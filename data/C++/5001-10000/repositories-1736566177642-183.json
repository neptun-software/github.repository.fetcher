{
  "metadata": {
    "timestamp": 1736566177642,
    "page": 183,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "goldendict/goldendict",
      "stars": 6035,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.4677734375,
          "content": "*.o\n*~\n\nmouseover_win32/*.dll\nmouseover_win32/*.a\n\nlocale/*.qm\ndebug/\nbuild/\nrelease/\ntmp/\ngoldendict\nwinlibs/lib32-48/\n\nMakefile\nMakefile.Debug\nMakefile.Release\n\ngoldendict.pro.user\ngoldendict.pro.user.*\nhotkeys.pro.user\nhotkeys.pro.user.*\nobject_script.goldendict.Debug\nobject_script.goldendict.Release\n\nversion.txt\n\n.gitattributes\n\n/goldendict.app/\n/GoldenDict.app/\n*.dmg\n\n.DS_Store\nInfo.plist\nGoldenDict.xcodeproj/\n\n# visual studio files\n*.sdf\n*.opensdf\n*.suo\n*.vcxproj.user\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 2.111328125,
          "content": "language: cpp\ncompiler: gcc\nsudo: require\ndist: xenial\n\nbefore_install:\n  # sudo add-apt-repository ppa:beineri/opt-qt593-trusty -y\n  - sudo apt-get update -qq\n\ninstall:\n  - |\n    sudo apt-get -y install git pkg-config build-essential qt5-qmake \\\n    libvorbis-dev zlib1g-dev libhunspell-dev x11proto-record-dev \\\n    qtdeclarative5-dev libqtwebkit-dev libxtst-dev liblzo2-dev libbz2-dev \\\n    libao-dev libavutil-dev libavformat-dev libswresample-dev libtiff5-dev libeb16-dev \\\n    libqt5webkit5-dev libqt5svg5-dev libqt5x11extras5-dev qttools5-dev \\\n    qttools5-dev-tools qtmultimedia5-dev libqt5multimedia5-plugins libopencc-dev liblzma-dev libzstd1-dev doxygen cmake\n  # source /opt/qt*/bin/qt*-env.sh\n\nscript:\n  - git clone https://github.com/BYVoid/OpenCC\n  - cd OpenCC/\n  - make PREFIX=/usr -j$(nproc)\n  - sudo make install\n  - cd ..\n  - qmake CONFIG+=release PREFIX=/usr CONFIG+=old_hunspell CONFIG+=zim_support # CONFIG+=chinese_conversion_support\n  - make -j$(nproc)\n  - make INSTALL_ROOT=appdir -j$(nproc) install ; find appdir/\n  - wget -c -nv \"https://github.com/probonopd/linuxdeployqt/releases/download/continuous/linuxdeployqt-continuous-x86_64.AppImage\"\n  - chmod a+x linuxdeployqt-continuous-x86_64.AppImage\n  - unset QTDIR; unset QT_PLUGIN_PATH ; unset LD_LIBRARY_PATH\n  - # Add ssl libraries to .Appimage\n  - mkdir -p appdir/usr/lib/\n  - cp /lib/x86_64-linux-gnu/libssl.so.1.0.0 appdir/usr/lib/\n  - cp /lib/x86_64-linux-gnu/libcrypto.so.1.0.0 appdir/usr/lib/\n  - #\n  - export VERSION=$(git rev-parse --short HEAD) # linuxdeployqt uses this for naming the file\n  - ./linuxdeployqt-continuous-x86_64.AppImage appdir/usr/share/applications/*.desktop -appimage\n\nafter_success:\n  - find appdir -executable -type f -exec ldd {} \\; | grep \" => /usr\" | cut -d \" \" -f 2-3 | sort | uniq\n  - # curl --upload-file GoldenDict*.AppImage https://transfer.sh/GoldenDict-git.$(git rev-parse --short HEAD)-x86_64.AppImage\n  - wget -c https://github.com/probonopd/uploadtool/raw/master/upload.sh\n  - bash upload.sh GoldenDict*.AppImage*\n  \nbranches:\n  except:\n    - # Do not build tags that we create when we upload to GitHub Releases\n    - /^(?i:continuous)/\n"
        },
        {
          "name": "CREDITS.txt",
          "type": "blob",
          "size": 2.3359375,
          "content": "﻿Konstantin Isakov <ikm\\goldendict.org>: Principal author of the program\nJennie Petoumenou <epetoumenou\\gmail.com>: Greek transliteration and Greek translation\nMindaugas Baranauskas <embar\\super.lt>: Lithuanian translation\nVit Pelcak <vit\\pelcak.org>: Czech translation\nHero Phương <herophuong93\\gmail.com> , Trần Đình Anh Tuấn <tuantda.vn\\gmail.com>: Vietnamese translation\nDaniele Di Pisa <daniele\\systems.it>: Italian translation\nDaniel Kaneider: German translation\nZhang Jinsong <zhangsong023\\gmail.com>: Simplified Chinese translation\nUsama Akkad <uahello\\gmail.com>, Linux Arab Community Team <linuxac.org>: Arabic translation\nKorostil Daniel <ted.korostiled\\gmail.com>: Ukrainian translation\nGrzegorz Karpowicz <greg.karpowicz\\gmail.com>: Polish translation\nNardog <alphisation\\gmail.com>: Japanese translation\nMaha 吳寶原, Ray Chou 周邦信, Marcus Bingenheimer, 黃文龍 <wlhunag\\gmail.com>: Traditional Chinese translation\nBesmir Godole <bgodole\\gmail.com>: Albanian translation\nLeonardo Montenegro <thesolidone\\gmail.com>, MCHAL <MCHAL@anomail.de>, Alexandro Casanova <shorterfire\\gmail.com>: Brazilian Portuguese translation\nJulian Depetris Chauvin <jdepetris\\gmail.com>: Interface enhancements\nYanina Weingast <yjweingast\\gmail.com>: Argentinian Spanish translation\nTvangeste <i.4m.l33t\\yandex.ru>: Interface enhancements\nZdenko Podobný <zdenop\\gmail.com>: Slovak translation\nFerenc Kempelen <lion\\netngine.hu>: Hungarian translation\nŞükrü Yekta Karabulut <sukruyekta\\gmail.com>: Turkish translation\nAmos Batto <amosbatto\\yahoo.com>: Quechua, Aymara and Bolivian Spanish translations\nCarlos A. Cortijo Bon <carlos_cortijo\\yahoo.com>: Spanish from Spain translation\nVictor Ibragimov <victor.ibragimov\\gmail.com>: Tajik translation\nMaksim Tamkovič <quendimax\\gmail.com>: Belarusian translation and transliteration\nVirtualTam <virtualtam\\myopera.com>: French translation\nPanho Ku <maranamho\\gmail.com>: Korean translation\nТим Перце <kreativnooko\\gmail.com>: Serbian translation\nCris van Minnen: Dutch translation\nTimon Wong <timon86.wang\\gmail.com>: MDict (*.mdx/*.mdd) dictionary format\nPICTT Turkmenistan: Turkmen translation\nNasrollah Noori <nanopqr@gmail.com>: Persian translation\nVladimir Gerovski: Macedonian Translation\nNikolay Korotkiy <sikmir\\gmail.com>: Finnish translation\nRobin Townsend: Lojban translation\nJoan Montané: Catalan translation\n"
        },
        {
          "name": "GoldenDict.exe.manifest",
          "type": "blob",
          "size": 0.5927734375,
          "content": "<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">\n  <trustInfo xmlns=\"urn:schemas-microsoft-com:asm.v3\">\n    <security>\n      <requestedPrivileges>\n        <requestedExecutionLevel level=\"asInvoker\" uiAccess=\"false\"></requestedExecutionLevel>\n      </requestedPrivileges>\n    </security>\n  </trustInfo>\n  <dependency>\n    <dependentAssembly>\n      <assemblyIdentity type=\"win32\" name=\"Microsoft.Windows.Common-Controls\" version=\"6.0.0.0\" publicKeyToken=\"6595b64144ccf1df\" language=\"*\" processorArchitecture=\"*\"></assemblyIdentity>\n    </dependentAssembly>\n  </dependency>\n</assembly>"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 34.8896484375,
          "content": "    GoldenDict, a dictionary lookup program.\n    Copyright (C) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    The text of the license follows.\n\n\n\t\t    GNU GENERAL PUBLIC LICENSE\n\t\t       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n\t\t\t    Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n\t\t       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n \n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n  \n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n\t\t     END OF TERMS AND CONDITIONS\n\n\t    How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<http://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<http://www.gnu.org/philosophy/why-not-lgpl.html>.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.8955078125,
          "content": "## Introduction\n\n<b>GoldenDict</b> is a feature-rich dictionary lookup program, supporting multiple dictionary formats (StarDict/Babylon/Lingvo/Dictd/AARD/MDict/SDict) and online dictionaries, featuring perfect article rendering with the complete markup, illustrations and other content retained, and allowing you to type in words without any accents or correct case.\n\n## Requirements\n\nThis code has been run and tested on Windows XP/Vista/7, Ubuntu Linux, Mac OS X.\n\n### External Deps\n\n* Make, GCC, Git\n* Qt framework. Minimum required version is 4.6. But Qt 4.7 or 4.8 is recommended.\n* Qt Creator IDE is recommended for development\n* Various libraries on Linux (png, zlib, etc)\n* On Mac and Windows all the libraries are already included in the repository\n\n### Installing External Deps on Ubuntu Linux\n\n    sudo apt-get install git pkg-config build-essential qt4-qmake \\\n         libvorbis-dev zlib1g-dev libhunspell-dev x11proto-record-dev \\\n         libqt4-dev libqtwebkit-dev libxtst-dev liblzo2-dev libbz2-dev \\\n         libao-dev libavutil-dev libavformat-dev libtiff5-dev libeb16-dev\n\n#### Installing External Deps on Ubuntu Linux for Qt5\n\n    sudo apt-get install git pkg-config build-essential qt5-qmake \\\n         libvorbis-dev zlib1g-dev libhunspell-dev x11proto-record-dev \\\n         qtdeclarative5-dev libxtst-dev liblzo2-dev libbz2-dev \\\n         libao-dev libavutil-dev libavformat-dev libtiff5-dev libeb16-dev \\\n         libqt5webkit5-dev libqt5svg5-dev libqt5x11extras5-dev qttools5-dev \\\n         qttools5-dev-tools qtmultimedia5-dev libqt5multimedia5-plugins\n\n## How to build\n\nFirst, clone this repository, e.g.:\n\n    git clone https://github.com/goldendict/goldendict.git\n\nAnd then invoke `qmake-qt4` and `make`:\n\n    cd goldendict && qmake-qt4 && make\n\nIn case when `qmake-qt4` does not exist, try using `qmake` but make sure it is indeed from the Qt 4 installation.\nOn the other hand, if you want to use `qt5`, make sure that `qmake` is from Qt 5 installation. If not, you can try\nfinding it at a path like `/usr/lib/x86_64-linux-gnu/qt5/bin/qmake`.\nAlternatively, you might want to load `goldendict.pro` file from within Qt Creator, especially on Windows.\n\nNote: To compile with `libhunspell` older than 1.5 pass `\"CONFIG+=old_hunspell\"` to `qmake`.\n\n### Building with Chinese conversion support\n\nTo add Chinese conversion support you need at first install libopencc-dev package:\n\n    sudo apt-get install libopencc-dev\n\nThen pass `\"CONFIG+=chinese_conversion_support\"` to `qmake`\n\n    qmake \"CONFIG+=chinese_conversion_support\"\n\n### Building with Zim dictionaries support\n\nTo add Zim and Slob formats support you need at first install lzma-dev and zstd-dev packages:\n\n    sudo apt-get install liblzma-dev libzstd-dev\n\nThen pass `\"CONFIG+=zim_support\"` to `qmake`\n\n    qmake \"CONFIG+=zim_support\"\n\n### Building without extra tiff handler\n\nIf you have problem building with libtiff5-dev package, you can pass\n`\"CONFIG+=no_extra_tiff_handler\"` to `qmake` in order to disable extra tiff support\n(without such extra support some b/w tiff images will not be displayed):\n\n    qmake \"CONFIG+=no_extra_tiff_handler\"\n\n### Building without Epwing format support\n\nIf you have problem building with libeb-dev package, you can pass\n`\"CONFIG+=no_epwing_support\"` to `qmake` in order to disable Epwing format support\n\n    qmake \"CONFIG+=no_epwing_support\"\n\n### Building without internal audio players\n\nIf you have problem building with FFmpeg/libao (for example, Ubuntu older than 12.04), you can pass\n`\"CONFIG+=no_ffmpeg_player\"` to `qmake` in order to disable FFmpeg+libao internal audio player back end:\n\n    qmake \"CONFIG+=no_ffmpeg_player\"\n\nIf you have problem building with Qt5 Multimedia or experience GStreamer run-time errors (for example, Ubuntu 14.04), you can pass\n`\"CONFIG+=no_qtmultimedia_player\"` to `qmake` in order to disable Qt Multimedia internal audio player back end:\n\n    qmake \"CONFIG+=no_qtmultimedia_player\"\n\n<b>NB:</b> All additional settings for `qmake` that you need must be combined in one `qmake` launch, for example:\n\n    qmake \"CONFIG+=zim_support\" \"CONFIG+=no_extra_tiff_handler\" \"CONFIG+=no_ffmpeg_player\"\n\n\nThen, invoke `make clean` before `make` because the setting change:\n\n    make clean && make\n\n### Building under Windows with MS Visual Studio\n\nTo build GoldenDict with Visual Studio take one of next library packs and unpack it to `\"winlibs/lib/msvc\"` folder in GoldenDict sources folder.  \n[GoldenDict_libs_VS2013_x86_v4.7z](http://www.mediafire.com/file/3il4vr1l8299nxn/GoldenDict_libs_VS2013_x86_v4.7z) - for MS Visual Studio 2013, 32 bit  \n[GoldenDict_libs_VS2013_x64_v4.7z](http://www.mediafire.com/file/2itgg8bafppg6lw/GoldenDict_libs_VS2013_x64_v4.7z) - for MS Visual Studio 2013, 64 bit  \n[GoldenDict_libs_VS2015_x86_v4.7z](http://www.mediafire.com/file/0a7ygy9rn99oevm/GoldenDict_libs_VS2015_x86_v4.7z) - for MS Visual Studio 2015, 32 bit  \n[GoldenDict_libs_VS2015_x64_v4.7z](http://www.mediafire.com/file/yoy2q8af0s1467m/GoldenDict_libs_VS2015_x64_v4.7z) - for MS Visual Studio 2015, 64 bit  \n\nTo create project files for Visual Studio you can pass `\"-tp vc\"` option to `qmake`.\n\nNote: In Qt 5.6.0 and later the `Webkit` module was removed from official release builds. You should build it from sources to compile GoldenDict.\n\n\n## Installation\n\nInstallation is an optional step since the built binary can be used as-is without installation. But you can properly install via:\n\n    make install\n\n<b>NB:</b> Don't do that on Windows!\n\nYou can uninstall via:\n\n    make uninstall\n\n## License\n\nThis project is licensed under the <b>GNU GPLv3+</b> license, a copy of which can be found in the `LICENSE.txt` file.\n\n## Support\n\nUsers looking for support should file an issue in the official [GoldenDict issue tracker](https://github.com/goldendict/goldendict/issues),\nor even better: submit a [pull request](https://github.com/goldendict/goldendict/pulls) if you have a fix available.\nGeneral questions should be asked on the [official GoldenDict forum](http://goldendict.org/forum/).\n"
        },
        {
          "name": "aard.cc",
          "type": "blob",
          "size": 31.8828125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"aard.hh\"\n#include \"btreeidx.hh\"\n#include \"folding.hh\"\n#include \"utf8.hh\"\n#include \"chunkedstorage.hh\"\n#include \"langcoder.hh\"\n#include \"fsencoding.hh\"\n#include \"decompress.hh\"\n#include \"gddebug.hh\"\n#include \"ftshelpers.hh\"\n#include \"htmlescape.hh\"\n\n#include <map>\n#include <set>\n#include <string>\n\n#ifdef _MSC_VER\n#include <stub_msvc.h>\n#endif\n\n#include <QString>\n#include <QSemaphore>\n#include <QThreadPool>\n#include <QAtomicInt>\n#include <QDomDocument>\n#include <QtEndian>\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n#include <QRegularExpression>\n#endif\n\n#include \"ufile.hh\"\n#include \"wstring_qt.hh\"\n#include \"qt4x5.hh\"\n\nnamespace Aard {\n\nusing std::map;\nusing std::multimap;\nusing std::pair;\nusing std::set;\nusing std::string;\nusing gd::wstring;\n\nusing BtreeIndexing::WordArticleLink;\nusing BtreeIndexing::IndexedWords;\nusing BtreeIndexing::IndexInfo;\n\nnamespace {\n\nDEF_EX_STR( exNotAardFile, \"Not an AARD file\", Dictionary::Ex )\nDEF_EX_STR( exCantReadFile, \"Can't read file\", Dictionary::Ex )\nDEF_EX_STR( exWordIsTooLarge, \"Enountered a word that is too large:\", Dictionary::Ex )\nDEF_EX_STR( exSuddenEndOfFile, \"Sudden end of file\", Dictionary::Ex )\n\n#pragma pack( push, 1 )\n\n/// AAR file header\nstruct AAR_header\n{\n    char signature[4];\n    char checksum[40];\n    quint16 version;\n    char uuid[16];\n    quint16 volume;\n    quint16 totalVolumes;\n    quint32 metaLength;\n    quint32 wordsCount;\n    quint32 articleOffset;\n    char indexItemFormat[4];\n    char keyLengthFormat[2];\n    char articleLengthFormat[2];\n}\n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\nstruct IndexElement\n{\n    quint32 wordOffset;\n    quint32 articleOffset;\n}\n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\nstruct IndexElement64\n{\n    quint32 wordOffset;\n    quint64 articleOffset;\n}\n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\nenum\n{\n  Signature = 0x58524141, // AARX on little-endian, XRAA on big-endian\n  CurrentFormatVersion = 4 + BtreeIndexing::FormatVersion + Folding::Version\n};\n\nstruct IdxHeader\n{\n  quint32 signature; // First comes the signature, AARX\n  quint32 formatVersion; // File format version (CurrentFormatVersion)\n  quint32 chunksOffset; // The offset to chunks' storage\n  quint32 indexBtreeMaxElements; // Two fields from IndexInfo\n  quint32 indexRootOffset;\n  quint32 wordCount;\n  quint32 articleCount;\n  quint32 langFrom;  // Source language\n  quint32 langTo;    // Target language\n}\n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\n#pragma pack( pop )\n\nbool indexIsOldOrBad( string const & indexFile )\n{\n  File::Class idx( indexFile, \"rb\" );\n\n  IdxHeader header;\n\n  return idx.readRecords( &header, sizeof( header ), 1 ) != 1 ||\n         header.signature != Signature ||\n         header.formatVersion != CurrentFormatVersion;\n}\n\nvoid readJSONValue( string const & source, string & str, string::size_type & pos)\n{\n    int level = 1;\n    char endChar;\n    str.push_back( source[pos] );\n    if( source[pos] == '{')\n        endChar = '}';\n    else if( source[pos] == '[' )\n        endChar = ']';\n    else if( source[pos] == '\\\"' )\n    {\n        str.clear();\n        endChar = '\\\"';\n    }\n    else\n        endChar = ',';\n\n    pos++;\n    char ch = 0;\n    char lastCh = 0;\n    while( !( ch == endChar && lastCh != '\\\\' && level == 0 )\n           && pos < source.size() )\n    {\n        lastCh = ch;\n        ch = source[ pos++ ];\n        if( ( ch == '{' || ch == '[' ) && lastCh != '\\\\' )\n          level++;\n        if( ( ch == '}' || ch == ']' ) && lastCh != '\\\\' )\n          level--;\n\n        if( ch == endChar &&\n            ( ( ch == '\\\"' && lastCh != '\\\\' ) || ch == ',' )\n            && level == 1)\n          break;\n        str.push_back( ch );\n    }\n}\n\nmap< string, string > parseMetaData( string const & metaData )\n{\n// Parsing JSON string\n    map< string, string > data;\n    string name, value;\n    string::size_type n = 0;\n\n    while( n < metaData.length() && metaData[n] != '{' )\n        n++;\n    while( n < metaData.length() )\n    {\n        // Skip to '\"'\n        while( n < metaData.length() && metaData[n] != '\\\"' )\n            n++;\n        if( ++n >= metaData.length() )\n            break;\n\n        // Read name\n        while(  n < metaData.length() &&\n                !( ( metaData[n] == '\\\"' || metaData[n] == '{' ) && metaData[n-1] != '\\\\' ) )\n            name.push_back( metaData[n++]);\n\n        // Skip to ':'\n        if( ++n >= metaData.length() )\n            break;\n        while( n < metaData.length() && metaData[n] != ':' )\n            n++;\n        if( ++n >= metaData.length() )\n            break;\n\n        // Find value start after ':'\n        while( n < metaData.length()\n               && !( ( metaData[n] == '\\\"'\n                       || metaData[n] == '{'\n                       || metaData[n] == '['\n                       || ( metaData[n] >= '0' && metaData[n] <= '9' ) )\n               && metaData[n-1] != '\\\\' ) )\n            n++;\n        if( n >= metaData.length() )\n            break;\n\n        readJSONValue( metaData, value, n);\n\n        data[name] = value;\n\n        name.clear();\n        value.clear();\n        if( ++n >= metaData.length() )\n            break;\n    }\n    return data;\n}\n\nclass AardDictionary: public BtreeIndexing::BtreeDictionary\n{\n    Mutex idxMutex;\n    Mutex aardMutex;\n    File::Class idx;\n    IdxHeader idxHeader;\n    ChunkedStorage::Reader chunks;\n    string dictionaryName;\n    File::Class df;\n\n  public:\n\n    AardDictionary( string const & id, string const & indexFile,\n                     vector< string > const & dictionaryFiles );\n\n    ~AardDictionary();\n\n    virtual string getName() throw()\n    { return dictionaryName; }\n\n    virtual map< Dictionary::Property, string > getProperties() throw()\n    { return map< Dictionary::Property, string >(); }\n\n    virtual unsigned long getArticleCount() throw()\n    { return idxHeader.articleCount; }\n\n    virtual unsigned long getWordCount() throw()\n    { return idxHeader.wordCount; }\n\n    inline virtual quint32 getLangFrom() const\n    { return idxHeader.langFrom; }\n\n    inline virtual quint32 getLangTo() const\n    { return idxHeader.langTo; }\n\n    virtual sptr< Dictionary::DataRequest > getArticle( wstring const &,\n                                                        vector< wstring > const & alts,\n                                                        wstring const &,\n                                                        bool ignoreDiacritics )\n      THROW_SPEC( std::exception );\n\n    virtual QString const& getDescription();\n\n    virtual sptr< Dictionary::DataRequest > getSearchResults( QString const & searchString,\n                                                              int searchMode, bool matchCase,\n                                                              int distanceBetweenWords,\n                                                              int maxResults,\n                                                              bool ignoreWordsOrder,\n                                                              bool ignoreDiacritics,\n                                                              QThreadPool * ftsThreadPoolPtr );\n    virtual void getArticleText( uint32_t articleAddress, QString & headword, QString & text );\n\n    virtual void makeFTSIndex(QAtomicInt & isCancelled, bool firstIteration );\n\n    virtual void setFTSParameters( Config::FullTextSearch const & fts )\n    {\n      can_FTS = fts.enabled\n                && !fts.disabledTypes.contains( \"AARD\", Qt::CaseInsensitive )\n                && ( fts.maxDictionarySize == 0 || getArticleCount() <= fts.maxDictionarySize );\n    }\n\nprotected:\n\n    virtual void loadIcon() throw();\n\nprivate:\n\n    /// Loads the article.\n    void loadArticle( quint32 address,\n                      string & articleText,\n                      bool rawText = false );\n    string convert( string const & in_data );\n\n    friend class AardArticleRequest;\n};\n\nAardDictionary::AardDictionary( string const & id,\n                                string const & indexFile,\n                                vector< string > const & dictionaryFiles ):\n    BtreeDictionary( id, dictionaryFiles ),\n    idx( indexFile, \"rb\" ),\n    idxHeader( idx.read< IdxHeader >() ),\n    chunks( idx, idxHeader.chunksOffset ),\n    df( dictionaryFiles[ 0 ], \"rb\" )\n{\n    // Read dictionary name\n\n    idx.seek( sizeof( idxHeader ) );\n    vector< char > dName( idx.read< quint32 >() );\n    if( dName.size() )\n    {\n        idx.read( &dName.front(), dName.size() );\n        dictionaryName = string( &dName.front(), dName.size() );\n    }\n\n    // Initialize the index\n\n    openIndex( IndexInfo( idxHeader.indexBtreeMaxElements,\n                          idxHeader.indexRootOffset ),\n               idx, idxMutex );\n\n    // Full-text search parameters\n\n    can_FTS = true;\n\n    ftsIdxName = indexFile + \"_FTS\";\n\n    if( !Dictionary::needToRebuildIndex( dictionaryFiles, ftsIdxName )\n        && !FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) )\n      FTS_index_completed.ref();\n}\n\nAardDictionary::~AardDictionary()\n{\n    df.close();\n}\n\nvoid AardDictionary::loadIcon() throw()\n{\n  if ( dictionaryIconLoaded )\n    return;\n\n  QString fileName =\n    QDir::fromNativeSeparators( FsEncoding::decode( getDictionaryFilenames()[ 0 ].c_str() ) );\n\n  // Remove the extension\n  fileName.chop( 3 );\n\n  if( !loadIconFromFile( fileName ) )\n  {\n    // Load failed -- use default icons\n    dictionaryNativeIcon = dictionaryIcon = QIcon(\":/icons/icon32_aard.png\");\n  }\n\n  dictionaryIconLoaded = true;\n}\n\nstring AardDictionary::convert( const string & in )\n{\n    string inConverted;\n    char inCh, lastCh = 0;\n    bool afterEol = false;\n\n    for( string::const_iterator i = in.begin(), j = in.end(); i != j; ++i )\n    {\n        inCh = *i;\n        if( lastCh == '\\\\' )\n        {\n            inConverted.erase( inConverted.size() - 1 );\n            lastCh = 0;\n            if( inCh == 'n' )\n            {\n                inConverted.append( \"<br/>\");\n                afterEol = true;\n                continue;\n            }\n            else if( inCh == 'r')\n                continue;\n        }\n        else if( inCh == ' ' && afterEol )\n        {\n            inConverted.append( \"&nbsp;\" );\n            continue;\n        } else\n            lastCh = inCh;\n        afterEol = false;\n        inConverted.push_back( inCh );\n    }\n\n    QString text = QString::fromUtf8( inConverted.c_str() );\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n    text.replace( QRegularExpression( \"<\\\\s*a\\\\s+href\\\\s*=\\\\s*\\\\\\\"(w:|s:){0,1}([^#](?!ttp://)[^\\\\\\\"]*)(.)\",\n                                      QRegularExpression::DotMatchesEverythingOption ),\n                  \"<a href=\\\"bword:\\\\2\\\"\");\n    text.replace( QRegularExpression( \"<\\\\s*a\\\\s+href\\\\s*=\\\\s*'(w:|s:){0,1}([^#](?!ttp://)[^']*)(.)\",\n                                      QRegularExpression::DotMatchesEverythingOption ),\n                  \"<a href=\\\"bword:\\\\2\\\"\");\n\n    // Anchors\n    text.replace( QRegularExpression( \"<a\\\\s+href=\\\"bword:([^#\\\"]+)#([^\\\"]+)\" ),\n                  \"<a href=\\\"gdlookup://localhost/\\\\1?gdanchor=\\\\2\" );\n\n    static QRegularExpression self_closing_divs( \"(<div\\\\s+[^>]*)/>\",\n                                                 QRegularExpression::CaseInsensitiveOption );  // <div ... />\n    text.replace( self_closing_divs, \"\\\\1></div>\" );\n#else\n    text.replace( QRegExp( \"<\\\\s*a\\\\s+href\\\\s*=\\\\s*\\\\\\\"(w:|s:){0,1}([^#](?!ttp://)[^\\\\\\\"]*)(.)\" ),\n                  \"<a href=\\\"bword:\\\\2\\\"\");\n    text.replace( QRegExp( \"<\\\\s*a\\\\s+href\\\\s*=\\\\s*'(w:|s:){0,1}([^#](?!ttp://)[^']*)(.)\" ),\n                  \"<a href=\\\"bword:\\\\2\\\"\");\n\n    // Anchors\n    text.replace( QRegExp( \"<a\\\\s+href=\\\"bword:([^#\\\"]+)#([^\\\"]+)\" ),\n                  \"<a href=\\\"gdlookup://localhost/\\\\1?gdanchor=\\\\2\" );\n\n    static QRegExp self_closing_divs( \"(<div\\\\s[^>]*)/>\", Qt::CaseInsensitive );  // <div ... />\n    text.replace( self_closing_divs, \"\\\\1></div>\" );\n#endif\n\n    // Fix outstanding elements\n    text += \"<br style=\\\"clear:both;\\\" />\";\n\n    return text.toUtf8().data();\n}\n\nvoid AardDictionary::loadArticle( quint32 address,\n                                  string & articleText,\n                                  bool rawText )\n{\n    quint32 articleOffset = address;\n    quint32 articleSize;\n    quint32 size;\n\n    vector< char > articleBody;\n\n    articleText.clear();\n\n\n    while( 1 )\n    {\n      articleText = string( QObject::tr( \"Article loading error\" ).toUtf8().constData() );\n      try\n      {\n        Mutex::Lock _( aardMutex );\n        df.seek( articleOffset );\n        df.read( &size, sizeof(size) );\n        articleSize = qFromBigEndian( size );\n\n        // Don't try to read and decode too big articles,\n        // it is most likely error in dictionary\n        if( articleSize > 1048576 )\n          break;\n\n        articleBody.resize( articleSize );\n        df.read( &articleBody.front(), articleSize );\n      }\n      catch( std::exception &ex )\n      {\n        gdWarning( \"AARD: Failed loading article from \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n        break;\n      }\n      catch(...)\n      {\n        break;\n      }\n\n      if ( articleBody.empty() )\n        break;\n\n      articleText.clear();\n\n      string text = decompressBzip2( articleBody.data(), articleSize );\n      if( text.empty() )\n        text = decompressZlib( articleBody.data(), articleSize );\n      if( text.empty() )\n        text = string( articleBody.data(), articleSize );\n\n      if( text.empty() || text[ 0 ] != '[' )\n        break;\n\n      string::size_type n = text.find( '\\\"' );\n      if( n == string::npos )\n        break;\n\n      readJSONValue( text, articleText, n );\n\n      if( articleText.empty() )\n      {\n        n = text.find( \"\\\"r\\\"\" );\n        if( n != string::npos && n + 3 < text.size() )\n        {\n          n = text.find( '\\\"', n + 3 );\n          if( n == string::npos )\n            break;\n\n          string link;\n          readJSONValue( text, link, n );\n          if( !link.empty() )\n          {\n            string encodedLink;\n            encodedLink.reserve( link.size() );\n            bool prev = false;\n            for( string::const_iterator i = link.begin(); i != link.end(); ++i )\n            {\n              if( *i == '\\\\' )\n              {\n                if( !prev )\n                {\n                  prev = true;\n                  continue;\n                }\n              }\n              encodedLink.push_back( *i );\n              prev = false;\n            }\n            encodedLink = string( QUrl( QString::fromUtf8( encodedLink.data(), encodedLink.size() ) ).toEncoded().data() );\n            articleText = \"<a href=\\\"\" + encodedLink + \"\\\">\" + link + \"</a>\";\n          }\n        }\n      }\n\n      break;\n    }\n\n    if( !articleText.empty() )\n    {\n      if( rawText )\n        return;\n\n      articleText = convert( articleText );\n    }\n    else\n      articleText = string( QObject::tr( \"Article decoding error\" ).toUtf8().constData() );\n\n    // See Issue #271: A mechanism to clean-up invalid HTML cards.\n    string cleaner = \"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\n                     \"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\n                     \"</b></b></b></b></b></b></b></b>\"\n                     \"</i></i></i></i></i></i></i></i>\"\n                     \"</a></a></a></a></a></a></a></a>\";\n\n    string prefix( \"<div class=\\\"aard\\\"\" );\n    if( isToLanguageRTL() )\n      prefix += \" dir=\\\"rtl\\\"\";\n    prefix += \">\";\n\n    articleText = prefix + articleText + cleaner + \"</div>\";\n}\n\nQString const& AardDictionary::getDescription()\n{\n    if( !dictionaryDescription.isEmpty() )\n        return dictionaryDescription;\n\n    AAR_header dictHeader;\n    quint32 size;\n    vector< char > data;\n\n    {\n        Mutex::Lock _( aardMutex );\n        df.seek( 0 );\n        df.read( &dictHeader, sizeof(dictHeader) );\n        size = qFromBigEndian( dictHeader.metaLength );\n        data.resize( size );\n        df.read( &data.front(), size );\n    }\n\n    string metaStr = decompressBzip2( data.data(), size );\n    if( metaStr.empty() )\n        metaStr = decompressZlib( data.data(), size );\n\n    map< string, string > meta = parseMetaData( metaStr );\n\n    if( !meta.empty() )\n    {\n        map< string, string >::const_iterator iter = meta.find( \"copyright\" );\n        if( iter != meta.end() )\n          dictionaryDescription = QString( QObject::tr( \"Copyright: %1%2\" ) ).arg( QString::fromUtf8( iter->second.c_str() ) ).arg( \"\\n\\n\" );\n\n        iter = meta.find( \"version\" );\n        if( iter != meta.end() )\n          dictionaryDescription = QString( QObject::tr( \"Version: %1%2\" ) ).arg( QString::fromUtf8( iter->second.c_str() ) ).arg( \"\\n\\n\" );\n\n        iter = meta.find( \"description\" );\n        if( iter != meta.end() )\n        {\n          QString desc = QString::fromUtf8( iter->second.c_str() );\n          desc.replace( \"\\\\n\", \"\\n\" );\n          desc.replace( \"\\\\t\", \"\\t\" );\n          dictionaryDescription += desc;\n        }\n    }\n\n    if( dictionaryDescription.isEmpty() )\n      dictionaryDescription = \"NONE\";\n\n    return dictionaryDescription;\n}\n\nvoid AardDictionary::makeFTSIndex( QAtomicInt & isCancelled, bool firstIteration )\n{\n  if( !( Dictionary::needToRebuildIndex( getDictionaryFilenames(), ftsIdxName )\n         || FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) ) )\n    FTS_index_completed.ref();\n\n  if( haveFTSIndex() )\n    return;\n\n  if( ensureInitDone().size() )\n    return;\n\n  if( firstIteration && getArticleCount() > FTS::MaxDictionarySizeForFastSearch )\n    return;\n\n  gdDebug( \"Aard: Building the full-text index for dictionary: %s\\n\",\n           getName().c_str() );\n\n  try\n  {\n    FtsHelpers::makeFTSIndex( this, isCancelled );\n    FTS_index_completed.ref();\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"Aard: Failed building full-text search index for \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n    QFile::remove( FsEncoding::decode( ftsIdxName.c_str() ) );\n  }\n}\n\nvoid AardDictionary::getArticleText( uint32_t articleAddress, QString & headword, QString & text )\n{\n  try\n  {\n    headword.clear();\n    string articleText;\n\n    loadArticle( articleAddress, articleText );\n\n    text = Html::unescape( QString::fromUtf8( articleText.data(), articleText.size() ) );\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"Aard: Failed retrieving article from \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n  }\n}\n\nsptr< Dictionary::DataRequest > AardDictionary::getSearchResults( QString const & searchString,\n                                                                  int searchMode, bool matchCase,\n                                                                  int distanceBetweenWords,\n                                                                  int maxResults,\n                                                                  bool ignoreWordsOrder,\n                                                                  bool ignoreDiacritics,\n                                                                  QThreadPool * ftsThreadPoolPtr )\n{\n  return new FtsHelpers::FTSResultsRequest( *this, searchString,searchMode, matchCase, distanceBetweenWords, maxResults, ignoreWordsOrder, ignoreDiacritics, ftsThreadPoolPtr );\n}\n\n/// AardDictionary::getArticle()\n\nclass AardArticleRequest;\n\nclass AardArticleRequestRunnable: public QRunnable\n{\n  AardArticleRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  AardArticleRequestRunnable( AardArticleRequest & r_,\n                              QSemaphore & hasExited_ ): r( r_ ),\n                                                         hasExited( hasExited_ )\n  {}\n\n  ~AardArticleRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass AardArticleRequest: public Dictionary::DataRequest\n{\n  friend class AardArticleRequestRunnable;\n\n  wstring word;\n  vector< wstring > alts;\n  AardDictionary & dict;\n  bool ignoreDiacritics;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  AardArticleRequest( wstring const & word_,\n                      vector< wstring > const & alts_,\n                      AardDictionary & dict_, bool ignoreDiacritics_ ):\n    word( word_ ), alts( alts_ ), dict( dict_ ), ignoreDiacritics( ignoreDiacritics_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new AardArticleRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by DslArticleRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~AardArticleRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid AardArticleRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid AardArticleRequest::run()\n{\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  vector< WordArticleLink > chain = dict.findArticles( word, ignoreDiacritics );\n\n  for( unsigned x = 0; x < alts.size(); ++x )\n  {\n    /// Make an additional query for each alt\n\n    vector< WordArticleLink > altChain = dict.findArticles( alts[ x ], ignoreDiacritics );\n\n    chain.insert( chain.end(), altChain.begin(), altChain.end() );\n  }\n\n  multimap< wstring, pair< string, string > > mainArticles, alternateArticles;\n\n  set< quint32 > articlesIncluded; // Some synonims make it that the articles\n                                    // appear several times. We combat this\n                                    // by only allowing them to appear once.\n\n  wstring wordCaseFolded = Folding::applySimpleCaseOnly( word );\n  if( ignoreDiacritics )\n    wordCaseFolded = Folding::applyDiacriticsOnly( wordCaseFolded );\n\n  for( unsigned x = 0; x < chain.size(); ++x )\n  {\n    if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    {\n      finish();\n      return;\n    }\n\n    if ( articlesIncluded.find( chain[ x ].articleOffset ) != articlesIncluded.end() )\n      continue; // We already have this article in the body.\n\n    // Now grab that article\n\n    string headword, articleText;\n\n    headword = chain[ x ].word;\n    try\n    {\n      dict.loadArticle( chain[ x ].articleOffset, articleText );\n    }\n    catch(...)\n    {\n    }\n\n    // Ok. Now, does it go to main articles, or to alternate ones? We list\n    // main ones first, and alternates after.\n\n    // We do the case-folded comparison here.\n\n    wstring headwordStripped =\n      Folding::applySimpleCaseOnly( Utf8::decode( headword ) );\n    if( ignoreDiacritics )\n      headwordStripped = Folding::applyDiacriticsOnly( headwordStripped );\n\n    multimap< wstring, pair< string, string > > & mapToUse =\n      ( wordCaseFolded == headwordStripped ) ?\n        mainArticles : alternateArticles;\n\n    mapToUse.insert( pair< wstring, pair< string, string > >(\n      Folding::applySimpleCaseOnly( Utf8::decode( headword ) ),\n      pair< string, string >( headword, articleText ) ) );\n\n    articlesIncluded.insert( chain[ x ].articleOffset );\n  }\n\n  if ( mainArticles.empty() && alternateArticles.empty() )\n  {\n    // No such word\n    finish();\n    return;\n  }\n\n  string result;\n\n  multimap< wstring, pair< string, string > >::const_iterator i;\n\n  for( i = mainArticles.begin(); i != mainArticles.end(); ++i )\n  {\n      result += \"<h3>\";\n      result += i->second.first;\n      result += \"</h3>\";\n      result += i->second.second;\n  }\n\n  for( i = alternateArticles.begin(); i != alternateArticles.end(); ++i )\n  {\n      result += \"<h3>\";\n      result += i->second.first;\n      result += \"</h3>\";\n      result += i->second.second;\n  }\n\n  Mutex::Lock _( dataMutex );\n\n  data.resize( result.size() );\n\n  memcpy( &data.front(), result.data(), result.size() );\n\n  hasAnyData = true;\n\n  finish();\n}\n\nsptr< Dictionary::DataRequest > AardDictionary::getArticle( wstring const & word,\n                                                            vector< wstring > const & alts,\n                                                            wstring const &,\n                                                            bool ignoreDiacritics )\n  THROW_SPEC( std::exception )\n{\n  return new AardArticleRequest( word, alts, *this, ignoreDiacritics );\n}\n\n} // anonymous namespace\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing & initializing,\n                                      unsigned maxHeadwordsToExpand )\n  THROW_SPEC( std::exception )\n{\n  vector< sptr< Dictionary::Class > > dictionaries;\n\n  for( vector< string >::const_iterator i = fileNames.begin(); i != fileNames.end();\n       ++i )\n  {\n      // Skip files with the extensions different to .aar to speed up the\n      // scanning\n      if ( i->size() < 4 ||\n          strcasecmp( i->c_str() + ( i->size() - 4 ), \".aar\" ) != 0 )\n        continue;\n\n      // Got the file -- check if we need to rebuid the index\n\n      vector< string > dictFiles( 1, *i );\n\n      string dictId = Dictionary::makeDictionaryId( dictFiles );\n\n      string indexFile = indicesDir + dictId;\n\n      if ( Dictionary::needToRebuildIndex( dictFiles, indexFile ) ||\n           indexIsOldOrBad( indexFile ) )\n      {\n        try\n        {\n\n          gdDebug( \"Aard: Building the index for dictionary: %s\\n\", i->c_str() );\n\n          {\n            QFileInfo info( FsEncoding::decode( i->c_str() ) );\n            if( static_cast< quint64 >( info.size() ) > ULONG_MAX )\n            {\n              gdWarning( \"File %s is too large\\n\", i->c_str() );\n              continue;\n            }\n          }\n\n          File::Class df( *i, \"rb\" );\n\n          AAR_header dictHeader;\n\n          df.read( &dictHeader, sizeof(dictHeader) );\n          bool has64bitIndex = !strncmp( dictHeader.indexItemFormat, \">LQ\", 4 );\n          if( strncmp( dictHeader.signature, \"aard\", 4 )\n              || ( !has64bitIndex && strncmp( dictHeader.indexItemFormat, \">LL\", 4 ) )\n              || strncmp( dictHeader.keyLengthFormat, \">H\", 2 )\n              || strncmp( dictHeader.articleLengthFormat, \">L\", 2) )\n          {\n              gdWarning( \"File %s is not in supported aard format\\n\", i->c_str() );\n              continue;\n          }\n\n          vector< char > data;\n          quint32 size = qFromBigEndian( dictHeader.metaLength );\n\n          if( size == 0 )\n          {\n              gdWarning( \"File %s has invalid metadata\", i->c_str() );\n              continue;\n          }\n\n          data.resize( size );\n          df.read( &data.front(), size );\n          string metaStr = decompressBzip2( data.data(), size );\n          if( metaStr.empty() )\n              metaStr = decompressZlib( data.data(), size );\n\n          map< string, string > meta = parseMetaData( metaStr );\n\n          if( meta.empty() )\n          {\n              gdWarning( \"File %s has invalid metadata\", i->c_str() );\n              continue;\n          }\n\n          string dictName;\n          map< string, string >::const_iterator iter = meta.find( \"title\" );\n          if( iter != meta.end() )\n              dictName = iter->second;\n\n          string langFrom;\n          iter = meta.find( \"index_language\" );\n          if( iter != meta.end() )\n              langFrom = iter->second;\n\n          string langTo;\n          iter = meta.find( \"article_language\" );\n          if( iter != meta.end() )\n              langTo = iter->second;\n\n          if( ( dictName.compare( \"Wikipedia\") == 0 || dictName.compare( \"Wikiquote\" ) == 0 || dictName.compare( \"Wiktionary\" ) == 0 )\n              && !langTo.empty() )\n          {\n            string capitalized = langTo.c_str();\n            capitalized[0] = toupper( capitalized[0] );\n            dictName = dictName + \" (\" + capitalized + \")\";\n          }\n\n          quint16 volumes = qFromBigEndian( dictHeader.totalVolumes );\n          if( volumes > 1 )\n          {\n            QString const ss = QString( \" (%1/%2)\" ).arg( qFromBigEndian( dictHeader.volume ) ).arg( volumes );\n            dictName += ss.toLocal8Bit().data();\n          }\n\n          initializing.indexingDictionary( dictName );\n\n          File::Class idx( indexFile, \"wb\" );\n          IdxHeader idxHeader;\n          memset( &idxHeader, 0, sizeof( idxHeader ) );\n\n          // We write a dummy header first. At the end of the process the header\n          // will be rewritten with the right values.\n\n          idx.write( idxHeader );\n\n          idx.write( (quint32) dictName.size() );\n          if( !dictName.empty() )\n              idx.write( dictName.data(), dictName.size() );\n\n          IndexedWords indexedWords;\n\n          ChunkedStorage::Writer chunks( idx );\n\n          quint32 wordCount = qFromBigEndian( dictHeader.wordsCount );\n          set< quint32 > articleOffsets;\n\n          quint32 pos = df.tell();\n          quint32 wordsBase = pos + wordCount * ( has64bitIndex ? sizeof( IndexElement64 ) : sizeof( IndexElement ) );\n          quint32 articlesBase = qFromBigEndian( dictHeader.articleOffset );\n\n          data.clear();\n          for( quint32 j = 0; j < wordCount; j++ )\n          {\n            quint32 articleOffset;\n            quint32 wordOffset;\n\n            if( has64bitIndex )\n            {\n              IndexElement64 el64;\n\n              df.seek( pos );\n              df.read( &el64, sizeof(el64) );\n              articleOffset = articlesBase + qFromBigEndian( el64.articleOffset );\n              wordOffset = wordsBase + qFromBigEndian( el64.wordOffset );\n            }\n            else\n            {\n              IndexElement el;\n\n              df.seek( pos );\n              df.read( &el, sizeof(el) );\n              articleOffset = articlesBase + qFromBigEndian( el.articleOffset );\n              wordOffset = wordsBase + qFromBigEndian( el.wordOffset );\n            }\n\n            df.seek( wordOffset );\n\n            quint16 sizeBE;\n            df.read( &sizeBE, sizeof(sizeBE) );\n            quint16 wordSize = qFromBigEndian( sizeBE );\n            if( data.size() < wordSize )\n              data.resize( wordSize );\n            df.read( &data.front(), wordSize );\n\n            if( articleOffsets.find( articleOffset ) == articleOffsets.end() )\n                articleOffsets.insert( articleOffset );\n\n            // Insert new entry\n            wstring word = Utf8::decode( string( data.data(), wordSize ) );\n            if( maxHeadwordsToExpand && dictHeader.wordsCount >= maxHeadwordsToExpand )\n              indexedWords.addSingleWord( word, articleOffset);\n            else\n              indexedWords.addWord( word, articleOffset);\n\n            pos += has64bitIndex ? sizeof( IndexElement64 ) : sizeof( IndexElement );\n          }\n          data.clear();\n\n          idxHeader.articleCount = articleOffsets.size();\n          articleOffsets.clear();\n\n          // Finish with the chunks\n\n          idxHeader.chunksOffset = chunks.finish();\n\n          // Build index\n\n          IndexInfo idxInfo = BtreeIndexing::buildIndex( indexedWords, idx );\n\n          idxHeader.indexBtreeMaxElements = idxInfo.btreeMaxElements;\n          idxHeader.indexRootOffset = idxInfo.rootOffset;\n\n          indexedWords.clear(); // Release memory -- no need for this data\n\n          // That concludes it. Update the header.\n\n          idxHeader.signature = Signature;\n          idxHeader.formatVersion = CurrentFormatVersion;\n\n          idxHeader.wordCount = wordCount;\n\n          if( langFrom.size() == 3)\n              idxHeader.langFrom = LangCoder::findIdForLanguageCode3( langFrom.c_str() );\n          else if( langFrom.size() == 2 )\n              idxHeader.langFrom = LangCoder::code2toInt( langFrom.c_str() );\n\n          if( langTo.size() == 3)\n              idxHeader.langTo = LangCoder::findIdForLanguageCode3( langTo.c_str() );\n          else if( langTo.size() == 2 )\n              idxHeader.langTo = LangCoder::code2toInt( langTo.c_str() );\n\n          idx.rewind();\n\n          idx.write( &idxHeader, sizeof( idxHeader ) );\n        }\n        catch( std::exception & e )\n        {\n          gdWarning( \"Aard dictionary indexing failed: %s, error: %s\\n\",\n                    i->c_str(), e.what() );\n          continue;\n        }\n        catch( ... )\n        {\n          gdWarning( \"Aard dictionary indexing failed\\n\" );\n          continue;\n        }\n      } // if need to rebuild\n      try\n      {\n        dictionaries.push_back( new AardDictionary( dictId,\n                                                    indexFile,\n                                                    dictFiles ) );\n      }\n      catch( std::exception & e )\n      {\n        gdWarning( \"Aard dictionary initializing failed: %s, error: %s\\n\",\n                  i->c_str(), e.what() );\n        continue;\n      }\n  }\n  return dictionaries;\n}\n\n}\n"
        },
        {
          "name": "aard.hh",
          "type": "blob",
          "size": 0.6845703125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __AARD_HH_INCLUDED__\n#define __AARD_HH_INCLUDED__\n\n#include \"dictionary.hh\"\n\n/// Support for the aard dictionaries.\nnamespace Aard {\n\nusing std::vector;\nusing std::string;\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing &,\n                                      unsigned maxHeadwordsToExpand )\n  THROW_SPEC( std::exception );\n\n}\n\n#endif\n"
        },
        {
          "name": "about.cc",
          "type": "blob",
          "size": 2.109375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"about.hh\"\n#include <QtGui>\n#include <QSysInfo>\n\n#include \"qt4x5.hh\"\n\nAbout::About( QWidget * parent ): QDialog( parent )\n{\n  ui.setupUi( this );\n\n  QFile versionFile( \":/version.txt\" );\n\n  QString version;\n\n  if ( !versionFile.open( QFile::ReadOnly ) )\n    version = tr( \"[Unknown]\" );\n  else\n    version = QString::fromLatin1( versionFile.readAll() ).trimmed();\n\n  ui.version->setText( version );\n\n#if defined (_MSC_VER)\n  QString compilerVersion = QString( \"Visual C++ %1.%2.%3\" )\n                               .arg( GD_CXX_MSVC_MAJOR )\n                               .arg( GD_CXX_MSVC_MINOR )\n                               .arg( GD_CXX_MSVC_BUILD );\n#elif defined (__clang__) && defined (__clang_version__)\n  QString compilerVersion = QLatin1String( \"Clang \" ) + QLatin1String( __clang_version__ );\n#else\n  QString compilerVersion = QLatin1String( \"GCC \" ) + QLatin1String( __VERSION__ );\n#endif\n\n  ui.qtVersion->setText( tr( \"Based on Qt %1 (%2, %3 bit)\" ).arg(\n                           QLatin1String( qVersion() ),\n                           compilerVersion,\n                           QString::number( QSysInfo::WordSize ) ) );\n\n  QFile creditsFile( \":/CREDITS.txt\" );\n\n  if ( creditsFile.open( QFile::ReadOnly ) )\n  {\n    QStringList creditsList =\n      QString::fromUtf8(\n        creditsFile.readAll() ).split( '\\n', Qt4x5::skipEmptyParts() );\n\n    QString html = \"<html><body style='color: black; background: #f4f4f4;'>\";\n\n    for( int x = 0; x < creditsList.size(); ++x )\n    {\n      QString str = creditsList[ x ];\n\n      str.replace( \"\\\\\", \"@\" );\n\n      str = Qt4x5::escape( str );\n\n      int colon = str.indexOf( \":\" );\n\n      if ( colon != -1 )\n      {\n        QString name( str.left( colon ) );\n\n        name.replace( \", \", \"<br>\" );\n\n        str = \"<font color='blue'>\" + name + \"</font><br>&nbsp;&nbsp;&nbsp;&nbsp;\"\n              + str.mid( colon + 1 );\n      }\n\n      html += str;\n      html += \"<br>\";\n    }\n\n    html += \"</body></html>\";\n\n    ui.credits->setHtml( html );\n  }\n}\n"
        },
        {
          "name": "about.hh",
          "type": "blob",
          "size": 0.8115234375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef ABOUT_HH\n#define ABOUT_HH\n\n#include \"ui_about.h\"\n#include <QDialog>\n\n// Microsoft Visual C++ version\n#if defined (_MSC_VER)\n   // how many digits does the build number have?\n#  if _MSC_FULL_VER / 10000 == _MSC_VER\n#    define GD_CXX_MSVC_BUILD (_MSC_FULL_VER % 10000)  // four digits\n#  elif _MSC_FULL_VER / 100000 == _MSC_VER\n#    define GD_CXX_MSVC_BUILD (_MSC_FULL_VER % 100000) // five digits\n#  else\n#    define GD_CXX_MSVC_BUILD 0\n#  endif\n#  define GD_CXX_MSVC_MAJOR (_MSC_VER/100-6)\n#  define GD_CXX_MSVC_MINOR (_MSC_VER%100)\n#endif\n\nclass About: public QDialog\n{\n  Q_OBJECT\npublic:\n\n  About( QWidget * parent = 0 );\n\nprivate:\n\n  Ui::About ui;\n};\n\n#endif // ABOUT_HH\n"
        },
        {
          "name": "about.ui",
          "type": "blob",
          "size": 5.1650390625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ui version=\"4.0\">\n <class>About</class>\n <widget class=\"QDialog\" name=\"About\">\n  <property name=\"windowModality\">\n   <enum>Qt::NonModal</enum>\n  </property>\n  <property name=\"geometry\">\n   <rect>\n    <x>0</x>\n    <y>0</y>\n    <width>400</width>\n    <height>400</height>\n   </rect>\n  </property>\n  <property name=\"windowTitle\">\n   <string>About</string>\n  </property>\n  <property name=\"modal\">\n   <bool>true</bool>\n  </property>\n  <layout class=\"QVBoxLayout\" name=\"verticalLayout_2\">\n   <item>\n    <layout class=\"QHBoxLayout\" name=\"horizontalLayout\">\n     <item>\n      <widget class=\"QLabel\" name=\"icon\">\n       <property name=\"minimumSize\">\n        <size>\n         <width>80</width>\n         <height>80</height>\n        </size>\n       </property>\n       <property name=\"maximumSize\">\n        <size>\n         <width>80</width>\n         <height>80</height>\n        </size>\n       </property>\n       <property name=\"text\">\n        <string/>\n       </property>\n       <property name=\"pixmap\">\n        <pixmap resource=\"resources.qrc\">:/icons/programicon.png</pixmap>\n       </property>\n       <property name=\"scaledContents\">\n        <bool>true</bool>\n       </property>\n       <property name=\"alignment\">\n        <set>Qt::AlignCenter</set>\n       </property>\n       <property name=\"margin\">\n        <number>10</number>\n       </property>\n      </widget>\n     </item>\n     <item>\n      <layout class=\"QVBoxLayout\" name=\"verticalLayout\">\n       <item>\n        <layout class=\"QHBoxLayout\" name=\"horizontalLayout_2\">\n         <property name=\"spacing\">\n          <number>0</number>\n         </property>\n         <item>\n          <widget class=\"QLabel\" name=\"label\">\n           <property name=\"text\">\n            <string>GoldenDict dictionary lookup program, version </string>\n           </property>\n           <property name=\"alignment\">\n            <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignVCenter</set>\n           </property>\n          </widget>\n         </item>\n         <item>\n          <widget class=\"QLabel\" name=\"version\">\n           <property name=\"accessibleDescription\">\n            <string/>\n           </property>\n           <property name=\"text\">\n            <string notr=\"true\">#.#</string>\n           </property>\n           <property name=\"textInteractionFlags\">\n            <set>Qt::TextEditorInteraction</set>\n           </property>\n          </widget>\n         </item>\n        </layout>\n       </item>\n       <item>\n        <widget class=\"QLabel\" name=\"label_2\">\n         <property name=\"text\">\n          <string>(c) 2008-2013 Konstantin Isakov (ikm@goldendict.org)</string>\n         </property>\n         <property name=\"alignment\">\n          <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignVCenter</set>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <widget class=\"QLabel\" name=\"label_3\">\n         <property name=\"text\">\n          <string>Licensed under GNU GPLv3 or later</string>\n         </property>\n         <property name=\"alignment\">\n          <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignVCenter</set>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <widget class=\"QLabel\" name=\"qtVersion\">\n         <property name=\"text\">\n          <string notr=\"true\">Based on Qt #.#.# (GCC #.#, 32/64 bit)</string>\n         </property>\n         <property name=\"textInteractionFlags\">\n          <set>Qt::TextEditorInteraction</set>\n         </property>\n        </widget>\n       </item>\n      </layout>\n     </item>\n    </layout>\n   </item>\n   <item>\n    <widget class=\"QLabel\" name=\"label_5\">\n     <property name=\"text\">\n      <string>Credits:</string>\n     </property>\n     <property name=\"alignment\">\n      <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignVCenter</set>\n     </property>\n    </widget>\n   </item>\n   <item>\n    <widget class=\"QTextBrowser\" name=\"credits\">\n     <property name=\"enabled\">\n      <bool>true</bool>\n     </property>\n     <property name=\"sizePolicy\">\n      <sizepolicy hsizetype=\"Expanding\" vsizetype=\"Expanding\">\n       <horstretch>0</horstretch>\n       <verstretch>1</verstretch>\n      </sizepolicy>\n     </property>\n    </widget>\n   </item>\n   <item>\n    <widget class=\"QDialogButtonBox\" name=\"buttonBox\">\n     <property name=\"orientation\">\n      <enum>Qt::Horizontal</enum>\n     </property>\n     <property name=\"standardButtons\">\n      <set>QDialogButtonBox::Ok</set>\n     </property>\n     <property name=\"centerButtons\">\n      <bool>true</bool>\n     </property>\n    </widget>\n   </item>\n  </layout>\n </widget>\n <resources>\n  <include location=\"resources.qrc\"/>\n </resources>\n <connections>\n  <connection>\n   <sender>buttonBox</sender>\n   <signal>accepted()</signal>\n   <receiver>About</receiver>\n   <slot>accept()</slot>\n   <hints>\n    <hint type=\"sourcelabel\">\n     <x>248</x>\n     <y>254</y>\n    </hint>\n    <hint type=\"destinationlabel\">\n     <x>157</x>\n     <y>274</y>\n    </hint>\n   </hints>\n  </connection>\n  <connection>\n   <sender>buttonBox</sender>\n   <signal>rejected()</signal>\n   <receiver>About</receiver>\n   <slot>reject()</slot>\n   <hints>\n    <hint type=\"sourcelabel\">\n     <x>316</x>\n     <y>260</y>\n    </hint>\n    <hint type=\"destinationlabel\">\n     <x>286</x>\n     <y>274</y>\n    </hint>\n   </hints>\n  </connection>\n </connections>\n</ui>\n"
        },
        {
          "name": "article-style-print.css",
          "type": "blob",
          "size": 0.1796875,
          "content": "/* This stylesheet is used for printing only, overriding article-style.css */\n\nhtml, body, .gdarticle\n{\n  background: white;\n}\n\n/* Hide audio icons */\n\n.dsl_s_wav\n{\n  display: none;\n}\n"
        },
        {
          "name": "article-style-st-babylon.css",
          "type": "blob",
          "size": 1.5869140625,
          "content": "html\n{\n  background-color: white;\n}\n\nbody\n{\n\tbackground: white;\n\tfont-size: 13px;\n}\n\n.gdarticle\n{\n  background: white;\n}\n\nh3 {\n\tfont-size: 1em;\n}\n\n::selection\n{\n\tbackground: #4492E8;\n\tcolor: white;\n}\n\n/* Dictionary's name heading */\n.gddictname\n{\n\tfont-weight: normal; \n\tfont-size: 11px;\n\tborder: none; \n\tborder-top-left-radius: 8px; \n\tborder-top-right-radius: 0px;\n\tbackground: #F0EDED;\n\tpadding-top: 5px; \n\tpadding-bottom: 5px;\n}\n\n.gddicticon\n{\n\tdisplay: inline;\n\tpadding-right: 5px;\n}\n\n.gddicticon img\n{\n\tborder: 0;\n\theight: 16px;\n\tvertical-align: text-top;\n}\n\n/* The 'From ' string which precedes dictionary name in the heading */\n.gdfromprefix\n{\n\tdisplay: none;\n}\n\n/* Move the collapse/expand buttons to the right */\n.collapse_expand_area\n{\n  float: right;\n  margin-right: 2px;\n}\n\n.gdexpandicon, .gdexpandicon:hover, .gdcollapseicon, .gdcollapseicon:hover\n{\n    width:15px;\n    background-position: center;\n    background-repeat:no-repeat;\n    vertical-align: text-bottom;\n    padding-left: -5px;\n    margin-left: 0px;\n}\n\n.gdexpandicon {\n    background-image: url('qrcx://localhost/icons/expand_article.png');\n}\n\n.gdexpandicon:hover {\n    background-image: url('qrcx://localhost/icons/expand_article_hovered.png');\n}\n\n.gdcollapseicon {\n    background-image: url('qrcx://localhost/icons/collapse_article.png');\n}\n\n.gdcollapseicon:hover {\n    background-image: url('qrcx://localhost/icons/collapse_article_hovered.png');\n}\n\n.bglpos { color: black; font-weight: bold; font-size: 11px; background: #F0EDED; display: inline; }\n\n.bgltrn { color: #808080; font-size: 12px; display: inline; }\n\na, .mwiki a\n{\n\tcolor: #0066CC;\n}\n\n"
        },
        {
          "name": "article-style-st-lingoes-blue.css",
          "type": "blob",
          "size": 6.5615234375,
          "content": "body {\n\tbackground: #EAF0F8;\n\tmargin: 0.3em;\n\tfont-family: \"Arial Unicode MS\", \"Lucida Sans Unicode\", Tahoma, Verdana, \"Palatino Linotype\", sans-serif;\n\tline-height: 120%;\n}\n\na {\n\ttext-decoration: none;\n\tcolor: darkblue;\n}\n \na:hover {\n\ttext-decoration: underline;\n}\n\n.gdarticle {\n\tbackground: #FFFEF2;\n\tmargin-top: 0.1em;\n\tmargin-bottom: 0.35em;\n\tpadding: 5px;\n\tpadding-top: -10px;\n\tborder: 1px solid #C7D4DC;\n\tborder-radius: 8px;\n}\n\n.gdactivearticle {\n\tbackground: #FFFEF2;\n\tborder: 1px solid #92B0DD;\n}\n\n.gdarticleseparator + script + .gdactivearticle .gddictname {\n\tborder-top: 1px solid #92B0DD;\n\tborder-right: 1px solid #92B0DD;\n}\n\n.gddictname {\n    display: -webkit-box; /* needed to be able to reorder elements, e.g. icon, dictionary name, collapse icon */\n\tfont-size: 12px;\n\tfont-weight: normal;\n\tfloat: right;\n\tborder: 0px;\n\tborder-top: 1px solid #C7D4DC;\n\tborder-right: 1px solid #C7D4DC;\n\tborder-top-right-radius: 8px;\n\tborder-bottom-left-radius: 6px;\n\tmargin: -6px;\n\tmargin-bottom: 5px;\n\tmargin-left: 2px;\n\tpadding-right: 0.4em;\n\tcolor: #34517D;\n\tbackground: #DDE6F5;\n\t-webkit-user-select: none;\n\tuser-select: none;\n\tcursor: default;\n}\n\n/* Actual text with the dictionary title */\n.gddicttitle\n{\n  display:block;\n  -webkit-box-ordinal-group: 1;\n  -webkit-box-flex: 1;\n}\n\n.gdactivearticle .gddictname {\n\tborder-top: 1px solid #92B0DD;\n\tborder-right: 1px solid #92B0DD;\n\tcolor: darkblue;\n\tbackground: #CFDDF0;\n}\n\n.gdcollapsedarticle .gddictname\n{\n  opacity: 0.7;\n}\n\n/* Nice diagonal pattern for the collapsed article */\n.gdcollapsedarticle\n{\n\tbackground-image: -webkit-linear-gradient(left top, #ccc 0%, #ccc 25%, #bbb 25%, #bbb 50%, #ccc 50%, #ccc 75%, #bbb 75%);\n\tbackground-size: 50px 50px;\n}\n\n/* Move the collapse/expand buttons to the last, 3rd position */\n.collapse_expand_area\n{\n  display: block;\n  -webkit-box-ordinal-group: 3;\n}\n\n.gddicticon\n{\n  display: block;\n  vertical-align: text-bottom;\n  padding-right: -1em;\n  padding-left: 0.3em;\n  -webkit-box-ordinal-group: 2;\n}\n\n.gdexpandicon, .gdexpandicon:hover, .gdcollapseicon, .gdcollapseicon:hover\n{\n    width:15px;\n    background-position: center 25%;\n    background-repeat:no-repeat;\n    vertical-align: top;\n    padding-left: -5px;\n    margin-left: 0px;\n}\n\n.gdexpandicon {\n    background-image: url('qrcx://localhost/icons/expand_article.png');\n}\n\n.gdexpandicon:hover {\n    background-image: url('qrcx://localhost/icons/expand_article_hovered.png');\n}\n\n.gdcollapseicon {\n    background-image: url('qrcx://localhost/icons/collapse_article.png');\n}\n\n.gdcollapseicon:hover {\n    background-image: url('qrcx://localhost/icons/collapse_article_hovered.png');\n}\n\n.gdarticleseparator {\n\tdisplay: none;\n}\n\n/* The 'From ' string which preceeds dictionary name in the heading */\n.gdfromprefix {\n\tdisplay: none;\n}\n\n/* The first headword in a (possibly) multi-headword DSL article */\n.gdarticlebody > div:first-child .dsl_headwords,\n.gdarticlebody > h3:first-child {\n\tmargin-top: -3px;\n\tdisplay: inline-block;\n}\n\n.mwiki .toc, .mwiki .metadata mbox-small plainlinks {\n\tdisplay:none\n}\n\n\n.gddicticon img {\n\tborder: 0;\n\theight: 15px;\n\tvertical-align: text-top; \n}\n\n/* Text selection */\n::selection {\n\tbackground: #839EC7;\n\tcolor:#fff;\n}\n\ncode::selection {\n\tbackground: #839EC7;\n}\n\n/* Headers */\nh3 {\n\tcolor: inherit; \n\tfont-family: Arial;\n}\n\n/******** DSL Dictionaries ****************/\n\n/* DSL headwords */\n.dsl_headwords {\n\tcolor: inherit;\n\tfont-family: Arial;\n}\n\n/* Formatting */\n.dsl_b {\n\tfont-family: Arial;\n}\n\n.dsl_ex, .dsl_ex .dsl_opt\n{\n\tcolor: slategray;\n}\n\n.dsl_ref {\n\tcolor: #0000DD; \n}\n\n.dsl_url { \n\tcolor: #0000DD; \n}\n\n/* Stress settings */\n.dsl_stress_without_accent,\n.dsl_opt .dsl_ex .dsl_stress_without_accent {\n\tdisplay: none;\n\tcolor: green;\n}\n\n.dsl_stress_with_accent,\n.dsl_opt .dsl_ex .dsl_stress_with_accent {\n\tdisplay: inline;\n\tcolor: #DD0000;\n}\n.dsl_stress,\n.dsl_opt .dsl_ex .dsl_stress {\n\tdisplay: inline;\n\tcolor: blue;\n}\n\n/* Sound icon */\n.dsl_s_wav img {\n\tdisplay: none;\n}\n\n.dsl_s_wav a {\n\ttext-decoration: none;\n\t-webkit-user-select: none;\n\tdisplay: inline-block;\n\twidth: 18px;\n\theight: 18px;\n\t-webkit-border-radius: 100px;\n\ttext-align: center;\n\tvertical-align: text-bottom;\n}\n\n.dsl_s_wav a {\n\tcolor: #FFF;\n\tborder: 1px solid #798415;\n\t-webkit-box-shadow: 1px 1px #CCC, inset -1px -1px #4E7500;\n\n\tbackground: -webkit-gradient(linear, left top, right bottom, color-stop(0%,rgba(191,210,85,1)), color-stop(50%,rgba(142,185,42,1)), color-stop(51%,rgba(114,170,0,1)), color-stop(100%,rgba(158,203,45,1)));\n}\n\n.dsl_s_wav a:hover {\n\tbackground: -webkit-gradient(linear, left top, right bottom, color-stop(0%,#e6f0a3), color-stop(50%,#d2e638), color-stop(51%,#c3d825), color-stop(100%,#dbf043));\n\n\tborder: 1px solid #A2B01C;\n\t-webkit-box-shadow: 1px 1px #CCC, inset -1px -1px #8A991A;\n}\n\n.dsl_s_wav a:active {\n\t-webkit-box-shadow: 1px 1px #CCC, inset 1px 1px #B1C421;\n}\n\n.dsl_s_wav a:after {\n\tdisplay: inline-block;\n\tfont-family: \"Webdings\";\n\tcontent:\"X\";\n\twidth: 18px;\n\theight: 18px;\n\tfont-size: 16px;\n\ttext-align: center;\n\tvertical-align: center;\n\t-webkit-background-clip: text;\n\tcolor: #E6EF8F;\n\t-webkit-text-stroke: 1px #51580E;\n}\n\n.dsl_s_wav a:hover:after {\n\t-webkit-text-stroke: 1px #656E11;\n}\n\n\n/******** Verbix Dictionaries ****************/\n\n.sdct_h .normal {\n\tfont-family: Arial;\n\tfont-size: 10pt;\n\tcolor:#000000;\n\tfont-weight: normal;\n\ttext-decoration:none;\n}\n\n.sdct_h .irregular {\n\tfont-family: Arial;\n\tfont-size: 10pt;\n\tcolor:#FF0000;\n\tfont-weight: bold;\n\ttext-decoration:none;\n}\n\n.sdct_h .orto {\n\tfont-family: Arial;\n\tfont-size: 10pt;\n\tcolor:#0000FF;\n\tfont-weight: normal;\n\ttext-decoration:none;\n}\n\n.sdct_h .archaic {\n\tfont-family: Arial;\n\tfont-size: 10pt;\n\tcolor:#800080;\n\tfont-weight: normal;\n\ttext-decoration:none;\n}\n\n.sdct_h .notused {\n\tfont-family: Arial;\n\tfont-size: 10pt;\n\tcolor:#808080;\n\tfont-weight: normal;\n\ttext-decoration:none;\n}\n\n.sdct_h .pronoun {\n\tfont-family: Arial;\n\tfont-size: 10pt;\n\tcolor:#008000;\n\tfont-weight: normal;\n\ttext-decoration:none;\n}\n\n\n.sdct_h > table {\n\tborder: 1px solid #444444;\n\tborder-collapse: collapse;\n}\n\n.sdct_h td.verbtable {\n\tborder: 1px solid #444444;\n}\n\n.sdct_h th {\n\tbackground-color: #A6C9EF;\n\tfont-weight: bold;\n}\n\n.sdct_h .mini {\n\tfont-size: 8pt; font-weight: normal; color: #808080;\n}\n\n.sdct_h div.spacerline {\n\tclear: both;\n\tmargin-left: 8px;\n\twidth:100%;\n\tborder-top: 1px solid #ccc;\n}\n\n.sdct_h div.spacer {\n\tclear: both;\n}\n\n.sdct_h div.float {\n\tmargin-left: 8px;\n\tfloat: left;\n}\n\n.sdct_h div.float400 {\n\tmargin-left: 8px;\n\tfloat: left;\n\twidth: 400px;\n}\n\t\n.sdct_h div.float250color {\n\tmargin-left: 8px;\n\tfloat: left;\n\twidth: 250px;\n\tborder-style: dashed;\n\tborder-color:#0033CC;\n\tborder-collapse:collapse;\n\tborder-width:1px;\n\tbackground-color:#eeeeee;\n\tpadding: 8px 8px 8px 8px;\n} "
        },
        {
          "name": "article-style-st-lingoes.css",
          "type": "blob",
          "size": 1.474609375,
          "content": "a \n{\n  color: #2233bb;\n  text-decoration: none;\n}\n\na:hover\n{\n  color: #6677ff;\n}\n\n::selection\n{\n  background: #3399ff;\n  color: white;\n}\n\nbody\n{\n  background: #fffef2;\n  color: black;\n  font-family: Tahoma, Verdana, SimSun, SimSun-ExtB, sans-serif;\n  margin: 5px;\n}\n\n.gdarticle\n{\n  background: #fffef2;\n  margin-top: -8px;\n  position: relative;\n}\n\n.gddicticon\n{\n  display: inline;\n  margin-left: -3px;\n  padding-right: 5px;\n}\n\n.gddicticon img\n{\n  border: 0px;\n  height: 16px;\n  vertical-align: text-top;\n}\n\n.gdfromprefix\n{\n  display: none;\n}\n\n.gddictname\n{\n  display: inline-block;\n  border: 1px solid #92b0dd;\n  padding: 0.2em;\n  padding-left: 0.5em;\n  padding-right: 0.5em;\n  margin-top: 1em;\n  margin-bottom: -0.1em;\n  background: #cfddf0;\n  color: #000080;\n  font-weight: normal;\n  font-size: 12px;\n}\n\n.collapse_expand_area\n{\n  position: absolute;\n  right: 0px;\n}\n\n.gdexpandicon, .gdexpandicon:hover, .gdcollapseicon, .gdcollapseicon:hover\n{\n  background-position: center 35%;\n  background-repeat:no-repeat;\n}\n\n\n.gdexpandicon {\n  background-image: url('qrcx://localhost/icons/expand_article.png');\n}\n\n.gdexpandicon:hover {\n  background-image: url('qrcx://localhost/icons/expand_article_hovered.png');\n}\n\n.gdcollapseicon {\n  background-image: url('qrcx://localhost/icons/collapse_article.png');\n}\n\n.gdcollapseicon:hover {\n  background-image: url('qrcx://localhost/icons/collapse_article_hovered.png');\n}\n\n.gddictnamebodyseparator\n{\n  display: inline-block;\n  width: 100%;\n  border-top: 1px solid #92b0dd;\n}\n"
        },
        {
          "name": "article-style-st-lingvo.css",
          "type": "blob",
          "size": 1.3935546875,
          "content": "html\n{\n  background-color: white;\n}\n\nbody\n{\n  background: white;\n}\n\na\n{\n  text-decoration: none;\n  color: darkblue;\n}\n\na:hover\n{\n  text-decoration: underline;\n}\n\n.gdarticle\n{\n  background: white;\n}\n\n/* Dictionary's name heading */\n.gddictname\n{\n  border: 1px dotted black; padding: 0.2em; padding-left: 0.5em;\n  margin-top: 1.2em; margin-bottom: 0.1em; font-weight: bold; font-size: 14px;\n  background: #87CEEB;\n}\n\n/* The 'From ' string which preceeds dictionary name in the heading */\n.gdfromprefix\n{\n  display: none;\n}\n\n.gddictname\n{\n\t font-size: 13px;\n  font-weight: normal;\n  \n  float: right;\n  border: 1px solid white;\n  margin-top: 7px;\n  color: #7f7f7f;\n  background: white;\n}\n\n.gdarticleseparator + script + .gdarticle .gddictname\n{\n  border-top: 1px solid #ccc;\n/*  margin-top: 11px;*/\n}\n\n.gdactivearticle .gddictname\n{\n\t font-size: 13px;\n  font-weight: normal;\n  \n  float: right;\n  border: 1px solid #b3d7f7;\n  margin-top: 7px;\n  color: #0066ff;\n  background: #deecf8;\n}\n\n.gdarticleseparator + script + .gdactivearticle .gddictname\n{\n  border-top: 1px solid #b3d7f7;\n/*  margin-top: 11px;*/\n}\n\n.gdarticleseparator\n{\n  margin-top: 10px;\n  border-bottom: 1px solid #cccccc;\n  margin-bottom: 0px;\n  width: 100%;\n  display: inline-block;\n  clear: both;\n}\n\n.gddictname + h3, .gddictname + .dsl_article > .dsl_headwords\n{\n  margin-top: 10px;\n}\n\n.dsl_ex, .dsl_ex .dsl_opt\n{\n  color: inherit;\n}\n\n.dsl_com\n{\n  color: black;\n}\n"
        },
        {
          "name": "article-style-st-modern.css",
          "type": "blob",
          "size": 3.2119140625,
          "content": "html\n{\n  background-color: white;\n}\n\nbody\n{\n  margin-top: 1px;\n  margin-right: 3px;\n  margin-left:  2px;\n  margin-bottom: 3px;\n  background: white;\n  font-family: Tahoma, Verdana, \"Lucida Sans Unicode\", \"Segoe UI\", \"Palatino Linotype\", \"Arial Unicode MS\", sans-serif;\n}\n\na\n{\n  text-decoration: none;\n  color: darkblue;\n}\n\na:hover\n{\n  text-decoration: underline;\n}\n\n.gdarticle\n{\n  margin-top: 0.1em;\n  margin-bottom: 0.4em;\n  padding: 5px;\n  border: 1px solid #d0dde2;\n  border-radius: 8px;\n  background: white;\n}\n\n.gdactivearticle\n{\n  border: 1px solid #3399FF;\n}\n\n.gdarticleseparator + script + .gdactivearticle .gddictname\n{\n  border-top: 1px solid #3399FF;\n}\n\n.gdarticleseparator\n{\n  display: none;\n}\n\n/* Hide the 'From ' string which precedes dictionary name in the heading */\n.gdfromprefix\n{\n  display: none;\n}\n\n.gddictname\n{\n  display: -webkit-box; /* needed to be able to reorder elements, e.g. icon, dictionary name, collapse icon */\n  font-size: 12px;\n  font-weight: normal;\n  float: right;\n  border: 0px;\n  border-top-right-radius: 8px;\n  border-bottom-left-radius: 6px;\n  margin: -6px;\n  margin-bottom: 5px;\n  margin-left: 2px;\n  padding-right: 0.3em;\n  color: #4480f8;\n  background: #E0E8F0;\n\n  -webkit-user-select: none;\n  user-select: none;\n  cursor: default;\n}\n\n/* Actual text with the dictionary title */\n.gddicttitle\n{\n  display:block;\n  -webkit-box-ordinal-group: 1;\n  -webkit-box-flex: 1;\n}\n\n.gdactivearticle .gddictname\n{\n  font-size: 13px;\n  font-weight: normal;\n  margin: -6px;\n  margin-bottom: 5px;\n  margin-left: 2px;\n\n  float: right;\n  border: 1px solid #3399FF;\n  color: #0066cc;\n  background: #deecf8;\n}\n\n.gdcollapsedarticle .gddictname\n{\n  opacity: 0.7;\n}\n\n/* Nice diagonal pattern for the collapsed article */\n.gdcollapsedarticle\n{\n\tbackground-image: -webkit-linear-gradient(left top, #ccc 0%, #ccc 25%, #bbb 25%, #bbb 50%, #ccc 50%, #ccc 75%, #bbb 75%);\n\tbackground-size: 50px 50px;\n}\n\n/* Move the collapse/expand buttons to the last, 3rd position */\n.collapse_expand_area\n{\n  display: block;\n  -webkit-box-ordinal-group: 3;\n}\n\n.gddicticon\n{\n  display: block;\n  vertical-align: text-bottom;\n  padding-right: -1em;\n  padding-left: 0.3em;\n  -webkit-box-ordinal-group: 2;\n}\n\n.gdexpandicon, .gdexpandicon:hover, .gdcollapseicon, .gdcollapseicon:hover\n{\n    width:15px;\n    background-position: center 35%;\n    background-repeat:no-repeat;\n    vertical-align: text-bottom;\n    padding-left: -5px;\n    margin-left: 0px;\n}\n\n.gdexpandicon {\n    background-image: url('qrcx://localhost/icons/expand_article.png');\n}\n\n.gdexpandicon:hover {\n    background-image: url('qrcx://localhost/icons/expand_article_hovered.png');\n}\n\n.gdcollapseicon {\n    background-image: url('qrcx://localhost/icons/collapse_article.png');\n}\n\n.gdcollapseicon:hover {\n    background-image: url('qrcx://localhost/icons/collapse_article_hovered.png');\n}\n\n/* The first headword in a (possibly) multi-headword DSL article */\n.gdarticlebody > div:first-child .dsl_headwords,\n.gdarticlebody > h3:first-child\n{\n  margin-top: -3px;\n  display: inline-block;\n}\n\n.gdspellsuggestion\n{\n  /* Add some vertical space before the article */\n  margin-top: 1.5em;\n}\n\n.dsl_ex, .dsl_ex .dsl_opt\n{\n  color: steelblue;\n}\n\n::selection {\n  background:#cc0000;\n  color:#fff;\n}\n\ncode::selection {\n  background: #333333;\n}\n"
        },
        {
          "name": "article-style.css",
          "type": "blob",
          "size": 54.8837890625,
          "content": "/******** Global, non-dictionary-specific classes ***********/\n\n\nbody\n{\n  background: #fefdeb;\n  font-family: Tahoma, Verdana, \"Lucida Sans Unicode\", sans-serif;\n  font-size: 13px;\n}\n\n/* This stylesheet is used to highligh current selection when doing a search.\n  It changes the default selection color (e.g. blue under Windows, orange under Ubuntu) */\n\n/* highlight/select color in Windows when a widget is inactive is nearly impossible to read (light gray).\n * then change it to green to use with the find option. */\n::selection {\n  background: #c00;\n  color: #fff;\n}\n\n/* Don't allow to select [] */\n:before, :after {\n  -webkit-user-select: none;\n  user-select: none;\n}\n\n/* Plaintext dictionaries are usually 80-column formatted and take a lot\n * of space. We try to use smaller fonts for them therefore. */\npre\n{\n  font-size: 12px;\n}\n\n/* Dictionary's name heading */\n.gddictname\n{\n  border: 1px dotted black; padding: 0.2em; padding-left: 0.5em;\n  margin-top: 1.2em; margin-bottom: 9px; font-weight: bold; font-size: 14px;\n  /*background: #ffffdd;*/\n}\n\n/* The 'From ' string which precedes dictionary name in the heading */\n.gdfromprefix\n{\n}\n\n/* The article span. Here we have a padding/margin hack to make fragment links\n   behave better (have some space before the start of article) */\n.gdarticle\n{\n  display: block;\n  padding-top: 1px;\n  margin-top: -8px;\n  margin-bottom: 8px;\n  background: #fefdeb;\n/*fix for invalid blg*/\n  font-style:normal;\n}\n\n/* CSS trick to prevent the floating elements to overflow\n   the article boundaries, see Issue #333. */\n.gdarticle:after\n{\n   content: \"\";\n   display: block;\n   height: 0;\n   clear: both;\n}\n\n/* Appears between the articles */\n.gdarticleseparator\n{\n}\n\n/* Dictionary query error description string */\n.gderrordesc\n{\n  font-style: italic;\n  background: url(\"qrcx://localhost/icons/warning.png\") center left no-repeat !important;\n  padding-left: 22px !important;\n  margin: 1em;\n}\n\n/********* Babylon dictionaries' classes *********/\n\n/* Transcriptions in Babylon dictionaries */\n.bgltrn:before\n{\n  content:\"[\";\n}\n\n.bgltrn:after\n{\n  content:\"]\";\n}\n\n.bgltrn { display:block; }\n\n/* Part of speech in Babylon dictionaries. Usually irrelevant,\n * therefore hidden */\n.bglpos { display: none; }\n\n/* Right-to-left text */\n.bglrtl\n{\n  text-align: right;\n  direction: rtl;\n}\n\n/******** StarDict dictionaries' classes *********/\n\n\n/* StarDict type 'h' -- Html content. We don't normally do anything here. */\ndiv.sdct_h\n{\n}\n\n.sdict_h_wav img\n{\n  /* Ugly hack since \"vertical-align: middle;\" looks _terrible_ in Qt4's webkit: */\n  vertical-align: -30%;\n}\n\n/* StarDict type 'm' -- Pure meaning. Presented as <pre> */\npre.sdct_m\n{\n}\n\n/* StarDict type 'l' -- Pure meaning which used to be in locale encoding. */\npre.sdct_m\n{\n}\n\n/* StarDict type 'g' -- Pango Markup */\ndiv.sdct_g\n{\n}\n\n/* StarDict type 't' -- Transcription */\ndiv.sdct_t\n{\n  font-weight: bold;\n}\n\n/* StarDict type 'y' -- Chinese YinBiao or Japanese KANA */\ndiv.sdct_y\n{\n}\n\n/* StarDict type 'x'. Should have xdxf_*-styled elements inside */\ndiv.sdct_x\n{\n}\n\n/* Blockquotes in XDXF-styled elements are used\n   for indentation purposes, see Issue #305. */\n.sdct_x blockquote\n{\n  margin: 0px;\n  padding-left: 9px;\n  display: inline-block;\n}\n\n/******** XDXF markup classes *********/\n\ndiv.xdxf\n{\n}\n\n/* Key -- keys shouldn't normally be present in the article's body since they\n * are accounted for separately, hence we hide them */\n.xdxf_k\n{\n  display: none;\n}\n\n/* ...and if there's a break after it, we hide it too so we don't have an\n * extra vertical spacing. */\n.xdxf_k + br\n{\n  display: none;\n}\n\n/* Article structure tag */\n.xdxf_num\n{\n    color: red;\n    font-weight: bold;\n    padding-left:-15px;\n}\n.xdxf_def\n{\n    display: block;\n    border-color: #e3e3e3;\n    border-width: 1px;\n    border-style: dashed;\n    margin: 1px;\n    margin-left: 15px;\n}\n\n.xdxf_def:target\n{\n    /* this pseudoclass is used to marked out the referenced <def> that was just clicked */\n    border-color: red;\n    border-width: 1px;\n    border-style: double;\n}\n\n/* Abbreviation */\n.xdxf_abbr\n{\n  font-style: italic;\n  color: seagreen;\n  cursor: default;\n  border-bottom: 1px seagreen dotted;\n}\n\n/* Editorial comment */\n.xdxf_co, .xdxf_co_old\n{\n    color: darkslateblue;\n    font-style: italic;\n}\n.xdxf_co:before\n{\n    content:\"(\"\n}\n.xdxf_co:after\n{\n    content:\")\"\n}\n\n/* Grammar information */\n.xdxf_gr\n{\n    color: orangered;\n    display: block;\n}\n\n.xdxf_gr_old\n{\n    color: blue; /*orangered;*/\n}\n\n/* Example */\n.xdxf_ex\n{\n    color: #808080;\n    display: block;\n    margin-left: 14px;\n}\n\n.xdxf_ex_old\n{\n    color: #808080;\n}\n\n.xdxf_ex_source:before\n{\n    content:\"[\"\n}\n.xdxf_ex_source:after\n{\n    content:\"]\"\n}\n\n.xdxf_ex_tran:before\n{\n    content:\"— \"\n}\n\n.xdxf_ex_tran\n{\n    font-style: italic;\n}\n\n/* Direct translation */\n.xdxf_dtrn\n{\n    font-weight: bold;\n    color: #dd7800;\n}\n\n/* Transcription */\n.xdxf_tr:before\n{\n  content:\"[\";\n}\n\n.xdxf_tr:after\n{\n  content:\"]\";\n}\n\n.xdxf_tr, .xdxf_tr_old\n{\n  font-weight: bold;\n}\n\n/* Resource reference -- for now just a span. Since there's not yet a mechanism\n * to load resources off XDXF articles in GoldenDict, we just hide them. */\n.xdxf_rref\n{\n  display: none;\n}\n\n.xdxf_headwords\n{\n  font-size: 116%;\n  font-weight: bold;\n  margin-top: 10px;\n  margin-bottom: 10px;\n}\n\n/* The words in examples that are meaked out; they are marked out only when placed into <ex> tag */\n.xdxf_ex .xdxf_ex_markd, .xdxf_ex_old .xdxf_ex_markd\n{\n  color:black;\n  background-color:lightgray;\n}\n\n.xdxf_opt\n{\n  color: #808080;\n}\n\n/******** SDictionary markup classes *********/\n\n.sdict_forms\n{\n  font-style: italic;\n}\n\n/* Transcription */\n.sdict_tr:before\n{\n  content:\"[\";\n}\n\n.sdict_tr:after\n{\n  content:\"] \";\n}\n\n.sdict_tr\n{\n  font-weight: bold;\n}\n\n/************* LSA audio archives **************/\n\n/* A table which contains a play icon and a word's link */\n.lsa_play\n{\n  margin-top: 8px;\n  margin-left: 8px;\n}\n\n.lsa_play a\n{\n  text-decoration: none;\n}\n\n/************* DSL dictionaries **************/\n\n.dsl_u\n{\n  text-decoration: underline;\n}\n\n.dsl_article\n{\n  display:inline;\n}\n\n.dsl_article font[color=c_default_color]\n{\n  color: green;\n}\n\n.dsl_m, .dsl_m0\n{\n  padding-left: 0px;\n}\n\n.dsl_m1\n{\n  padding-left: 9px;\n}\n\n.dsl_m2\n{\n  padding-left: 18px;\n}\n\n.dsl_m3\n{\n  padding-left: 27px;\n}\n\n.dsl_m4\n{\n  padding-left: 36px;\n}\n\n.dsl_m5\n{\n  padding-left: 45px;\n}\n\n.dsl_m6\n{\n  padding-left: 54px;\n}\n\n.dsl_m7\n{\n  padding-left: 63px;\n}\n\n.dsl_m8\n{\n  padding-left: 72px;\n}\n\n.dsl_m9\n{\n  padding-left: 81px;\n}\n\n.dsl_p, .dsl_p :not(a) /* DSL Feature: Enforce the style even if the children tags say otherwise, except links */\n{\n  color: green !important; /* DSL label color must have highest priority */\n  font-style: italic;\n  cursor: default;\n  font-weight: normal; /* DSL feature: labels are always of normal weight */\n}\n\n.dsl_stress_without_accent {\n  display: none;\n}\n\n.dsl_t\n{\n  font-weight: bold;\n}\n\n.dsl_headwords\n{\n  font-weight: bold;\n  margin-top: 15px;\n  margin-bottom: 10px;\n}\n\n.dsl_headwords p\n{\n  font-weight: bold;\n  font-size: 15px;\n  margin: 0;\n}\n\n.dsl_definition p\n{\n  margin: 0;\n}\n\n.dsl_opt\n{\n  display: none;\n}\n\n.dsl_opt,\n.dsl_opt .dsl_ex,\n.dsl_opt .dsl_ex :not(a),\n.dsl_opt .dsl_ex font[color] /* DSL Feature: Enforce the optional zone color even if the children tags say otherwise */\n{\n  color: gray;\n}\n\n.dsl_ex, .dsl_ex .dsl_opt\n{\n  color: gray;\n}\n\n/* Style for expand optional parts button */\n.hidden_expand_opt\n{\n  color: blue;\n  cursor: pointer;\n  vertical-align: text-bottom;\n}\n\n.dsl_s_wav img\n{\n  /* Ugly hack since \"vertical-align: middle;\" looks _terrible_ in Qt4's webkit: */\n  vertical-align: -30%;\n}\n\n.dsl_video .img\n{\n  display: inline-block;\n  background: url('qrcx://localhost/icons/video.png');\n  background-repeat: no-repeat;\n  /* Ugly hack since \"vertical-align: middle;\" looks _terrible_ in Qt4's webkit: */\n  vertical-align: -30%;\n  width: 22px;\n  height: 22px;\n  margin: 0;\n  padding: 0;\n}\n\n.dsl_video .filename\n{\n  display: none; /* by default, the file name is hidden */\n  padding-left: 5px;\n}\n\n/************* MDict dictionaries **************/\n.mdict\n{\n  margin-top: 1em;\n}\n\n.mdict a[name]\n{\n  text-decoration: none;\n  color: inherit;\n}\n\n/************* Zim dictionaries **************/\n\n.zimdict\n{\n  font-size: 110%!important;\n}\n\n.zimdict_headword\n{\n  font-weight: bold!important;\n}\n\n/************* Spelling suggestions *****************/\n\n.gdspellsuggestion\n{\n  /* Add some vertical space before the article */\n  margin-top: 1em;\n}\n\n/************* Stemmed suggestions *****************/\n\n.gdstemmedsuggestion\n{\n  /* Add some horizontal and vertical space */\n  margin-top: 1em;\n  margin-left: 1px;\n}\n\n\n.gdstemmedsuggestion_head\n{\n  margin-left: 11px;\n  font-style: italic;\n}\n\n.gdstemmedsuggestion_body\n{\n}\n\n/************* Dictd articles *****************/\n.dictd_article\n{\n  /* Add some vertical space before the article */\n  margin-top: 1em;\n}\n\n.dictd_phonetic:before, .dictd_phonetic:after\n{\n  content: \"\\\\\";\n  font-style: normal;\n}\n\n.dictd_phonetic:after\n{\n  margin-left: 3px;\n}\n\n.dictd_phonetic\n{\n  font-style: italic;\n  color: #009900;\n}\n\n.dictd_article a:link\n{\n  color: #0000FF;\n}\n\n.dictserver_from\n{\n  font-size: 110%;\n  font-weight: 600;\n}\n\n/************* Epwing dictionaries *****************/\n\n.epwing_narrow_font\n{\n  width: 7px;\n  height: 13px;\n  vertical-align: -15%;\n}\n\n.epwing_wide_font\n{\n  width: 13px;\n  height: 13px;\n  vertical-align: -15%;\n}\n\n.epwing_article\n{\n  display:inline;\n}\n\n/************* Websites *****************/\n\n.website_padding\n{\n  height: 1em;\n  clear:both;\n}\n\n/************* Forvo **************/\n\n.forvo_headword\n{\n  margin-top: 15px;\n  margin-bottom: 10px;\n  font-weight: bold;\n  font-size: 15px;\n}\n\n/* A table which contains a play icon and information about the sound */\n.forvo_play\n{\n  margin-top: 8px;\n  margin-left: 8px;\n}\n\n.forvo_user\n{\n  text-decoration: none;\n  color: green;\n}\n\n.forvo_location\n{\n  color: grey;\n}\n\n.forvo_positive_votes\n{\n  font-weight: bold;\n  color: green;\n}\n\n.forvo_negative_votes\n{\n  font-weight: bold;\n  color: red;\n}\n\n/************* Programs **************/\n\n/* A table which contains a play icon and a word's link */\n.programs_play\n{\n  margin-top: 8px;\n  margin-left: 8px;\n}\n\n.programs_play a\n{\n  text-decoration: none;\n}\n\n.programs_plaintext, .programs_html\n{\n  margin-top: 15px;\n}\n\n/************* Voice engines **************/\n\n.voiceengines_play\n{\n  margin-top: 8px;\n  margin-left: 8px;\n}\n\n.voiceengines_play a\n{\n  text-decoration: none;\n}\n\n/************* MediaWiki articles *****************\n The following consist of excerpts from different .css files edited\n with a .mwiki prepended to each record.\n*/\n\n.mwiki\n{\n  /* Add some vertical space before the article */\n  margin-top: 1em;\n}\n\n.mwiki .topicon\n{\n  /* Those are padlocks on top and such -- we disable those for GoldenDict\n     since they look really ugly here */\n  display: none;\n}\n\n/************ common.css **************/\n\n/**\n * CSS in this file is used by *all* skins (that have any CSS at all).  Be\n * careful what you put in here, since what looks good in one skin may not in\n * another, but don't ignore the poor non-Monobook users either.\n */\n.mwiki .mw-plusminus-null { color: #aaa; }\n\n.mwiki .texvc { direction: ltr; unicode-bidi: embed; }\n.mwiki img.tex { vertical-align: middle; }\n.mwiki span.texhtml { font-family: serif; }\n\n/* add a bit of margin space between the preview and the toolbar */\n/* this replaces the ugly <p><br /></p> we used to insert into the page source */\n.mwiki #wikiPreview.ontop { margin-bottom: 1em; }\n\n/* Stop floats from intruding into edit area in previews */\n.mwiki #toolbar, .mwiki #wpTextbox1 { clear: both; }\n\n.mwiki div#mw-js-message {\n\tmargin: 1em 5%;\n\tpadding: 0.5em 2.5%;\n\tborder: solid 1px #ddd;\n\tbackground-color: #fcfcfc;\n}\n\n/* Edit section links */\n.mwiki .editsection {\n\tfloat: right;\n\tmargin-left: 5px;\n}\n\n/**\n * File histories\n */\n.mwiki table.filehistory {\n\tborder:1px solid #ccc;\n\tborder-collapse:collapse;\n}\n\n.mwiki table.filehistory th,\n.mwiki table.filehistory td {\n\tpadding: 0 0.2em 0 0.2em;\n\tvertical-align:top;\n\tborder:1px solid #ccc;\n}\n.mwiki table.filehistory th {\n\ttext-align: left;\n}\n.mwiki table.filehistory td.mw-imagepage-filesize,\n.mwiki table.filehistory th.mw-imagepage-filesize {\n\twhite-space:nowrap;\n}\n\n.mwiki table.filehistory td.filehistory-selected {\n\tfont-weight: bold;\n}\n\n/*\n * rev_deleted stuff\n */\n.mwiki li span.deleted, .mwiki span.history-deleted {\n\ttext-decoration: line-through;\n\tcolor: #888;\n\tfont-style: italic;\n}\n\n/**\n * Forms\n */\n.mwiki body.ltr td.mw-label { text-align: right; }\n.mwiki body.ltr td.mw-input { text-align: left; }\n.mwiki body.ltr td.mw-submit { text-align: left; }\n.mwiki body.rtl td.mw-label { text-align: left; }\n.mwiki body.rtl td.mw-input { text-align: right; }\n.mwiki body.rtl td.mw-submit { text-align: right; }\n\n.mwiki td.mw-label { vertical-align: top; }\n.mwiki td.mw-submit { white-space: nowrap; }\n\n/**\n * Image captions\n */\n.mwiki body.rtl .thumbcaption { text-align:right; }\n.mwiki body.rtl .magnify { float:left; }\n\n.mwiki body.ltr .thumbcaption { text-align:left; }\n.mwiki body.ltr .magnify { float:right; }\n\n/**\n * Hidden categories\n */\n.mwiki .mw-hidden-cats-hidden { display: none; }\n.mwiki .catlinks-allhidden { display: none; }\n\n/* Convenience links to edit block, delete and protect reasons */\n.mwiki p.mw-ipb-conveniencelinks, .mwiki p.mw-protect-editreasons,\n.mwiki p.mw-filedelete-editreasons, .mwiki p.mw-delete-editreasons {\n\tfont-size: 90%;\n\tfloat: right;\n}\n\n/* Search results */\n.mwiki div.searchresult {\n\tfont-size: 95%;\n\twidth:38em;\n}\n.mwiki .mw-search-results li {\n\tpadding-bottom: 1em;\n\tlist-style:none;\n}\n.mwiki .mw-search-result-data {\n\tcolor: green;\n\tfont-size: 97%;\n}\n\n.mwiki td#mw-search-menu {\n\tpadding-left:6em;\n\tfont-size:85%;\n}\n\n.mwiki div#mw-search-interwiki {\n\tfloat: right;\n\twidth: 18em;\n\tborder-style: solid;\n\tborder-color: #AAAAAA;\n\tborder-width: 1px;\n\tmargin-top: 2ex;\n}\n\n.mwiki div#mw-search-interwiki li {\n\tfont-size: 95%;\n}\n\n.mwiki .mw-search-interwiki-more {\n\tfloat: right;\n\tfont-size: 90%;\n}\n\n.mwiki span.searchalttitle {\n\tfont-size: 95%;\n}\n\n.mwiki div.searchdidyoumean {\n\tfont-size: 127%;\n\tmargin-bottom: 1ex;\n\tmargin-top: 1ex;\n\t/* Note that this color won't affect the link, as desired. */\n\tcolor: #c00;\n}\n\n.mwiki div.searchdidyoumean em {\n\tfont-weight: bold;\n}\n\n.mwiki .searchmatch {\n\tfont-weight: bold;\n}\n\n.mwiki div.searchresults {\n\tborder:1px solid darkblue;\n\tpadding-top: 10px;\n\tpadding-bottom: 10px;\n\tpadding-left: 20px;\n\tpadding-right: 20px;\n}\n\n/*\n * UserRights stuff\n */\n.mwiki .mw-userrights-disabled {\n\tcolor: #888;\n}\n\n.mwiki table.mw-userrights-groups * td,.mwiki table.mw-userrights-groups * th {\n\tpadding-right: 1.5em;\n}\n\n/*\n * OpenSearch ajax suggestions\n */\n.mwiki .os-suggest {\n\toverflow: auto;\n\toverflow-x: hidden;\n\tposition: absolute;\n\ttop: 0px;\n\tleft: 0px;\n\twidth: 0px;\n\tbackground-color: white;\n\tbackground-color: Window;\n\tborder-style: solid;\n\tborder-color: #AAAAAA;\n\tborder-width: 1px;\n\tz-index:99;\n\tvisibility:hidden;\n\tfont-size:95%;\n}\n\n.mwiki table.os-suggest-results {\n\tfont-size: 95%;\n\tcursor: pointer;\n\tborder: 0;\n\tborder-collapse: collapse;\n\twidth: 100%;\n}\n\n.mwiki td.os-suggest-result, .mwiki td.os-suggest-result-hl {\n\twhite-space: nowrap;\n\tbackground-color: white;\n\tbackground-color: Window;\n\tcolor: black;\n\tcolor: WindowText;\n\tpadding: 2px;\n}\n.mwiki td.os-suggest-result-hl,\n.mwiki td.os-suggest-result-hl-webkit {\n\tbackground-color: #4C59A6;\n\tcolor: white;\n}\n.mwiki td.os-suggest-result-hl {\n\t/* System colors are misimplemented in Safari 3.0 and earlier,\n\t   making highlighted text illegible... */\n\tbackground-color: Highlight;\n\tcolor: HighlightText;\n}\n\n.mwiki .os-suggest-toggle {\n\tposition: relative;\n\tleft: 1ex;\n\tfont-size: 65%;\n}\n.mwiki .os-suggest-toggle-def {\n\tposition: absolute;\n\ttop: 0px;\n\tleft: 0px;\n\tfont-size: 65%;\n\tvisibility: hidden;\n}\n\n/* Page history styling */\n/* the auto-generated edit comments */\n.mwiki .autocomment { color: gray; }\n.mwiki #pagehistory .history-user {\n    margin-left: 0.4em;\n    margin-right: 0.2em;\n}\n.mwiki #pagehistory span.minor { font-weight: bold; }\n.mwiki #pagehistory li { border: 1px solid white; }\n.mwiki #pagehistory li.selected {\n    background-color: #f9f9f9;\n    border: 1px dashed #aaa;\n}\n\n/*\n * Special:ListGroupRights styling\n * Special:Statistics styling\n*/\n\n.mwiki table.mw-listgrouprights-table,\n.mwiki table.mw-statistics-table {\n\tborder: 1px solid #ccc;\n\tborder-collapse: collapse;\n}\n\n.mwiki table.mw-listgrouprights-table tr  {\n\tvertical-align: top;\n}\n\n.mwiki table.mw-listgrouprights-table td, .mwiki table.mw-listgrouprights-table th,\n.mwiki table.mw-statistics-table td, .mwiki table.mw-statistics-table th {\n\tpadding: 0.5em 0.2em 0.5em 0.2em;\n\tborder: 1px solid #ccc;\n}\n\n.mwiki td.mw-statistics-numbers {\n\ttext-align: right;\n}\n\n/* Special:SpecialPages styling */\n.mwiki h4.mw-specialpagesgroup {\n\tbackground-color: #dcdcdc;\n\tpadding: 2px;\n\tmargin: .3em 0em 0em 0em;\n}\n.mwiki .mw-specialpagerestricted {\n\tfont-weight: bold;\n}\n\n.mwiki #shared-image-dup, .mwiki #shared-image-conflict {\n\tfont-style: italic;\n}\n\n/* Special:EmailUser styling */\n.mwiki table.mw-emailuser-table {\n\twidth: 98%;\n}\n.mwiki td#mw-emailuser-sender, .mwiki td#mw-emailuser-recipient {\n\tfont-weight: bold;\n}\n\n/* Special:Prefixindex styling */\n.mwiki table#mw-prefixindex-list-table,\n.mwiki table#mw-prefixindex-nav-table {\n\twidth: 98%;\n\tbackground-color: transparent;\n}\n.mwiki td#mw-prefixindex-nav-form  {\n\tfont-size: smaller;\n\tmargin-bottom: 1em;\n\ttext-align: right;\n\tvertical-align: top;\n}\n\n/*\n * Recreating deleted page warning\n * Reupload file warning\n * Page protection warning\n * incl. log entries for these warnings\n */\n.mwiki div.mw-warning-with-logexcerpt {\n\tpadding: 3px;\n\tmargin-bottom: 3px;\n\tborder: 2px solid #2F6FAB;\n}\n.mwiki div.mw-warning-with-logexcerpt ul li {\n\tfont-size: 90%;\n}\n\n/* (show/hide) revision deletion links */\n.mwiki span.mw-revdelundel-link,\n.mwiki strong.mw-revdelundel-link {\n\tfont-family: monospace;\n\tfont-size: smaller\n}\n\n/* feed links */\n.mwiki a.feedlink {\n\tbackground: url(\"images/feed-icon.png\") center left no-repeat;\n\tpadding-left: 16px;\n}\n\n/************ monobook/main.css **************/\n\n/*\n** MediaWiki 'monobook' style sheet for CSS2-capable browsers.\n** Copyright Gabriel Wicke - http://wikidev.net/\n** License: GPL (http://www.gnu.org/copyleft/gpl.html)\n**\n** Loosely based on http://www.positioniseverything.net/ordered-floats.html by Big John\n** and the Plone 2.0 styles, see http://plone.org/ (Alexander Limi,Joe Geldart & Tom Croucher,\n** Michael Zeltner and Geir Bækholt)\n** All you guys rock :)\n*/\n\n.mwiki #column-content {\n\twidth: 100%;\n\tfloat: right;\n\tmargin: 0 0 .6em -12.2em;\n\tpadding: 0;\n}\n.mwiki #content {\n\tmargin: 2.8em 0 0 12.2em;\n\tpadding: 0 1em 1em 1em;\n\tposition: relative;\n\tz-index: 2;\n}\n.mwiki #column-one {\n\tpadding-top: 160px;\n}\n.mwiki #content {\n\tbackground: white;\n\tcolor: black;\n\tborder: 1px solid #aaa;\n\tborder-right: none;\n\tline-height: 1.5em;\n}\n/* the left column width is specified in class .portlet */\n\n/* Font size:\n** We take advantage of keyword scaling- browsers won't go below 9px\n** More at http://www.w3.org/2003/07/30-font-size\n** http://style.cleverchimp.com/font_size_intervals/altintervals.html\n*/\n\n/*\nbody {\n\tfont: x-small sans-serif;\n\tbackground: #f9f9f9 url(headbg.jpg) 0 0 no-repeat;\n\tcolor: black;\n\tmargin: 0;\n\tpadding: 0;\n}\n*/\n\n/* scale back up to a sane default */\n.mwiki #globalWrapper {\n\tfont-size: 127%;\n\twidth: 100%;\n\tmargin: 0;\n\tpadding: 0;\n}\n.mwiki .visualClear {\n\tclear: both;\n}\n\n/* general styles */\n\n.mwiki table {\n\tfont-size: 100%;\n\tcolor: black;\n\t/* we don't want the bottom borders of <h2>s to be visible through\n\t   floated tables */\n\tbackground-color: white;\n}\n.mwiki fieldset table {\n\t/* but keep table layouts in forms clean... */\n\tbackground: none;\n}\n.mwiki a {\n\ttext-decoration: none;\n\tcolor: #002bb8;\n\tbackground: none;\n}\n.mwiki a:visited {\n\tcolor: #5a3696;\n}\n.mwiki a:active {\n\tcolor: #faa700;\n}\n.mwiki a:hover {\n\ttext-decoration: underline;\n}\n.mwiki a.stub {\n\tcolor: #772233;\n}\n.mwiki a.new, .mwiki #p-personal a.new {\n\tcolor: #ba0000;\n}\n.mwiki a.new:visited, .mwiki #p-personal a.new:visited {\n\tcolor: #a55858;\n}\n\n.mwiki img {\n\tborder: none;\n\tvertical-align: middle;\n}\n.mwiki p {\n\tmargin: .4em 0 .5em 0;\n\tline-height: 1.5em;\n}\n.mwiki p img {\n\tmargin: 0;\n}\n\n.mwiki hr {\n\theight: 1px;\n\tcolor: #aaa;\n\tbackground-color: #aaa;\n\tborder: 0;\n\tmargin: .2em 0 .2em 0;\n}\n\n.mwiki h1, .mwiki h2, .mwiki h3, .mwiki h4, .mwiki h5, .mwiki h6 {\n\tcolor: black;\n\tbackground: none;\n\tfont-weight: normal;\n\tmargin: 0;\n\tpadding-top: .5em;\n\tpadding-bottom: .17em;\n\tborder-bottom: 1px solid #aaa;\n}\n.mwiki h1 { font-size: 188%; }\n.mwiki h1 .editsection { font-size: 53%; }\n.mwiki h2 { font-size: 150%; }\n.mwiki h2 .editsection { font-size: 67%; }\n.mwiki h3, .mwiki h4, .mwiki h5, .mwiki h6 {\n\tborder-bottom: none;\n\tfont-weight: bold;\n}\n.mwiki h3 { font-size: 132%; }\n.mwiki h3 .editsection { font-size: 76%; font-weight: normal; }\n.mwiki h4 { font-size: 116%; }\n.mwiki h4 .editsection { font-size: 86%; font-weight: normal; }\n.mwiki h5 { font-size: 100%; }\n.mwiki h5 .editsection { font-weight: normal; }\n.mwiki h6 { font-size: 80%;  }\n.mwiki h6 .editsection { font-size: 125%; font-weight: normal; }\n\n.mwiki ul {\n\tline-height: 1.5em;\n\tlist-style-type: square;\n\tmargin: .3em 0 0 1.5em;\n\tpadding: 0;\n\tlist-style-image: url(bullet.gif);\n}\n.mwiki ol {\n\tline-height: 1.5em;\n\tmargin: .3em 0 0 3.2em;\n\tpadding: 0;\n\tlist-style-image: none;\n}\n.mwiki li {\n\tmargin-bottom: .1em;\n}\n.mwiki dt {\n\tfont-weight: bold;\n\tmargin-bottom: .1em;\n}\n.mwiki dl {\n\tmargin-top: .2em;\n\tmargin-bottom: .5em;\n}\n.mwiki dd {\n\tline-height: 1.5em;\n\tmargin-left: 2em;\n\tmargin-bottom: .1em;\n}\n\n.mwiki fieldset {\n\tborder: 1px solid #2f6fab;\n\tmargin: 1em 0 1em 0;\n\tpadding: 0 1em 1em;\n\tline-height: 1.5em;\n}\n.mwiki fieldset.nested {\n\tmargin: 0 0 0.5em 0;\n\tpadding: 0 0.5em 0.5em;\n}\n.mwiki legend {\n\tpadding: .5em;\n\tfont-size: 95%;\n}\n.mwiki form {\n\tborder: none;\n\tmargin: 0;\n}\n\n.mwiki textarea {\n\twidth: 100%;\n\tpadding: .1em;\n}\n\n.mwiki input.historysubmit {\n\tpadding: 0 .3em .3em .3em !important;\n\tfont-size: 94%;\n\tcursor: pointer;\n\theight: 1.7em !important;\n\tmargin-left: 1.6em;\n}\n.mwiki select {\n\tvertical-align: top;\n}\n.mwiki abbr, .mwiki acronym, .mwiki .explain {\n\tborder-bottom: 1px dotted black;\n\tcolor: black;\n\tbackground: none;\n\tcursor: help;\n}\n.mwiki q {\n\tfont-family: Times, \"Times New Roman\", serif;\n\tfont-style: italic;\n}\n/* disabled for now\n.mwiki blockquote {\n\tfont-family: Times, \"Times New Roman\", serif;\n\tfont-style: italic;\n}*/\n.mwiki code {\n\tbackground-color: #f9f9f9;\n}\n.mwiki pre {\n\tpadding: 1em;\n\tborder: 1px dashed #2f6fab;\n\tcolor: black;\n\tbackground-color: #f9f9f9;\n\tline-height: 1.1em;\n}\n\n/*\n** the main content area\n*/\n\n.mwiki #siteSub {\n\tdisplay: none;\n}\n.mwiki #jump-to-nav {\n\tdisplay: none;\n}\n\n.mwiki #contentSub, .mwiki #contentSub2 {\n\tfont-size: 84%;\n\tline-height: 1.2em;\n\tmargin: 0 0 1.4em 1em;\n\tcolor: #7d7d7d;\n\twidth: auto;\n}\n.mwiki span.subpages {\n\tdisplay: block;\n}\n\n/* Some space under the headers in the content area */\n.mwiki #bodyContent h1, .mwiki #bodyContent h2 {\n\tmargin-bottom: .6em;\n}\n.mwiki #bodyContent h3, .mwiki #bodyContent h4, .mwiki #bodyContent h5 {\n\tmargin-bottom: .3em;\n}\n.mwiki #firstHeading {\n\tmargin-bottom: .1em;\n\t/* These two rules hack around bug 2013 (fix for more limited bug 11325).\n\t   When bug 2013 is fixed properly, they should be removed. */\n\tline-height: 1.2em;\n\tpadding-bottom: 0;\n}\n\n/* user notification thing */\n.mwiki .usermessage {\n\tbackground-color: #ffce7b;\n\tborder: 1px solid #ffa500;\n\tcolor: black;\n\tfont-weight: bold;\n\tmargin: 2em 0 1em;\n\tpadding: .5em 1em;\n\tvertical-align: middle;\n}\n.mwiki #siteNotice {\n\ttext-align: center;\n\tfont-size: 95%;\n\tpadding: 0 .9em;\n}\n.mwiki #siteNotice p {\n\tmargin: 0;\n\tpadding: 0;\n}\n.mwiki .success {\n\tcolor: green;\n\tfont-size: larger;\n}\n.mwiki .error {\n\tcolor: red;\n\tfont-size: larger;\n}\n.mwiki .errorbox, .mwiki .successbox {\n\tfont-size: larger;\n\tborder: 2px solid;\n\tpadding: .5em 1em;\n\tfloat: left;\n\tmargin-bottom: 2em;\n\tcolor: #000;\n}\n.mwiki .errorbox {\n\tborder-color: red;\n\tbackground-color: #fff2f2;\n}\n.mwiki .successbox {\n\tborder-color: green;\n\tbackground-color: #dfd;\n}\n.mwiki .errorbox h2, .mwiki .successbox h2 {\n\tfont-size: 1em;\n\tfont-weight: bold;\n\tdisplay: inline;\n\tmargin: 0 .5em 0 0;\n\tborder: none;\n}\n\n.mwiki .catlinks {\n\tborder: 1px solid #aaa;\n\tbackground-color: #f9f9f9;\n\tpadding: 5px;\n\tmargin-top: 1em;\n\tclear: both;\n}\n/* currently unused, intended to be used by a metadata box\nin the bottom-right corner of the content area */\n.mwiki .documentDescription {\n\t/* The summary text describing the document */\n\tfont-weight: bold;\n\tdisplay: block;\n\tmargin: 1em 0;\n\tline-height: 1.5em;\n}\n.mwiki .documentByLine {\n\ttext-align: right;\n\tfont-size: 90%;\n\tclear: both;\n\tfont-weight: normal;\n\tcolor: #76797c;\n}\n\n/* emulate center */\n.mwiki .center {\n\twidth: 100%;\n\ttext-align: center;\n}\n.mwiki *.center * {\n\tmargin-left: auto;\n\tmargin-right: auto;\n}\n/* small for tables and similar */\n.mwiki .small, .mwiki .small * {\n\tfont-size: 94%;\n}\n.mwiki table.small {\n\tfont-size: 100%;\n}\n\n/*\n** content styles\n*/\n\n.mwiki #toc,\n.mwiki .toc,\n.mwiki .mw-warning {\n\tborder: 1px solid #aaa;\n\tbackground-color: #f9f9f9;\n\tpadding: 5px;\n\tfont-size: 95%;\n}\n.mwiki #toc h2,\n.mwiki .toc h2 {\n\tdisplay: inline;\n\tborder: none;\n\tpadding: 0;\n\tfont-size: 100%;\n\tfont-weight: bold;\n}\n.mwiki #toc #toctitle,\n.mwiki .toc #toctitle,\n.mwiki #toc .toctitle,\n.mwiki .toc .toctitle {\n\ttext-align: center;\n}\n.mwiki #toc ul,\n.mwiki .toc ul {\n\tlist-style-type: none;\n\tlist-style-image: none;\n\tmargin-left: 0;\n\tpadding-left: 0;\n\ttext-align: left;\n}\n.mwiki #toc ul ul,\n.mwiki .toc ul ul {\n\tmargin: 0 0 0 2em;\n}\n.mwiki #toc .toctoggle,\n.mwiki .toc .toctoggle {\n\tfont-size: 94%;\n}\n\n.mwiki .mw-warning {\n\tmargin-left: 50px;\n\tmargin-right: 50px;\n\ttext-align: center;\n}\n\n/* images */\n.mwiki div.floatright, .mwiki table.floatright {\n\tclear: right;\n\tfloat: right;\n\tposition: relative;\n\tmargin: 0 0 .5em .5em;\n\tborder: 0;\n/*\n\tborder: .5em solid white;\n\tborder-width: .5em 0 .8em 1.4em;\n*/\n}\n.mwiki div.floatright p { font-style: italic; }\n.mwiki div.floatleft, .mwiki table.floatleft {\n\tfloat: left;\n\tclear: left;\n\tposition: relative;\n\tmargin: 0 .5em .5em 0;\n\tborder: 0;\n/*\n\tmargin: .3em .5em .5em 0;\n\tborder: .5em solid white;\n\tborder-width: .5em 1.4em .8em 0;\n*/\n}\n.mwiki div.floatleft p { font-style: italic; }\n/* thumbnails */\n.mwiki div.thumb {\n\tmargin-bottom: .5em;\n\tborder-style: solid;\n\tborder-color: white;\n\twidth: auto;\n}\n.mwiki div.thumbinner {\n\tborder: 1px solid #ccc;\n\tpadding: 3px !important;\n\tbackground-color: #f9f9f9;\n\tfont-size: 94%;\n\ttext-align: center;\n\toverflow: hidden;\n}\n.mwiki html .thumbimage {\n\tborder: 1px solid #ccc;\n}\n.mwiki html .thumbcaption {\n\tborder: none;\n\ttext-align: left;\n\tline-height: 1.4em;\n\tpadding: 3px !important;\n\tfont-size: 94%;\n}\n.mwiki div.magnify {\n\tfloat: right;\n\tborder: none !important;\n\tbackground: none !important;\n}\n.mwiki div.magnify a, .mwiki div.magnify img {\n\tdisplay: block;\n\tborder: none !important;\n\tbackground: none !important;\n}\n.mwiki div.tright {\n\tclear: right;\n\tfloat: right;\n\tborder-width: .5em 0 .8em 1.4em;\n}\n.mwiki div.tleft {\n\tfloat: left;\n\tclear: left;\n\tmargin-right: .5em;\n\tborder-width: .5em 1.4em .8em 0;\n}\n.mwiki img.thumbborder {\n\tborder: 1px solid #dddddd;\n}\n.mwiki .hiddenStructure {\n\tdisplay: none;\n}\n\n/*\n** classes for special content elements like town boxes\n** intended to be referenced directly from the wiki src\n*/\n\n/*\n** User styles\n*/\n/* table standards */\n.mwiki table.rimage {\n\tfloat: right;\n\tposition: relative;\n\tmargin-left: 1em;\n\tmargin-bottom: 1em;\n\ttext-align: center;\n}\n.mwiki .toccolours {\n\tborder: 1px solid #aaa;\n\tbackground-color: #f9f9f9;\n\tpadding: 5px;\n\tfont-size: 95%;\n}\n\n/*\n** edit views etc\n*/\n.mwiki .special li {\n\tline-height: 1.4em;\n\tmargin: 0;\n\tpadding: 0;\n}\n\n/*\n** keep the whitespace in front of the ^=, hides rule from konqueror\n** this is css3, the validator doesn't like it when validating as css2\n*/\n.mwiki #bodyContent a.external,\n.mwiki #bodyContent a[href ^=\"gopher://\"] {\n\tbackground: url(external.png) center right no-repeat;\n\tpadding-right: 13px;\n}\n.mwiki #bodyContent a[href ^=\"https://\"],\n.mwiki .link-https {\n\tbackground: url(lock_icon.gif) center right no-repeat;\n\tpadding-right: 16px;\n}\n.mwiki #bodyContent a[href ^=\"mailto:\"],\n.mwiki .link-mailto {\n\tbackground: url(mail_icon.gif) center right no-repeat;\n\tpadding-right: 18px;\n}\n.mwiki #bodyContent a[href ^=\"news://\"] {\n\tbackground: url(news_icon.png) center right no-repeat;\n\tpadding-right: 18px;\n}\n.mwiki #bodyContent a[href ^=\"ftp://\"],\n.mwiki .link-ftp {\n\tbackground: url(file_icon.gif) center right no-repeat;\n\tpadding-right: 18px;\n}\n.mwiki #bodyContent a[href ^=\"irc://\"],\n.mwiki #bodyContent a.extiw[href ^=\"irc://\"],\n.mwiki .link-irc {\n\tbackground: url(discussionitem_icon.gif) center right no-repeat;\n\tpadding-right: 18px;\n}\n.mwiki #bodyContent a.external[href $=\".ogg\"], .mwiki #bodyContent a.external[href $=\".OGG\"],\n.mwiki #bodyContent a.external[href $=\".oga\"], .mwiki #bodyContent a.external[href $=\".OGA\"],\n.mwiki #bodyContent a.external[href $=\".mid\"], .mwiki #bodyContent a.external[href $=\".MID\"],\n.mwiki #bodyContent a.external[href $=\".midi\"], .mwiki #bodyContent a.external[href $=\".MIDI\"],\n.mwiki #bodyContent a.external[href $=\".mp3\"], .mwiki #bodyContent a.external[href $=\".MP3\"],\n.mwiki #bodyContent a.external[href $=\".wav\"], .mwiki #bodyContent a.external[href $=\".WAV\"],\n.mwiki #bodyContent a.external[href $=\".wma\"], .mwiki #bodyContent a.external[href $=\".WMA\"],\n.mwiki .link-audio {\n\tbackground: url(\"audio.png\") center right no-repeat;\n\tpadding-right: 13px;\n}\n.mwiki #bodyContent a.external[href $=\".ogm\"], .mwiki #bodyContent a.external[href $=\".OGM\"],\n.mwiki #bodyContent a.external[href $=\".avi\"], .mwiki #bodyContent a.external[href $=\".AVI\"],\n.mwiki #bodyContent a.external[href $=\".mpeg\"], .mwiki #bodyContent a.external[href $=\".MPEG\"],\n.mwiki #bodyContent a.external[href $=\".mpg\"], .mwiki #bodyContent a.external[href $=\".MPG\"],\n.mwiki .link-video {\n\tbackground: url(\"video.png\") center right no-repeat;\n\tpadding-right: 13px;\n}\n.mwiki #bodyContent a.external[href $=\".pdf\"], .mwiki #bodyContent a.external[href $=\".PDF\"],\n.mwiki #bodyContent a.external[href *=\".pdf#\"], .mwiki #bodyContent a.external[href *=\".PDF#\"],\n.mwiki #bodyContent a.external[href *=\".pdf?\"], .mwiki #bodyContent a.external[href *=\".PDF?\"],\n.mwiki .link-document {\n\tbackground: url(\"document.png\") center right no-repeat;\n\tpadding-right: 12px;\n}\n\n/* disable interwiki styling */\n.mwiki #bodyContent a.extiw,\n.mwiki #bodyContent a.extiw:active {\n\tcolor: #36b;\n\tbackground: none;\n\tpadding: 0;\n}\n.mwiki #bodyContent a.external {\n\tcolor: #36b;\n}\n/* this can be used in the content area to switch off\nspecial external link styling */\n.mwiki #bodyContent .plainlinks a {\n\tbackground: none !important;\n\tpadding: 0 !important;\n}\n/*\n** Structural Elements\n*/\n\n/*\n** general portlet styles (elements in the quickbar)\n*/\n.mwiki .portlet {\n\tborder: none;\n\tmargin: 0 0 .5em;\n\tpadding: 0;\n\tfloat: none;\n\twidth: 11.6em;\n\toverflow: hidden;\n}\n.mwiki .portlet h4 {\n\tfont-size: 95%;\n\tfont-weight: normal;\n\twhite-space: nowrap;\n}\n.mwiki .portlet h5 {\n\tbackground: transparent;\n\tpadding: 0 1em 0 .5em;\n\tdisplay: inline;\n\theight: 1em;\n\ttext-transform: lowercase;\n\tfont-size: 91%;\n\tfont-weight: normal;\n\twhite-space: nowrap;\n}\n.mwiki .portlet h6 {\n\tbackground: #ffae2e;\n\tborder: 1px solid #2f6fab;\n\tborder-style: solid solid none solid;\n\tpadding: 0 1em 0 1em;\n\ttext-transform: lowercase;\n\tdisplay: block;\n\tfont-size: 1em;\n\theight: 1.2em;\n\tfont-weight: normal;\n\twhite-space: nowrap;\n}\n.mwiki .pBody {\n\tfont-size: 95%;\n\tbackground-color: white;\n\tcolor: black;\n\tborder-collapse: collapse;\n\tborder: 1px solid #aaa;\n\tpadding: 0 .8em .3em .5em;\n}\n.mwiki .portlet h1,\n.mwiki .portlet h2,\n.mwiki .portlet h3,\n.mwiki .portlet h4 {\n\tmargin: 0;\n\tpadding: 0;\n}\n.mwiki .portlet ul {\n\tline-height: 1.5em;\n\tlist-style-type: square;\n\tlist-style-image: url(bullet.gif);\n\tfont-size: 95%;\n}\n.mwiki .portlet li {\n\tpadding: 0;\n\tmargin: 0;\n}\n\n/*\n** Logo properties\n*/\n\n.mwiki #p-logo {\n\ttop: 0;\n\tleft: 0;\n\tposition: absolute; /*needed to use z-index */\n\tz-index: 3;\n\theight: 155px;\n\twidth: 12em;\n\toverflow: visible;\n}\n.mwiki #p-logo h5 {\n\tdisplay: none;\n}\n.mwiki #p-logo a,\n.mwiki #p-logo a:hover {\n\tdisplay: block;\n\theight: 155px;\n\twidth: 12.2em;\n\tbackground-repeat: no-repeat;\n\tbackground-position: 35% 50% !important;\n\ttext-decoration: none;\n}\n\n/*\n** Search portlet\n*/\n.mwiki #p-search {\n\tposition: relative;\n\tz-index: 3;\n}\n.mwiki input.searchButton {\n\tmargin-top: 1px;\n\tfont-size: 95%;\n}\n.mwiki #searchGoButton {\n\tpadding-left: .5em;\n\tpadding-right: .5em;\n\tfont-weight: bold;\n}\n.mwiki #searchInput {\n\twidth: 10.9em;\n\tmargin: 0;\n\tfont-size: 95%;\n}\n.mwiki #p-search .pBody {\n\tpadding: .5em .4em .4em .4em;\n\ttext-align: center;\n}\n.mwiki #p-search #searchform div div {\n\tmargin-top: .4em;\n\tfont-size: 95%;\n}\n/*\n** the personal toolbar\n*/\n.mwiki #p-personal {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tz-index: 0;\n}\n.mwiki #p-personal {\n\twidth: 100%;\n\twhite-space: nowrap;\n\tpadding: 0;\n\tmargin: 0;\n\tborder: none;\n\tbackground: none;\n\toverflow: visible;\n\tline-height: 1.2em;\n}\n.mwiki #p-personal h5 {\n\tdisplay: none;\n}\n.mwiki #p-personal .portlet,\n.mwiki #p-personal .pBody {\n\tz-index: 0;\n\tpadding: 0;\n\tmargin: 0;\n\tborder: none;\n\toverflow: visible;\n\tbackground: none;\n}\n/* this is the ul contained in the portlet */\n.mwiki #p-personal ul {\n\tborder: none;\n\tline-height: 1.4em;\n\tcolor: #2f6fab;\n\tpadding: 0 2em 0 3em;\n\tmargin: 0;\n\ttext-align: right;\n\tlist-style: none;\n\tz-index: 0;\n\tbackground: none;\n\tcursor: default;\n}\n.mwiki #p-personal li {\n\tz-index: 0;\n\tborder: none;\n\tpadding: 0;\n\tdisplay: inline;\n\tcolor: #2f6fab;\n\tmargin-left: 1em;\n\tline-height: 1.2em;\n\tbackground: none;\n}\n.mwiki #p-personal li a {\n\ttext-decoration: none;\n\tcolor: #005896;\n\tpadding-bottom: .2em;\n\tbackground: none;\n}\n.mwiki #p-personal li a:hover {\n\tbackground-color: white;\n\tpadding-bottom: .2em;\n\ttext-decoration: none;\n}\n.mwiki #p-personal li.active a:hover {\n\tbackground-color: transparent;\n}\n/* the icon in front of the user name, single quotes\nin bg url to hide it from iemac */\n.mwiki li#pt-userpage,\n.mwiki li#pt-anonuserpage,\n.mwiki li#pt-login {\n\tbackground: url(user.gif) top left no-repeat;\n\tpadding-left: 20px;\n\ttext-transform: none;\n}\n.mwiki #p-personal ul {\n\ttext-transform: lowercase;\n}\n.mwiki #p-personal li.active {\n\tfont-weight: bold;\n}\n/*\n** the page-related actions- page/talk, edit etc\n*/\n.mwiki #p-cactions {\n\tposition: absolute;\n\ttop: 1.3em;\n\tleft: 11.5em;\n\tmargin: 0;\n\twhite-space: nowrap;\n\twidth: 76%;\n\tline-height: 1.1em;\n\toverflow: visible;\n\tbackground: none;\n\tborder-collapse: collapse;\n\tpadding-left: 1em;\n\tlist-style: none;\n\tfont-size: 95%;\n}\n.mwiki #p-cactions ul {\n\tlist-style: none;\n}\n.mwiki #p-cactions li {\n\tdisplay: inline;\n\tborder: 1px solid #aaa;\n\tborder-bottom: none;\n\tpadding: 0 0 .1em 0;\n\tmargin: 0 .3em 0 0;\n\toverflow: visible;\n\tbackground: white;\n}\n.mwiki #p-cactions li.selected {\n\tborder-color: #fabd23;\n\tpadding: 0 0 .2em 0;\n\tfont-weight: bold;\n}\n.mwiki #p-cactions li a {\n\tbackground-color: #fbfbfb;\n\tcolor: #002bb8;\n\tborder: none;\n\tpadding: 0 .8em .3em;\n\tposition: relative;\n\tz-index: 0;\n\tmargin: 0;\n\ttext-decoration: none;\n}\n.mwiki #p-cactions li.selected a {\n\tz-index: 3;\n\tpadding: 0 1em .2em!important;\n\tbackground-color: white;\n}\n.mwiki #p-cactions .new a {\n\tcolor: #ba0000;\n}\n.mwiki #p-cactions li a:hover {\n\tz-index: 3;\n\ttext-decoration: none;\n\tbackground-color: white;\n}\n.mwiki #p-cactions h5 {\n\tdisplay: none;\n}\n.mwiki #p-cactions li.istalk {\n\tmargin-right: 0;\n}\n.mwiki #p-cactions li.istalk a {\n\tpadding-right: .5em;\n}\n.mwiki #p-cactions #ca-addsection a {\n\tpadding-left: .4em;\n\tpadding-right: .4em;\n}\n/* offsets to distinguish the tab groups */\n.mwiki li#ca-talk {\n\tmargin-right: 1.6em;\n}\n.mwiki li#ca-watch, .mwiki li#ca-unwatch, .mwiki li#ca-varlang-0, .mwiki li#ca-print {\n\tmargin-left: 1.6em;\n}\n.mwiki #p-cactions .pBody {\n\tfont-size: 1em;\n\tbackground-color: transparent;\n\tcolor: inherit;\n\tborder-collapse: inherit;\n\tborder: 0;\n\tpadding: 0;\n}\n.mwiki #p-cactions .hiddenStructure {\n\tdisplay: none;\n}\n.mwiki #p-cactions li a {\n\ttext-transform: lowercase;\n}\n\n.mwiki #p-lang {\n\tposition: relative;\n\tz-index: 3;\n}\n\n/* TODO: #t-iscite is only used by the Cite extension, come up with some\n * system which allows extensions to add to this file on the fly\n */\n.mwiki #t-ispermalink, .mwiki #t-iscite {\n\tcolor: #999;\n}\n/*\n** footer\n*/\n.mwiki #footer {\n\tbackground-color: white;\n\tborder-top: 1px solid #fabd23;\n\tborder-bottom: 1px solid #fabd23;\n\tmargin: .6em 0 1em 0;\n\tpadding: .4em 0 1.2em 0;\n\ttext-align: center;\n\tfont-size: 90%;\n}\n.mwiki #footer li {\n\tdisplay: inline;\n\tmargin: 0 1.3em;\n}\n.mwiki #f-poweredbyico, .mwiki #f-copyrightico {\n\tmargin: 0 8px;\n\tposition: relative;\n\ttop: -2px; /* Bump it up just a tad */\n}\n.mwiki #f-poweredbyico {\n\tfloat: right;\n\theight: 1%;\n}\n.mwiki #f-copyrightico {\n\tfloat: left;\n\theight: 1%;\n}\n\n/* js pref toc */\n.mwiki #preftoc {\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 100%;\n\tclear: both;\n}\n.mwiki #preftoc li {\n\tbackground-color: #f0f0f0;\n\tcolor: #000;\n}\n.mwiki #preftoc li {\n\tmargin: 1px -2px 1px 2px;\n\tfloat: left;\n\tpadding: 2px 0 3px 0;\n\tborder: 1px solid #fff;\n\tborder-right-color: #716f64;\n\tborder-bottom: 0;\n\tposition: relative;\n\twhite-space: nowrap;\n\tlist-style-type: none;\n\tlist-style-image: none;\n\tz-index: 3;\n}\n.mwiki #preftoc li.selected {\n\tfont-weight: bold;\n\tbackground-color: #f9f9f9;\n\tborder: 1px solid #aaa;\n\tborder-bottom: none;\n\tcursor: default;\n\ttop: 1px;\n\tpadding-top: 2px;\n\tmargin-right: -3px;\n}\n.mwiki #preftoc > li.selected {\n\ttop: 2px;\n}\n.mwiki #preftoc a,\n.mwiki #preftoc a:active {\n\tdisplay: block;\n\tcolor: #000;\n\tpadding: 0 .7em;\n\tposition: relative;\n\ttext-decoration: none;\n}\n.mwiki #preftoc li.selected a {\n\tcursor: default;\n\ttext-decoration: none;\n}\n.mwiki #prefcontrol {\n\tpadding-top: 2em;\n\tclear: both;\n}\n.mwiki #preferences {\n\tmargin: 0;\n\tborder: 1px solid #aaa;\n\tclear: both;\n\tpadding: 1.5em;\n\tbackground-color: #F9F9F9;\n}\n.mwiki .prefsection {\n\tborder: none;\n\tpadding: 0;\n\tmargin: 0;\n}\n.mwiki .prefsection fieldset {\n\tborder: 1px solid #aaa;\n\tfloat: left;\n\tmargin-right: 2em;\n}\n.mwiki .prefsection legend {\n\tfont-weight: bold;\n}\n.mwiki .prefsection table, .mwiki .prefsection legend {\n\tbackground-color: #F9F9F9;\n}\n.mwiki .mainLegend {\n\tdisplay: none;\n}\n.mwiki div.prefsectiontip {\n\tfont-size: x-small;\n\tpadding: .2em 2em;\n\tcolor: #666;\n}\n.mwiki .btnSavePrefs {\n\tfont-weight: bold;\n\tpadding-left: .3em;\n\tpadding-right: .3em;\n}\n\n.mwiki .preferences-login {\n\tclear: both;\n\tmargin-bottom: 1.5em;\n}\n\n.mwiki .prefcache {\n\tfont-size: 90%;\n\tmargin-top: 2em;\n}\n\n.mwiki div#userloginForm form,\n.mwiki div#userlogin form#userlogin2 {\n\tmargin: 0 3em 1em 0;\n\tborder: 1px solid #aaa;\n\tclear: both;\n\tpadding: 1.5em 2em;\n\tbackground-color: #f9f9f9;\n\tfloat: left;\n}\n.mwiki .rtl div#userloginForm form,\n.mwiki .rtl div#userlogin form#userlogin2 {\n\tfloat: right;\n}\n\n.mwiki div#userloginForm table,\n.mwiki div#userlogin form#userlogin2 table {\n\tbackground-color: #f9f9f9;\n}\n\n.mwiki div#userloginForm h2,\n.mwiki div#userlogin form#userlogin2 h2 {\n\tpadding-top: 0;\n}\n\n.mwiki div#userlogin .captcha,\n.mwiki div#userloginForm .captcha {\n\tborder: 1px solid #bbb;\n\tpadding: 1.5em 2em;\n\tbackground-color: white;\n}\n\n.mwiki #loginend, .mwiki #signupend {\n\tclear: both;\n}\n\n.mwiki #userloginprompt, .mwiki #languagelinks {\n\tfont-size: 85%;\n}\n\n.mwiki #login-sectiontip {\n\tfont-size: 85%;\n\tline-height: 1.2;\n\tpadding-top: 2em;\n}\n\n.mwiki #userlogin .loginText, .mwiki #userlogin .loginPassword {\n\twidth: 12em;\n}\n\n.mwiki #userloginlink a, .mwiki #wpLoginattempt, .mwiki #wpCreateaccount {\n\tfont-weight: bold;\n}\n\n\n/* IE/Mac fixes were cut out */\n\n.mwiki .redirectText {\n\tfont-size: 150%;\n\tmargin: 5px;\n}\n\n.mwiki .printfooter {\n\tdisplay: none;\n}\n\n.mwiki .not-patrolled {\n\tbackground-color: #ffa;\n}\n.mwiki div.patrollink {\n\tclear: both;\n\tfont-size: 75%;\n\ttext-align: right;\n}\n.mwiki span.newpage, .mwiki span.minor, .mwiki span.bot {\n\tfont-weight: bold;\n}\n.mwiki span.unpatrolled {\n\tfont-weight: bold;\n\tcolor: red;\n}\n\n.mwiki .sharedUploadNotice {\n\tfont-style: italic;\n}\n\n.mwiki span.updatedmarker {\n\tcolor: black;\n\tbackground-color: #0f0;\n}\n\n.mwiki table.gallery {\n\tborder: 1px solid #ccc;\n\tmargin: 2px;\n\tpadding: 2px;\n\tbackground-color: white;\n}\n\n.mwiki table.gallery tr {\n\tvertical-align: top;\n}\n\n.mwiki table.gallery td {\n\tvertical-align: top;\n\tbackground-color: #f9f9f9;\n\tborder: solid 2px white;\n}\n/* Keep this temporarily so that cached pages will display right */\n.mwiki table.gallery td.galleryheader {\n    text-align: center;\n\tfont-weight: bold;\n}\n.mwiki table.gallery caption {\n\tfont-weight: bold;\n}\n\n.mwiki div.gallerybox {\n\tmargin: 2px;\n}\n\n.mwiki div.gallerybox div.thumb {\n\ttext-align: center;\n\tborder: 1px solid #ccc;\n\tmargin: 2px;\n}\n\n.mwiki div.gallerytext {\n\toverflow: hidden;\n\tfont-size: 94%;\n\tpadding: 2px 4px;\n}\n\n.mwiki span.comment {\n\tfont-style: italic;\n}\n\n.mwiki span.changedby {\n\tfont-size: 95%;\n}\n\n.mwiki .previewnote {\n\ttext-indent: 3em;\n\tcolor: #c00;\n\tborder-bottom: 1px solid #aaa;\n\tpadding-bottom: 1em;\n\tmargin-bottom: 1em;\n}\n\n.mwiki .previewnote p {\n\tmargin: 0;\n\tpadding: 0;\n}\n\n.mwiki .editExternally {\n\tborder: 1px solid gray;\n\tbackground-color: #ffffff;\n\tpadding: 3px;\n\tmargin-top: 0.5em;\n\tfloat: left;\n\tfont-size: small;\n\ttext-align: center;\n}\n.mwiki .editExternallyHelp {\n\tfont-style: italic;\n\tcolor: gray;\n}\n\n.mwiki .toggle {\n\tmargin-left: 2em;\n\ttext-indent: -2em;\n}\n\n/* Classes for EXIF data display */\n.mwiki table.mw_metadata {\n\tfont-size: 0.8em;\n\tmargin-left: 0.5em;\n\tmargin-bottom: 0.5em;\n\twidth: 300px;\n}\n\n.mwiki table.mw_metadata caption {\n\tfont-weight: bold;\n}\n\n.mwiki table.mw_metadata th {\n\tfont-weight: normal;\n}\n\n.mwiki table.mw_metadata td {\n\tpadding: 0.1em;\n}\n\n.mwiki table.mw_metadata {\n\tborder: none;\n\tborder-collapse: collapse;\n}\n\n.mwiki table.mw_metadata td, .mwiki table.mw_metadata th {\n\ttext-align: center;\n\tborder: 1px solid #aaaaaa;\n\tpadding-left: 0.1em;\n\tpadding-right: 0.1em;\n}\n\n.mwiki table.mw_metadata th {\n\tbackground-color: #f9f9f9;\n}\n\n.mwiki table.mw_metadata td {\n\tbackground-color: #fcfcfc;\n}\n\n.mwiki table.collapsed tr.collapsable {\n\tdisplay: none;\n}\n\n\n/* filetoc */\n.mwiki ul#filetoc {\n\ttext-align: center;\n\tborder: 1px solid #aaaaaa;\n\tbackground-color: #f9f9f9;\n\tpadding: 5px;\n\tfont-size: 95%;\n\tmargin-bottom: 0.5em;\n\tmargin-left: 0;\n\tmargin-right: 0;\n}\n\n.mwiki #filetoc li {\n\tdisplay: inline;\n\tlist-style-type: none;\n\tpadding-right: 2em;\n}\n\n.mwiki input#wpSummary {\n\twidth: 80%;\n}\n\n/* @bug 1714 */\n.mwiki input#wpSave, .mwiki input#wpDiff {\n\tmargin-right: 0.33em;\n}\n\n.mwiki #wpSave {\n\tfont-weight: bold;\n}\n\n/* Classes for article validation */\n\n.mwiki table.revisionform_default {\n\tborder: 1px solid #000000;\n}\n\n.mwiki table.revisionform_focus {\n\tborder: 1px solid #000000;\n\tbackground-color:#00BBFF;\n}\n\n.mwiki tr.revision_tr_default {\n\tbackground-color:#EEEEEE;\n}\n\n.mwiki tr.revision_tr_first {\n\tbackground-color:#DDDDDD;\n}\n\n.mwiki p.revision_saved {\n\tcolor: green;\n\tfont-weight:bold;\n}\n\n.mwiki #mw_trackbacks {\n\tborder: solid 1px #bbbbff;\n\tbackground-color: #eeeeff;\n\tpadding: 0.2em;\n}\n\n\n/* Allmessages table */\n\n.mwiki #allmessagestable th {\n\tbackground-color: #b2b2ff;\n}\n\n.mwiki #allmessagestable tr.orig {\n\tbackground-color: #ffe2e2;\n}\n\n.mwiki #allmessagestable tr.new {\n\tbackground-color: #e2ffe2;\n}\n\n.mwiki #allmessagestable tr.def {\n\tbackground-color: #f0f0ff;\n}\n\n\n/* noarticletext */\n.mwiki div.noarticletext {\n\tborder: 1px solid #ccc;\n\tbackground: #fff;\n\tpadding: .2em 1em;\n\tcolor: #000;\n}\n\n.mwiki div#searchTargetContainer {\n\tleft:       10px;\n\ttop:        10px;\n\twidth:      90%;\n\tbackground: white;\n}\n\n.mwiki div#searchTarget {\n\tpadding:    3px;\n\tmargin:     5px;\n\tbackground: #F0F0F0;\n\tborder:     solid 1px blue;\n}\n\n.mwiki div#searchTarget ul li {\n\tlist-style: none;\n}\n\n.mwiki div#searchTarget ul li:before {\n\tcolor: orange;\n\tcontent: \"\\00BB \\0020\";\n}\n\n.mwiki div#searchTargetHide {\n\tfloat:right;\n\tborder:solid 1px black;\n\tbackground:#DCDCDC;\n\tpadding:2px;\n}\n\n.mwiki #powersearch p {\n\tmargin-top:0px;\n}\n\n.mwiki div.multipageimagenavbox {\n   border: solid 1px silver;\n   padding: 4px;\n   margin: 1em;\n   background: #f0f0f0;\n}\n\n.mwiki div.multipageimagenavbox div.thumb {\n   border: none;\n   margin-left: 2em;\n   margin-right: 2em;\n}\n\n.mwiki div.multipageimagenavbox hr {\n   margin: 6px;\n}\n\n.mwiki table.multipageimage td {\n   text-align: center;\n}\n\n/** Special:Version */\n\n.mwiki table#sv-ext, table#sv-hooks, .mwiki table#sv-software {\n\tmargin: 1em;\n\tpadding:0em;\n}\n\n.mwiki #sv-ext td, .mwiki #sv-hooks td, .mwiki #sv-software td,\n.mwiki #sv-ext th, .mwiki #sv-hooks th, .mwiki #sv-software th {\n\tborder: 1px solid #A0A0A0;\n\tpadding: 0 0.15em 0 0.15em;\n}\n.mwiki #sv-ext th, .mwiki #sv-hooks th, .mwiki #sv-software th {\n\tbackground-color: #F0F0F0;\n\tcolor: black;\n\tpadding: 0 0.15em 0 0.15em;\n}\n.mwiki tr.sv-space{\n\theight: 0.8em;\n\tborder:none;\n}\n.mwiki tr.sv-space td { display: none; }\n\n/*\n  Table pager (e.g. Special:Imagelist)\n  - remove underlines from the navigation link\n  - collapse borders\n  - set the borders to outsets (similar to Special:Allmessages)\n  - remove line wrapping for all td and th, set background color\n  - restore line wrapping for the last two table cells (description and size)\n*/\n.mwiki .TablePager { min-width: 80%; }\n.mwiki .TablePager_nav a { text-decoration: none; }\n.mwiki .TablePager { border-collapse: collapse; }\n.mwiki .TablePager, .mwiki .TablePager td, .mwiki .TablePager th {\n\tborder: 1px solid #aaaaaa;\n\tpadding: 0 0.15em 0 0.15em;\n}\n.mwiki .TablePager th { background-color: #eeeeff }\n.mwiki .TablePager td { background-color: #ffffff }\n.mwiki .TablePager tr:hover td { background-color: #eeeeff }\n\n.mwiki .imagelist td, .mwiki .imagelist th { white-space: nowrap }\n.mwiki .imagelist .TablePager_col_links { background-color: #eeeeff }\n.mwiki .imagelist .TablePager_col_img_description { white-space: normal }\n.mwiki .imagelist th.TablePager_sort { background-color: #ccccff }\n\n.mwiki .templatesUsed { margin-top: 1.5em; }\n\n.mwiki .mw-summary-preview {\n\tmargin: 0.1em 0;\n}\n\n/* Friendlier slave lag warnings */\n.mwiki div.mw-lag-warn-normal,\n.mwiki div.mw-lag-warn-high {\n\tpadding: 3px;\n\ttext-align: center;\n\tmargin: 3px auto;\n}\n.mwiki div.mw-lag-warn-normal {\n\tborder: 1px solid #FFCC66;\n\tbackground-color: #FFFFCC;\n}\n.mwiki div.mw-lag-warn-high {\n\tfont-weight: bold;\n\tborder: 2px solid #FF0033;\n\tbackground-color: #FFCCCC;\n}\n\n.mwiki .MediaTransformError {\n\tbackground-color: #ccc;\n\tpadding: 0.1em;\n}\n.mwiki .MediaTransformError td {\n\ttext-align: center;\n\tvertical-align: middle;\n\tfont-size: 90%;\n}\n\n/** Special:Search stuff */\n.mwiki div#mw-search-interwiki-caption {\n\ttext-align: center;\n\tfont-weight: bold;\n\tfont-size: 95%;\n}\n\n.mwiki .mw-search-interwiki-project {\n\tfont-size: 97%;\n\ttext-align: left;\n\tpadding-left: 0.2em;\n\tpadding-right: 0.15em;\n\tpadding-bottom: 0.2em;\n\tpadding-top: 0.15em;\n\tbackground: #cae8ff;\n}\n\n/* God-damned hack for the crappy layout */\n.mwiki .os-suggest {\n\tfont-size: 127%;\n}\n\n\n/**** Excerpts from http://en.wikipedia.org/wiki/MediaWiki:Common.css ******/\n/* Since GoldenDict support is not Wikipedia-specific, we don't include all\n * of it, and besides, it's large and volatile anyway. */\n/* It was also edited for the usually narrow article view */\n\n\n/* Make the list of references smaller */\n.mwiki ol.references {\n    font-size: 100%;\n}\n.mwiki .references-small {\n    font-size: 90%;\n}\n\n/* VALIDATOR NOTICE: the following is correct, but the W3C validator doesn't accept it */\n/* -moz-* is a vendor-specific extension (CSS 2.1 4.1.2.1) */\n/* column-count is from the CSS3 module \"CSS Multi-column Layout\" */\n/* Please ignore any validator errors caused by these two lines */\n.mwiki .references-2column {\n    font-size: 90%;\n    -moz-column-count: 2;\n    -webkit-column-count: 2;\n    column-count: 2;\n}\n\n/* Highlight clicked reference in blue to help navigation */\n.mwiki ol.references > li:target {\n    background-color: #DEF;\n}\n\n.mwiki sup.reference:target {\n    background-color: #DEF;\n}\n\n/* Styling for citations */\n.mwiki cite {\n    font-style: normal;\n    word-wrap: break-word;\n}\n\n/* If there is an inline link to a full citation, the full citation will turn blue when the inline link is clicked */\n.mwiki cite:target {\n    background-color: #DEF;\n}\n\n/* wikitable/prettytable class for skinning normal tables */\n.mwiki table.wikitable,\n.mwiki table.prettytable {\n    margin: 1em 1em 1em 0;\n    background: #f9f9f9;\n    border: 1px #aaa solid;\n    border-collapse: collapse;\n}\n.mwiki .wikitable th, .mwiki .wikitable td,\n.mwiki .prettytable th, .mwiki .prettytable td {\n    border: 1px #aaa solid;\n    padding: 0.2em;\n}\n.mwiki .wikitable th,\n.mwiki .prettytable th {\n    background: #f2f2f2;\n    text-align: center;\n}\n.mwiki .wikitable caption,\n.mwiki .prettytable caption {\n    font-weight: bold;\n}\n\n/* default skin for navigation boxes */\n.mwiki table.navbox {            /* navbox container style */\n  border:1px solid #aaa;\n  width:100%;\n  margin:auto;\n  clear:both;\n  font-size:88%;\n  text-align:center;\n  padding:1px;\n}\n.mwiki table.navbox + table.navbox {\n  margin-top:-1px;        /* single pixel border between adjacent navboxes (doesn't work for IE6, but that's okay) */\n}\n.mwiki .navbox-title, .mwiki .navbox-abovebelow, .mwiki table.navbox th {\n  text-align:center;      /* title and above/below styles */\n  padding-left:1em;\n  padding-right:1em;\n}\n.mwiki .navbox-group {           /* group style */\n  white-space:nowrap;\n  text-align:right;\n  font-weight:bold;\n  padding-left:1em;\n  padding-right:1em;\n}\n.mwiki .navbox, .mwiki .navbox-subgroup {\n  background:#fdfdfd;     /* Background color */\n}\n.mwiki .navbox-list {\n  border-color:#fdfdfd;   /* Must match background color */\n}\n.mwiki .navbox-title, .mwiki table.navbox th {\n  background:#ccccff;     /* Level 1 color */\n}\n.mwiki .navbox-abovebelow, .mwiki .navbox-group, .mwiki .navbox-subgroup .navbox-title {\n  background:#ddddff;     /* Level 2 color */\n}\n.mwiki .navbox-subgroup .navbox-group, .mwiki .navbox-subgroup .navbox-abovebelow {\n  background:#e6e6ff;     /* Level 3 color */\n}\n.mwiki .navbox-even {\n  background:#f7f7f7;     /* Even row striping */\n}\n.mwiki .navbox-odd {\n  background:transparent; /* Odd row striping */\n}\n\n.mwiki .collapseButton {         /* 'show'/'hide' buttons created dynamically by the        */\n    float: right;         /* CollapsibleTables javascript in [[MediaWiki:Common.js]] */\n    font-weight: normal;  /* are styled here so they can be customised.              */\n    text-align: right;\n    width: auto;\n}\n.mwiki .navbox .collapseButton { /* In navboxes, the show/hide button balances the vde links from */\n    width: 6em;           /* [[Template:Tnavbar]], so they need to be the same width.      */\n}\n\n\n\n/* Infobox template style */\n.mwiki .infobox {\n    border: 1px solid #aaa;\n    background-color: #f9f9f9;\n    color: black;\n/*    margin: 0.5em 0 0.5em 1em;*/\n    margin: 10px auto 0;\n    padding: 0.2em;\n/*\n    float: right;\n    clear: right;*/\n}\n\n.mwiki .infobox td,\n.mwiki .infobox th {\n    vertical-align: top;\n}\n.mwiki .infobox caption {\n    font-size: larger;\n}\n.mwiki .infobox.bordered {\n    border-collapse: collapse;\n}\n.mwiki .infobox.bordered td,\n.mwiki .infobox.bordered th {\n    border: 1px solid #aaa;\n}\n.mwiki .infobox.bordered .borderless td,\n.mwiki .infobox.bordered .borderless th {\n    border: 0;\n}\n\n.mwiki .infobox.sisterproject {\n    width: 20em;\n    font-size: 90%;\n}\n\n.mwiki .infobox.standard-talk {\n    border: 1px solid #c0c090;\n    background-color: #f8eaba;\n}\n.mwiki .infobox.standard-talk.bordered td,\n.mwiki .infobox.standard-talk.bordered th {\n    border: 1px solid #c0c090;\n}\n\n/* styles for bordered infobox with merged rows */\n.mwiki .infobox.bordered .mergedtoprow td,\n.mwiki .infobox.bordered .mergedtoprow th {\n    border: 0;\n    border-top: 1px solid #aaa;\n    border-right: 1px solid #aaa;\n}\n\n.mwiki .infobox.bordered .mergedrow td,\n.mwiki .infobox.bordered .mergedrow th {\n    border: 0;\n    border-right: 1px solid #aaa;\n}\n\n/* Styles for geography infoboxes, e.g. countries, country subdivisions, cities, etc. */\n.mwiki .infobox.geography {\n    text-align: left;\n    border-collapse: collapse;\n    line-height: 1.2em;\n    font-size: 90%;\n}\n\n.mwiki .infobox.geography  td,\n.mwiki .infobox.geography  th {\n    border-top: solid 1px #aaa;\n    padding: 0.4em 0.6em 0.4em 0.6em;\n}\n.mwiki .infobox.geography .mergedtoprow td,\n.mwiki .infobox.geography .mergedtoprow th {\n    border-top: solid 1px #aaa;\n    padding: 0.4em 0.6em 0.2em 0.6em;\n}\n\n.mwiki .infobox.geography .mergedrow td,\n.mwiki .infobox.geography .mergedrow th {\n    border: 0;\n    padding: 0 0.6em 0.2em 0.6em;\n}\n\n.mwiki .infobox.geography .mergedbottomrow td,\n.mwiki .infobox.geography .mergedbottomrow th {\n    border-top: 0;\n    border-bottom: solid 1px #aaa;\n    padding: 0 0.6em 0.4em 0.6em;\n}\n\n.mwiki .infobox.geography .maptable td,\n.mwiki .infobox.geography .maptable th {\n    border: 0;\n    padding: 0;\n}\n\n/* Style for \"notices\" */\n.mwiki .notice {\n    margin: 1em;\n    padding: 0.2em;\n}\n\n.mwiki #disambig {\n    border-top: 1px solid #ccc;\n    border-bottom: 1px solid #ccc;\n}\n\n.mwiki .rellink,\n.mwiki .dablink {\n    font-style: italic;\n    padding-left: 2em;\n}\n.mwiki .rellink i,\n.mwiki .dablink i {\n    font-style: normal;\n}\n\n/* Article message box styles */\n.mwiki table.ambox {            /* 10% = Will not overlap with other elements */\n    margin: -1px 10% 0px;    /* -1px = Single border between stacked boxes in all browsers */\n    border: 1px solid #aaa;\n    border-left: 10px solid #1e90ff;    /* Default \"notice\" blue */\n    background: #fbfbfb;\n}\n.mwiki .ambox th.mbox-text,\n.mwiki .ambox td.mbox-text {            /* The message body cell(s) */\n    padding: 0.25em 0.5em;       /* 0.5em left/right */\n}\n.mwiki .ambox td.mbox-image {           /* The left image cell */\n    padding: 2px 0 2px 0.5em;    /* 0.5em left, 0px right */\n}\n.mwiki .ambox td.mbox-imageright {      /* The right image cell */\n    padding: 2px 0.5em 2px 0;    /* 0px left, 0.5em right */\n}\n\n/* Standard Navigationsleisten, aka box hiding thingy from .de.  Documentation at [[Wikipedia:NavFrame]]. */\n.mwiki div.NavFrame {\n    margin: 0;\n    padding: 4px;\n    border: 1px solid #aaa;\n    text-align: center;\n    border-collapse: collapse;\n    font-size: 95%;\n}\n.mwiki div.NavFrame + div.NavFrame {\n    border-top-style: none;\n    border-top-style: hidden;\n}\n.mwiki div.NavPic {\n    background-color: #fff;\n    margin: 0;\n    padding: 2px;\n    float: left;\n}\n.mwiki div.NavFrame div.NavHead {\n    height: 1.6em;\n    font-weight: bold;\n    background-color: #ccf;\n    position:relative;\n}\n.mwiki div.NavFrame p {\n    font-size: 100%;\n}\n.mwiki div.NavFrame div.NavContent {\n    font-size: 100%;\n}\n.mwiki div.NavFrame div.NavContent p {\n    font-size: 100%;\n}\n.mwiki div.NavEnd {\n    margin: 0;\n    padding: 0;\n    line-height: 1px;\n    clear: both;\n}\n.mwiki a.NavToggle {\n    position: absolute;\n    top: 0;\n    right: 3px;\n    font-weight: normal;\n    font-size: 90%;\n}\n\n\n/****** Wiktionary-specific excerpts *********/\n\n.mwiki .audiolink a {\n    background: url(\"http://upload.wikimedia.org/wikipedia/commons/thumb/8/8a/Loudspeaker.svg/16px-Loudspeaker.svg.png\") center left no-repeat !important;\n    padding-left: 20px !important;\n    padding-right: 0 !important;\n}\n\n/* default setting for [[:Category:Inflection templates]] */\n\n.mwiki .infl-inline { display: inline }\n.mwiki .infl-table { display: none }\n/****default hide dict icon ***/\n.gddicticon{display:none;}\n\n.gdexpandicon {\n    cursor:pointer;\n    width:16px;\n    height:16px;\n    vertical-align: text-bottom;\n    background-image:url('qrcx://localhost/icons/arrow.png');\n}\n\n.gdcollapseicon {\n    cursor:pointer;\n    width:16px;\n    height:16px;\n    vertical-align: text-bottom;\n    background-image:url('qrcx://localhost/icons/downarrow.png');\n}\n\n/********** Slob dictionaries ***********/\n\n.slobdict img.imgtex\n{\n    vertical-align: baseline !important;\n}\n\n/************* GLS dictionaries **************/\n\n.glsdict_headwords\n{\n  font-weight: bold;\n  margin-top: 15px;\n  margin-bottom: 10px;\n  font-size: 116%;\n}\n\n.gls_wav img\n{\n  /* Ugly hack since \"vertical-align: middle;\" looks _terrible_ in Qt4's webkit: */\n  vertical-align: -30%;\n}\n"
        },
        {
          "name": "article_maker.cc",
          "type": "blob",
          "size": 35.1611328125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"article_maker.hh\"\n#include \"config.hh\"\n#include \"htmlescape.hh\"\n#include \"utf8.hh\"\n#include \"wstring_qt.hh\"\n#include <limits.h>\n#include <QFile>\n#include <QUrl>\n#include <QTextDocumentFragment>\n#include \"folding.hh\"\n#include \"langcoder.hh\"\n#include \"gddebug.hh\"\n#include \"qt4x5.hh\"\n\nusing std::vector;\nusing std::string;\nusing gd::wstring;\nusing std::set;\nusing std::list;\n\nArticleMaker::ArticleMaker( vector< sptr< Dictionary::Class > > const & dictionaries_,\n                            vector< Instances::Group > const & groups_,\n                            QString const & displayStyle_,\n                            QString const & addonStyle_):\n  dictionaries( dictionaries_ ),\n  groups( groups_ ),\n  displayStyle( displayStyle_ ),\n  addonStyle( addonStyle_ ),\n  needExpandOptionalParts( true )\n, collapseBigArticles( true )\n, articleLimitSize( 500 )\n{\n}\n\nvoid ArticleMaker::setDisplayStyle( QString const & st, QString const & adst )\n{\n  displayStyle = st;\n  addonStyle = adst;\n}\n\nstd::string ArticleMaker::makeHtmlHeader( QString const & word,\n                                          QString const & icon,\n                                          bool expandOptionalParts ) const\n{\n  string result =\n    \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\"\n    \"<html><head>\"\n    \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=utf-8\\\">\";\n\n  // Add a css stylesheet\n\n  {\n    QFile builtInCssFile( \":/article-style.css\" );\n    builtInCssFile.open( QFile::ReadOnly );\n    QByteArray css = builtInCssFile.readAll();\n\n    if( !css.isEmpty() )\n    {\n      result += \"\\n<!-- Built-in css -->\\n\";\n      result += \"<style type=\\\"text/css\\\" media=\\\"all\\\">\\n\";\n      result += css.data();\n      result += \"</style>\\n\";\n    }\n\n    if ( displayStyle.size() )\n    {\n      // Load an additional stylesheet\n      QFile builtInCssFile( QString( \":/article-style-st-%1.css\" ).arg( displayStyle ) );\n      builtInCssFile.open( QFile::ReadOnly );\n      css = builtInCssFile.readAll();\n      if( !css.isEmpty() )\n      {\n        result += \"<!-- Built-in style css -->\\n\";\n        result += \"<style type=\\\"text/css\\\" media=\\\"all\\\">\\n\";\n        result += css.data();\n        result += \"</style>\\n\";\n      }\n    }\n\n    QFile cssFile( Config::getUserCssFileName() );\n\n    if ( cssFile.open( QFile::ReadOnly ) )\n    {\n      css = cssFile.readAll();\n      if( !css.isEmpty() )\n      {\n        result += \"<!-- User css -->\\n\";\n        result += \"<style type=\\\"text/css\\\" media=\\\"all\\\">\\n\";\n        result += css.data();\n        result += \"</style>\\n\";\n      }\n    }\n\n    if( !addonStyle.isEmpty() )\n    {\n      QString name = Config::getStylesDir() + addonStyle\n                     + QDir::separator() + \"article-style.css\";\n      QFile addonCss( name );\n      if( addonCss.open( QFile::ReadOnly ) )\n      {\n        css = addonCss.readAll();\n        if( !css.isEmpty() )\n        {\n          result += \"<!-- Addon style css -->\\n\";\n          result += \"<style type=\\\"text/css\\\" media=\\\"all\\\">\\n\";\n          result += css.data();\n          result += \"</style>\\n\";\n        }\n      }\n    }\n\n    // Turn on/off expanding of article optional parts\n    if( expandOptionalParts )\n    {\n      result += \"<!-- Expand optional parts css -->\\n\";\n      result += \"<style type=\\\"text/css\\\" media=\\\"all\\\">\\n\";\n      result += \"\\n.dsl_opt\\n{\\n  display: inline;\\n}\\n\\n.hidden_expand_opt\\n{\\n  display: none !important;\\n}\\n\";\n      result += \"</style>\\n\";\n    }\n\n  }\n\n  // Add print-only css\n\n  {\n    QFile builtInCssFile( \":/article-style-print.css\" );\n    builtInCssFile.open( QFile::ReadOnly );\n    QByteArray css = builtInCssFile.readAll();\n    if( !css.isEmpty() )\n    {\n      result += \"<!-- Built-in print css -->\\n\";\n      result += \"<style type=\\\"text/css\\\" media=\\\"print\\\">\\n\";\n      result += css.data();\n      result += \"</style>\\n\";\n    }\n\n    QFile cssFile( Config::getUserCssPrintFileName() );\n\n    if ( cssFile.open( QFile::ReadOnly ) )\n    {\n      css = cssFile.readAll();\n      if( !css.isEmpty() )\n      {\n        result += \"<!-- User print css -->\\n\";\n        result += \"<style type=\\\"text/css\\\" media=\\\"print\\\">\\n\";\n        result += css.data();\n        result += \"</style>\\n\";\n        css.clear();\n      }\n    }\n\n    if( !addonStyle.isEmpty() )\n    {\n      QString name = Config::getStylesDir() + addonStyle\n                     + QDir::separator() + \"article-style-print.css\";\n      QFile addonCss( name );\n      if( addonCss.open( QFile::ReadOnly ) )\n      {\n        css = addonCss.readAll();\n        if( !css.isEmpty() )\n        {\n          result += \"<!-- Addon style print css -->\\n\";\n          result += \"<style type=\\\"text/css\\\" media=\\\"print\\\">\\n\";\n          result += css.data();\n          result += \"</style>\\n\";\n        }\n      }\n    }\n  }\n\n  result += \"<title>\" + Html::escape( Utf8::encode( gd::toWString( word ) ) ) + \"</title>\";\n\n  // This doesn't seem to be much of influence right now, but we'll keep\n  // it anyway.\n  if ( icon.size() )\n    result += \"<link rel=\\\"icon\\\" type=\\\"image/png\\\" href=\\\"qrcx://localhost/flags/\" + Html::escape( icon.toUtf8().data() ) + \"\\\" />\\n\";\n\n  result += \"<script type=\\\"text/javascript\\\">\"\n            \"var gdAudioLinks = { first: null, current: null };\"\n            \"function gdMakeArticleActive( newId ) {\"\n            \"if ( gdCurrentArticle != 'gdfrom-' + newId ) {\"\n            \"el=document.getElementById( gdCurrentArticle ); el.className = el.className.replace(' gdactivearticle','');\"\n            \"el=document.getElementById( 'gdfrom-' + newId ); el.className = el.className + ' gdactivearticle';\"\n            \"gdCurrentArticle = 'gdfrom-' + newId; gdAudioLinks.current = newId;\"\n            \"articleview.onJsActiveArticleChanged(gdCurrentArticle); } }\"\n            \"var overIframeId = null;\"\n            \"function gdSelectArticle( id ) {\"\n            \"var selection = window.getSelection(); var range = document.createRange();\"\n            \"range.selectNodeContents(document.getElementById('gdfrom-' + id));\"\n            \"selection.removeAllRanges(); selection.addRange(range); }\"\n            \"function processIframeMouseOut() { overIframeId = null; top.focus(); }\"\n            \"function processIframeMouseOver( newId ) { overIframeId = newId; }\"\n            \"function processIframeClick() { if( overIframeId != null ) { overIframeId = overIframeId.replace( 'gdexpandframe-', '' ); gdMakeArticleActive( overIframeId ) } }\"\n            \"function init() { window.addEventListener('blur', processIframeClick, false); }\"\n            \"window.addEventListener('load', init, false);\"\n            \"function gdExpandOptPart( expanderId, optionalId ) {  var d1=document.getElementById(expanderId); var i = 0; if( d1.alt == '[+]' ) {\"\n            \"d1.alt = '[-]'; d1.src = 'qrcx://localhost/icons/collapse_opt.png'; for( i = 0; i < 1000; i++ ) { var d2=document.getElementById( optionalId + i ); if( !d2 ) break; d2.style.display='inline'; } }\"\n            \"else { d1.alt = '[+]'; d1.src = 'qrcx://localhost/icons/expand_opt.png'; for( i = 0; i < 1000; i++ ) { var d2=document.getElementById( optionalId + i ); if( !d2 ) break; d2.style.display='none'; } } };\"\n            \"function gdExpandArticle( id ) { elem = document.getElementById('gdarticlefrom-'+id); ico = document.getElementById('expandicon-'+id); art=document.getElementById('gdfrom-'+id);\"\n            \"ev=window.event; t=null;\"\n            \"if(ev) t=ev.target || ev.srcElement;\"\n            \"if(elem.style.display=='inline' && t==ico) {\"\n            \"elem.style.display='none'; ico.className='gdexpandicon';\"\n            \"art.className = art.className+' gdcollapsedarticle';\"\n            \"nm=document.getElementById('gddictname-'+id); nm.style.cursor='pointer';\"\n            \"if(ev) ev.stopPropagation(); ico.title=''; nm.title=\\\"\";\n  result += tr( \"Expand article\" ).toUtf8().data();\n  result += \"\\\" } else if(elem.style.display=='none') {\"\n            \"elem.style.display='inline'; ico.className='gdcollapseicon';\"\n            \"art.className=art.className.replace(' gdcollapsedarticle','');\"\n            \"nm=document.getElementById('gddictname-'+id); nm.style.cursor='default';\"\n            \"nm.title=''; ico.title=\\\"\";\n  result += tr( \"Collapse article\").toUtf8().data();\n  result += \"\\\" } }\"\n            \"function gdCheckArticlesNumber() {\"\n            \"elems=document.getElementsByClassName('gddictname');\"\n            \"if(elems.length == 1) {\"\n              \"el=elems.item(0); s=el.id.replace('gddictname-','');\"\n              \"el=document.getElementById('gdfrom-'+s);\"\n              \"if(el && el.className.search('gdcollapsedarticle')>0) gdExpandArticle(s);\"\n            \"} }\"\n            \"</script>\";\n\n  result += \"</head><body>\";\n\n  return result;\n}\n\nstd::string ArticleMaker::makeNotFoundBody( QString const & word,\n                                            QString const & group )\n{\n  string result( \"<div class=\\\"gdnotfound\\\"><p>\" );\n\n  QString str( word );\n  if( str.isRightToLeft() )\n  {\n    str.insert( 0, (ushort)0x202E ); // RLE, Right-to-Left Embedding\n    str.append( (ushort)0x202C ); // PDF, POP DIRECTIONAL FORMATTING\n  }\n\n  if ( word.size() )\n    result += tr( \"No translation for <b>%1</b> was found in group <b>%2</b>.\" ).\n              arg( QString::fromUtf8( Html::escape( str.toUtf8().data() ).c_str() ) ).\n              arg( QString::fromUtf8( Html::escape( group.toUtf8().data() ).c_str() ) ).\n                toUtf8().data();\n  else\n    result += tr( \"No translation was found in group <b>%1</b>.\" ).\n              arg( QString::fromUtf8( Html::escape( group.toUtf8().data() ).c_str() ) ).\n                toUtf8().data();\n\n  result += \"</p></div>\";\n\n  return result;\n}\n\nsptr< Dictionary::DataRequest > ArticleMaker::makeDefinitionFor(\n  Config::InputPhrase const & phrase, unsigned groupId,\n  QMap< QString, QString > const & contexts,\n  QSet< QString > const & mutedDicts,\n  QStringList const & dictIDs , bool ignoreDiacritics ) const\n{\n  if( !dictIDs.isEmpty() )\n  {\n    QStringList ids = dictIDs;\n    std::vector< sptr< Dictionary::Class > > ftsDicts;\n\n    // Find dictionaries by ID's\n    for( unsigned x = 0; x < dictionaries.size(); x++ )\n    {\n      for( QStringList::Iterator it = ids.begin(); it != ids.end(); ++it )\n      {\n        if( *it == QString::fromStdString( dictionaries[ x ]->getId() ) )\n        {\n          ftsDicts.push_back( dictionaries[ x ] );\n          ids.erase( it );\n          break;\n        }\n      }\n      if( ids.isEmpty() )\n        break;\n    }\n\n    string header = makeHtmlHeader( phrase.phrase, QString(), true );\n\n    return new ArticleRequest( phrase, \"\",\n                               contexts, ftsDicts, header,\n                               -1, true );\n  }\n\n  if ( groupId == Instances::Group::HelpGroupId )\n  {\n    // This is a special group containing internal welcome/help pages\n    string result = makeHtmlHeader( phrase.phrase, QString(), needExpandOptionalParts );\n\n    if ( phrase.phrase == tr( \"Welcome!\" ) )\n    {\n      result += tr(\n\"<h3 align=\\\"center\\\">Welcome to <b>GoldenDict</b>!</h3>\"\n\"<p>To start working with the program, first visit <b>Edit|Dictionaries</b> to add some directory paths where to search \"\n\"for the dictionary files, set up various Wikipedia sites or other sources, adjust dictionary order or create dictionary groups.\"\n\"<p>And then you're ready to look up your words! You can do that in this window \"\n\"by using a pane to the left, or you can <a href=\\\"Working with popup\\\">look up words from other active applications</a>. \"\n\"<p>To customize program, check out the available preferences at <b>Edit|Preferences</b>. \"\n\"All settings there have tooltips, be sure to read them if you are in doubt about anything.\"\n\"<p>Should you need further help, have any questions, \"\n\"suggestions or just wonder what the others think, you are welcome at the program's <a href=\\\"http://goldendict.org/forum/\\\">forum</a>.\"\n\"<p>Check program's <a href=\\\"http://goldendict.org/\\\">website</a> for the updates. \"\n\"<p>(c) 2008-2013 Konstantin Isakov. Licensed under GPLv3 or later.\"\n\n        ).toUtf8().data();\n    }\n    else\n    if ( phrase.phrase == tr( \"Working with popup\" ) )\n    {\n      result += ( tr( \"<h3 align=\\\"center\\\">Working with the popup</h3>\"\n\n\"To look up words from other active applications, you would need to first activate the <i>\\\"Scan popup functionality\\\"</i> in <b>Preferences</b>, \"\n\"and then enable it at any time either by triggering the 'Popup' icon above, or \"\n\"by clicking the tray icon down below with your right mouse button and choosing so in the menu you've popped. \" ) +\n\n#ifdef Q_OS_WIN32\n  tr( \"Then just stop the cursor over the word you want to look up in another application, \"\n       \"and a window would pop up which would describe it to you.\" )\n#else\n  tr( \"Then just select any word you want to look up in another application by your mouse \"\n      \"(double-click it or swipe it with mouse with the button pressed), \"\n      \"and a window would pop up which would describe the word to you.\" )\n#endif\n  ).toUtf8().data();\n    }\n    else\n    {\n      // Not found\n      return makeNotFoundTextFor( phrase.phrase, \"help\" );\n    }\n\n    result += \"</body></html>\";\n\n    sptr< Dictionary::DataRequestInstant > r = new Dictionary::DataRequestInstant( true );\n\n    r->getData().resize( result.size() );\n    memcpy( &( r->getData().front() ), result.data(), result.size() );\n\n    return r;\n  }\n\n  // Find the given group\n\n  Instances::Group const * activeGroup = 0;\n\n  for( unsigned x = 0; x < groups.size(); ++x )\n    if ( groups[ x ].id == groupId )\n    {\n      activeGroup = &groups[ x ];\n      break;\n    }\n\n  // If we've found a group, use its dictionaries; otherwise, use the global\n  // heap.\n  std::vector< sptr< Dictionary::Class > > const & activeDicts =\n    activeGroup ? activeGroup->dictionaries : dictionaries;\n\n  string header = makeHtmlHeader( phrase.phrase,\n                                  activeGroup && activeGroup->icon.size() ?\n                                    activeGroup->icon : QString(),\n                                  needExpandOptionalParts );\n\n  if ( mutedDicts.size() )\n  {\n    std::vector< sptr< Dictionary::Class > > unmutedDicts;\n\n    unmutedDicts.reserve( activeDicts.size() );\n\n    for( unsigned x = 0; x < activeDicts.size(); ++x )\n      if ( !mutedDicts.contains(\n              QString::fromStdString( activeDicts[ x ]->getId() ) ) )\n        unmutedDicts.push_back( activeDicts[ x ] );\n\n    return new ArticleRequest( phrase, activeGroup ? activeGroup->name : \"\",\n                               contexts, unmutedDicts, header,\n                               collapseBigArticles ? articleLimitSize : -1,\n                               needExpandOptionalParts, ignoreDiacritics );\n  }\n  else\n    return new ArticleRequest( phrase, activeGroup ? activeGroup->name : \"\",\n                               contexts, activeDicts, header,\n                               collapseBigArticles ? articleLimitSize : -1,\n                               needExpandOptionalParts, ignoreDiacritics );\n}\n\nsptr< Dictionary::DataRequest > ArticleMaker::makeNotFoundTextFor(\n  QString const & word, QString const & group ) const\n{\n  string result = makeHtmlHeader( word, QString(), true ) + makeNotFoundBody( word, group ) +\n    \"</body></html>\";\n\n  sptr< Dictionary::DataRequestInstant > r = new Dictionary::DataRequestInstant( true );\n\n  r->getData().resize( result.size() );\n  memcpy( &( r->getData().front() ), result.data(), result.size() );\n\n  return r;\n}\n\nsptr< Dictionary::DataRequest > ArticleMaker::makeEmptyPage() const\n{\n  string result = makeHtmlHeader( tr( \"(untitled)\" ), QString(), true ) +\n    \"</body></html>\";\n\n  sptr< Dictionary::DataRequestInstant > r =\n      new Dictionary::DataRequestInstant( true );\n\n  r->getData().resize( result.size() );\n  memcpy( &( r->getData().front() ), result.data(), result.size() );\n\n  return r;\n}\n\nsptr< Dictionary::DataRequest > ArticleMaker::makePicturePage( string const & url ) const\n{\n  string result = makeHtmlHeader( tr( \"(picture)\" ), QString(), true )\n                  + \"<a href=\\\"javascript: if(history.length>2) history.go(-1)\\\">\"\n                  + \"<img src=\\\"\" + url + \"\\\" /></a>\"\n                  + \"</body></html>\";\n\n  sptr< Dictionary::DataRequestInstant > r =\n      new Dictionary::DataRequestInstant( true );\n\n  r->getData().resize( result.size() );\n  memcpy( &( r->getData().front() ), result.data(), result.size() );\n\n  return r;\n}\n\nvoid ArticleMaker::setExpandOptionalParts( bool expand )\n{\n  needExpandOptionalParts = expand;\n}\n\nvoid ArticleMaker::setCollapseParameters( bool autoCollapse, int articleSize )\n{\n  collapseBigArticles = autoCollapse;\n  articleLimitSize = articleSize;\n}\n\n\nbool ArticleMaker::adjustFilePath( QString & fileName )\n{\n  QFileInfo info( fileName );\n  if( !info.isFile() )\n  {\n    QString dir = Config::getConfigDir();\n    dir.chop( 1 );\n    info.setFile( dir + fileName);\n    if( info.isFile() )\n    {\n      fileName = info.canonicalFilePath();\n      return true;\n    }\n  }\n  return false;\n}\n\n//////// ArticleRequest\n\nArticleRequest::ArticleRequest(\n  Config::InputPhrase const & phrase, QString const & group_,\n  QMap< QString, QString > const & contexts_,\n  vector< sptr< Dictionary::Class > > const & activeDicts_,\n  string const & header,\n  int sizeLimit, bool needExpandOptionalParts_, bool ignoreDiacritics_ ):\n    word( phrase.phrase ), group( group_ ), contexts( contexts_ ),\n    activeDicts( activeDicts_ ),\n    altsDone( false ), bodyDone( false ), foundAnyDefinitions( false ),\n    closePrevSpan( false )\n,   articleSizeLimit( sizeLimit )\n,   needExpandOptionalParts( needExpandOptionalParts_ )\n,   ignoreDiacritics( ignoreDiacritics_ )\n{\n  if ( !phrase.punctuationSuffix.isEmpty() )\n    alts.insert( gd::toWString( phrase.phraseWithSuffix() ) );\n\n  // No need to lock dataMutex on construction\n\n  hasAnyData = true;\n\n  data.resize( header.size() );\n  memcpy( &data.front(), header.data(), header.size() );\n\n  // Accumulate main forms\n\n  for( unsigned x = 0; x < activeDicts.size(); ++x )\n  {\n    sptr< Dictionary::WordSearchRequest > s = activeDicts[ x ]->findHeadwordsForSynonym( gd::toWString( word ) );\n\n    connect( s.get(), SIGNAL( finished() ),\n             this, SLOT( altSearchFinished() ), Qt::QueuedConnection );\n\n    altSearches.push_back( s );\n  }\n\n  altSearchFinished(); // Handle any ones which have already finished\n}\n\nvoid ArticleRequest::altSearchFinished()\n{\n  if ( altsDone )\n    return;\n\n  // Check every request for finishing\n  for( list< sptr< Dictionary::WordSearchRequest > >::iterator i =\n         altSearches.begin(); i != altSearches.end(); )\n  {\n    if ( (*i)->isFinished() )\n    {\n      // This one's finished\n      for( size_t count = (*i)->matchesCount(), x = 0; x < count; ++x )\n        alts.insert( (**i)[ x ].word );\n\n      altSearches.erase( i++ );\n    }\n    else\n      ++i;\n  }\n\n  if ( altSearches.empty() )\n  {\n#ifdef QT_DEBUG\n    qDebug( \"alts finished\\n\" );\n#endif\n\n    // They all've finished! Now we can look up bodies\n\n    altsDone = true; // So any pending signals in queued mode won't mess us up\n\n    vector< wstring > altsVector( alts.begin(), alts.end() );\n\n#ifdef QT_DEBUG\n    for( unsigned x = 0; x < altsVector.size(); ++x )\n    {\n      qDebug() << \"Alt:\" << gd::toQString( altsVector[ x ] );\n    }\n#endif\n\n    wstring wordStd = gd::toWString( word );\n\n    if( activeDicts.size() <= 1 )\n      articleSizeLimit = -1; // Don't collapse article if only one dictionary presented\n\n    for( unsigned x = 0; x < activeDicts.size(); ++x )\n    {\n      try\n      {\n        sptr< Dictionary::DataRequest > r =\n          activeDicts[ x ]->getArticle( wordStd, altsVector,\n                                        gd::toWString( contexts.value( QString::fromStdString( activeDicts[ x ]->getId() ) ) ),\n                                        ignoreDiacritics );\n\n        connect( r.get(), SIGNAL( finished() ),\n                 this, SLOT( bodyFinished() ), Qt::QueuedConnection );\n\n        bodyRequests.push_back( r );\n      }\n      catch( std::exception & e )\n      {\n        gdWarning( \"getArticle request error (%s) in \\\"%s\\\"\\n\",\n                   e.what(), activeDicts[ x ]->getName().c_str() );\n      }\n    }\n\n    bodyFinished(); // Handle any ones which have already finished\n  }\n}\n\nint ArticleRequest::findEndOfCloseDiv( const QString &str, int pos )\n{\n  for( ; ; )\n  {\n    int n1 = str.indexOf( \"</div>\", pos );\n    if( n1 <= 0 )\n      return n1;\n\n    int n2 = str.indexOf( \"<div \", pos );\n    if( n2 <= 0 || n2 > n1 )\n      return n1 + 6;\n\n    pos = findEndOfCloseDiv( str, n2 + 1 );\n    if( pos <= 0 )\n      return pos;\n  }\n}\n\nvoid ArticleRequest::bodyFinished()\n{\n  if ( bodyDone )\n    return;\n\n  GD_DPRINTF( \"some body finished\\n\" );\n\n  bool wasUpdated = false;\n\n  while ( bodyRequests.size() )\n  {\n    // Since requests should go in order, check the first one first\n    if ( bodyRequests.front()->isFinished() )\n    {\n      // Good\n\n      GD_DPRINTF( \"one finished.\\n\" );\n\n      Dictionary::DataRequest & req = *bodyRequests.front();\n\n      QString errorString = req.getErrorString();\n\n      if ( req.dataSize() >= 0 || errorString.size() )\n      {\n        sptr< Dictionary::Class > const & activeDict =\n            activeDicts[ activeDicts.size() - bodyRequests.size() ];\n\n        string dictId = activeDict->getId();\n\n        string head;\n\n        string gdFrom = \"gdfrom-\" + Html::escape( dictId );\n\n        if ( closePrevSpan )\n        {\n          head += \"</div></div><div style=\\\"clear:both;\\\"></div><span class=\\\"gdarticleseparator\\\"></span>\";\n        }\n        else\n        {\n          // This is the first article\n          head += \"<script type=\\\"text/javascript\\\">\"\n                  \"var gdCurrentArticle=\\\"\" + gdFrom  + \"\\\"; \"\n                  \"articleview.onJsActiveArticleChanged(gdCurrentArticle)</script>\";\n        }\n\n        bool collapse = false;\n        if( articleSizeLimit >= 0 )\n        {\n          try\n          {\n            Mutex::Lock _( dataMutex );\n            QString text = QString::fromUtf8( req.getFullData().data(), req.getFullData().size() );\n\n            if( !needExpandOptionalParts )\n            {\n              // Strip DSL optional parts\n              int pos = 0;\n              for( ; ; )\n              {\n                pos = text.indexOf( \"<div class=\\\"dsl_opt\\\"\" );\n                if( pos > 0 )\n                {\n                  int endPos = findEndOfCloseDiv( text, pos + 1 );\n                  if( endPos > pos)\n                    text.remove( pos, endPos - pos );\n                  else\n                    break;\n                }\n                else\n                  break;\n              }\n            }\n\n            int size = QTextDocumentFragment::fromHtml( text ).toPlainText().length();\n            if( size > articleSizeLimit )\n              collapse = true;\n          }\n          catch(...)\n          {\n          }\n        }\n\n        string jsVal = Html::escapeForJavaScript( dictId );\n        head += \"<script type=\\\"text/javascript\\\">var gdArticleContents; \"\n          \"if ( !gdArticleContents ) gdArticleContents = \\\"\" + jsVal +\" \\\"; \"\n          \"else gdArticleContents += \\\"\" + jsVal + \" \\\";</script>\";\n\n        head += string( \"<div class=\\\"gdarticle\" ) +\n                ( closePrevSpan ? \"\" : \" gdactivearticle\" ) +\n                ( collapse ? \" gdcollapsedarticle\" : \"\" ) +\n                \"\\\" id=\\\"\" + gdFrom +\n                \"\\\" onClick=\\\"gdMakeArticleActive( '\" + jsVal + \"' );\\\" \" +\n                \" onContextMenu=\\\"gdMakeArticleActive( '\" + jsVal + \"' );\\\"\"\n                + \">\";\n\n        closePrevSpan = true;\n\n        head += string( \"<div class=\\\"gddictname\\\" onclick=\\\"gdExpandArticle(\\'\" ) + dictId + \"\\');\"\n          + ( collapse ? \"\\\" style=\\\"cursor:pointer;\" : \"\" )\n          + \"\\\" id=\\\"gddictname-\" + Html::escape( dictId ) + \"\\\"\"\n          + ( collapse ? string( \" title=\\\"\" ) + tr( \"Expand article\" ).toUtf8().data() + \"\\\"\" : \"\" )\n          + \"><span class=\\\"gddicticon\\\"><img src=\\\"gico://\" + Html::escape( dictId )\n          + \"/dicticon.png\\\"></span><span class=\\\"gdfromprefix\\\">\"  +\n          Html::escape( tr( \"From \" ).toUtf8().data() ) + \"</span><span class=\\\"gddicttitle\\\">\" +\n          Html::escape( activeDict->getName().c_str() ) + \"</span>\"\n          + \"<span class=\\\"collapse_expand_area\\\"><img src=\\\"qrcx://localhost/icons/blank.png\\\" class=\\\"\"\n          + ( collapse ? \"gdexpandicon\" : \"gdcollapseicon\" )\n          + \"\\\" id=\\\"expandicon-\" + Html::escape( dictId ) + \"\\\"\"\n          + ( collapse ? \"\" : string( \" title=\\\"\" ) + tr( \"Collapse article\" ).toUtf8().data() + \"\\\"\" )\n          + \"></span>\" + \"</div>\";\n\n        head += \"<div class=\\\"gddictnamebodyseparator\\\"></div>\";\n\n        head += \"<div class=\\\"gdarticlebody gdlangfrom-\";\n        head += LangCoder::intToCode2( activeDict->getLangFrom() ).toLatin1().data();\n        head += \"\\\" lang=\\\"\";\n        head += LangCoder::intToCode2( activeDict->getLangTo() ).toLatin1().data();\n        head += \"\\\"\";\n        head += \" style=\\\"display:\";\n        head += collapse ? \"none\" : \"inline\";\n        head += string( \"\\\" id=\\\"gdarticlefrom-\" ) + Html::escape( dictId ) + \"\\\">\";\n\n        if ( errorString.size() )\n        {\n          head += \"<div class=\\\"gderrordesc\\\">\" +\n            Html::escape( tr( \"Query error: %1\" ).arg( errorString ).toUtf8().data() )\n          + \"</div>\";\n        }\n\n        Mutex::Lock _( dataMutex );\n\n        size_t offset = data.size();\n\n        data.resize( data.size() + head.size() + ( req.dataSize() > 0 ? req.dataSize() : 0 ) );\n\n        memcpy( &data.front() + offset, head.data(), head.size() );\n\n        try\n        {\n          if ( req.dataSize() > 0 )\n            bodyRequests.front()->getDataSlice( 0, req.dataSize(),\n                                                &data.front() + offset + head.size() );\n        }\n        catch( std::exception & e )\n        {\n          gdWarning( \"getDataSlice error: %s\\n\", e.what() );\n        }\n\n        wasUpdated = true;\n\n        foundAnyDefinitions = true;\n      }\n      GD_DPRINTF( \"erasing..\\n\" );\n      bodyRequests.pop_front();\n      GD_DPRINTF( \"erase done..\\n\" );\n    }\n    else\n    {\n      GD_DPRINTF( \"one not finished.\\n\" );\n      break;\n    }\n  }\n\n  if ( bodyRequests.empty() )\n  {\n    // No requests left, end the article\n\n    bodyDone = true;\n\n    {\n      string footer;\n\n      if ( closePrevSpan )\n      {\n        footer += \"</div></div>\";\n        closePrevSpan = false;\n      }\n\n      if ( !foundAnyDefinitions )\n      {\n        // No definitions were ever found, say so to the user.\n\n        // Larger words are usually whole sentences - don't clutter the output\n        // with their full bodies.\n        footer += ArticleMaker::makeNotFoundBody( word.size() < 40 ? word : \"\", group );\n\n        // When there were no definitions, we run stemmed search.\n        stemmedWordFinder = new WordFinder( this );\n\n        connect( stemmedWordFinder.get(), SIGNAL( finished() ),\n                 this, SLOT( stemmedSearchFinished() ), Qt::QueuedConnection );\n\n        stemmedWordFinder->stemmedMatch( word, activeDicts );\n      }\n      else\n      {\n        footer += \"</body></html>\";\n      }\n\n      Mutex::Lock _( dataMutex );\n\n      size_t offset = data.size();\n\n      data.resize( data.size() + footer.size() );\n\n      memcpy( &data.front() + offset, footer.data(), footer.size() );\n    }\n\n    if ( stemmedWordFinder.get() )\n      update();\n    else\n      finish();\n  }\n  else\n  if ( wasUpdated )\n    update();\n}\n\nvoid ArticleRequest::stemmedSearchFinished()\n{\n  // Got stemmed matching results\n\n  WordFinder::SearchResults sr = stemmedWordFinder->getResults();\n\n  string footer;\n\n  bool continueMatching = false;\n\n  if ( sr.size() )\n  {\n    footer += \"<div class=\\\"gdstemmedsuggestion\\\"><span class=\\\"gdstemmedsuggestion_head\\\">\" +\n      Html::escape( tr( \"Close words: \" ).toUtf8().data() ) +\n      \"</span><span class=\\\"gdstemmedsuggestion_body\\\">\";\n\n    for( unsigned x = 0; x < sr.size(); ++x )\n    {\n      footer += linkWord( sr[ x ].first );\n\n      if ( x != sr.size() - 1 )\n      {\n        footer += \", \";\n      }\n    }\n\n    footer += \"</span></div>\";\n  }\n\n  splittedWords = splitIntoWords( word );\n\n  if ( splittedWords.first.size() > 1 ) // Contains more than one word\n  {\n    disconnect( stemmedWordFinder.get(), SIGNAL( finished() ),\n                this, SLOT( stemmedSearchFinished() ) );\n\n    connect( stemmedWordFinder.get(), SIGNAL( finished() ),\n             this, SLOT( individualWordFinished() ), Qt::QueuedConnection );\n\n    currentSplittedWordStart = -1;\n    currentSplittedWordEnd = currentSplittedWordStart;\n\n    firstCompoundWasFound = false;\n\n    compoundSearchNextStep( false );\n\n    continueMatching = true;\n  }\n\n  if ( !continueMatching )\n    footer += \"</body></html>\";\n\n  {\n    Mutex::Lock _( dataMutex );\n\n    size_t offset = data.size();\n\n    data.resize( data.size() + footer.size() );\n\n    memcpy( &data.front() + offset, footer.data(), footer.size() );\n  }\n\n  if ( continueMatching )\n    update();\n  else\n    finish();\n}\n\nvoid ArticleRequest::compoundSearchNextStep( bool lastSearchSucceeded )\n{\n  if ( !lastSearchSucceeded )\n  {\n    // Last search was unsuccessful. First, emit what we had.\n\n    string footer;\n\n    if ( lastGoodCompoundResult.size() ) // We have something to append\n    {\n//      DPRINTF( \"Appending\\n\" );\n\n      if ( !firstCompoundWasFound )\n      {\n        // Append the beginning\n        footer += \"<div class=\\\"gdstemmedsuggestion\\\"><span class=\\\"gdstemmedsuggestion_head\\\">\" +\n          Html::escape( tr( \"Compound expressions: \" ).toUtf8().data() ) +\n          \"</span><span class=\\\"gdstemmedsuggestion_body\\\">\";\n\n        firstCompoundWasFound = true;\n      }\n      else\n      {\n        // Append the separator\n        footer += \" / \";\n      }\n\n      footer += linkWord( lastGoodCompoundResult );\n\n      lastGoodCompoundResult.clear();\n    }\n\n    // Then, start a new search for the next word, if possible\n\n    if ( currentSplittedWordStart >= splittedWords.first.size() - 2 )\n    {\n      // The last word was the last possible to start from\n\n      if ( firstCompoundWasFound )\n        footer += \"</span>\";\n\n      // Now add links to all the individual words. They conclude the result.\n\n      footer += \"<div class=\\\"gdstemmedsuggestion\\\"><span class=\\\"gdstemmedsuggestion_head\\\">\" +\n        Html::escape( tr( \"Individual words: \" ).toUtf8().data() ) +\n        \"</span><span class=\\\"gdstemmedsuggestion_body\\\"\";\n      if( splittedWords.first[ 0 ].isRightToLeft() )\n        footer += \" dir=\\\"rtl\\\"\";\n      footer += \">\";\n\n      footer += escapeSpacing( splittedWords.second[ 0 ] );\n\n      for( int x = 0; x < splittedWords.first.size(); ++x )\n      {\n        footer += linkWord( splittedWords.first[ x ] );\n        footer += escapeSpacing( splittedWords.second[ x + 1 ] );\n      }\n\n      footer += \"</span>\";\n\n      footer += \"</body></html>\";\n\n      appendToData( footer );\n\n      finish();\n\n      return;\n    }\n\n    if ( footer.size() )\n    {\n      appendToData( footer );\n      update();\n    }\n\n    // Advance to the next word and start from looking up two words\n    ++currentSplittedWordStart;\n    currentSplittedWordEnd = currentSplittedWordStart + 1;\n  }\n  else\n  {\n    // Last lookup succeeded -- see if we can try the larger sequence\n\n    if ( currentSplittedWordEnd < splittedWords.first.size() - 1 )\n    {\n      // We can, indeed.\n      ++currentSplittedWordEnd;\n    }\n    else\n    {\n      // We can't. Emit what we have and start over.\n\n      ++currentSplittedWordEnd; // So we could use the same code for result\n                                // emitting\n\n      // Initiate new lookup\n      compoundSearchNextStep( false );\n\n      return;\n    }\n  }\n\n  // Build the compound sequence\n\n  currentSplittedWordCompound = makeSplittedWordCompound();\n\n  // Look it up\n\n//  DPRINTF( \"Looking up %s\\n\", qPrintable( currentSplittedWordCompound ) );\n\n  stemmedWordFinder->expressionMatch( currentSplittedWordCompound, activeDicts, 40, // Would one be enough? Leave 40 to be safe.\n                                      Dictionary::SuitableForCompoundSearching );\n}\n\nQString ArticleRequest::makeSplittedWordCompound()\n{\n  QString result;\n\n  result.clear();\n\n  for( int x = currentSplittedWordStart; x <= currentSplittedWordEnd; ++x )\n  {\n    result.append( splittedWords.first[ x ] );\n\n    if ( x < currentSplittedWordEnd )\n    {\n      wstring ws( gd::toWString( splittedWords.second[ x + 1 ] ) );\n\n      Folding::normalizeWhitespace( ws );\n\n      result.append( gd::toQString( ws ) );\n    }\n  }\n\n  return result;\n}\n\nvoid ArticleRequest::individualWordFinished()\n{\n  WordFinder::SearchResults const & results = stemmedWordFinder->getResults();\n\n  if ( results.size() )\n  {\n    wstring source = Folding::applySimpleCaseOnly( gd::toWString( currentSplittedWordCompound ) );\n\n    bool hadSomething = false;\n\n    for( unsigned x = 0; x < results.size(); ++x )\n    {\n      if ( results[ x ].second )\n      {\n        // Spelling suggestion match found. No need to continue.\n        hadSomething = true;\n        lastGoodCompoundResult = currentSplittedWordCompound;\n        break;\n      }\n\n      // Prefix match found. Check if the aliases are acceptable.\n\n      wstring result( Folding::applySimpleCaseOnly( gd::toWString( results[ x ].first ) ) );\n\n      if ( source.size() <= result.size() && result.compare( 0, source.size(), source ) == 0 )\n      {\n        // The resulting string begins with the source one\n\n        hadSomething = true;\n\n        if ( source.size() == result.size() )\n        {\n          // Got the match. No need to continue.\n          lastGoodCompoundResult = currentSplittedWordCompound;\n          break;\n        }\n      }\n    }\n\n    if ( hadSomething )\n    {\n      compoundSearchNextStep( true );\n      return;\n    }\n  }\n\n  compoundSearchNextStep( false );\n}\n\nvoid ArticleRequest::appendToData( std::string const & str )\n{\n  Mutex::Lock _( dataMutex );\n\n  size_t offset = data.size();\n\n  data.resize( data.size() + str.size() );\n\n  memcpy( &data.front() + offset, str.data(), str.size() );\n\n}\n\nQPair< ArticleRequest::Words, ArticleRequest::Spacings > ArticleRequest::splitIntoWords( QString const & input )\n{\n  QPair< Words, Spacings > result;\n\n  QChar const * ptr = input.data();\n\n  for( ; ; )\n  {\n    QString spacing;\n\n    for( ; ptr->unicode() && ( Folding::isPunct( ptr->unicode() ) || Folding::isWhitespace( ptr->unicode() ) ); ++ptr )\n      spacing.append( *ptr );\n\n    result.second.append( spacing );\n\n    QString word;\n\n    for( ; ptr->unicode() && !( Folding::isPunct( ptr->unicode() ) || Folding::isWhitespace( ptr->unicode() ) ); ++ptr )\n      word.append( *ptr );\n\n    if ( word.isEmpty() )\n      break;\n\n    result.first.append( word );\n  }\n\n  return result;\n}\n\nstring ArticleRequest::linkWord( QString const & str )\n{\n  QUrl url;\n\n  url.setScheme( \"gdlookup\" );\n  url.setHost( \"localhost\" );\n  url.setPath( Qt4x5::Url::ensureLeadingSlash( str ) );\n\n  string escapedResult = Html::escape( str.toUtf8().data() );\n  return string( \"<a href=\\\"\" ) + url.toEncoded().data() + \"\\\">\" + escapedResult +\"</a>\";\n}\n\nstd::string ArticleRequest::escapeSpacing( QString const & str )\n{\n  QByteArray spacing = Html::escape( str.toUtf8().data() ).c_str();\n\n  spacing.replace( \"\\n\", \"<br>\" );\n\n  return spacing.data();\n}\n\nvoid ArticleRequest::cancel()\n{\n    if( isFinished() )\n        return;\n    if( !altSearches.empty() )\n    {\n        for( list< sptr< Dictionary::WordSearchRequest > >::iterator i =\n               altSearches.begin(); i != altSearches.end(); ++i )\n        {\n            (*i)->cancel();\n        }\n    }\n    if( !bodyRequests.empty() )\n    {\n        for( list< sptr< Dictionary::DataRequest > >::iterator i =\n               bodyRequests.begin(); i != bodyRequests.end(); ++i )\n        {\n            (*i)->cancel();\n        }\n    }\n    if( stemmedWordFinder.get() ) stemmedWordFinder->cancel();\n    finish();\n}\n"
        },
        {
          "name": "article_maker.hh",
          "type": "blob",
          "size": 6.5791015625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __ARTICLE_MAKER_HH_INCLUDED__\n#define __ARTICLE_MAKER_HH_INCLUDED__\n\n#include <QObject>\n#include <QMap>\n#include <set>\n#include <list>\n#include \"config.hh\"\n#include \"dictionary.hh\"\n#include \"instances.hh\"\n#include \"wordfinder.hh\"\n\n/// This class generates the article's body for the given lookup request\nclass ArticleMaker: public QObject\n{\n  Q_OBJECT // We make it QObject to use tr() conveniently\n\n  std::vector< sptr< Dictionary::Class > > const & dictionaries;\n  std::vector< Instances::Group > const & groups;\n\n  QString displayStyle, addonStyle;\n\n  bool needExpandOptionalParts;\n  bool collapseBigArticles;\n  int articleLimitSize;\n\npublic:\n\n  /// On construction, a reference to all dictionaries and a reference all\n  /// groups' instances are to be passed. Those references are kept stored as\n  /// references, and as such, any changes to them would reflect on the results\n  /// of the inquiries, although those changes are perfectly legal.\n  ArticleMaker( std::vector< sptr< Dictionary::Class > > const & dictionaries,\n                std::vector< Instances::Group > const & groups,\n                QString const & displayStyle,\n                QString const & addonStyle);\n\n  /// Sets the display style to use for any new requests. This affects the\n  /// choice of the stylesheet file.\n  void setDisplayStyle( QString const &, QString const & addonStyle );\n\n  /// Looks up the given phrase within the given group, and creates a full html\n  /// page text containing its definition.\n  /// The result is returned as Dictionary::DataRequest just like dictionaries\n  /// themselves do. The difference is that the result is a complete html page\n  /// with all definitions from all the relevant dictionaries.\n  /// Contexts is a map of context values to be passed to each dictionary, where\n  /// the keys are dictionary ids.\n  /// If mutedDicts is not empty, the search would be limited only to those\n  /// dictionaries in group which aren't listed there.\n  sptr< Dictionary::DataRequest > makeDefinitionFor( Config::InputPhrase const & phrase, unsigned groupId,\n                                                     QMap< QString, QString > const & contexts,\n                                                     QSet< QString > const & mutedDicts =\n                                                       QSet< QString >(),\n                                                     QStringList const & dictIDs = QStringList(),\n                                                     bool ignoreDiacritics = false ) const;\n\n  /// Makes up a text which states that no translation for the given word\n  /// was found. Sometimes it's better to call this directly when it's already\n  /// known that there's no translation.\n  sptr< Dictionary::DataRequest > makeNotFoundTextFor( QString const & word, QString const & group ) const;\n\n  /// Creates an 'untitled' page. The result is guaranteed to be instant.\n  sptr< Dictionary::DataRequest > makeEmptyPage() const;\n\n  /// Create page with one picture\n  sptr< Dictionary::DataRequest > makePicturePage( std::string const & url ) const;\n\n  /// Set auto expanding optional parts of articles\n  void setExpandOptionalParts( bool expand );\n\n  /// Add base path to file path if it's relative and file not found\n  /// Return true if path successfully adjusted\n  static bool adjustFilePath( QString & fileName );\n\n  /// Set collapse articles parameters\n  void setCollapseParameters( bool autoCollapse, int articleSize );\n\nprivate:\n\n  /// Makes everything up to and including the opening body tag.\n  std::string makeHtmlHeader( QString const & word, QString const & icon,\n                              bool expandOptionalParts ) const;\n\n  /// Makes the html body for makeNotFoundTextFor()\n  static std::string makeNotFoundBody( QString const & word, QString const & group );\n\n  friend class ArticleRequest; // Allow it calling makeNotFoundBody()\n};\n\n/// The request specific to article maker. This should really be private,\n/// but we need it to be handled by moc.\nclass ArticleRequest: public Dictionary::DataRequest\n{\n  Q_OBJECT\n\n  QString word, group;\n  QMap< QString, QString > contexts;\n  std::vector< sptr< Dictionary::Class > > activeDicts;\n  \n  std::set< gd::wstring > alts; // Accumulated main forms\n  std::list< sptr< Dictionary::WordSearchRequest > > altSearches;\n  bool altsDone, bodyDone;\n  std::list< sptr< Dictionary::DataRequest > > bodyRequests;\n  bool foundAnyDefinitions;\n  bool closePrevSpan; // Indicates whether the last opened article span is to\n                      // be closed after the article ends.\n  sptr< WordFinder > stemmedWordFinder; // Used when there're no results\n\n  /// A sequence of words and spacings between them, including the initial\n  /// spacing before the first word and the final spacing after the last word.\n  typedef QList< QString > Words;\n  typedef QList< QString > Spacings;\n\n  /// Splits the given string into words and spacings between them.\n  QPair< Words, Spacings > splitIntoWords( QString const & );\n\n  QPair< Words, Spacings > splittedWords;\n  int currentSplittedWordStart;\n  int currentSplittedWordEnd;\n  QString currentSplittedWordCompound;\n  QString lastGoodCompoundResult;\n  bool firstCompoundWasFound;\n  int articleSizeLimit;\n  bool needExpandOptionalParts;\n  bool ignoreDiacritics;\n\npublic:\n\n  ArticleRequest( Config::InputPhrase const & phrase, QString const & group,\n                  QMap< QString, QString > const & contexts,\n                  std::vector< sptr< Dictionary::Class > > const & activeDicts,\n                  std::string const & header,\n                  int sizeLimit, bool needExpandOptionalParts_,\n                  bool ignoreDiacritics = false );\n\n  virtual void cancel();\n//  { finish(); } // Add our own requests cancellation here\n\nprivate slots:\n\n  void altSearchFinished();\n  void bodyFinished();\n  void stemmedSearchFinished();\n  void individualWordFinished();\n\nprivate:\n\n  /// Appends the given string to 'data', with locking its mutex.\n  void appendToData( std::string const & );\n\n  /// Uses stemmedWordFinder to perform the next step of looking up word\n  /// combinations.\n  void compoundSearchNextStep( bool lastSearchSucceeded );\n\n  /// Creates a single word out of the [currentSplittedWordStart..End] range.\n  QString makeSplittedWordCompound();\n\n  /// Makes an html link to the given word.\n  std::string linkWord( QString const & );\n\n  /// Escapes the spacing between the words to include in html.\n  std::string escapeSpacing( QString const & );\n\n  /// Find end of corresponding </div> tag\n  int findEndOfCloseDiv( QString const &, int pos );\n};\n\n\n#endif\n"
        },
        {
          "name": "article_netmgr.cc",
          "type": "blob",
          "size": 20.26953125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#if defined( _MSC_VER ) && _MSC_VER < 1800 // VS2012 and older\n#include <stdint_msvc.h>\n#else\n#include <stdint.h>\n#endif\n\n#include <QUrl>\n\n#include \"article_netmgr.hh\"\n#include \"wstring_qt.hh\"\n#include \"gddebug.hh\"\n#include \"qt4x5.hh\"\n\nusing std::string;\n\n#if QT_VERSION >= 0x050300 // Qt 5.3+\n\n  // SecurityWhiteList\n\n  SecurityWhiteList & SecurityWhiteList::operator=( SecurityWhiteList const & swl )\n  {\n    swlDelete();\n    swlCopy( swl );\n    return *this;\n  }\n\n  QWebSecurityOrigin * SecurityWhiteList::setOrigin( QUrl const & url )\n  {\n    swlDelete();\n    originUri = url.toString( QUrl::PrettyDecoded );\n    origin = new QWebSecurityOrigin( url );\n    return origin;\n  }\n\n  void SecurityWhiteList::swlCopy( SecurityWhiteList const & swl )\n  {\n    if( swl.origin )\n    {\n      hostsToAccess = swl.hostsToAccess;\n      originUri = swl.originUri;\n      origin = new QWebSecurityOrigin( QUrl( originUri ) );\n\n      for( QSet< QPair< QString, QString > >::iterator it = hostsToAccess.begin();\n           it != hostsToAccess.end(); ++it )\n        origin->addAccessWhitelistEntry( it->first, it->second, QWebSecurityOrigin::AllowSubdomains );\n    }\n  }\n\n  void SecurityWhiteList::swlDelete()\n  {\n    if( origin )\n    {\n      for( QSet< QPair< QString, QString > >::iterator it = hostsToAccess.begin();\n           it != hostsToAccess.end(); ++it )\n        origin->removeAccessWhitelistEntry( it->first, it->second, QWebSecurityOrigin::AllowSubdomains );\n\n      delete origin;\n      origin = 0;\n    }\n    hostsToAccess.clear();\n    originUri.clear();\n  }\n\n  // AllowFrameReply\n\n  AllowFrameReply::AllowFrameReply( QNetworkReply * _reply ) :\n    baseReply( _reply )\n  {\n    // Set base data\n\n    setOperation( baseReply->operation() );\n    setRequest( baseReply->request() );\n    setUrl( baseReply->url() );\n\n    // Signals to own slots\n\n    connect( baseReply, SIGNAL( metaDataChanged() ), this, SLOT( applyMetaData() ) );\n\n    connect( baseReply, SIGNAL( error( QNetworkReply::NetworkError) ),\n             this, SLOT( applyError( QNetworkReply::NetworkError ) ) );\n\n    connect( baseReply, SIGNAL( readyRead() ), this, SLOT( readDataFromBase() ) );\n\n    // Redirect QNetworkReply signals\n\n    connect( baseReply, SIGNAL( downloadProgress( qint64, qint64 ) ),\n             this, SIGNAL( downloadProgress( qint64, qint64 ) ) );\n\n    connect( baseReply, SIGNAL( encrypted() ), this, SIGNAL( encrypted() ) );\n\n    connect( baseReply, SIGNAL( finished() ), this, SIGNAL( finished() ) );\n\n    connect( baseReply, SIGNAL( preSharedKeyAuthenticationRequired( QSslPreSharedKeyAuthenticator * ) ),\n             this, SIGNAL( preSharedKeyAuthenticationRequired( QSslPreSharedKeyAuthenticator * ) ) );\n\n    connect( baseReply, SIGNAL( redirected( const QUrl & ) ), this, SIGNAL( redirected( const QUrl & ) ) );\n\n    connect( baseReply, SIGNAL( sslErrors( const QList< QSslError > & ) ),\n             this, SIGNAL( sslErrors( const QList< QSslError > & ) ) );\n\n    connect( baseReply, SIGNAL( uploadProgress( qint64, qint64 ) ),\n             this, SIGNAL( uploadProgress( qint64, qint64 ) ) );\n\n    // Redirect QIODevice signals\n\n    connect( baseReply, SIGNAL( aboutToClose() ), this, SIGNAL( aboutToClose() ) );\n\n    connect( baseReply, SIGNAL( bytesWritten( qint64 ) ), this, SIGNAL( bytesWritten( qint64 ) ) );\n\n    connect( baseReply, SIGNAL( readChannelFinished() ), this, SIGNAL( readChannelFinished() ) );\n\n    setOpenMode( QIODevice::ReadOnly );\n  }\n\n  void AllowFrameReply::applyMetaData()\n  {\n    // Set raw headers except X-Frame-Options\n    QList< QByteArray > rawHeaders = baseReply->rawHeaderList();\n    for( QList< QByteArray >::iterator it = rawHeaders.begin(); it != rawHeaders.end(); ++it )\n    {\n      if( it->toLower() != \"x-frame-options\" )\n        setRawHeader( *it, baseReply->rawHeader( *it ) );\n    }\n\n    // Set known headers\n    setHeader( QNetworkRequest::ContentDispositionHeader,\n               baseReply->header( QNetworkRequest::ContentDispositionHeader ) );\n    setHeader( QNetworkRequest::ContentTypeHeader,\n               baseReply->header( QNetworkRequest::ContentTypeHeader ) );\n    setHeader( QNetworkRequest::ContentLengthHeader,\n               baseReply->header( QNetworkRequest::ContentLengthHeader ) );\n    setHeader( QNetworkRequest::LocationHeader,\n               baseReply->header( QNetworkRequest::LocationHeader ) );\n    setHeader( QNetworkRequest::LastModifiedHeader,\n               baseReply->header( QNetworkRequest::LastModifiedHeader ) );\n    setHeader( QNetworkRequest::CookieHeader,\n               baseReply->header( QNetworkRequest::CookieHeader ) );\n    setHeader( QNetworkRequest::SetCookieHeader,\n               baseReply->header( QNetworkRequest::SetCookieHeader ) );\n    setHeader( QNetworkRequest::UserAgentHeader,\n               baseReply->header( QNetworkRequest::UserAgentHeader ) );\n    setHeader( QNetworkRequest::ServerHeader,\n               baseReply->header( QNetworkRequest::ServerHeader ) );\n\n    // Set attributes\n    setAttribute( QNetworkRequest::HttpStatusCodeAttribute,\n                  baseReply->attribute( QNetworkRequest::HttpStatusCodeAttribute ) );\n    setAttribute( QNetworkRequest::HttpReasonPhraseAttribute,\n                  baseReply->attribute( QNetworkRequest::HttpReasonPhraseAttribute ) );\n    setAttribute( QNetworkRequest::RedirectionTargetAttribute,\n                  baseReply->attribute( QNetworkRequest::RedirectionTargetAttribute ) );\n    setAttribute( QNetworkRequest::ConnectionEncryptedAttribute,\n                  baseReply->attribute( QNetworkRequest::ConnectionEncryptedAttribute ) );\n    setAttribute( QNetworkRequest::SourceIsFromCacheAttribute,\n                  baseReply->attribute( QNetworkRequest::SourceIsFromCacheAttribute ) );\n    setAttribute( QNetworkRequest::HttpPipeliningWasUsedAttribute,\n                  baseReply->attribute( QNetworkRequest::HttpPipeliningWasUsedAttribute ) );\n    setAttribute( QNetworkRequest::BackgroundRequestAttribute,\n                  baseReply->attribute( QNetworkRequest::BackgroundRequestAttribute ) );\n    setAttribute( QNetworkRequest::SpdyWasUsedAttribute,\n                  baseReply->attribute( QNetworkRequest::SpdyWasUsedAttribute ) );\n\n    emit metaDataChanged();\n  }\n\n  void AllowFrameReply::setReadBufferSize( qint64 size )\n  {\n    QNetworkReply::setReadBufferSize( size );\n    baseReply->setReadBufferSize( size );\n  }\n\n  qint64 AllowFrameReply::bytesAvailable() const\n  {\n    return buffer.size() + QNetworkReply::bytesAvailable();\n  }\n\n  void AllowFrameReply::applyError( QNetworkReply::NetworkError code )\n  {\n    setError( code, baseReply->errorString() );\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 15, 0 )\n    emit errorOccurred( code );\n#else\n    emit error( code );\n#endif\n  }\n\n  void AllowFrameReply::readDataFromBase()\n  {\n    QByteArray data;\n    data.resize( baseReply->bytesAvailable() );\n    baseReply->read( data.data(), data.size() );\n    buffer += data;\n    emit readyRead();\n  }\n\n  qint64 AllowFrameReply::readData( char * data, qint64 maxSize )\n  {\n    qint64 size = qMin( maxSize, qint64( buffer.size() ) );\n    memcpy( data, buffer.data(), size );\n    buffer.remove( 0, size );\n    return size;\n  }\n\n#endif\n\nnamespace\n{\n  /// Uses some heuristics to chop off the first domain name from the host name,\n  /// but only if it's not too base. Returns the resulting host name.\n  QString getHostBase( QUrl const & url )\n  {\n    QString host = url.host();\n\n    QStringList domains = host.split( '.' );\n\n    int left = domains.size();\n\n    // Skip last <=3-letter domain name\n    if ( left && domains[ left - 1 ].size() <= 3 )\n      --left;\n\n    // Skip another <=3-letter domain name\n    if ( left && domains[ left - 1 ].size() <= 3 )\n      --left;\n\n    if ( left > 1 )\n    {\n      // We've got something like www.foobar.co.uk -- we can chop off the first\n      // domain\n\n      return host.mid( domains[ 0 ].size() + 1 );\n    }\n    else\n      return host;\n  }\n}\n\nQNetworkReply * ArticleNetworkAccessManager::createRequest( Operation op,\n                                                            QNetworkRequest const & req,\n                                                            QIODevice * outgoingData )\n{\n  QNetworkRequest localReq( req );\n\n  if( ( localReq.url().scheme() == \"gdlookup\" || localReq.url().scheme() == \"http\" ) && localReq.url().host() == \"upload.wikimedia.org\" )\n  {\n    // Handle some requests from offline wikipedia/wiktionary without scheme or with \"http\" scheme\n\n    QUrl newUrl( req.url() );\n    newUrl.setScheme( \"https\" );\n    localReq.setUrl( newUrl );\n  }\n\n  if ( op == GetOperation )\n  {\n    if ( localReq.url().scheme() == \"qrcx\" )\n    {\n      // We have to override the local load policy for the qrc scheme, hence\n      // we use qrcx and redirect it here back to qrc\n      QUrl newUrl( localReq.url() );\n\n      newUrl.setScheme( \"qrc\" );\n      newUrl.setHost( \"\" );\n\n      localReq.setUrl( newUrl );\n\n      return QNetworkAccessManager::createRequest( op, localReq, outgoingData );\n    }\n\n#if QT_VERSION >= 0x050300 // Qt 5.3+\n    // Workaround of same-origin policy\n    if( ( localReq.url().scheme().startsWith( \"http\" ) || localReq.url().scheme() == \"ftp\" )\n        && localReq.hasRawHeader( \"Referer\" ) )\n    {\n      QByteArray referer = localReq.rawHeader( \"Referer\" );\n      QUrl refererUrl = QUrl::fromEncoded( referer );\n\n      if( refererUrl.scheme().startsWith( \"http\") || refererUrl.scheme() == \"ftp\" )\n      {\n        // Only for pages from network resources\n        if ( !localReq.url().host().endsWith( refererUrl.host() ) )\n        {\n          QUrl frameUrl;\n          frameUrl.setScheme( refererUrl.scheme() );\n          frameUrl.setHost( refererUrl.host() );\n          QString frameStr = frameUrl.toString( QUrl::PrettyDecoded );\n\n          SecurityWhiteList & value = allOrigins[ frameStr ];\n          if( !value.origin )\n            value.setOrigin( frameUrl );\n\n          QPair< QString, QString > target( localReq.url().scheme(), localReq.url().host() );\n          if( value.hostsToAccess.find( target ) == value.hostsToAccess.end() )\n          {\n            value.hostsToAccess.insert( target );\n            value.origin->addAccessWhitelistEntry( target.first, target.second,\n                                                   QWebSecurityOrigin::AllowSubdomains );\n          }\n        }\n      }\n    }\n#endif\n\n    QString contentType;\n\n    sptr< Dictionary::DataRequest > dr = getResource( localReq.url(), contentType );\n\n    if ( dr.get() )\n      return new ArticleResourceReply( this, localReq, dr, contentType );\n  }\n\n  // Check the Referer. If the user has opted-in to block elements from external\n  // pages, we block them.\n\n  if ( disallowContentFromOtherSites && localReq.hasRawHeader( \"Referer\" ) )\n  {\n    QByteArray referer = localReq.rawHeader( \"Referer\" );\n\n    //DPRINTF( \"Referer: %s\\n\", referer.data() );\n\n    QUrl refererUrl = QUrl::fromEncoded( referer );\n\n    //DPRINTF( \"Considering %s vs %s\\n\", getHostBase( localReq.url() ).toUtf8().data(),\n    //        getHostBase( refererUrl ).toUtf8().data() );\n\n    if ( !localReq.url().host().endsWith( refererUrl.host() ) &&\n         getHostBase( localReq.url() ) != getHostBase( refererUrl ) && !localReq.url().scheme().startsWith(\"data\") )\n    {\n      gdWarning( \"Blocking element \\\"%s\\\"\\n\", localReq.url().toEncoded().data() );\n\n      return new BlockedNetworkReply( this );\n    }\n  }\n\n  if( localReq.url().scheme() == \"file\" )\n  {\n    // Check file presence and adjust path if necessary\n    QString fileName = localReq.url().toLocalFile();\n    if( localReq.url().host().isEmpty() && articleMaker.adjustFilePath( fileName ) )\n    {\n      QUrl newUrl( localReq.url() );\n      QUrl localUrl = QUrl::fromLocalFile( fileName );\n\n      newUrl.setHost( localUrl.host() );\n      newUrl.setPath( Qt4x5::Url::ensureLeadingSlash( localUrl.path() ) );\n\n      localReq.setUrl( newUrl );\n\n      return QNetworkAccessManager::createRequest( op, localReq, outgoingData );\n    }\n  }\n\n  QNetworkReply *reply = 0;\n\n  // spoof User-Agent\n  if ( hideGoldenDictHeader && localReq.url().scheme().startsWith(\"http\", Qt::CaseInsensitive))\n  {\n    QByteArray const userAgentHeader = \"User-Agent\";\n    localReq.setRawHeader( userAgentHeader,\n                           localReq.rawHeader( userAgentHeader ).replace( qApp->applicationName().toUtf8(), \"\" ) );\n    reply = QNetworkAccessManager::createRequest( op, localReq, outgoingData );\n  }\n\n  if( !reply )\n    reply = QNetworkAccessManager::createRequest( op, localReq, outgoingData );\n\n  if( localReq.url().scheme() == \"https\")\n  {\n#ifndef QT_NO_OPENSSL\n    connect( reply, SIGNAL( sslErrors( QList< QSslError > ) ),\n             reply, SLOT( ignoreSslErrors() ) );\n#endif\n  }\n\n#if QT_VERSION >= 0x050300 // Qt 5.3+\n  return op == QNetworkAccessManager::GetOperation\n         || op == QNetworkAccessManager::HeadOperation ? new AllowFrameReply( reply ) : reply;\n#else\n  return reply;\n#endif\n}\n\nsptr< Dictionary::DataRequest > ArticleNetworkAccessManager::getResource(\n  QUrl const & url, QString & contentType )\n{\n  GD_DPRINTF( \"getResource: %ls\\n\", url.toString().toStdWString().c_str() );\n  GD_DPRINTF( \"scheme: %ls\\n\", url.scheme().toStdWString().c_str() );\n  GD_DPRINTF( \"host: %ls\\n\", url.host().toStdWString().c_str() );\n\n  if ( url.scheme() == \"gdlookup\" )\n  {\n    if( !url.host().isEmpty() && url.host() != \"localhost\" )\n    {\n      // Strange request - ignore it\n      return new Dictionary::DataRequestInstant( false );\n    }\n\n    contentType = \"text/html\";\n\n    if ( Qt4x5::Url::queryItemValue( url, \"blank\" ) == \"1\" )\n      return articleMaker.makeEmptyPage();\n\n    Config::InputPhrase phrase ( Qt4x5::Url::queryItemValue( url, \"word\" ).trimmed(),\n                                 Qt4x5::Url::queryItemValue( url, \"punctuation_suffix\" ) );\n\n    bool groupIsValid = false;\n    unsigned group = Qt4x5::Url::queryItemValue( url, \"group\" ).toUInt( &groupIsValid );\n   \n    QString dictIDs = Qt4x5::Url::queryItemValue( url, \"dictionaries\" );\n    if( !dictIDs.isEmpty() )\n    {\n      // Individual dictionaries set from full-text search\n      QStringList dictIDList = dictIDs.split( \",\" );\n      return articleMaker.makeDefinitionFor( phrase, 0, QMap< QString, QString >(), QSet< QString >(), dictIDList );\n    }\n\n    // See if we have some dictionaries muted\n\n    QStringList const mutedDictList = Qt4x5::Url::queryItemValue( url, \"muted\" ).split( ',' );\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 14, 0 )\n    QSet< QString > const mutedDicts( mutedDictList.cbegin(), mutedDictList.cend() );\n#else\n    QSet< QString > const mutedDicts = QSet< QString >::fromList( mutedDictList );\n#endif\n\n    // Unpack contexts\n\n    QMap< QString, QString > contexts;\n\n    QString contextsEncoded = Qt4x5::Url::queryItemValue( url, \"contexts\" );\n\n    if ( contextsEncoded.size() )\n    {\n      QByteArray ba = QByteArray::fromBase64( contextsEncoded.toLatin1() );\n\n      QBuffer buf( & ba );\n\n      buf.open( QBuffer::ReadOnly );\n\n      QDataStream stream( &buf );\n\n      stream >> contexts;\n    }\n\n    // See for ignore diacritics\n\n    bool ignoreDiacritics = Qt4x5::Url::queryItemValue( url, \"ignore_diacritics\" ) == \"1\";\n\n    if ( groupIsValid && phrase.isValid() ) // Require group and phrase to be passed\n      return articleMaker.makeDefinitionFor( phrase, group, contexts, mutedDicts, QStringList(), ignoreDiacritics );\n  }\n\n  if ( ( url.scheme() == \"bres\" || url.scheme() == \"gdau\" || url.scheme() == \"gdvideo\" || url.scheme() == \"gico\" ) &&\n       url.path().size() )\n  {\n    //DPRINTF( \"Get %s\\n\", req.url().host().toLocal8Bit().data() );\n    //DPRINTF( \"Get %s\\n\", req.url().path().toLocal8Bit().data() );\n\n    string id = url.host().toStdString();\n\n    bool search = ( id == \"search\" );\n\n    if ( !search )\n    {\n      for( unsigned x = 0; x < dictionaries.size(); ++x )\n        if ( dictionaries[ x ]->getId() == id )\n        {\n            if( url.scheme() == \"gico\" )\n            {\n                QByteArray bytes;\n                QBuffer buffer(&bytes);\n                buffer.open(QIODevice::WriteOnly);\n                dictionaries[ x ]->getIcon().pixmap( 16 ).save(&buffer, \"PNG\");\n                buffer.close();\n                sptr< Dictionary::DataRequestInstant > ico = new Dictionary::DataRequestInstant( true );\n                ico->getData().resize( bytes.size() );\n                memcpy( &( ico->getData().front() ), bytes.data(), bytes.size() );\n                return ico;\n            }\n            try\n            {\n              return  dictionaries[ x ]->getResource( Qt4x5::Url::fullPath( url ).mid( 1 ).toUtf8().data() );\n            }\n            catch( std::exception & e )\n            {\n              gdWarning( \"getResource request error (%s) in \\\"%s\\\"\\n\", e.what(),\n                         dictionaries[ x ]->getName().c_str() );\n              return sptr< Dictionary::DataRequest >();\n            }\n        }\n    }\n    else\n    {\n      // We don't do search requests for now\n#if 0\n      for( unsigned x = 0; x < dictionaries.size(); ++x )\n      {\n        if ( search || dictionaries[ x ]->getId() == id )\n        {\n          try\n          {\n            dictionaries[ x ]->getResource( url.path().mid( 1 ).toUtf8().data(),\n                                            data );\n\n            return true;\n          }\n          catch( Dictionary::exNoSuchResource & )\n          {\n            if ( !search )\n              break;\n          }\n        }\n      }\n#endif      \n    }\n  }\n\n  if ( url.scheme() == \"gdpicture\" )\n  {\n    contentType = \"text/html\";\n    QUrl imgUrl ( url );\n    imgUrl.setScheme( \"bres\" );\n    return articleMaker.makePicturePage( imgUrl.toEncoded().data() );\n  }\n\n  return sptr< Dictionary::DataRequest >();\n}\n\nArticleResourceReply::ArticleResourceReply( QObject * parent,\n  QNetworkRequest const & netReq,\n  sptr< Dictionary::DataRequest > const & req_,\n  QString const & contentType ):\n  QNetworkReply( parent ), req( req_ ), alreadyRead( 0 )\n{\n  setRequest( netReq );\n\n  setOpenMode( ReadOnly );\n\n  if ( contentType.size() )\n    setHeader( QNetworkRequest::ContentTypeHeader, contentType );\n\n  connect( req.get(), SIGNAL( updated() ),\n           this, SLOT( reqUpdated() ) );\n  \n  connect( req.get(), SIGNAL( finished() ),\n           this, SLOT( reqFinished() ) );\n  \n  if ( req->isFinished() || req->dataSize() > 0 )\n  {\n    connect( this, SIGNAL( readyReadSignal() ),\n             this, SLOT( readyReadSlot() ), Qt::QueuedConnection );\n    connect( this, SIGNAL( finishedSignal() ),\n             this, SLOT( finishedSlot() ), Qt::QueuedConnection );\n\n    emit readyReadSignal();\n\n    if ( req->isFinished() )\n    {\n      emit finishedSignal();\n      GD_DPRINTF( \"In-place finish.\\n\" );\n    }\n  }\n}\n\nArticleResourceReply::~ArticleResourceReply()\n{\n  req->cancel();\n}\n\nvoid ArticleResourceReply::reqUpdated()\n{\n  emit readyRead();\n}\n\nvoid ArticleResourceReply::reqFinished()\n{\n  emit readyRead();\n  finishedSlot();\n}\n\nqint64 ArticleResourceReply::bytesAvailable() const\n{\n  qint64 avail = req->dataSize();\n  \n  if ( avail < 0 )\n    return 0;\n  \n  return avail - alreadyRead + QNetworkReply::bytesAvailable();\n}\n\nqint64 ArticleResourceReply::readData( char * out, qint64 maxSize )\n{\n  // From the doc: \"This function might be called with a maxSize of 0,\n  // which can be used to perform post-reading operations\".\n  if ( maxSize == 0 )\n    return 0;\n\n  GD_DPRINTF( \"====reading %d bytes\\n\", (int)maxSize );\n\n  bool finished = req->isFinished();\n  \n  qint64 avail = req->dataSize();\n\n  if ( avail < 0 )\n    return finished ? -1 : 0;\n\n  qint64 left = avail - alreadyRead;\n  \n  qint64 toRead = maxSize < left ? maxSize : left;\n\n  try\n  {\n    req->getDataSlice( alreadyRead, toRead, out );\n  }\n  catch( std::exception & e )\n  {\n    qWarning( \"getDataSlice error: %s\\n\", e.what() );\n  }\n\n  alreadyRead += toRead;\n\n  if ( !toRead && finished )\n    return -1;\n  else\n    return toRead;\n}\n\nvoid ArticleResourceReply::readyReadSlot()\n{\n  readyRead();\n}\n\nvoid ArticleResourceReply::finishedSlot()\n{\n  if ( req->dataSize() < 0 )\n  {\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 15, 0 )\n    emit errorOccurred( ContentNotFoundError );\n#else\n    emit error( ContentNotFoundError );\n#endif\n  }\n\n  finished();\n}\n\nBlockedNetworkReply::BlockedNetworkReply( QObject * parent ): QNetworkReply( parent )\n{\n  setError( QNetworkReply::ContentOperationNotPermittedError, \"Content Blocked\" );\n\n  connect( this, SIGNAL( finishedSignal() ), this, SLOT( finishedSlot() ),\n           Qt::QueuedConnection );\n\n  emit finishedSignal(); // This way we call readyRead()/finished() sometime later\n}\n\n\nvoid BlockedNetworkReply::finishedSlot()\n{\n  emit readyRead();\n  emit finished();\n}\n"
        },
        {
          "name": "article_netmgr.hh",
          "type": "blob",
          "size": 6.015625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __ARTICLE_NETMGR_HH_INCLUDED__\n#define __ARTICLE_NETMGR_HH_INCLUDED__\n\n#include <QtNetwork>\n\n#if QT_VERSION >= 0x050300  // Qt 5.3+\n#include <QWebSecurityOrigin>\n#include <QSet>\n#include <QMap>\n#include <QPair>\n#endif\n\n#include \"dictionary.hh\"\n#include \"article_maker.hh\"\n\nusing std::vector;\n\n/// A custom QNetworkAccessManager version which fetches images from the\n/// dictionaries when requested.\n\n#if QT_VERSION >= 0x050300  // Qt 5.3+\n\n// White lists for QWebSecurityOrigin\nstruct SecurityWhiteList\n{\n  QWebSecurityOrigin * origin;\n  QString originUri;\n  QSet< QPair< QString, QString > > hostsToAccess;\n\n  SecurityWhiteList() :\n    origin( 0 )\n  {}\n\n  ~SecurityWhiteList()\n  { swlDelete(); }\n\n  SecurityWhiteList( SecurityWhiteList const & swl ) :\n    origin( 0 )\n  { swlCopy( swl ); }\n\n  SecurityWhiteList & operator=( SecurityWhiteList const & swl );\n  QWebSecurityOrigin * setOrigin( QUrl const & url );\n\nprivate:\n  void swlCopy( SecurityWhiteList const & swl );\n  void swlDelete();\n};\n\ntypedef QMap< QString, SecurityWhiteList > Origins;\n\n// Proxy class for QNetworkReply to remove X-Frame-Options header\n// It allow to show websites in <iframe> tag like Qt 4.x\n\nclass AllowFrameReply : public QNetworkReply\n{\n  Q_OBJECT\nprivate:\n  QNetworkReply * baseReply;\n  QByteArray buffer;\n\n  AllowFrameReply();\n  AllowFrameReply( AllowFrameReply const & );\n\npublic:\n  explicit AllowFrameReply( QNetworkReply * _reply );\n  ~AllowFrameReply()\n  { delete baseReply; }\n\n  // QNetworkReply virtual functions\n  void setReadBufferSize( qint64 size );\n  void close()\n  { baseReply->close(); }\n\n  // QIODevice virtual functions\n  qint64 bytesAvailable() const;\n  bool atEnd() const\n  { return baseReply->atEnd(); }\n  qint64 bytesToWrite() const\n  { return baseReply->bytesToWrite(); }\n  bool canReadLine() const\n  { return baseReply->canReadLine(); }\n  bool isSequential() const\n  { return baseReply->isSequential(); }\n  bool waitForReadyRead( int msecs )\n  { return baseReply->waitForReadyRead( msecs ); }\n  bool waitForBytesWritten( int msecs )\n  { return baseReply->waitForBytesWritten( msecs ); }\n  bool reset()\n  { return baseReply->reset(); }\n\npublic slots:\n\n  // Own AllowFrameReply slots\n  void applyMetaData();\n  void applyError( QNetworkReply::NetworkError code );\n  void readDataFromBase();\n\n  // Redirect QNetworkReply slots\n  virtual void abort()\n  { baseReply->abort(); }\n  virtual void ignoreSslErrors()\n  { baseReply->ignoreSslErrors(); }\n\nprotected:\n  // QNetworkReply virtual functions\n  void ignoreSslErrorsImplementation( const QList< QSslError > & errors )\n  { baseReply->ignoreSslErrors( errors ); }\n  void setSslConfigurationImplementation( const QSslConfiguration & configuration )\n  { baseReply->setSslConfiguration( configuration ); }\n  void sslConfigurationImplementation( QSslConfiguration & configuration ) const\n  { configuration = baseReply->sslConfiguration(); }\n\n  // QIODevice virtual functions\n  qint64 readData( char * data, qint64 maxSize );\n  qint64 readLineData( char * data, qint64 maxSize )\n  { return baseReply->readLine( data, maxSize ); }\n  qint64 writeData( const char * data, qint64 maxSize )\n  { return baseReply->write( data, maxSize ); }\n};\n#endif\n\nclass ArticleNetworkAccessManager: public QNetworkAccessManager\n{\n  vector< sptr< Dictionary::Class > > const & dictionaries;\n  ArticleMaker const & articleMaker;\n  bool const & disallowContentFromOtherSites;\n  bool const & hideGoldenDictHeader;\n#if QT_VERSION >= 0x050300  // Qt 5.3+\n  Origins allOrigins;\n#endif\npublic:\n\n  ArticleNetworkAccessManager( QObject * parent,\n                               vector< sptr< Dictionary::Class > > const &\n                               dictionaries_,\n                               ArticleMaker const & articleMaker_,\n                               bool const & disallowContentFromOtherSites_,\n                               bool const & hideGoldenDictHeader_ ):\n    QNetworkAccessManager( parent ), dictionaries( dictionaries_ ),\n    articleMaker( articleMaker_ ),\n    disallowContentFromOtherSites( disallowContentFromOtherSites_ ),\n    hideGoldenDictHeader( hideGoldenDictHeader_ )\n  {}\n\n  /// Tries handling any kind of internal resources referenced by dictionaries.\n  /// If it succeeds, the result is a dictionary request object. Otherwise, an\n  /// empty pointer is returned.\n  /// The function can optionally set the Content-Type header correspondingly.\n  sptr< Dictionary::DataRequest > getResource( QUrl const & url,\n                                               QString & contentType );\n\nprotected:\n\n  virtual QNetworkReply * createRequest( Operation op,\n                                         QNetworkRequest const & req,\n                                         QIODevice * outgoingData );\n};\n\nclass ArticleResourceReply: public QNetworkReply\n{\n  Q_OBJECT\n\n  sptr< Dictionary::DataRequest > req;\n  qint64 alreadyRead;\n\npublic:\n\n  ArticleResourceReply( QObject * parent,\n                        QNetworkRequest const &,\n                        sptr< Dictionary::DataRequest > const &,\n                        QString const & contentType );\n\n  ~ArticleResourceReply();\n\nprotected:\n\n  virtual qint64 bytesAvailable() const;\n\n  virtual void abort()\n  {}\n  virtual qint64 readData( char * data, qint64 maxSize );\n\n  // We use the hackery below to work around the fact that we need to emit\n  // ready/finish signals after we've been constructed.\nsignals:\n\n  void readyReadSignal();\n  void finishedSignal();\n\nprivate slots:\n\n  void reqUpdated();\n  void reqFinished();\n  \n  void readyReadSlot();\n  void finishedSlot();\n};\n\nclass BlockedNetworkReply: public QNetworkReply\n{\n  Q_OBJECT\n\npublic:\n\n  BlockedNetworkReply( QObject * parent );\n\n  virtual qint64 readData( char *, qint64 )\n  {\n    return -1;\n  }\n\n  virtual void abort()\n  {}\n\nprotected:\n\n  // We use the hackery below to work around the fact that we need to emit\n  // ready/finish signals after we've been constructed.\n\nsignals:\n\n  void finishedSignal();\n\nprivate slots:\n\n  void finishedSlot();\n};\n\n#endif\n"
        },
        {
          "name": "articleinspector.cc",
          "type": "blob",
          "size": 1.3544921875,
          "content": "#include \"articleinspector.hh\"\n\n#if QT_VERSION >= 0x040600\n\n#include <algorithm>\n\nusing std::list;\n\nlist< ArticleInspector * > ArticleInspector::openedInspectors;\n\nArticleInspector::ArticleInspector( Config::Class * cfg, QWidget* parent ) :\n  QWebInspector( parent ),\n  cfg( cfg )\n{\n  if ( cfg == NULL )\n    throw exInit();\n}\n\nArticleInspector::~ArticleInspector()\n{\n}\n\nvoid ArticleInspector::beforeClosed()\n{\n  list< ArticleInspector * >::iterator itemIter = std::find( openedInspectors.begin(),\n                                                             openedInspectors.end(), this );\n  if ( itemIter != openedInspectors.end() )\n  {\n    openedInspectors.erase( itemIter );\n    // Save geometry of the recent closed inspector window\n    QByteArray geometry = saveGeometry();\n    cfg->inspectorGeometry = geometry;\n  }\n}\n\nvoid ArticleInspector::showEvent( QShowEvent * event )\n{\n  if ( openedInspectors.empty() )\n  {\n    // Restore geometry from config, if no inspector opened\n    restoreGeometry( cfg->inspectorGeometry );\n  }\n  else\n  {\n    // Load geometry from first inspector opened\n    ArticleInspector * p = openedInspectors.front();\n    setGeometry( p->geometry() );\n  }\n\n  if( std::find( openedInspectors.begin(), openedInspectors.end(), this ) == openedInspectors.end() )\n    openedInspectors.push_back( this );\n\n  QWebInspector::showEvent( event );\n}\n\n#endif // QT_VERSION\n"
        },
        {
          "name": "articleinspector.hh",
          "type": "blob",
          "size": 0.6435546875,
          "content": "#ifndef ARTICLEINSPECTOR_HH\n#define ARTICLEINSPECTOR_HH\n\n#include <QtGlobal>\n\n#if QT_VERSION >= 0x040600\n\n#include <QWebInspector>\n#include <list>\n#include \"config.hh\"\n#include \"ex.hh\"\n\nclass ArticleInspector : public QWebInspector\n{\nQ_OBJECT\n\npublic:\n  DEF_EX( exInit, \"Article inspector failed to init\", std::exception )\n\n  explicit ArticleInspector( Config::Class * cfg,  QWidget* parent = 0 );\n  ~ArticleInspector();\n\npublic slots:\n  void beforeClosed();\n\nprotected:\n  void showEvent( QShowEvent *event );\n\nprivate:\n  Config::Class * cfg;\n\n  static std::list< ArticleInspector * > openedInspectors;\n};\n\n#endif // QT_VERSION\n\n#endif // ARTICLEINSPECTOR_HH\n"
        },
        {
          "name": "articleview.cc",
          "type": "blob",
          "size": 91.0400390625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"articleview.hh\"\n#include <map>\n#include <QMessageBox>\n#include <QWebHitTestResult>\n#include <QMenu>\n#include <QDesktopServices>\n#include <QWebHistory>\n#include <QClipboard>\n#include <QKeyEvent>\n#include <QFileDialog>\n#include \"folding.hh\"\n#include \"wstring_qt.hh\"\n#include \"webmultimediadownload.hh\"\n#include \"programs.hh\"\n#include \"gddebug.hh\"\n#include <QDebug>\n#include <QCryptographicHash>\n#include \"gestures.hh\"\n#include \"fulltextsearch.hh\"\n\n#if QT_VERSION >= 0x040600\n#include <QWebElement>\n#include <QWebElementCollection>\n#endif\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n#include <QRegularExpression>\n#include \"wildcard.hh\"\n#endif\n\n#include \"qt4x5.hh\"\n\n#include <assert.h>\n\n#ifdef Q_OS_WIN32\n#include <windows.h>\n\n#include <QPainter>\n#endif\n\n#include <QBuffer>\n\n#if defined( Q_OS_WIN32 ) || defined( Q_OS_MAC )\n#include \"speechclient.hh\"\n#endif\n\nusing std::map;\nusing std::list;\n\n/// This class exposes only slim, minimal API to JavaScript clients in order to\n/// reduce attack surface available to potentionally malicious external scripts.\nclass ArticleViewJsProxy: public QObject\n{\n  Q_OBJECT\npublic:\n  /// Note: view becomes the parent of this proxy object.\n  explicit ArticleViewJsProxy( ArticleView & view ):\n    QObject( &view ), articleView( view )\n  {}\n\n  Q_INVOKABLE void onJsActiveArticleChanged( QString const & id )\n  { articleView.onJsActiveArticleChanged( id ); }\n\nprivate:\n  ArticleView & articleView;\n};\n\n/// AccentMarkHandler class\n///\n/// Remove accent marks from text\n/// and mirror position in normalized text to original text\n\nclass AccentMarkHandler\n{\nprotected:\n  QString normalizedString;\n  QVector< int > accentMarkPos;\npublic:\n  AccentMarkHandler()\n  {}\n  virtual ~AccentMarkHandler()\n  {}\n  static QChar accentMark()\n  { return QChar( 0x301 ); }\n\n  /// Create text without accent marks\n  /// and store mark positions\n  virtual void setText( QString const & baseString )\n  {\n    accentMarkPos.clear();\n    normalizedString.clear();\n    int pos = 0;\n    QChar mark = accentMark();\n\n    for( int x = 0; x < baseString.length(); x++ )\n    {\n      if( baseString.at( x ) == mark )\n      {\n        accentMarkPos.append( pos );\n        continue;\n      }\n      normalizedString.append( baseString.at( x ) );\n      pos++;\n    }\n  }\n\n  /// Return text without accent marks\n  QString const & normalizedText() const\n  { return normalizedString; }\n\n  /// Convert position into position in original text\n  int mirrorPosition( int const & pos ) const\n  {\n    int newPos = pos;\n    for( int x = 0; x < accentMarkPos.size(); x++ )\n    {\n      if( accentMarkPos.at( x ) < pos )\n        newPos++;\n      else\n        break;\n    }\n    return newPos;\n  }\n};\n\n/// End of DslAccentMark class\n\n/// DiacriticsHandler class\n///\n/// Remove diacritics from text\n/// and mirror position in normalized text to original text\n\nclass DiacriticsHandler : public AccentMarkHandler\n{\npublic:\n  DiacriticsHandler()\n  {}\n  ~DiacriticsHandler()\n  {}\n\n  /// Create text without diacriticss\n  /// and store diacritic marks positions\n  virtual void setText( QString const & baseString )\n  {\n    accentMarkPos.clear();\n    normalizedString.clear();\n\n    gd::wstring baseText = gd::toWString( baseString );\n    gd::wstring normText;\n\n    int pos = 0;\n    normText.reserve( baseText.size() );\n\n    gd::wchar const * nextChar = baseText.data();\n    size_t consumed;\n\n    for( size_t left = baseText.size(); left; )\n    {\n      if( *nextChar >= 0x10000 )\n      {\n        // Will be translated into surrogate pair\n        normText.push_back( *nextChar );\n        pos += 2;\n        nextChar++; left--;\n        continue;\n      }\n\n      gd::wchar ch = Folding::foldedDiacritic( nextChar, left, consumed );\n\n      if( Folding::isCombiningMark( ch ) )\n      {\n        accentMarkPos.append( pos );\n        nextChar++; left--;\n        continue;\n      }\n\n      if( consumed > 1 )\n      {\n        for( size_t i = 1; i < consumed; i++ )\n          accentMarkPos.append( pos );\n      }\n\n      normText.push_back( ch );\n      pos += 1;\n      nextChar += consumed;\n      left -= consumed;\n    }\n    normalizedString = gd::toQString( normText );\n  }\n};\n\n/// End of DiacriticsHandler class\n\nstatic QVariant evaluateJavaScriptVariableSafe( QWebFrame * frame, const QString & variable )\n{\n  return frame->evaluateJavaScript(\n        QString( \"( typeof( %1 ) !== 'undefined' && %1 !== undefined ) ? %1 : null;\" )\n        .arg( variable ) );\n}\n\nnamespace {\n\nchar const * const scrollToPrefix = \"gdfrom-\";\n\nbool isScrollTo( QString const & id )\n{\n  return id.startsWith( scrollToPrefix );\n}\n\nQString dictionaryIdFromScrollTo( QString const & scrollTo )\n{\n  Q_ASSERT( isScrollTo( scrollTo ) );\n  const int scrollToPrefixLength = 7;\n  return scrollTo.mid( scrollToPrefixLength );\n}\n\nQString searchStatusMessageNoMatches()\n{\n  return ArticleView::tr( \"Phrase not found\" );\n}\n\nQString searchStatusMessage( int activeMatch, int matchCount )\n{\n  Q_ASSERT( matchCount > 0 );\n  Q_ASSERT( activeMatch > 0 );\n  Q_ASSERT( activeMatch <= matchCount );\n  return ArticleView::tr( \"%1 of %2 matches\" ).arg( activeMatch ).arg( matchCount );\n}\n\n} // unnamed namespace\n\nQString ArticleView::scrollToFromDictionaryId( QString const & dictionaryId )\n{\n  Q_ASSERT( !isScrollTo( dictionaryId ) );\n  return scrollToPrefix + dictionaryId;\n}\n\nArticleView::ArticleView( QWidget * parent, ArticleNetworkAccessManager & nm,\n                          AudioPlayerPtr const & audioPlayer_,\n                          std::vector< sptr< Dictionary::Class > > const & allDictionaries_,\n                          Instances::Groups const & groups_, bool popupView_,\n                          Config::Class const & cfg_,\n                          QAction & openSearchAction_,\n                          QAction * dictionaryBarToggled_,\n                          GroupComboBox const * groupComboBox_ ):\n  QFrame( parent ),\n  articleNetMgr( nm ),\n  audioPlayer( audioPlayer_ ),\n  allDictionaries( allDictionaries_ ),\n  groups( groups_ ),\n  popupView( popupView_ ),\n  cfg( cfg_ ),\n  jsProxy( new ArticleViewJsProxy( *this ) ),\n  pasteAction( this ),\n  articleUpAction( this ),\n  articleDownAction( this ),\n  goBackAction( this ),\n  goForwardAction( this ),\n  selectCurrentArticleAction( this ),\n  copyAsTextAction( this ),\n  inspectAction( this ),\n  openSearchAction( openSearchAction_ ),\n  searchIsOpened( false ),\n  dictionaryBarToggled( dictionaryBarToggled_ ),\n  groupComboBox( groupComboBox_ ),\n  ftsSearchIsOpened( false ),\n  ftsSearchMatchCase( false ),\n  ftsPosition( 0 )\n{\n  ui.setupUi( this );\n\n  ui.definition->setUp( const_cast< Config::Class * >( &cfg ) );\n\n  goBackAction.setShortcut( QKeySequence( \"Alt+Left\" ) );\n  ui.definition->addAction( &goBackAction );\n  connect( &goBackAction, SIGNAL( triggered() ),\n           this, SLOT( back() ) );\n\n  goForwardAction.setShortcut( QKeySequence( \"Alt+Right\" ) );\n  ui.definition->addAction( &goForwardAction );\n  connect( &goForwardAction, SIGNAL( triggered() ),\n           this, SLOT( forward() ) );\n\n  ui.definition->pageAction( QWebPage::Copy )->setShortcut( QKeySequence::Copy );\n  ui.definition->addAction( ui.definition->pageAction( QWebPage::Copy ) );\n\n  QAction * selectAll = ui.definition->pageAction( QWebPage::SelectAll );\n  selectAll->setShortcut( QKeySequence::SelectAll );\n  selectAll->setShortcutContext( Qt::WidgetWithChildrenShortcut );\n  ui.definition->addAction( selectAll );\n\n  ui.definition->setContextMenuPolicy( Qt::CustomContextMenu );\n\n  ui.definition->page()->setLinkDelegationPolicy( QWebPage::DelegateAllLinks );\n\n  ui.definition->page()->setNetworkAccessManager( &articleNetMgr );\n\n  connect( ui.definition, SIGNAL( loadFinished( bool ) ),\n           this, SLOT( loadFinished( bool ) ) );\n\n  attachToJavaScript();\n  connect( ui.definition->page()->mainFrame(), SIGNAL( javaScriptWindowObjectCleared() ),\n           this, SLOT( attachToJavaScript() ) );\n\n  connect( ui.definition, SIGNAL( titleChanged( QString const & ) ),\n           this, SLOT( handleTitleChanged( QString const & ) ) );\n\n  connect( ui.definition, SIGNAL( urlChanged( QUrl const & ) ),\n           this, SLOT( handleUrlChanged( QUrl const & ) ) );\n\n  connect( ui.definition, SIGNAL( customContextMenuRequested( QPoint const & ) ),\n           this, SLOT( contextMenuRequested( QPoint const & ) ) );\n\n  connect( ui.definition, SIGNAL( linkClicked( QUrl const & ) ),\n           this, SLOT( linkClicked( QUrl const & ) ) );\n\n  connect( ui.definition->page(), SIGNAL( linkHovered ( const QString &, const QString &, const QString & ) ),\n           this, SLOT( linkHovered ( const QString &, const QString &, const QString & ) ) );\n\n  connect( ui.definition, SIGNAL( doubleClicked( QPoint ) ),this,SLOT( doubleClicked( QPoint ) ) );\n\n  pasteAction.setShortcut( QKeySequence::Paste  );\n  ui.definition->addAction( &pasteAction );\n  connect( &pasteAction, SIGNAL( triggered() ), this, SLOT( pasteTriggered() ) );\n\n  articleUpAction.setShortcut( QKeySequence( \"Alt+Up\" ) );\n  ui.definition->addAction( &articleUpAction );\n  connect( &articleUpAction, SIGNAL( triggered() ), this, SLOT( moveOneArticleUp() ) );\n\n  articleDownAction.setShortcut( QKeySequence( \"Alt+Down\" ) );\n  ui.definition->addAction( &articleDownAction );\n  connect( &articleDownAction, SIGNAL( triggered() ), this, SLOT( moveOneArticleDown() ) );\n\n  ui.definition->addAction( &openSearchAction );\n  connect( &openSearchAction, SIGNAL( triggered() ), this, SLOT( openSearch() ) );\n\n  selectCurrentArticleAction.setShortcut( QKeySequence( \"Ctrl+Shift+A\" ));\n  selectCurrentArticleAction.setText( tr( \"Select Current Article\" ) );\n  ui.definition->addAction( &selectCurrentArticleAction );\n  connect( &selectCurrentArticleAction, SIGNAL( triggered() ),\n           this, SLOT( selectCurrentArticle() ) );\n\n  copyAsTextAction.setShortcut( QKeySequence( \"Ctrl+Shift+C\" ) );\n  copyAsTextAction.setText( tr( \"Copy as text\" ) );\n  ui.definition->addAction( &copyAsTextAction );\n  connect( &copyAsTextAction, SIGNAL( triggered() ),\n           this, SLOT( copyAsText() ) );\n\n  inspectAction.setShortcut( QKeySequence( Qt::Key_F12 ) );\n  inspectAction.setText( tr( \"Inspect\" ) );\n  ui.definition->addAction( &inspectAction );\n  connect( &inspectAction, SIGNAL( triggered() ), this, SLOT( inspect() ) );\n\n  ui.definition->installEventFilter( this );\n  ui.searchFrame->installEventFilter( this );\n  ui.ftsSearchFrame->installEventFilter( this );\n\n  QWebSettings * settings = ui.definition->page()->settings();\n  settings->setAttribute( QWebSettings::LocalContentCanAccessRemoteUrls, true );\n  settings->setAttribute( QWebSettings::LocalContentCanAccessFileUrls, true );\n\n  // Load the default blank page instantly, so there would be no flicker.\n\n  QString contentType;\n  QUrl blankPage( \"gdlookup://localhost?blank=1\" );\n\n  sptr< Dictionary::DataRequest > r = articleNetMgr.getResource( blankPage,\n                                                                 contentType );\n\n  ui.definition->setHtml( QString::fromUtf8( &( r->getFullData().front() ),\n                                             r->getFullData().size() ),\n                          blankPage );\n\n  expandOptionalParts = cfg.preferences.alwaysExpandOptionalParts;\n\n#if QT_VERSION >= QT_VERSION_CHECK(4, 6, 0)\n  ui.definition->grabGesture( Gestures::GDPinchGestureType );\n  ui.definition->grabGesture( Gestures::GDSwipeGestureType );\n#endif\n\n  // Variable name for store current selection range\n  rangeVarName = QString( \"sr_%1\" ).arg( QString::number( (quint64)this, 16 ) );\n}\n\n// explicitly report the minimum size, to avoid\n// sidebar widgets' improper resize during restore\nQSize ArticleView::minimumSizeHint() const\n{\n  return ui.searchFrame->minimumSizeHint();\n}\n\nvoid ArticleView::setGroupComboBox( GroupComboBox const * g )\n{\n  groupComboBox = g;\n}\n\nArticleView::~ArticleView()\n{\n  cleanupTemp();\n  audioPlayer->stop();\n\n#if QT_VERSION >= QT_VERSION_CHECK(4, 6, 0)\n  ui.definition->ungrabGesture( Gestures::GDPinchGestureType );\n  ui.definition->ungrabGesture( Gestures::GDSwipeGestureType );\n#endif\n}\n\nvoid ArticleView::showDefinition( Config::InputPhrase const & phrase, unsigned group,\n                                  QString const & scrollTo,\n                                  Contexts const & contexts_ )\n{\n  // first, let's stop the player\n  audioPlayer->stop();\n\n  QUrl req;\n  Contexts contexts( contexts_ );\n\n  req.setScheme( \"gdlookup\" );\n  req.setHost( \"localhost\" );\n  Qt4x5::Url::addQueryItem( req, \"word\", phrase.phrase );\n  if ( !phrase.punctuationSuffix.isEmpty() )\n    Qt4x5::Url::addQueryItem( req, \"punctuation_suffix\", phrase.punctuationSuffix );\n  Qt4x5::Url::addQueryItem( req, \"group\", QString::number( group ) );\n  if( cfg.preferences.ignoreDiacritics )\n    Qt4x5::Url::addQueryItem( req, \"ignore_diacritics\", \"1\" );\n\n  if ( scrollTo.size() )\n    Qt4x5::Url::addQueryItem( req, \"scrollto\", scrollTo );\n\n  Contexts::Iterator pos = contexts.find( \"gdanchor\" );\n  if( pos != contexts.end() )\n  {\n    Qt4x5::Url::addQueryItem( req, \"gdanchor\", contexts[ \"gdanchor\" ] );\n    contexts.erase( pos );\n  }\n\n  if ( contexts.size() )\n  {\n    QBuffer buf;\n\n    buf.open( QIODevice::WriteOnly );\n\n    QDataStream stream( &buf );\n\n    stream << contexts;\n\n    buf.close();\n\n    Qt4x5::Url::addQueryItem( req,  \"contexts\", QString::fromLatin1( buf.buffer().toBase64() ) );\n  }\n\n  QString mutedDicts = getMutedForGroup( group );\n\n  if ( mutedDicts.size() )\n    Qt4x5::Url::addQueryItem( req,  \"muted\", mutedDicts );\n\n  // Update headwords history\n  emit sendWordToHistory( phrase.phrase );\n\n  // Any search opened is probably irrelevant now\n  closeSearch();\n\n  // Clear highlight all button selection\n  ui.highlightAllButton->setChecked(false);\n\n  emit setExpandMode( expandOptionalParts );\n\n  load( req );\n\n  //QApplication::setOverrideCursor( Qt::WaitCursor );\n  ui.definition->setCursor( Qt::WaitCursor );\n}\n\nvoid ArticleView::showDefinition( QString const & word, unsigned group,\n                                  QString const & scrollTo,\n                                  Contexts const & contexts_ )\n{\n  showDefinition( Config::InputPhrase::fromPhrase( word ), group, scrollTo, contexts_ );\n}\n\nvoid ArticleView::showDefinition( QString const & word, QStringList const & dictIDs,\n                                  QRegExp const & searchRegExp, unsigned group,\n                                  bool ignoreDiacritics )\n{\n  if( dictIDs.isEmpty() )\n    return;\n\n  // first, let's stop the player\n  audioPlayer->stop();\n\n  QUrl req;\n\n  req.setScheme( \"gdlookup\" );\n  req.setHost( \"localhost\" );\n  Qt4x5::Url::addQueryItem( req, \"word\", word );\n  Qt4x5::Url::addQueryItem( req, \"dictionaries\", dictIDs.join( \",\") );\n  Qt4x5::Url::addQueryItem( req, \"regexp\", searchRegExp.pattern() );\n  if( searchRegExp.caseSensitivity() == Qt::CaseSensitive )\n    Qt4x5::Url::addQueryItem( req, \"matchcase\", \"1\" );\n  if( searchRegExp.patternSyntax() == QRegExp::WildcardUnix )\n    Qt4x5::Url::addQueryItem( req, \"wildcards\", \"1\" );\n  Qt4x5::Url::addQueryItem( req, \"group\", QString::number( group ) );\n  if( ignoreDiacritics )\n    Qt4x5::Url::addQueryItem( req, \"ignore_diacritics\", \"1\" );\n\n  // Update headwords history\n  emit sendWordToHistory( word );\n\n  // Any search opened is probably irrelevant now\n  closeSearch();\n\n  // Clear highlight all button selection\n  ui.highlightAllButton->setChecked(false);\n\n  emit setExpandMode( expandOptionalParts );\n\n  load( req );\n\n  //QApplication::setOverrideCursor( Qt::WaitCursor );\n  ui.definition->setCursor( Qt::WaitCursor );\n}\n\nvoid ArticleView::showAnticipation()\n{\n  ui.definition->setHtml( \"\" );\n  ui.definition->setCursor( Qt::WaitCursor );\n  //QApplication::setOverrideCursor( Qt::WaitCursor );\n}\n\nvoid ArticleView::loadFinished( bool )\n{\n  QUrl url = ui.definition->url();\n\n  // See if we have any iframes in need of expansion\n\n  QList< QWebFrame * > frames = ui.definition->page()->mainFrame()->childFrames();\n\n  bool wereFrames = false;\n\n  for( QList< QWebFrame * >::iterator i = frames.begin(); i != frames.end(); ++i )\n  {\n    if ( (*i)->frameName().startsWith( \"gdexpandframe-\" ) )\n    {\n      //DPRINTF( \"Name: %s\\n\", (*i)->frameName().toUtf8().data() );\n      //DPRINTF( \"Size: %d\\n\", (*i)->contentsSize().height() );\n      //DPRINTF( \">>>>>>>>Height = %s\\n\", (*i)->evaluateJavaScript( \"document.body.offsetHeight;\" ).toString().toUtf8().data() );\n\n      // Set the height\n      ui.definition->page()->mainFrame()->evaluateJavaScript( QString( \"document.getElementById('%1').height = %2;\" ).\n        arg( (*i)->frameName() ).\n        arg( (*i)->contentsSize().height() ) );\n\n      // Show it\n      ui.definition->page()->mainFrame()->evaluateJavaScript( QString( \"document.getElementById('%1').style.display = 'block';\" ).\n        arg( (*i)->frameName() ) );\n\n      (*i)->evaluateJavaScript( \"var gdLastUrlText;\" );\n      (*i)->evaluateJavaScript( \"document.addEventListener( 'click', function() { gdLastUrlText = window.event.srcElement.textContent; }, true );\" );\n      (*i)->evaluateJavaScript( \"document.addEventListener( 'contextmenu', function() { gdLastUrlText = window.event.srcElement.textContent; }, true );\" );\n\n      wereFrames = true;\n    }\n  }\n\n  if ( wereFrames )\n  {\n    // There's some sort of glitch -- sometimes you need to move a mouse\n\n    QMouseEvent ev( QEvent::MouseMove, QPoint(), Qt::MouseButton(), Qt::MouseButtons(), Qt::KeyboardModifiers() );\n\n    qApp->sendEvent( ui.definition, &ev );\n  }\n\n  // Expand collapsed article if only one loaded\n  ui.definition->page()->mainFrame()->evaluateJavaScript( \"gdCheckArticlesNumber();\" );\n\n  QVariant userDataVariant = ui.definition->history()->currentItem().userData();\n  if ( userDataVariant.type() == QVariant::Map )\n  {\n    QMap< QString, QVariant > userData = userDataVariant.toMap();\n\n    double sx = 0, sy = 0;\n    bool moveToCurrentArticle = true;\n\n    if ( userData.value( \"sx\" ).type() == QVariant::Double )\n    {\n      sx = userData.value( \"sx\" ).toDouble();\n      moveToCurrentArticle = false;\n    }\n\n    if ( userData.value( \"sy\" ).type() == QVariant::Double )\n    {\n      sy = userData.value( \"sy\" ).toDouble();\n      moveToCurrentArticle = false;\n    }\n\n    const QString currentArticle = userData.value( \"currentArticle\" ).toString();\n    if( !currentArticle.isEmpty() )\n    {\n      // There's a current article saved, so set it to be current.\n      // If a scroll position was stored - even (0, 0) - don't move to the\n      // current article.\n      setCurrentArticle( currentArticle, moveToCurrentArticle );\n    }\n\n    if ( sx != 0 || sy != 0 )\n    {\n      // Restore scroll position if at least one non-zero coordinate was stored.\n      // Moving to (0, 0) is a no-op, so don't restore it.\n      ui.definition->page()->mainFrame()->evaluateJavaScript(\n          QString( \"window.scroll( %1, %2 );\" ).arg( sx ).arg( sy ) );\n    }\n  }\n  else\n  {\n    QString const scrollTo = Qt4x5::Url::queryItemValue( url, \"scrollto\" );\n    if( isScrollTo( scrollTo ) )\n    {\n      // There is no active article saved in history, but we have it as a parameter.\n      // setCurrentArticle will save it and scroll there.\n      setCurrentArticle( scrollTo, true );\n    }\n  }\n\n  ui.definition->unsetCursor();\n  //QApplication::restoreOverrideCursor();\n\n#if QT_VERSION >= QT_VERSION_CHECK(4, 6, 0)\n  if( !Qt4x5::Url::queryItemValue( url, \"gdanchor\" ).isEmpty() )\n  {\n    QString anchor = QUrl::fromPercentEncoding( Qt4x5::Url::encodedQueryItemValue( url, \"gdanchor\" ) );\n\n    // Find GD anchor on page\n\n    int n = anchor.indexOf( '_' );\n    if( n == 33 )\n      // MDict pattern: (\"g\" + dictionary ID (33 chars total))_(articleID(quint64, hex))_(original anchor)\n      n = anchor.indexOf( '_', n + 1 );\n    else\n      n = 0;\n\n    if( n > 0 )\n    {\n      QString originalAnchor = anchor.mid( n + 1 );\n\n      QRegExp rx;\n      rx.setMinimal( true );\n      rx.setPattern( anchor.left( 34 ) + \"[0-9a-f]*_\" + originalAnchor );\n\n      QWebElementCollection coll = ui.definition->page()->mainFrame()->findAllElements( \"a[name]\" );\n      coll += ui.definition->page()->mainFrame()->findAllElements( \"a[id]\" );\n\n      for( QWebElementCollection::iterator it = coll.begin(); it != coll.end(); ++it )\n      {\n        QString name = (*it).attribute( \"name\" );\n        QString id = (*it).attribute( \"id\" );\n        if( ( !name.isEmpty() && rx.indexIn( name ) >= 0 )\n            || ( !id.isEmpty() && rx.indexIn( id ) >= 0 ))\n        {\n          // Anchor found, jump to it\n\n          url.clear();\n          url.setFragment( rx.cap( 0 ) );\n          ui.definition->page()->mainFrame()->evaluateJavaScript(\n             QString( \"window.location.hash = \\\"%1\\\"\" ).arg( QString::fromUtf8( url.toEncoded() ) ) );\n\n          break;\n        }\n      }\n    }\n    else\n    {\n      url.clear();\n      url.setFragment( anchor );\n      ui.definition->page()->mainFrame()->evaluateJavaScript(\n         QString( \"window.location.hash = \\\"%1\\\"\" ).arg( QString::fromUtf8( url.toEncoded() ) ) );\n    }\n  }\n#endif\n\n  emit pageLoaded( this );\n\n  if( Qt4x5::Url::hasQueryItem( ui.definition->url(), \"regexp\" ) )\n    highlightFTSResults();\n}\n\nvoid ArticleView::handleTitleChanged( QString const & title )\n{\n  if( !title.isEmpty() ) // Qt 5.x WebKit raise signal titleChanges(QString()) while navigation within page\n    emit titleChanged( this, title );\n}\n\nvoid ArticleView::handleUrlChanged( QUrl const & url )\n{\n  QIcon icon;\n\n  unsigned group = getGroup( url );\n\n  if ( group )\n  {\n    // Find the group's instance corresponding to the fragment value\n    for( unsigned x = 0; x < groups.size(); ++x )\n      if ( groups[ x ].id == group )\n      {\n        // Found it\n\n        icon = groups[ x ].makeIcon();\n        break;\n      }\n  }\n\n  emit iconChanged( this, icon );\n}\n\nunsigned ArticleView::getGroup( QUrl const & url )\n{\n  if ( url.scheme() == \"gdlookup\" && Qt4x5::Url::hasQueryItem( url, \"group\" ) )\n    return Qt4x5::Url::queryItemValue( url, \"group\" ).toUInt();\n\n  return 0;\n}\n\nQStringList ArticleView::getArticlesList()\n{\n  return evaluateJavaScriptVariableSafe( ui.definition->page()->mainFrame(), \"gdArticleContents\" )\n      .toString().trimmed().split( ' ', Qt4x5::skipEmptyParts() );\n}\n\nQString ArticleView::getActiveArticleId()\n{\n  QString currentArticle = getCurrentArticle();\n  if ( !isScrollTo( currentArticle ) )\n    return QString(); // Incorrect id\n\n  return dictionaryIdFromScrollTo( currentArticle );\n}\n\nQString ArticleView::getCurrentArticle()\n{\n  QVariant v = evaluateJavaScriptVariableSafe( ui.definition->page()->mainFrame(), \"gdCurrentArticle\" );\n\n  if ( v.type() == QVariant::String )\n    return v.toString();\n  else\n    return QString();\n}\n\nvoid ArticleView::jumpToDictionary( QString const & id, bool force )\n{\n  QString targetArticle = scrollToFromDictionaryId( id );\n\n  // jump only if neceessary, or when forced\n  if ( force || targetArticle != getCurrentArticle() )\n  {\n    setCurrentArticle( targetArticle, true );\n  }\n}\n\nbool ArticleView::setCurrentArticle( QString const & id, bool moveToIt )\n{\n  if ( !isScrollTo( id ) )\n    return false; // Incorrect id\n\n  if ( !ui.definition->isVisible() )\n    return false; // No action on background page, scrollIntoView there don't work\n\n  QString const dictionaryId = dictionaryIdFromScrollTo( id );\n  if( !getArticlesList().contains( dictionaryId ) )\n    return false;\n\n  if ( moveToIt )\n    ui.definition->page()->mainFrame()->evaluateJavaScript( QString( \"document.getElementById('%1').scrollIntoView(true);\" ).arg( id ) );\n\n  ui.definition->page()->mainFrame()->evaluateJavaScript(\n    QString( \"gdMakeArticleActive( '%1' );\" ).arg( dictionaryId ) );\n\n  return true;\n}\n\nvoid ArticleView::selectCurrentArticle()\n{\n  ui.definition->page()->mainFrame()->evaluateJavaScript(\n        QString( \"gdSelectArticle( '%1' );\" ).arg( getActiveArticleId() ) );\n}\n\nbool ArticleView::isFramedArticle( QString const & ca )\n{\n  if ( ca.isEmpty() )\n    return false;\n\n  return ui.definition->page()->mainFrame()->\n               evaluateJavaScript( QString( \"!!document.getElementById('gdexpandframe-%1');\" )\n                                          .arg( dictionaryIdFromScrollTo( ca ) ) ).toBool();\n}\n\nbool ArticleView::isExternalLink( QUrl const & url )\n{\n  return url.scheme() == \"http\" || url.scheme() == \"https\" ||\n         url.scheme() == \"ftp\" || url.scheme() == \"mailto\" ||\n         url.scheme() == \"file\";\n}\n\nvoid ArticleView::tryMangleWebsiteClickedUrl( QUrl & url, Contexts & contexts )\n{\n  // Don't try mangling audio urls, even if they are from the framed websites\n\n  if( ( url.scheme() == \"http\" || url.scheme() == \"https\" )\n      && ! Dictionary::WebMultimediaDownload::isAudioUrl( url ) )\n  {\n    // Maybe a link inside a website was clicked?\n\n    QString ca = getCurrentArticle();\n\n    if ( isFramedArticle( ca ) )\n    {\n      QVariant result = evaluateJavaScriptVariableSafe( ui.definition->page()->currentFrame(), \"gdLastUrlText\" );\n\n      if ( result.type() == QVariant::String )\n      {\n        // Looks this way\n        contexts[ dictionaryIdFromScrollTo( ca ) ] = QString::fromLatin1( url.toEncoded() );\n\n        QUrl target;\n\n        QString queryWord = result.toString();\n\n        // Empty requests are treated as no request, so we work this around by\n        // adding a space.\n        if ( queryWord.isEmpty() )\n          queryWord = \" \";\n\n        target.setScheme( \"gdlookup\" );\n        target.setHost( \"localhost\" );\n        target.setPath( \"/\" + queryWord );\n\n        url = target;\n      }\n    }\n  }\n}\n\nvoid ArticleView::updateCurrentArticleFromCurrentFrame( QWebFrame * frame )\n{\n  if ( !frame )\n    frame = ui.definition->page()->currentFrame();\n\n  for( ; frame; frame = frame->parentFrame() )\n  {\n    QString frameName = frame->frameName();\n\n    if ( frameName.startsWith( \"gdexpandframe-\" ) )\n    {\n      QString newCurrent = scrollToFromDictionaryId( frameName.mid( 14 ) );\n\n      if ( getCurrentArticle() != newCurrent )\n        setCurrentArticle( newCurrent, false );\n\n      break;\n    }\n  }\n}\n\nvoid ArticleView::saveHistoryUserData()\n{\n  QMap< QString, QVariant > userData = ui.definition->history()->\n                                       currentItem().userData().toMap();\n\n  // Save current article, which can be empty\n\n  userData[ \"currentArticle\" ] = getCurrentArticle();\n\n  // We also save window position. We restore it when the page is fully loaded,\n  // when any hidden frames are expanded.\n\n  userData[ \"sx\" ] = ui.definition->page()->mainFrame()->evaluateJavaScript( \"window.scrollX;\" ).toDouble();\n  userData[ \"sy\" ] = ui.definition->page()->mainFrame()->evaluateJavaScript( \"window.scrollY;\" ).toDouble();\n\n  ui.definition->history()->currentItem().setUserData( userData );\n}\n\nvoid ArticleView::load( QUrl const & url )\n{\n  saveHistoryUserData();\n  ui.definition->load( url );\n}\n\nvoid ArticleView::cleanupTemp()\n{\n  QSet< QString >::iterator it = desktopOpenedTempFiles.begin();\n  while( it != desktopOpenedTempFiles.end() )\n  {\n    if( QFile::remove( *it ) )\n      it = desktopOpenedTempFiles.erase( it );\n    else\n      ++it;\n  }\n}\n\nbool ArticleView::handleF3( QObject * /*obj*/, QEvent * ev )\n{\n  if ( ev->type() == QEvent::ShortcutOverride\n       || ev->type() == QEvent::KeyPress )\n  {\n    QKeyEvent * ke = static_cast<QKeyEvent *>( ev );\n    if ( ke->key() == Qt::Key_F3 && isSearchOpened() ) {\n      if ( !ke->modifiers() )\n      {\n        if( ev->type() == QEvent::KeyPress )\n          on_searchNext_clicked();\n\n        ev->accept();\n        return true;\n      }\n\n      if ( ke->modifiers() == Qt::ShiftModifier )\n      {\n        if( ev->type() == QEvent::KeyPress )\n          on_searchPrevious_clicked();\n\n        ev->accept();\n        return true;\n      }\n    }\n    if ( ke->key() == Qt::Key_F3 && ftsSearchIsOpened )\n    {\n      if ( !ke->modifiers() )\n      {\n        if( ev->type() == QEvent::KeyPress )\n          on_ftsSearchNext_clicked();\n\n        ev->accept();\n        return true;\n      }\n\n      if ( ke->modifiers() == Qt::ShiftModifier )\n      {\n        if( ev->type() == QEvent::KeyPress )\n          on_ftsSearchPrevious_clicked();\n\n        ev->accept();\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nbool ArticleView::eventFilter( QObject * obj, QEvent * ev )\n{\n#if QT_VERSION >= QT_VERSION_CHECK(4, 6, 0)\n  if( ev->type() == QEvent::Gesture )\n  {\n    Gestures::GestureResult result;\n    QPoint pt;\n\n    bool handled = Gestures::handleGestureEvent( obj, ev, result, pt );\n\n    if( handled )\n    {\n      if( result == Gestures::ZOOM_IN )\n        zoomIn();\n      else\n      if( result == Gestures::ZOOM_OUT )\n        zoomOut();\n      else\n      if( result == Gestures::SWIPE_LEFT )\n        back();\n      else\n      if( result == Gestures::SWIPE_RIGHT )\n        forward();\n      else\n      if( result == Gestures::SWIPE_UP || result == Gestures::SWIPE_DOWN )\n      {\n        int delta = result == Gestures::SWIPE_UP ? -120 : 120;\n        QWidget *widget = static_cast< QWidget * >( obj );\n\n        QWidget *child = widget->childAt( widget->mapFromGlobal( pt ) );\n        if( child )\n          widget = child;\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 12, 0 )\n        QWheelEvent whev( widget->mapFromGlobal( pt ), pt, QPoint(), QPoint( 0, delta ),\n                          Qt::NoButton, Qt::NoModifier, Qt::NoScrollPhase, false );\n#else\n        QWheelEvent whev( widget->mapFromGlobal( pt ), pt, delta, Qt::NoButton, Qt::NoModifier );\n#endif\n        qApp->sendEvent( widget, &whev );\n      }\n    }\n\n    return handled;\n  }\n\n  if( ev->type() == QEvent::MouseMove )\n  {\n    if( Gestures::isFewTouchPointsPresented() )\n    {\n      ev->accept();\n      return true;\n    }\n  }\n#endif\n\n  if ( handleF3( obj, ev ) )\n  {\n    return true;\n  }\n\n  if ( obj == ui.definition )\n  {\n    if ( ev->type() == QEvent::MouseButtonPress ) {\n      QMouseEvent * event = static_cast< QMouseEvent * >( ev );\n      if ( event->button() == Qt::XButton1 ) {\n        back();\n        return true;\n      }\n      if ( event->button() == Qt::XButton2 ) {\n        forward();\n        return true;\n      }\n    }\n    else\n    if ( ev->type() == QEvent::KeyPress )\n    {\n      QKeyEvent * keyEvent = static_cast< QKeyEvent * >( ev );\n\n      if ( keyEvent->modifiers() &\n           ( Qt::ControlModifier | Qt::AltModifier | Qt::MetaModifier ) )\n        return false; // A non-typing modifier is pressed\n\n      if( keyEvent->key() == Qt::Key_Backspace )\n        return !canGoBack();  // Prevent QWebView navigation to first (empty) page\n\n      if ( keyEvent->key() == Qt::Key_Space ||\n           keyEvent->key() == Qt::Key_Backspace ||\n           keyEvent->key() == Qt::Key_Tab ||\n           keyEvent->key() == Qt::Key_Backtab ||\n           keyEvent->key() == Qt::Key_Return ||\n           keyEvent->key() == Qt::Key_Enter )\n        return false; // Those key have other uses than to start typing\n\n      QString text = keyEvent->text();\n\n      if ( text.size() )\n      {\n        emit typingEvent( text );\n        return true;\n      }\n    }\n  }\n  else\n    return QFrame::eventFilter( obj, ev );\n\n  return false;\n}\n\nQString ArticleView::getMutedForGroup( unsigned group )\n{\n  if ( dictionaryBarToggled && dictionaryBarToggled->isChecked() )\n  {\n    // Dictionary bar is active -- mute the muted dictionaries\n    Instances::Group const * groupInstance = groups.findGroup( group );\n\n    // Find muted dictionaries for current group\n    Config::Group const * grp = cfg.getGroup( group );\n    Config::MutedDictionaries const * mutedDictionaries;\n    if( group == Instances::Group::AllGroupId )\n      mutedDictionaries = popupView ? &cfg.popupMutedDictionaries : &cfg.mutedDictionaries;\n    else\n        mutedDictionaries = grp ? ( popupView ? &grp->popupMutedDictionaries : &grp->mutedDictionaries ) : 0;\n    if( !mutedDictionaries )\n      return QString();\n\n    QStringList mutedDicts;\n\n    if ( groupInstance )\n    {\n      for( unsigned x = 0; x < groupInstance->dictionaries.size(); ++x )\n      {\n        QString id = QString::fromStdString(\n                       groupInstance->dictionaries[ x ]->getId() );\n\n        if ( mutedDictionaries->contains( id ) )\n          mutedDicts.append( id );\n      }\n    }\n\n    if ( mutedDicts.size() )\n      return mutedDicts.join( \",\" );\n  }\n\n  return QString();\n}\n\nvoid ArticleView::linkHovered ( const QString & link, const QString & , const QString & )\n{\n  QString msg;\n  QUrl url(link);\n\n  if ( url.scheme() == \"bres\" )\n  {\n    msg = tr( \"Resource\" );\n  }\n  else\n  if ( url.scheme() == \"gdau\" || Dictionary::WebMultimediaDownload::isAudioUrl( url ) )\n  {\n    msg = tr( \"Audio\" );\n  }\n  else\n  if ( url.scheme() == \"gdtts\" )\n  {\n    msg = tr( \"TTS Voice\" );\n  }\n  else\n  if ( url.scheme() == \"gdpicture\" )\n  {\n    msg = tr( \"Picture\" );\n  }\n  else\n  if ( url.scheme() == \"gdvideo\" )\n  {\n    if ( url.path().isEmpty() )\n    {\n      msg = tr( \"Video\" );\n    }\n    else\n    {\n      QString path = url.path();\n      if ( path.startsWith( '/' ) )\n      {\n        path = path.mid( 1 );\n      }\n      msg = tr( \"Video: %1\" ).arg( path );\n    }\n  }\n  else\n  if (url.scheme() == \"gdlookup\" || url.scheme().compare( \"bword\" ) == 0)\n  {\n    QString def = url.path();\n    if (def.startsWith(\"/\"))\n    {\n      def = def.mid( 1 );\n    }\n\n    if( Qt4x5::Url::hasQueryItem( url, \"dict\" ) )\n    {\n      // Link to other dictionary\n      QString dictName( Qt4x5::Url::queryItemValue( url, \"dict\" ) );\n      if( !dictName.isEmpty() )\n        msg = tr( \"Definition from dictionary \\\"%1\\\": %2\" ).arg( dictName ).arg( def );\n    }\n\n    if( msg.isEmpty() )\n    {\n      if( def.isEmpty() && url.hasFragment() )\n        msg = '#' + url.fragment(); // this must be a citation, footnote or backlink\n      else\n        msg = tr( \"Definition: %1\").arg( def );\n    }\n  }\n  else\n  {\n    msg = link;\n  }\n\n  emit statusBarMessage( msg );\n}\n\nvoid ArticleView::attachToJavaScript()\n{\n  ui.definition->page()->mainFrame()->addToJavaScriptWindowObject( \"articleview\", jsProxy );\n}\n\nvoid ArticleView::linkClicked( QUrl const & url_ )\n{\n  Qt::KeyboardModifiers kmod = QApplication::keyboardModifiers();\n\n  // Lock jump on links while Alt key is pressed\n  if( kmod & Qt::AltModifier )\n    return;\n\n  updateCurrentArticleFromCurrentFrame();\n\n  QUrl url( url_ );\n  Contexts contexts;\n\n  tryMangleWebsiteClickedUrl( url, contexts );\n\n  if ( !popupView &&\n       ( ui.definition->isMidButtonPressed() ||\n         ( kmod & ( Qt::ControlModifier | Qt::ShiftModifier ) ) ) )\n  {\n    // Mid button or Control/Shift is currently pressed - open the link in new tab\n    emit openLinkInNewTab( url, ui.definition->url(), getCurrentArticle(), contexts );\n  }\n  else\n    openLink( url, ui.definition->url(), getCurrentArticle(), contexts );\n}\n\nvoid ArticleView::openLink( QUrl const & url, QUrl const & ref,\n                            QString const & scrollTo,\n                            Contexts const & contexts_ )\n{\n  qDebug() << \"clicked\" << url;\n\n  Contexts contexts( contexts_ );\n\n  if( url.scheme().compare( \"gdpicture\" ) == 0 )\n    load( url );\n  else\n  if ( url.scheme().compare( \"bword\" ) == 0 )\n  {\n    if( Qt4x5::Url::hasQueryItem( ref, \"dictionaries\" ) )\n    {\n      QStringList dictsList = Qt4x5::Url::queryItemValue( ref, \"dictionaries\" )\n                                          .split( \",\", Qt4x5::skipEmptyParts() );\n\n      showDefinition( url.path(), dictsList, QRegExp(), getGroup( ref ), false );\n    }\n    else\n      showDefinition( url.path(),\n                      getGroup( ref ), scrollTo, contexts );\n  }\n  else\n  if ( url.scheme() == \"gdlookup\" ) // Plain html links inherit gdlookup scheme\n  {\n    if ( url.hasFragment() )\n    {\n      ui.definition->page()->mainFrame()->evaluateJavaScript(\n        QString( \"window.location = \\\"%1\\\"\" ).arg( QString::fromUtf8( url.toEncoded() ) ) );\n    }\n    else\n    {\n      if( Qt4x5::Url::hasQueryItem( ref, \"dictionaries\" ) )\n      {\n        // Specific dictionary group from full-text search\n        QStringList dictsList = Qt4x5::Url::queryItemValue( ref, \"dictionaries\" )\n                                            .split( \",\", Qt4x5::skipEmptyParts() );\n\n        showDefinition( url.path().mid( 1 ), dictsList, QRegExp(), getGroup( ref ), false );\n        return;\n      }\n\n      QString newScrollTo( scrollTo );\n      if( Qt4x5::Url::hasQueryItem( url, \"dict\" ) )\n      {\n        // Link to other dictionary\n        QString dictName( Qt4x5::Url::queryItemValue( url, \"dict\" ) );\n        for( unsigned i = 0; i < allDictionaries.size(); i++ )\n        {\n          if( dictName.compare( QString::fromUtf8( allDictionaries[ i ]->getName().c_str() ) ) == 0 )\n          {\n            newScrollTo = scrollToFromDictionaryId( QString::fromUtf8( allDictionaries[ i ]->getId().c_str() ) );\n            break;\n          }\n        }\n      }\n\n      if( Qt4x5::Url::hasQueryItem( url, \"gdanchor\" ) )\n        contexts[ \"gdanchor\" ] = Qt4x5::Url::queryItemValue( url, \"gdanchor\" );\n\n      showDefinition( url.path().mid( 1 ),\n                      getGroup( ref ), newScrollTo, contexts );\n    }\n  }\n  else\n  if ( url.scheme() == \"bres\" || url.scheme() == \"gdau\" || url.scheme() == \"gdvideo\" ||\n       Dictionary::WebMultimediaDownload::isAudioUrl( url ) )\n  {\n    // Download it\n\n    // Clear any pending ones\n\n    resourceDownloadRequests.clear();\n\n    resourceDownloadUrl = url;\n\n    if ( Dictionary::WebMultimediaDownload::isAudioUrl( url ) )\n    {\n      sptr< Dictionary::DataRequest > req =\n        new Dictionary::WebMultimediaDownload( url, articleNetMgr );\n\n      resourceDownloadRequests.push_back( req );\n\n      connect( req.get(), SIGNAL( finished() ),\n               this, SLOT( resourceDownloadFinished() ) );\n    }\n    else\n    if ( url.scheme() == \"gdau\" && url.host() == \"search\" )\n    {\n      // Since searches should be limited to current group, we just do them\n      // here ourselves since otherwise we'd need to pass group id to netmgr\n      // and it should've been having knowledge of the current groups, too.\n\n      unsigned currentGroup = getGroup( ref );\n\n      std::vector< sptr< Dictionary::Class > > const * activeDicts = 0;\n\n      if ( groups.size() )\n      {\n        for( unsigned x = 0; x < groups.size(); ++x )\n          if ( groups[ x ].id == currentGroup )\n          {\n            activeDicts = &( groups[ x ].dictionaries );\n            break;\n          }\n      }\n      else\n        activeDicts = &allDictionaries;\n\n      if ( activeDicts )\n      {\n        unsigned preferred = UINT_MAX;\n        if( url.hasFragment() )\n        {\n          // Find sound in the preferred dictionary\n          QString preferredName = Qt4x5::Url::fragment( url );\n          try\n          {\n            for( unsigned x = 0; x < activeDicts->size(); ++x )\n            {\n              if( preferredName.compare( QString::fromUtf8( (*activeDicts)[ x ]->getName().c_str() ) ) == 0 )\n              {\n                preferred = x;\n                sptr< Dictionary::DataRequest > req =\n                  (*activeDicts)[ x ]->getResource(\n                    url.path().mid( 1 ).toUtf8().data() );\n\n                resourceDownloadRequests.push_back( req );\n\n                if ( !req->isFinished() )\n                {\n                  // Queued loading\n                  connect( req.get(), SIGNAL( finished() ),\n                           this, SLOT( resourceDownloadFinished() ) );\n                }\n                else\n                {\n                  // Immediate loading\n                  if( req->dataSize() > 0 )\n                  {\n                    // Resource already found, stop next search\n                    resourceDownloadFinished();\n                    return;\n                  }\n                }\n                break;\n              }\n            }\n          }\n          catch( std::exception & e )\n          {\n            emit statusBarMessage(\n                  tr( \"ERROR: %1\" ).arg( e.what() ),\n                  10000, QPixmap( \":/icons/error.png\" ) );\n          }\n        }\n        for( unsigned x = 0; x < activeDicts->size(); ++x )\n        {\n          try\n          {\n            if( x == preferred )\n              continue;\n\n            sptr< Dictionary::DataRequest > req =\n              (*activeDicts)[ x ]->getResource(\n                url.path().mid( 1 ).toUtf8().data() );\n\n            resourceDownloadRequests.push_back( req );\n\n            if ( !req->isFinished() )\n            {\n              // Queued loading\n              connect( req.get(), SIGNAL( finished() ),\n                       this, SLOT( resourceDownloadFinished() ) );\n            }\n            else\n            {\n              // Immediate loading\n              if( req->dataSize() > 0 )\n              {\n                // Resource already found, stop next search\n                break;\n              }\n            }\n          }\n          catch( std::exception & e )\n          {\n            emit statusBarMessage(\n                  tr( \"ERROR: %1\" ).arg( e.what() ),\n                  10000, QPixmap( \":/icons/error.png\" ) );\n          }\n        }\n      }\n    }\n    else\n    {\n      // Normal resource download\n      QString contentType;\n\n      sptr< Dictionary::DataRequest > req =\n        articleNetMgr.getResource( url, contentType );\n\n      if ( !req.get() )\n      {\n        // Request failed, fail\n      }\n      else\n      if ( req->isFinished() && req->dataSize() >= 0 )\n      {\n        // Have data ready, handle it\n        resourceDownloadRequests.push_back( req );\n        resourceDownloadFinished();\n\n        return;\n      }\n      else\n      if ( !req->isFinished() )\n      {\n        // Queue to be handled when done\n\n        resourceDownloadRequests.push_back( req );\n\n        connect( req.get(), SIGNAL( finished() ),\n                 this, SLOT( resourceDownloadFinished() ) );\n      }\n    }\n\n    if ( resourceDownloadRequests.empty() ) // No requests were queued\n    {\n      QMessageBox::critical( this, \"GoldenDict\", tr( \"The referenced resource doesn't exist.\" ) );\n      return;\n    }\n    else\n      resourceDownloadFinished(); // Check any requests finished already\n  }\n  else\n  if ( url.scheme() == \"gdprg\" )\n  {\n    // Program. Run it.\n    QString id( url.host() );\n\n    for( Config::Programs::const_iterator i = cfg.programs.begin();\n         i != cfg.programs.end(); ++i )\n    {\n      if ( i->id == id )\n      {\n        // Found the corresponding program.\n        Programs::RunInstance * req = new Programs::RunInstance;\n\n        connect( req, SIGNAL(finished(QByteArray,QString)),\n                 req, SLOT( deleteLater() ) );\n\n        QString error;\n\n        // Delete the request if it fails to start\n        if ( !req->start( *i, url.path().mid( 1 ), error ) )\n        {\n          delete req;\n\n          QMessageBox::critical( this, \"GoldenDict\",\n                                 error );\n        }\n\n        return;\n      }\n    }\n\n    // Still here? No such program exists.\n    QMessageBox::critical( this, \"GoldenDict\",\n                           tr( \"The referenced audio program doesn't exist.\" ) );\n  }\n  else\n  if ( url.scheme() == \"gdtts\" )\n  {\n// TODO: Port TTS\n#if defined( Q_OS_WIN32 ) || defined( Q_OS_MAC )\n    // Text to speech\n    QString md5Id = Qt4x5::Url::queryItemValue( url, \"engine\" );\n    QString text( url.path().mid( 1 ) );\n\n    for ( Config::VoiceEngines::const_iterator i = cfg.voiceEngines.begin();\n          i != cfg.voiceEngines.end(); ++i )\n    {\n      QString itemMd5Id = QString( QCryptographicHash::hash(\n                                     i->id.toUtf8(),\n                                     QCryptographicHash::Md5 ).toHex() );\n\n      if ( itemMd5Id == md5Id )\n      {\n        SpeechClient * speechClient = new SpeechClient( *i, this );\n        connect( speechClient, SIGNAL( finished() ), speechClient, SLOT( deleteLater() ) );\n        speechClient->tell( text );\n        break;\n      }\n    }\n#endif\n  }\n  else\n  if ( isExternalLink( url ) )\n  {\n    // Use the system handler for the conventional external links\n    QDesktopServices::openUrl( url );\n  }\n}\n\nResourceToSaveHandler * ArticleView::saveResource( const QUrl & url, const QString & fileName )\n{\n  return saveResource( url, ui.definition->url(), fileName );\n}\n\nResourceToSaveHandler * ArticleView::saveResource( const QUrl & url, const QUrl & ref, const QString & fileName )\n{\n  ResourceToSaveHandler * handler = new ResourceToSaveHandler( this, fileName );\n  sptr< Dictionary::DataRequest > req;\n\n  if( url.scheme() == \"bres\" || url.scheme() == \"gico\" || url.scheme() == \"gdau\" || url.scheme() == \"gdvideo\" )\n  {\n    if ( url.host() == \"search\" )\n    {\n      // Since searches should be limited to current group, we just do them\n      // here ourselves since otherwise we'd need to pass group id to netmgr\n      // and it should've been having knowledge of the current groups, too.\n\n      unsigned currentGroup = getGroup( ref );\n\n      std::vector< sptr< Dictionary::Class > > const * activeDicts = 0;\n\n      if ( groups.size() )\n      {\n        for( unsigned x = 0; x < groups.size(); ++x )\n          if ( groups[ x ].id == currentGroup )\n          {\n            activeDicts = &( groups[ x ].dictionaries );\n            break;\n          }\n      }\n      else\n        activeDicts = &allDictionaries;\n\n      if ( activeDicts )\n      {\n        unsigned preferred = UINT_MAX;\n        if( url.hasFragment() && url.scheme() == \"gdau\" )\n        {\n          // Find sound in the preferred dictionary\n          QString preferredName = Qt4x5::Url::fragment( url );\n          for( unsigned x = 0; x < activeDicts->size(); ++x )\n          {\n            try\n            {\n              if( preferredName.compare( QString::fromUtf8( (*activeDicts)[ x ]->getName().c_str() ) ) == 0 )\n              {\n                preferred = x;\n                sptr< Dictionary::DataRequest > req =\n                  (*activeDicts)[ x ]->getResource(\n                    url.path().mid( 1 ).toUtf8().data() );\n\n                handler->addRequest( req );\n\n                if( req->isFinished() && req->dataSize() > 0 )\n                {\n                  handler->downloadFinished();\n                  return handler;\n                }\n                break;\n              }\n            }\n            catch( std::exception & e )\n            {\n              gdWarning( \"getResource request error (%s) in \\\"%s\\\"\\n\", e.what(),\n                         (*activeDicts)[ x ]->getName().c_str() );\n            }\n          }\n        }\n        for( unsigned x = 0; x < activeDicts->size(); ++x )\n        {\n          try\n          {\n            if( x == preferred )\n              continue;\n\n            req = (*activeDicts)[ x ]->getResource(\n                    Qt4x5::Url::path( url ).mid( 1 ).toUtf8().data() );\n\n            handler->addRequest( req );\n\n            if( req->isFinished() && req->dataSize() > 0 )\n            {\n              // Resource already found, stop next search\n              break;\n            }\n          }\n          catch( std::exception & e )\n          {\n            gdWarning( \"getResource request error (%s) in \\\"%s\\\"\\n\", e.what(),\n                       (*activeDicts)[ x ]->getName().c_str() );\n          }\n        }\n      }\n    }\n    else\n    {\n      // Normal resource download\n      QString contentType;\n      req = articleNetMgr.getResource( url, contentType );\n\n      if( req.get() )\n      {\n        handler->addRequest( req );\n      }\n    }\n  }\n  else\n  {\n    req = new Dictionary::WebMultimediaDownload( url, articleNetMgr );\n\n    handler->addRequest( req );\n  }\n\n  if ( handler->isEmpty() ) // No requests were queued\n  {\n    emit statusBarMessage(\n          tr( \"ERROR: %1\" ).arg( tr( \"The referenced resource doesn't exist.\" ) ),\n          10000, QPixmap( \":/icons/error.png\" ) );\n  }\n\n  // Check already finished downloads\n  handler->downloadFinished();\n\n  return handler;\n}\n\nvoid ArticleView::updateMutedContents()\n{\n  QUrl currentUrl = ui.definition->url();\n\n  if ( currentUrl.scheme() != \"gdlookup\" )\n    return; // Weird url -- do nothing\n\n  unsigned group = getGroup( currentUrl );\n\n  if ( !group )\n    return; // No group in url -- do nothing\n\n  QString mutedDicts = getMutedForGroup( group );\n\n  if ( Qt4x5::Url::queryItemValue( currentUrl, \"muted\" ) != mutedDicts )\n  {\n    // The list has changed -- update the url\n\n    Qt4x5::Url::removeQueryItem( currentUrl, \"muted\" );\n\n    if ( mutedDicts.size() )\n    Qt4x5::Url::addQueryItem( currentUrl, \"muted\", mutedDicts );\n\n    load( currentUrl );\n\n    //QApplication::setOverrideCursor( Qt::WaitCursor );\n    ui.definition->setCursor( Qt::WaitCursor );\n  }\n}\n\nbool ArticleView::canGoBack()\n{\n  // First entry in a history is always an empty page,\n  // so we skip it.\n  return ui.definition->history()->currentItemIndex() > 1;\n}\n\nbool ArticleView::canGoForward()\n{\n  return ui.definition->history()->canGoForward();\n}\n\nvoid ArticleView::setSelectionBySingleClick( bool set )\n{\n  ui.definition->setSelectionBySingleClick( set );\n}\n\nvoid ArticleView::back()\n{\n  // Don't allow navigating back to page 0, which is usually the initial\n  // empty page\n  if ( canGoBack() )\n  {\n    saveHistoryUserData();\n    ui.definition->back();\n  }\n}\n\nvoid ArticleView::forward()\n{\n  saveHistoryUserData();\n  ui.definition->forward();\n}\n\nvoid ArticleView::reload()\n{\n  QMap< QString, QVariant > userData = ui.definition->history()->currentItem().userData().toMap();\n\n  // Save current article, which can be empty\n  userData[ \"currentArticle\" ] = getCurrentArticle();\n\n  // Remove saved window position. Reloading occurs in response to changes that\n  // may affect content height, so restoring the current window position can cause\n  // uncontrolled jumps. Scrolling to the current article (i.e. jumping to the top\n  // of it) is simple, reliable and predictable, if not ideal.\n  userData[ \"sx\" ].clear();\n  userData[ \"sy\" ].clear();\n\n  ui.definition->history()->currentItem().setUserData( userData );\n\n  ui.definition->reload();\n}\n\nbool ArticleView::hasSound()\n{\n  QVariant v = ui.definition->page()->mainFrame()->evaluateJavaScript( \"gdAudioLinks.first\" );\n  if ( v.type() == QVariant::String )\n    return !v.toString().isEmpty();\n  return false;\n}\n\nvoid ArticleView::playSound()\n{\n  QVariant v;\n  QString soundScript;\n\n  v = ui.definition->page()->mainFrame()->evaluateJavaScript( \"gdAudioLinks[gdAudioLinks.current]\" );\n\n  if ( v.type() == QVariant::String )\n    soundScript = v.toString();\n\n  // fallback to the first one\n  if ( soundScript.isEmpty() )\n  {\n    v = ui.definition->page()->mainFrame()->evaluateJavaScript( \"gdAudioLinks.first\" );\n    if ( v.type() == QVariant::String )\n      soundScript = v.toString();\n  }\n\n  if ( !soundScript.isEmpty() )\n    openLink( QUrl::fromEncoded( soundScript.toUtf8() ), ui.definition->url() );\n}\n\nQString ArticleView::toHtml()\n{\n  return ui.definition->page()->mainFrame()->toHtml();\n}\n\nQString ArticleView::getTitle()\n{\n  return ui.definition->page()->mainFrame()->title();\n}\n\nConfig::InputPhrase ArticleView::getPhrase() const\n{\n  const QUrl url = ui.definition->url();\n  return Config::InputPhrase( Qt4x5::Url::queryItemValue( url, \"word\" ),\n                              Qt4x5::Url::queryItemValue( url, \"punctuation_suffix\" ) );\n}\n\nvoid ArticleView::print( QPrinter * printer ) const\n{\n  ui.definition->print( printer );\n}\n\nvoid ArticleView::contextMenuRequested( QPoint const & pos )\n{\n  // Is that a link? Is there a selection?\n\n  QWebHitTestResult r = ui.definition->page()->mainFrame()->\n                          hitTestContent( pos );\n\n  updateCurrentArticleFromCurrentFrame( r.frame() );\n\n  QMenu menu( this );\n\n  QAction * followLink = 0;\n  QAction * followLinkExternal = 0;\n  QAction * followLinkNewTab = 0;\n  QAction * lookupSelection = 0;\n  QAction * lookupSelectionGr = 0;\n  QAction * lookupSelectionNewTab = 0;\n  QAction * lookupSelectionNewTabGr = 0;\n  QAction * maxDictionaryRefsAction = 0;\n  QAction * addWordToHistoryAction = 0;\n  QAction * addHeaderToHistoryAction = 0;\n  QAction * sendWordToInputLineAction = 0;\n  QAction * saveImageAction = 0;\n  QAction * saveSoundAction = 0;\n\n  QUrl targetUrl( r.linkUrl() );\n  Contexts contexts;\n\n  tryMangleWebsiteClickedUrl( targetUrl, contexts );\n\n  if ( !r.linkUrl().isEmpty() )\n  {\n    if ( !isExternalLink( targetUrl ) )\n    {\n      followLink = new QAction( tr( \"&Open Link\" ), &menu );\n      menu.addAction( followLink );\n\n      if ( !popupView )\n      {\n        followLinkNewTab = new QAction( QIcon( \":/icons/addtab.png\" ),\n                                        tr( \"Open Link in New &Tab\" ), &menu );\n        menu.addAction( followLinkNewTab );\n      }\n    }\n\n    if ( isExternalLink( r.linkUrl() ) )\n    {\n      followLinkExternal = new QAction( tr( \"Open Link in &External Browser\" ), &menu );\n      menu.addAction( followLinkExternal );\n      menu.addAction( ui.definition->pageAction( QWebPage::CopyLinkToClipboard ) );\n    }\n  }\n\n#if QT_VERSION >= 0x040600\n  QWebElement el = r.element();\n  QUrl imageUrl;\n  if( !popupView && el.tagName().compare( \"img\", Qt::CaseInsensitive ) == 0 )\n  {\n    imageUrl = QUrl::fromPercentEncoding( el.attribute( \"src\" ).toLatin1() );\n    if( !imageUrl.isEmpty() )\n    {\n      menu.addAction( ui.definition->pageAction( QWebPage::CopyImageToClipboard ) );\n      saveImageAction = new QAction( tr( \"Save &image...\" ), &menu );\n      menu.addAction( saveImageAction );\n    }\n  }\n\n  if( !popupView && ( targetUrl.scheme() == \"gdau\"\n                      || Dictionary::WebMultimediaDownload::isAudioUrl( targetUrl ) ) )\n  {\n    saveSoundAction = new QAction( tr( \"Save s&ound...\" ), &menu );\n    menu.addAction( saveSoundAction );\n  }\n#endif\n\n  QString selectedText = ui.definition->selectedText();\n  QString text = selectedText.trimmed();\n\n  if ( text.size() && text.size() < 60 )\n  {\n    // We don't prompt for selections larger or equal to 60 chars, since\n    // it ruins the menu and it's hardly a single word anyway.\n\n    if( text.isRightToLeft() )\n    {\n      text.insert( 0, (ushort)0x202E ); // RLE, Right-to-Left Embedding\n      text.append( (ushort)0x202C ); // PDF, POP DIRECTIONAL FORMATTING\n    }\n\n    lookupSelection = new QAction( tr( \"&Look up \\\"%1\\\"\" ).\n                                   arg( text ),\n                                   &menu );\n    menu.addAction( lookupSelection );\n\n    if ( !popupView )\n    {\n      lookupSelectionNewTab = new QAction( QIcon( \":/icons/addtab.png\" ),\n                                           tr( \"Look up \\\"%1\\\" in &New Tab\" ).\n                                           arg( text ),\n                                           &menu );\n      menu.addAction( lookupSelectionNewTab );\n\n      sendWordToInputLineAction = new QAction( tr( \"Send \\\"%1\\\" to input line\" ).\n                                               arg( text ),\n                                               &menu );\n      menu.addAction( sendWordToInputLineAction );\n    }\n\n    addWordToHistoryAction = new QAction( tr( \"&Add \\\"%1\\\" to history\" ).\n                                          arg( text ),\n                                          &menu );\n    menu.addAction( addWordToHistoryAction );\n\n    Instances::Group const * altGroup =\n      ( groupComboBox && groupComboBox->getCurrentGroup() !=  getGroup( ui.definition->url() )  ) ?\n        groups.findGroup( groupComboBox->getCurrentGroup() ) : 0;\n\n    if ( altGroup )\n    {\n      QIcon icon = altGroup->icon.size() ? QIcon( \":/flags/\" + altGroup->icon ) :\n                   QIcon();\n\n      lookupSelectionGr = new QAction( icon, tr( \"Look up \\\"%1\\\" in %2\" ).\n                                       arg( text ).\n                                       arg( altGroup->name ), &menu );\n      menu.addAction( lookupSelectionGr );\n\n      if ( !popupView )\n      {\n        lookupSelectionNewTabGr = new QAction( QIcon( \":/icons/addtab.png\" ),\n                                               tr( \"Look up \\\"%1\\\" in %2 in &New Tab\" ).\n                                               arg( text ).\n                                               arg( altGroup->name ), &menu );\n        menu.addAction( lookupSelectionNewTabGr );\n      }\n    }\n  }\n\n  if( text.isEmpty() && !cfg.preferences.storeHistory)\n  {\n    QString txt = ui.definition->title();\n    if( txt.size() > 60 )\n      txt = txt.left( 60 ) + \"...\";\n\n    addHeaderToHistoryAction = new QAction( tr( \"&Add \\\"%1\\\" to history\" ).\n                                            arg( txt ),\n                                            &menu );\n    menu.addAction( addHeaderToHistoryAction );\n  }\n\n  if ( selectedText.size() )\n  {\n    menu.addAction( ui.definition->pageAction( QWebPage::Copy ) );\n    menu.addAction( &copyAsTextAction );\n  }\n  else\n  {\n    menu.addAction( &selectCurrentArticleAction );\n    menu.addAction( ui.definition->pageAction( QWebPage::SelectAll ) );\n  }\n\n  map< QAction *, QString > tableOfContents;\n\n  // Add table of contents\n  QStringList ids = getArticlesList();\n\n  if ( !menu.isEmpty() && ids.size() )\n    menu.addSeparator();\n\n  unsigned refsAdded = 0;\n  bool maxDictionaryRefsReached = false;\n\n  for( QStringList::const_iterator i = ids.constBegin(); i != ids.constEnd();\n       ++i, ++refsAdded )\n  {\n    // Find this dictionary\n\n    for( unsigned x = allDictionaries.size(); x--; )\n    {\n      if ( allDictionaries[ x ]->getId() == i->toUtf8().data() )\n      {\n        QAction * action = 0;\n        if ( refsAdded == cfg.preferences.maxDictionaryRefsInContextMenu )\n        {\n          // Enough! Or the menu would become too large.\n          maxDictionaryRefsAction = new QAction( \".........\", &menu );\n          action = maxDictionaryRefsAction;\n          maxDictionaryRefsReached = true;\n        }\n        else\n        {\n          action = new QAction(\n                  allDictionaries[ x ]->getIcon(),\n                  QString::fromUtf8( allDictionaries[ x ]->getName().c_str() ),\n                  &menu );\n          // Force icons in menu on all platforms,\n          // since without them it will be much harder\n          // to find things.\n          action->setIconVisibleInMenu( true );\n        }\n        menu.addAction( action );\n\n        tableOfContents[ action ] = *i;\n\n        break;\n      }\n    }\n    if( maxDictionaryRefsReached )\n      break;\n  }\n\n  menu.addSeparator();\n  menu.addAction( &inspectAction );\n\n  if ( !menu.isEmpty() )\n  {\n    connect( this, SIGNAL( closePopupMenu() ), &menu, SLOT( close() ) );\n    QAction * result = menu.exec( ui.definition->mapToGlobal( pos ) );\n\n    if ( !result )\n      return;\n\n    if ( result == followLink )\n      openLink( targetUrl, ui.definition->url(), getCurrentArticle(), contexts );\n    else\n    if ( result == followLinkExternal )\n      QDesktopServices::openUrl( r.linkUrl() );\n    else\n    if ( result == lookupSelection )\n      showDefinition( selectedText, getGroup( ui.definition->url() ), getCurrentArticle() );\n    else\n    if ( result == lookupSelectionGr && groupComboBox )\n      showDefinition( selectedText, groupComboBox->getCurrentGroup(), QString() );\n    else\n    if ( result == addWordToHistoryAction )\n      emit forceAddWordToHistory( selectedText );\n    if ( result == addHeaderToHistoryAction )\n      emit forceAddWordToHistory( ui.definition->title() );\n    else\n    if( result == sendWordToInputLineAction )\n      emit sendWordToInputLine( selectedText );\n    else\n    if ( !popupView && result == followLinkNewTab )\n      emit openLinkInNewTab( targetUrl, ui.definition->url(), getCurrentArticle(), contexts );\n    else\n    if ( !popupView && result == lookupSelectionNewTab )\n      emit showDefinitionInNewTab( selectedText, getGroup( ui.definition->url() ),\n                                   getCurrentArticle(), Contexts() );\n    else\n    if ( !popupView && result == lookupSelectionNewTabGr && groupComboBox )\n      emit showDefinitionInNewTab( selectedText, groupComboBox->getCurrentGroup(),\n                                   QString(), Contexts() );\n    else\n    if( result == saveImageAction || result == saveSoundAction )\n    {\n#if QT_VERSION >= 0x040600\n      QUrl url = ( result == saveImageAction ) ? imageUrl : targetUrl;\n      QString savePath;\n      QString fileName;\n\n      if ( cfg.resourceSavePath.isEmpty() )\n        savePath = QDir::homePath();\n      else\n      {\n        savePath = QDir::fromNativeSeparators( cfg.resourceSavePath );\n        if ( !QDir( savePath ).exists() )\n          savePath = QDir::homePath();\n      }\n\n      QString name = Qt4x5::Url::path( url ).section( '/', -1 );\n\n      if ( result == saveSoundAction )\n      {\n        // Audio data\n        if ( name.indexOf( '.' ) < 0 )\n          name += \".wav\";\n\n        fileName = savePath + \"/\" + name;\n        fileName = QFileDialog::getSaveFileName( parentWidget(), tr( \"Save sound\" ),\n                                                 fileName,\n                                                 tr( \"Sound files (*.wav *.ogg *.oga *.mp3 *.mp4 *.aac *.flac *.mid *.wv *.ape);;All files (*.*)\" ) );\n      }\n      else\n      {\n        // Image data\n\n        // Check for babylon image name\n        if ( name[ 0 ] == '\\x1E' )\n          name.remove( 0, 1 );\n        if ( name.length() && name[ name.length() - 1 ] == '\\x1F' )\n          name.chop( 1 );\n\n        fileName = savePath + \"/\" + name;\n        fileName = QFileDialog::getSaveFileName( parentWidget(), tr( \"Save image\" ),\n                                                 fileName,\n                                                 tr( \"Image files (*.bmp *.jpg *.png *.tif);;All files (*.*)\" ) );\n      }\n\n      if ( !fileName.isEmpty() )\n      {\n        QFileInfo fileInfo( fileName );\n        emit storeResourceSavePath( QDir::toNativeSeparators( fileInfo.absoluteDir().absolutePath() ) );\n        saveResource( url, ui.definition->url(), fileName );\n      }\n#endif\n    }\n    else\n    {\n      if ( !popupView && result == maxDictionaryRefsAction )\n        emit showDictsPane();\n\n      // Match against table of contents\n      QString id = tableOfContents[ result ];\n\n      if ( id.size() )\n        setCurrentArticle( scrollToFromDictionaryId( id ), true );\n    }\n  }\n#if 0\n  DPRINTF( \"%s\\n\", r.linkUrl().isEmpty() ? \"null\" : \"not null\" );\n\n  DPRINTF( \"url = %s\\n\", r.linkUrl().toString().toLocal8Bit().data() );\n  DPRINTF( \"title = %s\\n\", r.title().toLocal8Bit().data() );\n#endif\n}\n\nvoid ArticleView::resourceDownloadFinished()\n{\n  if ( resourceDownloadRequests.empty() )\n    return; // Stray signal\n\n  // Find any finished resources\n  for( list< sptr< Dictionary::DataRequest > >::iterator i =\n       resourceDownloadRequests.begin(); i != resourceDownloadRequests.end(); )\n  {\n    if ( (*i)->isFinished() )\n    {\n      if ( (*i)->dataSize() >= 0 )\n      {\n        // Ok, got one finished, all others are irrelevant now\n\n        vector< char > const & data = (*i)->getFullData();\n\n        if ( resourceDownloadUrl.scheme() == \"gdau\" ||\n             Dictionary::WebMultimediaDownload::isAudioUrl( resourceDownloadUrl ) )\n        {\n          // Audio data\n          connect( audioPlayer.data(), SIGNAL( error( QString ) ), this, SLOT( audioPlayerError( QString ) ), Qt::UniqueConnection );\n          QString errorMessage = audioPlayer->play( data.data(), data.size() );\n          if( !errorMessage.isEmpty() )\n            QMessageBox::critical( this, \"GoldenDict\", tr( \"Failed to play sound file: %1\" ).arg( errorMessage ) );\n        }\n        else\n        {\n          // Create a temporary file\n          // Remove the ones previously used, if any\n          cleanupTemp();\n          QString fileName;\n\n          {\n            QTemporaryFile tmp(\n              QDir::temp().filePath( \"XXXXXX-\" + resourceDownloadUrl.path().section( '/', -1 ) ), this );\n\n            if ( !tmp.open() || (size_t) tmp.write( &data.front(), data.size() ) != data.size() )\n            {\n              QMessageBox::critical( this, \"GoldenDict\", tr( \"Failed to create temporary file.\" ) );\n              return;\n            }\n\n            tmp.setAutoRemove( false );\n\n            desktopOpenedTempFiles.insert( fileName = tmp.fileName() );\n          }\n\n          if ( !QDesktopServices::openUrl( QUrl::fromLocalFile( fileName ) ) )\n            QMessageBox::critical( this, \"GoldenDict\",\n                                   tr( \"Failed to auto-open resource file, try opening manually: %1.\" ).arg( fileName ) );\n        }\n\n        // Ok, whatever it was, it's finished. Remove this and any other\n        // requests and finish.\n\n        resourceDownloadRequests.clear();\n\n        return;\n      }\n      else\n      {\n        // This one had no data. Erase it.\n        resourceDownloadRequests.erase( i++ );\n      }\n    }\n    else // Unfinished, wait.\n      break;\n  }\n\n  if ( resourceDownloadRequests.empty() )\n  {\n    emit statusBarMessage(\n          tr( \"WARNING: %1\" ).arg( tr( \"The referenced resource failed to download.\" ) ),\n          10000, QPixmap( \":/icons/error.png\" ) );\n  }\n}\n\nvoid ArticleView::audioPlayerError( QString const & message )\n{\n  emit statusBarMessage( tr( \"WARNING: Audio Player: %1\" ).arg( message ),\n                         10000, QPixmap( \":/icons/error.png\" ) );\n}\n\nvoid ArticleView::pasteTriggered()\n{\n  Config::InputPhrase phrase = cfg.preferences.sanitizeInputPhrase( QApplication::clipboard()->text() );\n\n  if ( phrase.isValid() )\n  {\n    unsigned groupId = getGroup( ui.definition->url() );\n    if ( groupId == 0 )\n    {\n      // We couldn't figure out the group out of the URL,\n      // so let's try the currently selected group.\n      groupId = groupComboBox->getCurrentGroup();\n    }\n    showDefinition( phrase, groupId, getCurrentArticle() );\n  }\n}\n\nvoid ArticleView::moveOneArticleUp()\n{\n  QString current = getCurrentArticle();\n\n  if ( current.size() )\n  {\n    QStringList lst = getArticlesList();\n\n    int idx = lst.indexOf( dictionaryIdFromScrollTo( current ) );\n\n    if ( idx != -1 )\n    {\n      --idx;\n\n      if ( idx < 0 )\n        idx = lst.size() - 1;\n\n      setCurrentArticle( scrollToFromDictionaryId( lst[ idx ] ), true );\n    }\n  }\n}\n\nvoid ArticleView::moveOneArticleDown()\n{\n  QString current = getCurrentArticle();\n\n  if ( current.size() )\n  {\n    QStringList lst = getArticlesList();\n\n    int idx = lst.indexOf( dictionaryIdFromScrollTo( current ) );\n\n    if ( idx != -1 )\n    {\n      idx = ( idx + 1 ) % lst.size();\n\n      setCurrentArticle( scrollToFromDictionaryId( lst[ idx ] ), true );\n    }\n  }\n}\n\nvoid ArticleView::openSearch()\n{\n  if( !isVisible() )\n    return;\n\n  if( ftsSearchIsOpened )\n    closeSearch();\n\n  if ( !searchIsOpened )\n  {\n    ui.searchFrame->show();\n    ui.searchText->setText( getTitle() );\n    searchIsOpened = true;\n  }\n\n  ui.searchText->setFocus();\n  ui.searchText->selectAll();\n\n  // Clear any current selection\n  if ( ui.definition->selectedText().size() )\n  {\n    ui.definition->page()->currentFrame()->\n           evaluateJavaScript( \"window.getSelection().removeAllRanges();_=0;\" );\n  }\n\n  if ( ui.searchText->property( \"noResults\" ).toBool() )\n  {\n    ui.searchText->setProperty( \"noResults\", false );\n\n    // Reload stylesheet\n    reloadStyleSheet();\n  }\n}\n\nvoid ArticleView::on_searchPrevious_clicked()\n{\n  if ( searchIsOpened )\n    performFindOperation( false, true );\n}\n\nvoid ArticleView::on_searchNext_clicked()\n{\n  if ( searchIsOpened )\n    performFindOperation( false, false );\n}\n\nvoid ArticleView::on_searchText_textEdited()\n{\n  performFindOperation( true, false );\n}\n\nvoid ArticleView::on_searchText_returnPressed()\n{\n  on_searchNext_clicked();\n}\n\nvoid ArticleView::on_searchCloseButton_clicked()\n{\n  closeSearch();\n}\n\nvoid ArticleView::on_searchCaseSensitive_clicked()\n{\n  performFindOperation( true, false );\n}\n\nvoid ArticleView::on_highlightAllButton_clicked()\n{\n  performFindOperation( false, false, true );\n}\n\nvoid ArticleView::onJsActiveArticleChanged(QString const & id)\n{\n  if ( !isScrollTo( id ) )\n    return; // Incorrect id\n\n  emit activeArticleChanged( this, dictionaryIdFromScrollTo( id ) );\n}\n\nvoid ArticleView::doubleClicked( QPoint pos )\n{\n#if QT_VERSION >= 0x040600\n  QWebHitTestResult r = ui.definition->page()->mainFrame()->hitTestContent( pos );\n  QWebElement el = r.element();\n  QUrl imageUrl;\n  if( el.tagName().compare( \"img\", Qt::CaseInsensitive ) == 0 )\n  {\n    // Double click on image; download it and transfer to external program\n\n    imageUrl = QUrl::fromPercentEncoding( el.attribute( \"src\" ).toLatin1() );\n    if( !imageUrl.isEmpty() )\n    {\n      // Download it\n\n      // Clear any pending ones\n      resourceDownloadRequests.clear();\n\n      resourceDownloadUrl = imageUrl;\n      sptr< Dictionary::DataRequest > req;\n\n      if ( imageUrl.scheme() == \"http\" || imageUrl.scheme() == \"https\" || imageUrl.scheme() == \"ftp\" )\n      {\n        // Web resource\n        req = new Dictionary::WebMultimediaDownload( imageUrl, articleNetMgr );\n      }\n      else\n      if ( imageUrl.scheme() == \"bres\" || imageUrl.scheme() == \"gdpicture\" )\n      {\n        // Local resource\n        QString contentType;\n        req = articleNetMgr.getResource( imageUrl, contentType );\n      }\n      else\n      {\n        // Unsupported scheme\n        gdWarning( \"Unsupported url scheme \\\"%s\\\" to download image\\n\", imageUrl.scheme().toUtf8().data() );\n        return;\n      }\n\n      if ( !req.get() )\n      {\n        // Request failed, fail\n        gdWarning( \"Can't create request to download image \\\"%s\\\"\\n\", imageUrl.toString().toUtf8().data() );\n        return;\n      }\n\n      if ( req->isFinished() && req->dataSize() >= 0 )\n      {\n        // Have data ready, handle it\n        resourceDownloadRequests.push_back( req );\n        resourceDownloadFinished();\n        return;\n      }\n      else\n      if ( !req->isFinished() )\n      {\n        // Queue to be handled when done\n        resourceDownloadRequests.push_back( req );\n        connect( req.get(), SIGNAL( finished() ), this, SLOT( resourceDownloadFinished() ) );\n      }\n      if ( resourceDownloadRequests.empty() ) // No requests were queued\n      {\n        gdWarning( \"The referenced resource \\\"%s\\\" doesn't exist\\n\", imageUrl.toString().toUtf8().data() ) ;\n        return;\n      }\n      else\n        resourceDownloadFinished(); // Check any requests finished already\n    }\n    return;\n  }\n#endif\n\n  // We might want to initiate translation of the selected word\n\n  if ( cfg.preferences.doubleClickTranslates )\n  {\n    QString selectedText = ui.definition->selectedText();\n\n    // Do some checks to make sure there's a sensible selection indeed\n    if ( Folding::applyWhitespaceOnly( gd::toWString( selectedText ) ).size() &&\n         selectedText.size() < 60 )\n    {\n      // Initiate translation\n      Qt::KeyboardModifiers kmod = QApplication::keyboardModifiers();\n      if (kmod & (Qt::ControlModifier | Qt::ShiftModifier))\n      { // open in new tab\n        emit showDefinitionInNewTab( selectedText, getGroup( ui.definition->url() ),\n                                     getCurrentArticle(), Contexts() );\n      }\n      else\n      {\n        QUrl const & ref = ui.definition->url();\n\n        if( Qt4x5::Url::hasQueryItem( ref, \"dictionaries\" ) )\n        {\n          QStringList dictsList = Qt4x5::Url::queryItemValue(ref, \"dictionaries\" )\n                                              .split( \",\", Qt4x5::skipEmptyParts() );\n          showDefinition( selectedText, dictsList, QRegExp(), getGroup( ref ), false );\n        }\n        else\n          showDefinition( selectedText, getGroup( ref ), getCurrentArticle() );\n      }\n    }\n  }\n}\n\n\nvoid ArticleView::performFindOperation( bool restart, bool backwards, bool checkHighlight )\n{\n  QString text = ui.searchText->text();\n\n  if ( restart || checkHighlight )\n  {\n    if( restart ) {\n      // Anyone knows how we reset the search position?\n      // For now we resort to this hack:\n      if ( ui.definition->selectedText().size() )\n      {\n        ui.definition->page()->currentFrame()->\n               evaluateJavaScript( \"window.getSelection().removeAllRanges();_=0;\" );\n      }\n    }\n\n    QWebPage::FindFlags f;\n\n    if ( ui.searchCaseSensitive->isChecked() )\n      f |= QWebPage::FindCaseSensitively;\n#if QT_VERSION >= 0x040600\n    f |= QWebPage::HighlightAllOccurrences;\n#endif\n\n    ui.definition->findText( \"\", f );\n\n    if( ui.highlightAllButton->isChecked() )\n      ui.definition->findText( text, f );\n\n    if( checkHighlight )\n      return;\n  }\n\n  QWebPage::FindFlags f;\n\n  if ( ui.searchCaseSensitive->isChecked() )\n    f |= QWebPage::FindCaseSensitively;\n\n  if ( backwards )\n    f |= QWebPage::FindBackward;\n\n  bool setMark = text.size() && !ui.definition->findText( text, f );\n\n  if ( ui.searchText->property( \"noResults\" ).toBool() != setMark )\n  {\n    ui.searchText->setProperty( \"noResults\", setMark );\n\n    // Reload stylesheet\n    reloadStyleSheet();\n  }\n}\n\nvoid ArticleView::reloadStyleSheet()\n{\n  for( QWidget * w = parentWidget(); w; w = w->parentWidget() )\n  {\n    if ( w->styleSheet().size() )\n    {\n      w->setStyleSheet( w->styleSheet() );\n      break;\n    }\n  }\n}\n\n\nbool ArticleView::closeSearch()\n{\n  if ( searchIsOpened )\n  {\n    ui.searchFrame->hide();\n    ui.definition->setFocus();\n    searchIsOpened = false;\n\n    return true;\n  }\n  else\n  if( ftsSearchIsOpened )\n  {\n    allMatches.clear();\n    uniqueMatches.clear();\n    ftsPosition = 0;\n    ftsSearchIsOpened = false;\n\n    ui.ftsSearchFrame->hide();\n    ui.definition->setFocus();\n\n    QWebPage::FindFlags flags;\n\n  #if QT_VERSION >= 0x040600\n    flags |= QWebPage::HighlightAllOccurrences;\n  #endif\n\n    ui.definition->findText( \"\", flags );\n\n    return true;\n  }\n  else\n    return false;\n}\n\nbool ArticleView::isSearchOpened()\n{\n  return searchIsOpened;\n}\n\nvoid ArticleView::showEvent( QShowEvent * ev )\n{\n  QFrame::showEvent( ev );\n\n  if ( !searchIsOpened )\n    ui.searchFrame->hide();\n\n  if( !ftsSearchIsOpened )\n    ui.ftsSearchFrame->hide();\n}\n\nvoid ArticleView::receiveExpandOptionalParts( bool expand )\n{\n  if( expandOptionalParts != expand )\n    switchExpandOptionalParts();\n}\n\nvoid ArticleView::switchExpandOptionalParts()\n{\n  expandOptionalParts = !expandOptionalParts;\n  emit setExpandMode( expandOptionalParts );\n  reload();\n}\n\nvoid ArticleView::copyAsText()\n{\n  QString text = ui.definition->selectedText();\n  if( !text.isEmpty() )\n    QApplication::clipboard()->setText( text );\n}\n\nvoid ArticleView::inspect()\n{\n  ui.definition->triggerPageAction( QWebPage::InspectElement );\n}\n\nvoid ArticleView::highlightFTSResults()\n{\n  closeSearch();\n\n  const QUrl & url = ui.definition->url();\n\n  QString regString = Qt4x5::Url::queryItemValue( url, \"regexp\" );\n  if( regString.isEmpty() )\n    return;\n  const bool ignoreDiacritics = Qt4x5::Url::hasQueryItem( url, \"ignore_diacritics\" );\n  if( ignoreDiacritics )\n    regString = gd::toQString( Folding::applyDiacriticsOnly( gd::toWString( regString ) ) );\n  else\n    regString = regString.remove( AccentMarkHandler::accentMark() );\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  QRegularExpression regexp;\n  if( Qt4x5::Url::hasQueryItem( url, \"wildcards\" ) )\n    regexp.setPattern( wildcardsToRegexp( regString ) );\n  else\n    regexp.setPattern( regString );\n\n  QRegularExpression::PatternOptions patternOptions = QRegularExpression::DotMatchesEverythingOption\n                                                      | QRegularExpression::UseUnicodePropertiesOption\n                                                      | QRegularExpression::MultilineOption\n                                                      | QRegularExpression::InvertedGreedinessOption;\n  if( !Qt4x5::Url::hasQueryItem( url, \"matchcase\" ) )\n    patternOptions |= QRegularExpression::CaseInsensitiveOption;\n  regexp.setPatternOptions( patternOptions );\n\n  if( regexp.pattern().isEmpty() || !regexp.isValid() )\n    return;\n#else\n  QRegExp regexp( regString,\n                  Qt4x5::Url::hasQueryItem( url, \"matchcase\" ) ? Qt::CaseSensitive : Qt::CaseInsensitive,\n                  Qt4x5::Url::hasQueryItem( url, \"wildcards\" ) ? QRegExp::WildcardUnix : QRegExp::RegExp2 );\n\n\n  if( regexp.pattern().isEmpty() )\n    return;\n\n  regexp.setMinimal( true );\n#endif\n\n  sptr< AccentMarkHandler > marksHandler = ignoreDiacritics ?\n                                           new DiacriticsHandler : new AccentMarkHandler;\n\n  // Clear any current selection\n  if ( ui.definition->selectedText().size() )\n  {\n    ui.definition->page()->currentFrame()->\n           evaluateJavaScript( \"window.getSelection().removeAllRanges();_=0;\" );\n  }\n\n  QString pageText = ui.definition->page()->currentFrame()->toPlainText();\n  marksHandler->setText( pageText );\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  QRegularExpressionMatchIterator it = regexp.globalMatch( marksHandler->normalizedText() );\n  while( it.hasNext() )\n  {\n    QRegularExpressionMatch match = it.next();\n\n    // Mirror pos and matched length to original string\n    int pos = match.capturedStart();\n    int spos = marksHandler->mirrorPosition( pos );\n    int matched = marksHandler->mirrorPosition( pos + match.capturedLength() ) - spos;\n\n    // Add mark pos (if presented)\n    while( spos + matched < pageText.length()\n           && pageText[ spos + matched ].category() == QChar::Mark_NonSpacing )\n      matched++;\n\n    if( matched > FTS::MaxMatchLengthForHighlightResults )\n    {\n      gdWarning( \"ArticleView::highlightFTSResults(): Too long match - skipped (matched length %i, allowed %i)\",\n                 match.capturedLength(), FTS::MaxMatchLengthForHighlightResults );\n    }\n    else\n      allMatches.append( pageText.mid( spos, matched ) );\n  }\n#else\n  int pos = 0;\n\n  while( pos >= 0 )\n  {\n    pos = regexp.indexIn( marksHandler->normalizedText(), pos );\n    if( pos >= 0 )\n    {\n      // Mirror pos and matched length to original string\n      int spos = marksHandler->mirrorPosition( pos );\n      int matched = marksHandler->mirrorPosition( pos + regexp.matchedLength() ) - spos;\n\n      // Add mark pos (if presented)\n      while( spos + matched < pageText.length()\n             && pageText[ spos + matched ].category() == QChar::Mark_NonSpacing )\n        matched++;\n\n      if( matched > FTS::MaxMatchLengthForHighlightResults )\n      {\n        gdWarning( \"ArticleView::highlightFTSResults(): Too long match - skipped (matched length %i, allowed %i)\",\n                   regexp.matchedLength(), FTS::MaxMatchLengthForHighlightResults );\n      }\n      else\n        allMatches.append( pageText.mid( spos, matched ) );\n\n      pos += regexp.matchedLength();\n    }\n  }\n#endif\n\n  ftsSearchMatchCase = Qt4x5::Url::hasQueryItem( url, \"matchcase\" );\n\n  QWebPage::FindFlags flags;\n\n  if( ftsSearchMatchCase )\n    flags |= QWebPage::FindCaseSensitively;\n\n  if( allMatches.isEmpty() )\n    ui.ftsSearchStatusLabel->setText( searchStatusMessageNoMatches() );\n  else\n  {\n    highlightAllFtsOccurences( flags );\n    if( ui.definition->findText( allMatches.at( 0 ), flags ) )\n    {\n        ui.definition->page()->currentFrame()->\n               evaluateJavaScript( QString( \"%1=window.getSelection().getRangeAt(0);_=0;\" )\n                                   .arg( rangeVarName ) );\n    }\n    Q_ASSERT( ftsPosition == 0 );\n    ui.ftsSearchStatusLabel->setText( searchStatusMessage( 1, allMatches.size() ) );\n  }\n\n  ui.ftsSearchFrame->show();\n  ui.ftsSearchPrevious->setEnabled( false );\n  ui.ftsSearchNext->setEnabled( allMatches.size()>1 );\n\n  ftsSearchIsOpened = true;\n}\n\nvoid ArticleView::highlightAllFtsOccurences( QWebPage::FindFlags flags )\n{\n  flags |= QWebPage::HighlightAllOccurrences;\n\n  // Usually allMatches contains mostly duplicates. Thus searching for each element of\n  // allMatches to highlight them takes a long time => collect unique elements into a\n  // set and search for them instead.\n  // Don't use QList::toSet() or QSet's range constructor because they reserve space\n  // for QList::size() elements, whereas the final QSet size is likely 1 or 2.\n  QSet< QString > uniqueMatches;\n  for( int x = 0; x < allMatches.size(); ++x )\n  {\n    QString const & match = allMatches.at( x );\n    // Consider words that differ only in case equal if the search is case-insensitive.\n    uniqueMatches.insert( ftsSearchMatchCase ? match : match.toLower() );\n  }\n\n  for( QSet< QString >::const_iterator it = uniqueMatches.constBegin(); it != uniqueMatches.constEnd(); ++it )\n    ui.definition->findText( *it, flags );\n}\n\nvoid ArticleView::performFtsFindOperation( bool backwards )\n{\n  if( !ftsSearchIsOpened )\n    return;\n\n  if( allMatches.isEmpty() )\n  {\n    ui.ftsSearchStatusLabel->setText( searchStatusMessageNoMatches() );\n    ui.ftsSearchNext->setEnabled( false );\n    ui.ftsSearchPrevious->setEnabled( false );\n    return;\n  }\n\n  QWebPage::FindFlags flags;\n\n  if( ftsSearchMatchCase )\n    flags |= QWebPage::FindCaseSensitively;\n\n\n  // Restore saved highlighted selection\n  ui.definition->page()->currentFrame()->\n         evaluateJavaScript( QString( \"var sel=window.getSelection();sel.removeAllRanges();sel.addRange(%1);_=0;\" )\n                             .arg( rangeVarName ) );\n\n  bool res;\n  if( backwards )\n  {\n    if( ftsPosition > 0 )\n    {\n      res = ui.definition->findText( allMatches.at( ftsPosition - 1 ),\n                                     flags | QWebPage::FindBackward );\n      ftsPosition -= 1;\n    }\n    else\n      res = ui.definition->findText( allMatches.at( ftsPosition ),\n                                     flags | QWebPage::FindBackward );\n\n    ui.ftsSearchPrevious->setEnabled( res );\n    if( !ui.ftsSearchNext->isEnabled() )\n      ui.ftsSearchNext->setEnabled( res );\n  }\n  else\n  {\n    if( ftsPosition < allMatches.size() - 1 )\n    {\n      res = ui.definition->findText( allMatches.at( ftsPosition + 1 ), flags );\n      ftsPosition += 1;\n    }\n    else\n      res = ui.definition->findText( allMatches.at( ftsPosition ), flags );\n\n    ui.ftsSearchNext->setEnabled( res );\n    if( !ui.ftsSearchPrevious->isEnabled() )\n      ui.ftsSearchPrevious->setEnabled( res );\n  }\n\n  ui.ftsSearchStatusLabel->setText( searchStatusMessage( ftsPosition + 1, allMatches.size() ) );\n\n  // Store new highlighted selection\n  ui.definition->page()->currentFrame()->\n         evaluateJavaScript( QString( \"%1=window.getSelection().getRangeAt(0);_=0;\" )\n                             .arg( rangeVarName ) );\n}\n\nvoid ArticleView::on_ftsSearchPrevious_clicked()\n{\n  performFtsFindOperation( true );\n}\n\nvoid ArticleView::on_ftsSearchNext_clicked()\n{\n  performFtsFindOperation( false );\n}\n\n#ifdef Q_OS_WIN32\n\nvoid ArticleView::readTag( const QString & from, QString & to, int & count )\n{\n    QChar ch, prev_ch;\n    bool inQuote = false, inDoublequote = false;\n\n    to.append( ch = prev_ch = from[ count++ ] );\n    while( count < from.size() )\n    {\n        ch = from[ count ];\n        if( ch == '>' && !( inQuote || inDoublequote ) )\n        {\n            to.append( ch );\n            break;\n        }\n        if( ch == '\\'' )\n            inQuote = !inQuote;\n        if( ch == '\\\"' )\n            inDoublequote = !inDoublequote;\n        to.append( prev_ch = ch );\n        count++;\n    }\n}\n\nQString ArticleView::insertSpans( QString const & html )\n{\n    QChar ch;\n    QString newContent;\n    bool inSpan = false, escaped = false;\n\n    /// Enclose every word in string (exclude tags) with <span></span>\n\n    for( int i = 0; i < html.size(); i++ )\n    {\n        ch = html[ i ];\n        if( ch == '&' )\n        {\n            escaped = true;\n            if( inSpan )\n            {\n                newContent.append( \"</span>\" );\n                inSpan = false;\n            }\n            newContent.append( ch );\n            continue;\n        }\n\n        if( ch == '<' ) // Skip tag\n        {\n            escaped = false;\n            if( inSpan )\n            {\n                newContent.append( \"</span>\" );\n                inSpan = false;\n            }\n            readTag( html, newContent, i );\n            continue;\n        }\n\n        if( escaped )\n        {\n            if( ch == ';' )\n                escaped = false;\n            newContent.append( ch );\n            continue;\n        }\n\n        if( !inSpan && ( ch.isLetterOrNumber() || ch.isLowSurrogate() ) )\n        {\n            newContent.append( \"<span>\");\n            inSpan = true;\n        }\n\n        if( inSpan && !( ch.isLetterOrNumber() || ch.isLowSurrogate() ) )\n        {\n            newContent.append( \"</span>\");\n            inSpan = false;\n        }\n\n        if( ch.isLowSurrogate() )\n        {\n            newContent.append( ch );\n            ch = html[ ++i ];\n        }\n\n        newContent.append( ch );\n        if( ch == '-' && !( html[ i + 1 ] == ' ' || ( i > 0 && html[ i - 1 ] == ' ' ) ) )\n            newContent.append( \"<span style=\\\"font-size:0pt\\\"> </span>\" );\n    }\n    if( inSpan )\n        newContent.append( \"</span>\" );\n    return newContent;\n}\n\nQString ArticleView::checkElement( QWebElement & elem, QPoint const & pt )\n{\n    /// Search for lower-level matching element\n\n    QWebElement parentElem = elem;\n    QWebElement childElem = elem.firstChild();\n    while( !childElem.isNull() )\n    {\n      if( childElem.geometry().contains( pt ) )\n      {\n        parentElem = childElem;\n        childElem = parentElem.firstChild();\n        continue;\n      }\n      childElem = childElem.nextSibling();\n    }\n\n    return parentElem.toPlainText();\n}\n\nQString ArticleView::wordAtPoint( int x, int y )\n{\n  QString word;\n\n  if( popupView )\n    return word;\n\n  QPoint pos = mapFromGlobal( QPoint( x, y ) );\n  QWebFrame *frame = ui.definition->page()->frameAt( pos );\n  if( !frame )\n    return word;\n\n  QPoint posWithScroll = pos + frame->scrollPosition();\n\n  /// Find target HTML element\n\n  QWebHitTestResult result = frame->hitTestContent( pos );\n  QWebElement baseElem = result.enclosingBlockElement();\n\n  if( baseElem.tagName().compare( \"BODY\" ) == 0 ||      /// Assume empty field position\n      baseElem.tagName().compare( \"HTML\" ) == 0 ||\n      baseElem.tagName().compare( \"HEAD\" ) == 0 )\n    return word;\n\n  /// Save selection position\n\n  baseElem.evaluateJavaScript( \"var __gd_sel=window.getSelection();\"\n                               \"if(__gd_sel && __gd_sel.rangeCount>0) {\"\n                                 \"__gd_SelRange=__gd_sel.getRangeAt(0);\"\n                                 \"if(__gd_SelRange.collapsed) __gd_sel.removeAllRanges();\"\n                                 \"else {\"\n                                   \"__gd_StartTree=[]; __gd_EndTree=[];\"\n                                   \"var __gd_baseRange=document.createRange();\"\n                                   \"__gd_baseRange.selectNode(this);\"\n                                   \"if(__gd_baseRange.comparePoint(__gd_SelRange.startContainer,0)==0) {\"\n                                     \"__gd_StartOffset=__gd_SelRange.startOffset;\"\n                                     \"var __gd_child=__gd_SelRange.startContainer;\"\n                                     \"var __gd_parent='';\"\n                                     \"if(__gd_child==this) __gd_StartTree.push(-1);\"\n                                     \"else while(__gd_parent!=this) {\"\n                                       \"var n=0; __gd_parent=__gd_child.parentNode;\"\n                                       \"var __gd_el=__gd_parent.firstChild;\"\n                                       \"while(__gd_el!=__gd_child) { n++; __gd_el=__gd_el.nextSibling; }\"\n                                       \"__gd_StartTree.push(n);\"\n                                       \"__gd_child=__gd_parent;\"\n                                     \"}\"\n                                   \"}\"\n                                   \"if(__gd_baseRange.comparePoint(__gd_SelRange.endContainer,0)==0) {\"\n                                     \"__gd_EndOffset=__gd_SelRange.endOffset;\"\n                                     \"var __gd_child=__gd_SelRange.endContainer;\"\n                                     \"var __gd_parent='';\"\n                                     \"if(__gd_child==this) __gd_EndTree.push(-1);\"\n                                     \"else while(__gd_parent!=this) {\"\n                                       \"var n=0; __gd_parent=__gd_child.parentNode;\"\n                                       \"var __gd_el=__gd_parent.firstChild;\"\n                                       \"while(__gd_el!=__gd_child) { n++; __gd_el=__gd_el.nextSibling; }\"\n                                       \"__gd_EndTree.push(n);\"\n                                       \"__gd_child=__gd_parent;\"\n                                     \"}\"\n                                   \"}\"\n                                 \"}\"\n                               \"}\"\n                               );\n\n  /// Enclose every word be <span> </span>\n\n  QString content = baseElem.toInnerXml();\n  QString newContent = insertSpans( content );\n\n  /// Set new code and re-render it to fill geometry\n\n  QImage img( baseElem.geometry().width(), baseElem.geometry().height(), QImage::Format_Mono );\n  img.fill( 0 );\n  QPainter painter( & img );\n\n  baseElem.setInnerXml( newContent );\n  baseElem.render( &painter );\n\n  /// Search in all child elements and check it\n\n  QWebElementCollection elemCollection = baseElem.findAll( \"*\" );\n  foreach ( QWebElement elem, elemCollection )\n  {\n      if( elem.geometry().contains( posWithScroll ) )\n          word = checkElement( elem, posWithScroll );\n      if( !word.isEmpty() )\n          break;\n  }\n\n  /// Restore old content\n  baseElem.setInnerXml( content );\n\n  /// Restore selection\n\n  baseElem.evaluateJavaScript( \"var flag=0;\"\n                               \"if(__gd_StartTree && __gd_StartTree.length) {\"\n                                 \"var __gd_el=this;\"\n                                 \"while(__gd_StartTree.length) {\"\n                                   \"__gd_el=__gd_el.firstChild;\"\n                                   \"var n=__gd_StartTree.pop();\"\n                                   \"if(n<0) __gd_el=this;\"\n                                   \"else for(var i=0;i<n;i++) __gd_el=__gd_el.nextSibling;\"\n                                 \"}\"\n                                 \"__gd_SelRange.setStart(__gd_el, __gd_StartOffset);\"\n                                 \"__gd_StartTree.splice(0,__gd_StartTree.length);\"\n                                 \"flag+=1;\"\n                               \"}\"\n                               \"if(__gd_EndTree && __gd_EndTree.length) {\"\n                                 \"var __gd_el=this;\"\n                                 \"while(__gd_EndTree.length) {\"\n                                   \"__gd_el=__gd_el.firstChild;\"\n                                   \"var n=__gd_EndTree.pop();\"\n                                   \"if(n<0) __gd_el=this;\"\n                                   \"else for(var i=0;i<n;i++) __gd_el=__gd_el.nextSibling;\"\n                                 \"}\"\n                                 \"__gd_SelRange.setEnd(__gd_el, __gd_EndOffset);\"\n                                 \"__gd_EndTree.splice(0,__gd_EndTree.length);\"\n                                 \"flag+=1;\"\n                               \"}\"\n                               \"if(flag>0) {\"\n                                 \"var __gd_sel=window.getSelection();\"\n                                 \"__gd_sel.removeAllRanges();\"\n                                 \"__gd_sel.addRange(__gd_SelRange);\"\n                               \"}\"\n                               );\n\n  return word;\n}\n\n#endif\n\nResourceToSaveHandler::ResourceToSaveHandler(ArticleView * view, QString const & fileName ) :\n  QObject( view ),\n  fileName( fileName ),\n  alreadyDone( false )\n{\n  connect( this, SIGNAL( statusBarMessage( QString, int, QPixmap ) ),\n           view, SIGNAL( statusBarMessage( QString, int, QPixmap ) ) );\n}\n\nvoid ResourceToSaveHandler::addRequest( sptr<Dictionary::DataRequest> req )\n{\n  if( !alreadyDone )\n  {\n    downloadRequests.push_back( req );\n\n    connect( req.get(), SIGNAL( finished() ),\n             this, SLOT( downloadFinished() ) );\n  }\n}\n\nvoid ResourceToSaveHandler::downloadFinished()\n{\n  if ( downloadRequests.empty() )\n    return; // Stray signal\n\n  // Find any finished resources\n  for( list< sptr< Dictionary::DataRequest > >::iterator i =\n       downloadRequests.begin(); i != downloadRequests.end(); )\n  {\n    if ( (*i)->isFinished() )\n    {\n      if ( (*i)->dataSize() >= 0 && !alreadyDone )\n      {\n        QByteArray resourceData;\n        vector< char > const & data = (*i)->getFullData();\n        resourceData = QByteArray( data.data(), data.size() );\n\n        // Write data to file\n\n        if ( !fileName.isEmpty() )\n        {\n          QFileInfo fileInfo( fileName );\n          QDir().mkpath( fileInfo.absoluteDir().absolutePath() );\n\n          QFile file( fileName );\n          if ( file.open( QFile::WriteOnly ) )\n          {\n            file.write( resourceData.data(), resourceData.size() );\n            file.close();\n          }\n\n          if ( file.error() )\n          {\n            emit statusBarMessage(\n                  tr( \"ERROR: %1\" ).arg( tr( \"Resource saving error: \" ) + file.errorString() ),\n                  10000, QPixmap( \":/icons/error.png\" ) );\n          }\n        }\n        alreadyDone = true;\n\n        // Clear other requests\n\n        downloadRequests.clear();\n        break;\n      }\n      else\n      {\n        // This one had no data. Erase it.\n        downloadRequests.erase( i++ );\n      }\n    }\n    else // Unfinished, wait.\n      break;\n  }\n\n  if ( downloadRequests.empty() )\n  {\n    if( !alreadyDone )\n    {\n      emit statusBarMessage(\n            tr( \"WARNING: %1\" ).arg( tr( \"The referenced resource failed to download.\" ) ),\n            10000, QPixmap( \":/icons/error.png\" ) );\n    }\n    emit done();\n    deleteLater();\n  }\n}\n\n#include \"articleview.moc\"\n"
        },
        {
          "name": "articleview.hh",
          "type": "blob",
          "size": 12.98046875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __ARTICLEVIEW_HH_INCLUDED__\n#define __ARTICLEVIEW_HH_INCLUDED__\n\n#include <QWebView>\n#include <QMap>\n#include <QUrl>\n#include <QSet>\n#include <list>\n#include \"article_netmgr.hh\"\n#include \"audioplayerinterface.hh\"\n#include \"instances.hh\"\n#include \"groupcombobox.hh\"\n#include \"ui_articleview.h\"\n\nclass ArticleViewJsProxy;\nclass ResourceToSaveHandler;\n\n/// A widget with the web view tailored to view and handle articles -- it\n/// uses the appropriate netmgr, handles link clicks, rmb clicks etc\nclass ArticleView: public QFrame\n{\n  Q_OBJECT\n\n  ArticleNetworkAccessManager & articleNetMgr;\n  AudioPlayerPtr const & audioPlayer;\n  std::vector< sptr< Dictionary::Class > > const & allDictionaries;\n  Instances::Groups const & groups;\n  bool popupView;\n  Config::Class const & cfg;\n\n  Ui::ArticleView ui;\n\n  ArticleViewJsProxy * const jsProxy;\n\n  QAction pasteAction, articleUpAction, articleDownAction,\n          goBackAction, goForwardAction, selectCurrentArticleAction,\n          copyAsTextAction, inspectAction;\n  QAction & openSearchAction;\n  bool searchIsOpened;\n  bool expandOptionalParts;\n  QString rangeVarName;\n\n  /// Any resource we've decided to download off the dictionary gets stored here.\n  /// Full vector capacity is used for search requests, where we have to make\n  /// a multitude of requests.\n  std::list< sptr< Dictionary::DataRequest > > resourceDownloadRequests;\n  /// Url of the resourceDownloadRequests\n  QUrl resourceDownloadUrl;\n\n  /// For resources opened via desktop services\n  QSet< QString > desktopOpenedTempFiles;\n\n  QAction * dictionaryBarToggled;\n  GroupComboBox const * groupComboBox;\n\n  /// Search in results of full-text search\n  QStringList allMatches;\n  QStringList uniqueMatches;\n  bool ftsSearchIsOpened, ftsSearchMatchCase;\n  int ftsPosition;\n\n  void highlightFTSResults();\n  void highlightAllFtsOccurences( QWebPage::FindFlags flags );\n  void performFtsFindOperation( bool backwards );\n\npublic:\n  /// The popupView flag influences contents of the context menus to be\n  /// appropriate to the context of the view.\n  /// The groups aren't copied -- rather than that, the reference is kept\n  ArticleView( QWidget * parent,\n               ArticleNetworkAccessManager &,\n               AudioPlayerPtr const &,\n               std::vector< sptr< Dictionary::Class > > const & allDictionaries,\n               Instances::Groups const &,\n               bool popupView,\n               Config::Class const & cfg,\n               QAction & openSearchAction_,\n               QAction * dictionaryBarToggled = 0,\n               GroupComboBox const * groupComboBox = 0 );\n\n  /// Sets the currently active group combo box. When looking up selections,\n  /// this allows presenting a choice of looking up in the currently chosen\n  /// group. Setting this to 0 disables this. It is 0 by default.\n  void setGroupComboBox( GroupComboBox const * );\n\n  virtual QSize minimumSizeHint() const;\n\n  ~ArticleView();\n\n  typedef QMap< QString, QString > Contexts;\n\n  /// Returns \"gdfrom-\" + dictionaryId.\n  static QString scrollToFromDictionaryId( QString const & dictionaryId );\n\n  /// Shows the definition of the given word with the given group.\n  /// scrollTo can be optionally set to a \"gdfrom-xxxx\" identifier to position\n  /// the page to that article on load.\n  /// contexts is an optional map of context values to be passed for dictionaries.\n  /// The only values to pass here are ones obtained from showDefinitionInNewTab()\n  /// signal or none at all.\n  void showDefinition( Config::InputPhrase const & phrase, unsigned group,\n                       QString const & scrollTo = QString(),\n                       Contexts const & contexts = Contexts() );\n\n  void showDefinition( QString const & word, unsigned group,\n                       QString const & scrollTo = QString(),\n                       Contexts const & contexts = Contexts() );\n\n  void showDefinition( QString const & word, QStringList const & dictIDs,\n                       QRegExp const & searchRegExp, unsigned group,\n                       bool ignoreDiacritics );\n\n  /// Clears the view and sets the application-global waiting cursor,\n  /// which will be restored when some article loads eventually.\n  void showAnticipation();\n\n  /// Opens the given link. Supposed to be used in response to\n  /// openLinkInNewTab() signal. The link scheme is therefore supposed to be\n  /// one of the internal ones.\n  /// contexts is an optional map of context values to be passed for dictionaries.\n  /// The only values to pass here are ones obtained from showDefinitionInNewTab()\n  /// signal or none at all.\n  void openLink( QUrl const & url, QUrl const & referrer,\n                 QString const & scrollTo = QString(),\n                 Contexts const & contexts = Contexts() );\n\n  /// Called when the state of dictionary bar changes and the view is active.\n  /// The function reloads content if the change affects it.\n  void updateMutedContents();\n\n  bool canGoBack();\n  bool canGoForward();\n\n  /// Called when preference changes\n  void setSelectionBySingleClick( bool set );\n\npublic slots:\n\n  /// Goes back in history\n  void back();\n\n  /// Goes forward in history\n  void forward();\n\n  /// Takes the focus to the view\n  void focus()\n  { ui.definition->setFocus( Qt::ShortcutFocusReason ); }\n\npublic:\n\n  /// Reloads the view\n  void reload();\n\n  /// Returns true if there's an audio reference on the page, false otherwise.\n  bool hasSound();\n\n  /// Plays the first audio reference on the page, if any.\n  void playSound();\n\n  void setZoomFactor( qreal factor )\n  { ui.definition->setZoomFactor( factor ); }\n\n  /// Returns current article's text in .html format\n  QString toHtml();\n\n  /// Returns current article's title\n  QString getTitle();\n\n  /// Returns the phrase translated by the current article.\n  Config::InputPhrase getPhrase() const;\n\n  /// Prints current article\n  void print( QPrinter * ) const;\n\n  /// Closes search if it's open and returns true. Returns false if it\n  /// wasn't open.\n  bool closeSearch();\n\n  bool isSearchOpened();\n\n  /// Jumps to the article specified by the dictionary id,\n  /// by executing a javascript code.\n  void jumpToDictionary( QString const &, bool force );\n\n  /// Returns all articles currently present in view, as a list of dictionary\n  /// string ids.\n  QStringList getArticlesList();\n\n  /// Returns the dictionary id of the currently active article in the view.\n  QString getActiveArticleId();\n\n  ResourceToSaveHandler * saveResource( const QUrl & url, const QString & fileName );\n  ResourceToSaveHandler * saveResource( const QUrl & url, const QUrl & ref, const QString & fileName );\n\n  /// Return group id of the view\n  unsigned getViewGroup()\n  { return getGroup( ui.definition->url() ); }\n\nsignals:\n\n  void iconChanged( ArticleView *, QIcon const & icon );\n\n  void titleChanged( ArticleView *, QString const & title );\n\n  void pageLoaded( ArticleView * );\n\n  /// Signals that the following link was requested to be opened in new tab\n  void openLinkInNewTab( QUrl const &, QUrl const & referrer,\n                         QString const & fromArticle,\n                         ArticleView::Contexts const & contexts );\n  /// Signals that the following definition was requested to be showed in new tab\n  void showDefinitionInNewTab( QString const & word, unsigned group,\n                               QString const & fromArticle,\n                               ArticleView::Contexts const & contexts );\n\n  /// Put translated word into history\n  void sendWordToHistory( QString const & word );\n\n  /// Emitted when user types a text key. This should typically be used to\n  /// switch focus to word input.\n  void typingEvent( QString const & text );\n\n  void statusBarMessage( QString const & message, int timeout = 0, QPixmap const & pixmap = QPixmap());\n\n  /// Signals that the dictionaries pane was requested to be showed\n  void showDictsPane( );\n\n  /// Emitted when an article becomes active,\n  /// typically in response to user actions\n  /// (clicking on the article or using shortcuts).\n  /// id - the dictionary id of the active article.\n  void activeArticleChanged ( ArticleView const *, QString const & id );\n\n  /// Signal to add word to history even if history is disabled\n  void forceAddWordToHistory( const QString & word);\n\n  /// Signal to close popup menu\n  void closePopupMenu();\n\n  /// Signal to set optional parts expand mode\n  void setExpandMode ( bool  expand );\n\n  void sendWordToInputLine( QString const & word );\n\n  void storeResourceSavePath(QString const & );\n\n  void zoomIn();\n  void zoomOut();\n\npublic slots:\n\n  void on_searchPrevious_clicked();\n  void on_searchNext_clicked();\n\n  void onJsActiveArticleChanged(QString const & id);\n\n  /// Handles F3 and Shift+F3 for search navigation\n  bool handleF3( QObject * obj, QEvent * ev );\n\n  /// Control optional parts expanding\n  void receiveExpandOptionalParts( bool expand );\n  void switchExpandOptionalParts();\n\n  /// Selects an entire text of the current article\n  void selectCurrentArticle();\n\nprivate slots:\n\n  void loadFinished( bool ok );\n  void handleTitleChanged( QString const & title );\n  void handleUrlChanged( QUrl const & url );\n  void attachToJavaScript();\n  void linkClicked( QUrl const & );\n  void linkHovered( const QString & link, const QString & title, const QString & textContent );\n  void contextMenuRequested( QPoint const & );\n\n  void resourceDownloadFinished();\n\n  /// We handle pasting by attempting to define the word in clipboard.\n  void pasteTriggered();\n\n  /// Nagivates to the previous article relative to the active one.\n  void moveOneArticleUp();\n\n  /// Nagivates to the next article relative to the active one.\n  void moveOneArticleDown();\n\n  /// Opens the search area\n  void openSearch();\n\n  void on_searchText_textEdited();\n  void on_searchText_returnPressed();\n  void on_searchCloseButton_clicked();\n  void on_searchCaseSensitive_clicked();\n  void on_highlightAllButton_clicked();\n\n  void on_ftsSearchPrevious_clicked();\n  void on_ftsSearchNext_clicked();\n\n  /// Handles the double-click from the definition.\n  void doubleClicked( QPoint pos );\n\n  /// Handles audio player error message\n  void audioPlayerError( QString const & message );\n\n  /// Copy current selection as plain text\n  void copyAsText();\n\n  /// Inspect element\n  void inspect();\n\nprivate:\n\n  /// Deduces group from the url. If there doesn't seem to be any group,\n  /// returns 0.\n  unsigned getGroup( QUrl const & );\n\n\n  /// Returns current article in the view, in the form of \"gdfrom-xxx\" id.\n  QString getCurrentArticle();\n\n  /// Sets the current article by executing a javascript code.\n  /// If moveToIt is true, it moves the focus to it as well.\n  /// Returns true in case of success, false otherwise.\n  bool setCurrentArticle( QString const &, bool moveToIt = false );\n\n  /// Checks if the given article in form of \"gdfrom-xxx\" is inside a \"website\"\n  /// frame.\n  bool isFramedArticle( QString const & );\n\n  /// Checks if the given link is to be opened externally, as opposed to opening\n  /// it in-place.\n  bool isExternalLink( QUrl const & url );\n\n  /// Sees if the last clicked link is from a website frame. If so, changes url\n  /// to point to url text translation instead, and saves the original\n  /// url to the appropriate \"contexts\" entry.\n  void tryMangleWebsiteClickedUrl( QUrl & url, Contexts & contexts );\n\n  /// Use the known information about the current frame to update the current\n  /// article's value.\n  void updateCurrentArticleFromCurrentFrame( QWebFrame * frame = 0 );\n\n  /// Saves current article and scroll position for the current history item.\n  /// Should be used when leaving the page.\n  void saveHistoryUserData();\n\n  /// Loads a page at @p url into view.\n  void load( QUrl const & url );\n\n  /// Attempts removing last temporary file created.\n  void cleanupTemp();\n\n  bool eventFilter( QObject * obj, QEvent * ev );\n\n  void performFindOperation( bool restart, bool backwards, bool checkHighlight = false );\n\n  void reloadStyleSheet();\n\n  /// Returns the comma-separated list of dictionary ids which should be muted\n  /// for the given group. If there are none, returns empty string.\n  QString getMutedForGroup( unsigned group );\n\nprotected:\n\n  // We need this to hide the search bar when we're showed\n  void showEvent( QShowEvent * );\n\n#ifdef Q_OS_WIN32\n\n  /// Search inside web page for word under cursor\n\nprivate:\n  QString insertSpans( QString const & html );\n  void readTag( QString const & from, QString & to, int & count );\n  QString checkElement( QWebElement & elem, const QPoint & pt );\npublic:\n  QString wordAtPoint( int x, int y );\n#endif\n\n};\n\nclass ResourceToSaveHandler: public QObject\n{\n  Q_OBJECT\n\npublic:\n  explicit ResourceToSaveHandler( ArticleView * view, QString const & fileName );\n  void addRequest( sptr< Dictionary::DataRequest > req );\n  bool isEmpty()\n  { return downloadRequests.empty(); }\n\nsignals:\n  void done();\n  void statusBarMessage( QString const & message, int timeout = 0, QPixmap const & pixmap = QPixmap() );\n\npublic slots:\n  void downloadFinished();\n\nprivate:\n  std::list< sptr< Dictionary::DataRequest > > downloadRequests;\n  QString fileName;\n  bool alreadyDone;\n};\n\n#endif\n"
        },
        {
          "name": "articleview.ui",
          "type": "blob",
          "size": 7.486328125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ui version=\"4.0\">\n <class>ArticleView</class>\n <widget class=\"QWidget\" name=\"ArticleView\">\n  <property name=\"geometry\">\n   <rect>\n    <x>0</x>\n    <y>0</y>\n    <width>833</width>\n    <height>634</height>\n   </rect>\n  </property>\n  <property name=\"windowTitle\">\n   <string>Form</string>\n  </property>\n  <layout class=\"QVBoxLayout\" name=\"verticalLayout_2\" stretch=\"1000,0,0\">\n   <property name=\"leftMargin\">\n    <number>0</number>\n   </property>\n   <property name=\"topMargin\">\n    <number>0</number>\n   </property>\n   <property name=\"rightMargin\">\n    <number>0</number>\n   </property>\n   <property name=\"bottomMargin\">\n    <number>0</number>\n   </property>\n   <item>\n    <widget class=\"QFrame\" name=\"frame\">\n     <property name=\"frameShape\">\n      <enum>QFrame::StyledPanel</enum>\n     </property>\n     <property name=\"frameShadow\">\n      <enum>QFrame::Raised</enum>\n     </property>\n     <layout class=\"QVBoxLayout\" name=\"verticalLayout\">\n      <property name=\"leftMargin\">\n       <number>0</number>\n      </property>\n      <property name=\"topMargin\">\n       <number>0</number>\n      </property>\n      <property name=\"rightMargin\">\n       <number>0</number>\n      </property>\n      <property name=\"bottomMargin\">\n       <number>0</number>\n      </property>\n      <item>\n       <widget class=\"ArticleWebView\" name=\"definition\" native=\"true\">\n        <property name=\"url\" stdset=\"0\">\n         <url>\n          <string>about:blank</string>\n         </url>\n        </property>\n       </widget>\n      </item>\n     </layout>\n    </widget>\n   </item>\n   <item>\n    <widget class=\"QFrame\" name=\"ftsSearchFrame\">\n     <property name=\"frameShadow\">\n      <enum>QFrame::Raised</enum>\n     </property>\n     <layout class=\"QHBoxLayout\" name=\"horizontalLayout_3\">\n      <item>\n       <widget class=\"QToolButton\" name=\"ftsSearchPrevious\">\n        <property name=\"text\">\n         <string>&amp;Previous</string>\n        </property>\n        <property name=\"icon\">\n         <iconset resource=\"resources.qrc\">\n          <normaloff>:/icons/previous.png</normaloff>:/icons/previous.png</iconset>\n        </property>\n        <property name=\"toolButtonStyle\">\n         <enum>Qt::ToolButtonTextBesideIcon</enum>\n        </property>\n       </widget>\n      </item>\n      <item>\n       <widget class=\"QToolButton\" name=\"ftsSearchNext\">\n        <property name=\"text\">\n         <string>&amp;Next</string>\n        </property>\n        <property name=\"icon\">\n         <iconset resource=\"resources.qrc\">\n          <normaloff>:/icons/next.png</normaloff>:/icons/next.png</iconset>\n        </property>\n        <property name=\"toolButtonStyle\">\n         <enum>Qt::ToolButtonTextBesideIcon</enum>\n        </property>\n       </widget>\n      </item>\n      <item>\n       <widget class=\"QLabel\" name=\"ftsSearchStatusLabel\"/>\n      </item>\n      <item>\n       <spacer name=\"horizontalSpacer_2\">\n        <property name=\"orientation\">\n         <enum>Qt::Horizontal</enum>\n        </property>\n        <property name=\"sizeHint\" stdset=\"0\">\n         <size>\n          <width>40</width>\n          <height>20</height>\n         </size>\n        </property>\n       </spacer>\n      </item>\n     </layout>\n    </widget>\n   </item>\n   <item>\n    <widget class=\"QFrame\" name=\"searchFrame\">\n     <property name=\"sizePolicy\">\n      <sizepolicy hsizetype=\"Preferred\" vsizetype=\"Preferred\">\n       <horstretch>0</horstretch>\n       <verstretch>0</verstretch>\n      </sizepolicy>\n     </property>\n     <property name=\"frameShape\">\n      <enum>QFrame::NoFrame</enum>\n     </property>\n     <property name=\"frameShadow\">\n      <enum>QFrame::Raised</enum>\n     </property>\n     <layout class=\"QGridLayout\" name=\"gridLayout\">\n      <item row=\"0\" column=\"0\">\n       <layout class=\"QHBoxLayout\" name=\"horizontalLayout_2\">\n        <item>\n         <widget class=\"QLabel\" name=\"label\">\n          <property name=\"text\">\n           <string>Find:</string>\n          </property>\n         </widget>\n        </item>\n        <item>\n         <widget class=\"QLineEdit\" name=\"searchText\"/>\n        </item>\n        <item>\n         <widget class=\"QToolButton\" name=\"searchCloseButton\">\n          <property name=\"text\">\n           <string>x</string>\n          </property>\n          <property name=\"icon\">\n           <iconset resource=\"resources.qrc\">\n            <normaloff>:/icons/closetab.png</normaloff>:/icons/closetab.png</iconset>\n          </property>\n          <property name=\"autoRaise\">\n           <bool>true</bool>\n          </property>\n         </widget>\n        </item>\n       </layout>\n      </item>\n      <item row=\"1\" column=\"0\">\n       <layout class=\"QHBoxLayout\" name=\"horizontalLayout\">\n        <item>\n         <widget class=\"QToolButton\" name=\"searchPrevious\">\n          <property name=\"text\">\n           <string>&amp;Previous</string>\n          </property>\n          <property name=\"icon\">\n           <iconset resource=\"resources.qrc\">\n            <normaloff>:/icons/previous.png</normaloff>:/icons/previous.png</iconset>\n          </property>\n          <property name=\"toolButtonStyle\">\n           <enum>Qt::ToolButtonTextBesideIcon</enum>\n          </property>\n          <property name=\"autoRaise\">\n           <bool>true</bool>\n          </property>\n         </widget>\n        </item>\n        <item>\n         <widget class=\"QToolButton\" name=\"searchNext\">\n          <property name=\"text\">\n           <string>&amp;Next</string>\n          </property>\n          <property name=\"icon\">\n           <iconset resource=\"resources.qrc\">\n            <normaloff>:/icons/next.png</normaloff>:/icons/next.png</iconset>\n          </property>\n          <property name=\"shortcut\">\n           <string>Ctrl+G</string>\n          </property>\n          <property name=\"toolButtonStyle\">\n           <enum>Qt::ToolButtonTextBesideIcon</enum>\n          </property>\n          <property name=\"autoRaise\">\n           <bool>true</bool>\n          </property>\n         </widget>\n        </item>\n        <item>\n         <widget class=\"QToolButton\" name=\"highlightAllButton\">\n          <property name=\"text\">\n           <string>Highlight &amp;all</string>\n          </property>\n          <property name=\"icon\">\n           <iconset resource=\"resources.qrc\">\n            <normaloff>:/icons/highlighter.png</normaloff>:/icons/highlighter.png</iconset>\n          </property>\n          <property name=\"checkable\">\n           <bool>true</bool>\n          </property>\n          <property name=\"checked\">\n           <bool>false</bool>\n          </property>\n          <property name=\"toolButtonStyle\">\n           <enum>Qt::ToolButtonTextBesideIcon</enum>\n          </property>\n          <property name=\"autoRaise\">\n           <bool>true</bool>\n          </property>\n         </widget>\n        </item>\n        <item>\n         <widget class=\"QCheckBox\" name=\"searchCaseSensitive\">\n          <property name=\"text\">\n           <string>&amp;Case Sensitive</string>\n          </property>\n         </widget>\n        </item>\n        <item>\n         <spacer name=\"horizontalSpacer\">\n          <property name=\"orientation\">\n           <enum>Qt::Horizontal</enum>\n          </property>\n          <property name=\"sizeHint\" stdset=\"0\">\n           <size>\n            <width>782</width>\n            <height>20</height>\n           </size>\n          </property>\n         </spacer>\n        </item>\n       </layout>\n      </item>\n     </layout>\n    </widget>\n   </item>\n  </layout>\n </widget>\n <customwidgets>\n  <customwidget>\n   <class>ArticleWebView</class>\n   <extends>QWidget</extends>\n   <header>articlewebview.hh</header>\n  </customwidget>\n </customwidgets>\n <resources>\n  <include location=\"resources.qrc\"/>\n </resources>\n <connections/>\n</ui>\n"
        },
        {
          "name": "articlewebview.cc",
          "type": "blob",
          "size": 4.11328125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"articlewebview.hh\"\n#include <QMouseEvent>\n#include <QWebFrame>\n#include <QApplication>\n#include \"articleinspector.hh\"\n#include \"qt4x5.hh\"\n\n#ifdef Q_OS_WIN32\n#include <qt_windows.h>\n#endif\n\nArticleWebView::ArticleWebView( QWidget *parent ):\n  QWebView( parent ),\n#if QT_VERSION >= 0x040600\n  inspector( NULL ),\n#endif\n  midButtonPressed( false ),\n  selectionBySingleClick( false ),\n  showInspectorDirectly( true )\n{\n}\n\nArticleWebView::~ArticleWebView()\n{\n#if QT_VERSION >= 0x040600\n  if ( inspector )\n    inspector->deleteLater();\n#endif\n}\n\nvoid ArticleWebView::setUp( Config::Class * cfg )\n{\n  this->cfg = cfg;\n}\n\nvoid ArticleWebView::triggerPageAction( QWebPage::WebAction action, bool checked )\n{\n#if QT_VERSION >= 0x040600\n  if ( action == QWebPage::InspectElement )\n  {\n    // Get or create inspector instance for current view.\n    if ( !inspector )\n    {\n      inspector = new ArticleInspector( cfg );\n      inspector->setPage( page() );\n      connect( this, SIGNAL( destroyed() ), inspector, SLOT( beforeClosed() ) );\n    }\n\n    if ( showInspectorDirectly )\n    {\n      showInspectorDirectly = false;\n      // Bring up the inspector window and set focus\n      inspector->show();\n      inspector->activateWindow();\n      inspector->raise();\n      return;\n    }\n  }\n#endif\n\n  QWebView::triggerPageAction( action, checked );\n}\n\nbool ArticleWebView::event( QEvent * event )\n{\n  switch ( event->type() )\n  {\n  case QEvent::MouseButtonRelease:\n  case QEvent::MouseButtonDblClick:\n    showInspectorDirectly = true;\n    break;\n\n  case QEvent::ContextMenu:\n    showInspectorDirectly = false;\n    break;\n\n  default:\n    break;\n  }\n\n  return QWebView::event( event );\n}\n\nvoid ArticleWebView::mousePressEvent( QMouseEvent * event )\n{\n  if ( event->buttons() & Qt4x5::middleButton() )\n    midButtonPressed = true;\n\n  QWebView::mousePressEvent( event );\n\n  if ( selectionBySingleClick && ( event->buttons() & Qt::LeftButton ) )\n  {\n    findText(\"\"); // clear the selection first, if any\n    QMouseEvent ev( QEvent::MouseButtonDblClick, event->pos(), Qt::LeftButton, Qt::LeftButton, event->modifiers() );\n    QApplication::sendEvent( page(), &ev );\n  }\n}\n\nvoid ArticleWebView::mouseReleaseEvent( QMouseEvent * event )\n{\n  bool noMidButton = !( event->buttons() & Qt4x5::middleButton() );\n\n  QWebView::mouseReleaseEvent( event );\n\n  if ( midButtonPressed & noMidButton )\n    midButtonPressed = false;\n}\n\nvoid ArticleWebView::mouseDoubleClickEvent( QMouseEvent * event )\n{\n  QWebView::mouseDoubleClickEvent( event );\n#if QT_VERSION >= 0x040600\n  int scrollBarWidth = page()->mainFrame()->scrollBarGeometry( Qt::Vertical ).width();\n  int scrollBarHeight = page()->mainFrame()->scrollBarGeometry( Qt::Horizontal ).height();\n#else\n  int scrollBarWidth = 0;\n  int scrollBarHeight = 0;\n#endif\n\n  // emit the signal only if we are not double-clicking on scrollbars\n  if ( ( event->x() < width() - scrollBarWidth ) &&\n       ( event->y() < height() - scrollBarHeight ) )\n  {\n    emit doubleClicked( event->pos() );\n  }\n\n}\n\nvoid ArticleWebView::focusInEvent( QFocusEvent * event )\n{\n  QWebView::focusInEvent( event );\n\n  switch( event->reason() )\n  {\n    case Qt::MouseFocusReason:\n    case Qt::TabFocusReason:\n    case Qt::BacktabFocusReason:\n      page()->mainFrame()->evaluateJavaScript(\"top.focus();\");\n      break;\n\n    default:\n      break;\n  }\n}\n\nvoid ArticleWebView::wheelEvent( QWheelEvent *ev )\n{\n#ifdef Q_OS_WIN32\n\n  // Avoid wrong mouse wheel handling in QWebView\n  // if system preferences is set to \"scroll by page\"\n\n  if( ev->modifiers() == Qt::NoModifier )\n  {\n    unsigned nLines;\n    SystemParametersInfo( SPI_GETWHEELSCROLLLINES, 0, &nLines, 0 );\n    if( nLines == WHEEL_PAGESCROLL )\n    {\n      QKeyEvent kev( QEvent::KeyPress, ev->delta() > 0 ? Qt::Key_PageUp : Qt::Key_PageDown,\n                     Qt::NoModifier );\n      QApplication::sendEvent( this, &kev );\n\n      ev->accept();\n      return;\n    }\n  }\n#endif\n\n  if ( ev->modifiers().testFlag( Qt::ControlModifier ) )\n  {\n     ev->ignore();\n  }\n  else\n  {\n     QWebView::wheelEvent( ev );\n  }\n\n}\n"
        },
        {
          "name": "articlewebview.hh",
          "type": "blob",
          "size": 2.0166015625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __ARTICLEWEBVIEW_HH_INCLUDED__\n#define __ARTICLEWEBVIEW_HH_INCLUDED__\n\n#include <QWebView>\n#include \"config.hh\"\n\nclass ArticleInspector;\n\n/// A thin wrapper around QWebView to accommodate to some ArticleView's needs.\n/// Currently the only added features:\n/// 1. Ability to know if the middle mouse button is pressed or not according\n///    to the view's current state. This is used to open links in new tabs when\n///    they are clicked with middle button. There's also an added possibility to\n///    get double-click events after the fact with the doubleClicked() signal.\n/// 2. Manage our own QWebInspector instance. In order to show inspector correctly,\n///    use triggerPageAction( QWebPage::InspectElement ) instead.\nclass ArticleWebView: public QWebView\n{\n  Q_OBJECT\n\npublic:\n\n  ArticleWebView( QWidget * parent );\n  ~ArticleWebView();\n\n  void setUp( Config::Class * cfg );\n\n  bool isMidButtonPressed() const\n  { return midButtonPressed; }\n  void setSelectionBySingleClick( bool set )\n  { selectionBySingleClick = set; }\n\n  void triggerPageAction( QWebPage::WebAction action, bool checked = false );\n\nsignals:\n\n  /// Signals that the user has just double-clicked. The signal is delivered\n  /// after the event was processed by the view -- that's the difference from\n  /// installing an event filter. This is used for translating the double-clicked\n  /// word, which gets selected by the view in response to double-click.\n  void doubleClicked( QPoint pos );\n\nprotected:\n\n  bool event( QEvent * event );\n  void mousePressEvent( QMouseEvent * event );\n  void mouseReleaseEvent( QMouseEvent * event );\n  void mouseDoubleClickEvent( QMouseEvent * event );\n  void focusInEvent( QFocusEvent * event );\n  void wheelEvent( QWheelEvent * event );\n\nprivate:\n\n  Config::Class * cfg;\n  ArticleInspector * inspector;\n\n  bool midButtonPressed;\n  bool selectionBySingleClick;\n  bool showInspectorDirectly;\n};\n\n#endif\n"
        },
        {
          "name": "atomic_rename.cc",
          "type": "blob",
          "size": 1.0869140625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"atomic_rename.hh\"\n#include <QtGlobal>\n#include <QVector>\n#include <string> // for wchar_t\n#include <QFile>\n#include <QDir>\n\n#ifdef Q_OS_WIN32\n#include <windows.h>\n#endif\n\n#include <stdio.h>\n\n\nbool renameAtomically( QString const & oldName, QString const & newName )\n{\n#ifdef Q_OS_WIN32\n\n  QString srcFile( QDir::toNativeSeparators( oldName ) );\n  QVector< wchar_t > srcFileW( srcFile.size() + 1 );\n  srcFileW[ srcFile.toWCharArray( srcFileW.data() ) ] = 0;\n\n  QString destFile( QDir::toNativeSeparators( newName ) );\n  QVector< wchar_t > destFileW( destFile.size() + 1 );\n  destFileW[ destFile.toWCharArray( destFileW.data() ) ] = 0;\n\n  if ( !MoveFileExW( srcFileW.data(), destFileW.data(),  MOVEFILE_REPLACE_EXISTING ) )\n    return false;\n\n#else\n\n  if ( rename( QFile::encodeName( QDir::toNativeSeparators( oldName ) ).data(),\n               QFile::encodeName( QDir::toNativeSeparators( newName ) ).data() ) )\n    return false;\n\n#endif\n\n  return true;\n}\n"
        },
        {
          "name": "atomic_rename.hh",
          "type": "blob",
          "size": 0.53125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __ATOMIC_RENAME_HH_INCLUDED__\n#define __ATOMIC_RENAME_HH_INCLUDED__\n\n#include <QString>\n\n/// Performs an atomic rename of file, from oldBame to newName. If newName\n/// exists, it gets overwritten. Names should feature Qt-style separators\n/// (straight slashes). Returns true on success, false on failure.\nbool renameAtomically( QString const & oldName, QString const & newName );\n\n#endif\n"
        },
        {
          "name": "audiolink.cc",
          "type": "blob",
          "size": 1.1376953125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"audiolink.hh\"\n\nstd::string addAudioLink( std::string const & url,\n                          std::string const & dictionaryId )\n{\n    return std::string( \"<script type=\\\"text/javascript\\\">\" +\n                        makeAudioLinkScript( url, dictionaryId ) +\n                        \"</script>\" );\n}\n\nstd::string makeAudioLinkScript( std::string const & url,\n                                 std::string const & dictionaryId )\n{\n  /// Convert \"'\" to \"\\'\" - this char broke autoplay of audiolinks\n\n  std::string ref;\n  bool escaped = false;\n  for( unsigned x = 0; x < url.size(); x++ )\n  {\n    char ch = url[ x ];\n    if( escaped )\n    {\n      ref += ch;\n      escaped = false;\n      continue;\n    }\n    if( ch == '\\'' )\n      ref += '\\\\';\n    ref += ch;\n    escaped = ( ch == '\\\\' );\n  }\n\n  std::string audioLinkForDict = \"gdAudioLinks['\" + dictionaryId + \"']\";\n  return \"gdAudioLinks.first = gdAudioLinks.first || \" + ref + \";\" +\n         audioLinkForDict + \" = \" + audioLinkForDict + \" || \" + ref + \";\";\n}\n"
        },
        {
          "name": "audiolink.hh",
          "type": "blob",
          "size": 0.7666015625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __AUDIOLINK_HH_INCLUDED__\n#define __AUDIOLINK_HH_INCLUDED__\n\n\n#include <string>\n\n/// Adds a piece of javascript to save the given audiolink to a special\n/// javascript variable. Embed this into article's html to enable the\n/// 'say sound' functionality.\n/// The url should be escaped and surrounded by quotes.\n/// The dictionary id is used to make active dictionary feature work.\nstd::string addAudioLink( std::string const & url,\n                          std::string const & dictionaryId );\n\nstd::string makeAudioLinkScript( std::string const & url,\n                                 std::string const & dictionaryId );\n\n#endif\n"
        },
        {
          "name": "audioplayerfactory.cc",
          "type": "blob",
          "size": 2.66796875,
          "content": "/* This file is (c) 2018 Igor Kushnir <igorkuo@gmail.com>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include <QScopedPointer>\n#include <QObject>\n#include \"audioplayerfactory.hh\"\n#include \"ffmpegaudioplayer.hh\"\n#include \"multimediaaudioplayer.hh\"\n#include \"externalaudioplayer.hh\"\n#include \"gddebug.hh\"\n\nAudioPlayerFactory::AudioPlayerFactory( Config::Preferences const & p ) :\n  useInternalPlayer( p.useInternalPlayer ),\n  internalPlayerBackend( p.internalPlayerBackend ),\n  audioPlaybackProgram( p.audioPlaybackProgram )\n{\n  reset();\n}\n\nvoid AudioPlayerFactory::setPreferences( Config::Preferences const & p )\n{\n  if( p.useInternalPlayer != useInternalPlayer )\n  {\n    useInternalPlayer = p.useInternalPlayer;\n    internalPlayerBackend = p.internalPlayerBackend;\n    audioPlaybackProgram = p.audioPlaybackProgram;\n    reset();\n  }\n  else\n  if( useInternalPlayer && p.internalPlayerBackend != internalPlayerBackend )\n  {\n    internalPlayerBackend = p.internalPlayerBackend;\n    reset();\n  }\n  else\n  if( !useInternalPlayer && p.audioPlaybackProgram != audioPlaybackProgram )\n  {\n    audioPlaybackProgram = p.audioPlaybackProgram;\n    ExternalAudioPlayer * const externalPlayer =\n        qobject_cast< ExternalAudioPlayer * >( playerPtr.data() );\n    if( externalPlayer )\n      setAudioPlaybackProgram( *externalPlayer );\n    else\n      gdWarning( \"External player was expected, but it does not exist.\\n\" );\n  }\n}\n\nvoid AudioPlayerFactory::reset()\n{\n  if( useInternalPlayer )\n  {\n    // qobject_cast checks below account for the case when an unsupported backend\n    // is stored in config. After this backend is replaced with the default one\n    // upon preferences saving, the code below does not reset playerPtr with\n    // another object of the same type.\n\n#ifdef MAKE_FFMPEG_PLAYER\n    Q_ASSERT( Config::InternalPlayerBackend::defaultBackend().isFfmpeg()\n              && \"Adjust the code below after changing the default backend.\" );\n\n    if( !internalPlayerBackend.isQtmultimedia() )\n    {\n      if( !playerPtr || !qobject_cast< Ffmpeg::AudioPlayer * >( playerPtr.data() ) )\n        playerPtr.reset( new Ffmpeg::AudioPlayer );\n      return;\n    }\n#endif\n\n#ifdef MAKE_QTMULTIMEDIA_PLAYER\n    if( !playerPtr || !qobject_cast< MultimediaAudioPlayer * >( playerPtr.data() ) )\n      playerPtr.reset( new MultimediaAudioPlayer );\n    return;\n#endif\n  }\n\n  QScopedPointer< ExternalAudioPlayer > externalPlayer( new ExternalAudioPlayer );\n  setAudioPlaybackProgram( *externalPlayer );\n  playerPtr.reset( externalPlayer.take() );\n}\n\nvoid AudioPlayerFactory::setAudioPlaybackProgram( ExternalAudioPlayer & externalPlayer )\n{\n  externalPlayer.setPlayerCommandLine( audioPlaybackProgram.trimmed() );\n}\n"
        },
        {
          "name": "audioplayerfactory.hh",
          "type": "blob",
          "size": 1.044921875,
          "content": "/* This file is (c) 2018 Igor Kushnir <igorkuo@gmail.com>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef AUDIOPLAYERFACTORY_HH_INCLUDED\n#define AUDIOPLAYERFACTORY_HH_INCLUDED\n\n#include \"audioplayerinterface.hh\"\n#include \"config.hh\"\n\nclass ExternalAudioPlayer;\n\nclass AudioPlayerFactory\n{\n  Q_DISABLE_COPY( AudioPlayerFactory )\npublic:\n  explicit AudioPlayerFactory( Config::Preferences const & );\n  void setPreferences( Config::Preferences const & );\n  /// The returned reference to a smart pointer is valid as long as this object\n  /// exists. The pointer to the owned AudioPlayerInterface may change after the\n  /// call to setPreferences(), but it is guaranteed to never be null.\n  AudioPlayerPtr const & player() const { return playerPtr; }\n\nprivate:\n  void reset();\n  void setAudioPlaybackProgram( ExternalAudioPlayer & externalPlayer );\n\n  bool useInternalPlayer;\n  Config::InternalPlayerBackend internalPlayerBackend;\n  QString audioPlaybackProgram;\n  AudioPlayerPtr playerPtr;\n};\n\n#endif // AUDIOPLAYERFACTORY_HH_INCLUDED\n"
        },
        {
          "name": "audioplayerinterface.hh",
          "type": "blob",
          "size": 0.9208984375,
          "content": "/* This file is (c) 2018 Igor Kushnir <igorkuo@gmail.com>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef AUDIOPLAYERINTERFACE_HH_INCLUDED\n#define AUDIOPLAYERINTERFACE_HH_INCLUDED\n\n#include <QScopedPointer>\n#include <QString>\n#include <QObject>\n\nclass AudioPlayerInterface : public QObject\n{\n  Q_OBJECT\npublic:\n  /// Stops current playback if any, copies the audio buffer at [data, data + size),\n  /// then plays this buffer. It is safe to invalidate \\p data after this function call.\n  /// Returns an error message in case of immediate failure; an empty string\n  /// in case of success.\n  virtual QString play( const char * data, int size ) = 0;\n  /// Stops current playback if any.\n  virtual void stop() = 0;\n\nsignals:\n  /// Notifies of asynchronous errors.\n  void error( QString message );\n};\n\ntypedef QScopedPointer< AudioPlayerInterface > AudioPlayerPtr;\n\n#endif // AUDIOPLAYERINTERFACE_HH_INCLUDED\n"
        },
        {
          "name": "authentication.ui",
          "type": "blob",
          "size": 2.6064453125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ui version=\"4.0\">\n <class>Dialog</class>\n <widget class=\"QDialog\" name=\"Dialog\">\n  <property name=\"geometry\">\n   <rect>\n    <x>0</x>\n    <y>0</y>\n    <width>389</width>\n    <height>120</height>\n   </rect>\n  </property>\n  <property name=\"windowTitle\">\n   <string>Proxy authentication required</string>\n  </property>\n  <layout class=\"QGridLayout\">\n   <item row=\"0\" column=\"0\" colspan=\"2\">\n    <widget class=\"QLabel\" name=\"label\">\n     <property name=\"text\">\n      <string>You need to supply a Username and a Password to access via proxy</string>\n     </property>\n     <property name=\"wordWrap\">\n      <bool>false</bool>\n     </property>\n    </widget>\n   </item>\n   <item row=\"1\" column=\"0\">\n    <widget class=\"QLabel\" name=\"label_2\">\n     <property name=\"text\">\n      <string>Username:</string>\n     </property>\n    </widget>\n   </item>\n   <item row=\"1\" column=\"1\">\n    <widget class=\"QLineEdit\" name=\"userEdit\"/>\n   </item>\n   <item row=\"2\" column=\"0\">\n    <widget class=\"QLabel\" name=\"label_3\">\n     <property name=\"text\">\n      <string>Password:</string>\n     </property>\n    </widget>\n   </item>\n   <item row=\"2\" column=\"1\">\n    <widget class=\"QLineEdit\" name=\"passwordEdit\">\n     <property name=\"echoMode\">\n      <enum>QLineEdit::Password</enum>\n     </property>\n    </widget>\n   </item>\n   <item row=\"4\" column=\"0\" colspan=\"2\">\n    <widget class=\"QDialogButtonBox\" name=\"buttonBox\">\n     <property name=\"orientation\">\n      <enum>Qt::Horizontal</enum>\n     </property>\n     <property name=\"standardButtons\">\n      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>\n     </property>\n    </widget>\n   </item>\n   <item row=\"3\" column=\"0\">\n    <spacer>\n     <property name=\"orientation\">\n      <enum>Qt::Vertical</enum>\n     </property>\n     <property name=\"sizeHint\" stdset=\"0\">\n      <size>\n       <width>20</width>\n       <height>40</height>\n      </size>\n     </property>\n    </spacer>\n   </item>\n  </layout>\n </widget>\n <resources/>\n <connections>\n  <connection>\n   <sender>buttonBox</sender>\n   <signal>accepted()</signal>\n   <receiver>Dialog</receiver>\n   <slot>accept()</slot>\n   <hints>\n    <hint type=\"sourcelabel\">\n     <x>248</x>\n     <y>254</y>\n    </hint>\n    <hint type=\"destinationlabel\">\n     <x>157</x>\n     <y>274</y>\n    </hint>\n   </hints>\n  </connection>\n  <connection>\n   <sender>buttonBox</sender>\n   <signal>rejected()</signal>\n   <receiver>Dialog</receiver>\n   <slot>reject()</slot>\n   <hints>\n    <hint type=\"sourcelabel\">\n     <x>316</x>\n     <y>260</y>\n    </hint>\n    <hint type=\"destinationlabel\">\n     <x>286</x>\n     <y>274</y>\n    </hint>\n   </hints>\n  </connection>\n </connections>\n</ui>\n"
        },
        {
          "name": "belarusiantranslit.cc",
          "type": "blob",
          "size": 36.544921875,
          "content": "/* This file is (c) 2013 Maksim Tamkovicz <quendimax@gmail.com>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"belarusiantranslit.hh\"\n#include \"transliteration.hh\"\n#include <QCoreApplication>\n\nnamespace BelarusianTranslit {\n\nclass BelarusianLatinToClassicTable: public Transliteration::Table\n{\npublic:\n  BelarusianLatinToClassicTable()\n  {\n    // Utf8ins()\n\n    // latin to cyrillic\n    ins( \"a\", \"а\" );\n    ins( \"b\", \"б\" );\n    ins( \"c\", \"ц\" );\n    ins( \"ć\", \"ць\" );\n    ins( \"č\", \"ч\" );\n    ins( \"cz\", \"ч\" );\n    ins( \"d\", \"д\" );\n    ins( \"e\", \"э\" );\n    ins( \"f\", \"ф\" );\n    ins( \"g\", \"ґ\" );\n    ins( \"h\", \"г\" );\n    ins( \"i\", \"і\" );\n    ins( \"j\", \"й\" );\n    ins( \"k\", \"к\" );\n    ins( \"l\", \"ль\" );\n    ins( \"ł\", \"л\" );\n    ins( \"m\", \"м\" );\n    ins( \"n\", \"н\" );\n    ins( \"ń\", \"нь\" );\n    ins( \"o\", \"о\" );\n    ins( \"p\", \"п\" );\n    ins( \"r\", \"р\" );\n    ins( \"s\", \"с\" );\n    ins( \"ś\", \"сь\" );\n    ins( \"š\", \"ш\" );\n    ins( \"sz\", \"ш\" );\n    ins( \"t\", \"т\" );\n    ins( \"u\", \"у\" );\n    ins( \"ŭ\", \"ў\" );\n    ins( \"v\", \"в\" );\n    ins( \"w\", \"в\" );\n    ins( \"y\", \"ы\" );\n    ins( \"z\", \"з\" );\n    ins( \"ź\", \"зь\" );\n    ins( \"ž\", \"ж\" );\n    ins( \"ż\", \"ж\" );\n    ins( \"ch\", \"х\" );\n\n    ins( \"ja\", \"я\" );   ins( \"je\", \"е\" );   ins( \"jo\", \"ё\" );   ins( \"ju\", \"ю\" );\n    ins( \"la\", \"ля\" );  ins( \"le\", \"ле\" );  ins( \"lo\", \"лё\" );  ins( \"lu\", \"лю\" );  ins( \"li\", \"лі\" );\n\n    ins( \"bia\", \"бя\" );  ins( \"bie\", \"бе\" );  ins( \"bio\", \"бё\" );  ins( \"biu\", \"бю\" );\n    ins( \"cia\", \"ця\" );  ins( \"cie\", \"це\" );  ins( \"cio\", \"цё\" );  ins( \"ciu\", \"цю\" );\n    ins( \"dzia\",\"дзя\" ); ins( \"dzie\",\"дзе\" ); ins( \"dzio\",\"дзё\" ); ins( \"dziu\",\"дзю\" );\n    ins( \"fia\", \"фя\" );  ins( \"fie\", \"фе\" );  ins( \"fio\", \"фё\" );  ins( \"fiu\", \"фю\" );\n    ins( \"gia\", \"ґя\" );  ins( \"gie\", \"ґе\" );  ins( \"gio\", \"ґё\" );  ins( \"giu\", \"ґю\" );\n    ins( \"hia\", \"гя\" );  ins( \"hie\", \"ге\" );  ins( \"hio\", \"гё\" );  ins( \"hiu\", \"гю\" );\n    ins( \"kia\", \"кя\" );  ins( \"kie\", \"ке\" );  ins( \"kio\", \"кё\" );  ins( \"kiu\", \"кю\" );\n    ins( \"lia\", \"ліa\" ); ins( \"lie\", \"ліэ\" ); ins( \"lio\", \"ліо\" ); ins( \"liu\", \"ліу\" );\n    ins( \"mia\", \"мя\" );  ins( \"mie\", \"ме\" );  ins( \"mio\", \"мё\" );  ins( \"miu\", \"мю\" );\n    ins( \"nia\", \"ня\" );  ins( \"nie\", \"не\" );  ins( \"nio\", \"нё\" );  ins( \"niu\", \"ню\" );\n    ins( \"pia\", \"пя\" );  ins( \"pie\", \"пе\" );  ins( \"pio\", \"пё\" );  ins( \"piu\", \"пю\" );\n    ins( \"sia\", \"ся\" );  ins( \"sie\", \"се\" );  ins( \"sio\", \"сё\" );  ins( \"siu\", \"сю\" );\n    ins( \"via\", \"вя\" );  ins( \"vie\", \"ве\" );  ins( \"vio\", \"вё\" );  ins( \"viu\", \"вю\" );\n    ins( \"wia\", \"вя\" );  ins( \"wie\", \"ве\" );  ins( \"wio\", \"вё\" );  ins( \"wiu\", \"вю\" );\n    ins( \"zia\", \"зя\" );  ins( \"zie\", \"зе\" );  ins( \"zio\", \"зё\" );  ins( \"ziu\", \"зю\" );\n    ins( \"chia\", \"хя\" ); ins( \"chie\", \"хе\" ); ins( \"chio\", \"хё\" ); ins( \"chiu\", \"хю\" );\n\n    ins( \"bja\", \"б'я\" );  ins( \"bje\", \"б'е\" );  ins( \"bjo\", \"б'ё\" );  ins( \"bju\", \"б'ю\" );\n    ins( \"cia\", \"ц'я\" );  ins( \"cje\", \"ц'е\" );  ins( \"cjo\", \"ц'ё\" );  ins( \"cju\", \"ц'ю\" );\n    ins( \"fja\", \"ф'я\" );  ins( \"fje\", \"ф'е\" );  ins( \"fjo\", \"ф'ё\" );  ins( \"fju\", \"ф'ю\" );\n    ins( \"hja\", \"г'я\" );  ins( \"hje\", \"г'е\" );  ins( \"hjo\", \"г'ё\" );  ins( \"hju\", \"г'ю\" );\n    ins( \"kja\", \"к'я\" );  ins( \"kje\", \"к'е\" );  ins( \"kjo\", \"к'ё\" );  ins( \"kju\", \"к'ю\" );\n    ins( \"łja\", \"л'я\" );  ins( \"łje\", \"л'е\" );  ins( \"łjo\", \"л'ё\" );  ins( \"łju\", \"л'ю\" );\n    ins( \"mja\", \"м'я\" );  ins( \"mje\", \"м'е\" );  ins( \"mjo\", \"м'ё\" );  ins( \"mju\", \"м'ю\" );\n    ins( \"nja\", \"н'я\" );  ins( \"nje\", \"н'е\" );  ins( \"njo\", \"н'ё\" );  ins( \"nju\", \"н'ю\" );\n    ins( \"pja\", \"п'я\" );  ins( \"pje\", \"п'е\" );  ins( \"pjo\", \"п'ё\" );  ins( \"pju\", \"п'ю\" );\n    ins( \"sja\", \"с'я\" );  ins( \"sje\", \"с'е\" );  ins( \"sjo\", \"с'ё\" );  ins( \"sju\", \"с'ю\" );\n    ins( \"vja\", \"в'я\" );  ins( \"vje\", \"в'е\" );  ins( \"vjo\", \"в'ё\" );  ins( \"vju\", \"в'ю\" );\n    ins( \"wja\", \"в'я\" );  ins( \"wje\", \"в'е\" );  ins( \"wjo\", \"в'ё\" );  ins( \"wju\", \"в'ю\" );\n    ins( \"zja\", \"з'я\" );  ins( \"zje\", \"з'е\" );  ins( \"zjo\", \"з'ё\" );  ins( \"zju\", \"з'ю\" );\n    ins( \"chja\", \"х'я\" ); ins( \"chje\", \"х'е\" ); ins( \"chjo\", \"х'ё\" ); ins( \"chju\", \"х'ю\" );\n\n    ins( \"nnia\", \"ньня\" );  ins( \"nnie\", \"ньне\" );  ins( \"nnio\", \"ньнё\" );  ins( \"nniu\", \"ньню\" );ins( \"nni\", \"ньні\" );\n\n    // cyrillic to latin\n    ins( \"а\", \"a\" );   ins( \"б\", \"b\" );   ins( \"в\", \"v\" );   ins( \"г\", \"h\" );\n    ins( \"ґ\", \"g\" );   ins( \"д\", \"d\" );   ins( \"е\", \"je\" );  ins( \"ё\", \"jo\" );\n    ins( \"ж\", \"ž\" );   ins( \"з\", \"z\" );   ins( \"і\", \"i\" );   ins( \"ї\", \"ï\" );\n    ins( \"й\", \"j\" );   ins( \"к\", \"k\" );   ins( \"л\", \"ł\" );   ins( \"м\", \"m\" );\n    ins( \"н\", \"n\" );   ins( \"о\", \"o\" );   ins( \"п\", \"p\" );   ins( \"р\", \"r\" );\n    ins( \"с\", \"s\" );   ins( \"т\", \"t\" );   ins( \"у\", \"u\" );   ins( \"ў\", \"ŭ\" );\n    ins( \"ф\", \"f\" );   ins( \"х\", \"ch\" );  ins( \"ц\", \"c\" );   ins( \"ч\", \"č\" );\n    ins( \"ш\", \"š\" );   ins( \"ы\", \"y\" );   ins( \"э\", \"e\" );   ins( \"ю\", \"ju\" );\n    ins( \"я\", \"ja\" );  ins( \"кг\", \"g\" );\n    ins( \"бе\", \"bie\" );  ins( \"бё\", \"bio\" );  ins( \"бю\", \"biu\" );  ins( \"бя\", \"bia\" );\n    ins( \"ве\", \"vie\" );  ins( \"вё\", \"vio\" );  ins( \"вю\", \"viu\" );  ins( \"вя\", \"via\" );\n    ins( \"ге\", \"hie\" );  ins( \"гё\", \"hio\" );  ins( \"гю\", \"hiu\" );  ins( \"гя\", \"hia\" );\n    ins( \"ґе\", \"gie\" );  ins( \"ґё\", \"gio\" );  ins( \"ґю\", \"giu\" );  ins( \"ґя\", \"gia\" );\n    ins( \"кге\", \"gie\" ); ins( \"кгё\", \"gio\" ); ins( \"кгю\", \"giu\" ); ins( \"кгя\", \"gia\" );\n    ins( \"зе\", \"zie\" );  ins( \"зё\", \"zio\" );  ins( \"зю\", \"ziu\" );  ins( \"зя\", \"zia\" );  ins( \"зь\", \"ź\" );\n    ins( \"ке\", \"kie\" );  ins( \"кё\", \"kio\" );  ins( \"кю\", \"kiu\" );  ins( \"кя\", \"kia\" );\n    ins( \"ле\", \"le\" );   ins( \"лё\", \"lo\" );   ins( \"лю\", \"lu\" );   ins( \"ля\", \"la\" );   ins( \"ль\", \"l\" );   ins( \"лі\", \"li\" );\n    ins( \"ме\", \"mie\" );  ins( \"мё\", \"mio\" );  ins( \"мю\", \"miu\" );  ins( \"мя\", \"mia\" );  ins( \"мь\", \"m\" );\n    ins( \"не\", \"nie\" );  ins( \"нё\", \"nio\" );  ins( \"ню\", \"niu\" );  ins( \"ня\", \"nia\" );  ins( \"нь\", \"ń\" );\n    ins( \"пе\", \"pie\" );  ins( \"пё\", \"pio\" );  ins( \"пю\", \"piu\" );  ins( \"пя\", \"pia\" );  ins( \"пь\", \"p\" );\n    ins( \"се\", \"sie\" );  ins( \"сё\", \"sio\" );  ins( \"сю\", \"siu\" );  ins( \"ся\", \"sia\" );  ins( \"сь\", \"ś\" );\n    ins( \"фе\", \"fie\" );  ins( \"фё\", \"fio\" );  ins( \"фю\", \"fiu\" );  ins( \"фя\", \"fia\" );  ins( \"фь\", \"f\" );\n    ins( \"хе\", \"chie\" ); ins( \"хё\", \"chio\" ); ins( \"хю\", \"chiu\" ); ins( \"хя\", \"chia\" );\n    ins( \"це\", \"cie\" );  ins( \"цё\", \"cio\" );  ins( \"цю\", \"ciu\" );  ins( \"ця\", \"cia\" );  ins( \"ць\", \"ć\" );\n    ins( \"бʼ\", \"b\" );    ins( \"б'\", \"b\" );    ins( \"б’\", \"b\" );\n    ins( \"вʼ\", \"v\" );    ins( \"в'\", \"v\" );    ins( \"в’\", \"v\" );\n    ins( \"гʼ\", \"h\" );    ins( \"г'\", \"h\" );    ins( \"г’\", \"h\" );\n    ins( \"ґʼ\", \"g\" );    ins( \"ґ'\", \"g\" );    ins( \"ґ’\", \"g\" );\n    ins( \"дʼ\", \"d\" );    ins( \"д'\", \"d\" );    ins( \"д’\", \"d\" );\n    ins( \"жʼ\", \"ž\" );    ins( \"ж'\", \"ž\" );    ins( \"ж’\", \"ž\" );\n    ins( \"зʼ\", \"z\" );    ins( \"з'\", \"z\" );    ins( \"з’\", \"z\" );\n    ins( \"кʼ\", \"k\" );    ins( \"к'\", \"k\" );    ins( \"к’\", \"k\" );\n    ins( \"лʼ\", \"ł\" );    ins( \"л'\", \"ł\" );    ins( \"л’\", \"ł\" );\n    ins( \"мʼ\", \"m\" );    ins( \"м'\", \"m\" );    ins( \"м’\", \"m\" );\n    ins( \"нʼ\", \"n\" );    ins( \"н'\", \"n\" );    ins( \"н’\", \"n\" );\n    ins( \"пʼ\", \"p\" );    ins( \"п'\", \"p\" );    ins( \"п’\", \"p\" );\n    ins( \"рʼ\", \"r\" );    ins( \"р'\", \"r\" );    ins( \"р’\", \"r\" );\n    ins( \"сʼ\", \"s\" );    ins( \"с'\", \"s\" );    ins( \"с’\", \"s\" );\n    ins( \"тʼ\", \"t\" );    ins( \"т'\", \"t\" );    ins( \"т’\", \"t\" );\n    ins( \"фʼ\", \"f\" );    ins( \"ф'\", \"f\" );    ins( \"ф’\", \"f\" );\n    ins( \"хʼ\", \"ch\" );   ins( \"х'\", \"ch\" );   ins( \"х’\", \"ch\" );\n    ins( \"цʼ\", \"c\" );    ins( \"ц'\", \"c\" );    ins( \"ц’\", \"c\" );\n    ins( \"чʼ\", \"č\" );    ins( \"ч'\", \"č\" );    ins( \"ч’\", \"č\" );\n    ins( \"шʼ\", \"š\" );    ins( \"ш'\", \"š\" );    ins( \"ш’\", \"š\" );\n  }\n};\n\nclass BelarusianLatinToSchoolTable: public Transliteration::Table\n{\npublic:\n  BelarusianLatinToSchoolTable()\n  {\n    // Utf8ins()\n\n    // latin to cyrillic\n    ins( \"a\", \"а\" );\n    ins( \"b\", \"б\" );\n    ins( \"c\", \"ц\" );\n    ins( \"ć\", \"ць\" );\n    ins( \"č\", \"ч\" );\n    ins( \"cz\", \"ч\" );\n    ins( \"d\", \"д\" );\n    ins( \"e\", \"э\" );\n    ins( \"f\", \"ф\" );\n    ins( \"g\", \"г\" );\n    ins( \"h\", \"г\" );\n    ins( \"i\", \"і\" );\n    ins( \"j\", \"й\" );\n    ins( \"k\", \"к\" );\n    ins( \"l\", \"ль\" );\n    ins( \"ł\", \"л\" );\n    ins( \"m\", \"м\" );\n    ins( \"n\", \"н\" );\n    ins( \"ń\", \"нь\" );\n    ins( \"o\", \"о\" );\n    ins( \"p\", \"п\" );\n    ins( \"r\", \"р\" );\n    ins( \"s\", \"с\" );\n    ins( \"ś\", \"сь\" );\n    ins( \"š\", \"ш\" );\n    ins( \"sz\", \"ш\" );\n    ins( \"t\", \"т\" );\n    ins( \"u\", \"у\" );\n    ins( \"ŭ\", \"ў\" );\n    ins( \"v\", \"в\" );\n    ins( \"w\", \"в\" );\n    ins( \"y\", \"ы\" );\n    ins( \"z\", \"з\" );\n    ins( \"ź\", \"зь\" );\n    ins( \"ž\", \"ж\" );\n    ins( \"ż\", \"ж\" );\n    ins( \"ch\", \"х\" );\n\n    ins( \"ja\", \"я\" );   ins( \"je\", \"е\" );   ins( \"jo\", \"ё\" );   ins( \"ju\", \"ю\" );\n    ins( \"la\", \"ля\" );  ins( \"le\", \"ле\" );  ins( \"lo\", \"лё\" );  ins( \"lu\", \"лю\" );  ins( \"li\", \"лі\" );\n\n    ins( \"bia\", \"бя\" );  ins( \"bie\", \"бе\" );  ins( \"bio\", \"бё\" );  ins( \"biu\", \"бю\" );\n    ins( \"cia\", \"ця\" );  ins( \"cie\", \"це\" );  ins( \"cio\", \"цё\" );  ins( \"ciu\", \"цю\" );\n    ins( \"dzia\",\"дзя\" ); ins( \"dzie\",\"дзе\" ); ins( \"dzio\",\"дзё\" ); ins( \"dziu\",\"дзю\" );\n    ins( \"fia\", \"фя\" );  ins( \"fie\", \"фе\" );  ins( \"fio\", \"фё\" );  ins( \"fiu\", \"фю\" );\n    ins( \"gia\", \"гя\" );  ins( \"gie\", \"ге\" );  ins( \"gio\", \"гё\" );  ins( \"giu\", \"гю\" );\n    ins( \"hia\", \"гя\" );  ins( \"hie\", \"ге\" );  ins( \"hio\", \"гё\" );  ins( \"hiu\", \"гю\" );\n    ins( \"kia\", \"кя\" );  ins( \"kie\", \"ке\" );  ins( \"kio\", \"кё\" );  ins( \"kiu\", \"кю\" );\n    ins( \"lia\", \"ліa\" ); ins( \"lie\", \"ліэ\" ); ins( \"lio\", \"ліо\" ); ins( \"liu\", \"ліу\" );\n    ins( \"mia\", \"мя\" );  ins( \"mie\", \"ме\" );  ins( \"mio\", \"мё\" );  ins( \"miu\", \"мю\" );\n    ins( \"nia\", \"ня\" );  ins( \"nie\", \"не\" );  ins( \"nio\", \"нё\" );  ins( \"niu\", \"ню\" );\n    ins( \"pia\", \"пя\" );  ins( \"pie\", \"пе\" );  ins( \"pio\", \"пё\" );  ins( \"piu\", \"пю\" );\n    ins( \"sia\", \"ся\" );  ins( \"sie\", \"се\" );  ins( \"sio\", \"сё\" );  ins( \"siu\", \"сю\" );\n    ins( \"via\", \"вя\" );  ins( \"vie\", \"ве\" );  ins( \"vio\", \"вё\" );  ins( \"viu\", \"вю\" );\n    ins( \"wia\", \"вя\" );  ins( \"wie\", \"ве\" );  ins( \"wio\", \"вё\" );  ins( \"wiu\", \"вю\" );\n    ins( \"zia\", \"зя\" );  ins( \"zie\", \"зе\" );  ins( \"zio\", \"зё\" );  ins( \"ziu\", \"зю\" );\n    ins( \"chia\", \"хя\" ); ins( \"chie\", \"хе\" ); ins( \"chio\", \"хё\" ); ins( \"chiu\", \"хю\" );\n\n    ins( \"bja\", \"б'я\" );  ins( \"bje\", \"б'е\" );  ins( \"bjo\", \"б'ё\" );  ins( \"bju\", \"б'ю\" );\n    ins( \"cia\", \"ц'я\" );  ins( \"cje\", \"ц'е\" );  ins( \"cjo\", \"ц'ё\" );  ins( \"cju\", \"ц'ю\" );\n    ins( \"fja\", \"ф'я\" );  ins( \"fje\", \"ф'е\" );  ins( \"fjo\", \"ф'ё\" );  ins( \"fju\", \"ф'ю\" );\n    ins( \"hja\", \"г'я\" );  ins( \"hje\", \"г'е\" );  ins( \"hjo\", \"г'ё\" );  ins( \"hju\", \"г'ю\" );\n    ins( \"kja\", \"к'я\" );  ins( \"kje\", \"к'е\" );  ins( \"kjo\", \"к'ё\" );  ins( \"kju\", \"к'ю\" );\n    ins( \"łja\", \"л'я\" );  ins( \"łje\", \"л'е\" );  ins( \"łjo\", \"л'ё\" );  ins( \"łju\", \"л'ю\" );\n    ins( \"mja\", \"м'я\" );  ins( \"mje\", \"м'е\" );  ins( \"mjo\", \"м'ё\" );  ins( \"mju\", \"м'ю\" );\n    ins( \"nja\", \"н'я\" );  ins( \"nje\", \"н'е\" );  ins( \"njo\", \"н'ё\" );  ins( \"nju\", \"н'ю\" );\n    ins( \"pja\", \"п'я\" );  ins( \"pje\", \"п'е\" );  ins( \"pjo\", \"п'ё\" );  ins( \"pju\", \"п'ю\" );\n    ins( \"sja\", \"с'я\" );  ins( \"sje\", \"с'е\" );  ins( \"sjo\", \"с'ё\" );  ins( \"sju\", \"с'ю\" );\n    ins( \"vja\", \"в'я\" );  ins( \"vje\", \"в'е\" );  ins( \"vjo\", \"в'ё\" );  ins( \"vju\", \"в'ю\" );\n    ins( \"wja\", \"в'я\" );  ins( \"wje\", \"в'е\" );  ins( \"wjo\", \"в'ё\" );  ins( \"wju\", \"в'ю\" );\n    ins( \"zja\", \"з'я\" );  ins( \"zje\", \"з'е\" );  ins( \"zjo\", \"з'ё\" );  ins( \"zju\", \"з'ю\" );\n    ins( \"źja\", \"з'я\" );  ins( \"źje\", \"з'е\" );  ins( \"źjo\", \"з'ё\" );  ins( \"źju\", \"з'ю\" );\n    ins( \"chja\", \"х'я\" ); ins( \"chje\", \"х'е\" ); ins( \"chjo\", \"х'ё\" ); ins( \"chju\", \"х'ю\" );\n\n    ins( \"śbia\", \"сбя\" );  ins( \"śbie\", \"сбе\" );  ins( \"śbio\", \"сбё\" );  ins( \"śbiu\", \"сбю\" );  ins( \"śbi\", \"сбі\" );\n    ins( \"ścia\", \"сця\" );  ins( \"ście\", \"сце\" );  ins( \"ścio\", \"сцё\" );  ins( \"ściu\", \"сцю\" );  ins( \"ści\", \"сці\" );  ins( \"ść\", \"сць\" );\n    ins( \"śdzia\",\"сдзя\" ); ins( \"śdzie\",\"сдзе\" ); ins( \"śdzio\",\"сдзё\" ); ins( \"śdziu\",\"сдзю\" ); ins( \"śdzi\",\"сдзі\" ); ins( \"śdź\",\"сдзь\" );\n    ins( \"śfia\", \"сфя\" );  ins( \"śfie\", \"сфе\" );  ins( \"śfio\", \"сфё\" );  ins( \"śfiu\", \"сфю\" );  ins( \"śfi\", \"сфі\" );\n    ins( \"ślia\", \"сліa\" ); ins( \"ślie\", \"сліэ\" ); ins( \"ślio\", \"сліо\" ); ins( \"śliu\", \"сліу\" ); ins( \"śli\", \"слі\" );  ins( \"śl\", \"сль\" );\n    ins( \"śmia\", \"смя\" );  ins( \"śmie\", \"сме\" );  ins( \"śmio\", \"смё\" );  ins( \"śmiu\", \"смю\" );  ins( \"śmi\", \"смі\" );\n    ins( \"śnia\", \"сня\" );  ins( \"śnie\", \"сне\" );  ins( \"śnio\", \"снё\" );  ins( \"śniu\", \"сню\" );  ins( \"śni\", \"сні\" );  ins( \"śń\", \"снь\" );\n    ins( \"śpia\", \"спя\" );  ins( \"śpie\", \"спе\" );  ins( \"śpio\", \"спё\" );  ins( \"śpiu\", \"спю\" );  ins( \"śpi\", \"спі\" );\n    ins( \"śsia\", \"сся\" );  ins( \"śsie\", \"ссе\" );  ins( \"śsio\", \"ссё\" );  ins( \"śsiu\", \"ссю\" );  ins( \"śsi\", \"ссі\" );\n    ins( \"śvia\", \"свя\" );  ins( \"śvie\", \"све\" );  ins( \"śvio\", \"свё\" );  ins( \"śviu\", \"свю\" );  ins( \"śvi\", \"сві\" );\n    ins( \"świa\", \"свя\" );  ins( \"świe\", \"све\" );  ins( \"świo\", \"свё\" );  ins( \"świu\", \"свю\" );  ins( \"świ\", \"сві\" );\n    ins( \"śzia\", \"сзя\" );  ins( \"śzie\", \"сзе\" );  ins( \"śzio\", \"сзё\" );  ins( \"śziu\", \"сзю\" );  ins( \"śzi\", \"сзі\" );  ins( \"śź\", \"сзь\" );\n\n    ins( \"ćbia\", \"цбя\" );  ins( \"ćbie\", \"цбе\" );  ins( \"ćbio\", \"цбё\" );  ins( \"ćbiu\", \"цбю\" );  ins( \"ćbi\", \"цбі\" );\n    ins( \"ćcia\", \"цця\" );  ins( \"ćcie\", \"цце\" );  ins( \"ćcio\", \"ццё\" );  ins( \"ćciu\", \"ццю\" );  ins( \"ćci\", \"цці\" );\n    ins( \"ćdzia\",\"цдзя\" ); ins( \"ćdzie\",\"цдзе\" ); ins( \"ćdzio\",\"цдзё\" ); ins( \"ćdziu\",\"цдзю\" ); ins( \"ćdzi\",\"цдзі\" );\n    ins( \"ćfia\", \"цфя\" );  ins( \"ćfie\", \"цфе\" );  ins( \"ćfio\", \"цфё\" );  ins( \"ćfiu\", \"цфю\" );  ins( \"ćfi\", \"цфі\" );\n    ins( \"ćlia\", \"цліa\" ); ins( \"ćlie\", \"цліэ\" ); ins( \"ćlio\", \"цліо\" ); ins( \"ćliu\", \"цліу\" ); ins( \"ćli\", \"цлі\" );  ins( \"ćl\", \"цль\" );\n    ins( \"ćmia\", \"цмя\" );  ins( \"ćmie\", \"цме\" );  ins( \"ćmio\", \"цмё\" );  ins( \"ćmiu\", \"цмю\" );  ins( \"ćmi\", \"цмі\" );\n    ins( \"ćnia\", \"цня\" );  ins( \"ćnie\", \"цне\" );  ins( \"ćnio\", \"цнё\" );  ins( \"ćniu\", \"цню\" );  ins( \"ćni\", \"цні\" );  ins( \"ćń\", \"цнь\" );\n    ins( \"ćpia\", \"цпя\" );  ins( \"ćpie\", \"цпе\" );  ins( \"ćpio\", \"цпё\" );  ins( \"ćpiu\", \"цпю\" );  ins( \"ćpi\", \"цпі\" );\n    ins( \"ćsia\", \"цся\" );  ins( \"ćsie\", \"цсе\" );  ins( \"ćsio\", \"цсё\" );  ins( \"ćsiu\", \"цсю\" );  ins( \"ćsi\", \"цсі\" );  ins( \"ćś\", \"цсь\" );\n    ins( \"ćvia\", \"цвя\" );  ins( \"ćvie\", \"цве\" );  ins( \"ćvio\", \"цвё\" );  ins( \"ćviu\", \"цвю\" );  ins( \"ćvi\", \"цві\" );\n    ins( \"ćwia\", \"цвя\" );  ins( \"ćwie\", \"цве\" );  ins( \"ćwio\", \"цвё\" );  ins( \"ćwiu\", \"цвю\" );  ins( \"ćwi\", \"цві\" );\n    ins( \"ćzia\", \"цзя\" );  ins( \"ćzie\", \"цзе\" );  ins( \"ćzio\", \"цзё\" );  ins( \"ćziu\", \"цзю\" );  ins( \"ćzi\", \"цзі\" );  ins( \"ćź\", \"цзь\" );\n\n    ins( \"źbia\", \"збя\" );  ins( \"źbie\", \"збе\" );  ins( \"źbio\", \"збё\" );  ins( \"źbiu\", \"збю\" );  ins( \"źbi\", \"збі\" );\n    ins( \"źcia\", \"зця\" );  ins( \"źcie\", \"зце\" );  ins( \"źcio\", \"зцё\" );  ins( \"źciu\", \"зцю\" );  ins( \"źci\", \"зці\" );  ins( \"źć\", \"зць\" );\n    ins( \"ździa\",\"здзя\" ); ins( \"ździe\",\"здзе\" ); ins( \"ździo\",\"здзё\" ); ins( \"ździu\",\"здзю\" ); ins( \"ździ\",\"здзі\" ); ins( \"źdź\",\"здзь\" );\n    ins( \"źfia\", \"зфя\" );  ins( \"źfie\", \"зфе\" );  ins( \"źfio\", \"зфё\" );  ins( \"źfiu\", \"зфю\" );  ins( \"źfi\", \"зфі\" );\n    ins( \"źlia\", \"зліa\" ); ins( \"źlie\", \"зліэ\" ); ins( \"źlio\", \"зліо\" ); ins( \"źliu\", \"зліу\" ); ins( \"źli\", \"злі\" );  ins( \"źl\", \"зль\" );\n    ins( \"źmia\", \"змя\" );  ins( \"źmie\", \"зме\" );  ins( \"źmio\", \"змё\" );  ins( \"źmiu\", \"змю\" );  ins( \"źmi\", \"змі\" );\n    ins( \"źnia\", \"зня\" );  ins( \"źnie\", \"зне\" );  ins( \"źnio\", \"знё\" );  ins( \"źniu\", \"зню\" );  ins( \"źni\", \"зні\" );\n    ins( \"źpia\", \"зпя\" );  ins( \"źpie\", \"зпе\" );  ins( \"źpio\", \"зпё\" );  ins( \"źpiu\", \"зпю\" );  ins( \"źpi\", \"зпі\" );\n    ins( \"źsia\", \"зся\" );  ins( \"źsie\", \"зсе\" );  ins( \"źsio\", \"зсё\" );  ins( \"źsiu\", \"зсю\" );  ins( \"źsi\", \"зсі\" );\n    ins( \"źvia\", \"звя\" );  ins( \"źvie\", \"зве\" );  ins( \"źvio\", \"звё\" );  ins( \"źviu\", \"звю\" );  ins( \"źvi\", \"зві\" );\n    ins( \"źwia\", \"звя\" );  ins( \"źwie\", \"зве\" );  ins( \"źwio\", \"звё\" );  ins( \"źwiu\", \"звю\" );  ins( \"źwi\", \"зві\" );\n    ins( \"źzia\", \"ззя\" );  ins( \"źzie\", \"ззе\" );  ins( \"źzio\", \"ззё\" );  ins( \"źziu\", \"ззю\" );  ins( \"źzi\", \"ззі\" );\n\n    ins( \"ńnia\", \"ння\" );  ins( \"ńnie\", \"нне\" );  ins( \"ńnio\", \"ннё\" );  ins( \"ńniu\", \"нню\" );  ins( \"ńni\", \"нні\" );\n    ins( \"dździa\", \"ддзя\" );  ins( \"dździe\", \"ддзе\" );  ins( \"dździo\", \"ддзё\" );  ins( \"dździu\", \"ддзю\" );  ins( \"dździ\", \"ддзі\" );\n\n    // cyrillic to latin\n    ins( \"а\", \"a\" );   ins( \"б\", \"b\" );   ins( \"в\", \"v\" );   ins( \"г\", \"h\" );\n    ins( \"ґ\", \"g\" );   ins( \"д\", \"d\" );   ins( \"е\", \"je\" );  ins( \"ё\", \"jo\" );\n    ins( \"ж\", \"ž\" );   ins( \"з\", \"z\" );   ins( \"і\", \"i\" );   ins( \"ї\", \"ï\" );\n    ins( \"й\", \"j\" );   ins( \"к\", \"k\" );   ins( \"л\", \"ł\" );   ins( \"м\", \"m\" );\n    ins( \"н\", \"n\" );   ins( \"о\", \"o\" );   ins( \"п\", \"p\" );   ins( \"р\", \"r\" );\n    ins( \"с\", \"s\" );   ins( \"т\", \"t\" );   ins( \"у\", \"u\" );   ins( \"ў\", \"ŭ\" );\n    ins( \"ф\", \"f\" );   ins( \"х\", \"ch\" );  ins( \"ц\", \"c\" );   ins( \"ч\", \"č\" );\n    ins( \"ш\", \"š\" );   ins( \"ы\", \"y\" );   ins( \"э\", \"e\" );   ins( \"ю\", \"ju\" );\n    ins( \"я\", \"ja\" );  ins( \"кг\", \"g\" );\n    ins( \"бе\", \"bie\" );  ins( \"бё\", \"bio\" );  ins( \"бю\", \"biu\" );  ins( \"бя\", \"bia\" );\n    ins( \"ве\", \"vie\" );  ins( \"вё\", \"vio\" );  ins( \"вю\", \"viu\" );  ins( \"вя\", \"via\" );\n    ins( \"ге\", \"hie\" );  ins( \"гё\", \"hio\" );  ins( \"гю\", \"hiu\" );  ins( \"гя\", \"hia\" );\n    ins( \"ґе\", \"gie\" );  ins( \"ґё\", \"gio\" );  ins( \"ґю\", \"giu\" );  ins( \"ґя\", \"gia\" );\n    ins( \"кге\", \"gie\" ); ins( \"кгё\", \"gio\" ); ins( \"кгю\", \"giu\" ); ins( \"кгя\", \"gia\" );\n    ins( \"зе\", \"zie\" );  ins( \"зё\", \"zio\" );  ins( \"зю\", \"ziu\" );  ins( \"зя\", \"zia\" );  ins( \"зь\", \"ź\" );\n    ins( \"ке\", \"kie\" );  ins( \"кё\", \"kio\" );  ins( \"кю\", \"kiu\" );  ins( \"кя\", \"kia\" );\n    ins( \"ле\", \"le\" );   ins( \"лё\", \"lo\" );   ins( \"лю\", \"lu\" );   ins( \"ля\", \"la\" );   ins( \"ль\", \"l\" );   ins( \"лі\", \"li\" );\n    ins( \"ме\", \"mie\" );  ins( \"мё\", \"mio\" );  ins( \"мю\", \"miu\" );  ins( \"мя\", \"mia\" );  ins( \"мь\", \"m\" );\n    ins( \"не\", \"nie\" );  ins( \"нё\", \"nio\" );  ins( \"ню\", \"niu\" );  ins( \"ня\", \"nia\" );  ins( \"нь\", \"ń\" );\n    ins( \"пе\", \"pie\" );  ins( \"пё\", \"pio\" );  ins( \"пю\", \"piu\" );  ins( \"пя\", \"pia\" );  ins( \"пь\", \"p\" );\n    ins( \"се\", \"sie\" );  ins( \"сё\", \"sio\" );  ins( \"сю\", \"siu\" );  ins( \"ся\", \"sia\" );  ins( \"сь\", \"ś\" );\n    ins( \"фе\", \"fie\" );  ins( \"фё\", \"fio\" );  ins( \"фю\", \"fiu\" );  ins( \"фя\", \"fia\" );  ins( \"фь\", \"f\" );\n    ins( \"хе\", \"chie\" ); ins( \"хё\", \"chio\" ); ins( \"хю\", \"chiu\" ); ins( \"хя\", \"chia\" );\n    ins( \"це\", \"cie\" );  ins( \"цё\", \"cio\" );  ins( \"цю\", \"ciu\" );  ins( \"ця\", \"cia\" );  ins( \"ць\", \"ć\" );\n    ins( \"бʼ\", \"b\" );    ins( \"б'\", \"b\" );    ins( \"б’\", \"b\" );\n    ins( \"вʼ\", \"v\" );    ins( \"в'\", \"v\" );    ins( \"в’\", \"v\" );\n    ins( \"гʼ\", \"h\" );    ins( \"г'\", \"h\" );    ins( \"г’\", \"h\" );\n    ins( \"ґʼ\", \"g\" );    ins( \"ґ'\", \"g\" );    ins( \"ґ’\", \"g\" );\n    ins( \"дʼ\", \"d\" );    ins( \"д'\", \"d\" );    ins( \"д’\", \"d\" );\n    ins( \"жʼ\", \"ž\" );    ins( \"ж'\", \"ž\" );    ins( \"ж’\", \"ž\" );\n    ins( \"зʼ\", \"z\" );    ins( \"з'\", \"z\" );    ins( \"з’\", \"z\" );\n    ins( \"кʼ\", \"k\" );    ins( \"к'\", \"k\" );    ins( \"к’\", \"k\" );\n    ins( \"лʼ\", \"ł\" );    ins( \"л'\", \"ł\" );    ins( \"л’\", \"ł\" );\n    ins( \"мʼ\", \"m\" );    ins( \"м'\", \"m\" );    ins( \"м’\", \"m\" );\n    ins( \"нʼ\", \"n\" );    ins( \"н'\", \"n\" );    ins( \"н’\", \"n\" );\n    ins( \"пʼ\", \"p\" );    ins( \"п'\", \"p\" );    ins( \"п’\", \"p\" );\n    ins( \"рʼ\", \"r\" );    ins( \"р'\", \"r\" );    ins( \"р’\", \"r\" );\n    ins( \"сʼ\", \"s\" );    ins( \"с'\", \"s\" );    ins( \"с’\", \"s\" );\n    ins( \"тʼ\", \"t\" );    ins( \"т'\", \"t\" );    ins( \"т’\", \"t\" );\n    ins( \"фʼ\", \"f\" );    ins( \"ф'\", \"f\" );    ins( \"ф’\", \"f\" );\n    ins( \"хʼ\", \"ch\" );   ins( \"х'\", \"ch\" );   ins( \"х’\", \"ch\" );\n    ins( \"цʼ\", \"c\" );    ins( \"ц'\", \"c\" );    ins( \"ц’\", \"c\" );\n    ins( \"чʼ\", \"č\" );    ins( \"ч'\", \"č\" );    ins( \"ч’\", \"č\" );\n    ins( \"шʼ\", \"š\" );    ins( \"ш'\", \"š\" );    ins( \"ш’\", \"š\" );\n  }\n};\n\nclass BelarusianSchoolToClassicTable: public Transliteration::Table\n{\npublic:\n  BelarusianSchoolToClassicTable()\n  {\n    ins( \"ньне\", \"нне\" );   ins( \"ньня\", \"ння\" );   ins( \"ньню\", \"нню\" );   ins( \"ньнё\", \"ннё\" );   ins( \"ньні\", \"нні\" );\n    ins( \"нне\", \"ньне\" );   ins( \"ння\", \"ньня\" );   ins( \"нню\", \"ньню\" );   ins( \"ннё\", \"ньнё\" );   ins( \"нні\", \"ньні\" );\n\n    ins( \"льле\", \"лле\" );   ins( \"льля\", \"лля\" );   ins( \"льлю\", \"ллю\" );   ins( \"льлё\", \"ллё\" );   ins( \"льлі\", \"ллі\" );\n    ins( \"лле\", \"льле\" );   ins( \"лля\", \"льля\" );   ins( \"ллю\", \"льлю\" );   ins( \"ллё\", \"льлё\" );   ins( \"ллі\", \"льлі\" );\n\n    ins( \"зьбе\", \"збе\" );   ins( \"зьбя\", \"збя\" );   ins( \"зьбю\", \"збю\" );   ins( \"зьбё\", \"збё\" );   ins( \"зьбі\", \"збі\" );\n    ins( \"збе\", \"зьбе\" );   ins( \"збя\", \"зьбя\" );   ins( \"збю\", \"зьбю\" );   ins( \"збё\", \"зьбё\" );   ins( \"збі\", \"зьбі\" );\n    ins( \"зьве\", \"зве\" );   ins( \"зьвя\", \"звя\" );   ins( \"зьвю\", \"звю\" );   ins( \"зьвё\", \"звё\" );   ins( \"зьві\", \"зві\" );\n    ins( \"зве\", \"зьве\" );   ins( \"звя\", \"зьвя\" );   ins( \"звю\", \"зьвю\" );   ins( \"звё\", \"зьвё\" );   ins( \"зві\", \"зьві\" );\n    ins( \"зьдзе\", \"здзе\" ); ins( \"зьдзя\", \"здзя\" ); ins( \"зьдзю\", \"здзю\" ); ins( \"зьдзё\", \"здзё\" ); ins( \"зьдзі\", \"здзі\" ); ins( \"зьдзь\", \"здзь\" );\n    ins( \"здзе\", \"зьдзе\" ); ins( \"здзя\", \"зьдзя\" ); ins( \"здзю\", \"зьдзю\" ); ins( \"здзё\", \"зьдзё\" ); ins( \"здзі\", \"зьдзі\" ); ins( \"здзь\", \"здзь\" );\n    ins( \"зьзе\", \"ззе\" );   ins( \"зьзя\", \"ззя\" );   ins( \"зьзю\", \"ззю\" );   ins( \"зьзё\", \"ззё\" );   ins( \"зьзі\", \"ззі\" );   ins( \"зьзь\", \"ззь\" );\n    ins( \"ззе\", \"зьзе\" );   ins( \"ззя\", \"зьзя\" );   ins( \"ззю\", \"зьзю\" );   ins( \"ззё\", \"зьзё\" );   ins( \"ззі\", \"зьзі\" );   ins( \"ззь\", \"зьзь\" );\n    ins( \"зьле\", \"зле\" );   ins( \"зьля\", \"зля\" );   ins( \"зьлю\", \"злю\" );   ins( \"зьлё\", \"злё\" );   ins( \"зьлі\", \"злі\" );   ins( \"зьль\", \"зль\" );\n    ins( \"зле\", \"зьле\" );   ins( \"зля\", \"зьля\" );   ins( \"злю\", \"зьлю\" );   ins( \"злё\", \"зьлё\" );   ins( \"злі\", \"зьлі\" );   ins( \"зль\", \"зьль\" );\n    ins( \"зьме\", \"зме\" );   ins( \"зьмя\", \"змя\" );   ins( \"зьмю\", \"змю\" );   ins( \"зьмё\", \"змё\" );   ins( \"зьмі\", \"змі\" );\n    ins( \"зме\", \"зьме\" );   ins( \"змя\", \"зьмя\" );   ins( \"змю\", \"зьмю\" );   ins( \"змё\", \"зьмё\" );   ins( \"змі\", \"зьмі\" );\n    ins( \"зьне\", \"зне\" );   ins( \"зьня\", \"зня\" );   ins( \"зьню\", \"зню\" );   ins( \"зьнё\", \"знё\" );   ins( \"зьні\", \"зні\" );   ins( \"зьнь\", \"знь\" );\n    ins( \"зне\", \"зьне\" );   ins( \"зня\", \"зьня\" );   ins( \"зню\", \"зьню\" );   ins( \"знё\", \"зьнё\" );   ins( \"зні\", \"зьні\" );   ins( \"знь\", \"зьнь\" );\n    ins( \"зьпе\", \"зпе\" );   ins( \"зьпя\", \"зпя\" );   ins( \"зьпю\", \"зпю\" );   ins( \"зьпё\", \"зпё\" );   ins( \"зьпі\", \"зпі\" );\n    ins( \"зпе\", \"зьпе\" );   ins( \"зпя\", \"зьпя\" );   ins( \"зпю\", \"зьпю\" );   ins( \"зпё\", \"зьпё\" );   ins( \"зпі\", \"зьпі\" );\n    ins( \"зьсе\", \"зсе\" );   ins( \"зься\", \"зся\" );   ins( \"зьсю\", \"зсю\" );   ins( \"зьсё\", \"зсё\" );   ins( \"зьсі\", \"зсі\" );   ins( \"зьсь\", \"зсь\" );\n    ins( \"зсе\", \"зьсе\" );   ins( \"зся\", \"зься\" );   ins( \"зсю\", \"зьсю\" );   ins( \"зсё\", \"зьсё\" );   ins( \"зсі\", \"зьсі\" );   ins( \"зсь\", \"зьсь\" );\n    ins( \"зьфе\", \"зфе\" );   ins( \"зьфя\", \"зфя\" );   ins( \"зьфю\", \"зфю\" );   ins( \"зьфё\", \"зфё\" );   ins( \"зьфі\", \"зфі\" );\n    ins( \"зфе\", \"зьфе\" );   ins( \"зфя\", \"зьфя\" );   ins( \"зфю\", \"зьфю\" );   ins( \"зфё\", \"зьфё\" );   ins( \"зфі\", \"зьфі\" );\n    ins( \"зьхе\", \"зхе\" );   ins( \"зьхя\", \"зхя\" );   ins( \"зьхю\", \"зхю\" );   ins( \"зьхё\", \"зхё\" );   ins( \"зьхі\", \"зхі\" );\n    ins( \"зхе\", \"зьхе\" );   ins( \"зхя\", \"зьхя\" );   ins( \"зхю\", \"зьхю\" );   ins( \"зхё\", \"зьхё\" );   ins( \"зхі\", \"зьхі\" );\n    ins( \"зьце\", \"зце\" );   ins( \"зьця\", \"зця\" );   ins( \"зьцю\", \"зцю\" );   ins( \"зьцё\", \"зцё\" );   ins( \"зьці\", \"зці\" );   ins( \"зьць\", \"зць\" );\n    ins( \"зце\", \"зьце\" );   ins( \"зця\", \"зьця\" );   ins( \"зцю\", \"зьцю\" );   ins( \"зцё\", \"зьцё\" );   ins( \"зці\", \"зьці\" );   ins( \"зць\", \"зьць\" );\n\n    ins( \"сьбе\", \"сбе\" );   ins( \"сьбя\", \"сбя\" );   ins( \"сьбю\", \"сбю\" );   ins( \"сьбё\", \"сбё\" );   ins( \"сьбі\", \"сбі\" );\n    ins( \"сбе\", \"сьбе\" );   ins( \"сбя\", \"сьбя\" );   ins( \"сбю\", \"сьбю\" );   ins( \"сбё\", \"сьбё\" );   ins( \"сбі\", \"сьбі\" );\n    ins( \"сьве\", \"све\" );   ins( \"сьвя\", \"свя\" );   ins( \"сьвю\", \"свю\" );   ins( \"сьвё\", \"свё\" );   ins( \"сьві\", \"сві\" );\n    ins( \"све\", \"сьве\" );   ins( \"свя\", \"сьвя\" );   ins( \"свю\", \"сьвю\" );   ins( \"свё\", \"сьвё\" );   ins( \"сві\", \"зьві\" );\n    ins( \"сьдзе\", \"сдзе\" ); ins( \"сьдзя\", \"сдзя\" ); ins( \"сьдзю\", \"сдзю\" ); ins( \"сьдзё\", \"сдзё\" ); ins( \"сьдзі\", \"сдзі\" ); ins( \"сьдзь\", \"сдзь\" );\n    ins( \"сдзе\", \"сьдзе\" ); ins( \"сдзя\", \"сьдзя\" ); ins( \"сдзю\", \"сьдзю\" ); ins( \"сдзё\", \"сьдзё\" ); ins( \"сдзі\", \"сьдзі\" ); ins( \"сдзь\", \"сьдзь\" );\n    ins( \"сьзе\", \"сзе\" );   ins( \"сьзя\", \"сзя\" );   ins( \"сьзю\", \"сзю\" );   ins( \"сьзё\", \"сзё\" );   ins( \"сьзі\", \"сзі\" );   ins( \"сьзь\", \"сзь\" );\n    ins( \"сзе\", \"сьзе\" );   ins( \"сзя\", \"сьзя\" );   ins( \"сзю\", \"сьзю\" );   ins( \"сзё\", \"сьзё\" );   ins( \"сзі\", \"сьзі\" );   ins( \"сзь\", \"сьзь\" );\n    ins( \"сьле\", \"сле\" );   ins( \"сьля\", \"сля\" );   ins( \"сьлю\", \"слю\" );   ins( \"сьлё\", \"слё\" );   ins( \"сьлі\", \"слі\" );   ins( \"сьль\", \"сль\" );\n    ins( \"сле\", \"сьле\" );   ins( \"сля\", \"сьля\" );   ins( \"слю\", \"сьлю\" );   ins( \"слё\", \"сьлё\" );   ins( \"слі\", \"сьлі\" );   ins( \"сль\", \"сьль\" );\n    ins( \"сьме\", \"сме\" );   ins( \"сьмя\", \"смя\" );   ins( \"сьмю\", \"смю\" );   ins( \"сьмё\", \"смё\" );   ins( \"сьмі\", \"смі\" );\n    ins( \"сме\", \"сьме\" );   ins( \"смя\", \"сьмя\" );   ins( \"смю\", \"сьмю\" );   ins( \"смё\", \"сьмё\" );   ins( \"смі\", \"сьмі\" );\n    ins( \"сьне\", \"сне\" );   ins( \"сьня\", \"сня\" );   ins( \"сьню\", \"сню\" );   ins( \"сьнё\", \"снё\" );   ins( \"сьні\", \"сні\" );   ins( \"сьнь\", \"снь\" );\n    ins( \"сне\", \"сьне\" );   ins( \"сня\", \"сьня\" );   ins( \"сню\", \"сьню\" );   ins( \"снё\", \"сьнё\" );   ins( \"сні\", \"сьні\" );   ins( \"снь\", \"сьнь\" );\n    ins( \"сьпе\", \"спе\" );   ins( \"сьпя\", \"спя\" );   ins( \"сьпю\", \"спю\" );   ins( \"сьпё\", \"спё\" );   ins( \"сьпі\", \"спі\" );\n    ins( \"спе\", \"сьпе\" );   ins( \"спя\", \"сьпя\" );   ins( \"спю\", \"сьпю\" );   ins( \"спё\", \"сьпё\" );   ins( \"спі\", \"сьпі\" );\n    ins( \"сьсе\", \"ссе\" );   ins( \"сься\", \"сся\" );   ins( \"сьсю\", \"ссю\" );   ins( \"сьсё\", \"ссё\" );   ins( \"сьсі\", \"ссі\" );   ins( \"сьсь\", \"ссь\" );\n    ins( \"ссе\", \"сьсе\" );   ins( \"сся\", \"сься\" );   ins( \"ссю\", \"сьсю\" );   ins( \"ссё\", \"сьсё\" );   ins( \"ссі\", \"сьсі\" );   ins( \"ссь\", \"сьсь\" );\n    ins( \"сьфе\", \"сфе\" );   ins( \"сьфя\", \"сфя\" );   ins( \"сьфю\", \"сфю\" );   ins( \"сьфё\", \"сфё\" );   ins( \"сьфі\", \"сфі\" );\n    ins( \"сфе\", \"сьфе\" );   ins( \"сфя\", \"сьфя\" );   ins( \"сфю\", \"сьфю\" );   ins( \"сфё\", \"сьфё\" );   ins( \"сфі\", \"сьфі\" );\n    ins( \"сьхе\", \"схе\" );   ins( \"сьхя\", \"схя\" );   ins( \"сьхю\", \"схю\" );   ins( \"сьхё\", \"схё\" );   ins( \"сьхі\", \"схі\" );\n    ins( \"схе\", \"сьхе\" );   ins( \"схя\", \"сьхя\" );   ins( \"схю\", \"сьхю\" );   ins( \"схё\", \"сьхё\" );   ins( \"схі\", \"сьхі\" );\n    ins( \"сьце\", \"сце\" );   ins( \"сьця\", \"сця\" );   ins( \"сьцю\", \"сцю\" );   ins( \"сьцё\", \"сцё\" );   ins( \"сьці\", \"сці\" );   ins( \"сьць\", \"сць\" );\n    ins( \"сце\", \"сьце\" );   ins( \"сця\", \"сьця\" );   ins( \"сцю\", \"сьцю\" );   ins( \"сцё\", \"сьцё\" );   ins( \"сці\", \"сьці\" );   ins( \"сць\", \"сьць\" );\n\n    ins( \"цьбе\", \"цбе\" );   ins( \"цьбя\", \"цбя\" );   ins( \"цьбю\", \"цбю\" );   ins( \"цьбё\", \"цбё\" );   ins( \"цьбі\", \"цбі\" );\n    ins( \"цбе\", \"цьбе\" );   ins( \"цбя\", \"цьбя\" );   ins( \"цбю\", \"цьбю\" );   ins( \"цбё\", \"цьбё\" );   ins( \"цбі\", \"цьбі\" );\n    ins( \"цьве\", \"цве\" );   ins( \"цьвя\", \"цвя\" );   ins( \"цьвю\", \"цвю\" );   ins( \"цьвё\", \"цвё\" );   ins( \"цьві\", \"цві\" );\n    ins( \"цве\", \"цьве\" );   ins( \"цвя\", \"цьвя\" );   ins( \"цвю\", \"цьвю\" );   ins( \"цвё\", \"цьвё\" );   ins( \"цві\", \"цьві\" );\n    ins( \"цьдзе\", \"цдзе\" ); ins( \"цьдзя\", \"цдзя\" ); ins( \"цьдзю\", \"цдзю\" ); ins( \"цьдзё\", \"цдзё\" ); ins( \"цьдзі\", \"цдзі\" ); ins( \"цьдзь\", \"цдзь\" );\n    ins( \"цдзе\", \"цьдзе\" ); ins( \"цдзя\", \"цьдзя\" ); ins( \"цдзю\", \"цьдзю\" ); ins( \"цдзё\", \"цьдзё\" ); ins( \"цдзі\", \"цьдзі\" ); ins( \"цдзь\", \"цьдзь\" );\n    ins( \"цьзе\", \"цзе\" );   ins( \"цьзя\", \"цзя\" );   ins( \"цьзю\", \"цзю\" );   ins( \"цьзё\", \"цзё\" );   ins( \"цьзі\", \"цзі\" );   ins( \"цьзь\", \"цзь\" );\n    ins( \"цзе\", \"цьзе\" );   ins( \"цзя\", \"цьзя\" );   ins( \"цзю\", \"цьзю\" );   ins( \"цзё\", \"цьзё\" );   ins( \"цзі\", \"цьзі\" );   ins( \"цзь\", \"цьзь\" );\n    ins( \"цьле\", \"цле\" );   ins( \"цьля\", \"цля\" );   ins( \"цьлю\", \"цлю\" );   ins( \"цьлё\", \"цлё\" );   ins( \"цьлі\", \"цлі\" );   ins( \"цьль\", \"цль\" );\n    ins( \"цле\", \"цьле\" );   ins( \"цля\", \"цьля\" );   ins( \"цлю\", \"цьлю\" );   ins( \"цлё\", \"цьлё\" );   ins( \"цлі\", \"цьлі\" );   ins( \"цль\", \"цьль\" );\n    ins( \"цьме\", \"цме\" );   ins( \"цьмя\", \"цмя\" );   ins( \"цьмю\", \"цмю\" );   ins( \"цьмё\", \"цмё\" );   ins( \"цьмі\", \"цмі\" );\n    ins( \"цме\", \"цьме\" );   ins( \"цмя\", \"цьмя\" );   ins( \"цмю\", \"цьмю\" );   ins( \"цмё\", \"цьмё\" );   ins( \"цмі\", \"цьмі\" );\n    ins( \"цьне\", \"цне\" );   ins( \"цьня\", \"цня\" );   ins( \"цьню\", \"цню\" );   ins( \"цьнё\", \"цнё\" );   ins( \"цьні\", \"цні\" );   ins( \"цьнь\", \"цнь\" );\n    ins( \"цне\", \"цьне\" );   ins( \"цня\", \"цьня\" );   ins( \"цню\", \"цьню\" );   ins( \"цнё\", \"цьнё\" );   ins( \"цні\", \"цьні\" );   ins( \"цнь\", \"цьнь\" );\n    ins( \"цьпе\", \"цпе\" );   ins( \"цьпя\", \"цпя\" );   ins( \"цьпю\", \"цпю\" );   ins( \"цьпё\", \"цпё\" );   ins( \"цьпі\", \"цпі\" );\n    ins( \"цпе\", \"цьпе\" );   ins( \"цпя\", \"цьпя\" );   ins( \"цпю\", \"цьпю\" );   ins( \"цпё\", \"цьпё\" );   ins( \"цпі\", \"цьпі\" );\n    ins( \"цьсе\", \"цсе\" );   ins( \"цься\", \"цся\" );   ins( \"цьсю\", \"цсю\" );   ins( \"цьсё\", \"цсё\" );   ins( \"цьсі\", \"цсі\" );   ins( \"цьсь\", \"цсь\" );\n    ins( \"цсе\", \"цьсе\" );   ins( \"цся\", \"цься\" );   ins( \"цсю\", \"цьсю\" );   ins( \"цсё\", \"цьсё\" );   ins( \"цсі\", \"цьсі\" );   ins( \"цсь\", \"цьсь\" );\n    ins( \"цьфе\", \"цфе\" );   ins( \"цьфя\", \"цфя\" );   ins( \"цьфю\", \"цфю\" );   ins( \"цьфё\", \"цфё\" );   ins( \"цьфі\", \"цфі\" );\n    ins( \"цфе\", \"цьфе\" );   ins( \"цфя\", \"цьфя\" );   ins( \"цфю\", \"цьфю\" );   ins( \"цфё\", \"цьфё\" );   ins( \"цфі\", \"цьфі\" );\n    ins( \"цьце\", \"цце\" );   ins( \"цьця\", \"цця\" );   ins( \"цьцю\", \"ццю\" );   ins( \"цьцё\", \"ццё\" );   ins( \"цьці\", \"цці\" );   ins( \"цьць\", \"цць\" );\n    ins( \"цце\", \"цьце\" );   ins( \"цця\", \"цьця\" );   ins( \"ццю\", \"цьцю\" );   ins( \"ццё\", \"цьцё\" );   ins( \"цці\", \"цьці\" );   ins( \"цць\", \"цьць\" );\n\n    ins( \"дзьдзе\", \"ддзе\" ); ins( \"дзьдзя\", \"ддзя\" ); ins( \"дзьдзю\", \"ддзю\" ); ins( \"дзьдзё\", \"ддзё\" ); ins( \"дзьдзі\", \"ддзі\" );\n    ins( \"ддзе\", \"дзьдзе\" ); ins( \"ддзя\", \"дзьдзя\" ); ins( \"ддзю\", \"дзьдзю\" ); ins( \"ддзё\", \"дзьдзё\" ); ins( \"ддзі\", \"дзьдзі\" );\n\n    ins( \"з'е\", \"зье\" );   ins( \"з'я\", \"зья\" );   ins( \"з'ю\", \"зью\" );   ins( \"з'ё\", \"зьё\" );   ins( \"з'і\", \"зьі\" );\n    ins( \"зье\", \"з'е\" );   ins( \"зья\", \"з'я\" );   ins( \"зью\", \"з'ю\" );   ins( \"зьё\", \"з'ё\" );   ins( \"зьі\", \"з'і\" );\n    ins( \"зʼе\", \"зье\" );   ins( \"зʼя\", \"зья\" );   ins( \"зʼю\", \"зью\" );   ins( \"зʼё\", \"зьё\" );   ins( \"зʼі\", \"зьі\" );\n    ins( \"зье\", \"зʼе\" );   ins( \"зья\", \"зʼя\" );   ins( \"зью\", \"зʼю\" );   ins( \"зьё\", \"зʼё\" );   ins( \"зьі\", \"зʼі\" );\n    ins( \"з’е\", \"зье\" );   ins( \"з’я\", \"зья\" );   ins( \"з’ю\", \"зью\" );   ins( \"з’ё\", \"зьё\" );   ins( \"з’і\", \"зьі\" );\n    ins( \"зье\", \"з’е\" );   ins( \"зья\", \"з’я\" );   ins( \"зью\", \"з’ю\" );   ins( \"зьё\", \"з’ё\" );   ins( \"зьі\", \"з’і\" );\n  }\n};\n\nstd::vector< sptr< Dictionary::Class > > makeDictionaries() THROW_SPEC( std::exception )\n{\n  static BelarusianLatinToClassicTable t0;\n  static BelarusianLatinToSchoolTable t1;\n  static BelarusianSchoolToClassicTable t2;\n  std::vector< sptr< Dictionary::Class > > dicts;\n\n  dicts.push_back( new Transliteration::TransliterationDictionary( \"c31b24abf412abc9b23bb40a898f1040\",\n                   QCoreApplication::translate( \"BelarusianTranslit\", \"Belarusian transliteration from latin to cyrillic (classic orthography)\" ).toUtf8().data(),\n                   QIcon( \":/flags/by.png\" ), t0, false ) );\n  dicts.push_back( new Transliteration::TransliterationDictionary( \"c31b24abf412abc9b23bb40a898f1041\",\n                   QCoreApplication::translate( \"BelarusianTranslit\", \"Belarusian transliteration from latin to cyrillic (school orthography)\" ).toUtf8().data(),\n                   QIcon( \":/flags/by.png\" ), t1, false ) );\n  dicts.push_back( new Transliteration::TransliterationDictionary( \"c31b24abf412abc9b23bb40a898f1042\",\n                   QCoreApplication::translate( \"BelarusianTranslit\", \"Belarusian transliteration (smoothes out the difference\\n\"\n                                                \"between classic and school orthography in cyrillic)\" ).toUtf8().data(),\n                   QIcon( \":/flags/by.png\" ), t2, false ) );\n  return dicts;\n}\n\n}\n"
        },
        {
          "name": "belarusiantranslit.hh",
          "type": "blob",
          "size": 0.4384765625,
          "content": "/* This file is (c) 2013 Maksim Tamkovicz <quendimax@gmail.com>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __BELARUSIANTRANSLIT_HH_INCLUDED__\n#define __BELARUSIANTRANSLIT_HH_INCLUDED__\n\n#include <vector>\n#include \"dictionary.hh\"\n\n// Support for Belarusian transliteration\nnamespace BelarusianTranslit {\n\nstd::vector< sptr< Dictionary::Class > > makeDictionaries() THROW_SPEC( std::exception );\n\n}\n\n#endif\n"
        },
        {
          "name": "bgl.cc",
          "type": "blob",
          "size": 42.779296875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"bgl.hh\"\n#include \"btreeidx.hh\"\n#include \"bgl_babylon.hh\"\n#include \"file.hh\"\n#include \"folding.hh\"\n#include \"utf8.hh\"\n#include \"chunkedstorage.hh\"\n#include \"langcoder.hh\"\n#include \"language.hh\"\n#include \"gddebug.hh\"\n#include \"fsencoding.hh\"\n#include \"htmlescape.hh\"\n#include \"ftshelpers.hh\"\n\n#include <map>\n#include <set>\n#include <list>\n#include <zlib.h>\n#include <ctype.h>\n#include <string.h>\n\n#ifdef _MSC_VER\n#include <stub_msvc.h>\n#endif\n\n#include <QSemaphore>\n#include <QThreadPool>\n#include <QAtomicInt>\n#include <QDebug>\n\n#include <QRegExp>\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n#include <QRegularExpression>\n#endif\n\n#include \"qt4x5.hh\"\n\nnamespace Bgl {\n\nusing std::map;\nusing std::multimap;\nusing std::set;\nusing gd::wstring;\nusing gd::wchar;\nusing std::list;\nusing std::pair;\nusing std::string;\n\nusing BtreeIndexing::WordArticleLink;\nusing BtreeIndexing::IndexedWords;\nusing BtreeIndexing::IndexInfo;\n\nnamespace\n{\n  enum\n  {\n    Signature = 0x584c4742, // BGLX on little-endian, XLGB on big-endian\n    CurrentFormatVersion = 19 + BtreeIndexing::FormatVersion\n  };\n\n  struct IdxHeader\n  {\n    uint32_t signature; // First comes the signature, BGLX\n    uint32_t formatVersion; // File format version, currently 1.\n    uint32_t parserVersion; // Version of the parser used to parse the BGL file.\n                            // If it's lower than the current one, the file is to\n                            // be re-parsed.\n    uint32_t foldingVersion; // Version of the folding algorithm used when building\n                             // index. If it's different from the current one,\n                             // the file is to be rebuilt.\n    uint32_t articleCount; // Total number of articles, for informative purposes only\n    uint32_t wordCount; // Total number of words, for informative purposes only\n    /// Add more fields here, like name, description, author and such.\n    uint32_t chunksOffset; // The offset to chunks' storage\n    uint32_t indexBtreeMaxElements; // Two fields from IndexInfo\n    uint32_t indexRootOffset;\n    uint32_t resourceListOffset; // The offset of the list of resources\n    uint32_t resourcesCount; // Number of resources stored\n    uint32_t langFrom;  // Source language\n    uint32_t langTo;    // Target language\n    uint32_t iconAddress; // Address of the icon in the chunks' storage\n    uint32_t iconSize; // Size of the icon in the chunks' storage, 0 = no icon\n    uint32_t descriptionAddress; // Address of the dictionary description in the chunks' storage\n    uint32_t descriptionSize; // Size of the description in the chunks' storage, 0 = no description\n  }\n  #ifndef _MSC_VER\n  __attribute__((packed))\n  #endif\n  ;\n\n  bool indexIsOldOrBad( string const & indexFile )\n  {\n    File::Class idx( indexFile, \"rb\" );\n\n    IdxHeader header;\n\n    return idx.readRecords( &header, sizeof( header ), 1 ) != 1 ||\n           header.signature != Signature ||\n           header.formatVersion != CurrentFormatVersion ||\n           header.parserVersion != Babylon::ParserVersion ||\n           header.foldingVersion != Folding::Version;\n  }\n\n  // Removes the $1$-like postfix\n  string removePostfix( string const & in )\n  {\n    if ( in.size() && in[ in.size() - 1 ] == '$' )\n    {\n      // Find the end of it and cut it, barring any unexpectedness\n      for( long x = in.size() - 2; x >= 0; x-- )\n      {\n        if ( in[ x ] == '$' )\n          return in.substr( 0, x );\n        else\n        if ( !isdigit( in[ x ] ) )\n          break;\n      }\n    }\n\n    return in;\n  }\n\n  // Removes any leading or trailing whitespace\n  void trimWs( string & word )\n  {\n    if ( word.size() )\n    {\n      unsigned begin = 0;\n\n      while( begin < word.size() && Utf8::isspace( word[ begin ] ) )\n        ++begin;\n\n      if ( begin == word.size() ) // Consists of ws entirely?\n        word.clear();\n      else\n      {\n        unsigned end = word.size();\n\n        // Doesn't consist of ws entirely, so must end with just isspace()\n        // condition.\n        while( Utf8::isspace( word[ end - 1 ] ) )\n          --end;\n\n        if ( end != word.size() || begin )\n          word = string( word, begin, end - begin );\n      }\n    }\n  }\n\n  void addEntryToIndex( string & word,\n                        uint32_t articleOffset,\n                        IndexedWords & indexedWords,\n                        vector< wchar > & wcharBuffer )\n  {\n    // Strip any leading or trailing whitespaces\n    trimWs( word );\n\n    // If the word starts with a slash, we drop it. There are quite a lot\n    // of them, and they all seem to be redudant duplicates.\n\n    if ( word.size() && word[ 0 ] == '/' )\n      return;\n\n    // Check the input word for a superscript postfix ($1$, $2$ etc), which\n    // signifies different meaning in Bgl files. We emit different meaning\n    // as different articles, but they appear in the index as the same word.\n\n    if ( word.size() && word[ word.size() - 1 ] == '$' )\n    {\n      word = removePostfix( word );\n      trimWs( word );\n    }\n\n    // Convert the word from utf8 to wide chars\n\n    if ( wcharBuffer.size() <= word.size() )\n      wcharBuffer.resize( word.size() + 1 );\n\n    long result = Utf8::decode( word.c_str(), word.size(),\n                                &wcharBuffer.front() );\n\n    if ( result < 0 )\n    {\n      gdWarning( \"Failed to decode utf8 of headword \\\"%s\\\", skipping it.\", word.c_str() );\n      return;\n    }\n\n    indexedWords.addWord( wstring( &wcharBuffer.front(), result ), articleOffset );\n  }\n\n\n  DEF_EX( exFailedToDecompressArticle, \"Failed to decompress article's body\", Dictionary::Ex )\n  DEF_EX( exChunkIndexOutOfRange, \"Chunk index is out of range\", Dictionary::Ex )\n\n  class BglDictionary: public BtreeIndexing::BtreeDictionary\n  {\n    Mutex idxMutex;\n    File::Class idx;\n    IdxHeader idxHeader;\n    string dictionaryName;\n    ChunkedStorage::Reader chunks;\n\n  public:\n\n    BglDictionary( string const & id, string const & indexFile,\n                   string const & dictionaryFile );\n\n    virtual string getName() throw()\n    { return dictionaryName; }\n\n    virtual map< Dictionary::Property, string > getProperties() throw()\n    { return map< Dictionary::Property, string >(); }\n\n    virtual unsigned long getArticleCount() throw()\n    { return idxHeader.articleCount; }\n\n    virtual unsigned long getWordCount() throw()\n    { return idxHeader.wordCount; }\n\n    inline virtual quint32 getLangFrom() const\n    { return idxHeader.langFrom; }\n\n    inline virtual quint32 getLangTo() const\n    { return idxHeader.langTo; }\n\n    virtual sptr< Dictionary::WordSearchRequest > findHeadwordsForSynonym( wstring const & )\n      THROW_SPEC( std::exception );\n\n    virtual sptr< Dictionary::DataRequest > getArticle( wstring const &,\n                                                        vector< wstring > const & alts,\n                                                        wstring const &,\n                                                        bool ignoreDiacritics )\n      THROW_SPEC( std::exception );\n\n    virtual sptr< Dictionary::DataRequest > getResource( string const & name )\n      THROW_SPEC( std::exception );\n\n    virtual sptr< Dictionary::DataRequest > getSearchResults( QString const & searchString,\n                                                              int searchMode, bool matchCase,\n                                                              int distanceBetweenWords,\n                                                              int maxResults,\n                                                              bool ignoreWordsOrder,\n                                                              bool ignoreDiacritics,\n                                                              QThreadPool * ftsThreadPoolPtr );\n    virtual QString const& getDescription();\n\n    virtual void getArticleText( uint32_t articleAddress, QString & headword, QString & text );\n\n    virtual void makeFTSIndex(QAtomicInt & isCancelled, bool firstIteration );\n\n    virtual void setFTSParameters( Config::FullTextSearch const & fts )\n    {\n      can_FTS = fts.enabled\n                && !fts.disabledTypes.contains( \"BGL\", Qt::CaseInsensitive )\n                && ( fts.maxDictionarySize == 0 || getArticleCount() <= fts.maxDictionarySize );\n    }\n\n  protected:\n\n    virtual void loadIcon() throw();\n\n  private:\n\n\n    /// Loads an article with the given offset, filling the given strings.\n    void loadArticle( uint32_t offset, string & headword,\n                      string & displayedHeadword, string & articleText );\n\n    static void replaceCharsetEntities( string & );\n\n    friend class BglHeadwordsRequest;\n    friend class BglArticleRequest;\n    friend class BglResourceRequest;\n  };\n\n  BglDictionary::BglDictionary( string const & id, string const & indexFile,\n                                string const & dictionaryFile ):\n    BtreeDictionary( id, vector< string >( 1, dictionaryFile ) ),\n    idx( indexFile, \"rb\" ),\n    idxHeader( idx.read< IdxHeader >() ),\n    chunks( idx, idxHeader.chunksOffset )\n  {\n    idx.seek( sizeof( idxHeader ) );\n\n    // Read the dictionary's name\n\n    size_t len = idx.read< uint32_t >();\n\n    if( len )\n    {\n      vector< char > nameBuf( len );\n\n      idx.read( &nameBuf.front(), len );\n\n      dictionaryName = string( &nameBuf.front(), len );\n    }\n\n    // Initialize the index\n\n    openIndex( IndexInfo( idxHeader.indexBtreeMaxElements,\n                        idxHeader.indexRootOffset ),\n               idx, idxMutex );\n\n    can_FTS = true;\n\n    ftsIdxName = indexFile + \"_FTS\";\n\n    if( !Dictionary::needToRebuildIndex( getDictionaryFilenames(), ftsIdxName )\n        && !FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) )\n      FTS_index_completed.ref();\n  }\n\n  void BglDictionary::loadIcon() throw()\n  {\n    if ( dictionaryIconLoaded )\n      return;\n\n    QString fileName =\n      QDir::fromNativeSeparators( FsEncoding::decode( getDictionaryFilenames()[ 0 ].c_str() ) );\n\n    // Remove the extension\n    fileName.chop( 3 );\n\n    if( !loadIconFromFile( fileName ) )\n    {\n      if( idxHeader.iconSize )\n      {\n\n        // Try loading icon now\n\n        vector< char > chunk;\n\n        Mutex::Lock _( idxMutex );\n\n        char * iconData = chunks.getBlock( idxHeader.iconAddress, chunk );\n\n        QImage img;\n\n        if (img.loadFromData( ( unsigned char *) iconData, idxHeader.iconSize  ) )\n        {\n          // Load successful\n\n          dictionaryNativeIcon = QIcon( QPixmap::fromImage( img ) );\n\n          // Transform it to be square\n          int max = img.width() > img.height() ? img.width() : img.height();\n\n          QImage result( max, max, QImage::Format_ARGB32 );\n          result.fill( 0 ); // Black transparent\n\n          QPainter painter( &result );\n\n          painter.drawImage( QPoint( img.width() == max ? 0 : ( max - img.width() ) / 2,\n                                     img.height() == max ? 0 : ( max - img.height() ) / 2 ),\n                             img );\n\n          painter.end();\n\n          dictionaryIcon = QIcon( QPixmap::fromImage( result ) );\n        }\n      }\n\n      if ( dictionaryIcon.isNull() )\n        dictionaryIcon = dictionaryNativeIcon = QIcon(\":/icons/icon32_bgl.png\");\n    }\n\n    dictionaryIconLoaded = true;\n  }\n\n  void BglDictionary::loadArticle( uint32_t offset, string & headword,\n                                   string & displayedHeadword,\n                                   string & articleText )\n  {\n    vector< char > chunk;\n\n    Mutex::Lock _( idxMutex );\n\n    char * articleData = chunks.getBlock( offset, chunk );\n\n    headword = articleData;\n\n    displayedHeadword = articleData + headword.size() + 1;\n\n    articleText =\n      string( articleData + headword.size() +\n                displayedHeadword.size() + 2 );\n  }\n\n  QString const& BglDictionary::getDescription()\n  {\n    if( !dictionaryDescription.isEmpty() )\n      return dictionaryDescription;\n\n    if( idxHeader.descriptionSize == 0 )\n      dictionaryDescription = \"NONE\";\n    else\n    {\n      Mutex::Lock _( idxMutex );\n      vector< char > chunk;\n      char * dictDescription = chunks.getBlock( idxHeader.descriptionAddress, chunk );\n      string str( dictDescription );\n      if( !str.empty() )\n        dictionaryDescription += QString( QObject::tr( \"Copyright: %1%2\" ) )\n                                 .arg( Html::unescape( QString::fromUtf8( str.data(), str.size() ) ) )\n                                 .arg( \"\\n\\n\" );\n      dictDescription += str.size() + 1;\n\n      str = string( dictDescription );\n      if( !str.empty() )\n        dictionaryDescription += QString( QObject::tr( \"Author: %1%2\" ) )\n                                 .arg( QString::fromUtf8( str.data(), str.size() ) )\n                                 .arg( \"\\n\\n\" );\n      dictDescription += str.size() + 1;\n\n      str = string( dictDescription );\n      if( !str.empty() )\n        dictionaryDescription += QString( QObject::tr( \"E-mail: %1%2\" ) )\n                                 .arg( QString::fromUtf8( str.data(), str.size() ) )\n                                 .arg( \"\\n\\n\" );\n      dictDescription += str.size() + 1;\n\n      str = string( dictDescription );\n      if( !str.empty() )\n        dictionaryDescription += Html::unescape( QString::fromUtf8( str.data(), str.size() ) );\n    }\n\n    return dictionaryDescription;\n  }\n\n  void BglDictionary::getArticleText( uint32_t articleAddress, QString & headword, QString & text )\n  {\n    try\n    {\n      string headwordStr, displayedHeadwordStr, articleStr;\n      loadArticle( articleAddress, headwordStr, displayedHeadwordStr, articleStr );\n\n      // Some headword normalization similar while indexing\n      trimWs( headwordStr );\n\n      if ( headwordStr.size() && headwordStr[ 0 ] == '/' )\n        headwordStr.erase(); // We will take headword from index later\n\n      if ( headwordStr.size()\n           && headwordStr[ headwordStr.size() - 1 ] == '$' )\n      {\n        headwordStr = removePostfix( headwordStr );\n        trimWs( headwordStr );\n      }\n\n      headword = QString::fromUtf8( headwordStr.data(), headwordStr.size() );\n\n      wstring wstr = Utf8::decode( articleStr );\n\n      if ( getLangTo() == LangCoder::code2toInt( \"he\" ) )\n      {\n        for ( unsigned int i = 0; i < wstr.size(); i++ )\n        {\n          if ( (wstr[ i ] >= 224 && wstr[ i ] <= 250) || (wstr[ i ] >= 192 && wstr[ i ] <= 210) ) // Hebrew chars encoded ecoded as windows-1255 or ISO-8859-8, or as vowel-points of windows-1255\n            wstr[ i ] += 1488 - 224; // Convert to Hebrew unicode\n        }\n      }\n\n      text = Html::unescape( gd::toQString( wstr ) );\n    }\n    catch( std::exception &ex )\n    {\n      gdWarning( \"BGL: Failed retrieving article from \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n    }\n  }\n\n  void BglDictionary::makeFTSIndex( QAtomicInt & isCancelled, bool firstIteration )\n  {\n    if( !( Dictionary::needToRebuildIndex( getDictionaryFilenames(), ftsIdxName )\n           || FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) ) )\n      FTS_index_completed.ref();\n\n    if( haveFTSIndex() )\n      return;\n\n    if( firstIteration && getArticleCount() > FTS::MaxDictionarySizeForFastSearch )\n      return;\n\n    gdDebug( \"Bgl: Building the full-text index for dictionary: %s\\n\",\n             getName().c_str() );\n\n    try\n    {\n      FtsHelpers::makeFTSIndex( this, isCancelled );\n      FTS_index_completed.ref();\n    }\n    catch( std::exception &ex )\n    {\n      gdWarning( \"Bgl: Failed building full-text search index for \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n      QFile::remove( FsEncoding::decode( ftsIdxName.c_str() ) );\n    }\n  }\n\n/// BglDictionary::findHeadwordsForSynonym()\n\nclass BglHeadwordsRequest;\n\nclass BglHeadwordsRequestRunnable: public QRunnable\n{\n  BglHeadwordsRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  BglHeadwordsRequestRunnable( BglHeadwordsRequest & r_,\n                               QSemaphore & hasExited_ ): r( r_ ),\n                                                          hasExited( hasExited_ )\n  {}\n\n  ~BglHeadwordsRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass BglHeadwordsRequest: public Dictionary::WordSearchRequest\n{\n  friend class BglHeadwordsRequestRunnable;\n\n  wstring str;\n  BglDictionary & dict;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  BglHeadwordsRequest( wstring const & word_,\n                       BglDictionary & dict_ ):\n    str( word_ ), dict( dict_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new BglHeadwordsRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by BglHeadwordsRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~BglHeadwordsRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid BglHeadwordsRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid BglHeadwordsRequest::run()\n{\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  vector< WordArticleLink > chain = dict.findArticles( str );\n\n  wstring caseFolded = Folding::applySimpleCaseOnly( str );\n\n  for( unsigned x = 0; x < chain.size(); ++x )\n  {\n    if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    {\n      finish();\n      return;\n    }\n\n    string headword, displayedHeadword, articleText;\n\n    dict.loadArticle( chain[ x ].articleOffset,\n                      headword, displayedHeadword, articleText );\n\n    wstring headwordDecoded;\n    try\n    {\n      headwordDecoded = Utf8::decode( removePostfix(  headword ) );\n    }\n    catch( Utf8::exCantDecode & )\n    {\n    }\n\n    if ( caseFolded != Folding::applySimpleCaseOnly( headwordDecoded ) && !headwordDecoded.empty() )\n    {\n      // The headword seems to differ from the input word, which makes the\n      // input word its synonym.\n      Mutex::Lock _( dataMutex );\n\n      matches.push_back( headwordDecoded );\n    }\n  }\n\n  finish();\n}\n\nsptr< Dictionary::WordSearchRequest >\n  BglDictionary::findHeadwordsForSynonym( wstring const & word )\n  THROW_SPEC( std::exception )\n{\n  return synonymSearchEnabled ? new BglHeadwordsRequest( word, *this ) :\n                                Class::findHeadwordsForSynonym( word );\n}\n\n// Converts a $1$-like postfix to a <sup>1</sup> one\nstring postfixToSuperscript( string const & in )\n{\n  if ( !in.size() || in[ in.size() - 1 ] != '$' )\n    return in;\n\n  for( long x = in.size() - 2; x >= 0; x-- )\n  {\n    if ( in[ x ] == '$' )\n    {\n      if ( in.size() - x - 2 > 2 )\n      {\n        // Large postfixes seem like something we wouldn't want to show --\n        // some dictionaries seem to have each word numbered using the\n        // postfix.\n        return in.substr( 0, x );\n      }\n      else\n        return in.substr( 0, x ) + \"<sup>\" + in.substr( x + 1, in.size() - x - 2 ) + \"</sup>\";\n    }\n    else\n    if ( !isdigit( in[ x ] ) )\n      break;\n  }\n\n  return in;\n}\n\n\n/// BglDictionary::getArticle()\n\nclass BglArticleRequest;\n\nclass BglArticleRequestRunnable: public QRunnable\n{\n  BglArticleRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  BglArticleRequestRunnable( BglArticleRequest & r_,\n                                  QSemaphore & hasExited_ ): r( r_ ),\n                                                             hasExited( hasExited_ )\n  {}\n\n  ~BglArticleRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass BglArticleRequest: public Dictionary::DataRequest\n{\n  friend class BglArticleRequestRunnable;\n\n  wstring word;\n  vector< wstring > alts;\n  BglDictionary & dict;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n  bool ignoreDiacritics;\n\npublic:\n\n  BglArticleRequest( wstring const & word_,\n                     vector< wstring > const & alts_,\n                     BglDictionary & dict_, bool ignoreDiacritics_ ):\n    word( word_ ), alts( alts_ ), dict( dict_ ), ignoreDiacritics( ignoreDiacritics_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new BglArticleRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by BglArticleRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  void fixHebString(string & hebStr); // Hebrew support\n  void fixHebArticle(string & hebArticle); // Hebrew support\n\n  ~BglArticleRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid BglArticleRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid BglArticleRequest::fixHebString(string & hebStr) // Hebrew support - convert non-unicode to unicode\n{\n  wstring hebWStr;\n  try\n  {\n    hebWStr = Utf8::decode(hebStr);\n  }\n  catch( Utf8::exCantDecode & )\n  {\n    hebStr = \"Utf-8 decoding error\";\n    return;\n  }\n\n  for (unsigned int i=0; i<hebWStr.size();i++)\n  {\n    if ( (hebWStr[ i ] >= 224 && hebWStr[ i ] <= 250) || (hebWStr[ i ] >= 192 && hebWStr[ i ] <= 210) ) // Hebrew chars encoded ecoded as windows-1255 or ISO-8859-8, or as vowel-points of windows-1255\n        hebWStr[i]+=1488-224; // Convert to Hebrew unicode\n  }\n  hebStr=Utf8::encode(hebWStr);\n}\n\nvoid BglArticleRequest::fixHebArticle(string & hebArticle) // Hebrew support - remove extra chars at the end\n{\n  unsigned nulls;\n\n  for ( nulls = hebArticle.size(); nulls > 0 &&\n        ( ( hebArticle[ nulls - 1 ] <= 32 &&\n            hebArticle[ nulls - 1 ] >= 0 ) ||\n          ( hebArticle[ nulls - 1 ] >= 65 &&\n            hebArticle[ nulls - 1 ] <= 90 ) ); --nulls ) ; //special chars and A-Z\n\n  hebArticle.resize( nulls );\n}\n\nvoid BglArticleRequest::run()\n{\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  vector< WordArticleLink > chain = dict.findArticles( word, ignoreDiacritics );\n\n  static Language::Id hebrew = LangCoder::code2toInt( \"he\" ); // Hebrew support\n\n  for( unsigned x = 0; x < alts.size(); ++x )\n  {\n    /// Make an additional query for each alt\n\n    vector< WordArticleLink > altChain = dict.findArticles( alts[ x ], ignoreDiacritics );\n\n    chain.insert( chain.end(), altChain.begin(), altChain.end() );\n  }\n\n  multimap< wstring, pair< string, string > > mainArticles, alternateArticles;\n\n  set< uint32_t > articlesIncluded; // Some synonims make it that the articles\n                                    // appear several times. We combat this\n                                    // by only allowing them to appear once.\n  // Sometimes the articles are physically duplicated. We store hashes of\n  // the bodies to account for this.\n  set< QByteArray > articleBodiesIncluded;\n\n  wstring wordCaseFolded = Folding::applySimpleCaseOnly( word );\n  if( ignoreDiacritics )\n    wordCaseFolded = Folding::applyDiacriticsOnly( wordCaseFolded );\n\n  for( unsigned x = 0; x < chain.size(); ++x )\n  {\n    if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    {\n      finish();\n      return;\n    }\n\n    try\n    {\n\n    if ( articlesIncluded.find( chain[ x ].articleOffset ) != articlesIncluded.end() )\n      continue; // We already have this article in the body.\n\n    // Now grab that article\n\n    string headword, displayedHeadword, articleText;\n\n    dict.loadArticle( chain[ x ].articleOffset,\n                      headword, displayedHeadword, articleText );\n\n    // Ok. Now, does it go to main articles, or to alternate ones? We list\n    // main ones first, and alternates after.\n\n    // We do the case-folded and postfix-less comparison here.\n\n    wstring headwordStripped =\n      Folding::applySimpleCaseOnly( Utf8::decode( removePostfix( headword ) ) );\n    if( ignoreDiacritics )\n      headwordStripped = Folding::applyDiacriticsOnly( headwordStripped );\n\n    // Hebrew support - fix Hebrew text\n    if (dict.idxHeader.langFrom == hebrew)\n    {\n        displayedHeadword= displayedHeadword.size() ? displayedHeadword : headword;\n        fixHebString(articleText);\n        fixHebArticle(articleText);\n        fixHebString(displayedHeadword);\n    }\n\n    string const & targetHeadword = displayedHeadword.size() ?\n                                    displayedHeadword : headword;\n\n    QCryptographicHash hash( QCryptographicHash::Md5 );\n    hash.addData( targetHeadword.data(), targetHeadword.size() + 1 ); // with 0\n    hash.addData( articleText.data(), articleText.size() );\n\n    if ( !articleBodiesIncluded.insert( hash.result() ).second )\n      continue; // Already had this body\n\n    multimap< wstring, pair< string, string > > & mapToUse =\n      ( wordCaseFolded == headwordStripped ) ?\n        mainArticles : alternateArticles;\n\n    mapToUse.insert( pair< wstring, pair< string, string > >(\n      Folding::applySimpleCaseOnly( Utf8::decode( headword ) ),\n      pair< string, string >( targetHeadword, articleText ) ) );\n\n    articlesIncluded.insert( chain[ x ].articleOffset );\n\n    } // try\n    catch( std::exception &ex )\n    {\n      gdWarning( \"BGL: Failed loading article from \\\"%s\\\", reason: %s\\n\", dict.getName().c_str(), ex.what() );\n    }\n  }\n\n  if ( mainArticles.empty() && alternateArticles.empty() )\n  {\n    // No such word\n    finish();\n    return;\n  }\n\n  string result;\n\n  multimap< wstring, pair< string, string > >::const_iterator i;\n\n  string cleaner = \"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\n                   \"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\n                   \"</b></b></b></b></b></b></b></b>\"\n                   \"</i></i></i></i></i></i></i></i>\";\n  for( i = mainArticles.begin(); i != mainArticles.end(); ++i )\n  {\n      if (dict.isFromLanguageRTL() ) // RTL support\n        result += \"<h3 style=\\\"text-align:right;direction:rtl\\\">\";\n      else\n        result += \"<h3>\";\n      result += postfixToSuperscript( i->second.first );\n      result += \"</h3>\";\n      if ( dict.isToLanguageRTL() )\n        result += \"<div class=\\\"bglrtl\\\">\" + i->second.second + \"</div>\";\n      else\n        result += \"<div>\" + i->second.second + \"</div>\";\n      result += cleaner;\n  }\n\n \n  for( i = alternateArticles.begin(); i != alternateArticles.end(); ++i )\n  {\n      if (dict.isFromLanguageRTL() ) // RTL support\n        result += \"<h3 style=\\\"text-align:right;direction:rtl\\\">\";\n      else\n        result += \"<h3>\";\n      result += postfixToSuperscript( i->second.first );\n      result += \"</h3>\";\n      if ( dict.isToLanguageRTL() )\n        result += \"<div class=\\\"bglrtl\\\">\" + i->second.second + \"</div>\";\n      else\n        result += \"<div>\" + i->second.second + \"</div>\";\n      result += cleaner;\n  }\n  // Do some cleanups in the text\n\n  BglDictionary::replaceCharsetEntities( result );\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  result = QString::fromUtf8( result.c_str() )\n          // onclick location to link\n          .replace( QRegularExpression( \"<([a-z0-9]+)\\\\s+[^>]*onclick=\\\"[a-z.]*location(?:\\\\.href)\\\\s*=\\\\s*'([^']+)[^>]*>([^<]+)</\\\\1>\",\n                                        QRegularExpression::CaseInsensitiveOption ),\n                    \"<a href=\\\"\\\\2\\\">\\\\3</a>\")\n           .replace( QRegularExpression( \"(<\\\\s*a\\\\s+[^>]*href\\\\s*=\\\\s*[\\\"']\\\\s*)bword://\",\n                                         QRegularExpression::CaseInsensitiveOption ),\n                     \"\\\\1bword:\" )\n          //remove invalid width, height attrs\n          .replace( QRegularExpression( \"(width|height)\\\\s*=\\\\s*[\\\"']\\\\d{7,}[\\\"'']\" ),\n                   \"\" )\n          //remove invalid <br> tag\n          .replace( QRegularExpression( \"<br>(<div|<table|<tbody|<tr|<td|</div>|</table>|</tbody>|</tr>|</td>|function addScript|var scNode|scNode|var atag|while\\\\(atag|atag=atag|document\\\\.getElementsByTagName|addScript|src=\\\"bres|<a onmouseover=\\\"return overlib|onclick=\\\"return overlib)\",\n                                        QRegularExpression::CaseInsensitiveOption ),\n                    \"\\\\1\" )\n          .replace( QRegularExpression( \"(AUTOSTATUS, WRAP\\\\);\\\" |</DIV>|addScript\\\\('JS_FILE_PHONG_VT_45634'\\\\);|appendChild\\\\(scNode\\\\);|atag\\\\.firstChild;)<br>\",\n                                        QRegularExpression::CaseInsensitiveOption ),\n                    \" \\\\1 \" )\n           .toUtf8().data();\n#else\n  result = QString::fromUtf8( result.c_str() )\n          // onclick location to link\n          .replace( QRegExp( \"<([a-z0-9]+)\\\\s+[^>]*onclick=\\\"[a-z.]*location(?:\\\\.href)\\\\s*=\\\\s*'([^']+)[^>]*>([^<]+)</\\\\1>\", Qt::CaseInsensitive ),\n                    \"<a href=\\\"\\\\2\\\">\\\\3</a>\")\n           .replace( QRegExp( \"(<\\\\s*a\\\\s+[^>]*href\\\\s*=\\\\s*[\\\"']\\\\s*)bword://\", Qt::CaseInsensitive ),\n                     \"\\\\1bword:\" )\n          //remove invalid width, height attrs\n          .replace(QRegExp( \"(width|height)\\\\s*=\\\\s*[\\\"']\\\\d{7,}[\\\"'']\" ),\n                   \"\" )\n          //remove invalid <br> tag\n          .replace( QRegExp( \"<br>(<div|<table|<tbody|<tr|<td|</div>|</table>|</tbody>|</tr>|</td>|function addScript|var scNode|scNode|var atag|while\\\\(atag|atag=atag|document\\\\.getElementsByTagName|addScript|src=\\\"bres|<a onmouseover=\\\"return overlib|onclick=\\\"return overlib)\", Qt::CaseInsensitive ),\n                    \"\\\\1\" )\n          .replace( QRegExp( \"(AUTOSTATUS, WRAP\\\\);\\\" |</DIV>|addScript\\\\('JS_FILE_PHONG_VT_45634'\\\\);|appendChild\\\\(scNode\\\\);|atag\\\\.firstChild;)<br>\", Qt::CaseInsensitive ),\n                    \" \\\\1 \" )\n           .toUtf8().data();\n#endif\n\n  Mutex::Lock _( dataMutex );\n\n  data.resize( result.size() );\n\n  memcpy( &data.front(), result.data(), result.size() );\n\n  hasAnyData = true;\n\n  finish();\n}\n\nsptr< Dictionary::DataRequest > BglDictionary::getArticle( wstring const & word,\n                                                           vector< wstring > const & alts,\n                                                           wstring const &,\n                                                           bool ignoreDiacritics )\n  THROW_SPEC( std::exception )\n{\n  return new BglArticleRequest( word, alts, *this, ignoreDiacritics );\n}\n\n\n//// BglDictionary::getResource()\n\nclass BglResourceRequest;\n\nclass BglResourceRequestRunnable: public QRunnable\n{\n  BglResourceRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  BglResourceRequestRunnable( BglResourceRequest & r_,\n                              QSemaphore & hasExited_ ): r( r_ ),\n                                                         hasExited( hasExited_ )\n  {}\n\n  ~BglResourceRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass BglResourceRequest: public Dictionary::DataRequest\n{\n  friend class BglResourceRequestRunnable;\n\n  Mutex & idxMutex;\n  File::Class & idx;\n  uint32_t resourceListOffset, resourcesCount;\n  string name;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  BglResourceRequest( Mutex & idxMutex_,\n                      File::Class & idx_,\n                      uint32_t resourceListOffset_,\n                      uint32_t resourcesCount_,\n                      string const & name_ ):\n    idxMutex( idxMutex_ ),\n    idx( idx_ ),\n    resourceListOffset( resourceListOffset_ ),\n    resourcesCount( resourcesCount_ ),\n    name( name_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new BglResourceRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by BglResourceRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~BglResourceRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid BglResourceRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid BglResourceRequest::run()\n{\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  string nameLowercased = name;\n\n  for( string::iterator i = nameLowercased.begin(); i != nameLowercased.end();\n       ++i )\n    *i = tolower( *i );\n\n  Mutex::Lock _( idxMutex );\n\n  idx.seek( resourceListOffset );\n\n  for( size_t count = resourcesCount; count--; )\n  {\n    if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      break;\n\n    vector< char > nameData( idx.read< uint32_t >() );\n    idx.read( &nameData.front(), nameData.size() );\n\n    for( size_t x = nameData.size(); x--; )\n      nameData[ x ] = tolower( nameData[ x ] );\n\n    uint32_t offset = idx.read< uint32_t >();\n\n    if ( string( &nameData.front(), nameData.size() ) == nameLowercased )\n    {\n      // We have a match.\n\n      idx.seek( offset );\n\n      Mutex::Lock _( dataMutex );\n\n      data.resize( idx.read< uint32_t >() );\n\n      vector< unsigned char > compressedData( idx.read< uint32_t >() );\n\n      idx.read( &compressedData.front(), compressedData.size() );\n\n      unsigned long decompressedLength = data.size();\n\n      if ( uncompress( (unsigned char *) &data.front(),\n                       &decompressedLength,\n                       &compressedData.front(),\n                       compressedData.size() ) != Z_OK ||\n           decompressedLength != data.size() )\n      {\n        gdWarning( \"Failed to decompress resource \\\"%s\\\", ignoring it.\\n\", name.c_str() );\n      }\n      else\n        hasAnyData = true;\n\n      break;\n    }\n  }\n\n  finish();\n}\n\nsptr< Dictionary::DataRequest > BglDictionary::getResource( string const & name )\n  THROW_SPEC( std::exception )\n{\n  return new BglResourceRequest( idxMutex, idx, idxHeader.resourceListOffset,\n                                 idxHeader.resourcesCount, name );\n}\n\n  /// Replaces <CHARSET c=\"t\">1234;</CHARSET> occurrences with &#x1234;\n  void BglDictionary::replaceCharsetEntities( string & text )\n  {\n    QString str = QString::fromUtf8( text.c_str() );\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n    QRegularExpression charsetExp( \"<\\\\s*charset\\\\s+c\\\\s*=\\\\s*[\\\"']?t[\\\"']?\\\\s*>((?:\\\\s*[0-9a-fA-F]+\\\\s*;\\\\s*)*)<\\\\s*/\\\\s*charset\\\\s*>\",\n                                   QRegularExpression::CaseInsensitiveOption\n                                   | QRegularExpression::InvertedGreedinessOption );\n\n    QRegularExpression oneValueExp( \"\\\\s*([0-9a-fA-F]+)\\\\s*;\" );\n    QString result;\n    int pos = 0;\n\n    QRegularExpressionMatchIterator it = charsetExp.globalMatch( str );\n    while( it.hasNext() )\n    {\n      QRegularExpressionMatch match = it.next();\n      result += str.midRef( pos, match.capturedStart() - pos );\n      pos = match.capturedEnd();\n\n      QRegularExpressionMatchIterator itValue = oneValueExp.globalMatch( match.captured( 1 ) );\n      while( itValue.hasNext() )\n      {\n        QRegularExpressionMatch matchValue = itValue.next();\n        result += \"&#x\" + matchValue.captured( 1 ) + \";\";\n      }\n    }\n\n    if( pos )\n    {\n      result += str.midRef( pos );\n      str = result;\n    }\n#else\n    QRegExp charsetExp( \"<\\\\s*charset\\\\s+c\\\\s*=\\\\s*[\\\"']?t[\\\"']?\\\\s*>((?:\\\\s*[0-9a-fA-F]+\\\\s*;\\\\s*)*)<\\\\s*/\\\\s*charset\\\\s*>\",\n                        Qt::CaseInsensitive );\n\n    charsetExp.setMinimal( true );\n    \n    QRegExp oneValueExp( \"\\\\s*([0-9a-fA-F]+)\\\\s*;\" );\n\n    for( int pos = 0; ( pos = charsetExp.indexIn( str, pos ) ) != -1; )\n    {\n      //DPRINTF( \"Match: %s\\n\", str.mid( pos, charsetExp.matchedLength() ).toUtf8().data() );\n      \n      QString out;\n\n      for( int p = 0; ( p = oneValueExp.indexIn( charsetExp.cap( 1 ), p ) ) != -1; )\n      {\n        //DPRINTF( \"Cap: %s\\n\", oneValueExp.cap( 1 ).toUtf8().data() );\n        out += \"&#x\" + oneValueExp.cap( 1 ) + \";\";\n\n        p += oneValueExp.matchedLength();\n      }\n\n      str.replace( pos, charsetExp.matchedLength(), out );\n    }\n#endif\n\n    text = str.toUtf8().data();\n  }\n\n  class ResourceHandler: public Babylon::ResourceHandler\n  {\n    File::Class & idxFile;\n    list< pair< string, uint32_t > > resources;\n\n  public:\n\n    ResourceHandler( File::Class & idxFile_ ): idxFile( idxFile_ )\n    {}\n\n    list< pair< string, uint32_t > > const & getResources() const\n    { return resources; }\n\n  protected:\n    virtual void handleBabylonResource( string const & filename,\n                                        char const * data, size_t size );\n  };\n\n  void ResourceHandler::handleBabylonResource( string const & filename,\n                                               char const * data, size_t size )\n  {\n    //DPRINTF( \"Handling resource file %s (%u bytes)\\n\", filename.c_str(), size );\n\n    vector< unsigned char > compressedData( compressBound( size ) );\n\n    unsigned long compressedSize = compressedData.size();\n\n    if ( compress( &compressedData.front(), &compressedSize,\n                   (unsigned char const *) data, size ) != Z_OK )\n    {\n      gdWarning( \"Failed to compress the body of resource \\\"%s\\\", dropping it.\\n\", filename.c_str() );\n      return;\n    }\n\n    resources.push_back( pair< string, uint32_t >( filename, idxFile.tell() ) );\n\n    idxFile.write< uint32_t >( size );\n    idxFile.write< uint32_t >( compressedSize );\n    idxFile.write( &compressedData.front(), compressedSize );\n  }\n}\n\nsptr< Dictionary::DataRequest > BglDictionary::getSearchResults( QString const & searchString,\n                                                                 int searchMode, bool matchCase,\n                                                                 int distanceBetweenWords,\n                                                                 int maxResults,\n                                                                 bool ignoreWordsOrder,\n                                                                 bool ignoreDiacritics,\n                                                                 QThreadPool * ftsThreadPoolPtr )\n{\n  return new FtsHelpers::FTSResultsRequest( *this, searchString,searchMode, matchCase, distanceBetweenWords, maxResults, ignoreWordsOrder, ignoreDiacritics, ftsThreadPoolPtr );\n}\n\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing & initializing )\n  THROW_SPEC( std::exception )\n{\n  vector< sptr< Dictionary::Class > > dictionaries;\n\n  for( vector< string >::const_iterator i = fileNames.begin(); i != fileNames.end();\n       ++i )\n  {\n    // Skip files with the extensions different to .bgl to speed up the\n    // scanning\n    if ( i->size() < 4 ||\n        strcasecmp( i->c_str() + ( i->size() - 4 ), \".bgl\" ) != 0 )\n      continue;\n\n    // Got the file -- check if we need to rebuid the index\n\n    vector< string > dictFiles( 1, *i );\n\n    string dictId = Dictionary::makeDictionaryId( dictFiles );\n\n    string indexFile = indicesDir + dictId;\n\n    if ( Dictionary::needToRebuildIndex( dictFiles, indexFile ) ||\n         indexIsOldOrBad( indexFile ) )\n    {\n      // Building the index\n\n      gdDebug( \"Bgl: Building the index for dictionary: %s\\n\", i->c_str() );\n\n      try\n      {\n        Babylon b( *i );\n\n        if ( !b.open() )\n          continue;\n\n        std::string sourceCharset, targetCharset;\n\n        if ( !b.read( sourceCharset, targetCharset ) )\n        {\n          gdWarning( \"Failed to start reading from %s, skipping it\\n\", i->c_str() );\n          continue;\n        }\n\n        initializing.indexingDictionary( b.title() );\n\n        File::Class idx( indexFile, \"wb\" );\n\n        IdxHeader idxHeader;\n\n        memset( &idxHeader, 0, sizeof( idxHeader ) );\n\n        // We write a dummy header first. At the end of the process the header\n        // will be rewritten with the right values.\n\n        idx.write( idxHeader );\n\n        idx.write< uint32_t >( b.title().size() );\n        idx.write( b.title().data(), b.title().size() );\n\n        // This is our index data that we accumulate during the loading process.\n        // For each new word encountered, we emit the article's body to the file\n        // immediately, inserting the word itself and its offset in this map.\n        // This map maps folded words to the original words and the corresponding\n        // articles' offsets.\n        IndexedWords indexedWords;\n\n        // We use this buffer to decode utf8 into it.\n        vector< wchar > wcharBuffer;\n\n        ChunkedStorage::Writer chunks( idx );\n\n        uint32_t articleCount = 0, wordCount = 0;\n\n        ResourceHandler resourceHandler( idx );\n\n        b.setResourcePrefix( string( \"bres://\" ) + dictId + \"/\" );\n\n        // Save icon if there's one\n        if ( size_t sz = b.getIcon().size() )\n        {\n          idxHeader.iconAddress = chunks.startNewBlock();\n          chunks.addToBlock( &b.getIcon().front(), sz );\n          idxHeader.iconSize = sz;\n        }\n\n        // Save dictionary description if there's one\n        idxHeader.descriptionSize = 0;\n        idxHeader.descriptionAddress = chunks.startNewBlock();\n\n        chunks.addToBlock( b.copyright().c_str(), b.copyright().size() + 1 );\n        idxHeader.descriptionSize += b.copyright().size() + 1;\n\n        chunks.addToBlock( b.author().c_str(), b.author().size() + 1 );\n        idxHeader.descriptionSize += b.author().size() + 1;\n\n        chunks.addToBlock( b.email().c_str(), b.email().size() + 1 );\n        idxHeader.descriptionSize += b.email().size() + 1;\n\n        chunks.addToBlock( b.description().c_str(), b.description().size() + 1 );\n        idxHeader.descriptionSize += b.description().size() + 1;\n\n        for( ; ; )\n        {\n          bgl_entry e = b.readEntry( &resourceHandler );\n\n          if ( e.headword.empty() )\n            break;\n\n          // Save the article's body itself first\n\n          uint32_t articleAddress = chunks.startNewBlock();\n\n          chunks.addToBlock( e.headword.c_str(), e.headword.size() + 1 );\n          chunks.addToBlock( e.displayedHeadword.c_str(), e.displayedHeadword.size() + 1 );\n          chunks.addToBlock( e.definition.c_str(), e.definition.size() + 1 );\n\n          // Add entries to the index\n\n          addEntryToIndex( e.headword, articleAddress, indexedWords, wcharBuffer );\n\n          for( unsigned x = 0; x < e.alternates.size(); ++x )\n            addEntryToIndex( e.alternates[ x ], articleAddress, indexedWords, wcharBuffer );\n\n          wordCount += 1 + e.alternates.size();\n          ++articleCount;\n        }\n\n        // Finish with the chunks\n\n        idxHeader.chunksOffset = chunks.finish();\n\n        GD_DPRINTF( \"Writing index...\\n\" );\n\n        // Good. Now build the index\n\n        IndexInfo idxInfo = BtreeIndexing::buildIndex( indexedWords, idx );\n\n        idxHeader.indexBtreeMaxElements = idxInfo.btreeMaxElements;\n        idxHeader.indexRootOffset = idxInfo.rootOffset;\n\n        // Save the resource's list.\n\n        idxHeader.resourceListOffset = idx.tell();\n        idxHeader.resourcesCount = resourceHandler.getResources().size();\n\n        for( list< pair< string, uint32_t > >::const_iterator j =\n            resourceHandler.getResources().begin();\n             j != resourceHandler.getResources().end(); ++j )\n        {\n          idx.write< uint32_t >( j->first.size() );\n          idx.write( j->first.data(), j->first.size() );\n          idx.write< uint32_t >( j->second );\n        }\n\n        // That concludes it. Update the header.\n\n        idxHeader.signature = Signature;\n        idxHeader.formatVersion = CurrentFormatVersion;\n        idxHeader.parserVersion = Babylon::ParserVersion;\n        idxHeader.foldingVersion = Folding::Version;\n        idxHeader.articleCount = articleCount;\n        idxHeader.wordCount = wordCount;\n        idxHeader.langFrom = b.sourceLang();//LangCoder::findIdForLanguage( Utf8::decode( b.sourceLang() ) );\n        idxHeader.langTo = b.targetLang();//LangCoder::findIdForLanguage( Utf8::decode( b.targetLang() ) );\n\n        idx.rewind();\n\n        idx.write( &idxHeader, sizeof( idxHeader ) );\n      }\n      catch( std::exception & e )\n      {\n        gdWarning( \"BGL dictionary indexing failed: %s, error: %s\\n\",\n                   i->c_str(), e.what() );\n      }\n    }\n\n    try\n    {\n      dictionaries.push_back( new BglDictionary( dictId,\n                                                 indexFile,\n                                                 *i ) );\n    }\n    catch( std::exception & e )\n    {\n      gdWarning( \"BGL dictionary initializing failed: %s, error: %s\\n\",\n                 i->c_str(), e.what() );\n    }\n  }\n\n  return dictionaries;\n}\n\n}\n"
        },
        {
          "name": "bgl.hh",
          "type": "blob",
          "size": 1.1103515625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __BGL_HH_INCLUDED__\n#define __BGL_HH_INCLUDED__\n\n#include \"dictionary.hh\"\n\n/// Support for the Babylon's .bgl dictionaries.\nnamespace Bgl {\n\nusing std::vector;\nusing std::string;\n\n/// Goes through the given list of file names, trying each one as a possible\n/// dictionary. Upon finding one, creates a corresponding dictionary instance.\n/// As a result, a list of dictionaries is created.\n/// indicesDir indicates a directory where index files can be created, should\n/// there be need for them. The index file name would be the same as the\n/// dictionary's id, made by makeDictionaryId() from the list of file names.\n/// Any exception thrown would terminate the program with an error.\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                    vector< string > const & fileNames,\n                                    string const & indicesDir,\n                                    Dictionary::Initializing & )\n  THROW_SPEC( std::exception );\n\n}\n\n#endif\n"
        },
        {
          "name": "bgl_babylon.cc",
          "type": "blob",
          "size": 23.478515625,
          "content": "/***************************************************************************\n *   Copyright (C) 2007 by Raul Fernandes and Karl Grill                   *\n *   rgbr@yahoo.com.br                                                     *\n *                                                                         *\n *   This program is free software; you can redistribute it and/or modify  *\n *   it under the terms of the GNU General Public License as published by  *\n *   the Free Software Foundation; either version 2 of the License, or     *\n *   (at your option) any later version.                                   *\n *                                                                         *\n *   This program is distributed in the hope that it will be useful,       *\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *\n *   GNU General Public License for more details.                          *\n *                                                                         *\n *   You should have received a copy of the GNU General Public License     *\n *   along with this program; if not, write to the                         *\n *   Free Software Foundation, Inc.,                                       *\n *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *\n ***************************************************************************/\n\n/* Various improvements were made by Konstantin Isakov for the GoldenDict\n * program. */\n\n#include \"bgl_babylon.hh\"\n#include <algorithm>\n#include <cerrno>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <iconv.h>\n#include <QTextDocument>\n#include \"gddebug.hh\"\n#include \"ufile.hh\"\n#include \"iconv.hh\"\n#include \"htmlescape.hh\"\n#include <QString>\n#include <QDebug>\n#include \"dictionary.hh\"\n\n#ifdef _WIN32\n#include <io.h>\n#define DUP _dup\n#else\n#include <unistd.h>\n#define DUP dup\n#endif\n\nusing std::string;\n\nDEF_EX_STR( exCantReadFile, \"Can't read file\", Dictionary::Ex )\nDEF_EX( exUserAbort, \"User abort\", Dictionary::Ex )\nDEF_EX( exIconv, \"Iconv library error\", Dictionary::Ex )\nDEF_EX( exAllocation, \"Error memory allocation\", Dictionary::Ex )\n\nBabylon::Babylon( std::string filename ) :\nm_filename( filename )\n{\n  file = NULL;\n}\n\n\nBabylon::~Babylon()\n{\n  close();\n}\n\n\nbool Babylon::open()\n{\n  FILE *f;\n  unsigned char buf[6];\n  int i;\n\n  f = gd_fopen( m_filename.c_str(), \"rb\" );\n  if( f == NULL )\n    return false;\n\n  i = fread( buf, 1, 6, f );\n\n  /* First four bytes: BGL signature 0x12340001 or 0x12340002 (big-endian) */\n  if( i < 6 || memcmp( buf, \"\\x12\\x34\\x00\", 3 ) || buf[3] == 0 || buf[3] > 2 )\n  {\n    fclose( f );\n    return false;\n  }\n\n  /* Calculate position of gz header */\n\n  i = buf[4] << 8 | buf[5];\n\n  if( i < 6 )\n  {\n    fclose( f );\n    return false;\n  }\n\n  if( fseek( f, i, SEEK_SET ) ) /* can't seek - emulate */\n      for(int j=0;j < i - 6;j++) fgetc( f );\n\n  if( ferror( f ) || feof( f ) )\n  {\n    fclose( f );\n    return false;\n  }\n\n  /* we need to flush the file because otherwise some nfs mounts don't seem\n   * to properly update the file position for the following reopen */\n\n  fflush( f );\n\n#ifdef Q_OS_MAC\n  /* Under Mac OS X the above technique don't set reopen position properly */\n  int fn = DUP( fileno( f ) );\n  lseek( fn, i, SEEK_SET );\n  file = gzdopen( fn, \"r\" );\n#else\n  file = gzdopen( DUP( fileno( f ) ), \"r\" );\n#endif\n\n  fclose( f );\n\n  if( file == NULL )\n    return false;\n\n  return true;\n}\n\n\nvoid Babylon::close()\n{\n  if ( file )\n  {\n    gzclose( file );\n    file = 0;\n  }\n}\n\n\nbool Babylon::readBlock( bgl_block &block )\n{\n  if( gzeof( file ) || file == NULL )\n    return false;\n\n  block.length = bgl_readnum( 1 );\n  block.type = block.length & 0xf;\n  if( block.type == 4 ) return false; // end of file marker\n  block.length >>= 4;\n  block.length = block.length < 4 ? bgl_readnum( block.length + 1 ) : block.length - 4 ;\n  if( block.length )\n  {\n    block.data = (char *)malloc( block.length );\n    if( !block.data )\n      throw exAllocation();\n\n    unsigned res = gzread( file, block.data, block.length );\n    if( block.length != res )\n    {\n      free( block.data );\n      block.length = 0;\n      gzclearerr( file );\n      return false;\n    }\n  }\n\n  return true;\n}\n\n\nunsigned int Babylon::bgl_readnum( int bytes )\n{\n  unsigned char buf[4];\n  unsigned val = 0;\n\n  if ( bytes < 1 || bytes > 4 ) return (0);\n\n  int res = gzread( file, buf, bytes );\n\n  if( res != bytes )\n  {\n    gzclearerr( file );\n    return 4;  // Read error - return end of file marker\n  }\n\n  for(int i=0;i<bytes;i++) val= (val << 8) | buf[i];\n  return val;\n}\n\n\nbool Babylon::read(std::string &source_charset, std::string &target_charset)\n{\n  if( file == NULL ) return false;\n\n  bgl_block block;\n  unsigned int pos;\n  unsigned int type;\n  std::string headword;\n  std::string definition;\n\n  bool isUtf8File = false;\n\n  m_sourceCharset = source_charset;\n  m_targetCharset = target_charset;\n  m_numEntries = 0;\n  while( readBlock( block ) )\n  {\n    headword.clear();\n    definition.clear();\n    switch( block.type )\n    {\n      case 0:\n        switch( block.data[0] )\n        {\n          case 8:\n            type = (unsigned int)block.data[2];\n            if( type > 64 ) type -= 65;\n            if ( type >= 14 )\n              type = 0;\n            m_defaultCharset = bgl_charset[type];\n            break;\n          default:\n            break;\n        }\n        break;\n      case 1:\n      case 7:\n      case 10:\n      case 11:\n        // Only count entries\n        m_numEntries++;\n        break;\n      case 3:\n        pos = 2;\n        switch( block.data[1] )\n        {\n          case 1:\n            headword.reserve( block.length - 2 );\n            for(unsigned int a=0;a<block.length-2;a++) headword += block.data[pos++];\n            m_title = headword;\n            break;\n          case 2:\n            headword.reserve( block.length - 2 );\n            for(unsigned int a=0;a<block.length-2;a++) headword += block.data[pos++];\n            m_author = headword;\n            break;\n          case 3:\n            headword.reserve( block.length - 2 );\n            for(unsigned int a=0;a<block.length-2;a++) headword += block.data[pos++];\n            m_email = headword;\n            break;\n          case 4:\n            headword.reserve( block.length - 2 );\n            for(unsigned int a=0;a<block.length-2;a++) headword += block.data[pos++];\n            m_copyright = headword;\n            break;\n          case 7:\n            m_sourceLang = bgl_language[(unsigned char)(block.data[5])];\n            //m_sourceLang = headword;\n            break;\n          case 8:\n            m_targetLang = bgl_language[(unsigned char)(block.data[5])];\n            //m_targetLang = headword;\n            break;\n          case 9:\n            headword.reserve( block.length - 2 );\n            for(unsigned int a=0;a<block.length-2;a++) {\n              if (block.data[pos] == '\\r') {\n              } else if (block.data[pos] == '\\n') {\n                headword += \"<br>\";\n              } else {\n                headword += block.data[pos];\n              }\n              pos++;\n            }\n            m_description = headword;\n            break;\n          case 11:\n            icon.resize( block.length - 2 );\n            memcpy( &icon.front(), &(block.data[ 2 ]), icon.size() );\n          break;\n          case 17:\n            if ( block.length >= 5 && ( (unsigned char) block.data[ 4 ] & 0x80 ) != 0 )\n              isUtf8File = true;\n          break;\n          case 26:\n            type = (unsigned int)block.data[2];\n            if( type > 64 ) type -= 65;\n            if ( type >= 14 )\n              type = 0;\n            if (m_sourceCharset.empty())\n              m_sourceCharset = bgl_charset[type];\n            break;\n          case 27:\n            type = (unsigned int)block.data[2];\n            if( type > 64 ) type -= 65;\n            if ( type >= 14 )\n              type = 0;\n            if (m_targetCharset.empty())\n              m_targetCharset = bgl_charset[type];\n            break;\n          default:\n            break;\n        }\n        break;\n      default:\n        ;\n    }\n    if( block.length ) free( block.data );\n  }\n  gzseek( file, 0, SEEK_SET );\n\n  if ( isUtf8File )\n  {\n    //FDPRINTF( stderr, \"%s: utf8 file.\\n\", m_title.c_str() );\n    m_defaultCharset = \"UTF-8\";\n    m_sourceCharset = \"UTF-8\";\n    m_targetCharset = \"UTF-8\";\n  }\n\n  convertToUtf8( m_title, BGL_TARGET_CHARSET );\n  convertToUtf8( m_author, BGL_TARGET_CHARSET );\n  convertToUtf8( m_email, BGL_TARGET_CHARSET );\n  convertToUtf8( m_copyright, BGL_TARGET_CHARSET );\n  convertToUtf8( m_description, BGL_TARGET_CHARSET );\n  GD_DPRINTF(\"Default charset: %s\\nSource Charset: %s\\nTargetCharset: %s\\n\", m_defaultCharset.c_str(), m_sourceCharset.c_str(), m_targetCharset.c_str());\n  return true;\n}\n\n\nbgl_entry Babylon::readEntry( ResourceHandler * resourceHandler )\n{\n  bgl_entry entry;\n\n  if( file == NULL )\n  {\n    entry.headword = \"\";\n    return entry;\n  }\n\n  bgl_block block;\n  unsigned int len, pos;\n  unsigned int alts_num;\n  std::string headword, displayedHeadword;\n  std::string definition;\n  std::string temp;\n  std::vector<std::string> alternates;\n  std::string alternate;\n  std::string root;\n  bool defBodyEnded = false;\n  std::string transcription;\n\n  while( readBlock( block ) )\n  {\n    switch( block.type )\n    {\n      case 2:\n      {\n        pos = 0;\n        len = (unsigned char)block.data[pos++];\n        if( pos + len > block.length )\n          break;\n        std::string filename( block.data+pos, len );\n        //if (filename != \"8EAF66FD.bmp\" && filename != \"C2EEF3F6.html\") {\n            pos += len;\n        if ( resourceHandler )\n          resourceHandler->handleBabylonResource( filename,\n                                                  block.data + pos,\n                                                  block.length - pos );\n    #if 0\n            FILE *ifile = gd_fopen(filename.c_str(), \"w\");\n            fwrite(block.data + pos, 1, block.length -pos, ifile);\n            fclose(ifile);\n    #endif\n        break;\n      }\n      case 1:\n      case 7:\n      case 10:\n      case 11:\n        alternate.clear();\n        headword.clear();\n        displayedHeadword.clear();\n        root.clear();\n        definition.clear();\n        temp.clear();\n        pos = 0;\n\n        // Headword\n        if( block.type == 11 )\n        {\n          pos = 1;\n          if( pos + 4 > block.length )\n            break;\n          len = qFromBigEndian( *reinterpret_cast< quint32 * >( block.data + pos ) );\n          pos += 4;\n        }\n        else\n        {\n          len = (unsigned char)block.data[pos++];\n        }\n\n        if( pos + len > block.length )\n          break;\n\n        headword.reserve( len );\n        for(unsigned int a=0;a<len;a++)\n          headword += block.data[pos++];\n\n        convertToUtf8( headword, BGL_SOURCE_CHARSET );\n\n        // Try to repair malformed headwords\n        if( headword.find( \"&#\" ) != string::npos )\n          headword = Html::unescapeUtf8( headword );\n\n        if( block.type == 11 )\n        {\n          // Alternate forms\n          if( pos + 4 >= block.length )\n            break;\n\n          alts_num = qFromBigEndian( *reinterpret_cast< quint32 * >( block.data + pos ) );\n          pos += 4;\n\n          for( unsigned j = 0; j < alts_num; j++ )\n          {\n            if( pos + 4 > block.length )\n              break;\n            len = qFromBigEndian( *reinterpret_cast< quint32 * >( block.data + pos ) );\n            pos += 4;\n\n            if( pos + len >= block.length )\n              break;\n            alternate.reserve( len );\n            for(unsigned int a=0;a<len;a++) alternate += block.data[pos++];\n            convertToUtf8( alternate, BGL_SOURCE_CHARSET );\n\n            // Try to repair malformed forms\n            if( alternate.find( \"&#\" ) != string::npos )\n              alternate = Html::unescapeUtf8( alternate );\n\n            alternates.push_back( alternate );\n            alternate.clear();\n          }\n        }\n\n        // Definition\n\n        if( block.type == 11 )\n        {\n          if( pos + 4 > block.length )\n            break;\n          len = qFromBigEndian( *reinterpret_cast< quint32 * >( block.data + pos ) );\n          pos += 4;\n        }\n        else\n        {\n          len = qFromBigEndian( *reinterpret_cast< quint16 * >( block.data + pos ) );\n          pos += 2;\n        }\n\n        if( pos + len > block.length )\n          break;\n\n        definition.reserve( len );\n\n        for(unsigned int a=0;a<len;a++)\n        {\n          if( (unsigned char)block.data[pos] == 0x0a )\n          {\n            definition += \"<br>\";\n            pos++;\n          }\n          else if ( (unsigned char)block.data[pos] == 6 )\n          {\n            // Something\n            pos += 2;\n            ++a;\n            definition += \" \";\n          }\n          else if ( (unsigned char)block.data[pos] >= 0x40 &&\n                    len - a >= 2 &&\n                    (unsigned char)block.data[pos + 1 ] == 0x18 )\n          {\n            // Hidden displayed headword (a displayed headword which\n            // contains some garbage and shouldn't probably be visible).\n            unsigned length = (unsigned char)block.data[ pos ] - 0x3F;\n\n            if ( length > len - a - 2 )\n            {\n              GD_FDPRINTF( stderr, \"Hidden displayed headword is too large %s\\n\", headword.c_str() );\n              pos += len - a;\n              break;\n            }\n\n            pos += length + 2;\n            a += length + 1;\n          }\n          else if ( (unsigned char)block.data[pos] == 0x18 )\n          {\n            // Displayed headword\n              unsigned length = (unsigned char)block.data[ pos + 1 ];\n\n            if ( length > len - a - 2 )\n            {\n              GD_FDPRINTF( stderr, \"Displayed headword's length is too large for headword %s\\n\", headword.c_str() );\n              pos += len - a;\n              break;\n            }\n\n            displayedHeadword = std::string( block.data + pos + 2, length );\n            pos += length + 2;\n            a += length + 1;\n          }\n          else\n          if ( block.data[ pos ] == 0x28 && defBodyEnded &&\n               len - a >= 3 )\n          {\n            // 2-byte sized displayed headword\n            unsigned length = qFromBigEndian( *reinterpret_cast< quint16 * >( block.data + pos + 1 ) );\n\n            if ( length > len - a - 3 )\n            {\n              GD_FDPRINTF( stderr, \"2-byte sized displayed headword for %s is too large\\n\", headword.c_str() );\n              pos += len - a;\n              break;\n            }\n\n            displayedHeadword = std::string( block.data + pos + 3, length );\n\n            pos += length + 3;\n            a += length + 2;\n          }\n          else if ( (unsigned char)block.data[pos] == 0x50 && len - a - 1 >= 2 &&\n                    (unsigned char)block.data[pos + 1 ] == 0x1B )\n          {\n            // 1-byte-sized transcription\n            unsigned length = (unsigned char)block.data[pos + 2 ];\n\n            if ( length > len - a - 3 )\n            {\n              GD_FDPRINTF( stderr, \"1-byte-sized transcription's length is too large for headword %s\\n\", headword.c_str() );\n              pos += len - a;\n              break;\n            }\n\n            if( m_targetCharset.compare( \"UTF-8\" ) != 0 )\n            {\n              try\n              {\n                transcription = Iconv::toUtf8( \"CP1252\", block.data + pos + 3, length );\n              }\n              catch( Iconv::Ex & e )\n              {\n                qWarning( \"Bgl: charset conversion error, no trancription processing's done: %s\\n\", e.what() );\n                transcription = std::string( block.data + pos + 3, length );\n              }\n            }\n            else\n              transcription = std::string( block.data + pos + 3, length );\n\n            pos += length + 3;\n            a += length + 2;\n          }\n          else if ( (unsigned char)block.data[pos] == 0x60 && len - a - 1 >= 3 &&\n                    (unsigned char)block.data[pos + 1 ] == 0x1B )\n          {\n            // 2-byte-sized transcription\n            unsigned length = qFromBigEndian( *reinterpret_cast< quint16 * >( block.data + pos + 2 ) );\n\n            if ( length > len - a - 4)\n            {\n              GD_FDPRINTF( stderr, \"2-byte-sized transcription's length is too large for headword %s\\n\", headword.c_str() );\n              pos += len - a;\n              break;\n            }\n\n            if( m_targetCharset.compare( \"UTF-8\" ) != 0 )\n            {\n              try\n              {\n                transcription = Iconv::toUtf8( \"CP1252\", block.data + pos + 4, length );\n              }\n              catch( Iconv::Ex & e )\n              {\n                qWarning( \"Bgl: charset conversion error, no trancription processing's done: %s\\n\", e.what() );\n                transcription = std::string( block.data + pos + 4, length );\n              }\n            }\n            else\n              transcription = std::string( block.data + pos + 4, length );\n\n            pos += length + 4;\n            a += length + 3;\n          }\n          else if ( (unsigned char)block.data[pos] >= 0x40 &&\n                    len - a >= 2 &&\n                    (unsigned char)block.data[pos + 1 ] == 0x1B )\n          {\n            // Hidden transcription (a transcription which is usually the same\n            // as the headword and shouldn't probably be visible).\n            unsigned length = (unsigned char)block.data[ pos ] - 0x3F;\n\n            if ( length > len - a - 2 )\n            {\n              GD_FDPRINTF( stderr, \"Hidden transcription is too large %s\\n\", headword.c_str() );\n              pos += len - a;\n              break;\n            }\n\n            pos += length + 2;\n            a += length + 1;\n          }\n          else if ( (unsigned char)block.data[pos] == 0x1E )\n          {\n            // Resource reference begin marker\n            definition += m_resourcePrefix;\n            ++pos;\n          }\n          else if ( (unsigned char)block.data[pos] == 0x1F )\n          {\n            // Resource reference end marker\n            ++pos;\n          }\n          else if( (unsigned char)block.data[pos] < 0x20 )\n          {\n            if( a <= len - 3 && block.data[pos] == 0x14 && block.data[pos+1] == 0x02 ) {\n              int index = (unsigned char)block.data[pos+2] - 0x30;\n              if (index >= 0 && index <= 10) {\n                definition = \"<span class=\\\"bglpos\\\">\" + partOfSpeech[index] + \"</span> \" + definition;\n              }\n              pos += 3;\n              a += 2;\n              //pos += len - a;\n              //break;\n            }\n            else\n            if (block.data[pos] == 0x14) {\n              defBodyEnded = true; // Presumably\n              pos++;\n            } else if ((unsigned char)block.data[pos] == 0x1A){\n                unsigned length = (unsigned char)block.data[ pos + 1 ];\n                if (length <= 10){// 0x1A identifies two different data types.\n                                  // data about the Hebrew root should be shorter then\n                                  // 10 bytes, and in the other data type the byte\n                          // after 0x1A is > 10 (at least it is in Bybylon's\n                          // Hebrew dictionaries).   \n                    root = std::string( block.data + pos + 2, length );\n                    std::reverse(root.begin(),root.end());\n                    definition += \" (\" + root + \")\";\n                    pos += length + 2;\n                    a += length + 1;\n               }\n                else\n                    pos++;\n            } else {\n                definition += block.data[pos++];\n            }\n          }else definition += block.data[pos++];\n        }\n        convertToUtf8( definition, BGL_TARGET_CHARSET );\n        if( !transcription.empty() )\n          definition = std::string( \"<span class=\\\"bgltrn\\\">\" ) +  transcription + \"</span>\" + definition;\n\n        if ( displayedHeadword.size() )\n          convertToUtf8( displayedHeadword, BGL_TARGET_CHARSET );\n\n        // Alternate forms\n        while( pos < block.length )\n        {\n          len = (unsigned char)block.data[pos++];\n          if( pos + len > block.length ) break;\n          alternate.reserve( len );\n          for(unsigned int a=0;a<len;a++) alternate += block.data[pos++];\n          convertToUtf8( alternate, BGL_SOURCE_CHARSET );\n\n          // Try to repair malformed forms\n          if( alternate.find( \"&#\" ) != string::npos )\n            alternate = Html::unescapeUtf8( alternate );\n\n          alternates.push_back( alternate );\n          alternate.clear();\n        }\n\n        // Try adding displayed headword to the list of alts\n        if ( headword != displayedHeadword )\n        {\n          // Only add displayed headword if the normal one has two or more digits.\n          // This would indicate some irregularity in it (like e.g. if it serves\n          // as some kind of an identifier instead of being an actual headword)\n          int totalDigits = 0;\n\n          for( char const * p = headword.c_str(); *p; ++p )\n            if ( *p >= '0' && *p <= '9' )\n            {\n              if ( ++totalDigits > 1 )\n                break;\n            }\n\n          if ( totalDigits > 1 )\n          {\n            // Ok, let's add it.\n\n            // Does it contain HTML? If it does, we need to strip it\n            if ( displayedHeadword.find( '<' ) != string::npos ||\n                 displayedHeadword.find( '&' ) != string::npos )\n            {\n              string result = Html::unescapeUtf8( displayedHeadword );\n\n              if ( result != headword )\n                alternates.push_back( result );\n            }\n            else\n              alternates.push_back(displayedHeadword);\n          }\n        }\n\n        entry.headword = headword;\n\n        entry.displayedHeadword = displayedHeadword;\n        entry.definition = definition;\n\n        entry.alternates = alternates;\n\n        if( block.length ) free( block.data );\n\n        // Some dictionaries can in fact have an empty headword, so we\n        // make it non-empty here to differentiate between the end of entries.\n        if ( entry.headword.empty() )\n          entry.headword += ' ';\n\n        return entry;\n\n        break;\n      default:\n        ;\n    }\n    if( block.length ) free( block.data );\n  }\n  entry.headword = \"\";\n  return entry;\n}\n\n\n\nvoid Babylon::convertToUtf8( std::string &s, unsigned int type )\n{\n  if( s.size() < 1 ) return;\n  if( type > 2 ) return;\n\n  if( s.compare( 0, 13, \"<charset c=U>\") == 0 )\n      return;\n\n  std::string charset;\n  switch( type )\n  {\n    case BGL_DEFAULT_CHARSET:\n      if(!m_defaultCharset.empty()) charset = m_defaultCharset;\n      else charset = m_sourceCharset;\n      break;\n    case BGL_SOURCE_CHARSET:\n      if(!m_sourceCharset.empty()) charset = m_sourceCharset;\n      else charset = m_defaultCharset;\n      break;\n    case BGL_TARGET_CHARSET:\n      if(!m_targetCharset.empty()) charset = m_targetCharset;\n      else charset = m_defaultCharset;\n      break;\n    default:\n      ;\n  }\n\n  if( charset == \"UTF-8\" )\n    return;\n\n  iconv_t cd = iconv_open( \"UTF-8\", charset.c_str() );\n  if( cd == (iconv_t)(-1) )\n    throw exIconv();\n\n  char *outbuf, *defbuf;\n  size_t inbufbytes, outbufbytes;\n\n  inbufbytes = s.size();\n  outbufbytes = s.size() * 6;\n\n  char *inbuf;\n  inbuf = (char *)s.data();\n  outbuf = (char*)malloc( outbufbytes + 1 );\n  if( !outbuf )\n  {\n    iconv_close( cd );\n    throw exAllocation();\n  }\n\n  memset( outbuf, '\\0', outbufbytes + 1 );\n  defbuf = outbuf;\n  while (inbufbytes) {\n    if (iconv(cd, &inbuf, &inbufbytes, &outbuf, &outbufbytes) == (size_t)-1) {\n      gdWarning( \"\\\"%s\\\" - error in iconv conversion (%s)\\n\", inbuf, strerror( errno ) );\n      break;\n//      inbuf++;\n//      inbufbytes--;\n    }\n  }\n  \n  // Flush the state. This fixes CP1255 problems.\n  iconv( cd, 0, 0, &outbuf, &outbufbytes );\n  \n  if( inbufbytes == 0 )\n    s = std::string( defbuf );\n\n  free( defbuf );\n  iconv_close( cd );\n}\n"
        },
        {
          "name": "bgl_babylon.hh",
          "type": "blob",
          "size": 8.099609375,
          "content": "/***************************************************************************\n *   Copyright (C) 2007 by Raul Fernandes and Karl Grill                   *\n *   rgbr@yahoo.com.br                                                     *\n *                                                                         *\n *   This program is free software; you can redistribute it and/or modify  *\n *   it under the terms of the GNU General Public License as published by  *\n *   the Free Software Foundation; either version 2 of the License, or     *\n *   (at your option) any later version.                                   *\n *                                                                         *\n *   This program is distributed in the hope that it will be useful,       *\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *\n *   GNU General Public License for more details.                          *\n *                                                                         *\n *   You should have received a copy of the GNU General Public License     *\n *   along with this program; if not, write to the                         *\n *   Free Software Foundation, Inc.,                                       *\n *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *\n ***************************************************************************/\n\n#ifndef BABYLON_H\n#define BABYLON_H\n\n#include <stdlib.h>\n#include <zlib.h>\n\n#include <string>\n#include <vector>\n#include <qglobal.h>\n#if defined( _MSC_VER ) && _MSC_VER < 1800 // VS2012 and older\n#include <stdint_msvc.h>\n#else\n#include <stdint.h>\n#endif\n\n//const std::string bgl_language[] = {\n#ifndef blgCode2Int\n#define blgCode2Int( index, code0, code1 ) (((uint32_t)index) << 16 ) + (((uint32_t)code1) << 8 ) + (uint32_t)code0\n#endif\nconst quint32 bgl_language[] = {\n    blgCode2Int( 0, 'e', 'n' ),// \"English\",\n    blgCode2Int( 0, 'f', 'r' ),//\"French\",\n    blgCode2Int( 0, 'i', 't' ),//\"Italian\",\n    blgCode2Int( 0, 'e', 's' ),//\"Spanish\",\n    blgCode2Int( 0, 'n', 'l' ),//\"Dutch\",\n    blgCode2Int( 0, 'p', 't' ),//\"Portuguese\",\n    blgCode2Int( 0, 'd', 'e' ),//\"German\",\n    blgCode2Int( 0, 'r', 'u' ),//\"Russian\",\n    blgCode2Int( 0, 'j', 'a' ),//\"Japanese\",\n    blgCode2Int( 1, 'z', 'h' ),//\"\\x01\",//\"Traditional Chinese\",\n    blgCode2Int( 2, 'z', 'h' ),//\"\\x02\",//\"Simplified Chinese\",\n    blgCode2Int( 0, 'e', 'l' ),//\"Greek\",\n    blgCode2Int( 0, 'k', 'o' ),//\"Korean\",\n    blgCode2Int( 0, 't', 'r' ),//\"Turkish\",\n    blgCode2Int( 0, 'h', 'e' ),//\"Hebrew\",\n    blgCode2Int( 0, 'a', 'r' ),//\"Arabic\",\n    blgCode2Int( 0, 't', 'h' ),//\"Thai\",\n    blgCode2Int( 3, 0, 0 ),//\"\\x03\",//\"Other\",\n    blgCode2Int( 4, 'z', 'h' ),//\"\\x04\",//\"Other Simplified Chinese dialects\",\n    blgCode2Int( 5, 'z', 'h' ),//\"\\x05\",//Other Traditional Chinese dialects\",\n    blgCode2Int( 6, 0, 0 ),//\"\\x06\",//Other Eastern-European languages\",\n    blgCode2Int( 7, 0, 0 ),//\"\\x07\",//Other Western-European languages\",\n    blgCode2Int( 8, 'r', 'u' ),//\"\\x08\",//Other Russian languages\",\n    blgCode2Int( 9, 'j', 'a' ),//\"\\x09\",//Other Japanese languages\",\n    blgCode2Int( 10, 0, 0 ),//\"\\x0A\",//\"Other Baltic languages\",\n    blgCode2Int( 11, 'e', 'l' ),//\"\\x0B\",//Other Greek languages\",\n    blgCode2Int( 12, 'k', 'o' ),//\"\\x0C\",//\"Other Korean dialects\",\n    blgCode2Int( 13, 't', 'r' ),//\"\\x0D\",//Other Turkish dialects\",\n    blgCode2Int( 14, 't', 'h' ),//\"\\x0E\",//\"Other Thai dialects\",\n    blgCode2Int( 0, 'p', 'l' ),//\"Polish\",\n    blgCode2Int( 0, 'h', 'u' ),//\"Hungarian\",\n    blgCode2Int( 0, 'c', 's' ),//\"Czech\",\n    blgCode2Int( 0, 'l', 't' ),//\"Lithuanian\",\n    blgCode2Int( 0, 'l', 'v' ),//\"Latvian\",\n    blgCode2Int( 0, 'c', 'a' ),//\"Catalan\",\n    blgCode2Int( 0, 'h', 'r' ),//\"Croatian\",\n    blgCode2Int( 0, 's', 'r' ),//\"Serbian\",\n    blgCode2Int( 0, 's', 'k' ),//\"Slovak\",\n    blgCode2Int( 0, 's', 'q' ),//\"Albanian\",\n    blgCode2Int( 0, 'u', 'r' ),//\"Urdu\",\n    blgCode2Int( 0, 's', 'l' ),//\"Slovenian\",\n    blgCode2Int( 0, 'e', 't' ),//\"Estonian\",\n    blgCode2Int( 0, 'b', 'g' ),//\"Bulgarian\",\n    blgCode2Int( 0, 'd', 'a' ),//\"Danish\",\n    blgCode2Int( 0, 'f', 'i' ),//\"Finnish\",\n    blgCode2Int( 0, 'i', 's' ),//\"Icelandic\",\n    blgCode2Int( 0, 'n', 'o' ),//\"Norwegian\",\n    blgCode2Int( 0, 'r', 'o' ),//\"Romanian\",\n    blgCode2Int( 0, 's', 'v' ),//\"Swedish\",\n    blgCode2Int( 0, 'u', 'k' ),//\"Ukrainian\",\n    blgCode2Int( 0, 'b', 'e' ),//\"Belarusian\",\n    blgCode2Int( 0, 'f', 'a' ),//\"Farsi\"=Persian,\n    blgCode2Int( 0, 'e', 'u' ),//\"Basque\",\n    blgCode2Int( 0, 'm', 'k' ),//\"Macedonian\",\n    blgCode2Int( 0, 'a', 'f' ),//\"Afrikaans\",\n    blgCode2Int( 0, 'f', 'o' ),//\"Faeroese\"=Faroese,\n    blgCode2Int( 0, 'l', 'a' ),//\"Latin\",\n    blgCode2Int( 0, 'e', 'o' ),//\"Esperanto\",\n    blgCode2Int( 15, 0, 0 ),//\"Tamazight\",\n    blgCode2Int( 0, 'h', 'y' )//\"Armenian\"\n};\n\n\nconst std::string bgl_charsetname[] = {\n\t\"Default\" ,\n\t\"Latin\",\n\t\"Eastern European\",\n\t\"Cyrillic\",\n\t\"Japanese\",\n\t\"Traditional Chinese\",\n\t\"Simplified Chinese\",\n\t\"Baltic\",\n\t\"Greek\",\n\t\"Korean\",\n\t\"Turkish\",\n\t\"Hebrew\",\n\t\"Arabic\",\n\t\"Thai\" };\n\nconst std::string bgl_charset[] = {\n\t\"WINDOWS-1252\", /*Default*/\n\t\"WINDOWS-1252\", /*Latin*/\n\t\"WINDOWS-1250\", /*Eastern European*/\n\t\"WINDOWS-1251\", /*Cyriilic*/\n\t\"CP932\", /*Japanese*/\n\t\"BIG5\", /*Traditional Chinese*/\n\t\"GB18030\", /*Simplified Chinese*/\n\t\"CP1257\", /*Baltic*/\n\t\"CP1253\", /*Greek*/\n\t\"EUC-KR\",  /*Korean*/\n\t\"ISO-8859-9\", /*Turkish*/\n\t\"WINDOWS-1255\", /*Hebrew*/\n\t\"CP1256\", /*Arabic*/\n\t\"CP874\"  /*Thai*/ };\n\nconst std::string partOfSpeech[] = {\n  \"n.\",\n  \"adj.\",\n  \"v.\",\n  \"adv.\",\n  \"interj.\",\n  \"pron.\",\n  \"prep.\",\n  \"conj.\",\n  \"suff.\",\n  \"pref.\",\n  \"art.\" };\n\ntypedef struct {\n\tunsigned type;\n\tunsigned length;\n\tchar * data;\n} bgl_block;\n\ntypedef struct {\n        std::string headword;\n        std::string definition;\n        std::string displayedHeadword;\n        std::vector<std::string> alternates;\n} bgl_entry;\n\nclass Babylon\n{\npublic:\n    Babylon( std::string );\n    ~Babylon();\n\n    // Subclass this to store resources\n    class ResourceHandler\n    {\n    public:\n\n      virtual void handleBabylonResource( std::string const & filename,\n                                          char const * data, size_t size )=0;\n\n      virtual ~ResourceHandler()\n      {}\n    };\n\n    /// Sets a prefix string to append to each resource reference in hyperlinks.\n    void setResourcePrefix( std::string const & prefix )\n    { m_resourcePrefix = prefix; }\n\n    bool open();\n    void close();\n    bool readBlock( bgl_block& );\n    bool read(std::string &source_charset, std::string &target_charset);\n    bgl_entry readEntry( ResourceHandler * = 0 );\n\n    inline std::string title() const { return m_title; }\n    inline std::string author() const { return m_author; }\n    inline std::string email() const { return m_email; }\n    inline std::string description() const { return m_description; }\n    inline std::string copyright() const { return m_copyright; }\n    inline quint32 sourceLang() const { return m_sourceLang; }//std::string sourceLang() const { return m_sourceLang; }\n    inline quint32 targetLang() const { return m_targetLang; }//inline std::string targetLang() const { return m_targetLang; }\n    inline unsigned int numEntries() const { return m_numEntries; }\n    inline std::string charset() const { return m_defaultCharset; }\n\n    inline std::string filename() const { return m_filename; }\n\n    std::vector< char > const & getIcon() const\n    { return icon; }\n\n    enum\n    {\n      ParserVersion = 17\n    };\n\nprivate:\n    unsigned int bgl_readnum( int );\n    void convertToUtf8( std::string &, unsigned int = 0 );\n\n    std::string m_filename;\n    gzFile file;\n\n    std::string m_title;\n    std::string m_author;\n    std::string m_email;\n    std::string m_description;\n    std::string m_copyright;\n    quint32 m_sourceLang; //std::string m_sourceLang;\n    quint32 m_targetLang;//std::string m_targetLang;\n    unsigned int m_numEntries;\n    std::string m_defaultCharset;\n    std::string m_sourceCharset;\n    std::string m_targetCharset;\n    std::vector< char > icon;\n\n    std::string m_resourcePrefix;\n\n    enum CHARSET { BGL_DEFAULT_CHARSET, BGL_SOURCE_CHARSET, BGL_TARGET_CHARSET };\n};\n\n#endif // BABYLON_H\n"
        },
        {
          "name": "broken_xrecord.cc",
          "type": "blob",
          "size": 0.5712890625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"broken_xrecord.hh\"\n\n#include <QtGui>\n\n#ifdef HAVE_X11\n#include <X11/Xlib.h>\n#include <X11/extensions/record.h>\n#include <QX11Info>\n#endif\n\nbool isRECORDBroken()\n{\n#ifdef HAVE_X11\n\n char const * vendor = ServerVendor( QX11Info::display() );\n\n if ( vendor && strstr( vendor, \"X.Org\" ) )\n {\n   int release = VendorRelease( QX11Info::display() );\n\n   return release >= 10600000 && release < 10701000;\n }\n\n#endif\n\n  return false;\n}\n"
        },
        {
          "name": "broken_xrecord.hh",
          "type": "blob",
          "size": 0.46875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __BROKEN_XRECORD_HH_INCLUDED__\n#define __BROKEN_XRECORD_HH_INCLUDED__\n\n/// Returns true if the RECORD extension is likely to be broken. Under Windows\n/// it always returns false.\n/// This function is to be removed once the RECORD extension is working again\n/// on all the major distributions.\nbool isRECORDBroken();\n\n#endif\n"
        },
        {
          "name": "btreeidx.cc",
          "type": "blob",
          "size": 42.455078125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"btreeidx.hh\"\n#include \"folding.hh\"\n#include \"utf8.hh\"\n#include <QRunnable>\n#include <QThreadPool>\n#include <QSemaphore>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"gddebug.hh\"\n#include \"wstring_qt.hh\"\n#include \"qt4x5.hh\"\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n#include <QRegularExpression>\n#include \"wildcard.hh\"\n#endif\n\n//#define __BTREE_USE_LZO\n// LZO mode is experimental and unsupported. Tests didn't show any substantial\n// speed improvements.\n\n#ifdef __BTREE_USE_LZO\n#include <lzo/lzo1x.h>\n\nnamespace {\nstruct __LzoInit\n{\n  __LzoInit()\n  {\n    lzo_init();\n  }\n} __lzoInit;\n}\n\n#else\n#include <zlib.h>\n#endif\n\nnamespace BtreeIndexing {\n\nusing gd::wstring;\nusing gd::wchar;\nusing std::pair;\n\nenum\n{\n  BtreeMinElements = 64,\n  BtreeMaxElements = 8192\n};\n\nBtreeIndex::BtreeIndex():\n  idxFile( 0 ), rootNodeLoaded( false )\n{\n}\n\nBtreeDictionary::BtreeDictionary( string const & id,\n                                  vector< string > const & dictionaryFiles ):\n  Dictionary::Class( id, dictionaryFiles )\n{\n}\n\nstring const & BtreeDictionary::ensureInitDone()\n{\n  static string empty;\n\n  return empty;\n}\n\nvoid BtreeIndex::openIndex( IndexInfo const & indexInfo,\n                            File::Class & file, Mutex & mutex )\n{\n  indexNodeSize = indexInfo.btreeMaxElements;\n  rootOffset = indexInfo.rootOffset;\n\n  idxFile = &file;\n  idxFileMutex = &mutex;\n\n  rootNodeLoaded = false;\n  rootNode.clear();\n}\n\nvector< WordArticleLink > BtreeIndex::findArticles( wstring const & word, bool ignoreDiacritics )\n{\n  vector< WordArticleLink > result;\n\n  try\n  {\n    wstring folded = Folding::apply( word );\n    if( folded.empty() )\n      folded = Folding::applyWhitespaceOnly( word );\n\n    bool exactMatch;\n\n    vector< char > leaf;\n    uint32_t nextLeaf;\n\n    char const * leafEnd;\n\n    char const * chainOffset = findChainOffsetExactOrPrefix( folded, exactMatch,\n                                                             leaf, nextLeaf,\n                                                             leafEnd );\n\n    if ( chainOffset && exactMatch )\n    {\n      result = readChain( chainOffset );\n\n      antialias( word, result, ignoreDiacritics );\n    }\n  }\n  catch( std::exception & e )\n  {\n    gdWarning( \"Articles searching failed, error: %s\\n\", e.what() );\n    result.clear();\n  }\n  catch(...)\n  {\n    qWarning( \"Articles searching failed\\n\" );\n    result.clear();\n  }\n\n  return result;\n}\n\nclass BtreeWordSearchRunnable: public QRunnable\n{\n  BtreeWordSearchRequest & r;\n  QSemaphore & hasExited;\n  \npublic:\n\n  BtreeWordSearchRunnable( BtreeWordSearchRequest & r_,\n                           QSemaphore & hasExited_ ): r( r_ ),\n                                                      hasExited( hasExited_ )\n  {}\n\n  ~BtreeWordSearchRunnable()\n  {\n    hasExited.release();\n  }\n  \n  virtual void run();\n};\n\nvoid BtreeWordSearchRunnable::run()\n{\n  r.run();\n}\n\nBtreeWordSearchRequest::BtreeWordSearchRequest( BtreeDictionary & dict_,\n                                                wstring const & str_,\n                                                unsigned minLength_,\n                                                int maxSuffixVariation_,\n                                                bool allowMiddleMatches_,\n                                                unsigned long maxResults_,\n                                                bool startRunnable ):\n  dict( dict_ ), str( str_ ),\n  maxResults( maxResults_ ),\n  minLength( minLength_ ),\n  maxSuffixVariation( maxSuffixVariation_ ),\n  allowMiddleMatches( allowMiddleMatches_ )\n{\n  if( startRunnable )\n  {\n    QThreadPool::globalInstance()->start(\n      new BtreeWordSearchRunnable( *this, hasExited ) );\n  }\n}\n\nvoid BtreeWordSearchRequest::findMatches()\n{\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  if ( dict.ensureInitDone().size() )\n  {\n    setErrorString( QString::fromUtf8( dict.ensureInitDone().c_str() ) );\n    finish();\n    return;\n  }\n  \n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  QRegularExpression regexp;\n#else\n  QRegExp regexp;\n#endif\n  bool useWildcards = false;\n  if( allowMiddleMatches )\n    useWildcards = ( str.find( '*' ) != wstring::npos ||\n                     str.find( '?' ) != wstring::npos ||\n                     str.find( '[' ) != wstring::npos ||\n                     str.find( ']' ) != wstring::npos );\n\n  wstring folded = Folding::apply( str );\n\n  int minMatchLength = 0;\n\n  if( useWildcards )\n  {\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n    regexp.setPattern( wildcardsToRegexp( gd::toQString( Folding::applyDiacriticsOnly( Folding::applySimpleCaseOnly( str ) ) ) ) );\n    if( !regexp.isValid() )\n      regexp.setPattern( QRegularExpression::escape( regexp.pattern() ) );\n    regexp.setPatternOptions( QRegularExpression::CaseInsensitiveOption );\n#else\n    regexp.setPattern( gd::toQString( Folding::applyDiacriticsOnly( Folding::applySimpleCaseOnly( str ) ) ) );\n    regexp.setPatternSyntax( QRegExp::WildcardUnix );\n    regexp.setCaseSensitivity( Qt::CaseInsensitive );\n#endif\n\n    bool bNoLetters = folded.empty();\n    wstring foldedWithWildcards;\n\n    if( bNoLetters )\n      foldedWithWildcards = Folding::applyWhitespaceOnly( str );\n    else\n      foldedWithWildcards = Folding::apply( str, useWildcards );\n\n    // Calculate minimum match length\n\n    bool insideSet = false;\n    bool escaped = false;\n    for( wstring::size_type x = 0; x < foldedWithWildcards.size(); x++ )\n    {\n      wchar ch = foldedWithWildcards[ x ];\n\n      if( ch == L'\\\\' && !escaped )\n      {\n        escaped = true;\n        continue;\n      }\n\n      if( ch == L']' && !escaped )\n      {\n        insideSet = false;\n        continue;\n      }\n\n      if( insideSet )\n      {\n        escaped = false;\n        continue;\n      }\n\n      if( ch == L'[' && !escaped )\n      {\n        minMatchLength += 1;\n        insideSet = true;\n        continue;\n      }\n\n      if( ch == L'*' && !escaped )\n        continue;\n\n      escaped = false;\n      minMatchLength += 1;\n    }\n\n    // Fill first match chars\n\n    folded.clear();\n    folded.reserve( foldedWithWildcards.size() );\n    escaped = false;\n    for( wstring::size_type x = 0; x < foldedWithWildcards.size(); x++ )\n    {\n      wchar ch = foldedWithWildcards[ x ];\n\n      if( escaped )\n      {\n        if( bNoLetters || ( ch != L'*' && ch != L'?' && ch != L'[' && ch != L']' ) )\n          folded.push_back( ch );\n        escaped = false;\n        continue;\n      }\n\n      if( ch == L'\\\\' )\n      {\n        if( bNoLetters || folded.empty() )\n        {\n          escaped = true;\n          continue;\n        }\n        else\n          break;\n      }\n\n      if( ch == '*' || ch == '?' || ch == '[' || ch == ']' )\n        break;\n\n      folded.push_back( ch );\n    }\n  }\n  else\n  {\n    if( folded.empty() )\n      folded = Folding::applyWhitespaceOnly( str );\n  }\n\n  int initialFoldedSize = folded.size();\n\n  int charsLeftToChop = 0;\n\n  if ( maxSuffixVariation >= 0 )\n  {\n    charsLeftToChop = initialFoldedSize - (int)minLength;\n\n    if ( charsLeftToChop < 0 )\n      charsLeftToChop = 0;\n    else\n    if ( charsLeftToChop > maxSuffixVariation )\n      charsLeftToChop = maxSuffixVariation;\n  }\n\n  try\n  {\n    for( ; ; )\n    {\n      bool exactMatch;\n      vector< char > leaf;\n      uint32_t nextLeaf;\n      char const * leafEnd;\n\n      char const * chainOffset = dict.findChainOffsetExactOrPrefix( folded, exactMatch,\n                                                                    leaf, nextLeaf,\n                                                                    leafEnd );\n\n      if ( chainOffset )\n      for( ; ; )\n      {\n        if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n          break;\n\n        //DPRINTF( \"offset = %u, size = %u\\n\", chainOffset - &leaf.front(), leaf.size() );\n\n        vector< WordArticleLink > chain = dict.readChain( chainOffset );\n\n        wstring chainHead = Utf8::decode( chain[ 0 ].word );\n\n        wstring resultFolded = Folding::apply( chainHead );\n        if( resultFolded.empty() )\n          resultFolded = Folding::applyWhitespaceOnly( chainHead );\n\n        if ( ( useWildcards && folded.empty() ) ||\n             ( resultFolded.size() >= folded.size()\n               && !resultFolded.compare( 0, folded.size(), folded ) ) )\n        {\n          // Exact or prefix match\n\n          Mutex::Lock _( dataMutex );\n\n          for( unsigned x = 0; x < chain.size(); ++x )\n          {\n            if( useWildcards )\n            {\n              wstring word = Utf8::decode( chain[ x ].prefix + chain[ x ].word );\n              wstring result = Folding::applyDiacriticsOnly( word );\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n              if( result.size() >= (wstring::size_type)minMatchLength )\n              {\n                QRegularExpressionMatch match = regexp.match( gd::toQString( result ) );\n                if( match.hasMatch() && match.capturedStart() == 0 )\n                {\n                  addMatch( word );\n                }\n              }\n#else\n              if( result.size() >= (wstring::size_type)minMatchLength\n                  && regexp.indexIn( gd::toQString( result ) ) == 0\n                  && regexp.matchedLength() >= minMatchLength )\n              {\n                addMatch( word );\n              }\n#endif\n            }\n            else\n            {\n              // Skip middle matches, if requested. If suffix variation is specified,\n              // make sure the string isn't larger than requested.\n              if ( ( allowMiddleMatches || Folding::apply( Utf8::decode( chain[ x ].prefix ) ).empty() ) &&\n                   ( maxSuffixVariation < 0 || (int)resultFolded.size() - initialFoldedSize <= maxSuffixVariation ) )\n                  addMatch( Utf8::decode( chain[ x ].prefix + chain[ x ].word ) );\n            }\n          }\n\n          if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n            break;\n\n          if ( matches.size() >= maxResults )\n          {\n            // For now we actually allow more than maxResults if the last\n            // chain yield more than one result. That's ok and maybe even more\n            // desirable.\n            break;\n          }\n        }\n        else\n          // Neither exact nor a prefix match, end this\n          break;\n\n        // Fetch new leaf if we're out of chains here\n\n        if ( chainOffset >= leafEnd )\n        {\n          // We're past the current leaf, fetch the next one\n\n          //DPRINTF( \"advancing\\n\" );\n\n          if ( nextLeaf )\n          {\n            Mutex::Lock _( *dict.idxFileMutex );\n\n            dict.readNode( nextLeaf, leaf );\n            leafEnd = &leaf.front() + leaf.size();\n\n            nextLeaf = dict.idxFile->read< uint32_t >();\n            chainOffset = &leaf.front() + sizeof( uint32_t );\n\n            uint32_t leafEntries = *(uint32_t *)&leaf.front();\n\n            if ( leafEntries == 0xffffFFFF )\n            {\n              //DPRINTF( \"bah!\\n\" );\n              exit( 1 );\n            }\n          }\n          else\n            break; // That was the last leaf\n        }\n      }\n\n      if ( charsLeftToChop && !Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      {\n        --charsLeftToChop;\n        folded.resize( folded.size() - 1 );\n      }\n      else\n        break;\n    }\n  }\n  catch( std::exception & e )\n  {\n    qWarning( \"Index searching failed: \\\"%s\\\", error: %s\\n\",\n              dict.getName().c_str(), e.what() );\n  }\n  catch(...)\n  {\n    gdWarning( \"Index searching failed: \\\"%s\\\"\\n\", dict.getName().c_str() );\n  }\n}\n\nvoid BtreeWordSearchRequest::run()\n{\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  if ( dict.ensureInitDone().size() )\n  {\n    setErrorString( QString::fromUtf8( dict.ensureInitDone().c_str() ) );\n    finish();\n    return;\n  }\n\n  findMatches();\n\n  finish();\n}\n\nBtreeWordSearchRequest::~BtreeWordSearchRequest()\n{\n  isCancelled.ref();\n  hasExited.acquire();\n}\n\nsptr< Dictionary::WordSearchRequest > BtreeDictionary::prefixMatch(\n  wstring const & str, unsigned long maxResults )\n  THROW_SPEC( std::exception )\n{\n  return new BtreeWordSearchRequest( *this, str, 0, -1, true, maxResults );\n}\n\nsptr< Dictionary::WordSearchRequest > BtreeDictionary::stemmedMatch(\n  wstring const & str, unsigned minLength, unsigned maxSuffixVariation,\n  unsigned long maxResults )\n  THROW_SPEC( std::exception )\n{\n  return new BtreeWordSearchRequest( *this, str, minLength, (int)maxSuffixVariation,\n                                     false, maxResults );\n}\n\nvoid BtreeIndex::readNode( uint32_t offset, vector< char > & out )\n{\n  idxFile->seek( offset );\n\n  uint32_t uncompressedSize = idxFile->read< uint32_t >();\n  uint32_t compressedSize = idxFile->read< uint32_t >();\n\n  //DPRINTF( \"%x,%x\\n\", uncompressedSize, compressedSize );\n\n  out.resize( uncompressedSize );\n\n  vector< unsigned char > compressedData( compressedSize );\n\n  idxFile->read( &compressedData.front(), compressedData.size() );\n\n  #ifdef __BTREE_USE_LZO\n\n  lzo_uint decompressedLength = out.size();\n\n  if ( lzo1x_decompress( &compressedData.front(), compressedData.size(),\n                         (unsigned char *)&out.front(), &decompressedLength, 0 )\n       != LZO_E_OK || decompressedLength != out.size() )\n    throw exFailedToDecompressNode();\n\n  #else\n\n  unsigned long decompressedLength = out.size();\n\n  if ( uncompress( (unsigned char *)&out.front(),\n                   &decompressedLength,\n                   &compressedData.front(),\n                   compressedData.size() ) != Z_OK ||\n       decompressedLength != out.size() )\n    throw exFailedToDecompressNode();\n  #endif\n}\n\nchar const * BtreeIndex::findChainOffsetExactOrPrefix( wstring const & target,\n                                                       bool & exactMatch,\n                                                       vector< char > & extLeaf,\n                                                       uint32_t & nextLeaf,\n                                                       char const * & leafEnd )\n{\n  if ( !idxFile )\n    throw exIndexWasNotOpened();\n  \n  Mutex::Lock _( *idxFileMutex );\n  \n  // Lookup the index by traversing the index btree\n\n  vector< wchar > wcharBuffer;\n\n  exactMatch = false;\n\n  // Read a node\n\n  uint32_t currentNodeOffset = rootOffset;\n\n  if ( !rootNodeLoaded )\n  {\n    // Time to load our root node. We do it only once, at the first request.\n    readNode( rootOffset, rootNode );\n    rootNodeLoaded = true;\n  }\n\n  char const * leaf = &rootNode.front();\n  leafEnd = leaf + rootNode.size();\n\n  if( target.empty() )\n  {\n    //For empty target string we return first chain in index\n    for( ; ; )\n    {\n      uint32_t leafEntries = *(uint32_t *)leaf;\n\n      if ( leafEntries == 0xffffFFFF )\n      {\n        // A node\n        currentNodeOffset = *( (uint32_t *)leaf + 1 );\n        readNode( currentNodeOffset, extLeaf );\n        leaf = &extLeaf.front();\n        leafEnd = leaf + extLeaf.size();\n        nextLeaf = idxFile->read< uint32_t >();\n      }\n      else\n      {\n        // A leaf\n        if( currentNodeOffset == rootOffset )\n        {\n          // Only one leaf in index, there's no next leaf\n          nextLeaf = 0;\n        }\n        if( !leafEntries )\n          return 0;\n\n        return leaf + sizeof( uint32_t );\n      }\n    }\n  }\n\n  for( ; ; )\n  {\n    // Is it a leaf or a node?\n\n    uint32_t leafEntries = *(uint32_t *)leaf;\n\n    if ( leafEntries == 0xffffFFFF )\n    {\n      // A node\n\n      //DPRINTF( \"=>a node\\n\" );\n\n      uint32_t const * offsets = (uint32_t *)leaf + 1;\n\n      char const * ptr = leaf + sizeof( uint32_t ) +\n                         ( indexNodeSize + 1 ) * sizeof( uint32_t );\n\n      // ptr now points to a span of zero-separated strings, up to leafEnd.\n      // We find our match using a binary search.\n\n      char const * closestString;\n\n      int compareResult;\n\n      char const * window = ptr;\n      unsigned windowSize = leafEnd - ptr;\n\n      for( ; ; )\n      {  \n        // We boldly shoot in the middle of the whole mess, and then adjust\n        // to the beginning of the string that we've hit.\n        char const * testPoint = window + windowSize/2;\n  \n        closestString = testPoint;\n  \n        while( closestString > ptr && closestString[ -1 ] )\n          --closestString;\n  \n        size_t wordSize = strlen( closestString );\n  \n        if ( wcharBuffer.size() <= wordSize )\n          wcharBuffer.resize( wordSize + 1 );\n  \n        long result = Utf8::decode( closestString, wordSize, &wcharBuffer.front() );\n\n        if ( result < 0 )\n          throw Utf8::exCantDecode( closestString );\n  \n        wcharBuffer[ result ] = 0;\n\n        //DPRINTF( \"Checking against %s\\n\", closestString );\n\n        compareResult = target.compare( &wcharBuffer.front() );\n  \n        if ( !compareResult )\n        {\n          // The target string matches the current one. Finish the search.\n          break;\n        }\n        if ( compareResult < 0 )\n        {\n          // The target string is smaller than the current one.\n          // Go to the left.\n          windowSize = closestString - window;\n\n          if ( !windowSize )\n            break;\n        }\n        else\n        {\n          // The target string is larger than the current one.\n          // Go to the right.\n          windowSize -= ( closestString - window )  + wordSize + 1;\n          window = closestString + wordSize + 1;\n\n          if ( !windowSize )\n            break;\n        }\n      }\n\n      #if 0\n      DPRINTF( \"The winner is %s, compareResult = %d\\n\", closestString, compareResult );\n\n      if ( closestString != ptr )\n      {\n        char const * left = closestString -1;\n\n        while( left != ptr && left[ -1 ] )\n          --left;\n\n        DPRINTF( \"To the left: %s\\n\", left );\n      }\n      else\n        DPRINTF( \"To the lest -- nothing\\n\" );\n\n      char const * right = closestString + strlen( closestString ) + 1;\n\n      if ( right != leafEnd )\n      {\n        DPRINTF( \"To the right: %s\\n\", right );\n      }\n      else\n        DPRINTF( \"To the right -- nothing\\n\" );\n      #endif\n\n      // Now, whatever the outcome (compareResult) is, we need to find\n      // entry number for the closestMatch string.\n       \n      unsigned entry = 0;\n\n      for( char const * next = ptr; next != closestString;\n           next += strlen( next ) + 1, ++entry ) ;\n\n      // Ok, now check the outcome\n\n      if ( !compareResult )\n      {\n        // The target string matches the one found.\n        // Go to the right, since it's there where we store such results.\n        currentNodeOffset = offsets[ entry + 1 ];\n      }\n      if ( compareResult < 0 )\n      {\n        // The target string is smaller than the one found.\n        // Go to the left.\n        currentNodeOffset = offsets[ entry ];\n      }\n      else\n      {\n        // The target string is larger than the one found.\n        // Go to the right.\n        currentNodeOffset = offsets[ entry + 1 ];\n      }\n\n      //DPRINTF( \"reading node at %x\\n\", currentNodeOffset );\n      readNode( currentNodeOffset, extLeaf );\n      leaf = &extLeaf.front();\n      leafEnd = leaf + extLeaf.size();\n    }\n    else\n    {\n      //DPRINTF( \"=>a leaf\\n\" );\n      // A leaf\n\n      // If this leaf is the root, there's no next leaf, it just can't be.\n      // We do this check because the file's position indicator just won't\n      // be in the right place for root node anyway, since we precache it.\n      nextLeaf = ( currentNodeOffset != rootOffset ? idxFile->read< uint32_t >() : 0 );\n\n      if ( !leafEntries )\n      {\n        // Empty leaf? This may only be possible for entirely empty trees only.\n        if ( currentNodeOffset != rootOffset )\n          throw exCorruptedChainData();\n        else\n          return 0; // No match\n      }\n\n      // Build an array containing all chain pointers\n      char const * ptr = leaf + sizeof( uint32_t );\n\n      uint32_t chainSize;\n\n      vector< char const * > chainOffsets( leafEntries );\n\n      {\n        char const ** nextOffset = &chainOffsets.front();\n\n        while( leafEntries-- )\n        {\n          *nextOffset++ = ptr;\n\n          memcpy( &chainSize, ptr, sizeof( uint32_t ) );\n\n          //DPRINTF( \"%s + %s\\n\", ptr + sizeof( uint32_t ), ptr + sizeof( uint32_t ) + strlen( ptr + sizeof( uint32_t ) ) + 1 );\n\n          ptr += sizeof( uint32_t ) + chainSize;\n        }\n      }\n\n      // Now do a binary search in it, aiming to find where our target\n      // string lands.\n\n      char const ** window = &chainOffsets.front();\n      unsigned windowSize = chainOffsets.size();\n\n      for( ; ; )\n      {\n        //DPRINTF( \"window = %u, ws = %u\\n\", window - &chainOffsets.front(), windowSize );\n\n        char const ** chainToCheck = window + windowSize/2;\n        ptr = *chainToCheck;\n  \n        memcpy( &chainSize, ptr, sizeof( uint32_t ) );\n        ptr += sizeof( uint32_t );\n  \n        size_t wordSize = strlen( ptr );\n  \n        if ( wcharBuffer.size() <= wordSize )\n          wcharBuffer.resize( wordSize + 1 );\n  \n        //DPRINTF( \"checking against word %s, left = %u\\n\", ptr, leafEntries );\n  \n        long result = Utf8::decode( ptr, wordSize, &wcharBuffer.front() );\n  \n        if ( result < 0 )\n          throw Utf8::exCantDecode( ptr );\n  \n        wcharBuffer[ result ] = 0;\n  \n        wstring foldedWord = Folding::apply( &wcharBuffer.front() );\n        if( foldedWord.empty() )\n          foldedWord = Folding::applyWhitespaceOnly( &wcharBuffer.front() );\n  \n        int compareResult = target.compare( foldedWord );\n  \n        if ( !compareResult )\n        {\n          // Exact match -- return and be done\n          exactMatch = true;\n  \n          return ptr - sizeof( uint32_t );\n        }\n        else\n        if ( compareResult < 0 )\n        {\n          // The target string is smaller than the current one.\n          // Go to the first half\n           \n          windowSize /= 2;\n\n          if ( !windowSize )\n          {\n            // That finishes our search. Since our target string\n            // landed before the last tested chain, we return a possible\n            // prefix match against that chain.\n            return ptr - sizeof( uint32_t );\n          }\n        }\n        else\n        {\n          // The target string is larger than the current one.\n          // Go to the second half\n\n          windowSize -= windowSize/2 + 1;\n\n          if ( !windowSize )\n          {\n            // That finishes our search. Since our target string\n            // landed after the last tested chain, we return the next\n            // chain. If there's no next chain in this leaf, this\n            // would mean the first element in the next leaf.\n            if ( chainToCheck == &chainOffsets.back() )\n            {\n              if ( nextLeaf )\n              {\n                readNode( nextLeaf, extLeaf );\n  \n                leafEnd = &extLeaf.front() + extLeaf.size();\n  \n                nextLeaf = idxFile->read< uint32_t >();\n  \n                return &extLeaf.front() + sizeof( uint32_t );\n              }\n              else\n                return 0; // This was the last leaf\n            }\n            else\n              return chainToCheck[ 1 ];\n          }\n\n          window = chainToCheck + 1;\n        }\n      }\n    }\n  }\n}\n\nvector< WordArticleLink > BtreeIndex::readChain( char const * & ptr )\n{\n  uint32_t chainSize;\n\n  memcpy( &chainSize, ptr, sizeof( uint32_t ) );\n\n  ptr += sizeof( uint32_t );\n\n  vector< WordArticleLink > result;\n\n  while( chainSize )\n  {\n    string str = ptr;\n    ptr += str.size() + 1;\n\n    string prefix = ptr;\n    ptr += prefix.size() + 1;\n\n    uint32_t articleOffset;\n\n    memcpy( &articleOffset, ptr, sizeof( uint32_t ) );\n\n    ptr += sizeof( uint32_t );\n\n    result.push_back( WordArticleLink( str, articleOffset, prefix ) );\n\n    if ( chainSize < str.size() + 1 + prefix.size() + 1 + sizeof( uint32_t ) )\n      throw exCorruptedChainData();\n    else\n      chainSize -= str.size() + 1 + prefix.size() + 1 + sizeof( uint32_t );\n  }\n\n  return result;\n}\n\nvoid BtreeIndex::antialias( wstring const & str,\n                            vector< WordArticleLink > & chain,\n                            bool ignoreDiacritics )\n{\n  wstring caseFolded = Folding::applySimpleCaseOnly( gd::normalize( str ) );\n  if( ignoreDiacritics )\n    caseFolded = Folding::applyDiacriticsOnly( caseFolded );\n\n  for( unsigned x = chain.size(); x--; )\n  {\n    // If after applying case folding to each word they wouldn't match, we\n    // drop the entry.\n    wstring entry = Folding::applySimpleCaseOnly( gd::normalize( Utf8::decode( chain[ x ].prefix + chain[ x ].word ) ) );\n    if( ignoreDiacritics )\n      entry = Folding::applyDiacriticsOnly( entry );\n\n    if ( entry != caseFolded )\n      chain.erase( chain.begin() + x );\n    else\n    if ( chain[ x ].prefix.size() ) // If there's a prefix, merge it with the word,\n                                    // since it's what dictionaries expect\n    {\n      chain[ x ].word.insert( 0, chain[ x ].prefix );\n      chain[ x ].prefix.clear();\n    }\n  }\n}\n\n\n/// A function which recursively creates btree node.\n/// The nextIndex iterator is being iterated over and increased when building\n/// leaf nodes.\nstatic uint32_t buildBtreeNode( IndexedWords::const_iterator & nextIndex,\n                                size_t indexSize,\n                                File::Class & file, size_t maxElements,\n                                uint32_t & lastLeafLinkOffset )\n{\n  // We compress all the node data. This buffer would hold it.\n  vector< unsigned char > uncompressedData;\n\n  bool isLeaf = indexSize <= maxElements;\n\n  if ( isLeaf )\n  {\n    // A leaf.\n\n    uint32_t totalChainsLength = 0;\n\n    IndexedWords::const_iterator nextWord = nextIndex;\n\n    for( unsigned x = indexSize; x--; ++nextWord )\n    {\n      totalChainsLength += sizeof( uint32_t );\n\n      vector< WordArticleLink > const & chain = nextWord->second;\n\n      for( unsigned y = 0; y < chain.size(); ++y )\n        totalChainsLength += chain[ y ].word.size() + 1 + chain[ y ].prefix.size() + 1 + sizeof( uint32_t );\n    }\n\n    uncompressedData.resize( sizeof( uint32_t ) + totalChainsLength );\n\n    // First uint32_t indicates that this is a leaf.\n    *(uint32_t *)&uncompressedData.front() = indexSize;\n\n    unsigned char * ptr = &uncompressedData.front() + sizeof( uint32_t );\n\n    for( unsigned x = indexSize; x--; ++nextIndex )\n    {\n      vector< WordArticleLink > const & chain = nextIndex->second;\n\n      unsigned char * saveSizeHere = ptr;\n\n      ptr += sizeof( uint32_t );\n\n      uint32_t size = 0;\n\n      for( unsigned y = 0; y < chain.size(); ++y )\n      {\n        memcpy( ptr, chain[ y ].word.c_str(), chain[ y ].word.size() + 1 );\n        ptr += chain[ y ].word.size() + 1;\n\n        memcpy( ptr, chain[ y ].prefix.c_str(), chain[ y ].prefix.size() + 1 );\n        ptr += chain[ y ].prefix.size() + 1;\n\n        memcpy( ptr, &(chain[ y ].articleOffset), sizeof( uint32_t ) );\n        ptr += sizeof( uint32_t );\n\n        size += chain[ y ].word.size() + 1 + chain[ y ].prefix.size() + 1 + sizeof( uint32_t );\n      }\n\n      memcpy( saveSizeHere, &size, sizeof( uint32_t ) );\n    }\n  }\n  else\n  {\n    // A node which will have children.\n\n    uncompressedData.resize( sizeof( uint32_t ) + ( maxElements + 1 ) * sizeof( uint32_t ) );\n\n    // First uint32_t indicates that this is a node.\n    *(uint32_t *)&uncompressedData.front() = 0xffffFFFF;\n\n    unsigned prevEntry = 0;\n\n    unsigned step = indexSize / ( maxElements + 1 );\n    bool useNonUniformLeaves = ( maxElements >= BtreeMaxElements && step > maxElements && step < BtreeMinElements * maxElements );\n\n    for( unsigned x = 0; x < maxElements; ++x )\n    {\n      unsigned curEntry;\n\n      if( useNonUniformLeaves )\n      {\n        curEntry = prevEntry + BtreeMinElements * maxElements;\n        if( curEntry > indexSize - ( maxElements - x ) * maxElements )\n        {\n          curEntry = indexSize - ( maxElements - x ) * maxElements;\n          if( curEntry <= prevEntry )\n            curEntry = prevEntry + BtreeMinElements;\n        }\n      }\n      else\n        curEntry = (uint64_t) indexSize * ( x + 1 ) / ( maxElements + 1 );\n\n      uint32_t offset = buildBtreeNode( nextIndex,\n                                        curEntry - prevEntry,\n                                        file, maxElements,\n                                        lastLeafLinkOffset );\n\n      memcpy( &uncompressedData.front() + sizeof( uint32_t ) + x * sizeof( uint32_t ), &offset, sizeof( uint32_t ) );\n\n      size_t sz = nextIndex->first.size() + 1;\n\n      size_t prevSize = uncompressedData.size();\n      uncompressedData.resize( prevSize + sz );\n\n      memcpy( &uncompressedData.front() + prevSize, nextIndex->first.c_str(),\n              sz );\n\n      prevEntry = curEntry;\n    }\n\n    // Rightmost child\n    uint32_t offset = buildBtreeNode( nextIndex,\n                                      indexSize - prevEntry,\n                                      file, maxElements,\n                                      lastLeafLinkOffset );\n    memcpy( &uncompressedData.front() + sizeof( uint32_t ) +\n            maxElements * sizeof( uint32_t ), &offset, sizeof( offset ) );\n  }\n\n  // Save the result.\n\n  #ifdef __BTREE_USE_LZO\n\n  vector< unsigned char > compressedData( uncompressedData.size() + uncompressedData.size() / 16 + 64 + 3 );\n\n  char workMem[ LZO1X_1_MEM_COMPRESS ];\n\n  lzo_uint compressedSize;\n\n  if ( lzo1x_1_compress( &uncompressedData.front(), uncompressedData.size(),\n                         &compressedData.front(), &compressedSize, workMem )\n       != LZO_E_OK )\n  {\n    FDPRINTF( stderr, \"Failed to compress btree node.\\n\" );\n    abort();\n  }\n\n  #else\n\n  vector< unsigned char > compressedData( compressBound( uncompressedData.size() ) );\n\n  unsigned long compressedSize = compressedData.size();\n\n  if ( compress( &compressedData.front(), &compressedSize,\n                 &uncompressedData.front(), uncompressedData.size() ) != Z_OK )\n  {\n    qFatal( \"Failed to compress btree node.\" );\n    abort();\n  }\n\n  #endif\n\n  uint32_t offset = file.tell();\n\n  file.write< uint32_t >( uncompressedData.size() );\n  file.write< uint32_t >( compressedSize );\n  file.write( &compressedData.front(), compressedSize );\n\n  if ( isLeaf )\n  {\n    // A link to the next leef, which is zero and which will be updated\n    // should we happen to have another leaf.\n    \n    file.write( ( uint32_t ) 0 );\n\n    uint32_t here = file.tell();\n\n    if ( lastLeafLinkOffset )\n    {\n      // Update the previous leaf to have the offset of this one.\n      file.seek( lastLeafLinkOffset );\n      file.write( offset );\n      file.seek( here );\n    }\n\n    // Make sure next leaf knows where to write its offset for us.\n    lastLeafLinkOffset = here - sizeof( uint32_t );\n  }\n\n  return offset;\n}\n\nvoid IndexedWords::addWord( wstring const & word, uint32_t articleOffset, unsigned int maxHeadwordSize )\n{\n  wchar const * wordBegin = word.c_str();\n  string::size_type wordSize = word.size();\n\n  // Safeguard us against various bugs here. Don't attempt adding words\n  // which are freakishly huge.\n  if ( wordSize > maxHeadwordSize )\n  {\n#define MAX_LOG_WORD_SIZE 500\n    string headword;\n    if( wordSize <= MAX_LOG_WORD_SIZE )\n      headword = Utf8::encode( word );\n    else\n    {\n      std::vector< char > buffer( MAX_LOG_WORD_SIZE * 4 );\n      headword = string( &buffer.front(),\n                         Utf8::encode( wordBegin, MAX_LOG_WORD_SIZE, &buffer.front() ) );\n      headword += \"...\";\n    }\n    gdWarning( \"Skipped too long headword: \\\"%s\\\"\", headword.c_str() );\n    return;\n#undef MAX_LOG_WORD_SIZE\n  }\n\n  // Skip any leading whitespace\n  while( *wordBegin && Folding::isWhitespace( *wordBegin ) )\n  {\n    ++wordBegin;\n    --wordSize;\n  }\n\n  // Skip any trailing whitespace\n  while( wordSize && Folding::isWhitespace( wordBegin[ wordSize - 1 ] ) )\n    --wordSize;\n\n  wchar const * nextChar = wordBegin;\n\n  vector< char > utfBuffer( wordSize * 4 );\n\n  int wordsAdded = 0; // Number of stored parts\n\n  for( ; ; )\n  {\n    // Skip any whitespace/punctuation\n    for( ; ; ++nextChar )\n    {\n      if ( !*nextChar ) // End of string ends everything\n      {\n          if( wordsAdded == 0)\n          {\n              wstring folded = Folding::applyWhitespaceOnly( wstring( wordBegin, wordSize ) );\n              if( !folded.empty() )\n              {\n                  iterator i = insert(\n                    IndexedWords::value_type(\n                      string( &utfBuffer.front(),\n                              Utf8::encode( folded.data(), folded.size(), &utfBuffer.front() ) ),\n                      vector< WordArticleLink >() ) ).first;\n\n                  // Try to conserve memory somewhat -- slow insertions are ok\n                  i->second.reserve( i->second.size() + 1 );\n\n                  string utfWord( &utfBuffer.front(),\n                                  Utf8::encode( wordBegin, wordSize, &utfBuffer.front() ) );\n                  string utfPrefix;\n                  i->second.push_back( WordArticleLink( utfWord, articleOffset, utfPrefix ) );\n              }\n          }\n          return;\n      }\n  \n      if ( !Folding::isWhitespace( *nextChar ) && !Folding::isPunct( *nextChar ) )\n        break;\n    }\n\n    // Insert this word\n    wstring folded = Folding::apply( nextChar );\n    \n    iterator i = insert(\n      IndexedWords::value_type(\n        string( &utfBuffer.front(),\n                Utf8::encode( folded.data(), folded.size(), &utfBuffer.front() ) ),\n        vector< WordArticleLink >() ) ).first;\n\n    if ( ( i->second.size() < 1024 ) || ( nextChar == wordBegin ) ) // Don't overpopulate chains with middle matches\n    {\n      // Try to conserve memory somewhat -- slow insertions are ok\n      i->second.reserve( i->second.size() + 1 );\n  \n      string utfWord( &utfBuffer.front(),\n                      Utf8::encode( nextChar, wordSize - ( nextChar - wordBegin ), &utfBuffer.front() ) );\n  \n      string utfPrefix( &utfBuffer.front(),\n                        Utf8::encode( wordBegin, nextChar - wordBegin, &utfBuffer.front() ) );\n  \n      i->second.push_back( WordArticleLink( utfWord, articleOffset, utfPrefix ) );\n    }\n\n    wordsAdded += 1;\n\n    // Skip all non-whitespace/punctuation\n    for( ++nextChar; ; ++nextChar )\n    {\n      if ( !*nextChar )\n        return; // End of string ends everything\n\n      if ( Folding::isWhitespace( *nextChar ) || Folding::isPunct( *nextChar ) )\n        break;\n    }\n  }\n}\n\nvoid IndexedWords::addSingleWord( wstring const & word, uint32_t articleOffset )\n{\n  wstring folded = Folding::apply( word );\n  if( folded.empty() )\n      folded = Folding::applyWhitespaceOnly( word );\n  operator []( Utf8::encode( folded ) ).push_back(\n    WordArticleLink( Utf8::encode( word ), articleOffset ) );\n}\n\nIndexInfo buildIndex( IndexedWords const & indexedWords, File::Class & file )\n{\n  size_t indexSize = indexedWords.size();\n  IndexedWords::const_iterator nextIndex = indexedWords.begin();\n\n  // Skip any empty words. No point in indexing those, and some dictionaries\n  // are known to have buggy empty-word entries (Stardict's jargon for instance).\n\n  while( indexSize && nextIndex->first.empty() )\n  {\n    indexSize--;\n    ++nextIndex;\n  }\n\n  // We try to stick to two-level tree for most dictionaries. Try finding\n  // the right size for it.\n\n  size_t btreeMaxElements = ( (size_t) sqrt( (double) indexSize ) ) + 1;\n\n  if ( btreeMaxElements < BtreeMinElements )\n    btreeMaxElements = BtreeMinElements;\n  else\n  if ( btreeMaxElements > BtreeMaxElements )\n    btreeMaxElements = BtreeMaxElements;\n\n  GD_DPRINTF( \"Building a tree of %u elements\\n\", (unsigned) btreeMaxElements );\n\n  uint32_t lastLeafOffset = 0;\n\n  uint32_t rootOffset = buildBtreeNode( nextIndex, indexSize,\n                                        file, btreeMaxElements,\n                                        lastLeafOffset );\n\n  return IndexInfo( btreeMaxElements, rootOffset );\n}\n\nvoid BtreeIndex::getAllHeadwords( QSet< QString > & headwords )\n{\n  if ( !idxFile )\n    throw exIndexWasNotOpened();\n\n  findArticleLinks( NULL, NULL, &headwords );\n}\n\nvoid BtreeIndex::findAllArticleLinks( QVector< WordArticleLink > & articleLinks )\n{\n  if ( !idxFile )\n    throw exIndexWasNotOpened();\n\n  QSet< uint32_t > offsets;\n\n  findArticleLinks( &articleLinks, &offsets, NULL );\n}\n\nvoid BtreeIndex::findArticleLinks( QVector< WordArticleLink > * articleLinks,\n                                   QSet< uint32_t > * offsets,\n                                   QSet< QString > *headwords,\n                                   QAtomicInt * isCancelled )\n{\n  uint32_t currentNodeOffset = rootOffset;\n  uint32_t nextLeaf = 0;\n  uint32_t leafEntries;\n\n  Mutex::Lock _( *idxFileMutex );\n\n  if ( !rootNodeLoaded )\n  {\n    // Time to load our root node. We do it only once, at the first request.\n    readNode( rootOffset, rootNode );\n    rootNodeLoaded = true;\n  }\n\n  char const * leaf = &rootNode.front();\n  char const * leafEnd = leaf + rootNode.size();\n  char const * chainPtr = 0;\n\n  vector< char > extLeaf;\n\n  // Find first leaf\n\n  for( ; ; )\n  {\n    leafEntries = *(uint32_t *)leaf;\n\n    if( isCancelled && Qt4x5::AtomicInt::loadAcquire( *isCancelled ) )\n      return;\n\n    if ( leafEntries == 0xffffFFFF )\n    {\n      // A node\n      currentNodeOffset = *( (uint32_t *)leaf + 1 );\n      readNode( currentNodeOffset, extLeaf );\n      leaf = &extLeaf.front();\n      leafEnd = leaf + extLeaf.size();\n      nextLeaf = idxFile->read< uint32_t >();\n    }\n    else\n    {\n      // A leaf\n      chainPtr = leaf + sizeof( uint32_t );\n      break;\n    }\n  }\n\n  if ( !leafEntries )\n  {\n    // Empty leaf? This may only be possible for entirely empty trees only.\n    if ( currentNodeOffset != rootOffset )\n      throw exCorruptedChainData();\n    else\n      return; // No match\n  }\n\n  // Read all chains\n\n  for( ; ; )\n  {\n    vector< WordArticleLink > result = readChain( chainPtr );\n\n    if( headwords && static_cast< vector< WordArticleLink >::size_type >( headwords->capacity() ) < headwords->size() + result.size() )\n    {\n      int n = headwords->capacity();\n      headwords->reserve( n + n / 10 );\n    }\n\n    if( offsets && static_cast< vector< WordArticleLink >::size_type >( offsets->capacity() ) < offsets->size() + result.size() )\n    {\n      int n = offsets->capacity();\n      offsets->reserve( n + n / 10 );\n    }\n\n    if( articleLinks && static_cast< vector< WordArticleLink >::size_type >( articleLinks->capacity() ) < articleLinks->size() + result.size() )\n    {\n      int n = articleLinks->capacity();\n      articleLinks->reserve( n + n / 10 );\n    }\n\n    for( unsigned i = 0; i < result.size(); i++ )\n    {\n      if( isCancelled && Qt4x5::AtomicInt::loadAcquire( *isCancelled ) )\n        return;\n\n      if( headwords )\n        headwords->insert( QString::fromUtf8( ( result[ i ].prefix + result[ i ].word ).c_str() ) );\n\n      if( offsets && offsets->contains( result[ i ].articleOffset ) )\n        continue;\n\n      if( offsets )\n        offsets->insert( result[ i ].articleOffset );\n\n      if( articleLinks )\n        articleLinks->push_back( WordArticleLink( result[ i ].prefix + result[ i ].word, result[ i ].articleOffset ) );\n    }\n\n    if ( chainPtr >= leafEnd )\n    {\n      // We're past the current leaf, fetch the next one\n\n      if ( nextLeaf )\n      {\n        readNode( nextLeaf, extLeaf );\n        leaf = &extLeaf.front();\n        leafEnd = leaf + extLeaf.size();\n\n        nextLeaf = idxFile->read< uint32_t >();\n        chainPtr = leaf + sizeof( uint32_t );\n\n        leafEntries = *(uint32_t *)leaf;\n\n        if ( leafEntries == 0xffffFFFF )\n          throw exCorruptedChainData();\n      }\n      else\n        break; // That was the last leaf\n    }\n  }\n}\n\nvoid BtreeIndex::getHeadwordsFromOffsets( QList<uint32_t> & offsets,\n                                          QVector<QString> & headwords,\n                                          QAtomicInt * isCancelled )\n{\n  uint32_t currentNodeOffset = rootOffset;\n  uint32_t nextLeaf = 0;\n  uint32_t leafEntries;\n\n  std::sort( offsets.begin(), offsets.end() );\n\n  Mutex::Lock _( *idxFileMutex );\n\n  if ( !rootNodeLoaded )\n  {\n    // Time to load our root node. We do it only once, at the first request.\n    readNode( rootOffset, rootNode );\n    rootNodeLoaded = true;\n  }\n\n  char const * leaf = &rootNode.front();\n  char const * leafEnd = leaf + rootNode.size();\n  char const * chainPtr = 0;\n\n  vector< char > extLeaf;\n\n  // Find first leaf\n\n  for( ; ; )\n  {\n    leafEntries = *(uint32_t *)leaf;\n\n    if( isCancelled && Qt4x5::AtomicInt::loadAcquire( *isCancelled ) )\n      return;\n\n    if ( leafEntries == 0xffffFFFF )\n    {\n      // A node\n      currentNodeOffset = *( (uint32_t *)leaf + 1 );\n      readNode( currentNodeOffset, extLeaf );\n      leaf = &extLeaf.front();\n      leafEnd = leaf + extLeaf.size();\n      nextLeaf = idxFile->read< uint32_t >();\n    }\n    else\n    {\n      // A leaf\n      chainPtr = leaf + sizeof( uint32_t );\n      break;\n    }\n  }\n\n  if ( !leafEntries )\n  {\n    // Empty leaf? This may only be possible for entirely empty trees only.\n    if ( currentNodeOffset != rootOffset )\n      throw exCorruptedChainData();\n    else\n      return; // No match\n  }\n\n  // Read all chains\n\n  typedef QList< uint32_t >::Iterator ListIterator;\n  ListIterator begOffsets = offsets.begin();\n  ListIterator endOffsets = offsets.end();\n\n  for( ; ; )\n  {\n    vector< WordArticleLink > result = readChain( chainPtr );\n\n    for( unsigned i = 0; i < result.size(); i++ )\n    {\n      std::pair< ListIterator, ListIterator > const range = std::equal_range( begOffsets, endOffsets,\n                                                                              result.at( i ).articleOffset );\n\n      if( range.first != range.second )\n      {\n        if( isCancelled && Qt4x5::AtomicInt::loadAcquire( *isCancelled ) )\n          return;\n\n        headwords.append(  QString::fromUtf8( ( result[ i ].prefix + result[ i ].word ).c_str() ) );\n        offsets.erase( range.first );\n        begOffsets = offsets.begin();\n        endOffsets = offsets.end();\n      }\n\n      if( offsets.isEmpty() )\n        break;\n    }\n\n    if( offsets.isEmpty() )\n      break;\n\n    if ( chainPtr >= leafEnd )\n    {\n      // We're past the current leaf, fetch the next one\n\n      if ( nextLeaf )\n      {\n        readNode( nextLeaf, extLeaf );\n        leaf = &extLeaf.front();\n        leafEnd = leaf + extLeaf.size();\n\n        nextLeaf = idxFile->read< uint32_t >();\n        chainPtr = leaf + sizeof( uint32_t );\n\n        leafEntries = *(uint32_t *)leaf;\n\n        if ( leafEntries == 0xffffFFFF )\n          throw exCorruptedChainData();\n      }\n      else\n        break; // That was the last leaf\n    }\n  }\n}\n\nbool BtreeDictionary::getHeadwords( QStringList &headwords )\n{\n  QSet< QString > setOfHeadwords;\n\n  headwords.clear();\n  setOfHeadwords.reserve( getWordCount() );\n\n  try\n  {\n    getAllHeadwords( setOfHeadwords );\n\n    if( setOfHeadwords.size() )\n    {\n#if QT_VERSION >= 0x040700\n      headwords.reserve( setOfHeadwords.size() );\n#endif\n\n      QSet< QString >::const_iterator it = setOfHeadwords.constBegin();\n      QSet< QString >::const_iterator end = setOfHeadwords.constEnd();\n\n      for( ; it != end; ++it )\n        headwords.append( *it );\n    }\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"Failed headwords retrieving for \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n  }\n\n  return headwords.size() > 0;\n}\n\nvoid BtreeDictionary::getArticleText(uint32_t, QString &, QString & )\n{\n}\n\n}\n"
        },
        {
          "name": "btreeidx.hh",
          "type": "blob",
          "size": 9.49609375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __BTREEIDX_HH_INCLUDED__\n#define __BTREEIDX_HH_INCLUDED__\n\n#include \"dictionary.hh\"\n#include \"file.hh\"\n\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <QVector>\n#include <QSet>\n#include <QList>\n#include \"cpp_features.hh\"\n\n#if defined( _MSC_VER ) && _MSC_VER < 1800 // VS2012 and older\n#include <stdint_msvc.h>\n#else\n#include <stdint.h>\n#endif\n\n/// A base for the dictionary which creates a btree index to look up\n/// the words.\nnamespace BtreeIndexing {\n\nusing std::string;\nusing gd::wstring;\nusing std::vector;\nusing std::map;\n\nenum\n{\n  /// This is to be bumped up each time the internal format changes.\n  /// The value isn't used here by itself, it is supposed to be added\n  /// to each dictionary's internal format version.\n  FormatVersion = 4\n};\n\n// These exceptions which might be thrown during the index traversal\n\nDEF_EX( exIndexWasNotOpened, \"The index wasn't opened\", Dictionary::Ex )\nDEF_EX( exFailedToDecompressNode, \"Failed to decompress a btree's node\", Dictionary::Ex )\nDEF_EX( exCorruptedChainData, \"Corrupted chain data in the leaf of a btree encountered\", Dictionary::Ex )\n\n/// This structure describes a word linked to its translation. The\n/// translation is represented as an abstract 32-bit offset.\nstruct WordArticleLink\n{\n  string word, prefix; // in utf8\n  uint32_t articleOffset;\n\n  WordArticleLink()\n  {}\n\n  WordArticleLink( string const & word_, uint32_t articleOffset_, string const & prefix_ = string() ):\n    word( word_ ), prefix( prefix_ ), articleOffset( articleOffset_ )\n  {}\n};\n\n/// Information needed to open the index\nstruct IndexInfo\n{\n  uint32_t btreeMaxElements, rootOffset;\n\n  IndexInfo( uint32_t btreeMaxElements_, uint32_t rootOffset_ ):\n    btreeMaxElements( btreeMaxElements_ ), rootOffset( rootOffset_ )\n  {}\n};\n\n/// Base btree indexing class which allows using what buildIndex() function\n/// created. It's quite low-lovel and is basically a set of 'building blocks'\n/// functions.\nclass BtreeIndex\n{\npublic:\n\n  BtreeIndex();\n\n  /// Opens the index. The file reference is saved to be used for\n  /// subsequent lookups.\n  /// The mutex is the one to be locked when working with the file.\n  void openIndex( IndexInfo const &, File::Class &, Mutex & );\n\n  /// Finds articles that match the given string. A case-insensitive search\n  /// is performed.\n  vector< WordArticleLink > findArticles( wstring const &, bool ignoreDiacritics = false );\n\n  /// Find all unique article links in the index\n  void findAllArticleLinks( QVector< WordArticleLink > & articleLinks );\n\n  /// Retrieve all unique headwords from index\n  void getAllHeadwords( QSet< QString > & headwords );\n\n  /// Find all article links and/or headwords in the index\n  void findArticleLinks( QVector< WordArticleLink > * articleLinks,\n                         QSet< uint32_t > * offsets,\n                         QSet< QString > * headwords,\n                         QAtomicInt * isCancelled = 0 );\n\n  /// Retrieve headwords for presented article addresses\n  void getHeadwordsFromOffsets( QList< uint32_t > & offsets,\n                                QVector< QString > & headwords,\n                                QAtomicInt * isCancelled = 0 );\n\nprotected:\n\n  /// Finds the offset in the btree leaf for the given word, either matching\n  /// by an exact match, or by finding the smallest entry that might match\n  /// by prefix. It can return zero if there isn't even a possible prefx\n  /// match. The input string must already be folded. The exactMatch is set\n  /// to true when an exact match is located, and to false otherwise.\n  /// The located leaf is loaded to 'leaf', and the pointer to the next\n  /// leaf is saved to 'nextLeaf'.\n  /// However, due to root node being permanently cached, the 'leaf' passed\n  /// might not get used at all if the root node was the terminal one. In that\n  /// case, the returned pointer wouldn't belong to 'leaf' at all. To that end,\n  /// the leafEnd pointer always holds the pointer to the first byte outside\n  /// the node data.\n  char const * findChainOffsetExactOrPrefix( wstring const & target,\n                                             bool & exactMatch,\n                                             vector< char > & leaf,\n                                             uint32_t & nextLeaf,\n                                             char const * & leafEnd );\n\n  /// Reads a node or leaf at the given offset. Just uncompresses its data\n  /// to the given vector and does nothing more.\n  void readNode( uint32_t offset, vector< char > & out );\n\n  /// Reads the word-article links' chain at the given offset. The pointer\n  /// is updated to point to the next chain, if there's any.\n  vector< WordArticleLink > readChain( char const * & );\n\n  /// Drops any aliases which arose due to folding. Only case-folded aliases\n  /// are left.\n  void antialias( wstring const &, vector< WordArticleLink > &, bool ignoreDiactitics );\n\nprotected:\n\n  Mutex * idxFileMutex;\n  File::Class * idxFile;\n\nprivate:\n\n  uint32_t indexNodeSize;\n  uint32_t rootOffset;\n  bool rootNodeLoaded;\n  vector< char > rootNode; // We load root note here and keep it at all times,\n                           // since all searches always start with it.\n};\n\n/// A base for the dictionary that utilizes a btree index build using\n/// buildIndex() function declared below.\nclass BtreeDictionary: public Dictionary::Class, public BtreeIndex\n{\npublic:\n\n  BtreeDictionary( string const & id, vector< string > const & dictionaryFiles );\n\n  /// Btree-indexed dictionaries are usually a good source for compound searches.\n  virtual Dictionary::Features getFeatures() const throw()\n  { return Dictionary::SuitableForCompoundSearching; }\n\n  /// This function does the search using the btree index. Derivatives usually\n  /// need not to implement this function.\n  virtual sptr< Dictionary::WordSearchRequest > prefixMatch( wstring const &,\n                                                             unsigned long )\n    THROW_SPEC( std::exception );\n\n  virtual sptr< Dictionary::WordSearchRequest > stemmedMatch( wstring const &,\n                                                              unsigned minLength,\n                                                              unsigned maxSuffixVariation,\n                                                              unsigned long maxResults )\n    THROW_SPEC( std::exception );\n\n  virtual bool isLocalDictionary()\n  { return true; }\n\n  virtual bool getHeadwords( QStringList &headwords );\n\n  virtual void getArticleText( uint32_t articleAddress, QString & headword, QString & text );\n\n  string const & ftsIndexName() const\n  { return ftsIdxName; }\n\n  Mutex & getFtsMutex()\n  { return ftsIdxMutex; }\n\n  virtual uint32_t getFtsIndexVersion()\n  { return 0; }\n\n  // Sort articles offsets for full-text search in dictionary-specific order\n  // to increase of articles retrieving speed\n  // Default - simple sorting in increase order\n  virtual void sortArticlesOffsetsForFTS( QVector< uint32_t > & offsets,\n                                          QAtomicInt & isCancelled )\n  { Q_UNUSED( isCancelled ); std::sort( offsets.begin(), offsets.end() ); }\n\n  /// Called before each matching operation to ensure that any child init\n  /// has completed. Mainly used for deferred init. The default implementation\n  /// does nothing.\n  /// The function returns an empty string if the initialization is or was\n  /// successful, or a human-readable error string otherwise.\n  virtual string const & ensureInitDone();\n\nprotected:\n  Mutex ftsIdxMutex;\n  string ftsIdxName;\n\n  friend class BtreeWordSearchRequest;\n  friend class FTSResultsRequest;\n};\n\nclass BtreeWordSearchRequest: public Dictionary::WordSearchRequest\n{\n  friend class BtreeWordSearchRunnable;\nprotected:\n  BtreeDictionary & dict;\n  wstring str;\n  unsigned long maxResults;\n  unsigned minLength;\n  int maxSuffixVariation;\n  bool allowMiddleMatches;\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  BtreeWordSearchRequest( BtreeDictionary & dict_,\n                          wstring const & str_,\n                          unsigned minLength_,\n                          int maxSuffixVariation_,\n                          bool allowMiddleMatches_,\n                          unsigned long maxResults_,\n                          bool startRunnable = true );\n\n  virtual void findMatches();\n\n  void run(); // Run from another thread by BtreeWordSearchRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~BtreeWordSearchRequest();\n};\n\n// Everything below is for building the index data.\n\n/// This represents the index in its source form, as a map which binds folded\n/// words to sequences of their unfolded source forms and the corresponding\n/// article offsets. The words are utf8-encoded -- it doesn't break Unicode\n/// sorting, but conserves space.\nstruct IndexedWords: public map< string, vector< WordArticleLink > >\n{\n  /// Instead of adding to the map directly, use this function. It does folding\n  /// itself, and for phrases/sentences it adds additional entries beginning with\n  /// each new word.\n  void addWord( wstring const & word, uint32_t articleOffset, unsigned int maxHeadwordSize = 256U );\n\n  /// Differs from addWord() in that it only adds a single entry. We use this\n  /// for zip's file names.\n  void addSingleWord( wstring const & word, uint32_t articleOffset );\n};\n\n/// Builds the index, as a compressed btree. Returns IndexInfo.\n/// All the data is stored to the given file, beginning from its current\n/// position.\nIndexInfo buildIndex( IndexedWords const &, File::Class & file );\n\n}\n\n#endif\n\n"
        },
        {
          "name": "categorized_logging.hh",
          "type": "blob",
          "size": 2.0595703125,
          "content": "/* This file is (c) 2022 Igor Kushnir <igorkuo@gmail.com>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef CATEGORIZED_LOGGING_HH_INCLUDED\n#define CATEGORIZED_LOGGING_HH_INCLUDED\n\n// Lots of changes have been made to Qt's implementation of categorized logging in versions 5.3 and 5.4.\n// __VA_ARGS__ was introduced in C++11.\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 4, 0 ) && __cplusplus >= 201103L\n#include <QLoggingCategory>\n#define GD_CATEGORIZED_LOGGING\n#endif\n\n#ifdef GD_CATEGORIZED_LOGGING\nQ_DECLARE_LOGGING_CATEGORY( dictionaryResourceLc )\n\n#if !defined(QT_NO_WARNING_OUTPUT)\n/// Print a categorized warning message.\n#  define gdCWarning(category, ...) \\\n    for (bool qt_category_enabled = category().isWarningEnabled(); qt_category_enabled; qt_category_enabled = false) \\\n        gdCWarningImpl( category(), __VA_ARGS__ )\n#else\n#  define qCWarning(category, ...) QT_NO_QDEBUG_MACRO()\n#endif\n\n#if !defined(QT_NO_DEBUG_OUTPUT)\n/// Print a categorized debug message.\n#  define gdCDebug(category, ...) \\\n    for (bool qt_category_enabled = category().isDebugEnabled(); qt_category_enabled; qt_category_enabled = false) \\\n        gdCDebugImpl( category(), __VA_ARGS__ )\n#else\n#  define qCDebug(category, ...) QT_NO_QDEBUG_MACRO()\n#endif\n\nvoid gdCWarningImpl( QLoggingCategory const & category, char const * message, ... ) Q_ATTRIBUTE_FORMAT_PRINTF( 2, 3 );\nvoid gdCDebugImpl( QLoggingCategory const & category, char const * message, ... ) Q_ATTRIBUTE_FORMAT_PRINTF( 2, 3 );\n\n#else // GD_CATEGORIZED_LOGGING\n// Compatibility shims.\n\nenum GdLoggingCategory\n{\n  dictionaryResourceLc,\n};\n\n/// Equivalent to gdWarning( @p message, ... )\nvoid gdCWarning( GdLoggingCategory, char const * message, ... )\n#if defined(Q_CC_GNU) && !defined(__INSURE__)\n__attribute__ ((format (printf, 2, 3)))\n#endif\n;\n/// Equivalent to gdDebug( @p message, ... )\nvoid gdCDebug( GdLoggingCategory, char const * message, ... )\n#if defined(Q_CC_GNU) && !defined(__INSURE__)\n__attribute__ ((format (printf, 2, 3)))\n#endif\n;\n#endif // GD_CATEGORIZED_LOGGING\n\n#endif // CATEGORIZED_LOGGING_HH_INCLUDED\n"
        },
        {
          "name": "chinese.cc",
          "type": "blob",
          "size": 4.9384765625,
          "content": "/* This file is (c) 2015 Zhe Wang <0x1997@gmail.com>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"chinese.hh\"\n#include <stdexcept>\n#include <QCoreApplication>\n#ifdef Q_OS_MAC\n#include <opencc/opencc.h>\n#endif\n#include <opencc/Export.hpp>\n#include <opencc/SimpleConverter.hpp>\n#include \"folding.hh\"\n#include \"gddebug.hh\"\n#include \"transliteration.hh\"\n#include \"utf8.hh\"\n\nnamespace Chinese {\n\nclass CharacterConversionDictionary: public Transliteration::BaseTransliterationDictionary\n{\n#ifdef Q_OS_MAC\n  opencc_t converter;\n#else\n  opencc::SimpleConverter* converter;\n#endif\n\npublic:\n\n  CharacterConversionDictionary( std::string const & id, std::string const & name,\n                                 QIcon icon, QString const & openccConfig);\n  ~CharacterConversionDictionary();\n\n  std::vector< gd::wstring > getAlternateWritings( gd::wstring const & )\n    throw();\n};\n\nCharacterConversionDictionary::CharacterConversionDictionary( std::string const & id,\n                                                              std::string const & name_,\n                                                              QIcon icon_,\n                                                              QString const & openccConfig):\n  Transliteration::BaseTransliterationDictionary( id, name_, icon_, false ),\n  converter( NULL )\n{\n  try {\n#ifdef Q_OS_MAC\n    converter = opencc_open( openccConfig.toLocal8Bit().constData() );\n    if( converter == reinterpret_cast< opencc_t >( -1 ) )\n    {\n      gdWarning( \"CharacterConversionDictionary: failed to initialize OpenCC from config %s: %s\\n\",\n                 openccConfig.toLocal8Bit().constData(), opencc_error() );\n    }\n#else\n    converter = new opencc::SimpleConverter( openccConfig.toLocal8Bit().constData() );\n#endif\n  } catch ( std::runtime_error& e ) {\n    gdWarning( \"CharacterConversionDictionary: failed to initialize OpenCC from config %s: %s\\n\",\n               openccConfig.toLocal8Bit().constData(), e.what() );\n  }\n}\n\nCharacterConversionDictionary::~CharacterConversionDictionary()\n{\n#ifdef Q_OS_MAC\n  if ( converter != NULL && converter != reinterpret_cast< opencc_t >( -1 ) )\n    opencc_close( converter );\n#else\n  if ( converter != NULL )\n    delete converter;\n#endif\n}\n\nstd::vector< gd::wstring > CharacterConversionDictionary::getAlternateWritings( gd::wstring const & str )\n  throw()\n{\n  std::vector< gd::wstring > results;\n\n  if ( converter != NULL ) {\n    gd::wstring folded = Folding::applySimpleCaseOnly( str );\n    std::string input = Utf8::encode( folded );\n    std::string output;\n    gd::wstring result;\n\n    try {\n#ifdef Q_OS_MAC\n      if ( converter != NULL && converter != reinterpret_cast< opencc_t >( -1 ) )\n      {\n        char * tmp = opencc_convert_utf8( converter, input.c_str(), input.length() );\n        if( tmp )\n        {\n          output = std::string( tmp );\n          opencc_convert_utf8_free( tmp );\n        }\n        else\n          gdWarning( \"OpenCC: conversion failed %s\\n\", opencc_error() );\n      }\n#else\n      output = converter->Convert( input );\n#endif\n      result = Utf8::decode( output );\n    } catch ( std::exception& ex ) {\n      gdWarning( \"OpenCC: conversion failed %s\\n\", ex.what() );\n    }\n\n    if ( !result.empty() && result != folded )\n      results.push_back( result );\n  }\n\n  return results;\n}\n\nstd::vector< sptr< Dictionary::Class > > makeDictionaries( Config::Chinese const & cfg )\n  THROW_SPEC( std::exception )\n{\n  std::vector< sptr< Dictionary::Class > > result;\n\n#ifdef Q_OS_LINUX\n  QString configDir = \"\";\n#else\n  QString configDir = Config::getOpenCCDir();\n  if( !configDir.isEmpty() )\n    configDir += \"/\";\n#endif\n\n  if ( cfg.enable )\n  {\n    if ( cfg.enableSCToTWConversion )\n    {\n      result.push_back( new CharacterConversionDictionary( \"bf1c33a59cbacea8f39b5b5475787cfd\",\n                                                           QCoreApplication::translate( \"ChineseConversion\", \"Simplified to traditional Chinese (Taiwan variant) conversion\" ).toUtf8().data(),\n                                                           QIcon( \":/flags/tw.png\" ), configDir + \"s2tw.json\" ) );\n    }\n\n    if ( cfg.enableSCToHKConversion )\n    {\n      result.push_back( new CharacterConversionDictionary( \"9e0681fb9e1c0b6c90e6fb46111d96b5\",\n                                                           QCoreApplication::translate( \"ChineseConversion\", \"Simplified to traditional Chinese (Hong Kong variant) conversion\" ).toUtf8().data(),\n                                                           QIcon( \":/flags/hk.png\" ), configDir + \"s2hk.json\" ) );\n    }\n\n    if ( cfg.enableTCToSCConversion )\n    {\n      result.push_back( new CharacterConversionDictionary( \"0db536ce0bdc52ea30d11a82c5db4a27\",\n                                                           QCoreApplication::translate( \"ChineseConversion\", \"Traditional to simplified Chinese conversion\" ).toUtf8().data(),\n                                                           QIcon( \":/flags/cn.png\" ), configDir + \"t2s.json\" ) );\n    }\n  }\n\n  return result;\n}\n\n}\n"
        },
        {
          "name": "chinese.hh",
          "type": "blob",
          "size": 0.439453125,
          "content": "/* This file is (c) 2015 Zhe Wang <0x1997@gmail.com>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __CHINESE_HH_INCLUDED__\n#define __CHINESE_HH_INCLUDED__\n\n#include <map>\n#include \"config.hh\"\n#include \"dictionary.hh\"\n\n/// Chinese character conversion support.\nnamespace Chinese {\n\nstd::vector< sptr< Dictionary::Class > > makeDictionaries( Config::Chinese const & )\n  THROW_SPEC( std::exception );\n\n}\n\n#endif\n"
        },
        {
          "name": "chineseconversion.cc",
          "type": "blob",
          "size": 0.958984375,
          "content": "/* This file is (c) 2015 Zhe Wang <0x1997@gmail.com>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"chineseconversion.hh\"\n#include \"ui_chineseconversion.h\"\n\nChineseConversion::ChineseConversion(QWidget * parent, Config::Chinese const & cfg) :\n  QGroupBox(parent),\n  ui(new Ui::ChineseConversion)\n{\n  ui->setupUi( this );\n\n  setChecked( cfg.enable );\n  ui->enableSCToTWConversion->setChecked( cfg.enableSCToTWConversion );\n  ui->enableSCToHKConversion->setChecked( cfg.enableSCToHKConversion );\n  ui->enableTCToSCConversion->setChecked( cfg.enableTCToSCConversion );\n}\n\nChineseConversion::~ChineseConversion()\n{\n  delete ui;\n}\n\nvoid ChineseConversion::getConfig( Config::Chinese & cfg ) const\n{\n  cfg.enable = isChecked();\n  cfg.enableSCToTWConversion = ui->enableSCToTWConversion->isChecked();\n  cfg.enableSCToHKConversion = ui->enableSCToHKConversion->isChecked();\n  cfg.enableTCToSCConversion = ui->enableTCToSCConversion->isChecked();\n}\n"
        },
        {
          "name": "chineseconversion.hh",
          "type": "blob",
          "size": 0.580078125,
          "content": "/* This file is (c) 2015 Zhe Wang <0x1997@gmail.com>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __CHINESE_CONVERSION_HH_INCLUDED__\n#define __CHINESE_CONVERSION_HH_INCLUDED__\n\n#include <QGroupBox>\n#include \"config.hh\"\n\nnamespace Ui {\nclass ChineseConversion;\n}\n\nclass ChineseConversion : public QGroupBox\n{\n  Q_OBJECT\n\npublic:\n  ChineseConversion( QWidget * parent, Config::Chinese const & );\n  ~ChineseConversion();\n\n  void getConfig( Config::Chinese & ) const;\n\nprivate:\n  Ui::ChineseConversion *ui;\n};\n\n#endif // __CHINESE_CONVERSION_HH_INCLUDED__\n"
        },
        {
          "name": "chineseconversion.ui",
          "type": "blob",
          "size": 1.9716796875,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ui version=\"4.0\">\n <class>ChineseConversion</class>\n <widget class=\"QGroupBox\" name=\"ChineseConversion\">\n  <property name=\"geometry\">\n   <rect>\n    <x>0</x>\n    <y>0</y>\n    <width>689</width>\n    <height>128</height>\n   </rect>\n  </property>\n  <property name=\"sizePolicy\">\n   <sizepolicy hsizetype=\"Preferred\" vsizetype=\"Preferred\">\n    <horstretch>0</horstretch>\n    <verstretch>0</verstretch>\n   </sizepolicy>\n  </property>\n  <property name=\"windowTitle\">\n   <string>Chinese Conversion</string>\n  </property>\n  <property name=\"toolTip\">\n   <string>Enable conversion between simplified and traditional Chinese characters</string>\n  </property>\n  <property name=\"title\">\n   <string>Chinese Con&amp;version</string>\n  </property>\n  <property name=\"checkable\">\n   <bool>true</bool>\n  </property>\n  <layout class=\"QGridLayout\" name=\"gridLayout\">\n   <item row=\"0\" column=\"0\">\n    <widget class=\"QCheckBox\" name=\"enableSCToTWConversion\">\n     <property name=\"toolTip\">\n      <string>Enable conversion from simplified characters to traditional (Taiwan variant) characters</string>\n     </property>\n     <property name=\"text\">\n      <string>SC to TC (Taiwan variant)</string>\n     </property>\n    </widget>\n   </item>\n   <item row=\"0\" column=\"1\">\n    <widget class=\"QCheckBox\" name=\"enableSCToHKConversion\">\n     <property name=\"toolTip\">\n      <string>Enable conversion from simplified characters to traditional (Hong Kong variant) characters</string>\n     </property>\n     <property name=\"text\">\n      <string>SC to TC (Hong Kong variant)</string>\n     </property>\n    </widget>\n   </item>\n   <item row=\"0\" column=\"2\">\n    <widget class=\"QCheckBox\" name=\"enableTCToSCConversion\">\n     <property name=\"toolTip\">\n      <string>Enable conversion from traditional characters to simplified characters</string>\n     </property>\n     <property name=\"text\">\n      <string>TC to SC</string>\n     </property>\n    </widget>\n   </item>\n  </layout>\n </widget>\n <resources/>\n <connections/>\n</ui>\n"
        },
        {
          "name": "chunkedstorage.cc",
          "type": "blob",
          "size": 3.9443359375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"chunkedstorage.hh\"\n#include <zlib.h>\n#include <string.h>\n\nnamespace ChunkedStorage {\n\nenum\n{\n  ChunkMaxSize = 65536 // Can't be more since it would overflow the address\n};\n\nWriter::Writer( File::Class & f ):\n  file( f ), chunkStarted( false ), bufferUsed( 0 )\n{\n  // Create a sratchpad at the beginning of file. We use it to write chunk\n  // table if it would fit, in order to save some seek times.\n\n  char zero[ 4096 ];\n\n  memset( zero, 0, sizeof( zero ) );\n\n  scratchPadOffset = file.tell();\n  scratchPadSize = sizeof( zero );\n\n  file.write( zero, sizeof( zero ) );\n}\n\nuint32_t Writer::startNewBlock()\n{\n  if ( bufferUsed >= ChunkMaxSize )\n  {\n    // Need to flush first.\n    saveCurrentChunk();\n  }\n\n  chunkStarted = true;\n\n  // The address is comprised of the offset within the chunk (in lower\n  // 16 bits, always fits there since ChunkMaxSize-1 does) and the\n  // number of the chunk, which is therefore limited to be 65535 max.\n  return bufferUsed | ( (uint32_t)offsets.size() << 16 );\n}\n\nvoid Writer::addToBlock( void const * data, size_t size )\n{\n  if ( !size )\n    return;\n\n  if ( buffer.size() - bufferUsed < size )\n    buffer.resize( bufferUsed + size );\n\n  memcpy( &buffer.front() + bufferUsed, data, size );\n\n  bufferUsed += size;\n\n  chunkStarted = false;\n}\n\nvoid Writer::saveCurrentChunk()\n{\n  size_t maxCompressedSize = compressBound( bufferUsed );\n\n  if ( bufferCompressed.size() < maxCompressedSize )\n    bufferCompressed.resize( maxCompressedSize );\n\n  unsigned long compressedSize = bufferCompressed.size();\n\n  if ( compress( &bufferCompressed.front(), &compressedSize,\n                 &buffer.front(), bufferUsed ) != Z_OK )\n    throw exFailedToCompressChunk();\n\n  offsets.push_back( file.tell() );\n\n  file.write( (uint32_t) bufferUsed );\n  file.write( (uint32_t) compressedSize );\n  file.write( &bufferCompressed.front(), compressedSize );\n\n  bufferUsed = 0;\n\n  chunkStarted = false;\n}\n\nuint32_t Writer::finish()\n{\n  if ( bufferUsed || chunkStarted )\n    saveCurrentChunk();\n\n  bool useScratchPad = false;\n  uint32_t savedOffset = 0;\n\n  if ( scratchPadSize >= offsets.size() * sizeof( uint32_t ) + sizeof( uint32_t ) )\n  {\n    useScratchPad = true;\n    savedOffset = file.tell();\n    file.seek( scratchPadOffset );\n  }\n\n  uint32_t offset = file.tell();\n\n  file.write( (uint32_t) offsets.size() );\n\n  if ( offsets.size() )\n    file.write( &offsets.front(), offsets.size() * sizeof( uint32_t ) );\n\n  if ( useScratchPad )\n    file.seek( savedOffset );\n\n  offsets.clear();\n  chunkStarted = false;\n\n  return offset;\n}\n\nReader::Reader( File::Class & f, uint32_t offset ): file( f )\n{\n  file.seek( offset );\n\n  uint32_t size =  file.read< uint32_t >();\n  if ( size == 0 )\n    return;\n  offsets.resize( size );\n  file.read( &offsets.front(), offsets.size() * sizeof( uint32_t ) );\n}\n\nchar * Reader::getBlock( uint32_t address, vector< char > & chunk )\n{\n  size_t chunkIdx = address >> 16;\n\n  if ( chunkIdx >= offsets.size() )\n    throw exAddressOutOfRange();\n\n  // Read and decompress the chunk\n  {\n    file.seek( offsets[ chunkIdx ] );\n\n    uint32_t uncompressedSize = file.read< uint32_t >();\n    uint32_t compressedSize = file.read< uint32_t >();\n\n    chunk.resize( uncompressedSize );\n\n    vector< unsigned char > compressedData( compressedSize );\n\n    file.read( &compressedData.front(), compressedData.size() );\n\n    unsigned long decompressedLength = chunk.size();\n\n    if ( uncompress( (unsigned char *)&chunk.front(),\n                     &decompressedLength,\n                     &compressedData.front(),\n                     compressedData.size() ) != Z_OK ||\n         decompressedLength != chunk.size() )\n      throw exFailedToDecompressChunk();\n  }\n\n  size_t offsetInChunk = address & 0xffFF;\n\n  if ( offsetInChunk > chunk.size() ) // It can be equal to for 0-sized blocks\n    throw exAddressOutOfRange();\n\n  return &chunk.front() + offsetInChunk;\n}\n\n}\n"
        },
        {
          "name": "chunkedstorage.hh",
          "type": "blob",
          "size": 2.9345703125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __CHUNKEDSTORAGE_HH_INCLUDED__\n#define __CHUNKEDSTORAGE_HH_INCLUDED__\n\n#include \"ex.hh\"\n#include \"file.hh\"\n\n#include <vector>\n#if defined( _MSC_VER ) && _MSC_VER < 1800 // VS2012 and older\n#include <stdint_msvc.h>\n#else\n#include <stdint.h>\n#endif\n\n/// A chunked compression storage. We use this for articles' bodies. The idea\n/// is to store data in a separately-compressed chunks, much like in dictzip,\n/// but without any fancy gzip-compatibility or whatever. Another difference\n/// is that any block of data saved is always contained within one chunk,\n/// even if its size does exceed its maximum allowed size. This is very\n/// handy since we're retrieving the data by the same blocks we used to save\n/// it as, that' the only kind of seek we support, really.\nnamespace ChunkedStorage {\n\nusing std::vector;\n\nDEF_EX( Ex, \"Chunked storage exception\", std::exception )\nDEF_EX( exFailedToCompressChunk, \"Failed to compress a chunk\", Ex )\nDEF_EX( exAddressOutOfRange, \"The given chunked address is out of range\", Ex )\nDEF_EX( exFailedToDecompressChunk, \"Failed to decompress a chunk\", Ex )\n\n/// This class writes data blocks in chunks.\nclass Writer\n{\n  vector< uint32_t > offsets;\n  File::Class & file;\n  size_t scratchPadOffset, scratchPadSize;\n\npublic:\n\n  Writer( File::Class & );\n\n  /// Starts new block. Returns its address.\n  uint32_t startNewBlock();\n\n  /// Add data to the previously started block.\n  void addToBlock( void const * data, size_t size );\n\n  /// Finishes writing chunks and returns the offset to the chunk table which\n  /// gets written at the moment of finishing.\n  uint32_t finish();\n\nprivate:\n\n  /// Indicates that an address was allocated, which would mean the writeout\n  /// of the pending chunk is required even if its size is zero.\n  bool chunkStarted;\n\n  // This buffer accumulates the chunk data until either enough data is\n  // stored (>=ChunkMaxSize), or there's no more data left to store.\n  vector< unsigned char > buffer;\n\n  // Here we compress the chunk before writing it out to file.\n  vector< unsigned char > bufferCompressed;\n\n  // The amount of data stored in buffer so far. We keep it separate\n  // from buffer.size() for performance reasons; the latter one only\n  // grows, but never shrinks.\n  size_t bufferUsed;\n\n  void saveCurrentChunk();\n};\n\n/// This class reads data blocks previously written by Writer.\nclass Reader\n{\n  vector< uint32_t > offsets;\n  File::Class & file;\n\npublic:\n  /// Creates reader by giving it a file to read from and the offset returned\n  /// by Writer::finish().\n  Reader( File::Class &, uint32_t );\n\n  /// Reads the block previously written by Writer, identified by its address.\n  /// Uses the user-provided storage to load the entire chunk, and then to\n  /// return a pointer to the requested block inside it.\n  char * getBlock( uint32_t address, vector< char > & );\n};\n\n}\n\n#endif\n"
        },
        {
          "name": "config.cc",
          "type": "blob",
          "size": 85.9853515625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"config.hh\"\n#include \"folding.hh\"\n#include \"wstring_qt.hh\"\n#include <QDir>\n#include <QFile>\n#include <QtXml>\n#include \"gddebug.hh\"\n\n#if defined( _MSC_VER ) && _MSC_VER < 1800 // VS2012 and older\n#include <stdint_msvc.h>\n#else\n#include <stdint.h>\n#endif\n\n#ifdef Q_OS_WIN32\n#include \"shlobj.h\"\n#endif\n\n#include \"atomic_rename.hh\"\n#include \"qt4x5.hh\"\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n#include <QStandardPaths>\n#else\n#include <QDesktopServices>\n#endif\n\n#if defined( HAVE_X11 ) && QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n// Whether XDG Base Directory specification might be followed.\n// Only Qt5 builds are supported, as Qt4 doesn't provide all functions needed\n// to get XDG Base Directory compliant locations.\n#define XDG_BASE_DIRECTORY_COMPLIANCE\n#endif\n\nnamespace Config {\n\nnamespace\n{\n#ifdef XDG_BASE_DIRECTORY_COMPLIANCE\n  const char xdgSubdirName[] = \"goldendict\";\n\n  QDir getDataDir()\n  {\n    QDir dir = QStandardPaths::writableLocation( QStandardPaths::GenericDataLocation );\n    dir.mkpath( xdgSubdirName );\n    if ( !dir.cd( xdgSubdirName ) )\n      throw exCantUseDataDir();\n\n    return dir;\n  }\n#endif\n\n  QString portableHomeDirPath()\n  {\n    return QCoreApplication::applicationDirPath() + \"/portable\";\n  }\n\n  QDir getHomeDir()\n  {\n    if ( isPortableVersion() )\n      return QDir( portableHomeDirPath() );\n\n    QDir result;\n\n    result = QDir::home();\n    #ifdef Q_OS_WIN32\n      if ( result.cd( \"Application Data/GoldenDict\" ) )\n        return result;\n      char const * pathInHome = \"GoldenDict\";\n      result = QDir::fromNativeSeparators( QString::fromWCharArray( _wgetenv( L\"APPDATA\" ) ) );\n    #else\n      char const * pathInHome = \".goldendict\";\n      #ifdef XDG_BASE_DIRECTORY_COMPLIANCE\n        // check if an old config dir is present, otherwise use standards-compliant location\n        if ( !result.exists( pathInHome ) )\n        {\n          result.setPath( QStandardPaths::writableLocation( QStandardPaths::ConfigLocation ) );\n          pathInHome = xdgSubdirName;\n        }\n      #endif\n    #endif\n\n    result.mkpath( pathInHome );\n\n    if ( !result.cd( pathInHome ) )\n      throw exCantUseHomeDir();\n\n    return result;\n  }\n\n}\n\nProxyServer::ProxyServer(): enabled( false ), useSystemProxy( false ), type( Socks5 ), port( 3128 )\n{\n}\n\nHotKey::HotKey(): modifiers(), key1( 0 ), key2( 0 )\n{\n}\n\n// Does anyone know how to separate modifiers from the keycode? We'll\n// use our own mask.\n\nuint32_t const keyMask = 0x01FFFFFF;\n\nHotKey::HotKey( QKeySequence const & seq ):\n  modifiers( seq[ 0 ] & ~keyMask ),\n  key1( seq[ 0 ] & keyMask ),\n  key2( seq[ 1 ] & keyMask )\n{\n}\n\nQKeySequence HotKey::toKeySequence() const\n{\n  int v2 = key2 ? ( key2 | modifiers ): 0;\n\n  return QKeySequence( key1 | modifiers, v2 );\n}\n\nbool InternalPlayerBackend::anyAvailable()\n{\n#if defined( MAKE_FFMPEG_PLAYER ) || defined( MAKE_QTMULTIMEDIA_PLAYER )\n  return true;\n#else\n  return false;\n#endif\n}\n\nInternalPlayerBackend InternalPlayerBackend::defaultBackend()\n{\n#if defined( MAKE_FFMPEG_PLAYER )\n  return ffmpeg();\n#elif defined( MAKE_QTMULTIMEDIA_PLAYER )\n  return qtmultimedia();\n#else\n  return InternalPlayerBackend( QString() );\n#endif\n}\n\nQStringList InternalPlayerBackend::nameList()\n{\n  QStringList result;\n#ifdef MAKE_FFMPEG_PLAYER\n  result.push_back( ffmpeg().uiName() );\n#endif\n#ifdef MAKE_QTMULTIMEDIA_PLAYER\n  result.push_back( qtmultimedia().uiName() );\n#endif\n  return result;\n}\n\nbool InternalPlayerBackend::isFfmpeg() const\n{\n#ifdef MAKE_FFMPEG_PLAYER\n  return *this == ffmpeg();\n#else\n  return false;\n#endif\n}\n\nbool InternalPlayerBackend::isQtmultimedia() const\n{\n#ifdef MAKE_QTMULTIMEDIA_PLAYER\n  return *this == qtmultimedia();\n#else\n  return false;\n#endif\n}\n\nScanPopupWindowFlags spwfFromInt( int id )\n{\n  if( id == SPWF_Popup )\n    return SPWF_Popup;\n  if( id == SPWF_Tool )\n    return SPWF_Tool;\n\n  if( id != SPWF_default )\n    gdWarning( \"Invalid ScanPopup unpinned window flags: %d\\n\", id );\n  return SPWF_default;\n}\n\nInputPhrase Preferences::sanitizeInputPhrase( QString const & inputPhrase ) const\n{\n  InputPhrase result;\n\n  if( limitInputPhraseLength && inputPhrase.size() > inputPhraseLengthLimit )\n  {\n    gdDebug( \"Ignoring an input phrase %d symbols long. The configured maximum input phrase length is %d symbols.\",\n             inputPhrase.size(), inputPhraseLengthLimit );\n    return result;\n  }\n\n  const QString withPunct = inputPhrase.simplified().remove( QChar( 0xAD ) ); // Simplify whitespaces and remove soft hyphens\n  result.phrase = gd::toQString( Folding::trimWhitespaceOrPunct( gd::toWString( withPunct ) ) );\n  if ( !result.isValid() )\n    return result; // The suffix of an invalid input phrase must be empty.\n\n  const int prefixSize = withPunct.indexOf( result.phrase.at(0) );\n  const int suffixSize = withPunct.size() - prefixSize - result.phrase.size();\n  Q_ASSERT( suffixSize >= 0 );\n  Q_ASSERT( withPunct.size() - suffixSize - 1\n            == withPunct.lastIndexOf( result.phrase.at( result.phrase.size() - 1 ) ) );\n  if ( suffixSize != 0 )\n    result.punctuationSuffix = withPunct.right( suffixSize );\n\n  return result;\n}\n\nPreferences::Preferences():\n  newTabsOpenAfterCurrentOne( false ),\n  newTabsOpenInBackground( true ),\n  hideSingleTab( false ),\n  mruTabOrder ( false ),\n  hideMenubar( false ),\n  enableTrayIcon( true ),\n  startToTray( false ),\n  closeToTray( true ),\n  autoStart( false ),\n  doubleClickTranslates( true ),\n  selectWordBySingleClick( false ),\n  escKeyHidesMainWindow( false ),\n  alwaysOnTop ( false ),\n  searchInDock ( false ),\n\n  enableMainWindowHotkey( true ),\n  mainWindowHotkey( QKeySequence( \"Ctrl+F11,F11\" ) ),\n  enableClipboardHotkey( true ),\n  clipboardHotkey( QKeySequence( \"Ctrl+C,C\" ) ),\n\n  enableScanPopup( true ),\n  startWithScanPopupOn( false ),\n  enableScanPopupModifiers( false ),\n  scanPopupModifiers( 0 ),\n  scanPopupAltMode( false ),\n  scanPopupAltModeSecs( 3 ),\n  ignoreOwnClipboardChanges( false ),\n  scanPopupUseUIAutomation( true ),\n  scanPopupUseIAccessibleEx( true ),\n  scanPopupUseGDMessage( true ),\n  scanPopupUnpinnedWindowFlags( SPWF_default ),\n  scanPopupUnpinnedBypassWMHint( false ),\n  scanToMainWindow( false ),\n  ignoreDiacritics( false ),\n#ifdef HAVE_X11\n  showScanFlag( false ),\n#endif\n  pronounceOnLoadMain( false ),\n  pronounceOnLoadPopup( false ),\n  useInternalPlayer( InternalPlayerBackend::anyAvailable() ),\n  internalPlayerBackend( InternalPlayerBackend::defaultBackend() ),\n  checkForNewReleases( true ),\n  disallowContentFromOtherSites( false ),\n  enableWebPlugins( false ),\n  hideGoldenDictHeader( false ),\n  maxNetworkCacheSize( 50 ),\n  clearNetworkCacheOnExit( true ),\n  zoomFactor( 1 ),\n  helpZoomFactor( 1 ),\n  wordsZoomLevel( 0 ),\n  maxStringsInHistory( 500 ),\n  storeHistory( 1 ),\n  alwaysExpandOptionalParts( false )\n, historyStoreInterval( 0 )\n, favoritesStoreInterval( 0 )\n, confirmFavoritesDeletion( true )\n, collapseBigArticles( false )\n, articleSizeLimit( 2000 )\n, limitInputPhraseLength( false )\n, inputPhraseLengthLimit( 1000 )\n, maxDictionaryRefsInContextMenu ( 20 )\n#ifndef Q_WS_X11\n, trackClipboardChanges( false )\n#endif\n, synonymSearchEnabled( true )\n{\n}\n\n#ifdef MAKE_CHINESE_CONVERSION_SUPPORT\nChinese::Chinese():\n  enable( false ),\n  enableSCToTWConversion( true ),\n  enableSCToHKConversion( true ),\n  enableTCToSCConversion( true )\n{\n}\n#endif\n\nRomaji::Romaji():\n  enable( false ),\n  enableHepburn( true ),\n  enableNihonShiki( false ),\n  enableKunreiShiki( false ),\n  enableHiragana( true ),\n  enableKatakana( true )\n{\n}\n\nGroup * Class::getGroup( unsigned id )\n{\n  for( int x = 0; x < groups.size(); x++ )\n    if( groups.at( x ).id == id )\n      return &groups[ x ];\n  return 0;\n}\n\nGroup const * Class::getGroup( unsigned id ) const\n{\n  for( int x = 0; x < groups.size(); x++ )\n    if( groups.at( x ).id == id )\n      return &groups.at( x );\n  return 0;\n}\n\nvoid Events::signalMutedDictionariesChanged()\n{\n  emit mutedDictionariesChanged();\n}\n\nnamespace {\n\nMediaWikis makeDefaultMediaWikis( bool enable )\n{\n  MediaWikis mw;\n\n  mw.push_back( MediaWiki( \"ae6f89aac7151829681b85f035d54e48\", \"English Wikipedia\", \"https://en.wikipedia.org/w\", enable, \"\" ) );\n  mw.push_back( MediaWiki( \"affcf9678e7bfe701c9b071f97eccba3\", \"English Wiktionary\", \"https://en.wiktionary.org/w\", false, \"\"  ) );\n  mw.push_back( MediaWiki( \"8e0c1c2b6821dab8bdba8eb869ca7176\", \"Russian Wikipedia\", \"https://ru.wikipedia.org/w\", false, \"\" ) );\n  mw.push_back( MediaWiki( \"b09947600ae3902654f8ad4567ae8567\", \"Russian Wiktionary\", \"https://ru.wiktionary.org/w\", false, \"\" ) );\n  mw.push_back( MediaWiki( \"a8a66331a1242ca2aeb0b4aed361c41d\", \"German Wikipedia\", \"https://de.wikipedia.org/w\", false, \"\" ) );\n  mw.push_back( MediaWiki( \"21c64bca5ec10ba17ff19f3066bc962a\", \"German Wiktionary\", \"https://de.wiktionary.org/w\", false, \"\" ) );\n  mw.push_back( MediaWiki( \"96957cb2ad73a20c7a1d561fc83c253a\", \"Portuguese Wikipedia\", \"https://pt.wikipedia.org/w\", false, \"\" ) );\n  mw.push_back( MediaWiki( \"ed4c3929196afdd93cc08b9a903aad6a\", \"Portuguese Wiktionary\", \"https://pt.wiktionary.org/w\", false, \"\" ) );\n  mw.push_back( MediaWiki( \"f3b4ec8531e52ddf5b10d21e4577a7a2\", \"Greek Wikipedia\", \"https://el.wikipedia.org/w\", false, \"\" ) );\n  mw.push_back( MediaWiki( \"5d45232075d06e002dea72fe3e137da1\", \"Greek Wiktionary\", \"https://el.wiktionary.org/w\", false, \"\" ) );\n\n  return mw;\n}\n\nWebSites makeDefaultWebSites()\n{\n  WebSites ws;\n\n  ws.push_back( WebSite( \"b88cb2898e634c6638df618528284c2d\", \"Google En-En (Oxford)\", \"https://www.google.com/search?q=define:%GDWORD%&hl=en\", false, \"\", true ) );\n  ws.push_back( WebSite( \"f376365a0de651fd7505e7e5e683aa45\", \"Urban Dictionary\", \"https://www.urbandictionary.com/define.php?term=%GDWORD%\", false, \"\", true ) );\n  ws.push_back( WebSite( \"324ca0306187df7511b26d3847f4b07c\", \"Multitran (En)\", \"https://multitran.ru/c/m.exe?CL=1&l1=1&s=%GD1251%\", false, \"\", true ) );\n  ws.push_back( WebSite( \"924db471b105299c82892067c0f10787\", \"Lingvo (En-Ru)\", \"http://lingvopro.abbyyonline.com/en/Search/en-ru/%GDWORD%\", false, \"\", true ) );\n  ws.push_back( WebSite( \"087a6d65615fb047f4c80eef0a9465db\", \"Michaelis (Pt-En)\", \"http://michaelis.uol.com.br/moderno/ingles/index.php?lingua=portugues-ingles&palavra=%GDISO1%\", false, \"\", true ) );\n\n  return ws;\n}\n\nDictServers makeDefaultDictServers()\n{\n  DictServers ds;\n\n  return ds;\n}\n\nPrograms makeDefaultPrograms()\n{\n  Programs programs;\n\n  // The following list doesn't make a lot of sense under Windows\n#ifndef Q_OS_WIN\n  programs.push_back( Program( false, Program::Audio, \"428b4c2b905ef568a43d9a16f59559b0\", \"Festival\", \"festival --tts\", \"\" ) );\n  programs.push_back( Program( false, Program::Audio, \"2cf8b3a60f27e1ac812de0b57c148340\", \"Espeak\", \"espeak %GDWORD%\", \"\" ) );\n  programs.push_back( Program( false, Program::Html, \"4f898f7582596cea518c6b0bfdceb8b3\", \"Manpages\", \"man -a --html=/bin/cat %GDWORD%\", \"\" ) );\n#endif\n\n  return programs;\n}\n\n/// Sets option to true of false if node is \"1\" or \"0\" respectively, or leaves\n/// it intact if it's neither \"1\" nor \"0\".\nvoid applyBoolOption( bool & option, QDomNode const & node )\n{\n  QString value = node.toElement().text();\n\n  if ( value == \"1\" )\n    option = true;\n  else\n  if ( value == \"0\" )\n    option = false;\n}\n\nGroup loadGroup( QDomElement grp, unsigned * nextId = 0 )\n{\n  Group g;\n\n  if ( grp.hasAttribute( \"id\" ) )\n    g.id = grp.attribute( \"id\" ).toUInt();\n  else\n    g.id = nextId ? (*nextId)++ : 0;\n\n  g.name = grp.attribute( \"name\" );\n  g.icon = grp.attribute( \"icon\" );\n  g.favoritesFolder = grp.attribute( \"favoritesFolder\" );\n\n  if ( !grp.attribute( \"iconData\" ).isEmpty() )\n    g.iconData = QByteArray::fromBase64( grp.attribute( \"iconData\" ).toLatin1() );\n\n  if ( !grp.attribute( \"shortcut\" ).isEmpty() )\n    g.shortcut = QKeySequence::fromString( grp.attribute( \"shortcut\" ) );\n\n  QDomNodeList dicts = grp.elementsByTagName( \"dictionary\" );\n\n  for( Qt4x5::Dom::size_type y = 0; y < dicts.length(); ++y )\n    g.dictionaries.push_back( DictionaryRef( dicts.item( y ).toElement().text(),\n                                             dicts.item( y ).toElement().attribute( \"name\" ) ) );\n\n  QDomNode muted = grp.namedItem( \"mutedDictionaries\" );\n  dicts = muted.toElement().elementsByTagName( \"mutedDictionary\" );\n  for( Qt4x5::Dom::size_type x = 0; x < dicts.length(); ++x )\n    g.mutedDictionaries.insert( dicts.item( x ).toElement().text() );\n\n  dicts = muted.toElement().elementsByTagName( \"popupMutedDictionary\" );\n  for( Qt4x5::Dom::size_type x = 0; x < dicts.length(); ++x )\n    g.popupMutedDictionaries.insert( dicts.item( x ).toElement().text() );\n\n  return g;\n}\n\nMutedDictionaries loadMutedDictionaries( QDomNode mutedDictionaries )\n{\n  MutedDictionaries result;\n\n  if ( !mutedDictionaries.isNull() )\n  {\n    QDomNodeList nl = mutedDictionaries.toElement().\n                        elementsByTagName( \"mutedDictionary\" );\n\n    for( Qt4x5::Dom::size_type x = 0; x < nl.length(); ++x )\n      result.insert( nl.item( x ).toElement().text() );\n  }\n\n  return result;\n}\n\nvoid saveMutedDictionaries( QDomDocument & dd, QDomElement & muted,\n                            MutedDictionaries const & mutedDictionaries )\n{\n  for( MutedDictionaries::const_iterator i = mutedDictionaries.begin();\n       i != mutedDictionaries.end(); ++i )\n  {\n    QDomElement dict = dd.createElement( \"mutedDictionary\" );\n    muted.appendChild( dict );\n\n    QDomText value = dd.createTextNode( *i );\n    dict.appendChild( value );\n  }\n}\n\n}\n\nClass load() THROW_SPEC( exError )\n{\n  QString configName  = getConfigFileName();\n\n  bool loadFromTemplate = false;\n\n  if ( !QFile::exists( configName ) )\n  {\n    // Make the default config, save it and return it\n    Class c;\n\n    #ifdef Q_OS_LINUX\n    if ( QDir( \"/usr/share/stardict/dic\" ).exists() )\n      c.paths.push_back( Path( \"/usr/share/stardict/dic\", true ) );\n\n    if ( QDir( \"/usr/share/dictd\" ).exists() )\n      c.paths.push_back( Path( \"/usr/share/dictd\", true ) );\n\n    if ( QDir( \"/usr/share/opendict/dictionaries\" ).exists() )\n      c.paths.push_back( Path( \"/usr/share/opendict/dictionaries\", true ) );\n\n    if ( QDir( \"/usr/share/goldendict-wordnet\" ).exists() )\n      c.paths.push_back( Path( \"/usr/share/goldendict-wordnet\", true ) );\n\n    if ( QDir( \"/usr/share/WyabdcRealPeopleTTS\" ).exists() )\n      c.soundDirs.push_back( SoundDir( \"/usr/share/WyabdcRealPeopleTTS\", \"WyabdcRealPeopleTTS\" ) );\n\n    if ( QDir( \"/usr/share/myspell/dicts\" ).exists() )\n      c.hunspell.dictionariesPath = \"/usr/share/myspell/dicts\";\n\n    #endif\n\n    #ifdef Q_OS_WIN32\n\n    // get path to Program Files\n    wchar_t buf[ MAX_PATH ];\n    SHGetFolderPathW( NULL, CSIDL_PROGRAM_FILES, NULL, 0, buf );\n    QString pathToProgramFiles = QString::fromWCharArray( buf );\n    if ( pathToProgramFiles.isEmpty() )\n      pathToProgramFiles = \"C:\\\\Program Files\";\n\n    if ( QDir( pathToProgramFiles + \"\\\\StarDict\\\\dic\" ).exists() )\n      c.paths.push_back( Path( pathToProgramFiles + \"\\\\StarDict\\\\dic\", true ) );\n\n    if ( QDir( pathToProgramFiles + \"\\\\StarDict\\\\WyabdcRealPeopleTTS\" ).exists() )\n      c.soundDirs.push_back( SoundDir( pathToProgramFiles + \"\\\\StarDict\\\\WyabdcRealPeopleTTS\", \"WyabdcRealPeopleTTS\" ) );\n    else\n    if ( QDir( pathToProgramFiles + \"\\\\WyabdcRealPeopleTTS\" ).exists() )\n      c.soundDirs.push_back( SoundDir( pathToProgramFiles + \"\\\\WyabdcRealPeopleTTS\", \"WyabdcRealPeopleTTS\" ) );\n\n    // #### \"C:/Program Files\" is bad! will not work for German Windows etc.\n    // #### should be replaced to system path\n\n//    if ( QDir( \"C:/Program Files/StarDict/dic\" ).exists() )\n//      c.paths.push_back( Path( \"C:/Program Files/StarDict/dic\", true ) );\n//\n//    if ( QDir( \"C:/Program Files/StarDict/WyabdcRealPeopleTTS\" ).exists() )\n//      c.soundDirs.push_back( SoundDir( \"C:/Program Files/StarDict/WyabdcRealPeopleTTS\", \"WyabdcRealPeopleTTS\" ) );\n//    else\n//    if ( QDir( \"C:/Program Files/WyabdcRealPeopleTTS\" ).exists() )\n//      c.soundDirs.push_back( SoundDir( \"C:/Program Files/WyabdcRealPeopleTTS\", \"WyabdcRealPeopleTTS\" ) );\n\n    #endif\n\n    #ifndef Q_OS_WIN32\n    c.preferences.audioPlaybackProgram = \"mplayer\";\n    #endif\n\n    QString possibleMorphologyPath = getProgramDataDir() + \"/content/morphology\";\n\n    if ( QDir( possibleMorphologyPath ).exists() )\n      c.hunspell.dictionariesPath = possibleMorphologyPath;\n\n    c.mediawikis = makeDefaultMediaWikis( true );\n    c.webSites = makeDefaultWebSites();\n    c.dictServers = makeDefaultDictServers();\n    c.programs = makeDefaultPrograms();\n\n    // Check if we have a template config file. If we do, load it instead\n\n    configName = getProgramDataDir() + \"/content/defconfig\";\n    loadFromTemplate = QFile( configName ).exists();\n\n    if ( !loadFromTemplate )\n    {\n      save( c );\n\n      return c;\n    }\n  }\n\n  getStylesDir();\n\n  QFile configFile( configName );\n\n  if ( !configFile.open( QFile::ReadOnly ) )\n    throw exCantReadConfigFile();\n\n  QDomDocument dd;\n\n  QString errorStr;\n  int errorLine, errorColumn;\n\n  if ( !loadFromTemplate )\n  {\n    // Load the config as usual\n    if ( !dd.setContent( &configFile, false, &errorStr, &errorLine, &errorColumn  ) )\n    {\n      GD_DPRINTF( \"Error: %s at %d,%d\\n\", errorStr.toLocal8Bit().constData(),  errorLine,  errorColumn );\n        throw exMalformedConfigFile();\n    }\n  }\n  else\n  {\n    // We need to replace all %PROGRAMDIR% with the program data dir\n    QByteArray data = configFile.readAll();\n\n    data.replace( \"%PROGRAMDIR%\", getProgramDataDir().toUtf8() );\n\n    QBuffer bufferedData( &data );\n\n    if ( !dd.setContent( &bufferedData, false, &errorStr, &errorLine, &errorColumn  ) )\n    {\n      GD_DPRINTF( \"Error: %s at %d,%d\\n\", errorStr.toLocal8Bit().constData(),  errorLine,  errorColumn );\n        throw exMalformedConfigFile();\n    }\n  }\n\n  configFile.close();\n\n  QDomNode root = dd.namedItem( \"config\" );\n\n  Class c;\n\n  QDomNode paths = root.namedItem( \"paths\" );\n\n  if ( !paths.isNull() )\n  {\n    QDomNodeList nl = paths.toElement().elementsByTagName( \"path\" );\n\n    for( Qt4x5::Dom::size_type x = 0; x < nl.length(); ++x )\n      c.paths.push_back(\n        Path( nl.item( x ).toElement().text(),\n              nl.item( x ).toElement().attribute( \"recursive\" ) == \"1\" ) );\n  }\n\n  QDomNode soundDirs = root.namedItem( \"sounddirs\" );\n\n  if ( !soundDirs.isNull() )\n  {\n    QDomNodeList nl = soundDirs.toElement().elementsByTagName( \"sounddir\" );\n\n    for( Qt4x5::Dom::size_type x = 0; x < nl.length(); ++x )\n      c.soundDirs.push_back(\n        SoundDir( nl.item( x ).toElement().text(),\n                  nl.item( x ).toElement().attribute( \"name\" ),\n                  nl.item( x ).toElement().attribute( \"icon\" ) ) );\n  }\n\n  QDomNode dictionaryOrder = root.namedItem( \"dictionaryOrder\" );\n\n  if ( !dictionaryOrder.isNull() )\n    c.dictionaryOrder = loadGroup( dictionaryOrder.toElement() );\n\n  QDomNode inactiveDictionaries = root.namedItem( \"inactiveDictionaries\" );\n\n  if ( !inactiveDictionaries.isNull() )\n    c.inactiveDictionaries = loadGroup( inactiveDictionaries.toElement() );\n\n  QDomNode groups = root.namedItem( \"groups\" );\n\n  if ( !groups.isNull() )\n  {\n    c.groups.nextId = groups.toElement().attribute( \"nextId\", \"1\" ).toUInt();\n\n    QDomNodeList nl = groups.toElement().elementsByTagName( \"group\" );\n\n    for( Qt4x5::Dom::size_type x = 0; x < nl.length(); ++x )\n    {\n      QDomElement grp = nl.item( x ).toElement();\n\n      c.groups.push_back( loadGroup( grp, &c.groups.nextId ) );\n    }\n  }\n\n  QDomNode hunspell = root.namedItem( \"hunspell\" );\n\n  if ( !hunspell.isNull() )\n  {\n    c.hunspell.dictionariesPath = hunspell.toElement().attribute( \"dictionariesPath\" );\n\n    QDomNodeList nl = hunspell.toElement().elementsByTagName( \"enabled\" );\n\n    for( Qt4x5::Dom::size_type x = 0; x < nl.length(); ++x )\n      c.hunspell.enabledDictionaries.push_back( nl.item( x ).toElement().text() );\n  }\n\n  QDomNode transliteration = root.namedItem( \"transliteration\" );\n\n  if ( !transliteration.isNull() )\n  {\n    applyBoolOption( c.transliteration.enableRussianTransliteration,\n                     transliteration.namedItem( \"enableRussianTransliteration\" ) );\n\n    applyBoolOption( c.transliteration.enableGermanTransliteration,\n                     transliteration.namedItem( \"enableGermanTransliteration\" ) );\n\n    applyBoolOption( c.transliteration.enableGreekTransliteration,\n                     transliteration.namedItem( \"enableGreekTransliteration\" ) );\n\n    applyBoolOption( c.transliteration.enableBelarusianTransliteration,\n                     transliteration.namedItem( \"enableBelarusianTransliteration\" ) );\n\n#ifdef MAKE_CHINESE_CONVERSION_SUPPORT\n    QDomNode chinese = transliteration.namedItem( \"chinese\" );\n\n    if ( !chinese.isNull() )\n    {\n      applyBoolOption( c.transliteration.chinese.enable, chinese.namedItem( \"enable\" ) );\n      applyBoolOption( c.transliteration.chinese.enableSCToTWConversion, chinese.namedItem( \"enableSCToTWConversion\" ) );\n      applyBoolOption( c.transliteration.chinese.enableSCToHKConversion, chinese.namedItem( \"enableSCToHKConversion\" ) );\n      applyBoolOption( c.transliteration.chinese.enableTCToSCConversion, chinese.namedItem( \"enableTCToSCConversion\" ) );\n    }\n#endif\n\n    QDomNode romaji = transliteration.namedItem( \"romaji\" );\n\n    if ( !romaji.isNull() )\n    {\n      applyBoolOption( c.transliteration.romaji.enable, romaji.namedItem( \"enable\" ) );\n      applyBoolOption( c.transliteration.romaji.enableHepburn, romaji.namedItem( \"enableHepburn\" ) );\n      applyBoolOption( c.transliteration.romaji.enableNihonShiki, romaji.namedItem( \"enableNihonShiki\" ) );\n      applyBoolOption( c.transliteration.romaji.enableKunreiShiki, romaji.namedItem( \"enableKunreiShiki\" ) );\n      applyBoolOption( c.transliteration.romaji.enableHiragana, romaji.namedItem( \"enableHiragana\" ) );\n      applyBoolOption( c.transliteration.romaji.enableKatakana, romaji.namedItem( \"enableKatakana\" ) );\n    }\n  }\n\n  QDomNode forvo = root.namedItem( \"forvo\" );\n\n  if ( !forvo.isNull() )\n  {\n    applyBoolOption( c.forvo.enable,\n                     forvo.namedItem( \"enable\" ) );\n\n    c.forvo.apiKey = forvo.namedItem( \"apiKey\" ).toElement().text();\n    c.forvo.languageCodes = forvo.namedItem( \"languageCodes\" ).toElement().text();\n  }\n  else\n    c.forvo.languageCodes = \"en, ru\"; // Default demo values\n\n  QDomNode programs = root.namedItem( \"programs\" );\n\n  if ( !programs.isNull() )\n  {\n    QDomNodeList nl = programs.toElement().elementsByTagName( \"program\" );\n\n    for( Qt4x5::Dom::size_type x = 0; x < nl.length(); ++x )\n    {\n      QDomElement pr = nl.item( x ).toElement();\n\n      Program p;\n\n      p.id = pr.attribute( \"id\" );\n      p.name = pr.attribute( \"name\" );\n      p.commandLine = pr.attribute( \"commandLine\" );\n      p.enabled = ( pr.attribute( \"enabled\" ) == \"1\" );\n      p.type = (Program::Type)( pr.attribute( \"type\" ).toInt() );\n      p.iconFilename = pr.attribute( \"icon\" );\n\n      c.programs.push_back( p );\n    }\n  }\n  else\n  {\n    c.programs = makeDefaultPrograms();\n  }\n\n  QDomNode mws = root.namedItem( \"mediawikis\" );\n\n  if ( !mws.isNull() )\n  {\n    QDomNodeList nl = mws.toElement().elementsByTagName( \"mediawiki\" );\n\n    for( Qt4x5::Dom::size_type x = 0; x < nl.length(); ++x )\n    {\n      QDomElement mw = nl.item( x ).toElement();\n\n      MediaWiki w;\n\n      w.id = mw.attribute( \"id\" );\n      w.name = mw.attribute( \"name\" );\n      w.url = mw.attribute( \"url\" );\n      w.enabled = ( mw.attribute( \"enabled\" ) == \"1\" );\n      w.icon = mw.attribute( \"icon\" );\n\n      c.mediawikis.push_back( w );\n    }\n  }\n  else\n  {\n    // When upgrading, populate the list with some choices, but don't enable\n    // anything.\n    c.mediawikis = makeDefaultMediaWikis( false );\n  }\n\n  QDomNode wss = root.namedItem( \"websites\" );\n\n  if ( !wss.isNull() )\n  {\n    QDomNodeList nl = wss.toElement().elementsByTagName( \"website\" );\n\n    for( Qt4x5::Dom::size_type x = 0; x < nl.length(); ++x )\n    {\n      QDomElement ws = nl.item( x ).toElement();\n\n      WebSite w;\n\n      w.id = ws.attribute( \"id\" );\n      w.name = ws.attribute( \"name\" );\n      w.url = ws.attribute( \"url\" );\n      w.enabled = ( ws.attribute( \"enabled\" ) == \"1\" );\n      w.iconFilename = ws.attribute( \"icon\" );\n      w.inside_iframe = ( ws.attribute( \"inside_iframe\", \"1\" ) == \"1\" );\n\n      c.webSites.push_back( w );\n    }\n  }\n  else\n  {\n    // Upgrading\n    c.webSites = makeDefaultWebSites();\n  }\n\n  QDomNode dss = root.namedItem( \"dictservers\" );\n\n  if ( !dss.isNull() )\n  {\n    QDomNodeList nl = dss.toElement().elementsByTagName( \"server\" );\n\n    for( Qt4x5::Dom::size_type x = 0; x < nl.length(); ++x )\n    {\n      QDomElement ds = nl.item( x ).toElement();\n\n      DictServer d;\n\n      d.id = ds.attribute( \"id\" );\n      d.name = ds.attribute( \"name\" );\n      d.url = ds.attribute( \"url\" );\n      d.enabled = ( ds.attribute( \"enabled\" ) == \"1\" );\n      d.databases = ds.attribute( \"databases\" );\n      d.strategies = ds.attribute( \"strategies\" );\n      d.iconFilename = ds.attribute( \"icon\" );\n\n      c.dictServers.push_back( d );\n    }\n  }\n  else\n  {\n    // Upgrading\n    c.dictServers = makeDefaultDictServers();\n  }\n\n  QDomNode ves = root.namedItem( \"voiceEngines\" );\n\n  if ( !ves.isNull() )\n  {\n    QDomNodeList nl = ves.toElement().elementsByTagName( \"voiceEngine\" );\n\n    for ( Qt4x5::Dom::size_type x = 0; x < nl.length(); ++x )\n    {\n      QDomElement ve = nl.item( x ).toElement();\n      VoiceEngine v;\n\n      v.enabled = ve.attribute( \"enabled\" ) == \"1\";\n      v.id = ve.attribute( \"id\" );\n      v.name = ve.attribute( \"name\" );\n      v.iconFilename = ve.attribute( \"icon\" );\n      v.volume = ve.attribute( \"volume\", \"50\" ).toInt();\n      if( v.volume < 0 || v.volume > 100 )\n        v.volume = 50;\n      v.rate = ve.attribute( \"rate\", \"50\" ).toInt();\n      if( v.rate < 0 || v.rate > 100 )\n        v.rate = 50;\n      c.voiceEngines.push_back( v );\n    }\n  }\n\n  c.mutedDictionaries = loadMutedDictionaries( root.namedItem( \"mutedDictionaries\" ) );\n  c.popupMutedDictionaries = loadMutedDictionaries( root.namedItem( \"popupMutedDictionaries\" ) );\n\n  QDomNode preferences = root.namedItem( \"preferences\" );\n\n  if ( !preferences.isNull() )\n  {\n    c.preferences.interfaceLanguage = preferences.namedItem( \"interfaceLanguage\" ).toElement().text();\n    c.preferences.helpLanguage = preferences.namedItem( \"helpLanguage\" ).toElement().text();\n    c.preferences.displayStyle = preferences.namedItem( \"displayStyle\" ).toElement().text();\n    c.preferences.newTabsOpenAfterCurrentOne = ( preferences.namedItem( \"newTabsOpenAfterCurrentOne\" ).toElement().text() == \"1\" );\n    c.preferences.newTabsOpenInBackground = ( preferences.namedItem( \"newTabsOpenInBackground\" ).toElement().text() == \"1\" );\n    c.preferences.hideSingleTab = ( preferences.namedItem( \"hideSingleTab\" ).toElement().text() == \"1\" );\n    c.preferences.mruTabOrder = ( preferences.namedItem( \"mruTabOrder\" ).toElement().text() == \"1\" );\n    c.preferences.hideMenubar = ( preferences.namedItem( \"hideMenubar\" ).toElement().text() == \"1\" );\n    c.preferences.enableTrayIcon = ( preferences.namedItem( \"enableTrayIcon\" ).toElement().text() == \"1\" );\n    c.preferences.startToTray = ( preferences.namedItem( \"startToTray\" ).toElement().text() == \"1\" );\n    c.preferences.closeToTray = ( preferences.namedItem( \"closeToTray\" ).toElement().text() == \"1\" );\n    c.preferences.autoStart = ( preferences.namedItem( \"autoStart\" ).toElement().text() == \"1\" );\n    c.preferences.alwaysOnTop = ( preferences.namedItem( \"alwaysOnTop\" ).toElement().text() == \"1\" );\n    c.preferences.searchInDock = ( preferences.namedItem( \"searchInDock\" ).toElement().text() == \"1\" );\n\n    if ( !preferences.namedItem( \"doubleClickTranslates\" ).isNull() )\n      c.preferences.doubleClickTranslates = ( preferences.namedItem( \"doubleClickTranslates\" ).toElement().text() == \"1\" );\n\n    if ( !preferences.namedItem( \"selectWordBySingleClick\" ).isNull() )\n      c.preferences.selectWordBySingleClick = ( preferences.namedItem( \"selectWordBySingleClick\" ).toElement().text() == \"1\" );\n\n    if ( !preferences.namedItem( \"escKeyHidesMainWindow\" ).isNull() )\n      c.preferences.escKeyHidesMainWindow = ( preferences.namedItem( \"escKeyHidesMainWindow\" ).toElement().text() == \"1\" );\n\n    if ( !preferences.namedItem( \"zoomFactor\" ).isNull() )\n      c.preferences.zoomFactor = preferences.namedItem( \"zoomFactor\" ).toElement().text().toDouble();\n\n    if ( !preferences.namedItem( \"helpZoomFactor\" ).isNull() )\n      c.preferences.helpZoomFactor = preferences.namedItem( \"helpZoomFactor\" ).toElement().text().toDouble();\n\n    if ( !preferences.namedItem( \"wordsZoomLevel\" ).isNull() )\n      c.preferences.wordsZoomLevel = preferences.namedItem( \"wordsZoomLevel\" ).toElement().text().toInt();\n\n    applyBoolOption( c.preferences.enableMainWindowHotkey, preferences.namedItem( \"enableMainWindowHotkey\" ) );\n    if ( !preferences.namedItem( \"mainWindowHotkey\" ).isNull() )\n      c.preferences.mainWindowHotkey = QKeySequence::fromString( preferences.namedItem( \"mainWindowHotkey\" ).toElement().text() );\n    applyBoolOption( c.preferences.enableClipboardHotkey, preferences.namedItem( \"enableClipboardHotkey\" ) );\n    if ( !preferences.namedItem( \"clipboardHotkey\" ).isNull() )\n      c.preferences.clipboardHotkey = QKeySequence::fromString( preferences.namedItem( \"clipboardHotkey\" ).toElement().text() );\n\n    c.preferences.enableScanPopup = ( preferences.namedItem( \"enableScanPopup\" ).toElement().text() == \"1\" );\n    c.preferences.startWithScanPopupOn = ( preferences.namedItem( \"startWithScanPopupOn\" ).toElement().text() == \"1\" );\n    c.preferences.enableScanPopupModifiers = ( preferences.namedItem( \"enableScanPopupModifiers\" ).toElement().text() == \"1\" );\n    c.preferences.scanPopupModifiers = ( preferences.namedItem( \"scanPopupModifiers\" ).toElement().text().toULong() );\n    c.preferences.scanPopupAltMode = ( preferences.namedItem( \"scanPopupAltMode\" ).toElement().text() == \"1\" );\n    if ( !preferences.namedItem( \"scanPopupAltModeSecs\" ).isNull() )\n      c.preferences.scanPopupAltModeSecs = preferences.namedItem( \"scanPopupAltModeSecs\" ).toElement().text().toUInt();\n    c.preferences.ignoreOwnClipboardChanges = ( preferences.namedItem( \"ignoreOwnClipboardChanges\" ).toElement().text() == \"1\" );\n    c.preferences.scanToMainWindow = ( preferences.namedItem( \"scanToMainWindow\" ).toElement().text() == \"1\" );\n    c.preferences.ignoreDiacritics = ( preferences.namedItem( \"ignoreDiacritics\" ).toElement().text() == \"1\" );\n#ifdef HAVE_X11\n    c.preferences.showScanFlag= ( preferences.namedItem( \"showScanFlag\" ).toElement().text() == \"1\" );\n#endif\n    c.preferences.scanPopupUseUIAutomation = ( preferences.namedItem( \"scanPopupUseUIAutomation\" ).toElement().text() == \"1\" );\n    c.preferences.scanPopupUseIAccessibleEx = ( preferences.namedItem( \"scanPopupUseIAccessibleEx\" ).toElement().text() == \"1\" );\n    c.preferences.scanPopupUseGDMessage = ( preferences.namedItem( \"scanPopupUseGDMessage\" ).toElement().text() == \"1\" );\n    c.preferences.scanPopupUnpinnedWindowFlags = spwfFromInt( preferences.namedItem( \"scanPopupUnpinnedWindowFlags\" ).toElement().text().toInt() );\n    c.preferences.scanPopupUnpinnedBypassWMHint = ( preferences.namedItem( \"scanPopupUnpinnedBypassWMHint\" ).toElement().text() == \"1\" );\n\n    c.preferences.pronounceOnLoadMain = ( preferences.namedItem( \"pronounceOnLoadMain\" ).toElement().text() == \"1\" );\n    c.preferences.pronounceOnLoadPopup = ( preferences.namedItem( \"pronounceOnLoadPopup\" ).toElement().text() == \"1\" );\n\n    if ( InternalPlayerBackend::anyAvailable() )\n    {\n      if ( !preferences.namedItem( \"useInternalPlayer\" ).isNull() )\n        c.preferences.useInternalPlayer = ( preferences.namedItem( \"useInternalPlayer\" ).toElement().text() == \"1\" );\n    }\n    else\n      c.preferences.useInternalPlayer = false;\n\n    if ( !preferences.namedItem( \"internalPlayerBackend\" ).isNull() )\n      c.preferences.internalPlayerBackend.setUiName( preferences.namedItem( \"internalPlayerBackend\" ).toElement().text() );\n\n    if ( !preferences.namedItem( \"audioPlaybackProgram\" ).isNull() )\n      c.preferences.audioPlaybackProgram = preferences.namedItem( \"audioPlaybackProgram\" ).toElement().text();\n    else\n      c.preferences.audioPlaybackProgram = \"mplayer\";\n\n    QDomNode proxy = preferences.namedItem( \"proxyserver\" );\n\n    if ( !proxy.isNull() )\n    {\n      c.preferences.proxyServer.enabled = ( proxy.toElement().attribute( \"enabled\" ) == \"1\" );\n      c.preferences.proxyServer.useSystemProxy = ( proxy.toElement().attribute( \"useSystemProxy\" ) == \"1\" );\n      c.preferences.proxyServer.type = ( ProxyServer::Type ) proxy.namedItem( \"type\" ).toElement().text().toULong();\n      c.preferences.proxyServer.host = proxy.namedItem( \"host\" ).toElement().text();\n      c.preferences.proxyServer.port = proxy.namedItem( \"port\" ).toElement().text().toULong();\n      c.preferences.proxyServer.user = proxy.namedItem( \"user\" ).toElement().text();\n      c.preferences.proxyServer.password = proxy.namedItem( \"password\" ).toElement().text();\n      c.preferences.proxyServer.systemProxyUser = proxy.namedItem( \"systemProxyUser\" ).toElement().text();\n      c.preferences.proxyServer.systemProxyPassword = proxy.namedItem( \"systemProxyPassword\" ).toElement().text();\n    }\n\n    if ( !preferences.namedItem( \"checkForNewReleases\" ).isNull() )\n      c.preferences.checkForNewReleases = ( preferences.namedItem( \"checkForNewReleases\" ).toElement().text() == \"1\" );\n\n    if ( !preferences.namedItem( \"disallowContentFromOtherSites\" ).isNull() )\n      c.preferences.disallowContentFromOtherSites = ( preferences.namedItem( \"disallowContentFromOtherSites\" ).toElement().text() == \"1\" );\n\n    if ( !preferences.namedItem( \"enableWebPlugins\" ).isNull() )\n      c.preferences.enableWebPlugins = ( preferences.namedItem( \"enableWebPlugins\" ).toElement().text() == \"1\" );\n\n    if ( !preferences.namedItem( \"hideGoldenDictHeader\" ).isNull() )\n      c.preferences.hideGoldenDictHeader = ( preferences.namedItem( \"hideGoldenDictHeader\" ).toElement().text() == \"1\" );\n\n    if ( !preferences.namedItem( \"maxNetworkCacheSize\" ).isNull() )\n      c.preferences.maxNetworkCacheSize = preferences.namedItem( \"maxNetworkCacheSize\" ).toElement().text().toInt();\n\n    if ( !preferences.namedItem( \"clearNetworkCacheOnExit\" ).isNull() )\n      c.preferences.clearNetworkCacheOnExit = ( preferences.namedItem( \"clearNetworkCacheOnExit\" ).toElement().text() == \"1\" );\n\n    if ( !preferences.namedItem( \"maxStringsInHistory\" ).isNull() )\n      c.preferences.maxStringsInHistory = preferences.namedItem( \"maxStringsInHistory\" ).toElement().text().toUInt() ;\n\n    if ( !preferences.namedItem( \"storeHistory\" ).isNull() )\n      c.preferences.storeHistory = preferences.namedItem( \"storeHistory\" ).toElement().text().toUInt() ;\n\n    if ( !preferences.namedItem( \"alwaysExpandOptionalParts\" ).isNull() )\n      c.preferences.alwaysExpandOptionalParts = preferences.namedItem( \"alwaysExpandOptionalParts\" ).toElement().text().toUInt() ;\n\n    if ( !preferences.namedItem( \"addonStyle\" ).isNull() )\n      c.preferences.addonStyle = preferences.namedItem( \"addonStyle\" ).toElement().text();\n\n    if ( !preferences.namedItem( \"historyStoreInterval\" ).isNull() )\n      c.preferences.historyStoreInterval = preferences.namedItem( \"historyStoreInterval\" ).toElement().text().toUInt() ;\n\n    if ( !preferences.namedItem( \"favoritesStoreInterval\" ).isNull() )\n      c.preferences.favoritesStoreInterval = preferences.namedItem( \"favoritesStoreInterval\" ).toElement().text().toUInt() ;\n\n    if ( !preferences.namedItem( \"confirmFavoritesDeletion\" ).isNull() )\n      c.preferences.confirmFavoritesDeletion = ( preferences.namedItem( \"confirmFavoritesDeletion\" ).toElement().text() == \"1\" );\n\n    if ( !preferences.namedItem( \"collapseBigArticles\" ).isNull() )\n      c.preferences.collapseBigArticles = ( preferences.namedItem( \"collapseBigArticles\" ).toElement().text() == \"1\" );\n\n    if ( !preferences.namedItem( \"articleSizeLimit\" ).isNull() )\n      c.preferences.articleSizeLimit = preferences.namedItem( \"articleSizeLimit\" ).toElement().text().toInt();\n\n    if ( !preferences.namedItem( \"limitInputPhraseLength\" ).isNull() )\n      c.preferences.limitInputPhraseLength = ( preferences.namedItem( \"limitInputPhraseLength\" ).toElement().text() == \"1\" );\n\n    if ( !preferences.namedItem( \"inputPhraseLengthLimit\" ).isNull() )\n      c.preferences.inputPhraseLengthLimit = preferences.namedItem( \"inputPhraseLengthLimit\" ).toElement().text().toInt();\n\n    if ( !preferences.namedItem( \"maxDictionaryRefsInContextMenu\" ).isNull() )\n      c.preferences.maxDictionaryRefsInContextMenu = preferences.namedItem( \"maxDictionaryRefsInContextMenu\" ).toElement().text().toUShort();\n\n#ifndef Q_WS_X11\n    if ( !preferences.namedItem( \"trackClipboardChanges\" ).isNull() )\n      c.preferences.trackClipboardChanges = ( preferences.namedItem( \"trackClipboardChanges\" ).toElement().text() == \"1\" );\n#endif\n\n    if ( !preferences.namedItem( \"synonymSearchEnabled\" ).isNull() )\n      c.preferences.synonymSearchEnabled = ( preferences.namedItem( \"synonymSearchEnabled\" ).toElement().text() == \"1\" );\n\n    QDomNode fts = preferences.namedItem( \"fullTextSearch\" );\n\n    if ( !fts.isNull() )\n    {\n      if ( !fts.namedItem( \"searchMode\" ).isNull() )\n        c.preferences.fts.searchMode = fts.namedItem( \"searchMode\" ).toElement().text().toInt();\n\n      if ( !fts.namedItem( \"matchCase\" ).isNull() )\n        c.preferences.fts.matchCase = ( fts.namedItem( \"matchCase\" ).toElement().text() == \"1\" );\n\n      if ( !fts.namedItem( \"maxArticlesPerDictionary\" ).isNull() )\n        c.preferences.fts.maxArticlesPerDictionary = fts.namedItem( \"maxArticlesPerDictionary\" ).toElement().text().toInt();\n\n      if ( !fts.namedItem( \"maxDistanceBetweenWords\" ).isNull() )\n        c.preferences.fts.maxDistanceBetweenWords = fts.namedItem( \"maxDistanceBetweenWords\" ).toElement().text().toInt();\n\n      if ( !fts.namedItem( \"useMaxArticlesPerDictionary\" ).isNull() )\n        c.preferences.fts.useMaxArticlesPerDictionary = ( fts.namedItem( \"useMaxArticlesPerDictionary\" ).toElement().text() == \"1\" );\n\n      if ( !fts.namedItem( \"useMaxDistanceBetweenWords\" ).isNull() )\n        c.preferences.fts.useMaxDistanceBetweenWords = ( fts.namedItem( \"useMaxDistanceBetweenWords\" ).toElement().text() == \"1\" );\n\n      if ( !fts.namedItem( \"dialogGeometry\" ).isNull() )\n        c.preferences.fts.dialogGeometry = QByteArray::fromBase64( fts.namedItem( \"dialogGeometry\" ).toElement().text().toLatin1() );\n\n      if( !fts.namedItem( \"disabledTypes\" ).isNull() )\n      c.preferences.fts.disabledTypes = fts.namedItem( \"disabledTypes\" ).toElement().text();\n\n      if ( !fts.namedItem( \"enabled\" ).isNull() )\n        c.preferences.fts.enabled = ( fts.namedItem( \"enabled\" ).toElement().text() == \"1\" );\n\n      if ( !fts.namedItem( \"ignoreWordsOrder\" ).isNull() )\n        c.preferences.fts.ignoreWordsOrder = ( fts.namedItem( \"ignoreWordsOrder\" ).toElement().text() == \"1\" );\n\n      if ( !fts.namedItem( \"ignoreDiacritics\" ).isNull() )\n        c.preferences.fts.ignoreDiacritics = ( fts.namedItem( \"ignoreDiacritics\" ).toElement().text() == \"1\" );\n\n      if ( !fts.namedItem( \"maxDictionarySize\" ).isNull() )\n        c.preferences.fts.maxDictionarySize = fts.namedItem( \"maxDictionarySize\" ).toElement().text().toUInt();\n    }\n\n  }\n\n  c.lastMainGroupId = root.namedItem( \"lastMainGroupId\" ).toElement().text().toUInt();\n  c.lastPopupGroupId = root.namedItem( \"lastPopupGroupId\" ).toElement().text().toUInt();\n\n  QDomNode popupWindowState = root.namedItem( \"popupWindowState\" );\n\n  if ( !popupWindowState.isNull() )\n    c.popupWindowState = QByteArray::fromBase64( popupWindowState.toElement().text().toLatin1() );\n\n  QDomNode popupWindowGeometry = root.namedItem( \"popupWindowGeometry\" );\n\n  if ( !popupWindowGeometry.isNull() )\n    c.popupWindowGeometry = QByteArray::fromBase64( popupWindowGeometry.toElement().text().toLatin1() );\n\n  c.pinPopupWindow = ( root.namedItem( \"pinPopupWindow\" ).toElement().text() == \"1\" );\n\n  c.popupWindowAlwaysOnTop = ( root.namedItem( \"popupWindowAlwaysOnTop\" ).toElement().text() == \"1\" );\n\n  QDomNode mainWindowState = root.namedItem( \"mainWindowState\" );\n\n  if ( !mainWindowState.isNull() )\n    c.mainWindowState = QByteArray::fromBase64( mainWindowState.toElement().text().toLatin1() );\n\n  QDomNode mainWindowGeometry = root.namedItem( \"mainWindowGeometry\" );\n\n  if ( !mainWindowGeometry.isNull() )\n    c.mainWindowGeometry = QByteArray::fromBase64( mainWindowGeometry.toElement().text().toLatin1() );\n\n  QDomNode helpWindowGeometry = root.namedItem( \"helpWindowGeometry\" );\n\n  if ( !helpWindowGeometry.isNull() )\n    c.helpWindowGeometry = QByteArray::fromBase64( helpWindowGeometry.toElement().text().toLatin1() );\n\n  QDomNode helpSplitterState = root.namedItem( \"helpSplitterState\" );\n\n  if ( !helpSplitterState.isNull() )\n    c.helpSplitterState = QByteArray::fromBase64( helpSplitterState.toElement().text().toLatin1() );\n\n#ifdef Q_OS_WIN\n  QDomNode maximizedMainWindowGeometry = root.namedItem( \"maximizedMainWindowGeometry\" );\n\n  if ( !maximizedMainWindowGeometry.isNull() )\n  {\n    int x = 0, y = 0, width = 0, height = 0;\n    if( !maximizedMainWindowGeometry.namedItem( \"x\" ).isNull() )\n      x = maximizedMainWindowGeometry.namedItem( \"x\" ).toElement().text().toInt();\n    if( !maximizedMainWindowGeometry.namedItem( \"y\" ).isNull() )\n      y = maximizedMainWindowGeometry.namedItem( \"y\" ).toElement().text().toInt();\n    if( !maximizedMainWindowGeometry.namedItem( \"width\" ).isNull() )\n      width = maximizedMainWindowGeometry.namedItem( \"width\" ).toElement().text().toInt();\n    if( !maximizedMainWindowGeometry.namedItem( \"height\" ).isNull() )\n      height = maximizedMainWindowGeometry.namedItem( \"height\" ).toElement().text().toInt();\n    c.maximizedMainWindowGeometry = QRect( x, y, width, height );\n  }\n\n  QDomNode normalMainWindowGeometry = root.namedItem( \"normalMainWindowGeometry\" );\n\n  if ( !normalMainWindowGeometry.isNull() )\n  {\n    int x = 0, y = 0, width = 0, height = 0;\n    if( !normalMainWindowGeometry.namedItem( \"x\" ).isNull() )\n      x = normalMainWindowGeometry.namedItem( \"x\" ).toElement().text().toInt();\n    if( !normalMainWindowGeometry.namedItem( \"y\" ).isNull() )\n      y = normalMainWindowGeometry.namedItem( \"y\" ).toElement().text().toInt();\n    if( !normalMainWindowGeometry.namedItem( \"width\" ).isNull() )\n      width = normalMainWindowGeometry.namedItem( \"width\" ).toElement().text().toInt();\n    if( !normalMainWindowGeometry.namedItem( \"height\" ).isNull() )\n      height = normalMainWindowGeometry.namedItem( \"height\" ).toElement().text().toInt();\n    c.normalMainWindowGeometry = QRect( x, y, width, height );\n  }\n#endif\n\n  QDomNode dictInfoGeometry = root.namedItem( \"dictInfoGeometry\" );\n\n  if ( !dictInfoGeometry.isNull() )\n    c.dictInfoGeometry = QByteArray::fromBase64( dictInfoGeometry.toElement().text().toLatin1() );\n\n  QDomNode inspectorGeometry = root.namedItem( \"inspectorGeometry\" );\n\n  if ( !inspectorGeometry.isNull() )\n    c.inspectorGeometry = QByteArray::fromBase64( inspectorGeometry.toElement().text().toLatin1() );\n\n  QDomNode dictionariesDialogGeometry = root.namedItem( \"dictionariesDialogGeometry\" );\n\n  if ( !dictionariesDialogGeometry.isNull() )\n    c.dictionariesDialogGeometry = QByteArray::fromBase64( dictionariesDialogGeometry.toElement().text().toLatin1() );\n\n  QDomNode const printPreviewDialogGeometry = root.namedItem( \"printPreviewDialogGeometry\" );\n  if( !printPreviewDialogGeometry.isNull() )\n    c.printPreviewDialogGeometry = QByteArray::fromBase64( printPreviewDialogGeometry.toElement().text().toLatin1() );\n\n  QDomNode timeForNewReleaseCheck = root.namedItem( \"timeForNewReleaseCheck\" );\n\n  if ( !timeForNewReleaseCheck.isNull() )\n    c.timeForNewReleaseCheck = QDateTime::fromString( timeForNewReleaseCheck.toElement().text(),\n                                                      Qt::ISODate );\n\n  c.skippedRelease = root.namedItem( \"skippedRelease\" ).toElement().text();\n\n  c.showingDictBarNames = ( root.namedItem( \"showingDictBarNames\" ).toElement().text() == \"1\" );\n\n  c.usingSmallIconsInToolbars = ( root.namedItem( \"usingSmallIconsInToolbars\" ).toElement().text() == \"1\" );\n\n  if ( !root.namedItem( \"historyExportPath\" ).isNull() )\n    c.historyExportPath = root.namedItem( \"historyExportPath\" ).toElement().text();\n\n  if ( !root.namedItem( \"resourceSavePath\" ).isNull() )\n    c.resourceSavePath = root.namedItem( \"resourceSavePath\" ).toElement().text();\n\n  if ( !root.namedItem( \"articleSavePath\" ).isNull() )\n    c.articleSavePath = root.namedItem( \"articleSavePath\" ).toElement().text();\n\n  if ( !root.namedItem( \"editDictionaryCommandLine\" ).isNull() )\n    c.editDictionaryCommandLine = root.namedItem( \"editDictionaryCommandLine\" ).toElement().text();\n\n  if ( !root.namedItem( \"maxPictureWidth\" ).isNull() )\n    c.maxPictureWidth = root.namedItem( \"maxPictureWidth\" ).toElement().text().toInt();\n\n  if ( !root.namedItem( \"maxHeadwordSize\" ).isNull() )\n  {\n    unsigned int value = root.namedItem( \"maxHeadwordSize\" ).toElement().text().toUInt();\n    if ( value != 0 ) // 0 is invalid value for our purposes\n    {\n      c.maxHeadwordSize = value;\n    }\n  }\n\n  if ( !root.namedItem( \"maxHeadwordsToExpand\" ).isNull() )\n    c.maxHeadwordsToExpand = root.namedItem( \"maxHeadwordsToExpand\" ).toElement().text().toUInt();\n\n  QDomNode headwordsDialog = root.namedItem( \"headwordsDialog\" );\n\n  if ( !headwordsDialog.isNull() )\n  {\n    if ( !headwordsDialog.namedItem( \"searchMode\" ).isNull() )\n      c.headwordsDialog.searchMode = headwordsDialog.namedItem( \"searchMode\" ).toElement().text().toInt();\n\n    if ( !headwordsDialog.namedItem( \"matchCase\" ).isNull() )\n      c.headwordsDialog.matchCase = ( headwordsDialog.namedItem( \"matchCase\" ).toElement().text() == \"1\" );\n\n    if ( !headwordsDialog.namedItem( \"autoApply\" ).isNull() )\n      c.headwordsDialog.autoApply = ( headwordsDialog.namedItem( \"autoApply\" ).toElement().text() == \"1\" );\n\n    if ( !headwordsDialog.namedItem( \"headwordsExportPath\" ).isNull() )\n      c.headwordsDialog.headwordsExportPath = headwordsDialog.namedItem( \"headwordsExportPath\" ).toElement().text();\n\n    if ( !headwordsDialog.namedItem( \"headwordsDialogGeometry\" ).isNull() )\n      c.headwordsDialog.headwordsDialogGeometry = QByteArray::fromBase64( headwordsDialog.namedItem( \"headwordsDialogGeometry\" ).toElement().text().toLatin1() );\n  }\n\n  return c;\n}\n\nnamespace {\nvoid saveGroup( Group const & data, QDomElement & group )\n{\n  QDomDocument dd = group.ownerDocument();\n\n  QDomAttr id = dd.createAttribute( \"id\" );\n\n  id.setValue( QString::number( data.id ) );\n\n  group.setAttributeNode( id );\n\n  QDomAttr name = dd.createAttribute( \"name\" );\n\n  name.setValue( data.name );\n\n  group.setAttributeNode( name );\n\n  if( data.favoritesFolder.size() )\n  {\n    QDomAttr folder = dd.createAttribute( \"favoritesFolder\" );\n    folder.setValue( data.favoritesFolder );\n    group.setAttributeNode( folder );\n  }\n\n  if ( data.icon.size() )\n  {\n    QDomAttr icon = dd.createAttribute( \"icon\" );\n\n    icon.setValue( data.icon );\n\n    group.setAttributeNode( icon );\n  }\n\n  if ( data.iconData.size() )\n  {\n    QDomAttr iconData = dd.createAttribute( \"iconData\" );\n\n    iconData.setValue( QString::fromLatin1( data.iconData.toBase64() ) );\n\n    group.setAttributeNode( iconData );\n  }\n\n  if ( !data.shortcut.isEmpty() )\n  {\n    QDomAttr shortcut = dd.createAttribute( \"shortcut\" );\n\n    shortcut.setValue(  data.shortcut.toString() );\n\n    group.setAttributeNode( shortcut );\n  }\n\n  for( QVector< DictionaryRef >::const_iterator j = data.dictionaries.begin(); j != data.dictionaries.end(); ++j )\n  {\n    QDomElement dictionary = dd.createElement( \"dictionary\" );\n\n    group.appendChild( dictionary );\n\n    QDomText value = dd.createTextNode( j->id );\n\n    dictionary.appendChild( value );\n\n    QDomAttr name = dd.createAttribute( \"name\" );\n\n    name.setValue( j->name );\n\n    dictionary.setAttributeNode( name );\n  }\n\n  QDomElement muted = dd.createElement( \"mutedDictionaries\" );\n  group.appendChild( muted );\n\n  for( MutedDictionaries::const_iterator i = data.mutedDictionaries.begin();\n       i != data.mutedDictionaries.end(); ++i )\n  {\n    QDomElement dict = dd.createElement( \"mutedDictionary\" );\n    muted.appendChild( dict );\n\n    QDomText value = dd.createTextNode( *i );\n    dict.appendChild( value );\n  }\n\n  for( MutedDictionaries::const_iterator i = data.popupMutedDictionaries.begin();\n       i != data.popupMutedDictionaries.end(); ++i )\n  {\n    QDomElement dict = dd.createElement( \"popupMutedDictionary\" );\n    muted.appendChild( dict );\n\n    QDomText value = dd.createTextNode( *i );\n    dict.appendChild( value );\n  }\n}\n\n}\n\nvoid save( Class const & c ) THROW_SPEC( exError )\n{\n  QFile configFile( getConfigFileName() + \".tmp\" );\n\n  if ( !configFile.open( QFile::WriteOnly ) )\n    throw exCantWriteConfigFile();\n\n  QDomDocument dd;\n\n  QDomElement root = dd.createElement( \"config\" );\n  dd.appendChild( root );\n\n  {\n    QDomElement paths = dd.createElement( \"paths\" );\n    root.appendChild( paths );\n\n    for( Paths::const_iterator i = c.paths.begin(); i != c.paths.end(); ++i )\n    {\n      QDomElement path = dd.createElement( \"path\" );\n      paths.appendChild( path );\n\n      QDomAttr recursive = dd.createAttribute( \"recursive\" );\n      recursive.setValue( i->recursive ? \"1\" : \"0\" );\n      path.setAttributeNode( recursive );\n\n      QDomText value = dd.createTextNode( i->path );\n\n      path.appendChild( value );\n    }\n  }\n\n  {\n    QDomElement soundDirs = dd.createElement( \"sounddirs\" );\n    root.appendChild( soundDirs );\n\n    for( SoundDirs::const_iterator i = c.soundDirs.begin(); i != c.soundDirs.end(); ++i )\n    {\n      QDomElement soundDir = dd.createElement( \"sounddir\" );\n      soundDirs.appendChild( soundDir );\n\n      QDomAttr name = dd.createAttribute( \"name\" );\n      name.setValue( i->name );\n      soundDir.setAttributeNode( name );\n\n      QDomAttr icon = dd.createAttribute( \"icon\" );\n      icon.setValue( i->iconFilename );\n      soundDir.setAttributeNode( icon );\n\n      QDomText value = dd.createTextNode( i->path );\n\n      soundDir.appendChild( value );\n    }\n  }\n\n  {\n    QDomElement dictionaryOrder = dd.createElement( \"dictionaryOrder\" );\n    root.appendChild( dictionaryOrder );\n    saveGroup( c.dictionaryOrder, dictionaryOrder );\n  }\n\n  {\n    QDomElement inactiveDictionaries = dd.createElement( \"inactiveDictionaries\" );\n    root.appendChild( inactiveDictionaries );\n    saveGroup( c.inactiveDictionaries, inactiveDictionaries );\n  }\n\n  {\n    QDomElement groups = dd.createElement( \"groups\" );\n    root.appendChild( groups );\n\n    QDomAttr nextId = dd.createAttribute( \"nextId\" );\n    nextId.setValue( QString::number( c.groups.nextId ) );\n    groups.setAttributeNode( nextId );\n\n    for( Groups::const_iterator i = c.groups.begin(); i != c.groups.end(); ++i )\n    {\n      QDomElement group = dd.createElement( \"group\" );\n      groups.appendChild( group );\n\n      saveGroup( *i, group );\n    }\n  }\n\n  {\n    QDomElement hunspell = dd.createElement( \"hunspell\" );\n    QDomAttr path = dd.createAttribute( \"dictionariesPath\" );\n    path.setValue( c.hunspell.dictionariesPath );\n    hunspell.setAttributeNode( path );\n    root.appendChild( hunspell );\n\n    for( int x = 0; x < c.hunspell.enabledDictionaries.size(); ++x )\n    {\n      QDomElement en = dd.createElement( \"enabled\" );\n      QDomText value = dd.createTextNode( c.hunspell.enabledDictionaries.at( x ) );\n\n      en.appendChild( value );\n      hunspell.appendChild( en );\n    }\n  }\n\n  {\n    // Russian translit\n\n    QDomElement transliteration = dd.createElement( \"transliteration\" );\n    root.appendChild( transliteration );\n\n    QDomElement opt = dd.createElement( \"enableRussianTransliteration\" );\n    opt.appendChild( dd.createTextNode( c.transliteration.enableRussianTransliteration ? \"1\":\"0\" ) );\n    transliteration.appendChild( opt );\n\n    // German translit\n\n    opt = dd.createElement( \"enableGermanTransliteration\" );\n    opt.appendChild( dd.createTextNode( c.transliteration.enableGermanTransliteration ? \"1\":\"0\" ) );\n    transliteration.appendChild( opt );\n\n    // Greek translit\n\n    opt = dd.createElement( \"enableGreekTransliteration\" );\n    opt.appendChild( dd.createTextNode( c.transliteration.enableGreekTransliteration ? \"1\":\"0\" ) );\n    transliteration.appendChild( opt );\n\n    // Belarusian translit\n\n    opt = dd.createElement( \"enableBelarusianTransliteration\" );\n    opt.appendChild( dd.createTextNode( c.transliteration.enableBelarusianTransliteration ? \"1\":\"0\" ) );\n    transliteration.appendChild( opt );\n\n#ifdef MAKE_CHINESE_CONVERSION_SUPPORT\n    // Chinese\n\n    QDomElement chinese = dd.createElement( \"chinese\" );\n    transliteration.appendChild( chinese );\n\n    opt = dd.createElement( \"enable\" );\n    opt.appendChild( dd.createTextNode( c.transliteration.chinese.enable ? \"1\":\"0\" ) );\n    chinese.appendChild( opt );\n\n    opt = dd.createElement( \"enableSCToTWConversion\" );\n    opt.appendChild( dd.createTextNode( c.transliteration.chinese.enableSCToTWConversion ? \"1\":\"0\" ) );\n    chinese.appendChild( opt );\n\n    opt = dd.createElement( \"enableSCToHKConversion\" );\n    opt.appendChild( dd.createTextNode( c.transliteration.chinese.enableSCToHKConversion ? \"1\":\"0\" ) );\n    chinese.appendChild( opt );\n\n    opt = dd.createElement( \"enableTCToSCConversion\" );\n    opt.appendChild( dd.createTextNode( c.transliteration.chinese.enableTCToSCConversion ? \"1\":\"0\" ) );\n    chinese.appendChild( opt );\n#endif\n\n    // Romaji\n\n    QDomElement romaji = dd.createElement( \"romaji\" );\n    transliteration.appendChild( romaji );\n\n    opt = dd.createElement( \"enable\" );\n    opt.appendChild( dd.createTextNode( c.transliteration.romaji.enable ? \"1\":\"0\" ) );\n    romaji.appendChild( opt );\n\n    opt = dd.createElement( \"enableHepburn\" );\n    opt.appendChild( dd.createTextNode( c.transliteration.romaji.enableHepburn ? \"1\":\"0\" ) );\n    romaji.appendChild( opt );\n\n    opt = dd.createElement( \"enableNihonShiki\" );\n    opt.appendChild( dd.createTextNode( c.transliteration.romaji.enableNihonShiki ? \"1\":\"0\" ) );\n    romaji.appendChild( opt );\n\n    opt = dd.createElement( \"enableKunreiShiki\" );\n    opt.appendChild( dd.createTextNode( c.transliteration.romaji.enableKunreiShiki ? \"1\":\"0\" ) );\n    romaji.appendChild( opt );\n\n    opt = dd.createElement( \"enableHiragana\" );\n    opt.appendChild( dd.createTextNode( c.transliteration.romaji.enableHiragana ? \"1\":\"0\" ) );\n    romaji.appendChild( opt );\n\n    opt = dd.createElement( \"enableKatakana\" );\n    opt.appendChild( dd.createTextNode( c.transliteration.romaji.enableKatakana ? \"1\":\"0\" ) );\n    romaji.appendChild( opt );\n  }\n\n  {\n    // Forvo\n\n    QDomElement forvo = dd.createElement( \"forvo\" );\n    root.appendChild( forvo );\n\n    QDomElement opt = dd.createElement( \"enable\" );\n    opt.appendChild( dd.createTextNode( c.forvo.enable ? \"1\":\"0\" ) );\n    forvo.appendChild( opt );\n\n    opt = dd.createElement( \"apiKey\" );\n    opt.appendChild( dd.createTextNode( c.forvo.apiKey ) );\n    forvo.appendChild( opt );\n\n    opt = dd.createElement( \"languageCodes\" );\n    opt.appendChild( dd.createTextNode( c.forvo.languageCodes ) );\n    forvo.appendChild( opt );\n  }\n\n  {\n    QDomElement mws = dd.createElement( \"mediawikis\" );\n    root.appendChild( mws );\n\n    for( MediaWikis::const_iterator i = c.mediawikis.begin(); i != c.mediawikis.end(); ++i )\n    {\n      QDomElement mw = dd.createElement( \"mediawiki\" );\n      mws.appendChild( mw );\n\n      QDomAttr id = dd.createAttribute( \"id\" );\n      id.setValue( i->id );\n      mw.setAttributeNode( id );\n\n      QDomAttr name = dd.createAttribute( \"name\" );\n      name.setValue( i->name );\n      mw.setAttributeNode( name );\n\n      QDomAttr url = dd.createAttribute( \"url\" );\n      url.setValue( i->url );\n      mw.setAttributeNode( url );\n\n      QDomAttr enabled = dd.createAttribute( \"enabled\" );\n      enabled.setValue( i->enabled ? \"1\" : \"0\" );\n      mw.setAttributeNode( enabled );\n\n      QDomAttr icon = dd.createAttribute( \"icon\" );\n      icon.setValue( i->icon );\n      mw.setAttributeNode( icon );\n    }\n  }\n\n  {\n    QDomElement wss = dd.createElement( \"websites\" );\n    root.appendChild( wss );\n\n    for( WebSites::const_iterator i = c.webSites.begin(); i != c.webSites.end(); ++i )\n    {\n      QDomElement ws = dd.createElement( \"website\" );\n      wss.appendChild( ws );\n\n      QDomAttr id = dd.createAttribute( \"id\" );\n      id.setValue( i->id );\n      ws.setAttributeNode( id );\n\n      QDomAttr name = dd.createAttribute( \"name\" );\n      name.setValue( i->name );\n      ws.setAttributeNode( name );\n\n      QDomAttr url = dd.createAttribute( \"url\" );\n      url.setValue( i->url );\n      ws.setAttributeNode( url );\n\n      QDomAttr enabled = dd.createAttribute( \"enabled\" );\n      enabled.setValue( i->enabled ? \"1\" : \"0\" );\n      ws.setAttributeNode( enabled );\n\n      QDomAttr icon = dd.createAttribute( \"icon\" );\n      icon.setValue( i->iconFilename );\n      ws.setAttributeNode( icon );\n\n      QDomAttr inside_iframe = dd.createAttribute( \"inside_iframe\" );\n      inside_iframe.setValue( i->inside_iframe ? \"1\" : \"0\" );\n      ws.setAttributeNode( inside_iframe );\n    }\n  }\n\n  {\n    QDomElement dss = dd.createElement( \"dictservers\" );\n    root.appendChild( dss );\n\n    for( DictServers::const_iterator i = c.dictServers.begin(); i != c.dictServers.end(); ++i )\n    {\n      QDomElement ds = dd.createElement( \"server\" );\n      dss.appendChild( ds );\n\n      QDomAttr id = dd.createAttribute( \"id\" );\n      id.setValue( i->id );\n      ds.setAttributeNode( id );\n\n      QDomAttr name = dd.createAttribute( \"name\" );\n      name.setValue( i->name );\n      ds.setAttributeNode( name );\n\n      QDomAttr url = dd.createAttribute( \"url\" );\n      url.setValue( i->url );\n      ds.setAttributeNode( url );\n\n      QDomAttr enabled = dd.createAttribute( \"enabled\" );\n      enabled.setValue( i->enabled ? \"1\" : \"0\" );\n      ds.setAttributeNode( enabled );\n\n      QDomAttr databases = dd.createAttribute( \"databases\" );\n      databases.setValue( i->databases );\n      ds.setAttributeNode( databases );\n\n      QDomAttr strategies = dd.createAttribute( \"strategies\" );\n      strategies.setValue( i->strategies );\n      ds.setAttributeNode( strategies );\n\n      QDomAttr icon = dd.createAttribute( \"icon\" );\n      icon.setValue( i->iconFilename );\n      ds.setAttributeNode( icon );\n    }\n  }\n\n  {\n    QDomElement programs = dd.createElement( \"programs\" );\n    root.appendChild( programs );\n\n    for( Programs::const_iterator i = c.programs.begin(); i != c.programs.end(); ++i )\n    {\n      QDomElement p = dd.createElement( \"program\" );\n      programs.appendChild( p );\n\n      QDomAttr id = dd.createAttribute( \"id\" );\n      id.setValue( i->id );\n      p.setAttributeNode( id );\n\n      QDomAttr name = dd.createAttribute( \"name\" );\n      name.setValue( i->name );\n      p.setAttributeNode( name );\n\n      QDomAttr commandLine = dd.createAttribute( \"commandLine\" );\n      commandLine.setValue( i->commandLine );\n      p.setAttributeNode( commandLine );\n\n      QDomAttr enabled = dd.createAttribute( \"enabled\" );\n      enabled.setValue( i->enabled ? \"1\" : \"0\" );\n      p.setAttributeNode( enabled );\n\n      QDomAttr type = dd.createAttribute( \"type\" );\n      type.setValue( QString::number( i->type ) );\n      p.setAttributeNode( type );\n\n      QDomAttr icon = dd.createAttribute( \"icon\" );\n      icon.setValue( i->iconFilename );\n      p.setAttributeNode( icon );\n    }\n  }\n\n  {\n    QDomNode ves = dd.createElement( \"voiceEngines\" );\n    root.appendChild( ves );\n\n    for ( VoiceEngines::const_iterator i = c.voiceEngines.begin(); i != c.voiceEngines.end(); ++i )\n    {\n      QDomElement v = dd.createElement( \"voiceEngine\" );\n      ves.appendChild( v );\n\n      QDomAttr id = dd.createAttribute( \"id\" );\n      id.setValue( i->id );\n      v.setAttributeNode( id );\n\n      QDomAttr name = dd.createAttribute( \"name\" );\n      name.setValue( i->name );\n      v.setAttributeNode( name );\n\n      QDomAttr enabled = dd.createAttribute( \"enabled\" );\n      enabled.setValue( i->enabled ? \"1\" : \"0\" );\n      v.setAttributeNode( enabled );\n\n      QDomAttr icon = dd.createAttribute( \"icon\" );\n      icon.setValue( i->iconFilename );\n      v.setAttributeNode( icon );\n\n      QDomAttr volume = dd.createAttribute( \"volume\" );\n      volume.setValue( QString::number( i->volume ) );\n      v.setAttributeNode( volume );\n\n      QDomAttr rate = dd.createAttribute( \"rate\" );\n      rate.setValue( QString::number( i->rate ) );\n      v.setAttributeNode( rate );\n    }\n  }\n\n  {\n    QDomElement muted = dd.createElement( \"mutedDictionaries\" );\n    root.appendChild( muted );\n    saveMutedDictionaries( dd, muted, c.mutedDictionaries );\n  }\n\n  {\n    QDomElement muted = dd.createElement( \"popupMutedDictionaries\" );\n    root.appendChild( muted );\n    saveMutedDictionaries( dd, muted, c.popupMutedDictionaries );\n  }\n\n  {\n    QDomElement preferences = dd.createElement( \"preferences\" );\n    root.appendChild( preferences );\n\n    QDomElement opt = dd.createElement( \"interfaceLanguage\" );\n    opt.appendChild( dd.createTextNode( c.preferences.interfaceLanguage ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"helpLanguage\" );\n    opt.appendChild( dd.createTextNode( c.preferences.helpLanguage ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"displayStyle\" );\n    opt.appendChild( dd.createTextNode( c.preferences.displayStyle ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"newTabsOpenAfterCurrentOne\" );\n    opt.appendChild( dd.createTextNode( c.preferences.newTabsOpenAfterCurrentOne ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"newTabsOpenInBackground\" );\n    opt.appendChild( dd.createTextNode( c.preferences.newTabsOpenInBackground ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"hideSingleTab\" );\n    opt.appendChild( dd.createTextNode( c.preferences.hideSingleTab ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"mruTabOrder\" );\n    opt.appendChild( dd.createTextNode( c.preferences.mruTabOrder ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"hideMenubar\" );\n    opt.appendChild( dd.createTextNode( c.preferences.hideMenubar ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"enableTrayIcon\" );\n    opt.appendChild( dd.createTextNode( c.preferences.enableTrayIcon ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"startToTray\" );\n    opt.appendChild( dd.createTextNode( c.preferences.startToTray ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"closeToTray\" );\n    opt.appendChild( dd.createTextNode( c.preferences.closeToTray ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"autoStart\" );\n    opt.appendChild( dd.createTextNode( c.preferences.autoStart ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"doubleClickTranslates\" );\n    opt.appendChild( dd.createTextNode( c.preferences.doubleClickTranslates ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"selectWordBySingleClick\" );\n    opt.appendChild( dd.createTextNode( c.preferences.selectWordBySingleClick ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"escKeyHidesMainWindow\" );\n    opt.appendChild( dd.createTextNode( c.preferences.escKeyHidesMainWindow ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"zoomFactor\" );\n    opt.appendChild( dd.createTextNode( QString::number( c.preferences.zoomFactor ) ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"helpZoomFactor\" );\n    opt.appendChild( dd.createTextNode( QString::number( c.preferences.helpZoomFactor ) ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"wordsZoomLevel\" );\n    opt.appendChild( dd.createTextNode( QString::number( c.preferences.wordsZoomLevel ) ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"enableMainWindowHotkey\" );\n    opt.appendChild( dd.createTextNode( c.preferences.enableMainWindowHotkey ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"mainWindowHotkey\" );\n    opt.appendChild( dd.createTextNode( c.preferences.mainWindowHotkey.toKeySequence().toString() ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"enableClipboardHotkey\" );\n    opt.appendChild( dd.createTextNode( c.preferences.enableClipboardHotkey ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"clipboardHotkey\" );\n    opt.appendChild( dd.createTextNode( c.preferences.clipboardHotkey.toKeySequence().toString() ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"enableScanPopup\" );\n    opt.appendChild( dd.createTextNode( c.preferences.enableScanPopup ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"startWithScanPopupOn\" );\n    opt.appendChild( dd.createTextNode( c.preferences.startWithScanPopupOn ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"enableScanPopupModifiers\" );\n    opt.appendChild( dd.createTextNode( c.preferences.enableScanPopupModifiers ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"scanPopupModifiers\" );\n    opt.appendChild( dd.createTextNode( QString::number( c.preferences.scanPopupModifiers ) ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"scanPopupAltMode\" );\n    opt.appendChild( dd.createTextNode( c.preferences.scanPopupAltMode ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"scanPopupAltModeSecs\" );\n    opt.appendChild( dd.createTextNode( QString::number( c.preferences.scanPopupAltModeSecs ) ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"ignoreOwnClipboardChanges\" );\n    opt.appendChild( dd.createTextNode( c.preferences.ignoreOwnClipboardChanges ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"scanToMainWindow\" );\n    opt.appendChild( dd.createTextNode( c.preferences.scanToMainWindow ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"ignoreDiacritics\" );\n    opt.appendChild( dd.createTextNode( c.preferences.ignoreDiacritics ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n#ifdef HAVE_X11\n    opt = dd.createElement( \"showScanFlag\" );\n    opt.appendChild( dd.createTextNode( c.preferences.showScanFlag? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n#endif\n\n    opt = dd.createElement( \"scanPopupUseUIAutomation\" );\n    opt.appendChild( dd.createTextNode( c.preferences.scanPopupUseUIAutomation ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"scanPopupUseIAccessibleEx\" );\n    opt.appendChild( dd.createTextNode( c.preferences.scanPopupUseIAccessibleEx ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"scanPopupUseGDMessage\" );\n    opt.appendChild( dd.createTextNode( c.preferences.scanPopupUseGDMessage ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"scanPopupUnpinnedWindowFlags\" );\n    opt.appendChild( dd.createTextNode( QString::number( c.preferences.scanPopupUnpinnedWindowFlags ) ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"scanPopupUnpinnedBypassWMHint\" );\n    opt.appendChild( dd.createTextNode( c.preferences.scanPopupUnpinnedBypassWMHint ? \"1\":\"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"pronounceOnLoadMain\" );\n    opt.appendChild( dd.createTextNode( c.preferences.pronounceOnLoadMain ? \"1\" : \"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"pronounceOnLoadPopup\" );\n    opt.appendChild( dd.createTextNode( c.preferences.pronounceOnLoadPopup ? \"1\" : \"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"useInternalPlayer\" );\n    opt.appendChild( dd.createTextNode( c.preferences.useInternalPlayer ? \"1\" : \"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"internalPlayerBackend\" );\n    opt.appendChild( dd.createTextNode( c.preferences.internalPlayerBackend.uiName() ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"audioPlaybackProgram\" );\n    opt.appendChild( dd.createTextNode( c.preferences.audioPlaybackProgram ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"alwaysOnTop\" );\n    opt.appendChild( dd.createTextNode( c.preferences.alwaysOnTop ? \"1\" : \"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"searchInDock\" );\n    opt.appendChild( dd.createTextNode( c.preferences.searchInDock ? \"1\" : \"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"historyStoreInterval\" );\n    opt.appendChild( dd.createTextNode( QString::number( c.preferences.historyStoreInterval ) ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"favoritesStoreInterval\" );\n    opt.appendChild( dd.createTextNode( QString::number( c.preferences.favoritesStoreInterval ) ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"confirmFavoritesDeletion\" );\n    opt.appendChild( dd.createTextNode( c.preferences.confirmFavoritesDeletion ? \"1\" : \"0\" ) );\n    preferences.appendChild( opt );\n\n    {\n      QDomElement proxy = dd.createElement( \"proxyserver\" );\n      preferences.appendChild( proxy );\n\n      QDomAttr enabled = dd.createAttribute( \"enabled\" );\n      enabled.setValue( c.preferences.proxyServer.enabled ? \"1\" : \"0\" );\n      proxy.setAttributeNode( enabled );\n\n      QDomAttr useSystemProxy = dd.createAttribute( \"useSystemProxy\" );\n      useSystemProxy.setValue( c.preferences.proxyServer.useSystemProxy ? \"1\" : \"0\" );\n      proxy.setAttributeNode( useSystemProxy );\n\n      opt = dd.createElement( \"type\" );\n      opt.appendChild( dd.createTextNode( QString::number( c.preferences.proxyServer.type ) ) );\n      proxy.appendChild( opt );\n\n      opt = dd.createElement( \"host\" );\n      opt.appendChild( dd.createTextNode( c.preferences.proxyServer.host ) );\n      proxy.appendChild( opt );\n\n      opt = dd.createElement( \"port\" );\n      opt.appendChild( dd.createTextNode( QString::number( c.preferences.proxyServer.port ) ) );\n      proxy.appendChild( opt );\n\n      opt = dd.createElement( \"user\" );\n      opt.appendChild( dd.createTextNode( c.preferences.proxyServer.user ) );\n      proxy.appendChild( opt );\n\n      opt = dd.createElement( \"password\" );\n      opt.appendChild( dd.createTextNode( c.preferences.proxyServer.password ) );\n      proxy.appendChild( opt );\n\n      opt = dd.createElement( \"systemProxyUser\" );\n      opt.appendChild( dd.createTextNode( c.preferences.proxyServer.systemProxyUser ) );\n      proxy.appendChild( opt );\n\n      opt = dd.createElement( \"systemProxyPassword\" );\n      opt.appendChild( dd.createTextNode( c.preferences.proxyServer.systemProxyPassword ) );\n      proxy.appendChild( opt );\n    }\n\n    opt = dd.createElement( \"checkForNewReleases\" );\n    opt.appendChild( dd.createTextNode( c.preferences.checkForNewReleases ? \"1\" : \"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"disallowContentFromOtherSites\" );\n    opt.appendChild( dd.createTextNode( c.preferences.disallowContentFromOtherSites ? \"1\" : \"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"enableWebPlugins\" );\n    opt.appendChild( dd.createTextNode( c.preferences.enableWebPlugins ? \"1\" : \"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"hideGoldenDictHeader\" );\n    opt.appendChild( dd.createTextNode( c.preferences.hideGoldenDictHeader ? \"1\" : \"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"maxNetworkCacheSize\" );\n    opt.appendChild( dd.createTextNode( QString::number( c.preferences.maxNetworkCacheSize ) ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"clearNetworkCacheOnExit\" );\n    opt.appendChild( dd.createTextNode( c.preferences.clearNetworkCacheOnExit ? \"1\" : \"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"maxStringsInHistory\" );\n    opt.appendChild( dd.createTextNode( QString::number( c.preferences.maxStringsInHistory ) ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"storeHistory\" );\n    opt.appendChild( dd.createTextNode( QString::number( c.preferences.storeHistory ) ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"alwaysExpandOptionalParts\" );\n    opt.appendChild( dd.createTextNode( QString::number( c.preferences.alwaysExpandOptionalParts ) ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"addonStyle\" );\n    opt.appendChild( dd.createTextNode( c.preferences.addonStyle ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"collapseBigArticles\" );\n    opt.appendChild( dd.createTextNode( c.preferences.collapseBigArticles ? \"1\" : \"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"articleSizeLimit\" );\n    opt.appendChild( dd.createTextNode( QString::number( c.preferences.articleSizeLimit ) ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"limitInputPhraseLength\" );\n    opt.appendChild( dd.createTextNode( c.preferences.limitInputPhraseLength ? \"1\" : \"0\" ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"inputPhraseLengthLimit\" );\n    opt.appendChild( dd.createTextNode( QString::number( c.preferences.inputPhraseLengthLimit ) ) );\n    preferences.appendChild( opt );\n\n    opt = dd.createElement( \"maxDictionaryRefsInContextMenu\" );\n    opt.appendChild( dd.createTextNode( QString::number( c.preferences.maxDictionaryRefsInContextMenu ) ) );\n    preferences.appendChild( opt );\n\n#ifndef Q_WS_X11\n    opt = dd.createElement( \"trackClipboardChanges\" );\n    opt.appendChild( dd.createTextNode( c.preferences.trackClipboardChanges ? \"1\" : \"0\" ) );\n    preferences.appendChild( opt );\n#endif\n\n    opt = dd.createElement( \"synonymSearchEnabled\" );\n    opt.appendChild( dd.createTextNode( c.preferences.synonymSearchEnabled ? \"1\" : \"0\" ) );\n    preferences.appendChild( opt );\n\n    {\n      QDomNode hd = dd.createElement( \"fullTextSearch\" );\n      preferences.appendChild( hd );\n\n      QDomElement opt = dd.createElement( \"searchMode\" );\n      opt.appendChild( dd.createTextNode( QString::number( c.preferences.fts.searchMode ) ) );\n      hd.appendChild( opt );\n\n      opt = dd.createElement( \"matchCase\" );\n      opt.appendChild( dd.createTextNode( c.preferences.fts.matchCase ? \"1\" : \"0\" ) );\n      hd.appendChild( opt );\n\n      opt = dd.createElement( \"maxArticlesPerDictionary\" );\n      opt.appendChild( dd.createTextNode( QString::number( c.preferences.fts.maxArticlesPerDictionary ) ) );\n      hd.appendChild( opt );\n\n      opt = dd.createElement( \"maxDistanceBetweenWords\" );\n      opt.appendChild( dd.createTextNode( QString::number( c.preferences.fts.maxDistanceBetweenWords ) ) );\n      hd.appendChild( opt );\n\n      opt = dd.createElement( \"useMaxArticlesPerDictionary\" );\n      opt.appendChild( dd.createTextNode( c.preferences.fts.useMaxArticlesPerDictionary ? \"1\" : \"0\" ) );\n      hd.appendChild( opt );\n\n      opt = dd.createElement( \"useMaxDistanceBetweenWords\" );\n      opt.appendChild( dd.createTextNode( c.preferences.fts.useMaxDistanceBetweenWords ? \"1\" : \"0\" ) );\n      hd.appendChild( opt );\n\n      opt = dd.createElement( \"dialogGeometry\" );\n      opt.appendChild( dd.createTextNode( QString::fromLatin1( c.preferences.fts.dialogGeometry.toBase64() ) ) );\n      hd.appendChild( opt );\n\n      opt = dd.createElement( \"disabledTypes\" );\n      opt.appendChild( dd.createTextNode( c.preferences.fts.disabledTypes ) );\n      hd.appendChild( opt );\n\n      opt = dd.createElement( \"enabled\" );\n      opt.appendChild( dd.createTextNode( c.preferences.fts.enabled ? \"1\" : \"0\" ) );\n      hd.appendChild( opt );\n\n      opt = dd.createElement( \"ignoreWordsOrder\" );\n      opt.appendChild( dd.createTextNode( c.preferences.fts.ignoreWordsOrder ? \"1\" : \"0\" ) );\n      hd.appendChild( opt );\n\n      opt = dd.createElement( \"ignoreDiacritics\" );\n      opt.appendChild( dd.createTextNode( c.preferences.fts.ignoreDiacritics ? \"1\" : \"0\" ) );\n      hd.appendChild( opt );\n\n      opt = dd.createElement( \"maxDictionarySize\" );\n      opt.appendChild( dd.createTextNode( QString::number( c.preferences.fts.maxDictionarySize ) ) );\n      hd.appendChild( opt );\n    }\n\n  }\n\n  {\n    QDomElement opt = dd.createElement( \"lastMainGroupId\" );\n    opt.appendChild( dd.createTextNode( QString::number( c.lastMainGroupId ) ) );\n    root.appendChild( opt );\n\n    opt = dd.createElement( \"lastPopupGroupId\" );\n    opt.appendChild( dd.createTextNode( QString::number( c.lastPopupGroupId ) ) );\n    root.appendChild( opt );\n\n    opt = dd.createElement( \"popupWindowState\" );\n    opt.appendChild( dd.createTextNode( QString::fromLatin1( c.popupWindowState.toBase64() ) ) );\n    root.appendChild( opt );\n\n    opt = dd.createElement( \"popupWindowGeometry\" );\n    opt.appendChild( dd.createTextNode( QString::fromLatin1( c.popupWindowGeometry.toBase64() ) ) );\n    root.appendChild( opt );\n\n    opt = dd.createElement( \"pinPopupWindow\" );\n    opt.appendChild( dd.createTextNode( c.pinPopupWindow ? \"1\" : \"0\" ) );\n    root.appendChild( opt );\n\n    opt = dd.createElement( \"popupWindowAlwaysOnTop\" );\n    opt.appendChild( dd.createTextNode( c.popupWindowAlwaysOnTop ? \"1\" : \"0\" ) );\n    root.appendChild( opt );\n\n    opt = dd.createElement( \"mainWindowState\" );\n    opt.appendChild( dd.createTextNode( QString::fromLatin1( c.mainWindowState.toBase64() ) ) );\n    root.appendChild( opt );\n\n    opt = dd.createElement( \"mainWindowGeometry\" );\n    opt.appendChild( dd.createTextNode( QString::fromLatin1( c.mainWindowGeometry.toBase64() ) ) );\n    root.appendChild( opt );\n\n    opt = dd.createElement( \"helpWindowGeometry\" );\n    opt.appendChild( dd.createTextNode( QString::fromLatin1( c.helpWindowGeometry.toBase64() ) ) );\n    root.appendChild( opt );\n\n    opt = dd.createElement( \"helpSplitterState\" );\n    opt.appendChild( dd.createTextNode( QString::fromLatin1( c.helpSplitterState.toBase64() ) ) );\n    root.appendChild( opt );\n\n#ifdef Q_OS_WIN\n    {\n      QDomElement maximizedMainWindowGeometry = dd.createElement( \"maximizedMainWindowGeometry\" );\n      root.appendChild( maximizedMainWindowGeometry );\n\n      opt = dd.createElement( \"x\" );\n      opt.appendChild( dd.createTextNode( QString::number( c.maximizedMainWindowGeometry.x() ) ) );\n      maximizedMainWindowGeometry.appendChild( opt );\n\n      opt = dd.createElement( \"y\" );\n      opt.appendChild( dd.createTextNode( QString::number( c.maximizedMainWindowGeometry.y() ) ) );\n      maximizedMainWindowGeometry.appendChild( opt );\n\n      opt = dd.createElement( \"width\" );\n      opt.appendChild( dd.createTextNode( QString::number( c.maximizedMainWindowGeometry.width() ) ) );\n      maximizedMainWindowGeometry.appendChild( opt );\n\n      opt = dd.createElement( \"height\" );\n      opt.appendChild( dd.createTextNode( QString::number( c.maximizedMainWindowGeometry.height() ) ) );\n      maximizedMainWindowGeometry.appendChild( opt );\n\n      QDomElement normalMainWindowGeometry = dd.createElement( \"normalMainWindowGeometry\" );\n      root.appendChild( normalMainWindowGeometry );\n\n      opt = dd.createElement( \"x\" );\n      opt.appendChild( dd.createTextNode( QString::number( c.normalMainWindowGeometry.x() ) ) );\n      normalMainWindowGeometry.appendChild( opt );\n\n      opt = dd.createElement( \"y\" );\n      opt.appendChild( dd.createTextNode( QString::number( c.normalMainWindowGeometry.y() ) ) );\n      normalMainWindowGeometry.appendChild( opt );\n\n      opt = dd.createElement( \"width\" );\n      opt.appendChild( dd.createTextNode( QString::number( c.normalMainWindowGeometry.width() ) ) );\n      normalMainWindowGeometry.appendChild( opt );\n\n      opt = dd.createElement( \"height\" );\n      opt.appendChild( dd.createTextNode( QString::number( c.normalMainWindowGeometry.height() ) ) );\n      normalMainWindowGeometry.appendChild( opt );\n    }\n#endif\n\n    opt = dd.createElement( \"dictInfoGeometry\" );\n    opt.appendChild( dd.createTextNode( QString::fromLatin1( c.dictInfoGeometry.toBase64() ) ) );\n    root.appendChild( opt );\n\n    opt = dd.createElement( \"inspectorGeometry\" );\n    opt.appendChild( dd.createTextNode( QString::fromLatin1( c.inspectorGeometry.toBase64() ) ) );\n    root.appendChild( opt );\n\n    opt = dd.createElement( \"dictionariesDialogGeometry\" );\n    opt.appendChild( dd.createTextNode( QString::fromLatin1( c.dictionariesDialogGeometry.toBase64() ) ) );\n    root.appendChild( opt );\n\n    opt = dd.createElement( \"printPreviewDialogGeometry\" );\n    opt.appendChild( dd.createTextNode( QString::fromLatin1( c.printPreviewDialogGeometry.toBase64() ) ) );\n    root.appendChild( opt );\n\n    opt = dd.createElement( \"timeForNewReleaseCheck\" );\n    opt.appendChild( dd.createTextNode( c.timeForNewReleaseCheck.toString( Qt::ISODate ) ) );\n    root.appendChild( opt );\n\n    opt = dd.createElement( \"skippedRelease\" );\n    opt.appendChild( dd.createTextNode( c.skippedRelease ) );\n    root.appendChild( opt );\n\n    opt = dd.createElement( \"showingDictBarNames\" );\n    opt.appendChild( dd.createTextNode( c.showingDictBarNames ? \"1\" : \"0\" ) );\n    root.appendChild( opt );\n\n    opt = dd.createElement( \"usingSmallIconsInToolbars\" );\n    opt.appendChild( dd.createTextNode( c.usingSmallIconsInToolbars ? \"1\" : \"0\" ) );\n    root.appendChild( opt );\n\n    if( !c.historyExportPath.isEmpty() )\n    {\n        opt = dd.createElement( \"historyExportPath\" );\n        opt.appendChild( dd.createTextNode( c.historyExportPath ) );\n        root.appendChild( opt );\n    }\n\n    if( !c.resourceSavePath.isEmpty() )\n    {\n        opt = dd.createElement( \"resourceSavePath\" );\n        opt.appendChild( dd.createTextNode( c.resourceSavePath ) );\n        root.appendChild( opt );\n    }\n\n    if( !c.articleSavePath.isEmpty() )\n    {\n        opt = dd.createElement( \"articleSavePath\" );\n        opt.appendChild( dd.createTextNode( c.articleSavePath ) );\n        root.appendChild( opt );\n    }\n\n    opt = dd.createElement( \"editDictionaryCommandLine\" );\n    opt.appendChild( dd.createTextNode( c.editDictionaryCommandLine ) );\n    root.appendChild( opt );\n\n    opt = dd.createElement( \"maxPictureWidth\" );\n    opt.appendChild( dd.createTextNode( QString::number( c.maxPictureWidth ) ) );\n    root.appendChild( opt );\n\n    opt = dd.createElement( \"maxHeadwordSize\" );\n    opt.appendChild( dd.createTextNode( QString::number( c.maxHeadwordSize ) ) );\n    root.appendChild( opt );\n\n    opt = dd.createElement( \"maxHeadwordsToExpand\" );\n    opt.appendChild( dd.createTextNode( QString::number( c.maxHeadwordsToExpand ) ) );\n    root.appendChild( opt );\n  }\n\n  {\n    QDomNode hd = dd.createElement( \"headwordsDialog\" );\n    root.appendChild( hd );\n\n    QDomElement opt = dd.createElement( \"searchMode\" );\n    opt.appendChild( dd.createTextNode( QString::number( c.headwordsDialog.searchMode ) ) );\n    hd.appendChild( opt );\n\n    opt = dd.createElement( \"matchCase\" );\n    opt.appendChild( dd.createTextNode( c.headwordsDialog.matchCase ? \"1\" : \"0\" ) );\n    hd.appendChild( opt );\n\n    opt = dd.createElement( \"autoApply\" );\n    opt.appendChild( dd.createTextNode( c.headwordsDialog.autoApply ? \"1\" : \"0\" ) );\n    hd.appendChild( opt );\n\n    opt = dd.createElement( \"headwordsExportPath\" );\n    opt.appendChild( dd.createTextNode( c.headwordsDialog.headwordsExportPath ) );\n    hd.appendChild( opt );\n\n    opt = dd.createElement( \"headwordsDialogGeometry\" );\n    opt.appendChild( dd.createTextNode( QString::fromLatin1( c.headwordsDialog.headwordsDialogGeometry.toBase64() ) ) );\n    hd.appendChild( opt );\n  }\n\n  QByteArray result( dd.toByteArray() );\n\n  if ( configFile.write( result ) != result.size() )\n    throw exCantWriteConfigFile();\n\n  configFile.close();\n\n  renameAtomically( configFile.fileName(), getConfigFileName() );\n}\n\nQString getConfigFileName()\n{\n  return getHomeDir().absoluteFilePath( \"config\" );\n}\n\nQString getConfigDir() THROW_SPEC( exError )\n{\n  return getHomeDir().path() + QDir::separator();\n}\n\nQString getIndexDir() THROW_SPEC( exError )\n{\n  QDir result = getHomeDir();\n\n#ifdef XDG_BASE_DIRECTORY_COMPLIANCE\n  // store index in XDG_CACHE_HOME in non-portable version\n  // *and* when an old index directory in GoldenDict home doesn't exist\n  if ( !isPortableVersion() && !result.exists( \"index\" ) )\n  {\n    result.setPath( getCacheDir() );\n  }\n#endif\n\n  result.mkpath( \"index\" );\n\n  if ( !result.cd( \"index\" ) )\n    throw exCantUseIndexDir();\n\n  return result.path() + QDir::separator();\n}\n\nQString getPidFileName() THROW_SPEC( exError )\n{\n  return getHomeDir().filePath( \"pid\" );\n}\n\nQString getHistoryFileName() THROW_SPEC( exError )\n{\n  QString homeHistoryPath = getHomeDir().filePath( \"history\" );\n\n#ifdef XDG_BASE_DIRECTORY_COMPLIANCE\n  // use separate data dir for history, if it is not already stored alongside\n  // configuration in non-portable mode\n  if ( !isPortableVersion() && !QFile::exists( homeHistoryPath ) )\n  {\n    return getDataDir().filePath( \"history\" );\n  }\n#endif\n\n  return homeHistoryPath;\n}\n\nQString getFavoritiesFileName() THROW_SPEC( exError )\n{\n  return getHomeDir().filePath( \"favorites\" );\n}\n\nQString getUserCssFileName() THROW_SPEC( exError )\n{\n  return getHomeDir().filePath( \"article-style.css\" );\n}\n\nQString getUserCssPrintFileName() THROW_SPEC( exError )\n{\n  return getHomeDir().filePath( \"article-style-print.css\" );\n}\n\nQString getUserQtCssFileName() THROW_SPEC( exError )\n{\n  return getHomeDir().filePath( \"qt-style.css\" );\n}\n\nQString getProgramDataDir() throw()\n{\n  if ( isPortableVersion() )\n    return QCoreApplication::applicationDirPath();\n\n  #ifdef PROGRAM_DATA_DIR\n  return PROGRAM_DATA_DIR;\n  #else\n  return QCoreApplication::applicationDirPath();\n  #endif\n}\n\nQString getLocDir() throw()\n{\n  if ( QDir( getProgramDataDir() ).cd( \"locale\" ) )\n    return getProgramDataDir() + \"/locale\";\n  else\n    return QCoreApplication::applicationDirPath() + \"/locale\";\n}\n\nQString getHelpDir() throw()\n{\n  if ( QDir( getProgramDataDir() ).cd( \"help\" ) )\n    return getProgramDataDir() + \"/help\";\n  else\n    return QCoreApplication::applicationDirPath() + \"/help\";\n}\n\n#ifdef MAKE_CHINESE_CONVERSION_SUPPORT\nQString getOpenCCDir() throw()\n{\n#if defined( Q_OS_WIN )\n  if ( QDir( \"opencc\" ).exists() )\n    return \"opencc\";\n  else\n    return QCoreApplication::applicationDirPath() + \"/opencc\";\n#elif defined( Q_OS_MAC )\n  QString path = QCoreApplication::applicationDirPath() + \"/opencc\";\n  if ( QDir( path ).exists() )\n    return path;\n\n  return QString();\n#else\n  return QString();\n#endif\n}\n#endif\n\nbool isPortableVersion() throw()\n{\n  struct IsPortable\n  {\n    bool isPortable;\n\n    IsPortable(): isPortable( QFileInfo( portableHomeDirPath() ).isDir() )\n    {}\n  };\n\n  static IsPortable p;\n\n  return p.isPortable;\n}\n\nQString getPortableVersionDictionaryDir() throw()\n{\n  if ( isPortableVersion() )\n    return getProgramDataDir() + \"/content\";\n  else\n    return QString();\n}\n\nQString getPortableVersionMorphoDir() throw()\n{\n  if ( isPortableVersion() )\n    return getPortableVersionDictionaryDir() + \"/morphology\";\n  else\n    return QString();\n}\n\nQString getStylesDir() throw()\n{\n  QDir result = getHomeDir();\n\n  result.mkpath( \"styles\" );\n\n  if ( !result.cd( \"styles\" ) )\n    return QString();\n\n  return result.path() + QDir::separator();\n}\n\nQString getCacheDir() throw()\n{\n  return isPortableVersion() ? portableHomeDirPath() + \"/cache\"\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  #ifdef HAVE_X11\n                             : QStandardPaths::writableLocation( QStandardPaths::GenericCacheLocation ) + \"/goldendict\";\n  #else\n                             : QStandardPaths::writableLocation( QStandardPaths::CacheLocation );\n  #endif\n#else\n                             : QDesktopServices::storageLocation( QDesktopServices::CacheLocation );\n#endif\n}\n\nQString getNetworkCacheDir() throw()\n{\n  return getCacheDir() + \"/network\";\n}\n\n}\n"
        },
        {
          "name": "config.hh",
          "type": "blob",
          "size": 23.091796875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __CONFIG_HH_INCLUDED__\n#define __CONFIG_HH_INCLUDED__\n\n#include <QObject>\n#include <QVector>\n#include <QString>\n#include <QSize>\n#include <QDateTime>\n#include <QKeySequence>\n#include <QSet>\n#include <QMetaType>\n#include \"cpp_features.hh\"\n#include \"ex.hh\"\n\n#ifdef Q_OS_WIN\n#include <QRect>\n#endif\n\n/// GoldenDict's configuration\nnamespace Config {\n\n/// Dictionaries which are temporarily disabled via the dictionary bar.\ntypedef QSet< QString > MutedDictionaries;\n\n#ifdef Q_OS_WIN\n#pragma pack(push,4)\n#endif\n\n/// A path where to search for the dictionaries\nstruct Path\n{\n  QString path;\n  bool recursive;\n\n  Path(): recursive( false ) {}\n  Path( QString const & path_, bool recursive_ ):\n    path( path_ ), recursive( recursive_ ) {}\n\n  bool operator == ( Path const & other ) const\n  { return path == other.path && recursive == other.recursive; }\n};\n\n/// A list of paths where to search for the dictionaries\ntypedef QVector< Path > Paths;\n\n/// A directory holding bunches of audiofiles, which is indexed into a separate\n/// dictionary.\nstruct SoundDir\n{\n  QString path, name;\n  QString iconFilename;\n\n  SoundDir()\n  {}\n\n  SoundDir( QString const & path_, QString const & name_, QString iconFilename_ = \"\" ):\n    path( path_ ), name( name_ ), iconFilename( iconFilename_ )\n  {}\n\n  bool operator == ( SoundDir const & other ) const\n  { return path == other.path && name == other.name && iconFilename == other.iconFilename; }\n};\n\n/// A list of SoundDirs\ntypedef QVector< SoundDir > SoundDirs;\n\nstruct DictionaryRef\n{\n  QString id; // Dictionrary id, which is usually an md5 hash\n  QString name; // Dictionary name, used to recover when its id changes\n\n  DictionaryRef()\n  {}\n\n  DictionaryRef( QString const & id_, QString const & name_ ):\n    id( id_ ), name( name_ ) {}\n\n  bool operator == ( DictionaryRef const & other ) const\n  { return id == other.id && name == other.name; }\n};\n\n/// A dictionary group\nstruct Group\n{\n  unsigned id;\n  QString name, icon;\n  QByteArray iconData;\n  QKeySequence shortcut;\n  QString favoritesFolder;\n  QVector< DictionaryRef > dictionaries;\n  Config::MutedDictionaries mutedDictionaries; // Disabled via dictionary bar\n  Config::MutedDictionaries popupMutedDictionaries; // Disabled via dictionary bar in popup\n\n  Group(): id( 0 ) {}\n\n  bool operator == ( Group const & other ) const\n  { return id == other.id && name == other.name && icon == other.icon &&\n           favoritesFolder == other.favoritesFolder &&\n           dictionaries == other.dictionaries && shortcut == other.shortcut &&\n           mutedDictionaries == other.mutedDictionaries &&\n           popupMutedDictionaries == other.popupMutedDictionaries &&\n           iconData == other.iconData; }\n\n  bool operator != ( Group const & other ) const\n  { return ! operator == ( other ); }\n};\n\n/// All the groups\nstruct Groups: public QVector< Group >\n{\n  unsigned nextId; // Id to use to create the group next time\n\n  Groups(): nextId( 1 )\n  {}\n};\n\n/// Proxy server configuration\nstruct ProxyServer\n{\n  bool enabled;\n  bool useSystemProxy;\n\n  enum Type\n  {\n    Socks5 = 0,\n    HttpConnect,\n    HttpGet\n  } type;\n\n  QString host;\n  unsigned port;\n  QString user, password;\n  QString systemProxyUser, systemProxyPassword;\n\n  ProxyServer();\n};\n\n// A hotkey -- currently qt modifiers plus one or two keys\nstruct HotKey\n{\n  Qt::KeyboardModifiers modifiers;\n  int key1, key2;\n\n  HotKey();\n\n  /// We use the first two keys of QKeySequence, with modifiers being stored\n  /// in the first one.\n  HotKey( QKeySequence const & );\n\n  QKeySequence toKeySequence() const;\n};\n\nstruct FullTextSearch\n{\n  int searchMode;\n  bool matchCase;\n  int maxArticlesPerDictionary;\n  int maxDistanceBetweenWords;\n  bool useMaxDistanceBetweenWords;\n  bool useMaxArticlesPerDictionary;\n  bool enabled;\n  bool ignoreWordsOrder;\n  bool ignoreDiacritics;\n  quint32 maxDictionarySize;\n  QByteArray dialogGeometry;\n  QString disabledTypes;\n\n  FullTextSearch() :\n    searchMode( 0 ), matchCase( false ),\n    maxArticlesPerDictionary( 100 ),\n    maxDistanceBetweenWords( 2 ),\n    useMaxDistanceBetweenWords( true ),\n    useMaxArticlesPerDictionary( false ),\n    enabled( true ),\n    ignoreWordsOrder( false ),\n    ignoreDiacritics( false ),\n    maxDictionarySize( 0 )\n  {}\n};\n\n/// This class encapsulates supported backend preprocessor logic,\n/// discourages duplicating backend names in code, which is error-prone.\nclass InternalPlayerBackend\n{\npublic:\n  /// Returns true if at least one backend is available.\n  static bool anyAvailable();\n  /// Returns the default backend or null backend if none is available.\n  static InternalPlayerBackend defaultBackend();\n  /// Returns the name list of supported backends.\n  static QStringList nameList();\n\n  /// Returns true if built with FFmpeg player support and the name matches.\n  bool isFfmpeg() const;\n  /// Returns true if built with Qt Multimedia player support and the name matches.\n  bool isQtmultimedia() const;\n\n  QString const & uiName() const\n  { return name; }\n\n  void setUiName( QString const & name_ )\n  { name = name_; }\n\n  bool operator == ( InternalPlayerBackend const & other ) const\n  { return name == other.name; }\n\n  bool operator != ( InternalPlayerBackend const & other ) const\n  { return ! operator == ( other ); }\n\nprivate:\n#ifdef MAKE_FFMPEG_PLAYER\n  static InternalPlayerBackend ffmpeg()\n  { return InternalPlayerBackend( \"FFmpeg+libao\" ); }\n#endif\n\n#ifdef MAKE_QTMULTIMEDIA_PLAYER\n  static InternalPlayerBackend qtmultimedia()\n  { return InternalPlayerBackend( \"Qt Multimedia\" ); }\n#endif\n\n  explicit InternalPlayerBackend( QString const & name_ ) : name( name_ )\n  {}\n\n  QString name;\n};\n\n#if defined( HAVE_X11 ) && QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  // The ScanPopup window flags customization code has been tested\n  // only in X11 desktop environments and window managers.\n  // None of the window flags configurations I have tried works perfectly well\n  // in XFCE with Qt4. Let us enable customization code for Qt5 exclusively to\n  // avoid regressions with Qt4.\n  #define ENABLE_SPWF_CUSTOMIZATION\n#endif\n\nenum ScanPopupWindowFlags\n{\n  SPWF_default = 0,\n  SPWF_Popup,\n  SPWF_Tool\n};\nScanPopupWindowFlags spwfFromInt( int id );\n\nstruct InputPhrase\n{\n  InputPhrase()\n  {}\n\n  InputPhrase( QString const & _phrase, QString const & _suffix ) :\n    phrase( _phrase ),\n    punctuationSuffix( _suffix )\n  {}\n\n  static InputPhrase fromPhrase( QString const & phrase )\n  {\n    return InputPhrase( phrase, QString() );\n  }\n\n  bool isValid() const { return !phrase.isEmpty(); }\n\n  QString phraseWithSuffix() const { return phrase + punctuationSuffix; }\n\n  QString phrase;\n  QString punctuationSuffix;\n};\n\ninline bool operator == ( InputPhrase const & a, InputPhrase const & b )\n{\n  return a.phrase == b.phrase && a.punctuationSuffix == b.punctuationSuffix;\n}\ninline bool operator != ( InputPhrase const & a, InputPhrase const & b )\n{\n  return !( a == b );\n}\n\n/// Various user preferences\nstruct Preferences\n{\n  QString interfaceLanguage; // Empty value corresponds to system default\n  QString helpLanguage; // Empty value corresponds to interface language\n  QString displayStyle; // Empty value corresponds to the default one\n  bool newTabsOpenAfterCurrentOne;\n  bool newTabsOpenInBackground;\n  bool hideSingleTab;\n  bool mruTabOrder;\n  bool hideMenubar;\n  bool enableTrayIcon;\n  bool startToTray;\n  bool closeToTray;\n  bool autoStart;\n  bool doubleClickTranslates;\n  bool selectWordBySingleClick;\n  bool escKeyHidesMainWindow;\n  bool alwaysOnTop;\n\n  /// An old UI mode when tranlateLine and wordList\n  /// are in the dockable side panel, not on the toolbar.\n  bool searchInDock;\n\n  bool enableMainWindowHotkey;\n  HotKey mainWindowHotkey;\n  bool enableClipboardHotkey;\n  HotKey clipboardHotkey;\n\n  bool enableScanPopup;\n  bool startWithScanPopupOn;\n  bool enableScanPopupModifiers;\n  unsigned long scanPopupModifiers; // Combination of KeyboardState::Modifier\n  bool scanPopupAltMode; // When you press modifier shortly after the selection\n  unsigned scanPopupAltModeSecs;\n  bool ignoreOwnClipboardChanges;\n  bool scanPopupUseUIAutomation;\n  bool scanPopupUseIAccessibleEx;\n  bool scanPopupUseGDMessage;\n  ScanPopupWindowFlags scanPopupUnpinnedWindowFlags;\n  bool scanPopupUnpinnedBypassWMHint;\n  bool scanToMainWindow;\n  bool ignoreDiacritics;\n#ifdef HAVE_X11\n  bool showScanFlag;\n#endif\n\n  // Whether the word should be pronounced on page load, in main window/popup\n  bool pronounceOnLoadMain, pronounceOnLoadPopup;\n  bool useInternalPlayer;\n  InternalPlayerBackend internalPlayerBackend;\n  QString audioPlaybackProgram;\n\n  ProxyServer proxyServer;\n\n  bool checkForNewReleases;\n  bool disallowContentFromOtherSites;\n  bool enableWebPlugins;\n  bool hideGoldenDictHeader;\n  int maxNetworkCacheSize;\n  bool clearNetworkCacheOnExit;\n\n  qreal zoomFactor;\n  qreal helpZoomFactor;\n  int wordsZoomLevel;\n\n  unsigned maxStringsInHistory;\n  unsigned storeHistory;\n  bool alwaysExpandOptionalParts;\n\n  unsigned historyStoreInterval;\n  unsigned favoritesStoreInterval;\n\n  bool confirmFavoritesDeletion;\n\n  bool collapseBigArticles;\n  int articleSizeLimit;\n\n  bool limitInputPhraseLength;\n  int inputPhraseLengthLimit;\n  InputPhrase sanitizeInputPhrase( QString const & inputPhrase ) const;\n\n  unsigned short maxDictionaryRefsInContextMenu;\n#ifndef Q_WS_X11\n  bool trackClipboardChanges;\n#endif\n\n  bool synonymSearchEnabled;\n\n  QString addonStyle;\n\n  FullTextSearch fts;\n\n  Preferences();\n};\n\n/// A MediaWiki network dictionary definition\nstruct MediaWiki\n{\n  QString id, name, url;\n  bool enabled;\n  QString icon;\n\n  MediaWiki(): enabled( false )\n  {}\n\n  MediaWiki( QString const & id_, QString const & name_, QString const & url_,\n             bool enabled_, QString const & icon_ ):\n    id( id_ ), name( name_ ), url( url_ ), enabled( enabled_ ), icon( icon_ ) {}\n\n  bool operator == ( MediaWiki const & other ) const\n  { return id == other.id && name == other.name && url == other.url &&\n           enabled == other.enabled && icon == other.icon ; }\n};\n\n/// Any website which can be queried though a simple template substitution\nstruct WebSite\n{\n  QString id, name, url;\n  bool enabled;\n  QString iconFilename;\n  bool inside_iframe;\n\n  WebSite(): enabled( false )\n  {}\n\n  WebSite( QString const & id_, QString const & name_, QString const & url_,\n           bool enabled_, QString const & iconFilename_, bool inside_iframe_ ):\n    id( id_ ), name( name_ ), url( url_ ), enabled( enabled_ ), iconFilename( iconFilename_ ),\n    inside_iframe( inside_iframe_ ) {}\n\n  bool operator == ( WebSite const & other ) const\n  { return id == other.id && name == other.name && url == other.url &&\n           enabled == other.enabled && iconFilename == other.iconFilename &&\n           inside_iframe == other.inside_iframe; }\n};\n\n/// All the WebSites\ntypedef QVector< WebSite > WebSites;\n\n/// Any DICT server\nstruct DictServer\n{\n  QString id, name, url;\n  bool enabled;\n  QString databases;\n  QString strategies;\n  QString iconFilename;\n\n  DictServer(): enabled( false )\n  {}\n\n  DictServer( QString const & id_, QString const & name_, QString const & url_,\n              bool enabled_, QString const & databases_, QString const & strategies_,\n              QString const & iconFilename_ ):\n    id( id_ ), name( name_ ), url( url_ ), enabled( enabled_ ), databases( databases_ ),\n    strategies( strategies_ ), iconFilename( iconFilename_ )  {}\n\n  bool operator == ( DictServer const & other ) const\n  { return id == other.id && name == other.name && url == other.url\n           && enabled == other.enabled && databases == other.databases\n           && strategies == other.strategies\n           && iconFilename == other.iconFilename; }\n};\n\n/// All the DictServers\ntypedef QVector< DictServer > DictServers;\n\n/// Hunspell configuration\nstruct Hunspell\n{\n  QString dictionariesPath;\n\n  typedef QVector< QString > Dictionaries;\n\n  Dictionaries enabledDictionaries;\n\n  bool operator == ( Hunspell const & other ) const\n  { return dictionariesPath == other.dictionariesPath &&\n    enabledDictionaries == other.enabledDictionaries; }\n\n  bool operator != ( Hunspell const & other ) const\n  { return ! operator == ( other ); }\n};\n\n/// All the MediaWikis\ntypedef QVector< MediaWiki > MediaWikis;\n\n#ifdef MAKE_CHINESE_CONVERSION_SUPPORT\n/// Chinese transliteration configuration\nstruct Chinese\n{\n  bool enable;\n\n  bool enableSCToTWConversion;\n  bool enableSCToHKConversion;\n  bool enableTCToSCConversion;\n\n  Chinese();\n\n  bool operator == ( Chinese const & other ) const\n  { return enable == other.enable &&\n           enableSCToTWConversion == other.enableSCToTWConversion &&\n           enableSCToHKConversion == other.enableSCToHKConversion &&\n           enableTCToSCConversion == other.enableTCToSCConversion; }\n\n  bool operator != ( Chinese const & other ) const\n  { return ! operator == ( other ); }\n\n};\n#endif\n\n/// Romaji transliteration configuration\nstruct Romaji\n{\n  bool enable;\n\n  bool enableHepburn;\n  bool enableNihonShiki;\n  bool enableKunreiShiki;\n  bool enableHiragana;\n  bool enableKatakana;\n\n  Romaji();\n\n  bool operator == ( Romaji const & other ) const\n  { return enable == other.enable &&\n           enableHepburn == other.enableHepburn &&\n           enableNihonShiki == other.enableNihonShiki &&\n           enableKunreiShiki == other.enableKunreiShiki &&\n           enableHiragana == other.enableHiragana &&\n           enableKatakana == other.enableKatakana; }\n\n  bool operator != ( Romaji const & other ) const\n  { return ! operator == ( other ); }\n\n};\n\nstruct Transliteration\n{\n  bool enableRussianTransliteration;\n  bool enableGermanTransliteration;\n  bool enableGreekTransliteration;\n  bool enableBelarusianTransliteration;\n#ifdef MAKE_CHINESE_CONVERSION_SUPPORT\n  Chinese chinese;\n#endif\n  Romaji romaji;\n\n  bool operator == ( Transliteration const & other ) const\n  { return enableRussianTransliteration == other.enableRussianTransliteration &&\n           enableGermanTransliteration == other.enableGermanTransliteration &&\n           enableGreekTransliteration == other.enableGreekTransliteration &&\n           enableBelarusianTransliteration == other.enableBelarusianTransliteration &&\n#ifdef MAKE_CHINESE_CONVERSION_SUPPORT\n           chinese == other.chinese &&\n#endif\n           romaji == other.romaji;\n  }\n\n  bool operator != ( Transliteration const & other ) const\n  { return ! operator == ( other ); }\n\n  Transliteration():\n      enableRussianTransliteration( false ),\n      enableGermanTransliteration( false ),\n      enableGreekTransliteration( false ),\n      enableBelarusianTransliteration( false )\n  {}\n};\n\nstruct Forvo\n{\n  bool enable;\n  QString apiKey;\n  QString languageCodes;\n\n  Forvo(): enable( false )\n  {}\n\n  bool operator == ( Forvo const & other ) const\n  { return enable == other.enable &&\n           apiKey == other.apiKey &&\n           languageCodes == other.languageCodes;\n  }\n\n  bool operator != ( Forvo const & other ) const\n  { return ! operator == ( other ); }\n};\n\nstruct Program\n{\n  bool enabled;\n  enum Type\n  {\n    Audio,\n    PlainText,\n    Html,\n    PrefixMatch,\n    MaxTypeValue\n  } type;\n  QString id, name, commandLine;\n  QString iconFilename;\n\n  Program(): enabled( false )\n  {}\n\n  Program( bool enabled_, Type type_, QString const & id_,\n          QString const & name_, QString const & commandLine_, QString const & iconFilename_ ):\n    enabled( enabled_ ), type( type_ ), id( id_ ), name( name_ ),\n    commandLine( commandLine_ ), iconFilename( iconFilename_ ) {}\n\n  bool operator == ( Program const & other ) const\n  { return enabled == other.enabled &&\n           type == other.type &&\n           name == other.name &&\n           commandLine == other.commandLine &&\n           iconFilename == other.iconFilename;\n  }\n\n  bool operator != ( Program const & other ) const\n  { return ! operator == ( other ); }\n};\n\ntypedef QVector< Program > Programs;\n\nstruct VoiceEngine\n{\n  bool enabled;\n  QString id;\n  QString name;\n  QString iconFilename;\n  int volume; // 0-100 allowed\n  int rate;   // 0-100 allowed\n\n  VoiceEngine(): enabled( false )\n    , volume( 50 )\n    , rate( 50 )\n  {}\n  VoiceEngine( QString id_, QString name_, int volume_, int rate_ ):\n    enabled( false )\n    , id( id_ )\n    , name( name_ )\n    , volume( volume_ )\n    , rate( rate_ )\n  {}\n\n  bool operator == ( VoiceEngine const & other ) const\n  {\n    return enabled == other.enabled &&\n           id == other.id &&\n           name == other.name &&\n           iconFilename == other.iconFilename &&\n           volume == other.volume &&\n           rate == other.rate;\n  }\n\n  bool operator != ( VoiceEngine const & other ) const\n    { return ! operator == ( other ); }\n};\n\ntypedef QVector< VoiceEngine> VoiceEngines;\n\nstruct HeadwordsDialog\n{\n  int searchMode;\n  bool matchCase;\n  bool autoApply;\n  QString headwordsExportPath;\n  QByteArray headwordsDialogGeometry;\n\n  HeadwordsDialog() :\n    searchMode( 0 ), matchCase( false )\n    , autoApply( false )\n  {}\n};\n\nstruct Class\n{\n  Paths paths;\n  SoundDirs soundDirs;\n  Group dictionaryOrder;\n  Group inactiveDictionaries;\n  Groups groups;\n  Preferences preferences;\n  MediaWikis mediawikis;\n  WebSites webSites;\n  DictServers dictServers;\n  Hunspell hunspell;\n  Transliteration transliteration;\n  Forvo forvo;\n  Programs programs;\n  VoiceEngines voiceEngines;\n\n  unsigned lastMainGroupId; // Last used group in main window\n  unsigned lastPopupGroupId; // Last used group in popup window\n\n  QByteArray popupWindowState; // Binary state saved by QMainWindow\n  QByteArray popupWindowGeometry; // Geometry saved by QMainWindow\n  QByteArray dictInfoGeometry; // Geometry of \"Dictionary info\" window\n  QByteArray inspectorGeometry; // Geometry of WebKit inspector window\n  QByteArray dictionariesDialogGeometry; // Geometry of Dictionaries dialog\n  QByteArray printPreviewDialogGeometry; // Geometry of Print Preview dialog\n  QByteArray helpWindowGeometry; // Geometry of help window\n  QByteArray helpSplitterState; // Geometry of help splitter\n\n  QString historyExportPath; // Path for export/import history\n  QString resourceSavePath;  // Path to save images/audio\n  QString articleSavePath;   // Path to save articles\n\n  bool pinPopupWindow; // Last pin status\n  bool popupWindowAlwaysOnTop; // Last status of pinned popup window\n\n  QByteArray mainWindowState; // Binary state saved by QMainWindow\n  QByteArray mainWindowGeometry; // Geometry saved by QMainWindow\n\n  MutedDictionaries mutedDictionaries; // Disabled via dictionary bar\n  MutedDictionaries popupMutedDictionaries; // Disabled via dictionary bar in popup\n\n  QDateTime timeForNewReleaseCheck; // Only effective if\n                                    // preferences.checkForNewReleases is set\n  QString skippedRelease; // Empty by default\n\n  bool showingDictBarNames;\n\n  bool usingSmallIconsInToolbars;\n\n  int maxPictureWidth; // Maximum picture width\n\n  /// Maximum size for the headwords.\n  /// Bigger headwords won't be indexed. For now, only in DSL.\n  unsigned int maxHeadwordSize;\n\n  unsigned int maxHeadwordsToExpand;\n\n  HeadwordsDialog headwordsDialog;\n\n#ifdef Q_OS_WIN\n  QRect maximizedMainWindowGeometry;\n  QRect normalMainWindowGeometry;\n#endif\n\n  QString editDictionaryCommandLine; // Command line to call external editor for dictionary\n\n  Class(): lastMainGroupId( 0 ), lastPopupGroupId( 0 ),\n           pinPopupWindow( false ), showingDictBarNames( false ),\n           usingSmallIconsInToolbars( false ),\n           maxPictureWidth( 0 ), maxHeadwordSize ( 256U ),\n           maxHeadwordsToExpand( 0 )\n  {}\n  Group * getGroup( unsigned id );\n  Group const * getGroup( unsigned id ) const;\n};\n\n#ifdef Q_OS_WIN\n#pragma pack(pop)\n#endif\n\n/// Configuration-specific events. Some parts of the program need to react\n/// to specific changes in configuration. The object of this class is used\n/// to emit signals when such events happen -- and the listeners connect to\n/// them to be notified of them.\n/// This class is separate from the main Class since QObjects can't be copied.\nclass Events: public QObject\n{\n  Q_OBJECT\n\npublic:\n\n  /// Signals that the value of the mutedDictionaries has changed.\n  /// This emits mutedDictionariesChanged() signal, so the subscribers will\n  /// be notified.\n  void signalMutedDictionariesChanged();\n\nsignals:\n\n  /// THe value of the mutedDictionaries has changed.\n  void mutedDictionariesChanged();\n\nprivate:\n};\n\nDEF_EX( exError, \"Error with the program's configuration\", std::exception )\nDEF_EX( exCantUseDataDir, \"Can't use XDG_DATA_HOME directory to store GoldenDict data\", exError )\nDEF_EX( exCantUseHomeDir, \"Can't use home directory to store GoldenDict preferences\", exError )\nDEF_EX( exCantUseIndexDir, \"Can't use index directory to store GoldenDict index files\", exError )\nDEF_EX( exCantReadConfigFile, \"Can't read the configuration file\", exError )\nDEF_EX( exCantWriteConfigFile, \"Can't write the configuration file\", exError )\nDEF_EX( exMalformedConfigFile, \"The configuration file is malformed\", exError )\n\n/// Loads the configuration, or creates the default one if none is present\nClass load() THROW_SPEC( exError );\n\n/// Saves the configuration\nvoid save( Class const & ) THROW_SPEC( exError );\n\n/// Returns the configuration file name.\nQString getConfigFileName();\n\n/// Returns the main configuration directory.\nQString getConfigDir() THROW_SPEC( exError );\n\n/// Returns the index directory, where the indices are to be stored.\nQString getIndexDir() THROW_SPEC( exError );\n\n/// Returns the filename of a .pid file which should store current pid of\n/// the process.\nQString getPidFileName() THROW_SPEC( exError );\n\n/// Returns the filename of a history file which stores search history.\nQString getHistoryFileName() THROW_SPEC( exError );\n\n/// Returns the filename of a favorities file.\nQString getFavoritiesFileName() THROW_SPEC( exError );\n\n/// Returns the user .css file name.\nQString getUserCssFileName() THROW_SPEC( exError );\n\n/// Returns the user .css file name used for printing only.\nQString getUserCssPrintFileName() THROW_SPEC( exError );\n\n/// Returns the user .css file name for the Qt interface customization.\nQString getUserQtCssFileName() THROW_SPEC( exError );\n\n/// Returns the program's data dir. Under Linux that would be something like\n/// /usr/share/apps/goldendict, under Windows C:/Program Files/GoldenDict.\nQString getProgramDataDir() throw();\n\n/// Returns the directory storing program localizized files (.qm).\nQString getLocDir() throw();\n\n/// Returns the directory storing program help files (.qch).\nQString getHelpDir() throw();\n\n#ifdef MAKE_CHINESE_CONVERSION_SUPPORT\n/// Returns the directory storing OpenCC configuration and dictionary files (.json and .ocd).\nQString getOpenCCDir() throw();\n#endif\n\n/// Returns true if the program is configured as a portable version. In that\n/// mode, all the settings and indices are kept in the program's directory.\nbool isPortableVersion() throw();\n\n/// Returns directory with dictionaries for portable version. It is content/\n/// in the application's directory.\nQString getPortableVersionDictionaryDir() throw();\n\n/// Returns directory with morpgologies for portable version. It is\n/// content/morphology in the application's directory.\nQString getPortableVersionMorphoDir() throw();\n\n/// Returns the add-on styles directory.\nQString getStylesDir() throw();\n\n/// Returns the directory where user-specific non-essential (cached) data should be written.\nQString getCacheDir() throw();\n\n/// Returns the article network disk cache directory.\nQString getNetworkCacheDir() throw();\n\n}\n\nQ_DECLARE_METATYPE( Config::InputPhrase )\n\n#endif\n"
        },
        {
          "name": "configure",
          "type": "blob",
          "size": 0.3037109375,
          "content": "#!/bin/bash\n\necho\necho To build the program, run qmake, then make.\necho\necho The following dependency packages are required: libvorbis-dev, zlib1g-dev, libhunspell-dev, x11proto-record-dev, qt4-qmake, libqt4-dev, g++, libxtst-dev, libphonon-dev. They can be named slightly different in different distributions.\n"
        },
        {
          "name": "country.cc",
          "type": "blob",
          "size": 10.6669921875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"country.hh\"\n#include \"folding.hh\"\n#include <QtCore>\n#include \"wstring_qt.hh\"\n\nnamespace Country {\n\nnamespace\n{\n  struct Database: public QMap< QString, QString >\n  {\n    static Database const & instance()\n    { static Database db; return db; }\n\n  private:\n\n    Database();\n\n    void addCountry( QString const & country, QString const & code )\n    {\n      (*this)[ gd::toQString( Folding::apply( gd::toWString( country ) ) ) ] = code.toLower();\n    }\n  };\n\n  Database::Database()\n  {\n    addCountry( \"Afghanistan\", \"AF\" );\n    addCountry( \"Aland Islands\", \"AX\" );\n    addCountry( \"Albania\", \"AL\" );\n    addCountry( \"Algeria\", \"DZ\" );\n    addCountry( \"American Samoa\", \"AS\" );\n    addCountry( \"Andorra\", \"AD\" );\n    addCountry( \"Angola\", \"AO\" );\n    addCountry( \"Anguilla\", \"AI\" );\n    addCountry( \"Antarctica\", \"AQ\" );\n    addCountry( \"Antigua and Barbuda\", \"AG\" );\n    addCountry( \"Argentina\", \"AR\" );\n    addCountry( \"Armenia\", \"AM\" );\n    addCountry( \"Aruba\", \"AW\" );\n    addCountry( \"Australia\", \"AU\" );\n    addCountry( \"Austria\", \"AT\" );\n    addCountry( \"Azerbaijan\", \"AZ\" );\n    addCountry( \"Bahamas\", \"BS\" );\n    addCountry( \"Bahrain\", \"BH\" );\n    addCountry( \"Bangladesh\", \"BD\" );\n    addCountry( \"Barbados\", \"BB\" );\n    addCountry( \"Belarus\", \"BY\" );\n    addCountry( \"Belgium\", \"BE\" );\n    addCountry( \"Belize\", \"BZ\" );\n    addCountry( \"Benin\", \"BJ\" );\n    addCountry( \"Bermuda\", \"BM\" );\n    addCountry( \"Bhutan\", \"BT\" );\n    addCountry( \"Bolivia, Plurinational State of\", \"BO\" );\n    addCountry( \"Bolivia\", \"BO\" );\n    addCountry( \"Bosnia and Herzegovina\", \"BA\" );\n    addCountry( \"Botswana\", \"BW\" );\n    addCountry( \"Bouvet Island\", \"BV\" );\n    addCountry( \"Brazil\", \"BR\" );\n    addCountry( \"British Indian Ocean Territory\", \"IO\" );\n    addCountry( \"Brunei Darussalam\", \"BN\" );\n    addCountry( \"Bulgaria\", \"BG\" );\n    addCountry( \"Burkina Faso\", \"BF\" );\n    addCountry( \"Burundi\", \"BI\" );\n    addCountry( \"Cambodia\", \"KH\" );\n    addCountry( \"Cameroon\", \"CM\" );\n    addCountry( \"Canada\", \"CA\" );\n    addCountry( \"Cape Verde\", \"CV\" );\n    addCountry( \"Cayman Islands\", \"KY\" );\n    addCountry( \"Central African Republic\", \"CF\" );\n    addCountry( \"Chad\", \"TD\" );\n    addCountry( \"Chile\", \"CL\" );\n    addCountry( \"China\", \"CN\" );\n    addCountry( \"Christmas Island\", \"CX\" );\n    addCountry( \"Cocos (Keeling) Islands\", \"CC\" );\n    addCountry( \"Colombia\", \"CO\" );\n    addCountry( \"Comoros\", \"KM\" );\n    addCountry( \"Congo\", \"CG\" );\n    addCountry( \"Congo, the Democratic Republic of the\", \"CD\" );\n    addCountry( \"Cook Islands\", \"CK\" );\n    addCountry( \"Costa Rica\", \"CR\" );\n    addCountry( \"Cote d'Ivoire\", \"CI\" );\n    addCountry( \"Croatia\", \"HR\" );\n    addCountry( \"Cuba\", \"CU\" );\n    addCountry( \"Cyprus\", \"CY\" );\n    addCountry( \"Czech Republic\", \"CZ\" );\n    addCountry( \"Denmark\", \"DK\" );\n    addCountry( \"Djibouti\", \"DJ\" );\n    addCountry( \"Dominica\", \"DM\" );\n    addCountry( \"Dominican Republic\", \"DO\" );\n    addCountry( \"Ecuador\", \"EC\" );\n    addCountry( \"Egypt\", \"EG\" );\n    addCountry( \"El Salvador\", \"SV\" );\n    addCountry( \"Equatorial Guinea\", \"GQ\" );\n    addCountry( \"Eritrea\", \"ER\" );\n    addCountry( \"Estonia\", \"EE\" );\n    addCountry( \"Ethiopia\", \"ET\" );\n    addCountry( \"Falkland Islands (Malvinas)\", \"FK\" );\n    addCountry( \"Faroe Islands\", \"FO\" );\n    addCountry( \"Fiji\", \"FJ\" );\n    addCountry( \"Finland\", \"FI\" );\n    addCountry( \"France\", \"FR\" );\n    addCountry( \"French Guiana\", \"GF\" );\n    addCountry( \"French Polynesia\", \"PF\" );\n    addCountry( \"French Southern Territories\", \"TF\" );\n    addCountry( \"Gabon\", \"GA\" );\n    addCountry( \"Gambia\", \"GM\" );\n    addCountry( \"Georgia\", \"GE\" );\n    addCountry( \"Germany\", \"DE\" );\n    addCountry( \"Ghana\", \"GH\" );\n    addCountry( \"Gibraltar\", \"GI\" );\n    addCountry( \"Greece\", \"GR\" );\n    addCountry( \"Greenland\", \"GL\" );\n    addCountry( \"Grenada\", \"GD\" );\n    addCountry( \"Guadeloupe\", \"GP\" );\n    addCountry( \"Guam\", \"GU\" );\n    addCountry( \"Guatemala\", \"GT\" );\n    addCountry( \"Guernsey\", \"GG\" );\n    addCountry( \"Guinea\", \"GN\" );\n    addCountry( \"Guinea-Bissau\", \"GW\" );\n    addCountry( \"Guyana\", \"GY\" );\n    addCountry( \"Haiti\", \"HT\" );\n    addCountry( \"Heard Island and McDonald Islands\", \"HM\" );\n    addCountry( \"Holy See (Vatican City State)\", \"VA\" );\n    addCountry( \"Honduras\", \"HN\" );\n    addCountry( \"Hong Kong\", \"HK\" );\n    addCountry( \"Hungary\", \"HU\" );\n    addCountry( \"Iceland\", \"IS\" );\n    addCountry( \"India\", \"IN\" );\n    addCountry( \"Indonesia\", \"ID\" );\n    addCountry( \"Iran, Islamic Republic of\", \"IR\" );\n    addCountry( \"Iran\", \"IR\" );\n    addCountry( \"Iraq\", \"IQ\" );\n    addCountry( \"Ireland\", \"IE\" );\n    addCountry( \"Isle of Man\", \"IM\" );\n    addCountry( \"Israel\", \"IL\" );\n    addCountry( \"Italy\", \"IT\" );\n    addCountry( \"Jamaica\", \"JM\" );\n    addCountry( \"Japan\", \"JP\" );\n    addCountry( \"Jersey\", \"JE\" );\n    addCountry( \"Jordan\", \"JO\" );\n    addCountry( \"Kazakhstan\", \"KZ\" );\n    addCountry( \"Kenya\", \"KE\" );\n    addCountry( \"Kiribati\", \"KI\" );\n    addCountry( \"Korea, Democratic People's Republic of\", \"KP\" );\n    addCountry( \"Korea, Republic of\", \"KR\" );\n    addCountry( \"Korea\", \"KR\" );\n    addCountry( \"Kuwait\", \"KW\" );\n    addCountry( \"Kyrgyzstan\", \"KG\" );\n    addCountry( \"Lao People's Democratic Republic\", \"LA\" );\n    addCountry( \"Latvia\", \"LV\" );\n    addCountry( \"Lebanon\", \"LB\" );\n    addCountry( \"Lesotho\", \"LS\" );\n    addCountry( \"Liberia\", \"LR\" );\n    addCountry( \"Libyan Arab Jamahiriya\", \"LY\" );\n    addCountry( \"Liechtenstein\", \"LI\" );\n    addCountry( \"Lithuania\", \"LT\" );\n    addCountry( \"Luxembourg\", \"LU\" );\n    addCountry( \"Macao\", \"MO\" );\n    addCountry( \"Macedonia, the former Yugoslav Republic of\", \"MK\" );\n    addCountry( \"Macedonia\", \"MK\" );\n    addCountry( \"Madagascar\", \"MG\" );\n    addCountry( \"Malawi\", \"MW\" );\n    addCountry( \"Malaysia\", \"MY\" );\n    addCountry( \"Maldives\", \"MV\" );\n    addCountry( \"Mali\", \"ML\" );\n    addCountry( \"Malta\", \"MT\" );\n    addCountry( \"Marshall Islands\", \"MH\" );\n    addCountry( \"Martinique\", \"MQ\" );\n    addCountry( \"Mauritania\", \"MR\" );\n    addCountry( \"Mauritius\", \"MU\" );\n    addCountry( \"Mayotte\", \"YT\" );\n    addCountry( \"Mexico\", \"MX\" );\n    addCountry( \"Micronesia, Federated States of\", \"FM\" );\n    addCountry( \"Micronesia\", \"FM\" );\n    addCountry( \"Moldova, Republic of\", \"MD\" );\n    addCountry( \"Moldova\", \"MD\" );\n    addCountry( \"Monaco\", \"MC\" );\n    addCountry( \"Mongolia\", \"MN\" );\n    addCountry( \"Montenegro\", \"ME\" );\n    addCountry( \"Montserrat\", \"MS\" );\n    addCountry( \"Morocco\", \"MA\" );\n    addCountry( \"Mozambique\", \"MZ\" );\n    addCountry( \"Myanmar\", \"MM\" );\n    addCountry( \"Namibia\", \"NA\" );\n    addCountry( \"Nauru\", \"NR\" );\n    addCountry( \"Nepal\", \"NP\" );\n    addCountry( \"Netherlands\", \"NL\" );\n    addCountry( \"Netherlands Antilles\", \"AN\" );\n    addCountry( \"New Caledonia\", \"NC\" );\n    addCountry( \"New Zealand\", \"NZ\" );\n    addCountry( \"Nicaragua\", \"NI\" );\n    addCountry( \"Niger\", \"NE\" );\n    addCountry( \"Nigeria\", \"NG\" );\n    addCountry( \"Niue\", \"NU\" );\n    addCountry( \"Norfolk Island\", \"NF\" );\n    addCountry( \"Northern Mariana Islands\", \"MP\" );\n    addCountry( \"Norway\", \"NO\" );\n    addCountry( \"Oman\", \"OM\" );\n    addCountry( \"Pakistan\", \"PK\" );\n    addCountry( \"Palau\", \"PW\" );\n    addCountry( \"Palestinian Territory, Occupied\", \"PS\" );\n    addCountry( \"Panama\", \"PA\" );\n    addCountry( \"Papua New Guinea\", \"PG\" );\n    addCountry( \"Paraguay\", \"PY\" );\n    addCountry( \"Peru\", \"PE\" );\n    addCountry( \"Philippines\", \"PH\" );\n    addCountry( \"Pitcairn\", \"PN\" );\n    addCountry( \"Poland\", \"PL\" );\n    addCountry( \"Portugal\", \"PT\" );\n    addCountry( \"Puerto Rico\", \"PR\" );\n    addCountry( \"Qatar\", \"QA\" );\n    addCountry( \"Reunion\", \"RE\" );\n    addCountry( \"Romania\", \"RO\" );\n    addCountry( \"Russian Federation\", \"RU\" );\n    addCountry( \"Russia\", \"RU\" );\n    addCountry( \"Rwanda\", \"RW\" );\n    addCountry( \"Saint Barthélemy\", \"BL\" );\n    addCountry( \"Saint Helena, Ascension and Tristan da Cunha\", \"SH\" );\n    addCountry( \"Saint Kitts and Nevis\", \"KN\" );\n    addCountry( \"Saint Lucia\", \"LC\" );\n    addCountry( \"Saint Martin (French part)\", \"MF\" );\n    addCountry( \"Saint Pierre and Miquelon\", \"PM\" );\n    addCountry( \"Saint Vincent and the Grenadines\", \"VC\" );\n    addCountry( \"Samoa\", \"WS\" );\n    addCountry( \"San Marino\", \"SM\" );\n    addCountry( \"Sao Tome and Principe\", \"ST\" );\n    addCountry( \"Saudi Arabia\", \"SA\" );\n    addCountry( \"Senegal\", \"SN\" );\n    addCountry( \"Serbia\", \"RS\" );\n    addCountry( \"Seychelles\", \"SC\" );\n    addCountry( \"Sierra Leone\", \"SL\" );\n    addCountry( \"Singapore\", \"SG\" );\n    addCountry( \"Slovakia\", \"SK\" );\n    addCountry( \"Slovenia\", \"SI\" );\n    addCountry( \"Solomon Islands\", \"SB\" );\n    addCountry( \"Somalia\", \"SO\" );\n    addCountry( \"South Africa\", \"ZA\" );\n    addCountry( \"South Georgia and the South Sandwich Islands\", \"GS\" );\n    addCountry( \"Spain\", \"ES\" );\n    addCountry( \"Sri Lanka\", \"LK\" );\n    addCountry( \"Sudan\", \"SD\" );\n    addCountry( \"Suriname\", \"SR\" );\n    addCountry( \"Svalbard and Jan Mayen\", \"SJ\" );\n    addCountry( \"Swaziland\", \"SZ\" );\n    addCountry( \"Sweden\", \"SE\" );\n    addCountry( \"Switzerland\", \"CH\" );\n    addCountry( \"Syrian Arab Republic\", \"SY\" );\n    addCountry( \"Taiwan, Province of China\", \"TW\" );\n    addCountry( \"Tajikistan\", \"TJ\" );\n    addCountry( \"Tanzania, United Republic of\", \"TZ\" );\n    addCountry( \"Tanzania\", \"TZ\" );\n    addCountry( \"Thailand\", \"TH\" );\n    addCountry( \"Timor-Leste\", \"TL\" );\n    addCountry( \"Togo\", \"TG\" );\n    addCountry( \"Tokelau\", \"TK\" );\n    addCountry( \"Tonga\", \"TO\" );\n    addCountry( \"Trinidad and Tobago\", \"TT\" );\n    addCountry( \"Tunisia\", \"TN\" );\n    addCountry( \"Turkey\", \"TR\" );\n    addCountry( \"Turkmenistan\", \"TM\" );\n    addCountry( \"Turks and Caicos Islands\", \"TC\" );\n    addCountry( \"Tuvalu\", \"TV\" );\n    addCountry( \"Uganda\", \"UG\" );\n    addCountry( \"Ukraine\", \"UA\" );\n    addCountry( \"United Arab Emirates\", \"AE\" );\n    addCountry( \"United Kingdom\", \"GB\" );\n    addCountry( \"United States\", \"US\" );\n    addCountry( \"United States Minor Outlying Islands\", \"UM\" );\n    addCountry( \"Uruguay\", \"UY\" );\n    addCountry( \"Uzbekistan\", \"UZ\" );\n    addCountry( \"Vanuatu\", \"VU\" );\n    addCountry( \"Venezuela, Bolivarian Republic of\", \"VE\" );\n    addCountry( \"Venezuela\", \"VE\" );\n    addCountry( \"Viet Nam\", \"VN\" );\n    addCountry( \"Virgin Islands, British\", \"VG\" );\n    addCountry( \"Virgin Islands, U.S.\", \"VI\" );\n    addCountry( \"Wallis and Futuna\", \"WF\" );\n    addCountry( \"Western Sahara\", \"EH\" );\n    addCountry( \"Yemen\", \"YE\" );\n    addCountry( \"Zambia\", \"ZM\" );\n    addCountry( \"Zimbabwe\", \"ZW\" );\n  }\n}\n\nQString englishNametoIso2( QString const & name )\n{\n  Database::const_iterator i = Database::instance().find( gd::toQString( Folding::apply( gd::toWString( name ) ) ) );\n\n  if ( i == Database::instance().end() )\n    return QString();\n  else\n    return i.value();\n}\n\n}\n"
        },
        {
          "name": "country.hh",
          "type": "blob",
          "size": 0.27734375,
          "content": "#ifndef COUNTRY_HH\n#define COUNTRY_HH\n\n#include <QString>\n\nnamespace Country {\n\n/// Attempts converting the given country name, in english, to its iso-3166-1\n/// 2-letter code. If fails, empty string is returned.\nQString englishNametoIso2( QString const & );\n\n}\n\n#endif // COUNTRY_HH\n"
        },
        {
          "name": "cpp_features.hh",
          "type": "blob",
          "size": 0.1767578125,
          "content": "#ifndef __CPP_HH_INCLUDED__\n#define __CPP_HH_INCLUDED__\n\n#if __cplusplus > 199711L\n#define THROW_SPEC(...)\n#else\n#define THROW_SPEC(...) throw(__VA_ARGS__)\n#endif\n\n#endif // CPP_HH\n"
        },
        {
          "name": "decompress.cc",
          "type": "blob",
          "size": 3.8251953125,
          "content": "#include \"decompress.hh\"\n#include \"zlib.h\"\n#include \"bzlib.h\"\n\n#ifdef MAKE_ZIM_SUPPORT\n#include \"lzma.h\"\n#include \"zstd.h\"\n#endif\n\n#define CHUNK_SIZE 2048\n\nQByteArray zlibDecompress( const char * bufptr, unsigned length )\n{\nz_stream zs;\nchar buf[CHUNK_SIZE];\nQByteArray str;\nint res;\n    memset( &zs, 0, sizeof(zs) );\n    zs.next_in = (Bytef *)bufptr;\n    zs.avail_in = length;\n    while( 1 )\n    {\n        res = inflateInit( &zs );\n        if( res != Z_OK )\n            break;\n        while( res != Z_STREAM_END )\n        {\n            zs.next_out = (Bytef *)buf;\n            zs.avail_out = CHUNK_SIZE;\n            res = inflate( &zs, Z_SYNC_FLUSH );\n            str.append( buf, CHUNK_SIZE - zs.avail_out );\n            if( res != Z_OK && res != Z_STREAM_END )\n                 break;\n        }\n        break;\n    }\n    inflateEnd( &zs );\n    if( res != Z_STREAM_END )\n        str.clear();\n    return str;\n}\n\nstring decompressZlib( const char * bufptr, unsigned length )\n{\n  QByteArray b = zlibDecompress( bufptr, length );\n  return string( b.constData(), b.size() );\n}\n\nstring decompressBzip2( const char * bufptr, unsigned length )\n{\nbz_stream zs;\nchar buf[CHUNK_SIZE];\nstring str;\nint res;\n    memset( &zs, 0, sizeof(zs) );\n    zs.next_in = (char *)bufptr;\n    zs.avail_in = length;\n    zs.total_in_lo32 = length;\n    while( 1 )\n    {\n        res = BZ2_bzDecompressInit( &zs, 0, 0 );\n        if( res != BZ_OK )\n            break;\n        while( res != BZ_STREAM_END )\n        {\n            zs.next_out = buf;\n            zs.avail_out = CHUNK_SIZE;\n            zs.total_out_lo32 = length;\n            res = BZ2_bzDecompress( &zs );\n            str.append( buf, CHUNK_SIZE - zs.avail_out );\n            if( res != BZ_OK && res != BZ_STREAM_END )\n                break;\n        }\n        break;\n    }\n    BZ2_bzDecompressEnd( &zs );\n    if( res != BZ_STREAM_END )\n        str.clear();\n    return str;\n}\n\n#ifdef MAKE_ZIM_SUPPORT\n\nstring decompressLzma2( const char * bufptr, unsigned length,\n                        bool raw_decoder )\n{\nstring str;\nlzma_ret res;\nchar buf[CHUNK_SIZE];\n\n  lzma_stream strm = LZMA_STREAM_INIT;\n  strm.next_in = reinterpret_cast< const uint8_t * >( bufptr );\n  strm.avail_in = length;\n\n  lzma_options_lzma opt;\n  lzma_filter filters[ 2 ];\n\n  if( raw_decoder )\n  {\n    lzma_lzma_preset(&opt, LZMA_PRESET_DEFAULT);\n\n    filters[ 0 ].id = LZMA_FILTER_LZMA2;\n    filters[ 0 ].options = &opt;\n    filters[ 1 ].id = LZMA_VLI_UNKNOWN;\n  }\n\n  while( 1 )\n  {\n    if( raw_decoder )\n      res = lzma_raw_decoder( &strm, filters );\n    else\n      res = lzma_stream_decoder( &strm, UINT64_MAX, 0 );\n\n    if( res != LZMA_OK )\n      break;\n\n    while ( res != LZMA_STREAM_END )\n    {\n      strm.next_out = reinterpret_cast< uint8_t * >( buf );\n      strm.avail_out = CHUNK_SIZE;\n      res = lzma_code( &strm, LZMA_RUN );\n      str.append( buf, CHUNK_SIZE - strm.avail_out );\n      if( res != LZMA_OK && res != LZMA_STREAM_END )\n        break;\n    }\n    lzma_end( &strm );\n    if( res != LZMA_STREAM_END )\n      str.clear();\n\n    break;\n  }\n  return str;\n}\n\nstring decompressZstd( const char *bufptr, unsigned length )\n{\n  string str;\n  char buf[CHUNK_SIZE];\n  size_t res;\n//  string err;\n  ZSTD_DStream *zds;\n  ZSTD_inBuffer in_buf = { bufptr, length, 0 };\n  ZSTD_outBuffer out_buf = { buf, CHUNK_SIZE, 0 };\n\n  zds = ZSTD_createDStream();\n  if( !zds )\n    return str;\n\n  res = ZSTD_initDStream( zds );\n  if( ZSTD_isError( res ) )\n  {\n//    err = string( ZSTD_getErrorName( res ) );\n    ZSTD_freeDStream( zds );\n    return str;\n  }\n\n  do\n  {\n    out_buf.pos = 0;\n    res = ZSTD_decompressStream( zds, &out_buf, &in_buf );\n    if( ZSTD_isError( res ) )\n    {\n//      err = string( ZSTD_getErrorName( res ) );\n      ZSTD_freeDStream( zds );\n      return string();\n    }\n\n    str.append( buf, out_buf.pos );\n  }\n  while( out_buf.pos >= out_buf.size );\n\n  ZSTD_freeDStream( zds );\n\n  return str;\n}\n\n#endif\n"
        },
        {
          "name": "decompress.hh",
          "type": "blob",
          "size": 0.5517578125,
          "content": "#ifndef __DECOMPRESS_HH_INCLUDED__\n#define __DECOMPRESS_HH_INCLUDED__\n\n#include <QByteArray>\n#include <string>\n\nusing std::string;\n\nQByteArray zlibDecompress( const char * bufptr, unsigned length );\n\nstring decompressZlib( const char * bufptr, unsigned length );\n\nstring decompressBzip2( const char * bufptr, unsigned length );\n\n#ifdef MAKE_ZIM_SUPPORT\n\nstring decompressLzma2( const char * bufptr, unsigned length,\n                        bool raw_decoder = false );\n\nstring decompressZstd( const char * bufptr, unsigned length );\n\n#endif\n\n#endif // DECOMPRESS_HH\n"
        },
        {
          "name": "delegate.cc",
          "type": "blob",
          "size": 0.8994140625,
          "content": "#include <QStyleOptionViewItemV4>\n\n#include \"delegate.hh\"\n\nWordListItemDelegate::WordListItemDelegate(  QAbstractItemDelegate * delegate  ) :\nQStyledItemDelegate()\n{\n  mainDelegate = static_cast< QStyledItemDelegate * >( delegate );\n}\n\nvoid WordListItemDelegate::paint( QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index ) const\n{\n#if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)\n  QStyleOptionViewItem opt4 = option;\n#else\n  QStyleOptionViewItemV4 opt4 = option;\n#endif\n  QStyleOptionViewItem opt = option;\n  initStyleOption( &opt4, index );\n  if( opt4.text.isRightToLeft() )\n  {\n    opt.direction = Qt::RightToLeft;\n    if( opt4.textElideMode != Qt::ElideNone )\n      opt.textElideMode = Qt::ElideLeft;\n  }\n  else\n  {\n    opt.direction = Qt::LeftToRight;\n    if( opt4.textElideMode != Qt::ElideNone )\n      opt.textElideMode = Qt::ElideRight;\n  }\n  mainDelegate->paint( painter, opt, index );\n}\n"
        },
        {
          "name": "delegate.hh",
          "type": "blob",
          "size": 0.421875,
          "content": "#ifndef __DELEGATE_HH_INCLUDED__\n#define __DELEGATE_HH_INCLUDED__\n\n#include <QAbstractItemDelegate>\n#include <QStyledItemDelegate>\n\nclass WordListItemDelegate : public QStyledItemDelegate\n{\npublic:\n  WordListItemDelegate( QAbstractItemDelegate * delegate );\n  virtual void paint( QPainter * painter, const QStyleOptionViewItem & option, const QModelIndex & index ) const;\n\nprivate:\n  QStyledItemDelegate * mainDelegate;\n};\n\n#endif\n\n"
        },
        {
          "name": "dictdfiles.cc",
          "type": "blob",
          "size": 25.6064453125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"dictdfiles.hh\"\n#include \"btreeidx.hh\"\n#include \"folding.hh\"\n#include \"utf8.hh\"\n#include \"dictzip.h\"\n#include \"htmlescape.hh\"\n#include \"fsencoding.hh\"\n#include \"langcoder.hh\"\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\n#include <list>\n#include <wctype.h>\n#include <stdlib.h>\n#include \"gddebug.hh\"\n#include \"ftshelpers.hh\"\n#include <QUrl>\n\n#include <QDebug>\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n#include <QRegularExpression>\n#endif\n\n#ifdef _MSC_VER\n#include <stub_msvc.h>\n#endif\n\nnamespace DictdFiles {\n\nusing std::map;\nusing std::multimap;\nusing std::pair;\nusing std::set;\nusing std::string;\nusing gd::wstring;\nusing std::vector;\nusing std::list;\n\nusing BtreeIndexing::WordArticleLink;\nusing BtreeIndexing::IndexedWords;\nusing BtreeIndexing::IndexInfo;\n\nnamespace {\n\nDEF_EX_STR( exCantReadFile, \"Can't read file\", Dictionary::Ex )\nDEF_EX( exFailedToReadLineFromIndex, \"Failed to read line from index file\", Dictionary::Ex )\nDEF_EX( exMalformedIndexFileLine, \"Malformed index file line encountered\", Dictionary::Ex )\nDEF_EX( exInvalidBase64, \"Invalid base64 sequence encountered\", Dictionary::Ex )\nDEF_EX_STR( exDictzipError, \"DICTZIP error\", Dictionary::Ex )\n\nenum\n{\n  Signature = 0x58444344, // DCDX on little-endian, XDCD on big-endian\n  CurrentFormatVersion = 5 + BtreeIndexing::FormatVersion + Folding::Version\n};\n\nstruct IdxHeader\n{\n  uint32_t signature; // First comes the signature, DCDX\n  uint32_t formatVersion; // File format version (CurrentFormatVersion)\n  uint32_t wordCount; // Total number of words\n  uint32_t articleCount; // Total number of articles\n  uint32_t indexBtreeMaxElements; // Two fields from IndexInfo\n  uint32_t indexRootOffset;\n  uint32_t langFrom;  // Source language\n  uint32_t langTo;    // Target language\n}\n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\nbool indexIsOldOrBad( string const & indexFile )\n{\n  File::Class idx( indexFile, \"rb\" );\n\n  IdxHeader header;\n\n  return idx.readRecords( &header, sizeof( header ), 1 ) != 1 ||\n         header.signature != Signature ||\n         header.formatVersion != CurrentFormatVersion;\n}\n\nclass DictdDictionary: public BtreeIndexing::BtreeDictionary\n{\n  Mutex idxMutex;\n  File::Class idx, indexFile; // The later is .index file\n  IdxHeader idxHeader;\n  dictData * dz;\n  string dictionaryName;\n  Mutex indexFileMutex, dzMutex;\n\npublic:\n\n  DictdDictionary( string const & id, string const & indexFile,\n                   vector< string > const & dictionaryFiles );\n\n  ~DictdDictionary();\n\n  virtual string getName() throw()\n  { return dictionaryName; }\n\n  virtual map< Dictionary::Property, string > getProperties() throw()\n  { return map< Dictionary::Property, string >(); }\n\n  virtual unsigned long getArticleCount() throw()\n  { return idxHeader.articleCount; }\n\n  virtual unsigned long getWordCount() throw()\n  { return idxHeader.wordCount; }\n\n  virtual void loadIcon() throw();\n\n  inline virtual quint32 getLangFrom() const\n  { return idxHeader.langFrom; }\n\n  inline virtual quint32 getLangTo() const\n  { return idxHeader.langTo; }\n\n  virtual sptr< Dictionary::DataRequest > getArticle( wstring const &,\n                                                      vector< wstring > const & alts,\n                                                      wstring const &,\n                                                      bool ignoreDiacritics )\n    THROW_SPEC( std::exception );\n\n  virtual QString const& getDescription();\n\n  virtual sptr< Dictionary::DataRequest > getSearchResults( QString const & searchString,\n                                                            int searchMode, bool matchCase,\n                                                            int distanceBetweenWords,\n                                                            int maxResults,\n                                                            bool ignoreWordsOrder,\n                                                            bool ignoreDiacritics,\n                                                            QThreadPool * ftsThreadPoolPtr );\n  void getArticleText( uint32_t articleAddress, QString & headword, QString & text );\n\n  virtual void makeFTSIndex(QAtomicInt & isCancelled, bool firstIteration );\n\n  virtual void setFTSParameters( Config::FullTextSearch const & fts )\n  {\n    can_FTS = fts.enabled\n              && !fts.disabledTypes.contains( \"DICTD\", Qt::CaseInsensitive )\n              && ( fts.maxDictionarySize == 0 || getArticleCount() <= fts.maxDictionarySize );\n  }\n};\n\nDictdDictionary::DictdDictionary( string const & id,\n                                  string const & indexFile,\n                                  vector< string > const & dictionaryFiles ):\n  BtreeDictionary( id, dictionaryFiles ),\n  idx( indexFile, \"rb\" ),\n  indexFile( dictionaryFiles[ 0 ], \"rb\" ),\n  idxHeader( idx.read< IdxHeader >() )\n{\n\n  // Read the dictionary name\n  idx.seek( sizeof( idxHeader ) );\n\n  vector< char > dName( idx.read< uint32_t >() );\n  if( dName.size() > 0 )\n  {\n    idx.read( &dName.front(), dName.size() );\n    dictionaryName = string( &dName.front(), dName.size() );\n  }\n\n  // Open the .dict file\n\n  DZ_ERRORS error;\n  dz = dict_data_open( dictionaryFiles[ 1 ].c_str(), &error, 0 );\n\n  if ( !dz )\n    throw exDictzipError( string( dz_error_str( error ) )\n                          + \"(\" + getDictionaryFilenames()[ 1 ] + \")\" );\n\n  // Initialize the index\n\n  openIndex( IndexInfo( idxHeader.indexBtreeMaxElements,\n                        idxHeader.indexRootOffset ),\n             idx, idxMutex );\n\n  // Full-text search parameters\n\n  can_FTS = true;\n\n  ftsIdxName = indexFile + \"_FTS\";\n\n  if( !Dictionary::needToRebuildIndex( dictionaryFiles, ftsIdxName )\n      && !FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) )\n    FTS_index_completed.ref();\n}\n\nDictdDictionary::~DictdDictionary()\n{\n  if ( dz )\n    dict_data_close( dz );\n}\n\nstring nameFromFileName( string const & indexFileName )\n{\n  if ( indexFileName.empty() )\n    return string();\n\n  char const * sep = strrchr( indexFileName.c_str(), FsEncoding::separator() );\n\n  if ( !sep )\n    sep = indexFileName.c_str();\n\n  char const * dot = strrchr( sep, '.' );\n\n  if ( !dot )\n    dot = indexFileName.c_str() + indexFileName.size();\n\n  return Utf8::encode( FsEncoding::decode( string( sep + 1, dot - sep - 1 ) ) );\n}\n\nvoid DictdDictionary::loadIcon() throw()\n{\n  if ( dictionaryIconLoaded )\n    return;\n\n  QString fileName =\n    QDir::fromNativeSeparators( FsEncoding::decode( getDictionaryFilenames()[ 0 ].c_str() ) );\n\n  // Remove the extension\n  fileName.chop( 5 );\n\n  if( !loadIconFromFile( fileName ) )\n  {\n    // Load failed -- use default icons\n    dictionaryNativeIcon = dictionaryIcon = QIcon(\":/icons/icon32_dictd.png\");\n  }\n\n  dictionaryIconLoaded = true;\n}\n\nuint32_t decodeBase64( string const & str )\n{\n  static char const digits[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n  uint32_t number = 0;\n\n  for( char const * next = str.c_str(); *next; ++next )\n  {\n    char const * d = strchr( digits, *next );\n\n    if ( !d )\n      throw exInvalidBase64();\n\n    number = number * 64 + ( d - digits );\n  }\n\n  return number;\n}\n\nsptr< Dictionary::DataRequest > DictdDictionary::getArticle( wstring const & word,\n                                                             vector< wstring > const & alts,\n                                                             wstring const &,\n                                                             bool ignoreDiacritics )\n  THROW_SPEC( std::exception )\n{\n  try\n  {\n    vector< WordArticleLink > chain = findArticles( word, ignoreDiacritics );\n\n    for( unsigned x = 0; x < alts.size(); ++x )\n    {\n      /// Make an additional query for each alt\n\n      vector< WordArticleLink > altChain = findArticles( alts[ x ], ignoreDiacritics );\n\n      chain.insert( chain.end(), altChain.begin(), altChain.end() );\n    }\n\n    multimap< wstring, string > mainArticles, alternateArticles;\n\n    set< uint32_t > articlesIncluded; // Some synonyms make it that the articles\n                                      // appear several times. We combat this\n                                      // by only allowing them to appear once.\n\n    wstring wordCaseFolded = Folding::applySimpleCaseOnly( word );\n    if( ignoreDiacritics )\n      wordCaseFolded = Folding::applyDiacriticsOnly( wordCaseFolded );\n\n    char buf[ 16384 ];\n\n    for( unsigned x = 0; x < chain.size(); ++x )\n    {\n      if ( articlesIncluded.find( chain[ x ].articleOffset ) != articlesIncluded.end() )\n        continue; // We already have this article in the body.\n\n      // Now load that article\n\n      {\n        Mutex::Lock _( indexFileMutex );\n        indexFile.seek( chain[ x ].articleOffset );\n\n        if ( !indexFile.gets( buf, sizeof( buf ), true ) )\n          throw exFailedToReadLineFromIndex();\n      }\n\n      char * tab1 = strchr( buf, '\\t' );\n\n      if ( !tab1 )\n        throw exMalformedIndexFileLine();\n\n      char * tab2 = strchr( tab1 + 1, '\\t' );\n\n      if ( !tab2 )\n        throw exMalformedIndexFileLine();\n\n      // After tab1 should be article offset, after tab2 -- article size\n\n      uint32_t articleOffset = decodeBase64( string( tab1 + 1, tab2 - tab1 - 1 ) );\n\n      char * tab3 = strchr( tab2 + 1, '\\t');\n\n      uint32_t articleSize;\n      if ( tab3 )\n      {\n         articleSize = decodeBase64( string( tab2 + 1, tab3 - tab2 - 1 ) );\n      }\n      else\n      {\n        articleSize = decodeBase64( tab2 + 1 );\n      }\n\n      string articleText;\n\n      char * articleBody;\n      {\n        Mutex::Lock _( dzMutex );\n        articleBody = dict_data_read_( dz, articleOffset, articleSize, 0, 0 );\n      }\n\n      if ( !articleBody )\n      {\n        articleText = string( \"<div class=\\\"dictd_article\\\">DICTZIP error: \" )\n                      + dict_error_str( dz ) + \"</div>\";\n      }\n      else\n      {\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n        static QRegularExpression phonetic( \"\\\\\\\\([^\\\\\\\\]+)\\\\\\\\\",\n                                            QRegularExpression::CaseInsensitiveOption ); // phonetics: \\stuff\\ ...\n        static QRegularExpression refs( \"\\\\{([^\\\\{\\\\}]+)\\\\}\",\n                                        QRegularExpression::CaseInsensitiveOption );     // links: {stuff}\n        static QRegularExpression links( \"<a href=\\\"gdlookup://localhost/([^\\\"]*)\\\">\",\n                                         QRegularExpression::CaseInsensitiveOption );\n        static QRegularExpression tags( \"<[^>]*>\",\n                                        QRegularExpression::CaseInsensitiveOption );\n#else\n        static QRegExp phonetic( \"\\\\\\\\([^\\\\\\\\]+)\\\\\\\\\", Qt::CaseInsensitive ); // phonetics: \\stuff\\ ...\n        static QRegExp refs( \"\\\\{([^\\\\{\\\\}]+)\\\\}\", Qt::CaseInsensitive );     // links: {stuff}\n        static QRegExp links( \"<a href=\\\"gdlookup://localhost/([^\\\"]*)\\\">\", Qt::CaseInsensitive );\n        static QRegExp tags( \"<[^>]*>\", Qt::CaseInsensitive );\n#endif\n\n        articleText = string( \"<div class=\\\"dictd_article\\\"\" );\n        if( isToLanguageRTL() )\n          articleText += \" dir=\\\"rtl\\\"\";\n        articleText += \">\";\n\n        string convertedText = Html::preformat( articleBody, isToLanguageRTL() );\n        free( articleBody );\n\n        QString articleString = QString::fromUtf8( convertedText.c_str() )\n                                .replace(phonetic, \"<span class=\\\"dictd_phonetic\\\">\\\\1</span>\")\n                                .replace(refs, \"<a href=\\\"gdlookup://localhost/\\\\1\\\">\\\\1</a>\");\n        convertedText.erase();\n\n        int pos = 0;\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n        QString articleNewString;\n        QRegularExpressionMatchIterator it = links.globalMatch( articleString );\n        while( it.hasNext() )\n        {\n          QRegularExpressionMatch match = it.next();\n          articleNewString += articleString.midRef( pos, match.capturedStart() - pos );\n          pos = match.capturedEnd();\n\n          QString link = match.captured( 1 );\n          link.replace( tags, \" \" );\n          link.replace( \"&nbsp;\", \" \" );\n\n          QString newLink = match.captured();\n          newLink.replace( 30, match.capturedLength( 1 ),\n                           QString::fromUtf8( QUrl::toPercentEncoding( link.simplified() ) ) );\n          articleNewString += newLink;\n        }\n        if( pos )\n        {\n          articleNewString += articleString.midRef( pos );\n          articleString = articleNewString;\n          articleNewString.clear();\n        }\n#else\n        for( ; ; )\n        {\n          pos = articleString.indexOf( links, pos );\n          if( pos < 0 )\n            break;\n\n          QString link = links.cap( 1 );\n          link.replace( tags, \" \" );\n          link.replace( \"&nbsp;\", \" \" );\n          articleString.replace( pos + 30, links.cap( 1 ).length(),\n                                 QString::fromUtf8( QUrl::toPercentEncoding( link.simplified() ) ) );\n          pos += 30;\n        }\n#endif\n\n        articleString += \"</div>\";\n\n        articleText += articleString.toUtf8().data();\n      }\n\n      // Ok. Now, does it go to main articles, or to alternate ones? We list\n      // main ones first, and alternates after.\n\n      // We do the case-folded comparison here.\n\n      wstring headwordStripped =\n        Folding::applySimpleCaseOnly( Utf8::decode( chain[ x ].word ) );\n      if( ignoreDiacritics )\n        headwordStripped = Folding::applyDiacriticsOnly( headwordStripped );\n\n      multimap< wstring, string > & mapToUse =\n        ( wordCaseFolded == headwordStripped ) ?\n          mainArticles : alternateArticles;\n\n      mapToUse.insert( pair< wstring, string >(\n        Folding::applySimpleCaseOnly( Utf8::decode( chain[ x ].word ) ),\n        articleText ) );\n\n      articlesIncluded.insert( chain[ x ].articleOffset );\n    }\n\n    if ( mainArticles.empty() && alternateArticles.empty() )\n      return new Dictionary::DataRequestInstant( false );\n\n    string result;\n\n    multimap< wstring, string >::const_iterator i;\n\n    for( i = mainArticles.begin(); i != mainArticles.end(); ++i )\n      result += i->second;\n\n    for( i = alternateArticles.begin(); i != alternateArticles.end(); ++i )\n      result += i->second;\n\n    sptr< Dictionary::DataRequestInstant > ret =\n      new Dictionary::DataRequestInstant( true );\n\n    ret->getData().resize( result.size() );\n\n    memcpy( &(ret->getData().front()), result.data(), result.size() );\n\n    return ret;\n  }\n  catch( std::exception & e )\n  {\n    return new Dictionary::DataRequestInstant( QString( e.what() ) );\n  }\n}\n\nQString const& DictdDictionary::getDescription()\n{\n    if( !dictionaryDescription.isEmpty() )\n        return dictionaryDescription;\n\n    sptr< Dictionary::DataRequest > req = getArticle( GD_NATIVE_TO_WS( L\"00databaseinfo\" ),\n                                                      vector< wstring >(), wstring(), false );\n\n    if( req->dataSize() > 0 )\n      dictionaryDescription = Html::unescape( QString::fromUtf8( req->getFullData().data(), req->getFullData().size() ), true );\n    else\n      dictionaryDescription = \"NONE\";\n\n    return dictionaryDescription;\n}\n\nvoid DictdDictionary::makeFTSIndex( QAtomicInt & isCancelled, bool firstIteration )\n{\n  if( !( Dictionary::needToRebuildIndex( getDictionaryFilenames(), ftsIdxName )\n         || FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) ) )\n    FTS_index_completed.ref();\n\n  if( haveFTSIndex() )\n    return;\n\n  if( ensureInitDone().size() )\n    return;\n\n  if( firstIteration && getArticleCount() > FTS::MaxDictionarySizeForFastSearch )\n    return;\n\n  gdDebug( \"DictD: Building the full-text index for dictionary: %s\\n\",\n           getName().c_str() );\n\n  try\n  {\n    FtsHelpers::makeFTSIndex( this, isCancelled );\n    FTS_index_completed.ref();\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"DictD: Failed building full-text search index for \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n    QFile::remove( FsEncoding::decode( ftsIdxName.c_str() ) );\n  }\n}\n\nvoid DictdDictionary::getArticleText( uint32_t articleAddress, QString & headword, QString & text )\n{\n  try\n  {\n    char buf[ 16384 ];\n    {\n      Mutex::Lock _( indexFileMutex );\n      indexFile.seek( articleAddress );\n\n      if ( !indexFile.gets( buf, sizeof( buf ), true ) )\n        throw exFailedToReadLineFromIndex();\n    }\n\n    char * tab1 = strchr( buf, '\\t' );\n\n    if ( !tab1 )\n      throw exMalformedIndexFileLine();\n\n    headword = QString::fromUtf8( buf, tab1 - buf );\n\n    char * tab2 = strchr( tab1 + 1, '\\t' );\n\n    if ( !tab2 )\n      throw exMalformedIndexFileLine();\n\n    // After tab1 should be article offset, after tab2 -- article size\n\n    uint32_t articleOffset = decodeBase64( string( tab1 + 1, tab2 - tab1 - 1 ) );\n\n    char * tab3 = strchr( tab2 + 1, '\\t');\n\n    uint32_t articleSize;\n    if ( tab3 )\n    {\n      articleSize = decodeBase64( string( tab2 + 1, tab3 - tab2 - 1 ) );\n    }\n    else\n    {\n      articleSize = decodeBase64( tab2 + 1 );\n    }\n\n    string articleText;\n\n    char * articleBody;\n    {\n      Mutex::Lock _( dzMutex );\n      articleBody = dict_data_read_( dz, articleOffset, articleSize, 0, 0 );\n    }\n\n    if ( !articleBody )\n    {\n      articleText = dict_error_str( dz );\n    }\n    else\n    {\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n      static QRegularExpression phonetic( \"\\\\\\\\([^\\\\\\\\]+)\\\\\\\\\",\n                                          QRegularExpression::CaseInsensitiveOption ); // phonetics: \\stuff\\ ...\n      static QRegularExpression refs( \"\\\\{([^\\\\{\\\\}]+)\\\\}\",\n                                      QRegularExpression::CaseInsensitiveOption );     // links: {stuff}\n#else\n      static QRegExp phonetic( \"\\\\\\\\([^\\\\\\\\]+)\\\\\\\\\", Qt::CaseInsensitive ); // phonetics: \\stuff\\ ...\n      static QRegExp refs( \"\\\\{([^\\\\{\\\\}]+)\\\\}\", Qt::CaseInsensitive );     // links: {stuff}\n#endif\n\n      string convertedText = Html::preformat( articleBody, isToLanguageRTL() );\n      free( articleBody );\n\n      text = QString::fromUtf8( convertedText.data(), convertedText.size() )\n            .replace(phonetic, \"<span class=\\\"dictd_phonetic\\\">\\\\1</span>\")\n            .replace(refs, \"<a href=\\\"gdlookup://localhost/\\\\1\\\">\\\\1</a>\");\n\n      text = Html::unescape( text );\n    }\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"DictD: Failed retrieving article from \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n  }\n}\n\nsptr< Dictionary::DataRequest > DictdDictionary::getSearchResults( QString const & searchString,\n                                                                   int searchMode, bool matchCase,\n                                                                   int distanceBetweenWords,\n                                                                   int maxResults,\n                                                                   bool ignoreWordsOrder,\n                                                                   bool ignoreDiacritics,\n                                                                   QThreadPool * ftsThreadPoolPtr )\n{\n  return new FtsHelpers::FTSResultsRequest( *this, searchString,searchMode, matchCase, distanceBetweenWords, maxResults, ignoreWordsOrder, ignoreDiacritics, ftsThreadPoolPtr );\n}\n\n} // anonymous namespace\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing & initializing )\n  THROW_SPEC( std::exception )\n{\n  vector< sptr< Dictionary::Class > > dictionaries;\n\n  for( vector< string >::const_iterator i = fileNames.begin(); i != fileNames.end();\n       ++i )\n  {\n    // Only allow .index suffixes\n\n    if ( i->size() < 6 ||\n         strcasecmp( i->c_str() + ( i->size() - 6 ), \".index\" ) != 0 )\n      continue;\n\n    try\n    {\n      vector< string > dictFiles( 1, *i );\n\n      // Check if there is an 'abrv' file present\n      string baseName( *i, 0, i->size() - 5 );\n\n      dictFiles.push_back( string() );\n\n      if ( !File::tryPossibleName( baseName + \"dict\", dictFiles[ 1 ] ) &&\n           !File::tryPossibleName( baseName + \"dict.dz\", dictFiles[ 1 ] ) )\n      {\n        // No corresponding .dict file, skipping\n        continue;\n      }\n\n      string dictId = Dictionary::makeDictionaryId( dictFiles );\n\n      string indexFile = indicesDir + dictId;\n\n      if ( Dictionary::needToRebuildIndex( dictFiles, indexFile ) ||\n           indexIsOldOrBad( indexFile ) )\n      {\n        // Building the index\n        string dictionaryName = nameFromFileName( dictFiles[ 0 ] );\n\n        gdDebug( \"DictD: Building the index for dictionary: %s\\n\", dictionaryName.c_str() );\n\n        initializing.indexingDictionary( dictionaryName );\n\n        File::Class idx( indexFile, \"wb\" );\n\n        IdxHeader idxHeader;\n\n        memset( &idxHeader, 0, sizeof( idxHeader ) );\n\n        // We write a dummy header first. At the end of the process the header\n        // will be rewritten with the right values.\n\n        idx.write( idxHeader );\n\n        IndexedWords indexedWords;\n\n        File::Class indexFile( dictFiles[ 0 ], \"rb\" );\n\n        // Read words from index until none's left.\n\n        char buf[ 16384 ];\n\n        do\n        {\n          uint32_t curOffset = indexFile.tell();\n\n          if ( !indexFile.gets( buf, sizeof( buf ), true ) )\n            break;\n\n          // Check that there are exactly two or three tabs in the record.\n          char * tab1 = strchr( buf, '\\t' );\n          if ( tab1 )\n          {\n            char * tab2 = strchr( tab1 + 1, '\\t' );\n            if ( tab2 )\n            {\n              char * tab3 = strchr( tab2 + 1, '\\t');\n              if ( tab3 )\n              {\n                char * tab4 = strchr( tab3 + 1, '\\t');\n                if ( tab4 )\n                {\n                  GD_DPRINTF( \"Warning: too many tabs present, skipping: %s\\n\", buf );\n                  continue;\n                }\n\n                // Handle the forth entry, if it exists. From dictfmt man:\n                // When --index-keep-orig option is used fourth column is created\n                // (if necessary) in .index file.\n                indexedWords.addWord( Utf8::decode( string( tab3 + 1, strlen ( tab3 + 1 ) ) ), curOffset );\n                ++idxHeader.wordCount;\n              }\n              indexedWords.addWord( Utf8::decode( string( buf, strchr( buf, '\\t' ) - buf ) ), curOffset );\n              ++idxHeader.wordCount;\n              ++idxHeader.articleCount;\n\n              // Check for proper dictionary name\n              if ( !strncmp( buf, \"00databaseshort\", 15 ) || !strncmp( buf, \"00-database-short\", 17 ) )\n              {\n                // After tab1 should be article offset, after tab2 -- article size\n                uint32_t articleOffset = decodeBase64( string( tab1 + 1, tab2 - tab1 - 1 ) );\n                uint32_t articleSize = decodeBase64( tab2 + 1 );\n\n                DZ_ERRORS error;\n                dictData * dz = dict_data_open( dictFiles[ 1 ].c_str(), &error, 0 );\n\n                if ( dz )\n                {\n                  char * articleBody = dict_data_read_( dz, articleOffset, articleSize, 0, 0 );\n                  if ( articleBody )\n                  {\n                    char * eol;\n                    if ( !strncmp( articleBody, \"00databaseshort\", 15 ) || !strncmp( articleBody, \"00-database-short\", 17 ) )\n                      eol = strchr( articleBody, '\\n'  ); // skip the first line (headword itself)\n                    else\n                      eol = articleBody; // No headword itself\n                    if ( eol )\n                    {\n                      while( *eol && Utf8::isspace( *eol ) ) ++eol; // skip spaces\n\n                      // use only the single line for the dictionary title\n                      char * endEol = strchr( eol, '\\n' );\n                      if ( endEol )\n                        *endEol = 0;\n\n                      GD_DPRINTF( \"DICT NAME: '%s'\\n\", eol );\n                      dictionaryName = eol;\n                    }\n                  }\n                  dict_data_close( dz );\n                }\n                else\n                  throw exDictzipError( string( dz_error_str( error ) )\n                                        + \"(\" + dictFiles[ 1 ] + \")\" );\n              }\n            }\n            else\n            {\n              GD_DPRINTF( \"Warning: only a single tab present, skipping: %s\\n\", buf );\n              continue;\n            }\n          }\n          else\n          {\n            GD_DPRINTF( \"Warning: no tabs present, skipping: %s\\n\", buf );\n            continue;\n          }\n\n\n        } while( !indexFile.eof() );\n\n\n        // Write dictionary name\n\n        idx.write( (uint32_t) dictionaryName.size() );\n        idx.write( dictionaryName.data(), dictionaryName.size() );\n\n        // Build index\n\n        IndexInfo idxInfo = BtreeIndexing::buildIndex( indexedWords, idx );\n\n        idxHeader.indexBtreeMaxElements = idxInfo.btreeMaxElements;\n        idxHeader.indexRootOffset = idxInfo.rootOffset;\n\n        // That concludes it. Update the header.\n\n        idxHeader.signature = Signature;\n        idxHeader.formatVersion = CurrentFormatVersion;\n\n        // read languages\n        QPair<quint32,quint32> langs =\n            LangCoder::findIdsForFilename( QString::fromStdString( dictFiles[ 0 ] ) );\n\n        // if no languages found, try dictionary's name\n        if ( langs.first == 0 || langs.second == 0 )\n        {\n          langs =\n            LangCoder::findIdsForFilename( QString::fromStdString( nameFromFileName( dictFiles[ 0 ] ) ) );\n        }\n\n        idxHeader.langFrom = langs.first;\n        idxHeader.langTo = langs.second;\n\n        idx.rewind();\n\n        idx.write( &idxHeader, sizeof( idxHeader ) );\n      }\n\n      dictionaries.push_back( new DictdDictionary( dictId,\n                                                   indexFile,\n                                                   dictFiles ) );\n    }\n    catch( std::exception & e )\n    {\n      gdWarning( \"Dictd dictionary \\\"%s\\\" reading failed, error: %s\\n\",\n                 i->c_str(), e.what() );\n    }\n  }\n\n  return dictionaries;\n}\n\n}\n"
        },
        {
          "name": "dictdfiles.hh",
          "type": "blob",
          "size": 0.6474609375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __DICTDFILES_HH_INCLUDED__\n#define __DICTDFILES_HH_INCLUDED__\n\n#include \"dictionary.hh\"\n\n/// Support for the dictd (.index/dict.dz) files.\nnamespace DictdFiles {\n\nusing std::vector;\nusing std::string;\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing & )\n    THROW_SPEC( std::exception );\n\n}\n\n#endif\n"
        },
        {
          "name": "dictgroupwidget.ui",
          "type": "blob",
          "size": 2.74609375,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ui version=\"4.0\">\n <class>DictGroupWidget</class>\n <widget class=\"QWidget\" name=\"DictGroupWidget\">\n  <property name=\"geometry\">\n   <rect>\n    <x>0</x>\n    <y>0</y>\n    <width>403</width>\n    <height>333</height>\n   </rect>\n  </property>\n  <property name=\"windowTitle\">\n   <string>Form</string>\n  </property>\n  <layout class=\"QVBoxLayout\" name=\"verticalLayout\">\n   <item>\n    <widget class=\"DictListWidget\" name=\"dictionaries\"/>\n   </item>\n   <item>\n    <layout class=\"QHBoxLayout\" name=\"horizontalLayout\">\n     <item>\n      <widget class=\"QLabel\" name=\"label\">\n       <property name=\"text\">\n        <string>Group icon:</string>\n       </property>\n      </widget>\n     </item>\n     <item>\n      <widget class=\"QComboBox\" name=\"groupIcon\"/>\n     </item>\n     <item>\n      <spacer name=\"horizontalSpacer\">\n       <property name=\"orientation\">\n        <enum>Qt::Horizontal</enum>\n       </property>\n       <property name=\"sizeHint\" stdset=\"0\">\n        <size>\n         <width>40</width>\n         <height>20</height>\n        </size>\n       </property>\n      </spacer>\n     </item>\n     <item>\n      <widget class=\"QLabel\" name=\"label_3\">\n       <property name=\"minimumSize\">\n        <size>\n         <width>16</width>\n         <height>16</height>\n        </size>\n       </property>\n       <property name=\"maximumSize\">\n        <size>\n         <width>16</width>\n         <height>16</height>\n        </size>\n       </property>\n       <property name=\"text\">\n        <string notr=\"true\"/>\n       </property>\n       <property name=\"pixmap\">\n        <pixmap resource=\"resources.qrc\">:/icons/hotkeys.png</pixmap>\n       </property>\n       <property name=\"scaledContents\">\n        <bool>true</bool>\n       </property>\n      </widget>\n     </item>\n     <item>\n      <widget class=\"QLabel\" name=\"label_2\">\n       <property name=\"text\">\n        <string>Shortcut:</string>\n       </property>\n      </widget>\n     </item>\n     <item>\n      <widget class=\"HotKeyEdit\" name=\"shortcut\"/>\n     </item>\n    </layout>\n   </item>\n   <item>\n    <layout class=\"QHBoxLayout\" name=\"horizontalLayout_2\">\n     <item>\n      <widget class=\"QLabel\" name=\"label_4\">\n       <property name=\"text\">\n        <string>Favorites folder:</string>\n       </property>\n      </widget>\n     </item>\n     <item>\n      <widget class=\"QLineEdit\" name=\"favoritesFolder\"/>\n     </item>\n    </layout>\n   </item>\n  </layout>\n </widget>\n <customwidgets>\n  <customwidget>\n   <class>DictListWidget</class>\n   <extends>QListWidget</extends>\n   <header>groups_widgets.hh</header>\n  </customwidget>\n  <customwidget>\n   <class>HotKeyEdit</class>\n   <extends>QLineEdit</extends>\n   <header>hotkeyedit.hh</header>\n  </customwidget>\n </customwidgets>\n <resources>\n  <include location=\"resources.qrc\"/>\n </resources>\n <connections/>\n</ui>\n"
        },
        {
          "name": "dictheadwords.cc",
          "type": "blob",
          "size": 10.28125,
          "content": "/* This file is (c) 2014 Abs62\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"dictheadwords.hh\"\n#include \"gddebug.hh\"\n#include \"mainwindow.hh\"\n\n#include <QRegExp>\n#include <QDir>\n#include <QFileDialog>\n#include <QTimer>\n#include <QProgressDialog>\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 12, 0 )\n#include <QRegularExpression>\n#include \"wildcard.hh\"\n#include \"gddebug.hh\"\n#endif\n\n#define AUTO_APPLY_LIMIT 150000\n\nDictHeadwords::DictHeadwords( QWidget *parent, Config::Class & cfg_,\n                              Dictionary::Class * dict_ ) :\n  QDialog(parent)\n, cfg( cfg_ )\n, dict( dict_ )\n, helpAction( this )\n{\n  ui.setupUi( this );\n\n  bool fromMainWindow = parent->objectName() == \"MainWindow\";\n\n  if( fromMainWindow )\n    setAttribute( Qt::WA_DeleteOnClose, false );\n\n  setWindowFlags( windowFlags() & ~Qt::WindowContextHelpButtonHint );\n\n  if( cfg.headwordsDialog.headwordsDialogGeometry.size() > 0 )\n    restoreGeometry( cfg.headwordsDialog.headwordsDialogGeometry );\n\n  ui.searchModeCombo->addItem( tr( \"Text\" ), QRegExp::FixedString );\n  ui.searchModeCombo->addItem( tr( \"Wildcards\" ), QRegExp::WildcardUnix );\n  ui.searchModeCombo->addItem( tr( \"RegExp\" ), QRegExp::RegExp );\n  ui.searchModeCombo->setCurrentIndex( cfg.headwordsDialog.searchMode );\n\n  ui.exportButton->setAutoDefault( false );\n  ui.OKButton->setAutoDefault( false);\n  ui.applyButton->setAutoDefault( true );\n  ui.applyButton->setDefault( true );\n\n  ui.matchCase->setChecked( cfg.headwordsDialog.matchCase );\n\n  model = new QStringListModel( this );\n  model->setStringList( headers );\n\n  proxy = new QSortFilterProxyModel( this );\n\n  proxy->setSourceModel( model );\n\n  proxy->setSortCaseSensitivity( Qt::CaseInsensitive );\n  proxy->setSortLocaleAware( true );\n  proxy->setDynamicSortFilter( false );\n\n  ui.headersListView->setModel( proxy );\n  ui.headersListView->setEditTriggers( QAbstractItemView::NoEditTriggers );\n\n  // very important call, for performance reasons:\n  ui.headersListView->setUniformItemSizes( true );\n\n  delegate = new WordListItemDelegate( ui.headersListView->itemDelegate() );\n  if( delegate )\n    ui.headersListView->setItemDelegate( delegate );\n\n  ui.autoApply->setChecked( cfg.headwordsDialog.autoApply );\n\n  connect( this, SIGNAL( finished( int ) ), this, SLOT( savePos() ) );\n\n  if( !fromMainWindow )\n  {\n    ui.helpButton->hide();\n    connect( this, SIGNAL( closeDialog() ), this, SLOT( accept() ) );\n  }\n  else\n  {\n    connect( ui.helpButton, SIGNAL( clicked() ),\n             this, SLOT( helpRequested() ) );\n\n    helpAction.setShortcut( QKeySequence( \"F1\" ) );\n    helpAction.setShortcutContext( Qt::WidgetWithChildrenShortcut );\n\n    connect( &helpAction, SIGNAL( triggered() ),\n             this, SLOT( helpRequested() ) );\n\n    addAction( &helpAction );\n  }\n\n  connect( ui.OKButton, SIGNAL( clicked( bool ) ), this, SLOT( okButtonClicked() ) );\n  connect( ui.exportButton, SIGNAL( clicked( bool ) ), this, SLOT( exportButtonClicked() ) );\n  connect( ui.applyButton, SIGNAL( clicked( bool ) ), this, SLOT( filterChanged() ) );\n\n  connect( ui.autoApply, SIGNAL( stateChanged( int ) ),\n           this, SLOT( autoApplyStateChanged( int ) ) );\n\n  connect( ui.filterLine, SIGNAL( textChanged( QString ) ),\n           this, SLOT( filterChangedInternal() ) );\n  connect( ui.searchModeCombo, SIGNAL( currentIndexChanged( int ) ),\n           this, SLOT( filterChangedInternal() ) );\n  connect( ui.matchCase, SIGNAL( stateChanged( int ) ),\n           this, SLOT( filterChangedInternal() ) );\n\n  connect( ui.headersListView, SIGNAL( clicked( QModelIndex ) ),\n           this, SLOT( itemClicked( QModelIndex ) ) );\n\n  connect( proxy, SIGNAL( dataChanged( QModelIndex, QModelIndex ) ),\n           this, SLOT( showHeadwordsNumber() ) );\n\n  ui.headersListView->installEventFilter( this );\n\n  setup( dict_ );\n}\n\nDictHeadwords::~DictHeadwords()\n{\n  if( delegate )\n    delegate->deleteLater();\n}\n\nvoid DictHeadwords::setup( Dictionary::Class *dict_ )\n{\n  QApplication::setOverrideCursor( Qt::WaitCursor );\n\n  dict = dict_;\n\n  setWindowTitle( QString::fromUtf8( dict->getName().c_str() ) );\n\n  headers.clear();\n  model->setStringList( headers );\n\n  dict->getHeadwords( headers );\n  model->setStringList( headers );\n\n  proxy->sort( 0 );\n  filterChanged();\n\n  if( headers.size() > AUTO_APPLY_LIMIT )\n  {\n    cfg.headwordsDialog.autoApply = ui.autoApply->isChecked();\n    ui.autoApply->setChecked( false );\n    ui.autoApply->setEnabled( false );\n  }\n  else\n  {\n    ui.autoApply->setEnabled( true );\n    ui.autoApply->setChecked( cfg.headwordsDialog.autoApply );\n  }\n\n  ui.applyButton->setEnabled( !ui.autoApply->isChecked() );\n\n  setWindowIcon( dict->getIcon() );\n\n  dictId = QString( dict->getId().c_str() );\n\n  QApplication::restoreOverrideCursor();\n}\n\nvoid DictHeadwords::savePos()\n{\n  cfg.headwordsDialog.searchMode = ui.searchModeCombo->currentIndex();\n  cfg.headwordsDialog.matchCase = ui.matchCase->isChecked();\n\n  if( headers.size() <= AUTO_APPLY_LIMIT )\n    cfg.headwordsDialog.autoApply = ui.autoApply->isChecked();\n\n  cfg.headwordsDialog.headwordsDialogGeometry = saveGeometry();\n}\n\nbool DictHeadwords::eventFilter( QObject * obj, QEvent * ev )\n{\n  if( obj == ui.headersListView && ev->type() == QEvent::KeyPress )\n  {\n    QKeyEvent * kev = static_cast< QKeyEvent * >( ev );\n    if( kev->key() == Qt::Key_Return || kev->key() == Qt::Key_Enter )\n    {\n      itemClicked( ui.headersListView->currentIndex() );\n      return true;\n    }\n  }\n  return QDialog::eventFilter( obj, ev );\n}\n\nvoid DictHeadwords::okButtonClicked()\n{\n  savePos();\n  closeDialog();\n}\n\nvoid DictHeadwords::reject()\n{\n  savePos();\n  closeDialog();\n}\n\nvoid DictHeadwords::exportButtonClicked()\n{\n  saveHeadersToFile();\n}\n\nvoid DictHeadwords::filterChangedInternal()\n{\n  // emit signal in async manner, to avoid UI slowdown\n  if( ui.autoApply->isChecked() )\n    QTimer::singleShot( 100, this, SLOT( filterChanged() ) );\n}\n\nvoid DictHeadwords::filterChanged()\n{\n  QRegExp::PatternSyntax syntax =\n          QRegExp::PatternSyntax( ui.searchModeCombo->itemData(\n                  ui.searchModeCombo->currentIndex()).toInt() );\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 12, 0 )\n  QRegularExpression::PatternOptions options = QRegularExpression::UseUnicodePropertiesOption;\n  if( !ui.matchCase->isChecked() )\n    options |= QRegularExpression::CaseInsensitiveOption;\n\n  QString pattern;\n  switch( syntax )\n  {\n    case QRegExp::FixedString:  pattern = QRegularExpression::escape( ui.filterLine->text() );\n                                break;\n    case QRegExp::WildcardUnix: pattern = wildcardsToRegexp( ui.filterLine->text() );\n                                break;\n    default:                    pattern = ui.filterLine->text();\n                                break;\n  }\n\n  QRegularExpression regExp( pattern, options );\n\n  if( !regExp.isValid() )\n  {\n    gdWarning( \"Invalid regexp pattern: %s\\n\", pattern.toUtf8().data() );\n    regExp.setPattern( QString::fromLatin1( \"\\1\" ) );\n  }\n\n  QApplication::setOverrideCursor( Qt::WaitCursor );\n\n  proxy->setFilterRegularExpression( regExp );\n#else\n  Qt::CaseSensitivity caseSensitivity = ui.matchCase->isChecked() ? Qt::CaseSensitive\n                                                                  : Qt::CaseInsensitive;\n  QRegExp regExp( ui.filterLine->text(), caseSensitivity, syntax );\n\n  QApplication::setOverrideCursor( Qt::WaitCursor );\n\n  proxy->setFilterRegExp( regExp );\n#endif\n\n  proxy->sort( 0 );\n\n  QApplication::restoreOverrideCursor();\n\n  showHeadwordsNumber();\n}\n\nvoid DictHeadwords::itemClicked( const QModelIndex & index )\n{\n  QVariant value = proxy->data( index, Qt::DisplayRole );\n  if ( value.canConvert< QString >() )\n  {\n    QString headword = value.toString();\n    emit headwordSelected( headword, dictId );\n  }\n}\n\nvoid DictHeadwords::autoApplyStateChanged( int state )\n{\n  ui.applyButton->setEnabled( state == Qt::Unchecked );\n}\n\nvoid DictHeadwords::showHeadwordsNumber()\n{\n  ui.headersNumber->setText( tr( \"Unique headwords total: %1, filtered: %2\" )\n                             .arg( QString::number( headers.size() ) )\n                             .arg( QString::number( proxy->rowCount() ) ) );\n}\n\nvoid DictHeadwords::saveHeadersToFile()\n{\n  QString exportPath;\n  if( cfg.headwordsDialog.headwordsExportPath.isEmpty() )\n    exportPath = QDir::homePath();\n  else\n  {\n    exportPath = QDir::fromNativeSeparators( cfg.headwordsDialog.headwordsExportPath );\n    if( !QDir( exportPath ).exists() )\n      exportPath = QDir::homePath();\n  }\n\n  QString fileName = QFileDialog::getSaveFileName( this, tr( \"Save headwords to file\" ),\n                                                   exportPath,\n                                                   tr( \"Text files (*.txt);;All files (*.*)\" ) );\n  if( fileName.size() == 0)\n      return;\n\n  cfg.headwordsDialog.headwordsExportPath = QDir::toNativeSeparators(\n                                              QFileInfo( fileName ).absoluteDir().absolutePath() );\n  QFile file( fileName );\n\n  for(;;)\n  {\n    if ( !file.open( QFile::WriteOnly | QIODevice::Text ) )\n      break;\n\n    int headwordsNumber = proxy->rowCount();\n\n    // Setup progress dialog\n    int n = headwordsNumber;\n    int step = 1;\n    while( n > 1000 )\n    {\n      step *= 10;\n      n /= 10;\n    }\n\n    QProgressDialog progress( tr( \"Export headwords...\"), tr( \"Cancel\" ),\n                              0, n, this );\n    progress.setWindowModality( Qt::WindowModal );\n\n    // Write UTF-8 BOM\n    QByteArray line;\n    line.append( 0xEF ).append( 0xBB ).append( 0xBF );\n    if ( file.write( line ) != line.size() )\n      break;\n\n    // Write headwords\n\n    int i;\n    for( i = 0; i < headwordsNumber; ++i )\n    {\n      if( i % step == 0 )\n        progress.setValue( i / step );\n\n      if( progress.wasCanceled() )\n        break;\n\n      QVariant value = proxy->data( proxy->index( i, 0 ) );\n      if( !value.canConvert< QString >() )\n        continue;\n\n      line = value.toString().toUtf8();\n\n      line.replace( '\\n', ' ' );\n      line.replace( '\\r', ' ' );\n\n      line += \"\\n\";\n\n      if ( file.write( line ) != line.size() )\n        break;\n    }\n\n    if( i < headwordsNumber && !progress.wasCanceled() )\n      break;\n\n    file.close();\n    return;\n  }\n\n  gdWarning( \"Headers export error: %s\", file.errorString().toUtf8().data() );\n  file.close();\n}\n\nvoid DictHeadwords::helpRequested()\n{\n  MainWindow * mainWindow = qobject_cast< MainWindow * >( parentWidget() );\n  if( mainWindow )\n    mainWindow->showGDHelpForID( \"Dictionary headwords\" );\n}\n"
        },
        {
          "name": "dictheadwords.hh",
          "type": "blob",
          "size": 1.365234375,
          "content": "#ifndef __DICTHEADWORDS_H_INCLUDED__\n#define __DICTHEADWORDS_H_INCLUDED__\n\n#include <QDialog>\n#include <QSet>\n#include <QString>\n#include <QStringList>\n#include <QStringListModel>\n#include <QSortFilterProxyModel>\n#include <QAction>\n\n#include \"config.hh\"\n#include \"ui_dictheadwords.h\"\n#include \"dictionary.hh\"\n#include \"delegate.hh\"\n#include \"helpwindow.hh\"\n\nclass DictHeadwords : public QDialog\n{\n  Q_OBJECT\n\npublic:\n  explicit DictHeadwords( QWidget * parent, Config::Class & cfg_,\n                          Dictionary::Class * dict_ );\n  virtual ~DictHeadwords();\n\n  void setup( Dictionary::Class * dict_ );\n\nprotected:\n  Config::Class & cfg;\n  Dictionary::Class * dict;\n  QStringList headers;\n  QStringListModel * model;\n  QSortFilterProxyModel * proxy;\n  WordListItemDelegate * delegate;\n  QString dictId;\n\n  QAction helpAction;\n\n  void saveHeadersToFile();\n  bool eventFilter( QObject * obj, QEvent * ev );\n\nprivate:\n  Ui::DictHeadwords ui;\nprivate slots:\n  void savePos();\n  void filterChangedInternal();\n  void filterChanged();\n  void exportButtonClicked();\n  void okButtonClicked();\n  void itemClicked( const QModelIndex & index );\n  void autoApplyStateChanged( int state );\n  void showHeadwordsNumber();\n  virtual void reject();\n  void helpRequested();\n\nsignals:\n  void headwordSelected( QString const &, QString const & );\n  void closeDialog();\n};\n\n#endif // __DICTHEADWORDS_H_INCLUDED__\n"
        },
        {
          "name": "dictheadwords.ui",
          "type": "blob",
          "size": 4.26953125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ui version=\"4.0\">\n <class>DictHeadwords</class>\n <widget class=\"QDialog\" name=\"DictHeadwords\">\n  <property name=\"geometry\">\n   <rect>\n    <x>0</x>\n    <y>0</y>\n    <width>458</width>\n    <height>550</height>\n   </rect>\n  </property>\n  <property name=\"windowTitle\">\n   <string notr=\"true\"/>\n  </property>\n  <layout class=\"QVBoxLayout\" name=\"verticalLayout_3\">\n   <item>\n    <layout class=\"QGridLayout\" name=\"gridLayout\">\n     <item row=\"3\" column=\"0\">\n      <widget class=\"QListView\" name=\"headersListView\"/>\n     </item>\n     <item row=\"3\" column=\"1\">\n      <layout class=\"QVBoxLayout\" name=\"verticalLayout_2\">\n       <item>\n        <widget class=\"QGroupBox\" name=\"groupBox\">\n         <property name=\"title\">\n          <string>Search mode</string>\n         </property>\n         <layout class=\"QVBoxLayout\" name=\"verticalLayout\">\n          <item>\n           <widget class=\"QComboBox\" name=\"searchModeCombo\">\n            <property name=\"toolTip\">\n             <string>This element determines how filter string will be interpreted</string>\n            </property>\n           </widget>\n          </item>\n          <item>\n           <widget class=\"QCheckBox\" name=\"matchCase\">\n            <property name=\"toolTip\">\n             <string>If checked on the symbols case will be take in account when filtering</string>\n            </property>\n            <property name=\"text\">\n             <string>Match case</string>\n            </property>\n           </widget>\n          </item>\n         </layout>\n        </widget>\n       </item>\n       <item>\n        <widget class=\"QPushButton\" name=\"exportButton\">\n         <property name=\"toolTip\">\n          <string>Exports headwords to file</string>\n         </property>\n         <property name=\"text\">\n          <string>Export</string>\n         </property>\n         <property name=\"autoDefault\">\n          <bool>false</bool>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <spacer name=\"verticalSpacer\">\n         <property name=\"orientation\">\n          <enum>Qt::Vertical</enum>\n         </property>\n         <property name=\"sizeHint\" stdset=\"0\">\n          <size>\n           <width>20</width>\n           <height>40</height>\n          </size>\n         </property>\n        </spacer>\n       </item>\n       <item>\n        <widget class=\"QPushButton\" name=\"helpButton\">\n         <property name=\"text\">\n          <string>Help</string>\n         </property>\n         <property name=\"autoDefault\">\n          <bool>false</bool>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <widget class=\"QPushButton\" name=\"OKButton\">\n         <property name=\"text\">\n          <string>OK</string>\n         </property>\n         <property name=\"autoDefault\">\n          <bool>false</bool>\n         </property>\n        </widget>\n       </item>\n      </layout>\n     </item>\n     <item row=\"2\" column=\"1\">\n      <widget class=\"QPushButton\" name=\"applyButton\">\n       <property name=\"toolTip\">\n        <string>Press this button to apply filter to headwords list</string>\n       </property>\n       <property name=\"text\">\n        <string>Apply</string>\n       </property>\n       <property name=\"autoDefault\">\n        <bool>false</bool>\n       </property>\n       <property name=\"default\">\n        <bool>true</bool>\n       </property>\n      </widget>\n     </item>\n     <item row=\"1\" column=\"1\">\n      <widget class=\"QCheckBox\" name=\"autoApply\">\n       <property name=\"toolTip\">\n        <string>If checked any filter changes will we immediately applied to headwords list</string>\n       </property>\n       <property name=\"text\">\n        <string>Auto apply</string>\n       </property>\n      </widget>\n     </item>\n     <item row=\"1\" column=\"0\">\n      <widget class=\"QLabel\" name=\"label\">\n       <property name=\"text\">\n        <string>Filter:</string>\n       </property>\n      </widget>\n     </item>\n     <item row=\"2\" column=\"0\">\n      <widget class=\"QLineEdit\" name=\"filterLine\">\n       <property name=\"toolTip\">\n        <string>Filter string (fixed string, wildcards or regular expression)</string>\n       </property>\n      </widget>\n     </item>\n    </layout>\n   </item>\n   <item>\n    <widget class=\"QLabel\" name=\"headersNumber\">\n     <property name=\"text\">\n      <string/>\n     </property>\n    </widget>\n   </item>\n  </layout>\n </widget>\n <resources/>\n <connections/>\n</ui>\n"
        },
        {
          "name": "dictinfo.cc",
          "type": "blob",
          "size": 2.2412109375,
          "content": "#include \"dictinfo.hh\"\n#include \"langcoder.hh\"\n#include \"language.hh\"\n#include \"fsencoding.hh\"\n#include <QString>\n\nDictInfo::DictInfo( Config::Class &cfg_, QWidget *parent ) :\n  QDialog( parent),\n  cfg( cfg_)\n{\n  ui.setupUi( this );\n  if( cfg.dictInfoGeometry.size() > 0 )\n    restoreGeometry( cfg.dictInfoGeometry );\n  connect( this, SIGNAL( finished( int ) ), this, SLOT( savePos( int ) ) );\n}\n\nvoid DictInfo::showInfo( sptr<Dictionary::Class> dict )\n{\n  setWindowTitle( QString::fromUtf8( dict->getName().data(), dict->getName().size() ) );\n\n  ui.dictionaryTotalArticles->setText( QString::number( dict->getArticleCount() ) );\n  ui.dictionaryTotalWords->setText( QString::number( dict->getWordCount() ) );\n  ui.dictionaryTranslatesFrom->setText( Language::localizedStringForId( dict->getLangFrom() ) );\n  ui.dictionaryTranslatesTo->setText( Language::localizedStringForId( dict->getLangTo() ) );\n\n  ui.openFolder->setVisible( dict->isLocalDictionary() );\n  ui.editDictionary->setVisible( dict->isLocalDictionary() && !dict->getMainFilename().isEmpty() && !cfg.editDictionaryCommandLine.isEmpty());\n  ui.editDictionary->setToolTip(\n        tr( \"Edit the dictionary via command:\\n%1\" ).arg( cfg.editDictionaryCommandLine ) );\n\n  if( dict->getWordCount() == 0 )\n    ui.headwordsButton->setVisible( false );\n  else\n    ui.buttonsLayout->insertSpacerItem( 0, new QSpacerItem( 40, 20, QSizePolicy::Expanding ) );\n\n  std::vector< std::string > const & filenames = dict->getDictionaryFilenames();\n\n  QString filenamesText;\n\n  for( unsigned x = 0; x < filenames.size(); x++ )\n  {\n    filenamesText += FsEncoding::decode( filenames[ x ].c_str() );\n    filenamesText += '\\n';\n  }\n\n  ui.dictionaryFileList->setPlainText( filenamesText );\n\n  QString info = dict->getDescription();\n\n  if( !info.isEmpty() && info.compare( \"NONE\" ) != 0 )\n    ui.infoLabel->setPlainText( info );\n  else\n    ui.infoLabel->clear();\n\n  setWindowIcon( dict->getIcon() );\n}\n\nvoid DictInfo::savePos( int )\n{\n  cfg.dictInfoGeometry = saveGeometry();\n}\n\nvoid DictInfo::on_editDictionary_clicked()\n{\n  done( EDIT_DICTIONARY );\n}\n\nvoid DictInfo::on_openFolder_clicked()\n{\n  done( OPEN_FOLDER );\n}\n\nvoid DictInfo::on_OKButton_clicked()\n{\n  done( ACCEPTED );\n}\n\nvoid DictInfo::on_headwordsButton_clicked()\n{\n  done( SHOW_HEADWORDS );\n}\n"
        },
        {
          "name": "dictinfo.hh",
          "type": "blob",
          "size": 0.6376953125,
          "content": "#ifndef DICTINFO_HH\n#define DICTINFO_HH\n\n#include <QDialog>\n#include \"ui_dictinfo.h\"\n#include \"dictionary.hh\"\n#include \"config.hh\"\n\nclass DictInfo: public QDialog\n{\n  Q_OBJECT\npublic:\n\n  enum Actions\n  {\n    REJECTED,\n    ACCEPTED,\n    OPEN_FOLDER,\n    EDIT_DICTIONARY,\n    SHOW_HEADWORDS\n  };\n\n  DictInfo( Config::Class &cfg_, QWidget * parent = 0 );\n  void showInfo( sptr< Dictionary::Class > dict );\n\nprivate:\n  Ui::DictInfo ui;\n  Config::Class &cfg;\nprivate slots:\n  void savePos( int );\n  void on_editDictionary_clicked();\n  void on_openFolder_clicked();\n  void on_OKButton_clicked();\n  void on_headwordsButton_clicked();\n};\n\n#endif // DICTINFO_HH\n"
        },
        {
          "name": "dictinfo.ui",
          "type": "blob",
          "size": 8.056640625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ui version=\"4.0\">\n <class>DictInfo</class>\n <widget class=\"QDialog\" name=\"DictInfo\">\n  <property name=\"geometry\">\n   <rect>\n    <x>0</x>\n    <y>0</y>\n    <width>600</width>\n    <height>400</height>\n   </rect>\n  </property>\n  <property name=\"windowTitle\">\n   <string/>\n  </property>\n  <property name=\"modal\">\n   <bool>true</bool>\n  </property>\n  <layout class=\"QVBoxLayout\" name=\"verticalLayout\">\n   <item>\n    <widget class=\"QGroupBox\" name=\"groupBox\">\n     <property name=\"title\">\n      <string/>\n     </property>\n     <layout class=\"QGridLayout\" name=\"gridLayout\">\n      <item row=\"0\" column=\"0\">\n       <widget class=\"QLabel\" name=\"label_2\">\n        <property name=\"text\">\n         <string>Total articles:</string>\n        </property>\n       </widget>\n      </item>\n      <item row=\"0\" column=\"1\">\n       <widget class=\"QLabel\" name=\"dictionaryTotalArticles\">\n        <property name=\"text\">\n         <string notr=\"true\"/>\n        </property>\n        <property name=\"alignment\">\n         <set>Qt::AlignCenter</set>\n        </property>\n       </widget>\n      </item>\n      <item row=\"0\" column=\"2\">\n       <widget class=\"QLabel\" name=\"label_4\">\n        <property name=\"text\">\n         <string>Translates from:</string>\n        </property>\n       </widget>\n      </item>\n      <item row=\"0\" column=\"3\">\n       <widget class=\"QLabel\" name=\"dictionaryTranslatesFrom\">\n        <property name=\"text\">\n         <string notr=\"true\"/>\n        </property>\n       </widget>\n      </item>\n      <item row=\"1\" column=\"0\">\n       <widget class=\"QLabel\" name=\"label_6\">\n        <property name=\"text\">\n         <string>Total words:</string>\n        </property>\n       </widget>\n      </item>\n      <item row=\"1\" column=\"1\">\n       <widget class=\"QLabel\" name=\"dictionaryTotalWords\">\n        <property name=\"text\">\n         <string notr=\"true\"/>\n        </property>\n        <property name=\"alignment\">\n         <set>Qt::AlignCenter</set>\n        </property>\n       </widget>\n      </item>\n      <item row=\"1\" column=\"2\">\n       <widget class=\"QLabel\" name=\"label_8\">\n        <property name=\"text\">\n         <string>Translates to:</string>\n        </property>\n       </widget>\n      </item>\n      <item row=\"1\" column=\"3\">\n       <widget class=\"QLabel\" name=\"dictionaryTranslatesTo\">\n        <property name=\"text\">\n         <string notr=\"true\"/>\n        </property>\n       </widget>\n      </item>\n      <item row=\"0\" column=\"4\">\n       <widget class=\"QPushButton\" name=\"openFolder\">\n        <property name=\"text\">\n         <string>Open folder</string>\n        </property>\n        <property name=\"autoDefault\">\n         <bool>false</bool>\n        </property>\n        <property name=\"default\">\n         <bool>false</bool>\n        </property>\n        <property name=\"flat\">\n         <bool>false</bool>\n        </property>\n       </widget>\n      </item>\n      <item row=\"1\" column=\"4\">\n       <widget class=\"QPushButton\" name=\"editDictionary\">\n        <property name=\"enabled\">\n         <bool>true</bool>\n        </property>\n        <property name=\"text\">\n         <string>Edit dictionary</string>\n        </property>\n       </widget>\n      </item>\n     </layout>\n    </widget>\n   </item>\n   <item>\n    <widget class=\"QLabel\" name=\"label\">\n     <property name=\"text\">\n      <string>Files comprising this dictionary:</string>\n     </property>\n    </widget>\n   </item>\n   <item>\n    <widget class=\"QPlainTextEdit\" name=\"dictionaryFileList\">\n     <property name=\"sizePolicy\">\n      <sizepolicy hsizetype=\"Expanding\" vsizetype=\"Fixed\">\n       <horstretch>0</horstretch>\n       <verstretch>70</verstretch>\n      </sizepolicy>\n     </property>\n     <property name=\"minimumSize\">\n      <size>\n       <width>0</width>\n       <height>70</height>\n      </size>\n     </property>\n     <property name=\"maximumSize\">\n      <size>\n       <width>16777215</width>\n       <height>70</height>\n      </size>\n     </property>\n     <property name=\"palette\">\n      <palette>\n       <active>\n        <colorrole role=\"Base\">\n         <brush brushstyle=\"SolidPattern\">\n          <color alpha=\"255\">\n           <red>224</red>\n           <green>223</green>\n           <blue>223</blue>\n          </color>\n         </brush>\n        </colorrole>\n       </active>\n       <inactive>\n        <colorrole role=\"Base\">\n         <brush brushstyle=\"SolidPattern\">\n          <color alpha=\"255\">\n           <red>224</red>\n           <green>223</green>\n           <blue>223</blue>\n          </color>\n         </brush>\n        </colorrole>\n       </inactive>\n       <disabled>\n        <colorrole role=\"Base\">\n         <brush brushstyle=\"SolidPattern\">\n          <color alpha=\"255\">\n           <red>212</red>\n           <green>208</green>\n           <blue>200</blue>\n          </color>\n         </brush>\n        </colorrole>\n       </disabled>\n      </palette>\n     </property>\n     <property name=\"toolTip\">\n      <string notr=\"true\"/>\n     </property>\n     <property name=\"undoRedoEnabled\">\n      <bool>false</bool>\n     </property>\n     <property name=\"lineWrapMode\">\n      <enum>QPlainTextEdit::NoWrap</enum>\n     </property>\n     <property name=\"readOnly\">\n      <bool>true</bool>\n     </property>\n     <property name=\"plainText\">\n      <string notr=\"true\"/>\n     </property>\n    </widget>\n   </item>\n   <item>\n    <widget class=\"QLabel\" name=\"dictionaryDescriptionLabel\">\n     <property name=\"text\">\n      <string>Description:</string>\n     </property>\n    </widget>\n   </item>\n   <item>\n    <widget class=\"QPlainTextEdit\" name=\"infoLabel\">\n     <property name=\"palette\">\n      <palette>\n       <active>\n        <colorrole role=\"Base\">\n         <brush brushstyle=\"SolidPattern\">\n          <color alpha=\"255\">\n           <red>224</red>\n           <green>223</green>\n           <blue>223</blue>\n          </color>\n         </brush>\n        </colorrole>\n       </active>\n       <inactive>\n        <colorrole role=\"Base\">\n         <brush brushstyle=\"SolidPattern\">\n          <color alpha=\"255\">\n           <red>224</red>\n           <green>223</green>\n           <blue>223</blue>\n          </color>\n         </brush>\n        </colorrole>\n       </inactive>\n       <disabled>\n        <colorrole role=\"Base\">\n         <brush brushstyle=\"SolidPattern\">\n          <color alpha=\"255\">\n           <red>212</red>\n           <green>208</green>\n           <blue>200</blue>\n          </color>\n         </brush>\n        </colorrole>\n       </disabled>\n      </palette>\n     </property>\n     <property name=\"toolTip\">\n      <string notr=\"true\"/>\n     </property>\n     <property name=\"horizontalScrollBarPolicy\">\n      <enum>Qt::ScrollBarAlwaysOff</enum>\n     </property>\n     <property name=\"undoRedoEnabled\">\n      <bool>false</bool>\n     </property>\n     <property name=\"readOnly\">\n      <bool>true</bool>\n     </property>\n    </widget>\n   </item>\n   <item>\n    <layout class=\"QHBoxLayout\" name=\"buttonsLayout\">\n     <item>\n      <widget class=\"QPushButton\" name=\"headwordsButton\">\n       <property name=\"toolTip\">\n        <string>Show all unique dictionary headwords</string>\n       </property>\n       <property name=\"text\">\n        <string>Headwords</string>\n       </property>\n       <property name=\"autoDefault\">\n        <bool>false</bool>\n       </property>\n      </widget>\n     </item>\n     <item>\n      <spacer name=\"horizontalSpacer\">\n       <property name=\"orientation\">\n        <enum>Qt::Horizontal</enum>\n       </property>\n       <property name=\"sizeHint\" stdset=\"0\">\n        <size>\n         <width>40</width>\n         <height>20</height>\n        </size>\n       </property>\n      </spacer>\n     </item>\n     <item>\n      <widget class=\"QPushButton\" name=\"OKButton\">\n       <property name=\"text\">\n        <string notr=\"true\">OK</string>\n       </property>\n       <property name=\"default\">\n        <bool>true</bool>\n       </property>\n      </widget>\n     </item>\n     <item>\n      <spacer name=\"horizontalSpacer_2\">\n       <property name=\"orientation\">\n        <enum>Qt::Horizontal</enum>\n       </property>\n       <property name=\"sizeHint\" stdset=\"0\">\n        <size>\n         <width>40</width>\n         <height>20</height>\n        </size>\n       </property>\n      </spacer>\n     </item>\n    </layout>\n   </item>\n  </layout>\n </widget>\n <resources/>\n <connections/>\n</ui>\n"
        },
        {
          "name": "dictionary.cc",
          "type": "blob",
          "size": 12.4716796875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include \"dictionary.hh\"\n\n#include <QCryptographicHash>\n\n// For needToRebuildIndex(), read below\n#include <QFileInfo>\n#include <QDateTime>\n\n#include \"config.hh\"\n#include <QDir>\n#include <QFileInfo>\n#include <QCryptographicHash>\n#include <QDateTime>\n#include \"fsencoding.hh\"\n#include \"langcoder.hh\"\n\n#include <QImage>\n#include <QPainter>\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n#include <QRegularExpression>\n#else\n#include <QRegExp>\n#endif\n\n#include \"qt4x5.hh\"\n#include \"zipfile.hh\"\n\nnamespace Dictionary {\n\nbool Request::isFinished()\n{\n  return Qt4x5::AtomicInt::loadAcquire( isFinishedFlag );\n}\n\nvoid Request::update()\n{\n  if ( !Qt4x5::AtomicInt::loadAcquire( isFinishedFlag ) )\n    emit updated();\n}\n\nvoid Request::finish()\n{\n  if ( !Qt4x5::AtomicInt::loadAcquire( isFinishedFlag ) )\n  {\n    isFinishedFlag.ref();\n\n    emit finished();\n  }\n}\n\nvoid Request::setErrorString( QString const & str )\n{\n  Mutex::Lock _( errorStringMutex );\n\n  errorString = str;\n}\n\nQString Request::getErrorString()\n{\n  Mutex::Lock _( errorStringMutex );\n\n  return errorString;\n}\n\n\n///////// WordSearchRequest\n  \nsize_t WordSearchRequest::matchesCount()\n{\n  Mutex::Lock _( dataMutex );\n  \n  return matches.size();\n}\n\nWordMatch WordSearchRequest::operator [] ( size_t index ) THROW_SPEC( exIndexOutOfRange )\n{\n  Mutex::Lock _( dataMutex );\n  \n  if ( index >= matches.size() )\n    throw exIndexOutOfRange();\n  \n  return matches[ index ];\n}\n\nvector< WordMatch > & WordSearchRequest::getAllMatches() THROW_SPEC( exRequestUnfinished )\n{\n  if ( !isFinished() )\n    throw exRequestUnfinished();\n\n  return matches;\n}\n\nvoid WordSearchRequest::addMatch( WordMatch const & match )\n{\n  unsigned n;\n  for( n = 0; n < matches.size(); n++ )\n    if( matches[ n ].word.compare( match.word ) == 0 )\n      break;\n\n  if( n >= matches.size() )\n    matches.push_back( match );\n}\n\n////////////// DataRequest\n\nlong DataRequest::dataSize()\n{\n  Mutex::Lock _( dataMutex );\n  \n  return hasAnyData ? (long)data.size() : -1;\n}\n\nvoid DataRequest::getDataSlice( size_t offset, size_t size, void * buffer )\n  THROW_SPEC( exSliceOutOfRange )\n{\n  if ( size == 0 )\n    return;\n\n  Mutex::Lock _( dataMutex );\n\n  if ( offset + size > data.size() || !hasAnyData )\n    throw exSliceOutOfRange();\n\n  memcpy( buffer, &data[ offset ], size );\n}\n\nvector< char > & DataRequest::getFullData() THROW_SPEC( exRequestUnfinished )\n{\n  if ( !isFinished() )\n    throw exRequestUnfinished();\n\n  return data;\n}\n\nClass::Class( string const & id_, vector< string > const & dictionaryFiles_ ):\n  id( id_ ), dictionaryFiles( dictionaryFiles_ ), dictionaryIconLoaded( false )\n  , can_FTS( false), FTS_index_completed( false )\n{\n}\n\nvoid Class::deferredInit()\n{\n}\n\nsptr< WordSearchRequest > Class::stemmedMatch( wstring const & /*str*/,\n                                               unsigned /*minLength*/,\n                                               unsigned /*maxSuffixVariation*/,\n                                               unsigned long /*maxResults*/ )\n  THROW_SPEC( std::exception )\n{\n  return new WordSearchRequestInstant();\n}\n\nsptr< WordSearchRequest > Class::findHeadwordsForSynonym( wstring const & )\n  THROW_SPEC( std::exception )\n{\n  return new WordSearchRequestInstant();\n}\n\nvector< wstring > Class::getAlternateWritings( wstring const & )\n  throw()\n{\n  return vector< wstring >();\n}\n\nsptr< DataRequest > Class::getResource( string const & /*name*/ )\n  THROW_SPEC( std::exception )\n{\n  return new DataRequestInstant( false );\n}\n\nsptr< DataRequest > Class::getSearchResults(const QString &, int, bool, int, int, bool, bool, QThreadPool * )\n{\n  return new DataRequestInstant( false );\n}\n\nQString const& Class::getDescription()\n{\n    return dictionaryDescription;\n}\n\nQString Class::getMainFilename()\n{\n  return QString();\n}\n\nQIcon const & Class::getIcon() throw()\n{\n  if( !dictionaryIconLoaded )\n    loadIcon();\n  return dictionaryIcon;\n}\n\nQIcon const & Class::getNativeIcon() throw()\n{\n  if( !dictionaryIconLoaded )\n    loadIcon();\n  return dictionaryNativeIcon;\n}\n\nvoid Class::loadIcon() throw()\n{\n  dictionaryIconLoaded = true;\n}\n\nbool Class::loadIconFromFile( QString const & _filename, bool isFullName )\n{\n  QFileInfo info;\n  QString fileName( _filename );\n\n  if( isFullName )\n    info = QFileInfo( fileName );\n  else\n  {\n    fileName += \"bmp\";\n    info = QFileInfo( fileName );\n    if ( !info.isFile() )\n    {\n      fileName.chop( 3 );\n      fileName += \"png\";\n      info = QFileInfo( fileName );\n    }\n    if ( !info.isFile() )\n    {\n      fileName.chop( 3 );\n      fileName += \"jpg\";\n      info = QFileInfo( fileName );\n    }\n    if ( !info.isFile() )\n    {\n      fileName.chop( 3 );\n      fileName += \"ico\";\n      info = QFileInfo( fileName );\n    }\n  }\n\n  if ( info.isFile() )\n  {\n    QImage img( fileName );\n\n    if ( !img.isNull() )\n    {\n      // Load successful\n\n      // Apply the color key\n\n      img.setAlphaChannel( img.createMaskFromColor( QColor( 192, 192, 192 ).rgb(),\n                                                    Qt::MaskOutColor ) );\n\n      dictionaryNativeIcon = QIcon( QPixmap::fromImage( img ) );\n\n      // Transform it to be square\n      int max = img.width() > img.height() ? img.width() : img.height();\n\n      QImage result( max, max, QImage::Format_ARGB32 );\n      result.fill( 0 ); // Black transparent\n\n      QPainter painter( &result );\n\n      painter.drawImage( QPoint( img.width() == max ? 0 : ( max - img.width() ) / 2,\n                                 img.height() == max ? 0 : ( max - img.height() ) / 2 ),\n                         img );\n\n      painter.end();\n\n      dictionaryIcon = QIcon( QPixmap::fromImage( result ) );\n\n      return !dictionaryIcon.isNull();\n    }\n  }\n  return false;\n}\n\nvoid Class::isolateCSS( QString & css, QString const & wrapperSelector )\n{\n  if( css.isEmpty() )\n    return;\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  QRegularExpression reg1( \"\\\\/\\\\*(?:.(?!\\\\*\\\\/))*.?\\\\*\\\\/\",\n                           QRegularExpression::DotMatchesEverythingOption );\n  QRegularExpression reg2( \"[ \\\\*\\\\>\\\\+,;:\\\\[\\\\{\\\\]]\" );\n  QRegularExpression reg3( \"[,;\\\\{]\" );\n#else\n  QRegExp reg1( \"\\\\/\\\\*(?:.(?!\\\\*\\\\/))*.?\\\\*\\\\/\" );\n  QRegExp reg2( \"[ \\\\*\\\\>\\\\+,;:\\\\[\\\\{\\\\]]\" );\n  QRegExp reg3( \"[,;\\\\{]\" );\n#endif\n\n  int currentPos = 0;\n  QString newCSS;\n  QString prefix( \"#gdfrom-\" );\n  prefix += QString::fromLatin1( getId().c_str() );\n  if ( !wrapperSelector.isEmpty() )\n    prefix += \" \" + wrapperSelector;\n\n  // Strip comments\n  css.replace( reg1, QString() );\n\n  for( ; ; )\n  {\n    if( currentPos >= css.length() )\n      break;\n    QChar ch = css[ currentPos ];\n\n    if( ch == '@' )\n    {\n      // @ rules\n\n      int n = currentPos;\n      if( css.mid( currentPos, 7 ).compare( \"@import\", Qt::CaseInsensitive ) == 0\n          || css.mid( currentPos, 10 ).compare( \"@font-face\", Qt::CaseInsensitive ) == 0\n          || css.mid( currentPos, 10 ).compare( \"@namespace\", Qt::CaseInsensitive ) == 0\n          || css.mid( currentPos, 8 ).compare( \"@charset\", Qt::CaseInsensitive ) == 0 )\n      {\n        // Copy rule as is.\n        n = css.indexOf( ';', currentPos );\n        int n2 = css.indexOf( '{', currentPos );\n        if( n2 > 0 && n > n2 )\n          n = n2 - 1;\n      }\n      else\n      if( css.mid( currentPos, 6 ).compare( \"@media\", Qt::CaseInsensitive ) == 0 )\n      {\n        // We must to parse it content to isolate it.\n        // Copy all up to '{' and continue parse inside.\n        n = css.indexOf( '{', currentPos );\n      }\n      else\n      if( css.mid( currentPos, 5 ).compare( \"@page\", Qt::CaseInsensitive ) == 0 )\n      {\n        // Don't copy rule. GD use own page layout.\n        n = css.indexOf( '}', currentPos );\n        if( n < 0 )\n          break;\n        currentPos = n + 1;\n        continue;\n      }\n      else\n      {\n        // Copy rule as is.\n        n = css.indexOf( '}', currentPos );\n      }\n\n      newCSS.append( css.mid( currentPos, n < 0 ? n : n - currentPos + 1 ) );\n\n      if( n < 0 )\n        break;\n\n      currentPos = n + 1;\n      continue;\n    }\n\n    if( ch == '{' )\n    {\n      // Selector declaration block.\n      // We copy it up to '}' as is.\n\n      int n = css.indexOf( '}', currentPos );\n      newCSS.append( css.mid( currentPos, n == -1 ? n : n - currentPos + 1 ) );\n      if( n < 0 )\n        break;\n      currentPos = n + 1;\n      continue;\n    }\n\n    if( ch.isLetter() || ch == '.' || ch == '#' || ch == '*' || ch == '\\\\' || ch == ':' )\n    {\n      if( ch.isLetter() || ch == '*' )\n      {\n        // Check for namespace prefix\n        QChar chr;\n        for( int i = currentPos; i < css.length(); i++ )\n        {\n          chr = css[ i ];\n          if( chr.isLetterOrNumber() || chr.isMark() || chr == '_' || chr == '-'\n              || ( chr == '*' && i == currentPos ) )\n            continue;\n\n          if( chr == '|' )\n          {\n            // Namespace prefix found, copy it as is\n            newCSS.append( css.mid( currentPos, i - currentPos + 1 ) );\n            currentPos = i + 1;\n          }\n          break;\n        }\n        if ( chr == '|' )\n          continue;\n      }\n\n      // This is some selector.\n      // We must to add the isolate prefix to it.\n\n      int n = css.indexOf( reg2, currentPos + 1 );\n      QString s = css.mid( currentPos, n < 0 ? n : n - currentPos );\n      if( n < 0 )\n      {\n        newCSS.append( s );\n        break;\n      }\n      QString trimmed = s.trimmed();\n      if( trimmed.compare( \"body\", Qt::CaseInsensitive ) == 0\n          || trimmed.compare( \"html\", Qt::CaseInsensitive ) == 0 )\n      {\n        newCSS.append( s + \" \" + prefix + \" \" );\n        currentPos += 4;\n      }\n      else\n      {\n        newCSS.append( prefix + \" \" );\n      }\n\n      n = css.indexOf( reg3, currentPos );\n      s = css.mid( currentPos, n < 0 ? n : n - currentPos );\n      newCSS.append( s );\n      if( n < 0 )\n        break;\n      currentPos = n;\n      continue;\n    }\n\n    newCSS.append( ch );\n    ++currentPos;\n  }\n  css = newCSS;\n}\n\nstring makeDictionaryId( vector< string > const & dictionaryFiles ) throw()\n{\n  std::vector< string > sortedList;\n\n  if ( Config::isPortableVersion() )\n  {\n    // For portable version, we use relative paths\n    sortedList.reserve( dictionaryFiles.size() );\n\n    QDir dictionariesDir( Config::getPortableVersionDictionaryDir() );\n\n    for( unsigned x = 0; x < dictionaryFiles.size(); ++x )\n    {\n      string const & full( dictionaryFiles[ x ] );\n\n      QFileInfo fileInfo( FsEncoding::decode( full.c_str() ) );\n\n      if ( fileInfo.isAbsolute() )\n        sortedList.push_back( FsEncoding::encode( dictionariesDir.relativeFilePath( fileInfo.filePath() ) ) );\n      else\n      {\n        // Well, it's relative. We don't technically support those, but\n        // what the heck\n        sortedList.push_back( full );\n      }\n    }\n  }\n  else\n    sortedList = dictionaryFiles;\n\n  std::sort( sortedList.begin(), sortedList.end() );\n\n  QCryptographicHash hash( QCryptographicHash::Md5 );\n\n  for( std::vector< string >::const_iterator i = sortedList.begin();\n       i != sortedList.end(); ++i )\n    hash.addData( i->c_str(), i->size() + 1 );\n\n  return hash.result().toHex().data();\n}\n\n// While this file is not supposed to have any Qt stuff since it's used by\n// the dictionary backends, there's no platform-independent way to get hold\n// of a timestamp of the file, so we use here Qt anyway. It is supposed to\n// be fixed in the future when it's needed.\nbool needToRebuildIndex( vector< string > const & dictionaryFiles,\n                         string const & indexFile ) throw()\n{\n  unsigned long lastModified = 0;\n\n  for( std::vector< string >::const_iterator i = dictionaryFiles.begin();\n       i != dictionaryFiles.end(); ++i )\n  {\n    QString name = FsEncoding::decode( i->c_str() );\n    QFileInfo fileInfo( name );\n    unsigned long ts;\n\n    if( fileInfo.isDir() )\n      continue;\n\n    if( name.toLower().endsWith( \".zip\" ) )\n    {\n      ZipFile::SplitZipFile zf( name );\n      if( !zf.exists() )\n        return true;\n      ts = zf.lastModified().toTime_t();\n    }\n    else\n    {\n      if ( !fileInfo.exists() )\n        return true;\n      ts = fileInfo.lastModified().toTime_t();\n    }\n\n    if ( ts > lastModified )\n      lastModified = ts;\n  }\n\n  QFileInfo fileInfo( FsEncoding::decode( indexFile.c_str() ) );\n\n  if ( !fileInfo.exists() )\n    return true;\n\n  return fileInfo.lastModified().toTime_t() < lastModified;\n}\n\nQString generateRandomDictionaryId()\n{\n  return QString(\n    QCryptographicHash::hash(\n      QDateTime::currentDateTime().toString( \"\\\"Random\\\"dd.MM.yyyy hh:mm:ss.zzz\" ).toUtf8(),\n      QCryptographicHash::Md5 ).toHex() );\n}\n\n\n}\n"
        },
        {
          "name": "dictionary.hh",
          "type": "blob",
          "size": 17.169921875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __DICTIONARY_HH_INCLUDED__\n#define __DICTIONARY_HH_INCLUDED__\n\n#include <vector>\n#include <string>\n#include <map>\n#include <QObject>\n#include <QIcon>\n#include <QThreadPool>\n#include \"cpp_features.hh\"\n#include \"sptr.hh\"\n#include \"ex.hh\"\n#include \"mutex.hh\"\n#include \"wstring.hh\"\n#include \"langcoder.hh\"\n#include \"config.hh\"\n#include \"qt4x5.hh\"\n\n/// Abstract dictionary-related stuff\nnamespace Dictionary {\n\nusing std::vector;\nusing std::string;\nusing gd::wstring;\nusing std::map;\n\nenum Property\n{\n  Author,\n  Copyright,\n  Description,\n  Email\n};\n\nDEF_EX( Ex, \"Dictionary error\", std::exception )\nDEF_EX( exIndexOutOfRange, \"The supplied index is out of range\", Ex )\nDEF_EX( exSliceOutOfRange, \"The requested data slice is out of range\", Ex )\nDEF_EX( exRequestUnfinished, \"The request hasn't yet finished\", Ex )\n\n/// When you request a search to be performed in a dictionary, you get\n/// this structure in return. It accumulates search results over time.\n/// The finished() signal is emitted when the search has finished and there's\n/// no more matches to be expected. Note that before connecting to it, check\n/// the result of isFinished() -- if it's 'true', the search was instantaneous.\n/// Destroy the object when you are not interested in results anymore.\n///\n/// Creating, destroying and calling member functions of the requests is done\n/// in the GUI thread, however. Therefore, it is important to make sure those\n/// operations are fast (this is most important for word searches, where\n/// new requests are created and old ones deleted immediately upon a user\n/// changing query).\nclass Request: public QObject\n{\n  Q_OBJECT\n\npublic:\n\n  /// Returns whether the request has been processed in full and finished.\n  /// This means that the data accumulated is final and won't change anymore.\n  bool isFinished();\n\n  /// Either returns an empty string in case there was no error processing\n  /// the request, or otherwise a human-readable string describing the problem.\n  /// Note that an empty result, such as a lack of word or of an article isn't\n  /// an error -- but any kind of failure to connect to, or read the dictionary\n  /// is.\n  QString getErrorString();\n\n  /// Cancels the ongoing request. This may make Request destruct faster some\n  /// time in the future, Use this in preparation to destruct many Requests,\n  /// so that they'd be cancelling in parallel. When the request was fully\n  /// cancelled, it must emit the finished() signal, either as a result of an\n  /// actual finish which has happened just before the cancellation, or solely as\n  /// a result of a request being cancelled (in the latter case, the actual\n  /// request result may be empty or incomplete). That is, finish() must be\n  /// called by a derivative at least once if cancel() was called, either after\n  /// or before it was called.\n  virtual void cancel()=0;\n\n  virtual ~Request()\n  {}\n\nsignals:\n\n  /// This signal is emitted when more data becomes available. Local\n  /// dictionaries typically don't call this, since it is preferred that all\n  /// data would be available from them at once, but network dictionaries\n  /// might call that.\n  void updated();\n\n  /// This signal is emitted when the request has been processed in full and\n  /// finished. That is, it's emitted when isFinished() turns true.\n  void finished();\n\nprotected:\n\n  /// Called by derivatives to signal update().\n  void update();\n\n  /// Called by derivatives to set isFinished() flag and signal finished().\n  void finish();\n\n  /// Sets the error string to be returned by getErrorString().\n  void setErrorString( QString const & );\n\nprivate:\n\n  QAtomicInt isFinishedFlag;\n\n  Mutex errorStringMutex;\n  QString errorString;\n};\n\n/// This structure represents the word found. In addition to holding the\n/// word itself, it also holds its weight. It is 0 by default. Negative\n/// values should be used to store distance from Levenstein-like matching\n/// algorithms. Positive values are used by morphology matches.\nstruct WordMatch\n{\n  wstring word;\n  int weight;\n\n  WordMatch(): weight( 0 ) {}\n  WordMatch( wstring const & word_ ): word( word_ ), weight( 0 ){}\n  WordMatch( wstring const & word_, int weight_ ): word( word_ ),\n    weight( weight_ ) {}\n};\n\n/// This request type corresponds to all types of word searching operations.\nclass WordSearchRequest: public Request\n{\n  Q_OBJECT\n\npublic:\n\n  WordSearchRequest(): uncertain( false )\n  {}\n\n  /// Returns the number of matches found. The value can grow over time\n  /// unless isFinished() is true.\n  size_t matchesCount();\n\n  /// Returns the match with the given zero-based index, which should be less\n  /// than matchesCount().\n  WordMatch operator [] ( size_t index ) THROW_SPEC( exIndexOutOfRange );\n\n  /// Returns all the matches found. Since no further locking can or would be\n  /// done, this can only be called after the request has finished.\n  vector< WordMatch > & getAllMatches() THROW_SPEC( exRequestUnfinished );\n\n  /// Returns true if the match was uncertain -- that is, there may be more\n  /// results in the dictionary itself, the dictionary index isn't good enough\n  /// to tell that.\n  bool isUncertain() const\n  { return uncertain; }\n\n  /// Add match if one is not presented in matches list\n  void addMatch( WordMatch const & match );\n\nprotected:\n\n  // Subclasses should be filling up the 'matches' array, locking the mutex when\n  // whey work with it.\n  Mutex dataMutex;\n\n  vector< WordMatch > matches;\n  bool uncertain;\n};\n\n/// This request type corresponds to any kinds of data responses where a\n/// single large blob of binary data is returned. It currently used of article\n/// bodies and resources.\nclass DataRequest: public Request\n{\n  Q_OBJECT\n\npublic:\n\n  /// Returns the number of bytes read, with a -1 meaning that so far it's\n  /// uncertain whether resource even exists or not, and any non-negative value\n  /// meaning that that amount of bytes is not available.\n  /// If -1 is still being returned after the request has finished, that means\n  /// the resource wasn't found.\n  long dataSize();\n\n  /// Writes \"size\" bytes starting from \"offset\" of the data read to the given\n  /// buffer. \"size + offset\" must be <= than dataSize().\n  void getDataSlice( size_t offset, size_t size, void * buffer )\n    THROW_SPEC( exSliceOutOfRange );\n\n  /// Returns all the data read. Since no further locking can or would be\n  /// done, this can only be called after the request has finished.\n  vector< char > & getFullData() THROW_SPEC( exRequestUnfinished );\n\n  DataRequest(): hasAnyData( false ) {}\n\nprotected:\n\n  // Subclasses should be filling up the 'data' array, locking the mutex when\n  // whey work with it.\n  Mutex dataMutex;\n\n  bool hasAnyData; // With this being false, dataSize() always returns -1\n  vector< char > data;\n};\n\n/// A helper class for synchronous word search implementations.\nclass WordSearchRequestInstant: public WordSearchRequest\n{\npublic:\n\n  WordSearchRequestInstant()\n  { finish(); }\n\n  virtual void cancel()\n  {}\n\n  vector< WordMatch > & getMatches()\n  { return matches; }\n\n  void setUncertain( bool value )\n  { uncertain = value; }\n};\n\n/// A helper class for synchronous data read implementations.\nclass DataRequestInstant: public DataRequest\n{\npublic:\n\n  DataRequestInstant( bool succeeded )\n  { hasAnyData = succeeded; finish(); }\n\n  DataRequestInstant( QString const & errorString )\n  { setErrorString( errorString ); finish(); }\n\n  virtual void cancel()\n  {}\n\n  vector< char > & getData()\n  { return data; }\n};\n\n/// Dictionary features. Different dictionaries can possess different features,\n/// which hint at some of their aspects.\nenum Feature\n{\n  /// No features\n  NoFeatures = 0,\n  /// The dictionary is suitable to query when searching for compound expressions.\n  SuitableForCompoundSearching = 1\n};\n\nQ_DECLARE_FLAGS( Features, Feature )\nQ_DECLARE_OPERATORS_FOR_FLAGS( Features )\n\n/// A dictionary. Can be used to query words.\nclass Class\n{\n  string id;\n  vector< string > dictionaryFiles;\n\nprotected:\n  QString dictionaryDescription;\n  QIcon dictionaryIcon, dictionaryNativeIcon;\n  bool dictionaryIconLoaded;\n  bool can_FTS;\n  QAtomicInt FTS_index_completed;\n  bool synonymSearchEnabled;\n\n  // Load user icon if it exist\n  // By default set icon to empty\n  virtual void loadIcon() throw();\n\n  // Load icon from filename directly if isFullName == true\n  // else treat filename as name without extension\n  bool loadIconFromFile( QString const & filename, bool isFullName = false );\n\n  /// Make css content usable only for articles from this dictionary\n  void isolateCSS( QString & css, QString const & wrapperSelector = QString() );\n\npublic:\n\n  /// Creates a dictionary. The id should be made using\n  /// Format::makeDictionaryId(), the dictionaryFiles is the file names the\n  /// dictionary consists of.\n  Class( string const & id, vector< string > const & dictionaryFiles );\n\n  /// Called once after the dictionary is constructed. Usually called for each\n  /// dictionaries once all dictionaries were made. The implementation should\n  /// queue any initialization tasks the dictionary decided to postpone to\n  /// threadpools, network requests etc, so the system could complete them\n  /// in background.\n  /// The default implementation does nothing.\n  virtual void deferredInit();\n\n  /// Returns the dictionary's id.\n  string getId() throw()\n  { return id; }\n\n  /// Returns the list of file names the dictionary consists of.\n  vector< string > const & getDictionaryFilenames() throw()\n  { return dictionaryFiles; }\n\n  /// Returns the dictionary's full name, utf8.\n  virtual string getName() throw()=0;\n\n  /// Returns all the available properties, like the author's name, copyright,\n  /// description etc. All strings are in utf8.\n  virtual map< Property, string > getProperties() throw()=0;\n\n  /// Returns the features the dictionary possess. See the Feature enum for\n  /// their list.\n  virtual Features getFeatures() const throw()\n  { return NoFeatures; }\n\n  /// Returns the number of articles in the dictionary.\n  virtual unsigned long getArticleCount() throw()=0;\n\n  /// Returns the number of words in the dictionary. This can be equal to\n  /// the number of articles, or can be larger if some synonyms are present.\n  virtual unsigned long getWordCount() throw()=0;\n\n  /// Returns the dictionary's icon.\n  virtual QIcon const & getIcon() throw();\n\n  /// Returns the dictionary's native icon. Dsl icons are usually rectangular,\n  /// and are adapted by getIcon() to be square. This function allows getting\n  /// the original icon with no geometry transformations applied.\n  virtual QIcon const & getNativeIcon() throw();\n\n  /// Returns the dictionary's source language.\n  virtual quint32 getLangFrom() const\n  { return 0; }\n\n  /// Returns the dictionary's target language.\n  virtual quint32 getLangTo() const\n  { return 0; }\n\n  /// Looks up a given word in the dictionary, aiming for exact matches and\n  /// prefix matches. If it's not possible to locate any prefix matches, no\n  /// prefix results should be added. Not more than maxResults results should\n  /// be stored. The whole operation is supposed to be fast, though some\n  /// dictionaries, the network ones particularly, may of course be slow.\n  virtual sptr< WordSearchRequest > prefixMatch( wstring const &,\n                                                 unsigned long maxResults ) THROW_SPEC( std::exception )=0;\n\n  /// Looks up a given word in the dictionary, aiming to find different forms\n  /// of the given word by allowing suffix variations. This means allowing words\n  /// which can be as short as the input word size minus maxSuffixVariation, or as\n  /// long as the input word size plus maxSuffixVariation, which share at least\n  /// the input word size minus maxSuffixVariation initial symbols.\n  /// Since the goal is to find forms of the words, no matches where a word\n  /// in the middle of a phrase got matched should be returned.\n  /// The default implementation does nothing, returning an empty result.\n  virtual sptr< WordSearchRequest > stemmedMatch( wstring const &,\n                                                  unsigned minLength,\n                                                  unsigned maxSuffixVariation,\n                                                  unsigned long maxResults ) THROW_SPEC( std::exception );\n\n  /// Finds known headwords for the given word, that is, the words for which\n  /// the given word is a synonym. If a dictionary can't perform this operation,\n  /// it should leave the default implementation which always returns an empty\n  /// result.\n  virtual sptr< WordSearchRequest > findHeadwordsForSynonym( wstring const & )\n    THROW_SPEC( std::exception );\n\n  /// For a given word, provides alternate writings of it which are to be looked\n  /// up alongside with it. Transliteration dictionaries implement this. The\n  /// default implementation returns an empty list. Note that this function is\n  /// supposed to be very fast and simple, and the results are thus returned\n  /// synchronously.\n  virtual vector< wstring > getAlternateWritings( wstring const & )\n    throw();\n  \n  /// Returns a definition for the given word. The definition should\n  /// be an html fragment (without html/head/body tags) in an utf8 encoding.\n  /// The 'alts' vector could contain a list of words the definitions of which\n  /// should be included in the output as well, being treated as additional\n  /// synonyms for the main word.\n  /// context is a dictionary-specific data, currently only used for the\n  /// 'Websites' feature.\n  virtual sptr< DataRequest > getArticle( wstring const &,\n                                          vector< wstring > const & alts,\n                                          wstring const & context = wstring(),\n                                          bool ignoreDiacritics = false )\n    THROW_SPEC( std::exception )=0;\n\n  /// Loads contents of a resource named 'name' into the 'data' vector. This is\n  /// usually a picture file referenced in the article or something like that.\n  /// The default implementation always returns the non-existing resource\n  /// response.\n  virtual sptr< DataRequest > getResource( string const & /*name*/ )\n    THROW_SPEC( std::exception );\n\n  /// Returns a results of full-text search of given string similar getArticle().\n  virtual sptr< DataRequest > getSearchResults( QString const & searchString,\n                                                int searchMode, bool matchCase,\n                                                int distanceBetweenWords,\n                                                int maxArticlesPerDictionary,\n                                                bool ignoreWordsOrder,\n                                                bool ignoreDiacritics,\n                                                QThreadPool * ftsThreadPoolPtr );\n\n  // Return dictionary description if presented\n  virtual QString const& getDescription();\n\n  // Return dictionary main file name\n  virtual QString getMainFilename();\n\n  /// Check text direction\n  bool isFromLanguageRTL()\n  { return LangCoder::isLanguageRTL( getLangFrom() ); }\n  bool isToLanguageRTL()\n  { return LangCoder::isLanguageRTL( getLangTo() ); }\n\n  /// Return true if dictionary is local dictionary\n  virtual bool isLocalDictionary()\n  { return false; }\n\n  /// Dictionary can full-text search\n  bool canFTS()\n  { return can_FTS; }\n\n  /// Dictionary have index for full-text search\n  bool haveFTSIndex()\n  { return Qt4x5::AtomicInt::loadAcquire( FTS_index_completed ) != 0; }\n\n  /// Make index for full-text search\n  virtual void makeFTSIndex( QAtomicInt &, bool )\n  {}\n\n  /// Set full-text search parameters\n  virtual void setFTSParameters( Config::FullTextSearch const & )\n  {}\n\n  /// Retrieve all dictionary headwords\n  virtual bool getHeadwords( QStringList & )\n  { return false; }\n\n  /// Enable/disable search via synonyms\n  void setSynonymSearchEnabled( bool enabled )\n  { synonymSearchEnabled = enabled; }\n\n  virtual ~Class()\n  {}\n};\n\n/// Callbacks to be used when the dictionaries are being initialized.\nclass Initializing\n{\npublic:\n\n  /// Called by the Format instance to notify the caller that the given\n  /// dictionary is being indexed. Since indexing can take some time, this\n  /// is useful to show in some kind of a splash screen.\n  /// The dictionaryName is in utf8.\n  virtual void indexingDictionary( string const & dictionaryName ) throw()=0;\n\n  virtual ~Initializing()\n  {}\n};\n\n/// Generates an id based on the set of file names which the dictionary\n/// consists of. The resulting id is an alphanumeric hex value made by\n/// hashing the file names. This id should be used to identify dictionary\n/// and for the index file name, if one is needed.\n/// This function is supposed to be used by dictionary implementations.\nstring makeDictionaryId( vector< string > const & dictionaryFiles ) throw();\n\n/// Checks if it is needed to regenerate index file based on its timestamp\n/// and the timestamps of the dictionary files. If some files are newer than\n/// the index file, or the index file doesn't exist, returns true. If some\n/// dictionary files don't exist, returns true, too.\n/// This function is supposed to be used by dictionary implementations.\nbool needToRebuildIndex( vector< string > const & dictionaryFiles,\n                         string const & indexFile ) throw();\n\n/// Returns a random dictionary id useful for interactively created\n/// dictionaries.\nQString generateRandomDictionaryId();\n\n}\n\n#endif\n\n"
        },
        {
          "name": "dictionarybar.cc",
          "type": "blob",
          "size": 10.5537109375,
          "content": "#include \"dictionarybar.hh\"\n#include <QAction>\n#include <QApplication>\n#include <QMenu>\n#include <QContextMenuEvent>\n#include <QProcess>\n#include \"gddebug.hh\"\n#include \"fsencoding.hh\"\n#include \"qt4x5.hh\"\n#include <QDebug>\n\nusing std::vector;\n\nDictionaryBar::DictionaryBar( QWidget * parent,\n                              Config::Events & events, QString const & _editDictionaryCommand, unsigned short const & maxDictionaryRefsInContextMenu_ ):\n  QToolBar( tr( \"&Dictionary Bar\" ), parent ),\n  mutedDictionaries( 0 ),\n  configEvents( events ),\n  editDictionaryCommand( _editDictionaryCommand ),\n  maxDictionaryRefsInContextMenu(maxDictionaryRefsInContextMenu_),\n  use14x21( false ),\n  timerId( 0 )\n{\n  setObjectName( \"dictionaryBar\" );\n\n  maxDictionaryRefsAction = new QAction(  QIcon(\":/icons/expand_opt.png\"), tr( \"Extended menu with all dictionaries...\" ), this );\n\n  connect( &events, SIGNAL( mutedDictionariesChanged() ),\n           this, SLOT( mutedDictionariesChanged() ) );\n\n  connect( this, SIGNAL(actionTriggered(QAction*)),\n           this, SLOT(actionWasTriggered(QAction*)) );\n\n  installEventFilter( this );\n}\n\nstatic QString elideDictName( QString const & name )\n{\n  // Some names are way too long -- we insert an ellipsis in the middle of those\n\n  int const maxSize = 33;\n\n  if ( name.size() <= maxSize )\n    return name;\n\n  int const pieceSize = maxSize / 2 - 1;\n\n  return name.left( pieceSize ) + QChar( 0x2026 ) + name.right( pieceSize );\n}\n\nvoid DictionaryBar::setDictionaries( vector< sptr< Dictionary::Class > >\n                                     const & dictionaries )\n{\n  setUpdatesEnabled( false );\n\n  allDictionaries.clear();\n  allDictionaries = dictionaries;\n\n  clear();\n  dictActions.clear();\n\n  use14x21 = false;\n\n  for( unsigned x = 0; x < dictionaries.size(); ++x )\n  {\n    QIcon icon = dictionaries[ x ]->getNativeIcon();\n\n    QString dictName = QString::fromUtf8( dictionaries[ x ]->\n                                            getName().c_str() );\n\n    QAction * action = addAction( icon, elideDictName( dictName ) );\n\n    action->setToolTip( dictName ); // Tooltip need not be shortened\n\n    QString id = QString::fromStdString( dictionaries[ x ]->getId() );\n\n    action->setData( id );\n\n    action->setCheckable( true );\n\n    action->setChecked( mutedDictionaries ? !mutedDictionaries->contains( id ) : true );\n\n    QList< QSize > sizes = icon.availableSizes();\n\n    for( QList< QSize >::iterator i = sizes.begin(); i != sizes.end();\n         ++i )\n      if ( i->width() == 14 && i->height() == 21 )\n        use14x21 = true;\n\n    dictActions.append( action );\n  }\n\n  setDictionaryIconSize( 21 );\n\n  setUpdatesEnabled( true );\n}\n\nvoid DictionaryBar::setDictionaryIconSize( int extent )\n{\n  setIconSize( QSize( use14x21 ? extent*2/3 : extent, extent  ) );\n}\n\nvoid DictionaryBar::contextMenuEvent( QContextMenuEvent * event )\n{\n  showContextMenu( event );\n}\n\nvoid DictionaryBar::showContextMenu( QContextMenuEvent * event, bool extended )\n{\n  QMenu menu( this );\n\n  QAction * editAction =\n      menu.addAction( QIcon( \":/icons/bookcase.png\" ), tr( \"Edit this group\" ) );\n\n  QAction * infoAction = NULL;\n  QAction * headwordsAction = NULL;\n  QAction * editDictAction = NULL;\n  QAction * openDictFolderAction = NULL;\n  QString dictFilename;\n\n  QAction * dictAction = actionAt( event->x(), event->y() );\n  if( dictAction )\n  {\n    Dictionary::Class *pDict = NULL;\n    QString id = dictAction->data().toString();\n    for( unsigned i = 0; i < allDictionaries.size(); i++ )\n    {\n      if( id.compare( allDictionaries[ i ]->getId().c_str() ) == 0 )\n      {\n        pDict = allDictionaries[ i ].get();\n        break;\n      }\n    }\n\n    if( pDict )\n    {\n      infoAction =  menu.addAction( tr( \"Dictionary info\" ) );\n\n      if( pDict->isLocalDictionary() )\n      {\n        if( pDict->getWordCount() > 0 )\n          headwordsAction = menu.addAction( tr( \"Dictionary headwords\" ) );\n\n        openDictFolderAction = menu.addAction( tr( \"Open dictionary folder\" ) );\n\n        if( !editDictionaryCommand.isEmpty() )\n        {\n          if( !pDict->getMainFilename().isEmpty() )\n          {\n            dictFilename = pDict->getMainFilename();\n            editDictAction = menu.addAction( tr( \"Edit dictionary\" ) );\n          }\n        }\n      }\n    }\n  }\n\n  if ( !dictActions.empty() )\n    menu.addSeparator();\n\n  unsigned refsAdded = 0;\n\n  for( QList< QAction * >::iterator i = dictActions.begin();\n       i != dictActions.end(); ++i )\n  {\n\n    // Enough! Or the menu would become too large.\n    if ( refsAdded++ >= maxDictionaryRefsInContextMenu && !extended )\n    {\n      menu.addSeparator();\n      menu.addAction( maxDictionaryRefsAction );\n      break;\n    }\n\n    // We need new action, since the one we have has text elided\n    QAction * action = menu.addAction( (*i)->icon(), (*i)->toolTip() );\n\n    action->setCheckable( true );\n    action->setChecked( (*i)->isChecked() );\n    action->setData( QVariant::fromValue( (void *)*i ) );\n    // Force \"icon in menu\" on all platforms, for\n    // usability reasons.\n    action->setIconVisibleInMenu( true );\n  }\n\n  connect( this, SIGNAL( closePopupMenu() ), &menu, SLOT( close() ) );\n\n  QAction * result = menu.exec( event->globalPos() );\n\n  if( result && result == infoAction )\n  {\n    QString id = dictAction->data().toString();\n    emit showDictionaryInfo( id );\n    return;\n  }\n\n  if( result && result == headwordsAction )\n  {\n    QString id = dictAction->data().toString();\n    emit showDictionaryHeadwords( id );\n    return;\n  }\n\n  if( result && result == openDictFolderAction )\n  {\n    QString id = dictAction->data().toString();\n    emit openDictionaryFolder( id );\n    return;\n  }\n\n  if( result && result == editDictAction )\n  {\n    QString command( editDictionaryCommand );\n    command.replace( \"%GDDICT%\", \"\\\"\" + dictFilename + \"\\\"\" );\n    if( !Qt4x5::Process::startDetached( command ) )\n      QApplication::beep();\n  }\n\n  if( result && result == maxDictionaryRefsAction )\n  {\n    showContextMenu( event, true );\n  }\n\n  if ( result == editAction )\n    emit editGroupRequested();\n  else\n  if ( result && result->data().value< void * >() )\n    ( ( QAction * )( result->data().value< void * >() ) )->trigger();\n\n  event->accept();\n}\n\nvoid DictionaryBar::mutedDictionariesChanged()\n{\n  //DPRINTF( \"Muted dictionaries changed\\n\" );\n\n  if( !mutedDictionaries )\n    return;\n\n  // Update actions\n\n  setUpdatesEnabled( false );\n\n  for( QList< QAction * >::iterator i = dictActions.begin();\n       i != dictActions.end(); ++i )\n  {\n    bool isUnmuted = !mutedDictionaries->contains( (*i)->data().toString() );\n\n    if ( isUnmuted != (*i)->isChecked() )\n      (*i)->setChecked( isUnmuted );\n  }\n\n  setUpdatesEnabled( true );\n}\n\nvoid DictionaryBar::actionWasTriggered( QAction * action )\n{\n  if( !mutedDictionaries )\n    return;\n\n  QString id = action->data().toString();\n\n  if ( id.isEmpty() )\n    return; // Some weird action, not our button\n\n  if ( QApplication::keyboardModifiers() &\n         ( Qt::ControlModifier | Qt::ShiftModifier ) )\n  {\n    // Solo mode -- either use the dictionary exclusively, or toggle\n    // back all dictionaries if we do that already.\n\n    // Are we solo already?\n\n    bool isSolo = true;\n\n    // For solo, all dictionaries must be unchecked, since we're handling\n    // the result of the dictionary being (un)checked, and in case we were\n    // in solo, now we would end up with no dictionaries being checked at all.\n    for( QList< QAction * >::iterator i = dictActions.begin();\n         i != dictActions.end(); ++i )\n    {\n      if ( (*i)->isChecked() )\n      {\n        isSolo = false;\n        break;\n      }\n    }\n\n    if ( isSolo )\n    {\n      // Restore or clear all the dictionaries\n      if ( QApplication::keyboardModifiers() & Qt::ShiftModifier )\n        *mutedDictionaries = storedMutedSet;\n      else\n      {\n        for( QList< QAction * >::iterator i = dictActions.begin();\n             i != dictActions.end(); ++i )\n          mutedDictionaries->remove( (*i)->data().toString() );\n      }\n      storedMutedSet.clear();\n    }\n    else\n    {\n      // Save dictionaries state\n      storedMutedSet = *mutedDictionaries;\n\n      // Make dictionary solo\n      for( QList< QAction * >::iterator i = dictActions.begin();\n           i != dictActions.end(); ++i )\n      {\n        QString dictId = (*i)->data().toString();\n\n        if ( dictId == id )\n          mutedDictionaries->remove( dictId );\n        else\n          mutedDictionaries->insert( dictId );\n      }\n    }  \n    configEvents.signalMutedDictionariesChanged();\n  }\n  else\n  {\n    // Normal mode\n\n    storedMutedSet.clear();\n\n    if ( action->isChecked() )\n    {\n      // Unmute the dictionary\n\n      if ( mutedDictionaries->contains( id ) )\n      {\n        mutedDictionaries->remove( id );\n        configEvents.signalMutedDictionariesChanged();\n      }\n    }\n    else\n    {\n      // Mute the dictionary\n\n      if ( !mutedDictionaries->contains( id ) )\n      {\n        mutedDictionaries->insert( id );\n        configEvents.signalMutedDictionariesChanged();\n      }\n    }\n  }\n}\n\nvoid DictionaryBar::dictsPaneClicked( const QString & id )\n{\n  if ( !isVisible() )\n    return;\n\n  for( QList< QAction * >::iterator i = dictActions.begin();\n       i != dictActions.end(); ++i )\n  {\n    QString dictId = (*i)->data().toString();\n    if ( dictId == id )\n    {\n      (*i)->activate( QAction::Trigger );\n      break;\n    }\n  }\n}\n\nbool DictionaryBar::eventFilter( QObject * obj, QEvent * ev )\n{\n  if(obj == this && !isFloating() )\n  {\n    QPoint pt = parentWidget()->mapFromGlobal( QCursor::pos() );\n    switch( ev->type() )\n    {\n      case QEvent::Leave : if( geometry().contains( pt ) )\n                           {\n                             if( timerId )\n                               killTimer( timerId );\n                             timerId = startTimer( 500 );\n                             return true;\n                           }\n                           break;\n     case QEvent::Enter :  if( timerId != 0)\n                           {\n                             killTimer( timerId );\n                             timerId = 0;\n                           }\n                           break;\n      case QEvent::Timer:  if( static_cast< QTimerEvent * >( ev )->timerId() == timerId )\n                           {\n                             if( !geometry().contains( pt ) )\n                             {\n                               killTimer( timerId );\n                               timerId = 0;\n                               QEvent event( QEvent::Leave );\n                               QApplication::sendEvent( this, &event );\n                             }\n                             return true;\n                           }\n                           break;\n      default:             break;\n    }\n  }\n  return false;\n}\n"
        },
        {
          "name": "dictionarybar.hh",
          "type": "blob",
          "size": 2.4072265625,
          "content": "#ifndef __DICTIONARYBAR_HH_INCLUDED__\n#define __DICTIONARYBAR_HH_INCLUDED__\n\n#include <QToolBar>\n#include <QSize>\n#include <QList>\n#include <QString>\n#include <QTimer>\n#include \"dictionary.hh\"\n#include \"config.hh\"\n\n/// A bar containing dictionary icons of the currently chosen group.\n/// Individual dictionaries can be toggled on and off.\nclass DictionaryBar: public QToolBar\n{\n  Q_OBJECT\n\npublic:\n\n  /// Constructs an empty dictionary bar\n  DictionaryBar( QWidget * parent,\n                 Config::Events &, QString const & _editDictionaryCommand, unsigned short const & maxDictionaryRefsInContextMenu_ );\n\n  /// Sets dictionaries to be displayed in the bar. Their statuses (enabled/\n  /// disabled) are taken from the configuration data.\n  void setDictionaries( std::vector< sptr< Dictionary::Class > > const & );\n  void setMutedDictionaries( Config::MutedDictionaries * mutedDictionaries_ )\n  { mutedDictionaries = mutedDictionaries_; }\n  Config::MutedDictionaries const * getMutedDictionaries() const\n  { return mutedDictionaries; }\n  void setDictionaryIconSize( int extent );\n\nsignals:\n\n  /// Signalled when the user decided to edit group the bar currently\n  /// shows.\n  void editGroupRequested();\n\n  /// Signal for show dictionary info command from context menu\n  void showDictionaryInfo( QString const & id );\n\n  /// Signal for show dictionary headwords command from context menu\n  void showDictionaryHeadwords( QString const & id );\n\n  /// Signal for open dictionary folder from context menu\n  void openDictionaryFolder( QString const & id );\n\n  /// Signal to close context menu\n  void closePopupMenu();\n\nprivate:\n\n  Config::MutedDictionaries * mutedDictionaries;\n  Config::Events & configEvents;\n  Config::MutedDictionaries storedMutedSet;\n  QString editDictionaryCommand;\n  // how many dictionaries should be shown in the context menu:\n  unsigned short const & maxDictionaryRefsInContextMenu;\n  std::vector< sptr< Dictionary::Class > > allDictionaries;\n  /// All the actions we have added to the toolbar\n  QList< QAction * > dictActions;\n  QAction * maxDictionaryRefsAction;\n\n  bool use14x21;\n  int timerId;\n\n  virtual bool eventFilter( QObject *, QEvent * );\n\nprotected:\n\n  void contextMenuEvent( QContextMenuEvent * event );\n\nprivate slots:\n\n  void mutedDictionariesChanged();\n\n  void actionWasTriggered( QAction * );\n\n  void dictsPaneClicked( QString const & );\n\n  void showContextMenu( QContextMenuEvent * event, bool extended = false );\n};\n\n#endif\n"
        },
        {
          "name": "dictserver.cc",
          "type": "blob",
          "size": 27.8916015625,
          "content": "/* This file is (c) 2014 Abs62\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"dictserver.hh\"\n#include \"wstring_qt.hh\"\n#include <QUrl>\n#include <QTcpSocket>\n#include <QString>\n#include <list>\n#include \"gddebug.hh\"\n#include \"htmlescape.hh\"\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n#include <QRegularExpression>\n#endif\n\nnamespace DictServer {\n\nusing namespace Dictionary;\n\nenum {\n  DefaultPort = 2628\n};\n\nnamespace {\n\n#define MAX_MATCHES_COUNT 60\n\nbool readLine( QTcpSocket & socket, QString & line,\n               QString & errorString, QAtomicInt & isCancelled )\n{\n  line.clear();\n  errorString.clear();\n  if( socket.state() != QTcpSocket::ConnectedState )\n    return false;\n\n  for( ; ; )\n  {\n    if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      return false;\n\n    if( socket.canReadLine() )\n    {\n      QByteArray reply = socket.readLine();\n      line = QString::fromUtf8( reply.data(), reply.size() );\n      return true;\n    }\n\n    if( !socket.waitForReadyRead( 2000 ) )\n    {\n      errorString = \"Data reading error: socket error \" + QString::number( socket.error() )\n                    + \": \\\"\" + socket.errorString() + \"\\\"\";\n      break;\n    }\n  }\n  return false;\n}\n\nbool connectToServer( QTcpSocket & socket, QString const & url,\n                      QString & errorString, QAtomicInt & isCancelled )\n{\n  QUrl serverUrl( url );\n  quint16 port = serverUrl.port( DefaultPort );\n  QString reply;\n\n  for( ; ; )\n  {\n    if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      return false;\n\n    socket.connectToHost( serverUrl.host(), port );\n\n    if( socket.state() != QTcpSocket::ConnectedState )\n    {\n      if( !socket.waitForConnected( 5000 ) )\n        break;\n    }\n\n    if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      return false;\n\n    if( !readLine( socket, reply, errorString, isCancelled ) )\n      break;\n\n    if( !reply.isEmpty() && reply.left( 3 ) != \"220\" )\n    {\n      errorString = \"Server refuse connection: \" + reply;\n      return false;\n    }\n\n    QString msgId = reply.mid( reply.lastIndexOf(\" \") ).trimmed();\n\n    socket.write( QByteArray( \"CLIENT GoldenDict\\r\\n\") );\n    if( !socket.waitForBytesWritten( 1000 ) )\n      break;\n\n    if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      return false;\n\n    if( !readLine( socket, reply, errorString, isCancelled ) )\n      break;\n\n    if( !serverUrl.userInfo().isEmpty() )\n    {\n      QString authCommand = QString( \"AUTH \" );\n      QString authString = msgId;\n\n      int pos = serverUrl.userInfo().indexOf( QRegExp( \"[:;]\" ) );\n      if( pos > 0 )\n      {\n        authCommand += serverUrl.userInfo().left( pos );\n        authString += serverUrl.userInfo().mid( pos + 1 );\n      }\n      else\n        authCommand += serverUrl.userInfo();\n\n      authCommand += \" \";\n      authCommand += QCryptographicHash::hash( authString.toUtf8(), QCryptographicHash::Md5 ).toHex();\n      authCommand += \"\\r\\n\";\n\n      socket.write( authCommand.toUtf8() );\n\n      if( !socket.waitForBytesWritten( 1000 ) )\n        break;\n\n      if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n        return false;\n\n      if( !readLine( socket, reply, errorString, isCancelled ) )\n        break;\n\n      if( reply.left( 3 ) != \"230\" )\n      {\n        errorString = \"Authentication error: \" + reply;\n        return false;\n      }\n    }\n\n    socket.write( QByteArray( \"OPTION MIME\\r\\n\" ) );\n\n    if( !socket.waitForBytesWritten( 1000 ) )\n      break;\n\n    if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      return false;\n\n    if( !readLine( socket, reply, errorString, isCancelled ) )\n      break;\n\n    if( reply.left( 3 ) != \"250\" )\n    {\n      // RFC 2229, 3.10.1.1:\n      // OPTION MIME is a REQUIRED server capability,\n      // all DICT servers MUST implement this command.\n      errorString = \"Server doesn't support mime capability: \" + reply;\n      return false;\n    }\n\n    return true;\n  }\n\n  if( !Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    errorString = QString( \"Server connection fault, socket error %1: \\\"%2\\\"\" )\n                  .arg( QString::number( socket.error() ) )\n                  .arg( socket.errorString() );\n  return false;\n}\n\nvoid disconnectFromServer( QTcpSocket & socket )\n{\n  if( socket.state() == QTcpSocket::ConnectedState )\n    socket.write( QByteArray( \"QUIT\\r\\n\" ) );\n\n  socket.disconnectFromHost();\n}\n\nclass DictServerDictionary: public Dictionary::Class\n{\n  string name;\n  QString url, icon;\n  quint32 langId;\n  QString errorString;\n  QTcpSocket socket;\n  QStringList databases;\n  QStringList strategies;\n  QStringList serverDatabases;\n\npublic:\n\n  DictServerDictionary( string const & id, string const & name_,\n                        QString const & url_,\n                        QString const & database_,\n                        QString const & strategies_,\n                        QString const & icon_ ):\n    Dictionary::Class( id, vector< string >() ),\n    name( name_ ),\n    url( url_ ),\n    icon( icon_ ),\n    langId( 0 )\n  {\n    int pos = url.indexOf( \"://\" );\n    if( pos < 0 )\n      url = \"dict://\" + url;\n\n    databases = database_.split( QRegExp( \"[ ,;]\" ), Qt4x5::skipEmptyParts() );\n    if( databases.isEmpty() )\n      databases.append( \"*\" );\n\n    strategies = strategies_.split( QRegExp( \"[ ,;]\" ), Qt4x5::skipEmptyParts() );\n    if( strategies.isEmpty() )\n      strategies.append( \"prefix\" );\n  }\n\n  virtual string getName() throw()\n  { return name; }\n\n  virtual map< Property, string > getProperties() throw()\n  { return map< Property, string >(); }\n\n  virtual unsigned long getArticleCount() throw()\n  { return 0; }\n\n  virtual unsigned long getWordCount() throw()\n  { return 0; }\n\n  virtual sptr< WordSearchRequest > prefixMatch( wstring const &,\n                                                 unsigned long maxResults ) THROW_SPEC( std::exception );\n\n  virtual sptr< DataRequest > getArticle( wstring const &, vector< wstring > const & alts,\n                                          wstring const &, bool )\n    THROW_SPEC( std::exception );\n\n  virtual quint32 getLangFrom() const\n  { return langId; }\n\n  virtual quint32 getLangTo() const\n  { return langId; }\n\n  virtual QString const & getDescription();\nprotected:\n\n  virtual void loadIcon() throw();\n\n  void getServerDatabases();\n\n  friend class DictServerWordSearchRequest;\n  friend class DictServerArticleRequest;\n};\n\nvoid DictServerDictionary::loadIcon() throw()\n{\n  if ( dictionaryIconLoaded )\n    return;\n\n  if( !icon.isEmpty() )\n  {\n    QFileInfo fInfo(  QDir( Config::getConfigDir() ), icon );\n    if( fInfo.isFile() )\n      loadIconFromFile( fInfo.absoluteFilePath(), true );\n  }\n  if( dictionaryIcon.isNull() )\n    dictionaryIcon = dictionaryNativeIcon = QIcon(\":/icons/network.png\");\n  dictionaryIconLoaded = true;\n}\n\nQString const & DictServerDictionary::getDescription()\n{\n  if( serverDatabases.isEmpty() )\n  {\n    dictionaryDescription.clear();\n    getServerDatabases();\n  }\n\n  if( dictionaryDescription.isEmpty() )\n  {\n    dictionaryDescription = QCoreApplication::translate( \"DictServer\", \"Url: \" ) + url + \"\\n\";\n    dictionaryDescription += QCoreApplication::translate( \"DictServer\", \"Databases: \" ) + databases.join( \", \" ) + \"\\n\";\n    dictionaryDescription += QCoreApplication::translate( \"DictServer\", \"Search strategies: \" ) + strategies.join( \", \" );\n    if( !serverDatabases.isEmpty() )\n    {\n      dictionaryDescription += \"\\n\\n\";\n      dictionaryDescription += QCoreApplication::translate( \"DictServer\", \"Server databases\" )\n                               + \" (\" + QString::number( serverDatabases.size()) + \"):\";\n      for( QStringList::const_iterator i = serverDatabases.begin(); i != serverDatabases.end(); ++i )\n        dictionaryDescription += \"\\n\" + *i;\n    }\n  }\n  return dictionaryDescription;\n}\n\nvoid DictServerDictionary::getServerDatabases()\n{\n  QAtomicInt isCancelled;\n  QTcpSocket * socket = new QTcpSocket;\n\n  if( !socket )\n    return;\n\n  if( connectToServer( *socket, url, errorString, isCancelled ) )\n  {\n    for( ; ; )\n    {\n      QString req = QString( \"SHOW DB\\r\\n\" );\n      socket->write( req.toUtf8() );\n      socket->waitForBytesWritten( 1000 );\n\n      QString reply;\n\n      if( !readLine( *socket, reply, errorString, isCancelled ) )\n        return;\n\n      if( reply.left( 3 ) == \"110\" )\n      {\n        int countPos = reply.indexOf( ' ', 4 );\n        // Get databases count\n        int count = reply.mid( 4, countPos > 4 ? countPos - 4 : -1 ).toInt();\n\n        // Read databases\n        for( int x = 0; x < count; x++ )\n        {\n          if( !readLine( *socket, reply, errorString, isCancelled ) )\n             break;\n\n          if( reply[ 0 ] == '.' )\n            break;\n\n          while( reply.endsWith( '\\r' ) || reply.endsWith( '\\n' ) )\n            reply.chop( 1 );\n\n          if( !reply.isEmpty() )\n            serverDatabases.append( reply );\n        }\n\n        break;\n      }\n      else\n      {\n        gdWarning( \"Retrieving databases from \\\"%s\\\" fault: %s\\n\",\n                   getName().c_str(), reply.toUtf8().data() );\n        break;\n      }\n    }\n    disconnectFromServer( *socket );\n  }\n\n  if( !errorString.isEmpty() )\n    gdWarning( \"Retrieving databases from \\\"%s\\\" fault: %s\\n\",\n               getName().c_str(), errorString.toUtf8().data() );\n  delete socket;\n}\n\nclass DictServerWordSearchRequest;\n\nclass DictServerWordSearchRequestRunnable: public QRunnable\n{\n  DictServerWordSearchRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  DictServerWordSearchRequestRunnable( DictServerWordSearchRequest & r_,\n                                       QSemaphore & hasExited_ ): r( r_ ),\n                                       hasExited( hasExited_ )\n  {}\n\n  ~DictServerWordSearchRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass DictServerWordSearchRequest: public Dictionary::WordSearchRequest\n{\n  QAtomicInt isCancelled;\n  wstring word;\n  QString errorString;\n  QSemaphore hasExited;\n  DictServerDictionary & dict;\n  QTcpSocket * socket;\n\npublic:\n\n  DictServerWordSearchRequest( wstring const & word_,\n                               DictServerDictionary & dict_ ) :\n    word( word_ ),\n    dict( dict_ ),\n    socket( 0 )\n  {\n    QThreadPool::globalInstance()->start(\n      new DictServerWordSearchRequestRunnable( *this, hasExited ) );\n  }\n\n  void run();\n\n  ~DictServerWordSearchRequest()\n  {\n    hasExited.acquire();\n  }\n\n  virtual void cancel();\n\n};\n\nvoid DictServerWordSearchRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid DictServerWordSearchRequest::run()\n{\n  if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  socket = new QTcpSocket;\n\n  if( !socket )\n  {\n    finish();\n    return;\n  }\n\n  if( connectToServer( *socket, dict.url, errorString, isCancelled ) )\n  {\n    QStringList matchesList;\n\n    for( int ns = 0; ns < dict.strategies.size(); ns++ )\n    {\n      for( int i = 0; i < dict.databases.size(); i++ )\n      {\n        QString matchReq = QString( \"MATCH \" )\n                           + dict.databases.at( i )\n                           + \" \" + dict.strategies.at( ns )\n                           + \" \\\"\" + gd::toQString( word )\n                           + \"\\\"\\r\\n\";\n        socket->write( matchReq.toUtf8() );\n        socket->waitForBytesWritten( 1000 );\n\n        if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n          break;\n\n        QString reply;\n\n        if( !readLine( *socket, reply, errorString, isCancelled ) )\n          break;\n\n        if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n          break;\n\n        if( reply.left( 3 ) == \"250\" )\n        {\n          // \"OK\" reply - matches info will be later\n          if( !readLine( *socket, reply, errorString, isCancelled ) )\n            break;\n\n          if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n            break;\n        }\n\n        if( reply.left( 3 ) == \"552\" )\n        {\n          // No matches\n          continue;\n        }\n\n        if( reply[ 0 ] == '5' || reply[ 0 ] == '4' )\n        {\n          // Database error\n          gdWarning( \"Find matches in \\\"%s\\\", database \\\"%s\\\", strategy \\\"%s\\\" fault: %s\\n\",\n                     dict.getName().c_str(), dict.databases.at( i ).toUtf8().data(),\n                     dict.strategies.at( ns ).toUtf8().data(), reply.toUtf8().data() );\n          continue;\n        }\n\n        if( reply.left( 3 ) == \"152\" )\n        {\n          // Matches found\n          int countPos = reply.indexOf( ' ', 4 );\n\n          // Get matches count\n          int count = reply.mid( 4, countPos > 4 ? countPos - 4 : -1 ).toInt();\n\n          // Read matches\n          for( int x = 0; x <= count; x++ )\n          {\n            if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n              break;\n\n            if( !readLine( *socket, reply, errorString, isCancelled ) )\n              break;\n\n            if( reply[ 0 ] == '.' )\n              break;\n\n            while( reply.endsWith( '\\r' ) || reply.endsWith( '\\n' ) )\n              reply.chop( 1 );\n\n            int pos = reply.indexOf( ' ' );\n            if( pos >= 0 )\n            {\n              QString word = reply.mid( pos + 1 );\n              if( word.endsWith( '\\\"') )\n                word.chop( 1 );\n              if( word[ 0 ] ==  '\\\"' )\n                word = word.mid( 1 );\n\n              matchesList.append( word );\n            }\n          }\n          if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) || !errorString.isEmpty() )\n            break;\n        }\n      }\n\n      if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) || !errorString.isEmpty() )\n        break;\n\n      matchesList.removeDuplicates();\n      if( matchesList.size() >= MAX_MATCHES_COUNT )\n        break;\n    }\n\n    if( !Qt4x5::AtomicInt::loadAcquire( isCancelled ) && errorString.isEmpty() )\n    {\n      matchesList.removeDuplicates();\n\n      int count = matchesList.size();\n      if( count > MAX_MATCHES_COUNT )\n        count = MAX_MATCHES_COUNT;\n\n      if( count )\n      {\n        Mutex::Lock _( dataMutex );\n        for( int x = 0; x < count; x++ )\n          matches.push_back( gd::toWString( matchesList.at( x ) ) );\n      }\n    }\n  }\n\n  if( !errorString.isEmpty() )\n    gdWarning( \"Prefix find in \\\"%s\\\" fault: %s\\n\", dict.getName().c_str(),\n                errorString.toUtf8().data() );\n\n  if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    socket->abort();\n  else\n    disconnectFromServer( *socket );\n\n  delete socket;\n  if( !Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    finish();\n}\n\nvoid DictServerWordSearchRequest::cancel()\n{\n  isCancelled.ref();\n\n  Mutex::Lock _( dataMutex );\n  finish();\n}\n\nclass DictServerArticleRequest;\n\nclass DictServerArticleRequestRunnable: public QRunnable\n{\n  DictServerArticleRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  DictServerArticleRequestRunnable( DictServerArticleRequest & r_,\n                                    QSemaphore & hasExited_ ): r( r_ ),\n                                    hasExited( hasExited_ )\n  {}\n\n  ~DictServerArticleRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass DictServerArticleRequest: public Dictionary::DataRequest\n{\n  QAtomicInt isCancelled;\n  wstring word;\n  QString errorString;\n  QSemaphore hasExited;\n  DictServerDictionary & dict;\n  QTcpSocket * socket;\n\npublic:\n\n  DictServerArticleRequest( wstring const & word_,\n                            DictServerDictionary & dict_ ) :\n    word( word_ ),\n    dict( dict_ ),\n    socket( 0 )\n  {\n    QThreadPool::globalInstance()->start(\n      new DictServerArticleRequestRunnable( *this, hasExited ) );\n  }\n\n  void run();\n\n  ~DictServerArticleRequest()\n  {\n    hasExited.acquire();\n  }\n\n  virtual void cancel();\n\n};\n\nvoid DictServerArticleRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid DictServerArticleRequest::run()\n{\n  if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  socket = new QTcpSocket;\n\n  if( !socket )\n  {\n    finish();\n    return;\n  }\n\n  if( connectToServer( *socket, dict.url, errorString, isCancelled ) )\n  {\n    string articleData;\n\n    for( int i = 0; i < dict.databases.size(); i++ )\n    {\n      QString defineReq = QString( \"DEFINE \" )\n                         + dict.databases.at( i )\n                         + \" \\\"\" + gd::toQString( word ) + \"\\\"\\r\\n\";\n      socket->write( defineReq.toUtf8() );\n      socket->waitForBytesWritten( 1000 );\n\n      QString reply;\n\n      if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n        break;\n\n      if( !readLine( *socket, reply, errorString, isCancelled ) )\n        break;\n\n      if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n        break;\n\n      if( reply.left( 3 ) == \"250\" )\n      {\n        // \"OK\" reply - matches info will be later\n        if( !readLine( *socket, reply, errorString, isCancelled ) )\n          break;\n\n        if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n          break;\n      }\n\n      if( reply.left( 3 ) == \"552\" )\n      {\n        // No matches found\n        continue;\n      }\n\n      if( reply[ 0 ] == '5' || reply[ 0 ] == '4' )\n      {\n        // Database error\n        gdWarning( \"Articles request from \\\"%s\\\", database \\\"%s\\\" fault: %s\\n\",\n                   dict.getName().c_str(), dict.databases.at( i ).toUtf8().data(),\n                   reply.toUtf8().data() );\n        continue;\n      }\n\n      if( reply.left( 3 ) == \"150\" )\n      {\n        // Articles found\n        int countPos = reply.indexOf( ' ', 4 );\n\n        QString articleText;\n\n        // Get articles count\n        int count = reply.mid( 4, countPos > 4 ? countPos - 4 : -1 ).toInt();\n\n        // Read articles\n        for( int x = 0; x < count; x++ )\n        {\n          if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n            break;\n\n          if( !readLine( *socket, reply, errorString, isCancelled ) )\n            break;\n\n          if( reply.left( 3 ) == \"250\" )\n            break;\n\n          if( reply.left( 3 ) == \"151\" )\n          {\n            int pos = 4;\n            int endPos;\n\n            // Skip requested word\n            if( reply[ pos ] == '\\\"' )\n              endPos = reply.indexOf( '\\\"', pos + 1 ) + 1;\n            else\n              endPos = reply.indexOf( ' ', pos );\n\n            if( endPos < pos )\n            {\n              // It seems mailformed string\n              break;\n            }\n\n            pos = endPos + 1;\n\n            QString dbID, dbName;\n\n            // Retrieve database ID\n            endPos = reply.indexOf( ' ', pos );\n\n            if( endPos < pos )\n            {\n              // It seems mailformed string\n              break;\n            }\n\n            dbID = reply.mid( pos, endPos - pos );\n\n            // Retrieve database ID\n            pos = endPos + 1;\n            endPos = reply.indexOf( ' ', pos );\n            if( reply[ pos ] == '\\\"' )\n              endPos = reply.indexOf( '\\\"', pos + 1 ) + 1;\n            else\n              endPos = reply.indexOf( ' ', pos );\n\n            if( endPos < pos )\n            {\n              // It seems mailformed string\n              break;\n            }\n\n            dbName = reply.mid( pos, endPos - pos );\n            if( dbName.endsWith( '\\\"' ) )\n              dbName.chop( 1 );\n            if( dbName[ 0 ] == '\\\"' )\n              dbName = dbName.mid( 1 );\n\n            articleData += string( \"<div class=\\\"dictserver_from\\\">From \" )\n                           + dbName.toUtf8().data()\n                           + \" [\" + dbID.toUtf8().data() + \"]:\"\n                           + \"</div>\";\n\n            // Retreive MIME headers if any\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n            static QRegularExpression contentTypeExpr( \"Content-Type\\\\s*:\\\\s*text/html\",\n                                                       QRegularExpression::CaseInsensitiveOption );\n#else\n            QRegExp contentTypeExpr( \"Content-Type\\\\s*:\\\\s*text/html\", Qt::CaseInsensitive );\n#endif\n            bool contentInHtml = false;\n            for( ; ; )\n            {\n              if( !readLine( *socket, reply, errorString, isCancelled ) )\n                break;\n\n              if( reply == \"\\r\\n\" )\n                break;\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n              QRegularExpressionMatch match = contentTypeExpr.match( reply );\n              if( match.hasMatch() )\n                contentInHtml = true;\n#else\n              if( contentTypeExpr.indexIn( reply ) >= 0 )\n                contentInHtml = true;\n#endif\n            }\n\n            // Retrieve article text\n\n            articleText.clear();\n            for( ; ; )\n            {\n              if( !readLine( *socket, reply, errorString, isCancelled ) )\n                break;\n\n              if( reply == \".\\r\\n\" )\n                break;\n\n              articleText += reply;\n            }\n\n            if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) || !errorString.isEmpty() )\n              break;\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n            static QRegularExpression phonetic( \"\\\\\\\\([^\\\\\\\\]+)\\\\\\\\\",\n                                                QRegularExpression::CaseInsensitiveOption ); // phonetics: \\stuff\\ ...\n            static QRegularExpression divs_inside_phonetic( \"</div([^>]*)><div([^>]*)>\",\n                                                            QRegularExpression::CaseInsensitiveOption );\n            static QRegularExpression refs( \"\\\\{([^\\\\{\\\\}]+)\\\\}\",\n                                            QRegularExpression::CaseInsensitiveOption );     // links: {stuff}\n            static QRegularExpression links( \"<a href=\\\"gdlookup://localhost/([^\\\"]*)\\\">\",\n                                             QRegularExpression::CaseInsensitiveOption );\n            static QRegularExpression tags( \"<[^>]*>\",\n                                            QRegularExpression::CaseInsensitiveOption );\n#else\n            QRegExp phonetic( \"\\\\\\\\([^\\\\\\\\]+)\\\\\\\\\", Qt::CaseInsensitive ); // phonetics: \\stuff\\ ...\n            QRegExp divs_inside_phonetic( \"</div([^>]*)><div([^>]*)>\", Qt::CaseInsensitive );\n            QRegExp refs( \"\\\\{([^\\\\{\\\\}]+)\\\\}\", Qt::CaseInsensitive );     // links: {stuff}\n            QRegExp links( \"<a href=\\\"gdlookup://localhost/([^\\\"]*)\\\">\", Qt::CaseInsensitive );\n            QRegExp tags( \"<[^>]*>\", Qt::CaseInsensitive );\n#endif\n            string articleStr;\n            if( contentInHtml )\n              articleStr = articleText.toUtf8().data();\n            else\n              articleStr = Html::preformat( articleText.toUtf8().data() );\n\n            articleText = QString::fromUtf8( articleStr.c_str(), articleStr.size() );\n            if( !contentInHtml )\n            {\n              articleText = articleText.replace(refs, \"<a href=\\\"gdlookup://localhost/\\\\1\\\">\\\\1</a>\" );\n\n              pos = 0;\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n              QString articleNewText;\n\n              // Handle phonetics\n\n              QRegularExpressionMatchIterator it = phonetic.globalMatch( articleText );\n              while( it.hasNext() )\n              {\n                QRegularExpressionMatch match = it.next();\n                articleNewText += articleText.midRef( pos, match.capturedStart() - pos );\n                pos = match.capturedEnd();\n\n                QString phonetic_text = match.captured( 1 );\n                phonetic_text.replace( divs_inside_phonetic, \"</span></div\\\\1><div\\\\2><span class=\\\"dictd_phonetic\\\">\" );\n\n                articleNewText += \"<span class=\\\"dictd_phonetic\\\">\" + phonetic_text + \"</span>\";\n              }\n              if( pos )\n              {\n                articleNewText += articleText.midRef( pos );\n                articleText = articleNewText;\n                articleNewText.clear();\n              }\n\n              // Handle links\n\n              pos = 0;\n              it = links.globalMatch( articleText );\n              while( it.hasNext() )\n              {\n                QRegularExpressionMatch match = it.next();\n                articleNewText += articleText.midRef( pos, match.capturedStart() - pos );\n                pos = match.capturedEnd();\n\n                QString link = match.captured( 1 );\n                link.replace( tags, \" \" );\n                link.replace( \"&nbsp;\", \" \" );\n\n                QString newLink = match.captured();\n                newLink.replace( 30, match.capturedLength( 1 ),\n                                 QString::fromUtf8( QUrl::toPercentEncoding( link.simplified() ) ) );\n                articleNewText += newLink;\n              }\n              if( pos )\n              {\n                articleNewText += articleText.midRef( pos );\n                articleText = articleNewText;\n                articleNewText.clear();\n              }\n#else\n              // Handle phonetics\n\n              for( ; ; )\n              {\n                pos = articleText.indexOf( phonetic, pos );\n                if( pos < 0 )\n                  break;\n\n                QString phonetic_text = phonetic.cap( 1 );\n                phonetic_text.replace( divs_inside_phonetic, \"</span></div\\\\1><div\\\\2><span class=\\\"dictd_phonetic\\\">\" );\n                phonetic_text = \"<span class=\\\"dictd_phonetic\\\">\" + phonetic_text + \"</span>\";\n                articleText.replace( pos, phonetic.cap().length(), phonetic_text );\n                pos += phonetic_text.length();\n              }\n\n              // Handle links\n\n              pos = 0;\n              for( ; ; )\n              {\n                pos = articleText.indexOf( links, pos );\n                if( pos < 0 )\n                  break;\n\n                QString link = links.cap( 1 );\n                link.replace( tags, \" \" );\n                link.replace( \"&nbsp;\", \" \" );\n                articleText.replace( pos + 30, links.cap( 1 ).length(),\n                                     QString::fromUtf8( QUrl::toPercentEncoding( link.simplified() ) ) );\n                pos += 30;\n              }\n#endif\n            }\n\n            articleData += string( \"<div class=\\\"dictd_article\\\">\" )\n                           + articleText.toUtf8().data()\n                           + \"<br></div>\";\n          }\n\n          if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) || !errorString.isEmpty() )\n            break;\n        }\n      }\n    }\n    if( !Qt4x5::AtomicInt::loadAcquire( isCancelled ) && errorString.isEmpty() && !articleData.empty() )\n    {\n      Mutex::Lock _( dataMutex );\n\n      data.resize( articleData.size() );\n      memcpy( &data.front(), articleData.data(), articleData.size() );\n\n      hasAnyData = true;\n    }\n  }\n\n  if( !errorString.isEmpty() )\n    gdWarning( \"Articles request from \\\"%s\\\" fault: %s\\n\", dict.getName().c_str(),\n                errorString.toUtf8().data() );\n\n  if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    socket->abort();\n  else\n    disconnectFromServer( *socket );\n\n  delete socket;\n  if( !Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    finish();\n}\n\nvoid DictServerArticleRequest::cancel()\n{\n  isCancelled.ref();\n\n  Mutex::Lock _( dataMutex );\n  finish();\n}\n\nsptr< WordSearchRequest > DictServerDictionary::prefixMatch( wstring const & word,\n                                                             unsigned long maxResults )\n  THROW_SPEC( std::exception )\n{\n  (void) maxResults;\n  if ( word.size() > 80 )\n  {\n    // Don't make excessively large queries -- they're fruitless anyway\n\n    return new WordSearchRequestInstant();\n  }\n  else\n    return new DictServerWordSearchRequest( word, *this );\n}\n\nsptr< DataRequest > DictServerDictionary::getArticle( wstring const & word,\n                                                      vector< wstring > const &,\n                                                      wstring const &, bool )\n  THROW_SPEC( std::exception )\n{\n  if ( word.size() > 80 )\n  {\n    // Don't make excessively large queries -- they're fruitless anyway\n\n    return new DataRequestInstant( false );\n  }\n  else\n    return new DictServerArticleRequest( word, *this );\n}\n\n} // Anonimuos namespace\n\nvector< sptr< Dictionary::Class > > makeDictionaries( Config::DictServers const & servers )\n  THROW_SPEC( std::exception )\n{\n  vector< sptr< Dictionary::Class > > result;\n\n  for( int x = 0; x < servers.size(); ++x )\n  {\n    if ( servers[ x ].enabled )\n      result.push_back( new DictServerDictionary( servers[ x ].id.toStdString(),\n                                                  servers[ x ].name.toUtf8().data(),\n                                                  servers[ x ].url,\n                                                  servers[ x ].databases,\n                                                  servers[ x ].strategies,\n                                                  servers[ x ].iconFilename  ) );\n  }\n\n  return result;\n}\n\n} // namespace DictServer\n"
        },
        {
          "name": "dictserver.hh",
          "type": "blob",
          "size": 0.4287109375,
          "content": "#ifndef __DICTSERVER_HH__INCLUDED__\n#define __DICTSERVER_HH__INCLUDED__\n\n#include \"dictionary.hh\"\n#include \"config.hh\"\n\n/// Support for servers supporting DICT protocol.\nnamespace DictServer {\n\nusing std::vector;\nusing std::string;\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      Config::DictServers const & servers )\n    THROW_SPEC( std::exception );\n\n}\n\n#endif // __DICTSERVER_HH__INCLUDED__\n"
        },
        {
          "name": "dictspanewidget.hh",
          "type": "blob",
          "size": 0.52734375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __DICTSPANEWIDGET_HH_INCLUDED__\n#define __DICTSPANEWIDGET_HH_INCLUDED__\n\n#include <QWidget>\n#include <QSize>\n\n/// A widget holding the contents of the 'Dictionaries pane' docklet.\nclass DictsPaneWidget: public QWidget\n{\n  Q_OBJECT\npublic:\n\n  DictsPaneWidget( QWidget * parent = 0 ): QWidget( parent )\n  {}\n\n  virtual QSize sizeHint() const\n  { return QSize( 204, 204 ); }\n\n};\n\n#endif\n"
        },
        {
          "name": "dictzip.c",
          "type": "blob",
          "size": 25.103515625,
          "content": "/* Made up from data.c and other supplementary files of dictd-1.0.11 for the\n * GoldenDict program.\n */\n\n/* data.c -- \n * Created: Tue Jul 16 12:45:41 1996 by faith@dict.org\n * Revised: Sat Mar 30 10:46:06 2002 by faith@dict.org\n * Copyright 1996, 1997, 1998, 2000, 2002 Rickard E. Faith (faith@dict.org)\n * \n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 1, or (at your option) any\n * later version.\n * \n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Suite 500, Boston, MA 02110, USA.\n */\n\n#include <stdlib.h>\n#include <time.h>\n#include \"dictzip.h\"\n#include <limits.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"ufile.hh\"\n\n#define BUFFERSIZE 10240\n\n#define OUT_BUFFER_SIZE 0xffffL\n\n#define IN_BUFFER_SIZE ((unsigned long)((double)(OUT_BUFFER_SIZE - 12) * 0.89))\n\n/* For gzip-compatible header, as defined in RFC 1952 */\n\n\t\t\t\t/* Magic for GZIP (rfc1952)                */\n#define GZ_MAGIC1     0x1f\t/* First magic byte                        */\n#define GZ_MAGIC2     0x8b\t/* Second magic byte                       */\n\n\t\t\t\t/* FLaGs (bitmapped), from rfc1952         */\n#define GZ_FTEXT      0x01\t/* Set for ASCII text                      */\n#define GZ_FHCRC      0x02\t/* Header CRC16                            */\n#define GZ_FEXTRA     0x04\t/* Optional field (random access index)    */\n#define GZ_FNAME      0x08\t/* Original name                           */\n#define GZ_COMMENT    0x10\t/* Zero-terminated, human-readable comment */\n#define GZ_MAX           2\t/* Maximum compression                     */\n#define GZ_FAST          4\t/* Fasted compression                      */\n\n\t\t\t\t/* These are from rfc1952                  */\n#define GZ_OS_FAT        0\t/* FAT filesystem (MS-DOS, OS/2, NT/Win32) */\n#define GZ_OS_AMIGA      1\t/* Amiga                                   */\n#define GZ_OS_VMS        2\t/* VMS (or OpenVMS)                        */\n#define GZ_OS_UNIX       3      /* Unix                                    */\n#define GZ_OS_VMCMS      4      /* VM/CMS                                  */\n#define GZ_OS_ATARI      5      /* Atari TOS                               */\n#define GZ_OS_HPFS       6      /* HPFS filesystem (OS/2, NT)              */\n#define GZ_OS_MAC        7      /* Macintosh                               */\n#define GZ_OS_Z          8      /* Z-System                                */\n#define GZ_OS_CPM        9      /* CP/M                                    */\n#define GZ_OS_TOPS20    10      /* TOPS-20                                 */\n#define GZ_OS_NTFS      11      /* NTFS filesystem (NT)                    */\n#define GZ_OS_QDOS      12      /* QDOS                                    */\n#define GZ_OS_ACORN     13      /* Acorn RISCOS                            */\n#define GZ_OS_UNKNOWN  255      /* unknown                                 */\n\n#define GZ_RND_S1       'R'\t/* First magic for random access format    */\n#define GZ_RND_S2       'A'\t/* Second magic for random access format   */\n\n#define GZ_ID1           0\t/* GZ_MAGIC1                               */\n#define GZ_ID2           1\t/* GZ_MAGIC2                               */\n#define GZ_CM            2\t/* Compression Method (Z_DEFALTED)         */\n#define GZ_FLG\t         3\t/* FLaGs (see above)                       */\n#define GZ_MTIME         4\t/* Modification TIME                       */\n#define GZ_XFL           8\t/* eXtra FLags (GZ_MAX or GZ_FAST)         */\n#define GZ_OS            9\t/* Operating System                        */\n#define GZ_XLEN         10\t/* eXtra LENgth (16bit)                    */\n#define GZ_FEXTRA_START 12\t/* Start of extra fields                   */\n#define GZ_SI1          12\t/* Subfield ID1                            */\n#define GZ_SI2          13      /* Subfield ID2                            */\n#define GZ_SUBLEN       14\t/* Subfield length (16bit)                 */\n#define GZ_VERSION      16      /* Version for subfield format             */\n#define GZ_CHUNKLEN     18\t/* Chunk length (16bit)                    */\n#define GZ_CHUNKCNT     20\t/* Number of chunks (16bit)                */\n#define GZ_RNDDATA      22\t/* Random access data (16bit)              */\n\n\n#define DBG_VERBOSE     (0<<30|1<< 0) /* Verbose                            */\n#define DBG_ZIP         (0<<30|1<< 1) /* Zip                                */\n#define DBG_UNZIP       (0<<30|1<< 2) /* Unzip                              */\n#define DBG_SEARCH      (0<<30|1<< 3) /* Search                             */\n#define DBG_SCAN        (0<<30|1<< 4) /* Config file scan                   */\n#define DBG_PARSE       (0<<30|1<< 5) /* Config file parse                  */\n#define DBG_INIT        (0<<30|1<< 6) /* Database initialization            */\n#define DBG_PORT        (0<<30|1<< 7) /* Log port number for connections    */\n#define DBG_LEV         (0<<30|1<< 8) /* Levenshtein matching               */\n#define DBG_AUTH        (0<<30|1<< 9) /* Debug authentication               */\n#define DBG_NODETACH    (0<<30|1<<10) /* Don't detach as a background proc. */\n#define DBG_NOFORK      (0<<30|1<<11) /* Don't fork (single threaded)       */\n#define DBG_ALT         (0<<30|1<<12) /* altcompare()                      */\n\n#define LOG_SERVER      (0<<30|1<< 0) /* Log server diagnostics             */\n#define LOG_CONNECT     (0<<30|1<< 1) /* Log connection information         */\n#define LOG_STATS       (0<<30|1<< 2) /* Log termination information        */\n#define LOG_COMMAND     (0<<30|1<< 3) /* Log commands                       */\n#define LOG_FOUND       (0<<30|1<< 4) /* Log words found                    */\n#define LOG_NOTFOUND    (0<<30|1<< 5) /* Log words not found                */\n#define LOG_CLIENT      (0<<30|1<< 6) /* Log client                         */\n#define LOG_HOST        (0<<30|1<< 7) /* Log remote host name               */\n#define LOG_TIMESTAMP   (0<<30|1<< 8) /* Log with timestamps                */\n#define LOG_MIN         (0<<30|1<< 9) /* Log a few minimal things           */\n#define LOG_AUTH        (0<<30|1<<10) /* Log authentication denials         */\n\n#define DICT_LOG_TERM    0\n#define DICT_LOG_DEFINE  1\n#define DICT_LOG_MATCH   2\n#define DICT_LOG_NOMATCH 3\n#define DICT_LOG_CLIENT  4\n#define DICT_LOG_TRACE   5\n#define DICT_LOG_COMMAND 6\n#define DICT_LOG_AUTH    7\n#define DICT_LOG_CONNECT 8\n\n#define DICT_UNKNOWN    0\n#define DICT_TEXT       1\n#define DICT_GZIP       2\n#define DICT_DZIP       3\n\n#include <ctype.h>\n#include <fcntl.h>\n#include <assert.h>\n\n#include <sys/stat.h>\n\n#define USE_CACHE 1\n\n#define dict_data_filter( ... )\n#define PRINTF( ... )\n\n#define xmalloc malloc\n#define xfree free\n\nstatic const char * _err_programName = \"GoldenDict\";\n\n#define log_error( ... )\n#define log_error_va( ... )\n\nstatic void err_fatal( const char *routine, const char *format, ... )\n{\n   va_list ap;\n\n   fflush( stdout );\n   if (_err_programName) {\n      if (routine)\n\t fprintf( stderr, \"%s (%s): \", _err_programName, routine );\n      else\n\t fprintf( stderr, \"%s: \", _err_programName );\n   } else {\n      if (routine) fprintf( stderr, \"%s: \", routine );\n   }\n   \n   va_start( ap, format );\n   vfprintf( stderr, format, ap );\n   log_error_va( routine, format, ap );\n   va_end( ap );\n   \n   fflush( stderr );\n   fflush( stdout );\n//   exit ( 1 );\n}\n\n/* \\doc |err_fatal_errno| flushes \"stdout\", prints a fatal error report on\n   \"stderr\", prints the system error corresponding to |errno|, flushes\n   \"stderr\" and \"stdout\", and calls |exit|.  |routine| is the name of the\n   routine in which the error took place. */\n\nstatic void err_fatal_errno( const char *routine, const char *format, ... )\n{\n   va_list ap;\n   int     errorno = errno;\n\n   fflush( stdout );\n   if (_err_programName) {\n      if (routine)\n\t fprintf( stderr, \"%s (%s): \", _err_programName, routine );\n      else\n\t fprintf( stderr, \"%s: \", _err_programName );\n   } else {\n      if (routine) fprintf( stderr, \"%s: \", routine );\n   }\n   \n   va_start( ap, format );\n   vfprintf( stderr, format, ap );\n   log_error_va( routine, format, ap );\n   va_end( ap );\n\n#if HAVE_STRERROR\n   fprintf( stderr, \"%s: %s\\n\", routine, strerror( errorno ) );\n   log_error( routine, \"%s: %s\\n\", routine, strerror( errorno ) );\n#else\n   errno = errorno;\n   perror( routine );\n   log_error( routine, \"%s: errno = %d\\n\", routine, errorno );\n#endif\n   \n   fflush( stderr );\n   fflush( stdout );\n//   exit( 1 );\n}\n\n/* \\doc |err_internal| flushes \"stdout\", prints the fatal error message,\n   flushes \"stderr\" and \"stdout\", and calls |abort| so that a core dump is\n   generated. */\n\nstatic void err_internal( const char *routine, const char *format, ... )\n{\n  va_list ap;\n\n  fflush( stdout );\n  if (_err_programName) {\n     if (routine)\n  fprintf( stderr, \"%s (%s): Internal error\\n     \",\n     _err_programName, routine );\n     else\n  fprintf( stderr, \"%s: Internal error\\n     \", _err_programName );\n  } else {\n     if (routine) fprintf( stderr, \"%s: Internal error\\n     \", routine );\n     else         fprintf( stderr, \"Internal error\\n     \" );\n  }\n\n  va_start( ap, format );\n  vfprintf( stderr, format, ap );\n  log_error( routine, format, ap );\n  va_end( ap );\n\n  if (_err_programName)\n     fprintf( stderr, \"Aborting %s...\\n\", _err_programName );\n  else\n     fprintf( stderr, \"Aborting...\\n\" );\n  fflush( stderr );\n  fflush( stdout );\n//  abort();\n}\n\n#ifndef __func__\n# ifdef __FUNCTION__\n#  define __func__  __FUNCTION__\n# else\n#  define __func__  __FILE__\n# endif\n#endif\n\nstatic enum  DZ_ERRORS dict_read_header( const char *filename,\n\t\t\t\t\t dictData *header,\n\t\t\t\t\t int computeCRC )\n{\n   FILE          *str;\n   int           id1, id2, si1, si2;\n   char          buffer[BUFFERSIZE];\n   int           extraLength, subLength;\n   int           i;\n   char          *pt;\n   int           c;\n   struct stat   sb;\n   unsigned long crc   = crc32( 0L, Z_NULL, 0 );\n   int           count;\n   unsigned long offset;\n\n   if (!(str = gd_fopen( filename, \"rb\" )))\n   {\n      err_fatal_errno( __func__,\n\t\t       \"Cannot open data file \\\"%s\\\" for read\\n\", filename );\n      return DZ_ERR_OPENFILE;\n   }\n\n   header->filename     = NULL;//str_find( filename );\n   header->headerLength = GZ_XLEN - 1;\n   header->type         = DICT_UNKNOWN;\n   \n   id1                  = getc( str );\n   id2                  = getc( str );\n\n   if (id1 != GZ_MAGIC1 || id2 != GZ_MAGIC2) {\n      header->type = DICT_TEXT;\n      fstat( fileno( str ), &sb );\n      header->compressedLength = header->length = sb.st_size;\n      header->origFilename     = NULL;//str_find( filename );\n      header->mtime            = sb.st_mtime;\n      if (computeCRC) {\n\t rewind( str );\n\t while (!feof( str )) {\n\t    if ((count = fread( buffer, 1, BUFFERSIZE, str ))) {\n\t       crc = crc32( crc, (Bytef *)buffer, count );\n\t    }\n\t }\n      }\n      header->crc = crc;\n      fclose( str );\n      return DZ_NOERROR;\n   }\n   header->type = DICT_GZIP;\n   \n   header->method       = getc( str );\n   header->flags        = getc( str );\n   header->mtime        = getc( str ) <<  0;\n   header->mtime       |= getc( str ) <<  8;\n   header->mtime       |= getc( str ) << 16;\n   header->mtime       |= getc( str ) << 24;\n   header->extraFlags   = getc( str );\n   header->os           = getc( str );\n   \n   if (header->flags & GZ_FEXTRA) {\n      extraLength          = getc( str ) << 0;\n      extraLength         |= getc( str ) << 8;\n      header->headerLength += extraLength + 2;\n      si1                  = getc( str );\n      si2                  = getc( str );\n      \n      if (si1 == GZ_RND_S1 && si2 == GZ_RND_S2) {\n\t subLength            = getc( str ) << 0;\n\t subLength           |= getc( str ) << 8;\n\t header->version      = getc( str ) << 0;\n\t header->version     |= getc( str ) << 8;\n\t \n\t if (header->version != 1)\n\t {\n\t    err_internal( __func__,\n\t\t\t  \"dzip header version %d not supported\\n\",\n\t\t\t  header->version );\n\t    fclose( str );\n\t    return DZ_ERR_UNSUPPORTED_FORMAT;\n\t }\n   \n\t header->chunkLength  = getc( str ) << 0;\n\t header->chunkLength |= getc( str ) << 8;\n\t header->chunkCount   = getc( str ) << 0;\n\t header->chunkCount  |= getc( str ) << 8;\n\t \n\t if (header->chunkCount <= 0) {\n\t    fclose( str );\n\t    return DZ_ERR_INVALID_FORMAT;\n\t }\n\t header->chunks = xmalloc( sizeof( header->chunks[0] )\n\t\t\t\t   * header->chunkCount );\n         if( header->chunks == 0 )\n         {\n           fclose( str );\n           return DZ_ERR_NOMEMORY;\n         }\n\n         for (i = 0; i < header->chunkCount; i++) {\n\t    header->chunks[i]  = getc( str ) << 0;\n\t    header->chunks[i] |= getc( str ) << 8;\n\t }\n\t header->type = DICT_DZIP;\n      } else {\n\t fseek( str, header->headerLength, SEEK_SET );\n      }\n   }\n   \n   if (header->flags & GZ_FNAME) { /* FIXME! Add checking against header len */\n      pt = buffer;\n      while ((c = getc( str )) && c != EOF){\n\t *pt++ = c;\n\n\t if (pt == buffer + sizeof (buffer)){\n\t    err_fatal (\n\t       __func__,\n\t       \"too long FNAME field in dzip file \\\"%s\\\"\\n\", filename);\n\t    fclose( str );\n\t    if( header->chunks )\n\t      free( header->chunks );\n\t    return DZ_ERR_INVALID_FORMAT;\n\t }\n      }\n\n      *pt = '\\0';\n      header->origFilename = NULL;//str_find( buffer );\n      header->headerLength += strlen( buffer ) + 1;\n   } else {\n      header->origFilename = NULL;\n   }\n   \n   if (header->flags & GZ_COMMENT) { /* FIXME! Add checking for header len */\n      pt = buffer;\n      while ((c = getc( str )) && c != EOF){\n\t *pt++ = c;\n\n\t if (pt == buffer + sizeof (buffer)){\n\t    err_fatal (\n\t       __func__,\n\t       \"too long COMMENT field in dzip file \\\"%s\\\"\\n\", filename);\n\t    fclose( str );\n\t    if( header->chunks )\n\t      free( header->chunks );\n\t    return DZ_ERR_INVALID_FORMAT;\n\t }\n      }\n\n      *pt = '\\0';\n      header->comment = NULL;//str_find( buffer );\n      header->headerLength += strlen( buffer ) + 1;\n   } else {\n      header->comment = NULL;\n   }\n\n   if (header->flags & GZ_FHCRC) {\n      getc( str );\n      getc( str );\n      header->headerLength += 2;\n   }\n\n   if (ftell( str ) != header->headerLength + 1)\n   {\n      err_internal( __func__,\n\t\t    \"File position (%lu) != header length + 1 (%d)\\n\",\n\t\t    ftell( str ), header->headerLength + 1 );\n      fclose( str );\n      if( header->chunks )\n        free( header->chunks );\n      return DZ_ERR_INVALID_FORMAT;\n   }\n\n   fseek( str, -8, SEEK_END );\n   header->crc     = getc( str ) <<  0;\n   header->crc    |= getc( str ) <<  8;\n   header->crc    |= getc( str ) << 16;\n   header->crc    |= getc( str ) << 24;\n   header->length  = getc( str ) <<  0;\n   header->length |= getc( str ) <<  8;\n   header->length |= getc( str ) << 16;\n   header->length |= getc( str ) << 24;\n   header->compressedLength = ftell( str );\n\n\t\t\t\t/* Compute offsets */\n   header->offsets = xmalloc( sizeof( header->offsets[0] )\n\t\t\t      * header->chunkCount );\n   if( header->offsets == 0 ) {\n     if( header->chunks )\n       free( header->chunks );\n     return DZ_ERR_NOMEMORY;\n   }\n\n   for (offset = header->headerLength + 1, i = 0;\n\ti < header->chunkCount;\n\ti++)\n   {\n      header->offsets[i] = offset;\n      offset += header->chunks[i];\n   }\n\n   fclose( str );\n   return DZ_NOERROR;\n}\n\ndictData *dict_data_open( const char *filename,\n                          enum DZ_ERRORS * error,\n                          int computeCRC )\n{\n   dictData    *h = NULL;\n//   struct stat sb;\n   int         j;\n\n   if (!filename)\n   {\n     *error = DZ_ERR_OPENFILE;\n     return NULL;\n   }\n\n   h = xmalloc( sizeof( struct dictData ) );\n   if( h == 0 )\n   {\n     *error = DZ_ERR_NOMEMORY;\n     return 0;\n   }\n\n   memset( h, 0, sizeof( struct dictData ) );\n#ifdef __WIN32\n   h->fd = INVALID_HANDLE_VALUE;\n#endif\n   h->initialized = 0;\n\n   for(;;)\n   {\n#ifdef __WIN32\n     wchar_t wname[16384];\n#endif\n     *error = dict_read_header( filename, h, computeCRC );\n     if ( *error != DZ_NOERROR ) {\n       break; /*\n        err_fatal( __func__,\n       \"\\\"%s\\\" not in text or dzip format\\n\", filename );*/\n     }\n\n#ifdef __WIN32\n     if( MultiByteToWideChar( CP_UTF8, 0, filename, -1, wname, 16384 ) == 0 )\n     {\n       *error = DZ_ERR_OPENFILE;\n       break;\n     }\n\n     h->fd = CreateFileW( wname, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, 0,\n                          OPEN_EXISTING, FILE_FLAG_RANDOM_ACCESS, 0);\n     if( h->fd == INVALID_HANDLE_VALUE )\n     {\n       *error = DZ_ERR_OPENFILE;\n       break;\n     }\n\n     h->size = GetFileSize( h->fd, 0 );\n#else\n     h->fd = gd_fopen( filename, \"rb\" );\n\n     if ( !h->fd )\n     {\n       *error = DZ_ERR_OPENFILE;\n       break;\n        /*err_fatal_errno( __func__,\n             \"Cannot open data file \\\"%s\\\"\\n\", filename );*/\n      }\n\n     fseek( h->fd, 0, SEEK_END );\n\n     h->size = ftell( h->fd );\n#endif\n\n     for (j = 0; j < DICT_CACHE_SIZE; j++) {\n        h->cache[j].chunk    = -1;\n        h->cache[j].stamp    = -1;\n        h->cache[j].inBuffer = NULL;\n        h->cache[j].count    = 0;\n     }\n\n     *error = DZ_NOERROR;\n     return h;\n   }\n   dict_data_close( h );\n   return( 0 );\n}\n\nvoid dict_data_close( dictData *header )\n{\n   int i;\n\n   if (!header)\n      return;\n\n#ifdef __WIN32\n   if ( header->fd != INVALID_HANDLE_VALUE )\n     CloseHandle( header->fd );\n#else\n   if ( header->fd )\n     fclose( header->fd );\n#endif\n\n   if (header->chunks)       xfree( header->chunks );\n   if (header->offsets)      xfree( header->offsets );\n\n   if (header->initialized) {\n      if (inflateEnd( &header->zStream ))\n\t err_internal( __func__,\n\t\t       \"Cannot shut down inflation engine: %s\\n\",\n\t\t       header->zStream.msg );\n   }\n\n   for (i = 0; i < DICT_CACHE_SIZE; ++i){\n      if (header -> cache [i].inBuffer)\n\t xfree (header -> cache [i].inBuffer);\n   }\n\n   memset( header, 0, sizeof( struct dictData ) );\n   xfree( header );\n}\n\nchar *dict_data_read_ (\n   dictData *h, unsigned long start, unsigned long size,\n   const char *preFilter, const char *postFilter )\n{\n   char * buffer;\n   char * pt;\n   unsigned long end;\n   int           count;\n   char          *inBuffer;\n   char          outBuffer[OUT_BUFFER_SIZE];\n   int           firstChunk, lastChunk;\n   int           firstOffset, lastOffset;\n   int           i, j;\n   int           found, target, lastStamp;\n   (void) preFilter;\n   (void) postFilter;\n\n   end  = start + size;\n\n   buffer = xmalloc( size + 1 );\n   if( !buffer )\n   {\n     strcpy( h->errorString, dz_error_str( DZ_ERR_NOMEMORY ) );\n     return 0;\n   }\n\n   if ( !size )\n   {\n     *buffer = 0;\n     return buffer;\n   }\n\n   PRINTF(DBG_UNZIP,\n\t  (\"dict_data_read( %p, %lu, %lu, %s, %s )\\n\",\n\t   h, start, size, preFilter, postFilter ));\n\n   assert( h != NULL);\n   switch (h->type) {\n   case DICT_GZIP:\n/*\n      err_fatal( __func__,\n\t\t \"Cannot seek on pure gzip format files.\\n\"\n\t\t \"Use plain text (for performance)\"\n\t\t \" or dzip format (for space savings).\\n\" );\n      break;\n*/\n      strcpy( h->errorString, \"Cannot seek on pure gzip format files\" );\n      xfree( buffer );\n      return 0;\n   case DICT_TEXT:\n   {\n#ifdef __WIN32\n     long hiPtr = 0;\n     DWORD pos = SetFilePointer( h->fd, start, &hiPtr, FILE_BEGIN );\n     DWORD readed = 0;\n     if( pos != INVALID_SET_FILE_POINTER || GetLastError() != NO_ERROR )\n       ReadFile( h->fd, buffer, size, &readed, 0 );\n     if( size != readed )\n#else\n     if ( fseek( h->fd, start, SEEK_SET ) != 0 ||\n          fread( buffer, size, 1, h->fd ) != 1 )\n#endif\n     {\n       strcpy( h->errorString, dz_error_str( DZ_ERR_READFILE ) );\n       xfree( buffer );\n       return 0;\n     }\n\n     buffer[size] = '\\0';\n   }\n   break;\n   case DICT_DZIP:\n      if (!h->initialized) {\n\t h->zStream.zalloc    = NULL;\n\t h->zStream.zfree     = NULL;\n\t h->zStream.opaque    = NULL;\n\t h->zStream.next_in   = 0;\n\t h->zStream.avail_in  = 0;\n\t h->zStream.next_out  = NULL;\n\t h->zStream.avail_out = 0;\n\t if (inflateInit2( &h->zStream, -15 ) != Z_OK)\n/*\n\t    err_internal( __func__,\n\t\t\t  \"Cannot initialize inflation engine: %s\\n\",\n\t\t\t  h->zStream.msg );\n*/\n\t {\n\t   sprintf( h->errorString, \"Cannot initialize inflation engine: %s\", h->zStream.msg );\n\t   xfree( buffer );\n\t   return 0;\n\t }\n\t ++h->initialized;\n      }\n      firstChunk  = start / h->chunkLength;\n      firstOffset = start - firstChunk * h->chunkLength;\n      lastChunk   = end / h->chunkLength;\n      lastOffset  = end - lastChunk * h->chunkLength;\n      PRINTF(DBG_UNZIP,\n\t     (\"   start = %lu, end = %lu\\n\"\n\t      \"firstChunk = %d, firstOffset = %d,\"\n\t      \" lastChunk = %d, lastOffset = %d\\n\",\n\t      start, end, firstChunk, firstOffset, lastChunk, lastOffset ));\n      for (pt = buffer, i = firstChunk; i <= lastChunk; i++) {\n\n\t\t\t\t/* Access cache */\n\t found  = 0;\n\t target = 0;\n\t lastStamp = INT_MAX;\n\t for (j = 0; j < DICT_CACHE_SIZE; j++) {\n#if USE_CACHE\n\t    if (h->cache[j].chunk == i) {\n\t       found  = 1;\n\t       target = j;\n\t       break;\n\t    }\n#endif\n\t    if (h->cache[j].stamp < lastStamp) {\n\t       lastStamp = h->cache[j].stamp;\n\t       target = j;\n\t    }\n\t }\n\n\t h->cache[target].stamp = ++h->stamp;\n\t if( h->stamp < 0 )\n\t {\n\t    h->stamp = 0;\n\t    for (j = 0; j < DICT_CACHE_SIZE; j++)\n\t      h->cache[j].stamp = -1;\n\t }\n\t if (found) {\n\t    count = h->cache[target].count;\n\t    inBuffer = h->cache[target].inBuffer;\n\t } else {\n#ifdef __WIN32\n        DWORD pos ;\n        DWORD readed;\n#endif\n\t    h->cache[target].chunk = -1;\n\t    if (!h->cache[target].inBuffer)\n\t       h->cache[target].inBuffer = xmalloc( h->chunkLength );\n\t    inBuffer = h->cache[target].inBuffer;\n\t    if( !inBuffer )\n\t    {\n\t      strcpy( h->errorString, dz_error_str( DZ_ERR_NOMEMORY ) );\n\t      xfree( buffer );\n\t      return 0;\n\t    }\n\n\t    if (h->chunks[i] >= OUT_BUFFER_SIZE ) {\n/*\n\t       err_internal( __func__,\n\t\t\t     \"h->chunks[%d] = %d >= %ld (OUT_BUFFER_SIZE)\\n\",\n\t\t\t     i, h->chunks[i], OUT_BUFFER_SIZE );\n*/\n              sprintf( h->errorString, \"h->chunks[%d] = %d >= %ld (OUT_BUFFER_SIZE)\\n\",\n                       i, h->chunks[i], OUT_BUFFER_SIZE );\n              xfree( buffer );\n              return 0;\n\t    }\n\n#ifdef __WIN32\n      pos = SetFilePointer( h->fd, h->offsets[ i ], 0, FILE_BEGIN );\n      readed = 0;\n      if( pos != INVALID_SET_FILE_POINTER || GetLastError() != NO_ERROR )\n        ReadFile( h->fd, outBuffer, h->chunks[ i ], &readed, 0 );\n      if( h->chunks[ i ] != (int)readed )\n#else\n      if ( fseek( h->fd, h->offsets[ i ], SEEK_SET ) != 0 ||\n           fread( outBuffer, h->chunks[ i ], 1, h->fd ) != 1 )\n#endif\n      {\n        strcpy( h->errorString, dz_error_str( DZ_ERR_READFILE ) );\n        xfree( buffer );\n        return 0;\n      }\n\n      dict_data_filter( outBuffer, &count, OUT_BUFFER_SIZE, preFilter );\n\t \n\t    h->zStream.next_in   = (Bytef *)outBuffer;\n\t    h->zStream.avail_in  = h->chunks[i];\n\t    h->zStream.next_out  = (Bytef *)inBuffer;\n\t    h->zStream.avail_out = h->chunkLength;\n\t    if (inflate( &h->zStream,  Z_PARTIAL_FLUSH ) != Z_OK)\n\t    {\n//\t       err_fatal( __func__, \"inflate: %s\\n\", h->zStream.msg );\n\t      sprintf( h->errorString, \"inflate: %s\\n\", h->zStream.msg );\n\t      xfree( buffer );\n\t      return 0;\n\t    }\n\t    if (h->zStream.avail_in)\n/*\n\t       err_internal( __func__,\n\t\t\t     \"inflate did not flush (%d pending, %d avail)\\n\",\n\t\t\t     h->zStream.avail_in, h->zStream.avail_out );\n*/\n\t    {\n\t      sprintf( h->errorString, \"inflate did not flush (%d pending, %d avail)\\n\",\n\t\t       h->zStream.avail_in, h->zStream.avail_out );\n\t      xfree( buffer );\n\t      return 0;\n\t    }\n\t    \n\t    count = h->chunkLength - h->zStream.avail_out;\n      dict_data_filter( inBuffer, &count, h->chunkLength, postFilter );\n\n\t    h->cache[target].count = count;\n\t    h->cache[target].chunk = i;\n\t }\n\t \n\t if (i == firstChunk) {\n\t    if (i == lastChunk) {\n\t       memcpy( pt, inBuffer + firstOffset, lastOffset-firstOffset);\n\t       pt += lastOffset - firstOffset;\n\t    } else {\n\t       if (count != h->chunkLength )\n/*\n\t\t  err_internal( __func__,\n\t\t\t\t\"Length = %d instead of %d\\n\",\n\t\t\t\tcount, h->chunkLength );\n*/\n\t       {\n\t\t sprintf( h->errorString, \"Length = %d instead of %d\\n\",\n\t\t\t  count, h->chunkLength );\n\t\t xfree( buffer );\n\t\t return 0;\n\t       }\n\t       memcpy( pt, inBuffer + firstOffset,\n\t\t       h->chunkLength - firstOffset );\n\t       pt += h->chunkLength - firstOffset;\n\t    }\n\t } else if (i == lastChunk) {\n\t    memcpy( pt, inBuffer, lastOffset );\n\t    pt += lastOffset;\n\t } else {\n\t    assert( count == h->chunkLength );\n\t    memcpy( pt, inBuffer, h->chunkLength );\n\t    pt += h->chunkLength;\n\t }\n      }\n      *pt = '\\0';\n      break;\n   case DICT_UNKNOWN:\n//      err_fatal( __func__, \"Cannot read unknown file type\\n\" );\n      strcpy( h->errorString, \"Cannot read unknown file type\" );\n      xfree( buffer );\n      return 0;\n   }\n   h->errorString[ 0 ] = 0;\n   return buffer;\n}\n\nchar *dict_error_str( dictData *data )\n{\n  return data->errorString;\n}\n\nconst char * dz_error_str( enum DZ_ERRORS error )\n{\n  switch( error )\n  {\n    case DZ_NOERROR:                return \"No error\";\n    case DZ_ERR_OPENFILE:           return \"Open file error\";\n    case DZ_ERR_READFILE:           return \"Read file error\";\n    case DZ_ERR_INVALID_FORMAT:     return \"Invalid file format\";\n    case DZ_ERR_UNSUPPORTED_FORMAT: return \"Unsupported file format\";\n    case DZ_ERR_NOMEMORY:           return \"Memory allocation error\";\n    case DZ_ERR_INTERNAL:           return \"Internal error\";\n  }\n  return \"Unknown error\";\n}\n"
        },
        {
          "name": "dictzip.h",
          "type": "blob",
          "size": 2.82421875,
          "content": "/* Made up from data.h and other supplementary files of dictd-1.0.11 for the\n * GoldenDict program.\n */\n\n/* data.h -- \n * Created: Sat Mar 15 18:04:25 2003 by Aleksey Cheusov <vle@gmx.net>\n * Copyright 1994-2003 Rickard E. Faith (faith@dict.org)\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 1, or (at your option) any\n * later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Suite 500, Boston, MA 02110, USA.\n */\n\n#ifndef _DICTZIP_H_\n#define _DICTZIP_H_\n\n#include <stdio.h>\n#include <zlib.h>\n\n#ifdef __WIN32\n#include <windows.h>\n#endif\n\n#ifdef __cplusplus\nextern \"C\" \n{\n#endif\n\n\n/* Excerpts from defs.h */\n\n#define DICT_CACHE_SIZE 5\n\ntypedef struct dictCache {\n   int           chunk;\n   char          *inBuffer;\n   int           stamp;\n   int           count;\n} dictCache;\n\nenum DZ_ERRORS {\n  DZ_NOERROR = 0,\n  DZ_ERR_INTERNAL,\n  DZ_ERR_OPENFILE,\n  DZ_ERR_READFILE,\n  DZ_ERR_UNSUPPORTED_FORMAT,\n  DZ_ERR_INVALID_FORMAT,\n  DZ_ERR_NOMEMORY\n};\n\ntypedef struct dictData {\n#ifdef __WIN32\n   HANDLE        fd;\t\t/* file handle */\n#else\n   FILE *        fd;\t\t/* file descriptor */\n#endif\n\n   unsigned long size;\t\t/* size of file */\n   \n   int           type;\n   const char    *filename;\n   z_stream      zStream;\n   int           initialized;\n\n   int           headerLength;\n   int           method;\n   int           flags;\n   time_t        mtime;\n   int           extraFlags;\n   int           os;\n   int           version;\n   int           chunkLength;\n   int           chunkCount;\n   int           *chunks;\n   unsigned long *offsets;\t/* Sum-scan of chunks. */\n   const char    *origFilename;\n   const char    *comment;\n   unsigned long crc;\n   unsigned long length;\n   unsigned long compressedLength;\n   int           stamp;\n   dictCache     cache[DICT_CACHE_SIZE];\n   char          errorString[512];\n} dictData;\n\n\n/* initialize .data file */\nextern dictData *dict_data_open (\n   const char *filename, enum DZ_ERRORS * error, int computeCRC);\n/* */\nextern void dict_data_close (\n   dictData *data);\n\nextern char *dict_data_read_ (\n   dictData *data,\n   unsigned long start, unsigned long end,\n   const char *preFilter,\n   const char *postFilter );\n\nextern char *dict_error_str( dictData *data );\n\nextern const char *dz_error_str( enum DZ_ERRORS error );\n\nextern int        mmap_mode;\n\n#ifdef __cplusplus\n}  /* end extern \"C\" */\n#endif\n\n#endif /* _DICTZIP_H_ */\n"
        },
        {
          "name": "dsl.cc",
          "type": "blob",
          "size": 75.0673828125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"dsl.hh\"\n#include \"dsl_details.hh\"\n#include \"btreeidx.hh\"\n#include \"folding.hh\"\n#include \"utf8.hh\"\n#include \"chunkedstorage.hh\"\n#include \"dictzip.h\"\n#include \"htmlescape.hh\"\n#include \"iconv.hh\"\n#include \"filetype.hh\"\n#include \"fsencoding.hh\"\n#include \"audiolink.hh\"\n#include \"langcoder.hh\"\n#include \"wstring_qt.hh\"\n#include \"zipfile.hh\"\n#include \"indexedzip.hh\"\n#include \"categorized_logging.hh\"\n#include \"gddebug.hh\"\n#include \"tiff.hh\"\n#include \"fulltextsearch.hh\"\n#include \"ftshelpers.hh\"\n#include \"language.hh\"\n\n#include <zlib.h>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\n#include <list>\n#include <wctype.h>\n\n#ifdef _MSC_VER\n#include <stub_msvc.h>\n#endif\n\n#include <QSemaphore>\n#include <QThreadPool>\n#include <QAtomicInt>\n#include <QUrl>\n\n#include <QDir>\n#include <QFileInfo>\n#include <QPainter>\n#include <QMap>\n#include <QStringList>\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n#include <QRegularExpression>\n#else\n#include <QRegExp>\n#endif\n\n// For TIFF conversion\n#include <QImage>\n#include <QByteArray>\n#include <QBuffer>\n\n// For SVG handling\n#include <QtSvg/QSvgRenderer>\n\n#include \"qt4x5.hh\"\n\nnamespace Dsl {\n\nusing namespace Details;\n\nusing std::map;\nusing std::multimap;\nusing std::pair;\nusing std::set;\nusing std::string;\nusing gd::wstring;\nusing gd::wchar;\nusing std::vector;\nusing std::list;\n\nusing BtreeIndexing::WordArticleLink;\nusing BtreeIndexing::IndexedWords;\nusing BtreeIndexing::IndexInfo;\n\nnamespace {\n\nDEF_EX_STR( exCantReadFile, \"Can't read file\", Dictionary::Ex )\nDEF_EX( exUserAbort, \"User abort\", Dictionary::Ex )\nDEF_EX_STR( exDictzipError, \"DICTZIP error\", Dictionary::Ex )\n\nenum\n{\n  Signature = 0x584c5344, // DSLX on little-endian, XLSD on big-endian\n  CurrentFormatVersion = 23 + BtreeIndexing::FormatVersion + Folding::Version,\n  CurrentZipSupportVersion = 2,\n  CurrentFtsIndexVersion = 7\n};\n\nstruct IdxHeader\n{\n  uint32_t signature; // First comes the signature, DSLX\n  uint32_t formatVersion; // File format version (CurrentFormatVersion)\n  uint32_t zipSupportVersion; // Zip support version -- narrows down reindexing\n                              // when it changes only for dictionaries with the\n                              // zip files\n  int dslEncoding; // Which encoding is used for the file indexed\n  uint32_t chunksOffset; // The offset to chunks' storage\n  uint32_t hasAbrv; // Non-zero means file has abrvs at abrvAddress\n  uint32_t abrvAddress; // Address of abrv map in the chunked storage\n  uint32_t indexBtreeMaxElements; // Two fields from IndexInfo\n  uint32_t indexRootOffset;\n  uint32_t articleCount; // Number of articles this dictionary has\n  uint32_t wordCount; // Number of headwords this dictionary has\n  uint32_t langFrom;  // Source language\n  uint32_t langTo;    // Target language\n  uint32_t hasZipFile; // Non-zero means there's a zip file with resources\n                       // present\n  uint32_t hasSoundDictionaryName;\n  uint32_t zipIndexBtreeMaxElements; // Two fields from IndexInfo of the zip\n                                     // resource index.\n  uint32_t zipIndexRootOffset;\n}\n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\nstruct InsidedCard\n{\n  uint32_t offset;\n  uint32_t size;\n  QVector< wstring > headwords;\n  InsidedCard( uint32_t _offset, uint32_t _size, QVector< wstring > const & words ) :\n  offset( _offset ), size( _size ), headwords( words )\n  {}\n  InsidedCard( InsidedCard const & e ) :\n  offset( e.offset ), size( e.size ), headwords( e.headwords )\n  {}\n  InsidedCard() {}\n\n};\n\nbool indexIsOldOrBad( string const & indexFile, bool hasZipFile )\n{\n  File::Class idx( indexFile, \"rb\" );\n\n  IdxHeader header;\n\n  return idx.readRecords( &header, sizeof( header ), 1 ) != 1 ||\n         header.signature != Signature ||\n         header.formatVersion != CurrentFormatVersion ||\n         (bool) header.hasZipFile != hasZipFile ||\n         ( hasZipFile && header.zipSupportVersion != CurrentZipSupportVersion );\n}\n\nclass DslDictionary: public BtreeIndexing::BtreeDictionary\n{\n  Mutex idxMutex;\n  File::Class idx;\n  IdxHeader idxHeader;\n  sptr< ChunkedStorage::Reader > chunks;\n  string dictionaryName;\n  string preferredSoundDictionary;\n  map< string, string > abrv;\n  Mutex dzMutex;\n  dictData * dz;\n  Mutex resourceZipMutex;\n  IndexedZip resourceZip;\n  BtreeIndex resourceZipIndex;\n\n  QAtomicInt deferredInitDone;\n  Mutex deferredInitMutex;\n  bool deferredInitRunnableStarted;\n  QSemaphore deferredInitRunnableExited;\n\n  string initError;\n\n  int optionalPartNom;\n  quint8 articleNom;\n  int maxPictureWidth;\n\n  wstring currentHeadword;\n  string resourceDir1, resourceDir2;\n\npublic:\n\n  DslDictionary( string const & id, string const & indexFile,\n                 vector< string > const & dictionaryFiles,\n                 int maxPictureWidth_ );\n\n  virtual void deferredInit();\n\n  ~DslDictionary();\n\n  virtual string getName() throw()\n  { return dictionaryName; }\n\n  virtual map< Dictionary::Property, string > getProperties() throw()\n  { return map< Dictionary::Property, string >(); }\n\n  virtual unsigned long getArticleCount() throw()\n  { return idxHeader.articleCount; }\n\n  virtual unsigned long getWordCount() throw()\n  { return idxHeader.wordCount; }\n\n  inline virtual quint32 getLangFrom() const\n  { return idxHeader.langFrom; }\n\n  inline virtual quint32 getLangTo() const\n  { return idxHeader.langTo; }\n\n  inline virtual string getResourceDir1() const\n  { return resourceDir1; }\n\n  inline virtual string getResourceDir2() const\n  { return resourceDir2; }\n\n  #if 0\n  virtual vector< wstring > findHeadwordsForSynonym( wstring const & )\n    THROW_SPEC( std::exception )\n  {\n    return vector< wstring >();\n  }\n  #endif\n\n  virtual sptr< Dictionary::DataRequest > getArticle( wstring const &,\n                                                      vector< wstring > const & alts,\n                                                      wstring const &,\n                                                      bool ignoreDiacritics )\n    THROW_SPEC( std::exception );\n\n  virtual sptr< Dictionary::DataRequest > getResource( string const & name )\n    THROW_SPEC( std::exception );\n\n  virtual sptr< Dictionary::DataRequest > getSearchResults( QString const & searchString,\n                                                            int searchMode, bool matchCase,\n                                                            int distanceBetweenWords,\n                                                            int maxResults,\n                                                            bool ignoreWordsOrder,\n                                                            bool ignoreDiacritics,\n                                                            QThreadPool * ftsThreadPoolPtr );\n  virtual QString const& getDescription();\n\n  virtual QString getMainFilename();\n\n  virtual void getArticleText( uint32_t articleAddress, QString & headword, QString & text );\n\n  virtual void makeFTSIndex(QAtomicInt & isCancelled, bool firstIteration );\n\n  virtual void setFTSParameters( Config::FullTextSearch const & fts )\n  {\n    if( ensureInitDone().size() )\n      return;\n\n    can_FTS = fts.enabled\n              && !fts.disabledTypes.contains( \"DSL\", Qt::CaseInsensitive )\n              && ( fts.maxDictionarySize == 0 || getArticleCount() <= fts.maxDictionarySize );\n  }\n\n  virtual uint32_t getFtsIndexVersion()\n  { return CurrentFtsIndexVersion; }\n\nprotected:\n\n  virtual void loadIcon() throw();\n\nprivate:\n\n  virtual string const & ensureInitDone();\n  void doDeferredInit();\n\n  /// Loads the article. Does not process the DSL language.\n  void loadArticle( uint32_t address,\n                    wstring const & requestedHeadwordFolded,\n                    bool ignoreDiacritics,\n                    wstring & tildeValue,\n                    wstring & displayedHeadword,\n                    unsigned & headwordIndex,\n                    wstring & articleText );\n\n  /// Converts DSL language to an Html.\n  string dslToHtml( wstring const &, wstring const & headword = wstring() );\n\n  // Parts of dslToHtml()\n  string nodeToHtml( ArticleDom::Node const & );\n  string processNodeChildren( ArticleDom::Node const & node );\n\n  bool hasHiddenZones()           /// Return true if article has hidden zones\n  { return optionalPartNom != 0; }\n\n  friend class DslArticleRequest;\n  friend class DslResourceRequest;\n  friend class DslFTSResultsRequest;\n  friend class DslDeferredInitRunnable;\n};\n\nDslDictionary::DslDictionary( string const & id,\n                              string const & indexFile,\n                              vector< string > const & dictionaryFiles,\n                              int maxPictureWidth_ ):\n  BtreeDictionary( id, dictionaryFiles ),\n  idx( indexFile, \"rb\" ),\n  idxHeader( idx.read< IdxHeader >() ),\n  dz( 0 ),\n  deferredInitRunnableStarted( false ),\n  optionalPartNom( 0 ),\n  articleNom( 0 ),\n  maxPictureWidth( maxPictureWidth_ )\n{\n  can_FTS = true;\n\n  ftsIdxName = indexFile + \"_FTS\";\n\n  if( !Dictionary::needToRebuildIndex( dictionaryFiles, ftsIdxName )\n      && !FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) )\n    FTS_index_completed.ref();\n\n  // Read the dictionary name\n\n  idx.seek( sizeof( idxHeader ) );\n\n  vector< char > dName( idx.read< uint32_t >() );\n  if( dName.size() > 0 )\n  {\n    idx.read( &dName.front(), dName.size() );\n    dictionaryName = string( &dName.front(), dName.size() );\n  }\n\n  vector< char > sName( idx.read< uint32_t >() );\n  if( sName.size() > 0 )\n  {\n    idx.read( &sName.front(), sName.size() );\n    preferredSoundDictionary = string( &sName.front(), sName.size() );\n  }\n\n  resourceDir1 = getDictionaryFilenames()[ 0 ] + \".files\" + FsEncoding::separator();\n  QString s = FsEncoding::decode( getDictionaryFilenames()[ 0 ].c_str() );\n  if( s.endsWith( QString::fromLatin1( \".dz\" ), Qt::CaseInsensitive ) )\n    s.chop( 3 );\n  resourceDir2 = FsEncoding::encode( s ) + \".files\" + FsEncoding::separator();\n\n  // Everything else would be done in deferred init\n}\n\nDslDictionary::~DslDictionary()\n{\n  Mutex::Lock _( deferredInitMutex );\n\n  // Wait for init runnable to complete if it was ever started\n  if ( deferredInitRunnableStarted )\n    deferredInitRunnableExited.acquire();\n\n  if ( dz )\n    dict_data_close( dz );\n}\n\n//////// DslDictionary::deferredInit()\n\nclass DslDeferredInitRunnable: public QRunnable\n{\n  DslDictionary & dictionary;\n  QSemaphore & hasExited;\n\npublic:\n\n  DslDeferredInitRunnable( DslDictionary & dictionary_,\n                           QSemaphore & hasExited_ ):\n    dictionary( dictionary_ ), hasExited( hasExited_ )\n  {}\n\n  ~DslDeferredInitRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run()\n  {\n    dictionary.doDeferredInit();\n  }\n};\n\nvoid DslDictionary::deferredInit()\n{\n  if ( !Qt4x5::AtomicInt::loadAcquire( deferredInitDone ) )\n  {\n    Mutex::Lock _( deferredInitMutex );\n\n    if ( Qt4x5::AtomicInt::loadAcquire( deferredInitDone ) )\n      return;\n\n    if ( !deferredInitRunnableStarted )\n    {\n      QThreadPool::globalInstance()->start(\n        new DslDeferredInitRunnable( *this, deferredInitRunnableExited ),\n        -1000 );\n      deferredInitRunnableStarted = true;\n    }\n  }\n}\n\n\nstring const & DslDictionary::ensureInitDone()\n{\n  // Simple, really.\n  doDeferredInit();\n\n  return initError;\n}\n\nvoid DslDictionary::doDeferredInit()\n{\n  if ( !Qt4x5::AtomicInt::loadAcquire( deferredInitDone ) )\n  {\n    Mutex::Lock _( deferredInitMutex );\n\n    if ( Qt4x5::AtomicInt::loadAcquire( deferredInitDone ) )\n      return;\n\n    // Do deferred init\n\n    try\n    {\n      // Don't lock index file - no one should be working with it until\n      // the init is complete.\n      //Mutex::Lock _( idxMutex );\n\n      chunks = new ChunkedStorage::Reader( idx, idxHeader.chunksOffset );\n\n      // Open the .dsl file\n\n      DZ_ERRORS error;\n      dz = dict_data_open( getDictionaryFilenames()[ 0 ].c_str(), &error, 0 );\n\n      if ( !dz )\n        throw exDictzipError( string( dz_error_str( error ) )\n                              + \"(\" + getDictionaryFilenames()[ 0 ] + \")\" );\n\n      // Read the abrv, if any\n\n      if ( idxHeader.hasAbrv )\n      {\n        vector< char > chunk;\n\n        char * abrvBlock = chunks->getBlock( idxHeader.abrvAddress, chunk );\n\n        uint32_t total;\n        memcpy( &total, abrvBlock, sizeof( uint32_t ) );\n        abrvBlock += sizeof( uint32_t );\n\n        GD_DPRINTF( \"Loading %u abbrv\\n\", total );\n\n        while( total-- )\n        {\n          uint32_t keySz;\n          memcpy( &keySz, abrvBlock, sizeof( uint32_t ) );\n          abrvBlock += sizeof( uint32_t );\n\n          char * key = abrvBlock;\n\n          abrvBlock += keySz;\n\n          uint32_t valueSz;\n          memcpy( &valueSz, abrvBlock, sizeof( uint32_t ) );\n          abrvBlock += sizeof( uint32_t );\n\n          abrv[ string( key, keySz ) ] = string( abrvBlock, valueSz );\n\n          abrvBlock += valueSz;\n        }\n      }\n\n      // Initialize the index\n\n      openIndex( IndexInfo( idxHeader.indexBtreeMaxElements,\n                            idxHeader.indexRootOffset ),\n                 idx, idxMutex );\n\n      // Open a resource zip file, if there's one\n\n      if ( idxHeader.hasZipFile &&\n           ( idxHeader.zipIndexBtreeMaxElements ||\n             idxHeader.zipIndexRootOffset ) )\n      {\n        resourceZip.openIndex( IndexInfo( idxHeader.zipIndexBtreeMaxElements,\n                                          idxHeader.zipIndexRootOffset ),\n                               idx, idxMutex );\n\n        QString zipName = QDir::fromNativeSeparators(\n            FsEncoding::decode( getDictionaryFilenames().back().c_str() ) );\n\n        if ( zipName.endsWith( \".zip\", Qt::CaseInsensitive ) ) // Sanity check\n          resourceZip.openZipFile( zipName );\n      }\n    }\n    catch( std::exception & e )\n    {\n      initError = e.what();\n    }\n    catch( ... )\n    {\n      initError = \"Unknown error\";\n    }\n\n    deferredInitDone.ref();\n  }\n}\n\n\nvoid DslDictionary::loadIcon() throw()\n{\n  if ( dictionaryIconLoaded )\n    return;\n\n  QString fileName =\n    QDir::fromNativeSeparators( FsEncoding::decode( getDictionaryFilenames()[ 0 ].c_str() ) );\n\n  // Remove the extension\n  if ( fileName.endsWith( \".dsl.dz\", Qt::CaseInsensitive ) )\n    fileName.chop( 6 );\n  else\n    fileName.chop( 3 );\n\n  if ( !loadIconFromFile( fileName ) )\n  {\n    // Load failed -- use default icons\n    dictionaryIcon = QIcon(\":/icons/icon32_dsl.png\");\n    dictionaryNativeIcon = QIcon(\":/icons/icon_dsl_native.png\");\n  }\n\n  dictionaryIconLoaded = true;\n}\n\n/// Determines whether or not this char is treated as whitespace for dsl\n/// parsing or not. We can't rely on any Unicode standards here, since the\n/// only standard that matters here is the original Dsl compiler's insides.\n/// Some dictionaries, for instance, are known to specifically use a non-\n/// breakable space (0xa0) to indicate that a headword begins with a space,\n/// so nbsp is not a whitespace character for Dsl compiler.\n/// For now we have only space and tab, since those are most likely the only\n/// ones recognized as spaces by that compiler.\nbool isDslWs( wchar ch )\n{\n  switch( ch )\n  {\n    case ' ':\n    case '\\t':\n      return true;\n    default:\n      return false;\n  }\n}\n\nvoid DslDictionary::loadArticle( uint32_t address,\n                                 wstring const & requestedHeadwordFolded,\n                                 bool ignoreDiacritics,\n                                 wstring & tildeValue,\n                                 wstring & displayedHeadword,\n                                 unsigned & headwordIndex,\n                                 wstring & articleText )\n{\n  wstring articleData;\n\n  {\n    vector< char > chunk;\n\n    char * articleProps;\n\n    {\n      Mutex::Lock _( idxMutex );\n\n      articleProps = chunks->getBlock( address, chunk );\n    }\n\n    uint32_t articleOffset, articleSize;\n\n    memcpy( &articleOffset, articleProps, sizeof( articleOffset ) );\n    memcpy( &articleSize, articleProps + sizeof( articleOffset ),\n            sizeof( articleSize ) );\n\n    GD_DPRINTF( \"offset = %x\\n\", articleOffset );\n\n\n    char * articleBody;\n\n    {\n      Mutex::Lock _( dzMutex );\n\n      articleBody = dict_data_read_( dz, articleOffset, articleSize, 0, 0 );\n    }\n\n    if ( !articleBody )\n    {\n//      throw exCantReadFile( getDictionaryFilenames()[ 0 ] );\n      articleData = GD_NATIVE_TO_WS( L\"\\n\\r\\t\" ) + gd::toWString( QString( \"DICTZIP error: \" ) + dict_error_str( dz ) );\n    }\n    else\n    {\n      try\n      {\n        articleData =\n          DslIconv::toWstring(\n            DslIconv::getEncodingNameFor( DslEncoding( idxHeader.dslEncoding ) ),\n            articleBody, articleSize );\n        free( articleBody );\n\n        // Strip DSL comments\n        bool b = false;\n        stripComments( articleData, b );\n      }\n      catch( ... )\n      {\n        free( articleBody );\n        throw;\n      }\n    }\n  }\n\n  size_t pos = 0;\n  bool hadFirstHeadword = false;\n  bool foundDisplayedHeadword = false;\n\n  // Check is we retrieve insided card\n  bool insidedCard = isDslWs( articleData.at( 0 ) );\n\n  wstring tildeValueWithUnsorted; // This one has unsorted parts left\n  for( headwordIndex = 0; ; )\n  {\n    size_t begin = pos;\n\n    pos = articleData.find_first_of( GD_NATIVE_TO_WS( L\"\\n\\r\" ), begin );\n\n    if ( pos == wstring::npos )\n      pos = articleData.size();\n\n    if ( !foundDisplayedHeadword )\n    {\n      // Process the headword\n\n      wstring rawHeadword = wstring( articleData, begin, pos - begin );\n\n      if( insidedCard && !rawHeadword.empty() && isDslWs( rawHeadword[ 0 ] ) )\n      {\n        // Headword of the insided card\n        wstring::size_type hpos = rawHeadword.find( L'@' );\n        if( hpos != string::npos )\n        {\n          wstring head = Folding::trimWhitespace( rawHeadword.substr( hpos + 1 ) );\n          hpos = head.find( L'~' );\n          while( hpos != string::npos )\n          {\n            if( hpos == 0 || head[ hpos ] != L'\\\\' )\n              break;\n            hpos = head.find( L'~', hpos + 1 );\n          }\n          if( hpos == string::npos )\n            rawHeadword = head;\n          else\n            rawHeadword.clear();\n        }\n      }\n\n      if( !rawHeadword.empty() )\n      {\n        if ( !hadFirstHeadword )\n        {\n          // We need our tilde expansion value\n          tildeValue = rawHeadword;\n\n          list< wstring > lst;\n\n          expandOptionalParts( tildeValue, &lst );\n\n          if ( lst.size() ) // Should always be\n            tildeValue = lst.front();\n\n          tildeValueWithUnsorted = tildeValue;\n\n          processUnsortedParts( tildeValue, false );\n        }\n        wstring str = rawHeadword;\n\n        if ( hadFirstHeadword )\n          expandTildes( str, tildeValueWithUnsorted );\n\n        processUnsortedParts( str, true );\n\n        str = Folding::applySimpleCaseOnly( str );\n\n        list< wstring > lst;\n        expandOptionalParts( str, &lst );\n\n        // Does one of the results match the requested word? If so, we'd choose\n        // it as our headword.\n\n        for( list< wstring >::iterator i = lst.begin(); i != lst.end(); ++i )\n        {\n          unescapeDsl( *i );\n          normalizeHeadword( *i );\n\n          bool found;\n          if( ignoreDiacritics )\n            found = Folding::applyDiacriticsOnly( Folding::trimWhitespace( *i ) ) == Folding::applyDiacriticsOnly( requestedHeadwordFolded );\n          else\n            found = Folding::trimWhitespace( *i ) == requestedHeadwordFolded;\n\n          if ( found )\n          {\n            // Found it. Now we should make a displayed headword for it.\n            if ( hadFirstHeadword )\n              expandTildes( rawHeadword, tildeValueWithUnsorted );\n\n            processUnsortedParts( rawHeadword, false );\n\n            displayedHeadword = rawHeadword;\n\n            foundDisplayedHeadword = true;\n            break;\n          }\n        }\n\n        if ( !foundDisplayedHeadword )\n        {\n          ++headwordIndex;\n          hadFirstHeadword = true;\n        }\n      }\n    }\n\n\n    if ( pos == articleData.size() )\n      break;\n\n    // Skip \\n\\r\n\n    if ( articleData[ pos ] == '\\r' )\n      ++pos;\n\n    if ( pos != articleData.size() )\n    {\n      if ( articleData[ pos ] == '\\n' )\n        ++pos;\n    }\n\n    if ( pos == articleData.size() )\n    {\n      // Ok, it's end of article\n      break;\n    }\n    if( isDslWs( articleData[ pos ] ) )\n    {\n     // Check for begin article text\n      if( insidedCard )\n      {\n        // Check for next insided headword\n        wstring::size_type hpos = articleData.find_first_of( GD_NATIVE_TO_WS( L\"\\n\\r\" ), pos );\n        if ( hpos == wstring::npos )\n          hpos = articleData.size();\n\n        wstring str = wstring( articleData, pos, hpos - pos );\n\n        hpos = str.find( L'@');\n        if( hpos == wstring::npos || str[ hpos - 1 ] == L'\\\\' || !isAtSignFirst( str ) )\n          break;\n      }\n      else\n        break;\n    }\n  }\n\n  if ( !foundDisplayedHeadword )\n  {\n    // This is strange. Anyway, use tilde expansion value, it's better\n    // than nothing (or requestedHeadwordFolded for insided card.\n    if( insidedCard )\n      displayedHeadword = requestedHeadwordFolded;\n    else\n      displayedHeadword = tildeValue;\n  }\n\n  if ( pos != articleData.size() )\n    articleText = wstring( articleData, pos );\n  else\n    articleText.clear();\n}\n\nstring DslDictionary::dslToHtml( wstring const & str, wstring const & headword )\n{\n // Normalize the string\n  wstring normalizedStr = gd::normalize( str );\n  currentHeadword = headword;\n\n  ArticleDom dom( normalizedStr, getName(), headword );\n\n  optionalPartNom = 0;\n\n  string html = processNodeChildren( dom.root );\n\n  return html;\n}\n\nstring DslDictionary::processNodeChildren( ArticleDom::Node const & node )\n{\n  string result;\n\n  for( ArticleDom::Node::const_iterator i = node.begin(); i != node.end();\n       ++i )\n    result += nodeToHtml( *i );\n\n  return result;\n}\nstring DslDictionary::nodeToHtml( ArticleDom::Node const & node )\n{\n  string result;\n\n  if ( !node.isTag )\n  {\n    result = Html::escape( Utf8::encode( node.text ) );\n\n    // Handle all end-of-line\n\n    string::size_type n;\n\n    // Strip all '\\r'\n    while( ( n = result.find( '\\r' ) ) != string::npos )\n      result.erase( n, 1 );\n\n    // Replace all '\\n'\n    while( ( n = result.find( '\\n' ) ) != string::npos )\n      result.replace( n, 1, \"<p></p>\" );\n\n    return result;\n  }\n\n  if ( node.tagName == GD_NATIVE_TO_WS( L\"b\" ) )\n    result += \"<b class=\\\"dsl_b\\\">\" + processNodeChildren( node ) + \"</b>\";\n  else\n  if ( node.tagName == GD_NATIVE_TO_WS( L\"i\" ) )\n    result += \"<i class=\\\"dsl_i\\\">\" + processNodeChildren( node ) + \"</i>\";\n  else\n  if ( node.tagName == GD_NATIVE_TO_WS( L\"u\" ) )\n  {\n    string nodeText = processNodeChildren( node );\n\n    if ( nodeText.size() && isDslWs( nodeText[ 0 ] ) )\n      result.push_back( ' ' ); // Fix a common problem where in \"foo[i] bar[/i]\"\n                               // the space before \"bar\" gets underlined.\n\n    result += \"<span class=\\\"dsl_u\\\">\" + nodeText + \"</span>\";\n  }\n  else\n  if ( node.tagName == GD_NATIVE_TO_WS( L\"c\" ) )\n  {\n    result += \"<font color=\\\"\" + ( node.tagAttrs.size() ?\n      Html::escape( Utf8::encode( node.tagAttrs ) ) : string( \"c_default_color\" ) )\n      + \"\\\">\" + processNodeChildren( node ) + \"</font>\";\n  }\n  else\n  if ( node.tagName == GD_NATIVE_TO_WS( L\"*\" ) )\n  {\n      string id = \"O\" + getId().substr( 0, 7 ) + \"_\" +\n                QString::number( articleNom ).toStdString() +\n                \"_opt_\" + QString::number( optionalPartNom++ ).toStdString();\n    result += \"<span class=\\\"dsl_opt\\\" id=\\\"\" + id + \"\\\">\" + processNodeChildren( node ) + \"</span>\";\n  }\n  else\n  if ( node.tagName == GD_NATIVE_TO_WS( L\"m\" ) )\n      result += \"<div class=\\\"dsl_m\\\">\" + processNodeChildren( node ) + \"</div>\";\n  else\n  if ( node.tagName.size() == 2 && node.tagName[ 0 ] == L'm' &&\n       iswdigit( node.tagName[ 1 ] ) )\n    result += \"<div class=\\\"dsl_\" + Utf8::encode( node.tagName ) + \"\\\">\" + processNodeChildren( node ) + \"</div>\";\n  else\n  if ( node.tagName == GD_NATIVE_TO_WS( L\"trn\" ) )\n    result += \"<span class=\\\"dsl_trn\\\">\" + processNodeChildren( node ) + \"</span>\";\n  else\n  if ( node.tagName == GD_NATIVE_TO_WS( L\"ex\" ) )\n    result += \"<span class=\\\"dsl_ex\\\">\" + processNodeChildren( node ) + \"</span>\";\n  else\n  if ( node.tagName == GD_NATIVE_TO_WS( L\"com\" ) )\n    result += \"<span class=\\\"dsl_com\\\">\" + processNodeChildren( node ) + \"</span>\";\n  else\n  if ( node.tagName == GD_NATIVE_TO_WS( L\"s\" ) || node.tagName == GD_NATIVE_TO_WS( L\"video\" ) )\n  {\n    string filename = Filetype::simplifyString( Utf8::encode( node.renderAsText() ), false );\n    string n = resourceDir1 + FsEncoding::encode( filename );\n\n    if ( Filetype::isNameOfSound( filename ) )\n    {\n      // If we have the file here, do the exact reference to this dictionary.\n      // Otherwise, make a global 'search' one.\n\n      bool search =\n          !File::exists( n ) && !File::exists( resourceDir2 + FsEncoding::encode( filename ) ) &&\n          !File::exists( FsEncoding::dirname( getDictionaryFilenames()[ 0 ] ) +\n                                              FsEncoding::separator() +\n                                              FsEncoding::encode( filename ) ) &&\n          ( !resourceZip.isOpen() ||\n            !resourceZip.hasFile( Utf8::decode( filename ) ) );\n\n      QUrl url;\n      url.setScheme( \"gdau\" );\n      url.setHost( QString::fromUtf8( search ? \"search\" : getId().c_str() ) );\n      url.setPath( Qt4x5::Url::ensureLeadingSlash( QString::fromUtf8( filename.c_str() ) ) );\n      if( search && idxHeader.hasSoundDictionaryName )\n        Qt4x5::Url::setFragment( url, QString::fromUtf8( preferredSoundDictionary.c_str() ) );\n\n      string ref = string( \"\\\"\" ) + url.toEncoded().data() + \"\\\"\";\n\n      result += addAudioLink( ref, getId() );\n\n      result += \"<span class=\\\"dsl_s_wav\\\"><a href=\" + ref\n         + \"><img src=\\\"qrcx://localhost/icons/playsound.png\\\" border=\\\"0\\\" align=\\\"absmiddle\\\" alt=\\\"Play\\\"/></a></span>\";\n    }\n    else\n    if ( Filetype::isNameOfPicture( filename ) )\n    {\n      QUrl url;\n      url.setScheme( \"bres\" );\n      url.setHost( QString::fromUtf8( getId().c_str() ) );\n      url.setPath( Qt4x5::Url::ensureLeadingSlash( QString::fromUtf8( filename.c_str() ) ) );\n\n      vector< char > imgdata;\n      bool resize = false;\n\n      try\n      {\n        File::loadFromFile( n, imgdata );\n      }\n      catch( File::exCantOpen & )\n      {\n        try\n        {\n          n = resourceDir2 + FsEncoding::encode( filename );\n          File::loadFromFile( n, imgdata );\n        }\n        catch( File::exCantOpen & )\n        {\n          try\n          {\n            n = FsEncoding::dirname( getDictionaryFilenames()[ 0 ] ) +\n                FsEncoding::separator() +\n                FsEncoding::encode( filename );\n            File::loadFromFile( n, imgdata );\n          }\n          catch( File::exCantOpen & )\n          {\n            // Try reading from zip file\n            if ( resourceZip.isOpen() )\n            {\n              Mutex::Lock _( resourceZipMutex );\n              resourceZip.loadFile( Utf8::decode( filename ), imgdata );\n            }\n          }\n        }\n      }\n      catch(...)\n      {\n      }\n\n      if( !imgdata.empty() )\n      {\n        if( Filetype::isNameOfSvg( filename ) )\n        {\n          // We don't need to render svg file now\n\n          QSvgRenderer svg;\n          svg.load( QByteArray::fromRawData( imgdata.data(), imgdata.size() ) );\n          if( svg.isValid() )\n          {\n            QSize imgsize = svg.defaultSize();\n            resize = maxPictureWidth > 0\n                     && imgsize.width() > maxPictureWidth;\n          }\n        }\n        else\n        {\n          QImage img = QImage::fromData( (unsigned char *) &imgdata.front(),\n                                         imgdata.size() );\n\n#ifdef MAKE_EXTRA_TIFF_HANDLER\n          if( img.isNull() && Filetype::isNameOfTiff( filename ) )\n            GdTiff::tiffToQImage( &imgdata.front(), imgdata.size(), img );\n#endif\n\n          resize = maxPictureWidth > 0\n                   && img.width() > maxPictureWidth;\n        }\n      }\n\n      if( resize )\n      {\n        string link( url.toEncoded().data() );\n        link.replace( 0, 4, \"gdpicture\" );\n        result += string( \"<a href=\\\"\" ) + link + \"\\\">\"\n                          + \"<img src=\\\"\" + url.toEncoded().data()\n                          + \"\\\" alt=\\\"\" + Html::escape( filename ) + \"\\\"\"\n                          + \"width=\\\"\" + QString::number( maxPictureWidth).toStdString() + \"\\\"/>\"\n                          + \"</a>\";\n      }\n      else\n        result += string( \"<img src=\\\"\" ) + url.toEncoded().data()\n                  + \"\\\" alt=\\\"\" + Html::escape( filename ) + \"\\\"/>\";\n    }\n    else\n    if ( Filetype::isNameOfVideo( filename ) ) {\n      QUrl url;\n      url.setScheme( \"gdvideo\" );\n      url.setHost( QString::fromUtf8( getId().c_str() ) );\n      url.setPath( Qt4x5::Url::ensureLeadingSlash( QString::fromUtf8( filename.c_str() ) ) );\n\n      result += string( \"<a class=\\\"dsl_s dsl_video\\\" href=\\\"\" ) + url.toEncoded().data() + \"\\\">\"\n             + \"<span class=\\\"img\\\"></span>\"\n             + \"<span class=\\\"filename\\\">\" + processNodeChildren( node ) + \"</span>\" + \"</a>\";\n    }\n    else\n    {\n      // Unknown file type, downgrade to a hyperlink\n\n      QUrl url;\n      url.setScheme( \"bres\" );\n      url.setHost( QString::fromUtf8( getId().c_str() ) );\n      url.setPath( Qt4x5::Url::ensureLeadingSlash( QString::fromUtf8( filename.c_str() ) ) );\n\n      result += string( \"<a class=\\\"dsl_s\\\" href=\\\"\" ) + url.toEncoded().data()\n             + \"\\\">\" + processNodeChildren( node ) + \"</a>\";\n    }\n  }\n  else\n  if ( node.tagName == GD_NATIVE_TO_WS( L\"url\" ) )\n  {\n    string link;\n    if( !node.tagAttrs.empty() )\n    {\n      QString attrs = gd::toQString( node.tagAttrs );\n      int n = attrs.indexOf( \"target=\\\"\" );\n      if( n >= 0 )\n      {\n        QString target = attrs.mid( n + 8 );\n        if( target.endsWith( '\\\"' ) )\n          target.chop( 1 );\n        link = Html::escape( Filetype::simplifyString( string( target.toUtf8().data() ), false ) );\n      }\n    }\n    if( link.empty() )\n      link = Html::escape( Filetype::simplifyString( Utf8::encode( node.renderAsText() ), false ) );\n\n    if( QUrl::fromEncoded( link.c_str() ).scheme().isEmpty() )\n      link = \"http://\" + link;\n\n    QUrl url( QString::fromUtf8( link.c_str() ) );\n    if( url.isLocalFile() && url.host().isEmpty() )\n    {\n      // Convert relative links to local files to absolute ones\n      QString name = QFileInfo( getMainFilename() ).absolutePath();\n      name += url.toLocalFile();\n      QFileInfo info( name );\n      if( info.isFile() )\n      {\n        name = info.canonicalFilePath();\n        url.setPath( Qt4x5::Url::ensureLeadingSlash( QUrl::fromLocalFile( name ).path() ) );\n        link = string( url.toEncoded().data() );\n      }\n    }\n\n    result += \"<a class=\\\"dsl_url\\\" href=\\\"\" + link +\"\\\">\" + processNodeChildren( node ) + \"</a>\";\n  }\n  else\n  if ( node.tagName == GD_NATIVE_TO_WS( L\"!trs\" ) )\n  {\n    result += \"<span class=\\\"dsl_trs\\\">\" + processNodeChildren( node ) + \"</span>\";\n  }\n  else\n  if ( node.tagName == GD_NATIVE_TO_WS( L\"p\") )\n  {\n    result += \"<span class=\\\"dsl_p\\\"\";\n\n    string val = Utf8::encode( node.renderAsText() );\n\n    // If we have such a key, display a title\n\n    map< string, string >::const_iterator i = abrv.find( val );\n\n    if ( i != abrv.end() )\n    {\n      string title;\n\n      if ( Utf8::decode( i->second ).size() < 70 )\n      {\n        // Replace all spaces with non-breakable ones, since that's how\n        // Lingvo shows tooltips\n        title.reserve( i->second.size() );\n\n        for( char const * c = i->second.c_str(); *c; ++c )\n        {\n          if ( *c == ' ' || *c == '\\t' )\n          {\n            // u00A0 in utf8\n            title.push_back( 0xC2 );\n            title.push_back( 0xA0 );\n          }\n          else\n          if( *c == '-' ) // Change minus to non-breaking hyphen (uE28091 in utf8)\n          {\n            title.push_back( 0xE2 );\n            title.push_back( 0x80 );\n            title.push_back( 0x91 );\n          }\n          else\n            title.push_back( *c );\n        }\n      }\n      else\n        title = i->second;\n\n      result += \" title=\\\"\" + Html::escape( title ) + \"\\\"\";\n    }\n\n    result += \">\" + processNodeChildren( node ) + \"</span>\";\n  }\n  else\n  if ( node.tagName == GD_NATIVE_TO_WS( L\"'\" ) )\n  {\n    // There are two ways to display the stress: by adding an accent sign or via font styles.\n    // We generate two spans, one with accented data and another one without it, so the\n    // user could pick up the best suitable option.\n    string data = processNodeChildren( node );\n    result += \"<span class=\\\"dsl_stress\\\"><span class=\\\"dsl_stress_without_accent\\\">\" + data + \"</span>\"\n        + \"<span class=\\\"dsl_stress_with_accent\\\">\" + data + Utf8::encode( wstring( 1, 0x301 ) )\n        + \"</span></span>\";\n  }\n  else\n  if ( node.tagName == GD_NATIVE_TO_WS( L\"lang\" ) )\n  {\n    result += \"<span class=\\\"dsl_lang\\\"\";\n    if( !node.tagAttrs.empty() )\n    {\n      // Find ISO 639-1 code\n      string langcode;\n      QString attr = gd::toQString( node.tagAttrs );\n      int n = attr.indexOf( \"id=\" );\n      if( n >= 0 )\n      {\n        int id = attr.mid( n + 3 ).toInt();\n        if( id )\n          langcode = findCodeForDslId( id );\n      }\n      else\n      {\n        n = attr.indexOf( \"name=\\\"\" );\n        if( n >= 0 )\n        {\n          int n2 = attr.indexOf( '\\\"', n + 6 );\n          if( n2 > 0 )\n          {\n            quint32 id = dslLanguageToId( gd::toWString( attr.mid( n + 6, n2 - n - 6 ) ) );\n            langcode = LangCoder::intToCode2( id ).toStdString();\n          }\n        }\n      }\n      if( !langcode.empty() )\n        result += \" lang=\\\"\" + langcode + \"\\\"\";\n    }\n    result += \">\" + processNodeChildren( node ) + \"</span>\";\n  }\n  else\n  if ( node.tagName == GD_NATIVE_TO_WS( L\"ref\" ) )\n  {\n    QUrl url;\n    QString attrs;\n    if( !node.tagAttrs.empty() )\n      attrs = gd::toQString( node.tagAttrs );\n\n    wstring refStr;\n    if( !attrs.isEmpty() )\n    {\n      int n = attrs.indexOf( \"target=\\\"\" );\n      if( n >= 0 )\n      {\n        int n_end = attrs.indexOf( '\\\"', n + 8 );\n        QString target = attrs.mid( n, n_end > n ? n_end - n + 1 : -1 );\n        attrs.remove( target );\n        if( !attrs.isEmpty() )\n          attrs = attrs.trimmed();\n\n        target = target.mid( 8 );\n        if( target.endsWith( '\\\"' ) )\n          target.chop( 1 );\n        refStr = gd::toWString( target );\n      }\n    }\n\n    url.setScheme( \"gdlookup\" );\n    url.setHost( \"localhost\" );\n\n    if( refStr.empty() )\n      refStr = node.renderAsText();\n    normalizeHeadword( refStr );\n    url.setPath( Qt4x5::Url::ensureLeadingSlash( gd::toQString( refStr ) ) );\n    if( !attrs.isEmpty() )\n    {\n      QString attr = attrs.remove( '\\\"' );\n      int n = attr.indexOf( '=' );\n      if( n > 0 )\n      {\n        QList< QPair< QString, QString > > query;\n        query.append( QPair< QString, QString >( attr.left( n ), attr.mid( n + 1 ) ) );\n        Qt4x5::Url::setQueryItems( url, query );\n      }\n    }\n\n    result += string( \"<a class=\\\"dsl_ref\\\" href=\\\"\" ) + url.toEncoded().data() +\"\\\">\"\n              + processNodeChildren( node ) + \"</a>\";\n  }\n  else\n  if ( node.tagName == GD_NATIVE_TO_WS( L\"@\" ) )\n  {\n    // Special case - insided card header was not parsed\n\n    QUrl url;\n\n    url.setScheme( \"gdlookup\" );\n    url.setHost( \"localhost\" );\n    wstring nodeStr = node.renderAsText();\n    normalizeHeadword( nodeStr );\n    url.setPath( Qt4x5::Url::ensureLeadingSlash( gd::toQString( nodeStr ) ) );\n\n    result += string( \"<a class=\\\"dsl_ref\\\" href=\\\"\" ) + url.toEncoded().data() +\"\\\">\"\n              + processNodeChildren( node ) + \"</a>\";\n  }\n  else\n  if ( node.tagName == GD_NATIVE_TO_WS( L\"sub\" ) )\n  {\n    result += \"<sub>\" + processNodeChildren( node ) + \"</sub>\";\n  }\n  else\n  if ( node.tagName == GD_NATIVE_TO_WS( L\"sup\" ) )\n  {\n    result += \"<sup>\" + processNodeChildren( node ) + \"</sup>\";\n  }\n  else\n  if ( node.tagName == GD_NATIVE_TO_WS( L\"t\" ) )\n  {\n    result += \"<span class=\\\"dsl_t\\\">\" + processNodeChildren( node ) + \"</span>\";\n  }\n  else\n  if ( node.tagName == GD_NATIVE_TO_WS( L\"br\" ) )\n  {\n    result += \"<br />\";\n  }\n  else\n  {\n    gdWarning( \"DSL: Unknown tag \\\"%s\\\" with attributes \\\"%s\\\" found in \\\"%s\\\", article \\\"%s\\\".\",\n               gd::toQString( node.tagName ).toUtf8().data(), gd::toQString( node.tagAttrs ).toUtf8().data(),\n               getName().c_str(), gd::toQString( currentHeadword ).toUtf8().data() );\n\n    result += \"<span class=\\\"dsl_unknown\\\">[\" + string( gd::toQString( node.tagName ).toUtf8().data() );\n    if( !node.tagAttrs.empty() )\n      result += \" \" + string( gd::toQString( node.tagAttrs ).toUtf8().data() );\n    result += \"]\" + processNodeChildren( node ) + \"</span>\";\n  }\n\n  return result;\n}\n\nQString const& DslDictionary::getDescription()\n{\n    if( !dictionaryDescription.isEmpty() )\n        return dictionaryDescription;\n\n    dictionaryDescription = \"NONE\";\n\n    QString fileName =\n      QDir::fromNativeSeparators( FsEncoding::decode( getDictionaryFilenames()[ 0 ].c_str() ) );\n\n    // Remove the extension\n    if ( fileName.endsWith( \".dsl.dz\", Qt::CaseInsensitive ) )\n      fileName.chop( 6 );\n    else\n      fileName.chop( 3 );\n\n    fileName += \"ann\";\n    QFileInfo info( fileName );\n\n    if ( info.exists() )\n    {\n        QFile annFile( fileName );\n        if( !annFile.open( QFile::ReadOnly | QFile::Text ) )\n            return dictionaryDescription;\n\n        QTextStream annStream( &annFile );\n        QString data, str;\n\n        str = annStream.readLine();\n\n        if( str.left( 10 ).compare( \"#LANGUAGE \" ) != 0 )\n        {\n            annStream.seek( 0 );\n            dictionaryDescription = annStream.readAll();\n        }\n        else\n        {\n            // Multilanguage annotation\n\n            qint32 gdLang, annLang;\n            QString langStr;\n            gdLang = LangCoder::code2toInt( QLocale::system().name().left( 2 ).toLatin1().data() );\n            for(;;)\n            {\n                data.clear();\n                langStr = str.mid( 10 ).replace( '\\\"', ' ').trimmed();\n                annLang = LangCoder::findIdForLanguage( gd::toWString( langStr ) );\n                do\n                {\n                    str = annStream.readLine();\n                    if( str.left( 10 ).compare( \"#LANGUAGE \" ) == 0 )\n                        break;\n                    if( !str.endsWith( '\\n' ) )\n                        str.append( '\\n' );\n                    data += str;\n                }\n                while ( !annStream.atEnd() );\n                if( dictionaryDescription.compare( \"NONE \") == 0 || langStr.compare( \"English\", Qt::CaseInsensitive ) == 0 || gdLang == annLang )\n                    dictionaryDescription = data.trimmed();\n                if( gdLang == annLang || annStream.atEnd() )\n                    break;\n            }\n        }\n    }\n    return dictionaryDescription;\n}\n\nQString DslDictionary::getMainFilename()\n{\n  return FsEncoding::decode( getDictionaryFilenames()[ 0 ].c_str() );\n}\n\nvoid DslDictionary::makeFTSIndex( QAtomicInt & isCancelled, bool firstIteration )\n{\n  if( !( Dictionary::needToRebuildIndex( getDictionaryFilenames(), ftsIdxName )\n         || FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) ) )\n    FTS_index_completed.ref();\n\n\n  if( haveFTSIndex() )\n    return;\n\n  if( ensureInitDone().size() )\n    return;\n\n  if( firstIteration && getArticleCount() > FTS::MaxDictionarySizeForFastSearch )\n    return;\n\n  gdDebug( \"Dsl: Building the full-text index for dictionary: %s\\n\",\n           getName().c_str() );\n\n  try\n  {\n    FtsHelpers::makeFTSIndex( this, isCancelled );\n    FTS_index_completed.ref();\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"DSL: Failed building full-text search index for \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n    QFile::remove( FsEncoding::decode( ftsIdxName.c_str() ) );\n  }\n}\n\nvoid DslDictionary::getArticleText( uint32_t articleAddress, QString & headword, QString & text )\n{\n  headword.clear();\n  text.clear();\n\n  vector< char > chunk;\n\n  char * articleProps;\n  wstring articleData;\n\n  {\n    Mutex::Lock _( idxMutex );\n    articleProps = chunks->getBlock( articleAddress, chunk );\n  }\n\n  uint32_t articleOffset, articleSize;\n\n  memcpy( &articleOffset, articleProps, sizeof( articleOffset ) );\n  memcpy( &articleSize, articleProps + sizeof( articleOffset ),\n          sizeof( articleSize ) );\n\n  char * articleBody;\n\n  {\n    Mutex::Lock _( dzMutex );\n    articleBody = dict_data_read_( dz, articleOffset, articleSize, 0, 0 );\n  }\n\n  if ( !articleBody )\n  {\n    return;\n  }\n  else\n  {\n    try\n    {\n      articleData =\n        DslIconv::toWstring(\n          DslIconv::getEncodingNameFor( DslEncoding( idxHeader.dslEncoding ) ),\n          articleBody, articleSize );\n      free( articleBody );\n\n      // Strip DSL comments\n      bool b = false;\n      stripComments( articleData, b );\n    }\n    catch( ... )\n    {\n      free( articleBody );\n      return;\n    }\n  }\n\n  // Skip headword\n\n  size_t pos = 0;\n  wstring articleHeadword, tildeValue;\n\n  // Check if we retrieve insided card\n  bool insidedCard = isDslWs( articleData.at( 0 ) );\n\n  for( ; ; )\n  {\n    size_t begin = pos;\n\n    pos = articleData.find_first_of( GD_NATIVE_TO_WS( L\"\\n\\r\" ), begin );\n\n    if ( articleHeadword.empty() )\n    {\n      // Process the headword\n\n      articleHeadword = wstring( articleData, begin, pos - begin );\n\n      if( insidedCard && !articleHeadword.empty() && isDslWs( articleHeadword[ 0 ] ) )\n      {\n        // Headword of the insided card\n        wstring::size_type hpos = articleHeadword.find( L'@' );\n        if( hpos != string::npos )\n        {\n          wstring head = Folding::trimWhitespace( articleHeadword.substr( hpos + 1 ) );\n          hpos = head.find( L'~' );\n          while( hpos != string::npos )\n          {\n            if( hpos == 0 || head[ hpos ] != L'\\\\' )\n              break;\n            hpos = head.find( L'~', hpos + 1 );\n          }\n          if( hpos == string::npos )\n            articleHeadword = head;\n          else\n            articleHeadword.clear();\n        }\n      }\n\n      if( !articleHeadword.empty() )\n      {\n        list< wstring > lst;\n\n        tildeValue = articleHeadword;\n\n        processUnsortedParts( articleHeadword, true );\n        expandOptionalParts( articleHeadword, &lst );\n\n        if ( lst.size() ) // Should always be\n          articleHeadword = lst.front();\n      }\n    }\n\n    if ( pos == articleData.size() )\n      break;\n\n    // Skip \\n\\r\n\n    if ( articleData[ pos ] == '\\r' )\n      ++pos;\n\n    if ( pos != articleData.size() )\n    {\n      if ( articleData[ pos ] == '\\n' )\n        ++pos;\n    }\n\n    if ( pos == articleData.size() )\n    {\n      // Ok, it's end of article\n      break;\n    }\n    if( isDslWs( articleData[ pos ] ) )\n    {\n     // Check for begin article text\n      if( insidedCard )\n      {\n        // Check for next insided headword\n        wstring::size_type hpos = articleData.find_first_of( GD_NATIVE_TO_WS( L\"\\n\\r\" ), pos );\n        if ( hpos == wstring::npos )\n          hpos = articleData.size();\n\n        wstring str = wstring( articleData, pos, hpos - pos );\n\n        hpos = str.find( L'@');\n        if( hpos == wstring::npos || str[ hpos - 1 ] == L'\\\\' || !isAtSignFirst( str ) )\n          break;\n      }\n      else\n        break;\n    }\n  }\n\n  if( !articleHeadword.empty() )\n  {\n    unescapeDsl( articleHeadword );\n    normalizeHeadword( articleHeadword );\n    headword = gd::toQString( articleHeadword );\n  }\n\n  wstring articleText;\n\n  if ( pos != articleData.size() )\n    articleText = wstring( articleData, pos );\n  else\n    articleText.clear();\n\n  if( !tildeValue.empty() )\n  {\n    list< wstring > lst;\n\n    processUnsortedParts( tildeValue, false );\n    expandOptionalParts( tildeValue, &lst );\n\n    if ( lst.size() ) // Should always be\n      expandTildes( articleText, lst.front() );\n  }\n\n  if( !articleText.empty() )\n  {\n    text = gd::toQString( articleText ).normalized( QString::NormalizationForm_C );\n\n    articleText.clear();\n\n    // Parse article text\n\n    // Strip some areas\n\n    const int stripTagsNumber = 5;\n    static QString stripTags[ stripTagsNumber ] =\n                                                  {\n                                                    \"s\",\n                                                    \"url\",\n                                                    \"!trs\",\n                                                    \"video\",\n                                                    \"preview\"\n                                                  };\n    static QString stripEndTags[ stripTagsNumber ] =\n                                                  {\n                                                    \"[/s]\",\n                                                    \"[/url]\",\n                                                    \"[/!trs]\",\n                                                    \"[/video]\",\n                                                    \"[/preview]\"\n                                                  };\n\n    int pos = 0;\n    while( pos >= 0 )\n    {\n      pos = text.indexOf( '[', pos, Qt::CaseInsensitive );\n      if( pos >= 0 )\n      {\n        if( ( pos > 0 && text[ pos - 1 ] == '\\\\' && ( pos < 2 || text[ pos - 2 ] != '\\\\' ) )\n              || ( pos > text.size() - 2 || text[ pos + 1 ] == '/' ) )\n        {\n          pos += 1;\n          continue;\n        }\n\n        int pos2 = text.indexOf( ']',  pos + 1, Qt::CaseInsensitive );\n        if( pos2 < 0 )\n          break;\n\n        QString tag = text.mid( pos + 1, pos2 - pos - 1 );\n\n        int n;\n        for( n = 0; n < stripTagsNumber; n++ )\n        {\n          if( tag.compare( stripTags[ n ], Qt::CaseInsensitive ) == 0 )\n          {\n            pos2 = text.indexOf( stripEndTags[ n ] , pos + stripTags[ n ].size() + 2, Qt::CaseInsensitive );\n            text.replace( pos, pos2 > 0 ? pos2 - pos + stripEndTags[ n ].length() : text.length() - pos, \" \" );\n            break;\n          }\n        }\n\n        if( n >= stripTagsNumber )\n          pos += 1;\n      }\n    }\n\n    // Strip tags\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n    text.replace( QRegularExpression( \"\\\\[(|/)(p|trn|ex|com|\\\\*|t|br|m[0-9]?)\\\\]\" ), \" \" );\n    text.replace( QRegularExpression( \"\\\\[(|/)lang(\\\\s[^\\\\]]*)?\\\\]\" ), \" \" );\n    text.remove( QRegularExpression( \"\\\\[[^\\\\\\\\\\\\[\\\\]]+\\\\]\" ) );\n#else\n    text.replace( QRegExp( \"\\\\[(|/)(p|trn|ex|com|\\\\*|t|br|m[0-9]?)\\\\]\" ), \" \" );\n    text.replace( QRegExp( \"\\\\[(|/)lang(\\\\s[^\\\\]]*)?\\\\]\" ), \" \" );\n    text.remove( QRegExp( \"\\\\[[^\\\\\\\\\\\\[\\\\]]+\\\\]\" ) );\n#endif\n    text.remove( QString::fromLatin1( \"<<\" ) );\n    text.remove( QString::fromLatin1( \">>\" ) );\n\n    // Chech for insided cards\n\n    bool haveInsidedCards = false;\n    pos = 0;\n    while( pos >= 0 )\n    {\n      pos = text.indexOf( \"@\", pos );\n      if( pos > 0 && text.at( pos - 1 ) != '\\\\' )\n      {\n        haveInsidedCards = true;\n        break;\n      }\n\n      if( pos >= 0 )\n        pos += 1;\n    }\n\n    if( haveInsidedCards )\n    {\n      // Use base DSL parser for articles with insided cards\n      ArticleDom dom( gd::toWString( text ), getName(), articleHeadword );\n      text = gd::toQString( dom.root.renderAsText( true ) );\n    }\n    else\n    {\n      // Unescape DSL symbols\n      pos = 0;\n      while( pos >= 0 )\n      {\n        pos = text.indexOf( '\\\\', pos );\n        if( pos >= 0 )\n        {\n          if( text[ pos + 1 ] == '\\\\' )\n            pos += 1;\n\n          text.remove( pos, 1 );\n        }\n      }\n    }\n  }\n}\n\n/// DslDictionary::getArticle()\n\nclass DslArticleRequest;\n\nclass DslArticleRequestRunnable: public QRunnable\n{\n  DslArticleRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  DslArticleRequestRunnable( DslArticleRequest & r_,\n                             QSemaphore & hasExited_ ): r( r_ ),\n                                                        hasExited( hasExited_ )\n  {}\n\n  ~DslArticleRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass DslArticleRequest: public Dictionary::DataRequest\n{\n  friend class DslArticleRequestRunnable;\n\n  wstring word;\n  vector< wstring > alts;\n  DslDictionary & dict;\n  bool ignoreDiacritics;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  DslArticleRequest( wstring const & word_,\n                     vector< wstring > const & alts_,\n                     DslDictionary & dict_, bool ignoreDiacritics_ ):\n    word( word_ ), alts( alts_ ), dict( dict_ ), ignoreDiacritics( ignoreDiacritics_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new DslArticleRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by DslArticleRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~DslArticleRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid DslArticleRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid DslArticleRequest::run()\n{\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  if ( dict.ensureInitDone().size() )\n  {\n    setErrorString( QString::fromUtf8( dict.ensureInitDone().c_str() ) );\n    finish();\n    return;\n  }\n\n  vector< WordArticleLink > chain = dict.findArticles( word, ignoreDiacritics );\n\n  for( unsigned x = 0; x < alts.size(); ++x )\n  {\n    /// Make an additional query for each alt\n\n    vector< WordArticleLink > altChain = dict.findArticles( alts[ x ], ignoreDiacritics );\n\n    chain.insert( chain.end(), altChain.begin(), altChain.end() );\n  }\n\n  // Some synonyms make it that the articles appear several times. We combat\n  // this by only allowing them to appear once. Dsl treats different headwords\n  // of the same article as different articles, so we also include headword\n  // index here.\n  set< pair< uint32_t, unsigned > > articlesIncluded;\n\n  wstring wordCaseFolded = Folding::applySimpleCaseOnly( word );\n\n  for( unsigned x = 0; x < chain.size(); ++x )\n  {\n    // Check if we're cancelled occasionally\n    if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    {\n      finish();\n      return;\n    }\n\n    // Grab that article\n\n    wstring tildeValue;\n    wstring displayedHeadword;\n    wstring articleBody;\n    unsigned headwordIndex;\n\n    string articleText, articleAfter;\n\n    try\n    {\n      dict.loadArticle( chain[ x ].articleOffset, wordCaseFolded, ignoreDiacritics, tildeValue,\n                        displayedHeadword, headwordIndex, articleBody );\n\n      if ( !articlesIncluded.insert( std::make_pair( chain[ x ].articleOffset,\n                                                     headwordIndex ) ).second )\n        continue; // We already have this article in the body.\n\n      dict.articleNom += 1;\n\n      if( displayedHeadword.empty() || isDslWs( displayedHeadword[ 0 ] ) )\n        displayedHeadword = word; // Special case - insided card\n\n      articleText += \"<div class=\\\"dsl_article\\\">\";\n      articleText += \"<div class=\\\"dsl_headwords\\\"\";\n      if( dict.isFromLanguageRTL() )\n        articleText += \" dir=\\\"rtl\\\"\";\n      articleText += \"><p>\";\n\n      if( displayedHeadword.size() == 1 && displayedHeadword[0] == '<' )  // Fix special case - \"<\" header\n          articleText += \"<\";                                             // dslToHtml can't handle it correctly.\n      else\n        articleText += dict.dslToHtml( displayedHeadword, displayedHeadword );\n\n      /// After this may be expand button will be inserted\n\n      articleAfter += \"</p></div>\";\n\n      expandTildes( articleBody, tildeValue );\n\n      articleAfter += \"<div class=\\\"dsl_definition\\\"\";\n      if( dict.isToLanguageRTL() )\n        articleAfter += \" dir=\\\"rtl\\\"\";\n      articleAfter += \">\";\n\n      articleAfter += dict.dslToHtml( articleBody, displayedHeadword );\n      articleAfter += \"</div>\";\n      articleAfter += \"</div>\";\n\n      if( dict.hasHiddenZones() )\n      {\n        string prefix = \"O\" + dict.getId().substr( 0, 7 ) + \"_\" + QString::number( dict.articleNom ).toStdString();\n        string id1 = prefix + \"_expand\";\n        string id2 = prefix + \"_opt_\";\n        string button = \" <img src=\\\"qrcx://localhost/icons/expand_opt.png\\\" class=\\\"hidden_expand_opt\\\" id=\\\"\" + id1 +\n                        \"\\\" onclick=\\\"gdExpandOptPart('\" + id1 + \"','\" + id2 +\"')\\\" alt=\\\"[+]\\\"/>\";\n        if( articleText.compare( articleText.size() - 4, 4, \"</p>\" ) == 0 )\n          articleText.insert( articleText.size() - 4, \" \" + button );\n        else\n          articleText += button;\n      }\n\n      articleText += articleAfter;\n    }\n    catch( std::exception &ex )\n    {\n      gdWarning( \"DSL: Failed loading article from \\\"%s\\\", reason: %s\\n\", dict.getName().c_str(), ex.what() );\n      articleText = string( \"<span class=\\\"dsl_article\\\">\" )\n                    + string( QObject::tr( \"Article loading error\" ).toUtf8().constData() )\n                    + \"</span>\";\n    }\n\n    Mutex::Lock _( dataMutex );\n\n    data.resize( data.size() + articleText.size() );\n\n    memcpy( &data.front() + data.size() - articleText.size(),\n            articleText.data(), articleText.size() );\n\n    hasAnyData = true;\n  }\n\n  finish();\n}\n\nsptr< Dictionary::DataRequest > DslDictionary::getArticle( wstring const & word,\n                                                           vector< wstring > const & alts,\n                                                           wstring const &,\n                                                           bool ignoreDiacritics )\n  THROW_SPEC( std::exception )\n{\n  return new DslArticleRequest( word, alts, *this, ignoreDiacritics );\n}\n\n//// DslDictionary::getResource()\n\nclass DslResourceRequest;\n\nclass DslResourceRequestRunnable: public QRunnable\n{\n  DslResourceRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  DslResourceRequestRunnable( DslResourceRequest & r_,\n                              QSemaphore & hasExited_ ): r( r_ ),\n                                                         hasExited( hasExited_ )\n  {}\n\n  ~DslResourceRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass DslResourceRequest: public Dictionary::DataRequest\n{\n  friend class DslResourceRequestRunnable;\n\n  DslDictionary & dict;\n\n  string resourceName;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  DslResourceRequest( DslDictionary & dict_,\n                      string const & resourceName_ ):\n    dict( dict_ ),\n    resourceName( resourceName_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new DslResourceRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by DslResourceRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~DslResourceRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid DslResourceRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid DslResourceRequest::run()\n{\n  // Some runnables linger enough that they are cancelled before they start\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  if ( dict.ensureInitDone().size() )\n  {\n    setErrorString( QString::fromUtf8( dict.ensureInitDone().c_str() ) );\n    finish();\n    return;\n  }\n\n  string n =\n    FsEncoding::dirname( dict.getDictionaryFilenames()[ 0 ] ) +\n    FsEncoding::separator() +\n    FsEncoding::encode( resourceName );\n\n  GD_DPRINTF( \"n is %s\\n\", n.c_str() );\n\n  try\n  {\n    try\n    {\n      Mutex::Lock _( dataMutex );\n\n      File::loadFromFile( n, data );\n    }\n    catch( File::exCantOpen & )\n    {\n      n = dict.getResourceDir1() + FsEncoding::encode( resourceName );\n      try {\n        Mutex::Lock _( dataMutex );\n\n        File::loadFromFile( n, data );\n      }\n      catch( File::exCantOpen & )\n      {\n        n = dict.getResourceDir2() + FsEncoding::encode( resourceName );\n\n        try\n        {\n          Mutex::Lock _( dataMutex );\n\n          File::loadFromFile( n, data );\n        }\n        catch( File::exCantOpen & )\n        {\n          // Try reading from zip file\n\n          if ( dict.resourceZip.isOpen() )\n          {\n            Mutex::Lock _( dict.resourceZipMutex );\n\n            Mutex::Lock __( dataMutex );\n\n            if ( !dict.resourceZip.loadFile( Utf8::decode( resourceName ), data ) )\n              throw; // Make it fail since we couldn't read the archive\n          }\n          else\n            throw;\n        }\n      }\n    }\n\n    if ( Filetype::isNameOfTiff( resourceName ) )\n    {\n      // Convert it\n\n      dataMutex.lock();\n\n      QImage img = QImage::fromData( (unsigned char *) &data.front(),\n                                     data.size() );\n\n#ifdef MAKE_EXTRA_TIFF_HANDLER\n      if( img.isNull() )\n        GdTiff::tiffToQImage( &data.front(), data.size(), img );\n#endif\n\n      dataMutex.unlock();\n\n      if ( !img.isNull() )\n      {\n        // Managed to load -- now store it back as BMP\n\n        QByteArray ba;\n        QBuffer buffer( &ba );\n        buffer.open( QIODevice::WriteOnly );\n        img.save( &buffer, \"BMP\" );\n\n        Mutex::Lock _( dataMutex );\n\n        data.resize( buffer.size() );\n\n        memcpy( &data.front(), buffer.data(), data.size() );\n      }\n    }\n\n    Mutex::Lock _( dataMutex );\n\n    hasAnyData = true;\n  }\n  catch( std::exception &ex )\n  {\n    gdCWarning( dictionaryResourceLc, \"DSL: Failed loading resource \\\"%s\\\" for \\\"%s\\\", reason: %s\\n\",\n                resourceName.c_str(), dict.getName().c_str(), ex.what() );\n    // Resource not loaded -- we don't set the hasAnyData flag then\n  }\n\n  finish();\n}\n\nsptr< Dictionary::DataRequest > DslDictionary::getResource( string const & name )\n  THROW_SPEC( std::exception )\n{\n  return new DslResourceRequest( *this, name );\n}\n\n#if 0\nstatic void findCorrespondingFiles( string const & ifo,\n                                    string & idx, string & dict, string & syn,\n                                    bool needSyn )\n{\n  string base( ifo, 0, ifo.size() - 3 );\n\n  if ( !(\n          tryPossibleName( base + \"idx\", idx ) ||\n          tryPossibleName( base + \"idx.gz\", idx ) ||\n          tryPossibleName( base + \"idx.dz\", idx ) ||\n          tryPossibleName( base + \"IDX\", idx ) ||\n          tryPossibleName( base + \"IDX.GZ\", idx ) ||\n          tryPossibleName( base + \"IDX.DZ\", idx )\n      ) )\n    throw exNoIdxFile( ifo );\n\n  if ( !(\n          tryPossibleName( base + \"dict\", dict ) ||\n          tryPossibleName( base + \"dict.dz\", dict ) ||\n          tryPossibleName( base + \"DICT\", dict ) ||\n          tryPossibleName( base + \"dict.DZ\", dict )\n      ) )\n    throw exNoDictFile( ifo );\n\n  if ( needSyn && !(\n                     tryPossibleName( base + \"syn\", syn ) ||\n                     tryPossibleName( base + \"syn.gz\", syn ) ||\n                     tryPossibleName( base + \"syn.dz\", syn ) ||\n                     tryPossibleName( base + \"SYN\", syn ) ||\n                     tryPossibleName( base + \"SYN.GZ\", syn ) ||\n                     tryPossibleName( base + \"SYN.DZ\", syn )\n     ) )\n    throw exNoSynFile( ifo );\n}\n#endif\n\nsptr< Dictionary::DataRequest > DslDictionary::getSearchResults( QString const & searchString,\n                                                                 int searchMode, bool matchCase,\n                                                                 int distanceBetweenWords,\n                                                                 int maxResults,\n                                                                 bool ignoreWordsOrder,\n                                                                 bool ignoreDiacritics,\n                                                                 QThreadPool * ftsThreadPoolPtr )\n{\n  return new FtsHelpers::FTSResultsRequest( *this, searchString,searchMode, matchCase, distanceBetweenWords, maxResults, ignoreWordsOrder, ignoreDiacritics, ftsThreadPoolPtr );\n}\n\n} // anonymous namespace\n\n/// makeDictionaries\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing & initializing,\n                                      int maxPictureWidth, unsigned int maxHeadwordSize )\n  THROW_SPEC( std::exception )\n{\n  vector< sptr< Dictionary::Class > > dictionaries;\n\n  for( vector< string >::const_iterator i = fileNames.begin(); i != fileNames.end();\n       ++i )\n  {\n    // Try .dsl and .dsl.dz suffixes\n\n    bool uncompressedDsl = ( i->size() >= 4 &&\n                             strcasecmp( i->c_str() + ( i->size() - 4 ), \".dsl\" ) == 0 );\n    if ( !uncompressedDsl &&\n         ( i->size() < 7 ||\n           strcasecmp( i->c_str() + ( i->size() - 7 ), \".dsl.dz\" ) != 0 ) )\n      continue;\n\n    // Make sure it's not an abbreviation file\n\n    int extSize = ( uncompressedDsl ? 4 : 7 );\n    if ( i->size() - extSize >= 5 &&\n         strncasecmp( i->c_str() + i->size() - extSize - 5, \"_abrv\", 5 ) == 0 )\n    {\n      // It is, skip it\n      continue;\n    }\n\n    unsigned atLine = 0; // Indicates current line in .dsl, for debug purposes\n\n    try\n    {\n      vector< string > dictFiles( 1, *i );\n\n      // Check if there is an 'abrv' file present\n      string baseName = ( (*i)[ i->size() - 4 ] == '.' ) ?\n               string( *i, 0, i->size() - 4 ) : string( *i, 0, i->size() - 7 );\n\n      string abrvFileName;\n\n      if ( File::tryPossibleName( baseName + \"_abrv.dsl\", abrvFileName ) ||\n           File::tryPossibleName( baseName + \"_abrv.dsl.dz\", abrvFileName ) ||\n           File::tryPossibleName( baseName + \"_ABRV.DSL\", abrvFileName ) ||\n           File::tryPossibleName( baseName + \"_ABRV.DSL.DZ\", abrvFileName ) ||\n           File::tryPossibleName( baseName + \"_ABRV.DSL.dz\", abrvFileName ) )\n        dictFiles.push_back( abrvFileName );\n\n      string dictId = Dictionary::makeDictionaryId( dictFiles );\n\n      // See if there's a zip file with resources present. If so, include it.\n\n      string zipFileName;\n\n      if ( File::tryPossibleZipName( baseName + \".dsl.files.zip\", zipFileName ) ||\n           File::tryPossibleZipName( baseName + \".dsl.dz.files.zip\", zipFileName ) ||\n           File::tryPossibleZipName( baseName + \".DSL.FILES.ZIP\", zipFileName ) ||\n           File::tryPossibleZipName( baseName + \".DSL.DZ.FILES.ZIP\", zipFileName ) )\n        dictFiles.push_back( zipFileName );\n\n      string indexFile = indicesDir + dictId;\n\n      if ( Dictionary::needToRebuildIndex( dictFiles, indexFile ) ||\n           indexIsOldOrBad( indexFile, zipFileName.size() ) )\n      {\n        DslScanner scanner( *i );\n\n        try { // Here we intercept any errors during the read to save line at\n              // which the incident happened. We need alive scanner for that.\n\n        if ( scanner.getDictionaryName() == GD_NATIVE_TO_WS( L\"Abbrev\" ) )\n          continue; // For now just skip abbreviations\n\n        // Building the index\n        initializing.indexingDictionary( Utf8::encode( scanner.getDictionaryName() ) );\n\n        gdDebug( \"Dsl: Building the index for dictionary: %s\\n\",\n                 gd::toQString( scanner.getDictionaryName() ).toUtf8().data() );\n\n        File::Class idx( indexFile, \"wb\" );\n\n        IdxHeader idxHeader;\n\n        memset( &idxHeader, 0, sizeof( idxHeader ) );\n\n        // We write a dummy header first. At the end of the process the header\n        // will be rewritten with the right values.\n\n        idx.write( idxHeader );\n\n        string dictionaryName = Utf8::encode( scanner.getDictionaryName() );\n\n        idx.write( (uint32_t) dictionaryName.size() );\n        idx.write( dictionaryName.data(), dictionaryName.size() );\n\n        string soundDictName = Utf8::encode( scanner.getSoundDictionaryName() );\n        if( !soundDictName.empty() )\n        {\n          idxHeader.hasSoundDictionaryName = 1;\n          idx.write( (uint32_t) soundDictName.size() );\n          idx.write( soundDictName.data(), soundDictName.size() );\n        }\n\n        idxHeader.dslEncoding = scanner.getEncoding();\n\n        IndexedWords indexedWords;\n\n        ChunkedStorage::Writer chunks( idx );\n\n        // Read the abbreviations\n\n        if ( abrvFileName.size() )\n        {\n          try\n          {\n            DslScanner abrvScanner( abrvFileName );\n\n            map< string, string > abrv;\n\n            wstring curString;\n            size_t curOffset;\n\n            for( ; ; )\n            {\n              // Skip any whitespace\n              if ( !abrvScanner.readNextLineWithoutComments( curString, curOffset ) )\n                break;\n              if ( curString.empty() || isDslWs( curString[ 0 ] ) )\n                continue;\n\n              list< wstring > keys;\n\n              bool eof = false;\n\n              // Insert the key and read more, or get to the definition\n              for( ; ; )\n              {\n                processUnsortedParts( curString, true );\n\n                if ( keys.size() )\n                  expandTildes( curString, keys.front() );\n\n                expandOptionalParts( curString, &keys );\n\n                if ( !abrvScanner.readNextLineWithoutComments( curString, curOffset ) || curString.empty() )\n                {\n                  gdWarning( \"Premature end of file %s\\n\", abrvFileName.c_str() );\n                  eof = true;\n                  break;\n                }\n\n                if ( isDslWs( curString[ 0 ] ) )\n                  break;\n              }\n\n              if ( eof )\n                break;\n\n              curString.erase( 0, curString.find_first_not_of( GD_NATIVE_TO_WS( L\" \\t\" ) ) );\n\n              if ( keys.size() )\n                expandTildes( curString, keys.front() );\n\n              // If the string has any dsl markup, we strip it\n              string value = Utf8::encode( ArticleDom( curString ).root.renderAsText() );\n\n              for( list< wstring >::iterator i = keys.begin(); i != keys.end();\n                   ++i )\n              {\n                unescapeDsl( *i );\n                normalizeHeadword( *i );\n\n                abrv[ Utf8::encode( Folding::trimWhitespace( *i ) ) ] = value;\n              }\n            }\n\n            idxHeader.hasAbrv = 1;\n            idxHeader.abrvAddress = chunks.startNewBlock();\n\n            uint32_t sz = abrv.size();\n\n            chunks.addToBlock( &sz, sizeof( uint32_t ) );\n\n            for( map< string, string >::const_iterator i = abrv.begin();\n                 i != abrv.end(); ++i )\n            {\n//              DPRINTF( \"%s:%s\\n\", i->first.c_str(), i->second.c_str() );\n\n              sz = i->first.size();\n              chunks.addToBlock( &sz, sizeof( uint32_t ) );\n              chunks.addToBlock( i->first.data(), sz );\n              sz = i->second.size();\n              chunks.addToBlock( &sz, sizeof( uint32_t ) );\n              chunks.addToBlock( i->second.data(), sz );\n            }\n          }\n          catch( std::exception & e )\n          {\n            gdWarning( \"Error reading abrv file \\\"%s\\\", error: %s. Skipping it.\\n\",\n                       abrvFileName.c_str(), e.what() );\n          }\n        }\n\n        bool hasString = false;\n        wstring curString;\n        size_t curOffset;\n\n        uint32_t articleCount = 0, wordCount = 0;\n\n        for( ; ; )\n        {\n          // Find the main headword\n\n          if ( !hasString && !scanner.readNextLineWithoutComments( curString, curOffset ) )\n            break; // Clean end of file\n\n          hasString = false;\n\n          // The line read should either consist of pure whitespace, or be a\n          // headword\n\n          if ( curString.empty() )\n            continue;\n\n          if ( isDslWs( curString[ 0 ] ) )\n          {\n            // The first character is blank. Let's make sure that all other\n            // characters are blank, too.\n            for( size_t x = 1; x < curString.size(); ++x )\n            {\n              if ( !isDslWs( curString[ x ] ) )\n              {\n                gdWarning( \"Garbage string in %s at offset 0x%lX\\n\", i->c_str(), (unsigned long) curOffset );\n                break;\n              }\n            }\n            continue;\n          }\n\n          // Ok, got the headword\n\n          list< wstring > allEntryWords;\n\n          processUnsortedParts( curString, true );\n          expandOptionalParts( curString, &allEntryWords );\n\n          uint32_t articleOffset = curOffset;\n\n          //DPRINTF( \"Headword: %ls\\n\", curString.c_str() );\n\n          // More headwords may follow\n\n          for( ; ; )\n          {\n            if ( ! ( hasString = scanner.readNextLineWithoutComments( curString, curOffset ) ) )\n            {\n              gdWarning( \"Premature end of file %s\\n\", i->c_str() );\n              break;\n            }\n\n            // Lingvo skips empty strings between the headwords\n            if ( curString.empty() )\n              continue;\n\n            if ( isDslWs( curString[ 0 ] ) )\n              break; // No more headwords\n\n#ifdef QT_DEBUG\n            qDebug() << \"Alt headword\" << gd::toQString( curString );\n#endif\n\n            processUnsortedParts( curString, true );\n            expandTildes( curString, allEntryWords.front() );\n            expandOptionalParts( curString, &allEntryWords );\n          }\n\n          if ( !hasString )\n            break;\n\n          // Insert new entry\n\n          uint32_t descOffset = chunks.startNewBlock();\n\n          chunks.addToBlock( &articleOffset, sizeof( articleOffset ) );\n\n          for( list< wstring >::iterator j = allEntryWords.begin();\n               j != allEntryWords.end(); ++j )\n          {\n            unescapeDsl( *j );\n            normalizeHeadword( *j );\n            indexedWords.addWord( *j, descOffset, maxHeadwordSize );\n          }\n\n          ++articleCount;\n          wordCount += allEntryWords.size();\n\n          int insideInsided = 0;\n          wstring headword;\n          QVector< InsidedCard > insidedCards;\n          uint32_t offset = curOffset;\n          QVector< wstring > insidedHeadwords;\n          unsigned linesInsideCard = 0;\n          int dogLine = 0;\n          bool wasEmptyLine = false;\n          int headwordLine = scanner.getLinesRead() - 2;\n          bool noSignificantLines = Folding::applyWhitespaceOnly( curString ).empty();\n          bool haveLine = !noSignificantLines;\n\n          // Skip the article's body\n          for( ; ; )\n          {\n            hasString = haveLine ? true : scanner.readNextLineWithoutComments( curString, curOffset );\n            haveLine = false;\n\n            if ( !hasString || ( curString.size() && !isDslWs( curString[ 0 ] ) ) )\n            {\n              if( insideInsided )\n              {\n                gdWarning( \"Unclosed tag '@' at line %i\", dogLine );\n                insidedCards.append( InsidedCard( offset, curOffset - offset, insidedHeadwords ) );\n              }\n              if( noSignificantLines )\n                gdWarning( \"Orphan headword at line %i\", headwordLine );\n\n              break;\n            }\n\n            // Check for orphan strings\n\n            if( curString.empty() )\n            {\n              wasEmptyLine = true;\n              continue;\n            }\n            else\n            {\n              if( wasEmptyLine && !Folding::applyWhitespaceOnly( curString ).empty() )\n                gdWarning( \"Orphan string at line %i\", scanner.getLinesRead() - 1 );\n            }\n\n            if( noSignificantLines )\n              noSignificantLines = Folding::applyWhitespaceOnly( curString ).empty();\n\n            // Find embedded cards\n\n            wstring::size_type n = curString.find( L'@' );\n            if( n == wstring::npos || curString[ n - 1 ] == L'\\\\' )\n            {\n              if( insideInsided )\n                linesInsideCard++;\n\n              continue;\n            }\n            else\n            {\n              // Embedded card tag must be placed at first position in line after spaces\n              if( !isAtSignFirst( curString ) )\n              {\n                gdWarning( \"Unescaped '@' symbol at line %i\", scanner.getLinesRead() - 1 );\n\n                if( insideInsided )\n                  linesInsideCard++;\n\n                continue;\n              }\n            }\n\n            dogLine = scanner.getLinesRead() - 1;\n\n            // Handle embedded card\n\n            if( insideInsided )\n            {\n              if( linesInsideCard )\n              {\n                insidedCards.append( InsidedCard( offset, curOffset - offset, insidedHeadwords ) );\n\n                insidedHeadwords.clear();\n                linesInsideCard = 0;\n                offset = curOffset;\n              }\n            }\n            else\n            {\n              offset = curOffset;\n              linesInsideCard = 0;\n            }\n\n            headword = Folding::trimWhitespace( curString.substr( n + 1 ) );\n\n            if( !headword.empty() )\n            {\n              processUnsortedParts( headword, true );\n              expandTildes( headword, allEntryWords.front() );\n              insidedHeadwords.append( headword );\n              insideInsided = true;\n            }\n            else\n              insideInsided = false;\n          }\n\n          // Now that we're having read the first string after the article\n          // itself, we can use its offset to calculate the article's size.\n          // An end of file works here, too.\n\n          uint32_t articleSize = ( curOffset - articleOffset );\n\n          chunks.addToBlock( &articleSize, sizeof( articleSize ) );\n\n          for( QVector< InsidedCard >::iterator i = insidedCards.begin(); i != insidedCards.end(); ++i )\n          {\n            uint32_t descOffset = chunks.startNewBlock();\n            chunks.addToBlock( &(*i).offset, sizeof( (*i).offset ) );\n            chunks.addToBlock( &(*i).size, sizeof( (*i).size ) );\n\n            for( int x = 0; x < (*i).headwords.size(); x++ )\n            {\n              allEntryWords.clear();\n              expandOptionalParts( (*i).headwords[ x ], &allEntryWords );\n\n              for( list< wstring >::iterator j = allEntryWords.begin();\n                   j != allEntryWords.end(); ++j )\n              {\n                unescapeDsl( *j );\n                normalizeHeadword( *j );\n                indexedWords.addWord( *j, descOffset, maxHeadwordSize );\n              }\n\n              wordCount += allEntryWords.size();\n            }\n            ++articleCount;\n          }\n\n          if ( !hasString )\n            break;\n        }\n\n        // Finish with the chunks\n\n        idxHeader.chunksOffset = chunks.finish();\n\n        // Build index\n\n        IndexInfo idxInfo = BtreeIndexing::buildIndex( indexedWords, idx );\n\n        idxHeader.indexBtreeMaxElements = idxInfo.btreeMaxElements;\n        idxHeader.indexRootOffset = idxInfo.rootOffset;\n\n        indexedWords.clear(); // Release memory -- no need for this data\n\n        // If there was a zip file, index it too\n\n        if ( zipFileName.size() )\n        {\n          GD_DPRINTF( \"Indexing zip file\\n\" );\n\n          idxHeader.hasZipFile = 1;\n\n          IndexedWords zipFileNames;\n          IndexedZip zipFile;\n          if( zipFile.openZipFile( QDir::fromNativeSeparators(\n                                   FsEncoding::decode( zipFileName.c_str() ) ) ) )\n              zipFile.indexFile( zipFileNames );\n\n          if( !zipFileNames.empty() )\n          {\n            // Build the resulting zip file index\n\n            IndexInfo idxInfo = BtreeIndexing::buildIndex( zipFileNames, idx );\n\n            idxHeader.zipIndexBtreeMaxElements = idxInfo.btreeMaxElements;\n            idxHeader.zipIndexRootOffset = idxInfo.rootOffset;\n          }\n          else\n          {\n            // Bad zip file -- no index (though the mark that we have one\n            // remains)\n            idxHeader.zipIndexBtreeMaxElements = 0;\n            idxHeader.zipIndexRootOffset = 0;\n          }\n        }\n        else\n          idxHeader.hasZipFile = 0;\n\n        // That concludes it. Update the header.\n\n        idxHeader.signature = Signature;\n        idxHeader.formatVersion = CurrentFormatVersion;\n        idxHeader.zipSupportVersion = CurrentZipSupportVersion;\n\n        idxHeader.articleCount = articleCount;\n        idxHeader.wordCount = wordCount;\n\n        idxHeader.langFrom = dslLanguageToId( scanner.getLangFrom() );\n        idxHeader.langTo = dslLanguageToId( scanner.getLangTo() );\n\n        idx.rewind();\n\n        idx.write( &idxHeader, sizeof( idxHeader ) );\n\n      } // In-place try for saving line count\n      catch( ... )\n      {\n        atLine = scanner.getLinesRead();\n        throw;\n      }\n\n      } // if need to rebuild\n\n      dictionaries.push_back( new DslDictionary( dictId,\n                                                 indexFile,\n                                                 dictFiles,\n                                                 maxPictureWidth ) );\n    }\n    catch( std::exception & e )\n    {\n      gdWarning( \"DSL dictionary reading failed: %s:%u, error: %s\\n\",\n                 i->c_str(), atLine, e.what() );\n    }\n  }\n\n  return dictionaries;\n}\n\n\n}\n"
        },
        {
          "name": "dsl.hh",
          "type": "blob",
          "size": 0.708984375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __DSL_HH_INCLUDED__\n#define __DSL_HH_INCLUDED__\n\n#include \"dictionary.hh\"\n\n/// Support for the ABBYY Lingvo .DSL files.\nnamespace Dsl {\n\nusing std::vector;\nusing std::string;\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing &,\n                                      int maxPictureWidth, unsigned int maxHeadwordSize )\n    THROW_SPEC( std::exception );\n\n}\n\n#endif\n"
        },
        {
          "name": "dsl_details.cc",
          "type": "blob",
          "size": 36.828125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"dsl_details.hh\"\n\n#include \"folding.hh\"\n#include \"langcoder.hh\"\n#include \"gddebug.hh\"\n#include \"ufile.hh\"\n#include \"wstring_qt.hh\"\n#include \"utf8.hh\"\n\n#include <stdio.h>\n#include <wctype.h>\n\n#include <algorithm>\n\nnamespace Dsl {\nnamespace Details {\n\nusing gd::wstring;\nusing std::list;\n\n#ifndef __linux__\n\n// wcscasecmp() function is a GNU extension, we need to reimplement it\n// for non-GNU systems.\n\nint wcscasecmp( const wchar *s1, const wchar *s2 )\n{\n  for( ; ; ++s1, ++s2 )\n  {\n    if ( towlower( *s1 ) != towlower( *s2 ) )\n      return towlower( *s1 ) > towlower( *s2 ) ? 1 : -1;\n\n    if ( !*s1 )\n      break;\n  }\n\n  return 0;\n}\n\n#endif\n\nstatic DSLLangCode LangCodes[] =\n{\n  { 1, \"en\" },\n  { 1033, \"en\" },\n  { 2, \"ru\" },\n  { 1049, \"ru\" },\n  { 1068, \"az\" },\n  { 1025, \"ar\" },\n  { 1067, \"am\" },\n  { 15, \"af\" },\n  { 1078, \"af\" },\n  { 9, \"eu\" },\n  { 1069, \"eu\" },\n  { 1133, \"ba\" },\n  { 21, \"be\" },\n  { 1059, \"be\" },\n  { 22, \"bg\" },\n  { 1026, \"bg\" },\n  { 19, \"hu\" },\n  { 1038, \"hu\" },\n  { 10, \"nl\" },\n  { 1043, \"nl\" },\n  { 1032, \"el\" },\n  { 1079, \"ka\" },\n  { 13, \"da\" },\n  { 1030, \"da\" },\n  { 16, \"id\" },\n  { 1057, \"id\" },\n  { 1039, \"is\" },\n  { 6, \"es\" },\n  { 7, \"es\" },\n  { 3082, \"es\" },\n  { 1034, \"es\" },\n  { 5, \"it\" },\n  { 1040, \"it\" },\n  { 1087, \"kk\" },\n  { 1595, \"ky\" },\n  { 28, \"ch\" },\n  { 29, \"ch\" },\n  { 1028, \"ch\" },\n  { 2052, \"ch\" },\n  { 30, \"la\" },\n  { 1540, \"la\" },\n  { 1142, \"la\" },\n  { 1062, \"lv\" },\n  { 1063, \"lt\" },\n  { 1086, \"ms\" },\n  { 3, \"de\" },\n  { 26, \"de\" },\n  { 1031, \"de\" },\n  { 32775, \"de\" },\n  { 14, \"nb\" },\n  { 1044, \"nb\" },\n  { 25, \"nn\" },\n  { 2068, \"nn\" },\n  { 20, \"pl\" },\n  { 1045, \"pl\" },\n  { 8, \"pt\" },\n  { 2070, \"pt\" },\n  { 1048, \"ro\" },\n  { 23, \"sr\" },\n  { 3098, \"sr\" },\n  { 1051, \"sk\" },\n  { 1060, \"sl\" },\n  { 17, \"sw\" },\n  { 1089, \"sw\" },\n  { 1064, \"tg\" },\n  { 1092, \"tt\" },\n  { 27, \"tr\" },\n  { 1055, \"tr\" },\n  { 1090, \"tk\" },\n  { 1091, \"tz\" },\n  { 24, \"uk\" },\n  { 1058, \"uk\" },\n  { 11, \"fi\" },\n  { 1035, \"fi\" },\n  { 4, \"fr\" },\n  { 1036, \"fr\" },\n  { 18, \"cs\" },\n  { 1029, \"cs\" },\n  { 12, \"sv\" },\n  { 1053, \"sv\" },\n  { 1061, \"et\" },\n  { 0, \"\" },\n};\n\nstring findCodeForDslId( int id )\n{\n  for( DSLLangCode const * lc = LangCodes; lc->code_id; ++lc )\n  {\n    if ( id == lc->code_id )\n    {\n      // We've got a match\n      return string( lc->code );\n    }\n  }\n  return string();\n}\n\nbool isAtSignFirst( wstring const & str )\n{\n  // Test if '@' is first in string except spaces and dsl tags\n  QRegExp reg( \"[ \\\\t]*(?:\\\\[[^\\\\]]+\\\\][ \\\\t]*)*@\", Qt::CaseInsensitive, QRegExp::RegExp2 );\n  return reg.indexIn( gd::toQString( str ) ) == 0;\n}\n\n/////////////// ArticleDom\n\nwstring ArticleDom::Node::renderAsText( bool stripTrsTag ) const\n{\n  if ( !isTag )\n    return text;\n\n  wstring result;\n\n  for( list< Node >::const_iterator i = begin(); i != end(); ++i )\n    if( !stripTrsTag || i->tagName != GD_NATIVE_TO_WS( L\"!trs\" ) )\n      result += i->renderAsText( stripTrsTag );\n\n  return result;\n}\n\nnamespace {\n\n/// @return true if @p tagName equals \"mN\" where N is a digit\nbool is_mN( wstring const & tagName )\n{\n  return tagName.size() == 2 && tagName[ 0 ] == L'm' && iswdigit( tagName[ 1 ] );\n}\n\nbool isAnyM( wstring const & tagName )\n{\n  return tagName == GD_NATIVE_TO_WS( L\"m\" ) || is_mN( tagName );\n}\n\nbool checkM( wstring const & dest, wstring const & src )\n{\n  return src == GD_NATIVE_TO_WS( L\"m\" ) && is_mN( dest );\n}\n\n/// Closing the [mN] tags is optional. Quote from https://documentation.help/ABBYY-Lingvo8/paragraph_form.htm:\n/// Any paragraph from this tag until the end of card or until system meets an «[/m]» (margin shift toggle off) tag\nstruct MustTagBeClosed\n{\n  bool operator()( ArticleDom::Node const * tag ) const\n  {\n    Q_ASSERT( tag->isTag );\n    return !isAnyM( tag->tagName );\n  }\n};\n\n} // unnamed namespace\n\nArticleDom::ArticleDom( wstring const & str, string const & dictName,\n                        wstring const & headword_):\n  root( Node::Tag(), wstring(), wstring() ), stringPos( str.c_str() ),\n  lineStartPos( str.c_str() ),\n  transcriptionCount( 0 ),\n  mediaCount( 0 ),\n  dictionaryName( dictName ),\n  headword( headword_ )\n{\n  list< Node * > stack; // Currently opened tags\n\n  Node * textNode = 0; // A leaf node which currently accumulates text.\n\n  try\n  {\n    for( ;; )\n    {\n      nextChar();\n\n      if ( ch == L'@' && !escaped )\n      {\n        if( !atSignFirstInLine() )\n        {\n          // Not insided card\n          if( dictName.empty() )\n            gdWarning( \"Unescaped '@' symbol found\" );\n          else\n            gdWarning( \"Unescaped '@' symbol found in \\\"%s\\\"\", dictName.c_str() );\n        }\n        else\n        {\n          // Insided card\n          wstring linkTo;\n          nextChar();\n          for( ; ; nextChar() )\n          {\n            if( ch == L'\\n' )\n              break;\n            if( ch != L'\\r' )\n            {\n              if( escaped && ( ch == L'(' || ch == ')' ) )\n                linkTo.push_back( L'\\\\' );\n              linkTo.push_back( ch );\n            }\n          }\n          linkTo = Folding::trimWhitespace( linkTo );\n\n          if( !linkTo.empty() )\n          {\n            list< wstring > allLinkEntries;\n            processUnsortedParts( linkTo, true );\n            expandOptionalParts( linkTo, &allLinkEntries );\n\n            for( list< wstring >::iterator entry = allLinkEntries.begin();\n                 entry != allLinkEntries.end(); )\n            {\n              if ( !textNode )\n              {\n                Node text = Node( Node::Text(), wstring() );\n\n                if ( stack.empty() )\n                {\n                  root.push_back( text );\n                  stack.push_back( &root.back() );\n                }\n                else\n                {\n                  stack.back()->push_back( text );\n                  stack.push_back( &stack.back()->back() );\n                }\n\n                textNode = stack.back();\n              }\n              textNode->text.push_back( L'-' );\n              textNode->text.push_back( L' ' );\n\n              // Close the currently opened text node\n              stack.pop_back();\n              textNode = 0;\n\n              wstring linkText = Folding::trimWhitespace( *entry );\n              ArticleDom nodeDom( linkText, dictName, headword_ );\n\n              Node link( Node::Tag(), GD_NATIVE_TO_WS( L\"@\" ), wstring() );\n              for( Node::iterator n = nodeDom.root.begin(); n != nodeDom.root.end(); ++n )\n                link.push_back( *n );\n\n              ++entry;\n\n              if ( stack.empty() )\n              {\n                root.push_back( link );\n                if( entry != allLinkEntries.end() ) // Add line break before next entry\n                  root.push_back( Node( Node::Tag(), GD_NATIVE_TO_WS( L\"br\" ), wstring() ) );\n              }\n              else\n              {\n                stack.back()->push_back( link );\n                if( entry != allLinkEntries.end() )\n                  stack.back()->push_back( Node( Node::Tag(), GD_NATIVE_TO_WS( L\"br\" ), wstring() ) );\n              }\n            }\n\n            // Skip to next '@'\n\n            while( !( ch == L'@' && !escaped && atSignFirstInLine() ) )\n              nextChar();\n\n            stringPos--;\n            ch = L'\\n';\n            escaped = false;\n          }\n        }\n      } // if ( ch == L'@' )\n\n      if ( ch == L'[' && !escaped )\n      {\n        // Beginning of a tag.\n        bool isClosing;\n        wstring name;\n        wstring attrs;\n\n        try\n        {\n          do\n          {\n            nextChar();\n          } while( Folding::isWhitespace( ch ) );\n\n          if ( ch == L'/' && !escaped )\n          {\n            // A closing tag.\n            isClosing = true;\n            nextChar();\n          }\n          else\n            isClosing = false;\n\n          // Read tag's name\n\n          while( ( ch != L']' || escaped ) && !Folding::isWhitespace( ch ) )\n          {\n            name.push_back( ch );\n            nextChar();\n          }\n\n          while( Folding::isWhitespace( ch ) )\n            nextChar();\n\n          // Read attrs\n\n          while( ch != L']' || escaped )\n          {\n            attrs.push_back( ch );\n            nextChar();\n          }\n        }\n        catch( eot )\n        {\n          if( !dictionaryName.empty() )\n            gdWarning( \"DSL: Unfinished tag \\\"%s\\\" with attributes \\\"%s\\\" found in \\\"%s\\\", article \\\"%s\\\".\",\n                       gd::toQString( name ).toUtf8().data(), gd::toQString( attrs ).toUtf8().data(),\n                       dictionaryName.c_str(), gd::toQString( headword ).toUtf8().data() );\n          else\n            gdWarning( \"DSL: Unfinished tag \\\"%s\\\" with attributes \\\"%s\\\" found\",\n                       gd::toQString( name ).toUtf8().data(), gd::toQString( attrs ).toUtf8().data() );\n\n          throw eot();\n        }\n\n        // Add the tag, or close it\n\n        if ( textNode )\n        {\n          // Close the currently opened text node\n          stack.pop_back();\n          textNode = 0;\n        }\n\n        // If the tag is [t], we update the transcriptionCount\n        if ( name == GD_NATIVE_TO_WS( L\"t\" ) )\n        {\n          if ( isClosing )\n          {\n            if ( transcriptionCount )\n              --transcriptionCount;\n          }\n          else\n            ++transcriptionCount;\n        }\n        \n        // If the tag is [s], we update the mediaCount\n        if ( name == GD_NATIVE_TO_WS( L\"s\" ) )\n        {\n          if ( isClosing )\n          {\n            if ( mediaCount )\n              --mediaCount;\n          }\n          else\n            ++mediaCount;\n        }\n\n        if ( !isClosing )\n        {\n          if( isAnyM( name ) )\n          {\n            // Opening an 'mX' or 'm' tag closes any previous 'm' tag\n            closeTag( GD_NATIVE_TO_WS( L\"m\" ), stack, false );\n          }\n          openTag( name, attrs, stack );\n          if ( name == GD_NATIVE_TO_WS( L\"br\" ) )\n          {\n            // [br] tag don't have closing tag\n            closeTag( name, stack );\n          }\n        }\n        else\n        {\n          closeTag( name, stack );\n        } // if ( isClosing )\n        continue;\n      } // if ( ch == '[' )\n\n      if ( ch == L'<' && !escaped )\n      {\n        // Special case: the <<name>> link\n\n        nextChar();\n\n        if ( ch != L'<' || escaped )\n        {\n          // Ok, it's not it.\n          --stringPos;\n\n          if ( escaped )\n          {\n            --stringPos;\n            escaped = false;\n          }\n          ch = L'<';\n        }\n        else\n        {\n          // Get the link's body\n          do\n          {\n            nextChar();\n          } while( Folding::isWhitespace( ch ) );\n\n          wstring linkTo, linkText;\n\n          for( ; ; nextChar() )\n          {\n            // Is it the end?\n            if ( ch == L'>' && !escaped )\n            {\n              nextChar();\n\n              if ( ch == L'>' && !escaped )\n                break;\n              else\n              {\n                linkTo.push_back( L'>' );\n                linkTo.push_back( ch );\n\n                linkText.push_back( L'>' );\n                if( escaped )\n                  linkText.push_back( L'\\\\' );\n                linkText.push_back( ch );\n              }\n            }\n            else\n            {\n              linkTo.push_back( ch );\n\n              if( escaped )\n                linkText.push_back( L'\\\\' );\n              linkText.push_back( ch );\n            }\n          }\n\n          // Add the corresponding node\n\n          if ( textNode )\n          {\n            // Close the currently opened text node\n            stack.pop_back();\n            textNode = 0;\n          }\n\n          linkText = Folding::trimWhitespace( linkText );\n          processUnsortedParts( linkText, true );\n          ArticleDom nodeDom( linkText, dictName, headword_ );\n\n          Node link( Node::Tag(), GD_NATIVE_TO_WS( L\"ref\" ), wstring() );\n          for( Node::iterator n = nodeDom.root.begin(); n != nodeDom.root.end(); ++n )\n            link.push_back( *n );\n\n          if ( stack.empty() )\n            root.push_back( link );\n          else\n            stack.back()->push_back( link );\n\n          continue;\n        }\n      } // if ( ch == '<' )\n\n      if ( ch == L'{' && !escaped )\n      {\n        // Special case: {{comment}}\n\n        nextChar();\n\n        if ( ch != L'{' || escaped )\n        {\n          // Ok, it's not it.\n          --stringPos;\n\n          if ( escaped )\n          {\n            --stringPos;\n            escaped = false;\n          }\n          ch = L'{';\n        }\n        else\n        {\n          // Skip the comment's body\n          for( ; ; )\n          {\n            nextChar();\n\n            // Is it the end?\n            if ( ch == L'}' && !escaped )\n            {\n              nextChar();\n\n              if ( ch == L'}' && !escaped )\n                break;\n            }\n          }\n\n          continue;\n        }\n      } // if ( ch == '{' )\n\n      // If we're here, we've got a normal symbol, to be saved as text.\n\n      // If there's currently no text node, open one\n      if ( !textNode )\n      {\n        Node text = Node( Node::Text(), wstring() );\n\n        if ( stack.empty() )\n        {\n          root.push_back( text );\n          stack.push_back( &root.back() );\n        }\n        else\n        {\n          stack.back()->push_back( text );\n          stack.push_back( &stack.back()->back() );\n        }\n\n        textNode = stack.back();\n      }\n\n      // If we're inside the transcription, do old-encoding conversion\n      if ( transcriptionCount )\n      {\n        switch ( ch )\n        {\n          case 0x2021: ch = 0xE6; break;\n          case 0x407: ch = 0x72; break;\n          case 0xB0: ch = 0x6B; break;\n          case 0x20AC: ch = 0x254; break;\n          case 0x404: ch = 0x7A; break;\n          case 0x40F: ch = 0x283; break;\n          case 0xAB: ch = 0x74; break;\n          case 0xAC: ch = 0x64; break;\n          case 0x2020: ch = 0x259; break;\n          case 0x490: ch = 0x6D; break;\n          case 0xA7: ch = 0x66; break;\n          case 0xAE: ch = 0x6C; break;\n          case 0xB1: ch = 0x67; break;\n          case 0x45E: ch = 0x65; break;\n          case 0xAD: ch = 0x6E; break;\n          case 0xA9: ch = 0x73; break;\n          case 0xA6: ch = 0x77; break;\n          case 0x2026: ch = 0x28C; break;\n          case 0x452: ch = 0x76; break;\n          case 0x408: ch = 0x70; break;\n          case 0x40C: ch = 0x75; break;\n          case 0x406: ch = 0x68; break;\n          case 0xB5: ch = 0x61; break;\n          case 0x491: ch = 0x25B; break;\n          case 0x40A: ch = 0x14B; break;\n          case 0x2030: ch = 0xF0; break;\n          case 0x456: ch = 0x6A; break;\n          case 0xA4: ch = 0x62; break;\n          case 0x409: ch = 0x292; break;\n          case 0x40E: ch = 0x69; break;\n          //case 0x44D: ch = 0x131; break;\n          case 0x40B: ch = 0x4E8; break;\n          case 0xB6: ch = 0x28A; break;\n          case 0x2018: ch = 0x251; break;\n          case 0x457: ch = 0x265; break;\n          case 0x458: ch = 0x153; break;\n          case 0x405: textNode->text.push_back( 0x153 ); ch = 0x303; break;\n          case 0x441: ch = 0x272; break;\n          case 0x442: textNode->text.push_back( 0x254 ); ch = 0x303; break;\n          case 0x443: ch = 0xF8; break;\n          case 0x445: textNode->text.push_back(0x25B ); ch = 0x303; break;\n          case 0x446: ch = 0xE7; break;\n          case 0x44C: textNode->text.push_back( 0x251 ); ch = 0x303; break;\n          case 0x44D: ch = 0x26A; break;\n          case 0x44F: ch = 0x252; break;\n          case 0x30: ch = 0x3B2; break;\n          case 0x31: textNode->text.push_back( 0x65 ); ch = 0x303; break;\n          case 0x32: ch = 0x25C; break;\n          case 0x33: ch = 0x129; break;\n          case 0x34: ch = 0xF5; break;\n          case 0x36: ch = 0x28E; break;\n          case 0x37: ch = 0x263; break;\n          case 0x38: ch = 0x1DD; break;\n          case 0x3A: ch = 0x2D0; break;\n          case 0x27: ch = 0x2C8; break;\n          case 0x455: ch = 0x1D0; break;\n          case 0xB7: ch = 0xE3; break;\n\n          case 0x00a0: ch = 0x02A7; break;\n          //case 0x00b1: ch = 0x0261; break;\n          case 0x0402: textNode->text.push_back( 0x0069 ); ch = L':'; break;\n          case 0x0403: textNode->text.push_back( 0x0251 ); ch = L':'; break;\n          //case 0x040b: ch = 0x03b8; break;\n          //case 0x040e: ch = 0x026a; break;\n          case 0x0428: ch = 0x0061; break;\n          case 0x0453: textNode->text.push_back( 0x0075 ); ch = L':'; break;\n          case 0x201a: ch = 0x0254; break;\n          case 0x201e: ch = 0x0259; break;\n          case 0x2039: textNode->text.push_back( 0x0064 ); ch = 0x0292; break;\n        }\n      }\n\n      if ( escaped && ch == L' ' && mediaCount == 0 )\n        ch = 0xA0; // Escaped spaces turn into non-breakable ones in Lingvo\n            \n      textNode->text.push_back( ch );\n    } // for( ; ; )\n  }\n  catch( eot )\n  {\n  }\n\n  if ( textNode )\n    stack.pop_back();\n\n  if ( stack.size() )\n  {\n    list< Node * >::iterator it = std::find_if( stack.begin(), stack.end(), MustTagBeClosed() );\n    if( it == stack.end() )\n      return; // no unclosed tags that must be closed => nothing to warn about\n    QByteArray const firstTagName = gd::toQString( ( *it )->tagName ).toUtf8();\n    ++it;\n    unsigned const unclosedTagCount = 1 + std::count_if( it, stack.end(), MustTagBeClosed() );\n\n    if( dictName.empty() )\n    {\n      gdWarning( \"Warning: %u tag(s) were unclosed, first tag name \\\"%s\\\".\\n\",\n                 unclosedTagCount, firstTagName.constData() );\n    }\n    else\n    {\n      gdWarning( \"Warning: %u tag(s) were unclosed in \\\"%s\\\", article \\\"%s\\\", first tag name \\\"%s\\\".\\n\",\n                 unclosedTagCount, dictName.c_str(), gd::toQString( headword ).toUtf8().constData(),\n                 firstTagName.constData() );\n    }\n  }\n}\n\nvoid ArticleDom::openTag( wstring const & name,\n                          wstring const & attrs,\n                          list<Node *> &stack )\n{\n  list< Node > nodesToReopen;\n\n  if( isAnyM( name ) )\n  {\n    // All tags above [m] tag will be closed and reopened after\n    // to avoid break this tag by closing some other tag.\n\n    while( stack.size() )\n    {\n      nodesToReopen.push_back( Node( Node::Tag(), stack.back()->tagName,\n                                     stack.back()->tagAttrs ) );\n\n      if ( stack.back()->empty() )\n      {\n        // Empty nodes are deleted since they're no use\n\n        stack.pop_back();\n\n        Node * parent = stack.size() ? stack.back() : &root;\n\n        parent->pop_back();\n      }\n      else\n        stack.pop_back();\n    }\n  }\n\n  // Add tag\n\n  Node node( Node::Tag(), name, attrs );\n\n  if ( stack.empty() )\n  {\n    root.push_back( node );\n    stack.push_back( &root.back() );\n  }\n  else\n  {\n    stack.back()->push_back( node );\n    stack.push_back( &stack.back()->back() );\n  }\n\n  // Reopen tags if needed\n\n  while( nodesToReopen.size() )\n  {\n    if ( stack.empty() )\n    {\n      root.push_back( nodesToReopen.back() );\n      stack.push_back( &root.back() );\n    }\n    else\n    {\n      stack.back()->push_back( nodesToReopen.back() );\n      stack.push_back( &stack.back()->back() );\n    }\n\n    nodesToReopen.pop_back();\n  }\n\n}\n\nvoid ArticleDom::closeTag( wstring const & name,\n                           list< Node * > & stack,\n                           bool warn )\n{\n  // Find the tag which is to be closed\n\n  list< Node * >::reverse_iterator n;\n\n  for( n = stack.rbegin(); n != stack.rend(); ++n )\n  {\n    if ( (*n)->tagName == name || checkM( (*n)->tagName, name ) )\n    {\n      // Found it\n      break;\n    }\n  }\n\n  if ( n != stack.rend() )\n  {\n    // If there is a corresponding tag, close all tags above it,\n    // then close the tag itself, then reopen all the tags which got\n    // closed.\n\n    list< Node > nodesToReopen;\n\n    while( stack.size() )\n    {\n      bool found = stack.back()->tagName == name ||\n                   checkM( stack.back()->tagName, name );\n\n      if ( !found )\n        nodesToReopen.push_back( Node( Node::Tag(), stack.back()->tagName,\n                                       stack.back()->tagAttrs ) );\n\n      if ( stack.back()->empty() && stack.back()->tagName != GD_NATIVE_TO_WS( L\"br\" ) )\n      {\n        // Empty nodes except [br] tag are deleted since they're no use\n\n        stack.pop_back();\n\n        Node * parent = stack.size() ? stack.back() : &root;\n\n        parent->pop_back();\n      }\n      else\n        stack.pop_back();\n\n      if ( found )\n        break;\n    }\n\n    while( nodesToReopen.size() )\n    {\n      if ( stack.empty() )\n      {\n        root.push_back( nodesToReopen.back() );\n        stack.push_back( &root.back() );\n      }\n      else\n      {\n        stack.back()->push_back( nodesToReopen.back() );\n        stack.push_back( &stack.back()->back() );\n      }\n\n      nodesToReopen.pop_back();\n    }\n  }\n  else\n  if ( warn )\n  {\n    if( !dictionaryName.empty() )\n      gdWarning( \"No corresponding opening tag for closing tag \\\"%s\\\" found in \\\"%s\\\", article \\\"%s\\\".\",\n                 gd::toQString( name ).toUtf8().data(), dictionaryName.c_str(),\n                 gd::toQString( headword ).toUtf8().data() );\n    else\n      gdWarning( \"No corresponding opening tag for closing tag \\\"%s\\\" found.\",\n                 gd::toQString( name ).toUtf8().data() );\n  }\n}\n\nvoid ArticleDom::nextChar() THROW_SPEC( eot )\n{\n  if ( !*stringPos )\n    throw eot();\n\n  ch = *stringPos++;\n\n  if ( ch == L'\\\\' )\n  {\n    if ( !*stringPos )\n      throw eot();\n\n    ch = *stringPos++;\n\n    escaped = true;\n  }\n  else\n  if ( ch == L'[' && *stringPos == L'[' )\n  {\n    ++stringPos;\n    escaped = true;\n  }\n  else\n  if ( ch == L']' && *stringPos == L']' )\n  {\n    ++stringPos;\n    escaped = true;\n  }\n  else\n    escaped = false;\n\n  if( ch == '\\n' || ch == '\\r' )\n    lineStartPos = stringPos;\n}\n\nbool ArticleDom::atSignFirstInLine()\n{\n  // Check if '@' sign is first after '\\n', leading spaces and dsl tags\n  if( stringPos <= lineStartPos )\n    return true;\n\n  return isAtSignFirst( wstring( lineStartPos ) );\n}\n\n/////////////// DslScanner\n\nDslScanner::DslScanner( string const & fileName ) THROW_SPEC( Ex, Iconv::Ex ):\n  encoding( Windows1252 ), iconv( encoding ), readBufferPtr( readBuffer ),\n  readBufferLeft( 0 ), wcharBuffer( 64 ), linesRead( 0 )\n{\n  // Since .dz is backwards-compatible with .gz, we use gz- functions to\n  // read it -- they are much nicer than the dict_data- ones.\n\n  f = gd_gzopen( fileName.c_str() );\n  if ( !f )\n    throw exCantOpen( fileName );\n\n  // Now try guessing the encoding by reading the first two bytes\n\n  unsigned char firstBytes[ 2 ];\n\n  if ( gzread( f, firstBytes, sizeof( firstBytes ) ) != sizeof( firstBytes ) )\n  {\n    // Apparently the file's too short\n    gzclose( f );\n    throw exMalformedDslFile( fileName );\n  }\n\n  bool needExactEncoding = false;\n\n\n  // If the file begins with the dedicated Unicode marker, we just consume\n  // it. If, on the other hand, it's not, we return the bytes back\n  if ( firstBytes[ 0 ] == 0xFF && firstBytes[ 1 ] == 0xFE )\n    encoding = Utf16LE;\n  else\n  if ( firstBytes[ 0 ] == 0xFE && firstBytes[ 1 ] == 0xFF )\n    encoding = Utf16BE;\n  else\n  if ( firstBytes[ 0 ] == 0xEF && firstBytes[ 1 ] == 0xBB )\n  {\n    // Looks like Utf8, read one more byte\n    if ( gzread( f, firstBytes, 1 ) != 1 || firstBytes[ 0 ] != 0xBF )\n    {\n      // Either the file's too short, or the BOM is weird\n      gzclose( f );\n      throw exMalformedDslFile( fileName );\n    }\n    \n    encoding = Utf8;\n  }\n  else\n  {\n    if ( firstBytes[ 0 ] && !firstBytes[ 1 ] )\n      encoding = Utf16LE;\n    else\n    if ( !firstBytes[ 0 ] && firstBytes[ 1 ] )\n      encoding = Utf16BE;\n    else\n    {\n      // Ok, this doesn't look like 16-bit Unicode. We will start with a\n      // 8-bit encoding with an intent to find out the exact one from\n      // the header.\n      needExactEncoding = true;\n      encoding = Windows1251;\n    }\n\n    if ( gzrewind( f ) )\n    {\n      gzclose( f );\n      throw exCantOpen( fileName );\n    }\n  }\n\n  iconv.reinit( encoding );\n\n  // We now can use our own readNextLine() function\n\n  wstring str;\n  size_t offset;\n\n  for( ; ; )\n  {\n    if ( !readNextLineWithoutComments( str, offset ) )\n    {\n      gzclose( f );\n      throw exMalformedDslFile( fileName );\n    }\n\n    if ( str.empty() || str[ 0 ] != L'#' )\n      break;\n\n    bool isName = false;\n    bool isLangFrom = false;\n    bool isLangTo = false;\n    bool isSoundDict = false;\n\n    if ( !str.compare( 0, 5, GD_NATIVE_TO_WS( L\"#NAME\" ), 5 ) )\n      isName = true;\n    else\n    if ( !str.compare( 0, 15, GD_NATIVE_TO_WS( L\"#INDEX_LANGUAGE\" ), 15 ) )\n      isLangFrom = true;\n    else\n    if ( !str.compare( 0, 18, GD_NATIVE_TO_WS( L\"#CONTENTS_LANGUAGE\" ), 18 ) )\n      isLangTo = true;\n    else\n    if ( !str.compare( 0, 17, GD_NATIVE_TO_WS( L\"#SOUND_DICTIONARY\" ), 17 ) )\n      isSoundDict = true;\n    else\n    if ( str.compare( 0, 17, GD_NATIVE_TO_WS( L\"#SOURCE_CODE_PAGE\" ), 17 ) )\n      continue;\n\n    // Locate the argument\n\n    size_t beg = str.find_first_of( L'\"' );\n\n    if ( beg == wstring::npos )\n      throw exMalformedDslFile( fileName );\n\n    size_t end = str.find_last_of( L'\"' );\n\n    if ( end == beg )\n      throw exMalformedDslFile( fileName );\n\n    wstring arg( str, beg + 1, end - beg - 1 );\n\n    if ( isName )\n      dictionaryName = arg;\n    else if ( isLangFrom )\n      langFrom = arg;\n    else if ( isLangTo )\n      langTo = arg;\n    else if ( isSoundDict )\n      soundDictionary = arg;\n    else\n    {\n      // The encoding\n      if ( !needExactEncoding )\n      {\n        // We don't need that!\n        GD_FDPRINTF( stderr, \"Warning: encoding was specified in a Unicode file, ignoring.\\n\" );\n      }\n      else\n      if ( !wcscasecmp( arg.c_str(), GD_NATIVE_TO_WS( L\"Latin\" ) ) )\n        encoding = Windows1252;\n      else\n      if ( !wcscasecmp( arg.c_str(), GD_NATIVE_TO_WS( L\"Cyrillic\" ) ) )\n        encoding = Windows1251;\n      else\n      if ( !wcscasecmp( arg.c_str(), GD_NATIVE_TO_WS( L\"EasternEuropean\" ) ) )\n        encoding = Windows1250;\n      else\n      {\n        gzclose( f );\n        throw exUnknownCodePage();\n      }\n    }\n  }\n\n  // The loop will always end up reading a line which was not a #-directive.\n  // We need to rewind to that line so readNextLine() would return it again\n  // next time it's called. To do that, we just use the slow gzseek() and\n  // empty the read buffer.\n  if( gzdirect( f ) )                    // Without this ZLib 1.2.7 gzread() return 0\n    gzrewind( f );                       // after gzseek() call on uncompressed files\n  gzseek( f, offset, SEEK_SET );\n  readBufferPtr = readBuffer;\n  readBufferLeft = 0;\n\n  if ( needExactEncoding )\n    iconv.reinit( encoding );\n}\n\nDslScanner::~DslScanner() throw()\n{\n  gzclose( f );\n}\n\nbool DslScanner::readNextLine( wstring & out, size_t & offset ) THROW_SPEC( Ex,\n                                                                       Iconv::Ex )\n{\n  offset = (size_t)( gztell( f ) - readBufferLeft );\n\n  // For now we just read one char at a time\n  size_t readMultiple = distanceToBytes( 1 );\n\n  size_t leftInOut = wcharBuffer.size();\n\n  wchar * outPtr = &wcharBuffer.front();\n\n  for( ; ; )\n  {\n    // Check that we have bytes to read\n    if ( readBufferLeft < 4 ) // To convert one char, we need at most 4 bytes\n    {\n      if ( !gzeof( f ) )\n      {\n        // To avoid having to deal with ring logic, we move the remaining bytes\n        // to the beginning\n        memmove( readBuffer, readBufferPtr, readBufferLeft );\n\n        // Read some more bytes to readBuffer\n        int result = gzread( f, readBuffer + readBufferLeft,\n                             sizeof( readBuffer ) - readBufferLeft );\n\n        if ( result == -1 )\n          throw exCantReadDslFile();\n\n        readBufferPtr = readBuffer;\n        readBufferLeft += (size_t) result;\n      }\n    }\n\n    if ( readBufferLeft < readMultiple )\n    {\n      // No more data. Return what we've got so far, forget the last byte if\n      // it was a 16-bit Unicode and a file had an odd number of bytes.\n      readBufferLeft = 0;\n\n      if ( outPtr != &wcharBuffer.front() )\n      {\n        // If there was a stray \\r, remove it\n        if ( outPtr[ -1 ] == L'\\r' )\n          --outPtr;\n\n        out = wstring( &wcharBuffer.front(), outPtr - &wcharBuffer.front() );\n\n        ++linesRead;\n\n        return true;\n      }\n      else\n        return false;\n    }\n\n    // Check that we have chars to write\n    if ( leftInOut < 2 ) // With 16-bit wchars, 2 is needed for a surrogate pair\n    {\n      wcharBuffer.resize( wcharBuffer.size() + 64 );\n      outPtr = &wcharBuffer.front() + wcharBuffer.size() - 64 - leftInOut;\n      leftInOut += 64;\n    }\n\n    // Ok, now convert one char\n    size_t outBytesLeft = sizeof( wchar );\n\n    Iconv::Result r =\n      iconv.convert( (void const *&)readBufferPtr, readBufferLeft,\n                     (void *&)outPtr, outBytesLeft );\n\n    if ( r == Iconv::NeedMoreOut && outBytesLeft == sizeof( wchar ) )\n    {\n      // Seems to be a surrogate pair with a 16-bit target wchar\n\n      outBytesLeft *= 2;\n      r = iconv.convert( (void const *&)readBufferPtr, readBufferLeft,\n                     (void *&)outPtr, outBytesLeft );\n      --leftInOut; // Complements the next decremention\n    }\n\n    if ( outBytesLeft )\n      throw exEncodingError();\n\n    --leftInOut;\n\n    // Have we got \\n?\n    if ( outPtr[ -1 ] == L'\\n' )\n    {\n      --outPtr;\n\n      // Now kill a \\r if there is one, and return the result.\n      if ( outPtr != &wcharBuffer.front() && outPtr[ -1 ] == L'\\r' )\n          --outPtr;\n\n      out = wstring( &wcharBuffer.front(), outPtr - &wcharBuffer.front() );\n\n      ++linesRead;\n\n      return true;\n    }\n  }\n}\n\nbool DslScanner::readNextLineWithoutComments( wstring & out, size_t & offset )\n                 THROW_SPEC( Ex, Iconv::Ex )\n{\n  wstring str;\n  bool commentToNextLine = false;\n  size_t currentOffset;\n\n  out.erase();\n  offset = 0;\n\n  do\n  {\n    bool b = readNextLine( str, currentOffset );\n\n    if( offset == 0 )\n      offset = currentOffset;\n\n    if( !b )\n      return false;\n\n    stripComments( str, commentToNextLine);\n\n    out += str;\n  }\n  while( commentToNextLine );\n\n  return true;\n}\n\n/////////////// DslScanner\n\nDslIconv::DslIconv( DslEncoding e ) THROW_SPEC( Iconv::Ex ):\n  Iconv( Iconv::GdWchar, getEncodingNameFor( e ) )\n{\n}\n\nvoid DslIconv::reinit( DslEncoding e ) THROW_SPEC( Iconv::Ex )\n{\n  Iconv::reinit( Iconv::GdWchar, getEncodingNameFor( e ) );\n}\n\nchar const * DslIconv::getEncodingNameFor( DslEncoding e )\n{\n  switch( e )\n  {\n    case Utf16LE:\n      return \"UTF-16LE\";\n    case Utf16BE:\n      return \"UTF-16BE\";\n    case Windows1252:\n      return \"WINDOWS-1252\";\n    case Windows1251:\n      return \"WINDOWS-1251\";\n    case Details::Utf8:\n      return \"UTF-8\";\n    case Windows1250:\n    default:\n      return \"WINDOWS-1250\";\n  }\n}\n\n\nvoid processUnsortedParts( wstring & str, bool strip )\n{\n  int refCount = 0;\n\n  size_t startPos = 0;\n\n  for( size_t x = 0; x < str.size(); )\n  {\n    wchar ch = str[ x ];\n\n    if ( ch == L'\\\\' )\n    {\n      // Escape code\n      x += 2;\n      continue;\n    }\n\n    if ( ch == '{' )\n    {\n      ++refCount;\n\n      if ( !strip )\n      {\n        // Just remove it and continue\n        str.erase( x, 1 );\n        continue;\n      }\n      else\n      if ( refCount == 1 )\n      {\n        // First opening brace. Save this position, we will be erasing the\n        // whole range when we encounter the last closing brace.\n        startPos = x;\n      }\n    }\n    else\n    if ( ch == '}' )\n    {\n      --refCount;\n\n      if ( refCount < 0 )\n      {\n        GD_FDPRINTF( stderr, \"Warning: an unmatched closing brace was encountered.\\n\" );\n        refCount = 0;\n        // But we remove that thing either way\n        str.erase( x, 1 );\n        continue;\n      }\n\n      if ( !strip )\n      {\n        // Just remove it and continue\n        str.erase( x, 1 );\n        continue;\n      }\n      else\n      if ( !refCount )\n      {\n        // The final closing brace -- we can erase the whole range now.\n        str.erase( startPos, x - startPos + 1 );\n        x = startPos;\n\n        continue;\n      }\n    }\n\n    ++x;\n  }\n\n  if ( strip && refCount )\n  {\n    GD_FDPRINTF( stderr, \"Warning: unclosed brace(s) encountered.\\n\" );\n    str.erase( startPos );\n  }\n}\n\nvoid expandOptionalParts( wstring & str, list< wstring > * result,\n                          size_t x, bool inside_recurse )\n{\n  if( str.size() > 500 )\n  {\n    // Don't expand too long headwords - it is highly likely incorrect dictionary\n    result->push_back( str );\n    return;\n  }\n\n  list< wstring > expanded;\n  list< wstring > * headwords;\n  headwords = inside_recurse ? result : &expanded;\n\n  for( ; x < str.size(); )\n  {\n    wchar ch = str[ x ];\n\n    if ( ch == L'\\\\' )\n    {\n      // Escape code\n      x += 2;\n    }\n    else\n    if ( ch == L'(' )\n    {\n      // First, handle the case where this block is removed\n\n      {\n        int refCount = 1;\n\n        for( size_t y = x + 1; y < str.size(); ++y )\n        {\n          wchar ch = str[ y ];\n\n          if ( ch == L'\\\\' )\n          {\n            // Escape code\n            ++y;\n          }\n          else\n          if ( ch == L'(' )\n            ++refCount;\n          else\n          if ( ch == L')' )\n          {\n            if ( !--refCount )\n            {\n              // Now that the closing parenthesis is found,\n              // cut the whole thing out and be done.\n\n              if ( y != x + 1 ) // Only do for non-empty cases\n              {\n                wstring removed( str, 0, x );\n                removed.append( str, y + 1, str.size() - y - 1 );\n\n                expandOptionalParts( removed, headwords, x, true );\n              }\n\n              break;\n            }\n          }\n        }\n\n        if ( refCount && x != str.size() - 1 )\n        {\n          // Closing paren not found? Chop it.\n\n          wstring removed( str, 0, x );\n\n          // Limit the amount of results to avoid excessive resource consumption\n          if ( headwords->size() < 32 )\n            headwords->push_back( removed );\n          else\n          {\n            if( !inside_recurse )\n              result->merge( expanded );\n            return;\n          }\n        }\n      }\n\n      // Now, handling the case where it is kept -- we just erase\n      // the paren and go on\n\n      str.erase( x, 1 );\n    }\n    else\n    if ( ch == L')' )\n    {\n      // Closing paren doesn't mean much -- just erase it\n      str.erase( x, 1 );\n    }\n    else\n      ++x;\n  }\n\n  // Limit the amount of results to avoid excessive resource consumption\n  if ( headwords->size() < 32 )\n    headwords->push_back( str );\n  if( !inside_recurse )\n    result->merge( expanded );\n}\n\nstatic const wstring openBraces( GD_NATIVE_TO_WS( L\"{{\" ) );\nstatic const wstring closeBraces( GD_NATIVE_TO_WS( L\"}}\" ) );\n\nvoid stripComments( wstring & str, bool & nextLine )\n{\n  string::size_type n = 0, n2 = 0;\n\n  for( ; ; )\n  {\n    if( nextLine )\n    {\n      n = str.find( closeBraces, n2 );\n      if( n == string::npos )\n      {\n        str.erase( n2, n );\n        return;\n      }\n      str.erase( n2, n - n2 + 2 );\n      nextLine = false;\n    }\n\n    n = str.find( openBraces, n2 );\n    if( n == string::npos )\n      return;\n    nextLine = true;\n    n2 = n;\n  }\n}\n\nvoid expandTildes( wstring & str, wstring const & tildeReplacement )\n{\n  wstring tildeValue = Folding::trimWhitespace( tildeReplacement );\n  for( size_t x = 0; x < str.size(); )\n    if ( str[ x ] == L'\\\\' )\n      x+=2;\n    else\n    if ( str[ x ] == L'~' )\n    {\n      if( x > 0 && str[ x - 1 ] == '^' && ( x < 2 || str[ x - 2 ] != '\\\\' ) )\n      {\n        str.replace( x - 1, 2, tildeValue );\n        str[ x - 1 ] = QChar( str[ x - 1 ] ).isUpper() ? QChar::toLower( (uint)str[ x - 1 ] )\n                                                       : QChar::toUpper( (uint)str[ x - 1 ] );\n        x = x - 1 + tildeValue.size();\n      }\n      else\n      {\n        str.replace( x, 1, tildeValue );\n        x += tildeValue.size();\n      }\n    }\n    else\n      ++x;\n}\n\nvoid unescapeDsl( wstring & str )\n{\n  for( size_t x = 0; x < str.size(); ++x )\n    if ( str[ x ] == L'\\\\' )\n      str.erase( x, 1 ); // ++x would skip the next char without processing it\n}\n\nvoid normalizeHeadword( wstring & str )\n{\n  for( size_t x = str.size(); x-- > 1; ) // >1 -- Don't test the first char\n  {\n    if ( str[ x ] == L' ' )\n    {\n      size_t y;\n      for( y = x; y && ( str[ y - 1 ] == L' ' ) ; --y );\n\n      if ( y != x )\n      {\n        // Remove extra spaces\n\n        str.erase( y, x - y );\n\n        x = y;\n      }\n    }\n  }\n  if( !str.empty() && str[ str.size() - 1 ] == L' ' )\n    str.erase( str.size() - 1, 1 );\n  if( !str.empty() && str[ 0 ] == L' ' )\n    str.erase( 0, 1 );\n}\n\nnamespace\n{\n  void cutEnding( wstring & where, wstring const & ending )\n  {\n    if ( where.size() > ending.size() &&\n         where.compare( where.size() - ending.size(),\n                               ending.size(), ending ) == 0 )\n      where.erase( where.size() - ending.size() );\n  }\n}\n\nquint32 dslLanguageToId( wstring const & name )\n{\n  static wstring newSp( GD_NATIVE_TO_WS( L\"newspelling\" ) );\n  static wstring st( GD_NATIVE_TO_WS( L\"standard\" ) );\n  static wstring ms( GD_NATIVE_TO_WS( L\"modernsort\" ) );\n  static wstring ts( GD_NATIVE_TO_WS( L\"traditionalsort\" ) );\n  static wstring prc( GD_NATIVE_TO_WS( L\"prc\" ) );\n\n  // Any of those endings are to be removed\n\n  wstring nameStripped = Folding::apply( name );\n\n  cutEnding( nameStripped, newSp );\n  cutEnding( nameStripped, st );\n  cutEnding( nameStripped, ms );\n  cutEnding( nameStripped, ts );\n  cutEnding( nameStripped, prc );\n\n  return LangCoder::findIdForLanguage( nameStripped );\n}\n\n}\n}\n"
        },
        {
          "name": "dsl_details.hh",
          "type": "blob",
          "size": 6.6865234375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __DSL_DETAILS_HH_INCLUDED__\n#define __DSL_DETAILS_HH_INCLUDED__\n\n#include <string>\n#include <list>\n#include <vector>\n#include <zlib.h>\n#include \"dictionary.hh\"\n#include \"iconv.hh\"\n\n// Implementation details for Dsl, not part of its interface\nnamespace Dsl {\nnamespace Details {\n\nusing std::string;\nusing gd::wstring;\nusing gd::wchar;\nusing std::list;\nusing std::vector;\n\n// Those are possible encodings for .dsl files\nenum DslEncoding\n{\n  Utf16LE,\n  Utf16BE,\n  Windows1252,\n  Windows1251,\n  Windows1250,\n  Utf8 // This is an extension. Detected solely by the UTF8 BOM.\n};\n\nstruct DSLLangCode\n{\n  int code_id;\n  char code[ 3 ]; // ISO 639-1\n};\n\nstring findCodeForDslId( int id );\n\nbool isAtSignFirst( wstring const & str );\n\n/// Parses the DSL language, representing it in its structural DOM form.\nstruct ArticleDom\n{\n  struct Node: public list< Node >\n  {\n    bool isTag; // true if it is a tag with subnodes, false if it's a leaf text\n                // data.\n    // Those are only used if isTag is true\n    wstring tagName;\n    wstring tagAttrs;\n    wstring text; // This is only used if isTag is false\n\n    class Text {};\n    class Tag {};\n\n    Node( Tag, wstring const & name, wstring const & attrs ): isTag( true ),\n      tagName( name ), tagAttrs( attrs )\n    {}\n\n    Node( Text, wstring const & text_ ): isTag( false ), text( text_ )\n    {}\n\n    /// Concatenates all childen text nodes recursively to form all text\n    /// the node contains stripped of any markup.\n    wstring renderAsText( bool stripTrsTag = false ) const;\n  };\n\n  /// Does the parse at construction. Refer to the 'root' member variable\n  /// afterwards.\n  ArticleDom( wstring const &, string const & dictName = string(),\n              wstring const & headword_ = wstring() );\n\n  /// Root of DOM's tree\n  Node root;\n\nprivate:\n\n  void openTag( wstring const & name, wstring const & attr, list< Node * > & stack );\n\n  void closeTag( wstring const & name, list< Node * > & stack,\n                 bool warn = true );\n\n  bool atSignFirstInLine();\n\n  wchar const * stringPos, * lineStartPos;\n\n  class eot {};\n\n  wchar ch;\n  bool escaped;\n  unsigned transcriptionCount; // >0 = inside a [t] tag\n  unsigned mediaCount; // >0 = inside a [s] tag\n\n  void nextChar() THROW_SPEC( eot );\n\n  /// Information for diagnostic purposes\n  string dictionaryName;\n  wstring headword;\n};\n\n/// A adapted version of Iconv which takes Dsl encoding and decodes to wchar.\nclass DslIconv: public Iconv\n{\npublic:\n  DslIconv( DslEncoding ) THROW_SPEC( Iconv::Ex );\n  void reinit( DslEncoding ) THROW_SPEC( Iconv::Ex );\n\n  /// Returns a name to be passed to iconv for the given dsl encoding.\n  static char const * getEncodingNameFor( DslEncoding );\n};\n\n/// Opens the .dsl or .dsl.dz file and allows line-by-line reading. Auto-detects\n/// the encoding, and reads all headers by itself.\nclass DslScanner\n{\n  gzFile f;\n  DslEncoding encoding;\n  DslIconv iconv;\n  wstring dictionaryName;\n  wstring langFrom, langTo;\n  wstring soundDictionary;\n  char readBuffer[ 65536 ];\n  char * readBufferPtr;\n  size_t readBufferLeft;\n  vector< wchar > wcharBuffer;\n  unsigned linesRead;\n\npublic:\n\n  DEF_EX( Ex, \"Dsl scanner exception\", Dictionary::Ex )\n  DEF_EX_STR( exCantOpen, \"Can't open .dsl file\", Ex )\n  DEF_EX( exCantReadDslFile, \"Can't read .dsl file\", Ex )\n  DEF_EX_STR( exMalformedDslFile, \"The .dsl file is malformed:\", Ex )\n  DEF_EX( exUnknownCodePage, \"The .dsl file specified an unknown code page\", Ex )\n  DEF_EX( exEncodingError, \"Encoding error\", Ex ) // Should never happen really\n\n  DslScanner( string const & fileName ) THROW_SPEC( Ex, Iconv::Ex );\n  ~DslScanner() throw();\n\n  /// Returns the detected encoding of this file.\n  DslEncoding getEncoding() const\n  { return encoding; }\n\n  /// Returns the dictionary's name, as was read from file's headers.\n  wstring const & getDictionaryName() const\n  { return dictionaryName; }\n\n  /// Returns the dictionary's source language, as was read from file's headers.\n  wstring const & getLangFrom() const\n  { return langFrom; }\n\n  /// Returns the dictionary's target language, as was read from file's headers.\n  wstring const & getLangTo() const\n  { return langTo; }\n\n  /// Returns the preferred external dictionary with sounds, as was read from file's headers.\n  wstring const & getSoundDictionaryName() const\n  { return soundDictionary; }\n\n  /// Reads next line from the file. Returns true if reading succeeded --\n  /// the string gets stored in the one passed, along with its physical\n  /// file offset in the file (the uncompressed one if the file is compressed).\n  /// If end of file is reached, false is returned.\n  /// Reading begins from the first line after the headers (ones which start\n  /// with #).\n  bool readNextLine( wstring &, size_t & offset ) THROW_SPEC( Ex, Iconv::Ex );\n\n  /// Similar readNextLine but strip all DSL comments {{...}}\n  bool readNextLineWithoutComments( wstring &, size_t & offset ) THROW_SPEC( Ex, Iconv::Ex );\n\n  /// Returns the number of lines read so far from the file.\n  unsigned getLinesRead() const\n  { return linesRead; }\n\n  /// Converts the given number of characters to the number of bytes they\n  /// would occupy in the file, knowing its encoding. It's possible to know\n  /// that because no multibyte encodings are supported in .dsls.\n  inline size_t distanceToBytes( size_t ) const;\n};\n\n/// This function either removes parts of string enclosed in braces, or leaves\n/// them intact. The braces themselves are removed always, though.\nvoid processUnsortedParts( wstring & str, bool strip );\n\n/// Expands optional parts of a headword (ones marked with parentheses),\n/// producing all possible combinations where they are present or absent.\nvoid expandOptionalParts( wstring & str, list< wstring > * result,\n                          size_t x = 0, bool inside_recurse = false );\n\n/// Expands all unescaped tildes, inserting tildeReplacement text instead of\n/// them.\nvoid expandTildes( wstring & str, wstring const & tildeReplacement );\n\n/// Unescapes any escaped chars. Be sure to handle all their special meanings\n/// before unescaping them.\nvoid unescapeDsl( wstring & str );\n\n/// Normalizes the headword. Currently turns any sequences of consecutive spaces\n/// into a single space.\nvoid normalizeHeadword( wstring & );\n\n/// Strip DSL {{...}} comments\nvoid stripComments( wstring &, bool & );\n\ninline size_t DslScanner::distanceToBytes( size_t x ) const\n{\n  switch( encoding )\n  {\n    case Utf16LE:\n    case Utf16BE:\n      return x*2;\n    default:\n      return x;\n  }\n}\n\n/// Converts the given language name taken from Dsl header (i.e. getLangFrom(),\n/// getLangTo()) to its proper language id.\nquint32 dslLanguageToId( wstring const & name );\n\n}\n}\n\n#endif\n"
        },
        {
          "name": "editdictionaries.cc",
          "type": "blob",
          "size": 9.09375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"editdictionaries.hh\"\n#include \"loaddictionaries.hh\"\n#include \"dictinfo.hh\"\n#include \"mainwindow.hh\"\n#include <QMessageBox>\n\nusing std::vector;\n\nEditDictionaries::EditDictionaries( QWidget * parent, Config::Class & cfg_,\n                                    vector< sptr< Dictionary::Class > > & dictionaries_,\n                                    Instances::Groups & groupInstances_,\n                                    QNetworkAccessManager & dictNetMgr_ ):\n  QDialog( parent, Qt::WindowSystemMenuHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint ),\n  cfg( cfg_ ),\n  dictionaries( dictionaries_ ),\n  groupInstances( groupInstances_ ),\n  dictNetMgr( dictNetMgr_ ),\n  origCfg( cfg ),\n  sources( this, cfg ),\n  orderAndProps( new OrderAndProps( this, cfg.dictionaryOrder, cfg.inactiveDictionaries,\n                                    dictionaries ) ),\n  groups( new Groups( this, dictionaries, cfg.groups, orderAndProps->getCurrentDictionaryOrder() ) ),\n  dictionariesChanged( false ),\n  groupsChanged( false ),\n  lastCurrentTab( 0 )\n, helpWindow( 0 )\n, helpAction( this )\n{\n  // Some groups may have contained links to non-existnent dictionaries. We\n  // would like to preserve them if no edits were done. To that end, we save\n  // the initial group readings so that if no edits were really done, we won't\n  // be changing groups.\n  origCfg.groups = groups->getGroups();\n  origCfg.dictionaryOrder = orderAndProps->getCurrentDictionaryOrder();\n  origCfg.inactiveDictionaries = orderAndProps->getCurrentInactiveDictionaries();\n\n  ui.setupUi( this );\n\n  setWindowIcon( QIcon(\":/icons/book.png\") );\n\n  ui.tabs->clear();\n\n  ui.tabs->addTab( &sources, QIcon(\":/icons/reload.png\"), tr( \"&Sources\" ) );\n  ui.tabs->addTab( orderAndProps.get(), QIcon(\":/icons/book.png\"), tr( \"&Dictionaries\" ) );\n  ui.tabs->addTab( groups.get(), QIcon(\":/icons/bookcase.png\"), tr( \"&Groups\" ) );\n\n  connect( ui.buttons, SIGNAL( clicked( QAbstractButton * ) ),\n           this, SLOT( buttonBoxClicked( QAbstractButton * ) ) );\n\n  connect( &sources, SIGNAL( rescan() ), this, SLOT( rescanSources() ) );\n\n  connect( groups.get(), SIGNAL( showDictionaryInfo( QString const & ) ),\n           this, SIGNAL( showDictionaryInfo( QString const & ) ) );\n\n  connect( orderAndProps.get(), SIGNAL( showDictionaryHeadwords( QString const & ) ),\n           this, SIGNAL( showDictionaryHeadwords( QString const & ) ) );\n\n  connect( ui.buttons, SIGNAL( helpRequested() ),\n           this, SLOT( helpRequested() ) );\n\n  helpAction.setShortcut( QKeySequence( \"F1\" ) );\n  helpAction.setShortcutContext( Qt::WidgetWithChildrenShortcut );\n\n  connect( &helpAction, SIGNAL( triggered() ),\n           this, SLOT( helpRequested() ) );\n\n  addAction( &helpAction );\n\n}\n\nvoid EditDictionaries::editGroup( unsigned id )\n{\n  if ( id == Instances::Group::AllGroupId )\n    ui.tabs->setCurrentIndex( 1 );\n  else\n  {\n    ui.tabs->setCurrentIndex( 2 );\n    groups->editGroup( id );\n  }\n}\n\nvoid EditDictionaries::save()\n{\n  Config::Groups newGroups = groups->getGroups();\n  Config::Group newOrder = orderAndProps->getCurrentDictionaryOrder();\n  Config::Group newInactive = orderAndProps->getCurrentInactiveDictionaries();\n\n  if ( isSourcesChanged() )\n    acceptChangedSources( false );\n\n  if ( origCfg.groups != newGroups || origCfg.dictionaryOrder != newOrder ||\n       origCfg.inactiveDictionaries != newInactive )\n  {\n    groupsChanged = true;\n    cfg.groups = newGroups;\n    cfg.dictionaryOrder = newOrder;\n    cfg.inactiveDictionaries = newInactive;\n  }\n}\n\nvoid EditDictionaries::accept()\n{\n  save();\n  QDialog::accept();\n}\n\nvoid EditDictionaries::on_tabs_currentChanged( int index )\n{\n  if ( index == -1 || !isVisible() )\n    return; // Sent upon the construction/destruction\n\n  if ( !lastCurrentTab && index )\n  {\n    // We're switching away from the Sources tab -- if its contents were\n    // changed, we need to either apply or reject now.\n\n    if ( isSourcesChanged() )\n    {\n      ui.tabs->setCurrentIndex( 0 );\n\n      QMessageBox question( QMessageBox::Question, tr( \"Sources changed\" ),\n                            tr( \"Some sources were changed. Would you like to accept the changes?\" ),\n                            QMessageBox::NoButton, this );\n\n      QPushButton * accept = question.addButton( tr( \"Accept\" ), QMessageBox::AcceptRole );\n\n      question.addButton( tr( \"Cancel\" ), QMessageBox::RejectRole );\n\n      question.exec();\n\n      if ( question.clickedButton() == accept )\n      {\n        acceptChangedSources( true );\n        \n        lastCurrentTab = index;\n        ui.tabs->setCurrentIndex( index );\n      }\n      else\n      {\n        // Prevent tab from switching\n        lastCurrentTab = 0;\n        return;\n      }\n    }\n  }\n  else\n  if ( lastCurrentTab == 1 && index != 1 )\n  {\n    // When switching from the dictionary order, we need to propagate any\n    // changes to the groups.\n    groups->updateDictionaryOrder( orderAndProps->getCurrentDictionaryOrder() );\n  }\n\n  lastCurrentTab = index;\n}\n\nvoid EditDictionaries::rescanSources()\n{\n  acceptChangedSources( true );\n}\n\nvoid EditDictionaries::buttonBoxClicked( QAbstractButton * button )\n{\n  if (ui.buttons->buttonRole(button) == QDialogButtonBox::ApplyRole) {\n    if ( isSourcesChanged() ) {\n      acceptChangedSources( true );\n    }\n    save();\n  }\n}\n\nbool EditDictionaries::isSourcesChanged() const\n{\n  return sources.getPaths() != cfg.paths ||\n         sources.getSoundDirs() != cfg.soundDirs ||\n         sources.getHunspell() != cfg.hunspell ||\n         sources.getTransliteration() != cfg.transliteration ||\n         sources.getForvo() != cfg.forvo ||\n         sources.getMediaWikis() != cfg.mediawikis ||\n         sources.getWebSites() != cfg.webSites ||\n         sources.getDictServers() != cfg.dictServers ||\n         sources.getPrograms() != cfg.programs ||\n         sources.getVoiceEngines() != cfg.voiceEngines;\n}\n\nvoid EditDictionaries::acceptChangedSources( bool rebuildGroups )\n{\n  dictionariesChanged = true;\n\n  Config::Groups savedGroups = groups->getGroups();\n  Config::Group savedOrder = orderAndProps->getCurrentDictionaryOrder();\n  Config::Group savedInactive = orderAndProps->getCurrentInactiveDictionaries();\n\n  cfg.paths = sources.getPaths();\n  cfg.soundDirs = sources.getSoundDirs();\n  cfg.hunspell = sources.getHunspell();\n  cfg.transliteration = sources.getTransliteration();\n  cfg.forvo = sources.getForvo();\n  cfg.mediawikis = sources.getMediaWikis();\n  cfg.webSites = sources.getWebSites();\n  cfg.dictServers = sources.getDictServers();\n  cfg.programs = sources.getPrograms();\n  cfg.voiceEngines = sources.getVoiceEngines();\n\n  groupInstances.clear(); // Those hold pointers to dictionaries, we need to\n                          // free them.\n\n  ui.tabs->setUpdatesEnabled( false );\n  ui.tabs->removeTab( 1 );\n  ui.tabs->removeTab( 1 );\n  groups.reset();\n  orderAndProps.reset();\n\n  loadDictionaries( this, true, cfg, dictionaries, dictNetMgr );\n\n  // If no changes to groups were made, update the original data\n  bool noGroupEdits = ( origCfg.groups == savedGroups );\n\n  if ( noGroupEdits )\n    savedGroups = cfg.groups;\n\n  Instances::updateNames( savedGroups, dictionaries );\n\n  bool noOrderEdits = ( origCfg.dictionaryOrder == savedOrder );\n\n  if ( noOrderEdits )\n    savedOrder = cfg.dictionaryOrder;\n\n  Instances::updateNames( savedOrder, dictionaries );\n\n  bool noInactiveEdits = ( origCfg.inactiveDictionaries == savedInactive );\n\n  if ( noInactiveEdits )\n    savedInactive  = cfg.inactiveDictionaries;\n\n  Instances::updateNames( savedInactive, dictionaries );\n\n  if ( rebuildGroups )\n  {\n    orderAndProps = new OrderAndProps( this, savedOrder, savedInactive, dictionaries );\n    ui.tabs->insertTab( 1, orderAndProps.get(), QIcon(\":/icons/book.png\"), tr( \"&Dictionaries\" ) );\n\n    groups = new Groups( this, dictionaries, savedGroups, orderAndProps->getCurrentDictionaryOrder() );\n    ui.tabs->insertTab( 2, groups.get(), QIcon(\":/icons/bookcase.png\"), tr( \"&Groups\" ) );\n\n    ui.tabs->setUpdatesEnabled( true );\n\n    if ( noGroupEdits )\n      origCfg.groups = groups->getGroups();\n\n    if ( noOrderEdits )\n      origCfg.dictionaryOrder = orderAndProps->getCurrentDictionaryOrder();\n\n    if ( noInactiveEdits )\n      origCfg.inactiveDictionaries = orderAndProps->getCurrentInactiveDictionaries();\n  }\n}\n\nvoid EditDictionaries::helpRequested()\n{\n  if( !helpWindow )\n  {\n    MainWindow * mainWindow = qobject_cast< MainWindow * >( parentWidget() );\n    if( mainWindow )\n      mainWindow->closeGDHelp();\n\n    helpWindow = new Help::HelpWindow( this, cfg );\n\n    if( helpWindow )\n    {\n      #ifdef Q_OS_MAC\n        helpWindow->setWindowFlags( Qt::Dialog );\n      #else\n        helpWindow->setWindowFlags( Qt::Window );\n      #endif\n\n      connect( helpWindow, SIGNAL( needClose() ),\n               this, SLOT( closeHelp() ) );\n      helpWindow->showHelpFor( \"Manage dictionaries\" );\n      helpWindow->show();\n      #ifdef Q_OS_MAC\n        helpWindow->activateWindow();\n      #endif\n    }\n  }\n  else\n  {\n    if( !helpWindow->isVisible() )\n      helpWindow->show();\n\n    helpWindow->activateWindow();\n  }\n}\n\nvoid EditDictionaries::closeHelp()\n{\n  if( helpWindow )\n    helpWindow->hide();\n}\n"
        },
        {
          "name": "editdictionaries.hh",
          "type": "blob",
          "size": 2.185546875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __EDITDICTIONARIES_HH_INCLUDED__\n#define __EDITDICTIONARIES_HH_INCLUDED__\n\n#include \"dictionary.hh\"\n#include \"config.hh\"\n#include \"ui_editdictionaries.h\"\n#include \"sources.hh\"\n#include \"orderandprops.hh\"\n#include \"groups.hh\"\n#include \"instances.hh\"\n#include \"helpwindow.hh\"\n#include <QNetworkAccessManager>\n#include <QAction>\n\nclass EditDictionaries: public QDialog\n{\n  Q_OBJECT\n\npublic:\n\n  EditDictionaries( QWidget * parent, Config::Class & cfg,\n                    std::vector< sptr< Dictionary::Class > > & dictionaries,\n                    Instances::Groups & groupInstances, // We only clear those on rescan\n                    QNetworkAccessManager & dictNetMgr );\n\n  ~EditDictionaries()\n  { if( helpWindow ) delete helpWindow; }\n\n  /// Instructs the dialog to position itself on editing the given group.\n  void editGroup( unsigned id );\n\n  /// Returns true if any changes to the 'dictionaries' vector passed were done.\n  bool areDictionariesChanged() const\n  { return dictionariesChanged; }\n\n  /// Returns true if groups were changed.\n  bool areGroupsChanged() const\n  { return groupsChanged; }\n\nprotected:\n\n  virtual void accept();\n  \nprivate slots:\n\n  void on_tabs_currentChanged( int index );\n\n  void buttonBoxClicked( QAbstractButton * button );\n\n  void rescanSources();\n\n  void helpRequested();\n  void closeHelp();\n\nsignals:\n\n  void showDictionaryInfo( QString const & dictId );\n\n  void showDictionaryHeadwords( QString const & dictId );\n\nprivate:\n\n  bool isSourcesChanged() const;\n\n  void acceptChangedSources( bool rebuildGroups );\n\n  void save();\n  \nprivate:\n   \n  Config::Class & cfg;\n  std::vector< sptr< Dictionary::Class > > & dictionaries;\n  Instances::Groups & groupInstances;\n  QNetworkAccessManager & dictNetMgr;\n  \n  // Backed up to decide later if something was changed or not\n  Config::Class origCfg;\n\n  Ui::EditDictionaries ui;\n  Sources sources;\n  sptr< OrderAndProps > orderAndProps;\n  sptr< Groups > groups;\n\n  bool dictionariesChanged;\n  bool groupsChanged;\n  \n  int lastCurrentTab;\n\n  Help::HelpWindow * helpWindow;\n  QAction helpAction;\n};\n\n#endif\n"
        },
        {
          "name": "editdictionaries.ui",
          "type": "blob",
          "size": 1.75390625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ui version=\"4.0\">\n <class>EditDictionaries</class>\n <widget class=\"QDialog\" name=\"EditDictionaries\">\n  <property name=\"geometry\">\n   <rect>\n    <x>0</x>\n    <y>0</y>\n    <width>839</width>\n    <height>532</height>\n   </rect>\n  </property>\n  <property name=\"windowTitle\">\n   <string>Dictionaries</string>\n  </property>\n  <layout class=\"QVBoxLayout\" name=\"verticalLayout\">\n   <item>\n    <widget class=\"QTabWidget\" name=\"tabs\">\n     <property name=\"currentIndex\">\n      <number>0</number>\n     </property>\n     <widget class=\"QWidget\" name=\"dummy\">\n      <attribute name=\"title\">\n       <string notr=\"true\">Dummy</string>\n      </attribute>\n     </widget>\n    </widget>\n   </item>\n   <item>\n    <widget class=\"QDialogButtonBox\" name=\"buttons\">\n     <property name=\"orientation\">\n      <enum>Qt::Horizontal</enum>\n     </property>\n     <property name=\"standardButtons\">\n      <set>QDialogButtonBox::Apply|QDialogButtonBox::Cancel|QDialogButtonBox::Help|QDialogButtonBox::Ok</set>\n     </property>\n    </widget>\n   </item>\n  </layout>\n </widget>\n <resources/>\n <connections>\n  <connection>\n   <sender>buttons</sender>\n   <signal>accepted()</signal>\n   <receiver>EditDictionaries</receiver>\n   <slot>accept()</slot>\n   <hints>\n    <hint type=\"sourcelabel\">\n     <x>248</x>\n     <y>254</y>\n    </hint>\n    <hint type=\"destinationlabel\">\n     <x>157</x>\n     <y>274</y>\n    </hint>\n   </hints>\n  </connection>\n  <connection>\n   <sender>buttons</sender>\n   <signal>rejected()</signal>\n   <receiver>EditDictionaries</receiver>\n   <slot>reject()</slot>\n   <hints>\n    <hint type=\"sourcelabel\">\n     <x>316</x>\n     <y>260</y>\n    </hint>\n    <hint type=\"destinationlabel\">\n     <x>286</x>\n     <y>274</y>\n    </hint>\n   </hints>\n  </connection>\n </connections>\n</ui>\n"
        },
        {
          "name": "epwing.cc",
          "type": "blob",
          "size": 32.9775390625,
          "content": "/* This file is (c) 2014 Abs62\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"epwing_book.hh\"\n#include \"epwing.hh\"\n\n#include <QByteArray>\n#include <QDir>\n#include <QRunnable>\n#include <QSemaphore>\n\n#include <map>\n#include <set>\n#include <string>\n\n#include \"btreeidx.hh\"\n#include \"folding.hh\"\n#include \"categorized_logging.hh\"\n#include \"gddebug.hh\"\n#include \"fsencoding.hh\"\n#include \"chunkedstorage.hh\"\n#include \"wstring.hh\"\n#include \"wstring_qt.hh\"\n#include \"utf8.hh\"\n#include \"filetype.hh\"\n#include \"ftshelpers.hh\"\n\nnamespace Epwing {\n\nusing BtreeIndexing::WordArticleLink;\nusing BtreeIndexing::IndexedWords;\nusing BtreeIndexing::IndexInfo;\n\nusing std::map;\nusing std::multimap;\nusing std::vector;\nusing std::set;\nusing std::pair;\nusing gd::wstring;\n\nnamespace {\n\n#pragma pack( push, 1 )\n\nenum\n{\n  Signature = 0x58575045, // EPWX on little-endian, XWPE on big-endian\n  CurrentFormatVersion = 6 + BtreeIndexing::FormatVersion + Folding::Version\n};\n\nstruct IdxHeader\n{\n  quint32 signature; // First comes the signature, EPWX\n  quint32 formatVersion; // File format version (CurrentFormatVersion)\n  quint32 chunksOffset; // The offset to chunks' storage\n  quint32 indexBtreeMaxElements; // Two fields from IndexInfo\n  quint32 indexRootOffset;\n  quint32 wordCount;\n  quint32 articleCount;\n  quint32 nameSize;\n  quint32 langFrom;  // Source language\n  quint32 langTo;    // Target language\n}\n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\n#pragma pack( pop )\n\nbool indexIsOldOrBad( string const & indexFile )\n{\n  File::Class idx( indexFile, \"rb\" );\n\n  IdxHeader header;\n\n  return idx.readRecords( &header, sizeof( header ), 1 ) != 1 ||\n         header.signature != Signature ||\n         header.formatVersion != CurrentFormatVersion;\n}\n\nclass EpwingDictionary: public BtreeIndexing::BtreeDictionary\n{\n  Mutex idxMutex;\n  File::Class idx;\n  IdxHeader idxHeader;\n  string bookName;\n  ChunkedStorage::Reader chunks;\n  Epwing::Book::EpwingBook eBook;\n  QString cacheDirectory;\n\npublic:\n\n  EpwingDictionary( string const & id, string const & indexFile,\n                    vector< string > const & dictionaryFiles,\n                    int subBook );\n\n  ~EpwingDictionary();\n\n  virtual string getName() throw()\n  { return bookName; }\n\n  virtual map< Dictionary::Property, string > getProperties() throw()\n  { return map< Dictionary::Property, string >(); }\n\n  virtual unsigned long getArticleCount() throw()\n  { return idxHeader.articleCount; }\n\n  virtual unsigned long getWordCount() throw()\n  { return idxHeader.wordCount; }\n\n  inline virtual quint32 getLangFrom() const\n  { return idxHeader.langFrom; }\n\n  inline virtual quint32 getLangTo() const\n  { return idxHeader.langTo; }\n\n  virtual QString const& getDescription();\n\n  virtual sptr< Dictionary::DataRequest > getArticle( wstring const &,\n                                                      vector< wstring > const & alts,\n                                                      wstring const &,\n                                                      bool ignoreDiacritics )\n    THROW_SPEC( std::exception );\n\n  virtual sptr< Dictionary::DataRequest > getResource( string const & name )\n    THROW_SPEC( std::exception );\n\n  virtual sptr< Dictionary::DataRequest > getSearchResults( QString const & searchString,\n                                                            int searchMode, bool matchCase,\n                                                            int distanceBetweenWords,\n                                                            int maxResults,\n                                                            bool ignoreWordsOrder,\n                                                            bool ignoreDiacritics,\n                                                            QThreadPool * ftsThreadPoolPtr );\n  virtual void getArticleText( uint32_t articleAddress, QString & headword, QString & text );\n\n  virtual void makeFTSIndex(QAtomicInt & isCancelled, bool firstIteration );\n\n  virtual void setFTSParameters( Config::FullTextSearch const & fts )\n  {\n    if( ensureInitDone().size() )\n      return;\n\n    can_FTS = fts.enabled\n              && !fts.disabledTypes.contains( \"EPWING\", Qt::CaseInsensitive )\n              && ( fts.maxDictionarySize == 0 || getArticleCount() <= fts.maxDictionarySize );\n  }\n\n  static int japaneseWriting( gd::wchar ch );\n\n  static bool isSign( gd::wchar ch );\n\n  static bool isJapanesePunctiation( gd::wchar ch );\n\n  virtual sptr< Dictionary::WordSearchRequest > prefixMatch( wstring const &,\n                                                             unsigned long )\n    THROW_SPEC( std::exception );\n\n  virtual sptr< Dictionary::WordSearchRequest > stemmedMatch( wstring const &,\n                                                              unsigned minLength,\n                                                              unsigned maxSuffixVariation,\n                                                              unsigned long maxResults )\n    THROW_SPEC( std::exception );\n\nprotected:\n\n  void loadIcon() throw();\n\nprivate:\n\n  /// Loads the article.\n  void loadArticle( quint32 address, string & articleHeadword,\n                    string & articleText, int & articlePage, int & articleOffset );\n\n  void loadArticle( int articlePage, int articleOffset, string & articleHeadword,\n                    string & articleText );\n\n  void createCacheDirectory();\n\n  void removeDirectory( QString const & directory );\n\n  QString const & getImagesCacheDir()\n  { return eBook.getImagesCacheDir(); }\n\n  QString const & getSoundsCacheDir()\n  { return eBook.getSoundsCacheDir(); }\n\n  QString const & getMoviesCacheDir()\n  { return eBook.getMoviesCacheDir(); }\n\n  friend class EpwingArticleRequest;\n  friend class EpwingResourceRequest;\n  friend class EpwingWordSearchRequest;\n};\n\n\nEpwingDictionary::EpwingDictionary( string const & id,\n                                    string const & indexFile,\n                                    vector< string > const & dictionaryFiles,\n                                    int subBook ):\n  BtreeDictionary( id, dictionaryFiles ),\n  idx( indexFile, \"rb\" ),\n  idxHeader( idx.read< IdxHeader >() ),\n  chunks( idx, idxHeader.chunksOffset )\n{\n  vector< char > data( idxHeader.nameSize );\n  idx.seek( sizeof( idxHeader ) );\n  if( data.size() > 0 )\n  {\n    idx.read( &data.front(), idxHeader.nameSize );\n    bookName = string( &data.front(), idxHeader.nameSize );\n  }\n\n  // Initialize eBook\n\n  eBook.setBook( dictionaryFiles[ 0 ] );\n  eBook.setSubBook( subBook );\n\n  // Initialize the index\n\n  openIndex( IndexInfo( idxHeader.indexBtreeMaxElements,\n                        idxHeader.indexRootOffset ),\n             idx, idxMutex );\n\n  eBook.setDictID( getId() );\n\n  cacheDirectory = QDir::tempPath() + QDir::separator()\n                   + QString::fromUtf8( getId().c_str() )\n                   + \".cache\";\n  eBook.setCacheDirectory( cacheDirectory );\n\n  // Full-text search parameters\n\n  can_FTS = true;\n\n  ftsIdxName = indexFile + \"_FTS\";\n\n  if( !Dictionary::needToRebuildIndex( dictionaryFiles, ftsIdxName )\n      && !FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) )\n    FTS_index_completed.ref();\n}\n\nEpwingDictionary::~EpwingDictionary()\n{\n  removeDirectory( cacheDirectory );\n}\n\nvoid EpwingDictionary::loadIcon() throw()\n{\n  if ( dictionaryIconLoaded )\n    return;\n\n  QString fileName = FsEncoding::decode( getDictionaryFilenames()[ 0 ].c_str() )\n                     + QDir::separator()\n                     + eBook.getCurrentSubBookDirectory() + \".\";\n\n  if( !fileName.isEmpty() )\n    loadIconFromFile( fileName );\n\n  if( dictionaryIcon.isNull() )\n  {\n    // Load failed -- use default icons\n    dictionaryNativeIcon = dictionaryIcon = QIcon(\":/icons/icon32_epwing.png\");\n  }\n\n  dictionaryIconLoaded = true;\n}\n\nvoid EpwingDictionary::removeDirectory( QString const & directory )\n{\n  QDir dir( directory );\n  Q_FOREACH( QFileInfo info, dir.entryInfoList( QDir::NoDotAndDotDot\n                                                | QDir::AllDirs\n                                                | QDir::Files,\n                                                QDir::DirsFirst))\n  {\n    if( info.isDir() )\n      removeDirectory( info.absoluteFilePath() );\n    else\n      QFile::remove( info.absoluteFilePath() );\n  }\n\n  dir.rmdir( directory );\n}\n\nvoid EpwingDictionary::loadArticle( quint32 address,\n                                    string & articleHeadword,\n                                    string & articleText,\n                                    int & articlePage,\n                                    int & articleOffset )\n{\n  vector< char > chunk;\n\n  char * articleProps;\n\n  {\n    Mutex::Lock _( idxMutex );\n    articleProps = chunks.getBlock( address, chunk );\n  }\n\n  memcpy( &articlePage, articleProps, sizeof( articlePage ) );\n  memcpy( &articleOffset, articleProps + sizeof( articlePage ),\n          sizeof( articleOffset ) );\n\n  QString headword, text;\n\n  try\n  {\n    Mutex::Lock _( eBook.getLibMutex() );\n    eBook.getArticle( headword, text, articlePage, articleOffset, false );\n  }\n  catch( std::exception & e )\n  {\n    text = QString( \"Article reading error: %1\")\n           .arg( QString::fromUtf8( e.what() ) );\n  }\n\n  articleHeadword = string( headword.toUtf8().data() );\n  articleText = string( text.toUtf8().data() );\n\n  string prefix( \"<div class=\\\"epwing_text\\\">\" );\n\n  articleText = prefix + articleText + \"</div>\";\n}\n\nvoid EpwingDictionary::loadArticle( int articlePage,\n                                    int articleOffset,\n                                    string & articleHeadword,\n                                    string & articleText )\n{\n  QString headword, text;\n\n  try\n  {\n    Mutex::Lock _( eBook.getLibMutex() );\n    eBook.getArticle( headword, text, articlePage, articleOffset, false );\n  }\n  catch( std::exception & e )\n  {\n    text = QString( \"Article reading error: %1\")\n           .arg( QString::fromUtf8( e.what() ) );\n  }\n\n  articleHeadword = string( headword.toUtf8().data() );\n  articleText = string( text.toUtf8().data() );\n\n  string prefix( \"<div class=\\\"epwing_text\\\">\" );\n\n  articleText = prefix + articleText + \"</div>\";\n}\n\nQString const& EpwingDictionary::getDescription()\n{\n  if( !dictionaryDescription.isEmpty() )\n    return dictionaryDescription;\n\n  dictionaryDescription = \"NONE\";\n\n  QString str;\n  {\n    Mutex::Lock _( eBook.getLibMutex() );\n    str = eBook.copyright();\n  }\n\n  if( !str.isEmpty() )\n    dictionaryDescription = str;\n\n  return dictionaryDescription;\n}\n\nvoid EpwingDictionary::makeFTSIndex( QAtomicInt & isCancelled, bool firstIteration )\n{\n  if( !( Dictionary::needToRebuildIndex( getDictionaryFilenames(), ftsIdxName )\n         || FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) ) )\n    FTS_index_completed.ref();\n\n\n  if( haveFTSIndex() )\n    return;\n\n  if( firstIteration && getArticleCount() > FTS::MaxDictionarySizeForFastSearch )\n    return;\n\n  gdDebug( \"Epwing: Building the full-text index for dictionary: %s\\n\",\n           getName().c_str() );\n\n  try\n  {\n    FtsHelpers::makeFTSIndex( this, isCancelled );\n    FTS_index_completed.ref();\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"Epwing: Failed building full-text search index for \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n    QFile::remove( FsEncoding::decode( ftsIdxName.c_str() ) );\n  }\n}\n\nvoid EpwingDictionary::getArticleText( uint32_t articleAddress, QString & headword, QString & text )\n{\n  headword.clear();\n  text.clear();\n\n  vector< char > chunk;\n  char * articleProps;\n\n  {\n    Mutex::Lock _( idxMutex );\n    articleProps = chunks.getBlock( articleAddress, chunk );\n  }\n\n  uint32_t articlePage, articleOffset;\n\n  memcpy( &articlePage, articleProps, sizeof( articlePage ) );\n  memcpy( &articleOffset, articleProps + sizeof( articlePage ),\n          sizeof( articleOffset ) );\n\n  try\n  {\n    Mutex::Lock _( eBook.getLibMutex() );\n    eBook.getArticle( headword, text, articlePage, articleOffset, true );\n  }\n  catch( std::exception & e )\n  {\n    text = QString( \"Article reading error: %1\")\n           .arg( QString::fromUtf8( e.what() ) );\n  }\n}\n\n/// EpwingDictionary::getArticle()\n\nclass EpwingArticleRequest;\n\nclass EpwingArticleRequestRunnable: public QRunnable\n{\n  EpwingArticleRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  EpwingArticleRequestRunnable( EpwingArticleRequest & r_,\n                                QSemaphore & hasExited_ ): r( r_ ),\n                                                           hasExited( hasExited_ )\n  {}\n\n  ~EpwingArticleRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass EpwingArticleRequest: public Dictionary::DataRequest\n{\n  friend class EpwingArticleRequestRunnable;\n\n  wstring word;\n  vector< wstring > alts;\n  EpwingDictionary & dict;\n  bool ignoreDiacritics;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  EpwingArticleRequest( wstring const & word_,\n                        vector< wstring > const & alts_,\n                        EpwingDictionary & dict_, bool ignoreDiacritics_ ):\n    word( word_ ), alts( alts_ ), dict( dict_ ), ignoreDiacritics( ignoreDiacritics_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new EpwingArticleRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by EpwingArticleRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~EpwingArticleRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid EpwingArticleRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid EpwingArticleRequest::run()\n{\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  vector< WordArticleLink > chain = dict.findArticles( word, ignoreDiacritics );\n\n  for( unsigned x = 0; x < alts.size(); ++x )\n  {\n    /// Make an additional query for each alt\n\n    vector< WordArticleLink > altChain = dict.findArticles( alts[ x ], ignoreDiacritics );\n\n    chain.insert( chain.end(), altChain.begin(), altChain.end() );\n  }\n\n  multimap< wstring, pair< string, string > > mainArticles, alternateArticles;\n\n  set< quint32 > articlesIncluded; // Some synonims make it that the articles\n                                    // appear several times. We combat this\n                                    // by only allowing them to appear once.\n\n  wstring wordCaseFolded = Folding::applySimpleCaseOnly( word );\n  if( ignoreDiacritics )\n    wordCaseFolded = Folding::applyDiacriticsOnly( wordCaseFolded );\n\n  QVector< int > pages, offsets;\n\n  for( unsigned x = 0; x < chain.size(); ++x )\n  {\n    if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    {\n      finish();\n      return;\n    }\n\n    if ( articlesIncluded.find( chain[ x ].articleOffset ) != articlesIncluded.end() )\n      continue; // We already have this article in the body.\n\n    // Now grab that article\n\n    string headword, articleText;\n    int articlePage, articleOffset;\n\n    try\n    {\n      dict.loadArticle( chain[ x ].articleOffset, headword, articleText,\n                        articlePage, articleOffset );\n    }\n    catch(...)\n    {\n    }\n\n    pages.append( articlePage );\n    offsets.append( articleOffset );\n\n    // Ok. Now, does it go to main articles, or to alternate ones? We list\n    // main ones first, and alternates after.\n\n    // We do the case-folded comparison here.\n\n    wstring headwordStripped =\n      Folding::applySimpleCaseOnly( Utf8::decode( headword ) );\n    if( ignoreDiacritics )\n      headwordStripped = Folding::applyDiacriticsOnly( headwordStripped );\n\n    multimap< wstring, pair< string, string > > & mapToUse =\n      ( wordCaseFolded == headwordStripped ) ?\n        mainArticles : alternateArticles;\n\n    mapToUse.insert( pair< wstring, pair< string, string > >(\n      Folding::applySimpleCaseOnly( Utf8::decode( headword ) ),\n      pair< string, string >( headword, articleText ) ) );\n\n    articlesIncluded.insert( chain[ x ].articleOffset );\n  }\n\n  // Also try to find word in the built-in dictionary index\n  try\n  {\n    string headword, articleText;\n\n    QVector< int > pg, off;\n    {\n      Mutex::Lock _( dict.eBook.getLibMutex() );\n      dict.eBook.getArticlePos( gd::toQString( word ), pg, off );\n    }\n\n    for( int i = 0; i < pg.size(); i++ )\n    {\n      bool already = false;\n      for( int n = 0; n < pages.size(); n++ )\n      {\n        if( pages.at( n ) == pg.at( i )\n            && abs( offsets.at( n ) - off.at( i ) ) <= 4 )\n        {\n          already = true;\n          break;\n        }\n      }\n\n      if( !already )\n      {\n        dict.loadArticle( pg.at( i ), off.at( i ), headword, articleText );\n\n        mainArticles.insert( pair< wstring, pair< string, string > >(\n          Folding::applySimpleCaseOnly( Utf8::decode( headword ) ),\n          pair< string, string >( headword, articleText ) ) );\n\n        pages.append( pg.at( i ) );\n        offsets.append( off.at( i ) );\n      }\n    }\n  }\n  catch(...)\n  {\n  }\n\n  if ( mainArticles.empty() && alternateArticles.empty() )\n  {\n    // No such word\n    finish();\n    return;\n  }\n\n  string result = \"<div class=\\\"epwing_article\\\">\";\n\n  multimap< wstring, pair< string, string > >::const_iterator i;\n\n  for( i = mainArticles.begin(); i != mainArticles.end(); ++i )\n  {\n      result += \"<h3>\";\n      result += i->second.first;\n      result += \"</h3>\";\n      result += i->second.second;\n  }\n\n  for( i = alternateArticles.begin(); i != alternateArticles.end(); ++i )\n  {\n      result += \"<h3>\";\n      result += i->second.first;\n      result += \"</h3>\";\n      result += i->second.second;\n  }\n\n  result += \"</div>\";\n\n  Mutex::Lock _( dataMutex );\n\n  data.resize( result.size() );\n\n  memcpy( &data.front(), result.data(), result.size() );\n\n  hasAnyData = true;\n\n  finish();\n}\n\nsptr< Dictionary::DataRequest > EpwingDictionary::getArticle( wstring const & word,\n                                                              vector< wstring > const & alts,\n                                                              wstring const &,\n                                                              bool ignoreDiacritics )\n  THROW_SPEC( std::exception )\n{\n  return new EpwingArticleRequest( word, alts, *this, ignoreDiacritics );\n}\n\n//// EpwingDictionary::getResource()\n\nclass EpwingResourceRequest;\n\nclass EpwingResourceRequestRunnable: public QRunnable\n{\n  EpwingResourceRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  EpwingResourceRequestRunnable( EpwingResourceRequest & r_,\n                              QSemaphore & hasExited_ ): r( r_ ),\n                                                         hasExited( hasExited_ )\n  {}\n\n  ~EpwingResourceRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass EpwingResourceRequest: public Dictionary::DataRequest\n{\n  friend class EpwingResourceRequestRunnable;\n\n  EpwingDictionary & dict;\n\n  string resourceName;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  EpwingResourceRequest( EpwingDictionary & dict_,\n                      string const & resourceName_ ):\n    dict( dict_ ),\n    resourceName( resourceName_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new EpwingResourceRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by EpwingResourceRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~EpwingResourceRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid EpwingResourceRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid EpwingResourceRequest::run()\n{\n  // Some runnables linger enough that they are cancelled before they start\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  QString cacheDir;\n  {\n    Mutex::Lock _( dict.eBook.getLibMutex() );\n    if( Filetype::isNameOfPicture( resourceName ) )\n      cacheDir = dict.getImagesCacheDir();\n    else\n    if( Filetype::isNameOfSound( resourceName ) )\n      cacheDir = dict.getSoundsCacheDir();\n    else\n    if( Filetype::isNameOfVideo( resourceName ) )\n      cacheDir = dict.getMoviesCacheDir();\n  }\n\n  try\n  {\n    if( cacheDir.isEmpty() )\n    {\n      finish();\n      return;\n    }\n\n    QString fullName = cacheDir + QDir::separator()\n                       + FsEncoding::decode( resourceName.c_str() );\n\n    QFile f( fullName );\n    if( f.open( QFile::ReadOnly ) )\n    {\n      QByteArray buffer = f.readAll();\n\n      Mutex::Lock _( dataMutex );\n\n      data.resize( buffer.size() );\n\n      memcpy( &data.front(), buffer.data(), data.size() );\n\n      hasAnyData = true;\n    }\n  }\n  catch( std::exception &ex )\n  {\n    gdCWarning( dictionaryResourceLc, \"Epwing: Failed loading resource \\\"%s\\\" for \\\"%s\\\", reason: %s\\n\",\n                resourceName.c_str(), dict.getName().c_str(), ex.what() );\n    // Resource not loaded -- we don't set the hasAnyData flag then\n  }\n\n  finish();\n}\n\nsptr< Dictionary::DataRequest > EpwingDictionary::getResource( string const & name )\n  THROW_SPEC( std::exception )\n{\n  return new EpwingResourceRequest( *this, name );\n}\n\n\nsptr< Dictionary::DataRequest > EpwingDictionary::getSearchResults( QString const & searchString,\n                                                                    int searchMode, bool matchCase,\n                                                                    int distanceBetweenWords,\n                                                                    int maxResults,\n                                                                    bool ignoreWordsOrder,\n                                                                    bool ignoreDiacritics,\n                                                                    QThreadPool * ftsThreadPoolPtr )\n{\n  return new FtsHelpers::FTSResultsRequest( *this, searchString,searchMode, matchCase, distanceBetweenWords, maxResults, ignoreWordsOrder, ignoreDiacritics, ftsThreadPoolPtr );\n}\n\nint EpwingDictionary::japaneseWriting( gd::wchar ch )\n{\n  if( ( ch >= 0x30A0 && ch <= 0x30FF )\n      || ( ch >= 0x31F0 && ch <= 0x31FF )\n      || ( ch >= 0x3200 && ch <= 0x32FF )\n      || ( ch >= 0xFF00 && ch <= 0xFFEF )\n      || ( ch == 0x1B000 ) )\n    return 1; // Katakana\n  else\n  if( ( ch >= 0x3040 && ch <= 0x309F )\n      || ( ch == 0x1B001 ) )\n    return 2; // Hiragana\n  else\n  if( ( ch >= 0x4E00 && ch <= 0x9FAF )\n      || ( ch >= 0x3400 && ch <= 0x4DBF ) )\n    return 3; // Kanji\n\n  return 0;\n}\n\nbool EpwingDictionary::isSign( gd::wchar ch )\n{\n  switch( ch )\n  {\n    case 0x002B: // PLUS SIGN\n    case 0x003C: // LESS-THAN SIGN\n    case 0x003D: // EQUALS SIGN\n    case 0x003E: // GREATER-THAN SIGN\n    case 0x00AC: // NOT SIGN\n    case 0xFF0B: // FULLWIDTH PLUS SIGN\n    case 0xFF1C: // FULLWIDTH LESS-THAN SIGN\n    case 0xFF1D: // FULLWIDTH EQUALS SIGN\n    case 0xFF1E: // FULLWIDTH GREATER-THAN SIGN\n    case 0xFFE2: // FULLWIDTH NOT SIGN\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nbool EpwingDictionary::isJapanesePunctiation( gd::wchar ch )\n{\n  return ch >= 0x3000 && ch <= 0x303F;\n}\n\nclass EpwingWordSearchRequest;\n\nclass EpwingWordSearchRunnable: public QRunnable\n{\n  EpwingWordSearchRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  EpwingWordSearchRunnable( EpwingWordSearchRequest & r_,\n                            QSemaphore & hasExited_ ): r( r_ ),\n                                                       hasExited( hasExited_ )\n  {}\n\n  ~EpwingWordSearchRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass EpwingWordSearchRequest: public BtreeIndexing::BtreeWordSearchRequest\n{\n  friend class EpwingWordSearchRunnable;\n\n  EpwingDictionary & edict;\n\npublic:\n\n  EpwingWordSearchRequest( EpwingDictionary & dict_,\n                           wstring const & str_,\n                           unsigned minLength_,\n                           int maxSuffixVariation_,\n                           bool allowMiddleMatches_,\n                           unsigned long maxResults_ ):\n    BtreeWordSearchRequest( dict_, str_, minLength_, maxSuffixVariation_, allowMiddleMatches_, maxResults_, false ),\n    edict( dict_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new EpwingWordSearchRunnable( *this, hasExited ) );\n  }\n\n  virtual void findMatches();\n};\n\nvoid EpwingWordSearchRunnable::run()\n{\n  r.run();\n}\n\nvoid EpwingWordSearchRequest::findMatches()\n{\n  BtreeWordSearchRequest::findMatches();\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  while( matches.size() < maxResults )\n  {\n    QVector< QString > headwords;\n    {\n      Mutex::Lock _( edict.eBook.getLibMutex() );\n      if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n        break;\n\n      if( !edict.eBook.getMatches( gd::toQString( str ), headwords ) )\n        break;\n    }\n\n    Mutex::Lock _( dataMutex );\n\n    for( int i = 0; i < headwords.size(); i++ )\n      addMatch( gd::toWString( headwords.at( i ) ) );\n\n    break;\n  }\n\n  finish();\n}\n\nsptr< Dictionary::WordSearchRequest > EpwingDictionary::prefixMatch(\n  wstring const & str, unsigned long maxResults )\n  THROW_SPEC( std::exception )\n{\n  return new EpwingWordSearchRequest( *this, str, 0, -1, true, maxResults );\n}\n\nsptr< Dictionary::WordSearchRequest > EpwingDictionary::stemmedMatch(\n  wstring const & str, unsigned minLength, unsigned maxSuffixVariation,\n  unsigned long maxResults )\n  THROW_SPEC( std::exception )\n{\n  return new EpwingWordSearchRequest( *this, str, minLength, (int)maxSuffixVariation,\n                                      false, maxResults );\n}\n\n} // anonymous namespace\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing & initializing )\n  THROW_SPEC( std::exception )\n{\n  vector< sptr< Dictionary::Class > > dictionaries;\n\n  vector< string > dictFiles;\n  QByteArray catName;\n  catName += QDir::separator().toLatin1();\n  catName += \"catalogs\";\n\n  for( vector< string >::const_iterator i = fileNames.begin(); i != fileNames.end();\n       ++i )\n  {\n      // Skip files other than \"catalogs\" to speed up the scanning\n\n      if ( i->size() < (unsigned)catName.size() ||\n          strcasecmp( i->c_str() + ( i->size() - catName.size() ), catName.data() ) != 0 )\n        continue;\n\n      int ndir = i->size() - catName.size();\n      if( ndir < 1 )\n        ndir = 1;\n\n      string mainDirectory = i->substr( 0, ndir );\n\n      Epwing::Book::EpwingBook dict;\n      int subBooksNumber = 0;\n      try\n      {\n        subBooksNumber = dict.setBook( mainDirectory );\n      }\n      catch( std::exception & e )\n      {\n        gdWarning( \"Epwing dictionary initializing failed: %s, error: %s\\n\",\n                   mainDirectory.c_str(), e.what() );\n        continue;\n      }\n\n      for( int sb = 0; sb < subBooksNumber; sb++ )\n      {\n        QString dir;\n\n        try\n        {\n          dictFiles.clear();\n          dictFiles.push_back( mainDirectory );\n          dictFiles.push_back( *i );\n\n          dict.setSubBook( sb );\n\n          dir = FsEncoding::decode( mainDirectory.c_str() )\n                + FsEncoding::separator()\n                + dict.getCurrentSubBookDirectory();\n\n          Epwing::Book::EpwingBook::collectFilenames( dir, dictFiles );\n\n          QString fontSubName = FsEncoding::decode( mainDirectory.c_str() )\n                                + QDir::separator()\n                                + \"afonts_\" + QString::number( sb );\n          QFileInfo info( fontSubName );\n          if( info.exists() && info.isFile() )\n            dictFiles.push_back( FsEncoding::encode( fontSubName ) );\n\n          // Check if we need to rebuid the index\n\n          string dictId = Dictionary::makeDictionaryId( dictFiles );\n\n          string indexFile = indicesDir + dictId;\n\n          if ( Dictionary::needToRebuildIndex( dictFiles, indexFile ) ||\n                 indexIsOldOrBad( indexFile ) )\n          {\n            gdDebug( \"Epwing: Building the index for dictionary in directory %s\\n\", dir.toUtf8().data() );\n\n            QString str = dict.title();\n            QByteArray nameData = str.toUtf8();\n            initializing.indexingDictionary( nameData.data() );\n\n            File::Class idx( indexFile, \"wb\" );\n\n            IdxHeader idxHeader;\n\n            memset( &idxHeader, 0, sizeof( idxHeader ) );\n\n            // We write a dummy header first. At the end of the process the header\n            // will be rewritten with the right values.\n\n            idx.write( idxHeader );\n\n            idx.write( nameData.data(), nameData.size() );\n            idxHeader.nameSize = nameData.size();\n\n            IndexedWords indexedWords;\n\n            ChunkedStorage::Writer chunks( idx );\n\n            Epwing::Book::EpwingHeadword head;\n\n            dict.getFirstHeadword( head );\n\n            int wordCount = 0;\n            int articleCount = 0;\n\n            for( ; ; )\n            {\n              if( !head.headword.isEmpty() )\n              {\n                uint32_t offset = chunks.startNewBlock();\n                chunks.addToBlock( &head.page, sizeof( head.page ) );\n                chunks.addToBlock( &head.offset, sizeof( head.offset ) );\n\n                wstring hw = gd::toWString( head.headword );\n\n                indexedWords.addWord( hw, offset );\n                wordCount++;\n                articleCount++;\n\n                vector< wstring > words;\n\n                // Parse combined kanji/katakana/hiragana headwords\n\n                int w_prev = 0;\n                wstring word;\n                for( wstring::size_type n = 0; n < hw.size(); n++ )\n                {\n                  gd::wchar ch = hw[ n ];\n\n                  if( Folding::isPunct( ch ) || Folding::isWhitespace( ch )\n                      || EpwingDictionary::isSign( ch ) || EpwingDictionary::isJapanesePunctiation( ch ) )\n                    continue;\n\n                  int w = EpwingDictionary::japaneseWriting( ch );\n\n                  if( w > 0 )\n                  {\n                    // Store only separated words\n                    gd::wchar ch_prev = 0;\n                    if( n )\n                      ch_prev = hw[ n - 1 ];\n                    bool needStore = ( n == 0\n                                       || Folding::isPunct( ch_prev )\n                                       || Folding::isWhitespace( ch_prev )\n                                       || EpwingDictionary::isJapanesePunctiation( ch ) );\n\n                    word.push_back( ch );\n                    w_prev = w;\n                    wstring::size_type i;\n                    for(  i = n + 1; i < hw.size(); i++ )\n                    {\n                      ch = hw[ i ];\n                      if( Folding::isPunct( ch ) || Folding::isWhitespace( ch )\n                          || EpwingDictionary::isJapanesePunctiation( ch ) )\n                        break;\n                      w = EpwingDictionary::japaneseWriting( ch );\n                      if( w != w_prev )\n                        break;\n                      word.push_back( ch );\n                    }\n\n                    if( needStore )\n                    {\n                      if( i >= hw.size() || Folding::isPunct( ch ) || Folding::isWhitespace( ch )\n                          || EpwingDictionary::isJapanesePunctiation( ch ) )\n                        words.push_back( word );\n                    }\n                    word.clear();\n\n                    if( i < hw.size() )\n                      n = i;\n                    else\n                      break;\n                  }\n                }\n\n                if( words.size() > 1 )\n                {\n                  // Allow only one word in every charset\n\n                  size_t n;\n                  int writings[ 4 ];\n                  memset( writings, 0, sizeof(writings) );\n\n                  for( n = 0; n < words.size(); n++ )\n                  {\n                    int w = EpwingDictionary::japaneseWriting( words[ n ][ 0 ] );\n                    if( writings[ w ] )\n                      break;\n                    else\n                      writings[ w ] = 1;\n                  }\n\n                  if( n >= words.size() )\n                  {\n                    for( n = 0; n < words.size(); n++ )\n                    {\n                      indexedWords.addWord( words[ n ], offset );\n                      wordCount++;\n                    }\n                  }\n                }\n\n              }\n              if( !dict.getNextHeadword( head ) )\n                break;\n            }\n\n            dict.clearBuffers();\n\n            // Finish with the chunks\n\n            idxHeader.chunksOffset = chunks.finish();\n\n            // Build index\n\n            IndexInfo idxInfo = BtreeIndexing::buildIndex( indexedWords, idx );\n\n            idxHeader.indexBtreeMaxElements = idxInfo.btreeMaxElements;\n            idxHeader.indexRootOffset = idxInfo.rootOffset;\n\n            indexedWords.clear(); // Release memory -- no need for this data\n\n            // That concludes it. Update the header.\n\n            idxHeader.signature = Signature;\n            idxHeader.formatVersion = CurrentFormatVersion;\n\n            idxHeader.wordCount = wordCount;\n            idxHeader.articleCount = articleCount;\n\n            idx.rewind();\n\n            idx.write( &idxHeader, sizeof( idxHeader ) );\n\n\n          } // If need to rebuild\n\n          dictionaries.push_back( new EpwingDictionary( dictId,\n                                                        indexFile,\n                                                        dictFiles,\n                                                        sb ) );\n        }\n        catch( std::exception & e )\n        {\n          gdWarning( \"Epwing dictionary initializing failed: %s, error: %s\\n\",\n                     dir.toUtf8().data(), e.what() );\n          continue;\n        }\n      }\n\n  }\n  return dictionaries;\n}\n\n} // namespace Epwing\n"
        },
        {
          "name": "epwing.hh",
          "type": "blob",
          "size": 0.509765625,
          "content": "#ifndef __EPWING_HH__INCLUDED__\n#define __EPWING_HH__INCLUDED__\n\n#include \"dictionary.hh\"\n\n/// Support for the Epwing dictionaries.\nnamespace Epwing {\n\nusing std::vector;\nusing std::string;\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing & )\n    THROW_SPEC( std::exception );\n}\n\n#endif // __EPWING_HH__INCLUDED__\n"
        },
        {
          "name": "epwing_book.cc",
          "type": "blob",
          "size": 49.7451171875,
          "content": "/* This file is (c) 2014 Abs62\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"epwing_book.hh\"\n\n#include <QDir>\n#include <QTextStream>\n#include <QTextDocumentFragment>\n#include \"gddebug.hh\"\n#include \"fsencoding.hh\"\n#include \"audiolink.hh\"\n#include \"wstring.hh\"\n#include \"wstring_qt.hh\"\n#include \"folding.hh\"\n#include \"epwing_charmap.hh\"\n\n#if defined( Q_OS_WIN32 ) || defined( Q_OS_MAC )\n#define _FILE_OFFSET_BITS 64\n#endif\n\n#include <eb/text.h>\n#include <eb/appendix.h>\n#include <eb/error.h>\n#include <eb/binary.h>\n#include <eb/font.h>\n\n#define HitsBufferSize 512\n\nnamespace Epwing {\n\nvoid initialize()\n{\n  eb_initialize_library();\n}\n\nvoid finalize()\n{\n  eb_finalize_library();\n}\n\nnamespace Book {\n\n#define HookFunc(name) \\\n    EB_Error_Code name(EB_Book *, EB_Appendix *, void*, EB_Hook_Code, int, \\\n                       const unsigned int*)\n\nHookFunc( hook_newline );\nHookFunc( hook_iso8859_1 );\nHookFunc( hook_narrow_jisx0208 );\nHookFunc( hook_wide_jisx0208 );\nHookFunc( hook_gb2312 );\nHookFunc( hook_superscript );\nHookFunc( hook_subscript );\nHookFunc( hook_decoration );\nHookFunc( hook_color_image );\nHookFunc( hook_gray_image );\nHookFunc( hook_mono_image );\nHookFunc( hook_wave );\nHookFunc( hook_mpeg );\nHookFunc( hook_narrow_font );\nHookFunc( hook_wide_font );\nHookFunc( hook_reference );\n\nconst EB_Hook hooks[] = {\n  { EB_HOOK_NEWLINE, hook_newline },\n  { EB_HOOK_ISO8859_1, hook_iso8859_1 },\n  { EB_HOOK_NARROW_JISX0208, hook_narrow_jisx0208 },\n  { EB_HOOK_WIDE_JISX0208, hook_wide_jisx0208 },\n  { EB_HOOK_GB2312, hook_gb2312 },\n  { EB_HOOK_BEGIN_SUBSCRIPT, hook_subscript },\n  { EB_HOOK_END_SUBSCRIPT, hook_subscript },\n  { EB_HOOK_BEGIN_SUPERSCRIPT, hook_superscript },\n  { EB_HOOK_END_SUPERSCRIPT, hook_superscript },\n  { EB_HOOK_BEGIN_DECORATION, hook_decoration },\n  { EB_HOOK_END_DECORATION, hook_decoration },\n  { EB_HOOK_BEGIN_COLOR_BMP, hook_color_image },\n  { EB_HOOK_BEGIN_COLOR_JPEG, hook_color_image },\n  { EB_HOOK_END_COLOR_GRAPHIC, hook_color_image },\n  { EB_HOOK_BEGIN_IN_COLOR_BMP, hook_color_image },\n  { EB_HOOK_BEGIN_IN_COLOR_JPEG, hook_color_image },\n  { EB_HOOK_END_IN_COLOR_GRAPHIC, hook_color_image },\n  { EB_HOOK_BEGIN_MONO_GRAPHIC, hook_mono_image },\n  { EB_HOOK_END_MONO_GRAPHIC, hook_mono_image },\n  { EB_HOOK_BEGIN_WAVE, hook_wave },\n  { EB_HOOK_END_WAVE, hook_wave },\n  { EB_HOOK_BEGIN_MPEG, hook_mpeg },\n  { EB_HOOK_END_MPEG, hook_mpeg },\n  { EB_HOOK_NARROW_FONT, hook_narrow_font },\n  { EB_HOOK_WIDE_FONT, hook_wide_font },\n  { EB_HOOK_BEGIN_REFERENCE, hook_reference },\n  { EB_HOOK_END_REFERENCE, hook_reference },\n  { EB_HOOK_NULL, NULL }\n};\n\nconst EB_Hook refHooks[] = {\n  { EB_HOOK_BEGIN_REFERENCE, hook_reference },\n  { EB_HOOK_END_REFERENCE, hook_reference },\n  { EB_HOOK_NULL, NULL }\n};\n\n#define EUC_TO_ASCII_TABLE_START\t0xa0\n#define EUC_TO_ASCII_TABLE_END\t\t0xff\n\n// Tables from EB library\n\nstatic const unsigned char euc_a1_to_ascii_table[] = {\n    0x00, 0x20, 0x00, 0x00, 0x2c, 0x2e, 0x00, 0x3a,     /* 0xa0 */\n    0x3b, 0x3f, 0x21, 0x00, 0x00, 0x00, 0x60, 0x00,     /* 0xa8 */\n    0x5e, 0x7e, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00,     /* 0xb0 */\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x2f,     /* 0xb8 */\n    0x5c, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x27,     /* 0xc0 */\n    0x00, 0x22, 0x28, 0x29, 0x00, 0x00, 0x5b, 0x5d,     /* 0xc8 */\n    0x7b, 0x7d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     /* 0xd0 */\n    0x00, 0x00, 0x00, 0x00, 0x2b, 0x2d, 0x00, 0x00,     /* 0xd8 */\n    0x00, 0x3d, 0x00, 0x3c, 0x3e, 0x00, 0x00, 0x00,     /* 0xe0 */\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c,     /* 0xe8 */\n    0x24, 0x00, 0x00, 0x25, 0x23, 0x26, 0x2a, 0x40,     /* 0xf0 */\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     /* 0xf8 */\n};\n\nstatic const unsigned char euc_a3_to_ascii_table[] = {\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     /* 0xa0 */\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     /* 0xa8 */\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,     /* 0xb0 */\n    0x38, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     /* 0xb8 */\n    0x00, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,     /* 0xc0 */\n    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,     /* 0xc8 */\n    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,     /* 0xd0 */\n    0x58, 0x59, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00,     /* 0xd8 */\n    0x00, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,     /* 0xe0 */\n    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,     /* 0xe8 */\n    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,     /* 0xf0 */\n    0x78, 0x79, 0x7a, 0x00, 0x00, 0x00, 0x00, 0x00,     /* 0xf8 */\n};\n\n// Hook functions\n\nEB_Error_Code hook_newline( EB_Book * book, EB_Appendix *, void * ptr,\n                            EB_Hook_Code, int, const unsigned int * )\n{\n  EContainer * container = static_cast< EContainer * >( ptr );\n\n  if( container->textOnly )\n    eb_write_text_byte1( book,  '\\n' );\n  else\n    eb_write_text_string( book, \"<br>\" );\n  return EB_SUCCESS;\n}\n\nEB_Error_Code hook_iso8859_1( EB_Book * book, EB_Appendix *, void * container,\n                              EB_Hook_Code, int, const unsigned int * argv )\n{\n  EpwingBook * ebook = static_cast< EpwingBook * >( container );\n  if( ebook->codecISO() )\n  {\n    QByteArray b = ebook->codecISO()->toUnicode( (const char *)argv, 1 ).toUtf8();\n    eb_write_text( book, b.data(), b.size() );\n  }\n  return EB_SUCCESS;\n}\n\nEB_Error_Code hook_narrow_jisx0208( EB_Book * book, EB_Appendix *,\n                                    void * container, EB_Hook_Code, int,\n                                    const unsigned int * argv )\n{\n  if( *argv == 0xA1E3 )\n    eb_write_text_string( book, \"&lt;\" );\n  else\n  if( *argv == 0xA1E4 )\n    eb_write_text_string( book, \"&gt;\" );\n  else\n  if( *argv == 0xA1F5 )\n    eb_write_text_string( book, \"&amp;\" );\n  else\n  {\n    unsigned char buf[ 2 ];\n    buf[ 0 ] = argv[ 0 ] >> 8;\n    buf[ 1 ] = argv[ 0 ] & 0xff;\n    int out_code = 0;\n\n    if( buf[ 0 ] == 0xA1 && buf[ 1 ] >= EUC_TO_ASCII_TABLE_START )\n      out_code = euc_a1_to_ascii_table[ buf[ 1 ] - EUC_TO_ASCII_TABLE_START ];\n    else\n    if( buf[ 0 ] == 0xA3 && buf[ 1 ] >= EUC_TO_ASCII_TABLE_START )\n      out_code = euc_a3_to_ascii_table[ buf[ 1 ] - EUC_TO_ASCII_TABLE_START ];\n\n    if( out_code == 0 )\n    {\n      EContainer * cont = static_cast< EContainer * >( container );\n      if( cont->book->codecEuc() )\n      {\n        QByteArray str = cont->book->codecEuc()->toUnicode( (const char *)buf, 2 ).toUtf8();\n        eb_write_text( book, str.data(), str.size() );\n      }\n      else\n        eb_write_text( book, (const char *)buf, 2 );\n    }\n    else\n      eb_write_text_byte1( book, out_code );\n  }\n\n  return EB_SUCCESS;\n}\n\nEB_Error_Code hook_wide_jisx0208( EB_Book * book, EB_Appendix *, void * ptr,\n                                  EB_Hook_Code, int, const unsigned int * argv )\n{\n  EpwingBook * ebook = static_cast< EContainer * >( ptr )->book;\n\n  char buf[2];\n  buf[1] = *argv & 0xFF;\n  buf[0] = ( *argv & 0xFF00 ) >> 8;\n\n  if( ebook->codecEuc() )\n  {\n    QByteArray b = ebook->codecEuc()->toUnicode( buf, 2 ).toUtf8();\n    eb_write_text( book, b.data(), b.size() );\n  }\n  else\n    eb_write_text_byte2( book, buf[ 0 ], buf[ 1 ] );\n\n  return EB_SUCCESS;\n}\n\nEB_Error_Code hook_gb2312( EB_Book * book, EB_Appendix *, void * container,\n                           EB_Hook_Code, int, const unsigned int * argv )\n{\n  EpwingBook * ebook = static_cast< EContainer * >( container )->book;\n\n  char buf[2];\n  buf[1] = *argv & 0xFF;\n  buf[0] = ( *argv & 0xFF00 ) >> 8 ;\n\n  if( ebook->codecGB() )\n  {\n    QByteArray b = ebook->codecGB()->toUnicode( buf, 2 ).toUtf8();\n    eb_write_text( book, b.data(), b.size() );\n  }\n  else\n    eb_write_text_byte2( book, buf[ 0 ], buf[ 1 ] );\n\n  return EB_SUCCESS;\n}\n\nEB_Error_Code hook_subscript( EB_Book * book, EB_Appendix *, void * container,\n                              EB_Hook_Code code, int, const unsigned int * )\n{\n  EContainer * cn = static_cast< EContainer * >( container );\n\n  if( cn->textOnly )\n    return EB_SUCCESS;\n\n  if( code == EB_HOOK_BEGIN_SUBSCRIPT )\n    eb_write_text_string( book, cn->book->beginDecoration( EpwingBook::SUBSCRIPT ) );\n\n  if( code == EB_HOOK_END_SUBSCRIPT )\n    eb_write_text_string( book, cn->book->endDecoration( EpwingBook::SUBSCRIPT ) );\n\n  return EB_SUCCESS;\n}\n\nEB_Error_Code hook_superscript( EB_Book * book, EB_Appendix *, void * container,\n                                EB_Hook_Code code, int, const unsigned int * )\n{\n  EContainer * cn = static_cast< EContainer * >( container );\n\n  if( cn->textOnly )\n    return EB_SUCCESS;\n\n  if( code == EB_HOOK_BEGIN_SUPERSCRIPT )\n    eb_write_text_string( book, cn->book->beginDecoration( EpwingBook::SUPERSCRIPT ) );\n\n  if( code == EB_HOOK_END_SUPERSCRIPT )\n    eb_write_text_string( book, cn->book->endDecoration( EpwingBook::SUPERSCRIPT ) );\n\n  return EB_SUCCESS;\n}\n\nEB_Error_Code hook_decoration( EB_Book * book, EB_Appendix *, void * container,\n                               EB_Hook_Code code, int, const unsigned int * argv )\n{\n  EContainer * cn = static_cast< EContainer * >( container );\n\n  if( cn->textOnly )\n    return EB_SUCCESS;\n\n  if( code == EB_HOOK_BEGIN_DECORATION )\n    eb_write_text_string( book, cn->book->beginDecoration( argv[ 1 ] ) );\n\n  if( code == EB_HOOK_END_DECORATION )\n    eb_write_text_string( book, cn->book->endDecoration( argv[ 1 ] ) );\n\n  return EB_SUCCESS;\n}\n\nEB_Error_Code hook_color_image( EB_Book * book, EB_Appendix *, void * container,\n                                EB_Hook_Code code, int, const unsigned int * argv )\n{\n  EContainer * cn = static_cast< EContainer * >( container );\n\n  if( cn->textOnly )\n    return EB_SUCCESS;\n\n  QByteArray str = cn->book->handleColorImage( code, argv );\n  if( !str.isEmpty() )\n    eb_write_text( book, str.data(), str.size() );\n\n  return EB_SUCCESS;\n}\n\nEB_Error_Code hook_mono_image( EB_Book * book, EB_Appendix *, void * container,\n                               EB_Hook_Code code, int, const unsigned int * argv )\n{\n  EContainer * cn = static_cast< EContainer * >( container );\n\n  if( cn->textOnly )\n    return EB_SUCCESS;\n\n  QByteArray str = cn->book->handleMonoImage( code, argv );\n  if( !str.isEmpty() )\n    eb_write_text( book, str.data(), str.size() );\n\n  return EB_SUCCESS;\n}\n\nEB_Error_Code hook_wave( EB_Book * book, EB_Appendix *, void * container,\n                         EB_Hook_Code code, int, const unsigned int * argv )\n{\n  EContainer * cn = static_cast< EContainer * >( container );\n\n  if( cn->textOnly )\n    return EB_SUCCESS;\n\n  QByteArray str = cn->book->handleWave( code, argv );\n  if( !str.isEmpty() )\n    eb_write_text( book, str.data(), str.size() );\n\n  return EB_SUCCESS;\n}\n\nEB_Error_Code hook_mpeg( EB_Book * book, EB_Appendix *, void * container,\n                         EB_Hook_Code code, int, const unsigned int * argv )\n{\n  EContainer * cn = static_cast< EContainer * >( container );\n\n  if( cn->textOnly )\n    return EB_SUCCESS;\n\n  QByteArray str = cn->book->handleMpeg( code, argv );\n  if( !str.isEmpty() )\n    eb_write_text( book, str.data(), str.size() );\n\n  return EB_SUCCESS;\n}\n\nEB_Error_Code hook_narrow_font( EB_Book * book, EB_Appendix *, void * container,\n                                EB_Hook_Code, int, const unsigned int * argv )\n{\n  EContainer * cn = static_cast< EContainer * >( container );\n\n  QByteArray str = cn->book->handleNarrowFont( argv, cn->textOnly );\n  if( !str.isEmpty() )\n    eb_write_text( book, str.data(), str.size() );\n\n  return EB_SUCCESS;\n}\n\nEB_Error_Code hook_wide_font( EB_Book * book, EB_Appendix *, void * container,\n                              EB_Hook_Code, int, const unsigned int * argv )\n{\n  EContainer * cn = static_cast< EContainer * >( container );\n\n  QByteArray str = cn->book->handleWideFont( argv, cn->textOnly );\n  if( !str.isEmpty() )\n    eb_write_text( book, str.data(), str.size() );\n\n  return EB_SUCCESS;\n}\n\nEB_Error_Code hook_reference( EB_Book * book, EB_Appendix *, void * container,\n                              EB_Hook_Code code, int, const unsigned int * argv )\n{\n  EContainer * cn = static_cast< EContainer * >( container );\n\n  if( cn->textOnly )\n    return EB_SUCCESS;\n\n  QByteArray str = cn->book->handleReference( code, argv );\n  if( !str.isEmpty() )\n    eb_write_text( book, str.data(), str.size() );\n\n  return EB_SUCCESS;\n}\n\n// EpwingBook class\n\nEpwingBook::EpwingBook() :\n  currentSubBook( -1 )\n{\n  codec_ISO = QTextCodec::codecForName( \"ISO8859-1\" );\n  codec_GB = QTextCodec::codecForName( \"GB2312\" );\n  codec_Euc = QTextCodec::codecForName(\"EUC-JP\");\n\n  eb_initialize_book( &book );\n  eb_initialize_appendix( &appendix );\n\n  eb_initialize_hookset( &hookSet );\n  eb_set_hooks( &hookSet, hooks );\n\n  eb_initialize_hookset( &refHookSet );\n  eb_set_hooks( &refHookSet, refHooks );\n}\n\nEpwingBook::~EpwingBook()\n{\n  eb_finalize_hookset( &hookSet );\n  eb_finalize_appendix( &appendix );\n  eb_finalize_book( &book );\n}\n\nvoid EpwingBook::setErrorString( QString const & func, EB_Error_Code code )\n{\n  QTextCodec * const localeCodec = gdCodecForLocale();\n  error_string = QString( \"EB \\\"%1\\\" function error: %2 (%3)\" )\n                 .arg( func, localeCodec->toUnicode( eb_error_string( code ) ),\n                       localeCodec->toUnicode( eb_error_message( code ) ) );\n\n  if( currentPosition.page != 0 )\n    error_string += QString( \" on page %1, offset %2\" ).arg( QString::number( currentPosition.page ) )\n                                                       .arg( QString::number( currentPosition.offset ) );\n}\n\nvoid EpwingBook::collectFilenames( QString const & directory, vector< string > & files )\n{\n  QDir dir( directory );\n  QString catName;\n  catName += QDir::separator();\n  catName += \"catalogs\";\n\n  QFileInfoList entries = dir.entryInfoList( QDir::AllDirs | QDir::Files | QDir::NoDotAndDotDot,\n                                             QDir::Name | QDir::DirsLast );\n\n  for( QFileInfoList::const_iterator i = entries.constBegin();\n       i != entries.constEnd(); ++i )\n  {\n    QString fullName = QDir::toNativeSeparators( i->filePath() );\n\n    if( i->isDir() )\n      collectFilenames( fullName, files );\n    else\n      files.push_back( FsEncoding::encode( fullName ) );\n  }\n}\n\nint EpwingBook::setBook( string const & directory )\n{\n  error_string.clear();\n\n  if( directory.empty() )\n    throw exEpwing( \"No such directory\" );\n\n  currentPosition.page = 0;\n\n  indexHeadwordsPosition.page = 0;\n  indexHeadwordsPosition.offset = 0;\n\n  currentSubBook = -1;\n\n  EB_Error_Code ret = eb_bind( &book, directory.c_str() );\n  if( ret != EB_SUCCESS )\n  {\n    setErrorString( \"eb_bind\", ret );\n    throw exEbLibrary( error_string.toUtf8().data() );\n    return -1;\n  }\n\n  ret = eb_bind_appendix( &appendix, directory.c_str() );\n  if( ret != EB_SUCCESS )\n  {\n    setErrorString( \"eb_bind_appendix\", ret );\n  }\n\n  ret = eb_subbook_list( &book, subBookList, &subBookCount );\n  if( ret != EB_SUCCESS )\n  {\n    setErrorString( \"eb_subbook_list\", ret );\n    throw exEbLibrary( error_string.toUtf8().data() );\n  }\n\n  ret = eb_appendix_subbook_list( &appendix, subAppendixList, &subAppendixCount );\n  if( ret != EB_SUCCESS )\n  {\n    setErrorString( \"eb_appendix_subbook_list\", ret );\n  }\n\n  if( !codec_Euc\n      || ( book.character_code == EB_CHARCODE_ISO8859_1 && !codec_ISO )\n      || ( book.character_code == EB_CHARCODE_JISX0208_GB2312 && !codec_GB ) )\n    throw exEpwing( \"No required codec to decode dictionary\" );\n\n  rootDir = FsEncoding::decode( directory.c_str() );\n\n  return subBookCount;\n}\n\nbool EpwingBook::setSubBook( int book_nom )\n{\n  error_string.clear();\n\n  customFontsMap.clear();\n\n  currentPosition.page = 0;\n\n  if( book_nom < 0 || book_nom >= subBookCount )\n    throw exEpwing( \"Invalid subbook number\" );\n\n  if( currentSubBook == book_nom )\n    return true;\n\n  EB_Error_Code ret = eb_set_subbook( &book, subBookList[ book_nom ] );\n  if( ret != EB_SUCCESS )\n  {\n    setErrorString( \"eb_set_subbook\", ret );\n    throw exEbLibrary( error_string.toUtf8().data() );\n  }\n  currentSubBook = book_nom;\n\n  if( book_nom < subAppendixCount )\n  {\n    ret = eb_set_appendix_subbook( &appendix, subAppendixList[ book_nom ] );\n    if( ret != EB_SUCCESS )\n    {\n      setErrorString( \"eb_set_appendix_subbook\", ret );\n    }\n  }\n\n  if( eb_have_font( &book, EB_FONT_16 ) )\n  {\n    ret = eb_set_font( &book, EB_FONT_16 );\n    if( ret != EB_SUCCESS )\n      setErrorString( \"eb_set_font\", ret );\n  }\n\n  // Load fonts list\n\n  QString fileName = rootDir + QDir::separator()\n                     + \"afonts_\" + QString::number( book_nom );\n\n  QFile f( fileName );\n  if( f.open( QFile::ReadOnly | QFile::Text ) )\n  {\n    QTextStream ts( &f );\n    ts.setCodec( \"UTF-8\" );\n\n    QString line = ts.readLine();\n    while( !line.isEmpty() )\n    {\n      QStringList list = line.remove( '\\n' ).split( ' ', Qt4x5::skipEmptyParts() );\n      if( list.count() == 2 )\n        customFontsMap[ list[ 0 ] ] = list[ 1 ];\n      line = ts.readLine();\n    }\n\n    f.close();\n  }\n\n  return true;\n}\n\nvoid EpwingBook::setCacheDirectory( QString const & cacheDir )\n{\n  mainCacheDir = cacheDir;\n  cacheImagesDir.clear();\n  cacheSoundsDir.clear();\n  cacheMoviesDir.clear();\n  cacheFontsDir.clear();\n\n  imageCacheList.clear();\n  soundsCacheList.clear();\n  moviesCacheList.clear();\n  fontsCacheList.clear();\n}\n\nQString EpwingBook::createCacheDir( QString const & dirName )\n{\n  QDir dir;\n  QFileInfo info( mainCacheDir );\n  if( !info.exists() || !info.isDir() )\n  {\n    if( !dir.mkdir( mainCacheDir ) )\n    {\n      gdWarning( \"Epwing: can't create cache directory \\\"%s\\\"\", mainCacheDir.toUtf8().data() );\n      return QString();\n    }\n  }\n\n  QString cacheDir = mainCacheDir + QDir::separator() + dirName;\n  info = QFileInfo( cacheDir );\n  if( !info.exists() || !info.isDir() )\n  {\n    if( !dir.mkdir( cacheDir ) )\n    {\n      gdWarning( \"Epwing: can't create cache directory \\\"%s\\\"\", cacheDir.toUtf8().data() );\n      return QString();\n    }\n  }\n  return cacheDir;\n}\n\nQString EpwingBook::getCurrentSubBookDirectory()\n{\n  error_string.clear();\n\n  if( currentSubBook < 0 || currentSubBook >= subBookCount )\n  {\n    setErrorString( \"eb_subbook_directory2\", EB_ERR_NO_SUCH_BOOK );\n    throw exEbLibrary( error_string.toUtf8().data() );\n  }\n\n  char buffer[ EB_MAX_PATH_LENGTH + 1 ];\n\n  EB_Error_Code ret = eb_subbook_directory2( &book, subBookList[ currentSubBook ], buffer );\n  if( ret != EB_SUCCESS )\n  {\n    setErrorString( \"eb_subbook_directory2\", ret );\n    throw exEbLibrary( error_string.toUtf8().data() );\n  }\n\n  return QString::fromLocal8Bit( buffer );\n}\n\nQString EpwingBook::makeFName( QString const & ext, int page, int offset ) const\n{\n  QString name = QString::number( page )\n                 + \"x\"\n                 + QString::number( offset )\n                 + \".\"\n                 + ext;\n  return name;\n}\n\nQString EpwingBook::title()\n{\n  char buf[ EB_MAX_TITLE_LENGTH + 1 ];\n  error_string.clear();\n\n  EB_Error_Code ret = eb_subbook_title( &book, buf );\n  if( ret != EB_SUCCESS )\n  {\n    setErrorString( \"eb_subbook_title\", ret );\n    throw exEbLibrary( error_string.toUtf8().data() );\n  }\n\n  buf[ EB_MAX_TITLE_LENGTH ] = 0;\n  if( codec_Euc )\n    return codec_Euc->toUnicode( buf );\n\n  return QString();\n}\n\nQString EpwingBook::copyright()\n{\n  error_string.clear();\n\n  if( !eb_have_copyright( &book ) )\n    return QString();\n\n  EB_Position position;\n  EB_Error_Code ret = eb_copyright( &book, &position );\n  if( ret != EB_SUCCESS )\n  {\n    setErrorString( \"eb_copyright\", ret );\n    throw exEbLibrary( error_string.toUtf8().data() );\n  }\n\n  currentPosition = position;\n\n  return getText( position.page, position.offset, true );\n}\n\nQString EpwingBook::getText( int page, int offset, bool text_only )\n{\n  error_string.clear();\n\n  EB_Position pos;\n  pos.page = page;\n  pos.offset = offset;\n  currentPosition = pos;\n\n  EB_Error_Code ret = eb_seek_text(&book, &pos);\n  if( ret != EB_SUCCESS )\n  {\n    setErrorString( \"eb_seek_text\", ret );\n    currentPosition.page = 0;\n    throw exEbLibrary( error_string.toUtf8().data() );\n  }\n\n  QByteArray buf;\n  char buffer[ TextBufferSize + 1 ];\n  ssize_t buffer_length;\n\n  EContainer container( this, text_only );\n\n  prepareToRead();\n\n  for( ; ; )\n  {\n    ret = eb_read_text( &book, &appendix, &hookSet, &container,\n                        TextBufferSize, buffer, &buffer_length );\n\n    if( ret != EB_SUCCESS )\n    {\n      setErrorString( \"eb_read_text\", ret );\n      break;\n    }\n\n    buf += QByteArray( buffer, buffer_length );\n\n    if( eb_is_text_stopped( &book ) )\n      break;\n\n    if( buf.length() > TextSizeLimit )\n    {\n      error_string = \"Data too large\";\n      currentPosition.page = 0;\n      return QString();\n    }\n  }\n\n  QString text = QString::fromUtf8( buf.data(), buf.size() ).trimmed();\n  finalizeText( text );\n  return text;\n}\n\nvoid EpwingBook::getReferencesFromText( int page, int offset )\n{\n  error_string.clear();\n\n  EB_Position pos;\n  pos.page = page;\n  pos.offset = offset;\n\n  currentPosition = pos;\n\n  EB_Error_Code ret = eb_seek_text(&book, &pos);\n  if( ret != EB_SUCCESS )\n  {\n    setErrorString( \"eb_seek_text\", ret );\n    throw exEbLibrary( error_string.toUtf8().data() );\n  }\n\n  char buffer[ TextBufferSize + 1 ];\n  ssize_t buffer_length;\n\n  EContainer container( this, false );\n\n  prepareToRead();\n\n  for( ; ; )\n  {\n    ret = eb_read_text( &book, &appendix, &refHookSet, &container,\n                        TextBufferSize, buffer, &buffer_length );\n\n    if( ret != EB_SUCCESS )\n    {\n      setErrorString( \"eb_read_text\", ret );\n      break;\n    }\n\n    if( eb_is_text_stopped( &book ) )\n      break;\n  }\n\n  for( int x = 0; x < refPages.size(); x++ )\n    LinksQueue.push_back( EWPos( refPages[ x ], refOffsets[ x ] ) );\n}\n\nEB_Error_Code EpwingBook::forwardText( EB_Position & startPos )\n{\n  EB_Error_Code ret = eb_seek_text( &book, &startPos );\n  if( ret != EB_SUCCESS )\n  {\n    setErrorString( \"eb_seek_text\", ret );\n    throw exEbLibrary( error_string.toUtf8().data() );\n  }\n\n  ret = eb_forward_text( &book, &appendix );\n  while( ret == EB_ERR_END_OF_CONTENT )\n  {\n    ret = eb_tell_text( &book, &startPos );\n    if( ret != EB_SUCCESS )\n      break;\n\n    if( startPos.page >= book.subbook_current->text.end_page )\n      return EB_ERR_END_OF_CONTENT;\n\n    startPos.offset += 2;\n    currentPosition = startPos;\n\n    ret = eb_seek_text( &book, &startPos );\n\n    if( ret == EB_SUCCESS )\n      ret = eb_forward_text( &book, &appendix );\n  }\n  return ret;\n}\n\nvoid EpwingBook::getFirstHeadword( EpwingHeadword & head )\n{\n  error_string.clear();\n\n  EB_Position pos;\n\n  EB_Error_Code ret = eb_text( &book, &pos );\n  if( ret != EB_SUCCESS )\n  {\n    setErrorString( \"eb_text\", ret );\n    throw exEbLibrary( error_string.toUtf8().data() );\n  }\n\n  ret = forwardText( pos );\n  if( ret != EB_SUCCESS )\n  {\n    setErrorString( \"forwardText\", ret );\n    throw exEbLibrary( error_string.toUtf8().data() );\n  }\n\n  eb_backward_text( &book, &appendix );\n\n  ret = eb_tell_text( &book, &pos );\n  if( ret != EB_SUCCESS )\n  {\n    setErrorString( \"eb_tell_text\", ret );\n    throw exEbLibrary( error_string.toUtf8().data() );\n  }\n\n  currentPosition = pos;\n  indexHeadwordsPosition = pos;\n\n  head.page = pos.page;\n  head.offset = pos.offset;\n\n  if( !readHeadword( pos, head.headword, true ) )\n    throw exEbLibrary( error_string.toUtf8().data() );\n\n  fixHeadword( head.headword );\n\n  EWPos epos( pos.page, pos.offset );\n  allHeadwordPositions[ head.headword ] << epos;\n}\n\nbool EpwingBook::getNextHeadword( EpwingHeadword & head )\n{\n  EB_Position pos;\n\n  QRegExp badLinks( \"#(v|n)\\\\d\" );\n\n  // At first we check references queue\n  while( !LinksQueue.isEmpty() )\n  {\n    EWPos epos = LinksQueue.last();\n    LinksQueue.pop_back();\n\n    pos.page = epos.first;\n    pos.offset = epos.second;\n\n    if( readHeadword( pos, head.headword, true ) )\n    {\n      if( head.headword.isEmpty()\n          || head.headword.contains( badLinks ) )\n        continue;\n\n      fixHeadword( head.headword );\n\n      head.page = pos.page;\n      head.offset = pos.offset;\n\n      if( allHeadwordPositions.contains( head.headword ) )\n      {\n        // existed position\n        bool existed = false;\n        foreach( EWPos epos, allHeadwordPositions[ head.headword ] )\n        {\n          if( pos.page == epos.first && abs( pos.offset - epos.second ) <= 4 )\n          {\n            existed = true;\n            break;\n          }\n        }\n        if( !existed )\n        {\n          allHeadwordPositions[ head.headword ] << EWPos( pos.page, pos.offset );\n          return true;\n        }\n      }\n      else\n      {\n        allHeadwordPositions[ head.headword ] << EWPos( pos.page, pos.offset );\n        return true;\n      }\n    }\n  }\n\n  // No queued positions - forward to next article\n\n  error_string.clear();\n\n  pos = indexHeadwordsPosition;\n\n  for( ; ; )\n  {\n    EB_Error_Code ret = forwardText( pos );\n    indexHeadwordsPosition = pos;\n\n    if( ret == EB_ERR_END_OF_CONTENT )\n      return false;\n    else\n    if( ret != EB_SUCCESS )\n    {\n      setErrorString( \"eb_forward_text\", ret );\n      throw exEbLibrary( error_string.toUtf8().data() );\n    }\n\n    ret = eb_tell_text( &book, &pos );\n    if( ret != EB_SUCCESS )\n    {\n      setErrorString( \"eb_tell_text\", ret );\n      throw exEbLibrary( error_string.toUtf8().data() );\n    }\n\n    indexHeadwordsPosition = pos;\n\n    try\n    {\n      getReferencesFromText( pos.page, pos.offset );\n    }\n    catch( std::exception & )\n    {\n    }\n\n    head.page = pos.page;\n    head.offset = pos.offset;\n\n    if( !readHeadword( pos, head.headword, true ) )\n      throw exEbLibrary( error_string.toUtf8().data() );\n\n    if( head.headword.isEmpty() )\n      continue;\n\n    fixHeadword( head.headword );\n\n    if( allHeadwordPositions.contains( head.headword ) )\n    {\n      // existed position\n      bool existed = false;\n      foreach( EWPos epos, allHeadwordPositions[ head.headword ] )\n      {\n        if( pos.page == epos.first && abs( pos.offset - epos.second ) <= 4 )\n        {\n          existed = true;\n          break;\n        }\n      }\n      if( !existed )\n      {\n        allHeadwordPositions[ head.headword ] << EWPos( pos.page, pos.offset );\n        return true;\n      }\n    }\n    else\n    {\n      allHeadwordPositions[ head.headword ] << EWPos( pos.page, pos.offset );\n      return true;\n    }\n  }\n\n  return true;\n}\n\nbool EpwingBook::readHeadword( EB_Position const& pos,\n                               QString & headword,\n                               bool text_only )\n{\n  EContainer container( this, text_only );\n  ssize_t head_length;\n\n  EB_Position newPos = pos;\n\n  EB_Error_Code ret = eb_seek_text( &book, &newPos );\n  if( ret != EB_SUCCESS )\n  {\n    setErrorString( \"eb_seek_text\", ret );\n    return false;\n  }\n\n  char buffer[ TextBufferSize + 1 ];\n\n  ret = eb_read_heading( &book, &appendix, &hookSet, &container,\n                         TextBufferSize, buffer, &head_length );\n  if( ret != EB_SUCCESS )\n  {\n    setErrorString( \"eb_read_heading\", ret );\n    return false;\n  }\n\n  headword = QString::fromUtf8( buffer, head_length );\n  return true;\n}\n\nbool EpwingBook::isHeadwordCorrect( QString const & headword )\n{\n  QByteArray buf, buf2;\n  EB_Hit hits[ 2 ];\n  int hit_count;\n  EB_Error_Code ret;\n\n  if( headword.isEmpty() )\n    return false;\n\n  if( book.character_code == EB_CHARCODE_ISO8859_1 && codec_ISO )\n    buf = codec_ISO->fromUnicode( headword );\n  else\n  if( ( book.character_code == EB_CHARCODE_JISX0208 || book.character_code == EB_CHARCODE_JISX0208_GB2312 )\n      && codec_Euc )\n    buf = codec_Euc->fromUnicode( headword );\n\n  if( book.character_code == EB_CHARCODE_JISX0208_GB2312 && codec_GB )\n    buf2 = codec_GB->fromUnicode( headword );\n\n  if( !buf.isEmpty() && eb_search_exactword( &book, buf.data() ) == EB_SUCCESS )\n  {\n    ret = eb_hit_list( &book, 2, hits, &hit_count );\n    if( ret == EB_SUCCESS && hit_count > 0 )\n      return true;\n  }\n\n  if( !buf2.isEmpty() && eb_search_exactword( &book, buf2.data() ) == EB_SUCCESS )\n  {\n    ret = eb_hit_list( &book, 2, hits, &hit_count );\n    if( ret == EB_SUCCESS && hit_count > 0 )\n      return true;\n  }\n\n  return false;\n}\n\nvoid EpwingBook::fixHeadword( QString & headword )\n{\n  if(headword.isEmpty() )\n    return;\n\n  headword.remove( QChar( 0x30FB ) ); // Used in Japan transcription\n\n  if( isHeadwordCorrect( headword) )\n    return;\n\n  QString fixed = headword;\n  fixed.remove( QRegExp( \"/[^/]+/\", Qt::CaseSensitive ) );\n\n  if( isHeadwordCorrect( fixed ) )\n  {\n    headword = fixed;\n    return;\n  }\n\n  gd::wstring folded = Folding::applyPunctOnly( gd::toWString( fixed ) );\n  fixed = gd::toQString( folded );\n\n  if( isHeadwordCorrect( fixed ) )\n  {\n    headword = fixed;\n    return;\n  }\n\n  folded = Folding::applyDiacriticsOnly( folded );\n  fixed = gd::toQString( folded );\n\n  if( isHeadwordCorrect( fixed ) )\n  {\n    headword = fixed;\n    return;\n  }\n\n  folded = Folding::applyWhitespaceOnly( folded );\n  fixed = gd::toQString( folded );\n\n  if( isHeadwordCorrect( fixed ) )\n    headword = fixed;\n}\n\nvoid EpwingBook::getArticle( QString & headword, QString & articleText,\n                             int page, int offset, bool text_only)\n{\n  error_string.clear();\n  char buffer[ TextBufferSize + 1 ];\n\n  EB_Position pos;\n  pos.page = page;\n  pos.offset = offset;\n\n  currentPosition = pos;\n\n  EB_Error_Code ret = eb_seek_text( &book, &pos );\n  if( ret != EB_SUCCESS )\n  {\n    setErrorString( \"eb_seek_text\", ret );\n    throw exEbLibrary( error_string.toUtf8().data() );\n  }\n\n  EContainer container( this, text_only );\n  ssize_t length;\n\n  prepareToRead();\n\n  ret = eb_read_heading( &book, &appendix, &hookSet, &container,\n                         TextBufferSize, buffer, &length );\n  if( ret != EB_SUCCESS )\n  {\n    setErrorString( \"eb_read_heading\", ret );\n    throw exEbLibrary( error_string.toUtf8().data() );\n  }\n\n  headword = QString::fromUtf8( buffer, length );\n  finalizeText( headword );\n\n  if( text_only )\n    fixHeadword( headword );\n\n  articleText = getText( pos.page, pos.offset, text_only );\n}\n\nconst char * EpwingBook::beginDecoration( unsigned int code )\n{\n  const char * str = \"\";\n\n  code = normalizeDecorationCode( code );\n\n  switch( code )\n  {\n    case ITALIC:      str = \"<i>\";\n                      break;\n    case BOLD:        str = \"<b>\";\n                      break;\n    case EMPHASIS:    str = \"<em>\";\n                      break;\n    case SUBSCRIPT:   str = \"<sub>\";\n                      break;\n    case SUPERSCRIPT: str = \"<sup>\";\n                      break;\n    default:          gdWarning( \"Epwing: Unknown decoration code %i\", code );\n                      code = UNKNOWN;\n                      break;\n  }\n  decorationStack.push( code );\n  return str;\n}\n\nconst char * EpwingBook::endDecoration( unsigned int code )\n{\n  const char * str = \"\";\n\n  code = normalizeDecorationCode( code );\n\n  if( code != ITALIC && code != BOLD && code != EMPHASIS\n      && code != SUBSCRIPT && code != SUPERSCRIPT )\n    code = UNKNOWN;\n\n  unsigned int storedCode = UNKNOWN;\n  if( !decorationStack.isEmpty() )\n    storedCode = decorationStack.pop();\n\n  if( storedCode != code )\n  {\n    gdWarning( \"Epwing: tags mismatch detected\" );\n    if( storedCode == UNKNOWN )\n      storedCode = code;\n  }\n\n  switch( storedCode )\n  {\n    case ITALIC:      str = \"</i>\";\n                      break;\n    case BOLD:        str = \"</b>\";\n                      break;\n    case EMPHASIS:    str = \"</em>\";\n                      break;\n    case SUBSCRIPT:   str = \"</sub>\";\n                      break;\n    case SUPERSCRIPT: str = \"</sup>\";\n                      break;\n    case UNKNOWN:     break;\n  }\n\n  return str;\n}\n\nunsigned int EpwingBook::normalizeDecorationCode( unsigned int code )\n{\n  // Some non-standard codes\n  switch( code )\n  {\n    case 0x1101: return BOLD;\n    case 0x1103: return ITALIC;\n  }\n  return code;\n}\n\nvoid EpwingBook::finalizeText( QString & text )\n{\n  // Close unclosed tags\n  while( !decorationStack.isEmpty() )\n  {\n    unsigned int code = decorationStack.pop();\n    switch( code )\n    {\n      case ITALIC:      text += \"</i>\";\n                        break;\n      case BOLD:        text += \"</b>\";\n                        break;\n      case EMPHASIS:    text += \"</em>\";\n                        break;\n      case SUBSCRIPT:   text += \"</sub>\";\n                        break;\n      case SUPERSCRIPT: text += \"</sup>\";\n                        break;\n    }\n  }\n\n  // Replace references\n\n  int pos = 0;\n  QRegExp reg1( \"<R[^<]*>\" );\n  QRegExp reg2( \"</R[^<]*>\" );\n\n  EContainer cont( this, true );\n\n  char buf[ TextBufferSize + 1 ];\n\n  for( int x = 0; x < refCloseCount; x++ )\n  {\n    pos = text.indexOf( reg1, pos );\n    if( pos < 0 )\n      break;\n\n    EB_Position ebpos;\n    ebpos.page = refPages[ x ];\n    ebpos.offset = refOffsets[ x ];\n\n    QUrl url;\n    url.setScheme( \"gdlookup\" );\n    url.setHost( \"localhost\" );\n\n    // Read headword\n\n    eb_seek_text( &book, &ebpos );\n\n    ssize_t length;\n    EB_Error_Code ret = eb_read_heading( &book, &appendix, &hookSet, &cont,\n                                         TextBufferSize, buf, &length );\n    if( ret == EB_SUCCESS )\n    {\n      QString headword = QString::fromUtf8( buf, length );\n      fixHeadword( headword );\n      url.setPath( Qt4x5::Url::ensureLeadingSlash( headword ) );\n    }\n\n    QString link = \"<a href=\\\"\" + url.toEncoded() + \"\\\">\";\n\n    text.replace( reg1.cap(), link );\n\n    pos = text.indexOf( reg2, pos );\n    if( pos < 0 )\n      break;\n\n    text.replace( reg2.cap(), \"</a>\" );\n  }\n}\n\nvoid EpwingBook::prepareToRead()\n{\n  refPages.clear();\n  refOffsets.clear();\n  refOpenCount = refCloseCount = 0;\n}\n\nQByteArray EpwingBook::handleColorImage( EB_Hook_Code code,\n                                         const unsigned int * argv )\n{\n  QString name, fullName;\n  EB_Position pos;\n\n  if( code == EB_HOOK_END_COLOR_GRAPHIC\n      || code == EB_HOOK_END_IN_COLOR_GRAPHIC )\n    return QByteArray();\n\n  pos.page = argv[ 2 ];\n  pos.offset = argv[ 3 ];\n\n  EB_Error_Code ret = eb_set_binary_color_graphic( &book, & pos );\n  if( ret != EB_SUCCESS )\n  {\n    setErrorString( \"eb_set_binary_color_graphic\", ret );\n    gdWarning( \"Epwing image retrieve error: %s\",\n               error_string.toUtf8().data() );\n    return QByteArray();\n  }\n\n  if( cacheImagesDir.isEmpty() )\n    cacheImagesDir = createCacheDir( \"images\" );\n\n  if( code == EB_HOOK_BEGIN_COLOR_BMP\n      || code == EB_HOOK_BEGIN_IN_COLOR_BMP )\n    name = makeFName( \"bmp\", pos.page, pos.offset );\n  else\n  if( code == EB_HOOK_BEGIN_COLOR_JPEG\n      || code == EB_HOOK_BEGIN_IN_COLOR_JPEG )\n    name = makeFName( \"jpg\", pos.page, pos.offset );\n\n  if( !cacheImagesDir.isEmpty() )\n    fullName = cacheImagesDir + QDir::separator() + name;\n\n  QUrl url;\n  url.setScheme( \"bres\" );\n  url.setHost( dictID );\n  url.setPath( Qt4x5::Url::ensureLeadingSlash( name ) );\n  QByteArray urlStr = \"<p class=\\\"epwing_image\\\"><img src=\\\"\" + url.toEncoded()\n                      + \"\\\" alt=\\\"\" + name.toUtf8() + \"\\\"></p>\";\n\n  if( imageCacheList.contains( name, Qt::CaseSensitive ) )\n  {\n    // We already have this image in cache\n    return urlStr;\n  }\n\n  if( !fullName.isEmpty() )\n  {\n    QFile f( fullName );\n    if( f.open( QFile::WriteOnly ) )\n    {\n      QByteArray buffer;\n      buffer.resize( BinaryBufferSize );\n      ssize_t length;\n\n      for( ; ; )\n      {\n        ret = eb_read_binary( &book, BinaryBufferSize,\n                              buffer.data(), &length );\n        if( ret != EB_SUCCESS )\n        {\n          setErrorString( \"eb_read_binary\", ret );\n          gdWarning( \"Epwing image retrieve error: %s\",\n                     error_string.toUtf8().data() );\n          break;\n        }\n\n        f.write( buffer.data(), length );\n\n        if( length < BinaryBufferSize )\n          break;\n      }\n      f.close();\n\n      imageCacheList.append( name );\n    }\n  }\n\n  return urlStr;\n}\n\nQByteArray EpwingBook::handleMonoImage( EB_Hook_Code code,\n                                        const unsigned int * argv )\n{\n  QString name, fullName;\n  EB_Position pos;\n\n  if( code == EB_HOOK_BEGIN_MONO_GRAPHIC )\n  {\n    monoHeight = argv[ 2 ];\n    monoWidth = argv[ 3 ];\n    return QByteArray();\n  }\n\n  // Handle EB_HOOK_END_MONO_GRAPHIC hook\n\n  pos.page = argv[ 1 ];\n  pos.offset = argv[ 2 ];\n\n  EB_Error_Code ret = eb_set_binary_mono_graphic( &book, &pos, monoWidth, monoHeight );\n  if( ret != EB_SUCCESS )\n  {\n    setErrorString( \"eb_set_binary_mono_graphic\", ret );\n    gdWarning( \"Epwing image retrieve error: %s\",\n               error_string.toUtf8().data() );\n    return QByteArray();\n  }\n\n  if( cacheImagesDir.isEmpty() )\n    cacheImagesDir = createCacheDir( \"images\" );\n\n  name = makeFName( \"bmp\", pos.page, pos.offset );\n\n  if( !cacheImagesDir.isEmpty() )\n    fullName = cacheImagesDir + QDir::separator() + name;\n\n  QUrl url;\n  url.setScheme( \"bres\" );\n  url.setHost( dictID );\n  url.setPath( Qt4x5::Url::ensureLeadingSlash( name ) );\n  QByteArray urlStr = \"<span class=\\\"epwing_image\\\"><img src=\\\"\" + url.toEncoded()\n                      + \"\\\" alt=\\\"\" + name.toUtf8() + \"\\\"/></span>\";\n\n  if( imageCacheList.contains( name, Qt::CaseSensitive ) )\n  {\n    // We already have this image in cache\n    return urlStr;\n  }\n\n  if( !fullName.isEmpty() )\n  {\n    QFile f( fullName );\n    if( f.open( QFile::WriteOnly | QFile::Truncate ) )\n    {\n      QByteArray buffer;\n      buffer.resize( BinaryBufferSize );\n      ssize_t length;\n\n      for( ; ; )\n      {\n        ret = eb_read_binary( &book, BinaryBufferSize,\n                              buffer.data(), &length );\n        if( ret != EB_SUCCESS )\n        {\n          setErrorString( \"eb_read_binary\", ret );\n          gdWarning( \"Epwing image retrieve error: %s\",\n                     error_string.toUtf8().data() );\n          break;\n        }\n\n        f.write( buffer.data(), length );\n\n        if( length < BinaryBufferSize )\n          break;\n      }\n      f.close();\n\n      imageCacheList.append( name );\n    }\n  }\n\n  return urlStr;\n}\n\nQByteArray EpwingBook::handleWave( EB_Hook_Code code, const unsigned int * argv )\n{\n\n  if( code == EB_HOOK_END_WAVE )\n    return QByteArray( \"<img src=\\\"qrcx://localhost/icons/playsound.png\\\" border=\\\"0\\\" align=\\\"absmiddle\\\" alt=\\\"Play\\\"/></a></span>\" );\n\n  // Handle EB_HOOK_BEGIN_WAVE\n\n  EB_Position spos, epos;\n  spos.page = argv[ 2 ];\n  spos.offset = argv[ 3 ];\n  epos.page = argv[ 4 ];\n  epos.offset = argv[ 5 ];\n\n  eb_set_binary_wave( &book, &spos, &epos );\n\n  if( cacheSoundsDir.isEmpty() )\n    cacheSoundsDir = createCacheDir( \"sounds\" );\n\n  QString name = makeFName( \"wav\", spos.page, spos.offset );\n  QString fullName;\n\n  if( !cacheSoundsDir.isEmpty() )\n    fullName = cacheSoundsDir + QDir::separator() + name;\n\n  QUrl url;\n  url.setScheme( \"gdau\" );\n  url.setHost( dictID );\n  url.setPath( Qt4x5::Url::ensureLeadingSlash( name ) );\n\n  string ref = string( \"\\\"\" )+ url.toEncoded().data() + \"\\\"\";\n  QByteArray result = addAudioLink( ref , dictID.toUtf8().data() ).c_str();\n\n  result += QByteArray( \"<span class=\\\"epwing_wav\\\"><a href=\" ) + ref.c_str() + \">\";\n\n  if( soundsCacheList.contains( name, Qt::CaseSensitive ) )\n  {\n    // We already have this sound in cache\n    return result;\n  }\n\n  if( !fullName.isEmpty() )\n  {\n    QFile f( fullName );\n    if( f.open( QFile::WriteOnly | QFile::Truncate ) )\n    {\n      QByteArray buffer;\n      buffer.resize( BinaryBufferSize );\n      ssize_t length;\n\n      for( ; ; )\n      {\n        EB_Error_Code ret = eb_read_binary( &book, BinaryBufferSize,\n                                            buffer.data(), &length );\n        if( ret != EB_SUCCESS )\n        {\n          setErrorString( \"eb_read_binary\", ret );\n          gdWarning( \"Epwing sound retrieve error: %s\",\n                     error_string.toUtf8().data() );\n          break;\n        }\n\n        f.write( buffer.data(), length );\n\n        if( length < BinaryBufferSize )\n          break;\n      }\n      f.close();\n\n      soundsCacheList.append( name );\n    }\n  }\n  return result;\n}\n\nQByteArray EpwingBook::handleMpeg( EB_Hook_Code code, const unsigned int * argv )\n{\n\n  if( code == EB_HOOK_END_MPEG )\n    return QByteArray( \"</a></span>\" );\n\n  // Handle EB_HOOK_BEGIN_MPEG\n\n  char file[ EB_MAX_PATH_LENGTH + 1 ];\n\n  unsigned int *p = (unsigned int *)( argv + 2 );\n  eb_compose_movie_path_name( &book, p, file );\n\n  QString name = QString::fromLocal8Bit( file );\n  name = QFileInfo( name ).fileName();\n  name += \".mpg\";\n\n  eb_set_binary_mpeg( &book, argv + 2 );\n\n  if( cacheMoviesDir.isEmpty() )\n    cacheMoviesDir = createCacheDir( \"movies\" );\n\n  QString fullName;\n\n  if( !cacheMoviesDir.isEmpty() )\n    fullName = cacheMoviesDir + QDir::separator() + name;\n\n  QUrl url;\n  url.setScheme( \"gdvideo\" );\n  url.setHost( dictID );\n  url.setPath( Qt4x5::Url::ensureLeadingSlash( name ) );\n\n  QByteArray result = QByteArray( \"<span class=\\\"epwing_mpeg\\\"><a href=\" ) + url.toEncoded() + \">\";\n\n  if( moviesCacheList.contains( name, Qt::CaseSensitive ) )\n  {\n    // We already have this movie in cache\n    return result;\n  }\n\n  if( !fullName.isEmpty() )\n  {\n    QFile f( fullName );\n    if( f.open( QFile::WriteOnly | QFile::Truncate ) )\n    {\n      QByteArray buffer;\n      buffer.resize( BinaryBufferSize );\n      ssize_t length;\n\n      for( ; ; )\n      {\n        EB_Error_Code ret = eb_read_binary( &book, BinaryBufferSize,\n                                            buffer.data(), &length );\n        if( ret != EB_SUCCESS )\n        {\n          setErrorString( \"eb_read_binary\", ret );\n          gdWarning( \"Epwing movie retrieve error: %s\",\n                     error_string.toUtf8().data() );\n          break;\n        }\n\n        f.write( buffer.data(), length );\n\n        if( length < BinaryBufferSize )\n          break;\n      }\n      f.close();\n\n      moviesCacheList.append( name );\n    }\n  }\n  return result;\n}\n\nQByteArray EpwingBook::codeToUnicode( QString const & code )\n{\n  QString subst;\n\n  if( !customFontsMap.isEmpty() && customFontsMap.contains( code ) )\n  {\n    subst = QTextDocumentFragment::fromHtml( customFontsMap[ code ] )\n                                   .toPlainText();\n    return subst.toUtf8();\n  }\n\n  return EpwingCharmap::instance().mapToUtf8( code );\n}\n\nQByteArray EpwingBook::handleNarrowFont( const unsigned int * argv,\n                                         bool text_only )\n{\n  QString fcode = \"n\" + QString::number( *argv, 16 );\n\n  // Check substitution list\n\n  QByteArray b = codeToUnicode( fcode );\n  if( !b.isEmpty() || text_only )\n    return b;\n\n  // Find font image in book\n\n  if( !eb_have_narrow_font( &book ) )\n    return QByteArray( \"?\" );\n\n  QString fname = fcode + \".png\";\n\n  if( cacheFontsDir.isEmpty() )\n    cacheFontsDir = createCacheDir( \"fonts\" );\n\n  QString fullName = cacheFontsDir + QDir::separator() + fname;\n\n  QUrl url;\n  url.setScheme( \"file\" );\n  url.setHost( \"/\");\n  url.setPath( Qt4x5::Url::ensureLeadingSlash( QDir::fromNativeSeparators( fullName ) ) );\n\n  QByteArray link = \"<img class=\\\"epwing_narrow_font\\\" src=\\\"\" + url.toEncoded() + \"\\\"/>\";\n\n  if( fontsCacheList.contains( fname, Qt::CaseSensitive ) )\n  {\n    // We already have this image in cache\n    return link;\n  }\n\n  if( !cacheFontsDir.isEmpty() )\n  {\n    char bitmap[EB_SIZE_NARROW_FONT_16];\n    EB_Error_Code ret = eb_narrow_font_character_bitmap( &book, *argv, bitmap );\n    if( ret != EB_SUCCESS )\n    {\n      setErrorString( \"eb_narrow_font_character_bitmap\", ret );\n      gdWarning( \"Epwing: Font retrieve error: %s\", error_string.toUtf8().data() );\n      return QByteArray( \"?\" );\n    }\n\n      size_t nlen;\n      char buff[EB_SIZE_NARROW_FONT_16_PNG];\n      ret = eb_bitmap_to_png( bitmap, 8, 16, buff, &nlen );\n      if( ret != EB_SUCCESS )\n      {\n        setErrorString( \"eb_bitmap_to_png\", ret );\n        gdWarning( \"Epwing: Font retrieve error: %s\", error_string.toUtf8().data() );\n        return QByteArray( \"?\" );\n      }\n\n\n    QFile f( fullName );\n    if( f.open( QFile::WriteOnly | QFile::Truncate ) )\n    {\n      f.write( buff, nlen );\n      f.close();\n      fontsCacheList.append( fname );\n    }\n  }\n\n  return link;\n}\n\nQByteArray EpwingBook::handleWideFont( const unsigned int * argv,\n                                       bool text_only )\n{\n  QString fcode = \"w\" + QString::number( *argv, 16 );\n\n  // Check substitution list\n\n  QByteArray b = codeToUnicode( fcode );\n  if( !b.isEmpty() || text_only )\n    return b;\n\n  // Find font image in book\n\n  if( !eb_have_wide_font( &book ) )\n    return QByteArray( \"?\" );\n\n  QString fname = fcode + \".png\";\n\n  if( cacheFontsDir.isEmpty() )\n    cacheFontsDir = createCacheDir( \"fonts\" );\n\n  QString fullName = cacheFontsDir + QDir::separator() + fname;\n\n  QUrl url;\n  url.setScheme( \"file\" );\n  url.setHost( \"/\");\n  url.setPath( Qt4x5::Url::ensureLeadingSlash( QDir::fromNativeSeparators( fullName ) ) );\n\n  QByteArray link = \"<img class=\\\"epwing_wide_font\\\" src=\\\"\" + url.toEncoded() + \"\\\"/>\";\n\n  if( fontsCacheList.contains( fname, Qt::CaseSensitive ) )\n  {\n    // We already have this image in cache\n    return link;\n  }\n\n  if( !cacheFontsDir.isEmpty() )\n  {\n    char bitmap[EB_SIZE_WIDE_FONT_16];\n    EB_Error_Code ret = eb_wide_font_character_bitmap( &book, *argv, bitmap );\n    if( ret != EB_SUCCESS )\n    {\n      setErrorString( \"eb_wide_font_character_bitmap\", ret );\n      gdWarning( \"Epwing: Font retrieve error: %s\", error_string.toUtf8().data() );\n      return QByteArray( \"?\" );\n    }\n\n    size_t wlen;\n    char buff[EB_SIZE_WIDE_FONT_16_PNG];\n    ret = eb_bitmap_to_png( bitmap, 16, 16, buff, &wlen );\n    if( ret != EB_SUCCESS )\n    {\n      setErrorString( \"eb_bitmap_to_png\", ret );\n      gdWarning( \"Epwing: Font retrieve error: %s\", error_string.toUtf8().data() );\n      return QByteArray( \"?\" );\n    }\n\n    QFile f( fullName );\n    if( f.open( QFile::WriteOnly | QFile::Truncate ) )\n    {\n      f.write( buff, wlen );\n      f.close();\n      fontsCacheList.append( fname );\n    }\n  }\n\n  return link;\n}\n\nQByteArray EpwingBook::handleReference( EB_Hook_Code code, const unsigned int * argv )\n{\n  if( code == EB_HOOK_BEGIN_REFERENCE )\n  {\n    if( refOpenCount > refCloseCount )\n      return QByteArray();\n\n    QString str = QString( \"<R%1>\" ).arg( refOpenCount );\n    refOpenCount += 1;\n    return str.toUtf8();\n  }\n\n  // EB_HOOK_END_REFERENCE\n\n  if( refCloseCount >= refOpenCount )\n    return QByteArray();\n\n  refPages.append( argv[ 1 ] );\n  refOffsets.append( argv[ 2 ] );\n\n  QString str = QString( \"</R%1>\").arg( refCloseCount );\n  refCloseCount += 1;\n\n  return str.toUtf8();\n}\n\nbool EpwingBook::getMatches( QString word, QVector< QString > & matches )\n{\n  QByteArray bword, bword2;\n  EB_Hit hits[ HitsBufferSize ];\n  int hitCount = 0;\n\n  if( book.character_code == EB_CHARCODE_ISO8859_1 && codec_ISO )\n    bword = codec_ISO->fromUnicode( word );\n  else\n  if( ( book.character_code == EB_CHARCODE_JISX0208 || book.character_code == EB_CHARCODE_JISX0208_GB2312 )\n      && codec_Euc )\n    bword = codec_Euc->fromUnicode( word );\n\n  if( book.character_code == EB_CHARCODE_JISX0208_GB2312 && codec_GB )\n    bword2 = codec_GB->fromUnicode( word );\n\n  if( !bword.isEmpty() )\n  {\n    EB_Error_Code ret = eb_search_word( &book, bword.data() );\n    if( ret != EB_SUCCESS )\n    {\n      setErrorString( \"eb_search_word\", ret );\n      gdWarning( \"Epwing word search error: %s\",\n                   error_string.toUtf8().data() );\n      return false;\n    }\n\n    ret = eb_hit_list( &book, 10, hits, &hitCount );\n    if( ret != EB_SUCCESS )\n    {\n      setErrorString( \"eb_hit_list\", ret );\n      gdWarning( \"Epwing word search error: %s\",\n                   error_string.toUtf8().data() );\n      return false;\n    }\n  }\n\n  if( hitCount == 0 && !bword2.isEmpty() )\n  {\n    EB_Error_Code ret = eb_search_word( &book, bword2.data() );\n    if( ret != EB_SUCCESS )\n    {\n      setErrorString( \"eb_search_word\", ret );\n      gdWarning( \"Epwing word search error: %s\",\n                   error_string.toUtf8().data() );\n      return false;\n    }\n\n    ret = eb_hit_list( &book, 10, hits, &hitCount );\n    if( ret != EB_SUCCESS )\n    {\n      setErrorString( \"eb_hit_list\", ret );\n      gdWarning( \"Epwing word search error: %s\",\n                   error_string.toUtf8().data() );\n      return false;\n    }\n  }\n\n  QVector< int > pages, offsets;\n\n  for( int i = 0; i < hitCount; i++ )\n  {\n    bool same_article = false;\n    for( int n = 0; n < pages.size(); n++ )\n    {\n      if( pages.at( n ) == hits[ i ].text.page\n          && offsets.at( n ) == hits[ i ].text.offset )\n      {\n        same_article = true;\n        continue;\n      }\n    }\n    if( !same_article )\n    {\n      pages.push_back( hits[ i ].text.page );\n      offsets.push_back( hits[ i ].text.offset );\n\n      QString headword;\n      if( readHeadword( hits[ i ].heading, headword, true ) )\n      {\n        if( isHeadwordCorrect( headword ) )\n          matches.push_back( headword );\n      }\n    }\n  }\n  return true;\n}\n\nbool EpwingBook::getArticlePos( QString word, QVector< int > & pages, QVector< int > & offsets )\n{\n  QByteArray bword, bword2;\n  EB_Hit hits[ HitsBufferSize ];\n  int hitCount = 0;\n\n  if( book.character_code == EB_CHARCODE_ISO8859_1 && codec_ISO )\n    bword = codec_ISO->fromUnicode( word );\n  else\n  if( ( book.character_code == EB_CHARCODE_JISX0208 || book.character_code == EB_CHARCODE_JISX0208_GB2312 )\n      && codec_Euc )\n    bword = codec_Euc->fromUnicode( word );\n\n  if( book.character_code == EB_CHARCODE_JISX0208_GB2312 && codec_GB )\n    bword2 = codec_GB->fromUnicode( word );\n\n  if( !bword.isEmpty() )\n  {\n    EB_Error_Code ret = eb_search_exactword( &book, bword.data() );\n    if( ret != EB_SUCCESS )\n    {\n      setErrorString( \"eb_search_word\", ret );\n      gdWarning( \"Epwing word search error: %s\",\n                   error_string.toUtf8().data() );\n      return false;\n    }\n\n    ret = eb_hit_list( &book, HitsBufferSize, hits, &hitCount );\n    if( ret != EB_SUCCESS )\n    {\n      setErrorString( \"eb_hit_list\", ret );\n      gdWarning( \"Epwing word search error: %s\",\n                   error_string.toUtf8().data() );\n      return false;\n    }\n  }\n\n  if( hitCount == 0 && !bword2.isEmpty() )\n  {\n    EB_Error_Code ret = eb_search_exactword( &book, bword2.data() );\n    if( ret != EB_SUCCESS )\n    {\n      setErrorString( \"eb_search_word\", ret );\n      gdWarning( \"Epwing word search error: %s\",\n                   error_string.toUtf8().data() );\n      return false;\n    }\n\n    ret = eb_hit_list( &book, HitsBufferSize, hits, &hitCount );\n    if( ret != EB_SUCCESS )\n    {\n      setErrorString( \"eb_hit_list\", ret );\n      gdWarning( \"Epwing word search error: %s\",\n                   error_string.toUtf8().data() );\n      return false;\n    }\n  }\n\n  for( int i = 0; i < hitCount; i++ )\n  {\n    bool same_article = false;\n    for( int n = 0; n < pages.size(); n++ )\n    {\n      if( pages.at( n ) == hits[ i ].text.page\n          && offsets.at( n ) == hits[ i ].text.offset )\n      {\n        same_article = true;\n        continue;\n      }\n    }\n    if( !same_article )\n    {\n      pages.push_back( hits[ i ].text.page );\n      offsets.push_back( hits[ i ].text.offset );\n    }\n  }\n\n  return !pages.empty();\n}\n\nMutex EpwingBook::libMutex;\n\n} // namespace Book\n\n} // namespace Epwing\n"
        },
        {
          "name": "epwing_book.hh",
          "type": "blob",
          "size": 5.5576171875,
          "content": "#ifndef __EPWING_BOOK_HH_INCLUDED__\n#define __EPWING_BOOK_HH_INCLUDED__\n\n#include <qglobal.h>\n\n#if defined( Q_OS_WIN32 ) || defined( Q_OS_MAC )\n#define _FILE_OFFSET_BITS 64\n#endif\n\n#include \"dictionary.hh\"\n#include \"ex.hh\"\n#include \"mutex.hh\"\n\n#include <QString>\n#include <QTextCodec>\n#include <QMap>\n#include <QVector>\n#include <vector>\n#include <string>\n\n#ifdef _MSC_VER\n#include <stub_msvc.h>\n#endif\n\n#include <eb/eb.h>\n\nnamespace Epwing {\n\nDEF_EX_STR( exEbLibrary, \"EB library report error\", Dictionary::Ex )\nDEF_EX_STR( exEpwing, \"Epwing parsing error:\", Dictionary::Ex )\n\nvoid initialize();\nvoid finalize();\n\nnamespace Book {\n\nusing std::vector;\nusing std::string;\n\nenum {\n  TextBufferSize = 4095,\n  BinaryBufferSize = 50000,\n  TextSizeLimit = 2800000\n};\n\nstruct EpwingHeadword\n{\n  QString headword;\n  quint32 page;\n  quint32 offset;\n};\n\nclass EpwingBook\n{\n  typedef QPair< int, int > EWPos;\n\n  void setErrorString( QString const & func, EB_Error_Code code );\n\n  EB_Book book;\n  EB_Appendix appendix;\n  EB_Hookset hookSet, refHookSet;\n  EB_Subbook_Code subBookList[ EB_MAX_SUBBOOKS ];\n  EB_Subbook_Code subAppendixList[ EB_MAX_SUBBOOKS ];\n  EB_Position currentPosition, indexHeadwordsPosition;\n  int subBookCount, subAppendixCount;\n  int currentSubBook;\n  QString error_string;\n  QString mainCacheDir, rootDir;\n  QString cacheImagesDir, cacheSoundsDir, cacheMoviesDir, cacheFontsDir;\n  QString dictID;\n  QTextCodec * codec_ISO, * codec_GB, * codec_Euc;\n  QStack< unsigned int > decorationStack;\n  int monoWidth, monoHeight;\n  QStringList imageCacheList, soundsCacheList, moviesCacheList, fontsCacheList;\n  QMap< QString, QString > baseFontsMap, customFontsMap;\n  QVector< int > refPages, refOffsets;\n  QMap< QString, QList< EWPos > > allHeadwordPositions;\n  QVector< EWPos > LinksQueue;\n  int refOpenCount, refCloseCount;\n  static Mutex libMutex;\n\n  QString createCacheDir( QString const & dir);\n\n  // Close unslosed tags\n  void finalizeText( QString & text );\n\n  // Reset internal variables\n  void prepareToRead();\n\n  // Retrieve references from article\n  void getReferencesFromText( int page, int offset );\n\n  // Move to next article\n  EB_Error_Code forwardText( EB_Position & startPos );\n\n  // Retrieve article text from dictionary\n  QString getText( int page, int offset, bool text_only );\n\n  unsigned int normalizeDecorationCode( unsigned int code );\n\n  QByteArray codeToUnicode( QString const & code );\n\npublic:\n\n  enum DecorationCodes {\n    UNKNOWN = 0,\n    ITALIC = 1,\n    BOLD = 3,\n    EMPHASIS = 4,\n    SUBSCRIPT = 5,\n    SUPERSCRIPT = 6\n  };\n\n  EpwingBook();\n  ~EpwingBook();\n\n  Mutex & getLibMutex()\n  { return libMutex; }\n\n  QString const &errorString() const\n  { return error_string; }\n\n  QTextCodec * codecISO()\n  { return codec_ISO; }\n\n  QTextCodec * codecGB()\n  { return codec_GB; }\n\n  QTextCodec *codecEuc()\n  { return codec_Euc; }\n\n  int getSubBookCount()\n  { return subBookCount; }\n\n  void setDictID( const string & id )\n  { dictID = QString::fromUtf8( id.c_str() ); }\n\n  QString const & getImagesCacheDir()\n  { return cacheImagesDir; }\n\n  QString const & getSoundsCacheDir()\n  { return cacheSoundsDir; }\n\n  QString const & getMoviesCacheDir()\n  { return cacheMoviesDir; }\n\n  void clearBuffers()\n  {\n    allHeadwordPositions.clear();\n    LinksQueue.clear();\n  }\n\n\n  // Make name for resource\n  QString makeFName( QString const & ext, int page, int offset ) const;\n\n  // Store all files in Epwing folder\n  static void collectFilenames( QString const & directory,\n                                vector< string > & files );\n\n  // Initialize dictionary book\n  int setBook( string const & directory );\n\n  // Set subbook inside dictionary\n  bool setSubBook( int book_nom );\n\n  void setCacheDirectory( QString const & cacheDir );\n\n  QString getCurrentSubBookDirectory();\n\n  QString copyright();\n  QString title();\n\n  // Seek to first article\n  void getFirstHeadword( EpwingHeadword & head );\n\n  // Find next headword and article position\n  bool getNextHeadword( EpwingHeadword & head );\n\n  bool readHeadword( EB_Position const & pos,\n                     QString & headword,\n                     bool text_only );\n\n  bool isHeadwordCorrect( QString const & headword );\n\n  void fixHeadword( QString & headword );\n\n  // Retrieve article from dictionary\n  void getArticle( QString & headword, QString & articleText,\n                   int page, int offset, bool text_only );\n\n  const char * beginDecoration( unsigned int code );\n  const char * endDecoration( unsigned int code );\n\n  QByteArray handleColorImage( EB_Hook_Code code,\n                               const unsigned int * argv );\n\n  QByteArray handleMonoImage( EB_Hook_Code code,\n                              const unsigned int * argv );\n\n  QByteArray handleWave( EB_Hook_Code code,\n                         const unsigned int * argv );\n\n  QByteArray handleMpeg( EB_Hook_Code code,\n                         const unsigned int * argv );\n\n  QByteArray handleNarrowFont( const unsigned int * argv,\n                               bool text_only );\n\n  QByteArray handleWideFont( const unsigned int * argv,\n                             bool text_only );\n\n  QByteArray handleReference( EB_Hook_Code code,\n                              const unsigned int * argv );\n\n  bool getMatches( QString word, QVector< QString > & matches );\n\n  bool getArticlePos( QString word, QVector< int > & pages, QVector< int > & offsets );\n};\n\nstruct EContainer\n{\n  EpwingBook * book;\n  bool textOnly;\n\n  EContainer( EpwingBook * book_ ) :\n    book( book_ ),\n    textOnly( false )\n  {}\n\n  EContainer( EpwingBook * book_, bool text_only ) :\n    book( book_ ),\n    textOnly( text_only )\n  {}\n};\n\n\n}\n\n}\n\n\n#endif // __EPWING_BOOK_HH_INCLUDED__\n"
        },
        {
          "name": "epwing_charmap.cc",
          "type": "blob",
          "size": 2.5517578125,
          "content": "/* This file is (c) 2014 Abs62\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"epwing_charmap.hh\"\n\nnamespace Epwing {\n\nEpwingCharmap & EpwingCharmap::instance()\n{\n  static EpwingCharmap ec;\n  return ec;\n}\n\nQByteArray EpwingCharmap::mapToUtf8( QString const & code )\n{\n  if( charMap.contains( code ) )\n    return QString( charMap[ code ] ).toUtf8();\n\n  return QByteArray();\n}\n\nvoid EpwingCharmap::addEntry( QString const & code, QChar ch )\n{\n  charMap[ code ] = ch;\n}\n\nEpwingCharmap::EpwingCharmap()\n{\n  addEntry( \"na121\", 0x00E1 );\n  addEntry( \"na122\", 0x00E0 );\n  addEntry( \"na12a\", 0x01DD );\n  addEntry( \"na12e\", 0x00E9 );\n  addEntry( \"na12f\", 0x00E8 );\n  addEntry( \"na134\", 0x00ED );\n  addEntry( \"na135\", 0x00EC );\n  addEntry( \"na136\", 0x00F3 );\n  addEntry( \"na137\", 0x00F2 );\n  addEntry( \"na13e\", 0x00FA );\n  addEntry( \"na13f\", 0x00F9 );\n  addEntry( \"na143\", 0x00E6 );\n  addEntry( \"na144\", 0x01FD );\n  addEntry( \"na149\", 0x0067 );\n  addEntry( \"na157\", 0x00E9 );\n  addEntry( \"na16a\", 0x00C1 );\n  addEntry( \"na16b\", 0x00C0 );\n  addEntry( \"na16d\", 0x00C9 );\n  addEntry( \"na171\", 0x00FD );\n  addEntry( \"na172\", 0x1EF3 );\n  addEntry( \"na17d\", 0x00DA );\n  addEntry( \"na235\", 0x002F );\n  addEntry( \"na240\", 0x0154 );\n  addEntry( \"na244\", 0x0179 );\n  addEntry( \"na627\", 0x00A7 );\n  addEntry( \"na62b\", 0x00AB );\n  addEntry( \"na637\", 0x30FB );\n  addEntry( \"na63b\", 0x00BB );\n  addEntry( \"na646\", 0x00C6 );\n  addEntry( \"na647\", 0x00C7 );\n  addEntry( \"na649\", 0x00C9 );\n  addEntry( \"na660\", 0x00E0 );\n  addEntry( \"na662\", 0x00E2 );\n  addEntry( \"na664\", 0x00E4 );\n  addEntry( \"na667\", 0x00E7 );\n  addEntry( \"na668\", 0x00E8 );\n  addEntry( \"na669\", 0x00E9 );\n  addEntry( \"na66a\", 0x00EA );\n  addEntry( \"na66b\", 0x00EB );\n  addEntry( \"na66e\", 0x00EE );\n  addEntry( \"na66f\", 0x00EF );\n  addEntry( \"na671\", 0x00F1 );\n  addEntry( \"na674\", 0x00F4 );\n  addEntry( \"na676\", 0x00F6 );\n  addEntry( \"na67b\", 0x00FB );\n  addEntry( \"na67c\", 0x00FC );\n  addEntry( \"na722\", 0x0152 );\n  addEntry( \"na723\", 0x0153 );\n  addEntry( \"na73e\", 0x0101 );\n  addEntry( \"na73f\", 0x0103 );\n  addEntry( \"na740\", 0x0113 );\n  addEntry( \"na741\", 0x0115 );\n  addEntry( \"na742\", 0x012B );\n  addEntry( \"na743\", 0x012D );\n  addEntry( \"na744\", 0x014F );\n  addEntry( \"na746\", 0x016B );\n  addEntry( \"na747\", 0x01D4 );\n  addEntry( \"na74b\", 0x0227 );\n  addEntry( \"na753\", 0x1EBD );\n  addEntry( \"na823\", 0x2026 );\n  addEntry( \"wa424\", 0x00E6 );\n  addEntry( \"wa460\", 0x2460 );\n  addEntry( \"wa461\", 0x2461 );\n  addEntry( \"wa462\", 0x2462 );\n  addEntry( \"wa463\", 0x2463 );\n  addEntry( \"wa464\", 0x2464 );\n}\n\n} // namespace Epwing\n"
        },
        {
          "name": "epwing_charmap.hh",
          "type": "blob",
          "size": 0.4921875,
          "content": "#ifndef __EPWING_CHARMAP_HH_INCLUDED_\n#define __EPWING_CHARMAP_HH_INCLUDED_\n\n#include <QString>\n#include <QByteArray>\n#include <QMap>\n\nnamespace Epwing {\n\nclass EpwingCharmap\n{\npublic:\n\n  /// The class is a singleton.\n  static EpwingCharmap & instance();\n\n  /// Map Epwing extra char to Utf-8\n  QByteArray mapToUtf8( QString const & code );\n\nprivate:\n  EpwingCharmap();\n\n  void addEntry( QString const & code, QChar ch );\n\n  QMap< QString, QChar > charMap;\n};\n\n}\n\n#endif // __EPWING_CHARMAP_HH_INCLUDED_\n"
        },
        {
          "name": "ex.hh",
          "type": "blob",
          "size": 1.2138671875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __EX_HH_INCLUDED__\n#define __EX_HH_INCLUDED__\n\n#include <string>\n\n/// A way to declare an exception class fast\n/// Do like this:\n/// DEF_EX( exErrorInFoo, \"An error in foo encountered\", std::exception )\n/// DEF_EX( exFooNotFound, \"Foo was not found\", exErrorInFoo )\n\n#define DEF_EX( exName, exDescription, exParent ) \\\nclass exName: public exParent { \\\npublic: \\\nvirtual const char * what() const throw() { return (exDescription); } \\\nvirtual ~exName() throw() {} };\n\n/// Same as DEF_EX, but takes a runtime string argument, which gets concatenated\n/// with the description.\n/// \n///   DEF_EX_STR( exCantOpen, \"can't open file\", std::exception )\n///   ...\n///   throw exCantOpen( \"example.txt\" );\n///\n///   what() would return \"can't open file example.txt\"\n\n#define DEF_EX_STR( exName, exDescription, exParent ) \\\nclass exName: public exParent { \\\nstd::string value; \\\npublic: \\\n  exName( std::string const & value_ ): value( std::string( exDescription ) + \" \" + value_ ) {} \\\nvirtual const char * what() const throw() { return value.c_str(); } \\\nvirtual ~exName() throw() {} };\n\n#endif\n"
        },
        {
          "name": "externalaudioplayer.cc",
          "type": "blob",
          "size": 2.85546875,
          "content": "/* This file is (c) 2018 Igor Kushnir <igorkuo@gmail.com>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"externalaudioplayer.hh\"\n#include \"externalviewer.hh\"\n\nExternalAudioPlayer::ExternalAudioPlayer() : exitingViewer( 0 )\n{\n}\n\nExternalAudioPlayer::~ExternalAudioPlayer()\n{\n  // Destroy viewers immediately to prevent memory and temporary file leaks\n  // at application exit.\n\n  // Set viewer to null first and foremost to make sure that onViewerDestroyed()\n  // doesn't attempt to start viewer or mess the smart pointer up.\n  stopAndDestroySynchronously( viewer.take() );\n\n  stopAndDestroySynchronously( exitingViewer );\n}\n\nvoid ExternalAudioPlayer::setPlayerCommandLine( QString const & playerCommandLine_ )\n{\n  playerCommandLine = playerCommandLine_;\n}\n\nQString ExternalAudioPlayer::play( const char * data, int size )\n{\n  stop();\n\n  Q_ASSERT( !viewer && \"viewer must be null at this point for exception safety.\" );\n  try\n  {\n    // Our destructor properly destroys viewers we remember about.\n    // In the unlikely case that we call viewer.reset() during the application\n    // exit, ~QObject() prevents leaks as this class is a parent of all viewers.\n    viewer.reset( new ExternalViewer( data, size, \"wav\", playerCommandLine, this ) );\n  }\n  catch( const ExternalViewer::Ex & e )\n  {\n    return e.what();\n  }\n\n  if( exitingViewer )\n    return QString(); // Will start later.\n  return startViewer();\n}\n\nvoid ExternalAudioPlayer::stop()\n{\n  if( !exitingViewer && viewer && !viewer->stop() )\n  {\n    // Give the previous viewer a chance to stop before starting a new one.\n    // This prevents overlapping audio and possible conflicts between\n    // external program instances.\n    // Graceful stopping is better than calling viewer.reset() because:\n    //   1) the process gets a chance to clean up and save its state;\n    //   2) there is no event loop blocking and consequently no (short) UI freeze\n    //      while synchronously waiting for the external process to exit.\n    exitingViewer = viewer.take();\n  }\n  else // viewer is either not started or already stopped -> simply destroy it.\n    viewer.reset();\n}\n\nvoid ExternalAudioPlayer::onViewerDestroyed( QObject * destroyedViewer )\n{\n  if( exitingViewer == destroyedViewer )\n  {\n    exitingViewer = 0;\n    if( viewer )\n    {\n      QString errorMessage = startViewer();\n      if( !errorMessage.isEmpty() )\n        emit error( errorMessage );\n    }\n  }\n  else\n  if( viewer.data() == destroyedViewer )\n    viewer.take(); // viewer finished and died -> release ownership.\n}\n\nQString ExternalAudioPlayer::startViewer()\n{\n  Q_ASSERT( !exitingViewer && viewer );\n  connect( viewer.data(), SIGNAL( destroyed( QObject * ) ),\n           this, SLOT( onViewerDestroyed( QObject * ) ) );\n  try\n  {\n    viewer->start();\n  }\n  catch( const ExternalViewer::Ex & e )\n  {\n    viewer.reset();\n    return e.what();\n  }\n  return QString();\n}\n"
        },
        {
          "name": "externalaudioplayer.hh",
          "type": "blob",
          "size": 1.33984375,
          "content": "/* This file is (c) 2018 Igor Kushnir <igorkuo@gmail.com>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef EXTERNALAUDIOPLAYER_HH_INCLUDED\n#define EXTERNALAUDIOPLAYER_HH_INCLUDED\n\n#include <QScopedPointer>\n#include <QString>\n#include \"audioplayerinterface.hh\"\n\nclass ExternalViewer;\n\nclass ExternalAudioPlayer : public AudioPlayerInterface\n{\n  Q_OBJECT\npublic:\n  ExternalAudioPlayer();\n  ~ExternalAudioPlayer();\n  /// \\param playerCommandLine_ Will be used in future play() calls.\n  void setPlayerCommandLine( QString const & playerCommandLine_ );\n\n  virtual QString play( const char * data, int size );\n  virtual void stop();\n\nprivate slots:\n  void onViewerDestroyed( QObject * destroyedViewer );\n\nprivate:\n  QString startViewer();\n\n  QString playerCommandLine;\n  ExternalViewer * exitingViewer; ///< If not null: points to the previous viewer,\n                                  ///< the current viewer (if any) is not started yet\n                                  ///< and waits for exitingViewer to be destroyed first.\n\n  struct ScopedPointerDeleteLater\n  {\n    static void cleanup( QObject * p ) { if( p ) p->deleteLater(); }\n  };\n  // deleteLater() is safer because viewer actively participates in the QEventLoop.\n  QScopedPointer< ExternalViewer, ScopedPointerDeleteLater > viewer;\n};\n\n#endif // EXTERNALAUDIOPLAYER_HH_INCLUDED\n"
        },
        {
          "name": "externalviewer.cc",
          "type": "blob",
          "size": 2.2734375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include <QDir>\n#include <QTimer>\n#include \"externalviewer.hh\"\n#include \"parsecmdline.hh\"\n#include \"gddebug.hh\"\n\nExternalViewer::ExternalViewer( const char * data, int size,\n                                QString const & extension, QString const & viewerCmdLine_,\n                                QObject * parent)\n    THROW_SPEC( exCantCreateTempFile ):\n  QObject( parent ),\n  tempFile( QDir::temp().filePath( QString( \"gd-XXXXXXXX.\" ) + extension ) ),\n  viewer( this ),\n  viewerCmdLine( viewerCmdLine_ )\n{\n  if ( !tempFile.open() || tempFile.write( data, size ) != size )\n    throw exCantCreateTempFile();\n\n  tempFileName = tempFile.fileName(); // For some reason it loses it after it was closed()\n\n#ifdef Q_OS_WIN32\n  // Issue #239\n  tempFileName = QDir::toNativeSeparators(tempFileName);\n#endif\n\n  tempFile.close();\n\n  GD_DPRINTF( \"%s\\n\", tempFile.fileName().toLocal8Bit().data() );\n}\n\nvoid ExternalViewer::start() THROW_SPEC( exCantRunViewer )\n{\n  connect( &viewer, SIGNAL( finished( int, QProcess::ExitStatus ) ),\n           this, SLOT( deleteLater() ) );\n  connect( &viewer, SIGNAL( error( QProcess::ProcessError ) ),\n           this, SLOT( deleteLater() ) );\n\n  QStringList args = parseCommandLine( viewerCmdLine );\n\n  if ( !args.isEmpty() )\n  {\n    QString program = args.first();\n    args.pop_front();\n    args.push_back( tempFileName );\n    viewer.start( program, args, QIODevice::NotOpen );\n    if ( !viewer.waitForStarted() )\n      throw exCantRunViewer( viewerCmdLine.toUtf8().data() );\n  }\n  else\n    throw exCantRunViewer( tr( \"the viewer program name is empty\" ).toUtf8().data() );\n}\n\nbool ExternalViewer::stop()\n{\n  if( viewer.state() == QProcess::NotRunning )\n    return true;\n  viewer.terminate();\n  QTimer::singleShot( 1000, &viewer, SLOT( kill() ) ); // In case terminate() fails.\n  return false;\n}\n\nvoid ExternalViewer::stopSynchronously()\n{\n  // This implementation comes straight from QProcess::~QProcess().\n  if( viewer.state() == QProcess::NotRunning )\n    return;\n  viewer.kill();\n  viewer.waitForFinished();\n}\n\nvoid stopAndDestroySynchronously( ExternalViewer * viewer )\n{\n  if( !viewer )\n    return;\n  viewer->stopSynchronously();\n  delete viewer;\n}\n"
        },
        {
          "name": "externalviewer.hh",
          "type": "blob",
          "size": 1.6845703125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __EXTERNALVIEWER_HH_INCLUDED__\n#define __EXTERNALVIEWER_HH_INCLUDED__\n\n#include <QObject>\n#include <QTemporaryFile>\n#include <QProcess>\n#include \"ex.hh\"\n#include \"cpp_features.hh\"\n\n/// An external viewer, opens resources in other programs\nclass ExternalViewer: public QObject\n{\n  Q_OBJECT\n\n  QTemporaryFile tempFile;\n  QProcess viewer;\n  QString viewerCmdLine;\n  QString tempFileName;\n\npublic:\n\n  DEF_EX( Ex, \"External viewer exception\", std::exception )\n  DEF_EX( exCantCreateTempFile, \"Couldn't create temporary file.\", Ex )\n  DEF_EX_STR( exCantRunViewer, \"Couldn't run external viewer:\", Ex )\n\n  ExternalViewer( const char * data, int size,\n                  QString const & extension, QString const & viewerCmdLine,\n                  QObject * parent = 0 )\n    THROW_SPEC( exCantCreateTempFile );\n\n  // Once this is called, the object will be deleted when it's done, even if\n  // the function throws.\n  void start() THROW_SPEC( exCantRunViewer );\n\n  /// If the external process is running, requests its termination and returns\n  /// false - expect the QObject::destroyed() signal to be emitted soon.\n  /// If the external process is not running, returns true, the object\n  /// destruction is not necessarily scheduled in this case.\n  bool stop();\n  /// Kills the process if it is running and waits for it to finish.\n  void stopSynchronously();\n};\n\n/// Call this function instead of simply deleting viewer to prevent the\n/// \"QProcess: Destroyed while process X is still running.\" warning in log.\nvoid stopAndDestroySynchronously( ExternalViewer * viewer );\n\n#endif\n"
        },
        {
          "name": "extlineedit.cc",
          "type": "blob",
          "size": 4.5166015625,
          "content": "/* This file is (c) 2012 Tvangeste <i.4m.l33t@yandex.ru>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"extlineedit.hh\"\n\n#include <QPainter>\n\n#if QT_VERSION >= 0x040600\n#include <QPropertyAnimation>\n#endif\n\nExtLineEdit::ExtLineEdit(QWidget *parent) :\n    QLineEdit(parent)\n{\n\n  for (int i = 0; i < 2; ++i) {\n      iconButtons[i] = new IconButton(this);\n      iconButtons[i]->installEventFilter(this);\n      iconButtons[i]->hide();\n      iconButtons[i]->setAutoHide(false);\n      iconEnabled[i] = false;\n  }\n\n    ensurePolished();\n    updateMargins();\n\n    connect(iconButtons[Left], SIGNAL(clicked()), this, SLOT(iconClicked()));\n    connect(iconButtons[Right], SIGNAL(clicked()), this, SLOT(iconClicked()));\n\n    connect(this, SIGNAL( textChanged( QString ) ), this, SLOT( updateButtons( QString ) ) );\n}\n\nExtLineEdit::~ExtLineEdit()\n{\n}\n\nvoid ExtLineEdit::setButtonVisible(Side side, bool visible)\n{\n    iconButtons[side]->setVisible(visible);\n    iconEnabled[side] = visible;\n    updateMargins();\n}\n\nbool ExtLineEdit::isButtonVisible(Side side) const\n{\n    return iconEnabled[side];\n}\n\nvoid ExtLineEdit::setButtonAutoHide(Side side, bool autohide)\n{\n    iconButtons[side]->setAutoHide(autohide);\n\n    if (autohide)\n    {\n      iconButtons[side]->setOpacity( text().isEmpty() ? 0.0 : 1.0 );\n    }\n    else\n    {\n      iconButtons[side]->setOpacity( 1.0 );\n    }\n}\n\nvoid ExtLineEdit::updateButtons(QString text)\n{\n  if ( oldText.isEmpty() || text.isEmpty() ) {\n    for (int i = 0; i < 2; ++i) {\n      if ( iconButtons[i]->isAutoHide() )\n      {\n       iconButtons[i]->animate( !text.isEmpty() );\n      }\n    }\n    oldText = text;\n  }\n}\n\nvoid ExtLineEdit::iconClicked()\n{\n    IconButton * button = qobject_cast<IconButton *>( sender() );\n    int index = -1;\n    for (int i = 0; i < 2; ++i)\n        if (iconButtons[i] == button)\n            index = i;\n\n    if (index == -1)\n        return;\n\n    if (index == Left)\n      emit leftButtonClicked();\n    else if (index == Right)\n      emit rightButtonClicked();\n}\n\nvoid ExtLineEdit::updateMargins()\n{\n    bool leftToRight = (layoutDirection() == Qt::LeftToRight);\n    Side realLeft = (leftToRight ? Left : Right);\n    Side realRight = (leftToRight ? Right : Left);\n\n    int leftMargin = iconButtons[realLeft]->pixmap().width() + 8;\n    int rightMargin = iconButtons[realRight]->pixmap().width() + 8;\n\n    setTextMargins(\n            (iconEnabled[realLeft] ? leftMargin : 0), 1,\n            (iconEnabled[realRight] ? rightMargin : 0), 1);\n}\n\nvoid ExtLineEdit::updateButtonPositions()\n{\n    QRect contentRect = rect();\n    for (int i = 0; i < 2; ++i) {\n        Side iconPos = (Side)i;\n        if (layoutDirection() == Qt::RightToLeft)\n            iconPos = (iconPos == Left ? Right : Left);\n\n        if (iconPos == ExtLineEdit::Right) {\n            int const iconoffset = textMargins().right() + 4;\n            iconButtons[i]->setGeometry(contentRect.adjusted(width() - iconoffset, 0, 0, 0));\n        } else {\n            int const iconoffset = textMargins().left() + 4;\n            iconButtons[i]->setGeometry(contentRect.adjusted(0, 0, -width() + iconoffset, 0));\n        }\n    }\n}\n\nvoid ExtLineEdit::resizeEvent(QResizeEvent *)\n{\n    updateButtonPositions();\n}\n\nvoid ExtLineEdit::setButtonPixmap(Side side, const QPixmap &buttonPixmap)\n{\n    iconButtons[side]->setPixmap(buttonPixmap);\n    updateMargins();\n    updateButtonPositions();\n    update();\n}\n\nQPixmap ExtLineEdit::buttonPixmap(Side side) const\n{\n    return pixmaps[side];\n}\n\nvoid ExtLineEdit::setButtonToolTip(Side side, const QString &tip)\n{\n    iconButtons[side]->setToolTip(tip);\n}\n\nvoid ExtLineEdit::setButtonFocusPolicy(Side side, Qt::FocusPolicy policy)\n{\n    iconButtons[side]->setFocusPolicy(policy);\n}\n\nIconButton::IconButton(QWidget *parent)\n    : QAbstractButton(parent)\n{\n    setCursor(Qt::ArrowCursor);\n    setFocusPolicy(Qt::NoFocus);\n    setFocusProxy(parent);\n}\n\nvoid IconButton::paintEvent(QPaintEvent *)\n{\n    QPainter painter(this);\n\n    QRect pixmapRect = QRect(0, 0, m_pixmap.width(), m_pixmap.height());\n    pixmapRect.moveCenter(rect().center());\n\n    if (m_autohide)\n    {\n      painter.setOpacity(m_opacity);\n    }\n\n    painter.drawPixmap(pixmapRect, m_pixmap);\n}\n\nvoid IconButton::animate(bool visible)\n{\n#if QT_VERSION >= 0x040600\n  QPropertyAnimation *animation = new QPropertyAnimation(this, \"opacity\");\n  animation->setDuration(250);\n  if (visible)\n  {\n    animation->setEndValue(1.0);\n  }\n  else\n  {\n    animation->setEndValue(0.0);\n  }\n  animation->start(QAbstractAnimation::DeleteWhenStopped);\n#else\n  setOpacity(visible ? 1.0 : 0.0);\n#endif\n}\n"
        },
        {
          "name": "extlineedit.hh",
          "type": "blob",
          "size": 1.90625,
          "content": "/* This file is (c) 2012 Tvangeste <i.4m.l33t@yandex.ru>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef EXTLINEEDIT_H\n#define EXTLINEEDIT_H\n\n#include <QLineEdit>\n#include <QAbstractButton>\n\nclass IconButton: public QAbstractButton\n{\n    Q_OBJECT\n    Q_PROPERTY(QPixmap pixmap READ pixmap WRITE setPixmap)\n    Q_PROPERTY(float opacity READ opacity WRITE setOpacity)\n\npublic:\n    explicit IconButton(QWidget * parent = 0);\n    void paintEvent(QPaintEvent * event);\n    void animate(bool visible);\n\n    void setPixmap(const QPixmap & pixmap) { m_pixmap = pixmap; update(); }\n    QPixmap pixmap() const { return m_pixmap; }\n\n    void setAutoHide(bool autohide) { m_autohide = autohide; update(); }\n    bool isAutoHide() const { return m_autohide; }\n\n    float opacity() { return m_opacity; }\n    void setOpacity(float opacity) { m_opacity = opacity; update(); }\n\nprivate:\n    QPixmap m_pixmap;\n    bool m_autohide;\n    float m_opacity;\n};\n\nclass ExtLineEdit : public QLineEdit\n{\n    Q_OBJECT\n    Q_ENUMS(Side)\n\npublic:\n    enum Side { Left = 0, Right = 1 };\n\n    explicit ExtLineEdit(QWidget * parent = 0);\n    ~ExtLineEdit();\n\n    QPixmap buttonPixmap(Side side) const;\n    void setButtonPixmap(Side side, const QPixmap &pixmap);\n\n    void setButtonVisible(Side side, bool visible);\n    bool isButtonVisible(Side side) const;\n\n    void setButtonToolTip(Side side, const QString &);\n    void setButtonFocusPolicy(Side side, Qt::FocusPolicy policy);\n\n    void setButtonAutoHide(Side side, bool autohide);\n\nsignals:\n    void leftButtonClicked();\n    void rightButtonClicked();\n\nprivate slots:\n    void iconClicked();\n    void updateButtons(QString text);\n\nprotected:\n    virtual void resizeEvent( QResizeEvent * e );\n\nprivate:\n    void updateMargins();\n    void updateButtonPositions();\n    QPixmap pixmaps[2];\n    IconButton * iconButtons[2];\n    bool iconEnabled[2];\n    QString oldText;\n};\n\n#endif // EXTLINEEDIT_H\n"
        },
        {
          "name": "favoritespanewidget.cc",
          "type": "blob",
          "size": 29.416015625,
          "content": "/* This file is (c) 2017 Abs62\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include <QDebug>\n#include <QApplication>\n#include <QDockWidget>\n#include <QKeyEvent>\n#include <QClipboard>\n#include <QDomDocument>\n#include <QMessageBox>\n#include <QtAlgorithms>\n#include <QMap>\n#include <algorithm>\n\n#include \"favoritespanewidget.hh\"\n#include \"gddebug.hh\"\n#include \"atomic_rename.hh\"\n#include \"qt4x5.hh\"\n\n/************************************************** FavoritesPaneWidget *********************************************/\n\nvoid FavoritesPaneWidget::setUp( Config::Class * cfg, QMenu * menu )\n{\n  m_cfg = cfg;\n  m_favoritesTree = findChild< TreeView * >( \"favoritesTree\" );\n  QDockWidget * favoritesPane = qobject_cast< QDockWidget * >( parentWidget() );\n  m_favoritesTree->setHeaderHidden( true );\n\n  // Delete selected items action\n  m_deleteSelectedAction = new QAction( this );\n  m_deleteSelectedAction->setText( tr( \"&Delete Selected\" ) );\n  m_deleteSelectedAction->setShortcut( QKeySequence( QKeySequence::Delete ) );\n  m_deleteSelectedAction->setShortcutContext( Qt::WidgetWithChildrenShortcut );\n  addAction( m_deleteSelectedAction );\n  connect( m_deleteSelectedAction, SIGNAL( triggered() ),\n           this, SLOT( deleteSelectedItems() ) );\n\n  // Copy selected items to clipboard\n  m_copySelectedToClipboard = new QAction( this );\n  m_copySelectedToClipboard->setText( tr( \"Copy Selected\" ) );\n  m_copySelectedToClipboard->setShortcut( QKeySequence( QKeySequence::Copy ) );\n  m_copySelectedToClipboard->setShortcutContext( Qt::WidgetWithChildrenShortcut );\n  addAction( m_copySelectedToClipboard );\n  connect( m_copySelectedToClipboard, SIGNAL( triggered() ),\n           this, SLOT( copySelectedItems() ) );\n\n  // Add folder to tree view\n  m_addFolder = new QAction( this );\n  m_addFolder->setText( tr( \"Add folder\" ) );\n  addAction( m_addFolder );\n  connect( m_addFolder, SIGNAL( triggered() ), this, SLOT( addFolder() ) );\n\n\n  // Handle context menu, reusing some of the top-level window's History menu\n  m_favoritesMenu = new QMenu( this );\n  m_separator = m_favoritesMenu->addSeparator();\n  QListIterator< QAction * > actionsIter( menu->actions() );\n  while ( actionsIter.hasNext() )\n    m_favoritesMenu->addAction( actionsIter.next() );\n\n  // Make the favorites pane's titlebar\n\n  favoritesLabel.setText( tr( \"Favorites:\" ) );\n  favoritesLabel.setObjectName( \"favoritesLabel\" );\n  if ( layoutDirection() == Qt::LeftToRight )\n  {\n    favoritesLabel.setAlignment( Qt::AlignLeft );\n  }\n  else\n  {\n    favoritesLabel.setAlignment( Qt::AlignRight );\n  }\n\n  favoritesPaneTitleBarLayout.addWidget( &favoritesLabel );\n  favoritesPaneTitleBarLayout.setContentsMargins(5, 5, 5, 5);\n  favoritesPaneTitleBar.setLayout( &favoritesPaneTitleBarLayout );\n  favoritesPaneTitleBar.setObjectName(\"favoritesPaneTitleBar\");\n  favoritesPane->setTitleBarWidget( &favoritesPaneTitleBar );\n\n  // Favorites tree\n  m_favoritesModel = new FavoritesModel( Config::getFavoritiesFileName(), this );\n\n  listItemDelegate = new WordListItemDelegate( m_favoritesTree->itemDelegate() );\n  m_favoritesTree->setItemDelegate( listItemDelegate );\n\n  QAbstractItemModel * oldModel = m_favoritesTree->model();\n  m_favoritesTree->setModel( m_favoritesModel );\n  if( oldModel )\n    oldModel->deleteLater();\n\n  connect( m_favoritesTree, SIGNAL( expanded( QModelIndex ) ),\n           m_favoritesModel, SLOT( itemExpanded( QModelIndex ) ) );\n\n  connect( m_favoritesTree, SIGNAL( collapsed( QModelIndex ) ),\n           m_favoritesModel, SLOT( itemCollapsed( QModelIndex ) ) );\n\n  connect( m_favoritesModel, SIGNAL( expandItem( QModelIndex) ),\n           m_favoritesTree, SLOT( expand( QModelIndex ) ) );\n\n  m_favoritesModel->checkAllNodesForExpand();\n  m_favoritesTree->viewport()->setAcceptDrops( true );\n  m_favoritesTree->setDragEnabled( true );\n//  m_favoritesTree->setDragDropMode( QAbstractItemView::InternalMove );\n  m_favoritesTree->setDragDropMode( QAbstractItemView::DragDrop );\n  m_favoritesTree->setDefaultDropAction( Qt::MoveAction );\n\n  m_favoritesTree->setRootIsDecorated( true );\n\n  m_favoritesTree->setContextMenuPolicy( Qt::CustomContextMenu );\n  m_favoritesTree->setSelectionMode( QAbstractItemView::ExtendedSelection );\n\n  m_favoritesTree->setEditTriggers( QAbstractItemView::SelectedClicked | QAbstractItemView::EditKeyPressed );\n\n  m_favoritesTree->installEventFilter( this );\n  m_favoritesTree->viewport()->installEventFilter( this );\n\n  // list selection and keyboard navigation\n  connect( m_favoritesTree, SIGNAL( clicked( QModelIndex const & ) ),\n           this, SLOT( onItemClicked( QModelIndex const & ) ) );\n\n  connect ( m_favoritesTree->selectionModel(), SIGNAL( selectionChanged ( QItemSelection const & , QItemSelection const & ) ),\n      this, SLOT( onSelectionChanged( QItemSelection const & ) ) );\n\n  connect( m_favoritesTree, SIGNAL( customContextMenuRequested( QPoint const & ) ),\n           this, SLOT( showCustomMenu( QPoint const & ) ) );\n}\n\nFavoritesPaneWidget::~FavoritesPaneWidget()\n{\n  if( listItemDelegate )\n    delete listItemDelegate;\n}\n\nbool FavoritesPaneWidget::eventFilter( QObject * obj, QEvent * ev )\n{\n  // unused for now\n\n  return QWidget::eventFilter( obj, ev );\n}\n\nvoid FavoritesPaneWidget::copySelectedItems()\n{\n  QModelIndexList selectedIdxs = m_favoritesTree->selectionModel()->selectedIndexes();\n\n  if ( selectedIdxs.isEmpty() )\n  {\n    // nothing to do\n    return;\n  }\n\n  QStringList selectedStrings = m_favoritesModel->getTextForIndexes( selectedIdxs );\n\n  QApplication::clipboard()->setText( selectedStrings.join( QString::fromLatin1( \"\\n\" ) ) );\n}\n\nvoid FavoritesPaneWidget::deleteSelectedItems()\n{\n  QModelIndexList selectedIdxs = m_favoritesTree->selectionModel()->selectedIndexes();\n\n  if ( selectedIdxs.isEmpty() )\n  {\n    // nothing to do\n    return;\n  }\n\n  if( m_cfg->preferences.confirmFavoritesDeletion )\n  {\n    QMessageBox mb( QMessageBox::Warning, \"GoldenDict\",\n                    tr( \"All selected items will be deleted. Continue?\" ),\n                    QMessageBox::Yes | QMessageBox::No );\n    mb.exec();\n    if( mb.result() != QMessageBox::Yes )\n      return;\n  }\n\n  m_favoritesModel->removeItemsForIndexes( selectedIdxs );\n}\n\nvoid FavoritesPaneWidget::showCustomMenu(QPoint const & pos)\n{\n  QModelIndexList selectedIdxs = m_favoritesTree->selectionModel()->selectedIndexes();\n\n  m_favoritesMenu->removeAction( m_copySelectedToClipboard );\n  m_favoritesMenu->removeAction( m_deleteSelectedAction );\n  m_favoritesMenu->removeAction( m_addFolder );\n\n  m_separator->setVisible( !selectedIdxs.isEmpty() );\n\n  if ( !selectedIdxs.isEmpty() )\n  {\n    m_favoritesMenu->insertAction( m_separator, m_copySelectedToClipboard );\n    m_favoritesMenu->insertAction( m_separator, m_deleteSelectedAction );\n  }\n\n  if( selectedIdxs.size() <= 1 )\n  {\n    m_favoritesMenu->insertAction( m_separator, m_addFolder );\n    m_separator->setVisible( true );\n  }\n\n  m_favoritesMenu->exec( m_favoritesTree->mapToGlobal( pos ) );\n}\n\nvoid FavoritesPaneWidget::onSelectionChanged( QItemSelection const & selection )\n{\n  if ( m_favoritesTree->selectionModel()->selectedIndexes().size() != 1\n       || selection.indexes().isEmpty() )\n    return;\n\n  itemSelectionChanged = true;\n  emitFavoritesItemRequested( selection.indexes().front() );\n}\n\nvoid FavoritesPaneWidget::onItemClicked( QModelIndex const & idx )\n{\n  if ( !itemSelectionChanged && m_favoritesTree->selectionModel()->selectedIndexes().size() == 1 )\n  {\n    emitFavoritesItemRequested( idx );\n  }\n  itemSelectionChanged = false;\n}\n\nvoid FavoritesPaneWidget::emitFavoritesItemRequested( QModelIndex const & idx )\n{\n  if( m_favoritesModel->itemType( idx ) != TreeItem::Word )\n  {\n    // Item is not headword\n    return;\n  }\n\n  QString headword = m_favoritesModel->data( idx, Qt::DisplayRole ).toString();\n  QString path = m_favoritesModel->pathToItem( idx );\n\n  if( !headword.isEmpty() )\n    emit favoritesItemRequested( headword, path );\n}\n\nvoid FavoritesPaneWidget::addFolder()\n{\n  QModelIndexList selectedIdx = m_favoritesTree->selectionModel()->selectedIndexes();\n  if( selectedIdx.size() > 1 )\n    return;\n\n  QModelIndex folderIdx;\n  if( selectedIdx.size() )\n    folderIdx = m_favoritesModel->addNewFolder( selectedIdx.front() );\n  else\n    folderIdx = m_favoritesModel->addNewFolder( QModelIndex() );\n\n  if( folderIdx.isValid() )\n    m_favoritesTree->edit( folderIdx );\n}\n\nvoid FavoritesPaneWidget::addHeadword( QString const & path, QString const & headword )\n{\n  m_favoritesModel->addNewHeadword( path, headword );\n}\n\nbool FavoritesPaneWidget::removeHeadword( QString const & path, QString const & headword )\n{\n  return m_favoritesModel->removeHeadword( path, headword );\n}\n\nbool FavoritesPaneWidget::isHeadwordPresent( const QString & path, const QString & headword )\n{\n  return m_favoritesModel->isHeadwordPresent( path, headword );\n}\n\nvoid FavoritesPaneWidget::getDataInXml( QByteArray & dataStr )\n{\n  m_favoritesModel->getDataInXml( dataStr );\n}\n\nvoid FavoritesPaneWidget::getDataInPlainText( QString & dataStr )\n{\n  m_favoritesModel->getDataInPlainText( dataStr );\n}\n\nbool FavoritesPaneWidget::setDataFromXml( QString const & dataStr )\n{\n  return m_favoritesModel->setDataFromXml( dataStr );\n}\n\nvoid FavoritesPaneWidget::setSaveInterval( unsigned interval )\n{\n  if( timerId )\n  {\n    killTimer( timerId );\n    timerId = 0;\n  }\n  if( interval )\n  {\n    m_favoritesModel->saveData();\n    timerId = startTimer( interval * 60000 );\n  }\n}\n\nvoid FavoritesPaneWidget::timerEvent( QTimerEvent * ev )\n{\n  Q_UNUSED( ev )\n  m_favoritesModel->saveData();\n}\n\nvoid FavoritesPaneWidget::saveData()\n{\n  m_favoritesModel->saveData();\n}\n\n/************************************************** TreeItem *********************************************/\n\nTreeItem::TreeItem( const QVariant &data, TreeItem *parent, Type type ) :\n  itemData( data ),\n  parentItem( parent ),\n  m_type( type ),\n  m_expanded( false )\n{\n}\n\nTreeItem::~TreeItem()\n{\n  qDeleteAll( childItems );\n}\n\nvoid TreeItem::appendChild( TreeItem *item )\n{\n  childItems.append( item );\n}\n\nvoid TreeItem::insertChild( int row, TreeItem * item )\n{\n  if( row > childItems.count() )\n    row = childItems.count();\n  childItems.insert( row, item );\n}\n\nTreeItem *TreeItem::child( int row ) const\n{\n  return childItems.value( row );\n}\n\nvoid TreeItem::deleteChild( int row )\n{\n  if( row < 0 || row >= childItems.count() )\n    return;\n\n  TreeItem *it = childItems.at( row );\n  childItems.removeAt( row );\n  delete it;\n}\n\nint TreeItem::childCount() const\n{\n  return childItems.count();\n}\n\nQVariant TreeItem::data() const\n{\n  return itemData;\n}\n\nvoid TreeItem::setData( const QVariant & newData )\n{\n  itemData = newData;\n}\n\nint TreeItem::row() const\n{\n  if( parentItem )\n      return parentItem->childItems.indexOf( const_cast< TreeItem * >( this ) );\n\n  return 0;\n}\n\nTreeItem *TreeItem::parent()\n{\n  return parentItem;\n}\n\nQt::ItemFlags TreeItem::flags() const\n{\n  Qt::ItemFlags f = Qt::ItemIsEnabled | Qt::ItemIsSelectable |\n                    Qt::ItemIsDragEnabled;\n  if( m_type == Folder )\n    f |= Qt::ItemIsEditable | Qt::ItemIsDropEnabled;\n  else\n  if( m_type == Root )\n    f |= Qt::ItemIsDropEnabled;\n\n  return f;\n}\n\nQString TreeItem::fullPath() const\n{\n  // Get full path from root item\n  QString path;\n  TreeItem * par = parentItem;\n  for( ; ; )\n  {\n    if( !par )\n      break;\n    path = par->data().toString() + \"/\" + path;\n    par = par->parentItem;\n  }\n  return path;\n}\n\nTreeItem * TreeItem::duplicateItem( TreeItem * newParent ) const\n{\n  TreeItem * newItem = new TreeItem( itemData, newParent, m_type );\n  if( m_type == Folder )\n  {\n    QList< TreeItem * >::const_iterator it = childItems.begin();\n    for( ; it != childItems.end(); ++it )\n      newItem->appendChild( (*it)->duplicateItem( newItem ) );\n  }\n  return newItem;\n}\n\nbool TreeItem::haveAncestor( TreeItem * item )\n{\n  TreeItem *par = parentItem;\n  for( ; ; )\n  {\n    if( !par )\n      break;\n    if( par == item )\n      return true;\n    par = par->parent();\n  }\n  return false;\n}\n\nbool TreeItem::haveSameItem( TreeItem * item, bool allowSelf )\n{\n  QList< TreeItem * >::const_iterator it = childItems.begin();\n  QString name = item->data().toString();\n  for( ; it != childItems.end(); ++it )\n  {\n    if( *it == item && !allowSelf )\n      return true;\n    if( (*it)->data().toString() == name && (*it)->type() == item->type() && (*it) != item )\n      return true;\n  }\n\n  return false;\n}\n\nQStringList TreeItem::getTextFromAllChilds() const\n{\n  QStringList list;\n  QList< TreeItem * >::const_iterator it = childItems.begin();\n  for( ; it != childItems.end(); ++it )\n  {\n    if( (*it)->type() == Word )\n    {\n      QString txt = (*it)->data().toString();\n      list.append( txt );\n    }\n    else // Folder\n    {\n      QStringList childList = (*it)->getTextFromAllChilds();\n      list.append( childList );\n    }\n  }\n  return list;\n}\n\n/************************************************** FavoritesModel *********************************************/\n\nFavoritesModel::FavoritesModel( QString favoritesFilename, QObject * parent ) :\n  QAbstractItemModel( parent ),\n  m_favoritesFilename( favoritesFilename ),\n  rootItem( 0 ),\n  dirty( false )\n{\n  readData();\n  dirty = false;\n}\n\nFavoritesModel::~FavoritesModel()\n{\n  if( rootItem )\n    delete rootItem;\n}\n\nQt::ItemFlags FavoritesModel::flags( const QModelIndex &idx ) const\n{\n  TreeItem * item = getItem( idx );\n  return item->flags();\n}\n\nQVariant FavoritesModel::headerData( int , Qt::Orientation,\n                                     int ) const\n{\n  return QVariant();\n}\n\nQModelIndex FavoritesModel::index( int row, int column, const QModelIndex &parentIdx ) const\n{\n//  if(!hasIndex(row, column, parent))\n//    return QModelIndex();\n\n  TreeItem *parentItem = getItem( parentIdx );\n\n  TreeItem *childItem = parentItem->child(row);\n  if( childItem )\n    return createIndex( row, column, childItem );\n\n  return QModelIndex();\n}\n\nQModelIndex FavoritesModel::parent( const QModelIndex &index ) const\n{\n  if ( !index.isValid() )\n    return QModelIndex();\n\n  TreeItem *childItem = getItem( index );\n  if( childItem == rootItem )\n    return QModelIndex();\n\n  TreeItem *parentItem = childItem->parent();\n\n  if( parentItem == rootItem )\n    return QModelIndex();\n\n  return createIndex( parentItem->row(), 0, parentItem );\n}\n\nint FavoritesModel::rowCount(const QModelIndex &parent) const\n{\n  if ( parent.column() > 0 )\n    return 0;\n\n  TreeItem *parentItem = getItem( parent );\n\n  return parentItem->childCount();\n}\n\nint FavoritesModel::columnCount(const QModelIndex & ) const\n{\n  return 1;\n}\n\nbool FavoritesModel::removeRows( int row, int count, const QModelIndex &parent )\n{\n  TreeItem * parentItem = getItem( parent );\n\n  beginRemoveRows( parent, row, row + count - 1 );\n\n  for( int i = 0; i < count; i++ )\n    parentItem->deleteChild( row );\n\n  endRemoveRows();\n\n  dirty = true;\n\n  return true;\n}\n\nbool FavoritesModel::setData( const QModelIndex & index, const QVariant & value, int role )\n{\n  if( role != Qt::EditRole || !index.isValid() || value.toString().isEmpty() )\n    return false;\n\n  QModelIndex parentIdx = parent( index );\n  if( findItemInFolder( value.toString(), TreeItem::Folder, parentIdx ).isValid() )\n  {\n    // Such folder is already presented in parent folder\n    return false;\n  }\n\n  TreeItem * item = getItem( index );\n  item->setData( value );\n\n  dirty = true;\n\n  return true;\n}\n\nQVariant FavoritesModel::data( QModelIndex const & index, int role ) const\n{\n  if( !index.isValid() )\n    return QVariant();\n\n  TreeItem *item = getItem( index );\n  if( item == rootItem )\n    return QVariant();\n\n  if ( role == Qt::DisplayRole || role == Qt::ToolTipRole )\n  {\n    return item->data();\n  }\n  else\n  if( role == Qt::DecorationRole )\n  {\n    if( item->type() == TreeItem::Folder || item->type() == TreeItem::Root )\n      return QIcon( \":/icons/folder.png\" );\n\n    return QVariant();\n  }\n  if( role == Qt::EditRole )\n  {\n    if( item->type() == TreeItem::Folder )\n      return item->data();\n\n    return QVariant();\n  }\n\n  return QVariant();\n}\n\nQt::DropActions FavoritesModel::supportedDropActions() const\n{\n  return Qt::MoveAction | Qt::CopyAction;\n}\n\nvoid FavoritesModel::readData()\n{\n  // Read data from \"favorities\" file\n\n  beginResetModel();\n\n  if( rootItem )\n    delete rootItem;\n\n  rootItem = new TreeItem( QVariant(), 0, TreeItem::Root );\n\n  QFile favoritesFile( m_favoritesFilename );\n  if( !favoritesFile.open( QFile::ReadOnly ) )\n  {\n    gdDebug( \"No favorites file found\" );\n    return;\n  }\n\n  QString errorStr;\n  int errorLine, errorColumn;\n  dom.clear();\n\n  if ( !dom.setContent( &favoritesFile, false, &errorStr, &errorLine, &errorColumn  ) )\n  {\n    // Mailformed file\n    gdWarning( \"Favorites file parsing error: %s at %d,%d\\n\", errorStr.toUtf8().data(),  errorLine,  errorColumn );\n\n    QMessageBox mb( QMessageBox::Warning, \"GoldenDict\",\n                      tr( \"Error in favorities file\" ),\n                      QMessageBox::Ok );\n    mb.exec();\n\n    dom.clear();\n    favoritesFile.close();\n    renameAtomically( m_favoritesFilename, m_favoritesFilename + \".bak\" );\n  }\n  else\n    favoritesFile.close();\n\n  QDomNode rootNode = dom.documentElement();\n  addFolder( rootItem, rootNode );\n  dom.clear();\n\n  endResetModel();\n  dirty = false;\n}\n\nvoid FavoritesModel::saveData()\n{\n  if( !dirty )\n    return;\n\n  QFile tmpFile( m_favoritesFilename + \".tmp\" );\n  if( !tmpFile.open( QFile::WriteOnly ) )\n  {\n    gdWarning( \"Can't write favorites file, error: %s\", tmpFile.errorString().toUtf8().data() );\n    return;\n  }\n\n  dom.clear();\n\n  QDomElement el = dom.createElement( \"root\" );\n  dom.appendChild( el );\n  storeFolder( rootItem, el );\n\n  QByteArray result( dom.toByteArray() );\n\n  if ( tmpFile.write( result ) != result.size() )\n  {\n    gdWarning( \"Can't write favorites file, error: %s\", tmpFile.errorString().toUtf8().data() );\n    return;\n  }\n\n  tmpFile.close();\n\n  if( renameAtomically( tmpFile.fileName(), m_favoritesFilename ) )\n    dirty = false;\n\n  dom.clear();\n}\n\nvoid FavoritesModel::addFolder( TreeItem *parent, QDomNode &node )\n{\n  QDomNodeList nodes = node.childNodes();\n  for( int i = 0; i < nodes.count(); i++ )\n  {\n    QDomElement el = nodes.at( i ).toElement();\n    if( el.nodeName() == \"folder\" )\n    {\n      // New subfolder\n      QString name = el.attribute( \"name\", \"\" );\n      TreeItem *item = new TreeItem( name, parent, TreeItem::Folder );\n      item->setExpanded( el.attribute( \"expanded\", \"0\" ) == \"1\" );\n      parent->appendChild( item );\n      addFolder( item, el );\n    }\n    else\n    {\n      QString word = el.text();\n      parent->appendChild( new TreeItem( word, parent, TreeItem::Word ) );\n    }\n  }\n  dirty = true;\n}\n\nvoid FavoritesModel::storeFolder( TreeItem * folder, QDomNode & node )\n{\n  int n = folder->childCount();\n  for( int i = 0; i < n; i++ )\n  {\n    TreeItem * child = folder->child( i );\n    QString name = child->data().toString();\n    if( child->type() == TreeItem::Folder )\n    {\n      QDomElement el = dom.createElement( \"folder\" );\n      el.setAttribute( \"name\", name );\n      el.setAttribute( \"expanded\", child->isExpanded() ? \"1\" : \"0\" );\n      node.appendChild( el );\n      storeFolder( child, el );\n    }\n    else\n    {\n      QDomElement el = dom.createElement( \"headword\" );\n      el.appendChild( dom.createTextNode( name ) );\n      node.appendChild( el );\n    }\n  }\n}\n\nvoid FavoritesModel::itemExpanded( const QModelIndex & index )\n{\n  if( index.isValid() )\n  {\n    TreeItem *item = getItem( index );\n    item->setExpanded( true );\n  }\n}\n\nvoid FavoritesModel::itemCollapsed( const QModelIndex & index )\n{\n  if( index.isValid() )\n  {\n    TreeItem *item = getItem( index );\n    item->setExpanded( false );\n  }\n}\n\nvoid FavoritesModel::checkAllNodesForExpand()\n{\n  checkNodeForExpand( rootItem, QModelIndex() );\n}\n\nvoid FavoritesModel::checkNodeForExpand( const TreeItem * item, const QModelIndex & parent )\n{\n  for( int i = 0; i < item->childCount(); i++ )\n  {\n    TreeItem * ch = item->child( i );\n    if( ch->type() == TreeItem::Folder && ch->isExpanded() )\n    {\n      // We need to expand this node...\n      QModelIndex idx = index( i, 0, parent );\n      emit expandItem( idx );\n\n      // ...and check it for children nodes\n      checkNodeForExpand( item->child( i ), idx );\n    }\n  }\n}\n\nQStringList FavoritesModel::mimeTypes() const\n{\n  return QStringList( QString::fromLatin1( FAVORITES_MIME_TYPE ) );\n}\n\nQMimeData *FavoritesModel::mimeData( const QModelIndexList & indexes ) const\n{\n  FavoritesMimeData *data = new FavoritesMimeData();\n  data->setIndexesList( indexes );\n  return data;\n}\n\nbool FavoritesModel::dropMimeData( const QMimeData *data, Qt::DropAction action,\n                                   int row, int, const QModelIndex &par )\n{\n  if( action == Qt::MoveAction || action == Qt::CopyAction )\n  {\n    if( data->hasFormat( FAVORITES_MIME_TYPE ) )\n    {\n      FavoritesMimeData const * mimeData = qobject_cast< FavoritesMimeData const * >( data );\n      if( mimeData )\n      {\n        QModelIndexList const & list = mimeData->getIndexesList();\n\n        if( list.isEmpty() )\n          return false;\n\n        TreeItem * parentItem = getItem( par );\n        QModelIndex parentIdx = par;\n\n        if( row < 0 )\n          row = 0;\n\n        QList< QModelIndex >::const_iterator it = list.begin();\n        QList< TreeItem * > movedItems;\n        for( ; it != list.end(); ++it )\n        {\n          TreeItem * item = getItem( *it );\n\n          // Check if we can copy/move this item\n          if( parentItem->haveAncestor( item ) || parentItem->haveSameItem( item, action == Qt::MoveAction ) )\n            return false;\n\n          movedItems.append( item );\n        }\n\n        // Insert items to new place\n\n        beginInsertRows( parentIdx, row, row + movedItems.count() - 1 );\n        for( int i = 0; i < movedItems.count(); i++ )\n        {\n          TreeItem * item = movedItems.at( i );\n          TreeItem *newItem = item->duplicateItem( parentItem );\n          parentItem->insertChild( row + i, newItem );\n        }\n        endInsertRows();\n\n        dirty = true;\n\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nQModelIndex FavoritesModel::findItemInFolder( const QString & itemName, int itemType,\n                                              const QModelIndex & parentIdx )\n{\n  TreeItem * parentItem = getItem( parentIdx );\n  for( int i = 0; i < parentItem->childCount(); i++ )\n  {\n    TreeItem * item = parentItem->child( i );\n    if( item->data().toString() == itemName && item->type() == itemType )\n      return createIndex( i, 0, item );\n  }\n  return QModelIndex();\n}\n\nTreeItem *FavoritesModel::getItem( const QModelIndex &index ) const\n{\n  if( index.isValid() )\n  {\n    TreeItem *item = static_cast< TreeItem * >( index.internalPointer() );\n    if (item)\n      return item;\n  }\n  return rootItem;\n}\n\nQStringList FavoritesModel::getTextForIndexes( const QModelIndexList & idxList ) const\n{\n  QStringList list;\n  QModelIndexList::const_iterator it = idxList.begin();\n  for( ; it != idxList.end(); ++it )\n  {\n    TreeItem *item = getItem( *it );\n    if( item->type() == TreeItem::Word )\n      list.append( item->data().toString() );\n    else\n      list.append( item->getTextFromAllChilds() );\n  }\n  return list;\n}\n\nvoid FavoritesModel::removeItemsForIndexes( const QModelIndexList & idxList )\n{\n  // We should delete items from lowest tree level and in decreasing order\n  // so that first deletions won't affect the indexes for subsequent deletions.\n\n  QMap< int, QModelIndexList > itemsToDelete;\n  int lowestLevel = 0;\n\n  QModelIndexList::const_iterator it = idxList.begin();\n  for( ; it != idxList.end(); ++it )\n  {\n    int n = level( *it );\n    if( n > lowestLevel )\n      lowestLevel = n;\n    itemsToDelete[ n ].append( *it );\n  }\n\n  for( int i = lowestLevel; i >= 0; i-- )\n  {\n    QModelIndexList idxSublist = itemsToDelete[ i ];\n#if __cplusplus >= 201103L\n    // Cannot simply use std::greater< QModelIndex >, because the necessary overload of operator> is missing:\n    // stl_function.h: error: no match for ‘operator>’ (operand types are ‘const QModelIndex’ and ‘const QModelIndex’)\n    // Deprecated qGreater function object template is implemented in terms of operator<, like the lambda below.\n    std::sort( idxSublist.begin(), idxSublist.end(), []( QModelIndex const & a, QModelIndex const & b ) {\n      return b < a;\n    } );\n#else\n    std::sort( idxSublist.begin(), idxSublist.end(), qGreater< QModelIndex >() );\n#endif\n\n    it = idxSublist.begin();\n    for( ; it != idxSublist.end(); ++it )\n    {\n      QModelIndex parentIdx = parent( *it );\n      removeRows( (*it).row(), 1, parentIdx );\n    }\n  }\n}\n\nQModelIndex FavoritesModel::addNewFolder( const QModelIndex & idx )\n{\n  QModelIndex parentIdx;\n  if( idx.isValid() )\n    parentIdx = parent( idx );\n  else\n    parentIdx = idx;\n\n  QString baseName = QString::fromLatin1( \"New folder\" );\n\n  // Create unique name\n\n  QString name = baseName;\n  if( findItemInFolder( name, TreeItem::Folder, parentIdx ).isValid() )\n  {\n    int i;\n    for( i = 1; i < 1000; i++ )\n    {\n      name = baseName + QString::number( i );\n      if( !findItemInFolder( name, TreeItem::Folder, parentIdx ).isValid() )\n        break;\n    }\n    if( i >= 1000 )\n      return QModelIndex();\n  }\n\n  // Create folder with unique name\n\n  TreeItem *parentItem = getItem( parentIdx );\n  int row;\n\n  if( idx.isValid() )\n  {\n    // Insert after selected element\n    row = idx.row() + 1;\n  }\n  else\n  {\n    // No selected element - add to end of root folder\n    row = parentItem->childCount();\n  }\n\n  beginInsertRows( parentIdx, row, row );\n  TreeItem * newFolder = new TreeItem( name, parentItem, TreeItem::Folder );\n  parentItem->insertChild( row, newFolder );\n  endInsertRows();\n\n  dirty = true;\n\n  return createIndex( row, 0, newFolder );\n}\n\nbool FavoritesModel::addNewHeadword( const QString & path, const QString & headword )\n{\n  QModelIndex parentIdx;\n\n  // Find or create target folder\n\n  QStringList folders = path.split( \"/\", Qt4x5::skipEmptyParts() );\n  QStringList::const_iterator it = folders.begin();\n  for( ; it != folders.end(); ++it )\n    parentIdx = forceFolder( *it, parentIdx );\n\n  // Add headword\n\n  return addHeadword( headword, parentIdx );\n}\n\nbool FavoritesModel::removeHeadword( const QString & path, const QString & headword )\n{\n  QModelIndex idx;\n\n  // Find target folder\n\n  QStringList folders = path.split( \"/\", Qt4x5::skipEmptyParts() );\n  QStringList::const_iterator it = folders.begin();\n  for( ; it != folders.end(); ++it )\n  {\n    idx = findItemInFolder( *it, TreeItem::Folder, idx );\n    if( !idx.isValid() )\n      break;\n  }\n\n  if( path.isEmpty() || idx.isValid() )\n  {\n    idx = findItemInFolder( headword, TreeItem::Word, idx );\n    if( idx.isValid() )\n    {\n      QModelIndexList list;\n      list.append( idx );\n      removeItemsForIndexes( list );\n      return true;\n    }\n  }\n\n  return false;\n}\n\nbool FavoritesModel::isHeadwordPresent( const QString & path, const QString & headword )\n{\n  QModelIndex idx;\n\n  // Find target folder\n\n  QStringList folders = path.split( \"/\", Qt4x5::skipEmptyParts() );\n  QStringList::const_iterator it = folders.begin();\n  for( ; it != folders.end(); ++it )\n  {\n    idx = findItemInFolder( *it, TreeItem::Folder, idx );\n    if( !idx.isValid() )\n      break;\n  }\n\n  if( path.isEmpty() || idx.isValid() )\n  {\n    idx = findItemInFolder( headword, TreeItem::Word, idx );\n    return idx.isValid();\n  }\n\n  return false;\n}\n\nQModelIndex FavoritesModel::forceFolder( QString const & name, const QModelIndex & parentIdx )\n{\n  QModelIndex idx = findItemInFolder( name, TreeItem::Folder, parentIdx );\n  if( idx.isValid() )\n    return idx;\n\n  // Folder not found, create it\n  TreeItem * parentItem = getItem( parentIdx );\n  TreeItem * newItem = new TreeItem( name, parentItem, TreeItem::Folder );\n  int row = parentItem->childCount();\n\n  beginInsertRows( parentIdx, row, row );\n  parentItem->appendChild( newItem );\n  endInsertRows();\n\n  dirty = true;\n\n  return createIndex( row, 0, newItem );\n}\n\nbool FavoritesModel::addHeadword( const QString & word, const QModelIndex & parentIdx )\n{\n  QModelIndex idx = findItemInFolder( word, TreeItem::Word, parentIdx );\n  if( idx.isValid() )\n    return false;\n\n  // Headword not found, append it\n  TreeItem * parentItem = getItem( parentIdx );\n  TreeItem * newItem = new TreeItem( word, parentItem, TreeItem::Word );\n  int row = parentItem->childCount();\n\n  beginInsertRows( parentIdx, row, row );\n  parentItem->appendChild( newItem );\n  endInsertRows();\n\n  dirty = true;\n\n  return true;\n}\n\nint FavoritesModel::level( QModelIndex const & idx )\n{\n  int n = 0;\n  QModelIndex parentIdx = parent( idx );\n  while( parentIdx.isValid() )\n  {\n    n++;\n    parentIdx = parent( parentIdx );\n  }\n  return n;\n}\n\nQString FavoritesModel::pathToItem( QModelIndex const & idx )\n{\n  QString path;\n  QModelIndex parentIdx = parent( idx );\n  while( parentIdx.isValid() )\n  {\n    if( !path.isEmpty() )\n      path = \"/\" + path;\n\n    path = data( parentIdx, Qt::DisplayRole ).toString() + path;\n\n    parentIdx = parent( parentIdx );\n  }\n  return path;\n}\n\nvoid FavoritesModel::getDataInXml( QByteArray & dataStr )\n{\n  dom.clear();\n\n  QDomElement el = dom.createElement( \"root\" );\n  dom.appendChild( el );\n  storeFolder( rootItem, el );\n\n  dataStr = dom.toByteArray();\n  dom.clear();\n}\n\nvoid FavoritesModel::getDataInPlainText( QString & dataStr )\n{\n  QModelIndexList list;\n  list.append( QModelIndex() );\n  dataStr = getTextForIndexes( list ).join( QString::fromLatin1( \"\\n\" ) );\n}\n\nbool FavoritesModel::setDataFromXml( QString const & dataStr )\n{\n  QString errorStr;\n  int errorLine, errorColumn;\n  dom.clear();\n\n  if ( !dom.setContent( dataStr, false, &errorStr, &errorLine, &errorColumn  ) )\n  {\n    // Mailformed data\n    gdWarning( \"XML parsing error: %s at %d,%d\\n\", errorStr.toUtf8().data(),  errorLine,  errorColumn );\n    dom.clear();\n    return false;\n  }\n\n  beginResetModel();\n\n  if( rootItem )\n    delete rootItem;\n\n  rootItem = new TreeItem( QVariant(), 0, TreeItem::Root );\n\n  QDomNode rootNode = dom.documentElement();\n  addFolder( rootItem, rootNode );\n\n  endResetModel();\n\n  dom.clear();\n  dirty = true;\n  return true;\n}\n"
        },
        {
          "name": "favoritespanewidget.hh",
          "type": "blob",
          "size": 7.8203125,
          "content": "/* This file is (c) 2017 Abs62\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __FAVORITIESPANEWIDGET_HH__INCLUDED__\n#define __FAVORITIESPANEWIDGET_HH__INCLUDED__\n\n#include <QWidget>\n#include <QSize>\n#include <QAbstractItemModel>\n#include <QLabel>\n#include <QHBoxLayout>\n#include <QMenu>\n#include <QDomNode>\n#include <QList>\n#include <QMimeData>\n\n#include <config.hh>\n#include \"delegate.hh\"\n#include \"treeview.hh\"\n\nclass FavoritesModel;\n\nclass FavoritesPaneWidget : public QWidget\n{\n  Q_OBJECT\npublic:\n  FavoritesPaneWidget( QWidget * parent = 0 ): QWidget( parent ),\n    itemSelectionChanged( false )\n  , listItemDelegate( 0 )\n  , m_favoritesModel( 0 )\n  , timerId( 0 )\n  {}\n\n  virtual ~FavoritesPaneWidget();\n\n  virtual QSize sizeHint() const\n  { return QSize( 204, 204 ); }\n\n  void setUp( Config::Class * cfg, QMenu * menu );\n\n  void addHeadword( QString const & path, QString const & headword );\n\n  bool removeHeadword( QString const & path, QString const & headword );\n\n  // Export/import Favorites\n  void getDataInXml( QByteArray & dataStr );\n  void getDataInPlainText( QString & dataStr );\n  bool setDataFromXml( QString const & dataStr );\n\n  void setFocusOnTree()\n  { m_favoritesTree->setFocus(); }\n\n  // Set interval for periodical save\n  void setSaveInterval( unsigned interval );\n\n  // Return true if headwors is already presented in Favorites\n  bool isHeadwordPresent( QString const & path, QString const & headword );\n\n  void saveData();\n\nsignals:\n  void favoritesItemRequested( QString const & word, QString const & faforitesFolder );\n\nprotected:\n  virtual void timerEvent( QTimerEvent * ev );\n\nprivate slots:\n  void emitFavoritesItemRequested(QModelIndex const &);\n  void onSelectionChanged(QItemSelection const & selection);\n  void onItemClicked(QModelIndex const & idx);\n  void showCustomMenu(QPoint const & pos);\n  void deleteSelectedItems();\n  void copySelectedItems();\n  void addFolder();\n\nprivate:\n  virtual bool eventFilter( QObject *, QEvent * );\n\n  Config::Class * m_cfg ;\n  TreeView * m_favoritesTree;\n  QMenu * m_favoritesMenu;\n  QAction * m_deleteSelectedAction;\n  QAction * m_separator;\n  QAction * m_copySelectedToClipboard;\n  QAction * m_addFolder;\n\n  QWidget favoritesPaneTitleBar;\n  QHBoxLayout favoritesPaneTitleBarLayout;\n  QLabel favoritesLabel;\n\n  /// needed to avoid multiple notifications\n  /// when selecting items via mouse and keyboard\n  bool itemSelectionChanged;\n\n  WordListItemDelegate * listItemDelegate;\n  FavoritesModel * m_favoritesModel;\n\n  int timerId;\n};\n\n\nclass TreeItem\n{\npublic:\n  enum Type { Word, Folder, Root };\n\n  TreeItem( const QVariant &data, TreeItem *parent = 0, Type type_ = Word );\n  ~TreeItem();\n\n  void appendChild( TreeItem * child );\n\n  void insertChild( int row, TreeItem * item );\n\n  // Remove child from list and delete it\n  void deleteChild( int row );\n\n  TreeItem * child( int row ) const;\n  int childCount() const;\n  QVariant data() const;\n  void setData( const QVariant & newData );\n  int row() const;\n  TreeItem * parent();\n\n  Type type() const\n  { return m_type; }\n\n  Qt::ItemFlags flags() const;\n\n  void setExpanded( bool expanded )\n  { m_expanded = expanded; }\n\n  bool isExpanded() const\n  { return m_expanded; }\n\n  // Full path from root folder\n  QString fullPath() const;\n\n  // Duplicate item with all childs\n  TreeItem * duplicateItem( TreeItem * newParent ) const;\n\n  // Check if item is ancestor of this element\n  bool haveAncestor( TreeItem * item );\n\n  // Check if same item already presented between childs\n  bool haveSameItem( TreeItem * item, bool allowSelf );\n\n  // Retrieve text from all childs\n  QStringList getTextFromAllChilds() const;\n\nprivate:\n  QList< TreeItem * > childItems;\n  QVariant itemData;\n  TreeItem *parentItem;\n  Type m_type;\n  bool m_expanded;\n};\n\nclass FavoritesModel : public QAbstractItemModel\n{\n  Q_OBJECT\npublic:\n  explicit FavoritesModel( QString favoritesFilename, QObject * parent = 0 );\n  ~FavoritesModel();\n\n  QVariant data( const QModelIndex &index, int role ) const;\n  Qt::ItemFlags flags( const QModelIndex &index ) const;\n  QVariant headerData( int section, Qt::Orientation orientation,\n                       int role = Qt::DisplayRole ) const;\n  QModelIndex index( int row, int column,\n                     const QModelIndex &parent = QModelIndex() ) const;\n  QModelIndex parent( const QModelIndex &index ) const;\n  int rowCount( const QModelIndex &parent = QModelIndex() ) const;\n  int columnCount( const QModelIndex &parent = QModelIndex() ) const;\n  bool removeRows( int row, int count, const QModelIndex &parent );\n  bool setData( const QModelIndex &index, const QVariant &value, int role );\n\n  // Drag & drop support\n  Qt::DropActions supportedDropActions() const;\n  QStringList mimeTypes() const;\n  QMimeData *mimeData(const QModelIndexList &indexes) const;\n  bool dropMimeData(const QMimeData *data, Qt::DropAction action,\n                    int row, int column, const QModelIndex &par);\n\n  // Restore nodes expanded state after data loading\n  void checkNodeForExpand( const TreeItem * item, const QModelIndex &parent );\n  void checkAllNodesForExpand();\n\n  // Retrieve text data for indexes\n  QStringList getTextForIndexes( QModelIndexList const & idxList ) const;\n\n  // Delete items for indexes\n  void removeItemsForIndexes( QModelIndexList const & idxList );\n\n  // Add new folder beside item and return its index\n  // or empty index if fail\n  QModelIndex addNewFolder( QModelIndex const & idx );\n\n  // Add new headword to given folder\n  // return false if it already exists there\n  bool addNewHeadword( QString const & path, QString const & headword );\n\n  // Remove headword from given folder\n  // return false if failed\n  bool removeHeadword( QString const & path, QString const & headword );\n\n  // Return true if headwors is already presented in Favorites\n  bool isHeadwordPresent( QString const & path, QString const & headword );\n\n  // Return path in the tree to item\n  QString pathToItem( QModelIndex const & idx );\n\n  TreeItem::Type itemType( QModelIndex const & idx )\n  { return getItem( idx )->type(); }\n\n  // Export/import Favorites\n  void getDataInXml( QByteArray & dataStr );\n  void getDataInPlainText( QString & dataStr );\n  bool setDataFromXml( QString const & dataStr );\n\n  void saveData();\n\npublic slots:\n  void itemCollapsed ( const QModelIndex & index );\n  void itemExpanded ( const QModelIndex & index );\n\nsignals:\n  void expandItem( const QModelIndex & index );\n\nprotected:\n  void readData();\n  void addFolder( TreeItem * parent, QDomNode & node );\n  void storeFolder( TreeItem * folder, QDomNode & node );\n\n  // Find item in folder\n  QModelIndex findItemInFolder( QString const & itemName, int itemType,\n                                QModelIndex const & parentIdx );\n\n  TreeItem *getItem( const QModelIndex &index ) const;\n\n  // Find folder with given name or create it if folder not exist\n  QModelIndex forceFolder( QString const & name, QModelIndex const & parentIdx );\n\n  // Add headword to given folder\n  // return false if such headwordalready exists\n  bool addHeadword( QString const & word, QModelIndex const & parentIdx );\n\n  // Return tree level for item\n  int level( QModelIndex const & idx );\n\nprivate:\n  QString m_favoritesFilename;\n  TreeItem * rootItem;\n  QDomDocument dom;\n  bool dirty;\n};\n\n#define FAVORITES_MIME_TYPE \"application/x-goldendict-tree-items\"\n\nclass FavoritesMimeData : public QMimeData\n{\n  Q_OBJECT\npublic:\n  FavoritesMimeData() : QMimeData()\n  {}\n\n  virtual QStringList formats() const\n  { return QStringList( QString::fromLatin1( FAVORITES_MIME_TYPE ) ); }\n\n  virtual bool hasFormat(const QString & mimetype) const\n  { return mimetype.compare( QString::fromLatin1( FAVORITES_MIME_TYPE ) ) == 0; }\n\n  void setIndexesList( QModelIndexList const & list )\n  { indexes.clear(); indexes = list; }\n\n  QModelIndexList const & getIndexesList() const\n  { return indexes; }\n\nprivate:\n  QStringList mimeFormats;\n  QModelIndexList indexes;\n};\n\n#endif // __FAVORITIESPANEWIDGET_HH__INCLUDED__\n"
        },
        {
          "name": "ffmpegaudio.cc",
          "type": "blob",
          "size": 17.6298828125,
          "content": "#ifdef MAKE_FFMPEG_PLAYER\n\n#include \"ffmpegaudio.hh\"\n\n#include <math.h>\n#include <errno.h>\n\n#ifndef INT64_C\n#define INT64_C(c) (c ## LL)\n#endif\n\n#ifndef UINT64_C\n#define UINT64_C(c) (c ## ULL)\n#endif\n\n#include <ao/ao.h>\n\nextern \"C\" {\n#include <libavcodec/avcodec.h>\n#include <libavformat/avformat.h>\n#include <libavutil/avutil.h>\n#include \"libswresample/swresample.h\"\n}\n\n#include <QString>\n#include <QDataStream>\n#include <QDebug>\n\n#include <vector>\n\n#include \"gddebug.hh\"\n#include \"qt4x5.hh\"\n\nusing std::vector;\n\nnamespace Ffmpeg\n{\n\nQMutex DecoderThread::deviceMutex_;\n\nstatic inline QString avErrorString( int errnum )\n{\n  char buf[64];\n  av_strerror( errnum, buf, 64 );\n  return QString::fromLatin1( buf );\n}\n\nAudioService & AudioService::instance()\n{\n  static AudioService a;\n  return a;\n}\n\nAudioService::AudioService()\n{\n#if LIBAVFORMAT_VERSION_MAJOR < 58 || ( LIBAVFORMAT_VERSION_MAJOR == 58 && LIBAVFORMAT_VERSION_MINOR < 9 )\n  av_register_all();\n#endif\n  ao_initialize();\n}\n\nAudioService::~AudioService()\n{\n  emit cancelPlaying( true );\n  ao_shutdown();\n}\n\nvoid AudioService::playMemory( const char * ptr, int size )\n{\n  emit cancelPlaying( false );\n  QByteArray audioData( ptr, size );\n  DecoderThread * thread = new DecoderThread( audioData, this );\n\n  connect( thread, SIGNAL( error( QString ) ), this, SIGNAL( error( QString ) ) );\n  connect( this, SIGNAL( cancelPlaying( bool ) ), thread, SLOT( cancel( bool ) ), Qt::DirectConnection );\n  connect( thread, SIGNAL( finished() ), thread, SLOT( deleteLater() ) );\n\n  thread->start();\n}\n\nvoid AudioService::stop()\n{\n  emit cancelPlaying( false );\n}\n\nstruct DecoderContext\n{\n  enum\n  {\n    kBufferSize = 32768\n  };\n\n  static QMutex deviceMutex_;\n  QAtomicInt & isCancelled_;\n  QByteArray audioData_;\n  QDataStream audioDataStream_;\n  AVFormatContext * formatContext_;\n#if LIBAVCODEC_VERSION_MAJOR < 59\n  AVCodec * codec_;\n#else\n  const AVCodec * codec_;\n#endif\n  AVCodecContext * codecContext_;\n  AVIOContext * avioContext_;\n  AVStream * audioStream_;\n  ao_device * aoDevice_;\n  bool avformatOpened_;\n\n  SwrContext *swr_;\n\n  DecoderContext( QByteArray const & audioData, QAtomicInt & isCancelled );\n  ~DecoderContext();\n\n  bool openCodec( QString & errorString );\n  void closeCodec();\n  bool openOutputDevice( QString & errorString );\n  void closeOutputDevice();\n  bool play( QString & errorString );\n  bool normalizeAudio( AVFrame * frame, vector<char> & samples );\n  void playFrame( AVFrame * frame );\n  int nbChannels() {\n#if LIBAVCODEC_VERSION_MAJOR >= 61\n    return codecContext_->ch_layout.nb_channels;\n#else\n    return codecContext_->channels;\n#endif\n  }\n};\n\nDecoderContext::DecoderContext( QByteArray const & audioData, QAtomicInt & isCancelled ):\n  isCancelled_( isCancelled ),\n  audioData_( audioData ),\n  audioDataStream_( audioData_ ),\n  formatContext_( NULL ),\n  codec_( NULL ),\n  codecContext_( NULL ),\n  avioContext_( NULL ),\n  audioStream_( NULL ),\n  aoDevice_( NULL ),\n  avformatOpened_( false ),\n  swr_( NULL )\n{\n}\n\nDecoderContext::~DecoderContext()\n{\n  closeOutputDevice();\n  closeCodec();\n}\n\nstatic int readAudioData( void * opaque, unsigned char * buffer, int bufferSize )\n{\n  QDataStream * pStream = ( QDataStream * )opaque;\n  // This function is passed as the read_packet callback into avio_alloc_context().\n  // The documentation for this callback parameter states:\n  // For stream protocols, must never return 0 but rather a proper AVERROR code.\n  if( pStream->atEnd() )\n    return AVERROR_EOF;\n  const int bytesRead = pStream->readRawData( ( char * )buffer, bufferSize );\n  // QDataStream::readRawData() returns 0 at EOF => return AVERROR_EOF in this case.\n  // An error is unlikely here, so just print a warning and return AVERROR_EOF too.\n  if( bytesRead < 0 )\n    gdWarning( \"readAudioData: error while reading raw data.\" );\n  return bytesRead > 0 ? bytesRead : AVERROR_EOF;\n}\n\nbool DecoderContext::openCodec( QString & errorString )\n{\n  formatContext_ = avformat_alloc_context();\n  if ( !formatContext_ )\n  {\n    errorString = QObject::tr( \"avformat_alloc_context() failed.\" );\n    return false;\n  }\n\n#if LIBAVCODEC_VERSION_MAJOR < 56 || ( LIBAVCODEC_VERSION_MAJOR == 56 && LIBAVCODEC_VERSION_MINOR < 56 )\n  unsigned char * avioBuffer = ( unsigned char * )av_malloc( kBufferSize + FF_INPUT_BUFFER_PADDING_SIZE );\n#else\n  unsigned char * avioBuffer = ( unsigned char * )av_malloc( kBufferSize + AV_INPUT_BUFFER_PADDING_SIZE );\n#endif\n  if ( !avioBuffer )\n  {\n    errorString = QObject::tr( \"av_malloc() failed.\" );\n    return false;\n  }\n\n  // Don't free buffer allocated here (if succeeded), it will be cleaned up automatically.\n  avioContext_ = avio_alloc_context( avioBuffer, kBufferSize, 0, &audioDataStream_, readAudioData, NULL, NULL );\n  if ( !avioContext_ )\n  {\n    av_free( avioBuffer );\n    errorString = QObject::tr( \"avio_alloc_context() failed.\" );\n    return false;\n  }\n\n  avioContext_->seekable = 0;\n  avioContext_->write_flag = 0;\n\n  // If pb not set, avformat_open_input() simply crash.\n  formatContext_->pb = avioContext_;\n  formatContext_->flags |= AVFMT_FLAG_CUSTOM_IO;\n\n  int ret = 0;\n  avformatOpened_ = true;\n\n  ret = avformat_open_input( &formatContext_, \"_STREAM_\", NULL, NULL );\n  if ( ret < 0 )\n  {\n    errorString = QObject::tr( \"avformat_open_input() failed: %1.\" ).arg( avErrorString( ret ) );\n    return false;\n  }\n\n  ret = avformat_find_stream_info( formatContext_, NULL );\n  if ( ret < 0 )\n  {\n    errorString = QObject::tr( \"avformat_find_stream_info() failed: %1.\" ).arg( avErrorString( ret ) );\n    return false;\n  }\n\n  // Find audio stream, use the first audio stream if available\n  for ( unsigned i = 0; i < formatContext_->nb_streams; i++ )\n  {\n#if LIBAVCODEC_VERSION_MAJOR < 57 || ( LIBAVCODEC_VERSION_MAJOR == 57 && LIBAVCODEC_VERSION_MINOR < 33 )\n    if ( formatContext_->streams[i]->codec->codec_type == AVMEDIA_TYPE_AUDIO )\n#else\n      if ( formatContext_->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_AUDIO )\n#endif\n    {\n      audioStream_ = formatContext_->streams[i];\n      break;\n    }\n  }\n  if ( !audioStream_ )\n  {\n    errorString = QObject::tr( \"Could not find audio stream.\" );\n    return false;\n  }\n\n#if LIBAVCODEC_VERSION_MAJOR < 57 || ( LIBAVCODEC_VERSION_MAJOR == 57 && LIBAVCODEC_VERSION_MINOR < 33 )\n  codecContext_ = audioStream_->codec;\n  codec_ = avcodec_find_decoder( codecContext_->codec_id );\n  if ( !codec_ )\n  {\n    errorString = QObject::tr( \"Codec [id: %1] not found.\" ).arg( codecContext_->codec_id );\n    return false;\n  }\n#else\n  codec_ = avcodec_find_decoder( audioStream_->codecpar->codec_id );\n  if ( !codec_ )\n  {\n    errorString = QObject::tr( \"Codec [id: %1] not found.\" ).arg( audioStream_->codecpar->codec_id );\n    return false;\n  }\n  codecContext_ = avcodec_alloc_context3( codec_ );\n  if ( !codecContext_ )\n  {\n    errorString = QObject::tr( \"avcodec_alloc_context3() failed.\" );\n    return false;\n  }\n  avcodec_parameters_to_context( codecContext_, audioStream_->codecpar );\n#endif\n\n  ret = avcodec_open2( codecContext_, codec_, NULL );\n  if ( ret < 0 )\n  {\n    errorString = QObject::tr( \"avcodec_open2() failed: %1.\" ).arg( avErrorString( ret ) );\n    return false;\n  }\n\n  gdDebug( \"Codec open: %s: channels: %d, rate: %d, format: %s\\n\", codec_->long_name,\n          nbChannels(), codecContext_->sample_rate, av_get_sample_fmt_name( codecContext_->sample_fmt ) );\n\n  if ( codecContext_->sample_fmt == AV_SAMPLE_FMT_S32  ||\n       codecContext_->sample_fmt == AV_SAMPLE_FMT_S32P ||\n       codecContext_->sample_fmt == AV_SAMPLE_FMT_FLT  ||\n       codecContext_->sample_fmt == AV_SAMPLE_FMT_FLTP ||\n       codecContext_->sample_fmt == AV_SAMPLE_FMT_DBL  ||\n       codecContext_->sample_fmt == AV_SAMPLE_FMT_DBLP )\n  {\n#if LIBAVCODEC_VERSION_MAJOR >= 61\n    int ret = swr_alloc_set_opts2( &swr_,\n        &codecContext_->ch_layout,\n        AV_SAMPLE_FMT_S16,\n        codecContext_->sample_rate,\n        &codecContext_->ch_layout,\n        codecContext_->sample_fmt,\n        codecContext_->sample_rate,\n        0,\n        NULL );\n    if ( ret < 0 ) {\n      errorString = QObject::tr( \"swr_alloc_set_opts2() failed: %1.\" ).arg( avErrorString( ret ) );\n      return false;\n    }\n#else\n    swr_ = swr_alloc_set_opts( NULL,\n        codecContext_->channel_layout,\n        AV_SAMPLE_FMT_S16,\n        codecContext_->sample_rate,\n        codecContext_->channel_layout,\n        codecContext_->sample_fmt,\n        codecContext_->sample_rate,\n        0,\n        NULL );\n#endif\n    swr_init( swr_ );\n  }\n\n  return true;\n}\n\nvoid DecoderContext::closeCodec()\n{\n  if ( swr_ )\n  {\n    swr_free( &swr_ );\n  }\n\n  if ( !formatContext_ )\n  {\n    if ( avioContext_ )\n    {\n      av_free( avioContext_->buffer );\n      avioContext_ = NULL;\n    }\n    return;\n  }\n\n  // avformat_open_input() is not called, just free the buffer associated with\n  // the AVIOContext, and the AVFormatContext\n  if ( !avformatOpened_ )\n  {\n    if ( formatContext_ )\n    {\n      avformat_free_context( formatContext_ );\n      formatContext_ = NULL;\n    }\n\n    if ( avioContext_ )\n    {\n      av_free( avioContext_->buffer );\n      avioContext_ = NULL;\n    }\n    return;\n  }\n\n  avformatOpened_ = false;\n\n  // Closing a codec context without prior avcodec_open2() will result in\n  // a crash in ffmpeg\n  if ( audioStream_ && codecContext_ && codec_ )\n  {\n    audioStream_->discard = AVDISCARD_ALL;\n    avcodec_close( codecContext_ );\n#if LIBAVCODEC_VERSION_MAJOR > 57 || ( LIBAVCODEC_VERSION_MAJOR == 57 && LIBAVCODEC_VERSION_MINOR >= 33 )\n    avcodec_free_context( &codecContext_ );\n#endif\n  }\n\n  avformat_close_input( &formatContext_ );\n  av_free( avioContext_->buffer );\n}\n\nbool DecoderContext::openOutputDevice( QString & errorString )\n{\n  // Prepare for audio output\n  int aoDriverId = ao_default_driver_id();\n  ao_info * aoDrvInfo = ao_driver_info( aoDriverId );\n\n  if ( aoDriverId < 0 || !aoDrvInfo )\n  {\n    errorString = QObject::tr( \"Cannot find usable audio output device.\" );\n    return false;\n  }\n\n  ao_sample_format aoSampleFormat;\n  memset (&aoSampleFormat, 0, sizeof(aoSampleFormat) );\n  aoSampleFormat.channels = nbChannels();\n  aoSampleFormat.rate = codecContext_->sample_rate;\n  aoSampleFormat.byte_format = AO_FMT_NATIVE;\n  aoSampleFormat.matrix = 0;\n  aoSampleFormat.bits = qMin( 16, av_get_bytes_per_sample( codecContext_->sample_fmt ) << 3 );\n\n  if ( aoSampleFormat.bits == 0 )\n  {\n    errorString = QObject::tr( \"Unsupported sample format.\" );\n    return false;\n  }\n\n  gdDebug( \"ao_open_live(): %s: channels: %d, rate: %d, bits: %d\\n\",\n          aoDrvInfo->name, aoSampleFormat.channels, aoSampleFormat.rate, aoSampleFormat.bits );\n\n  aoDevice_ = ao_open_live( aoDriverId, &aoSampleFormat, NULL );\n  if ( !aoDevice_ )\n  {\n    errorString = QObject::tr( \"ao_open_live() failed: \" );\n\n    switch ( errno )\n    {\n      case AO_ENODRIVER:\n        errorString += QObject::tr( \"No driver.\" );\n        break;\n      case AO_ENOTLIVE:\n        errorString += QObject::tr( \"This driver is not a live output device.\" );\n        break;\n      case AO_EBADOPTION:\n        errorString += QObject::tr( \"A valid option key has an invalid value.\" );\n        break;\n      case AO_EOPENDEVICE:\n        errorString += QObject::tr( \"Cannot open the device: %1, channels: %2, rate: %3, bits: %4.\" )\n                       .arg( aoDrvInfo->short_name )\n                       .arg( aoSampleFormat.channels )\n                       .arg( aoSampleFormat.rate )\n                       .arg( aoSampleFormat.bits );\n        break;\n      default:\n        errorString += QObject::tr( \"Unknown error.\" );\n        break;\n    }\n\n    return false;\n  }\n\n  return true;\n}\n\nvoid DecoderContext::closeOutputDevice()\n{\n  // ao_close() is synchronous, it will wait until all audio streams flushed\n  if ( aoDevice_ )\n  {\n    ao_close( aoDevice_ );\n    aoDevice_ = NULL;\n  }\n}\n\nbool DecoderContext::play( QString & errorString )\n{\n#if LIBAVCODEC_VERSION_MAJOR < 55 || ( LIBAVCODEC_VERSION_MAJOR == 55 && LIBAVCODEC_VERSION_MINOR < 28 )\n  AVFrame * frame = avcodec_alloc_frame();\n#else\n  AVFrame * frame = av_frame_alloc();\n#endif\n  if ( !frame )\n  {\n    errorString = QObject::tr( \"avcodec_alloc_frame() failed.\" );\n    return false;\n  }\n\n  AVPacket packet;\n  av_init_packet( &packet );\n\n  while ( !Qt4x5::AtomicInt::loadAcquire( isCancelled_ ) &&\n          av_read_frame( formatContext_, &packet ) >= 0 )\n  {\n    if ( packet.stream_index == audioStream_->index )\n    {\n      AVPacket pack = packet;\n#if LIBAVCODEC_VERSION_MAJOR < 57 || ( LIBAVCODEC_VERSION_MAJOR == 57 && LIBAVCODEC_VERSION_MINOR < 37 )\n      int gotFrame = 0;\n      do\n      {\n        int len = avcodec_decode_audio4( codecContext_, frame, &gotFrame, &pack );\n        if ( !Qt4x5::AtomicInt::loadAcquire( isCancelled_ ) && gotFrame )\n        {\n          playFrame( frame );\n        }\n        if( len <= 0 || Qt4x5::AtomicInt::loadAcquire( isCancelled_ ) )\n          break;\n        pack.size -= len;\n        pack.data += len;\n      }\n      while( pack.size > 0 );\n#else\n      int ret = avcodec_send_packet( codecContext_, &pack );\n      /* read all the output frames (in general there may be any number of them) */\n      while( ret >= 0 )\n      {\n        ret = avcodec_receive_frame( codecContext_, frame);\n\n        if ( Qt4x5::AtomicInt::loadAcquire( isCancelled_ ) || ret < 0 )\n          break;\n\n        playFrame( frame );\n      }\n#endif\n    }\n    // av_free_packet() must be called after each call to av_read_frame()\n#if LIBAVCODEC_VERSION_MAJOR < 57 || ( LIBAVCODEC_VERSION_MAJOR == 57 && LIBAVCODEC_VERSION_MINOR < 7 )\n    av_free_packet( &packet );\n#else\n    av_packet_unref( &packet );\n#endif\n  }\n\n#if LIBAVCODEC_VERSION_MAJOR < 57 || ( LIBAVCODEC_VERSION_MAJOR == 57 && LIBAVCODEC_VERSION_MINOR < 37 )\n  if ( !Qt4x5::AtomicInt::loadAcquire( isCancelled_ ) &&\n       codecContext_->codec->capabilities & CODEC_CAP_DELAY )\n  {\n    av_init_packet( &packet );\n    int gotFrame = 0;\n    while ( avcodec_decode_audio4( codecContext_, frame, &gotFrame, &packet ) >= 0 && gotFrame )\n    {\n      if ( Qt4x5::AtomicInt::loadAcquire( isCancelled_ ) )\n        break;\n      playFrame( frame );\n    }\n  }\n#else\n  /* flush the decoder */\n  av_init_packet( &packet );\n  packet.data = NULL;\n  packet.size = 0;\n  int ret = avcodec_send_packet(codecContext_, &packet );\n  while( ret >= 0 )\n  {\n    ret = avcodec_receive_frame(codecContext_, frame);\n    if ( Qt4x5::AtomicInt::loadAcquire( isCancelled_ ) || ret < 0 )\n      break;\n    playFrame( frame );\n  }\n#endif\n\n#if LIBAVCODEC_VERSION_MAJOR < 54\n  av_free( frame );\n#elif LIBAVCODEC_VERSION_MAJOR < 55 || ( LIBAVCODEC_VERSION_MAJOR == 55 && LIBAVCODEC_VERSION_MINOR < 28 )\n  avcodec_free_frame( &frame );\n#else\n  av_frame_free( &frame );\n#endif\n\n  return true;\n}\n\nstatic inline int32_t toInt32( double v )\n{\n  if ( v >= 1.0 )\n    return 0x7fffffffL;\n  else if ( v <= -1.0 )\n    return 0x80000000L;\n  return floor( v * 2147483648.0 );\n}\n\nbool DecoderContext::normalizeAudio( AVFrame * frame, vector<char> & samples )\n{\n  int lineSize = 0;\n  int dataSize = av_samples_get_buffer_size( &lineSize, nbChannels(),\n                                             frame->nb_samples, codecContext_->sample_fmt, 1 );\n\n  // Portions from: https://code.google.com/p/lavfilters/source/browse/decoder/LAVAudio/LAVAudio.cpp\n  // But this one use 8, 16, 32 bits integer, respectively.\n  switch ( codecContext_->sample_fmt )\n  {\n    case AV_SAMPLE_FMT_U8:\n    case AV_SAMPLE_FMT_S16:\n    {\n      samples.resize( dataSize );\n      memcpy( &samples.front(), frame->data[0], lineSize );\n    }\n    break;\n    // Planar\n    case AV_SAMPLE_FMT_U8P:\n    {\n      samples.resize( dataSize );\n\n      uint8_t * out = ( uint8_t * )&samples.front();\n      for ( int i = 0; i < frame->nb_samples; i++ )\n      {\n        for ( int ch = 0; ch < nbChannels(); ch++ )\n        {\n          *out++ = ( ( uint8_t * )frame->extended_data[ch] )[i];\n        }\n      }\n    }\n    break;\n    case AV_SAMPLE_FMT_S16P:\n    {\n      samples.resize( dataSize );\n\n      int16_t * out = ( int16_t * )&samples.front();\n      for ( int i = 0; i < frame->nb_samples; i++ )\n      {\n        for ( int ch = 0; ch < nbChannels(); ch++ )\n        {\n          *out++ = ( ( int16_t * )frame->extended_data[ch] )[i];\n        }\n      }\n    }\n    break;\n    case AV_SAMPLE_FMT_S32:\n    /* Pass through */\n    case AV_SAMPLE_FMT_S32P:\n    /* Pass through */\n    case AV_SAMPLE_FMT_FLT:\n    /* Pass through */\n    case AV_SAMPLE_FMT_FLTP:\n    /* Pass through */\n    {\n      samples.resize( dataSize / 2 );\n\n      uint8_t *out = ( uint8_t * )&samples.front();\n      swr_convert( swr_, &out, frame->nb_samples, (const uint8_t**)frame->extended_data, frame->nb_samples );\n    }\n    break;\n    case AV_SAMPLE_FMT_DBL:\n    case AV_SAMPLE_FMT_DBLP:\n    {\n      samples.resize( dataSize / 4 );\n\n      uint8_t *out = ( uint8_t * )&samples.front();\n      swr_convert( swr_, &out, frame->nb_samples, (const uint8_t**)frame->extended_data, frame->nb_samples );\n    }\n    break;\n    default:\n      return false;\n  }\n\n  return true;\n}\n\nvoid DecoderContext::playFrame( AVFrame * frame )\n{\n  if ( !frame )\n    return;\n\n  vector<char> samples;\n  if ( normalizeAudio( frame, samples ) )\n    ao_play( aoDevice_, &samples.front(), samples.size() );\n}\n\nDecoderThread::DecoderThread( QByteArray const & audioData, QObject * parent ) :\n  QThread( parent ),\n  isCancelled_( 0 ),\n  audioData_( audioData )\n{\n}\n\nDecoderThread::~DecoderThread()\n{\n  isCancelled_.ref();\n}\n\nvoid DecoderThread::run()\n{\n  QString errorString;\n  DecoderContext d( audioData_, isCancelled_ );\n\n  if ( !d.openCodec( errorString ) )\n  {\n    emit error( errorString );\n    return;\n  }\n\n  while ( !deviceMutex_.tryLock( 100 ) )\n  {\n    if ( Qt4x5::AtomicInt::loadAcquire( isCancelled_ ) )\n      return;\n  }\n\n  if ( !d.openOutputDevice( errorString ) )\n    emit error( errorString );\n  else if ( !d.play( errorString ) )\n    emit error( errorString );\n\n  d.closeOutputDevice();\n  deviceMutex_.unlock();\n}\n\nvoid DecoderThread::cancel( bool waitUntilFinished )\n{\n  isCancelled_.ref();\n  if ( waitUntilFinished )\n    this->wait();\n}\n\n}\n\n#endif // MAKE_FFMPEG_PLAYER\n"
        },
        {
          "name": "ffmpegaudio.hh",
          "type": "blob",
          "size": 0.9384765625,
          "content": "#ifndef __FFMPEGAUDIO_HH_INCLUDED__\n#define __FFMPEGAUDIO_HH_INCLUDED__\n\n#ifdef MAKE_FFMPEG_PLAYER\n\n#include <QObject>\n#include <QMutex>\n#include <QAtomicInt>\n#include <QByteArray>\n#include <QThread>\n\nnamespace Ffmpeg\n{\n\nclass AudioService : public QObject\n{\n  Q_OBJECT\n\npublic:\n  static AudioService & instance();\n  void playMemory( const char * ptr, int size );\n  void stop();\n\nsignals:\n  void cancelPlaying( bool waitUntilFinished );\n  void error( QString const & message );\n\nprivate:\n  AudioService();\n  ~AudioService();\n};\n\nclass DecoderThread: public QThread\n{\n  Q_OBJECT\n\n  static QMutex deviceMutex_;\n  QAtomicInt isCancelled_;\n  QByteArray audioData_;\n\npublic:\n  DecoderThread( QByteArray const & audioData, QObject * parent );\n  virtual ~DecoderThread();\n\npublic slots:\n  void run();\n  void cancel( bool waitUntilFinished );\n\nsignals:\n  void error( QString const & message );\n};\n\n}\n\n#endif // MAKE_FFMPEG_PLAYER\n\n#endif // __FFMPEGAUDIO_HH_INCLUDED__\n"
        },
        {
          "name": "ffmpegaudioplayer.hh",
          "type": "blob",
          "size": 0.8359375,
          "content": "/* This file is (c) 2018 Igor Kushnir <igorkuo@gmail.com>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef FFMPEGAUDIOPLAYER_HH_INCLUDED\n#define FFMPEGAUDIOPLAYER_HH_INCLUDED\n\n#include \"audioplayerinterface.hh\"\n#include \"ffmpegaudio.hh\"\n\n#ifdef MAKE_FFMPEG_PLAYER\n\nnamespace Ffmpeg\n{\n\nclass AudioPlayer : public AudioPlayerInterface\n{\n  Q_OBJECT\npublic:\n  AudioPlayer()\n  {\n    connect( &AudioService::instance(), SIGNAL( error( QString ) ),\n             this, SIGNAL( error( QString ) ) );\n  }\n\n  ~AudioPlayer()\n  {\n    stop();\n  }\n\n  virtual QString play( const char * data, int size )\n  {\n    AudioService::instance().playMemory( data, size );\n    return QString();\n  }\n\n  virtual void stop()\n  {\n    AudioService::instance().stop();\n  }\n};\n\n}\n\n#endif // MAKE_FFMPEG_PLAYER\n\n#endif // FFMPEGAUDIOPLAYER_HH_INCLUDED\n"
        },
        {
          "name": "file.cc",
          "type": "blob",
          "size": 6.9384765625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"file.hh\"\n\n#include <cstring>\n#include <cerrno>\n#include <string>\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#ifndef _MSC_VER\n#include <unistd.h>\n#endif\n\n#ifdef __WIN32\n#include <windows.h>\n#endif\n\n#include \"ufile.hh\"\n#include \"fsencoding.hh\"\n#include \"zipfile.hh\"\n\nnamespace File {\n\nenum\n{\n  // We employ a writing buffer to considerably speed up file operations when\n  // they consists of many small writes. The default size for the buffer is 64k\n  WriteBufferSize = 65536\n};\n\nbool tryPossibleName( std::string const & name, std::string & copyTo )\n{\n  if ( File::exists( name ) )\n  {\n    copyTo = name;\n    return true;\n  }\n  else\n    return false;\n}\n\nbool tryPossibleZipName( std::string const & name, std::string & copyTo )\n{\n  if ( ZipFile::SplitZipFile( FsEncoding::decode( name.c_str() ) ).exists() )\n  {\n    copyTo = name;\n    return true;\n  }\n  else\n    return false;\n}\n\nvoid loadFromFile( std::string const & n, std::vector< char > & data )\n{\n  File::Class f( n, \"rb\" );\n\n  f.seekEnd();\n\n  data.resize( f.tell() );\n\n  f.rewind();\n\n  f.read( &data.front(), data.size() );\n}\n\nbool exists( char const * filename ) throw()\n{\n#ifdef __WIN32\n  struct _stat buf;\n  wchar_t wname[16384];\n  MultiByteToWideChar( CP_UTF8, 0, filename, -1, wname, 16384 );\n  return _wstat( wname, &buf ) == 0;\n#else\n  struct stat buf;\n\n  // EOVERFLOW rationale: if the file is too large, it still does exist\n  return stat( filename, &buf ) == 0 || errno == EOVERFLOW;\n#endif\n}\n\nvoid Class::open( char const * filename, char const * mode ) THROW_SPEC( exCantOpen )\n{\n  QFile::OpenMode openMode = QIODevice::Text;\n  const char * pch = mode;\n  while( *pch )\n  {\n    switch( *pch )\n    {\n      case 'r': openMode |= QIODevice::ReadOnly;\n                break;\n      case 'w': openMode |= QIODevice::WriteOnly;\n                break;\n      case '+': openMode &= ~( QIODevice::ReadOnly | QIODevice::WriteOnly );\n                openMode |= QIODevice::ReadWrite;\n                break;\n      case 'a': openMode |= QIODevice::Append;\n                break;\n      case 'b': openMode &= ~QIODevice::Text;\n                break;\n      default:  break;\n    }\n    ++pch;\n  }\n\n  f.setFileName( FsEncoding::decode( filename ) );\n\n  if ( !f.open( openMode ) )\n    throw exCantOpen( std::string( filename ) + \": \" + f.errorString().toUtf8().data() );\n}\n\nClass::Class( char const * filename, char const * mode ) THROW_SPEC( exCantOpen ):\n  writeBuffer( 0 )\n{\n  open( filename, mode );\n}\n\nClass::Class( std::string const & filename, char const * mode )\n  THROW_SPEC( exCantOpen ): writeBuffer( 0 )\n{\n  open( filename.c_str(), mode );\n}\n\nvoid Class::read( void * buf, qint64 size ) THROW_SPEC( exReadError, exWriteError )\n{\n  if ( !size )\n    return;\n\n  if ( writeBuffer )\n    flushWriteBuffer();\n\n  qint64 result = f.read( reinterpret_cast<char *>( buf ), size );\n\n  if ( result != size )\n    throw exReadError();\n}\n\nsize_t Class::readRecords( void * buf, qint64 size, size_t count ) THROW_SPEC( exWriteError )\n{\n  if ( writeBuffer )\n    flushWriteBuffer();\n\n  qint64 result = f.read( reinterpret_cast<char *>( buf ), size * count );\n  return result < 0 ? result : result / size;\n}\n\nvoid Class::write( void const * buf, qint64 size ) THROW_SPEC( exWriteError, exAllocation )\n{\n  if ( !size )\n    return;\n\n  if ( size >= WriteBufferSize )\n  {\n    // If the write is large, there's not much point in buffering\n    flushWriteBuffer();\n\n    qint64 result = f.write( reinterpret_cast<char const *>( buf ), size );\n\n    if ( result != size )\n      throw exWriteError();\n\n    return;\n  }\n\n  if ( !writeBuffer )\n  {\n    // Allocate the writing buffer since we don't have any yet\n    writeBuffer = new char[ WriteBufferSize ];\n    if( !writeBuffer )\n      throw exAllocation();\n    writeBufferLeft = WriteBufferSize;\n  }\n\n  size_t toAdd = size < writeBufferLeft ? size : writeBufferLeft;\n\n  memcpy( writeBuffer + ( WriteBufferSize - writeBufferLeft ),\n          buf, toAdd );\n\n  size -= toAdd;\n  writeBufferLeft -= toAdd;\n\n  if ( !writeBufferLeft ) // Out of buffer? Flush it.\n  {\n    flushWriteBuffer();\n\n    if ( size ) // Something's still left? Add to buffer.\n    {\n      memcpy( writeBuffer, (char const *)buf + toAdd, size );\n      writeBufferLeft -= size;\n    }\n  }\n}\n\nsize_t Class::writeRecords( void const * buf, qint64 size, size_t count )\n  THROW_SPEC( exWriteError )\n{\n  flushWriteBuffer();\n\n  qint64 result = f.write( reinterpret_cast<const char *>( buf ), size * count );\n  return result < 0 ? result : result / size;\n}\n\nchar * Class::gets( char * s, int size, bool stripNl )\n  THROW_SPEC( exWriteError )\n{\n  if ( writeBuffer )\n    flushWriteBuffer();\n\n  qint64 len = f.readLine( s, size );\n  char * result = len > 0 ? s : NULL;\n\n  if ( result && stripNl )\n  {\n    \n    char * last = result + len;\n\n    while( len-- )\n    {\n      --last;\n\n      if ( *last == '\\n' || *last == '\\r' )\n        *last = 0;\n      else\n        break;\n    }\n  }\n\n  return result;\n}\n\nstd::string Class::gets( bool stripNl ) THROW_SPEC( exReadError, exWriteError )\n{\n  char buf[ 1024 ];\n\n  if ( !gets( buf, sizeof( buf ), stripNl ) )\n    throw exReadError();\n\n  return std::string( buf );\n}\n\nvoid Class::seek( qint64 offset ) THROW_SPEC( exSeekError, exWriteError )\n{\n  if ( writeBuffer )\n    flushWriteBuffer();\n\n  if ( !f.seek( offset ) )\n    throw exSeekError();\n}\n\nvoid Class::seekCur( qint64 offset ) THROW_SPEC( exSeekError, exWriteError )\n{\n  if ( writeBuffer )\n    flushWriteBuffer();\n\n  if( !f.seek( f.pos() + offset ) )\n    throw exSeekError();\n}\n\nvoid Class::seekEnd( qint64 offset ) THROW_SPEC( exSeekError, exWriteError )\n{\n  if ( writeBuffer )\n    flushWriteBuffer();\n\n  if( !f.seek( f.size() + offset ) )\n    throw exSeekError();\n}\n\nvoid Class::rewind() THROW_SPEC( exSeekError, exWriteError )\n{\n  seek( 0 );\n}\n\nqint64 Class::tell() THROW_SPEC( exSeekError )\n{\n  qint64 result = f.pos();\n\n  if ( result == -1 )\n    throw exSeekError();\n\n  if ( writeBuffer )\n    result += ( WriteBufferSize - writeBufferLeft );\n\n  return result;\n}\n\nbool Class::eof() THROW_SPEC( exWriteError )\n{\n  if ( writeBuffer )\n    flushWriteBuffer();\n\n  return f.atEnd();\n}\n\nQFile & Class::file() THROW_SPEC( exWriteError )\n{\n  flushWriteBuffer();\n\n  return f;\n}\n\nvoid Class::close() THROW_SPEC( exWriteError )\n{\n  releaseWriteBuffer();\n  f.close();\n}\n\nClass::~Class() throw()\n{\n  if ( f.isOpen() )\n  {\n    try\n    {\n      releaseWriteBuffer();\n    }\n    catch( exWriteError & )\n    {\n    }\n    f.close();\n  }\n}\n\nvoid Class::flushWriteBuffer() THROW_SPEC( exWriteError )\n{\n  if ( writeBuffer && writeBufferLeft != WriteBufferSize )\n  {\n    qint64 result = f.write( writeBuffer, WriteBufferSize - writeBufferLeft );\n\n    if ( result != WriteBufferSize - writeBufferLeft )\n      throw exWriteError();\n\n    writeBufferLeft = WriteBufferSize;\n  }\n}\n\nvoid Class::releaseWriteBuffer() THROW_SPEC( exWriteError )\n{\n  flushWriteBuffer();\n\n  if ( writeBuffer )\n  {\n    delete [] writeBuffer;\n\n    writeBuffer = 0;\n  }\n}\n\n\n}\n"
        },
        {
          "name": "file.hh",
          "type": "blob",
          "size": 4.65625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __FILE_HH_INCLUDED__\n#define __FILE_HH_INCLUDED__\n\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <QFile>\n#include \"cpp_features.hh\"\n#include \"ex.hh\"\n\n/// A simple wrapper over FILE * operations with added write-buffering,\n/// used for non-Qt parts of code.\n/// It is possible to ifdef implementation details for some platforms.\nnamespace File {\n\nDEF_EX( Ex, \"File exception\", std::exception )\nDEF_EX_STR( exCantOpen, \"Can't open\", Ex )\nDEF_EX( exReadError, \"Error reading from the file\", Ex )\nDEF_EX( exWriteError, \"Error writing to the file\", Ex )\nDEF_EX( exSeekError, \"File seek error\", Ex )\nDEF_EX( exAllocation, \"Memory allocation error\", Ex )\n\n/// Checks if the file exists or not.\n\nbool tryPossibleName( std::string const & name, std::string & copyTo );\n\nbool tryPossibleZipName( std::string const & name, std::string & copyTo );\n\nvoid loadFromFile( std::string const & n, std::vector< char > & data );\n\nbool exists( char const * filename ) throw();\n\ninline bool exists( std::string const & filename ) throw()\n{ return exists( filename.c_str() ); }\n\nclass Class\n{\n  QFile f;\n  char * writeBuffer;\n  qint64 writeBufferLeft;\n\n  void open( char const * filename, char const * mode ) THROW_SPEC( exCantOpen );\n\npublic:\n\n  Class( char const * filename, char const * mode ) THROW_SPEC( exCantOpen );\n\n  Class( std::string const & filename, char const * mode ) THROW_SPEC( exCantOpen );\n\n  /// Reads the number of bytes to the buffer, throws an error if it\n  /// failed to fill the whole buffer (short read, i/o error etc).\n  void read( void * buf, qint64 size ) THROW_SPEC( exReadError, exWriteError );\n\n  template< typename T >\n  void read( T & value ) THROW_SPEC( exReadError, exWriteError )\n  { read( &value, sizeof( value ) ); }\n\n  template< typename T >\n  T read() THROW_SPEC( exReadError, exWriteError )\n  { T value; read( value ); return value; }\n\n  /// Attempts reading at most 'count' records sized 'size'. Returns\n  /// the number of records it managed to read, up to 'count'.\n  size_t readRecords( void * buf, qint64 size, size_t count ) THROW_SPEC( exWriteError );\n\n  /// Writes the number of bytes from the buffer, throws an error if it\n  /// failed to write the whole buffer (short write, i/o error etc).\n  /// This function employs write buffering, and as such, writes may not\n  /// end up on disk immediately, or a short write may occur later\n  /// than it really did. If you don't want write buffering, use\n  /// writeRecords() function instead.\n  void write( void const * buf, qint64 size ) THROW_SPEC( exWriteError, exAllocation );\n\n  template< typename T >\n  void write( T const & value ) THROW_SPEC( exWriteError )\n  { write( &value, sizeof( value ) ); }\n\n  /// Attempts writing at most 'count' records sized 'size'. Returns\n  /// the number of records it managed to write, up to 'count'.\n  /// This function does not employ buffering, but flushes the buffer if it\n  /// was used before.\n  size_t writeRecords( void const * buf, qint64 size, size_t count )\n    THROW_SPEC( exWriteError );\n\n  /// Reads a string from the file. Unlike the normal fgets(), this one\n  /// can strip the trailing newline character, if this was requested.\n  /// Returns either s or 0 if no characters were read.\n  char * gets( char * s, int size, bool stripNl = false ) THROW_SPEC( exWriteError );\n\n  /// Like the above, but uses its own local internal buffer (1024 bytes\n  /// currently), and strips newlines by default.\n  std::string gets( bool stripNl = true ) THROW_SPEC( exReadError, exWriteError );\n\n  /// Seeks in the file, relative to its beginning.\n  void seek( qint64 offset ) THROW_SPEC( exSeekError, exWriteError );\n  /// Seeks in the file, relative to the current position.\n  void seekCur( qint64 offset ) THROW_SPEC( exSeekError, exWriteError );\n  /// Seeks in the file, relative to the end of file.\n  void seekEnd( qint64 offset = 0 ) THROW_SPEC( exSeekError, exWriteError );\n\n  /// Seeks to the beginning of file\n  void rewind() THROW_SPEC( exSeekError, exWriteError );\n\n  /// Tells the current position within the file, relative to its beginning.\n  qint64 tell() THROW_SPEC( exSeekError );\n\n  /// Returns true if end-of-file condition is set.\n  bool eof() THROW_SPEC( exWriteError );\n\n  /// Returns the underlying FILE * record, so other operations can be\n  /// performed on it.\n  QFile & file() THROW_SPEC( exWriteError );\n\n  /// Closes the file. No further operations are valid.\n  void close() THROW_SPEC( exWriteError );\n\n  ~Class() throw();\n\nprivate:\n\n  void flushWriteBuffer() THROW_SPEC( exWriteError );\n  void releaseWriteBuffer() THROW_SPEC( exWriteError );\n};\n\n}\n\n#endif\n"
        },
        {
          "name": "filetype.cc",
          "type": "blob",
          "size": 3.1396484375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"filetype.hh\"\n#include \"utf8.hh\"\n#include <ctype.h>\n\nnamespace Filetype {\n\nnamespace {\n\n/// Checks if the given string ends with the given substring\nbool endsWith( string const & str, string const & tail )\n{\n  return str.size() >= tail.size() &&\n    str.compare( str.size() - tail.size(), tail.size(), tail ) == 0;\n}\n\n}\n\n/// Removes any trailing or leading spaces and lowercases the string.\n/// The lowercasing is done simplistically, but it is enough for file\n/// extensions.\nstring simplifyString( string const & str, bool lowercase )\n{\n  string result;\n\n  size_t beginPos = 0;\n\n  while( beginPos < str.size() && Utf8::isspace( str[ beginPos ] ) )\n    ++beginPos;\n\n  size_t endPos = str.size();\n\n  while( endPos && Utf8::isspace( str[ endPos - 1 ] ) )\n    --endPos;\n\n  if( endPos <= beginPos )\n    return string();\n\n  result.reserve( endPos - beginPos );\n\n  while( beginPos < endPos )\n    result.push_back( lowercase ? tolower( str[ beginPos++ ] ) : str[ beginPos++ ] );\n\n  return result;\n}\n\nbool isNameOfSound( string const & name )\n{\n  string s = simplifyString( name );\n\n  return\n    endsWith( s, \".wav\" ) ||\n    endsWith( s, \".au\" ) ||\n    endsWith( s, \".voc\" ) ||\n    endsWith( s, \".ogg\" ) ||\n    endsWith( s, \".oga\" ) ||\n    endsWith( s, \".mp3\" ) ||\n    endsWith( s, \".m4a\") ||\n    endsWith( s, \".aac\" ) ||\n    endsWith( s, \".flac\" ) ||\n    endsWith( s, \".mid\" ) ||\n    endsWith( s, \".kar\" ) ||\n    endsWith( s, \".mpc\" ) ||\n    endsWith( s, \".wma\" ) ||\n    endsWith( s, \".wv\" ) ||\n    endsWith( s, \".ape\" ) ||\n    endsWith( s, \".spx\" ) ||\n    endsWith( s, \".opus\" ) ||\n    endsWith( s, \".mpa\" ) ||\n    endsWith( s, \".mp2\" );\n}\n\nbool isNameOfVideo( string const & name )\n{\n  string s = simplifyString( name );\n\n  return\n    endsWith( s, \".mpg\" ) ||\n    endsWith( s, \".mpeg\" )||\n    endsWith( s, \".mpe\" ) ||\n    endsWith( s, \".ogv\" ) ||\n    endsWith( s, \".ogm\" ) ||\n    endsWith( s, \".avi\" ) ||\n    endsWith( s, \".m4v\" ) ||\n    endsWith( s, \".mp4\" ) ||\n    endsWith( s, \".mkv\" ) ||\n    endsWith( s, \".wmv\" ) ||\n    endsWith( s, \".sfw\" ) ||\n    endsWith( s, \".flv\" ) ||\n    endsWith( s, \".divx\" ) ||\n    endsWith( s, \".3gp\" ) ||\n    endsWith( s, \".webm\" ) ||\n    endsWith( s, \".mov\" );\n}\n\nbool isNameOfPicture( string const & name )\n{\n  string s = simplifyString( name );\n\n  return\n    endsWith( s, \".jpg\" ) ||\n    endsWith( s, \".jpeg\" ) ||\n    endsWith( s, \".jpe\" ) ||\n    endsWith( s, \".png\" ) ||\n    endsWith( s, \".gif\" ) ||\n    endsWith( s, \".bmp\" ) ||\n    endsWith( s, \".tif\" ) ||\n    endsWith( s, \".tiff\" ) ||\n    endsWith( s, \".tga\" ) ||\n    endsWith( s, \".pcx\" ) ||\n    endsWith( s, \".ico\" ) ||\n    endsWith( s, \".webp\" ) ||\n    endsWith( s, \".svg\" );\n}\n\nbool isNameOfTiff( string const & name )\n{\n  string s = simplifyString( name );\n\n  return\n    endsWith( s, \".tif\" ) ||\n    endsWith( s, \".tiff\" );\n}\n\nbool isNameOfCSS( string const & name )\n{\n  string s = simplifyString( name );\n\n  return\n    endsWith( s, \".css\" );\n}\n\nbool isNameOfSvg( string const & name )\n{\n  string s = simplifyString( name );\n\n  return\n    endsWith( s, \".svg\" );\n}\n\n}\n"
        },
        {
          "name": "filetype.hh",
          "type": "blob",
          "size": 1.3330078125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __FILETYPE_HH_INCLUDED__\n#define __FILETYPE_HH_INCLUDED__\n\n#include <string>\n\n/// Utilities to guess file types based on their names.\nnamespace Filetype {\n\nusing std::string;\n\n/// Removes any trailing or leading spaces and may lowercases the string.\nstring simplifyString( string const & str, bool lowercase = true );\n/// Returns true if the name resembles the one of a sound file (i.e. ends\n/// with .wav, .ogg and such).\nbool isNameOfSound( string const & );\n/// Returns true if the name resembles the one of a video file (i.e. ends\n/// with .mpg, .ogv and such).\nbool isNameOfVideo( string const & );\n/// Returns true if the name resembles the one of a picture file (i.e. ends\n/// with .jpg, .png and such).\nbool isNameOfPicture( string const & );\n/// Returns true if the name resembles the one of a .tiff file (i.e. ends\n/// with .tif or tiff). We have this one separately since we need to reconvert\n/// TIFF files as WebKit doesn't seem to support them.\nbool isNameOfTiff( string const & );\n/// Returns true if the name resembles the one of a .css file\nbool isNameOfCSS( string const & );\n/// Returns true if the name resembles the one of a .svg file\nbool isNameOfSvg( string const & name );\n\n}\n\n#endif\n\n"
        },
        {
          "name": "fixx11h.h",
          "type": "blob",
          "size": 0.64453125,
          "content": "// This is a standard way (e.g., in KDE libs) of dealing\n// with X11 headers mess.\n\n#ifdef Unsorted\n#undef Unsorted\n#endif\n\n#ifdef None\n#undef None\n#endif\n\n#ifdef Bool\n#undef Bool\n#endif\n\n#ifdef FontChange\n#undef FontChange\n#endif\n\n#ifdef KeyPress\n#undef KeyPress\n#endif\n\n#ifdef KeyRelease\n#undef KeyRelease\n#endif\n\n#ifdef Above\n#undef Above\n#endif\n\n#ifdef Below\n#undef Below\n#endif\n\n#ifdef FocusIn\n#undef FocusIn\n#endif\n\n#ifdef FocusOut\n#undef FocusOut\n#endif\n\n#ifdef Always\n#undef Always\n#endif\n\n#ifdef Success\n#undef Success\n#endif\n\n#ifdef GrayScale\n#undef GrayScale\n#endif\n\n#ifdef Status\n#undef Status\n#endif\n\n#ifdef CursorShape\n#undef CursorShape\n#endif\n\n"
        },
        {
          "name": "flags.qrc",
          "type": "blob",
          "size": 8.58984375,
          "content": "<RCC>\n    <qresource prefix=\"/\">\n        <file>flags/wiki.png</file>\n        <file>flags/folder.png</file>\n        <file>flags/ad.png</file>\n        <file>flags/ae.png</file>\n        <file>flags/af.png</file>\n        <file>flags/ag.png</file>\n        <file>flags/ai.png</file>\n        <file>flags/al.png</file>\n        <file>flags/am.png</file>\n        <file>flags/an.png</file>\n        <file>flags/ao.png</file>\n        <file>flags/ar.png</file>\n        <file>flags/as.png</file>\n        <file>flags/at.png</file>\n        <file>flags/au.png</file>\n        <file>flags/aw.png</file>\n        <file>flags/ax.png</file>\n        <file>flags/az.png</file>\n        <file>flags/ba.png</file>\n        <file>flags/bb.png</file>\n        <file>flags/bd.png</file>\n        <file>flags/be.png</file>\n        <file>flags/bf.png</file>\n        <file>flags/bg.png</file>\n        <file>flags/bh.png</file>\n        <file>flags/bi.png</file>\n        <file>flags/bj.png</file>\n        <file>flags/bm.png</file>\n        <file>flags/bn.png</file>\n        <file>flags/bo.png</file>\n        <file>flags/br.png</file>\n        <file>flags/bs.png</file>\n        <file>flags/bt.png</file>\n        <file>flags/bv.png</file>\n        <file>flags/bw.png</file>\n        <file>flags/by.png</file>\n        <file>flags/bz.png</file>\n        <file>flags/ca.png</file>\n        <file>flags/ct.png</file>\n        <file>flags/cc.png</file>\n        <file>flags/cd.png</file>\n        <file>flags/cf.png</file>\n        <file>flags/cg.png</file>\n        <file>flags/ch.png</file>\n        <file>flags/ci.png</file>\n        <file>flags/ck.png</file>\n        <file>flags/cl.png</file>\n        <file>flags/cm.png</file>\n        <file>flags/cn.png</file>\n        <file>flags/co.png</file>\n        <file>flags/cr.png</file>\n        <file>flags/cs.png</file>\n        <file>flags/cu.png</file>\n        <file>flags/cv.png</file>\n        <file>flags/cx.png</file>\n        <file>flags/cy.png</file>\n        <file>flags/cz.png</file>\n        <file>flags/de.png</file>\n        <file>flags/dj.png</file>\n        <file>flags/dk.png</file>\n        <file>flags/dm.png</file>\n        <file>flags/do.png</file>\n        <file>flags/dz.png</file>\n        <file>flags/ec.png</file>\n        <file>flags/ee.png</file>\n        <file>flags/eg.png</file>\n        <file>flags/eh.png</file>\n        <file>flags/england.png</file>\n        <file>flags/er.png</file>\n        <file>flags/es.png</file>\n        <file>flags/et.png</file>\n        <file>flags/europeanunion.png</file>\n        <file>flags/fam.png</file>\n        <file>flags/fi.png</file>\n        <file>flags/fj.png</file>\n        <file>flags/fk.png</file>\n        <file>flags/fm.png</file>\n        <file>flags/fo.png</file>\n        <file>flags/fr.png</file>\n        <file>flags/ga.png</file>\n        <file>flags/gb.png</file>\n        <file>flags/gd.png</file>\n        <file>flags/ge.png</file>\n        <file>flags/gf.png</file>\n        <file>flags/gh.png</file>\n        <file>flags/gi.png</file>\n        <file>flags/gl.png</file>\n        <file>flags/gm.png</file>\n        <file>flags/gn.png</file>\n        <file>flags/gp.png</file>\n        <file>flags/gq.png</file>\n        <file>flags/gr.png</file>\n        <file>flags/gs.png</file>\n        <file>flags/gt.png</file>\n        <file>flags/gu.png</file>\n        <file>flags/gw.png</file>\n        <file>flags/gy.png</file>\n        <file>flags/hk.png</file>\n        <file>flags/hm.png</file>\n        <file>flags/hn.png</file>\n        <file>flags/hr.png</file>\n        <file>flags/ht.png</file>\n        <file>flags/hu.png</file>\n        <file>flags/id.png</file>\n        <file>flags/ie.png</file>\n        <file>flags/il.png</file>\n        <file>flags/in.png</file>\n        <file>flags/io.png</file>\n        <file>flags/iq.png</file>\n        <file>flags/ir.png</file>\n        <file>flags/is.png</file>\n        <file>flags/it.png</file>\n        <file>flags/ja.png</file>\n        <file>flags/jm.png</file>\n        <file>flags/jo.png</file>\n        <file>flags/jp.png</file>\n        <file>flags/ke.png</file>\n        <file>flags/kg.png</file>\n        <file>flags/kh.png</file>\n        <file>flags/ki.png</file>\n        <file>flags/km.png</file>\n        <file>flags/kn.png</file>\n        <file>flags/kp.png</file>\n        <file>flags/kr.png</file>\n        <file>flags/kw.png</file>\n        <file>flags/ky.png</file>\n        <file>flags/kz.png</file>\n        <file>flags/la.png</file>\n        <file>flags/lb.png</file>\n        <file>flags/lc.png</file>\n        <file>flags/li.png</file>\n        <file>flags/lk.png</file>\n        <file>flags/lr.png</file>\n        <file>flags/ls.png</file>\n        <file>flags/lt.png</file>\n        <file>flags/lu.png</file>\n        <file>flags/lv.png</file>\n        <file>flags/ly.png</file>\n        <file>flags/ma.png</file>\n        <file>flags/mc.png</file>\n        <file>flags/md.png</file>\n        <file>flags/me.png</file>\n        <file>flags/mg.png</file>\n        <file>flags/mh.png</file>\n        <file>flags/mk.png</file>\n        <file>flags/ml.png</file>\n        <file>flags/mm.png</file>\n        <file>flags/mn.png</file>\n        <file>flags/mo.png</file>\n        <file>flags/mp.png</file>\n        <file>flags/mq.png</file>\n        <file>flags/mr.png</file>\n        <file>flags/ms.png</file>\n        <file>flags/mt.png</file>\n        <file>flags/mu.png</file>\n        <file>flags/mv.png</file>\n        <file>flags/mw.png</file>\n        <file>flags/mx.png</file>\n        <file>flags/my.png</file>\n        <file>flags/mz.png</file>\n        <file>flags/na.png</file>\n        <file>flags/nc.png</file>\n        <file>flags/ne.png</file>\n        <file>flags/nf.png</file>\n        <file>flags/ng.png</file>\n        <file>flags/ni.png</file>\n        <file>flags/nl.png</file>\n        <file>flags/no.png</file>\n        <file>flags/np.png</file>\n        <file>flags/nr.png</file>\n        <file>flags/nu.png</file>\n        <file>flags/nz.png</file>\n        <file>flags/om.png</file>\n        <file>flags/pa.png</file>\n        <file>flags/pe.png</file>\n        <file>flags/pf.png</file>\n        <file>flags/pg.png</file>\n        <file>flags/ph.png</file>\n        <file>flags/pk.png</file>\n        <file>flags/pl.png</file>\n        <file>flags/pm.png</file>\n        <file>flags/pn.png</file>\n        <file>flags/pr.png</file>\n        <file>flags/ps.png</file>\n        <file>flags/pt.png</file>\n        <file>flags/pw.png</file>\n        <file>flags/py.png</file>\n        <file>flags/qa.png</file>\n        <file>flags/re.png</file>\n        <file>flags/ro.png</file>\n        <file>flags/rs.png</file>\n        <file>flags/ru.png</file>\n        <file>flags/rw.png</file>\n        <file>flags/sa.png</file>\n        <file>flags/sb.png</file>\n        <file>flags/scotland.png</file>\n        <file>flags/sc.png</file>\n        <file>flags/sd.png</file>\n        <file>flags/se.png</file>\n        <file>flags/sg.png</file>\n        <file>flags/sh.png</file>\n        <file>flags/si.png</file>\n        <file>flags/sj.png</file>\n        <file>flags/sk.png</file>\n        <file>flags/sl.png</file>\n        <file>flags/sm.png</file>\n        <file>flags/sn.png</file>\n        <file>flags/so.png</file>\n        <file>flags/sr.png</file>\n        <file>flags/st.png</file>\n        <file>flags/sv.png</file>\n        <file>flags/sy.png</file>\n        <file>flags/sz.png</file>\n        <file>flags/tc.png</file>\n        <file>flags/td.png</file>\n        <file>flags/tf.png</file>\n        <file>flags/tg.png</file>\n        <file>flags/th.png</file>\n        <file>flags/tj.png</file>\n        <file>flags/tk.png</file>\n        <file>flags/tl.png</file>\n        <file>flags/tm.png</file>\n        <file>flags/tn.png</file>\n        <file>flags/to.png</file>\n        <file>flags/tr.png</file>\n        <file>flags/tt.png</file>\n        <file>flags/tv.png</file>\n        <file>flags/tw.png</file>\n        <file>flags/tz.png</file>\n        <file>flags/ua.png</file>\n        <file>flags/ug.png</file>\n        <file>flags/um.png</file>\n        <file>flags/us.png</file>\n        <file>flags/uy.png</file>\n        <file>flags/uz.png</file>\n        <file>flags/va.png</file>\n        <file>flags/vc.png</file>\n        <file>flags/ve.png</file>\n        <file>flags/vg.png</file>\n        <file>flags/vi.png</file>\n        <file>flags/vn.png</file>\n        <file>flags/vu.png</file>\n        <file>flags/wales.png</file>\n        <file>flags/wi.png</file>\n        <file>flags/wf.png</file>\n        <file>flags/ws.png</file>\n        <file>flags/ye.png</file>\n        <file>flags/yt.png</file>\n        <file>flags/za.png</file>\n        <file>flags/zm.png</file>\n        <file>flags/zw.png</file>\n        <file>flags/en.png</file>\n        <file>flags/uk.png</file>\n        <file>flags/eo.png</file>\n        <file>flags/jb.png</file>\n        <file>flags/other.png</file>\n    </qresource>\n</RCC>\n"
        },
        {
          "name": "flags",
          "type": "tree",
          "content": null
        },
        {
          "name": "folding.cc",
          "type": "blob",
          "size": 23.6181640625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"folding.hh\"\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n#include <QRegularExpression>\n#else\n#include <QRegExp>\n#endif\n\nnamespace Folding {\n\n#include \"inc_case_folding.hh\"\n#include \"inc_diacritic_folding.hh\"\n\n/// Tests if the given char is one of the Unicode combining marks. Some are\n/// caught by the diacritics folding table, but they are only handled there\n/// when they come with their main characters, not by themselves. The rest\n/// are caught here.\nbool isCombiningMark( wchar ch )\n{\n  return (\n           ( ch >= 0x300 && ch <= 0x36F ) ||\n           ( ch >= 0x1DC0 && ch <= 0x1DFF ) ||\n           ( ch >= 0x20D0 && ch <= 0x20FF ) ||\n           ( ch >= 0xFE20 && ch <= 0xFE2F )\n         );\n}\n\nwstring apply( wstring const & in, bool preserveWildcards )\n{\n  // First, strip diacritics and apply ws/punctuation removal\n\n  wstring withoutDiacritics;\n\n  withoutDiacritics.reserve( in.size() );\n\n  wchar const * nextChar = in.data();\n\n  size_t consumed;\n\n  for( size_t left = in.size(); left; )\n  {\n    wchar ch = foldDiacritic( nextChar, left, consumed );\n\n    if ( !isCombiningMark( ch ) && !isWhitespace( ch )\n         && ( !isPunct( ch )\n              || ( preserveWildcards &&\n                   ( ch == '\\\\' || ch == '?' || ch == '*' || ch == '[' || ch == ']' ) )\n            )\n    )\n      withoutDiacritics.push_back( ch );\n\n    nextChar += consumed;\n    left -= consumed;\n  }\n\n  // Now, fold the case\n\n  wstring caseFolded;\n\n  caseFolded.reserve( withoutDiacritics.size() * foldCaseMaxOut );\n\n  nextChar = withoutDiacritics.data();\n\n  wchar buf[ foldCaseMaxOut ];\n\n  for( size_t left = withoutDiacritics.size(); left--; )\n    caseFolded.append( buf, foldCase(  *nextChar++, buf ) );\n\n  return caseFolded;\n}\n\nwstring applySimpleCaseOnly( wstring const & in )\n{\n  wchar const * nextChar = in.data();\n\n  wstring out;\n\n  out.reserve( in.size() );\n\n  for( size_t left = in.size(); left--; )\n    out.push_back( foldCaseSimple( *nextChar++ ) );\n\n  return out;\n}\n\nwstring applyFullCaseOnly( wstring const & in )\n{\n  wstring caseFolded;\n\n  caseFolded.reserve( in.size() * foldCaseMaxOut );\n\n  wchar const * nextChar = in.data();\n\n  wchar buf[ foldCaseMaxOut ];\n\n  for( size_t left = in.size(); left--; )\n    caseFolded.append( buf, foldCase(  *nextChar++, buf ) );\n\n  return caseFolded;\n}\n\nwstring applyDiacriticsOnly( wstring const & in )\n{\n  wstring withoutDiacritics;\n\n  withoutDiacritics.reserve( in.size() );\n\n  wchar const * nextChar = in.data();\n\n  size_t consumed;\n\n  for( size_t left = in.size(); left; )\n  {\n    wchar ch = foldDiacritic( nextChar, left, consumed );\n\n    if ( !isCombiningMark( ch ) )\n      withoutDiacritics.push_back( ch );\n\n    nextChar += consumed;\n    left -= consumed;\n  }\n\n  return withoutDiacritics;\n}\n\nwstring applyPunctOnly( wstring const & in )\n{\n  wchar const * nextChar = in.data();\n\n  wstring out;\n\n  out.reserve( in.size() );\n\n  for( size_t left = in.size(); left--; ++nextChar )\n    if ( !isPunct( *nextChar ) )\n      out.push_back( *nextChar );\n\n  return out;\n}\n\nwstring applyWhitespaceOnly( wstring const & in )\n{\n  wchar const * nextChar = in.data();\n\n  wstring out;\n\n  out.reserve( in.size() );\n\n  for( size_t left = in.size(); left--; ++nextChar )\n    if ( !isWhitespace( *nextChar ) )\n      out.push_back( *nextChar );\n\n  return out;\n}\n\nwstring applyWhitespaceAndPunctOnly( wstring const & in )\n{\n  wchar const * nextChar = in.data();\n\n  wstring out;\n\n  out.reserve( in.size() );\n\n  for( size_t left = in.size(); left--; ++nextChar )\n    if ( !isWhitespace( *nextChar ) && !isPunct( *nextChar ) )\n      out.push_back( *nextChar );\n\n  return out;\n}\n\nbool isWhitespace( wchar ch )\n{\n  switch( ch )\n  {\n    case '\\n':\n    case '\\r':\n    case '\\t':\n\n    case 0x2028: // Zl, LINE SEPARATOR\n\n    case 0x2029: // Zp, PARAGRAPH SEPARATOR\n\n    case 0x0020: // Zs, SPACE\n    case 0x00A0: // Zs, NO-BREAK SPACE\n    case 0x1680: // Zs, OGHAM SPACE MARK\n    case 0x180E: // Zs, MONGOLIAN VOWEL SEPARATOR\n    case 0x2000: // Zs, EN QUAD\n    case 0x2001: // Zs, EM QUAD\n    case 0x2002: // Zs, EN SPACE\n    case 0x2003: // Zs, EM SPACE\n    case 0x2004: // Zs, THREE-PER-EM SPACE\n    case 0x2005: // Zs, FOUR-PER-EM SPACE\n    case 0x2006: // Zs, SIX-PER-EM SPACE\n    case 0x2007: // Zs, FIGURE SPACE\n    case 0x2008: // Zs, PUNCTUATION SPACE\n    case 0x2009: // Zs, THIN SPACE\n    case 0x200A: // Zs, HAIR SPACE\n    case 0x202F: // Zs, NARROW NO-BREAK SPACE\n    case 0x205F: // Zs, MEDIUM MATHEMATICAL SPACE\n    case 0x3000: // Zs, IDEOGRAPHIC SPACE\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nbool isPunct( wchar ch )\n{\n  switch( ch )\n  {\n    // Pc\n\n    case 0x005F: // LOW LINE\n    case 0x203F: // UNDERTIE\n    case 0x2040: // CHARACTER TIE\n    case 0x2054: // INVERTED UNDERTIE\n    case 0x30FB: // KATAKANA MIDDLE DOT\n    case 0xFE33: // PRESENTATION FORM FOR VERTICAL LOW LINE\n    case 0xFE34: // PRESENTATION FORM FOR VERTICAL WAVY LOW LINE\n    case 0xFE4D: // DASHED LOW LINE\n    case 0xFE4E: // CENTRELINE LOW LINE\n    case 0xFE4F: // WAVY LOW LINE\n    case 0xFF3F: // FULLWIDTH LOW LINE\n    case 0xFF65: // HALFWIDTH KATAKANA MIDDLE DOT\n\n    // Pd\n    case 0x002D: // HYPHEN-MINUS\n    case 0x058A: // ARMENIAN HYPHEN\n    case 0x1806: // MONGOLIAN TODO SOFT HYPHEN\n    case 0x2010: // HYPHEN\n    case 0x2011: // NON-BREAKING HYPHEN\n    case 0x2012: // FIGURE DASH\n    case 0x2013: // EN DASH\n    case 0x2014: // EM DASH\n    case 0x2015: // HORIZONTAL BAR\n    case 0x301C: // WAVE DASH\n    case 0x3030: // WAVY DASH\n    case 0x30A0: // KATAKANA-HIRAGANA DOUBLE HYPHEN\n    case 0xFE31: // PRESENTATION FORM FOR VERTICAL EM DASH\n    case 0xFE32: // PRESENTATION FORM FOR VERTICAL EN DASH\n    case 0xFE58: // SMALL EM DASH\n    case 0xFE63: // SMALL HYPHEN-MINUS\n    case 0xFF0D: // FULLWIDTH HYPHEN-MINUS\n\n    // Ps\n    case 0x0028: // LEFT PARENTHESIS\n    case 0x005B: // LEFT SQUARE BRACKET\n    case 0x007B: // LEFT CURLY BRACKET\n    case 0x0F3A: // TIBETAN MARK GUG RTAGS GYON\n    case 0x0F3C: // TIBETAN MARK ANG KHANG GYON\n    case 0x169B: // OGHAM FEATHER MARK\n    case 0x201A: // SINGLE LOW-9 QUOTATION MARK\n    case 0x201E: // DOUBLE LOW-9 QUOTATION MARK\n    case 0x2045: // LEFT SQUARE BRACKET WITH QUILL\n    case 0x207D: // SUPERSCRIPT LEFT PARENTHESIS\n    case 0x208D: // SUBSCRIPT LEFT PARENTHESIS\n    case 0x2329: // LEFT-POINTING ANGLE BRACKET\n    case 0x2768: // MEDIUM LEFT PARENTHESIS ORNAMENT\n    case 0x276A: // MEDIUM FLATTENED LEFT PARENTHESIS ORNAMENT\n    case 0x276C: // MEDIUM LEFT-POINTING ANGLE BRACKET ORNAMENT\n    case 0x276E: // HEAVY LEFT-POINTING ANGLE QUOTATION MARK ORNAMENT\n    case 0x2770: // HEAVY LEFT-POINTING ANGLE BRACKET ORNAMENT\n    case 0x2772: // LIGHT LEFT TORTOISE SHELL BRACKET ORNAMENT\n    case 0x2774: // MEDIUM LEFT CURLY BRACKET ORNAMENT\n    case 0x27C5: // LEFT S-SHAPED BAG DELIMITER\n    case 0x27E6: // MATHEMATICAL LEFT WHITE SQUARE BRACKET\n    case 0x27E8: // MATHEMATICAL LEFT ANGLE BRACKET\n    case 0x27EA: // MATHEMATICAL LEFT DOUBLE ANGLE BRACKET\n    case 0x27EC: // MATHEMATICAL LEFT WHITE TORTOISE SHELL BRACKET\n    case 0x27EE: // MATHEMATICAL LEFT FLATTENED PARENTHESIS\n    case 0x2983: // LEFT WHITE CURLY BRACKET\n    case 0x2985: // LEFT WHITE PARENTHESIS\n    case 0x2987: // Z NOTATION LEFT IMAGE BRACKET\n    case 0x2989: // Z NOTATION LEFT BINDING BRACKET\n    case 0x298B: // LEFT SQUARE BRACKET WITH UNDERBAR\n    case 0x298D: // LEFT SQUARE BRACKET WITH TICK IN TOP CORNER\n    case 0x298F: // LEFT SQUARE BRACKET WITH TICK IN BOTTOM CORNER\n    case 0x2991: // LEFT ANGLE BRACKET WITH DOT\n    case 0x2993: // LEFT ARC LESS-THAN BRACKET\n    case 0x2995: // DOUBLE LEFT ARC GREATER-THAN BRACKET\n    case 0x2997: // LEFT BLACK TORTOISE SHELL BRACKET\n    case 0x29D8: // LEFT WIGGLY FENCE\n    case 0x29DA: // LEFT DOUBLE WIGGLY FENCE\n    case 0x29FC: // LEFT-POINTING CURVED ANGLE BRACKET\n    case 0x2E22: // TOP LEFT HALF BRACKET\n    case 0x2E24: // BOTTOM LEFT HALF BRACKET\n    case 0x2E26: // LEFT SIDEWAYS U BRACKET\n    case 0x2E28: // LEFT DOUBLE PARENTHESIS\n    case 0x3008: // LEFT ANGLE BRACKET\n    case 0x300A: // LEFT DOUBLE ANGLE BRACKET\n    case 0x300C: // LEFT CORNER BRACKET\n    case 0x300E: // LEFT WHITE CORNER BRACKET\n    case 0x3010: // LEFT BLACK LENTICULAR BRACKET\n    case 0x3014: // LEFT TORTOISE SHELL BRACKET\n    case 0x3016: // LEFT WHITE LENTICULAR BRACKET\n    case 0x3018: // LEFT WHITE TORTOISE SHELL BRACKET\n    case 0x301A: // LEFT WHITE SQUARE BRACKET\n    case 0x301D: // REVERSED DOUBLE PRIME QUOTATION MARK\n    case 0xFD3E: // ORNATE LEFT PARENTHESIS\n    case 0xFE17: // PRESENTATION FORM FOR VERTICAL LEFT WHITE LENTICULAR BRACKET\n    case 0xFE35: // PRESENTATION FORM FOR VERTICAL LEFT PARENTHESIS\n    case 0xFE37: // PRESENTATION FORM FOR VERTICAL LEFT CURLY BRACKET\n    case 0xFE39: // PRESENTATION FORM FOR VERTICAL LEFT TORTOISE SHELL BRACKET\n    case 0xFE3B: // PRESENTATION FORM FOR VERTICAL LEFT BLACK LENTICULAR BRACKET\n    case 0xFE3D: // PRESENTATION FORM FOR VERTICAL LEFT DOUBLE ANGLE BRACKET\n    case 0xFE3F: // PRESENTATION FORM FOR VERTICAL LEFT ANGLE BRACKET\n    case 0xFE41: // PRESENTATION FORM FOR VERTICAL LEFT CORNER BRACKET\n    case 0xFE43: // PRESENTATION FORM FOR VERTICAL LEFT WHITE CORNER BRACKET\n    case 0xFE47: // PRESENTATION FORM FOR VERTICAL LEFT SQUARE BRACKET\n    case 0xFE59: // SMALL LEFT PARENTHESIS\n    case 0xFE5B: // SMALL LEFT CURLY BRACKET\n    case 0xFE5D: // SMALL LEFT TORTOISE SHELL BRACKET\n    case 0xFF08: // FULLWIDTH LEFT PARENTHESIS\n    case 0xFF3B: // FULLWIDTH LEFT SQUARE BRACKET\n    case 0xFF5B: // FULLWIDTH LEFT CURLY BRACKET\n    case 0xFF5F: // FULLWIDTH LEFT WHITE PARENTHESIS\n    case 0xFF62: // HALFWIDTH LEFT CORNER BRACKET\n\n    // Pe\n    case 0x0029: // RIGHT PARENTHESIS\n    case 0x005D: // RIGHT SQUARE BRACKET\n    case 0x007D: // RIGHT CURLY BRACKET\n    case 0x0F3B: // TIBETAN MARK GUG RTAGS GYAS\n    case 0x0F3D: // TIBETAN MARK ANG KHANG GYAS\n    case 0x169C: // OGHAM REVERSED FEATHER MARK\n    case 0x2046: // RIGHT SQUARE BRACKET WITH QUILL\n    case 0x207E: // SUPERSCRIPT RIGHT PARENTHESIS\n    case 0x208E: // SUBSCRIPT RIGHT PARENTHESIS\n    case 0x232A: // RIGHT-POINTING ANGLE BRACKET\n    case 0x23B5: // BOTTOM SQUARE BRACKET\n    case 0x2769: // MEDIUM RIGHT PARENTHESIS ORNAMENT\n    case 0x276B: // MEDIUM FLATTENED RIGHT PARENTHESIS ORNAMENT\n    case 0x276D: // MEDIUM RIGHT-POINTING ANGLE BRACKET ORNAMENT\n    case 0x276F: // HEAVY RIGHT-POINTING ANGLE QUOTATION MARK ORNAMENT\n    case 0x2771: // HEAVY RIGHT-POINTING ANGLE BRACKET ORNAMENT\n    case 0x2773: // LIGHT RIGHT TORTOISE SHELL BRACKET ORNAMENT\n    case 0x2775: // MEDIUM RIGHT CURLY BRACKET ORNAMENT\n    case 0x27E7: // MATHEMATICAL RIGHT WHITE SQUARE BRACKET\n    case 0x27E9: // MATHEMATICAL RIGHT ANGLE BRACKET\n    case 0x27EB: // MATHEMATICAL RIGHT DOUBLE ANGLE BRACKET\n    case 0x2984: // RIGHT WHITE CURLY BRACKET\n    case 0x2986: // RIGHT WHITE PARENTHESIS\n    case 0x2988: // Z NOTATION RIGHT IMAGE BRACKET\n    case 0x298A: // Z NOTATION RIGHT BINDING BRACKET\n    case 0x298C: // RIGHT SQUARE BRACKET WITH UNDERBAR\n    case 0x298E: // RIGHT SQUARE BRACKET WITH TICK IN BOTTOM CORNER\n    case 0x2990: // RIGHT SQUARE BRACKET WITH TICK IN TOP CORNER\n    case 0x2992: // RIGHT ANGLE BRACKET WITH DOT\n    case 0x2994: // RIGHT ARC GREATER-THAN BRACKET\n    case 0x2996: // DOUBLE RIGHT ARC LESS-THAN BRACKET\n    case 0x2998: // RIGHT BLACK TORTOISE SHELL BRACKET\n    case 0x29D9: // RIGHT WIGGLY FENCE\n    case 0x29DB: // RIGHT DOUBLE WIGGLY FENCE\n    case 0x29FD: // RIGHT-POINTING CURVED ANGLE BRACKET\n    case 0x3009: // RIGHT ANGLE BRACKET\n    case 0x300B: // RIGHT DOUBLE ANGLE BRACKET\n    case 0x300D: // RIGHT CORNER BRACKET\n    case 0x300F: // RIGHT WHITE CORNER BRACKET\n    case 0x3011: // RIGHT BLACK LENTICULAR BRACKET\n    case 0x3015: // RIGHT TORTOISE SHELL BRACKET\n    case 0x3017: // RIGHT WHITE LENTICULAR BRACKET\n    case 0x3019: // RIGHT WHITE TORTOISE SHELL BRACKET\n    case 0x301B: // RIGHT WHITE SQUARE BRACKET\n    case 0x301E: // DOUBLE PRIME QUOTATION MARK\n    case 0x301F: // LOW DOUBLE PRIME QUOTATION MARK\n    case 0xFD3F: // ORNATE RIGHT PARENTHESIS\n    case 0xFE36: // PRESENTATION FORM FOR VERTICAL RIGHT PARENTHESIS\n    case 0xFE38: // PRESENTATION FORM FOR VERTICAL RIGHT CURLY BRACKET\n    case 0xFE3A: // PRESENTATION FORM FOR VERTICAL RIGHT TORTOISE SHELL BRACKET\n    case 0xFE3C: // PRESENTATION FORM FOR VERTICAL RIGHT BLACK LENTICULAR BRACKET\n    case 0xFE3E: // PRESENTATION FORM FOR VERTICAL RIGHT DOUBLE ANGLE BRACKET\n    case 0xFE40: // PRESENTATION FORM FOR VERTICAL RIGHT ANGLE BRACKET\n    case 0xFE42: // PRESENTATION FORM FOR VERTICAL RIGHT CORNER BRACKET\n    case 0xFE44: // PRESENTATION FORM FOR VERTICAL RIGHT WHITE CORNER BRACKET\n    case 0xFE48: // PRESENTATION FORM FOR VERTICAL RIGHT SQUARE BRACKET\n    case 0xFE5A: // SMALL RIGHT PARENTHESIS\n    case 0xFE5C: // SMALL RIGHT CURLY BRACKET\n    case 0xFE5E: // SMALL RIGHT TORTOISE SHELL BRACKET\n    case 0xFF09: // FULLWIDTH RIGHT PARENTHESIS\n    case 0xFF3D: // FULLWIDTH RIGHT SQUARE BRACKET\n    case 0xFF5D: // FULLWIDTH RIGHT CURLY BRACKET\n    case 0xFF60: // FULLWIDTH RIGHT WHITE PARENTHESIS\n    case 0xFF63: // HALFWIDTH RIGHT CORNER BRACKET\n\n    // Pf\n    case 0x00BB: // RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK\n    case 0x2019: // RIGHT SINGLE QUOTATION MARK\n    case 0x201D: // RIGHT DOUBLE QUOTATION MARK\n    case 0x203A: // SINGLE RIGHT-POINTING ANGLE QUOTATION MARK\n\n\n    // Pi\n    case 0x00AB: // LEFT-POINTING DOUBLE ANGLE QUOTATION MARK\n    case 0x2018: // LEFT SINGLE QUOTATION MARK\n    case 0x201C: // LEFT DOUBLE QUOTATION MARK\n    case 0x2039: // SINGLE LEFT-POINTING ANGLE QUOTATION MARK\n\n    // Po\n    case 0x0021: // EXCLAMATION MARK\n    case 0x0022: // QUOTATION MARK\n    case 0x0023: // NUMBER SIGN\n    case 0x0025: // PERCENT SIGN\n    case 0x0026: // AMPERSAND\n    case 0x0027: // APOSTROPHE\n    case 0x002A: // ASTERISK\n    case 0x002C: // COMMA\n    case 0x002E: // FULL STOP\n    case 0x002F: // SOLIDUS\n    case 0x003A: // COLON\n    case 0x003B: // SEMICOLON\n    case 0x003F: // QUESTION MARK\n    case 0x0040: // COMMERCIAL AT\n    case 0x005C: // REVERSE SOLIDUS\n    case 0x00A1: // INVERTED EXCLAMATION MARK\n    case 0x00B7: // MIDDLE DOT\n    case 0x00BF: // INVERTED QUESTION MARK\n    case 0x037E: // GREEK QUESTION MARK\n    case 0x0387: // GREEK ANO TELEIA\n    case 0x055A: // ARMENIAN APOSTROPHE\n    case 0x055B: // ARMENIAN EMPHASIS MARK\n    case 0x055C: // ARMENIAN EXCLAMATION MARK\n    case 0x055D: // ARMENIAN COMMA\n    case 0x055E: // ARMENIAN QUESTION MARK\n    case 0x055F: // ARMENIAN ABBREVIATION MARK\n    case 0x0589: // ARMENIAN FULL STOP\n    case 0x05BE: // HEBREW PUNCTUATION MAQAF\n    case 0x05C0: // HEBREW PUNCTUATION PASEQ\n    case 0x05C3: // HEBREW PUNCTUATION SOF PASUQ\n    case 0x05F3: // HEBREW PUNCTUATION GERESH\n    case 0x05F4: // HEBREW PUNCTUATION GERSHAYIM\n    case 0x060C: // ARABIC COMMA\n    case 0x060D: // ARABIC DATE SEPARATOR\n    case 0x061B: // ARABIC SEMICOLON\n    case 0x061F: // ARABIC QUESTION MARK\n    case 0x066A: // ARABIC PERCENT SIGN\n    case 0x066B: // ARABIC DECIMAL SEPARATOR\n    case 0x066C: // ARABIC THOUSANDS SEPARATOR\n    case 0x066D: // ARABIC FIVE POINTED STAR\n    case 0x06D4: // ARABIC FULL STOP\n    case 0x0700: // SYRIAC END OF PARAGRAPH\n    case 0x0701: // SYRIAC SUPRALINEAR FULL STOP\n    case 0x0702: // SYRIAC SUBLINEAR FULL STOP\n    case 0x0703: // SYRIAC SUPRALINEAR COLON\n    case 0x0704: // SYRIAC SUBLINEAR COLON\n    case 0x0705: // SYRIAC HORIZONTAL COLON\n    case 0x0706: // SYRIAC COLON SKEWED LEFT\n    case 0x0707: // SYRIAC COLON SKEWED RIGHT\n    case 0x0708: // SYRIAC SUPRALINEAR COLON SKEWED LEFT\n    case 0x0709: // SYRIAC SUBLINEAR COLON SKEWED RIGHT\n    case 0x070A: // SYRIAC CONTRACTION\n    case 0x070B: // SYRIAC HARKLEAN OBELUS\n    case 0x070C: // SYRIAC HARKLEAN METOBELUS\n    case 0x070D: // SYRIAC HARKLEAN ASTERISCUS\n    case 0x0964: // DEVANAGARI DANDA\n    case 0x0965: // DEVANAGARI DOUBLE DANDA\n    case 0x0970: // DEVANAGARI ABBREVIATION SIGN\n    case 0x0DF4: // SINHALA PUNCTUATION KUNDDALIYA\n    case 0x0E4F: // THAI CHARACTER FONGMAN\n    case 0x0E5A: // THAI CHARACTER ANGKHANKHU\n    case 0x0E5B: // THAI CHARACTER KHOMUT\n    case 0x0F04: // TIBETAN MARK INITIAL YIG MGO MDUN MA\n    case 0x0F05: // TIBETAN MARK CLOSING YIG MGO SGAB MA\n    case 0x0F06: // TIBETAN MARK CARET YIG MGO PHUR SHAD MA\n    case 0x0F07: // TIBETAN MARK YIG MGO TSHEG SHAD MA\n    case 0x0F08: // TIBETAN MARK SBRUL SHAD\n    case 0x0F09: // TIBETAN MARK BSKUR YIG MGO\n    case 0x0F0A: // TIBETAN MARK BKA- SHOG YIG MGO\n    case 0x0F0B: // TIBETAN MARK INTERSYLLABIC TSHEG\n    case 0x0F0C: // TIBETAN MARK DELIMITER TSHEG BSTAR\n    case 0x0F0D: // TIBETAN MARK SHAD\n    case 0x0F0E: // TIBETAN MARK NYIS SHAD\n    case 0x0F0F: // TIBETAN MARK TSHEG SHAD\n    case 0x0F10: // TIBETAN MARK NYIS TSHEG SHAD\n    case 0x0F11: // TIBETAN MARK RIN CHEN SPUNGS SHAD\n    case 0x0F12: // TIBETAN MARK RGYA GRAM SHAD\n    case 0x0F85: // TIBETAN MARK PALUTA\n    case 0x104A: // MYANMAR SIGN LITTLE SECTION\n    case 0x104B: // MYANMAR SIGN SECTION\n    case 0x104C: // MYANMAR SYMBOL LOCATIVE\n    case 0x104D: // MYANMAR SYMBOL COMPLETED\n    case 0x104E: // MYANMAR SYMBOL AFOREMENTIONED\n    case 0x104F: // MYANMAR SYMBOL GENITIVE\n    case 0x10FB: // GEORGIAN PARAGRAPH SEPARATOR\n    case 0x1361: // ETHIOPIC WORDSPACE\n    case 0x1362: // ETHIOPIC FULL STOP\n    case 0x1363: // ETHIOPIC COMMA\n    case 0x1364: // ETHIOPIC SEMICOLON\n    case 0x1365: // ETHIOPIC COLON\n    case 0x1366: // ETHIOPIC PREFACE COLON\n    case 0x1367: // ETHIOPIC QUESTION MARK\n    case 0x1368: // ETHIOPIC PARAGRAPH SEPARATOR\n    case 0x166D: // CANADIAN SYLLABICS CHI SIGN\n    case 0x166E: // CANADIAN SYLLABICS FULL STOP\n    case 0x16EB: // RUNIC SINGLE PUNCTUATION\n    case 0x16EC: // RUNIC MULTIPLE PUNCTUATION\n    case 0x16ED: // RUNIC CROSS PUNCTUATION\n    case 0x1735: // PHILIPPINE SINGLE PUNCTUATION\n    case 0x1736: // PHILIPPINE DOUBLE PUNCTUATION\n    case 0x17D4: // KHMER SIGN KHAN\n    case 0x17D5: // KHMER SIGN BARIYOOSAN\n    case 0x17D6: // KHMER SIGN CAMNUC PII KUUH\n    case 0x17D8: // KHMER SIGN BEYYAL\n    case 0x17D9: // KHMER SIGN PHNAEK MUAN\n    case 0x17DA: // KHMER SIGN KOOMUUT\n    case 0x1800: // MONGOLIAN BIRGA\n    case 0x1801: // MONGOLIAN ELLIPSIS\n    case 0x1802: // MONGOLIAN COMMA\n    case 0x1803: // MONGOLIAN FULL STOP\n    case 0x1804: // MONGOLIAN COLON\n    case 0x1805: // MONGOLIAN FOUR DOTS\n    case 0x1807: // MONGOLIAN SIBE SYLLABLE BOUNDARY MARKER\n    case 0x1808: // MONGOLIAN MANCHU COMMA\n    case 0x1809: // MONGOLIAN MANCHU FULL STOP\n    case 0x180A: // MONGOLIAN NIRUGU\n    case 0x1944: // LIMBU EXCLAMATION MARK\n    case 0x1945: // LIMBU QUESTION MARK\n    case 0x2016: // DOUBLE VERTICAL LINE\n    case 0x2017: // DOUBLE LOW LINE\n    case 0x2020: // DAGGER\n    case 0x2021: // DOUBLE DAGGER\n    case 0x2022: // BULLET\n    case 0x2023: // TRIANGULAR BULLET\n    case 0x2024: // ONE DOT LEADER\n    case 0x2025: // TWO DOT LEADER\n    case 0x2026: // HORIZONTAL ELLIPSIS\n    case 0x2027: // HYPHENATION POINT\n    case 0x2030: // PER MILLE SIGN\n    case 0x2031: // PER TEN THOUSAND SIGN\n    case 0x2032: // PRIME\n    case 0x2033: // DOUBLE PRIME\n    case 0x2034: // TRIPLE PRIME\n    case 0x2035: // REVERSED PRIME\n    case 0x2036: // REVERSED DOUBLE PRIME\n    case 0x2037: // REVERSED TRIPLE PRIME\n    case 0x2038: // CARET\n    case 0x203B: // REFERENCE MARK\n    case 0x203C: // DOUBLE EXCLAMATION MARK\n    case 0x203D: // INTERROBANG\n    case 0x203E: // OVERLINE\n    case 0x2041: // CARET INSERTION POINT\n    case 0x2042: // ASTERISM\n    case 0x2043: // HYPHEN BULLET\n    case 0x2047: // DOUBLE QUESTION MARK\n    case 0x2048: // QUESTION EXCLAMATION MARK\n    case 0x2049: // EXCLAMATION QUESTION MARK\n    case 0x204A: // TIRONIAN SIGN ET\n    case 0x204B: // REVERSED PILCROW SIGN\n    case 0x204C: // BLACK LEFTWARDS BULLET\n    case 0x204D: // BLACK RIGHTWARDS BULLET\n    case 0x204E: // LOW ASTERISK\n    case 0x204F: // REVERSED SEMICOLON\n    case 0x2050: // CLOSE UP\n    case 0x2051: // TWO ASTERISKS ALIGNED VERTICALLY\n    case 0x2053: // SWUNG DASH\n    case 0x2057: // QUADRUPLE PRIME\n    case 0x23B6: // BOTTOM SQUARE BRACKET OVER TOP SQUARE BRACKET\n    case 0x3001: // IDEOGRAPHIC COMMA\n    case 0x3002: // IDEOGRAPHIC FULL STOP\n    case 0x3003: // DITTO MARK\n    case 0x303D: // PART ALTERNATION MARK\n    case 0xFE30: // PRESENTATION FORM FOR VERTICAL TWO DOT LEADER\n    case 0xFE45: // SESAME DOT\n    case 0xFE46: // WHITE SESAME DOT\n    case 0xFE49: // DASHED OVERLINE\n    case 0xFE4A: // CENTRELINE OVERLINE\n    case 0xFE4B: // WAVY OVERLINE\n    case 0xFE4C: // DOUBLE WAVY OVERLINE\n    case 0xFE50: // SMALL COMMA\n    case 0xFE51: // SMALL IDEOGRAPHIC COMMA\n    case 0xFE52: // SMALL FULL STOP\n    case 0xFE54: // SMALL SEMICOLON\n    case 0xFE55: // SMALL COLON\n    case 0xFE56: // SMALL QUESTION MARK\n    case 0xFE57: // SMALL EXCLAMATION MARK\n    case 0xFE5F: // SMALL NUMBER SIGN\n    case 0xFE60: // SMALL AMPERSAND\n    case 0xFE61: // SMALL ASTERISK\n    case 0xFE68: // SMALL REVERSE SOLIDUS\n    case 0xFE6A: // SMALL PERCENT SIGN\n    case 0xFE6B: // SMALL COMMERCIAL AT\n    case 0xFF01: // FULLWIDTH EXCLAMATION MARK\n    case 0xFF02: // FULLWIDTH QUOTATION MARK\n    case 0xFF03: // FULLWIDTH NUMBER SIGN\n    case 0xFF05: // FULLWIDTH PERCENT SIGN\n    case 0xFF06: // FULLWIDTH AMPERSAND\n    case 0xFF07: // FULLWIDTH APOSTROPHE\n    case 0xFF0A: // FULLWIDTH ASTERISK\n    case 0xFF0C: // FULLWIDTH COMMA\n    case 0xFF0E: // FULLWIDTH FULL STOP\n    case 0xFF0F: // FULLWIDTH SOLIDUS\n    case 0xFF1A: // FULLWIDTH COLON\n    case 0xFF1B: // FULLWIDTH SEMICOLON\n    case 0xFF1F: // FULLWIDTH QUESTION MARK\n    case 0xFF20: // FULLWIDTH COMMERCIAL AT\n    case 0xFF3C: // FULLWIDTH REVERSE SOLIDUS\n    case 0xFF61: // HALFWIDTH IDEOGRAPHIC FULL STOP\n    case 0xFF64: // HALFWIDTH IDEOGRAPHIC COMMA\n      return true;\n    default:\n      return false;\n  }\n}\n\nwstring trimWhitespaceOrPunct( wstring const & in )\n{\n  wchar const * wordBegin = in.c_str();\n  wstring::size_type wordSize = in.size();\n\n  // Skip any leading whitespace\n  while( *wordBegin && ( Folding::isWhitespace( *wordBegin ) || Folding::isPunct( *wordBegin ) ) )\n  {\n    ++wordBegin;\n    --wordSize;\n  }\n\n  // Skip any trailing whitespace\n  while( wordSize && ( Folding::isWhitespace( wordBegin[ wordSize - 1 ] ) ||\n                       Folding::isPunct( wordBegin[ wordSize - 1 ] ) ) )\n    --wordSize;\n\n  return wstring( wordBegin, wordSize );\n}\n\nwstring trimWhitespace( wstring const & in )\n{\n  wchar const * wordBegin = in.c_str();\n  wstring::size_type wordSize = in.size();\n\n  // Skip any leading whitespace\n  while( *wordBegin && Folding::isWhitespace( *wordBegin ) )\n  {\n    ++wordBegin;\n    --wordSize;\n  }\n\n  // Skip any trailing whitespace\n  while( wordSize && Folding::isWhitespace( wordBegin[ wordSize - 1 ] ) )\n    --wordSize;\n\n  return wstring( wordBegin, wordSize );\n}\n\nvoid normalizeWhitespace( wstring & str )\n{\n  for( size_t x = str.size(); x-- > 1; ) // >1 -- Don't test the first char\n  {\n    if ( isWhitespace( str[ x ] ) )\n    {\n      size_t y;\n      for( y = x; y && ( isWhitespace( str[ y - 1 ] ) ) ; --y );\n\n      if ( y != x )\n      {\n        // Remove extra spaces\n\n        str.erase( y, x - y );\n\n        x = y;\n\n        str[ x ] = ' ';\n      }\n    }\n  }\n}\n\nQString escapeWildcardSymbols( const QString & str )\n{\n  QString escaped( str );\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  escaped.replace( QRegularExpression( \"([\\\\[\\\\]\\\\?\\\\*])\" ), \"\\\\\\\\1\" );\n#else\n  escaped.replace( QRegExp( \"([\\\\[\\\\]\\\\?\\\\*])\", Qt::CaseInsensitive ), \"\\\\\\\\1\" );\n#endif\n  return escaped;\n}\n\nQString unescapeWildcardSymbols( const QString & str )\n{\n  QString unescaped( str );\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  unescaped.replace( QRegularExpression( \"\\\\\\\\([\\\\[\\\\]\\\\?\\\\*])\" ), \"\\\\1\" );\n#else\n  unescaped.replace( QRegExp( \"\\\\\\\\([\\\\[\\\\]\\\\?\\\\*])\", Qt::CaseInsensitive ), \"\\\\1\" );\n#endif\n  return unescaped;\n}\n\nwchar foldedDiacritic( wchar const * in, size_t size, size_t & consumed )\n{\n  return foldDiacritic( in, size, consumed );\n}\n\n\n}\n"
        },
        {
          "name": "folding.hh",
          "type": "blob",
          "size": 3.4833984375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __FOLDING_HH_INCLUDED__\n#define __FOLDING_HH_INCLUDED__\n\n#include \"wstring.hh\"\n#include <QString>\n\n/// Folding provides means to translate several possible ways to write a\n/// symbol into one. This facilitates searching. Here we currently perform\n/// full case folding (everything gets translated to lowercase, ligatures\n/// and complex letters are decomposed), diacritics folding (all diacritic\n/// marks get removed) and whitespace/punctuation marks removal. These\n/// transforms are done according to the Unicode standard and/or drafts. The\n/// exact algorithms, lists and types of folding performed might get changed\n/// in the future -- in this case, the Version field will be bumped up.\n\nnamespace Folding {\n\nusing gd::wstring;\nusing gd::wchar;\n\n/// The algorithm's version.\nenum\n{\n  Version = 6\n};\n\n/// Applies the folding algorithm to each character in the given string,\n/// making another one as a result.\nwstring apply( wstring const &, bool preserveWildcards = false );\n\n/// Applies only simple case folding algorithm. Since many dictionaries have\n/// different case style, we interpret words differing only by case as synonyms.\nwstring applySimpleCaseOnly( wstring const & );\n\n/// Applies only full case folding algorithm. This includes simple case, but also\n/// decomposing ligatures and complex letters.\nwstring applyFullCaseOnly( wstring const & );\n\n/// Applies only diacritics folding algorithm.\nwstring applyDiacriticsOnly( wstring const & );\n\n/// Applies only punctuation folding algorithm.\nwstring applyPunctOnly( wstring const & );\n\n/// Applies only whitespace folding algorithm.\nwstring applyWhitespaceOnly( wstring const & );\n\n/// Applies only whitespace&punctuation folding algorithm.\nwstring applyWhitespaceAndPunctOnly( wstring const & );\n\n/// Returns true if the given character is any form of whitespace, false\n/// otherwise. Whitespace corresponds to Zl/Zp/Zs Unicode classes, and also\n/// includes \\n, \\r and \\t.\nbool isWhitespace( wchar ch );\n\n/// Returns true if the given character is any form of punctuation, false\n/// otherwise. Punctuation corresponds to Pc/Pd/Pe/Pf/Pi/Po/Ps classes.\nbool isPunct( wchar ch );\n\n/// Removes any whitespace or punctuation from the beginning and the end of\n/// the word.\nwstring trimWhitespaceOrPunct( wstring const & );\n\n/// Removes any whitespace from the beginning and the end of\n/// the word.\nwstring trimWhitespace( wstring const & );\n\n/// Turns any sequences of consecutive whitespace into a single basic space.\nvoid normalizeWhitespace( wstring & );\n\n/// Same as apply( wstring ), but without any heap operations, therefore\n/// preferable when there're many strings to process. Returns -1 if the\n/// operation succeeded, or otherwise the minimum value of outSize required\n/// to succeed.\n/// Currently commented out, consider implementing it in case indices'\n/// generation would be too slow.\n//ssize_t apply( wchar const * in, wchar * out, size_t outSize );\n\n/// Unescape all wildcard symbols (for exast search)\nQString unescapeWildcardSymbols( QString const & );\n\n/// Escape all wildcard symbols (for place word to input line)\nQString escapeWildcardSymbols( QString const & );\n\n/// Return result of foldDiacritic() from \"inc_diacritic_folding.hh\"\nwchar foldedDiacritic( wchar const * in, size_t size, size_t & consumed );\n\n/// Tests if the given char is one of the Unicode combining marks.\nbool isCombiningMark( wchar ch );\n\n}\n\n#endif\n\n"
        },
        {
          "name": "forvo.cc",
          "type": "blob",
          "size": 12.2138671875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"forvo.hh\"\n#include \"wstring_qt.hh\"\n#include <QNetworkAccessManager>\n#include <QNetworkReply>\n#include <QtXml>\n#include <list>\n#include \"audiolink.hh\"\n#include \"htmlescape.hh\"\n#include \"country.hh\"\n#include \"language.hh\"\n#include \"langcoder.hh\"\n#include \"utf8.hh\"\n#include \"gddebug.hh\"\n#include \"qt4x5.hh\"\n\nnamespace Forvo {\n\nusing namespace Dictionary;\n\nnamespace {\n\nclass ForvoDictionary: public Dictionary::Class\n{\n  string name;\n  QString apiKey, languageCode;\n  QNetworkAccessManager & netMgr;\n\npublic:\n\n  ForvoDictionary( string const & id, string const & name_,\n                   QString const & apiKey_,\n                   QString const & languageCode_,\n                   QNetworkAccessManager & netMgr_ ):\n    Dictionary::Class( id, vector< string >() ),\n    name( name_ ),\n    apiKey( apiKey_ ),\n    languageCode( languageCode_ ),\n    netMgr( netMgr_ )\n  {\n  }\n\n  virtual string getName() throw()\n  { return name; }\n\n  virtual map< Property, string > getProperties() throw()\n  { return map< Property, string >(); }\n\n  virtual unsigned long getArticleCount() throw()\n  { return 0; }\n\n  virtual unsigned long getWordCount() throw()\n  { return 0; }\n\n  virtual sptr< WordSearchRequest > prefixMatch( wstring const & /*word*/,\n                                                 unsigned long /*maxResults*/ ) THROW_SPEC( std::exception )\n  {\n    sptr< WordSearchRequestInstant > sr = new WordSearchRequestInstant;\n\n    sr->setUncertain( true );\n\n    return sr;\n  }\n\n  virtual sptr< DataRequest > getArticle( wstring const &, vector< wstring > const & alts,\n                                          wstring const &, bool )\n    THROW_SPEC( std::exception );\n\nprotected:\n\n  virtual void loadIcon() throw();\n\n};\n\nsptr< DataRequest > ForvoDictionary::getArticle( wstring const & word,\n                                                 vector< wstring > const & alts,\n                                                 wstring const &, bool )\n  THROW_SPEC( std::exception )\n{\n  if ( word.size() > 80 )\n  {\n    // Don't make excessively large queries -- they're fruitless anyway\n\n    return new DataRequestInstant( false );\n  }\n  else\n    return new ForvoArticleRequest( word, alts, apiKey, languageCode, getId(),\n                                    netMgr );\n}\n\nvoid ForvoDictionary::loadIcon() throw()\n{\n  if ( dictionaryIconLoaded )\n    return;\n\n// Experimental code to generate icon -- but the flags clutter the interface too\n// much and we're better with a single icon.\n#if 0\n  if ( languageCode.size() == 2 )\n  {\n    QString countryCode = Language::countryCodeForId( LangCoder::code2toInt( languageCode.toLatin1().data() ) );\n\n    if ( countryCode.size() )\n    {\n      QImage flag( QString( \":/flags/%1.png\" ).arg( countryCode.toLower() ) );\n\n      if ( !flag.isNull() )\n      {\n        QImage img( \":/icons/forvo_icon_base.png\" );\n\n        {\n          QPainter painter( &img );\n          painter.drawImage( QPoint( 5, 7 ), flag );\n        }\n\n        return QIcon( QPixmap::fromImage( img ) );\n      }\n    }\n  }\n#endif\n  dictionaryIcon = dictionaryNativeIcon = QIcon( \":/icons/forvo.png\" );\n  dictionaryIconLoaded = true;\n}\n\n}\n\nvoid ForvoArticleRequest::cancel()\n{\n  finish();\n}\n\nForvoArticleRequest::ForvoArticleRequest( wstring const & str,\n                                          vector< wstring > const & alts,\n                                          QString const & apiKey_,\n                                          QString const & languageCode_,\n                                          string const & dictionaryId_,\n                                          QNetworkAccessManager & mgr ):\n  apiKey( apiKey_ ), languageCode( languageCode_ ),\n  dictionaryId( dictionaryId_ )\n{\n  connect( &mgr, SIGNAL( finished( QNetworkReply * ) ),\n           this, SLOT( requestFinished( QNetworkReply * ) ),\n           Qt::QueuedConnection );\n  \n  addQuery(  mgr, str );\n\n  for( unsigned x = 0; x < alts.size(); ++x )\n    addQuery( mgr, alts[ x ] );\n}\n\nvoid ForvoArticleRequest::addQuery( QNetworkAccessManager & mgr,\n                                    wstring const & str )\n{\n  gdDebug( \"Forvo: requesting article %s\\n\", gd::toQString( str ).toUtf8().data() );\n\n  QString key;\n\n  if ( apiKey.simplified().isEmpty() )\n  {\n    // Use the default api key. That's the key I have just registered myself.\n    // It has a limit of 1000 requests a day, and may also get banned in the\n    // future. Can't do much about it. Get your own key, it is simple.\n    key = \"5efa5d045a16d10ad9c4705bd5d8e56a\";\n  }\n  else\n    key = apiKey;\n\n  QUrl reqUrl = QUrl::fromEncoded(\n      QString( \"https://apifree.forvo.com\"\n               \"/key/\" + key +\n               \"/action/word-pronunciations\"\n               \"/format/xml\"\n               \"/word/\" + QLatin1String( QUrl::toPercentEncoding( gd::toQString( str ) ) ) +\n               \"/language/\" + languageCode +\n               \"/order/rate-desc\"\n       ).toUtf8() );\n\n//  DPRINTF( \"req: %s\\n\", reqUrl.toEncoded().data() );\n\n  sptr< QNetworkReply > netReply = mgr.get( QNetworkRequest( reqUrl ) );\n  \n  netReplies.push_back( NetReply( netReply, Utf8::encode( str ) ) );\n}\n\nvoid ForvoArticleRequest::requestFinished( QNetworkReply * r )\n{\n  GD_DPRINTF( \"Finished.\\n\" );\n\n  if ( isFinished() ) // Was cancelled\n    return;\n\n  // Find this reply\n\n  bool found = false;\n  \n  for( NetReplies::iterator i = netReplies.begin(); i != netReplies.end(); ++i )\n  {\n    if ( i->reply.get() == r )\n    {\n      i->finished = true; // Mark as finished\n      found = true;\n      break;\n    }\n  }\n\n  if ( !found )\n  {\n    // Well, that's not our reply, don't do anything\n    return;\n  }\n  \n  bool updated = false;\n\n  for( ; netReplies.size() && netReplies.front().finished; netReplies.pop_front() )\n  {\n    sptr< QNetworkReply > netReply = netReplies.front().reply;\n    \n    if ( netReply->error() == QNetworkReply::NoError )\n    {\n      QDomDocument dd;\n  \n      QString errorStr;\n      int errorLine, errorColumn;\n  \n      if ( !dd.setContent( netReply.get(), false, &errorStr, &errorLine, &errorColumn  ) )\n      {\n        setErrorString( QString( tr( \"XML parse error: %1 at %2,%3\" ).\n                                 arg( errorStr ).arg( errorLine ).arg( errorColumn ) ) );\n      }\n      else\n      {\n//        DPRINTF( \"%s\\n\", dd.toByteArray().data() );\n\n        QDomNode items = dd.namedItem( \"items\" );\n  \n        if ( !items.isNull() )\n        {\n          QDomNodeList nl = items.toElement().elementsByTagName( \"item\" );\n\n          if ( nl.count() )\n          {\n            string articleBody;\n\n            articleBody += \"<div class='forvo_headword'>\";\n            articleBody += Html::escape( netReplies.front().word );\n            articleBody += \"</div>\";\n\n            articleBody += \"<table class=\\\"forvo_play\\\">\";\n\n            for( Qt4x5::Dom::size_type x = 0; x < nl.length(); ++x )\n            {\n              QDomElement item = nl.item( x ).toElement();\n\n              QDomNode mp3 = item.namedItem( \"pathmp3\" );\n\n              if ( !mp3.isNull() )\n              {\n                articleBody += \"<tr>\";\n\n                QUrl url( mp3.toElement().text() );\n\n                string ref = string( \"\\\"\" ) + url.toEncoded().data() + \"\\\"\";\n\n                articleBody += addAudioLink( ref, dictionaryId ).c_str();\n\n                bool isMale = ( item.namedItem( \"sex\" ).toElement().text().toLower() != \"f\" );\n\n                QString user = item.namedItem( \"username\" ).toElement().text();\n                QString country = item.namedItem( \"country\" ).toElement().text();\n\n                string userProfile = string( \"http://www.forvo.com/user/\" ) +\n                                     QUrl::toPercentEncoding( user ).data() + \"/\";\n\n                int totalVotes = item.namedItem( \"num_votes\" ).toElement().text().toInt();\n                int positiveVotes = item.namedItem( \"num_positive_votes\" ).toElement().text().toInt();\n                int negativeVotes = totalVotes - positiveVotes;\n\n                string votes;\n\n                if ( positiveVotes || negativeVotes )\n                {\n                  votes += \" \";\n\n                  if ( positiveVotes )\n                  {\n                    votes += \"<span class='forvo_positive_votes'>+\";\n                    votes += QByteArray::number( positiveVotes ).data();\n                    votes += \"</span>\";\n                  }\n\n                  if ( negativeVotes )\n                  {\n                    if ( positiveVotes )\n                      votes += \" \";\n\n                    votes += \"<span class='forvo_negative_votes'>-\";\n                    votes += QByteArray::number( negativeVotes ).data();\n                    votes += \"</span>\";\n                  }\n                }\n\n                string addTime =\n                    tr( \"Added %1\" ).arg( item.namedItem( \"addtime\" ).toElement().text() ).toUtf8().data();\n\n                articleBody += \"<td><a href=\" + ref + \" title=\\\"\" + Html::escape( addTime ) + \"\\\"><img src=\\\"qrcx://localhost/icons/playsound.png\\\" border=\\\"0\\\" alt=\\\"Play\\\"/></a></td>\";\n                articleBody += string( \"<td>\" ) + tr( \"by\" ).toUtf8().data() + \" <a class='forvo_user' href='\"\n                               + userProfile + \"'>\"\n                               + Html::escape( user.toUtf8().data() )\n                               + \"</a> <span class='forvo_location'>(\"\n                               + ( isMale ? tr( \"Male\" ) : tr( \"Female\" ) ).toUtf8().data()\n                               + \" \"\n                               + tr( \"from\" ).toUtf8().data()\n                               + \" \"\n                               + \"<img src='qrcx://localhost/flags/\" + Country::englishNametoIso2( country ).toUtf8().data()\n                               + \".png'/> \"\n                               + Html::escape( country.toUtf8().data() )\n                               + \")</span>\"\n                               + votes\n                               + \"</td>\";\n                articleBody += \"</tr>\";\n              }\n            }\n\n            articleBody += \"</table>\";\n\n            Mutex::Lock _( dataMutex );\n\n            size_t prevSize = data.size();\n            \n            data.resize( prevSize + articleBody.size() );\n  \n            memcpy( &data.front() + prevSize, articleBody.data(), articleBody.size() );\n  \n            hasAnyData = true;\n\n            updated = true;\n          }\n        }\n\n        QDomNode errors = dd.namedItem( \"errors\" );\n\n        if ( !errors.isNull() )\n        {\n          QString text( errors.namedItem( \"error\" ).toElement().text() );\n\n          if ( text == \"Limit/day reached.\" && apiKey.simplified().isEmpty() )\n          {\n            // Give a hint that the user should apply for his own key.\n\n            text += \"\\n\" + tr( \"Go to Edit|Dictionaries|Sources|Forvo and apply for our own API key to make this error disappear.\" );\n          }\n\n          setErrorString( text );\n        }\n      }\n      GD_DPRINTF( \"done.\\n\" );\n    }\n    else\n      setErrorString( netReply->errorString() );\n  }\n\n  if ( netReplies.empty() )\n    finish();\n  else\n  if ( updated )\n    update();\n}\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      Dictionary::Initializing &,\n                                      Config::Forvo const & forvo,\n                                      QNetworkAccessManager & mgr )\n  THROW_SPEC( std::exception )\n{\n  vector< sptr< Dictionary::Class > > result;\n\n  if ( forvo.enable )\n  {\n    QStringList codes = forvo.languageCodes.split( ',', Qt4x5::skipEmptyParts() );\n\n    QSet< QString > usedCodes;\n\n    for( int x = 0; x < codes.size(); ++x )\n    {\n      QString code = codes[ x ].simplified();\n\n      if ( code.size() && !usedCodes.contains( code ) )\n      {\n        // Generate id\n\n        QCryptographicHash hash( QCryptographicHash::Md5 );\n\n        hash.addData( \"Forvo source version 1.0\" );\n        hash.addData( code.toUtf8() );\n\n        QString displayedCode( code.toLower() );\n\n        if ( displayedCode.size() )\n          displayedCode[ 0 ] = displayedCode[ 0 ].toUpper();\n\n        result.push_back(\n            new ForvoDictionary( hash.result().toHex().data(),\n                                 QString( \"Forvo (%1)\" ).arg( displayedCode ).toUtf8().data(),\n                                 forvo.apiKey, code, mgr ) );\n\n        usedCodes.insert( code );\n      }\n    }\n  }\n\n  return result;\n}\n\n}\n"
        },
        {
          "name": "forvo.hh",
          "type": "blob",
          "size": 1.6513671875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __FORVO_HH_INCLUDED__\n#define __FORVO_HH_INCLUDED__\n\n#include \"dictionary.hh\"\n#include \"config.hh\"\n#include <QNetworkAccessManager>\n#include \"wstring.hh\"\n#include <QNetworkReply>\n\n/// Support for Forvo pronunciations, based on its API.\nnamespace Forvo {\n\nusing std::vector;\nusing std::string;\nusing gd::wstring;\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      Dictionary::Initializing &,\n                                      Config::Forvo const &,\n                                      QNetworkAccessManager & )\n    THROW_SPEC( std::exception );\n\n/// Exposed here for moc\nclass ForvoArticleRequest: public Dictionary::DataRequest\n{\n  Q_OBJECT\n\n  struct NetReply\n  {\n    sptr< QNetworkReply > reply;\n    string word;\n    bool finished;\n\n    NetReply( sptr< QNetworkReply > const & reply_, string const & word_ ):\n      reply( reply_ ), word( word_ ), finished( false )\n    {}\n  };\n\n  typedef std::list< NetReply > NetReplies;\n  NetReplies netReplies;\n  QString apiKey, languageCode;\n  string dictionaryId;\n\npublic:\n\n  ForvoArticleRequest( wstring const & word, vector< wstring > const & alts,\n                       QString const & apiKey_,\n                       QString const & languageCode_,\n                       string const & dictionaryId_,\n                       QNetworkAccessManager & mgr );\n\n  virtual void cancel();\n\nprivate:\n\n  void addQuery( QNetworkAccessManager & mgr, wstring const & word );\n\nprivate slots:\n  virtual void requestFinished( QNetworkReply * );\n};\n\n}\n\n#endif\n"
        },
        {
          "name": "fsencoding.cc",
          "type": "blob",
          "size": 1.4755859375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"fsencoding.hh\"\n#include \"wstring_qt.hh\"\n#include <QString>\n#include <QDir>\n#include <vector>\n\nnamespace FsEncoding {\n\nstring encode( wstring const & str )\n{\n#ifdef __WIN32\n  return string( gd::toQString( str ).toUtf8().data() );\n#else\n  return string( gd::toQString( str ).toLocal8Bit().data() );\n#endif\n}\n\nstring encode( string const & str )\n{\n#ifdef __WIN32\n  return string( str );\n#else\n  return string( QString::fromUtf8( str.c_str() ).toLocal8Bit().data() );\n#endif\n}\n\nstring encode( QString const & str )\n{\n#ifdef __WIN32\n  return string( str.toUtf8().data() );\n#else\n  return string( str.toLocal8Bit().data() );\n#endif\n}\n\nwstring decode( string const & str )\n{\n#ifdef __WIN32\n  return gd::toWString( QString::fromUtf8( str.c_str() ) );\n#else\n  return gd::toWString( QString::fromLocal8Bit( str.c_str() ) );\n#endif\n}\n\nQString decode( const char *str )\n{\n#ifdef __WIN32\n  return QString::fromUtf8( str );\n#else\n  return QString::fromLocal8Bit( str );\n#endif\n}\n\nchar separator()\n{\n  return QDir::separator().toLatin1();\n}\n\nstring dirname( string const & str )\n{\n  size_t x = str.rfind( separator() );\n\n  if ( x == string::npos )\n    return string( \".\" );\n\n  return string( str, 0, x );\n}\n\nstring basename( string const & str )\n{\n  size_t x = str.rfind( separator() );\n\n  if ( x == string::npos )\n    return str;\n\n  return string( str, x + 1 );\n}\n\n}\n"
        },
        {
          "name": "fsencoding.hh",
          "type": "blob",
          "size": 1.212890625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __FSENCODING_HH_INCLUDED__\n#define __FSENCODING_HH_INCLUDED__\n\n#include \"wstring.hh\"\n#include <QString>\n\n/// Utilities to convert a wide string or an utf8 string to the local 8bit\n/// encoding of the file system, and to do other manipulations on the file\n/// names.\nnamespace FsEncoding {\n\nusing std::string;\nusing gd::wstring;\n\n/// Encodes the given wide string to the utf8 encoding.\nstring encode( wstring const & );\n\n/// Encodes the given string in utf8 to the system 8bit encoding.\nstring encode( string const & );\n\n/// Encodes the QString to the utf8/local 8-bit encoding.\nstring encode( QString const & );\n\n/// Decodes the given utf8-encoded string to a wide string.\nwstring decode( string const & str );\n\n/// Decodes the given utf8/local 8-bit string to a QString.\nQString decode( const char *str );\n\n/// Returns the filesystem separator (/ on Unix and clones, \\ on Windows).\nchar separator();\n\n/// Returns the directory part of the given filename.\nstring dirname( string const & );\n\n/// Returns the name part of the given filename.\nstring basename( string const & );\n\n}\n\n#endif\n"
        },
        {
          "name": "ftshelpers.cc",
          "type": "blob",
          "size": 38.4169921875,
          "content": "/* This file is (c) 2014 Abs62\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"fulltextsearch.hh\"\n#include \"ftshelpers.hh\"\n#include \"wstring_qt.hh\"\n#include \"file.hh\"\n#include \"gddebug.hh\"\n#include \"folding.hh\"\n#include \"qt4x5.hh\"\n\n#include <vector>\n#include <string>\n\n#include <QVector>\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n#include <QRegularExpression>\n#include \"wildcard.hh\"\n#endif\n\nusing std::vector;\nusing std::string;\n\nDEF_EX( exUserAbort, \"User abort\", Dictionary::Ex )\n\nnamespace FtsHelpers\n{\n\nbool ftsIndexIsOldOrBad( string const & indexFile,\n                         BtreeIndexing::BtreeDictionary * dict )\n{\n  File::Class idx( indexFile, \"rb\" );\n\n  FtsIdxHeader header;\n\n  return idx.readRecords( &header, sizeof( header ), 1 ) != 1 ||\n         header.signature != FtsSignature ||\n         header.formatVersion != CurrentFtsFormatVersion + dict->getFtsIndexVersion();\n}\n\nstatic QString makeHiliteRegExpString( QStringList const & words,\n                                       int searchMode,\n                                       int distanceBetweenWords )\n{\n  QString searchString( \"(\" );\n\n  QString stripWords( \"(?:\\\\W+\\\\w+){0,\" );\n  if( distanceBetweenWords >= 0 )\n    stripWords += QString::number( distanceBetweenWords );\n  stripWords += \"}\\\\W+\";\n\n  QString boundWord( searchMode == FTS::WholeWords ? \"\\\\b\" : \"(?:\\\\w*)\");\n\n  for( int x = 0; x < words.size(); x++ )\n  {\n    if( x )\n      searchString += stripWords;\n\n    searchString += boundWord + words[ x ] + boundWord;\n  }\n\n  searchString += \")\";\n  return searchString;\n}\n\nbool parseSearchString( QString const & str, QStringList & indexWords,\n                        QStringList & searchWords,\n                        QRegExp & searchRegExp, int searchMode,\n                        bool matchCase,\n                        int distanceBetweenWords,\n                        bool & hasCJK )\n{\n  searchWords.clear();\n  indexWords.clear();\n  QRegExp spacesRegExp( \"\\\\W+\" );\n  QRegExp wordRegExp( QString( \"\\\\w{\" ) + QString::number( FTS::MinimumWordSize ) + \",}\" );\n  QRegExp setsRegExp( \"\\\\[[^\\\\]]+\\\\]\", Qt::CaseInsensitive, QRegExp::RegExp2 );\n  QRegExp regexRegExp( \"\\\\\\\\[afnrtvdDwWsSbB]|\\\\\\\\x([0-9A-Fa-f]{4})|\\\\\\\\0([0-7]{3})\", Qt::CaseSensitive, QRegExp::RegExp2 );\n\n  hasCJK = false;\n  for( int x = 0; x < str.size(); x++ )\n    if( isCJKChar( str.at( x ).unicode() ) )\n    {\n      hasCJK = true;\n      break;\n    }\n\n  if( searchMode == FTS::WholeWords || searchMode == FTS::PlainText )\n  {\n    if( hasCJK )\n      return false;\n\n    // Make words list for search in article text\n    searchWords = str.normalized( QString::NormalizationForm_C )\n                     .split( spacesRegExp, Qt4x5::skipEmptyParts() );\n\n    // Make words list for index search\n    QStringList list = str.normalized( QString::NormalizationForm_C )\n                          .toLower().split( spacesRegExp, Qt4x5::skipEmptyParts() );\n    indexWords = list.filter( wordRegExp );\n    indexWords.removeDuplicates();\n\n    // Make regexp for results hilite\n\n    QStringList allWords = str.split( spacesRegExp, Qt4x5::skipEmptyParts() );\n    QString searchString = makeHiliteRegExpString( allWords, searchMode, distanceBetweenWords );\n\n    searchRegExp = QRegExp( searchString, matchCase ? Qt::CaseSensitive : Qt::CaseInsensitive,\n                            QRegExp::RegExp2 );\n    searchRegExp.setMinimal( true );\n\n    return !indexWords.isEmpty();\n  }\n  else\n  {\n    // Make words list for index search\n\n    QString tmp = str;\n\n    // Remove RegExp commands\n    if( searchMode == FTS::RegExp )\n      tmp.replace( regexRegExp, \" \" );\n\n    // Remove all symbol sets\n    tmp.replace( setsRegExp, \" \" );\n\n    QStringList list = tmp.normalized( QString::NormalizationForm_C )\n                          .toLower().split( spacesRegExp, Qt4x5::skipEmptyParts() );\n\n    if( hasCJK )\n    {\n      QStringList wordList, hieroglyphList;\n      for( int i = 0; i < list.size(); i ++ )\n      {\n        QString word = list.at( i );\n\n        // Check for CJK symbols in word\n        bool parsed = false;\n        QString hieroglyph;\n        for( int x = 0; x < word.size(); x++ )\n          if( isCJKChar( word.at( x ).unicode() ) )\n          {\n            parsed = true;\n            hieroglyph.append( word[ x ] );\n\n            if( QChar( word.at( x ) ).isHighSurrogate()\n                &&  QChar( word[ x + 1 ] ).isLowSurrogate() )\n              hieroglyph.append( word[ ++x ] );\n\n            hieroglyphList.append( hieroglyph );\n            hieroglyph.clear();\n          }\n\n        // If word don't contains CJK symbols put it in list as is\n        if( !parsed )\n          wordList.append( word );\n      }\n\n      indexWords = wordList.filter( wordRegExp );\n      indexWords.removeDuplicates();\n\n      hieroglyphList.removeDuplicates();\n      indexWords += hieroglyphList;\n    }\n    else\n    {\n      indexWords = list.filter( wordRegExp );\n      indexWords.removeDuplicates();\n    }\n\n    searchRegExp = QRegExp( str, matchCase ? Qt::CaseSensitive : Qt::CaseInsensitive,\n                            searchMode == FTS::Wildcards ? QRegExp::WildcardUnix : QRegExp::RegExp2 );\n    searchRegExp.setMinimal( true );\n  }\n\n  return true;\n}\n\nvoid parseArticleForFts( uint32_t articleAddress, QString & articleText,\n                         QMap< QString, QVector< uint32_t > > & words,\n                         bool handleRoundBrackets )\n{\n  if( articleText.isEmpty() )\n    return;\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  QRegularExpression regBrackets( \"(\\\\([\\\\w\\\\p{M}]+\\\\)){0,1}([\\\\w\\\\p{M}]+)(\\\\([\\\\w\\\\p{M}]+\\\\)){0,1}([\\\\w\\\\p{M}]+){0,1}(\\\\([\\\\w\\\\p{M}]+\\\\)){0,1}\",\n                                  QRegularExpression::UseUnicodePropertiesOption);\n  QRegularExpression regSplit( \"[^\\\\w\\\\p{M}]+\", QRegularExpression::UseUnicodePropertiesOption );\n\n  QStringList articleWords = articleText.normalized( QString::NormalizationForm_C )\n                                        .split( QRegularExpression( handleRoundBrackets ? \"[^\\\\w\\\\(\\\\)\\\\p{M}]+\" : \"[^\\\\w\\\\p{M}]+\",\n                                                                    QRegularExpression::UseUnicodePropertiesOption ),\n                                                Qt4x5::skipEmptyParts() );\n#else\n  QRegExp regBrackets = QRegExp( \"(\\\\(\\\\w+\\\\)){0,1}(\\\\w+)(\\\\(\\\\w+\\\\)){0,1}(\\\\w+){0,1}(\\\\(\\\\w+\\\\)){0,1}\" );\n  QRegExp regSplit = QRegExp( \"\\\\W+\" );\n\n  QStringList articleWords = articleText.normalized( QString::NormalizationForm_C )\n                                        .split( QRegExp( handleRoundBrackets ? \"[^\\\\w\\\\(\\\\)]+\" : \"\\\\W+\" ), Qt4x5::skipEmptyParts() );\n#endif\n\n  QSet< QString > setOfWords;\n  setOfWords.reserve( articleWords.size() );\n\n  for( int x = 0; x < articleWords.size(); x++ )\n  {\n    QString word = articleWords.at( x ).toLower();\n\n    bool hasCJK = false;\n    QString hieroglyph;\n\n    // If word contains CJK symbols we add to index only these symbols separately\n    for( int y = 0; y < word.size(); y++ )\n      if( isCJKChar( word.at( y ).unicode() ) )\n      {\n        hasCJK = true;\n        hieroglyph.append( word[ y ] );\n\n        if( QChar( word.at( y ) ).isHighSurrogate()\n            &&  QChar( word[ y + 1 ] ).isLowSurrogate() )\n          hieroglyph.append( word[ ++y ] );\n\n        if( !setOfWords.contains( hieroglyph ) )\n        {\n          setOfWords.insert( hieroglyph );\n          words[ hieroglyph ].push_back( articleAddress );\n        }\n\n        hieroglyph.clear();\n      }\n\n    if( !hasCJK )\n    {\n      // Else we add word to index as is\n      if( word.size() < FTS::MinimumWordSize )\n        continue;\n\n      if( handleRoundBrackets && ( word.indexOf( '(' ) >= 0 || word.indexOf( ')' ) >= 0 ) )\n      {\n        // Special handle for words with round brackets - DSL feature\n        QStringList list;\n\n        QStringList oldVariant = word.split( regSplit, Qt4x5::skipEmptyParts() );\n        for( QStringList::iterator it = oldVariant.begin(); it != oldVariant.end(); ++it )\n          if( it->size() >= FTS::MinimumWordSize && !list.contains( *it ) )\n            list.append( *it );\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n        QRegularExpressionMatch match = regBrackets.match( word );\n        if( match.hasMatch() )\n        {\n          QStringList parts = match.capturedTexts();\n          // Add empty strings for compatibility with QRegExp behaviour\n          for( int i = match.lastCapturedIndex() + 1; i < 6; i++ )\n            parts.append( QString() );\n#else\n        int pos = regBrackets.indexIn( word );\n        if( pos >= 0 )\n        {\n          QStringList parts = regBrackets.capturedTexts();\n#endif\n          QString parsedWord = parts[ 2 ] + parts[ 4 ]; // Brackets removed\n\n          if( parsedWord.size() >= FTS::MinimumWordSize && !list.contains( parsedWord ) )\n            list.append( parsedWord );\n\n          parsedWord = parts[ 1 ].remove( '(' ).remove( ')' )\n                       + parts[ 2 ]\n                       + parts[ 3 ].remove( '(' ).remove( ')' )\n                       + parts[ 4 ]\n                       + parts[ 5 ].remove( '(' ).remove( ')' ); // Brackets expansed\n\n          if( parsedWord.size() >= FTS::MinimumWordSize && !list.contains( parsedWord ) )\n            list.append( parsedWord );\n        }\n\n        for( QStringList::iterator it = list.begin(); it != list.end(); ++it )\n        {\n          if( !setOfWords.contains( *it ) )\n          {\n            setOfWords.insert( *it );\n            words[ *it ].push_back( articleAddress );\n          }\n        }\n      }\n      else\n      if( !setOfWords.contains( word ) )\n      {\n        setOfWords.insert( word );\n        words[ word ].push_back( articleAddress );\n      }\n    }\n  }\n}\n\nvoid makeFTSIndex( BtreeIndexing::BtreeDictionary * dict, QAtomicInt & isCancelled )\n{\n  Mutex::Lock _( dict->getFtsMutex() );\n\n  if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    throw exUserAbort();\n\n  File::Class ftsIdx( dict->ftsIndexName(), \"wb\" );\n\n  FtsIdxHeader ftsIdxHeader;\n  memset( &ftsIdxHeader, 0, sizeof( ftsIdxHeader ) );\n\n  // We write a dummy header first. At the end of the process the header\n  // will be rewritten with the right values.\n\n  ftsIdx.write( ftsIdxHeader );\n\n  ChunkedStorage::Writer chunks( ftsIdx );\n\n  BtreeIndexing::IndexedWords indexedWords;\n\n  QSet< uint32_t > setOfOffsets;\n  setOfOffsets.reserve( dict->getArticleCount() );\n\n  dict->findArticleLinks( 0, &setOfOffsets, 0, &isCancelled );\n\n  if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    throw exUserAbort();\n\n  QVector< uint32_t > offsets;\n  offsets.resize( setOfOffsets.size() );\n  uint32_t * ptr = &offsets.front();\n\n  for( QSet< uint32_t >::ConstIterator it = setOfOffsets.constBegin();\n       it != setOfOffsets.constEnd(); ++it )\n  {\n    *ptr = *it;\n    ptr++;\n  }\n\n  // Free memory\n  setOfOffsets.clear();\n  setOfOffsets.squeeze();\n\n  if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    throw exUserAbort();\n\n  dict->sortArticlesOffsetsForFTS( offsets, isCancelled );\n\n  QMap< QString, QVector< uint32_t > > ftsWords;\n\n  bool needHandleBrackets;\n  {\n    QString name = QString::fromUtf8( dict->getDictionaryFilenames()[ 0 ].c_str() ).toLower();\n    needHandleBrackets = name.endsWith( \".dsl\" ) || name.endsWith( \"dsl.dz\" );\n  }\n\n  // index articles for full-text search\n  for( int i = 0; i < offsets.size(); i++ )\n  {\n    if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      throw exUserAbort();\n\n    QString headword, articleStr;\n\n    dict->getArticleText( offsets.at( i ), headword, articleStr );\n\n    parseArticleForFts( offsets.at( i ), articleStr, ftsWords, needHandleBrackets );\n  }\n\n  // Free memory\n  offsets.clear();\n  offsets.squeeze();\n\n# define BUF_SIZE 20000\n  QVector< QPair< gd::wstring, uint32_t > > wordsWithOffsets;\n  wordsWithOffsets.reserve( BUF_SIZE );\n\n  QMap< QString, QVector< uint32_t > >::iterator it = ftsWords.begin();\n  while( it != ftsWords.end() )\n  {\n    if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      throw exUserAbort();\n\n    uint32_t offset = chunks.startNewBlock();\n    uint32_t size = it.value().size();\n\n    chunks.addToBlock( &size, sizeof(uint32_t) );\n    chunks.addToBlock( it.value().data(), size * sizeof(uint32_t) );\n\n    wordsWithOffsets.append( QPair< gd::wstring, uint32_t >( gd::toWString( it.key() ), offset ) );\n\n    it = ftsWords.erase( it );\n\n    if( wordsWithOffsets.size() >= BUF_SIZE )\n    {\n      for( int i = 0; i < wordsWithOffsets.size(); i++ )\n      {\n        if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n          throw exUserAbort();\n        indexedWords.addSingleWord( wordsWithOffsets[ i ].first, wordsWithOffsets[ i ].second );\n      }\n      wordsWithOffsets.clear();\n    }\n  }\n\n  // Free memory\n  ftsWords.clear();\n\n  for( int i = 0; i < wordsWithOffsets.size(); i++ )\n  {\n    if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      throw exUserAbort();\n    indexedWords.addSingleWord( wordsWithOffsets[ i ].first, wordsWithOffsets[ i ].second );\n  }\n#undef BUF_SIZE\n\n  // Free memory\n  wordsWithOffsets.clear();\n  wordsWithOffsets.squeeze();\n\n  ftsIdxHeader.chunksOffset = chunks.finish();\n  ftsIdxHeader.wordCount = indexedWords.size();\n\n  if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    throw exUserAbort();\n\n  BtreeIndexing::IndexInfo ftsIdxInfo = BtreeIndexing::buildIndex( indexedWords, ftsIdx );\n\n  // Free memory\n  indexedWords.clear();\n\n  ftsIdxHeader.indexBtreeMaxElements = ftsIdxInfo.btreeMaxElements;\n  ftsIdxHeader.indexRootOffset = ftsIdxInfo.rootOffset;\n\n  ftsIdxHeader.signature = FtsHelpers::FtsSignature;\n  ftsIdxHeader.formatVersion = FtsHelpers::CurrentFtsFormatVersion + dict->getFtsIndexVersion();\n\n  ftsIdx.rewind();\n  ftsIdx.writeRecords( &ftsIdxHeader, sizeof(ftsIdxHeader), 1 );\n}\n\nbool isCJKChar( ushort ch )\n{\n  if( ( ch >= 0x3400 && ch <= 0x9FFF )\n      || ( ch >= 0xF900 && ch <= 0xFAFF )\n      || ( ch >= 0xD800 && ch <= 0xDFFF ) )\n    return true;\n\n  return false;\n}\n\nvoid FTSResultsRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid FTSResultsRequest::checkArticles( QVector< uint32_t > const & offsets,\n                                       QStringList const & words,\n                                       QRegExp const & searchRegexp )\n{\n  int results = 0;\n  QString headword, articleText;\n  QList< uint32_t > offsetsForHeadwords;\n  QVector< QStringList > hiliteRegExps;\n\n  QString id = QString::fromUtf8( dict.getId().c_str() );\n  bool needHandleBrackets;\n  {\n    QString name = QString::fromUtf8( dict.getDictionaryFilenames()[ 0 ].c_str() ).toLower();\n    needHandleBrackets = name.endsWith( \".dsl\" ) || name.endsWith( \".dsl.dz\" );\n  }\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  QRegularExpression regBrackets( \"(\\\\([\\\\w\\\\p{M}]+\\\\)){0,1}([\\\\w\\\\p{M}]+)(\\\\([\\\\w\\\\p{M}]+\\\\)){0,1}([\\\\w\\\\p{M}]+){0,1}(\\\\([\\\\w\\\\p{M}]+\\\\)){0,1}\",\n                                  QRegularExpression::UseUnicodePropertiesOption);\n  QRegularExpression regSplit( \"[^\\\\w\\\\p{M}]+\", QRegularExpression::UseUnicodePropertiesOption );\n#else\n  QRegExp regBrackets = QRegExp( \"(\\\\(\\\\w+\\\\)){0,1}(\\\\w+)(\\\\(\\\\w+\\\\)){0,1}(\\\\w+){0,1}(\\\\(\\\\w+\\\\)){0,1}\" );\n  QRegExp regSplit = QRegExp( \"\\\\W+\" );\n#endif\n\n  if( searchMode == FTS::Wildcards || searchMode == FTS::RegExp )\n  {\n    // RegExp mode\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n    QRegularExpression searchRegularExpression;\n    if( searchMode == FTS::Wildcards )\n      searchRegularExpression.setPattern( wildcardsToRegexp( searchRegexp.pattern() ) );\n    else\n      searchRegularExpression.setPattern( searchRegexp.pattern() );\n    QRegularExpression::PatternOptions patternOptions = QRegularExpression::DotMatchesEverythingOption\n                                                        | QRegularExpression::UseUnicodePropertiesOption\n                                                        | QRegularExpression::MultilineOption\n                                                        | QRegularExpression::InvertedGreedinessOption;\n    if( searchRegexp.caseSensitivity() == Qt::CaseInsensitive )\n      patternOptions |= QRegularExpression::CaseInsensitiveOption;\n    searchRegularExpression.setPatternOptions( patternOptions );\n    if( !searchRegularExpression.isValid() )\n      searchRegularExpression.setPattern( \"\" );\n#endif\n    for( int i = 0; i < offsets.size(); i++ )\n    {\n      if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n        break;\n\n      dict.getArticleText( offsets.at( i ), headword, articleText );\n      articleText = articleText.normalized( QString::NormalizationForm_C );\n\n      if( ignoreDiacritics )\n        articleText = gd::toQString( Folding::applyDiacriticsOnly( gd::toWString( articleText ) ) );\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n      if( articleText.contains( searchRegularExpression ) )\n#else\n      if( articleText.contains( searchRegexp ) )\n#endif\n      {\n        if( headword.isEmpty() )\n          offsetsForHeadwords.append( offsets.at( i ) );\n        else\n          foundHeadwords->append( FTS::FtsHeadword( headword, id, QStringList(), matchCase ) );\n\n        results++;\n        if( maxResults > 0 && results >= maxResults )\n          break;\n      }\n    }\n  }\n  else\n  {\n    // Words mode\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n    QRegularExpression splitWithBrackets( \"[^\\\\w\\\\(\\\\)\\\\p{M}]+\", QRegularExpression::UseUnicodePropertiesOption );\n    QRegularExpression splitWithoutBrackets( \"[^\\\\w\\\\p{M}]+\", QRegularExpression::UseUnicodePropertiesOption );\n#else\n    QRegExp splitWithBrackets( \"[^\\\\w\\\\(\\\\)]+\" );\n    QRegExp splitWithoutBrackets( \"\\\\W+\" );\n#endif\n\n    Qt::CaseSensitivity cs = matchCase ? Qt::CaseSensitive : Qt::CaseInsensitive;\n    QVector< QPair< QString, bool > > wordsList;\n    if( ignoreWordsOrder )\n    {\n      for( QStringList::const_iterator it = words.begin(); it != words.end(); ++it )\n        wordsList.append( QPair< QString, bool >( *it, true ) );\n    }\n\n    for( int i = 0; i < offsets.size(); i++ )\n    {\n      if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n        break;\n\n      int pos = 0;\n      int matchWordNom = 0;\n      int unmatchWordNom = 0;\n      int nextNotFoundPos = 0;\n\n      QVector< QStringList > allOrders;\n      QStringList order;\n\n      if( ignoreWordsOrder )\n      {\n        for( int i = 0; i < wordsList.size(); i++ )\n          wordsList[ i ].second = true;\n      }\n\n      dict.getArticleText( offsets.at( i ), headword, articleText );\n\n      articleText = articleText.normalized( QString::NormalizationForm_C );\n\n      if( ignoreDiacritics )\n        articleText = gd::toQString( Folding::applyDiacriticsOnly( gd::toWString( articleText ) ) );\n\n      QStringList articleWords = articleText.split( needHandleBrackets ? splitWithBrackets : splitWithoutBrackets,\n                                                    Qt4x5::skipEmptyParts() );\n\n      int wordsNum = articleWords.length();\n      while ( pos < wordsNum )\n      {\n          QString s = articleWords[ pos ];\n          bool breakSearch = false;\n\n          QStringList parsedWords;\n          if( needHandleBrackets && ( s.indexOf( '(' ) >= 0 || s.indexOf( ')' ) >= 0 ) )\n          {\n            // Handle brackets\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n            QRegularExpressionMatch match_brackets = regBrackets.match( s );\n            if( match_brackets.hasMatch() )\n            {\n              QStringList parts = match_brackets.capturedTexts();\n              // Add empty strings for compatibility with QRegExp behaviour\n              for( int i = match_brackets.lastCapturedIndex() + 1; i < 6; i++ )\n                parts.append( QString() );\n#else\n            int pos = regBrackets.indexIn( s );\n            if( pos >= 0 )\n            {\n              QStringList parts = regBrackets.capturedTexts();\n#endif\n              QString word = parts[ 2 ] + parts[ 4 ]; // Brackets removed\n              parsedWords.append( word );\n\n              word = parts[ 1 ].remove( '(' ).remove( ')' )\n                     + parts[ 2 ]\n                     + parts[ 3 ].remove( '(' ).remove( ')' )\n                     + parts[ 4 ]\n                     + parts[ 5 ].remove( '(' ).remove( ')' ); // Brackets expansed\n              parsedWords.append( word );\n            }\n            else\n              parsedWords = s.split( regSplit, Qt4x5::skipEmptyParts() );\n          }\n          else\n            parsedWords.append( s );\n\n          int n;\n          for( n = 0; n < parsedWords.size(); n++ )\n          {\n            if( ignoreWordsOrder )\n            {\n              int i;\n              for( i = 0; i < wordsList.size(); i++ )\n              {\n                if( wordsList.at( i ).second )\n                {\n                  if( ( searchMode == FTS::WholeWords && parsedWords.at( n ).compare( wordsList.at( i ).first, cs ) == 0 )\n                      || ( searchMode == FTS::PlainText && parsedWords.at( n ).contains( wordsList.at( i ).first, cs ) ) )\n                  {\n                    wordsList[ i ].second = false;\n\n                    if( parsedWords.size() > 1 )\n                    {\n                      QString wordToHilite = s;\n                      while( !wordToHilite.isEmpty() && ( wordToHilite.at( 0 ) == '(' || wordToHilite.at( 0 ) == ')' ) )\n                        wordToHilite.remove( 0, 1 );\n                      while( !wordToHilite.isEmpty() && ( wordToHilite.endsWith( '(' ) || wordToHilite.endsWith( ')' ) ) )\n                        wordToHilite.chop( 1 );\n                      order.append( wordToHilite.replace( '(', \"\\\\(\" ).replace( ')', \"\\\\)\" ) );\n                    }\n                    else\n                      order.append( wordsList.at( i ).first );\n\n                    break;\n                  }\n                }\n              }\n              if( i < wordsList.size() )\n              {\n                // Word found\n\n                matchWordNom += 1;\n\n                if( matchWordNom == 1 )\n                {\n                  // Store position to remake search if sequence will not be found\n                  nextNotFoundPos = pos + 1;\n                }\n\n                if( matchWordNom >= words.size() )\n                {\n                  // All words are found\n                  // Store found words sequence and continue search\n                  // It's nesessary for hilite search results\n\n                  // Check if such sequence already presented\n                  int x;\n                  for( x = 0; x < allOrders.size(); x++ )\n                  {\n                    if( allOrders[ x ] == order )\n                      break;\n                  }\n                  if( x >= allOrders.size() )\n                    allOrders.append( order );\n\n                  order.clear();\n\n                  matchWordNom = 0;\n                  unmatchWordNom = 0;\n                  for( int i = 0; i < wordsList.size(); i++ )\n                    wordsList[ i ].second = true;\n                  nextNotFoundPos = 0;\n\n                  break;\n                }\n\n                unmatchWordNom = 0;\n                break;\n              }\n              else\n              if( matchWordNom > 0 && n >= parsedWords.size() - 1 )\n              {\n                unmatchWordNom += 1;\n                if( distanceBetweenWords >= 0 && unmatchWordNom > distanceBetweenWords )\n                {\n                  // Sequence broken, clear all counters\n                  matchWordNom = 0;\n                  unmatchWordNom = 0;\n                  for( int i = 0; i < wordsList.size(); i++ )\n                    wordsList[ i ].second = true;\n                  order.clear();\n                }\n              }\n            }\n            else\n            {\n              if( ( searchMode == FTS::WholeWords && parsedWords.at( n ).compare( words.at( matchWordNom ), cs ) == 0 )\n                  || ( searchMode == FTS::PlainText && parsedWords.at( n ).contains( words.at( matchWordNom ), cs ) ) )\n              {\n                matchWordNom += 1;\n\n                if( matchWordNom == 1 )\n                {\n                  // Store position to remake search if sequence will not be found\n                  nextNotFoundPos = pos + 1;\n                }\n\n                if( needHandleBrackets )\n                {\n                  if( parsedWords.size() > 1 )\n                  {\n                    QString wordToHilite = s;\n                    while( !wordToHilite.isEmpty() && ( wordToHilite.at( 0 ) == '(' || wordToHilite.at( 0 ) == ')' ) )\n                      wordToHilite.remove( 0, 1 );\n                    while( !wordToHilite.isEmpty() && ( wordToHilite.endsWith( '(' ) || wordToHilite.endsWith( ')' ) ) )\n                      wordToHilite.chop( 1 );\n                    order.append( wordToHilite.replace( '(', \"\\\\(\" ).replace( ')', \"\\\\)\" ) );\n                  }\n                  else\n                    order.append( words.at( matchWordNom - 1 ) );\n                }\n\n                if( matchWordNom >= words.size() )\n                {\n                  // All words are found\n                  if( needHandleBrackets )\n                  {\n                    if( allOrders.isEmpty() )\n                      allOrders.append( words );\n\n                    // Check if such sequence already presented\n                    int x;\n                    for( x = 0; x < allOrders.size(); x++ )\n                    {\n                      if( allOrders[ x ] == order )\n                        break;\n                    }\n                    if( x >= allOrders.size() )\n                      allOrders.append( order );\n\n                    matchWordNom = 0;\n                    unmatchWordNom = 0;\n                    order.clear();\n                    nextNotFoundPos = 0;\n                  }\n                  else\n                    breakSearch = true;\n                  break;\n                }\n                unmatchWordNom = 0;\n                break;\n              }\n              else\n              if( matchWordNom > 0 && n >= parsedWords.size() - 1 )\n              {\n                unmatchWordNom += 1;\n                if( distanceBetweenWords >= 0 && unmatchWordNom > distanceBetweenWords )\n                {\n                  matchWordNom = 0;\n                  unmatchWordNom = 0;\n                  if( needHandleBrackets )\n                    order.clear();\n                }\n              }\n            }\n          }\n          if( breakSearch )\n            break;\n          if( nextNotFoundPos > 0 && matchWordNom == 0 )\n          {\n            pos = nextNotFoundPos;\n            nextNotFoundPos = 0;\n          }\n          else\n            pos += 1;\n      }\n\n      if( !allOrders.isEmpty() || matchWordNom >= words.size() )\n      {\n        QStringList hiliteReg;\n        if( !allOrders.isEmpty() )\n        {\n          for( int i = 0; i < allOrders.size(); i++ )\n          {\n            QString hiliteStr = makeHiliteRegExpString( allOrders.at( i ), searchMode, distanceBetweenWords );\n            hiliteReg.append( hiliteStr );\n          }\n          allOrders.clear();\n        }\n        if( headword.isEmpty() )\n        {\n          offsetsForHeadwords.append( offsets.at( i ) );\n          hiliteRegExps.append( hiliteReg );\n        }\n        else\n          foundHeadwords->append( FTS::FtsHeadword( headword, id, hiliteReg, matchCase ) );\n\n        results++;\n        if( maxResults > 0 && results >= maxResults )\n          break;\n      }\n    }\n  }\n  if( !offsetsForHeadwords.isEmpty() )\n  {\n    QVector< QString > headwords;\n    dict.getHeadwordsFromOffsets( offsetsForHeadwords, headwords, &isCancelled );\n    for( int x = 0; x < headwords.size(); x++ )\n      foundHeadwords->append( FTS::FtsHeadword( headwords.at( x ), id, x < hiliteRegExps.size() ? hiliteRegExps.at( x ) : QStringList(), matchCase ) );\n  }\n}\n\nvoid FTSResultsRequest::indexSearch( BtreeIndexing::BtreeIndex & ftsIndex,\n                                     sptr< ChunkedStorage::Reader > chunks,\n                                     QStringList & indexWords,\n                                     QStringList & searchWords )\n{\n  // Find articles which contains all requested words\n\n  vector< BtreeIndexing::WordArticleLink > links;\n  QSet< uint32_t > setOfOffsets, tmp;\n  uint32_t size;\n\n  if( indexWords.isEmpty() )\n    return;\n\n  int n = indexWords.length();\n  for( int i = 0; i < n; i++ )\n  {\n    if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      return;\n\n    tmp.clear();\n\n    links = ftsIndex.findArticles( gd::toWString( indexWords.at( i ) ), ignoreDiacritics );\n    for( unsigned x = 0; x < links.size(); x++ )\n    {\n\n      if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n        return;\n\n      vector< char > chunk;\n      char * linksPtr;\n      {\n        Mutex::Lock _( dict.getFtsMutex() );\n        linksPtr = chunks->getBlock( links[ x ].articleOffset, chunk );\n      }\n\n      memcpy( &size, linksPtr, sizeof(uint32_t) );\n      linksPtr += sizeof(uint32_t);\n      for( uint32_t y = 0; y < size; y++ )\n      {\n        tmp.insert( *( reinterpret_cast< uint32_t * >( linksPtr ) ) );\n        linksPtr += sizeof(uint32_t);\n      }\n    }\n\n    links.clear();\n\n    if( i == 0 )\n      setOfOffsets = tmp;\n    else\n      setOfOffsets = setOfOffsets.intersect( tmp );\n  }\n\n  tmp.clear();\n\n  if( setOfOffsets.isEmpty() )\n    return;\n\n  QVector< uint32_t > offsets;\n  offsets.resize( setOfOffsets.size() );\n  uint32_t * ptr = &offsets.front();\n\n  for( QSet< uint32_t >::ConstIterator it = setOfOffsets.constBegin();\n       it != setOfOffsets.constEnd(); ++it )\n  {\n    *ptr = *it;\n    ptr++;\n  }\n\n  setOfOffsets.clear();\n\n  dict.sortArticlesOffsetsForFTS( offsets, isCancelled );\n\n  checkArticles( offsets, searchWords );\n}\n\nvoid FTSResultsRequest::combinedIndexSearch( BtreeIndexing::BtreeIndex & ftsIndex,\n                                             sptr< ChunkedStorage::Reader > chunks,\n                                             QStringList & indexWords,\n                                             QStringList & searchWords,\n                                             QRegExp & regexp )\n{\n  // Special case - combination of index search for hieroglyphs\n  // and full index search for other words\n\n  QSet< uint32_t > setOfOffsets;\n  uint32_t size;\n\n  if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    return;\n\n  if( indexWords.isEmpty() )\n    return;\n\n  QStringList wordsList, hieroglyphsList;\n\n  for( int x = 0; x < indexWords.size(); x++ )\n  {\n    QString const & word = indexWords.at( x );\n    if( isCJKChar( word[ 0 ].unicode() ) )\n      hieroglyphsList.append( word );\n    else\n      wordsList.append( word );\n  }\n\n  QVector< QSet< uint32_t > > allWordsLinks;\n\n  int n = wordsList.size();\n  if( !hieroglyphsList.isEmpty() )\n    n += 1;\n\n  allWordsLinks.resize( n );\n  int wordNom = 0;\n\n  if( !hieroglyphsList.empty() )\n  {\n    QSet< uint32_t > tmp;\n    vector< BtreeIndexing::WordArticleLink > links;\n\n    for( int i = 0; i < hieroglyphsList.size(); i++ )\n    {\n      links = ftsIndex.findArticles( gd::toWString( hieroglyphsList.at( i ) ) );\n      for( unsigned x = 0; x < links.size(); x++ )\n      {\n\n        if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n          return;\n\n        vector< char > chunk;\n        char * linksPtr;\n        {\n          Mutex::Lock _( dict.getFtsMutex() );\n          linksPtr = chunks->getBlock( links[ x ].articleOffset, chunk );\n        }\n\n        memcpy( &size, linksPtr, sizeof(uint32_t) );\n        linksPtr += sizeof(uint32_t);\n        for( uint32_t y = 0; y < size; y++ )\n        {\n          tmp.insert( *( reinterpret_cast< uint32_t * >( linksPtr ) ) );\n          linksPtr += sizeof(uint32_t);\n        }\n      }\n\n      links.clear();\n\n      if( i == 0 )\n        setOfOffsets = tmp;\n      else\n        setOfOffsets = setOfOffsets.intersect( tmp );\n    }\n\n    allWordsLinks[ wordNom ] = setOfOffsets;\n    setOfOffsets.clear();\n    wordNom += 1;\n  }\n\n  if( !wordsList.isEmpty() )\n  {\n    QVector< BtreeIndexing::WordArticleLink > links;\n    links.reserve( wordsInIndex );\n    ftsIndex.findArticleLinks( &links, 0, 0, &isCancelled );\n\n    for( int x = 0; x < links.size(); x++ )\n    {\n      if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n        return;\n\n      QString word = QString::fromUtf8( links[ x ].word.data(), links[ x ].word.size() );\n\n      if( ignoreDiacritics )\n        word = gd::toQString( Folding::applyDiacriticsOnly( gd::toWString( word ) ) );\n\n      for( int i = 0; i < wordsList.size(); i++ )\n      {\n        if( word.length() >= wordsList.at( i ).length() && word.contains( wordsList.at( i ) ) )\n        {\n          vector< char > chunk;\n          char * linksPtr;\n          {\n            Mutex::Lock _( dict.getFtsMutex() );\n            linksPtr = chunks->getBlock( links[ x ].articleOffset, chunk );\n          }\n\n          memcpy( &size, linksPtr, sizeof(uint32_t) );\n          linksPtr += sizeof(uint32_t);\n          for( uint32_t y = 0; y < size; y++ )\n          {\n            allWordsLinks[ wordNom ].insert( *( reinterpret_cast< uint32_t * >( linksPtr ) ) );\n            linksPtr += sizeof(uint32_t);\n          }\n          wordNom += 1;\n          if( searchMode == FTS::PlainText || searchMode == FTS::WholeWords )\n            break;\n        }\n      }\n    }\n\n    links.clear();\n  }\n\n  for( int i = 0; i < allWordsLinks.size(); i++ )\n  {\n    if( i == 0 )\n      setOfOffsets = allWordsLinks.at( i );\n    else\n      setOfOffsets = setOfOffsets.intersect( allWordsLinks.at( i ) );\n  }\n\n  if( setOfOffsets.isEmpty() )\n    return;\n\n  allWordsLinks.clear();\n\n  QVector< uint32_t > offsets;\n  offsets.resize( setOfOffsets.size() );\n  uint32_t * ptr = &offsets.front();\n\n  for( QSet< uint32_t >::ConstIterator it = setOfOffsets.constBegin();\n       it != setOfOffsets.constEnd(); ++it )\n  {\n    *ptr = *it;\n    ptr++;\n  }\n\n  setOfOffsets.clear();\n\n  dict.sortArticlesOffsetsForFTS( offsets, isCancelled );\n\n  checkArticles( offsets, searchWords, regexp );\n}\n\nvoid FTSResultsRequest::fullIndexSearch( BtreeIndexing::BtreeIndex & ftsIndex,\n                                         sptr< ChunkedStorage::Reader > chunks,\n                                         QStringList & indexWords,\n                                         QStringList & searchWords,\n                                         QRegExp & regexp )\n{\n  QSet< uint32_t > setOfOffsets;\n  uint32_t size;\n  QVector< BtreeIndexing::WordArticleLink > links;\n\n  if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    return;\n\n  if( indexWords.isEmpty() )\n    return;\n\n  links.reserve( wordsInIndex );\n  ftsIndex.findArticleLinks( &links, 0, 0, &isCancelled );\n\n  QVector< QSet< uint32_t > > allWordsLinks;\n  allWordsLinks.resize( indexWords.size() );\n\n  for( int x = 0; x < links.size(); x++ )\n  {\n    if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      return;\n\n    QString word = QString::fromUtf8( links[ x ].word.data(), links[ x ].word.size() );\n\n    if( ignoreDiacritics )\n      word = gd::toQString( Folding::applyDiacriticsOnly( gd::toWString( word ) ) );\n\n    for( int i = 0; i < indexWords.size(); i++ )\n    {\n      if( word.length() >= indexWords.at( i ).length() && word.contains( indexWords.at( i ) ) )\n      {\n        vector< char > chunk;\n        char * linksPtr;\n        {\n          Mutex::Lock _( dict.getFtsMutex() );\n          linksPtr = chunks->getBlock( links[ x ].articleOffset, chunk );\n        }\n\n        memcpy( &size, linksPtr, sizeof(uint32_t) );\n        linksPtr += sizeof(uint32_t);\n        for( uint32_t y = 0; y < size; y++ )\n        {\n          allWordsLinks[ i ].insert( *( reinterpret_cast< uint32_t * >( linksPtr ) ) );\n          linksPtr += sizeof(uint32_t);\n        }\n        if( searchMode == FTS::PlainText )\n          break;\n      }\n    }\n  }\n\n  links.clear();\n\n  for( int i = 0; i < allWordsLinks.size(); i++ )\n  {\n    if( i == 0 )\n      setOfOffsets = allWordsLinks.at( i );\n    else\n      setOfOffsets = setOfOffsets.intersect( allWordsLinks.at( i ) );\n  }\n\n  if( setOfOffsets.isEmpty() )\n    return;\n\n  allWordsLinks.clear();\n\n  QVector< uint32_t > offsets;\n  offsets.resize( setOfOffsets.size() );\n  uint32_t * ptr = &offsets.front();\n\n  for( QSet< uint32_t >::ConstIterator it = setOfOffsets.constBegin();\n       it != setOfOffsets.constEnd(); ++it )\n  {\n    *ptr = *it;\n    ptr++;\n  }\n\n  setOfOffsets.clear();\n\n  dict.sortArticlesOffsetsForFTS( offsets, isCancelled );\n\n  checkArticles( offsets, searchWords, regexp );\n}\n\nvoid FTSResultsRequest::fullSearch( QStringList & searchWords, QRegExp & regexp )\n{\n  // Whole file survey\n\n  if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    return;\n\n  QSet< uint32_t > setOfOffsets;\n  setOfOffsets.reserve( dict.getArticleCount() );\n  dict.findArticleLinks( 0, &setOfOffsets, 0, &isCancelled );\n\n  if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    return;\n\n  QVector< uint32_t > offsets;\n  offsets.resize( setOfOffsets.size() );\n  uint32_t * ptr = &offsets.front();\n\n  for( QSet< uint32_t >::ConstIterator it = setOfOffsets.constBegin();\n       it != setOfOffsets.constEnd(); ++it )\n  {\n    *ptr = *it;\n    ptr++;\n  }\n\n  if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    return;\n\n  setOfOffsets.clear();\n\n  dict.sortArticlesOffsetsForFTS( offsets, isCancelled );\n\n  if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    return;\n\n  checkArticles( offsets, searchWords, regexp );\n}\n\nvoid FTSResultsRequest::run()\n{\n  if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  if ( dict.ensureInitDone().size() )\n  {\n    setErrorString( QString::fromUtf8( dict.ensureInitDone().c_str() ) );\n    finish();\n    return;\n  }\n\n  try\n  {\n    QStringList indexWords, searchWords;\n    QRegExp searchRegExp;\n\n    if( !FtsHelpers::parseSearchString( searchString, indexWords, searchWords, searchRegExp,\n                                        searchMode, matchCase, distanceBetweenWords, hasCJK ) )\n    {\n      finish();\n      return;\n    }\n\n    if( dict.haveFTSIndex() && !indexWords.isEmpty() )\n    {\n      FtsIdxHeader ftsIdxHeader;\n      BtreeIndexing::BtreeIndex ftsIndex;\n      sptr< ChunkedStorage::Reader > chunks;\n\n      File::Class ftsIdx( dict.ftsIndexName(), \"rb\" );\n\n      {\n        Mutex::Lock _( dict.getFtsMutex() );\n\n        ftsIdxHeader = ftsIdx.read< FtsIdxHeader >();\n\n        wordsInIndex = ftsIdxHeader.wordCount;\n\n        ftsIndex.openIndex( BtreeIndexing::IndexInfo( ftsIdxHeader.indexBtreeMaxElements,\n                                                      ftsIdxHeader.indexRootOffset ),\n                            ftsIdx, dict.getFtsMutex() );\n\n        chunks = new ChunkedStorage::Reader( ftsIdx, ftsIdxHeader.chunksOffset );\n      }\n\n      if( hasCJK )\n        combinedIndexSearch( ftsIndex, chunks, indexWords, searchWords, searchRegExp );\n      else\n      {\n        if( searchMode == FTS::WholeWords )\n          indexSearch( ftsIndex, chunks, indexWords, searchWords );\n        else\n          fullIndexSearch( ftsIndex, chunks, indexWords, searchWords, searchRegExp );\n      }\n    }\n    else\n    {\n      fullSearch( searchWords, searchRegExp );\n    }\n\n    if( foundHeadwords && foundHeadwords->size() > 0 )\n    {\n      Mutex::Lock _( dataMutex );\n      data.resize( sizeof( foundHeadwords ) );\n      memcpy( &data.front(), &foundHeadwords, sizeof( foundHeadwords ) );\n      foundHeadwords = 0;\n      hasAnyData = true;\n    }\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"FTS: Failed full-text search for \\\"%s\\\", reason: %s\\n\",\n               dict.getName().c_str(), ex.what() );\n    // Results not loaded -- we don't set the hasAnyData flag then\n  }\n\n  finish();\n}\n\n} // namespace\n\n"
        },
        {
          "name": "ftshelpers.hh",
          "type": "blob",
          "size": 4.64453125,
          "content": "#ifndef __FTSHELPERS_HH_INCLUDED__\n#define __FTSHELPERS_HH_INCLUDED__\n\n#include <QString>\n#include <QRegExp>\n#include <QRunnable>\n#include <QSemaphore>\n#include <QList>\n\n#include \"dictionary.hh\"\n#include \"btreeidx.hh\"\n#include \"fulltextsearch.hh\"\n#include \"chunkedstorage.hh\"\n#include \"folding.hh\"\n#include \"wstring_qt.hh\"\n\n#include <string>\n\nnamespace FtsHelpers\n{\n\nenum\n{\n  FtsSignature = 0x58535446, // FTSX on little-endian, XSTF on big-endian\n  CurrentFtsFormatVersion = 2 + BtreeIndexing::FormatVersion + Folding::Version,\n};\n\n#pragma pack(push,1)\n\nstruct FtsIdxHeader\n{\n  uint32_t signature; // First comes the signature, FTSX\n  uint32_t formatVersion; // File format version\n  uint32_t chunksOffset; // The offset to chunks' storage\n  uint32_t indexBtreeMaxElements; // Two fields from IndexInfo\n  uint32_t indexRootOffset;\n  uint32_t wordCount; // Number of unique words this dictionary has\n}\n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\n#pragma pack(pop)\n\nbool ftsIndexIsOldOrBad( std::string const & indexFile,\n                         BtreeIndexing::BtreeDictionary * dict );\n\nbool parseSearchString( QString const & str, QStringList & IndexWords,\n                        QStringList & searchWords,\n                        QRegExp & searchRegExp, int searchMode,\n                        bool matchCase,\n                        int distanceBetweenWords,\n                        bool & hasCJK );\n\nvoid parseArticleForFts( uint32_t articleAddress, QString & articleText,\n                         QMap< QString, QVector< uint32_t > > & words,\n                         bool handleRoundBrackets = false );\n\nvoid makeFTSIndex( BtreeIndexing::BtreeDictionary * dict, QAtomicInt & isCancelled );\n\nbool isCJKChar( ushort ch );\n\nclass FTSResultsRequest;\n\nclass FTSResultsRequestRunnable : public QRunnable\n{\n  FTSResultsRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  FTSResultsRequestRunnable( FTSResultsRequest & r_,\n                             QSemaphore & hasExited_ ) : r( r_ ),\n                                                         hasExited( hasExited_ )\n  {}\n\n  ~FTSResultsRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass FTSResultsRequest : public Dictionary::DataRequest\n{\n  BtreeIndexing::BtreeDictionary & dict;\n\n  QString searchString;\n  int searchMode;\n  bool matchCase;\n  int distanceBetweenWords;\n  int maxResults;\n  bool hasCJK;\n  bool ignoreWordsOrder;\n  bool ignoreDiacritics;\n  int wordsInIndex;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\n  QList< FTS::FtsHeadword > * foundHeadwords;\n\n  void checkArticles( QVector< uint32_t > const & offsets,\n                      QStringList const & words,\n                      QRegExp const & searchRegexp = QRegExp() );\n\n  void indexSearch( BtreeIndexing::BtreeIndex & ftsIndex,\n                    sptr< ChunkedStorage::Reader > chunks,\n                    QStringList & indexWords,\n                    QStringList & searchWords );\n\n  void combinedIndexSearch( BtreeIndexing::BtreeIndex & ftsIndex,\n                            sptr< ChunkedStorage::Reader > chunks,\n                            QStringList & indexWords,\n                            QStringList & searchWords,\n                            QRegExp & regexp );\n\n  void fullIndexSearch( BtreeIndexing::BtreeIndex & ftsIndex,\n                        sptr< ChunkedStorage::Reader > chunks,\n                        QStringList & indexWords,\n                        QStringList & searchWords,\n                        QRegExp & regexp );\n\n  void fullSearch( QStringList & searchWords, QRegExp & regexp );\n\npublic:\n\n  FTSResultsRequest( BtreeIndexing::BtreeDictionary & dict_, QString const & searchString_,\n                     int searchMode_, bool matchCase_, int distanceBetweenWords_, int maxResults_,\n                     bool ignoreWordsOrder_, bool ignoreDiacritics_, QThreadPool * ftsThreadPoolPtr ):\n    dict( dict_ ),\n    searchString( searchString_ ),\n    searchMode( searchMode_ ),\n    matchCase( matchCase_ ),\n    distanceBetweenWords( distanceBetweenWords_ ),\n    maxResults( maxResults_ ),\n    hasCJK( false ),\n    ignoreWordsOrder( ignoreWordsOrder_ ),\n    ignoreDiacritics( ignoreDiacritics_ ),\n    wordsInIndex( 0 )\n  {\n    if( ignoreDiacritics_ )\n      searchString = gd::toQString( Folding::applyDiacriticsOnly( gd::toWString( searchString_ ) ) );\n\n    foundHeadwords = new QList< FTS::FtsHeadword >;\n    ftsThreadPoolPtr->start(\n      new FTSResultsRequestRunnable( *this, hasExited ), -100 );\n  }\n\n  void run();\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~FTSResultsRequest()\n  {\n    isCancelled.ref();\n    if( foundHeadwords )\n      delete foundHeadwords;\n    hasExited.acquire();\n  }\n};\n\n} // namespace\n\n#endif // __FTSHELPERS_HH_INCLUDED__\n"
        },
        {
          "name": "fulltextsearch.cc",
          "type": "blob",
          "size": 22.37109375,
          "content": "/* This file is (c) 2014 Abs62\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"fulltextsearch.hh\"\n#include \"ftshelpers.hh\"\n#include \"gddebug.hh\"\n#include \"mainwindow.hh\"\n#include \"qt4x5.hh\"\n\n#include <QThreadPool>\n#include <QIntValidator>\n#include <QMessageBox>\n#include <qalgorithms.h>\n\n#if ( QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 ) ) && defined( Q_OS_WIN32 )\n\n#include \"initializing.hh\"\n#include <qt_windows.h>\n#include <uxtheme.h>\n\n#endif\n\nnamespace FTS\n{\n\nenum\n{\n  MinDistanceBetweenWords = 0,\n  MaxDistanceBetweenWords = 15,\n  MinArticlesPerDictionary = 1,\n  MaxArticlesPerDictionary = 10000\n};\n\nvoid Indexing::run()\n{\n  try\n  {\n    // First iteration - dictionaries with no more MaxDictionarySizeForFastSearch articles\n    for( size_t x = 0; x < dictionaries.size(); x++ )\n    {\n      if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n        break;\n\n      if( dictionaries.at( x )->canFTS()\n          &&!dictionaries.at( x )->haveFTSIndex() )\n      {\n        emit sendNowIndexingName( QString::fromUtf8( dictionaries.at( x )->getName().c_str() ) );\n        dictionaries.at( x )->makeFTSIndex( isCancelled, true );\n      }\n    }\n\n    // Second iteration - all remaining dictionaries\n    for( size_t x = 0; x < dictionaries.size(); x++ )\n    {\n      if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n        break;\n\n      if( dictionaries.at( x )->canFTS()\n          &&!dictionaries.at( x )->haveFTSIndex() )\n      {\n        emit sendNowIndexingName( QString::fromUtf8( dictionaries.at( x )->getName().c_str() ) );\n        dictionaries.at( x )->makeFTSIndex( isCancelled, false );\n      }\n    }\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"Exception occured while full-text search: %s\", ex.what() );\n  }\n  emit sendNowIndexingName( QString() );\n}\n\n\nFtsIndexing::FtsIndexing( std::vector< sptr< Dictionary::Class > > const & dicts):\n  dictionaries( dicts ),\n  started( false )\n{\n}\n\nvoid FtsIndexing::doIndexing()\n{\n  if( started )\n    stopIndexing();\n\n  if( !started )\n  {\n    while( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      isCancelled.deref();\n\n    Indexing *idx = new Indexing( isCancelled, dictionaries, indexingExited );\n\n    connect( idx, SIGNAL( sendNowIndexingName( QString ) ), this, SLOT( setNowIndexedName( QString ) ) );\n\n    QThreadPool::globalInstance()->start( idx );\n\n    started = true;\n  }\n}\n\nvoid FtsIndexing::stopIndexing()\n{\n  if( started )\n  {\n    if( !Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      isCancelled.ref();\n\n    indexingExited.acquire();\n    started = false;\n\n    setNowIndexedName( QString() );\n  }\n}\n\nvoid FtsIndexing::setNowIndexedName( QString name )\n{\n  {\n    Mutex::Lock _( nameMutex );\n    nowIndexing = name;\n  }\n  emit newIndexingName( name );\n}\n\nQString FtsIndexing::nowIndexingName()\n{\n  Mutex::Lock _( nameMutex );\n  return nowIndexing;\n}\n\nvoid addSortedHeadwords( QList< FtsHeadword > & base_list, QList< FtsHeadword > const & add_list)\n{\n  QList< FtsHeadword > list;\n\n  if( add_list.isEmpty() )\n    return;\n\n  if( base_list.isEmpty() )\n  {\n    base_list = add_list;\n    return;\n  }\n\n  list.reserve( base_list.size() + add_list.size() );\n\n  QList< FtsHeadword >::iterator base_it = base_list.begin();\n  QList< FtsHeadword >::const_iterator add_it = add_list.constBegin();\n\n  while( base_it != base_list.end() || add_it != add_list.end() )\n  {\n    if( base_it == base_list.end() )\n    {\n      while( add_it != add_list.end() )\n      {\n        list.append( *add_it );\n        ++add_it;\n      }\n      break;\n    }\n\n    if( add_it == add_list.end() )\n    {\n      while( base_it != base_list.end() )\n      {\n        list.append( *base_it );\n        ++base_it;\n      }\n      break;\n    }\n\n    if( *add_it < *base_it )\n    {\n      list.append( *add_it );\n      ++add_it;\n    }\n    else if( *add_it == *base_it )\n    {\n      base_it->dictIDs.append( add_it->dictIDs );\n      for( QStringList::const_iterator itr = add_it->foundHiliteRegExps.constBegin();\n             itr != add_it->foundHiliteRegExps.constEnd(); ++itr )\n      {\n        if( !base_it->foundHiliteRegExps.contains( *itr ) )\n          base_it->foundHiliteRegExps.append( *itr );\n      }\n      ++add_it;\n    }\n    else\n    {\n      list.append( *base_it );\n      ++base_it;\n    }\n  }\n\n  base_list.swap( list );\n}\n\nFullTextSearchDialog::FullTextSearchDialog( QWidget * parent,\n                                            Config::Class & cfg_,\n                                            std::vector< sptr< Dictionary::Class > > const & dictionaries_,\n                                            std::vector< Instances::Group > const & groups_,\n                                            FtsIndexing & ftsidx ) :\n  QDialog( parent ),\n  cfg( cfg_ ),\n  dictionaries( dictionaries_ ),\n  groups( groups_ ),\n  group( 0 ),\n  ignoreWordsOrder( cfg_.preferences.fts.ignoreWordsOrder ),\n  ignoreDiacritics( cfg_.preferences.fts.ignoreDiacritics ),\n  ftsThreadPool( this ),\n  searchInProgress( false ),\n  ftsIdx( ftsidx )\n, helpAction( this )\n{\n  ui.setupUi( this );\n\n  ftsThreadPool.setExpiryTimeout( -1 );\n  int threads = ftsThreadPool.maxThreadCount();\n  if( threads > 1 )\n    ftsThreadPool.setMaxThreadCount( threads - 1 );\n\n  setAttribute( Qt::WA_DeleteOnClose, false );\n  setWindowFlags( windowFlags() & ~Qt::WindowContextHelpButtonHint );\n\n  setWindowTitle( tr( \"Full-text search\" ) );\n\n  if( cfg.preferences.fts.dialogGeometry.size() > 0 )\n    restoreGeometry( cfg.preferences.fts.dialogGeometry );\n\n  setNewIndexingName( ftsIdx.nowIndexingName() );\n\n  connect( &ftsIdx, SIGNAL( newIndexingName( QString ) ),\n           this, SLOT( setNewIndexingName( QString ) ) );\n\n  ui.searchMode->addItem( tr( \"Whole words\" ), WholeWords );\n  ui.searchMode->addItem( tr( \"Plain text\"), PlainText );\n  ui.searchMode->addItem( tr( \"Wildcards\" ), Wildcards );\n  ui.searchMode->addItem( tr( \"RegExp\" ), RegExp );\n  ui.searchMode->setCurrentIndex( cfg.preferences.fts.searchMode );\n\n  ui.searchProgressBar->hide();\n\n  ui.checkBoxDistanceBetweenWords->setText( tr( \"Max distance between words (%1-%2):\" )\n                                            .arg( QString::number( MinDistanceBetweenWords ) )\n                                            .arg( QString::number( MaxDistanceBetweenWords ) ) );\n  ui.checkBoxDistanceBetweenWords->setChecked( cfg.preferences.fts.useMaxDistanceBetweenWords );\n\n  ui.distanceBetweenWords->setMinimum( MinDistanceBetweenWords );\n  ui.distanceBetweenWords->setMaximum( MaxDistanceBetweenWords );\n  ui.distanceBetweenWords->setValue( cfg.preferences.fts.maxDistanceBetweenWords );\n\n  ui.checkBoxArticlesPerDictionary->setText( tr( \"Max articles per dictionary (%1-%2):\" )\n                                             .arg( QString::number( MinArticlesPerDictionary ) )\n                                             .arg( QString::number( MaxArticlesPerDictionary ) ) );\n  ui.checkBoxArticlesPerDictionary->setChecked( cfg.preferences.fts.useMaxArticlesPerDictionary );\n\n  ui.articlesPerDictionary->setMinimum( MinArticlesPerDictionary );\n  ui.articlesPerDictionary->setMaximum( MaxArticlesPerDictionary );\n  ui.articlesPerDictionary->setValue( cfg.preferences.fts.maxArticlesPerDictionary );\n\n  int mode = ui.searchMode->itemData( ui.searchMode->currentIndex() ).toInt();\n  if( mode == WholeWords || mode == PlainText )\n  {\n    ui.checkBoxIgnoreWordOrder->setChecked( ignoreWordsOrder );\n    ui.checkBoxIgnoreWordOrder->setEnabled( true );\n  }\n  else\n  {\n    ui.checkBoxIgnoreWordOrder->setChecked( false );\n    ui.checkBoxIgnoreWordOrder->setEnabled( false );\n  }\n\n  ui.checkBoxIgnoreDiacritics->setChecked( ignoreDiacritics );\n\n  ui.matchCase->setChecked( cfg.preferences.fts.matchCase );\n\n  setLimitsUsing();\n\n  connect( ui.checkBoxDistanceBetweenWords, SIGNAL( stateChanged( int ) ),\n           this, SLOT( setLimitsUsing() ) );\n  connect( ui.checkBoxArticlesPerDictionary, SIGNAL( stateChanged( int ) ),\n           this, SLOT( setLimitsUsing() ) );\n  connect( ui.searchMode, SIGNAL( currentIndexChanged( int ) ),\n           this, SLOT( setLimitsUsing() ) );\n  connect( ui.checkBoxIgnoreWordOrder, SIGNAL( stateChanged( int ) ),\n           this, SLOT( ignoreWordsOrderClicked() ) );\n  connect( ui.checkBoxIgnoreDiacritics, SIGNAL( stateChanged( int ) ),\n           this, SLOT( ignoreDiacriticsClicked() ) );\n\n  model = new HeadwordsListModel( this, results, activeDicts );\n  ui.headwordsView->setModel( model );\n\n  ui.articlesFoundLabel->setText( tr( \"Articles found: \" ) + \"0\" );\n\n  connect( ui.headwordsView, SIGNAL( clicked( QModelIndex ) ),\n           this, SLOT( itemClicked( QModelIndex ) ) );\n\n  connect( this, SIGNAL( finished( int ) ), this, SLOT( saveData() ) );\n\n  connect( ui.OKButton, SIGNAL( clicked() ), this, SLOT( accept() ) );\n  connect( ui.cancelButton, SIGNAL( clicked() ), this, SLOT( reject() ) );\n\n  connect( ui.helpButton, SIGNAL( clicked() ),\n           this, SLOT( helpRequested() ) );\n\n  helpAction.setShortcut( QKeySequence( \"F1\" ) );\n  helpAction.setShortcutContext( Qt::WidgetWithChildrenShortcut );\n\n  connect( &helpAction, SIGNAL( triggered() ),\n           this, SLOT( helpRequested() ) );\n\n  addAction( &helpAction );\n\n  ui.headwordsView->installEventFilter( this );\n\n  delegate = new WordListItemDelegate( ui.headwordsView->itemDelegate() );\n  if( delegate )\n    ui.headwordsView->setItemDelegate( delegate );\n\n#if ( QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 ) ) && defined( Q_OS_WIN32 )\n\n  // Style \"windowsvista\" in Qt5 turn off progress bar animation for classic appearance\n  // We use simply \"windows\" style instead for this case\n\n  oldBarStyle = 0;\n\n  if( QSysInfo::windowsVersion() >= QSysInfo::WV_VISTA\n      && ( QSysInfo::windowsVersion() & QSysInfo::WV_NT_based )\n      && !IsThemeActive() )\n  {\n    QStyle * barStyle = WindowsStyle::instance().getStyle();\n\n    if( barStyle )\n    {\n      oldBarStyle = ui.searchProgressBar->style();\n      ui.searchProgressBar->setStyle( barStyle );\n    }\n  }\n\n#endif\n\n  ui.searchLine->setText( static_cast< MainWindow * >( parent )->getTranslateLineText() );\n  ui.searchLine->selectAll();\n}\n\nFullTextSearchDialog::~FullTextSearchDialog()\n{\n  if( delegate )\n    delegate->deleteLater();\n\n#if ( QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 ) ) && defined( Q_OS_WIN32 )\n\n  if( oldBarStyle )\n    ui.searchProgressBar->setStyle( oldBarStyle );\n\n#endif\n}\n\nvoid FullTextSearchDialog::stopSearch()\n{\n  if( !searchReqs.empty() )\n  {\n    for( std::list< sptr< Dictionary::DataRequest > >::iterator it = searchReqs.begin();\n         it != searchReqs.end(); ++it )\n      if( !(*it)->isFinished() )\n        (*it)->cancel();\n\n    while( searchReqs.size() )\n      QApplication::processEvents();\n  }\n}\n\nvoid FullTextSearchDialog::showDictNumbers()\n{\n  ui.totalDicts->setText( QString::number( activeDicts.size() ) );\n\n  unsigned ready = 0, toIndex = 0;\n  for( unsigned x = 0; x < activeDicts.size(); x++ )\n  {\n    if( activeDicts.at( x )->haveFTSIndex() )\n      ready++;\n    else\n      toIndex++;\n  }\n\n  ui.readyDicts->setText( QString::number( ready ) );\n  ui.toIndexDicts->setText( QString::number( toIndex ) );\n}\n\nvoid FullTextSearchDialog::saveData()\n{\n  cfg.preferences.fts.searchMode = ui.searchMode->currentIndex();\n  cfg.preferences.fts.matchCase = ui.matchCase->isChecked();\n  cfg.preferences.fts.maxArticlesPerDictionary = ui.articlesPerDictionary->text().toInt();\n  cfg.preferences.fts.maxDistanceBetweenWords = ui.distanceBetweenWords->text().toInt();\n  cfg.preferences.fts.useMaxDistanceBetweenWords = ui.checkBoxDistanceBetweenWords->isChecked();\n  cfg.preferences.fts.useMaxArticlesPerDictionary = ui.checkBoxArticlesPerDictionary->isChecked();\n  cfg.preferences.fts.ignoreWordsOrder = ignoreWordsOrder;\n  cfg.preferences.fts.ignoreDiacritics = ignoreDiacritics;\n\n  cfg.preferences.fts.dialogGeometry = saveGeometry();\n}\n\nvoid FullTextSearchDialog::setNewIndexingName( QString name )\n{\n  ui.nowIndexingLabel->setText( tr( \"Now indexing: \" )\n                                + ( name.isEmpty() ? tr( \"None\" ) : name ) );\n  showDictNumbers();\n}\n\nvoid FullTextSearchDialog::setLimitsUsing()\n{\n  int mode = ui.searchMode->itemData( ui.searchMode->currentIndex() ).toInt();\n  if( mode == WholeWords || mode == PlainText )\n  {\n    ui.checkBoxDistanceBetweenWords->setEnabled( true );\n    ui.distanceBetweenWords->setEnabled( ui.checkBoxDistanceBetweenWords->isChecked() );\n    ui.checkBoxIgnoreWordOrder->setChecked( ignoreWordsOrder );\n    ui.checkBoxIgnoreWordOrder->setEnabled( true );\n  }\n  else\n  {\n    ui.checkBoxIgnoreWordOrder->setEnabled( false );\n    ui.checkBoxIgnoreWordOrder->setChecked( false );\n    ui.checkBoxDistanceBetweenWords->setEnabled( false );\n    ui.distanceBetweenWords->setEnabled( false );\n  }\n  ui.articlesPerDictionary->setEnabled( ui.checkBoxArticlesPerDictionary->isChecked() );\n}\n\nvoid FullTextSearchDialog::ignoreWordsOrderClicked()\n{\n  ignoreWordsOrder = ui.checkBoxIgnoreWordOrder->isChecked();\n}\n\nvoid FullTextSearchDialog::ignoreDiacriticsClicked()\n{\n  ignoreDiacritics = ui.checkBoxIgnoreDiacritics->isChecked();\n}\n\nvoid FullTextSearchDialog::accept()\n{\n  QStringList list1, list2;\n  int mode = ui.searchMode->itemData( ui.searchMode->currentIndex() ).toInt();\n\n  int maxResultsPerDict = ui.checkBoxArticlesPerDictionary->isChecked() ?\n                            ui.articlesPerDictionary->value() : -1;\n  int distanceBetweenWords = ui.checkBoxDistanceBetweenWords->isChecked() ?\n                               ui.distanceBetweenWords->value() : -1;\n\n  model->clear();\n  ui.articlesFoundLabel->setText( tr( \"Articles found: \" ) + QString::number( results.size() ) );\n\n  bool hasCJK;\n  if( !FtsHelpers::parseSearchString( ui.searchLine->text(), list1, list2,\n                                      searchRegExp, mode,\n                                      ui.matchCase->isChecked(),\n                                      distanceBetweenWords,\n                                      hasCJK ) )\n  {\n    if( hasCJK && ( mode == WholeWords || mode == PlainText ) )\n    {\n      QMessageBox message( QMessageBox::Warning,\n                           \"GoldenDict\",\n                           tr( \"CJK symbols in search string are not compatible with search modes \\\"Whole words\\\" and \\\"Plain text\\\"\" ),\n                           QMessageBox::Ok,\n                           this );\n      message.exec();\n    }\n    else\n    {\n      QMessageBox message( QMessageBox::Warning,\n                           \"GoldenDict\",\n                           tr( \"The search line must contains at least one word containing \" )\n                           + QString::number( MinimumWordSize ) + tr( \" or more symbols\" ),\n                           QMessageBox::Ok,\n                           this );\n      message.exec();\n    }\n    return;\n  }\n\n  if( activeDicts.empty() )\n  {\n    QMessageBox message( QMessageBox::Warning,\n                         \"GoldenDict\",\n                         tr( \"No dictionaries for full-text search\" ),\n                         QMessageBox::Ok,\n                         this );\n    message.exec();\n    return;\n  }\n\n  ui.OKButton->setEnabled( false );\n  ui.searchProgressBar->show();\n\n  // Make search requests\n\n  for( unsigned x = 0; x < activeDicts.size(); ++x )\n  {\n    sptr< Dictionary::DataRequest > req = activeDicts[ x ]->getSearchResults(\n                                                              ui.searchLine->text(),\n                                                              mode,\n                                                              ui.matchCase->isChecked(),\n                                                              distanceBetweenWords,\n                                                              maxResultsPerDict,\n                                                              ignoreWordsOrder,\n                                                              ignoreDiacritics,\n                                                              &ftsThreadPool\n                                                            );\n    connect( req.get(), SIGNAL( finished() ),\n             this, SLOT( searchReqFinished() ), Qt::QueuedConnection );\n\n    searchInProgress = true;\n    searchReqs.push_back( req );\n  }\n\n  searchReqFinished(); // Handle any ones which have already finished\n}\n\nvoid FullTextSearchDialog::searchReqFinished()\n{\n  QList< FtsHeadword > allHeadwords;\n  while ( searchReqs.size() )\n  {\n    std::list< sptr< Dictionary::DataRequest > >::iterator it;\n    for( it = searchReqs.begin(); it != searchReqs.end(); ++it )\n    {\n      if ( (*it)->isFinished() )\n      {\n        GD_DPRINTF( \"one finished.\\n\" );\n\n        QString errorString = (*it)->getErrorString();\n\n        if ( (*it)->dataSize() >= 0 || errorString.size() )\n        {\n          QList< FtsHeadword > * headwords;\n          if( (unsigned)(*it)->dataSize() >= sizeof( headwords ) )\n          {\n            QList< FtsHeadword > hws;\n            try\n            {\n              (*it)->getDataSlice( 0, sizeof( headwords ), &headwords );\n              hws.swap( *headwords );\n              std::sort( hws.begin(),  hws.end() );\n              delete headwords;\n              addSortedHeadwords( allHeadwords, hws );\n            }\n            catch( std::exception & e )\n            {\n              gdWarning( \"getDataSlice error: %s\\n\", e.what() );\n            }\n          }\n\n        }\n        break;\n      }\n    }\n    if( it != searchReqs.end() )\n    {\n      GD_DPRINTF( \"erasing..\\n\" );\n      searchReqs.erase( it );\n      GD_DPRINTF( \"erase done..\\n\" );\n      continue;\n    }\n    else\n      break;\n  }\n\n  if( !allHeadwords.isEmpty() )\n  {\n     model->addResults( QModelIndex(), allHeadwords );\n     ui.articlesFoundLabel->setText( tr( \"Articles found: \" )\n                                     + QString::number( results.size() ) );\n  }\n\n  if ( searchReqs.empty() && searchInProgress )\n  {\n    searchInProgress = false;\n    ui.searchProgressBar->hide();\n    ui.OKButton->setEnabled( true );\n    QApplication::beep();\n  }\n}\n\nvoid FullTextSearchDialog::reject()\n{\n  if( !searchReqs.empty() )\n    stopSearch();\n  else\n  {\n    saveData();\n    emit closeDialog();\n  }\n}\n\nvoid FullTextSearchDialog::itemClicked( const QModelIndex & idx )\n{\n  if( idx.isValid() && idx.row() < results.size() )\n  {\n    QString headword = results[ idx.row() ].headword;\n    QRegExp reg;\n    if( !results[ idx.row() ].foundHiliteRegExps.isEmpty() )\n    {\n      reg = QRegExp( results[ idx.row() ].foundHiliteRegExps.join( \"|\"),\n                     results[ idx.row() ].matchCase ? Qt::CaseSensitive : Qt::CaseInsensitive,\n                     QRegExp::RegExp2 );\n      reg.setMinimal( true );\n    }\n    else\n      reg = searchRegExp;\n    emit showTranslationFor( headword, results[ idx.row() ].dictIDs, reg, ignoreDiacritics );\n  }\n}\n\nvoid FullTextSearchDialog::updateDictionaries()\n{\n  activeDicts.clear();\n\n  // Find the given group\n\n  Instances::Group const * activeGroup = 0;\n\n  for( unsigned x = 0; x < groups.size(); ++x )\n    if ( groups[ x ].id == group )\n    {\n      activeGroup = &groups[ x ];\n      break;\n    }\n\n  // If we've found a group, use its dictionaries; otherwise, use the global\n  // heap.\n  std::vector< sptr< Dictionary::Class > > const & groupDicts =\n    activeGroup ? activeGroup->dictionaries : dictionaries;\n\n  // Exclude muted dictionaries\n\n  Config::Group const * grp = cfg.getGroup( group );\n  Config::MutedDictionaries const * mutedDicts;\n\n  if( group == Instances::Group::AllGroupId )\n    mutedDicts = &cfg.mutedDictionaries;\n  else\n    mutedDicts = grp ? &grp->mutedDictionaries : 0;\n\n  if( mutedDicts && !mutedDicts->isEmpty() )\n  {\n    activeDicts.reserve( groupDicts.size() );\n    for( unsigned x = 0; x < groupDicts.size(); ++x )\n      if ( groupDicts[ x ]->canFTS()\n           && !mutedDicts->contains( QString::fromStdString( groupDicts[ x ]->getId() ) )\n         )\n        activeDicts.push_back( groupDicts[ x ] );\n  }\n  else\n  {\n    for( unsigned x = 0; x < groupDicts.size(); ++x )\n      if ( groupDicts[ x ]->canFTS() )\n        activeDicts.push_back( groupDicts[ x ] );\n  }\n\n  showDictNumbers();\n}\n\nbool FullTextSearchDialog::eventFilter( QObject * obj, QEvent * ev )\n{\n  if( obj == ui.headwordsView && ev->type() == QEvent::KeyPress )\n  {\n    QKeyEvent * kev = static_cast< QKeyEvent * >( ev );\n    if( kev->key() == Qt::Key_Return || kev->key() == Qt::Key_Enter )\n    {\n      itemClicked( ui.headwordsView->currentIndex() );\n      return true;\n    }\n  }\n  return QDialog::eventFilter( obj, ev );\n}\n\nvoid FullTextSearchDialog::helpRequested()\n{\n  MainWindow * mainWindow = qobject_cast< MainWindow * >( parentWidget() );\n  if( mainWindow )\n    mainWindow->showGDHelpForID( \"Full-text search\" );\n}\n\n/// HeadwordsListModel\n\nint HeadwordsListModel::rowCount( QModelIndex const & ) const\n{\n  return headwords.size();\n}\n\nQVariant HeadwordsListModel::data( QModelIndex const & index, int role ) const\n{\n  if( index.row() < 0 )\n    return QVariant();\n\n  FtsHeadword const & head = headwords[ index.row() ];\n\n  if ( head.headword.isEmpty() )\n    return QVariant();\n\n  switch ( role )\n  {\n    case Qt::ToolTipRole:\n    {\n      QString tt;\n      for( int x = 0; x < head.dictIDs.size(); x++ )\n      {\n        if( x != 0 )\n          tt += \"<br>\";\n\n        int n = getDictIndex( head.dictIDs[ x ] );\n        if( n != -1 )\n          tt += QString::fromUtf8( dictionaries[ n ]->getName().c_str() ) ;\n      }\n      return tt;\n    }\n\n    case Qt::DisplayRole :\n      return head.headword;\n\n    case Qt::EditRole :\n      return head.headword;\n\n    default:;\n  }\n\n  return QVariant();\n}\n\nvoid HeadwordsListModel::addResults(const QModelIndex & parent, QList< FtsHeadword > const & hws )\n{\nQ_UNUSED( parent );\n  beginResetModel();\n\n  addSortedHeadwords( headwords, hws );\n\n  endResetModel();\n  emit contentChanged();\n}\n\nbool HeadwordsListModel::clear()\n{\n  beginResetModel();\n\n  headwords.clear();\n\n  endResetModel();\n\n  emit contentChanged();\n\n  return true;\n}\n\nint HeadwordsListModel::getDictIndex( QString const & id ) const\n{\n  std::string dictID( id.toUtf8().data() );\n  for( unsigned x = 0; x < dictionaries.size(); x++ )\n  {\n    if( dictionaries[ x ]->getId().compare( dictID ) == 0 )\n      return x;\n  }\n  return -1;\n}\n\nQString FtsHeadword::trimQuotes( QString const & str ) const\n{\n  QString trimmed( str );\n\n  int n = 0;\n  while( str[ n ] == '\\\"' || str[ n ] == '\\'' )\n    n++;\n  if( n )\n    trimmed = trimmed.mid( n );\n\n  while( trimmed.endsWith( '\\\"' ) || trimmed.endsWith( '\\'' ) )\n    trimmed.chop( 1 );\n\n  return trimmed;\n}\n\nbool FtsHeadword::operator <( FtsHeadword const & other ) const\n{\n  QString first = trimQuotes( headword );\n  QString second = trimQuotes( other.headword );\n\n  int result = first.localeAwareCompare( second );\n  if( result )\n    return result < 0;\n\n  // Headwords without quotes are equal\n\n  if( first.size() != headword.size() || second.size() != other.headword.size() )\n    return headword.localeAwareCompare( other.headword ) < 0;\n\n  return false;\n}\n\n} // namespace FTS\n"
        },
        {
          "name": "fulltextsearch.hh",
          "type": "blob",
          "size": 5.646484375,
          "content": "#ifndef __FULLTEXTSEARCH_HH_INCLUDED__\n#define __FULLTEXTSEARCH_HH_INCLUDED__\n\n#include <QSemaphore>\n#include <QStringList>\n#include <QRegExp>\n#include <QAbstractListModel>\n#include <QList>\n#include <QAction>\n\n#include \"dictionary.hh\"\n#include \"ui_fulltextsearch.h\"\n#include \"mutex.hh\"\n#include \"config.hh\"\n#include \"instances.hh\"\n#include \"delegate.hh\"\n\nnamespace FTS\n{\n\nenum {\n  // Minimum word length for indexing\n  MinimumWordSize = 4,\n\n  // Maximum dictionary size for first iteration of FTS indexing\n  MaxDictionarySizeForFastSearch = 150000,\n\n  // Maxumum match length for highlight search results\n  // (QWebPage::findText() crashes on too long strings)\n  MaxMatchLengthForHighlightResults = 500\n};\n\nenum SearchMode\n{\n  WholeWords = 0,\n  PlainText,\n  Wildcards,\n  RegExp\n};\n\nstruct FtsHeadword\n{\n  QString headword;\n  QStringList dictIDs;\n  QStringList foundHiliteRegExps;\n  bool matchCase;\n\n  FtsHeadword( QString const & headword_, QString const & dictid_,\n               QStringList hilites, bool match_case ) :\n    headword( headword_ ),\n    foundHiliteRegExps( hilites ),\n    matchCase( match_case )\n  {\n    dictIDs.append( dictid_ );\n  }\n\n  QString trimQuotes( QString const & ) const;\n\n  bool operator <( FtsHeadword const & other ) const;\n\n  bool operator ==( FtsHeadword const & other ) const\n  { return headword.compare( other.headword, Qt::CaseInsensitive ) == 0; }\n\n  bool operator !=( FtsHeadword const & other ) const\n  { return headword.compare( other.headword, Qt::CaseInsensitive ) != 0; }\n};\n\nclass Indexing : public QObject, public QRunnable\n{\nQ_OBJECT\n\n  QAtomicInt & isCancelled;\n  std::vector< sptr< Dictionary::Class > > const & dictionaries;\n  QSemaphore & hasExited;\n\npublic:\n  Indexing( QAtomicInt & cancelled, std::vector< sptr< Dictionary::Class > > const & dicts,\n            QSemaphore & hasExited_):\n    isCancelled( cancelled ),\n    dictionaries( dicts ),\n    hasExited( hasExited_ )\n  {}\n\n  ~Indexing()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n\nsignals:\n  void sendNowIndexingName( QString );\n};\n\nclass FtsIndexing : public QObject\n{\nQ_OBJECT\npublic:\n  FtsIndexing( std::vector< sptr< Dictionary::Class > > const & dicts );\n  virtual ~FtsIndexing()\n  { stopIndexing(); }\n\n  void setDictionaries( std::vector< sptr< Dictionary::Class > > const & dicts )\n  {\n    clearDictionaries();\n    dictionaries = dicts;\n  }\n\n  void clearDictionaries()\n  { dictionaries.clear(); }\n\n  /// Start dictionaries indexing for full-text search\n  void doIndexing();\n\n  /// Break indexing thread\n  void stopIndexing();\n\n  QString nowIndexingName();\n\nprotected:\n  QAtomicInt isCancelled;\n  QSemaphore indexingExited;\n  std::vector< sptr< Dictionary::Class > > dictionaries;\n  bool started;\n  QString nowIndexing;\n  Mutex nameMutex;\n\nprivate slots:\n  void setNowIndexedName( QString name );\n\nsignals:\n  void newIndexingName( QString name );\n};\n\n/// A model to be projected into the view, according to Qt's MVC model\nclass HeadwordsListModel: public QAbstractListModel\n{\n  Q_OBJECT\n\npublic:\n\n  HeadwordsListModel( QWidget * parent, QList< FtsHeadword > & headwords_,\n                      std::vector< sptr< Dictionary::Class > > const & dicts ):\n    QAbstractListModel( parent ), headwords( headwords_ ),\n    dictionaries( dicts )\n  {}\n\n  int rowCount( QModelIndex const & parent ) const;\n  QVariant data( QModelIndex const & index, int role ) const;\n\n//  bool insertRows( int row, int count, const QModelIndex & parent );\n//  bool removeRows( int row, int count, const QModelIndex & parent );\n//  bool setData( QModelIndex const & index, const QVariant & value, int role );\n\n  void addResults(const QModelIndex & parent, QList< FtsHeadword > const & headwords );\n  bool clear();\n\nprivate:\n\n  QList< FtsHeadword > & headwords;\n  std::vector< sptr< Dictionary::Class > > const & dictionaries;\n\n  int getDictIndex( QString const & id ) const;\n\nsignals:\n  void contentChanged();\n};\n\nclass FullTextSearchDialog : public QDialog\n{\n  Q_OBJECT\n\n  Config::Class & cfg;\n  std::vector< sptr< Dictionary::Class > > const & dictionaries;\n  std::vector< Instances::Group > const & groups;\n  unsigned group;\n  std::vector< sptr< Dictionary::Class > > activeDicts;\n  bool ignoreWordsOrder;\n  bool ignoreDiacritics;\n  QThreadPool ftsThreadPool;\n  bool searchInProgress;\n\n  std::list< sptr< Dictionary::DataRequest > > searchReqs;\n\n  FtsIndexing & ftsIdx;\n\n  QRegExp searchRegExp;\n\n#if ( QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 ) ) && defined( Q_OS_WIN32 )\n  QStyle * oldBarStyle;\n#endif\n\npublic:\n  FullTextSearchDialog( QWidget * parent,\n                        Config::Class & cfg_,\n                        std::vector< sptr< Dictionary::Class > > const & dictionaries_,\n                        std::vector< Instances::Group > const & groups_,\n                        FtsIndexing & ftsidx );\n  virtual ~FullTextSearchDialog();\n\n  void setCurrentGroup( unsigned group_ )\n  { group = group_; updateDictionaries(); }\n\n  void stopSearch();\n\nprotected:\n  bool eventFilter( QObject * obj, QEvent * ev );\n\nprivate:\n  Ui::FullTextSearchDialog ui;\n  QList< FtsHeadword > results;\n  HeadwordsListModel * model;\n  WordListItemDelegate * delegate;\n  QAction helpAction;\n\n  void showDictNumbers();\n\nprivate slots:\n  void setNewIndexingName( QString );\n  void saveData();\n  void accept();\n  void setLimitsUsing();\n  void ignoreWordsOrderClicked();\n  void ignoreDiacriticsClicked();\n  void searchReqFinished();\n  void reject();\n  void itemClicked( QModelIndex const & idx );\n  void updateDictionaries();\n  void helpRequested();\n\nsignals:\n  void showTranslationFor( QString const &, QStringList const & dictIDs,\n                           QRegExp const & searchRegExp, bool ignoreDiacritics );\n  void closeDialog();\n};\n\n\n} // namespace FTS\n\n#endif // __FULLTEXTSEARCH_HH_INCLUDED__\n"
        },
        {
          "name": "fulltextsearch.ui",
          "type": "blob",
          "size": 7.5546875,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ui version=\"4.0\">\n <class>FullTextSearchDialog</class>\n <widget class=\"QDialog\" name=\"FullTextSearchDialog\">\n  <property name=\"geometry\">\n   <rect>\n    <x>0</x>\n    <y>0</y>\n    <width>492</width>\n    <height>593</height>\n   </rect>\n  </property>\n  <property name=\"minimumSize\">\n   <size>\n    <width>430</width>\n    <height>450</height>\n   </size>\n  </property>\n  <property name=\"windowTitle\">\n   <string/>\n  </property>\n  <layout class=\"QVBoxLayout\" name=\"verticalLayout_2\">\n   <item>\n    <widget class=\"QGroupBox\" name=\"groupBox\">\n     <property name=\"title\">\n      <string>Search</string>\n     </property>\n     <layout class=\"QVBoxLayout\" name=\"verticalLayout\">\n      <item>\n       <widget class=\"QLineEdit\" name=\"searchLine\"/>\n      </item>\n      <item>\n       <layout class=\"QGridLayout\" name=\"gridLayout_2\">\n        <item row=\"1\" column=\"2\">\n         <widget class=\"QCheckBox\" name=\"matchCase\">\n          <property name=\"text\">\n           <string>Match case</string>\n          </property>\n         </widget>\n        </item>\n        <item row=\"0\" column=\"2\">\n         <layout class=\"QHBoxLayout\" name=\"horizontalLayout_2\">\n          <item>\n           <widget class=\"QLabel\" name=\"label_8\">\n            <property name=\"text\">\n             <string>Mode:</string>\n            </property>\n           </widget>\n          </item>\n          <item>\n           <widget class=\"QComboBox\" name=\"searchMode\"/>\n          </item>\n         </layout>\n        </item>\n        <item row=\"1\" column=\"1\">\n         <widget class=\"QSpinBox\" name=\"articlesPerDictionary\"/>\n        </item>\n        <item row=\"0\" column=\"1\">\n         <widget class=\"QSpinBox\" name=\"distanceBetweenWords\"/>\n        </item>\n        <item row=\"0\" column=\"0\">\n         <widget class=\"QCheckBox\" name=\"checkBoxDistanceBetweenWords\">\n          <property name=\"text\">\n           <string/>\n          </property>\n         </widget>\n        </item>\n        <item row=\"1\" column=\"0\">\n         <widget class=\"QCheckBox\" name=\"checkBoxArticlesPerDictionary\">\n          <property name=\"text\">\n           <string/>\n          </property>\n         </widget>\n        </item>\n       </layout>\n      </item>\n      <item>\n       <layout class=\"QHBoxLayout\" name=\"horizontalLayout_4\">\n        <item>\n         <widget class=\"QCheckBox\" name=\"checkBoxIgnoreWordOrder\">\n          <property name=\"text\">\n           <string>Ignore words order</string>\n          </property>\n         </widget>\n        </item>\n        <item>\n         <widget class=\"QCheckBox\" name=\"checkBoxIgnoreDiacritics\">\n          <property name=\"text\">\n           <string>Ignore diacritics</string>\n          </property>\n         </widget>\n        </item>\n       </layout>\n      </item>\n     </layout>\n    </widget>\n   </item>\n   <item>\n    <widget class=\"QListView\" name=\"headwordsView\"/>\n   </item>\n   <item>\n    <layout class=\"QHBoxLayout\" name=\"horizontalLayout\">\n     <item>\n      <widget class=\"QLabel\" name=\"articlesFoundLabel\">\n       <property name=\"minimumSize\">\n        <size>\n         <width>0</width>\n         <height>21</height>\n        </size>\n       </property>\n       <property name=\"text\">\n        <string>Articles found:</string>\n       </property>\n      </widget>\n     </item>\n     <item>\n      <widget class=\"QProgressBar\" name=\"searchProgressBar\">\n       <property name=\"maximum\">\n        <number>0</number>\n       </property>\n       <property name=\"value\">\n        <number>-1</number>\n       </property>\n       <property name=\"alignment\">\n        <set>Qt::AlignCenter</set>\n       </property>\n      </widget>\n     </item>\n    </layout>\n   </item>\n   <item>\n    <widget class=\"QGroupBox\" name=\"groupBox_2\">\n     <property name=\"title\">\n      <string>Available dictionaries in group:</string>\n     </property>\n     <layout class=\"QGridLayout\" name=\"gridLayout\">\n      <item row=\"1\" column=\"0\" colspan=\"2\">\n       <widget class=\"QLabel\" name=\"label_3\">\n        <property name=\"text\">\n         <string>Wait for indexing:</string>\n        </property>\n       </widget>\n      </item>\n      <item row=\"0\" column=\"2\">\n       <widget class=\"QLabel\" name=\"totalDicts\">\n        <property name=\"text\">\n         <string/>\n        </property>\n       </widget>\n      </item>\n      <item row=\"0\" column=\"4\">\n       <widget class=\"QLabel\" name=\"readyDicts\">\n        <property name=\"text\">\n         <string/>\n        </property>\n       </widget>\n      </item>\n      <item row=\"0\" column=\"0\">\n       <widget class=\"QLabel\" name=\"label\">\n        <property name=\"text\">\n         <string>Total:</string>\n        </property>\n       </widget>\n      </item>\n      <item row=\"0\" column=\"3\">\n       <widget class=\"QLabel\" name=\"label_2\">\n        <property name=\"text\">\n         <string>Indexed:</string>\n        </property>\n       </widget>\n      </item>\n      <item row=\"1\" column=\"2\">\n       <widget class=\"QLabel\" name=\"toIndexDicts\">\n        <property name=\"text\">\n         <string/>\n        </property>\n       </widget>\n      </item>\n     </layout>\n    </widget>\n   </item>\n   <item>\n    <widget class=\"QLabel\" name=\"nowIndexingLabel\">\n     <property name=\"text\">\n      <string>Now indexing: None</string>\n     </property>\n    </widget>\n   </item>\n   <item>\n    <layout class=\"QHBoxLayout\" name=\"horizontalLayout_3\">\n     <item>\n      <spacer name=\"horizontalSpacer_2\">\n       <property name=\"orientation\">\n        <enum>Qt::Horizontal</enum>\n       </property>\n       <property name=\"sizeHint\" stdset=\"0\">\n        <size>\n         <width>40</width>\n         <height>20</height>\n        </size>\n       </property>\n      </spacer>\n     </item>\n     <item>\n      <widget class=\"QPushButton\" name=\"OKButton\">\n       <property name=\"text\">\n        <string>Search</string>\n       </property>\n       <property name=\"autoDefault\">\n        <bool>false</bool>\n       </property>\n       <property name=\"default\">\n        <bool>true</bool>\n       </property>\n      </widget>\n     </item>\n     <item>\n      <spacer name=\"horizontalSpacer_4\">\n       <property name=\"orientation\">\n        <enum>Qt::Horizontal</enum>\n       </property>\n       <property name=\"sizeHint\" stdset=\"0\">\n        <size>\n         <width>40</width>\n         <height>20</height>\n        </size>\n       </property>\n      </spacer>\n     </item>\n     <item>\n      <widget class=\"QPushButton\" name=\"cancelButton\">\n       <property name=\"text\">\n        <string>Cancel</string>\n       </property>\n      </widget>\n     </item>\n     <item>\n      <spacer name=\"horizontalSpacer\">\n       <property name=\"orientation\">\n        <enum>Qt::Horizontal</enum>\n       </property>\n       <property name=\"sizeHint\" stdset=\"0\">\n        <size>\n         <width>40</width>\n         <height>20</height>\n        </size>\n       </property>\n      </spacer>\n     </item>\n     <item>\n      <widget class=\"QPushButton\" name=\"helpButton\">\n       <property name=\"text\">\n        <string>Help</string>\n       </property>\n      </widget>\n     </item>\n     <item>\n      <spacer name=\"horizontalSpacer_3\">\n       <property name=\"orientation\">\n        <enum>Qt::Horizontal</enum>\n       </property>\n       <property name=\"sizeHint\" stdset=\"0\">\n        <size>\n         <width>40</width>\n         <height>20</height>\n        </size>\n       </property>\n      </spacer>\n     </item>\n    </layout>\n   </item>\n  </layout>\n </widget>\n <tabstops>\n  <tabstop>searchLine</tabstop>\n  <tabstop>headwordsView</tabstop>\n  <tabstop>checkBoxDistanceBetweenWords</tabstop>\n  <tabstop>distanceBetweenWords</tabstop>\n  <tabstop>searchMode</tabstop>\n  <tabstop>checkBoxArticlesPerDictionary</tabstop>\n  <tabstop>articlesPerDictionary</tabstop>\n  <tabstop>matchCase</tabstop>\n  <tabstop>OKButton</tabstop>\n  <tabstop>cancelButton</tabstop>\n </tabstops>\n <resources/>\n <connections/>\n</ui>\n"
        },
        {
          "name": "gdappstyle.cc",
          "type": "blob",
          "size": 1.5537109375,
          "content": "/* This file is (c) 2012 Tvangeste <i.4m.l33t@yandex.ru>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"gdappstyle.hh\"\n\n#if QT_VERSION >= 0x040600\n\n#include \"dictionarybar.hh\"\n\n#include <QWidget>\n#include <QToolButton>\n#include <QDebug>\n\nGdAppStyle::GdAppStyle(QProxyStyle * parent) : QProxyStyle(parent) {}\n\nint GdAppStyle::pixelMetric ( PixelMetric metric, const QStyleOption * option, const QWidget * widget) const\n{\n  int defaultVal = QProxyStyle::pixelMetric(metric, option, widget);\n\n  if ( dictionaryBarButton( widget ) )\n  {\n    if ( metric == QStyle::PM_ButtonShiftVertical || metric == QStyle::PM_ButtonShiftHorizontal )\n    {\n      if (option ->state & State_Sunken ) {\n        return defaultVal;\n      }\n\n      if ( option ->state & State_On ) {\n        // No shift for for the checked tool buttons on the dictionary bar,\n        // that's why the whole thing with QProxyStyle is neded, to achieve this.\n        return 0;\n      }\n    }\n  }\n\n  // Qt don't upscale icons for high dpi scales\n  // We limit maximum small icon size to 21 pixel\n  // (standard icon size for Lingvo dictionaries)\n  if( metric == QStyle::PM_SmallIconSize )\n    return defaultVal < 21 ? defaultVal : 21;\n\n  return defaultVal;\n}\n\nbool GdAppStyle::dictionaryBarButton(const QWidget * widget) const {\n  if (widget) {\n    const QWidget * parent = widget->parentWidget();\n    if ( parent &&\n         qobject_cast<const DictionaryBar *>( parent ) &&\n         qobject_cast<const QToolButton *>( widget ) )\n      return true;\n  }\n\n  return false;\n}\n\n#endif // QT_VERSION\n"
        },
        {
          "name": "gdappstyle.hh",
          "type": "blob",
          "size": 0.70703125,
          "content": "/* This file is (c) 2012 Tvangeste <i.4m.l33t@yandex.ru>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef GDAPPSTYLE_HH\n#define GDAPPSTYLE_HH\n\n#include <QtGlobal>\n\n#if QT_VERSION >= 0x040600\n\n#include <QStyle>\n#include <QProxyStyle>\n#include <QStyleOption>\n\nclass GdAppStyle : public QProxyStyle\n{\n    Q_OBJECT\n\npublic:\n  explicit GdAppStyle(QProxyStyle *style = 0);\n  virtual int pixelMetric ( PixelMetric metric, const QStyleOption * option = 0, const QWidget * widget = 0 ) const;\n\nsignals:\n\npublic slots:\n\nprivate:\n  /// is this widget a tool button on the dictionary bar?\n  bool dictionaryBarButton(const QWidget * widget) const;\n\n};\n\n#endif // QT_VERSION\n\n#endif // GDAPPSTYLE_HH\n"
        },
        {
          "name": "gddebug.cc",
          "type": "blob",
          "size": 3.55078125,
          "content": "/* This file is (c) 2013 Abs62\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include <QMutex>\n#include <QMutexLocker>\n#include <QTextCodec>\n#include <QString>\n#include \"categorized_logging.hh\"\n#include \"gddebug.hh\"\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 5, 0 )\n#define TO_LOG_MESSAGE( msg, ap ) QString::vasprintf( msg, ap ).toUtf8().constData()\n#else\n#define TO_LOG_MESSAGE( msg, ap ) QString().vsprintf( msg, ap ).toUtf8().constData()\n#endif\n\nQFile * logFilePtr;\n\nnamespace {\n\nclass Utf8CodecForLocaleReplacer\n{\npublic:\n  static QTextCodec * originalCodecForLocale()\n  {\n    if( !shouldReplaceCodecForLocale() )\n      return QTextCodec::codecForLocale();\n    // codecForLocaleMutex is locked while the UTF8 codec replaces the original codec.\n    // Thus calling QTextCodec::codecForLocale() while holding a lock is guaranteed to\n    // return the original codec, not its temporary UTF8 replacement.\n    QMutexLocker _( &codecForLocaleMutex );\n    return QTextCodec::codecForLocale();\n  }\n\n  Utf8CodecForLocaleReplacer():\n    replaceCodecForLocale( shouldReplaceCodecForLocale() ), localeCodec( 0 )\n  {\n    if( !replaceCodecForLocale )\n      return;\n    codecForLocaleMutex.lock();\n    localeCodec = QTextCodec::codecForLocale();\n    // This static local variable caches the result of a possibly slow call to codecForName().\n    static QTextCodec * const utf8Codec = QTextCodec::codecForName( \"UTF8\" );\n    QTextCodec::setCodecForLocale( utf8Codec );\n  }\n\n  ~Utf8CodecForLocaleReplacer()\n  {\n    if( !replaceCodecForLocale )\n      return;\n    QTextCodec::setCodecForLocale( localeCodec );\n    codecForLocaleMutex.unlock();\n  }\n\nprivate:\n  static bool shouldReplaceCodecForLocale()\n  { return logFilePtr && logFilePtr->isOpen(); }\n\n  static QMutex codecForLocaleMutex;\n\n  bool const replaceCodecForLocale;\n  QTextCodec * localeCodec;\n};\n\nQMutex Utf8CodecForLocaleReplacer::codecForLocaleMutex;\n\n} // unnamed namespace\n\nvoid gdWarning(const char *msg, ...)\n{\n  va_list ap;\n  va_start(ap, msg);\n  {\n    Utf8CodecForLocaleReplacer codecReplacer;\n    qWarning( \"%s\", TO_LOG_MESSAGE( msg, ap ) );\n  }\n  va_end(ap);\n}\n\nvoid gdDebug(const char *msg, ...)\n{\n  va_list ap;\n  va_start(ap, msg);\n  {\n    Utf8CodecForLocaleReplacer codecReplacer;\n    qDebug( \"%s\", TO_LOG_MESSAGE( msg, ap ) );\n  }\n  va_end(ap);\n}\n\n#ifdef GD_CATEGORIZED_LOGGING\nQ_LOGGING_CATEGORY( dictionaryResourceLc, \"goldendict.dictionary.resource\" )\n#endif\n\n#ifdef GD_CATEGORIZED_LOGGING\nvoid gdCWarningImpl( QLoggingCategory const & category, char const * msg, ... )\n#else\nvoid gdCWarning( GdLoggingCategory, char const * msg, ... )\n#endif\n{\n  va_list ap;\n  va_start( ap, msg );\n  {\n    Utf8CodecForLocaleReplacer codecReplacer;\n#ifdef GD_CATEGORIZED_LOGGING\n    QMessageLogger( QT_MESSAGELOG_FILE, QT_MESSAGELOG_LINE, QT_MESSAGELOG_FUNC, category.categoryName() )\n        .warning( \"%s\", TO_LOG_MESSAGE( msg, ap ) );\n#else\n    qWarning( \"%s\", TO_LOG_MESSAGE( msg, ap ) );\n#endif\n  }\n  va_end( ap );\n}\n\n#ifdef GD_CATEGORIZED_LOGGING\nvoid gdCDebugImpl( QLoggingCategory const & category, char const * msg, ... )\n#else\nvoid gdCDebug( GdLoggingCategory, char const * msg, ... )\n#endif\n{\n  va_list ap;\n  va_start( ap, msg );\n  {\n    Utf8CodecForLocaleReplacer codecReplacer;\n#ifdef GD_CATEGORIZED_LOGGING\n    QMessageLogger( QT_MESSAGELOG_FILE, QT_MESSAGELOG_LINE, QT_MESSAGELOG_FUNC, category.categoryName() )\n        .debug( \"%s\", TO_LOG_MESSAGE( msg, ap ) );\n#else\n    qDebug( \"%s\", TO_LOG_MESSAGE( msg, ap ) );\n#endif\n  }\n  va_end( ap );\n}\n\nQTextCodec * gdCodecForLocale()\n{\n  return Utf8CodecForLocaleReplacer::originalCodecForLocale();\n}\n"
        },
        {
          "name": "gddebug.hh",
          "type": "blob",
          "size": 0.7734375,
          "content": "#ifndef __GDDEBUG_HH_INCLUDED__\n#define __GDDEBUG_HH_INCLUDED__\n\n#include <QFile>\n\nclass QTextCodec;\n\n#ifdef NO_CONSOLE\n  #define GD_DPRINTF(...) do {} while( 0 )\n  #define GD_FDPRINTF(...) do {} while( 0 )\n#else\n  #ifdef NO_GD_DPRINTF\n    #define GD_DPRINTF(...) do {} while( 0 )\n  #else\n    #define GD_DPRINTF(...) printf(__VA_ARGS__)\n  #endif\n  #define GD_FDPRINTF(...) fprintf(__VA_ARGS__)\n#endif\n\nvoid gdWarning(const char *, ...) /* print warning message */\n#if defined(Q_CC_GNU) && !defined(__INSURE__)\n    __attribute__ ((format (printf, 1, 2)))\n#endif\n;\n\nvoid gdDebug(const char *, ...)\n#if defined(Q_CC_GNU) && !defined(__INSURE__)\n    __attribute__ ((format (printf, 1, 2)))\n#endif\n;\n\nQTextCodec * gdCodecForLocale();\n\nextern QFile * logFilePtr;\n\n#endif // __GDDEBUG_HH_INCLUDED__\n"
        },
        {
          "name": "generators",
          "type": "tree",
          "content": null
        },
        {
          "name": "german.cc",
          "type": "blob",
          "size": 1.068359375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"german.hh\"\n#include \"transliteration.hh\"\n#include <QCoreApplication>\n\nnamespace GermanTranslit {\n\nclass GermanTable: public Transliteration::Table\n{\npublic:\n\n  GermanTable();\n};\n\nGermanTable::GermanTable()\n{\n  // Utf8\n\n  ins( \"ue\", \"ü\" );\n  ins( \"ae\", \"ä\" );\n  ins( \"oe\", \"ö\" );\n  ins( \"ss\", \"ß\" );\n\n  ins( \"UE\", \"Ü\" );\n  ins( \"AE\", \"Ä\" );\n  ins( \"OE\", \"Ö\" );\n  ins( \"SS\", \"ß\" );\n\n  ins( \"Ue\", \"Ü\" );\n  ins( \"Ae\", \"Ä\" );\n  ins( \"Oe\", \"Ö\" );\n  ins( \"Ss\", \"ß\" );\n\n//  ins( \"ü\", \"ue\" );\n//  ins( \"ä\", \"ae\" );\n//  ins( \"ö\", \"oe\" );\n//  ins( \"ß\", \"ss\" );\n\n}\n\nsptr< Dictionary::Class > makeDictionary() THROW_SPEC( std::exception )\n{\n  static GermanTable t;\n\n  return new Transliteration::TransliterationDictionary( \"cf1b74acd98adea9b2bba16af38f1081\",\n                      QCoreApplication::translate( \"GermanTranslit\", \"German Transliteration\" ).toUtf8().data(),\n                      QIcon( \":/flags/de.png\" ), t );\n}\n\n\n}\n\n"
        },
        {
          "name": "german.hh",
          "type": "blob",
          "size": 0.365234375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef GERMAN_HH\n#define GERMAN_HH\n\n#include \"dictionary.hh\"\n\n// Support for German transliteration\nnamespace GermanTranslit {\n\nsptr< Dictionary::Class > makeDictionary() THROW_SPEC( std::exception );\n\n}\n\n#endif // GERMAN_HH\n"
        },
        {
          "name": "gestures.cc",
          "type": "blob",
          "size": 11.703125,
          "content": "/* This file is (c) 2014 Abs62\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include <QTouchEvent>\n#include <QSwipeGesture>\n#include <QVariant>\n#include <math.h>\n#include \"articleview.hh\"\n#include \"gestures.hh\"\n\n#if QT_VERSION >= QT_VERSION_CHECK(4, 6, 0)\n\nnamespace Gestures\n{\n\nQt::GestureType GDPinchGestureType;\nQt::GestureType GDSwipeGestureType;\nstatic bool fewTouchPointsPresented;\n\nbool isFewTouchPointsPresented()\n{\n  return fewTouchPointsPresented;\n}\n\nQSwipeGesture::SwipeDirection getHorizontalDirection( qreal angle )\n{\n  if ( ( 0 <= angle && angle <= 45 )\n       || ( 315 <= angle && angle <= 360 ) )\n    return QSwipeGesture::Right;\n\n  if ( 135 <= angle && angle <= 225 )\n    return QSwipeGesture::Left;\n\n  return QSwipeGesture::NoDirection;\n}\n\nQSwipeGesture::SwipeDirection getVerticalDirection( qreal angle )\n{\n  if ( 45 < angle && angle < 135 )\n    return QSwipeGesture::Up;\n\n  if ( 225 < angle && angle < 315 )\n    return QSwipeGesture::Down;\n\n  return QSwipeGesture::NoDirection;\n}\n\nGDPinchGesture::GDPinchGesture( QObject * parent ) :\nQGesture( parent ),\nisNewSequence( true )\n{\n}\n\nQGesture * GDPinchGestureRecognizer::create( QObject * pTarget )\n{\n  if ( pTarget && pTarget->isWidgetType()) {\n    static_cast< QWidget * >( pTarget )->setAttribute( Qt::WA_AcceptTouchEvents );\n  }\n  QGesture *pGesture = new GDPinchGesture( pTarget );\n  return pGesture;\n}\n\nvoid GDPinchGestureRecognizer::reset( QGesture * pGesture )\n{\n  QGestureRecognizer::reset( pGesture );\n}\n\nQGestureRecognizer::Result GDPinchGestureRecognizer::recognize( QGesture * state,\n                                                                QObject *,\n                                                                QEvent * event)\n{\n  QGestureRecognizer::Result result = QGestureRecognizer::Ignore;\n  GDPinchGesture * gest = static_cast< GDPinchGesture * >( state );\n\n  switch ( event->type() )\n  {\n    case QEvent::TouchBegin:\n      {\n        result = QGestureRecognizer::MayBeGesture;\n        gest->isNewSequence = true;\n        break;\n      }\n#if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)\n    case QEvent::TouchCancel:\n#endif\n    case QEvent::TouchEnd:\n      {\n        result = QGestureRecognizer::CancelGesture;\n        fewTouchPointsPresented = false;\n        break;\n      }\n    case QEvent::TouchUpdate:\n      {\n        gest->scaleChanged = false;\n        const QTouchEvent * const ev = static_cast< const QTouchEvent * >( event );\n        fewTouchPointsPresented = ( ev->touchPoints().size() > 1 );\n        if ( ev->touchPoints().size() == 2 )\n        {\n          QTouchEvent::TouchPoint p1 = ev->touchPoints().at( 0 );\n          QTouchEvent::TouchPoint p2 = ev->touchPoints().at( 1 );\n\n          QPointF centerPoint = ( p1.screenPos() + p2.screenPos() ) / 2.0;\n          gest->setHotSpot( centerPoint );\n          if ( gest->isNewSequence )\n          {\n            gest->startPosition[ 0 ] = p1.screenPos();\n            gest->startPosition[ 1 ] = p2.screenPos();\n            gest->lastCenterPoint = centerPoint;\n          }\n          else\n          {\n            gest->lastCenterPoint = gest->centerPoint;\n          }\n          gest->centerPoint = centerPoint;\n\n          if ( gest->isNewSequence )\n          {\n            gest->scaleFactor = 1.0;\n            gest->lastScaleFactor = 1.0;\n            gest->totalScaleFactor = 1.0;\n          }\n          else\n          {\n            gest->lastScaleFactor = gest->scaleFactor;\n            QLineF line( p1.screenPos(), p2.screenPos() );\n            QLineF lastLine( p1.lastScreenPos(),  p2.lastScreenPos() );\n            gest->scaleFactor = line.length() / lastLine.length();\n          }\n\n          gest->totalScaleFactor = gest->totalScaleFactor * gest->scaleFactor;\n          gest->scaleChanged = true;\n\n          gest->isNewSequence = false;\n          if( gest->totalScaleFactor <= OUT_SCALE_LIMIT || gest->totalScaleFactor >= IN_SCALE_LIMIT )\n          {\n            result = QGestureRecognizer::TriggerGesture;\n            gest->isNewSequence = true;\n          }\n          else\n            result = QGestureRecognizer::MayBeGesture;\n        }\n        else\n        {\n          gest->isNewSequence = true;\n          if ( gest->state() == Qt::NoGesture )\n            result = QGestureRecognizer::Ignore;\n          else\n            result = QGestureRecognizer::FinishGesture;\n        }\n        break;\n    }\n  case QEvent::MouseButtonPress:\n  case QEvent::MouseMove:\n  case QEvent::MouseButtonRelease:\n      result = QGestureRecognizer::Ignore;\n      break;\n  default:\n      result = QGestureRecognizer::Ignore;\n      break;\n  }\n  return result;\n}\n\n\nGDSwipeGesture::GDSwipeGesture( QObject * parent ) :\nQGesture( parent ),\nvertDirection( QSwipeGesture::NoDirection ),\nhorizDirection( QSwipeGesture::NoDirection ),\nstarted( false )\n{\n}\n\nQGesture * GDSwipeGestureRecognizer::create( QObject * pTarget )\n{\n  if ( pTarget && pTarget->isWidgetType() ) {\n    static_cast< QWidget * >( pTarget )->setAttribute( Qt::WA_AcceptTouchEvents );\n  }\n  QGesture *pGesture = new GDSwipeGesture( pTarget );\n  return pGesture;\n}\n\nvoid GDSwipeGestureRecognizer::reset( QGesture * pGesture )\n{\n  GDSwipeGesture * gest = static_cast< GDSwipeGesture * >( pGesture );\n  gest->vertDirection = QSwipeGesture::NoDirection;\n  gest->horizDirection = QSwipeGesture::NoDirection;\n  gest->lastPositions[ 0 ] = QPoint();\n  gest->lastPositions[ 1 ] = QPoint();\n\n  QGestureRecognizer::reset( pGesture );\n}\n\nqreal GDSwipeGestureRecognizer::computeAngle( int dx, int dy )\n{\n   double PI = 3.14159265;\n\n   // Need to convert from screen coordinates direction\n   // into classical coordinates direction.\n   dy = -dy;\n\n   double result = atan2( (double)dy, (double)dx ) ;\n   result = ( result * 180 ) / PI;\n\n   // Always return positive angle.\n   if ( result < 0 )\n      result += 360;\n\n   return result;\n}\n\nQGestureRecognizer::Result GDSwipeGestureRecognizer::recognize( QGesture * state,\n                                                                QObject *,\n                                                                QEvent * event)\n{\n  GDSwipeGesture * swipe = static_cast< GDSwipeGesture * >( state );\n  QGestureRecognizer::Result result = QGestureRecognizer::Ignore;\n\n  switch( event->type() )\n  {\n    case QEvent::TouchBegin:\n      {\n        swipe->unsetHotSpot();\n        swipe->lastPositions[ 0 ] = QPoint();\n        swipe->started = true;\n        result = QGestureRecognizer::MayBeGesture;\n        break;\n      }\n#if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)\n    case QEvent::TouchCancel:\n#endif\n    case QEvent::TouchEnd:\n      {\n        fewTouchPointsPresented = false;\n        result = QGestureRecognizer::CancelGesture;\n        break;\n      }\n    case QEvent::TouchUpdate:\n      {\n        const QTouchEvent * const ev = static_cast< const QTouchEvent * >( event );\n        fewTouchPointsPresented = ( ev->touchPoints().size() > 1 );\n        if( !swipe->started )\n          result = QGestureRecognizer::CancelGesture;\n        else\n        if( ev->touchPoints().size() == 2 )\n        {\n          //2-point gesture\n\n          QTouchEvent::TouchPoint p1 = ev->touchPoints().at( 0 );\n          QTouchEvent::TouchPoint p2 = ev->touchPoints().at( 1 );\n\n          if (swipe->lastPositions[0].isNull()) {\n            swipe->lastPositions[ 0 ] = p1.startScreenPos().toPoint();\n            swipe->lastPositions[ 1 ] = p2.startScreenPos().toPoint();\n          }\n\n          if( !swipe->hasHotSpot() )\n          {\n            swipe->setHotSpot( ( p1.startScreenPos() + p2.startScreenPos() ) / 2 );\n          }\n\n          int dx1 = p1.screenPos().toPoint().x() - swipe->lastPositions[ 0 ].x();\n          int dx2 = p2.screenPos().toPoint().x() - swipe->lastPositions[ 1 ].x();\n          int dy1 = p1.screenPos().toPoint().y() - swipe->lastPositions[ 0 ].y();\n          int dy2 = p2.screenPos().toPoint().y() - swipe->lastPositions[ 1 ].y();\n\n          if( qAbs( ( dx1 + dx2 ) / 2.0 ) >= MOVE_X_TRESHOLD ||\n              qAbs( ( dy1 + dy2 ) / 2.0 ) >= MOVE_Y_TRESHOLD )\n          {\n            qreal angle1 = computeAngle( dx1, dy1 );\n            qreal angle2 = computeAngle( dx2, dy2 );\n            QSwipeGesture::SwipeDirection vertDir = getVerticalDirection( angle1 );\n            QSwipeGesture::SwipeDirection horizDir = getHorizontalDirection( angle1 );\n\n            if( vertDir != getVerticalDirection( angle2 ) ||\n                horizDir != getHorizontalDirection( angle2 ) )\n            {\n              // It seems it is no swipe gesture\n              result = QGestureRecognizer::CancelGesture;\n              break;\n            }\n\n            if( ( swipe->vertDirection != QSwipeGesture::NoDirection && horizDir != QSwipeGesture::NoDirection ) ||\n                ( swipe->horizDirection != QSwipeGesture::NoDirection && vertDir != QSwipeGesture::NoDirection ) )\n            {\n              // Gesture direction changed\n              result = QGestureRecognizer::CancelGesture;\n              break;\n            }\n\n            swipe->vertDirection = vertDir;\n            swipe->horizDirection = horizDir;\n\n            swipe->lastPositions[ 0 ] = p1.screenPos().toPoint();\n            swipe->lastPositions[ 1 ] = p2.screenPos().toPoint();\n\n            result = QGestureRecognizer::TriggerGesture;\n          }\n          else\n            result = QGestureRecognizer::MayBeGesture;\n        }\n        else // No 2-point gesture\n          result = QGestureRecognizer::CancelGesture;\n        break;\n      }\n    case QEvent::MouseButtonPress:\n    case QEvent::MouseMove:\n    case QEvent::MouseButtonRelease:\n          result = QGestureRecognizer::Ignore;\n          break;\n    default:\n        result = QGestureRecognizer::Ignore;\n        break;\n  }\n\n  return result;\n}\n\nconst qreal GDPinchGestureRecognizer::OUT_SCALE_LIMIT = 0.5;\nconst qreal GDPinchGestureRecognizer::IN_SCALE_LIMIT = 2;\n\nbool handleGestureEvent( QObject * obj, QEvent * event, GestureResult & result,\n                         QPoint & point )\n{\n  result = NOT_HANLDED;\n\n  if( event->type() != QEvent::Gesture || !obj->isWidgetType() )\n    return false;\n\n  QGestureEvent * gev = static_cast<QGestureEvent *>( event );\n\n  gev->accept( Qt::PanGesture );\n\n  QGesture * gesture = gev->gesture( GDSwipeGestureType );\n  if( gesture )\n  {\n    GDSwipeGesture * swipe = static_cast< GDSwipeGesture * >( gesture );\n    point = swipe->hotSpot().toPoint();\n\n    if( swipe->getHorizDirection() != QSwipeGesture::NoDirection )\n      result = swipe->getHorizDirection() == QSwipeGesture::Left ?\n               SWIPE_LEFT : SWIPE_RIGHT;\n\n    if( swipe->getVertDirection() != QSwipeGesture::NoDirection )\n      result = swipe->getVertDirection() == QSwipeGesture::Up ?\n                SWIPE_UP : SWIPE_DOWN;\n\n    gev->setAccepted( true );\n    return true;\n  }\n\n  gesture = gev->gesture( GDPinchGestureType );\n  if( gesture )\n  {\n    GDPinchGesture * pinch = static_cast< GDPinchGesture * >( gesture );\n    point = pinch->getCenterPoint().toPoint();\n\n    if( pinch->isScaleChanged() )\n    {\n      if( pinch->getTotalScaleFactor() <= GDPinchGestureRecognizer::OUT_SCALE_LIMIT )\n        result = ZOOM_OUT;\n      if( pinch->getTotalScaleFactor() >= GDPinchGestureRecognizer::IN_SCALE_LIMIT )\n        result = ZOOM_IN;\n    }\n    gev->setAccepted( true );\n    return true;\n  }\n\n  gesture = gev->gesture( Qt::PanGesture );\n  if( gesture )\n  {\n    gev->setAccepted( true );\n    return true;\n  }\n  return false;\n}\n\nvoid registerRecognizers()\n{\n  QGestureRecognizer * pRecognizer = new Gestures::GDPinchGestureRecognizer();\n  GDPinchGestureType = QGestureRecognizer::registerRecognizer( pRecognizer );\n\n  pRecognizer = new Gestures::GDSwipeGestureRecognizer();\n  GDSwipeGestureType = QGestureRecognizer::registerRecognizer( pRecognizer );\n}\n\nvoid unregisterRecognizers()\n{\n  if( GDPinchGestureType )\n    QGestureRecognizer::unregisterRecognizer( GDPinchGestureType );\n\n  if( GDSwipeGestureType )\n    QGestureRecognizer::unregisterRecognizer( GDSwipeGestureType );\n}\n\n} // namespace\n\n#endif //QT_VERSION\n"
        },
        {
          "name": "gestures.hh",
          "type": "blob",
          "size": 2.53125,
          "content": "#ifndef __GESTURES_HH_INCLUDED__\n#define __GESTURES_HH_INCLUDED__\n\n#if QT_VERSION >= QT_VERSION_CHECK(4, 6, 0)\n\n#include <QGestureRecognizer>\n#include <QGesture>\n#include <QTimer>\n#include <QEvent>\n#include <QAction>\n\nnamespace Gestures\n{\n\nenum GestureResult\n{\n  NOT_HANLDED,\n  SWIPE_LEFT,\n  SWIPE_RIGHT,\n  SWIPE_UP,\n  SWIPE_DOWN,\n  ZOOM_IN,\n  ZOOM_OUT\n};\n\nextern Qt::GestureType GDPinchGestureType;\nextern Qt::GestureType GDSwipeGestureType;\n\nvoid registerRecognizers();\n\nvoid unregisterRecognizers();\n\nbool isFewTouchPointsPresented();\n\nclass GDPinchGestureRecognizer;\nclass GDPinchGesture : public QGesture\n{\npublic:\n  GDPinchGesture( QObject * parent );\n\n  bool isScaleChanged() const\n  { return scaleChanged; }\n  QPointF const & getCenterPoint() const\n  { return centerPoint; }\n  qreal getTotalScaleFactor() const\n  { return totalScaleFactor; }\n\nprotected:\n  QPointF startCenterPoint;\n  QPointF lastCenterPoint;\n  QPointF centerPoint;\n\n  qreal lastScaleFactor;\n  qreal scaleFactor;\n  qreal totalScaleFactor;\n\n  bool isNewSequence;\n  QPointF startPosition[ 2 ];\n  bool scaleChanged;\n\n  friend class GDPinchGestureRecognizer;\n};\n\nclass GDSwipeGestureRecognizer;\nclass GDSwipeGesture : public QGesture\n{\npublic:\n  GDSwipeGesture( QObject * parent );\n  QSwipeGesture::SwipeDirection getHorizDirection() const\n  { return horizDirection; }\n  QSwipeGesture::SwipeDirection getVertDirection() const\n  { return vertDirection; }\n\nprotected:\n  QSwipeGesture::SwipeDirection vertDirection;\n  QSwipeGesture::SwipeDirection horizDirection;\n  QPoint lastPositions[ 2 ];\n  bool started;\n\n  friend class GDSwipeGestureRecognizer;\n};\n\nclass GDPinchGestureRecognizer : public QGestureRecognizer\n{\npublic:\n  static const qreal OUT_SCALE_LIMIT;\n  static const qreal IN_SCALE_LIMIT;\n\n  GDPinchGestureRecognizer() {}\nprivate:\n\n  virtual QGesture* create( QObject* pTarget );\n  virtual QGestureRecognizer::Result recognize( QGesture* pGesture, QObject *pWatched, QEvent * pEvent );\n  void reset( QGesture *pGesture );\n};\n\nclass GDSwipeGestureRecognizer : public QGestureRecognizer\n{\npublic:\n  GDSwipeGestureRecognizer(){}\nprivate:\n  static const int MOVE_X_TRESHOLD = 100;\n  static const int MOVE_Y_TRESHOLD = 50;\n\n  virtual QGesture * create( QObject* pTarget );\n  virtual QGestureRecognizer::Result recognize( QGesture* pGesture, QObject * pWatched, QEvent * pEvent );\n  void reset ( QGesture * pGesture );\n  qreal computeAngle( int dx, int dy );\n};\n\nbool handleGestureEvent( QObject * obj, QEvent * event, GestureResult & result, QPoint & point );\n\n} // namespace\n\n#endif\n\n#endif // __GESTURES_HH_INCLUDED__\n"
        },
        {
          "name": "gls.cc",
          "type": "blob",
          "size": 50.8134765625,
          "content": "/* This file is (c) 2008-2017 Abs62\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include <zlib.h>\n#include \"gls.hh\"\n#include \"iconv.hh\"\n#include \"dictionary.hh\"\n#include \"ufile.hh\"\n#include \"btreeidx.hh\"\n#include \"folding.hh\"\n#include \"categorized_logging.hh\"\n#include \"gddebug.hh\"\n#include \"utf8.hh\"\n#include \"wstring_qt.hh\"\n#include \"chunkedstorage.hh\"\n#include \"langcoder.hh\"\n#include \"dictzip.h\"\n#include \"indexedzip.hh\"\n#include \"ftshelpers.hh\"\n#include \"fsencoding.hh\"\n#include \"htmlescape.hh\"\n#include \"filetype.hh\"\n#include \"tiff.hh\"\n#include \"audiolink.hh\"\n\n#include <QString>\n#include <QSemaphore>\n#include <QThreadPool>\n#include <QAtomicInt>\n// For TIFF conversion\n#include <QImage>\n#include <QByteArray>\n#include <QBuffer>\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n#include <QRegularExpression>\n#endif\n\n#include <string>\n#include <list>\n#include <map>\n#include <set>\n\n#ifdef _MSC_VER\n#include <stub_msvc.h>\n#endif\n\nnamespace Gls {\n\nusing std::list;\nusing std::map;\nusing std::set;\nusing std::multimap;\nusing std::pair;\n\nusing gd::wstring;\nusing gd::wchar;\n\nusing BtreeIndexing::WordArticleLink;\nusing BtreeIndexing::IndexedWords;\nusing BtreeIndexing::IndexInfo;\n\nenum Encoding\n{\n  Utf8,\n  Utf16LE,\n  Utf16BE\n};\n\n/////////////// GlsScanner\n\nclass GlsScanner\n{\n  gzFile f;\n  Encoding encoding;\n  Iconv iconv;\n  wstring dictionaryName;\n  wstring dictionaryDecription, dictionaryAuthor;\n  wstring langFrom, langTo;\n  char readBuffer[ 65536 ];\n  char * readBufferPtr;\n  size_t readBufferLeft;\n  vector< wchar > wcharBuffer;\n  unsigned linesRead;\n\npublic:\n\n  DEF_EX( Ex, \"Gls scanner exception\", Dictionary::Ex )\n  DEF_EX_STR( exCantOpen, \"Can't open .gls file\", Ex )\n  DEF_EX( exCantReadGlsFile, \"Can't read .gls file\", Ex )\n  DEF_EX_STR( exMalformedGlsFile, \"The .gls file is malformed:\", Ex )\n  DEF_EX( exEncodingError, \"Encoding error\", Ex ) // Should never happen really\n\n  GlsScanner( string const & fileName ) THROW_SPEC( Ex, Iconv::Ex );\n  ~GlsScanner() throw();\n\n  /// Returns the detected encoding of this file.\n  Encoding getEncoding() const\n  { return encoding; }\n\n  /// Returns the dictionary's name, as was read from file's headers.\n  wstring const & getDictionaryName() const\n  { return dictionaryName; }\n\n  /// Returns the dictionary's author, as was read from file's headers.\n  wstring const & getDictionaryAuthor() const\n  { return dictionaryAuthor; }\n\n  /// Returns the dictionary's description, as was read from file's headers.\n  wstring const & getDictionaryDescription() const\n  { return dictionaryDecription; }\n\n  /// Returns the dictionary's source language, as was read from file's headers.\n  wstring const & getLangFrom() const\n  { return langFrom; }\n\n  /// Returns the dictionary's target language, as was read from file's headers.\n  wstring const & getLangTo() const\n  { return langTo; }\n\n  /// Reads next line from the file. Returns true if reading succeeded --\n  /// the string gets stored in the one passed, along with its physical\n  /// file offset in the file (the uncompressed one if the file is compressed).\n  /// If end of file is reached, false is returned.\n  /// Reading begins from the first line after the headers (ones which end\n  /// by the \"### Glossary section:\" line).\n  bool readNextLine( wstring &, size_t & offset ) THROW_SPEC( Ex, Iconv::Ex );\n\n  /// Returns the number of lines read so far from the file.\n  unsigned getLinesRead() const\n  { return linesRead; }\n\n  /// Returns a name to be passed to iconv for the given encoding.\n  static char const * getEncodingNameFor( Encoding e )\n  {\n    switch( e )\n    {\n      case Utf16LE:\n        return Iconv::Utf16Le;\n      case Utf16BE:\n        return \"UTF-16BE\";\n      case Utf8:\n      default:\n        return Iconv::Utf8;\n    }\n  }\n};\n\nGlsScanner::GlsScanner( string const & fileName ) THROW_SPEC( Ex, Iconv::Ex ):\n  encoding( Utf8 ), iconv( Iconv::GdWchar, Iconv::Utf8 ), readBufferPtr( readBuffer ),\n  readBufferLeft( 0 ), wcharBuffer( 64 ), linesRead( 0 )\n{\n  // Since .dz is backwards-compatible with .gz, we use gz- functions to\n  // read it -- they are much nicer than the dict_data- ones.\n\n  f = gd_gzopen( fileName.c_str() );\n  if ( !f )\n    throw exCantOpen( fileName );\n\n  // Now try guessing the encoding by reading the first two bytes\n\n  unsigned char firstBytes[ 2 ];\n\n  if ( gzread( f, firstBytes, sizeof( firstBytes ) ) != sizeof( firstBytes ) )\n  {\n    // Apparently the file's too short\n    gzclose( f );\n    throw exMalformedGlsFile( fileName );\n  }\n\n  // If the file begins with the dedicated Unicode marker, we just consume\n  // it. If, on the other hand, it's not, we return the bytes back\n  if ( firstBytes[ 0 ] == 0xFF && firstBytes[ 1 ] == 0xFE )\n    encoding = Utf16LE;\n  else\n  if ( firstBytes[ 0 ] == 0xFE && firstBytes[ 1 ] == 0xFF )\n    encoding = Utf16BE;\n  else\n  if ( firstBytes[ 0 ] == 0xEF && firstBytes[ 1 ] == 0xBB )\n  {\n    // Looks like Utf8, read one more byte\n    if ( gzread( f, firstBytes, 1 ) != 1 || firstBytes[ 0 ] != 0xBF )\n    {\n      // Either the file's too short, or the BOM is weird\n      gzclose( f );\n      throw exMalformedGlsFile( fileName );\n    }\n    encoding = Utf8;\n  }\n  else\n  {\n    if ( gzrewind( f ) )\n    {\n      gzclose( f );\n      throw exCantOpen( fileName );\n    }\n    encoding = Utf8;\n  }\n\n  if( encoding != Utf8 )\n    iconv.reinit( Iconv::GdWchar, getEncodingNameFor( encoding ) );\n\n  // We now can use our own readNextLine() function\n\n  wstring str;\n  wstring *currentField = 0;\n  wstring mark = GD_NATIVE_TO_WS( L\"###\" );\n  wstring titleMark = GD_NATIVE_TO_WS( L\"### Glossary title:\" );\n  wstring authorMark = GD_NATIVE_TO_WS( L\"### Author:\" );\n  wstring descriptionMark = GD_NATIVE_TO_WS( L\"### Description:\" );\n  wstring langFromMark = GD_NATIVE_TO_WS( L\"### Source language:\" );\n  wstring langToMark = GD_NATIVE_TO_WS( L\"### Target language:\" );\n  wstring endOfHeaderMark = GD_NATIVE_TO_WS( L\"### Glossary section:\" );\n  size_t offset;\n\n  for( ; ; )\n  {\n    if ( !readNextLine( str, offset ) )\n    {\n      gzclose( f );\n      throw exMalformedGlsFile( fileName );\n    }\n\n    if( str.compare( 0, 3, mark.c_str(), 3 ) == 0 )\n    {\n      currentField = 0;\n\n      if( str.compare( 0, titleMark.size(), titleMark ) == 0 )\n      {\n        dictionaryName = wstring( str, titleMark.size(), str.size() - titleMark.size() );\n        currentField = &dictionaryName;\n      }\n      else\n      if( str.compare( 0, authorMark.size(), authorMark ) == 0 )\n      {\n        dictionaryAuthor = wstring( str, authorMark.size(), str.size() - authorMark.size() );\n        currentField = &dictionaryAuthor;\n      }\n      else\n      if( str.compare( 0, descriptionMark.size(), descriptionMark ) == 0 )\n      {\n        dictionaryDecription = wstring( str, descriptionMark.size(), str.size() - descriptionMark.size() );\n        currentField = &dictionaryDecription;\n      }\n      else\n      if( str.compare( 0, langFromMark.size(), langFromMark ) == 0 )\n      {\n        langFrom = wstring( str, langFromMark.size(), str.size() - langFromMark.size() );\n      }\n      else\n      if( str.compare( 0, langToMark.size(), langToMark ) == 0 )\n      {\n        langTo = wstring( str, langToMark.size(), str.size() - langToMark.size() );\n      }\n      else\n      if( str.compare( 0, endOfHeaderMark.size(), endOfHeaderMark ) == 0 )\n      {\n        break;\n      }\n    }\n    else\n    {\n      /// Handle multiline headers\n      if( currentField )\n        *currentField += str;\n    }\n  }\n}\n\nbool GlsScanner::readNextLine( wstring & out, size_t & offset ) THROW_SPEC( Ex,\n                                                                       Iconv::Ex )\n{\n  offset = (size_t)( gztell( f ) - readBufferLeft );\n\n  // For now we just read one char at a time\n  size_t readMultiple = ( encoding == Utf16LE || encoding == Utf16BE ) ? 2 : 1;\n\n  size_t leftInOut = wcharBuffer.size();\n\n  wchar * outPtr = &wcharBuffer.front();\n\n  for( ; ; )\n  {\n    // Check that we have bytes to read\n    if ( readBufferLeft < 4 ) // To convert one char, we need at most 4 bytes\n    {\n      if ( !gzeof( f ) )\n      {\n        // To avoid having to deal with ring logic, we move the remaining bytes\n        // to the beginning\n        memmove( readBuffer, readBufferPtr, readBufferLeft );\n\n        // Read some more bytes to readBuffer\n        int result = gzread( f, readBuffer + readBufferLeft,\n                             sizeof( readBuffer ) - readBufferLeft );\n\n        if ( result == -1 )\n          throw exCantReadGlsFile();\n\n        readBufferPtr = readBuffer;\n        readBufferLeft += (size_t) result;\n      }\n    }\n\n    if ( readBufferLeft < readMultiple )\n    {\n      // No more data. Return what we've got so far, forget the last byte if\n      // it was a 16-bit Unicode and a file had an odd number of bytes.\n      readBufferLeft = 0;\n\n      if ( outPtr != &wcharBuffer.front() )\n      {\n        // If there was a stray \\r, remove it\n        if ( outPtr[ -1 ] == L'\\r' )\n          --outPtr;\n\n        out = wstring( &wcharBuffer.front(), outPtr - &wcharBuffer.front() );\n\n        ++linesRead;\n\n        return true;\n      }\n      else\n        return false;\n    }\n\n    // Check that we have chars to write\n    if ( leftInOut < 2 ) // With 16-bit wchars, 2 is needed for a surrogate pair\n    {\n      wcharBuffer.resize( wcharBuffer.size() + 64 );\n      outPtr = &wcharBuffer.front() + wcharBuffer.size() - 64 - leftInOut;\n      leftInOut += 64;\n    }\n\n    // Ok, now convert one char\n    size_t outBytesLeft = sizeof( wchar );\n\n    Iconv::Result r =\n      iconv.convert( (void const *&)readBufferPtr, readBufferLeft,\n                     (void *&)outPtr, outBytesLeft );\n\n    if ( r == Iconv::NeedMoreOut && outBytesLeft == sizeof( wchar ) )\n    {\n      // Seems to be a surrogate pair with a 16-bit target wchar\n\n      outBytesLeft *= 2;\n      r = iconv.convert( (void const *&)readBufferPtr, readBufferLeft,\n                     (void *&)outPtr, outBytesLeft );\n      --leftInOut; // Complements the next decremention\n    }\n\n    if ( outBytesLeft )\n      throw exEncodingError();\n\n    --leftInOut;\n\n    // Have we got \\n?\n    if ( outPtr[ -1 ] == L'\\n' )\n    {\n      --outPtr;\n\n      // Now kill a \\r if there is one, and return the result.\n      if ( outPtr != &wcharBuffer.front() && outPtr[ -1 ] == L'\\r' )\n          --outPtr;\n\n      out = wstring( &wcharBuffer.front(), outPtr - &wcharBuffer.front() );\n\n      ++linesRead;\n\n      return true;\n    }\n  }\n}\n\nGlsScanner::~GlsScanner() throw()\n{\n  gzclose( f );\n}\n\nnamespace {\n\n////////////////// GLS Dictionary\n\nDEF_EX_STR( exCantReadFile, \"Can't read file\", Dictionary::Ex )\nDEF_EX( exUserAbort, \"User abort\", Dictionary::Ex )\nDEF_EX_STR( exDictzipError, \"DICTZIP error\", Dictionary::Ex )\n\nenum\n{\n  Signature = 0x58534c47, // GLSX on little-endian, XSLG on big-endian\n  CurrentFormatVersion = 1 + BtreeIndexing::FormatVersion + Folding::Version,\n  CurrentZipSupportVersion = 2,\n  CurrentFtsIndexVersion = 1\n};\n\nstruct IdxHeader\n{\n  uint32_t signature; // First comes the signature, GLSX\n  uint32_t formatVersion; // File format version (CurrentFormatVersion)\n  uint32_t zipSupportVersion; // Zip support version -- narrows down reindexing\n                              // when it changes only for dictionaries with the\n                              // zip files\n  int glsEncoding; // Which encoding is used for the file indexed\n  uint32_t chunksOffset; // The offset to chunks' storage\n  uint32_t indexBtreeMaxElements; // Two fields from IndexInfo\n  uint32_t indexRootOffset;\n  uint32_t articleCount; // Number of articles this dictionary has\n  uint32_t wordCount; // Number of headwords this dictionary has\n  uint32_t langFrom;  // Source language\n  uint32_t langTo;    // Target language\n  uint32_t hasZipFile; // Non-zero means there's a zip file with resources\n                       // present\n  uint32_t zipIndexBtreeMaxElements; // Two fields from IndexInfo of the zip\n                                     // resource index.\n  uint32_t zipIndexRootOffset;\n}\n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\nbool indexIsOldOrBad( string const & indexFile, bool hasZipFile )\n{\n  File::Class idx( indexFile, \"rb\" );\n\n  IdxHeader header;\n\n  return idx.readRecords( &header, sizeof( header ), 1 ) != 1 ||\n         header.signature != Signature ||\n         header.formatVersion != CurrentFormatVersion ||\n         (bool) header.hasZipFile != hasZipFile ||\n         ( hasZipFile && header.zipSupportVersion != CurrentZipSupportVersion );\n}\n\nclass GlsDictionary: public BtreeIndexing::BtreeDictionary\n{\n  Mutex idxMutex;\n  File::Class idx;\n  IdxHeader idxHeader;\n  dictData * dz;\n  ChunkedStorage::Reader chunks;\n  Mutex dzMutex;\n  Mutex resourceZipMutex;\n  IndexedZip resourceZip;\n  string dictionaryName;\n\npublic:\n\n  GlsDictionary( string const & id, string const & indexFile,\n                      vector< string > const & dictionaryFiles );\n\n  ~GlsDictionary();\n\n  virtual string getName() throw()\n  { return dictionaryName; }\n\n  virtual map< Dictionary::Property, string > getProperties() throw()\n  { return map< Dictionary::Property, string >(); }\n\n  virtual unsigned long getArticleCount() throw()\n  { return idxHeader.articleCount; }\n\n  virtual unsigned long getWordCount() throw()\n  { return idxHeader.wordCount; }\n\n  inline virtual quint32 getLangFrom() const\n  { return idxHeader.langFrom; }\n\n  inline virtual quint32 getLangTo() const\n  { return idxHeader.langTo; }\n\n  virtual sptr< Dictionary::WordSearchRequest > findHeadwordsForSynonym( wstring const & )\n    THROW_SPEC( std::exception );\n\n  virtual sptr< Dictionary::DataRequest > getArticle( wstring const &,\n                                                      vector< wstring > const & alts,\n                                                      wstring const &,\n                                                      bool ignoreDiacritics )\n    THROW_SPEC( std::exception );\n\n  virtual sptr< Dictionary::DataRequest > getResource( string const & name )\n    THROW_SPEC( std::exception );\n\n  virtual QString const& getDescription();\n\n  virtual QString getMainFilename();\n\n  virtual sptr< Dictionary::DataRequest > getSearchResults( QString const & searchString,\n                                                            int searchMode, bool matchCase,\n                                                            int distanceBetweenWords,\n                                                            int maxResults,\n                                                            bool ignoreWordsOrder,\n                                                            bool ignoreDiacritics,\n                                                            QThreadPool * ftsThreadPoolPtr );\n\n  virtual void getArticleText( uint32_t articleAddress, QString & headword, QString & text );\n\n  virtual void makeFTSIndex(QAtomicInt & isCancelled, bool firstIteration );\n\n  virtual void setFTSParameters( Config::FullTextSearch const & fts )\n  {\n    can_FTS = fts.enabled\n              && !fts.disabledTypes.contains( \"GLS\", Qt::CaseInsensitive )\n              && ( fts.maxDictionarySize == 0 || getArticleCount() <= fts.maxDictionarySize );\n  }\nprotected:\n\n  void loadIcon() throw();\n\nprivate:\n\n  /// Loads the article, storing its headword and formatting the data it has\n  /// into an html.\n  void loadArticle(  uint32_t address,\n                     string & headword,\n                     string & articleText );\n\n  /// Loads the article\n  void loadArticleText(  uint32_t address,\n                         vector< string > & headwords,\n                         string & articleText );\n\n  /// Process resource links (images, audios, etc)\n  QString & filterResource( QString & article );\n\n  friend class GlsResourceRequest;\n  friend class GlsArticleRequest;\n  friend class GlsHeadwordsRequest;\n};\n\nGlsDictionary::GlsDictionary( string const & id,\n                              string const & indexFile,\n                              vector< string > const & dictionaryFiles ):\n  BtreeDictionary( id, dictionaryFiles ),\n  idx( indexFile, \"rb\" ),\n  idxHeader( idx.read< IdxHeader >() ),\n  dz( 0 ),\n  chunks( idx, idxHeader.chunksOffset )\n{\n  // Open the .gls file\n\n  DZ_ERRORS error;\n  dz = dict_data_open( getDictionaryFilenames()[ 0 ].c_str(), &error, 0 );\n\n  if ( !dz )\n    throw exDictzipError( string( dz_error_str( error ) )\n                          + \"(\" + getDictionaryFilenames()[ 0 ] + \")\" );\n\n  // Read the dictionary name\n\n  idx.seek( sizeof( idxHeader ) );\n\n  vector< char > dName( idx.read< uint32_t >() );\n  if( dName.size() > 0 )\n  {\n    idx.read( &dName.front(), dName.size() );\n    dictionaryName = string( &dName.front(), dName.size() );\n  }\n\n  // Initialize the index\n\n  openIndex( IndexInfo( idxHeader.indexBtreeMaxElements,\n                        idxHeader.indexRootOffset ),\n             idx, idxMutex );\n\n  // Open a resource zip file, if there's one\n\n  if ( idxHeader.hasZipFile &&\n       ( idxHeader.zipIndexBtreeMaxElements ||\n         idxHeader.zipIndexRootOffset ) )\n  {\n    resourceZip.openIndex( IndexInfo( idxHeader.zipIndexBtreeMaxElements,\n                                      idxHeader.zipIndexRootOffset ),\n                           idx, idxMutex );\n\n    QString zipName = QDir::fromNativeSeparators(\n        FsEncoding::decode( getDictionaryFilenames().back().c_str() ) );\n\n    if ( zipName.endsWith( \".zip\", Qt::CaseInsensitive ) ) // Sanity check\n      resourceZip.openZipFile( zipName );\n  }\n\n  // Full-text search parameters\n\n  can_FTS = true;\n\n  ftsIdxName = indexFile + \"_FTS\";\n\n  if( !Dictionary::needToRebuildIndex( dictionaryFiles, ftsIdxName )\n      && !FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) )\n    FTS_index_completed.ref();\n}\n\nGlsDictionary::~GlsDictionary()\n{\n  if ( dz )\n    dict_data_close( dz );\n}\n\nvoid GlsDictionary::loadIcon() throw()\n{\n  if ( dictionaryIconLoaded )\n    return;\n\n  QString fileName =\n    QDir::fromNativeSeparators( FsEncoding::decode( getDictionaryFilenames()[ 0 ].c_str() ) );\n\n  // Remove the extension\n  if ( fileName.endsWith( \".gls.dz\", Qt::CaseInsensitive ) )\n    fileName.chop( 6 );\n  else\n    fileName.chop( 3 );\n\n  if ( !loadIconFromFile( fileName ) )\n  {\n    // Load failed -- use default icon\n    dictionaryNativeIcon = dictionaryIcon = QIcon(\":/icons/icon32_gls.png\");\n  }\n\n  dictionaryIconLoaded = true;\n}\n\nQString const& GlsDictionary::getDescription()\n{\n  if( !dictionaryDescription.isEmpty() )\n      return dictionaryDescription;\n\n  try {\n    GlsScanner scanner( getDictionaryFilenames()[ 0 ] );\n    string str = Utf8::encode( scanner.getDictionaryAuthor() );\n    if( !str.empty() )\n      dictionaryDescription = QString( QObject::tr( \"Author: %1%2\" ) )\n                              .arg( QString::fromUtf8( str.c_str() ) )\n                              .arg( \"\\n\\n\" );\n    str = Utf8::encode( scanner.getDictionaryDescription() );\n    if( !str.empty() )\n    {\n      QString desc = QString::fromUtf8( str.c_str() );\n      desc.replace( \"\\t\", \"<br/>\" );\n      desc.replace( \"\\\\n\", \"<br/>\" );\n      desc.replace( \"<br>\", \"<br/>\", Qt::CaseInsensitive );\n      dictionaryDescription += Html::unescape( desc, true );\n    }\n  }\n  catch( std::exception & e )\n  {\n    gdWarning( \"GLS dictionary description reading failed: %s, error: %s\\n\",\n               getName().c_str(), e.what() );\n  }\n\n  if( dictionaryDescription.isEmpty() )\n    dictionaryDescription = \"NONE\";\n\n  return dictionaryDescription;\n}\n\nQString GlsDictionary::getMainFilename()\n{\n  return FsEncoding::decode( getDictionaryFilenames()[ 0 ].c_str() );\n}\n\nvoid GlsDictionary::makeFTSIndex( QAtomicInt & isCancelled, bool firstIteration )\n{\n  if( !( Dictionary::needToRebuildIndex( getDictionaryFilenames(), ftsIdxName )\n         || FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) ) )\n    FTS_index_completed.ref();\n\n  if( haveFTSIndex() )\n    return;\n\n  if( ensureInitDone().size() )\n    return;\n\n  if( firstIteration && getArticleCount() > FTS::MaxDictionarySizeForFastSearch )\n    return;\n\n  gdDebug( \"Gls: Building the full-text index for dictionary: %s\\n\",\n           getName().c_str() );\n\n  try\n  {\n    FtsHelpers::makeFTSIndex( this, isCancelled );\n    FTS_index_completed.ref();\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"Gls: Failed building full-text search index for \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n    QFile::remove( FsEncoding::decode( ftsIdxName.c_str() ) );\n  }\n}\n\nvoid GlsDictionary::loadArticleText( uint32_t address,\n                                     vector< string > & headwords,\n                                     string & articleText )\n{\n  vector< char > chunk;\n  char * articleProps;\n  {\n    Mutex::Lock _( idxMutex );\n\n    articleProps = chunks.getBlock( address, chunk );\n  }\n\n  uint32_t articleOffset, articleSize;\n\n  memcpy( &articleOffset, articleProps, sizeof( articleOffset ) );\n  memcpy( &articleSize, articleProps + sizeof( articleOffset ),\n          sizeof( articleSize ) );\n\n  char * articleBody;\n\n  {\n    Mutex::Lock _( dzMutex );\n\n    articleBody = dict_data_read_( dz, articleOffset, articleSize, 0, 0 );\n  }\n\n  headwords.clear();\n  articleText.clear();\n  string headword;\n\n  if ( !articleBody )\n  {\n    articleText = string( \"\\n\\tDICTZIP error: \" ) + dict_error_str( dz );\n  }\n  else\n  {\n    string articleData = Iconv::toUtf8( GlsScanner::getEncodingNameFor( Encoding( idxHeader.glsEncoding ) ), articleBody, articleSize );\n    string::size_type start_pos = 0, end_pos = 0;\n\n    for( ; ; )\n    {\n      // Replace all \"\\r\\n\" by \"\\n\"\n      end_pos = articleData.find( \"\\r\\n\", start_pos );\n      if( end_pos == string::npos )\n      {\n        articleText += articleData.substr( start_pos, end_pos );\n        break;\n      }\n      else\n      {\n        articleText += articleData.substr( start_pos, end_pos - start_pos ) + \"\\n\";\n        start_pos = end_pos + 2;\n      }\n    }\n\n    // Find headword\n    start_pos = articleText.find( '\\n' );\n    if( start_pos != string::npos )\n    {\n      headword = articleText.substr( 0, start_pos );\n      articleText = articleText.substr( start_pos + 1, string::npos );\n    }\n\n    // Parse headwords\n\n    start_pos = 0;\n    end_pos = 0;\n    for( ; ; )\n    {\n      end_pos = headword.find( '|', start_pos );\n      if( end_pos == wstring::npos )\n      {\n        string hw = headword.substr( start_pos );\n        if( !hw.empty() )\n          headwords.push_back( hw );\n        break;\n      }\n      headwords.push_back( headword.substr( start_pos, end_pos - start_pos ) );\n      start_pos = end_pos + 1;\n    }\n  }\n}\n\nvoid GlsDictionary::loadArticle( uint32_t address,\n                                 string & headword,\n                                 string & articleText )\n{\n  string articleBody;\n  vector< string > headwords;\n  loadArticleText( address, headwords, articleBody );\n\n  QString article = QString::fromLatin1( \"<div class=\\\"glsdict\\\">\" );\n  if( headwords.size() )\n  {\n    // Headwords\n    article += \"<div class=\\\"glsdict_headwords\\\"\";\n    if( isFromLanguageRTL() )\n      article += \" dir=\\\"rtl\\\"\";\n    if( headwords.size() > 1 )\n    {\n      QString altHeadwords;\n      for( vector< string >::size_type i = 1; i < headwords.size(); i++ )\n      {\n        if( i > 1 )\n          altHeadwords += \", \";\n        altHeadwords += QString::fromUtf8( headwords[ i ].c_str(), headwords[ i ].size() );\n      }\n      article += \" title=\\\"\" + altHeadwords + \"\\\"\";\n    }\n    article += \">\";\n\n    headword = headwords.front();\n    article += QString::fromUtf8( headword.c_str(), headword.size() );\n\n    article += \"</div>\";\n  }\n\n  if( isToLanguageRTL() )\n    article += \"<div style=\\\"display:inline;\\\" dir=\\\"rtl\\\">\";\n\n  QString text = QString::fromUtf8( articleBody.c_str(), articleBody.size() );\n\n  article += filterResource( text );\n\n  if( isToLanguageRTL() )\n    article += \"</div>\";\n\n  article +=\"</div>\";\n\n  articleText = string( article.toUtf8().data() );\n}\n\nQString & GlsDictionary::filterResource( QString & article )\n{\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  QRegularExpression imgRe( \"(<\\\\s*img\\\\s+[^>]*src\\\\s*=\\\\s*[\\\"']+)(?!(?:data|https?|ftp|qrcx):)\",\n                            QRegularExpression::CaseInsensitiveOption\n                            | QRegularExpression::InvertedGreedinessOption );\n  QRegularExpression linkRe( \"(<\\\\s*link\\\\s+[^>]*href\\\\s*=\\\\s*[\\\"']+)(?!(?:data|https?|ftp):)\",\n                             QRegularExpression::CaseInsensitiveOption\n                             | QRegularExpression::InvertedGreedinessOption );\n#else\n  QRegExp imgRe( \"(<\\\\s*img\\\\s+[^>]*src\\\\s*=\\\\s*[\\\"']+)(?!(?:data|https?|ftp|qrcx):)\", Qt::CaseInsensitive );\n  imgRe.setMinimal( true );\n  QRegExp linkRe( \"(<\\\\s*link\\\\s+[^>]*href\\\\s*=\\\\s*[\\\"']+)(?!(?:data|https?|ftp):)\", Qt::CaseInsensitive );\n  linkRe.setMinimal( true );\n#endif\n  article.replace( imgRe , \"\\\\1bres://\" + QString::fromStdString( getId() ) + \"/\" )\n         .replace( linkRe, \"\\\\1bres://\" + QString::fromStdString( getId() ) + \"/\" );\n\n  // Handle links to articles\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  QRegularExpression linksReg( \"<a(\\\\s+[^>]*)href\\\\s*=\\\\s*['\\\"](bword://)?([^'\\\"]+)['\\\"]\",\n                               QRegularExpression::CaseInsensitiveOption );\n#else\n  QRegExp linksReg( \"<a(\\\\s*[^>]*)href\\\\s*=\\\\s*['\\\"](bword://)?([^'\\\"]+)['\\\"]\" );\n  linksReg.setMinimal( true );\n#endif\n\n  int pos = 0;\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  QString articleNewText;\n  QRegularExpressionMatchIterator it = linksReg.globalMatch( article );\n  while( it.hasNext() )\n  {\n    QRegularExpressionMatch match = it.next();\n    articleNewText += article.midRef( pos, match.capturedStart() - pos );\n    pos = match.capturedEnd();\n\n    QString link = match.captured( 3 );\n#else\n  while( pos >= 0 )\n  {\n    pos = linksReg.indexIn( article, pos );\n    if( pos < 0 )\n      break;\n\n    QString link = linksReg.cap( 3 );\n#endif\n    if( link.indexOf( ':' ) < 0 )\n    {\n      QString newLink;\n      if( link.indexOf( '#' ) < 0 )\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n        newLink = QString( \"<a\" ) + match.captured( 1 ) + \"href=\\\"bword:\" + link + \"\\\"\";\n#else\n        newLink = QString( \"<a\" ) + linksReg.cap( 1 ) + \"href=\\\"bword:\" + link + \"\\\"\";\n#endif\n\n      // Anchors\n\n      if( link.indexOf( '#' ) > 0 )\n      {\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n        newLink = QString( \"<a\" ) + match.captured( 1 ) + \"href=\\\"gdlookup://localhost/\" + link + \"\\\"\";\n#else\n        newLink = QString( \"<a\" ) + linksReg.cap( 1 ) + \"href=\\\"gdlookup://localhost/\" + link + \"\\\"\";\n#endif\n        newLink.replace( \"#\", \"?gdanchor=\" );\n      }\n\n      if( !newLink.isEmpty() )\n      {\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n        articleNewText += newLink;\n#else\n        article.replace( pos, linksReg.cap( 0 ).size(), newLink );\n        pos += newLink.size();\n#endif\n      }\n      else\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n        articleNewText += match.captured();\n#else\n        pos += linksReg.cap( 0 ).size();\n#endif\n    }\n    else\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n      articleNewText += match.captured();\n  }\n  if( pos )\n  {\n    articleNewText += article.midRef( pos );\n    article = articleNewText;\n    articleNewText.clear();\n  }\n#else\n      pos += linksReg.cap( 0 ).size();\n  }\n#endif\n\n  // Handle \"audio\" tags\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  QRegularExpression audioRe( \"<\\\\s*audio\\\\s+src\\\\s*=\\\\s*([\\\"']+)([^\\\"']+)([\\\"'])\\\\s*>(.*)</audio>\",\n                              QRegularExpression::CaseInsensitiveOption\n                              | QRegularExpression::DotMatchesEverythingOption\n                              | QRegularExpression::InvertedGreedinessOption );\n#else\n  QRegExp audioRe( \"<\\\\s*audio\\\\s+src\\\\s*=\\\\s*([\\\"']+)([^\\\"']+)([\\\"'])\\\\s*>(.*)</audio>\", Qt::CaseInsensitive );\n  audioRe.setMinimal( true );\n#endif\n\n  pos = 0;\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  it = audioRe.globalMatch( article );\n  while( it.hasNext() )\n  {\n    QRegularExpressionMatch match = it.next();\n    articleNewText += article.midRef( pos, match.capturedStart() - pos );\n    pos = match.capturedEnd();\n\n    QString src = match.captured( 2 );\n#else\n  while( pos >= 0 )\n  {\n    pos = audioRe.indexIn( article, pos );\n    if( pos < 0 )\n      break;\n\n    QString src = audioRe.cap( 2 );\n#endif\n    if( src.indexOf( \"://\" ) >= 0 )\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n      articleNewText += match.captured();\n#else\n      pos += audioRe.cap( 0 ).length();\n#endif\n    else\n    {\n      std::string href = \"\\\"gdau://\" + getId() + \"/\" + src.toUtf8().data() + \"\\\"\";\n      QString newTag = QString::fromUtf8( ( addAudioLink( href, getId() ) + \"<span class=\\\"gls_wav\\\"><a href=\" + href + \">\" ).c_str() );\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n      newTag += match.captured( 4 );\n      if( match.captured( 4 ).indexOf( \"<img \" ) < 0 )\n        newTag += \" <img src=\\\"qrcx://localhost/icons/playsound.png\\\" border=\\\"0\\\" alt=\\\"Play\\\">\";\n      newTag += \"</a></span>\";\n\n      articleNewText += newTag;\n#else\n      newTag += audioRe.cap( 4 );\n      if( audioRe.cap( 4 ).indexOf( \"<img \" ) < 0 )\n        newTag += \" <img src=\\\"qrcx://localhost/icons/playsound.png\\\" border=\\\"0\\\" alt=\\\"Play\\\">\";\n      newTag += \"</a></span>\";\n\n      article.replace( pos, audioRe.cap( 0 ).length(), newTag );\n      pos += newTag.length();\n#endif\n    }\n  }\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  if( pos )\n  {\n    articleNewText += article.midRef( pos );\n    article = articleNewText;\n    articleNewText.clear();\n  }\n#endif\n\n  return article;\n}\n\nvoid GlsDictionary::getArticleText( uint32_t articleAddress, QString & headword, QString & text )\n{\n  try\n  {\n    vector< string > headwords;\n    string articleStr;\n    loadArticleText( articleAddress, headwords, articleStr );\n\n    if( !headwords.empty() )\n      headword = QString::fromUtf8( headwords.front().data(), headwords.front().size() );\n\n    wstring wstr = Utf8::decode( articleStr );\n\n    text = Html::unescape( gd::toQString( wstr ) );\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"Gls: Failed retrieving article from \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n  }\n}\n\n/// GlsDictionary::findHeadwordsForSynonym()\n\nclass GlsHeadwordsRequest;\n\nclass GlsHeadwordsRequestRunnable: public QRunnable\n{\n  GlsHeadwordsRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  GlsHeadwordsRequestRunnable( GlsHeadwordsRequest & r_,\n                               QSemaphore & hasExited_ ): r( r_ ),\n                                                          hasExited( hasExited_ )\n  {}\n\n  ~GlsHeadwordsRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass GlsHeadwordsRequest: public Dictionary::WordSearchRequest\n{\n  friend class GlsHeadwordsRequestRunnable;\n\n  wstring word;\n  GlsDictionary & dict;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  GlsHeadwordsRequest( wstring const & word_, GlsDictionary & dict_ ):\n    word( word_ ), dict( dict_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new GlsHeadwordsRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by StardictHeadwordsRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~GlsHeadwordsRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid GlsHeadwordsRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid GlsHeadwordsRequest::run()\n{\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  try\n  {\n    vector< WordArticleLink > chain = dict.findArticles( word );\n\n    wstring caseFolded = Folding::applySimpleCaseOnly( word );\n\n    for( unsigned x = 0; x < chain.size(); ++x )\n    {\n      if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      {\n        finish();\n        return;\n      }\n\n      string articleText;\n      vector< string > headwords;\n\n      dict.loadArticleText( chain[ x ].articleOffset,\n                            headwords, articleText );\n\n      wstring headwordDecoded = Utf8::decode( headwords.front() );\n\n      if ( caseFolded != Folding::applySimpleCaseOnly( headwordDecoded ) )\n      {\n        // The headword seems to differ from the input word, which makes the\n        // input word its synonym.\n        Mutex::Lock _( dataMutex );\n\n        matches.push_back( headwordDecoded );\n      }\n    }\n  }\n  catch( std::exception & e )\n  {\n    setErrorString( QString::fromUtf8( e.what() ) );\n  }\n\n  finish();\n}\n\nsptr< Dictionary::WordSearchRequest >\n  GlsDictionary::findHeadwordsForSynonym( wstring const & word )\n  THROW_SPEC( std::exception )\n{\n  return synonymSearchEnabled ? new GlsHeadwordsRequest( word, *this ) :\n                                Class::findHeadwordsForSynonym( word );\n}\n\n\n/// GlsDictionary::getArticle()\n\nclass GlsArticleRequest;\n\nclass GlsArticleRequestRunnable: public QRunnable\n{\n  GlsArticleRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  GlsArticleRequestRunnable( GlsArticleRequest & r_,\n                             QSemaphore & hasExited_ ): r( r_ ),\n                                                        hasExited( hasExited_ )\n  {}\n\n  ~GlsArticleRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass GlsArticleRequest: public Dictionary::DataRequest\n{\n  friend class GlsArticleRequestRunnable;\n\n  wstring word;\n  vector< wstring > alts;\n  GlsDictionary & dict;\n  bool ignoreDiacritics;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  GlsArticleRequest( wstring const & word_,\n                     vector< wstring > const & alts_,\n                     GlsDictionary & dict_, bool ignoreDiacritics_ ):\n    word( word_ ), alts( alts_ ), dict( dict_ ), ignoreDiacritics( ignoreDiacritics_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new GlsArticleRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by GlsArticleRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~GlsArticleRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid GlsArticleRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid GlsArticleRequest::run()\n{\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n  try\n  {\n    vector< WordArticleLink > chain = dict.findArticles( word, ignoreDiacritics );\n\n    for( unsigned x = 0; x < alts.size(); ++x )\n    {\n      /// Make an additional query for each alt\n\n      vector< WordArticleLink > altChain = dict.findArticles( alts[ x ], ignoreDiacritics );\n\n      chain.insert( chain.end(), altChain.begin(), altChain.end() );\n    }\n\n    multimap< wstring, pair< string, string > > mainArticles, alternateArticles;\n\n    set< uint32_t > articlesIncluded; // Some synonims make it that the articles\n                                      // appear several times. We combat this\n                                      // by only allowing them to appear once.\n\n    wstring wordCaseFolded = Folding::applySimpleCaseOnly( word );\n    if( ignoreDiacritics )\n      wordCaseFolded = Folding::applyDiacriticsOnly( wordCaseFolded );\n\n    for( unsigned x = 0; x < chain.size(); ++x )\n    {\n      if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      {\n        finish();\n        return;\n      }\n\n      if ( articlesIncluded.find( chain[ x ].articleOffset ) != articlesIncluded.end() )\n        continue; // We already have this article in the body.\n\n      // Now grab that article\n\n      string headword, articleText;\n\n      dict.loadArticle( chain[ x ].articleOffset, headword, articleText );\n\n      // Ok. Now, does it go to main articles, or to alternate ones? We list\n      // main ones first, and alternates after.\n\n      // We do the case-folded comparison here.\n\n      wstring headwordStripped =\n        Folding::applySimpleCaseOnly( Utf8::decode( headword ) );\n      if( ignoreDiacritics )\n        headwordStripped = Folding::applyDiacriticsOnly( headwordStripped );\n\n      multimap< wstring, pair< string, string > > & mapToUse =\n        ( wordCaseFolded == headwordStripped ) ?\n          mainArticles : alternateArticles;\n\n      mapToUse.insert( pair< wstring, pair< string, string > >(\n        Folding::applySimpleCaseOnly( Utf8::decode( headword ) ),\n        pair< string, string >( headword, articleText ) ) );\n\n      articlesIncluded.insert( chain[ x ].articleOffset );\n    }\n\n    if ( mainArticles.empty() && alternateArticles.empty() )\n    {\n      // No such word\n      finish();\n      return;\n    }\n\n    string result;\n\n    multimap< wstring, pair< string, string > >::const_iterator i;\n\n    for( i = mainArticles.begin(); i != mainArticles.end(); ++i )\n    {\n        result += i->second.second;\n    }\n\n    for( i = alternateArticles.begin(); i != alternateArticles.end(); ++i )\n    {\n        result += i->second.second;\n    }\n\n    Mutex::Lock _( dataMutex );\n\n    data.resize( result.size() );\n\n    memcpy( &data.front(), result.data(), result.size() );\n\n    hasAnyData = true;\n  }\n  catch( std::exception & e )\n  {\n    setErrorString( QString::fromUtf8( e.what() ) );\n  }\n\n  finish();\n}\n\nsptr< Dictionary::DataRequest > GlsDictionary::getArticle( wstring const & word,\n                                                           vector< wstring > const & alts,\n                                                           wstring const &,\n                                                           bool ignoreDiacritics )\n  THROW_SPEC( std::exception )\n{\n  return new GlsArticleRequest( word, alts, *this, ignoreDiacritics );\n}\n\n//////////////// GlsDictionary::getResource()\n\nclass GlsResourceRequest;\n\nclass GlsResourceRequestRunnable: public QRunnable\n{\n  GlsResourceRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  GlsResourceRequestRunnable( GlsResourceRequest & r_,\n                              QSemaphore & hasExited_ ): r( r_ ),\n                                                         hasExited( hasExited_ )\n  {}\n\n  ~GlsResourceRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass GlsResourceRequest: public Dictionary::DataRequest\n{\n  friend class GlsResourceRequestRunnable;\n\n  GlsDictionary & dict;\n\n  string resourceName;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  GlsResourceRequest( GlsDictionary & dict_,\n                      string const & resourceName_ ):\n    dict( dict_ ),\n    resourceName( resourceName_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new GlsResourceRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by GlsResourceRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~GlsResourceRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid GlsResourceRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid GlsResourceRequest::run()\n{\n  // Some runnables linger enough that they are cancelled before they start\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  try\n  {\n    string n =\n      FsEncoding::dirname( dict.getDictionaryFilenames()[ 0 ] ) +\n      FsEncoding::separator() +\n      FsEncoding::encode( resourceName );\n\n    GD_DPRINTF( \"n is %s\\n\", n.c_str() );\n\n    try\n    {\n      Mutex::Lock _( dataMutex );\n\n      File::loadFromFile( n, data );\n    }\n    catch( File::exCantOpen & )\n    {\n      n = dict.getDictionaryFilenames()[ 0 ] + \".files\" +\n          FsEncoding::separator() +\n          FsEncoding::encode( resourceName );\n\n      try\n      {\n        Mutex::Lock _( dataMutex );\n\n        File::loadFromFile( n, data );\n      }\n      catch( File::exCantOpen & )\n      {\n        // Try reading from zip file\n\n        if ( dict.resourceZip.isOpen() )\n        {\n          Mutex::Lock _( dict.resourceZipMutex );\n\n          Mutex::Lock __( dataMutex );\n\n          if ( !dict.resourceZip.loadFile( Utf8::decode( resourceName ), data ) )\n            throw; // Make it fail since we couldn't read the archive\n        }\n        else\n          throw;\n      }\n    }\n\n    if ( Filetype::isNameOfTiff( resourceName ) )\n    {\n      // Convert it\n\n      dataMutex.lock();\n\n      QImage img = QImage::fromData( (unsigned char *) &data.front(),\n                                     data.size() );\n\n#ifdef MAKE_EXTRA_TIFF_HANDLER\n      if( img.isNull() )\n        GdTiff::tiffToQImage( &data.front(), data.size(), img );\n#endif\n\n      dataMutex.unlock();\n\n      if ( !img.isNull() )\n      {\n        // Managed to load -- now store it back as BMP\n\n        QByteArray ba;\n        QBuffer buffer( &ba );\n        buffer.open( QIODevice::WriteOnly );\n        img.save( &buffer, \"BMP\" );\n\n        Mutex::Lock _( dataMutex );\n\n        data.resize( buffer.size() );\n\n        memcpy( &data.front(), buffer.data(), data.size() );\n      }\n    }\n\n    if( Filetype::isNameOfCSS( resourceName ) )\n    {\n      Mutex::Lock _( dataMutex );\n\n      QString css = QString::fromUtf8( data.data(), data.size() );\n\n      // Correct some url's\n\n      QString id = QString::fromUtf8( dict.getId().c_str() );\n      int pos = 0;\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n      QRegularExpression links( \"url\\\\(\\\\s*(['\\\"]?)([^'\\\"]*)(['\\\"]?)\\\\s*\\\\)\",\n                                QRegularExpression::CaseInsensitiveOption );\n\n      QString newCSS;\n      QRegularExpressionMatchIterator it = links.globalMatch( css );\n      while( it.hasNext() )\n      {\n        QRegularExpressionMatch match = it.next();\n        newCSS += css.midRef( pos, match.capturedStart() - pos );\n        pos = match.capturedEnd();\n\n        QString url = match.captured( 2 );\n\n        if( url.indexOf( \":/\" ) >= 0 || url.indexOf( \"data:\" ) >= 0)\n        {\n          // External link\n          newCSS += match.captured();\n          continue;\n        }\n\n        QString newUrl = QString( \"url(\" ) + match.captured( 1 ) + \"bres://\"\n                                           + id + \"/\" + url + match.captured( 3 ) + \")\";\n        newCSS += newUrl;\n      }\n      if( pos )\n      {\n        newCSS += css.midRef( pos );\n        css = newCSS;\n        newCSS.clear();\n      }\n#else\n      QRegExp links( \"url\\\\(\\\\s*(['\\\"]?)([^'\\\"]*)(['\\\"]?)\\\\s*\\\\)\", Qt::CaseInsensitive, QRegExp::RegExp );\n      for( ; ; )\n      {\n        pos = links.indexIn( css, pos );\n        if( pos < 0 )\n          break;\n        QString url = links.cap( 2 );\n\n        if( url.indexOf( \":/\" ) >= 0 || url.indexOf( \"data:\" ) >= 0)\n        {\n          // External link\n          pos += links.cap().size();\n          continue;\n        }\n\n        QString newUrl = QString( \"url(\" ) + links.cap( 1 ) + \"bres://\"\n                                           + id + \"/\" + url + links.cap( 3 ) + \")\";\n        css.replace( pos, links.cap().size(), newUrl );\n        pos += newUrl.size();\n      }\n#endif\n\n      dict.isolateCSS( css );\n      QByteArray bytes = css.toUtf8();\n      data.resize( bytes.size() );\n      memcpy( &data.front(), bytes.constData(), bytes.size() );\n    }\n\n    Mutex::Lock _( dataMutex );\n    hasAnyData = true;\n  }\n  catch( std::exception &ex )\n  {\n    gdCWarning( dictionaryResourceLc, \"GLS: Failed loading resource \\\"%s\\\" for \\\"%s\\\", reason: %s\\n\",\n                resourceName.c_str(), dict.getName().c_str(), ex.what() );\n    // Resource not loaded -- we don't set the hasAnyData flag then\n  }\n\n  finish();\n}\n\nsptr< Dictionary::DataRequest > GlsDictionary::getResource( string const & name )\n  THROW_SPEC( std::exception )\n{\n  return new GlsResourceRequest( *this, name );\n}\n\nsptr< Dictionary::DataRequest > GlsDictionary::getSearchResults( QString const & searchString,\n                                                                 int searchMode, bool matchCase,\n                                                                 int distanceBetweenWords,\n                                                                 int maxResults,\n                                                                 bool ignoreWordsOrder,\n                                                                 bool ignoreDiacritics,\n                                                                 QThreadPool * ftsThreadPoolPtr )\n{\n  return new FtsHelpers::FTSResultsRequest( *this, searchString,searchMode, matchCase, distanceBetweenWords, maxResults, ignoreWordsOrder, ignoreDiacritics, ftsThreadPoolPtr );\n}\n\n} // anonymous namespace\n\n/// makeDictionaries\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing & initializing )\n  THROW_SPEC( std::exception )\n{\n  vector< sptr< Dictionary::Class > > dictionaries;\n\n  for( vector< string >::const_iterator i = fileNames.begin(); i != fileNames.end();\n       ++i )\n  {\n    // Try .gls and .gls.dz suffixes\n\n    if( !( i->size() >= 4 && strcasecmp( i->c_str() + ( i->size() - 4 ), \".gls\" ) == 0 )\n        && !( i->size() >= 7 && strcasecmp( i->c_str() + ( i->size() - 7 ), \".gls.dz\" ) == 0 ) )\n      continue;\n\n    unsigned atLine = 0; // Indicates current line in .gls, for debug purposes\n\n    try\n    {\n      vector< string > dictFiles( 1, *i );\n\n      string dictId = Dictionary::makeDictionaryId( dictFiles );\n\n      // See if there's a zip file with resources present. If so, include it.\n\n      string baseName = ( (*i)[ i->size() - 4 ] == '.' ) ?\n               string( *i, 0, i->size() - 4 ) : string( *i, 0, i->size() - 7 );\n\n      string zipFileName;\n\n      if ( File::tryPossibleZipName( baseName + \".gls.files.zip\", zipFileName ) ||\n           File::tryPossibleZipName( baseName + \".gls.dz.files.zip\", zipFileName ) ||\n           File::tryPossibleZipName( baseName + \".GLS.FILES.ZIP\", zipFileName ) ||\n           File::tryPossibleZipName( baseName + \".GLS.DZ.FILES.ZIP\", zipFileName ) )\n        dictFiles.push_back( zipFileName );\n\n      string indexFile = indicesDir + dictId;\n\n      if ( Dictionary::needToRebuildIndex( dictFiles, indexFile ) ||\n           indexIsOldOrBad( indexFile, zipFileName.size() ) )\n      {\n        GlsScanner scanner( *i );\n\n        try { // Here we intercept any errors during the read to save line at\n              // which the incident happened. We need alive scanner for that.\n\n          // Building the index\n          initializing.indexingDictionary( Utf8::encode( scanner.getDictionaryName() ) );\n\n          gdDebug( \"Gls: Building the index for dictionary: %s\\n\",\n                   gd::toQString( scanner.getDictionaryName() ).toUtf8().data() );\n\n          File::Class idx( indexFile, \"wb\" );\n\n          IdxHeader idxHeader;\n\n          memset( &idxHeader, 0, sizeof( idxHeader ) );\n\n          // We write a dummy header first. At the end of the process the header\n          // will be rewritten with the right values.\n\n          idx.write( idxHeader );\n\n          string dictionaryName = Utf8::encode( scanner.getDictionaryName() );\n\n          idx.write( (uint32_t) dictionaryName.size() );\n          idx.write( dictionaryName.data(), dictionaryName.size() );\n\n          idxHeader.glsEncoding = scanner.getEncoding();\n\n          IndexedWords indexedWords;\n\n          ChunkedStorage::Writer chunks( idx );\n\n          wstring curString;\n          size_t curOffset;\n\n          uint32_t articleCount = 0, wordCount = 0;\n\n          for( ; ; )\n          {\n            // Find the headwords\n\n            if ( !scanner.readNextLine( curString, curOffset ) )\n              break; // Clean end of file\n\n            if( curString.empty() )\n              continue;\n\n            uint32_t articleOffset = curOffset;\n\n            // Parse headwords\n\n            list< wstring > allEntryWords;\n            wstring::size_type start_pos = 0, end_pos = 0;\n            for( ; ; )\n            {\n              end_pos = curString.find( '|', start_pos );\n              if( end_pos == wstring::npos )\n              {\n                wstring headword = curString.substr( start_pos );\n                if( !headword.empty() )\n                  allEntryWords.push_back( headword );\n                break;\n              }\n              allEntryWords.push_back( curString.substr( start_pos, end_pos - start_pos ) );\n              start_pos = end_pos + 1;\n            }\n\n            // Skip article body\n\n            for( ; ; )\n            {\n              if( !scanner.readNextLine( curString, curOffset ) )\n                break;\n              if( curString.empty() )\n                break;\n            }\n\n            // Insert new entry\n\n            uint32_t descOffset = chunks.startNewBlock();\n            chunks.addToBlock( &articleOffset, sizeof( articleOffset ) );\n\n            uint32_t articleSize = curOffset - articleOffset;\n            chunks.addToBlock( &articleSize, sizeof( articleSize ) );\n\n            for( list< wstring >::iterator j = allEntryWords.begin();\n                 j != allEntryWords.end(); ++j )\n              indexedWords.addWord( *j, descOffset );\n\n            ++articleCount;\n            wordCount += allEntryWords.size();\n          }\n\n          // Finish with the chunks\n\n          idxHeader.chunksOffset = chunks.finish();\n\n          // Build index\n\n          IndexInfo idxInfo = BtreeIndexing::buildIndex( indexedWords, idx );\n\n          idxHeader.indexBtreeMaxElements = idxInfo.btreeMaxElements;\n          idxHeader.indexRootOffset = idxInfo.rootOffset;\n\n          indexedWords.clear(); // Release memory -- no need for this data\n\n          // If there was a zip file, index it too\n\n          if ( zipFileName.size() )\n          {\n            GD_DPRINTF( \"Indexing zip file\\n\" );\n\n            idxHeader.hasZipFile = 1;\n\n            IndexedWords zipFileNames;\n            IndexedZip zipFile;\n            if( zipFile.openZipFile( QDir::fromNativeSeparators(\n                                     FsEncoding::decode( zipFileName.c_str() ) ) ) )\n                zipFile.indexFile( zipFileNames );\n\n            if( !zipFileNames.empty() )\n            {\n              // Build the resulting zip file index\n\n              IndexInfo idxInfo = BtreeIndexing::buildIndex( zipFileNames, idx );\n\n              idxHeader.zipIndexBtreeMaxElements = idxInfo.btreeMaxElements;\n              idxHeader.zipIndexRootOffset = idxInfo.rootOffset;\n            }\n            else\n            {\n              // Bad zip file -- no index (though the mark that we have one\n              // remains)\n              idxHeader.zipIndexBtreeMaxElements = 0;\n              idxHeader.zipIndexRootOffset = 0;\n            }\n          }\n          else\n            idxHeader.hasZipFile = 0;\n\n          // That concludes it. Update the header.\n\n          idxHeader.signature = Signature;\n          idxHeader.formatVersion = CurrentFormatVersion;\n          idxHeader.zipSupportVersion = CurrentZipSupportVersion;\n\n          idxHeader.articleCount = articleCount;\n          idxHeader.wordCount = wordCount;\n\n          idxHeader.langFrom = LangCoder::findIdForLanguage( scanner.getLangFrom() );\n          idxHeader.langTo = LangCoder::findIdForLanguage( scanner.getLangTo() );\n          if( idxHeader.langFrom == 0 && idxHeader.langTo == 0 )\n          {\n            // if no languages found, try dictionary's file name\n            QPair<quint32,quint32> langs =\n                LangCoder::findIdsForFilename( QString::fromStdString( dictFiles[ 0 ] ) );\n\n            // if no languages found, try dictionary's name\n            if ( langs.first == 0 || langs.second == 0 )\n            {\n              langs =\n                LangCoder::findIdsForFilename( QString::fromStdString( dictionaryName ) );\n            }\n            idxHeader.langFrom = langs.first;\n            idxHeader.langTo = langs.second;\n          }\n\n          idx.rewind();\n\n          idx.write( &idxHeader, sizeof( idxHeader ) );\n        } // In-place try for saving line count\n        catch( ... )\n        {\n          atLine = scanner.getLinesRead();\n          throw;\n        }\n\n      } // if need to rebuild\n      dictionaries.push_back( new GlsDictionary( dictId,\n                                                 indexFile,\n                                                 dictFiles ) );\n    }\n    catch( std::exception & e )\n    {\n      gdWarning( \"GLS dictionary reading failed: %s:%u, error: %s\\n\",\n                 i->c_str(), atLine, e.what() );\n    }\n  }\n\n  return dictionaries;\n}\n\n} // namespace Gls\n"
        },
        {
          "name": "gls.hh",
          "type": "blob",
          "size": 0.501953125,
          "content": "#ifndef __GLS_HH_INCLUDED__\n#define __GLS_HH_INCLUDED__\n\n#include \"dictionary.hh\"\n\n/// Support for the Dabilon source .GLS files.\nnamespace Gls {\n\nusing std::vector;\nusing std::string;\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing & )\n    THROW_SPEC( std::exception );\n\n}\n\n#endif // __GLS_HH_INCLUDED__\n"
        },
        {
          "name": "goldendict.pro",
          "type": "blob",
          "size": 16.4599609375,
          "content": "TEMPLATE = app\nTARGET = goldendict\nVERSION = 1.5.0+git\n\n# Generate version file. We do this here and in a build rule described later.\n# The build rule is required since qmake isn't run each time the project is\n# rebuilt; and doing it here is required too since any other way the RCC\n# compiler would complain if version.txt wouldn't exist (fresh checkouts).\n\nsystem(git describe --tags --always --dirty > version.txt): hasGit=1\n\nisEmpty( hasGit ) {\n  message(Failed to precisely describe the version via Git -- using the default version string)\n  system(echo $$VERSION > version.txt)\n}\n\n!CONFIG( verbose_build_output ) {\n  !win32|*-msvc* {\n    # Reduce build log verbosity except for MinGW builds (mingw-make cannot\n    # execute \"@echo ...\" commands inserted by qmake).\n    CONFIG += silent\n  }\n}\n\nCONFIG( release, debug|release ) {\n  DEFINES += NDEBUG NO_GD_DPRINTF\n}\n\n# DEPENDPATH += . generators\nINCLUDEPATH += .\n\nQT += core \\\n      gui \\\n      xml \\\n      network \\\n      svg\n\ngreaterThan(QT_MAJOR_VERSION, 4) {\n    QT += widgets \\\n          webkitwidgets \\\n          printsupport \\\n          help\n\n    # QMediaPlayer is not available in Qt4.\n    !CONFIG( no_qtmultimedia_player ) {\n      QT += multimedia\n      DEFINES += MAKE_QTMULTIMEDIA_PLAYER\n    }\n} else {\n    QT += webkit\n    CONFIG += help\n}\n\n!CONFIG( no_ffmpeg_player ) {\n  DEFINES += MAKE_FFMPEG_PLAYER\n}\n\nQT += sql\nCONFIG += exceptions \\\n    rtti \\\n    stl\nOBJECTS_DIR = build\nUI_DIR = build\nMOC_DIR = build\nRCC_DIR = build\nLIBS += \\\n        -lz \\\n        -lbz2 \\\n        -llzo2\n\nwin32 {\n    TARGET = GoldenDict\n\n    win32-msvc* {\n        VERSION = 1.5.0 # More complicated things cause errors during compilation under MSVC++\n        DEFINES += __WIN32 _CRT_SECURE_NO_WARNINGS\n        contains(QMAKE_TARGET.arch, x86_64) {\n            DEFINES += NOMINMAX __WIN64\n        }\n        LIBS += -L$${PWD}/winlibs/lib/msvc\n        QMAKE_CXXFLAGS += /wd4290 # silence the warning C4290: C++ exception specification ignored\n        QMAKE_LFLAGS_RELEASE += /OPT:REF /OPT:ICF\n        DEFINES += GD_NO_MANIFEST\n        # QMAKE_CXXFLAGS_RELEASE += /GL # slows down the linking significantly\n        LIBS += -lshell32 -luser32 -lsapi -lole32\n        Debug: LIBS+= -lhunspelld\n        Release: LIBS+= -lhunspell\n        HUNSPELL_LIB = hunspell\n    } else {\n        CONFIG(gcc48) {\n            x64 {\n                LIBS += -L$${PWD}/winlibs/lib64-48\n                QMAKE_CXXFLAGS += -m64\n                QMAKE_CFLAGS += -m64\n            } else {\n                LIBS += -L$${PWD}/winlibs/lib32-48\n            }\n        } else {\n            LIBS += -L$${PWD}/winlibs/lib\n        }\n        !x64:QMAKE_LFLAGS += -Wl,--large-address-aware\n\n        isEmpty(HUNSPELL_LIB) {\n          LIBS += -lhunspell-1.6.1\n        } else {\n          LIBS += -l$$HUNSPELL_LIB\n        }\n        QMAKE_CXXFLAGS += -Wextra -Wempty-body\n    }\n\n    LIBS += -liconv \\\n        -lwsock32 \\\n        -lpsapi \\\n        -lole32 \\\n        -loleaut32 \\\n        -ladvapi32 \\\n        -lcomdlg32\n    LIBS += -lvorbisfile \\\n        -lvorbis \\\n        -logg\n    !CONFIG( no_ffmpeg_player ) {\n        LIBS += -lao \\\n            -lswresample-gd \\\n            -lavutil-gd \\\n            -lavformat-gd \\\n            -lavcodec-gd\n    }\n\n\n    RC_FILE = goldendict.rc\n    INCLUDEPATH += winlibs/include\n\n    # Enable console in Debug mode on Windows, with useful logging messages\n    Debug:CONFIG += console\n\n    Release:DEFINES += NO_CONSOLE\n\n    gcc48:QMAKE_CXXFLAGS += -Wno-unused-local-typedefs\n\n    CONFIG += zim_support\n\n    !CONFIG( no_chinese_conversion_support ) {\n        CONFIG += chinese_conversion_support\n    }\n\n    greaterThan(QT_MAJOR_VERSION, 4) {\n      LIBS += -luxtheme\n    }\n}\n\nunix:!mac {\n  DEFINES += HAVE_X11\n  # This is to keep symbols for backtraces\n  QMAKE_CXXFLAGS += -rdynamic\n  QMAKE_LFLAGS += -rdynamic\n\n    greaterThan(QT_MAJOR_VERSION, 4) {\n      greaterThan(QT_MINOR_VERSION, 0) {\n        QT += x11extras\n      }\n    }\n\n    CONFIG += link_pkgconfig\n    PKGCONFIG += vorbisfile \\\n        vorbis \\\n        ogg \\\n        hunspell\n    !CONFIG( no_ffmpeg_player ) {\n        PKGCONFIG += ao \\\n            libavutil \\\n            libavformat \\\n            libavcodec \\\n            libswresample \\\n    }\n    arm {\n        LIBS += -liconv\n    } else {\n        LIBS += -lX11 -lXtst\n    }\n\n    # Install prefix: first try to use qmake's PREFIX variable,\n    # then $PREFIX from system environment, and if both fails,\n    # use the hardcoded /usr/local.\n    PREFIX = $${PREFIX}\n    isEmpty( PREFIX ):PREFIX = $$(PREFIX)\n    isEmpty( PREFIX ):PREFIX = /usr/local\n    message(Install Prefix is: $$PREFIX)\n\n    DEFINES += PROGRAM_DATA_DIR=\\\\\\\"$$PREFIX/share/goldendict/\\\\\\\"\n    target.path = $$PREFIX/bin/\n    locale.path = $$PREFIX/share/goldendict/locale/\n    locale.files = locale/*.qm\n    INSTALLS += target \\\n        locale\n    icons.path = $$PREFIX/share/pixmaps\n    icons.files = redist/icons/*.*\n    INSTALLS += icons\n    desktops.path = $$PREFIX/share/applications\n    desktops.files = redist/*.desktop\n    INSTALLS += desktops\n    metainfo.path = $$PREFIX/share/metainfo\n    metainfo.files = redist/*.metainfo.xml\n    INSTALLS += metainfo\n    helps.path = $$PREFIX/share/goldendict/help/\n    helps.files = help/*.qch\n    INSTALLS += helps\n}\nfreebsd {\n    LIBS += -liconv -lexecinfo\n}\nmac {\n    TARGET = GoldenDict\n    # Uncomment this line to make a universal binary.\n    # You will need to use Xcode 3 and Qt Carbon SDK\n    # if you want the support for PowerPC and/or Mac OS X 10.4\n    # CONFIG += x86 x86_64 ppc\n    LIBS = -lz \\\n        -lbz2 \\\n        -liconv \\\n        -lvorbisfile \\\n        -lvorbis \\\n        -logg \\\n        -lhunspell-1.6.1 \\\n        -llzo2\n    !CONFIG( no_ffmpeg_player ) {\n        LIBS += -lao \\\n            -lswresample-gd \\\n            -lavutil-gd \\\n            -lavformat-gd \\\n            -lavcodec-gd\n    }\n    INCLUDEPATH = $${PWD}/maclibs/include\n    LIBS += -L$${PWD}/maclibs/lib -framework AppKit -framework Carbon\n    OBJECTIVE_SOURCES += lionsupport.mm \\\n                         machotkeywrapper.mm \\\n                         macmouseover.mm \\\n                         speechclient_mac.mm\n    ICON = icons/macicon.icns\n    QMAKE_INFO_PLIST = myInfo.plist\n    QMAKE_POST_LINK = mkdir -p GoldenDict.app/Contents/Frameworks & \\\n                      cp -nR $${PWD}/maclibs/lib/ GoldenDict.app/Contents/Frameworks/ & \\\n                      mkdir -p GoldenDict.app/Contents/MacOS/locale & \\\n                      cp -R locale/*.qm GoldenDict.app/Contents/MacOS/locale/ & \\\n                      mkdir -p GoldenDict.app/Contents/MacOS/help & \\\n                      cp -R $${PWD}/help/*.qch GoldenDict.app/Contents/MacOS/help/\n\n    CONFIG += zim_support\n    !CONFIG( no_chinese_conversion_support ) {\n        CONFIG += chinese_conversion_support\n        CONFIG( x86 ) {\n            QMAKE_POST_LINK += & mkdir -p GoldenDict.app/Contents/MacOS/opencc & \\\n                                 cp -R $${PWD}/opencc/*.json GoldenDict.app/Contents/MacOS/opencc/ & \\\n                                 cp -R $${PWD}/opencc/*.ocd GoldenDict.app/Contents/MacOS/opencc/\n        } else {\n            QMAKE_POST_LINK += & mkdir -p GoldenDict.app/Contents/MacOS/opencc & \\\n                                 cp -R $${PWD}/opencc/x64/*.json GoldenDict.app/Contents/MacOS/opencc/ & \\\n                                 cp -R $${PWD}/opencc/x64/*.ocd GoldenDict.app/Contents/MacOS/opencc/\n        }\n    }\n}\nDEFINES += PROGRAM_VERSION=\\\\\\\"$$VERSION\\\\\\\"\n\n# Input\nHEADERS += folding.hh \\\n    inc_case_folding.hh \\\n    inc_diacritic_folding.hh \\\n    mainwindow.hh \\\n    sptr.hh \\\n    dictionary.hh \\\n    ex.hh \\\n    config.hh \\\n    sources.hh \\\n    utf8.hh \\\n    file.hh \\\n    bgl_babylon.hh \\\n    bgl.hh \\\n    initializing.hh \\\n    article_netmgr.hh \\\n    dictzip.h \\\n    btreeidx.hh \\\n    stardict.hh \\\n    chunkedstorage.hh \\\n    xdxf2html.hh \\\n    iconv.hh \\\n    lsa.hh \\\n    htmlescape.hh \\\n    dsl.hh \\\n    dsl_details.hh \\\n    filetype.hh \\\n    fsencoding.hh \\\n    groups.hh \\\n    groups_widgets.hh \\\n    instances.hh \\\n    article_maker.hh \\\n    scanpopup.hh \\\n    articleview.hh \\\n    audioplayerinterface.hh \\\n    audioplayerfactory.hh \\\n    ffmpegaudioplayer.hh \\\n    multimediaaudioplayer.hh \\\n    externalaudioplayer.hh \\\n    externalviewer.hh \\\n    wordfinder.hh \\\n    groupcombobox.hh \\\n    keyboardstate.hh \\\n    mouseover.hh \\\n    preferences.hh \\\n    mutex.hh \\\n    mediawiki.hh \\\n    sounddir.hh \\\n    hunspell.hh \\\n    dictdfiles.hh \\\n    audiolink.hh \\\n    wstring.hh \\\n    wstring_qt.hh \\\n    processwrapper.hh \\\n    hotkeywrapper.hh \\\n    searchpanewidget.hh \\\n    hotkeyedit.hh \\\n    langcoder.hh \\\n    editdictionaries.hh \\\n    loaddictionaries.hh \\\n    transliteration.hh \\\n    romaji.hh \\\n    belarusiantranslit.hh \\\n    russiantranslit.hh \\\n    german.hh \\\n    website.hh \\\n    orderandprops.hh \\\n    language.hh \\\n    dictionarybar.hh \\\n    broken_xrecord.hh \\\n    history.hh \\\n    atomic_rename.hh \\\n    articlewebview.hh \\\n    zipfile.hh \\\n    indexedzip.hh \\\n    termination.hh \\\n    greektranslit.hh \\\n    webmultimediadownload.hh \\\n    forvo.hh \\\n    country.hh \\\n    about.hh \\\n    programs.hh \\\n    parsecmdline.hh \\\n    dictspanewidget.hh \\\n    maintabwidget.hh \\\n    mainstatusbar.hh \\\n    gdappstyle.hh \\\n    ufile.hh \\\n    xdxf.hh \\\n    sdict.hh \\\n    decompress.hh \\\n    aard.hh \\\n    mruqmenu.hh \\\n    dictinfo.hh \\\n    zipsounds.hh \\\n    stylescombobox.hh \\\n    extlineedit.hh \\\n    translatebox.hh \\\n    historypanewidget.hh \\\n    wordlist.hh \\\n    mdictparser.hh \\\n    mdx.hh \\\n    voiceengines.hh \\\n    ffmpegaudio.hh \\\n    articleinspector.hh \\\n    delegate.hh \\\n    zim.hh \\\n    categorized_logging.hh \\\n    gddebug.hh \\\n    qt4x5.hh \\\n    gestures.hh \\\n    tiff.hh \\\n    dictheadwords.hh \\\n    fulltextsearch.hh \\\n    ftshelpers.hh \\\n    dictserver.hh \\\n    helpwindow.hh \\\n    slob.hh \\\n    ripemd.hh \\\n    gls.hh \\\n    splitfile.hh \\\n    favoritespanewidget.hh \\\n    cpp_features.hh \\\n    treeview.hh\n\nFORMS += groups.ui \\\n    dictgroupwidget.ui \\\n    mainwindow.ui \\\n    sources.ui \\\n    initializing.ui \\\n    scanpopup.ui \\\n    articleview.ui \\\n    preferences.ui \\\n    about.ui \\\n    editdictionaries.ui \\\n    orderandprops.ui \\\n    dictinfo.ui \\\n    dictheadwords.ui \\\n    authentication.ui \\\n    fulltextsearch.ui\n\nSOURCES += folding.cc \\\n    main.cc \\\n    dictionary.cc \\\n    config.cc \\\n    sources.cc \\\n    mainwindow.cc \\\n    utf8.cc \\\n    file.cc \\\n    bgl_babylon.cc \\\n    bgl.cc \\\n    initializing.cc \\\n    article_netmgr.cc \\\n    dictzip.c \\\n    btreeidx.cc \\\n    stardict.cc \\\n    chunkedstorage.cc \\\n    xdxf2html.cc \\\n    iconv.cc \\\n    lsa.cc \\\n    htmlescape.cc \\\n    dsl.cc \\\n    dsl_details.cc \\\n    filetype.cc \\\n    fsencoding.cc \\\n    groups.cc \\\n    groups_widgets.cc \\\n    instances.cc \\\n    article_maker.cc \\\n    scanpopup.cc \\\n    articleview.cc \\\n    audioplayerfactory.cc \\\n    multimediaaudioplayer.cc \\\n    externalaudioplayer.cc \\\n    externalviewer.cc \\\n    wordfinder.cc \\\n    groupcombobox.cc \\\n    keyboardstate.cc \\\n    mouseover.cc \\\n    preferences.cc \\\n    mutex.cc \\\n    mediawiki.cc \\\n    sounddir.cc \\\n    hunspell.cc \\\n    dictdfiles.cc \\\n    audiolink.cc \\\n    wstring.cc \\\n    wstring_qt.cc \\\n    processwrapper.cc \\\n    hotkeywrapper.cc \\\n    hotkeyedit.cc \\\n    langcoder.cc \\\n    editdictionaries.cc \\\n    loaddictionaries.cc \\\n    transliteration.cc \\\n    romaji.cc \\\n    belarusiantranslit.cc \\\n    russiantranslit.cc \\\n    german.cc \\\n    website.cc \\\n    orderandprops.cc \\\n    language.cc \\\n    dictionarybar.cc \\\n    broken_xrecord.cc \\\n    history.cc \\\n    atomic_rename.cc \\\n    articlewebview.cc \\\n    zipfile.cc \\\n    indexedzip.cc \\\n    termination.cc \\\n    greektranslit.cc \\\n    webmultimediadownload.cc \\\n    forvo.cc \\\n    country.cc \\\n    about.cc \\\n    programs.cc \\\n    parsecmdline.cc \\\n    maintabwidget.cc \\\n    mainstatusbar.cc \\\n    gdappstyle.cc \\\n    ufile.cc \\\n    xdxf.cc \\\n    sdict.cc \\\n    decompress.cc \\\n    aard.cc \\\n    mruqmenu.cc \\\n    dictinfo.cc \\\n    zipsounds.cc \\\n    stylescombobox.cc \\\n    extlineedit.cc \\\n    translatebox.cc \\\n    historypanewidget.cc \\\n    wordlist.cc \\\n    mdictparser.cc \\\n    mdx.cc \\\n    voiceengines.cc \\\n    ffmpegaudio.cc \\\n    articleinspector.cc \\\n    delegate.cc \\\n    zim.cc \\\n    gddebug.cc \\\n    gestures.cc \\\n    tiff.cc \\\n    dictheadwords.cc \\\n    fulltextsearch.cc \\\n    ftshelpers.cc \\\n    dictserver.cc \\\n    helpwindow.cc \\\n    slob.cc \\\n    ripemd.cc \\\n    gls.cc \\\n    splitfile.cc \\\n    favoritespanewidget.cc \\\n    treeview.cc\n\nwin32 {\n    FORMS   += texttospeechsource.ui\n    SOURCES += mouseover_win32/ThTypes.c \\\n               wordbyauto.cc \\\n               guids.c \\\n               x64.cc \\\n               speechclient_win.cc \\\n               texttospeechsource.cc \\\n               speechhlp.cc\n    HEADERS += mouseover_win32/ThTypes.h \\\n               wordbyauto.hh \\\n               uiauto.hh \\\n               x64.hh \\\n               texttospeechsource.hh \\\n               sapi.hh \\\n               sphelper.hh \\\n               speechclient.hh \\\n               speechhlp.hh \\\n               hotkeys.h\n}\n\nmac {\n    HEADERS += macmouseover.hh \\\n               texttospeechsource.hh \\\n               speechclient.hh\n    FORMS   += texttospeechsource.ui\n    SOURCES += texttospeechsource.cc\n}\n\nunix:!mac {\n    HEADERS += scanflag.hh\n    FORMS   += scanflag.ui\n    SOURCES += scanflag.cc\n}\n\ngreaterThan(QT_MAJOR_VERSION, 4) {\n    HEADERS += wildcard.hh\n    SOURCES += wildcard.cc\n}\n\nCONFIG( zim_support ) {\n  DEFINES += MAKE_ZIM_SUPPORT\n  LIBS += -llzma -lzstd\n}\n\n!CONFIG( no_extra_tiff_handler ) {\n  DEFINES += MAKE_EXTRA_TIFF_HANDLER\n  LIBS += -ltiff\n}\n\nCONFIG( no_epwing_support ) {\n  DEFINES += NO_EPWING_SUPPORT\n}\n\n!CONFIG( no_epwing_support ) {\n  HEADERS += epwing.hh \\\n             epwing_book.hh \\\n             epwing_charmap.hh\n  SOURCES += epwing.cc \\\n             epwing_book.cc \\\n             epwing_charmap.cc\n  LIBS += -leb\n}\n\nCONFIG( chinese_conversion_support ) {\n  DEFINES += MAKE_CHINESE_CONVERSION_SUPPORT\n  FORMS   += chineseconversion.ui\n  HEADERS += chinese.hh \\\n             chineseconversion.hh\n  SOURCES += chinese.cc \\\n             chineseconversion.cc\n  win32-msvc* {\n    Debug:   LIBS += -lopenccd\n    Release: LIBS += -lopencc\n  } else {\n    mac {\n      LIBS += -lopencc.2\n    } else {\n      LIBS += -lopencc\n    }\n  }\n}\n\nCONFIG( old_hunspell ) {\n  DEFINES += OLD_HUNSPELL_INTERFACE\n}\n\nRESOURCES += resources.qrc \\\n    flags.qrc\nTRANSLATIONS += locale/ru_RU.ts \\\n    locale/zh_CN.ts \\\n    locale/cs_CZ.ts \\\n    locale/de_DE.ts \\\n    locale/el_GR.ts \\\n    locale/hu_HU.ts \\\n    locale/bg_BG.ts \\\n    locale/ar_SA.ts \\\n    locale/lt_LT.ts \\\n    locale/uk_UA.ts \\\n    locale/vi_VN.ts \\\n    locale/it_IT.ts \\\n    locale/pl_PL.ts \\\n    locale/ja_JP.ts \\\n    locale/zh_TW.ts \\\n    locale/sq_AL.ts \\\n    locale/pt_BR.ts \\\n    locale/es_AR.ts \\\n    locale/es_BO.ts \\\n    locale/es_ES.ts \\\n    locale/ca_CT.ts \\\n    locale/sk_SK.ts \\\n    locale/tr_TR.ts \\\n    locale/qu_WI.ts \\\n    locale/tg_TJ.ts \\\n    locale/ay_WI.ts \\\n    locale/be_BY.ts \\\n    locale/be_BY@latin.ts \\\n    locale/fr_FR.ts \\\n    locale/ko_KR.ts \\\n    locale/nl_NL.ts \\\n    locale/sr_SR.ts \\\n    locale/sv_SE.ts \\\n    locale/tk_TM.ts \\\n    locale/fa_IR.ts \\\n    locale/mk_MK.ts \\\n    locale/eo_EO.ts \\\n    locale/fi_FI.ts \\\n    locale/jb_JB.ts \\\n    locale/hi_IN.ts \\\n    locale/ie_001.ts\n\n# Build version file\n!isEmpty( hasGit ) {\n  QMAKE_EXTRA_TARGETS += revtarget\n  PRE_TARGETDEPS      += $$PWD/version.txt\n  revtarget.target     = $$PWD/version.txt\n\n  !win32 {\n    revtarget.commands   = cd $$PWD; git describe --tags --always --dirty > $$revtarget.target\n  } else {\n    revtarget.commands   = git --git-dir=\\\"$$PWD/.git\\\" describe --tags --always --dirty > $$revtarget.target\n  }\n\n  ALL_SOURCES = $$SOURCES $$HEADERS $$FORMS\n  for(src, ALL_SOURCES) {\n    QUALIFIED_SOURCES += $${PWD}/$${src}\n  }\n  revtarget.depends = $$QUALIFIED_SOURCES\n}\n\n# This makes qmake generate translations\n\nwin32:# Windows doesn't seem to have *-qt4 symlinks\nisEmpty(QMAKE_LRELEASE):QMAKE_LRELEASE = $$[QT_INSTALL_BINS]/lrelease\nisEmpty(QMAKE_LRELEASE):QMAKE_LRELEASE = $$[QT_INSTALL_BINS]/lrelease-qt4\n\n# The *.qm files might not exist when qmake is run for the first time,\n# causing the standard install rule to be ignored, and no translations\n# will be installed. With this, we create the qm files during qmake run.\n!win32 {\n  system($${QMAKE_LRELEASE} -silent $${_PRO_FILE_} 2> /dev/null)\n}\n\nupdateqm.input = TRANSLATIONS\nupdateqm.output = locale/${QMAKE_FILE_BASE}.qm\nupdateqm.commands = $$QMAKE_LRELEASE \\\n    ${QMAKE_FILE_IN} \\\n    -qm \\\n    ${QMAKE_FILE_OUT}\nupdateqm.CONFIG += no_link\nQMAKE_EXTRA_COMPILERS += updateqm\nTS_OUT = $$TRANSLATIONS\nTS_OUT ~= s/.ts/.qm/g\nPRE_TARGETDEPS += $$TS_OUT\n\ninclude( qtsingleapplication/src/qtsingleapplication.pri )\n\n"
        },
        {
          "name": "goldendict.rc",
          "type": "blob",
          "size": 0.9931640625,
          "content": "#include \"windows.h\"\n\nIDI_ICON1 ICON DISCARDABLE \"icons/programicon.ico\"\nIDI_ICON2 ICON DISCARDABLE \"icons/programicon_old.ico\"\n#define GOLDENDICT_VER 1,5,0,0\n#define GOLDENDICT_VER_STR \"1.5.0\"\n\n#if !defined( _MSC_VER ) && !defined( GD_NO_MANIFEST ) // Visual Studio embeds the manifest automatically\n1 RT_MANIFEST GoldenDict.exe.manifest\n#endif\n\n1 VERSIONINFO\n FILEVERSION GOLDENDICT_VER\n PRODUCTVERSION GOLDENDICT_VER\n FILEFLAGS 0x0L\n FILEFLAGSMASK 0x3fL\n FILEOS 0x00040004L\n FILETYPE 0x1L\n FILESUBTYPE 0x0L\nBEGIN\n\tBLOCK \"StringFileInfo\"\n\tBEGIN\n\t\tBLOCK \"000004b0\"\n\t\tBEGIN\n\t\t\tVALUE \"CompanyName\", \"GoldenDict\"\n\t\t\tVALUE \"FileDescription\", \"GoldenDict dictionary lookup program\"\n\t\t\tVALUE \"FileVersion\", GOLDENDICT_VER_STR\n\t\t\tVALUE \"LegalCopyright\", \"www.goldendict.org\"\n\t\t\tVALUE \"InternalName\", \"goldendict\"\n\t\t\tVALUE \"OriginalFilename\", \"goldendict.exe\"\n\t\t\tVALUE \"ProductName\", \"GoldenDict\"\n\t\t\tVALUE \"ProductVersion\", GOLDENDICT_VER_STR\n\t\tEND\n\tEND\n\tBLOCK \"VarFileInfo\"\n\tBEGIN\n\t\tVALUE \"Translation\", 0x0, 1200\n\tEND\nEND\n"
        },
        {
          "name": "greektranslit.cc",
          "type": "blob",
          "size": 18.630859375,
          "content": "/* This file is (c) 2010 Jennie Petoumenou <epetoumenou@gmail.com>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"greektranslit.hh\"\n#include \"transliteration.hh\"\n#include <QCoreApplication>\n\nnamespace GreekTranslit {\n\nclass GreekTable: public Transliteration::Table\n{\npublic:\n\n  GreekTable();\n};\n\nGreekTable::GreekTable()\n{\n  // Utf8\n\n    //I. LATIN -> MODERN & CLASSICAL GREEK (COMMON CHARACTERS)\n    ins(\"a\",      \"α\");\n    ins(\"b\",      \"β\");\n    ins(\"v\",      \"β\");\n    ins(\"g\",      \"γ\");\n    ins(\"d\",      \"δ\");\n    ins(\"e\",      \"ε\");\n    ins(\"z\",      \"ζ\");\n    ins(\"h\",      \"η\");\n    ins(\"q\",      \"θ\");\n    ins(\"8\",      \"θ\");\n    ins(\"i\",      \"ι\");\n    ins(\"k\",      \"κ\");\n    ins(\"l\",      \"λ\");\n    ins(\"m\",      \"μ\");\n    ins(\"n\",      \"ν\");\n    ins(\"c\",      \"ξ\");\n    ins(\"3\",      \"ξ\");\n    ins(\"ks\",     \"ξ\");\n    ins(\"o\",      \"ο\");\n    ins(\"p\",      \"π\");\n    ins(\"r\",      \"ρ\");\n    ins(\"s\",      \"σ\");\n    ins(\"s1\",     \"σ\");\n    ins(\"j\",      \"ς\");\n    ins(\"s2\",     \"ς\");\n    ins(\"s\\\\n\",   \"ς\");\n    ins(\"t\",      \"τ\");\n    ins(\"u\",      \"υ\");\n    ins(\"f\",      \"φ\");\n    ins(\"x\",      \"χ\");\n    ins(\"y\",      \"ψ\");\n    ins(\"ps\",     \"ψ\");\n    ins(\"w\",      \"ω\");\n\n    ins(\"A\",      \"Α\");\n    ins(\"B\",      \"Β\");\n    ins(\"V\",      \"Β\");\n    ins(\"G\",      \"Γ\");\n    ins(\"D\",      \"Δ\");\n    ins(\"E\",      \"Ε\");\n    ins(\"Z\",      \"Ζ\");\n    ins(\"H\",      \"Η\");\n    ins(\"Q\",      \"Θ\");\n    ins(\"I\",      \"Ι\");\n    ins(\"K\",      \"Κ\");\n    ins(\"L\",      \"Λ\");\n    ins(\"M\",      \"Μ\");\n    ins(\"N\",      \"Ν\");\n    ins(\"C\",      \"Ξ\");\n    ins(\"KS\",     \"Ξ\");\n    ins(\"Ks\",     \"Ξ\");\n    ins(\"O\",      \"Ο\");\n    ins(\"P\",      \"Π\");\n    ins(\"R\",      \"Τ\");\n    ins(\"S\",      \"Σ\");\n    ins(\"S1\",     \"Σ\");\n    ins(\"J\",      \"Σ\");\n    ins(\"S2\",     \"Σ\");\n    ins(\"S\\\\n\",   \"Σ\");\n    ins(\"T\",      \"Τ\");\n    ins(\"U\",      \"Υ\");\n    ins(\"F\",      \"Φ\");\n    ins(\"X\",      \"Χ\");\n    ins(\"Y\",      \"Ψ\");\n    ins(\"PS\",     \"Ψ\");\n    ins(\"Ps\",     \"Ψ\");\n    ins(\"W\",      \"Ω\");\n\n    //II. LATIN -> MODERN GREEK (DIACRITICS)\n    \n    ins(\"'a\",      \"ά\");\n    ins(\"'e\",      \"έ\");\n    ins(\"'h\",      \"ή\");\n    ins(\"'i\",      \"ί\");\n    ins(\"\\\"i\",     \"ϊ\");\n    ins(\"\\\"'i\",    \"ΐ\");\n    ins(\"'\\\"i\",    \"ΐ\");\n    ins(\"'o\",      \"ό\");\n    ins(\"'u\",      \"ύ\");\n    ins(\"\\\"u\",     \"ϋ\");\n    ins(\"\\\"'u\",    \"ΰ\");\n    ins(\"'\\\"u\",    \"ΰ\");\n    ins(\"'w\",      \"ώ\");\n\n    ins(\"'A\",      \"Ά\");\n    ins(\"'E\",      \"Έ\");\n    ins(\"'H\",      \"Ή\");\n    ins(\"'I\",      \"Ί\");\n    ins(\"\\\"I\",     \"Ϊ\");\n    ins(\"'O\",      \"Ό\");\n    ins(\"'U\",      \"Ύ\");\n    ins(\"\\\"U\",     \"Ϋ\");\n    ins(\"'W\",      \"Ώ\");\n\n    //IV. LATIN -> CLASSICAL GREEK (DIACRITICS - BETA CODE)\n    // Adapted from beta2unicode.py by James Tauber <http://jtauber.com/>\n\n\t//ORDER: Breathing - Accent\n\t\n    //uppercase (asterisk & capitals)\n    \n\t\t//oceia - bareia\n    ins(\"*)A\",     \"Ἀ\");\n    ins(\"*(A\",     \"Ἁ\");\n    ins(\"*\\\\A\",     \"Ὰ\");\n    ins(\"*/A\",      \"Ά\");\n    ins(\"*)\\\\A\",   \"Ἂ\");\n    ins(\"*(\\\\A\",   \"Ἃ\");\n    ins(\"*)/A\",    \"Ἄ\");\n    ins(\"*(/A\",    \"Ἅ\");\n\n    ins(\"*)E\",     \"Ἐ\");\n    ins(\"*(E\",     \"Ἑ\");\n    ins(\"*\\\\E\",     \"Ὲ\");\n    ins(\"*/E\",      \"Έ\");\n    ins(\"*)\\\\E\",   \"Ἒ\");\n    ins(\"*(\\\\E\",   \"Ἓ\");\n    ins(\"*)/E\",    \"Ἔ\");\n    ins(\"*(/E\",    \"Ἕ\");\n\n    ins(\"*)H\",     \"Ἠ\");\n    ins(\"*(H\",     \"Ἡ\");\n    ins(\"*\\\\H\",     \"Ὴ\");\n    ins(\"*/H\",      \"Ή\");\n    ins(\"*)\\\\H\",   \"Ἢ\");\n    ins(\"*(\\\\H\",   \"Ἣ\");\n    ins(\"*)/H\",    \"Ἤ\");\n    ins(\"*(/H\",    \"Ἥ\");\n\n    ins(\"*)I\",     \"Ἰ\");\n    ins(\"*(I\",     \"Ἱ\");\n    ins(\"*\\\\I\",     \"Ὶ\");\n    ins(\"*/I\",      \"Ί\");\n    ins(\"*)\\\\I\",   \"Ἲ\");\n    ins(\"*(\\\\I\",   \"Ἳ\");\n    ins(\"*)/I\",    \"Ἴ\");\n    ins(\"*(/I\",    \"Ἵ\");\n\n    ins(\"*)O\",     \"Ὀ\");\n    ins(\"*(O\",     \"Ὁ\");\n    ins(\"*\\\\O\",     \"Ὸ\");\n    ins(\"*/O\",      \"Ό\");\n    ins(\"*)\\\\O\",   \"Ὂ\");\n    ins(\"*(\\\\O\",   \"Ὃ\");\n    ins(\"*)/O\",    \"Ὄ\");\n    ins(\"*(/O\",    \"Ὅ\");\n\n    ins(\"*(R\",    \"Ῥ\");\t\n\n    ins(\"*(U\",     \"Ὑ\");\n    ins(\"*\\\\U\",     \"Ὺ\");\n    ins(\"*/U\",      \"Ύ\");\n    ins(\"*(\\\\U\",   \"Ὓ\");\n    ins(\"*(/U\",    \"Ὕ\");\n\n    ins(\"*)W\",     \"Ὠ\");\n    ins(\"*(W\",     \"Ὡ\");\n    ins(\"*\\\\W\",     \"Ὼ\");\n    ins(\"*/W\",      \"Ώ\");\n    ins(\"*)\\\\W\",   \"Ὢ\");\n    ins(\"*(\\\\W\",   \"Ὣ\");\n    ins(\"*)/W\",    \"Ὤ\");\n    ins(\"*(/W\",    \"Ὥ\");\n\n\t\t//perispwmenh\n    ins(\"*)=A\",    \"Ἆ\");\n    ins(\"*(=A\",    \"Ἇ\");\n    \n    ins(\"*)=H\",    \"Ἦ\");\n    ins(\"*(=H\",    \"Ἧ\");\n    \n    ins(\"*)=I\",    \"Ἶ\");\n    ins(\"*(=I\",    \"Ἷ\");\n    \n    ins(\"*(=U\",    \"Ὗ\");\n    \n    ins(\"*)=W\",    \"Ὦ\");\n    ins(\"*(=W\",    \"Ὧ\");\n\n\t\t//upogegrammenh\n    ins(\"*A|\",      \"ᾼ\");\n    ins(\"*)A|\",    \"ᾈ\");\n    ins(\"*(A|\",    \"ᾉ\");\n    ins(\"*)/A|\",   \"ᾌ\");\n    ins(\"*(/A|\",   \"ᾍ\");\n    ins(\"*)=A|\",   \"ᾎ\");\n    ins(\"*(=A|\",   \"ᾏ\");\n\n    ins(\"*H|\",      \"ῌ\");\n    ins(\"*)H|\",    \"ᾘ\");\n    ins(\"*(H|\",    \"ᾙ\");\n    ins(\"*)/H|\",   \"ᾜ\");\n    ins(\"*(/H|\",   \"ᾝ\");\n    ins(\"*)=H|\",   \"ᾞ\");\n    ins(\"*(=H|\",   \"ᾟ\");\n\n    ins(\"*W|\",      \"ῼ\"); \n    ins(\"*)W|\",    \"ᾨ\");\n    ins(\"*(W|\",    \"ᾩ\");\n    ins(\"*)/W|\",   \"ᾬ\");\n    ins(\"*(/W|\",   \"ᾭ\");\n    ins(\"*)=W|\",   \"ᾮ\");\n    ins(\"*(=W|\",   \"ᾯ\");\n\n    ins(\"*|A\",      \"ᾼ\");\n    ins(\"*)|A\",    \"ᾈ\");\n    ins(\"*(|A\",    \"ᾉ\");\n    ins(\"*)/|A\",   \"ᾌ\");\n    ins(\"*(/|A\",   \"ᾍ\");\n    ins(\"*)=|A\",   \"ᾎ\");\n    ins(\"*(=|A\",   \"ᾏ\");\n\n    ins(\"*|H\",      \"ῌ\");\n    ins(\"*)|H\",    \"ᾘ\");\n    ins(\"*(|H\",    \"ᾙ\");\n    ins(\"*)/|H\",   \"ᾜ\");\n    ins(\"*(/|H\",   \"ᾝ\");\n    ins(\"*)=|H\",   \"ᾞ\");\n    ins(\"*(=|H\",   \"ᾟ\");\n\n    ins(\"*|W\",      \"ῼ\"); \n    ins(\"*)|W\",    \"ᾨ\");\n    ins(\"*(|W\",    \"ᾩ\");\n    ins(\"*)/|W\",   \"ᾬ\");\n    ins(\"*(/|W\",   \"ᾭ\");\n    ins(\"*)=|W\",   \"ᾮ\");\n    ins(\"*(=|W\",   \"ᾯ\");\n\n\t\t//diairesis\n    ins(\"*+I\",      \"Ϊ\");\n    ins(\"*+U\",      \"Ϋ\");\n    \n    //uppercase (asterisk & small letters)\n    \n\t\t//oceia - bareia\n    ins(\"*)a\",     \"Ἀ\");\n    ins(\"*(a\",     \"Ἁ\");\n    ins(\"*\\\\a\",     \"Ὰ\");\n    ins(\"*/a\",      \"Ά\");\n    ins(\"*)\\\\a\",   \"Ἂ\");\n    ins(\"*(\\\\a\",   \"Ἃ\");\n    ins(\"*)/a\",    \"Ἄ\");\n    ins(\"*(/a\",    \"Ἅ\");\n\n    ins(\"*)e\",     \"Ἐ\");\n    ins(\"*(e\",     \"Ἑ\");\n    ins(\"*\\\\e\",     \"Ὲ\");\n    ins(\"*/e\",      \"Έ\");\n    ins(\"*)\\\\e\",   \"Ἒ\");\n    ins(\"*(\\\\e\",   \"Ἓ\");\n    ins(\"*)/e\",    \"Ἔ\");\n    ins(\"*(/e\",    \"Ἕ\");\n\n    ins(\"*)h\",     \"Ἠ\");\n    ins(\"*(h\",     \"Ἡ\");\n    ins(\"*\\\\h\",     \"Ὴ\");\n    ins(\"*/h\",      \"Ή\");\n    ins(\"*)\\\\h\",   \"Ἢ\");\n    ins(\"*(\\\\h\",   \"Ἣ\");\n    ins(\"*)/h\",    \"Ἤ\");\n    ins(\"*(/h\",    \"Ἥ\");\n\n    ins(\"*)i\",     \"Ἰ\");\n    ins(\"*(i\",     \"Ἱ\");\n    ins(\"*\\\\i\",     \"Ὶ\");\n    ins(\"*/i\",      \"Ί\");\n    ins(\"*)\\\\i\",   \"Ἲ\");\n    ins(\"*(\\\\i\",   \"Ἳ\");\n    ins(\"*)/i\",    \"Ἴ\");\n    ins(\"*(/i\",    \"Ἵ\");\n\n    ins(\"*)o\",     \"Ὀ\");\n    ins(\"*(o\",     \"Ὁ\");\n    ins(\"*\\\\o\",     \"Ὸ\");\n    ins(\"*/o\",      \"Ό\");\n    ins(\"*)\\\\o\",   \"Ὂ\");\n    ins(\"*(\\\\o\",   \"Ὃ\");\n    ins(\"*)/o\",    \"Ὄ\");\n    ins(\"*(/o\",    \"Ὅ\");\n\n    ins(\"*(r\",     \"Ῥ\");\t\n\n    ins(\"*(u\",     \"Ὑ\");\n    ins(\"*\\\\u\",     \"Ὺ\");\n    ins(\"*/u\",      \"Ύ\");\n    ins(\"*(\\\\u\",   \"Ὓ\");\n    ins(\"*(/u\",    \"Ὕ\");\n\n    ins(\"*)w\",     \"Ὠ\");\n    ins(\"*(w\",     \"Ὡ\");\n    ins(\"*\\\\w\",     \"Ὼ\");\n    ins(\"*/w\",      \"Ώ\");\n    ins(\"*)\\\\w\",   \"Ὢ\");\n    ins(\"*(\\\\w\",   \"Ὣ\");\n    ins(\"*)/w\",    \"Ὤ\");\n    ins(\"*(/w\",    \"Ὥ\");\n\n\t\t//perispwmenh\n    ins(\"*)=a\",    \"Ἆ\");\n    ins(\"*(=a\",    \"Ἇ\");\n    \n    ins(\"*)=h\",    \"Ἦ\");\n    ins(\"*(=h\",    \"Ἧ\");\n    \n    ins(\"*)=i\",    \"Ἶ\");\n    ins(\"*(=i\",    \"Ἷ\");\n    \n    ins(\"*(=u\",    \"Ὗ\");\n    \n    ins(\"*)=w\",    \"Ὦ\");\n    ins(\"*(=w\",    \"Ὧ\");\n\n\t\t//upogegrammenh\n    ins(\"*a|\",      \"ᾼ\");\n    ins(\"*)a|\",    \"ᾈ\");\n    ins(\"*(a|\",    \"ᾉ\");\n    ins(\"*)/a|\",   \"ᾌ\");\n    ins(\"*(/a|\",   \"ᾍ\");\n    ins(\"*)=a|\",   \"ᾎ\");\n    ins(\"*(=a|\",   \"ᾏ\");\n\n    ins(\"*h|\",      \"ῌ\");\n    ins(\"*)h|\",    \"ᾘ\");\n    ins(\"*(h|\",    \"ᾙ\");\n    ins(\"*)/h|\",   \"ᾜ\");\n    ins(\"*(/h|\",   \"ᾝ\");\n    ins(\"*)=h|\",   \"ᾞ\");\n    ins(\"*(=h|\",   \"ᾟ\");\n\n    ins(\"*w|\",      \"ῼ\"); \n    ins(\"*)w|\",    \"ᾨ\");\n    ins(\"*(w|\",    \"ᾩ\");\n    ins(\"*)/w|\",   \"ᾬ\");\n    ins(\"*(/w|\",   \"ᾭ\");\n    ins(\"*)=w|\",   \"ᾮ\");\n    ins(\"*(=w|\",   \"ᾯ\");\n\n    ins(\"*|a\",      \"ᾼ\");\n    ins(\"*)|a\",    \"ᾈ\");\n    ins(\"*(|a\",    \"ᾉ\");\n    ins(\"*)/|a\",   \"ᾌ\");\n    ins(\"*(/|a\",   \"ᾍ\");\n    ins(\"*)=|a\",   \"ᾎ\");\n    ins(\"*(=|a\",   \"ᾏ\");\n\n    ins(\"*|h\",      \"ῌ\");\n    ins(\"*)|h\",    \"ᾘ\");\n    ins(\"*(|h\",    \"ᾙ\");\n    ins(\"*)/|h\",   \"ᾜ\");\n    ins(\"*(/|h\",   \"ᾝ\");\n    ins(\"*)=|h\",   \"ᾞ\");\n    ins(\"*(=|h\",   \"ᾟ\");\n\n    ins(\"*|w\",      \"ῼ\"); \n    ins(\"*)|w\",    \"ᾨ\");\n    ins(\"*(|w\",    \"ᾩ\");\n    ins(\"*)/|w\",   \"ᾬ\");\n    ins(\"*(/|w\",   \"ᾭ\");\n    ins(\"*)=|w\",   \"ᾮ\");\n    ins(\"*(=|w\",   \"ᾯ\");\n\n\t\t//diairesis\n    ins(\"*+i\",      \"Ϊ\");\n    ins(\"*+u\",      \"Ϋ\");\n    \n    //uppercase (capitals)\n    \n\t\t//oceia - bareia\n    ins(\"A)\",     \"Ἀ\");\n    ins(\"A(\",     \"Ἁ\");\n    ins(\"A\\\\\",     \"Ὰ\");\n    ins(\"A/\",      \"Ά\");\n    ins(\"A)\\\\\",   \"Ἂ\");\n    ins(\"A(\\\\\",   \"Ἃ\");\n    ins(\"A)/\",    \"Ἄ\");\n    ins(\"A(/\",    \"Ἅ\");\n\n    ins(\"E)\",     \"Ἐ\");\n    ins(\"E(\",     \"Ἑ\");\n    ins(\"E\\\\\",     \"Ὲ\");\n    ins(\"E/\",      \"Έ\");\n    ins(\"E)\\\\\",   \"Ἒ\");\n    ins(\"E(\\\\\",   \"Ἓ\");\n    ins(\"E)/\",    \"Ἔ\");\n    ins(\"E(/\",    \"Ἕ\");\n\n    ins(\"H)\",     \"Ἠ\");\n    ins(\"H(\",     \"Ἡ\");\n    ins(\"H\\\\\",     \"Ὴ\");\n    ins(\"H/\",      \"Ή\");\n    ins(\"H)\\\\\",   \"Ἢ\");\n    ins(\"H(\\\\\",   \"Ἣ\");\n    ins(\"H)/\",    \"Ἤ\");\n    ins(\"H(/\",    \"Ἥ\");\n\n    ins(\"I)\",     \"Ἰ\");\n    ins(\"I(\",     \"Ἱ\");\n    ins(\"I\\\\\",     \"Ὶ\");\n    ins(\"I/\",      \"Ί\");\n    ins(\"I)\\\\\",   \"Ἲ\");\n    ins(\"I(\\\\\",   \"Ἳ\");\n    ins(\"I)/\",    \"Ἴ\");\n    ins(\"I(/\",    \"Ἵ\");\n\n    ins(\"O)\",     \"Ὀ\");\n    ins(\"O(\",     \"Ὁ\");\n    ins(\"O\\\\\",     \"Ὸ\");\n    ins(\"O/\",      \"Ό\");\n    ins(\"O)\\\\\",   \"Ὂ\");\n    ins(\"O(\\\\\",   \"Ὃ\");\n    ins(\"O)/\",    \"Ὄ\");\n    ins(\"O(/\",    \"Ὅ\");\n\n    ins(\"R(\",     \"Ῥ\");\n\n    ins(\"U)\",     \"ὐ\");\n    ins(\"U(\",     \"Ὑ\");\n    ins(\"U\\\\\",     \"Ὺ\");\n    ins(\"U/\",      \"Ύ\");\n    ins(\"U)\\\\\",   \"ὒ\");\n    ins(\"U(\\\\\",   \"Ὓ\");\n    ins(\"U)/\",    \"ὔ\");\n    ins(\"U(/\",    \"Ὕ\");\n\n    ins(\"W)\",     \"Ὠ\");\n    ins(\"W(\",     \"Ὡ\");\n    ins(\"W\\\\\",     \"Ὼ\");\n    ins(\"W/\",      \"Ώ\");\n    ins(\"W)\\\\\",   \"Ὢ\");\n    ins(\"W(\\\\\",   \"Ὣ\");\n    ins(\"W)/\",    \"Ὤ\");\n    ins(\"W(/\",    \"Ὥ\");\n\n\t\t//perispwmenh\n    ins(\"A=\",      \"ᾶ\");\n    ins(\"A)=\",    \"Ἆ\");\n    ins(\"A(=\",    \"Ἇ\");\n    \n    ins(\"H=\",      \"ῆ\");\n    ins(\"H)=\",    \"Ἦ\");\n    ins(\"H(=\",    \"Ἧ\");\n    \n    ins(\"I=\",      \"ῖ\");\n    ins(\"I)=\",    \"Ἶ\");\n    ins(\"I(=\",    \"Ἷ\");\n    \n    ins(\"U=\",      \"ῦ\");\n    ins(\"U)=\",    \"ὖ\");\n    ins(\"U(=\",    \"Ὗ\");\n    \n    ins(\"W=\",      \"ῶ\");\n    ins(\"W)=\",    \"Ὦ\");\n    ins(\"W(=\",    \"Ὧ\");\n\n\t\t//upogegrammenh\n    ins(\"A|\",      \"ᾼ\");\n    ins(\"A)|\",    \"ᾈ\");\n    ins(\"A(|\",    \"ᾉ\");\n    ins(\"A/|\",     \"ᾴ\");\n    ins(\"A)/|\",   \"ᾌ\");\n    ins(\"A(/|\",   \"ᾍ\");\n    ins(\"A=|\",     \"ᾷ\");\n    ins(\"A)=|\",   \"ᾎ\");\n    ins(\"A(=|\",   \"ᾏ\");\n\n    ins(\"H|\",      \"ῌ\");\n    ins(\"H)|\",    \"ᾘ\");\n    ins(\"H(|\",    \"ᾙ\");\n    ins(\"H/|\",     \"ῄ\");\n    ins(\"H)/|\",   \"ᾜ\");\n    ins(\"H(/|\",   \"ᾝ\");\n    ins(\"H=|\",     \"ῇ\");\n    ins(\"H)=|\",   \"ᾞ\");\n    ins(\"H(=|\",   \"ᾟ\");\n\n    ins(\"W|\",      \"ῼ\"); \n    ins(\"W)|\",    \"ᾨ\");\n    ins(\"W(|\",    \"ᾩ\");\n    ins(\"W/|\",     \"ῴ\");\n    ins(\"W)/|\",   \"ᾬ\");\n    ins(\"W(/|\",   \"ᾭ\");\n    ins(\"W=|\",     \"ῷ\");\n    ins(\"W)=|\",   \"ᾮ\");\n    ins(\"W(=|\",   \"ᾯ\");\n\n\t\t//diairesis\n    ins(\"I+\",      \"Ϊ\");\n    ins(\"I+\\\\\",    \"ῒ\");\n    ins(\"I+/\",     \"ΐ\");\n    ins(\"U+\",      \"Ϋ\");\n    ins(\"U+\\\\\",    \"ῢ\");\n    ins(\"U+/\",     \"ΰ\");    \n\n    //lowercase (small letters)\n    \n\t\t//oceia - bareia\n    ins(\"a)\",     \"ἀ\");\n    ins(\"a(\",     \"ἁ\");\n    ins(\"a\\\\\",     \"ὰ\");\n    ins(\"a/\",      \"ά\");\n    ins(\"a)\\\\\",   \"ἂ\");\n    ins(\"a(\\\\\",   \"ἃ\");\n    ins(\"a)/\",    \"ἄ\");\n    ins(\"a(/\",    \"ἅ\");\n\n    ins(\"e)\",     \"ἐ\");\n    ins(\"e(\",     \"ἑ\");\n    ins(\"e\\\\\",     \"ὲ\");\n    ins(\"e/\",      \"έ\");\n    ins(\"e)\\\\\",   \"ἒ\");\n    ins(\"e(\\\\\",   \"ἓ\");\n    ins(\"e)/\",    \"ἔ\");\n    ins(\"e(/\",    \"ἕ\");\n\n    ins(\"h)\",     \"ἠ\");\n    ins(\"h(\",     \"ἡ\");\n    ins(\"h\\\\\",     \"ὴ\");\n    ins(\"h/\",      \"ή\");\n    ins(\"h)\\\\\",   \"ἢ\");\n    ins(\"h(\\\\\",   \"ἣ\");\n    ins(\"h)/\",    \"ἤ\");\n    ins(\"h(/\",    \"ἥ\");\n\n    ins(\"i)\",     \"ἰ\");\n    ins(\"i(\",     \"ἱ\");\n    ins(\"i\\\\\",     \"ὶ\");\n    ins(\"i/\",      \"ί\");\n    ins(\"i)\\\\\",   \"ἲ\");\n    ins(\"i(\\\\\",   \"ἳ\");\n    ins(\"i)/\",    \"ἴ\");\n    ins(\"i(/\",    \"ἵ\");\n\n    ins(\"o)\",     \"ὀ\");\n    ins(\"o(\",     \"ὁ\");\n    ins(\"o\\\\\",     \"ὸ\");\n    ins(\"o/\",      \"ό\");\n    ins(\"o)\\\\\",   \"ὂ\");\n    ins(\"o(\\\\\",   \"ὃ\");\n    ins(\"o)/\",    \"ὄ\");\n    ins(\"o(/\",    \"ὅ\");\n\n    ins(\"r(\",      \"ῤ\");\n\n    ins(\"u)\",     \"ὐ\");\n    ins(\"u(\",     \"ὑ\");\n    ins(\"u\\\\\",     \"ὺ\");\n    ins(\"u/\",      \"ύ\");\n    ins(\"u)\\\\\",   \"ὒ\");\n    ins(\"u(\\\\\",   \"ὓ\");\n    ins(\"u)/\",    \"ὔ\");\n    ins(\"u(/\",    \"ὕ\");\n\n    ins(\"w)\",     \"ὠ\");\n    ins(\"w(\",     \"ὡ\");\n    ins(\"w\\\\\",     \"ὼ\");\n    ins(\"w/\",      \"ώ\");\n    ins(\"w)\\\\\",   \"ὢ\");\n    ins(\"w(\\\\\",   \"ὣ\");\n    ins(\"w)/\",    \"ὤ\");\n    ins(\"w(/\",    \"ὥ\");\n\n\t\t//perispwmenh\n    ins(\"a=\",      \"ᾶ\");\n    ins(\"a)=\",    \"ἆ\");\n    ins(\"a(=\",    \"ἇ\");\n    \n    ins(\"h=\",      \"ῆ\");\n    ins(\"h)=\",    \"ἦ\");\n    ins(\"h(=\",    \"ἧ\");\n    \n    ins(\"i=\",      \"ῖ\");\n    ins(\"i)=\",    \"ἶ\");\n    ins(\"i(=\",    \"ἷ\");\n    \n    ins(\"u=\",      \"ῦ\");\n    ins(\"u)=\",    \"ὖ\");\n    ins(\"u(=\",    \"ὗ\");\n    \n    ins(\"w=\",      \"ῶ\");\n    ins(\"w)=\",    \"ὦ\");\n    ins(\"w(=\",    \"ὧ\");\n\n\t\t//upogegrammenh\n    ins(\"a|\",      \"ᾳ\");\n    ins(\"a)|\",    \"ᾀ\");\n    ins(\"a(|\",    \"ᾁ\");\n    ins(\"a/|\",     \"ᾴ\");\n    ins(\"a)/|\",   \"ᾄ\");\n    ins(\"a(/|\",   \"ᾅ\");\n    ins(\"a=|\",     \"ᾷ\");\n    ins(\"a)=|\",   \"ᾆ\");\n    ins(\"a(=|\",   \"ᾇ\");\n\n    ins(\"h|\",      \"ῃ\");\n    ins(\"h)|\",    \"ᾐ\");\n    ins(\"h(|\",    \"ᾑ\");\n    ins(\"h/|\",     \"ῄ\");\n    ins(\"h)/|\",   \"ᾔ\");\n    ins(\"h(/|\",   \"ᾕ\");\n    ins(\"h=|\",     \"ῇ\");\n    ins(\"h)=|\",   \"ᾖ\");\n    ins(\"h(=|\",   \"ᾗ\");\n\n    ins(\"w|\",      \"ῳ\"); \n    ins(\"w)|\",    \"ᾠ\");\n    ins(\"w(|\",    \"ᾡ\");\n    ins(\"w/|\",     \"ῴ\");\n    ins(\"w)/|\",   \"ᾤ\");\n    ins(\"w(/|\",   \"ᾥ\");\n    ins(\"w=|\",     \"ῷ\");\n    ins(\"w)=|\",   \"ᾦ\");\n    ins(\"w(=|\",   \"ᾧ\");\n\n\t\t//diairesis\n    ins(\"i+\",      \"ϊ\");\n    ins(\"i+\\\\\",    \"ῒ\");\n    ins(\"i+/\",     \"ΐ\");\n    ins(\"u+\",      \"ϋ\");\n    ins(\"u+\\\\\",    \"ῢ\");\n    ins(\"u+/\",     \"ΰ\");\n    \n\n\t//ORDER: ACCENT - BREATHING (UNOFFICIAL)\n\t\n    //uppercase (capitals)\n    \n\t\t//oceia - bareia\n    ins(\"A\\\\)\",   \"Ἂ\");\n    ins(\"A\\\\(\",   \"Ἃ\");\n    ins(\"A/)\",    \"Ἄ\");\n    ins(\"A/(\",    \"Ἅ\");\n\n    ins(\"E\\\\)\",   \"Ἒ\");\n    ins(\"E\\\\(\",   \"Ἓ\");\n    ins(\"E/)\",    \"Ἔ\");\n    ins(\"E/(\",    \"Ἕ\");\n\n    ins(\"H\\\\)\",   \"Ἢ\");\n    ins(\"H\\\\(\",   \"Ἣ\");\n    ins(\"H/)\",    \"Ἤ\");\n    ins(\"H/(\",    \"Ἥ\");\n\n    ins(\"I\\\\)\",   \"Ἲ\");\n    ins(\"I\\\\(\",   \"Ἳ\");\n    ins(\"I/)\",    \"Ἴ\");\n    ins(\"I/(\",    \"Ἵ\");\n\n    ins(\"O\\\\)\",   \"Ὂ\");\n    ins(\"O\\\\(\",   \"Ὃ\");\n    ins(\"O/)\",    \"Ὄ\");\n    ins(\"O/(\",    \"Ὅ\");\n\n    ins(\"U\\\\(\",   \"Ὓ\");\n    ins(\"U/(\",    \"Ὕ\");\n\n    ins(\"W\\\\)\",   \"Ὢ\");\n    ins(\"W\\\\(\",   \"Ὣ\");\n    ins(\"W/)\",    \"Ὤ\");\n    ins(\"W/(\",    \"Ὥ\");\n\n\t\t//perispwmenh\n    ins(\"A=)\",    \"Ἆ\");\n    ins(\"A=(\",    \"Ἇ\");\n    \n    ins(\"H=)\",    \"Ἦ\");\n    ins(\"H=(\",    \"Ἧ\");\n    \n    ins(\"I=)\",    \"Ἶ\");\n    ins(\"I=(\",    \"Ἷ\");\n    \n    ins(\"U=(\",    \"Ὗ\");\n    \n    ins(\"W=)\",    \"Ὦ\");\n    ins(\"W=(\",    \"Ὧ\");\n\n\t\t//upogegrammenh\n    ins(\"A/)|\",   \"ᾌ\");\n    ins(\"A/(|\",   \"ᾍ\");\n    ins(\"A=)|\",   \"ᾎ\");\n    ins(\"A=(|\",   \"ᾏ\");\n\n    ins(\"H/)|\",   \"ᾜ\");\n    ins(\"H/(|\",   \"ᾝ\");\n    ins(\"H=)|\",   \"ᾞ\");\n    ins(\"H=(|\",   \"ᾟ\");\n\n    ins(\"W/)|\",   \"ᾬ\");\n    ins(\"W/(|\",   \"ᾭ\");\n    ins(\"W=)|\",   \"ᾮ\");\n    ins(\"W=(|\",   \"ᾯ\");\n\n    //lowercase (small letters)\n    \n\t\t//oceia - bareia\n    ins(\"a\\\\)\",   \"ἂ\");\n    ins(\"a\\\\(\",   \"ἃ\");\n    ins(\"a/)\",    \"ἄ\");\n    ins(\"a/(\",    \"ἅ\");\n\n\n    ins(\"e\\\\)\",   \"ἒ\");\n    ins(\"e\\\\(\",   \"ἓ\");\n    ins(\"e/)\",    \"ἔ\");\n    ins(\"e/(\",    \"ἕ\");\n\n    ins(\"h\\\\)\",   \"ἢ\");\n    ins(\"h\\\\(\",   \"ἣ\");\n    ins(\"h/)\",    \"ἤ\");\n    ins(\"h/(\",    \"ἥ\");\n\n    ins(\"i\\\\)\",   \"ἲ\");\n    ins(\"i\\\\(\",   \"ἳ\");\n    ins(\"i/)\",    \"ἴ\");\n    ins(\"i/(\",    \"ἵ\");\n\n    ins(\"o\\\\)\",   \"ὂ\");\n    ins(\"o\\\\(\",   \"ὃ\");\n    ins(\"o/)\",    \"ὄ\");\n    ins(\"o/(\",    \"ὅ\");\n\n    ins(\"u\\\\)\",   \"ὒ\");\n    ins(\"u\\\\(\",   \"ὓ\");\n    ins(\"u/)\",    \"ὔ\");\n    ins(\"u/(\",    \"ὕ\");\n\n    ins(\"w\\\\)\",   \"ὢ\");\n    ins(\"w\\\\(\",   \"ὣ\");\n    ins(\"w/)\",    \"ὤ\");\n    ins(\"w/(\",    \"ὥ\");\n\n\t\t//perispwmenh\n    ins(\"a=)\",    \"ἆ\");\n    ins(\"a=(\",    \"ἇ\");\n    \n    ins(\"h=)\",    \"ἦ\");\n    ins(\"h=(\",    \"ἧ\");\n    \n    ins(\"i=)\",    \"ἶ\");\n    ins(\"i=(\",    \"ἷ\");\n    \n    ins(\"u=)\",    \"ὖ\");\n    ins(\"u=(\",    \"ὗ\");\n    \n    ins(\"w=)\",    \"ὦ\");\n    ins(\"w=(\",    \"ὧ\");\n\n\t\t//upogegrammenh\n    ins(\"a/)|\",   \"ᾄ\");\n    ins(\"a/(|\",   \"ᾅ\");\n    ins(\"a=)|\",   \"ᾆ\");\n    ins(\"a=(|\",   \"ᾇ\");\n\n    ins(\"h/)|\",   \"ᾔ\");\n    ins(\"h/(|\",   \"ᾕ\");\n    ins(\"h=)|\",   \"ᾖ\");\n    ins(\"h=(|\",   \"ᾗ\");\n\n    ins(\"w/)|\",   \"ᾤ\");\n    ins(\"w/(|\",   \"ᾥ\");\n    ins(\"w=)|\",   \"ᾦ\");\n    ins(\"w=(|\",   \"ᾧ\");\n\n\t\t//diairesis\n    ins(\"i\\\\+\",    \"ῒ\");\n    ins(\"i/+\",     \"ΐ\");\n    ins(\"u\\\\+\",    \"ῢ\");\n    ins(\"u/+\",     \"ΰ\");\n\t\n\t//IΙI. MODERN GREEK <-> CLASSICAL GREEK\n\t\t//convert tonos to oceia\n  \n    ins(\"ά\",      \"ά\");\n    ins(\"έ\",      \"έ\");\n    ins(\"ή\",      \"ή\");\n    ins(\"ί\",      \"ί\");\n    ins(\"ΐ\",      \"ΐ\");\n    ins(\"ό\",      \"ό\");\n    ins(\"ύ\",      \"ύ\");\n    ins(\"ΰ\",      \"ΰ\");\n    ins(\"ώ\",      \"ώ\");\n\n    ins(\"Ά\",      \"Ά\");\n    ins(\"Έ\",      \"Έ\");\n    ins(\"Ή\",      \"Ή\");\n    ins(\"Ί\",      \"Ί\");\n    ins(\"Ό\",      \"Ό\");\n    ins(\"Ύ\",      \"Ύ\");\n    ins(\"Ώ\",      \"Ώ\");\n\n\t\t//convert oceia to tonos\n  \n    ins(\"ά\",      \"ά\");\n    ins(\"έ\",      \"έ\");\n    ins(\"ή\",      \"ή\");\n    ins(\"ί\",      \"ί\");\n    ins(\"ΐ\",      \"ΐ\");\n    ins(\"ό\",      \"ό\");\n    ins(\"ύ\",      \"ύ\");\n    ins(\"ΰ\",      \"ΰ\");\n    ins(\"ώ\",      \"ώ\");\n\n    ins(\"Ά\",      \"Ά\");\n    ins(\"Έ\",      \"Έ\");\n    ins(\"Ή\",      \"Ή\");\n    ins(\"Ί\",      \"Ί\");\n    ins(\"Ό\",      \"Ό\");\n    ins(\"Ύ\",      \"Ύ\");\n    ins(\"Ώ\",      \"Ώ\");\n\n\n}\n\nsptr< Dictionary::Class > makeDictionary() THROW_SPEC( std::exception )\n{\n  static GreekTable t;\n\n  return new Transliteration::TransliterationDictionary( \"baa9e37a1aa69cdb5daca14a48ffe5ae\",\n                      QCoreApplication::translate( \"GreekTranslit\", \"Greek Transliteration\" ).toUtf8().data(),\n                      QIcon( \":/flags/gr.png\" ), t );\n}\n\n}\n"
        },
        {
          "name": "greektranslit.hh",
          "type": "blob",
          "size": 0.3818359375,
          "content": "/* This file is (c) 2010 Jennie Petoumenou <epetoumenou@gmail.com>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef GREEKTRANSLIT_HH\n#define GREEKTRANSLIT_HH\n\n#include \"dictionary.hh\"\n\n// Support for Greek transliteration\nnamespace GreekTranslit {\n\nsptr< Dictionary::Class > makeDictionary() THROW_SPEC( std::exception );\n\n}\n\n#endif // GREEKTRANSLIT_HH\n"
        },
        {
          "name": "groupcombobox.cc",
          "type": "blob",
          "size": 3.037109375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"groupcombobox.hh\"\n#include <QEvent>\n#include <QShortcutEvent>\n\nGroupComboBox::GroupComboBox( QWidget * parent ): QComboBox( parent ),\n  popupAction( this ),\n  selectNextAction( this ),\n  selectPreviousAction( this )\n{\n  setSizeAdjustPolicy( AdjustToContents );\n  setToolTip( tr( \"Choose a Group (Alt+G)\" ) );\n\n  popupAction.setShortcut( QKeySequence( \"Alt+G\" ) );\n  connect( &popupAction, SIGNAL( triggered() ),\n           this, SLOT( popupGroups() ) );\n\n  addAction( &popupAction );\n\n  selectNextAction.setShortcut( QKeySequence( \"Alt+PgDown\" ) );\n  connect( &selectNextAction, SIGNAL( triggered() ),\n           this, SLOT( selectNextGroup() ) );\n  addAction( &selectNextAction );\n\n  selectPreviousAction.setShortcut( QKeySequence( \"Alt+PgUp\" ) );\n  connect( &selectPreviousAction, SIGNAL( triggered() ),\n           this, SLOT( selectPreviousGroup() ) );\n  addAction( &selectPreviousAction );\n\n  setMaxVisibleItems( 30 );\n}\n\nvoid GroupComboBox::fill( Instances::Groups const & groups )\n{\n  unsigned prevId = 0;\n\n  if ( count() )\n    prevId = itemData( currentIndex() ).toUInt();\n\n  clear();\n\n  for( QMap< int, int >::iterator i = shortcuts.begin(); i != shortcuts.end(); ++i )\n    releaseShortcut( i.key() );\n\n  shortcuts.clear();\n\n  for( unsigned x  = 0; x < groups.size(); ++x )\n  {\n    addItem( groups[ x ].makeIcon(),\n             groups[ x ].name, groups[ x ].id );\n\n    if ( prevId == groups[ x ].id )\n      setCurrentIndex( x );\n\n    // Create a shortcut\n\n    if ( !groups[ x ].shortcut.isEmpty() )\n    {\n      int id = grabShortcut( groups[ x ].shortcut );\n      setShortcutEnabled( id );\n\n      shortcuts.insert( id, x );\n    }\n  }\n}\n\nbool GroupComboBox::event( QEvent * event )\n{\n  if ( event->type() == QEvent::Shortcut )\n  {\n    QShortcutEvent * ev = ( QShortcutEvent * ) event;\n\n    QMap< int, int >::const_iterator i = shortcuts.find( ev->shortcutId() );\n\n    if ( i != shortcuts.end() )\n    {\n      ev->accept();\n      setCurrentIndex( i.value() );\n      return true;\n    }\n  }\n\n  return QComboBox::event( event );\n}\n\nQList< QAction * > GroupComboBox::getExternActions()\n{\n  QList< QAction * > list;\n  list.append( &popupAction );\n  list.append( &selectNextAction );\n  list.append( &selectPreviousAction );\n  return list;\n}\n\nvoid GroupComboBox::setCurrentGroup( unsigned id )\n{\n  for( int x  = 0; x < count(); ++x )\n  {\n    if ( itemData( x ).toUInt() == id )\n    {\n      setCurrentIndex( x );\n      break;\n    }\n  }\n}\n\nunsigned GroupComboBox::getCurrentGroup() const\n{\n  if ( !count() )\n    return 0;\n\n  return itemData( currentIndex() ).toUInt();\n}\n\nvoid GroupComboBox::popupGroups()\n{\n  showPopup();\n}\n\nvoid GroupComboBox::selectNextGroup()\n{\n  if( count() <= 1 )\n    return;\n  int n = currentIndex() + 1;\n  if( n >= count() )\n    n = 0;\n  setCurrentIndex( n );\n}\n\nvoid GroupComboBox::selectPreviousGroup()\n{\n  if( count() <= 1 )\n    return;\n  int n = currentIndex() - 1;\n  if( n < 0 )\n    n = count() - 1;\n  setCurrentIndex( n );\n}\n"
        },
        {
          "name": "groupcombobox.hh",
          "type": "blob",
          "size": 1.4052734375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __GROUPCOMBOBOX_HH_INCLUDED__\n#define __GROUPCOMBOBOX_HH_INCLUDED__\n\n#include <QComboBox>\n#include <QAction>\n#include <QSize>\n#include <QList>\n#include \"instances.hh\"\n\n/// This is a combo box which is for choosing the dictionary group\nclass GroupComboBox: public QComboBox\n{\n  Q_OBJECT\n\npublic:\n\n  GroupComboBox( QWidget * parent );\n\n  /// Fills combo-box with the given groups\n  void fill( Instances::Groups const & );\n\n  /// Chooses the given group in the combobox. If there's no such group,\n  /// does nothing.\n  void setCurrentGroup( unsigned id );\n\n\n  /// Returns current group.\n  unsigned getCurrentGroup() const;\n\n  /// Return actions which should be accessible from FTS and Headwords dialogs\n  QList< QAction * > getExternActions();\n\nprotected:\n\n  /// We handle shortcut events here.\n  virtual bool event( QEvent * event );\n\n  /// Work around the never-changing QComboBox::minimumSizeHint(), which prevents\n  /// reducing the width of a group combobox beyond the value at application start.\n  virtual QSize minimumSizeHint() const { return sizeHint(); }\n\nprivate slots:\n\n  void popupGroups();\n  void selectNextGroup();\n  void selectPreviousGroup();\n\nprivate:\n\n  QAction popupAction;\n  QAction selectNextAction, selectPreviousAction;\n  QMap< int, int > shortcuts;\n};\n\n#endif\n\n"
        },
        {
          "name": "groups.cc",
          "type": "blob",
          "size": 6.85546875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"groups.hh\"\n#include \"instances.hh\"\n#include \"dictionary.hh\"\n#include <QMessageBox>\n#include <QInputDialog>\n\nusing std::vector;\n\nGroups::Groups( QWidget * parent,\n                vector< sptr< Dictionary::Class > > const & dicts_,\n                Config::Groups const & groups_,\n                Config::Group const & order ): QWidget( parent ),\n  dicts( dicts_ ), groups( groups_ )\n{\n  ui.setupUi( this );\n\n  // Populate the dictionaries' list\n\n  ui.dictionaries->setAsSource();\n  ui.dictionaries->populate( Instances::Group( order, dicts, Config::Group() ).dictionaries,\n                             dicts );\n\n  ui.searchLine->applyTo( ui.dictionaries );\n  addAction( ui.searchLine->getFocusAction() );\n\n  groupsListMenu = new QMenu( tr( \"Group tabs\" ), ui.groups );\n\n  groupsListButton = new QToolButton( ui.groups );\n  groupsListButton->setAutoRaise( true );\n  groupsListButton->setIcon( QIcon( \":/icons/windows-list.png\" ) );\n  groupsListButton->setMenu( groupsListMenu );\n  groupsListButton->setToolTip( tr( \"Open groups list\" ) );\n  groupsListButton->setPopupMode( QToolButton::InstantPopup );\n  ui.groups->setCornerWidget( groupsListButton );\n  groupsListButton->setFocusPolicy( Qt::ClickFocus );\n\n  connect(groupsListMenu, SIGNAL( aboutToShow() ), this, SLOT( fillGroupsMenu() ) );\n  connect(groupsListMenu, SIGNAL( triggered( QAction * ) ),\n          this, SLOT( switchToGroup( QAction * ) ) );\n\n  // Populate groups' widget\n\n  ui.groups->populate( groups, dicts, ui.dictionaries->getCurrentDictionaries() );\n\n  connect( ui.addGroup, SIGNAL( clicked() ),\n           this, SLOT( addNew() ) );\n  connect( ui.renameGroup, SIGNAL( clicked() ),\n           this, SLOT( renameCurrent() ) );\n  connect( ui.removeGroup, SIGNAL( clicked() ),\n           this, SLOT( removeCurrent() ) );\n  connect( ui.removeAllGroups, SIGNAL( clicked() ),\n           this, SLOT( removeAll() ) );\n  connect( ui.addDictsToGroup, SIGNAL( clicked() ),\n           this, SLOT( addToGroup() ) );\n  connect( ui.dictionaries, SIGNAL(  doubleClicked(const QModelIndex &) ),\n           this, SLOT( addToGroup() ) );\n  connect( ui.removeDictsFromGroup, SIGNAL( clicked() ),\n           this, SLOT( removeFromGroup() ) );\n  connect( ui.autoGroups, SIGNAL( clicked() ),\n           this, SLOT( addAutoGroups() ) );\n  connect( ui.groups, SIGNAL( showDictionaryInfo( QString const & ) ),\n           this, SIGNAL( showDictionaryInfo( QString const & ) ) );\n\n  ui.dictionaries->setContextMenuPolicy( Qt::CustomContextMenu );\n  connect( ui.dictionaries, SIGNAL( customContextMenuRequested( QPoint ) ),\n           this, SLOT( showDictInfo( QPoint ) ) );\n\n  countChanged();\n}\n\nvoid Groups::editGroup( unsigned id )\n{\n  for( int x = 0; x < groups.size(); ++x )\n  {\n    if ( groups[ x ].id == id )\n    {\n      ui.groups->setCurrentIndex( x );\n      ui.groups->currentWidget()->setFocus();\n      break;\n    }\n  }\n}\n\nvoid Groups::updateDictionaryOrder( Config::Group const & order )\n{\n  // Make sure it differs from what we have\n\n  Instances::Group newOrder( order, dicts, Config::Group() );\n\n  if ( ui.dictionaries->getCurrentDictionaries() != newOrder.dictionaries )\n  {\n    // Repopulate\n    ui.dictionaries->populate( Instances::Group( order, dicts, Config::Group() ).dictionaries,\n                               dicts );\n  }\n}\n\nConfig::Groups Groups::getGroups() const\n{\n  return ui.groups->makeGroups();\n}\n\nvoid Groups::countChanged()\n{\n  bool en = ui.groups->count();\n\n  ui.renameGroup->setEnabled( en );\n  ui.removeGroup->setEnabled( en );\n  ui.removeAllGroups->setEnabled( en );\n\n  int stretch = ui.groups->count() / 5;\n  if( stretch > 3 ) stretch = 3;\n  ui.gridLayout->setColumnStretch( 2, stretch );\n}\n\nvoid Groups::addNew()\n{\n  bool ok;\n\n  QString name = QInputDialog::getText( this, tr( \"Add group\" ),\n                                  tr(\"Give a name for the new group:\"), QLineEdit::Normal,\n                                  \"\", &ok );\n\n  if ( ok )\n  {\n    ui.groups->addNewGroup( name );\n    countChanged();\n  }\n}\n\nvoid Groups::addAutoGroups()\n{\n  ui.groups->addAutoGroups();\n  countChanged();\n}\n\nvoid Groups::renameCurrent()\n{\n  int current = ui.groups->currentIndex();\n\n  if ( current < 0 )\n    return;\n\n  bool ok;\n\n  QString name = QInputDialog::getText( this, tr(\"Rename group\"),\n                                  tr(\"Give a new name for the group:\"), QLineEdit::Normal,\n                                  ui.groups->getCurrentGroupName(), &ok );\n\n  if ( ok )\n    ui.groups->renameCurrentGroup( name );\n}\n\nvoid Groups::removeCurrent()\n{\n  int current = ui.groups->currentIndex();\n\n  if ( current >= 0 && QMessageBox::question( this, tr( \"Remove group\" ),\n         tr( \"Are you sure you want to remove the group <b>%1</b>?\" ).arg( ui.groups->getCurrentGroupName() ),\n         QMessageBox::Yes, QMessageBox::Cancel ) == QMessageBox::Yes )\n  {\n    ui.groups->removeCurrentGroup();\n    countChanged();\n  }\n}\n\nvoid Groups::removeAll()\n{\n  int current = ui.groups->currentIndex();\n\n  if ( current >= 0 && QMessageBox::question( this, tr( \"Remove all groups\" ),\n         tr( \"Are you sure you want to remove all the groups?\" ),\n         QMessageBox::Yes, QMessageBox::Cancel ) == QMessageBox::Yes )\n  {\n    ui.groups->removeAllGroups();\n    countChanged();\n  }\n}\n\nvoid Groups::addToGroup()\n{\n  int current = ui.groups->currentIndex();\n\n  if ( current >= 0 )\n  {\n    ui.groups->getCurrentModel()->addSelectedUniqueFromModel( ui.dictionaries->selectionModel() );\n  }\n}\n\nvoid Groups::removeFromGroup()\n{\n  int current = ui.groups->currentIndex();\n\n  if ( current >= 0 )\n  {\n    ui.groups->getCurrentModel()->removeSelectedRows( ui.groups->getCurrentSelectionModel() );\n  }\n}\n\nvoid Groups::showDictInfo( QPoint const & pos )\n{\n  QVariant data = ui.dictionaries->getModel()->data(\n        ui.searchLine->mapToSource(ui.dictionaries->indexAt( pos ) ), Qt::EditRole );\n  QString id;\n  if( data.canConvert< QString >() )\n    id = data.toString();\n\n  if( !id.isEmpty() )\n  {\n    vector< sptr< Dictionary::Class > > const & dicts = ui.dictionaries->getCurrentDictionaries();\n    unsigned n;\n    for( n = 0; n < dicts.size(); n++ )\n      if( id.compare( QString::fromUtf8( dicts.at( n )->getId().c_str() ) ) == 0 )\n        break;\n    if( n < dicts.size() )\n      emit showDictionaryInfo( id );\n  }\n}\n\nvoid Groups::fillGroupsMenu()\n{\n  groupsListMenu->clear();\n  for( int i = 0; i < ui.groups->count(); i++ )\n  {\n    QAction * act = groupsListMenu->addAction( ui.groups->tabText( i ) );\n    act->setData( i );\n    if (ui.groups->currentIndex() == i)\n    {\n      QFont f( act->font() );\n      f.setBold( true );\n      act->setFont( f );\n    }\n  }\n\n  if( groupsListMenu->actions().size() > 1 )\n    groupsListMenu->setActiveAction( groupsListMenu->actions().at( ui.groups->currentIndex() ) );\n}\n\nvoid Groups::switchToGroup( QAction * act )\n{\n  int idx = act->data().toInt();\n  ui.groups->setCurrentIndex(idx);\n}\n"
        },
        {
          "name": "groups.hh",
          "type": "blob",
          "size": 1.51171875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __GROUPS_HH_INCLUDED__\n#define __GROUPS_HH_INCLUDED__\n\n#include \"ui_groups.h\"\n#include \"config.hh\"\n#include \"dictionary.hh\"\n#include \"groups_widgets.hh\"\n#include <QToolButton>\n#include <QMenu>\n\nclass Groups: public QWidget\n{\n  Q_OBJECT\n\npublic:\n  Groups( QWidget * parent,\n          std::vector< sptr< Dictionary::Class > > const &,\n          Config::Groups const &,\n          Config::Group const & order );\n\n  /// Instructs the dialog to position itself on editing the given group.\n  void editGroup( unsigned id );\n\n  /// Should be called when the dictionary order has changed to reflect on\n  /// that changes. It would only do anything if the order has actually\n  /// changed.\n  void updateDictionaryOrder( Config::Group const & order );\n\n  Config::Groups getGroups() const;\n\nprivate:\n  Ui::Groups ui;\n  std::vector< sptr< Dictionary::Class > > const & dicts;\n  Config::Groups groups;\n\n  QToolButton * groupsListButton;\n  QMenu * groupsListMenu;\n\n  // Reacts to the event that the number of groups is possibly changed\n  void countChanged();\n\nprivate slots:\n  void addNew();\n  void renameCurrent();\n  void removeCurrent();\n  void removeAll();\n  void addToGroup();\n  void removeFromGroup();\n  void addAutoGroups();\n  void showDictInfo( const QPoint & pos );\n  void fillGroupsMenu();\n  void switchToGroup( QAction * act );\n\nsignals:\n  void showDictionaryInfo( QString const & id );\n};\n\n#endif\n"
        },
        {
          "name": "groups.ui",
          "type": "blob",
          "size": 6.44921875,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ui version=\"4.0\">\n <class>Groups</class>\n <widget class=\"QWidget\" name=\"Groups\">\n  <property name=\"geometry\">\n   <rect>\n    <x>0</x>\n    <y>0</y>\n    <width>662</width>\n    <height>319</height>\n   </rect>\n  </property>\n  <property name=\"windowTitle\">\n   <string notr=\"true\">Groups</string>\n  </property>\n  <layout class=\"QGridLayout\" name=\"gridLayout\" columnstretch=\"1,0,0\">\n   <item row=\"0\" column=\"0\">\n    <layout class=\"QVBoxLayout\" name=\"verticalLayout_3\">\n     <item>\n      <widget class=\"QLabel\" name=\"label_2\">\n       <property name=\"text\">\n        <string>Dictionaries available:</string>\n       </property>\n      </widget>\n     </item>\n     <item>\n      <widget class=\"QuickFilterLine\" name=\"searchLine\"/>\n     </item>\n     <item>\n      <widget class=\"DictListWidget\" name=\"dictionaries\"/>\n     </item>\n    </layout>\n   </item>\n   <item row=\"0\" column=\"1\">\n    <layout class=\"QVBoxLayout\" name=\"verticalLayout_2\">\n     <item>\n      <spacer name=\"verticalSpacer_2\">\n       <property name=\"orientation\">\n        <enum>Qt::Vertical</enum>\n       </property>\n       <property name=\"sizeHint\" stdset=\"0\">\n        <size>\n         <width>20</width>\n         <height>40</height>\n        </size>\n       </property>\n      </spacer>\n     </item>\n     <item>\n      <widget class=\"QPushButton\" name=\"addDictsToGroup\">\n       <property name=\"minimumSize\">\n        <size>\n         <width>32</width>\n         <height>32</height>\n        </size>\n       </property>\n       <property name=\"maximumSize\">\n        <size>\n         <width>32</width>\n         <height>32</height>\n        </size>\n       </property>\n       <property name=\"toolTip\">\n        <string>Add selected dictionaries to group (Ins)</string>\n       </property>\n       <property name=\"text\">\n        <string>&gt;</string>\n       </property>\n       <property name=\"shortcut\">\n        <string>Ins</string>\n       </property>\n      </widget>\n     </item>\n     <item>\n      <widget class=\"QPushButton\" name=\"removeDictsFromGroup\">\n       <property name=\"minimumSize\">\n        <size>\n         <width>32</width>\n         <height>32</height>\n        </size>\n       </property>\n       <property name=\"maximumSize\">\n        <size>\n         <width>32</width>\n         <height>32</height>\n        </size>\n       </property>\n       <property name=\"toolTip\">\n        <string>Remove selected dictionaries from group (Del)</string>\n       </property>\n       <property name=\"text\">\n        <string>&lt;</string>\n       </property>\n       <property name=\"shortcut\">\n        <string>Del</string>\n       </property>\n      </widget>\n     </item>\n     <item>\n      <spacer name=\"verticalSpacer\">\n       <property name=\"orientation\">\n        <enum>Qt::Vertical</enum>\n       </property>\n       <property name=\"sizeHint\" stdset=\"0\">\n        <size>\n         <width>20</width>\n         <height>40</height>\n        </size>\n       </property>\n      </spacer>\n     </item>\n    </layout>\n   </item>\n   <item row=\"0\" column=\"2\">\n    <layout class=\"QVBoxLayout\" name=\"verticalLayout\">\n     <item>\n      <widget class=\"QLabel\" name=\"label_3\">\n       <property name=\"text\">\n        <string>Groups:</string>\n       </property>\n      </widget>\n     </item>\n     <item>\n      <widget class=\"DictGroupsWidget\" name=\"groups\">\n       <property name=\"tabPosition\">\n        <enum>QTabWidget::North</enum>\n       </property>\n       <property name=\"elideMode\">\n        <enum>Qt::ElideRight</enum>\n       </property>\n       <widget class=\"QWidget\" name=\"tab_4\">\n        <attribute name=\"title\">\n         <string>Tab 2</string>\n        </attribute>\n       </widget>\n      </widget>\n     </item>\n     <item>\n      <layout class=\"QHBoxLayout\" name=\"horizontalLayout\">\n       <item>\n        <widget class=\"QPushButton\" name=\"addGroup\">\n         <property name=\"toolTip\">\n          <string>Create new dictionary group</string>\n         </property>\n         <property name=\"text\">\n          <string>&amp;Add group</string>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <widget class=\"QPushButton\" name=\"autoGroups\">\n         <property name=\"toolTip\">\n          <string>Create language-based groups</string>\n         </property>\n         <property name=\"text\">\n          <string>Auto groups</string>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <widget class=\"QPushButton\" name=\"renameGroup\">\n         <property name=\"toolTip\">\n          <string>Rename current dictionary group</string>\n         </property>\n         <property name=\"text\">\n          <string>Re&amp;name group</string>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <widget class=\"QPushButton\" name=\"removeGroup\">\n         <property name=\"toolTip\">\n          <string>Remove current dictionary group</string>\n         </property>\n         <property name=\"text\">\n          <string>&amp;Remove group</string>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <widget class=\"QPushButton\" name=\"removeAllGroups\">\n         <property name=\"toolTip\">\n          <string>Remove all dictionary groups</string>\n         </property>\n         <property name=\"text\">\n          <string>Remove all groups</string>\n         </property>\n        </widget>\n       </item>\n      </layout>\n     </item>\n    </layout>\n   </item>\n   <item row=\"1\" column=\"0\" colspan=\"3\">\n    <widget class=\"QLabel\" name=\"label_4\">\n     <property name=\"text\">\n      <string>Drag&amp;drop dictionaries to and from the groups, move them inside the groups, reorder the groups using your mouse.</string>\n     </property>\n     <property name=\"wordWrap\">\n      <bool>true</bool>\n     </property>\n    </widget>\n   </item>\n  </layout>\n </widget>\n <customwidgets>\n  <customwidget>\n   <class>DictListWidget</class>\n   <extends>QListWidget</extends>\n   <header>groups_widgets.hh</header>\n  </customwidget>\n  <customwidget>\n   <class>QuickFilterLine</class>\n   <extends>QLineEdit</extends>\n   <header>groups_widgets.hh</header>\n  </customwidget>\n  <customwidget>\n   <class>DictGroupsWidget</class>\n   <extends>QTabWidget</extends>\n   <header>groups_widgets.hh</header>\n   <container>1</container>\n  </customwidget>\n </customwidgets>\n <tabstops>\n  <tabstop>dictionaries</tabstop>\n  <tabstop>addDictsToGroup</tabstop>\n  <tabstop>removeDictsFromGroup</tabstop>\n  <tabstop>groups</tabstop>\n  <tabstop>addGroup</tabstop>\n  <tabstop>autoGroups</tabstop>\n  <tabstop>renameGroup</tabstop>\n  <tabstop>removeGroup</tabstop>\n  <tabstop>removeAllGroups</tabstop>\n  <tabstop>searchLine</tabstop>\n </tabstops>\n <resources/>\n <connections/>\n</ui>\n"
        },
        {
          "name": "groups_widgets.cc",
          "type": "blob",
          "size": 28.310546875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"groups_widgets.hh\"\n\n#include \"instances.hh\"\n#include \"config.hh\"\n#include \"langcoder.hh\"\n#include \"language.hh\"\n#include \"fsencoding.hh\"\n\n//#include \"initializing.hh\"\n\n#include <QMenu>\n#include <QDir>\n#include <QIcon>\n#include <QMap>\n#include <QVector>\n#include <QFileInfo>\n#include <QFileDialog>\n#include <QMessageBox>\n\nusing std::vector;\n\n/// DictGroupWidget\n\nDictGroupWidget::DictGroupWidget( QWidget * parent,\n                                  vector< sptr< Dictionary::Class > > const & dicts,\n                                  Config::Group const & group ):\n  QWidget( parent ),\n  groupId( group.id )\n{\n  ui.setupUi( this );\n  ui.dictionaries->populate( Instances::Group( group, dicts, Config::Group() ).dictionaries, dicts );\n\n  // Populate icons' list\n\n  QStringList icons = QDir( \":/flags/\" ).entryList( QDir::Files, QDir::NoSort );\n\n  ui.groupIcon->addItem( tr( \"None\" ), \"\" );\n\n  bool usesIconData = !group.iconData.isEmpty();\n\n  if ( !usesIconData )\n    ui.groupIcon->addItem( tr( \"From file...\" ), \"\" );\n  else\n    ui.groupIcon->addItem( Instances::iconFromData( group.iconData ), group.icon, group.icon );\n\n  for( int x = 0; x < icons.size(); ++x )\n  {\n    QString n( icons[ x ] );\n    n.chop( 4 );\n    n[ 0 ] = n[ 0 ].toUpper();\n\n    ui.groupIcon->addItem( QIcon( \":/flags/\" + icons[ x ] ), n, icons[ x ] );\n\n    if ( !usesIconData && icons[ x ] == group.icon )\n      ui.groupIcon->setCurrentIndex( x + 2 );\n  }\n\n  if ( usesIconData )\n    ui.groupIcon->setCurrentIndex( 1 );\n\n  ui.shortcut->setHotKey( Config::HotKey( group.shortcut ) );\n\n  ui.favoritesFolder->setText( group.favoritesFolder );\n\n  connect( ui.groupIcon, SIGNAL(activated(int)),this,SLOT(groupIconActivated(int)),\n           Qt::QueuedConnection );\n\n  ui.dictionaries->setContextMenuPolicy( Qt::CustomContextMenu );\n  connect( ui.dictionaries, SIGNAL( customContextMenuRequested( QPoint ) ),\n           this, SLOT( showDictInfo( QPoint ) ) );\n\n  connect( ui.dictionaries, SIGNAL( doubleClicked( QModelIndex ) ),\n           this, SLOT( removeCurrentItem( QModelIndex ) ) );\n}\n\nvoid DictGroupWidget::groupIconActivated( int index )\n{\n  if ( index == 1 )\n  {\n    QList< QByteArray > supImageFormats = QImageReader::supportedImageFormats();\n\n    QString formatList( \" (\" );\n\n    for( int x = 0; x < supImageFormats.size(); ++x )\n      formatList += \"*.\" + QString::fromLatin1( supImageFormats[ x ] ) + \" \";\n\n    formatList.chop( 1 );\n    formatList.append( \")\" );\n\n    QString chosenFile =\n        QFileDialog::getOpenFileName( this, tr( \"Choose a file to use as group icon\" ),\n                                      QString(),\n                                      tr( \"Images\" ) + formatList + \";;\" +\n                                      tr( \"All files\" ) + \" (*.*)\" );\n\n    if ( !chosenFile.isEmpty() )\n    {\n      QIcon icon( chosenFile );\n\n      if ( icon.isNull() )\n        QMessageBox::critical( this, tr( \"Error\" ), tr( \"Can't read the specified image file.\" ) );\n      else\n      {\n        ui.groupIcon->setItemIcon( 1, icon );\n\n        QString baseName = QFileInfo( chosenFile ).completeBaseName();\n        ui.groupIcon->setItemText( 1, baseName );\n        ui.groupIcon->setItemData( 1, baseName );\n      }\n    }\n  }\n}\n\nConfig::Group DictGroupWidget::makeGroup() const\n{\n  Instances::Group g( \"\" );\n\n  g.id = groupId;\n\n  g.dictionaries = ui.dictionaries->getCurrentDictionaries();\n\n  int currentIndex = ui.groupIcon->currentIndex();\n\n  if ( currentIndex == 1 ) // File\n    g.iconData = ui.groupIcon->itemIcon( currentIndex );\n\n  g.icon = ui.groupIcon->itemData( currentIndex ).toString();\n\n  g.shortcut = ui.shortcut->getHotKey().toKeySequence();\n\n  g.favoritesFolder = ui.favoritesFolder->text().replace( '\\\\', '/' );\n\n  return g.makeConfigGroup();\n}\n\nvoid DictGroupWidget::showDictInfo( QPoint const & pos )\n{\n  QVariant data = ui.dictionaries->getModel()->data( ui.dictionaries->indexAt( pos ), Qt::EditRole );\n  QString id;\n  if( data.canConvert< QString >() )\n    id = data.toString();\n\n  if( !id.isEmpty() )\n  {\n    vector< sptr< Dictionary::Class > > const & dicts = ui.dictionaries->getCurrentDictionaries();\n    unsigned n;\n    for( n = 0; n < dicts.size(); n++ )\n      if( id.compare( QString::fromUtf8( dicts.at( n )->getId().c_str() ) ) == 0 )\n        break;\n    if( n < dicts.size() )\n      emit showDictionaryInfo( id );\n  }\n}\n\nvoid DictGroupWidget::removeCurrentItem( QModelIndex const & index )\n{\n  (void)index;\n  ui.dictionaries->getModel()->removeSelectedRows( ui.dictionaries->selectionModel() );\n}\n\n/// DictListModel\n\nvoid DictListModel::populate(\n  std::vector< sptr< Dictionary::Class > > const & active,\n  std::vector< sptr< Dictionary::Class > > const & available )\n{\n  dictionaries = active;\n  allDicts = &available;\n\n  beginResetModel();\n  endResetModel();\n}\n\nvoid DictListModel::populate(\n  std::vector< sptr< Dictionary::Class > > const & active )\n{\n  dictionaries = active;\n  beginResetModel();\n  endResetModel();\n}\n\nvoid DictListModel::setAsSource()\n{\n  isSource = true;\n}\n\nstd::vector< sptr< Dictionary::Class > > const &\n  DictListModel::getCurrentDictionaries() const\n{\n  return dictionaries;\n}\n\nQt::ItemFlags DictListModel::flags( QModelIndex const & index ) const\n{\n  Qt::ItemFlags defaultFlags = QAbstractListModel::flags( index );\n\n  if (index.isValid())\n     return Qt::ItemIsDragEnabled | defaultFlags;\n  else\n     return Qt::ItemIsDropEnabled | defaultFlags;\n}\n\nint DictListModel::rowCount( QModelIndex const & ) const\n{\n  return dictionaries.size();\n}\n\nQVariant DictListModel::data( QModelIndex const & index, int role ) const\n{\n  if( index.row() < 0 )\n    return QVariant();\n  \n  sptr< Dictionary::Class > const & item = dictionaries[ index.row() ];\n\n  if ( !item )\n    return QVariant();\n\n  switch ( role )\n  {\n    case Qt::ToolTipRole:\n    {\n      QString tt = \"<b>\" + QString::fromUtf8( item->getName().c_str() ) + \"</b>\";\n\n      QString lfrom( Language::localizedNameForId( item->getLangFrom() ) );\n      QString lto( Language::localizedNameForId( item->getLangTo() ) );\n      if ( !lfrom.isEmpty() )\n      {\n        if ( lfrom == lto )\n          tt += \"<br>\" + lfrom;\n        else\n          tt += \"<br>\" + lfrom + \" - \" + lto;\n      }\n\n      int entries = item->getArticleCount();\n      if ( !entries )\n        entries = item->getWordCount();\n      if ( entries )\n        tt += \"<br>\" + tr( \"%1 entries\" ).arg( entries );\n\n      const std::vector< std::string > & dirs = item->getDictionaryFilenames();\n\n      if ( dirs.size() )\n      {\n        tt += \"<hr>\";\n        tt += FsEncoding::decode( dirs.at( 0 ).c_str() );\n      }\n\n      tt.replace( \" \", \"&nbsp;\" );\n      return tt;\n    }\n\n    case Qt::DisplayRole :\n      return QString::fromUtf8( item->getName().c_str() );\n\n    case Qt::EditRole :\n      return QString::fromUtf8( item->getId().c_str() );\n\n    case Qt::DecorationRole:\n      // make all icons of the same size to avoid visual size/alignment problems\n      return item->getIcon().pixmap( 32 ).scaledToHeight( 21, Qt::SmoothTransformation );\n\n    default:;\n  }\n\n  return QVariant();\n}\n\nbool DictListModel::insertRows( int row, int count, const QModelIndex & parent )\n{\n  if ( isSource )\n    return false;\n\n  beginInsertRows( parent, row, row + count - 1 );\n  dictionaries.insert( dictionaries.begin() + row, count,\n                       sptr< Dictionary::Class >() );\n  endInsertRows();\n  emit contentChanged();\n  return true;\n}\n\nvoid DictListModel::addRow(const QModelIndex & parent, sptr< Dictionary::Class > dict)\n{\n  for (unsigned i = 0; i < dictionaries.size(); i++)\n  {\n    if (dictionaries[i]->getId() == dict->getId())\n      return;\n  }\n\n  beginInsertRows( parent, dictionaries.size(), dictionaries.size()+1 );\n  dictionaries.push_back(dict);\n  endInsertRows();\n  emit contentChanged();\n}\n\nbool DictListModel::removeRows( int row, int count,\n                                const QModelIndex & parent )\n{\n  if ( isSource )\n    return false;\n\n  beginRemoveRows( parent, row, row + count - 1 );\n  dictionaries.erase( dictionaries.begin() + row,\n                      dictionaries.begin() + row + count );\n  endRemoveRows();\n  emit contentChanged();\n  return true;\n}\n\nbool DictListModel::setData( QModelIndex const & index, const QVariant & value,\n                             int role )\n{\n  if ( isSource || !allDicts || !index.isValid() ||\n       index.row() >= (int)dictionaries.size() )\n    return false;\n\n  if ( ( role == Qt::DisplayRole ) || ( role ==  Qt::DecorationRole ) )\n  {\n    // Allow changing that, but do nothing\n    return true;\n  }\n\n  if ( role == Qt::EditRole )\n  {\n    Config::Group g;\n\n    g.dictionaries.push_back( Config::DictionaryRef( value.toString(), QString() ) );\n\n    Instances::Group i( g, *allDicts, Config::Group() );\n\n    if ( i.dictionaries.size() == 1 )\n    {\n      // Found that dictionary\n      dictionaries[ index.row() ] = i.dictionaries.front();\n\n      emit dataChanged( index, index );\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\nQt::DropActions DictListModel::supportedDropActions() const\n{\n  return Qt::MoveAction;\n}\n\nvoid DictListModel::removeSelectedRows( QItemSelectionModel * source )\n{\n  if ( !source )\n    return;\n\n  QModelIndexList rows = source->selectedRows();\n\n  if ( !rows.count() )\n    return;\n\n  for ( int i = rows.count()-1; i >= 0; --i )\n  {\n    dictionaries.erase( dictionaries.begin() + rows.at( i ).row() );\n  }\n\n  beginResetModel();\n  endResetModel();\n  emit contentChanged();\n}\n\nvoid DictListModel::addSelectedUniqueFromModel( QItemSelectionModel * source )\n{\n  if ( !source )\n    return;\n\n  QModelIndexList rows = source->selectedRows();\n\n  if ( !rows.count() )\n    return;\n\n  const QSortFilterProxyModel * proxyModel = dynamic_cast< const QSortFilterProxyModel * > ( source->model() );\n\n  const DictListModel * baseModel;\n\n  if ( proxyModel )\n  {\n    baseModel = dynamic_cast< const DictListModel * > ( proxyModel->sourceModel() );\n  }\n  else\n  {\n    baseModel = dynamic_cast< const DictListModel * > ( source->model() );\n  }\n\n  if ( !baseModel )\n    return;\n\n  QVector< std::string > list;\n  QVector< std::string > dicts;\n  for ( unsigned i = 0; i < dictionaries.size(); i++ )\n    dicts.append( dictionaries.at( i )->getId() );\n\n  for ( int i = 0; i < rows.count(); i++ )\n  {\n    QModelIndex idx = proxyModel ? proxyModel->mapToSource(rows.at( i )) : rows.at( i );\n    std::string id = baseModel->dictionaries.at( idx.row() )->getId();\n\n    if ( !dicts.contains( id ) )\n      list.append( id );\n  }\n\n  if ( list.empty() )\n    return;\n\n  for ( int j = 0; j < list.size(); j++ )\n  {\n    for ( unsigned i = 0; i < allDicts->size(); i++ )\n    {\n      if ( allDicts->at( i )->getId() == list.at( j ) )\n      {\n        dictionaries.push_back( allDicts->at( i ) );\n        break;\n      }\n    }\n  }\n\n  beginResetModel();\n  endResetModel();\n  emit contentChanged();\n}\n\nvoid DictListModel::filterDuplicates()\n{\n  QSet< QString > ids;\n  bool doReset = false;\n\n  for ( unsigned i = 0; i < dictionaries.size(); i++ )\n  {\n    QString id = QString::fromStdString( dictionaries.at( i )->getId() );\n\n    if ( ids.contains( id ) )\n    {\n      dictionaries.erase( dictionaries.begin() + i-- );\n      doReset = true;\n      continue;\n    }\n\n    ids.insert( id );\n  }\n\n  if ( doReset )\n  {\n    beginResetModel();\n    endResetModel();\n    emit contentChanged();\n  }\n}\n\n/// DictListWidget\n\nDictListWidget::DictListWidget( QWidget * parent ): QListView( parent ),\n  model( this )\n{\n  setModel( &model );\n\n  setSelectionMode( ExtendedSelection );\n\n  setDragEnabled( true );\n  setAcceptDrops( true );\n  setDropIndicatorShown( true );\n}\n\nDictListWidget::~DictListWidget()\n{\n  setModel( 0 );\n}\n\nvoid DictListWidget::populate(\n  std::vector< sptr< Dictionary::Class > > const & active,\n  std::vector< sptr< Dictionary::Class > > const & available )\n{\n  model.populate( active, available );\n}\n\nvoid DictListWidget::populate(\n  std::vector< sptr< Dictionary::Class > > const & active )\n{\n  model.populate( active );\n}\n\nvoid DictListWidget::setAsSource()\n{\n  setDropIndicatorShown( false );\n  model.setAsSource();\n}\n\nstd::vector< sptr< Dictionary::Class > > const &\n  DictListWidget::getCurrentDictionaries() const\n{\n  return model.getCurrentDictionaries();\n}\n\nvoid DictListWidget::dropEvent( QDropEvent * event )\n{\n  DictListWidget * sourceList = dynamic_cast< DictListWidget * > ( event->source() );\n\n  QListView::dropEvent( event );\n\n  if ( sourceList != this )\n  {\n    model.filterDuplicates();\n  }\n}\n\nvoid DictListWidget::focusInEvent( QFocusEvent * )\n{\n  emit gotFocus();\n}\n\nvoid DictListWidget::rowsInserted( QModelIndex const & parent, int start, int end )\n{\n  QListView::rowsInserted( parent, start, end );\n\n  // When inserting new rows, make the first of them current\n  selectionModel()->setCurrentIndex( model.index( start, 0, parent ),\n                                     QItemSelectionModel::NoUpdate );\n}\n\nvoid DictListWidget::rowsAboutToBeRemoved( QModelIndex const & parent, int start, int end )\n{\n  // When removing rows, if the current row is among the removed ones, select\n  // an item just before the first row to be removed, if there's one.\n  QModelIndex current = currentIndex();\n\n  if ( current.isValid() && current.row() &&\n       current.row() >= start && current.row() <= end )\n    selectionModel()->setCurrentIndex( model.index( current.row() - 1, 0, parent ),\n                                       QItemSelectionModel::NoUpdate );\n\n  QListView::rowsAboutToBeRemoved( parent, start, end );\n}\n\n\n// DictGroupsWidget\n\nDictGroupsWidget::DictGroupsWidget( QWidget * parent ):\n  QTabWidget( parent ), nextId( 1 ), allDicts( 0 ), activeDicts( 0 )\n{\n#if QT_VERSION >= 0x040500\n  setMovable( true );\n#endif\n  setContextMenuPolicy( Qt::CustomContextMenu );\n  connect( this, SIGNAL( customContextMenuRequested( QPoint ) ),\n           this, SLOT( contextMenu( QPoint ) ) );\n}\n\nnamespace {\n\nQString escapeAmps( QString const & str )\n{\n  QString result( str );\n  result.replace( \"&\", \"&&\" );\n  return result;\n}\n\nQString unescapeAmps( QString const & str )\n{\n  QString result( str );\n  result.replace( \"&&\", \"&\" );\n  return result;\n}\n\n}\n\nvoid DictGroupsWidget::populate( Config::Groups const & groups,\n                                 vector< sptr< Dictionary::Class > > const & allDicts_,\n                                 vector< sptr< Dictionary::Class > > const & activeDicts_ )\n{\n  while( count() )\n    removeCurrentGroup();\n\n  allDicts = &allDicts_;\n  activeDicts = &activeDicts_;\n\n  for( int x = 0; x < groups.size(); ++x )\n  {\n    DictGroupWidget *gr = new DictGroupWidget( this, *allDicts, groups[ x ] );\n    addTab( gr, escapeAmps( groups[ x ].name ) );\n    connect( gr, SIGNAL( showDictionaryInfo( QString const & ) ),\n             this, SIGNAL( showDictionaryInfo( QString const & ) ) );\n    connect( gr->getModel(), SIGNAL( contentChanged() ), this, SLOT( tabDataChanged() ) );\n\n    setCurrentIndex( x );\n    QString toolTipStr = \"\\\"\" + tabText( x ) + \"\\\"\\n\" + tr( \"Dictionaries: \" )\n                         + QString::number( getCurrentModel()->getCurrentDictionaries().size() );\n    setTabToolTip( x, toolTipStr );\n  }\n\n  nextId = groups.nextId;\n\n  setCurrentIndex( 0 );\n\n  setUsesScrollButtons( count() > 3 );\n}\n\n/// Creates groups from what is currently set up\nConfig::Groups DictGroupsWidget::makeGroups() const\n{\n  Config::Groups result;\n\n  result.nextId = nextId;\n\n  for( int x = 0; x < count(); ++x )\n  {\n    result.push_back( dynamic_cast< DictGroupWidget & >( *widget( x ) ).makeGroup() );\n    result.back().name = unescapeAmps( tabText( x ) );\n  }\n\n  return result;\n}\n\nDictListModel * DictGroupsWidget::getCurrentModel() const\n{\n  int current = currentIndex();\n\n  if ( current >= 0 )\n  {\n    DictGroupWidget * w = ( DictGroupWidget * ) widget( current );\n    return w->getModel();\n  }\n\n  return 0;\n}\n\nQItemSelectionModel * DictGroupsWidget::getCurrentSelectionModel() const\n{\n  int current = currentIndex();\n\n  if ( current >= 0 )\n  {\n    DictGroupWidget * w = ( DictGroupWidget * ) widget( current );\n    return w->getSelectionModel();\n  }\n\n  return 0;\n}\n\n\nvoid DictGroupsWidget::addNewGroup( QString const & name )\n{\n  if ( !allDicts )\n    return;\n\n  int idx = currentIndex() + 1;\n\n  Config::Group newGroup;\n\n  newGroup.id = nextId++;\n\n  DictGroupWidget *gr = new DictGroupWidget( this, *allDicts, newGroup );\n  insertTab( idx, gr, escapeAmps( name ) );\n  connect( gr, SIGNAL( showDictionaryInfo( QString const & ) ),\n           this, SIGNAL( showDictionaryInfo( QString const & ) ) );\n\n  setCurrentIndex( idx );\n\n  connect( gr->getModel(), SIGNAL( contentChanged() ), this, SLOT( tabDataChanged() ) );\n\n  QString toolTipStr = \"\\\"\" + tabText( idx ) + \"\\\"\\n\" + tr( \"Dictionaries: \" )\n                       + QString::number( getCurrentModel()->getCurrentDictionaries().size() );\n  setTabToolTip( idx, toolTipStr );\n\n  setUsesScrollButtons( count() > 3 );\n}\n\nint DictGroupsWidget::addUniqueGroup( const QString & name )\n{\n  for( int n = 0; n < count(); n++ )\n    if( tabText( n ) == name )\n    {\n      setCurrentIndex( n );\n      return n;\n    }\n\n  addNewGroup( name );\n  return currentIndex();\n}\n\nvoid DictGroupsWidget::addAutoGroups()\n{\n  if( !activeDicts )\n    return;\n\n  if ( QMessageBox::information( this, tr( \"Confirmation\" ),\n         tr( \"Are you sure you want to generate a set of groups \"\n             \"based on language pairs?\" ), QMessageBox::Yes,\n             QMessageBox::Cancel ) != QMessageBox::Yes )\n    return;\n\n  QMap< QString, QVector< sptr<Dictionary::Class> > > dictMap;\n  QMap< QString, QVector< sptr<Dictionary::Class> > > morphoMap;\n\n  // Put active dictionaries into lists\n\n  for ( unsigned i = 0; i < activeDicts->size(); i++ )\n  {\n    sptr<Dictionary::Class> dict = activeDicts->at( i );\n\n    int idFrom = dict->getLangFrom();\n    int idTo = dict->getLangTo();\n    if( idFrom == 0)\n    {\n      // Attempt to find language pair in dictionary name\n\n      QPair<quint32,quint32> ids = LangCoder::findIdsForName( QString::fromUtf8( dict->getName().c_str() ) );\n      idFrom = ids.first;\n      idTo = ids.second;\n    }\n\n    QString name( tr( \"Unassigned\" ) );\n    if ( idFrom != 0 && idTo != 0 )\n    {\n      QString lfrom = LangCoder::intToCode2( idFrom );\n      QString lto = LangCoder::intToCode2( idTo );\n      lfrom[ 0 ] = lfrom[ 0 ].toTitleCase();\n      lto[ 0 ] = lto[ 0 ].toTitleCase();\n      name = lfrom + \" - \" + lto;\n    }\n    else if( !dict->getDictionaryFilenames().empty() )\n    {\n      // Handle special case - morphology dictionaries\n\n      QString fileName = QFileInfo( FsEncoding::decode( dict->getDictionaryFilenames()[ 0 ].c_str() ) ).fileName();\n      if( fileName.endsWith( \".aff\", Qt::CaseInsensitive ) )\n      {\n        QString code = fileName.left( 2 ).toLower();\n        morphoMap[ code ].push_back( dict );\n        continue;\n      }\n    }\n\n    dictMap[ name ].push_back( dict );\n  }\n\n  QStringList const groupList = dictMap.keys();\n  QStringList const morphoList = morphoMap.keys();\n\n  // Insert morphology dictionaries into corresponding lists\n\n  for( QStringList::ConstIterator ln = morphoList.begin(); ln != morphoList.end(); ++ln )\n  {\n    for( QStringList::ConstIterator gr = groupList.begin(); gr != groupList.end(); ++gr )\n      if( ln->compare( gr->left( 2 ), Qt::CaseInsensitive ) == 0 )\n      {\n        QVector<sptr<Dictionary::Class> > vdg = dictMap[ *gr ];\n        vdg += morphoMap[ *ln ];\n        dictMap[ *gr ] = vdg;\n      }\n  }\n\n  // Make groups\n\n  for( QStringList::ConstIterator gr = groupList.begin(); gr != groupList.end(); ++gr )\n  {\n    if( count() )\n      setCurrentIndex( count() - 1 );\n\n    addUniqueGroup( *gr );\n\n    // add dictionaries into the current group\n    QVector< sptr<Dictionary::Class> > vd = dictMap[ *gr ];\n    DictListModel *model = getCurrentModel();\n    for( int i = 0; i < vd.count(); i++ )\n      model->addRow(QModelIndex(), vd.at( i ) );\n  }\n}\n\nQString DictGroupsWidget::getCurrentGroupName() const\n{\n  int current = currentIndex();\n\n  if ( current >= 0 )\n    return unescapeAmps( tabText( current ) );\n\n  return QString();\n}\n\nvoid DictGroupsWidget::renameCurrentGroup( QString const & name )\n{\n  int current = currentIndex();\n\n  if ( current >= 0 )\n    setTabText( current, escapeAmps( name ) );\n}\n\nvoid DictGroupsWidget::removeCurrentGroup()\n{\n  int current = currentIndex();\n\n  if ( current >= 0 )\n  {\n    QWidget * w = widget( current );\n    removeTab( current );\n    delete w;\n  }\n\n  setUsesScrollButtons( count() > 3 );\n}\n\nvoid DictGroupsWidget::removeAllGroups()\n{\n  while ( count() )\n  {\n    QWidget * w = widget( 0 );\n    removeTab( 0 );\n    delete w;\n  }\n}\n\nvoid DictGroupsWidget::combineGroups( int source, int target )\n{\n  if( source < 0 || source >= count() || target < 0 || target >= count() )\n    return;\n\n  setCurrentIndex( source );\n  vector< sptr< Dictionary::Class > > const & dicts = getCurrentModel()->getCurrentDictionaries();\n\n  setCurrentIndex( target );\n  DictListModel *model = getCurrentModel();\n\n  disconnect( model, SIGNAL( contentChanged() ), this, SLOT( tabDataChanged() ) );\n\n  for( unsigned i = 0; i < dicts.size(); i++ )\n    model->addRow( QModelIndex(), dicts[ i ] );\n\n  connect( model, SIGNAL( contentChanged() ), this, SLOT( tabDataChanged() ) );\n\n  QString toolTipStr = \"\\\"\" + tabText( target ) + \"\\\"\\n\" + tr( \"Dictionaries: \" )\n                       + QString::number( model->getCurrentDictionaries().size() );\n  setTabToolTip( target, toolTipStr );\n}\n\nvoid DictGroupsWidget::contextMenu( QPoint const & pos )\n{\n  int clickedGroup = tabBar()->tabAt( pos );\n  if( clickedGroup < 0 )\n    return;\n  QString name = tabText( clickedGroup );\n  if( name.length() != 7 || name.mid( 2, 3 ) != \" - \" )\n    return;\n\n  QMenu menu( this );\n\n  QAction *combineSourceAction = new QAction( QString( tr( \"Combine groups by source language to \\\"%1->\\\"\" ) )\n                                              .arg( name.left( 2 ) ), &menu );\n  combineSourceAction->setEnabled( false );\n\n  QString grLeft = name.left( 2 );\n  QString grRight = name.right( 2 );\n  for( int i = 0; i < count(); i++ )\n  {\n    QString str = tabText( i );\n    if( i != clickedGroup && str.length() == 7 && str.mid( 2, 3 ) == \" - \" && str.startsWith( grLeft ) )\n    {\n      combineSourceAction->setEnabled( true );\n      break;\n    }\n  }\n  menu.addAction( combineSourceAction );\n\n  QAction *combineTargetAction = new QAction( QString( tr( \"Combine groups by target language to \\\"->%1\\\"\" ) )\n                                              .arg( name.right( 2 ) ), &menu );\n  combineTargetAction->setEnabled( false );\n\n  for( int i = 0; i < count(); i++ )\n  {\n    QString str = tabText( i );\n    if( i != clickedGroup && str.length() == 7 && str.mid( 2, 3 ) == \" - \" && str.endsWith( grRight ) )\n    {\n      combineTargetAction->setEnabled( true );\n      break;\n    }\n  }\n  menu.addAction( combineTargetAction );\n\n  QAction *combineTwoSidedAction = NULL;\n  if( grLeft != grRight )\n  {\n    combineTwoSidedAction = new QAction( QString( tr( \"Make two-side translate group \\\"%1-%2-%1\\\"\" ) )\n                                         .arg( grLeft ).arg( grRight ), &menu );\n\n    combineTwoSidedAction->setEnabled( false );\n\n    QString str = grRight + \" - \" + grLeft;\n    for( int i = 0; i < count(); i++ )\n    {\n      if( str == tabText( i ) )\n      {\n        combineTwoSidedAction->setEnabled( true );\n        break;\n      }\n    }\n\n    menu.addAction( combineTwoSidedAction );\n  }\n\n  QAction *combineFirstAction = new QAction( QString( tr( \"Combine groups with \\\"%1\\\"\" ) )\n                                             .arg( grLeft ), &menu );\n  combineFirstAction->setEnabled( false );\n  for( int i = 0; i < count(); i++ )\n  {\n    QString str = tabText( i );\n    if( i != clickedGroup && str.length() == 7 && str.mid( 2, 3 ) == \" - \" &&\n        ( str.startsWith( grLeft ) || str.endsWith( grLeft ) ) )\n    {\n      combineFirstAction->setEnabled( true );\n      break;\n    }\n  }\n  menu.addAction( combineFirstAction );\n\n  QAction *combineSecondAction = NULL;\n\n  if( grLeft != grRight )\n  {\n    combineSecondAction = new QAction( QString( tr( \"Combine groups with \\\"%1\\\"\" ) )\n                                        .arg( grRight ), &menu );\n    combineSecondAction->setEnabled( false );\n\n    for( int i = 0; i < count(); i++ )\n    {\n      QString str = tabText( i );\n      if( i != clickedGroup && str.length() == 7 && str.mid( 2, 3 ) == \" - \" &&\n          ( str.startsWith( grRight ) || str.endsWith( grRight ) ) )\n      {\n        combineSecondAction->setEnabled( true );\n        break;\n      }\n    }\n    menu.addAction( combineSecondAction );\n  }\n\n  QAction *result = menu.exec( mapToGlobal( pos ) );\n\n  setUpdatesEnabled( false );\n  int targetGroup;\n\n  if( result && result == combineSourceAction )\n  {\n    setCurrentIndex( clickedGroup );\n    targetGroup = addUniqueGroup( grLeft + \"->\" );\n\n    for( int i = 0; i < count(); i++ )\n    {\n      QString str = tabText( i );\n      if( str.length() == 7 && str.mid( 2, 3 ) == \" - \" && str.startsWith( grLeft ) )\n        combineGroups( i, targetGroup );\n    }\n\n    setCurrentIndex( targetGroup );\n  }\n  else\n  if( result && result == combineTargetAction )\n  {\n    setCurrentIndex( clickedGroup );\n    targetGroup = addUniqueGroup( \"->\" + grRight );\n\n    for( int i = 0; i < count(); i++ )\n    {\n      QString str = tabText( i );\n      if( str.length() == 7 && str.mid( 2, 3 ) == \" - \" && str.endsWith( grRight ) )\n        combineGroups( i, targetGroup );\n    }\n\n    setCurrentIndex( targetGroup );\n  }\n  else\n  if( result && result == combineTwoSidedAction )\n  {\n    setCurrentIndex( clickedGroup );\n    targetGroup = addUniqueGroup( name + \" - \" + grLeft );\n    QString str = grRight + \" - \" + grLeft;\n\n    for( int i = 0; i < count(); i++ )\n      if( tabText( i ) == name || tabText( i ) == str )\n        combineGroups( i, targetGroup );\n\n    setCurrentIndex( targetGroup );\n  }\n  else\n  if( result && ( result == combineFirstAction || result == combineSecondAction ) )\n  {\n    QString const & grBase = result == combineFirstAction ? grLeft : grRight;\n    setCurrentIndex( clickedGroup );\n    targetGroup = addUniqueGroup( grBase );\n\n    for( int i = 0; i < count(); i++ )\n    {\n      QString str = tabText( i );\n      if( str.length() == 7 && str.mid( 2, 3 ) == \" - \" &&\n          ( str.startsWith( grBase ) || str.endsWith( grBase ) ) )\n        combineGroups( i, targetGroup );\n    }\n\n    setCurrentIndex( targetGroup );\n  }\n\n  setUpdatesEnabled( true );\n}\n\nvoid DictGroupsWidget::tabDataChanged()\n{\n  QString toolTipStr = \"\\\"\" + tabText( currentIndex() ) + \"\\\"\\n\" + tr( \"Dictionaries: \" )\n                       + QString::number( getCurrentModel()->getCurrentDictionaries().size() );\n  setTabToolTip( currentIndex(), toolTipStr );\n}\n\nQuickFilterLine::QuickFilterLine( QWidget * parent ): ExtLineEdit( parent ), m_focusAction(this)\n{\n  m_proxyModel.setFilterCaseSensitivity( Qt::CaseInsensitive );\n\n#if QT_VERSION >= 0x040700\n  setPlaceholderText( tr( \"Dictionary search/filter (Ctrl+F)\" ) );\n#endif\n\n  m_focusAction.setShortcut( QKeySequence( \"Ctrl+F\" ) );\n  connect( &m_focusAction, SIGNAL( triggered() ),\n           this, SLOT( focusFilterLine() ) );\n\n  QPixmap image(\":/icons/system-search.png\");\n  setButtonPixmap(ExtLineEdit::Left, image.scaled(18, 18, Qt::KeepAspectRatio, Qt::SmoothTransformation));\n  setButtonToolTip(ExtLineEdit::Left, tr(\"Quick Search\"));\n  setButtonVisible(ExtLineEdit::Left, true);\n\n  QPixmap right(\":/icons/clear.png\");\n  setButtonPixmap(ExtLineEdit::Right, right);\n  setButtonToolTip(ExtLineEdit::Right, tr(\"Clear Search\"));\n  setButtonVisible(ExtLineEdit::Right, true);\n  setButtonAutoHide(ExtLineEdit::Right, true);\n  connect( this, SIGNAL( rightButtonClicked() ), this, SLOT( clear() ) );\n\n  setFocusPolicy(Qt::StrongFocus);\n\n  connect (this, SIGNAL( textChanged( QString const & ) ),\n      this, SLOT( filterChangedInternal() ) );\n}\n\nQuickFilterLine::~QuickFilterLine()\n{\n}\n\nvoid QuickFilterLine::applyTo( QAbstractItemView * source )\n{\n  m_source = source;\n  m_proxyModel.setSourceModel( source->model() );\n  source->setModel( &m_proxyModel );\n}\n\nQModelIndex QuickFilterLine::mapToSource( QModelIndex const & idx )\n{\n  if ( &m_proxyModel == idx.model() )\n  {\n    return m_proxyModel.mapToSource( idx );\n  }\n  else\n  {\n    return idx;\n  }\n}\n\nvoid QuickFilterLine::filterChangedInternal()\n{\n  // emit signal in async manner, to avoid UI slowdown\n  QTimer::singleShot( 1, this, SLOT( emitFilterChanged() ) );\n}\n\nvoid QuickFilterLine::emitFilterChanged()\n{\n  m_proxyModel.setFilterFixedString(text());\n  emit filterChanged( text() );\n}\n\nvoid QuickFilterLine::focusFilterLine()\n{\n  setFocus();\n  selectAll();\n}\n\nvoid QuickFilterLine::keyPressEvent( QKeyEvent * event )\n{\n  switch ( event->key() )\n  {\n    case Qt::Key_Down:\n      if ( m_source )\n      {\n        m_source->setCurrentIndex( m_source->model()->index( 0,0 ) );\n        m_source->setFocus();\n      }\n      break;\n    default:\n      ExtLineEdit::keyPressEvent( event );\n  }\n}\n"
        },
        {
          "name": "groups_widgets.hh",
          "type": "blob",
          "size": 6.458984375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __GROUPS_WIDGETS_HH_INCLUDED__\n#define __GROUPS_WIDGETS_HH_INCLUDED__\n\n// Various custom widgets used in the Groups dialog\n\n#include <vector>\n\n#include <QAction>\n#include <QListWidget>\n#include <QSortFilterProxyModel>\n\n#include \"config.hh\"\n#include \"dictionary.hh\"\n#include \"extlineedit.hh\"\n\n/// A model to be projected into the view, according to Qt's MVC model\nclass DictListModel: public QAbstractListModel\n{\n  Q_OBJECT\n\npublic:\n\n  DictListModel( QWidget * parent ):\n    QAbstractListModel( parent ), isSource( false ), allDicts( 0 )\n  {}\n\n  /// Populates the current model with the given dictionaries. This is\n  /// ought to be part of construction process.\n  void populate( std::vector< sptr< Dictionary::Class > > const & active,\n                 std::vector< sptr< Dictionary::Class > > const & available );\n  void populate( std::vector< sptr< Dictionary::Class > > const & active );\n\n  /// Marks that this model is used as an immutable dictionary source\n  void setAsSource();\n  bool sourceModel() const { return isSource; }\n\n  /// Returns the dictionaries the model currently has listed\n  std::vector< sptr< Dictionary::Class > > const & getCurrentDictionaries() const;\n\n  void removeSelectedRows( QItemSelectionModel * source );\n  void addSelectedUniqueFromModel( QItemSelectionModel * source );\n\n  Qt::ItemFlags flags( QModelIndex const &index ) const;\n  int rowCount( QModelIndex const & parent ) const;\n  QVariant data( QModelIndex const & index, int role ) const;\n  bool insertRows( int row, int count, const QModelIndex & parent );\n  bool removeRows( int row, int count, const QModelIndex & parent );\n  bool setData( QModelIndex const & index, const QVariant & value, int role );\n\n  void addRow(const QModelIndex & parent, sptr< Dictionary::Class > dict);\n\n  Qt::DropActions supportedDropActions() const;\n\n  void filterDuplicates();\n\nprivate:\n\n  bool isSource;\n  std::vector< sptr< Dictionary::Class > > dictionaries;\n  std::vector< sptr< Dictionary::Class > > const * allDicts;\n\nsignals:\n  void contentChanged();\n};\n\n/// This widget is for dictionaries' lists, it handles drag-n-drop operations\n/// with them etc.\nclass DictListWidget: public QListView\n{\n  Q_OBJECT\npublic:\n  DictListWidget( QWidget * parent );\n  ~DictListWidget();\n\n  /// Populates the current list with the given dictionaries.\n  void populate( std::vector< sptr< Dictionary::Class > > const & active,\n                 std::vector< sptr< Dictionary::Class > > const & available );\n  void populate( std::vector< sptr< Dictionary::Class > > const & active );\n\n  /// Marks that this widget is used as an immutable dictionary source\n  void setAsSource();\n\n  /// Returns the dictionaries the widget currently has listed\n  std::vector< sptr< Dictionary::Class > > const & getCurrentDictionaries() const;\n\n  DictListModel * getModel()\n  { return & model; }\n\nsignals:\n  void gotFocus();\n\nprotected:\n  virtual void dropEvent( QDropEvent * event );\n  virtual void focusInEvent(QFocusEvent *);\n\n  // We need these to to handle drag-and-drop focus issues\n  virtual void rowsInserted( QModelIndex const & parent, int start, int end );\n  virtual void rowsAboutToBeRemoved( QModelIndex const & parent, int start, int end );\n\nprivate:\n  DictListModel model;\n};\n\n#include \"ui_dictgroupwidget.h\"\n\n/// A widget that is placed into each tab in the Groups dialog.\nclass DictGroupWidget: public QWidget\n{\n  Q_OBJECT\n\npublic:\n  DictGroupWidget( QWidget * parent,\n                   std::vector< sptr< Dictionary::Class > > const &,\n                   Config::Group const & );\n\n  /// Makes the group's configuration out of the data currently held.\n  /// Since the group's name is not part of the widget by design right now\n  /// (it is known by the containing tab widget only), it is returned as empty.\n  Config::Group makeGroup() const;\n\n  DictListModel * getModel() const\n  { return ui.dictionaries->getModel(); }\n\n  QItemSelectionModel * getSelectionModel() const\n  { return ui.dictionaries->selectionModel(); }\n\nprivate slots:\n\n  void groupIconActivated( int );\n  void showDictInfo( const QPoint & pos );\n  void removeCurrentItem( QModelIndex const & );\n\nprivate:\n  Ui::DictGroupWidget ui;\n  unsigned groupId;\n\nsignals:\n  void showDictionaryInfo( QString const & id );\n};\n\n/// A tab widget with groups inside\nclass DictGroupsWidget: public QTabWidget\n{\n  Q_OBJECT\n\npublic:\n\n  DictGroupsWidget( QWidget * parent );\n\n  /// Creates all the tabs with the groups\n  void populate( Config::Groups const &,\n                 std::vector< sptr< Dictionary::Class > > const & allDicts,\n                 std::vector< sptr< Dictionary::Class > > const & activeDicts );\n\n  /// Creates new empty group with the given name\n  void addNewGroup( QString const & );\n\n  /// Creates new empty group with the given name if no such group\n  /// and return it index\n  int addUniqueGroup( QString const & name );\n\n  void addAutoGroups();\n\n  /// Returns currently chosen group's name\n  QString getCurrentGroupName() const;\n\n  /// Changes the name of the currently chosen group, if any, to the given one\n  void renameCurrentGroup( QString const & );\n\n  /// Removes the currently chosen group, if any\n  void removeCurrentGroup();\n\n  /// Removes all the groups\n  void removeAllGroups();\n\n  /// Creates groups from what is currently set up\n  Config::Groups makeGroups() const;\n\n  DictListModel * getCurrentModel() const;\n\n  QItemSelectionModel * getCurrentSelectionModel() const;\n\nprivate:\n\n  /// Add source group to target group\n  void combineGroups( int source, int target );\n\n  unsigned nextId;\n  std::vector< sptr< Dictionary::Class > > const * allDicts;\n  std::vector< sptr< Dictionary::Class > > const * activeDicts;\n\nprivate slots:\n  void contextMenu( QPoint const & );\n  void tabDataChanged();\n\nsignals:\n  void showDictionaryInfo( QString const & id );\n};\n\nclass QuickFilterLine: public ExtLineEdit\n{\n  Q_OBJECT\n\npublic:\n\n  QuickFilterLine( QWidget * parent );\n  ~QuickFilterLine();\n\n  /// Sets the source view to filter\n  void applyTo( QAbstractItemView * source );\n\n  QAction * getFocusAction() { return & m_focusAction; }\n\n  QModelIndex mapToSource( QModelIndex const & idx );\n\nprotected:\n  virtual void keyPressEvent( QKeyEvent * event );\n\nprivate:\n  QSortFilterProxyModel m_proxyModel;\n  QAction m_focusAction;\n  QAbstractItemView * m_source;\n\nprivate slots:\n  void filterChangedInternal();\n  void emitFilterChanged();\n  void focusFilterLine();\n\nsignals:\n  void filterChanged(QString const & filter);\n\n\n};\n\n#endif\n"
        },
        {
          "name": "guids.c",
          "type": "blob",
          "size": 2.1328125,
          "content": "#define INITGUID\n#include <basetyps.h>\n\nDEFINE_GUID(IID_IUIAutomation,            0x30cbe57d, 0xd9d0, 0x452a, 0xab, 0x13, 0x7a, 0xc5, 0xac, 0x48, 0x25, 0xee);\nDEFINE_GUID(CLSID_CUIAutomation,          0xff48dba4, 0x60ef, 0x4201, 0xaa, 0x87, 0x54, 0x10, 0x3e, 0xef, 0x59, 0x4e);\nDEFINE_GUID(IID_IUIAutomationElement,     0xd22108aa, 0x8ac5, 0x49a5, 0x83, 0x7b, 0x37, 0xbb, 0xb3, 0xd7, 0x59, 0x1e);\nDEFINE_GUID(IID_IUIAutomationTextPattern, 0x32eba289, 0x3583, 0x42c9, 0x9c, 0x59, 0x3b, 0x6d, 0x9a, 0x1e, 0x9b, 0x6a);\nDEFINE_GUID(IID_IUIAutomationTextRange,   0xa543cc6a, 0xf4ae, 0x494b, 0x82, 0x39, 0xc8, 0x14, 0x48, 0x11, 0x87, 0xa8);\nDEFINE_GUID(IID_IUIAutomationTreeWalker,  0x4042c624, 0x389c, 0x4afc, 0xa6, 0x30, 0x9d, 0xf8, 0x54, 0xa5, 0x41, 0xfc);\n\nDEFINE_GUID(CLSID_SpVoice,                0x96749377, 0x3391, 0x11D2, 0x9e, 0xe3, 0x00, 0xc0, 0x4f, 0x79, 0x73, 0x96);\nDEFINE_GUID(IID_ISpVoice,                 0x6C44DF74, 0x72B9, 0x4992, 0xa1, 0xec, 0xef, 0x99, 0x6e, 0x04, 0x22, 0xd4);\nDEFINE_GUID(CLSID_SpObjectToken,          0xEF411752, 0x3736, 0x4CB4, 0x9c, 0x8c, 0x8e, 0xf4, 0xcc, 0xb5, 0x8e, 0xfe);\nDEFINE_GUID(IID_ISpObjectToken,           0x14056589, 0xE16C, 0x11D2, 0xbb, 0x90, 0x00, 0xc0, 0x4f, 0x8e, 0xe6, 0xc0);\nDEFINE_GUID(CLSID_SpObjectTokenCategory,  0xA910187F, 0x0C7A, 0x45AC, 0x92, 0xcc, 0x59, 0xed, 0xaf, 0xb7, 0x7b, 0x53);\nDEFINE_GUID(IID_ISpObjectTokenCategory,   0x2D3D3845, 0x39AF, 0x4850, 0xbb, 0xf9, 0x40, 0xb4, 0x97, 0x80, 0x01, 0x1d);\nDEFINE_GUID(IID_IEnumSpObjectTokens,      0x06B64F9E, 0x7FDA, 0x11D2, 0xb4, 0xf2, 0x00, 0xc0, 0x4f, 0x79, 0x73, 0x96);\nDEFINE_GUID(IID_ISpEventSource,           0xBE7A9CCE, 0x5F9E, 0x11D2, 0x96, 0x0f, 0x00, 0xc0, 0x4f, 0x8e, 0xe6, 0x28);\nDEFINE_GUID(IID_ISpNotifySource,          0x5EFF4AEF, 0x8487, 0x11D2, 0x96, 0x1c, 0x00, 0xc0, 0x4f, 0x8e, 0xe6, 0x28);\nDEFINE_GUID(IID_ISpNotifySink,            0x259684DC, 0x37C3, 0x11D2, 0x96, 0x03, 0x00, 0xc0, 0x4f, 0x8e, 0xe6, 0x28);\nDEFINE_GUID(IID_ISpDataKey,               0x14056581, 0xE16C, 0x11D2, 0xbb, 0x90, 0x00, 0xc0, 0x4f, 0x8e, 0xe6, 0xc0);\nDEFINE_GUID(IID_ISpStreamFormat,          0xBED530BE, 0x2606, 0x4F4D, 0xa1, 0xc0, 0x54, 0xc5, 0xcd, 0xa5, 0x56, 0x6f);\n\n"
        },
        {
          "name": "help",
          "type": "tree",
          "content": null
        },
        {
          "name": "helpwindow.cc",
          "type": "blob",
          "size": 7.7890625,
          "content": "/* This file is (c) 2014 Abs62\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include <QDir>\n#include <QFileInfo>\n#include <QSplitter>\n#include <QHelpContentWidget>\n#include <QHelpIndexWidget>\n#include <QLayout>\n#include <QDesktopServices>\n\n#include \"helpwindow.hh\"\n#include \"gddebug.hh\"\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 15, 0 )\n#include <QHelpLink>\n#endif\n\nnamespace Help {\n\nHelpBrowser::HelpBrowser( QHelpEngineCore * engine, QWidget *parent ) :\n    QTextBrowser( parent ),\n    helpEngine( engine )\n{\n  connect( this, SIGNAL( anchorClicked( QUrl ) ), this, SLOT( linkClicked( QUrl ) ) );\n}\n\nvoid HelpBrowser::showHelpForKeyword( QString const & id )\n{\n  if ( helpEngine )\n  {\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 15, 0 )\n    auto const links = helpEngine->documentsForIdentifier( id );\n    if( !links.empty() )\n      setSource( links.constFirst().url );\n#else\n    QMap< QString, QUrl > links = helpEngine->linksForIdentifier( id );\n    if( !links.isEmpty() )\n      setSource( links.constBegin().value() );\n#endif\n  }\n}\n\nQVariant HelpBrowser::loadResource( int type, QUrl const & name )\n{\n  QByteArray ba;\n  if( type < 4 && helpEngine )\n  {\n    QUrl url(name);\n    if( name.isRelative() )\n      url = source().resolved( url );\n\n     ba = helpEngine->fileData(url );\n   }\n   return ba;\n}\n\nvoid HelpBrowser::linkClicked( QUrl const & url )\n{\n  if( url.scheme() == \"http\" || url.scheme() == \"https\" )\n  {\n    QDesktopServices::openUrl( url );\n  }\n  else\n    setSource( url );\n}\n\nHelpWindow::HelpWindow( QWidget * parent, Config::Class & cfg_ ) :\n  QDialog( parent ),\n  cfg( cfg_ ),\n  helpEngine( 0 )\n{\n  resize( QSize( 600, 450 ) );\n  setWindowTitle( tr( \"GoldenDict help\" ) );\n  setWindowFlags( windowFlags() & ~Qt::WindowContextHelpButtonHint );\n\n  QVBoxLayout * mainLayout = new QVBoxLayout( this );\n  setLayout( mainLayout );\n\n  navToolBar = new QToolBar( this );\n  navHome = navToolBar->addAction( QIcon( \":/icons/home.png\" ), tr( \"Home\" ) );\n  navToolBar->widgetForAction( navHome )->setObjectName( \"helpHomeButton\" );\n  navBack = navToolBar->addAction( QIcon( \":/icons/previous.png\" ), tr( \"Back\" ) );\n  navToolBar->widgetForAction( navBack )->setObjectName( \"helpBackButton\" );\n  navForward = navToolBar->addAction( QIcon( \":/icons/next.png\" ), tr( \"Forward\" ) );\n  navToolBar->widgetForAction( navForward )->setObjectName( \"helpForwardButton\" );\n\n  navToolBar->addSeparator();\n\n  zoomInAction = navToolBar->addAction( QIcon( \":/icons/icon32_zoomin\" ), tr( \"Zoom In\" ) );\n  navToolBar->widgetForAction( zoomInAction )->setObjectName( \"zoomInButton\" );\n  zoomOutAction = navToolBar->addAction( QIcon( \":/icons/icon32_zoomout\" ), tr( \"Zoom Out\" ) );\n  navToolBar->widgetForAction( zoomInAction )->setObjectName( \"zoomOutButton\" );\n  zoomBaseAction = navToolBar->addAction( QIcon( \":/icons/icon32_zoombase\" ), tr( \"Normal Size\" ) );\n  navToolBar->widgetForAction( zoomBaseAction )->setObjectName( \"zoomBaseButton\" );\n\n  navForward->setEnabled( false );\n  navBack->setEnabled( false );\n\n  mainLayout->addWidget( navToolBar );\n\n  QString localeName = cfg.preferences.helpLanguage;\n\n  if( localeName.isEmpty() )\n    localeName = cfg.preferences.interfaceLanguage;\n\n  if( localeName.isEmpty() )\n    localeName = QLocale::system().name();\n\n  QString helpDir = Config::getHelpDir();\n  helpFile = QDir::toNativeSeparators( helpDir + \"/gdhelp_\" + localeName + \".qch\" );\n\n  if( !QFileInfo( helpFile ).isFile() )\n    helpFile = QDir::toNativeSeparators( helpDir + \"/gdhelp_\" + localeName.left( 2 ) + \".qch\" );\n\n  if( !QFileInfo( helpFile ).isFile() )\n    helpFile = QDir::toNativeSeparators( helpDir + \"/gdhelp_en.qch\" );\n\n  helpCollectionFile = QDir::toNativeSeparators( Config::getConfigDir() + \"gdhelp.qhc\" );\n\n  helpEngine = new QHelpEngine( helpCollectionFile );\n\n  if( !helpEngine->setupData() )\n  {\n    gdWarning( \"Help engine initialization error: %s\", helpEngine->error().toUtf8().data() );\n    delete helpEngine;\n    helpEngine = 0;\n  }\n  else\n  {\n    if( !helpEngine->registerDocumentation( helpFile ) )\n    {\n      gdWarning( \"Help engine set file error: %s\", helpEngine->error().toUtf8().data() );\n    }\n\n    tabWidget = new QTabWidget( this );\n    tabWidget->addTab( helpEngine->contentWidget(), tr( \"Content\" ) );\n    tabWidget->addTab( helpEngine->indexWidget(), tr( \"Index\" ) );\n\n    helpBrowser = new HelpBrowser( helpEngine, this );\n\n    helpBrowser->setOpenLinks( false );\n\n    connect( helpEngine->contentWidget(), SIGNAL( linkActivated( QUrl ) ),\n             helpBrowser, SLOT( setSource( QUrl ) ) );\n    connect( helpEngine->indexWidget(), SIGNAL( linkActivated( QUrl, QString ) ),\n             helpBrowser, SLOT( setSource( QUrl ) ) );\n\n    connect( navHome, SIGNAL( triggered() ), helpBrowser, SLOT( home() ) );\n    connect( navForward, SIGNAL( triggered() ), helpBrowser, SLOT( forward() ) );\n    connect( navBack, SIGNAL( triggered() ), helpBrowser, SLOT( backward() ) );\n\n    connect( helpBrowser, SIGNAL( forwardAvailable( bool ) ),\n             this, SLOT( forwardEnabled( bool ) ) );\n\n    connect( helpBrowser, SIGNAL( backwardAvailable( bool ) ),\n             this, SLOT( backwardEnabled( bool ) ) );\n\n    connect( helpEngine->contentWidget(), SIGNAL( clicked( QModelIndex ) ),\n             this, SLOT( contentsItemClicked( QModelIndex ) ) );\n\n    connect( zoomInAction, SIGNAL( triggered( ) ), this, SLOT( zoomIn() ) );\n    connect( zoomOutAction, SIGNAL( triggered( ) ), this, SLOT( zoomOut() ) );\n    connect( zoomBaseAction, SIGNAL( triggered( ) ), this, SLOT( zoomBase() ) );\n\n    splitter = new QSplitter( this );\n    splitter->addWidget( tabWidget );\n    splitter->addWidget( helpBrowser );\n\n    splitter->setStretchFactor( 0, 1 );\n    splitter->setStretchFactor( 1, 4 );\n    mainLayout->addWidget( splitter );\n  }\n\n  if( !cfg.helpWindowGeometry.isEmpty() )\n    restoreGeometry( cfg.helpWindowGeometry );\n  if( !cfg.helpSplitterState.isEmpty() )\n    splitter->restoreState( cfg.helpSplitterState );\n\n  QFont f = helpBrowser->font();\n  fontSize = f.pointSize();\n  if( fontSize < 10 )\n  {\n    fontSize = 10;\n    f.setPointSize( fontSize );\n    helpBrowser->setFont( f );\n  }\n\n  applyZoomFactor();\n}\n\nHelpWindow::~HelpWindow()\n{\n  if( helpEngine )\n    delete helpEngine;\n\n  QFile f( helpCollectionFile );\n  f.remove();\n}\n\nvoid HelpWindow::reject()\n{\n  cfg.helpWindowGeometry = saveGeometry();\n  cfg.helpSplitterState = splitter->saveState();\n  emit needClose();\n}\n\nvoid HelpWindow::accept()\n{\n  cfg.helpWindowGeometry = saveGeometry();\n  cfg.helpSplitterState = splitter->saveState();\n  emit needClose();\n}\n\nvoid HelpWindow::showHelpFor( QString const & keyword )\n{\n  helpBrowser->showHelpForKeyword( keyword );\n}\n\nvoid HelpWindow::forwardEnabled( bool enabled )\n{\n  navForward->setEnabled( enabled );\n}\n\nvoid HelpWindow::backwardEnabled( bool enabled )\n{\n  navBack->setEnabled( enabled );\n}\n\nvoid HelpWindow::contentsItemClicked( QModelIndex const & index )\n{\n  QHelpContentItem * item = helpEngine->contentModel()->contentItemAt( index );\n  if( !item->url().isEmpty() )\n    helpBrowser->setSource( item->url() );\n}\n\nvoid HelpWindow::zoomIn()\n{\n  cfg.preferences.helpZoomFactor += 0.2;\n  applyZoomFactor();\n}\n\nvoid HelpWindow::zoomOut()\n{\n  cfg.preferences.helpZoomFactor -= 0.2;\n  applyZoomFactor();\n}\n\nvoid HelpWindow::zoomBase()\n{\n  cfg.preferences.helpZoomFactor = 1;\n  applyZoomFactor();\n}\n\nvoid HelpWindow::applyZoomFactor()\n{\n  if ( cfg.preferences.helpZoomFactor >= 5 )\n    cfg.preferences.helpZoomFactor = 5;\n  else if ( cfg.preferences.helpZoomFactor <= 0.2 )\n    cfg.preferences.helpZoomFactor = 0.2;\n\n  zoomInAction->setEnabled( cfg.preferences.helpZoomFactor < 5 );\n  zoomOutAction->setEnabled( cfg.preferences.helpZoomFactor > 0.2 );\n  zoomBaseAction->setEnabled( cfg.preferences.helpZoomFactor != 1.0 );\n\n  if( fontSize > 0 )\n  {\n    QFont f = helpBrowser->font();\n    f.setPointSize( fontSize * cfg.preferences.helpZoomFactor );\n    helpBrowser->setFont( f );\n  }\n}\n\n} // namespace Help\n"
        },
        {
          "name": "helpwindow.hh",
          "type": "blob",
          "size": 1.5341796875,
          "content": "#ifndef __HELPWINDOW_HH_INCLUDED__\n#define __HELPWINDOW_HH_INCLUDED__\n\n#include <QDialog>\n#include <QToolBar>\n#include <QtHelp/QHelpEngine>\n#include <QString>\n#include <QTextBrowser>\n#include <QTableWidget>\n#include <QAction>\n#include <QSplitter>\n\n#include <exception>\n\n#include \"config.hh\"\n\nnamespace Help {\n\nclass HelpBrowser : public QTextBrowser\n{\nQ_OBJECT\npublic:\n  HelpBrowser( QHelpEngineCore * engine, QWidget *parent );\n  void showHelpForKeyword( QString const & id );\nprivate:\n  QVariant loadResource( int type, QUrl const & name );\n  QHelpEngineCore * helpEngine;\n\nprivate slots:\n  void linkClicked( QUrl const & url );\n};\n\n\nclass HelpWindow : public QDialog\n{\nQ_OBJECT\n\n  Config::Class & cfg;\n  QToolBar * navToolBar;\n  QHelpEngine * helpEngine;\n  QTabWidget * tabWidget;\n  HelpBrowser * helpBrowser;\n  QAction * navForward, * navBack, * navHome;\n  QAction * zoomInAction, * zoomOutAction, * zoomBaseAction;\n  QSplitter * splitter;\n\n  QString helpFile, helpCollectionFile;\n\n  int fontSize;\n\n  void applyZoomFactor();\n\npublic:\n  HelpWindow( QWidget * parent, Config::Class & cfg_ );\n  ~HelpWindow();\n\n  QHelpEngine const * getHelpEngine()\n  { return helpEngine; }\n\n  void showHelpFor( QString const & keyword );\n\npublic slots:\n  virtual void reject();\n  virtual void accept();\n  void forwardEnabled( bool enabled );\n  void backwardEnabled( bool enabled );\n  void contentsItemClicked( QModelIndex const & index );\n\n  void zoomIn();\n  void zoomOut();\n  void zoomBase();\n\nsignals:\n  void needClose();\n};\n\n} // namespace Help\n\n#endif // __HELPWINDOW_HH_INCLUDED__\n"
        },
        {
          "name": "history.cc",
          "type": "blob",
          "size": 3.640625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"history.hh\"\n#include \"config.hh\"\n#include \"atomic_rename.hh\"\n#include <QFile>\n#include <QDebug>\n\nHistory::History( unsigned size, unsigned maxItemLength_ ): maxSize( size ),\n  maxItemLength( maxItemLength_ ), addingEnabled( true )\n, dirty( false )\n, timerId ( 0 )\n{\n}\n\nHistory::History( Load, unsigned size, unsigned maxItemLength_ ): maxSize( size ),\n   maxItemLength( maxItemLength_ ), addingEnabled( true )\n , dirty( false )\n , timerId ( 0 )\n{\n  QFile file( Config::getHistoryFileName() );\n\n  if ( !file.open( QFile::ReadOnly | QIODevice::Text ) )\n    return; // No file -- no history\n\n  for( unsigned count = 0 ; count < maxSize; ++count )\n  {\n    QByteArray lineUtf8 = file.readLine( 4096 );\n\n    if ( lineUtf8.endsWith( '\\n' ) )\n      lineUtf8.chop( 1 );\n\n    if ( lineUtf8.isEmpty() )\n      break;\n\n    QString line = QString::fromUtf8( lineUtf8 );\n\n    int firstSpace = line.indexOf( ' ' );\n\n    if ( firstSpace < 0 || firstSpace + 1 == line.size() )\n      // No spaces or value? Bad line. End this.\n      break;\n\n    bool isNumber;\n\n    unsigned groupId = line.left( firstSpace ).toUInt( &isNumber, 10 );\n\n    if ( !isNumber )\n      break; // That's not right\n\n    items.push_back( Item( groupId, line.right( line.size() - firstSpace - 1 ) ) );\n  }\n}\n\nHistory::Item History::getItem( int index )\n{\n  if ( index < 0 || index >= items.size() )\n  {\n    return Item();\n  }\n  return items.at( index );\n}\n\nvoid History::addItem( Item const & item )\n{\n  // qDebug() << \"adding item \" << item.word << \", enabled=\" << enabled();\n  if( !enabled() )\n    return;\n\n  if ( (unsigned)item.word.size() > getMaxItemLength() || item.word.isEmpty() )\n  {\n    // The search looks bogus. Don't save it.\n    return;\n  }\n\n  if ( items.contains( item ) )\n    items.removeAll( item );\n\n  // Special case: if this items differs from the previous one only by group,\n  // remove it too.\n\n  if ( items.size() && items.first().word == item.word )\n    items.pop_front();\n\n  items.push_front( item );\n\n  ensureSizeConstraints();\n\n  dirty = true;\n\n  emit itemsChanged();\n}\n\nbool History::ensureSizeConstraints()\n{\n  bool changed = false;\n  while( items.size() > (int)maxSize )\n  {\n    items.pop_back();\n    changed = true;\n    dirty = true;\n  }\n\n  return changed;\n}\n\nvoid History::setMaxSize( unsigned maxSize_ )\n{\n  maxSize = maxSize_;\n  if ( ensureSizeConstraints() )\n  {\n    emit itemsChanged();\n  }\n}\n\nint History::size() const\n{\n  return items.size();\n}\n\nbool History::save()\n{\n  if( !dirty )\n    return true;\n\n  QFile file( Config::getHistoryFileName() + \".tmp\" );\n\n  if ( !file.open( QFile::WriteOnly | QIODevice::Text ) )\n    return false;\n\n  for( QList< Item >::const_iterator i = items.constBegin();\n       i != items.constEnd(); ++i )\n  {\n    QByteArray line = i->word.toUtf8();\n\n    // Those could ruin our format, so we replace them by spaces. They shouldn't\n    // be there anyway.\n    line.replace( '\\n', ' ' );\n    line.replace( '\\r', ' ' );\n\n    line = QByteArray::number( i->groupId ) + \" \" + line + \"\\n\";\n\n    if ( file.write( line ) != line.size() )\n      return false;\n  }\n\n  file.close();\n\n  dirty = false;\n\n  return renameAtomically( file.fileName(), Config::getHistoryFileName() );\n}\n\nvoid History::clear()\n{\n  items.clear();\n  dirty = true;\n\n  emit itemsChanged();\n}\n\nvoid History::setSaveInterval( unsigned interval )\n{\n  if( timerId )\n  {\n    killTimer( timerId );\n    timerId = 0;\n  }\n  if( interval )\n  {\n    if( dirty )\n      save();\n    timerId = startTimer( interval * 60000 );\n  }\n}\n\nvoid History::timerEvent( QTimerEvent * ev )\n{\n  Q_UNUSED( ev );\n  save();\n}\n"
        },
        {
          "name": "history.hh",
          "type": "blob",
          "size": 3.0224609375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __HISTORY_HH_INCLUDED__\n#define __HISTORY_HH_INCLUDED__\n\n#include <QObject>\n#include <QList>\n#include <QString>\n\n#define DEFAULT_MAX_HISTORY_ITEM_LENGTH 256\n\n/// Search history\nclass History: public QObject\n{\n  Q_OBJECT\n\npublic:\n\n  /// An item in history\n  struct Item\n  {\n    /// Group the search was performed in\n    unsigned groupId;\n    /// The word that was searched\n    QString word;\n\n    Item(): groupId( 0 )\n    {}\n\n    Item( unsigned groupId_, QString const & word_ ):\n      groupId( groupId_ ), word( word_ )\n    {}\n\n    bool operator == ( Item const & other ) const\n    { return QString::compare( word, other.word, Qt::CaseInsensitive) == 0 && groupId == other.groupId; }\n\n    bool operator != ( Item const & other ) const\n    { return ! operator == ( other ); }\n  };\n\n  /// Indicates an intention to load -- see the relevant History constructor.\n  struct Load {};\n\n  /// Constructs an empty history which can hold at most \"size\" items.\n  History( unsigned size = 20 , unsigned maxItemLength = DEFAULT_MAX_HISTORY_ITEM_LENGTH );\n\n  /// Loads history from its file. If load fails, the result would be an empty\n  /// history. The size parameter is same as in other constructor.\n  History( Load, unsigned size = 20, unsigned maxItemLength = DEFAULT_MAX_HISTORY_ITEM_LENGTH );\n\n  /// Adds new item. The item is always added at the beginning of the list.\n  /// If there was such an item already somewhere on the list, it gets removed\n  /// from there. If otherwise the resulting list gets too large, the oldest\n  /// item gets removed from the end of the list.\n  void addItem( Item const & );\n\n  Item getItem( int index );\n\n  /// Remove item with given index from list\n  void removeItem( int index )\n  { items.removeAt( index ); dirty = true; emit itemsChanged(); }\n\n  /// Attempts saving history. Returns true if succeeded - false otherwise.\n  /// Since history isn't really that valuable, failures can be ignored.\n  bool save();\n\n  /// Clears history.\n  void clear();\n\n  /// History size.\n  int size() const;\n\n  /// Gets the current items. The first one is the newest one on the list.\n  QList< Item > const & getItems() const\n  { return items; }\n\n  /// Enable/disable add words to hystory\n  void enableAdd( bool enable )\n  { addingEnabled = enable; }\n  bool enabled()\n  { return addingEnabled; }\n\n  void setMaxSize( unsigned maxSize_ );\n\n  void setSaveInterval( unsigned interval );\n\n  unsigned getMaxSize()\n  { return maxSize; }\n\n  unsigned getMaxItemLength() const\n  { return maxItemLength; }\n\nsignals:\n\n  /// Signals the changes in items in response to addItem() or clear().\n  void itemsChanged();\n\nprivate:\n\n  /// Returns true if the items list has been modified\n  /// in order to fit into the constraints.\n  bool ensureSizeConstraints();\n\n  QList< Item > items;\n  unsigned maxSize;\n  unsigned maxItemLength;\n  bool addingEnabled;\n  bool dirty;\n  int timerId;\n\nprotected:\n  virtual void timerEvent( QTimerEvent * );\n};\n\n#endif\n"
        },
        {
          "name": "historypanewidget.cc",
          "type": "blob",
          "size": 7.9541015625,
          "content": "/* This file is (c) 2013 Tvangeste <i.4m.l33t@yandex.ru>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include <QDebug>\n#include <QApplication>\n#include <QDockWidget>\n#include <QKeyEvent>\n#include <QClipboard>\n#include <algorithm>\n#include <functional>\n\n#include \"historypanewidget.hh\"\n\nvoid HistoryPaneWidget::setUp( Config::Class * cfg,  History * history, QMenu * menu )\n{\n  m_cfg = cfg;\n  m_history = history;\n  m_historyList = findChild<QListView*>( \"historyList\" );\n  QDockWidget * historyPane = qobject_cast<QDockWidget*>( parentWidget() );\n\n  // Delete selected items action\n  m_deleteSelectedAction = new QAction( this );\n  m_deleteSelectedAction->setText( tr( \"&Delete Selected\" ) );\n  m_deleteSelectedAction->setShortcut( QKeySequence( QKeySequence::Delete ) );\n  m_deleteSelectedAction->setShortcutContext( Qt::WidgetWithChildrenShortcut );\n  addAction( m_deleteSelectedAction );\n  connect( m_deleteSelectedAction, SIGNAL( triggered() ),\n           this, SLOT( deleteSelectedItems() ) );\n\n  // Copy selected items to clipboard\n  m_copySelectedToClipboard = new QAction( this );\n  m_copySelectedToClipboard->setText( tr( \"Copy Selected\" ) );\n  m_copySelectedToClipboard->setShortcut( QKeySequence( QKeySequence::Copy ) );\n  m_copySelectedToClipboard->setShortcutContext( Qt::WidgetWithChildrenShortcut );\n  addAction( m_copySelectedToClipboard );\n  connect( m_copySelectedToClipboard, SIGNAL( triggered() ),\n           this, SLOT( copySelectedItems() ) );\n\n\n  // Handle context menu, reusing some of the top-level window's History menu\n  m_historyMenu = new QMenu( this );\n  m_separator = m_historyMenu->addSeparator();\n  QListIterator<QAction *> actionsIter( menu->actions() );\n  while ( actionsIter.hasNext() )\n    m_historyMenu->addAction( actionsIter.next() );\n\n  // Make the history pane's titlebar\n\n  historyLabel.setText( tr( \"History:\" ) );\n  historyLabel.setObjectName( \"historyLabel\" );\n  historyCountLabel.setObjectName( \"historyCountLabel\" );\n  if ( layoutDirection() == Qt::LeftToRight )\n  {\n    historyLabel.setAlignment( Qt::AlignLeft );\n    historyCountLabel.setAlignment( Qt::AlignRight );\n  }\n  else\n  {\n    historyLabel.setAlignment( Qt::AlignRight );\n    historyCountLabel.setAlignment( Qt::AlignLeft );\n  }\n  updateHistoryCounts();\n\n  historyPaneTitleBarLayout.addWidget( &historyLabel );\n  historyPaneTitleBarLayout.addWidget( &historyCountLabel );\n  historyPaneTitleBarLayout.setContentsMargins(5, 5, 5, 5);\n  historyPaneTitleBar.setLayout( &historyPaneTitleBarLayout );\n  historyPaneTitleBar.setObjectName(\"historyPaneTitleBar\");\n  historyPane->setTitleBarWidget( &historyPaneTitleBar );\n\n  // History list\n  HistoryModel * historyModel = new HistoryModel( m_history, this );\n  m_historyList->setModel( historyModel );\n  m_historyList->setContextMenuPolicy( Qt::CustomContextMenu );\n  // very important call, for performance reasons:\n  m_historyList->setUniformItemSizes( true );\n  m_historyList->setSelectionMode( QAbstractItemView::ExtendedSelection );\n  m_historyList->installEventFilter( this );\n  m_historyList->viewport()->installEventFilter( this );\n\n  // list selection and keyboard navigation\n  connect( m_historyList, SIGNAL( clicked( QModelIndex const & ) ),\n           this, SLOT( onItemClicked( QModelIndex const & ) ) );\n  connect( m_history, SIGNAL( itemsChanged() ),\n           this, SLOT( updateHistoryCounts() ) );\n  connect ( m_historyList->selectionModel(), SIGNAL( selectionChanged ( QItemSelection const & , QItemSelection const & ) ),\n      this, SLOT( onSelectionChanged( QItemSelection const & ) ) );\n\n  connect( m_historyList, SIGNAL( customContextMenuRequested( QPoint const & ) ),\n           this, SLOT( showCustomMenu( QPoint const & ) ) );\n\n  listItemDelegate = new WordListItemDelegate( m_historyList->itemDelegate() );\n  m_historyList->setItemDelegate( listItemDelegate );\n}\n\nHistoryPaneWidget::~HistoryPaneWidget()\n{\n  if( listItemDelegate )\n    delete listItemDelegate;\n}\n\nvoid HistoryPaneWidget::copySelectedItems()\n{\n  QModelIndexList selectedIdxs = m_historyList->selectionModel()->selectedIndexes();\n\n  if ( selectedIdxs.isEmpty() )\n  {\n    // nothing to do\n    return;\n  }\n\n  QStringList selectedStrings;\n  QListIterator<QModelIndex> i( selectedIdxs );\n  while ( i.hasNext() )\n  {\n    selectedStrings << m_historyList->model()->data( i.next() ).toString();\n  }\n\n  QApplication::clipboard()->setText( selectedStrings.join( QString::fromLatin1( \"\\n\" ) ) );\n}\n\nvoid HistoryPaneWidget::deleteSelectedItems()\n{\n  QModelIndexList selectedIdxs = m_historyList->selectionModel()->selectedIndexes();\n\n  if ( selectedIdxs.isEmpty() )\n  {\n    // nothing to do\n    return;\n  }\n\n  QList<int> idxsToDelete;\n\n  QListIterator<QModelIndex> i( selectedIdxs );\n  while ( i.hasNext() )\n  {\n    idxsToDelete << i.next().row();\n  }\n\n  // Need to sort indexes in the decreasing order so that\n  // the first deletions won't affect the indexes for subsequent deletions.\n  std::sort( idxsToDelete.begin(), idxsToDelete.end(), std::greater<int>() );\n\n  QListIterator<int> idxs( idxsToDelete );\n  while ( idxs.hasNext() )\n    m_history->removeItem( idxs.next() );\n\n  if ( idxsToDelete.size() == 1 )\n  {\n    // We've just removed a single entry,\n    // keep the selection at the same index.\n    m_historyList->setCurrentIndex(selectedIdxs.front());\n    m_historyList->selectionModel()->select(\n          selectedIdxs.front(), QItemSelectionModel::SelectCurrent );\n  }\n  else\n  {\n    // Too many deletions, better to reset the selection.\n    m_historyList->selectionModel()->reset();\n  }\n}\n\nbool HistoryPaneWidget::eventFilter( QObject * obj, QEvent * ev )\n{\n  // unused for now\n\n  return QWidget::eventFilter( obj, ev );\n}\n\nvoid HistoryPaneWidget::showCustomMenu(QPoint const & pos)\n{\n  bool selectionEmpty = m_historyList->selectionModel()->selection().empty();\n\n  m_historyMenu->removeAction( m_copySelectedToClipboard );\n  m_historyMenu->removeAction( m_deleteSelectedAction );\n\n  m_separator->setVisible( !selectionEmpty );\n\n  if ( !selectionEmpty )\n  {\n    m_historyMenu->insertAction( m_separator, m_copySelectedToClipboard );\n    m_historyMenu->insertAction( m_separator, m_deleteSelectedAction );\n  }\n\n  m_historyMenu->exec( m_historyList->mapToGlobal( pos ) );\n}\n\nvoid HistoryPaneWidget::emitHistoryItemRequested( QModelIndex const & idx )\n{\n  QVariant value = m_historyList->model()->data( idx );\n  if ( !value.isNull() )\n  {\n    emit historyItemRequested( value.toString() );\n  }\n}\n\nvoid HistoryPaneWidget::onSelectionChanged( QItemSelection const & selection )\n{\n  // qDebug() << \"selectionChanged\";\n\n  if ( selection.empty() )\n    return;\n\n  itemSelectionChanged = true;\n  emitHistoryItemRequested( selection.front().topLeft() );\n}\n\nvoid HistoryPaneWidget::onItemClicked( QModelIndex const & idx )\n{\n  // qDebug() << \"clicked\";\n\n  if ( !itemSelectionChanged )\n  {\n    emitHistoryItemRequested( idx );\n  }\n  itemSelectionChanged = false;\n}\n\nvoid HistoryPaneWidget::updateHistoryCounts()\n{\n  historyCountLabel.setText( tr( \"%1/%2\" ).\n                             arg( m_history->size() ).\n                             arg( m_cfg->preferences.maxStringsInHistory ) );\n  historyCountLabel.setToolTip(\n        tr( \"History size: %1 entries out of maximum %2\" ).\n        arg( m_history->size() ).\n        arg( m_cfg->preferences.maxStringsInHistory ));\n}\n\nHistoryModel::HistoryModel( History * history, QObject * parent )\n  : QAbstractListModel( parent ), m_history(history)\n{\n\n  connect( m_history, SIGNAL( itemsChanged() ),\n           this, SLOT( historyChanged() ) );\n\n}\n\nint HistoryModel::rowCount( QModelIndex const & /*parent*/ ) const\n{\n  return m_history->size();\n}\n\nQVariant HistoryModel::data( QModelIndex const & index, int role ) const\n{\n  // qDebug() << \"data: \" << index;\n\n  if ( !index.isValid() || index.row() >= m_history->size() )\n  {\n    return QVariant();\n  }\n\n  if ( role == Qt::DisplayRole || role == Qt::ToolTipRole )\n  {\n    return m_history->getItem( index.row() ).word;\n  }\n  else\n  {\n    return QVariant();\n  }\n}\n\nvoid HistoryModel::historyChanged()\n{\n//  qDebug() << \"History Changed!!\";\n\n  beginResetModel();\n  endResetModel();\n}\n"
        },
        {
          "name": "historypanewidget.hh",
          "type": "blob",
          "size": 2.1650390625,
          "content": "/* This file is (c) 2013 Tvangeste <i.4m.l33t@yandex.ru>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __HISTORYPANEWIDGET_HH_INCLUDED__\n#define __HISTORYPANEWIDGET_HH_INCLUDED__\n\n#include <QWidget>\n#include <QSize>\n#include <QAbstractListModel>\n#include <QListView>\n#include <QLabel>\n#include <QHBoxLayout>\n#include <QMenu>\n\n#include <config.hh>\n#include \"history.hh\"\n#include \"delegate.hh\"\n\n/// A widget holding the contents of the 'History' docklet.\nclass HistoryPaneWidget : public QWidget\n{\n  Q_OBJECT\npublic:\n  explicit HistoryPaneWidget( QWidget * parent = 0 ): QWidget( parent ),\n    itemSelectionChanged( false )\n  , listItemDelegate( 0 )\n  {}\n  virtual ~HistoryPaneWidget();\n\n  virtual QSize sizeHint() const\n  { return QSize( 204, 204 ); }\n\n  void setUp( Config::Class * cfg,  History * history, QMenu * menu );\n\nsignals:\n  void historyItemRequested( QString const & word );\n\npublic slots:\n  void updateHistoryCounts();\n\nprivate slots:\n  void emitHistoryItemRequested(QModelIndex const &);\n  void onSelectionChanged(QItemSelection const & selection);\n  void onItemClicked(QModelIndex const & idx);\n  void showCustomMenu(QPoint const & pos);\n  void deleteSelectedItems();\n  void copySelectedItems();\n\nprivate:\n  virtual bool eventFilter( QObject *, QEvent * );\n\n  Config::Class * m_cfg ;\n  History * m_history;\n  QListView * m_historyList;\n  QMenu * m_historyMenu;\n  QAction * m_deleteSelectedAction;\n  QAction * m_separator;\n  QAction * m_copySelectedToClipboard;\n\n  QWidget historyPaneTitleBar;\n  QHBoxLayout historyPaneTitleBarLayout;\n  QLabel historyLabel;\n  QLabel historyCountLabel;\n\n  /// needed to avoid multiple notifications\n  /// when selecting history items via mouse and keyboard\n  bool itemSelectionChanged;\n\n  WordListItemDelegate * listItemDelegate;\n};\n\nclass HistoryModel : public QAbstractListModel\n{\n  Q_OBJECT\npublic:\n  explicit HistoryModel( History * history , QObject * parent = 0 );\n\n  int rowCount( QModelIndex const & parent = QModelIndex() ) const;\n\n  QVariant data( QModelIndex const & index, int role = Qt::DisplayRole ) const;\n\nprivate slots:\n  void historyChanged();\n\nprivate:\n  History * m_history;\n};\n\n#endif // HISTORYPANEWIDGET_HH\n"
        },
        {
          "name": "hotkeyedit.cc",
          "type": "blob",
          "size": 5.8251953125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"hotkeyedit.hh\"\n#include <QKeyEvent>\n\n#ifdef Q_OS_WIN\n#include <windows.h>\n#endif\n\nHotKeyEdit::HotKeyEdit( QWidget * parent ):\n  QLineEdit( parent ),\n  currentModifiers(), currentKey1( 0 ), currentKey2( 0 ),\n  continuingCombo( false )\n{\n  renderCurrentValue();\n  installEventFilter( this );\n}\n\nvoid HotKeyEdit::setHotKey( Config::HotKey const & hk )\n{\n  currentModifiers = hk.modifiers;\n  currentKey1 = hk.key1;\n  currentKey2 = hk.key2;\n\n  renderCurrentValue();\n}\n\nConfig::HotKey HotKeyEdit::getHotKey() const\n{\n  Config::HotKey hk;\n\n  hk.modifiers = currentModifiers;\n  hk.key1 = currentKey1;\n  hk.key2 = currentKey2;\n\n  return hk;\n}\n\nvoid HotKeyEdit::renderCurrentValue()\n{\n  QString result;\n\n  if ( currentKey1 )\n  {\n    result = QKeySequence( currentKey1 | currentModifiers ).toString( QKeySequence::NativeText );\n\n    if ( currentKey2 )\n     result += \"+\" + QKeySequence( currentKey2 ).toString( QKeySequence::NativeText );\n  }\n\n  setText( result );\n}\n\nvoid HotKeyEdit::keyPressEvent( QKeyEvent * event )\n{\n  int key = event->key();\n  Qt::KeyboardModifiers modifiers = event->modifiers() & ~Qt::KeypadModifier;\n\n#ifdef Q_OS_WIN\n  if( objectName() == \"mainWindowHotkey\" || objectName() == \"clipboardHotkey\" )\n  {\n    int newkey = VkeyToQTkey( event->nativeVirtualKey() );\n    if( newkey )\n      key = newkey;\n  }\n#endif\n\n  switch( key )\n  {\n    case 0:\n    case Qt::Key_unknown:\n    case Qt::Key_Shift:\n    case Qt::Key_Control:\n    case Qt::Key_Meta:\n    case Qt::Key_Alt:\n    case Qt::Key_AltGr:\n      continuingCombo = false;\n      QLineEdit::keyPressEvent( event );\n    break;\n\n    default:\n    {\n      if ( !modifiers &&\n           ( ( key == Qt::Key_Backspace ) || ( key == Qt::Key_Delete  ) ) )\n      {\n        // Delete current combo\n        currentKey1 = 0;\n        currentKey2 = 0;\n        currentModifiers = Qt::KeyboardModifiers();\n        continuingCombo = false;\n      }\n      else\n      if ( !continuingCombo )\n      {\n        if ( modifiers || event->text().isEmpty() ) // Don't allow plain letters\n        {\n          currentKey2 = 0;\n          currentKey1 = key;\n          currentModifiers = modifiers;\n          continuingCombo = true;\n        }\n      }\n      else\n      {\n        currentKey2 = key;\n        continuingCombo = false;\n      }\n\n      renderCurrentValue();\n    }\n    break;\n  }\n}\n\nvoid HotKeyEdit::keyReleaseEvent( QKeyEvent * event )\n{\n  switch( event->key() )\n  {\n    case 0:\n    case Qt::Key_unknown:\n    case Qt::Key_Shift:\n    case Qt::Key_Control:\n    case Qt::Key_Meta:\n    case Qt::Key_Alt:\n    case Qt::Key_AltGr:\n      continuingCombo = false;\n    break;\n  }\n\n  QLineEdit::keyReleaseEvent( event );\n}\n\nbool HotKeyEdit::eventFilter( QObject *, QEvent * event )\n{\n  if( event->type() == QEvent::ShortcutOverride )\n  {\n    event->accept();\n    return true;\n  }\n  return false;\n}\n\n#ifdef Q_OS_WIN\n\nint HotKeyEdit::VkeyToQTkey( quint32 vkey )\n{\n  if ( vkey >= Qt::Key_A && vkey <= Qt::Key_Z)\n    return vkey;\n\n  switch( vkey )\n  {\n    case VK_NUMPAD0:     return Qt::Key_0;\n    case VK_NUMPAD1:     return Qt::Key_1;\n    case VK_NUMPAD2:     return Qt::Key_2;\n    case VK_NUMPAD3:     return Qt::Key_3;\n    case VK_NUMPAD4:     return Qt::Key_4;\n    case VK_NUMPAD5:     return Qt::Key_5;\n    case VK_NUMPAD6:     return Qt::Key_6;\n    case VK_NUMPAD7:     return Qt::Key_7;\n    case VK_NUMPAD8:     return Qt::Key_8;\n    case VK_NUMPAD9:     return Qt::Key_9;\n    case VK_DIVIDE:      return Qt::Key_Slash;\n    case VK_MULTIPLY:    return Qt::Key_Asterisk;\n    case VK_SUBTRACT:    return Qt::Key_Minus;\n    case VK_ADD:         return Qt::Key_Plus;\n    case VK_DECIMAL:     return Qt::Key_Period;\n    case VK_F1:          return Qt::Key_F1;\n    case VK_F2:          return Qt::Key_F2;\n    case VK_F3:          return Qt::Key_F3;\n    case VK_F4:          return Qt::Key_F4;\n    case VK_F5:          return Qt::Key_F5;\n    case VK_F6:          return Qt::Key_F6;\n    case VK_F7:          return Qt::Key_F7;\n    case VK_F8:          return Qt::Key_F8;\n    case VK_F9:          return Qt::Key_F9;\n    case VK_F10:         return Qt::Key_F10;\n    case VK_F11:         return Qt::Key_F11;\n    case VK_F12:         return Qt::Key_F12;\n    case VK_F13:         return Qt::Key_F13;\n    case VK_F14:         return Qt::Key_F14;\n    case VK_F15:         return Qt::Key_F15;\n    case VK_F16:         return Qt::Key_F16;\n    case VK_F17:         return Qt::Key_F17;\n    case VK_F18:         return Qt::Key_F18;\n    case VK_F19:         return Qt::Key_F19;\n    case VK_F20:         return Qt::Key_F20;\n    case VK_F21:         return Qt::Key_F21;\n    case VK_F22:         return Qt::Key_F22;\n    case VK_F23:         return Qt::Key_F23;\n    case VK_F24:         return Qt::Key_F24;\n    case 0x30:           return Qt::Key_ParenRight;\n    case 0x31:           return Qt::Key_Exclam;\n    case 0x32:           return Qt::Key_At;\n    case 0x33:           return Qt::Key_NumberSign;\n    case 0x34:           return Qt::Key_Dollar;\n    case 0x35:           return Qt::Key_Percent;\n    case 0x36:           return Qt::Key_AsciiCircum;\n    case 0x37:           return Qt::Key_Ampersand;\n    case 0x38:           return Qt::Key_copyright;\n    case 0x39:           return Qt::Key_ParenLeft;\n    case VK_OEM_MINUS:   return Qt::Key_Underscore;\n    case VK_OEM_PLUS:    return Qt::Key_Equal;\n    case VK_OEM_1:       return Qt::Key_Semicolon;\n    case VK_OEM_2:       return Qt::Key_Question;\n    case VK_OEM_3:       return Qt::Key_QuoteLeft;\n    case VK_OEM_4:       return Qt::Key_BracketLeft;\n    case VK_OEM_5:       return Qt::Key_Backslash;\n    case VK_OEM_6:       return Qt::Key_BracketRight;\n    case VK_OEM_7:       return Qt::Key_Apostrophe;\n    case VK_OEM_COMMA:   return Qt::Key_Less;\n    case VK_OEM_PERIOD:  return Qt::Key_Greater;\n\n    default:;\n  }\n\n  return 0;\n}\n\n#endif\n"
        },
        {
          "name": "hotkeyedit.hh",
          "type": "blob",
          "size": 0.818359375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __HOTKEYEDIT_HH_INCLUDED__\n#define __HOTKEYEDIT_HH_INCLUDED__\n\n#include \"config.hh\"\n#include <QLineEdit>\n\n// This widget allows grabbing a hotkey\nclass HotKeyEdit: public QLineEdit\n{\n  Q_OBJECT\n\n  Qt::KeyboardModifiers currentModifiers;\n  int currentKey1, currentKey2;\n\n  bool continuingCombo;\n\npublic:\n\n  HotKeyEdit( QWidget * parent = 0 );\n\n  void setHotKey( Config::HotKey const & );\n  Config::HotKey getHotKey() const;\n\nprotected:\n\n  void keyPressEvent( QKeyEvent * event );\n  void keyReleaseEvent( QKeyEvent * event );\n\nprivate:\n\n  void renderCurrentValue();\n  bool eventFilter( QObject *, QEvent * event );\n#ifdef Q_OS_WIN\n  int VkeyToQTkey( quint32 vkey );\n#endif\n};\n\n#endif\n"
        },
        {
          "name": "hotkeys.c",
          "type": "blob",
          "size": 5.0859375,
          "content": "#include <windows.h>\n#include \"hotkeys.h\"\n#include \"stdio.h\"\n\nstatic LRESULT CALLBACK lowLevelKeyboardProc(int, WPARAM, LPARAM);\n\n// Max number of hotkeys\n#define MAX_HOTKEYS 5\n\n// Max time interval between first and second part of hotkey (ms)\n#define MAX_KEYS_TIME_INTERVAL 500\n\nstatic HINSTANCE hInstance;\nstatic HWND hGDWindow;\nstatic HHOOK hKbdHook;\n\ntypedef struct HotkeyStruct\n{\n  DWORD key1;\n  DWORD key2;\n  DWORD mods;\n  DWORD lasttime;\n} HotkeyStruct;\n\nstatic HotkeyStruct hotkeys[ MAX_HOTKEYS ];\n\n__declspec (dllexport) void removeHook()\n{\n  if( hKbdHook )\n  {\n    UnhookWindowsHookEx( hKbdHook );\n    hKbdHook = 0;\n  }\n}\n\n__declspec (dllexport) BOOL setHook( HWND hwnd )\n{\n  hGDWindow = hwnd;\n  removeHook();\n  hKbdHook = SetWindowsHookEx( WH_KEYBOARD_LL, lowLevelKeyboardProc, hInstance, 0 );\n  return hKbdHook != 0;\n}\n\n__declspec (dllexport) BOOL setHotkeys( DWORD key1, DWORD key2, DWORD modifiers, int nom )\n{\n  if( nom < 0 || nom >= MAX_HOTKEYS )\n    return FALSE;\n  hotkeys[ nom ].key1 = key1;\n  hotkeys[ nom ].key2 = key2;\n  hotkeys[ nom ].mods = modifiers;\n  hotkeys[ nom ].lasttime = 0;\n  return TRUE;\n}\n\n__declspec (dllexport) void clearHotkeys()\n{\n  int i;\n  for( i = 0; i < MAX_HOTKEYS; i++ )\n    memset( hotkeys + i, 0, sizeof( HotkeyStruct ) );\n}\n\nstatic BOOL isModifiersPressed( DWORD modifiers )\n{\n  int n = GetAsyncKeyState( VK_MENU ) & 0x8000;\n  if( ( ( modifiers & MOD_ALT ) && n == 0 )\n      || ( ( modifiers & MOD_ALT ) == 0 && n ) )\n    return FALSE;\n\n  n = GetAsyncKeyState( VK_SHIFT ) & 0x8000;\n  if( ( ( modifiers & MOD_SHIFT ) && n == 0 )\n      || ( ( modifiers & MOD_SHIFT ) == 0 && n ) )\n    return FALSE;\n\n  n = GetAsyncKeyState( VK_CONTROL ) & 0x8000;\n  if( ( ( modifiers & MOD_CONTROL ) && n == 0 )\n      || ( ( modifiers & MOD_CONTROL ) == 0 && n ) )\n    return FALSE;\n\n  n = ( GetAsyncKeyState( VK_LWIN ) & 0x8000 ) | ( GetAsyncKeyState( VK_RWIN ) & 0x8000 );\n  if( ( ( modifiers & MOD_WIN ) && n == 0 )\n      || ( ( modifiers & MOD_WIN ) == 0 && n ) )\n    return FALSE;\n\n  return TRUE;\n}\n\nstatic LRESULT CALLBACK lowLevelKeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)\n{\nint i;\nPKBDLLHOOKSTRUCT p;\nBOOL stop = FALSE;\n\n  if ( nCode < 0 ) return CallNextHookEx( hKbdHook, nCode, wParam, lParam );\n\n  if( nCode == HC_ACTION )\n  {\n    p = (PKBDLLHOOKSTRUCT)lParam;\n\n    for( ; ; )\n    {\n      // Check hotkeys\n\n      if( wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN )\n      {\n        DWORD new_time = GetTickCount();\n\n        // Check if key is second part of hotkey\n\n        for( i = 0; i < MAX_HOTKEYS; i++ )\n        {\n          if( hotkeys[ i ].key1 == 0 )\n            break;\n          if( hotkeys[ i ].key2 == 0 || hotkeys[ i ].lasttime == 0 )\n            continue;\n          if( hotkeys[ i ].key2 == p->vkCode && isModifiersPressed( hotkeys[ i ].mods ) )\n          {\n            if( new_time - hotkeys[ i ].lasttime <= MAX_KEYS_TIME_INTERVAL )\n            {\n              // Hotkey completed\n              // Clear all flags for first part\n\n              int j;\n              for( j = 0; j < MAX_HOTKEYS; j++ )\n                hotkeys[ j ].lasttime = 0;\n\n              PostMessage( hGDWindow, GD_HOTKEY_MESSAGE, (WPARAM)i, 0 );\n\n              stop = TRUE;\n              break;\n            }\n            else\n            {\n              // Interval exceeded, reset time\n              hotkeys[ i ].lasttime = new_time;\n              continue;\n            }\n          }\n          else\n          {\n            // Key is not second part, clear flag\n            hotkeys[ i ].lasttime = 0;\n          }\n        }\n        if( stop )\n          break;\n\n        // Check if key is first part of hotkey\n\n        for( i = 0; i < MAX_HOTKEYS; i++ )\n        {\n          if( hotkeys[ i ].key1 == 0 )\n            break;\n          if( hotkeys[ i ].key1 == p->vkCode && isModifiersPressed( hotkeys[ i ].mods ) )\n          {\n            // Match found\n            if( hotkeys[ i ].key2 == 0 )\n            {\n              // No second part, hotkey completed\n\n              // Clear all flags for first part\n              int j;\n              for( j = 0; j < MAX_HOTKEYS; j++ )\n                hotkeys[ j ].lasttime = 0;\n\n              PostMessage( hGDWindow, GD_HOTKEY_MESSAGE, (WPARAM)i, 0 );\n\n              stop = TRUE;\n              break;\n            }\n            else\n            {\n              // First part detected, need wait for second part\n              hotkeys[ i ].lasttime = new_time;\n              break;\n            }\n          }\n        }\n      }\n      break;\n    }\n  }\n\n  LRESULT result = CallNextHookEx(hKbdHook, nCode, wParam, lParam);\n  return ( stop ? 1 : result );\n}\n\nBOOL APIENTRY DllMain (HINSTANCE hInst     /* Library instance handle. */ ,\n                       DWORD reason        /* Reason this function is being called. */ ,\n                       LPVOID reserved     /* Not used. */ )\n{\n(void) reserved;\n    switch (reason)\n    {\n      case DLL_PROCESS_ATTACH:\n        hInstance = hInst;\n        break;\n\n      case DLL_PROCESS_DETACH:\n        removeHook();\n        break;\n\n      case DLL_THREAD_ATTACH:\n        break;\n\n      case DLL_THREAD_DETACH:\n        break;\n    }\n\n    /* Returns TRUE on success, FALSE on failure */\n    return TRUE;\n}\n"
        },
        {
          "name": "hotkeys.h",
          "type": "blob",
          "size": 0.38671875,
          "content": "#ifndef __HOTKEYS_H_INCLUDED__\n#define __HOTKEYS_H_INCLUDED__\n\n#include <windows.h>\n\n// Message if hotkey completed; WPARAM - hotkey number\n#define GD_HOTKEY_MESSAGE ( WM_APP + 1 )\n\ntypedef BOOL ( *setHookProc )( HWND hwnd );\ntypedef void ( *removeHookProc )();\ntypedef BOOL ( *setHotkeysProc )( DWORD, DWORD, DWORD, int );\ntypedef void ( *clearHotkeysProc )();\n\n#endif // __HOTKEYS_H_INCLUDED__\n"
        },
        {
          "name": "hotkeys.pro",
          "type": "blob",
          "size": 0.3857421875,
          "content": "#-------------------------------------------------\n#\n# DLL for global hotkeys handling\n# Should be build for Windows only\n# Place GdHotkey.dll beside GoldenDict.exe\n#\n#-------------------------------------------------\n\nwin32 {\n  QT       -= core gui\n\n  TARGET = GdHotkeys\n  TEMPLATE = lib\n\n  DEFINES += HOTKEYS_LIBRARY\n\n  SOURCES += \\\n          hotkeys.c\n\n  HEADERS += \\\n          hotkeys.h \\\n}\n"
        },
        {
          "name": "hotkeywrapper.cc",
          "type": "blob",
          "size": 23.22265625,
          "content": "#ifdef __WIN32 // Q_OS_WIN32 isn't available at this point\r\n#define _WIN32_WINNT 0x0430\r\n#include <windows.h>\r\n#endif\r\n\r\n#include \"hotkeywrapper.hh\"\r\n#include \"gddebug.hh\"\r\n\r\n#include <QWidget>\r\n#include <QMainWindow>\r\n\r\n#ifdef Q_OS_WIN\r\n#include \"mainwindow.hh\"\r\n#endif\r\n\r\n//////////////////////////////////////////////////////////////////////////\r\n\r\nQHotkeyApplication::QHotkeyApplication( int & argc, char ** argv ):\r\n  QIntermediateApplication( argc, argv )\r\n#ifdef Q_OS_WIN32\r\n,  mainWindow( 0 )\r\n#endif\r\n{\r\n  connect( this, SIGNAL( commitDataRequest( QSessionManager& ) ),\r\n           this, SLOT( hotkeyAppCommitData( QSessionManager& ) ), Qt::DirectConnection );\r\n\r\n  connect( this, SIGNAL( saveStateRequest( QSessionManager& ) ),\r\n           this, SLOT( hotkeyAppSaveState( QSessionManager& ) ), Qt::DirectConnection );\r\n\r\n#if defined( Q_OS_WIN ) && IS_QT_5\r\n  installNativeEventFilter( this );\r\n#endif\r\n}\r\n\r\nQHotkeyApplication::QHotkeyApplication( QString const & id,\r\n                                        int & argc, char ** argv ):\r\n  QIntermediateApplication( id, argc, argv )\r\n#ifdef Q_OS_WIN32\r\n,  mainWindow( 0 )\r\n#endif\r\n{\r\n  connect( this, SIGNAL( commitDataRequest( QSessionManager& ) ),\r\n           this, SLOT( hotkeyAppCommitData( QSessionManager& ) ), Qt::DirectConnection );\r\n\r\n  connect( this, SIGNAL( saveStateRequest( QSessionManager& ) ),\r\n           this, SLOT( hotkeyAppSaveState( QSessionManager& ) ), Qt::DirectConnection );\r\n\r\n#if defined( Q_OS_WIN ) && IS_QT_5\r\n  installNativeEventFilter( this );\r\n#endif\r\n}\r\n\r\nvoid QHotkeyApplication::addDataCommiter( DataCommitter & d )\r\n{\r\n  dataCommitters.append( &d );\r\n}\r\n\r\nvoid QHotkeyApplication::removeDataCommiter( DataCommitter & d )\r\n{\r\n  dataCommitters.removeAll( &d );\r\n}\r\n\r\nvoid QHotkeyApplication::hotkeyAppCommitData( QSessionManager & mgr )\r\n{\r\n  for( int x = 0; x < dataCommitters.size(); ++x )\r\n    dataCommitters[ x ]->commitData( mgr );\r\n}\r\n\r\nvoid QHotkeyApplication::hotkeyAppSaveState(QSessionManager & mgr )\r\n{\r\n  mgr.setRestartHint( QSessionManager::RestartNever );\r\n}\r\n\r\nvoid QHotkeyApplication::registerWrapper(HotkeyWrapper *wrapper)\r\n{\r\n  if (wrapper && !hotkeyWrappers.contains(wrapper))\r\n    hotkeyWrappers.append(wrapper);\r\n}\r\n\r\nvoid QHotkeyApplication::unregisterWrapper(HotkeyWrapper *wrapper)\r\n{\r\n  if (wrapper && hotkeyWrappers.contains(wrapper))\r\n    hotkeyWrappers.removeAll(wrapper);\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////\r\n\r\nHotkeyStruct::HotkeyStruct( quint32 key_, quint32 key2_, quint32 modifier_,\r\n                            int handle_, int id_ ):\r\n  key( key_ ),\r\n  key2( key2_ ),\r\n  modifier( modifier_ ),\r\n  handle( handle_ ),\r\n  id( id_ )\r\n#ifdef Q_OS_MAC\r\n  , hkRef( 0 )\r\n  , hkRef2( 0 )\r\n#endif\r\n{\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////\r\n\r\n#if !defined(Q_OS_MAC) && !defined(Q_WS_QWS)\r\nHotkeyWrapper::HotkeyWrapper(QObject *parent) : QThread( parent ),\r\n    state2(false)\r\n{\r\n#ifdef Q_OS_WIN\r\n  hwnd=(HWND)((static_cast<QMainWindow*>(parent))->winId());\r\n\r\n  dllHandler.hDLLHandle = LoadLibraryA( \"GdHotkeys.dll\" );\r\n  if( dllHandler.hDLLHandle )\r\n  {\r\n    dllHandler.setHook = ( setHookProc )GetProcAddress( dllHandler.hDLLHandle, \"setHook\" );\r\n    dllHandler.removeHook = ( removeHookProc )GetProcAddress( dllHandler.hDLLHandle, \"removeHook\" );\r\n    dllHandler.setHotkeys = ( setHotkeysProc )GetProcAddress( dllHandler.hDLLHandle, \"setHotkeys\" );\r\n    dllHandler.clearHotkeys = ( clearHotkeysProc )GetProcAddress( dllHandler.hDLLHandle, \"clearHotkeys\" );\r\n\r\n    if( !dllHandler.setHook || !dllHandler.removeHook || !dllHandler.setHotkeys || !dllHandler.clearHotkeys )\r\n    {\r\n      FreeLibrary( dllHandler.hDLLHandle );\r\n      dllHandler.hDLLHandle = 0;\r\n    }\r\n  }\r\n\r\n  if( dllHandler.hDLLHandle )\r\n    gdWarning( \"Handle global hotkeys via GdHotkeys.dll\" );\r\n  else\r\n    gdWarning( \"Handle global hotkeys via RegisterHotkey()\" );\r\n\r\n#else\r\n  init();\r\n#endif\r\n  (static_cast<QHotkeyApplication*>(qApp))->registerWrapper(this);\r\n}\r\n\r\nHotkeyWrapper::~HotkeyWrapper()\r\n{\r\n  unregister();\r\n#ifdef Q_OS_WIN32\r\n  if( dllHandler.hDLLHandle )\r\n    FreeLibrary( dllHandler.hDLLHandle );\r\n#endif\r\n}\r\n\r\nvoid HotkeyWrapper::waitKey2()\r\n{\r\n  state2 = false;\r\n\r\n#ifdef HAVE_X11\r\n\r\n  if ( keyToUngrab != grabbedKeys.end() )\r\n  {\r\n    ungrabKey( keyToUngrab );\r\n    keyToUngrab = grabbedKeys.end();\r\n  }\r\n\r\n#endif\r\n}\r\n\r\nbool HotkeyWrapper::checkState(quint32 vk, quint32 mod)\r\n{\r\n  if ( state2 )\r\n  { // wait for 2nd key\r\n\r\n    waitKey2(); // Cancel the 2nd-key wait stage\r\n\r\n    if (state2waiter.key2 == vk && state2waiter.modifier == mod)\r\n    {\r\n      emit hotkeyActivated( state2waiter.handle );\r\n      return true;\r\n    }\r\n  }\r\n\r\n  for (int i = 0; i < hotkeys.count(); i++) {\r\n\r\n    const HotkeyStruct &hs = hotkeys.at(i);\r\n\r\n    if (hs.key == vk && hs.modifier == mod) {\r\n\r\n      #ifdef Q_OS_WIN32\r\n\r\n      if( hs.key2 != 0 || ( mod == MOD_CONTROL && ( vk == VK_INSERT || vk == 'c' || vk == 'C' ) ) )\r\n      {\r\n        // Pass-through first part of compound hotkey or clipdoard copy command\r\n\r\n        INPUT i[ 10 ];\r\n        memset( i, 0, sizeof( i ) );\r\n        int nextKeyNom = 0;\r\n        short emulateModKeys = 0;\r\n\r\n        // If modifier keys aren't pressed it looks like emulation\r\n        // We then also emulate full sequence\r\n\r\n        if( ( mod & MOD_ALT ) != 0 && ( GetAsyncKeyState( VK_MENU ) & 0x8000 ) == 0 )\r\n        {\r\n          emulateModKeys |= MOD_ALT;\r\n          i[ nextKeyNom ].type = INPUT_KEYBOARD;\r\n          i[ nextKeyNom ].ki.wVk = VK_MENU;\r\n          nextKeyNom += 1;\r\n        }\r\n        if( ( mod & MOD_CONTROL ) != 0 && ( GetAsyncKeyState( VK_CONTROL ) & 0x8000 ) == 0 )\r\n        {\r\n          emulateModKeys |= MOD_CONTROL;\r\n          i[ nextKeyNom ].type = INPUT_KEYBOARD;\r\n          i[ nextKeyNom ].ki.wVk = VK_CONTROL;\r\n          nextKeyNom += 1;\r\n        }\r\n        if( ( mod & MOD_SHIFT ) != 0 && ( GetAsyncKeyState( VK_SHIFT ) & 0x8000 ) == 0 )\r\n        {\r\n          emulateModKeys |= MOD_SHIFT;\r\n          i[ nextKeyNom ].type = INPUT_KEYBOARD;\r\n          i[ nextKeyNom ].ki.wVk = VK_SHIFT;\r\n          nextKeyNom += 1;\r\n        }\r\n        if( ( mod & MOD_WIN ) != 0 && ( GetAsyncKeyState( VK_LWIN ) & 0x8000 ) == 0\r\n            && ( GetAsyncKeyState( VK_RWIN ) & 0x8000 ) == 0 )\r\n        {\r\n          emulateModKeys |= MOD_WIN;\r\n          i[ nextKeyNom ].type = INPUT_KEYBOARD;\r\n          i[ nextKeyNom ].ki.wVk = VK_LWIN;\r\n          nextKeyNom += 1;\r\n        }\r\n\r\n        i[ nextKeyNom ].type = INPUT_KEYBOARD;\r\n        i[ nextKeyNom ].ki.wVk = vk;\r\n        nextKeyNom += 1;\r\n        i[ nextKeyNom ].type = INPUT_KEYBOARD;\r\n        i[ nextKeyNom ].ki.wVk = vk;\r\n        i[ nextKeyNom ].ki.dwFlags = KEYEVENTF_KEYUP;\r\n        nextKeyNom += 1;\r\n\r\n        if( emulateModKeys & MOD_WIN )\r\n        {\r\n          i[ nextKeyNom ].type = INPUT_KEYBOARD;\r\n          i[ nextKeyNom ].ki.wVk = VK_LWIN;\r\n          i[ nextKeyNom ].ki.dwFlags = KEYEVENTF_KEYUP;\r\n          nextKeyNom += 1;\r\n        }\r\n        if( emulateModKeys & MOD_SHIFT )\r\n        {\r\n          i[ nextKeyNom ].type = INPUT_KEYBOARD;\r\n          i[ nextKeyNom ].ki.wVk = VK_SHIFT;\r\n          i[ nextKeyNom ].ki.dwFlags = KEYEVENTF_KEYUP;\r\n          nextKeyNom += 1;\r\n        }\r\n        if( emulateModKeys & MOD_CONTROL )\r\n        {\r\n          i[ nextKeyNom ].type = INPUT_KEYBOARD;\r\n          i[ nextKeyNom ].ki.wVk = VK_CONTROL;\r\n          i[ nextKeyNom ].ki.dwFlags = KEYEVENTF_KEYUP;\r\n          nextKeyNom += 1;\r\n        }\r\n        if( emulateModKeys & MOD_ALT )\r\n        {\r\n          i[ nextKeyNom ].type = INPUT_KEYBOARD;\r\n          i[ nextKeyNom ].ki.wVk = VK_MENU;\r\n          i[ nextKeyNom ].ki.dwFlags = KEYEVENTF_KEYUP;\r\n          nextKeyNom += 1;\r\n        }\r\n\r\n        UnregisterHotKey( hwnd, hs.id );\r\n        SendInput( nextKeyNom, i, sizeof( *i ) );\r\n        RegisterHotKey(hwnd, hs.id, hs.modifier, hs.key);\r\n      }\r\n      #endif\r\n\r\n      if (hs.key2 == 0) {\r\n         emit hotkeyActivated( hs.handle );\r\n         return true;\r\n      }\r\n\r\n      state2 = true;\r\n      state2waiter = hs;\r\n      QTimer::singleShot(500, this, SLOT(waitKey2()));\r\n\r\n      #ifdef HAVE_X11\r\n\r\n      // Grab the second key, unless it's grabbed already\r\n      // Note that we only grab the clipboard key only if\r\n      // the sequence didn't begin with it\r\n\r\n      if ( ( isCopyToClipboardKey( hs.key, hs.modifier ) ||\r\n             !isCopyToClipboardKey( hs.key2, hs.modifier ) ) &&\r\n           !isKeyGrabbed( hs.key2, hs.modifier ) )\r\n        keyToUngrab = grabKey( hs.key2, hs.modifier );\r\n\r\n      #endif\r\n\r\n      return true;\r\n    }\r\n  }\r\n\r\n  state2 = false;\r\n  return false;\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////\r\n\r\n#ifdef Q_OS_WIN\r\n\r\nvoid HotkeyWrapper::init()\r\n{\r\n  QWidget *root = qApp->topLevelWidgets().value(0);\r\n  hwnd = (HWND)root->winId();\r\n}\r\n\r\nbool HotkeyWrapper::setGlobalKey( int key, int key2,\r\n                                  Qt::KeyboardModifiers modifier, int handle )\r\n{\r\n  if ( !key )\r\n    return false; // We don't monitor empty combinations\r\n\r\n  static int id = 0;\r\n  if( id > 0xBFFF - 1 )\r\n    id = 0;\r\n\r\n  quint32 mod = 0;\r\n  if (modifier & Qt::CTRL)\r\n    mod |= MOD_CONTROL;\r\n  if (modifier & Qt::ALT)\r\n    mod |= MOD_ALT;\r\n  if (modifier & Qt::SHIFT)\r\n    mod |= MOD_SHIFT;\r\n  if (modifier & Qt::META)\r\n    mod |= MOD_WIN;\r\n\r\n  quint32 vk = nativeKey( key );\r\n  quint32 vk2 = key2 ? nativeKey( key2 ) : 0;\r\n\r\n  hotkeys.append( HotkeyStruct( vk, vk2, mod, handle, id ) );\r\n\r\n  if( dllHandler.hDLLHandle )\r\n  {\r\n    dllHandler.removeHook();\r\n    dllHandler.setHotkeys( vk, vk2, mod, hotkeys.size() - 1 );\r\n    dllHandler.setHook( hwnd );\r\n    return true;\r\n  }\r\n\r\n  if (!RegisterHotKey(hwnd, id++, mod, vk))\r\n    return false;\r\n\r\n  if ( key2 && key2 != key )\r\n    return RegisterHotKey(hwnd, id++, mod, vk2);\r\n\r\n  return true;\r\n}\r\n\r\nbool HotkeyWrapper::winEvent ( MSG * message, long * result )\r\n{\r\n  (void) result;\r\n  if (message->message == WM_HOTKEY)\r\n    return checkState( (message->lParam >> 16), (message->lParam & 0xffff) );\r\n\r\n  if( message->message == GD_HOTKEY_MESSAGE )\r\n  {\r\n    int n = (int)message->wParam;\r\n    if( n < hotkeys.size() && n >= 0 )\r\n      emit hotkeyActivated( hotkeys.at( n ).handle );\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nquint32 HotkeyWrapper::nativeKey(int key)\r\n{\r\n  if (key >= Qt::Key_0 && key <= Qt::Key_9)\r\n    return VK_NUMPAD0 + ( key - Qt::Key_0 );\r\n\r\n  if (key >= Qt::Key_A && key <= Qt::Key_Z)\r\n    return key;\r\n\r\n  switch (key) {\r\n    case Qt::Key_Space:     return VK_SPACE;\r\n    case Qt::Key_Asterisk:  return VK_MULTIPLY;\r\n    case Qt::Key_Plus:      return VK_ADD;\r\n    case Qt::Key_Comma:     return VK_SEPARATOR;\r\n    case Qt::Key_Minus:     return VK_SUBTRACT;\r\n    case Qt::Key_Slash:     return VK_DIVIDE;\r\n    case Qt::Key_Tab:\r\n    case Qt::Key_Backtab:   return VK_TAB;\r\n    case Qt::Key_Backspace: return VK_BACK;\r\n    case Qt::Key_Return:\r\n    case Qt::Key_Escape:    return VK_ESCAPE;\r\n    case Qt::Key_Enter:     return VK_RETURN;\r\n    case Qt::Key_Insert:    return VK_INSERT;\r\n    case Qt::Key_Delete:    return VK_DELETE;\r\n    case Qt::Key_Pause:     return VK_PAUSE;\r\n    case Qt::Key_Print:     return VK_PRINT;\r\n    case Qt::Key_Clear:     return VK_CLEAR;\r\n    case Qt::Key_Home:      return VK_HOME;\r\n    case Qt::Key_End:       return VK_END;\r\n    case Qt::Key_Up:        return VK_UP;\r\n    case Qt::Key_Down:      return VK_DOWN;\r\n    case Qt::Key_Left:      return VK_LEFT;\r\n    case Qt::Key_Right:     return VK_RIGHT;\r\n    case Qt::Key_PageUp:    return VK_PRIOR;\r\n    case Qt::Key_PageDown:  return VK_NEXT;\r\n    case Qt::Key_F1:        return VK_F1;\r\n    case Qt::Key_F2:        return VK_F2;\r\n    case Qt::Key_F3:        return VK_F3;\r\n    case Qt::Key_F4:        return VK_F4;\r\n    case Qt::Key_F5:        return VK_F5;\r\n    case Qt::Key_F6:        return VK_F6;\r\n    case Qt::Key_F7:        return VK_F7;\r\n    case Qt::Key_F8:        return VK_F8;\r\n    case Qt::Key_F9:        return VK_F9;\r\n    case Qt::Key_F10:       return VK_F10;\r\n    case Qt::Key_F11:       return VK_F11;\r\n    case Qt::Key_F12:       return VK_F12;\r\n    case Qt::Key_F13:       return VK_F13;\r\n    case Qt::Key_F14:       return VK_F14;\r\n    case Qt::Key_F15:       return VK_F15;\r\n    case Qt::Key_F16:       return VK_F16;\r\n    case Qt::Key_F17:       return VK_F17;\r\n    case Qt::Key_F18:       return VK_F18;\r\n    case Qt::Key_F19:       return VK_F19;\r\n    case Qt::Key_F20:       return VK_F20;\r\n    case Qt::Key_F21:       return VK_F21;\r\n    case Qt::Key_F22:       return VK_F22;\r\n    case Qt::Key_F23:       return VK_F23;\r\n    case Qt::Key_F24:       return VK_F24;\r\n    case Qt::Key_Colon:\r\n    case Qt::Key_Semicolon:    return VK_OEM_1;\r\n    case Qt::Key_Question:     return VK_OEM_2;\r\n    case Qt::Key_AsciiTilde:\r\n    case Qt::Key_QuoteLeft:    return VK_OEM_3;\r\n    case Qt::Key_BraceLeft:\r\n    case Qt::Key_BracketLeft:  return VK_OEM_4;\r\n    case Qt::Key_Bar:\r\n    case Qt::Key_Backslash:    return VK_OEM_5;\r\n    case Qt::Key_BraceRight:\r\n    case Qt::Key_BracketRight: return VK_OEM_6;\r\n    case Qt::Key_QuoteDbl:\r\n    case Qt::Key_Apostrophe:   return VK_OEM_7;\r\n    case Qt::Key_Less:         return VK_OEM_COMMA;\r\n    case Qt::Key_Greater:      return VK_OEM_PERIOD;\r\n    case Qt::Key_Equal:        return VK_OEM_PLUS;\r\n    case Qt::Key_ParenRight:   return 0x30;\r\n    case Qt::Key_Exclam:       return 0x31;\r\n    case Qt::Key_At:           return 0x32;\r\n    case Qt::Key_NumberSign:   return 0x33;\r\n    case Qt::Key_Dollar:       return 0x34;\r\n    case Qt::Key_Percent:      return 0x35;\r\n    case Qt::Key_AsciiCircum:  return 0x36;\r\n    case Qt::Key_Ampersand:    return 0x37;\r\n    case Qt::Key_copyright:    return 0x38;\r\n    case Qt::Key_ParenLeft:    return 0x39;\r\n    case Qt::Key_Underscore:   return VK_OEM_MINUS;\r\n    default:;\r\n  }\r\n\r\n  return key;\r\n}\r\n\r\nvoid HotkeyWrapper::unregister()\r\n{\r\n  if( dllHandler.hDLLHandle )\r\n  {\r\n    dllHandler.removeHook();\r\n    dllHandler.clearHotkeys();\r\n  }\r\n  else\r\n  {\r\n    for (int i = 0; i < hotkeys.count(); i++)\r\n    {\r\n      HotkeyStruct const & hk = hotkeys.at( i );\r\n\r\n      UnregisterHotKey( hwnd, hk.id );\r\n\r\n      if ( hk.key2 && hk.key2 != hk.key )\r\n        UnregisterHotKey( hwnd, hk.id+1 );\r\n    }\r\n  }\r\n\r\n  (static_cast<QHotkeyApplication*>(qApp))->unregisterWrapper(this);\r\n}\r\n\r\n\r\n#if IS_QT_5\r\n\r\nbool QHotkeyApplication::nativeEventFilter( const QByteArray & /*eventType*/, void * message, long * result )\r\n{\r\n  MSG * msg = reinterpret_cast< MSG * >( message );\r\n\r\n  if ( msg->message == WM_HOTKEY || msg->message == GD_HOTKEY_MESSAGE )\r\n  {\r\n    for (int i = 0; i < hotkeyWrappers.size(); i++)\r\n    {\r\n      if ( hotkeyWrappers.at(i)->winEvent( msg, result ) )\r\n        return true;\r\n    }\r\n  }\r\n\r\n  if( mainWindow )\r\n  {\r\n    if( ( static_cast< MainWindow * >( mainWindow ) )->handleGDMessage( msg, result ) )\r\n      return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n#else // IS_QT_5\r\n\r\nbool QHotkeyApplication::winEventFilter ( MSG * message, long * result )\r\n{\r\n  if (message->message == WM_HOTKEY || message->message == GD_HOTKEY_MESSAGE)\r\n  {\r\n    for (int i = 0; i < hotkeyWrappers.size(); i++)\r\n    {\r\n      if ( hotkeyWrappers.at(i)->winEvent( message, result ) )\r\n        return true;\r\n    }\r\n  }\r\n\r\n  if( mainWindow )\r\n  {\r\n    if( ( static_cast< MainWindow * >( mainWindow ) )->handleGDMessage( message, result ) )\r\n      return true;\r\n  }\r\n\r\n  return QApplication::winEventFilter( message, result );\r\n}\r\n\r\n#endif\r\n\r\n//////////////////////////////////////////////////////////////////////////\r\n\r\n#else\r\n\r\n//////////////////////////////////////////////////////////////////////////\r\n\r\n#include <X11/keysym.h>\r\n\r\nvoid HotkeyWrapper::init()\r\n{\r\n  keyToUngrab = grabbedKeys.end();\r\n\r\n  // We use RECORD extension instead of XGrabKey. That's because XGrabKey\r\n  // prevents other clients from getting their input if it's grabbed.\r\n\r\n  Display * display = QX11Info::display();\r\n\r\n  lShiftCode = XKeysymToKeycode( display, XK_Shift_L );\r\n  rShiftCode = XKeysymToKeycode( display, XK_Shift_R );\r\n\r\n  lCtrlCode = XKeysymToKeycode( display, XK_Control_L );\r\n  rCtrlCode = XKeysymToKeycode( display, XK_Control_R );\r\n\r\n  lAltCode = XKeysymToKeycode( display, XK_Alt_L );\r\n  rAltCode = XKeysymToKeycode( display, XK_Alt_R );\r\n\r\n  lMetaCode = XKeysymToKeycode( display, XK_Super_L );\r\n  rMetaCode = XKeysymToKeycode( display, XK_Super_R );\r\n\r\n  cCode = XKeysymToKeycode( display, XK_c );\r\n  insertCode = XKeysymToKeycode( display, XK_Insert );\r\n  kpInsertCode = XKeysymToKeycode( display, XK_KP_Insert );\r\n\r\n  currentModifiers = 0;\r\n\r\n  // This one will be used to read the recorded content\r\n  dataDisplay = XOpenDisplay( 0 );\r\n\r\n  if ( !dataDisplay )\r\n    throw exInit();\r\n\r\n  recordRange = XRecordAllocRange();\r\n\r\n  if ( !recordRange )\r\n  {\r\n    XCloseDisplay( dataDisplay );\r\n    throw exInit();\r\n  }\r\n\r\n  recordRange->device_events.first = KeyPress;\r\n  recordRange->device_events.last = KeyRelease;\r\n  recordClientSpec = XRecordAllClients;\r\n\r\n  recordContext = XRecordCreateContext( display, 0,\r\n                                        &recordClientSpec, 1,\r\n                                        &recordRange, 1 );\r\n\r\n  if ( !recordContext )\r\n  {\r\n    XFree( recordRange );\r\n    XCloseDisplay( dataDisplay );\r\n    throw exInit();\r\n  }\r\n\r\n  // This is required to ensure context was indeed created\r\n  XSync( display, False );\r\n\r\n  connect( this, SIGNAL( keyRecorded( quint32, quint32 ) ),\r\n           this, SLOT( checkState( quint32, quint32 ) ),\r\n           Qt::QueuedConnection );\r\n\r\n  start();\r\n}\r\n\r\nvoid HotkeyWrapper::run() // Runs in a separate thread\r\n{\r\n  if ( !XRecordEnableContext( dataDisplay, recordContext,\r\n                              recordEventCallback,\r\n                              (XPointer) this ) )\r\n    GD_DPRINTF( \"Failed to enable record context\\n\" );\r\n}\r\n\r\n\r\nvoid HotkeyWrapper::recordEventCallback( XPointer ptr, XRecordInterceptData * data )\r\n{\r\n  ((HotkeyWrapper * )ptr)->handleRecordEvent( data );\r\n}\r\n\r\nvoid HotkeyWrapper::handleRecordEvent( XRecordInterceptData * data )\r\n{\r\n  if ( data->category == XRecordFromServer )\r\n  {\r\n    xEvent * event = ( xEvent * ) data->data;\r\n\r\n    if ( event->u.u.type == KeyPress )\r\n    {\r\n      KeyCode key = event->u.u.detail;\r\n\r\n      if ( key == lShiftCode ||\r\n           key == rShiftCode )\r\n        currentModifiers |= ShiftMask;\r\n      else\r\n      if ( key == lCtrlCode ||\r\n           key == rCtrlCode )\r\n        currentModifiers |= ControlMask;\r\n      else\r\n      if ( key == lAltCode ||\r\n           key == rAltCode )\r\n        currentModifiers |= Mod1Mask;\r\n      else\r\n      if ( key == lMetaCode ||\r\n           key == rMetaCode )\r\n        currentModifiers |= Mod4Mask;\r\n      else\r\n      {\r\n        // Here we employ a kind of hack translating KP_Insert key\r\n        // to just Insert. This allows reacting to both Insert keys.\r\n        if ( key == kpInsertCode )\r\n          key = insertCode;\r\n\r\n        emit keyRecorded( key, currentModifiers );\r\n      }\r\n    }\r\n    else\r\n    if ( event->u.u.type == KeyRelease )\r\n    {\r\n      KeyCode key = event->u.u.detail;\r\n\r\n      if ( key == lShiftCode ||\r\n           key == rShiftCode )\r\n        currentModifiers &= ~ShiftMask;\r\n      else\r\n      if ( key == lCtrlCode ||\r\n           key == rCtrlCode )\r\n        currentModifiers &= ~ControlMask;\r\n      else\r\n      if ( key == lAltCode ||\r\n           key == rAltCode )\r\n        currentModifiers &= ~Mod1Mask;\r\n      else\r\n      if ( key == lMetaCode ||\r\n           key == rMetaCode )\r\n        currentModifiers &= ~Mod4Mask;\r\n    }\r\n  }\r\n\r\n  XRecordFreeData( data );\r\n}\r\n\r\nbool HotkeyWrapper::setGlobalKey( int key, int key2,\r\n                                  Qt::KeyboardModifiers modifier, int handle )\r\n{\r\n  if ( !key )\r\n    return false; // We don't monitor empty combinations\r\n\r\n  int vk = nativeKey( key );\r\n  int vk2 = key2 ? nativeKey( key2 ) : 0;\r\n\r\n  quint32 mod = 0;\r\n  if (modifier & Qt::ShiftModifier)\r\n      mod |= ShiftMask;\r\n  if (modifier & Qt::ControlModifier)\r\n      mod |= ControlMask;\r\n  if (modifier & Qt::AltModifier)\r\n      mod |= Mod1Mask;\r\n  if (modifier & Qt::MetaModifier)\r\n      mod |= Mod4Mask;\r\n\r\n  hotkeys.append( HotkeyStruct( vk, vk2, mod, handle, 0 ) );\r\n\r\n  if ( !isCopyToClipboardKey( vk, mod ) )\r\n    grabKey( vk, mod ); // Make sure it doesn't get caught by other apps\r\n\r\n  return true;\r\n}\r\n\r\nbool HotkeyWrapper::isCopyToClipboardKey( quint32 keyCode, quint32 modifiers ) const\r\n{\r\n  return modifiers == ControlMask &&\r\n         ( keyCode == cCode || keyCode == insertCode || keyCode == kpInsertCode );\r\n}\r\n\r\nbool HotkeyWrapper::isKeyGrabbed( quint32 keyCode, quint32 modifiers ) const\r\n{\r\n  GrabbedKeys::const_iterator i = grabbedKeys.find( std::make_pair( keyCode, modifiers ) );\r\n\r\n  return i != grabbedKeys.end();\r\n}\r\n\r\nnamespace {\r\n\r\ntypedef int (*X11ErrorHandler) ( Display * display, XErrorEvent * event );\r\n\r\nclass X11GrabUngrabErrorHandler {\r\npublic:\r\n  static bool error;\r\n\r\n  static int grab_ungrab_error_handler( Display *, XErrorEvent * event )\r\n  {\r\n    qDebug() << \"grab_ungrab_error_handler is invoked\";\r\n    switch ( event->error_code )\r\n    {\r\n      case BadAccess:\r\n      case BadValue:\r\n      case BadWindow:\r\n        if ( event->request_code == 33 /* X_GrabKey */ ||\r\n             event->request_code == 34 /* X_UngrabKey */)\r\n        {\r\n          error = true;\r\n        }\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  X11GrabUngrabErrorHandler()\r\n  {\r\n    error = false;\r\n    previousErrorHandler_ = XSetErrorHandler( grab_ungrab_error_handler );\r\n  }\r\n\r\n  ~X11GrabUngrabErrorHandler()\r\n  {\r\n    XFlush( QX11Info::display() );\r\n    (void) XSetErrorHandler( previousErrorHandler_ );\r\n  }\r\n\r\n  bool isError() const\r\n  {\r\n    XFlush( QX11Info::display() );\r\n    return error;\r\n  }\r\n\r\nprivate:\r\n  X11ErrorHandler previousErrorHandler_;\r\n};\r\n\r\nbool X11GrabUngrabErrorHandler::error = false;\r\n\r\n} // anonymous namespace\r\n\r\n\r\nHotkeyWrapper::GrabbedKeys::iterator HotkeyWrapper::grabKey( quint32 keyCode,\r\n                                                             quint32 modifiers )\r\n{\r\n  std::pair< GrabbedKeys::iterator, bool > result =\r\n    grabbedKeys.insert( std::make_pair( keyCode, modifiers ) );\r\n\r\n\r\n  if ( result.second )\r\n  {\r\n    X11GrabUngrabErrorHandler errorHandler;\r\n    XGrabKey( QX11Info::display(), keyCode, modifiers, QX11Info::appRootWindow(),\r\n              True, GrabModeAsync, GrabModeAsync );\r\n\r\n    if ( errorHandler.isError() )\r\n    {\r\n      gdWarning( \"Possible hotkeys conflict. Check your hotkeys options.\" );\r\n      ungrabKey( result.first );\r\n    }\r\n  }\r\n\r\n  return result.first;\r\n}\r\n\r\nvoid HotkeyWrapper::ungrabKey( GrabbedKeys::iterator i )\r\n{\r\n  X11GrabUngrabErrorHandler errorHandler;\r\n  XUngrabKey( QX11Info::display(), i->first, i->second, QX11Info::appRootWindow() );\r\n\r\n  grabbedKeys.erase( i );\r\n\r\n  if ( errorHandler.isError() )\r\n  {\r\n    gdWarning( \"Cannot ungrab the hotkey\" );\r\n  }\r\n}\r\n\r\nquint32 HotkeyWrapper::nativeKey(int key)\r\n{\r\n  QString keySymName;\r\n\r\n  switch( key )\r\n  {\r\n    case Qt::Key_Insert:\r\n      keySymName = \"Insert\";\r\n    break;\r\n    default:\r\n      keySymName = QKeySequence( key ).toString();\r\n    break;\r\n  }\r\n\r\n  Display * display = QX11Info::display();\r\n  return XKeysymToKeycode( display, XStringToKeysym( keySymName.toLatin1().data() ) );\r\n}\r\n\r\nvoid HotkeyWrapper::unregister()\r\n{\r\n  Display * display = QX11Info::display();\r\n\r\n  XRecordDisableContext( display, recordContext );\r\n  XSync( display, False );\r\n\r\n  wait();\r\n\r\n  XRecordFreeContext( display, recordContext );\r\n  XFree( recordRange );\r\n  XCloseDisplay( dataDisplay );\r\n\r\n  while( grabbedKeys.size() )\r\n    ungrabKey( grabbedKeys.begin() );\r\n\r\n  (static_cast<QHotkeyApplication*>(qApp))->unregisterWrapper(this);\r\n}\r\n\r\n#endif\r\n#endif\r\n"
        },
        {
          "name": "hotkeywrapper.hh",
          "type": "blob",
          "size": 6.236328125,
          "content": "#ifndef HOTKEYWRAPPER_H\r\n#define HOTKEYWRAPPER_H\r\n\r\n#include <QtGui>\r\n\r\n#ifdef HAVE_X11\r\n\r\n#include <set>\r\n\r\n#include <X11/Xlib.h>\r\n#include <X11/extensions/record.h>\r\n#include <QX11Info>\r\n#include <X11/Xlibint.h>\r\n\r\n#undef Bool\r\n#undef min\r\n#undef max\r\n\r\n#endif\r\n\r\n#ifdef Q_OS_MAC\r\n#define __SECURITYHI__\r\n#include <Carbon/Carbon.h>\r\n#endif\r\n\r\n#include \"ex.hh\"\r\n#include \"qtsingleapplication.h\"\r\n#include \"qt4x5.hh\"\r\n\r\n#ifdef Q_OS_WIN32\r\n#include \"hotkeys.h\"\r\n#endif\r\n\r\n//////////////////////////////////////////////////////////////////////////\r\n\r\nstruct HotkeyStruct\r\n{\r\n  HotkeyStruct() {}\r\n  HotkeyStruct( quint32 key, quint32 key2, quint32 modifier, int handle, int id );\r\n\r\n  quint32 key, key2;\r\n  quint32 modifier;\r\n  int handle;\r\n  int id;\r\n#ifdef Q_OS_MAC\r\n  EventHotKeyRef hkRef, hkRef2;\r\n#endif\r\n};\r\n\r\n//////////////////////////////////////////////////////////////////////////\r\n\r\n#if !defined(Q_WS_QWS)\r\nclass HotkeyWrapper : public QThread // Thread is actually only used on X11\r\n{\r\n  Q_OBJECT\r\n\r\n  friend class QHotkeyApplication;\r\n\r\npublic:\r\n\r\n  DEF_EX( exInit, \"Hotkey wrapper failed to init\", std::exception )\r\n\r\n  HotkeyWrapper(QObject *parent);\r\n  virtual ~HotkeyWrapper();\r\n\r\n  /// The handle is passed back in hotkeyActivated() to inform which hotkey\r\n  /// was activated.\r\n  bool setGlobalKey( int key, int key2, Qt::KeyboardModifiers modifier,\r\n                     int handle );\r\n\r\n  /// Unregisters everything\r\n  void unregister();\r\n#ifdef Q_OS_WIN32\r\n  bool handleViaDLL()\r\n  { return dllHandler.hDLLHandle != 0; }\r\n#endif\r\n\r\nsignals:\r\n\r\n  void hotkeyActivated( int );\r\n\r\nprotected slots:\r\n\r\n  void waitKey2();\r\n\r\n#ifndef Q_OS_MAC\r\nprivate slots:\r\n\r\n  bool checkState( quint32 vk, quint32 mod );\r\n#endif\r\n\r\nprivate:\r\n\r\n  void init();\r\n  quint32 nativeKey(int key);\r\n\r\n  QList<HotkeyStruct> hotkeys;\r\n\r\n  bool state2;\r\n  HotkeyStruct state2waiter;\r\n\r\n#ifdef Q_OS_WIN32\r\n  virtual bool winEvent ( MSG * message, long * result );\r\n  HWND hwnd;\r\n\r\n  struct DLL_HANDLER\r\n  {\r\n    HMODULE hDLLHandle;\r\n    setHookProc setHook;\r\n    removeHookProc removeHook;\r\n    setHotkeysProc setHotkeys;\r\n    clearHotkeysProc clearHotkeys;\r\n  };\r\n\r\n  DLL_HANDLER dllHandler;\r\n\r\n#elif defined(Q_OS_MAC)\r\n\r\npublic:\r\n  void activated( int hkId );\r\nprivate:\r\n  void sendCmdC();\r\n\r\n  static EventHandlerUPP hotKeyFunction;\r\n  quint32 keyC;\r\n  EventHandlerRef handlerRef;\r\n\r\n#else\r\n\r\n  static void recordEventCallback( XPointer, XRecordInterceptData * );\r\n\r\n  /// Called by recordEventCallback()\r\n  void handleRecordEvent( XRecordInterceptData * );\r\n\r\n  void run(); // QThread\r\n\r\n  // We do one-time init of those, translating keysyms to keycodes\r\n  KeyCode lShiftCode, rShiftCode, lCtrlCode, rCtrlCode, lAltCode, rAltCode,\r\n          cCode, insertCode, kpInsertCode, lMetaCode, rMetaCode;\r\n\r\n  quint32 currentModifiers;\r\n\r\n  Display * dataDisplay;\r\n  XRecordRange * recordRange;\r\n  XRecordContext recordContext;\r\n  XRecordClientSpec recordClientSpec;\r\n\r\n  /// Holds all the keys currently grabbed.\r\n  /// The first value is keycode, the second is modifiers\r\n  typedef std::set< std::pair< quint32, quint32 > > GrabbedKeys;\r\n  GrabbedKeys grabbedKeys;\r\n\r\n  GrabbedKeys::iterator keyToUngrab; // Used for second stage grabs\r\n\r\n  /// Returns true if the given key is usually used to copy from clipboard,\r\n  /// false otherwise.\r\n  bool isCopyToClipboardKey( quint32 keyCode, quint32 modifiers ) const;\r\n  /// Returns true if the given key is grabbed, false otherwise\r\n  bool isKeyGrabbed( quint32 keyCode, quint32 modifiers ) const;\r\n  /// Grabs the given key, recording the fact in grabbedKeys. If the key's\r\n  /// already grabbed, does nothing.\r\n  /// Returns the key's iterator in grabbedKeys.\r\n  GrabbedKeys::iterator grabKey( quint32 keyCode, quint32 modifiers );\r\n  /// Ungrabs the given key. erasing it from grabbedKeys. The key's provided\r\n  /// as an interator inside the grabbedKeys set.\r\n  void ungrabKey( GrabbedKeys::iterator );\r\n\r\nsignals:\r\n\r\n  /// Emitted from the thread\r\n  void keyRecorded( quint32 vk, quint32 mod );\r\n\r\n#endif\r\n};\r\n#else\r\n\r\nclass HotkeyWrapper : public QObject\r\n{\r\n  Q_OBJECT\r\n\r\n  friend class QHotkeyApplication;\r\n\r\npublic:\r\n\r\n  DEF_EX( exInit, \"Hotkey wrapper failed to init\", std::exception )\r\n\r\n  HotkeyWrapper(QObject *parent): QObject( parent )\r\n  {}\r\n\r\n  bool setGlobalKey( int key, int key2, Qt::KeyboardModifiers modifier,\r\n                     int handle )\r\n  { return true; }\r\n\r\n  void unregister()\r\n  {}\r\n\r\nsignals:\r\n\r\n  void hotkeyActivated( int );\r\n};\r\n#endif\r\n\r\n//////////////////////////////////////////////////////////////////////////\r\n\r\nclass DataCommitter\r\n{\r\npublic:\r\n\r\n  virtual void commitData( QSessionManager & )=0;\r\n  virtual ~DataCommitter()\r\n  {}\r\n};\r\n\r\n// Intermediate class to avoid misunderstanding of #ifdef's\r\n// by Qt meta-object compiler\r\n\r\nclass QIntermediateApplication : public QtSingleApplication\r\n#if defined( Q_OS_WIN ) && IS_QT_5\r\n        , public QAbstractNativeEventFilter\r\n#endif\r\n{\r\npublic:\r\n  QIntermediateApplication( int & argc, char ** argv ) :\r\n    QtSingleApplication( argc, argv )\r\n  {}\r\n\r\n  QIntermediateApplication( QString const & id, int & argc, char ** argv ) :\r\n    QtSingleApplication( id, argc, argv )\r\n  {}\r\n};\r\n\r\nclass QHotkeyApplication : public QIntermediateApplication\r\n{\r\n  Q_OBJECT\r\n\r\n  friend class HotkeyWrapper;\r\n\r\n  QList< DataCommitter * > dataCommitters;\r\n\r\npublic:\r\n  QHotkeyApplication( int & argc, char ** argv );\r\n  QHotkeyApplication( QString const & id, int & argc, char ** argv );\r\n\r\n  void addDataCommiter( DataCommitter & );\r\n  void removeDataCommiter( DataCommitter & );\r\n\r\nprivate slots:\r\n  /// This calls all data committers.\r\n  void hotkeyAppCommitData( QSessionManager & );\r\n\r\n  void hotkeyAppSaveState( QSessionManager & );\r\n\r\nprotected:\r\n  void registerWrapper(HotkeyWrapper *wrapper);\r\n  void unregisterWrapper(HotkeyWrapper *wrapper);\r\n\r\n#ifdef Q_OS_WIN32\r\n#if IS_QT_5\r\n  virtual bool nativeEventFilter( const QByteArray & eventType, void * message, long * result );\r\n#else // IS_QT_5\r\n  virtual bool winEventFilter ( MSG * message, long * result );\r\n#endif // IS_QT_5\r\n\r\n  QWidget * mainWindow;\r\npublic:\r\n  void setMainWindow( QWidget * widget )\r\n  { mainWindow = widget; }\r\nprotected:\r\n#endif // Q_OS_WIN32\r\n  QList<HotkeyWrapper*> hotkeyWrappers;\r\n};\r\n\r\n//////////////////////////////////////////////////////////////////////////\r\n\r\n#endif // HOTKEYWRAPPER_H\r\n"
        },
        {
          "name": "htmlescape.cc",
          "type": "blob",
          "size": 3.8251953125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include <QString>\n#include <QTextDocumentFragment>\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n#include <QRegularExpression>\n#else\n#include <QRegExp>\n#endif\n\n#include \"htmlescape.hh\"\n\nnamespace Html {\n\nstring escape( string const & str )\n{\n  string result( str );\n\n  for( size_t x = result.size(); x--; )\n    switch ( result[ x ] )\n    {\n      case '&':\n        result.erase( x, 1 );\n        result.insert( x, \"&amp;\" );\n      break;\n\n      case '<':\n        result.erase( x, 1 );\n        result.insert( x, \"&lt;\" );\n      break;\n\n      case '>':\n        result.erase( x, 1 );\n        result.insert( x, \"&gt;\" );\n      break;\n\n      case '\"':\n        result.erase( x, 1 );\n        result.insert( x, \"&quot;\" );\n      break;\n\n      default:\n      break;\n    }\n\n  return result;\n}\n\nstatic void storeLineInDiv( string & result, string const & line, bool baseRightToLeft )\n{\n  result += \"<div\";\n  if( unescape( QString::fromUtf8( line.c_str(), line.size() ) ).isRightToLeft() != baseRightToLeft )\n  {\n    result += \" dir=\\\"\";\n    result += baseRightToLeft ? \"ltr\\\"\" : \"rtl\\\"\";\n  }\n  result += \">\";\n  result += line + \"</div>\";\n}\n\nstring preformat(string const & str , bool baseRightToLeft )\n{\n  string escaped = escape( str ), result, line;\n\n  line.reserve( escaped.size() );\n  result.reserve( escaped.size() );\n\n  bool leading = true;\n\n  for( char const * nextChar = escaped.c_str(); *nextChar; ++nextChar )\n  {\n    if ( leading )\n    {\n      if ( *nextChar == ' ' )\n      {\n        line += \"&nbsp;\";\n        continue;\n      }\n      else\n      if ( *nextChar == '\\t' )\n      {\n        line += \"&nbsp;&nbsp;&nbsp;&nbsp;\";\n        continue;\n      }\n    }\n\n    if ( *nextChar == '\\n' )\n    {\n      storeLineInDiv( result, line, baseRightToLeft );\n      line.clear();\n      leading = true;\n      continue;\n    }\n\n    if ( *nextChar == '\\r' )\n      continue; // Just skip all \\r\n\n    line.push_back( *nextChar );\n\n    leading = false;\n  }\n\n  if( !line.empty() )\n    storeLineInDiv( result, line, baseRightToLeft );\n\n  return result;\n}\n\nstring escapeForJavaScript( string const & str )\n{\n  string result( str );\n\n  for( size_t x = result.size(); x--; )\n    switch ( result[ x ] )\n    {\n      case '\\\\':\n      case '\"':\n      case '\\'':\n        result.insert( x, 1, '\\\\' );\n      break;\n\n      case '\\n':\n        result.erase( x, 1 );\n        result.insert( x, \"\\\\n\" );\n      break;\n\n      case '\\r':\n        result.erase( x, 1 );\n        result.insert( x, \"\\\\r\" );\n      break;\n\n      case '\\t':\n        result.erase( x, 1 );\n        result.insert( x, \"\\\\t\" );\n      break;\n\n      default:\n      break;\n    }\n\n  return result;\n}\n\nQString unescape( QString const & str, bool saveFormat )\n{\n  // Does it contain HTML? If it does, we need to strip it\n  if ( str.contains( '<' ) || str.contains( '&' ) )\n  {\n    QString tmp = str;\n    if( !saveFormat )\n    {\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n        tmp.replace( QRegularExpression( \"<(?:\\\\s*/?(?:div|h[1-6r]|q|p(?![alr])|br|li(?![ns])|td|blockquote|[uo]l|pre|d[dl]|nav|address))[^>]{0,}>\",\n                                         QRegularExpression::CaseInsensitiveOption ), \" \" );\n        tmp.remove( QRegularExpression( \"<[^>]*>\" ) );\n#else\n      tmp.replace( QRegExp( \"<(?:\\\\s*/?(?:div|h[1-6r]|q|p(?![alr])|br|li(?![ns])|td|blockquote|[uo]l|pre|d[dl]|nav|address))[^>]{0,}>\",\n                            Qt::CaseInsensitive, QRegExp::RegExp2 ), \" \" );\n      tmp.remove( QRegExp( \"<[^>]*>\", Qt::CaseSensitive, QRegExp::RegExp2 ) );\n#endif\n    }\n    return QTextDocumentFragment::fromHtml( tmp.trimmed() ).toPlainText();\n  }\n  return str;\n}\n\nstring unescapeUtf8( const string &str, bool saveFormat )\n{\n  return string( unescape( QString::fromUtf8( str.c_str(), str.size() ) ).toUtf8().data(), saveFormat );\n}\n\n}\n"
        },
        {
          "name": "htmlescape.hh",
          "type": "blob",
          "size": 0.966796875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __HTMLESCAPE_HH_INCLUDED__\n#define __HTMLESCAPE_HH_INCLUDED__\n\n#include <string>\n\nnamespace Html {\n\nusing std::string;\n\n// Replaces &, <, > and \" by their html entity equivalents\n// The \" is not really required to be escaped in html, but is replaced anyway\n// to make the result suitable for inserting as attributes' values.\nstring escape( string const & );\n\n// Converts the given preformatted text to html. Each end of line is replaced by\n// <br>, each leading space is converted to &nbsp;.\nstring preformat( string const &, bool baseRightToLeft = false );\n\n// Escapes the given string to be included in JavaScript.\nstring escapeForJavaScript( string const & );\n\n// Replace html entities\nQString unescape( QString const & str, bool saveFormat = false );\nstring unescapeUtf8( string const & str, bool saveFormat = false );\n\n}\n\n#endif\n"
        },
        {
          "name": "hunspell.cc",
          "type": "blob",
          "size": 23.1083984375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"hunspell.hh\"\n#include \"utf8.hh\"\n#include \"htmlescape.hh\"\n#include \"iconv.hh\"\n#include \"folding.hh\"\n#include \"wstring_qt.hh\"\n#include \"language.hh\"\n#include \"langcoder.hh\"\n\n#include <QRunnable>\n#include <QThreadPool>\n#include <QSemaphore>\n#include <QRegExp>\n#include <QDir>\n#include <QCoreApplication>\n#include <QFileInfo>\n\n#include <set>\n#include <hunspell/hunspell.hxx>\n#include \"gddebug.hh\"\n#include \"fsencoding.hh\"\n#include \"qt4x5.hh\"\n\nnamespace HunspellMorpho {\n\nusing namespace Dictionary;\n\nusing gd::wchar;\n\nnamespace {\n\nclass HunspellDictionary: public Dictionary::Class\n{\n  string name;\n  Hunspell hunspell;\n\n#ifdef Q_OS_WIN32\n  static string Utf8ToLocal8Bit( string const & name )\n  {\n    return string( QString::fromUtf8( name.c_str() ).toLocal8Bit().data() );\n  }\n#endif\n\npublic:\n\n  /// files[ 0 ] should be .aff file, files[ 1 ] should be .dic file.\n  HunspellDictionary( string const & id, string const & name_,\n                      vector< string > const & files ):\n    Dictionary::Class( id, files ),\n    name( name_ ),\n#ifdef Q_OS_WIN32\n    hunspell( Utf8ToLocal8Bit( files[ 0 ] ).c_str(), Utf8ToLocal8Bit( files[ 1 ] ).c_str() )\n#else\n    hunspell( files[ 0 ].c_str(), files[ 1 ].c_str() )\n#endif\n  {\n  }\n\n  virtual string getName() throw()\n  { return name; }\n\n  virtual map< Property, string > getProperties() throw()\n  { return map< Property, string >(); }\n\n  virtual unsigned long getArticleCount() throw()\n  { return 0; }\n\n  virtual unsigned long getWordCount() throw()\n  { return 0; }\n\n  virtual sptr< WordSearchRequest > prefixMatch( wstring const &,\n                                                 unsigned long maxResults )\n    THROW_SPEC( std::exception );\n\n  virtual sptr< WordSearchRequest > findHeadwordsForSynonym( wstring const & )\n    THROW_SPEC( std::exception );\n\n  virtual sptr< DataRequest > getArticle( wstring const &,\n                                          vector< wstring > const & alts,\n                                          wstring const &,\n                                          bool )\n    THROW_SPEC( std::exception );\n\n  virtual bool isLocalDictionary()\n  { return true; }\n\n  virtual vector< wstring > getAlternateWritings( const wstring & word ) throw();\n\nprotected:\n\n  virtual void loadIcon() throw();\n\nprivate:\n\n  // We used to have a separate mutex for each Hunspell instance, assuming\n  // that its code was reentrant (though probably not thread-safe). However,\n  // crashes were discovered later when using several Hunspell dictionaries\n  // simultaneously, and we've switched to have a single mutex for all hunspell\n  // calls - evidently it's not really reentrant.\n  static Mutex & getHunspellMutex()\n  {\n    static Mutex mutex;\n    return mutex;\n  }\n//  Mutex hunspellMutex;\n};\n\n/// Encodes the given string to be passed to the hunspell object. May throw\n/// Iconv::Ex\nstring encodeToHunspell( Hunspell &, wstring const & );\n\n/// Decodes the given string returned by the hunspell object. May throw\n/// Iconv::Ex\nwstring decodeFromHunspell( Hunspell &, char const * );\n\n/// Generates suggestions via hunspell\nQVector< wstring > suggest( wstring & word, Mutex & hunspellMutex,\n                            Hunspell & hunspell );\n\n/// Generates suggestions for compound expression\nvoid getSuggestionsForExpression( wstring const & expression,\n                                  vector< wstring > & suggestions,\n                                  Mutex & hunspellMutex,\n                                  Hunspell & hunspell );\n\n/// Returns true if the string contains whitespace, false otherwise\nbool containsWhitespace( wstring const & str )\n{\n  wchar const * next = str.c_str();\n\n  for( ; *next; ++next )\n    if ( Folding::isWhitespace( *next ) )\n      return true;\n\n  return false;\n}\n\nvoid HunspellDictionary::loadIcon() throw()\n{\n  if ( dictionaryIconLoaded )\n    return;\n\n  QString fileName =\n    QDir::fromNativeSeparators( FsEncoding::decode( getDictionaryFilenames()[ 0 ].c_str() ) );\n\n  // Remove the extension\n  fileName.chop( 3 );\n\n  if( !loadIconFromFile( fileName ) )\n  {\n    // Load failed -- use default icons\n    dictionaryNativeIcon = dictionaryIcon = QIcon(\":/icons/icon32_hunspell.png\");\n  }\n\n  dictionaryIconLoaded = true;\n}\n\nvector< wstring > HunspellDictionary::getAlternateWritings( wstring const & word ) throw()\n{\n  vector< wstring > results;\n\n  if( containsWhitespace( word ) )\n  {\n    getSuggestionsForExpression( word, results, getHunspellMutex(), hunspell );\n  }\n\n  return results;\n}\n\n/// HunspellDictionary::getArticle()\n\nclass HunspellArticleRequest;\n\nclass HunspellArticleRequestRunnable: public QRunnable\n{\n  HunspellArticleRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  HunspellArticleRequestRunnable( HunspellArticleRequest & r_,\n                                  QSemaphore & hasExited_ ): r( r_ ),\n                                                             hasExited( hasExited_ )\n  {}\n\n  ~HunspellArticleRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass HunspellArticleRequest: public Dictionary::DataRequest\n{\n  friend class HunspellArticleRequestRunnable;\n\n  Mutex & hunspellMutex;\n  Hunspell & hunspell;\n  wstring word;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  HunspellArticleRequest( wstring const & word_,\n                          Mutex & hunspellMutex_,\n                          Hunspell & hunspell_ ):\n    hunspellMutex( hunspellMutex_ ),\n    hunspell( hunspell_ ),\n    word( word_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new HunspellArticleRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by HunspellArticleRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~HunspellArticleRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid HunspellArticleRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid HunspellArticleRequest::run()\n{\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n#ifdef OLD_HUNSPELL_INTERFACE\n  // We'd need to free this if it gets allocated and an exception shows up\n  char ** suggestions = 0;\n  int suggestionsCount = 0;\n#else\n  vector< string > suggestions;\n#endif\n\n  try\n  {\n    wstring trimmedWord = Folding::trimWhitespaceOrPunct( word );\n\n    if ( containsWhitespace( trimmedWord ) )\n    {\n      // For now we don't analyze whitespace-containing phrases\n      finish();\n      return;\n    }\n\n    Mutex::Lock _( hunspellMutex );\n\n    string encodedWord = encodeToHunspell( hunspell, trimmedWord );\n\n#ifdef OLD_HUNSPELL_INTERFACE\n    if ( hunspell.spell( encodedWord.c_str() ) )\n#else\n    if ( hunspell.spell( encodedWord ) )\n#endif\n    {\n      // Good word -- no spelling suggestions then.\n      finish();\n      return;\n    }\n\n#ifdef OLD_HUNSPELL_INTERFACE\n    suggestionsCount = hunspell.suggest( &suggestions, encodedWord.c_str() );\n    if ( suggestionsCount )\n#else\n    suggestions = hunspell.suggest( encodedWord );\n    if ( !suggestions.empty() )\n#endif\n    {\n      // There were some suggestions made for us. Make an appropriate output.\n\n      string result = \"<div class=\\\"gdspellsuggestion\\\">\" +\n        Html::escape( QCoreApplication::translate( \"Hunspell\", \"Spelling suggestions: \" ).toUtf8().data() );\n\n      wstring lowercasedWord = Folding::applySimpleCaseOnly( word );\n\n#ifdef OLD_HUNSPELL_INTERFACE\n      for( int x = 0; x < suggestionsCount; ++x )\n      {\n        wstring suggestion = decodeFromHunspell( hunspell, suggestions[ x ] );\n#else\n      for( vector< string >::size_type x = 0; x < suggestions.size(); ++x )\n      {\n        wstring suggestion = decodeFromHunspell( hunspell, suggestions[ x ].c_str() );\n#endif\n\n        if ( Folding::applySimpleCaseOnly( suggestion ) == lowercasedWord )\n        {\n          // If among suggestions we see the same word just with the different\n          // case, we botch the search -- our searches are case-insensitive, and\n          // there's no need for suggestions on a good word.\n\n          finish();\n\n#ifdef OLD_HUNSPELL_INTERFACE\n          hunspell.free_list( &suggestions, suggestionsCount );\n#endif\n          return;\n        }\n        string suggestionUtf8 = Utf8::encode( suggestion );\n\n        result += \"<a href=\\\"bword:\";\n        result += Html::escape( suggestionUtf8 ) + \"\\\">\";\n        result += Html::escape( suggestionUtf8 ) + \"</a>\";\n\n#ifdef OLD_HUNSPELL_INTERFACE\n        if ( x != suggestionsCount - 1 )\n#else\n        if ( x != suggestions.size() - 1 )\n#endif\n          result += \", \";\n      }\n\n      result += \"</div>\";\n\n      Mutex::Lock _( dataMutex );\n\n      data.resize( result.size() );\n\n      memcpy( &data.front(), result.data(), result.size() );\n\n      hasAnyData = true;\n    }\n  }\n  catch( Iconv::Ex & e )\n  {\n    gdWarning( \"Hunspell: charset conversion error, no processing's done: %s\\n\", e.what() );\n  }\n  catch( std::exception & e )\n  {\n    gdWarning( \"Hunspell: error: %s\\n\", e.what() );\n  }\n\n#ifdef OLD_HUNSPELL_INTERFACE\n  if ( suggestions )\n  {\n    Mutex::Lock _( hunspellMutex );\n\n    hunspell.free_list( &suggestions, suggestionsCount );\n  }\n#endif\n\n  finish();\n}\n\nsptr< DataRequest > HunspellDictionary::getArticle( wstring const & word,\n                                                    vector< wstring > const &,\n                                                    wstring const &, bool )\n  THROW_SPEC( std::exception )\n{\n  return new HunspellArticleRequest( word, getHunspellMutex(), hunspell );\n}\n\n/// HunspellDictionary::findHeadwordsForSynonym()\n\nclass HunspellHeadwordsRequest;\n\nclass HunspellHeadwordsRequestRunnable: public QRunnable\n{\n  HunspellHeadwordsRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  HunspellHeadwordsRequestRunnable( HunspellHeadwordsRequest & r_,\n                                  QSemaphore & hasExited_ ): r( r_ ),\n                                                             hasExited( hasExited_ )\n  {}\n\n  ~HunspellHeadwordsRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass HunspellHeadwordsRequest: public Dictionary::WordSearchRequest\n{\n  friend class HunspellHeadwordsRequestRunnable;\n\n  Mutex & hunspellMutex;\n  Hunspell & hunspell;\n  wstring word;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  HunspellHeadwordsRequest( wstring const & word_,\n                            Mutex & hunspellMutex_,\n                            Hunspell & hunspell_ ):\n    hunspellMutex( hunspellMutex_ ),\n    hunspell( hunspell_ ),\n    word( word_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new HunspellHeadwordsRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by HunspellHeadwordsRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~HunspellHeadwordsRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid HunspellHeadwordsRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid HunspellHeadwordsRequest::run()\n{\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  wstring trimmedWord = Folding::trimWhitespaceOrPunct( word );\n\n  if ( trimmedWord.size() > 80 )\n  {\n    // We won't do anything for overly long sentences since that would probably\n    // only waste time.\n    finish();\n    return;\n  }\n\n  if ( containsWhitespace( trimmedWord ) )\n  {\n    vector< wstring > results;\n\n    getSuggestionsForExpression( trimmedWord, results, hunspellMutex, hunspell );\n\n    Mutex::Lock _( dataMutex );\n    for( unsigned i = 0; i < results.size(); i++ )\n      matches.push_back( results[ i ] );\n\n  }\n  else\n  {\n    QVector< wstring > suggestions = suggest( trimmedWord, hunspellMutex, hunspell );\n\n    if ( !suggestions.empty() )\n    {\n      Mutex::Lock _( dataMutex );\n\n      for( int x = 0; x < suggestions.size(); ++x )\n        matches.push_back( suggestions[ x ] );\n    }\n  }\n\n  finish();\n}\n\nQVector< wstring > suggest( wstring & word, Mutex & hunspellMutex, Hunspell & hunspell )\n{\n  QVector< wstring > result;\n\n#ifdef OLD_HUNSPELL_INTERFACE\n  // We'd need to free this if it gets allocated and an exception shows up\n  char ** suggestions = 0;\n  int suggestionsCount = 0;\n#else\n  vector< string > suggestions;\n#endif\n\n  try\n  {\n    Mutex::Lock _( hunspellMutex );\n\n    string encodedWord = encodeToHunspell( hunspell, word );\n\n#ifdef OLD_HUNSPELL_INTERFACE\n    suggestionsCount = hunspell.analyze( &suggestions, encodedWord.c_str() );\n    if ( suggestionsCount )\n#else\n    suggestions = hunspell.analyze( encodedWord );\n    if ( !suggestions.empty() )\n#endif\n    {\n      // There were some suggestions made for us. Make an appropriate output.\n\n      wstring lowercasedWord = Folding::applySimpleCaseOnly( word );\n\n      static QRegExp cutStem( \"^\\\\s*st:(((\\\\s+(?!\\\\w{2}:)(?!-)(?!\\\\+))|\\\\S+)+)\" );\n\n#ifdef OLD_HUNSPELL_INTERFACE\n      for( int x = 0; x < suggestionsCount; ++x )\n      {\n        QString suggestion = gd::toQString( decodeFromHunspell( hunspell, suggestions[ x ] ) );\n#else\n      for( vector< string >::size_type x = 0; x < suggestions.size(); ++x )\n      {\n        QString suggestion = gd::toQString( decodeFromHunspell( hunspell, suggestions[ x ].c_str() ) );\n#endif\n\n        // Strip comments\n        int n = suggestion.indexOf( '#' );\n        if( n >= 0 )\n          suggestion.chop( suggestion.length() - n );\n\n        GD_DPRINTF( \">>>Sugg: %s\\n\", suggestion.toLocal8Bit().data() );\n\n        if ( cutStem.indexIn( suggestion.trimmed() ) != -1 )\n        {\n          wstring alt = gd::toWString( cutStem.cap( 1 ) );\n\n          if ( Folding::applySimpleCaseOnly( alt ) != lowercasedWord ) // No point in providing same word\n          {\n#ifdef QT_DEBUG\n            qDebug() << \">>>>>Alt:\" << gd::toQString( alt );\n#endif\n            result.append( alt );\n          }\n        }\n      }\n    }\n  }\n  catch( Iconv::Ex & e )\n  {\n    gdWarning( \"Hunspell: charset conversion error, no processing's done: %s\\n\", e.what() );\n  }\n\n#ifdef OLD_HUNSPELL_INTERFACE\n  if ( suggestions )\n  {\n    Mutex::Lock _( hunspellMutex );\n\n    hunspell.free_list( &suggestions, suggestionsCount );\n  }\n#endif\n\n  return result;\n}\n\n\nsptr< WordSearchRequest > HunspellDictionary::findHeadwordsForSynonym( wstring const & word )\n  THROW_SPEC( std::exception )\n{\n  return new HunspellHeadwordsRequest( word, getHunspellMutex(), hunspell );\n}\n\n\n/// HunspellDictionary::prefixMatch()\n\nclass HunspellPrefixMatchRequest;\n\nclass HunspellPrefixMatchRequestRunnable: public QRunnable\n{\n  HunspellPrefixMatchRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  HunspellPrefixMatchRequestRunnable( HunspellPrefixMatchRequest & r_,\n                                      QSemaphore & hasExited_ ): r( r_ ),\n                                                                 hasExited( hasExited_ )\n  {}\n\n  ~HunspellPrefixMatchRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass HunspellPrefixMatchRequest: public Dictionary::WordSearchRequest\n{\n  friend class HunspellPrefixMatchRequestRunnable;\n\n  Mutex & hunspellMutex;\n  Hunspell & hunspell;\n  wstring word;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  HunspellPrefixMatchRequest( wstring const & word_,\n                              Mutex & hunspellMutex_,\n                              Hunspell & hunspell_ ):\n    hunspellMutex( hunspellMutex_ ),\n    hunspell( hunspell_ ),\n    word( word_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new HunspellPrefixMatchRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by HunspellPrefixMatchRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~HunspellPrefixMatchRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid HunspellPrefixMatchRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid HunspellPrefixMatchRequest::run()\n{\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  try\n  {\n    wstring trimmedWord = Folding::trimWhitespaceOrPunct( word );\n\n    if ( trimmedWord.empty() || containsWhitespace( trimmedWord ) )\n    {\n      // For now we don't analyze whitespace-containing phrases\n      finish();\n      return;\n    }\n\n    Mutex::Lock _( hunspellMutex );\n\n    string encodedWord = encodeToHunspell( hunspell, trimmedWord );\n\n#ifdef OLD_HUNSPELL_INTERFACE\n    if ( hunspell.spell( encodedWord.c_str() ) )\n#else\n    if ( hunspell.spell( encodedWord ) )\n#endif\n    {\n      // Known word -- add it to the result\n\n      Mutex::Lock _( dataMutex );\n\n      matches.push_back( WordMatch( trimmedWord, 1 ) );\n    }\n  }\n  catch( Iconv::Ex & e )\n  {\n    gdWarning( \"Hunspell: charset conversion error, no processing's done: %s\\n\", e.what() );\n  }\n\n  finish();\n}\n\nsptr< WordSearchRequest > HunspellDictionary::prefixMatch( wstring const & word,\n                                                           unsigned long /*maxResults*/ )\n  THROW_SPEC( std::exception )\n{\n  return new HunspellPrefixMatchRequest( word, getHunspellMutex(), hunspell );\n}\n\nvoid getSuggestionsForExpression( wstring const & expression,\n                                  vector<wstring> & suggestions,\n                                  Mutex & hunspellMutex,\n                                  Hunspell & hunspell )\n{\n  // Analyze each word separately and use the first two suggestions, if any.\n  // This is useful for compound expressions where some words is\n  // in different form, e.g. \"dozing off\" -> \"doze off\".\n\n  wstring trimmedWord = Folding::trimWhitespaceOrPunct( expression );\n  wstring word, punct;\n  QVector< wstring > words;\n\n  suggestions.clear();\n\n  // Parse string to separate words\n\n  for( wchar const * c = trimmedWord.c_str(); ; ++c )\n  {\n    if ( !*c || Folding::isPunct( *c ) || Folding::isWhitespace( * c ) )\n    {\n      if ( word.size() )\n      {\n        words.push_back( word );\n        word.clear();\n      }\n      if ( *c )\n        punct.push_back( *c );\n    }\n    else\n    {\n      if( punct.size() )\n      {\n        words.push_back( punct );\n        punct.clear();\n      }\n      if( *c )\n        word.push_back( *c );\n    }\n    if( !*c )\n      break;\n  }\n\n  if( words.size() > 21 )\n  {\n    // Too many words - no suggestions\n    return;\n  }\n\n  // Combine result strings from suggestions\n\n  QVector< wstring > results;\n\n  for( int i = 0; i < words.size(); i++ )\n  {\n    word = words.at( i );\n    if( Folding::isPunct( word[ 0 ] ) || Folding::isWhitespace( word[ 0 ] ) )\n    {\n      for( int j = 0; j < results.size(); j++ )\n        results[ j ].append( word );\n    }\n    else\n    {\n      QVector< wstring > sugg = suggest( word, hunspellMutex, hunspell );\n      int suggNum = sugg.size() + 1;\n      if( suggNum > 3 )\n        suggNum = 3;\n      int resNum = results.size();\n      wstring resultStr;\n\n      if( resNum == 0 )\n      {\n        for( int k = 0; k < suggNum; k++ )\n          results.push_back( k == 0 ? word : sugg.at( k - 1 ) );\n      }\n      else\n      {\n        for( int j = 0; j < resNum; j++ )\n        {\n          resultStr = results.at( j );\n          for( int k = 0; k < suggNum; k++ )\n          {\n            if( k == 0)\n              results[ j ].append( word );\n            else\n              results.push_back( resultStr + sugg.at( k - 1 ) );\n          }\n        }\n      }\n    }\n  }\n\n  for( int i = 0; i < results.size(); i++ )\n    if( results.at( i ) != trimmedWord )\n      suggestions.push_back( results.at( i ) );\n}\n\nstring encodeToHunspell( Hunspell & hunspell, wstring const & str )\n{\n  Iconv conv( hunspell.get_dic_encoding(), Iconv::GdWchar );\n\n  void const * in = str.data();\n  size_t inLeft = str.size() * sizeof( wchar );\n\n  vector< char > result( str.size() * 4 + 1 ); // +1 isn't actually needed,\n                                               // but then iconv complains on empty\n                                               // words\n\n  void * out = &result.front();\n  size_t outLeft = result.size();\n\n  if ( conv.convert( in, inLeft, out, outLeft ) != Iconv::Success )\n    throw Iconv::Ex();\n\n  return string( &result.front(), result.size() - outLeft );\n}\n\nwstring decodeFromHunspell( Hunspell & hunspell, char const * str )\n{\n  Iconv conv( Iconv::GdWchar, hunspell.get_dic_encoding() );\n\n  void const * in = str;\n  size_t inLeft = strlen( str );\n\n  vector< wchar > result( inLeft + 1 ); // +1 isn't needed, but see above\n\n  void * out = &result.front();\n  size_t outLeft = result.size() * sizeof( wchar );\n\n  if ( conv.convert( in, inLeft, out, outLeft ) != Iconv::Success )\n    throw Iconv::Ex();\n\n  return wstring( &result.front(), result.size() - outLeft/sizeof( wchar ) );\n}\n\n}\n\nvector< sptr< Dictionary::Class > > makeDictionaries( Config::Hunspell const & cfg )\n    THROW_SPEC( std::exception )\n{\n  vector< sptr< Dictionary::Class > > result;\n\n  vector< DataFiles > dataFiles = findDataFiles( cfg.dictionariesPath );\n\n\n  for( int x = 0; x < cfg.enabledDictionaries.size(); ++x )\n  {\n    for( unsigned d = dataFiles.size(); d--; )\n    {\n      if ( dataFiles[ d ].dictId == cfg.enabledDictionaries[ x ] )\n      {\n        // Found it\n\n        vector< string > dictFiles;\n\n        dictFiles.push_back(\n          FsEncoding::encode( QDir::toNativeSeparators( dataFiles[ d ].affFileName ) ) );\n        dictFiles.push_back(\n          FsEncoding::encode( QDir::toNativeSeparators( dataFiles[ d ].dicFileName ) ) );\n\n        result.push_back(\n          new HunspellDictionary( Dictionary::makeDictionaryId( dictFiles ),\n                                  dataFiles[ d ].dictName.toUtf8().data(),\n                                  dictFiles ) );\n        break;\n      }\n    }\n  }\n\n  return result;\n}\n\nvector< DataFiles > findDataFiles( QString const & path )\n{\n  // Empty path means unconfigured directory\n  if ( path.isEmpty() )\n    return vector< DataFiles >();\n\n  QDir dir( path );\n\n  // Find all affix files\n\n  QFileInfoList affixFiles = dir.entryInfoList( ( QStringList() << \"*.aff\" << \"*.AFF\" ), QDir::Files );\n\n  vector< DataFiles > result;\n  std::set< QString > presentNames;\n\n  for( QFileInfoList::const_iterator i = affixFiles.constBegin();\n       i != affixFiles.constEnd(); ++i )\n  {\n    QString affFileName = i->absoluteFilePath();\n\n    // See if there's a corresponding .dic file\n    QString dicFileNameBase = affFileName.mid( 0, affFileName.size() - 3 );\n\n    QString dicFileName = dicFileNameBase + \"dic\";\n\n    if ( !QFile( dicFileName ).exists() )\n    {\n      dicFileName = dicFileNameBase + \"DIC\";\n      if ( !QFile( dicFileName ).exists() )\n        continue; // No dic file\n    }\n\n    QString dictId = i->fileName();\n    dictId.chop( 4 );\n\n    QString dictBaseId = dictId.size() < 3 ? dictId :\n      ( ( dictId[ 2 ] == '-' || dictId[ 2 ] == '_' ) ? dictId.mid( 0, 2 ) : QString() );\n\n    dictBaseId = dictBaseId.toLower();\n\n    // Try making up good readable name from dictBaseId\n\n    QString localizedName;\n\n    if ( dictBaseId.size() == 2 )\n      localizedName = Language::localizedNameForId( LangCoder::code2toInt( dictBaseId.toLatin1().data() ) );\n\n    QString dictName = dictId;\n\n    if ( localizedName.size() )\n    {\n      dictName = localizedName;\n\n      if ( dictId.size() > 2 && ( dictId[ 2 ] == '-' || dictId[ 2 ] == '_' ) &&\n           dictId.mid( 3 ).toLower() != dictBaseId )\n        dictName += \" (\" + dictId.mid( 3 ) + \")\";\n    }\n\n    dictName = QCoreApplication::translate( \"Hunspell\", \"%1 Morphology\" ).arg( dictName );\n\n    if ( presentNames.insert( dictName ).second )\n    {\n      // Only include dictionaries with unique names. This combats stuff\n      // like symlinks en-US->en_US and such\n\n      result.push_back( DataFiles( affFileName, dicFileName, dictId, dictName ) );\n    }\n  }\n\n  return result;\n}\n\n}\n"
        },
        {
          "name": "hunspell.hh",
          "type": "blob",
          "size": 1.140625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __HUNSPELL_HH_INCLUDED__\n#define __HUNSPELL_HH_INCLUDED__\n\n#ifdef _MSC_VER\n#define HUNSPELL_STATIC\n#endif\n\n#include \"dictionary.hh\"\n#include \"config.hh\"\n\n/// Support for Hunspell-based morphology.\nnamespace HunspellMorpho {\n\nusing std::vector;\nusing std::string;\n\nstruct DataFiles\n{\n  QString affFileName, dicFileName; // Absolute, with Qt separators\n  QString dictId; // Dictionary id, e.g. \"en_US\"\n  QString dictName; // Localized dictionary name to be displayed, e.g. \"English(US) Morphology\"\n\n  DataFiles( QString const & affFileName_, QString const & dicFileName_,\n             QString const & dictId_, QString const & dictName_ ):\n    affFileName( affFileName_ ), dicFileName( dicFileName_ ),\n    dictId( dictId_ ), dictName( dictName_ )\n  {}\n};\n\n/// Finds all the DataFiles it can at the given path (with Qt separators).\nvector< DataFiles > findDataFiles( QString const & path );\n\nvector< sptr< Dictionary::Class > > makeDictionaries( Config::Hunspell const & )\n  THROW_SPEC( std::exception );\n\n}\n\n#endif\n"
        },
        {
          "name": "icons",
          "type": "tree",
          "content": null
        },
        {
          "name": "iconv.cc",
          "type": "blob",
          "size": 3.9423828125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"iconv.hh\"\n#include <vector>\n#include <errno.h>\n#include <string.h>\n\n#ifdef __WIN32\nchar const * const Iconv::GdWchar = \"UCS-4LE\";\n#else\nchar const * const Iconv::GdWchar = \"WCHAR_T\";\n#endif\n\nchar const * const Iconv::Utf16Le = \"UTF-16LE\";\nchar const * const Iconv::Utf8 = \"UTF-8\";\n\nusing gd::wchar;\n\nIconv::Iconv( char const * to, char const * from ) THROW_SPEC( exCantInit ):\n  state( iconv_open( to, from ) )\n{\n  if ( state == (iconv_t) -1 )\n    throw exCantInit( strerror( errno ) );\n}\n\nvoid Iconv::reinit( char const * to, char const * from ) THROW_SPEC( exCantInit )\n{\n  iconv_close( state );\n\n  state = iconv_open( to, from );\n\n  if ( state == (iconv_t) -1 )\n    throw exCantInit( strerror( errno ) );\n}\n\nIconv::~Iconv() throw()\n{\n  iconv_close( state );\n}\n\nIconv::Result Iconv::convert( void const * & inBuf, size_t  & inBytesLeft,\n                              void * & outBuf, size_t & outBytesLeft )\n  THROW_SPEC( exIncorrectSeq, exOther )\n{\n  size_t result = iconv( state,\n//                         #ifdef __WIN32\n//                         (char const **)&inBuf,\n//                         #else\n                         (char **)&inBuf,\n//                         #endif\n                                           &inBytesLeft,\n                         (char **)&outBuf, &outBytesLeft );\n\n  if ( result == (size_t) -1 )\n  {\n    switch( errno )\n    {\n      case EILSEQ:\n        throw exIncorrectSeq();\n      case EINVAL:\n        return NeedMoreIn;\n      case E2BIG:\n        return NeedMoreOut;\n      default:\n        throw exOther( strerror( errno ) );\n    }\n  }\n\n  return Success;\n}\n\ngd::wstring Iconv::toWstring( char const * fromEncoding, void const * fromData,\n                              size_t dataSize )\n  THROW_SPEC( exCantInit, exIncorrectSeq, exPrematureEnd, exOther )\n{\n  /// Special-case the dataSize == 0 to avoid any kind of iconv-specific\n  /// behaviour in that regard.\n\n  if ( !dataSize )\n    return gd::wstring();\n\n  Iconv ic( GdWchar, fromEncoding );\n\n  /// This size is usually enough, but may be enlarged during the conversion\n  std::vector< wchar > outBuf( dataSize );\n\n  void * outBufPtr = &outBuf.front();\n\n  size_t outBufLeft = outBuf.size() * sizeof( wchar );\n\n  for( ; ; )\n  {\n    switch( ic.convert( fromData, dataSize, outBufPtr, outBufLeft ) )\n    {\n      case Success:\n        return gd::wstring( &outBuf.front(),\n                            outBuf.size() - outBufLeft / sizeof( wchar ) );\n      case NeedMoreIn:\n        throw exPrematureEnd();\n      case NeedMoreOut:\n      {\n        // Grow the buffer and retry\n        // The pointer may get invalidated so we save the diff and restore it\n        size_t offset = (wchar *)outBufPtr - &outBuf.front();\n        outBuf.resize( outBuf.size() + 256 );\n        outBufPtr = &outBuf.front() + offset;\n        outBufLeft += 256;\n      }\n    }\n  }\n}\n\nstd::string Iconv::toUtf8( char const * fromEncoding, void const * fromData,\n                           size_t dataSize )\n  THROW_SPEC( exCantInit, exIncorrectSeq, exPrematureEnd, exOther )\n{\n  // Similar to toWstring\n\n  if ( !dataSize )\n    return std::string();\n\n  Iconv ic( Utf8, fromEncoding );\n\n  std::vector< char > outBuf( dataSize );\n\n  void * outBufPtr = &outBuf.front();\n\n  size_t outBufLeft = outBuf.size();\n\n  for( ; ; )\n  {\n    switch( ic.convert( fromData, dataSize, outBufPtr, outBufLeft ) )\n    {\n      case Success:\n        return std::string( &outBuf.front(),\n                            outBuf.size() - outBufLeft );\n      case NeedMoreIn:\n        throw exPrematureEnd();\n      case NeedMoreOut:\n      {\n        // Grow the buffer and retry\n        // The pointer may get invalidated so we save the diff and restore it\n        size_t offset = (char *)outBufPtr - &outBuf.front();\n        outBuf.resize( outBuf.size() + 256 );\n        outBufPtr = &outBuf.front() + offset;\n        outBufLeft += 256;\n      }\n    }\n  }\n}\n\n"
        },
        {
          "name": "iconv.hh",
          "type": "blob",
          "size": 2.2880859375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __ICONV_HH_INCLUDED__\n#define __ICONV_HH_INCLUDED__\n\n#include <iconv.h>\n#include \"wstring.hh\"\n#include \"ex.hh\"\n#include \"cpp_features.hh\"\n\n/// A wrapper for the iconv() character set conversion functions\nclass Iconv\n{\n  iconv_t state;\n\npublic:\n\n  DEF_EX( Ex, \"Iconv exception\", std::exception )\n  DEF_EX_STR( exCantInit, \"Can't initialize iconv conversion:\", Ex )\n  DEF_EX( exIncorrectSeq, \"Invalid character sequence encountered during character conversion\", Ex )\n  DEF_EX( exPrematureEnd, \"Character sequence ended prematurely during character conversion\", Ex )\n  DEF_EX_STR( exOther, \"An error has occurred during character conversion:\", Ex )\n\n  // Some predefined character sets' names\n\n  static char const * const GdWchar;\n  static char const * const Utf16Le;\n  static char const * const Utf8;\n\n  Iconv( char const * to, char const * from ) THROW_SPEC( exCantInit );\n\n  // Changes to another pair of encodings. All the internal state is reset.\n  void reinit( char const * to, char const * from ) THROW_SPEC( exCantInit );\n\n  ~Iconv() throw();\n\n  enum Result\n  {\n    Success, // All the data was successfully converted\n    NeedMoreIn, // Input has an incomplete multibyte character at its end\n    NeedMoreOut // The output buffer can't hold the result\n  };\n\n  Result convert( void const * & inBuf, size_t & inBytesLeft,\n                  void * & outBuf, size_t & outBytesLeft ) THROW_SPEC( exIncorrectSeq,\n                                                                  exOther );\n\n  // Converts a given block of data from the given encoding to a wide string.\n  static gd::wstring toWstring( char const * fromEncoding, void const * fromData,\n                                 size_t dataSize )\n    THROW_SPEC( exCantInit, exIncorrectSeq, exPrematureEnd, exOther );\n\n  // Converts a given block of data from the given encoding to an utf8-encoded\n  // string.\n  static std::string toUtf8( char const * fromEncoding, void const * fromData,\n                             size_t dataSize )\n    THROW_SPEC( exCantInit, exIncorrectSeq, exPrematureEnd, exOther );\n\nprivate:\n\n  // Copying/assigning not supported\n  Iconv( Iconv const & );\n  Iconv & operator = ( Iconv const & );\n};\n\n#endif\n\n"
        },
        {
          "name": "inc_case_folding.hh",
          "type": "blob",
          "size": 79.1083984375,
          "content": "// This file was generated automatically. Do not edit directly.\n\nenum { foldCaseMaxOut = 3 };\n\nsize_t foldCase( wchar in, wchar * out )\n{\n  switch( in )\n  {\n    case 0x41: *out = 0x61; return 1;\n    case 0x42: *out = 0x62; return 1;\n    case 0x43: *out = 0x63; return 1;\n    case 0x44: *out = 0x64; return 1;\n    case 0x45: *out = 0x65; return 1;\n    case 0x46: *out = 0x66; return 1;\n    case 0x47: *out = 0x67; return 1;\n    case 0x48: *out = 0x68; return 1;\n    case 0x49: *out = 0x69; return 1;\n    case 0x4a: *out = 0x6a; return 1;\n    case 0x4b: *out = 0x6b; return 1;\n    case 0x4c: *out = 0x6c; return 1;\n    case 0x4d: *out = 0x6d; return 1;\n    case 0x4e: *out = 0x6e; return 1;\n    case 0x4f: *out = 0x6f; return 1;\n    case 0x50: *out = 0x70; return 1;\n    case 0x51: *out = 0x71; return 1;\n    case 0x52: *out = 0x72; return 1;\n    case 0x53: *out = 0x73; return 1;\n    case 0x54: *out = 0x74; return 1;\n    case 0x55: *out = 0x75; return 1;\n    case 0x56: *out = 0x76; return 1;\n    case 0x57: *out = 0x77; return 1;\n    case 0x58: *out = 0x78; return 1;\n    case 0x59: *out = 0x79; return 1;\n    case 0x5a: *out = 0x7a; return 1;\n    case 0xb5: *out = 0x3bc; return 1;\n    case 0xc0: *out = 0xe0; return 1;\n    case 0xc1: *out = 0xe1; return 1;\n    case 0xc2: *out = 0xe2; return 1;\n    case 0xc3: *out = 0xe3; return 1;\n    case 0xc4: *out = 0xe4; return 1;\n    case 0xc5: *out = 0xe5; return 1;\n    case 0xc6: *out = 0xe6; return 1;\n    case 0xc7: *out = 0xe7; return 1;\n    case 0xc8: *out = 0xe8; return 1;\n    case 0xc9: *out = 0xe9; return 1;\n    case 0xca: *out = 0xea; return 1;\n    case 0xcb: *out = 0xeb; return 1;\n    case 0xcc: *out = 0xec; return 1;\n    case 0xcd: *out = 0xed; return 1;\n    case 0xce: *out = 0xee; return 1;\n    case 0xcf: *out = 0xef; return 1;\n    case 0xd0: *out = 0xf0; return 1;\n    case 0xd1: *out = 0xf1; return 1;\n    case 0xd2: *out = 0xf2; return 1;\n    case 0xd3: *out = 0xf3; return 1;\n    case 0xd4: *out = 0xf4; return 1;\n    case 0xd5: *out = 0xf5; return 1;\n    case 0xd6: *out = 0xf6; return 1;\n    case 0xd8: *out = 0xf8; return 1;\n    case 0xd9: *out = 0xf9; return 1;\n    case 0xda: *out = 0xfa; return 1;\n    case 0xdb: *out = 0xfb; return 1;\n    case 0xdc: *out = 0xfc; return 1;\n    case 0xdd: *out = 0xfd; return 1;\n    case 0xde: *out = 0xfe; return 1;\n    case 0xdf: out[ 0 ] = 0x73; out[ 1 ] = 0x73; return 2;\n    case 0x100: *out = 0x101; return 1;\n    case 0x102: *out = 0x103; return 1;\n    case 0x104: *out = 0x105; return 1;\n    case 0x106: *out = 0x107; return 1;\n    case 0x108: *out = 0x109; return 1;\n    case 0x10a: *out = 0x10b; return 1;\n    case 0x10c: *out = 0x10d; return 1;\n    case 0x10e: *out = 0x10f; return 1;\n    case 0x110: *out = 0x111; return 1;\n    case 0x112: *out = 0x113; return 1;\n    case 0x114: *out = 0x115; return 1;\n    case 0x116: *out = 0x117; return 1;\n    case 0x118: *out = 0x119; return 1;\n    case 0x11a: *out = 0x11b; return 1;\n    case 0x11c: *out = 0x11d; return 1;\n    case 0x11e: *out = 0x11f; return 1;\n    case 0x120: *out = 0x121; return 1;\n    case 0x122: *out = 0x123; return 1;\n    case 0x124: *out = 0x125; return 1;\n    case 0x126: *out = 0x127; return 1;\n    case 0x128: *out = 0x129; return 1;\n    case 0x12a: *out = 0x12b; return 1;\n    case 0x12c: *out = 0x12d; return 1;\n    case 0x12e: *out = 0x12f; return 1;\n    case 0x130: out[ 0 ] = 0x69; out[ 1 ] = 0x307; return 2;\n    case 0x132: *out = 0x133; return 1;\n    case 0x134: *out = 0x135; return 1;\n    case 0x136: *out = 0x137; return 1;\n    case 0x139: *out = 0x13a; return 1;\n    case 0x13b: *out = 0x13c; return 1;\n    case 0x13d: *out = 0x13e; return 1;\n    case 0x13f: *out = 0x140; return 1;\n    case 0x141: *out = 0x142; return 1;\n    case 0x143: *out = 0x144; return 1;\n    case 0x145: *out = 0x146; return 1;\n    case 0x147: *out = 0x148; return 1;\n    case 0x149: out[ 0 ] = 0x2bc; out[ 1 ] = 0x6e; return 2;\n    case 0x14a: *out = 0x14b; return 1;\n    case 0x14c: *out = 0x14d; return 1;\n    case 0x14e: *out = 0x14f; return 1;\n    case 0x150: *out = 0x151; return 1;\n    case 0x152: *out = 0x153; return 1;\n    case 0x154: *out = 0x155; return 1;\n    case 0x156: *out = 0x157; return 1;\n    case 0x158: *out = 0x159; return 1;\n    case 0x15a: *out = 0x15b; return 1;\n    case 0x15c: *out = 0x15d; return 1;\n    case 0x15e: *out = 0x15f; return 1;\n    case 0x160: *out = 0x161; return 1;\n    case 0x162: *out = 0x163; return 1;\n    case 0x164: *out = 0x165; return 1;\n    case 0x166: *out = 0x167; return 1;\n    case 0x168: *out = 0x169; return 1;\n    case 0x16a: *out = 0x16b; return 1;\n    case 0x16c: *out = 0x16d; return 1;\n    case 0x16e: *out = 0x16f; return 1;\n    case 0x170: *out = 0x171; return 1;\n    case 0x172: *out = 0x173; return 1;\n    case 0x174: *out = 0x175; return 1;\n    case 0x176: *out = 0x177; return 1;\n    case 0x178: *out = 0xff; return 1;\n    case 0x179: *out = 0x17a; return 1;\n    case 0x17b: *out = 0x17c; return 1;\n    case 0x17d: *out = 0x17e; return 1;\n    case 0x17f: *out = 0x73; return 1;\n    case 0x181: *out = 0x253; return 1;\n    case 0x182: *out = 0x183; return 1;\n    case 0x184: *out = 0x185; return 1;\n    case 0x186: *out = 0x254; return 1;\n    case 0x187: *out = 0x188; return 1;\n    case 0x189: *out = 0x256; return 1;\n    case 0x18a: *out = 0x257; return 1;\n    case 0x18b: *out = 0x18c; return 1;\n    case 0x18e: *out = 0x1dd; return 1;\n    case 0x18f: *out = 0x259; return 1;\n    case 0x190: *out = 0x25b; return 1;\n    case 0x191: *out = 0x192; return 1;\n    case 0x193: *out = 0x260; return 1;\n    case 0x194: *out = 0x263; return 1;\n    case 0x196: *out = 0x269; return 1;\n    case 0x197: *out = 0x268; return 1;\n    case 0x198: *out = 0x199; return 1;\n    case 0x19c: *out = 0x26f; return 1;\n    case 0x19d: *out = 0x272; return 1;\n    case 0x19f: *out = 0x275; return 1;\n    case 0x1a0: *out = 0x1a1; return 1;\n    case 0x1a2: *out = 0x1a3; return 1;\n    case 0x1a4: *out = 0x1a5; return 1;\n    case 0x1a6: *out = 0x280; return 1;\n    case 0x1a7: *out = 0x1a8; return 1;\n    case 0x1a9: *out = 0x283; return 1;\n    case 0x1ac: *out = 0x1ad; return 1;\n    case 0x1ae: *out = 0x288; return 1;\n    case 0x1af: *out = 0x1b0; return 1;\n    case 0x1b1: *out = 0x28a; return 1;\n    case 0x1b2: *out = 0x28b; return 1;\n    case 0x1b3: *out = 0x1b4; return 1;\n    case 0x1b5: *out = 0x1b6; return 1;\n    case 0x1b7: *out = 0x292; return 1;\n    case 0x1b8: *out = 0x1b9; return 1;\n    case 0x1bc: *out = 0x1bd; return 1;\n    case 0x1c4: *out = 0x1c6; return 1;\n    case 0x1c5: *out = 0x1c6; return 1;\n    case 0x1c7: *out = 0x1c9; return 1;\n    case 0x1c8: *out = 0x1c9; return 1;\n    case 0x1ca: *out = 0x1cc; return 1;\n    case 0x1cb: *out = 0x1cc; return 1;\n    case 0x1cd: *out = 0x1ce; return 1;\n    case 0x1cf: *out = 0x1d0; return 1;\n    case 0x1d1: *out = 0x1d2; return 1;\n    case 0x1d3: *out = 0x1d4; return 1;\n    case 0x1d5: *out = 0x1d6; return 1;\n    case 0x1d7: *out = 0x1d8; return 1;\n    case 0x1d9: *out = 0x1da; return 1;\n    case 0x1db: *out = 0x1dc; return 1;\n    case 0x1de: *out = 0x1df; return 1;\n    case 0x1e0: *out = 0x1e1; return 1;\n    case 0x1e2: *out = 0x1e3; return 1;\n    case 0x1e4: *out = 0x1e5; return 1;\n    case 0x1e6: *out = 0x1e7; return 1;\n    case 0x1e8: *out = 0x1e9; return 1;\n    case 0x1ea: *out = 0x1eb; return 1;\n    case 0x1ec: *out = 0x1ed; return 1;\n    case 0x1ee: *out = 0x1ef; return 1;\n    case 0x1f0: out[ 0 ] = 0x6a; out[ 1 ] = 0x30c; return 2;\n    case 0x1f1: *out = 0x1f3; return 1;\n    case 0x1f2: *out = 0x1f3; return 1;\n    case 0x1f4: *out = 0x1f5; return 1;\n    case 0x1f6: *out = 0x195; return 1;\n    case 0x1f7: *out = 0x1bf; return 1;\n    case 0x1f8: *out = 0x1f9; return 1;\n    case 0x1fa: *out = 0x1fb; return 1;\n    case 0x1fc: *out = 0x1fd; return 1;\n    case 0x1fe: *out = 0x1ff; return 1;\n    case 0x200: *out = 0x201; return 1;\n    case 0x202: *out = 0x203; return 1;\n    case 0x204: *out = 0x205; return 1;\n    case 0x206: *out = 0x207; return 1;\n    case 0x208: *out = 0x209; return 1;\n    case 0x20a: *out = 0x20b; return 1;\n    case 0x20c: *out = 0x20d; return 1;\n    case 0x20e: *out = 0x20f; return 1;\n    case 0x210: *out = 0x211; return 1;\n    case 0x212: *out = 0x213; return 1;\n    case 0x214: *out = 0x215; return 1;\n    case 0x216: *out = 0x217; return 1;\n    case 0x218: *out = 0x219; return 1;\n    case 0x21a: *out = 0x21b; return 1;\n    case 0x21c: *out = 0x21d; return 1;\n    case 0x21e: *out = 0x21f; return 1;\n    case 0x220: *out = 0x19e; return 1;\n    case 0x222: *out = 0x223; return 1;\n    case 0x224: *out = 0x225; return 1;\n    case 0x226: *out = 0x227; return 1;\n    case 0x228: *out = 0x229; return 1;\n    case 0x22a: *out = 0x22b; return 1;\n    case 0x22c: *out = 0x22d; return 1;\n    case 0x22e: *out = 0x22f; return 1;\n    case 0x230: *out = 0x231; return 1;\n    case 0x232: *out = 0x233; return 1;\n    case 0x23a: *out = 0x2c65; return 1;\n    case 0x23b: *out = 0x23c; return 1;\n    case 0x23d: *out = 0x19a; return 1;\n    case 0x23e: *out = 0x2c66; return 1;\n    case 0x241: *out = 0x242; return 1;\n    case 0x243: *out = 0x180; return 1;\n    case 0x244: *out = 0x289; return 1;\n    case 0x245: *out = 0x28c; return 1;\n    case 0x246: *out = 0x247; return 1;\n    case 0x248: *out = 0x249; return 1;\n    case 0x24a: *out = 0x24b; return 1;\n    case 0x24c: *out = 0x24d; return 1;\n    case 0x24e: *out = 0x24f; return 1;\n    case 0x345: *out = 0x3b9; return 1;\n    case 0x370: *out = 0x371; return 1;\n    case 0x372: *out = 0x373; return 1;\n    case 0x376: *out = 0x377; return 1;\n    case 0x386: *out = 0x3ac; return 1;\n    case 0x388: *out = 0x3ad; return 1;\n    case 0x389: *out = 0x3ae; return 1;\n    case 0x38a: *out = 0x3af; return 1;\n    case 0x38c: *out = 0x3cc; return 1;\n    case 0x38e: *out = 0x3cd; return 1;\n    case 0x38f: *out = 0x3ce; return 1;\n    case 0x390: out[ 0 ] = 0x3b9; out[ 1 ] = 0x308; out[ 2 ] = 0x301; return 3;\n    case 0x391: *out = 0x3b1; return 1;\n    case 0x392: *out = 0x3b2; return 1;\n    case 0x393: *out = 0x3b3; return 1;\n    case 0x394: *out = 0x3b4; return 1;\n    case 0x395: *out = 0x3b5; return 1;\n    case 0x396: *out = 0x3b6; return 1;\n    case 0x397: *out = 0x3b7; return 1;\n    case 0x398: *out = 0x3b8; return 1;\n    case 0x399: *out = 0x3b9; return 1;\n    case 0x39a: *out = 0x3ba; return 1;\n    case 0x39b: *out = 0x3bb; return 1;\n    case 0x39c: *out = 0x3bc; return 1;\n    case 0x39d: *out = 0x3bd; return 1;\n    case 0x39e: *out = 0x3be; return 1;\n    case 0x39f: *out = 0x3bf; return 1;\n    case 0x3a0: *out = 0x3c0; return 1;\n    case 0x3a1: *out = 0x3c1; return 1;\n    case 0x3a3: *out = 0x3c3; return 1;\n    case 0x3a4: *out = 0x3c4; return 1;\n    case 0x3a5: *out = 0x3c5; return 1;\n    case 0x3a6: *out = 0x3c6; return 1;\n    case 0x3a7: *out = 0x3c7; return 1;\n    case 0x3a8: *out = 0x3c8; return 1;\n    case 0x3a9: *out = 0x3c9; return 1;\n    case 0x3aa: *out = 0x3ca; return 1;\n    case 0x3ab: *out = 0x3cb; return 1;\n    case 0x3b0: out[ 0 ] = 0x3c5; out[ 1 ] = 0x308; out[ 2 ] = 0x301; return 3;\n    case 0x3c2: *out = 0x3c3; return 1;\n    case 0x3cf: *out = 0x3d7; return 1;\n    case 0x3d0: *out = 0x3b2; return 1;\n    case 0x3d1: *out = 0x3b8; return 1;\n    case 0x3d5: *out = 0x3c6; return 1;\n    case 0x3d6: *out = 0x3c0; return 1;\n    case 0x3d8: *out = 0x3d9; return 1;\n    case 0x3da: *out = 0x3db; return 1;\n    case 0x3dc: *out = 0x3dd; return 1;\n    case 0x3de: *out = 0x3df; return 1;\n    case 0x3e0: *out = 0x3e1; return 1;\n    case 0x3e2: *out = 0x3e3; return 1;\n    case 0x3e4: *out = 0x3e5; return 1;\n    case 0x3e6: *out = 0x3e7; return 1;\n    case 0x3e8: *out = 0x3e9; return 1;\n    case 0x3ea: *out = 0x3eb; return 1;\n    case 0x3ec: *out = 0x3ed; return 1;\n    case 0x3ee: *out = 0x3ef; return 1;\n    case 0x3f0: *out = 0x3ba; return 1;\n    case 0x3f1: *out = 0x3c1; return 1;\n    case 0x3f4: *out = 0x3b8; return 1;\n    case 0x3f5: *out = 0x3b5; return 1;\n    case 0x3f7: *out = 0x3f8; return 1;\n    case 0x3f9: *out = 0x3f2; return 1;\n    case 0x3fa: *out = 0x3fb; return 1;\n    case 0x3fd: *out = 0x37b; return 1;\n    case 0x3fe: *out = 0x37c; return 1;\n    case 0x3ff: *out = 0x37d; return 1;\n    case 0x400: *out = 0x450; return 1;\n    case 0x401: *out = 0x451; return 1;\n    case 0x402: *out = 0x452; return 1;\n    case 0x403: *out = 0x453; return 1;\n    case 0x404: *out = 0x454; return 1;\n    case 0x405: *out = 0x455; return 1;\n    case 0x406: *out = 0x456; return 1;\n    case 0x407: *out = 0x457; return 1;\n    case 0x408: *out = 0x458; return 1;\n    case 0x409: *out = 0x459; return 1;\n    case 0x40a: *out = 0x45a; return 1;\n    case 0x40b: *out = 0x45b; return 1;\n    case 0x40c: *out = 0x45c; return 1;\n    case 0x40d: *out = 0x45d; return 1;\n    case 0x40e: *out = 0x45e; return 1;\n    case 0x40f: *out = 0x45f; return 1;\n    case 0x410: *out = 0x430; return 1;\n    case 0x411: *out = 0x431; return 1;\n    case 0x412: *out = 0x432; return 1;\n    case 0x413: *out = 0x433; return 1;\n    case 0x414: *out = 0x434; return 1;\n    case 0x415: *out = 0x435; return 1;\n    case 0x416: *out = 0x436; return 1;\n    case 0x417: *out = 0x437; return 1;\n    case 0x418: *out = 0x438; return 1;\n    case 0x419: *out = 0x439; return 1;\n    case 0x41a: *out = 0x43a; return 1;\n    case 0x41b: *out = 0x43b; return 1;\n    case 0x41c: *out = 0x43c; return 1;\n    case 0x41d: *out = 0x43d; return 1;\n    case 0x41e: *out = 0x43e; return 1;\n    case 0x41f: *out = 0x43f; return 1;\n    case 0x420: *out = 0x440; return 1;\n    case 0x421: *out = 0x441; return 1;\n    case 0x422: *out = 0x442; return 1;\n    case 0x423: *out = 0x443; return 1;\n    case 0x424: *out = 0x444; return 1;\n    case 0x425: *out = 0x445; return 1;\n    case 0x426: *out = 0x446; return 1;\n    case 0x427: *out = 0x447; return 1;\n    case 0x428: *out = 0x448; return 1;\n    case 0x429: *out = 0x449; return 1;\n    case 0x42a: *out = 0x44a; return 1;\n    case 0x42b: *out = 0x44b; return 1;\n    case 0x42c: *out = 0x44c; return 1;\n    case 0x42d: *out = 0x44d; return 1;\n    case 0x42e: *out = 0x44e; return 1;\n    case 0x42f: *out = 0x44f; return 1;\n    case 0x460: *out = 0x461; return 1;\n    case 0x462: *out = 0x463; return 1;\n    case 0x464: *out = 0x465; return 1;\n    case 0x466: *out = 0x467; return 1;\n    case 0x468: *out = 0x469; return 1;\n    case 0x46a: *out = 0x46b; return 1;\n    case 0x46c: *out = 0x46d; return 1;\n    case 0x46e: *out = 0x46f; return 1;\n    case 0x470: *out = 0x471; return 1;\n    case 0x472: *out = 0x473; return 1;\n    case 0x474: *out = 0x475; return 1;\n    case 0x476: *out = 0x477; return 1;\n    case 0x478: *out = 0x479; return 1;\n    case 0x47a: *out = 0x47b; return 1;\n    case 0x47c: *out = 0x47d; return 1;\n    case 0x47e: *out = 0x47f; return 1;\n    case 0x480: *out = 0x481; return 1;\n    case 0x48a: *out = 0x48b; return 1;\n    case 0x48c: *out = 0x48d; return 1;\n    case 0x48e: *out = 0x48f; return 1;\n    case 0x490: *out = 0x491; return 1;\n    case 0x492: *out = 0x493; return 1;\n    case 0x494: *out = 0x495; return 1;\n    case 0x496: *out = 0x497; return 1;\n    case 0x498: *out = 0x499; return 1;\n    case 0x49a: *out = 0x49b; return 1;\n    case 0x49c: *out = 0x49d; return 1;\n    case 0x49e: *out = 0x49f; return 1;\n    case 0x4a0: *out = 0x4a1; return 1;\n    case 0x4a2: *out = 0x4a3; return 1;\n    case 0x4a4: *out = 0x4a5; return 1;\n    case 0x4a6: *out = 0x4a7; return 1;\n    case 0x4a8: *out = 0x4a9; return 1;\n    case 0x4aa: *out = 0x4ab; return 1;\n    case 0x4ac: *out = 0x4ad; return 1;\n    case 0x4ae: *out = 0x4af; return 1;\n    case 0x4b0: *out = 0x4b1; return 1;\n    case 0x4b2: *out = 0x4b3; return 1;\n    case 0x4b4: *out = 0x4b5; return 1;\n    case 0x4b6: *out = 0x4b7; return 1;\n    case 0x4b8: *out = 0x4b9; return 1;\n    case 0x4ba: *out = 0x4bb; return 1;\n    case 0x4bc: *out = 0x4bd; return 1;\n    case 0x4be: *out = 0x4bf; return 1;\n    case 0x4c0: *out = 0x4cf; return 1;\n    case 0x4c1: *out = 0x4c2; return 1;\n    case 0x4c3: *out = 0x4c4; return 1;\n    case 0x4c5: *out = 0x4c6; return 1;\n    case 0x4c7: *out = 0x4c8; return 1;\n    case 0x4c9: *out = 0x4ca; return 1;\n    case 0x4cb: *out = 0x4cc; return 1;\n    case 0x4cd: *out = 0x4ce; return 1;\n    case 0x4d0: *out = 0x4d1; return 1;\n    case 0x4d2: *out = 0x4d3; return 1;\n    case 0x4d4: *out = 0x4d5; return 1;\n    case 0x4d6: *out = 0x4d7; return 1;\n    case 0x4d8: *out = 0x4d9; return 1;\n    case 0x4da: *out = 0x4db; return 1;\n    case 0x4dc: *out = 0x4dd; return 1;\n    case 0x4de: *out = 0x4df; return 1;\n    case 0x4e0: *out = 0x4e1; return 1;\n    case 0x4e2: *out = 0x4e3; return 1;\n    case 0x4e4: *out = 0x4e5; return 1;\n    case 0x4e6: *out = 0x4e7; return 1;\n    case 0x4e8: *out = 0x4e9; return 1;\n    case 0x4ea: *out = 0x4eb; return 1;\n    case 0x4ec: *out = 0x4ed; return 1;\n    case 0x4ee: *out = 0x4ef; return 1;\n    case 0x4f0: *out = 0x4f1; return 1;\n    case 0x4f2: *out = 0x4f3; return 1;\n    case 0x4f4: *out = 0x4f5; return 1;\n    case 0x4f6: *out = 0x4f7; return 1;\n    case 0x4f8: *out = 0x4f9; return 1;\n    case 0x4fa: *out = 0x4fb; return 1;\n    case 0x4fc: *out = 0x4fd; return 1;\n    case 0x4fe: *out = 0x4ff; return 1;\n    case 0x500: *out = 0x501; return 1;\n    case 0x502: *out = 0x503; return 1;\n    case 0x504: *out = 0x505; return 1;\n    case 0x506: *out = 0x507; return 1;\n    case 0x508: *out = 0x509; return 1;\n    case 0x50a: *out = 0x50b; return 1;\n    case 0x50c: *out = 0x50d; return 1;\n    case 0x50e: *out = 0x50f; return 1;\n    case 0x510: *out = 0x511; return 1;\n    case 0x512: *out = 0x513; return 1;\n    case 0x514: *out = 0x515; return 1;\n    case 0x516: *out = 0x517; return 1;\n    case 0x518: *out = 0x519; return 1;\n    case 0x51a: *out = 0x51b; return 1;\n    case 0x51c: *out = 0x51d; return 1;\n    case 0x51e: *out = 0x51f; return 1;\n    case 0x520: *out = 0x521; return 1;\n    case 0x522: *out = 0x523; return 1;\n    case 0x524: *out = 0x525; return 1;\n    case 0x531: *out = 0x561; return 1;\n    case 0x532: *out = 0x562; return 1;\n    case 0x533: *out = 0x563; return 1;\n    case 0x534: *out = 0x564; return 1;\n    case 0x535: *out = 0x565; return 1;\n    case 0x536: *out = 0x566; return 1;\n    case 0x537: *out = 0x567; return 1;\n    case 0x538: *out = 0x568; return 1;\n    case 0x539: *out = 0x569; return 1;\n    case 0x53a: *out = 0x56a; return 1;\n    case 0x53b: *out = 0x56b; return 1;\n    case 0x53c: *out = 0x56c; return 1;\n    case 0x53d: *out = 0x56d; return 1;\n    case 0x53e: *out = 0x56e; return 1;\n    case 0x53f: *out = 0x56f; return 1;\n    case 0x540: *out = 0x570; return 1;\n    case 0x541: *out = 0x571; return 1;\n    case 0x542: *out = 0x572; return 1;\n    case 0x543: *out = 0x573; return 1;\n    case 0x544: *out = 0x574; return 1;\n    case 0x545: *out = 0x575; return 1;\n    case 0x546: *out = 0x576; return 1;\n    case 0x547: *out = 0x577; return 1;\n    case 0x548: *out = 0x578; return 1;\n    case 0x549: *out = 0x579; return 1;\n    case 0x54a: *out = 0x57a; return 1;\n    case 0x54b: *out = 0x57b; return 1;\n    case 0x54c: *out = 0x57c; return 1;\n    case 0x54d: *out = 0x57d; return 1;\n    case 0x54e: *out = 0x57e; return 1;\n    case 0x54f: *out = 0x57f; return 1;\n    case 0x550: *out = 0x580; return 1;\n    case 0x551: *out = 0x581; return 1;\n    case 0x552: *out = 0x582; return 1;\n    case 0x553: *out = 0x583; return 1;\n    case 0x554: *out = 0x584; return 1;\n    case 0x555: *out = 0x585; return 1;\n    case 0x556: *out = 0x586; return 1;\n    case 0x587: out[ 0 ] = 0x565; out[ 1 ] = 0x582; return 2;\n    case 0x10a0: *out = 0x2d00; return 1;\n    case 0x10a1: *out = 0x2d01; return 1;\n    case 0x10a2: *out = 0x2d02; return 1;\n    case 0x10a3: *out = 0x2d03; return 1;\n    case 0x10a4: *out = 0x2d04; return 1;\n    case 0x10a5: *out = 0x2d05; return 1;\n    case 0x10a6: *out = 0x2d06; return 1;\n    case 0x10a7: *out = 0x2d07; return 1;\n    case 0x10a8: *out = 0x2d08; return 1;\n    case 0x10a9: *out = 0x2d09; return 1;\n    case 0x10aa: *out = 0x2d0a; return 1;\n    case 0x10ab: *out = 0x2d0b; return 1;\n    case 0x10ac: *out = 0x2d0c; return 1;\n    case 0x10ad: *out = 0x2d0d; return 1;\n    case 0x10ae: *out = 0x2d0e; return 1;\n    case 0x10af: *out = 0x2d0f; return 1;\n    case 0x10b0: *out = 0x2d10; return 1;\n    case 0x10b1: *out = 0x2d11; return 1;\n    case 0x10b2: *out = 0x2d12; return 1;\n    case 0x10b3: *out = 0x2d13; return 1;\n    case 0x10b4: *out = 0x2d14; return 1;\n    case 0x10b5: *out = 0x2d15; return 1;\n    case 0x10b6: *out = 0x2d16; return 1;\n    case 0x10b7: *out = 0x2d17; return 1;\n    case 0x10b8: *out = 0x2d18; return 1;\n    case 0x10b9: *out = 0x2d19; return 1;\n    case 0x10ba: *out = 0x2d1a; return 1;\n    case 0x10bb: *out = 0x2d1b; return 1;\n    case 0x10bc: *out = 0x2d1c; return 1;\n    case 0x10bd: *out = 0x2d1d; return 1;\n    case 0x10be: *out = 0x2d1e; return 1;\n    case 0x10bf: *out = 0x2d1f; return 1;\n    case 0x10c0: *out = 0x2d20; return 1;\n    case 0x10c1: *out = 0x2d21; return 1;\n    case 0x10c2: *out = 0x2d22; return 1;\n    case 0x10c3: *out = 0x2d23; return 1;\n    case 0x10c4: *out = 0x2d24; return 1;\n    case 0x10c5: *out = 0x2d25; return 1;\n    case 0x1e00: *out = 0x1e01; return 1;\n    case 0x1e02: *out = 0x1e03; return 1;\n    case 0x1e04: *out = 0x1e05; return 1;\n    case 0x1e06: *out = 0x1e07; return 1;\n    case 0x1e08: *out = 0x1e09; return 1;\n    case 0x1e0a: *out = 0x1e0b; return 1;\n    case 0x1e0c: *out = 0x1e0d; return 1;\n    case 0x1e0e: *out = 0x1e0f; return 1;\n    case 0x1e10: *out = 0x1e11; return 1;\n    case 0x1e12: *out = 0x1e13; return 1;\n    case 0x1e14: *out = 0x1e15; return 1;\n    case 0x1e16: *out = 0x1e17; return 1;\n    case 0x1e18: *out = 0x1e19; return 1;\n    case 0x1e1a: *out = 0x1e1b; return 1;\n    case 0x1e1c: *out = 0x1e1d; return 1;\n    case 0x1e1e: *out = 0x1e1f; return 1;\n    case 0x1e20: *out = 0x1e21; return 1;\n    case 0x1e22: *out = 0x1e23; return 1;\n    case 0x1e24: *out = 0x1e25; return 1;\n    case 0x1e26: *out = 0x1e27; return 1;\n    case 0x1e28: *out = 0x1e29; return 1;\n    case 0x1e2a: *out = 0x1e2b; return 1;\n    case 0x1e2c: *out = 0x1e2d; return 1;\n    case 0x1e2e: *out = 0x1e2f; return 1;\n    case 0x1e30: *out = 0x1e31; return 1;\n    case 0x1e32: *out = 0x1e33; return 1;\n    case 0x1e34: *out = 0x1e35; return 1;\n    case 0x1e36: *out = 0x1e37; return 1;\n    case 0x1e38: *out = 0x1e39; return 1;\n    case 0x1e3a: *out = 0x1e3b; return 1;\n    case 0x1e3c: *out = 0x1e3d; return 1;\n    case 0x1e3e: *out = 0x1e3f; return 1;\n    case 0x1e40: *out = 0x1e41; return 1;\n    case 0x1e42: *out = 0x1e43; return 1;\n    case 0x1e44: *out = 0x1e45; return 1;\n    case 0x1e46: *out = 0x1e47; return 1;\n    case 0x1e48: *out = 0x1e49; return 1;\n    case 0x1e4a: *out = 0x1e4b; return 1;\n    case 0x1e4c: *out = 0x1e4d; return 1;\n    case 0x1e4e: *out = 0x1e4f; return 1;\n    case 0x1e50: *out = 0x1e51; return 1;\n    case 0x1e52: *out = 0x1e53; return 1;\n    case 0x1e54: *out = 0x1e55; return 1;\n    case 0x1e56: *out = 0x1e57; return 1;\n    case 0x1e58: *out = 0x1e59; return 1;\n    case 0x1e5a: *out = 0x1e5b; return 1;\n    case 0x1e5c: *out = 0x1e5d; return 1;\n    case 0x1e5e: *out = 0x1e5f; return 1;\n    case 0x1e60: *out = 0x1e61; return 1;\n    case 0x1e62: *out = 0x1e63; return 1;\n    case 0x1e64: *out = 0x1e65; return 1;\n    case 0x1e66: *out = 0x1e67; return 1;\n    case 0x1e68: *out = 0x1e69; return 1;\n    case 0x1e6a: *out = 0x1e6b; return 1;\n    case 0x1e6c: *out = 0x1e6d; return 1;\n    case 0x1e6e: *out = 0x1e6f; return 1;\n    case 0x1e70: *out = 0x1e71; return 1;\n    case 0x1e72: *out = 0x1e73; return 1;\n    case 0x1e74: *out = 0x1e75; return 1;\n    case 0x1e76: *out = 0x1e77; return 1;\n    case 0x1e78: *out = 0x1e79; return 1;\n    case 0x1e7a: *out = 0x1e7b; return 1;\n    case 0x1e7c: *out = 0x1e7d; return 1;\n    case 0x1e7e: *out = 0x1e7f; return 1;\n    case 0x1e80: *out = 0x1e81; return 1;\n    case 0x1e82: *out = 0x1e83; return 1;\n    case 0x1e84: *out = 0x1e85; return 1;\n    case 0x1e86: *out = 0x1e87; return 1;\n    case 0x1e88: *out = 0x1e89; return 1;\n    case 0x1e8a: *out = 0x1e8b; return 1;\n    case 0x1e8c: *out = 0x1e8d; return 1;\n    case 0x1e8e: *out = 0x1e8f; return 1;\n    case 0x1e90: *out = 0x1e91; return 1;\n    case 0x1e92: *out = 0x1e93; return 1;\n    case 0x1e94: *out = 0x1e95; return 1;\n    case 0x1e96: out[ 0 ] = 0x68; out[ 1 ] = 0x331; return 2;\n    case 0x1e97: out[ 0 ] = 0x74; out[ 1 ] = 0x308; return 2;\n    case 0x1e98: out[ 0 ] = 0x77; out[ 1 ] = 0x30a; return 2;\n    case 0x1e99: out[ 0 ] = 0x79; out[ 1 ] = 0x30a; return 2;\n    case 0x1e9a: out[ 0 ] = 0x61; out[ 1 ] = 0x2be; return 2;\n    case 0x1e9b: *out = 0x1e61; return 1;\n    case 0x1e9e: out[ 0 ] = 0x73; out[ 1 ] = 0x73; return 2;\n    case 0x1ea0: *out = 0x1ea1; return 1;\n    case 0x1ea2: *out = 0x1ea3; return 1;\n    case 0x1ea4: *out = 0x1ea5; return 1;\n    case 0x1ea6: *out = 0x1ea7; return 1;\n    case 0x1ea8: *out = 0x1ea9; return 1;\n    case 0x1eaa: *out = 0x1eab; return 1;\n    case 0x1eac: *out = 0x1ead; return 1;\n    case 0x1eae: *out = 0x1eaf; return 1;\n    case 0x1eb0: *out = 0x1eb1; return 1;\n    case 0x1eb2: *out = 0x1eb3; return 1;\n    case 0x1eb4: *out = 0x1eb5; return 1;\n    case 0x1eb6: *out = 0x1eb7; return 1;\n    case 0x1eb8: *out = 0x1eb9; return 1;\n    case 0x1eba: *out = 0x1ebb; return 1;\n    case 0x1ebc: *out = 0x1ebd; return 1;\n    case 0x1ebe: *out = 0x1ebf; return 1;\n    case 0x1ec0: *out = 0x1ec1; return 1;\n    case 0x1ec2: *out = 0x1ec3; return 1;\n    case 0x1ec4: *out = 0x1ec5; return 1;\n    case 0x1ec6: *out = 0x1ec7; return 1;\n    case 0x1ec8: *out = 0x1ec9; return 1;\n    case 0x1eca: *out = 0x1ecb; return 1;\n    case 0x1ecc: *out = 0x1ecd; return 1;\n    case 0x1ece: *out = 0x1ecf; return 1;\n    case 0x1ed0: *out = 0x1ed1; return 1;\n    case 0x1ed2: *out = 0x1ed3; return 1;\n    case 0x1ed4: *out = 0x1ed5; return 1;\n    case 0x1ed6: *out = 0x1ed7; return 1;\n    case 0x1ed8: *out = 0x1ed9; return 1;\n    case 0x1eda: *out = 0x1edb; return 1;\n    case 0x1edc: *out = 0x1edd; return 1;\n    case 0x1ede: *out = 0x1edf; return 1;\n    case 0x1ee0: *out = 0x1ee1; return 1;\n    case 0x1ee2: *out = 0x1ee3; return 1;\n    case 0x1ee4: *out = 0x1ee5; return 1;\n    case 0x1ee6: *out = 0x1ee7; return 1;\n    case 0x1ee8: *out = 0x1ee9; return 1;\n    case 0x1eea: *out = 0x1eeb; return 1;\n    case 0x1eec: *out = 0x1eed; return 1;\n    case 0x1eee: *out = 0x1eef; return 1;\n    case 0x1ef0: *out = 0x1ef1; return 1;\n    case 0x1ef2: *out = 0x1ef3; return 1;\n    case 0x1ef4: *out = 0x1ef5; return 1;\n    case 0x1ef6: *out = 0x1ef7; return 1;\n    case 0x1ef8: *out = 0x1ef9; return 1;\n    case 0x1efa: *out = 0x1efb; return 1;\n    case 0x1efc: *out = 0x1efd; return 1;\n    case 0x1efe: *out = 0x1eff; return 1;\n    case 0x1f08: *out = 0x1f00; return 1;\n    case 0x1f09: *out = 0x1f01; return 1;\n    case 0x1f0a: *out = 0x1f02; return 1;\n    case 0x1f0b: *out = 0x1f03; return 1;\n    case 0x1f0c: *out = 0x1f04; return 1;\n    case 0x1f0d: *out = 0x1f05; return 1;\n    case 0x1f0e: *out = 0x1f06; return 1;\n    case 0x1f0f: *out = 0x1f07; return 1;\n    case 0x1f18: *out = 0x1f10; return 1;\n    case 0x1f19: *out = 0x1f11; return 1;\n    case 0x1f1a: *out = 0x1f12; return 1;\n    case 0x1f1b: *out = 0x1f13; return 1;\n    case 0x1f1c: *out = 0x1f14; return 1;\n    case 0x1f1d: *out = 0x1f15; return 1;\n    case 0x1f28: *out = 0x1f20; return 1;\n    case 0x1f29: *out = 0x1f21; return 1;\n    case 0x1f2a: *out = 0x1f22; return 1;\n    case 0x1f2b: *out = 0x1f23; return 1;\n    case 0x1f2c: *out = 0x1f24; return 1;\n    case 0x1f2d: *out = 0x1f25; return 1;\n    case 0x1f2e: *out = 0x1f26; return 1;\n    case 0x1f2f: *out = 0x1f27; return 1;\n    case 0x1f38: *out = 0x1f30; return 1;\n    case 0x1f39: *out = 0x1f31; return 1;\n    case 0x1f3a: *out = 0x1f32; return 1;\n    case 0x1f3b: *out = 0x1f33; return 1;\n    case 0x1f3c: *out = 0x1f34; return 1;\n    case 0x1f3d: *out = 0x1f35; return 1;\n    case 0x1f3e: *out = 0x1f36; return 1;\n    case 0x1f3f: *out = 0x1f37; return 1;\n    case 0x1f48: *out = 0x1f40; return 1;\n    case 0x1f49: *out = 0x1f41; return 1;\n    case 0x1f4a: *out = 0x1f42; return 1;\n    case 0x1f4b: *out = 0x1f43; return 1;\n    case 0x1f4c: *out = 0x1f44; return 1;\n    case 0x1f4d: *out = 0x1f45; return 1;\n    case 0x1f50: out[ 0 ] = 0x3c5; out[ 1 ] = 0x313; return 2;\n    case 0x1f52: out[ 0 ] = 0x3c5; out[ 1 ] = 0x313; out[ 2 ] = 0x300; return 3;\n    case 0x1f54: out[ 0 ] = 0x3c5; out[ 1 ] = 0x313; out[ 2 ] = 0x301; return 3;\n    case 0x1f56: out[ 0 ] = 0x3c5; out[ 1 ] = 0x313; out[ 2 ] = 0x342; return 3;\n    case 0x1f59: *out = 0x1f51; return 1;\n    case 0x1f5b: *out = 0x1f53; return 1;\n    case 0x1f5d: *out = 0x1f55; return 1;\n    case 0x1f5f: *out = 0x1f57; return 1;\n    case 0x1f68: *out = 0x1f60; return 1;\n    case 0x1f69: *out = 0x1f61; return 1;\n    case 0x1f6a: *out = 0x1f62; return 1;\n    case 0x1f6b: *out = 0x1f63; return 1;\n    case 0x1f6c: *out = 0x1f64; return 1;\n    case 0x1f6d: *out = 0x1f65; return 1;\n    case 0x1f6e: *out = 0x1f66; return 1;\n    case 0x1f6f: *out = 0x1f67; return 1;\n    case 0x1f80: out[ 0 ] = 0x1f00; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f81: out[ 0 ] = 0x1f01; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f82: out[ 0 ] = 0x1f02; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f83: out[ 0 ] = 0x1f03; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f84: out[ 0 ] = 0x1f04; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f85: out[ 0 ] = 0x1f05; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f86: out[ 0 ] = 0x1f06; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f87: out[ 0 ] = 0x1f07; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f88: out[ 0 ] = 0x1f00; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f89: out[ 0 ] = 0x1f01; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f8a: out[ 0 ] = 0x1f02; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f8b: out[ 0 ] = 0x1f03; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f8c: out[ 0 ] = 0x1f04; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f8d: out[ 0 ] = 0x1f05; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f8e: out[ 0 ] = 0x1f06; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f8f: out[ 0 ] = 0x1f07; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f90: out[ 0 ] = 0x1f20; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f91: out[ 0 ] = 0x1f21; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f92: out[ 0 ] = 0x1f22; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f93: out[ 0 ] = 0x1f23; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f94: out[ 0 ] = 0x1f24; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f95: out[ 0 ] = 0x1f25; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f96: out[ 0 ] = 0x1f26; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f97: out[ 0 ] = 0x1f27; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f98: out[ 0 ] = 0x1f20; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f99: out[ 0 ] = 0x1f21; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f9a: out[ 0 ] = 0x1f22; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f9b: out[ 0 ] = 0x1f23; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f9c: out[ 0 ] = 0x1f24; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f9d: out[ 0 ] = 0x1f25; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f9e: out[ 0 ] = 0x1f26; out[ 1 ] = 0x3b9; return 2;\n    case 0x1f9f: out[ 0 ] = 0x1f27; out[ 1 ] = 0x3b9; return 2;\n    case 0x1fa0: out[ 0 ] = 0x1f60; out[ 1 ] = 0x3b9; return 2;\n    case 0x1fa1: out[ 0 ] = 0x1f61; out[ 1 ] = 0x3b9; return 2;\n    case 0x1fa2: out[ 0 ] = 0x1f62; out[ 1 ] = 0x3b9; return 2;\n    case 0x1fa3: out[ 0 ] = 0x1f63; out[ 1 ] = 0x3b9; return 2;\n    case 0x1fa4: out[ 0 ] = 0x1f64; out[ 1 ] = 0x3b9; return 2;\n    case 0x1fa5: out[ 0 ] = 0x1f65; out[ 1 ] = 0x3b9; return 2;\n    case 0x1fa6: out[ 0 ] = 0x1f66; out[ 1 ] = 0x3b9; return 2;\n    case 0x1fa7: out[ 0 ] = 0x1f67; out[ 1 ] = 0x3b9; return 2;\n    case 0x1fa8: out[ 0 ] = 0x1f60; out[ 1 ] = 0x3b9; return 2;\n    case 0x1fa9: out[ 0 ] = 0x1f61; out[ 1 ] = 0x3b9; return 2;\n    case 0x1faa: out[ 0 ] = 0x1f62; out[ 1 ] = 0x3b9; return 2;\n    case 0x1fab: out[ 0 ] = 0x1f63; out[ 1 ] = 0x3b9; return 2;\n    case 0x1fac: out[ 0 ] = 0x1f64; out[ 1 ] = 0x3b9; return 2;\n    case 0x1fad: out[ 0 ] = 0x1f65; out[ 1 ] = 0x3b9; return 2;\n    case 0x1fae: out[ 0 ] = 0x1f66; out[ 1 ] = 0x3b9; return 2;\n    case 0x1faf: out[ 0 ] = 0x1f67; out[ 1 ] = 0x3b9; return 2;\n    case 0x1fb2: out[ 0 ] = 0x1f70; out[ 1 ] = 0x3b9; return 2;\n    case 0x1fb3: out[ 0 ] = 0x3b1; out[ 1 ] = 0x3b9; return 2;\n    case 0x1fb4: out[ 0 ] = 0x3ac; out[ 1 ] = 0x3b9; return 2;\n    case 0x1fb6: out[ 0 ] = 0x3b1; out[ 1 ] = 0x342; return 2;\n    case 0x1fb7: out[ 0 ] = 0x3b1; out[ 1 ] = 0x342; out[ 2 ] = 0x3b9; return 3;\n    case 0x1fb8: *out = 0x1fb0; return 1;\n    case 0x1fb9: *out = 0x1fb1; return 1;\n    case 0x1fba: *out = 0x1f70; return 1;\n    case 0x1fbb: *out = 0x1f71; return 1;\n    case 0x1fbc: out[ 0 ] = 0x3b1; out[ 1 ] = 0x3b9; return 2;\n    case 0x1fbe: *out = 0x3b9; return 1;\n    case 0x1fc2: out[ 0 ] = 0x1f74; out[ 1 ] = 0x3b9; return 2;\n    case 0x1fc3: out[ 0 ] = 0x3b7; out[ 1 ] = 0x3b9; return 2;\n    case 0x1fc4: out[ 0 ] = 0x3ae; out[ 1 ] = 0x3b9; return 2;\n    case 0x1fc6: out[ 0 ] = 0x3b7; out[ 1 ] = 0x342; return 2;\n    case 0x1fc7: out[ 0 ] = 0x3b7; out[ 1 ] = 0x342; out[ 2 ] = 0x3b9; return 3;\n    case 0x1fc8: *out = 0x1f72; return 1;\n    case 0x1fc9: *out = 0x1f73; return 1;\n    case 0x1fca: *out = 0x1f74; return 1;\n    case 0x1fcb: *out = 0x1f75; return 1;\n    case 0x1fcc: out[ 0 ] = 0x3b7; out[ 1 ] = 0x3b9; return 2;\n    case 0x1fd2: out[ 0 ] = 0x3b9; out[ 1 ] = 0x308; out[ 2 ] = 0x300; return 3;\n    case 0x1fd3: out[ 0 ] = 0x3b9; out[ 1 ] = 0x308; out[ 2 ] = 0x301; return 3;\n    case 0x1fd6: out[ 0 ] = 0x3b9; out[ 1 ] = 0x342; return 2;\n    case 0x1fd7: out[ 0 ] = 0x3b9; out[ 1 ] = 0x308; out[ 2 ] = 0x342; return 3;\n    case 0x1fd8: *out = 0x1fd0; return 1;\n    case 0x1fd9: *out = 0x1fd1; return 1;\n    case 0x1fda: *out = 0x1f76; return 1;\n    case 0x1fdb: *out = 0x1f77; return 1;\n    case 0x1fe2: out[ 0 ] = 0x3c5; out[ 1 ] = 0x308; out[ 2 ] = 0x300; return 3;\n    case 0x1fe3: out[ 0 ] = 0x3c5; out[ 1 ] = 0x308; out[ 2 ] = 0x301; return 3;\n    case 0x1fe4: out[ 0 ] = 0x3c1; out[ 1 ] = 0x313; return 2;\n    case 0x1fe6: out[ 0 ] = 0x3c5; out[ 1 ] = 0x342; return 2;\n    case 0x1fe7: out[ 0 ] = 0x3c5; out[ 1 ] = 0x308; out[ 2 ] = 0x342; return 3;\n    case 0x1fe8: *out = 0x1fe0; return 1;\n    case 0x1fe9: *out = 0x1fe1; return 1;\n    case 0x1fea: *out = 0x1f7a; return 1;\n    case 0x1feb: *out = 0x1f7b; return 1;\n    case 0x1fec: *out = 0x1fe5; return 1;\n    case 0x1ff2: out[ 0 ] = 0x1f7c; out[ 1 ] = 0x3b9; return 2;\n    case 0x1ff3: out[ 0 ] = 0x3c9; out[ 1 ] = 0x3b9; return 2;\n    case 0x1ff4: out[ 0 ] = 0x3ce; out[ 1 ] = 0x3b9; return 2;\n    case 0x1ff6: out[ 0 ] = 0x3c9; out[ 1 ] = 0x342; return 2;\n    case 0x1ff7: out[ 0 ] = 0x3c9; out[ 1 ] = 0x342; out[ 2 ] = 0x3b9; return 3;\n    case 0x1ff8: *out = 0x1f78; return 1;\n    case 0x1ff9: *out = 0x1f79; return 1;\n    case 0x1ffa: *out = 0x1f7c; return 1;\n    case 0x1ffb: *out = 0x1f7d; return 1;\n    case 0x1ffc: out[ 0 ] = 0x3c9; out[ 1 ] = 0x3b9; return 2;\n    case 0x2126: *out = 0x3c9; return 1;\n    case 0x212a: *out = 0x6b; return 1;\n    case 0x212b: *out = 0xe5; return 1;\n    case 0x2132: *out = 0x214e; return 1;\n    case 0x2160: *out = 0x2170; return 1;\n    case 0x2161: *out = 0x2171; return 1;\n    case 0x2162: *out = 0x2172; return 1;\n    case 0x2163: *out = 0x2173; return 1;\n    case 0x2164: *out = 0x2174; return 1;\n    case 0x2165: *out = 0x2175; return 1;\n    case 0x2166: *out = 0x2176; return 1;\n    case 0x2167: *out = 0x2177; return 1;\n    case 0x2168: *out = 0x2178; return 1;\n    case 0x2169: *out = 0x2179; return 1;\n    case 0x216a: *out = 0x217a; return 1;\n    case 0x216b: *out = 0x217b; return 1;\n    case 0x216c: *out = 0x217c; return 1;\n    case 0x216d: *out = 0x217d; return 1;\n    case 0x216e: *out = 0x217e; return 1;\n    case 0x216f: *out = 0x217f; return 1;\n    case 0x2183: *out = 0x2184; return 1;\n    case 0x24b6: *out = 0x24d0; return 1;\n    case 0x24b7: *out = 0x24d1; return 1;\n    case 0x24b8: *out = 0x24d2; return 1;\n    case 0x24b9: *out = 0x24d3; return 1;\n    case 0x24ba: *out = 0x24d4; return 1;\n    case 0x24bb: *out = 0x24d5; return 1;\n    case 0x24bc: *out = 0x24d6; return 1;\n    case 0x24bd: *out = 0x24d7; return 1;\n    case 0x24be: *out = 0x24d8; return 1;\n    case 0x24bf: *out = 0x24d9; return 1;\n    case 0x24c0: *out = 0x24da; return 1;\n    case 0x24c1: *out = 0x24db; return 1;\n    case 0x24c2: *out = 0x24dc; return 1;\n    case 0x24c3: *out = 0x24dd; return 1;\n    case 0x24c4: *out = 0x24de; return 1;\n    case 0x24c5: *out = 0x24df; return 1;\n    case 0x24c6: *out = 0x24e0; return 1;\n    case 0x24c7: *out = 0x24e1; return 1;\n    case 0x24c8: *out = 0x24e2; return 1;\n    case 0x24c9: *out = 0x24e3; return 1;\n    case 0x24ca: *out = 0x24e4; return 1;\n    case 0x24cb: *out = 0x24e5; return 1;\n    case 0x24cc: *out = 0x24e6; return 1;\n    case 0x24cd: *out = 0x24e7; return 1;\n    case 0x24ce: *out = 0x24e8; return 1;\n    case 0x24cf: *out = 0x24e9; return 1;\n    case 0x2c00: *out = 0x2c30; return 1;\n    case 0x2c01: *out = 0x2c31; return 1;\n    case 0x2c02: *out = 0x2c32; return 1;\n    case 0x2c03: *out = 0x2c33; return 1;\n    case 0x2c04: *out = 0x2c34; return 1;\n    case 0x2c05: *out = 0x2c35; return 1;\n    case 0x2c06: *out = 0x2c36; return 1;\n    case 0x2c07: *out = 0x2c37; return 1;\n    case 0x2c08: *out = 0x2c38; return 1;\n    case 0x2c09: *out = 0x2c39; return 1;\n    case 0x2c0a: *out = 0x2c3a; return 1;\n    case 0x2c0b: *out = 0x2c3b; return 1;\n    case 0x2c0c: *out = 0x2c3c; return 1;\n    case 0x2c0d: *out = 0x2c3d; return 1;\n    case 0x2c0e: *out = 0x2c3e; return 1;\n    case 0x2c0f: *out = 0x2c3f; return 1;\n    case 0x2c10: *out = 0x2c40; return 1;\n    case 0x2c11: *out = 0x2c41; return 1;\n    case 0x2c12: *out = 0x2c42; return 1;\n    case 0x2c13: *out = 0x2c43; return 1;\n    case 0x2c14: *out = 0x2c44; return 1;\n    case 0x2c15: *out = 0x2c45; return 1;\n    case 0x2c16: *out = 0x2c46; return 1;\n    case 0x2c17: *out = 0x2c47; return 1;\n    case 0x2c18: *out = 0x2c48; return 1;\n    case 0x2c19: *out = 0x2c49; return 1;\n    case 0x2c1a: *out = 0x2c4a; return 1;\n    case 0x2c1b: *out = 0x2c4b; return 1;\n    case 0x2c1c: *out = 0x2c4c; return 1;\n    case 0x2c1d: *out = 0x2c4d; return 1;\n    case 0x2c1e: *out = 0x2c4e; return 1;\n    case 0x2c1f: *out = 0x2c4f; return 1;\n    case 0x2c20: *out = 0x2c50; return 1;\n    case 0x2c21: *out = 0x2c51; return 1;\n    case 0x2c22: *out = 0x2c52; return 1;\n    case 0x2c23: *out = 0x2c53; return 1;\n    case 0x2c24: *out = 0x2c54; return 1;\n    case 0x2c25: *out = 0x2c55; return 1;\n    case 0x2c26: *out = 0x2c56; return 1;\n    case 0x2c27: *out = 0x2c57; return 1;\n    case 0x2c28: *out = 0x2c58; return 1;\n    case 0x2c29: *out = 0x2c59; return 1;\n    case 0x2c2a: *out = 0x2c5a; return 1;\n    case 0x2c2b: *out = 0x2c5b; return 1;\n    case 0x2c2c: *out = 0x2c5c; return 1;\n    case 0x2c2d: *out = 0x2c5d; return 1;\n    case 0x2c2e: *out = 0x2c5e; return 1;\n    case 0x2c60: *out = 0x2c61; return 1;\n    case 0x2c62: *out = 0x26b; return 1;\n    case 0x2c63: *out = 0x1d7d; return 1;\n    case 0x2c64: *out = 0x27d; return 1;\n    case 0x2c67: *out = 0x2c68; return 1;\n    case 0x2c69: *out = 0x2c6a; return 1;\n    case 0x2c6b: *out = 0x2c6c; return 1;\n    case 0x2c6d: *out = 0x251; return 1;\n    case 0x2c6e: *out = 0x271; return 1;\n    case 0x2c6f: *out = 0x250; return 1;\n    case 0x2c70: *out = 0x252; return 1;\n    case 0x2c72: *out = 0x2c73; return 1;\n    case 0x2c75: *out = 0x2c76; return 1;\n    case 0x2c7e: *out = 0x23f; return 1;\n    case 0x2c7f: *out = 0x240; return 1;\n    case 0x2c80: *out = 0x2c81; return 1;\n    case 0x2c82: *out = 0x2c83; return 1;\n    case 0x2c84: *out = 0x2c85; return 1;\n    case 0x2c86: *out = 0x2c87; return 1;\n    case 0x2c88: *out = 0x2c89; return 1;\n    case 0x2c8a: *out = 0x2c8b; return 1;\n    case 0x2c8c: *out = 0x2c8d; return 1;\n    case 0x2c8e: *out = 0x2c8f; return 1;\n    case 0x2c90: *out = 0x2c91; return 1;\n    case 0x2c92: *out = 0x2c93; return 1;\n    case 0x2c94: *out = 0x2c95; return 1;\n    case 0x2c96: *out = 0x2c97; return 1;\n    case 0x2c98: *out = 0x2c99; return 1;\n    case 0x2c9a: *out = 0x2c9b; return 1;\n    case 0x2c9c: *out = 0x2c9d; return 1;\n    case 0x2c9e: *out = 0x2c9f; return 1;\n    case 0x2ca0: *out = 0x2ca1; return 1;\n    case 0x2ca2: *out = 0x2ca3; return 1;\n    case 0x2ca4: *out = 0x2ca5; return 1;\n    case 0x2ca6: *out = 0x2ca7; return 1;\n    case 0x2ca8: *out = 0x2ca9; return 1;\n    case 0x2caa: *out = 0x2cab; return 1;\n    case 0x2cac: *out = 0x2cad; return 1;\n    case 0x2cae: *out = 0x2caf; return 1;\n    case 0x2cb0: *out = 0x2cb1; return 1;\n    case 0x2cb2: *out = 0x2cb3; return 1;\n    case 0x2cb4: *out = 0x2cb5; return 1;\n    case 0x2cb6: *out = 0x2cb7; return 1;\n    case 0x2cb8: *out = 0x2cb9; return 1;\n    case 0x2cba: *out = 0x2cbb; return 1;\n    case 0x2cbc: *out = 0x2cbd; return 1;\n    case 0x2cbe: *out = 0x2cbf; return 1;\n    case 0x2cc0: *out = 0x2cc1; return 1;\n    case 0x2cc2: *out = 0x2cc3; return 1;\n    case 0x2cc4: *out = 0x2cc5; return 1;\n    case 0x2cc6: *out = 0x2cc7; return 1;\n    case 0x2cc8: *out = 0x2cc9; return 1;\n    case 0x2cca: *out = 0x2ccb; return 1;\n    case 0x2ccc: *out = 0x2ccd; return 1;\n    case 0x2cce: *out = 0x2ccf; return 1;\n    case 0x2cd0: *out = 0x2cd1; return 1;\n    case 0x2cd2: *out = 0x2cd3; return 1;\n    case 0x2cd4: *out = 0x2cd5; return 1;\n    case 0x2cd6: *out = 0x2cd7; return 1;\n    case 0x2cd8: *out = 0x2cd9; return 1;\n    case 0x2cda: *out = 0x2cdb; return 1;\n    case 0x2cdc: *out = 0x2cdd; return 1;\n    case 0x2cde: *out = 0x2cdf; return 1;\n    case 0x2ce0: *out = 0x2ce1; return 1;\n    case 0x2ce2: *out = 0x2ce3; return 1;\n    case 0x2ceb: *out = 0x2cec; return 1;\n    case 0x2ced: *out = 0x2cee; return 1;\n    case 0xa640: *out = 0xa641; return 1;\n    case 0xa642: *out = 0xa643; return 1;\n    case 0xa644: *out = 0xa645; return 1;\n    case 0xa646: *out = 0xa647; return 1;\n    case 0xa648: *out = 0xa649; return 1;\n    case 0xa64a: *out = 0xa64b; return 1;\n    case 0xa64c: *out = 0xa64d; return 1;\n    case 0xa64e: *out = 0xa64f; return 1;\n    case 0xa650: *out = 0xa651; return 1;\n    case 0xa652: *out = 0xa653; return 1;\n    case 0xa654: *out = 0xa655; return 1;\n    case 0xa656: *out = 0xa657; return 1;\n    case 0xa658: *out = 0xa659; return 1;\n    case 0xa65a: *out = 0xa65b; return 1;\n    case 0xa65c: *out = 0xa65d; return 1;\n    case 0xa65e: *out = 0xa65f; return 1;\n    case 0xa662: *out = 0xa663; return 1;\n    case 0xa664: *out = 0xa665; return 1;\n    case 0xa666: *out = 0xa667; return 1;\n    case 0xa668: *out = 0xa669; return 1;\n    case 0xa66a: *out = 0xa66b; return 1;\n    case 0xa66c: *out = 0xa66d; return 1;\n    case 0xa680: *out = 0xa681; return 1;\n    case 0xa682: *out = 0xa683; return 1;\n    case 0xa684: *out = 0xa685; return 1;\n    case 0xa686: *out = 0xa687; return 1;\n    case 0xa688: *out = 0xa689; return 1;\n    case 0xa68a: *out = 0xa68b; return 1;\n    case 0xa68c: *out = 0xa68d; return 1;\n    case 0xa68e: *out = 0xa68f; return 1;\n    case 0xa690: *out = 0xa691; return 1;\n    case 0xa692: *out = 0xa693; return 1;\n    case 0xa694: *out = 0xa695; return 1;\n    case 0xa696: *out = 0xa697; return 1;\n    case 0xa722: *out = 0xa723; return 1;\n    case 0xa724: *out = 0xa725; return 1;\n    case 0xa726: *out = 0xa727; return 1;\n    case 0xa728: *out = 0xa729; return 1;\n    case 0xa72a: *out = 0xa72b; return 1;\n    case 0xa72c: *out = 0xa72d; return 1;\n    case 0xa72e: *out = 0xa72f; return 1;\n    case 0xa732: *out = 0xa733; return 1;\n    case 0xa734: *out = 0xa735; return 1;\n    case 0xa736: *out = 0xa737; return 1;\n    case 0xa738: *out = 0xa739; return 1;\n    case 0xa73a: *out = 0xa73b; return 1;\n    case 0xa73c: *out = 0xa73d; return 1;\n    case 0xa73e: *out = 0xa73f; return 1;\n    case 0xa740: *out = 0xa741; return 1;\n    case 0xa742: *out = 0xa743; return 1;\n    case 0xa744: *out = 0xa745; return 1;\n    case 0xa746: *out = 0xa747; return 1;\n    case 0xa748: *out = 0xa749; return 1;\n    case 0xa74a: *out = 0xa74b; return 1;\n    case 0xa74c: *out = 0xa74d; return 1;\n    case 0xa74e: *out = 0xa74f; return 1;\n    case 0xa750: *out = 0xa751; return 1;\n    case 0xa752: *out = 0xa753; return 1;\n    case 0xa754: *out = 0xa755; return 1;\n    case 0xa756: *out = 0xa757; return 1;\n    case 0xa758: *out = 0xa759; return 1;\n    case 0xa75a: *out = 0xa75b; return 1;\n    case 0xa75c: *out = 0xa75d; return 1;\n    case 0xa75e: *out = 0xa75f; return 1;\n    case 0xa760: *out = 0xa761; return 1;\n    case 0xa762: *out = 0xa763; return 1;\n    case 0xa764: *out = 0xa765; return 1;\n    case 0xa766: *out = 0xa767; return 1;\n    case 0xa768: *out = 0xa769; return 1;\n    case 0xa76a: *out = 0xa76b; return 1;\n    case 0xa76c: *out = 0xa76d; return 1;\n    case 0xa76e: *out = 0xa76f; return 1;\n    case 0xa779: *out = 0xa77a; return 1;\n    case 0xa77b: *out = 0xa77c; return 1;\n    case 0xa77d: *out = 0x1d79; return 1;\n    case 0xa77e: *out = 0xa77f; return 1;\n    case 0xa780: *out = 0xa781; return 1;\n    case 0xa782: *out = 0xa783; return 1;\n    case 0xa784: *out = 0xa785; return 1;\n    case 0xa786: *out = 0xa787; return 1;\n    case 0xa78b: *out = 0xa78c; return 1;\n    case 0xfb00: out[ 0 ] = 0x66; out[ 1 ] = 0x66; return 2;\n    case 0xfb01: out[ 0 ] = 0x66; out[ 1 ] = 0x69; return 2;\n    case 0xfb02: out[ 0 ] = 0x66; out[ 1 ] = 0x6c; return 2;\n    case 0xfb03: out[ 0 ] = 0x66; out[ 1 ] = 0x66; out[ 2 ] = 0x69; return 3;\n    case 0xfb04: out[ 0 ] = 0x66; out[ 1 ] = 0x66; out[ 2 ] = 0x6c; return 3;\n    case 0xfb05: out[ 0 ] = 0x73; out[ 1 ] = 0x74; return 2;\n    case 0xfb06: out[ 0 ] = 0x73; out[ 1 ] = 0x74; return 2;\n    case 0xfb13: out[ 0 ] = 0x574; out[ 1 ] = 0x576; return 2;\n    case 0xfb14: out[ 0 ] = 0x574; out[ 1 ] = 0x565; return 2;\n    case 0xfb15: out[ 0 ] = 0x574; out[ 1 ] = 0x56b; return 2;\n    case 0xfb16: out[ 0 ] = 0x57e; out[ 1 ] = 0x576; return 2;\n    case 0xfb17: out[ 0 ] = 0x574; out[ 1 ] = 0x56d; return 2;\n    case 0xff21: *out = 0xff41; return 1;\n    case 0xff22: *out = 0xff42; return 1;\n    case 0xff23: *out = 0xff43; return 1;\n    case 0xff24: *out = 0xff44; return 1;\n    case 0xff25: *out = 0xff45; return 1;\n    case 0xff26: *out = 0xff46; return 1;\n    case 0xff27: *out = 0xff47; return 1;\n    case 0xff28: *out = 0xff48; return 1;\n    case 0xff29: *out = 0xff49; return 1;\n    case 0xff2a: *out = 0xff4a; return 1;\n    case 0xff2b: *out = 0xff4b; return 1;\n    case 0xff2c: *out = 0xff4c; return 1;\n    case 0xff2d: *out = 0xff4d; return 1;\n    case 0xff2e: *out = 0xff4e; return 1;\n    case 0xff2f: *out = 0xff4f; return 1;\n    case 0xff30: *out = 0xff50; return 1;\n    case 0xff31: *out = 0xff51; return 1;\n    case 0xff32: *out = 0xff52; return 1;\n    case 0xff33: *out = 0xff53; return 1;\n    case 0xff34: *out = 0xff54; return 1;\n    case 0xff35: *out = 0xff55; return 1;\n    case 0xff36: *out = 0xff56; return 1;\n    case 0xff37: *out = 0xff57; return 1;\n    case 0xff38: *out = 0xff58; return 1;\n    case 0xff39: *out = 0xff59; return 1;\n    case 0xff3a: *out = 0xff5a; return 1;\n    case 0x10400: *out = 0x10428; return 1;\n    case 0x10401: *out = 0x10429; return 1;\n    case 0x10402: *out = 0x1042a; return 1;\n    case 0x10403: *out = 0x1042b; return 1;\n    case 0x10404: *out = 0x1042c; return 1;\n    case 0x10405: *out = 0x1042d; return 1;\n    case 0x10406: *out = 0x1042e; return 1;\n    case 0x10407: *out = 0x1042f; return 1;\n    case 0x10408: *out = 0x10430; return 1;\n    case 0x10409: *out = 0x10431; return 1;\n    case 0x1040a: *out = 0x10432; return 1;\n    case 0x1040b: *out = 0x10433; return 1;\n    case 0x1040c: *out = 0x10434; return 1;\n    case 0x1040d: *out = 0x10435; return 1;\n    case 0x1040e: *out = 0x10436; return 1;\n    case 0x1040f: *out = 0x10437; return 1;\n    case 0x10410: *out = 0x10438; return 1;\n    case 0x10411: *out = 0x10439; return 1;\n    case 0x10412: *out = 0x1043a; return 1;\n    case 0x10413: *out = 0x1043b; return 1;\n    case 0x10414: *out = 0x1043c; return 1;\n    case 0x10415: *out = 0x1043d; return 1;\n    case 0x10416: *out = 0x1043e; return 1;\n    case 0x10417: *out = 0x1043f; return 1;\n    case 0x10418: *out = 0x10440; return 1;\n    case 0x10419: *out = 0x10441; return 1;\n    case 0x1041a: *out = 0x10442; return 1;\n    case 0x1041b: *out = 0x10443; return 1;\n    case 0x1041c: *out = 0x10444; return 1;\n    case 0x1041d: *out = 0x10445; return 1;\n    case 0x1041e: *out = 0x10446; return 1;\n    case 0x1041f: *out = 0x10447; return 1;\n    case 0x10420: *out = 0x10448; return 1;\n    case 0x10421: *out = 0x10449; return 1;\n    case 0x10422: *out = 0x1044a; return 1;\n    case 0x10423: *out = 0x1044b; return 1;\n    case 0x10424: *out = 0x1044c; return 1;\n    case 0x10425: *out = 0x1044d; return 1;\n    case 0x10426: *out = 0x1044e; return 1;\n    case 0x10427: *out = 0x1044f; return 1;\n    default: *out = in; return 1;\n  }\n}\n\nwchar foldCaseSimple( wchar in )\n{\n  switch( in )\n  {\n    case 0x41: return 0x61;\n    case 0x42: return 0x62;\n    case 0x43: return 0x63;\n    case 0x44: return 0x64;\n    case 0x45: return 0x65;\n    case 0x46: return 0x66;\n    case 0x47: return 0x67;\n    case 0x48: return 0x68;\n    case 0x49: return 0x69;\n    case 0x4a: return 0x6a;\n    case 0x4b: return 0x6b;\n    case 0x4c: return 0x6c;\n    case 0x4d: return 0x6d;\n    case 0x4e: return 0x6e;\n    case 0x4f: return 0x6f;\n    case 0x50: return 0x70;\n    case 0x51: return 0x71;\n    case 0x52: return 0x72;\n    case 0x53: return 0x73;\n    case 0x54: return 0x74;\n    case 0x55: return 0x75;\n    case 0x56: return 0x76;\n    case 0x57: return 0x77;\n    case 0x58: return 0x78;\n    case 0x59: return 0x79;\n    case 0x5a: return 0x7a;\n    case 0xb5: return 0x3bc;\n    case 0xc0: return 0xe0;\n    case 0xc1: return 0xe1;\n    case 0xc2: return 0xe2;\n    case 0xc3: return 0xe3;\n    case 0xc4: return 0xe4;\n    case 0xc5: return 0xe5;\n    case 0xc6: return 0xe6;\n    case 0xc7: return 0xe7;\n    case 0xc8: return 0xe8;\n    case 0xc9: return 0xe9;\n    case 0xca: return 0xea;\n    case 0xcb: return 0xeb;\n    case 0xcc: return 0xec;\n    case 0xcd: return 0xed;\n    case 0xce: return 0xee;\n    case 0xcf: return 0xef;\n    case 0xd0: return 0xf0;\n    case 0xd1: return 0xf1;\n    case 0xd2: return 0xf2;\n    case 0xd3: return 0xf3;\n    case 0xd4: return 0xf4;\n    case 0xd5: return 0xf5;\n    case 0xd6: return 0xf6;\n    case 0xd8: return 0xf8;\n    case 0xd9: return 0xf9;\n    case 0xda: return 0xfa;\n    case 0xdb: return 0xfb;\n    case 0xdc: return 0xfc;\n    case 0xdd: return 0xfd;\n    case 0xde: return 0xfe;\n    case 0x100: return 0x101;\n    case 0x102: return 0x103;\n    case 0x104: return 0x105;\n    case 0x106: return 0x107;\n    case 0x108: return 0x109;\n    case 0x10a: return 0x10b;\n    case 0x10c: return 0x10d;\n    case 0x10e: return 0x10f;\n    case 0x110: return 0x111;\n    case 0x112: return 0x113;\n    case 0x114: return 0x115;\n    case 0x116: return 0x117;\n    case 0x118: return 0x119;\n    case 0x11a: return 0x11b;\n    case 0x11c: return 0x11d;\n    case 0x11e: return 0x11f;\n    case 0x120: return 0x121;\n    case 0x122: return 0x123;\n    case 0x124: return 0x125;\n    case 0x126: return 0x127;\n    case 0x128: return 0x129;\n    case 0x12a: return 0x12b;\n    case 0x12c: return 0x12d;\n    case 0x12e: return 0x12f;\n    case 0x132: return 0x133;\n    case 0x134: return 0x135;\n    case 0x136: return 0x137;\n    case 0x139: return 0x13a;\n    case 0x13b: return 0x13c;\n    case 0x13d: return 0x13e;\n    case 0x13f: return 0x140;\n    case 0x141: return 0x142;\n    case 0x143: return 0x144;\n    case 0x145: return 0x146;\n    case 0x147: return 0x148;\n    case 0x14a: return 0x14b;\n    case 0x14c: return 0x14d;\n    case 0x14e: return 0x14f;\n    case 0x150: return 0x151;\n    case 0x152: return 0x153;\n    case 0x154: return 0x155;\n    case 0x156: return 0x157;\n    case 0x158: return 0x159;\n    case 0x15a: return 0x15b;\n    case 0x15c: return 0x15d;\n    case 0x15e: return 0x15f;\n    case 0x160: return 0x161;\n    case 0x162: return 0x163;\n    case 0x164: return 0x165;\n    case 0x166: return 0x167;\n    case 0x168: return 0x169;\n    case 0x16a: return 0x16b;\n    case 0x16c: return 0x16d;\n    case 0x16e: return 0x16f;\n    case 0x170: return 0x171;\n    case 0x172: return 0x173;\n    case 0x174: return 0x175;\n    case 0x176: return 0x177;\n    case 0x178: return 0xff;\n    case 0x179: return 0x17a;\n    case 0x17b: return 0x17c;\n    case 0x17d: return 0x17e;\n    case 0x17f: return 0x73;\n    case 0x181: return 0x253;\n    case 0x182: return 0x183;\n    case 0x184: return 0x185;\n    case 0x186: return 0x254;\n    case 0x187: return 0x188;\n    case 0x189: return 0x256;\n    case 0x18a: return 0x257;\n    case 0x18b: return 0x18c;\n    case 0x18e: return 0x1dd;\n    case 0x18f: return 0x259;\n    case 0x190: return 0x25b;\n    case 0x191: return 0x192;\n    case 0x193: return 0x260;\n    case 0x194: return 0x263;\n    case 0x196: return 0x269;\n    case 0x197: return 0x268;\n    case 0x198: return 0x199;\n    case 0x19c: return 0x26f;\n    case 0x19d: return 0x272;\n    case 0x19f: return 0x275;\n    case 0x1a0: return 0x1a1;\n    case 0x1a2: return 0x1a3;\n    case 0x1a4: return 0x1a5;\n    case 0x1a6: return 0x280;\n    case 0x1a7: return 0x1a8;\n    case 0x1a9: return 0x283;\n    case 0x1ac: return 0x1ad;\n    case 0x1ae: return 0x288;\n    case 0x1af: return 0x1b0;\n    case 0x1b1: return 0x28a;\n    case 0x1b2: return 0x28b;\n    case 0x1b3: return 0x1b4;\n    case 0x1b5: return 0x1b6;\n    case 0x1b7: return 0x292;\n    case 0x1b8: return 0x1b9;\n    case 0x1bc: return 0x1bd;\n    case 0x1c4: return 0x1c6;\n    case 0x1c5: return 0x1c6;\n    case 0x1c7: return 0x1c9;\n    case 0x1c8: return 0x1c9;\n    case 0x1ca: return 0x1cc;\n    case 0x1cb: return 0x1cc;\n    case 0x1cd: return 0x1ce;\n    case 0x1cf: return 0x1d0;\n    case 0x1d1: return 0x1d2;\n    case 0x1d3: return 0x1d4;\n    case 0x1d5: return 0x1d6;\n    case 0x1d7: return 0x1d8;\n    case 0x1d9: return 0x1da;\n    case 0x1db: return 0x1dc;\n    case 0x1de: return 0x1df;\n    case 0x1e0: return 0x1e1;\n    case 0x1e2: return 0x1e3;\n    case 0x1e4: return 0x1e5;\n    case 0x1e6: return 0x1e7;\n    case 0x1e8: return 0x1e9;\n    case 0x1ea: return 0x1eb;\n    case 0x1ec: return 0x1ed;\n    case 0x1ee: return 0x1ef;\n    case 0x1f1: return 0x1f3;\n    case 0x1f2: return 0x1f3;\n    case 0x1f4: return 0x1f5;\n    case 0x1f6: return 0x195;\n    case 0x1f7: return 0x1bf;\n    case 0x1f8: return 0x1f9;\n    case 0x1fa: return 0x1fb;\n    case 0x1fc: return 0x1fd;\n    case 0x1fe: return 0x1ff;\n    case 0x200: return 0x201;\n    case 0x202: return 0x203;\n    case 0x204: return 0x205;\n    case 0x206: return 0x207;\n    case 0x208: return 0x209;\n    case 0x20a: return 0x20b;\n    case 0x20c: return 0x20d;\n    case 0x20e: return 0x20f;\n    case 0x210: return 0x211;\n    case 0x212: return 0x213;\n    case 0x214: return 0x215;\n    case 0x216: return 0x217;\n    case 0x218: return 0x219;\n    case 0x21a: return 0x21b;\n    case 0x21c: return 0x21d;\n    case 0x21e: return 0x21f;\n    case 0x220: return 0x19e;\n    case 0x222: return 0x223;\n    case 0x224: return 0x225;\n    case 0x226: return 0x227;\n    case 0x228: return 0x229;\n    case 0x22a: return 0x22b;\n    case 0x22c: return 0x22d;\n    case 0x22e: return 0x22f;\n    case 0x230: return 0x231;\n    case 0x232: return 0x233;\n    case 0x23a: return 0x2c65;\n    case 0x23b: return 0x23c;\n    case 0x23d: return 0x19a;\n    case 0x23e: return 0x2c66;\n    case 0x241: return 0x242;\n    case 0x243: return 0x180;\n    case 0x244: return 0x289;\n    case 0x245: return 0x28c;\n    case 0x246: return 0x247;\n    case 0x248: return 0x249;\n    case 0x24a: return 0x24b;\n    case 0x24c: return 0x24d;\n    case 0x24e: return 0x24f;\n    case 0x345: return 0x3b9;\n    case 0x370: return 0x371;\n    case 0x372: return 0x373;\n    case 0x376: return 0x377;\n    case 0x386: return 0x3ac;\n    case 0x388: return 0x3ad;\n    case 0x389: return 0x3ae;\n    case 0x38a: return 0x3af;\n    case 0x38c: return 0x3cc;\n    case 0x38e: return 0x3cd;\n    case 0x38f: return 0x3ce;\n    case 0x391: return 0x3b1;\n    case 0x392: return 0x3b2;\n    case 0x393: return 0x3b3;\n    case 0x394: return 0x3b4;\n    case 0x395: return 0x3b5;\n    case 0x396: return 0x3b6;\n    case 0x397: return 0x3b7;\n    case 0x398: return 0x3b8;\n    case 0x399: return 0x3b9;\n    case 0x39a: return 0x3ba;\n    case 0x39b: return 0x3bb;\n    case 0x39c: return 0x3bc;\n    case 0x39d: return 0x3bd;\n    case 0x39e: return 0x3be;\n    case 0x39f: return 0x3bf;\n    case 0x3a0: return 0x3c0;\n    case 0x3a1: return 0x3c1;\n    case 0x3a3: return 0x3c3;\n    case 0x3a4: return 0x3c4;\n    case 0x3a5: return 0x3c5;\n    case 0x3a6: return 0x3c6;\n    case 0x3a7: return 0x3c7;\n    case 0x3a8: return 0x3c8;\n    case 0x3a9: return 0x3c9;\n    case 0x3aa: return 0x3ca;\n    case 0x3ab: return 0x3cb;\n    case 0x3c2: return 0x3c3;\n    case 0x3cf: return 0x3d7;\n    case 0x3d0: return 0x3b2;\n    case 0x3d1: return 0x3b8;\n    case 0x3d5: return 0x3c6;\n    case 0x3d6: return 0x3c0;\n    case 0x3d8: return 0x3d9;\n    case 0x3da: return 0x3db;\n    case 0x3dc: return 0x3dd;\n    case 0x3de: return 0x3df;\n    case 0x3e0: return 0x3e1;\n    case 0x3e2: return 0x3e3;\n    case 0x3e4: return 0x3e5;\n    case 0x3e6: return 0x3e7;\n    case 0x3e8: return 0x3e9;\n    case 0x3ea: return 0x3eb;\n    case 0x3ec: return 0x3ed;\n    case 0x3ee: return 0x3ef;\n    case 0x3f0: return 0x3ba;\n    case 0x3f1: return 0x3c1;\n    case 0x3f4: return 0x3b8;\n    case 0x3f5: return 0x3b5;\n    case 0x3f7: return 0x3f8;\n    case 0x3f9: return 0x3f2;\n    case 0x3fa: return 0x3fb;\n    case 0x3fd: return 0x37b;\n    case 0x3fe: return 0x37c;\n    case 0x3ff: return 0x37d;\n    case 0x400: return 0x450;\n    case 0x401: return 0x451;\n    case 0x402: return 0x452;\n    case 0x403: return 0x453;\n    case 0x404: return 0x454;\n    case 0x405: return 0x455;\n    case 0x406: return 0x456;\n    case 0x407: return 0x457;\n    case 0x408: return 0x458;\n    case 0x409: return 0x459;\n    case 0x40a: return 0x45a;\n    case 0x40b: return 0x45b;\n    case 0x40c: return 0x45c;\n    case 0x40d: return 0x45d;\n    case 0x40e: return 0x45e;\n    case 0x40f: return 0x45f;\n    case 0x410: return 0x430;\n    case 0x411: return 0x431;\n    case 0x412: return 0x432;\n    case 0x413: return 0x433;\n    case 0x414: return 0x434;\n    case 0x415: return 0x435;\n    case 0x416: return 0x436;\n    case 0x417: return 0x437;\n    case 0x418: return 0x438;\n    case 0x419: return 0x439;\n    case 0x41a: return 0x43a;\n    case 0x41b: return 0x43b;\n    case 0x41c: return 0x43c;\n    case 0x41d: return 0x43d;\n    case 0x41e: return 0x43e;\n    case 0x41f: return 0x43f;\n    case 0x420: return 0x440;\n    case 0x421: return 0x441;\n    case 0x422: return 0x442;\n    case 0x423: return 0x443;\n    case 0x424: return 0x444;\n    case 0x425: return 0x445;\n    case 0x426: return 0x446;\n    case 0x427: return 0x447;\n    case 0x428: return 0x448;\n    case 0x429: return 0x449;\n    case 0x42a: return 0x44a;\n    case 0x42b: return 0x44b;\n    case 0x42c: return 0x44c;\n    case 0x42d: return 0x44d;\n    case 0x42e: return 0x44e;\n    case 0x42f: return 0x44f;\n    case 0x460: return 0x461;\n    case 0x462: return 0x463;\n    case 0x464: return 0x465;\n    case 0x466: return 0x467;\n    case 0x468: return 0x469;\n    case 0x46a: return 0x46b;\n    case 0x46c: return 0x46d;\n    case 0x46e: return 0x46f;\n    case 0x470: return 0x471;\n    case 0x472: return 0x473;\n    case 0x474: return 0x475;\n    case 0x476: return 0x477;\n    case 0x478: return 0x479;\n    case 0x47a: return 0x47b;\n    case 0x47c: return 0x47d;\n    case 0x47e: return 0x47f;\n    case 0x480: return 0x481;\n    case 0x48a: return 0x48b;\n    case 0x48c: return 0x48d;\n    case 0x48e: return 0x48f;\n    case 0x490: return 0x491;\n    case 0x492: return 0x493;\n    case 0x494: return 0x495;\n    case 0x496: return 0x497;\n    case 0x498: return 0x499;\n    case 0x49a: return 0x49b;\n    case 0x49c: return 0x49d;\n    case 0x49e: return 0x49f;\n    case 0x4a0: return 0x4a1;\n    case 0x4a2: return 0x4a3;\n    case 0x4a4: return 0x4a5;\n    case 0x4a6: return 0x4a7;\n    case 0x4a8: return 0x4a9;\n    case 0x4aa: return 0x4ab;\n    case 0x4ac: return 0x4ad;\n    case 0x4ae: return 0x4af;\n    case 0x4b0: return 0x4b1;\n    case 0x4b2: return 0x4b3;\n    case 0x4b4: return 0x4b5;\n    case 0x4b6: return 0x4b7;\n    case 0x4b8: return 0x4b9;\n    case 0x4ba: return 0x4bb;\n    case 0x4bc: return 0x4bd;\n    case 0x4be: return 0x4bf;\n    case 0x4c0: return 0x4cf;\n    case 0x4c1: return 0x4c2;\n    case 0x4c3: return 0x4c4;\n    case 0x4c5: return 0x4c6;\n    case 0x4c7: return 0x4c8;\n    case 0x4c9: return 0x4ca;\n    case 0x4cb: return 0x4cc;\n    case 0x4cd: return 0x4ce;\n    case 0x4d0: return 0x4d1;\n    case 0x4d2: return 0x4d3;\n    case 0x4d4: return 0x4d5;\n    case 0x4d6: return 0x4d7;\n    case 0x4d8: return 0x4d9;\n    case 0x4da: return 0x4db;\n    case 0x4dc: return 0x4dd;\n    case 0x4de: return 0x4df;\n    case 0x4e0: return 0x4e1;\n    case 0x4e2: return 0x4e3;\n    case 0x4e4: return 0x4e5;\n    case 0x4e6: return 0x4e7;\n    case 0x4e8: return 0x4e9;\n    case 0x4ea: return 0x4eb;\n    case 0x4ec: return 0x4ed;\n    case 0x4ee: return 0x4ef;\n    case 0x4f0: return 0x4f1;\n    case 0x4f2: return 0x4f3;\n    case 0x4f4: return 0x4f5;\n    case 0x4f6: return 0x4f7;\n    case 0x4f8: return 0x4f9;\n    case 0x4fa: return 0x4fb;\n    case 0x4fc: return 0x4fd;\n    case 0x4fe: return 0x4ff;\n    case 0x500: return 0x501;\n    case 0x502: return 0x503;\n    case 0x504: return 0x505;\n    case 0x506: return 0x507;\n    case 0x508: return 0x509;\n    case 0x50a: return 0x50b;\n    case 0x50c: return 0x50d;\n    case 0x50e: return 0x50f;\n    case 0x510: return 0x511;\n    case 0x512: return 0x513;\n    case 0x514: return 0x515;\n    case 0x516: return 0x517;\n    case 0x518: return 0x519;\n    case 0x51a: return 0x51b;\n    case 0x51c: return 0x51d;\n    case 0x51e: return 0x51f;\n    case 0x520: return 0x521;\n    case 0x522: return 0x523;\n    case 0x524: return 0x525;\n    case 0x531: return 0x561;\n    case 0x532: return 0x562;\n    case 0x533: return 0x563;\n    case 0x534: return 0x564;\n    case 0x535: return 0x565;\n    case 0x536: return 0x566;\n    case 0x537: return 0x567;\n    case 0x538: return 0x568;\n    case 0x539: return 0x569;\n    case 0x53a: return 0x56a;\n    case 0x53b: return 0x56b;\n    case 0x53c: return 0x56c;\n    case 0x53d: return 0x56d;\n    case 0x53e: return 0x56e;\n    case 0x53f: return 0x56f;\n    case 0x540: return 0x570;\n    case 0x541: return 0x571;\n    case 0x542: return 0x572;\n    case 0x543: return 0x573;\n    case 0x544: return 0x574;\n    case 0x545: return 0x575;\n    case 0x546: return 0x576;\n    case 0x547: return 0x577;\n    case 0x548: return 0x578;\n    case 0x549: return 0x579;\n    case 0x54a: return 0x57a;\n    case 0x54b: return 0x57b;\n    case 0x54c: return 0x57c;\n    case 0x54d: return 0x57d;\n    case 0x54e: return 0x57e;\n    case 0x54f: return 0x57f;\n    case 0x550: return 0x580;\n    case 0x551: return 0x581;\n    case 0x552: return 0x582;\n    case 0x553: return 0x583;\n    case 0x554: return 0x584;\n    case 0x555: return 0x585;\n    case 0x556: return 0x586;\n    case 0x10a0: return 0x2d00;\n    case 0x10a1: return 0x2d01;\n    case 0x10a2: return 0x2d02;\n    case 0x10a3: return 0x2d03;\n    case 0x10a4: return 0x2d04;\n    case 0x10a5: return 0x2d05;\n    case 0x10a6: return 0x2d06;\n    case 0x10a7: return 0x2d07;\n    case 0x10a8: return 0x2d08;\n    case 0x10a9: return 0x2d09;\n    case 0x10aa: return 0x2d0a;\n    case 0x10ab: return 0x2d0b;\n    case 0x10ac: return 0x2d0c;\n    case 0x10ad: return 0x2d0d;\n    case 0x10ae: return 0x2d0e;\n    case 0x10af: return 0x2d0f;\n    case 0x10b0: return 0x2d10;\n    case 0x10b1: return 0x2d11;\n    case 0x10b2: return 0x2d12;\n    case 0x10b3: return 0x2d13;\n    case 0x10b4: return 0x2d14;\n    case 0x10b5: return 0x2d15;\n    case 0x10b6: return 0x2d16;\n    case 0x10b7: return 0x2d17;\n    case 0x10b8: return 0x2d18;\n    case 0x10b9: return 0x2d19;\n    case 0x10ba: return 0x2d1a;\n    case 0x10bb: return 0x2d1b;\n    case 0x10bc: return 0x2d1c;\n    case 0x10bd: return 0x2d1d;\n    case 0x10be: return 0x2d1e;\n    case 0x10bf: return 0x2d1f;\n    case 0x10c0: return 0x2d20;\n    case 0x10c1: return 0x2d21;\n    case 0x10c2: return 0x2d22;\n    case 0x10c3: return 0x2d23;\n    case 0x10c4: return 0x2d24;\n    case 0x10c5: return 0x2d25;\n    case 0x1e00: return 0x1e01;\n    case 0x1e02: return 0x1e03;\n    case 0x1e04: return 0x1e05;\n    case 0x1e06: return 0x1e07;\n    case 0x1e08: return 0x1e09;\n    case 0x1e0a: return 0x1e0b;\n    case 0x1e0c: return 0x1e0d;\n    case 0x1e0e: return 0x1e0f;\n    case 0x1e10: return 0x1e11;\n    case 0x1e12: return 0x1e13;\n    case 0x1e14: return 0x1e15;\n    case 0x1e16: return 0x1e17;\n    case 0x1e18: return 0x1e19;\n    case 0x1e1a: return 0x1e1b;\n    case 0x1e1c: return 0x1e1d;\n    case 0x1e1e: return 0x1e1f;\n    case 0x1e20: return 0x1e21;\n    case 0x1e22: return 0x1e23;\n    case 0x1e24: return 0x1e25;\n    case 0x1e26: return 0x1e27;\n    case 0x1e28: return 0x1e29;\n    case 0x1e2a: return 0x1e2b;\n    case 0x1e2c: return 0x1e2d;\n    case 0x1e2e: return 0x1e2f;\n    case 0x1e30: return 0x1e31;\n    case 0x1e32: return 0x1e33;\n    case 0x1e34: return 0x1e35;\n    case 0x1e36: return 0x1e37;\n    case 0x1e38: return 0x1e39;\n    case 0x1e3a: return 0x1e3b;\n    case 0x1e3c: return 0x1e3d;\n    case 0x1e3e: return 0x1e3f;\n    case 0x1e40: return 0x1e41;\n    case 0x1e42: return 0x1e43;\n    case 0x1e44: return 0x1e45;\n    case 0x1e46: return 0x1e47;\n    case 0x1e48: return 0x1e49;\n    case 0x1e4a: return 0x1e4b;\n    case 0x1e4c: return 0x1e4d;\n    case 0x1e4e: return 0x1e4f;\n    case 0x1e50: return 0x1e51;\n    case 0x1e52: return 0x1e53;\n    case 0x1e54: return 0x1e55;\n    case 0x1e56: return 0x1e57;\n    case 0x1e58: return 0x1e59;\n    case 0x1e5a: return 0x1e5b;\n    case 0x1e5c: return 0x1e5d;\n    case 0x1e5e: return 0x1e5f;\n    case 0x1e60: return 0x1e61;\n    case 0x1e62: return 0x1e63;\n    case 0x1e64: return 0x1e65;\n    case 0x1e66: return 0x1e67;\n    case 0x1e68: return 0x1e69;\n    case 0x1e6a: return 0x1e6b;\n    case 0x1e6c: return 0x1e6d;\n    case 0x1e6e: return 0x1e6f;\n    case 0x1e70: return 0x1e71;\n    case 0x1e72: return 0x1e73;\n    case 0x1e74: return 0x1e75;\n    case 0x1e76: return 0x1e77;\n    case 0x1e78: return 0x1e79;\n    case 0x1e7a: return 0x1e7b;\n    case 0x1e7c: return 0x1e7d;\n    case 0x1e7e: return 0x1e7f;\n    case 0x1e80: return 0x1e81;\n    case 0x1e82: return 0x1e83;\n    case 0x1e84: return 0x1e85;\n    case 0x1e86: return 0x1e87;\n    case 0x1e88: return 0x1e89;\n    case 0x1e8a: return 0x1e8b;\n    case 0x1e8c: return 0x1e8d;\n    case 0x1e8e: return 0x1e8f;\n    case 0x1e90: return 0x1e91;\n    case 0x1e92: return 0x1e93;\n    case 0x1e94: return 0x1e95;\n    case 0x1e9b: return 0x1e61;\n    case 0x1e9e: return 0xdf;\n    case 0x1ea0: return 0x1ea1;\n    case 0x1ea2: return 0x1ea3;\n    case 0x1ea4: return 0x1ea5;\n    case 0x1ea6: return 0x1ea7;\n    case 0x1ea8: return 0x1ea9;\n    case 0x1eaa: return 0x1eab;\n    case 0x1eac: return 0x1ead;\n    case 0x1eae: return 0x1eaf;\n    case 0x1eb0: return 0x1eb1;\n    case 0x1eb2: return 0x1eb3;\n    case 0x1eb4: return 0x1eb5;\n    case 0x1eb6: return 0x1eb7;\n    case 0x1eb8: return 0x1eb9;\n    case 0x1eba: return 0x1ebb;\n    case 0x1ebc: return 0x1ebd;\n    case 0x1ebe: return 0x1ebf;\n    case 0x1ec0: return 0x1ec1;\n    case 0x1ec2: return 0x1ec3;\n    case 0x1ec4: return 0x1ec5;\n    case 0x1ec6: return 0x1ec7;\n    case 0x1ec8: return 0x1ec9;\n    case 0x1eca: return 0x1ecb;\n    case 0x1ecc: return 0x1ecd;\n    case 0x1ece: return 0x1ecf;\n    case 0x1ed0: return 0x1ed1;\n    case 0x1ed2: return 0x1ed3;\n    case 0x1ed4: return 0x1ed5;\n    case 0x1ed6: return 0x1ed7;\n    case 0x1ed8: return 0x1ed9;\n    case 0x1eda: return 0x1edb;\n    case 0x1edc: return 0x1edd;\n    case 0x1ede: return 0x1edf;\n    case 0x1ee0: return 0x1ee1;\n    case 0x1ee2: return 0x1ee3;\n    case 0x1ee4: return 0x1ee5;\n    case 0x1ee6: return 0x1ee7;\n    case 0x1ee8: return 0x1ee9;\n    case 0x1eea: return 0x1eeb;\n    case 0x1eec: return 0x1eed;\n    case 0x1eee: return 0x1eef;\n    case 0x1ef0: return 0x1ef1;\n    case 0x1ef2: return 0x1ef3;\n    case 0x1ef4: return 0x1ef5;\n    case 0x1ef6: return 0x1ef7;\n    case 0x1ef8: return 0x1ef9;\n    case 0x1efa: return 0x1efb;\n    case 0x1efc: return 0x1efd;\n    case 0x1efe: return 0x1eff;\n    case 0x1f08: return 0x1f00;\n    case 0x1f09: return 0x1f01;\n    case 0x1f0a: return 0x1f02;\n    case 0x1f0b: return 0x1f03;\n    case 0x1f0c: return 0x1f04;\n    case 0x1f0d: return 0x1f05;\n    case 0x1f0e: return 0x1f06;\n    case 0x1f0f: return 0x1f07;\n    case 0x1f18: return 0x1f10;\n    case 0x1f19: return 0x1f11;\n    case 0x1f1a: return 0x1f12;\n    case 0x1f1b: return 0x1f13;\n    case 0x1f1c: return 0x1f14;\n    case 0x1f1d: return 0x1f15;\n    case 0x1f28: return 0x1f20;\n    case 0x1f29: return 0x1f21;\n    case 0x1f2a: return 0x1f22;\n    case 0x1f2b: return 0x1f23;\n    case 0x1f2c: return 0x1f24;\n    case 0x1f2d: return 0x1f25;\n    case 0x1f2e: return 0x1f26;\n    case 0x1f2f: return 0x1f27;\n    case 0x1f38: return 0x1f30;\n    case 0x1f39: return 0x1f31;\n    case 0x1f3a: return 0x1f32;\n    case 0x1f3b: return 0x1f33;\n    case 0x1f3c: return 0x1f34;\n    case 0x1f3d: return 0x1f35;\n    case 0x1f3e: return 0x1f36;\n    case 0x1f3f: return 0x1f37;\n    case 0x1f48: return 0x1f40;\n    case 0x1f49: return 0x1f41;\n    case 0x1f4a: return 0x1f42;\n    case 0x1f4b: return 0x1f43;\n    case 0x1f4c: return 0x1f44;\n    case 0x1f4d: return 0x1f45;\n    case 0x1f59: return 0x1f51;\n    case 0x1f5b: return 0x1f53;\n    case 0x1f5d: return 0x1f55;\n    case 0x1f5f: return 0x1f57;\n    case 0x1f68: return 0x1f60;\n    case 0x1f69: return 0x1f61;\n    case 0x1f6a: return 0x1f62;\n    case 0x1f6b: return 0x1f63;\n    case 0x1f6c: return 0x1f64;\n    case 0x1f6d: return 0x1f65;\n    case 0x1f6e: return 0x1f66;\n    case 0x1f6f: return 0x1f67;\n    case 0x1f88: return 0x1f80;\n    case 0x1f89: return 0x1f81;\n    case 0x1f8a: return 0x1f82;\n    case 0x1f8b: return 0x1f83;\n    case 0x1f8c: return 0x1f84;\n    case 0x1f8d: return 0x1f85;\n    case 0x1f8e: return 0x1f86;\n    case 0x1f8f: return 0x1f87;\n    case 0x1f98: return 0x1f90;\n    case 0x1f99: return 0x1f91;\n    case 0x1f9a: return 0x1f92;\n    case 0x1f9b: return 0x1f93;\n    case 0x1f9c: return 0x1f94;\n    case 0x1f9d: return 0x1f95;\n    case 0x1f9e: return 0x1f96;\n    case 0x1f9f: return 0x1f97;\n    case 0x1fa8: return 0x1fa0;\n    case 0x1fa9: return 0x1fa1;\n    case 0x1faa: return 0x1fa2;\n    case 0x1fab: return 0x1fa3;\n    case 0x1fac: return 0x1fa4;\n    case 0x1fad: return 0x1fa5;\n    case 0x1fae: return 0x1fa6;\n    case 0x1faf: return 0x1fa7;\n    case 0x1fb8: return 0x1fb0;\n    case 0x1fb9: return 0x1fb1;\n    case 0x1fba: return 0x1f70;\n    case 0x1fbb: return 0x1f71;\n    case 0x1fbc: return 0x1fb3;\n    case 0x1fbe: return 0x3b9;\n    case 0x1fc8: return 0x1f72;\n    case 0x1fc9: return 0x1f73;\n    case 0x1fca: return 0x1f74;\n    case 0x1fcb: return 0x1f75;\n    case 0x1fcc: return 0x1fc3;\n    case 0x1fd8: return 0x1fd0;\n    case 0x1fd9: return 0x1fd1;\n    case 0x1fda: return 0x1f76;\n    case 0x1fdb: return 0x1f77;\n    case 0x1fe8: return 0x1fe0;\n    case 0x1fe9: return 0x1fe1;\n    case 0x1fea: return 0x1f7a;\n    case 0x1feb: return 0x1f7b;\n    case 0x1fec: return 0x1fe5;\n    case 0x1ff8: return 0x1f78;\n    case 0x1ff9: return 0x1f79;\n    case 0x1ffa: return 0x1f7c;\n    case 0x1ffb: return 0x1f7d;\n    case 0x1ffc: return 0x1ff3;\n    case 0x2126: return 0x3c9;\n    case 0x212a: return 0x6b;\n    case 0x212b: return 0xe5;\n    case 0x2132: return 0x214e;\n    case 0x2160: return 0x2170;\n    case 0x2161: return 0x2171;\n    case 0x2162: return 0x2172;\n    case 0x2163: return 0x2173;\n    case 0x2164: return 0x2174;\n    case 0x2165: return 0x2175;\n    case 0x2166: return 0x2176;\n    case 0x2167: return 0x2177;\n    case 0x2168: return 0x2178;\n    case 0x2169: return 0x2179;\n    case 0x216a: return 0x217a;\n    case 0x216b: return 0x217b;\n    case 0x216c: return 0x217c;\n    case 0x216d: return 0x217d;\n    case 0x216e: return 0x217e;\n    case 0x216f: return 0x217f;\n    case 0x2183: return 0x2184;\n    case 0x24b6: return 0x24d0;\n    case 0x24b7: return 0x24d1;\n    case 0x24b8: return 0x24d2;\n    case 0x24b9: return 0x24d3;\n    case 0x24ba: return 0x24d4;\n    case 0x24bb: return 0x24d5;\n    case 0x24bc: return 0x24d6;\n    case 0x24bd: return 0x24d7;\n    case 0x24be: return 0x24d8;\n    case 0x24bf: return 0x24d9;\n    case 0x24c0: return 0x24da;\n    case 0x24c1: return 0x24db;\n    case 0x24c2: return 0x24dc;\n    case 0x24c3: return 0x24dd;\n    case 0x24c4: return 0x24de;\n    case 0x24c5: return 0x24df;\n    case 0x24c6: return 0x24e0;\n    case 0x24c7: return 0x24e1;\n    case 0x24c8: return 0x24e2;\n    case 0x24c9: return 0x24e3;\n    case 0x24ca: return 0x24e4;\n    case 0x24cb: return 0x24e5;\n    case 0x24cc: return 0x24e6;\n    case 0x24cd: return 0x24e7;\n    case 0x24ce: return 0x24e8;\n    case 0x24cf: return 0x24e9;\n    case 0x2c00: return 0x2c30;\n    case 0x2c01: return 0x2c31;\n    case 0x2c02: return 0x2c32;\n    case 0x2c03: return 0x2c33;\n    case 0x2c04: return 0x2c34;\n    case 0x2c05: return 0x2c35;\n    case 0x2c06: return 0x2c36;\n    case 0x2c07: return 0x2c37;\n    case 0x2c08: return 0x2c38;\n    case 0x2c09: return 0x2c39;\n    case 0x2c0a: return 0x2c3a;\n    case 0x2c0b: return 0x2c3b;\n    case 0x2c0c: return 0x2c3c;\n    case 0x2c0d: return 0x2c3d;\n    case 0x2c0e: return 0x2c3e;\n    case 0x2c0f: return 0x2c3f;\n    case 0x2c10: return 0x2c40;\n    case 0x2c11: return 0x2c41;\n    case 0x2c12: return 0x2c42;\n    case 0x2c13: return 0x2c43;\n    case 0x2c14: return 0x2c44;\n    case 0x2c15: return 0x2c45;\n    case 0x2c16: return 0x2c46;\n    case 0x2c17: return 0x2c47;\n    case 0x2c18: return 0x2c48;\n    case 0x2c19: return 0x2c49;\n    case 0x2c1a: return 0x2c4a;\n    case 0x2c1b: return 0x2c4b;\n    case 0x2c1c: return 0x2c4c;\n    case 0x2c1d: return 0x2c4d;\n    case 0x2c1e: return 0x2c4e;\n    case 0x2c1f: return 0x2c4f;\n    case 0x2c20: return 0x2c50;\n    case 0x2c21: return 0x2c51;\n    case 0x2c22: return 0x2c52;\n    case 0x2c23: return 0x2c53;\n    case 0x2c24: return 0x2c54;\n    case 0x2c25: return 0x2c55;\n    case 0x2c26: return 0x2c56;\n    case 0x2c27: return 0x2c57;\n    case 0x2c28: return 0x2c58;\n    case 0x2c29: return 0x2c59;\n    case 0x2c2a: return 0x2c5a;\n    case 0x2c2b: return 0x2c5b;\n    case 0x2c2c: return 0x2c5c;\n    case 0x2c2d: return 0x2c5d;\n    case 0x2c2e: return 0x2c5e;\n    case 0x2c60: return 0x2c61;\n    case 0x2c62: return 0x26b;\n    case 0x2c63: return 0x1d7d;\n    case 0x2c64: return 0x27d;\n    case 0x2c67: return 0x2c68;\n    case 0x2c69: return 0x2c6a;\n    case 0x2c6b: return 0x2c6c;\n    case 0x2c6d: return 0x251;\n    case 0x2c6e: return 0x271;\n    case 0x2c6f: return 0x250;\n    case 0x2c70: return 0x252;\n    case 0x2c72: return 0x2c73;\n    case 0x2c75: return 0x2c76;\n    case 0x2c7e: return 0x23f;\n    case 0x2c7f: return 0x240;\n    case 0x2c80: return 0x2c81;\n    case 0x2c82: return 0x2c83;\n    case 0x2c84: return 0x2c85;\n    case 0x2c86: return 0x2c87;\n    case 0x2c88: return 0x2c89;\n    case 0x2c8a: return 0x2c8b;\n    case 0x2c8c: return 0x2c8d;\n    case 0x2c8e: return 0x2c8f;\n    case 0x2c90: return 0x2c91;\n    case 0x2c92: return 0x2c93;\n    case 0x2c94: return 0x2c95;\n    case 0x2c96: return 0x2c97;\n    case 0x2c98: return 0x2c99;\n    case 0x2c9a: return 0x2c9b;\n    case 0x2c9c: return 0x2c9d;\n    case 0x2c9e: return 0x2c9f;\n    case 0x2ca0: return 0x2ca1;\n    case 0x2ca2: return 0x2ca3;\n    case 0x2ca4: return 0x2ca5;\n    case 0x2ca6: return 0x2ca7;\n    case 0x2ca8: return 0x2ca9;\n    case 0x2caa: return 0x2cab;\n    case 0x2cac: return 0x2cad;\n    case 0x2cae: return 0x2caf;\n    case 0x2cb0: return 0x2cb1;\n    case 0x2cb2: return 0x2cb3;\n    case 0x2cb4: return 0x2cb5;\n    case 0x2cb6: return 0x2cb7;\n    case 0x2cb8: return 0x2cb9;\n    case 0x2cba: return 0x2cbb;\n    case 0x2cbc: return 0x2cbd;\n    case 0x2cbe: return 0x2cbf;\n    case 0x2cc0: return 0x2cc1;\n    case 0x2cc2: return 0x2cc3;\n    case 0x2cc4: return 0x2cc5;\n    case 0x2cc6: return 0x2cc7;\n    case 0x2cc8: return 0x2cc9;\n    case 0x2cca: return 0x2ccb;\n    case 0x2ccc: return 0x2ccd;\n    case 0x2cce: return 0x2ccf;\n    case 0x2cd0: return 0x2cd1;\n    case 0x2cd2: return 0x2cd3;\n    case 0x2cd4: return 0x2cd5;\n    case 0x2cd6: return 0x2cd7;\n    case 0x2cd8: return 0x2cd9;\n    case 0x2cda: return 0x2cdb;\n    case 0x2cdc: return 0x2cdd;\n    case 0x2cde: return 0x2cdf;\n    case 0x2ce0: return 0x2ce1;\n    case 0x2ce2: return 0x2ce3;\n    case 0x2ceb: return 0x2cec;\n    case 0x2ced: return 0x2cee;\n    case 0xa640: return 0xa641;\n    case 0xa642: return 0xa643;\n    case 0xa644: return 0xa645;\n    case 0xa646: return 0xa647;\n    case 0xa648: return 0xa649;\n    case 0xa64a: return 0xa64b;\n    case 0xa64c: return 0xa64d;\n    case 0xa64e: return 0xa64f;\n    case 0xa650: return 0xa651;\n    case 0xa652: return 0xa653;\n    case 0xa654: return 0xa655;\n    case 0xa656: return 0xa657;\n    case 0xa658: return 0xa659;\n    case 0xa65a: return 0xa65b;\n    case 0xa65c: return 0xa65d;\n    case 0xa65e: return 0xa65f;\n    case 0xa662: return 0xa663;\n    case 0xa664: return 0xa665;\n    case 0xa666: return 0xa667;\n    case 0xa668: return 0xa669;\n    case 0xa66a: return 0xa66b;\n    case 0xa66c: return 0xa66d;\n    case 0xa680: return 0xa681;\n    case 0xa682: return 0xa683;\n    case 0xa684: return 0xa685;\n    case 0xa686: return 0xa687;\n    case 0xa688: return 0xa689;\n    case 0xa68a: return 0xa68b;\n    case 0xa68c: return 0xa68d;\n    case 0xa68e: return 0xa68f;\n    case 0xa690: return 0xa691;\n    case 0xa692: return 0xa693;\n    case 0xa694: return 0xa695;\n    case 0xa696: return 0xa697;\n    case 0xa722: return 0xa723;\n    case 0xa724: return 0xa725;\n    case 0xa726: return 0xa727;\n    case 0xa728: return 0xa729;\n    case 0xa72a: return 0xa72b;\n    case 0xa72c: return 0xa72d;\n    case 0xa72e: return 0xa72f;\n    case 0xa732: return 0xa733;\n    case 0xa734: return 0xa735;\n    case 0xa736: return 0xa737;\n    case 0xa738: return 0xa739;\n    case 0xa73a: return 0xa73b;\n    case 0xa73c: return 0xa73d;\n    case 0xa73e: return 0xa73f;\n    case 0xa740: return 0xa741;\n    case 0xa742: return 0xa743;\n    case 0xa744: return 0xa745;\n    case 0xa746: return 0xa747;\n    case 0xa748: return 0xa749;\n    case 0xa74a: return 0xa74b;\n    case 0xa74c: return 0xa74d;\n    case 0xa74e: return 0xa74f;\n    case 0xa750: return 0xa751;\n    case 0xa752: return 0xa753;\n    case 0xa754: return 0xa755;\n    case 0xa756: return 0xa757;\n    case 0xa758: return 0xa759;\n    case 0xa75a: return 0xa75b;\n    case 0xa75c: return 0xa75d;\n    case 0xa75e: return 0xa75f;\n    case 0xa760: return 0xa761;\n    case 0xa762: return 0xa763;\n    case 0xa764: return 0xa765;\n    case 0xa766: return 0xa767;\n    case 0xa768: return 0xa769;\n    case 0xa76a: return 0xa76b;\n    case 0xa76c: return 0xa76d;\n    case 0xa76e: return 0xa76f;\n    case 0xa779: return 0xa77a;\n    case 0xa77b: return 0xa77c;\n    case 0xa77d: return 0x1d79;\n    case 0xa77e: return 0xa77f;\n    case 0xa780: return 0xa781;\n    case 0xa782: return 0xa783;\n    case 0xa784: return 0xa785;\n    case 0xa786: return 0xa787;\n    case 0xa78b: return 0xa78c;\n    case 0xff21: return 0xff41;\n    case 0xff22: return 0xff42;\n    case 0xff23: return 0xff43;\n    case 0xff24: return 0xff44;\n    case 0xff25: return 0xff45;\n    case 0xff26: return 0xff46;\n    case 0xff27: return 0xff47;\n    case 0xff28: return 0xff48;\n    case 0xff29: return 0xff49;\n    case 0xff2a: return 0xff4a;\n    case 0xff2b: return 0xff4b;\n    case 0xff2c: return 0xff4c;\n    case 0xff2d: return 0xff4d;\n    case 0xff2e: return 0xff4e;\n    case 0xff2f: return 0xff4f;\n    case 0xff30: return 0xff50;\n    case 0xff31: return 0xff51;\n    case 0xff32: return 0xff52;\n    case 0xff33: return 0xff53;\n    case 0xff34: return 0xff54;\n    case 0xff35: return 0xff55;\n    case 0xff36: return 0xff56;\n    case 0xff37: return 0xff57;\n    case 0xff38: return 0xff58;\n    case 0xff39: return 0xff59;\n    case 0xff3a: return 0xff5a;\n    case 0x10400: return 0x10428;\n    case 0x10401: return 0x10429;\n    case 0x10402: return 0x1042a;\n    case 0x10403: return 0x1042b;\n    case 0x10404: return 0x1042c;\n    case 0x10405: return 0x1042d;\n    case 0x10406: return 0x1042e;\n    case 0x10407: return 0x1042f;\n    case 0x10408: return 0x10430;\n    case 0x10409: return 0x10431;\n    case 0x1040a: return 0x10432;\n    case 0x1040b: return 0x10433;\n    case 0x1040c: return 0x10434;\n    case 0x1040d: return 0x10435;\n    case 0x1040e: return 0x10436;\n    case 0x1040f: return 0x10437;\n    case 0x10410: return 0x10438;\n    case 0x10411: return 0x10439;\n    case 0x10412: return 0x1043a;\n    case 0x10413: return 0x1043b;\n    case 0x10414: return 0x1043c;\n    case 0x10415: return 0x1043d;\n    case 0x10416: return 0x1043e;\n    case 0x10417: return 0x1043f;\n    case 0x10418: return 0x10440;\n    case 0x10419: return 0x10441;\n    case 0x1041a: return 0x10442;\n    case 0x1041b: return 0x10443;\n    case 0x1041c: return 0x10444;\n    case 0x1041d: return 0x10445;\n    case 0x1041e: return 0x10446;\n    case 0x1041f: return 0x10447;\n    case 0x10420: return 0x10448;\n    case 0x10421: return 0x10449;\n    case 0x10422: return 0x1044a;\n    case 0x10423: return 0x1044b;\n    case 0x10424: return 0x1044c;\n    case 0x10425: return 0x1044d;\n    case 0x10426: return 0x1044e;\n    case 0x10427: return 0x1044f;\n    default: return in;\n  }\n}\n"
        },
        {
          "name": "inc_diacritic_folding.hh",
          "type": "blob",
          "size": 127.4306640625,
          "content": "// This file was generated automatically. Do not edit directly.\n\nenum { foldDiacriticMaxIn = 3 };\n\nwchar foldDiacritic( wchar const * in, size_t size, size_t & consumed )\n{\n  if ( size > 0 )\n  {\n    switch( in[ 0 ] )\n    {\n      case 0x41:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x41;\n            case 0x301:\n              consumed = 2; return 0x41;\n            case 0x302:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x41;\n                  case 0x301:\n                    consumed = 3; return 0x41;\n                  case 0x303:\n                    consumed = 3; return 0x41;\n                  case 0x309:\n                    consumed = 3; return 0x41;\n                }\n              }\n              consumed = 2; return 0x41;\n            case 0x303:\n              consumed = 2; return 0x41;\n            case 0x304:\n              consumed = 2; return 0x41;\n            case 0x306:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x41;\n                  case 0x301:\n                    consumed = 3; return 0x41;\n                  case 0x303:\n                    consumed = 3; return 0x41;\n                  case 0x309:\n                    consumed = 3; return 0x41;\n                }\n              }\n              consumed = 2; return 0x41;\n            case 0x307:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x304:\n                    consumed = 3; return 0x41;\n                }\n              }\n              consumed = 2; return 0x41;\n            case 0x308:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x304:\n                    consumed = 3; return 0x41;\n                }\n              }\n              consumed = 2; return 0x41;\n            case 0x309:\n              consumed = 2; return 0x41;\n            case 0x30a:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x301:\n                    consumed = 3; return 0x41;\n                }\n              }\n              consumed = 2; return 0x41;\n            case 0x30c:\n              consumed = 2; return 0x41;\n            case 0x30f:\n              consumed = 2; return 0x41;\n            case 0x311:\n              consumed = 2; return 0x41;\n            case 0x323:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x302:\n                    consumed = 3; return 0x41;\n                  case 0x306:\n                    consumed = 3; return 0x41;\n                }\n              }\n              consumed = 2; return 0x41;\n            case 0x325:\n              consumed = 2; return 0x41;\n            case 0x328:\n              consumed = 2; return 0x41;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x42:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x307:\n              consumed = 2; return 0x42;\n            case 0x323:\n              consumed = 2; return 0x42;\n            case 0x331:\n              consumed = 2; return 0x42;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x43:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x301:\n              consumed = 2; return 0x43;\n            case 0x302:\n              consumed = 2; return 0x43;\n            case 0x307:\n              consumed = 2; return 0x43;\n            case 0x30c:\n              consumed = 2; return 0x43;\n            case 0x327:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x301:\n                    consumed = 3; return 0x43;\n                }\n              }\n              consumed = 2; return 0x43;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x44:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x307:\n              consumed = 2; return 0x44;\n            case 0x30c:\n              consumed = 2; return 0x44;\n            case 0x323:\n              consumed = 2; return 0x44;\n            case 0x327:\n              consumed = 2; return 0x44;\n            case 0x32d:\n              consumed = 2; return 0x44;\n            case 0x331:\n              consumed = 2; return 0x44;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x45:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x45;\n            case 0x301:\n              consumed = 2; return 0x45;\n            case 0x302:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x45;\n                  case 0x301:\n                    consumed = 3; return 0x45;\n                  case 0x303:\n                    consumed = 3; return 0x45;\n                  case 0x309:\n                    consumed = 3; return 0x45;\n                }\n              }\n              consumed = 2; return 0x45;\n            case 0x303:\n              consumed = 2; return 0x45;\n            case 0x304:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x45;\n                  case 0x301:\n                    consumed = 3; return 0x45;\n                }\n              }\n              consumed = 2; return 0x45;\n            case 0x306:\n              consumed = 2; return 0x45;\n            case 0x307:\n              consumed = 2; return 0x45;\n            case 0x308:\n              consumed = 2; return 0x45;\n            case 0x309:\n              consumed = 2; return 0x45;\n            case 0x30c:\n              consumed = 2; return 0x45;\n            case 0x30f:\n              consumed = 2; return 0x45;\n            case 0x311:\n              consumed = 2; return 0x45;\n            case 0x323:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x302:\n                    consumed = 3; return 0x45;\n                }\n              }\n              consumed = 2; return 0x45;\n            case 0x327:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x306:\n                    consumed = 3; return 0x45;\n                }\n              }\n              consumed = 2; return 0x45;\n            case 0x328:\n              consumed = 2; return 0x45;\n            case 0x32d:\n              consumed = 2; return 0x45;\n            case 0x330:\n              consumed = 2; return 0x45;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x46:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x307:\n              consumed = 2; return 0x46;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x47:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x301:\n              consumed = 2; return 0x47;\n            case 0x302:\n              consumed = 2; return 0x47;\n            case 0x304:\n              consumed = 2; return 0x47;\n            case 0x306:\n              consumed = 2; return 0x47;\n            case 0x307:\n              consumed = 2; return 0x47;\n            case 0x30c:\n              consumed = 2; return 0x47;\n            case 0x327:\n              consumed = 2; return 0x47;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x48:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x302:\n              consumed = 2; return 0x48;\n            case 0x307:\n              consumed = 2; return 0x48;\n            case 0x308:\n              consumed = 2; return 0x48;\n            case 0x30c:\n              consumed = 2; return 0x48;\n            case 0x323:\n              consumed = 2; return 0x48;\n            case 0x327:\n              consumed = 2; return 0x48;\n            case 0x32e:\n              consumed = 2; return 0x48;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x49:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x49;\n            case 0x301:\n              consumed = 2; return 0x49;\n            case 0x302:\n              consumed = 2; return 0x49;\n            case 0x303:\n              consumed = 2; return 0x49;\n            case 0x304:\n              consumed = 2; return 0x49;\n            case 0x306:\n              consumed = 2; return 0x49;\n            case 0x307:\n              consumed = 2; return 0x49;\n            case 0x308:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x301:\n                    consumed = 3; return 0x49;\n                }\n              }\n              consumed = 2; return 0x49;\n            case 0x309:\n              consumed = 2; return 0x49;\n            case 0x30c:\n              consumed = 2; return 0x49;\n            case 0x30f:\n              consumed = 2; return 0x49;\n            case 0x311:\n              consumed = 2; return 0x49;\n            case 0x323:\n              consumed = 2; return 0x49;\n            case 0x328:\n              consumed = 2; return 0x49;\n            case 0x330:\n              consumed = 2; return 0x49;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x4a:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x302:\n              consumed = 2; return 0x4a;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x4b:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x301:\n              consumed = 2; return 0x4b;\n            case 0x30c:\n              consumed = 2; return 0x4b;\n            case 0x323:\n              consumed = 2; return 0x4b;\n            case 0x327:\n              consumed = 2; return 0x4b;\n            case 0x331:\n              consumed = 2; return 0x4b;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x4c:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x301:\n              consumed = 2; return 0x4c;\n            case 0x30c:\n              consumed = 2; return 0x4c;\n            case 0x323:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x304:\n                    consumed = 3; return 0x4c;\n                }\n              }\n              consumed = 2; return 0x4c;\n            case 0x327:\n              consumed = 2; return 0x4c;\n            case 0x32d:\n              consumed = 2; return 0x4c;\n            case 0x331:\n              consumed = 2; return 0x4c;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x4d:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x301:\n              consumed = 2; return 0x4d;\n            case 0x307:\n              consumed = 2; return 0x4d;\n            case 0x323:\n              consumed = 2; return 0x4d;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x4e:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x4e;\n            case 0x301:\n              consumed = 2; return 0x4e;\n            case 0x303:\n              consumed = 2; return 0x4e;\n            case 0x307:\n              consumed = 2; return 0x4e;\n            case 0x30c:\n              consumed = 2; return 0x4e;\n            case 0x323:\n              consumed = 2; return 0x4e;\n            case 0x327:\n              consumed = 2; return 0x4e;\n            case 0x32d:\n              consumed = 2; return 0x4e;\n            case 0x331:\n              consumed = 2; return 0x4e;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x4f:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x4f;\n            case 0x301:\n              consumed = 2; return 0x4f;\n            case 0x302:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x4f;\n                  case 0x301:\n                    consumed = 3; return 0x4f;\n                  case 0x303:\n                    consumed = 3; return 0x4f;\n                  case 0x309:\n                    consumed = 3; return 0x4f;\n                }\n              }\n              consumed = 2; return 0x4f;\n            case 0x303:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x301:\n                    consumed = 3; return 0x4f;\n                  case 0x304:\n                    consumed = 3; return 0x4f;\n                  case 0x308:\n                    consumed = 3; return 0x4f;\n                }\n              }\n              consumed = 2; return 0x4f;\n            case 0x304:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x4f;\n                  case 0x301:\n                    consumed = 3; return 0x4f;\n                }\n              }\n              consumed = 2; return 0x4f;\n            case 0x306:\n              consumed = 2; return 0x4f;\n            case 0x307:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x304:\n                    consumed = 3; return 0x4f;\n                }\n              }\n              consumed = 2; return 0x4f;\n            case 0x308:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x304:\n                    consumed = 3; return 0x4f;\n                }\n              }\n              consumed = 2; return 0x4f;\n            case 0x309:\n              consumed = 2; return 0x4f;\n            case 0x30b:\n              consumed = 2; return 0x4f;\n            case 0x30c:\n              consumed = 2; return 0x4f;\n            case 0x30f:\n              consumed = 2; return 0x4f;\n            case 0x311:\n              consumed = 2; return 0x4f;\n            case 0x31b:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x4f;\n                  case 0x301:\n                    consumed = 3; return 0x4f;\n                  case 0x303:\n                    consumed = 3; return 0x4f;\n                  case 0x309:\n                    consumed = 3; return 0x4f;\n                  case 0x323:\n                    consumed = 3; return 0x4f;\n                }\n              }\n              consumed = 2; return 0x4f;\n            case 0x323:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x302:\n                    consumed = 3; return 0x4f;\n                }\n              }\n              consumed = 2; return 0x4f;\n            case 0x328:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x304:\n                    consumed = 3; return 0x4f;\n                }\n              }\n              consumed = 2; return 0x4f;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x50:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x301:\n              consumed = 2; return 0x50;\n            case 0x307:\n              consumed = 2; return 0x50;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x52:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x301:\n              consumed = 2; return 0x52;\n            case 0x307:\n              consumed = 2; return 0x52;\n            case 0x30c:\n              consumed = 2; return 0x52;\n            case 0x30f:\n              consumed = 2; return 0x52;\n            case 0x311:\n              consumed = 2; return 0x52;\n            case 0x323:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x304:\n                    consumed = 3; return 0x52;\n                }\n              }\n              consumed = 2; return 0x52;\n            case 0x327:\n              consumed = 2; return 0x52;\n            case 0x331:\n              consumed = 2; return 0x52;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x53:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x301:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x307:\n                    consumed = 3; return 0x53;\n                }\n              }\n              consumed = 2; return 0x53;\n            case 0x302:\n              consumed = 2; return 0x53;\n            case 0x307:\n              consumed = 2; return 0x53;\n            case 0x30c:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x307:\n                    consumed = 3; return 0x53;\n                }\n              }\n              consumed = 2; return 0x53;\n            case 0x323:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x307:\n                    consumed = 3; return 0x53;\n                }\n              }\n              consumed = 2; return 0x53;\n            case 0x326:\n              consumed = 2; return 0x53;\n            case 0x327:\n              consumed = 2; return 0x53;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x54:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x307:\n              consumed = 2; return 0x54;\n            case 0x30c:\n              consumed = 2; return 0x54;\n            case 0x323:\n              consumed = 2; return 0x54;\n            case 0x326:\n              consumed = 2; return 0x54;\n            case 0x327:\n              consumed = 2; return 0x54;\n            case 0x32d:\n              consumed = 2; return 0x54;\n            case 0x331:\n              consumed = 2; return 0x54;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x55:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x55;\n            case 0x301:\n              consumed = 2; return 0x55;\n            case 0x302:\n              consumed = 2; return 0x55;\n            case 0x303:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x301:\n                    consumed = 3; return 0x55;\n                }\n              }\n              consumed = 2; return 0x55;\n            case 0x304:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x308:\n                    consumed = 3; return 0x55;\n                }\n              }\n              consumed = 2; return 0x55;\n            case 0x306:\n              consumed = 2; return 0x55;\n            case 0x308:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x55;\n                  case 0x301:\n                    consumed = 3; return 0x55;\n                  case 0x304:\n                    consumed = 3; return 0x55;\n                  case 0x30c:\n                    consumed = 3; return 0x55;\n                }\n              }\n              consumed = 2; return 0x55;\n            case 0x309:\n              consumed = 2; return 0x55;\n            case 0x30a:\n              consumed = 2; return 0x55;\n            case 0x30b:\n              consumed = 2; return 0x55;\n            case 0x30c:\n              consumed = 2; return 0x55;\n            case 0x30f:\n              consumed = 2; return 0x55;\n            case 0x311:\n              consumed = 2; return 0x55;\n            case 0x31b:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x55;\n                  case 0x301:\n                    consumed = 3; return 0x55;\n                  case 0x303:\n                    consumed = 3; return 0x55;\n                  case 0x309:\n                    consumed = 3; return 0x55;\n                  case 0x323:\n                    consumed = 3; return 0x55;\n                }\n              }\n              consumed = 2; return 0x55;\n            case 0x323:\n              consumed = 2; return 0x55;\n            case 0x324:\n              consumed = 2; return 0x55;\n            case 0x328:\n              consumed = 2; return 0x55;\n            case 0x32d:\n              consumed = 2; return 0x55;\n            case 0x330:\n              consumed = 2; return 0x55;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x56:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x303:\n              consumed = 2; return 0x56;\n            case 0x323:\n              consumed = 2; return 0x56;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x57:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x57;\n            case 0x301:\n              consumed = 2; return 0x57;\n            case 0x302:\n              consumed = 2; return 0x57;\n            case 0x307:\n              consumed = 2; return 0x57;\n            case 0x308:\n              consumed = 2; return 0x57;\n            case 0x323:\n              consumed = 2; return 0x57;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x58:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x307:\n              consumed = 2; return 0x58;\n            case 0x308:\n              consumed = 2; return 0x58;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x59:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x59;\n            case 0x301:\n              consumed = 2; return 0x59;\n            case 0x302:\n              consumed = 2; return 0x59;\n            case 0x303:\n              consumed = 2; return 0x59;\n            case 0x304:\n              consumed = 2; return 0x59;\n            case 0x307:\n              consumed = 2; return 0x59;\n            case 0x308:\n              consumed = 2; return 0x59;\n            case 0x309:\n              consumed = 2; return 0x59;\n            case 0x323:\n              consumed = 2; return 0x59;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x5a:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x301:\n              consumed = 2; return 0x5a;\n            case 0x302:\n              consumed = 2; return 0x5a;\n            case 0x307:\n              consumed = 2; return 0x5a;\n            case 0x30c:\n              consumed = 2; return 0x5a;\n            case 0x323:\n              consumed = 2; return 0x5a;\n            case 0x331:\n              consumed = 2; return 0x5a;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x61:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x61;\n            case 0x301:\n              consumed = 2; return 0x61;\n            case 0x302:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x61;\n                  case 0x301:\n                    consumed = 3; return 0x61;\n                  case 0x303:\n                    consumed = 3; return 0x61;\n                  case 0x309:\n                    consumed = 3; return 0x61;\n                }\n              }\n              consumed = 2; return 0x61;\n            case 0x303:\n              consumed = 2; return 0x61;\n            case 0x304:\n              consumed = 2; return 0x61;\n            case 0x306:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x61;\n                  case 0x301:\n                    consumed = 3; return 0x61;\n                  case 0x303:\n                    consumed = 3; return 0x61;\n                  case 0x309:\n                    consumed = 3; return 0x61;\n                }\n              }\n              consumed = 2; return 0x61;\n            case 0x307:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x304:\n                    consumed = 3; return 0x61;\n                }\n              }\n              consumed = 2; return 0x61;\n            case 0x308:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x304:\n                    consumed = 3; return 0x61;\n                }\n              }\n              consumed = 2; return 0x61;\n            case 0x309:\n              consumed = 2; return 0x61;\n            case 0x30a:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x301:\n                    consumed = 3; return 0x61;\n                }\n              }\n              consumed = 2; return 0x61;\n            case 0x30c:\n              consumed = 2; return 0x61;\n            case 0x30f:\n              consumed = 2; return 0x61;\n            case 0x311:\n              consumed = 2; return 0x61;\n            case 0x323:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x302:\n                    consumed = 3; return 0x61;\n                  case 0x306:\n                    consumed = 3; return 0x61;\n                }\n              }\n              consumed = 2; return 0x61;\n            case 0x325:\n              consumed = 2; return 0x61;\n            case 0x328:\n              consumed = 2; return 0x61;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x62:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x307:\n              consumed = 2; return 0x62;\n            case 0x323:\n              consumed = 2; return 0x62;\n            case 0x331:\n              consumed = 2; return 0x62;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x63:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x301:\n              consumed = 2; return 0x63;\n            case 0x302:\n              consumed = 2; return 0x63;\n            case 0x307:\n              consumed = 2; return 0x63;\n            case 0x30c:\n              consumed = 2; return 0x63;\n            case 0x327:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x301:\n                    consumed = 3; return 0x63;\n                }\n              }\n              consumed = 2; return 0x63;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x64:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x307:\n              consumed = 2; return 0x64;\n            case 0x30c:\n              consumed = 2; return 0x64;\n            case 0x323:\n              consumed = 2; return 0x64;\n            case 0x327:\n              consumed = 2; return 0x64;\n            case 0x32d:\n              consumed = 2; return 0x64;\n            case 0x331:\n              consumed = 2; return 0x64;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x65:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x65;\n            case 0x301:\n              consumed = 2; return 0x65;\n            case 0x302:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x65;\n                  case 0x301:\n                    consumed = 3; return 0x65;\n                  case 0x303:\n                    consumed = 3; return 0x65;\n                  case 0x309:\n                    consumed = 3; return 0x65;\n                }\n              }\n              consumed = 2; return 0x65;\n            case 0x303:\n              consumed = 2; return 0x65;\n            case 0x304:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x65;\n                  case 0x301:\n                    consumed = 3; return 0x65;\n                }\n              }\n              consumed = 2; return 0x65;\n            case 0x306:\n              consumed = 2; return 0x65;\n            case 0x307:\n              consumed = 2; return 0x65;\n            case 0x308:\n              consumed = 2; return 0x65;\n            case 0x309:\n              consumed = 2; return 0x65;\n            case 0x30c:\n              consumed = 2; return 0x65;\n            case 0x30f:\n              consumed = 2; return 0x65;\n            case 0x311:\n              consumed = 2; return 0x65;\n            case 0x323:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x302:\n                    consumed = 3; return 0x65;\n                }\n              }\n              consumed = 2; return 0x65;\n            case 0x327:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x306:\n                    consumed = 3; return 0x65;\n                }\n              }\n              consumed = 2; return 0x65;\n            case 0x328:\n              consumed = 2; return 0x65;\n            case 0x32d:\n              consumed = 2; return 0x65;\n            case 0x330:\n              consumed = 2; return 0x65;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x66:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x307:\n              consumed = 2; return 0x66;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x67:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x301:\n              consumed = 2; return 0x67;\n            case 0x302:\n              consumed = 2; return 0x67;\n            case 0x304:\n              consumed = 2; return 0x67;\n            case 0x306:\n              consumed = 2; return 0x67;\n            case 0x307:\n              consumed = 2; return 0x67;\n            case 0x30c:\n              consumed = 2; return 0x67;\n            case 0x327:\n              consumed = 2; return 0x67;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x68:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x302:\n              consumed = 2; return 0x68;\n            case 0x307:\n              consumed = 2; return 0x68;\n            case 0x308:\n              consumed = 2; return 0x68;\n            case 0x30c:\n              consumed = 2; return 0x68;\n            case 0x323:\n              consumed = 2; return 0x68;\n            case 0x327:\n              consumed = 2; return 0x68;\n            case 0x32e:\n              consumed = 2; return 0x68;\n            case 0x331:\n              consumed = 2; return 0x68;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x69:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x69;\n            case 0x301:\n              consumed = 2; return 0x69;\n            case 0x302:\n              consumed = 2; return 0x69;\n            case 0x303:\n              consumed = 2; return 0x69;\n            case 0x304:\n              consumed = 2; return 0x69;\n            case 0x306:\n              consumed = 2; return 0x69;\n            case 0x308:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x301:\n                    consumed = 3; return 0x69;\n                }\n              }\n              consumed = 2; return 0x69;\n            case 0x309:\n              consumed = 2; return 0x69;\n            case 0x30c:\n              consumed = 2; return 0x69;\n            case 0x30f:\n              consumed = 2; return 0x69;\n            case 0x311:\n              consumed = 2; return 0x69;\n            case 0x323:\n              consumed = 2; return 0x69;\n            case 0x328:\n              consumed = 2; return 0x69;\n            case 0x330:\n              consumed = 2; return 0x69;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x6a:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x302:\n              consumed = 2; return 0x6a;\n            case 0x30c:\n              consumed = 2; return 0x6a;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x6b:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x301:\n              consumed = 2; return 0x6b;\n            case 0x30c:\n              consumed = 2; return 0x6b;\n            case 0x323:\n              consumed = 2; return 0x6b;\n            case 0x327:\n              consumed = 2; return 0x6b;\n            case 0x331:\n              consumed = 2; return 0x6b;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x6c:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x301:\n              consumed = 2; return 0x6c;\n            case 0x30c:\n              consumed = 2; return 0x6c;\n            case 0x323:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x304:\n                    consumed = 3; return 0x6c;\n                }\n              }\n              consumed = 2; return 0x6c;\n            case 0x327:\n              consumed = 2; return 0x6c;\n            case 0x32d:\n              consumed = 2; return 0x6c;\n            case 0x331:\n              consumed = 2; return 0x6c;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x6d:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x301:\n              consumed = 2; return 0x6d;\n            case 0x307:\n              consumed = 2; return 0x6d;\n            case 0x323:\n              consumed = 2; return 0x6d;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x6e:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x6e;\n            case 0x301:\n              consumed = 2; return 0x6e;\n            case 0x303:\n              consumed = 2; return 0x6e;\n            case 0x307:\n              consumed = 2; return 0x6e;\n            case 0x30c:\n              consumed = 2; return 0x6e;\n            case 0x323:\n              consumed = 2; return 0x6e;\n            case 0x327:\n              consumed = 2; return 0x6e;\n            case 0x32d:\n              consumed = 2; return 0x6e;\n            case 0x331:\n              consumed = 2; return 0x6e;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x6f:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x6f;\n            case 0x301:\n              consumed = 2; return 0x6f;\n            case 0x302:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x6f;\n                  case 0x301:\n                    consumed = 3; return 0x6f;\n                  case 0x303:\n                    consumed = 3; return 0x6f;\n                  case 0x309:\n                    consumed = 3; return 0x6f;\n                }\n              }\n              consumed = 2; return 0x6f;\n            case 0x303:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x301:\n                    consumed = 3; return 0x6f;\n                  case 0x304:\n                    consumed = 3; return 0x6f;\n                  case 0x308:\n                    consumed = 3; return 0x6f;\n                }\n              }\n              consumed = 2; return 0x6f;\n            case 0x304:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x6f;\n                  case 0x301:\n                    consumed = 3; return 0x6f;\n                }\n              }\n              consumed = 2; return 0x6f;\n            case 0x306:\n              consumed = 2; return 0x6f;\n            case 0x307:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x304:\n                    consumed = 3; return 0x6f;\n                }\n              }\n              consumed = 2; return 0x6f;\n            case 0x308:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x304:\n                    consumed = 3; return 0x6f;\n                }\n              }\n              consumed = 2; return 0x6f;\n            case 0x309:\n              consumed = 2; return 0x6f;\n            case 0x30b:\n              consumed = 2; return 0x6f;\n            case 0x30c:\n              consumed = 2; return 0x6f;\n            case 0x30f:\n              consumed = 2; return 0x6f;\n            case 0x311:\n              consumed = 2; return 0x6f;\n            case 0x31b:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x6f;\n                  case 0x301:\n                    consumed = 3; return 0x6f;\n                  case 0x303:\n                    consumed = 3; return 0x6f;\n                  case 0x309:\n                    consumed = 3; return 0x6f;\n                  case 0x323:\n                    consumed = 3; return 0x6f;\n                }\n              }\n              consumed = 2; return 0x6f;\n            case 0x323:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x302:\n                    consumed = 3; return 0x6f;\n                }\n              }\n              consumed = 2; return 0x6f;\n            case 0x328:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x304:\n                    consumed = 3; return 0x6f;\n                }\n              }\n              consumed = 2; return 0x6f;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x70:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x301:\n              consumed = 2; return 0x70;\n            case 0x307:\n              consumed = 2; return 0x70;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x72:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x301:\n              consumed = 2; return 0x72;\n            case 0x307:\n              consumed = 2; return 0x72;\n            case 0x30c:\n              consumed = 2; return 0x72;\n            case 0x30f:\n              consumed = 2; return 0x72;\n            case 0x311:\n              consumed = 2; return 0x72;\n            case 0x323:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x304:\n                    consumed = 3; return 0x72;\n                }\n              }\n              consumed = 2; return 0x72;\n            case 0x327:\n              consumed = 2; return 0x72;\n            case 0x331:\n              consumed = 2; return 0x72;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x73:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x301:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x307:\n                    consumed = 3; return 0x73;\n                }\n              }\n              consumed = 2; return 0x73;\n            case 0x302:\n              consumed = 2; return 0x73;\n            case 0x307:\n              consumed = 2; return 0x73;\n            case 0x30c:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x307:\n                    consumed = 3; return 0x73;\n                }\n              }\n              consumed = 2; return 0x73;\n            case 0x323:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x307:\n                    consumed = 3; return 0x73;\n                }\n              }\n              consumed = 2; return 0x73;\n            case 0x326:\n              consumed = 2; return 0x73;\n            case 0x327:\n              consumed = 2; return 0x73;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x74:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x307:\n              consumed = 2; return 0x74;\n            case 0x308:\n              consumed = 2; return 0x74;\n            case 0x30c:\n              consumed = 2; return 0x74;\n            case 0x323:\n              consumed = 2; return 0x74;\n            case 0x326:\n              consumed = 2; return 0x74;\n            case 0x327:\n              consumed = 2; return 0x74;\n            case 0x32d:\n              consumed = 2; return 0x74;\n            case 0x331:\n              consumed = 2; return 0x74;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x75:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x75;\n            case 0x301:\n              consumed = 2; return 0x75;\n            case 0x302:\n              consumed = 2; return 0x75;\n            case 0x303:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x301:\n                    consumed = 3; return 0x75;\n                }\n              }\n              consumed = 2; return 0x75;\n            case 0x304:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x308:\n                    consumed = 3; return 0x75;\n                }\n              }\n              consumed = 2; return 0x75;\n            case 0x306:\n              consumed = 2; return 0x75;\n            case 0x308:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x75;\n                  case 0x301:\n                    consumed = 3; return 0x75;\n                  case 0x304:\n                    consumed = 3; return 0x75;\n                  case 0x30c:\n                    consumed = 3; return 0x75;\n                }\n              }\n              consumed = 2; return 0x75;\n            case 0x309:\n              consumed = 2; return 0x75;\n            case 0x30a:\n              consumed = 2; return 0x75;\n            case 0x30b:\n              consumed = 2; return 0x75;\n            case 0x30c:\n              consumed = 2; return 0x75;\n            case 0x30f:\n              consumed = 2; return 0x75;\n            case 0x311:\n              consumed = 2; return 0x75;\n            case 0x31b:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x75;\n                  case 0x301:\n                    consumed = 3; return 0x75;\n                  case 0x303:\n                    consumed = 3; return 0x75;\n                  case 0x309:\n                    consumed = 3; return 0x75;\n                  case 0x323:\n                    consumed = 3; return 0x75;\n                }\n              }\n              consumed = 2; return 0x75;\n            case 0x323:\n              consumed = 2; return 0x75;\n            case 0x324:\n              consumed = 2; return 0x75;\n            case 0x328:\n              consumed = 2; return 0x75;\n            case 0x32d:\n              consumed = 2; return 0x75;\n            case 0x330:\n              consumed = 2; return 0x75;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x76:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x303:\n              consumed = 2; return 0x76;\n            case 0x323:\n              consumed = 2; return 0x76;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x77:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x77;\n            case 0x301:\n              consumed = 2; return 0x77;\n            case 0x302:\n              consumed = 2; return 0x77;\n            case 0x307:\n              consumed = 2; return 0x77;\n            case 0x308:\n              consumed = 2; return 0x77;\n            case 0x30a:\n              consumed = 2; return 0x77;\n            case 0x323:\n              consumed = 2; return 0x77;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x78:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x307:\n              consumed = 2; return 0x78;\n            case 0x308:\n              consumed = 2; return 0x78;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x79:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x79;\n            case 0x301:\n              consumed = 2; return 0x79;\n            case 0x302:\n              consumed = 2; return 0x79;\n            case 0x303:\n              consumed = 2; return 0x79;\n            case 0x304:\n              consumed = 2; return 0x79;\n            case 0x307:\n              consumed = 2; return 0x79;\n            case 0x308:\n              consumed = 2; return 0x79;\n            case 0x309:\n              consumed = 2; return 0x79;\n            case 0x30a:\n              consumed = 2; return 0x79;\n            case 0x323:\n              consumed = 2; return 0x79;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x7a:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x301:\n              consumed = 2; return 0x7a;\n            case 0x302:\n              consumed = 2; return 0x7a;\n            case 0x307:\n              consumed = 2; return 0x7a;\n            case 0x30c:\n              consumed = 2; return 0x7a;\n            case 0x323:\n              consumed = 2; return 0x7a;\n            case 0x331:\n              consumed = 2; return 0x7a;\n          }\n        }\n        consumed = 1; return *in;\n      case 0xc0:\n        consumed = 1; return 0x41;\n      case 0xc1:\n        consumed = 1; return 0x41;\n      case 0xc2:\n        consumed = 1; return 0x41;\n      case 0xc3:\n        consumed = 1; return 0x41;\n      case 0xc4:\n        consumed = 1; return 0x41;\n      case 0xc5:\n        consumed = 1; return 0x41;\n      case 0xc6:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x301:\n              consumed = 2; return 0xc6;\n            case 0x304:\n              consumed = 2; return 0xc6;\n          }\n        }\n        consumed = 1; return *in;\n      case 0xc7:\n        consumed = 1; return 0x43;\n      case 0xc8:\n        consumed = 1; return 0x45;\n      case 0xc9:\n        consumed = 1; return 0x45;\n      case 0xca:\n        consumed = 1; return 0x45;\n      case 0xcb:\n        consumed = 1; return 0x45;\n      case 0xcc:\n        consumed = 1; return 0x49;\n      case 0xcd:\n        consumed = 1; return 0x49;\n      case 0xce:\n        consumed = 1; return 0x49;\n      case 0xcf:\n        consumed = 1; return 0x49;\n      case 0xd1:\n        consumed = 1; return 0x4e;\n      case 0xd2:\n        consumed = 1; return 0x4f;\n      case 0xd3:\n        consumed = 1; return 0x4f;\n      case 0xd4:\n        consumed = 1; return 0x4f;\n      case 0xd5:\n        consumed = 1; return 0x4f;\n      case 0xd6:\n        consumed = 1; return 0x4f;\n      case 0xd8:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x301:\n              consumed = 2; return 0xd8;\n          }\n        }\n        consumed = 1; return 0x4f;\n      case 0xd9:\n        consumed = 1; return 0x55;\n      case 0xda:\n        consumed = 1; return 0x55;\n      case 0xdb:\n        consumed = 1; return 0x55;\n      case 0xdc:\n        consumed = 1; return 0x55;\n      case 0xdd:\n        consumed = 1; return 0x59;\n      case 0xe0:\n        consumed = 1; return 0x61;\n      case 0xe1:\n        consumed = 1; return 0x61;\n      case 0xe2:\n        consumed = 1; return 0x61;\n      case 0xe3:\n        consumed = 1; return 0x61;\n      case 0xe4:\n        consumed = 1; return 0x61;\n      case 0xe5:\n        consumed = 1; return 0x61;\n      case 0xe6:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x301:\n              consumed = 2; return 0xe6;\n            case 0x304:\n              consumed = 2; return 0xe6;\n          }\n        }\n        consumed = 1; return *in;\n      case 0xe7:\n        consumed = 1; return 0x63;\n      case 0xe8:\n        consumed = 1; return 0x65;\n      case 0xe9:\n        consumed = 1; return 0x65;\n      case 0xea:\n        consumed = 1; return 0x65;\n      case 0xeb:\n        consumed = 1; return 0x65;\n      case 0xec:\n        consumed = 1; return 0x69;\n      case 0xed:\n        consumed = 1; return 0x69;\n      case 0xee:\n        consumed = 1; return 0x69;\n      case 0xef:\n        consumed = 1; return 0x69;\n      case 0xf1:\n        consumed = 1; return 0x6e;\n      case 0xf2:\n        consumed = 1; return 0x6f;\n      case 0xf3:\n        consumed = 1; return 0x6f;\n      case 0xf4:\n        consumed = 1; return 0x6f;\n      case 0xf5:\n        consumed = 1; return 0x6f;\n      case 0xf6:\n        consumed = 1; return 0x6f;\n      case 0xf8:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x301:\n              consumed = 2; return 0xf8;\n          }\n        }\n        consumed = 1; return 0x6f;\n      case 0xf9:\n        consumed = 1; return 0x75;\n      case 0xfa:\n        consumed = 1; return 0x75;\n      case 0xfb:\n        consumed = 1; return 0x75;\n      case 0xfc:\n        consumed = 1; return 0x75;\n      case 0xfd:\n        consumed = 1; return 0x79;\n      case 0xff:\n        consumed = 1; return 0x79;\n      case 0x100:\n        consumed = 1; return 0x41;\n      case 0x101:\n        consumed = 1; return 0x61;\n      case 0x102:\n        consumed = 1; return 0x41;\n      case 0x103:\n        consumed = 1; return 0x61;\n      case 0x104:\n        consumed = 1; return 0x41;\n      case 0x105:\n        consumed = 1; return 0x61;\n      case 0x106:\n        consumed = 1; return 0x43;\n      case 0x107:\n        consumed = 1; return 0x63;\n      case 0x108:\n        consumed = 1; return 0x43;\n      case 0x109:\n        consumed = 1; return 0x63;\n      case 0x10a:\n        consumed = 1; return 0x43;\n      case 0x10b:\n        consumed = 1; return 0x63;\n      case 0x10c:\n        consumed = 1; return 0x43;\n      case 0x10d:\n        consumed = 1; return 0x63;\n      case 0x10e:\n        consumed = 1; return 0x44;\n      case 0x10f:\n        consumed = 1; return 0x64;\n      case 0x110:\n        consumed = 1; return 0x44;\n      case 0x111:\n        consumed = 1; return 0x64;\n      case 0x112:\n        consumed = 1; return 0x45;\n      case 0x113:\n        consumed = 1; return 0x65;\n      case 0x114:\n        consumed = 1; return 0x45;\n      case 0x115:\n        consumed = 1; return 0x65;\n      case 0x116:\n        consumed = 1; return 0x45;\n      case 0x117:\n        consumed = 1; return 0x65;\n      case 0x118:\n        consumed = 1; return 0x45;\n      case 0x119:\n        consumed = 1; return 0x65;\n      case 0x11a:\n        consumed = 1; return 0x45;\n      case 0x11b:\n        consumed = 1; return 0x65;\n      case 0x11c:\n        consumed = 1; return 0x47;\n      case 0x11d:\n        consumed = 1; return 0x67;\n      case 0x11e:\n        consumed = 1; return 0x47;\n      case 0x11f:\n        consumed = 1; return 0x67;\n      case 0x120:\n        consumed = 1; return 0x47;\n      case 0x121:\n        consumed = 1; return 0x67;\n      case 0x122:\n        consumed = 1; return 0x47;\n      case 0x123:\n        consumed = 1; return 0x67;\n      case 0x124:\n        consumed = 1; return 0x48;\n      case 0x125:\n        consumed = 1; return 0x68;\n      case 0x126:\n        consumed = 1; return 0x48;\n      case 0x127:\n        consumed = 1; return 0x68;\n      case 0x128:\n        consumed = 1; return 0x49;\n      case 0x129:\n        consumed = 1; return 0x69;\n      case 0x12a:\n        consumed = 1; return 0x49;\n      case 0x12b:\n        consumed = 1; return 0x69;\n      case 0x12c:\n        consumed = 1; return 0x49;\n      case 0x12d:\n        consumed = 1; return 0x69;\n      case 0x12e:\n        consumed = 1; return 0x49;\n      case 0x12f:\n        consumed = 1; return 0x69;\n      case 0x130:\n        consumed = 1; return 0x49;\n      case 0x134:\n        consumed = 1; return 0x4a;\n      case 0x135:\n        consumed = 1; return 0x6a;\n      case 0x136:\n        consumed = 1; return 0x4b;\n      case 0x137:\n        consumed = 1; return 0x6b;\n      case 0x139:\n        consumed = 1; return 0x4c;\n      case 0x13a:\n        consumed = 1; return 0x6c;\n      case 0x13b:\n        consumed = 1; return 0x4c;\n      case 0x13c:\n        consumed = 1; return 0x6c;\n      case 0x13d:\n        consumed = 1; return 0x4c;\n      case 0x13e:\n        consumed = 1; return 0x6c;\n      case 0x140:\n        consumed = 1; return 0x6c;\n      case 0x141:\n        consumed = 1; return 0x4c;\n      case 0x142:\n        consumed = 1; return 0x6c;\n      case 0x143:\n        consumed = 1; return 0x4e;\n      case 0x144:\n        consumed = 1; return 0x6e;\n      case 0x145:\n        consumed = 1; return 0x4e;\n      case 0x146:\n        consumed = 1; return 0x6e;\n      case 0x147:\n        consumed = 1; return 0x4e;\n      case 0x148:\n        consumed = 1; return 0x6e;\n      case 0x14c:\n        consumed = 1; return 0x4f;\n      case 0x14d:\n        consumed = 1; return 0x6f;\n      case 0x14e:\n        consumed = 1; return 0x4f;\n      case 0x14f:\n        consumed = 1; return 0x6f;\n      case 0x150:\n        consumed = 1; return 0x4f;\n      case 0x151:\n        consumed = 1; return 0x6f;\n      case 0x154:\n        consumed = 1; return 0x52;\n      case 0x155:\n        consumed = 1; return 0x72;\n      case 0x156:\n        consumed = 1; return 0x52;\n      case 0x157:\n        consumed = 1; return 0x72;\n      case 0x158:\n        consumed = 1; return 0x52;\n      case 0x159:\n        consumed = 1; return 0x72;\n      case 0x15a:\n        consumed = 1; return 0x53;\n      case 0x15b:\n        consumed = 1; return 0x73;\n      case 0x15c:\n        consumed = 1; return 0x53;\n      case 0x15d:\n        consumed = 1; return 0x73;\n      case 0x15e:\n        consumed = 1; return 0x53;\n      case 0x15f:\n        consumed = 1; return 0x73;\n      case 0x160:\n        consumed = 1; return 0x53;\n      case 0x161:\n        consumed = 1; return 0x73;\n      case 0x162:\n        consumed = 1; return 0x54;\n      case 0x163:\n        consumed = 1; return 0x74;\n      case 0x164:\n        consumed = 1; return 0x54;\n      case 0x165:\n        consumed = 1; return 0x74;\n      case 0x166:\n        consumed = 1; return 0x54;\n      case 0x167:\n        consumed = 1; return 0x74;\n      case 0x168:\n        consumed = 1; return 0x55;\n      case 0x169:\n        consumed = 1; return 0x75;\n      case 0x16a:\n        consumed = 1; return 0x55;\n      case 0x16b:\n        consumed = 1; return 0x75;\n      case 0x16c:\n        consumed = 1; return 0x55;\n      case 0x16d:\n        consumed = 1; return 0x75;\n      case 0x16e:\n        consumed = 1; return 0x55;\n      case 0x16f:\n        consumed = 1; return 0x75;\n      case 0x170:\n        consumed = 1; return 0x55;\n      case 0x171:\n        consumed = 1; return 0x75;\n      case 0x172:\n        consumed = 1; return 0x55;\n      case 0x173:\n        consumed = 1; return 0x75;\n      case 0x174:\n        consumed = 1; return 0x57;\n      case 0x175:\n        consumed = 1; return 0x77;\n      case 0x176:\n        consumed = 1; return 0x59;\n      case 0x177:\n        consumed = 1; return 0x79;\n      case 0x178:\n        consumed = 1; return 0x59;\n      case 0x179:\n        consumed = 1; return 0x5a;\n      case 0x17a:\n        consumed = 1; return 0x7a;\n      case 0x17b:\n        consumed = 1; return 0x5a;\n      case 0x17c:\n        consumed = 1; return 0x7a;\n      case 0x17d:\n        consumed = 1; return 0x5a;\n      case 0x17e:\n        consumed = 1; return 0x7a;\n      case 0x17f:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x307:\n              consumed = 2; return 0x17f;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x180:\n        consumed = 1; return 0x62;\n      case 0x181:\n        consumed = 1; return 0x42;\n      case 0x182:\n        consumed = 1; return 0x42;\n      case 0x183:\n        consumed = 1; return 0x62;\n      case 0x187:\n        consumed = 1; return 0x43;\n      case 0x188:\n        consumed = 1; return 0x63;\n      case 0x18a:\n        consumed = 1; return 0x44;\n      case 0x18b:\n        consumed = 1; return 0x44;\n      case 0x18c:\n        consumed = 1; return 0x64;\n      case 0x191:\n        consumed = 1; return 0x46;\n      case 0x192:\n        consumed = 1; return 0x66;\n      case 0x193:\n        consumed = 1; return 0x47;\n      case 0x197:\n        consumed = 1; return 0x49;\n      case 0x198:\n        consumed = 1; return 0x4b;\n      case 0x199:\n        consumed = 1; return 0x6b;\n      case 0x19a:\n        consumed = 1; return 0x6c;\n      case 0x19d:\n        consumed = 1; return 0x4e;\n      case 0x19e:\n        consumed = 1; return 0x6e;\n      case 0x19f:\n        consumed = 1; return 0x4f;\n      case 0x1a0:\n        consumed = 1; return 0x4f;\n      case 0x1a1:\n        consumed = 1; return 0x6f;\n      case 0x1a4:\n        consumed = 1; return 0x50;\n      case 0x1a5:\n        consumed = 1; return 0x70;\n      case 0x1ab:\n        consumed = 1; return 0x74;\n      case 0x1ac:\n        consumed = 1; return 0x54;\n      case 0x1ad:\n        consumed = 1; return 0x74;\n      case 0x1ae:\n        consumed = 1; return 0x54;\n      case 0x1af:\n        consumed = 1; return 0x55;\n      case 0x1b0:\n        consumed = 1; return 0x75;\n      case 0x1b2:\n        consumed = 1; return 0x56;\n      case 0x1b3:\n        consumed = 1; return 0x59;\n      case 0x1b4:\n        consumed = 1; return 0x79;\n      case 0x1b5:\n        consumed = 1; return 0x5a;\n      case 0x1b6:\n        consumed = 1; return 0x7a;\n      case 0x1b7:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x30c:\n              consumed = 2; return 0x1b7;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x1ba:\n        consumed = 1; return 0x292;\n      case 0x1cd:\n        consumed = 1; return 0x41;\n      case 0x1ce:\n        consumed = 1; return 0x61;\n      case 0x1cf:\n        consumed = 1; return 0x49;\n      case 0x1d0:\n        consumed = 1; return 0x69;\n      case 0x1d1:\n        consumed = 1; return 0x4f;\n      case 0x1d2:\n        consumed = 1; return 0x6f;\n      case 0x1d3:\n        consumed = 1; return 0x55;\n      case 0x1d4:\n        consumed = 1; return 0x75;\n      case 0x1d5:\n        consumed = 1; return 0x55;\n      case 0x1d6:\n        consumed = 1; return 0x75;\n      case 0x1d7:\n        consumed = 1; return 0x55;\n      case 0x1d8:\n        consumed = 1; return 0x75;\n      case 0x1d9:\n        consumed = 1; return 0x55;\n      case 0x1da:\n        consumed = 1; return 0x75;\n      case 0x1db:\n        consumed = 1; return 0x55;\n      case 0x1dc:\n        consumed = 1; return 0x75;\n      case 0x1de:\n        consumed = 1; return 0x41;\n      case 0x1df:\n        consumed = 1; return 0x61;\n      case 0x1e0:\n        consumed = 1; return 0x41;\n      case 0x1e1:\n        consumed = 1; return 0x61;\n      case 0x1e2:\n        consumed = 1; return 0xc6;\n      case 0x1e3:\n        consumed = 1; return 0xe6;\n      case 0x1e4:\n        consumed = 1; return 0x47;\n      case 0x1e5:\n        consumed = 1; return 0x67;\n      case 0x1e6:\n        consumed = 1; return 0x47;\n      case 0x1e7:\n        consumed = 1; return 0x67;\n      case 0x1e8:\n        consumed = 1; return 0x4b;\n      case 0x1e9:\n        consumed = 1; return 0x6b;\n      case 0x1ea:\n        consumed = 1; return 0x4f;\n      case 0x1eb:\n        consumed = 1; return 0x6f;\n      case 0x1ec:\n        consumed = 1; return 0x4f;\n      case 0x1ed:\n        consumed = 1; return 0x6f;\n      case 0x1ee:\n        consumed = 1; return 0x1b7;\n      case 0x1ef:\n        consumed = 1; return 0x292;\n      case 0x1f0:\n        consumed = 1; return 0x6a;\n      case 0x1f4:\n        consumed = 1; return 0x47;\n      case 0x1f5:\n        consumed = 1; return 0x67;\n      case 0x1f8:\n        consumed = 1; return 0x4e;\n      case 0x1f9:\n        consumed = 1; return 0x6e;\n      case 0x1fa:\n        consumed = 1; return 0x41;\n      case 0x1fb:\n        consumed = 1; return 0x61;\n      case 0x1fc:\n        consumed = 1; return 0xc6;\n      case 0x1fd:\n        consumed = 1; return 0xe6;\n      case 0x1fe:\n        consumed = 1; return 0x4f;\n      case 0x1ff:\n        consumed = 1; return 0x6f;\n      case 0x200:\n        consumed = 1; return 0x41;\n      case 0x201:\n        consumed = 1; return 0x61;\n      case 0x202:\n        consumed = 1; return 0x41;\n      case 0x203:\n        consumed = 1; return 0x61;\n      case 0x204:\n        consumed = 1; return 0x45;\n      case 0x205:\n        consumed = 1; return 0x65;\n      case 0x206:\n        consumed = 1; return 0x45;\n      case 0x207:\n        consumed = 1; return 0x65;\n      case 0x208:\n        consumed = 1; return 0x49;\n      case 0x209:\n        consumed = 1; return 0x69;\n      case 0x20a:\n        consumed = 1; return 0x49;\n      case 0x20b:\n        consumed = 1; return 0x69;\n      case 0x20c:\n        consumed = 1; return 0x4f;\n      case 0x20d:\n        consumed = 1; return 0x6f;\n      case 0x20e:\n        consumed = 1; return 0x4f;\n      case 0x20f:\n        consumed = 1; return 0x6f;\n      case 0x210:\n        consumed = 1; return 0x52;\n      case 0x211:\n        consumed = 1; return 0x72;\n      case 0x212:\n        consumed = 1; return 0x52;\n      case 0x213:\n        consumed = 1; return 0x72;\n      case 0x214:\n        consumed = 1; return 0x55;\n      case 0x215:\n        consumed = 1; return 0x75;\n      case 0x216:\n        consumed = 1; return 0x55;\n      case 0x217:\n        consumed = 1; return 0x75;\n      case 0x218:\n        consumed = 1; return 0x53;\n      case 0x219:\n        consumed = 1; return 0x73;\n      case 0x21a:\n        consumed = 1; return 0x54;\n      case 0x21b:\n        consumed = 1; return 0x74;\n      case 0x21e:\n        consumed = 1; return 0x48;\n      case 0x21f:\n        consumed = 1; return 0x68;\n      case 0x220:\n        consumed = 1; return 0x4e;\n      case 0x221:\n        consumed = 1; return 0x64;\n      case 0x224:\n        consumed = 1; return 0x5a;\n      case 0x225:\n        consumed = 1; return 0x7a;\n      case 0x226:\n        consumed = 1; return 0x41;\n      case 0x227:\n        consumed = 1; return 0x61;\n      case 0x228:\n        consumed = 1; return 0x45;\n      case 0x229:\n        consumed = 1; return 0x65;\n      case 0x22a:\n        consumed = 1; return 0x4f;\n      case 0x22b:\n        consumed = 1; return 0x6f;\n      case 0x22c:\n        consumed = 1; return 0x4f;\n      case 0x22d:\n        consumed = 1; return 0x6f;\n      case 0x22e:\n        consumed = 1; return 0x4f;\n      case 0x22f:\n        consumed = 1; return 0x6f;\n      case 0x230:\n        consumed = 1; return 0x4f;\n      case 0x231:\n        consumed = 1; return 0x6f;\n      case 0x232:\n        consumed = 1; return 0x59;\n      case 0x233:\n        consumed = 1; return 0x79;\n      case 0x234:\n        consumed = 1; return 0x6c;\n      case 0x235:\n        consumed = 1; return 0x6e;\n      case 0x236:\n        consumed = 1; return 0x74;\n      case 0x253:\n        consumed = 1; return 0x62;\n      case 0x255:\n        consumed = 1; return 0x63;\n      case 0x256:\n        consumed = 1; return 0x64;\n      case 0x257:\n        consumed = 1; return 0x64;\n      case 0x25a:\n        consumed = 1; return 0x259;\n      case 0x260:\n        consumed = 1; return 0x67;\n      case 0x266:\n        consumed = 1; return 0x68;\n      case 0x268:\n        consumed = 1; return 0x69;\n      case 0x26b:\n        consumed = 1; return 0x6c;\n      case 0x26c:\n        consumed = 1; return 0x6c;\n      case 0x26d:\n        consumed = 1; return 0x6c;\n      case 0x271:\n        consumed = 1; return 0x6d;\n      case 0x272:\n        consumed = 1; return 0x6e;\n      case 0x273:\n        consumed = 1; return 0x6e;\n      case 0x27c:\n        consumed = 1; return 0x72;\n      case 0x27d:\n        consumed = 1; return 0x72;\n      case 0x282:\n        consumed = 1; return 0x73;\n      case 0x286:\n        consumed = 1; return 0x283;\n      case 0x288:\n        consumed = 1; return 0x74;\n      case 0x28b:\n        consumed = 1; return 0x76;\n      case 0x290:\n        consumed = 1; return 0x7a;\n      case 0x291:\n        consumed = 1; return 0x7a;\n      case 0x292:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x30c:\n              consumed = 2; return 0x292;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x293:\n        consumed = 1; return 0x292;\n      case 0x29d:\n        consumed = 1; return 0x6a;\n      case 0x2a0:\n        consumed = 1; return 0x71;\n      case 0x386:\n        consumed = 1; return 0x391;\n      case 0x388:\n        consumed = 1; return 0x395;\n      case 0x389:\n        consumed = 1; return 0x397;\n      case 0x38a:\n        consumed = 1; return 0x399;\n      case 0x38c:\n        consumed = 1; return 0x39f;\n      case 0x38e:\n        consumed = 1; return 0x3a5;\n      case 0x38f:\n        consumed = 1; return 0x3a9;\n      case 0x390:\n        consumed = 1; return 0x3b9;\n      case 0x391:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x391;\n            case 0x301:\n              consumed = 2; return 0x391;\n            case 0x304:\n              consumed = 2; return 0x391;\n            case 0x306:\n              consumed = 2; return 0x391;\n            case 0x313:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x391;\n                  case 0x301:\n                    consumed = 3; return 0x391;\n                  case 0x342:\n                    consumed = 3; return 0x391;\n                }\n              }\n              consumed = 2; return 0x391;\n            case 0x314:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x391;\n                  case 0x301:\n                    consumed = 3; return 0x391;\n                  case 0x342:\n                    consumed = 3; return 0x391;\n                }\n              }\n              consumed = 2; return 0x391;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x395:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x395;\n            case 0x301:\n              consumed = 2; return 0x395;\n            case 0x313:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x395;\n                  case 0x301:\n                    consumed = 3; return 0x395;\n                }\n              }\n              consumed = 2; return 0x395;\n            case 0x314:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x395;\n                  case 0x301:\n                    consumed = 3; return 0x395;\n                }\n              }\n              consumed = 2; return 0x395;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x397:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x397;\n            case 0x301:\n              consumed = 2; return 0x397;\n            case 0x313:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x397;\n                  case 0x301:\n                    consumed = 3; return 0x397;\n                  case 0x342:\n                    consumed = 3; return 0x397;\n                }\n              }\n              consumed = 2; return 0x397;\n            case 0x314:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x397;\n                  case 0x301:\n                    consumed = 3; return 0x397;\n                  case 0x342:\n                    consumed = 3; return 0x397;\n                }\n              }\n              consumed = 2; return 0x397;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x399:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x399;\n            case 0x301:\n              consumed = 2; return 0x399;\n            case 0x304:\n              consumed = 2; return 0x399;\n            case 0x306:\n              consumed = 2; return 0x399;\n            case 0x308:\n              consumed = 2; return 0x399;\n            case 0x313:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x399;\n                  case 0x301:\n                    consumed = 3; return 0x399;\n                  case 0x342:\n                    consumed = 3; return 0x399;\n                }\n              }\n              consumed = 2; return 0x399;\n            case 0x314:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x399;\n                  case 0x301:\n                    consumed = 3; return 0x399;\n                  case 0x342:\n                    consumed = 3; return 0x399;\n                }\n              }\n              consumed = 2; return 0x399;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x39f:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x39f;\n            case 0x301:\n              consumed = 2; return 0x39f;\n            case 0x313:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x39f;\n                  case 0x301:\n                    consumed = 3; return 0x39f;\n                }\n              }\n              consumed = 2; return 0x39f;\n            case 0x314:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x39f;\n                  case 0x301:\n                    consumed = 3; return 0x39f;\n                }\n              }\n              consumed = 2; return 0x39f;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x3a1:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x314:\n              consumed = 2; return 0x3a1;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x3a5:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x3a5;\n            case 0x301:\n              consumed = 2; return 0x3a5;\n            case 0x304:\n              consumed = 2; return 0x3a5;\n            case 0x306:\n              consumed = 2; return 0x3a5;\n            case 0x308:\n              consumed = 2; return 0x3a5;\n            case 0x314:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x3a5;\n                  case 0x301:\n                    consumed = 3; return 0x3a5;\n                  case 0x342:\n                    consumed = 3; return 0x3a5;\n                }\n              }\n              consumed = 2; return 0x3a5;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x3a9:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x3a9;\n            case 0x301:\n              consumed = 2; return 0x3a9;\n            case 0x313:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x3a9;\n                  case 0x301:\n                    consumed = 3; return 0x3a9;\n                  case 0x342:\n                    consumed = 3; return 0x3a9;\n                }\n              }\n              consumed = 2; return 0x3a9;\n            case 0x314:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x3a9;\n                  case 0x301:\n                    consumed = 3; return 0x3a9;\n                  case 0x342:\n                    consumed = 3; return 0x3a9;\n                }\n              }\n              consumed = 2; return 0x3a9;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x3aa:\n        consumed = 1; return 0x399;\n      case 0x3ab:\n        consumed = 1; return 0x3a5;\n      case 0x3ac:\n        consumed = 1; return 0x3b1;\n      case 0x3ad:\n        consumed = 1; return 0x3b5;\n      case 0x3ae:\n        consumed = 1; return 0x3b7;\n      case 0x3af:\n        consumed = 1; return 0x3b9;\n      case 0x3b0:\n        consumed = 1; return 0x3c5;\n      case 0x3b1:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x3b1;\n            case 0x301:\n              consumed = 2; return 0x3b1;\n            case 0x304:\n              consumed = 2; return 0x3b1;\n            case 0x306:\n              consumed = 2; return 0x3b1;\n            case 0x313:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x3b1;\n                  case 0x301:\n                    consumed = 3; return 0x3b1;\n                  case 0x342:\n                    consumed = 3; return 0x3b1;\n                }\n              }\n              consumed = 2; return 0x3b1;\n            case 0x314:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x3b1;\n                  case 0x301:\n                    consumed = 3; return 0x3b1;\n                  case 0x342:\n                    consumed = 3; return 0x3b1;\n                }\n              }\n              consumed = 2; return 0x3b1;\n            case 0x342:\n              consumed = 2; return 0x3b1;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x3b5:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x3b5;\n            case 0x301:\n              consumed = 2; return 0x3b5;\n            case 0x313:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x3b5;\n                  case 0x301:\n                    consumed = 3; return 0x3b5;\n                }\n              }\n              consumed = 2; return 0x3b5;\n            case 0x314:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x3b5;\n                  case 0x301:\n                    consumed = 3; return 0x3b5;\n                }\n              }\n              consumed = 2; return 0x3b5;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x3b7:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x3b7;\n            case 0x301:\n              consumed = 2; return 0x3b7;\n            case 0x313:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x3b7;\n                  case 0x301:\n                    consumed = 3; return 0x3b7;\n                  case 0x342:\n                    consumed = 3; return 0x3b7;\n                }\n              }\n              consumed = 2; return 0x3b7;\n            case 0x314:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x3b7;\n                  case 0x301:\n                    consumed = 3; return 0x3b7;\n                  case 0x342:\n                    consumed = 3; return 0x3b7;\n                }\n              }\n              consumed = 2; return 0x3b7;\n            case 0x342:\n              consumed = 2; return 0x3b7;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x3b9:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x3b9;\n            case 0x301:\n              consumed = 2; return 0x3b9;\n            case 0x304:\n              consumed = 2; return 0x3b9;\n            case 0x306:\n              consumed = 2; return 0x3b9;\n            case 0x308:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x3b9;\n                  case 0x301:\n                    consumed = 3; return 0x3b9;\n                  case 0x342:\n                    consumed = 3; return 0x3b9;\n                }\n              }\n              consumed = 2; return 0x3b9;\n            case 0x313:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x3b9;\n                  case 0x301:\n                    consumed = 3; return 0x3b9;\n                  case 0x342:\n                    consumed = 3; return 0x3b9;\n                }\n              }\n              consumed = 2; return 0x3b9;\n            case 0x314:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x3b9;\n                  case 0x301:\n                    consumed = 3; return 0x3b9;\n                  case 0x342:\n                    consumed = 3; return 0x3b9;\n                }\n              }\n              consumed = 2; return 0x3b9;\n            case 0x342:\n              consumed = 2; return 0x3b9;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x3bf:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x3bf;\n            case 0x301:\n              consumed = 2; return 0x3bf;\n            case 0x313:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x3bf;\n                  case 0x301:\n                    consumed = 3; return 0x3bf;\n                }\n              }\n              consumed = 2; return 0x3bf;\n            case 0x314:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x3bf;\n                  case 0x301:\n                    consumed = 3; return 0x3bf;\n                }\n              }\n              consumed = 2; return 0x3bf;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x3c1:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x313:\n              consumed = 2; return 0x3c1;\n            case 0x314:\n              consumed = 2; return 0x3c1;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x3c5:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x3c5;\n            case 0x301:\n              consumed = 2; return 0x3c5;\n            case 0x304:\n              consumed = 2; return 0x3c5;\n            case 0x306:\n              consumed = 2; return 0x3c5;\n            case 0x308:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x3c5;\n                  case 0x301:\n                    consumed = 3; return 0x3c5;\n                  case 0x342:\n                    consumed = 3; return 0x3c5;\n                }\n              }\n              consumed = 2; return 0x3c5;\n            case 0x313:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x3c5;\n                  case 0x301:\n                    consumed = 3; return 0x3c5;\n                  case 0x342:\n                    consumed = 3; return 0x3c5;\n                }\n              }\n              consumed = 2; return 0x3c5;\n            case 0x314:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x3c5;\n                  case 0x301:\n                    consumed = 3; return 0x3c5;\n                  case 0x342:\n                    consumed = 3; return 0x3c5;\n                }\n              }\n              consumed = 2; return 0x3c5;\n            case 0x342:\n              consumed = 2; return 0x3c5;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x3c9:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x3c9;\n            case 0x301:\n              consumed = 2; return 0x3c9;\n            case 0x313:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x3c9;\n                  case 0x301:\n                    consumed = 3; return 0x3c9;\n                  case 0x342:\n                    consumed = 3; return 0x3c9;\n                }\n              }\n              consumed = 2; return 0x3c9;\n            case 0x314:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x300:\n                    consumed = 3; return 0x3c9;\n                  case 0x301:\n                    consumed = 3; return 0x3c9;\n                  case 0x342:\n                    consumed = 3; return 0x3c9;\n                }\n              }\n              consumed = 2; return 0x3c9;\n            case 0x342:\n              consumed = 2; return 0x3c9;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x3ca:\n        consumed = 1; return 0x3b9;\n      case 0x3cb:\n        consumed = 1; return 0x3c5;\n      case 0x3cc:\n        consumed = 1; return 0x3bf;\n      case 0x3cd:\n        consumed = 1; return 0x3c5;\n      case 0x3ce:\n        consumed = 1; return 0x3c9;\n      case 0x3d2:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x301:\n              consumed = 2; return 0x3d2;\n            case 0x308:\n              consumed = 2; return 0x3d2;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x400:\n        consumed = 1; return 0x415;\n      case 0x401:\n        consumed = 1; return 0x415;\n      case 0x40d:\n        consumed = 1; return 0x418;\n      case 0x40e:\n        consumed = 1; return 0x423;\n      case 0x410:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x306:\n              consumed = 2; return 0x410;\n            case 0x308:\n              consumed = 2; return 0x410;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x415:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x415;\n            case 0x306:\n              consumed = 2; return 0x415;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x416:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x306:\n              consumed = 2; return 0x416;\n            case 0x308:\n              consumed = 2; return 0x416;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x417:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x308:\n              consumed = 2; return 0x417;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x418:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x418;\n            case 0x304:\n              consumed = 2; return 0x418;\n            case 0x308:\n              consumed = 2; return 0x418;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x41e:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x308:\n              consumed = 2; return 0x41e;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x423:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x304:\n              consumed = 2; return 0x423;\n            case 0x308:\n              consumed = 2; return 0x423;\n            case 0x30b:\n              consumed = 2; return 0x423;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x427:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x308:\n              consumed = 2; return 0x427;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x42b:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x308:\n              consumed = 2; return 0x42b;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x42d:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x308:\n              consumed = 2; return 0x42d;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x430:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x306:\n              consumed = 2; return 0x430;\n            case 0x308:\n              consumed = 2; return 0x430;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x435:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x435;\n            case 0x306:\n              consumed = 2; return 0x435;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x436:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x306:\n              consumed = 2; return 0x436;\n            case 0x308:\n              consumed = 2; return 0x436;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x437:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x308:\n              consumed = 2; return 0x437;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x438:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x300:\n              consumed = 2; return 0x438;\n            case 0x304:\n              consumed = 2; return 0x438;\n            case 0x308:\n              consumed = 2; return 0x438;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x43e:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x308:\n              consumed = 2; return 0x43e;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x443:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x304:\n              consumed = 2; return 0x443;\n            case 0x308:\n              consumed = 2; return 0x443;\n            case 0x30b:\n              consumed = 2; return 0x443;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x447:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x308:\n              consumed = 2; return 0x447;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x44b:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x308:\n              consumed = 2; return 0x44b;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x44d:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x308:\n              consumed = 2; return 0x44d;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x450:\n        consumed = 1; return 0x435;\n      case 0x451:\n        consumed = 1; return 0x435;\n      case 0x45d:\n        consumed = 1; return 0x438;\n      case 0x45e:\n        consumed = 1; return 0x443;\n      case 0x474:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x30f:\n              consumed = 2; return 0x474;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x475:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x30f:\n              consumed = 2; return 0x475;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x476:\n        consumed = 1; return 0x474;\n      case 0x477:\n        consumed = 1; return 0x475;\n      case 0x47c:\n        consumed = 1; return 0x460;\n      case 0x47d:\n        consumed = 1; return 0x461;\n      case 0x48a:\n        consumed = 1; return 0x419;\n      case 0x48b:\n        consumed = 1; return 0x439;\n      case 0x48e:\n        consumed = 1; return 0x420;\n      case 0x48f:\n        consumed = 1; return 0x440;\n      case 0x490:\n        consumed = 1; return 0x413;\n      case 0x491:\n        consumed = 1; return 0x433;\n      case 0x492:\n        consumed = 1; return 0x413;\n      case 0x493:\n        consumed = 1; return 0x433;\n      case 0x494:\n        consumed = 1; return 0x413;\n      case 0x495:\n        consumed = 1; return 0x433;\n      case 0x496:\n        consumed = 1; return 0x416;\n      case 0x497:\n        consumed = 1; return 0x436;\n      case 0x498:\n        consumed = 1; return 0x417;\n      case 0x499:\n        consumed = 1; return 0x437;\n      case 0x49a:\n        consumed = 1; return 0x41a;\n      case 0x49b:\n        consumed = 1; return 0x43a;\n      case 0x49c:\n        consumed = 1; return 0x41a;\n      case 0x49d:\n        consumed = 1; return 0x43a;\n      case 0x49e:\n        consumed = 1; return 0x41a;\n      case 0x49f:\n        consumed = 1; return 0x43a;\n      case 0x4a2:\n        consumed = 1; return 0x41d;\n      case 0x4a3:\n        consumed = 1; return 0x43d;\n      case 0x4a6:\n        consumed = 1; return 0x41f;\n      case 0x4a7:\n        consumed = 1; return 0x43f;\n      case 0x4aa:\n        consumed = 1; return 0x421;\n      case 0x4ab:\n        consumed = 1; return 0x441;\n      case 0x4ac:\n        consumed = 1; return 0x422;\n      case 0x4ad:\n        consumed = 1; return 0x442;\n      case 0x4b0:\n        consumed = 1; return 0x4ae;\n      case 0x4b1:\n        consumed = 1; return 0x4af;\n      case 0x4b2:\n        consumed = 1; return 0x425;\n      case 0x4b3:\n        consumed = 1; return 0x425;\n      case 0x4b6:\n        consumed = 1; return 0x4bc;\n      case 0x4b7:\n        consumed = 1; return 0x4bc;\n      case 0x4b8:\n        consumed = 1; return 0x4bc;\n      case 0x4b9:\n        consumed = 1; return 0x447;\n      case 0x4be:\n        consumed = 1; return 0x4bc;\n      case 0x4bf:\n        consumed = 1; return 0x4bc;\n      case 0x4c1:\n        consumed = 1; return 0x416;\n      case 0x4c2:\n        consumed = 1; return 0x436;\n      case 0x4c3:\n        consumed = 1; return 0x41a;\n      case 0x4c4:\n        consumed = 1; return 0x43a;\n      case 0x4c5:\n        consumed = 1; return 0x41b;\n      case 0x4c6:\n        consumed = 1; return 0x43b;\n      case 0x4c7:\n        consumed = 1; return 0x41d;\n      case 0x4c8:\n        consumed = 1; return 0x43d;\n      case 0x4c9:\n        consumed = 1; return 0x41d;\n      case 0x4ca:\n        consumed = 1; return 0x43d;\n      case 0x4cb:\n        consumed = 1; return 0x4bc;\n      case 0x4cc:\n        consumed = 1; return 0x4bc;\n      case 0x4cd:\n        consumed = 1; return 0x41c;\n      case 0x4ce:\n        consumed = 1; return 0x43c;\n      case 0x4d0:\n        consumed = 1; return 0x410;\n      case 0x4d1:\n        consumed = 1; return 0x430;\n      case 0x4d2:\n        consumed = 1; return 0x410;\n      case 0x4d3:\n        consumed = 1; return 0x430;\n      case 0x4d6:\n        consumed = 1; return 0x415;\n      case 0x4d7:\n        consumed = 1; return 0x435;\n      case 0x4d8:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x308:\n              consumed = 2; return 0x4d8;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x4d9:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x308:\n              consumed = 2; return 0x4d9;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x4da:\n        consumed = 1; return 0x4d8;\n      case 0x4db:\n        consumed = 1; return 0x4d9;\n      case 0x4dc:\n        consumed = 1; return 0x416;\n      case 0x4dd:\n        consumed = 1; return 0x436;\n      case 0x4de:\n        consumed = 1; return 0x417;\n      case 0x4df:\n        consumed = 1; return 0x437;\n      case 0x4e2:\n        consumed = 1; return 0x418;\n      case 0x4e3:\n        consumed = 1; return 0x438;\n      case 0x4e4:\n        consumed = 1; return 0x418;\n      case 0x4e5:\n        consumed = 1; return 0x438;\n      case 0x4e6:\n        consumed = 1; return 0x41e;\n      case 0x4e7:\n        consumed = 1; return 0x43e;\n      case 0x4e8:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x308:\n              consumed = 2; return 0x4e8;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x4e9:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x308:\n              consumed = 2; return 0x4e9;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x4ea:\n        consumed = 1; return 0x4e8;\n      case 0x4eb:\n        consumed = 1; return 0x4e9;\n      case 0x4ec:\n        consumed = 1; return 0x42d;\n      case 0x4ed:\n        consumed = 1; return 0x44d;\n      case 0x4ee:\n        consumed = 1; return 0x423;\n      case 0x4ef:\n        consumed = 1; return 0x443;\n      case 0x4f0:\n        consumed = 1; return 0x423;\n      case 0x4f1:\n        consumed = 1; return 0x443;\n      case 0x4f2:\n        consumed = 1; return 0x423;\n      case 0x4f3:\n        consumed = 1; return 0x443;\n      case 0x4f4:\n        consumed = 1; return 0x427;\n      case 0x4f5:\n        consumed = 1; return 0x447;\n      case 0x4f8:\n        consumed = 1; return 0x42b;\n      case 0x4f9:\n        consumed = 1; return 0x44b;\n      case 0x5d0:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x5b7:\n              consumed = 2; return 0x5d0;\n            case 0x5b8:\n              consumed = 2; return 0x5d0;\n            case 0x5bc:\n              consumed = 2; return 0x5d0;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x5d1:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x5bc:\n              consumed = 2; return 0x5d1;\n            case 0x5bf:\n              consumed = 2; return 0x5d1;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x5d2:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x5bc:\n              consumed = 2; return 0x5d2;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x5d3:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x5bc:\n              consumed = 2; return 0x5d3;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x5d4:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x5bc:\n              consumed = 2; return 0x5d4;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x5d5:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x5b9:\n              consumed = 2; return 0x5d5;\n            case 0x5bc:\n              consumed = 2; return 0x5d5;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x5d6:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x5bc:\n              consumed = 2; return 0x5d6;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x5d8:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x5bc:\n              consumed = 2; return 0x5d8;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x5d9:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x5b4:\n              consumed = 2; return 0x5d9;\n            case 0x5bc:\n              consumed = 2; return 0x5d9;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x5da:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x5bc:\n              consumed = 2; return 0x5da;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x5db:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x5bc:\n              consumed = 2; return 0x5db;\n            case 0x5bf:\n              consumed = 2; return 0x5db;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x5dc:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x5bc:\n              consumed = 2; return 0x5dc;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x5de:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x5bc:\n              consumed = 2; return 0x5de;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x5e0:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x5bc:\n              consumed = 2; return 0x5e0;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x5e1:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x5bc:\n              consumed = 2; return 0x5e1;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x5e3:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x5bc:\n              consumed = 2; return 0x5e3;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x5e4:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x5bc:\n              consumed = 2; return 0x5e4;\n            case 0x5bf:\n              consumed = 2; return 0x5e4;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x5e6:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x5bc:\n              consumed = 2; return 0x5e6;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x5e7:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x5bc:\n              consumed = 2; return 0x5e7;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x5e8:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x5bc:\n              consumed = 2; return 0x5e8;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x5e9:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x5bc:\n              if ( size > 2 )\n              {\n                switch( in[ 2 ] )\n                {\n                  case 0x5c1:\n                    consumed = 3; return 0x5e9;\n                  case 0x5c2:\n                    consumed = 3; return 0x5e9;\n                }\n              }\n              consumed = 2; return 0x5e9;\n            case 0x5c1:\n              consumed = 2; return 0x5e9;\n            case 0x5c2:\n              consumed = 2; return 0x5e9;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x5ea:\n        if ( size > 1 )\n        {\n          switch( in[ 1 ] )\n          {\n            case 0x5bc:\n              consumed = 2; return 0x5ea;\n          }\n        }\n        consumed = 1; return *in;\n      case 0x1e00:\n        consumed = 1; return 0x41;\n      case 0x1e01:\n        consumed = 1; return 0x61;\n      case 0x1e02:\n        consumed = 1; return 0x42;\n      case 0x1e03:\n        consumed = 1; return 0x62;\n      case 0x1e04:\n        consumed = 1; return 0x42;\n      case 0x1e05:\n        consumed = 1; return 0x62;\n      case 0x1e06:\n        consumed = 1; return 0x42;\n      case 0x1e07:\n        consumed = 1; return 0x62;\n      case 0x1e08:\n        consumed = 1; return 0x43;\n      case 0x1e09:\n        consumed = 1; return 0x63;\n      case 0x1e0a:\n        consumed = 1; return 0x44;\n      case 0x1e0b:\n        consumed = 1; return 0x64;\n      case 0x1e0c:\n        consumed = 1; return 0x44;\n      case 0x1e0d:\n        consumed = 1; return 0x64;\n      case 0x1e0e:\n        consumed = 1; return 0x44;\n      case 0x1e0f:\n        consumed = 1; return 0x64;\n      case 0x1e10:\n        consumed = 1; return 0x44;\n      case 0x1e11:\n        consumed = 1; return 0x64;\n      case 0x1e12:\n        consumed = 1; return 0x44;\n      case 0x1e13:\n        consumed = 1; return 0x64;\n      case 0x1e14:\n        consumed = 1; return 0x45;\n      case 0x1e15:\n        consumed = 1; return 0x65;\n      case 0x1e16:\n        consumed = 1; return 0x45;\n      case 0x1e17:\n        consumed = 1; return 0x65;\n      case 0x1e18:\n        consumed = 1; return 0x45;\n      case 0x1e19:\n        consumed = 1; return 0x65;\n      case 0x1e1a:\n        consumed = 1; return 0x45;\n      case 0x1e1b:\n        consumed = 1; return 0x65;\n      case 0x1e1c:\n        consumed = 1; return 0x45;\n      case 0x1e1d:\n        consumed = 1; return 0x65;\n      case 0x1e1e:\n        consumed = 1; return 0x46;\n      case 0x1e1f:\n        consumed = 1; return 0x66;\n      case 0x1e20:\n        consumed = 1; return 0x47;\n      case 0x1e21:\n        consumed = 1; return 0x67;\n      case 0x1e22:\n        consumed = 1; return 0x48;\n      case 0x1e23:\n        consumed = 1; return 0x68;\n      case 0x1e24:\n        consumed = 1; return 0x48;\n      case 0x1e25:\n        consumed = 1; return 0x68;\n      case 0x1e26:\n        consumed = 1; return 0x48;\n      case 0x1e27:\n        consumed = 1; return 0x68;\n      case 0x1e28:\n        consumed = 1; return 0x48;\n      case 0x1e29:\n        consumed = 1; return 0x68;\n      case 0x1e2a:\n        consumed = 1; return 0x48;\n      case 0x1e2b:\n        consumed = 1; return 0x68;\n      case 0x1e2c:\n        consumed = 1; return 0x49;\n      case 0x1e2d:\n        consumed = 1; return 0x69;\n      case 0x1e2e:\n        consumed = 1; return 0x49;\n      case 0x1e2f:\n        consumed = 1; return 0x69;\n      case 0x1e30:\n        consumed = 1; return 0x4b;\n      case 0x1e31:\n        consumed = 1; return 0x6b;\n      case 0x1e32:\n        consumed = 1; return 0x4b;\n      case 0x1e33:\n        consumed = 1; return 0x6b;\n      case 0x1e34:\n        consumed = 1; return 0x4b;\n      case 0x1e35:\n        consumed = 1; return 0x6b;\n      case 0x1e36:\n        consumed = 1; return 0x4c;\n      case 0x1e37:\n        consumed = 1; return 0x6c;\n      case 0x1e38:\n        consumed = 1; return 0x4c;\n      case 0x1e39:\n        consumed = 1; return 0x6c;\n      case 0x1e3a:\n        consumed = 1; return 0x4c;\n      case 0x1e3b:\n        consumed = 1; return 0x6c;\n      case 0x1e3c:\n        consumed = 1; return 0x4c;\n      case 0x1e3d:\n        consumed = 1; return 0x6c;\n      case 0x1e3e:\n        consumed = 1; return 0x4d;\n      case 0x1e3f:\n        consumed = 1; return 0x6d;\n      case 0x1e40:\n        consumed = 1; return 0x4d;\n      case 0x1e41:\n        consumed = 1; return 0x6d;\n      case 0x1e42:\n        consumed = 1; return 0x4d;\n      case 0x1e43:\n        consumed = 1; return 0x6d;\n      case 0x1e44:\n        consumed = 1; return 0x4e;\n      case 0x1e45:\n        consumed = 1; return 0x6e;\n      case 0x1e46:\n        consumed = 1; return 0x4e;\n      case 0x1e47:\n        consumed = 1; return 0x6e;\n      case 0x1e48:\n        consumed = 1; return 0x4e;\n      case 0x1e49:\n        consumed = 1; return 0x6e;\n      case 0x1e4a:\n        consumed = 1; return 0x4e;\n      case 0x1e4b:\n        consumed = 1; return 0x6e;\n      case 0x1e4c:\n        consumed = 1; return 0x4f;\n      case 0x1e4d:\n        consumed = 1; return 0x6f;\n      case 0x1e4e:\n        consumed = 1; return 0x4f;\n      case 0x1e4f:\n        consumed = 1; return 0x6f;\n      case 0x1e50:\n        consumed = 1; return 0x4f;\n      case 0x1e51:\n        consumed = 1; return 0x6f;\n      case 0x1e52:\n        consumed = 1; return 0x4f;\n      case 0x1e53:\n        consumed = 1; return 0x6f;\n      case 0x1e54:\n        consumed = 1; return 0x50;\n      case 0x1e55:\n        consumed = 1; return 0x70;\n      case 0x1e56:\n        consumed = 1; return 0x50;\n      case 0x1e57:\n        consumed = 1; return 0x70;\n      case 0x1e58:\n        consumed = 1; return 0x52;\n      case 0x1e59:\n        consumed = 1; return 0x72;\n      case 0x1e5a:\n        consumed = 1; return 0x52;\n      case 0x1e5b:\n        consumed = 1; return 0x72;\n      case 0x1e5c:\n        consumed = 1; return 0x52;\n      case 0x1e5d:\n        consumed = 1; return 0x72;\n      case 0x1e5e:\n        consumed = 1; return 0x52;\n      case 0x1e5f:\n        consumed = 1; return 0x72;\n      case 0x1e60:\n        consumed = 1; return 0x53;\n      case 0x1e61:\n        consumed = 1; return 0x73;\n      case 0x1e62:\n        consumed = 1; return 0x53;\n      case 0x1e63:\n        consumed = 1; return 0x73;\n      case 0x1e64:\n        consumed = 1; return 0x53;\n      case 0x1e65:\n        consumed = 1; return 0x73;\n      case 0x1e66:\n        consumed = 1; return 0x53;\n      case 0x1e67:\n        consumed = 1; return 0x73;\n      case 0x1e68:\n        consumed = 1; return 0x53;\n      case 0x1e69:\n        consumed = 1; return 0x73;\n      case 0x1e6a:\n        consumed = 1; return 0x54;\n      case 0x1e6b:\n        consumed = 1; return 0x74;\n      case 0x1e6c:\n        consumed = 1; return 0x54;\n      case 0x1e6d:\n        consumed = 1; return 0x74;\n      case 0x1e6e:\n        consumed = 1; return 0x54;\n      case 0x1e6f:\n        consumed = 1; return 0x74;\n      case 0x1e70:\n        consumed = 1; return 0x54;\n      case 0x1e71:\n        consumed = 1; return 0x74;\n      case 0x1e72:\n        consumed = 1; return 0x55;\n      case 0x1e73:\n        consumed = 1; return 0x75;\n      case 0x1e74:\n        consumed = 1; return 0x55;\n      case 0x1e75:\n        consumed = 1; return 0x75;\n      case 0x1e76:\n        consumed = 1; return 0x55;\n      case 0x1e77:\n        consumed = 1; return 0x75;\n      case 0x1e78:\n        consumed = 1; return 0x55;\n      case 0x1e79:\n        consumed = 1; return 0x75;\n      case 0x1e7a:\n        consumed = 1; return 0x55;\n      case 0x1e7b:\n        consumed = 1; return 0x75;\n      case 0x1e7c:\n        consumed = 1; return 0x56;\n      case 0x1e7d:\n        consumed = 1; return 0x76;\n      case 0x1e7e:\n        consumed = 1; return 0x56;\n      case 0x1e7f:\n        consumed = 1; return 0x76;\n      case 0x1e80:\n        consumed = 1; return 0x57;\n      case 0x1e81:\n        consumed = 1; return 0x77;\n      case 0x1e82:\n        consumed = 1; return 0x57;\n      case 0x1e83:\n        consumed = 1; return 0x77;\n      case 0x1e84:\n        consumed = 1; return 0x57;\n      case 0x1e85:\n        consumed = 1; return 0x77;\n      case 0x1e86:\n        consumed = 1; return 0x57;\n      case 0x1e87:\n        consumed = 1; return 0x77;\n      case 0x1e88:\n        consumed = 1; return 0x57;\n      case 0x1e89:\n        consumed = 1; return 0x77;\n      case 0x1e8a:\n        consumed = 1; return 0x58;\n      case 0x1e8b:\n        consumed = 1; return 0x78;\n      case 0x1e8c:\n        consumed = 1; return 0x58;\n      case 0x1e8d:\n        consumed = 1; return 0x78;\n      case 0x1e8e:\n        consumed = 1; return 0x59;\n      case 0x1e8f:\n        consumed = 1; return 0x79;\n      case 0x1e90:\n        consumed = 1; return 0x5a;\n      case 0x1e91:\n        consumed = 1; return 0x7a;\n      case 0x1e92:\n        consumed = 1; return 0x5a;\n      case 0x1e93:\n        consumed = 1; return 0x7a;\n      case 0x1e94:\n        consumed = 1; return 0x5a;\n      case 0x1e95:\n        consumed = 1; return 0x7a;\n      case 0x1e96:\n        consumed = 1; return 0x68;\n      case 0x1e97:\n        consumed = 1; return 0x74;\n      case 0x1e98:\n        consumed = 1; return 0x77;\n      case 0x1e99:\n        consumed = 1; return 0x79;\n      case 0x1e9a:\n        consumed = 1; return 0x61;\n      case 0x1e9b:\n        consumed = 1; return 0x17f;\n      case 0x1ea0:\n        consumed = 1; return 0x41;\n      case 0x1ea1:\n        consumed = 1; return 0x61;\n      case 0x1ea2:\n        consumed = 1; return 0x41;\n      case 0x1ea3:\n        consumed = 1; return 0x61;\n      case 0x1ea4:\n        consumed = 1; return 0x41;\n      case 0x1ea5:\n        consumed = 1; return 0x61;\n      case 0x1ea6:\n        consumed = 1; return 0x41;\n      case 0x1ea7:\n        consumed = 1; return 0x61;\n      case 0x1ea8:\n        consumed = 1; return 0x41;\n      case 0x1ea9:\n        consumed = 1; return 0x61;\n      case 0x1eaa:\n        consumed = 1; return 0x41;\n      case 0x1eab:\n        consumed = 1; return 0x61;\n      case 0x1eac:\n        consumed = 1; return 0x41;\n      case 0x1ead:\n        consumed = 1; return 0x61;\n      case 0x1eae:\n        consumed = 1; return 0x41;\n      case 0x1eaf:\n        consumed = 1; return 0x61;\n      case 0x1eb0:\n        consumed = 1; return 0x41;\n      case 0x1eb1:\n        consumed = 1; return 0x61;\n      case 0x1eb2:\n        consumed = 1; return 0x41;\n      case 0x1eb3:\n        consumed = 1; return 0x61;\n      case 0x1eb4:\n        consumed = 1; return 0x41;\n      case 0x1eb5:\n        consumed = 1; return 0x61;\n      case 0x1eb6:\n        consumed = 1; return 0x41;\n      case 0x1eb7:\n        consumed = 1; return 0x61;\n      case 0x1eb8:\n        consumed = 1; return 0x45;\n      case 0x1eb9:\n        consumed = 1; return 0x65;\n      case 0x1eba:\n        consumed = 1; return 0x45;\n      case 0x1ebb:\n        consumed = 1; return 0x65;\n      case 0x1ebc:\n        consumed = 1; return 0x45;\n      case 0x1ebd:\n        consumed = 1; return 0x65;\n      case 0x1ebe:\n        consumed = 1; return 0x45;\n      case 0x1ebf:\n        consumed = 1; return 0x65;\n      case 0x1ec0:\n        consumed = 1; return 0x45;\n      case 0x1ec1:\n        consumed = 1; return 0x65;\n      case 0x1ec2:\n        consumed = 1; return 0x45;\n      case 0x1ec3:\n        consumed = 1; return 0x65;\n      case 0x1ec4:\n        consumed = 1; return 0x45;\n      case 0x1ec5:\n        consumed = 1; return 0x65;\n      case 0x1ec6:\n        consumed = 1; return 0x45;\n      case 0x1ec7:\n        consumed = 1; return 0x65;\n      case 0x1ec8:\n        consumed = 1; return 0x49;\n      case 0x1ec9:\n        consumed = 1; return 0x69;\n      case 0x1eca:\n        consumed = 1; return 0x49;\n      case 0x1ecb:\n        consumed = 1; return 0x69;\n      case 0x1ecc:\n        consumed = 1; return 0x4f;\n      case 0x1ecd:\n        consumed = 1; return 0x6f;\n      case 0x1ece:\n        consumed = 1; return 0x4f;\n      case 0x1ecf:\n        consumed = 1; return 0x6f;\n      case 0x1ed0:\n        consumed = 1; return 0x4f;\n      case 0x1ed1:\n        consumed = 1; return 0x6f;\n      case 0x1ed2:\n        consumed = 1; return 0x4f;\n      case 0x1ed3:\n        consumed = 1; return 0x6f;\n      case 0x1ed4:\n        consumed = 1; return 0x4f;\n      case 0x1ed5:\n        consumed = 1; return 0x6f;\n      case 0x1ed6:\n        consumed = 1; return 0x4f;\n      case 0x1ed7:\n        consumed = 1; return 0x6f;\n      case 0x1ed8:\n        consumed = 1; return 0x4f;\n      case 0x1ed9:\n        consumed = 1; return 0x6f;\n      case 0x1eda:\n        consumed = 1; return 0x4f;\n      case 0x1edb:\n        consumed = 1; return 0x6f;\n      case 0x1edc:\n        consumed = 1; return 0x4f;\n      case 0x1edd:\n        consumed = 1; return 0x6f;\n      case 0x1ede:\n        consumed = 1; return 0x4f;\n      case 0x1edf:\n        consumed = 1; return 0x6f;\n      case 0x1ee0:\n        consumed = 1; return 0x4f;\n      case 0x1ee1:\n        consumed = 1; return 0x6f;\n      case 0x1ee2:\n        consumed = 1; return 0x4f;\n      case 0x1ee3:\n        consumed = 1; return 0x6f;\n      case 0x1ee4:\n        consumed = 1; return 0x55;\n      case 0x1ee5:\n        consumed = 1; return 0x75;\n      case 0x1ee6:\n        consumed = 1; return 0x55;\n      case 0x1ee7:\n        consumed = 1; return 0x75;\n      case 0x1ee8:\n        consumed = 1; return 0x55;\n      case 0x1ee9:\n        consumed = 1; return 0x75;\n      case 0x1eea:\n        consumed = 1; return 0x55;\n      case 0x1eeb:\n        consumed = 1; return 0x75;\n      case 0x1eec:\n        consumed = 1; return 0x55;\n      case 0x1eed:\n        consumed = 1; return 0x75;\n      case 0x1eee:\n        consumed = 1; return 0x55;\n      case 0x1eef:\n        consumed = 1; return 0x75;\n      case 0x1ef0:\n        consumed = 1; return 0x55;\n      case 0x1ef1:\n        consumed = 1; return 0x75;\n      case 0x1ef2:\n        consumed = 1; return 0x59;\n      case 0x1ef3:\n        consumed = 1; return 0x79;\n      case 0x1ef4:\n        consumed = 1; return 0x59;\n      case 0x1ef5:\n        consumed = 1; return 0x79;\n      case 0x1ef6:\n        consumed = 1; return 0x59;\n      case 0x1ef7:\n        consumed = 1; return 0x79;\n      case 0x1ef8:\n        consumed = 1; return 0x59;\n      case 0x1ef9:\n        consumed = 1; return 0x79;\n      case 0x1f00:\n        consumed = 1; return 0x3b1;\n      case 0x1f01:\n        consumed = 1; return 0x3b1;\n      case 0x1f02:\n        consumed = 1; return 0x3b1;\n      case 0x1f03:\n        consumed = 1; return 0x3b1;\n      case 0x1f04:\n        consumed = 1; return 0x3b1;\n      case 0x1f05:\n        consumed = 1; return 0x3b1;\n      case 0x1f06:\n        consumed = 1; return 0x3b1;\n      case 0x1f07:\n        consumed = 1; return 0x3b1;\n      case 0x1f08:\n        consumed = 1; return 0x391;\n      case 0x1f09:\n        consumed = 1; return 0x391;\n      case 0x1f0a:\n        consumed = 1; return 0x391;\n      case 0x1f0b:\n        consumed = 1; return 0x391;\n      case 0x1f0c:\n        consumed = 1; return 0x391;\n      case 0x1f0d:\n        consumed = 1; return 0x391;\n      case 0x1f0e:\n        consumed = 1; return 0x391;\n      case 0x1f0f:\n        consumed = 1; return 0x391;\n      case 0x1f10:\n        consumed = 1; return 0x3b5;\n      case 0x1f11:\n        consumed = 1; return 0x3b5;\n      case 0x1f12:\n        consumed = 1; return 0x3b5;\n      case 0x1f13:\n        consumed = 1; return 0x3b5;\n      case 0x1f14:\n        consumed = 1; return 0x3b5;\n      case 0x1f15:\n        consumed = 1; return 0x3b5;\n      case 0x1f18:\n        consumed = 1; return 0x395;\n      case 0x1f19:\n        consumed = 1; return 0x395;\n      case 0x1f1a:\n        consumed = 1; return 0x395;\n      case 0x1f1b:\n        consumed = 1; return 0x395;\n      case 0x1f1c:\n        consumed = 1; return 0x395;\n      case 0x1f1d:\n        consumed = 1; return 0x395;\n      case 0x1f20:\n        consumed = 1; return 0x3b7;\n      case 0x1f21:\n        consumed = 1; return 0x3b7;\n      case 0x1f22:\n        consumed = 1; return 0x3b7;\n      case 0x1f23:\n        consumed = 1; return 0x3b7;\n      case 0x1f24:\n        consumed = 1; return 0x3b7;\n      case 0x1f25:\n        consumed = 1; return 0x3b7;\n      case 0x1f26:\n        consumed = 1; return 0x3b7;\n      case 0x1f27:\n        consumed = 1; return 0x3b7;\n      case 0x1f28:\n        consumed = 1; return 0x397;\n      case 0x1f29:\n        consumed = 1; return 0x397;\n      case 0x1f2a:\n        consumed = 1; return 0x397;\n      case 0x1f2b:\n        consumed = 1; return 0x397;\n      case 0x1f2c:\n        consumed = 1; return 0x397;\n      case 0x1f2d:\n        consumed = 1; return 0x397;\n      case 0x1f2e:\n        consumed = 1; return 0x397;\n      case 0x1f2f:\n        consumed = 1; return 0x397;\n      case 0x1f30:\n        consumed = 1; return 0x3b9;\n      case 0x1f31:\n        consumed = 1; return 0x3b9;\n      case 0x1f32:\n        consumed = 1; return 0x3b9;\n      case 0x1f33:\n        consumed = 1; return 0x3b9;\n      case 0x1f34:\n        consumed = 1; return 0x3b9;\n      case 0x1f35:\n        consumed = 1; return 0x3b9;\n      case 0x1f36:\n        consumed = 1; return 0x3b9;\n      case 0x1f37:\n        consumed = 1; return 0x3b9;\n      case 0x1f38:\n        consumed = 1; return 0x399;\n      case 0x1f39:\n        consumed = 1; return 0x399;\n      case 0x1f3a:\n        consumed = 1; return 0x399;\n      case 0x1f3b:\n        consumed = 1; return 0x399;\n      case 0x1f3c:\n        consumed = 1; return 0x399;\n      case 0x1f3d:\n        consumed = 1; return 0x399;\n      case 0x1f3e:\n        consumed = 1; return 0x399;\n      case 0x1f3f:\n        consumed = 1; return 0x399;\n      case 0x1f40:\n        consumed = 1; return 0x3bf;\n      case 0x1f41:\n        consumed = 1; return 0x3bf;\n      case 0x1f42:\n        consumed = 1; return 0x3bf;\n      case 0x1f43:\n        consumed = 1; return 0x3bf;\n      case 0x1f44:\n        consumed = 1; return 0x3bf;\n      case 0x1f45:\n        consumed = 1; return 0x3bf;\n      case 0x1f48:\n        consumed = 1; return 0x39f;\n      case 0x1f49:\n        consumed = 1; return 0x39f;\n      case 0x1f4a:\n        consumed = 1; return 0x39f;\n      case 0x1f4b:\n        consumed = 1; return 0x39f;\n      case 0x1f4c:\n        consumed = 1; return 0x39f;\n      case 0x1f4d:\n        consumed = 1; return 0x39f;\n      case 0x1f50:\n        consumed = 1; return 0x3c5;\n      case 0x1f51:\n        consumed = 1; return 0x3c5;\n      case 0x1f52:\n        consumed = 1; return 0x3c5;\n      case 0x1f53:\n        consumed = 1; return 0x3c5;\n      case 0x1f54:\n        consumed = 1; return 0x3c5;\n      case 0x1f55:\n        consumed = 1; return 0x3c5;\n      case 0x1f56:\n        consumed = 1; return 0x3c5;\n      case 0x1f57:\n        consumed = 1; return 0x3c5;\n      case 0x1f59:\n        consumed = 1; return 0x3a5;\n      case 0x1f5b:\n        consumed = 1; return 0x3a5;\n      case 0x1f5d:\n        consumed = 1; return 0x3a5;\n      case 0x1f5f:\n        consumed = 1; return 0x3a5;\n      case 0x1f60:\n        consumed = 1; return 0x3c9;\n      case 0x1f61:\n        consumed = 1; return 0x3c9;\n      case 0x1f62:\n        consumed = 1; return 0x3c9;\n      case 0x1f63:\n        consumed = 1; return 0x3c9;\n      case 0x1f64:\n        consumed = 1; return 0x3c9;\n      case 0x1f65:\n        consumed = 1; return 0x3c9;\n      case 0x1f66:\n        consumed = 1; return 0x3c9;\n      case 0x1f67:\n        consumed = 1; return 0x3c9;\n      case 0x1f68:\n        consumed = 1; return 0x3a9;\n      case 0x1f69:\n        consumed = 1; return 0x3a9;\n      case 0x1f6a:\n        consumed = 1; return 0x3a9;\n      case 0x1f6b:\n        consumed = 1; return 0x3a9;\n      case 0x1f6c:\n        consumed = 1; return 0x3a9;\n      case 0x1f6d:\n        consumed = 1; return 0x3a9;\n      case 0x1f6e:\n        consumed = 1; return 0x3a9;\n      case 0x1f6f:\n        consumed = 1; return 0x3a9;\n      case 0x1f70:\n        consumed = 1; return 0x3b1;\n      case 0x1f71:\n        consumed = 1; return 0x3b1;\n      case 0x1f72:\n        consumed = 1; return 0x3b5;\n      case 0x1f73:\n        consumed = 1; return 0x3b5;\n      case 0x1f74:\n        consumed = 1; return 0x3b7;\n      case 0x1f75:\n        consumed = 1; return 0x3b7;\n      case 0x1f76:\n        consumed = 1; return 0x3b9;\n      case 0x1f77:\n        consumed = 1; return 0x3b9;\n      case 0x1f78:\n        consumed = 1; return 0x3bf;\n      case 0x1f79:\n        consumed = 1; return 0x3bf;\n      case 0x1f7a:\n        consumed = 1; return 0x3c5;\n      case 0x1f7b:\n        consumed = 1; return 0x3c5;\n      case 0x1f7c:\n        consumed = 1; return 0x3c9;\n      case 0x1f7d:\n        consumed = 1; return 0x3c9;\n      case 0x1f80:\n        consumed = 1; return 0x3b1;\n      case 0x1f81:\n        consumed = 1; return 0x3b1;\n      case 0x1f82:\n        consumed = 1; return 0x3b1;\n      case 0x1f83:\n        consumed = 1; return 0x3b1;\n      case 0x1f84:\n        consumed = 1; return 0x3b1;\n      case 0x1f85:\n        consumed = 1; return 0x3b1;\n      case 0x1f86:\n        consumed = 1; return 0x3b1;\n      case 0x1f87:\n        consumed = 1; return 0x3b1;\n      case 0x1f88:\n        consumed = 1; return 0x391;\n      case 0x1f89:\n        consumed = 1; return 0x391;\n      case 0x1f8a:\n        consumed = 1; return 0x391;\n      case 0x1f8b:\n        consumed = 1; return 0x391;\n      case 0x1f8c:\n        consumed = 1; return 0x391;\n      case 0x1f8d:\n        consumed = 1; return 0x391;\n      case 0x1f8e:\n        consumed = 1; return 0x391;\n      case 0x1f8f:\n        consumed = 1; return 0x391;\n      case 0x1f90:\n        consumed = 1; return 0x3b7;\n      case 0x1f91:\n        consumed = 1; return 0x3b7;\n      case 0x1f92:\n        consumed = 1; return 0x3b7;\n      case 0x1f93:\n        consumed = 1; return 0x3b7;\n      case 0x1f94:\n        consumed = 1; return 0x3b7;\n      case 0x1f95:\n        consumed = 1; return 0x3b7;\n      case 0x1f96:\n        consumed = 1; return 0x3b7;\n      case 0x1f97:\n        consumed = 1; return 0x3b7;\n      case 0x1f98:\n        consumed = 1; return 0x397;\n      case 0x1f99:\n        consumed = 1; return 0x397;\n      case 0x1f9a:\n        consumed = 1; return 0x397;\n      case 0x1f9b:\n        consumed = 1; return 0x397;\n      case 0x1f9c:\n        consumed = 1; return 0x397;\n      case 0x1f9d:\n        consumed = 1; return 0x397;\n      case 0x1f9e:\n        consumed = 1; return 0x397;\n      case 0x1f9f:\n        consumed = 1; return 0x397;\n      case 0x1fa0:\n        consumed = 1; return 0x3c9;\n      case 0x1fa1:\n        consumed = 1; return 0x3c9;\n      case 0x1fa2:\n        consumed = 1; return 0x3c9;\n      case 0x1fa3:\n        consumed = 1; return 0x3c9;\n      case 0x1fa4:\n        consumed = 1; return 0x3c9;\n      case 0x1fa5:\n        consumed = 1; return 0x3c9;\n      case 0x1fa6:\n        consumed = 1; return 0x3c9;\n      case 0x1fa7:\n        consumed = 1; return 0x3c9;\n      case 0x1fa8:\n        consumed = 1; return 0x3a9;\n      case 0x1fa9:\n        consumed = 1; return 0x3a9;\n      case 0x1faa:\n        consumed = 1; return 0x3a9;\n      case 0x1fab:\n        consumed = 1; return 0x3a9;\n      case 0x1fac:\n        consumed = 1; return 0x3a9;\n      case 0x1fad:\n        consumed = 1; return 0x3a9;\n      case 0x1fae:\n        consumed = 1; return 0x3a9;\n      case 0x1faf:\n        consumed = 1; return 0x3a9;\n      case 0x1fb0:\n        consumed = 1; return 0x3b1;\n      case 0x1fb1:\n        consumed = 1; return 0x3b1;\n      case 0x1fb2:\n        consumed = 1; return 0x3b1;\n      case 0x1fb3:\n        consumed = 1; return 0x3b1;\n      case 0x1fb4:\n        consumed = 1; return 0x3b1;\n      case 0x1fb6:\n        consumed = 1; return 0x3b1;\n      case 0x1fb7:\n        consumed = 1; return 0x3b1;\n      case 0x1fb8:\n        consumed = 1; return 0x391;\n      case 0x1fb9:\n        consumed = 1; return 0x391;\n      case 0x1fba:\n        consumed = 1; return 0x391;\n      case 0x1fbb:\n        consumed = 1; return 0x391;\n      case 0x1fbc:\n        consumed = 1; return 0x391;\n      case 0x1fc2:\n        consumed = 1; return 0x3b7;\n      case 0x1fc3:\n        consumed = 1; return 0x3b7;\n      case 0x1fc4:\n        consumed = 1; return 0x3b7;\n      case 0x1fc6:\n        consumed = 1; return 0x3b7;\n      case 0x1fc7:\n        consumed = 1; return 0x3b7;\n      case 0x1fc8:\n        consumed = 1; return 0x395;\n      case 0x1fc9:\n        consumed = 1; return 0x395;\n      case 0x1fca:\n        consumed = 1; return 0x397;\n      case 0x1fcb:\n        consumed = 1; return 0x397;\n      case 0x1fcc:\n        consumed = 1; return 0x397;\n      case 0x1fd0:\n        consumed = 1; return 0x3b9;\n      case 0x1fd1:\n        consumed = 1; return 0x3b9;\n      case 0x1fd2:\n        consumed = 1; return 0x3b9;\n      case 0x1fd3:\n        consumed = 1; return 0x3b9;\n      case 0x1fd6:\n        consumed = 1; return 0x3b9;\n      case 0x1fd7:\n        consumed = 1; return 0x3b9;\n      case 0x1fd8:\n        consumed = 1; return 0x399;\n      case 0x1fd9:\n        consumed = 1; return 0x399;\n      case 0x1fda:\n        consumed = 1; return 0x399;\n      case 0x1fdb:\n        consumed = 1; return 0x399;\n      case 0x1fe0:\n        consumed = 1; return 0x3c5;\n      case 0x1fe1:\n        consumed = 1; return 0x3c5;\n      case 0x1fe2:\n        consumed = 1; return 0x3c5;\n      case 0x1fe3:\n        consumed = 1; return 0x3c5;\n      case 0x1fe4:\n        consumed = 1; return 0x3c1;\n      case 0x1fe5:\n        consumed = 1; return 0x3c1;\n      case 0x1fe6:\n        consumed = 1; return 0x3c5;\n      case 0x1fe7:\n        consumed = 1; return 0x3c5;\n      case 0x1fe8:\n        consumed = 1; return 0x3a5;\n      case 0x1fe9:\n        consumed = 1; return 0x3a5;\n      case 0x1fea:\n        consumed = 1; return 0x3a5;\n      case 0x1feb:\n        consumed = 1; return 0x3a5;\n      case 0x1fec:\n        consumed = 1; return 0x3a1;\n      case 0x1ff2:\n        consumed = 1; return 0x3c9;\n      case 0x1ff3:\n        consumed = 1; return 0x3c9;\n      case 0x1ff4:\n        consumed = 1; return 0x3c9;\n      case 0x1ff6:\n        consumed = 1; return 0x3c9;\n      case 0x1ff7:\n        consumed = 1; return 0x3c9;\n      case 0x1ff8:\n        consumed = 1; return 0x39f;\n      case 0x1ff9:\n        consumed = 1; return 0x39f;\n      case 0x1ffa:\n        consumed = 1; return 0x3a9;\n      case 0x1ffb:\n        consumed = 1; return 0x3a9;\n      case 0x1ffc:\n        consumed = 1; return 0x3a9;\n      case 0xfb1d:\n        consumed = 1; return 0x5d9;\n      case 0xfb2a:\n        consumed = 1; return 0x5e9;\n      case 0xfb2b:\n        consumed = 1; return 0x5e9;\n      case 0xfb2c:\n        consumed = 1; return 0x5e9;\n      case 0xfb2d:\n        consumed = 1; return 0x5e9;\n      case 0xfb2e:\n        consumed = 1; return 0x5d0;\n      case 0xfb2f:\n        consumed = 1; return 0x5d0;\n      case 0xfb30:\n        consumed = 1; return 0x5d0;\n      case 0xfb31:\n        consumed = 1; return 0x5d1;\n      case 0xfb32:\n        consumed = 1; return 0x5d2;\n      case 0xfb33:\n        consumed = 1; return 0x5d3;\n      case 0xfb34:\n        consumed = 1; return 0x5d4;\n      case 0xfb35:\n        consumed = 1; return 0x5d5;\n      case 0xfb36:\n        consumed = 1; return 0x5d6;\n      case 0xfb38:\n        consumed = 1; return 0x5d8;\n      case 0xfb39:\n        consumed = 1; return 0x5d9;\n      case 0xfb3a:\n        consumed = 1; return 0x5da;\n      case 0xfb3b:\n        consumed = 1; return 0x5db;\n      case 0xfb3c:\n        consumed = 1; return 0x5dc;\n      case 0xfb3e:\n        consumed = 1; return 0x5de;\n      case 0xfb40:\n        consumed = 1; return 0x5e0;\n      case 0xfb41:\n        consumed = 1; return 0x5e1;\n      case 0xfb43:\n        consumed = 1; return 0x5e3;\n      case 0xfb44:\n        consumed = 1; return 0x5e4;\n      case 0xfb46:\n        consumed = 1; return 0x5e6;\n      case 0xfb47:\n        consumed = 1; return 0x5e7;\n      case 0xfb48:\n        consumed = 1; return 0x5e8;\n      case 0xfb49:\n        consumed = 1; return 0x5e9;\n      case 0xfb4a:\n        consumed = 1; return 0x5ea;\n      case 0xfb4b:\n        consumed = 1; return 0x5d5;\n      case 0xfb4c:\n        consumed = 1; return 0x5d1;\n      case 0xfb4d:\n        consumed = 1; return 0x5db;\n      case 0xfb4e:\n        consumed = 1; return 0x5e4;\n    }\n  }\n  if ( size )\n  {\n    consumed = 1; return *in;\n  }\n  consumed = 0; return 0;\n}\n"
        },
        {
          "name": "indexedzip.cc",
          "type": "blob",
          "size": 6.6669921875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"indexedzip.hh\"\n#include \"zipfile.hh\"\n#include <zlib.h>\n#include \"gddebug.hh\"\n#include \"utf8.hh\"\n#include \"iconv.hh\"\n#include \"wstring_qt.hh\"\n\n#include <QDebug>\n\nusing namespace BtreeIndexing;\nusing std::vector;\n\nbool IndexedZip::openZipFile( QString const & name )\n{\n  zip.setFileName( name );\n\n  zipIsOpen = zip.open( QFile::ReadOnly );\n\n  return zipIsOpen;\n}\n\nbool IndexedZip::hasFile( gd::wstring const & name )\n{\n  if ( !zipIsOpen )\n    return false;\n\n  vector< WordArticleLink > links = findArticles( name );\n\n  return !links.empty();\n}\n\nbool IndexedZip::loadFile( gd::wstring const & name, vector< char > & data )\n{\n  if ( !zipIsOpen )\n    return false;\n\n  vector< WordArticleLink > links = findArticles( name );\n\n  if ( links.empty() )\n    return false;\n\n  return loadFile( links[ 0 ].articleOffset, data );\n}\n\nbool IndexedZip::loadFile( uint32_t offset, vector< char > & data )\n{\n  if ( !zipIsOpen )\n    return false;\n\n  // Now seek into the zip file and read its header\n\n  if ( !zip.seek( offset ) )\n    return false;\n\n  ZipFile::LocalFileHeader header;\n\n  if ( !ZipFile::readLocalHeader( zip, header ) )\n  {\n    GD_DPRINTF( \"Failed to load header\\n\" );\n    return false;\n  }\n\n  // Which algorithm was used?\n\n  switch( header.compressionMethod )\n  {\n    case ZipFile::Uncompressed:\n      GD_DPRINTF( \"Uncompressed\\n\" );\n      data.resize( header.uncompressedSize );\n      return (size_t) zip.read( &data.front(), data.size() ) == data.size();\n\n    case ZipFile::Deflated:\n    {\n      GD_DPRINTF( \"Deflated\\n\" );\n\n      // Now do the deflation\n\n      QByteArray compressedData = zip.read( header.compressedSize );\n\n      if ( compressedData.size() != (int)header.compressedSize )\n        return false;\n\n      data.resize( header.uncompressedSize );\n\n      z_stream stream;\n\n      memset( &stream, 0, sizeof( stream ) );\n\n      stream.next_in = ( Bytef * ) compressedData.data();\n      stream.avail_in = compressedData.size();\n      stream.next_out = ( Bytef * ) &data.front();\n      stream.avail_out = data.size();\n\n      if ( inflateInit2( &stream, -MAX_WBITS ) != Z_OK )\n      {\n        data.clear();        \n        return false;\n      }\n\n      if ( inflate( &stream, Z_FINISH ) != Z_STREAM_END )\n      {\n        GD_DPRINTF( \"Not zstream end!\" );\n\n        data.clear();\n\n        inflateEnd( &stream );\n\n        return false;\n      }\n\n      inflateEnd( &stream );\n\n      return true;\n    }\n\n    default:\n\n      return false;\n  }\n}\n\nbool IndexedZip::indexFile( BtreeIndexing::IndexedWords &zipFileNames, quint32 * filesCount )\n{\n    if ( !zipIsOpen )\n        return false;\n    if ( !ZipFile::positionAtCentralDir( zip ) )\n        return false;\n\n    // File seems to be a valid zip file\n\n\n    QTextCodec * const localeCodec = gdCodecForLocale();\n\n    ZipFile::CentralDirEntry entry;\n\n    bool alreadyCounted;\n    if( filesCount )\n      *filesCount = 0;\n\n    while( ZipFile::readNextEntry( zip, entry ) )\n    {\n      if ( entry.compressionMethod == ZipFile::Unsupported )\n      {\n        qWarning( \"Zip warning: compression method unsupported -- skipping file \\\"%s\\\"\\n\",\n                  entry.fileName.data() );\n        continue;\n      }\n\n      // Check if the file name has some non-ascii letters.\n\n      unsigned char const * ptr = ( unsigned char const * )\n                                    entry.fileName.constData();\n\n      bool hasNonAscii = false;\n\n      for( ; ; )\n      {\n        if ( *ptr & 0x80 )\n        {\n          hasNonAscii = true;\n          break;\n        }\n        else\n        if ( !*ptr++ )\n          break;\n      }\n\n      alreadyCounted = false;\n\n      if ( !hasNonAscii )\n      {\n        // Add entry as is\n\n        zipFileNames.addSingleWord( Utf8::decode( entry.fileName.data() ),\n                                    entry.localHeaderOffset );\n        if( filesCount )\n          *filesCount += 1;\n      }\n      else\n      {\n        // Try assuming different encodings. Those are UTF8, system locale and two\n        // Russian ones (Windows and Windows OEM). Unfortunately, zip\n        // files do not say which encoding they utilize.\n\n        // Utf8\n        try\n        {\n          wstring decoded = Utf8::decode( entry.fileName.constData() );\n\n          zipFileNames.addSingleWord( decoded,\n                                      entry.localHeaderOffset );\n          if( filesCount != 0 && !alreadyCounted )\n          {\n            *filesCount += 1;\n            alreadyCounted = true;\n          }\n        }\n        catch( Utf8::exCantDecode & )\n        {\n          // Failed to decode\n        }\n\n        if( !entry.fileNameInUTF8 )\n        {\n          wstring nameInSystemLocale;\n\n          // System locale\n          if( localeCodec )\n          {\n            QString name = localeCodec->toUnicode( entry.fileName.constData(),\n                                                   entry.fileName.size() );\n            nameInSystemLocale = gd::toWString( name );\n            if( !nameInSystemLocale.empty() )\n            {\n              zipFileNames.addSingleWord( nameInSystemLocale,\n                                          entry.localHeaderOffset );\n\n              if( filesCount != 0 && !alreadyCounted )\n              {\n                *filesCount += 1;\n                alreadyCounted = true;\n              }\n            }\n          }\n\n\n          // CP866\n          try\n          {\n            wstring decoded = Iconv::toWstring( \"CP866\", entry.fileName.constData(),\n                                                entry.fileName.size() );\n\n            if( nameInSystemLocale.compare( decoded ) != 0 )\n            {\n              zipFileNames.addSingleWord( decoded,\n                                          entry.localHeaderOffset );\n\n              if( filesCount != 0 && !alreadyCounted )\n              {\n                *filesCount += 1;\n                alreadyCounted = true;\n              }\n            }\n          }\n          catch( Iconv::Ex & )\n          {\n              // Failed to decode\n          }\n\n          // CP1251\n          try\n          {\n            wstring decoded = Iconv::toWstring( \"CP1251\", entry.fileName.constData(),\n                                                entry.fileName.size() );\n\n            if( nameInSystemLocale.compare( decoded ) != 0 )\n            {\n              zipFileNames.addSingleWord( decoded,\n                                          entry.localHeaderOffset );\n\n              if( filesCount != 0 && !alreadyCounted )\n              {\n                *filesCount += 1;\n                alreadyCounted = true;\n              }\n            }\n          }\n          catch( Iconv::Ex & )\n          {\n            // Failed to decode\n          }\n        }\n      }\n    }\n    return true;\n}\n"
        },
        {
          "name": "indexedzip.hh",
          "type": "blob",
          "size": 1.4501953125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __INDEXEDZIP_HH_INCLUDED__\n#define __INDEXEDZIP_HH_INCLUDED__\n\n#include \"btreeidx.hh\"\n#include <QFile>\n#include \"zipfile.hh\"\n\n/// Allows using a btree index to read zip files. Basically built on top of\n/// the base dictionary infrastructure adapted for zips.\nclass IndexedZip: public BtreeIndexing::BtreeIndex\n{\n  ZipFile::SplitZipFile zip;\n  bool zipIsOpen;\n\npublic:\n\n  IndexedZip(): zipIsOpen( false )\n  {}\n\n  /// Opens the index. The values are those previously returned by buildIndex().\n  using BtreeIndexing::BtreeIndex::openIndex;\n\n  /// Opens the zip file itself. Returns true if succeeded, false otherwise.\n  bool openZipFile( QString const & );\n\n  /// Returns true if the zip is open, false otherwise.\n  bool isOpen() const\n  { return zipIsOpen; }\n\n  /// Checks whether the given file exists in the zip file or not.\n  /// Note that this function is thread-safe, since it does not access zip file.\n  bool hasFile( gd::wstring const & name );\n\n  /// Attempts loading the given file into the given vector. Returns true on\n  /// success, false otherwise.\n  bool loadFile( gd::wstring const & name, std::vector< char > & );\n  bool loadFile( uint32_t offset, std::vector< char > & );\n\n  /// Index compressed files in zip file\n  bool indexFile( BtreeIndexing::IndexedWords &zipFileNames, quint32 * filesCount = 0 );\n};\n\n#endif\n"
        },
        {
          "name": "initializing.cc",
          "type": "blob",
          "size": 2.1357421875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include <QIcon>\n#include \"initializing.hh\"\n#include <QCloseEvent>\n\n#if ( QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 ) ) && defined( Q_OS_WIN32 )\n#include <qt_windows.h>\n#include <uxtheme.h>\n\nWindowsStyle::WindowsStyle()\n{\n  style = QStyleFactory::create( \"windows\" );\n}\n\nWindowsStyle & WindowsStyle::instance()\n{\n  static WindowsStyle ws;\n  return ws;\n}\n\n#endif\n\nInitializing::Initializing( QWidget * parent, bool showOnStartup ): QDialog( parent )\n{\n  ui.setupUi( this );\n  setWindowFlags( Qt::Dialog | Qt::CustomizeWindowHint | Qt::WindowTitleHint |\n                  Qt::WindowMinimizeButtonHint );\n\n  #ifndef Q_OS_MAC\n    setWindowIcon( QIcon( \":/icons/programicon.png\" ) );\n  #else\n    setWindowIcon( QIcon( \":/icons/macicon.png\" ) );\n  #endif\n\n#if ( QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 ) ) && defined( Q_OS_WIN32 )\n\n  // Style \"windowsvista\" in Qt5 turn off progress bar animation for classic appearance\n  // We use simply \"windows\" style instead for this case\n\n  oldBarStyle = 0;\n\n  if( QSysInfo::windowsVersion() >= QSysInfo::WV_VISTA\n      && ( QSysInfo::windowsVersion() & QSysInfo::WV_NT_based )\n      && !IsThemeActive() )\n  {\n    QStyle * barStyle = WindowsStyle::instance().getStyle();\n\n    if( barStyle )\n    {\n      oldBarStyle = ui.progressBar->style();\n      ui.progressBar->setStyle( barStyle );\n    }\n  }\n\n#endif\n\n  if ( showOnStartup )\n  {\n    ui.operation->setText( tr( \"Please wait...\" ) );\n    ui.dictionary->hide();\n    ui.progressBar->hide();\n    show();\n  }\n}\n\nvoid Initializing::indexing( QString const & dictionaryName )\n{\n  ui.operation->setText( tr( \"Please wait while indexing dictionary\" ) );\n  ui.dictionary->setText( dictionaryName );\n  ui.dictionary->show();\n  ui.progressBar->show();\n  adjustSize();\n  show();\n}\n\nvoid Initializing::closeEvent( QCloseEvent * ev )\n{\n  ev->ignore();\n}\n\nvoid Initializing::reject()\n{\n}\n\n#if ( QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 ) ) && defined( Q_OS_WIN32 )\n\nInitializing::~Initializing()\n{\n  if( oldBarStyle )\n    ui.progressBar->setStyle( oldBarStyle );\n}\n\n#endif\n"
        },
        {
          "name": "initializing.hh",
          "type": "blob",
          "size": 1.0615234375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __INITIALIZING_HH_INCLUDED__\n#define __INITIALIZING_HH_INCLUDED__\n\n#include <QDialog>\n#include \"ui_initializing.h\"\n\n#if ( QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 ) ) && defined( Q_OS_WIN32 )\n\n#include <QtWidgets/QStyleFactory>\n\nclass WindowsStyle {\npublic:\n  /// The class is a singleton.\n  static WindowsStyle & instance();\n\n  QStyle * getStyle()\n  { return style; }\n\nprivate:\n  WindowsStyle();\n\n  QStyle * style;\n};\n\n#endif\n\nclass Initializing: public QDialog\n{\n  Q_OBJECT\n\npublic:\n\n  Initializing( QWidget * parent, bool showOnStartup );\n#if ( QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 ) ) && defined( Q_OS_WIN32 )\n  ~Initializing();\n#endif\n\npublic slots:\n\n  void indexing( QString const & dictionaryName );\n\nprivate:\n\n  virtual void closeEvent( QCloseEvent * );\n  virtual void reject();\n#if ( QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 ) ) && defined( Q_OS_WIN32 )\n  QStyle * oldBarStyle;\n#endif\n\n  Ui::Initializing ui;\n};\n\n#endif\n\n"
        },
        {
          "name": "initializing.ui",
          "type": "blob",
          "size": 1.7197265625,
          "content": "<ui version=\"4.0\" >\n <class>Initializing</class>\n <widget class=\"QDialog\" name=\"Initializing\" >\n  <property name=\"windowModality\" >\n   <enum>Qt::ApplicationModal</enum>\n  </property>\n  <property name=\"geometry\" >\n   <rect>\n    <x>0</x>\n    <y>0</y>\n    <width>326</width>\n    <height>84</height>\n   </rect>\n  </property>\n  <property name=\"minimumSize\">\n   <size>\n    <width>326</width>\n    <height>0</height>\n   </size>\n  </property>\n  <property name=\"windowTitle\" >\n   <string>GoldenDict - Initializing</string>\n  </property>\n  <layout class=\"QVBoxLayout\" name=\"verticalLayout\" >\n   <item>\n    <widget class=\"QLabel\" name=\"operation\" >\n     <property name=\"text\" >\n      <string>Please wait while indexing dictionary</string>\n     </property>\n     <property name=\"alignment\" >\n      <set>Qt::AlignCenter</set>\n     </property>\n    </widget>\n   </item>\n   <item>\n    <widget class=\"QLabel\" name=\"dictionary\" >\n     <property name=\"font\" >\n      <font>\n       <weight>75</weight>\n       <bold>true</bold>\n      </font>\n     </property>\n     <property name=\"text\" >\n      <string>Dictionary Name</string>\n     </property>\n     <property name=\"scaledContents\" >\n      <bool>false</bool>\n     </property>\n     <property name=\"alignment\" >\n      <set>Qt::AlignCenter</set>\n     </property>\n     <property name=\"wordWrap\">\n      <bool>true</bool>\n     </property>\n    </widget>\n   </item>\n   <item>\n    <widget class=\"QProgressBar\" name=\"progressBar\" >\n     <property name=\"maximum\" >\n      <number>0</number>\n     </property>\n     <property name=\"value\" >\n      <number>-1</number>\n     </property>\n     <property name=\"alignment\">\n      <set>Qt::AlignCenter</set>\n     </property>\n    </widget>\n   </item>\n  </layout>\n </widget>\n <resources/>\n <connections/>\n</ui>\n"
        },
        {
          "name": "instances.cc",
          "type": "blob",
          "size": 5.8544921875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"instances.hh\"\n#include <set>\n#include <QBuffer>\n\nnamespace Instances {\n\nusing std::set;\nusing std::string;\n\nGroup::Group( Config::Group const & cfgGroup,\n              vector< sptr< Dictionary::Class > > const & allDictionaries,\n              Config::Group const & inactiveGroup ):\n  id( cfgGroup.id ),\n  name( cfgGroup.name ),\n  icon( cfgGroup.icon ),\n  favoritesFolder( cfgGroup.favoritesFolder ),\n  shortcut( cfgGroup.shortcut )\n{\n  if ( !cfgGroup.iconData.isEmpty() )\n    iconData = iconFromData( cfgGroup.iconData );\n\n  vector< sptr< Dictionary::Class > > groupDicts;\n\n  for( unsigned x = 0; x < (unsigned)cfgGroup.dictionaries.size(); ++x )\n  {\n    std::string id = cfgGroup.dictionaries[ x ].id.toStdString();\n\n    bool added = false;\n\n    for( unsigned y = allDictionaries.size(); y--; )\n      if ( allDictionaries[ y ]->getId() == id )\n      {\n        groupDicts.push_back( allDictionaries[ y ] );\n        added = true;\n        break;\n      }\n\n    if ( !added )\n    {\n      // Try matching by name instead\n      QString qname = cfgGroup.dictionaries[ x ].name;\n      std::string name = qname.toUtf8().data();\n\n      if ( !qname.isEmpty() )\n      {\n\n        // To avoid duplicates in dictionaries list we don't add dictionary\n        // if it with such name was already added or presented in rest of list\n\n        unsigned n;\n        for( n = 0; n < groupDicts.size(); n++ )\n          if( groupDicts[ n ]->getName() == name )\n            break;\n        if( n < groupDicts.size() )\n          continue;\n\n        for( n = x + 1; n < (unsigned)cfgGroup.dictionaries.size(); n++ )\n          if( cfgGroup.dictionaries[ n ].name == qname )\n            break;\n        if( n < (unsigned)cfgGroup.dictionaries.size() )\n          continue;\n\n        for( unsigned y = 0; y < allDictionaries.size(); ++y )\n          if ( allDictionaries[ y ]->getName() == name )\n          {\n            groupDicts.push_back( allDictionaries[ y ] );\n            break;\n          }\n      }\n    }\n  }\n\n  // Remove inactive dictionaries\n\n  if( inactiveGroup.dictionaries.isEmpty() )\n    dictionaries = groupDicts;\n  else\n  {\n    set< string > inactiveSet;\n    for( int i = 0; i < inactiveGroup.dictionaries.size(); i++ )\n      inactiveSet.insert( inactiveGroup.dictionaries[ i ].id.toStdString() );\n\n    for( unsigned i = 0; i < groupDicts.size(); i++ )\n      if( inactiveSet.find( groupDicts[ i ]->getId() ) == inactiveSet.end() )\n        dictionaries.push_back( groupDicts[ i ] );\n  }\n}\n\nGroup::Group( QString const & name_ ): id( 0 ), name( name_ )\n{\n}\n\nConfig::Group Group::makeConfigGroup()\n{\n  Config::Group result;\n\n  result.id = id;\n  result.name = name;\n  result.icon = icon;\n  result.shortcut = shortcut;\n  result.favoritesFolder = favoritesFolder;\n\n  if ( !iconData.isNull() )\n  {\n    QDataStream stream( &result.iconData, QIODevice::WriteOnly );\n\n    stream << iconData;\n  }\n\n  for( unsigned x = 0; x < dictionaries.size(); ++x )\n    result.dictionaries.push_back(\n      Config::DictionaryRef( dictionaries[ x ]->getId().c_str(),\n                             QString::fromUtf8( dictionaries[ x ]->getName().c_str() ) ) );\n\n  return result;\n}\n\nQIcon Group::makeIcon() const\n{\n  if ( !iconData.isNull() )\n    return iconData;\n\n  QIcon i = icon.size() ?\n                 QIcon( \":/flags/\" + icon ) : QIcon();\n\n  return i;\n}\n\nvoid Group::checkMutedDictionaries( Config::MutedDictionaries * mutedDictionaries ) const\n{\n  Config::MutedDictionaries temp;\n\n  for( unsigned x = 0; x < dictionaries.size(); x++ )\n  {\n    QString id = QString::fromStdString( dictionaries[ x ]->getId() );\n    if( mutedDictionaries->contains( id ) )\n      temp.insert( id );\n  }\n  * mutedDictionaries = temp;\n}\n\nGroup * Groups::findGroup( unsigned id )\n{\n  for( unsigned x = 0; x < size(); ++x )\n    if ( operator [] ( x ).id == id )\n      return &( operator [] ( x ) );\n\n  return 0;\n}\n\nGroup const * Groups::findGroup( unsigned id ) const\n{\n  for( unsigned x = 0; x < size(); ++x )\n    if ( operator [] ( x ).id == id )\n      return &( operator [] ( x ) );\n\n  return 0;\n}\n\nvoid complementDictionaryOrder( Group & group,\n                                Group const & inactiveDictionaries,\n                                vector< sptr< Dictionary::Class > > const & dicts )\n{\n  set< string > presentIds;\n\n  for( unsigned x = group.dictionaries.size(); x--; )\n    presentIds.insert( group.dictionaries[ x ]->getId());\n\n  for( unsigned x = inactiveDictionaries.dictionaries.size(); x--; )\n    presentIds.insert( inactiveDictionaries.dictionaries[ x ]->getId() );\n\n  for( unsigned x = 0; x < dicts.size(); ++x )\n  {\n    if ( presentIds.find( dicts[ x ]->getId() ) == presentIds.end() )\n      group.dictionaries.push_back( dicts[ x ] );\n  }\n}\n\nvoid updateNames( Config::Group & group,\n                  vector< sptr< Dictionary::Class > > const & allDictionaries )\n{\n\n  for( unsigned x = group.dictionaries.size(); x--; )\n  {\n    std::string id = group.dictionaries[ x ].id.toStdString();\n\n    for( unsigned y = allDictionaries.size(); y--; )\n      if ( allDictionaries[ y ]->getId() == id )\n      {\n        group.dictionaries[ x ].name = QString::fromUtf8( allDictionaries[ y ]->getName().c_str() );\n        break;\n      }\n  }\n}\n\nvoid updateNames( Config::Groups & groups,\n                  vector< sptr< Dictionary::Class > > const & allDictionaries )\n{\n  for( int x = 0; x < groups.size(); ++x )\n    updateNames( groups[ x ], allDictionaries );\n}\n\nvoid updateNames( Config::Class & cfg,\n                  vector< sptr< Dictionary::Class > > const & allDictionaries )\n{\n  updateNames( cfg.dictionaryOrder, allDictionaries );\n  updateNames( cfg.inactiveDictionaries, allDictionaries );\n  updateNames( cfg.groups, allDictionaries );\n}\n\nQIcon iconFromData( QByteArray const & iconData )\n{\n  QDataStream stream( iconData );\n\n  QIcon result;\n\n  stream >> result;\n\n  return result;\n}\n\n}\n"
        },
        {
          "name": "instances.hh",
          "type": "blob",
          "size": 3.2158203125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __INSTANCES_HH_INCLUDED__\n#define __INSTANCES_HH_INCLUDED__\n\n#include \"config.hh\"\n#include \"dictionary.hh\"\n#include <QIcon>\n#include <limits.h>\n\n// This complements Config, providing instances for the stored configurations.\n// Simply put, it can convert groups to ones which hold references to\n// dictionaries directly, instead of only having their ids, and can also convert\n// them back.\n\nnamespace Instances {\n\nusing std::vector;\n\nstruct Group\n{\n  unsigned id;\n  QString name, icon, favoritesFolder;\n  QIcon iconData;\n  QKeySequence shortcut;\n  vector< sptr< Dictionary::Class > > dictionaries;\n\n  /// Instantiates the given group from its configuration. If some dictionary\n  /// wasn't found, it just skips it.\n  Group( Config::Group const & cfgGroup,\n         vector< sptr< Dictionary::Class > > const & allDictionaries,\n         Config::Group const & inactiveGroup );\n\n  /// Creates an empty group.\n  Group( QString const & name_ );\n\n  /// Makes the configuration group from the current contents.\n  Config::Group makeConfigGroup();\n\n  /// Makes an icon object for this group, based on the icon's name or iconData.\n  QIcon makeIcon() const;\n\n  /// Remove id's if not presented in group dictionaries\n  void checkMutedDictionaries( Config::MutedDictionaries * mutedDictionaries ) const;\n\n  // Some constants\n\n  /// The id of the 'All' group\n  static const unsigned AllGroupId = UINT_MAX - 1;\n\n  /// The id of the fictious 'Help' group\n  static const unsigned HelpGroupId = UINT_MAX;\n\n  /// Invalid value, used to specify that no group id is specified at all.\n  static const unsigned NoGroupId = 0;\n};\n\nstruct Groups: public vector< Group >\n{\n  /// Tries finding the given group by its id. Returns the group found, or\n  /// 0 if there's no such group.\n  Group * findGroup( unsigned id );\n  Group const * findGroup( unsigned id ) const;\n};\n\n/// Adds any dictionaries not already present in the given group or in\n/// inactiveDictionaires to its end. Meant to be used with dictionaryOrder\n/// special group.\nvoid complementDictionaryOrder( Group & dictionaryOrder,\n                                Group const & inactiveDictionaries,\n                                vector< sptr< Dictionary::Class > > const &\n                                allDictionaries );\n\n/// For any dictionaries present in the group, updates their names to match\n/// the dictionaries they refer to in their current form, if they exist.\n/// If the dictionary instance can't be located, the name is left untouched.\nvoid updateNames( Config::Group &,\n                  vector< sptr< Dictionary::Class > > const & allDictionaries );\n\n/// Does updateNames() for a set of given groups.\nvoid updateNames( Config::Groups &,\n                  vector< sptr< Dictionary::Class > > const & allDictionaries );\n\n/// Does updateNames() for any relevant dictionary groups present in the\n/// configuration.\nvoid updateNames( Config::Class &,\n                  vector< sptr< Dictionary::Class > > const & allDictionaries );\n\n/// Creates icon from icon data. Used by Group, but also by others who work\n/// with icon data directly.\nQIcon iconFromData( QByteArray const & );\n\n}\n\n#endif\n"
        },
        {
          "name": "keyboardstate.cc",
          "type": "blob",
          "size": 1.84765625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"keyboardstate.hh\"\n#include <QObject> // To get Qt Q_OS defines\n\n#ifdef Q_OS_WIN32\n#include <windows.h>\n#elif defined(HAVE_X11)\n#include <QX11Info>\n#include <X11/X.h>\n#include <X11/XKBlib.h>\n#elif defined Q_OS_MAC\n#define __SECURITYHI__\n#include <Carbon/Carbon.h>\n#endif\n\nbool KeyboardState::checkModifiersPressed( int mask )\n{\n  #if defined(Q_WS_QWS)\n    return false;\n  #elif defined(Q_OS_WIN32)\n\n  return !(\n    ( mask & Alt && !( GetAsyncKeyState( VK_MENU ) & 0x8000 ) ) ||\n    ( mask & Ctrl && !( GetAsyncKeyState( VK_CONTROL ) & 0x8000 ) ) ||\n    ( mask & Shift && !( GetAsyncKeyState( VK_SHIFT ) & 0x8000 ) ) ||\n    ( mask & LeftAlt && !( GetAsyncKeyState( VK_LMENU ) & 0x8000 ) ) ||\n    ( mask & RightAlt && !( GetAsyncKeyState( VK_RMENU ) & 0x8000 ) ) ||\n    ( mask & LeftCtrl && !( GetAsyncKeyState( VK_LCONTROL ) & 0x8000 ) ) ||\n    ( mask & RightCtrl && !( GetAsyncKeyState( VK_RCONTROL ) & 0x8000 ) ) ||\n    ( mask & LeftShift && !( GetAsyncKeyState( VK_LSHIFT ) & 0x8000 ) ) ||\n    ( mask & RightShift && !( GetAsyncKeyState( VK_RSHIFT ) & 0x8000 ) ) );\n\n  #elif defined Q_OS_MAC\n  UInt32 keys = GetCurrentKeyModifiers();\n  return !(\n    ( mask & Alt && !( keys & ( 1 << optionKeyBit ) ) ) ||\n    ( mask & Ctrl && !( keys & ( 1 << cmdKeyBit ) ) ) ||\n    ( mask & Shift && !( keys & ( 1 << shiftKeyBit ) ) ) ||\n    ( mask & Win && !( keys & ( 1 << controlKeyBit ) ) ) );\n  #else\n  XkbStateRec state;\n\n  XkbGetState( QX11Info::display(), XkbUseCoreKbd, &state );\n\n  return !(\n    ( mask & Alt && !( state.base_mods & Mod1Mask ) ) ||\n    ( mask & Ctrl && !( state.base_mods & ControlMask ) ) ||\n    ( mask & Shift && !( state.base_mods & ShiftMask ) ) ||\n    ( mask & Win && !( state.base_mods & Mod4Mask ) ) );\n  #endif\n}\n\n"
        },
        {
          "name": "keyboardstate.hh",
          "type": "blob",
          "size": 0.8623046875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __KEYBOARDSTATE_HH_INCLUDED__\n#define __KEYBOARDSTATE_HH_INCLUDED__\n\n/// Since Qt doesn't provide a way to test for keyboard modifiers state\n/// when the app isn't in focus, we have to implement this separately for\n/// each platform.\nclass KeyboardState\n{\npublic:\n\n  enum Modifier\n  {\n    Alt = 1,\n    Ctrl = 2,\n    Shift = 4,\n    Win = 8, // Ironically, Linux only, since it's no use under Windows\n    LeftAlt = 16, // Those Left-Right are Windows-only, at least for now\n    RightAlt = 32,\n    LeftCtrl = 64,\n    RightCtrl = 128,\n    LeftShift = 256,\n    RightShift = 512\n  };\n\n  /// Returns true if all Modifiers present within the given mask are pressed\n  /// right now.\n  bool checkModifiersPressed( int mask );\n};\n\n#endif\n"
        },
        {
          "name": "langcoder.cc",
          "type": "blob",
          "size": 11.857421875,
          "content": "/* This file is (c) 2008-2013 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"langcoder.hh\"\n#include \"folding.hh\"\n#include \"wstring_qt.hh\"\n#include \"language.hh\"\n\n#ifdef _MSC_VER\n#include <stub_msvc.h>\n#endif\n\n#include <cctype>\n#include <QLocale>\n\nLangCoder langCoder;\n\n// Language codes\n\nstatic GDLangCode LangCodes[] = {\n\n    { \"aa\", \"aar\", -1, \"Afar\" },\n    { \"ab\", \"abk\", -1, \"Abkhazian\" },\n    { \"ae\", \"ave\", -1, \"Avestan\" },\n    { \"af\", \"afr\", -1, \"Afrikaans\" },\n    { \"ak\", \"aka\", -1, \"Akan\" },\n    { \"am\", \"amh\", -1, \"Amharic\" },\n    { \"an\", \"arg\", -1, \"Aragonese\" },\n    { \"ar\", \"ara\", 1, \"Arabic\" },\n    { \"as\", \"asm\", -1, \"Assamese\" },\n    { \"av\", \"ava\", -1, \"Avaric\" },\n    { \"ay\", \"aym\", -1, \"Aymara\" },\n    { \"az\", \"aze\", 0, \"Azerbaijani\" },\n    { \"ba\", \"bak\", 0, \"Bashkir\" },\n    { \"be\", \"bel\", 0, \"Belarusian\" },\n    { \"bg\", \"bul\", 0, \"Bulgarian\" },\n    { \"bh\", \"bih\", -1, \"Bihari\" },\n    { \"bi\", \"bis\", -1, \"Bislama\" },\n    { \"bm\", \"bam\", -1, \"Bambara\" },\n    { \"bn\", \"ben\", -1, \"Bengali\" },\n    { \"bo\", \"tib\", -1, \"Tibetan\" },\n    { \"br\", \"bre\", -1, \"Breton\" },\n    { \"bs\", \"bos\", 0, \"Bosnian\" },\n    { \"ca\", \"cat\", -1, \"Catalan\" },\n    { \"ce\", \"che\", -1, \"Chechen\" },\n    { \"ch\", \"cha\", -1, \"Chamorro\" },\n    { \"co\", \"cos\", -1, \"Corsican\" },\n    { \"cr\", \"cre\", -1, \"Cree\" },\n    { \"cs\", \"cze\", 0, \"Czech\" },\n    { \"cu\", \"chu\", 0, \"Church Slavic\" },\n    { \"cv\", \"chv\", 0, \"Chuvash\" },\n    { \"cy\", \"wel\", 0, \"Welsh\" },\n    { \"da\", \"dan\", 0, \"Danish\" },\n    { \"de\", \"ger\", 0, \"German\" },\n    { \"dv\", \"div\", -1, \"Divehi\" },\n    { \"dz\", \"dzo\", -1, \"Dzongkha\" },\n    { \"ee\", \"ewe\", -1, \"Ewe\" },\n    { \"el\", \"gre\", 0, \"Greek\" },\n    { \"en\", \"eng\", 0, \"English\" },\n    { \"eo\", \"epo\", 0, \"Esperanto\" },\n    { \"es\", \"spa\", 0, \"Spanish\" },\n    { \"et\", \"est\", 0, \"Estonian\" },\n    { \"eu\", \"baq\", 0, \"Basque\" },\n    { \"fa\", \"per\", -1, \"Persian\" },\n    { \"ff\", \"ful\", -1, \"Fulah\" },\n    { \"fi\", \"fin\", 0, \"Finnish\" },\n    { \"fj\", \"fij\", -1, \"Fijian\" },\n    { \"fo\", \"fao\", -1, \"Faroese\" },\n    { \"fr\", \"fre\", 0, \"French\" },\n    { \"fy\", \"fry\", -1, \"Western Frisian\" },\n    { \"ga\", \"gle\", 0, \"Irish\" },\n    { \"gd\", \"gla\", 0, \"Scottish Gaelic\" },\n    { \"gl\", \"glg\", -1, \"Galician\" },\n    { \"gn\", \"grn\", -1, \"Guarani\" },\n    { \"gu\", \"guj\", -1, \"Gujarati\" },\n    { \"gv\", \"glv\", -1, \"Manx\" },\n    { \"ha\", \"hau\", -1, \"Hausa\" },\n    { \"he\", \"heb\", 1, \"Hebrew\" },\n    { \"hi\", \"hin\", -1, \"Hindi\" },\n    { \"ho\", \"hmo\", -1, \"Hiri Motu\" },\n    { \"hr\", \"hrv\", 0, \"Croatian\" },\n    { \"ht\", \"hat\", -1, \"Haitian\" },\n    { \"hu\", \"hun\", 0, \"Hungarian\" },\n    { \"hy\", \"arm\", 0, \"Armenian\" },\n    { \"hz\", \"her\", -1, \"Herero\" },\n    { \"ia\", \"ina\", -1, \"Interlingua\" },\n    { \"id\", \"ind\", -1, \"Indonesian\" },\n    { \"ie\", \"ile\", -1, \"Interlingue\" },\n    { \"ig\", \"ibo\", -1, \"Igbo\" },\n    { \"ii\", \"iii\", -1, \"Sichuan Yi\" },\n    { \"ik\", \"ipk\", -1, \"Inupiaq\" },\n    { \"io\", \"ido\", -1, \"Ido\" },\n    { \"is\", \"ice\", -1, \"Icelandic\" },\n    { \"it\", \"ita\", 0, \"Italian\" },\n    { \"iu\", \"iku\", -1, \"Inuktitut\" },\n    { \"ja\", \"jpn\", 0, \"Japanese\" },\n    { \"jv\", \"jav\", -1, \"Javanese\" },\n    { \"ka\", \"geo\", 0, \"Georgian\" },\n    { \"kg\", \"kon\", -1, \"Kongo\" },\n    { \"ki\", \"kik\", -1, \"Kikuyu\" },\n    { \"kj\", \"kua\", -1, \"Kwanyama\" },\n    { \"kk\", \"kaz\", 0, \"Kazakh\" },\n    { \"kl\", \"kal\", -1, \"Kalaallisut\" },\n    { \"km\", \"khm\", -1, \"Khmer\" },\n    { \"kn\", \"kan\", -1, \"Kannada\" },\n    { \"ko\", \"kor\", 0, \"Korean\" },\n    { \"kr\", \"kau\", -1, \"Kanuri\" },\n    { \"ks\", \"kas\", -1, \"Kashmiri\" },\n    { \"ku\", \"kur\", -1, \"Kurdish\" },\n    { \"kv\", \"kom\", 0, \"Komi\" },\n    { \"kw\", \"cor\", -1, \"Cornish\" },\n    { \"ky\", \"kir\", -1, \"Kirghiz\" },\n    { \"la\", \"lat\", 0, \"Latin\" },\n    { \"lb\", \"ltz\", 0, \"Luxembourgish\" },\n    { \"lg\", \"lug\", -1, \"Ganda\" },\n    { \"li\", \"lim\", -1, \"Limburgish\" },\n    { \"ln\", \"lin\", -1, \"Lingala\" },\n    { \"lo\", \"lao\", -1, \"Lao\" },\n    { \"lt\", \"lit\", 0, \"Lithuanian\" },\n    { \"lu\", \"lub\", -1, \"Luba-Katanga\" },\n    { \"lv\", \"lav\", 0, \"Latvian\" },\n    { \"mg\", \"mlg\", -1, \"Malagasy\" },\n    { \"mh\", \"mah\", -1, \"Marshallese\" },\n    { \"mi\", \"mao\", -1, \"Maori\" },\n    { \"mk\", \"mac\", 0, \"Macedonian\" },\n    { \"ml\", \"mal\", -1, \"Malayalam\" },\n    { \"mn\", \"mon\", -1, \"Mongolian\" },\n    { \"mr\", \"mar\", -1, \"Marathi\" },\n    { \"ms\", \"may\", -1, \"Malay\" },\n    { \"mt\", \"mlt\", -1, \"Maltese\" },\n    { \"my\", \"bur\", -1, \"Burmese\" },\n    { \"na\", \"nau\", -1, \"Nauru\" },\n    { \"nb\", \"nob\", 0, \"Norwegian Bokmal\" },\n    { \"nd\", \"nde\", -1, \"North Ndebele\" },\n    { \"ne\", \"nep\", -1, \"Nepali\" },\n    { \"ng\", \"ndo\", -1, \"Ndonga\" },\n    { \"nl\", \"dut\", -1, \"Dutch\" },\n    { \"nn\", \"nno\", -1, \"Norwegian Nynorsk\" },\n    { \"no\", \"nor\", 0, \"Norwegian\" },\n    { \"nr\", \"nbl\", -1, \"South Ndebele\" },\n    { \"nv\", \"nav\", -1, \"Navajo\" },\n    { \"ny\", \"nya\", -1, \"Chichewa\" },\n    { \"oc\", \"oci\", -1, \"Occitan\" },\n    { \"oj\", \"oji\", -1, \"Ojibwa\" },\n    { \"om\", \"orm\", -1, \"Oromo\" },\n    { \"or\", \"ori\", -1, \"Oriya\" },\n    { \"os\", \"oss\", -1, \"Ossetian\" },\n    { \"pa\", \"pan\", -1, \"Panjabi\" },\n    { \"pi\", \"pli\", -1, \"Pali\" },\n    { \"pl\", \"pol\", 0, \"Polish\" },\n    { \"ps\", \"pus\", -1, \"Pashto\" },\n    { \"pt\", \"por\", 0, \"Portuguese\" },\n    { \"qu\", \"que\", -1, \"Quechua\" },\n    { \"rm\", \"roh\", -1, \"Raeto-Romance\" },\n    { \"rn\", \"run\", -1, \"Kirundi\" },\n    { \"ro\", \"rum\", 0, \"Romanian\" },\n    { \"ru\", \"rus\", 0, \"Russian\" },\n    { \"rw\", \"kin\", -1, \"Kinyarwanda\" },\n    { \"sa\", \"san\", -1, \"Sanskrit\" },\n    { \"sc\", \"srd\", -1, \"Sardinian\" },\n    { \"sd\", \"snd\", -1, \"Sindhi\" },\n    { \"se\", \"sme\", -1, \"Northern Sami\" },\n    { \"sg\", \"sag\", -1, \"Sango\" },\n    { \"sh\", \"shr\", 0, \"Serbo-Croatian\" },\n    { \"si\", \"sin\", -1, \"Sinhala\" },\n    { \"sk\", \"slo\", 0, \"Slovak\" },\n    { \"sl\", \"slv\", 0, \"Slovenian\" },\n    { \"sm\", \"smo\", -1, \"Samoan\" },\n    { \"sn\", \"sna\", -1, \"Shona\" },\n    { \"so\", \"som\", -1, \"Somali\" },\n    { \"sq\", \"alb\", 0, \"Albanian\" },\n    { \"sr\", \"srp\", 0, \"Serbian\" },\n    { \"ss\", \"ssw\", -1, \"Swati\" },\n    { \"st\", \"sot\", -1, \"Southern Sotho\" },\n    { \"su\", \"sun\", -1, \"Sundanese\" },\n    { \"sv\", \"swe\", 0, \"Swedish\" },\n    { \"sw\", \"swa\", -1, \"Swahili\" },\n    { \"ta\", \"tam\", -1, \"Tamil\" },\n    { \"te\", \"tel\", -1, \"Telugu\" },\n    { \"tg\", \"tgk\", 0, \"Tajik\" },\n    { \"th\", \"tha\", -1, \"Thai\" },\n    { \"ti\", \"tir\", -1, \"Tigrinya\" },\n    { \"tk\", \"tuk\", 0, \"Turkmen\" },\n    { \"tl\", \"tgl\", -1, \"Tagalog\" },\n    { \"tn\", \"tsn\", -1, \"Tswana\" },\n    { \"to\", \"ton\", -1, \"Tonga\" },\n    { \"tr\", \"tur\", 0, \"Turkish\" },\n    { \"ts\", \"tso\", -1, \"Tsonga\" },\n    { \"tt\", \"tat\", -1, \"Tatar\" },\n    { \"tw\", \"twi\", -1, \"Twi\" },\n    { \"ty\", \"tah\", -1, \"Tahitian\" },\n    { \"ug\", \"uig\", -1, \"Uighur\" },\n    { \"uk\", \"ukr\", -1, \"Ukrainian\" },\n    { \"ur\", \"urd\", -1, \"Urdu\" },\n    { \"uz\", \"uzb\", 0, \"Uzbek\" },\n    { \"ve\", \"ven\", -1, \"Venda\" },\n    { \"vi\", \"vie\", -1, \"Vietnamese\" },\n    { \"vo\", \"vol\", 0, \"Volapuk\" },\n    { \"wa\", \"wln\", -1, \"Walloon\" },\n    { \"wo\", \"wol\", -1, \"Wolof\" },\n    { \"xh\", \"xho\", -1, \"Xhosa\" },\n    { \"yi\", \"yid\", -1, \"Yiddish\" },\n    { \"yo\", \"yor\", -1, \"Yoruba\" },\n    { \"za\", \"zha\", -1, \"Zhuang\" },\n    { \"zh\", \"chi\", 0, \"Chinese\" },\n    { \"zu\", \"zul\", -1, \"Zulu\" },\n    { \"jb\", \"jbo\", 0, \"Lojban\" },\n\n    { \"\", \"\", 0, \"\" }\n};\n\nLangCoder::LangCoder()\n{\n  for (int i = 0; true; i++) {\n    const GDLangCode &lc = LangCodes[i];\n    if (lc.lang[0] == 0)\n      break;\n    codeMap[code2toInt(lc.code)] = i;\n  }\n}\n\nQString LangCoder::decode(quint32 code)\n{\n  if (langCoder.codeMap.contains(code))\n    return LangCodes[langCoder.codeMap[code]].lang;\n\n  return QString();\n}\n\nQIcon LangCoder::icon(quint32 code)\n{\n  if (langCoder.codeMap.contains(code))\n  {\n    const GDLangCode &lc = LangCodes[ langCoder.codeMap[ code ] ];\n    return QIcon( \":/flags/\" + QString(lc.code) + \".png\" );\n  }\n\n  return QIcon();\n}\n\nLangStruct LangCoder::langStruct(quint32 code)\n{\n  LangStruct ls;\n  ls.code = code;\n  ls.order = -1;\n  if (codeMap.contains(code)) {\n    int order = codeMap[code];\n    const GDLangCode &lc = LangCodes[order];\n    ls.order = order;\n    ls.lang = lc.lang;\n    ls.icon = QIcon(\":/flags/\" + QString(lc.code) + \".png\");\n  }\n  return ls;\n}\n\nQString LangCoder::intToCode2( quint32 val )\n{\n  if ( !val || val == 0xFFffFFff )\n    return QString();\n\n  char code[ 2 ];\n\n  code[ 0 ] = val & 0xFF;\n  code[ 1 ] = ( val >> 8 ) & 0xFF;\n\n  return QString::fromLatin1( code, 2 );\n}\n\nquint32 LangCoder::findIdForLanguage( gd::wstring const & lang )\n{\n  gd::wstring langFolded = Folding::apply( lang );\n\n  for( GDLangCode const * lc = LangCodes; lc->code[ 0 ]; ++lc )\n  {\n    if ( langFolded == Folding::apply( gd::toWString( lc->lang ) ) )\n    {\n      // We've got a match\n      return code2toInt( lc->code );\n    }\n  }\n\n  return Language::findBlgLangIDByEnglishName( lang );\n  //return 0;\n}\n\nquint32 LangCoder::findIdForLanguageCode3( const char * code3 )\n{\n  for( GDLangCode const * lc = LangCodes; lc->code[ 0 ]; ++lc )\n  {\n    if ( strcasecmp( code3, lc->code3 ) == 0 )\n    {\n      // We've got a match\n      return code2toInt( lc->code );\n    }\n  }\n\n  return 0;\n}\n\nquint32 LangCoder::guessId( const QString & lang )\n{\n  QString lstr = lang.simplified().toLower();\n\n  // too small to guess\n  if (lstr.size() < 2)\n    return 0;\n\n  // check if it could be the whole language name\n  if (lstr.size() >= 3)\n  {\n    for( GDLangCode const * lc = LangCodes; lc->code[ 0 ]; ++lc )\n    {\n      if ( lstr == ( lstr.size() == 3 ? QString( lc->code3 ) : QString( lc->lang ) ) )\n      {\n        // We've got a match\n        return code2toInt( lc->code );\n      }\n    }\n  }\n\n  // still not found - try to match by 2-symbol code\n  return code2toInt( lstr.left(2).toLatin1().data() );\n}\n\nQPair<quint32,quint32> LangCoder::findIdsForName( QString const & name )\n{\n  QString nameFolded = \"|\" + name.toCaseFolded() + \"|\";\n  QRegExp reg( \"[^a-z]([a-z]{2,3})-([a-z]{2,3})[^a-z]\" ); reg.setMinimal(true);\n  int off = 0;\n\n  while ( reg.indexIn( nameFolded, off ) >= 0 )\n  {\n    quint32 from = guessId( reg.cap(1) );\n    quint32 to = guessId( reg.cap(2) );\n    if (from && to)\n      return QPair<quint32,quint32>(from, to);\n\n    off += reg.matchedLength();\n  }\n\n  return QPair<quint32,quint32>(0, 0);\n}\n\nQPair<quint32,quint32> LangCoder::findIdsForFilename( QString const & name )\n{\n  return findIdsForName( QFileInfo( name ).fileName() );\n}\n\nbool LangCoder::isLanguageRTL( quint32 code )\n{\n  if ( langCoder.codeMap.contains( code ) )\n  {\n    GDLangCode &lc = LangCodes[ langCoder.codeMap[ code ] ];\n    if( lc.isRTL < 0 )\n    {\n#if QT_VERSION >= 0x040700\n      lc.isRTL = ( int )( QLocale( lc.code ).textDirection() == Qt::RightToLeft );\n#else\n      lc.isRTL = 0;\n#endif\n    }\n    return lc.isRTL != 0;\n  }\n\n  return false;\n}\n\n/*\nLangStruct& LangCoder::CodeToLangStruct(const QString &code)\n{\n  if (codeMap.contains(code)) {\n    LangStruct &ls = codeMap[code];\n    if (ls.icon.isNull() && *ls.icon_code) {\n      ls.icon = QIcon(\":/Resources/flags/\" + QString(ls.icon_code) + \".png\");\n    }\n        return ls;\n  }\n\n    return dummyLS;\n}\n\nQString LangCoder::CodeToHtml(const QString &code)\n{\n  if (codeMap.contains(code)) {\n    LangStruct &ls = codeMap[code];\n    if (*ls.icon_code) {\n      return \"<img src=':/Resources/flags/\" + QString(ls.icon_code) + \".png'>&nbsp;\" + ls.lang;\n    }\n        return ls.lang;\n  }\n\n    return \"\";\n}\n\nbool LangCoder::CheckCode(QString &code)\n{\n  code = code.toUpper();\n\n  if (codeMap.contains(code))\n    return true;\n\n  if (code == \"DEU\") {\n    code = \"GER\";\n    return true;\n  }\n\n  return false;\n}\n*/\n\n/*\nLangModel::LangModel(QObject * parent) : QAbstractItemModel(parent)\n{\n}\n\nint LangModel::columnCount ( const QModelIndex & parent ) const\n{\n  return 2;\n}\n\nint LangModel::rowCount ( const QModelIndex & parent ) const\n{\n  return arraySize(LangCodes);\n}\n\nQVariant LangModel::data ( const QModelIndex & index, int role ) const\n{\n  switch (role) {\n    case Qt::DisplayRole:\n      return LangCodes[index.row()].lang;\n\n    case LangCodeRole:\n      return LangCodes[index.row()].code;\n\n    default:;\n  }\n\n  return QVariant();\n}\n\nQModelIndex LangModel::index ( int row, int column, const QModelIndex & parent ) const\n{\n  return createIndex(row, column);\n}\n\nQModelIndex LangModel::parent ( const QModelIndex & index ) const\n{\n  return QModelIndex();\n}\n*/\n"
        },
        {
          "name": "langcoder.hh",
          "type": "blob",
          "size": 2.3974609375,
          "content": "#ifndef LANGCODER_H\r\n#define LANGCODER_H\r\n\r\n#include <QtGui>\r\n#include \"wstring.hh\"\r\n\r\nstruct GDLangCode\r\n{\r\n    char code[ 3 ]; // ISO 639-1\r\n    char code3[ 4 ]; // ISO 639-2B ( http://www.loc.gov/standards/iso639-2/ )\r\n    int isRTL; // Right-to-left writing; 0 - no, 1 - yes, -1 - let Qt define\r\n    char const * lang; // Language name in English\r\n};\r\n\r\n                   \r\ntemplate <typename T, int N>\r\ninline int arraySize(T (&)[N])   { return N; }\r\n\r\n\r\nstruct LangStruct\r\n{\r\n  int order;\r\n  quint32 code;\r\n  QIcon icon;\r\n  QString lang;\r\n};\r\n\r\nclass LangCoder\r\n{\r\npublic:\r\n  LangCoder();\r\n\r\n  static quint32 code2toInt(const char code[2])\r\n  { return ( ((quint32)code[1]) << 8 ) + (quint32)code[0]; }\r\n\r\n  static QString intToCode2( quint32 );\r\n\r\n  /// Finds the id for the given language name, written in english. The search\r\n  /// is case- and punctuation insensitive.\r\n  static quint32 findIdForLanguage( gd::wstring const & );\r\n\r\n  static quint32 findIdForLanguageCode3( const char * );\r\n\r\n  static QPair<quint32,quint32> findIdsForName( QString const & );\r\n  static QPair<quint32,quint32> findIdsForFilename( QString const & );\r\n\r\n  static quint32 guessId( const QString & lang );\r\n\r\n  /// Returns decoded name of language or empty string if not found.\r\n  static QString decode(quint32 code);\r\n  /// Returns icon for language or empty string if not found.\r\n  static QIcon icon(quint32 code);\r\n\r\n  /// Return true for RTL languages\r\n  static bool isLanguageRTL(quint32 code);\r\n\r\n  //const QMap<quint32, int>& codes() { return codeMap; }\r\n\r\n  LangStruct langStruct(quint32 code);\r\n\r\n//\tQString CodeToHtml(const QString &code);\r\n\r\n//\tbool CheckCode(QString &code);\r\n\r\nprivate:\r\n  QMap<quint32, int> codeMap;\r\n//\tLangStruct dummyLS;\r\n};\r\n\r\n//extern LangCoder langCoder;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n#define LangCodeRole\tQt::UserRole\r\n\r\n/*\r\nclass LangModel : public QAbstractItemModel\r\n{\r\npublic:\r\n  LangModel(QObject * parent = 0);\r\n\r\n  virtual int columnCount ( const QModelIndex & parent = QModelIndex(}, const;\r\n  virtual int rowCount ( const QModelIndex & parent = QModelIndex(}, const;\r\n\r\n  virtual QVariant data ( const QModelIndex & index, int role = Qt::DisplayRole ) const;\r\n\r\n  virtual QModelIndex index ( int row, int column, const QModelIndex & parent = QModelIndex(}, const;\r\n  virtual QModelIndex parent ( const QModelIndex & index ) const;\r\n};\r\n*/\r\n\r\n#endif // LANGCODER_H\r\n"
        },
        {
          "name": "language.cc",
          "type": "blob",
          "size": 24.138671875,
          "content": "#include \"language.hh\"\n#include \"langcoder.hh\"\n#include <map>\n#include <QCoreApplication>\n\n#if defined( _MSC_VER ) && _MSC_VER < 1800 // VS2012 and older\n#include <stdint_msvc.h>\n#else\n#include <stdint.h>\n#endif\n\nnamespace Language {\n\nnamespace {\n\nusing std::map;\n\nstruct Db\n{\n  static Db const & instance();\n\n  map< QString, QString > const & getIso2ToEnglish() const\n  { return iso2ToEnglish; }\n  map< QString, QString > const & getIso2ToLocalized() const\n  { return iso2ToLocalized; }\n\n  map< QString, QString > const & getIso2ToCountry() const\n  { return iso2ToCountry; }\n\nprivate:\n\n  map< QString, QString > iso2ToEnglish, iso2ToLocalized, iso2ToCountry;\n\n  Db();\n\n  void addEntry( QString const & iso2, QString const & english,\n                 QString const & localized );\n};\n\nDb const & Db::instance()\n{\n  static Db v;\n\n  return v;\n}\n\nvoid Db::addEntry( QString const & iso2, QString const & english,\n                   QString const & localized )\n{\n  iso2ToEnglish[ iso2 ] = english;\n  iso2ToLocalized[ iso2 ] = localized;\n}\n\nDb::Db()\n{\n  addEntry( \"aa\", \"Afar\", QCoreApplication::translate( \"Language\", \"Afar\" ) );\n  addEntry( \"ab\", \"Abkhazian\", QCoreApplication::translate( \"Language\", \"Abkhazian\" ) );\n  addEntry( \"ae\", \"Avestan\", QCoreApplication::translate( \"Language\", \"Avestan\" ) );\n  addEntry( \"af\", \"Afrikaans\", QCoreApplication::translate( \"Language\", \"Afrikaans\" ) );\n  addEntry( \"ak\", \"Akan\", QCoreApplication::translate( \"Language\", \"Akan\" ) );\n  addEntry( \"am\", \"Amharic\", QCoreApplication::translate( \"Language\", \"Amharic\" ) );\n  addEntry( \"an\", \"Aragonese\", QCoreApplication::translate( \"Language\", \"Aragonese\" ) );\n  addEntry( \"ar\", \"Arabic\", QCoreApplication::translate( \"Language\", \"Arabic\" ) );\n  addEntry( \"as\", \"Assamese\", QCoreApplication::translate( \"Language\", \"Assamese\" ) );\n  addEntry( \"av\", \"Avaric\", QCoreApplication::translate( \"Language\", \"Avaric\" ) );\n  addEntry( \"ay\", \"Aymara\", QCoreApplication::translate( \"Language\", \"Aymara\" ) );\n  addEntry( \"az\", \"Azerbaijani\", QCoreApplication::translate( \"Language\", \"Azerbaijani\" ) );\n  addEntry( \"ba\", \"Bashkir\", QCoreApplication::translate( \"Language\", \"Bashkir\" ) );\n  addEntry( \"be\", \"Belarusian\", QCoreApplication::translate( \"Language\", \"Belarusian\" ) );\n  addEntry( \"bg\", \"Bulgarian\", QCoreApplication::translate( \"Language\", \"Bulgarian\" ) );\n  addEntry( \"bh\", \"Bihari\", QCoreApplication::translate( \"Language\", \"Bihari\" ) );\n  addEntry( \"bi\", \"Bislama\", QCoreApplication::translate( \"Language\", \"Bislama\" ) );\n  addEntry( \"bm\", \"Bambara\", QCoreApplication::translate( \"Language\", \"Bambara\" ) );\n  addEntry( \"bn\", \"Bengali\", QCoreApplication::translate( \"Language\", \"Bengali\" ) );\n  addEntry( \"bo\", \"Tibetan\", QCoreApplication::translate( \"Language\", \"Tibetan\" ) );\n  addEntry( \"br\", \"Breton\", QCoreApplication::translate( \"Language\", \"Breton\" ) );\n  addEntry( \"bs\", \"Bosnian\", QCoreApplication::translate( \"Language\", \"Bosnian\" ) );\n  addEntry( \"ca\", \"Catalan\", QCoreApplication::translate( \"Language\", \"Catalan\" ) );\n  addEntry( \"ce\", \"Chechen\", QCoreApplication::translate( \"Language\", \"Chechen\" ) );\n  addEntry( \"ch\", \"Chamorro\", QCoreApplication::translate( \"Language\", \"Chamorro\" ) );\n  addEntry( \"co\", \"Corsican\", QCoreApplication::translate( \"Language\", \"Corsican\" ) );\n  addEntry( \"cr\", \"Cree\", QCoreApplication::translate( \"Language\", \"Cree\" ) );\n  addEntry( \"cs\", \"Czech\", QCoreApplication::translate( \"Language\", \"Czech\" ) );\n  addEntry( \"cu\", \"Church Slavic\", QCoreApplication::translate( \"Language\", \"Church Slavic\" ) );\n  addEntry( \"cv\", \"Chuvash\", QCoreApplication::translate( \"Language\", \"Chuvash\" ) );\n  addEntry( \"cy\", \"Welsh\", QCoreApplication::translate( \"Language\", \"Welsh\" ) );\n  addEntry( \"da\", \"Danish\", QCoreApplication::translate( \"Language\", \"Danish\" ) );\n  addEntry( \"de\", \"German\", QCoreApplication::translate( \"Language\", \"German\" ) );\n  addEntry( \"dv\", \"Divehi\", QCoreApplication::translate( \"Language\", \"Divehi\" ) );\n  addEntry( \"dz\", \"Dzongkha\", QCoreApplication::translate( \"Language\", \"Dzongkha\" ) );\n  addEntry( \"ee\", \"Ewe\", QCoreApplication::translate( \"Language\", \"Ewe\" ) );\n  addEntry( \"el\", \"Greek\", QCoreApplication::translate( \"Language\", \"Greek\" ) );\n  addEntry( \"en\", \"English\", QCoreApplication::translate( \"Language\", \"English\" ) );\n  addEntry( \"eo\", \"Esperanto\", QCoreApplication::translate( \"Language\", \"Esperanto\" ) );\n  addEntry( \"es\", \"Spanish\", QCoreApplication::translate( \"Language\", \"Spanish\" ) );\n  addEntry( \"et\", \"Estonian\", QCoreApplication::translate( \"Language\", \"Estonian\" ) );\n  addEntry( \"eu\", \"Basque\", QCoreApplication::translate( \"Language\", \"Basque\" ) );\n  addEntry( \"fa\", \"Persian\", QCoreApplication::translate( \"Language\", \"Persian\" ) );\n  addEntry( \"ff\", \"Fulah\", QCoreApplication::translate( \"Language\", \"Fulah\" ) );\n  addEntry( \"fi\", \"Finnish\", QCoreApplication::translate( \"Language\", \"Finnish\" ) );\n  addEntry( \"fj\", \"Fijian\", QCoreApplication::translate( \"Language\", \"Fijian\" ) );\n  addEntry( \"fo\", \"Faroese\", QCoreApplication::translate( \"Language\", \"Faroese\" ) );\n  addEntry( \"fr\", \"French\", QCoreApplication::translate( \"Language\", \"French\" ) );\n  addEntry( \"fy\", \"Western Frisian\", QCoreApplication::translate( \"Language\", \"Western Frisian\" ) );\n  addEntry( \"ga\", \"Irish\", QCoreApplication::translate( \"Language\", \"Irish\" ) );\n  addEntry( \"gd\", \"Scottish Gaelic\", QCoreApplication::translate( \"Language\", \"Scottish Gaelic\" ) );\n  addEntry( \"gl\", \"Galician\", QCoreApplication::translate( \"Language\", \"Galician\" ) );\n  addEntry( \"gn\", \"Guarani\", QCoreApplication::translate( \"Language\", \"Guarani\" ) );\n  addEntry( \"gu\", \"Gujarati\", QCoreApplication::translate( \"Language\", \"Gujarati\" ) );\n  addEntry( \"gv\", \"Manx\", QCoreApplication::translate( \"Language\", \"Manx\" ) );\n  addEntry( \"ha\", \"Hausa\", QCoreApplication::translate( \"Language\", \"Hausa\" ) );\n  addEntry( \"he\", \"Hebrew\", QCoreApplication::translate( \"Language\", \"Hebrew\" ) );\n  addEntry( \"hi\", \"Hindi\", QCoreApplication::translate( \"Language\", \"Hindi\" ) );\n  addEntry( \"ho\", \"Hiri Motu\", QCoreApplication::translate( \"Language\", \"Hiri Motu\" ) );\n  addEntry( \"hr\", \"Croatian\", QCoreApplication::translate( \"Language\", \"Croatian\" ) );\n  addEntry( \"ht\", \"Haitian\", QCoreApplication::translate( \"Language\", \"Haitian\" ) );\n  addEntry( \"hu\", \"Hungarian\", QCoreApplication::translate( \"Language\", \"Hungarian\" ) );\n  addEntry( \"hy\", \"Armenian\", QCoreApplication::translate( \"Language\", \"Armenian\" ) );\n  addEntry( \"hz\", \"Herero\", QCoreApplication::translate( \"Language\", \"Herero\" ) );\n  addEntry( \"ia\", \"Interlingua\", QCoreApplication::translate( \"Language\", \"Interlingua\" ) );\n  addEntry( \"id\", \"Indonesian\", QCoreApplication::translate( \"Language\", \"Indonesian\" ) );\n  addEntry( \"ie\", \"Interlingue\", QCoreApplication::translate( \"Language\", \"Interlingue\" ) );\n  addEntry( \"ig\", \"Igbo\", QCoreApplication::translate( \"Language\", \"Igbo\" ) );\n  addEntry( \"ii\", \"Sichuan Yi\", QCoreApplication::translate( \"Language\", \"Sichuan Yi\" ) );\n  addEntry( \"ik\", \"Inupiaq\", QCoreApplication::translate( \"Language\", \"Inupiaq\" ) );\n  addEntry( \"io\", \"Ido\", QCoreApplication::translate( \"Language\", \"Ido\" ) );\n  addEntry( \"is\", \"Icelandic\", QCoreApplication::translate( \"Language\", \"Icelandic\" ) );\n  addEntry( \"it\", \"Italian\", QCoreApplication::translate( \"Language\", \"Italian\" ) );\n  addEntry( \"iu\", \"Inuktitut\", QCoreApplication::translate( \"Language\", \"Inuktitut\" ) );\n  addEntry( \"ja\", \"Japanese\", QCoreApplication::translate( \"Language\", \"Japanese\" ) );\n  addEntry( \"jv\", \"Javanese\", QCoreApplication::translate( \"Language\", \"Javanese\" ) );\n  addEntry( \"ka\", \"Georgian\", QCoreApplication::translate( \"Language\", \"Georgian\" ) );\n  addEntry( \"kg\", \"Kongo\", QCoreApplication::translate( \"Language\", \"Kongo\" ) );\n  addEntry( \"ki\", \"Kikuyu\", QCoreApplication::translate( \"Language\", \"Kikuyu\" ) );\n  addEntry( \"kj\", \"Kwanyama\", QCoreApplication::translate( \"Language\", \"Kwanyama\" ) );\n  addEntry( \"kk\", \"Kazakh\", QCoreApplication::translate( \"Language\", \"Kazakh\" ) );\n  addEntry( \"kl\", \"Kalaallisut\", QCoreApplication::translate( \"Language\", \"Kalaallisut\" ) );\n  addEntry( \"km\", \"Khmer\", QCoreApplication::translate( \"Language\", \"Khmer\" ) );\n  addEntry( \"kn\", \"Kannada\", QCoreApplication::translate( \"Language\", \"Kannada\" ) );\n  addEntry( \"ko\", \"Korean\", QCoreApplication::translate( \"Language\", \"Korean\" ) );\n  addEntry( \"kr\", \"Kanuri\", QCoreApplication::translate( \"Language\", \"Kanuri\" ) );\n  addEntry( \"ks\", \"Kashmiri\", QCoreApplication::translate( \"Language\", \"Kashmiri\" ) );\n  addEntry( \"ku\", \"Kurdish\", QCoreApplication::translate( \"Language\", \"Kurdish\" ) );\n  addEntry( \"kv\", \"Komi\", QCoreApplication::translate( \"Language\", \"Komi\" ) );\n  addEntry( \"kw\", \"Cornish\", QCoreApplication::translate( \"Language\", \"Cornish\" ) );\n  addEntry( \"ky\", \"Kirghiz\", QCoreApplication::translate( \"Language\", \"Kirghiz\" ) );\n  addEntry( \"la\", \"Latin\", QCoreApplication::translate( \"Language\", \"Latin\" ) );\n  addEntry( \"lb\", \"Luxembourgish\", QCoreApplication::translate( \"Language\", \"Luxembourgish\" ) );\n  addEntry( \"lg\", \"Ganda\", QCoreApplication::translate( \"Language\", \"Ganda\" ) );\n  addEntry( \"li\", \"Limburgish\", QCoreApplication::translate( \"Language\", \"Limburgish\" ) );\n  addEntry( \"ln\", \"Lingala\", QCoreApplication::translate( \"Language\", \"Lingala\" ) );\n  addEntry( \"lo\", \"Lao\", QCoreApplication::translate( \"Language\", \"Lao\" ) );\n  addEntry( \"lt\", \"Lithuanian\", QCoreApplication::translate( \"Language\", \"Lithuanian\" ) );\n  addEntry( \"lu\", \"Luba-Katanga\", QCoreApplication::translate( \"Language\", \"Luba-Katanga\" ) );\n  addEntry( \"lv\", \"Latvian\", QCoreApplication::translate( \"Language\", \"Latvian\" ) );\n  addEntry( \"mg\", \"Malagasy\", QCoreApplication::translate( \"Language\", \"Malagasy\" ) );\n  addEntry( \"mh\", \"Marshallese\", QCoreApplication::translate( \"Language\", \"Marshallese\" ) );\n  addEntry( \"mi\", \"Maori\", QCoreApplication::translate( \"Language\", \"Maori\" ) );\n  addEntry( \"mk\", \"Macedonian\", QCoreApplication::translate( \"Language\", \"Macedonian\" ) );\n  addEntry( \"ml\", \"Malayalam\", QCoreApplication::translate( \"Language\", \"Malayalam\" ) );\n  addEntry( \"mn\", \"Mongolian\", QCoreApplication::translate( \"Language\", \"Mongolian\" ) );\n  addEntry( \"mr\", \"Marathi\", QCoreApplication::translate( \"Language\", \"Marathi\" ) );\n  addEntry( \"ms\", \"Malay\", QCoreApplication::translate( \"Language\", \"Malay\" ) );\n  addEntry( \"mt\", \"Maltese\", QCoreApplication::translate( \"Language\", \"Maltese\" ) );\n  addEntry( \"my\", \"Burmese\", QCoreApplication::translate( \"Language\", \"Burmese\" ) );\n  addEntry( \"na\", \"Nauru\", QCoreApplication::translate( \"Language\", \"Nauru\" ) );\n  addEntry( \"nb\", \"Norwegian Bokmal\", QCoreApplication::translate( \"Language\", \"Norwegian Bokmal\" ) );\n  addEntry( \"nd\", \"North Ndebele\", QCoreApplication::translate( \"Language\", \"North Ndebele\" ) );\n  addEntry( \"ne\", \"Nepali\", QCoreApplication::translate( \"Language\", \"Nepali\" ) );\n  addEntry( \"ng\", \"Ndonga\", QCoreApplication::translate( \"Language\", \"Ndonga\" ) );\n  addEntry( \"nl\", \"Dutch\", QCoreApplication::translate( \"Language\", \"Dutch\" ) );\n  addEntry( \"nn\", \"Norwegian Nynorsk\", QCoreApplication::translate( \"Language\", \"Norwegian Nynorsk\" ) );\n  addEntry( \"no\", \"Norwegian\", QCoreApplication::translate( \"Language\", \"Norwegian\" ) );\n  addEntry( \"nr\", \"South Ndebele\", QCoreApplication::translate( \"Language\", \"South Ndebele\" ) );\n  addEntry( \"nv\", \"Navajo\", QCoreApplication::translate( \"Language\", \"Navajo\" ) );\n  addEntry( \"ny\", \"Chichewa\", QCoreApplication::translate( \"Language\", \"Chichewa\" ) );\n  addEntry( \"oc\", \"Occitan\", QCoreApplication::translate( \"Language\", \"Occitan\" ) );\n  addEntry( \"oj\", \"Ojibwa\", QCoreApplication::translate( \"Language\", \"Ojibwa\" ) );\n  addEntry( \"om\", \"Oromo\", QCoreApplication::translate( \"Language\", \"Oromo\" ) );\n  addEntry( \"or\", \"Oriya\", QCoreApplication::translate( \"Language\", \"Oriya\" ) );\n  addEntry( \"os\", \"Ossetian\", QCoreApplication::translate( \"Language\", \"Ossetian\" ) );\n  addEntry( \"pa\", \"Panjabi\", QCoreApplication::translate( \"Language\", \"Panjabi\" ) );\n  addEntry( \"pi\", \"Pali\", QCoreApplication::translate( \"Language\", \"Pali\" ) );\n  addEntry( \"pl\", \"Polish\", QCoreApplication::translate( \"Language\", \"Polish\" ) );\n  addEntry( \"ps\", \"Pashto\", QCoreApplication::translate( \"Language\", \"Pashto\" ) );\n  addEntry( \"pt\", \"Portuguese\", QCoreApplication::translate( \"Language\", \"Portuguese\" ) );\n  addEntry( \"qu\", \"Quechua\", QCoreApplication::translate( \"Language\", \"Quechua\" ) );\n  addEntry( \"rm\", \"Raeto-Romance\", QCoreApplication::translate( \"Language\", \"Raeto-Romance\" ) );\n  addEntry( \"rn\", \"Kirundi\", QCoreApplication::translate( \"Language\", \"Kirundi\" ) );\n  addEntry( \"ro\", \"Romanian\", QCoreApplication::translate( \"Language\", \"Romanian\" ) );\n  addEntry( \"ru\", \"Russian\", QCoreApplication::translate( \"Language\", \"Russian\" ) );\n  addEntry( \"rw\", \"Kinyarwanda\", QCoreApplication::translate( \"Language\", \"Kinyarwanda\" ) );\n  addEntry( \"sa\", \"Sanskrit\", QCoreApplication::translate( \"Language\", \"Sanskrit\" ) );\n  addEntry( \"sc\", \"Sardinian\", QCoreApplication::translate( \"Language\", \"Sardinian\" ) );\n  addEntry( \"sd\", \"Sindhi\", QCoreApplication::translate( \"Language\", \"Sindhi\" ) );\n  addEntry( \"se\", \"Northern Sami\", QCoreApplication::translate( \"Language\", \"Northern Sami\" ) );\n  addEntry( \"sg\", \"Sango\", QCoreApplication::translate( \"Language\", \"Sango\" ) );\n  addEntry( \"sh\", \"Serbo-Croatian\", QCoreApplication::translate( \"Language\", \"Serbo-Croatian\" ) );\n  addEntry( \"si\", \"Sinhala\", QCoreApplication::translate( \"Language\", \"Sinhala\" ) );\n  addEntry( \"sk\", \"Slovak\", QCoreApplication::translate( \"Language\", \"Slovak\" ) );\n  addEntry( \"sl\", \"Slovenian\", QCoreApplication::translate( \"Language\", \"Slovenian\" ) );\n  addEntry( \"sm\", \"Samoan\", QCoreApplication::translate( \"Language\", \"Samoan\" ) );\n  addEntry( \"sn\", \"Shona\", QCoreApplication::translate( \"Language\", \"Shona\" ) );\n  addEntry( \"so\", \"Somali\", QCoreApplication::translate( \"Language\", \"Somali\" ) );\n  addEntry( \"sq\", \"Albanian\", QCoreApplication::translate( \"Language\", \"Albanian\" ) );\n  addEntry( \"sr\", \"Serbian\", QCoreApplication::translate( \"Language\", \"Serbian\" ) );\n  addEntry( \"ss\", \"Swati\", QCoreApplication::translate( \"Language\", \"Swati\" ) );\n  addEntry( \"st\", \"Southern Sotho\", QCoreApplication::translate( \"Language\", \"Southern Sotho\" ) );\n  addEntry( \"su\", \"Sundanese\", QCoreApplication::translate( \"Language\", \"Sundanese\" ) );\n  addEntry( \"sv\", \"Swedish\", QCoreApplication::translate( \"Language\", \"Swedish\" ) );\n  addEntry( \"sw\", \"Swahili\", QCoreApplication::translate( \"Language\", \"Swahili\" ) );\n  addEntry( \"ta\", \"Tamil\", QCoreApplication::translate( \"Language\", \"Tamil\" ) );\n  addEntry( \"te\", \"Telugu\", QCoreApplication::translate( \"Language\", \"Telugu\" ) );\n  addEntry( \"tg\", \"Tajik\", QCoreApplication::translate( \"Language\", \"Tajik\" ) );\n  addEntry( \"th\", \"Thai\", QCoreApplication::translate( \"Language\", \"Thai\" ) );\n  addEntry( \"ti\", \"Tigrinya\", QCoreApplication::translate( \"Language\", \"Tigrinya\" ) );\n  addEntry( \"tk\", \"Turkmen\", QCoreApplication::translate( \"Language\", \"Turkmen\" ) );\n  addEntry( \"tl\", \"Tagalog\", QCoreApplication::translate( \"Language\", \"Tagalog\" ) );\n  addEntry( \"tn\", \"Tswana\", QCoreApplication::translate( \"Language\", \"Tswana\" ) );\n  addEntry( \"to\", \"Tonga\", QCoreApplication::translate( \"Language\", \"Tonga\" ) );\n  addEntry( \"tr\", \"Turkish\", QCoreApplication::translate( \"Language\", \"Turkish\" ) );\n  addEntry( \"ts\", \"Tsonga\", QCoreApplication::translate( \"Language\", \"Tsonga\" ) );\n  addEntry( \"tt\", \"Tatar\", QCoreApplication::translate( \"Language\", \"Tatar\" ) );\n  addEntry( \"tw\", \"Twi\", QCoreApplication::translate( \"Language\", \"Twi\" ) );\n  addEntry( \"ty\", \"Tahitian\", QCoreApplication::translate( \"Language\", \"Tahitian\" ) );\n  addEntry( \"ug\", \"Uighur\", QCoreApplication::translate( \"Language\", \"Uighur\" ) );\n  addEntry( \"uk\", \"Ukrainian\", QCoreApplication::translate( \"Language\", \"Ukrainian\" ) );\n  addEntry( \"ur\", \"Urdu\", QCoreApplication::translate( \"Language\", \"Urdu\" ) );\n  addEntry( \"uz\", \"Uzbek\", QCoreApplication::translate( \"Language\", \"Uzbek\" ) );\n  addEntry( \"ve\", \"Venda\", QCoreApplication::translate( \"Language\", \"Venda\" ) );\n  addEntry( \"vi\", \"Vietnamese\", QCoreApplication::translate( \"Language\", \"Vietnamese\" ) );\n  addEntry( \"vo\", \"Volapuk\", QCoreApplication::translate( \"Language\", \"Volapuk\" ) );\n  addEntry( \"wa\", \"Walloon\", QCoreApplication::translate( \"Language\", \"Walloon\" ) );\n  addEntry( \"wo\", \"Wolof\", QCoreApplication::translate( \"Language\", \"Wolof\" ) );\n  addEntry( \"xh\", \"Xhosa\", QCoreApplication::translate( \"Language\", \"Xhosa\" ) );\n  addEntry( \"yi\", \"Yiddish\", QCoreApplication::translate( \"Language\", \"Yiddish\" ) );\n  addEntry( \"yo\", \"Yoruba\", QCoreApplication::translate( \"Language\", \"Yoruba\" ) );\n  addEntry( \"za\", \"Zhuang\", QCoreApplication::translate( \"Language\", \"Zhuang\" ) );\n  addEntry( \"zh\", \"Chinese\", QCoreApplication::translate( \"Language\", \"Chinese\" ) );\n  addEntry( \"zu\", \"Zulu\", QCoreApplication::translate( \"Language\", \"Zulu\" ) );\n  addEntry( \"jb\", \"Lojban\", QCoreApplication::translate( \"Language\", \"Lojban\" ) );\n\n  // Countries\n\n  iso2ToCountry[ \"aa\" ] = \"et\";\n  iso2ToCountry[ \"af\" ] = \"za\";\n  iso2ToCountry[ \"am\" ] = \"et\";\n  iso2ToCountry[ \"an\" ] = \"es\";\n  iso2ToCountry[ \"ar\" ] = \"ae\";\n  iso2ToCountry[ \"as\" ] = \"in\";\n  iso2ToCountry[ \"az\" ] = \"az\";\n  iso2ToCountry[ \"be\" ] = \"by\";\n  iso2ToCountry[ \"bg\" ] = \"bg\";\n  iso2ToCountry[ \"bn\" ] = \"bd\";\n  iso2ToCountry[ \"bo\" ] = \"cn\";\n  iso2ToCountry[ \"br\" ] = \"fr\";\n  iso2ToCountry[ \"bs\" ] = \"ba\";\n  iso2ToCountry[ \"ca\" ] = \"ct\";\n  iso2ToCountry[ \"cs\" ] = \"cz\";\n  iso2ToCountry[ \"cy\" ] = \"gb\";\n  iso2ToCountry[ \"da\" ] = \"dk\";\n  iso2ToCountry[ \"de\" ] = \"de\";\n  iso2ToCountry[ \"dz\" ] = \"bt\";\n  iso2ToCountry[ \"el\" ] = \"gr\";\n  iso2ToCountry[ \"en\" ] = \"gb\";\n  iso2ToCountry[ \"es\" ] = \"es\";\n  iso2ToCountry[ \"et\" ] = \"ee\";\n  iso2ToCountry[ \"eu\" ] = \"es\";\n  iso2ToCountry[ \"fa\" ] = \"ir\";\n  iso2ToCountry[ \"fi\" ] = \"fi\";\n  iso2ToCountry[ \"fo\" ] = \"fo\";\n  iso2ToCountry[ \"fr\" ] = \"fr\";\n  iso2ToCountry[ \"fy\" ] = \"nl\";\n  iso2ToCountry[ \"ga\" ] = \"ie\";\n  iso2ToCountry[ \"gd\" ] = \"gb\";\n  iso2ToCountry[ \"gl\" ] = \"es\";\n  iso2ToCountry[ \"gu\" ] = \"in\";\n  iso2ToCountry[ \"gv\" ] = \"gb\";\n  iso2ToCountry[ \"ha\" ] = \"ng\";\n  iso2ToCountry[ \"he\" ] = \"il\";\n  iso2ToCountry[ \"hi\" ] = \"in\";\n  iso2ToCountry[ \"hr\" ] = \"hr\";\n  iso2ToCountry[ \"ht\" ] = \"ht\";\n  iso2ToCountry[ \"hu\" ] = \"hu\";\n  iso2ToCountry[ \"hy\" ] = \"am\";\n  iso2ToCountry[ \"id\" ] = \"id\";\n  iso2ToCountry[ \"ig\" ] = \"ng\";\n  iso2ToCountry[ \"ik\" ] = \"ca\";\n  iso2ToCountry[ \"is\" ] = \"is\";\n  iso2ToCountry[ \"it\" ] = \"it\";\n  iso2ToCountry[ \"iu\" ] = \"ca\";\n  iso2ToCountry[ \"iw\" ] = \"il\";\n  iso2ToCountry[ \"ja\" ] = \"jp\";\n  iso2ToCountry[ \"jb\" ] = \"jb\";\n  iso2ToCountry[ \"ka\" ] = \"ge\";\n  iso2ToCountry[ \"kk\" ] = \"kz\";\n  iso2ToCountry[ \"kl\" ] = \"gl\";\n  iso2ToCountry[ \"km\" ] = \"kh\";\n  iso2ToCountry[ \"kn\" ] = \"in\";\n  iso2ToCountry[ \"ko\" ] = \"kr\";\n  iso2ToCountry[ \"ku\" ] = \"tr\";\n  iso2ToCountry[ \"kw\" ] = \"gb\";\n  iso2ToCountry[ \"ky\" ] = \"kg\";\n  iso2ToCountry[ \"lg\" ] = \"ug\";\n  iso2ToCountry[ \"li\" ] = \"be\";\n  iso2ToCountry[ \"lo\" ] = \"la\";\n  iso2ToCountry[ \"lt\" ] = \"lt\";\n  iso2ToCountry[ \"lv\" ] = \"lv\";\n  iso2ToCountry[ \"mg\" ] = \"mg\";\n  iso2ToCountry[ \"mi\" ] = \"nz\";\n  iso2ToCountry[ \"mk\" ] = \"mk\";\n  iso2ToCountry[ \"ml\" ] = \"in\";\n  iso2ToCountry[ \"mn\" ] = \"mn\";\n  iso2ToCountry[ \"mr\" ] = \"in\";\n  iso2ToCountry[ \"ms\" ] = \"my\";\n  iso2ToCountry[ \"mt\" ] = \"mt\";\n  iso2ToCountry[ \"nb\" ] = \"no\";\n  iso2ToCountry[ \"ne\" ] = \"np\";\n  iso2ToCountry[ \"nl\" ] = \"nl\";\n  iso2ToCountry[ \"nn\" ] = \"no\";\n  iso2ToCountry[ \"nr\" ] = \"za\";\n  iso2ToCountry[ \"oc\" ] = \"fr\";\n  iso2ToCountry[ \"om\" ] = \"et\";\n  iso2ToCountry[ \"or\" ] = \"in\";\n  iso2ToCountry[ \"pa\" ] = \"pk\";\n  iso2ToCountry[ \"pl\" ] = \"pl\";\n  iso2ToCountry[ \"pt\" ] = \"pt\";\n  iso2ToCountry[ \"ro\" ] = \"ro\";\n  iso2ToCountry[ \"ru\" ] = \"ru\";\n  iso2ToCountry[ \"rw\" ] = \"rw\";\n  iso2ToCountry[ \"sa\" ] = \"in\";\n  iso2ToCountry[ \"sc\" ] = \"it\";\n  iso2ToCountry[ \"sd\" ] = \"in\";\n  iso2ToCountry[ \"se\" ] = \"no\";\n  iso2ToCountry[ \"si\" ] = \"lk\";\n  iso2ToCountry[ \"sk\" ] = \"sk\";\n  iso2ToCountry[ \"sl\" ] = \"si\";\n  iso2ToCountry[ \"so\" ] = \"so\";\n  iso2ToCountry[ \"sq\" ] = \"al\";\n  iso2ToCountry[ \"sr\" ] = \"rs\";\n  iso2ToCountry[ \"ss\" ] = \"za\";\n  iso2ToCountry[ \"st\" ] = \"za\";\n  iso2ToCountry[ \"sv\" ] = \"se\";\n  iso2ToCountry[ \"ta\" ] = \"in\";\n  iso2ToCountry[ \"te\" ] = \"in\";\n  iso2ToCountry[ \"tg\" ] = \"tj\";\n  iso2ToCountry[ \"th\" ] = \"th\";\n  iso2ToCountry[ \"ti\" ] = \"er\";\n  iso2ToCountry[ \"tk\" ] = \"tm\";\n  iso2ToCountry[ \"tl\" ] = \"ph\";\n  iso2ToCountry[ \"tn\" ] = \"za\";\n  iso2ToCountry[ \"tr\" ] = \"tr\";\n  iso2ToCountry[ \"ts\" ] = \"za\";\n  iso2ToCountry[ \"tt\" ] = \"ru\";\n  iso2ToCountry[ \"ug\" ] = \"cn\";\n  iso2ToCountry[ \"uk\" ] = \"ua\";\n  iso2ToCountry[ \"ur\" ] = \"pk\";\n  iso2ToCountry[ \"uz\" ] = \"uz\";\n  iso2ToCountry[ \"ve\" ] = \"za\";\n  iso2ToCountry[ \"vi\" ] = \"vn\";\n  iso2ToCountry[ \"wa\" ] = \"be\";\n  iso2ToCountry[ \"wo\" ] = \"sn\";\n  iso2ToCountry[ \"xh\" ] = \"za\";\n  iso2ToCountry[ \"yi\" ] = \"us\";\n  iso2ToCountry[ \"yo\" ] = \"ng\";\n  iso2ToCountry[ \"zh\" ] = \"cn\";\n  iso2ToCountry[ \"zu\" ] = \"za\";\n}\n\n}\n\n/// babylon languages\n#ifndef blgCode2Int\n#define blgCode2Int( index, code0, code1 ) (((uint32_t)index) << 16 ) + (((uint32_t)code1) << 8 ) + (uint32_t)code0\n#endif\nconst BabylonLang BabylonDb[] ={\n    { blgCode2Int( 1, 'z', 'h' ), \"tw\", \"Traditional Chinese\", QT_TR_NOOP( \"Traditional Chinese\" ) },\n    { blgCode2Int( 2, 'z', 'h' ), \"cn\", \"Simplified Chinese\", QT_TR_NOOP( \"Simplified Chinese\" ) },\n    { blgCode2Int( 3, 0, 0 ), \"other\", \"Other\", QT_TR_NOOP( \"Other\" ) },\n    { blgCode2Int( 4, 'z', 'h' ), \"cn\", \"Other Simplified Chinese dialects\", QT_TR_NOOP( \"Other Simplified Chinese dialects\" ) },\n    { blgCode2Int( 5, 'z', 'h' ), \"tw\", \"Other Traditional Chinese dialects\", QT_TR_NOOP( \"Other Traditional Chinese dialects\" ) },\n    { blgCode2Int( 6, 0, 0 ), \"other\", \"Other Eastern-European languages\", QT_TR_NOOP( \"Other Eastern-European languages\" ) },\n    { blgCode2Int( 7, 0, 0 ), \"other\", \"Other Western-European languages\", QT_TR_NOOP( \"Other Western-European languages\" )},\n    { blgCode2Int( 8, 'r', 'u' ), \"ru\", \"Other Russian languages\", QT_TR_NOOP( \"Other Russian languages\" ) },\n    { blgCode2Int( 9, 'j', 'a' ), \"jp\", \"Other Japanese languages\", QT_TR_NOOP( \"Other Japanese languages\" ) },\n    { blgCode2Int( 10, 0, 0 ), \"other\", \"Other Baltic languages\", QT_TR_NOOP( \"Other Baltic languages\" )},\n    { blgCode2Int( 11, 'e', 'l' ), \"gr\", \"Other Greek languages\", QT_TR_NOOP( \"Other Greek languages\" ) },\n    { blgCode2Int( 12, 'k', 'o' ), \"kr\", \"Other Korean dialects\", QT_TR_NOOP( \"Other Korean dialects\" ) },\n    { blgCode2Int( 13, 't', 'r' ), \"tr\", \"Other Turkish dialects\", QT_TR_NOOP( \"Other Turkish dialects\" ) },\n    { blgCode2Int( 14, 't', 'h' ), \"th\", \"Other Thai dialects\", QT_TR_NOOP( \"Other Thai dialects\" ) },\n    { blgCode2Int( 15, 0, 0 ), \"dz\", \"Tamazight\", QT_TR_NOOP( \"Tamazight\" ) }\n};\n\nBabylonLang getBabylonLangByIndex( int index )\n{\n    return BabylonDb[ index ];\n}\n\nquint32 findBlgLangIDByEnglishName( gd::wstring const & lang )\n{\n    QString enName = gd::toQString( lang );\n    for( int idx=0;idx < 15 ; ++idx )\n    {\n        if( QString::compare( BabylonDb[ idx ].englishName, enName, Qt::CaseInsensitive  ) == 0 )\n            return BabylonDb[ idx ].id;\n    }\n    return 0;\n}\n\nQString englishNameForId( Id id )\n{\n    if(  id >= 0x010000 && id <= 0x0fffff ) //babylon\n    {\n        return BabylonDb[ ( (id >> 16 ) & 0x0f) - 1 ].englishName;\n    }\n  map< QString, QString >::const_iterator i =\n      Db::instance().getIso2ToEnglish().find( LangCoder::intToCode2( id ) );\n\n  if ( i == Db::instance().getIso2ToEnglish().end() )\n    return QString();\n\n  return i->second;\n}\n\nQString localizedNameForId( Id id )\n{\n    if(  id >= 0x010000 && id <= 0x0fffff ) //babylon\n    {\n        return QCoreApplication::translate( \"Language\", BabylonDb[ ( ( id >> 16 ) & 0x0f ) - 1 ].localizedName );\n    }\n  map< QString, QString >::const_iterator i =\n      Db::instance().getIso2ToLocalized().find( LangCoder::intToCode2( id ) );\n\n  if ( i == Db::instance().getIso2ToLocalized().end() )\n    return QString();\n\n  return i->second;\n}\n\nQString countryCodeForId( Id id )\n{\n    if(  id >= 0x010000 && id <= 0x0fffff ) //babylon\n    {\n        return BabylonDb[ ( ( id >> 16 ) & 0x0f ) - 1 ].contryCode;\n    }\n  map< QString, QString >::const_iterator i =\n      Db::instance().getIso2ToCountry().find( LangCoder::intToCode2( id ) );\n\n  if ( i == Db::instance().getIso2ToCountry().end() )\n    return QString();\n\n  return i->second;\n}\n\nQString localizedStringForId( Id langId )\n{\n    QString name = localizedNameForId( langId );\n\n    if ( name.isEmpty() )\n      return name;\n\n    QString iconId = countryCodeForId( langId );\n\n    if( iconId.isEmpty() )\n      return name;\n    else\n      return QString( \"<img src=\\\":/flags/%1.png\\\"> %2\" ).arg( iconId ).arg( name );\n  }\n}\n"
        },
        {
          "name": "language.hh",
          "type": "blob",
          "size": 1.7998046875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __LANGUAGE_HH_INCLUDED__\n#define __LANGUAGE_HH_INCLUDED__\n\n#include <QString>\n#include \"wstring_qt.hh\"\n/// Language-specific stuff - codes, names, ids etc.\nnamespace Language {\n\n/// This identifies any language uniquely within the program. It also has\n/// two special meanings - Unknown and Any.\ntypedef quint32 Id;\n\nenum\n{\n  /// Value for Id which signifies that the language is unknown or unspecified.\n  Unknown = 0,\n  /// Value for Id which signifies that the language can be any, or all of them.\n  Any =  0xFFffFFff\n};\n\n/// Returns name in English for the given Id. If the Id is incorrect, or has\n/// Unknown/Any values, returns empty string.\nQString englishNameForId( Id );\n\n/// Returns name for the given Id, translated to the current UI language.\n/// If the Id is incorrect, or has Unknown/Any values, returns empty string.\nQString localizedNameForId( Id );\n\n/// Returns a two-letter code of a country which speaks the given language.\n/// This is useful for picking up icons for languages. If there's no\n/// corresponding country it the database, returns an empty strings.\nQString countryCodeForId( Id );\n\n/// Returns name for the given Id, translated to the current UI language, wish corresponding image tag.\n/// If the Id is incorrect, or has Unknown/Any values, returns empty string.\nQString localizedStringForId( Id );\n\n// All other functions are to be used from LangCoder, which is supposed to\n// be migrated here over time.\n\nstruct BabylonLang{\n    Id id;\n    const QString contryCode;\n    const QString englishName;\n    const char * localizedName;\n};\nBabylonLang getBabylonLangByIndex( int index );\nquint32 findBlgLangIDByEnglishName( gd::wstring const & lang );\n}\n\n#endif\n"
        },
        {
          "name": "lionsupport.h",
          "type": "blob",
          "size": 0.3955078125,
          "content": "#ifndef LIONSUPPORT_H\n#define LIONSUPPORT_H\n\n#include \"mainwindow.hh\"\n\nclass LionSupport\n{\npublic:\n    /**\n     * Returns whether the current system is Lion.\n     */\n    static bool isLion();\n\n    /**\n     * Adds fullscreen button to window for Lion.\n     */\n    static void addFullscreen(MainWindow *window);\n\n    //Check for retina display\n    static bool isRetinaDisplay();\n};\n\n#endif // LIONSUPPORT_H\n"
        },
        {
          "name": "lionsupport.mm",
          "type": "blob",
          "size": 1.126953125,
          "content": "#include <AppKit/NSWindow.h>\n#include <AppKit/NSScreen.h>\n#include \"lionsupport.h\"\n\nbool LionSupport::isLion()\n{\n    NSString *string = [NSString string];\n    // this selector was added only in Lion. so we can check if it's responding, we are on Lion\n    return [string respondsToSelector:@selector(linguisticTagsInRange:scheme:options:orthography:tokenRanges:)];\n}\n\nvoid LionSupport::addFullscreen(MainWindow *window)\n{\n#if defined(MAC_OS_X_VERSION_10_7) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7\n    if (isLion()) // checks if lion is running\n    {\n        NSView *nsview = (NSView *) window->winId();\n        NSWindow *nswindow = [nsview window];\n        [nswindow setCollectionBehavior:NSWindowCollectionBehaviorFullScreenPrimary];\n    }\n#else\n#warning No fullscreen support will be included in this build\n#endif\n}\n\nbool LionSupport::isRetinaDisplay()\n{\n#if defined(MAC_OS_X_VERSION_10_7) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7\n  return( [ [ NSScreen mainScreen ] respondsToSelector:@selector( backingScaleFactor ) ]\n          && [ [ NSScreen mainScreen ] backingScaleFactor ] > 1.5 );\n#else\n  return false;\n#endif\n}\n"
        },
        {
          "name": "loaddictionaries.cc",
          "type": "blob",
          "size": 13.103515625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"loaddictionaries.hh\"\n#include \"initializing.hh\"\n#include \"bgl.hh\"\n#include \"stardict.hh\"\n#include \"lsa.hh\"\n#include \"dsl.hh\"\n#include \"mediawiki.hh\"\n#include \"sounddir.hh\"\n#include \"hunspell.hh\"\n#include \"dictdfiles.hh\"\n#include \"romaji.hh\"\n#include \"russiantranslit.hh\"\n#include \"german.hh\"\n#include \"greektranslit.hh\"\n#include \"belarusiantranslit.hh\"\n#include \"website.hh\"\n#include \"forvo.hh\"\n#include \"programs.hh\"\n#include \"voiceengines.hh\"\n#include \"gddebug.hh\"\n#include \"fsencoding.hh\"\n#include \"xdxf.hh\"\n#include \"sdict.hh\"\n#include \"aard.hh\"\n#include \"zipsounds.hh\"\n#include \"mdx.hh\"\n#include \"zim.hh\"\n#include \"dictserver.hh\"\n#include \"slob.hh\"\n#include \"gls.hh\"\n\n#ifndef NO_EPWING_SUPPORT\n#include \"epwing.hh\"\n#endif\n\n#ifdef MAKE_CHINESE_CONVERSION_SUPPORT\n#include \"chinese.hh\"\n#endif\n\n#include <QMessageBox>\n#include <QDir>\n\n#include <set>\n\nusing std::set;\n\nusing std::string;\nusing std::vector;\n\nLoadDictionaries::LoadDictionaries( Config::Class const & cfg ):\n  paths( cfg.paths ), soundDirs( cfg.soundDirs ), hunspell( cfg.hunspell ),\n  transliteration( cfg.transliteration ),\n  exceptionText( \"Load did not finish\" ), // Will be cleared upon success\n  maxPictureWidth( cfg.maxPictureWidth ),\n  maxHeadwordSize( cfg.maxHeadwordSize ),\n  maxHeadwordToExpand( cfg.maxHeadwordsToExpand )\n{\n  // Populate name filters\n\n  nameFilters << \"*.bgl\" << \"*.ifo\" << \"*.lsa\" << \"*.dat\"\n              << \"*.dsl\" << \"*.dsl.dz\"  << \"*.index\" << \"*.xdxf\"\n              << \"*.xdxf.dz\" << \"*.dct\" << \"*.aar\" << \"*.zips\"\n              << \"*.mdx\" << \"*.gls\" << \"*.gls.dz\"\n#ifdef MAKE_ZIM_SUPPORT\n              << \"*.zim\" << \"*.zimaa\" << \"*.slob\"\n#endif\n#ifndef NO_EPWING_SUPPORT\n              << \"*catalogs\"\n#endif\n;\n}\n\nvoid LoadDictionaries::run()\n{\n  try\n  {\n    for( Config::Paths::const_iterator i = paths.begin(); i != paths.end(); ++i )\n      handlePath( *i );\n\n    // Make soundDirs\n    {\n      vector< sptr< Dictionary::Class > > soundDirDictionaries =\n        SoundDir::makeDictionaries( soundDirs, FsEncoding::encode( Config::getIndexDir() ), *this );\n\n      dictionaries.insert( dictionaries.end(), soundDirDictionaries.begin(),\n                           soundDirDictionaries.end() );\n    }\n\n    // Make hunspells\n    {\n      vector< sptr< Dictionary::Class > > hunspellDictionaries =\n        HunspellMorpho::makeDictionaries( hunspell );\n\n      dictionaries.insert( dictionaries.end(), hunspellDictionaries.begin(),\n                           hunspellDictionaries.end() );\n    }\n\n    exceptionText.clear();\n  }\n  catch( std::exception & e )\n  {\n    exceptionText = e.what();\n  }\n}\n\nvoid LoadDictionaries::handlePath( Config::Path const & path )\n{\n  vector< string > allFiles;\n\n  QDir dir( path.path );\n\n  QFileInfoList entries = dir.entryInfoList( nameFilters, QDir::AllDirs | QDir::Files | QDir::NoDotAndDotDot );\n\n  for( QFileInfoList::const_iterator i = entries.constBegin();\n       i != entries.constEnd(); ++i )\n  {\n    QString fullName = i->absoluteFilePath();\n\n    if ( path.recursive && i->isDir() )\n    {\n      // Make sure the path doesn't look like with dsl resources\n      if ( !fullName.endsWith( \".dsl.files\", Qt::CaseInsensitive ) &&\n           !fullName.endsWith( \".dsl.dz.files\", Qt::CaseInsensitive ) )\n        handlePath( Config::Path( fullName, true ) );\n    }\n\n    if ( !i->isDir() )\n      allFiles.push_back( FsEncoding::encode( QDir::toNativeSeparators( fullName ) ) );\n  }\n\n  {\n    vector< sptr< Dictionary::Class > > bglDictionaries =\n      Bgl::makeDictionaries( allFiles, FsEncoding::encode( Config::getIndexDir() ), *this );\n\n    dictionaries.insert( dictionaries.end(), bglDictionaries.begin(),\n                         bglDictionaries.end() );\n  }\n\n  {\n    vector< sptr< Dictionary::Class > > stardictDictionaries =\n      Stardict::makeDictionaries( allFiles, FsEncoding::encode( Config::getIndexDir() ), *this, maxHeadwordToExpand );\n\n    dictionaries.insert( dictionaries.end(), stardictDictionaries.begin(),\n                         stardictDictionaries.end() );\n  }\n\n  {\n    vector< sptr< Dictionary::Class > > lsaDictionaries =\n      Lsa::makeDictionaries( allFiles, FsEncoding::encode( Config::getIndexDir() ), *this );\n\n    dictionaries.insert( dictionaries.end(), lsaDictionaries.begin(),\n                         lsaDictionaries.end() );\n  }\n\n  {\n    vector< sptr< Dictionary::Class > > dslDictionaries =\n      Dsl::makeDictionaries(\n          allFiles, FsEncoding::encode( Config::getIndexDir() ), *this, maxPictureWidth, maxHeadwordSize );\n\n    dictionaries.insert( dictionaries.end(), dslDictionaries.begin(),\n                         dslDictionaries.end() );\n  }\n\n  {\n    vector< sptr< Dictionary::Class > > dictdDictionaries =\n      DictdFiles::makeDictionaries( allFiles, FsEncoding::encode( Config::getIndexDir() ), *this );\n\n    dictionaries.insert( dictionaries.end(), dictdDictionaries.begin(),\n                         dictdDictionaries.end() );\n  }\n  {\n    vector< sptr< Dictionary::Class > > xdxfDictionaries =\n      Xdxf::makeDictionaries( allFiles, FsEncoding::encode( Config::getIndexDir() ), *this );\n\n    dictionaries.insert( dictionaries.end(), xdxfDictionaries.begin(),\n                         xdxfDictionaries.end() );\n  }\n  {\n    vector< sptr< Dictionary::Class > > sdictDictionaries =\n      Sdict::makeDictionaries( allFiles, FsEncoding::encode( Config::getIndexDir() ), *this );\n\n    dictionaries.insert( dictionaries.end(), sdictDictionaries.begin(),\n                         sdictDictionaries.end() );\n  }\n  {\n    vector< sptr< Dictionary::Class > > aardDictionaries =\n      Aard::makeDictionaries( allFiles, FsEncoding::encode( Config::getIndexDir() ), *this, maxHeadwordToExpand );\n\n    dictionaries.insert( dictionaries.end(), aardDictionaries.begin(),\n                         aardDictionaries.end() );\n  }\n  {\n    vector< sptr< Dictionary::Class > > zipSoundsDictionaries =\n      ZipSounds::makeDictionaries( allFiles, FsEncoding::encode( Config::getIndexDir() ), *this );\n\n    dictionaries.insert( dictionaries.end(), zipSoundsDictionaries.begin(),\n                         zipSoundsDictionaries.end() );\n  }\n  {\n    vector< sptr< Dictionary::Class > > mdxDictionaries =\n      Mdx::makeDictionaries( allFiles, FsEncoding::encode( Config::getIndexDir() ), *this );\n\n    dictionaries.insert( dictionaries.end(), mdxDictionaries.begin(),\n                         mdxDictionaries.end() );\n  }\n  {\n    vector< sptr< Dictionary::Class > > glsDictionaries =\n      Gls::makeDictionaries( allFiles, FsEncoding::encode( Config::getIndexDir() ), *this );\n\n    dictionaries.insert( dictionaries.end(), glsDictionaries.begin(),\n                         glsDictionaries.end() );\n  }\n#ifdef MAKE_ZIM_SUPPORT\n  {\n    vector< sptr< Dictionary::Class > > zimDictionaries =\n      Zim::makeDictionaries( allFiles, FsEncoding::encode( Config::getIndexDir() ), *this, maxHeadwordToExpand );\n\n    dictionaries.insert( dictionaries.end(), zimDictionaries.begin(),\n                         zimDictionaries.end() );\n  }\n  {\n    vector< sptr< Dictionary::Class > > slobDictionaries =\n      Slob::makeDictionaries( allFiles, FsEncoding::encode( Config::getIndexDir() ), *this, maxHeadwordToExpand );\n\n    dictionaries.insert( dictionaries.end(), slobDictionaries.begin(),\n                         slobDictionaries.end() );\n  }\n#endif\n#ifndef NO_EPWING_SUPPORT\n  {\n    vector< sptr< Dictionary::Class > > epwingDictionaries =\n      Epwing::makeDictionaries( allFiles, FsEncoding::encode( Config::getIndexDir() ), *this );\n\n    dictionaries.insert( dictionaries.end(), epwingDictionaries.begin(),\n                         epwingDictionaries.end() );\n  }\n#endif\n}\n\nvoid LoadDictionaries::indexingDictionary( string const & dictionaryName ) throw()\n{\n  emit indexingDictionarySignal( QString::fromUtf8( dictionaryName.c_str() ) );\n}\n\n\nvoid loadDictionaries( QWidget * parent, bool showInitially,\n                       Config::Class const & cfg,\n                       std::vector< sptr< Dictionary::Class > > & dictionaries,\n                       QNetworkAccessManager & dictNetMgr,\n                       bool doDeferredInit_ )\n{\n  dictionaries.clear();\n\n  ::Initializing init( parent, showInitially );\n\n  // Start a thread to load all the dictionaries\n\n  LoadDictionaries loadDicts( cfg );\n\n  QObject::connect( &loadDicts, SIGNAL( indexingDictionarySignal( QString const & ) ),\n                    &init, SLOT( indexing( QString const & ) ) );\n\n  QEventLoop localLoop;\n\n  QObject::connect( &loadDicts, SIGNAL( finished() ),\n                    &localLoop, SLOT( quit() ) );\n\n  loadDicts.start();\n\n  localLoop.exec();\n\n  loadDicts.wait();\n\n  if ( loadDicts.getExceptionText().size() )\n  {\n    QMessageBox::critical( parent, QCoreApplication::translate( \"LoadDictionaries\", \"Error loading dictionaries\" ),\n                           QString::fromUtf8( loadDicts.getExceptionText().c_str() ) );\n\n    return;\n  }\n\n  dictionaries = loadDicts.getDictionaries();\n\n  ///// We create transliterations synchronously since they are very simple\n\n#ifdef MAKE_CHINESE_CONVERSION_SUPPORT\n  // Make Chinese conversion\n  {\n    vector< sptr< Dictionary::Class > > chineseDictionaries =\n      Chinese::makeDictionaries( cfg.transliteration.chinese );\n\n    dictionaries.insert( dictionaries.end(), chineseDictionaries.begin(),\n                         chineseDictionaries.end() );\n  }\n#endif\n\n  // Make Romaji\n  {\n    vector< sptr< Dictionary::Class > > romajiDictionaries =\n      Romaji::makeDictionaries( cfg.transliteration.romaji );\n\n    dictionaries.insert( dictionaries.end(), romajiDictionaries.begin(),\n                         romajiDictionaries.end() );\n  }\n\n  // Make Russian transliteration\n  if ( cfg.transliteration.enableRussianTransliteration )\n    dictionaries.push_back( RussianTranslit::makeDictionary() );\n\n  // Make German transliteration\n  if ( cfg.transliteration.enableGermanTransliteration )\n    dictionaries.push_back( GermanTranslit::makeDictionary() );\n\n  // Make Greek transliteration\n  if ( cfg.transliteration.enableGreekTransliteration )\n    dictionaries.push_back( GreekTranslit::makeDictionary() );\n\n  // Make Belarusian transliteration\n  if ( cfg.transliteration.enableBelarusianTransliteration )\n  {\n    vector< sptr< Dictionary::Class > > dicts = BelarusianTranslit::makeDictionaries();\n    dictionaries.insert( dictionaries.end(), dicts.begin(), dicts.end() );\n  }\n\n  ///// We create MediaWiki dicts synchronously, since they use netmgr\n\n  {\n    vector< sptr< Dictionary::Class > > dicts =\n      MediaWiki::makeDictionaries( loadDicts, cfg.mediawikis, dictNetMgr );\n\n    dictionaries.insert( dictionaries.end(), dicts.begin(), dicts.end() );\n  }\n\n  ///// WebSites are very simple, no need to create them asynchronously\n  {\n    vector< sptr< Dictionary::Class > > dicts =\n      WebSite::makeDictionaries( cfg.webSites, dictNetMgr );\n\n    dictionaries.insert( dictionaries.end(), dicts.begin(), dicts.end() );\n  }\n\n  //// Forvo dictionaries\n\n  {\n    vector< sptr< Dictionary::Class > > dicts =\n      Forvo::makeDictionaries( loadDicts, cfg.forvo, dictNetMgr );\n\n    dictionaries.insert( dictionaries.end(), dicts.begin(), dicts.end() );\n  }\n\n  //// Programs\n  {\n    vector< sptr< Dictionary::Class > > dicts =\n      Programs::makeDictionaries( cfg.programs );\n\n    dictionaries.insert( dictionaries.end(), dicts.begin(), dicts.end() );\n  }\n\n  //// Text to Speech\n  {\n    vector< sptr< Dictionary::Class > > dicts =\n      VoiceEngines::makeDictionaries( cfg.voiceEngines );\n\n    dictionaries.insert( dictionaries.end(), dicts.begin(), dicts.end() );\n  }\n\n  {\n    vector< sptr< Dictionary::Class > > dicts =\n      DictServer::makeDictionaries( cfg.dictServers );\n\n    dictionaries.insert( dictionaries.end(), dicts.begin(), dicts.end() );\n  }\n\n  GD_DPRINTF( \"Load done\\n\" );\n\n  // Remove any stale index files\n\n  set< string > ids;\n  std::pair< std::set< string >::iterator, bool > ret;\n\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n  QTextCodec::setCodecForCStrings( QTextCodec::codecForName( \"UTF8\" ) );\n#endif\n\n  for( unsigned x = dictionaries.size(); x--; )\n  {\n    ret = ids.insert( dictionaries[ x ]->getId() );\n    if( !ret.second )\n    {\n      gdWarning( \"Duplicate dictionary ID found: ID=%s, name=\\\"%s\\\", path=\\\"%s\\\"\",\n                 dictionaries[ x ]->getId().c_str(),\n                 dictionaries[ x ]->getName().c_str(),\n                 dictionaries[ x ]->getDictionaryFilenames().empty() ?\n                   \"\" : dictionaries[ x ]->getDictionaryFilenames()[ 0 ].c_str()\n                );\n    }\n  }\n\n  QDir indexDir( Config::getIndexDir() );\n\n  QStringList allIdxFiles = indexDir.entryList( QDir::Files );\n\n  for( QStringList::const_iterator i = allIdxFiles.constBegin();\n       i != allIdxFiles.constEnd(); ++i )\n  {\n    if ( ids.find( FsEncoding::encode( *i ) ) == ids.end()\n         && i->size() == 32 )\n      indexDir.remove( *i );\n    else\n    if ( i->endsWith( \"_FTS\" )\n         && i->size() == 36\n         && ids.find( FsEncoding::encode( i->left( 32 ) ) ) == ids.end() )\n      indexDir.remove( *i );\n  }\n\n  // Run deferred inits\n\n  if ( doDeferredInit_ )\n    doDeferredInit( dictionaries );\n}\n\nvoid doDeferredInit( std::vector< sptr< Dictionary::Class > > & dictionaries )\n{\n  for( unsigned x = 0; x < dictionaries.size(); ++x )\n    dictionaries[ x ]->deferredInit();\n}\n"
        },
        {
          "name": "loaddictionaries.hh",
          "type": "blob",
          "size": 2.19921875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __LOADDICTIONARIES_HH_INCLUDED__\n#define __LOADDICTIONARIES_HH_INCLUDED__\n\n#include \"initializing.hh\"\n#include \"config.hh\"\n#include \"dictionary.hh\"\n\n#include <QThread>\n#include <QNetworkAccessManager>\n\n/// Use loadDictionaries() function below -- this is a helper thread class\nclass LoadDictionaries: public QThread, public Dictionary::Initializing\n{\n  Q_OBJECT\n\n  QStringList nameFilters;\n  Config::Paths const & paths;\n  Config::SoundDirs const & soundDirs;\n  Config::Hunspell const & hunspell;\n  Config::Transliteration const & transliteration;\n  std::vector< sptr< Dictionary::Class > > dictionaries;\n  std::string exceptionText;\n  int maxPictureWidth;\n  unsigned int maxHeadwordSize;\n  unsigned int maxHeadwordToExpand;\n\npublic:\n\n  LoadDictionaries( Config::Class const & cfg );\n\n  virtual void run();\n\n  std::vector< sptr< Dictionary::Class > > const & getDictionaries() const\n  { return dictionaries; }\n\n  /// Empty string means to exception occurred\n  std::string const & getExceptionText() const\n  { return exceptionText; }\n\nsignals:\n\n  void indexingDictionarySignal( QString const & dictionaryName );\n\npublic:\n\n  virtual void indexingDictionary( std::string const & dictionaryName ) throw();\n\nprivate:\n\n  void handlePath( Config::Path const & );\n};\n\n/// Loads all dictionaries mentioned in the configuration passed, into the\n/// supplied array. When necessary, a window would pop up describing the process.\n/// If showInitially is passed as true, the window will always popup.\n/// If doDeferredInit is true (default), doDeferredInit() is done on all\n/// dictionaries at the end.\nvoid loadDictionaries( QWidget * parent, bool showInitially,\n                       Config::Class const & cfg,\n                       std::vector< sptr< Dictionary::Class > > &,\n                       QNetworkAccessManager & dictNetMgr,\n                       bool doDeferredInit = true );\n\n/// Runs deferredInit() on all the given dictionaries. Useful when\n/// loadDictionaries() was previously called with doDeferredInit = false.\nvoid doDeferredInit( std::vector< sptr< Dictionary::Class > > & );\n#endif\n\n"
        },
        {
          "name": "locale",
          "type": "tree",
          "content": null
        },
        {
          "name": "lsa.cc",
          "type": "blob",
          "size": 17.00390625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"lsa.hh\"\n#include \"file.hh\"\n#include \"iconv.hh\"\n#include \"folding.hh\"\n#include \"utf8.hh\"\n#include \"btreeidx.hh\"\n#include \"fsencoding.hh\"\n#include \"audiolink.hh\"\n#include \"gddebug.hh\"\n\n#include <set>\n#include <string>\n\n#ifdef _MSC_VER\n#include <stub_msvc.h>\n#endif\n\n#define OV_EXCLUDE_STATIC_CALLBACKS\n#include <vorbis/vorbisfile.h>\n#include <QDir>\n#include <QUrl>\n#include <QDebug>\n#include <QFile>\n\n#include \"qt4x5.hh\"\n\nnamespace Lsa {\n\nusing std::string;\nusing gd::wstring;\nusing std::map;\nusing std::multimap;\nusing std::set;\nusing BtreeIndexing::WordArticleLink;\nusing BtreeIndexing::IndexedWords;\nusing BtreeIndexing::IndexInfo;\n\nnamespace {\n\nDEF_EX( exInvalidData, \"Invalid data encountered\", Dictionary::Ex )\nDEF_EX( exFailedToOpenVorbisData, \"Failed to open Vorbis data\", Dictionary::Ex )\nDEF_EX( exFailedToSeekInVorbisData, \"Failed to seek in Vorbis data\", Dictionary::Ex )\nDEF_EX( exFailedToRetrieveVorbisInfo, \"Failed to retrieve Vorbis info\", Dictionary::Ex )\n\nenum\n{\n  Signature = 0x5841534c, // LSAX on little-endian, XASL on big-endian\n  CurrentFormatVersion = 5\n};\n\nstruct IdxHeader\n{\n  uint32_t signature; // First comes the signature, BGLX\n  uint32_t formatVersion; // File format version, currently 1.\n  uint32_t soundsCount; // Total number of sounds, for informative purposes only\n  uint32_t vorbisOffset; // Offset of the vorbis file which contains all snds\n  uint32_t indexBtreeMaxElements; // Two fields from IndexInfo\n  uint32_t indexRootOffset;\n} \n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\nbool indexIsOldOrBad( string const & indexFile )\n{\n  File::Class idx( indexFile, \"rb\" );\n\n  IdxHeader header;\n\n  return idx.readRecords( &header, sizeof( header ), 1 ) != 1 ||\n         header.signature != Signature ||\n         header.formatVersion != CurrentFormatVersion;\n}\n\nstring stripExtension( string const & str )\n{\n  if ( str.size() > 3 &&\n      ( strcasecmp( str.c_str() + ( str.size() - 4 ), \".wav\" ) == 0 ) )\n    return string( str, 0, str.size() - 4 );\n  else\n    return str;\n}\n\nstruct Entry\n{\n  string name;\n\n  uint32_t samplesLength;\n  uint32_t samplesOffset;\npublic:\n\n  // Reads an entry from the file's current position\n  Entry( File::Class & f );\n};\n\nEntry::Entry( File::Class & f )\n{\n  bool firstEntry = ( f.tell() == 13 );\n  // Read the entry's filename\n  size_t read = 0;\n\n  vector< uint16_t > filenameBuffer( 64 );\n\n  for( ; ; ++read )\n  {\n    if ( filenameBuffer.size() <= read )\n      filenameBuffer.resize( read + 64 );\n\n    f.read( &filenameBuffer[ read ], 2 );\n\n    if ( filenameBuffer[ read ] == 0xD )\n    {\n      if ( f.read< uint16_t >() != 0xA )\n        throw exInvalidData();\n\n      // Filename ending marker\n      break;\n    }\n  }\n\n  // Skip zero or ff, or just ff.\n\n  if ( uint8_t x = f.read< uint8_t >() )\n  {\n    if ( x != 0xFF )\n      throw exInvalidData();\n  }\n  else\n  if ( f.read< uint8_t >() != 0xFF )\n    throw exInvalidData();\n\n\n  if ( !firstEntry )\n  {\n    // For all entries but the first one, read its offset in\n    // samples.\n    samplesOffset  = f.read< uint32_t >();\n\n    if ( f.read< uint8_t >() != 0xFF )\n      throw exInvalidData();\n  }\n  else\n    samplesOffset = 0;\n\n  // Read the size of the recording, in samples\n  samplesLength = f.read< uint32_t >();\n\n  name = Iconv::toUtf8( Iconv::Utf16Le, &filenameBuffer.front(),\n                        read * sizeof( uint16_t ) );\n}\n\nclass LsaDictionary: public BtreeIndexing::BtreeDictionary\n{\n  Mutex idxMutex;\n  File::Class idx;\n  IdxHeader idxHeader;\n\npublic:\n\n  LsaDictionary( string const & id, string const & indexFile,\n                 vector< string > const & dictionaryFiles );\n\n  virtual string getName() throw();\n\n  virtual map< Dictionary::Property, string > getProperties() throw()\n  { return map< Dictionary::Property, string >(); }\n\n  virtual unsigned long getArticleCount() throw()\n  { return idxHeader.soundsCount; }\n\n  virtual unsigned long getWordCount() throw()\n  { return getArticleCount(); }\n\n  virtual sptr< Dictionary::DataRequest > getArticle( wstring const &,\n                                                      vector< wstring > const & alts,\n                                                      wstring const &,\n                                                      bool ignoreDiacritics )\n    THROW_SPEC( std::exception );\n\n  virtual sptr< Dictionary::DataRequest > getResource( string const & name )\n    THROW_SPEC( std::exception );\n\nprotected:\n\n  virtual void loadIcon() throw();\n};\n\nstring LsaDictionary::getName() throw()\n{\n  string result = FsEncoding::basename( getDictionaryFilenames()[ 0 ] );\n\n  // Strip the extension\n  result.erase( result.rfind( '.' ) );\n\n  return result;\n}\n\nLsaDictionary::LsaDictionary( string const & id,\n                              string const & indexFile,\n                              vector< string > const & dictionaryFiles ):\n  BtreeDictionary( id, dictionaryFiles ),\n  idx( indexFile, \"rb\" ),\n  idxHeader( idx.read< IdxHeader >() )\n{\n  // Initialize the index\n\n  openIndex( IndexInfo( idxHeader.indexBtreeMaxElements,\n                        idxHeader.indexRootOffset ),\n             idx, idxMutex );\n}\n\nsptr< Dictionary::DataRequest > LsaDictionary::getArticle( wstring const & word,\n                                                           vector< wstring > const & alts,\n                                                           wstring const &,\n                                                           bool ignoreDiacritics )\n  THROW_SPEC( std::exception )\n{\n  vector< WordArticleLink > chain = findArticles( word, ignoreDiacritics );\n\n  for( unsigned x = 0; x < alts.size(); ++x )\n  {\n    /// Make an additional query for each alt\n\n    vector< WordArticleLink > altChain = findArticles( alts[ x ], ignoreDiacritics );\n\n    chain.insert( chain.end(), altChain.begin(), altChain.end() );\n  }\n\n  multimap< wstring, string > mainArticles, alternateArticles;\n\n  set< uint32_t > articlesIncluded; // Some synonims make it that the articles\n                                    // appear several times. We combat this\n                                    // by only allowing them to appear once.\n\n  wstring wordCaseFolded = Folding::applySimpleCaseOnly( word );\n  if( ignoreDiacritics )\n    wordCaseFolded = Folding::applyDiacriticsOnly( wordCaseFolded );\n\n  for( unsigned x = 0; x < chain.size(); ++x )\n  {\n    if ( articlesIncluded.find( chain[ x ].articleOffset ) != articlesIncluded.end() )\n      continue; // We already have this article in the body.\n\n    // Ok. Now, does it go to main articles, or to alternate ones? We list\n    // main ones first, and alternates after.\n\n    // We do the case-folded comparison here.\n\n    wstring headwordStripped =\n      Folding::applySimpleCaseOnly( Utf8::decode( chain[ x ].word ) );\n    if( ignoreDiacritics )\n      headwordStripped = Folding::applyDiacriticsOnly( headwordStripped );\n\n    multimap< wstring, string > & mapToUse =\n      ( wordCaseFolded == headwordStripped ) ?\n        mainArticles : alternateArticles;\n\n    mapToUse.insert( std::pair< wstring, string >(\n      Folding::applySimpleCaseOnly( Utf8::decode( chain[ x ].word ) ), chain[ x ].word ) );\n\n    articlesIncluded.insert( chain[ x ].articleOffset );\n  }\n\n  if ( mainArticles.empty() && alternateArticles.empty() )\n    return new Dictionary::DataRequestInstant( false ); // No such word\n\n  string result;\n\n  multimap< wstring, string >::const_iterator i;\n\n  result += \"<table class=\\\"lsa_play\\\">\";\n  for( i = mainArticles.begin(); i != mainArticles.end(); ++i )\n  {\n    result += \"<tr>\";\n\n    QUrl url;\n    url.setScheme( \"gdau\" );\n    url.setHost( QString::fromUtf8( getId().c_str() ) );\n    url.setPath( Qt4x5::Url::ensureLeadingSlash( QString::fromUtf8( i->second.c_str() ) ) );\n\n    string ref = string( \"\\\"\" ) + url.toEncoded().data() + \"\\\"\";\n\n    result += addAudioLink( ref, getId() );\n\n    result += \"<td><a href=\" + ref + \"><img src=\\\"qrcx://localhost/icons/playsound.png\\\" border=\\\"0\\\" alt=\\\"Play\\\"/></a></td>\";\n    result += \"<td><a href=\" + ref + \">\" + i->second + \"</a></td>\";\n    result += \"</tr>\";\n  }\n\n  for( i = alternateArticles.begin(); i != alternateArticles.end(); ++i )\n  {\n    result += \"<tr>\";\n\n    QUrl url;\n    url.setScheme( \"gdau\" );\n    url.setHost( QString::fromUtf8( getId().c_str() ) );\n    url.setPath( Qt4x5::Url::ensureLeadingSlash( QString::fromUtf8( i->second.c_str() ) ) );\n\n    string ref = string( \"\\\"\" ) + url.toEncoded().data() + \"\\\"\";\n\n    result += addAudioLink( ref, getId() );\n\n    result += \"<td><a href=\" + ref + \"><img src=\\\"qrcx://localhost/icons/playsound.png\\\" border=\\\"0\\\" alt=\\\"Play\\\"/></a></td>\";\n    result += \"<td><a href=\" + ref + \">\" + i->second + \"</a></td>\";\n    result += \"</tr>\";\n  }\n\n  result += \"</table>\";\n\n  Dictionary::DataRequestInstant * ret =\n    new Dictionary::DataRequestInstant( true );\n\n  ret->getData().resize( result.size() );\n\n  memcpy( &(ret->getData().front()), result.data(), result.size() );\n\n  return ret;\n}\n\n/// This wraps around file operations\nstruct ShiftedVorbis\n{\n  QFile & f;\n  size_t shift;\n\n  ShiftedVorbis( QFile & f_, size_t shift_ ): f( f_ ), shift( shift_ )\n  {}\n\n  static size_t read( void * ptr, size_t size, size_t nmemb, void * datasource );\n  static int seek( void * datasource, ogg_int64_t offset, int whence );\n  static long tell( void * datasource );\n\n  static ov_callbacks callbacks;\n};\n\nsize_t ShiftedVorbis::read( void * ptr, size_t size, size_t nmemb,\n                            void * datasource )\n{\n  ShiftedVorbis * sv = ( ShiftedVorbis * ) datasource;\n\n  return sv->f.read( reinterpret_cast<char *>( ptr ), size * nmemb );\n}\n\nint ShiftedVorbis::seek( void * datasource, ogg_int64_t offset, int whence )\n{\n  ShiftedVorbis * sv = ( ShiftedVorbis * ) datasource;\n\n  if ( whence == SEEK_SET )\n    offset += sv->shift;\n\n  if( whence == SEEK_CUR )\n    offset += sv->f.pos();\n\n  if( whence == SEEK_END )\n    offset += sv->f.size();\n\n  return sv->f.seek( offset );\n}\n\nlong ShiftedVorbis::tell( void * datasource )\n{\n  ShiftedVorbis * sv = ( ShiftedVorbis * ) datasource;\n  long result = sv->f.pos();\n\n  if ( result != -1 )\n    result -= sv->shift;\n\n  return result;\n}\n\nov_callbacks ShiftedVorbis::callbacks = { ShiftedVorbis::read,\n                                          ShiftedVorbis::seek,\n                                          NULL,\n                                          ShiftedVorbis::tell };\n\n// A crude .wav header which is sufficient for our needs\nstruct WavHeader\n{\n  char riff[ 4 ]; // RIFF\n  uint32_t riffLength;\n  char waveAndFmt[ 8 ]; // WAVEfmt%20\n  uint32_t fmtLength; // 16\n  uint16_t formatTag; // 1\n  uint16_t channels; // 1 or 2\n  uint32_t samplesPerSec;\n  uint32_t bytesPerSec;\n  uint16_t blockAlign;\n  uint16_t bitsPerSample; // 16\n  char data[ 4 ]; // data\n  uint32_t dataLength;\n} \n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\nsptr< Dictionary::DataRequest > LsaDictionary::getResource( string const & name )\n  THROW_SPEC( std::exception )\n{\n  // See if the name ends in .wav. Remove that extension then\n\n  string strippedName =\n    ( name.size() > 3 && ( name.compare( name.size() - 4, 4, \".wav\" ) == 0 ) ) ?\n      string( name, 0, name.size() - 4 ) : name;\n\n  vector< WordArticleLink > chain = findArticles( Utf8::decode( strippedName ) );\n\n  if ( chain.empty() )\n    return new Dictionary::DataRequestInstant( false ); // No such resource\n\n  File::Class f( getDictionaryFilenames()[ 0 ], \"rb\" );\n\n  f.seek( chain[ 0 ].articleOffset );\n  Entry e( f );\n\n  f.seek( idxHeader.vorbisOffset );\n\n  ShiftedVorbis sv( f.file(), idxHeader.vorbisOffset );\n\n  OggVorbis_File vf;\n\n  int result = ov_open_callbacks( &sv, &vf, 0, 0, ShiftedVorbis::callbacks );\n\n  if ( result )\n    throw exFailedToOpenVorbisData();\n\n  if ( ov_pcm_seek( &vf, e.samplesOffset ) )\n    throw exFailedToSeekInVorbisData();\n\n  vorbis_info * vi = ov_info( &vf, -1 );\n\n  if ( !vi )\n  {\n    ov_clear( &vf );\n\n    throw exFailedToRetrieveVorbisInfo();\n  }\n\n  sptr< Dictionary::DataRequestInstant > dr = new\n    Dictionary::DataRequestInstant( true );\n\n  vector< char > & data = dr->getData();\n\n  data.resize( sizeof( WavHeader ) + e.samplesLength * 2 );\n\n  WavHeader * wh = (WavHeader *)&data.front();\n\n  memset( wh, 0, sizeof( *wh ) );\n\n  memcpy( wh->riff, \"RIFF\", 4 );\n  wh->riffLength = data.size() - 8;\n\n  memcpy( wh->waveAndFmt, \"WAVEfmt \", 8 );\n  wh->fmtLength = 16;\n  wh->formatTag = 1;\n  wh->channels = vi->channels;\n  wh->samplesPerSec = vi->rate;\n  wh->bytesPerSec = vi->channels * vi->rate * 2;\n  wh->blockAlign = vi->channels * 2;\n  wh->bitsPerSample = 16;\n  memcpy( wh->data, \"data\", 4 );\n  wh->dataLength = data.size() - sizeof( *wh );\n\n  // Now decode vorbis to the rest of the block\n\n  char * ptr = &data.front() + sizeof( *wh );\n  int left = data.size() - sizeof( *wh );\n  int bitstream = 0;\n\n  while( left )\n  {\n    long result = ov_read( &vf, ptr, left, 0, 2, 1, &bitstream );\n\n    if ( result <= 0 )\n    {\n      gdWarning( \"Failed to read Vorbis data (code = %ld)\\n\", result );\n      memset( ptr, 0, left );\n      break;\n    }\n\n    if ( result > left )\n    {\n      GD_FDPRINTF( stderr, \"Warning: Vorbis decode returned more data than requested.\\n\" );\n\n      result = left;\n    }\n\n    ptr += result;\n    left -= result;\n  }\n\n  ov_clear( &vf );\n\n  return dr;\n}\n\nvoid LsaDictionary::loadIcon() throw()\n{\n  if ( dictionaryIconLoaded )\n    return;\n\n  QString fileName =\n    QDir::fromNativeSeparators( FsEncoding::decode( getDictionaryFilenames()[ 0 ].c_str() ) );\n\n  // Remove the extension\n  fileName.chop( 3 );\n\n  if( !loadIconFromFile( fileName ) )\n  {\n    // Load failed -- use default icons\n    dictionaryNativeIcon = dictionaryIcon = QIcon(\":/icons/playsound.png\");\n  }\n\n  dictionaryIconLoaded = true;\n}\n\n}\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing & initializing )\n  THROW_SPEC( std::exception )\n{\n  vector< sptr< Dictionary::Class > > dictionaries;\n\n  for( vector< string >::const_iterator i = fileNames.begin(); i != fileNames.end();\n       ++i )\n  {\n    /// Only allow .dat and .lsa extensions to save scanning time\n    if ( i->size() < 4 ||\n        ( strcasecmp( i->c_str() + ( i->size() - 4 ), \".dat\" ) != 0 &&\n          strcasecmp( i->c_str() + ( i->size() - 4 ), \".lsa\" ) != 0 ) )\n      continue;\n\n    try\n    {\n      File::Class f( *i, \"rb\" );\n\n      /// Check the signature\n\n      char buf[ 9 ];\n\n      if ( f.readRecords( buf, 9, 1 ) != 1 || memcmp( buf, \"L\\09\\0S\\0A\\0\\xff\", 9 ) != 0 )\n      {\n        // The file is too short or the signature doesn't match -- skip this\n        // file\n        continue;\n      }\n\n      vector< string > dictFiles( 1, *i );\n\n      string dictId = Dictionary::makeDictionaryId( dictFiles );\n\n      string indexFile = indicesDir + dictId;\n\n      if ( Dictionary::needToRebuildIndex( dictFiles, indexFile ) || indexIsOldOrBad( indexFile ) )\n      {\n        // Building the index\n\n        gdDebug( \"Lsa: Building the index for dictionary: %s\\n\", i->c_str() );\n\n        initializing.indexingDictionary( FsEncoding::basename( *i ) );\n\n        File::Class idx( indexFile, \"wb\" );\n\n        IdxHeader idxHeader;\n\n        memset( &idxHeader, 0, sizeof( idxHeader ) );\n\n        // We write a dummy header first. At the end of the process the header\n        // will be rewritten with the right values.\n\n        idx.write( idxHeader );\n\n        IndexedWords indexedWords;\n\n        /// XXX handle big-endian machines here!\n        uint32_t entriesCount = f.read< uint32_t >();\n\n        GD_DPRINTF( \"%s: %u entries\\n\", i->c_str(), entriesCount );\n\n        idxHeader.soundsCount = entriesCount;\n\n        vector< uint16_t > filenameBuffer;\n\n        while( entriesCount-- )\n        {\n          uint32_t offset = f.tell();\n\n          Entry e( f );\n\n\n          // Remove the extension, no need for that in the index\n          e.name = stripExtension( e.name );\n\n          GD_DPRINTF( \"Read filename %s (%u at %u)<\\n\", e.name.c_str(), e.samplesLength, e.samplesOffset );\n\n          // Insert new entry into an index\n\n          indexedWords.addWord( Utf8::decode( e.name ), offset );\n        }\n\n        idxHeader.vorbisOffset = f.tell();\n\n        // Make sure there's really some vobis data there\n\n        char buf[ 4 ];\n\n        f.read( buf, sizeof( buf ) );\n\n        if ( strncmp( buf, \"OggS\", 4 ) != 0 )\n          throw exInvalidData();\n\n        // Build the index\n\n        IndexInfo idxInfo = BtreeIndexing::buildIndex( indexedWords, idx );\n\n        idxHeader.indexBtreeMaxElements = idxInfo.btreeMaxElements;\n        idxHeader.indexRootOffset = idxInfo.rootOffset;\n\n         // That concludes it. Update the header.\n\n        idxHeader.signature = Signature;\n        idxHeader.formatVersion = CurrentFormatVersion;\n\n        idx.rewind();\n\n        idx.write( &idxHeader, sizeof( idxHeader ) );\n      }\n\n      dictionaries.push_back( new LsaDictionary( dictId,\n                                                 indexFile,\n                                                 dictFiles ) );\n    }\n    catch( std::exception & e )\n    {\n      gdWarning( \"Lingvo's LSA reading failed: %s, error: %s\\n\",\n                 i->c_str(), e.what() );\n    }\n  }\n\n  return dictionaries;\n}\n\n\n}\n"
        },
        {
          "name": "lsa.hh",
          "type": "blob",
          "size": 0.646484375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __L9SA_HH_INCLUDED__\n#define __L9SA_HH_INCLUDED__\n\n#include \"dictionary.hh\"\n\n/// Support for LSA (.dat, .lsa) audio archives of the Lingo program.\nnamespace Lsa {\n\nusing std::vector;\nusing std::string;\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing & )\n  THROW_SPEC( std::exception );\n\n}\n\n#endif\n"
        },
        {
          "name": "machotkeywrapper.mm",
          "type": "blob",
          "size": 7.9541015625,
          "content": "/* This file is (c) 2013 Abs62\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"hotkeywrapper.hh\"\n#include <ApplicationServices/ApplicationServices.h>\n\nnamespace MacKeyMapping\n{\n// Convert Qt key codes to Mac OS X native codes\n\nstruct ReverseMapEntry\n{\n  UniChar  character;\n  UInt16   keyCode;\n};\n\nstatic struct ReverseMapEntry * mapping;\nstatic int mapEntries = 0;\n\nvoid createMapping()\n{\n  if( mapping == NULL )\n  {\n    TISInputSourceRef inputSourceRef = TISCopyInputSourceForLanguage( CFSTR( \"en\" ) );\n    if ( !inputSourceRef )\n      inputSourceRef = TISCopyCurrentKeyboardInputSource();\n    if ( !inputSourceRef )\n      return;\n\n    CFDataRef dataRef = ( CFDataRef )TISGetInputSourceProperty( inputSourceRef,\n                                     kTISPropertyUnicodeKeyLayoutData ); \n                        // this method returns null under macos Japanese input method(and also Chinese), which causes cmd+C+C not to be registered as a hotkey\n    if( !dataRef )\n    {\n        // solve the null value under Japanese keyboard\n        inputSourceRef = TISCopyCurrentKeyboardLayoutInputSource();\n        dataRef = static_cast<CFDataRef>((TISGetInputSourceProperty(inputSourceRef, kTISPropertyUnicodeKeyLayoutData)));\n        if (!dataRef) {\n          return;\n        }\n    }\n\n    const UCKeyboardLayout * keyboardLayoutPtr = ( const UCKeyboardLayout * )CFDataGetBytePtr( dataRef );\n    if( !keyboardLayoutPtr )\n      return;\n\n    mapping = ( struct ReverseMapEntry * )calloc( 128 , sizeof(struct ReverseMapEntry) );\n    if( !mapping )\n      return;\n\n    mapEntries = 0;\n\n    for( int i = 0; i < 128; i++ )\n    {\n      UInt32 theDeadKeyState = 0;\n      UniCharCount theLength = 0;\n      if( UCKeyTranslate( keyboardLayoutPtr, i, kUCKeyActionDisplay, 0, LMGetKbdType(),\n                            kUCKeyTranslateNoDeadKeysBit, &theDeadKeyState, 1, &theLength,\n                            &mapping[ mapEntries ].character ) == noErr && theLength > 0 )\n      {\n        if( isprint( mapping[ mapEntries ].character ) )\n        {\n          mapping[ mapEntries++ ].keyCode = i;\n        }\n      }\n    }\n  }\n}\n\nquint32 qtKeyToNativeKey( quint32 key )\n{\n  createMapping();\n  if( mapping == NULL )\n    return 0;\n\n  for( int i = 0; i < mapEntries; i++ )\n  {\n    if( mapping[ i ].character == key )\n      return mapping[ i ].keyCode;\n  }\n\n  return 0;\n}\n\n} // namespace MacKeyMapping\n\nstatic pascal OSStatus hotKeyHandler( EventHandlerCallRef /* nextHandler */, EventRef theEvent, void * userData )\n{\n  EventHotKeyID hkID;\n  GetEventParameter( theEvent, kEventParamDirectObject, typeEventHotKeyID, NULL, sizeof(EventHotKeyID), NULL, &hkID );\n  static_cast< HotkeyWrapper * >( userData )->activated( hkID.id );\n  return noErr;\n}\n\nHotkeyWrapper::HotkeyWrapper( QObject *parent )\n{\n(void) parent;\n  hotKeyFunction = NewEventHandlerUPP( hotKeyHandler );\n  EventTypeSpec type;\n  type.eventClass = kEventClassKeyboard;\n  type.eventKind = kEventHotKeyPressed;\n  InstallApplicationEventHandler( hotKeyFunction, 1, &type, this, &handlerRef );\n  keyC = nativeKey( 'c' );\n}\n\nHotkeyWrapper::~HotkeyWrapper()\n{\n  unregister();\n  RemoveEventHandler( handlerRef );\n}\n\nvoid HotkeyWrapper::waitKey2()\n{\n  state2 = false;\n}\n\nvoid HotkeyWrapper::activated( int hkId )\n{\n  if ( state2 )\n  { // wait for 2nd key\n\n    waitKey2(); // Cancel the 2nd-key wait stage\n\n    if ( hkId == state2waiter.id + 1 ||\n         ( hkId == state2waiter.id && state2waiter.key == state2waiter.key2 ) )\n    {\n      emit hotkeyActivated( state2waiter.handle );\n      return;\n    }\n  }\n\n  for ( int i = 0; i < hotkeys.count(); i++ )\n  {\n    HotkeyStruct &hs = hotkeys[ i ];\n    if( hkId == hs.id )\n    {\n      if( hs.key == keyC && hs.modifier == cmdKey )\n      {\n        // If that was a copy-to-clipboard shortcut, re-emit it back so it could\n        // reach its original destination so it could be acted upon.\n        UnregisterEventHotKey( hs.hkRef );\n\n        sendCmdC();\n\n        EventHotKeyID hotKeyID;\n        hotKeyID.signature = 'GDHK';\n        hotKeyID.id = hs.id;\n\n        RegisterEventHotKey( hs.key, hs.modifier, hotKeyID, GetApplicationEventTarget(), 0, &hs.hkRef );\n      }\n\n      if ( hs.key2 == 0 ) {\n         emit hotkeyActivated( hs.handle );\n         return;\n      }\n\n      state2 = true;\n      state2waiter = hs;\n      QTimer::singleShot( 500, this, SLOT( waitKey2() ) );\n      return;\n    }\n  }\n\n  state2 = false;\n  return;\n}\n\nvoid HotkeyWrapper::unregister()\n{\n  for ( int i = 0; i < hotkeys.count(); i++ )\n  {\n    HotkeyStruct const & hk = hotkeys.at( i );\n\n    UnregisterEventHotKey( hk.hkRef );\n\n    if ( hk.key2 && hk.key2 != hk.key )\n      UnregisterEventHotKey( hk.hkRef2 );\n  }\n\n  (static_cast< QHotkeyApplication * >( qApp ))->unregisterWrapper( this );\n}\n\nbool HotkeyWrapper::setGlobalKey( int key, int key2, Qt::KeyboardModifiers modifier, int handle )\n{\n  if ( !key )\n    return false; // We don't monitor empty combinations\n\n  quint32 vk = nativeKey( key );\n\n  if( vk == 0 )\n    return false;\n\n  quint32 vk2 = key2 ? nativeKey( key2 ) : 0;\n\n  static int nextId = 1;\n  if( nextId > 0xBFFF - 1 )\n    nextId = 1;\n\n  quint32 mod = 0;\n  if( modifier & Qt::CTRL )\n    mod |= cmdKey;\n  if( modifier & Qt::ALT )\n    mod |= optionKey;\n  if( modifier & Qt::SHIFT )\n    mod |= shiftKey;\n  if( modifier & Qt::META )\n    mod |= controlKey;\n\n  hotkeys.append( HotkeyStruct( vk, vk2, mod, handle, nextId ) );\n  HotkeyStruct &hk = hotkeys.last();\n\n  EventHotKeyID hotKeyID;\n  hotKeyID.signature = 'GDHK';\n  hotKeyID.id = nextId;\n\n  OSStatus ret = RegisterEventHotKey( vk, mod, hotKeyID, GetApplicationEventTarget(), 0, &hk.hkRef );\n  if ( ret != 0 )\n    return false;\n\n  if ( vk2 && vk2 != vk )\n  {\n    hotKeyID.id = nextId + 1;\n    ret = RegisterEventHotKey( vk2, mod, hotKeyID, GetApplicationEventTarget(), 0, &hk.hkRef2 );\n  }\n\n  nextId += 2;\n\n  return ret == 0;\n}\n\nquint32 HotkeyWrapper::nativeKey( int key )\n{\n  switch( key ) {\n    case Qt::Key_Escape:      return 0x35;\n    case Qt::Key_Tab:         return 0x30;\n    case Qt::Key_Backspace:   return 0x33;\n    case Qt::Key_Return:      return 0x24;\n    case Qt::Key_Enter:       return 0x4c;\n    case Qt::Key_Delete:      return 0x75;\n    case Qt::Key_Clear:       return 0x47;\n    case Qt::Key_Home:        return 0x73;\n    case Qt::Key_End:         return 0x77;\n    case Qt::Key_Left:        return 0x7b;\n    case Qt::Key_Up:          return 0x7e;\n    case Qt::Key_Right:       return 0x7c;\n    case Qt::Key_Down:        return 0x7d;\n    case Qt::Key_PageUp:      return 0x74;\n    case Qt::Key_PageDown:    return 0x79;\n    case Qt::Key_CapsLock:    return 0x57;\n    case Qt::Key_F1:          return 0x7a;\n    case Qt::Key_F2:          return 0x78;\n    case Qt::Key_F3:          return 0x63;\n    case Qt::Key_F4:          return 0x76;\n    case Qt::Key_F5:          return 0x60;\n    case Qt::Key_F6:          return 0x61;\n    case Qt::Key_F7:          return 0x62;\n    case Qt::Key_F8:          return 0x64;\n    case Qt::Key_F9:          return 0x65;\n    case Qt::Key_F10:         return 0x6d;\n    case Qt::Key_F11:         return 0x67;\n    case Qt::Key_F12:         return 0x6f;\n    case Qt::Key_F13:         return 0x69;\n    case Qt::Key_F14:         return 0x6b;\n    case Qt::Key_F15:         return 0x71;\n    case Qt::Key_Help:        return 0x72;\n    default:;\n  }\n  return MacKeyMapping::qtKeyToNativeKey( QChar( key ).toLower().toLatin1() );\n}\n\nvoid HotkeyWrapper::sendCmdC()\n{\n  CGEventFlags flags = kCGEventFlagMaskCommand;\n  CGEventRef ev;\n  CGEventSourceRef source = CGEventSourceCreate( kCGEventSourceStateCombinedSessionState );\n\n  //press down\n  ev = CGEventCreateKeyboardEvent( source, keyC, true );\n  CGEventSetFlags( ev, CGEventFlags( flags | CGEventGetFlags( ev ) ) ); //combine flags\n  CGEventPost( kCGAnnotatedSessionEventTap, ev );\n  CFRelease( ev );\n\n  //press up\n  ev = CGEventCreateKeyboardEvent( source, keyC, false );\n  CGEventSetFlags( ev, CGEventFlags( flags | CGEventGetFlags( ev ) ) ); //combine flags\n  CGEventPost( kCGAnnotatedSessionEventTap, ev );\n  CFRelease( ev );\n\n  CFRelease( source );\n}\n\nEventHandlerUPP HotkeyWrapper::hotKeyFunction = NULL;\n"
        },
        {
          "name": "maclibs",
          "type": "tree",
          "content": null
        },
        {
          "name": "macmouseover.hh",
          "type": "blob",
          "size": 1.4599609375,
          "content": "#ifndef __MACMOUSEOVER_HH_INCLUDED__\n#define __MACMOUSEOVER_HH_INCLUDED__\n\n#include <QObject>\n#include <QTimer>\n#include <ApplicationServices/ApplicationServices.h>\n#include \"config.hh\"\n#include \"keyboardstate.hh\"\n#include \"mutex.hh\"\n\n/// This is a mouseover feature interface, where you can point your mouse at\n/// any word in any window and wait a little, and it would provide that word\n/// for the translation.\n\nclass MacMouseOver: public QObject, public KeyboardState\n{\n  Q_OBJECT\n\npublic:\n\n  /// The class is a singleton.\n  static MacMouseOver & instance();\n\n  /// Enables mouseover. The mouseover is initially disabled.\n  void enableMouseOver();\n  /// Disables mouseover.\n  void disableMouseOver();\n\n  /// Set pointer to program configuration\n  void setPreferencesPtr( Config::Preferences const *ppref ) { pPref = ppref; };\n\n  /// Called from event loop callback\n  void mouseMoved();\n\n  static bool isAXAPIEnabled();\n  \nsignals:\n\n  /// Emitted when there was some text under cursor which was hovered over.\n  void hovered( QString const &, bool forcePopup );\n\nprivate slots:\n  void timerShot();\n\nprivate:\n\n  MacMouseOver();\n  ~MacMouseOver();\n  void handlePosition();\n  QString CFStringRefToQString( CFStringRef str );\n  void handleRetrievedString( QString & wordSeq, int wordSeqPos );\n\n  Config::Preferences const *pPref;\n  QTimer mouseTimer;\n  CFMachPortRef tapRef;\n  CFRunLoopSourceRef loop;\n  Mutex mouseMutex;\n  AXUIElementRef elementSystemWide;\n\n  bool mouseOverEnabled;\n\n};\n\n#endif\n\n"
        },
        {
          "name": "macmouseover.mm",
          "type": "blob",
          "size": 8.9111328125,
          "content": "#include \"macmouseover.hh\"\n#include <AppKit/NSTouch.h>\n#include <AppKit/NSEvent.h>\n#include <AppKit/NSScreen.h>\n#include <Foundation/NSAutoreleasePool.h>\n#include <Foundation/Foundation.h>\n\n#ifndef AVAILABLE_MAC_OS_X_VERSION_10_11_AND_LATER\n#define kAXValueTypeCGPoint kAXValueCGPointType\n#define kAXValueTypeCFRange kAXValueCFRangeType\n#endif\n\nconst int mouseOverInterval = 300;\n\nCGEventRef eventCallback( CGEventTapProxy proxy, CGEventType type, CGEventRef event, void *refcon )\n{\n(void) proxy;\n  if( type != kCGEventMouseMoved )\n    return event;\n  static_cast< MacMouseOver * >( refcon )->mouseMoved();\n  return event;\n}\n\nstatic CGPoint carbonScreenPointFromCocoaScreenPoint( NSPoint cocoaPoint )\n{\n  NSScreen *foundScreen = nil;\n  CGPoint thePoint;\n\n  for (NSScreen *screen in [NSScreen screens]) {\n    if (NSPointInRect(cocoaPoint, [screen frame])) {\n        foundScreen = screen;\n    }\n  }\n\n  if (foundScreen) {\n    CGFloat screenHeight = [foundScreen frame].size.height;\n    thePoint = CGPointMake(cocoaPoint.x, screenHeight - cocoaPoint.y - 1);\n  }\n  else\n    thePoint = CGPointMake(0.0, 0.0);\n\n  return thePoint;\n}\n\nMacMouseOver & MacMouseOver::instance()\n{\n  static MacMouseOver m;\n\n  return m;\n}\n\nMacMouseOver::MacMouseOver() :\n  pPref(NULL)\n, tapRef( 0 )\n, loop( 0 )\n{\n  mouseTimer.setSingleShot( true );\n  connect( &mouseTimer, SIGNAL( timeout() ), this, SLOT( timerShot() ) );\n\n  elementSystemWide = AXUIElementCreateSystemWide();\n}\n\nMacMouseOver::~MacMouseOver()\n{\n  disableMouseOver();\n\n  if( tapRef )\n    CFRelease( tapRef );\n\n  if( loop )\n    CFRelease( loop );\n\n  if( elementSystemWide )\n    CFRelease( elementSystemWide );\n}\n\nQString MacMouseOver::CFStringRefToQString( CFStringRef str )\n{\n  int length = CFStringGetLength( str );\n  if( length == 0 )\n    return QString();\n\n  UniChar *chars = new UniChar[ length ];\n  CFStringGetCharacters( str, CFRangeMake( 0, length ), chars );\n\n  QString result = QString::fromUtf16( chars, length );\n\n  delete[] chars;\n  return result;\n}\n\nvoid MacMouseOver::mouseMoved()\n{\n  mouseTimer.start( mouseOverInterval );\n}\n\nvoid MacMouseOver::enableMouseOver()\n{\n  mouseTimer.stop();\n  if( !isAXAPIEnabled() )\n    return;\n  if( !tapRef )\n    tapRef = CGEventTapCreate( kCGAnnotatedSessionEventTap, kCGHeadInsertEventTap,\n                               kCGEventTapOptionListenOnly,\n                               CGEventMaskBit( kCGEventMouseMoved ),\n                               eventCallback, this );\n  if( !tapRef )\n    return;\n  if( !loop )\n    loop = CFMachPortCreateRunLoopSource( kCFAllocatorDefault, tapRef, 0 );\n  if( loop )\n    CFRunLoopAddSource( CFRunLoopGetMain(), loop, kCFRunLoopCommonModes );\n}\n\nvoid MacMouseOver::disableMouseOver()\n{\n  mouseTimer.stop();\n  if( loop )\n    CFRunLoopRemoveSource( CFRunLoopGetMain(), loop, kCFRunLoopCommonModes );\n}\n\nvoid MacMouseOver::timerShot()\n{\n  if( mouseMutex.tryLock( 0 ) )\n    mouseMutex.unlock();\n  else\n    return;\n  if( !pPref )\n    return;\n  if( !pPref->enableScanPopupModifiers || checkModifiersPressed( pPref->scanPopupModifiers ) )\n    handlePosition();\n}\n\nvoid MacMouseOver::handlePosition()\n{\n  Mutex::Lock _( mouseMutex );\n\n  QString strToTranslate;\n\n  NSAutoreleasePool * pool = [ [ NSAutoreleasePool alloc ] init ];\n  CGPoint pt = carbonScreenPointFromCocoaScreenPoint( [NSEvent mouseLocation] );\n  [ pool drain ];\n\n  CFArrayRef names = 0;\n\n  AXUIElementRef elem = 0;\n  AXError err = AXUIElementCopyElementAtPosition( elementSystemWide, pt.x, pt.y, &elem );\n\n  if( err != kAXErrorSuccess )\n    return;\n\n  for( ; ; )\n  {\n    CFTypeRef parameter = AXValueCreate( kAXValueTypeCGPoint, &pt );\n    CFTypeRef rangeValue;\n    err = AXUIElementCopyParameterizedAttributeNames( elem, &names );\n    if( err != kAXErrorSuccess )\n      break;\n\n    int numOfAttributes = CFArrayGetCount( names );\n    if( CFArrayContainsValue( names, CFRangeMake( 0, numOfAttributes ), CFSTR( \"AXRangeForPosition\" ) ) )\n    {\n      // Standard interface\n      err = AXUIElementCopyParameterizedAttributeValue( elem, kAXRangeForPositionParameterizedAttribute,\n                                                            parameter, ( CFTypeRef * )&rangeValue );\n      CFRelease( parameter );\n      if( err != kAXErrorSuccess )\n        break;\n\n      CFStringRef stringValue;\n\n      CFRange decodedRange = CFRangeMake( 0, 0 );\n      bool b = AXValueGetValue( (AXValueRef)rangeValue, kAXValueTypeCFRange, &decodedRange );\n      CFRelease( rangeValue );\n      if( b )\n      {\n        int fromPos = decodedRange.location - 127;\n        if( fromPos < 0 )\n          fromPos = 0;\n        int wordPos = decodedRange.location - fromPos;  // Cursor position in result string\n\n        CFRange range = CFRangeMake( fromPos, wordPos + 1 );\n        parameter = AXValueCreate( kAXValueTypeCFRange, &range );\n        err = AXUIElementCopyParameterizedAttributeValue( elem, kAXStringForRangeParameterizedAttribute,\n                                                            parameter, (CFTypeRef *)&stringValue );\n        CFRelease( parameter );\n        if( err != kAXErrorSuccess )\n          break;\n\n        strToTranslate = CFStringRefToQString( stringValue );\n        CFRelease( stringValue );\n\n        // Read string further\n        for( int i = 1; i < 128; i++ )\n        {\n          range = CFRangeMake( decodedRange.location + i, 1 );\n          parameter = AXValueCreate( kAXValueTypeCFRange, &range );\n          err = AXUIElementCopyParameterizedAttributeValue( elem, kAXStringForRangeParameterizedAttribute,\n                                                              parameter, (CFTypeRef *)&stringValue );\n          CFRelease( parameter );\n\n          if( err != kAXErrorSuccess )\n            break;\n\n          QString s = CFStringRefToQString( stringValue );\n          CFRelease( stringValue );\n\n          if( s[ 0 ].isLetterOrNumber() || s[ 0 ] == '-' )\n            strToTranslate += s;\n          else\n            break;\n        }\n\n        handleRetrievedString( strToTranslate, wordPos );\n      }\n    }\n    else if( CFArrayContainsValue( names, CFRangeMake( 0, numOfAttributes ), CFSTR( \"AXTextMarkerForPosition\" ) ) )\n    {\n      // Safari interface\n      CFTypeRef marker, range;\n      CFStringRef str;\n      err = AXUIElementCopyParameterizedAttributeValue( elem, CFSTR( \"AXTextMarkerForPosition\" ),\n                                                            parameter, ( CFTypeRef * )&marker );\n      CFRelease( parameter );\n      if( err != kAXErrorSuccess )\n        break;\n\n      err = AXUIElementCopyParameterizedAttributeValue( elem, CFSTR( \"AXLeftWordTextMarkerRangeForTextMarker\" ),\n                                                        marker, ( CFTypeRef * )&range );\n      CFRelease( marker );\n      if( err != kAXErrorSuccess )\n        break;\n\n      err = AXUIElementCopyParameterizedAttributeValue( elem, CFSTR( \"AXStringForTextMarkerRange\" ),\n                                                        range, ( CFTypeRef * )&str );\n      CFRelease( range );\n      if( err == kAXErrorSuccess )\n      {\n        strToTranslate = CFStringRefToQString( str );\n        CFRelease( str );\n        handleRetrievedString( strToTranslate, 0 );\n      }\n    }\n    break;\n  }\n  if( elem )\n    CFRelease( elem );\n  if( names )\n    CFRelease( names );\n}\n\nvoid MacMouseOver::handleRetrievedString( QString & wordSeq, int wordSeqPos )\n{\n\n  if( wordSeq.isEmpty() )\n    return;\n\n  // locate the word inside the sequence\n\n  QString word;\n\n  if ( wordSeq[ wordSeqPos ].isSpace() )\n  {\n    // Currently we ignore such cases\n    return;\n  }\n  else\n  if ( !wordSeq[ wordSeqPos ].isLetterOrNumber() )\n  {\n    // Special case: the cursor points to something which doesn't look like a\n    // middle of the word -- assume that it's something that joins two words\n    // together.\n\n    int begin = wordSeqPos;\n\n    for( ; begin; --begin )\n      if ( !wordSeq[ begin - 1 ].isLetterOrNumber() )\n        break;\n\n    int end = wordSeqPos;\n\n    while( ++end < wordSeq.size() )\n      if ( !wordSeq[ end ].isLetterOrNumber() )\n        break;\n\n    if ( end - begin == 1 )\n    {\n      // Well, turns out it was just a single non-letter char, discard it\n      return;\n    }\n\n    word = wordSeq.mid( begin, end - begin );\n  }\n  else\n  {\n    // Cursor points to a letter -- cut the word it points to\n\n    int begin = wordSeqPos;\n\n    for( ; begin; --begin )\n      if ( !wordSeq[ begin - 1 ].isLetterOrNumber() )\n        break;\n\n    int end = wordSeqPos;\n\n    while( ++end < wordSeq.size() )\n    {\n      if ( !wordSeq[ end ].isLetterOrNumber() )\n        break;\n    }\n    word = wordSeq.mid( begin, end - begin );\n  }\n\n  // See if we have an RTL char. Reverse the whole string if we do.\n\n  for( int x = 0; x < word.size(); ++x )\n  {\n    QChar::Direction d = word[ x ].direction();\n\n    if ( d == QChar::DirR || d == QChar::DirAL ||\n         d == QChar::DirRLE || d == QChar::DirRLO )\n    {\n      std::reverse( word.begin(), word.end() );\n      break;\n    }\n  }\n\n  emit instance().hovered( word, false );\n}\n\nbool MacMouseOver::isAXAPIEnabled()\n{\n  if( NSFoundationVersionNumber >= 1000 )  // MacOS 10.9+\n    return AXIsProcessTrusted();\n\n  return AXAPIEnabled();\n}\n"
        },
        {
          "name": "main.cc",
          "type": "blob",
          "size": 16.0947265625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include <stdio.h>\n#include <QIcon>\n#include \"gdappstyle.hh\"\n#include \"mainwindow.hh\"\n#include \"config.hh\"\n\n#include \"processwrapper.hh\"\n#include \"hotkeywrapper.hh\"\n#ifdef HAVE_X11\n#include <fixx11h.h>\n#endif\n\n//#define __DO_DEBUG\n\n#define LOG_TO_FILE_KEY \"--log-to-file\"\n\n#ifdef Q_OS_WIN32\n#include <QtCore/qt_windows.h>\n#endif\n\n#ifdef __DO_DEBUG\n#include <sys/resource.h>\n#endif\n\n#include \"termination.hh\"\n#include \"atomic_rename.hh\"\n\n#include <QWebSecurityOrigin>\n#include <QMessageBox>\n#include <QDebug>\n#include <QFile>\n#include <QByteArray>\n#include <QString>\n#include <QTextStream>\n#include <QUrl>\n\n#include \"gddebug.hh\"\n\n#if defined( Q_OS_MAC ) && QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n#include \"lionsupport.h\"\n#endif\n\n#if ( QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 ) )\n\nvoid gdMessageHandler( QtMsgType type, const QMessageLogContext &context, const QString &mess )\n{\n  Q_UNUSED( context );\n  QString message( mess );\n  QByteArray msg = message.toUtf8().constData();\n\n#else\n\nvoid gdMessageHandler( QtMsgType type, const char *msg_ )\n{\n  QString message = QString::fromUtf8( msg_ );\n  QByteArray msg = QByteArray::fromRawData( msg_, strlen( msg_ ) );\n\n#endif\n\n  switch (type) {\n\n    case QtDebugMsg:\n      if( logFilePtr && logFilePtr->isOpen() )\n        message.insert( 0, \"Debug: \" );\n      else\n        fprintf(stderr, \"Debug: %s\\n\", msg.constData());\n      break;\n\n    case QtWarningMsg:\n      if( logFilePtr && logFilePtr->isOpen() )\n        message.insert( 0, \"Warning: \" );\n      else\n        fprintf(stderr, \"Warning: %s\\n\", msg.constData());\n      break;\n\n    case QtCriticalMsg:\n      if( logFilePtr && logFilePtr->isOpen() )\n        message.insert( 0, \"Critical: \" );\n      else\n        fprintf(stderr, \"Critical: %s\\n\", msg.constData());\n      break;\n\n    case QtFatalMsg:\n      if( logFilePtr && logFilePtr->isOpen() )\n      {\n        logFilePtr->write( \"Fatal: \" );\n        logFilePtr->write( msg );\n        logFilePtr->flush();\n      }\n      else\n        fprintf(stderr, \"Fatal: %s\\n\", msg.constData());\n      abort();\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 5, 0 )\n    case QtInfoMsg:\n      if( logFilePtr && logFilePtr->isOpen() )\n        message.insert( 0, \"Info: \" );\n      else\n        fprintf(stderr, \"Info: %s\\n\", msg.constData());\n      break;\n#endif\n  }\n\n  if( logFilePtr && logFilePtr->isOpen() )\n  {\n    message.append( \"\\n\" );\n    logFilePtr->write( message.toUtf8() );\n    logFilePtr->flush();\n  }\n}\n\nclass GDCommandLine\n{\n  bool showHelp, toggleScanPopup, logFile;\n  QString word, groupName, popupGroupName;\n  QVector< QString > arguments;\npublic:\n  GDCommandLine( int argc, char **argv );\n\n  bool needShowHelp() const\n  { return showHelp; }\n\n  inline bool needToggleScanPopup()\n  { return toggleScanPopup; }\n\n  inline bool needSetGroup()\n  { return !groupName.isEmpty(); }\n\n  inline QString getGroupName()\n  { return groupName; }\n\n  inline bool needSetPopupGroup()\n  { return !popupGroupName.isEmpty(); }\n\n  inline QString getPopupGroupName()\n  { return popupGroupName; }\n\n  inline bool needLogFile()\n  { return logFile; }\n\n  inline bool needTranslateWord()\n  { return !word.isEmpty(); }\n\n  inline QString wordToTranslate()\n  { return word; }\n\nprivate:\n  void handleUriSchemes();\n};\n\nGDCommandLine::GDCommandLine( int argc, char **argv ):\nshowHelp( false ),\ntoggleScanPopup( false ),\nlogFile( false )\n{\n  if( argc > 1 )\n  {\n#ifdef Q_OS_WIN32\n    (void) argv;\n    int num;\n    LPWSTR *pstr = CommandLineToArgvW( GetCommandLineW(), &num );\n    if( pstr && num > 1 )\n    {\n      for( int i = 1; i < num; i++ )\n        arguments.push_back( QString::fromWCharArray( pstr[ i ] ) );\n    }\n#else\n    for( int i = 1; i < argc; i++ )\n      arguments.push_back( QString::fromLocal8Bit( argv[ i ] ) );\n#endif\n    // Parse command line\n    for( int i = 0; i < arguments.size(); i++ )\n    {\n      if( arguments[ i ].compare( \"-h\" ) == 0 || arguments[ i ].compare( \"--help\" ) == 0 )\n      {\n        showHelp = true;\n        continue;\n      }\n      else\n      if( arguments[ i ].compare( \"--toggle-scan-popup\" ) == 0 )\n      {\n        toggleScanPopup = true;\n        continue;\n      }\n      else\n      if( arguments[ i ].compare( \"--log-to-file\" ) == 0 )\n      {\n        logFile = true;\n        continue;\n      }\n      else\n      if( arguments[ i ].startsWith( \"--group-name=\" ) )\n      {\n        groupName = arguments[ i ].mid( arguments[ i ].indexOf( '=' ) + 1 );\n        continue;\n      }\n      else\n      if( arguments[ i ].startsWith( \"--popup-group-name=\" ) )\n      {\n        popupGroupName = arguments[ i ].mid( arguments[ i ].indexOf( '=' ) + 1 );\n        continue;\n      }\n      else\n        word = arguments[ i ];\n    }\n\n    handleUriSchemes();\n  }\n}\n\nvoid GDCommandLine::handleUriSchemes()\n{\n  if( word.isEmpty() )\n    return;\n\n  static QLatin1String const uriSchemes[] = { QLatin1String( \"goldendict://\" ),\n                                              QLatin1String( \"dict://\" ) };\n  static size_t const uriSchemeCount = sizeof( uriSchemes ) / sizeof( uriSchemes[ 0 ] );\n  for( size_t i = 0; i < uriSchemeCount; ++i )\n  {\n    QLatin1String const scheme = uriSchemes[ i ];\n    if( !word.startsWith( scheme ) )\n      continue;\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n    int schemeSize = scheme.size();\n#else\n    int schemeSize = strlen( scheme.latin1() );\n#endif\n    if( word.size() > schemeSize && word.at( schemeSize ) == QLatin1Char( '/' ) )\n      ++schemeSize; // support dict:///word as well\n\n    word.remove( 0, schemeSize );\n\n    // An URI can end with a trailing slash, which has to be removed here. This should be more common\n    // than a deliberate lookup of the slash character or a string that ends with a slash.\n    // If word equals '/' (size 1), then word_ ends with 4 slashes, in which case translate the slash.\n    if( word.size() > 1 && word.at( word.size() - 1 ) == QLatin1Char( '/' ) )\n      word.chop( 1 );\n\n    word = QUrl::fromPercentEncoding( word.toUtf8() );\n    break;\n  }\n}\n\nclass LogFilePtrGuard\n{\n  QFile logFile;\n  Q_DISABLE_COPY( LogFilePtrGuard )  \npublic:\n  LogFilePtrGuard() { logFilePtr = &logFile; }\n  ~LogFilePtrGuard() { logFilePtr = 0; }\n};\n\nint main( int argc, char ** argv )\n{\n#ifdef Q_OS_UNIX\n    // GoldenDict use lots of X11 functions and it currently cannot work\n    // natively on Wayland. This workaround will force GoldenDict to use\n    // XWayland.\n    char * xdg_envc = getenv(\"XDG_SESSION_TYPE\");\n    QString xdg_session = xdg_envc ? QString::fromLatin1(xdg_envc) : QString();\n    if (!QString::compare(xdg_session, QString(\"wayland\"), Qt::CaseInsensitive))\n    {\n        setenv(\"QT_QPA_PLATFORM\", \"xcb\", 1);\n    }\n#endif\n  #ifdef Q_OS_MAC\n    setenv(\"LANG\", \"en_US.UTF-8\", 1);\n\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n   // Check for retina display\n   if( LionSupport::isRetinaDisplay() )\n     QApplication::setGraphicsSystem( \"native\" );\n   else\n     QApplication::setGraphicsSystem( \"raster\" );\n#endif\n  #endif\n\n  // The following clause fixes a race in the MinGW runtime where throwing\n  // exceptions for the first time in several threads simultaneously can cause\n  // an abort(). This code throws first exception in a safe, single-threaded\n  // manner, thus avoiding that race.\n  {\n    class Dummy {};\n\n    try\n    { throw Dummy(); }\n    catch( Dummy )\n    {}\n  }\n\n#if defined( Q_OS_UNIX )\n  setlocale( LC_ALL, \"\" ); // use correct char set mapping\n#endif\n\n  // --show-error-file is an undocumented, hidden option passed on exit by a crashing GoldenDict instance in its\n  // terminate handler. Therefore, we can assume that, if present, --show-error-file is the first command-line\n  // argument, that the second argument is the error file name and that there are no more arguments.\n  if( argc == 3 && strcmp( argv[ 1 ], \"--show-error-file\" ) == 0 )\n  {\n    // The program has crashed -- show a message about it\n\n#ifdef Q_OS_WIN32\n    int numArgs;\n    LPWSTR *pstr = CommandLineToArgvW( GetCommandLineW(), &numArgs );\n    Q_ASSERT( pstr );\n    Q_ASSERT( numArgs == 3 );\n    QString const errorFileName = QString::fromWCharArray( pstr[ 2 ] );\n#else\n    QString const errorFileName = QString::fromLocal8Bit( argv[ 2 ] );\n#endif\n\n    argc = 1; // the two arguments are parsed just above\n    QApplication app( argc, argv );\n\n    QFile errFile( errorFileName );\n\n    QString errorText;\n\n    if ( errFile.open( QFile::ReadOnly ) )\n      errorText = QString::fromUtf8( errFile.readAll() );\n\n    errorText += \"\\n\" + QString( \"This information is located in file %1, \"\n                                 \"which will be removed once you close this dialog.\").arg( errFile.fileName() );\n\n    QMessageBox::critical( 0, \"GoldenDict has crashed\", errorText );\n\n    errFile.remove();\n\n    return 0;\n  }\n\n  installTerminationHandler();\n\n  #ifdef __DO_DEBUG\n  {\n    rlimit limit;\n\n    memset( &limit, 0, sizeof( limit ) );\n    limit.rlim_cur = RLIM_INFINITY;\n    limit.rlim_max = RLIM_INFINITY;\n    setrlimit( RLIMIT_CORE, &limit );\n  }\n  #endif\n\n#ifdef __WIN32\n\n  // Under Windows, increase the amount of fopen()-able file descriptors from\n  // the default 512 up to 2048.\n  _setmaxstdio( 2048 );\n\n#endif\n\n  QHotkeyApplication app( \"GoldenDict\", argc, argv );\n  LogFilePtrGuard logFilePtrGuard;\n\n  GDCommandLine gdcl( argc, argv );\n\n  bool const showHelpAndExit = gdcl.needShowHelp();\n  // Ignore other command-line arguments if help is requested.\n  if( !showHelpAndExit && app.isRunning() )\n  {\n    bool wasMessage = false;\n\n    if( gdcl.needToggleScanPopup() )\n    {\n      app.sendMessage( \"toggleScanPopup\" );\n      wasMessage = true;\n    }\n\n    if( gdcl.needSetGroup() )\n    {\n      app.sendMessage( QString( \"setGroup: \" ) + gdcl.getGroupName() );\n      wasMessage = true;\n    }\n\n    if( gdcl.needSetPopupGroup() )\n    {\n      app.sendMessage( QString( \"setPopupGroup: \" ) + gdcl.getPopupGroupName() );\n      wasMessage = true;\n    }\n\n    if( gdcl.needTranslateWord() )\n    {\n      app.sendMessage( QString( \"translateWord: \" ) + gdcl.wordToTranslate() );\n      wasMessage = true;\n    }\n\n    if( !wasMessage )\n      app.sendMessage(\"bringToFront\");\n\n    return 0; // Another instance is running\n  }\n\n  app.setApplicationName( \"GoldenDict\" );\n  app.setOrganizationDomain( \"http://goldendict.org/\" );\n#if QT_VERSION >= 0x040600\n  app.setStyle(new GdAppStyle);\n#endif\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 7, 0 )\n  app.setDesktopFileName( QStringLiteral( \"org.goldendict.GoldenDict\" ) );\n#endif\n\n  #ifndef Q_OS_MAC\n    app.setWindowIcon( QIcon( \":/icons/programicon.png\" ) );\n  #endif\n\n#ifdef MAKE_CHINESE_CONVERSION_SUPPORT\n  // OpenCC needs to load it's data files by relative path on Windows and OS X\n  QDir::setCurrent( Config::getProgramDataDir() );\n#endif\n\n  // Load translations for system locale\n\n  QTranslator qtTranslator;\n\n  QString localeName = QLocale::system().name();\n\n  if ( !qtTranslator.load( \"qt_\" + localeName, Config::getLocDir() ) )\n    qtTranslator.load( \"qt_\" + localeName,\n                       QLibraryInfo::location( QLibraryInfo::TranslationsPath ) );\n\n  app.installTranslator( &qtTranslator );\n\n  QTranslator translator;\n\n  translator.load( Config::getLocDir() + \"/\" + localeName );\n\n  app.installTranslator( &translator );\n\n  // Show help after loading a system locale translator to translate the help message.\n  // Show help before loading Config to avoid conflicts with a possible another running\n  // GoldenDict instance. An unfortunate consequence of not loading Config is that the\n  // interface language configured in GoldenDict Preferences does not affect the help message.\n  if( showHelpAndExit )\n  {\n    QString const helpMessage = QCoreApplication::translate( \"CommandLineHelp\",\n        \"Usage:\\n\"\n        \"  goldendict [OPTION]... [WORD|URI]\\n\\n\"\n        \"GoldenDict dictionary lookup program\\n\\n\"\n        \"  WORD\\t\\t\\t\\tA word or quoted phrase to translate\\n\"\n        \"  URI\\t\\t\\t\\t\\\"[golden]dict://[/]word or phrase to translate[/]\\\"\\n\\n\"\n        \"Options:\\n\"\n        \"  -h, --help\\t\\t\\tShow command-line help and exit\\n\"\n        \"  --log-to-file\\t\\t\\tTurn on debug mode\\n\"\n        \"  --toggle-scan-popup\\t\\tToggle scanning mode on/off\\n\"\n        \"  --group-name=GROUP\\t\\tSet current group of dictionaries in the main window to GROUP\\n\"\n        \"  --popup-group-name=GROUP\\tSet current group of dictionaries in the popup window to GROUP\\n\\n\"\n        \"If another GoldenDict instance is running, the second instance exits immediately, the options\"\n        \" --toggle-scan-popup, --group-name, --popup-group-name affect the running instance,\"\n        \" WORD or URI is translated in the running instance's popup window.\\n\"\n        \"Otherwise, all options affect the initial state of the new instance,\"\n        \" WORD or URI is translated in the new instance's main window.\\n\\n\"\n        \"Assigning a global keyboard shortcut to the \\\"goldendict --toggle-scan-popup\\\"\"\n        \" command in system preferences emulates a scanning-mode-toggling global hotkey.\"\n                                                            );\n\n#ifdef Q_OS_WIN32\n    // GoldenDict has no console under Windows. Show help in a message box\n    // on this platform, as QCommandLineParser documentation recommends.\n    QMessageBox::information( 0, QCoreApplication::translate( \"CommandLineHelp\", \"GoldenDict command-line help\" ),\n                              helpMessage );\n#else\n    QTextStream out( stdout, QIODevice::WriteOnly );\n    out << helpMessage << '\\n';\n#endif\n\n    return 0;\n  }\n\n  Config::Class cfg;\n  for( ; ; )\n  {\n    try\n    {\n      cfg = Config::load();\n    }\n    catch( Config::exError & )\n    {\n      QMessageBox mb( QMessageBox::Warning, app.applicationName(),\n                      app.translate( \"Main\", \"Error in configuration file. Continue with default settings?\" ),\n                      QMessageBox::Yes | QMessageBox::No );\n      mb.exec();\n      if( mb.result() != QMessageBox::Yes )\n        return -1;\n\n      QString configFile = Config::getConfigFileName();\n      renameAtomically( configFile, configFile + \".bad\" );\n      continue;\n    }\n    break;\n  }\n\n  if( gdcl.needLogFile() )\n  {\n    // Open log file\n    logFilePtr->setFileName( Config::getConfigDir() + \"gd_log.txt\" );\n    logFilePtr->remove();\n    logFilePtr->open( QFile::ReadWrite );\n\n    // Write UTF-8 BOM\n    QByteArray line;\n    line.append( 0xEF ).append( 0xBB ).append( 0xBF );\n    logFilePtr->write( line );\n\n    // Install message handler\n#if ( QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 ) )\n    qInstallMessageHandler( gdMessageHandler );\n#else\n    qInstallMsgHandler( gdMessageHandler );\n#endif\n  }\n\n  if ( Config::isPortableVersion() )\n  {\n    // For portable version, hardcode some settings\n\n    cfg.paths.clear();\n    cfg.paths.push_back( Config::Path( Config::getPortableVersionDictionaryDir(), true ) );\n    cfg.soundDirs.clear();\n    cfg.hunspell.dictionariesPath = Config::getPortableVersionMorphoDir();\n  }\n\n  // Reload translations for user selected locale is nesessary\n\n  if( !cfg.preferences.interfaceLanguage.isEmpty() && localeName != cfg.preferences.interfaceLanguage )\n  {\n    localeName = cfg.preferences.interfaceLanguage;\n\n    if ( !qtTranslator.load( \"qt_\" + localeName, Config::getLocDir() ) )\n      qtTranslator.load( \"qt_\" + localeName,\n                                 QLibraryInfo::location( QLibraryInfo::TranslationsPath ) );\n\n    translator.load( Config::getLocDir() + \"/\" + localeName );\n  }\n\n  // Prevent app from quitting spontaneously when it works with scan popup\n  // and with the main window closed.\n  app.setQuitOnLastWindowClosed( false );\n\n#if QT_VERSION >= 0x040600\n  // Add the dictionary scheme we use as local, so that the file:// links would\n  // work in the articles. The function was introduced in Qt 4.6.\n  QWebSecurityOrigin::addLocalScheme( \"gdlookup\" );\n#endif\n\n  MainWindow m( cfg );\n\n  app.addDataCommiter( m );\n\n  QObject::connect( &app, SIGNAL(messageReceived(const QString&)),\n    &m, SLOT(messageFromAnotherInstanceReceived(const QString&)));\n\n  if( gdcl.needToggleScanPopup() )\n    m.toggleScanPopup();\n\n  if( gdcl.needSetGroup() )\n    m.setGroupByName( gdcl.getGroupName(), true );\n\n  if( gdcl.needSetPopupGroup() )\n    m.setGroupByName( gdcl.getPopupGroupName(), false );\n\n  if( gdcl.needTranslateWord() )\n    m.wordReceived( gdcl.wordToTranslate() );\n\n  int r = app.exec();\n\n  app.removeDataCommiter( m );\n\n  if( logFilePtr->isOpen() )\n    logFilePtr->close();\n\n  return r;\n}\n"
        },
        {
          "name": "mainstatusbar.cc",
          "type": "blob",
          "size": 2.8623046875,
          "content": "/* This file is (c) 2012 Tvangeste <i.4m.l33t@yandex.ru>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"mainstatusbar.hh\"\n\n#include <Qt>\n#include <QFrame>\n#include <QVBoxLayout>\n#include <QDebug>\n#include <QEvent>\n#include <QApplication>\n\nMainStatusBar::MainStatusBar( QWidget *parent ) : QWidget( parent )\n{\n  textWidget = new QLabel( QString(), this );\n  textWidget->setObjectName( \"text\" );\n  textWidget->setFont( QApplication::font( \"QStatusBar\" ) );\n  textWidget->setSizePolicy( QSizePolicy::Fixed, QSizePolicy::Fixed );\n\n  picWidget = new QLabel( QString(), this );\n  picWidget->setObjectName( \"icon\" );\n  picWidget->setPixmap( QPixmap() );\n  picWidget->setScaledContents( true );\n  picWidget->setSizePolicy( QSizePolicy::Fixed, QSizePolicy::Ignored );\n\n  timer = new QTimer( this );\n  timer->setSingleShot( true );\n\n  // layout\n  QHBoxLayout * layout = new QHBoxLayout;\n  layout->setSpacing( 0 );\n  layout->setSizeConstraint( QLayout::SetFixedSize );\n  layout->setAlignment( Qt::AlignLeft | Qt::AlignVCenter );\n  layout->setContentsMargins( 0, 0, 0, 0 );\n  layout->addWidget( picWidget );\n  layout->addWidget( textWidget );\n  setLayout( layout );\n\n  parentWidget()->installEventFilter( this );\n\n  connect( timer, SIGNAL( timeout() ), SLOT( clearMessage() ) );\n}\n\nbool MainStatusBar::hasImage() const\n{\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 15, 0 )\n  return !picWidget->pixmap( Qt::ReturnByValue ).isNull();\n#else\n  return !picWidget->pixmap()->isNull();\n#endif\n}\n\nvoid MainStatusBar::clearMessage()\n{\n  message.clear();\n  textWidget->setText( backgroungMessage );\n  picWidget->setPixmap( QPixmap() );\n  timer->stop();\n  refresh();\n}\n\nQString MainStatusBar::currentMessage() const\n{\n  return message;\n}\n\nvoid MainStatusBar::setBackgroundMessage(const QString & bkg_message )\n{\n  backgroungMessage = bkg_message;\n  if( message.isEmpty() )\n  {\n    textWidget->setText( backgroungMessage );\n    refresh();\n  }\n}\n\nvoid MainStatusBar::showMessage(const QString & str, int timeout, const QPixmap & pixmap)\n{\n  textWidget->setText( message = str );\n  picWidget->setPixmap( pixmap );\n\n  // reload stylesheet\n  setStyleSheet( styleSheet() );\n\n  if ( timeout > 0 )\n  {\n    timer->start( timeout );\n  }\n\n  refresh();\n}\n\nvoid MainStatusBar::refresh()\n{\n  if ( !textWidget->text().isEmpty() )\n  {\n    adjustSize();\n\n    if ( hasImage() )\n    {\n      picWidget->setFixedSize( textWidget->height(), textWidget->height() );\n    }\n    else\n    {\n      picWidget->setFixedSize( 0, 0 );\n    }\n\n    adjustSize();\n\n    move( QPoint( 0, parentWidget()->height() - height() ) );\n\n    show();\n    raise();\n  }\n  else\n  {\n    hide();\n  }\n}\n\nvoid MainStatusBar::mousePressEvent ( QMouseEvent * )\n{\n  clearMessage();\n}\n\nbool MainStatusBar::eventFilter( QObject *, QEvent * e )\n{\n  switch ( e->type() ) {\n    case QEvent::Resize:\n      refresh();\n      break;\n    default:\n      break;\n  };\n\n  return false;\n}\n"
        },
        {
          "name": "mainstatusbar.hh",
          "type": "blob",
          "size": 1.001953125,
          "content": "/* This file is (c) 2012 Tvangeste <i.4m.l33t@yandex.ru>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef MAINSTATUSBAR_HH\n#define MAINSTATUSBAR_HH\n\n#include <QWidget>\n#include <QLabel>\n#include <QString>\n#include <QTimer>\n\nclass MainStatusBar : public QWidget\n{\n  Q_OBJECT\n  Q_PROPERTY(bool hasImage READ hasImage)\n\npublic:\n  explicit MainStatusBar(QWidget * parent);\n  QString currentMessage() const;\n\nsignals:\n\npublic slots:\n  void showMessage(const QString & text, int timeout = 0, const QPixmap & pixmap = QPixmap());\n  void clearMessage();\n  void setBackgroundMessage( QString const & message );\n\nprotected:\n  virtual void mousePressEvent(QMouseEvent * event);\n\nprivate:\n  // component to display a small picture\n  QLabel * picWidget;\n\n  // component to display text\n  QLabel * textWidget;\n\n  QTimer * timer;\n  QString backgroungMessage;\n  QString message;\n\n  bool eventFilter(QObject *obj, QEvent * event);\n  void refresh();\n  bool hasImage() const;\n};\n\n#endif // MAINSTATUSBAR_HH\n"
        },
        {
          "name": "maintabwidget.cc",
          "type": "blob",
          "size": 1.8193359375,
          "content": "/* This file is (c) 2012 Tvangeste <i.4m.l33t@yandex.ru>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"maintabwidget.hh\"\n#include \"qt4x5.hh\"\n#include <QDebug>\n#include <QEvent>\n#include <QMouseEvent>\n\nMainTabWidget::MainTabWidget( QWidget * parent) : QTabWidget( parent ) {\n  hideSingleTab = false;\n  installEventFilter( this );\n  tabBar()->installEventFilter( this );\n}\n\nvoid MainTabWidget::setHideSingleTab(bool hide)\n{\n  hideSingleTab = hide;\n  updateTabBarVisibility();\n}\n\nvoid MainTabWidget::tabInserted(int index)\n{\n  (void) index;\n  updateTabBarVisibility();\n\n  // Avoid bug in Qt 4.8.0\n  setUsesScrollButtons( count() > 10 );\n}\n\nvoid MainTabWidget::tabRemoved(int index)\n{\n  (void) index;\n  updateTabBarVisibility();\n\n  // Avoid bug in Qt 4.8.0\n  setUsesScrollButtons( count() > 10 );\n}\n\nvoid MainTabWidget::updateTabBarVisibility()\n{\n  tabBar()->setVisible( !hideSingleTab || tabBar()->count() > 1 );\n}\n\n/*\nvoid MainTabWidget::mouseDoubleClickEvent ( QMouseEvent * event )\n{\n  (void) event;\n  emit doubleClicked();\n}\n*/\n\nbool MainTabWidget::eventFilter( QObject * obj, QEvent * ev )\n{\n  // mouseDoubleClickEvent don't called under Ubuntu\n  if( ev->type() == QEvent::MouseButtonDblClick )\n  {\n    QMouseEvent * mev = static_cast< QMouseEvent *>( ev );\n    if( mev->y() >= tabBar()->rect().y()\n        && mev->y() <= tabBar()->rect().y() + tabBar()->rect().height()\n        && tabBar()->tabAt( mev->pos() ) == -1 )\n    {\n      emit doubleClicked();\n      return true;\n    }\n  }\n\n  if( obj == tabBar() && ev->type() == QEvent::MouseButtonPress )\n  {\n     QMouseEvent * mev = static_cast< QMouseEvent *>( ev );\n     if( mev->button() == Qt4x5::middleButton() )\n     {\n         emit tabCloseRequested( tabBar()->tabAt( mev->pos() ) );\n         return true;\n     }\n  }\n\n  return QTabWidget::eventFilter( obj, ev );\n}\n"
        },
        {
          "name": "maintabwidget.hh",
          "type": "blob",
          "size": 0.91015625,
          "content": "/* This file is (c) 2012 Tvangeste <i.4m.l33t@yandex.ru>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef MAINTABWIDGET_HH\n#define MAINTABWIDGET_HH\n\n#include <QTabWidget>\n#include <QTabBar>\n\n/// An extension of QTabWidget that allows to better control\n/// the tabbar visibility.\nclass MainTabWidget: public QTabWidget\n{\n  Q_OBJECT\n  Q_PROPERTY(bool hideSingleTab READ isHideSingleTab WRITE setHideSingleTab)\n\npublic:\n  MainTabWidget( QWidget * parent = 0 );\n\n  bool isHideSingleTab() const { return hideSingleTab; }\n  void setHideSingleTab(bool hide);\n\nsignals:\n  void doubleClicked();\n\nprotected:\n//  virtual void mouseDoubleClickEvent ( QMouseEvent * event );\n\nprivate:\n  virtual void tabInserted(int index);\n  virtual void tabRemoved(int index);\n  void updateTabBarVisibility();\n  virtual bool eventFilter( QObject * obj, QEvent * ev );\n\n  bool hideSingleTab;\n};\n\n#endif // MAINTABWIDGET_HH\n"
        },
        {
          "name": "mainwindow.cc",
          "type": "blob",
          "size": 147.5126953125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef NO_EPWING_SUPPORT\n#include \"epwing_book.hh\"\n#endif\n\n#include \"mainwindow.hh\"\n#include \"editdictionaries.hh\"\n#include \"loaddictionaries.hh\"\n#include \"preferences.hh\"\n#include \"about.hh\"\n#include \"mruqmenu.hh\"\n#include \"gestures.hh\"\n#include \"dictheadwords.hh\"\n#include <limits.h>\n#include <QDebug>\n#include <QTextStream>\n#include <QDir>\n#include <QUrl>\n#include <QMessageBox>\n#include <QIcon>\n#include <QList>\n#include <QToolBar>\n#include <QCloseEvent>\n#include <QDesktopServices>\n#include <QProcess>\n#include <QCryptographicHash>\n#include <QFileDialog>\n#include <QPrinter>\n#include <QPageSetupDialog>\n#include <QPrintPreviewDialog>\n#include <QPrintDialog>\n#include <QRunnable>\n#include <QThreadPool>\n#include <QSslConfiguration>\n\n#include <limits.h>\n#include <set>\n#include <map>\n#include \"gddebug.hh\"\n\n#include \"dictinfo.hh\"\n#include \"fsencoding.hh\"\n#include \"historypanewidget.hh\"\n#include \"qt4x5.hh\"\n#include <QDesktopWidget>\n#include \"ui_authentication.h\"\n\n#ifdef Q_OS_MAC\n#include \"lionsupport.h\"\n#include \"macmouseover.hh\"\n#endif\n\n#ifdef Q_OS_WIN32\n#include <windows.h>\n#include \"mouseover_win32/GDDataTranfer.h\"\n#include \"wstring.hh\"\n#include \"wstring_qt.hh\"\n\n#define gdStoreNormalGeometryEvent ( ( QEvent::Type )( QEvent::User + 1 ) )\n#define gdApplyNormalGeometryEvent ( ( QEvent::Type )( QEvent::User + 2 ) )\n\n#endif\n\n#ifdef X11_MAIN_WINDOW_FOCUS_WORKAROUNDS\n#include <QX11Info>\n#include <X11/Xlib.h>\n#include <fixx11h.h>\n#endif\n\n#define MIN_THREAD_COUNT 4\n\nusing std::set;\nusing std::wstring;\nusing std::map;\nusing std::pair;\n\nnamespace {\n\n#ifdef X11_MAIN_WINDOW_FOCUS_WORKAROUNDS\nclass MinimumSizeWidget: public QWidget\n{\n  Q_OBJECT\npublic:\n  explicit MinimumSizeWidget( QWidget * parent ):\n    QWidget( parent )\n  {\n    setSizePolicy( QSizePolicy::Fixed, QSizePolicy::Fixed );\n  }\n\n  virtual QSize sizeHint() const\n  { return QSize( 1, 1 ); }\n};\n#endif\n\n} // unnamed namespace\n\n#ifndef QT_NO_OPENSSL\n\nclass InitSSLRunnable : public QRunnable\n{\n  virtual void run()\n  {\n    /// This action force SSL library initialisation which may continue a few seconds\n    QSslConfiguration::setDefaultConfiguration( QSslConfiguration::defaultConfiguration() );\n  }\n};\n\n#endif\n\nMainWindow::MainWindow( Config::Class & cfg_ ):\n  trayIcon( 0 ),\n  groupLabel( &searchPaneTitleBar ),\n  foundInDictsLabel( &dictsPaneTitleBar ),\n  escAction( this ),\n  focusTranslateLineAction( this ),\n  addTabAction( this ),\n  closeCurrentTabAction( this ),\n  closeAllTabAction( this ),\n  closeRestTabAction( this ),\n  switchToNextTabAction( this ),\n  switchToPrevTabAction( this ),\n  showDictBarNamesAction( tr( \"Show Names in Dictionary &Bar\" ), this ),\n  useSmallIconsInToolbarsAction( tr( \"Show Small Icons in &Toolbars\" ), this ),\n  toggleMenuBarAction( tr( \"&Menubar\" ), this ),\n  switchExpandModeAction( this ),\n  focusHeadwordsDlgAction( this ),\n  focusArticleViewAction( this ),\n  addAllTabToFavoritesAction( this ),\n  trayIconMenu( this ),\n  addTab( this ),\n  cfg( cfg_ ),\n  history( History::Load(), cfg_.preferences.maxStringsInHistory, cfg_.maxHeadwordSize ),\n  dictionaryBar( this, configEvents, cfg.editDictionaryCommandLine, cfg.preferences.maxDictionaryRefsInContextMenu ),\n  articleMaker( dictionaries, groupInstances, cfg.preferences.displayStyle,\n                cfg.preferences.addonStyle ),\n  articleNetMgr( this, dictionaries, articleMaker,\n                 cfg.preferences.disallowContentFromOtherSites, cfg.preferences.hideGoldenDictHeader ),\n  dictNetMgr( this ),\n  audioPlayerFactory( cfg.preferences ),\n  wordFinder( this ),\n  newReleaseCheckTimer( this ),\n  latestReleaseReply( 0 ),\n  wordListSelChanged( false )\n, wasMaximized( false )\n, blockUpdateWindowTitle( false )\n, headwordsDlg( 0 )\n, ftsIndexing( dictionaries )\n, ftsDlg( 0 )\n, helpWindow( 0 )\n, starIcon( \":/icons/star.png\" )\n, blueStarIcon( \":/icons/star_blue.png\" )\n#ifdef Q_OS_WIN32\n, gdAskMessage( 0xFFFFFFFF )\n#endif\n{\n  if( QThreadPool::globalInstance()->maxThreadCount() < MIN_THREAD_COUNT )\n    QThreadPool::globalInstance()->setMaxThreadCount( MIN_THREAD_COUNT );\n\n#ifndef QT_NO_OPENSSL\n  QThreadPool::globalInstance()->start( new InitSSLRunnable );\n#endif\n\n  qRegisterMetaType< Config::InputPhrase >();\n\n#ifndef NO_EPWING_SUPPORT\n  Epwing::initialize();\n#endif\n\n  ui.setupUi( this );\n\n  articleMaker.setCollapseParameters( cfg.preferences.collapseBigArticles, cfg.preferences.articleSizeLimit );\n\n#if QT_VERSION >= QT_VERSION_CHECK(4, 6, 0)\n  // Set own gesture recognizers\n  Gestures::registerRecognizers();\n#endif\n\n  // use our own, custom statusbar\n  setStatusBar(0);\n  mainStatusBar = new MainStatusBar( this );\n\n  // Make the toolbar\n  navToolbar = addToolBar( tr( \"&Navigation\" ) );\n  navToolbar->setObjectName( \"navToolbar\" );\n\n  navBack = navToolbar->addAction( QIcon( \":/icons/previous.png\" ), tr( \"Back\" ) );\n  navToolbar->widgetForAction( navBack )->setObjectName( \"backButton\" );\n  navForward = navToolbar->addAction( QIcon( \":/icons/next.png\" ), tr( \"Forward\" ) );\n  navToolbar->widgetForAction( navForward )->setObjectName( \"forwardButton\" );\n\n  QWidget * translateBoxWidget = new QWidget( this );\n  QHBoxLayout * translateBoxLayout = new QHBoxLayout( translateBoxWidget );\n  translateBoxWidget->setLayout( translateBoxLayout );\n  translateBoxLayout->setContentsMargins( 0, 0, 0, 0 );\n  translateBoxLayout->setSpacing( 0 );\n\n  // translate box\n  groupListInToolbar = new GroupComboBox( navToolbar );\n  groupListInToolbar->setSizePolicy( QSizePolicy::Fixed, QSizePolicy::Preferred );\n  groupListInToolbar->setSizeAdjustPolicy( QComboBox::AdjustToContents );\n  translateBoxLayout->addWidget( groupListInToolbar );\n\n  translateBox = new TranslateBox( navToolbar );\n  translateBox->setSizePolicy( QSizePolicy::MinimumExpanding, QSizePolicy::Fixed );\n  translateBoxLayout->addWidget( translateBox );\n  translateBoxToolBarAction = navToolbar->addWidget( translateBoxWidget );\n\n  // scan popup\n  beforeScanPopupSeparator = navToolbar->addSeparator();\n  beforeScanPopupSeparator->setVisible( cfg.preferences.enableScanPopup );\n  navToolbar->widgetForAction( beforeScanPopupSeparator )->setObjectName( \"beforeScanPopupSeparator\" );\n\n  enableScanPopup = navToolbar->addAction( QIcon( \":/icons/wizard.png\" ), tr( \"Scan Popup\" ) );\n  enableScanPopup->setCheckable( true );\n  enableScanPopup->setVisible( cfg.preferences.enableScanPopup );\n  navToolbar->widgetForAction( enableScanPopup )->setObjectName( \"scanPopupButton\" );\n  if ( cfg.preferences.enableScanPopup && cfg.preferences.startWithScanPopupOn )\n    enableScanPopup->setChecked( true );\n\n  connect( enableScanPopup, SIGNAL( toggled( bool ) ),\n           this, SLOT( scanEnableToggled( bool ) ) );\n\n  afterScanPopupSeparator = navToolbar->addSeparator();\n  afterScanPopupSeparator->setVisible( cfg.preferences.enableScanPopup );\n  navToolbar->widgetForAction( afterScanPopupSeparator )->setObjectName( \"afterScanPopupSeparator\" );\n\n  // sound\n  navPronounce = navToolbar->addAction( QIcon( \":/icons/playsound_full.png\" ), tr( \"Pronounce Word (Alt+S)\" ) );\n  navPronounce->setShortcut( QKeySequence( \"Alt+S\" ) );\n  navPronounce->setEnabled( false );\n  navToolbar->widgetForAction( navPronounce )->setObjectName( \"soundButton\" );\n\n  connect( navPronounce, SIGNAL( triggered() ),\n           this, SLOT( pronounce() ) );\n\n  // zooming\n  // named separator (to be able to hide it via CSS)\n  navToolbar->widgetForAction( navToolbar->addSeparator() )->setObjectName( \"separatorBeforeZoom\" );\n\n  zoomIn = navToolbar->addAction( QIcon( \":/icons/icon32_zoomin.png\" ), tr( \"Zoom In\" ) );\n  zoomIn->setShortcuts( QList< QKeySequence >() <<\n                       QKeySequence::ZoomIn <<\n                       QKeySequence( \"Ctrl+=\" ) );\n  navToolbar->widgetForAction( zoomIn )->setObjectName( \"zoomInButton\" );\n\n  zoomOut = navToolbar->addAction( QIcon( \":/icons/icon32_zoomout.png\" ), tr( \"Zoom Out\" ) );\n  zoomOut->setShortcut( QKeySequence::ZoomOut );\n  navToolbar->widgetForAction( zoomOut )->setObjectName( \"zoomOutButton\" );\n\n  zoomBase = navToolbar->addAction( QIcon( \":/icons/icon32_zoombase.png\" ), tr( \"Normal Size\" ) );\n  zoomBase->setShortcut( QKeySequence( \"Ctrl+0\" ) );\n  navToolbar->widgetForAction( zoomBase )->setObjectName( \"zoomBaseButton\" );\n\n  // named separator (to be able to hide it via CSS)\n  navToolbar->widgetForAction( navToolbar->addSeparator() )->setObjectName( \"separatorBeforeSave\" );\n\n  navToolbar->addAction( ui.saveArticle );\n  navToolbar->widgetForAction( ui.saveArticle )->setObjectName( \"saveArticleButton\" );\n\n  navToolbar->addAction( ui.print );\n  navToolbar->widgetForAction( ui.print )->setObjectName( \"printButton\" );\n\n  navToolbar->widgetForAction( navToolbar->addSeparator() )->setObjectName( \"separatorBeforeAddToFavorites\" );\n\n  addToFavorites = navToolbar->addAction( starIcon, tr( \"Add current tab to Favorites\" ) );\n  navToolbar->widgetForAction( addToFavorites )->setObjectName( \"addToFavoritesButton\" );\n\n  connect( addToFavorites, SIGNAL( triggered() ), this, SLOT( handleAddToFavoritesButton() ) );\n  connect( ui.actionAddToFavorites, SIGNAL( triggered() ), this, SLOT( addCurrentTabToFavorites() ) );\n\n  beforeOptionsSeparator = navToolbar->addSeparator();\n  navToolbar->widgetForAction( beforeOptionsSeparator )->setObjectName( \"beforeOptionsSeparator\" );\n  beforeOptionsSeparator->setVisible( cfg.preferences.hideMenubar);\n\n  QMenu * buttonMenu = new QMenu( this );\n  buttonMenu->addAction( ui.dictionaries );\n  buttonMenu->addAction( ui.preferences );\n  buttonMenu->addSeparator();\n  buttonMenu->addMenu( ui.menuFavorites );\n  buttonMenu->addMenu( ui.menuHistory );\n  buttonMenu->addSeparator();\n  buttonMenu->addMenu( ui.menuFile );\n  buttonMenu->addMenu( ui.menuView );\n  buttonMenu->addMenu( ui.menuSearch );\n  buttonMenu->addMenu( ui.menu_Help );\n\n  ui.fullTextSearchAction->setEnabled( cfg.preferences.fts.enabled );\n\n  menuButton = new QToolButton( navToolbar );\n  menuButton->setPopupMode( QToolButton::InstantPopup );\n  menuButton->setMenu( buttonMenu );\n  menuButton->setIcon( QIcon (\":/icons/menu_button.png\") );\n  menuButton->addAction( ui.menuOptions );\n  menuButton->setToolTip( tr( \"Menu Button\" ) );\n  menuButton->setObjectName( \"menuButton\" );\n  menuButton->setFocusPolicy( Qt::NoFocus );\n\n  menuButtonAction = navToolbar->addWidget(menuButton);\n  menuButtonAction->setVisible( cfg.preferences.hideMenubar );\n\n  // Make the search pane's titlebar\n  groupLabel.setText( tr( \"Look up in:\" ) );\n  groupListInDock = new GroupComboBox( &searchPaneTitleBar );\n\n  searchPaneTitleBarLayout.setContentsMargins( 8, 5, 8, 4 );\n  searchPaneTitleBarLayout.addWidget( &groupLabel );\n  searchPaneTitleBarLayout.addWidget( groupListInDock );\n  searchPaneTitleBarLayout.addStretch();\n\n  searchPaneTitleBar.setLayout( &searchPaneTitleBarLayout );\n\n  ui.searchPane->setTitleBarWidget( &searchPaneTitleBar );\n  connect( ui.searchPane->toggleViewAction(), SIGNAL( triggered( bool ) ),\n           this, SLOT( updateSearchPaneAndBar( bool ) ) );\n\n  if ( cfg.preferences.searchInDock )\n  {\n    groupList = groupListInDock;\n    translateLine = ui.translateLine;\n    wordList = ui.wordList;\n  }\n  else\n  {\n    groupList = groupListInToolbar;\n    translateLine = translateBox->translateLine();\n    wordList = translateBox->wordList();\n  }\n  wordList->attachFinder( &wordFinder );\n\n  // for the old UI:\n  ui.wordList->setTranslateLine( ui.translateLine );\n\n  groupList->setFocusPolicy(Qt::ClickFocus);\n  wordList->setFocusPolicy(Qt::ClickFocus);\n\n  wordListDefaultFont = wordList->font();\n  translateLineDefaultFont = translateLine->font();\n  groupListDefaultFont = groupList->font();\n\n  // Make the dictionaries pane's titlebar\n  foundInDictsLabel.setText( tr( \"Found in Dictionaries:\" ) );\n  dictsPaneTitleBarLayout.addWidget( &foundInDictsLabel );\n  dictsPaneTitleBarLayout.setContentsMargins(5, 5, 5, 5);\n  dictsPaneTitleBar.setLayout( &dictsPaneTitleBarLayout );\n  dictsPaneTitleBar.setObjectName(\"dictsPaneTitleBar\");\n  ui.dictsPane->setTitleBarWidget( &dictsPaneTitleBar );\n  ui.dictsList->setContextMenuPolicy( Qt::CustomContextMenu );\n\n  connect( ui.dictsPane, SIGNAL( visibilityChanged( bool ) ),\n           this, SLOT( dictsPaneVisibilityChanged ( bool ) ) );\n\n  connect( ui.dictsList, SIGNAL( itemClicked( QListWidgetItem * ) ),\n           this, SLOT( foundDictsPaneClicked( QListWidgetItem * ) ) );\n\n  connect( ui.dictsList, SIGNAL( customContextMenuRequested( const QPoint & ) ),\n           this, SLOT( foundDictsContextMenuRequested( const QPoint & ) ) );\n\n  connect( zoomIn, SIGNAL( triggered() ),\n           this, SLOT( zoomin() ) );\n  connect( zoomOut, SIGNAL( triggered() ),\n           this, SLOT( zoomout() ) );\n  connect( zoomBase, SIGNAL( triggered() ),\n           this, SLOT( unzoom() ) );\n\n  ui.menuZoom->addAction( zoomIn );\n  ui.menuZoom->addAction( zoomOut );\n  ui.menuZoom->addAction( zoomBase );\n\n  ui.menuZoom->addSeparator();\n\n  wordsZoomIn = ui.menuZoom->addAction( QIcon( \":/icons/icon32_zoomin.png\" ), tr( \"Words Zoom In\" ) );\n  wordsZoomIn->setShortcuts( QList< QKeySequence >() <<\n                            QKeySequence( \"Alt++\" ) <<\n                            QKeySequence( \"Alt+=\" ) );\n  wordsZoomOut = ui.menuZoom->addAction( QIcon( \":/icons/icon32_zoomout.png\" ), tr( \"Words Zoom Out\" ) );\n  wordsZoomOut->setShortcut( QKeySequence( \"Alt+-\" ) );\n  wordsZoomBase = ui.menuZoom->addAction( QIcon( \":/icons/icon32_zoombase.png\" ), tr( \"Words Normal Size\" ) );\n  wordsZoomBase->setShortcut( QKeySequence( \"Alt+0\" ) );\n\n  connect( wordsZoomIn, SIGNAL(triggered()), this, SLOT(doWordsZoomIn()) );\n  connect( wordsZoomOut, SIGNAL(triggered()), this, SLOT(doWordsZoomOut()) );\n  connect( wordsZoomBase, SIGNAL(triggered()), this, SLOT(doWordsZoomBase()) );\n\n  // tray icon\n  connect( trayIconMenu.addAction( tr( \"Show &Main Window\" ) ), SIGNAL( triggered() ),\n           this, SLOT( showMainWindow() ) );\n  trayIconMenu.addAction( enableScanPopup );\n  trayIconMenu.addSeparator();\n  connect( trayIconMenu.addAction( tr( \"&Quit\" ) ), SIGNAL( triggered() ),\n           this, SLOT( quitApp() ) );\n\n  addGlobalAction( &escAction, SLOT( handleEsc() ) );\n  escAction.setShortcut( QKeySequence( \"Esc\" ) );\n\n  addGlobalAction( &focusTranslateLineAction, SLOT( focusTranslateLine() ) );\n  focusTranslateLineAction.setShortcuts( QList< QKeySequence >() <<\n                                         QKeySequence( \"Alt+D\" ) <<\n                                         QKeySequence( \"Ctrl+L\" ) );\n\n  addGlobalAction( &focusHeadwordsDlgAction, SLOT( focusHeadwordsDialog() ) );\n  focusHeadwordsDlgAction.setShortcut( QKeySequence( \"Ctrl+D\" ) );\n\n  addGlobalAction( &focusArticleViewAction, SLOT( focusArticleView() ) );\n  focusArticleViewAction.setShortcut( QKeySequence( \"Ctrl+N\" ) );\n\n  addGlobalAction( ui.fullTextSearchAction, SLOT( showFullTextSearchDialog() ) );\n\n  addTabAction.setShortcutContext( Qt::WidgetWithChildrenShortcut );\n  addTabAction.setShortcut( QKeySequence( \"Ctrl+T\" ) );\n\n  // Tab management\n  tabListMenu = new MRUQMenu(tr(\"Opened tabs\"), ui.tabWidget);\n\n  connect (tabListMenu, SIGNAL(ctrlReleased()), this, SLOT(ctrlReleased()));\n\n  connect( &addTabAction, SIGNAL( triggered() ),\n           this, SLOT( addNewTab() ) );\n\n  addAction( &addTabAction );\n\n  closeCurrentTabAction.setShortcutContext( Qt::WidgetWithChildrenShortcut );\n  closeCurrentTabAction.setShortcut( QKeySequence( \"Ctrl+W\" ) );\n  closeCurrentTabAction.setText( tr(\"Close current tab\") );\n  closeCurrentTabAction.setIcon( QIcon(\":/icons/closetab.png\") );\n\n  connect( &closeCurrentTabAction, SIGNAL( triggered() ),\n           this, SLOT( closeCurrentTab() ) );\n\n  addAction( &closeCurrentTabAction );\n\n  closeAllTabAction.setShortcutContext( Qt::WidgetWithChildrenShortcut );\n  closeAllTabAction.setShortcut( QKeySequence( \"Ctrl+Shift+W\" ) );\n  closeAllTabAction.setText( tr(\"Close all tabs\") );\n\n  connect( &closeAllTabAction, SIGNAL( triggered() ),\n           this, SLOT( closeAllTabs() ) );\n\n  addAction( &closeAllTabAction );\n\n  closeRestTabAction.setShortcutContext( Qt::WidgetWithChildrenShortcut );\n  closeRestTabAction.setText( tr(\"Close all tabs except current\") );\n\n  connect( &closeRestTabAction, SIGNAL( triggered() ),\n           this, SLOT( closeRestTabs() ) );\n\n  addAction( &closeRestTabAction );\n\n  switchToNextTabAction.setShortcutContext( Qt::WidgetWithChildrenShortcut );\n  switchToNextTabAction.setShortcut( QKeySequence( \"Ctrl+PgDown\" ) );\n\n  connect( &switchToNextTabAction, SIGNAL( triggered() ),\n           this, SLOT( switchToNextTab() ) );\n\n  addAction( &switchToNextTabAction );\n\n  switchToPrevTabAction.setShortcutContext( Qt::WidgetWithChildrenShortcut );\n  switchToPrevTabAction.setShortcut( QKeySequence( \"Ctrl+PgUp\" ) );\n\n  connect( &switchToPrevTabAction, SIGNAL( triggered() ),\n           this, SLOT( switchToPrevTab() ) );\n\n  addAction( &switchToPrevTabAction );\n\n  switchExpandModeAction.setShortcutContext( Qt::WidgetWithChildrenShortcut );\n  switchExpandModeAction.setShortcuts( QList< QKeySequence >() <<\n                                       QKeySequence( Qt::CTRL + Qt::Key_8 ) <<\n                                       QKeySequence( Qt::CTRL + Qt::Key_Asterisk ) <<\n                                       QKeySequence( Qt::CTRL + Qt::SHIFT + Qt::Key_8 ) );\n\n  connect( &switchExpandModeAction, SIGNAL( triggered() ),\n           this, SLOT(switchExpandOptionalPartsMode() ) );\n\n  addAction( &switchExpandModeAction );\n\n  addAllTabToFavoritesAction.setText( tr( \"Add all tabs to Favorites\" ) );\n\n  connect( &addAllTabToFavoritesAction, SIGNAL( triggered() ),\n           this, SLOT( addAllTabsToFavorites() ) );\n\n  tabMenu = new QMenu(this);\n  tabMenu->addAction( &closeCurrentTabAction );\n  tabMenu->addAction( &closeRestTabAction );\n  tabMenu->addSeparator();\n  tabMenu->addAction( &closeAllTabAction );\n  tabMenu->addSeparator();\n  tabMenu->addAction( addToFavorites );\n  tabMenu->addAction( &addAllTabToFavoritesAction );\n\n  // Dictionary bar names\n\n  showDictBarNamesAction.setCheckable( true );\n  showDictBarNamesAction.setChecked( cfg.showingDictBarNames );\n\n  connect( &showDictBarNamesAction, SIGNAL( triggered() ),\n           this, SLOT( showDictBarNamesTriggered() ) );\n\n  // Use small icons in toolbars\n\n  useSmallIconsInToolbarsAction.setCheckable( true );\n  useSmallIconsInToolbarsAction.setChecked( cfg.usingSmallIconsInToolbars );\n\n  connect( &useSmallIconsInToolbarsAction, SIGNAL( triggered() ),\n           this, SLOT( useSmallIconsInToolbarsTriggered() ) );\n\n  // Toggle Menubar\n  toggleMenuBarAction.setCheckable( true );\n  toggleMenuBarAction.setChecked( !cfg.preferences.hideMenubar );\n  toggleMenuBarAction.setShortcut( QKeySequence( \"Ctrl+M\" ) );\n\n  connect( &toggleMenuBarAction, SIGNAL( triggered() ),\n           this, SLOT( toggleMenuBarTriggered() ) );\n\n  // Populate 'View' menu\n\n  ui.menuView->addAction( &toggleMenuBarAction );\n  ui.menuView->addSeparator();\n  ui.menuView->addAction( ui.searchPane->toggleViewAction() );\n  ui.searchPane->toggleViewAction()->setShortcut( QKeySequence( \"Ctrl+S\" ) );\n  ui.menuView->addAction( ui.dictsPane->toggleViewAction() );\n  ui.dictsPane->toggleViewAction()->setShortcut( QKeySequence( \"Ctrl+R\" ) );\n  ui.menuView->addAction( ui.favoritesPane->toggleViewAction() );\n  ui.favoritesPane->toggleViewAction()->setShortcut( QKeySequence( \"Ctrl+I\" ) );\n  ui.menuView->addAction( ui.historyPane->toggleViewAction() );\n  ui.historyPane->toggleViewAction()->setShortcut( QKeySequence( \"Ctrl+H\" ) );\n  ui.menuView->addSeparator();\n  ui.menuView->addAction( dictionaryBar.toggleViewAction() );\n  ui.menuView->addAction( navToolbar->toggleViewAction() );\n  ui.menuView->addSeparator();\n  ui.menuView->addAction( &showDictBarNamesAction );\n  ui.menuView->addAction( &useSmallIconsInToolbarsAction );\n  ui.menuView->addSeparator();\n  ui.alwaysOnTop->setChecked( cfg.preferences.alwaysOnTop );\n  ui.menuView->addAction( ui.alwaysOnTop );\n\n  // Dictionary bar\n\n  Instances::Group const * igrp = groupInstances.findGroup( cfg.lastMainGroupId );\n  if( cfg.lastMainGroupId == Instances::Group::AllGroupId )\n  {\n    if( igrp )\n      igrp->checkMutedDictionaries( &cfg.mutedDictionaries );\n    dictionaryBar.setMutedDictionaries( &cfg.mutedDictionaries );\n  }\n  else\n  {\n    Config::Group * grp = cfg.getGroup( cfg.lastMainGroupId );\n    if( igrp && grp )\n      igrp->checkMutedDictionaries( &grp->mutedDictionaries );\n    dictionaryBar.setMutedDictionaries( grp ? &grp->mutedDictionaries : 0 );\n  }\n\n  showDictBarNamesTriggered(); // Make update its state according to initial\n                               // setting\n\n  useSmallIconsInToolbarsTriggered();\n\n  connect( this, SIGNAL( clickOnDictPane( QString const & ) ),\n           &dictionaryBar, SLOT( dictsPaneClicked( QString const & ) ) );\n\n  addToolBar( &dictionaryBar );\n\n  connect( dictionaryBar.toggleViewAction(), SIGNAL(triggered(bool)),\n           this, SLOT(dictionaryBarToggled(bool)) );\n  // This one will be disconnected once the slot is activated. It exists\n  // only to handle the initial appearance of the dictionary bar.\n  connect( dictionaryBar.toggleViewAction(), SIGNAL(toggled(bool)),\n           this, SLOT(dictionaryBarToggled(bool)) );\n\n  connect( &dictionaryBar, SIGNAL(editGroupRequested()),\n           this, SLOT(editCurrentGroup()) );\n\n  connect( &dictionaryBar, SIGNAL( showDictionaryInfo( QString const & ) ),\n           this, SLOT( showDictionaryInfo( QString const & ) ) );\n\n  connect( &dictionaryBar, SIGNAL( showDictionaryHeadwords( QString const & ) ),\n           this, SLOT( showDictionaryHeadwords( QString const & ) ) );\n\n  connect( &dictionaryBar, SIGNAL( openDictionaryFolder( QString const & ) ),\n           this, SLOT( openDictionaryFolder( QString const & ) ) );\n\n  // Favorites\n\n  ui.favoritesPaneWidget->setUp( &cfg, ui.menuFavorites );\n  ui.favoritesPaneWidget->setSaveInterval( cfg.preferences.favoritesStoreInterval );\n\n  connect( ui.favoritesPane, SIGNAL( visibilityChanged( bool ) ),\n           this, SLOT( updateFavoritesMenu() ) );\n\n  connect( ui.menuFavorites, SIGNAL( aboutToShow() ),\n           this, SLOT( updateFavoritesMenu() ) );\n\n  connect( ui.favoritesPaneWidget, SIGNAL( favoritesItemRequested( QString, QString ) ),\n           this, SLOT( headwordFromFavorites( QString, QString ) ) );\n\n  // History\n  ui.historyPaneWidget->setUp( &cfg, &history, ui.menuHistory );\n  history.enableAdd( cfg.preferences.storeHistory );\n\n  connect( ui.historyPaneWidget, SIGNAL( historyItemRequested( QString const & ) ),\n           this, SLOT( showHistoryItem( QString const & ) ) );\n\n  connect( ui.historyPane, SIGNAL( visibilityChanged( bool ) ),\n           this, SLOT( updateHistoryMenu() ) );\n\n  connect( ui.menuHistory, SIGNAL( aboutToShow() ),\n           this, SLOT( updateHistoryMenu() ) );\n\n#if !defined( HAVE_X11 ) || QT_VERSION < QT_VERSION_CHECK( 5, 0, 0 )\n  // Show tray icon early so the user would be happy. It won't be functional\n  // though until the program inits fully.\n  // Do not create dummy tray icon in X. Cause QT5 failed to upgrade systemtray context menu.\n  // And as result menu for some DEs apppear to be empty, for example in MATE DE.\n\n  if ( cfg.preferences.enableTrayIcon )\n  {\n    trayIcon = new QSystemTrayIcon( QIcon::fromTheme(\"goldendict-tray\", QIcon( \":/icons/programicon_old.png\" )), this );\n    trayIcon->setToolTip( tr( \"Loading...\" ) );\n    trayIcon->show();\n  }\n#endif\n\n  connect( navBack, SIGNAL( triggered() ),\n           this, SLOT( backClicked() ) );\n  connect( navForward, SIGNAL( triggered() ),\n           this, SLOT( forwardClicked() ) );\n\n  addTab.setAutoRaise( true );\n  addTab.setToolTip( tr( \"New Tab\"  ) );\n  addTab.setFocusPolicy( Qt::NoFocus );\n  addTab.setIcon( QIcon( \":/icons/addtab.png\" ) );\n\n  ui.tabWidget->setHideSingleTab(cfg.preferences.hideSingleTab);\n  ui.tabWidget->clear();\n\n  ui.tabWidget->setCornerWidget( &addTab, Qt::TopLeftCorner );\n  //ui.tabWidget->setCornerWidget( &closeTab, Qt::TopRightCorner );\n\n#if QT_VERSION >= 0x040500\n  ui.tabWidget->setMovable( true );\n#endif\n\n#ifndef Q_OS_WIN32\n  ui.tabWidget->setDocumentMode( true );\n#endif\n\n  ui.tabWidget->setContextMenuPolicy( Qt::CustomContextMenu );\n\n  connect( &addTab, SIGNAL( clicked() ),\n           this, SLOT( addNewTab() ) );\n\n  connect( ui.tabWidget, SIGNAL( doubleClicked() ),\n           this, SLOT( addNewTab() ) );\n\n  connect( ui.tabWidget, SIGNAL( tabCloseRequested( int ) ),\n           this, SLOT( tabCloseRequested( int ) ) );\n\n  connect( ui.tabWidget, SIGNAL( currentChanged( int ) ),\n           this, SLOT( tabSwitched( int ) ) );\n\n  connect( ui.tabWidget, SIGNAL( customContextMenuRequested(QPoint)) ,\n           this, SLOT( tabMenuRequested(QPoint)) );\n\n#if QT_VERSION >= 0x040500\n  ui.tabWidget->setTabsClosable( true );\n#endif\n\n  connect( ui.quit, SIGNAL( triggered() ),\n           this, SLOT( quitApp() ) );\n\n  connect( ui.dictionaries, SIGNAL( triggered() ),\n           this, SLOT( editDictionaries() ) );\n\n  connect( ui.preferences, SIGNAL( triggered() ),\n           this, SLOT( editPreferences() ) );\n\n  connect( ui.visitHomepage, SIGNAL( triggered() ),\n           this, SLOT( visitHomepage() ) );\n  connect( ui.visitForum, SIGNAL( triggered() ),\n           this, SLOT( visitForum() ) );\n  connect( ui.openConfigFolder, SIGNAL( triggered() ),\n           this, SLOT( openConfigFolder() ) );\n  connect( ui.about, SIGNAL( triggered() ),\n           this, SLOT( showAbout() ) );\n  connect( ui.showReference, SIGNAL( triggered() ),\n           this, SLOT( showGDHelp() ) );\n\n  connect( groupListInDock, SIGNAL( currentIndexChanged( QString const & ) ),\n           this, SLOT( currentGroupChanged( QString const & ) ) );\n\n  connect( groupListInToolbar, SIGNAL( currentIndexChanged( QString const & ) ),\n           this, SLOT( currentGroupChanged( QString const & ) ) );\n\n  connect( ui.translateLine, SIGNAL( textChanged( QString const & ) ),\n           this, SLOT( translateInputChanged( QString const & ) ) );\n\n  connect( translateBox->translateLine(), SIGNAL( textChanged( QString const & ) ),\n           this, SLOT( translateInputChanged( QString const & ) ) );\n\n  connect( ui.translateLine, SIGNAL( returnPressed() ),\n           this, SLOT( translateInputFinished() ) );\n\n  connect( translateBox->translateLine(), SIGNAL( returnPressed() ),\n           this, SLOT( translateInputFinished() ) );\n\n  connect( ui.wordList, SIGNAL( itemSelectionChanged() ),\n           this, SLOT( wordListSelectionChanged() ) );\n\n  connect( translateBox->wordList(), SIGNAL( itemDoubleClicked ( QListWidgetItem * ) ),\n           this, SLOT( wordListItemActivated( QListWidgetItem * ) ) );\n\n  connect( ui.wordList, SIGNAL( itemClicked( QListWidgetItem * ) ),\n           this, SLOT( wordListItemActivated( QListWidgetItem * ) ) );\n\n  connect( ui.wordList, SIGNAL( statusBarMessage( QString const &, int, QPixmap const & ) ),\n           this, SLOT( showStatusBarMessage( QString const &, int, QPixmap const & ) ) );\n\n  connect( translateBox->wordList(), SIGNAL( statusBarMessage( QString const &, int, QPixmap const & ) ),\n           this, SLOT( showStatusBarMessage( QString const &, int, QPixmap const & ) ) );\n\n  connect( ui.dictsList, SIGNAL( itemSelectionChanged() ),\n           this, SLOT( dictsListSelectionChanged() ) );\n\n  connect( ui.dictsList, SIGNAL( itemDoubleClicked( QListWidgetItem * ) ),\n           this, SLOT( dictsListItemActivated( QListWidgetItem * ) ) );\n\n  connect( &configEvents, SIGNAL( mutedDictionariesChanged() ),\n           this, SLOT( mutedDictionariesChanged() ) );\n\n  this->installEventFilter( this );\n\n  ui.translateLine->installEventFilter( this );\n  translateBox->translateLine()->installEventFilter( this );\n\n  ui.wordList->installEventFilter( this );\n  translateBox->wordList()->installEventFilter( this );\n\n  ui.wordList->viewport()->installEventFilter( this );\n  translateBox->wordList()->viewport()->installEventFilter( this );\n\n  ui.dictsList->installEventFilter( this );\n  ui.dictsList->viewport()->installEventFilter( this );\n  //tabWidget doesn't propagate Ctrl+Tab to the parent widget unless event filter is installed\n  ui.tabWidget->installEventFilter( this );\n\n  ui.historyList->installEventFilter( this );\n\n  ui.favoritesTree->installEventFilter( this );\n\n  groupListInDock->installEventFilter( this );\n  groupListInToolbar->installEventFilter( this );\n\n  connect( &ftsIndexing, SIGNAL( newIndexingName( QString ) ), this, SLOT( showFTSIndexingName( QString ) ) );\n\n#ifdef Q_OS_WIN\n  if( cfg.normalMainWindowGeometry.width() <= 0 )\n  {\n    QRect r = QApplication::desktop()->availableGeometry();\n    cfg.normalMainWindowGeometry.setRect( r.width() / 4, r.height() / 4, r.width() / 2, r.height() / 2 );\n  }\n  if( cfg.maximizedMainWindowGeometry.width() > 0 )\n  {\n    setGeometry( cfg.maximizedMainWindowGeometry );\n    if ( cfg.mainWindowGeometry.size() )\n      restoreGeometry( cfg.mainWindowGeometry );\n    if ( cfg.mainWindowState.size() )\n      restoreState( cfg.mainWindowState, 1 );\n    setWindowState( windowState() | Qt::WindowMaximized );\n  }\n  else\n#endif\n#ifndef Q_OS_MAC\n  {\n    if ( cfg.mainWindowGeometry.size() )\n      restoreGeometry( cfg.mainWindowGeometry );\n    if ( cfg.mainWindowState.size() )\n      restoreState( cfg.mainWindowState, 1 );\n  }\n#endif\n  updateSearchPaneAndBar( cfg.preferences.searchInDock );\n  ui.searchPane->setVisible( cfg.preferences.searchInDock );\n\n  applyProxySettings();\n  applyWebSettings();\n\n  connect( &dictNetMgr, SIGNAL( proxyAuthenticationRequired( QNetworkProxy, QAuthenticator * ) ),\n           this, SLOT( proxyAuthentication( QNetworkProxy, QAuthenticator * ) ) );\n\n  connect( &articleNetMgr, SIGNAL( proxyAuthenticationRequired( QNetworkProxy, QAuthenticator * ) ),\n           this, SLOT( proxyAuthentication( QNetworkProxy, QAuthenticator * ) ) );\n\n  setupNetworkCache( cfg.preferences.maxNetworkCacheSize );\n\n  makeDictionaries();\n\n  // After we have dictionaries and groups, we can populate history\n//  historyChanged();\n\n  setWindowTitle( \"GoldenDict\" );\n\n#ifdef Q_OS_MAC\n  {\n    if ( cfg.mainWindowGeometry.size() )\n      restoreGeometry( cfg.mainWindowGeometry );\n    if ( cfg.mainWindowState.size() )\n      restoreState( cfg.mainWindowState, 1 );\n  }\n#endif\n\n  blockUpdateWindowTitle = true;\n  addNewTab();\n\n  // Create tab list menu\n  createTabList();\n\n  // Show the initial welcome text\n\n  {\n    ArticleView *view = getCurrentArticleView();\n\n    history.enableAdd( false );\n\n    blockUpdateWindowTitle = true;\n\n    view->showDefinition( tr( \"Welcome!\" ), Instances::Group::HelpGroupId );\n\n    history.enableAdd( cfg.preferences.storeHistory );\n  }\n\n  translateLine->setFocus();\n\n  applyQtStyleSheet( cfg.preferences.displayStyle, cfg.preferences.addonStyle );\n\n  makeScanPopup();\n\n  if ( trayIcon )\n  {\n    // Upgrade existing dummy tray icon into a full-functional one\n\n    trayIcon->setContextMenu( &trayIconMenu );\n    trayIcon->show();\n\n    connect( trayIcon, SIGNAL( activated( QSystemTrayIcon::ActivationReason ) ),\n             this, SLOT( trayIconActivated( QSystemTrayIcon::ActivationReason ) ) );\n  }\n\n  updateTrayIcon();\n\n  // Update zoomers\n  adjustCurrentZoomFactor();\n  scaleArticlesByCurrentZoomFactor();\n  applyWordsZoomLevel();\n\n  // Update autostart info\n  setAutostart(cfg.preferences.autoStart);\n\n  // Initialize global hotkeys\n  installHotKeys();\n\n  if ( cfg.preferences.alwaysOnTop )\n  {\n    on_alwaysOnTop_triggered( true );\n  }\n\n  // Only show window initially if it wasn't configured differently\n  if ( !cfg.preferences.enableTrayIcon || !cfg.preferences.startToTray )\n  {\n    show();\n    focusTranslateLine();\n  }\n\n  connect( &newReleaseCheckTimer, SIGNAL( timeout() ),\n           this, SLOT( checkForNewRelease() ) );\n\n#ifdef X11_MAIN_WINDOW_FOCUS_WORKAROUNDS\n  // The X11 focus workaround in toggleMainWindow() emulates a left mouse button\n  // click on the top-left pixel of the main GoldenDict window. This hack steals\n  // focus from other applications reliably, but it also performs this click at\n  // the position that belongs to the File menu in the default KDE Plasma style,\n  // because the menu bar has no left margin there.\n  // Insert a minimum-size widget, which ignores mouse clicks, to the left of the\n  // menu bar to work around opening of the File menu each time the main window\n  // is shown (e.g. via a hotkey or when another GoldenDict instance is launched).\n  menuBar()->setCornerWidget( new MinimumSizeWidget( this ), Qt::TopLeftCorner );\n#endif\n\n  if ( cfg.preferences.hideMenubar )\n  {\n    toggleMenuBarTriggered( false );\n  }\n\n  prepareNewReleaseChecks();\n\n  // makeDictionaries() didn't do deferred init - we do it here, at the end.\n  doDeferredInit( dictionaries );\n\n  updateStatusLine();\n\n#ifdef Q_OS_MAC\n  if( cfg.preferences.startWithScanPopupOn && !MacMouseOver::isAXAPIEnabled() )\n      mainStatusBar->showMessage( tr( \"Accessibility API is not enabled\" ), 10000,\n                                      QPixmap( \":/icons/error.png\" ) );\n#endif\n\n  wasMaximized = isMaximized();\n\n  history.setSaveInterval( cfg.preferences.historyStoreInterval );\n\n  #ifdef Q_OS_MAC\n    LionSupport::addFullscreen(this);\n  #endif\n#ifdef Q_OS_WIN32\n  gdAskMessage = RegisterWindowMessage( GD_MESSAGE_NAME );\n  ( static_cast< QHotkeyApplication * >( qApp ) )->setMainWindow( this );\n#endif\n\n#if QT_VERSION >= QT_VERSION_CHECK(4, 6, 0)\n  ui.centralWidget->grabGesture( Gestures::GDPinchGestureType );\n  ui.centralWidget->grabGesture( Gestures::GDSwipeGestureType );\n#endif\n\n  if( layoutDirection() == Qt::RightToLeft )\n  {\n    // Adjust button icons for Right-To-Left layout\n    navBack->setIcon( QIcon( \":/icons/next.png\" ) );\n    navForward->setIcon( QIcon( \":/icons/previous.png\" ) );\n  }\n}\n\nvoid MainWindow::ctrlTabPressed()\n{\n    emit fillWindowsMenu();\n    tabListButton->click();\n}\n\nvoid MainWindow::updateSearchPaneAndBar( bool searchInDock )\n{\n  QString text = translateLine->text();\n\n  if( ftsDlg )\n    removeGroupComboBoxActionsFromDialog( ftsDlg, groupList );\n  if( headwordsDlg )\n    removeGroupComboBoxActionsFromDialog( headwordsDlg, groupList );\n\n  if ( searchInDock )\n  {\n    cfg.preferences.searchInDock = true;\n\n    navToolbar->setAllowedAreas( Qt::AllToolBarAreas );\n\n    groupList = groupListInDock;\n    translateLine = ui.translateLine;\n    wordList = ui.wordList;\n\n    translateBoxToolBarAction->setVisible( false );\n  }\n  else\n  {\n    cfg.preferences.searchInDock = false;\n\n    // handle the main toolbar, it must not be on the side, since it should\n    // contain the group widget and the translate line. Valid locations: Top and Bottom.\n    navToolbar->setAllowedAreas( Qt::BottomToolBarArea | Qt::TopToolBarArea );\n    if ( toolBarArea( navToolbar ) & ( Qt::LeftToolBarArea | Qt::RightToolBarArea ) )\n    {\n      if ( toolBarArea( &dictionaryBar ) == Qt::TopToolBarArea )\n      {\n        insertToolBar( &dictionaryBar, navToolbar );\n      }\n      else\n      {\n        addToolBar( Qt::TopToolBarArea, navToolbar );\n      }\n    }\n\n    groupList = groupListInToolbar;\n    translateLine = translateBox->translateLine();\n    wordList = translateBox->wordList();\n\n    translateBoxToolBarAction->setVisible( true );\n  }\n\n  if( ftsDlg )\n    addGroupComboBoxActionsToDialog( ftsDlg, groupList );\n  if( headwordsDlg )\n    addGroupComboBoxActionsToDialog( headwordsDlg, groupList );\n\n  translateLine->setToolTip( tr( \"String to search in dictionaries. The wildcards '*', '?' and sets of symbols '[...]' are allowed.\\nTo find '*', '?', '[', ']' symbols use '\\\\*', '\\\\?', '\\\\[', '\\\\]' respectively\" ) );\n\n  // reset the flag when switching UI modes\n  wordListSelChanged = false;\n\n  wordList->attachFinder( &wordFinder );\n\n  updateGroupList();\n  applyWordsZoomLevel();\n\n  setTranslateBoxTextAndKeepSuffix( text, WildcardsAreAlreadyEscaped, DisablePopup );\n  focusTranslateLine();\n}\n\nvoid MainWindow::mousePressEvent( QMouseEvent *event)\n{\n\n  if (handleBackForwardMouseButtons( event ) )\n  {\n    return;\n  }\n\n  if( event->button() != Qt4x5::middleButton() )\n    return QMainWindow::mousePressEvent(event);\n\n  // middle clicked\n  QString subtype = \"plain\";\n\n    QString str = QApplication::clipboard()->text(subtype,\n      QClipboard::Selection);\n  setTranslateBoxTextAndClearSuffix( str, EscapeWildcards, NoPopupChange );\n\n        QKeyEvent ev(QEvent::KeyPress, Qt::Key_Enter,\n           Qt::NoModifier);\n        QApplication::sendEvent(translateLine, &ev);\n}\n\nMainWindow::~MainWindow()\n{\n#ifdef Q_OS_WIN\n  if( isMaximized() )\n  {\n    cfg.maximizedMainWindowGeometry = geometry();\n  }\n  else\n  {\n    cfg.maximizedMainWindowGeometry = QRect();\n    if( !isMinimized() )\n      cfg.normalMainWindowGeometry = geometry();\n  }\n#endif\n\n  closeHeadwordsDialog();\n\n  ftsIndexing.stopIndexing();\n\n#if QT_VERSION >= QT_VERSION_CHECK(4, 6, 0)\n  ui.centralWidget->ungrabGesture( Gestures::GDPinchGestureType );\n  ui.centralWidget->ungrabGesture( Gestures::GDSwipeGestureType );\n//  Gestures::unregisterRecognizers();\n#endif\n\n  // Close all tabs -- they should be destroyed before network managers\n  // do.\n  while( ui.tabWidget->count() )\n  {\n    QWidget * w = ui.tabWidget->widget( 0 );\n\n    ui.tabWidget->removeTab( 0 );\n\n    delete w;\n  }\n\n#ifndef NO_EPWING_SUPPORT\n  Epwing::finalize();\n#endif\n}\n\nvoid MainWindow::addGlobalAction( QAction * action, const char * slot )\n{\n  action->setShortcutContext( Qt::WidgetWithChildrenShortcut );\n  connect( action, SIGNAL( triggered() ), this, slot );\n\n  ui.centralWidget->addAction( action );\n  ui.dictsPane->addAction( action );\n  ui.searchPaneWidget->addAction( action );\n  ui.favoritesPane->addAction( action );\n  ui.historyPane->addAction( action );\n  groupList->addAction( action );\n  translateBox->addAction( action );\n}\n\nvoid MainWindow::addGlobalActionsToDialog( QDialog * dialog )\n{\n  dialog->addAction( &focusTranslateLineAction );\n  dialog->addAction( &focusHeadwordsDlgAction );\n  dialog->addAction( &focusArticleViewAction );\n  dialog->addAction( ui.fullTextSearchAction );\n}\n\nvoid MainWindow::addGroupComboBoxActionsToDialog( QDialog * dialog, GroupComboBox * pGroupComboBox )\n{\n  dialog->addActions( pGroupComboBox->getExternActions() );\n}\n\nvoid MainWindow::removeGroupComboBoxActionsFromDialog( QDialog * dialog, GroupComboBox * pGroupComboBox )\n{\n  QList< QAction * > actions = pGroupComboBox->getExternActions();\n  for( QList< QAction * >::iterator it = actions.begin(); it != actions.end(); ++it )\n    dialog->removeAction( *it );\n}\n\nvoid MainWindow::commitData( QSessionManager & )\n{\n  commitData();\n}\n\nvoid MainWindow::commitData()\n{\n  if( cfg.preferences.clearNetworkCacheOnExit )\n    if( QAbstractNetworkCache * cache = articleNetMgr.cache() )\n      cache->clear();\n\n  try\n  {\n    // Save MainWindow state and geometry\n    cfg.mainWindowState = saveState( 1 );\n    cfg.mainWindowGeometry = saveGeometry();\n\n    // Save popup window state and geometry\n\n    if( scanPopup.get() )\n      scanPopup->saveConfigData();\n\n    // Save any changes in last chosen groups etc\n    try\n    {\n      Config::save( cfg );\n    }\n    catch( std::exception & e )\n    {\n      gdWarning( \"Configuration saving failed, error: %s\\n\", e.what() );\n    }\n\n    // Save history\n    history.save();\n\n    // Save favorites\n    ui.favoritesPaneWidget->saveData();\n  }\n  catch( std::exception & e )\n  {\n    gdWarning( \"Commit data failed, error: %s\\n\", e.what() );\n  }\n}\n\nQPrinter & MainWindow::getPrinter()\n{\n  if ( printer.get() )\n    return *printer;\n\n  printer = new QPrinter( QPrinter::HighResolution );\n\n  return *printer;\n}\n\nvoid MainWindow::applyQtStyleSheet( QString const & displayStyle, QString const & addonStyle )\n{\n  QFile builtInCssFile( \":/qt-style.css\" );\n  builtInCssFile.open( QFile::ReadOnly );\n  QByteArray css = builtInCssFile.readAll();\n\n#if defined(Q_OS_MAC)\n  QFile macCssFile( \":/qt-style-macos.css\" );\n  macCssFile.open( QFile::ReadOnly );\n  css += macCssFile.readAll();\n#endif\n\n  if ( displayStyle.size() )\n  {\n    // Load an additional stylesheet\n    QFile builtInCssFile( QString( \":/qt-style-st-%1.css\" ).arg( displayStyle ) );\n    if ( builtInCssFile.open( QFile::ReadOnly ) )\n      css += builtInCssFile.readAll();\n  }\n\n  // Try loading a style sheet if there's one\n  QFile cssFile( Config::getUserQtCssFileName() );\n\n  if ( cssFile.open( QFile::ReadOnly ) )\n    css += cssFile.readAll();\n\n  if( !addonStyle.isEmpty() )\n  {\n    QString name = Config::getStylesDir() + addonStyle\n                   + QDir::separator() + \"qt-style.css\";\n    QFile addonCss( name );\n    if( addonCss.open( QFile::ReadOnly ) )\n      css += addonCss.readAll();\n  }\n\n  setStyleSheet( css );\n}\n\nvoid MainWindow::updateTrayIcon()\n{\n  if ( !trayIcon && cfg.preferences.enableTrayIcon )\n  {\n    // Need to show it\n    trayIcon = new QSystemTrayIcon( QIcon::fromTheme(\"goldendict-tray\", QIcon( \":/icons/programicon_old.png\" )), this );\n    trayIcon->setContextMenu( &trayIconMenu );\n    trayIcon->show();\n\n    connect( trayIcon, SIGNAL( activated( QSystemTrayIcon::ActivationReason ) ),\n             this, SLOT( trayIconActivated( QSystemTrayIcon::ActivationReason ) ) );\n  }\n  else\n  if ( trayIcon && !cfg.preferences.enableTrayIcon )\n  {\n    // Need to hide it\n    delete trayIcon;\n\n    trayIcon = 0;\n  }\n  if ( trayIcon )\n  {\n    // Update the icon to reflect the scanning mode\n    trayIcon->setIcon( enableScanPopup->isChecked() ?\n        QIcon::fromTheme(\"goldendict-scan-tray\", QIcon( \":/icons/programicon_scan.png\" )) :\n        QIcon::fromTheme(\"goldendict-tray\", QIcon( \":/icons/programicon_old.png\" )) );\n\n    trayIcon->setToolTip( \"GoldenDict\" );\n  }\n\n  // The 'Close to tray' action is associated with the tray icon, so we hide\n  // or show it here.\n  ui.actionCloseToTray->setVisible( cfg.preferences.enableTrayIcon );\n}\n\nvoid MainWindow::wheelEvent( QWheelEvent *ev )\n{\n  if ( ev->modifiers().testFlag( Qt::ControlModifier ) )\n  {\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n    int const delta = ev->angleDelta().y();\n#else\n    int const delta = ev->delta();\n#endif\n    if ( delta > 0 )\n    {\n        zoomin();\n    }\n    else if ( delta < 0 )\n    {\n        zoomout();\n    }\n    ev->accept();\n  }\n  else\n  {\n    ev->ignore();\n  }\n}\n\nvoid MainWindow::closeEvent( QCloseEvent * ev )\n{\n  if ( cfg.preferences.enableTrayIcon && cfg.preferences.closeToTray )\n  {\n    if( !cfg.preferences.searchInDock )\n      translateBox->setPopupEnabled( false );\n\n#ifdef HAVE_X11\n    // Don't ignore the close event, because doing so cancels session logout if\n    // the main window is visible when the user attempts to log out.\n    // The main window will be only hidden, because QApplication::quitOnLastWindowClosed\n    // property is false and Qt::WA_DeleteOnClose widget attribute is not set.\n    Q_ASSERT(!QApplication::quitOnLastWindowClosed());\n    Q_ASSERT(!testAttribute(Qt::WA_DeleteOnClose));\n#else\n    // Ignore the close event because closing the main window breaks global hotkeys on Windows.\n    ev->ignore();\n    hide();\n#endif\n  }\n  else\n  {\n    ev->accept();\n    quitApp();\n  }\n}\n\nvoid MainWindow::quitApp()\n{\n  commitData();\n  qApp->quit();\n}\n\nvoid MainWindow::applyProxySettings()\n{\n  if( cfg.preferences.proxyServer.enabled && cfg.preferences.proxyServer.useSystemProxy )\n  {\n    QList<QNetworkProxy> proxies = QNetworkProxyFactory::systemProxyForQuery();\n    if( !cfg.preferences.proxyServer.systemProxyUser.isEmpty() )\n    {\n      proxies.first().setUser( cfg.preferences.proxyServer.systemProxyUser );\n      proxies.first().setPassword( cfg.preferences.proxyServer.systemProxyPassword );\n    }\n    QNetworkProxy::setApplicationProxy( proxies.first() );\n    return;\n  }\n\n  QNetworkProxy::ProxyType type = QNetworkProxy::NoProxy;\n\n  if ( cfg.preferences.proxyServer.enabled )\n  {\n    switch( cfg.preferences.proxyServer.type )\n    {\n      case Config::ProxyServer::Socks5:\n        type = QNetworkProxy::Socks5Proxy;\n      break;\n      case Config::ProxyServer::HttpConnect:\n        type = QNetworkProxy::HttpProxy;\n      break;\n      case Config::ProxyServer::HttpGet:\n        type = QNetworkProxy::HttpCachingProxy;\n      break;\n\n      default:\n      break;\n    }\n  }\n\n  QNetworkProxy proxy( type );\n\n  if ( cfg.preferences.proxyServer.enabled )\n  {\n   proxy.setHostName( cfg.preferences.proxyServer.host );\n   proxy.setPort( cfg.preferences.proxyServer.port );\n\n   if ( cfg.preferences.proxyServer.user.size() )\n     proxy.setUser( cfg.preferences.proxyServer.user );\n\n   if ( cfg.preferences.proxyServer.password.size() )\n     proxy.setPassword( cfg.preferences.proxyServer.password );\n  }\n\n  QNetworkProxy::setApplicationProxy( proxy );\n}\n\nvoid MainWindow::applyWebSettings()\n{\n  QWebSettings *defaultSettings = QWebSettings::globalSettings();\n  defaultSettings->setAttribute(QWebSettings::PluginsEnabled, cfg.preferences.enableWebPlugins);\n  defaultSettings->setAttribute( QWebSettings::DeveloperExtrasEnabled, true );\n}\n\nvoid MainWindow::setupNetworkCache( int maxSize )\n{\n  // x << 20 == x * 2^20 converts mebibytes to bytes.\n  qint64 const maxCacheSizeInBytes = maxSize <= 0 ? qint64( 0 ) : static_cast< qint64 >( maxSize ) << 20;\n\n  if( QAbstractNetworkCache * abstractCache = articleNetMgr.cache() )\n  {\n    QNetworkDiskCache * const diskCache = qobject_cast< QNetworkDiskCache * >( abstractCache );\n    Q_ASSERT_X( diskCache, Q_FUNC_INFO, \"Unexpected network cache type.\" );\n    diskCache->setMaximumCacheSize( maxCacheSizeInBytes );\n    return;\n  }\n  if( maxCacheSizeInBytes == 0 )\n    return; // There is currently no cache and it is not needed.\n\n  QString const cacheDirectory = Config::getNetworkCacheDir();\n  if( !QDir().mkpath( cacheDirectory ) )\n  {\n    gdWarning( \"Cannot create a cache directory %s. Disabling network cache.\", cacheDirectory.toUtf8().constData() );\n    return;\n  }\n  QNetworkDiskCache * const diskCache = new QNetworkDiskCache( this );\n  diskCache->setMaximumCacheSize( maxCacheSizeInBytes );\n  diskCache->setCacheDirectory( cacheDirectory );\n  articleNetMgr.setCache( diskCache );\n}\n\nvoid MainWindow::makeDictionaries()\n{\n  Q_ASSERT( !scanPopup && \"Scan popup must not exist while dictionaries are initialized. \"\n                          \"It does not support dictionaries changes and must be constructed anew.\" );\n\n  wordFinder.clear();\n\n  dictionariesUnmuted.clear();\n\n  ftsIndexing.stopIndexing();\n  ftsIndexing.clearDictionaries();\n\n  loadDictionaries( this, isVisible(), cfg, dictionaries, dictNetMgr, false );\n\n  for( unsigned x = 0; x < dictionaries.size(); x++ )\n  {\n    dictionaries[ x ]->setFTSParameters( cfg.preferences.fts );\n    dictionaries[ x ]->setSynonymSearchEnabled( cfg.preferences.synonymSearchEnabled );\n  }\n\n  ftsIndexing.setDictionaries( dictionaries );\n  ftsIndexing.doIndexing();\n\n  updateStatusLine();\n  updateGroupList();\n}\n\nvoid MainWindow::updateStatusLine()\n{\n  unsigned articleCount = 0, wordCount = 0;\n\n  for( unsigned x = dictionaries.size(); x--; )\n  {\n    articleCount += dictionaries[ x ]->getArticleCount();\n    wordCount += dictionaries[ x ]->getWordCount();\n  }\n\n  mainStatusBar->showMessage( tr( \"%1 dictionaries, %2 articles, %3 words\" ).\n                              arg( dictionaries.size() ).arg( articleCount ).\n                              arg( wordCount ), 10000 );\n}\n\nvoid MainWindow::updateGroupList()\n{\n  bool haveGroups = cfg.groups.size();\n\n  groupList->setVisible( haveGroups );\n\n  groupLabel.setText( haveGroups ? tr( \"Look up in:\" ) : tr( \"Look up:\" ) );\n\n  // currentIndexChanged() signal is very trigger-happy. To avoid triggering\n  // it, we disconnect it while we're clearing and filling back groups.\n  disconnect( groupList, SIGNAL( currentIndexChanged( QString const & ) ),\n              this, SLOT( currentGroupChanged( QString const & ) ) );\n\n  groupInstances.clear();\n\n  // Add dictionaryOrder first, as the 'All' group.\n  {\n    Instances::Group g( cfg.dictionaryOrder, dictionaries, Config::Group() );\n\n    // Add any missing entries to dictionary order\n    Instances::complementDictionaryOrder( g,\n                                          Instances::Group( cfg.inactiveDictionaries, dictionaries, Config::Group() ),\n                                          dictionaries );\n\n    g.name = tr( \"All\" );\n    g.id = Instances::Group::AllGroupId;\n    g.icon = \"folder.png\";\n\n    groupInstances.push_back( g );\n  }\n\n  for( int x  = 0; x < cfg.groups.size(); ++x )\n    groupInstances.push_back( Instances::Group( cfg.groups[ x ], dictionaries, cfg.inactiveDictionaries ) );\n\n  // Update names for dictionaries that are present, so that they could be\n  // found in case they got moved.\n  Instances::updateNames( cfg, dictionaries );\n\n  groupList->fill( groupInstances );\n  groupList->setCurrentGroup( cfg.lastMainGroupId );\n  updateCurrentGroupProperty();\n\n  updateDictionaryBar();\n\n#ifdef QT_DEBUG\n  qDebug() << \"Reloading all the tabs...\";\n#endif\n\n  for( int i = 0; i < ui.tabWidget->count(); ++i )\n  {\n    ArticleView & view =\n      dynamic_cast< ArticleView & >( *( ui.tabWidget->widget( i ) ) );\n\n    view.reload();\n  }\n\n  connect( groupList, SIGNAL( currentIndexChanged( QString const & ) ),\n           this, SLOT( currentGroupChanged( QString const & ) ) );\n}\n\nvoid MainWindow::updateDictionaryBar()\n{\n  if ( !dictionaryBar.toggleViewAction()->isChecked() )\n    return; // It's not enabled, therefore hidden -- don't waste time\n\n  unsigned currentId = groupList -> getCurrentGroup();\n  Instances::Group * grp = groupInstances.findGroup( currentId );\n\n  dictionaryBar.setMutedDictionaries( 0 );\n  if ( grp ) { // Should always be !0, but check as a safeguard\n    if( currentId == Instances::Group::AllGroupId )\n      dictionaryBar.setMutedDictionaries( &cfg.mutedDictionaries );\n    else\n    {\n      Config::Group * grp = cfg.getGroup( currentId );\n      dictionaryBar.setMutedDictionaries( grp ? &grp->mutedDictionaries : 0 );\n    }\n\n    dictionaryBar.setDictionaries( grp->dictionaries );\n\n    if ( useSmallIconsInToolbarsAction.isChecked() ) {\n      int extent = QApplication::style()->pixelMetric(QStyle::PM_SmallIconSize);\n      dictionaryBar.setDictionaryIconSize( extent );\n    }\n  }\n}\n\nvoid MainWindow::makeScanPopup()\n{\n  scanPopup.reset();\n\n  if ( !cfg.preferences.enableScanPopup &&\n       !cfg.preferences.enableClipboardHotkey )\n    return;\n\n  scanPopup = new ScanPopup( 0, cfg, articleNetMgr, audioPlayerFactory.player(),\n                             dictionaries, groupInstances, history );\n\n  scanPopup->setStyleSheet( styleSheet() );\n\n  if ( cfg.preferences.enableScanPopup && enableScanPopup->isChecked() )\n    scanPopup->enableScanning();\n\n  connect( scanPopup.get(), SIGNAL(editGroupRequested( unsigned ) ),\n           this, SLOT(editDictionaries( unsigned )), Qt::QueuedConnection );\n\n  connect( scanPopup.get(), SIGNAL(sendPhraseToMainWindow( Config::InputPhrase const & ) ),\n           this, SLOT(phraseReceived( Config::InputPhrase const & )), Qt::QueuedConnection );\n\n  connect( this, SIGNAL( setExpandOptionalParts( bool ) ),\n           scanPopup.get(), SIGNAL( setViewExpandMode( bool ) ) );\n\n  connect( scanPopup.get(), SIGNAL( setExpandMode( bool ) ),\n           this, SLOT( setExpandMode( bool ) ) );\n\n  connect( scanPopup.get(), SIGNAL( forceAddWordToHistory( const QString & ) ),\n           this, SLOT( forceAddWordToHistory( const QString & ) ) );\n\n  connect( scanPopup.get(), SIGNAL( showDictionaryInfo( const QString & ) ),\n           this, SLOT( showDictionaryInfo( const QString & ) ) );\n\n  connect( scanPopup.get(), SIGNAL( openDictionaryFolder( const QString & ) ),\n           this, SLOT( openDictionaryFolder( const QString & ) ) );\n\n  connect( scanPopup.get(), SIGNAL( sendWordToHistory( QString ) ),\n           this, SLOT( addWordToHistory( QString ) ) );\n\n  connect( this, SIGNAL( setPopupGroupByName( QString ) ),\n           scanPopup.get(), SLOT( setGroupByName( QString ) ) );\n\n  connect( scanPopup.get(), SIGNAL( sendWordToFavorites( QString, uint ) ),\n           this, SLOT( addWordToFavorites( QString, uint ) ) );\n\n  connect( scanPopup.get(), SIGNAL( isWordPresentedInFavorites( QString, uint ) ),\n           this, SLOT( isWordPresentedInFavorites( QString, uint ) ) );\n\n#ifdef Q_OS_WIN32\n  connect( scanPopup.get(), SIGNAL( isGoldenDictWindow( HWND ) ),\n           this, SLOT( isGoldenDictWindow( HWND ) ) );\n#endif\n}\n\nvector< sptr< Dictionary::Class > > const & MainWindow::getActiveDicts()\n{\n  if ( groupInstances.empty() )\n    return dictionaries;\n\n  int current = groupList->currentIndex();\n\n  if ( current < 0 || current >= (int) groupInstances.size() )\n  {\n    // This shouldn't ever happen\n    return dictionaries;\n  }\n\n  Config::MutedDictionaries const * mutedDictionaries = dictionaryBar.getMutedDictionaries();\n  if ( !dictionaryBar.toggleViewAction()->isChecked() || mutedDictionaries == 0 )\n    return groupInstances[ current ].dictionaries;\n  else\n  {\n    vector< sptr< Dictionary::Class > > const & activeDicts =\n      groupInstances[ current ].dictionaries;\n\n    // Populate the special dictionariesUnmuted array with only unmuted\n    // dictionaries\n\n    dictionariesUnmuted.clear();\n    dictionariesUnmuted.reserve( activeDicts.size() );\n\n    for( unsigned x = 0; x < activeDicts.size(); ++x )\n      if ( !mutedDictionaries->contains(\n              QString::fromStdString( activeDicts[ x ]->getId() ) ) )\n        dictionariesUnmuted.push_back( activeDicts[ x ] );\n\n    return dictionariesUnmuted;\n  }\n}\n\nvoid MainWindow::createTabList()\n{\n  tabListMenu->setIcon(QIcon(\":/icons/windows-list.png\"));\n  connect(tabListMenu, SIGNAL(aboutToShow()), this, SLOT(fillWindowsMenu()));\n  connect(tabListMenu, SIGNAL(triggered(QAction*)), this, SLOT(switchToWindow(QAction*)));\n\n  tabListButton = new QToolButton(ui.tabWidget);\n  tabListButton->setAutoRaise(true);\n  tabListButton->setIcon(tabListMenu->icon());\n  tabListButton->setMenu(tabListMenu);\n  tabListButton->setToolTip( tr( \"Open Tabs List\" ) );\n  tabListButton->setPopupMode(QToolButton::InstantPopup);\n  ui.tabWidget->setCornerWidget(tabListButton);\n  tabListButton->setFocusPolicy(Qt::NoFocus);\n}\n\nvoid MainWindow::fillWindowsMenu()\n{\n  tabListMenu->clear();\n\n  if(cfg.preferences.mruTabOrder)\n  {\n    for (int i = 0; i < mruList.count(); i++)\n    {\n      QAction *act = tabListMenu->addAction(ui.tabWidget->tabIcon(ui.tabWidget->indexOf(mruList.at(i))), ui.tabWidget->tabText(ui.tabWidget->indexOf(mruList.at(i))));\n\n      //remember the index of the Tab to be later used in ctrlReleased()\n      act->setData(ui.tabWidget->indexOf(mruList.at(i)));\n\n      if (ui.tabWidget->currentIndex() == ui.tabWidget->indexOf(mruList.at(i)))\n      {\n        QFont f( act->font() );\n        f.setBold( true );\n        act->setFont( f );\n      }\n    }\n    if (tabListMenu->actions().size() > 1)\n    {\n      tabListMenu->setActiveAction(tabListMenu->actions().at(1));\n    }\n  }\n  else\n  {\n    for (int i = 0; i < ui.tabWidget->count(); i++)\n    {\n      QAction *act = tabListMenu->addAction( ui.tabWidget->tabIcon( i ),\n      ui.tabWidget->tabText( i ) );\n      act->setData( i );\n      if (ui.tabWidget->currentIndex() == i)\n      {\n        QFont f( act->font() );\n        f.setBold( true );\n        act->setFont( f );\n      }\n    }\n  }\n  return;\n}\n\nvoid MainWindow::switchToWindow(QAction *act)\n{\n  int idx = act->data().toInt();\n  ui.tabWidget->setCurrentIndex(idx);\n}\n\n\nvoid MainWindow::addNewTab()\n{\n  createNewTab( true, tr( \"(untitled)\" ) );\n}\n\nArticleView * MainWindow::createNewTab( bool switchToIt,\n                                        QString const & name )\n{\n  ArticleView * view = new ArticleView( this, articleNetMgr, audioPlayerFactory.player(),\n                                        dictionaries, groupInstances, false, cfg,\n                                        *ui.searchInPageAction,\n                                        dictionaryBar.toggleViewAction(),\n                                        groupList );\n\n  connect( view, SIGNAL( titleChanged(  ArticleView *, QString const & ) ),\n           this, SLOT( titleChanged(  ArticleView *, QString const & ) ) );\n\n  connect( view, SIGNAL( iconChanged( ArticleView *, QIcon const & ) ),\n           this, SLOT( iconChanged( ArticleView *, QIcon const & ) ) );\n\n  connect( view, SIGNAL( pageLoaded( ArticleView * ) ),\n           this, SLOT( pageLoaded( ArticleView * ) ) );\n\n  connect( view, SIGNAL( openLinkInNewTab( QUrl const &, QUrl const &, QString const &, ArticleView::Contexts const & ) ),\n           this, SLOT( openLinkInNewTab( QUrl const &, QUrl const &, QString const &, ArticleView::Contexts const & ) ) );\n\n  connect( view, SIGNAL( showDefinitionInNewTab( QString const &, unsigned, QString const &, ArticleView::Contexts const & ) ),\n           this, SLOT( showDefinitionInNewTab( QString const &, unsigned, QString const &, ArticleView::Contexts const & ) ) );\n\n  connect( view, SIGNAL( typingEvent( QString const & ) ),\n           this, SLOT( typingEvent( QString const & ) ) );\n\n  connect( view, SIGNAL( activeArticleChanged( ArticleView const *, const QString & ) ),\n           this, SLOT( activeArticleChanged( ArticleView const *, const QString & ) ) );\n\n  connect( view, SIGNAL( statusBarMessage( QString const &, int, QPixmap const & ) ),\n           this, SLOT( showStatusBarMessage( QString const &, int, QPixmap const & ) ) );\n\n  connect( view, SIGNAL( showDictsPane( ) ), this, SLOT( showDictsPane( ) ) );\n\n  connect( view, SIGNAL( forceAddWordToHistory( const QString & ) ),\n           this, SLOT( forceAddWordToHistory( const QString & ) ) );\n\n  connect( this, SIGNAL( setExpandOptionalParts( bool ) ),\n           view, SLOT( receiveExpandOptionalParts( bool ) ) );\n\n  connect( view, SIGNAL( setExpandMode( bool ) ), this, SLOT( setExpandMode( bool ) ) );\n\n  connect( view, SIGNAL( sendWordToHistory( QString ) ),\n           this, SLOT( addWordToHistory( QString ) ) );\n\n  connect( view, SIGNAL( sendWordToInputLine( QString const & ) ),\n           this, SLOT( sendWordToInputLine( QString const & ) ) );\n\n  connect( view, SIGNAL( storeResourceSavePath( QString const & ) ),\n           this, SLOT( storeResourceSavePath( QString const & ) ) );\n\n  connect( view, SIGNAL( zoomIn()), this, SLOT( zoomin() ) );\n\n  connect( view, SIGNAL( zoomOut()), this, SLOT( zoomout() ) );\n\n  view->setSelectionBySingleClick( cfg.preferences.selectWordBySingleClick );\n\n  int index = cfg.preferences.newTabsOpenAfterCurrentOne ?\n              ui.tabWidget->currentIndex() + 1 : ui.tabWidget->count();\n\n  QString escaped = name;\n  escaped.replace( \"&\", \"&&\" );\n\n  ui.tabWidget->insertTab( index, view, escaped );\n  mruList.append(dynamic_cast<QWidget*>(view));\n\n  if ( switchToIt )\n    ui.tabWidget->setCurrentIndex( index );\n\n  view->setZoomFactor( cfg.preferences.zoomFactor );\n\n#ifdef Q_OS_WIN32\n  view->installEventFilter( this );\n#endif\n  return view;\n}\n\nvoid MainWindow::tabCloseRequested( int x )\n{\n  QWidget * w = ui.tabWidget->widget( x );\n\n  mruList.removeOne(w);\n\n  // In MRU case: First, we switch to the appropriate tab\n  // and only then remove the old one.\n\n  //activate a tab in accordance with MRU\n  if ( cfg.preferences.mruTabOrder && mruList.size() > 0 ) {\n    ui.tabWidget->setCurrentWidget(mruList.at(0));\n  }\n  else if( ui.tabWidget->count() > 1 )\n  {\n    //activate neighboring tab\n    int n = x >= ui.tabWidget->count() - 1 ? x - 1 : x + 1;\n    if( n >= 0 )\n      ui.tabWidget->setCurrentIndex( n );\n  }\n\n  ui.tabWidget->removeTab( x );\n  delete w;\n\n  if( ui.tabWidget->count() != 0 )\n    return;\n  // if everything is closed, add a new tab\n  addNewTab();\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  QWidget const * const focused = focusWidget();\n  if( !focused || focused == ui.tabWidget->tabBar() )\n  {\n    // The article view in the last closed tab had focus. Now no widget has focus or the tab bar acquired useless to it\n    // focus. In this situation GoldenDict ignores typing a new phrase to be translated. Furthermore, when no widget has\n    // focus, focus-transferring shortcuts don't work. Give focus to the newly created article view to work this around.\n    // Cannot just call focusArticleView() or focusTranslateLine(), because no window should be activated here.\n    Q_ASSERT( getCurrentArticleView() );\n    getCurrentArticleView()->focus();\n  }\n#endif\n}\n\nvoid MainWindow::closeCurrentTab()\n{\n  tabCloseRequested( ui.tabWidget->currentIndex() );\n}\n\nvoid MainWindow::closeAllTabs()\n{\n  while (ui.tabWidget->count() > 1)\n    closeCurrentTab();\n\n  // close last tab\n  closeCurrentTab();\n}\n\nvoid MainWindow::closeRestTabs()\n{\n  if ( ui.tabWidget->count() < 2 )\n    return;\n\n  int idx = ui.tabWidget->currentIndex();\n\n  for (int i = 0; i < idx; i++)\n    tabCloseRequested(0);\n\n  ui.tabWidget->setCurrentIndex(0);\n\n  while (ui.tabWidget->count() > 1)\n    tabCloseRequested(1);\n}\n\nvoid MainWindow::switchToNextTab()\n{\n  if ( ui.tabWidget->count() < 2 )\n    return;\n\n  ui.tabWidget->setCurrentIndex( ( ui.tabWidget->currentIndex() + 1 ) % ui.tabWidget->count() );\n}\n\nvoid MainWindow::switchToPrevTab()\n{\n  if ( ui.tabWidget->count() < 2 )\n    return;\n\n  if ( !ui.tabWidget->currentIndex() )\n    ui.tabWidget->setCurrentIndex( ui.tabWidget->count() - 1 );\n  else\n    ui.tabWidget->setCurrentIndex( ui.tabWidget->currentIndex() - 1 );\n}\n\n//emitted by tabListMenu when user releases Ctrl\nvoid MainWindow::ctrlReleased()\n{\n    if (tabListMenu->actions().size() > 1)\n    {\n        QAction *act = tabListMenu->activeAction();\n        if( act == 0 )\n          act = tabListMenu->actions().at( 1 );\n        ui.tabWidget->setCurrentIndex( act->data().toInt() );\n    }\n    tabListMenu->hide();\n}\n\nvoid MainWindow::backClicked()\n{\n  GD_DPRINTF( \"Back\\n\" );\n\n  ArticleView *view = getCurrentArticleView();\n\n  view->back();\n}\n\nvoid MainWindow::forwardClicked()\n{\n  GD_DPRINTF( \"Forward\\n\" );\n\n  ArticleView *view = getCurrentArticleView();\n\n  view->forward();\n}\n\nvoid MainWindow::titleChanged( ArticleView * view, QString const & title )\n{\n  QString escaped = title;\n  escaped.replace( \"&\", \"&&\" );\n\n  if( escaped.isRightToLeft() )\n  {\n    escaped.insert( 0, (ushort)0x202E ); // RLE, Right-to-Left Embedding\n    escaped.append( (ushort)0x202C ); // PDF, POP DIRECTIONAL FORMATTING\n  }\n\n  int index = ui.tabWidget->indexOf( view );\n  ui.tabWidget->setTabText( index, escaped );\n\n  if( index == ui.tabWidget->currentIndex() )\n  {\n    // Set icon for \"Add to Favorites\" action\n    int groupId = 0;\n    ArticleView *view = getCurrentArticleView();\n    if( view )\n      groupId = view->getViewGroup();\n    if( groupId == 0 )\n      groupId = cfg.lastMainGroupId;\n\n    if( isWordPresentedInFavorites( title, groupId ) )\n    {\n      addToFavorites->setIcon( blueStarIcon );\n      addToFavorites->setToolTip( tr( \"Remove current tab from Favorites\" ) );\n    }\n    else\n    {\n      addToFavorites->setIcon( starIcon );\n      addToFavorites->setToolTip( tr( \"Add current tab to Favorites\" ) );\n    }\n\n    updateWindowTitle();\n  }\n}\n\nvoid MainWindow::iconChanged( ArticleView * view, QIcon const & icon )\n{\n  ui.tabWidget->setTabIcon( ui.tabWidget->indexOf( view ), groupInstances.size() > 1 ? icon : QIcon() );\n}\n\nvoid MainWindow::updateWindowTitle()\n{\n  ArticleView *view = getCurrentArticleView();\n  if ( view )\n  {\n    QString str = view->getTitle();\n    if( !str.isEmpty() )\n    {\n      if( str.isRightToLeft() )\n      {\n        str.insert( 0, (ushort)0x202E ); // RLE, Right-to-Left Embedding\n        str.append( (ushort)0x202C ); // PDF, POP DIRECTIONAL FORMATTING\n      }\n      if( !blockUpdateWindowTitle )\n        setWindowTitle( tr( \"%1 - %2\" ).arg( str, \"GoldenDict\" ) );\n      blockUpdateWindowTitle = false;\n    }\n  }\n}\n\nvoid MainWindow::pageLoaded( ArticleView * view )\n{\n  if( view != getCurrentArticleView() )\n    return; // It was background action\n\n  updateBackForwardButtons();\n\n  updatePronounceAvailability();\n\n  if ( cfg.preferences.pronounceOnLoadMain )\n    pronounce( view );\n\n  updateFoundInDictsList();\n}\n\nvoid MainWindow::showStatusBarMessage( QString const & message, int timeout, QPixmap const & icon )\n{\n  if( message.isEmpty() )\n    mainStatusBar->clearMessage();\n  else\n    mainStatusBar->showMessage( message, timeout, icon );\n}\n\nvoid MainWindow::tabSwitched( int )\n{\n  translateBox->setPopupEnabled( false );\n  updateBackForwardButtons();\n  updatePronounceAvailability();\n  updateFoundInDictsList();\n  updateWindowTitle();\n  if (mruList.size() > 1)\n  {\n    int from = mruList.indexOf( ui.tabWidget->widget( ui.tabWidget->currentIndex() ) );\n    if ( from > 0)\n      mruList.move( from, 0 );\n  }\n\n  // Set icon for \"Add to Favorites\" action\n\n  int groupId = 0;\n  ArticleView *view = getCurrentArticleView();\n  if( view )\n    groupId = view->getViewGroup();\n  if( groupId == 0 )\n    groupId = cfg.lastMainGroupId;\n\n  QString headword = ui.tabWidget->tabText( ui.tabWidget->currentIndex() );\n  if( isWordPresentedInFavorites( unescapeTabHeader( headword ), groupId ) )\n  {\n    addToFavorites->setIcon( blueStarIcon );\n    addToFavorites->setToolTip( tr( \"Remove current tab from Favorites\" ) );\n  }\n  else\n  {\n    addToFavorites->setIcon( starIcon );\n    addToFavorites->setToolTip( tr( \"Add current tab to Favorites\" ) );\n  }\n}\n\nvoid MainWindow::tabMenuRequested(QPoint pos)\n{\n//  // do not show this menu for single tab\n//  if ( ui.tabWidget->count() < 2 )\n//    return;\n\n  tabMenu->popup(ui.tabWidget->mapToGlobal(pos));\n}\n\nvoid MainWindow::dictionaryBarToggled( bool )\n{\n  // From now on, only the triggered() signal is interesting to us\n  disconnect( dictionaryBar.toggleViewAction(), SIGNAL(toggled(bool)),\n              this, SLOT(dictionaryBarToggled(bool)) );\n\n  updateDictionaryBar(); // Updates dictionary bar contents if it's shown\n  applyMutedDictionariesState(); // Visibility change affects searches and results\n}\n\nvoid MainWindow::pronounce( ArticleView * view )\n{\n  if ( view )\n    view->playSound();\n  else\n    getCurrentArticleView()->playSound();\n}\n\nvoid MainWindow::showDictsPane( )\n{\n  if( !ui.dictsPane->isVisible() )\n    ui.dictsPane->show();\n}\n\nvoid MainWindow::dictsPaneVisibilityChanged( bool visible )\n{\n  if (visible) {\n    updateFoundInDictsList();\n  }\n}\n\nvoid MainWindow::updateFoundInDictsList()\n{\n  if (!ui.dictsList->isVisible())\n  {\n    // nothing to do, the list is not visible\n    return;\n  }\n\n  ui.dictsList->clear();\n\n  ArticleView *view = getCurrentArticleView();\n\n  if ( view )\n  {\n    QStringList ids = view->getArticlesList();\n    QString activeId = view->getActiveArticleId();\n\n    for( QStringList::const_iterator i = ids.constBegin(); i != ids.constEnd(); ++i)\n    {\n      // Find this dictionary\n\n      for( unsigned x = dictionaries.size(); x--; )\n      {\n        if ( dictionaries[ x ]->getId() == i->toUtf8().data() )\n        {\n          QString dictName = QString::fromUtf8( dictionaries[ x ]->getName().c_str() );\n          QString dictId = QString::fromUtf8( dictionaries[ x ]->getId().c_str() );\n          QListWidgetItem * item =\n              new QListWidgetItem(\n                dictionaries[ x ]->getIcon().pixmap(32).scaledToHeight( 21, Qt::SmoothTransformation ),\n                dictName,\n                ui.dictsList, QListWidgetItem::Type );\n          item->setData(Qt::UserRole, QVariant( dictId ) );\n          item->setToolTip(dictName);\n\n          ui.dictsList->addItem( item );\n          if (dictId == activeId)\n          {\n            ui.dictsList->setCurrentItem(item);\n          }\n          break;\n        }\n      }\n    }\n  }\n}\n\nvoid MainWindow::updateBackForwardButtons()\n{\n  ArticleView *view = getCurrentArticleView();\n\n  if ( view )\n  {\n    navBack->setEnabled(view->canGoBack());\n    navForward->setEnabled(view->canGoForward());\n  }\n}\n\nvoid MainWindow::updatePronounceAvailability()\n{\n  bool pronounceEnabled = ui.tabWidget->count() > 0 &&\n    getCurrentArticleView()->hasSound();\n\n  navPronounce->setEnabled( pronounceEnabled );\n}\n\nvoid MainWindow::editDictionaries( unsigned editDictionaryGroup )\n{\n  hotkeyWrapper.reset(); // No hotkeys while we're editing dictionaries\n  scanPopup.reset(); // No scan popup either. No one should use dictionaries.\n  closeHeadwordsDialog();\n  closeFullTextSearchDialog();\n\n  ftsIndexing.stopIndexing();\n  ftsIndexing.clearDictionaries();\n\n  wordFinder.clear();\n  dictionariesUnmuted.clear();\n\n  hideGDHelp();\n\n  { // Limit existence of newCfg\n\n  Config::Class newCfg = cfg;\n  EditDictionaries dicts( this, newCfg, dictionaries, groupInstances, dictNetMgr );\n\n  connect( &dicts, SIGNAL( showDictionaryInfo( QString const & ) ),\n           this, SLOT( showDictionaryInfo( QString const & ) ) );\n\n  connect( &dicts, SIGNAL( showDictionaryHeadwords( QString const & ) ),\n           this, SLOT( showDictionaryHeadwords( QString const & ) ) );\n\n  if ( editDictionaryGroup != Instances::Group::NoGroupId )\n    dicts.editGroup( editDictionaryGroup );\n\n  dicts.restoreGeometry( cfg.dictionariesDialogGeometry );\n  dicts.exec();\n  cfg.dictionariesDialogGeometry = newCfg.dictionariesDialogGeometry = dicts.saveGeometry();\n\n  if ( dicts.areDictionariesChanged() || dicts.areGroupsChanged() )\n  {\n\n    // Set muted dictionaries from old groups\n    for( int x = 0; x < newCfg.groups.size(); x++ )\n    {\n      unsigned id = newCfg.groups[ x ].id;\n      if( id != Instances::Group::NoGroupId )\n      {\n        Config::Group const * grp = cfg.getGroup( id );\n        if( grp )\n        {\n          newCfg.groups[ x ].mutedDictionaries = grp->mutedDictionaries;\n          newCfg.groups[ x ].popupMutedDictionaries = grp->popupMutedDictionaries;\n        }\n      }\n    }\n\n    cfg = newCfg;\n\n    updateGroupList();\n\n    Config::save( cfg );\n\n    updateSuggestionList();\n  }\n\n  }\n\n  makeScanPopup();\n  installHotKeys();\n\n  for( unsigned x = 0; x < dictionaries.size(); x++ )\n  {\n    dictionaries[ x ]->setFTSParameters( cfg.preferences.fts );\n    dictionaries[ x ]->setSynonymSearchEnabled( cfg.preferences.synonymSearchEnabled );\n  }\n\n  ftsIndexing.setDictionaries( dictionaries );\n  ftsIndexing.doIndexing();\n}\n\nvoid MainWindow::editCurrentGroup()\n{\n  editDictionaries( groupList->getCurrentGroup() );\n}\n\nvoid MainWindow::editPreferences()\n{\n  hotkeyWrapper.reset(); // So we could use the keys it hooks\n  scanPopup.reset(); // No scan popup either. No one should use dictionaries.\n  closeHeadwordsDialog();\n  closeFullTextSearchDialog();\n\n  ftsIndexing.stopIndexing();\n  ftsIndexing.clearDictionaries();\n\n  Preferences preferences( this, cfg );\n\n  hideGDHelp();\n\n  preferences.show();\n\n  if ( preferences.exec() == QDialog::Accepted )\n  {\n    Config::Preferences p = preferences.getPreferences();\n\n    // These parameters are not set in dialog\n    p.zoomFactor = cfg.preferences.zoomFactor;\n    p.helpZoomFactor = cfg.preferences.helpZoomFactor;\n    p.wordsZoomLevel = cfg.preferences.wordsZoomLevel;\n    p.hideMenubar = cfg.preferences.hideMenubar;\n    p.searchInDock = cfg.preferences.searchInDock;\n    p.alwaysOnTop = cfg.preferences.alwaysOnTop;\n#ifndef Q_WS_X11\n    p.trackClipboardChanges = cfg.preferences.trackClipboardChanges;\n#endif\n    p.proxyServer.systemProxyUser = cfg.preferences.proxyServer.systemProxyUser;\n    p.proxyServer.systemProxyPassword = cfg.preferences.proxyServer.systemProxyPassword;\n\n    p.fts.dialogGeometry = cfg.preferences.fts.dialogGeometry;\n    p.fts.matchCase = cfg.preferences.fts.matchCase;\n    p.fts.maxArticlesPerDictionary = cfg.preferences.fts.maxArticlesPerDictionary;\n    p.fts.maxDistanceBetweenWords = cfg.preferences.fts.maxDistanceBetweenWords;\n    p.fts.searchMode = cfg.preferences.fts.searchMode;\n    p.fts.useMaxArticlesPerDictionary = cfg.preferences.fts.useMaxArticlesPerDictionary;\n    p.fts.useMaxDistanceBetweenWords = cfg.preferences.fts.useMaxDistanceBetweenWords;\n    p.fts.ignoreWordsOrder = cfg.preferences.fts.ignoreWordsOrder;\n    p.fts.ignoreDiacritics = cfg.preferences.fts.ignoreDiacritics;\n\n    bool needReload = false;\n\n    // See if we need to reapply stylesheets\n    if ( cfg.preferences.displayStyle != p.displayStyle || cfg.preferences.addonStyle != p.addonStyle )\n    {\n      applyQtStyleSheet( p.displayStyle, p.addonStyle );\n      articleMaker.setDisplayStyle( p.displayStyle, p.addonStyle );\n      needReload = true;\n    }\n\n    if( cfg.preferences.collapseBigArticles != p.collapseBigArticles\n        || cfg.preferences.articleSizeLimit != p.articleSizeLimit )\n    {\n      articleMaker.setCollapseParameters( p.collapseBigArticles, p.articleSizeLimit );\n    }\n\n    // See if we need to reapply expand optional parts mode\n    if( cfg.preferences.alwaysExpandOptionalParts != p.alwaysExpandOptionalParts )\n    {\n      emit setExpandOptionalParts( p.alwaysExpandOptionalParts );\n      // Signal setExpandOptionalParts reload all articles\n      needReload = false;\n    }\n\n    // See if we need to change help language\n    if( cfg.preferences.helpLanguage != p.helpLanguage )\n      closeGDHelp();\n\n    for( int x = 0; x < ui.tabWidget->count(); ++x )\n    {\n      ArticleView & view =\n        dynamic_cast< ArticleView & >( *( ui.tabWidget->widget( x ) ) );\n\n      view.setSelectionBySingleClick( p.selectWordBySingleClick );\n\n      if( needReload )\n        view.reload();\n    }\n\n    if( cfg.preferences.historyStoreInterval != p.historyStoreInterval )\n      history.setSaveInterval( p.historyStoreInterval );\n\n    if( cfg.preferences.favoritesStoreInterval != p.favoritesStoreInterval )\n      ui.favoritesPaneWidget->setSaveInterval( p.favoritesStoreInterval );\n\n    if( cfg.preferences.maxNetworkCacheSize != p.maxNetworkCacheSize )\n      setupNetworkCache( p.maxNetworkCacheSize );\n    cfg.preferences = p;\n\n    audioPlayerFactory.setPreferences( cfg.preferences );\n\n    beforeScanPopupSeparator->setVisible( cfg.preferences.enableScanPopup );\n    enableScanPopup->setVisible( cfg.preferences.enableScanPopup );\n    afterScanPopupSeparator->setVisible( cfg.preferences.enableScanPopup );\n\n    if ( !cfg.preferences.enableScanPopup )\n      enableScanPopup->setChecked( false );\n\n    updateTrayIcon();\n    applyProxySettings();\n    applyWebSettings();\n\n    ui.tabWidget->setHideSingleTab(cfg.preferences.hideSingleTab);\n\n    setAutostart( cfg.preferences.autoStart );\n\n    prepareNewReleaseChecks();\n\n    history.enableAdd( cfg.preferences.storeHistory );\n    history.setMaxSize( cfg.preferences.maxStringsInHistory );\n    ui.historyPaneWidget->updateHistoryCounts();\n\n    for( unsigned x = 0; x < dictionaries.size(); x++ )\n    {\n      dictionaries[ x ]->setFTSParameters( cfg.preferences.fts );\n      dictionaries[ x ]->setSynonymSearchEnabled( cfg.preferences.synonymSearchEnabled );\n    }\n\n    ui.fullTextSearchAction->setEnabled( cfg.preferences.fts.enabled );\n\n    Config::save( cfg );\n  }\n\n  makeScanPopup();\n  installHotKeys();\n\n  ftsIndexing.setDictionaries( dictionaries );\n  ftsIndexing.doIndexing();\n}\n\nvoid MainWindow::currentGroupChanged( QString const & )\n{\n  cfg.lastMainGroupId = groupList->getCurrentGroup();\n  Instances::Group const * igrp = groupInstances.findGroup( cfg.lastMainGroupId );\n  if( cfg.lastMainGroupId == Instances::Group::AllGroupId )\n  {\n    if( igrp )\n      igrp->checkMutedDictionaries( &cfg.mutedDictionaries );\n    dictionaryBar.setMutedDictionaries( &cfg.mutedDictionaries );\n  }\n  else\n  {\n    Config::Group * grp = cfg.getGroup( cfg.lastMainGroupId );\n    if( grp )\n    {\n      if( igrp )\n        igrp->checkMutedDictionaries( &grp->mutedDictionaries );\n      dictionaryBar.setMutedDictionaries( &grp->mutedDictionaries );\n    }\n    else\n      dictionaryBar.setMutedDictionaries( 0 );\n  }\n\n  updateDictionaryBar();\n\n  // Update word search results\n  translateBox->setPopupEnabled( false );\n  updateSuggestionList();\n  translateInputFinished( false );\n\n  updateCurrentGroupProperty();\n\n  if( ftsDlg )\n    ftsDlg->setCurrentGroup( cfg.lastMainGroupId );\n}\n\nvoid MainWindow::updateCurrentGroupProperty()\n{\n  // We maintain currentGroup property so styles could use that to change\n  // fonts based on group names\n  Instances::Group * grp =\n      groupInstances.findGroup( groupList->getCurrentGroup() );\n\n  if ( grp && translateLine->property( \"currentGroup\" ).toString() !=\n       grp->name )\n  {\n    translateLine->setProperty( \"currentGroup\", grp->name );\n    wordList->setProperty( \"currentGroup\", grp->name );\n    QString ss = styleSheet();\n\n    // Only update stylesheet if it mentions currentGroup, as updating the\n    // stylesheet is a slow operation\n    if ( ss.contains(\"currentGroup\") )\n      setStyleSheet( ss );\n  }\n}\n\nvoid MainWindow::translateInputChanged( QString const & newValue )\n{\n  updateSuggestionList( newValue );\n  translateBoxSuffix = QString();\n}\n\nvoid MainWindow::updateSuggestionList()\n{\n  updateSuggestionList( translateLine->text() );\n}\n\nvoid MainWindow::updateSuggestionList( QString const & newValue )\n{\n  // If there's some status bar message present, clear it since it may be\n  // about the previous search that has failed.\n  if ( !mainStatusBar->currentMessage().isEmpty() )\n  {\n    mainStatusBar->clearMessage();\n  }\n\n  // If some word is selected in the word list, unselect it. This prevents\n  // triggering a set of spurious activation signals when the list changes.\n\n  if ( wordList->selectionModel()->hasSelection() )\n    wordList->setCurrentItem( 0, QItemSelectionModel::Clear );\n\n  QString req = newValue.trimmed();\n\n  if ( !req.size() )\n  {\n    // An empty request always results in an empty result\n    wordFinder.cancel();\n    wordList->clear();\n    wordList->unsetCursor();\n\n    // Reset the noResults mark if it's on right now\n    if ( translateLine->property( \"noResults\" ).toBool() )\n    {\n      translateLine->setProperty( \"noResults\", false );\n      setStyleSheet( styleSheet() );\n    }\n    return;\n  }\n\n  wordList->setCursor( Qt::WaitCursor );\n\n  wordFinder.prefixMatch( req, getActiveDicts() );\n}\n\nvoid MainWindow::translateInputFinished( bool checkModifiers )\n{\n  QString word = translateLine->text().trimmed();\n  if( word.isEmpty() )\n    return;\n  word = Folding::unescapeWildcardSymbols( word );\n  respondToTranslationRequest( Config::InputPhrase( word, translateBoxSuffix ), checkModifiers );\n}\n\nvoid MainWindow::respondToTranslationRequest( Config::InputPhrase const & phrase,\n                                              bool checkModifiers, QString const & scrollTo )\n{\n  if ( phrase.isValid() )\n  {\n    Qt::KeyboardModifiers mods = QApplication::keyboardModifiers();\n    if ( checkModifiers && ( mods & (Qt::ControlModifier | Qt::ShiftModifier) ) )\n      addNewTab();\n\n    showTranslationFor( phrase, 0, scrollTo );\n\n    if ( cfg.preferences.searchInDock )\n    {\n      if ( ui.searchPane->isFloating() )\n        activateWindow();\n    }\n\n    getCurrentArticleView()->focus();\n  }\n}\n\nvoid MainWindow::setTranslateBoxTextAndKeepSuffix( QString text, WildcardPolicy wildcardPolicy,\n                                                   TranslateBoxPopup popupAction )\n{\n  if( wildcardPolicy == EscapeWildcards )\n    text = Folding::escapeWildcardSymbols( text );\n\n  if( popupAction == NoPopupChange || cfg.preferences.searchInDock )\n    translateLine->setText( text );\n  else\n    translateBox->setText( text, popupAction == EnablePopup );\n}\n\nvoid MainWindow::setTranslateBoxTextAndClearSuffix( QString const & text, WildcardPolicy wildcardPolicy,\n                                                    TranslateBoxPopup popupAction )\n{\n  setTranslateBoxTextAndKeepSuffix( text, wildcardPolicy, popupAction );\n  translateBoxSuffix = QString();\n}\n\nvoid MainWindow::handleEsc()\n{\n  ArticleView *view = getCurrentArticleView();\n  if ( view && view->closeSearch() )\n    return;\n\n  if( cfg.preferences.escKeyHidesMainWindow )\n  {\n    toggleMainWindow();\n  }\n  else\n    focusTranslateLine();\n}\n\nvoid MainWindow::focusTranslateLine()\n{\n  if ( cfg.preferences.searchInDock )\n  {\n    if ( ui.searchPane->isFloating() )\n      ui.searchPane->activateWindow();\n  }\n  else\n  {\n    if ( !isActiveWindow() )\n      activateWindow();\n  }\n\n  translateLine->clearFocus();\n  translateLine->setFocus();\n  translateLine->selectAll();\n}\n\nvoid MainWindow::applyMutedDictionariesState()\n{\n  translateBox->setPopupEnabled( false );\n\n  updateSuggestionList();\n\n  ArticleView *view = getCurrentArticleView();\n\n  if ( view )\n  {\n    // Update active article view\n    view->updateMutedContents();\n  }\n}\n\nbool MainWindow::handleBackForwardMouseButtons ( QMouseEvent * event) {\n  if ( event->button() == Qt::XButton1 ) {\n    backClicked();\n    return true;\n  }\n  else\n  if ( event->button() == Qt::XButton2 ) {\n    forwardClicked();\n    return true;\n  }\n  else\n    return false;\n}\n\nbool MainWindow::eventFilter( QObject * obj, QEvent * ev )\n{\n#ifdef Q_OS_WIN\n  if( obj == this && ev->type() == gdStoreNormalGeometryEvent )\n  {\n    if( !isMaximized() && !isMinimized() && !isFullScreen() )\n      cfg.normalMainWindowGeometry = normalGeometry();\n    ev->accept();\n    return true;\n  }\n\n  if( obj == this && ev->type() == gdApplyNormalGeometryEvent )\n  {\n    if( !isMaximized() && !isMinimized() && !isFullScreen() )\n      setGeometry( cfg.normalMainWindowGeometry );\n    ev->accept();\n    return true;\n  }\n#endif\n  if ( ev->type() == QEvent::ShortcutOverride\n       || ev->type() == QEvent::KeyPress )\n  {\n    // Handle Ctrl+H to show the History Pane.\n    QKeyEvent * ke = static_cast<QKeyEvent*>( ev );\n    if ( ke->key() == Qt::Key_H && ke->modifiers() == Qt::ControlModifier )\n    {\n      if( ev->type() == QEvent::KeyPress )\n        on_showHideHistory_triggered();\n      ev->accept();\n      return true;\n    }\n\n    // Handle Ctrl+I to show the Favorities Pane.\n    if ( ke->key() == Qt::Key_I && ke->modifiers() == Qt::ControlModifier )\n    {\n      if( ev->type() == QEvent::KeyPress )\n        on_showHideFavorites_triggered();\n      ev->accept();\n      return true;\n    }\n\n    // Handle F3/Shift+F3 shortcuts\n    if ( ke->key() == Qt::Key_F3 )\n    {\n      ArticleView  * view = getCurrentArticleView();\n      if ( view  && view->handleF3( obj, ev ) )\n        return true;\n    }\n  }\n\n  // when the main window is moved or resized, hide the word list suggestions\n  if ( obj == this && ( ev->type() == QEvent::Move || ev->type() == QEvent::Resize ) )\n  {\n#ifdef Q_OS_WIN\n    if( !isMaximized() && !isMinimized() && !isFullScreen() && gdAskMessage != 0xFFFFFFFF )\n    {\n      QEvent *ev = new QEvent( gdStoreNormalGeometryEvent );\n      qApp->postEvent( this, ev );\n    }\n#endif\n    if ( !cfg.preferences.searchInDock )\n    {\n        translateBox->setPopupEnabled( false );\n        return false;\n    }\n  }\n\n  if ( obj == this && ev->type() == QEvent::WindowStateChange )\n  {\n    QWindowStateChangeEvent *stev = static_cast< QWindowStateChangeEvent *>( ev );\n    wasMaximized = ( stev->oldState() == Qt::WindowMaximized && isMinimized() );\n\n#ifdef Q_OS_WIN\n    if( stev->oldState() == Qt::WindowMaximized && !isMinimized() && cfg.normalMainWindowGeometry.width() > 0 )\n    {\n      QEvent *ev = new QEvent( gdApplyNormalGeometryEvent );\n      qApp->postEvent( this, ev );\n    }\n#endif\n  }\n\n  if ( ev->type() == QEvent::MouseButtonPress ) {\n    QMouseEvent * event = static_cast< QMouseEvent * >( ev );\n\n    // clicks outside of the word list should hide it.\n    if (obj != translateBox->wordList() && obj != translateBox->wordList()->viewport()) {\n      translateBox->setPopupEnabled( false );\n    }\n\n    return handleBackForwardMouseButtons( event );\n  }\n\n  if (ev->type() == QEvent::KeyPress)\n  {\n    QKeyEvent *keyevent = static_cast<QKeyEvent*>(ev);\n\n    bool handleCtrlTab = ( obj == translateLine\n                           || obj == wordList\n                           || obj == ui.historyList\n                           || obj == ui.favoritesTree\n                           || obj == ui.dictsList\n                           || obj == groupList );\n\n    if (keyevent->modifiers() == Qt::ControlModifier && keyevent->key() == Qt::Key_Tab)\n    {\n      if (cfg.preferences.mruTabOrder)\n      {\n        ctrlTabPressed();\n        return true;\n      }\n      else if( handleCtrlTab )\n      {\n        QApplication::sendEvent( ui.tabWidget, ev );\n        return true;\n      }\n      return false;\n    }\n    if( handleCtrlTab && keyevent->matches( QKeySequence::PreviousChild ) ) // Handle only Ctrl+Shist+Tab here because Ctrl+Tab was already handled before\n    {\n      QApplication::sendEvent( ui.tabWidget, ev );\n      return true;\n    }\n  }\n\n  if ( obj == translateLine )\n  {\n    if ( ev->type() == QEvent::KeyPress )\n    {\n      QKeyEvent * keyEvent = static_cast< QKeyEvent * >( ev );\n\n      if ( cfg.preferences.searchInDock )\n      {\n        if ( keyEvent->matches( QKeySequence::MoveToNextLine ) && wordList->count() )\n        {\n          wordList->setFocus( Qt::ShortcutFocusReason );\n          wordList->setCurrentRow( 0, QItemSelectionModel::ClearAndSelect );\n          return true;\n        }\n      }\n\n    }\n\n    if ( ev->type() == QEvent::FocusIn ) {\n      QFocusEvent * focusEvent = static_cast< QFocusEvent * >( ev );\n\n      // select all on mouse click\n      if ( focusEvent->reason() == Qt::MouseFocusReason ) {\n        QTimer::singleShot(0, this, SLOT(focusTranslateLine()));\n      }\n      return false;\n    }\n\n    if ( ev->type() == QEvent::Resize ) {\n      QResizeEvent * resizeEvent = static_cast< QResizeEvent * >( ev );\n      groupList->setFixedHeight( resizeEvent->size().height() );\n      return false;\n    }\n  }\n  else\n  if ( obj == wordList )\n  {\n    if ( ev->type() == QEvent::KeyPress )\n    {\n      QKeyEvent * keyEvent = static_cast< QKeyEvent * >( ev );\n\n      if ( keyEvent->matches( QKeySequence::MoveToPreviousLine ) &&\n           !wordList->currentRow() )\n      {\n        wordList->setCurrentRow( 0, QItemSelectionModel::Clear );\n        translateLine->setFocus( Qt::ShortcutFocusReason );\n        return true;\n      }\n\n      if ( keyEvent->matches( QKeySequence::InsertParagraphSeparator ) &&\n           wordList->selectedItems().size() )\n      {\n        if ( cfg.preferences.searchInDock )\n        {\n          if ( ui.searchPane->isFloating() )\n            activateWindow();\n        }\n\n        getCurrentArticleView()->focus();\n\n        return cfg.preferences.searchInDock;\n      }\n\n      // Handle typing events used to initiate new lookups\n      // TODO: refactor to eliminate duplication (see below)\n\n      if ( keyEvent->modifiers() &\n           ( Qt::ControlModifier | Qt::AltModifier | Qt::MetaModifier ) )\n        return false; // A non-typing modifier is pressed\n\n      if ( keyEvent->key() == Qt::Key_Space ||\n           keyEvent->key() == Qt::Key_Backspace ||\n           keyEvent->key() == Qt::Key_Tab ||\n           keyEvent->key() == Qt::Key_Backtab )\n        return false; // Those key have other uses than to start typing\n                      // or don't make sense\n\n      QString text = keyEvent->text();\n\n      if ( text.size() )\n      {\n        typingEvent( text );\n        return true;\n      }\n    }\n  }\n  else\n  if (obj == ui.dictsList) {\n    if ( ev->type() == QEvent::KeyPress )\n    {\n      QKeyEvent * keyEvent = static_cast< QKeyEvent * >( ev );\n\n      // Handle typing events used to initiate new lookups\n      // TODO: refactor to eliminate duplication (see above)\n\n      if ( keyEvent->modifiers() &\n           ( Qt::ControlModifier | Qt::AltModifier | Qt::MetaModifier ) )\n        return false; // A non-typing modifier is pressed\n\n      if ( keyEvent->key() == Qt::Key_Space ||\n           keyEvent->key() == Qt::Key_Backspace ||\n           keyEvent->key() == Qt::Key_Tab ||\n           keyEvent->key() == Qt::Key_Backtab )\n        return false; // Those key have other uses than to start typing\n                      // or don't make sense\n\n      QString text = keyEvent->text();\n\n      if ( text.size() )\n      {\n        typingEvent( text );\n        return true;\n      }\n    }\n  }\n    return QMainWindow::eventFilter( obj, ev );\n\n  return false;\n}\n\nvoid MainWindow::wordListItemActivated( QListWidgetItem * item )\n{\n  if( wordListSelChanged )\n    wordListSelChanged = false;\n  else {\n    // TODO: code duplication with translateInputFinished!\n\n    Qt::KeyboardModifiers mods = QApplication::keyboardModifiers();\n    if ( mods & (Qt::ControlModifier | Qt::ShiftModifier) )\n      addNewTab();\n\n    showTranslationFor( item->text() );\n    getCurrentArticleView()->focus();\n  }\n}\n\nvoid MainWindow::wordListSelectionChanged()\n{\n  QList< QListWidgetItem * > selected = wordList->selectedItems();\n\n  if ( selected.size() )\n  {\n    wordListSelChanged = true;\n    showTranslationFor( selected.front()->text() );\n  }\n}\n\nvoid MainWindow::dictsListItemActivated( QListWidgetItem * item )\n{\n  jumpToDictionary( item, true );\n}\n\nvoid MainWindow::dictsListSelectionChanged()\n{\n  QList< QListWidgetItem * > selected = ui.dictsList->selectedItems();\n  if ( selected.size() )\n    jumpToDictionary( selected.front() );\n}\n\nvoid MainWindow::jumpToDictionary( QListWidgetItem * item, bool force )\n{\n  ArticleView * view = getCurrentArticleView();\n  if ( view )\n  {\n    view->jumpToDictionary( item->data( Qt::UserRole ).toString(), force );\n  }\n}\n\nvoid MainWindow::openLinkInNewTab( QUrl const & url,\n                                   QUrl const & referrer,\n                                   QString const & fromArticle,\n                                   ArticleView::Contexts const & contexts )\n{\n  createNewTab( !cfg.preferences.newTabsOpenInBackground, \"\" )->\n      openLink( url, referrer, fromArticle, contexts );\n}\n\nvoid MainWindow::showDefinitionInNewTab( QString const & word,\n                                         unsigned group,\n                                         QString const & fromArticle,\n                                         ArticleView::Contexts const & contexts )\n{\n  createNewTab( !cfg.preferences.newTabsOpenInBackground, word )->\n      showDefinition( word, group, fromArticle, contexts );\n}\n\nvoid MainWindow::activeArticleChanged( ArticleView const * view, QString const & id )\n{\n  if( view != getCurrentArticleView() )\n    return; // It was background action\n\n  // select the row with the corresponding id\n  for (int i = 0; i < ui.dictsList->count(); ++i) {\n    QListWidgetItem * w = ui.dictsList->item( i );\n    QString dictId = w->data( Qt::UserRole ).toString();\n\n    if ( dictId == id )\n    {\n      // update the current row, but only if necessary\n      if ( i != ui.dictsList->currentRow() )\n      {\n        ui.dictsList->setCurrentRow(i);\n      }\n      return;\n    }\n  }\n}\n\nvoid MainWindow::typingEvent( QString const & t )\n{\n  if ( t == \"\\n\" || t == \"\\r\" )\n  {\n    if( translateLine->isEnabled() )\n      focusTranslateLine();\n  }\n  else\n  {\n    if ( ( cfg.preferences.searchInDock && ui.searchPane->isFloating() ) || ui.dictsPane->isFloating() )\n      ui.searchPane->activateWindow();\n\n    if( translateLine->isEnabled() )\n    {\n      translateLine->setFocus();\n      // Escaping the typed-in characters is the user's responsibility.\n      setTranslateBoxTextAndClearSuffix( t, WildcardsAreAlreadyEscaped, EnablePopup );\n      translateLine->setCursorPosition( t.size() );\n    }\n  }\n}\n\nvoid MainWindow::mutedDictionariesChanged()\n{\n  if ( dictionaryBar.toggleViewAction()->isChecked() )\n    applyMutedDictionariesState();\n}\n\nvoid MainWindow::showHistoryItem( QString const & word )\n{\n  // qDebug() << \"Showing history item\" << word;\n\n  history.enableAdd( false );\n\n  setTranslateBoxTextAndClearSuffix( word, EscapeWildcards, DisablePopup );\n  showTranslationFor( word );\n\n  history.enableAdd( cfg.preferences.storeHistory );\n}\n\nvoid MainWindow::showTranslationFor( Config::InputPhrase const & phrase,\n                                     unsigned inGroup,\n                                     QString const & scrollTo )\n{\n  ArticleView *view = getCurrentArticleView();\n\n  navPronounce->setEnabled( false );\n\n  unsigned group = inGroup ? inGroup :\n                   ( groupInstances.empty() ? 0 :\n                        groupInstances[ groupList->currentIndex() ].id );\n\n  view->showDefinition( phrase, group, scrollTo );\n\n  #if 0\n  QUrl req;\n\n  req.setScheme( \"gdlookup\" );\n  req.setHost( \"localhost\" );\n  req.addQueryItem( \"word\", inWord );\n  req.addQueryItem( \"group\",\n                    cfg.groups.empty() ? \"\" :\n                      groupInstances[ groupList->currentIndex() ].name );\n\n  ui.definition->load( req );\n\n  return;\n#endif\n\n  #if 0\n  wstring word = inWord.trimmed().toStdWString();\n\n  // Where to look?\n\n  vector< sptr< Dictionary::Class > > const & activeDicts = getActiveDicts();\n\n  // Accumulate main forms\n\n  vector< wstring > alts;\n\n  {\n    set< wstring > altsSet;\n\n    for( unsigned x = 0; x < activeDicts.size(); ++x )\n    {\n      vector< wstring > found = activeDicts[ x ]->findHeadwordsForSynonym( word );\n\n      altsSet.insert( found.begin(), found.end() );\n    }\n\n    alts.insert( alts.begin(), altsSet.begin(), altsSet.end() );\n  }\n\n  for( unsigned x = 0; x < alts.size(); ++x )\n  {\n    DPRINTF( \"Alt: %ls\\n\", alts[ x ].c_str() );\n  }\n\n\n  string result =\n    \"<html><head>\"\n    \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=utf-8\\\">\";\n\n  QFile cssFile( Config::getUserCssFileName() );\n\n  if ( cssFile.open( QFile::ReadOnly ) )\n  {\n    result += \"<style type=\\\"text/css\\\">\\n\";\n    result += cssFile.readAll().data();\n    result += \"</style>\\n\";\n  }\n\n  result += \"</head><body>\";\n\n  for( unsigned x = 0; x < activeDicts.size(); ++x )\n  {\n    try\n    {\n      string body = activeDicts[ x ]->getArticle( word, alts );\n\n      DPRINTF( \"From %s: %s\\n\", activeDicts[ x ]->getName().c_str(), body.c_str() );\n\n      result += \"<div class=\\\"gddictname\\\">From \" + activeDicts[ x ]->getName() + \"</div>\" + body;\n    }\n    catch( Dictionary::exNoSuchWord & )\n    {\n      continue;\n    }\n  }\n\n  result += \"</body></html>\";\n\n  ArticleMaker am( dictionaries, groupInstances );\n\n  string result = am.makeDefinitionFor( inWord, \"En\" );\n\n  ui.definition->setContent( result.c_str(), QString() );\n\n  #endif\n\n  //ui.tabWidget->setTabText( ui.tabWidget->indexOf(ui.tab), inWord.trimmed() );\n}\n\nvoid MainWindow::showTranslationFor( QString const & word )\n{\n  showTranslationFor( Config::InputPhrase::fromPhrase( word ) );\n}\n\nvoid MainWindow::showTranslationFor( QString const & inWord,\n                                     QStringList const & dictIDs,\n                                     QRegExp const & searchRegExp,\n                                     bool ignoreDiacritics )\n{\n  ArticleView *view = getCurrentArticleView();\n\n  navPronounce->setEnabled( false );\n\n  view->showDefinition( inWord, dictIDs, searchRegExp,\n                        groupInstances[ groupList->currentIndex() ].id,\n                        ignoreDiacritics );\n}\n\n#ifdef X11_MAIN_WINDOW_FOCUS_WORKAROUNDS\nvoid MainWindow::toggleMainWindow( bool onlyShow, bool byIconClick )\n#else\nvoid MainWindow::toggleMainWindow( bool onlyShow )\n#endif\n{\n  bool shown = false;\n\n  if( !cfg.preferences.searchInDock )\n    translateBox->setPopupEnabled( false );\n\n  if ( !isVisible() )\n  {\n    show();\n\n#ifdef Q_OS_WIN32\n    if( !!( hotkeyWrapper ) && hotkeyWrapper->handleViaDLL() )\n    {\n      // Some dances with tambourine\n      HWND wId = (HWND) winId();\n      DWORD pId = GetWindowThreadProcessId( wId, NULL );\n      DWORD fpId = GetWindowThreadProcessId( GetForegroundWindow(), NULL );\n\n      //Attach Thread to get the Input - i am now allowed to set the Foreground window!\n      AttachThreadInput( fpId, pId, true );\n      SetActiveWindow( wId );\n      SetForegroundWindow( wId );\n      SetFocus( wId );\n      AttachThreadInput( fpId, pId, false );\n    }\n#endif\n\n    qApp->setActiveWindow( this );\n    activateWindow();\n    raise();\n    shown = true;\n  }\n  else\n  if ( isMinimized() )\n  {\n    if( wasMaximized )\n      showMaximized();\n    else\n      showNormal();\n    activateWindow();\n    raise();\n    shown = true;\n  }\n  else\n  if ( !isActiveWindow() )\n  {\n    qApp->setActiveWindow( this );\n#ifdef Q_OS_WIN32\n    if( !!( hotkeyWrapper ) && hotkeyWrapper->handleViaDLL() )\n    {\n      // Some dances with tambourine\n      HWND wId = (HWND) winId();\n      DWORD pId = GetWindowThreadProcessId( wId, NULL );\n      DWORD fpId = GetWindowThreadProcessId( GetForegroundWindow(), NULL );\n\n      //Attach Thread to get the Input - i am now allowed to set the Foreground window!\n      AttachThreadInput( fpId, pId, true );\n      SetActiveWindow( wId );\n      SetForegroundWindow( wId );\n      SetFocus( wId );\n      AttachThreadInput( fpId, pId, false );\n    }\n#endif\n    raise();\n    activateWindow();\n    shown = true;\n  }\n  else\n  if ( !onlyShow )\n  {\n    if (cfg.preferences.enableTrayIcon)\n      hide();\n    else\n      showMinimized();\n\n    if( headwordsDlg )\n      headwordsDlg->hide();\n\n    if( ftsDlg )\n      ftsDlg->hide();\n\n    if( helpWindow )\n      helpWindow->hide();\n  }\n\n  if ( shown )\n  {\n    if( headwordsDlg )\n      headwordsDlg->show();\n\n    if( ftsDlg )\n      ftsDlg->show();\n\n    focusTranslateLine();\n\n#ifdef X11_MAIN_WINDOW_FOCUS_WORKAROUNDS\n    if( !byIconClick )\n      QTimer::singleShot( 0, this, SLOT( forceX11Focus() ) );\n#endif\n  }\n}\n\n#ifdef X11_MAIN_WINDOW_FOCUS_WORKAROUNDS\nvoid MainWindow::forceX11Focus()\n{\n  Window wh = 0;\n  int rev = 0;\n  XGetInputFocus( QX11Info::display(), &wh, &rev );\n  if( wh != internalWinId() )\n  {\n    QPoint const pointRelativeToRoot = mapToGlobal( QPoint( 0, 0 ) );\n    XEvent event;\n    memset( &event, 0, sizeof( event) );\n    event.type = ButtonPress;\n    event.xbutton.x = 0;\n    event.xbutton.y = 0;\n    event.xbutton.x_root = pointRelativeToRoot.x();\n    event.xbutton.y_root = pointRelativeToRoot.y();\n    event.xbutton.window = internalWinId();\n    event.xbutton.root = QX11Info::appRootWindow( QX11Info::appScreen() );\n    event.xbutton.state = Button1Mask;\n    event.xbutton.button = Button1;\n    event.xbutton.same_screen = true;\n    event.xbutton.time = CurrentTime;\n\n    XSendEvent( QX11Info::display(), internalWinId(), true, 0xfff, &event );\n    XFlush( QX11Info::display() );\n    event.type = ButtonRelease;\n    XSendEvent( QX11Info::display(), internalWinId(), true, 0xfff, &event );\n    XFlush( QX11Info::display() );\n  }\n}\n#endif\n\nvoid MainWindow::installHotKeys()\n{\n  hotkeyWrapper.reset(); // Remove the old one\n\n  if ( cfg.preferences.enableMainWindowHotkey ||\n       cfg.preferences.enableClipboardHotkey )\n  {\n    try\n    {\n      hotkeyWrapper = new HotkeyWrapper( this );\n    }\n    catch( HotkeyWrapper::exInit & )\n    {\n      QMessageBox::critical( this, \"GoldenDict\",\n        tr( \"Failed to initialize hotkeys monitoring mechanism.<br>\"\n            \"Make sure your XServer has RECORD extension turned on.\" ) );\n\n      return;\n    }\n\n    if ( cfg.preferences.enableMainWindowHotkey )\n      hotkeyWrapper->setGlobalKey( cfg.preferences.mainWindowHotkey.key1,\n                                   cfg.preferences.mainWindowHotkey.key2,\n                                   cfg.preferences.mainWindowHotkey.modifiers,\n                                   0 );\n\n    if ( cfg.preferences.enableClipboardHotkey && scanPopup.get() )\n    {\n      hotkeyWrapper->setGlobalKey( cfg.preferences.clipboardHotkey.key1,\n                                   cfg.preferences.clipboardHotkey.key2,\n                                   cfg.preferences.clipboardHotkey.modifiers,\n                                   1 );\n    }\n\n    connect( hotkeyWrapper.get(), SIGNAL( hotkeyActivated( int ) ),\n             this, SLOT( hotKeyActivated( int ) ),\n#ifdef Q_OS_WIN32\n             hotkeyWrapper->handleViaDLL() ? Qt::QueuedConnection : Qt::AutoConnection );\n#else\n             Qt::AutoConnection );\n#endif\n  }\n}\n\nvoid MainWindow::hotKeyActivated( int hk )\n{\n  if ( !hk )\n    toggleMainWindow();\n  else\n  if ( scanPopup.get() )\n  {\n#ifdef HAVE_X11\n    // When the user requests translation with the Ctrl+C+C hotkey in certain apps\n    // on some GNU/Linux systems, GoldenDict appears to handle Ctrl+C+C before the\n    // active application finishes handling Ctrl+C. As a result, GoldenDict finds\n    // the clipboard empty, silently cancels the translation request, and users report\n    // that Ctrl+C+C is broken in these apps. Slightly delay handling the clipboard\n    // hotkey to give the active application more time and thus work around the issue.\n    QTimer::singleShot( 10, scanPopup.get(), SLOT( translateWordFromClipboard() ) );\n#else\n    scanPopup->translateWordFromClipboard();\n#endif\n  }\n}\n\nvoid MainWindow::prepareNewReleaseChecks()\n{\n  if ( cfg.preferences.checkForNewReleases )\n  {\n    QDateTime now = QDateTime::currentDateTime();\n\n    if ( !cfg.timeForNewReleaseCheck.isValid() ||\n         now.daysTo( cfg.timeForNewReleaseCheck ) > 2 )\n    {\n      // The date is invalid, or the check is set to happen more than 2 days\n      // in the future -- fix that.\n      cfg.timeForNewReleaseCheck = now.addDays( 2 );\n    }\n\n    int secsToCheck = now.secsTo( cfg.timeForNewReleaseCheck );\n\n    if ( secsToCheck < 1 )\n      secsToCheck = 1;\n\n    newReleaseCheckTimer.setSingleShot( true );\n    newReleaseCheckTimer.start( secsToCheck * 1000 );\n  }\n  else\n    newReleaseCheckTimer.stop(); // In case it was started before\n}\n\nvoid MainWindow::checkForNewRelease()\n{\n  if( latestReleaseReply )\n  {\n    disconnect( latestReleaseReply, 0, 0, 0 );\n    latestReleaseReply->deleteLater();\n  }\n  latestReleaseReply = 0;\n\n  QNetworkRequest req(\n    QUrl( \"http://goldendict.org/latest_release.php?current=\"\n          PROGRAM_VERSION \"&platform=\"\n#ifdef HAVE_X11\n          \"x11\"\n#endif\n#ifdef Q_OS_MAC\n          \"mac\"\n#endif\n#ifdef Q_WS_QWS\n          \"qws\"\n#endif\n#ifdef Q_OS_WIN\n          \"win\"\n#endif\n          ) );\n\n  latestReleaseReply = articleNetMgr.get( req );\n\n  connect( latestReleaseReply, SIGNAL( finished() ),\n           this, SLOT( latestReleaseReplyReady() ), Qt::QueuedConnection );\n}\n\nvoid MainWindow::latestReleaseReplyReady()\n{\n  if ( !latestReleaseReply )\n    return; // Some stray signal\n\n  bool success = false;\n  QString latestVersion, downloadUrl;\n\n  // See if we succeeded\n\n  if ( latestReleaseReply->error() == QNetworkReply::NoError )\n  {\n    QString latestReleaseInfo = QString::fromUtf8( latestReleaseReply->readLine() ).trimmed();\n    QStringList parts = latestReleaseInfo.split( ' ' );\n    if ( parts.size() == 2 )\n    {\n      latestVersion = parts[ 0 ];\n      downloadUrl = parts[ 1 ];\n      success = true;\n    }\n  }\n\n  disconnect( latestReleaseReply, 0, 0, 0 );\n  latestReleaseReply->deleteLater();\n  latestReleaseReply = 0;\n\n  if ( !success )\n  {\n    // Failed -- reschedule to check in two hours\n    newReleaseCheckTimer.start( 2 * 60 * 60 * 1000 );\n\n    GD_DPRINTF( \"Failed to check program version, retry in two hours\\n\" );\n  }\n  else\n  {\n    // Success -- reschedule for a normal check and save config\n    cfg.timeForNewReleaseCheck = QDateTime();\n\n    prepareNewReleaseChecks();\n\n    Config::save( cfg );\n\n    GD_DPRINTF( \"Program version's check successful, current version is %ls\\n\",\n                latestVersion.toStdWString().c_str() );\n  }\n\n  if ( success && latestVersion > PROGRAM_VERSION && latestVersion != cfg.skippedRelease )\n  {\n    QMessageBox msg( QMessageBox::Information,\n                     tr( \"New Release Available\" ),\n                     tr( \"Version <b>%1</b> of GoldenDict is now available for download.<br>\"\n                         \"Click <b>Download</b> to get to the download page.\" ).arg( latestVersion ),\n                     QMessageBox::NoButton,\n                     this );\n\n    QPushButton * dload = msg.addButton( tr( \"Download\" ), QMessageBox::AcceptRole );\n    QPushButton * skip = msg.addButton( tr( \"Skip This Release\" ), QMessageBox::DestructiveRole );\n    msg.addButton( QMessageBox::Cancel );\n\n    msg.exec();\n\n    if ( msg.clickedButton() == dload )\n      QDesktopServices::openUrl( QUrl( downloadUrl ) );\n    else\n    if ( msg.clickedButton() == skip )\n    {\n      cfg.skippedRelease = latestVersion;\n      Config::save( cfg );\n    }\n  }\n}\n\nvoid MainWindow::trayIconActivated( QSystemTrayIcon::ActivationReason r )\n{\n  switch(r) {\n    case QSystemTrayIcon::Trigger:\n      // Left click toggles the visibility of main window\n#ifdef X11_MAIN_WINDOW_FOCUS_WORKAROUNDS\n      toggleMainWindow( false, true );\n#else\n      toggleMainWindow();\n#endif\n      break;\n\n    case QSystemTrayIcon::MiddleClick:\n      // Middle mouse click on Tray translates selection\n      // it is functional like as stardict\n      if ( scanPopup.get() ) {\n        scanPopup->translateWordFromSelection();\n      }\n      break;\n    default:\n      break;\n\n  }\n}\n\nvoid MainWindow::scanEnableToggled( bool on )\n{\n  if ( !cfg.preferences.enableScanPopup )\n    return;\n\n  if ( scanPopup )\n  {\n    if ( on )\n    {\n      scanPopup->enableScanning();\n#ifdef Q_OS_MAC\n      if( !MacMouseOver::isAXAPIEnabled() )\n          mainStatusBar->showMessage( tr( \"Accessibility API is not enabled\" ), 10000,\n                                          QPixmap( \":/icons/error.png\" ) );\n#endif\n    }\n    else\n      scanPopup->disableScanning();\n  }\n\n  updateTrayIcon();\n}\n\nvoid MainWindow::showMainWindow()\n{\n  toggleMainWindow( true );\n}\n\nvoid MainWindow::visitHomepage()\n{\n  QDesktopServices::openUrl( QUrl( \"http://goldendict.org/\" ) );\n}\n\nvoid MainWindow::openConfigFolder()\n{\n  QDesktopServices::openUrl( QUrl::fromLocalFile( Config::getConfigDir() ) );\n}\n\nvoid MainWindow::visitForum()\n{\n  QDesktopServices::openUrl( QUrl( \"http://goldendict.org/forum/\" ) );\n}\n\nvoid MainWindow::showAbout()\n{\n  About about( this );\n\n  about.show();\n  about.exec();\n}\n\nvoid MainWindow::showDictBarNamesTriggered()\n{\n  bool show = showDictBarNamesAction.isChecked();\n\n  dictionaryBar.setToolButtonStyle( show ? Qt::ToolButtonTextBesideIcon :\n                                           Qt::ToolButtonIconOnly );\n  cfg.showingDictBarNames = show;\n}\n\nvoid MainWindow::useSmallIconsInToolbarsTriggered()\n{\n  bool useSmallIcons = useSmallIconsInToolbarsAction.isChecked();\n\n  int extent = useSmallIcons ? QApplication::style()->pixelMetric(QStyle::PM_SmallIconSize) :\n                               QApplication::style()->pixelMetric(QStyle::PM_ToolBarIconSize);\n\n  navToolbar->setIconSize( QSize( extent, extent ) );\n\n  // additional fix for #176\n  menuButton->setIconSize( QSize( extent, extent ) );\n\n  updateDictionaryBar();\n\n  cfg.usingSmallIconsInToolbars = useSmallIcons;\n\n  if( scanPopup.get() )\n    scanPopup->setDictionaryIconSize();\n}\n\nvoid MainWindow::toggleMenuBarTriggered(bool announce)\n{\n  cfg.preferences.hideMenubar = !toggleMenuBarAction.isChecked();\n\n  if ( announce )\n  {\n    if ( cfg.preferences.hideMenubar )\n    {\n      mainStatusBar->showMessage(\n            tr( \"You have chosen to hide a menubar. Use %1 to show it back.\" )\n            .arg( QString( \"<b>%1</b>\" ) ).arg( tr( \"Ctrl+M\" ) ),\n            10000,\n            QPixmap( \":/icons/warning.png\" ) );\n    }\n    else\n    {\n      mainStatusBar->clearMessage();\n    }\n  }\n\n  // Obtain from the menubar all the actions with shortcuts\n  // and either add them to the main window or remove them,\n  // depending on the menubar state.\n\n  QList<QMenu *> allMenus = menuBar()->findChildren<QMenu *>();\n  QListIterator<QMenu *> menuIter( allMenus );\n  while( menuIter.hasNext() )\n  {\n    QMenu * menu = menuIter.next();\n    QList<QAction *> allMenuActions = menu->actions();\n    QListIterator<QAction *> actionsIter( allMenuActions );\n    while( actionsIter.hasNext() )\n    {\n      QAction * action = actionsIter.next();\n      if ( !action->shortcut().isEmpty() )\n      {\n        if ( cfg.preferences.hideMenubar )\n        {\n          // add all menubar actions to the main window,\n          // before we hide the menubar\n          addAction( action );\n        }\n        else\n        {\n          // remove all menubar actions from the main window\n          removeAction( action );\n        }\n      }\n    }\n  }\n\n  menuBar()->setVisible( !cfg.preferences.hideMenubar );\n  beforeOptionsSeparator->setVisible( cfg.preferences.hideMenubar);\n  menuButtonAction->setVisible( cfg.preferences.hideMenubar );\n}\n\nvoid MainWindow::on_clearHistory_triggered()\n{\n  history.clear();\n  history.save();\n}\n\nvoid MainWindow::on_newTab_triggered()\n{\n  addNewTab();\n}\n\nvoid MainWindow::setAutostart(bool autostart)\n{\n#if defined Q_OS_WIN32\n    QSettings reg(\"HKEY_CURRENT_USER\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\",\n                  QSettings::NativeFormat);\n    if (autostart) {\n        QString app_fname = QString(\"\\\"%1\\\"\").arg( QCoreApplication::applicationFilePath() );\n        app_fname.replace(\"/\", \"\\\\\");\n        reg.setValue(QCoreApplication::applicationName(), app_fname);\n    }\n    else {\n        reg.remove(QCoreApplication::applicationName());\n    }\n    reg.sync();\n#elif defined HAVE_X11\n  const QString destinationPath = QDir::homePath() + \"/.config/autostart/goldendict-owned-by-preferences.desktop\";\n  if( autostart == QFile::exists( destinationPath ) )\n    return; // Nothing to do.\n  if( autostart )\n  {\n    const QString sourcePath = Config::getProgramDataDir() + \"../applications/org.goldendict.GoldenDict.desktop\";\n    QFile::copy( sourcePath, destinationPath );\n  }\n  else\n    QFile::remove( destinationPath );\n#endif\n}\n\nvoid MainWindow::on_actionCloseToTray_triggered()\n{\n  toggleMainWindow( !cfg.preferences.enableTrayIcon );\n}\n\nvoid MainWindow::on_pageSetup_triggered()\n{\n  if ( getPrinter().isValid() )\n  {\n    QPageSetupDialog dialog( &getPrinter(), this );\n\n    dialog.exec();\n  }\n  else\n    QMessageBox::critical( this, tr( \"Page Setup\" ),\n                           tr( \"No printer is available. Please install one first.\" ) );\n}\n\nvoid MainWindow::on_printPreview_triggered()\n{\n  QPrintPreviewDialog dialog( &getPrinter(), this,\n                              Qt::WindowSystemMenuHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint );\n  dialog.restoreGeometry( cfg.printPreviewDialogGeometry );\n\n  connect( &dialog, SIGNAL( paintRequested( QPrinter * ) ),\n           this, SLOT( printPreviewPaintRequested( QPrinter * ) ) );\n\n  dialog.exec();\n  cfg.printPreviewDialogGeometry = dialog.saveGeometry();\n}\n\nvoid MainWindow::on_print_triggered()\n{\n  QPrintDialog dialog( &getPrinter(), this );\n\n  dialog.setWindowTitle( tr( \"Print Article\") );\n\n  if ( dialog.exec() != QDialog::Accepted )\n   return;\n\n  ArticleView *view = getCurrentArticleView();\n\n  view->print( &getPrinter() );\n}\n\nvoid MainWindow::printPreviewPaintRequested( QPrinter * printer )\n{\n  ArticleView *view = getCurrentArticleView();\n\n  view->print( printer );\n}\n\nstatic void filterAndCollectResources( QString & html, QRegExp & rx, const QString & sep,\n                                       const QString & folder, set< QByteArray > & resourceIncluded,\n                                       vector< pair< QUrl, QString > > & downloadResources )\n{\n  int pos = 0;\n  int queryNom = 1;\n\n  while ( ( pos = rx.indexIn( html, pos ) ) != -1 )\n  {\n    QUrl url( rx.cap( 1 ) );\n    QString host = url.host();\n    QString resourcePath = Qt4x5::Url::fullPath( url );\n\n    if ( !host.startsWith( '/' ) )\n      host.insert( 0, '/' );\n    if ( !resourcePath.startsWith( '/' ) )\n      resourcePath.insert( 0, '/' );\n\n    // Replase query part of url (if exist)\n    int n = resourcePath.indexOf( QLatin1Char( '?' ) );\n    if( n >= 0 )\n    {\n      QString q_str = QString( \"_q%1\" ).arg( queryNom );\n      resourcePath.replace( n, resourcePath.length() - n, q_str );\n      queryNom += 1;\n    }\n\n    QCryptographicHash hash( QCryptographicHash::Md5 );\n    hash.addData( rx.cap().toUtf8() );\n\n    if ( resourceIncluded.insert( hash.result() ).second )\n    {\n      // Gather resource information (url, filename) to be download later\n      downloadResources.push_back( pair<QUrl, QString>( url, folder + host + resourcePath ) );\n    }\n\n    // Modify original url, set to the native one\n    resourcePath = QString::fromLatin1( QUrl::toPercentEncoding( resourcePath, \"/\" ) );\n    QString newUrl = sep + QDir( folder ).dirName() + host + resourcePath + sep;\n    html.replace( pos, rx.cap().length(), newUrl );\n    pos += newUrl.length();\n  }\n}\n\nvoid MainWindow::on_saveArticle_triggered()\n{\n  ArticleView *view = getCurrentArticleView();\n\n  QString fileName = view->getTitle().simplified();\n\n  // Replace reserved filename characters\n  QRegExp rxName( \"[/\\\\\\\\\\\\?\\\\*:\\\\|<>]\" );\n  fileName.replace( rxName, \"_\" );\n\n  fileName += \".html\";\n  QString savePath;\n\n  if ( cfg.articleSavePath.isEmpty() )\n    savePath = QDir::homePath();\n  else\n  {\n    savePath = QDir::fromNativeSeparators( cfg.articleSavePath );\n    if ( !QDir( savePath ).exists() )\n      savePath = QDir::homePath();\n  }\n\n  QFileDialog::Options options = QFileDialog::HideNameFilterDetails;\n  QString selectedFilter;\n  QStringList filters;\n  filters.push_back( tr( \"Article, Complete (*.html)\" ) );\n  filters.push_back( tr( \"Article, HTML Only (*.html)\" ) );\n\n  fileName = savePath + \"/\" + fileName;\n  fileName = QFileDialog::getSaveFileName( this, tr(  \"Save Article As\" ),\n                                           fileName,\n                                           filters.join( \";;\" ),\n                                           &selectedFilter, options );\n\n  // The \" (*.html)\" part of filters[i] is absent from selectedFilter in Qt 5.\n  bool const complete = filters.at( 0 ).startsWith( selectedFilter );\n\n  if ( !fileName.isEmpty() )\n  {\n\n    QFile file( fileName );\n\n    if ( !file.open( QIODevice::WriteOnly ) )\n    {\n      QMessageBox::critical( this, tr( \"Error\" ),\n                             tr( \"Can't save article: %1\" ).arg( file.errorString() ) );\n    }\n    else\n    {\n      QString html = view->toHtml();\n      QFileInfo fi( fileName );\n      cfg.articleSavePath = QDir::toNativeSeparators( fi.absoluteDir().absolutePath() );\n\n      // Convert internal links\n\n      QRegExp rx3( \"href=\\\"(bword:|gdlookup://localhost/)([^\\\"]+)\\\"\" );\n      int pos = 0;\n      while ( ( pos = rx3.indexIn( html, pos ) ) != -1 )\n      {\n        QString name = QUrl::fromPercentEncoding( rx3.cap( 2 ).simplified().toLatin1() );\n        QString anchor;\n        name.replace( \"?gdanchor=\", \"#\" );\n        int n = name.indexOf( '#' );\n        if( n > 0 )\n        {\n          anchor = name.mid( n );\n          name.truncate( n );\n          anchor.replace( QRegExp( \"(g[0-9a-f]{32}_)[0-9a-f]+_\" ), \"\\\\1\" ); // MDict anchors\n        }\n        name.replace( rxName, \"_\" );\n        name = QString( \"href=\\\"\" ) + QUrl::toPercentEncoding( name ) + \".html\" + anchor + \"\\\"\";\n        html.replace( pos, rx3.cap().length(), name );\n        pos += name.length();\n      }\n\n      // MDict anchors\n      QRegExp anchorLinkRe( \"(<\\\\s*a\\\\s+[^>]*\\\\b(?:name|id)\\\\b\\\\s*=\\\\s*[\\\"']*g[0-9a-f]{32}_)([0-9a-f]+_)(?=[^\\\"'])\", Qt::CaseInsensitive );\n      html.replace( anchorLinkRe, \"\\\\1\" );\n\n      if ( complete )\n      {\n        QString folder = fi.absoluteDir().absolutePath() + \"/\" + fi.baseName() + \"_files\";\n        QRegExp rx1( \"\\\"((?:bres|gico|gdau|qrcx|gdvideo)://[^\\\"]+)\\\"\" );\n        QRegExp rx2( \"'((?:bres|gico|gdau|qrcx|gdvideo)://[^']+)'\" );\n        set< QByteArray > resourceIncluded;\n        vector< pair< QUrl, QString > > downloadResources;\n\n        filterAndCollectResources( html, rx1, \"\\\"\", folder, resourceIncluded, downloadResources );\n        filterAndCollectResources( html, rx2, \"'\", folder, resourceIncluded, downloadResources );\n\n        ArticleSaveProgressDialog * progressDialog = new ArticleSaveProgressDialog( this );\n        // reserve '1' for saving main html file\n        int maxVal = 1;\n\n        // Pull and save resources to files\n        for ( vector< pair< QUrl, QString > >::const_iterator i = downloadResources.begin();\n              i != downloadResources.end(); ++i )\n        {\n          ResourceToSaveHandler * handler = view->saveResource( i->first, i->second );\n          if( !handler->isEmpty() )\n          {\n            maxVal += 1;\n            connect( handler, SIGNAL( done() ), progressDialog, SLOT( perform() ) );\n          }\n        }\n\n        progressDialog->setLabelText( tr(\"Saving article...\") );\n        progressDialog->setRange( 0, maxVal );\n        progressDialog->setValue( 0 );\n        progressDialog->show();\n\n        file.write( html.toUtf8() );\n        progressDialog->setValue( 1 );\n      }\n      else\n      {\n        file.write( html.toUtf8() );\n      }\n    }\n  }\n}\n\nvoid MainWindow::on_rescanFiles_triggered()\n{\n  hotkeyWrapper.reset(); // No hotkeys while we're editing dictionaries\n  scanPopup.reset(); // No scan popup either. No one should use dictionaries.\n  closeHeadwordsDialog();\n  closeFullTextSearchDialog();\n\n  ftsIndexing.stopIndexing();\n  ftsIndexing.clearDictionaries();\n\n  groupInstances.clear(); // Release all the dictionaries they hold\n  dictionaries.clear();\n  dictionariesUnmuted.clear();\n  dictionaryBar.setDictionaries( dictionaries );\n\n  loadDictionaries( this, true, cfg, dictionaries, dictNetMgr );\n\n  for( unsigned x = 0; x < dictionaries.size(); x++ )\n  {\n    dictionaries[ x ]->setFTSParameters( cfg.preferences.fts );\n    dictionaries[ x ]->setSynonymSearchEnabled( cfg.preferences.synonymSearchEnabled );\n  }\n\n  ftsIndexing.setDictionaries( dictionaries );\n  ftsIndexing.doIndexing();\n\n  updateGroupList();\n\n  makeScanPopup();\n  installHotKeys();\n\n  updateSuggestionList();\n}\n\nvoid MainWindow::on_alwaysOnTop_triggered( bool checked )\n{\n    cfg.preferences.alwaysOnTop = checked;\n\n    bool wasVisible = isVisible();\n\n    Qt::WindowFlags flags = this->windowFlags();\n    if (checked)\n    {\n        setWindowFlags(flags | Qt::CustomizeWindowHint | Qt::WindowStaysOnTopHint);\n        mainStatusBar->showMessage(\n              tr( \"The main window is set to be always on top.\" ),\n              10000,\n              QPixmap( \":/icons/warning.png\" ) );\n    }\n    else\n    {\n        setWindowFlags(flags ^ (Qt::CustomizeWindowHint | Qt::WindowStaysOnTopHint));\n        mainStatusBar->clearMessage();\n    }\n\n    if ( wasVisible )\n    {\n      show();\n    }\n\n    installHotKeys();\n}\n\nvoid MainWindow::zoomin()\n{\n  cfg.preferences.zoomFactor += 0.1;\n  applyZoomFactor();\n}\n\nvoid MainWindow::zoomout()\n{\n  cfg.preferences.zoomFactor -= 0.1;\n  applyZoomFactor();\n}\n\nvoid MainWindow::unzoom()\n{\n  cfg.preferences.zoomFactor = 1;\n  applyZoomFactor();\n}\n\nvoid MainWindow::applyZoomFactor()\n{\n  // Always call this function synchronously to potentially disable a zoom action,\n  // which is being repeatedly triggered. When the action is disabled, its\n  // triggered() signal is no longer emitted, which in turn improves performance.\n  adjustCurrentZoomFactor();\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  // Scaling article views asynchronously dramatically improves performance when\n  // a zoom action is triggered repeatedly while many or large articles are open\n  // in the main window or in scan popup.\n  // Multiple zoom action signals are processed before (often slow) article view\n  // scaling is requested. Multiple scaling requests then ask for the same zoom factor,\n  // so all of them except for the first one don't change anything and run very fast.\n  // In effect, some intermediate zoom factors are skipped when scaling is slow.\n  // The slower the scaling, the more steps are skipped.\n  QTimer::singleShot( 0, this, SLOT( scaleArticlesByCurrentZoomFactor() ) );\n#else\n  // The timer trick above usually doesn't improve performance with Qt4\n  // due to a different ordering of keyboard and timer events.\n  // Sometimes, unpredictably, it does work like with Qt5.\n  // Scale article views synchronously to avoid inconsistent or unexpected behavior.\n  scaleArticlesByCurrentZoomFactor();\n#endif\n}\n\nvoid MainWindow::adjustCurrentZoomFactor()\n{\n  if ( cfg.preferences.zoomFactor >= 5 )\n    cfg.preferences.zoomFactor = 5;\n  else if ( cfg.preferences.zoomFactor <= 0.1 )\n    cfg.preferences.zoomFactor = 0.1;\n\n  zoomIn->setEnabled( cfg.preferences.zoomFactor < 5 );\n  zoomOut->setEnabled( cfg.preferences.zoomFactor > 0.1 );\n  zoomBase->setEnabled( cfg.preferences.zoomFactor != 1.0 );\n}\n\nvoid MainWindow::scaleArticlesByCurrentZoomFactor()\n{\n  for ( int i = 0; i < ui.tabWidget->count(); i++ )\n  {\n    ArticleView & view =\n      dynamic_cast< ArticleView & >( *( ui.tabWidget->widget(i) ) );\n    view.setZoomFactor( cfg.preferences.zoomFactor );\n  }\n\n  if ( scanPopup.get() )\n    scanPopup->applyZoomFactor();\n}\n\nvoid MainWindow::doWordsZoomIn()\n{\n  ++cfg.preferences.wordsZoomLevel;\n\n  applyWordsZoomLevel();\n}\n\nvoid MainWindow::doWordsZoomOut()\n{\n  --cfg.preferences.wordsZoomLevel;\n\n  applyWordsZoomLevel();\n}\n\nvoid MainWindow::doWordsZoomBase()\n{\n  cfg.preferences.wordsZoomLevel = 0;\n\n  applyWordsZoomLevel();\n}\n\nvoid MainWindow::applyWordsZoomLevel()\n{\n  QFont font( wordListDefaultFont );\n\n  int ps = font.pointSize();\n\n  if ( cfg.preferences.wordsZoomLevel != 0 )\n  {\n    ps += cfg.preferences.wordsZoomLevel;\n\n    if ( ps < 1 )\n      ps = 1;\n\n    font.setPointSize( ps );\n  }\n\n  if ( wordList->font().pointSize() != ps )\n    wordList->setFont( font );\n\n  font = translateLineDefaultFont;\n\n  ps = font.pointSize();\n\n  if ( cfg.preferences.wordsZoomLevel != 0 )\n  {\n    ps += cfg.preferences.wordsZoomLevel;\n\n    if ( ps < 1 )\n      ps = 1;\n\n    font.setPointSize( ps );\n  }\n\n  if ( translateLine->font().pointSize() != ps )\n    translateLine->setFont( font );\n\n  font = groupListDefaultFont;\n\n  ps = font.pointSize();\n\n  if ( cfg.preferences.wordsZoomLevel != 0 )\n  {\n    ps += cfg.preferences.wordsZoomLevel;\n\n    if ( ps < 1 )\n      ps = 1;\n\n    font.setPointSize( ps );\n  }\n\n  if ( groupList->font().pointSize() != ps )\n  {\n    disconnect( groupList, SIGNAL( currentIndexChanged( QString const & ) ),\n                this, SLOT( currentGroupChanged( QString const & ) ) );\n    int n = groupList->currentIndex();\n    groupList->clear();\n    groupList->setFont( font );\n    groupList->fill( groupInstances );\n    groupList->setCurrentIndex( n );\n    connect( groupList, SIGNAL( currentIndexChanged( QString const & ) ),\n             this, SLOT( currentGroupChanged( QString const & ) ) );\n  }\n\n  wordsZoomBase->setEnabled( cfg.preferences.wordsZoomLevel != 0 );\n\n  if( !cfg.preferences.searchInDock )\n  {\n    // Invalidating navToolbar's layout displays translateBoxWidget w/o the need to press the toolbar\n    // extension button when Words Zoom level decreases enough for translateBoxWidget to fit in the toolbar.\n    navToolbar->layout()->invalidate();\n  }\n\n  if ( scanPopup.get() )\n    scanPopup->applyWordsZoomLevel();\n}\n\nvoid MainWindow::messageFromAnotherInstanceReceived( QString const & message )\n{\n  if ( message == \"bringToFront\" )\n  {\n    toggleMainWindow( true );\n    return;\n  }\n  if( message == \"toggleScanPopup\" )\n  {\n    toggleScanPopup();\n    return;\n  }\n  if( message.left( 15 ) == \"translateWord: \" )\n  {\n    if( scanPopup.get() )\n      scanPopup->translateWord( message.mid( 15 ) );\n    else\n      wordReceived( message.mid( 15 ) );\n  }\n  else\n  if( message.left( 10 ) == \"setGroup: \" )\n  {\n    setGroupByName( message.mid( 10 ), true );\n  }\n  else\n  if( message.left( 15 ) == \"setPopupGroup: \" )\n  {\n    setGroupByName( message.mid( 15 ), false );\n  }\n  else\n    qWarning() << \"Unknown message received from another instance: \" << message;\n}\n\nArticleView * MainWindow::getCurrentArticleView()\n{\n  if ( QWidget * cw = ui.tabWidget->currentWidget() )\n  {\n    return dynamic_cast< ArticleView * >( cw );\n  }\n  return 0;\n}\n\nvoid MainWindow::phraseReceived( Config::InputPhrase const & phrase )\n{\n  toggleMainWindow( true );\n  setTranslateBoxTextAndKeepSuffix( phrase.phrase, EscapeWildcards, NoPopupChange );\n  translateBoxSuffix = phrase.punctuationSuffix;\n  respondToTranslationRequest( phrase, false );\n}\n\nvoid MainWindow::wordReceived( const QString & word)\n{\n  phraseReceived( Config::InputPhrase::fromPhrase( word ) );\n}\n\nvoid MainWindow::headwordReceived( const QString & word, const QString & ID )\n{\n  toggleMainWindow( true );\n  setTranslateBoxTextAndClearSuffix( word, EscapeWildcards, NoPopupChange );\n  respondToTranslationRequest( Config::InputPhrase::fromPhrase( word ),\n                               false, ArticleView::scrollToFromDictionaryId( ID ) );\n}\n\nvoid MainWindow::updateFavoritesMenu()\n{\n  if ( ui.favoritesPane->toggleViewAction()->isChecked() )\n  {\n    ui.showHideFavorites->setText( tr( \"&Hide\" ) );\n  }\n  else\n  {\n    ui.showHideFavorites->setText( tr( \"&Show\" ) );\n  }\n}\n\nvoid MainWindow::updateHistoryMenu()\n{\n  if ( ui.historyPane->toggleViewAction()->isChecked() )\n  {\n    ui.showHideHistory->setText( tr( \"&Hide\" ) );\n  }\n  else\n  {\n    ui.showHideHistory->setText( tr( \"&Show\" ) );\n  }\n}\n\nvoid MainWindow::on_showHideFavorites_triggered()\n{\n  ui.favoritesPane->toggleViewAction()->trigger();\n  ui.favoritesPane->raise(); // useful when the Pane is tabbed.\n}\n\nvoid MainWindow::on_showHideHistory_triggered()\n{\n  ui.historyPane->toggleViewAction()->trigger();\n  ui.historyPane->raise(); // useful when the Pane is tabbed.\n}\n\nvoid MainWindow::on_exportHistory_triggered()\n{\n    QString exportPath;\n    if( cfg.historyExportPath.isEmpty() )\n        exportPath = QDir::homePath();\n    else\n    {\n        exportPath = QDir::fromNativeSeparators( cfg.historyExportPath );\n        if( !QDir( exportPath ).exists() )\n            exportPath = QDir::homePath();\n    }\n\n    QString fileName = QFileDialog::getSaveFileName( this, tr( \"Export history to file\" ),\n                                                     exportPath,\n                                                     tr( \"Text files (*.txt);;All files (*.*)\" ) );\n    if( fileName.size() == 0)\n        return;\n\n    cfg.historyExportPath = QDir::toNativeSeparators( QFileInfo( fileName ).absoluteDir().absolutePath() );\n    QFile file( fileName );\n\n    for(;;)\n    {\n        if ( !file.open( QFile::WriteOnly | QIODevice::Text ) )\n          break;\n\n        // Write UTF-8 BOM\n        QByteArray line;\n        line.append( 0xEF ).append( 0xBB ).append( 0xBF );\n        if ( file.write( line ) != line.size() )\n          break;\n\n        // Write history\n        QList< History::Item > const & items = history.getItems();\n\n        QList< History::Item >::const_iterator i;\n        for( i = items.constBegin(); i != items.constEnd(); ++i )\n        {\n          line = i->word.toUtf8();\n\n          line.replace( '\\n', ' ' );\n          line.replace( '\\r', ' ' );\n\n          line += \"\\n\";\n\n          if ( file.write( line ) != line.size() )\n            break;\n        }\n\n        if( i != items.constEnd() )\n          break;\n\n        file.close();\n        mainStatusBar->showMessage( tr( \"History export complete\" ), 5000 );\n        return;\n    }\n    QString errStr = QString( tr( \"Export error: \" ) ) + file.errorString();\n    file.close();\n    mainStatusBar->showMessage( errStr, 10000, QPixmap( \":/icons/error.png\" ) );\n}\n\n// TODO: consider moving parts of this method into History class.\nvoid MainWindow::on_importHistory_triggered()\n{\n    QString importPath;\n    if( cfg.historyExportPath.isEmpty() )\n        importPath = QDir::homePath();\n    else\n    {\n        importPath = QDir::fromNativeSeparators( cfg.historyExportPath );\n        if( !QDir( importPath ).exists() )\n            importPath = QDir::homePath();\n    }\n\n    QString fileName = QFileDialog::getOpenFileName( this, tr( \"Import history from file\" ),\n                                                     importPath,\n                                                     tr( \"Text files (*.txt);;All files (*.*)\" ) );\n    if( fileName.size() == 0)\n        return;\n\n    QFileInfo fileInfo( fileName );\n    cfg.historyExportPath = QDir::toNativeSeparators( fileInfo.absoluteDir().absolutePath() );\n    QString errStr;\n    QFile file( fileName );\n\n    for(;;)\n    {\n        if ( !file.open( QFile::ReadOnly | QIODevice::Text ) )\n          break;\n\n        QTextStream fileStream( & file );\n        QString itemStr, trimmedStr;\n        QList< QString > itemList;\n\n        history.clear();\n\n        do\n        {\n            itemStr = fileStream.readLine();\n            if( fileStream.status() >= QTextStream::ReadCorruptData )\n                break;\n\n            trimmedStr = itemStr.trimmed();\n            if( trimmedStr.isEmpty() )\n                continue;\n\n            if( (unsigned)trimmedStr.size() <= history.getMaxItemLength( ) )\n                itemList.prepend( trimmedStr );\n\n        } while( !fileStream.atEnd() && itemList.size() < (int)history.getMaxSize() );\n\n        history.enableAdd( true );\n\n        for( QList< QString >::const_iterator i = itemList.constBegin(); i != itemList.constEnd(); ++i )\n            history.addItem( History::Item( 1, *i ) );\n\n        history.enableAdd( cfg.preferences.storeHistory );\n\n        if( file.error() != QFile::NoError )\n            break;\n\n        if( fileStream.status() >= QTextStream::ReadCorruptData )\n        {\n            errStr = QString ( tr( \"Import error: invalid data in file\" ) );\n            mainStatusBar->showMessage( errStr, 10000, QPixmap( \":/icons/error.png\" ) );\n        }\n        else\n            mainStatusBar->showMessage( tr( \"History import complete\" ), 5000 );\n        return;\n    }\n    errStr = QString( tr( \"Import error: \" ) ) + file.errorString();\n    file.close();\n    mainStatusBar->showMessage( errStr, 10000, QPixmap( \":/icons/error.png\" ) );\n}\n\nvoid MainWindow::on_exportFavorites_triggered()\n{\n  QString exportPath;\n  if( cfg.historyExportPath.isEmpty() )\n    exportPath = QDir::homePath();\n  else\n  {\n    exportPath = QDir::fromNativeSeparators( cfg.historyExportPath );\n    if( !QDir( exportPath ).exists() )\n      exportPath = QDir::homePath();\n  }\n\n  QString fileName = QFileDialog::getSaveFileName( this, tr( \"Export Favorites to file\" ),\n                                                   exportPath,\n                                                   tr( \"XML files (*.xml);;All files (*.*)\" ) );\n  if( fileName.size() == 0)\n    return;\n\n  cfg.historyExportPath = QDir::toNativeSeparators( QFileInfo( fileName ).absoluteDir().absolutePath() );\n  QFile file( fileName );\n\n  for(;;)\n  {\n    if ( !file.open( QFile::WriteOnly | QIODevice::Text ) )\n      break;\n\n    QByteArray data;\n    ui.favoritesPaneWidget->getDataInXml( data );\n\n    if( file.write( data ) != data.size() )\n      break;\n\n    file.close();\n    mainStatusBar->showMessage( tr( \"Favorites export complete\" ), 5000 );\n    return;\n  }\n  QString errStr = QString( tr( \"Export error: \" ) ) + file.errorString();\n  file.close();\n  mainStatusBar->showMessage( errStr, 10000, QPixmap( \":/icons/error.png\" ) );\n}\n\nvoid MainWindow::on_ExportFavoritesToList_triggered()\n{\n  QString exportPath;\n  if( cfg.historyExportPath.isEmpty() )\n    exportPath = QDir::homePath();\n  else\n  {\n    exportPath = QDir::fromNativeSeparators( cfg.historyExportPath );\n    if( !QDir( exportPath ).exists() )\n      exportPath = QDir::homePath();\n  }\n\n  QString fileName = QFileDialog::getSaveFileName( this, tr( \"Export Favorites to file as plain list\" ),\n                                                   exportPath,\n                                                   tr( \"Text files (*.txt);;All files (*.*)\" ) );\n  if( fileName.size() == 0)\n    return;\n\n  cfg.historyExportPath = QDir::toNativeSeparators( QFileInfo( fileName ).absoluteDir().absolutePath() );\n  QFile file( fileName );\n\n  for(;;)\n  {\n    if ( !file.open( QFile::WriteOnly | QIODevice::Text ) )\n      break;\n\n    // Write UTF-8 BOM\n    QByteArray line;\n    line.append( 0xEF ).append( 0xBB ).append( 0xBF );\n    if ( file.write( line ) != line.size() )\n      break;\n\n    // Write Favorites\n    QString data;\n    ui.favoritesPaneWidget->getDataInPlainText( data );\n\n    line = data.toUtf8();\n    if( file.write( line ) != line.size() )\n      break;\n\n    file.close();\n    mainStatusBar->showMessage( tr( \"Favorites export complete\" ), 5000 );\n    return;\n  }\n  QString errStr = QString( tr( \"Export error: \" ) ) + file.errorString();\n  file.close();\n  mainStatusBar->showMessage( errStr, 10000, QPixmap( \":/icons/error.png\" ) );\n}\n\nvoid MainWindow::on_importFavorites_triggered()\n{\n  QString importPath;\n  if( cfg.historyExportPath.isEmpty() )\n    importPath = QDir::homePath();\n  else\n  {\n    importPath = QDir::fromNativeSeparators( cfg.historyExportPath );\n    if( !QDir( importPath ).exists() )\n      importPath = QDir::homePath();\n  }\n\n  QString fileName = QFileDialog::getOpenFileName( this, tr( \"Import Favorites from file\" ),\n                                                   importPath,\n                                                   tr( \"XML files (*.xml);;All files (*.*)\" ) );\n  if( fileName.size() == 0)\n    return;\n\n  QFileInfo fileInfo( fileName );\n  cfg.historyExportPath = QDir::toNativeSeparators( fileInfo.absoluteDir().absolutePath() );\n  QString errStr;\n  QFile file( fileName );\n\n  for(;;)\n  {\n    if ( !file.open( QFile::ReadOnly | QIODevice::Text ) )\n      break;\n\n    if( file.error() != QFile::NoError )\n        break;\n\n    QByteArray data = file.readAll();\n\n    if( !ui.favoritesPaneWidget->setDataFromXml( QString::fromUtf8( data.data(), data.size() ) ) )\n      break;\n\n    file.close();\n    mainStatusBar->showMessage( tr( \"Favorites import complete\" ), 5000 );\n    return;\n  }\n  if( file.error() != QFile::NoError )\n    errStr = QString( tr( \"Import error: \" ) ) + file.errorString();\n  else\n    errStr = QString( tr( \"Data parsing error\" ) );\n\n  file.close();\n  mainStatusBar->showMessage( errStr, 10000, QPixmap( \":/icons/error.png\" ) );\n}\n\nvoid MainWindow::fillWordListFromHistory()\n{\n    ui.wordList->setUpdatesEnabled( false );\n    ui.wordList->clear();\n\n    QList< History::Item > const & items = history.getItems();\n    for( int x = 0; x < items.size(); ++x )\n    {\n      History::Item const * i = &items[ x ];\n      QListWidgetItem * s = new QListWidgetItem( i->word, ui.wordList );\n      if (s->text().at(0).direction() == QChar::DirR)\n          s->setTextAlignment(Qt::AlignRight);\n      if (s->text().at(0).direction() == QChar::DirL)\n          s->setTextAlignment(Qt::AlignLeft);\n      ui.wordList->addItem( s );\n    }\n\n    ui.wordList->setUpdatesEnabled( true );\n}\n\nvoid MainWindow::focusWordList()\n{\n    if( ui.wordList->count() > 0 )\n        ui.wordList->setFocus();\n}\n\nvoid MainWindow::addWordToHistory( const QString & word )\n{\n  history.addItem( History::Item( 1, word.trimmed() ) );\n}\n\nvoid MainWindow::forceAddWordToHistory( const QString & word )\n{\n    history.enableAdd( true );\n    history.addItem( History::Item( 1, word.trimmed() ) );\n    history.enableAdd( cfg.preferences.storeHistory );\n}\n\nvoid MainWindow::setExpandMode( bool expand )\n{\n  articleMaker.setExpandOptionalParts( expand );\n}\n\nvoid MainWindow::switchExpandOptionalPartsMode()\n{\n  ArticleView * view = getCurrentArticleView();\n  if( view )\n    view->switchExpandOptionalParts();\n}\n\nvoid MainWindow::foundDictsPaneClicked( QListWidgetItem * item )\n{\n  Qt::KeyboardModifiers m = QApplication::keyboardModifiers();\n  if ( ( m & ( Qt::ControlModifier | Qt::ShiftModifier ) )\n       || ( m == Qt::AltModifier ) )\n  {\n    QString id = item->data( Qt::UserRole ).toString();\n    emit clickOnDictPane( id );\n  }\n}\n\nvoid MainWindow::showDictionaryInfo( const QString & id )\n{\n  QWidget * owner = 0;\n\n  if( sender()->objectName().compare( \"EditDictionaries\" ) == 0 )\n    owner = qobject_cast< QWidget * >( sender() );\n\n  if( owner == 0 )\n    owner = this;\n\n  for( unsigned x = 0; x < dictionaries.size(); x++ )\n  {\n    if( dictionaries[ x ]->getId() == id.toUtf8().data() )\n    {\n      DictInfo infoMsg( cfg, this );\n      infoMsg.showInfo( dictionaries[ x ] );\n      int result = infoMsg.exec();\n\n      if ( result == DictInfo::OPEN_FOLDER )\n      {\n        openDictionaryFolder( id );\n      }\n      else if ( result == DictInfo::EDIT_DICTIONARY)\n      {\n        editDictionary( dictionaries[x].get() );\n      }\n      else if( result == DictInfo::SHOW_HEADWORDS )\n      {\n        showDictionaryHeadwords( owner, dictionaries[x].get() );\n      }\n\n      break;\n    }\n  }\n}\n\nvoid MainWindow::showDictionaryHeadwords( const QString & id )\n{\n  QWidget * owner = 0;\n\n  if( sender()->objectName().compare( \"EditDictionaries\" ) == 0 )\n    owner = qobject_cast< QWidget * >( sender() );\n\n  if( owner == 0 )\n    owner = this;\n\n  for( unsigned x = 0; x < dictionaries.size(); x++ )\n  {\n    if( dictionaries[ x ]->getId() == id.toUtf8().data() )\n    {\n      showDictionaryHeadwords( owner, dictionaries[ x ].get() );\n      break;\n    }\n  }\n}\n\nvoid MainWindow::showDictionaryHeadwords( QWidget * owner, Dictionary::Class * dict )\n{\n  if( owner && owner != this )\n  {\n    DictHeadwords headwords( owner, cfg, dict );\n    headwords.exec();\n    return;\n  }\n\n  if( headwordsDlg == 0 )\n  {\n    headwordsDlg = new DictHeadwords( this, cfg, dict );\n    addGlobalActionsToDialog( headwordsDlg );\n    addGroupComboBoxActionsToDialog( headwordsDlg, groupList );\n    connect( headwordsDlg, SIGNAL( headwordSelected( QString, QString ) ),\n             this, SLOT( headwordReceived( QString, QString ) ) );\n    connect( headwordsDlg, SIGNAL( closeDialog() ),\n             this, SLOT( closeHeadwordsDialog() ), Qt::QueuedConnection );\n  }\n  else\n    headwordsDlg->setup( dict );\n\n  headwordsDlg->show();\n}\n\nvoid MainWindow::closeHeadwordsDialog()\n{\n  if( headwordsDlg )\n  {\n    delete headwordsDlg;\n    headwordsDlg = NULL;\n  }\n}\n\nvoid MainWindow::focusHeadwordsDialog()\n{\n  if( headwordsDlg )\n  {\n    headwordsDlg->activateWindow();\n    if ( ftsDlg )\n      ftsDlg->lower();\n  }\n}\n\nvoid MainWindow::focusArticleView()\n{\n  ArticleView * view = getCurrentArticleView();\n  if ( view )\n  {\n    if ( !isActiveWindow() )\n      activateWindow();\n    view->focus();\n  }\n}\n\nvoid MainWindow::editDictionary( Dictionary::Class * dict )\n{\n  QString dictFilename = dict->getMainFilename();\n  if( !cfg.editDictionaryCommandLine.isEmpty() && !dictFilename.isEmpty() )\n  {\n    QString command( cfg.editDictionaryCommandLine );\n    command.replace( \"%GDDICT%\", \"\\\"\" + dictFilename + \"\\\"\" );\n    if( command.contains( \"%GDWORD%\" ) )\n    {\n      QString headword = unescapeTabHeader( ui.tabWidget->tabText( ui.tabWidget->currentIndex() ) );\n      command.replace( \"%GDWORD%\", headword );\n    }\n    if( !Qt4x5::Process::startDetached( command ) )\n      QApplication::beep();\n  }\n}\n\n\nvoid MainWindow::openDictionaryFolder( const QString & id )\n{\n  for( unsigned x = 0; x < dictionaries.size(); x++ )\n  {\n    if( dictionaries[ x ]->getId() == id.toUtf8().data() )\n    {\n      if( dictionaries[ x ]->getDictionaryFilenames().size() > 0 )\n      {\n        QString fileName = FsEncoding::decode( dictionaries[ x ]->getDictionaryFilenames()[ 0 ].c_str() );\n        bool explorerLaunched = false;\n\n        // Platform-dependent way to launch a file explorer and to select a file,\n        // currently only on Windows.\n#if defined(Q_OS_WIN)\n        if ( !QFileInfo( fileName ).isDir() )\n        {\n          QString param = QLatin1String(\"explorer.exe \")\n              + QLatin1String(\"/select, \\\"\") + QDir::toNativeSeparators( fileName ) + QLatin1String(\"\\\"\");\n\n          qDebug() << \"Launching\" << param;\n\n          // We use CreateProcess() directly instead of QProcess::startDetached() since\n          // startDetached() does some evil things with quotes breaking explorer arguments.\n          // E.g., the following file cannot be properly selected via startDetached(), due to equals sign,\n          // which explorer considers as separator:\n          // Z:\\GoldenDict\\content\\-=MDict=-\\Test.mdx\n          PROCESS_INFORMATION pinfo;\n          STARTUPINFOW startupInfo = { sizeof( STARTUPINFO ), 0, 0, 0,\n                                       (ulong)CW_USEDEFAULT, (ulong)CW_USEDEFAULT,\n                                       (ulong)CW_USEDEFAULT, (ulong)CW_USEDEFAULT,\n                                       0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n                                     };\n          explorerLaunched = CreateProcess(0, (wchar_t*) param.utf16(),\n                                           0, 0, FALSE, CREATE_UNICODE_ENVIRONMENT | CREATE_NEW_CONSOLE, 0,\n                                           0, &startupInfo, &pinfo);\n\n          if ( explorerLaunched ) {\n            CloseHandle( pinfo.hThread );\n            CloseHandle( pinfo.hProcess );\n          }\n        }\n#endif\n\n        if ( !explorerLaunched )\n        {\n          QString folder = QFileInfo( fileName ).absoluteDir().absolutePath();\n          if( !folder.isEmpty() )\n            QDesktopServices::openUrl( QUrl::fromLocalFile( folder ) );\n        }\n      }\n      break;\n    }\n  }\n}\n\nvoid MainWindow::foundDictsContextMenuRequested( const QPoint &pos )\n{\n  QListWidgetItem *item = ui.dictsList->itemAt( pos );\n  if( item )\n  {\n    QString id = item->data( Qt::UserRole ).toString();\n    Dictionary::Class *pDict = NULL;\n\n    for( unsigned i = 0; i < dictionaries.size(); i++ )\n    {\n      if( id.compare( dictionaries[ i ]->getId().c_str() ) == 0 )\n      {\n        pDict = dictionaries[ i ].get();\n        break;\n      }\n    }\n\n    if( pDict == NULL )\n      return;\n\n    if( !pDict->isLocalDictionary() )\n    {\n      if ( scanPopup )\n        scanPopup.get()->blockSignals( true );\n      showDictionaryInfo( id );\n      if ( scanPopup )\n        scanPopup.get()->blockSignals( false );\n    }\n    else\n    {\n      QMenu menu( ui.dictsList );\n      QAction * infoAction = menu.addAction( tr( \"Dictionary info\" ) );\n\n      QAction * headwordsAction = NULL;\n      if( pDict->getWordCount() > 0 )\n        headwordsAction = menu.addAction( tr( \"Dictionary headwords\" ) );\n\n      QAction * openDictFolderAction = menu.addAction( tr( \"Open dictionary folder\" ) );\n\n      QAction * editAction = NULL;\n\n      QString dictFilename = pDict->getMainFilename();\n      if( !cfg.editDictionaryCommandLine.isEmpty() && !dictFilename.isEmpty() )\n        editAction = menu.addAction( tr( \"Edit dictionary\" ) );\n\n      QAction * result = menu.exec( ui.dictsList->mapToGlobal( pos ) );\n\n      if( result && result == infoAction )\n      {\n        if ( scanPopup )\n          scanPopup.get()->blockSignals( true );\n        showDictionaryInfo( id );\n        if ( scanPopup )\n          scanPopup.get()->blockSignals( false );\n      }\n      else\n      if( result && result == headwordsAction )\n      {\n        if ( scanPopup )\n          scanPopup.get()->blockSignals( true );\n        showDictionaryHeadwords( this, pDict );\n        if ( scanPopup )\n          scanPopup.get()->blockSignals( false );\n      }\n      else\n      if( result && result == openDictFolderAction )\n      {\n        openDictionaryFolder( id );\n      }\n      else\n      if( result && result == editAction )\n      {\n        editDictionary( pDict );\n      }\n    }\n  }\n}\n\nvoid MainWindow::sendWordToInputLine( const QString & word )\n{\n  setTranslateBoxTextAndClearSuffix( word, EscapeWildcards, NoPopupChange );\n}\n\nvoid MainWindow::storeResourceSavePath( const QString & newPath )\n{\n  cfg.resourceSavePath = newPath;\n}\n\nvoid MainWindow::proxyAuthentication( const QNetworkProxy &,\n                                      QAuthenticator * authenticator )\n{\n  QNetworkProxy proxy = QNetworkProxy::applicationProxy();\n\n  QString * userStr, * passwordStr;\n  if( cfg.preferences.proxyServer.useSystemProxy )\n  {\n    userStr = &cfg.preferences.proxyServer.systemProxyUser;\n    passwordStr = &cfg.preferences.proxyServer.systemProxyPassword;\n  }\n  else\n  {\n    userStr = &cfg.preferences.proxyServer.user;\n    passwordStr = &cfg.preferences.proxyServer.password;\n  }\n\n  if( proxy.user().isEmpty() && !userStr->isEmpty() )\n  {\n    authenticator->setUser( *userStr );\n    authenticator->setPassword( *passwordStr );\n\n    proxy.setUser( *userStr );\n    proxy.setPassword( *passwordStr );\n    QNetworkProxy::setApplicationProxy( proxy );\n  }\n  else\n  {\n    QDialog dlg;\n    Ui::Dialog ui;\n    ui.setupUi( &dlg );\n    dlg.adjustSize();\n\n    ui.userEdit->setText( *userStr );\n    ui.passwordEdit->setText( *passwordStr );\n\n    if ( dlg.exec() == QDialog::Accepted )\n    {\n      *userStr = ui.userEdit->text();\n      *passwordStr = ui.passwordEdit->text();\n\n      authenticator->setUser( *userStr );\n      authenticator->setPassword( *passwordStr );\n\n      proxy.setUser( *userStr );\n      proxy.setPassword( *passwordStr );\n      QNetworkProxy::setApplicationProxy( proxy );\n    }\n  }\n}\n\nvoid MainWindow::showFullTextSearchDialog()\n{\n  if( !ftsDlg )\n  {\n    ftsDlg = new FTS::FullTextSearchDialog( this, cfg, dictionaries, groupInstances, ftsIndexing );\n    addGlobalActionsToDialog( ftsDlg );\n    addGroupComboBoxActionsToDialog( ftsDlg, groupList );\n\n    connect( ftsDlg, SIGNAL( showTranslationFor( QString, QStringList, QRegExp, bool ) ),\n             this, SLOT( showTranslationFor( QString, QStringList, QRegExp, bool ) ) );\n    connect( ftsDlg, SIGNAL( closeDialog() ),\n             this, SLOT( closeFullTextSearchDialog() ), Qt::QueuedConnection );\n    connect( &configEvents, SIGNAL( mutedDictionariesChanged() ),\n             ftsDlg, SLOT( updateDictionaries() ) );\n\n    unsigned group = groupInstances.empty() ? 0\n                                            : groupInstances[ groupList->currentIndex() ].id;\n    ftsDlg->setCurrentGroup( group );\n  }\n\n  if( !ftsDlg ->isVisible() )\n    ftsDlg->show();\n  else\n  {\n    ftsDlg->activateWindow();\n    if ( headwordsDlg )\n      headwordsDlg->lower();\n  }\n}\n\nvoid MainWindow::closeFullTextSearchDialog()\n{\n  if( ftsDlg )\n  {\n    ftsDlg->stopSearch();\n    delete ftsDlg;\n    ftsDlg = 0;\n  }\n}\n\nvoid MainWindow::showGDHelp()\n{\n  if( !helpWindow )\n  {\n    helpWindow = new Help::HelpWindow( this, cfg );\n\n    if( helpWindow->getHelpEngine() )\n    {\n      connect( helpWindow, SIGNAL( needClose() ), this, SLOT( hideGDHelp() ) );\n      helpWindow->showHelpFor( \"Content\" );\n      helpWindow->show();\n    }\n    else\n    {\n      delete helpWindow;\n      helpWindow = 0;\n    }\n  }\n  else\n  {\n    helpWindow->show();\n    helpWindow->activateWindow();\n  }\n}\n\nvoid MainWindow::hideGDHelp()\n{\n  if( helpWindow )\n    helpWindow->hide();\n}\n\nvoid MainWindow::showGDHelpForID( QString const & id )\n{\n  if( !helpWindow )\n    showGDHelp();\n\n  if( helpWindow )\n  {\n    helpWindow->showHelpFor( id );\n    if( !helpWindow->isVisible() )\n    {\n      helpWindow->show();\n      helpWindow->activateWindow();\n    }\n  }\n}\n\nvoid MainWindow::closeGDHelp()\n{\n  if( helpWindow )\n  {\n    delete helpWindow;\n    helpWindow = 0;\n  }\n}\n\nvoid MainWindow::showFTSIndexingName( QString const & name )\n{\n  if( name.isEmpty() )\n    mainStatusBar->setBackgroundMessage( QString() );\n  else\n    mainStatusBar->setBackgroundMessage( tr( \"Now indexing for full-text search: \" ) + name );\n}\n\nQString MainWindow::unescapeTabHeader(QString const & header )\n{\n  // Reset table header to original headword\n\n  QString escaped = header;\n  escaped.replace( \"&&\", \"&\" );\n  if( escaped.startsWith( QChar( 0x202E ) ) )\n    escaped = escaped.mid( 1 );\n  if( escaped.endsWith( QChar( 0x202C ) ) )\n    escaped.chop( 1 );\n\n  return escaped;\n}\n\nQString MainWindow::tabFavoritesFolder( int tabNom )\n{\n  QString folder;\n  unsigned groupId = 0;\n  ArticleView * view = 0;\n\n  QWidget * cw = ui.tabWidget->widget( tabNom );\n  if ( cw )\n    view = dynamic_cast< ArticleView * >( cw );\n\n  if( view )\n    groupId = view->getViewGroup();\n  if( groupId == 0 )\n    groupId = cfg.lastMainGroupId;\n\n  Instances::Group const * igrp = groupInstances.findGroup( groupId );\n  if( igrp )\n    folder = igrp->favoritesFolder;\n\n  return folder;\n}\n\nvoid MainWindow::addCurrentTabToFavorites()\n{\n  QString headword = ui.tabWidget->tabText( ui.tabWidget->currentIndex() );\n\n  ui.favoritesPaneWidget->addHeadword( tabFavoritesFolder( ui.tabWidget->currentIndex() ), unescapeTabHeader( headword ) );\n\n  addToFavorites->setIcon( blueStarIcon );\n  addToFavorites->setToolTip( tr( \"Remove current tab from Favorites\" ) );\n}\n\nvoid MainWindow::handleAddToFavoritesButton()\n{\n  QString folder = tabFavoritesFolder( ui.tabWidget->currentIndex() );\n  QString headword = unescapeTabHeader( ui.tabWidget->tabText( ui.tabWidget->currentIndex() ) );\n\n  if( ui.favoritesPaneWidget->isHeadwordPresent( folder, headword ) )\n  {\n    QMessageBox mb( QMessageBox::Question, \"GoldenDict\", tr( \"Remove headword \\\"%1\\\" from Favorites?\" ).arg( headword ),\n                    QMessageBox::Yes | QMessageBox::No, this );\n    if( mb.exec() == QMessageBox::Yes )\n    {\n      if( ui.favoritesPaneWidget->removeHeadword( folder, headword ) )\n      {\n        addToFavorites->setIcon( starIcon );\n        addToFavorites->setToolTip( tr( \"Add current tab to Favorites\" ) );\n      }\n    }\n  }\n  else\n  {\n    ui.favoritesPaneWidget->addHeadword( folder, headword );\n    addToFavorites->setIcon( blueStarIcon );\n    addToFavorites->setToolTip( tr( \"Remove current tab from Favorites\" ) );\n  }\n}\n\nvoid MainWindow::addWordToFavorites( QString const & word, unsigned groupId )\n{\n  QString folder;\n  Instances::Group const * igrp = groupInstances.findGroup( groupId );\n  if( igrp )\n    folder = igrp->favoritesFolder;\n\n  ui.favoritesPaneWidget->addHeadword( folder, word );\n}\n\nvoid MainWindow::addAllTabsToFavorites()\n{\n  for( int i = 0; i < ui.tabWidget->count(); i++ )\n  {\n    QString headword = ui.tabWidget->tabText( i );\n    ui.favoritesPaneWidget->addHeadword( tabFavoritesFolder( i ), unescapeTabHeader( headword ) );\n  }\n  addToFavorites->setIcon( blueStarIcon );\n  addToFavorites->setToolTip( tr( \"Remove current tab from Favorites\" ) );\n}\n\nbool MainWindow::isWordPresentedInFavorites( QString const & word, unsigned groupId )\n{\n  QString folder;\n  Instances::Group const * igrp = groupInstances.findGroup( groupId );\n  if( igrp )\n    folder = igrp->favoritesFolder;\n\n  return ui.favoritesPaneWidget->isHeadwordPresent( folder, word );\n}\n\nvoid MainWindow::toggleScanPopup()\n{\n  enableScanPopup->toggle();\n}\n\nvoid MainWindow::setGroupByName( QString const & name, bool main_window )\n{\n  if( main_window )\n  {\n    int i;\n    for( i = 0; i < groupList->count(); i++ )\n    {\n      if( groupList->itemText( i ) == name )\n      {\n        groupList->setCurrentIndex( i );\n        break;\n      }\n    }\n    if( i >= groupList->count() )\n      gdWarning( \"Group \\\"%s\\\" for main window is not found\\n\", name.toUtf8().data() );\n  }\n  else\n  {\n    emit setPopupGroupByName( name );\n  }\n}\n\nvoid MainWindow::headwordFromFavorites( QString const & headword,\n                                        QString const & favoritesFolder )\n{\n  if( !favoritesFolder.isEmpty() )\n  {\n    // Find group by it Favorites folder\n    for( Instances::Groups::size_type i = 0; i < groupInstances.size(); i++ )\n    {\n      if( groupInstances[ i ].favoritesFolder == favoritesFolder )\n      {\n        // Group found. Select it and stop search.\n        if( groupList->currentIndex() != (int)i )\n        {\n          groupList->setCurrentIndex( i );\n\n          // Restore focus on Favorites tree\n          ui.favoritesPaneWidget->setFocusOnTree();\n        }\n        break;\n      }\n    }\n  }\n\n  // Show headword without lost of focus on Favorites tree\n  setTranslateBoxTextAndClearSuffix( headword, EscapeWildcards, DisablePopup );\n  showTranslationFor(headword );\n}\n\n#ifdef Q_OS_WIN32\n\nbool MainWindow::handleGDMessage( MSG * message, long * result )\n{\n  if( message->message != gdAskMessage )\n    return false;\n  *result = 0;\n\n  if( !isGoldenDictWindow( message->hwnd ) )\n    return true;\n\n  ArticleView * view = getCurrentArticleView();\n  if( !view )\n    return true;\n\n  LPGDDataStruct lpdata = ( LPGDDataStruct ) message->lParam;\n\n  QString str = view->wordAtPoint( lpdata->Pt.x, lpdata->Pt.y );\n\n  memset( lpdata->cwData, 0, lpdata->dwMaxLength * sizeof( WCHAR ) );\n  str.truncate( lpdata->dwMaxLength - 1 );\n  str.toWCharArray( lpdata->cwData );\n\n  *result = 1;\n  return true;\n}\n\nbool MainWindow::isGoldenDictWindow( HWND hwnd )\n{\n  return hwnd == (HWND)winId() || hwnd == (HWND)ui.centralWidget->winId();\n}\n\n#endif\n\n#ifdef X11_MAIN_WINDOW_FOCUS_WORKAROUNDS\n#include \"mainwindow.moc\"\n#endif\n"
        },
        {
          "name": "mainwindow.hh",
          "type": "blob",
          "size": 16.2587890625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __MAINWINDOW_HH_INCLUDED__\n#define __MAINWINDOW_HH_INCLUDED__\n\n#include <QMainWindow>\n#include <QThread>\n#include <QToolButton>\n#include <QSystemTrayIcon>\n#include <QNetworkAccessManager>\n#include <QProgressDialog>\n#include \"ui_mainwindow.h\"\n#include \"folding.hh\"\n#include \"config.hh\"\n#include \"dictionary.hh\"\n#include \"article_netmgr.hh\"\n#include \"audioplayerfactory.hh\"\n#include \"instances.hh\"\n#include \"article_maker.hh\"\n#include \"scanpopup.hh\"\n#include \"articleview.hh\"\n#include \"wordfinder.hh\"\n#include \"dictionarybar.hh\"\n#include \"history.hh\"\n#include \"mainstatusbar.hh\"\n#include \"mruqmenu.hh\"\n#include \"translatebox.hh\"\n#include \"wordlist.hh\"\n#include \"dictheadwords.hh\"\n#include \"fulltextsearch.hh\"\n#include \"helpwindow.hh\"\n\n#include \"hotkeywrapper.hh\"\n#ifdef HAVE_X11\n#include <fixx11h.h>\n#endif\n\n#ifdef HAVE_X11\n  // TODO: implement startup notification support and remove these workarounds\n  // (see investigation comments on #781).\n  #define X11_MAIN_WINDOW_FOCUS_WORKAROUNDS\n#endif\n\nusing std::string;\nusing std::vector;\n\nclass ExpandableToolBar : public QToolBar\n{\n  Q_OBJECT\n\npublic:\n  explicit ExpandableToolBar(QString const & title, QWidget * parent = 0)\n    : QToolBar(title, parent) {}\n  virtual QSize sizeHint() const\n  {\n    if ( !isFloating() && parentWidget() )\n    {\n      return QSize( parentWidget()->width(), QToolBar::sizeHint().height() );\n    }\n    else\n    {\n      return QToolBar::sizeHint();\n    }\n  }\n};\n\nclass MainWindow: public QMainWindow, public DataCommitter\n{\n  Q_OBJECT\n\npublic:\n\n  MainWindow( Config::Class & cfg );\n  ~MainWindow();\n\n  virtual void commitData( QSessionManager & );\n\n  void showGDHelpForID( QString const & id );\n  void closeGDHelp();\n  QString getTranslateLineText() const\n  { return translateLine->text(); }\n\n  void toggleScanPopup();\n\n  /// Set group for main/popup window\n  void setGroupByName( QString const & name, bool main_window );\n\npublic slots:\n\n  void messageFromAnotherInstanceReceived( QString const & );\n  void showStatusBarMessage ( QString const &, int, QPixmap const & );\n  void phraseReceived( Config::InputPhrase const & );\n  void wordReceived( QString const & );\n  void headwordReceived( QString const &, QString const & );\n  void setExpandMode( bool expand );\n  void headwordFromFavorites( QString const &, QString const & );\n  void quitApp();\n\nprivate:\n  void addGlobalAction( QAction * action, const char * slot );\n  void addGlobalActionsToDialog( QDialog * dialog );\n  void addGroupComboBoxActionsToDialog( QDialog * dialog, GroupComboBox * pGroupComboBox );\n  void removeGroupComboBoxActionsFromDialog( QDialog * dialog, GroupComboBox * pGroupComboBox );\n\n  void commitData();\n\n  QSystemTrayIcon * trayIcon;\n\n  Ui::MainWindow ui;\n\n  /// This widget is used as a title bar for the searchPane dock, and\n  /// incorporates the next three objects inside\n  QWidget searchPaneTitleBar;\n  QHBoxLayout searchPaneTitleBarLayout;\n  QLabel groupLabel;\n  GroupComboBox * groupList, * groupListInToolbar, * groupListInDock;\n\n  // Needed to be able to show/hide the translate box in the toolbar, since hiding\n  // the list expilictily doesn't work, see docs for QToolBar::addWidget().\n  QAction * translateBoxToolBarAction;\n\n  QWidget dictsPaneTitleBar;\n  QHBoxLayout dictsPaneTitleBarLayout;\n  QLabel foundInDictsLabel;\n\n  TranslateBox * translateBox;\n\n  /// Fonts saved before words zooming is in effect, so it could be reset back.\n  QFont wordListDefaultFont, translateLineDefaultFont, groupListDefaultFont;\n\n  QAction escAction, focusTranslateLineAction, addTabAction, closeCurrentTabAction,\n          closeAllTabAction, closeRestTabAction,\n          switchToNextTabAction, switchToPrevTabAction,\n          showDictBarNamesAction, useSmallIconsInToolbarsAction, toggleMenuBarAction,\n          switchExpandModeAction, focusHeadwordsDlgAction, focusArticleViewAction,\n          addAllTabToFavoritesAction;\n  QToolBar * navToolbar;\n  MainStatusBar * mainStatusBar;\n  QAction * navBack, * navForward, * navPronounce, * enableScanPopup;\n  QAction * beforeScanPopupSeparator, * afterScanPopupSeparator, * beforeOptionsSeparator;\n  QAction * zoomIn, * zoomOut, * zoomBase;\n  QAction * wordsZoomIn, * wordsZoomOut, * wordsZoomBase;\n  QAction * addToFavorites, * beforeAddToFavoritesSeparator;\n  QMenu trayIconMenu;\n  QMenu * tabMenu;\n  QAction * menuButtonAction;\n  QToolButton * menuButton;\n  MRUQMenu *tabListMenu;\n  //List that contains indexes of tabs arranged in a most-recently-used order\n  QList<QWidget*> mruList;\n  QToolButton addTab, *tabListButton;\n  Config::Class & cfg;\n  Config::Events configEvents;\n  History history;\n  DictionaryBar dictionaryBar;\n  vector< sptr< Dictionary::Class > > dictionaries;\n  /// Here we store unmuted dictionaries when the dictionary bar is active\n  vector< sptr< Dictionary::Class > > dictionariesUnmuted;\n  Instances::Groups groupInstances;\n  ArticleMaker articleMaker;\n  ArticleNetworkAccessManager articleNetMgr;\n  QNetworkAccessManager dictNetMgr; // We give dictionaries a separate manager,\n                                    // since their requests can be destroyed\n                                    // in a separate thread\n  AudioPlayerFactory audioPlayerFactory;\n\n  WordList * wordList;\n  QLineEdit * translateLine;\n  QString translateBoxSuffix; ///< A punctuation suffix that corresponds to translateLine's text.\n\n  WordFinder wordFinder;\n\n  sptr< ScanPopup > scanPopup;\n\n  sptr< HotkeyWrapper > hotkeyWrapper;\n\n  QTimer newReleaseCheckTimer; // Countdown to a check for the new program\n                               // release, if enabled\n  QNetworkReply *latestReleaseReply;\n\n  sptr< QPrinter > printer; // The printer we use for all printing operations\n\n  bool wordListSelChanged;\n\n  bool wasMaximized; // Window state before minimization\n\n  bool blockUpdateWindowTitle;\n\n  QPrinter & getPrinter(); // Creates a printer if it's not there and returns it\n\n  DictHeadwords * headwordsDlg;\n\n  FTS::FtsIndexing ftsIndexing;\n\n  FTS::FullTextSearchDialog * ftsDlg;\n\n  Help::HelpWindow * helpWindow;\n\n  QIcon starIcon, blueStarIcon;\n\n  /// Applies the qt's stylesheet, given the style's name.\n  void applyQtStyleSheet( QString const & displayStyle, QString const & addonStyle );\n\n  /// Creates, destroys or otherwise updates tray icon, according to the\n  /// current configuration and situation.\n  void updateTrayIcon();\n\n  void wheelEvent( QWheelEvent * );\n  void closeEvent( QCloseEvent * );\n\n  void applyProxySettings();\n  void applyWebSettings();\n  void setupNetworkCache( int maxSize );\n  void makeDictionaries();\n  void updateStatusLine();\n  void updateGroupList();\n  void updateDictionaryBar();\n  void makeScanPopup();\n\n  void updatePronounceAvailability();\n\n  void updateFoundInDictsList();\n\n  void updateBackForwardButtons();\n\n  void updateWindowTitle();\n\n  /// Updates word search request and active article view in response to\n  /// muting or unmuting dictionaries, or showing/hiding dictionary bar.\n  void applyMutedDictionariesState();\n\n  virtual bool eventFilter( QObject *, QEvent * );\n\n  /// Returns the reference to dictionaries stored in the currently active\n  /// group, or to all dictionaries if there are no groups.\n  vector< sptr< Dictionary::Class > > const & getActiveDicts();\n\n  /// Brings the main window to front if it's not currently, or hides it\n  /// otherwise. The hiding part is omitted if onlyShow is true.\n#ifdef X11_MAIN_WINDOW_FOCUS_WORKAROUNDS\n  void toggleMainWindow( bool onlyShow = false, bool byIconClick = false );\n#else\n  void toggleMainWindow( bool onlyShow = false );\n#endif\n\n  /// Creates hotkeyWrapper and hooks the currently set keys for it\n  void installHotKeys();\n\n  void applyZoomFactor();\n  void adjustCurrentZoomFactor();\n\n  void mousePressEvent ( QMouseEvent * event );\n\n  void updateCurrentGroupProperty();\n\n  /// Handles backward and forward mouse buttons and\n  /// returns true if the event is handled.\n  bool handleBackForwardMouseButtons(QMouseEvent *ev);\n\n  ArticleView * getCurrentArticleView();\n  void ctrlTabPressed();\n\n  void fillWordListFromHistory();\n\n  void showDictionaryHeadwords( QWidget * owner, Dictionary::Class * dict );\n\n  QString unescapeTabHeader( QString const & header );\n\n  void respondToTranslationRequest( Config::InputPhrase const & phrase,\n                                    bool checkModifiers, QString const & scrollTo = QString() );\n\n  void updateSuggestionList();\n  void updateSuggestionList( QString const & text );\n\n  enum WildcardPolicy { EscapeWildcards, WildcardsAreAlreadyEscaped };\n  enum TranslateBoxPopup { NoPopupChange, EnablePopup, DisablePopup };\n  void setTranslateBoxTextAndKeepSuffix( QString text, WildcardPolicy wildcardPolicy,\n                                         TranslateBoxPopup popupAction );\n  void setTranslateBoxTextAndClearSuffix( QString const & text, WildcardPolicy wildcardPolicy,\n                                          TranslateBoxPopup popupAction );\n\n  QString tabFavoritesFolder( int tabNom );\n\nprivate slots:\n\n#ifdef X11_MAIN_WINDOW_FOCUS_WORKAROUNDS\n  void forceX11Focus();\n#endif\n\n  void hotKeyActivated( int );\n\n  /// If new release checks are on, santizies the next check time and starts\n  /// the timer. Does nothing otherwise.\n  void prepareNewReleaseChecks();\n\nprivate slots:\n\n  /// Does the new release check.\n  void checkForNewRelease();\n\n  /// Signalled when the lastestReleaseReply is finished()\n  void latestReleaseReplyReady();\n\n  /// Receive click on \"Found in:\" pane\n  void foundDictsPaneClicked( QListWidgetItem * item );\n\n  /// Receive right click on \"Found in:\" pane\n  void foundDictsContextMenuRequested( const QPoint & pos );\n\n  void showDictionaryInfo( QString const & id );\n\n  void showDictionaryHeadwords( QString const & id );\n\n  void openDictionaryFolder( QString const & id );\n\n  void editDictionary ( Dictionary::Class * dict );\n\n  void showFTSIndexingName( QString const & name );\n\n  void handleAddToFavoritesButton();\n\n  void addCurrentTabToFavorites();\n\n  void addAllTabsToFavorites();\n\nprivate slots:\n\n  // Executed in response to a user click on an 'add tab' tool button\n  void addNewTab();\n  // Executed in response to a user click on an 'close' button on a tab\n  void tabCloseRequested( int );\n  // Closes current tab.\n  void closeCurrentTab();\n  void closeAllTabs();\n  void closeRestTabs();\n  void switchToNextTab();\n  void switchToPrevTab();\n  void ctrlReleased();\n\n  // Switch optional parts expand mode for current tab\n  void switchExpandOptionalPartsMode();\n\n  // Handling of active tab list\n  void createTabList();\n  void fillWindowsMenu();\n  void switchToWindow(QAction *act);\n\n  /// Triggered by the actions in the nav toolbar\n  void backClicked();\n  void forwardClicked();\n\n  /// ArticleView's title has changed\n  void titleChanged( ArticleView *, QString const & );\n  /// ArticleView's icon has changed\n  void iconChanged( ArticleView *, QIcon const & );\n\n  void pageLoaded( ArticleView * );\n  void tabSwitched( int );\n  void tabMenuRequested(QPoint pos);\n\n  void dictionaryBarToggled( bool checked );\n\n  /// Pronounces the currently displayed word by playing its first audio\n  /// reference, if it has any.\n  /// If view is 0, the operation is done for the currently open tab.\n  void pronounce( ArticleView * view = 0 );\n\n  void zoomin();\n  void zoomout();\n  void unzoom();\n\n  void scaleArticlesByCurrentZoomFactor();\n\n  void doWordsZoomIn();\n  void doWordsZoomOut();\n  void doWordsZoomBase();\n\n  void applyWordsZoomLevel();\n\n  /// If editDictionaryGroup is specified, the dialog positions on that group\n  /// initially.\n  void editDictionaries( unsigned editDictionaryGroup = Instances::Group::NoGroupId );\n  /// Edits current group when triggered from the dictionary bar.\n  void editCurrentGroup();\n  void editPreferences();\n\n  void currentGroupChanged( QString const & );\n  void translateInputChanged( QString const & );\n  void translateInputFinished( bool checkModifiers = true );\n\n  /// Closes any opened search in the article view, and focuses the translateLine/close main window to tray.\n  void handleEsc();\n\n  /// Gives the keyboard focus to the translateLine and selects all the text\n  /// it has.\n  void focusTranslateLine();\n\n  void wordListItemActivated( QListWidgetItem * );\n  void wordListSelectionChanged();\n\n  void dictsListItemActivated( QListWidgetItem * );\n  void dictsListSelectionChanged();\n\n  void jumpToDictionary( QListWidgetItem *, bool force = false );\n\n  void showDictsPane( );\n  void dictsPaneVisibilityChanged ( bool );\n\n  /// Creates a new tab, which is to be populated then with some content.\n  ArticleView * createNewTab( bool switchToIt,\n                              QString const & name );\n\n  void openLinkInNewTab( QUrl const &, QUrl const &, QString const &,\n                         ArticleView::Contexts const & contexts );\n  void showDefinitionInNewTab( QString const & word, unsigned group,\n                               QString const & fromArticle,\n                               ArticleView::Contexts const & contexts );\n  void typingEvent( QString const & );\n\n  void activeArticleChanged( ArticleView const *, QString const & id );\n\n  void mutedDictionariesChanged();\n\n  void showTranslationFor( Config::InputPhrase const &, unsigned inGroup = 0,\n                           QString const & scrollTo = QString() );\n  void showTranslationFor( QString const & );\n\n  void showTranslationFor( QString const &, QStringList const & dictIDs,\n                           QRegExp const & searchRegExp, bool ignoreDiacritics );\n\n  void showHistoryItem( QString const & );\n\n  void trayIconActivated( QSystemTrayIcon::ActivationReason );\n\n  void scanEnableToggled( bool );\n\n  void setAutostart( bool );\n\n  void showMainWindow();\n\n  void visitHomepage();\n  void visitForum();\n  void openConfigFolder();\n  void showAbout();\n\n  void showDictBarNamesTriggered();\n  void useSmallIconsInToolbarsTriggered();\n  void toggleMenuBarTriggered( bool announce = true );\n\n  void on_clearHistory_triggered();\n\n  void on_newTab_triggered();\n\n  void on_actionCloseToTray_triggered();\n\n  void on_pageSetup_triggered();\n  void on_printPreview_triggered();\n  void on_print_triggered();\n  void printPreviewPaintRequested( QPrinter * );\n\n  void on_saveArticle_triggered();\n\n  void on_rescanFiles_triggered();\n\n  void on_showHideFavorites_triggered();\n  void on_showHideHistory_triggered();\n  void on_exportHistory_triggered();\n  void on_importHistory_triggered();\n  void on_alwaysOnTop_triggered( bool checked );\n  void focusWordList();\n\n  void on_exportFavorites_triggered();\n  void on_importFavorites_triggered();\n  void on_ExportFavoritesToList_triggered();\n\n  void updateSearchPaneAndBar( bool searchInDock );\n\n  void updateFavoritesMenu();\n  void updateHistoryMenu();\n\n  /// Add word to history\n  void addWordToHistory( const QString & word );\n  /// Add word to history even if history is disabled in options\n  void forceAddWordToHistory( const QString & word);\n\n  void addWordToFavorites( QString const & word, unsigned groupId );\n\n  bool isWordPresentedInFavorites( QString const & word, unsigned groupId );\n\n  void sendWordToInputLine( QString const & word );\n\n  void storeResourceSavePath( QString const & );\n\n  void closeHeadwordsDialog();\n\n  void focusHeadwordsDialog();\n\n  void focusArticleView();\n\n  void proxyAuthentication( const QNetworkProxy & proxy, QAuthenticator * authenticator );\n\n  void showFullTextSearchDialog();\n  void closeFullTextSearchDialog();\n\n  void showGDHelp();\n  void hideGDHelp();\n\nsignals:\n  /// Set optional parts expand mode for all tabs\n  void setExpandOptionalParts( bool expand );\n\n  /// Retranslate Ctrl(Shift) + Click on dictionary pane to dictionary toolbar\n  void clickOnDictPane( QString const & id );\n\n  /// Set group for popup window\n  void setPopupGroupByName( QString const & name );\n\n#ifdef Q_OS_WIN32\n  /// For receiving message from scan libraries\nprotected:\n  unsigned gdAskMessage;\npublic:\n  bool handleGDMessage( MSG * message, long * result );\n\nprivate slots:\n  /// Return true while scanning GoldenDict window\n  bool isGoldenDictWindow( HWND hwnd );\n#endif\n};\n\nclass ArticleSaveProgressDialog : public QProgressDialog\n{\nQ_OBJECT\n\npublic:\n  explicit ArticleSaveProgressDialog( QWidget * parent = 0,  Qt::WindowFlags f = Qt::WindowFlags() ):\n    QProgressDialog( parent, f )\n  {\n    setAutoReset( false );\n    setAutoClose( false );\n  }\n\npublic slots:\n  void perform()\n  {\n    int progress = value() + 1;\n    if ( progress == maximum() )\n    {\n      emit close();\n      deleteLater();\n    }\n    setValue( progress );\n  }\n};\n\n#endif\n"
        },
        {
          "name": "mainwindow.ui",
          "type": "blob",
          "size": 19.078125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ui version=\"4.0\">\n <class>MainWindow</class>\n <widget class=\"QMainWindow\" name=\"MainWindow\">\n  <property name=\"geometry\">\n   <rect>\n    <x>0</x>\n    <y>0</y>\n    <width>653</width>\n    <height>538</height>\n   </rect>\n  </property>\n  <property name=\"windowTitle\">\n   <string notr=\"true\">GoldenDict</string>\n  </property>\n  <widget class=\"QWidget\" name=\"centralWidget\">\n   <layout class=\"QHBoxLayout\" name=\"horizontalLayout_2\">\n    <property name=\"leftMargin\">\n     <number>1</number>\n    </property>\n    <property name=\"topMargin\">\n     <number>2</number>\n    </property>\n    <property name=\"rightMargin\">\n     <number>1</number>\n    </property>\n    <property name=\"bottomMargin\">\n     <number>0</number>\n    </property>\n    <item>\n     <widget class=\"MainTabWidget\" name=\"tabWidget\">\n      <property name=\"currentIndex\">\n       <number>0</number>\n      </property>\n      <property name=\"iconSize\">\n       <size>\n        <width>16</width>\n        <height>16</height>\n       </size>\n      </property>\n      <property name=\"elideMode\">\n       <enum>Qt::ElideRight</enum>\n      </property>\n      <widget class=\"QWidget\" name=\"tab\">\n       <attribute name=\"title\">\n        <string>Welcome!</string>\n       </attribute>\n       <layout class=\"QHBoxLayout\" name=\"horizontalLayout_4\">\n        <property name=\"leftMargin\">\n         <number>0</number>\n        </property>\n        <property name=\"topMargin\">\n         <number>0</number>\n        </property>\n        <property name=\"rightMargin\">\n         <number>0</number>\n        </property>\n        <property name=\"bottomMargin\">\n         <number>0</number>\n        </property>\n       </layout>\n      </widget>\n     </widget>\n    </item>\n   </layout>\n  </widget>\n  <widget class=\"QMenuBar\" name=\"menubar\">\n   <property name=\"geometry\">\n    <rect>\n     <x>0</x>\n     <y>0</y>\n     <width>653</width>\n     <height>18</height>\n    </rect>\n   </property>\n   <widget class=\"QMenu\" name=\"menuFile\">\n    <property name=\"title\">\n     <string>&amp;File</string>\n    </property>\n    <addaction name=\"newTab\"/>\n    <addaction name=\"separator\"/>\n    <addaction name=\"pageSetup\"/>\n    <addaction name=\"printPreview\"/>\n    <addaction name=\"print\"/>\n    <addaction name=\"separator\"/>\n    <addaction name=\"saveArticle\"/>\n    <addaction name=\"separator\"/>\n    <addaction name=\"rescanFiles\"/>\n    <addaction name=\"separator\"/>\n    <addaction name=\"actionCloseToTray\"/>\n    <addaction name=\"quit\"/>\n   </widget>\n   <widget class=\"QMenu\" name=\"menu_Edit\">\n    <property name=\"title\">\n     <string>&amp;Edit</string>\n    </property>\n    <addaction name=\"dictionaries\"/>\n    <addaction name=\"preferences\"/>\n   </widget>\n   <widget class=\"QMenu\" name=\"menu_Help\">\n    <property name=\"title\">\n     <string>&amp;Help</string>\n    </property>\n    <addaction name=\"showReference\"/>\n    <addaction name=\"separator\"/>\n    <addaction name=\"visitHomepage\"/>\n    <addaction name=\"visitForum\"/>\n    <addaction name=\"separator\"/>\n    <addaction name=\"openConfigFolder\"/>\n    <addaction name=\"separator\"/>\n    <addaction name=\"about\"/>\n   </widget>\n   <widget class=\"QMenu\" name=\"menuView\">\n    <property name=\"title\">\n     <string>&amp;View</string>\n    </property>\n    <widget class=\"QMenu\" name=\"menuZoom\">\n     <property name=\"title\">\n      <string>&amp;Zoom</string>\n     </property>\n    </widget>\n    <addaction name=\"menuZoom\"/>\n   </widget>\n   <widget class=\"QMenu\" name=\"menuHistory\">\n    <property name=\"title\">\n     <string>H&amp;istory</string>\n    </property>\n    <addaction name=\"showHideHistory\"/>\n    <addaction name=\"exportHistory\"/>\n    <addaction name=\"importHistory\"/>\n    <addaction name=\"separator\"/>\n    <addaction name=\"clearHistory\"/>\n   </widget>\n   <widget class=\"QMenu\" name=\"menuSearch\">\n    <property name=\"title\">\n     <string>Search</string>\n    </property>\n    <addaction name=\"searchInPageAction\"/>\n    <addaction name=\"fullTextSearchAction\"/>\n   </widget>\n   <widget class=\"QMenu\" name=\"menuFavorites\">\n    <property name=\"title\">\n     <string>Favo&amp;rites</string>\n    </property>\n    <addaction name=\"showHideFavorites\"/>\n    <addaction name=\"exportFavorites\"/>\n    <addaction name=\"ExportFavoritesToList\"/>\n    <addaction name=\"importFavorites\"/>\n    <addaction name=\"separator\"/>\n    <addaction name=\"actionAddToFavorites\"/>\n   </widget>\n   <addaction name=\"menuFile\"/>\n   <addaction name=\"menuView\"/>\n   <addaction name=\"menu_Edit\"/>\n   <addaction name=\"menuSearch\"/>\n   <addaction name=\"menuHistory\"/>\n   <addaction name=\"menuFavorites\"/>\n   <addaction name=\"menu_Help\"/>\n  </widget>\n  <widget class=\"QDockWidget\" name=\"searchPane\">\n   <property name=\"windowTitle\">\n    <string>&amp;Search Pane</string>\n   </property>\n   <attribute name=\"dockWidgetArea\">\n    <number>1</number>\n   </attribute>\n   <widget class=\"SearchPaneWidget\" name=\"searchPaneWidget\">\n    <property name=\"sizePolicy\">\n     <sizepolicy hsizetype=\"Preferred\" vsizetype=\"Preferred\">\n      <horstretch>0</horstretch>\n      <verstretch>0</verstretch>\n     </sizepolicy>\n    </property>\n    <layout class=\"QVBoxLayout\" name=\"verticalLayout\">\n     <property name=\"leftMargin\">\n      <number>2</number>\n     </property>\n     <property name=\"topMargin\">\n      <number>1</number>\n     </property>\n     <property name=\"rightMargin\">\n      <number>2</number>\n     </property>\n     <property name=\"bottomMargin\">\n      <number>1</number>\n     </property>\n     <item>\n      <widget class=\"QLineEdit\" name=\"translateLine\">\n       <property name=\"minimumSize\">\n        <size>\n         <width>200</width>\n         <height>0</height>\n        </size>\n       </property>\n       <property name=\"baseSize\">\n        <size>\n         <width>0</width>\n         <height>0</height>\n        </size>\n       </property>\n       <property name=\"palette\">\n        <palette>\n         <active>\n          <colorrole role=\"Base\">\n           <brush brushstyle=\"SolidPattern\">\n            <color alpha=\"255\">\n             <red>254</red>\n             <green>253</green>\n             <blue>235</blue>\n            </color>\n           </brush>\n          </colorrole>\n         </active>\n         <inactive>\n          <colorrole role=\"Base\">\n           <brush brushstyle=\"SolidPattern\">\n            <color alpha=\"255\">\n             <red>254</red>\n             <green>253</green>\n             <blue>235</blue>\n            </color>\n           </brush>\n          </colorrole>\n         </inactive>\n         <disabled>\n          <colorrole role=\"Base\">\n           <brush brushstyle=\"SolidPattern\">\n            <color alpha=\"255\">\n             <red>255</red>\n             <green>255</green>\n             <blue>255</blue>\n            </color>\n           </brush>\n          </colorrole>\n         </disabled>\n        </palette>\n       </property>\n       <property name=\"frame\">\n        <bool>true</bool>\n       </property>\n      </widget>\n     </item>\n     <item>\n      <widget class=\"WordList\" name=\"wordList\">\n       <property name=\"palette\">\n        <palette>\n         <active>\n          <colorrole role=\"Base\">\n           <brush brushstyle=\"SolidPattern\">\n            <color alpha=\"255\">\n             <red>254</red>\n             <green>253</green>\n             <blue>235</blue>\n            </color>\n           </brush>\n          </colorrole>\n         </active>\n         <inactive>\n          <colorrole role=\"Base\">\n           <brush brushstyle=\"SolidPattern\">\n            <color alpha=\"255\">\n             <red>254</red>\n             <green>253</green>\n             <blue>235</blue>\n            </color>\n           </brush>\n          </colorrole>\n         </inactive>\n         <disabled>\n          <colorrole role=\"Base\">\n           <brush brushstyle=\"SolidPattern\">\n            <color alpha=\"255\">\n             <red>255</red>\n             <green>255</green>\n             <blue>255</blue>\n            </color>\n           </brush>\n          </colorrole>\n         </disabled>\n        </palette>\n       </property>\n      </widget>\n     </item>\n    </layout>\n   </widget>\n  </widget>\n  <widget class=\"QDockWidget\" name=\"dictsPane\">\n   <property name=\"windowTitle\">\n    <string>&amp;Results Navigation Pane</string>\n   </property>\n   <attribute name=\"dockWidgetArea\">\n    <number>2</number>\n   </attribute>\n   <widget class=\"DictsPaneWidget\" name=\"dictsPaneWidget\">\n    <layout class=\"QVBoxLayout\" name=\"verticalLayout_2\">\n     <property name=\"leftMargin\">\n      <number>2</number>\n     </property>\n     <property name=\"topMargin\">\n      <number>1</number>\n     </property>\n     <property name=\"rightMargin\">\n      <number>2</number>\n     </property>\n     <property name=\"bottomMargin\">\n      <number>1</number>\n     </property>\n     <item>\n      <widget class=\"QListWidget\" name=\"dictsList\"/>\n     </item>\n    </layout>\n   </widget>\n  </widget>\n  <widget class=\"QDockWidget\" name=\"favoritesPane\">\n   <property name=\"windowTitle\">\n    <string>Favor&amp;ites Pane</string>\n   </property>\n   <attribute name=\"dockWidgetArea\">\n    <number>2</number>\n   </attribute>\n   <widget class=\"FavoritesPaneWidget\" name=\"favoritesPaneWidget\">\n    <layout class=\"QVBoxLayout\" name=\"verticalLayout_3\">\n     <property name=\"leftMargin\">\n      <number>2</number>\n     </property>\n     <property name=\"topMargin\">\n      <number>1</number>\n     </property>\n     <property name=\"rightMargin\">\n      <number>2</number>\n     </property>\n     <property name=\"bottomMargin\">\n      <number>1</number>\n     </property>\n     <item>\n      <widget class=\"TreeView\" name=\"favoritesTree\"/>\n     </item>\n    </layout>\n   </widget>\n  </widget>\n  <widget class=\"QDockWidget\" name=\"historyPane\">\n   <property name=\"windowTitle\">\n    <string>&amp;History Pane</string>\n   </property>\n   <attribute name=\"dockWidgetArea\">\n    <number>2</number>\n   </attribute>\n   <widget class=\"HistoryPaneWidget\" name=\"historyPaneWidget\">\n    <layout class=\"QVBoxLayout\" name=\"verticalLayout_4\">\n     <property name=\"spacing\">\n      <number>2</number>\n     </property>\n     <property name=\"leftMargin\">\n      <number>2</number>\n     </property>\n     <property name=\"topMargin\">\n      <number>1</number>\n     </property>\n     <property name=\"rightMargin\">\n      <number>2</number>\n     </property>\n     <property name=\"bottomMargin\">\n      <number>1</number>\n     </property>\n     <item>\n      <widget class=\"QListView\" name=\"historyList\"/>\n     </item>\n    </layout>\n   </widget>\n  </widget>\n  <action name=\"dictionaries\">\n   <property name=\"icon\">\n    <iconset resource=\"resources.qrc\">\n     <normaloff>:/icons/book.png</normaloff>:/icons/book.png</iconset>\n   </property>\n   <property name=\"text\">\n    <string>&amp;Dictionaries...</string>\n   </property>\n   <property name=\"shortcut\">\n    <string>F3</string>\n   </property>\n   <property name=\"menuRole\">\n    <enum>QAction::NoRole</enum>\n   </property>\n  </action>\n  <action name=\"preferences\">\n   <property name=\"icon\">\n    <iconset resource=\"resources.qrc\">\n     <normaloff>:/icons/configure.png</normaloff>:/icons/configure.png</iconset>\n   </property>\n   <property name=\"text\">\n    <string>&amp;Preferences...</string>\n   </property>\n   <property name=\"shortcut\">\n    <string>F4</string>\n   </property>\n   <property name=\"menuRole\">\n    <enum>QAction::PreferencesRole</enum>\n   </property>\n  </action>\n  <action name=\"visitHomepage\">\n   <property name=\"text\">\n    <string>&amp;Homepage</string>\n   </property>\n   <property name=\"menuRole\">\n    <enum>QAction::NoRole</enum>\n   </property>\n  </action>\n  <action name=\"about\">\n   <property name=\"text\">\n    <string>&amp;About</string>\n   </property>\n   <property name=\"toolTip\">\n    <string>About GoldenDict</string>\n   </property>\n   <property name=\"menuRole\">\n    <enum>QAction::AboutRole</enum>\n   </property>\n  </action>\n  <action name=\"quit\">\n   <property name=\"text\">\n    <string>&amp;Quit</string>\n   </property>\n   <property name=\"toolTip\">\n    <string>Quit from application</string>\n   </property>\n   <property name=\"shortcut\">\n    <string>Ctrl+Q</string>\n   </property>\n   <property name=\"menuRole\">\n    <enum>QAction::QuitRole</enum>\n   </property>\n  </action>\n  <action name=\"visitForum\">\n   <property name=\"text\">\n    <string>&amp;Forum</string>\n   </property>\n   <property name=\"menuRole\">\n    <enum>QAction::NoRole</enum>\n   </property>\n  </action>\n  <action name=\"actionCloseToTray\">\n   <property name=\"text\">\n    <string>&amp;Close To Tray</string>\n   </property>\n   <property name=\"toolTip\">\n    <string>Minimizes the window to tray</string>\n   </property>\n   <property name=\"shortcut\">\n    <string>Ctrl+F4</string>\n   </property>\n   <property name=\"menuRole\">\n    <enum>QAction::NoRole</enum>\n   </property>\n  </action>\n  <action name=\"saveArticle\">\n   <property name=\"icon\">\n    <iconset resource=\"resources.qrc\">\n     <normaloff>:/icons/filesave.png</normaloff>:/icons/filesave.png</iconset>\n   </property>\n   <property name=\"text\">\n    <string>&amp;Save Article</string>\n   </property>\n   <property name=\"toolTip\">\n    <string>Save Article</string>\n   </property>\n   <property name=\"shortcut\">\n    <string>F2</string>\n   </property>\n   <property name=\"menuRole\">\n    <enum>QAction::NoRole</enum>\n   </property>\n  </action>\n  <action name=\"print\">\n   <property name=\"icon\">\n    <iconset resource=\"resources.qrc\">\n     <normaloff>:/icons/print.png</normaloff>:/icons/print.png</iconset>\n   </property>\n   <property name=\"text\">\n    <string>&amp;Print</string>\n   </property>\n   <property name=\"shortcut\">\n    <string>Ctrl+P</string>\n   </property>\n   <property name=\"menuRole\">\n    <enum>QAction::NoRole</enum>\n   </property>\n  </action>\n  <action name=\"pageSetup\">\n   <property name=\"text\">\n    <string>Page Set&amp;up</string>\n   </property>\n   <property name=\"menuRole\">\n    <enum>QAction::NoRole</enum>\n   </property>\n  </action>\n  <action name=\"printPreview\">\n   <property name=\"text\">\n    <string>Print Pre&amp;view</string>\n   </property>\n   <property name=\"menuRole\">\n    <enum>QAction::NoRole</enum>\n   </property>\n  </action>\n  <action name=\"rescanFiles\">\n   <property name=\"text\">\n    <string>&amp;Rescan Files</string>\n   </property>\n   <property name=\"shortcut\">\n    <string>Ctrl+F5</string>\n   </property>\n   <property name=\"menuRole\">\n    <enum>QAction::NoRole</enum>\n   </property>\n  </action>\n  <action name=\"clearHistory\">\n   <property name=\"text\">\n    <string>&amp;Clear</string>\n   </property>\n   <property name=\"menuRole\">\n    <enum>QAction::NoRole</enum>\n   </property>\n  </action>\n  <action name=\"newTab\">\n   <property name=\"icon\">\n    <iconset resource=\"resources.qrc\">\n     <normaloff>:/icons/addtab.png</normaloff>:/icons/addtab.png</iconset>\n   </property>\n   <property name=\"text\">\n    <string>&amp;New Tab</string>\n   </property>\n   <property name=\"shortcut\">\n    <string>Ctrl+T</string>\n   </property>\n   <property name=\"shortcutContext\">\n    <enum>Qt::WidgetShortcut</enum>\n   </property>\n   <property name=\"menuRole\">\n    <enum>QAction::NoRole</enum>\n   </property>\n  </action>\n  <action name=\"openConfigFolder\">\n   <property name=\"text\">\n    <string>&amp;Configuration Folder</string>\n   </property>\n   <property name=\"menuRole\">\n    <enum>QAction::NoRole</enum>\n   </property>\n  </action>\n  <action name=\"showHideHistory\">\n   <property name=\"text\">\n    <string>&amp;Show</string>\n   </property>\n   <property name=\"shortcut\">\n    <string>Ctrl+H</string>\n   </property>\n   <property name=\"menuRole\">\n    <enum>QAction::NoRole</enum>\n   </property>\n  </action>\n  <action name=\"exportHistory\">\n   <property name=\"text\">\n    <string>&amp;Export</string>\n   </property>\n   <property name=\"menuRole\">\n    <enum>QAction::NoRole</enum>\n   </property>\n  </action>\n  <action name=\"importHistory\">\n   <property name=\"text\">\n    <string>&amp;Import</string>\n   </property>\n   <property name=\"menuRole\">\n    <enum>QAction::NoRole</enum>\n   </property>\n  </action>\n  <action name=\"alwaysOnTop\">\n   <property name=\"checkable\">\n    <bool>true</bool>\n   </property>\n   <property name=\"text\">\n    <string>&amp;Always on Top</string>\n   </property>\n   <property name=\"toolTip\">\n    <string>Always on Top</string>\n   </property>\n   <property name=\"shortcut\">\n    <string>Ctrl+O</string>\n   </property>\n  </action>\n  <action name=\"menuOptions\">\n   <property name=\"icon\">\n    <iconset resource=\"resources.qrc\">\n     <normaloff>:/icons/menu_button.png</normaloff>:/icons/menu_button.png</iconset>\n   </property>\n   <property name=\"text\">\n    <string>Menu Button</string>\n   </property>\n   <property name=\"toolTip\">\n    <string>Menu Button</string>\n   </property>\n  </action>\n  <action name=\"searchInPageAction\">\n   <property name=\"text\">\n    <string>Search in page</string>\n   </property>\n   <property name=\"shortcut\">\n    <string>Ctrl+F</string>\n   </property>\n   <property name=\"menuRole\">\n    <enum>QAction::TextHeuristicRole</enum>\n   </property>\n  </action>\n  <action name=\"fullTextSearchAction\">\n   <property name=\"text\">\n    <string>Full-text search</string>\n   </property>\n   <property name=\"shortcut\">\n    <string>Ctrl+Shift+F</string>\n   </property>\n   <property name=\"shortcutContext\">\n    <enum>Qt::WidgetWithChildrenShortcut</enum>\n   </property>\n   <property name=\"menuRole\">\n    <enum>QAction::TextHeuristicRole</enum>\n   </property>\n  </action>\n  <action name=\"showReference\">\n   <property name=\"text\">\n    <string>GoldenDict reference</string>\n   </property>\n   <property name=\"shortcut\">\n    <string>F1</string>\n   </property>\n  </action>\n  <action name=\"showHideFavorites\">\n   <property name=\"text\">\n    <string>Show</string>\n   </property>\n   <property name=\"shortcut\">\n    <string notr=\"true\">Ctrl+I</string>\n   </property>\n  </action>\n  <action name=\"exportFavorites\">\n   <property name=\"text\">\n    <string>Export</string>\n   </property>\n  </action>\n  <action name=\"importFavorites\">\n   <property name=\"text\">\n    <string>Import</string>\n   </property>\n  </action>\n  <action name=\"actionAddToFavorites\">\n   <property name=\"text\">\n    <string>Add</string>\n   </property>\n   <property name=\"statusTip\">\n    <string>Add current tab to Favorites</string>\n   </property>\n   <property name=\"shortcut\">\n    <string>Ctrl+E</string>\n   </property>\n  </action>\n  <action name=\"ExportFavoritesToList\">\n   <property name=\"text\">\n    <string>Export to list</string>\n   </property>\n  </action>\n </widget>\n <customwidgets>\n  <customwidget>\n   <class>SearchPaneWidget</class>\n   <extends>QWidget</extends>\n   <header>searchpanewidget.hh</header>\n   <container>1</container>\n  </customwidget>\n  <customwidget>\n   <class>DictsPaneWidget</class>\n   <extends>QWidget</extends>\n   <header>dictspanewidget.hh</header>\n   <container>1</container>\n  </customwidget>\n  <customwidget>\n   <class>MainTabWidget</class>\n   <extends>QTabWidget</extends>\n   <header>maintabwidget.hh</header>\n   <container>1</container>\n  </customwidget>\n  <customwidget>\n   <class>HistoryPaneWidget</class>\n   <extends>QWidget</extends>\n   <header>historypanewidget.hh</header>\n   <container>1</container>\n  </customwidget>\n  <customwidget>\n   <class>WordList</class>\n   <extends>QListWidget</extends>\n   <header>wordlist.hh</header>\n  </customwidget>\n  <customwidget>\n   <class>FavoritesPaneWidget</class>\n   <extends>QWidget</extends>\n   <header>favoritespanewidget.hh</header>\n   <container>1</container>\n  </customwidget>\n  <customwidget>\n   <class>TreeView</class>\n   <extends>QTreeView</extends>\n   <header>treeview.hh</header>\n  </customwidget>\n </customwidgets>\n <tabstops>\n  <tabstop>translateLine</tabstop>\n  <tabstop>tabWidget</tabstop>\n  <tabstop>dictsList</tabstop>\n </tabstops>\n <resources>\n  <include location=\"resources.qrc\"/>\n </resources>\n <connections/>\n</ui>\n"
        },
        {
          "name": "mdictparser.cc",
          "type": "blob",
          "size": 19.0830078125,
          "content": "// https://bitbucket.org/xwang/mdict-analysis\n// https://github.com/zhansliu/writemdict/blob/master/fileformat.md\n// Octopus MDict Dictionary File (.mdx) and Resource File (.mdd) Analyser\n//\n// Copyright (C) 2012, 2013 Xiaoqiang Wang <xiaoqiangwang AT gmail DOT com>\n// Copyright (C) 2013 Timon Wong <timon86.wang AT gmail DOT com>\n// Copyright (C) 2015 Zhe Wang <0x1998 AT gmail DOT com>\n//\n// This program is a free software; you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, version 3 of the License.\n//\n// You can get a copy of GNU General Public License along this program\n// But you can always get it from http://www.gnu.org/licenses/gpl.txt\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n\n#include \"mdictparser.hh\"\n\n#include <errno.h>\n#include <zlib.h>\n#include <iconv.h>\n#include <lzo/lzo1x.h>\n\n#include <QtEndian>\n#include <QStringList>\n#include <QByteArray>\n#include <QFileInfo>\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n#include <QRegularExpression>\n#else\n#include <QRegExp>\n#endif\n#include <QDomDocument>\n#include <QTextDocumentFragment>\n#include <QDataStream>\n\n#include \"decompress.hh\"\n#include \"gddebug.hh\"\n#include \"ripemd.hh\"\n#include \"qt4x5.hh\"\n\nnamespace Mdict\n{\n\nenum EncryptedSection\n{\n  EcryptedHeadWordHeader = 1,\n  EcryptedHeadWordIndex = 2\n};\n\nstatic inline int u16StrSize( const ushort * unicode )\n{\n  int size = 0;\n  if ( unicode )\n  {\n    while ( unicode[size] != 0 )\n      size++;\n  }\n  return size;\n}\n\nstatic QDomNamedNodeMap parseHeaderAttributes( const QString & headerText )\n{\n  QDomNamedNodeMap attributes;\n  QDomDocument doc;\n  doc.setContent( headerText );\n\n  QDomElement docElem = doc.documentElement();\n  attributes = docElem.attributes();\n\n  for ( int i = 0; i < attributes.count(); i++ )\n  {\n    QDomAttr attr = attributes.item( i ).toAttr();\n  }\n\n  return attributes;\n}\n\nsize_t MdictParser::RecordIndex::bsearch( const vector<MdictParser::RecordIndex> & offsets, qint64 val )\n{\n  if ( offsets.size() == 0 )\n    return ( size_t ) ( -1 );\n\n  size_t lo = 0;\n  size_t hi = offsets.size() - 1;\n\n  while ( lo <= hi )\n  {\n    size_t mid = ( lo + hi ) >> 1;\n    RecordIndex const & p = offsets[mid];\n    if ( p == val )\n      return mid;\n    else if ( p < val )\n      lo = mid + 1;\n    else\n      hi = mid - 1;\n  }\n\n  return ( size_t ) ( -1 );\n}\n\nMdictParser::MdictParser() :\n  version_( 0 ),\n  numHeadWordBlocks_( 0 ),\n  headWordBlockInfoSize_( 0 ),\n  headWordBlockSize_( 0 ),\n  headWordBlockInfoPos_( 0 ),\n  headWordPos_( 0 ),\n  totalRecordsSize_( 0 ),\n  recordPos_( 0 ),\n  wordCount_( 0 ),\n  numberTypeSize_( 0 ),\n  encrypted_( 0 ),\n  rtl_( false )\n{\n}\n\nbool MdictParser::open( const char * filename )\n{\n  filename_ = QString::fromUtf8( filename );\n  file_ = new QFile( filename_ );\n\n  GD_DPRINTF( \"MdictParser: open %s\\n\", filename );\n\n  if ( file_.isNull() || !file_->exists() )\n    return false;\n\n  if ( !file_->open( QIODevice::ReadOnly ) )\n    return false;\n\n  QDataStream in( file_ );\n  in.setByteOrder( QDataStream::BigEndian );\n\n  if ( !readHeader( in ) )\n    return false;\n\n  if ( !readHeadWordBlockInfos( in ) )\n    return false;\n\n  if ( !readRecordBlockInfos() )\n    return false;\n\n  return true;\n}\n\nbool MdictParser::readNextHeadWordIndex( MdictParser::HeadWordIndex & headWordIndex )\n{\n  if ( headWordBlockInfosIter_ == headWordBlockInfos_.end() )\n    return false;\n\n  qint64 compressedSize = headWordBlockInfosIter_->first;\n  qint64 decompressedSize = headWordBlockInfosIter_->second;\n\n  if ( compressedSize < 8 )\n    return false;\n\n  ScopedMemMap compressed( *file_, headWordPos_, compressedSize );\n  if ( !compressed.startAddress() )\n    return false;\n\n  headWordPos_ += compressedSize;\n  QByteArray decompressed;\n  if ( !parseCompressedBlock( compressedSize, ( char * )compressed.startAddress(),\n                              decompressedSize, decompressed ) )\n    return false;\n\n  headWordIndex = splitHeadWordBlock( decompressed );\n  ++headWordBlockInfosIter_;\n  return true;\n}\n\nbool MdictParser::checkAdler32(const char * buffer, unsigned int len, quint32 checksum)\n{\n  uLong adler = adler32( 0L, Z_NULL, 0 );\n  adler = adler32( adler, ( const Bytef * ) buffer, len );\n  return (adler & 0xFFFFFFFF) == checksum;\n}\n\nQString MdictParser::toUtf16( const char * fromCode, const char * from, size_t fromSize )\n{\n  if ( !fromCode || !from )\n    return QString();\n\n  iconv_t conv = iconv_open( \"UTF-16//IGNORE\", fromCode );\n  if ( conv == ( iconv_t ) - 1 )\n    return QString();\n\n  vector<char> result;\n  const static int CHUNK_SIZE = 512;\n  char buf[CHUNK_SIZE];\n  char ** inBuf = ( char ** )&from;\n\n  while ( fromSize )\n  {\n    char * outBuf = buf;\n    size_t outBytesLeft = CHUNK_SIZE;\n    size_t ret = iconv( conv, inBuf, &fromSize, &outBuf, &outBytesLeft );\n\n    if ( ret == ( size_t ) - 1 )\n    {\n      if ( errno != E2BIG )\n      {\n        // Real problem\n        result.clear();\n        break;\n      }\n    }\n\n    result.insert( result.end(), buf, buf + CHUNK_SIZE - outBytesLeft );\n  }\n\n  iconv_close( conv );\n  if ( result.size() <= 2 )\n    return QString();\n  return QString::fromUtf16( ( const ushort * )&result.front() );\n}\n\nbool MdictParser::decryptHeadWordIndex(char * buffer, qint64 len)\n{\n  RIPEMD128 ripemd;\n  ripemd.update( ( const uchar * ) buffer + 4, 4 );\n  ripemd.update( ( const uchar * ) \"\\x95\\x36\\x00\\x00\", 4 );\n\n  uint8_t key[16];\n  ripemd.digest( key );\n\n  buffer += 8;\n  len -= 8;\n  uint8_t prev = 0x36;\n  for (qint64 i = 0; i < len; ++i)\n  {\n    uint8_t byte = buffer[i];\n    byte = (byte >> 4) | (byte << 4);\n    byte = byte ^ prev ^ (i & 0xFF) ^ key[i % 16];\n    prev = buffer[i];\n    buffer[i] = byte;\n  }\n  return true;\n}\n\nbool MdictParser::parseCompressedBlock( qint64 compressedBlockSize,\n                                        const char * compressedBlockPtr,\n                                        qint64 decompressedBlockSize,\n                                        QByteArray & decompressedBlock )\n{\n  if ( compressedBlockSize <= 8 )\n    return false;\n\n  // compression type\n  quint32 type = qFromBigEndian<quint32>( ( const uchar * ) compressedBlockPtr );\n  quint32 checksum = qFromBigEndian<quint32>( ( const uchar * )compressedBlockPtr + 4 );\n  const char * buf = compressedBlockPtr + 8;\n  qint64 size = compressedBlockSize - 8;\n\n  switch ( type )\n  {\n    case 0x00000000:\n      // No compression\n      if ( !checkAdler32( buf, size, checksum ) )\n      {\n        gdWarning( \"MDict: parseCompressedBlock: plain: checksum not match\" );\n        return false;\n      }\n\n      decompressedBlock = QByteArray( buf, size );\n      return true;\n\n    case 0x01000000:\n      {\n        // LZO compression\n        int result;\n        lzo_uint blockSize = ( lzo_uint )decompressedBlockSize;\n        decompressedBlock.resize( blockSize );\n        result = lzo1x_decompress_safe( ( const uchar * ) buf, size,\n                                        ( uchar * )decompressedBlock.data(),\n                                        &blockSize, NULL );\n\n        if ( result != LZO_E_OK || blockSize != ( lzo_uint )decompressedBlockSize )\n        {\n          gdWarning( \"MDict: parseCompressedBlock: decompression failed\" );\n          return false;\n        }\n\n        if ( checksum != lzo_adler32( lzo_adler32( 0, NULL, 0 ),\n                                      ( const uchar * )decompressedBlock.constData(),\n                                      blockSize ) )\n        {\n          gdWarning( \"MDict: parseCompressedBlock: lzo: checksum does not match\" );\n          return false;\n        }\n      }\n      break;\n\n    case 0x02000000:\n      // zlib compression\n      decompressedBlock = zlibDecompress( buf, size );\n\n      if ( !checkAdler32( decompressedBlock.constData(), decompressedBlock.size(),\n                          checksum ) )\n      {\n        gdWarning( \"MDict: parseCompressedBlock: zlib: checksum does not match\" );\n        return false;\n      }\n      break;\n\n    default:\n      gdWarning( \"MDict: parseCompressedBlock: unknown type\" );\n      return false;\n  }\n\n  return true;\n}\n\nqint64 MdictParser::readNumber( QDataStream & in )\n{\n  if ( numberTypeSize_ == 8 )\n  {\n    qint64 val;\n    in >> val;\n    return val;\n  }\n  else\n  {\n    quint32 val;\n    in >> val;\n    return val;\n  }\n}\n\nquint32 MdictParser::readU8OrU16( QDataStream & in, bool isU16 )\n{\n  if ( isU16 )\n  {\n    quint16 val;\n    in >> val;\n    return val;\n  }\n  else\n  {\n    quint8 val;\n    in >> val;\n    return val;\n  }\n}\n\nbool MdictParser::readHeader( QDataStream & in )\n{\n  qint32 headerTextSize;\n  in >> headerTextSize;\n\n  QByteArray headerTextUtf16 = file_->read( headerTextSize );\n  if ( headerTextUtf16.size() != headerTextSize )\n    return false;\n\n  QString headerText = toUtf16( \"UTF-16LE\", headerTextUtf16.constData(), headerTextUtf16.size() );\n\n  // Adler-32 checksum of the header text (little-endian)\n  quint32 checksum;\n  in.setByteOrder( QDataStream::LittleEndian );\n  in >> checksum;\n  if ( !checkAdler32( headerTextUtf16.constData(), headerTextUtf16.size(), checksum ) )\n  {\n    gdWarning( \"MDict: readHeader: checksum does not match\" );\n    return false;\n  }\n  headerTextUtf16.clear();\n  in.setByteOrder( QDataStream::BigEndian );\n\n  QDomNamedNodeMap headerAttributes = parseHeaderAttributes( headerText );\n\n  encoding_ = headerAttributes.namedItem( \"Encoding\" ).toAttr().value();\n  if ( encoding_ == \"GBK\" || encoding_ == \"GB2312\" )\n  {\n    encoding_ = \"GB18030\";\n  }\n  else if ( encoding_.isEmpty() || encoding_ == \"UTF-16\" )\n  {\n    encoding_ = \"UTF-16LE\";\n  }\n\n  // stylesheet attribute if present takes form of:\n  //   styleId # 1-255\n  //   style.prefix\n  //   style.suffix\n  if ( headerAttributes.contains( \"StyleSheet\" ) )\n  {\n    QString styleSheets = headerAttributes.namedItem( \"StyleSheet\" ).toAttr().value();\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n    QStringList lines = styleSheets.split( QRegularExpression( \"[\\r\\n]\" ), Qt4x5::keepEmptyParts() );\n#else\n    QStringList lines = styleSheets.split( QRegExp( \"[\\r\\n]\" ), QString::KeepEmptyParts );\n#endif\n    for ( int i = 0; i < lines.size() - 3; i += 3 )\n    {\n      styleSheets_[lines[i].toInt()] = pair<QString, QString>( lines[i + 1], lines[i + 2] );\n    }\n  }\n\n  // before version 2.0, number is 4 bytes integer\n  // version 2.0 and above uses 8 bytes\n  version_ = headerAttributes.namedItem( \"GeneratedByEngineVersion\" ).toAttr().value().toDouble();\n  if ( version_ < 2.0 )\n    numberTypeSize_ = 4;\n  else\n    numberTypeSize_ = 8;\n\n  // Encrypted ?\n  encrypted_ = headerAttributes.namedItem(\"Encrypted\").toAttr().value().toInt();\n\n  // Read metadata\n  rtl_ = headerAttributes.namedItem( \"Left2Right\" ).toAttr().value() != \"Yes\";\n  QString title = headerAttributes.namedItem( \"Title\" ).toAttr().value();\n  if ( title.isEmpty() || title.length() < 5 || title == \"Title (No HTML code allowed)\" )\n  {\n    // Use filename instead\n    QFileInfo fi( filename_ );\n    title_ = fi.baseName();\n  }\n  else\n  {\n    if ( title.contains( '<' ) || title.contains( '>' ) )\n      title_ = QTextDocumentFragment::fromHtml( title ).toPlainText();\n    else\n      title_ = title;\n  }\n  QString description = headerAttributes.namedItem( \"Description\" ).toAttr().value();\n  description_ = QTextDocumentFragment::fromHtml( description ).toPlainText();\n  return true;\n}\n\nbool MdictParser::readHeadWordBlockInfos( QDataStream & in )\n{\n  QByteArray header = file_->read( version_ >= 2.0 ? ( numberTypeSize_ * 5 )\n                                                   : ( numberTypeSize_ * 4 ) );\n  QDataStream stream( header );\n\n  // number of headword blocks\n  numHeadWordBlocks_ = readNumber( stream );\n  // number of entries\n  wordCount_ = readNumber( stream );\n\n  // number of bytes of a headword block info after decompression\n  qint64 decompressedSize;\n  if ( version_ >= 2.0 )\n    stream >> decompressedSize;\n\n  // number of bytes of a headword block info before decompression\n  headWordBlockInfoSize_ = readNumber( stream );\n  // number of bytes of a headword block\n  headWordBlockSize_ = readNumber( stream );\n\n  // Adler-32 checksum of the header. If those are encrypted, it is\n  // the checksum of the decrypted version\n  if ( version_ >= 2.0 )\n  {\n    quint32 checksum;\n    in >> checksum;\n    if ( !checkAdler32( header.constData(), numberTypeSize_ * 5, checksum ) )\n      return false;\n  }\n\n  headWordBlockInfoPos_ = file_->pos();\n\n  // read headword block info\n  QByteArray headWordBlockInfo = file_->read( headWordBlockInfoSize_ );\n  if ( headWordBlockInfo.size() != headWordBlockInfoSize_ )\n    return false;\n\n  if ( version_ >= 2.0 )\n  {\n    // decrypt\n    if ( encrypted_ & EcryptedHeadWordIndex )\n    {\n      if ( !decryptHeadWordIndex( headWordBlockInfo.data(),\n                                  headWordBlockInfo.size() ) )\n        return false;\n    }\n\n    QByteArray decompressed;\n    if ( !parseCompressedBlock( headWordBlockInfo.size(), headWordBlockInfo.data(),\n                                decompressedSize, decompressed) )\n      return false;\n\n    headWordBlockInfos_ = decodeHeadWordBlockInfo( decompressed );\n  }\n  else\n  {\n    headWordBlockInfos_ = decodeHeadWordBlockInfo( headWordBlockInfo );\n  }\n\n  headWordPos_ = file_->pos();\n  headWordBlockInfosIter_ = headWordBlockInfos_.begin();\n  return true;\n}\n\nbool MdictParser::readRecordBlockInfos()\n{\n  file_->seek( headWordBlockInfoPos_ + headWordBlockInfoSize_ +\n               headWordBlockSize_ );\n\n  QDataStream in( file_ );\n  in.setByteOrder( QDataStream::BigEndian );\n  qint64 numRecordBlocks = readNumber( in );\n  readNumber( in ); // total number of records, skip\n  qint64 recordInfoSize = readNumber( in );\n  totalRecordsSize_ = readNumber( in );\n  recordPos_ = file_->pos() + recordInfoSize;\n\n  // Build record block index\n  recordBlockInfos_.reserve( numRecordBlocks );\n\n  qint64 acc1 = 0;\n  qint64 acc2 = 0;\n  for ( qint64 i = 0; i < numRecordBlocks; i++ )\n  {\n    RecordIndex r;\n    r.compressedSize = readNumber( in );\n    r.decompressedSize = readNumber( in );\n    r.startPos = acc1;\n    r.shadowStartPos = acc2;\n    r.shadowEndPos = acc2 + r.decompressedSize;\n    recordBlockInfos_.push_back( r );\n\n    acc1 += r.compressedSize;\n    acc2 = r.shadowEndPos;\n  }\n\n  return true;\n}\n\nMdictParser::BlockInfoVector MdictParser::decodeHeadWordBlockInfo( QByteArray const & headWordBlockInfo )\n{\n  BlockInfoVector headWordBlockInfos;\n\n  QDataStream s( headWordBlockInfo );\n  s.setByteOrder( QDataStream::BigEndian );\n\n  bool isU16 = false;\n  int textTermSize = 0;\n\n  if ( version_ >= 2.0 )\n  {\n    isU16 = true;\n    textTermSize = 1;\n  }\n\n  while ( !s.atEnd() )\n  {\n    // Number of keywords in the block\n    s.skipRawData( numberTypeSize_ );\n    // Size of the first headword in the block\n    quint32 textHeadSize = readU8OrU16( s, isU16 );\n    // The first headword\n    if ( encoding_ != \"UTF-16LE\" )\n      s.skipRawData( textHeadSize + textTermSize );\n    else\n      s.skipRawData( ( textHeadSize + textTermSize ) * 2 );\n    // Size of the last headword in the block\n    quint32 textTailSize = readU8OrU16( s, isU16 );\n    // The last headword\n    if ( encoding_ != \"UTF-16LE\" )\n      s.skipRawData( textTailSize + textTermSize );\n    else\n      s.skipRawData( ( textTailSize + textTermSize ) * 2 );\n\n    // headword block compressed size\n    qint64 compressedSize = readNumber( s );\n    // headword block decompressed size\n    qint64 decompressedSize = readNumber( s );\n    headWordBlockInfos.push_back( BlockInfoVector::value_type( compressedSize, decompressedSize ) );\n  }\n\n  return headWordBlockInfos;\n}\n\nMdictParser::HeadWordIndex MdictParser::splitHeadWordBlock( QByteArray const & block )\n{\n  HeadWordIndex index;\n\n  const char * p = block.constData();\n  const char * end = p + block.size();\n\n  while ( p < end )\n  {\n    qint64 headWordId = ( numberTypeSize_ == 8 ) ?\n                        qFromBigEndian<qint64>( ( const uchar * )p ) :\n                        qFromBigEndian<quint32>( ( const uchar * )p );\n    p += numberTypeSize_;\n    QByteArray headWordBuf;\n\n    if ( encoding_ == \"UTF-16LE\" )\n    {\n      int headWordLength = u16StrSize( ( const ushort * )p );\n      headWordBuf = QByteArray( p, ( headWordLength + 1 ) * 2 );\n    }\n    else\n    {\n      int headWordLength = strlen( p );\n      headWordBuf = QByteArray( p, headWordLength + 1 );\n    }\n    p += headWordBuf.size();\n    QString headWord = toUtf16( encoding_, headWordBuf.constBegin(), headWordBuf.size() );\n    index.push_back( HeadWordIndex::value_type( headWordId, headWord ) );\n  }\n\n  return index;\n}\n\nbool MdictParser::readRecordBlock( MdictParser::HeadWordIndex & headWordIndex,\n                                   MdictParser::RecordHandler & recordHandler )\n{\n  // cache the index, the headWordIndex is already sorted\n  size_t idx = 0;\n\n  for ( HeadWordIndex::const_iterator i = headWordIndex.begin(); i != headWordIndex.end(); ++i )\n  {\n    if ( recordBlockInfos_[idx].shadowEndPos <= i->first )\n      idx = RecordIndex::bsearch( recordBlockInfos_, i->first );\n\n    if ( idx == ( size_t )( -1 ) )\n      return false;\n\n    RecordIndex const & recordIndex = recordBlockInfos_[idx];\n    HeadWordIndex::const_iterator iNext = i + 1;\n    qint64 recordSize;\n    if ( iNext == headWordIndex.end() )\n      recordSize = recordIndex.shadowEndPos - i->first;\n    else\n      recordSize = iNext->first - i->first;\n\n    RecordInfo recordInfo;\n    recordInfo.compressedBlockPos = recordPos_ + recordIndex.startPos;\n    recordInfo.recordOffset = i->first - recordIndex.shadowStartPos;\n    recordInfo.decompressedBlockSize = recordIndex.decompressedSize;\n    recordInfo.compressedBlockSize = recordIndex.compressedSize;\n    recordInfo.recordSize = recordSize;\n\n    recordHandler.handleRecord( i->second, recordInfo );\n  }\n\n  return true;\n}\n\nQString & MdictParser::substituteStylesheet( QString & article, MdictParser::StyleSheets const & styleSheets )\n{\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  QRegularExpression rx( \"`(\\\\d+)`\", QRegularExpression::UseUnicodePropertiesOption );\n  QString articleNewText;\n#else\n  QRegExp rx( \"`(\\\\d+)`\" );\n#endif\n  QString endStyle;\n  int pos = 0;\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  QRegularExpressionMatchIterator it = rx.globalMatch( article );\n  while ( it.hasNext() )\n  {\n    QRegularExpressionMatch match = it.next();\n    int styleId = match.captured( 1 ).toInt();\n    articleNewText += article.midRef( pos, match.capturedStart() - pos );\n    pos = match.capturedEnd();\n#else\n  while ( ( pos = rx.indexIn( article, pos ) ) != -1 )\n  {\n    int styleId = rx.cap( 1 ).toInt();\n#endif\n    StyleSheets::const_iterator iter = styleSheets.find( styleId );\n\n    if ( iter != styleSheets.end() )\n    {\n      QString rep = endStyle + iter->second.first;\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n      articleNewText += rep;\n#else\n      article.replace( pos, rx.cap( 0 ).length(), rep );\n      pos += rep.length();\n#endif\n      endStyle = iter->second.second;\n    }\n    else\n    {\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n      articleNewText += endStyle;\n#else\n      article.replace( pos, rx.cap( 0 ).length(), endStyle );\n      pos += endStyle.length();\n#endif\n      endStyle = \"\";\n    }\n  }\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  if( pos )\n  {\n    articleNewText += article.midRef( pos );\n    article = articleNewText;\n    articleNewText.clear();\n  }\n#endif\n  article += endStyle;\n  return article;\n}\n\n}\n"
        },
        {
          "name": "mdictparser.hh",
          "type": "blob",
          "size": 5.33203125,
          "content": "// https://bitbucket.org/xwang/mdict-analysis\n// https://github.com/zhansliu/writemdict/blob/master/fileformat.md\n// Octopus MDict Dictionary File (.mdx) and Resource File (.mdd) Analyser\n//\n// Copyright (C) 2012, 2013 Xiaoqiang Wang <xiaoqiangwang AT gmail DOT com>\n// Copyright (C) 2013 Timon Wong <timon86.wang AT gmail DOT com>\n// Copyright (C) 2015 Zhe Wang <0x1998 AT gmail DOT com>\n//\n// This program is a free software; you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, version 3 of the License.\n//\n// You can get a copy of GNU General Public License along this program\n// But you can always get it from http://www.gnu.org/licenses/gpl.txt\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n\n#ifndef __MDICTPARSER_HH_INCLUDED__\n#define __MDICTPARSER_HH_INCLUDED__\n\n#include <string>\n#include <vector>\n#include <map>\n#include <utility>\n\n#include <QPointer>\n#include <QFile>\n\nnamespace Mdict\n{\n\nusing std::string;\nusing std::vector;\nusing std::pair;\nusing std::map;\n\n// A helper class to handle memory map for QFile\nclass ScopedMemMap\n{\n  QFile & file;\n  uchar * address;\n\npublic:\n  ScopedMemMap( QFile & file, qint64 offset, qint64 size ) :\n    file( file ),\n    address( file.map( offset, size ) )\n  {\n  }\n\n  ~ScopedMemMap()\n  {\n    if ( address )\n      file.unmap( address );\n  }\n\n  inline uchar * startAddress()\n  {\n    return address;\n  }\n};\n\nclass MdictParser\n{\npublic:\n\n  enum\n  {\n    kParserVersion = 0x000000d\n  };\n\n  struct RecordIndex\n  {\n    qint64 startPos;\n    qint64 shadowStartPos;\n    qint64 shadowEndPos;\n    qint64 compressedSize;\n    qint64 decompressedSize;\n\n    inline bool operator==( qint64 rhs ) const\n    {\n      return ( shadowStartPos <= rhs ) && ( rhs < shadowEndPos );\n    }\n\n    inline bool operator<( qint64 rhs ) const\n    {\n      return shadowEndPos <= rhs;\n    }\n\n    inline bool operator>( qint64 rhs ) const\n    {\n      return shadowStartPos > rhs;\n    }\n\n    static size_t bsearch( vector<RecordIndex> const & offsets, qint64 val );\n  };\n\n  struct RecordInfo\n  {\n    qint64 compressedBlockPos;\n    qint64 recordOffset;\n\n    qint64 decompressedBlockSize;\n    qint64 compressedBlockSize;\n    qint64 recordSize;\n  };\n\n  class RecordHandler\n  {\n  public:\n    virtual void handleRecord( QString const & name, RecordInfo const & recordInfo ) = 0;\n  };\n\n  typedef vector< pair<qint64, qint64> > BlockInfoVector;\n  typedef vector< pair<qint64, QString> > HeadWordIndex;\n  typedef map<qint32, pair<QString, QString> > StyleSheets;\n\n  inline QString const & title() const\n  {\n    return title_;\n  }\n\n  inline QString const & description() const\n  {\n    return description_;\n  }\n\n  inline StyleSheets const & styleSheets() const\n  {\n    return styleSheets_;\n  }\n\n  inline quint32 wordCount() const\n  {\n    return wordCount_;\n  }\n\n  inline QString const & encoding() const\n  {\n    return encoding_;\n  }\n\n  inline QString const & filename() const\n  {\n    return filename_;\n  }\n\n  inline bool isRightToLeft() const\n  {\n    return rtl_;\n  }\n\n  MdictParser();\n  ~MdictParser() {}\n\n  bool open( const char * filename );\n  bool readNextHeadWordIndex( HeadWordIndex & headWordIndex );\n  bool readRecordBlock( HeadWordIndex & headWordIndex, RecordHandler & recordHandler );\n\n  // helpers\n  static QString toUtf16( const char * fromCode, const char * from, size_t fromSize );\n  static inline QString toUtf16( QString const & fromCode, const char * from, size_t fromSize )\n  {\n    return toUtf16( fromCode.toLatin1().constData(), from, fromSize );\n  }\n  static bool parseCompressedBlock( qint64 compressedBlockSize, const char * compressedBlockPtr,\n                                    qint64 decompressedBlockSize, QByteArray & decompressedBlock);\n  static QString & substituteStylesheet( QString & article, StyleSheets const & styleSheets );\n  static inline string substituteStylesheet( string const & article, StyleSheets const & styleSheets )\n  {\n    QString s = QString::fromUtf8( article.c_str() );\n    substituteStylesheet( s, styleSheets );\n    return string( s.toUtf8().constData() );\n  }\n\nprotected:\n  qint64 readNumber( QDataStream & in );\n  static quint32 readU8OrU16( QDataStream & in, bool isU16 );\n  static bool checkAdler32(const char * buffer, unsigned int len, quint32 checksum);\n  static bool decryptHeadWordIndex(char * buffer, qint64 len);\n  bool readHeader( QDataStream & in );\n  bool readHeadWordBlockInfos( QDataStream & in );\n  bool readRecordBlockInfos();\n  BlockInfoVector decodeHeadWordBlockInfo( QByteArray const & headWordBlockInfo );\n  HeadWordIndex splitHeadWordBlock( QByteArray const & block );\n\nprotected:\n  QString filename_;\n  QPointer<QFile> file_;\n  StyleSheets styleSheets_;\n  BlockInfoVector headWordBlockInfos_;\n  BlockInfoVector::iterator headWordBlockInfosIter_;\n  vector<RecordIndex> recordBlockInfos_;\n\n  QString encoding_;\n  QString title_;\n  QString description_;\n\n  double version_;\n  qint64 numHeadWordBlocks_;\n  qint64 headWordBlockInfoSize_;\n  qint64 headWordBlockSize_;\n  qint64 headWordBlockInfoPos_;\n  qint64 headWordPos_;\n  qint64 totalRecordsSize_;\n  qint64 recordPos_;\n\n  quint32 wordCount_;\n  int numberTypeSize_;\n  int encrypted_;\n  bool rtl_;\n};\n\n}\n\n#endif // __MDICTPARSER_HH_INCLUDED__\n"
        },
        {
          "name": "mdx.cc",
          "type": "blob",
          "size": 56.7470703125,
          "content": "/* This file is (c) 2013 Timon Wong <timon86.wang AT gmail DOT com>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"mdx.hh\"\n#include \"btreeidx.hh\"\n#include \"folding.hh\"\n#include \"utf8.hh\"\n#include \"file.hh\"\n#include \"wstring.hh\"\n#include \"wstring_qt.hh\"\n#include \"chunkedstorage.hh\"\n#include \"gddebug.hh\"\n#include \"langcoder.hh\"\n#include \"fsencoding.hh\"\n#include \"audiolink.hh\"\n#include \"ex.hh\"\n#include \"mdictparser.hh\"\n#include \"filetype.hh\"\n#include \"ftshelpers.hh\"\n#include \"htmlescape.hh\"\n\n#include <algorithm>\n#include <map>\n#include <set>\n#include <list>\n#include <ctype.h>\n#include <stdlib.h>\n\n#ifdef _MSC_VER\n#include <stub_msvc.h>\n#endif\n\n#include <QDir>\n#include <QString>\n#include <QSemaphore>\n#include <QThreadPool>\n#include <QAtomicInt>\n#include <QTextDocument>\n#include <QCryptographicHash>\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n#include <QRegularExpression>\n#endif\n\n#include \"qt4x5.hh\"\n\nnamespace Mdx\n{\n\nusing std::map;\nusing std::multimap;\nusing std::set;\nusing gd::wstring;\nusing gd::wchar;\nusing std::list;\nusing std::pair;\nusing std::string;\n\nusing BtreeIndexing::WordArticleLink;\nusing BtreeIndexing::IndexedWords;\nusing BtreeIndexing::IndexInfo;\n\nusing namespace Mdict;\n\nenum\n{\n  kSignature = 0x4349444d,  // MDIC\n  kCurrentFormatVersion = 12 + BtreeIndexing::FormatVersion + Folding::Version\n};\n\nDEF_EX( exCorruptDictionary, \"dictionary file was tampered or corrupted\", std::exception )\n\nstruct IdxHeader\n{\n  uint32_t signature; // First comes the signature, MDIC\n  uint32_t formatVersion; // File format version, currently 1.\n  uint32_t parserVersion; // Version of the parser used to parse the MDIC file.\n  // Version of the folding algorithm used when building\n  // index. If it's different from the current one,\n  // the file is to be rebuilt.\n  uint32_t foldingVersion;\n\n  uint32_t articleCount; // Total number of articles, for informative purposes only\n  uint32_t wordCount; // Total number of words, for informative purposes only\n\n  uint32_t isRightToLeft; // Right to left\n  uint32_t chunksOffset; // The offset to chunks' storage\n\n  uint32_t descriptionAddress; // Address of the dictionary description in the chunks' storage\n  uint32_t descriptionSize; // Size of the description in the chunks' storage, 0 = no description\n\n  uint32_t styleSheetAddress;\n  uint32_t styleSheetCount;\n\n  uint32_t indexBtreeMaxElements; // Two fields from IndexInfo\n  uint32_t indexRootOffset;\n\n  uint32_t langFrom; // Source language\n  uint32_t langTo; // Target language\n\n  uint32_t mddIndexInfosOffset; // address of IndexInfos for resource files (.mdd)\n  uint32_t mddIndexInfosCount; // count of IndexInfos for resource files\n}\n#ifndef _MSC_VER\n__attribute__( ( packed ) )\n#endif\n;\n\n// A helper method to read resources from .mdd file\nclass IndexedMdd: public BtreeIndexing::BtreeIndex\n{\n  Mutex & idxMutex;\n  Mutex fileMutex;\n  ChunkedStorage::Reader & chunks;\n  QFile mddFile;\n  bool isFileOpen;\n\npublic:\n\n  IndexedMdd( Mutex & idxMutex, ChunkedStorage::Reader & chunks ):\n    idxMutex( idxMutex ),\n    chunks( chunks ),\n    isFileOpen( false )\n  {}\n\n  /// Opens the index. The values are those previously returned by buildIndex().\n  using BtreeIndexing::BtreeIndex::openIndex;\n\n  /// Opens the mdd file itself. Returns true if succeeded, false otherwise.\n  bool open( const char * fileName )\n  {\n    mddFile.setFileName( QString::fromUtf8( fileName ) );\n    isFileOpen = mddFile.open( QFile::ReadOnly );\n    return isFileOpen;\n  }\n\n  /// Returns true if the mdd is open, false otherwise.\n  inline bool isOpen() const\n  {\n    return isFileOpen;\n  }\n\n  /// Checks whether the given file exists in the mdd file or not.\n  /// Note that this function is thread-safe, since it does not access mdd file.\n  bool hasFile( gd::wstring const & name )\n  {\n    if ( !isFileOpen )\n      return false;\n    vector< WordArticleLink > links = findArticles( name );\n    return !links.empty();\n  }\n\n  /// Attempts loading the given file into the given vector. Returns true on\n  /// success, false otherwise.\n  bool loadFile( gd::wstring const & name, std::vector< char > & result )\n  {\n    if ( !isFileOpen )\n      return false;\n\n    vector< WordArticleLink > links = findArticles( name );\n    if ( links.empty() )\n      return false;\n\n    MdictParser::RecordInfo indexEntry;\n    vector< char > chunk;\n    Mutex::Lock _( idxMutex );\n    const char * indexEntryPtr = chunks.getBlock( links[ 0 ].articleOffset, chunk );\n    memcpy( &indexEntry, indexEntryPtr, sizeof( indexEntry ) );\n\n    ScopedMemMap compressed( mddFile, indexEntry.compressedBlockPos, indexEntry.compressedBlockSize );\n    if ( !compressed.startAddress() )\n    {\n      return false;\n    }\n\n    QByteArray decompressed;\n    if ( !MdictParser::parseCompressedBlock( indexEntry.compressedBlockSize, ( char * )compressed.startAddress(),\n                                             indexEntry.decompressedBlockSize, decompressed ) )\n    {\n      return false;\n    }\n\n    result.resize( indexEntry.recordSize );\n    memcpy( &result.front(), decompressed.constData() + indexEntry.recordOffset, indexEntry.recordSize );\n    return true;\n  }\n\n};\n\nclass MdxDictionary: public BtreeIndexing::BtreeDictionary\n{\n  Mutex idxMutex;\n  File::Class idx;\n  IdxHeader idxHeader;\n  string dictionaryName;\n  string encoding;\n  ChunkedStorage::Reader chunks;\n  QFile dictFile;\n  vector< sptr< IndexedMdd > > mddResources;\n  MdictParser::StyleSheets styleSheets;\n\n  QAtomicInt deferredInitDone;\n  Mutex deferredInitMutex;\n  bool deferredInitRunnableStarted;\n  QSemaphore deferredInitRunnableExited;\n\n  string initError;\n  QString cacheDirName;\n\npublic:\n\n  MdxDictionary( string const & id, string const & indexFile, vector<string> const & dictionaryFiles );\n\n  ~MdxDictionary();\n\n  virtual void deferredInit();\n\n  virtual string getName() throw()\n  {\n    return dictionaryName;\n  }\n\n  virtual map< Dictionary::Property, string > getProperties() throw()\n  {\n    return map< Dictionary::Property, string >();\n  }\n\n  virtual unsigned long getArticleCount() throw()\n  {\n    return idxHeader.articleCount;\n  }\n\n  virtual unsigned long getWordCount() throw()\n  {\n    return idxHeader.wordCount;\n  }\n\n  inline virtual quint32 getLangFrom() const\n  {\n    return idxHeader.langFrom;\n  }\n\n  inline virtual quint32 getLangTo() const\n  {\n    return idxHeader.langTo;\n  }\n\n  virtual sptr< Dictionary::DataRequest > getArticle( wstring const & word,\n                                                      vector< wstring > const & alts,\n                                                      wstring const &,\n                                                      bool ignoreDiacritics ) THROW_SPEC( std::exception );\n  virtual sptr< Dictionary::DataRequest > getResource( string const & name ) THROW_SPEC( std::exception );\n  virtual QString const & getDescription();\n\n  virtual sptr< Dictionary::DataRequest > getSearchResults( QString const & searchString,\n                                                            int searchMode, bool matchCase,\n                                                            int distanceBetweenWords,\n                                                            int maxResults,\n                                                            bool ignoreWordsOrder,\n                                                            bool ignoreDiacritics,\n                                                            QThreadPool * ftsThreadPoolPtr );\n  virtual void getArticleText( uint32_t articleAddress, QString & headword, QString & text );\n\n  virtual void makeFTSIndex(QAtomicInt & isCancelled, bool firstIteration );\n\n  virtual void setFTSParameters( Config::FullTextSearch const & fts )\n  {\n    if( ensureInitDone().size() )\n      return;\n\n    can_FTS = fts.enabled\n              && !fts.disabledTypes.contains( \"MDICT\", Qt::CaseInsensitive )\n              && ( fts.maxDictionarySize == 0 || getArticleCount() <= fts.maxDictionarySize );\n  }\n\n  QString getCachedFileName( QString name );\n\nprotected:\n\n  virtual void loadIcon() throw();\n\nprivate:\n\n  virtual string const & ensureInitDone();\n  void doDeferredInit();\n\n  /// Loads an article with the given offset, filling the given strings.\n  void loadArticle( uint32_t offset, string & articleText, bool noFilter = false );\n\n  /// Process resource links (images, audios, etc)\n  QString & filterResource( QString const & articleId, QString & article );\n\n  void removeDirectory( QString const & directory );\n\n  friend class MdxHeadwordsRequest;\n  friend class MdxArticleRequest;\n  friend class MddResourceRequest;\n  friend class MdxDeferredInitRunnable;\n};\n\nMdxDictionary::MdxDictionary( string const & id, string const & indexFile,\n                              vector<string> const & dictionaryFiles ):\n  BtreeDictionary( id, dictionaryFiles ),\n  idx( indexFile, \"rb\" ),\n  idxHeader( idx.read< IdxHeader >() ),\n  chunks( idx, idxHeader.chunksOffset ),\n  deferredInitRunnableStarted( false )\n{\n  // Read the dictionary's name\n  idx.seek( sizeof( idxHeader ) );\n  size_t len = idx.read< uint32_t >();\n  vector< char > buf( len );\n  if( len > 0 )\n  {\n    idx.read( &buf.front(), len );\n    dictionaryName = string( &buf.front(), len );\n  }\n\n  // then read the dictionary's encoding\n  len = idx.read< uint32_t >();\n  if( len > 0 )\n  {\n    buf.resize( len );\n    idx.read( &buf.front(), len );\n    encoding = string( &buf.front(), len );\n  }\n\n  dictFile.setFileName( QString::fromUtf8( dictionaryFiles[ 0 ].c_str() ) );\n  dictFile.open( QIODevice::ReadOnly );\n\n  // Full-text search parameters\n\n  can_FTS = true;\n\n  ftsIdxName = indexFile + \"_FTS\";\n\n  if( !Dictionary::needToRebuildIndex( dictionaryFiles, ftsIdxName )\n      && !FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) )\n    FTS_index_completed.ref();\n\n  cacheDirName = QDir::tempPath() + QDir::separator()\n                 + QString::fromUtf8( getId().c_str() )\n                 + \".cache\";\n}\n\nMdxDictionary::~MdxDictionary()\n{\n  Mutex::Lock _( deferredInitMutex );\n\n  // Wait for init runnable to complete if it was ever started\n  if ( deferredInitRunnableStarted )\n    deferredInitRunnableExited.acquire();\n\n  dictFile.close();\n\n  removeDirectory( cacheDirName );\n}\n\n//////// MdxDictionary::deferredInit()\n\nclass MdxDeferredInitRunnable: public QRunnable\n{\n  MdxDictionary & dictionary;\n  QSemaphore & hasExited;\n\npublic:\n\n  MdxDeferredInitRunnable( MdxDictionary & dictionary_,\n                           QSemaphore & hasExited_ ):\n    dictionary( dictionary_ ), hasExited( hasExited_ )\n  {}\n\n  ~MdxDeferredInitRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run()\n  {\n    dictionary.doDeferredInit();\n  }\n};\n\nvoid MdxDictionary::deferredInit()\n{\n  if ( !Qt4x5::AtomicInt::loadAcquire( deferredInitDone ) )\n  {\n    Mutex::Lock _( deferredInitMutex );\n\n    if ( Qt4x5::AtomicInt::loadAcquire( deferredInitDone ) )\n      return;\n\n    if ( !deferredInitRunnableStarted )\n    {\n      QThreadPool::globalInstance()->start(\n        new MdxDeferredInitRunnable( *this, deferredInitRunnableExited ),\n        -1000 );\n      deferredInitRunnableStarted = true;\n    }\n  }\n}\n\nstring const & MdxDictionary::ensureInitDone()\n{\n  doDeferredInit();\n  return initError;\n}\n\nvoid MdxDictionary::doDeferredInit()\n{\n  if ( !Qt4x5::AtomicInt::loadAcquire( deferredInitDone ) )\n  {\n    Mutex::Lock _( deferredInitMutex );\n\n    if ( Qt4x5::AtomicInt::loadAcquire( deferredInitDone ) )\n      return;\n\n    // Do deferred init\n\n    try\n    {\n      // Retrieve stylesheets\n      idx.seek( idxHeader.styleSheetAddress );\n      for ( uint32_t i = 0; i < idxHeader.styleSheetCount; i++ )\n      {\n        qint32 key = idx.read< qint32 >();\n        vector< char > buf;\n        quint32 sz;\n\n        sz = idx.read< quint32 >();\n        buf.resize( sz );\n        idx.read( &buf.front(), sz );\n        QString styleBegin = QString::fromUtf8( buf.data() );\n\n        sz = idx.read< quint32 >();\n        buf.resize( sz );\n        idx.read( &buf.front(), sz );\n        QString styleEnd = QString::fromUtf8( buf.data() );\n\n        styleSheets[ key ] = pair<QString, QString>( styleBegin, styleEnd );\n      }\n\n      // Initialize the index\n      openIndex( IndexInfo( idxHeader.indexBtreeMaxElements,\n                            idxHeader.indexRootOffset ), idx, idxMutex );\n\n      vector< string > mddFileNames;\n      vector< IndexInfo > mddIndexInfos;\n      idx.seek( idxHeader.mddIndexInfosOffset );\n      for ( uint32_t i = 0; i < idxHeader.mddIndexInfosCount; i++ )\n      {\n        quint32 sz = idx.read< quint32 >();\n        vector< char > buf( sz );\n        idx.read( &buf.front(), sz );\n        uint32_t btreeMaxElements = idx.read<uint32_t>();\n        uint32_t rootOffset = idx.read<uint32_t>();\n        mddFileNames.push_back( string( &buf.front() ) );\n        mddIndexInfos.push_back( IndexInfo( btreeMaxElements, rootOffset ) );\n      }\n\n      vector< string > const dictFiles = getDictionaryFilenames();\n      for ( uint32_t i = 1; i < dictFiles.size() && i < mddFileNames.size() + 1; i++ )\n      {\n        QFileInfo fi( QString::fromUtf8( dictFiles[ i ].c_str() ) );\n        QString mddFileName = QString::fromUtf8( mddFileNames[ i - 1 ].c_str() );\n\n        if ( fi.fileName() != mddFileName || !fi.exists() )\n          continue;\n\n        sptr< IndexedMdd > mdd = new IndexedMdd( idxMutex, chunks );\n        mdd->openIndex( mddIndexInfos[ i - 1 ], idx, idxMutex );\n        mdd->open( dictFiles[ i ].c_str() );\n        mddResources.push_back( mdd );\n      }\n    }\n    catch ( std::exception & e )\n    {\n      initError = e.what();\n    }\n    catch ( ... )\n    {\n      initError = \"Unknown error\";\n    }\n\n    deferredInitDone.ref();\n  }\n}\n\nvoid MdxDictionary::makeFTSIndex( QAtomicInt & isCancelled, bool firstIteration )\n{\n  if( !( Dictionary::needToRebuildIndex( getDictionaryFilenames(), ftsIdxName )\n         || FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) ) )\n    FTS_index_completed.ref();\n\n  if( haveFTSIndex() )\n    return;\n\n  if( ensureInitDone().size() )\n    return;\n\n  if( firstIteration && getArticleCount() > FTS::MaxDictionarySizeForFastSearch )\n    return;\n\n  gdDebug( \"MDict: Building the full-text index for dictionary: %s\\n\",\n           getName().c_str() );\n\n  try\n  {\n    FtsHelpers::makeFTSIndex( this, isCancelled );\n    FTS_index_completed.ref();\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"MDict: Failed building full-text search index for \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n    QFile::remove( FsEncoding::decode( ftsIdxName.c_str() ) );\n  }\n}\n\nvoid MdxDictionary::getArticleText( uint32_t articleAddress, QString & headword, QString & text )\n{\n  try\n  {\n    headword.clear();\n    string articleText;\n\n    loadArticle( articleAddress, articleText, true );\n    text = Html::unescape( QString::fromUtf8( articleText.data(), articleText.size() ) );\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"MDict: Failed retrieving article from \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n  }\n}\n\nsptr< Dictionary::DataRequest > MdxDictionary::getSearchResults( QString const & searchString,\n                                                                 int searchMode, bool matchCase,\n                                                                 int distanceBetweenWords,\n                                                                 int maxResults,\n                                                                 bool ignoreWordsOrder,\n                                                                 bool ignoreDiacritics,\n                                                                 QThreadPool * ftsThreadPoolPtr )\n{\n  return new FtsHelpers::FTSResultsRequest( *this, searchString,searchMode, matchCase, distanceBetweenWords, maxResults, ignoreWordsOrder, ignoreDiacritics, ftsThreadPoolPtr );\n}\n\n/// MdxDictionary::getArticle\n\nclass MdxArticleRequest;\n\nclass MdxArticleRequestRunnable: public QRunnable\n{\n  MdxArticleRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  MdxArticleRequestRunnable( MdxArticleRequest & r_,\n                             QSemaphore & hasExited_ ):\n    r( r_ ),\n    hasExited( hasExited_ )\n  {}\n\n  ~MdxArticleRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass MdxArticleRequest: public Dictionary::DataRequest\n{\n  friend class MdxArticleRequestRunnable;\n\n  wstring word;\n  vector< wstring > alts;\n  MdxDictionary & dict;\n  bool ignoreDiacritics;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  MdxArticleRequest( wstring const & word_,\n                     vector< wstring > const & alts_,\n                     MdxDictionary & dict_,\n                     bool ignoreDiacritics_ ):\n    word( word_ ),\n    alts( alts_ ),\n    dict( dict_ ),\n    ignoreDiacritics( ignoreDiacritics_ )\n  {\n    QThreadPool::globalInstance()->start( new MdxArticleRequestRunnable( *this, hasExited ) );\n  }\n\n  void run();\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~MdxArticleRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid MdxArticleRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid MdxArticleRequest::run()\n{\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  if ( dict.ensureInitDone().size() )\n  {\n    setErrorString( QString::fromUtf8( dict.ensureInitDone().c_str() ) );\n    finish();\n    return;\n  }\n\n  vector< WordArticleLink > chain = dict.findArticles( word, ignoreDiacritics );\n\n  for ( unsigned x = 0; x < alts.size(); ++x )\n  {\n    /// Make an additional query for each alt\n    vector< WordArticleLink > altChain = dict.findArticles( alts[ x ], ignoreDiacritics );\n    chain.insert( chain.end(), altChain.begin(), altChain.end() );\n  }\n\n  // Some synonims make it that the articles appear several times. We combat this\n  // by only allowing them to appear once.\n  set< uint32_t > articlesIncluded;\n  // Sometimes the articles are physically duplicated. We store hashes of\n  // the bodies to account for this.\n  set< QByteArray > articleBodiesIncluded;\n  string articleText;\n\n  for ( unsigned x = 0; x < chain.size(); ++x )\n  {\n    if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    {\n      finish();\n      return;\n    }\n\n    if ( articlesIncluded.find( chain[ x ].articleOffset ) != articlesIncluded.end() )\n      continue; // We already have this article in the body.\n\n    // Grab that article\n    string articleBody;\n    bool hasError = false;\n    QString errorMessage;\n\n    try\n    {\n      dict.loadArticle( chain[ x ].articleOffset, articleBody );\n    }\n    catch ( exCorruptDictionary & )\n    {\n      errorMessage = tr( \"Dictionary file was tampered or corrupted\" );\n      hasError = true;\n    }\n    catch ( std::exception & e )\n    {\n      errorMessage = e.what();\n      hasError = true;\n    }\n\n    if ( hasError )\n    {\n      setErrorString( tr( \"Failed loading article from %1, reason: %2\" )\n                      .arg( QString::fromUtf8( dict.getDictionaryFilenames()[ 0 ].c_str() ) )\n                      .arg( errorMessage ) );\n      finish();\n      return;\n    }\n\n    if ( articlesIncluded.find( chain[ x ].articleOffset ) != articlesIncluded.end() )\n      continue; // We already have this article in the body.\n\n    QCryptographicHash hash( QCryptographicHash::Md5 );\n    hash.addData( articleBody.data(), articleBody.size() );\n    if ( !articleBodiesIncluded.insert( hash.result() ).second )\n      continue; // Already had this body\n\n    // Handle internal redirects\n    if ( strncmp( articleBody.c_str(), \"@@@LINK=\", 8 ) == 0 )\n    {\n      wstring target = Utf8::decode( articleBody.c_str() + 8 );\n      target = Folding::trimWhitespace( target );\n      // Make an additional query for this redirection\n      vector< WordArticleLink > altChain = dict.findArticles( target );\n      chain.insert( chain.end(), altChain.begin(), altChain.end() );\n      continue;\n    }\n\n    // See Issue #271: A mechanism to clean-up invalid HTML cards.\n    string cleaner = \"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\n                     \"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\n                     \"</b></b></b></b></b></b></b></b>\"\n                     \"</i></i></i></i></i></i></i></i>\"\n                     \"</a></a></a></a></a></a></a></a>\";\n    articleText += \"<div class=\\\"mdict\\\">\" + articleBody + cleaner + \"</div>\\n\";\n  }\n\n  if ( !articleText.empty() )\n  {\n    Mutex::Lock _( dataMutex );\n    data.insert( data.end(), articleText.begin(), articleText.end() );\n    hasAnyData = true;\n  }\n\n  finish();\n}\n\nsptr<Dictionary::DataRequest> MdxDictionary::getArticle( const wstring & word, const vector<wstring> & alts,\n                                                         const wstring &, bool ignoreDiacritics ) THROW_SPEC( std::exception )\n{\n  return new MdxArticleRequest( word, alts, *this, ignoreDiacritics );\n}\n\n/// MdxDictionary::getResource\n\nclass MddResourceRequest;\n\nclass MddResourceRequestRunnable: public QRunnable\n{\n  MddResourceRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  MddResourceRequestRunnable( MddResourceRequest & r_,\n                              QSemaphore & hasExited_ ): r( r_ ),\n    hasExited( hasExited_ )\n  {}\n\n  ~MddResourceRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass MddResourceRequest: public Dictionary::DataRequest\n{\n  friend class MddResourceRequestRunnable;\n\n  MdxDictionary & dict;\n  wstring resourceName;\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  MddResourceRequest( MdxDictionary & dict_,\n                      string const & resourceName_ ):\n    dict( dict_ ),\n    resourceName( Utf8::decode( resourceName_ ) )\n  {\n    QThreadPool::globalInstance()->start( new MddResourceRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by MddResourceRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~MddResourceRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid MddResourceRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid MddResourceRequest::run()\n{\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  if ( dict.ensureInitDone().size() )\n  {\n    setErrorString( QString::fromUtf8( dict.ensureInitDone().c_str() ) );\n    finish();\n    return;\n  }\n\n  // In order to prevent recursive internal redirection...\n  set< QByteArray > resourceIncluded;\n\n  for ( ;; )\n  {\n    // Some runnables linger enough that they are cancelled before they start\n    if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    {\n      finish();\n      return;\n    }\n\n    string u8ResourceName = Utf8::encode( resourceName );\n    QCryptographicHash hash( QCryptographicHash::Md5 );\n    hash.addData( u8ResourceName.data(), u8ResourceName.size() );\n    if ( !resourceIncluded.insert( hash.result() ).second )\n      continue;\n\n    // Convert to the Windows separator\n    std::replace( resourceName.begin(), resourceName.end(), '/', '\\\\' );\n    if ( resourceName[ 0 ] != '\\\\' )\n    {\n      resourceName.insert( 0, 1, '\\\\' );\n    }\n\n    Mutex::Lock _( dataMutex );\n    data.clear();\n\n    try\n    {\n      // local file takes precedence\n      string fn = FsEncoding::dirname( dict.getDictionaryFilenames()[ 0 ] ) +\n                  FsEncoding::separator() + u8ResourceName;\n      File::loadFromFile( fn, data );\n    }\n    catch ( File::exCantOpen & )\n    {\n      for ( vector< sptr< IndexedMdd > >::const_iterator i = dict.mddResources.begin();\n            i != dict.mddResources.end(); ++i  )\n      {\n        if ( ( *i )->loadFile( resourceName, data ) )\n          break;\n      }\n    }\n\n    // Check if this file has a redirection\n    // Always encoded in UTF16-LE\n    // L\"@@@LINK=\"\n    static const char pattern[16] =\n    {\n      '@', '\\0', '@', '\\0', '@', '\\0', 'L', '\\0', 'I', '\\0', 'N', '\\0', 'K', '\\0', '=', '\\0'\n    };\n\n    if ( data.size() > sizeof( pattern ) )\n    {\n      if ( memcmp( &data.front(),  pattern, sizeof( pattern ) ) == 0 )\n      {\n        data.push_back( '\\0' );\n        data.push_back( '\\0' );\n        QString target = MdictParser::toUtf16( \"UTF-16LE\", &data.front() + sizeof( pattern ),\n                                               data.size() - sizeof( pattern ) );\n        resourceName = gd::toWString( target.trimmed() );\n        continue;\n      }\n    }\n\n    if ( data.size() > 0 )\n    {\n      hasAnyData = true;\n\n      if ( Filetype::isNameOfCSS( u8ResourceName ) )\n      {\n        QString css = QString::fromUtf8( data.data(), data.size() );\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n        QRegularExpression links( \"url\\\\(\\\\s*(['\\\"]?)([^'\\\"]*)(['\\\"]?)\\\\s*\\\\)\",\n                                  QRegularExpression::CaseInsensitiveOption );\n#else\n        QRegExp links( \"url\\\\(\\\\s*(['\\\"]?)([^'\\\"]*)(['\\\"]?)\\\\s*\\\\)\", Qt::CaseInsensitive, QRegExp::RegExp );\n#endif\n        QString id = QString::fromUtf8( dict.getId().c_str() );\n        int pos = 0;\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n        QString newCSS;\n        QRegularExpressionMatchIterator it = links.globalMatch( css );\n        while ( it.hasNext() )\n        {\n          QRegularExpressionMatch match = it.next();\n          newCSS += css.midRef( pos, match.capturedStart() - pos );\n          pos = match.capturedEnd();\n          QString url = match.captured( 2 );\n#else\n        for( ; ; )\n        {\n          pos = links.indexIn( css, pos );\n          if( pos < 0 )\n            break;\n          QString url = links.cap( 2 );\n#endif\n\n          if( url.indexOf( \":/\" ) >= 0 || url.indexOf( \"data:\" ) >= 0)\n          {\n            // External link or base64-encoded data\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n            newCSS += match.captured();\n#else\n            pos += links.cap().size();\n#endif\n            continue;\n          }\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n          QString newUrl = QString( \"url(\" ) + match.captured( 1 ) + \"bres://\"\n                                             + id + \"/\" + url + match.captured( 3 ) + \")\";\n          newCSS += newUrl;\n#else\n          QString newUrl = QString( \"url(\" ) + links.cap( 1 ) + \"bres://\"\n                                             + id + \"/\" + url + links.cap( 3 ) + \")\";\n          css.replace( pos, links.cap().size(), newUrl );\n          pos += newUrl.size();\n#endif\n        }\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n        if( pos )\n        {\n          newCSS += css.midRef( pos );\n          css = newCSS;\n          newCSS.clear();\n        }\n#endif\n        dict.isolateCSS( css, \".mdict\" );\n        QByteArray bytes = css.toUtf8();\n        data.resize( bytes.size() );\n        memcpy( &data.front(), bytes.constData(), bytes.size() );\n      }\n    }\n    break;\n  }\n\n  finish();\n}\n\nsptr<Dictionary::DataRequest> MdxDictionary::getResource( const string & name ) THROW_SPEC( std::exception )\n{\n  return new MddResourceRequest( *this, name );\n}\n\nconst QString & MdxDictionary::getDescription()\n{\n  if ( !dictionaryDescription.isEmpty() )\n    return dictionaryDescription;\n\n  if ( idxHeader.descriptionSize == 0 )\n  {\n    dictionaryDescription = \"NONE\";\n  }\n  else\n  {\n    Mutex::Lock _( idxMutex );\n    vector< char > chunk;\n    char * dictDescription = chunks.getBlock( idxHeader.descriptionAddress, chunk );\n    string str( dictDescription );\n    dictionaryDescription = QString::fromUtf8( str.c_str(), str.size() );\n  }\n\n  return dictionaryDescription;\n}\n\nvoid MdxDictionary::loadIcon() throw()\n{\n  if ( dictionaryIconLoaded )\n    return;\n\n  QString fileName =\n    QDir::fromNativeSeparators( FsEncoding::decode( getDictionaryFilenames()[ 0 ].c_str() ) );\n\n  // Remove the extension\n  fileName.chop( 3 );\n\n  if ( !loadIconFromFile( fileName ) )\n  {\n    // Use default icons\n    dictionaryIcon = dictionaryNativeIcon = QIcon( \":/icons/mdict.png\" );\n  }\n\n  dictionaryIconLoaded = true;\n}\n\nvoid MdxDictionary::loadArticle( uint32_t offset, string & articleText, bool noFilter )\n{\n  vector< char > chunk;\n  Mutex::Lock _( idxMutex );\n\n  // Load record info from index\n  MdictParser::RecordInfo recordInfo;\n  char * pRecordInfo = chunks.getBlock( offset, chunk );\n  memcpy( &recordInfo, pRecordInfo, sizeof( recordInfo ) );\n\n  // Make a sub unique id for this article\n  QString articleId;\n  articleId.setNum( ( quint64 )pRecordInfo, 16 );\n\n  ScopedMemMap compressed( dictFile, recordInfo.compressedBlockPos, recordInfo.compressedBlockSize );\n  if ( !compressed.startAddress() )\n    throw exCorruptDictionary();\n\n  QByteArray decompressed;\n  if ( !MdictParser::parseCompressedBlock( recordInfo.compressedBlockSize, ( char * )compressed.startAddress(),\n                                           recordInfo.decompressedBlockSize, decompressed ) )\n    throw exCorruptDictionary();\n\n  QString article = MdictParser::toUtf16( encoding.c_str(),\n                                          decompressed.constData() + recordInfo.recordOffset,\n                                          recordInfo.recordSize );\n\n  article = MdictParser::substituteStylesheet( article, styleSheets );\n\n  if( !noFilter )\n    article = filterResource( articleId, article );\n\n  // Check for unclosed <span> and <div>\n\n  int openTags = article.count( QRegExp( \"<\\\\s*span\\\\b\", Qt::CaseInsensitive ) );\n  int closedTags = article.count( QRegExp( \"<\\\\s*/span\\\\s*>\", Qt::CaseInsensitive ) );\n  while( openTags > closedTags )\n  {\n    article += \"</span>\";\n    closedTags += 1;\n  }\n\n  openTags = article.count( QRegExp( \"<\\\\s*div\\\\b\", Qt::CaseInsensitive ) );\n  closedTags = article.count( QRegExp( \"<\\\\s*/div\\\\s*>\", Qt::CaseInsensitive ) );\n  while( openTags > closedTags )\n  {\n    article += \"</div>\";\n    closedTags += 1;\n  }\n\n  articleText = string( article.toUtf8().constData() );\n}\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\nQString & MdxDictionary::filterResource( QString const & articleId, QString & article )\n{\n  QString id = QString::fromStdString( getId() );\n  QString uniquePrefix = QString::fromLatin1( \"g\" ) + id + \"_\" + articleId + \"_\";\n\n  QRegularExpression allLinksRe( \"(?:<\\\\s*(a(?:rea)?|img|link|script|source)(?:\\\\s+[^>]+|\\\\s*)>)\",\n                                 QRegularExpression::CaseInsensitiveOption );\n  QRegularExpression wordCrossLink( \"([\\\\s\\\"']href\\\\s*=)\\\\s*([\\\"'])entry://([^>#]*?)((?:#[^>]*?)?)\\\\2\",\n                                    QRegularExpression::CaseInsensitiveOption );\n  QRegularExpression anchorIdRe( \"([\\\\s\\\"'](?:name|id)\\\\s*=)\\\\s*([\\\"'])\\\\s*(?=\\\\S)\",\n                                 QRegularExpression::CaseInsensitiveOption );\n  QRegularExpression anchorIdRe2( \"([\\\\s\\\"'](?:name|id)\\\\s*=)\\\\s*(?=[^\\\"'])([^\\\\s\\\">]+)\",\n                                  QRegularExpression::CaseInsensitiveOption );\n  QRegularExpression anchorLinkRe( \"([\\\\s\\\"']href\\\\s*=\\\\s*[\\\"'])entry://#\",\n                                   QRegularExpression::CaseInsensitiveOption );\n  QRegularExpression audioRe( \"([\\\\s\\\"']href\\\\s*=)\\\\s*([\\\"'])sound://([^\\\">]+)\\\\2\",\n                              QRegularExpression::CaseInsensitiveOption\n                              | QRegularExpression::InvertedGreedinessOption );\n  QRegularExpression stylesRe( \"([\\\\s\\\"']href\\\\s*=)\\\\s*([\\\"'])(?!\\\\s*\\\\b(?:(?:bres|https?|ftp)://|(?:data|javascript):))(?:file://)?[\\\\x00-\\\\x1f\\\\x7f]*\\\\.*/?([^\\\">]+)\\\\2\",\n                               QRegularExpression::CaseInsensitiveOption );\n  QRegularExpression stylesRe2( \"([\\\\s\\\"']href\\\\s*=)\\\\s*(?![\\\\s\\\"']|\\\\b(?:(?:bres|https?|ftp)://|(?:data|javascript):))(?:file://)?[\\\\x00-\\\\x1f\\\\x7f]*\\\\.*/?([^\\\\s\\\">]+)\",\n                                QRegularExpression::CaseInsensitiveOption );\n  QRegularExpression inlineScriptRe( \"<\\\\s*script(?:(?=\\\\s)(?:(?![\\\\s\\\"']src\\\\s*=)[^>])+|\\\\s*)>\",\n                                     QRegularExpression::CaseInsensitiveOption );\n  QRegularExpression closeScriptTagRe( \"<\\\\s*/script\\\\s*>\",\n                                       QRegularExpression::CaseInsensitiveOption );\n  QRegularExpression srcRe( \"([\\\\s\\\"']src\\\\s*=)\\\\s*([\\\"'])(?!\\\\s*\\\\b(?:(?:bres|https?|ftp)://|(?:data|javascript):))(?:file://)?[\\\\x00-\\\\x1f\\\\x7f]*\\\\.*/?([^\\\">]+)\\\\2\",\n                            QRegularExpression::CaseInsensitiveOption );\n  QRegularExpression srcRe2( \"([\\\\s\\\"']src\\\\s*=)\\\\s*(?![\\\\s\\\"']|\\\\b(?:(?:bres|https?|ftp)://|(?:data|javascript):))(?:file://)?[\\\\x00-\\\\x1f\\\\x7f]*\\\\.*/?([^\\\\s\\\">]+)\",\n                             QRegularExpression::CaseInsensitiveOption );\n\n  QString articleNewText;\n  int linkPos = 0;\n  QRegularExpressionMatchIterator it = allLinksRe.globalMatch( article );\n  while( it.hasNext() )\n  {\n    QRegularExpressionMatch allLinksMatch = it.next();\n\n    if( allLinksMatch.capturedEnd() < linkPos )\n      continue;\n\n    articleNewText += article.midRef( linkPos, allLinksMatch.capturedStart() - linkPos );\n    linkPos = allLinksMatch.capturedEnd();\n\n    QString linkTxt = allLinksMatch.captured();\n    QString linkType = allLinksMatch.captured( 1 ).toLower();\n    QString newLink;\n\n    if( !linkType.isEmpty() && linkType.at( 0 ) == 'a' )\n    {\n      QRegularExpressionMatch match = anchorIdRe.match( linkTxt );\n      if( match.hasMatch() )\n      {\n        QString newText = match.captured( 1 ) + match.captured( 2 ) + uniquePrefix;\n        newLink = linkTxt.replace( match.capturedStart(), match.capturedLength(), newText );\n      }\n      else\n        newLink = linkTxt.replace( anchorIdRe2, \"\\\\1\\\"\" + uniquePrefix + \"\\\\2\\\"\" );\n\n      newLink = newLink.replace( anchorLinkRe, \"\\\\1#\" + uniquePrefix );\n\n      match = audioRe.match( newLink );\n      if( match.hasMatch() )\n      {\n        // sounds and audio link script\n        QString newTxt = match.captured( 1 ) + match.captured( 2 )\n                         + \"gdau://\" + id + \"/\"\n                         + match.captured( 3 ) + match.captured( 2 );\n        newLink = QString::fromUtf8( addAudioLink( \"\\\"gdau://\" + getId() + \"/\" + match.captured( 3 ).toUtf8().data() + \"\\\"\", getId() ).c_str() )\n                  + newLink.replace( match.capturedStart(), match.capturedLength(), newTxt );\n      }\n\n      match = wordCrossLink.match( newLink );\n      if( match.hasMatch() )\n      {\n        QString newTxt = match.captured( 1 ) + match.captured( 2 )\n                         + \"gdlookup://localhost/\"\n                         + match.captured( 3 );\n\n        if( match.lastCapturedIndex() >= 4 && !match.captured( 4 ).isEmpty() )\n          newTxt += QString( \"?gdanchor=\" ) + uniquePrefix + match.captured( 4 ).mid( 1 );\n\n        newTxt += match.captured( 2 );\n        newLink.replace( match.capturedStart(), match.capturedLength(), newTxt );\n      }\n    }\n    else\n    if( linkType.compare( \"link\" ) == 0 )\n    {\n      // stylesheets\n      QRegularExpressionMatch match = stylesRe.match( linkTxt );\n      if( match.hasMatch() )\n      {\n        QString newText = match.captured( 1 ) + match.captured( 2 )\n                          + \"bres://\" + id + \"/\"\n                          + match.captured( 3 ) + match.captured( 2 );\n        newLink = linkTxt.replace( match.capturedStart(), match.capturedLength(), newText );\n      }\n      else\n        newLink = linkTxt.replace( stylesRe2,\n                                   \"\\\\1\\\"bres://\" + id + \"/\\\\2\\\"\" );\n    }\n    else\n    if( linkType.compare( \"script\" ) == 0 || linkType.compare( \"img\" ) == 0\n        || linkType.compare( \"source\" ) == 0 )\n    {\n      // javascripts and images\n      QRegularExpressionMatch match = inlineScriptRe.match( linkTxt );\n      if( linkType.at( 1 ) == 'c' // \"script\" tag\n          && match.hasMatch() && match.capturedLength() == linkTxt.length() )\n      {\n        // skip inline scripts\n        articleNewText += linkTxt;\n        match = closeScriptTagRe.match( article, linkPos );\n        if( match.hasMatch() )\n        {\n          articleNewText += article.midRef( linkPos, match.capturedEnd() - linkPos );\n          linkPos = match.capturedEnd();\n        }\n        continue;\n      }\n      else\n      {\n        match = srcRe.match( linkTxt );\n        if( match.hasMatch() )\n        {\n          QString newText;\n          if( linkType.at( 1 ) == 'o' ) // \"source\" tag\n          {\n            QString filename = match.captured( 3 );\n            QString newName = getCachedFileName( filename );\n            newName.replace( '\\\\', '/' );\n            newText = match.captured( 1 ) + match.captured( 2 )\n                      + \"file:///\" + newName + match.captured( 2 );\n          }\n          else\n          {\n            newText = match.captured( 1 ) + match.captured( 2 )\n                      + \"bres://\" + id + \"/\"\n                      + match.captured( 3 ) + match.captured( 2 );\n          }\n          newLink = linkTxt.replace( match.capturedStart(), match.capturedLength(), newText );\n        }\n        else\n          newLink = linkTxt.replace( srcRe2,\n                                     \"\\\\1\\\"bres://\" + id + \"/\\\\2\\\"\" );\n      }\n    }\n    if( !newLink.isEmpty() )\n    {\n      articleNewText += newLink;\n    }\n    else\n      articleNewText += allLinksMatch.captured();\n  }\n  if( linkPos )\n  {\n    articleNewText += article.midRef( linkPos );\n    article = articleNewText;\n  }\n\n  return article;\n}\n#else\nQString & MdxDictionary::filterResource( QString const & articleId, QString & article )\n{\n  QString id = QString::fromStdString( getId() );\n  QString uniquePrefix = QString::fromLatin1( \"g\" ) + id + \"_\" + articleId + \"_\";\n\n  QRegExp allLinksRe( \"(?:<\\\\s*(a(?:rea)?|img|link|script|source)(?:\\\\s+[^>]+|\\\\s*)>)\", Qt::CaseInsensitive );\n  QRegExp wordCrossLink( \"([\\\\s\\\"']href\\\\s*=)\\\\s*([\\\"'])entry://([^>#]*)((?:#[^>]*)?)\\\\2\", Qt::CaseInsensitive );\n  wordCrossLink.setMinimal( true );\n\n  QRegExp anchorIdRe( \"([\\\\s\\\"'](?:name|id)\\\\s*=)\\\\s*([\\\"'])\\\\s*(?=\\\\S)\", Qt::CaseInsensitive );\n  QRegExp anchorIdRe2( \"([\\\\s\\\"'](?:name|id)\\\\s*=)\\\\s*(?=[^\\\"'])([^\\\\s\\\">]+)\", Qt::CaseInsensitive );\n  QRegExp anchorLinkRe( \"([\\\\s\\\"']href\\\\s*=\\\\s*[\\\"'])entry://#\", Qt::CaseInsensitive );\n  QRegExp audioRe( \"([\\\\s\\\"']href\\\\s*=)\\\\s*([\\\"'])sound://([^\\\">]+)\\\\2\", Qt::CaseInsensitive );\n  audioRe.setMinimal( true );\n\n  QRegExp stylesRe( \"([\\\\s\\\"']href\\\\s*=)\\\\s*([\\\"'])(?!\\\\s*\\\\b(?:(?:bres|https?|ftp)://|(?:data|javascript):))(?:file://)?[\\\\x00-\\\\x1f\\\\x7f]*\\\\.*/?([^\\\">]+)\\\\2\",\n                    Qt::CaseInsensitive, QRegExp::RegExp2 );\n  stylesRe.setMinimal( true );\n  QRegExp stylesRe2( \"([\\\\s\\\"']href\\\\s*=)\\\\s*(?![\\\\s\\\"']|\\\\b(?:(?:bres|https?|ftp)://|(?:data|javascript):))(?:file://)?[\\\\x00-\\\\x1f\\\\x7f]*\\\\.*/?([^\\\\s\\\">]+)\",\n                     Qt::CaseInsensitive, QRegExp::RegExp2 );\n  QRegExp inlineScriptRe( \"<\\\\s*script(?:(?=\\\\s)(?:(?![\\\\s\\\"']src\\\\s*=)[^>])+|\\\\s*)>\", Qt::CaseInsensitive, QRegExp::RegExp2 );\n  QRegExp closeScriptTagRe( \"<\\\\s*/script\\\\s*>\", Qt::CaseInsensitive, QRegExp::RegExp2 );\n  QRegExp srcRe( \"([\\\\s\\\"']src\\\\s*=)\\\\s*([\\\"'])(?!\\\\s*\\\\b(?:(?:bres|https?|ftp)://|(?:data|javascript):))(?:file://)?[\\\\x00-\\\\x1f\\\\x7f]*\\\\.*/?([^\\\">]+)\\\\2\",\n                     Qt::CaseInsensitive, QRegExp::RegExp2 );\n  srcRe.setMinimal( true );\n  QRegExp srcRe2( \"([\\\\s\\\"']src\\\\s*=)\\\\s*(?![\\\\s\\\"']|\\\\b(?:(?:bres|https?|ftp)://|(?:data|javascript):))(?:file://)?[\\\\x00-\\\\x1f\\\\x7f]*\\\\.*/?([^\\\\s\\\">]+)\",\n                    Qt::CaseInsensitive, QRegExp::RegExp2 );\n\n  int linkPos = 0;\n  while( linkPos >= 0 )\n  {\n    linkPos = allLinksRe.indexIn( article, linkPos );\n    if( linkPos < 0 )\n      break;\n\n    QString linkTxt = allLinksRe.cap( 0 );\n    QString linkType = allLinksRe.cap( 1 ).toLower();\n    QString newLink;\n\n    if( !linkType.isEmpty() && linkType.at( 0 ) == 'a' )\n    {\n      int pos = anchorIdRe.indexIn( linkTxt );\n      if( pos >= 0 )\n      {\n        QString newText = anchorIdRe.cap( 1 ) + anchorIdRe.cap( 2 ) + uniquePrefix;\n        newLink = linkTxt.replace( pos, anchorIdRe.cap().length(), newText );\n      }\n      else\n        newLink = linkTxt.replace( anchorIdRe2, \"\\\\1\\\"\" + uniquePrefix + \"\\\\2\\\"\" );\n\n      newLink = newLink.replace( anchorLinkRe, \"\\\\1#\" + uniquePrefix );\n\n      pos = audioRe.indexIn( newLink );\n      if( pos >= 0 )\n      {\n        // sounds and audio link script\n        QString newTxt = audioRe.cap( 1 ) + audioRe.cap( 2 )\n                         + \"gdau://\" + id + \"/\"\n                         + audioRe.cap( 3 ) + audioRe.cap( 2 );\n        newLink = QString::fromUtf8( addAudioLink( \"\\\"gdau://\" + getId() + \"/\" + audioRe.cap( 3 ).toUtf8().data() + \"\\\"\", getId() ).c_str() )\n                  + newLink.replace( pos, audioRe.cap().length(), newTxt );\n      }\n\n      pos = wordCrossLink.indexIn( newLink );\n      if( pos >= 0 )\n      {\n        QString newTxt = wordCrossLink.cap( 1 ) + wordCrossLink.cap( 2 )\n                         + \"gdlookup://localhost/\"\n                         + wordCrossLink.cap( 3 );\n\n        if( !wordCrossLink.cap( 4 ).isEmpty() )\n          newTxt += QString( \"?gdanchor=\" ) + uniquePrefix + wordCrossLink.cap( 4 ).mid( 1 );\n\n        newTxt += wordCrossLink.cap( 2 );\n        newLink.replace( pos, wordCrossLink.cap( 0 ).length(), newTxt );\n      }\n    }\n    else\n    if( linkType.compare( \"link\" ) == 0 )\n    {\n      // stylesheets\n      int pos = stylesRe.indexIn( linkTxt );\n      if( pos >= 0 )\n      {\n        QString newText = stylesRe.cap( 1 ) + stylesRe.cap( 2 )\n                          + \"bres://\" + id + \"/\"\n                          + stylesRe.cap( 3 ) + stylesRe.cap( 2 );\n        newLink = linkTxt.replace( pos, stylesRe.cap().length(), newText );\n      }\n      else\n        newLink = linkTxt.replace( stylesRe2,\n                                   \"\\\\1\\\"bres://\" + id + \"/\\\\2\\\"\" );\n    }\n    else\n    if( linkType.compare( \"script\" ) == 0 || linkType.compare( \"img\" ) == 0\n        || linkType.compare( \"source\" ) == 0 )\n    {\n      // javascripts and images\n      if( linkType.at( 0 ) == 's' && inlineScriptRe.exactMatch( linkTxt ) )\n      {\n        // skip inline scripts\n        linkPos += linkTxt.length();\n        int pos = closeScriptTagRe.indexIn( article, linkPos );\n        if( pos > 0 )\n          linkPos = pos + closeScriptTagRe.cap().length();\n        continue;\n      }\n      else\n      {\n        int pos = srcRe.indexIn( linkTxt );\n        if( pos >= 0 )\n        {\n          QString newText;\n          if( linkType.at( 1 ) == 'o' ) // \"source\" tag\n          {\n            QString filename = srcRe.cap( 3 );\n            QString newName = getCachedFileName( filename );\n            newName.replace( '\\\\', '/' );\n            newText = srcRe.cap( 1 ) + srcRe.cap( 2 )\n                      + \"file:///\" + newName + srcRe.cap( 2 );\n          }\n          else\n          {\n            newText = srcRe.cap( 1 ) + srcRe.cap( 2 )\n                      + \"bres://\" + id + \"/\"\n                      + srcRe.cap( 3 ) + srcRe.cap( 2 );\n          }\n          newLink = linkTxt.replace( pos, srcRe.cap().length(), newText );\n        }\n        else\n          newLink = linkTxt.replace( srcRe2,\n                                     \"\\\\1\\\"bres://\" + id + \"/\\\\2\\\"\" );\n      }\n    }\n    if( !newLink.isEmpty() )\n    {\n      article.replace( linkPos, allLinksRe.cap().length(), newLink );\n      linkPos += newLink.length();\n    }\n    else\n      linkPos += allLinksRe.cap().length();\n  }\n\n  return article;\n}\n#endif\n\nQString MdxDictionary::getCachedFileName( QString filename )\n{\n  QDir dir;\n  QFileInfo info( cacheDirName );\n  if( !info.exists() || !info.isDir() )\n  {\n    if( !dir.mkdir( cacheDirName ) )\n    {\n      gdWarning( \"Mdx: can't create cache directory \\\"%s\\\"\", cacheDirName.toUtf8().data() );\n      return QString();\n    }\n  }\n\n  // Create subfolders if needed\n\n  QString name = filename;\n  name.replace( '/', '\\\\' );\n  QStringList list = name.split( '\\\\' );\n  int subFolders = list.size() - 1;\n  if( subFolders > 0 )\n  {\n    QString dirName = cacheDirName;\n    for( int i = 0; i < subFolders; i++ )\n    {\n      dirName += QDir::separator() + list.at( i );\n      QFileInfo dirInfo( dirName );\n      if( !dirInfo.exists() )\n      {\n        if( !dir.mkdir( dirName ) )\n        {\n          gdWarning( \"Mdx: can't create cache directory \\\"%s\\\"\", dirName.toUtf8().data() );\n          return QString();\n        }\n      }\n    }\n  }\n\n  QString fullName = cacheDirName + QDir::separator() + filename;\n\n  info.setFile( fullName );\n  if( !info.exists() )\n  {\n    QFile f( fullName );\n    if( f.open( QFile::WriteOnly ) )\n    {\n      gd::wstring resourceName = FsEncoding::decode( filename.toStdString() );\n      vector< char > data;\n\n      // In order to prevent recursive internal redirection...\n      set< QByteArray > resourceIncluded;\n\n      for ( ;; )\n      {\n\n        string u8ResourceName = Utf8::encode( resourceName );\n        QCryptographicHash hash( QCryptographicHash::Md5 );\n        hash.addData( u8ResourceName.data(), u8ResourceName.size() );\n        if ( !resourceIncluded.insert( hash.result() ).second )\n          continue;\n\n        // Convert to the Windows separator\n        std::replace( resourceName.begin(), resourceName.end(), '/', '\\\\' );\n        if ( resourceName[ 0 ] != '\\\\' )\n        {\n          resourceName.insert( 0, 1, '\\\\' );\n        }\n\n        try\n        {\n          // local file takes precedence\n          string fn = FsEncoding::dirname( getDictionaryFilenames()[ 0 ] ) +\n                      FsEncoding::separator() + u8ResourceName;\n          File::loadFromFile( fn, data );\n        }\n        catch ( File::exCantOpen & )\n        {\n          for ( vector< sptr< IndexedMdd > >::const_iterator i = mddResources.begin();\n                i != mddResources.end(); ++i )\n          {\n            if ( ( *i )->loadFile( resourceName, data ) )\n              break;\n          }\n        }\n\n        // Check if this file has a redirection\n        // Always encoded in UTF16-LE\n        // L\"@@@LINK=\"\n        static const char pattern[16] =\n        {\n          '@', '\\0', '@', '\\0', '@', '\\0', 'L', '\\0', 'I', '\\0', 'N', '\\0', 'K', '\\0', '=', '\\0'\n        };\n\n        if ( data.size() > sizeof( pattern ) )\n        {\n          if ( memcmp( &data.front(),  pattern, sizeof( pattern ) ) == 0 )\n          {\n            data.push_back( '\\0' );\n            data.push_back( '\\0' );\n            QString target = MdictParser::toUtf16( \"UTF-16LE\", &data.front() + sizeof( pattern ),\n                                                   data.size() - sizeof( pattern ) );\n            resourceName = gd::toWString( target.trimmed() );\n            continue;\n          }\n        }\n        break;\n      }\n\n      qint64 n = 0;\n      if( !data.empty() )\n        n = f.write( data.data(), data.size() );\n\n      f.close();\n\n      if( n < (qint64)data.size() )\n      {\n        gdWarning( \"Mdx: file \\\"%s\\\" writing error: \\\"%s\\\"\", fullName.toUtf8().data(),\n                                                             f.errorString().toUtf8().data() );\n        return QString();\n      }\n    }\n    else\n    {\n      gdWarning( \"Mdx: file \\\"%s\\\" creating error: \\\"%s\\\"\", fullName.toUtf8().data(),\n                                                            f.errorString().toUtf8().data() );\n      return QString();\n    }\n  }\n  return fullName;\n}\n\nvoid MdxDictionary::removeDirectory( QString const & directory )\n{\n  QDir dir( directory );\n  Q_FOREACH( QFileInfo info, dir.entryInfoList( QDir::NoDotAndDotDot\n                                                | QDir::AllDirs\n                                                | QDir::Files,\n                                                QDir::DirsFirst))\n  {\n    if( info.isDir() )\n      removeDirectory( info.absoluteFilePath() );\n    else\n      QFile::remove( info.absoluteFilePath() );\n  }\n\n  dir.rmdir( directory );\n}\n\nstatic void addEntryToIndex( QString const & word, uint32_t offset, IndexedWords & indexedWords )\n{\n  // Strip any leading or trailing whitespaces\n  QString wordTrimmed = word.trimmed();\n  indexedWords.addWord( gd::toWString( wordTrimmed ), offset );\n}\n\nstatic void addEntryToIndexSingle( QString const & word, uint32_t offset, IndexedWords & indexedWords )\n{\n  // Strip any leading or trailing whitespaces\n  QString wordTrimmed = word.trimmed();\n  indexedWords.addSingleWord( gd::toWString( wordTrimmed ), offset );\n}\n\nclass ArticleHandler: public MdictParser::RecordHandler\n{\npublic:\n  ArticleHandler( ChunkedStorage::Writer & chunks, IndexedWords & indexedWords ) :\n    chunks( chunks ),\n    indexedWords( indexedWords )\n  {\n  }\n\n  virtual void handleRecord( QString const & headWord, MdictParser::RecordInfo const & recordInfo )\n  {\n    // Save the article's record info\n    uint32_t articleAddress = chunks.startNewBlock();\n    chunks.addToBlock( &recordInfo, sizeof( recordInfo ) );\n    // Add entries to the index\n    addEntryToIndex( headWord, articleAddress, indexedWords );\n  }\n\nprivate:\n  ChunkedStorage::Writer & chunks;\n  IndexedWords & indexedWords;\n};\n\nclass ResourceHandler: public MdictParser::RecordHandler\n{\npublic:\n  ResourceHandler( ChunkedStorage::Writer & chunks, IndexedWords & indexedWords ):\n    chunks( chunks ),\n    indexedWords( indexedWords )\n  {\n  }\n\n  virtual void handleRecord( QString const & fileName, MdictParser::RecordInfo const & recordInfo )\n  {\n    uint32_t resourceInfoAddress = chunks.startNewBlock();\n    chunks.addToBlock( &recordInfo, sizeof( recordInfo ) );\n    // Add entries to the index\n    addEntryToIndexSingle( fileName, resourceInfoAddress, indexedWords );\n  }\n\nprivate:\n  ChunkedStorage::Writer & chunks;\n  IndexedWords & indexedWords;\n};\n\n\nstatic bool indexIsOldOrBad( vector< string > const & dictFiles, string const & indexFile )\n{\n  File::Class idx( indexFile, \"rb\" );\n  IdxHeader header;\n\n  return idx.readRecords( &header, sizeof( header ), 1 ) != 1 ||\n         header.signature != kSignature ||\n         header.formatVersion != kCurrentFormatVersion ||\n         header.parserVersion != MdictParser::kParserVersion ||\n         header.foldingVersion != Folding::Version ||\n         header.mddIndexInfosCount != dictFiles.size() - 1;\n}\n\nstatic void findResourceFiles( string const & mdx, vector< string > & dictFiles )\n{\n  string base( mdx, 0, mdx.size() - 4 );\n  // Check if there' is any file end with .mdd, which is the resource file for the dictionary\n  string resFile;\n  if ( File::tryPossibleName( base + \".mdd\", resFile ) )\n  {\n    dictFiles.push_back( resFile );\n    // Find complementary .mdd file (volumes), like follows:\n    //   demo.mdx   <- main dictionary file\n    //   demo.mdd   <- main resource file ( 1st volume )\n    //   demo.1.mdd <- 2nd volume\n    //   ...\n    //   demo.n.mdd <- nth volume\n    QString baseU8 = QString::fromUtf8( base.c_str() );\n    int vol = 1;\n    while ( File::tryPossibleName( string( QString( \"%1.%2.mdd\" ).arg( baseU8 ).arg( vol )\n                                           .toUtf8().constBegin() ), resFile ) )\n    {\n      dictFiles.push_back( resFile );\n      vol++;\n    }\n  }\n}\n\nvector< sptr< Dictionary::Class > > makeDictionaries( vector< string > const & fileNames,\n                                                      string const & indicesDir,\n                                                      Dictionary::Initializing & initializing ) THROW_SPEC( std::exception )\n{\n  vector< sptr< Dictionary::Class > > dictionaries;\n\n  for ( vector< string >::const_iterator i = fileNames.begin(); i != fileNames.end(); ++i )\n  {\n    // Skip files with the extensions different to .mdx to speed up the\n    // scanning\n    if ( i->size() < 4 || strcasecmp( i->c_str() + ( i->size() - 4 ), \".mdx\" ) != 0 )\n      continue;\n\n    vector< string > dictFiles( 1, *i );\n    findResourceFiles( *i, dictFiles );\n\n    string dictId = Dictionary::makeDictionaryId( dictFiles );\n    string indexFile = indicesDir + dictId;\n\n    if ( Dictionary::needToRebuildIndex( dictFiles, indexFile ) ||\n         indexIsOldOrBad( dictFiles, indexFile ) )\n    {\n      // Building the index\n\n      gdDebug( \"MDict: Building the index for dictionary: %s\\n\", i->c_str() );\n\n      MdictParser parser;\n      list< sptr< MdictParser > > mddParsers;\n\n      if ( !parser.open( i->c_str() ) )\n        continue;\n\n      string title = string( parser.title().toUtf8().constData() );\n      initializing.indexingDictionary( title );\n\n      for ( vector< string >::const_iterator mddIter = dictFiles.begin() + 1;\n            mddIter != dictFiles.end(); ++mddIter )\n      {\n        if ( File::exists( *mddIter ) )\n        {\n          sptr< MdictParser > mddParser = new MdictParser();\n          if ( !mddParser->open( mddIter->c_str() ) )\n          {\n            gdWarning( \"Broken mdd (resource) file: %s\\n\", mddIter->c_str() );\n            continue;\n          }\n          mddParsers.push_back( mddParser );\n        }\n      }\n\n      File::Class idx( indexFile, \"wb\" );\n      IdxHeader idxHeader;\n      memset( &idxHeader, 0, sizeof( idxHeader ) );\n      // We write a dummy header first. At the end of the process the header\n      // will be rewritten with the right values.\n      idx.write( idxHeader );\n\n      // Write the title first\n      idx.write< uint32_t >( title.size() );\n      idx.write( title.data(), title.size() );\n\n      // then the encoding\n      {\n        string encoding = string( parser.encoding().toUtf8().constData() );\n        idx.write< uint32_t >( encoding.size() );\n        idx.write( encoding.data(), encoding.size() );\n      }\n\n      // This is our index data that we accumulate during the loading process.\n      // For each new word encountered, we emit the article's body to the file\n      // immediately, inserting the word itself and its offset in this map.\n      // This map maps folded words to the original words and the corresponding\n      // articles' offsets.\n      IndexedWords indexedWords;\n      ChunkedStorage::Writer chunks( idx );\n\n      idxHeader.isRightToLeft = parser.isRightToLeft();\n\n      // Save dictionary description if there's one\n      {\n        string description = string( parser.description().toUtf8().constData() );\n        idxHeader.descriptionAddress = chunks.startNewBlock();\n        chunks.addToBlock( description.c_str(), description.size() + 1 );\n        idxHeader.descriptionSize = description.size() + 1;\n      }\n\n      ArticleHandler articleHandler( chunks, indexedWords );\n      MdictParser::HeadWordIndex headWordIndex;\n\n      // enumerating word and its definition\n      while ( parser.readNextHeadWordIndex( headWordIndex ) )\n      {\n        parser.readRecordBlock( headWordIndex, articleHandler );\n      }\n\n      // enumerating resources if there's any\n      vector< sptr< IndexedWords > > mddIndices;\n      vector< string > mddFileNames;\n      while ( !mddParsers.empty() )\n      {\n        sptr< MdictParser > mddParser = mddParsers.front();\n        sptr< IndexedWords > mddIndexedWords = new IndexedWords();\n        MdictParser::HeadWordIndex resourcesIndex;\n        ResourceHandler resourceHandler( chunks, *mddIndexedWords );\n\n        while ( mddParser->readNextHeadWordIndex( headWordIndex ) )\n        {\n          resourcesIndex.insert( resourcesIndex.end(), headWordIndex.begin(), headWordIndex.end() );\n        }\n        mddParser->readRecordBlock( resourcesIndex, resourceHandler );\n\n        mddIndices.push_back( mddIndexedWords );\n        // Save filename for .mdd files only\n        QFileInfo fi( mddParser->filename() );\n        mddFileNames.push_back( string( fi.fileName().toUtf8().constData() ) );\n        mddParsers.pop_front();\n      }\n\n      // Finish with the chunks\n      idxHeader.chunksOffset = chunks.finish();\n\n      GD_DPRINTF( \"Writing index...\\n\" );\n\n      // Good. Now build the index\n      IndexInfo idxInfo = BtreeIndexing::buildIndex( indexedWords, idx );\n      idxHeader.indexBtreeMaxElements = idxInfo.btreeMaxElements;\n      idxHeader.indexRootOffset = idxInfo.rootOffset;\n\n      // Save dictionary stylesheets\n      {\n        MdictParser::StyleSheets const & styleSheets = parser.styleSheets();\n        idxHeader.styleSheetAddress = idx.tell();\n        idxHeader.styleSheetCount = styleSheets.size();\n\n        for ( MdictParser::StyleSheets::const_iterator iter = styleSheets.begin();\n              iter != styleSheets.end(); ++iter )\n        {\n          string styleBegin( iter->second.first.toUtf8().constData() );\n          string styleEnd( iter->second.second.toUtf8().constData() );\n\n          // key\n          idx.write<qint32>( iter->first );\n          // styleBegin\n          idx.write<quint32>( ( quint32 )styleBegin.size() + 1 );\n          idx.write( styleBegin.c_str(), styleBegin.size() + 1 );\n          // styleEnd\n          idx.write<quint32>( ( quint32 )styleEnd.size() + 1 );\n          idx.write( styleEnd.c_str(), styleEnd.size() + 1 );\n        }\n      }\n\n      // read languages\n      QPair<quint32, quint32> langs = LangCoder::findIdsForFilename( QString::fromStdString( *i ) );\n\n      // if no languages found, try dictionary's name\n      if ( langs.first == 0 || langs.second == 0 )\n      {\n        langs = LangCoder::findIdsForFilename( parser.title() );\n      }\n\n      idxHeader.langFrom = langs.first;\n      idxHeader.langTo = langs.second;\n\n      // Build index info for each mdd file\n      vector< IndexInfo > mddIndexInfos;\n      for ( vector< sptr< IndexedWords > >::const_iterator mddIndexIter = mddIndices.begin();\n            mddIndexIter != mddIndices.end(); ++mddIndexIter )\n      {\n        IndexInfo resourceIdxInfo = BtreeIndexing::buildIndex( *( *mddIndexIter ), idx );\n        mddIndexInfos.push_back( resourceIdxInfo );\n      }\n\n      // Save address of IndexInfos for resource files\n      idxHeader.mddIndexInfosOffset = idx.tell();\n      idxHeader.mddIndexInfosCount = mddIndexInfos.size();\n      for ( uint32_t mi = 0; mi < mddIndexInfos.size(); mi++ )\n      {\n        const string & mddfile = mddFileNames[ mi ];\n\n        idx.write<quint32>( ( quint32 )mddfile.size() + 1 );\n        idx.write( mddfile.c_str(), mddfile.size() + 1 );\n        idx.write<uint32_t>( mddIndexInfos[ mi ].btreeMaxElements );\n        idx.write<uint32_t>( mddIndexInfos[ mi ].rootOffset );\n      }\n\n      // That concludes it. Update the header.\n      idxHeader.signature = kSignature;\n      idxHeader.formatVersion = kCurrentFormatVersion;\n      idxHeader.parserVersion = MdictParser::kParserVersion;\n      idxHeader.foldingVersion = Folding::Version;\n      idxHeader.articleCount = parser.wordCount();\n      idxHeader.wordCount = parser.wordCount();\n\n      idx.rewind();\n      idx.write( &idxHeader, sizeof( idxHeader ) );\n    }\n\n    dictionaries.push_back( new MdxDictionary( dictId, indexFile, dictFiles ) );\n  }\n\n  return dictionaries;\n}\n\n}\n"
        },
        {
          "name": "mdx.hh",
          "type": "blob",
          "size": 0.58984375,
          "content": "/* This file is (c) 2013 Timon Wong <timon86.wang AT gmail DOT com>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __MDX_HH_INCLUDED__\n#define __MDX_HH_INCLUDED__\n\n#include \"dictionary.hh\"\n\nnamespace Mdx\n{\n\nusing std::vector;\nusing std::string;\n\nvector< sptr< Dictionary::Class > > makeDictionaries( vector< string > const & fileNames,\n                                                      string const & indicesDir,\n                                                      Dictionary::Initializing & ) THROW_SPEC( std::exception );\n\n}\n\n#endif // __MDX_HH_INCLUDED__\n"
        },
        {
          "name": "mediawiki.cc",
          "type": "blob",
          "size": 27.46484375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"mediawiki.hh\"\n#include \"wstring_qt.hh\"\n#include <QNetworkAccessManager>\n#include <QNetworkReply>\n#include <QUrl>\n#include <QtXml>\n#include <algorithm>\n#include <list>\n#include \"gddebug.hh\"\n#include \"audiolink.hh\"\n#include \"langcoder.hh\"\n#include \"qt4x5.hh\"\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n#include <QRegularExpression>\n#endif\n\nnamespace MediaWiki {\n\nusing namespace Dictionary;\n\nnamespace {\n\nclass MediaWikiDictionary: public Dictionary::Class\n{\n  string name;\n  QString url, icon;\n  QNetworkAccessManager & netMgr;\n  quint32 langId;\n\npublic:\n\n  MediaWikiDictionary( string const & id, string const & name_,\n                       QString const & url_,\n                       QString const & icon_,\n                       QNetworkAccessManager & netMgr_ ):\n    Dictionary::Class( id, vector< string >() ),\n    name( name_ ),\n    url( url_ ),\n    icon( icon_ ),\n    netMgr( netMgr_ ),\n    langId( 0 )\n  {\n    int n = url.indexOf( \".\" );\n    if( n == 2 || ( n > 3 && url[ n-3 ] == '/' ) )\n      langId = LangCoder::code2toInt( url.mid( n - 2, 2 ).toLatin1().data() );\n  }\n\n  virtual string getName() throw()\n  { return name; }\n\n  virtual map< Property, string > getProperties() throw()\n  { return map< Property, string >(); }\n\n  virtual unsigned long getArticleCount() throw()\n  { return 0; }\n\n  virtual unsigned long getWordCount() throw()\n  { return 0; }\n\n  virtual sptr< WordSearchRequest > prefixMatch( wstring const &,\n                                                 unsigned long maxResults ) THROW_SPEC( std::exception );\n\n  virtual sptr< DataRequest > getArticle( wstring const &, vector< wstring > const & alts,\n                                          wstring const &, bool )\n    THROW_SPEC( std::exception );\n\n  virtual quint32 getLangFrom() const\n  { return langId; }\n\n  virtual quint32 getLangTo() const\n  { return langId; }\n\nprotected:\n\n  virtual void loadIcon() throw();\n\n};\n\nvoid MediaWikiDictionary::loadIcon() throw()\n{\n  if ( dictionaryIconLoaded )\n    return;\n\n  if( !icon.isEmpty() )\n  {\n    QFileInfo fInfo(  QDir( Config::getConfigDir() ), icon );\n    if( fInfo.isFile() )\n      loadIconFromFile( fInfo.absoluteFilePath(), true );\n  }\n  if( dictionaryIcon.isNull() )\n    dictionaryIcon = dictionaryNativeIcon = QIcon(\":/icons/icon32_wiki.png\");\n  dictionaryIconLoaded = true;\n}\n\nclass MediaWikiWordSearchRequest: public MediaWikiWordSearchRequestSlots\n{\n  sptr< QNetworkReply > netReply;\n  bool livedLongEnough; // Indicates that the request has lived long enough\n                        // to be destroyed prematurely. Used to prevent excessive\n                        // network loads when typing search terms rapidly.\n  bool isCancelling;\n\npublic:\n\n  MediaWikiWordSearchRequest( wstring const &,\n                              QString const & url, QNetworkAccessManager & mgr );\n\n  ~MediaWikiWordSearchRequest();\n\n  virtual void cancel();\n\nprotected:\n\n  virtual void timerEvent( QTimerEvent * );\n\nprivate:\n\n  virtual void downloadFinished();\n};\n\nMediaWikiWordSearchRequest::MediaWikiWordSearchRequest( wstring const & str,\n                                                        QString const & url,\n                                                        QNetworkAccessManager & mgr ):\n  livedLongEnough( false ), isCancelling( false )\n{\n  GD_DPRINTF( \"request begin\\n\" );\n  QUrl reqUrl( url + \"/api.php?action=query&list=allpages&aplimit=40&format=xml\" );\n\n#if IS_QT_5\n  Qt4x5::Url::addQueryItem( reqUrl, \"apfrom\", gd::toQString( str ).replace( '+', \"%2B\" ) );\n#else\n  reqUrl.addEncodedQueryItem( \"apfrom\", QUrl::toPercentEncoding( gd::toQString( str ) ) );\n#endif\n\n  netReply = mgr.get( QNetworkRequest( reqUrl ) );\n\n  connect( netReply.get(), SIGNAL( finished() ),\n           this, SLOT( downloadFinished() ) );\n\n#ifndef QT_NO_OPENSSL\n\n  connect( netReply.get(), SIGNAL( sslErrors( QList< QSslError > ) ),\n           netReply.get(), SLOT( ignoreSslErrors() ) );\n\n#endif\n\n  // We start a timer to postpone early destruction, so a rapid type won't make\n  // unnecessary network load\n  startTimer( 200 );\n}\n\nvoid MediaWikiWordSearchRequest::timerEvent( QTimerEvent * ev )\n{\n  killTimer( ev->timerId() );\n  livedLongEnough = true;\n\n  if ( isCancelling )\n    finish();\n}\n\nMediaWikiWordSearchRequest::~MediaWikiWordSearchRequest()\n{\n  GD_DPRINTF( \"request end\\n\" );\n}\n\nvoid MediaWikiWordSearchRequest::cancel()\n{\n  // We either finish it in place, or in the timer handler\n  isCancelling = true;\n\n  if ( netReply.get() )\n    netReply.reset();\n\n  if ( livedLongEnough )\n  {\n    finish();\n  }\n  else\n  {\n    GD_DPRINTF(\"not long enough\\n\" );\n  }\n}\n\nvoid MediaWikiWordSearchRequest::downloadFinished()\n{\n  if ( isCancelling || isFinished() ) // Was cancelled\n    return;\n\n  if ( netReply->error() == QNetworkReply::NoError )\n  {\n    QDomDocument dd;\n\n    QString errorStr;\n    int errorLine, errorColumn;\n\n    if ( !dd.setContent( netReply.get(), false, &errorStr, &errorLine, &errorColumn  ) )\n    {\n      setErrorString( QString( tr( \"XML parse error: %1 at %2,%3\" ).\n                               arg( errorStr ).arg( errorLine ).arg( errorColumn ) ) );\n    }\n    else\n    {\n      QDomNode pages = dd.namedItem( \"api\" ).namedItem( \"query\" ).namedItem( \"allpages\" );\n\n      if ( !pages.isNull() )\n      {\n        QDomNodeList nl = pages.toElement().elementsByTagName( \"p\" );\n\n        Mutex::Lock _( dataMutex );\n\n        for( Qt4x5::Dom::size_type x = 0; x < nl.length(); ++x )\n          matches.push_back( gd::toWString( nl.item( x ).toElement().attribute( \"title\" ) ) );\n      }\n    }\n    GD_DPRINTF( \"done.\\n\" );\n  }\n  else\n    setErrorString( netReply->errorString() );\n\n  finish();\n}\n\nclass MediaWikiSectionsParser\n{\npublic:\n  /// Since a recent Wikipedia UI redesign, the table of contents (ToC) is no longer part of an article's HTML.\n  /// ToC is absent from the text node of Wikipedia's MediaWiki API reply. Quote from\n  /// https://www.mediawiki.org/wiki/Reading/Web/Desktop_Improvements/Features/Table_of_contents#How_can_I_get_the_old_table_of_contents?\n  /// We intentionally do not add the old table of contents to the article in addition to the new sidebar location...\n  /// Users can restore the old table of contents position with the following JavaScript code:\n  /// document.querySelector('mw\\\\3Atocplace,meta[property=\"mw:PageProp/toc\"]').replaceWith( document.getElementById('mw-panel-toc') )\n  ///\n  /// This function searches for an indicator of the empty ToC in an article HTML. If the indicator is present,\n  /// generates ToC HTML from the sections element and replaces the indicator with the generated ToC.\n  static void generateTableOfContentsIfEmpty( QDomNode const & parseNode, QString & articleString )\n  {\n    QString const emptyTocIndicator = \"<meta property=\\\"mw:PageProp/toc\\\" />\";\n    int const emptyTocPos = articleString.indexOf( emptyTocIndicator );\n    if( emptyTocPos == -1 )\n      return; // The ToC must be absent or nonempty => nothing to do.\n\n    QDomElement const sectionsElement = parseNode.firstChildElement( \"sections\" );\n    if( sectionsElement.isNull() )\n    {\n      gdWarning( \"MediaWiki: empty table of contents and missing sections element.\" );\n      return;\n    }\n\n    gdDebug( \"MediaWiki: generating table of contents from the sections element.\" );\n    MediaWikiSectionsParser parser;\n    parser.generateTableOfContents( sectionsElement );\n    articleString.replace( emptyTocPos, emptyTocIndicator.size(), parser.tableOfContents );\n  }\n\nprivate:\n  MediaWikiSectionsParser() : previousLevel( 0 ) {}\n  void generateTableOfContents( QDomElement const & sectionsElement );\n\n  bool addListLevel( QString const & levelString );\n  void closeListTags( int currentLevel );\n\n  QString tableOfContents;\n  int previousLevel;\n};\n\nvoid MediaWikiSectionsParser::generateTableOfContents( QDomElement const & sectionsElement )\n{\n  // A real example of a typical child of the <sections> element:\n  // <s linkAnchor=\"Marginal_densities\" toclevel=\"2\" fromtitle=\"Probability_density_function\" level=\"3\"\n  //  line=\"Marginal densities\" byteoffset=\"15868\" anchor=\"Marginal_densities\" number=\"7.1\" index=\"9\"/>\n\n  // Use Wiktionary's ToC style, which had also been Wikipedia's ToC style until the UI redesign.\n  // Replace double quotes with single quotes to avoid escaping \" within string literals.\n\n  QString const elTagName = \"s\";\n  QDomElement el = sectionsElement.firstChildElement( elTagName );\n  if( el.isNull() )\n    return;\n\n  // Omit invisible and useless toctogglecheckbox, toctogglespan and toctogglelabel elements.\n  // The values of lang (e.g. 'en') and dir (e.g. 'ltr') attributes of the toctitle element depend on\n  // the article's language. These attributes have no visible effect and so are simply omitted here.\n  // TODO: the \"Contents\" string should be translated to the article's language, but I don't know how\n  // to implement this. Should \"Contents\" be enclosed in tr() to at least translate it to GoldenDict's\n  // interface language? Is there a language-agnostic Unicode symbol that stands for \"Contents\"?\n  tableOfContents = \"<div id='toc' class='toc' role='navigation' aria-labelledby='mw-toc-heading'>\"\n                    \"<div class='toctitle'><h2 id='mw-toc-heading'>Contents</h2></div>\";\n\n  do\n  {\n    if( !addListLevel( el.attribute( \"toclevel\" ) ) )\n    {\n      tableOfContents.clear();\n      return;\n    }\n\n    // From https://gerrit.wikimedia.org/r/c/mediawiki/core/+/831147/\n    // The anchor property ... should be used if you want to (eg) look up an element by ID using\n    // document.getElementById(). The linkAnchor property ... contains additional escaping appropriate for\n    // use in a URL fragment, and should be used (eg) if you are creating the href attribute of an <a> tag.\n    tableOfContents += \"<a href='#\";\n    tableOfContents += el.attribute( \"linkAnchor\" );\n    tableOfContents += \"'>\";\n\n    // Omit <span class=\"tocnumber\"> because it has no visible effect.\n    tableOfContents += el.attribute( \"number\" );\n    tableOfContents += ' ';\n    // Omit <span class=\"toctext\"> because it has no visible effect.\n    tableOfContents += el.attribute( \"line\" );\n\n    tableOfContents += \"</a>\";\n\n    el = el.nextSiblingElement( elTagName );\n  } while( !el.isNull() );\n\n  closeListTags( 1 );\n  // Close the first-level list tag and the toc div tag.\n  tableOfContents += \"</ul>\\n</div>\";\n}\n\nbool MediaWikiSectionsParser::addListLevel( QString const & levelString )\n{\n  bool convertedToInt;\n  int const level = levelString.toInt( &convertedToInt );\n\n  if( !convertedToInt )\n  {\n    gdWarning( \"MediaWiki: sections level is not an integer: %s\", levelString.toUtf8().constData() );\n    return false;\n  }\n  if( level <= 0 )\n  {\n    gdWarning( \"MediaWiki: unsupported nonpositive sections level: %s\", levelString.toUtf8().constData() );\n    return false;\n  }\n  if( level > previousLevel + 1 )\n  {\n    gdWarning( \"MediaWiki: unsupported sections level increase by more than one: from %d to %s\",\n               previousLevel, levelString.toUtf8().constData() );\n    return false;\n  }\n\n  if( level == previousLevel + 1 )\n  {\n    // Don't close the previous list item tag to nest the current deeper level's list in it.\n    tableOfContents += \"\\n<ul>\\n\";\n    previousLevel = level;\n  }\n  else\n    closeListTags( level );\n  Q_ASSERT( level == previousLevel );\n\n  // Open this list item tag.\n  // Omit the (e.g.) class=\"toclevel-4 tocsection-9\" attribute of <li> because it has no visible effect.\n  tableOfContents += \"<li>\";\n\n  return true;\n}\n\nvoid MediaWikiSectionsParser::closeListTags( int currentLevel )\n{\n  Q_ASSERT( currentLevel <= previousLevel );\n\n  // Close the previous list item tag.\n  tableOfContents += \"</li>\\n\";\n  // Close list and list item tags of deeper levels, if any.\n  while( currentLevel < previousLevel )\n  {\n    tableOfContents += \"</ul>\\n</li>\\n\";\n    --previousLevel;\n  }\n}\n\nclass MediaWikiArticleRequest: public MediaWikiDataRequestSlots\n{\n  typedef std::list< std::pair< QNetworkReply *, bool > > NetReplies;\n  NetReplies netReplies;\n  QString url;\n\npublic:\n\n  MediaWikiArticleRequest( wstring const & word, vector< wstring > const & alts,\n                           QString const & url, QNetworkAccessManager & mgr,\n                           Class * dictPtr_ );\n\n  virtual void cancel();\n\nprivate:\n\n  void addQuery( QNetworkAccessManager & mgr, wstring const & word );\n\n  virtual void requestFinished( QNetworkReply * );\n\n  /// This simple set implementation should be much more efficient than tree-\n  /// and hash-based standard/Qt containers when there are very few elements.\n  template< typename T >\n  class SmallSet {\n  public:\n    bool insert( T x )\n    {\n      if( std::find( elements.begin(), elements.end(), x ) != elements.end() )\n        return false;\n      elements.push_back( x );\n      return true;\n    }\n  private:\n    std::vector< T > elements;\n  };\n\n  /// The page id set allows to filter out duplicate articles in case MediaWiki\n  /// redirects the main word and words in the alts collection to the same page.\n  SmallSet< long long > addedPageIds;\n  Class * dictPtr;\n};\n\nvoid MediaWikiArticleRequest::cancel()\n{\n  finish();\n}\n\nMediaWikiArticleRequest::MediaWikiArticleRequest( wstring const & str,\n                                                  vector< wstring > const & alts,\n                                                  QString const & url_,\n                                                  QNetworkAccessManager & mgr,\n                                                  Class * dictPtr_ ):\n  url( url_ ), dictPtr( dictPtr_ )\n{\n  connect( &mgr, SIGNAL( finished( QNetworkReply * ) ),\n           this, SLOT( requestFinished( QNetworkReply * ) ),\n           Qt::QueuedConnection );\n  \n  addQuery(  mgr, str );\n\n  for( unsigned x = 0; x < alts.size(); ++x )\n    addQuery( mgr, alts[ x ] );\n}\n\nvoid MediaWikiArticleRequest::addQuery( QNetworkAccessManager & mgr,\n                                        wstring const & str )\n{\n  gdDebug( \"MediaWiki: requesting article %s\\n\", gd::toQString( str ).toUtf8().data() );\n\n  QUrl reqUrl( url + \"/api.php?action=parse&prop=text|revid|sections&format=xml&redirects\" );\n\n#if IS_QT_5\n  Qt4x5::Url::addQueryItem( reqUrl, \"page\", gd::toQString( str ).replace( '+', \"%2B\" ) );\n#else\n  reqUrl.addEncodedQueryItem( \"page\", QUrl::toPercentEncoding( gd::toQString( str ) ) );\n#endif\n\n  QNetworkReply * netReply = mgr.get( QNetworkRequest( reqUrl ) );\n  \n#ifndef QT_NO_OPENSSL\n\n  connect( netReply, SIGNAL( sslErrors( QList< QSslError > ) ),\n           netReply, SLOT( ignoreSslErrors() ) );\n\n#endif\n\n  netReplies.push_back( std::make_pair( netReply, false ) );\n}\n\nvoid MediaWikiArticleRequest::requestFinished( QNetworkReply * r )\n{\n  GD_DPRINTF( \"Finished.\\n\" );\n\n  if ( isFinished() ) // Was cancelled\n    return;\n\n  // Find this reply\n\n  bool found = false;\n  \n  for( NetReplies::iterator i = netReplies.begin(); i != netReplies.end(); ++i )\n  {\n    if ( i->first == r )\n    {\n      i->second = true; // Mark as finished\n      found = true;\n      break;\n    }\n  }\n\n  if ( !found )\n  {\n    // Well, that's not our reply, don't do anything\n    return;\n  }\n  \n  bool updated = false;\n\n  for( ; netReplies.size() && netReplies.front().second; netReplies.pop_front() )\n  {\n    QNetworkReply * netReply = netReplies.front().first;\n    \n    if ( netReply->error() == QNetworkReply::NoError )\n    {\n      QDomDocument dd;\n  \n      QString errorStr;\n      int errorLine, errorColumn;\n  \n      if ( !dd.setContent( netReply, false, &errorStr, &errorLine, &errorColumn  ) )\n      {\n        setErrorString( QString( tr( \"XML parse error: %1 at %2,%3\" ).\n                                 arg( errorStr ).arg( errorLine ).arg( errorColumn ) ) );\n      }\n      else\n      {\n        QDomNode parseNode = dd.namedItem( \"api\" ).namedItem( \"parse\" );\n  \n        if ( !parseNode.isNull() && parseNode.toElement().attribute( \"revid\" ) != \"0\"\n             // Don't show the same article more than once:\n             && addedPageIds.insert( parseNode.toElement().attribute( \"pageid\" ).toLongLong() ) )\n        {\n          QDomNode textNode = parseNode.namedItem( \"text\" );\n  \n          if ( !textNode.isNull() )\n          {\n            QString articleString = textNode.toElement().text();\n\n            // Replace all \":\" in links, remove '#' part in links to other articles\n            int pos = 0;\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n            QRegularExpression regLinks( \"<a\\\\s+href=\\\"/([^\\\"]+)\\\"\" );\n            QString articleNewString;\n            QRegularExpressionMatchIterator it = regLinks.globalMatch( articleString );\n            while( it.hasNext() )\n            {\n              QRegularExpressionMatch match = it.next();\n              articleNewString += articleString.midRef( pos, match.capturedStart() - pos );\n              pos = match.capturedEnd();\n\n              QString link = match.captured( 1 );\n#else\n            QRegExp regLinks( \"<a\\\\s+href=\\\"/([^\\\"]+)\\\"\" );\n            for( ; ; )\n            {\n              pos = regLinks.indexIn( articleString, pos );\n              if( pos < 0 )\n                break;\n              QString link = regLinks.cap( 1 );\n#endif\n              if( link.indexOf( \"://\" ) >= 0 )\n              {\n                // External link\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n                articleNewString += match.captured();\n#else\n                pos += regLinks.cap().size();\n#endif\n                continue;\n              }\n\n              if( link.indexOf( ':' ) >= 0 )\n                link.replace( ':', \"%3A\" );\n\n              int n = link.indexOf( '#', 1 );\n              if( n > 0 )\n              {\n                QString anchor = link.mid( n + 1 ).replace( '_', \"%5F\" );\n                link.truncate( n );\n                link += QString( \"?gdanchor=%1\" ).arg( anchor );\n              }\n\n              QString newLink = QString( \"<a href=\\\"/%1\\\"\" ).arg( link );\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n              articleNewString += newLink;\n            }\n            if( pos )\n            {\n              articleNewString += articleString.midRef( pos );\n              articleString = articleNewString;\n              articleNewString.clear();\n            }\n#else\n              articleString.replace( pos, regLinks.cap().size(), newLink );\n              pos += newLink.size();\n            }\n#endif\n\n            QUrl wikiUrl( url );\n            wikiUrl.setPath( \"/\" );\n  \n            // Update any special index.php pages to be absolute\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n            articleString.replace( QRegularExpression( \"<a\\\\shref=\\\"(/([\\\\w]*/)*index.php\\\\?)\" ),\n                                   QString( \"<a href=\\\"%1\\\\1\" ).arg( wikiUrl.toString() ) );\n#else\n            articleString.replace( QRegExp( \"<a\\\\shref=\\\"(/(\\\\w*/)*index.php\\\\?)\" ),\n                                   QString( \"<a href=\\\"%1\\\\1\" ).arg( wikiUrl.toString() ) );\n#endif\n\n            // audio tag\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n            QRegularExpression reg1( \"<audio\\\\s.+?</audio>\",\n                                     QRegularExpression::CaseInsensitiveOption\n                                     | QRegularExpression::DotMatchesEverythingOption );\n            QRegularExpression reg2( \"<source\\\\s+src=\\\"([^\\\"]+)\",\n                                     QRegularExpression::CaseInsensitiveOption );\n            pos = 0;\n            it = reg1.globalMatch( articleString );\n            while( it.hasNext() )\n            {\n              QRegularExpressionMatch match = it.next();\n              articleNewString += articleString.midRef( pos, match.capturedStart() - pos );\n              pos = match.capturedEnd();\n\n              QString tag = match.captured();\n              QRegularExpressionMatch match2 = reg2.match( tag );\n              if( match2.hasMatch() )\n              {\n                QString ref = match2.captured( 1 );\n                QString audio_url = \"<a href=\\\"\" + ref\n                                    + \"\\\"><img src=\\\"qrcx://localhost/icons/playsound.png\\\" border=\\\"0\\\" align=\\\"absmiddle\\\" alt=\\\"Play\\\"/></a>\";\n                articleNewString += audio_url;\n              }\n              else\n                articleNewString += match.captured();\n            }\n            if( pos )\n            {\n              articleNewString += articleString.midRef( pos );\n              articleString = articleNewString;\n              articleNewString.clear();\n            }\n#else\n            QRegExp reg1( \"<audio\\\\s.+</audio>\", Qt::CaseInsensitive, QRegExp::RegExp2 );\n            reg1.setMinimal( true );\n            QRegExp reg2( \"<source\\\\s+src=\\\"([^\\\"]+)\", Qt::CaseInsensitive );\n            pos = 0;\n            for( ; ; )\n            {\n              pos = reg1.indexIn( articleString, pos );\n              if( pos >= 0 )\n              {\n                QString tag = reg1.cap();\n                if( reg2.indexIn( tag ) >= 0 )\n                {\n                  QString ref = reg2.cap( 1 );\n                  QString audio_url = \"<a href=\\\"\" + ref\n                                      + \"\\\"><img src=\\\"qrcx://localhost/icons/playsound.png\\\" border=\\\"0\\\" align=\\\"absmiddle\\\" alt=\\\"Play\\\"/></a>\";\n                  articleString.replace( pos, tag.length(), audio_url );\n                }\n                pos += 1;\n              }\n              else\n                break;\n            }\n#endif\n            // audio url\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n            articleString.replace( QRegularExpression( \"<a\\\\s+href=\\\"(//upload\\\\.wikimedia\\\\.org/wikipedia/[^\\\"'&]*\\\\.og[ga](?:\\\\.mp3|))\\\"\" ),\n#else\n            articleString.replace( QRegExp( \"<a\\\\s+href=\\\"(//upload\\\\.wikimedia\\\\.org/wikipedia/[^\\\"'&]*\\\\.og[ga](?:\\\\.mp3|))\\\"\" ),\n#endif\n                                   QString::fromStdString( addAudioLink( string( \"\\\"\" ) + wikiUrl.scheme().toStdString() + \":\\\\1\\\"\",\n                                                                         this->dictPtr->getId() ) + \"<a href=\\\"\" + wikiUrl.scheme().toStdString() + \":\\\\1\\\"\" ) );\n\n            // Add url scheme to image source urls\n            articleString.replace( \" src=\\\"//\", \" src=\\\"\" + wikiUrl.scheme() + \"://\" );\n            //fix src=\"/foo/bar/Baz.png\"\n            articleString.replace( \"src=\\\"/\", \"src=\\\"\" + wikiUrl.toString() );\n\n            // Remove the /wiki/ prefix from links\n            articleString.replace( \"<a href=\\\"/wiki/\", \"<a href=\\\"\" );\n\n            // In those strings, change any underscores to spaces\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n            QRegularExpression rxLink( \"<a\\\\s+href=\\\"[^/:\\\">#]+\" );\n            it = rxLink.globalMatch( articleString );\n            while( it.hasNext() )\n            {\n              QRegularExpressionMatch match = it.next();\n              for( int i = match.capturedStart() + 9; i < match.capturedEnd(); i++ )\n                if( articleString.at( i ) == QChar( '_') )\n                  articleString[ i ] = ' ';\n            }\n#else\n            for( ; ; )\n            {\n              QString before = articleString;\n              articleString.replace( QRegExp( \"<a href=\\\"([^/:\\\">#]*)_\" ), \"<a href=\\\"\\\\1 \" );\n  \n              if ( articleString == before )\n                break;\n            }\n#endif\n            //fix file: url\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n            articleString.replace( QRegularExpression( \"<a\\\\s+href=\\\"([^:/\\\"]*file%3A[^/\\\"]+\\\")\",\n                                                       QRegularExpression::CaseInsensitiveOption ),\n#else\n            articleString.replace( QRegExp(\"<a\\\\s+href=\\\"([^:/\\\"]*file%3A[^/\\\"]+\\\")\", Qt::CaseInsensitive ),\n#endif\n                                   QString( \"<a href=\\\"%1/index.php?title=\\\\1\" ).arg( url ));\n\n            // Add url scheme to other urls like  \"//xxx\"\n            articleString.replace( \" href=\\\"//\", \" href=\\\"\" + wikiUrl.scheme() + \"://\" );\n\n            // Fix urls in \"srcset\" attribute\n            pos = 0;\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n            QRegularExpression regSrcset( \" srcset\\\\s*=\\\\s*\\\"/[^\\\"]+\\\"\" );\n            it = regSrcset.globalMatch( articleString );\n            while( it.hasNext() )\n            {\n              QRegularExpressionMatch match = it.next();\n              articleNewString += articleString.midRef( pos, match.capturedStart() - pos );\n              pos = match.capturedEnd();\n\n              QString srcset = match.captured();\n#else\n            QRegExp regSrcset( \" srcset\\\\s*=\\\\s*\\\"/([^\\\"]+)\\\"\" );\n            for( ; ; )\n            {\n              pos = regSrcset.indexIn( articleString, pos );\n              if( pos < 0 )\n                break;\n              QString srcset = regSrcset.cap();\n#endif\n              QString newSrcset = srcset.replace( \"//\", wikiUrl.scheme() + \"://\" );\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n              articleNewString += newSrcset;\n            }\n            if( pos )\n            {\n              articleNewString += articleString.midRef( pos );\n              articleString = articleNewString;\n              articleNewString.clear();\n            }\n#else\n              articleString.replace( pos, regSrcset.cap().size(), newSrcset );\n              pos += newSrcset.size();\n            }\n#endif\n\n            // Insert the ToC in the end to improve performance because no replacements are needed in the generated ToC.\n            MediaWikiSectionsParser::generateTableOfContentsIfEmpty( parseNode, articleString );\n\n            QByteArray articleBody = articleString.toUtf8();\n\n            articleBody.prepend( dictPtr->isToLanguageRTL() ? \"<div class=\\\"mwiki\\\" dir=\\\"rtl\\\">\" :\n                                                              \"<div class=\\\"mwiki\\\">\" );\n            articleBody.append( \"</div>\" );\n  \n            Mutex::Lock _( dataMutex );\n\n            size_t prevSize = data.size();\n            \n            data.resize( prevSize + articleBody.size() );\n  \n            memcpy( &data.front() + prevSize, articleBody.data(), articleBody.size() );\n  \n            hasAnyData = true;\n\n            updated = true;\n          }\n        }\n      }\n      GD_DPRINTF( \"done.\\n\" );\n    }\n    else\n      setErrorString( netReply->errorString() );\n\n    disconnect( netReply, 0, 0, 0 );\n    netReply->deleteLater();\n  }\n\n  if ( netReplies.empty() )\n    finish();\n  else\n  if ( updated )\n    update();\n}\n\nsptr< WordSearchRequest > MediaWikiDictionary::prefixMatch( wstring const & word,\n                                                            unsigned long maxResults )\n  THROW_SPEC( std::exception )\n{\n  (void) maxResults;\n  if ( word.size() > 80 )\n  {\n    // Don't make excessively large queries -- they're fruitless anyway\n\n    return new WordSearchRequestInstant();\n  }\n  else\n    return new MediaWikiWordSearchRequest( word, url, netMgr );\n}\n\nsptr< DataRequest > MediaWikiDictionary::getArticle( wstring const & word,\n                                                     vector< wstring > const & alts,\n                                                     wstring const &, bool )\n  THROW_SPEC( std::exception )\n{\n  if ( word.size() > 80 )\n  {\n    // Don't make excessively large queries -- they're fruitless anyway\n\n    return new DataRequestInstant( false );\n  }\n  else\n    return new MediaWikiArticleRequest( word, alts, url, netMgr, this );\n}\n\n}\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      Dictionary::Initializing &,\n                                      Config::MediaWikis const & wikis,\n                                      QNetworkAccessManager & mgr )\n  THROW_SPEC( std::exception )\n{\n  vector< sptr< Dictionary::Class > > result;\n\n  for( int x = 0; x < wikis.size(); ++x )\n  {\n    if ( wikis[ x ].enabled )\n      result.push_back( new MediaWikiDictionary( wikis[ x ].id.toStdString(),\n                                                 wikis[ x ].name.toUtf8().data(),\n                                                 wikis[ x ].url,\n                                                 wikis[ x ].icon,\n                                                 mgr ) );\n  }\n\n  return result;\n}\n\n}\n"
        },
        {
          "name": "mediawiki.hh",
          "type": "blob",
          "size": 1.0546875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __MEDIAWIKI_HH_INCLUDED__\n#define __MEDIAWIKI_HH_INCLUDED__\n\n#include \"dictionary.hh\"\n#include \"config.hh\"\n#include <QNetworkAccessManager>\n\n/// Support for MediaWiki-based wikis, based on its public API.\nnamespace MediaWiki {\n\nusing std::vector;\nusing std::string;\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      Dictionary::Initializing &,\n                                      Config::MediaWikis const & wikis,\n                                      QNetworkAccessManager & )\n    THROW_SPEC( std::exception );\n\n/// Exposed here for moc\nclass MediaWikiWordSearchRequestSlots: public Dictionary::WordSearchRequest\n{\n  Q_OBJECT\n\nprotected slots:\n\n  virtual void downloadFinished()\n  {}\n};\n\n/// Exposed here for moc\nclass MediaWikiDataRequestSlots: public Dictionary::DataRequest\n{\n  Q_OBJECT\n\nprotected slots:\n\n  virtual void requestFinished( QNetworkReply * )\n  {}\n};\n\n}\n\n#endif\n"
        },
        {
          "name": "mouseover.cc",
          "type": "blob",
          "size": 11.4130859375,
          "content": "#include \"mouseover.hh\"\n#include \"utf8.hh\"\n#include <QCoreApplication>\n#include <QDir>\n#include <algorithm>\n\n#ifdef Q_OS_WIN32\n#undef WINVER\n#define WINVER 0x0500\n#include <sddl.h>\n#include <accctrl.h>\n#include <aclapi.h>\n#include \"mouseover_win32/ThTypes.h\"\n#include \"wordbyauto.hh\"\n#include \"x64.hh\"\n#endif\n\nMouseOver & MouseOver::instance()\n{\n  static MouseOver m;\n\n  return m;\n}\n\n#ifdef Q_OS_WIN32\nconst UINT WM_MY_SHOW_TRANSLATION = WM_USER + 301;\nstatic wchar_t className[] = L\"GoldenDictMouseover\";\ntypedef BOOL ( WINAPI  *ChangeWindowMessageFilterFunc )( UINT, DWORD );\n\n#ifndef _MSC_VER\ntypedef struct tagCHANGEFILTERSTRUCT {\n  DWORD cbSize;\n  DWORD ExtStatus;\n} CHANGEFILTERSTRUCT, *PCHANGEFILTERSTRUCT;\n#endif\n\ntypedef BOOL ( WINAPI  *ChangeWindowMessageFilterExFunc )( HWND, UINT, DWORD, PCHANGEFILTERSTRUCT );\n\n#endif // Q_OS_WIN32\n\n#ifdef Q_OS_WIN32\n\n#ifndef ConvertStringSecurityDescriptorToSecurityDescriptor\n\nextern \"C\" BOOL WINAPI ConvertStringSecurityDescriptorToSecurityDescriptorW(\n                        LPCWSTR StringSecurityDescriptor,\n                        DWORD StringSDRevision,\n                        PSECURITY_DESCRIPTOR *SecurityDescriptor,\n                        PULONG SecurityDescriptorSize );\n\n#endif\n\nstatic void SetLowLabelToGDSynchroObjects()\n{\n// The LABEL_SECURITY_INFORMATION SDDL SACL to be set for low integrity\n#define LOW_INTEGRITY_SDDL_SACL_W L\"S:(ML;;NW;;;LW)\"\n//    DWORD dwErr = ERROR_SUCCESS;\n    PSECURITY_DESCRIPTOR pSD = NULL;\n\n    PACL pSacl = NULL; // not allocated\n    BOOL fSaclPresent = FALSE;\n    BOOL fSaclDefaulted = FALSE;\n#ifdef Q_OS_WIN64\n    LPCWSTR pwszMapFileName64 = L\"GoldenDictTextOutHookSharedMem64\";\n#endif\n    LPCWSTR pwszMapFileName = L\"GoldenDictTextOutHookSharedMem\";\n    LPCWSTR pwszSpyMutexName = L\"GoldenDictTextOutSpyMutex\";\n\n    if( ConvertStringSecurityDescriptorToSecurityDescriptorW( LOW_INTEGRITY_SDDL_SACL_W, 1 /* SDDL_REVISION_1 */, &pSD, NULL ) )\n    {\n        if( GetSecurityDescriptorSacl(pSD, &fSaclPresent, &pSacl, &fSaclDefaulted))\n        {\n// Note that psidOwner, psidGroup, and pDacl are\n// all NULL and set the new LABEL_SECURITY_INFORMATION\n\n#ifdef Q_OS_WIN64\n           /* dwErr = */ SetNamedSecurityInfoW( (LPWSTR)pwszMapFileName64,\n                     SE_KERNEL_OBJECT, LABEL_SECURITY_INFORMATION, NULL, NULL, NULL, pSacl);\n#endif\n           /* dwErr = */ SetNamedSecurityInfoW( (LPWSTR)pwszMapFileName,\n                    SE_KERNEL_OBJECT, LABEL_SECURITY_INFORMATION, NULL, NULL, NULL, pSacl);\n\n           /* dwErr = */ SetNamedSecurityInfoW( (LPWSTR)pwszSpyMutexName,\n                    SE_KERNEL_OBJECT, LABEL_SECURITY_INFORMATION, NULL, NULL, NULL, pSacl);\n\n        }\n        LocalFree(pSD);\n    }\n}\n\n#endif // Q_OS_WIN32\n\nMouseOver::MouseOver() :\n  pPref(NULL)\n{\n#ifdef Q_OS_WIN32\nHMODULE hm;\nChangeWindowMessageFilterFunc changeWindowMessageFilterFunc = NULL;\nChangeWindowMessageFilterExFunc changeWindowMessageFilterExFunc = NULL;\n  mouseOverEnabled = false;\n  \n  ThTypes_Init();\n  memset( GlobalData, 0, sizeof( TGlobalDLLData ) );\n#ifdef Q_OS_WIN64\n  memset( GlobalData32, 0, sizeof( TGlobalDLLData32 ) );\n#endif\n//  strcpy( GlobalData->LibName,\n//    QDir::toNativeSeparators( QDir( QCoreApplication::applicationDirPath() ).filePath( \"GdTextOutHook.dll\" ) ).toLocal8Bit().data() );\n#ifdef Q_OS_WIN64\n  QDir::toNativeSeparators( QDir( QCoreApplication::applicationDirPath() ).filePath( \"GdTextOutHook64.dll\" ) ).toWCharArray( GlobalData->LibName );\n  QDir::toNativeSeparators( QDir( QCoreApplication::applicationDirPath() + \"/x86\" ).filePath( \"GdTextOutHook.dll\" ) ).toWCharArray( GlobalData32->LibName );\n#else\n  QDir::toNativeSeparators( QDir( QCoreApplication::applicationDirPath() ).filePath( \"GdTextOutHook.dll\" ) ).toWCharArray( GlobalData->LibName );\n#endif\n\n  // Create the window to receive spying results to\n\n  WNDCLASSEX wcex;\n\n  wcex.cbSize = sizeof( WNDCLASSEX );\n\n  wcex.style            = 0;\n  wcex.lpfnWndProc      = ( WNDPROC ) eventHandler;\n  wcex.cbClsExtra       = 0;\n  wcex.cbWndExtra       = 0;\n  wcex.hInstance        = GetModuleHandle( 0 );\n  wcex.hIcon            = NULL;\n  wcex.hCursor          = NULL,\n  wcex.hbrBackground    = NULL;\n  wcex.lpszMenuName     = NULL;\n  wcex.lpszClassName    = className;\n  wcex.hIconSm          = NULL;\n\n  RegisterClassEx( &wcex );\n\n  GlobalData->ServerWND = CreateWindow( className, L\"\", 0, 0, 0, 0, 0, GetDesktopWindow(), NULL, GetModuleHandle( 0 ), 0 );\n#ifdef Q_OS_WIN64\n  GlobalData32->ServerWND = HandleToLong( GlobalData->ServerWND );\n#endif\n\n#ifdef Q_OS_WIN64\n  spyDll = LoadLibrary( QDir::toNativeSeparators( QDir( QCoreApplication::applicationDirPath() ).filePath( \"GdTextOutSpy64.dll\" ) ).toStdWString().c_str() );\n#else\n  spyDll = LoadLibrary( QDir::toNativeSeparators( QDir( QCoreApplication::applicationDirPath() ).filePath( \"GdTextOutSpy.dll\" ) ).toStdWString().c_str() );\n#endif\n\n  if ( spyDll )\n    activateSpyFn = ( ActivateSpyFn ) GetProcAddress( spyDll, \"ActivateTextOutSpying\" );\n\n// Allow messages from low intehrity process - for Vista and Win7\n  hm = GetModuleHandle( __TEXT(\"user32.dll\"));\n  if ( hm != NULL ) {\n      changeWindowMessageFilterExFunc = (ChangeWindowMessageFilterExFunc)GetProcAddress( hm, \"ChangeWindowMessageFilterEx\" );\n      if( changeWindowMessageFilterExFunc ) {\n          CHANGEFILTERSTRUCT cfs = { sizeof( CHANGEFILTERSTRUCT ), 0 };\n          changeWindowMessageFilterExFunc( GlobalData->ServerWND, WM_MY_SHOW_TRANSLATION, 1 /* MSGFLT_ALLOW */, &cfs );\n      } else {\n          changeWindowMessageFilterFunc = (ChangeWindowMessageFilterFunc)GetProcAddress( hm, \"ChangeWindowMessageFilter\" );\n          if( changeWindowMessageFilterFunc )\n              changeWindowMessageFilterFunc( WM_MY_SHOW_TRANSLATION, 1 /* MSGFLT_ADD */ );\n      }\n  }\n\n//Allow object access from low intehrity process - for Vista and Win7\n  SetLowLabelToGDSynchroObjects();\n\n#endif\n}\n\nvoid MouseOver::enableMouseOver()\n{\n#ifdef Q_OS_WIN32\n  if ( !mouseOverEnabled && activateSpyFn )\n  {\n    activateSpyFn( true );\n    installx64Hooks();\n    mouseOverEnabled = true;\n  }\n#endif\n}\n\nvoid MouseOver::disableMouseOver()\n{\n#ifdef Q_OS_WIN32\n  if ( mouseOverEnabled && activateSpyFn )\n  {\n    activateSpyFn( false );\n    removex64Hooks();\n    mouseOverEnabled = false;\n  }\n#endif\n}\n\n#ifdef Q_OS_WIN32\n\nLRESULT MouseOver::makeScanBitMask()\n{\nLRESULT res = 0;\n    if( pPref == NULL )\n        return 0;\n    if( !pPref->enableScanPopupModifiers || checkModifiersPressed( pPref->scanPopupModifiers ) ) {\n        res = GD_FLAG_METHOD_STANDARD;\n        if( pPref->scanPopupUseUIAutomation !=0 )\n            res |= GD_FLAG_METHOD_UI_AUTOMATION;\n        if( pPref->scanPopupUseIAccessibleEx !=0 )\n            res |= GD_FLAG_METHOD_IACCESSIBLEEX;\n        if( pPref->scanPopupUseGDMessage !=0 )\n            res |= GD_FLAG_METHOD_GD_MESSAGE;\n    }\n    return res;\n}\n\n#ifdef Q_OS_WIN64\n#define Global_Data GlobalData32\n#else\n#define Global_Data GlobalData\n#endif\n\nLRESULT CALLBACK MouseOver::eventHandler( HWND hwnd_, UINT msg,\n                                          WPARAM wparam, LPARAM lparam )\n{\n  if ( msg == WM_MY_SHOW_TRANSLATION )\n  {\n    LRESULT res = instance().makeScanBitMask();\n\n    if( res == 0 )\n        return 0;  // Don't handle word without necessity\n\n    if( wparam != 0) //Ask for methods of word retrieving\n        return res;\n\n    int wordSeqPos = 0;\n    QString wordSeq;\n\n#ifdef Q_OS_WIN64\n    HWND hwnd = ( HWND )LongToHandle( Global_Data->LastWND );\n#else\n    HWND hwnd = Global_Data->LastWND;\n#endif\n\n    if( Global_Data->CurMod.WordLen == 0)\n    {\n        if( ( res & GD_FLAG_METHOD_UI_AUTOMATION ) == 0 )\n            return 0;\n        POINT pt = Global_Data->LastPt;\n        WCHAR *pwstr = gdGetWordAtPointByAutomation( pt );\n        if( pwstr == NULL ) return 0;\n        wordSeq = QString::fromWCharArray( pwstr );\n    }\n    else\n    {\n\n        // Is the string in utf8 or in locale encoding?\n\n        gd::wchar testBuf[ 256 ];\n\n        long result = Utf8::decode( Global_Data->CurMod.MatchedWord,\n                                    strlen( Global_Data->CurMod.MatchedWord ),\n                                    testBuf );\n\n        if ( result >= 0 )\n        {\n          // It seems to be\n          QString begin = QString::fromUtf8( Global_Data->CurMod.MatchedWord,\n                                             Global_Data->CurMod.BeginPos ).normalized( QString::NormalizationForm_C );\n\n          QString end = QString::fromUtf8( Global_Data->CurMod.MatchedWord +\n                                           Global_Data->CurMod.BeginPos ).normalized( QString::NormalizationForm_C );\n\n          wordSeq = begin + end;\n          wordSeqPos = begin.size();\n        }\n        else\n        {\n        // It's not, so interpret it as in local encoding\n            QString begin = QString::fromLocal8Bit( Global_Data->CurMod.MatchedWord,\n                                                    Global_Data->CurMod.BeginPos ).normalized( QString::NormalizationForm_C );\n\n            QString end = QString::fromLocal8Bit( Global_Data->CurMod.MatchedWord +\n                                                  Global_Data->CurMod.BeginPos ).normalized( QString::NormalizationForm_C );\n\n            wordSeq = begin + end;\n            wordSeqPos = begin.size();\n        }\n    }\n\n    // Now locate the word inside the sequence\n\n    QString word;\n\n    if ( wordSeq[ wordSeqPos ].isSpace() )\n    {\n      // Currently we ignore such cases\n      return 0;\n    }\n    else\n    if ( !( wordSeq[ wordSeqPos ].isLetterOrNumber() || wordSeq[ wordSeqPos ] == QChar( 0xAD ) ) ) // Assume soft hyphen as letter\n    {\n      // Special case: the cursor points to something which doesn't look like a\n      // middle of the word -- assume that it's something that joins two words\n      // together.\n\n      int begin = wordSeqPos;\n\n      for( ; begin; --begin )\n        if ( !( wordSeq[ begin - 1 ].isLetterOrNumber() || wordSeq[ begin - 1 ] == QChar( 0xAD ) ) )\n          break;\n\n      int end = wordSeqPos;\n\n      while( ++end < wordSeq.size() )\n        if ( !( wordSeq[ end ].isLetterOrNumber() || wordSeq[ end ] == QChar( 0xAD ) ) )\n          break;\n\n      if ( end - begin == 1 )\n      {\n        // Well, turns out it was just a single non-letter char, discard it\n        return 0;\n      }\n\n      word = wordSeq.mid( begin, end - begin );\n    }\n    else\n    {\n      // Cursor points to a letter -- cut the word it points to\n\n      int begin = wordSeqPos;\n\n      for( ; begin; --begin )\n        if ( !( wordSeq[ begin - 1 ].isLetterOrNumber() || wordSeq[ begin - 1 ] == QChar( 0xAD ) ) )\n          break;\n\n      int end = wordSeqPos;\n\n      while( ++end < wordSeq.size() )\n      {\n        if ( !( wordSeq[ end ].isLetterOrNumber() || wordSeq[ end ] == QChar( 0xAD ) ) )\n          break;\n      }\n      word = wordSeq.mid( begin, end - begin );\n    }\n\n    // See if we have an RTL char. Reverse the whole string if we do.\n\n    if( lparam == 0 )\n    {\n      for( int x = 0; x < word.size(); ++x )\n      {\n        QChar::Direction d = word[ x ].direction();\n\n        if ( d == QChar::DirR || d == QChar::DirAL ||\n             d == QChar::DirRLE || d == QChar::DirRLO )\n        {\n          std::reverse( word.begin(), word.end() );\n          break;\n        }\n      }\n    }\n\n    bool forcePopup = false;\n    forcePopup = emit instance().isGoldenDictWindow( hwnd );\n    emit instance().hovered( word, forcePopup );\n    return 0;\n  }\n\n  return DefWindowProc( hwnd_, msg, wparam, lparam );\n}\n\n#endif\n\nMouseOver::~MouseOver()\n{\n#ifdef Q_OS_WIN32\n\n  disableMouseOver();\n\n  FreeLibrary( spyDll );\n\n  DestroyWindow( GlobalData->ServerWND );\n\n  UnregisterClass( className, GetModuleHandle( 0 ) );\n\n  ThTypes_End();\n\n#endif\n}\n\n"
        },
        {
          "name": "mouseover.hh",
          "type": "blob",
          "size": 1.6240234375,
          "content": "#ifndef __MOUSEOVER_HH_INCLUDED__\n#define __MOUSEOVER_HH_INCLUDED__\n\n#include <QObject>\n#include \"config.hh\"\n#include \"keyboardstate.hh\"\n\n#ifdef Q_OS_WIN32\n#include <windows.h>\n#endif\n\n/// This is a mouseover feature interface, where you can point your mouse at\n/// any word in any window and wait a little, and it would provide that word\n/// for the translation.\n/// This interface always exists, even on platforms that don't support that\n/// feature -- it just remains dormant on them.\n/// \n/// The Windows platform is the only one supported; it works with the help of\n/// two external .dll files,\nclass MouseOver: public QObject, public KeyboardState\n{\n  Q_OBJECT\n\npublic:\n\n  /// The class is a singleton.\n  static MouseOver & instance();\n\n  /// Enables mouseover. The mouseover is initially disabled.\n  void enableMouseOver();\n  /// Disables mouseover.\n  void disableMouseOver();\n\n  /// Set pointer to program configuration\n  void setPreferencesPtr( Config::Preferences const *ppref ) { pPref = ppref; };\n  \nsignals:\n\n  /// Emitted when there was some text under cursor which was hovered over.\n  void hovered( QString const &, bool forcePopup );\n\n#ifdef Q_OS_WIN32\n  /// Ask for source window is GoldenDict window\n  bool isGoldenDictWindow( HWND hwnd );\n#endif\n\nprivate:\n\n  MouseOver();\n  ~MouseOver();\n\n  Config::Preferences const *pPref;\n\n#ifdef Q_OS_WIN32\n\n  static LRESULT CALLBACK eventHandler( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam );\n\n  typedef void ( *ActivateSpyFn )( bool );\n  ActivateSpyFn activateSpyFn;\n  HINSTANCE spyDll;\n  bool mouseOverEnabled;\n\n  /// Create mask for scan methods\n  LRESULT makeScanBitMask();\n\n#endif\n\n};\n\n#endif\n\n"
        },
        {
          "name": "mouseover_win32",
          "type": "tree",
          "content": null
        },
        {
          "name": "mruqmenu.cc",
          "type": "blob",
          "size": 0.47265625,
          "content": "#include \"mruqmenu.hh\"\n#include <QKeyEvent>\n\nMRUQMenu::MRUQMenu(const QString title, QWidget *parent):\n        QMenu(title,parent)\n{\n    installEventFilter(this);\n}\n\nbool MRUQMenu::eventFilter(QObject *obj, QEvent *event)\n{\n    (void) obj;\n    if (event->type() == QEvent::KeyRelease){\n        QKeyEvent *keyevent = static_cast<QKeyEvent*>(event);\n        if (keyevent->key() == Qt::Key_Control){\n\t    emit ctrlReleased();\n            return true;\n        }\n    }\n    return false;\n}\n"
        },
        {
          "name": "mruqmenu.hh",
          "type": "blob",
          "size": 0.4111328125,
          "content": "#ifndef MRUQMENU_HH\n#define MRUQMENU_HH\n\n#include <QMenu>\n#include <QEvent>\n\n//The only difference between this class and QMenu is that this class emits\n//a signal when Ctrl button is released\nclass MRUQMenu: public QMenu\n{\n    Q_OBJECT\n\npublic:\n    MRUQMenu(const QString title, QWidget *parent = 0);\n\nprivate:\n    bool eventFilter (QObject*, QEvent*);\n\n    signals:\n    void ctrlReleased();\n};\n\n\n\n#endif // MRUQMENU_HH\n"
        },
        {
          "name": "multimediaaudioplayer.cc",
          "type": "blob",
          "size": 1.16015625,
          "content": "/* This file is (c) 2018 Igor Kushnir <igorkuo@gmail.com>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifdef MAKE_QTMULTIMEDIA_PLAYER\n\n#include <QByteArray>\n#include <QMediaContent>\n#include \"multimediaaudioplayer.hh\"\n\nMultimediaAudioPlayer::MultimediaAudioPlayer() :\n  player( 0, QMediaPlayer::StreamPlayback )\n{\n  typedef void( QMediaPlayer::* ErrorSignal )( QMediaPlayer::Error );\n  connect( &player, static_cast< ErrorSignal >( &QMediaPlayer::error ),\n           this, &MultimediaAudioPlayer::onMediaPlayerError );\n}\n\nQString MultimediaAudioPlayer::play( const char * data, int size )\n{\n  stop();\n\n  audioBuffer.setData( data, size );\n  if( !audioBuffer.open( QIODevice::ReadOnly ) )\n    return tr( \"Couldn't open audio buffer for reading.\" );\n\n  player.setMedia( QMediaContent(), &audioBuffer );\n  player.play();\n  return QString();\n}\n\nvoid MultimediaAudioPlayer::stop()\n{\n  player.setMedia( QMediaContent() ); // Forget about audioBuffer.\n  audioBuffer.close();\n  audioBuffer.setData( QByteArray() ); // Free memory.\n}\n\nvoid MultimediaAudioPlayer::onMediaPlayerError()\n{\n  emit error( player.errorString() );\n}\n\n#endif // MAKE_QTMULTIMEDIA_PLAYER\n"
        },
        {
          "name": "multimediaaudioplayer.hh",
          "type": "blob",
          "size": 0.7158203125,
          "content": "/* This file is (c) 2018 Igor Kushnir <igorkuo@gmail.com>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef MULTIMEDIAAUDIOPLAYER_HH_INCLUDED\n#define MULTIMEDIAAUDIOPLAYER_HH_INCLUDED\n\n#ifdef MAKE_QTMULTIMEDIA_PLAYER\n\n#include <QBuffer>\n#include <QMediaPlayer>\n#include \"audioplayerinterface.hh\"\n\nclass MultimediaAudioPlayer : public AudioPlayerInterface\n{\n  Q_OBJECT\npublic:\n  MultimediaAudioPlayer();\n\n  virtual QString play( const char * data, int size );\n  virtual void stop();\n\nprivate slots:\n  void onMediaPlayerError();\n\nprivate:\n  QBuffer audioBuffer;\n  QMediaPlayer player; ///< Depends on audioBuffer.\n};\n\n#endif // MAKE_QTMULTIMEDIA_PLAYER\n\n#endif // MULTIMEDIAAUDIOPLAYER_HH_INCLUDED\n"
        },
        {
          "name": "mutex.cc",
          "type": "blob",
          "size": 0.259765625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"mutex.hh\"\n\nMutex::Lock::Lock( Mutex & m_ ): m( m_ )\n{\n  m.lock();\n}\n\nMutex::Lock::~Lock()\n{\n  m.unlock();\n}\n"
        },
        {
          "name": "mutex.hh",
          "type": "blob",
          "size": 0.7646484375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __MUTEX_HH_INCLUDED__\n#define __MUTEX_HH_INCLUDED__\n\n#include <QMutex>\n\n/// This provides a mutex class. As you can see, it's just a Qt one, but it\n/// does provide the Lock class which doesn't seem to exist in Qt, and it does\n/// provide some abstraction for dictionaries in case they are to be ported\n/// away from Qt.\nclass Mutex: public QMutex\n{\npublic:\n  Mutex() : QMutex( Recursive )\n  {}\n  ~Mutex()\n  {}\n\n  /// Locks the given mutex on construction and unlocks on destruction\n  class Lock\n  {\n    Mutex & m;\n    \n  public:\n    \n    Lock( Mutex & );\n    ~Lock();\n    \n  private:\n    Lock( Lock const & );\n  };\n};\n\n#endif\n"
        },
        {
          "name": "myInfo.plist",
          "type": "blob",
          "size": 0.6494140625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist SYSTEM \"file://localhost/System/Library/DTDs/PropertyList.dtd\">\n<plist version=\"0.9\">\n<dict>\n\t<key>CFBundleIconFile</key>\n\t<string>@ICON@</string>\n\t<key>CFBundlePackageType</key>\n\t<string>APPL</string>\n    <key>CFBundleGetInfoString</key>\n\t<string>@SHORT_VERSION@</string>\n\t<key>CFBundleSignature</key>\n\t<string>@TYPEINFO@</string>\n\t<key>CFBundleExecutable</key>\n\t<string>@EXECUTABLE@</string>\n\t<key>CFBundleShortVersionString</key>\n\t<string>@SHORT_VERSION@</string>\n\t<key>CFBundleIdentifier</key>\n\t<string>org.goldendict</string>\t\n\t<key>NSPrincipalClass</key>\n\t<string>NSApplication</string>\n</dict>\n</plist>\n"
        },
        {
          "name": "nsis",
          "type": "tree",
          "content": null
        },
        {
          "name": "opencc",
          "type": "tree",
          "content": null
        },
        {
          "name": "options.ui",
          "type": "blob",
          "size": 2.015625,
          "content": "<ui version=\"4.0\" >\n <class>Options</class>\n <widget class=\"QDialog\" name=\"Options\" >\n  <property name=\"geometry\" >\n   <rect>\n    <x>0</x>\n    <y>0</y>\n    <width>400</width>\n    <height>81</height>\n   </rect>\n  </property>\n  <property name=\"windowTitle\" >\n   <string>Options</string>\n  </property>\n  <layout class=\"QVBoxLayout\" name=\"verticalLayout\" >\n   <item>\n    <widget class=\"QCheckBox\" name=\"checkBox\" >\n     <property name=\"toolTip\" >\n      <string>Imagine searching for the word 'cats'. One dictionary lists\nit as a synonym for 'cat', another one only knows 'cat'\nalone. With this option on, the first dictionary would help\ndiscover the main word 'cat' which would be added to the\nquery, and both dictionaries would include a definition for\n'cat' in response to the 'cats' query. This is very useful in\nmost cases, and thus it is recommended to keep this on.</string>\n     </property>\n     <property name=\"text\" >\n      <string>Inject main forms of synonyms into search queries</string>\n     </property>\n    </widget>\n   </item>\n   <item>\n    <widget class=\"QDialogButtonBox\" name=\"buttonBox\" >\n     <property name=\"orientation\" >\n      <enum>Qt::Horizontal</enum>\n     </property>\n     <property name=\"standardButtons\" >\n      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>\n     </property>\n    </widget>\n   </item>\n  </layout>\n </widget>\n <resources/>\n <connections>\n  <connection>\n   <sender>buttonBox</sender>\n   <signal>accepted()</signal>\n   <receiver>Options</receiver>\n   <slot>accept()</slot>\n   <hints>\n    <hint type=\"sourcelabel\" >\n     <x>248</x>\n     <y>254</y>\n    </hint>\n    <hint type=\"destinationlabel\" >\n     <x>157</x>\n     <y>274</y>\n    </hint>\n   </hints>\n  </connection>\n  <connection>\n   <sender>buttonBox</sender>\n   <signal>rejected()</signal>\n   <receiver>Options</receiver>\n   <slot>reject()</slot>\n   <hints>\n    <hint type=\"sourcelabel\" >\n     <x>316</x>\n     <y>260</y>\n    </hint>\n    <hint type=\"destinationlabel\" >\n     <x>286</x>\n     <y>274</y>\n    </hint>\n   </hints>\n  </connection>\n </connections>\n</ui>\n"
        },
        {
          "name": "orderandprops.cc",
          "type": "blob",
          "size": 9.7880859375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"orderandprops.hh\"\n#include \"instances.hh\"\n#include \"langcoder.hh\"\n#include \"language.hh\"\n#include \"fsencoding.hh\"\n#include <algorithm>\n\n#include <QMenu>\n#include <QPair>\n\nusing std::vector;\nusing std::sort;\n\nnamespace {\n\nbool dictNameLessThan( sptr< Dictionary::Class > const & dict1,\n                       sptr< Dictionary::Class > const & dict2 )\n{\n  QString str1 = QString::fromUtf8( dict1->getName().c_str() );\n  QString str2 = QString::fromUtf8( dict2->getName().c_str() );\n  if( str1.isEmpty() && !str2.isEmpty() )\n    return false;\n  if( !str1.isEmpty() && str2.isEmpty() )\n    return true;\n\n  return str1.localeAwareCompare( str2 ) < 0;\n}\n\nbool dictLessThan( sptr< Dictionary::Class > const & dict1,\n                   sptr< Dictionary::Class > const & dict2 )\n{\n  int idFrom1 = dict1->getLangFrom();\n  int idTo1 = dict1->getLangTo();\n  if( idFrom1 == 0)\n  {\n    QPair<quint32,quint32> ids = LangCoder::findIdsForName( QString::fromUtf8( dict1->getName().c_str() ) );\n    idFrom1 = ids.first;\n    idTo1 = ids.second;\n  }\n\n  int idFrom2 = dict2->getLangFrom();\n  int idTo2 = dict2->getLangTo();\n  if( idFrom2 == 0)\n  {\n    QPair<quint32,quint32> ids = LangCoder::findIdsForName( QString::fromUtf8( dict2->getName().c_str() ) );\n    idFrom2 = ids.first;\n    idTo2 = ids.second;\n  }\n\n  QString str1 = LangCoder::decode( idFrom1 );\n  QString str2 = LangCoder::decode( idFrom2 );\n  if( str1.isEmpty() && !str2.isEmpty() )\n    return false;\n  if( !str1.isEmpty() && str2.isEmpty() )\n    return true;\n  int res = str1.localeAwareCompare( str2 );\n  if( res )\n    return res < 0;\n\n  str1 = LangCoder::decode( idTo1 );\n  str2 = LangCoder::decode( idTo2 );\n  if( str1.isEmpty() && !str2.isEmpty() )\n    return false;\n  if( !str1.isEmpty() && str2.isEmpty() )\n    return true;\n  res = str1.localeAwareCompare( str2 );\n  if( res )\n    return res < 0;\n\n  str1 = QString::fromUtf8( dict1->getName().c_str() );\n  str2 = QString::fromUtf8( dict2->getName().c_str() );\n  if( str1.isEmpty() && !str2.isEmpty() )\n    return false;\n  if( !str1.isEmpty() && str2.isEmpty() )\n    return true;\n\n  return str1.localeAwareCompare( str2 ) < 0;\n}\n\n} // namespace\n\nOrderAndProps::OrderAndProps( QWidget * parent,\n                              Config::Group const & dictionaryOrder,\n                              Config::Group const & inactiveDictionaries,\n                              std::vector< sptr< Dictionary::Class > > const &\n                              allDictionaries ):\n  QWidget( parent )\n{\n  ui.setupUi( this );\n\n  Instances::Group order( dictionaryOrder, allDictionaries, Config::Group() );\n  Instances::Group inactive( inactiveDictionaries, allDictionaries, Config::Group() );\n\n  Instances::complementDictionaryOrder( order, inactive, allDictionaries );\n\n  ui.dictionaryOrder->populate( order.dictionaries, allDictionaries );\n  ui.inactiveDictionaries->populate( inactive.dictionaries, allDictionaries );\n\n  ui.searchLine->applyTo( ui.dictionaryOrder );\n  addAction( ui.searchLine->getFocusAction() );\n\n  disableDictionaryDescription();\n\n  ui.dictionaryOrder->setContextMenuPolicy( Qt::CustomContextMenu );\n  connect( ui.dictionaryOrder, SIGNAL( customContextMenuRequested( QPoint ) ),\n           this, SLOT( contextMenuRequested( QPoint ) ) );\n\n  connect( ui.dictionaryOrder, SIGNAL( gotFocus() ),\n           this, SLOT( dictListFocused() ) );\n  connect( ui.inactiveDictionaries, SIGNAL( gotFocus() ),\n           this, SLOT( inactiveDictListFocused() ) );\n\n  connect ( ui.dictionaryOrder->selectionModel(), SIGNAL( selectionChanged ( const QItemSelection & , const QItemSelection & ) ),\n      this, SLOT( dictionarySelectionChanged( const QItemSelection & ) ) );\n  connect ( ui.inactiveDictionaries->selectionModel(), SIGNAL( selectionChanged( const QItemSelection &, const QItemSelection & ) ),\n      this, SLOT( inactiveDictionarySelectionChanged( QItemSelection const & ) ) );\n\n  connect (ui.searchLine, SIGNAL( filterChanged( QString const & ) ),\n      this, SLOT( filterChanged( QString const &) ) );\n\n  connect( ui.dictionaryOrder->getModel(), SIGNAL( contentChanged() ),\n           this, SLOT( showDictNumbers() ) );\n  connect( ui.inactiveDictionaries->getModel(), SIGNAL( contentChanged() ),\n           this, SLOT( showDictNumbers() ) );\n\n  showDictNumbers();\n}\n\nConfig::Group OrderAndProps::getCurrentDictionaryOrder() const\n{\n  Instances::Group g( \"\" );\n\n  g.dictionaries = ui.dictionaryOrder->getCurrentDictionaries();\n\n  return g.makeConfigGroup();\n}\n\nConfig::Group OrderAndProps::getCurrentInactiveDictionaries() const\n{\n  Instances::Group g( \"\" );\n\n  g.dictionaries = ui.inactiveDictionaries->getCurrentDictionaries();\n\n  return g.makeConfigGroup();\n}\n\nvoid OrderAndProps::filterChanged( QString const & filterText)\n{\n  // when the filter is active, disable the possibility\n  // to drop dictionaries to this filtered list\n  ui.dictionaryOrder->setAcceptDrops(filterText.isEmpty());\n}\n\nvoid OrderAndProps::dictListFocused()\n{\n  describeDictionary( ui.dictionaryOrder, ui.searchLine->mapToSource( ui.dictionaryOrder->currentIndex() ) );\n}\n\nvoid OrderAndProps::inactiveDictListFocused()\n{\n  describeDictionary( ui.inactiveDictionaries, ui.inactiveDictionaries->currentIndex() );\n}\n\nvoid OrderAndProps::dictionarySelectionChanged( const QItemSelection & current )\n{\n  if ( current.empty() )\n    return;\n\n  describeDictionary( ui.dictionaryOrder, ui.searchLine->mapToSource( current.front().topLeft() ) );\n}\n\nvoid OrderAndProps::inactiveDictionarySelectionChanged( QItemSelection const & current )\n{\n  if ( current.empty() )\n    return;\n  describeDictionary( ui.inactiveDictionaries, current.front().topLeft() );\n}\n\nvoid OrderAndProps::disableDictionaryDescription()\n{\n  ui.dictionaryInformation->setEnabled( false );\n\n  ui.dictionaryName->clear();\n  ui.dictionaryTotalArticles->clear();\n  ui.dictionaryTotalWords->clear();\n  ui.dictionaryTranslatesFrom->clear();\n  ui.dictionaryTranslatesTo->clear();\n  ui.dictionaryFileList->clear();\n\n  ui.dictionaryDescription->clear();\n  ui.dictionaryDescription->setVisible( false );\n  ui.dictionaryDescriptionLabel->setVisible( false );\n  ui.infoVerticalSpacer->changeSize( 20, 5, QSizePolicy::Minimum, QSizePolicy::Expanding );\n  ui.infoVerticalLayout->invalidate();\n}\n\nvoid OrderAndProps::describeDictionary( DictListWidget * lst, QModelIndex const & idx )\n{\n  if ( !idx.isValid() || (unsigned) idx.row() >= lst->getCurrentDictionaries().size() )\n    disableDictionaryDescription();\n  else\n  {\n    sptr< Dictionary::Class > dict = lst->getCurrentDictionaries()[ idx.row() ];\n\n    if ( !dict )\n    {\n      return;\n    }\n\n    ui.dictionaryInformation->setEnabled( true );\n\n    ui.dictionaryName->setText( QString::fromUtf8( dict->getName().c_str() ) );\n\n    ui.dictionaryTotalArticles->setText( QString::number( dict->getArticleCount() ) );\n    ui.dictionaryTotalWords->setText( QString::number( dict->getWordCount() ) );\n    ui.dictionaryTranslatesFrom->setText( Language::localizedStringForId( dict->getLangFrom() ) );\n    ui.dictionaryTranslatesTo->setText( Language::localizedStringForId( dict->getLangTo() ) );\n\n    std::vector< std::string > const & filenames = dict->getDictionaryFilenames();\n\n    QString filenamesText;\n\n    for( unsigned x = 0; x < filenames.size(); x++ )\n    {\n      filenamesText += FsEncoding::decode( filenames[ x ].c_str() );\n      filenamesText += '\\n';\n    }\n\n    ui.dictionaryFileList->setPlainText( filenamesText );\n\n    QString const& descText = dict->getDescription();\n    if( !descText.isEmpty() && descText.compare( \"NONE\" ) != 0 )\n    {\n      ui.dictionaryDescription->setPlainText( descText );\n      ui.dictionaryDescription->setVisible( true );\n      ui.dictionaryDescriptionLabel->setVisible( true );\n      ui.infoVerticalSpacer->changeSize( 0, 0, QSizePolicy::Minimum, QSizePolicy::Minimum );\n    }\n    else\n    {\n      ui.dictionaryDescription->setVisible( false );\n      ui.dictionaryDescriptionLabel->setVisible( false );\n      ui.infoVerticalSpacer->changeSize( 20, 5, QSizePolicy::Minimum, QSizePolicy::Expanding );\n    }\n    ui.infoVerticalLayout->invalidate();\n  }\n}\n\nvoid OrderAndProps::contextMenuRequested( const QPoint & pos )\n{\n  QMenu menu( this );\n\n  QAction * showHeadwordsAction = NULL;\n  QModelIndex idx = ui.searchLine->mapToSource( ui.dictionaryOrder->indexAt( pos ) );\n  sptr< Dictionary::Class > dict;\n  if( idx.isValid() && (unsigned)idx.row() < ui.dictionaryOrder->getCurrentDictionaries().size() )\n    dict = ui.dictionaryOrder->getCurrentDictionaries()[ idx.row() ];\n  if ( dict && dict->getWordCount() > 0 )\n  {\n    showHeadwordsAction = new QAction( tr( \"Dictionary headwords\" ), &menu );\n    menu.addAction( showHeadwordsAction );\n  }\n\n  QAction * sortNameAction = new QAction( tr( \"Sort by name\" ), &menu );\n  menu.addAction( sortNameAction );\n  QAction * sortLangAction = new QAction( tr( \"Sort by languages\" ), &menu );\n  menu.addAction( sortLangAction );\n\n  QAction * result = menu.exec( ui.dictionaryOrder->mapToGlobal( pos ) );\n\n  if( result == sortNameAction || result == sortLangAction )\n  {\n    vector< sptr< Dictionary::Class > > sortedDicts = ui.dictionaryOrder->getCurrentDictionaries();\n    if( result == sortNameAction )\n      sort( sortedDicts.begin(), sortedDicts.end(), dictNameLessThan );\n    else\n      sort( sortedDicts.begin(), sortedDicts.end(), dictLessThan );\n    ui.dictionaryOrder->populate( sortedDicts );\n  }\n\n  if( result && result == showHeadwordsAction )\n  {\n    emit showDictionaryHeadwords( QString::fromUtf8( dict->getId().c_str() ) );\n  }\n}\n\nvoid OrderAndProps::showDictNumbers()\n{\n  ui.dictionariesNumber->setText( tr( \"Dictionaries active: %1, inactive: %2\" )\n                                  .arg( QString::number( ui.dictionaryOrder->getModel()->rowCount( QModelIndex() ) ) )\n                                  .arg( QString::number( ui.inactiveDictionaries->getModel()->rowCount( QModelIndex() ) ) ) );\n}\n"
        },
        {
          "name": "orderandprops.hh",
          "type": "blob",
          "size": 1.248046875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __ORDERANDPROPS_HH_INCLUDED__\n#define __ORDERANDPROPS_HH_INCLUDED__\n\n#include \"ui_orderandprops.h\"\n#include \"groups_widgets.hh\"\n#include <QSortFilterProxyModel>\n\nclass OrderAndProps: public QWidget\n{\n  Q_OBJECT;\n\npublic:\n\n  OrderAndProps( QWidget * parent, Config::Group const & dictionaryOrder,\n                 Config::Group const & inactiveDictionaries,\n                 std::vector< sptr< Dictionary::Class > > const & allDictionaries );\n\n  Config::Group getCurrentDictionaryOrder() const;\n  Config::Group getCurrentInactiveDictionaries() const;\n\nprivate slots:\n\n  void dictionarySelectionChanged( const QItemSelection &current );\n  void inactiveDictionarySelectionChanged( const QItemSelection &current );\n  void contextMenuRequested( const QPoint & pos );\n  void filterChanged( QString const & filterText );\n  void dictListFocused();\n  void inactiveDictListFocused();\n  void showDictNumbers();\n\nprivate:\n\n  Ui::OrderAndProps ui;\n\n  void disableDictionaryDescription();\n  void describeDictionary( DictListWidget *, QModelIndex const & );\n\nsignals:\n  void showDictionaryHeadwords( QString const & dictId );\n};\n\n#endif\n"
        },
        {
          "name": "orderandprops.ui",
          "type": "blob",
          "size": 10.7900390625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ui version=\"4.0\">\n <class>OrderAndProps</class>\n <widget class=\"QWidget\" name=\"OrderAndProps\">\n  <property name=\"geometry\">\n   <rect>\n    <x>0</x>\n    <y>0</y>\n    <width>606</width>\n    <height>585</height>\n   </rect>\n  </property>\n  <property name=\"windowTitle\">\n   <string>Form</string>\n  </property>\n  <layout class=\"QVBoxLayout\" name=\"verticalLayout_4\">\n   <item>\n    <layout class=\"QHBoxLayout\" name=\"horizontalLayout_2\">\n     <item>\n      <layout class=\"QVBoxLayout\" name=\"verticalLayout_3\">\n       <item>\n        <layout class=\"QGridLayout\" name=\"gridLayout_2\" rowstretch=\"0,10,10,0,0,2\">\n         <item row=\"3\" column=\"0\">\n          <layout class=\"QHBoxLayout\" name=\"horizontalLayout\">\n           <item>\n            <widget class=\"QLabel\" name=\"dictionariesNumber\">\n             <property name=\"text\">\n              <string notr=\"true\"/>\n             </property>\n            </widget>\n           </item>\n          </layout>\n         </item>\n         <item row=\"0\" column=\"0\">\n          <widget class=\"QLabel\" name=\"label\">\n           <property name=\"text\">\n            <string>Dictionary order:</string>\n           </property>\n          </widget>\n         </item>\n         <item row=\"2\" column=\"0\">\n          <widget class=\"DictListWidget\" name=\"dictionaryOrder\"/>\n         </item>\n         <item row=\"2\" column=\"1\">\n          <layout class=\"QVBoxLayout\" name=\"verticalLayout_2\"/>\n         </item>\n         <item row=\"5\" column=\"0\">\n          <widget class=\"DictListWidget\" name=\"inactiveDictionaries\"/>\n         </item>\n         <item row=\"4\" column=\"0\">\n          <widget class=\"QLabel\" name=\"label_2\">\n           <property name=\"text\">\n            <string>Inactive (disabled) dictionaries:</string>\n           </property>\n          </widget>\n         </item>\n         <item row=\"1\" column=\"0\">\n          <widget class=\"QuickFilterLine\" name=\"searchLine\"/>\n         </item>\n        </layout>\n       </item>\n      </layout>\n     </item>\n     <item>\n      <widget class=\"QGroupBox\" name=\"dictionaryInformation\">\n       <property name=\"title\">\n        <string>Dictionary information</string>\n       </property>\n       <layout class=\"QVBoxLayout\" name=\"infoVerticalLayout\">\n        <item>\n         <layout class=\"QGridLayout\" name=\"gridLayout\">\n          <item row=\"0\" column=\"0\">\n           <widget class=\"QLabel\" name=\"label_5\">\n            <property name=\"text\">\n             <string>Name:</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"0\" column=\"1\">\n           <widget class=\"QLabel\" name=\"dictionaryName\">\n            <property name=\"text\">\n             <string notr=\"true\">TextLabel</string>\n            </property>\n            <property name=\"textFormat\">\n             <enum>Qt::PlainText</enum>\n            </property>\n            <property name=\"textInteractionFlags\">\n             <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>\n            </property>\n           </widget>\n          </item>\n          <item row=\"1\" column=\"1\">\n           <widget class=\"QLabel\" name=\"dictionaryTotalArticles\">\n            <property name=\"text\">\n             <string notr=\"true\">TextLabel</string>\n            </property>\n            <property name=\"textFormat\">\n             <enum>Qt::PlainText</enum>\n            </property>\n           </widget>\n          </item>\n          <item row=\"1\" column=\"0\">\n           <widget class=\"QLabel\" name=\"label_6\">\n            <property name=\"text\">\n             <string>Total articles:</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"2\" column=\"0\">\n           <widget class=\"QLabel\" name=\"label_7\">\n            <property name=\"text\">\n             <string>Total words:</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"2\" column=\"1\">\n           <widget class=\"QLabel\" name=\"dictionaryTotalWords\">\n            <property name=\"text\">\n             <string notr=\"true\">TextLabel</string>\n            </property>\n            <property name=\"textFormat\">\n             <enum>Qt::PlainText</enum>\n            </property>\n           </widget>\n          </item>\n          <item row=\"3\" column=\"0\">\n           <widget class=\"QLabel\" name=\"label_9\">\n            <property name=\"text\">\n             <string>Translates from:</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"4\" column=\"0\">\n           <widget class=\"QLabel\" name=\"label_10\">\n            <property name=\"text\">\n             <string>Translates to:</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"3\" column=\"1\">\n           <widget class=\"QLabel\" name=\"dictionaryTranslatesFrom\">\n            <property name=\"text\">\n             <string notr=\"true\">TextLabel</string>\n            </property>\n            <property name=\"textFormat\">\n             <enum>Qt::RichText</enum>\n            </property>\n           </widget>\n          </item>\n          <item row=\"4\" column=\"1\">\n           <widget class=\"QLabel\" name=\"dictionaryTranslatesTo\">\n            <property name=\"text\">\n             <string notr=\"true\">TextLabel</string>\n            </property>\n            <property name=\"textFormat\">\n             <enum>Qt::RichText</enum>\n            </property>\n           </widget>\n          </item>\n         </layout>\n        </item>\n        <item>\n         <widget class=\"QLabel\" name=\"dictionaryDescriptionLabel\">\n          <property name=\"text\">\n           <string>Description:</string>\n          </property>\n         </widget>\n        </item>\n        <item>\n         <widget class=\"QPlainTextEdit\" name=\"dictionaryDescription\">\n          <property name=\"palette\">\n           <palette>\n            <active>\n             <colorrole role=\"Base\">\n              <brush brushstyle=\"SolidPattern\">\n               <color alpha=\"255\">\n                <red>224</red>\n                <green>223</green>\n                <blue>223</blue>\n               </color>\n              </brush>\n             </colorrole>\n            </active>\n            <inactive>\n             <colorrole role=\"Base\">\n              <brush brushstyle=\"SolidPattern\">\n               <color alpha=\"255\">\n                <red>224</red>\n                <green>223</green>\n                <blue>223</blue>\n               </color>\n              </brush>\n             </colorrole>\n            </inactive>\n            <disabled>\n             <colorrole role=\"Base\">\n              <brush brushstyle=\"SolidPattern\">\n               <color alpha=\"255\">\n                <red>212</red>\n                <green>208</green>\n                <blue>200</blue>\n               </color>\n              </brush>\n             </colorrole>\n            </disabled>\n           </palette>\n          </property>\n          <property name=\"frameShape\">\n           <enum>QFrame::NoFrame</enum>\n          </property>\n          <property name=\"readOnly\">\n           <bool>true</bool>\n          </property>\n         </widget>\n        </item>\n        <item>\n         <spacer name=\"infoVerticalSpacer\">\n          <property name=\"orientation\">\n           <enum>Qt::Vertical</enum>\n          </property>\n          <property name=\"sizeHint\" stdset=\"0\">\n           <size>\n            <width>20</width>\n            <height>5</height>\n           </size>\n          </property>\n         </spacer>\n        </item>\n        <item>\n         <spacer name=\"horizontalSpacer_5\">\n          <property name=\"orientation\">\n           <enum>Qt::Horizontal</enum>\n          </property>\n          <property name=\"sizeHint\" stdset=\"0\">\n           <size>\n            <width>256</width>\n            <height>5</height>\n           </size>\n          </property>\n         </spacer>\n        </item>\n        <item>\n         <widget class=\"QLabel\" name=\"label_11\">\n          <property name=\"text\">\n           <string>Files comprising this dictionary:</string>\n          </property>\n         </widget>\n        </item>\n        <item>\n         <widget class=\"QPlainTextEdit\" name=\"dictionaryFileList\">\n          <property name=\"sizePolicy\">\n           <sizepolicy hsizetype=\"Expanding\" vsizetype=\"Fixed\">\n            <horstretch>0</horstretch>\n            <verstretch>0</verstretch>\n           </sizepolicy>\n          </property>\n          <property name=\"minimumSize\">\n           <size>\n            <width>0</width>\n            <height>65</height>\n           </size>\n          </property>\n          <property name=\"maximumSize\">\n           <size>\n            <width>16777215</width>\n            <height>65</height>\n           </size>\n          </property>\n          <property name=\"palette\">\n           <palette>\n            <active>\n             <colorrole role=\"Base\">\n              <brush brushstyle=\"SolidPattern\">\n               <color alpha=\"255\">\n                <red>224</red>\n                <green>223</green>\n                <blue>222</blue>\n               </color>\n              </brush>\n             </colorrole>\n            </active>\n            <inactive>\n             <colorrole role=\"Base\">\n              <brush brushstyle=\"SolidPattern\">\n               <color alpha=\"255\">\n                <red>224</red>\n                <green>223</green>\n                <blue>222</blue>\n               </color>\n              </brush>\n             </colorrole>\n            </inactive>\n            <disabled>\n             <colorrole role=\"Base\">\n              <brush brushstyle=\"SolidPattern\">\n               <color alpha=\"255\">\n                <red>224</red>\n                <green>223</green>\n                <blue>222</blue>\n               </color>\n              </brush>\n             </colorrole>\n            </disabled>\n           </palette>\n          </property>\n          <property name=\"frameShape\">\n           <enum>QFrame::NoFrame</enum>\n          </property>\n          <property name=\"lineWrapMode\">\n           <enum>QPlainTextEdit::NoWrap</enum>\n          </property>\n          <property name=\"readOnly\">\n           <bool>true</bool>\n          </property>\n         </widget>\n        </item>\n       </layout>\n      </widget>\n     </item>\n    </layout>\n   </item>\n   <item>\n    <widget class=\"QLabel\" name=\"label_3\">\n     <property name=\"text\">\n      <string>Adjust the order by dragging and dropping items in it. Drop dictionaries to the inactive group to disable their use.</string>\n     </property>\n     <property name=\"wordWrap\">\n      <bool>true</bool>\n     </property>\n    </widget>\n   </item>\n  </layout>\n </widget>\n <customwidgets>\n  <customwidget>\n   <class>DictListWidget</class>\n   <extends>QListWidget</extends>\n   <header>groups_widgets.hh</header>\n  </customwidget>\n  <customwidget>\n   <class>QuickFilterLine</class>\n   <extends>QLineEdit</extends>\n   <header>groups_widgets.hh</header>\n  </customwidget>\n </customwidgets>\n <tabstops>\n  <tabstop>dictionaryOrder</tabstop>\n  <tabstop>inactiveDictionaries</tabstop>\n  <tabstop>dictionaryDescription</tabstop>\n  <tabstop>dictionaryFileList</tabstop>\n  <tabstop>searchLine</tabstop>\n </tabstops>\n <resources/>\n <connections/>\n</ui>\n"
        },
        {
          "name": "parsecmdline.cc",
          "type": "blob",
          "size": 1.041015625,
          "content": "#include \"parsecmdline.hh\"\n\nQStringList parseCommandLine( QString const & commandLine )\n{\n  // Parse arguments. Handle quotes correctly.\n  QStringList args;\n  bool openQuote = false;\n  bool possibleDoubleQuote = false;\n  bool startNew = true;\n  for( QString::const_iterator c = commandLine.begin(),\n       e = commandLine.end(); c != e; )\n  {\n    if ( *c == '\"' && !possibleDoubleQuote )\n    {\n      ++c;\n      if ( !openQuote )\n      {\n        openQuote = true;\n        if ( startNew )\n        {\n          args.push_back( QString() );\n          startNew = false;\n        }\n      }\n      else\n        possibleDoubleQuote = true;\n    }\n    else\n    if ( possibleDoubleQuote && *c != '\"' )\n    {\n      openQuote = false;\n      possibleDoubleQuote = false;\n    }\n    else\n    if ( *c == ' ' && !openQuote )\n    {\n      ++c;\n      startNew = true;\n    }\n    else\n    {\n      if ( startNew )\n      {\n        args.push_back( QString() );\n        startNew = false;\n      }\n      args.last().push_back( *c++ );\n      possibleDoubleQuote = false;\n    }\n  }\n\n  return args;\n}\n"
        },
        {
          "name": "parsecmdline.hh",
          "type": "blob",
          "size": 0.3173828125,
          "content": "#ifndef PARSECMDLINE_HH\n#define PARSECMDLINE_HH\n\n#include <QStringList>\n\n/// Given a command line (name of the executable with optional arguments),\n/// separates-out the name and all the arguments into a list. Supports quotes\n/// and double-quotes.\nQStringList parseCommandLine( QString const & );\n\n#endif // PARSECMDLINE_HH\n"
        },
        {
          "name": "preferences.cc",
          "type": "blob",
          "size": 24.7919921875,
          "content": "#include \"preferences.hh\"\n#include \"keyboardstate.hh\"\n#include \"language.hh\"\n#include \"langcoder.hh\"\n#include <QMessageBox>\n#include \"broken_xrecord.hh\"\n#include \"mainwindow.hh\"\n\n#include <algorithm>\n#include <vector>\n\nnamespace {\nstruct ComboBoxItem\n{\n  QIcon icon;\n  QString text;\n  QString userData;\n\n  explicit ComboBoxItem( QString const & languageCode, QString const & countryCode, QString const & userData_ ):\n    icon( QString( \":/flags/%1.png\" ).arg( countryCode ) ),\n    text( Language::localizedNameForId( LangCoder::code2toInt( languageCode.toLatin1().data() ) ) ),\n    userData( userData_ )\n  {}\n};\n\nbool operator<( ComboBoxItem const & a, ComboBoxItem const & b )\n{\n  return a.text < b.text;\n}\n\nvoid orderAndAddItems( QComboBox & comboBox, std::vector< ComboBoxItem > & items )\n{\n  // Sort by language name, because otherwise the list looks really weird.\n  std::sort( items.begin(), items.end() );\n  for( std::vector< ComboBoxItem >::iterator i = items.begin(); i != items.end(); ++i )\n    comboBox.addItem( i->icon, i->text, i->userData );\n}\n\n} // unnamed namespace\n\nPreferences::Preferences( QWidget * parent, Config::Class & cfg_ ):\n  QDialog( parent ), prevInterfaceLanguage( 0 )\n, helpWindow( 0 )\n, cfg( cfg_ )\n, helpAction( this )\n{\n  Config::Preferences const & p = cfg_.preferences;\n  ui.setupUi( this );\n\n  connect( ui.enableScanPopup, SIGNAL( toggled( bool ) ),\n           this, SLOT( enableScanPopupToggled( bool ) ) );\n\n  connect( ui.enableScanPopupModifiers, SIGNAL( toggled( bool ) ),\n           this, SLOT( enableScanPopupModifiersToggled( bool ) ) );\n\n  connect( ui.showScanFlag, SIGNAL( toggled( bool ) ),\n           this, SLOT( showScanFlagToggled( bool ) ) );\n\n  connect( ui.altKey, SIGNAL( clicked( bool ) ),\n           this, SLOT( wholeAltClicked( bool ) ) );\n  connect( ui.ctrlKey, SIGNAL( clicked( bool ) ),\n           this, SLOT( wholeCtrlClicked( bool ) ) );\n  connect( ui.shiftKey, SIGNAL( clicked( bool ) ),\n           this, SLOT( wholeShiftClicked( bool ) ) );\n\n  connect( ui.leftAlt, SIGNAL( clicked( bool ) ),\n           this, SLOT( sideAltClicked( bool ) ) );\n  connect( ui.rightAlt, SIGNAL( clicked( bool ) ),\n           this, SLOT( sideAltClicked( bool ) ) );\n  connect( ui.leftCtrl, SIGNAL( clicked( bool ) ),\n           this, SLOT( sideCtrlClicked( bool ) ) );\n  connect( ui.rightCtrl, SIGNAL( clicked( bool ) ),\n           this, SLOT( sideCtrlClicked( bool ) ) );\n  connect( ui.leftShift, SIGNAL( clicked( bool ) ),\n           this, SLOT( sideShiftClicked( bool ) ) );\n  connect( ui.rightShift, SIGNAL( clicked( bool ) ),\n           this, SLOT( sideShiftClicked( bool ) ) );\n\n  connect( ui.buttonBox, SIGNAL( helpRequested() ),\n           this, SLOT( helpRequested() ) );\n\n  helpAction.setShortcut( QKeySequence( \"F1\" ) );\n  helpAction.setShortcutContext( Qt::WidgetWithChildrenShortcut );\n\n  connect( &helpAction, SIGNAL( triggered() ),\n           this, SLOT( helpRequested() ) );\n\n  addAction( &helpAction );\n\n  // Load values into form\n\n  ui.interfaceLanguage->addItem( tr( \"System default\" ), QString() );\n  ui.interfaceLanguage->addItem( QIcon( \":/flags/us.png\" ), Language::localizedNameForId( LangCoder::code2toInt( \"en\" ) ), QString( \"en_US\" ) );\n\n  // See which other translations do we have\n\n  QStringList availLocs = QDir( Config::getLocDir() ).entryList( QStringList( \"*.qm\" ),\n                                                                 QDir::Files );\n\n  std::vector< ComboBoxItem > locs;\n  locs.reserve( availLocs.size() );\n\n  for( QStringList::iterator i = availLocs.begin(); i != availLocs.end(); ++i )\n  {\n    // Here we assume the xx_YY naming, where xx is language and YY is region.\n    QString lang = i->mid( 0, 2 );\n\n    if ( lang == \"qt\" )\n      continue; // We skip qt's own localizations\n\n    locs.push_back( ComboBoxItem( lang, i->mid( 3, 2 ).toLower(), i->mid( 0, i->size() - 3 ) ) );\n  }\n\n  orderAndAddItems( *ui.interfaceLanguage, locs );\n\n  for( int x = 0; x < ui.interfaceLanguage->count(); ++x )\n    if ( ui.interfaceLanguage->itemData( x ).toString() == p.interfaceLanguage )\n    {\n      ui.interfaceLanguage->setCurrentIndex( x );\n      prevInterfaceLanguage = x;\n      break;\n    }\n\n  // Fill help languages combobox\n\n  ui.helpLanguage->addItem( tr( \"Default\" ), QString() );\n\n  // See which helps do we have\n\n  QStringList availHelps = QDir( Config::getHelpDir() ).entryList( QStringList( \"*.qch\" ),\n                                                                 QDir::Files );\n\n  std::vector< ComboBoxItem > helps;\n  helps.reserve( availHelps.size() );\n\n  for( QStringList::iterator i = availHelps.begin(); i != availHelps.end(); ++i )\n  {\n    QString loc = i->mid( 7, i->length() - 11 ); // e.g. *i == \"gdhelp_en.qch\" => loc == \"en\"\n    QString lang = loc.mid( 0, 2 );\n    QString reg;\n    if(loc.length() >= 5 )\n      reg = loc.mid( 3, 2 ).toLower();\n    else\n    {\n      if( lang.compare( \"en\", Qt::CaseInsensitive ) == 0 )\n        reg = \"US\";\n      else\n        reg = lang.toUpper();\n    }\n\n    helps.push_back( ComboBoxItem( lang, reg.toLower(), lang + \"_\" + reg ) );\n  }\n\n  orderAndAddItems( *ui.helpLanguage, helps );\n\n  for( int x = 0; x < ui.helpLanguage->count(); ++x )\n    if ( ui.helpLanguage->itemData( x ).toString() == p.helpLanguage )\n    {\n      ui.helpLanguage->setCurrentIndex( x );\n      break;\n    }\n\n  ui.displayStyle->addItem( QIcon( \":/icons/programicon_old.png\" ), tr( \"Default\" ), QString() );\n  ui.displayStyle->addItem( QIcon( \":/icons/programicon.png\" ), tr( \"Modern\" ), QString( \"modern\" ) );\n  ui.displayStyle->addItem( QIcon( \":/icons/icon32_dsl.png\" ), tr( \"Lingvo\" ), QString( \"lingvo\" ) );\n  ui.displayStyle->addItem( QIcon( \":/icons/icon32_bgl.png\" ), tr( \"Babylon\" ), QString( \"babylon\" ) );\n  ui.displayStyle->addItem( QIcon( \":/icons/icon32_lingoes.png\" ), tr( \"Lingoes\" ), QString( \"lingoes\" ) );\n  ui.displayStyle->addItem( QIcon( \":/icons/icon32_lingoes.png\" ), tr( \"Lingoes-Blue\" ), QString( \"lingoes-blue\" ) );\n\n  for( int x = 0; x < ui.displayStyle->count(); ++x )\n    if ( ui.displayStyle->itemData( x ).toString() == p.displayStyle )\n    {\n      ui.displayStyle->setCurrentIndex( x );\n      break;\n    }\n\n#ifdef Q_OS_WIN32\n  // 1 MB stands for 2^20 bytes on Windows. \"MiB\" is never used by this OS.\n  ui.maxNetworkCacheSize->setSuffix( tr( \" MB\" ) );\n#endif\n  ui.maxNetworkCacheSize->setToolTip( ui.maxNetworkCacheSize->toolTip().arg( Config::getNetworkCacheDir() ) );\n\n  ui.newTabsOpenAfterCurrentOne->setChecked( p.newTabsOpenAfterCurrentOne );\n  ui.newTabsOpenInBackground->setChecked( p.newTabsOpenInBackground );\n  ui.hideSingleTab->setChecked( p.hideSingleTab );\n  ui.mruTabOrder->setChecked( p.mruTabOrder );\n  ui.enableTrayIcon->setChecked( p.enableTrayIcon );\n  ui.startToTray->setChecked( p.startToTray );\n  ui.closeToTray->setChecked( p.closeToTray );\n  ui.cbAutostart->setChecked( p.autoStart );\n  ui.doubleClickTranslates->setChecked( p.doubleClickTranslates );\n  ui.selectBySingleClick->setChecked( p.selectWordBySingleClick);\n  ui.escKeyHidesMainWindow->setChecked( p.escKeyHidesMainWindow );\n\n  ui.enableMainWindowHotkey->setChecked( p.enableMainWindowHotkey );\n  ui.mainWindowHotkey->setHotKey( p.mainWindowHotkey );\n  ui.enableClipboardHotkey->setChecked( p.enableClipboardHotkey );\n  ui.clipboardHotkey->setHotKey( p.clipboardHotkey );\n\n  ui.enableScanPopup->setChecked( p.enableScanPopup );\n  ui.startWithScanPopupOn->setChecked( p.startWithScanPopupOn );\n  ui.enableScanPopupModifiers->setChecked( p.enableScanPopupModifiers );\n\n  ui.altKey->setChecked( p.scanPopupModifiers & KeyboardState::Alt );\n  ui.ctrlKey->setChecked( p.scanPopupModifiers & KeyboardState::Ctrl );\n  ui.shiftKey->setChecked( p.scanPopupModifiers & KeyboardState::Shift );\n  ui.winKey->setChecked( p.scanPopupModifiers & KeyboardState::Win );\n  ui.leftAlt->setChecked( p.scanPopupModifiers & KeyboardState::LeftAlt );\n  ui.rightAlt->setChecked( p.scanPopupModifiers & KeyboardState::RightAlt );\n  ui.leftCtrl->setChecked( p.scanPopupModifiers & KeyboardState::LeftCtrl );\n  ui.rightCtrl->setChecked( p.scanPopupModifiers & KeyboardState::RightCtrl );\n  ui.leftShift->setChecked( p.scanPopupModifiers & KeyboardState::LeftShift );\n  ui.rightShift->setChecked( p.scanPopupModifiers & KeyboardState::RightShift );\n\n  ui.scanPopupAltMode->setChecked( p.scanPopupAltMode );\n  ui.scanPopupAltModeSecs->setValue( p.scanPopupAltModeSecs );\n  ui.ignoreOwnClipboardChanges->setChecked( p.ignoreOwnClipboardChanges );\n  ui.scanToMainWindow->setChecked( p.scanToMainWindow );\n  ui.scanPopupUseUIAutomation->setChecked( p.scanPopupUseUIAutomation );\n  ui.scanPopupUseIAccessibleEx->setChecked( p.scanPopupUseIAccessibleEx );\n  ui.scanPopupUseGDMessage->setChecked( p.scanPopupUseGDMessage );\n  ui.scanPopupUnpinnedWindowFlags->setCurrentIndex( p.scanPopupUnpinnedWindowFlags );\n  ui.scanPopupUnpinnedBypassWMHint->setChecked( p.scanPopupUnpinnedBypassWMHint );\n\n  ui.storeHistory->setChecked( p.storeHistory );\n  ui.historyMaxSizeField->setValue( p.maxStringsInHistory );\n  ui.historySaveIntervalField->setValue( p.historyStoreInterval );\n  ui.alwaysExpandOptionalParts->setChecked( p.alwaysExpandOptionalParts );\n\n  ui.favoritesSaveIntervalField->setValue( p.favoritesStoreInterval );\n  ui.confirmFavoritesDeletion->setChecked( p.confirmFavoritesDeletion );\n\n  ui.collapseBigArticles->setChecked( p.collapseBigArticles );\n  on_collapseBigArticles_toggled( ui.collapseBigArticles->isChecked() );\n  ui.articleSizeLimit->setValue( p.articleSizeLimit );\n\n  ui.limitInputPhraseLength->setChecked( p.limitInputPhraseLength );\n  on_limitInputPhraseLength_toggled( ui.limitInputPhraseLength->isChecked() );\n  ui.inputPhraseLengthLimit->setValue( p.inputPhraseLengthLimit );\n\n  ui.ignoreDiacritics->setChecked( p.ignoreDiacritics );\n\n  ui.synonymSearchEnabled->setChecked( p.synonymSearchEnabled );\n\n  ui.maxDictsInContextMenu->setValue( p.maxDictionaryRefsInContextMenu );\n\n  // Different platforms have different keys available\n\n#ifdef Q_OS_WIN32\n  ui.winKey->hide();\n#else\n  ui.leftAlt->hide();\n  ui.rightAlt->hide();\n  ui.leftCtrl->hide();\n  ui.rightCtrl->hide();\n  ui.leftShift->hide();\n  ui.rightShift->hide();\n#ifdef Q_OS_MAC\n  ui.altKey->setText( \"Opt\" );\n  ui.winKey->setText( \"Ctrl\" );\n  ui.ctrlKey->setText( \"Cmd\" );\n#endif\n#endif\n\n//Platform-specific options\n\n#ifndef Q_OS_WIN32\n  ui.groupBox_ScanPopupTechnologies->hide();\n//  ui.tabWidget->removeTab( 5 );\n#endif\n\n#ifndef ENABLE_SPWF_CUSTOMIZATION\n  ui.groupBox_ScanPopupWindowFlags->hide();\n#endif\n\n#ifdef HAVE_X11\n  ui.showScanFlag->setChecked( p.showScanFlag);\n#else\n  ui.showScanFlag->hide();\n  ui.ignoreOwnClipboardChanges->hide();\n#endif\n\n  // Sound\n\n  ui.pronounceOnLoadMain->setChecked( p.pronounceOnLoadMain );\n  ui.pronounceOnLoadPopup->setChecked( p.pronounceOnLoadPopup );\n\n  ui.internalPlayerBackend->addItems( Config::InternalPlayerBackend::nameList() );\n\n  // Make sure that exactly one radio button in the group is checked and that\n  // on_useExternalPlayer_toggled() is called.\n  ui.useExternalPlayer->setChecked( true );\n\n  if( ui.internalPlayerBackend->count() > 0 )\n  {\n    // Checking ui.useInternalPlayer automatically unchecks ui.useExternalPlayer.\n    ui.useInternalPlayer->setChecked( p.useInternalPlayer );\n\n    int index = ui.internalPlayerBackend->findText( p.internalPlayerBackend.uiName() );\n    if( index < 0 ) // The specified backend is unavailable.\n      index = ui.internalPlayerBackend->findText( Config::InternalPlayerBackend::defaultBackend().uiName() );\n    Q_ASSERT( index >= 0 && \"Logic error: the default backend must be present in the backend name list.\" );\n    ui.internalPlayerBackend->setCurrentIndex( index );\n  }\n  else\n  {\n    ui.useInternalPlayer->hide();\n    ui.internalPlayerBackend->hide();\n  }\n\n  ui.audioPlaybackProgram->setText( p.audioPlaybackProgram );\n\n  if ( !isRECORDBroken() )\n    ui.brokenXRECORD->hide();\n\n  // Proxy server\n\n  ui.useProxyServer->setChecked( p.proxyServer.enabled );\n\n  ui.proxyType->addItem( \"SOCKS5\" );\n  ui.proxyType->addItem( \"HTTP Transp.\" );\n  ui.proxyType->addItem( \"HTTP Caching\" );\n\n  ui.proxyType->setCurrentIndex( p.proxyServer.type );\n\n  ui.proxyHost->setText( p.proxyServer.host );\n  ui.proxyPort->setValue( p.proxyServer.port );\n\n  ui.proxyUser->setText( p.proxyServer.user );\n  ui.proxyPassword->setText( p.proxyServer.password );\n\n  if( p.proxyServer.useSystemProxy )\n  {\n    ui.systemProxy->setChecked( true );\n    ui.customSettingsGroup->setEnabled( false );\n  }\n  else\n  {\n    ui.customProxy->setChecked( true );\n    ui.customSettingsGroup->setEnabled( p.proxyServer.enabled );\n  }\n\n  connect( ui.customProxy, SIGNAL( toggled( bool ) ),\n           this, SLOT( customProxyToggled( bool ) ) );\n\n  connect( ui.useProxyServer, SIGNAL( toggled( bool ) ),\n           this, SLOT( customProxyToggled( bool ) ) );\n\n  ui.checkForNewReleases->setChecked( p.checkForNewReleases );\n  ui.disallowContentFromOtherSites->setChecked( p.disallowContentFromOtherSites );\n  ui.enableWebPlugins->setChecked( p.enableWebPlugins );\n  ui.hideGoldenDictHeader->setChecked( p.hideGoldenDictHeader );\n  ui.maxNetworkCacheSize->setValue( p.maxNetworkCacheSize );\n  ui.clearNetworkCacheOnExit->setChecked( p.clearNetworkCacheOnExit );\n\n  // Add-on styles\n  ui.addonStylesLabel->setVisible( ui.addonStyles->count() > 1 );\n  ui.addonStyles->setCurrentStyle( p.addonStyle );\n\n  // Full-text search parameters\n  ui.ftsGroupBox->setChecked( p.fts.enabled );\n\n  ui.allowAard->setChecked( !p.fts.disabledTypes.contains( \"AARD\", Qt::CaseInsensitive ) );\n  ui.allowBGL->setChecked( !p.fts.disabledTypes.contains( \"BGL\", Qt::CaseInsensitive ) );\n  ui.allowDictD->setChecked( !p.fts.disabledTypes.contains( \"DICTD\", Qt::CaseInsensitive ) );\n  ui.allowDSL->setChecked( !p.fts.disabledTypes.contains( \"DSL\", Qt::CaseInsensitive ) );\n  ui.allowMDict->setChecked( !p.fts.disabledTypes.contains( \"MDICT\", Qt::CaseInsensitive ) );\n  ui.allowSDict->setChecked( !p.fts.disabledTypes.contains( \"SDICT\", Qt::CaseInsensitive ) );\n  ui.allowSlob->setChecked( !p.fts.disabledTypes.contains( \"SLOB\", Qt::CaseInsensitive ) );\n  ui.allowStardict->setChecked( !p.fts.disabledTypes.contains( \"STARDICT\", Qt::CaseInsensitive ) );\n  ui.allowXDXF->setChecked( !p.fts.disabledTypes.contains( \"XDXF\", Qt::CaseInsensitive ) );\n  ui.allowZim->setChecked( !p.fts.disabledTypes.contains( \"ZIM\", Qt::CaseInsensitive ) );\n  ui.allowEpwing->setChecked( !p.fts.disabledTypes.contains( \"EPWING\", Qt::CaseInsensitive ) );\n  ui.allowGls->setChecked( !p.fts.disabledTypes.contains( \"GLS\", Qt::CaseInsensitive ) );\n#ifndef MAKE_ZIM_SUPPORT\n  ui.allowZim->hide();\n  ui.allowSlob->hide();\n#endif\n#ifdef NO_EPWING_SUPPORT\n  ui.allowEpwing->hide();\n#endif\n  ui.maxDictionarySize->setValue( p.fts.maxDictionarySize );\n}\n\nConfig::Preferences Preferences::getPreferences()\n{\n  Config::Preferences p;\n\n  p.interfaceLanguage =\n    ui.interfaceLanguage->itemData(\n      ui.interfaceLanguage->currentIndex() ).toString();\n\n  p.helpLanguage =\n    ui.helpLanguage->itemData(\n      ui.helpLanguage->currentIndex() ).toString();\n\n  p.displayStyle =\n    ui.displayStyle->itemData(\n      ui.displayStyle->currentIndex() ).toString();\n\n  p.newTabsOpenAfterCurrentOne = ui.newTabsOpenAfterCurrentOne->isChecked();\n  p.newTabsOpenInBackground = ui.newTabsOpenInBackground->isChecked();\n  p.hideSingleTab = ui.hideSingleTab->isChecked();\n  p.mruTabOrder = ui.mruTabOrder->isChecked();\n  p.enableTrayIcon = ui.enableTrayIcon->isChecked();\n  p.startToTray = ui.startToTray->isChecked();\n  p.closeToTray = ui.closeToTray->isChecked();\n  p.autoStart = ui.cbAutostart->isChecked();\n  p.doubleClickTranslates = ui.doubleClickTranslates->isChecked();\n  p.selectWordBySingleClick = ui.selectBySingleClick->isChecked();\n  p.escKeyHidesMainWindow = ui.escKeyHidesMainWindow->isChecked();\n\n  p.enableMainWindowHotkey = ui.enableMainWindowHotkey->isChecked();\n  p.mainWindowHotkey = ui.mainWindowHotkey->getHotKey();\n  p.enableClipboardHotkey = ui.enableClipboardHotkey->isChecked();\n  p.clipboardHotkey = ui.clipboardHotkey->getHotKey();\n\n  p.enableScanPopup = ui.enableScanPopup->isChecked();\n  p.startWithScanPopupOn = ui.startWithScanPopupOn->isChecked();\n  p.enableScanPopupModifiers = ui.enableScanPopupModifiers->isChecked();\n\n  p.scanPopupModifiers += ui.altKey->isChecked() ? KeyboardState::Alt : 0;\n  p.scanPopupModifiers += ui.ctrlKey->isChecked() ? KeyboardState::Ctrl: 0;\n  p.scanPopupModifiers += ui.shiftKey->isChecked() ? KeyboardState::Shift: 0;\n  p.scanPopupModifiers += ui.winKey->isChecked() ? KeyboardState::Win: 0;\n  p.scanPopupModifiers += ui.leftAlt->isChecked() ? KeyboardState::LeftAlt: 0;\n  p.scanPopupModifiers += ui.rightAlt->isChecked() ? KeyboardState::RightAlt: 0;\n  p.scanPopupModifiers += ui.leftCtrl->isChecked() ? KeyboardState::LeftCtrl: 0;\n  p.scanPopupModifiers += ui.rightCtrl->isChecked() ? KeyboardState::RightCtrl: 0;\n  p.scanPopupModifiers += ui.leftShift->isChecked() ? KeyboardState::LeftShift: 0;\n  p.scanPopupModifiers += ui.rightShift->isChecked() ? KeyboardState::RightShift: 0;\n\n  p.scanPopupAltMode = ui.scanPopupAltMode->isChecked();\n  p.scanPopupAltModeSecs = ui.scanPopupAltModeSecs->value();\n  p.ignoreOwnClipboardChanges = ui.ignoreOwnClipboardChanges->isChecked();\n  p.scanToMainWindow = ui.scanToMainWindow->isChecked();\n#ifdef HAVE_X11\n  p.showScanFlag= ui.showScanFlag->isChecked();\n#endif\n  p.scanPopupUseUIAutomation = ui.scanPopupUseUIAutomation->isChecked();\n  p.scanPopupUseIAccessibleEx = ui.scanPopupUseIAccessibleEx->isChecked();\n  p.scanPopupUseGDMessage = ui.scanPopupUseGDMessage->isChecked();\n  p.scanPopupUnpinnedWindowFlags = Config::spwfFromInt( ui.scanPopupUnpinnedWindowFlags->currentIndex() );\n  p.scanPopupUnpinnedBypassWMHint = ui.scanPopupUnpinnedBypassWMHint->isChecked();\n\n  p.storeHistory = ui.storeHistory->isChecked();\n  p.maxStringsInHistory = ui.historyMaxSizeField->text().toUInt();\n  p.historyStoreInterval = ui.historySaveIntervalField->text().toUInt();\n  p.alwaysExpandOptionalParts = ui.alwaysExpandOptionalParts->isChecked();\n\n  p.favoritesStoreInterval = ui.favoritesSaveIntervalField->text().toUInt();\n  p.confirmFavoritesDeletion = ui.confirmFavoritesDeletion->isChecked();\n\n  p.collapseBigArticles = ui.collapseBigArticles->isChecked();\n  p.articleSizeLimit = ui.articleSizeLimit->value();\n  p.limitInputPhraseLength = ui.limitInputPhraseLength->isChecked();\n  p.inputPhraseLengthLimit = ui.inputPhraseLengthLimit->value();\n  p.ignoreDiacritics = ui.ignoreDiacritics->isChecked();\n\n  p.synonymSearchEnabled = ui.synonymSearchEnabled->isChecked();\n\n  p.maxDictionaryRefsInContextMenu = ui.maxDictsInContextMenu->text().toInt();\n\n  p.pronounceOnLoadMain = ui.pronounceOnLoadMain->isChecked();\n  p.pronounceOnLoadPopup = ui.pronounceOnLoadPopup->isChecked();\n  p.useInternalPlayer = ui.useInternalPlayer->isChecked();\n  p.internalPlayerBackend.setUiName( ui.internalPlayerBackend->currentText() );\n  p.audioPlaybackProgram = ui.audioPlaybackProgram->text();\n\n  p.proxyServer.enabled = ui.useProxyServer->isChecked();\n  p.proxyServer.useSystemProxy = ui.systemProxy->isChecked();\n\n  p.proxyServer.type = ( Config::ProxyServer::Type ) ui.proxyType->currentIndex();\n\n  p.proxyServer.host = ui.proxyHost->text();\n  p.proxyServer.port = ( unsigned ) ui.proxyPort->value();\n\n  p.proxyServer.user = ui.proxyUser->text();\n  p.proxyServer.password = ui.proxyPassword->text();\n\n  p.checkForNewReleases = ui.checkForNewReleases->isChecked();\n  p.disallowContentFromOtherSites = ui.disallowContentFromOtherSites->isChecked();\n  p.enableWebPlugins = ui.enableWebPlugins->isChecked();\n  p.hideGoldenDictHeader = ui.hideGoldenDictHeader->isChecked();\n  p.maxNetworkCacheSize = ui.maxNetworkCacheSize->value();\n  p.clearNetworkCacheOnExit = ui.clearNetworkCacheOnExit->isChecked();\n\n  p.addonStyle = ui.addonStyles->getCurrentStyle();\n\n  p.fts.enabled = ui.ftsGroupBox->isChecked();\n  p.fts.maxDictionarySize = ui.maxDictionarySize->value();\n\n  if( !ui.allowAard->isChecked() )\n  {\n    if( !p.fts.disabledTypes.isEmpty() )\n      p.fts.disabledTypes += ',';\n    p.fts.disabledTypes += \"AARD\";\n  }\n\n  if( !ui.allowBGL->isChecked() )\n  {\n    if( !p.fts.disabledTypes.isEmpty() )\n      p.fts.disabledTypes += ',';\n    p.fts.disabledTypes += \"BGL\";\n  }\n\n  if( !ui.allowDictD->isChecked() )\n  {\n    if( !p.fts.disabledTypes.isEmpty() )\n      p.fts.disabledTypes += ',';\n    p.fts.disabledTypes += \"DICTD\";\n  }\n\n  if( !ui.allowDSL->isChecked() )\n  {\n    if( !p.fts.disabledTypes.isEmpty() )\n      p.fts.disabledTypes += ',';\n    p.fts.disabledTypes += \"DSL\";\n  }\n\n  if( !ui.allowMDict->isChecked() )\n  {\n    if( !p.fts.disabledTypes.isEmpty() )\n      p.fts.disabledTypes += ',';\n    p.fts.disabledTypes += \"MDICT\";\n  }\n\n  if( !ui.allowSDict->isChecked() )\n  {\n    if( !p.fts.disabledTypes.isEmpty() )\n      p.fts.disabledTypes += ',';\n    p.fts.disabledTypes += \"SDICT\";\n  }\n\n  if( !ui.allowSlob->isChecked() )\n  {\n    if( !p.fts.disabledTypes.isEmpty() )\n      p.fts.disabledTypes += ',';\n    p.fts.disabledTypes += \"SLOB\";\n  }\n\n  if( !ui.allowStardict->isChecked() )\n  {\n    if( !p.fts.disabledTypes.isEmpty() )\n      p.fts.disabledTypes += ',';\n    p.fts.disabledTypes += \"STARDICT\";\n  }\n\n  if( !ui.allowXDXF->isChecked() )\n  {\n    if( !p.fts.disabledTypes.isEmpty() )\n      p.fts.disabledTypes += ',';\n    p.fts.disabledTypes += \"XDXF\";\n  }\n\n  if( !ui.allowZim->isChecked() )\n  {\n    if( !p.fts.disabledTypes.isEmpty() )\n      p.fts.disabledTypes += ',';\n    p.fts.disabledTypes += \"ZIM\";\n  }\n\n  if( !ui.allowEpwing->isChecked() )\n  {\n    if( !p.fts.disabledTypes.isEmpty() )\n      p.fts.disabledTypes += ',';\n    p.fts.disabledTypes += \"EPWING\";\n  }\n\n  if( !ui.allowGls->isChecked() )\n  {\n    if( !p.fts.disabledTypes.isEmpty() )\n      p.fts.disabledTypes += ',';\n    p.fts.disabledTypes += \"GLS\";\n  }\n\n  return p;\n}\n\nvoid Preferences::enableScanPopupToggled( bool b )\n{\n  ui.scanPopupModifiers->setEnabled( b && ui.enableScanPopupModifiers->isChecked() );\n}\n\nvoid Preferences::enableScanPopupModifiersToggled( bool b )\n{\n  ui.scanPopupModifiers->setEnabled( b && ui.enableScanPopup->isChecked() );\n  if( b )\n    ui.showScanFlag->setChecked( false );\n}\n\nvoid Preferences::showScanFlagToggled( bool b )\n{\n  if( b )\n    ui.enableScanPopupModifiers->setChecked( false );\n}\n\nvoid Preferences::on_scanPopupUnpinnedWindowFlags_currentIndexChanged( int index )\n{\n  ui.scanPopupUnpinnedBypassWMHint->setEnabled( Config::spwfFromInt( index ) != Config::SPWF_default );\n}\n\nvoid Preferences::wholeAltClicked( bool b )\n{\n  if ( b )\n  {\n    ui.leftAlt->setChecked( false );\n    ui.rightAlt->setChecked( false );\n  }\n}\n\nvoid Preferences::wholeCtrlClicked( bool b )\n{\n  if ( b )\n  {\n    ui.leftCtrl->setChecked( false );\n    ui.rightCtrl->setChecked( false );\n  }\n}\n\nvoid Preferences::wholeShiftClicked( bool b )\n{\n  if ( b )\n  {\n    ui.leftShift->setChecked( false );\n    ui.rightShift->setChecked( false );\n  }\n}\n\nvoid Preferences::sideAltClicked( bool )\n{\n  if ( ui.leftAlt->isChecked() || ui.rightAlt->isChecked() )\n    ui.altKey->setChecked( false );\n}\n\nvoid Preferences::sideCtrlClicked( bool )\n{\n  if ( ui.leftCtrl->isChecked() || ui.rightCtrl->isChecked() )\n    ui.ctrlKey->setChecked( false );\n}\n\nvoid Preferences::sideShiftClicked( bool )\n{\n  if ( ui.leftShift->isChecked() || ui.rightShift->isChecked() )\n    ui.shiftKey->setChecked( false );\n}\n\nvoid Preferences::on_enableMainWindowHotkey_toggled( bool checked )\n{\n  ui.mainWindowHotkey->setEnabled( checked );\n}\n\nvoid Preferences::on_enableClipboardHotkey_toggled( bool checked )\n{\n  ui.clipboardHotkey->setEnabled( checked );\n}\n\nvoid Preferences::on_buttonBox_accepted()\n{\n  if ( prevInterfaceLanguage != ui.interfaceLanguage->currentIndex() )\n    QMessageBox::information( this, tr( \"Changing Language\" ),\n                              tr( \"Restart the program to apply the language change.\" ) );\n}\n\nvoid Preferences::on_useExternalPlayer_toggled( bool enabled )\n{\n  ui.internalPlayerBackend->setEnabled( !enabled );\n  ui.audioPlaybackProgram->setEnabled( enabled );\n}\n\nvoid Preferences::customProxyToggled( bool )\n{\n  ui.customSettingsGroup->setEnabled( ui.customProxy->isChecked()\n                                      && ui.useProxyServer->isChecked() );\n}\n\nvoid Preferences::on_maxNetworkCacheSize_valueChanged( int value )\n{\n  ui.clearNetworkCacheOnExit->setEnabled( value != 0 );\n}\n\nvoid Preferences::on_collapseBigArticles_toggled( bool checked )\n{\n  ui.articleSizeLimit->setEnabled( checked );\n}\n\nvoid Preferences::on_limitInputPhraseLength_toggled( bool checked )\n{\n  ui.inputPhraseLengthLimit->setEnabled( checked );\n}\n\nvoid Preferences::helpRequested()\n{\n  if( !helpWindow )\n  {\n    MainWindow * mainWindow = qobject_cast< MainWindow * >( parentWidget() );\n    if( mainWindow )\n      mainWindow->closeGDHelp();\n\n    helpWindow = new Help::HelpWindow( this, cfg );\n\n    if( helpWindow )\n    {\n      #ifdef Q_OS_MAC\n        helpWindow->setWindowFlags( Qt::Dialog );\n      #else\n        helpWindow->setWindowFlags( Qt::Window );\n      #endif\n\n      connect( helpWindow, SIGNAL( needClose() ),\n               this, SLOT( closeHelp() ) );\n      helpWindow->showHelpFor( \"Preferences\" );\n      helpWindow->show();\n      #ifdef Q_OS_MAC\n        helpWindow->activateWindow();\n      #endif\n    }\n  }\n  else\n  {\n    if( !helpWindow->isVisible() )\n      helpWindow->show();\n\n    helpWindow->activateWindow();\n  }\n}\n\nvoid Preferences::closeHelp()\n{\n  if( helpWindow )\n    helpWindow->hide();\n}\n"
        },
        {
          "name": "preferences.hh",
          "type": "blob",
          "size": 1.4345703125,
          "content": "#ifndef __PREFERENCES_HH_INCLUDED__\n#define __PREFERENCES_HH_INCLUDED__\n\n#include <QDialog>\n#include \"config.hh\"\n#include \"helpwindow.hh\"\n#include \"ui_preferences.h\"\n\n/// Preferences dialog -- allows changing various program options.\nclass Preferences: public QDialog\n{\n  Q_OBJECT\n\n  int prevInterfaceLanguage;\n\n  Help::HelpWindow * helpWindow;\n  Config::Class & cfg;\n  QAction helpAction;\n\npublic:\n\n  Preferences( QWidget * parent, Config::Class & cfg_ );\n  ~Preferences()\n  { if( helpWindow ) delete helpWindow; }\n\n  Config::Preferences getPreferences();\n\nprivate:\n\n  Ui::Preferences ui;\n\nprivate slots:\n\n  void enableScanPopupToggled( bool );\n  void enableScanPopupModifiersToggled( bool );\n  void showScanFlagToggled( bool b );\n  void on_scanPopupUnpinnedWindowFlags_currentIndexChanged( int index );\n\n  void wholeAltClicked( bool );\n  void wholeCtrlClicked( bool );\n  void wholeShiftClicked( bool );\n\n  void sideAltClicked( bool );\n  void sideCtrlClicked( bool );\n  void sideShiftClicked( bool );\n\n  void on_enableMainWindowHotkey_toggled( bool checked );\n  void on_enableClipboardHotkey_toggled( bool checked );\n\n  void on_buttonBox_accepted();\n\n  void on_useExternalPlayer_toggled( bool enabled );\n\n  void customProxyToggled( bool );\n  void on_maxNetworkCacheSize_valueChanged( int value );\n\n  void on_collapseBigArticles_toggled( bool checked );\n  void on_limitInputPhraseLength_toggled( bool checked );\n\n  void helpRequested();\n  void closeHelp();\n};\n\n#endif\n\n"
        },
        {
          "name": "preferences.ui",
          "type": "blob",
          "size": 66.6708984375,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ui version=\"4.0\">\n <class>Preferences</class>\n <widget class=\"QDialog\" name=\"Preferences\">\n  <property name=\"geometry\">\n   <rect>\n    <x>0</x>\n    <y>0</y>\n    <width>636</width>\n    <height>431</height>\n   </rect>\n  </property>\n  <property name=\"windowTitle\">\n   <string>Preferences</string>\n  </property>\n  <property name=\"windowIcon\">\n   <iconset resource=\"resources.qrc\">\n    <normaloff>:/icons/configure.png</normaloff>:/icons/configure.png</iconset>\n  </property>\n  <property name=\"modal\">\n   <bool>true</bool>\n  </property>\n  <layout class=\"QVBoxLayout\" name=\"verticalLayout_8\">\n   <item>\n    <widget class=\"QTabWidget\" name=\"tabWidget\">\n     <property name=\"currentIndex\">\n      <number>0</number>\n     </property>\n     <property name=\"iconSize\">\n      <size>\n       <width>15</width>\n       <height>15</height>\n      </size>\n     </property>\n     <property name=\"usesScrollButtons\">\n      <bool>false</bool>\n     </property>\n     <property name=\"documentMode\">\n      <bool>false</bool>\n     </property>\n     <widget class=\"QWidget\" name=\"tab\">\n      <attribute name=\"icon\">\n       <iconset resource=\"resources.qrc\">\n        <normaloff>:/icons/interface.png</normaloff>:/icons/interface.png</iconset>\n      </attribute>\n      <attribute name=\"title\">\n       <string>&amp;Interface</string>\n      </attribute>\n      <layout class=\"QGridLayout\" name=\"gridLayout_2\">\n       <item row=\"2\" column=\"1\">\n        <widget class=\"QGroupBox\" name=\"groupBox_2\">\n         <property name=\"title\">\n          <string>Startup</string>\n         </property>\n         <layout class=\"QVBoxLayout\" name=\"verticalLayout_2\">\n          <item>\n           <widget class=\"QCheckBox\" name=\"cbAutostart\">\n            <property name=\"toolTip\">\n             <string>Automatically starts GoldenDict after operation system bootup.</string>\n            </property>\n            <property name=\"text\">\n             <string>Start with system</string>\n            </property>\n           </widget>\n          </item>\n         </layout>\n        </widget>\n       </item>\n       <item row=\"8\" column=\"0\" colspan=\"2\">\n        <layout class=\"QHBoxLayout\" name=\"horizontalLayout_4\">\n         <item>\n          <widget class=\"QLabel\" name=\"addonStylesLabel\">\n           <property name=\"text\">\n            <string>Add-on style:</string>\n           </property>\n          </widget>\n         </item>\n         <item>\n          <widget class=\"StylesComboBox\" name=\"addonStyles\"/>\n         </item>\n         <item>\n          <spacer name=\"horizontalSpacer_6\">\n           <property name=\"orientation\">\n            <enum>Qt::Horizontal</enum>\n           </property>\n           <property name=\"sizeHint\" stdset=\"0\">\n            <size>\n             <width>40</width>\n             <height>20</height>\n            </size>\n           </property>\n          </spacer>\n         </item>\n        </layout>\n       </item>\n       <item row=\"2\" column=\"0\">\n        <widget class=\"QGroupBox\" name=\"enableTrayIcon\">\n         <property name=\"toolTip\">\n          <string>When enabled, an icon appears in the system tray area which can be used\nto open main window and perform other tasks.</string>\n         </property>\n         <property name=\"title\">\n          <string>Enable system tray icon</string>\n         </property>\n         <property name=\"alignment\">\n          <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignVCenter</set>\n         </property>\n         <property name=\"flat\">\n          <bool>false</bool>\n         </property>\n         <property name=\"checkable\">\n          <bool>true</bool>\n         </property>\n         <property name=\"checked\">\n          <bool>false</bool>\n         </property>\n         <layout class=\"QVBoxLayout\" name=\"verticalLayout\">\n          <item>\n           <widget class=\"QCheckBox\" name=\"startToTray\">\n            <property name=\"toolTip\">\n             <string>With this on, the application starts directly to system tray without showing\nits main window.</string>\n            </property>\n            <property name=\"text\">\n             <string>Start to system tray</string>\n            </property>\n           </widget>\n          </item>\n          <item>\n           <widget class=\"QCheckBox\" name=\"closeToTray\">\n            <property name=\"toolTip\">\n             <string>With this on, an attempt to close main window would hide it instead of closing\nthe application.</string>\n            </property>\n            <property name=\"text\">\n             <string>Close to system tray</string>\n            </property>\n           </widget>\n          </item>\n         </layout>\n        </widget>\n       </item>\n       <item row=\"3\" column=\"0\">\n        <widget class=\"QCheckBox\" name=\"doubleClickTranslates\">\n         <property name=\"text\">\n          <string>Double-click translates the word clicked</string>\n         </property>\n        </widget>\n       </item>\n       <item row=\"5\" column=\"0\">\n        <widget class=\"QCheckBox\" name=\"escKeyHidesMainWindow\">\n         <property name=\"toolTip\">\n          <string>Normally, pressing ESC key moves focus to the translation line.\nWith this on however, it will hide the main window.</string>\n         </property>\n         <property name=\"text\">\n          <string>ESC key hides main window</string>\n         </property>\n        </widget>\n       </item>\n       <item row=\"4\" column=\"0\">\n        <widget class=\"QCheckBox\" name=\"selectBySingleClick\">\n         <property name=\"toolTip\">\n          <string>Turn this option on if you want to select words by single mouse click</string>\n         </property>\n         <property name=\"text\">\n          <string>Select word by single click</string>\n         </property>\n        </widget>\n       </item>\n       <item row=\"0\" column=\"0\" colspan=\"2\">\n        <spacer name=\"verticalSpacer_8\">\n         <property name=\"orientation\">\n          <enum>Qt::Vertical</enum>\n         </property>\n         <property name=\"sizeHint\" stdset=\"0\">\n          <size>\n           <width>20</width>\n           <height>40</height>\n          </size>\n         </property>\n        </spacer>\n       </item>\n       <item row=\"1\" column=\"0\" colspan=\"2\">\n        <widget class=\"QGroupBox\" name=\"groupBox\">\n         <property name=\"title\">\n          <string>Tabbed browsing</string>\n         </property>\n         <layout class=\"QGridLayout\" name=\"gridLayout_5\">\n          <item row=\"0\" column=\"0\">\n           <widget class=\"QCheckBox\" name=\"newTabsOpenInBackground\">\n            <property name=\"toolTip\">\n             <string>Normally, opening a new tab switches to it immediately.\nWith this on however, new tabs will be opened without\nswitching to them.</string>\n            </property>\n            <property name=\"text\">\n             <string>Open new tabs in background</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"1\" column=\"0\">\n           <widget class=\"QCheckBox\" name=\"newTabsOpenAfterCurrentOne\">\n            <property name=\"toolTip\">\n             <string>With this on, new tabs are opened just after the\ncurrent, active one. Otherwise they are added to\nbe the last ones.</string>\n            </property>\n            <property name=\"text\">\n             <string>Open new tabs after the current one</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"0\" column=\"1\">\n           <widget class=\"QCheckBox\" name=\"hideSingleTab\">\n            <property name=\"toolTip\">\n             <string>Select this option if you don't want to see the main tab bar when only a single tab is opened.</string>\n            </property>\n            <property name=\"text\">\n             <string>Hide single tab</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"1\" column=\"1\">\n           <widget class=\"QCheckBox\" name=\"mruTabOrder\">\n            <property name=\"text\">\n             <string>Ctrl-Tab navigates tabs in MRU order</string>\n            </property>\n           </widget>\n          </item>\n         </layout>\n        </widget>\n       </item>\n       <item row=\"6\" column=\"0\" colspan=\"2\">\n        <layout class=\"QHBoxLayout\" name=\"horizontalLayout_6\">\n         <item>\n          <widget class=\"QLabel\" name=\"label_6\">\n           <property name=\"text\">\n            <string>Interface language:</string>\n           </property>\n          </widget>\n         </item>\n         <item>\n          <widget class=\"QComboBox\" name=\"interfaceLanguage\"/>\n         </item>\n         <item>\n          <spacer name=\"horizontalSpacer_3\">\n           <property name=\"orientation\">\n            <enum>Qt::Horizontal</enum>\n           </property>\n           <property name=\"sizeType\">\n            <enum>QSizePolicy::Fixed</enum>\n           </property>\n           <property name=\"sizeHint\" stdset=\"0\">\n            <size>\n             <width>40</width>\n             <height>20</height>\n            </size>\n           </property>\n          </spacer>\n         </item>\n         <item>\n          <widget class=\"QLabel\" name=\"label_9\">\n           <property name=\"text\">\n            <string>Display style:</string>\n           </property>\n          </widget>\n         </item>\n         <item>\n          <widget class=\"QComboBox\" name=\"displayStyle\"/>\n         </item>\n         <item>\n          <spacer name=\"horizontalSpacer_12\">\n           <property name=\"orientation\">\n            <enum>Qt::Horizontal</enum>\n           </property>\n           <property name=\"sizeHint\" stdset=\"0\">\n            <size>\n             <width>40</width>\n             <height>20</height>\n            </size>\n           </property>\n          </spacer>\n         </item>\n         <item>\n          <widget class=\"QLabel\" name=\"label_16\">\n           <property name=\"text\">\n            <string>Help language</string>\n           </property>\n          </widget>\n         </item>\n         <item>\n          <widget class=\"QComboBox\" name=\"helpLanguage\"/>\n         </item>\n         <item>\n          <spacer name=\"horizontalSpacer_7\">\n           <property name=\"orientation\">\n            <enum>Qt::Horizontal</enum>\n           </property>\n           <property name=\"sizeHint\" stdset=\"0\">\n            <size>\n             <width>40</width>\n             <height>20</height>\n            </size>\n           </property>\n          </spacer>\n         </item>\n        </layout>\n       </item>\n       <item row=\"10\" column=\"0\" colspan=\"2\">\n        <spacer name=\"verticalSpacer\">\n         <property name=\"orientation\">\n          <enum>Qt::Vertical</enum>\n         </property>\n         <property name=\"sizeHint\" stdset=\"0\">\n          <size>\n           <width>20</width>\n           <height>40</height>\n          </size>\n         </property>\n        </spacer>\n       </item>\n       <item row=\"3\" column=\"1\">\n        <layout class=\"QHBoxLayout\" name=\"horizontalLayout_13\">\n         <item>\n          <widget class=\"QLabel\" name=\"maxDictsInContextMenuLabel\">\n           <property name=\"sizePolicy\">\n            <sizepolicy hsizetype=\"Preferred\" vsizetype=\"Fixed\">\n             <horstretch>0</horstretch>\n             <verstretch>0</verstretch>\n            </sizepolicy>\n           </property>\n           <property name=\"toolTip\">\n            <string>Adjust this value to avoid huge context menus.</string>\n           </property>\n           <property name=\"text\">\n            <string>Context menu dictionaries limit:</string>\n           </property>\n          </widget>\n         </item>\n         <item>\n          <widget class=\"QSpinBox\" name=\"maxDictsInContextMenu\">\n           <property name=\"sizePolicy\">\n            <sizepolicy hsizetype=\"Fixed\" vsizetype=\"Fixed\">\n             <horstretch>0</horstretch>\n             <verstretch>0</verstretch>\n            </sizepolicy>\n           </property>\n           <property name=\"maximum\">\n            <number>9999</number>\n           </property>\n           <property name=\"value\">\n            <number>20</number>\n           </property>\n          </widget>\n         </item>\n         <item>\n          <widget class=\"QLabel\" name=\"label_12\">\n           <property name=\"sizePolicy\">\n            <sizepolicy hsizetype=\"Preferred\" vsizetype=\"Fixed\">\n             <horstretch>0</horstretch>\n             <verstretch>0</verstretch>\n            </sizepolicy>\n           </property>\n           <property name=\"text\">\n            <string/>\n           </property>\n          </widget>\n         </item>\n        </layout>\n       </item>\n      </layout>\n     </widget>\n     <widget class=\"QWidget\" name=\"tab_4\">\n      <attribute name=\"icon\">\n       <iconset resource=\"resources.qrc\">\n        <normaloff>:/icons/wizard.png</normaloff>:/icons/wizard.png</iconset>\n      </attribute>\n      <attribute name=\"title\">\n       <string>&amp;Scan Popup</string>\n      </attribute>\n      <layout class=\"QVBoxLayout\" name=\"verticalLayout_10\">\n       <item>\n        <spacer name=\"verticalSpacer_16\">\n         <property name=\"orientation\">\n          <enum>Qt::Vertical</enum>\n         </property>\n         <property name=\"sizeHint\" stdset=\"0\">\n          <size>\n           <width>20</width>\n           <height>40</height>\n          </size>\n         </property>\n        </spacer>\n       </item>\n       <item>\n        <widget class=\"QGroupBox\" name=\"enableScanPopup\">\n         <property name=\"toolTip\">\n          <string>When enabled, a translation popup window would be shown each time\nyou point your mouse on any word on the screen (Windows) or select\nany word with mouse (Linux). When enabled, you can switch it on and\noff from main window or tray icon.</string>\n         </property>\n         <property name=\"title\">\n          <string>Enable scan popup functionality</string>\n         </property>\n         <property name=\"checkable\">\n          <bool>true</bool>\n         </property>\n         <property name=\"checked\">\n          <bool>false</bool>\n         </property>\n         <layout class=\"QVBoxLayout\" name=\"verticalLayout_4\">\n          <item>\n           <widget class=\"QCheckBox\" name=\"startWithScanPopupOn\">\n            <property name=\"toolTip\">\n             <string>Chooses whether the scan popup mode is on by default or not. If checked,\nthe program would always start with the scan popup active.</string>\n            </property>\n            <property name=\"text\">\n             <string>Start with scan popup turned on</string>\n            </property>\n           </widget>\n          </item>\n          <item>\n           <widget class=\"QCheckBox\" name=\"enableScanPopupModifiers\">\n            <property name=\"toolTip\">\n             <string>With this enabled, the popup would only show up if all chosen keys are\nin the pressed state when the word selection changes.</string>\n            </property>\n            <property name=\"text\">\n             <string>Only show popup when all selected keys are kept pressed:</string>\n            </property>\n           </widget>\n          </item>\n          <item>\n           <widget class=\"QFrame\" name=\"scanPopupModifiers\">\n            <property name=\"frameShape\">\n             <enum>QFrame::NoFrame</enum>\n            </property>\n            <property name=\"frameShadow\">\n             <enum>QFrame::Plain</enum>\n            </property>\n            <property name=\"lineWidth\">\n             <number>0</number>\n            </property>\n            <layout class=\"QVBoxLayout\" name=\"verticalLayout_5\">\n             <property name=\"leftMargin\">\n              <number>0</number>\n             </property>\n             <property name=\"topMargin\">\n              <number>0</number>\n             </property>\n             <property name=\"rightMargin\">\n              <number>0</number>\n             </property>\n             <property name=\"bottomMargin\">\n              <number>0</number>\n             </property>\n             <item>\n              <layout class=\"QHBoxLayout\" name=\"horizontalLayout\">\n               <item>\n                <spacer name=\"horizontalSpacer\">\n                 <property name=\"orientation\">\n                  <enum>Qt::Horizontal</enum>\n                 </property>\n                 <property name=\"sizeHint\" stdset=\"0\">\n                  <size>\n                   <width>40</width>\n                   <height>20</height>\n                  </size>\n                 </property>\n                </spacer>\n               </item>\n               <item>\n                <layout class=\"QGridLayout\" name=\"gridLayout\">\n                 <item row=\"1\" column=\"1\">\n                  <widget class=\"QCheckBox\" name=\"leftCtrl\">\n                   <property name=\"toolTip\">\n                    <string>Left Ctrl only</string>\n                   </property>\n                   <property name=\"text\">\n                    <string>Left Ctrl</string>\n                   </property>\n                  </widget>\n                 </item>\n                 <item row=\"2\" column=\"2\">\n                  <widget class=\"QCheckBox\" name=\"rightShift\">\n                   <property name=\"toolTip\">\n                    <string>Right Shift only</string>\n                   </property>\n                   <property name=\"text\">\n                    <string>Right Shift</string>\n                   </property>\n                  </widget>\n                 </item>\n                 <item row=\"0\" column=\"0\">\n                  <widget class=\"QCheckBox\" name=\"altKey\">\n                   <property name=\"toolTip\">\n                    <string>Alt key</string>\n                   </property>\n                   <property name=\"text\">\n                    <string>Alt</string>\n                   </property>\n                  </widget>\n                 </item>\n                 <item row=\"0\" column=\"1\">\n                  <widget class=\"QCheckBox\" name=\"ctrlKey\">\n                   <property name=\"toolTip\">\n                    <string>Ctrl key</string>\n                   </property>\n                   <property name=\"text\">\n                    <string>Ctrl</string>\n                   </property>\n                  </widget>\n                 </item>\n                 <item row=\"1\" column=\"0\">\n                  <widget class=\"QCheckBox\" name=\"leftAlt\">\n                   <property name=\"toolTip\">\n                    <string>Left Alt only</string>\n                   </property>\n                   <property name=\"text\">\n                    <string>Left Alt</string>\n                   </property>\n                  </widget>\n                 </item>\n                 <item row=\"0\" column=\"2\">\n                  <widget class=\"QCheckBox\" name=\"shiftKey\">\n                   <property name=\"toolTip\">\n                    <string>Shift key</string>\n                   </property>\n                   <property name=\"text\">\n                    <string>Shift</string>\n                   </property>\n                  </widget>\n                 </item>\n                 <item row=\"2\" column=\"0\">\n                  <widget class=\"QCheckBox\" name=\"rightAlt\">\n                   <property name=\"toolTip\">\n                    <string>Right Alt only</string>\n                   </property>\n                   <property name=\"text\">\n                    <string>Right Alt</string>\n                   </property>\n                  </widget>\n                 </item>\n                 <item row=\"2\" column=\"1\">\n                  <widget class=\"QCheckBox\" name=\"rightCtrl\">\n                   <property name=\"toolTip\">\n                    <string>Right Ctrl only</string>\n                   </property>\n                   <property name=\"text\">\n                    <string>Right Ctrl</string>\n                   </property>\n                  </widget>\n                 </item>\n                 <item row=\"1\" column=\"2\">\n                  <widget class=\"QCheckBox\" name=\"leftShift\">\n                   <property name=\"toolTip\">\n                    <string>Left Shift only</string>\n                   </property>\n                   <property name=\"text\">\n                    <string>Left Shift</string>\n                   </property>\n                  </widget>\n                 </item>\n                 <item row=\"0\" column=\"3\">\n                  <widget class=\"QCheckBox\" name=\"winKey\">\n                   <property name=\"toolTip\">\n                    <string>Windows key or Meta key</string>\n                   </property>\n                   <property name=\"text\">\n                    <string>Win/Meta</string>\n                   </property>\n                  </widget>\n                 </item>\n                </layout>\n               </item>\n               <item>\n                <widget class=\"QFrame\" name=\"frame\">\n                 <property name=\"frameShape\">\n                  <enum>QFrame::NoFrame</enum>\n                 </property>\n                 <property name=\"frameShadow\">\n                  <enum>QFrame::Raised</enum>\n                 </property>\n                 <property name=\"lineWidth\">\n                  <number>0</number>\n                 </property>\n                 <layout class=\"QVBoxLayout\" name=\"verticalLayout_3\">\n                  <property name=\"leftMargin\">\n                   <number>0</number>\n                  </property>\n                  <property name=\"topMargin\">\n                   <number>0</number>\n                  </property>\n                  <property name=\"rightMargin\">\n                   <number>0</number>\n                  </property>\n                  <property name=\"bottomMargin\">\n                   <number>0</number>\n                  </property>\n                 </layout>\n                </widget>\n               </item>\n              </layout>\n             </item>\n            </layout>\n           </widget>\n          </item>\n          <item>\n           <layout class=\"QHBoxLayout\" name=\"horizontalLayout_5\">\n            <item>\n             <widget class=\"QCheckBox\" name=\"scanPopupAltMode\">\n              <property name=\"toolTip\">\n               <string>Normally, in order to activate a popup you have to\nmaintain the chosen keys pressed while you select\na word. With this enabled, the chosen keys may also\nbe pressed shortly after the selection is done.</string>\n              </property>\n              <property name=\"text\">\n               <string>Keys may also be pressed afterwards, within</string>\n              </property>\n             </widget>\n            </item>\n            <item>\n             <widget class=\"QSpinBox\" name=\"scanPopupAltModeSecs\">\n              <property name=\"toolTip\">\n               <string>To avoid false positives, the keys are only monitored\nafter the selection's done for a limited amount of\nseconds, which is specified here.</string>\n              </property>\n              <property name=\"wrapping\">\n               <bool>false</bool>\n              </property>\n              <property name=\"frame\">\n               <bool>true</bool>\n              </property>\n              <property name=\"alignment\">\n               <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignVCenter</set>\n              </property>\n              <property name=\"minimum\">\n               <number>1</number>\n              </property>\n              <property name=\"maximum\">\n               <number>99</number>\n              </property>\n             </widget>\n            </item>\n            <item>\n             <widget class=\"QLabel\" name=\"label_7\">\n              <property name=\"text\">\n               <string>secs</string>\n              </property>\n             </widget>\n            </item>\n            <item>\n             <spacer name=\"horizontalSpacer_5\">\n              <property name=\"orientation\">\n               <enum>Qt::Horizontal</enum>\n              </property>\n              <property name=\"sizeHint\" stdset=\"0\">\n               <size>\n                <width>40</width>\n                <height>20</height>\n               </size>\n              </property>\n             </spacer>\n            </item>\n           </layout>\n          </item>\n          <item>\n           <widget class=\"QCheckBox\" name=\"showScanFlag\">\n            <property name=\"toolTip\">\n             <string>Show a flag window before showing popup window, click the flag to show popup window. </string>\n            </property>\n            <property name=\"text\">\n             <string>Show scan flag when word is selected</string>\n            </property>\n           </widget>\n          </item>\n          <item>\n           <widget class=\"QCheckBox\" name=\"ignoreOwnClipboardChanges\">\n            <property name=\"toolTip\">\n             <string>Do not show popup when selection or clipboard in one of GoldenDict's own windows changes</string>\n            </property>\n            <property name=\"text\">\n             <string>Ignore GoldenDict's own selection and clipboard changes</string>\n            </property>\n           </widget>\n          </item>\n         </layout>\n        </widget>\n       </item>\n       <item>\n        <widget class=\"QCheckBox\" name=\"scanToMainWindow\">\n         <property name=\"toolTip\">\n          <string>Send translated word to main window instead of to show it in popup window</string>\n         </property>\n         <property name=\"text\">\n          <string>Send translated word to main window</string>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <spacer name=\"verticalSpacer_6\">\n         <property name=\"orientation\">\n          <enum>Qt::Vertical</enum>\n         </property>\n         <property name=\"sizeHint\" stdset=\"0\">\n          <size>\n           <width>20</width>\n           <height>40</height>\n          </size>\n         </property>\n        </spacer>\n       </item>\n      </layout>\n     </widget>\n     <widget class=\"QWidget\" name=\"tab_5\">\n      <attribute name=\"icon\">\n       <iconset resource=\"resources.qrc\">\n        <normaloff>:/icons/hotkeys.png</normaloff>:/icons/hotkeys.png</iconset>\n      </attribute>\n      <attribute name=\"title\">\n       <string>Hotkeys</string>\n      </attribute>\n      <layout class=\"QVBoxLayout\" name=\"verticalLayout_12\">\n       <item>\n        <spacer name=\"verticalSpacer_11\">\n         <property name=\"orientation\">\n          <enum>Qt::Vertical</enum>\n         </property>\n         <property name=\"sizeHint\" stdset=\"0\">\n          <size>\n           <width>20</width>\n           <height>19</height>\n          </size>\n         </property>\n        </spacer>\n       </item>\n       <item>\n        <widget class=\"QCheckBox\" name=\"enableMainWindowHotkey\">\n         <property name=\"text\">\n          <string>Use the following hotkey to show or hide the main window:</string>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <layout class=\"QHBoxLayout\" name=\"horizontalLayout_7\">\n         <item>\n          <spacer name=\"horizontalSpacer_2\">\n           <property name=\"orientation\">\n            <enum>Qt::Horizontal</enum>\n           </property>\n           <property name=\"sizeHint\" stdset=\"0\">\n            <size>\n             <width>40</width>\n             <height>20</height>\n            </size>\n           </property>\n          </spacer>\n         </item>\n         <item>\n          <widget class=\"HotKeyEdit\" name=\"mainWindowHotkey\">\n           <property name=\"enabled\">\n            <bool>false</bool>\n           </property>\n          </widget>\n         </item>\n        </layout>\n       </item>\n       <item>\n        <widget class=\"QCheckBox\" name=\"enableClipboardHotkey\">\n         <property name=\"text\">\n          <string>Use the following hotkey to translate a word from clipboard:</string>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <layout class=\"QHBoxLayout\" name=\"horizontalLayout_8\">\n         <item>\n          <spacer name=\"horizontalSpacer_4\">\n           <property name=\"orientation\">\n            <enum>Qt::Horizontal</enum>\n           </property>\n           <property name=\"sizeHint\" stdset=\"0\">\n            <size>\n             <width>40</width>\n             <height>20</height>\n            </size>\n           </property>\n          </spacer>\n         </item>\n         <item>\n          <widget class=\"HotKeyEdit\" name=\"clipboardHotkey\">\n           <property name=\"enabled\">\n            <bool>false</bool>\n           </property>\n          </widget>\n         </item>\n        </layout>\n       </item>\n       <item>\n        <spacer name=\"verticalSpacer_13\">\n         <property name=\"orientation\">\n          <enum>Qt::Vertical</enum>\n         </property>\n         <property name=\"sizeType\">\n          <enum>QSizePolicy::Fixed</enum>\n         </property>\n         <property name=\"sizeHint\" stdset=\"0\">\n          <size>\n           <width>20</width>\n           <height>16</height>\n          </size>\n         </property>\n        </spacer>\n       </item>\n       <item>\n        <widget class=\"QLabel\" name=\"label_8\">\n         <property name=\"text\">\n          <string>The hotkeys are global and work from any program and within any context as long as GoldenDict is running in background.</string>\n         </property>\n         <property name=\"wordWrap\">\n          <bool>true</bool>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <widget class=\"QLabel\" name=\"brokenXRECORD\">\n         <property name=\"text\">\n          <string>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;\n&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;\np, li { white-space: pre-wrap; }\n&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'DejaVu Sans'; font-size:9pt; font-weight:400; font-style:normal;&quot;&gt;\n&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; color:#ff0000;&quot;&gt;Note: You appear to be running an X.Org XServer release which has the RECORD extension broken. Hotkeys in GoldenDict will probably not work. This must be fixed in the server itself. Please refer to the following &lt;/span&gt;&lt;a href=&quot;https://bugs.freedesktop.org/show_bug.cgi?id=20500&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;bug entry&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot; color:#ff0000;&quot;&gt; and leave a comment there if you like.&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>\n         </property>\n         <property name=\"textFormat\">\n          <enum>Qt::RichText</enum>\n         </property>\n         <property name=\"wordWrap\">\n          <bool>true</bool>\n         </property>\n         <property name=\"openExternalLinks\">\n          <bool>true</bool>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <spacer name=\"verticalSpacer_12\">\n         <property name=\"orientation\">\n          <enum>Qt::Vertical</enum>\n         </property>\n         <property name=\"sizeHint\" stdset=\"0\">\n          <size>\n           <width>20</width>\n           <height>53</height>\n          </size>\n         </property>\n        </spacer>\n       </item>\n      </layout>\n     </widget>\n     <widget class=\"QWidget\" name=\"tab_2\">\n      <attribute name=\"icon\">\n       <iconset resource=\"resources.qrc\">\n        <normaloff>:/icons/playsound_color.png</normaloff>:/icons/playsound_color.png</iconset>\n      </attribute>\n      <attribute name=\"title\">\n       <string>&amp;Audio</string>\n      </attribute>\n      <layout class=\"QVBoxLayout\" name=\"verticalLayout_7\">\n       <item>\n        <spacer name=\"verticalSpacer_4\">\n         <property name=\"orientation\">\n          <enum>Qt::Vertical</enum>\n         </property>\n         <property name=\"sizeHint\" stdset=\"0\">\n          <size>\n           <width>20</width>\n           <height>40</height>\n          </size>\n         </property>\n        </spacer>\n       </item>\n       <item>\n        <widget class=\"QGroupBox\" name=\"groupBox_3\">\n         <property name=\"title\">\n          <string>Pronunciation</string>\n         </property>\n         <layout class=\"QVBoxLayout\" name=\"verticalLayout_15\">\n          <item>\n           <widget class=\"QCheckBox\" name=\"pronounceOnLoadMain\">\n            <property name=\"text\">\n             <string>Auto-pronounce words in main window</string>\n            </property>\n           </widget>\n          </item>\n          <item>\n           <widget class=\"QCheckBox\" name=\"pronounceOnLoadPopup\">\n            <property name=\"text\">\n             <string>Auto-pronounce words in scan popup</string>\n            </property>\n           </widget>\n          </item>\n         </layout>\n        </widget>\n       </item>\n       <item>\n        <widget class=\"QGroupBox\" name=\"groupBox_4\">\n         <property name=\"title\">\n          <string>Playback</string>\n         </property>\n         <layout class=\"QGridLayout\" name=\"gridLayout_audioPlayer\">\n          <item row=\"0\" column=\"0\">\n           <widget class=\"QRadioButton\" name=\"useInternalPlayer\">\n            <property name=\"toolTip\">\n             <string>Play audio files via built-in audio support</string>\n            </property>\n            <property name=\"text\">\n             <string>Use internal player:</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"0\" column=\"1\">\n           <widget class=\"QComboBox\" name=\"internalPlayerBackend\">\n            <property name=\"toolTip\">\n             <string>Choose audio back end</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"1\" column=\"0\">\n           <widget class=\"QRadioButton\" name=\"useExternalPlayer\">\n            <property name=\"toolTip\">\n             <string>Use any external program to play audio files</string>\n            </property>\n            <property name=\"text\">\n             <string>Use external program:</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"1\" column=\"1\">\n           <widget class=\"QLineEdit\" name=\"audioPlaybackProgram\">\n            <property name=\"enabled\">\n             <bool>false</bool>\n            </property>\n            <property name=\"toolTip\">\n             <string>Enter audio player command line</string>\n            </property>\n           </widget>\n          </item>\n         </layout>\n        </widget>\n       </item>\n       <item>\n        <spacer name=\"verticalSpacer_2\">\n         <property name=\"orientation\">\n          <enum>Qt::Vertical</enum>\n         </property>\n         <property name=\"sizeHint\" stdset=\"0\">\n          <size>\n           <width>20</width>\n           <height>46</height>\n          </size>\n         </property>\n        </spacer>\n       </item>\n      </layout>\n     </widget>\n     <widget class=\"QWidget\" name=\"tab_3\">\n      <attribute name=\"icon\">\n       <iconset resource=\"resources.qrc\">\n        <normaloff>:/icons/network.png</normaloff>:/icons/network.png</iconset>\n      </attribute>\n      <attribute name=\"title\">\n       <string>&amp;Network</string>\n      </attribute>\n      <layout class=\"QVBoxLayout\" name=\"verticalLayout_9\">\n       <item>\n        <spacer name=\"verticalSpacer_5\">\n         <property name=\"orientation\">\n          <enum>Qt::Vertical</enum>\n         </property>\n         <property name=\"sizeHint\" stdset=\"0\">\n          <size>\n           <width>20</width>\n           <height>40</height>\n          </size>\n         </property>\n        </spacer>\n       </item>\n       <item>\n        <widget class=\"QGroupBox\" name=\"useProxyServer\">\n         <property name=\"toolTip\">\n          <string>Enable if you wish to use a proxy server\nfor all program's network requests.</string>\n         </property>\n         <property name=\"title\">\n          <string>Use proxy server</string>\n         </property>\n         <property name=\"checkable\">\n          <bool>true</bool>\n         </property>\n         <property name=\"checked\">\n          <bool>false</bool>\n         </property>\n         <layout class=\"QVBoxLayout\" name=\"verticalLayout_6\">\n          <item>\n           <widget class=\"QRadioButton\" name=\"systemProxy\">\n            <property name=\"text\">\n             <string>System proxy</string>\n            </property>\n           </widget>\n          </item>\n          <item>\n           <widget class=\"QRadioButton\" name=\"customProxy\">\n            <property name=\"text\">\n             <string>Custom proxy</string>\n            </property>\n           </widget>\n          </item>\n          <item>\n           <widget class=\"QGroupBox\" name=\"customSettingsGroup\">\n            <property name=\"title\">\n             <string>Custom settings</string>\n            </property>\n            <layout class=\"QVBoxLayout\" name=\"verticalLayout_18\">\n             <item>\n              <layout class=\"QHBoxLayout\" name=\"horizontalLayout_3\">\n               <item>\n                <widget class=\"QLabel\" name=\"label\">\n                 <property name=\"text\">\n                  <string>Type:</string>\n                 </property>\n                </widget>\n               </item>\n               <item>\n                <widget class=\"QComboBox\" name=\"proxyType\"/>\n               </item>\n               <item>\n                <widget class=\"QLabel\" name=\"label_3\">\n                 <property name=\"text\">\n                  <string>Host:</string>\n                 </property>\n                </widget>\n               </item>\n               <item>\n                <widget class=\"QLineEdit\" name=\"proxyHost\"/>\n               </item>\n               <item>\n                <widget class=\"QLabel\" name=\"label_2\">\n                 <property name=\"text\">\n                  <string>Port:</string>\n                 </property>\n                </widget>\n               </item>\n               <item>\n                <widget class=\"QSpinBox\" name=\"proxyPort\">\n                 <property name=\"maximum\">\n                  <number>65535</number>\n                 </property>\n                 <property name=\"value\">\n                  <number>8080</number>\n                 </property>\n                </widget>\n               </item>\n              </layout>\n             </item>\n             <item>\n              <layout class=\"QHBoxLayout\" name=\"horizontalLayout_2\">\n               <item>\n                <widget class=\"QLabel\" name=\"label_4\">\n                 <property name=\"text\">\n                  <string>User:</string>\n                 </property>\n                </widget>\n               </item>\n               <item>\n                <widget class=\"QLineEdit\" name=\"proxyUser\"/>\n               </item>\n               <item>\n                <widget class=\"QLabel\" name=\"label_5\">\n                 <property name=\"text\">\n                  <string>Password:</string>\n                 </property>\n                </widget>\n               </item>\n               <item>\n                <widget class=\"QLineEdit\" name=\"proxyPassword\">\n                 <property name=\"echoMode\">\n                  <enum>QLineEdit::Password</enum>\n                 </property>\n                </widget>\n               </item>\n              </layout>\n             </item>\n            </layout>\n           </widget>\n          </item>\n         </layout>\n        </widget>\n       </item>\n       <item>\n        <spacer name=\"verticalSpacer_14\">\n         <property name=\"orientation\">\n          <enum>Qt::Vertical</enum>\n         </property>\n         <property name=\"sizeType\">\n          <enum>QSizePolicy::Fixed</enum>\n         </property>\n         <property name=\"sizeHint\" stdset=\"0\">\n          <size>\n           <width>20</width>\n           <height>10</height>\n          </size>\n         </property>\n        </spacer>\n       </item>\n       <item>\n        <widget class=\"QCheckBox\" name=\"disallowContentFromOtherSites\">\n         <property name=\"toolTip\">\n          <string>Enabling this would make GoldenDict block most advertisements\nby disallowing content (images, frames) not originating from the site\nyou are browsing. If some site breaks because of this, try disabling this.</string>\n         </property>\n         <property name=\"text\">\n          <string>Disallow loading content from other sites (hides most advertisements)</string>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <widget class=\"QCheckBox\" name=\"enableWebPlugins\">\n         <property name=\"toolTip\">\n          <string>Enabling this would allow to listen to sound pronunciations from\nonline dictionaries that rely on Flash or other web plugins.\nPlugin must be installed for this option to work.</string>\n         </property>\n         <property name=\"text\">\n          <string>Enable web plugins</string>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <widget class=\"QCheckBox\" name=\"hideGoldenDictHeader\">\n         <property name=\"toolTip\">\n          <string>Some sites detect GoldenDict via HTTP headers and block the requests.\nEnable this option to workaround the problem.</string>\n         </property>\n         <property name=\"text\">\n          <string>Do not identify GoldenDict in HTTP headers</string>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <layout class=\"QHBoxLayout\" name=\"horizontalLayout_11\">\n         <item>\n          <widget class=\"QLabel\" name=\"label_20\">\n           <property name=\"text\">\n            <string>Maximum network cache size:</string>\n           </property>\n          </widget>\n         </item>\n         <item>\n          <widget class=\"QSpinBox\" name=\"maxNetworkCacheSize\">\n           <property name=\"toolTip\">\n            <string>Maximum disk space occupied by GoldenDict's network cache in\n%1\nIf set to 0 the network disk cache will be disabled.</string>\n           </property>\n           <property name=\"suffix\">\n            <string> MiB</string>\n           </property>\n           <property name=\"maximum\">\n            <number>2000</number>\n           </property>\n           <property name=\"value\">\n            <number>50</number>\n           </property>\n          </widget>\n         </item>\n         <item>\n          <widget class=\"QCheckBox\" name=\"clearNetworkCacheOnExit\">\n           <property name=\"toolTip\">\n            <string>When this option is enabled, GoldenDict\nclears its network cache from disk during exit.</string>\n           </property>\n           <property name=\"text\">\n            <string>Clear network cache on exit</string>\n           </property>\n          </widget>\n         </item>\n         <item>\n          <spacer name=\"horizontalSpacer_15\">\n           <property name=\"orientation\">\n            <enum>Qt::Horizontal</enum>\n           </property>\n           <property name=\"sizeHint\" stdset=\"0\">\n            <size>\n             <width>40</width>\n             <height>20</height>\n            </size>\n           </property>\n          </spacer>\n         </item>\n        </layout>\n       </item>\n       <item>\n        <spacer name=\"verticalSpacer_10\">\n         <property name=\"orientation\">\n          <enum>Qt::Vertical</enum>\n         </property>\n         <property name=\"sizeType\">\n          <enum>QSizePolicy::Fixed</enum>\n         </property>\n         <property name=\"sizeHint\" stdset=\"0\">\n          <size>\n           <width>20</width>\n           <height>10</height>\n          </size>\n         </property>\n        </spacer>\n       </item>\n       <item>\n        <widget class=\"QCheckBox\" name=\"checkForNewReleases\">\n         <property name=\"toolTip\">\n          <string>When this is enabled, the program periodically\nchecks if a new, updated version of GoldenDict\nis available for download. If it is so, the program\ninforms the user about it and prompts to open a\ndownload page.</string>\n         </property>\n         <property name=\"text\">\n          <string>Check for new program releases periodically</string>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <spacer name=\"verticalSpacer_3\">\n         <property name=\"orientation\">\n          <enum>Qt::Vertical</enum>\n         </property>\n         <property name=\"sizeHint\" stdset=\"0\">\n          <size>\n           <width>20</width>\n           <height>39</height>\n          </size>\n         </property>\n        </spacer>\n       </item>\n      </layout>\n     </widget>\n     <widget class=\"QWidget\" name=\"tab_FTS\">\n      <attribute name=\"icon\">\n       <iconset resource=\"resources.qrc\">\n        <normaloff>:/icons/system-search.png</normaloff>:/icons/system-search.png</iconset>\n      </attribute>\n      <attribute name=\"title\">\n       <string>Full-text search</string>\n      </attribute>\n      <layout class=\"QVBoxLayout\" name=\"verticalLayout_19\">\n       <item>\n        <spacer name=\"verticalSpacer_9\">\n         <property name=\"orientation\">\n          <enum>Qt::Vertical</enum>\n         </property>\n         <property name=\"sizeHint\" stdset=\"0\">\n          <size>\n           <width>20</width>\n           <height>40</height>\n          </size>\n         </property>\n        </spacer>\n       </item>\n       <item>\n        <widget class=\"QGroupBox\" name=\"ftsGroupBox\">\n         <property name=\"title\">\n          <string>Allow full-text search for:</string>\n         </property>\n         <property name=\"checkable\">\n          <bool>true</bool>\n         </property>\n         <property name=\"checked\">\n          <bool>true</bool>\n         </property>\n         <layout class=\"QGridLayout\" name=\"gridLayout_4\">\n          <item row=\"0\" column=\"0\">\n           <widget class=\"QCheckBox\" name=\"allowAard\">\n            <property name=\"text\">\n             <string notr=\"true\">Aard</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"1\" column=\"0\">\n           <widget class=\"QCheckBox\" name=\"allowBGL\">\n            <property name=\"text\">\n             <string notr=\"true\">BGL</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"2\" column=\"0\">\n           <widget class=\"QCheckBox\" name=\"allowDictD\">\n            <property name=\"text\">\n             <string notr=\"true\">DictD</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"3\" column=\"0\">\n           <widget class=\"QCheckBox\" name=\"allowDSL\">\n            <property name=\"text\">\n             <string notr=\"true\">DSL</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"4\" column=\"0\">\n           <widget class=\"QCheckBox\" name=\"allowMDict\">\n            <property name=\"text\">\n             <string notr=\"true\">MDict</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"5\" column=\"0\">\n           <widget class=\"QCheckBox\" name=\"allowSDict\">\n            <property name=\"text\">\n             <string notr=\"true\">SDict</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"0\" column=\"1\">\n           <widget class=\"QCheckBox\" name=\"allowSlob\">\n            <property name=\"text\">\n             <string notr=\"true\">Slob</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"1\" column=\"1\">\n           <widget class=\"QCheckBox\" name=\"allowStardict\">\n            <property name=\"text\">\n             <string notr=\"true\">Stardict</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"2\" column=\"1\">\n           <widget class=\"QCheckBox\" name=\"allowXDXF\">\n            <property name=\"text\">\n             <string notr=\"true\">XDXF</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"3\" column=\"1\">\n           <widget class=\"QCheckBox\" name=\"allowZim\">\n            <property name=\"text\">\n             <string notr=\"true\">Zim</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"4\" column=\"1\">\n           <widget class=\"QCheckBox\" name=\"allowEpwing\">\n            <property name=\"text\">\n             <string notr=\"true\">Epwing</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"5\" column=\"1\">\n           <widget class=\"QCheckBox\" name=\"allowGls\">\n            <property name=\"text\">\n             <string notr=\"true\">GLS</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"6\" column=\"0\" colspan=\"2\">\n           <layout class=\"QHBoxLayout\" name=\"horizontalLayout_14\">\n            <item>\n             <widget class=\"QLabel\" name=\"label_14\">\n              <property name=\"text\">\n               <string>Don't search in dictionaries containing more than</string>\n              </property>\n             </widget>\n            </item>\n            <item>\n             <widget class=\"QSpinBox\" name=\"maxDictionarySize\">\n              <property name=\"maximum\">\n               <number>10000000</number>\n              </property>\n              <property name=\"singleStep\">\n               <number>10000</number>\n              </property>\n             </widget>\n            </item>\n            <item>\n             <widget class=\"QLabel\" name=\"label_15\">\n              <property name=\"text\">\n               <string>articles (0 - unlimited)</string>\n              </property>\n             </widget>\n            </item>\n            <item>\n             <spacer name=\"horizontalSpacer_10\">\n              <property name=\"orientation\">\n               <enum>Qt::Horizontal</enum>\n              </property>\n              <property name=\"sizeHint\" stdset=\"0\">\n               <size>\n                <width>40</width>\n                <height>20</height>\n               </size>\n              </property>\n             </spacer>\n            </item>\n           </layout>\n          </item>\n         </layout>\n        </widget>\n       </item>\n       <item>\n        <spacer name=\"verticalSpacer_7\">\n         <property name=\"orientation\">\n          <enum>Qt::Vertical</enum>\n         </property>\n         <property name=\"sizeHint\" stdset=\"0\">\n          <size>\n           <width>20</width>\n           <height>40</height>\n          </size>\n         </property>\n        </spacer>\n       </item>\n      </layout>\n     </widget>\n     <widget class=\"QWidget\" name=\"tab_Advanced\">\n      <attribute name=\"title\">\n       <string>Ad&amp;vanced</string>\n      </attribute>\n      <layout class=\"QVBoxLayout\" name=\"verticalLayout_11\">\n       <item>\n        <layout class=\"QHBoxLayout\" name=\"horizontalLayout_17\">\n         <item>\n          <widget class=\"QGroupBox\" name=\"groupBox_ScanPopupTechnologies\">\n           <property name=\"title\">\n            <string>ScanPopup extra technologies</string>\n           </property>\n           <layout class=\"QVBoxLayout\" name=\"verticalLayout_13\">\n            <item>\n             <widget class=\"QCheckBox\" name=\"scanPopupUseIAccessibleEx\">\n              <property name=\"toolTip\">\n               <string>Try to use IAccessibleEx technology to retrieve word under cursor.\nThis technology works only with some programs that support it\n (for example Internet Explorer 9).\nIt is not needed to select this option if you don't use such programs.</string>\n              </property>\n              <property name=\"text\">\n               <string>Use &amp;IAccessibleEx</string>\n              </property>\n             </widget>\n            </item>\n            <item>\n             <widget class=\"QCheckBox\" name=\"scanPopupUseUIAutomation\">\n              <property name=\"toolTip\">\n               <string>Try to use UI Automation technology to retrieve word under cursor.\nThis technology works only with some programs that support it.\nIt is not needed to select this option if you don't use such programs.</string>\n              </property>\n              <property name=\"text\">\n               <string>Use &amp;UIAutomation</string>\n              </property>\n             </widget>\n            </item>\n            <item>\n             <widget class=\"QCheckBox\" name=\"scanPopupUseGDMessage\">\n              <property name=\"toolTip\">\n               <string>Try to use special GoldenDict message to retrieve word under cursor.\nThis technology works only with some programs that support it.\nIt is not needed to select this option if you don't use such programs.</string>\n              </property>\n              <property name=\"text\">\n               <string>Use &amp;GoldenDict message</string>\n              </property>\n             </widget>\n            </item>\n           </layout>\n          </widget>\n         </item>\n         <item>\n          <widget class=\"QGroupBox\" name=\"groupBox_ScanPopupWindowFlags\">\n           <property name=\"title\">\n            <string>ScanPopup unpinned window flags</string>\n           </property>\n           <layout class=\"QVBoxLayout\" name=\"verticalLayout_22\">\n            <item>\n             <widget class=\"QComboBox\" name=\"scanPopupUnpinnedWindowFlags\">\n              <property name=\"toolTip\">\n               <string>Experiment with non-default flags if the unpinned scan popup window misbehaves</string>\n              </property>\n              <item>\n               <property name=\"text\">\n                <string>&lt;default&gt;</string>\n               </property>\n              </item>\n              <item>\n               <property name=\"text\">\n                <string>Popup</string>\n               </property>\n              </item>\n              <item>\n               <property name=\"text\">\n                <string>Tool</string>\n               </property>\n              </item>\n             </widget>\n            </item>\n            <item>\n             <widget class=\"QCheckBox\" name=\"scanPopupUnpinnedBypassWMHint\">\n              <property name=\"enabled\">\n               <bool>false</bool>\n              </property>\n              <property name=\"toolTip\">\n               <string>This hint can be combined with non-default window flags</string>\n              </property>\n              <property name=\"text\">\n               <string>Bypass window manager hint</string>\n              </property>\n             </widget>\n            </item>\n            <item>\n             <spacer name=\"verticalSpacer_18\">\n              <property name=\"orientation\">\n               <enum>Qt::Vertical</enum>\n              </property>\n              <property name=\"sizeHint\" stdset=\"0\">\n               <size>\n                <width>20</width>\n                <height>40</height>\n               </size>\n              </property>\n             </spacer>\n            </item>\n           </layout>\n          </widget>\n         </item>\n         <item>\n          <spacer name=\"horizontalSpacer_13\">\n           <property name=\"orientation\">\n            <enum>Qt::Horizontal</enum>\n           </property>\n           <property name=\"sizeHint\" stdset=\"0\">\n            <size>\n             <width>40</width>\n             <height>20</height>\n            </size>\n           </property>\n          </spacer>\n         </item>\n        </layout>\n       </item>\n       <item>\n        <layout class=\"QHBoxLayout\" name=\"horizontalLayout_15\">\n         <item>\n          <widget class=\"QGroupBox\" name=\"historyBox\">\n           <property name=\"title\">\n            <string>History</string>\n           </property>\n           <layout class=\"QVBoxLayout\" name=\"verticalLayout_14\">\n            <item>\n             <widget class=\"QCheckBox\" name=\"storeHistory\">\n              <property name=\"toolTip\">\n               <string>Turn this option on to store history of the translated words</string>\n              </property>\n              <property name=\"text\">\n               <string>Store &amp;history</string>\n              </property>\n              <property name=\"checked\">\n               <bool>true</bool>\n              </property>\n             </widget>\n            </item>\n            <item>\n             <layout class=\"QHBoxLayout\" name=\"horizontalLayout_9\">\n              <property name=\"topMargin\">\n               <number>0</number>\n              </property>\n              <item>\n               <widget class=\"QLabel\" name=\"historySizeLabel\">\n                <property name=\"toolTip\">\n                 <string>Specify the maximum number of entries to keep in history.</string>\n                </property>\n                <property name=\"text\">\n                 <string>Maximum history size:</string>\n                </property>\n               </widget>\n              </item>\n              <item>\n               <widget class=\"QSpinBox\" name=\"historyMaxSizeField\">\n                <property name=\"accelerated\">\n                 <bool>true</bool>\n                </property>\n                <property name=\"maximum\">\n                 <number>99999</number>\n                </property>\n                <property name=\"value\">\n                 <number>500</number>\n                </property>\n               </widget>\n              </item>\n              <item>\n               <spacer name=\"horizontalSpacer_8\">\n                <property name=\"orientation\">\n                 <enum>Qt::Horizontal</enum>\n                </property>\n                <property name=\"sizeHint\" stdset=\"0\">\n                 <size>\n                  <width>40</width>\n                  <height>20</height>\n                 </size>\n                </property>\n               </spacer>\n              </item>\n             </layout>\n            </item>\n            <item>\n             <layout class=\"QHBoxLayout\" name=\"horizontalLayout_10\">\n              <item>\n               <widget class=\"QLabel\" name=\"label_10\">\n                <property name=\"toolTip\">\n                 <string>History saving interval. If set to 0 history will be saved only during exit.</string>\n                </property>\n                <property name=\"statusTip\">\n                 <string/>\n                </property>\n                <property name=\"text\">\n                 <string>Save every</string>\n                </property>\n               </widget>\n              </item>\n              <item>\n               <widget class=\"QSpinBox\" name=\"historySaveIntervalField\">\n                <property name=\"statusTip\">\n                 <string/>\n                </property>\n                <property name=\"maximum\">\n                 <number>120</number>\n                </property>\n               </widget>\n              </item>\n              <item>\n               <widget class=\"QLabel\" name=\"label_11\">\n                <property name=\"text\">\n                 <string>minutes</string>\n                </property>\n               </widget>\n              </item>\n              <item>\n               <spacer name=\"horizontalSpacer_9\">\n                <property name=\"orientation\">\n                 <enum>Qt::Horizontal</enum>\n                </property>\n                <property name=\"sizeHint\" stdset=\"0\">\n                 <size>\n                  <width>40</width>\n                  <height>20</height>\n                 </size>\n                </property>\n               </spacer>\n              </item>\n             </layout>\n            </item>\n           </layout>\n          </widget>\n         </item>\n         <item>\n          <widget class=\"QGroupBox\" name=\"favoritesBox\">\n           <property name=\"title\">\n            <string>Favorites</string>\n           </property>\n           <layout class=\"QVBoxLayout\" name=\"verticalLayout_21\">\n            <item>\n             <layout class=\"QHBoxLayout\" name=\"horizontalLayout_16\">\n              <item>\n               <widget class=\"QLabel\" name=\"label_17\">\n                <property name=\"toolTip\">\n                 <string>Favorites saving interval. If set to 0 Favorites will be saved only during exit.</string>\n                </property>\n                <property name=\"text\">\n                 <string>Save every</string>\n                </property>\n               </widget>\n              </item>\n              <item>\n               <widget class=\"QSpinBox\" name=\"favoritesSaveIntervalField\">\n                <property name=\"maximum\">\n                 <number>120</number>\n                </property>\n               </widget>\n              </item>\n              <item>\n               <widget class=\"QLabel\" name=\"label_18\">\n                <property name=\"text\">\n                 <string>minutes</string>\n                </property>\n               </widget>\n              </item>\n             </layout>\n            </item>\n            <item>\n             <widget class=\"QCheckBox\" name=\"confirmFavoritesDeletion\">\n              <property name=\"toolTip\">\n               <string>Turn this option on to confirm every operation of items deletion</string>\n              </property>\n              <property name=\"text\">\n               <string>Confirmation for items deletion</string>\n              </property>\n             </widget>\n            </item>\n            <item>\n             <spacer name=\"verticalSpacer_15\">\n              <property name=\"orientation\">\n               <enum>Qt::Vertical</enum>\n              </property>\n              <property name=\"sizeHint\" stdset=\"0\">\n               <size>\n                <width>20</width>\n                <height>40</height>\n               </size>\n              </property>\n             </spacer>\n            </item>\n           </layout>\n          </widget>\n         </item>\n        </layout>\n       </item>\n       <item>\n        <widget class=\"QGroupBox\" name=\"groupBox_6\">\n         <property name=\"title\">\n          <string>Articles</string>\n         </property>\n         <layout class=\"QGridLayout\" name=\"gridLayout_3\">\n          <item row=\"0\" column=\"0\">\n           <widget class=\"QCheckBox\" name=\"collapseBigArticles\">\n            <property name=\"toolTip\">\n             <string>Select this option to automatic collapse big articles</string>\n            </property>\n            <property name=\"text\">\n             <string>Collapse articles more than</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"0\" column=\"1\">\n           <widget class=\"QSpinBox\" name=\"articleSizeLimit\">\n            <property name=\"toolTip\">\n             <string>Articles longer than this size will be collapsed</string>\n            </property>\n            <property name=\"maximum\">\n             <number>100000</number>\n            </property>\n            <property name=\"singleStep\">\n             <number>50</number>\n            </property>\n            <property name=\"value\">\n             <number>2000</number>\n            </property>\n           </widget>\n          </item>\n          <item row=\"0\" column=\"2\">\n           <widget class=\"QLabel\" name=\"label_13\">\n            <property name=\"text\">\n             <string>symbols</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"0\" column=\"3\">\n           <spacer name=\"horizontalSpacer_11\">\n            <property name=\"orientation\">\n             <enum>Qt::Horizontal</enum>\n            </property>\n            <property name=\"sizeHint\" stdset=\"0\">\n             <size>\n              <width>40</width>\n              <height>20</height>\n             </size>\n            </property>\n           </spacer>\n          </item>\n          <item row=\"1\" column=\"0\">\n           <widget class=\"QCheckBox\" name=\"limitInputPhraseLength\">\n            <property name=\"toolTip\">\n             <string>Turn this option on to ignore unreasonably long input text\nfrom mouse-over, selection, clipboard or command line</string>\n            </property>\n            <property name=\"text\">\n             <string>Ignore input phrases longer than</string>\n            </property>\n            <property name=\"checked\">\n             <bool>false</bool>\n            </property>\n           </widget>\n          </item>\n          <item row=\"1\" column=\"1\">\n           <widget class=\"QSpinBox\" name=\"inputPhraseLengthLimit\">\n            <property name=\"toolTip\">\n             <string>Input phrases longer than this size will be ignored</string>\n            </property>\n            <property name=\"maximum\">\n             <number>9999999</number>\n            </property>\n            <property name=\"singleStep\">\n             <number>10</number>\n            </property>\n            <property name=\"value\">\n             <number>1000</number>\n            </property>\n           </widget>\n          </item>\n          <item row=\"1\" column=\"2\">\n           <widget class=\"QLabel\" name=\"label_19\">\n            <property name=\"text\">\n             <string>symbols</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"1\" column=\"4\">\n           <widget class=\"QCheckBox\" name=\"ignoreDiacritics\">\n            <property name=\"toolTip\">\n             <string>Turn this option on to ignore diacritics while searching articles</string>\n            </property>\n            <property name=\"text\">\n             <string>Ignore diacritics while searching</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"0\" column=\"4\">\n           <widget class=\"QCheckBox\" name=\"alwaysExpandOptionalParts\">\n            <property name=\"toolTip\">\n             <string>Turn this option on to always expand optional parts of articles</string>\n            </property>\n            <property name=\"text\">\n             <string>Expand optional &amp;parts</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"1\" column=\"3\">\n           <spacer name=\"horizontalSpacer_14\">\n            <property name=\"orientation\">\n             <enum>Qt::Horizontal</enum>\n            </property>\n            <property name=\"sizeHint\" stdset=\"0\">\n             <size>\n              <width>40</width>\n              <height>20</height>\n             </size>\n            </property>\n           </spacer>\n          </item>\n         </layout>\n        </widget>\n       </item>\n       <item>\n        <widget class=\"QCheckBox\" name=\"synonymSearchEnabled\">\n         <property name=\"toolTip\">\n          <string>Turn this option on to enable extra articles search via synonym lists\nfrom Stardict, Babylon and GLS dictionaries</string>\n         </property>\n         <property name=\"text\">\n          <string>Extra search via synonyms</string>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <spacer name=\"verticalSpacer_17\">\n         <property name=\"orientation\">\n          <enum>Qt::Vertical</enum>\n         </property>\n         <property name=\"sizeHint\" stdset=\"0\">\n          <size>\n           <width>20</width>\n           <height>40</height>\n          </size>\n         </property>\n        </spacer>\n       </item>\n      </layout>\n     </widget>\n    </widget>\n   </item>\n   <item>\n    <widget class=\"QDialogButtonBox\" name=\"buttonBox\">\n     <property name=\"orientation\">\n      <enum>Qt::Horizontal</enum>\n     </property>\n     <property name=\"standardButtons\">\n      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Help|QDialogButtonBox::Ok</set>\n     </property>\n    </widget>\n   </item>\n  </layout>\n </widget>\n <customwidgets>\n  <customwidget>\n   <class>HotKeyEdit</class>\n   <extends>QLineEdit</extends>\n   <header>hotkeyedit.hh</header>\n  </customwidget>\n  <customwidget>\n   <class>StylesComboBox</class>\n   <extends>QComboBox</extends>\n   <header>stylescombobox.hh</header>\n  </customwidget>\n </customwidgets>\n <tabstops>\n  <tabstop>tabWidget</tabstop>\n  <tabstop>buttonBox</tabstop>\n  <tabstop>newTabsOpenInBackground</tabstop>\n  <tabstop>newTabsOpenAfterCurrentOne</tabstop>\n  <tabstop>enableTrayIcon</tabstop>\n  <tabstop>startToTray</tabstop>\n  <tabstop>closeToTray</tabstop>\n  <tabstop>cbAutostart</tabstop>\n  <tabstop>interfaceLanguage</tabstop>\n  <tabstop>startWithScanPopupOn</tabstop>\n  <tabstop>enableScanPopupModifiers</tabstop>\n  <tabstop>leftCtrl</tabstop>\n  <tabstop>rightShift</tabstop>\n  <tabstop>altKey</tabstop>\n  <tabstop>ctrlKey</tabstop>\n  <tabstop>leftAlt</tabstop>\n  <tabstop>shiftKey</tabstop>\n  <tabstop>rightAlt</tabstop>\n  <tabstop>rightCtrl</tabstop>\n  <tabstop>leftShift</tabstop>\n  <tabstop>winKey</tabstop>\n  <tabstop>scanPopupAltMode</tabstop>\n  <tabstop>scanPopupAltModeSecs</tabstop>\n  <tabstop>useProxyServer</tabstop>\n  <tabstop>proxyType</tabstop>\n  <tabstop>proxyHost</tabstop>\n  <tabstop>proxyPort</tabstop>\n  <tabstop>proxyUser</tabstop>\n  <tabstop>proxyPassword</tabstop>\n </tabstops>\n <resources>\n  <include location=\"resources.qrc\"/>\n </resources>\n <connections>\n  <connection>\n   <sender>buttonBox</sender>\n   <signal>accepted()</signal>\n   <receiver>Preferences</receiver>\n   <slot>accept()</slot>\n   <hints>\n    <hint type=\"sourcelabel\">\n     <x>248</x>\n     <y>254</y>\n    </hint>\n    <hint type=\"destinationlabel\">\n     <x>157</x>\n     <y>274</y>\n    </hint>\n   </hints>\n  </connection>\n  <connection>\n   <sender>buttonBox</sender>\n   <signal>rejected()</signal>\n   <receiver>Preferences</receiver>\n   <slot>reject()</slot>\n   <hints>\n    <hint type=\"sourcelabel\">\n     <x>316</x>\n     <y>260</y>\n    </hint>\n    <hint type=\"destinationlabel\">\n     <x>286</x>\n     <y>274</y>\n    </hint>\n   </hints>\n  </connection>\n </connections>\n</ui>\n"
        },
        {
          "name": "processwrapper.cc",
          "type": "blob",
          "size": 3.5009765625,
          "content": "#include \"processwrapper.hh\"\r\n\r\n#include <QtCore>\r\n\r\n#ifdef Q_OS_WIN32\r\n\r\n#include <windows.h>\r\n#include <stdio.h>\r\n#include <psapi.h>\r\n\r\nunsigned int ProcessWrapper::currentProcessId()\r\n{\r\n\treturn GetCurrentProcessId();\r\n}\r\n\r\nbool ProcessWrapper::processExists(unsigned int pid)\r\n{\r\n    DWORD aProcesses[1024], cbNeeded, cProcesses;\r\n    unsigned int i;\r\n\r\n    if ( !EnumProcesses( aProcesses, sizeof(aProcesses), &cbNeeded ) )\r\n        return false;\r\n\r\n    cProcesses = cbNeeded / sizeof(DWORD);\r\n    for ( i = 0; i < cProcesses; i++ )\r\n    {\r\n      unsigned int processID = aProcesses[i];\r\n      if ( processID == pid )\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nunsigned int ProcessWrapper::findProcess(const char *name, unsigned int pid_skip)\r\n{\r\n    DWORD aProcesses[1024], cbNeeded, cProcesses;\r\n    unsigned int i;\r\n    QString pname(name); pname += \".exe\";\r\n\r\n    if ( !EnumProcesses( aProcesses, sizeof(aProcesses), &cbNeeded ) )\r\n        return 0;\r\n\r\n    // Calculate how many process identifiers were returned.\r\n\r\n    cProcesses = cbNeeded / sizeof(DWORD);\r\n\r\n    // Print the name and process identifier for each process.\r\n\r\n    for ( i = 0; i < cProcesses; i++ )\r\n    {\r\n        unsigned int processID = aProcesses[i];\r\n        if( processID != 0 && processID != pid_skip )\r\n        {\r\n            char szProcessName[MAX_PATH] = \"<unknown>\";\r\n\r\n            // Get a handle to the process.\r\n\r\n            HANDLE hProcess = OpenProcess( PROCESS_QUERY_INFORMATION |\r\n                                           PROCESS_VM_READ,\r\n                                           FALSE, processID );\r\n\r\n            // Get the process name.\r\n\r\n            if (NULL != hProcess )\r\n            {\r\n                HMODULE hMod;\r\n                DWORD cbNeeded;\r\n\r\n                if ( EnumProcessModules( hProcess, &hMod, sizeof(hMod),\r\n                     &cbNeeded) )\r\n                {\r\n                    GetModuleBaseNameA( hProcess, hMod, szProcessName,\r\n                                       sizeof(szProcessName)/sizeof(TCHAR) );\r\n\r\n\t\t\t\t\tif (QString(szProcessName) == pname) {\r\n\t                    CloseHandle( hProcess );\r\n                        return processID;\r\n\t\t\t\t\t}\r\n                }\r\n\r\n\t\t\t\tCloseHandle( hProcess );\r\n            }\r\n\r\n            // Print the process name and identifier.\r\n\r\n            //_tprintf( TEXT(\"%s  (PID: %u)\\n\"), szProcessName, processID );\r\n\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n#else\r\n\r\n#include <unistd.h>\r\n\r\nunsigned int ProcessWrapper::currentProcessId()\r\n{\r\n    return getpid();\r\n}\r\n\r\nbool ProcessWrapper::processExists(unsigned int pid)\r\n{\r\n  return QFile::exists(QString(\"/proc/%1\").arg(pid));\r\n}\r\n\r\nunsigned int ProcessWrapper::findProcess(const char *name, unsigned int pid_skip)\r\n{\r\n    QString pname(\"(\" + QString(name) + \")\");\r\n    QDir pd(\"/proc\");\r\n    QFileInfoList list = pd.entryInfoList(QDir::Dirs | QDir::NoSymLinks | QDir::NoDotAndDotDot);\r\n    QFileInfoList::iterator it, it_end = list.end();\r\n    for (it = list.begin(); it != it_end; ++it)\r\n    {\r\n        const QFileInfo &fi = *it;\r\n        if (fi.baseName().at(0).isDigit()) {\r\n            QFile f(fi.absoluteFilePath()+\"/stat\");\r\n            if (f.open(QIODevice::ReadOnly)) {\r\n                QTextStream ts(&f);\r\n                unsigned int pid; ts >> pid;\r\n                if (pid == pid_skip)\r\n                    continue;\r\n                QString pn; ts >> pn;\r\n                if (pn == pname)\r\n                    return pid;\r\n            }\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n#endif\r\n\r\n\r\nProcessWrapper::ProcessWrapper()\r\n{\r\n}\r\n\r\n"
        },
        {
          "name": "processwrapper.hh",
          "type": "blob",
          "size": 0.30859375,
          "content": "#ifndef PROCESSWRAPPER_H\r\n#define PROCESSWRAPPER_H\r\n\r\nclass ProcessWrapper\r\n{\r\npublic:\r\n  ProcessWrapper();\r\n\r\n  static unsigned int findProcess(const char *name, unsigned int pid_skip = 0);\r\n\tstatic unsigned int currentProcessId();\r\n  static bool processExists(unsigned int pid);\r\n};\r\n\r\n#endif // PROCESSWRAPPER_H\r\n"
        },
        {
          "name": "programs.cc",
          "type": "blob",
          "size": 10.3115234375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"programs.hh\"\n#include \"audiolink.hh\"\n#include \"htmlescape.hh\"\n#include \"utf8.hh\"\n#include \"wstring_qt.hh\"\n#include \"parsecmdline.hh\"\n#include \"iconv.hh\"\n#include \"qt4x5.hh\"\n\n#include <QDir>\n#include <QFileInfo>\n\nnamespace Programs {\n\nusing namespace Dictionary;\n\nnamespace {\n\nclass ProgramsDictionary: public Dictionary::Class\n{\n  Config::Program prg;\npublic:\n\n  ProgramsDictionary( Config::Program const & prg_ ):\n    Dictionary::Class( prg_.id.toStdString(), vector< string >() ),\n    prg( prg_ )\n  {\n  }\n\n  virtual string getName() throw()\n  { return prg.name.toUtf8().data(); }\n\n  virtual map< Property, string > getProperties() throw()\n  { return map< Property, string >(); }\n\n  virtual unsigned long getArticleCount() throw()\n  { return 0; }\n\n  virtual unsigned long getWordCount() throw()\n  { return 0; }\n\n  virtual sptr< WordSearchRequest > prefixMatch( wstring const & word,\n                                                 unsigned long maxResults )\n    THROW_SPEC( std::exception );\n\n  virtual sptr< DataRequest > getArticle( wstring const &,\n                                          vector< wstring > const & alts,\n                                          wstring const &, bool )\n    THROW_SPEC( std::exception );\n\nprotected:\n\n  virtual void loadIcon() throw();\n};\n\nsptr< WordSearchRequest > ProgramsDictionary::prefixMatch( wstring const & word,\n                                                           unsigned long /*maxResults*/ )\n  THROW_SPEC( std::exception )\n{\n  if ( prg.type == Config::Program::PrefixMatch )\n    return new ProgramWordSearchRequest( gd::toQString( word ), prg );\n  else\n  {\n    sptr< WordSearchRequestInstant > sr = new WordSearchRequestInstant;\n\n    sr->setUncertain( true );\n\n    return sr;\n  }\n}\n\nsptr< Dictionary::DataRequest > ProgramsDictionary::getArticle(\n  wstring const & word, vector< wstring > const &, wstring const &, bool )\n  THROW_SPEC( std::exception )\n{\n  switch( prg.type )\n  {\n    case Config::Program::Audio:\n    {\n      // Audio results are instantaneous\n      string result;\n\n      string wordUtf8( Utf8::encode( word ) );\n\n      result += \"<table class=\\\"programs_play\\\"><tr>\";\n\n      QUrl url;\n      url.setScheme( \"gdprg\" );\n      url.setHost( QString::fromUtf8( getId().c_str() ) );\n      url.setPath( Qt4x5::Url::ensureLeadingSlash( QString::fromUtf8( wordUtf8.c_str() ) ) );\n\n      string ref = string( \"\\\"\" ) + url.toEncoded().data() + \"\\\"\";\n\n      result += addAudioLink( ref, getId() );\n\n      result += \"<td><a href=\" + ref + \"><img src=\\\"qrcx://localhost/icons/playsound.png\\\" border=\\\"0\\\" alt=\\\"Play\\\"/></a></td>\";\n      result += \"<td><a href=\" + ref + \">\" +\n                Html::escape( wordUtf8 ) + \"</a></td>\";\n      result += \"</tr></table>\";\n\n      sptr< DataRequestInstant > ret = new DataRequestInstant( true );\n\n      ret->getData().resize( result.size() );\n\n      memcpy( &(ret->getData().front()), result.data(), result.size() );\n      return ret;\n    }\n\n    case Config::Program::Html:\n    case Config::Program::PlainText:\n      return new ProgramDataRequest( gd::toQString( word ), prg );\n\n    default:\n      return new DataRequestInstant( false );\n  }\n}\n\nvoid ProgramsDictionary::loadIcon() throw()\n{\n  if ( dictionaryIconLoaded )\n    return;\n\n  if( !prg.iconFilename.isEmpty() )\n  {\n    QFileInfo fInfo(  QDir( Config::getConfigDir() ), prg.iconFilename );\n    if( fInfo.isFile() )\n      loadIconFromFile( fInfo.absoluteFilePath(), true );\n  }\n  if( dictionaryIcon.isNull() )\n    dictionaryIcon = dictionaryNativeIcon = QIcon(\":/icons/programs.png\");\n  dictionaryIconLoaded = true;\n}\n\n}\n\nRunInstance::RunInstance(): process( this )\n{\n  connect( this, SIGNAL(processFinished()), this,\n           SLOT(handleProcessFinished()), Qt::QueuedConnection );\n  connect( &process, SIGNAL(finished(int)), this, SIGNAL(processFinished()));\n  connect( &process, SIGNAL(error(QProcess::ProcessError)), this,\n           SIGNAL(processFinished()) );\n}\n\nbool RunInstance::start( Config::Program const & prg, QString const & word,\n                         QString & error )\n{\n  QStringList args = parseCommandLine( prg.commandLine );\n\n  if ( !args.empty() )\n  {\n    QString programName = args.first();\n    args.pop_front();\n\n    bool writeToStdInput = true;\n\n    for( int x = 0; x < args.size(); ++x )\n      if( args[ x ].indexOf( \"%GDWORD%\" ) >= 0 )\n      {\n        writeToStdInput = false;\n        args[ x ].replace( \"%GDWORD%\", word );\n      }\n\n    process.start( programName, args );\n    if( writeToStdInput )\n    {\n      process.write( word.toLocal8Bit() );\n      process.closeWriteChannel();\n    }\n\n    return true;\n  }\n  else\n  {\n    error = tr( \"No program name was given.\" );\n    return false;\n  }\n}\n\nvoid RunInstance::handleProcessFinished()\n{\n  // It seems that sometimes the process isn't finished yet despite being\n  // signalled as such. So we wait for it here, which should hopefully be\n  // nearly instant.\n  process.waitForFinished();\n\n  QByteArray output = process.readAllStandardOutput();\n\n  QString error;\n  if ( process.exitStatus() != QProcess::NormalExit )\n    error = tr( \"The program has crashed.\" );\n  else\n  if ( int code = process.exitCode() )\n    error = tr( \"The program has returned exit code %1.\" ).arg( code );\n\n  if ( !error.isEmpty() )\n  {\n    QByteArray err = process.readAllStandardError();\n\n    if ( !err.isEmpty() )\n      error += \"\\n\\n\" + QString::fromLocal8Bit( err );\n  }\n\n  emit finished( output, error );\n}\n\nProgramDataRequest::ProgramDataRequest( QString const & word,\n                                        Config::Program const & prg_ ):\n  prg( prg_ )\n{\n  connect( &instance, SIGNAL(finished(QByteArray,QString)),\n           this, SLOT(instanceFinished(QByteArray,QString)) );\n\n  QString error;\n  if ( !instance.start( prg, word, error ) )\n  {\n    setErrorString( error );\n    finish();\n  }\n}\n\nvoid ProgramDataRequest::instanceFinished( QByteArray output, QString error )\n{\n  QString prog_output;\n  if ( !isFinished() )\n  {\n    if ( !output.isEmpty() )\n    {\n      string result = \"<div class='programs_\";\n\n      switch( prg.type )\n      {\n      case Config::Program::PlainText:\n        result += \"plaintext'>\";\n        try\n        {\n          // Check BOM if present\n          unsigned char * uchars = reinterpret_cast< unsigned char * >( output.data() );\n          if( output.length() >= 2 && uchars[ 0 ] == 0xFF && uchars[ 1 ] == 0xFE )\n          {\n            int size = output.length() - 2;\n            if( size & 1 )\n              size -= 1;\n            string res= Iconv::toUtf8( \"UTF-16LE\", output.data() + 2, size );\n            prog_output = QString::fromUtf8( res.c_str(), res.size() );\n          }\n          else\n          if( output.length() >= 2 && uchars[ 0 ] == 0xFE && uchars[ 1 ] == 0xFF )\n          {\n            int size = output.length() - 2;\n            if( size & 1 )\n              size -= 1;\n            string res = Iconv::toUtf8( \"UTF-16BE\", output.data() + 2, size );\n            prog_output = QString::fromUtf8( res.c_str(), res.size() );\n          }\n          else\n          if( output.length() >= 3 && uchars[ 0 ] == 0xEF && uchars[ 1 ] == 0xBB && uchars[ 2 ] == 0xBF )\n          {\n            prog_output = QString::fromUtf8( output.data() + 3, output.length() - 3 );\n          }\n          else\n          {\n            // No BOM, assume local 8-bit encoding\n            prog_output = QString::fromLocal8Bit( output );\n          }\n        }\n        catch( std::exception & e )\n        {\n          error = e.what();\n        }\n        result += Html::preformat( prog_output.toUtf8().data() );\n        break;\n      default:\n        result += \"html'>\";\n        try\n        {\n          // Check BOM if present\n          unsigned char * uchars = reinterpret_cast< unsigned char * >( output.data() );\n          if( output.length() >= 2 && uchars[ 0 ] == 0xFF && uchars[ 1 ] == 0xFE )\n          {\n            int size = output.length() - 2;\n            if( size & 1 )\n              size -= 1;\n            result += Iconv::toUtf8( \"UTF-16LE\", output.data() + 2, size );\n          }\n          else\n          if( output.length() >= 2 && uchars[ 0 ] == 0xFE && uchars[ 1 ] == 0xFF )\n          {\n            int size = output.length() - 2;\n            if( size & 1 )\n              size -= 1;\n            result += Iconv::toUtf8( \"UTF-16BE\", output.data() + 2, size );\n          }\n          else\n          if( output.length() >= 3 && uchars[ 0 ] == 0xEF && uchars[ 1 ] == 0xBB && uchars[ 2 ] == 0xBF )\n          {\n            result += output.data() + 3;\n          }\n          else\n          {\n            // We assume html data is in utf8 encoding already.\n            result += output.data();\n          }\n        }\n        catch( std::exception & e )\n        {\n          error = e.what();\n        }\n      }\n\n      result += \"</div>\";\n\n      Mutex::Lock _( dataMutex );\n      data.resize( result.size() );\n      memcpy( data.data(), result.data(), data.size() );\n      hasAnyData = true;\n    }\n\n    if ( !error.isEmpty() )\n      setErrorString( error );\n\n    finish();\n  }\n}\n\nvoid ProgramDataRequest::cancel()\n{\n  finish();\n}\n\nProgramWordSearchRequest::ProgramWordSearchRequest( QString const & word,\n                                                    Config::Program const & prg_ ):\n  prg( prg_ )\n{\n  connect( &instance, SIGNAL(finished(QByteArray,QString)),\n           this, SLOT(instanceFinished(QByteArray,QString)) );\n\n  QString error;\n  if ( !instance.start( prg, word, error ) )\n  {\n    setErrorString( error );\n    finish();\n  }\n}\n\nvoid ProgramWordSearchRequest::instanceFinished( QByteArray output, QString error )\n{\n  if ( !isFinished() )\n  {\n    // Handle any Windows artifacts\n    output.replace( \"\\r\\n\", \"\\n\" );\n    QStringList result =\n      QString::fromUtf8( output ).split( \"\\n\", Qt4x5::skipEmptyParts() );\n\n    for( int x = 0; x < result.size(); ++x )\n      matches.push_back( Dictionary::WordMatch( gd::toWString( result[ x ] ) ) );\n\n    if ( !error.isEmpty() )\n      setErrorString( error );\n\n    finish();\n  }\n}\n\nvoid ProgramWordSearchRequest::cancel()\n{\n  finish();\n}\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n  Config::Programs const & programs )\n  THROW_SPEC( std::exception )\n{\n  vector< sptr< Dictionary::Class > > result;\n\n  for( Config::Programs::const_iterator i = programs.begin();\n       i != programs.end(); ++i )\n    if ( i->enabled )\n      result.push_back( new ProgramsDictionary( *i ) );\n\n  return result;\n}\n\n}\n"
        },
        {
          "name": "programs.hh",
          "type": "blob",
          "size": 1.724609375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __PROGRAMS_HH_INCLUDED__\n#define __PROGRAMS_HH_INCLUDED__\n\n#include <QProcess>\n#include \"dictionary.hh\"\n#include \"config.hh\"\n#include \"wstring.hh\"\n\n/// Support for arbitrary programs.\nnamespace Programs {\n\nusing std::vector;\nusing std::string;\nusing gd::wstring;\n\nvector< sptr< Dictionary::Class > > makeDictionaries( Config::Programs const & )\n  THROW_SPEC( std::exception );\n\nclass RunInstance: public QObject\n{\n  Q_OBJECT\n  QProcess process;\n\npublic:\n\n  RunInstance();\n\n  // Starts the process. Should only be used once. The finished() signal will\n  // be emitted once it finishes. If there's an error, returns false and the\n  // description is saved to 'error'.\n  bool start( Config::Program const &, QString const & word, QString & error );\n\nsignals:\n  // Connect to this signal to get run results\n  void finished( QByteArray output, QString error );\n\n  // Used internally only\nsignals:\n  void processFinished();\nprivate slots:\n\n  void handleProcessFinished();\n};\n\nclass ProgramDataRequest: public Dictionary::DataRequest\n{\n  Q_OBJECT\n  Config::Program prg;\n  RunInstance instance;\n\npublic:\n\n  ProgramDataRequest( QString const & word, Config::Program const & );\n\n  virtual void cancel();\n\nprivate slots:\n\n  void instanceFinished( QByteArray output, QString error );\n};\n\nclass ProgramWordSearchRequest: public Dictionary::WordSearchRequest\n{\n  Q_OBJECT\n  Config::Program prg;\n  RunInstance instance;\n\npublic:\n\n  ProgramWordSearchRequest( QString const & word, Config::Program const & );\n\n  virtual void cancel();\n\nprivate slots:\n\n  void instanceFinished( QByteArray output, QString error );\n};\n\n}\n\n#endif\n"
        },
        {
          "name": "qt-style-macos.css",
          "type": "blob",
          "size": 0.48046875,
          "content": "#navToolbar #translateLine\n{\n  margin-top: 1px;\n}\n\n#navToolbar GroupComboBox\n{\n  margin-bottom: 1px;\n  margin-top: 0px;\n  padding: 2px 18px 2px 4px;\n}\n\n#navToolbar GroupComboBox::drop-down {\n  padding-right: 2px;\n  border-right: 1px solid darkgray;\n}\n\nScanPopup #translateLine\n{\n  padding: 3px 3px 3px 3px;\n}\n\nScanPopup GroupComboBox\n{\n  margin: 2px 0px 4px 1px;\n  padding: 1px 18px 1px 4px;\n}\n\nScanPopup GroupComboBox::drop-down {\n  padding-right: 2px;\n  border-right: 1px solid darkgray;\n}\n"
        },
        {
          "name": "qt-style-st-babylon.css",
          "type": "blob",
          "size": 0.2822265625,
          "content": "MainWindow #translateLine, ScanPopup #translateLine, MainWindow #searchPane #wordList, MainWindow #dictsPane #dictsList,\nMainWindow #historyPane #historyList, MainWindow #favoritesPane #favoritesTree\n{\n  background: white;\n}\n\nMainWindow #searchPane #translateLine\n{\n  font-weight: bold;\n}\n"
        },
        {
          "name": "qt-style-st-lingoes-blue.css",
          "type": "blob",
          "size": 1.8642578125,
          "content": "MainWindow {\n    background-color: #CFDDF0;\n}\n\nMainWindow #menubar {\n    background-color: qlineargradient(x1:0, y1:0, x2:0, y2:1,\n                      stop:0 #F0F6FF, stop:0.5 #D2E0F5, stop:0.9 #DCEBFF, stop:1 #F0F6FF);\n}\n\nMainWindow #menubar::item {\n    padding: 2px 8px;\n    background: transparent;\n}\n\nMainWindow #menubar::item:selected { /* when selected using mouse or keyboard */\n    background: #839EC7;\n}\n\nMainWindow #menubar::item:pressed {\n    background: #728AAD;\n}\n\nMainWindow #translateLine, ScanPopup #translateLine, MainWindow #wordList {\n    background-color: #fff;\n}\n\nMainWindow #centralWidget QTabBar::tab {\n    border: 1px solid #667B9B;\n    border-bottom-color: #667B9B;\n    border-top-left-radius: 4px;\n    border-top-right-radius: 4px;\n    padding: 1px 3px;\n    margin-left: 1px;\n    margin-top: 2px;\n    margin-bottom: 2px;\n    background-color: #CFDDF0;\n    color: darkslategray;\n}\n\nMainWindow #centralWidget QTabBar::tab:selected {\n    background-color: #839EC7;\n    color: #fff;\n    border-bottom-style: none;\n}\n\nMainWindow #dictsPane #dictsList {\n   background: \t#EAF0F8; \n   color: darkblue;\n}\n\nArticleView #searchFrame QMenu {background-color: none}\nArticleView QMenu {background-color: none} \n\nMainWindow #dictionaryBar QToolTip {\n   background: #839EC7;\n   color: white;\n   border-style: none;\n}\n\nQMainWindow::separator {\n     width:  1px; /* when vertical */\n     height: 1px; /* when horizontal */\n} \n\n#dictsPaneTitleBar {\n  background: #A8C0E4;\n  margin: 2px;\n} \n\n/* Colored header for the History Pane */\n#historyPaneTitleBar {\n  background: #A8C0E4;\n  margin: 2px;\n} \n\nMainWindow #historyPane #historyList, MainWindow #favoritesPane #favoritesTree {\n   background: \t#EAF0F8; \n   color: #52627C;\n}\n\nMainStatusBar #text\n{\n  background: #839EC7;\n  color: #fff;\n}\n\nScanPopup #outerFrame\n{\n   background-color: #CEDDEF;\n}\n\nScanPopup #dictionaryBar\n{\n   background: #CEDDEF;\n}\n"
        },
        {
          "name": "qt-style-st-lingvo.css",
          "type": "blob",
          "size": 0.2080078125,
          "content": "MainWindow #translateLine, ScanPopup #translateLine, MainWindow #wordList, MainWindow #dictsPane #dictsList,\nMainWindow #historyPane #historyList, MainWindow #favoritesPane #favoritesTree\n{\n  background: white;\n}\n"
        },
        {
          "name": "qt-style-st-modern.css",
          "type": "blob",
          "size": 1.7783203125,
          "content": "MainWindow #translateLine, ScanPopup #translateLine, MainWindow #wordList, MainWindow #dictsPane #dictsList,\nMainWindow #historyPane #historyList, MainWindow #favoritesPane #favoritesTree\n{\n  background: white;\n}\n\n/* WARNING: hides all separators! */\n#navToolbar::separator {\n  width: 0px;\n}\n\n/* Another way to hide specific separators */\n#navToolbar #beforeOptionsSeparator, #navToolbar #beforeScanPopupSeparator, #navToolbar #afterScanPopupSeparator, #navToolbar #separatorBeforeZoom, #navToolbar #separatorBeforeSave {\n  background: rgba(0,0,0,0%);\n  width: 0px;\n  margin: -3px;\n}\n\n\n/* Hide various buttons in the toolbar: */\n#navToolbar #menuButtonXX, #navToolbar #soundButtonXX, #navToolbar #backButtonXX, #navToolbar #forwardButtonXX, #navToolbar #zoomInButtonXX, #navToolbar #zoomOutButtonXX, #navToolbar #zoomBaseButtonXX, #navToolbar #saveArticleButton, #navToolbar #printButton {\n  width:   0px;\n  height:  0px;\n  margin:  -3px;\n}\n\n/* remove the main toolbar handle */\n#navToolbar::handle, #dictionaryBar::handle {\n  image: none;\n  width:  0px;\n  margin-left: 1px;\n}\n\n#navToolbar #scanPopupButton {\n  margin-left: 5px;\n}\n\n/* Colored header for the \"Found in Dictionaries:\" pane */\n#dictsPaneTitleBar {\n  background: lightblue;\n  margin: 2px;\n}\n\n/* Colored header for the History Pane */\n#historyPaneTitleBar {\n  background: lightsteelblue;\n  margin: 2px;\n}\n\n/* Thin separators between the main UI and sidebars */\nQMainWindow::separator {\n     width:  1px; /* when vertical */\n     height: 1px; /* when horizontal */\n}\n\nScanPopup #goBackButtonAA,\n/* ScanPopup #queryError,        */\nScanPopup #goForwardButtonAA,\nScanPopup #wordListButtonXX,\nScanPopup #pronounceButtonAA,\nScanPopup #sendWordButtonXX\n/* ScanPopup #showDictionaryBar, */\n/* ScanPopup #pinButton */\n{\n  width: 0px;\n  height: 0px;\n  margin: -4px;\n}\n"
        },
        {
          "name": "qt-style.css",
          "type": "blob",
          "size": 3.5888671875,
          "content": "MainWindow #translateLine, ScanPopup #translateLine, MainWindow #wordList, MainWindow #dictsPane #dictsList, MainWindow #historyPane #historyList, MainWindow #favoritesPane #favoritesTree\n{\n  background: #fefdeb;\n  color: black;\n}\n\nMainWindow #translateLine[noResults=\"true\"],\nScanPopup #translateLine[noResults=\"true\"]\n{\n  background: #febb7d;\n}\n\n#navToolbar #menuButton::menu-indicator {\n  image: none;\n}\n\n#navToolbar #translateLine\n{\n  border: 1px solid gray;\n  border-radius: 3px;\n  padding: 1px 3px 2px 3px;\n  border-top-left-radius: 0px;\n  border-bottom-left-radius: 0px;\n  margin-left: 0px;\n}\n\n#navToolbar GroupComboBox\n{\n  margin-right: 0px;\n  border: 1px solid gray;\n  border-right: 1px transparent;\n  border-radius: 3px;\n  border-top-right-radius: 0px;\n  border-bottom-right-radius: 0px;\n  padding: 2px 4px 2px 4px;\n  background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,\n                              stop: 0 #E1E1E1, stop: 0.4 #DDDDDD,\n                              stop: 0.5 #D8D8D8, stop: 1.0 #D3D3D3);\n}\n\n#navToolbar GroupComboBox:on {\n  padding: 3px 3px 1px 5px;\n  background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,\n                              stop: 0 #D3D3D3, stop: 0.4 #D8D8D8,\n                              stop: 0.5 #DDDDDD, stop: 1.0 #E1E1E1);\n}\n\n#navToolbar GroupComboBox::drop-down {\n   subcontrol-origin: padding;\n   subcontrol-position: top right;\n   width: 15px;\n   border-left: 1px solid darkgray;\n   border-right: 1px transparent;\n}\n\n#navToolbar GroupComboBox::down-arrow {\n   image: url(:/icons/1downarrow.png);\n}\n\n#navToolbar GroupComboBox::down-arrow:on { /* shift the arrow when popup is open */\n   top: 1px;\n   left: 1px;\n}\n\nArticleView #searchText[noResults=\"true\"]\n{\n  background: #febb7d;\n}\n\nMainStatusBar #text\n{\n  border-top-right-radius: 3px;\n  border-top: 1px solid palette(dark);\n  border-right: 1px solid palette(dark);\n  background: palette(window);\n  padding: 2px;\n}\n\nMainStatusBar #icon\n{\n  border-top: 1px solid palette(dark);\n  background: palette(window);\n  padding: 2px;\n  padding-left: 4px;\n  padding-right: 0px;\n}\n\nScanPopup #translateLine\n{\n  margin: 0px;\n  padding: 1px 3px 1px 3px;\n  border: 1px solid gray;\n  border-radius: 3px;\n  border-top-left-radius: 0px;\n  border-bottom-left-radius: 0px;\n}\n\nScanPopup GroupComboBox\n{\n  margin: 0px 0px 0px 1px;\n  padding: 1px 4px 1px 4px;\n  border: 1px solid gray;\n  border-right: 1px transparent;\n  border-radius: 3px;\n  border-top-right-radius: 0px;\n  border-bottom-right-radius: 0px;\n  background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,\n                              stop: 0 #E1E1E1, stop: 0.4 #DDDDDD,\n                              stop: 0.5 #D8D8D8, stop: 1.0 #D3D3D3);\n}\n\nScanPopup GroupComboBox:on {\n  padding: 3px 3px 1px 5px;\n  background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,\n                              stop: 0 #D3D3D3, stop: 0.4 #D8D8D8,\n                              stop: 0.5 #DDDDDD, stop: 1.0 #E1E1E1);\n}\n\nScanPopup GroupComboBox::drop-down {\n   subcontrol-origin: padding;\n   subcontrol-position: top right;\n   width: 15px;\n   border-left: 1px solid darkgray;\n   border-right: 1px transparent;\n}\n\nScanPopup GroupComboBox::down-arrow {\n   image: url(:/icons/1downarrow.png);\n}\n\nScanPopup GroupComboBox::down-arrow:on { /* shift the arrow when popup is open */\n   top: 1px;\n   left: 1px;\n}\n\n.ScanPopup #outerFrame\n{\n  border: 1px solid palette(dark);\n}\n\n.ScanPopup MainStatusBar #text\n{\n  border-bottom: 1px solid palette(dark);\n}\n\n.ScanPopup MainStatusBar[hasImage=\"false\"] #text\n{\n  border-left: 1px solid palette(dark);\n}\n\n.ScanPopup MainStatusBar #icon\n{\n  border-left: 1px solid palette(dark);\n  border-bottom: 1px solid palette(dark);\n}\n"
        },
        {
          "name": "qt4x5.hh",
          "type": "blob",
          "size": 4.1796875,
          "content": "/* Thin wrappers for retaining compatibility for both Qt4.x and Qt5.x */\n\n#ifndef QT4X5_HH\n#define QT4X5_HH\n\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n# define IS_QT_5    0\n#else\n# define IS_QT_5    1\n#endif\n\n#include <QProcess>\n#include <QString>\n#include <QAtomicInt>\n#include <QTextDocument>\n\n#include <QUrl>\n#if IS_QT_5\n#include <QUrlQuery>\n#endif\n\nnamespace Qt4x5\n{\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 14, 0 )\ninline Qt::SplitBehaviorFlags keepEmptyParts()\n{ return Qt::KeepEmptyParts; }\ninline Qt::SplitBehaviorFlags skipEmptyParts()\n{ return Qt::SkipEmptyParts; }\n#else\ninline QString::SplitBehavior keepEmptyParts()\n{ return QString::KeepEmptyParts; }\ninline QString::SplitBehavior skipEmptyParts()\n{ return QString::SkipEmptyParts; }\n#endif\n\ninline Qt::MouseButton middleButton()\n{\n#if QT_VERSION >= QT_VERSION_CHECK( 4, 7, 0 )\n  return Qt::MiddleButton;\n#else\n  return Qt::MidButton;\n#endif\n}\n\ninline QString escape( QString const & plain )\n{\n#if IS_QT_5\n  return plain.toHtmlEscaped();\n#else\n  return Qt::escape( plain );\n#endif\n\n}\n\nnamespace AtomicInt\n{\n\ninline int loadAcquire( QAtomicInt const & ref )\n{\n#if IS_QT_5\n  return ref.loadAcquire();\n#else\n  return ( int )ref;\n#endif\n}\n\n}\n\nnamespace Url\n{\n\n// This wrapper is created due to behavior change of the setPath() method\n// See: https://bugreports.qt-project.org/browse/QTBUG-27728\n//       https://codereview.qt-project.org/#change,38257\ninline QString ensureLeadingSlash( const QString & path )\n{\n#if IS_QT_5\n  QLatin1Char slash( '/' );\n  if ( path.startsWith( slash ) )\n    return path;\n  return slash + path;\n#else\n  return path;\n#endif\n}\n\ninline bool hasQueryItem( QUrl const & url, QString const & key )\n{\n#if IS_QT_5\n  return QUrlQuery( url ).hasQueryItem( key );\n#else\n  return url.hasQueryItem( key );\n#endif\n}\n\ninline QString queryItemValue( QUrl const & url, QString const & item )\n{\n#if IS_QT_5\n  return QUrlQuery( url ).queryItemValue( item, QUrl::FullyDecoded );\n#else\n  return url.queryItemValue( item );\n#endif\n}\n\ninline QByteArray encodedQueryItemValue( QUrl const & url, QString const & item )\n{\n#if IS_QT_5\n  return QUrlQuery( url ).queryItemValue( item, QUrl::FullyEncoded ).toLatin1();\n#else\n  return url.encodedQueryItemValue( item.toLatin1() );\n#endif\n}\n\ninline void addQueryItem( QUrl & url, QString const & key, QString const & value )\n{\n#if IS_QT_5\n  QUrlQuery urlQuery( url );\n  urlQuery.addQueryItem( key, value );\n  url.setQuery( urlQuery );\n#else\n  url.addQueryItem( key, value );\n#endif\n}\n\ninline void removeQueryItem( QUrl & url, QString const & key )\n{\n#if IS_QT_5\n  QUrlQuery urlQuery( url );\n  urlQuery.removeQueryItem( key );\n  url.setQuery( urlQuery );\n#else\n  url.removeQueryItem( key );\n#endif\n}\n\ninline QString fullPath( QUrl const & url )\n{\n#if IS_QT_5\n  QString path = url.path( QUrl::FullyDecoded );\n  if( url.hasQuery() )\n  {\n    QUrlQuery urlQuery( url );\n    path += QString::fromLatin1( \"?\" ) + urlQuery.toString( QUrl::FullyDecoded );\n  }\n  return path;\n#else\n  return url.toString( QUrl::RemoveScheme | QUrl::RemoveAuthority | QUrl::RemoveFragment | QUrl::RemovePort );\n#endif\n}\n\ninline void setQueryItems( QUrl & url, QList< QPair< QString, QString > > const & query )\n{\n#if IS_QT_5\n  QUrlQuery urlQuery( url );\n  urlQuery.setQueryItems( query );\n  url.setQuery( urlQuery );\n#else\n  url.setQueryItems( query );\n#endif\n}\n\ninline QString path( QUrl const & url )\n{\n#if IS_QT_5\n  return url.path( QUrl::FullyDecoded );\n#else\n  return url.path();\n#endif\n}\n\ninline void setFragment( QUrl & url, const QString & fragment )\n{\n#if IS_QT_5\n  url.setFragment( fragment, QUrl::DecodedMode );\n#else\n  url.setFragment( fragment );\n#endif\n}\n\ninline QString fragment( const QUrl & url )\n{\n#if IS_QT_5\n  return url.fragment( QUrl::FullyDecoded );\n#else\n  return url.fragment();\n#endif\n}\n\n}\n\nnamespace Dom\n{\n\n#if IS_QT_5\ntypedef int size_type;\n#else\ntypedef uint size_type;\n#endif\n\n}\n\nnamespace Process\n{\n\ninline bool startDetached( QString const & command )\n{\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 15, 0 )\n  auto args = QProcess::splitCommand( command );\n  if( args.empty() )\n    return false;\n  auto const program = args.takeFirst();\n  return QProcess::startDetached( program, args );\n#else\n  return QProcess::startDetached( command );\n#endif\n}\n\n}\n\n}\n\n#endif // QT4X5_HH\n"
        },
        {
          "name": "qtsingleapplication",
          "type": "tree",
          "content": null
        },
        {
          "name": "redist",
          "type": "tree",
          "content": null
        },
        {
          "name": "resources.qrc",
          "type": "blob",
          "size": 3.515625,
          "content": "<RCC>\n    <qresource prefix=\"/\">\n        <file>version.txt</file>\n        <file>icons/print.png</file>\n        <file>icons/arrow.png</file>\n        <file>icons/prefix.png</file>\n        <file>icons/pushpin.png</file>\n        <file>icons/playsound.png</file>\n        <file>icons/closetab.png</file>\n        <file>icons/addtab.png</file>\n        <file>icons/next.png</file>\n        <file>icons/previous.png</file>\n        <file>icons/home.png</file>\n        <file>icons/reload.png</file>\n        <file>icons/programicon.png</file>\n        <file>icons/programicon_scan.png</file>\n        <file>icons/programs.png</file>\n        <file>icons/wizard.png</file>\n        <file>icons/warning.png</file>\n        <file>article-style.css</file>\n        <file>article-style-print.css</file>\n        <file>qt-style.css</file>\n        <file>icons/icon32_dsl.png</file>\n        <file>icons/icon32_stardict.png</file>\n        <file>icons/icon32_xdxf.png</file>\n        <file>icons/icon32_bgl.png</file>\n        <file>icons/icon32_dictd.png</file>\n        <file>icons/icon32_hunspell.png</file>\n        <file>icons/fileopen.png</file>\n        <file>icons/filesave.png</file>\n        <file>icons/icon32_wiki.png</file>\n        <file>icons/icon32_zoombase.png</file>\n        <file>icons/icon32_zoomin.png</file>\n        <file>icons/icon32_zoomout.png</file>\n        <file>icons/network.png</file>\n        <file>icons/hotkeys.png</file>\n        <file>icons/interface.png</file>\n        <file>icons/configure.png</file>\n        <file>icons/book.png</file>\n        <file>icons/bookcase.png</file>\n        <file>qt-style-st-lingvo.css</file>\n        <file>article-style-st-lingvo.css</file>\n        <file>icons/internet.png</file>\n        <file>icons/icon_dsl_native.png</file>\n        <file>icons/forvo.png</file>\n        <file>icons/windows-list.png</file>\n        <file>CREDITS.txt</file>\n        <file>icons/highlighter.png</file>\n        <file>icons/error.png</file>\n        <file>icons/macicon.png</file>\n        <file>icons/icon32_sdict.png</file>\n        <file>icons/icon32_aard.png</file>\n        <file>icons/expand_opt.png</file>\n        <file>icons/collapse_opt.png</file>\n        <file>article-style-st-babylon.css</file>\n        <file>qt-style-st-babylon.css</file>\n        <file>icons/1downarrow.png</file>\n        <file>icons/system-search.png</file>\n        <file>icons/menu_button.png</file>\n        <file>icons/clear.png</file>\n        <file>article-style-st-modern.css</file>\n        <file>qt-style-st-modern.css</file>\n        <file>article-style-st-lingoes.css</file>\n        <file>icons/icon32_lingoes.png</file>\n        <file>article-style-st-lingoes-blue.css</file>\n        <file>qt-style-st-lingoes-blue.css</file>\n        <file>qt-style-macos.css</file>\n        <file>icons/mdict.png</file>\n        <file>icons/downarrow.png</file>\n        <file>icons/blank.png</file>\n        <file>icons/expand_article_hovered.png</file>\n        <file>icons/expand_article.png</file>\n        <file>icons/collapse_article_hovered.png</file>\n        <file>icons/collapse_article.png</file>\n        <file>icons/video.png</file>\n        <file>icons/programicon_old.png</file>\n        <file>icons/playsound_color.png</file>\n        <file>icons/playsound_full.png</file>\n        <file>icons/icon32_zim.png</file>\n        <file>icons/icon32_epwing.png</file>\n        <file>icons/icon32_slob.png</file>\n        <file>icons/icon32_gls.png</file>\n        <file>icons/star.png</file>\n        <file>icons/star_blue.png</file>\n        <file>icons/folder.png</file>\n        <file>icons/ontop.png</file>\n    </qresource>\n</RCC>\n"
        },
        {
          "name": "ripemd.cc",
          "type": "blob",
          "size": 5.77734375,
          "content": "// Copyright (C) 2007 Michael Niedermayer <michaelni@gmx.at>\n// Copyright (C) 2013 James Almer <jamrial@gmail.com>\n// Copyright (C) 2015 Zhe Wang <0x1998@gmail.com>\n//\n// Based on the RIPEMD-128 implementation from libavutil\n//\n// This program is a free software; you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, version 3 of the License.\n//\n// You can get a copy of GNU General Public License along this program\n// But you can always get it from http://www.gnu.org/licenses/gpl.txt\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n\n#include \"ripemd.hh\"\n\n#include <limits>\n#include <string.h>\n#include <QtEndian>\n\n\nstatic const quint32 KA[4] = {\n    0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e\n};\n\nstatic const quint32 KB[4] = {\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9\n};\n\nstatic const int ROTA[80] = {\n    11, 14, 15, 12,  5,  8,  7 , 9, 11, 13, 14, 15,  6,  7,  9,  8,\n     7 , 6,  8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,\n    11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,\n    11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,\n     9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6\n};\n\nstatic const int ROTB[80] = {\n     8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,\n     9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,\n     9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,\n    15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,\n     8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11\n};\n\nstatic const int WA[80] = {\n     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n     7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,\n     3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,\n     1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,\n     4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13\n};\n\nstatic const int WB[80] = {\n     5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,\n     6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,\n    15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,\n     8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,\n    12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11\n};\n\n#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))\n\n#define ROUND128_0_TO_15(a,b,c,d,e,f,g,h)                               \\\n    a = rol(a + ((  b ^ c  ^ d)      + block[WA[n]]),         ROTA[n]); \\\n    e = rol(e + ((((f ^ g) & h) ^ g) + block[WB[n]] + KB[0]), ROTB[n]); \\\n    n++\n\n#define ROUND128_16_TO_31(a,b,c,d,e,f,g,h)                              \\\n    a = rol(a + ((((c ^ d) & b) ^ d) + block[WA[n]] + KA[0]), ROTA[n]); \\\n    e = rol(e + (((~g | f) ^ h)      + block[WB[n]] + KB[1]), ROTB[n]); \\\n    n++\n\n#define ROUND128_32_TO_47(a,b,c,d,e,f,g,h)                              \\\n    a = rol(a + (((~c | b) ^ d)      + block[WA[n]] + KA[1]), ROTA[n]); \\\n    e = rol(e + ((((g ^ h) & f) ^ h) + block[WB[n]] + KB[2]), ROTB[n]); \\\n    n++\n\n#define ROUND128_48_TO_63(a,b,c,d,e,f,g,h)                              \\\n    a = rol(a + ((((b ^ c) & d) ^ c) + block[WA[n]] + KA[2]), ROTA[n]); \\\n    e = rol(e + ((  f ^ g  ^ h)      + block[WB[n]]),         ROTB[n]); \\\n    n++\n\n#define R128_0                          \\\n    ROUND128_0_TO_15(a,b,c,d,e,f,g,h);  \\\n    ROUND128_0_TO_15(d,a,b,c,h,e,f,g);  \\\n    ROUND128_0_TO_15(c,d,a,b,g,h,e,f);  \\\n    ROUND128_0_TO_15(b,c,d,a,f,g,h,e)\n\n#define R128_16                         \\\n    ROUND128_16_TO_31(a,b,c,d,e,f,g,h); \\\n    ROUND128_16_TO_31(d,a,b,c,h,e,f,g); \\\n    ROUND128_16_TO_31(c,d,a,b,g,h,e,f); \\\n    ROUND128_16_TO_31(b,c,d,a,f,g,h,e)\n\n#define R128_32                         \\\n    ROUND128_32_TO_47(a,b,c,d,e,f,g,h); \\\n    ROUND128_32_TO_47(d,a,b,c,h,e,f,g); \\\n    ROUND128_32_TO_47(c,d,a,b,g,h,e,f); \\\n    ROUND128_32_TO_47(b,c,d,a,f,g,h,e)\n\n#define R128_48                         \\\n    ROUND128_48_TO_63(a,b,c,d,e,f,g,h); \\\n    ROUND128_48_TO_63(d,a,b,c,h,e,f,g); \\\n    ROUND128_48_TO_63(c,d,a,b,g,h,e,f); \\\n    ROUND128_48_TO_63(b,c,d,a,f,g,h,e)\n\n\nRIPEMD128::RIPEMD128()\n  : count(0)\n  , buffer()\n  , state()\n{\n  state[0] = 0x67452301;\n  state[1] = 0xEFCDAB89;\n  state[2] = 0x98BADCFE;\n  state[3] = 0x10325476;\n}\n\nvoid RIPEMD128::transform( const uchar buffer[64] )\n{\n    quint32 a, b, c, d, e, f, g, h;\n    quint32 block[16];\n    int n;\n\n    a = e = state[0];\n    b = f = state[1];\n    c = g = state[2];\n    d = h = state[3];\n\n    for (n = 0; n < 16; n++)\n      block[n] = qFromLittleEndian<quint32>( buffer + 4 * n );\n    n = 0;\n\n    R128_0; R128_0; R128_0; R128_0;\n\n    R128_16; R128_16; R128_16; R128_16;\n\n    R128_32; R128_32; R128_32; R128_32;\n\n    R128_48; R128_48; R128_48; R128_48;\n\n    h += c + state[1];\n    state[1] = state[2] + d + e;\n    state[2] = state[3] + a + f;\n    state[3] = state[0] + b + g;\n    state[0] = h;\n}\n\nvoid RIPEMD128::update( const uchar * data, size_t len )\n{\n  size_t i, j;\n\n  j = count & 63;\n  count += len;\n  if ( ( j + len ) > 63 )\n  {\n    memcpy( &buffer[j], data, ( i = 64 - j ) );\n    transform( buffer );\n    for ( ; i + 63 < len; i += 64 )\n      transform( &data[i] );\n    j = 0;\n  }\n  else\n  {\n    i = 0;\n  }\n  memcpy( &buffer[j], &data[i], len - i );\n}\n\nvoid RIPEMD128::digest( uchar * digest )\n{\n  quint64 finalcount = qFromLittleEndian( count << 3 );\n  update( (const uchar *) \"\\200\", 1 );\n  while ( ( count & 63 ) != 56 )\n    update( ( const uchar * ) \"\", 1 );\n  update( ( uchar * ) &finalcount, 8 ); /* Should cause a transform() */\n  for ( int i = 0; i < 4; i++ )\n    qToLittleEndian( state[i], digest + i*4 );\n}\n"
        },
        {
          "name": "ripemd.hh",
          "type": "blob",
          "size": 1.4765625,
          "content": "// Copyright (C) 2007 Michael Niedermayer <michaelni@gmx.at>\n// Copyright (C) 2013 James Almer <jamrial@gmail.com>\n// Copyright (C) 2015 Zhe Wang <0x1998@gmail.com>\n//\n// Based on the RIPEMD-128 implementation from libavutil\n//\n// This program is a free software; you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, version 3 of the License.\n//\n// You can get a copy of GNU General Public License along this program\n// But you can always get it from http://www.gnu.org/licenses/gpl.txt\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n\n#ifndef __RIPEMD_HH_INCLUDED__\n#define __RIPEMD_HH_INCLUDED__\n\n#include <stddef.h>\n#include <QtGlobal>\n\n#if defined( _MSC_VER ) && _MSC_VER < 1800 // VS2012 and older\n#include <stdint_msvc.h>\n#else\n#include <stdint.h>\n#endif\n\nclass RIPEMD128\n{\npublic:\n  RIPEMD128();\n\n  // Update hash value\n  void update( const uchar * data, size_t len );\n\n  // Finish hashing and output digest value.\n  void digest( uchar * digest );\n\nprivate:\n  quint64 count;       // number of bytes in buffer\n  uchar  buffer[64];  // 512-bit buffer of input values used in hash updating\n  quint32 state[10];   // current hash value\n\n  void transform( const uchar buffer[64] );\n};\n\n#endif // __RIPEMD_HH_INCLUDED__\n"
        },
        {
          "name": "romaji.cc",
          "type": "blob",
          "size": 8.4609375,
          "content": "#include \"romaji.hh\"\n#include <QCoreApplication>\n\nnamespace Romaji {\n\nclass HepburnHiragana: public Transliteration::Table\n{\npublic:\n\n  HepburnHiragana();\n};\n\nHepburnHiragana::HepburnHiragana()\n{\n  // Raw UTF8 -- handle with care. We'd better remap those to \\xAB hex encoding\n  ins( \"a\", \"あ\" ); ins( \"i\", \"い\" ); ins( \"u\", \"う\" ); ins( \"e\", \"え\" ); ins( \"o\", \"お\" ); \n\n  ins( \"ka\", \"か\" ); ins( \"ki\", \"き\" ); ins( \"ku\", \"く\" ); ins( \"ke\", \"け\" ); ins( \"ko\", \"こ\" ); ins( \"kya\", \"きゃ\" ); ins( \"kyu\", \"きゅ\" ); ins( \"kyo\", \"きょ\" ); \n  ins( \"sa\", \"さ\" ); ins( \"shi\", \"し\" ); ins( \"su\", \"す\" ); ins( \"se\", \"せ\" ); ins( \"so\", \"そ\" ); ins( \"sha\", \"しゃ\" ); ins( \"shu\", \"しゅ\" ); ins( \"sho\", \"しょ\" ); \n  ins( \"ta\", \"た\" ); ins( \"chi\", \"ち\" ); ins( \"tsu\", \"つ\" ); ins( \"te\", \"て\" ); ins( \"to\", \"と\" ); ins( \"cha\", \"ちゃ\" ); ins( \"chu\", \"ちゅ\" ); ins( \"cho\", \"ちょ\" ); \n  ins( \"na\", \"な\" ); ins( \"ni\", \"に\" ); ins( \"nu\", \"ぬ\" ); ins( \"ne\", \"ね\" ); ins( \"no\", \"の\" ); ins( \"nya\", \"にゃ\" ); ins( \"nyu\", \"にゅ\" ); ins( \"nyo\", \"にょ\" ); \n  ins( \"ha\", \"は\" ); ins( \"hi\", \"ひ\" ); ins( \"fu\", \"ふ\" ); ins( \"he\", \"へ\" ); ins( \"ho\", \"ほ\" ); ins( \"hya\", \"ひゃ\" ); ins( \"hyu\", \"ひゅ\" ); ins( \"hyo\", \"ひょ\" ); \n  ins( \"ma\", \"ま\" ); ins( \"mi\", \"み\" ); ins( \"mu\", \"む\" ); ins( \"me\", \"め\" ); ins( \"mo\", \"も\" ); ins( \"mya\", \"みゃ\" ); ins( \"myu\", \"みゅ\" ); ins( \"myo\", \"みょ\" ); \n  ins( \"ya\", \"や\" ); ins( \"yu\", \"ゆ\" ); ins( \"yo\", \"よ\" ); \n  ins( \"ra\", \"ら\" ); ins( \"ri\", \"り\" ); ins( \"ru\", \"る\" ); ins( \"re\", \"れ\" ); ins( \"ro\", \"ろ\" ); ins( \"rya\", \"りゃ\" ); ins( \"ryu\", \"りゅ\" ); ins( \"ryo\", \"りょ\" ); \n  ins( \"wa\", \"わ\" ); /*ゐ wi† \t\tゑ we† */ ins( \"wo\", \"を\" );\n  ins( \"n\", \"ん\" );\n  ins( \"ga\", \"が\" ); ins( \"gi\", \"ぎ\" ); ins( \"gu\", \"ぐ\" ); ins( \"ge\", \"げ\" ); ins( \"go\", \"ご\" ); ins( \"gya\", \"ぎゃ\" ); ins( \"gyu\", \"ぎゅ\" ); ins( \"gyo\", \"ぎょ\" ); \n  ins( \"za\", \"ざ\" ); ins( \"ji\", \"じ\" ); ins( \"zu\", \"ず\" ); ins( \"ze\", \"ぜ\" ); ins( \"zo\", \"ぞ\" ); ins( \"ja\", \"じゃ\" ); ins( \"ju\", \"じゅ\" ); ins( \"jo\", \"じょ\" ); \n  ins( \"da\", \"だ\" ); ins( \"(ji)\", \"ぢ\" ); ins( \"(zu)\", \"づ\" ); ins( \"de\", \"で\" ); ins( \"do\", \"ど\" ); ins( \"(ja)\", \"ぢゃ\" ); ins( \"(ju)\", \"ぢゅ\" ); ins( \"(jo)\", \"ぢょ\" ); \n  ins( \"ba\", \"ば\" ); ins( \"bi\", \"び\" ); ins( \"bu\", \"ぶ\" ); ins( \"be\", \"べ\" ); ins( \"bo\", \"ぼ\" ); ins( \"bya\", \"びゃ\" ); ins( \"byu\", \"びゅ\" ); ins( \"byo\", \"びょ\" ); \n  ins( \"pa\", \"ぱ\" ); ins( \"pi\", \"ぴ\" ); ins( \"pu\", \"ぷ\" ); ins( \"pe\", \"ぺ\" ); ins( \"po\", \"ぽ\" ); ins( \"pya\", \"ぴゃ\" ); ins( \"pyu\", \"ぴゅ\" ); ins( \"pyo\", \"ぴょ\" ); \n\n// Double consonants\n\n  ins( \"kka\", \"っか\" ); ins( \"kki\", \"っき\" ); ins( \"kku\", \"っく\" ); ins( \"kke\", \"っけ\" ); ins( \"kko\", \"っこ\" ); ins( \"kkya\", \"っきゃ\" ); ins( \"kkyu\", \"っきゅ\" ); ins( \"kkyo\", \"っきょ\" );\n  ins( \"ssa\", \"っさ\" ); ins( \"sshi\", \"っし\" ); ins( \"ssu\", \"っす\" ); ins( \"sse\", \"っせ\" ); ins( \"sso\", \"っそ\" ); ins( \"ssha\", \"っしゃ\" ); ins( \"sshu\", \"っしゅ\" ); ins( \"ssho\", \"っしょ\" );\n  ins( \"tta\", \"った\" ); ins( \"tchi\", \"っち\" ); ins( \"ttsu\", \"っつ\" ); ins( \"tte\", \"って\" ); ins( \"tto\", \"っと\" ); ins( \"tcha\", \"っちゃ\" ); ins( \"tchu\", \"っちゅ\" ); ins( \"tcho\", \"っちょ\" );\n  ins( \"ppa\", \"っぱ\" ); ins( \"ppi\", \"っぴ\" ); ins( \"ppu\", \"っぷ\" ); ins( \"ppe\", \"っぺ\" ); ins( \"ppo\", \"っぽ\" ); ins( \"ppya\", \"っぴゃ\" ); ins( \"ppyu\", \"っぴゅ\" ); ins( \"ppyo\", \"っぴょ\" );\n\n}\n\nclass HepburnKatakana: public Transliteration::Table\n{\npublic:\n\n  HepburnKatakana();\n};\n\nHepburnKatakana::HepburnKatakana()\n{\n  // Raw UTF8 -- handle with care. We'd better remap those to \\xAB hex encoding\n  ins( \"a\", \"ア\" ); ins( \"i\", \"イ\" ); ins( \"u\", \"ウ\" ); ins( \"e\", \"エ\" ); ins( \"o\", \"オ\" ); \n\n  ins( \"ka\", \"カ\" ); ins( \"ki\", \"キ\" ); ins( \"ku\", \"ク\" ); ins( \"ke\", \"ケ\" ); ins( \"ko\", \"コ\" ); ins( \"kya\", \"キャ\" ); ins( \"kyu\", \"キュ\" ); ins( \"kyo\", \"キョ\" ); \n  ins( \"sa\", \"サ\" ); ins( \"shi\", \"シ\" ); ins( \"su\", \"ス\" ); ins( \"se\", \"セ\" ); ins( \"so\", \"ソ\" ); ins( \"sha\", \"シャ\" ); ins( \"shu\", \"シュ\" ); ins( \"sho\", \"ショ\" ); \n  ins( \"ta\", \"タ\" ); ins( \"chi\", \"チ\" ); ins( \"tsu\", \"ツ\" ); ins( \"te\", \"テ\" ); ins( \"to\", \"ト\" ); ins( \"cha\", \"チャ\" ); ins( \"chu\", \"チュ\" ); ins( \"cho\", \"チョ\" ); \n  ins( \"na\", \"ナ\" ); ins( \"ni\", \"ニ\" ); ins( \"nu\", \"ヌ\" ); ins( \"ne\", \"ネ\" ); ins( \"no\", \"ノ\" ); ins( \"nya\", \"ニャ\" ); ins( \"nyu\", \"ニュ\" ); ins( \"nyo\", \"ニョ\" ); \n  ins( \"ha\", \"ハ\" ); ins( \"hi\", \"ヒ\" ); ins( \"fu\", \"フ\" ); ins( \"he\", \"ヘ\" ); ins( \"ho\", \"ホ\" ); ins( \"hya\", \"ヒャ\" ); ins( \"hyu\", \"ヒュ\" ); ins( \"hyo\", \"ヒョ\" ); \n  ins( \"ma\", \"マ\" ); ins( \"mi\", \"ミ\" ); ins( \"mu\", \"ム\" ); ins( \"me\", \"メ\" ); ins( \"mo\", \"モ\" ); ins( \"mya\", \"ミャ\" ); ins( \"myu\", \"ミュ\" ); ins( \"myo\", \"ミョ\" ); \n  ins( \"ya\", \"ヤ\" ); ins( \"yu\", \"ユ\" ); ins( \"yo\", \"ヨ\" ); \n  ins( \"ra\", \"ラ\" ); ins( \"ri\", \"リ\" ); ins( \"ru\", \"ル\" ); ins( \"re\", \"レ\" ); ins( \"ro\", \"ロ\" ); ins( \"rya\", \"リャ\" ); ins( \"ryu\", \"リュ\" ); ins( \"ryo\", \"リョ\" ); \n  ins( \"wa\", \"ワ\" ); /*ヰ wi† \t\tヱ we† \tヲ wo‡ \t*/\n  ins( \"n\", \"ン\" ); \n  ins( \"ga\", \"ガ\" ); ins( \"gi\", \"ギ\" ); ins( \"gu\", \"グ\" ); ins( \"ge\", \"ゲ\" ); ins( \"go\", \"ゴ\" ); ins( \"gya\", \"ギャ\" ); ins( \"gyu\", \"ギュ\" ); ins( \"gyo\", \"ギョ\" ); \n  ins( \"za\", \"ザ\" ); ins( \"ji\", \"ジ\" ); ins( \"zu\", \"ズ\" ); ins( \"ze\", \"ゼ\" ); ins( \"zo\", \"ゾ\" ); ins( \"ja\", \"ジャ\" ); ins( \"ju\", \"ジュ\" ); ins( \"jo\", \"ジョ\" ); \n  ins( \"da\", \"ダ\" ); ins( \"(ji)\", \"ヂ\" ); ins( \"(zu)\", \"ヅ\" ); ins( \"de\", \"デ\" ); ins( \"do\", \"ド\" ); ins( \"(ja)\", \"ヂャ\" ); ins( \"(ju)\", \"ヂュ\" ); ins( \"(jo)\", \"ヂョ\" ); \n  ins( \"ba\", \"バ\" ); ins( \"bi\", \"ビ\" ); ins( \"bu\", \"ブ\" ); ins( \"be\", \"ベ\" ); ins( \"bo\", \"ボ\" ); ins( \"bya\", \"ビャ\" ); ins( \"byu\", \"ビュ\" ); ins( \"byo\", \"ビョ\" ); \n  ins( \"pa\", \"パ\" ); ins( \"pi\", \"ピ\" ); ins( \"pu\", \"プ\" ); ins( \"pe\", \"ペ\" ); ins( \"po\", \"ポ\" ); ins( \"pya\", \"ピャ\" ); ins( \"pyu\", \"ピュ\" ); ins( \"pyo\", \"ピョ\" ); \n  ins( \"ye\", \"イェ\" ); \n  ins( \"wi\", \"ウィ\" ); ins( \"we\", \"ウェ\" ); ins( \"wo\", \"ウォ\" ); \n  ins( \"va\", \"ヷ\" ); /*ヸ vi† \t\tヹ ve†*/ ins( \"vo\", \"ヺ\" ); \n  ins( \"va\", \"ヴァ\" ); ins( \"vi\", \"ヴィ\" ); ins( \"vu\", \"ヴ\" ); ins( \"ve\", \"ヴェ\" ); ins( \"vo\", \"ヴォ\" ); \n  ins( \"she\", \"シェ\" ); \n  ins( \"je\", \"ジェ\" ); \n  ins( \"che\", \"チェ\" ); \n  ins( \"ti\", \"ティ\" ); ins( \"tu\", \"トゥ\" ); \n  ins( \"tyu\", \"テュ\" ); \n  ins( \"di\", \"ディ\" ); ins( \"du\", \"ドゥ\" ); \n  ins( \"dyu\", \"デュ\" ); \n  ins( \"tsa\", \"ツァ\" ); ins( \"tse\", \"ツェ\" ); ins( \"tso\", \"ツォ\" ); \n  ins( \"fa\", \"ファ\" ); ins( \"fi\", \"フィ\" ); ins( \"fe\", \"フェ\" ); ins( \"fo\", \"フォ\" ); \n  ins( \"fyu\", \"フュ\" ); \n  // Long vowel mark\n  ins( \"-\", \"ー\" );\n  // Double consonants\n\n  ins( \"kka\", \"ッカ\" ); ins( \"kki\", \"ッキ\" ); ins( \"kku\", \"ック\" ); ins( \"kke\", \"ッケ\" ); ins( \"kko\", \"ッコ\" ); ins( \"kkya\", \"ッキャ\" ); ins( \"kkyu\", \"ッキュ\" ); ins( \"kkyo\", \"ッキョ\" );\n  ins( \"ssa\", \"ッサ\" ); ins( \"sshi\", \"ッシ\" ); ins( \"ssu\", \"ッス\" ); ins( \"sse\", \"ッセ\" ); ins( \"sso\", \"ッソ\" ); ins( \"ssha\", \"ッシャ\" ); ins( \"sshu\", \"ッシュ\" ); ins( \"ssho\", \"ッショ\" );\n  ins( \"tta\", \"ッタ\" ); ins( \"tchi\", \"ッチ\" ); ins( \"ttsu\", \"ッツ\" ); ins( \"tte\", \"ッテ\" ); ins( \"tto\", \"ット\" ); ins( \"tcha\", \"ッチャ\" ); ins( \"tchu\", \"ッチュ\" ); ins( \"tcho\", \"ッチョ\" );\n  ins( \"ppa\", \"ッパ\" ); ins( \"ppi\", \"ッピ\" ); ins( \"ppu\", \"ップ\" ); ins( \"ppe\", \"ッペ\" ); ins( \"ppo\", \"ッポ\" ); ins( \"ppya\", \"ッピャ\" ); ins( \"ppyu\", \"ッピュ\" ); ins( \"ppyo\", \"ッピョ\" );\n}\n\nvector< sptr< Dictionary::Class > > makeDictionaries( Config::Romaji const & r )\n  THROW_SPEC( std::exception )\n{\n  vector< sptr< Dictionary::Class > > result;\n  \n  if ( r.enable )\n  {\n    if ( r.enableHepburn )\n    {\n      if ( r.enableHiragana )\n      {\n        static HepburnHiragana t;\n\n        result.push_back( new Transliteration::TransliterationDictionary( \"94eae5a5aaf5b0a900490f4d6b36aac0\",\n                            QCoreApplication::translate( \"Romaji\", \"Hepburn Romaji for Hiragana\" ).toUtf8().data(),\n                            QIcon( \":/flags/jp.png\" ), t, false ) );\n      }\n      \n      if ( r.enableKatakana )\n      {\n        static HepburnKatakana t;\n\n        result.push_back( new Transliteration::TransliterationDictionary( \"3252a35767d3f6e85e3e39069800dd2f\",\n                            QCoreApplication::translate( \"Romaji\", \"Hepburn Romaji for Katakana\" ).toUtf8().data(),\n                            QIcon( \":/flags/jp.png\" ), t, false ) );\n      }\n    }\n  }\n\n  return result;\n}\n\n}\n"
        },
        {
          "name": "romaji.hh",
          "type": "blob",
          "size": 0.4580078125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __ROMAJI_HH_INCLUDED__\n#define __ROMAJI_HH_INCLUDED__\n\n#include \"transliteration.hh\"\n#include \"config.hh\"\n\n/// Japanese romanization (Romaji) support.\nnamespace Romaji {\n\nusing std::vector;\n\nvector< sptr< Dictionary::Class > > makeDictionaries( Config::Romaji const & )\n  THROW_SPEC( std::exception );\n\n}\n\n#endif\n"
        },
        {
          "name": "russiantranslit.cc",
          "type": "blob",
          "size": 2.29296875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"russiantranslit.hh\"\n#include \"transliteration.hh\"\n#include <QCoreApplication>\n\nnamespace RussianTranslit {\n\nclass RussianTable: public Transliteration::Table\n{\npublic:\n\n  RussianTable();\n};\n\nRussianTable::RussianTable()\n{\n  // Utf8\n\n  // Lowercase\n  ins( \"a\", \"а\" );\n  ins( \"b\", \"б\" );\n  ins( \"v\", \"в\" );\n  ins( \"w\", \"в\" );\n  ins( \"g\", \"г\" );\n  ins( \"d\", \"д\" );\n  ins( \"e\", \"е\" );\n  ins( \"yo\", \"ё\" );\n  ins( \"zh\", \"ж\" );\n  ins( \"z\", \"з\" );\n  ins( \"i\", \"и\" );\n  ins( \"j\", \"й\" );\n  ins( \"k\", \"к\" );\n  ins( \"l\", \"л\" );\n  ins( \"m\", \"м\" );\n  ins( \"n\", \"н\" );\n  ins( \"o\", \"о\" );\n  ins( \"p\", \"п\" );\n  ins( \"r\", \"р\" );\n  ins( \"s\", \"с\" );\n  ins( \"t\", \"т\" );\n  ins( \"u\", \"у\" );\n  ins( \"f\", \"ф\" );\n  ins( \"h\", \"х\" );\n  ins( \"ts\", \"ц\" );\n  ins( \"c\", \"ц\" );\n  ins( \"ch\", \"ч\" );\n  ins( \"sh\", \"ш\" );\n  ins( \"shch\", \"щ\" );\n  ins( \"\\\"\", \"ъ\" );\n  ins( \"y\", \"ы\" );\n  ins( \"'\", \"ь\" );\n  ins( \"'e\", \"э\" );\n  ins( \"yu\", \"ю\" );\n  ins( \"ya\", \"я\" );\n\n  // Uppercase\n  ins( \"A\", \"А\" );\n  ins( \"B\", \"Б\" );\n  ins( \"V\", \"В\" );\n  ins( \"W\", \"В\" );\n  ins( \"G\", \"Г\" );\n  ins( \"D\", \"Д\" );\n  ins( \"E\", \"Е\" );\n  ins( \"YO\", \"Ё\" );\n  ins( \"Yo\", \"Ё\" );\n  ins( \"ZH\", \"Ж\" );\n  ins( \"Zh\", \"Ж\" );\n  ins( \"Z\", \"З\" );\n  ins( \"I\", \"И\" );\n  ins( \"J\", \"Й\" );\n  ins( \"K\", \"К\" );\n  ins( \"L\", \"Л\" );\n  ins( \"M\", \"М\" );\n  ins( \"N\", \"Н\" );\n  ins( \"O\", \"О\" );\n  ins( \"P\", \"П\" );\n  ins( \"R\", \"Р\" );\n  ins( \"S\", \"С\" );\n  ins( \"T\", \"Т\" );\n  ins( \"U\", \"У\" );\n  ins( \"F\", \"Ф\" );\n  ins( \"H\", \"Х\" );\n  ins( \"TS\", \"Ц\" );\n  ins( \"Ts\", \"Ц\" );\n  ins( \"C\", \"Ц\" );\n  ins( \"CH\", \"Ч\" );\n  ins( \"Ch\", \"Ч\" );\n  ins( \"SH\", \"Ш\" );\n  ins( \"Sh\", \"Ш\" );\n  ins( \"SHCH\", \"Щ\" );\n  ins( \"ShCh\", \"Щ\" );\n  ins( \"Y\", \"Ы\" );\n  ins( \"'E\", \"Э\" );\n  ins( \"YU\", \"Ю\" );\n  ins( \"Yu\", \"Ю\" );\n  ins( \"YA\", \"Я\" );\n  ins( \"Ya\", \"Я\" );\n}\n  \nsptr< Dictionary::Class > makeDictionary() THROW_SPEC( std::exception )\n{\n  static RussianTable t;\n\n  return new Transliteration::TransliterationDictionary( \"cf1b74acd98adea9b2bba16af38f1086\",\n                      QCoreApplication::translate( \"RussianTranslit\", \"Russian Transliteration\" ).toUtf8().data(),\n                      QIcon( \":/flags/ru.png\" ), t );\n}\n\n}\n\n"
        },
        {
          "name": "russiantranslit.hh",
          "type": "blob",
          "size": 0.3984375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __RUSSIANTRANSLIT_HH_INCLUDED__\n#define __RUSSIANTRANSLIT_HH_INCLUDED__\n\n#include \"dictionary.hh\"\n\n// Support for Russian transliteration\nnamespace RussianTranslit {\n\nsptr< Dictionary::Class > makeDictionary() THROW_SPEC( std::exception );\n\n}\n\n#endif\n\n"
        },
        {
          "name": "sapi.hh",
          "type": "blob",
          "size": 11.0390625,
          "content": "#ifndef __SAPI_HH_INCLUDED__\n#define __SAPI_HH_INCLUDED__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <windows.h>\n#include <oleacc.h>\n\n#undef INTERFACE\n\n#define SPCAT_VOICES  L\"HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Speech\\\\Voices\"\n\ntypedef void __stdcall SPNOTIFYCALLBACK( WPARAM wParam, LPARAM lParam );\n\ntypedef struct SPEVENTSOURCEINFO\n{\n  ULONGLONG ullEventInterest;\n  ULONGLONG ullQueuedInterest;\n  ULONG ulCount;\n} SPEVENTSOURCEINFO;\n\ntypedef enum SPEVENTENUM\n{\n  SPEI_UNDEFINED              = 0,\n  SPEI_START_INPUT_STREAM     = 1,\n  SPEI_END_INPUT_STREAM       = 2,\n  SPEI_VOICE_CHANGE           = 3,\n  SPEI_TTS_BOOKMARK           = 4,\n  SPEI_WORD_BOUNDARY          = 5,\n  SPEI_PHONEME                = 6,\n  SPEI_SENTENCE_BOUNDARY      = 7,\n  SPEI_VISEME                 = 8,\n  SPEI_TTS_AUDIO_LEVEL        = 9,\n  SPEI_TTS_PRIVATE            = 15,\n  SPEI_MIN_TTS                = 1,\n  SPEI_MAX_TTS                = 15,\n  SPEI_END_SR_STREAM          = 34,\n  SPEI_SOUND_START            = 35,\n  SPEI_SOUND_END              = 36,\n  SPEI_PHRASE_START           = 37,\n  SPEI_RECOGNITION            = 38,\n  SPEI_HYPOTHESIS             = 39,\n  SPEI_SR_BOOKMARK            = 40,\n  SPEI_PROPERTY_NUM_CHANGE    = 41,\n  SPEI_PROPERTY_STRING_CHANGE = 42,\n  SPEI_FALSE_RECOGNITION      = 43,\n  SPEI_INTERFERENCE           = 44,\n  SPEI_REQUEST_UI             = 45,\n  SPEI_RECO_STATE_CHANGE      = 46,\n  SPEI_ADAPTATION             = 47,\n  SPEI_START_SR_STREAM        = 48,\n  SPEI_RECO_OTHER_CONTEXT     = 49,\n  SPEI_SR_AUDIO_LEVEL         = 50,\n  SPEI_SR_RETAINEDAUDIO       = 51,\n  SPEI_SR_PRIVATE             = 52,\n  SPEI_RESERVED4              = 53,\n  SPEI_RESERVED5              = 54,\n  SPEI_RESERVED6              = 55,\n  SPEI_MIN_SR                 = 34,\n  SPEI_MAX_SR                 = 55,\n  SPEI_RESERVED1              = 30,\n  SPEI_RESERVED2              = 33,\n  SPEI_RESERVED3              = 63\n} SPEVENTENUM;\n\ntypedef enum SPEVENTLPARAMTYPE\n{\n  SPET_LPARAM_IS_UNDEFINED  = 0,\n  SPET_LPARAM_IS_TOKEN      = ( SPET_LPARAM_IS_UNDEFINED + 1 ) ,\n  SPET_LPARAM_IS_OBJECT     = ( SPET_LPARAM_IS_TOKEN + 1 ) ,\n  SPET_LPARAM_IS_POINTER    = ( SPET_LPARAM_IS_OBJECT + 1 ) ,\n  SPET_LPARAM_IS_STRING     = ( SPET_LPARAM_IS_POINTER + 1 )\n} SPEVENTLPARAMTYPE;\n\ntypedef struct SPEVENT\n{\n  SPEVENTENUM        eEventId : 16;\n  SPEVENTLPARAMTYPE  elParamType : 16;\n  ULONG              ulStreamNum;\n  ULONGLONG          ullAudioStreamOffset;\n  WPARAM             wParam;\n  LPARAM             lParam;\n} SPEVENT;\n\ntypedef WCHAR SPPHONEID;\n\ntypedef enum SPVISEMES\n{\n  SP_VISEME_0   = 0,\n  SP_VISEME_1   = ( SP_VISEME_0 + 1 ) ,\n  SP_VISEME_2   = ( SP_VISEME_1 + 1 ) ,\n  SP_VISEME_3   = ( SP_VISEME_2 + 1 ) ,\n  SP_VISEME_4   = ( SP_VISEME_3 + 1 ) ,\n  SP_VISEME_5   = ( SP_VISEME_4 + 1 ) ,\n  SP_VISEME_6   = ( SP_VISEME_5 + 1 ) ,\n  SP_VISEME_7   = ( SP_VISEME_6 + 1 ) ,\n  SP_VISEME_8   = ( SP_VISEME_7 + 1 ) ,\n  SP_VISEME_9   = ( SP_VISEME_8 + 1 ) ,\n  SP_VISEME_10  = ( SP_VISEME_9 + 1 ) ,\n  SP_VISEME_11  = ( SP_VISEME_10 + 1 ) ,\n  SP_VISEME_12  = ( SP_VISEME_11 + 1 ) ,\n  SP_VISEME_13  = ( SP_VISEME_12 + 1 ) ,\n  SP_VISEME_14  = ( SP_VISEME_13 + 1 ) ,\n  SP_VISEME_15  = ( SP_VISEME_14 + 1 ) ,\n  SP_VISEME_16  = ( SP_VISEME_15 + 1 ) ,\n  SP_VISEME_17  = ( SP_VISEME_16 + 1 ) ,\n  SP_VISEME_18  = ( SP_VISEME_17 + 1 ) ,\n  SP_VISEME_19  = ( SP_VISEME_18 + 1 ) ,\n  SP_VISEME_20  = ( SP_VISEME_19 + 1 ) ,\n  SP_VISEME_21  = ( SP_VISEME_20 + 1 )\n} SPVISEMES;\n\ntypedef enum SPDATAKEYLOCATION\n{\n  SPDKL_DefaultLocation = 0,\n  SPDKL_CurrentUser     = 1,\n  SPDKL_LocalMachine    = 2,\n  SPDKL_CurrentConfig   = 5\n} SPDATAKEYLOCATION;\n\ntypedef struct SPVOICESTATUS\n{\n  ULONG ulCurrentStream;\n  ULONG ulLastStreamQueued;\n  HRESULT hrLastResult;\n  DWORD dwRunningState;\n  ULONG ulInputWordPos;\n  ULONG ulInputWordLen;\n  ULONG ulInputSentPos;\n  ULONG ulInputSentLen;\n  LONG lBookmarkId;\n  SPPHONEID PhonemeId;\n  SPVISEMES VisemeId;\n  DWORD dwReserved1;\n  DWORD dwReserved2;\n} SPVOICESTATUS;\n\ntypedef enum SPVPRIORITY\n{\n  SPVPRI_NORMAL = 0,\n  SPVPRI_ALERT  = ( 1L << 0 ) ,\n  SPVPRI_OVER   = ( 1L << 1 )\n} SPVPRIORITY;\n\ntypedef enum SPEAKFLAGS\n{\n  SPF_DEFAULT           = 0,\n  SPF_ASYNC             = ( 1L << 0 ) ,\n  SPF_PURGEBEFORESPEAK  = ( 1L << 1 ) ,\n  SPF_IS_FILENAME       = ( 1L << 2 ) ,\n  SPF_IS_XML            = ( 1L << 3 ) ,\n  SPF_IS_NOT_XML        = ( 1L << 4 ) ,\n  SPF_PERSIST_XML       = ( 1L << 5 ) ,\n  SPF_NLP_SPEAK_PUNC    = ( 1L << 6 ) ,\n  SPF_PARSE_SAPI        = ( 1L << 7 ) ,\n  SPF_PARSE_SSML        = ( 1L << 8 ) ,\n  SPF_PARSE_AUTODETECT  = 0,\n  SPF_NLP_MASK          = SPF_NLP_SPEAK_PUNC,\n  SPF_PARSE_MASK        = ( SPF_PARSE_SAPI | SPF_PARSE_SSML ) ,\n  SPF_VOICE_MASK        = ( ( ( ( ( ( ( SPF_ASYNC | SPF_PURGEBEFORESPEAK )  | SPF_IS_FILENAME )  | SPF_IS_XML )  | SPF_IS_NOT_XML )  | SPF_NLP_MASK )  | SPF_PERSIST_XML )  | SPF_PARSE_MASK ) ,\n  SPF_UNUSED_FLAGS      = ~SPF_VOICE_MASK\n} SPEAKFLAGS;\n\ntypedef enum SPRUNSTATE\n{\n  SPRS_DONE         = ( 1L << 0 ) ,\n  SPRS_IS_SPEAKING  = ( 1L << 1 )\n} SPRUNSTATE;\n\nEXTERN_C const IID CLSID_SpVoice;\nEXTERN_C const IID IID_ISpVoice;\nEXTERN_C const IID IID_ISpObjectToken;\nEXTERN_C const IID CLSID_SpObjectToken;\nEXTERN_C const IID IID_IEnumSpObjectTokens;\nEXTERN_C const IID IID_ISpEventSource;\nEXTERN_C const IID IID_ISpNotifySource;\nEXTERN_C const IID IID_ISpNotifySink;\nEXTERN_C const IID IID_ISpObjectTokenCategory;\nEXTERN_C const IID CLSID_SpObjectTokenCategory;\n\ntypedef interface ISpVoice ISpVoice;\ntypedef interface ISpObjectToken ISpObjectToken;\ntypedef interface ISpObjectTokenCategory ISpObjectTokenCategory;\ntypedef interface IEnumSpObjectTokens IEnumSpObjectTokens;\ntypedef interface ISpEventSource ISpEventSource;\ntypedef interface ISpNotifySource ISpNotifySource;\ntypedef interface ISpNotifySink ISpNotifySink;\ntypedef interface ISpNotifyCallback ISpNotifyCallback;\ntypedef interface ISpDataKey ISpDataKey;\ntypedef interface ISpStreamFormat ISpStreamFormat;\n\n#define INTERFACE ISpNotifyCallback\nDECLARE_INTERFACE( ISpNotifyCallback )\n{\n  STDMETHOD( NotifyCallback )( THIS_ WPARAM, LPARAM ) PURE;\n};\n#undef INTERFACE\n\n#define INTERFACE ISpNotifySink\nDECLARE_INTERFACE_(ISpNotifySink, IUnknown )\n{\n  STDMETHOD(Notify)( THIS) PURE;\n};\n#undef INTERFACE\n\n#define INTERFACE ISpNotifySource\nDECLARE_INTERFACE_(ISpNotifySource, IUnknown )\n{\n  STDMETHOD( SetNotifySink )( THIS_ ISpNotifySink * ) PURE;\n  STDMETHOD( SetNotifyWindowMessage )( THIS_ HWND, UINT, WPARAM, LPARAM ) PURE;\n  STDMETHOD( SetNotifyCallbackFunction )( THIS_ SPNOTIFYCALLBACK ) PURE;\n  STDMETHOD( SetNotifyCallbackInterface )( THIS_ ISpNotifyCallback *, WPARAM, LPARAM ) PURE;\n  STDMETHOD( SetNotifyWin32Event )( THIS) PURE;\n  STDMETHOD( WaitForNotifyEvent )( THIS_ DWORD ) PURE;\n  STDMETHOD( GetNotifyEventHandle )( THIS_ DWORD ) PURE;\n};\n#undef INTERFACE\n\n#define INTERFACE ISpDataKey\nDECLARE_INTERFACE_( ISpDataKey, IUnknown )\n{\n  STDMETHOD( SetData )( THIS_ LPCWSTR, ULONG, const BYTE * ) PURE;\n  STDMETHOD( GetData )( THIS_ LPCWSTR, ULONG *, const BYTE * ) PURE;\n  STDMETHOD( SetStringValue )( THIS_ LPCWSTR, LPCWSTR ) PURE;\n  STDMETHOD( GetStringValue )( THIS_ LPCWSTR, LPWSTR * ) PURE;\n  STDMETHOD( SetDWORD )( THIS_ LPCWSTR, DWORD ) PURE;\n  STDMETHOD( GetDWORD )( THIS_ LPCWSTR, DWORD * ) PURE;\n  STDMETHOD( OpenKey )( THIS_ LPCWSTR, ISpDataKey * * ) PURE;\n  STDMETHOD( CreateKey )( THIS_ LPCWSTR, ISpDataKey * * ) PURE;\n  STDMETHOD( DeleteKey )( THIS_ LPCWSTR ) PURE;\n  STDMETHOD( DeleteValue )( THIS_ LPCWSTR ) PURE;\n  STDMETHOD( EnumKeys )( THIS_ ULONG, LPWSTR * ) PURE;\n  STDMETHOD( EnumValues )( THIS_ ULONG, LPWSTR * ) PURE;\n};\n#undef INTERFACE\n\n#define INTERFACE ISpEventSource\nDECLARE_INTERFACE_( ISpEventSource, ISpNotifySource )\n{\n  STDMETHOD( SetInterest )( THIS_ ULONGLONG, ULONGLONG ) PURE;\n  STDMETHOD( GetEvents )( THIS_ ULONG, SPEVENT *, ULONG ) PURE;\n  STDMETHOD( GetInfo )( THIS_ SPEVENTSOURCEINFO * ) PURE;\n};\n#undef INTERFACE\n\n#define INTERFACE IEnumSpObjectTokens\nDECLARE_INTERFACE_( IEnumSpObjectTokens, IUnknown )\n{\n  STDMETHOD( Next )( THIS_ ULONG, ISpObjectToken * *, ULONG * ) PURE;\n  STDMETHOD( Skip )( THIS_ ULONG ) PURE;\n  STDMETHOD( Reset )( THIS ) PURE;\n  STDMETHOD( Clone )( THIS_ IEnumSpObjectTokens * * ) PURE;\n  STDMETHOD( Item )( THIS_ ULONG, ISpObjectToken * * ) PURE;\n  STDMETHOD( GetCount )( THIS_ ULONG * ) PURE;\n};\n#undef INTERFACE\n\n#define INTERFACE ISpObjectToken\nDECLARE_INTERFACE_( ISpObjectToken, ISpDataKey )\n{\n  STDMETHOD( SetId )( THIS_ LPCWSTR, LPCWSTR, BOOL ) PURE;\n  STDMETHOD( GetId )( THIS_ LPWSTR * ) PURE;\n  STDMETHOD( GetCategory )( THIS_ ISpObjectTokenCategory * * ) PURE;\n  STDMETHOD( CreateInstance )( THIS_ IUnknown *, DWORD, REFIID, void * * ) PURE;\n  STDMETHOD( GetStorageFileName )( THIS_ REFCLSID, LPCWSTR, LPCWSTR, ULONG, LPWSTR * ) PURE;\n  STDMETHOD( RemoveStorageFileName )( THIS_ REFCLSID, LPCWSTR, BOOL ) PURE;\n  STDMETHOD( Remove )( THIS_ const CLSID * ) PURE;\n  STDMETHOD( IsUISupported )( THIS_ LPCWSTR, void *, ULONG, IUnknown *, BOOL * ) PURE;\n  STDMETHOD( DisplayUI )( THIS_ HWND, LPCWSTR, LPCWSTR, void *, ULONG, IUnknown * ) PURE;\n  STDMETHOD( MatchesAttributes )( THIS_ LPCWSTR, BOOL * ) PURE;\n};\n#undef INTERFACE\n\n#define INTERFACE ISpObjectTokenCategory\nDECLARE_INTERFACE_(ISpObjectTokenCategory, ISpDataKey)\n{\n  STDMETHOD(SetId)( THIS_ LPCWSTR, BOOL) PURE;\n  STDMETHOD(GetId)( THIS_ LPWSTR *) PURE;\n  STDMETHOD(GetDataKey)( THIS_ SPDATAKEYLOCATION, ISpDataKey * *) PURE;\n  STDMETHOD(EnumTokens)( THIS_ LPCWSTR, LPCWSTR, IEnumSpObjectTokens * *) PURE;\n  STDMETHOD(SetDefaultTokenId)( THIS_ LPCWSTR) PURE;\n  STDMETHOD(GetDefaultTokenId)( THIS_ LPWSTR *) PURE;\n};\n#undef INTERFACE\n\n#define INTERFACE ISpStreamFormat\nDECLARE_INTERFACE_( ISpStreamFormat, IStream )\n{\n  STDMETHOD( GetFormat )( THIS_ GUID *, WAVEFORMATEX * * ) PURE;\n};\n#undef INTERFACE\n\n#define INTERFACE ISpVoice\nDECLARE_INTERFACE_( ISpVoice, ISpEventSource )\n{\n  STDMETHOD( SetOutput )( THIS_ IUnknown *, BOOL ) PURE;\n  STDMETHOD( GetOutputObjectToken )( THIS_ ISpObjectToken * * ) PURE;\n  STDMETHOD( GetOutputStream )( THIS_ ISpStreamFormat * * ) PURE;\n  STDMETHOD( Pause )( THIS ) PURE;\n  STDMETHOD( Resume )( THIS ) PURE;\n  STDMETHOD( SetVoice )( THIS_ ISpObjectToken * ) PURE;\n  STDMETHOD( GetVoice )( THIS_ ISpObjectToken * * ) PURE;\n  STDMETHOD( Speak )( THIS_ LPCWSTR, DWORD, ULONG * ) PURE;\n  STDMETHOD( SpeakStream )( THIS_ IStream *, DWORD, ULONG * ) PURE;\n  STDMETHOD( GetStatus )( THIS_ SPVOICESTATUS *, LPWSTR * ) PURE;\n  STDMETHOD( Skip )( THIS_ LPCWSTR, long, ULONG * ) PURE;\n  STDMETHOD( SetPriority )( THIS_ SPVPRIORITY ) PURE;\n  STDMETHOD( GetPriority )( THIS_ SPVPRIORITY * ) PURE;\n  STDMETHOD( SetAlertBoundary )( THIS_ SPEVENTENUM ) PURE;\n  STDMETHOD( GetAlertBoundary )( THIS_ SPEVENTENUM * ) PURE;\n  STDMETHOD( SetRate )( THIS_ long ) PURE;\n  STDMETHOD( GetRate )( THIS_ long * ) PURE;\n  STDMETHOD( SetVolume )( THIS_ USHORT ) PURE;\n  STDMETHOD( GetVolume )( THIS_ USHORT * ) PURE;\n  STDMETHOD( WaitUntilDone )( THIS_ ULONG ) PURE;\n  STDMETHOD( SetSyncSpeakTimeout )( THIS_ ULONG ) PURE;\n  STDMETHOD( GetSyncSpeakTimeout )( THIS_ ULONG * ) PURE;\n  STDMETHOD( SpeakCompleteEvent )( THIS ) PURE;\n  STDMETHOD( IsUISupported )( THIS_ LPCWSTR, void *, ULONG, BOOL * ) PURE;\n  STDMETHOD( DisplayUI )( THIS_ HWND, LPCWSTR, LPCWSTR, LPCWSTR, void *, ULONG ) PURE;\n};\n#undef INTERFACE\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "scanflag.cc",
          "type": "blob",
          "size": 2.109375,
          "content": "#include <QCursor>\n#include <QDesktopWidget>\n\n#include \"scanflag.hh\"\n#include \"ui_scanflag.h\"\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 11, 0 )\n#include <QScreen>\n#endif\n\nstatic Qt::WindowFlags popupWindowFlags =\n\nQt::ToolTip | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint\n#if QT_VERSION >= 0x050000\n | Qt::WindowDoesNotAcceptFocus\n#endif\n;\n\nScanFlag::ScanFlag(QWidget *parent) :\n    QMainWindow(parent)\n{\n  ui.setupUi( this );\n\n  setWindowFlags( popupWindowFlags );\n\n  setAttribute(Qt::WA_X11DoNotAcceptFocus);\n\n  hideTimer.setSingleShot( true );\n  hideTimer.setInterval( 1500 );\n\n  connect( &hideTimer, SIGNAL( timeout() ),\n    this, SLOT( hideWindow() ) );\n\n  connect( ui.pushButton, SIGNAL( clicked( bool ) ),\n                this, SLOT( pushButtonClicked() ) );\n}\n\nScanFlag::~ScanFlag()\n{\n}\n\nvoid ScanFlag::pushButtonClicked()\n{\n  hideTimer.stop();\n  hide();\n  emit showScanPopup();\n}\n\nvoid ScanFlag::hideWindow()\n{\n  if ( isVisible() )\n    hide();\n}\n\nvoid ScanFlag::showScanFlag()\n{\n  if ( isVisible() )\n    hide();\n\n  QPoint currentPos = QCursor::pos();\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 11, 0 )\n  QRect const desktop = QGuiApplication::screenAt( currentPos )->geometry();\n#else\n  QRect const desktop = QApplication::desktop()->screenGeometry();\n#endif\n\n  QSize windowSize = geometry().size();\n\n  int x, y;\n\n  /// Try the to-the-right placement\n  if ( currentPos.x() + 4 + windowSize.width() <= desktop.topRight().x() )\n    x = currentPos.x() + 4;\n  else\n  /// Try the to-the-left placement\n  if ( currentPos.x() - 4 - windowSize.width() >= desktop.x() )\n    x = currentPos.x() - 4 - windowSize.width();\n  else\n  // Center it\n    x = desktop.x() + ( desktop.width() - windowSize.width() ) / 2;\n\n  /// Try the to-the-top placement\n  if ( currentPos.y() - 15 - windowSize.height() >= desktop.y() )\n    y = currentPos.y() - 15 - windowSize.height();\n  else\n  /// Try the to-the-bottom placement\n  if ( currentPos.y() + 15 + windowSize.height() <= desktop.bottomLeft().y() )\n    y = currentPos.y() + 15;\n  else\n  // Center it\n    y = desktop.y() + ( desktop.height() - windowSize.height() ) / 2;\n\n  move( x, y );\n\n  show();\n  hideTimer.start();\n}\n"
        },
        {
          "name": "scanflag.hh",
          "type": "blob",
          "size": 0.423828125,
          "content": "#ifndef SCAN_FLAG_H\n#define SCAN_FLAG_H\n\n\n#include \"config.hh\"\n#include <QMainWindow>\n#include <QTimer>\n#include \"ui_scanflag.h\"\n\nclass ScanFlag : public QMainWindow\n{\n  Q_OBJECT\n\npublic:\n  ScanFlag( QWidget *parent );\n\n  ~ScanFlag();\n\nsignals:\n  void showScanPopup ();\n\nprivate:\n  Ui::ScanFlag ui;\n  QTimer hideTimer;\n\nprivate slots:\n  void showScanFlag();\n  void pushButtonClicked();\n  void hideWindow();\n\n};\n\n#endif // SCAN_FLAG_H\n"
        },
        {
          "name": "scanflag.ui",
          "type": "blob",
          "size": 0.8447265625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ui version=\"4.0\">\n <class>ScanFlag</class>\n <widget class=\"QMainWindow\" name=\"ScanFlag\">\n  <property name=\"geometry\">\n   <rect>\n    <x>0</x>\n    <y>0</y>\n    <width>30</width>\n    <height>30</height>\n   </rect>\n  </property>\n  <property name=\"windowTitle\">\n   <string>MainWindow</string>\n  </property>\n  <widget class=\"QWidget\" name=\"centralwidget\">\n   <widget class=\"QPushButton\" name=\"pushButton\">\n    <property name=\"geometry\">\n     <rect>\n      <x>0</x>\n      <y>0</y>\n      <width>30</width>\n      <height>30</height>\n     </rect>\n    </property>\n    <property name=\"text\">\n     <string/>\n    </property>\n    <property name=\"icon\">\n     <iconset>\n     <normaloff>:/icons/programicon.png</normaloff>:/icons/programicon.png</iconset>\n    </property>\n   </widget>\n  </widget>\n </widget>\n <resources/>\n <connections/>\n</ui>\n"
        },
        {
          "name": "scanpopup.cc",
          "type": "blob",
          "size": 37.478515625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"scanpopup.hh\"\n#include \"folding.hh\"\n#include <QCursor>\n#include <QPixmap>\n#include <QBitmap>\n#include <QMenu>\n#include <QMouseEvent>\n#include <QDesktopWidget>\n#include \"gddebug.hh\"\n#include \"gestures.hh\"\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 11, 0 )\n#include <QScreen>\n#endif\n\n#ifdef Q_OS_MAC\n#include \"macmouseover.hh\"\n#define MouseOver MacMouseOver\n#else\n#include \"mouseover.hh\"\n#endif\n\nusing std::wstring;\n\n/// We use different window flags under Windows and X11 due to slight differences\n/// in their behavior on those platforms.\nstatic const Qt::WindowFlags defaultUnpinnedWindowFlags =\n\n#if defined (Q_OS_WIN) || ( defined (Q_OS_MAC) && QT_VERSION < QT_VERSION_CHECK( 5, 3, 0 ) )\nQt::Tool | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint\n#else\nQt::Popup\n#endif\n;\n\nstatic const Qt::WindowFlags pinnedWindowFlags =\n#ifdef HAVE_X11\n/// With the Qt::Dialog flag, scan popup is always on top of the main window\n/// on Linux/X11 with Qt 4, Qt 5 since version 5.12.1 (QTBUG-74309).\n/// Qt::Window allows to use the scan popup and the main window independently.\nQt::Window\n#else\nQt::Dialog\n#endif\n;\n\n#ifdef HAVE_X11\nstatic bool ownsClipboardMode( QClipboard::Mode mode )\n{\n  const QClipboard & clipboard = *QApplication::clipboard();\n  switch( mode )\n  {\n    case QClipboard::Clipboard:\n      return clipboard.ownsClipboard();\n    case QClipboard::Selection:\n      return clipboard.ownsSelection();\n    case QClipboard::FindBuffer:\n      return clipboard.ownsFindBuffer();\n  }\n\n  gdWarning( \"Unknown clipboard mode: %d\\n\", static_cast< int >( mode ) );\n  return false;\n}\n#endif\n\nScanPopup::ScanPopup( QWidget * parent,\n                      Config::Class & cfg_,\n                      ArticleNetworkAccessManager & articleNetMgr,\n                      AudioPlayerPtr const & audioPlayer_,\n                      std::vector< sptr< Dictionary::Class > > const & allDictionaries_,\n                      Instances::Groups const & groups_,\n                      History & history_ ):\n  QMainWindow( parent ),\n  cfg( cfg_ ),\n  isScanningEnabled( false ),\n  allDictionaries( allDictionaries_ ),\n  groups( groups_ ),\n  history( history_ ),\n  escapeAction( this ),\n  switchExpandModeAction( this ),\n  focusTranslateLineAction( this ),\n  openSearchAction( this ),\n  wordFinder( this ),\n  dictionaryBar( this, configEvents, cfg.editDictionaryCommandLine, cfg.preferences.maxDictionaryRefsInContextMenu ),\n  mouseEnteredOnce( false ),\n  mouseIntercepted( false ),\n  hideTimer( this ),\n  starIcon( \":/icons/star.png\" ),\n  blueStarIcon( \":/icons/star_blue.png\" )\n{\n  ui.setupUi( this );\n\n  openSearchAction.setShortcut( QKeySequence( \"Ctrl+F\" ) );\n\n  if( layoutDirection() == Qt::RightToLeft )\n  {\n    // Adjust button icons for Right-To-Left layout\n    ui.goBackButton->setIcon( QIcon( \":/icons/next.png\" ) );\n    ui.goForwardButton->setIcon( QIcon( \":/icons/previous.png\" ) );\n  }\n\n  mainStatusBar = new MainStatusBar( this );\n\n  ui.queryError->hide();\n\n  definition = new ArticleView( ui.outerFrame, articleNetMgr, audioPlayer_,\n                                allDictionaries, groups, true, cfg,\n                                openSearchAction,\n                                dictionaryBar.toggleViewAction()\n                                );\n\n  connect( this, SIGNAL(switchExpandMode() ),\n           definition, SLOT( switchExpandOptionalParts() ) );\n  connect( this, SIGNAL(setViewExpandMode( bool ) ),\n           definition, SLOT( receiveExpandOptionalParts( bool ) ) );\n  connect( definition, SIGNAL( setExpandMode( bool ) ),\n           this, SIGNAL( setExpandMode( bool ) ) );\n  connect( definition, SIGNAL( forceAddWordToHistory( QString ) ),\n           this, SIGNAL( forceAddWordToHistory( QString ) ) );\n  connect( this, SIGNAL( closeMenu() ),\n           definition, SIGNAL( closePopupMenu() ) );\n  connect( definition, SIGNAL( sendWordToHistory( QString ) ),\n           this, SIGNAL( sendWordToHistory( QString ) ) );\n  connect( definition, SIGNAL( typingEvent( QString const & ) ),\n           this, SLOT( typingEvent( QString const & ) ) );\n\n  wordListDefaultFont = ui.translateBox->wordList()->font();\n  translateLineDefaultFont = ui.translateBox->font();\n  groupListDefaultFont = ui.groupList->font();\n\n  ui.mainLayout->addWidget( definition );\n\n  ui.translateBox->wordList()->attachFinder( &wordFinder );\n  ui.translateBox->wordList()->setFocusPolicy(Qt::ClickFocus);\n  ui.translateBox->translateLine()->installEventFilter( this );\n\n  connect( ui.translateBox->translateLine(), SIGNAL( textChanged( QString const & ) ),\n           this, SLOT( translateInputChanged( QString const & ) ) );\n\n  connect( ui.translateBox->translateLine(), SIGNAL( returnPressed() ),\n           this, SLOT( translateInputFinished() ) );\n\n  connect( ui.translateBox->wordList(), SIGNAL( itemClicked( QListWidgetItem * ) ),\n           this, SLOT( wordListItemActivated( QListWidgetItem * ) ) );\n\n  connect( ui.translateBox->wordList(), SIGNAL( itemDoubleClicked ( QListWidgetItem * ) ),\n           this, SLOT( wordListItemActivated( QListWidgetItem * ) ) );\n\n  connect( ui.translateBox->wordList(), SIGNAL( statusBarMessage( QString const &, int, QPixmap const & ) ),\n           this, SLOT( showStatusBarMessage( QString const &, int, QPixmap const & ) ) );\n\n  ui.pronounceButton->hide();\n\n  ui.groupList->fill( groups );\n  ui.groupList->setCurrentGroup( cfg.lastPopupGroupId );\n\n  dictionaryBar.setFloatable( false );\n\n  Instances::Group const * igrp = groups.findGroup( cfg.lastPopupGroupId );\n  if( cfg.lastPopupGroupId == Instances::Group::AllGroupId )\n  {\n    if( igrp )\n      igrp->checkMutedDictionaries( &cfg.popupMutedDictionaries );\n    dictionaryBar.setMutedDictionaries( &cfg.popupMutedDictionaries );\n  }\n  else\n  {\n    Config::Group * grp = cfg.getGroup( cfg.lastPopupGroupId );\n    if( igrp && grp )\n      igrp->checkMutedDictionaries( &grp->popupMutedDictionaries );\n    dictionaryBar.setMutedDictionaries( grp ? &grp->popupMutedDictionaries : 0 );\n  }\n\n  addToolBar( Qt::RightToolBarArea, &dictionaryBar );\n\n  connect( &dictionaryBar, SIGNAL(editGroupRequested()),\n           this, SLOT(editGroupRequested()) );\n  connect( this, SIGNAL( closeMenu() ),\n           &dictionaryBar, SIGNAL( closePopupMenu() ) );\n  connect( &dictionaryBar, SIGNAL( showDictionaryInfo( QString const & ) ),\n           this, SIGNAL( showDictionaryInfo( QString const & ) ) );\n  connect( &dictionaryBar, SIGNAL( openDictionaryFolder( QString const & ) ),\n           this, SIGNAL( openDictionaryFolder( QString const & ) ) );\n\n  pinnedGeometry = cfg.popupWindowGeometry;\n  if ( cfg.popupWindowGeometry.size() )\n    restoreGeometry( cfg.popupWindowGeometry );\n\n  if ( cfg.popupWindowState.size() )\n    restoreState( cfg.popupWindowState, 1 );\n\n  ui.onTopButton->setChecked( cfg.popupWindowAlwaysOnTop );\n  ui.onTopButton->setVisible( cfg.pinPopupWindow );\n  connect( ui.onTopButton, SIGNAL( clicked( bool ) ), this, SLOT( alwaysOnTopClicked( bool ) ) );\n\n  ui.pinButton->setChecked( cfg.pinPopupWindow );\n\n  if ( cfg.pinPopupWindow )\n  {\n    dictionaryBar.setMovable( true );\n    Qt::WindowFlags flags = pinnedWindowFlags;\n    if( cfg.popupWindowAlwaysOnTop )\n      flags |= Qt::WindowStaysOnTopHint;\n    setWindowFlags( flags );\n  }\n  else\n  {\n    dictionaryBar.setMovable( false );\n    setWindowFlags( unpinnedWindowFlags() );\n  }\n\n  connect( &configEvents, SIGNAL( mutedDictionariesChanged() ),\n           this, SLOT( mutedDictionariesChanged() ) );\n\n  definition->focus();\n\n  #if 0 // Experimental code to give window a non-rectangular shape (i.e.\n        // balloon) using a colorkey mask.\n  QPixmap pixMask( size() );\n  render( &pixMask );\n\n  setMask( pixMask.createMaskFromColor( QColor( 255, 0, 0 ) ) );\n\n  // This helps against flickering\n  setAttribute( Qt::WA_NoSystemBackground );\n  #endif\n\n  escapeAction.setShortcut( QKeySequence( \"Esc\" ) );\n  addAction( &escapeAction );\n  connect( &escapeAction, SIGNAL( triggered() ),\n           this, SLOT( escapePressed() ) );\n\n  focusTranslateLineAction.setShortcutContext( Qt::WidgetWithChildrenShortcut );\n  addAction( &focusTranslateLineAction );\n  focusTranslateLineAction.setShortcuts( QList< QKeySequence >() <<\n                                         QKeySequence( \"Alt+D\" ) <<\n                                         QKeySequence( \"Ctrl+L\" ) );\n\n  connect( &focusTranslateLineAction, SIGNAL( triggered() ),\n           this, SLOT( focusTranslateLine() ) );\n\n  QAction * const focusArticleViewAction = new QAction( this );\n  focusArticleViewAction->setShortcutContext( Qt::WidgetWithChildrenShortcut );\n  focusArticleViewAction->setShortcut( QKeySequence( \"Ctrl+N\" ) );\n  addAction( focusArticleViewAction );\n  connect( focusArticleViewAction, SIGNAL( triggered() ), definition, SLOT( focus() ) );\n\n  switchExpandModeAction.setShortcuts( QList< QKeySequence >() <<\n                                       QKeySequence( Qt::CTRL + Qt::Key_8 ) <<\n                                       QKeySequence( Qt::CTRL + Qt::Key_Asterisk ) <<\n                                       QKeySequence( Qt::CTRL + Qt::SHIFT + Qt::Key_8 ) );\n\n  addAction( &switchExpandModeAction );\n  connect( &switchExpandModeAction, SIGNAL( triggered() ),\n           this, SLOT(switchExpandOptionalPartsMode() ) );\n\n  connect( ui.groupList, SIGNAL( currentIndexChanged( QString const & ) ),\n           this, SLOT( currentGroupChanged( QString const & ) ) );\n\n  connect( &wordFinder, SIGNAL( finished() ),\n           this, SLOT( prefixMatchFinished() ) );\n\n  connect( ui.pinButton, SIGNAL( clicked( bool ) ),\n           this, SLOT( pinButtonClicked( bool ) ) );\n\n  connect( definition, SIGNAL( pageLoaded( ArticleView * ) ),\n           this, SLOT( pageLoaded( ArticleView * ) ) );\n\n  connect( definition, SIGNAL( statusBarMessage( QString const &, int, QPixmap const & ) ),\n           this, SLOT( showStatusBarMessage( QString const &, int, QPixmap const & ) ) );\n\n  connect( definition, SIGNAL( titleChanged(  ArticleView *, QString const & ) ),\n           this, SLOT( titleChanged(  ArticleView *, QString const & ) ) );\n\n#ifdef HAVE_X11\n  connect( QApplication::clipboard(), SIGNAL( changed( QClipboard::Mode ) ),\n           this, SLOT( clipboardChanged( QClipboard::Mode ) ) );\n#else\n  if( cfg.preferences.trackClipboardChanges )\n    connect( QApplication::clipboard(), SIGNAL( changed( QClipboard::Mode ) ),\n             this, SLOT( clipboardChanged( QClipboard::Mode ) ) );\n#endif\n\n  connect( &MouseOver::instance(), SIGNAL( hovered( QString const &, bool ) ),\n           this, SLOT( mouseHovered( QString const &, bool ) ) );\n\n#ifdef Q_OS_WIN32\n  connect( &MouseOver::instance(), SIGNAL( isGoldenDictWindow( HWND ) ),\n           this, SIGNAL( isGoldenDictWindow( HWND ) ) );\n#endif\n\n  hideTimer.setSingleShot( true );\n  hideTimer.setInterval( 400 );\n\n  connect( &hideTimer, SIGNAL( timeout() ),\n           this, SLOT( hideTimerExpired() ) );\n\n  altModeExpirationTimer.setSingleShot( true );\n  altModeExpirationTimer.setInterval( cfg.preferences.scanPopupAltModeSecs * 1000 );\n\n  connect( &altModeExpirationTimer, SIGNAL( timeout() ),\n           this, SLOT( altModeExpired() ) );\n\n  // This one polls constantly for modifiers while alt mode lasts\n  altModePollingTimer.setSingleShot( false );\n  altModePollingTimer.setInterval( 50 );\n  connect( &altModePollingTimer, SIGNAL( timeout() ),\n           this, SLOT( altModePoll() ) );\n\n  mouseGrabPollTimer.setSingleShot( false );\n  mouseGrabPollTimer.setInterval( 10 );\n  connect( &mouseGrabPollTimer, SIGNAL( timeout() ),\n           this, SLOT(mouseGrabPoll())  );\n\n  MouseOver::instance().setPreferencesPtr( &( cfg.preferences ) );\n\n  ui.goBackButton->setEnabled( false );\n  ui.goForwardButton->setEnabled( false );\n\n#if QT_VERSION >= QT_VERSION_CHECK(4, 6, 0)\n  grabGesture( Gestures::GDPinchGestureType );\n  grabGesture( Gestures::GDSwipeGestureType );\n#endif\n\n#ifdef HAVE_X11\n  scanFlag = new ScanFlag( this );\n\n  connect( this, SIGNAL( showScanFlag( bool ) ),\n           scanFlag, SLOT( showScanFlag() ) );\n\n  connect( this, SIGNAL( hideScanFlag() ),\n           scanFlag, SLOT( hideWindow() ) );\n\n  connect( scanFlag, SIGNAL( showScanPopup() ),\n           this, SLOT( showEngagePopup() ) );\n\n  delayTimer.setSingleShot( true );\n  delayTimer.setInterval( 200 );\n\n  connect( &delayTimer, SIGNAL( timeout() ),\n    this, SLOT( delayShow() ) );\n#endif\n\n  applyZoomFactor();\n  applyWordsZoomLevel();\n}\n\nScanPopup::~ScanPopup()\n{\n  saveConfigData();\n\n  disableScanning();\n\n#if QT_VERSION >= QT_VERSION_CHECK(4, 6, 0)\n  ungrabGesture( Gestures::GDPinchGestureType );\n  ungrabGesture( Gestures::GDSwipeGestureType );\n#endif\n}\n\nvoid ScanPopup::saveConfigData()\n{\n  // Save state, geometry and pin status\n  cfg.popupWindowState = saveState( 1 );\n  cfg.popupWindowGeometry = saveGeometry();\n  cfg.pinPopupWindow = ui.pinButton->isChecked();\n  cfg.popupWindowAlwaysOnTop = ui.onTopButton->isChecked();\n}\n\nvoid ScanPopup::enableScanning()\n{\n  if ( !isScanningEnabled )\n  {\n    isScanningEnabled = true;\n    MouseOver::instance().enableMouseOver();\n  }\n}\n\nvoid ScanPopup::disableScanning()\n{\n  if ( isScanningEnabled )\n  {\n    MouseOver::instance().disableMouseOver();\n    isScanningEnabled = false;\n  }\n}\n\nvoid ScanPopup::applyZoomFactor()\n{\n  definition->setZoomFactor( cfg.preferences.zoomFactor );\n}\n\nvoid ScanPopup::applyWordsZoomLevel()\n{\n  QFont font( wordListDefaultFont );\n  int ps = font.pointSize();\n\n  if ( cfg.preferences.wordsZoomLevel != 0 )\n  {\n    ps += cfg.preferences.wordsZoomLevel;\n    if ( ps < 1 )\n      ps = 1;\n    font.setPointSize( ps );\n  }\n\n  if ( ui.translateBox->wordList()->font().pointSize() != ps )\n    ui.translateBox->wordList()->setFont( font );\n\n  font = translateLineDefaultFont;\n  ps = font.pointSize();\n\n  if ( cfg.preferences.wordsZoomLevel != 0 )\n  {\n    ps += cfg.preferences.wordsZoomLevel;\n    if ( ps < 1 )\n      ps = 1;\n    font.setPointSize( ps );\n  }\n\n  if ( ui.translateBox->translateLine()->font().pointSize() != ps )\n    ui.translateBox->translateLine()->setFont( font );\n\n  font = groupListDefaultFont;\n  ps = font.pointSize();\n\n  if ( cfg.preferences.wordsZoomLevel != 0 )\n  {\n    ps += cfg.preferences.wordsZoomLevel;\n    if ( ps < 1 )\n      ps = 1;\n    font.setPointSize( ps );\n  }\n\n  if ( ui.groupList->font().pointSize() != ps )\n  {\n    disconnect( ui.groupList, SIGNAL( currentIndexChanged( QString const & ) ),\n                this, SLOT( currentGroupChanged( QString const & ) ) );\n    int n = ui.groupList->currentIndex();\n    ui.groupList->clear();\n    ui.groupList->setFont( font );\n    ui.groupList->fill( groups );\n    ui.groupList->setCurrentIndex( n );\n    connect( ui.groupList, SIGNAL( currentIndexChanged( QString const & ) ),\n             this, SLOT( currentGroupChanged( QString const & ) ) );\n  }\n\n  ui.outerFrame->layout()->activate();\n}\n\nQt::WindowFlags ScanPopup::unpinnedWindowFlags() const\n{\n#ifdef ENABLE_SPWF_CUSTOMIZATION\n  const Config::ScanPopupWindowFlags spwf = cfg.preferences.scanPopupUnpinnedWindowFlags;\n  Qt::WindowFlags result;\n  if( spwf == Config::SPWF_Popup )\n    result = Qt::Popup;\n  else\n  if( spwf == Config::SPWF_Tool )\n    result = Qt::Tool | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint;\n  else\n    return defaultUnpinnedWindowFlags; // Ignore BypassWMHint option.\n\n  if( cfg.preferences.scanPopupUnpinnedBypassWMHint )\n    result |= Qt::X11BypassWindowManagerHint;\n  return result;\n#else\n  return defaultUnpinnedWindowFlags;\n#endif\n}\n\nvoid ScanPopup::translateWordFromClipboard()\n{\n\treturn translateWordFromClipboard(QClipboard::Clipboard);\n}\n\nvoid ScanPopup::translateWordFromSelection()\n{\n\treturn translateWordFromClipboard(QClipboard::Selection);\n}\n\nvoid ScanPopup::editGroupRequested()\n{\n  emit editGroupRequested( ui.groupList->getCurrentGroup() );\n}\n\nvoid ScanPopup::translateWordFromClipboard(QClipboard::Mode m)\n{\n  GD_DPRINTF( \"translating from clipboard or selection\\n\" );\n\n  QString subtype = \"plain\";\n\n  QString str = QApplication::clipboard()->text( subtype, m);\n\n  translateWord( str );\n}\n\nvoid ScanPopup::translateWord( QString const & word )\n{\n  pendingInputPhrase = cfg.preferences.sanitizeInputPhrase( word );\n\n  if ( !pendingInputPhrase.isValid() )\n    return; // Nothing there\n\n  // In case we had any timers engaged before, cancel them now.\n  altModePollingTimer.stop();\n  altModeExpirationTimer.stop();\n\n#ifdef HAVE_X11\n  emit hideScanFlag();\n#endif\n\n  inputPhrase = pendingInputPhrase;\n  engagePopup( false,\n#ifdef Q_OS_WIN\n      true // We only focus popup under Windows when activated via Ctrl+C+C\n           // -- on Linux it already has an implicit focus\n#else\n      false\n#endif\n      );\n}\n\n#ifdef HAVE_X11\nvoid ScanPopup::delayShow()\n{\n  QString subtype = \"plain\";\n  handleInputWord( QApplication::clipboard()->text( subtype, QClipboard::Selection ) );\n}\n#endif\n\nvoid ScanPopup::clipboardChanged( QClipboard::Mode m )\n{\n  if ( !isScanningEnabled )\n    return;\n#ifdef HAVE_X11\n  if( cfg.preferences.ignoreOwnClipboardChanges && ownsClipboardMode( m ) )\n    return;\n#endif\n\n  GD_DPRINTF( \"clipboard changed\\n\" );\n\n#ifdef HAVE_X11\n  if( m == QClipboard::Selection )\n  {\n    // Use delay show to prevent multiple popups while selection in progress\n    delayTimer.start();\n    return;\n  }\n#endif\n\n  QString subtype = \"plain\";\n\n  handleInputWord( QApplication::clipboard()->text( subtype, m ) );\n}\n\nvoid ScanPopup::mouseHovered( QString const & str, bool forcePopup )\n{\n  handleInputWord( str, forcePopup );\n}\n\nvoid ScanPopup::handleInputWord( QString const & str, bool forcePopup )\n{\n  Config::InputPhrase sanitizedPhrase = cfg.preferences.sanitizeInputPhrase( str );\n\n  if ( isVisible() && sanitizedPhrase == inputPhrase )\n  {\n    // Attempt to translate the same word we already have shown in scan popup.\n    // Ignore it, as it is probably a spurious mouseover event.\n    return;\n  }\n\n  pendingInputPhrase = sanitizedPhrase;\n\n  if ( !pendingInputPhrase.isValid() )\n  {\n    if ( cfg.preferences.scanPopupAltMode )\n    {\n      // In case we had any timers engaged before, cancel them now, since\n      // we're not going to translate anything anymore.\n      altModePollingTimer.stop();\n      altModeExpirationTimer.stop();\n    }\n    return;\n  }\n\n#ifdef HAVE_X11\n  if ( cfg.preferences.showScanFlag ) {\n    inputPhrase = pendingInputPhrase;\n    emit showScanFlag( forcePopup );\n    return;\n  }\n#endif\n\n  // Check key modifiers\n\n  if ( cfg.preferences.enableScanPopupModifiers && !checkModifiersPressed( cfg.preferences.scanPopupModifiers ) )\n  {\n    if ( cfg.preferences.scanPopupAltMode )\n    {\n      altModePollingTimer.start();\n      altModeExpirationTimer.start();\n    }\n\n    return;\n  }\n\n  inputPhrase = pendingInputPhrase;\n  engagePopup( forcePopup );\n}\n\n#ifdef HAVE_X11\nvoid ScanPopup::showEngagePopup()\n{\n  engagePopup(false);\n}\n#endif\n\nvoid ScanPopup::engagePopup( bool forcePopup, bool giveFocus )\n{\n  if( cfg.preferences.scanToMainWindow && !forcePopup )\n  {\n    // Send translated word to main window istead of show popup\n    emit sendPhraseToMainWindow( inputPhrase );\n    return;\n  }\n\n  definition->setSelectionBySingleClick( cfg.preferences.selectWordBySingleClick );\n\n  if ( !isVisible() )\n  {\n    // Need to show the window\n\n    if ( !ui.pinButton->isChecked() )\n    {\n      // Decide where should the window land\n\n      QPoint currentPos = QCursor::pos();\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 11, 0 )\n      QRect const desktop = QGuiApplication::screenAt( currentPos )->geometry();\n#else\n      QRect const desktop = QApplication::desktop()->screenGeometry();\n#endif\n\n      QSize windowSize = geometry().size();\n\n      int x, y;\n\n      /// Try the to-the-right placement\n      if ( currentPos.x() + 4 + windowSize.width() <= desktop.topRight().x() )\n        x = currentPos.x() + 4;\n      else\n      /// Try the to-the-left placement\n      if ( currentPos.x() - 4 - windowSize.width() >= desktop.x() )\n        x = currentPos.x() - 4 - windowSize.width();\n      else\n      // Center it\n        x = desktop.x() + ( desktop.width() - windowSize.width() ) / 2;\n\n      /// Try the to-the-bottom placement\n      if ( currentPos.y() + 15 + windowSize.height() <= desktop.bottomLeft().y() )\n        y = currentPos.y() + 15;\n      else\n      /// Try the to-the-top placement\n      if ( currentPos.y() - 15 - windowSize.height() >= desktop.y() )\n        y = currentPos.y() - 15 - windowSize.height();\n      else\n      // Center it\n        y = desktop.y() + ( desktop.height() - windowSize.height() ) / 2;\n\n      move( x, y );\n    }\n    else\n    {\n      if( pinnedGeometry.size() > 0 )\n        restoreGeometry( pinnedGeometry );\n    }\n\n    show();\n\n#ifdef ENABLE_SPWF_CUSTOMIZATION\n    // Ensure that the window always has focus on X11 with Qt::Tool flag.\n    // This also often prevents the window from disappearing prematurely with Qt::Popup flag,\n    // especially when combined with Qt::X11BypassWindowManagerHint flag.\n    if ( !ui.pinButton->isChecked() )\n      giveFocus = true;\n#endif\n\n    if ( giveFocus )\n    {\n      activateWindow();\n      raise();\n    }\n\n    if ( !ui.pinButton->isChecked() )\n    {\n      mouseEnteredOnce = false;\n      // Need to monitor the mouse so we know when to hide the window\n      interceptMouse();\n    }\n\n    // This produced some funky mouse grip-related bugs so we commented it out\n    //QApplication::processEvents(); // Make window appear immediately no matter what\n  }\n  else\n  if ( ui.pinButton->isChecked() )\n  {\n    // Pinned-down window isn't always on top, so we need to raise it\n    show();\n    activateWindow();\n    raise();\n  }\n#ifdef ENABLE_SPWF_CUSTOMIZATION\n  else\n  if ( ( windowFlags() & Qt::Tool ) == Qt::Tool )\n  {\n    // Ensure that the window with Qt::Tool flag always has focus on X11.\n    activateWindow();\n    raise();\n  }\n#endif\n\n  if ( ui.pinButton->isChecked() )\n       setWindowTitle( tr( \"%1 - %2\" ).arg( elideInputWord(), \"GoldenDict\" ) );\n\n  /// Too large strings make window expand which is probably not what user\n  /// wants\n  ui.translateBox->setText( Folding::escapeWildcardSymbols( inputPhrase.phrase ), false );\n  translateBoxSuffix = inputPhrase.punctuationSuffix;\n\n  showTranslationFor( inputPhrase );\n}\n\nQString ScanPopup::elideInputWord()\n{\n  QString const & inputWord = inputPhrase.phrase;\n  return inputWord.size() > 32 ? inputWord.mid( 0, 32 ) + \"...\" : inputWord;\n}\n\nvoid ScanPopup::currentGroupChanged( QString const & )\n{\n    cfg.lastPopupGroupId = ui.groupList->getCurrentGroup();\n    Instances::Group const * igrp = groups.findGroup( cfg.lastPopupGroupId );\n    if( cfg.lastPopupGroupId == Instances::Group::AllGroupId )\n    {\n      if( igrp )\n        igrp->checkMutedDictionaries( &cfg.popupMutedDictionaries );\n      dictionaryBar.setMutedDictionaries( &cfg.popupMutedDictionaries );\n    }\n    else\n    {\n      Config::Group * grp = cfg.getGroup( cfg.lastPopupGroupId );\n      if( grp )\n      {\n        if( igrp )\n          igrp->checkMutedDictionaries( &grp->popupMutedDictionaries );\n        dictionaryBar.setMutedDictionaries( &grp->popupMutedDictionaries );\n      }\n      else\n        dictionaryBar.setMutedDictionaries( 0 );\n    }\n\n  updateDictionaryBar();\n\n  if ( isVisible() )\n  {\n    updateSuggestionList();\n    translateInputFinished();\n  }\n\n  cfg.lastPopupGroupId = ui.groupList->getCurrentGroup();\n}\n\nvoid ScanPopup::wordListItemActivated( QListWidgetItem * item )\n{\n  showTranslationFor( Config::InputPhrase::fromPhrase( item->text() ) );\n}\n\nvoid ScanPopup::translateInputChanged( QString const & text )\n{\n  updateSuggestionList( text );\n  translateBoxSuffix = QString();\n}\n\nvoid ScanPopup::updateSuggestionList()\n{\n  updateSuggestionList( ui.translateBox->translateLine()->text() );\n}\n\nvoid ScanPopup::updateSuggestionList( QString const & text )\n{\n  mainStatusBar->clearMessage();\n  ui.translateBox->wordList()->setCurrentItem( 0, QItemSelectionModel::Clear );\n\n  QString req = text.trimmed();\n\n  if ( !req.size() )\n  {\n    // An empty request always results in an empty result\n    wordFinder.cancel();\n    ui.translateBox->wordList()->clear();\n    ui.translateBox->wordList()->unsetCursor();\n\n    // Reset the noResults mark if it's on right now\n    if ( ui.translateBox->translateLine()->property( \"noResults\" ).toBool() )\n    {\n      ui.translateBox->translateLine()->setProperty( \"noResults\", false );\n      setStyleSheet( styleSheet() );\n    }\n    return;\n  }\n\n  ui.translateBox->wordList()->setCursor( Qt::WaitCursor );\n\n  wordFinder.prefixMatch( req, getActiveDicts() );\n}\n\nvoid ScanPopup::translateInputFinished()\n{\n  QString const word = ui.translateBox->translateLine()->text().trimmed();\n  if( word.isEmpty() )\n    return;\n  inputPhrase.phrase = Folding::unescapeWildcardSymbols( word );\n  inputPhrase.punctuationSuffix = translateBoxSuffix;\n  showTranslationFor( inputPhrase );\n}\n\nvoid ScanPopup::showTranslationFor( Config::InputPhrase const & inputPhrase )\n{\n  ui.pronounceButton->hide();\n\n  unsigned groupId = ui.groupList->getCurrentGroup();\n  definition->showDefinition( inputPhrase, groupId );\n  definition->focus();\n}\n\nvector< sptr< Dictionary::Class > > const & ScanPopup::getActiveDicts()\n{\n  int current = ui.groupList->currentIndex();\n\n  if ( current < 0 || current >= (int) groups.size() )\n  {\n    // This shouldn't ever happen\n    return allDictionaries;\n  }\n\n  Config::MutedDictionaries const * mutedDictionaries = dictionaryBar.getMutedDictionaries();\n  if ( !dictionaryBar.toggleViewAction()->isChecked() || mutedDictionaries == 0 )\n    return groups[ current ].dictionaries;\n  else\n  {\n    vector< sptr< Dictionary::Class > > const & activeDicts =\n      groups[ current ].dictionaries;\n\n    // Populate the special dictionariesUnmuted array with only unmuted\n    // dictionaries\n\n    dictionariesUnmuted.clear();\n    dictionariesUnmuted.reserve( activeDicts.size() );\n\n    for( unsigned x = 0; x < activeDicts.size(); ++x )\n      if ( !mutedDictionaries->contains(\n              QString::fromStdString( activeDicts[ x ]->getId() ) ) )\n        dictionariesUnmuted.push_back( activeDicts[ x ] );\n\n    return dictionariesUnmuted;\n  }\n}\n\nvoid ScanPopup::typingEvent( QString const & t )\n{\n  if ( t == \"\\n\" || t == \"\\r\" )\n  {\n    focusTranslateLine();\n  }\n  else\n  {\n    ui.translateBox->translateLine()->setFocus();\n    ui.translateBox->setText( t, true );\n    ui.translateBox->translateLine()->setCursorPosition( t.size() );\n  }\n}\n\nbool ScanPopup::eventFilter( QObject * watched, QEvent * event )\n{\n  if ( watched == ui.translateBox->translateLine() )\n  {\n    if ( event->type() == QEvent::FocusIn )\n    {\n      QFocusEvent * focusEvent = static_cast< QFocusEvent * >( event );\n\n      // select all on mouse click\n      if ( focusEvent->reason() == Qt::MouseFocusReason ) {\n        QTimer::singleShot(0, this, SLOT(focusTranslateLine()));\n      }\n      return false;\n    }\n\n    if ( event->type() == QEvent::Resize )\n    {\n      // The UI looks ugly when group combobox is higher than translate line.\n      // Make the height of the combobox the same as the line edit's height.\n      // The fonts of these UI items should be kept in sync by applyWordsZoomLevel()\n      // so that text in the combobox is not clipped.\n      const QResizeEvent * const resizeEvent = static_cast< const QResizeEvent * >( event );\n      ui.groupList->setFixedHeight( resizeEvent->size().height() );\n      return false;\n    }\n  }\n\n  if ( mouseIntercepted )\n  {\n    // We're only interested in our events\n\n    if ( event->type() == QEvent::MouseMove )\n    {\n//    DPRINTF( \"Object: %s\\n\", watched->objectName().toUtf8().data() );\n      QMouseEvent * mouseEvent = ( QMouseEvent * ) event;\n      reactOnMouseMove( mouseEvent->globalPos() );\n    }\n  }\n\n  return QMainWindow::eventFilter( watched, event );\n}\n\nvoid ScanPopup::reactOnMouseMove( QPoint const & p )\n{\n  if ( geometry().contains( p ) )\n  {\n//        DPRINTF( \"got inside\\n\" );\n\n    hideTimer.stop();\n    mouseEnteredOnce = true;\n    uninterceptMouse();\n  }\n  else\n  {\n//        DPRINTF( \"outside\\n\" );\n    // We're in grab mode and outside the window - calculate the\n    // distance from it. We might want to hide it.\n\n    // When the mouse has entered once, we don't allow it stayng outside,\n    // but we give a grace period for it to return.\n    int proximity = mouseEnteredOnce ? 0 : 60;\n\n    // Note: watched == this ensures no other child objects popping out are\n    // receiving this event, meaning there's basically nothing under the\n    // cursor.\n    if ( /*watched == this &&*/\n         !frameGeometry().adjusted( -proximity, -proximity, proximity, proximity ).\n         contains( p ) )\n    {\n      // We've way too far from the window -- hide the popup\n\n      // If the mouse never entered the popup, hide the window instantly --\n      // the user just moved the cursor further away from the window.\n\n      if ( !mouseEnteredOnce )\n        hideWindow();\n      else\n        hideTimer.start();\n    }\n  }\n}\n\nvoid ScanPopup::mousePressEvent( QMouseEvent * ev )\n{\n  // With mouse grabs, the press can occur anywhere on the screen, which\n  // might mean hiding the window.\n\n  if ( !frameGeometry().contains( ev->globalPos() ) )\n  {\n    hideWindow();\n\n    return;\n  }\n\n  if ( ev->button() == Qt::LeftButton )\n  {\n    startPos = ev->globalPos();\n    setCursor( Qt::ClosedHandCursor );\n  }\n\n  QMainWindow::mousePressEvent( ev );\n}\n\nvoid ScanPopup::mouseMoveEvent( QMouseEvent * event )\n{\n  if ( event->buttons() && cursor().shape() == Qt::ClosedHandCursor )\n  {\n    QPoint newPos = event->globalPos();\n\n    QPoint delta = newPos - startPos;\n\n    startPos = newPos;\n\n    // Move the window\n\n    move( pos() + delta );\n  }\n\n  QMainWindow::mouseMoveEvent( event );\n}\n\nvoid ScanPopup::mouseReleaseEvent( QMouseEvent * ev )\n{\n  unsetCursor();\n  QMainWindow::mouseReleaseEvent( ev );\n}\n\nvoid ScanPopup::leaveEvent( QEvent * event )\n{\n  QMainWindow::leaveEvent( event );\n\n  // We hide the popup when the mouse leaves it.\n\n  // Combo-boxes seem to generate leave events for their parents when\n  // unfolded, so we check coordinates as well.\n  // If the dialog is pinned, we don't hide the popup.\n  // If some mouse buttons are pressed, we don't hide the popup either,\n  // since it indicates the move operation is underway.\n  if ( !ui.pinButton->isChecked() && !geometry().contains( QCursor::pos() ) &&\n       QApplication::mouseButtons() == Qt::NoButton )\n  {\n    hideTimer.start();\n  }\n}\n\nvoid ScanPopup::enterEvent( QEvent * event )\n{\n  QMainWindow::enterEvent( event );\n\n  if ( mouseEnteredOnce )\n  {\n    // We \"enter\" first time via our event filter. This seems to evade some\n    // unexpected behavior under Windows.\n\n    // If there was a countdown to hide the window, stop it.\n    hideTimer.stop();\n  }\n}\n\nvoid ScanPopup::requestWindowFocus()\n{\n  // One of the rare, actually working workarounds for requesting a user keyboard focus on X11,\n  // works for Qt::Popup windows, exactly like our Scan Popup (in unpinned state).\n  // Modern window managers actively resist to automatically focus pop-up windows.\n#if defined HAVE_X11 && QT_VERSION < QT_VERSION_CHECK( 5, 0, 0 )\n  if ( !ui.pinButton->isChecked() )\n  {\n    QMenu m( this );\n    m.addAction( \"\" );\n    m.show();\n    m.hide();\n  }\n#endif\n}\n\nvoid ScanPopup::showEvent( QShowEvent * ev )\n{\n  QMainWindow::showEvent( ev );\n\n  QTimer::singleShot(100, this, SLOT( requestWindowFocus() ) );\n\n  if ( groups.size() <= 1 ) // Only the default group? Hide then.\n    ui.groupList->hide();\n\n  if ( ui.showDictionaryBar->isChecked() != dictionaryBar.isVisible() )\n  {\n    ui.showDictionaryBar->setChecked( dictionaryBar.isVisible() );\n    updateDictionaryBar();\n  }\n}\n\nvoid ScanPopup::closeEvent( QCloseEvent * ev )\n{\n  if( isVisible() && ui.pinButton->isChecked() )\n    pinnedGeometry = saveGeometry();\n\n  QMainWindow::closeEvent( ev );\n}\n\nvoid ScanPopup::moveEvent( QMoveEvent * ev )\n{\n  if( isVisible() && ui.pinButton->isChecked() )\n    pinnedGeometry = saveGeometry();\n\n  QMainWindow::moveEvent( ev );\n}\n\nvoid ScanPopup::prefixMatchFinished()\n{\n  // Check that there's a window there at all\n  if ( isVisible() )\n  {\n    if ( wordFinder.getErrorString().size() )\n    {\n      ui.queryError->setToolTip( wordFinder.getErrorString() );\n      ui.queryError->show();\n    }\n    else\n      ui.queryError->hide();\n  }\n}\n\nvoid ScanPopup::on_pronounceButton_clicked()\n{\n  definition->playSound();\n}\n\nvoid ScanPopup::pinButtonClicked( bool checked )\n{\n  if ( checked )\n  {\n    uninterceptMouse();\n\n    ui.onTopButton->setVisible( true );\n    Qt::WindowFlags flags = pinnedWindowFlags;\n    if( ui.onTopButton->isChecked() )\n      flags |= Qt::WindowStaysOnTopHint;\n    setWindowFlags( flags );\n\n    setWindowTitle( tr( \"%1 - %2\" ).arg( elideInputWord(), \"GoldenDict\" ) );\n    dictionaryBar.setMovable( true );\n    hideTimer.stop();\n  }\n  else\n  {\n    ui.onTopButton->setVisible( false );\n    dictionaryBar.setMovable( false );\n    setWindowFlags( unpinnedWindowFlags() );\n\n    mouseEnteredOnce = true;\n  }\n\n  show();\n\n  if( checked )\n    pinnedGeometry = saveGeometry();\n}\n\nvoid ScanPopup::focusTranslateLine()\n{\n  if ( !isActiveWindow() )\n    activateWindow();\n\n  ui.translateBox->translateLine()->setFocus();\n  ui.translateBox->translateLine()->selectAll();\n}\n\nvoid ScanPopup::on_showDictionaryBar_clicked( bool checked )\n{\n  dictionaryBar.setVisible( checked );\n  updateDictionaryBar();\n  definition->updateMutedContents();\n}\n\nvoid ScanPopup::hideTimerExpired()\n{\n  if ( isVisible() )\n    hideWindow();\n}\n\nvoid ScanPopup::altModeExpired()\n{\n  // The alt mode duration has expired, so there's no need to poll for modifiers\n  // anymore.\n  altModePollingTimer.stop();\n}\n\nvoid ScanPopup::altModePoll()\n{\n  if ( !pendingInputPhrase.isValid() )\n  {\n    altModePollingTimer.stop();\n    altModeExpirationTimer.stop();\n  }\n  else\n  if ( checkModifiersPressed( cfg.preferences.scanPopupModifiers ) )\n  {\n    altModePollingTimer.stop();\n    altModeExpirationTimer.stop();\n\n    inputPhrase = pendingInputPhrase;\n    engagePopup( false );\n  }\n}\n\nvoid ScanPopup::pageLoaded( ArticleView * )\n{\n  ui.pronounceButton->setVisible( definition->hasSound() );\n\n  updateBackForwardButtons();\n\n  if ( cfg.preferences.pronounceOnLoadPopup )\n    definition->playSound();\n}\n\nvoid ScanPopup::showStatusBarMessage( QString const & message, int timeout, QPixmap const & icon )\n{\n  mainStatusBar->showMessage( message, timeout, icon );\n}\n\nvoid ScanPopup::escapePressed()\n{\n  if ( !definition->closeSearch() )\n    hideWindow();\n}\n\nvoid ScanPopup::hideWindow()\n{\n  uninterceptMouse();\n\n  emit closeMenu();\n  hideTimer.stop();\n  unsetCursor();\n  ui.translateBox->setPopupEnabled( false );\n  ui.translateBox->translateLine()->deselect();\n  hide();\n}\n\nvoid ScanPopup::interceptMouse()\n{\n  if ( !mouseIntercepted )\n  {\n    // We used to grab the mouse -- but this doesn't always work reliably\n    // (e.g. doesn't work at all in Windows 7 for some reason). Therefore\n    // we use a polling timer now.\n\n//    grabMouse();\n    mouseGrabPollTimer.start();\n\n    qApp->installEventFilter( this );\n\n    mouseIntercepted = true;\n  }\n}\n\nvoid ScanPopup::mouseGrabPoll()\n{\n  if ( mouseIntercepted )\n    reactOnMouseMove( QCursor::pos() );\n}\n\nvoid ScanPopup::uninterceptMouse()\n{\n  if ( mouseIntercepted )\n  {\n    qApp->removeEventFilter( this );\n    mouseGrabPollTimer.stop();\n//    releaseMouse();\n\n    mouseIntercepted = false;\n  }\n}\n\nvoid ScanPopup::updateDictionaryBar()\n{\n  if ( !dictionaryBar.toggleViewAction()->isChecked() )\n    return; // It's not enabled, therefore hidden -- don't waste time\n\n  unsigned currentId = ui.groupList->getCurrentGroup();\n  Instances::Group const * grp = groups.findGroup( currentId );\n\n  if ( grp ) // Should always be !0, but check as a safeguard\n    dictionaryBar.setDictionaries( grp->dictionaries );\n\n  if( currentId == Instances::Group::AllGroupId )\n    dictionaryBar.setMutedDictionaries( &cfg.popupMutedDictionaries );\n  else\n  {\n    Config::Group * grp = cfg.getGroup( currentId );\n    dictionaryBar.setMutedDictionaries( grp ? &grp->popupMutedDictionaries : 0 );\n  }\n\n  setDictionaryIconSize();\n}\n\nvoid ScanPopup::mutedDictionariesChanged()\n{\n  updateSuggestionList();\n  if ( dictionaryBar.toggleViewAction()->isChecked() )\n    definition->updateMutedContents();\n}\n\nvoid ScanPopup::on_sendWordButton_clicked()\n{\n  if ( !isVisible() )\n    return;\n  if( !ui.pinButton->isChecked() )\n  {\n    definition->closeSearch();\n    hideWindow();\n  }\n  emit sendPhraseToMainWindow( definition->getPhrase() );\n}\n\nvoid ScanPopup::on_sendWordToFavoritesButton_clicked()\n{\n  if ( !isVisible() )\n    return;\n  emit sendWordToFavorites( definition->getTitle(), cfg.lastPopupGroupId );\n\n  ui.sendWordToFavoritesButton->setIcon( blueStarIcon );\n}\n\nvoid ScanPopup::switchExpandOptionalPartsMode()\n{\n  if( isVisible() )\n    emit switchExpandMode();\n}\n\nvoid ScanPopup::updateBackForwardButtons()\n{\n  ui.goBackButton->setEnabled(definition->canGoBack());\n  ui.goForwardButton->setEnabled(definition->canGoForward());\n}\n\nvoid ScanPopup::on_goBackButton_clicked()\n{\n  definition->back();\n}\n\nvoid ScanPopup::on_goForwardButton_clicked()\n{\n  definition->forward();\n}\n\nvoid ScanPopup::setDictionaryIconSize()\n{\n  int extent = cfg.usingSmallIconsInToolbars ?\n               QApplication::style()->pixelMetric( QStyle::PM_SmallIconSize ) :\n               21;\n  dictionaryBar.setDictionaryIconSize( extent );\n}\n\nvoid ScanPopup::setGroupByName( QString const & name )\n{\n  int i;\n  for( i = 0; i < ui.groupList->count(); i++ )\n  {\n    if( ui.groupList->itemText( i ) == name )\n    {\n      ui.groupList->setCurrentIndex( i );\n      break;\n    }\n  }\n  if( i >= ui.groupList->count() )\n    gdWarning( \"Group \\\"%s\\\" for popup window is not found\\n\", name.toUtf8().data() );\n}\n\nvoid ScanPopup::alwaysOnTopClicked( bool checked )\n{\n  bool wasVisible = isVisible();\n  if( ui.pinButton->isChecked() )\n  {\n    Qt::WindowFlags flags = this->windowFlags();\n    if( checked )\n      setWindowFlags(flags | Qt::WindowStaysOnTopHint );\n    else\n      setWindowFlags(flags ^ Qt::WindowStaysOnTopHint );\n    if( wasVisible )\n      show();\n  }\n}\n\nvoid ScanPopup::titleChanged( ArticleView *, QString const & title )\n{\n  unsigned groupId = ui.groupList->getCurrentGroup();\n\n  // Set icon for \"Add to Favorites\" button\n  ui.sendWordToFavoritesButton->setIcon( isWordPresentedInFavorites( title, groupId ) ?\n                                         blueStarIcon : starIcon );\n}\n"
        },
        {
          "name": "scanpopup.hh",
          "type": "blob",
          "size": 7.4091796875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __SCANPOPUP_HH_INCLUDED__\n#define __SCANPOPUP_HH_INCLUDED__\n\n#include \"article_netmgr.hh\"\n#include \"articleview.hh\"\n#include \"wordfinder.hh\"\n#include \"keyboardstate.hh\"\n#include \"config.hh\"\n#include \"ui_scanpopup.h\"\n#include <QDialog>\n#include <QClipboard>\n#include \"history.hh\"\n#include \"dictionarybar.hh\"\n#include \"mainstatusbar.hh\"\n#ifdef HAVE_X11\n#include \"scanflag.hh\"\n#endif\n\n/// This is a popup dialog to show translations when clipboard scanning mode\n/// is enabled.\nclass ScanPopup: public QMainWindow, KeyboardState\n{\n  Q_OBJECT\n\npublic:\n\n  ScanPopup( QWidget * parent,\n             Config::Class & cfg,\n             ArticleNetworkAccessManager &,\n             AudioPlayerPtr const &,\n             std::vector< sptr< Dictionary::Class > > const & allDictionaries,\n             Instances::Groups const &,\n             History & );\n\n  ~ScanPopup();\n  \n  /// Enables scanning. When the object is created, the scanning is disabled\n  /// initially.\n  void enableScanning();\n  /// Disables scanning.\n  void disableScanning();\n\n  /// Applies current zoom factor to the popup's view. Should be called when\n  /// it's changed.\n  void applyZoomFactor();\n  void applyWordsZoomLevel();\n  /// Translate the word\n  void translateWord( QString const & word );\n\n  void setDictionaryIconSize();\n\n  void saveConfigData();\n\nsignals:\n\n  /// Forwarded from the dictionary bar, so that main window could act on this.\n  void editGroupRequested( unsigned id );\n  /// Send word to main window\n  void sendPhraseToMainWindow( Config::InputPhrase const & phrase );\n  /// Close opened menus when window hide\n  void closeMenu();\n  /// Signals to set expand optional parts mode (retranslation from/to MainWindow and dictionary bar)\n  void setExpandMode( bool expand );\n  void setViewExpandMode( bool expand );\n  /// Signal to switch expand optional parts mode\n  void switchExpandMode();\n  /// Signal to add word to history even if history is disabled\n  void forceAddWordToHistory( const QString & word);\n  /// Retranslate signal from dictionary bar\n  void showDictionaryInfo( QString const & id );\n  void openDictionaryFolder( QString const & id );\n  /// Put translated word into history\n  void sendWordToHistory( QString const & word );\n  /// Put translated word into Favorites\n  void sendWordToFavorites( QString const & word, unsigned groupId );\n  /// Check is word already presented in Favorites\n  bool isWordPresentedInFavorites( QString const & word, unsigned groupId );\n\n#ifdef HAVE_X11\n  /// Interaction with scan flag window\n  void showScanFlag( bool forcePopup );\n  void hideScanFlag();\n#endif\n\n#ifdef Q_OS_WIN32\n  /// Ask for source window is current translate tab\n  bool isGoldenDictWindow( HWND hwnd );\n#endif\n\npublic slots:\n  void requestWindowFocus();\n\n  /// Translates the word from the clipboard, showing the window etc.\n  void translateWordFromClipboard();\n  /// Translates the word from the clipboard selection\n  void translateWordFromSelection();\n  /// From the dictionary bar.\n  void editGroupRequested();\n\n  void setGroupByName( QString const & name );\n\n#ifdef HAVE_X11\n  void showEngagePopup();\n#endif\n\nprivate:\n\n  Qt::WindowFlags unpinnedWindowFlags() const;\n\n  // Translates the word from the clipboard or the clipboard selection\n  void translateWordFromClipboard(QClipboard::Mode m);\n\n  // Hides the popup window, effectively closing it.\n  void hideWindow();\n\n  // Grabs mouse and installs global event filter to track it thoroughly.\n  void interceptMouse();\n  // Ungrabs mouse and uninstalls global event filter.\n  void uninterceptMouse();\n\n  void updateDictionaryBar();\n\n  Config::Class & cfg;\n  bool isScanningEnabled;\n  std::vector< sptr< Dictionary::Class > > const & allDictionaries;\n  std::vector< sptr< Dictionary::Class > > dictionariesUnmuted;\n  Instances::Groups const & groups;\n  History & history;\n  Ui::ScanPopup ui;\n  ArticleView * definition;\n  QAction escapeAction, switchExpandModeAction, focusTranslateLineAction;\n  QAction openSearchAction;\n  Config::InputPhrase pendingInputPhrase, inputPhrase;\n  QString translateBoxSuffix; ///< A punctuation suffix that corresponds to translateBox's text.\n  WordFinder wordFinder;\n  Config::Events configEvents;\n  DictionaryBar dictionaryBar;\n  MainStatusBar * mainStatusBar;\n  /// Fonts saved before words zooming is in effect, so it could be reset back.\n  QFont wordListDefaultFont, translateLineDefaultFont, groupListDefaultFont;\n\n#ifdef HAVE_X11\n  ScanFlag * scanFlag;\n  QTimer delayTimer;\n#endif\n\n  bool mouseEnteredOnce;\n  bool mouseIntercepted;\n\n  QPoint startPos; // For window moving\n  QByteArray pinnedGeometry;\n\n  QTimer hideTimer; // When mouse leaves the window, a grace period is\n                    // given for it to return back. If it doesn't before\n                    // this timer expires, the window gets hidden.\n  QTimer altModeExpirationTimer, altModePollingTimer; // Timers for alt mode\n\n  QTimer mouseGrabPollTimer;\n\n  QIcon starIcon, blueStarIcon;\n\n  void handleInputWord( QString const & , bool forcePopup = false );\n  void engagePopup( bool forcePopup, bool giveFocus = false );\n\n  vector< sptr< Dictionary::Class > > const & getActiveDicts();\n\n  virtual bool eventFilter( QObject * watched, QEvent * event );\n\n  /// Called from event filter or from mouseGrabPoll to handle mouse event\n  /// while it is being intercepted.\n  void reactOnMouseMove( QPoint const & p );\n\n  virtual void mousePressEvent( QMouseEvent * );\n  virtual void mouseMoveEvent( QMouseEvent * );\n  virtual void mouseReleaseEvent( QMouseEvent * );\n  virtual void leaveEvent( QEvent * event );\n  virtual void enterEvent( QEvent * event );\n  virtual void showEvent( QShowEvent * );\n  virtual void closeEvent( QCloseEvent * );\n  virtual void moveEvent( QMoveEvent * );\n\n  /// Returns inputWord, chopped with appended ... if it's too long/\n  QString elideInputWord();\n\n  void updateBackForwardButtons();\n\n  void showTranslationFor( Config::InputPhrase const & inputPhrase );\n\n  void updateSuggestionList();\n  void updateSuggestionList( QString const & text );\n\nprivate slots:\n\n  void clipboardChanged( QClipboard::Mode );\n  void mouseHovered( QString const & , bool forcePopup);\n  void currentGroupChanged( QString const & );\n  void prefixMatchFinished();\n  void on_pronounceButton_clicked();\n  void pinButtonClicked( bool checked );\n  void on_showDictionaryBar_clicked( bool checked );\n  void showStatusBarMessage ( QString const &, int, QPixmap const & );\n  void on_sendWordButton_clicked();\n  void on_sendWordToFavoritesButton_clicked();\n  void on_goBackButton_clicked();\n  void on_goForwardButton_clicked();\n\n  void hideTimerExpired();\n  void altModeExpired();\n  void altModePoll();\n\n  /// Called repeatedly once the popup is initially engaged and we monitor the\n  /// mouse as it may move away from the window. This simulates mouse grab, in\n  /// essence, but seems more reliable. Once the mouse enters the window, the\n  /// polling stops.\n  void mouseGrabPoll();\n\n  void pageLoaded( ArticleView * );\n\n  void escapePressed();\n\n  void mutedDictionariesChanged();\n\n  void switchExpandOptionalPartsMode();\n\n  void translateInputChanged(QString const & text);\n  void translateInputFinished();\n  void wordListItemActivated( QListWidgetItem * );\n\n  void focusTranslateLine();\n\n  void typingEvent( QString const & );\n\n  void alwaysOnTopClicked( bool checked );\n\n  void titleChanged( ArticleView *, QString const & title );\n\n#ifdef HAVE_X11\n  void delayShow();\n#endif\n};\n\n#endif\n"
        },
        {
          "name": "scanpopup.ui",
          "type": "blob",
          "size": 9.509765625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ui version=\"4.0\">\n <class>ScanPopup</class>\n <widget class=\"QMainWindow\" name=\"ScanPopup\">\n  <property name=\"geometry\">\n   <rect>\n    <x>0</x>\n    <y>0</y>\n    <width>557</width>\n    <height>403</height>\n   </rect>\n  </property>\n  <property name=\"windowTitle\">\n   <string>Dialog</string>\n  </property>\n  <widget class=\"QWidget\" name=\"centralWidget\">\n   <property name=\"minimumSize\">\n    <size>\n     <width>280</width>\n     <height>100</height>\n    </size>\n   </property>\n   <layout class=\"QHBoxLayout\" name=\"horizontalLayout_222\">\n    <property name=\"leftMargin\">\n     <number>0</number>\n    </property>\n    <property name=\"topMargin\">\n     <number>0</number>\n    </property>\n    <property name=\"rightMargin\">\n     <number>0</number>\n    </property>\n    <property name=\"bottomMargin\">\n     <number>0</number>\n    </property>\n    <item>\n     <widget class=\"QFrame\" name=\"outerFrame\">\n      <property name=\"frameShape\">\n       <enum>QFrame::NoFrame</enum>\n      </property>\n      <property name=\"frameShadow\">\n       <enum>QFrame::Raised</enum>\n      </property>\n      <property name=\"lineWidth\">\n       <number>0</number>\n      </property>\n      <layout class=\"QVBoxLayout\" name=\"mainLayout\">\n       <property name=\"spacing\">\n        <number>3</number>\n       </property>\n       <property name=\"leftMargin\">\n        <number>3</number>\n       </property>\n       <property name=\"topMargin\">\n        <number>3</number>\n       </property>\n       <property name=\"rightMargin\">\n        <number>3</number>\n       </property>\n       <property name=\"bottomMargin\">\n        <number>3</number>\n       </property>\n       <item>\n        <layout class=\"QHBoxLayout\" name=\"horizontalLayout_3\">\n         <item>\n          <layout class=\"QHBoxLayout\" name=\"horizontalLayout\">\n           <property name=\"spacing\">\n            <number>0</number>\n           </property>\n           <item>\n            <widget class=\"GroupComboBox\" name=\"groupList\">\n             <property name=\"sizePolicy\">\n              <sizepolicy hsizetype=\"Fixed\" vsizetype=\"Preferred\">\n               <horstretch>0</horstretch>\n               <verstretch>0</verstretch>\n              </sizepolicy>\n             </property>\n             <property name=\"sizeAdjustPolicy\">\n              <enum>QComboBox::AdjustToContents</enum>\n             </property>\n            </widget>\n           </item>\n           <item>\n            <widget class=\"TranslateBox\" name=\"translateBox\">\n             <property name=\"sizePolicy\">\n              <sizepolicy hsizetype=\"MinimumExpanding\" vsizetype=\"Fixed\">\n               <horstretch>0</horstretch>\n               <verstretch>0</verstretch>\n              </sizepolicy>\n             </property>\n            </widget>\n           </item>\n          </layout>\n         </item>\n         <item>\n          <layout class=\"QHBoxLayout\" name=\"horizontalLayout_2\">\n           <item>\n            <widget class=\"QLabel\" name=\"queryError\">\n             <property name=\"enabled\">\n              <bool>true</bool>\n             </property>\n             <property name=\"text\">\n              <string/>\n             </property>\n             <property name=\"pixmap\">\n              <pixmap resource=\"resources.qrc\">:/icons/warning.png</pixmap>\n             </property>\n            </widget>\n           </item>\n           <item>\n            <widget class=\"QToolButton\" name=\"goBackButton\">\n             <property name=\"toolTip\">\n              <string>Back</string>\n             </property>\n             <property name=\"text\">\n              <string>...</string>\n             </property>\n             <property name=\"icon\">\n              <iconset resource=\"resources.qrc\">\n               <normaloff>:/icons/previous.png</normaloff>:/icons/previous.png</iconset>\n             </property>\n            </widget>\n           </item>\n           <item>\n            <widget class=\"QToolButton\" name=\"goForwardButton\">\n             <property name=\"toolTip\">\n              <string>Forward</string>\n             </property>\n             <property name=\"text\">\n              <string>...</string>\n             </property>\n             <property name=\"icon\">\n              <iconset resource=\"resources.qrc\">\n               <normaloff>:/icons/next.png</normaloff>:/icons/next.png</iconset>\n             </property>\n            </widget>\n           </item>\n           <item>\n            <widget class=\"QToolButton\" name=\"pronounceButton\">\n             <property name=\"toolTip\">\n              <string>Pronounce Word (Alt+S)</string>\n             </property>\n             <property name=\"text\">\n              <string>...</string>\n             </property>\n             <property name=\"icon\">\n              <iconset resource=\"resources.qrc\">\n               <normaloff>:/icons/playsound.png</normaloff>:/icons/playsound.png</iconset>\n             </property>\n             <property name=\"shortcut\">\n              <string>Alt+S</string>\n             </property>\n             <property name=\"autoRaise\">\n              <bool>false</bool>\n             </property>\n            </widget>\n           </item>\n           <item>\n            <widget class=\"QToolButton\" name=\"sendWordButton\">\n             <property name=\"toolTip\">\n              <string>Send word to main window (Alt+W)</string>\n             </property>\n             <property name=\"text\">\n              <string notr=\"true\">...</string>\n             </property>\n             <property name=\"icon\">\n              <iconset resource=\"resources.qrc\">\n               <normaloff>:/icons/programicon.png</normaloff>:/icons/programicon.png</iconset>\n             </property>\n             <property name=\"shortcut\">\n              <string>Alt+W</string>\n             </property>\n            </widget>\n           </item>\n           <item>\n            <widget class=\"QToolButton\" name=\"sendWordToFavoritesButton\">\n             <property name=\"toolTip\">\n              <string>Add word to Favorites (Ctrl+E)</string>\n             </property>\n             <property name=\"text\">\n              <string notr=\"true\">...</string>\n             </property>\n             <property name=\"icon\">\n              <iconset resource=\"resources.qrc\">\n               <normaloff>:/icons/star.png</normaloff>:/icons/star.png</iconset>\n             </property>\n             <property name=\"shortcut\">\n              <string notr=\"true\">Ctrl+E</string>\n             </property>\n            </widget>\n           </item>\n           <item>\n            <spacer name=\"horizontalSpacer\">\n             <property name=\"orientation\">\n              <enum>Qt::Horizontal</enum>\n             </property>\n             <property name=\"sizeHint\" stdset=\"0\">\n              <size>\n               <width>0</width>\n               <height>20</height>\n              </size>\n             </property>\n            </spacer>\n           </item>\n           <item>\n            <widget class=\"QToolButton\" name=\"showDictionaryBar\">\n             <property name=\"toolTip\">\n              <string>Shows or hides the dictionary bar</string>\n             </property>\n             <property name=\"text\">\n              <string>...</string>\n             </property>\n             <property name=\"icon\">\n              <iconset resource=\"resources.qrc\">\n               <normaloff>:/icons/bookcase.png</normaloff>:/icons/bookcase.png</iconset>\n             </property>\n             <property name=\"checkable\">\n              <bool>true</bool>\n             </property>\n             <property name=\"checked\">\n              <bool>false</bool>\n             </property>\n             <property name=\"autoRaise\">\n              <bool>true</bool>\n             </property>\n            </widget>\n           </item>\n           <item>\n            <widget class=\"QToolButton\" name=\"onTopButton\">\n             <property name=\"toolTip\">\n              <string>Always stay on top of all other windows</string>\n             </property>\n             <property name=\"text\">\n              <string notr=\"true\"/>\n             </property>\n             <property name=\"icon\">\n              <iconset resource=\"resources.qrc\">\n               <normaloff>:/icons/ontop.png</normaloff>:/icons/ontop.png</iconset>\n             </property>\n             <property name=\"checkable\">\n              <bool>true</bool>\n             </property>\n             <property name=\"autoRaise\">\n              <bool>true</bool>\n             </property>\n            </widget>\n           </item>\n           <item>\n            <widget class=\"QToolButton\" name=\"pinButton\">\n             <property name=\"toolTip\">\n              <string>Use this to pin down the window so it would stay on screen,\ncould be resized or managed in other ways.</string>\n             </property>\n             <property name=\"text\">\n              <string>...</string>\n             </property>\n             <property name=\"icon\">\n              <iconset resource=\"resources.qrc\">\n               <normaloff>:/icons/pushpin.png</normaloff>:/icons/pushpin.png</iconset>\n             </property>\n             <property name=\"checkable\">\n              <bool>true</bool>\n             </property>\n             <property name=\"autoRaise\">\n              <bool>true</bool>\n             </property>\n            </widget>\n           </item>\n          </layout>\n         </item>\n        </layout>\n       </item>\n      </layout>\n     </widget>\n    </item>\n   </layout>\n  </widget>\n </widget>\n <customwidgets>\n  <customwidget>\n   <class>GroupComboBox</class>\n   <extends>QComboBox</extends>\n   <header>groupcombobox.hh</header>\n  </customwidget>\n  <customwidget>\n   <class>TranslateBox</class>\n   <extends>QLineEdit</extends>\n   <header>translatebox.hh</header>\n  </customwidget>\n </customwidgets>\n <resources>\n  <include location=\"resources.qrc\"/>\n </resources>\n <connections/>\n</ui>\n"
        },
        {
          "name": "sdict.cc",
          "type": "blob",
          "size": 26.4326171875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"sdict.hh\"\n#include \"btreeidx.hh\"\n#include \"folding.hh\"\n#include \"utf8.hh\"\n#include \"chunkedstorage.hh\"\n#include \"langcoder.hh\"\n#include \"gddebug.hh\"\n#include \"fsencoding.hh\"\n#include \"decompress.hh\"\n#include \"htmlescape.hh\"\n#include \"ftshelpers.hh\"\n#include \"wstring_qt.hh\"\n\n#include <map>\n#include <set>\n#include <string>\n\n#ifdef _MSC_VER\n#include <stub_msvc.h>\n#endif\n\n#include <QString>\n#include <QSemaphore>\n#include <QThreadPool>\n#include <QAtomicInt>\n#include <QDebug>\n#include <QRegExp>\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n#include <QRegularExpression>\n#endif\n\n#include \"ufile.hh\"\n#include \"qt4x5.hh\"\n\nnamespace Sdict {\n\nusing std::map;\nusing std::multimap;\nusing std::pair;\nusing std::set;\nusing std::string;\nusing gd::wstring;\n\nusing BtreeIndexing::WordArticleLink;\nusing BtreeIndexing::IndexedWords;\nusing BtreeIndexing::IndexInfo;\n\nnamespace {\n\nDEF_EX_STR( exNotDctFile, \"Not an Sdictionary file\", Dictionary::Ex )\nDEF_EX_STR( exCantReadFile, \"Can't read file\", Dictionary::Ex )\nDEF_EX_STR( exWordIsTooLarge, \"Enountered a word that is too large:\", Dictionary::Ex )\nDEF_EX_STR( exSuddenEndOfFile, \"Sudden end of file\", Dictionary::Ex )\n\n#pragma pack( push, 1 )\n\n/// DCT file header\nstruct DCT_header\n{\n    char signature[4];\n    char inputLang[3];\n    char outputLang[3];\n    uint8_t compression;\n    uint32_t wordCount;\n    uint32_t shortIndexLength;\n    uint32_t titleOffset;\n    uint32_t copyrightOffset;\n    uint32_t versionOffset;\n    uint32_t shortIndexOffset;\n    uint32_t fullIndexOffset;\n    uint32_t articlesOffset;\n}\n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\nstruct IndexElement\n{\n    uint16_t nextWord;\n    uint16_t previousWord;\n    uint32_t articleOffset;\n}\n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\nenum\n{\n  Signature = 0x43494453, // SDIC on little-endian, CIDS on big-endian\n  CurrentFormatVersion = 1 + BtreeIndexing::FormatVersion + Folding::Version\n};\n\nstruct IdxHeader\n{\n  uint32_t signature; // First comes the signature, SDIC\n  uint32_t formatVersion; // File format version (CurrentFormatVersion)\n  uint32_t chunksOffset; // The offset to chunks' storage\n  uint32_t indexBtreeMaxElements; // Two fields from IndexInfo\n  uint32_t indexRootOffset;\n  uint32_t wordCount;\n  uint32_t articleCount;\n  uint32_t compressionType; // Data compression in file. 0 - no compression, 1 - zip, 2 - bzip2\n  uint32_t langFrom;  // Source language\n  uint32_t langTo;    // Target language\n}\n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\n#pragma pack( pop )\n\nbool indexIsOldOrBad( string const & indexFile )\n{\n  File::Class idx( indexFile, \"rb\" );\n\n  IdxHeader header;\n\n  return idx.readRecords( &header, sizeof( header ), 1 ) != 1 ||\n         header.signature != Signature ||\n         header.formatVersion != CurrentFormatVersion;\n}\n\nclass SdictDictionary: public BtreeIndexing::BtreeDictionary\n{\n    Mutex idxMutex, sdictMutex;\n    File::Class idx;\n    IdxHeader idxHeader;\n    ChunkedStorage::Reader chunks;\n    string dictionaryName;\n    File::Class df;\n\n  public:\n\n    SdictDictionary( string const & id, string const & indexFile,\n                     vector< string > const & dictionaryFiles );\n\n    ~SdictDictionary();\n\n    virtual string getName() throw()\n    { return dictionaryName; }\n\n    virtual map< Dictionary::Property, string > getProperties() throw()\n    { return map< Dictionary::Property, string >(); }\n\n    virtual unsigned long getArticleCount() throw()\n    { return idxHeader.articleCount; }\n\n    virtual unsigned long getWordCount() throw()\n    { return idxHeader.wordCount; }\n\n    inline virtual quint32 getLangFrom() const\n    { return idxHeader.langFrom; }\n\n    inline virtual quint32 getLangTo() const\n    { return idxHeader.langTo; }\n\n    virtual sptr< Dictionary::DataRequest > getArticle( wstring const &,\n                                                        vector< wstring > const & alts,\n                                                        wstring const &,\n                                                        bool ignoreDiacritics )\n      THROW_SPEC( std::exception );\n\n    virtual QString const & getDescription();\n\n    virtual sptr< Dictionary::DataRequest > getSearchResults( QString const & searchString,\n                                                              int searchMode, bool matchCase,\n                                                              int distanceBetweenWords,\n                                                              int maxResults,\n                                                              bool ignoreWordsOrder,\n                                                              bool ignoreDiacritics,\n                                                              QThreadPool * ftsThreadPoolPtr );\n    virtual void getArticleText( uint32_t articleAddress, QString & headword, QString & text );\n\n    virtual void makeFTSIndex(QAtomicInt & isCancelled, bool firstIteration );\n\n    virtual void setFTSParameters( Config::FullTextSearch const & fts )\n    {\n      can_FTS = fts.enabled\n                && !fts.disabledTypes.contains( \"SDICT\", Qt::CaseInsensitive )\n                && ( fts.maxDictionarySize == 0 || getArticleCount() <= fts.maxDictionarySize );\n    }\nprotected:\n\n    void loadIcon() throw();\n\nprivate:\n\n    /// Loads the article.\n    void loadArticle( uint32_t address,\n                      string & articleText );\n    string convert( string const & in_data );\n\n    friend class SdictArticleRequest;\n};\n\nSdictDictionary::SdictDictionary( string const & id,\n                                  string const & indexFile,\n                                  vector< string > const & dictionaryFiles ):\n    BtreeDictionary( id, dictionaryFiles ),\n    idx( indexFile, \"rb\" ),\n    idxHeader( idx.read< IdxHeader >() ),\n    chunks( idx, idxHeader.chunksOffset ),\n    df( dictionaryFiles[ 0 ], \"rb\" )\n{\n    // Read dictionary name\n\n    idx.seek( sizeof( idxHeader ) );\n    vector< char > dName( idx.read< uint32_t >() );\n    if( dName.size() > 0 )\n    {\n      idx.read( &dName.front(), dName.size() );\n      dictionaryName = string( &dName.front(), dName.size() );\n    }\n\n    // Initialize the index\n\n    openIndex( IndexInfo( idxHeader.indexBtreeMaxElements,\n                          idxHeader.indexRootOffset ),\n               idx, idxMutex );\n\n    // Full-text search parameters\n\n    can_FTS = true;\n\n    ftsIdxName = indexFile + \"_FTS\";\n\n    if( !Dictionary::needToRebuildIndex( dictionaryFiles, ftsIdxName )\n        && !FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) )\n      FTS_index_completed.ref();\n}\n\nSdictDictionary::~SdictDictionary()\n{\n    df.close();\n}\n\nvoid SdictDictionary::loadIcon() throw()\n{\n  if ( dictionaryIconLoaded )\n    return;\n\n  QString fileName =\n    QDir::fromNativeSeparators( FsEncoding::decode( getDictionaryFilenames()[ 0 ].c_str() ) );\n\n  // Remove the extension\n  fileName.chop( 3 );\n\n  if( !loadIconFromFile( fileName ) )\n  {\n    // Load failed -- use default icons\n    dictionaryNativeIcon = dictionaryIcon = QIcon(\":/icons/icon32_sdict.png\");\n  }\n\n  dictionaryIconLoaded = true;\n}\n\nstring SdictDictionary::convert( string const & in )\n{\n//    DPRINTF( \"Source>>>>>>>>>>: %s\\n\\n\\n\", in.c_str() );\n\n    string inConverted;\n\n    inConverted.reserve( in.size() );\n\n    bool afterEol = false;\n\n    for( string::const_iterator i = in.begin(), j = in.end(); i != j; ++i )\n    {\n      switch( *i )\n      {\n        case '\\n':\n          afterEol = true;\n          inConverted.append( \"<br/>\" );\n        break;\n\n        case ' ':\n          if ( afterEol )\n          {\n            inConverted.append( \"&nbsp;\" );\n            break;\n          }\n          // Fall-through\n\n        default:\n          inConverted.push_back( *i );\n          afterEol = false;\n      }\n    }\n\n    QString result = QString::fromUtf8( inConverted.c_str(), inConverted.size() );\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n    result.replace( QRegularExpression( \"<\\\\s*(p|br)\\\\s*>\",\n                                        QRegularExpression::CaseInsensitiveOption ),\n                    \"<br/>\" );\n    result.remove( QRegularExpression( \"<\\\\s*/p\\\\s*>\",\n                                       QRegularExpression::CaseInsensitiveOption ) );\n\n    result.replace( QRegularExpression( \"<\\\\s*t\\\\s*>\",\n                                        QRegularExpression::CaseInsensitiveOption ),\n                    \"<span class=\\\"sdict_tr\\\" dir=\\\"ltr\\\">\" );\n    result.replace( QRegularExpression( \"<\\\\s*f\\\\s*>\",\n                                        QRegularExpression::CaseInsensitiveOption ),\n                    \"<span class=\\\"sdict_forms\\\">\" );\n    result.replace( QRegularExpression( \"<\\\\s*/(t|f)\\\\s*>\",\n                                        QRegularExpression::CaseInsensitiveOption ),\n                    \"</span>\" );\n\n    result.replace( QRegularExpression( \"<\\\\s*l\\\\s*>\",\n                                        QRegularExpression::CaseInsensitiveOption ),\n                    \"<ul>\" );\n    result.replace( QRegularExpression( \"<\\\\s*/l\\\\s*>\",\n                                        QRegularExpression::CaseInsensitiveOption ),\n                    \"</ul>\" );\n#else\n    result.replace( QRegExp( \"<\\\\s*(p|br)\\\\s*>\", Qt::CaseInsensitive ), \"<br/>\" );\n    result.remove( QRegExp( \"<\\\\s*/p\\\\s*>\", Qt::CaseInsensitive ) );\n\n    result.replace( QRegExp( \"<\\\\s*t\\\\s*>\", Qt::CaseInsensitive ), \"<span class=\\\"sdict_tr\\\" dir=\\\"ltr\\\">\" );\n    result.replace( QRegExp( \"<\\\\s*f\\\\s*>\", Qt::CaseInsensitive ), \"<span class=\\\"sdict_forms\\\">\" );\n    result.replace( QRegExp( \"<\\\\s*/(t|f)\\\\s*>\", Qt::CaseInsensitive ), \"</span>\" );\n\n    result.replace( QRegExp( \"<\\\\s*l\\\\s*>\", Qt::CaseInsensitive ), \"<ul>\" );\n    result.replace( QRegExp( \"<\\\\s*/l\\\\s*>\", Qt::CaseInsensitive ), \"</ul>\" );\n#endif\n\n    // Links handling\n\n    int n = 0;\n    for( ; ; )\n    {\n      QRegExp start_link_tag( \"<\\\\s*r\\\\s*>\", Qt::CaseInsensitive );\n      QRegExp end_link_tag( \"<\\\\s*/r\\\\s*>\", Qt::CaseInsensitive );\n\n      n = result.indexOf( start_link_tag, n );\n      if( n < 0 )\n        break;\n\n      int end = result.indexOf( end_link_tag, n );\n      if( end < 0 )\n        break;\n\n      int tag_len = start_link_tag.cap().length();\n      QString link_text = result.mid( n + tag_len, end - n - tag_len );\n\n      result.replace( end, end_link_tag.cap().length(), \"</a>\" );\n      result.replace( n, tag_len, QString( \"<a class=\\\"sdict_wordref\\\" href=\\\"bword:\" ) + link_text + \"\\\">\");\n    }\n\n    // Adjust text direction for lines\n\n    n = 0;\n    bool b = true;\n    while( b )\n    {\n      int next = result.indexOf( \"<br/>\", n );\n      if( next < 0 )\n      {\n        next = result.length();\n        b = false;\n      }\n\n      if( !result.mid( n, next - n ).contains( '<' ) )\n      {\n        if( Html::unescape( result.mid( n, next - n ) ).isRightToLeft() != isToLanguageRTL() )\n        {\n          result.insert( next, \"</span>\" );\n          result.insert( n,\n                         QString( \"<span dir = \\\"\" )\n                         + ( isToLanguageRTL() ? \"ltr\" : \"rtl\" )\n                         + \"\\\">\"\n                        );\n          next = result.indexOf( \"<br/>\", n );\n        }\n      }\n\n      n = next + 5;\n    }\n\n    return result.toUtf8().data();\n}\n\nvoid SdictDictionary::loadArticle( uint32_t address,\n                                   string & articleText )\n{\n    uint32_t articleOffset = address;\n    uint32_t articleSize;\n\n    vector< char > articleBody;\n\n    {\n      Mutex::Lock _( sdictMutex );\n      df.seek( articleOffset );\n      df.read( &articleSize, sizeof(articleSize) );\n      articleBody.resize( articleSize );\n      df.read( &articleBody.front(), articleSize );\n    }\n\n    if ( articleBody.empty() )\n      throw exCantReadFile( getDictionaryFilenames()[ 0 ] );\n\n    if( idxHeader.compressionType == 1 )\n        articleText = decompressZlib( articleBody.data(), articleSize );\n    else if( idxHeader.compressionType == 2 )\n        articleText = decompressBzip2( articleBody.data(), articleSize );\n    else\n        articleText = string( articleBody.data(), articleSize );\n\n    articleText = convert( articleText );\n\n    string div = \"<div class=\\\"sdict\\\"\";\n    if( isToLanguageRTL() )\n      div += \" dir=\\\"rtl\\\"\";\n    div += \">\";\n\n    articleText.insert( 0, div );\n    articleText.append( \"</div>\" );\n}\n\nvoid SdictDictionary::makeFTSIndex( QAtomicInt & isCancelled, bool firstIteration )\n{\n  if( !( Dictionary::needToRebuildIndex( getDictionaryFilenames(), ftsIdxName )\n         || FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) ) )\n    FTS_index_completed.ref();\n\n  if( haveFTSIndex() )\n    return;\n\n  if( ensureInitDone().size() )\n    return;\n\n  if( firstIteration && getArticleCount() > FTS::MaxDictionarySizeForFastSearch )\n    return;\n\n  gdDebug( \"SDict: Building the full-text index for dictionary: %s\\n\",\n           getName().c_str() );\n\n  try\n  {\n    FtsHelpers::makeFTSIndex( this, isCancelled );\n    FTS_index_completed.ref();\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"SDict: Failed building full-text search index for \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n    QFile::remove( FsEncoding::decode( ftsIdxName.c_str() ) );\n  }\n}\n\nvoid SdictDictionary::getArticleText( uint32_t articleAddress, QString & headword, QString & text )\n{\n  try\n  {\n    string articleStr;\n    headword.clear();\n    text.clear();\n\n    loadArticle( articleAddress, articleStr );\n\n    try\n    {\n      wstring wstr = Utf8::decode( articleStr );\n      text = Html::unescape( gd::toQString( wstr ) );\n    }\n    catch( std::exception & )\n    {\n    }\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"SDict: Failed retrieving article from \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n  }\n}\n\nsptr< Dictionary::DataRequest > SdictDictionary::getSearchResults( QString const & searchString,\n                                                                   int searchMode, bool matchCase,\n                                                                   int distanceBetweenWords,\n                                                                   int maxResults,\n                                                                   bool ignoreWordsOrder,\n                                                                   bool ignoreDiacritics,\n                                                                   QThreadPool * ftsThreadPoolPtr )\n{\n  return new FtsHelpers::FTSResultsRequest( *this, searchString,searchMode, matchCase, distanceBetweenWords, maxResults, ignoreWordsOrder, ignoreDiacritics, ftsThreadPoolPtr );\n}\n\n/// SdictDictionary::getArticle()\n\nclass SdictArticleRequest;\n\nclass SdictArticleRequestRunnable: public QRunnable\n{\n  SdictArticleRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  SdictArticleRequestRunnable( SdictArticleRequest & r_,\n                               QSemaphore & hasExited_ ): r( r_ ),\n                                                          hasExited( hasExited_ )\n  {}\n\n  ~SdictArticleRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass SdictArticleRequest: public Dictionary::DataRequest\n{\n  friend class SdictArticleRequestRunnable;\n\n  wstring word;\n  vector< wstring > alts;\n  SdictDictionary & dict;\n  bool ignoreDiacritics;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  SdictArticleRequest( wstring const & word_,\n                       vector< wstring > const & alts_,\n                       SdictDictionary & dict_, bool ignoreDiacritics_ ):\n    word( word_ ), alts( alts_ ), dict( dict_ ), ignoreDiacritics( ignoreDiacritics_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new SdictArticleRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by DslArticleRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~SdictArticleRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid SdictArticleRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid SdictArticleRequest::run()\n{\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  vector< WordArticleLink > chain = dict.findArticles( word, ignoreDiacritics );\n\n  for( unsigned x = 0; x < alts.size(); ++x )\n  {\n    /// Make an additional query for each alt\n\n    vector< WordArticleLink > altChain = dict.findArticles( alts[ x ], ignoreDiacritics );\n\n    chain.insert( chain.end(), altChain.begin(), altChain.end() );\n  }\n\n  multimap< wstring, pair< string, string > > mainArticles, alternateArticles;\n\n  set< uint32_t > articlesIncluded; // Some synonims make it that the articles\n                                    // appear several times. We combat this\n                                    // by only allowing them to appear once.\n\n  wstring wordCaseFolded = Folding::applySimpleCaseOnly( word );\n  if( ignoreDiacritics )\n    wordCaseFolded = Folding::applyDiacriticsOnly( wordCaseFolded );\n\n  for( unsigned x = 0; x < chain.size(); ++x )\n  {\n    if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    {\n      finish();\n      return;\n    }\n\n    if ( articlesIncluded.find( chain[ x ].articleOffset ) != articlesIncluded.end() )\n      continue; // We already have this article in the body.\n\n    // Now grab that article\n\n    string headword, articleText;\n\n    headword = chain[ x ].word;\n\n    try\n    {\n      dict.loadArticle( chain[ x ].articleOffset, articleText );\n\n      // Ok. Now, does it go to main articles, or to alternate ones? We list\n      // main ones first, and alternates after.\n\n      // We do the case-folded comparison here.\n\n      wstring headwordStripped =\n        Folding::applySimpleCaseOnly( Utf8::decode( headword ) );\n      if( ignoreDiacritics )\n        headwordStripped = Folding::applyDiacriticsOnly( headwordStripped );\n\n      multimap< wstring, pair< string, string > > & mapToUse =\n        ( wordCaseFolded == headwordStripped ) ?\n          mainArticles : alternateArticles;\n\n      mapToUse.insert( pair< wstring, pair< string, string > >(\n        Folding::applySimpleCaseOnly( Utf8::decode( headword ) ),\n        pair< string, string >( headword, articleText ) ) );\n\n      articlesIncluded.insert( chain[ x ].articleOffset );\n    }\n    catch( std::exception &ex )\n    {\n      gdWarning( \"SDict: Failed loading article from \\\"%s\\\", reason: %s\\n\", dict.getName().c_str(), ex.what() );\n    }\n  }\n\n  if ( mainArticles.empty() && alternateArticles.empty() )\n  {\n    // No such word\n    finish();\n    return;\n  }\n\n  string result;\n\n  multimap< wstring, pair< string, string > >::const_iterator i;\n\n  for( i = mainArticles.begin(); i != mainArticles.end(); ++i )\n  {\n      result += dict.isFromLanguageRTL() ? \"<h3 dir=\\\"rtl\\\">\" : \"<h3>\";\n      result += i->second.first;\n      result += \"</h3>\";\n      result += i->second.second;\n  }\n\n  for( i = alternateArticles.begin(); i != alternateArticles.end(); ++i )\n  {\n      result += dict.isFromLanguageRTL() ? \"<h3 dir=\\\"rtl\\\">\" : \"<h3>\";\n      result += i->second.first;\n      result += \"</h3>\";\n      if( dict.isToLanguageRTL() )\n        result += \"<span dir=\\\"rtl\\\">\";\n      result += i->second.second;\n      if( dict.isToLanguageRTL() )\n        result += \"</span>\";\n  }\n\n  Mutex::Lock _( dataMutex );\n\n  data.resize( result.size() );\n\n  memcpy( &data.front(), result.data(), result.size() );\n\n  hasAnyData = true;\n\n  finish();\n}\n\nsptr< Dictionary::DataRequest > SdictDictionary::getArticle( wstring const & word,\n                                                             vector< wstring > const & alts,\n                                                             wstring const &,\n                                                             bool ignoreDiacritics )\n  THROW_SPEC( std::exception )\n{\n  return new SdictArticleRequest( word, alts, *this, ignoreDiacritics );\n}\n\nQString const& SdictDictionary::getDescription()\n{\n  if( !dictionaryDescription.isEmpty() )\n    return dictionaryDescription;\n\n  dictionaryDescription = QString( QObject::tr( \"Title: %1%2\" ) )\n                          .arg( QString::fromUtf8( getName().c_str() ) )\n                          .arg( \"\\n\\n\" );\n\n  try\n  {\n    Mutex::Lock _( sdictMutex );\n\n    DCT_header dictHeader;\n\n    df.seek( 0 );\n    if( df.readRecords( &dictHeader, sizeof(dictHeader), 1 ) != 1 )\n      throw exCantReadFile( getDictionaryFilenames()[ 0 ] );\n\n    int compression = dictHeader.compression & 0x0F;\n\n    vector< char > data;\n    uint32_t size;\n    string str;\n\n    df.seek( dictHeader.copyrightOffset );\n    df.read( &size, sizeof( size ) );\n    data.resize( size );\n    df.read( &data.front(), size );\n\n    if( compression == 1 )\n      str = decompressZlib( data.data(), size );\n    else if( compression == 2 )\n      str = decompressBzip2( data.data(), size );\n    else\n      str = string( data.data(), size );\n\n    dictionaryDescription += QString( QObject::tr( \"Copyright: %1%2\" ) )\n                             .arg( QString::fromUtf8( str.c_str(), str.size() ) )\n                             .arg( \"\\n\\n\" );\n\n    df.seek( dictHeader.versionOffset );\n    df.read( &size, sizeof( size ) );\n    data.resize( size );\n    df.read( &data.front(), size );\n\n    if( compression == 1 )\n      str = decompressZlib( data.data(), size );\n    else if( compression == 2 )\n      str = decompressBzip2( data.data(), size );\n    else\n      str = string( data.data(), size );\n\n    dictionaryDescription += QString( QObject::tr( \"Version: %1%2\" ) )\n                             .arg( QString::fromUtf8( str.c_str(), str.size() ) )\n                             .arg( \"\\n\\n\" );\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"SDict: Failed description reading for \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n  }\n\n  if( dictionaryDescription.isEmpty() )\n    dictionaryDescription = \"NONE\";\n\n  return dictionaryDescription;\n}\n\n} // anonymous namespace\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing & initializing )\n  THROW_SPEC( std::exception )\n{\n  vector< sptr< Dictionary::Class > > dictionaries;\n\n  for( vector< string >::const_iterator i = fileNames.begin(); i != fileNames.end();\n       ++i )\n  {\n      // Skip files with the extensions different to .dct to speed up the\n      // scanning\n      if ( i->size() < 4 ||\n          strcasecmp( i->c_str() + ( i->size() - 4 ), \".dct\" ) != 0 )\n        continue;\n\n      // Got the file -- check if we need to rebuid the index\n\n      vector< string > dictFiles( 1, *i );\n\n      string dictId = Dictionary::makeDictionaryId( dictFiles );\n\n      string indexFile = indicesDir + dictId;\n\n      if ( Dictionary::needToRebuildIndex( dictFiles, indexFile ) ||\n           indexIsOldOrBad( indexFile ) )\n      {\n        try\n        {\n          gdDebug( \"SDict: Building the index for dictionary: %s\\n\", i->c_str() );\n\n          File::Class df( *i, \"rb\" );\n\n          DCT_header dictHeader;\n\n          df.read( &dictHeader, sizeof(dictHeader) );\n          if( strncmp( dictHeader.signature, \"sdct\", 4 ) )\n          {\n              gdWarning( \"File \\\"%s\\\" is not valid SDictionary file\", i->c_str() );\n              continue;\n          }\n          int compression = dictHeader.compression & 0x0F;\n\n          vector< char > data;\n          uint32_t size;\n\n          df.seek( dictHeader.titleOffset );\n          df.read( &size, sizeof( size ) );\n          data.resize( size );\n          df.read( &data.front(), size );\n\n          string dictName;\n\n          if( compression == 1 )\n              dictName = decompressZlib( data.data(), size );\n          else if( compression == 2 )\n              dictName = decompressBzip2( data.data(), size );\n          else\n              dictName = string( data.data(), size );\n\n          initializing.indexingDictionary( dictName );\n\n          File::Class idx( indexFile, \"wb\" );\n          IdxHeader idxHeader;\n          memset( &idxHeader, 0, sizeof( idxHeader ) );\n\n          // We write a dummy header first. At the end of the process the header\n          // will be rewritten with the right values.\n\n          idx.write( idxHeader );\n\n          idx.write( (uint32_t) dictName.size() );\n          idx.write( dictName.data(), dictName.size() );\n\n          IndexedWords indexedWords;\n\n          ChunkedStorage::Writer chunks( idx );\n\n          uint32_t wordCount = 0;\n          set< uint32_t > articleOffsets;\n          uint32_t pos = dictHeader.fullIndexOffset;\n\n          for( uint32_t j = 0; j < dictHeader.wordCount; j++ )\n          {\n            IndexElement el;\n            df.seek( pos );\n            df.read( &el, sizeof(el) );\n            uint32_t articleOffset = dictHeader.articlesOffset + el.articleOffset;\n            size = el.nextWord - sizeof(el);\n            if( el.nextWord < sizeof(el) )\n                break;\n            wordCount++;\n            data.resize( size );\n            df.read( &data.front(), size );\n\n            if( articleOffsets.find( articleOffset ) == articleOffsets.end() )\n                articleOffsets.insert( articleOffset );\n\n            // Insert new entry\n\n            indexedWords.addWord( Utf8::decode( string( data.data(), size ) ), articleOffset);\n\n            pos += el.nextWord;\n          }\n          // Finish with the chunks\n\n          idxHeader.chunksOffset = chunks.finish();\n\n          // Build index\n\n          IndexInfo idxInfo = BtreeIndexing::buildIndex( indexedWords, idx );\n\n          idxHeader.indexBtreeMaxElements = idxInfo.btreeMaxElements;\n          idxHeader.indexRootOffset = idxInfo.rootOffset;\n\n          indexedWords.clear(); // Release memory -- no need for this data\n\n          // That concludes it. Update the header.\n\n          idxHeader.signature = Signature;\n          idxHeader.formatVersion = CurrentFormatVersion;\n\n          idxHeader.articleCount = articleOffsets.size();\n          idxHeader.wordCount = wordCount;\n\n          idxHeader.langFrom = LangCoder::code2toInt( dictHeader.inputLang );\n          idxHeader.langTo = LangCoder::code2toInt( dictHeader.outputLang );\n          idxHeader.compressionType = compression;\n\n          idx.rewind();\n\n          idx.write( &idxHeader, sizeof( idxHeader ) );\n        }\n        catch( std::exception & e )\n        {\n          gdWarning( \"Sdictionary dictionary indexing failed: %s, error: %s\\n\",\n                     i->c_str(), e.what() );\n          continue;\n        }\n        catch( ... )\n        {\n          qWarning( \"Sdictionary dictionary indexing failed\\n\" );\n          continue;\n        }\n      } // if need to rebuild\n      try\n      {\n        dictionaries.push_back( new SdictDictionary( dictId,\n                                                     indexFile,\n                                                     dictFiles ) );\n      }\n      catch( std::exception & e )\n      {\n        gdWarning( \"Sdictionary dictionary initializing failed: %s, error: %s\\n\",\n                   i->c_str(), e.what() );\n      }\n  }\n  return dictionaries;\n}\n\n}\n"
        },
        {
          "name": "sdict.hh",
          "type": "blob",
          "size": 0.62109375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __SDICT_HH_INCLUDED__\n#define __SDICT_HH_INCLUDED__\n\n#include \"dictionary.hh\"\n\n/// Support for the Sdict dictionaries.\nnamespace Sdict {\n\nusing std::vector;\nusing std::string;\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing & )\n  THROW_SPEC( std::exception );\n\n}\n\n#endif\n"
        },
        {
          "name": "searchpanewidget.hh",
          "type": "blob",
          "size": 0.515625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __SEARCHPANEWIDGET_HH_INCLUDED__\n#define __SEARCHPANEWIDGET_HH_INCLUDED__\n\n#include <QWidget>\n#include <QSize>\n\n/// A widget holding the contents of the 'Search pane' docklet.\nclass SearchPaneWidget: public QWidget\n{\npublic:\n\n  SearchPaneWidget( QWidget * parent = 0 ): QWidget( parent )\n  {}\n\n  virtual QSize sizeHint() const\n  { return QSize( 204, 204 ); }\n\n};\n\n#endif\n\n"
        },
        {
          "name": "slob.cc",
          "type": "blob",
          "size": 51.52734375,
          "content": "/* This file is (c) 2015 Abs62\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifdef MAKE_ZIM_SUPPORT\n\n#include \"slob.hh\"\n#include \"btreeidx.hh\"\n#include \"fsencoding.hh\"\n#include \"folding.hh\"\n#include \"categorized_logging.hh\"\n#include \"gddebug.hh\"\n#include \"utf8.hh\"\n#include \"decompress.hh\"\n#include \"langcoder.hh\"\n#include \"wstring.hh\"\n#include \"wstring_qt.hh\"\n#include \"ftshelpers.hh\"\n#include \"htmlescape.hh\"\n#include \"filetype.hh\"\n#include \"tiff.hh\"\n#include \"qt4x5.hh\"\n\n#ifdef _MSC_VER\n#include <stub_msvc.h>\n#endif\n\n#include <QString>\n#include <QFile>\n#include <QFileInfo>\n#include <QDir>\n#include <QTextCodec>\n#include <QMap>\n#include <QPair>\n#include <QRegExp>\n#include <QProcess>\n#include <QVector>\n#include <QtAlgorithms>\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n#include <QRegularExpression>\n#endif\n\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n\nnamespace Slob {\n\nusing std::string;\nusing std::map;\nusing std::vector;\nusing std::multimap;\nusing std::pair;\nusing std::set;\nusing gd::wstring;\n\nusing BtreeIndexing::WordArticleLink;\nusing BtreeIndexing::IndexedWords;\nusing BtreeIndexing::IndexInfo;\n\nDEF_EX_STR( exNotSlobFile, \"Not an Slob file\", Dictionary::Ex )\nDEF_EX_STR( exCantReadFile, \"Can't read file\", Dictionary::Ex )\nDEF_EX_STR( exCantDecodeFile, \"Can't decode file\", Dictionary::Ex )\nDEF_EX_STR( exNoCodecFound, \"No text codec found\", Dictionary::Ex )\nDEF_EX( exUserAbort, \"User abort\", Dictionary::Ex )\nDEF_EX( exNoResource, \"No resource found\", Dictionary::Ex )\n\n#pragma pack( push, 1 )\n\nenum\n{\n  Signature = 0x58424C53, // SLBX on little-endian, XBLS on big-endian\n  CurrentFormatVersion = 2 + BtreeIndexing::FormatVersion + Folding::Version\n};\n\nstruct IdxHeader\n{\n  quint32 signature; // First comes the signature, SLBX\n  quint32 formatVersion; // File format version (CurrentFormatVersion)\n  quint32 indexBtreeMaxElements; // Two fields from IndexInfo\n  quint32 indexRootOffset;\n  quint32 resourceIndexBtreeMaxElements; // Two fields from IndexInfo\n  quint32 resourceIndexRootOffset;\n  quint32 wordCount;\n  quint32 articleCount;\n  quint32 langFrom;  // Source language\n  quint32 langTo;    // Target language\n}\n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\n#pragma pack( pop )\n\nconst char SLOB_MAGIC[ 8 ] = { 0x21, 0x2d, 0x31, 0x53, 0x4c, 0x4f, 0x42, 0x1f };\n\nstruct RefEntry\n{\n  QString key;\n  quint32 itemIndex;\n  quint16 binIndex;\n  QString fragment;\n};\n\nbool indexIsOldOrBad( string const & indexFile )\n{\n  File::Class idx( indexFile, \"rb\" );\n\n  IdxHeader header;\n\n  return idx.readRecords( &header, sizeof( header ), 1 ) != 1 ||\n         header.signature != Signature ||\n         header.formatVersion != CurrentFormatVersion;\n}\n\n\nclass SlobFile\n{\npublic:\n  typedef QPair< quint64, quint32 > RefEntryOffsetItem;\n  typedef QVector< RefEntryOffsetItem > RefOffsetsVector;\n\nprivate:\n  enum Compressions\n  { UNKNOWN = 0, NONE, ZLIB, BZ2, LZMA2 };\n\n  QFile file;\n  QString fileName, dictionaryName;\n  Compressions compression;\n  QString encoding;\n  unsigned char uuid[ 16 ];\n  QTextCodec *codec;\n  QMap< QString, QString > tags;\n  QVector< QString > contentTypes;\n  quint32 blobCount;\n  quint64 storeOffset, fileSize, refsOffset;\n  quint32 refsCount, itemsCount;\n  quint64 itemsOffset, itemsDataOffset;\n  quint32 currentItem;\n  quint32 contentTypesCount;\n  string currentItemData;\n  RefOffsetsVector refsOffsetVector;\n\n  QString readTinyText();\n  QString readText();\n  QString readLargeText();\n  QString readString( unsigned length );\n\npublic:\n  SlobFile() :\n    compression( UNKNOWN )\n  , codec( 0 )\n  , blobCount( 0 )\n  , storeOffset( 0 )\n  , fileSize( 0 )\n  , refsOffset( 0 )\n  , refsCount( 0 )\n  , itemsCount( 0 )\n  , itemsOffset( 0 )\n  , itemsDataOffset( 0 )\n  , currentItem( 0xFFFFFFFF )\n  , contentTypesCount( 0 )\n  {}\n\n  ~SlobFile();\n\n  Compressions getCompression() const\n  { return compression; }\n\n  QString const & getEncoding() const\n  { return encoding; }\n\n  QString const & getDictionaryName() const\n  { return dictionaryName; }\n\n  quint32 blobsCount() const\n  { return blobCount; }\n\n  quint64 dataOffset() const\n  { return storeOffset; }\n\n  quint32 getRefsCount() const\n  { return refsCount; }\n\n  quint32 getContentTypesCount() const\n  { return contentTypesCount; }\n\n  QTextCodec * getCodec() const\n  { return codec; }\n\n  const RefOffsetsVector & getSortedRefOffsets();\n\n  void clearRefOffsets()\n  { refsOffsetVector.clear(); }\n\n  QString getContentType( quint8 content_id ) const\n  { return content_id < contentTypes.size() ? contentTypes[ content_id ] : QString(); }\n\n  QMap< QString, QString > const & getTags() const\n  { return tags; }\n\n  void open( const QString & name );\n\n  void getRefEntryAtOffset(quint64 offset, RefEntry & entry );\n\n  void getRefEntry(quint32 ref_nom, RefEntry & entry );\n\n  quint8 getItem( RefEntry const & entry, string * data );\n};\n\nSlobFile::~SlobFile()\n{\n  file.close();\n}\n\nQString SlobFile::readString( unsigned length )\n{\n  QByteArray data = file.read( length );\n  QString str;\n\n  if( codec != 0 && !data.isEmpty() )\n    str = codec->toUnicode( data );\n  else\n    str = QString( data );\n\n  char term = 0;\n  int n = str.indexOf( term );\n  if( n >= 0 )\n    str.resize( n );\n\n  return str;\n}\n\nQString SlobFile::readTinyText()\n{\n  unsigned char len;\n  if( !file.getChar( ( char * )&len ) )\n  {\n    QString error = fileName + \": \" + file.errorString();\n    throw exCantReadFile( string( error.toUtf8().data() ) );\n  }\n  return readString( len );\n}\n\nQString SlobFile::readText()\n{\n  quint16 len;\n  if( file.read( ( char * )&len, sizeof( len ) ) != sizeof( len ) )\n  {\n    QString error = fileName + \": \" + file.errorString();\n    throw exCantReadFile( string( error.toUtf8().data() ) );\n  }\n  return readString( qFromBigEndian( len ) );\n}\n\nQString SlobFile::readLargeText()\n{\n  quint32 len;\n  if( file.read( ( char * )&len, sizeof( len ) ) != sizeof( len ) )\n  {\n    QString error = fileName + \": \" + file.errorString();\n    throw exCantReadFile( string( error.toUtf8().data() ) );\n  }\n  return readString( qFromBigEndian( len ) );\n}\n\nvoid SlobFile::open( const QString & name )\n{\nQString error( name + \": \" );\n\n  if( file.isOpen() )\n    file.close();\n\n  fileName = name;\n\n  file.setFileName( name );\n\n  {\n    QFileInfo fi( name );\n    dictionaryName = fi.fileName();\n  }\n\n  for( ; ; )\n  {\n\n    if( !file.open( QFile::ReadOnly ) )\n      break;\n\n    char magic[ 8 ];\n    if( file.read( magic, sizeof( magic ) ) != sizeof( magic ) )\n      break;\n\n    if( memcmp( magic, SLOB_MAGIC, sizeof( magic ) ) != 0 )\n      throw exNotSlobFile( string( name.toUtf8().data() ) );\n\n    if( file.read( ( char * )uuid, sizeof( uuid ) ) != sizeof( uuid ) )\n      break;\n\n    // Read encoding\n\n    encoding = readTinyText();\n\n    codec = QTextCodec::codecForName( encoding.toLatin1() );\n    if( codec == 0 )\n    {\n      error = QString( \"for encoding \\\"\") + encoding + \"\\\"\";\n      throw exNoCodecFound( string( error.toUtf8().data() ) );\n    }\n\n    // Read compression type\n\n    QString compr = readTinyText();\n\n    if( compr.compare( \"zlib\", Qt::CaseInsensitive ) == 0 )\n      compression = ZLIB;\n    else\n    if( compr.compare( \"bz2\", Qt::CaseInsensitive ) == 0 )\n      compression = BZ2;\n    else\n    if( compr.compare( \"lzma2\", Qt::CaseInsensitive ) == 0 )\n      compression = LZMA2;\n    else\n    if( compr.isEmpty() || compr.compare( \"none\", Qt::CaseInsensitive ) == 0 )\n      compression = NONE;\n\n    // Read tags\n\n    unsigned char count;\n    if( !file.getChar( ( char * )&count ) )\n      break;\n\n    for( unsigned i = 0; i < count; i++ )\n    {\n      QString key = readTinyText();\n      QString value = readTinyText();\n      tags[ key ] = value;\n\n      if( key.compare( \"label\", Qt::CaseInsensitive ) == 0\n          || key.compare( \"name\", Qt::CaseInsensitive ) == 0)\n        dictionaryName = value;\n    }\n\n    // Read content types\n\n    if( !file.getChar( ( char * )&count ) )\n      break;\n\n    for( unsigned i = 0; i < count; i++ )\n    {\n      QString type = readText();\n      contentTypes.append( type );\n    }\n    contentTypesCount = count;\n\n    // Read data parameters\n\n    quint32 cnt;\n    if( file.read( ( char * )&cnt, sizeof( cnt ) ) != sizeof( cnt ) )\n      break;\n    blobCount = qFromBigEndian( cnt );\n\n    quint64 tmp;\n    if( file.read( ( char * )&tmp, sizeof( tmp ) ) != sizeof( tmp ) )\n      break;\n    storeOffset = qFromBigEndian( tmp );\n\n    if( file.read( ( char * )&tmp, sizeof( tmp ) ) != sizeof( tmp ) )\n      break;\n    fileSize = qFromBigEndian( tmp );\n\n    if( file.read( ( char * )&cnt, sizeof( cnt ) ) != sizeof( cnt ) )\n      break;\n    refsCount = qFromBigEndian( cnt );\n\n    refsOffset = file.pos();\n\n    if( !file.seek( storeOffset ) )\n      break;\n\n    if( file.read( ( char * )&cnt, sizeof( cnt ) ) != sizeof( cnt ) )\n      break;\n    itemsCount = qFromBigEndian( cnt );\n\n    itemsOffset = storeOffset + sizeof( itemsCount );\n    itemsDataOffset = itemsOffset + itemsCount * sizeof( quint64 );\n\n    return;\n  }\n  error += file.errorString();\n  throw exCantReadFile( string( error.toUtf8().data() ) );\n}\n\nconst SlobFile::RefOffsetsVector & SlobFile::getSortedRefOffsets()\n{\n  quint64 tmp;\n  qint64 size = refsCount * sizeof( quint64 );\n  quint64 base = refsOffset + size;\n\n  refsOffsetVector.clear();\n  refsOffsetVector.reserve( refsCount );\n\n  for( ; ; )\n  {\n    QByteArray offsets;\n    offsets.resize( size );\n\n    if( !file.seek( refsOffset ) || file.read( offsets.data(), size ) != size )\n      break;\n\n    for( quint32 i = 0; i < refsCount; i++ )\n    {\n      memcpy( &tmp, offsets.data() + i * sizeof( quint64 ), sizeof( tmp ) );\n      refsOffsetVector.append( RefEntryOffsetItem( base + qFromBigEndian( tmp ), i ) );\n    }\n\n    std::sort( refsOffsetVector.begin(), refsOffsetVector.end() );\n    return refsOffsetVector;\n  }\n  QString error = fileName + \": \" + file.errorString();\n  throw exCantReadFile( string( error.toUtf8().data() ) );\n}\n\nvoid SlobFile::getRefEntryAtOffset( quint64 offset, RefEntry & entry )\n{\n  for( ; ; )\n  {\n    if( !file.seek( offset ) )\n      break;\n\n    entry.key = readText();\n\n    quint32 index;\n    if( file.read( ( char * )&index, sizeof( index ) ) != sizeof( index ) )\n      break;\n    entry.itemIndex = qFromBigEndian( index );\n\n    quint16 binIndex;\n    if( file.read( ( char * )&binIndex, sizeof( binIndex ) ) != sizeof( binIndex ) )\n      break;\n    entry.binIndex = qFromBigEndian( binIndex );\n\n    entry.fragment = readTinyText();\n\n    return;\n  }\n  QString error = fileName + \": \" + file.errorString();\n  throw exCantReadFile( string( error.toUtf8().data() ) );\n}\n\nvoid SlobFile::getRefEntry( quint32 ref_nom, RefEntry & entry )\n{\n  quint64 pos = refsOffset + ref_nom * sizeof( quint64 );\n  quint64 offset, tmp;\n\n  for( ; ; )\n  {\n    if( !file.seek( pos ) || file.read( ( char * )&tmp, sizeof( tmp ) ) != sizeof( tmp ) )\n      break;\n\n    offset = qFromBigEndian( tmp ) + refsOffset + refsCount * sizeof( quint64 );\n\n    getRefEntryAtOffset( offset, entry );\n\n    return;\n  }\n  QString error = fileName + \": \" + file.errorString();\n  throw exCantReadFile( string( error.toUtf8().data() ) );\n}\n\nquint8 SlobFile::getItem( RefEntry const & entry, string * data )\n{\n  quint64 pos = itemsOffset + entry.itemIndex * sizeof( quint64 );\n  quint64 offset, tmp;\n\n  for( ; ; )\n  {\n    // Read item data types\n\n    if( !file.seek( pos ) || file.read( ( char * )&tmp, sizeof( tmp ) ) != sizeof( tmp ) )\n      break;\n\n    offset = qFromBigEndian( tmp ) + itemsDataOffset;\n\n    if( !file.seek( offset ) )\n      break;\n\n    quint32 bins, bins_be;\n    if( file.read( ( char * )&bins_be, sizeof( bins_be ) ) != sizeof( bins_be ) )\n      break;\n    bins = qFromBigEndian( bins_be );\n\n    if( entry.binIndex >= bins )\n      return 0xFF;\n\n    QVector< quint8 > ids;\n    ids.resize( bins );\n    if( file.read( ( char * )ids.data(), bins ) != bins )\n      break;\n\n    quint8 id = ids[ entry.binIndex ];\n\n    if( id >= (unsigned)contentTypes.size() )\n      return 0xFF;\n\n    if( data != 0 )\n    {\n      // Read item data\n      if( currentItem != entry.itemIndex )\n      {\n        currentItemData.clear();\n        quint32 length, length_be;\n        if( file.read( ( char * )&length_be, sizeof( length_be ) ) != sizeof( length_be ) )\n          break;\n        length = qFromBigEndian( length_be );\n\n        QByteArray compressedData = file.read( length );\n\n        if( compression == NONE )\n          currentItemData = string( compressedData.data(), compressedData.length() );\n        else\n        if( compression == ZLIB )\n          currentItemData = decompressZlib( compressedData.data(), length );\n        else\n        if( compression == BZ2 )\n          currentItemData = decompressBzip2( compressedData.data(), length );\n        else\n          currentItemData = decompressLzma2( compressedData.data(), length, true );\n\n        if( currentItemData.empty() )\n        {\n          currentItem = 0xFFFFFFFF;\n          return 0xFF;\n        }\n        currentItem = entry.itemIndex;\n      }\n\n      // Find bin data inside item\n\n      const char * ptr = currentItemData.c_str();\n      quint32 pos = entry.binIndex * sizeof( quint32 );\n\n      if( pos >= currentItemData.length() - sizeof( quint32 ) )\n        return 0xFF;\n\n      quint32 offset, offset_be;\n      memcpy( &offset_be, ptr + pos, sizeof( offset_be ) );\n      offset = qFromBigEndian( offset_be );\n\n      pos = bins * sizeof( quint32 ) + offset;\n\n      if( pos >= currentItemData.length() - sizeof( quint32 ) )\n        return 0xFF;\n\n      quint32 length, len_be;\n      memcpy( &len_be, ptr + pos, sizeof( len_be ) );\n      length = qFromBigEndian( len_be );\n\n      *data = currentItemData.substr( pos + sizeof( len_be ), length );\n    }\n\n    return ids[ entry.binIndex ];\n  }\n  QString error = fileName + \": \" + file.errorString();\n  throw exCantReadFile( string( error.toUtf8().data() ) );\n}\n\n// SlobDictionary\n\nclass SlobDictionary: public BtreeIndexing::BtreeDictionary\n{\n    Mutex idxMutex;\n    Mutex slobMutex, idxResourceMutex;\n    File::Class idx;\n    BtreeIndex resourceIndex;\n    IdxHeader idxHeader;\n    string dictionaryName;\n    SlobFile sf;\n    QString texCgiPath, texCachePath;\n\n  public:\n\n    SlobDictionary( string const & id, string const & indexFile,\n                    vector< string > const & dictionaryFiles );\n\n    ~SlobDictionary();\n\n    virtual string getName() throw()\n    { return dictionaryName; }\n\n    virtual map< Dictionary::Property, string > getProperties() throw()\n    { return map< Dictionary::Property, string >(); }\n\n    virtual unsigned long getArticleCount() throw()\n    { return idxHeader.articleCount; }\n\n    virtual unsigned long getWordCount() throw()\n    { return idxHeader.wordCount; }\n\n    inline virtual quint32 getLangFrom() const\n    { return idxHeader.langFrom; }\n\n    inline virtual quint32 getLangTo() const\n    { return idxHeader.langTo; }\n\n    virtual sptr< Dictionary::DataRequest > getArticle( wstring const &,\n                                                        vector< wstring > const & alts,\n                                                        wstring const &,\n                                                        bool ignoreDiacritics )\n      THROW_SPEC( std::exception );\n\n    virtual sptr< Dictionary::DataRequest > getResource( string const & name )\n      THROW_SPEC( std::exception );\n\n    virtual QString const& getDescription();\n\n    /// Loads the resource.\n    void loadResource( std::string &resourceName, string & data );\n\n    virtual sptr< Dictionary::DataRequest > getSearchResults( QString const & searchString,\n                                                              int searchMode, bool matchCase,\n                                                              int distanceBetweenWords,\n                                                              int maxResults,\n                                                              bool ignoreWordsOrder,\n                                                              bool ignoreDiacritics,\n                                                              QThreadPool * ftsThreadPoolPtr );\n    virtual void getArticleText( uint32_t articleAddress, QString & headword, QString & text );\n\n    quint64 getArticlePos(uint32_t articleNumber );\n\n    virtual void makeFTSIndex(QAtomicInt & isCancelled, bool firstIteration );\n\n    virtual void setFTSParameters( Config::FullTextSearch const & fts )\n    {\n      can_FTS = fts.enabled\n                && !fts.disabledTypes.contains( \"SLOB\", Qt::CaseInsensitive )\n                && ( fts.maxDictionarySize == 0 || getArticleCount() <= fts.maxDictionarySize );\n    }\n\n    virtual uint32_t getFtsIndexVersion()\n    { return 2; }\n\nprotected:\n\n    virtual void loadIcon() throw();\n\nprivate:\n\n    /// Loads the article.\n    void loadArticle( quint32 address,\n                      string & articleText );\n\n    quint32 readArticle( quint32 address,\n                         string & articleText,\n                         RefEntry & entry );\n\n    string convert( string const & in_data, RefEntry const & entry );\n\n    void removeDirectory( QString const & directory );\n\n    friend class SlobArticleRequest;\n    friend class SlobResourceRequest;\n};\n\nSlobDictionary::SlobDictionary( string const & id,\n                                string const & indexFile,\n                                vector< string > const & dictionaryFiles ):\n    BtreeDictionary( id, dictionaryFiles ),\n    idx( indexFile, \"rb\" ),\n    idxHeader( idx.read< IdxHeader >() )\n{\n    // Open data file\n\n    try\n    {\n      sf.open( FsEncoding::decode( dictionaryFiles[ 0 ].c_str() ) );\n    }\n    catch( std::exception & e )\n    {\n      gdWarning( \"Slob dictionary initializing failed: %s, error: %s\\n\",\n                 dictionaryFiles[ 0 ].c_str(), e.what() );\n    }\n\n    // Initialize the indexes\n\n    openIndex( IndexInfo( idxHeader.indexBtreeMaxElements,\n                          idxHeader.indexRootOffset ),\n               idx, idxMutex );\n\n    resourceIndex.openIndex( IndexInfo( idxHeader.resourceIndexBtreeMaxElements,\n                                        idxHeader.resourceIndexRootOffset ),\n                             idx, idxResourceMutex );\n\n    // Read dictionary name\n\n    dictionaryName = string( sf.getDictionaryName().toUtf8().constData() );\n    if( dictionaryName.empty() )\n    {\n      QString name = QDir::fromNativeSeparators( FsEncoding::decode( dictionaryFiles[ 0 ].c_str() ) );\n      int n = name.lastIndexOf( '/' );\n      dictionaryName = string( name.mid( n + 1 ).toUtf8().constData() );\n    }\n\n    // Full-text search parameters\n\n    can_FTS = true;\n\n    ftsIdxName = indexFile + \"_FTS\";\n\n    if( !Dictionary::needToRebuildIndex( dictionaryFiles, ftsIdxName )\n        && !FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) )\n      FTS_index_completed.ref();\n\n    texCgiPath = Config::getProgramDataDir() + \"/mimetex.cgi\";\n    if( QFileInfo( texCgiPath ).exists() )\n    {\n      QString dirName = QString::fromStdString( getId() );\n      QDir( QDir::tempPath() ).mkdir( dirName );\n      texCachePath = QDir::tempPath() + \"/\" + dirName;\n    }\n    else\n      texCgiPath.clear();\n}\n\nSlobDictionary::~SlobDictionary()\n{\n  if( !texCachePath.isEmpty() )\n    removeDirectory( texCachePath );\n}\n\nvoid SlobDictionary::removeDirectory( QString const & directory )\n{\n  QDir dir( directory );\n  Q_FOREACH( QFileInfo info, dir.entryInfoList( QDir::NoDotAndDotDot\n                                                | QDir::AllDirs\n                                                | QDir::Files,\n                                                QDir::DirsFirst))\n  {\n    if( info.isDir() )\n      removeDirectory( info.absoluteFilePath() );\n    else\n      QFile::remove( info.absoluteFilePath() );\n  }\n\n  dir.rmdir( directory );\n}\n\nvoid SlobDictionary::loadIcon() throw()\n{\n  if ( dictionaryIconLoaded )\n    return;\n\n  QString fileName =\n    QDir::fromNativeSeparators( FsEncoding::decode( getDictionaryFilenames()[ 0 ].c_str() ) );\n\n  // Remove the extension\n  fileName.chop( 4 );\n\n  if( !loadIconFromFile( fileName ) )\n  {\n    // Load failed -- use default icons\n    dictionaryNativeIcon = dictionaryIcon = QIcon(\":/icons/icon32_slob.png\");\n  }\n\n  dictionaryIconLoaded = true;\n}\n\nQString const& SlobDictionary::getDescription()\n{\n  if( !dictionaryDescription.isEmpty() )\n    return dictionaryDescription;\n\n  QMap< QString, QString > const & tags = sf.getTags();\n\n  QMap< QString, QString >::const_iterator it;\n  for( it = tags.begin(); it != tags.end(); ++it )\n  {\n    if( it != tags.begin() )\n      dictionaryDescription += \"\\n\\n\";\n\n    dictionaryDescription += it.key() + \": \" +it.value();\n  }\n\n  return dictionaryDescription;\n}\n\nvoid SlobDictionary::loadArticle( quint32 address,\n                                  string & articleText )\n{\n  articleText.clear();\n\n  RefEntry entry;\n\n  readArticle( address, articleText, entry );\n\n  if( !articleText.empty() )\n  {\n    articleText = convert( articleText, entry );\n  }\n  else\n    articleText = string( QObject::tr( \"Article decoding error\" ).toUtf8().constData() );\n\n  // See Issue #271: A mechanism to clean-up invalid HTML cards.\n  string cleaner = \"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\n                   \"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\n                   \"</b></b></b></b></b></b></b></b>\"\n                   \"</i></i></i></i></i></i></i></i>\"\n                   \"</a></a></a></a></a></a></a></a>\";\n\n  string prefix( \"<div class=\\\"slobdict\\\"\" );\n  if( isToLanguageRTL() )\n    prefix += \" dir=\\\"rtl\\\"\";\n  prefix += \">\";\n\n  articleText = prefix + articleText + cleaner + \"</div>\";\n}\n\nstring SlobDictionary::convert( const string & in, RefEntry const & entry )\n{\n  QString text = QString::fromUtf8( in.c_str() );\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  // pattern of img and script\n  text.replace( QRegularExpression( \"<\\\\s*(img|script)\\\\s+([^>]*)src=\\\"(?!(?:data|https?|ftp):)(|/)([^\\\"]*)\\\"\" ),\n                QString( \"<\\\\1 \\\\2src=\\\"bres://%1/\\\\4\\\"\").arg( getId().c_str() ) );\n\n  // pattern <link... href=\"...\" ...>\n  text.replace( QRegularExpression( \"<\\\\s*link\\\\s+([^>]*)href=\\\"(?!(?:data|https?|ftp):)\" ),\n                QString( \"<link \\\\1href=\\\"bres://%1/\").arg( getId().c_str() ) );\n#else\n  // pattern of img and script\n  text.replace( QRegExp( \"<\\\\s*(img|script)\\\\s+([^>]*)src=\\\"(?!(?:data|https?|ftp):)(|/)([^\\\"]*)\\\"\" ),\n                QString( \"<\\\\1 \\\\2src=\\\"bres://%1/\\\\4\\\"\").arg( getId().c_str() ) );\n\n  // pattern <link... href=\"...\" ...>\n  text.replace( QRegExp( \"<\\\\s*link\\\\s+([^>]*)href=\\\"(?!(?:data|https?|ftp):)\" ),\n                QString( \"<link \\\\1href=\\\"bres://%1/\").arg( getId().c_str() ) );\n#endif\n\n  // pattern <a href=\"...\" ...>, excluding any known protocols such as http://, mailto:, #(comment)\n  // these links will be translated into local definitions\n  QString anchor;\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  QRegularExpression rxLink( \"<\\\\s*a\\\\s+([^>]*)href=\\\"(?!(?:\\\\w+://|#|mailto:|tel:))(/|)([^\\\"]*)\\\"\\\\s*(title=\\\"[^\\\"]*\\\")?[^>]*>\" );\n  QRegularExpressionMatchIterator it = rxLink.globalMatch( text );\n  int pos = 0;\n  QString newText;\n  while( it.hasNext() )\n  {\n    QRegularExpressionMatch match = it.next();\n\n    newText += text.midRef( pos, match.capturedStart() - pos );\n    pos = match.capturedEnd();\n\n    QStringList list = match.capturedTexts();\n    // Add empty strings for compatibility with QRegExp behaviour\n    for( int i = match.lastCapturedIndex() + 1; i < 5; i++ )\n      list.append( QString() );\n#else\n  QRegExp rxLink( \"<\\\\s*a\\\\s+([^>]*)href=\\\"(?!(\\\\w+://|#|mailto:|tel:))(/|)([^\\\"]*)\\\"\\\\s*(title=\\\"[^\\\"]*\\\")?[^>]*>\",\n                       Qt::CaseSensitive,\n                       QRegExp::RegExp2 );\n\n  int pos = 0;\n  while( (pos = rxLink.indexIn( text, pos )) >= 0 )\n  {\n    QStringList list = rxLink.capturedTexts();\n#endif\n    QString tag = list[3];\n    if ( !list[4].isEmpty() )\n      tag = list[4].split(\"\\\"\")[1];\n\n    // Find anchor\n    int n = list[ 3 ].indexOf( '#' );\n    if( n > 0 )\n    {\n      anchor = QString( \"?gdanchor=\" ) + list[ 3 ].mid( n + 1 );\n      tag.remove( list[ 3 ].mid( n ) );\n    }\n    else\n      anchor.clear();\n\n    tag.remove( QRegExp(\".*/\") ).\n        remove( QRegExp( \"\\\\.(s|)htm(l|)$\", Qt::CaseInsensitive ) ).\n        replace( \"_\", \"%20\" ).\n        prepend( \"<a href=\\\"gdlookup://localhost/\" ).\n        append( anchor + \"\\\" \" + list[4] + \">\" );\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n    newText += tag;\n  }\n  if( pos )\n  {\n    newText += text.midRef( pos );\n    text = newText;\n  }\n  newText.clear();\n#else\n    text.replace( pos, list[0].length(), tag );\n    pos += tag.length() + 1;\n  }\n#endif\n\n  // Handle TeX formulas via mimetex.cgi\n\n  if( !texCgiPath.isEmpty() )\n  {\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n      QRegularExpression texImage( \"<\\\\s*img\\\\s+class=\\\"([^\\\"]+)\\\"\\\\s*([^>]*)alt=\\\"([^\\\"]+)\\\"[^>]*>\" );\n      QRegularExpression regFrac( \"\\\\\\\\[dt]frac\" );\n      QRegularExpression regSpaces( \"\\\\s+([\\\\{\\\\(\\\\[\\\\}\\\\)\\\\]])\" );\n#else\n    QRegExp texImage( \"<\\\\s*img\\\\s+class=\\\"([^\\\"]+)\\\"\\\\s*([^>]*)alt=\\\"([^\\\"]+)\\\"[^>]*>\",\n                      Qt::CaseSensitive,\n                      QRegExp::RegExp2 );\n    QRegExp regFrac = QRegExp( \"\\\\\\\\[dt]frac\" );\n    QRegExp regSpaces = QRegExp( \"\\\\s+([\\\\{\\\\(\\\\[\\\\}\\\\)\\\\]])\", Qt::CaseSensitive, QRegExp::RegExp2 );\n#endif\n    QRegExp multReg = QRegExp( \"\\\\*\\\\{(\\\\d+)\\\\}([^\\\\{]|\\\\{([^\\\\}]+)\\\\})\", Qt::CaseSensitive, QRegExp::RegExp2 );\n\n    QString arrayDesc( \"\\\\begin{array}{\" );\n    pos = 0;\n    unsigned texCount = 0;\n    QString imgName;\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n    QRegularExpressionMatchIterator it = texImage.globalMatch( text );\n    QString newText;\n    while( it.hasNext() )\n    {\n      QRegularExpressionMatch match = it.next();\n\n      newText += text.midRef( pos, match.capturedStart() - pos );\n      pos = match.capturedEnd();\n\n      QStringList list = match.capturedTexts();\n#else\n    while( (pos = texImage.indexIn( text, pos )) >= 0 )\n    {\n      QStringList list = texImage.capturedTexts();\n#endif\n\n      if( list[ 1 ].compare( \"tex\" ) == 0\n          || list[ 1 ].compare( \"mwe-math-fallback-image-inline\" ) == 0\n          || list[ 1 ].endsWith( \" tex\" ) )\n      {\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 5, 0 )\n        QString const name = QString::asprintf(\n#else\n        QString name;\n        name.sprintf(\n#endif\n               \"%04X%04X%04X.gif\", entry.itemIndex, entry.binIndex, texCount );\n\n        imgName = texCachePath + \"/\" + name;\n\n        if( !QFileInfo( imgName ).exists() )\n        {\n\n          // Replace some TeX commands which don't support by mimetex.cgi\n\n          QString tex = list[ 3 ];\n          tex.replace( regSpaces, \"\\\\1\" );\n          tex.replace( regFrac, \"\\\\frac\" );\n          tex.replace( \"\\\\leqslant\", \"\\\\leq\" );\n          tex.replace( \"\\\\geqslant\", \"\\\\geq\" );\n          tex.replace( \"\\\\infin\", \"\\\\infty\" );\n          tex.replace( \"\\\\iff\", \"\\\\Longleftrightarrow\" );\n          tex.replace( \"\\\\tbinom\", \"\\\\binom\" );\n          tex.replace( \"\\\\implies\", \"\\\\Longrightarrow\" );\n          tex.replace( \"{aligned}\", \"{align*}\" );\n          tex.replace( \"\\\\Subset\", \"\\\\subset\" );\n          tex.replace( \"\\\\xrightarrow\", \"\\\\longrightarrow^\" );\n          tex.remove( \"\\\\scriptstyle\" );\n          tex.remove( \"\\\\mathop\" );\n          tex.replace( \"\\\\bigg|\", \"|\" );\n\n          // Format array descriptions (mimetex now don't support *{N}x constructions in it)\n\n          int pos1 = 0;\n          while( pos1 >= 0 )\n          {\n            pos1 = tex.indexOf( arrayDesc, pos1, Qt::CaseInsensitive );\n            if( pos1 >= 0 )\n            {\n              // Retrieve array description\n              QString desc, newDesc;\n              int n = 0;\n              int nstart = pos1 + arrayDesc.size();\n              int i;\n              for( i = 0; i + nstart < tex.size(); i++ )\n              {\n                if( tex[ i + nstart ] == '{' )\n                  n += 1;\n                if( tex[ i + nstart ] == '}' )\n                  n -= 1;\n                if( n < 0 )\n                  break;\n              }\n              if( i > 0 && i + nstart + 1 < tex.size() )\n                desc = tex.mid( nstart, i );\n\n              if( !desc.isEmpty() )\n              {\n                // Expand multipliers: \"*{5}x\" -> \"xxxxx\"\n\n                newDesc = desc;\n                QString newStr;\n                int pos2 = 0;\n                while( pos2 >= 0 )\n                {\n                  pos2 = multReg.indexIn( newDesc, pos2 );\n                  if( pos2 >= 0 )\n                  {\n                    QStringList list = multReg.capturedTexts();\n                    int n = list[ 1 ].toInt();\n                    for( int i = 0; i < n; i++ )\n                      newStr += list[ 3 ].isEmpty() ? list[ 2 ] : list[ 3 ];\n                    newDesc.replace( pos2, list[ 0 ].size(), newStr );\n                    pos2 += newStr.size();\n                  }\n                  else\n                    break;\n                }\n                tex.replace( pos1 + arrayDesc.size(), desc.size(), newDesc );\n                pos1 += arrayDesc.size() + newDesc.size();\n              }\n              else\n                pos1 += arrayDesc.size();\n            }\n            else\n              break;\n          }\n\n          QStringList const arguments = QStringList() << \"-e\" << imgName << tex;\n          QProcess::execute( texCgiPath, arguments );\n        }\n\n        QString tag = QString( \"<img class=\\\"imgtex\\\" src=\\\"file://\" )\n#ifdef Q_OS_WIN32\n                      + \"/\"\n#endif\n                      + imgName + \"\\\" alt=\\\"\" + list[ 3 ] + \"\\\">\";\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n        newText += tag;\n#else\n        text.replace( pos, list[0].length(), tag );\n        pos += tag.length() + 1;\n#endif\n\n        texCount += 1;\n      }\n      else\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n        newText += list[ 0 ];\n#else\n        pos += list[ 0 ].length();\n#endif\n    }\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n    if( pos )\n    {\n      newText += text.midRef( pos );\n      text = newText;\n    }\n    newText.clear();\n#endif\n  }\n#ifdef Q_OS_WIN32\n  else\n  {\n    // Increase equations scale\n    text = QString::fromLatin1( \"<script type=\\\"text/x-mathjax-config\\\">MathJax.Hub.Config({\" )\n           + \" SVG: { scale: 170, linebreaks: { automatic:true } }\"\n           + \", \\\"HTML-CSS\\\": { scale: 210, linebreaks: { automatic:true } }\"\n           + \", CommonHTML: { scale: 210, linebreaks: { automatic:true } }\"\n           + \" });</script>\"\n           + text;\n  }\n#endif\n\n  // Fix outstanding elements\n  text += \"<br style=\\\"clear:both;\\\" />\";\n\n  return text.toUtf8().data();\n}\n\nvoid SlobDictionary::loadResource( std::string & resourceName, string & data )\n{\n  vector< WordArticleLink > link;\n  RefEntry entry;\n\n  link = resourceIndex.findArticles( Utf8::decode( resourceName ) );\n\n  if( link.empty() )\n    return;\n\n  readArticle( link[ 0 ].articleOffset, data, entry );\n}\n\nquint32 SlobDictionary::readArticle( quint32 articleNumber, std::string & result,\n                                     RefEntry & entry )\n{\n  string data;\n  quint8 contentId;\n\n  {\n    Mutex::Lock _( slobMutex );\n    if( entry.key.isEmpty() )\n      sf.getRefEntry( articleNumber, entry );\n    contentId = sf.getItem( entry, &data );\n  }\n\n  if( contentId == 0xFF )\n    return 0xFFFFFFFF;\n\n  QString contentType = sf.getContentType( contentId );\n\n  if( contentType.contains( \"text/html\", Qt::CaseInsensitive )\n      || contentType.contains( \"text/plain\", Qt::CaseInsensitive )\n      || contentType.contains( \"/css\", Qt::CaseInsensitive )\n      || contentType.contains( \"/javascript\", Qt::CaseInsensitive )\n      || contentType.contains( \"/json\", Qt::CaseInsensitive ))\n  {\n    QTextCodec *codec = sf.getCodec();\n    QString content = codec->toUnicode( data.c_str(), data.size() );\n    result = string( content.toUtf8().data() );\n  }\n  else\n    result = data;\n\n  return contentId;\n}\n\nquint64 SlobDictionary::getArticlePos( uint32_t articleNumber )\n{\n  RefEntry entry;\n  {\n    Mutex::Lock _( slobMutex );\n    sf.getRefEntry( articleNumber, entry );\n  }\n  return ( ( (quint64)( entry.binIndex ) ) << 32 ) | entry.itemIndex;\n}\n\nvoid SlobDictionary::makeFTSIndex( QAtomicInt & isCancelled, bool firstIteration )\n{\n  if( !( Dictionary::needToRebuildIndex( getDictionaryFilenames(), ftsIdxName )\n         || FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) ) )\n    FTS_index_completed.ref();\n\n  if( haveFTSIndex() )\n    return;\n\n  if( ensureInitDone().size() )\n    return;\n\n  if( firstIteration && getArticleCount() > FTS::MaxDictionarySizeForFastSearch )\n    return;\n\n  gdDebug( \"Slob: Building the full-text index for dictionary: %s\\n\",\n           getName().c_str() );\n\n  try\n  {\n    Mutex::Lock _( getFtsMutex() );\n\n    File::Class ftsIdx( ftsIndexName(), \"wb\" );\n\n    FtsHelpers::FtsIdxHeader ftsIdxHeader;\n    memset( &ftsIdxHeader, 0, sizeof( ftsIdxHeader ) );\n\n    // We write a dummy header first. At the end of the process the header\n    // will be rewritten with the right values.\n\n    ftsIdx.write( ftsIdxHeader );\n\n    ChunkedStorage::Writer chunks( ftsIdx );\n\n    BtreeIndexing::IndexedWords indexedWords;\n\n    QSet< uint32_t > setOfOffsets;\n    setOfOffsets.reserve( getWordCount() );\n\n    findArticleLinks( 0, &setOfOffsets, 0, &isCancelled );\n\n    if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      throw exUserAbort();\n\n    QVector< uint32_t > offsets;\n    offsets.reserve( setOfOffsets.size() );\n\n    slobMutex.lock();\n    SlobFile::RefOffsetsVector const & sortedOffsets = sf.getSortedRefOffsets();\n    slobMutex.unlock();\n\n    qint32 entries = sf.getRefsCount();\n    for( qint32 i = 0; i < entries; i++ )\n    {\n      if( setOfOffsets.find( sortedOffsets[ i ].second ) != setOfOffsets.end() )\n        offsets.append( sortedOffsets[ i ].second );\n    }\n\n    // Free memory\n    sf.clearRefOffsets();\n    setOfOffsets.clear();\n    setOfOffsets.squeeze();\n\n    if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      throw exUserAbort();\n\n    if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      throw exUserAbort();\n\n    QMap< QString, QVector< uint32_t > > ftsWords;\n\n    set< quint64 > indexedArticles;\n    RefEntry entry;\n    string articleText;\n    quint32 htmlType = 0xFFFFFFFF;\n\n    for( unsigned i = 0; i < sf.getContentTypesCount(); i++ )\n    {\n      if( sf.getContentType( i ).startsWith( \"text/html\", Qt::CaseInsensitive ) )\n      {\n        htmlType = i;\n        break;\n      }\n    }\n\n    // index articles for full-text search\n    for( int i = 0; i < offsets.size(); i++ )\n    {\n      if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n        throw exUserAbort();\n\n      QString articleStr;\n      quint32 articleNom = offsets.at( i );\n\n      {\n        Mutex::Lock _( slobMutex );\n        sf.getRefEntry( articleNom, entry );\n      }\n\n      quint64 articleID = ( ( (quint64)entry.itemIndex ) << 32 ) | entry.binIndex;\n\n      set< quint64 >::iterator it = indexedArticles.find( articleID );\n      if( it != indexedArticles.end() )\n        continue;\n\n      indexedArticles.insert( articleID );\n\n      quint32 type = readArticle( 0, articleText, entry );\n\n      articleStr = QString::fromUtf8( articleText.c_str(), articleText.length() );\n\n      if( type == htmlType )\n        articleStr = Html::unescape( articleStr );\n\n      FtsHelpers::parseArticleForFts( articleNom, articleStr, ftsWords );\n    }\n\n    // Free memory\n    offsets.clear();\n    offsets.squeeze();\n\n# define BUF_SIZE 20000\n    QVector< QPair< wstring, uint32_t > > wordsWithOffsets;\n    wordsWithOffsets.reserve( BUF_SIZE );\n\n    QMap< QString, QVector< uint32_t > >::iterator it = ftsWords.begin();\n    while( it != ftsWords.end() )\n    {\n      if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n        throw exUserAbort();\n\n      uint32_t offset = chunks.startNewBlock();\n      uint32_t size = it.value().size();\n\n      chunks.addToBlock( &size, sizeof(uint32_t) );\n      chunks.addToBlock( it.value().data(), size * sizeof(uint32_t) );\n\n      wordsWithOffsets.append( QPair< wstring, uint32_t >( gd::toWString( it.key() ), offset ) );\n\n      it = ftsWords.erase( it );\n\n      if( wordsWithOffsets.size() >= BUF_SIZE )\n      {\n        for( int i = 0; i < wordsWithOffsets.size(); i++ )\n        {\n          if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n            throw exUserAbort();\n          indexedWords.addSingleWord( wordsWithOffsets[ i ].first, wordsWithOffsets[ i ].second );\n        }\n        wordsWithOffsets.clear();\n      }\n    }\n\n    // Free memory\n    ftsWords.clear();\n\n    for( int i = 0; i < wordsWithOffsets.size(); i++ )\n    {\n      if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n        throw exUserAbort();\n      indexedWords.addSingleWord( wordsWithOffsets[ i ].first, wordsWithOffsets[ i ].second );\n    }\n#undef BUF_SIZE\n\n    // Free memory\n    wordsWithOffsets.clear();\n    wordsWithOffsets.squeeze();\n\n    if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      throw exUserAbort();\n\n    ftsIdxHeader.chunksOffset = chunks.finish();\n    ftsIdxHeader.wordCount = indexedWords.size();\n\n    if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      throw exUserAbort();\n\n    BtreeIndexing::IndexInfo ftsIdxInfo = BtreeIndexing::buildIndex( indexedWords, ftsIdx );\n\n    // Free memory\n    indexedWords.clear();\n\n    ftsIdxHeader.indexBtreeMaxElements = ftsIdxInfo.btreeMaxElements;\n    ftsIdxHeader.indexRootOffset = ftsIdxInfo.rootOffset;\n\n    ftsIdxHeader.signature = FtsHelpers::FtsSignature;\n    ftsIdxHeader.formatVersion = FtsHelpers::CurrentFtsFormatVersion + getFtsIndexVersion();\n\n    ftsIdx.rewind();\n    ftsIdx.writeRecords( &ftsIdxHeader, sizeof(ftsIdxHeader), 1 );\n\n    FTS_index_completed.ref();\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"Slob: Failed building full-text search index for \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n    QFile::remove( FsEncoding::decode( ftsIdxName.c_str() ) );\n  }\n}\n\nvoid SlobDictionary::getArticleText( uint32_t articleAddress, QString & headword, QString & text )\n{\n  try\n  {\n    RefEntry entry;\n    string articleText;\n\n    quint32 htmlType = 0xFFFFFFFF;\n\n    for( unsigned i = 0; i < sf.getContentTypesCount(); i++ )\n    {\n      if( sf.getContentType( i ).startsWith( \"text/html\", Qt::CaseInsensitive ) )\n      {\n        htmlType = i;\n        break;\n      }\n    }\n\n    quint32 type = readArticle( articleAddress, articleText, entry );\n    headword = entry.key;\n\n    text = QString::fromUtf8( articleText.data(), articleText.size() );\n\n    if( type == htmlType )\n      text = Html::unescape( text );\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"Slob: Failed retrieving article from \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n  }\n}\n\n\nsptr< Dictionary::DataRequest > SlobDictionary::getSearchResults( QString const & searchString,\n                                                                  int searchMode, bool matchCase,\n                                                                  int distanceBetweenWords,\n                                                                  int maxResults,\n                                                                  bool ignoreWordsOrder,\n                                                                  bool ignoreDiacritics,\n                                                                  QThreadPool * ftsThreadPoolPtr )\n{\n  return new FtsHelpers::FTSResultsRequest( *this, searchString, searchMode, matchCase, distanceBetweenWords, maxResults, ignoreWordsOrder, ignoreDiacritics, ftsThreadPoolPtr );\n}\n\n\n/// SlobDictionary::getArticle()\n\nclass SlobArticleRequest;\n\nclass SlobArticleRequestRunnable: public QRunnable\n{\n  SlobArticleRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  SlobArticleRequestRunnable( SlobArticleRequest & r_,\n                              QSemaphore & hasExited_ ): r( r_ ),\n                                                         hasExited( hasExited_ )\n  {}\n\n  ~SlobArticleRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass SlobArticleRequest: public Dictionary::DataRequest\n{\n  friend class SlobArticleRequestRunnable;\n\n  wstring word;\n  vector< wstring > alts;\n  SlobDictionary & dict;\n  bool ignoreDiacritics;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  SlobArticleRequest( wstring const & word_,\n                      vector< wstring > const & alts_,\n                      SlobDictionary & dict_, bool ignoreDiacritics_ ):\n    word( word_ ), alts( alts_ ), dict( dict_ ), ignoreDiacritics( ignoreDiacritics_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new SlobArticleRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by DslArticleRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~SlobArticleRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid SlobArticleRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid SlobArticleRequest::run()\n{\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  vector< WordArticleLink > chain = dict.findArticles( word, ignoreDiacritics );\n\n  for( unsigned x = 0; x < alts.size(); ++x )\n  {\n    /// Make an additional query for each alt\n\n    vector< WordArticleLink > altChain = dict.findArticles( alts[ x ], ignoreDiacritics );\n\n    chain.insert( chain.end(), altChain.begin(), altChain.end() );\n  }\n\n  multimap< wstring, pair< string, string > > mainArticles, alternateArticles;\n\n  set< quint64 > articlesIncluded; // Some synonims make it that the articles\n                                    // appear several times. We combat this\n                                    // by only allowing them to appear once.\n\n  wstring wordCaseFolded = Folding::applySimpleCaseOnly( word );\n  if( ignoreDiacritics )\n    wordCaseFolded = Folding::applyDiacriticsOnly( wordCaseFolded );\n\n  for( unsigned x = 0; x < chain.size(); ++x )\n  {\n    if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    {\n      finish();\n      return;\n    }\n\n    quint64 pos = dict.getArticlePos( chain[ x ].articleOffset ); // Several \"articleOffset\" values may refer to one article\n\n    if ( articlesIncluded.find( pos ) != articlesIncluded.end() )\n      continue; // We already have this article in the body.\n\n    // Now grab that article\n\n    string headword, articleText;\n\n    headword = chain[ x ].word;\n    try\n    {\n      dict.loadArticle( chain[ x ].articleOffset, articleText );\n    }\n    catch(...)\n    {\n    }\n\n    // Ok. Now, does it go to main articles, or to alternate ones? We list\n    // main ones first, and alternates after.\n\n    // We do the case-folded comparison here.\n\n    wstring headwordStripped =\n      Folding::applySimpleCaseOnly( Utf8::decode( headword ) );\n    if( ignoreDiacritics )\n      headwordStripped = Folding::applyDiacriticsOnly( headwordStripped );\n\n    multimap< wstring, pair< string, string > > & mapToUse =\n      ( wordCaseFolded == headwordStripped ) ?\n        mainArticles : alternateArticles;\n\n    mapToUse.insert( pair< wstring, pair< string, string > >(\n      Folding::applySimpleCaseOnly( Utf8::decode( headword ) ),\n      pair< string, string >( headword, articleText ) ) );\n\n    articlesIncluded.insert( pos );\n  }\n\n  if ( mainArticles.empty() && alternateArticles.empty() )\n  {\n    // No such word\n    finish();\n    return;\n  }\n\n  string result;\n\n  multimap< wstring, pair< string, string > >::const_iterator i;\n\n  for( i = mainArticles.begin(); i != mainArticles.end(); ++i )\n  {\n      result += \"<div class=\\\"slobdict\\\"><h3 class=\\\"slobdict_headword\\\">\";\n      result += i->second.first;\n      result += \"</h3></div>\";\n      result += i->second.second;\n  }\n\n  for( i = alternateArticles.begin(); i != alternateArticles.end(); ++i )\n  {\n      result += \"<div class=\\\"slobdict\\\"><h3 class=\\\"slobdict_headword\\\">\";\n      result += i->second.first;\n      result += \"</h3></div>\";\n      result += i->second.second;\n  }\n\n  Mutex::Lock _( dataMutex );\n\n  data.resize( result.size() );\n\n  memcpy( &data.front(), result.data(), result.size() );\n\n  hasAnyData = true;\n\n  finish();\n}\n\nsptr< Dictionary::DataRequest > SlobDictionary::getArticle( wstring const & word,\n                                                            vector< wstring > const & alts,\n                                                            wstring const &,\n                                                            bool ignoreDiacritics )\n  THROW_SPEC( std::exception )\n{\n  return new SlobArticleRequest( word, alts, *this, ignoreDiacritics );\n}\n\n//// SlobDictionary::getResource()\n\nclass SlobResourceRequest;\n\nclass SlobResourceRequestRunnable: public QRunnable\n{\n  SlobResourceRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  SlobResourceRequestRunnable( SlobResourceRequest & r_,\n                               QSemaphore & hasExited_ ): r( r_ ),\n                                                          hasExited( hasExited_ )\n  {}\n\n  ~SlobResourceRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass SlobResourceRequest: public Dictionary::DataRequest\n{\n  friend class SlobResourceRequestRunnable;\n\n  SlobDictionary & dict;\n\n  string resourceName;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  SlobResourceRequest( SlobDictionary & dict_,\n                       string const & resourceName_ ):\n    dict( dict_ ),\n    resourceName( resourceName_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new SlobResourceRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by ZimResourceRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~SlobResourceRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid SlobResourceRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid SlobResourceRequest::run()\n{\n  // Some runnables linger enough that they are cancelled before they start\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  try\n  {\n    string resource;\n    dict.loadResource( resourceName, resource );\n    if( resource.empty() )\n      throw exNoResource();\n\n    if( Filetype::isNameOfCSS( resourceName ) )\n    {\n      QString css = QString::fromUtf8( resource.data(), resource.size() );\n      dict.isolateCSS( css, \".slobdict\" );\n      QByteArray bytes = css.toUtf8();\n\n      Mutex::Lock _( dataMutex );\n      data.resize( bytes.size() );\n      memcpy( &data.front(), bytes.constData(), bytes.size() );\n    }\n    else\n    if ( Filetype::isNameOfTiff( resourceName ) )\n    {\n      // Convert it\n\n      dataMutex.lock();\n\n      QImage img = QImage::fromData( reinterpret_cast< const uchar * >( resource.data() ), resource.size() );\n\n#ifdef MAKE_EXTRA_TIFF_HANDLER\n      if( img.isNull() )\n        GdTiff::tiffToQImage( &data.front(), data.size(), img );\n#endif\n\n      dataMutex.unlock();\n\n      if ( !img.isNull() )\n      {\n        // Managed to load -- now store it back as BMP\n\n        QByteArray ba;\n        QBuffer buffer( &ba );\n        buffer.open( QIODevice::WriteOnly );\n        img.save( &buffer, \"BMP\" );\n\n        Mutex::Lock _( dataMutex );\n\n        data.resize( buffer.size() );\n\n        memcpy( &data.front(), buffer.data(), data.size() );\n      }\n    }\n    else\n    {\n      Mutex::Lock _( dataMutex );\n      data.resize( resource.size() );\n      memcpy( &data.front(), resource.data(), data.size() );\n    }\n\n    Mutex::Lock _( dataMutex );\n    hasAnyData = true;\n  }\n  catch( std::exception &ex )\n  {\n    gdCWarning( dictionaryResourceLc, \"SLOB: Failed loading resource \\\"%s\\\" from \\\"%s\\\", reason: %s\\n\",\n                resourceName.c_str(), dict.getName().c_str(), ex.what() );\n    // Resource not loaded -- we don't set the hasAnyData flag then\n  }\n\n  finish();\n}\n\nsptr< Dictionary::DataRequest > SlobDictionary::getResource( string const & name )\n  THROW_SPEC( std::exception )\n{\n  return new SlobResourceRequest( *this, name );\n}\n\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing & initializing,\n                                      unsigned maxHeadwordsToExpand )\n  THROW_SPEC( std::exception )\n{\n  vector< sptr< Dictionary::Class > > dictionaries;\n\n  for( vector< string >::const_iterator i = fileNames.begin(); i != fileNames.end();\n       ++i )\n  {\n      // Skip files with the extensions different to .slob to speed up the\n      // scanning\n\n      QString firstName = QDir::fromNativeSeparators( FsEncoding::decode( i->c_str() ) );\n      if( !firstName.endsWith( \".slob\") )\n        continue;\n\n      // Got the file -- check if we need to rebuid the index\n\n      vector< string > dictFiles( 1, *i );\n\n      string dictId = Dictionary::makeDictionaryId( dictFiles );\n\n      string indexFile = indicesDir + dictId;\n\n      try\n      {\n        if ( Dictionary::needToRebuildIndex( dictFiles, indexFile ) ||\n             indexIsOldOrBad( indexFile ) )\n        {\n          SlobFile sf;\n\n          gdDebug( \"Slob: Building the index for dictionary: %s\\n\", i->c_str() );\n\n          sf.open( firstName );\n\n          initializing.indexingDictionary( sf.getDictionaryName().toUtf8().constData() );\n\n          File::Class idx( indexFile, \"wb\" );\n          IdxHeader idxHeader;\n          memset( &idxHeader, 0, sizeof( idxHeader ) );\n\n          // We write a dummy header first. At the end of the process the header\n          // will be rewritten with the right values.\n\n          idx.write( idxHeader );\n\n          RefEntry refEntry;\n          quint32 entries = sf.getRefsCount();\n\n          IndexedWords indexedWords, indexedResources;\n\n          set< quint64 > articlesPos;\n          quint32 articleCount = 0, wordCount = 0;\n\n          SlobFile::RefOffsetsVector const & offsets = sf.getSortedRefOffsets();\n\n          for( quint32 i = 0; i < entries; i++ )\n          {\n            sf.getRefEntryAtOffset( offsets[ i ].first, refEntry );\n\n            quint8 type = sf.getItem( refEntry, 0 );\n\n            QString contentType = sf.getContentType( type );\n\n            if( contentType.startsWith( \"text/html\", Qt::CaseInsensitive )\n                || contentType.startsWith( \"text/plain\", Qt::CaseInsensitive ) )\n            {\n              //Article\n              if( maxHeadwordsToExpand && entries > maxHeadwordsToExpand )\n                indexedWords.addSingleWord( gd::toWString( refEntry.key ), offsets[ i ].second );\n              else\n                indexedWords.addWord( gd::toWString( refEntry.key ), offsets[ i ].second );\n\n              wordCount += 1;\n\n              quint64 pos = ( ( (quint64)refEntry.itemIndex ) << 32 ) + refEntry.binIndex;\n              if( articlesPos.find( pos ) == articlesPos.end() )\n              {\n                articleCount += 1;\n                articlesPos.insert( pos );\n              }\n            }\n            else\n            {\n              indexedResources.addSingleWord( gd::toWString( refEntry.key ), offsets[ i ].second );\n            }\n          }\n          sf.clearRefOffsets();\n\n          // Build index\n\n          {\n            IndexInfo idxInfo = BtreeIndexing::buildIndex( indexedWords, idx );\n\n            idxHeader.indexBtreeMaxElements = idxInfo.btreeMaxElements;\n            idxHeader.indexRootOffset = idxInfo.rootOffset;\n\n            indexedWords.clear(); // Release memory -- no need for this data\n          }\n\n          {\n            IndexInfo idxInfo = BtreeIndexing::buildIndex( indexedResources, idx );\n\n            idxHeader.resourceIndexBtreeMaxElements = idxInfo.btreeMaxElements;\n            idxHeader.resourceIndexRootOffset = idxInfo.rootOffset;\n\n            indexedResources.clear(); // Release memory -- no need for this data\n          }\n\n          idxHeader.signature = Signature;\n          idxHeader.formatVersion = CurrentFormatVersion;\n\n          idxHeader.articleCount = articleCount;\n          idxHeader.wordCount = wordCount;\n\n          QPair<quint32,quint32> langs =\n              LangCoder::findIdsForFilename( QString::fromStdString( dictFiles[ 0 ] ) );\n\n          idxHeader.langFrom = langs.first;\n          idxHeader.langTo = langs.second;\n\n          idx.rewind();\n\n          idx.write( &idxHeader, sizeof( idxHeader ) );\n\n        }\n        dictionaries.push_back( new SlobDictionary( dictId,\n                                                    indexFile,\n                                                    dictFiles ) );\n      }\n      catch( std::exception & e )\n      {\n        gdWarning( \"Slob dictionary initializing failed: %s, error: %s\\n\",\n                   i->c_str(), e.what() );\n        continue;\n      }\n      catch( ... )\n      {\n        qWarning( \"Slob dictionary initializing failed\\n\" );\n        continue;\n      }\n  }\n  return dictionaries;\n}\n\n} // namespace Slob\n\n#endif\n"
        },
        {
          "name": "slob.hh",
          "type": "blob",
          "size": 0.595703125,
          "content": "#ifndef __SLOB_HH_INCLUDED__\n#define __SLOB_HH_INCLUDED__\n\n#ifdef MAKE_ZIM_SUPPORT\n\n#include \"dictionary.hh\"\n\n/// Support for the Slob dictionaries.\nnamespace Slob {\n\nusing std::vector;\nusing std::string;\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing &,\n                                      unsigned maxHeadwordsToExpand )\n  THROW_SPEC( std::exception );\n\n}\n\n#endif\n\n#endif // __SLOB_HH_INCLUDED__\n"
        },
        {
          "name": "sounddir.cc",
          "type": "blob",
          "size": 14.43359375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"sounddir.hh\"\n#include \"file.hh\"\n#include \"folding.hh\"\n#include \"utf8.hh\"\n#include \"btreeidx.hh\"\n#include \"chunkedstorage.hh\"\n#include \"filetype.hh\"\n#include \"htmlescape.hh\"\n#include \"audiolink.hh\"\n#include \"wstring_qt.hh\"\n#include \"fsencoding.hh\"\n#include \"qt4x5.hh\"\n\n#include <set>\n#include <QDir>\n#include <QFileInfo>\n#include <QDebug>\n\nnamespace SoundDir {\n\nusing std::string;\nusing gd::wstring;\nusing std::map;\nusing std::multimap;\nusing std::set;\nusing BtreeIndexing::WordArticleLink;\nusing BtreeIndexing::IndexedWords;\nusing BtreeIndexing::IndexInfo;\n\nnamespace {\n\nenum\n{\n  Signature = 0x58524453, // SDRX on little-endian, XRDS on big-endian\n  CurrentFormatVersion = 1+ BtreeIndexing::FormatVersion + Folding::Version\n};\n\nstruct IdxHeader\n{\n  uint32_t signature; // First comes the signature, SDRX\n  uint32_t formatVersion; // File format version, is to be CurrentFormatVersion\n  uint32_t soundsCount; // Total number of sounds, for informative purposes only\n  uint32_t chunksOffset; // The offset to chunks' storage\n  uint32_t indexBtreeMaxElements; // Two fields from IndexInfo\n  uint32_t indexRootOffset;\n} \n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\nbool indexIsOldOrBad( string const & indexFile )\n{\n  File::Class idx( indexFile, \"rb\" );\n\n  IdxHeader header;\n\n  return idx.readRecords( &header, sizeof( header ), 1 ) != 1 ||\n         header.signature != Signature ||\n         header.formatVersion != CurrentFormatVersion;\n}\n\nclass SoundDirDictionary: public BtreeIndexing::BtreeDictionary\n{\n  string name;\n  Mutex idxMutex;\n  File::Class idx;\n  IdxHeader idxHeader;\n  ChunkedStorage::Reader chunks;\n  QString iconFilename;\n\npublic:\n\n  SoundDirDictionary( string const & id, string const & name,\n                      string const & indexFile,\n                      vector< string > const & dictionaryFiles,\n                      QString const & iconFilename_ );\n\n  virtual string getName() throw()\n  { return name; }\n\n  virtual map< Dictionary::Property, string > getProperties() throw()\n  { return map< Dictionary::Property, string >(); }\n\n  virtual unsigned long getArticleCount() throw()\n  { return idxHeader.soundsCount; }\n\n  virtual unsigned long getWordCount() throw()\n  { return getArticleCount(); }\n\n  virtual sptr< Dictionary::DataRequest > getArticle( wstring const &,\n                                                      vector< wstring > const & alts,\n                                                      wstring const &,\n                                                      bool ignoreDiacritics )\n    THROW_SPEC( std::exception );\n\n  virtual sptr< Dictionary::DataRequest > getResource( string const & name )\n    THROW_SPEC( std::exception );\n\nprotected:\n\n  virtual void loadIcon() throw();\n};\n\nSoundDirDictionary::SoundDirDictionary( string const & id,\n                                        string const & name_,\n                                        string const & indexFile,\n                                        vector< string > const & dictionaryFiles,\n                                        QString const & iconFilename_ ):\n  BtreeDictionary( id, dictionaryFiles ),\n  name( name_ ),\n  idx( indexFile, \"rb\" ),\n  idxHeader( idx.read< IdxHeader >() ),\n  chunks( idx, idxHeader.chunksOffset ),\n  iconFilename( iconFilename_ )\n{\n  // Initialize the index\n\n  openIndex( IndexInfo( idxHeader.indexBtreeMaxElements,\n                        idxHeader.indexRootOffset ),\n             idx, idxMutex );\n}\n\nsptr< Dictionary::DataRequest > SoundDirDictionary::getArticle( wstring const & word,\n                                                                vector< wstring > const & alts,\n                                                                wstring const &,\n                                                                bool ignoreDiacritics )\n  THROW_SPEC( std::exception )\n{\n  vector< WordArticleLink > chain = findArticles( word, ignoreDiacritics );\n\n  for( unsigned x = 0; x < alts.size(); ++x )\n  {\n    /// Make an additional query for each alt\n\n    vector< WordArticleLink > altChain = findArticles( alts[ x ], ignoreDiacritics );\n\n    chain.insert( chain.end(), altChain.begin(), altChain.end() );\n  }\n\n  // maps to the chain number\n  multimap< wstring, unsigned > mainArticles, alternateArticles;\n\n  set< uint32_t > articlesIncluded; // Some synonims make it that the articles\n                                    // appear several times. We combat this\n                                    // by only allowing them to appear once.\n\n  wstring wordCaseFolded = Folding::applySimpleCaseOnly( word );\n  if( ignoreDiacritics )\n    wordCaseFolded = Folding::applyDiacriticsOnly( wordCaseFolded );\n\n  for( unsigned x = 0; x < chain.size(); ++x )\n  {\n    if ( articlesIncluded.find( chain[ x ].articleOffset ) != articlesIncluded.end() )\n      continue; // We already have this article in the body.\n\n    // Ok. Now, does it go to main articles, or to alternate ones? We list\n    // main ones first, and alternates after.\n\n    // We do the case-folded comparison here.\n\n    wstring headwordStripped =\n      Folding::applySimpleCaseOnly( Utf8::decode( chain[ x ].word ) );\n    if( ignoreDiacritics )\n      headwordStripped = Folding::applyDiacriticsOnly( headwordStripped );\n\n    multimap< wstring, unsigned > & mapToUse =\n      ( wordCaseFolded == headwordStripped ) ?\n        mainArticles : alternateArticles;\n\n    mapToUse.insert( std::pair< wstring, uint32_t >(\n      Folding::applySimpleCaseOnly( Utf8::decode( chain[ x ].word ) ), x ) );\n\n    articlesIncluded.insert( chain[ x ].articleOffset );\n  }\n\n  if ( mainArticles.empty() && alternateArticles.empty() )\n    return new Dictionary::DataRequestInstant( false ); // No such word\n\n  string result;\n\n  multimap< wstring, uint32_t >::const_iterator i;\n\n  string displayedName;\n  vector< char > chunk;\n  char * nameBlock;\n\n  result += \"<table class=\\\"lsa_play\\\">\";\n  for( i = mainArticles.begin(); i != mainArticles.end(); ++i )\n  {\n    if( mainArticles.size() + alternateArticles.size() <= 1 )\n      displayedName = chain[ i->second ].word;\n    else\n    {\n      try\n      {\n        Mutex::Lock _( idxMutex );\n        nameBlock = chunks.getBlock( chain[ i->second ].articleOffset, chunk );\n\n        if ( nameBlock >= &chunk.front() + chunk.size() )\n        {\n          // chunks reader thinks it's okay since zero-sized records can exist,\n          // but we don't allow that.\n          throw ChunkedStorage::exAddressOutOfRange();\n        }\n\n        chunk.back() = 0; // It must end with 0 anyway, but just in case\n        displayedName = string( nameBlock );\n      }\n      catch(  ChunkedStorage::exAddressOutOfRange & )\n      {\n        // Bad address\n        continue;\n      }\n    }\n\n    result += \"<tr>\";\n\n    QUrl url;\n    url.setScheme( \"gdau\" );\n    url.setHost( QString::fromUtf8( getId().c_str() ) );\n    url.setPath( Qt4x5::Url::ensureLeadingSlash( QString::number( chain[ i->second ].articleOffset ) ) );\n\n    string ref = string( \"\\\"\" ) + url.toEncoded().data() + \"\\\"\";\n\n    result += addAudioLink( ref, getId() );\n\n    result += \"<td><a href=\" + ref + \"><img src=\\\"qrcx://localhost/icons/playsound.png\\\" border=\\\"0\\\" alt=\\\"Play\\\"/></a></td>\";\n    result += \"<td><a href=\" + ref + \">\" + Html::escape( displayedName ) + \"</a></td>\";\n    result += \"</tr>\";\n  }\n\n  for( i = alternateArticles.begin(); i != alternateArticles.end(); ++i )\n  {\n    if( mainArticles.size() + alternateArticles.size() <= 1 )\n      displayedName = chain[ i->second ].word;\n    else\n    {\n      try\n      {\n        Mutex::Lock _( idxMutex );\n        nameBlock = chunks.getBlock( chain[ i->second ].articleOffset, chunk );\n\n        if ( nameBlock >= &chunk.front() + chunk.size() )\n        {\n          // chunks reader thinks it's okay since zero-sized records can exist,\n          // but we don't allow that.\n          throw ChunkedStorage::exAddressOutOfRange();\n        }\n\n        chunk.back() = 0; // It must end with 0 anyway, but just in case\n        displayedName = string( nameBlock );\n      }\n      catch(  ChunkedStorage::exAddressOutOfRange & )\n      {\n        // Bad address\n        continue;\n      }\n    }\n\n    result += \"<tr>\";\n\n    QUrl url;\n    url.setScheme( \"gdau\" );\n    url.setHost( QString::fromUtf8( getId().c_str() ) );\n    url.setPath( Qt4x5::Url::ensureLeadingSlash( QString::number( chain[ i->second ].articleOffset ) ) );\n\n    string ref = string( \"\\\"\" ) + url.toEncoded().data() + \"\\\"\";\n\n    result += addAudioLink( ref, getId() );\n\n    result += \"<td><a href=\" + ref + \"><img src=\\\"qrcx://localhost/icons/playsound.png\\\" border=\\\"0\\\" alt=\\\"Play\\\"/></a></td>\";\n    result += \"<td><a href=\" + ref + \">\" + Html::escape( displayedName ) + \"</a></td>\";\n    result += \"</tr>\";\n  }\n\n  result += \"</table>\";\n\n  Dictionary::DataRequestInstant * ret =\n    new Dictionary::DataRequestInstant( true );\n\n  ret->getData().resize( result.size() );\n\n  memcpy( &(ret->getData().front()), result.data(), result.size() );\n\n  return ret;\n}\n\nvoid SoundDirDictionary::loadIcon() throw()\n{\n  if ( dictionaryIconLoaded )\n    return;\n\n  if( !iconFilename.isEmpty() )\n  {\n    QFileInfo fInfo(  QDir( Config::getConfigDir() ), iconFilename );\n    if( fInfo.isFile() )\n      loadIconFromFile( fInfo.absoluteFilePath(), true );\n  }\n  if( dictionaryIcon.isNull() )\n    dictionaryIcon = dictionaryNativeIcon = QIcon(\":/icons/playsound.png\");\n  dictionaryIconLoaded = true;\n}\n\nsptr< Dictionary::DataRequest > SoundDirDictionary::getResource( string const & name )\n  THROW_SPEC( std::exception )\n{\n  bool isNumber = false;\n\n  uint32_t articleOffset = QString::fromUtf8( name.c_str() ).toULong( &isNumber );\n\n  if ( !isNumber )\n    return new Dictionary::DataRequestInstant( false ); // No such resource\n\n  vector< char > chunk;\n  char * articleData;\n\n  try\n  {\n    Mutex::Lock _( idxMutex );\n\n    articleData = chunks.getBlock( articleOffset, chunk );\n\n    if ( articleData >= &chunk.front() + chunk.size() )\n    {\n      // chunks reader thinks it's okay since zero-sized records can exist,\n      // but we don't allow that.\n      throw ChunkedStorage::exAddressOutOfRange();\n    }\n  }\n  catch(  ChunkedStorage::exAddressOutOfRange & )\n  {\n    // Bad address\n    return new Dictionary::DataRequestInstant( false ); // No such resource\n  }\n\n  chunk.back() = 0; // It must end with 0 anyway, but just in case\n\n  QDir dir( QDir::fromNativeSeparators( FsEncoding::decode( getDictionaryFilenames()[ 0 ].c_str() ) ) );\n\n  QString fileName = QDir::toNativeSeparators( dir.filePath( QString::fromUtf8( articleData ) ) );\n\n  // Now try loading that file\n\n  try\n  {\n    File::Class f( FsEncoding::encode( fileName ), \"rb\" );\n\n    sptr< Dictionary::DataRequestInstant > dr = new\n      Dictionary::DataRequestInstant( true );\n\n    vector< char > & data = dr->getData();\n\n    f.seekEnd();\n\n    data.resize( f.tell() );\n\n    f.rewind();\n    f.read( &data.front(), data.size() );\n\n    return dr;\n  }\n  catch( File::Ex & )\n  {\n    return new Dictionary::DataRequestInstant( false ); // No such resource\n  }\n}\n\nvoid addDir( QDir const & baseDir, QDir const & dir, IndexedWords & indexedWords,\n             uint32_t & soundsCount, ChunkedStorage::Writer & chunks )\n{\n  QFileInfoList entries = dir.entryInfoList( QDir::Dirs | QDir::Files | QDir::NoDotAndDotDot );\n\n  for( QFileInfoList::const_iterator i = entries.constBegin();\n       i != entries.constEnd(); ++i )\n  {\n    if ( i->isDir() )\n      addDir( baseDir, QDir( i->absoluteFilePath() ), indexedWords, soundsCount, chunks );\n    else\n    if ( Filetype::isNameOfSound( i->fileName().toUtf8().data() ) )\n    {\n      // Add this sound to index\n\n      string fileName = baseDir.relativeFilePath( i->filePath() ).toUtf8().data();\n\n      uint32_t articleOffset = chunks.startNewBlock();\n      chunks.addToBlock( fileName.c_str(), fileName.size() + 1 );\n\n      wstring name = gd::toWString( i->fileName() );\n\n      wstring::size_type pos = name.rfind( L'.' );\n\n      if ( pos != wstring::npos )\n        name.erase( pos );\n\n      indexedWords.addWord( name, articleOffset );\n\n      ++soundsCount;\n    }\n  }\n}\n\n}\n\nvector< sptr< Dictionary::Class > > makeDictionaries( Config::SoundDirs const & soundDirs,\n                                                      string const & indicesDir,\n                                                      Dictionary::Initializing & initializing )\n  THROW_SPEC( std::exception )\n{\n  vector< sptr< Dictionary::Class > > dictionaries;\n\n  for( Config::SoundDirs::const_iterator i = soundDirs.begin(); i != soundDirs.end();\n       ++i )\n  {\n    QDir dir( i->path );\n\n    if ( !dir.exists() )\n      continue; // No such dir, no dictionary then\n\n    vector< string > dictFiles( 1,\n      FsEncoding::encode( QDir::toNativeSeparators( dir.canonicalPath() ) ) );\n\n    dictFiles.push_back( \"SoundDir\" ); // A mixin\n\n    string dictId = Dictionary::makeDictionaryId( dictFiles );\n\n    dictFiles.pop_back(); // Remove mixin\n\n    string indexFile = indicesDir + dictId;\n\n    if ( Dictionary::needToRebuildIndex( dictFiles, indexFile ) || indexIsOldOrBad( indexFile ) )\n    {\n      // Building the index\n\n      qDebug() << \"Sounds: Building the index for directory: \" << i->path;\n\n      initializing.indexingDictionary( i->name.toUtf8().data() );\n\n      File::Class idx( indexFile, \"wb\" );\n\n      IdxHeader idxHeader;\n\n      memset( &idxHeader, 0, sizeof( idxHeader ) );\n\n      // We write a dummy header first. At the end of the process the header\n      // will be rewritten with the right values.\n\n      idx.write( idxHeader );\n\n      IndexedWords indexedWords;\n\n      ChunkedStorage::Writer chunks( idx );\n\n      uint32_t soundsCount = 0; // Header's one is packed, we can't ref it\n\n      addDir( dir, dir, indexedWords, soundsCount, chunks );\n\n      idxHeader.soundsCount = soundsCount;\n\n      // Finish with the chunks\n\n      idxHeader.chunksOffset = chunks.finish();\n\n      // Build the index\n\n      IndexInfo idxInfo = BtreeIndexing::buildIndex( indexedWords, idx );\n\n      idxHeader.indexBtreeMaxElements = idxInfo.btreeMaxElements;\n      idxHeader.indexRootOffset = idxInfo.rootOffset;\n\n       // That concludes it. Update the header.\n\n      idxHeader.signature = Signature;\n      idxHeader.formatVersion = CurrentFormatVersion;\n\n      idx.rewind();\n\n      idx.write( &idxHeader, sizeof( idxHeader ) );\n    }\n\n    dictionaries.push_back( new SoundDirDictionary( dictId,\n                                                    i->name.toUtf8().data(),\n                                                    indexFile,\n                                                    dictFiles,\n                                                    i->iconFilename ) );\n  }\n\n  return dictionaries;\n}\n\n\n}\n"
        },
        {
          "name": "sounddir.hh",
          "type": "blob",
          "size": 0.666015625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __SOUNDDIR_HH_INCLUDED__\n#define __SOUNDDIR_HH_INCLUDED__\n\n#include \"dictionary.hh\"\n#include \"config.hh\"\n\n/// Support for sound dirs, arbitrary directories full of audio files.\nnamespace SoundDir {\n\nusing std::vector;\nusing std::string;\n\nvector< sptr< Dictionary::Class > > makeDictionaries( Config::SoundDirs const &,\n                                                      string const & indicesDir,\n                                                      Dictionary::Initializing & )\n  THROW_SPEC( std::exception );\n\n}\n\n#endif\n"
        },
        {
          "name": "sources.cc",
          "type": "blob",
          "size": 37.044921875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"sources.hh\"\n#include <QFileDialog>\n#include <QMessageBox>\n#include <QStandardItemModel>\n#include \"gddebug.hh\"\n\n#ifdef MAKE_CHINESE_CONVERSION_SUPPORT\n#include \"chineseconversion.hh\"\n#endif\n\n\nSources::Sources( QWidget * parent, Config::Class const & cfg):\n  QWidget( parent ),\n#ifdef MAKE_CHINESE_CONVERSION_SUPPORT\n  chineseConversion( new ChineseConversion( this, cfg.transliteration.chinese ) ),\n#endif\n#if defined( Q_OS_WIN32 ) || defined( Q_OS_MAC )\n  textToSpeechSource( NULL ),\n#endif\n  itemDelegate( new QItemDelegate( this ) ),\n  itemEditorFactory( new QItemEditorFactory() ),\n  mediawikisModel( this, cfg.mediawikis ),\n  webSitesModel( this, cfg.webSites ),\n  dictServersModel( this, cfg.dictServers ),\n  programsModel( this, cfg.programs ),\n  pathsModel( this, cfg.paths ),\n  soundDirsModel( this, cfg.soundDirs ),\n  hunspellDictsModel( this, cfg.hunspell )\n{\n  ui.setupUi( this );\n\n  Config::Hunspell const & hunspell = cfg.hunspell;\n  Config::Transliteration const & trs = cfg.transliteration;\n  Config::Forvo const & forvo = cfg.forvo;\n\n  // TODO: will programTypeEditorCreator and itemEditorFactory be destroyed by\n  // anyone?\n  QItemEditorCreatorBase * programTypeEditorCreator =\n         new QStandardItemEditorCreator< ProgramTypeEditor >();\n\n  itemEditorFactory->registerEditor( QVariant::Int, programTypeEditorCreator );\n\n  itemDelegate->setItemEditorFactory( itemEditorFactory );\n\n  ui.mediaWikis->setTabKeyNavigation( true );\n  ui.mediaWikis->setModel( &mediawikisModel );\n  ui.mediaWikis->resizeColumnToContents( 0 );\n  ui.mediaWikis->resizeColumnToContents( 1 );\n  ui.mediaWikis->resizeColumnToContents( 2 );\n  ui.mediaWikis->resizeColumnToContents( 3 );\n\n  ui.webSites->setTabKeyNavigation( true );\n  ui.webSites->setModel( &webSitesModel );\n  ui.webSites->resizeColumnToContents( 0 );\n  ui.webSites->resizeColumnToContents( 1 );\n  ui.webSites->resizeColumnToContents( 2 );\n  ui.webSites->resizeColumnToContents( 3 );\n  ui.webSites->resizeColumnToContents( 4 );\n\n  ui.dictServers->setTabKeyNavigation( true );\n  ui.dictServers->setModel( &dictServersModel );\n  ui.dictServers->resizeColumnToContents( 0 );\n  ui.dictServers->resizeColumnToContents( 1 );\n  ui.dictServers->resizeColumnToContents( 2 );\n  ui.dictServers->resizeColumnToContents( 3 );\n  ui.dictServers->resizeColumnToContents( 4 );\n  ui.dictServers->resizeColumnToContents( 5 );\n\n  ui.programs->setTabKeyNavigation( true );\n  ui.programs->setModel( &programsModel );\n  ui.programs->resizeColumnToContents( 0 );\n  // Make sure this thing will be large enough\n  ui.programs->setColumnWidth( 1,\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 11, 0 )\n    QFontMetrics( QFont() ).horizontalAdvance(\n#else\n    QFontMetrics( QFont() ).width(\n#endif\n      ProgramTypeEditor::getNameForType( Config::Program::PrefixMatch ) ) + 16 );\n  ui.programs->resizeColumnToContents( 2 );\n  ui.programs->resizeColumnToContents( 3 );\n  ui.programs->resizeColumnToContents( 4 );\n  ui.programs->setItemDelegate( itemDelegate );\n\n  ui.paths->setTabKeyNavigation( true );\n  ui.paths->setModel( &pathsModel );\n\n  fitPathsColumns();\n\n  ui.soundDirs->setTabKeyNavigation( true );\n  ui.soundDirs->setModel( &soundDirsModel );\n\n  fitSoundDirsColumns();\n\n  ui.hunspellPath->setText( hunspell.dictionariesPath );\n  ui.hunspellDictionaries->setTabKeyNavigation( true );\n  ui.hunspellDictionaries->setModel( &hunspellDictsModel );\n\n  fitHunspellDictsColumns();\n\n  ui.enableRussianTransliteration->setChecked( trs.enableRussianTransliteration );\n  ui.enableGermanTransliteration->setChecked( trs.enableGermanTransliteration );\n  ui.enableGreekTransliteration->setChecked( trs.enableGreekTransliteration );\n  ui.enableBelarusianTransliteration->setChecked( trs.enableBelarusianTransliteration );\n\n#ifdef MAKE_CHINESE_CONVERSION_SUPPORT\n  ui.transliterationLayout->addWidget(chineseConversion);\n  ui.transliterationLayout->addItem(new QSpacerItem(20, 40, QSizePolicy::Minimum, QSizePolicy::Expanding));\n#endif\n\n  ui.enableRomaji->setChecked( trs.romaji.enable );\n  ui.enableHepburn->setChecked( trs.romaji.enableHepburn );\n  ui.enableNihonShiki->setChecked( trs.romaji.enableNihonShiki );\n  ui.enableKunreiShiki->setChecked( trs.romaji.enableKunreiShiki );\n  ui.enableHiragana->setChecked( trs.romaji.enableHiragana );\n  ui.enableKatakana->setChecked( trs.romaji.enableKatakana );\n\n  ui.forvoEnabled->setChecked( forvo.enable );\n  ui.forvoApiKey->setText( forvo.apiKey );\n  ui.forvoLanguageCodes->setText( forvo.languageCodes );\n\n  // Text to speech\n#if defined( Q_OS_WIN32 ) || defined( Q_OS_MAC )\n  textToSpeechSource = new TextToSpeechSource( this, cfg.voiceEngines );\n  ui.tabWidget->addTab( textToSpeechSource, QIcon(\":/icons/playsound_color.png\"), tr( \"Text to Speech\" ) );\n#endif\n\n  if ( Config::isPortableVersion() )\n  {\n    // Paths\n\n    ui.paths->setEnabled( false );\n    ui.addPath->setEnabled( false );\n    ui.removePath->setEnabled( false );\n\n    // Sound dirs\n\n    {\n      QStandardItemModel * model =  new QStandardItemModel( this );\n      model->setHorizontalHeaderLabels( QStringList() << \" \" );\n      model->invisibleRootItem()->appendRow( new QStandardItem( tr( \"(not available in portable version)\" ) ) );\n      ui.soundDirs->setModel( model );\n      ui.soundDirs->setEnabled( false );\n\n      ui.addSoundDir->setEnabled( false );\n      ui.removeSoundDir->setEnabled( false );\n    }\n\n    // Morpho\n\n    ui.hunspellPath->setEnabled( false );\n    ui.changeHunspellPath->setEnabled( false );\n  }\n  else\n    ui.portableModeNote->hide();\n}\n\nvoid Sources::fitPathsColumns()\n{\n  ui.paths->resizeColumnToContents( 0 );\n  ui.paths->resizeColumnToContents( 1 );\n}\n\nvoid Sources::fitSoundDirsColumns()\n{\n  ui.soundDirs->resizeColumnToContents( 0 );\n  ui.soundDirs->resizeColumnToContents( 1 );\n  ui.soundDirs->resizeColumnToContents( 2 );\n}\n\nvoid Sources::fitHunspellDictsColumns()\n{\n  ui.hunspellDictionaries->resizeColumnToContents( 0 );\n  ui.hunspellDictionaries->resizeColumnToContents( 1 );\n}\n\nvoid Sources::on_addPath_clicked()\n{\n  QString dir =\n    QFileDialog::getExistingDirectory( this, tr( \"Choose a directory\" ) );\n\n  if ( !dir.isEmpty() )\n  {\n    pathsModel.addNewPath( dir );\n    fitPathsColumns();\n  }\n}\n\nvoid Sources::on_removePath_clicked()\n{\n  QModelIndex current = ui.paths->currentIndex();\n\n  if ( current.isValid() &&\n      QMessageBox::question( this, tr( \"Confirm removal\" ),\n                             tr( \"Remove directory <b>%1</b> from the list?\" ).arg( pathsModel.getCurrentPaths()[ current.row() ].path ),\n                             QMessageBox::Ok,\n                             QMessageBox::Cancel ) == QMessageBox::Ok )\n  {\n    pathsModel.removePath( current.row() );\n    fitPathsColumns();\n  }\n}\n\nvoid Sources::on_addSoundDir_clicked()\n{\n  QString dir =\n    QFileDialog::getExistingDirectory( this, tr( \"Choose a directory\" ) );\n\n  if ( !dir.isEmpty() )\n  {\n    soundDirsModel.addNewSoundDir( dir, QDir( dir ).dirName() );\n    fitSoundDirsColumns();\n  }\n}\n\nvoid Sources::on_removeSoundDir_clicked()\n{\n  QModelIndex current = ui.soundDirs->currentIndex();\n\n  if ( current.isValid() &&\n      QMessageBox::question( this, tr( \"Confirm removal\" ),\n                             tr( \"Remove directory <b>%1</b> from the list?\" ).arg( soundDirsModel.getCurrentSoundDirs()[ current.row() ].path ),\n                             QMessageBox::Ok,\n                             QMessageBox::Cancel ) == QMessageBox::Ok )\n  {\n    soundDirsModel.removeSoundDir( current.row() );\n    fitSoundDirsColumns();\n  }\n}\n\nvoid Sources::on_changeHunspellPath_clicked()\n{\n  QString dir =\n    QFileDialog::getExistingDirectory( this, tr( \"Choose a directory\" ) );\n\n  if ( !dir.isEmpty() )\n  {\n    ui.hunspellPath->setText( dir );\n    hunspellDictsModel.changePath( dir );\n    fitHunspellDictsColumns();\n  }\n}\n\nvoid Sources::on_addMediaWiki_clicked()\n{\n  mediawikisModel.addNewWiki();\n  QModelIndex result =\n    mediawikisModel.index( mediawikisModel.rowCount( QModelIndex() ) - 1,\n                           1, QModelIndex() );\n\n  ui.mediaWikis->scrollTo( result );\n  //ui.mediaWikis->setCurrentIndex( result );\n  ui.mediaWikis->edit( result );\n}\n\nvoid Sources::on_removeMediaWiki_clicked()\n{\n  QModelIndex current = ui.mediaWikis->currentIndex();\n\n  if ( current.isValid() &&\n       QMessageBox::question( this, tr( \"Confirm removal\" ),\n                              tr( \"Remove site <b>%1</b> from the list?\" ).arg( mediawikisModel.getCurrentWikis()[ current.row() ].name ),\n                              QMessageBox::Ok,\n                              QMessageBox::Cancel ) == QMessageBox::Ok )\n    mediawikisModel.removeWiki( current.row() );\n}\n\nvoid Sources::on_addWebSite_clicked()\n{\n  webSitesModel.addNewSite();\n\n  QModelIndex result =\n    webSitesModel.index( webSitesModel.rowCount( QModelIndex() ) - 1,\n                         1, QModelIndex() );\n\n  ui.webSites->scrollTo( result );\n  ui.webSites->edit( result );\n}\n\nvoid Sources::on_removeWebSite_clicked()\n{\n  QModelIndex current = ui.webSites->currentIndex();\n\n  if ( current.isValid() &&\n       QMessageBox::question( this, tr( \"Confirm removal\" ),\n                              tr( \"Remove site <b>%1</b> from the list?\" ).arg( webSitesModel.getCurrentWebSites()[ current.row() ].name ),\n                              QMessageBox::Ok,\n                              QMessageBox::Cancel ) == QMessageBox::Ok )\n    webSitesModel.removeSite( current.row() );\n}\n\nvoid Sources::on_addDictServer_clicked()\n{\n  dictServersModel.addNewServer();\n\n  QModelIndex result =\n    dictServersModel.index( dictServersModel.rowCount( QModelIndex() ) - 1,\n                            1, QModelIndex() );\n\n  ui.dictServers->scrollTo( result );\n  ui.dictServers->edit( result );\n}\n\nvoid Sources::on_removeDictServer_clicked()\n{\n  QModelIndex current = ui.dictServers->currentIndex();\n\n  if ( current.isValid() &&\n       QMessageBox::question( this, tr( \"Confirm removal\" ),\n                              tr( \"Remove site <b>%1</b> from the list?\" ).arg( dictServersModel.getCurrentDictServers()[ current.row() ].name ),\n                              QMessageBox::Ok,\n                              QMessageBox::Cancel ) == QMessageBox::Ok )\n    dictServersModel.removeServer( current.row() );\n}\n\nvoid Sources::on_addProgram_clicked()\n{\n  programsModel.addNewProgram();\n\n  QModelIndex result =\n    programsModel.index( programsModel.rowCount( QModelIndex() ) - 1,\n                         1, QModelIndex() );\n\n  ui.programs->scrollTo( result );\n  ui.programs->edit( result );\n}\n\nvoid Sources::on_removeProgram_clicked()\n{\n  QModelIndex current = ui.programs->currentIndex();\n\n  if ( current.isValid() &&\n       QMessageBox::question( this, tr( \"Confirm removal\" ),\n                              tr( \"Remove program <b>%1</b> from the list?\" ).arg( programsModel.getCurrentPrograms()[ current.row() ].name ),\n                              QMessageBox::Ok,\n                              QMessageBox::Cancel ) == QMessageBox::Ok )\n    programsModel.removeProgram( current.row() );\n}\n\nConfig::VoiceEngines Sources::getVoiceEngines() const\n{\n#if defined( Q_OS_WIN32 ) || defined( Q_OS_MAC )\n  if ( !textToSpeechSource )\n    return Config::VoiceEngines();\n  return textToSpeechSource->getVoiceEnginesModel().getCurrentVoiceEngines();\n#else\n  return Config::VoiceEngines();\n#endif\n}\n\nConfig::Hunspell Sources::getHunspell() const\n{\n  Config::Hunspell h;\n\n  h.dictionariesPath = ui.hunspellPath->text();\n  h.enabledDictionaries = hunspellDictsModel.getEnabledDictionaries();\n\n  return h;\n}\n\nConfig::Transliteration Sources::getTransliteration() const\n{\n  Config::Transliteration tr;\n\n  tr.enableRussianTransliteration = ui.enableRussianTransliteration->isChecked();\n  tr.enableGermanTransliteration = ui.enableGermanTransliteration->isChecked();\n  tr.enableGreekTransliteration = ui.enableGreekTransliteration->isChecked();\n  tr.enableBelarusianTransliteration = ui.enableBelarusianTransliteration->isChecked();\n#ifdef MAKE_CHINESE_CONVERSION_SUPPORT\n  chineseConversion->getConfig( tr.chinese );\n#endif\n  tr.romaji.enable = ui.enableRomaji->isChecked();\n  tr.romaji.enableHepburn = ui.enableHepburn->isChecked();\n  tr.romaji.enableNihonShiki = ui.enableNihonShiki->isChecked();\n  tr.romaji.enableKunreiShiki = ui.enableKunreiShiki->isChecked();\n  tr.romaji.enableHiragana = ui.enableHiragana->isChecked();\n  tr.romaji.enableKatakana = ui.enableKatakana->isChecked();\n\n  return tr;\n}\n\nConfig::Forvo Sources::getForvo() const\n{\n  Config::Forvo forvo;\n\n  forvo.enable = ui.forvoEnabled->isChecked();\n  forvo.apiKey = ui.forvoApiKey->text();\n  forvo.languageCodes = ui.forvoLanguageCodes->text();\n\n  return forvo;\n}\n\n////////// MediaWikisModel\n\nMediaWikisModel::MediaWikisModel( QWidget * parent,\n                                  Config::MediaWikis const & mediawikis_ ):\n  QAbstractItemModel( parent ), mediawikis( mediawikis_ )\n{\n}\nvoid MediaWikisModel::removeWiki( int index )\n{\n  beginRemoveRows( QModelIndex(), index, index );\n  mediawikis.erase( mediawikis.begin() + index );\n  endRemoveRows();\n}\n\nvoid MediaWikisModel::addNewWiki()\n{\n  Config::MediaWiki w;\n\n  w.enabled = false;\n\n  w.id = Dictionary::generateRandomDictionaryId();\n\n  w.url = \"http://\";\n\n  beginInsertRows( QModelIndex(), mediawikis.size(), mediawikis.size() );\n  mediawikis.push_back( w );\n  endInsertRows();\n}\n\nQModelIndex MediaWikisModel::index( int row, int column, QModelIndex const & /*parent*/ ) const\n{\n  return createIndex( row, column );\n}\n\nQModelIndex MediaWikisModel::parent( QModelIndex const & /*parent*/ ) const\n{\n  return QModelIndex();\n}\n\nQt::ItemFlags MediaWikisModel::flags( QModelIndex const & index ) const\n{\n  Qt::ItemFlags result = QAbstractItemModel::flags( index );\n\n  if ( index.isValid() )\n  {\n    if ( !index.column() )\n      result |= Qt::ItemIsUserCheckable;\n    else\n      result |= Qt::ItemIsEditable;\n  }\n\n  return result;\n}\n\nint MediaWikisModel::rowCount( QModelIndex const & parent ) const\n{\n  if ( parent.isValid() )\n    return 0;\n  else\n    return mediawikis.size();\n}\n\nint MediaWikisModel::columnCount( QModelIndex const & parent ) const\n{\n  if ( parent.isValid() )\n    return 0;\n  else\n    return 4;\n}\n\nQVariant MediaWikisModel::headerData( int section, Qt::Orientation /*orientation*/, int role ) const\n{\n  if ( role == Qt::DisplayRole )\n    switch( section )\n    {\n      case 0:\n        return tr( \"Enabled\" );\n      case 1:\n        return tr( \"Name\" );\n      case 2:\n        return tr( \"Address\" );\n      case 3:\n        return tr( \"Icon\" );\n      default:\n        return QVariant();\n    }\n\n  return QVariant();\n}\n\nQVariant MediaWikisModel::data( QModelIndex const & index, int role ) const\n{\n  if ( index.row() >= mediawikis.size() )\n    return QVariant();\n\n  if ( role == Qt::DisplayRole || role == Qt::EditRole )\n  {\n    switch( index.column() )\n    {\n      case 1:\n        return mediawikis[ index.row() ].name;\n      case 2:\n        return mediawikis[ index.row() ].url;\n      case 3:\n        return mediawikis[ index.row() ].icon;\n      default:\n        return QVariant();\n    }\n  }\n\n  if ( role == Qt::CheckStateRole && !index.column() )\n    return mediawikis[ index.row() ].enabled ? Qt::Checked : Qt::Unchecked;\n\n  return QVariant();\n}\n\nbool MediaWikisModel::setData( QModelIndex const & index, const QVariant & value,\n                               int role )\n{\n  if ( index.row() >= mediawikis.size() )\n    return false;\n\n  if ( role == Qt::CheckStateRole && !index.column() )\n  {\n    //DPRINTF( \"type = %d\\n\", (int)value.type() );\n    //DPRINTF( \"value = %d\\n\", (int)value.toInt() );\n\n    // XXX it seems to be always passing Int( 2 ) as a value, so we just toggle\n    mediawikis[ index.row() ].enabled = !mediawikis[ index.row() ].enabled;\n\n    dataChanged( index, index );\n    return true;\n  }\n\n  if ( role == Qt::DisplayRole || role == Qt::EditRole )\n    switch( index.column() )\n    {\n      case 1:\n        mediawikis[ index.row() ].name =  value.toString();\n        dataChanged( index, index );\n        return true;\n      case 2:\n        mediawikis[ index.row() ].url =  value.toString();\n        dataChanged( index, index );\n        return true;\n      case 3:\n        mediawikis[ index.row() ].icon =  value.toString();\n        dataChanged( index, index );\n        return true;\n      default:\n        return false;\n    }\n\n  return false;\n}\n\n\n////////// WebSitesModel\n\nWebSitesModel::WebSitesModel( QWidget * parent,\n                              Config::WebSites const & webSites_ ):\n  QAbstractItemModel( parent ), webSites( webSites_ )\n{\n}\nvoid WebSitesModel::removeSite( int index )\n{\n  beginRemoveRows( QModelIndex(), index, index );\n  webSites.erase( webSites.begin() + index );\n  endRemoveRows();\n}\n\nvoid WebSitesModel::addNewSite()\n{\n  Config::WebSite w;\n\n  w.enabled = false;\n\n  w.id = Dictionary::generateRandomDictionaryId();\n\n  w.url = \"http://\";\n\n  w.inside_iframe = true;\n\n  beginInsertRows( QModelIndex(), webSites.size(), webSites.size() );\n  webSites.push_back( w );\n  endInsertRows();\n}\n\nQModelIndex WebSitesModel::index( int row, int column, QModelIndex const & /*parent*/ ) const\n{\n  return createIndex( row, column );\n}\n\nQModelIndex WebSitesModel::parent( QModelIndex const & /*parent*/ ) const\n{\n  return QModelIndex();\n}\n\nQt::ItemFlags WebSitesModel::flags( QModelIndex const & index ) const\n{\n  Qt::ItemFlags result = QAbstractItemModel::flags( index );\n\n  if ( index.isValid() )\n  {\n    if ( index.column() <= 1 )\n      result |= Qt::ItemIsUserCheckable;\n    else\n      result |= Qt::ItemIsEditable;\n  }\n\n  return result;\n}\n\nint WebSitesModel::rowCount( QModelIndex const & parent ) const\n{\n  if ( parent.isValid() )\n    return 0;\n  else\n    return webSites.size();\n}\n\nint WebSitesModel::columnCount( QModelIndex const & parent ) const\n{\n  if ( parent.isValid() )\n    return 0;\n  else\n    return 5;\n}\n\nQVariant WebSitesModel::headerData( int section, Qt::Orientation /*orientation*/, int role ) const\n{\n  if( role == Qt::ToolTipRole )\n  {\n    if( section == 1 )\n      return tr( \"Insert article as link inside <iframe> tag\" );\n\n    return QVariant();\n  }\n\n  if ( role == Qt::DisplayRole )\n    switch( section )\n    {\n      case 0:\n        return tr( \"Enabled\" );\n      case 1:\n        return tr( \"As link\" );\n      case 2:\n        return tr( \"Name\" );\n      case 3:\n        return tr( \"Address\" );\n      case 4:\n        return tr( \"Icon\" );\n      default:\n        return QVariant();\n    }\n\n  return QVariant();\n}\n\nQVariant WebSitesModel::data( QModelIndex const & index, int role ) const\n{\n  if ( index.row() >= webSites.size() )\n    return QVariant();\n\n  if( role == Qt::ToolTipRole )\n  {\n    if( index.column() == 1 )\n      return tr( \"Insert article as link inside <iframe> tag\" );\n\n    return QVariant();\n  }\n\n  if ( role == Qt::DisplayRole || role == Qt::EditRole )\n  {\n    switch( index.column() )\n    {\n      case 2:\n        return webSites[ index.row() ].name;\n      case 3:\n        return webSites[ index.row() ].url;\n      case 4:\n        return webSites[ index.row() ].iconFilename;\n      default:\n        return QVariant();\n    }\n  }\n\n  if ( role == Qt::CheckStateRole && !index.column() )\n    return webSites[ index.row() ].enabled ? Qt::Checked : Qt::Unchecked;\n\n  if ( role == Qt::CheckStateRole && index.column() == 1 )\n    return webSites[ index.row() ].inside_iframe ? Qt::Checked : Qt::Unchecked;\n\n  return QVariant();\n}\n\nbool WebSitesModel::setData( QModelIndex const & index, const QVariant & value,\n                               int role )\n{\n  if ( index.row() >= webSites.size() )\n    return false;\n\n  if ( role == Qt::CheckStateRole && !index.column() )\n  {\n    //DPRINTF( \"type = %d\\n\", (int)value.type() );\n    //DPRINTF( \"value = %d\\n\", (int)value.toInt() );\n\n    // XXX it seems to be always passing Int( 2 ) as a value, so we just toggle\n    webSites[ index.row() ].enabled = !webSites[ index.row() ].enabled;\n\n    dataChanged( index, index );\n    return true;\n  }\n\n  if ( role == Qt::CheckStateRole && index.column() == 1 )\n  {\n    webSites[ index.row() ].inside_iframe = !webSites[ index.row() ].inside_iframe;\n\n    dataChanged( index, index );\n    return true;\n  }\n\n  if ( role == Qt::DisplayRole || role == Qt::EditRole )\n    switch( index.column() )\n    {\n      case 2:\n        webSites[ index.row() ].name =  value.toString();\n        dataChanged( index, index );\n        return true;\n      case 3:\n        webSites[ index.row() ].url =  value.toString();\n        dataChanged( index, index );\n        return true;\n      case 4:\n        webSites[ index.row() ].iconFilename =  value.toString();\n        dataChanged( index, index );\n        return true;\n      default:\n        return false;\n    }\n\n  return false;\n}\n\n////////// DictServersModel\n\nDictServersModel::DictServersModel( QWidget * parent,\n                              Config::DictServers const & dictServers_ ):\n  QAbstractItemModel( parent ), dictServers( dictServers_ )\n{\n}\nvoid DictServersModel::removeServer( int index )\n{\n  beginRemoveRows( QModelIndex(), index, index );\n  dictServers.erase( dictServers.begin() + index );\n  endRemoveRows();\n}\n\nvoid DictServersModel::addNewServer()\n{\n  Config::DictServer d;\n\n  d.enabled = false;\n\n  d.id = Dictionary::generateRandomDictionaryId();\n\n  d.url = \"dict://\";\n\n  beginInsertRows( QModelIndex(), dictServers.size(), dictServers.size() );\n  dictServers.push_back( d );\n  endInsertRows();\n}\n\nQModelIndex DictServersModel::index( int row, int column, QModelIndex const & /*parent*/ ) const\n{\n  return createIndex( row, column );\n}\n\nQModelIndex DictServersModel::parent( QModelIndex const & /*parent*/ ) const\n{\n  return QModelIndex();\n}\n\nQt::ItemFlags DictServersModel::flags( QModelIndex const & index ) const\n{\n  Qt::ItemFlags result = QAbstractItemModel::flags( index );\n\n  if ( index.isValid() )\n  {\n    if ( !index.column() )\n      result |= Qt::ItemIsUserCheckable;\n    else\n      result |= Qt::ItemIsEditable;\n  }\n\n  return result;\n}\n\nint DictServersModel::rowCount( QModelIndex const & parent ) const\n{\n  if ( parent.isValid() )\n    return 0;\n  else\n    return dictServers.size();\n}\n\nint DictServersModel::columnCount( QModelIndex const & parent ) const\n{\n  if ( parent.isValid() )\n    return 0;\n  else\n    return 6;\n}\n\nQVariant DictServersModel::headerData( int section, Qt::Orientation /*orientation*/, int role ) const\n{\n  if ( role == Qt::DisplayRole )\n    switch( section )\n    {\n      case 0:\n        return tr( \"Enabled\" );\n      case 1:\n        return tr( \"Name\" );\n      case 2:\n        return tr( \"Address\" );\n      case 3:\n        return tr( \"Databases\" );\n      case 4:\n        return tr( \"Strategies\" );\n      case 5:\n        return tr( \"Icon\" );\n      default:\n        return QVariant();\n    }\n\n  return QVariant();\n}\n\nQVariant DictServersModel::data( QModelIndex const & index, int role ) const\n{\n  if ( index.row() >= dictServers.size() )\n    return QVariant();\n\n  if ( role == Qt::DisplayRole || role == Qt::EditRole )\n  {\n    switch( index.column() )\n    {\n      case 1:\n        return dictServers[ index.row() ].name;\n      case 2:\n        return dictServers[ index.row() ].url;\n      case 3:\n        return dictServers[ index.row() ].databases;\n      case 4:\n        return dictServers[ index.row() ].strategies;\n      case 5:\n        return dictServers[ index.row() ].iconFilename;\n      default:\n        return QVariant();\n    }\n  }\n\n  if( role == Qt::ToolTipRole && index.column() == 3 )\n    return tr( \"Comma-delimited list of databases\\n(empty string or \\\"*\\\" matches all databases)\" );\n\n  if( role == Qt::ToolTipRole && index.column() == 4 )\n    return tr( \"Comma-delimited list of search strategies\\n(empty string mean \\\"prefix\\\" strategy)\" );\n\n  if ( role == Qt::CheckStateRole && !index.column() )\n    return dictServers[ index.row() ].enabled ? Qt::Checked : Qt::Unchecked;\n\n  return QVariant();\n}\n\nbool DictServersModel::setData( QModelIndex const & index, const QVariant & value,\n                               int role )\n{\n  if ( index.row() >= dictServers.size() )\n    return false;\n\n  if ( role == Qt::CheckStateRole && !index.column() )\n  {\n    // XXX it seems to be always passing Int( 2 ) as a value, so we just toggle\n    dictServers[ index.row() ].enabled = !dictServers[ index.row() ].enabled;\n\n    dataChanged( index, index );\n    return true;\n  }\n\n  if ( role == Qt::DisplayRole || role == Qt::EditRole )\n    switch( index.column() )\n    {\n      case 1:\n        dictServers[ index.row() ].name =  value.toString();\n        dataChanged( index, index );\n        return true;\n      case 2:\n        dictServers[ index.row() ].url =  value.toString();\n        dataChanged( index, index );\n        return true;\n      case 3:\n        dictServers[ index.row() ].databases =  value.toString();\n        dataChanged( index, index );\n        return true;\n      case 4:\n        dictServers[ index.row() ].strategies =  value.toString();\n        dataChanged( index, index );\n        return true;\n      case 5:\n        dictServers[ index.row() ].iconFilename =  value.toString();\n        dataChanged( index, index );\n        return true;\n      default:\n        return false;\n    }\n\n  return false;\n}\n\n\n////////// ProgramsModel\n\nProgramsModel::ProgramsModel( QWidget * parent,\n                              Config::Programs const & programs_ ):\n  QAbstractItemModel( parent ), programs( programs_ )\n{\n}\n\nvoid ProgramsModel::removeProgram( int index )\n{\n  beginRemoveRows( QModelIndex(), index, index );\n  programs.erase( programs.begin() + index );\n  endRemoveRows();\n}\n\nvoid ProgramsModel::addNewProgram()\n{\n  Config::Program p;\n\n  p.enabled = false;\n  p.type = Config::Program::Audio;\n\n  p.id = Dictionary::generateRandomDictionaryId();\n\n  beginInsertRows( QModelIndex(), programs.size(), programs.size() );\n  programs.push_back( p );\n  endInsertRows();\n}\n\nQModelIndex ProgramsModel::index( int row, int column, QModelIndex const & /*parent*/ ) const\n{\n  return createIndex( row, column );\n}\n\nQModelIndex ProgramsModel::parent( QModelIndex const & /*parent*/ ) const\n{\n  return QModelIndex();\n}\n\nQt::ItemFlags ProgramsModel::flags( QModelIndex const & index ) const\n{\n  Qt::ItemFlags result = QAbstractItemModel::flags( index );\n\n  if ( index.isValid() )\n  {\n    if ( !index.column() )\n      result |= Qt::ItemIsUserCheckable;\n    else\n      result |= Qt::ItemIsEditable;\n  }\n\n  return result;\n}\n\nint ProgramsModel::rowCount( QModelIndex const & parent ) const\n{\n  if ( parent.isValid() )\n    return 0;\n  else\n    return programs.size();\n}\n\nint ProgramsModel::columnCount( QModelIndex const & parent ) const\n{\n  if ( parent.isValid() )\n    return 0;\n  else\n    return 5;\n}\n\nQVariant ProgramsModel::headerData( int section, Qt::Orientation /*orientation*/, int role ) const\n{\n  if ( role == Qt::DisplayRole )\n    switch( section )\n    {\n      case 0:\n        return tr( \"Enabled\" );\n      case 1:\n        return tr( \"Type\" );\n      case 2:\n        return tr( \"Name\" );\n      case 3:\n        return tr( \"Command Line\" );\n      case 4:\n        return tr( \"Icon\" );\n      default:\n        return QVariant();\n    }\n\n  return QVariant();\n}\n\nQVariant ProgramsModel::data( QModelIndex const & index, int role ) const\n{\n  if ( index.row() >= programs.size() )\n    return QVariant();\n\n  if ( role == Qt::DisplayRole || role == Qt::EditRole )\n  {\n    switch( index.column() )\n    {\n      case 1:\n        if ( role == Qt::DisplayRole )\n          return ProgramTypeEditor::getNameForType( programs[ index.row() ].type );\n        else\n          return QVariant( ( int ) programs[ index.row() ].type );\n      case 2:\n        return programs[ index.row() ].name;\n      case 3:\n        return programs[ index.row() ].commandLine;\n      case 4:\n        return programs[ index.row() ].iconFilename;\n      default:\n        return QVariant();\n    }\n  }\n\n  if ( role == Qt::CheckStateRole && !index.column() )\n    return programs[ index.row() ].enabled ? Qt::Checked : Qt::Unchecked;\n\n  return QVariant();\n}\n\nbool ProgramsModel::setData( QModelIndex const & index, const QVariant & value,\n                             int role )\n{\n  if ( index.row() >= programs.size() )\n    return false;\n\n  if ( role == Qt::CheckStateRole && !index.column() )\n  {\n    programs[ index.row() ].enabled = !programs[ index.row() ].enabled;\n\n    dataChanged( index, index );\n    return true;\n  }\n\n  if ( role == Qt::DisplayRole || role == Qt::EditRole )\n    switch( index.column() )\n    {\n      case 1:\n        programs[ index.row() ].type = Config::Program::Type( value.toInt() );\n        dataChanged( index, index );\n        return true;\n      case 2:\n        programs[ index.row() ].name = value.toString();\n        dataChanged( index, index );\n        return true;\n      case 3:\n        programs[ index.row() ].commandLine = value.toString();\n        dataChanged( index, index );\n        return true;\n      case 4:\n        programs[ index.row() ].iconFilename = value.toString();\n        dataChanged( index, index );\n        return true;\n      default:\n        return false;\n    }\n\n  return false;\n}\n\nQString ProgramTypeEditor::getNameForType( int v )\n{\n  switch( v )\n  {\n    case Config::Program::Audio:\n      return tr( \"Audio\" );\n    case Config::Program::PlainText:\n      return tr( \"Plain Text\" );\n    case Config::Program::Html:\n      return tr( \"Html\" );\n    case Config::Program::PrefixMatch:\n      return tr( \"Prefix Match\" );\n    default:\n      return tr( \"Unknown\" );\n  }\n}\n\nProgramTypeEditor::ProgramTypeEditor( QWidget * widget ): QComboBox( widget )\n{\n  for( int x = 0; x < Config::Program::MaxTypeValue; ++x )\n    addItem( getNameForType( x ) );\n}\n\nint ProgramTypeEditor::getType() const\n{\n  return currentIndex();\n}\n\nvoid ProgramTypeEditor::setType( int t )\n{\n  setCurrentIndex( t );\n}\n\n////////// PathsModel\n\nPathsModel::PathsModel( QWidget * parent,\n                        Config::Paths const & paths_ ):\n  QAbstractItemModel( parent ), paths( paths_ )\n{\n}\n\nvoid PathsModel::removePath( int index )\n{\n  beginRemoveRows( QModelIndex(), index, index );\n  paths.erase( paths.begin() + index );\n  endRemoveRows();\n}\n\nvoid PathsModel::addNewPath( QString const & path )\n{\n  beginInsertRows( QModelIndex(), paths.size(), paths.size() );\n  paths.push_back( Config::Path( path, false ) );\n  endInsertRows();\n}\n\nQModelIndex PathsModel::index( int row, int column, QModelIndex const & /*parent*/ ) const\n{\n  return createIndex( row, column );\n}\n\nQModelIndex PathsModel::parent( QModelIndex const & /*parent*/ ) const\n{\n  return QModelIndex();\n}\n\nQt::ItemFlags PathsModel::flags( QModelIndex const & index ) const\n{\n  Qt::ItemFlags result = QAbstractItemModel::flags( index );\n\n  if ( index.isValid() && index.column() == 1 )\n    result |= Qt::ItemIsUserCheckable;\n\n  return result;\n}\n\nint PathsModel::rowCount( QModelIndex const & parent ) const\n{\n  if ( parent.isValid() )\n    return 0;\n  else\n    return paths.size();\n}\n\nint PathsModel::columnCount( QModelIndex const & parent ) const\n{\n  if ( parent.isValid() )\n    return 0;\n  else\n    return 2;\n}\n\nQVariant PathsModel::headerData( int section, Qt::Orientation /*orientation*/, int role ) const\n{\n  if ( role == Qt::DisplayRole )\n    switch( section )\n    {\n      case 0:\n        return tr( \"Path\" );\n      case 1:\n        return tr( \"Recursive\" );\n      default:\n        return QVariant();\n    }\n\n  return QVariant();\n}\n\nQVariant PathsModel::data( QModelIndex const & index, int role ) const\n{\n  if ( index.row() >= paths.size() )\n    return QVariant();\n\n  if ( ( role == Qt::DisplayRole || role == Qt::EditRole ) && !index.column() )\n    return paths[ index.row() ].path;\n\n  if ( role == Qt::CheckStateRole && index.column() == 1 )\n    return paths[ index.row() ].recursive ? Qt::Checked : Qt::Unchecked;\n\n  return QVariant();\n}\n\nbool PathsModel::setData( QModelIndex const & index, const QVariant & /*value*/,\n                          int role )\n{\n  if ( index.row() >= paths.size() )\n    return false;\n\n  if ( role == Qt::CheckStateRole && index.column() == 1 )\n  {\n    paths[ index.row() ].recursive = !paths[ index.row() ].recursive;\n\n    dataChanged( index, index );\n    return true;\n  }\n\n  return false;\n}\n\n\n////////// SoundDirsModel\n\nSoundDirsModel::SoundDirsModel( QWidget * parent,\n                                Config::SoundDirs const & soundDirs_ ):\n  QAbstractItemModel( parent ), soundDirs( soundDirs_ )\n{\n}\n\nvoid SoundDirsModel::removeSoundDir( int index )\n{\n  beginRemoveRows( QModelIndex(), index, index );\n  soundDirs.erase( soundDirs.begin() + index );\n  endRemoveRows();\n}\n\nvoid SoundDirsModel::addNewSoundDir( QString const & path, QString const & name )\n{\n  beginInsertRows( QModelIndex(), soundDirs.size(), soundDirs.size() );\n  soundDirs.push_back( Config::SoundDir( path, name ) );\n  endInsertRows();\n}\n\nQModelIndex SoundDirsModel::index( int row, int column, QModelIndex const & /*parent*/ ) const\n{\n  return createIndex( row, column );\n}\n\nQModelIndex SoundDirsModel::parent( QModelIndex const & /*parent*/ ) const\n{\n  return QModelIndex();\n}\n\nQt::ItemFlags SoundDirsModel::flags( QModelIndex const & index ) const\n{\n  Qt::ItemFlags result = QAbstractItemModel::flags( index );\n\n  if ( index.isValid() && index.column() < 3 )\n    result |= Qt::ItemIsEditable;\n\n  return result;\n}\n\nint SoundDirsModel::rowCount( QModelIndex const & parent ) const\n{\n  if ( parent.isValid() )\n    return 0;\n  else\n    return soundDirs.size();\n}\n\nint SoundDirsModel::columnCount( QModelIndex const & parent ) const\n{\n  if ( parent.isValid() )\n    return 0;\n  else\n    return 3;\n}\n\nQVariant SoundDirsModel::headerData( int section, Qt::Orientation /*orientation*/, int role ) const\n{\n  if ( role == Qt::DisplayRole )\n    switch( section )\n    {\n      case 0:\n        return tr( \"Path\" );\n      case 1:\n        return tr( \"Name\" );\n      case 2:\n        return tr( \"Icon\" );\n      default:\n        return QVariant();\n    }\n\n  return QVariant();\n}\n\nQVariant SoundDirsModel::data( QModelIndex const & index, int role ) const\n{\n  if ( index.row() >= soundDirs.size() )\n    return QVariant();\n\n  if ( ( role == Qt::DisplayRole || role == Qt::EditRole ) && !index.column() )\n    return soundDirs[ index.row() ].path;\n\n  if ( ( role == Qt::DisplayRole || role == Qt::EditRole ) && index.column() == 1 )\n    return soundDirs[ index.row() ].name;\n\n  if ( ( role == Qt::DisplayRole || role == Qt::EditRole ) && index.column() == 2 )\n    return soundDirs[ index.row() ].iconFilename;\n\n  return QVariant();\n}\n\nbool SoundDirsModel::setData( QModelIndex const & index, const QVariant & value,\n                              int role )\n{\n  if ( index.row() >= soundDirs.size() )\n    return false;\n\n  if ( ( role == Qt::DisplayRole || role == Qt::EditRole ) && index.column() < 3 )\n  {\n    if ( !index.column() )\n      soundDirs[ index.row() ].path = value.toString();\n    else if ( index.column() == 1 )\n      soundDirs[ index.row() ].name = value.toString();\n    else\n      soundDirs[ index.row() ].iconFilename = value.toString();\n\n    dataChanged( index, index );\n    return true;\n  }\n\n  return false;\n}\n\n\n////////// HunspellDictsModel\n\nHunspellDictsModel::HunspellDictsModel( QWidget * parent,\n                                        Config::Hunspell const & hunspell ):\n  QAbstractItemModel( parent ), enabledDictionaries( hunspell.enabledDictionaries )\n{\n  changePath( hunspell.dictionariesPath );\n}\n\nvoid HunspellDictsModel::changePath( QString const & newPath )\n{\n  dataFiles = HunspellMorpho::findDataFiles( newPath );\n  beginResetModel();\n  endResetModel();\n}\n\nQModelIndex HunspellDictsModel::index( int row, int column, QModelIndex const & /*parent*/ ) const\n{\n  return createIndex( row, column );\n}\n\nQModelIndex HunspellDictsModel::parent( QModelIndex const & /*parent*/ ) const\n{\n  return QModelIndex();\n}\n\nQt::ItemFlags HunspellDictsModel::flags( QModelIndex const & index ) const\n{\n  Qt::ItemFlags result = QAbstractItemModel::flags( index );\n\n  if ( index.isValid() )\n  {\n    if ( !index.column() )\n      result |= Qt::ItemIsUserCheckable;\n  }\n\n  return result;\n}\n\nint HunspellDictsModel::rowCount( QModelIndex const & parent ) const\n{\n  if ( parent.isValid() )\n    return 0;\n  else\n    return dataFiles.size();\n}\n\nint HunspellDictsModel::columnCount( QModelIndex const & parent ) const\n{\n  if ( parent.isValid() )\n    return 0;\n  else\n    return 2;\n}\n\nQVariant HunspellDictsModel::headerData( int section, Qt::Orientation /*orientation*/, int role ) const\n{\n  if ( role == Qt::DisplayRole )\n    switch( section )\n    {\n      case 0:\n        return tr( \"Enabled\" );\n      case 1:\n        return tr( \"Name\" );\n      default:\n        return QVariant();\n    }\n\n  return QVariant();\n}\n\nQVariant HunspellDictsModel::data( QModelIndex const & index, int role ) const\n{\n  if ( (unsigned)index.row() >= dataFiles.size() )\n    return QVariant();\n\n  if ( role == Qt::DisplayRole && index.column() == 1 )\n    return dataFiles[ index.row() ].dictName;\n\n  if ( role == Qt::CheckStateRole && !index.column() )\n  {\n    for( unsigned x = enabledDictionaries.size(); x--; )\n    {\n      if ( enabledDictionaries[ x ] == dataFiles[ index.row() ].dictId )\n        return Qt::Checked;\n    }\n\n    return Qt::Unchecked;\n  }\n\n  return QVariant();\n}\n\nbool HunspellDictsModel::setData( QModelIndex const & index, const QVariant & /*value*/,\n                               int role )\n{\n  if ( (unsigned)index.row() >= dataFiles.size() )\n    return false;\n\n  if ( role == Qt::CheckStateRole && !index.column() )\n  {\n    for( unsigned x = enabledDictionaries.size(); x--; )\n    {\n      if ( enabledDictionaries[ x ] == dataFiles[ index.row() ].dictId )\n      {\n        // Remove it now\n        enabledDictionaries.erase( enabledDictionaries.begin() + x );\n        dataChanged( index, index );\n        return true;\n      }\n    }\n\n    // Add it\n\n    enabledDictionaries.push_back( dataFiles[ index.row() ].dictId );\n\n    dataChanged( index, index );\n    return true;\n  }\n\n  return false;\n}\n\nvoid Sources::on_rescan_clicked()\n{\n  emit rescan();\n}\n"
        },
        {
          "name": "sources.hh",
          "type": "blob",
          "size": 9.7490234375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __SOURCES_HH_INCLUDED__\n#define __SOURCES_HH_INCLUDED__\n\n#include \"ui_sources.h\"\n#include \"config.hh\"\n#include \"hunspell.hh\"\n#include <QAbstractItemModel>\n#include <QComboBox>\n#include <QItemDelegate>\n#include <QItemEditorFactory>\n\n#if defined( Q_OS_WIN32 ) || defined( Q_OS_MAC )\n#include \"texttospeechsource.hh\"\n#endif\n\n#ifdef MAKE_CHINESE_CONVERSION_SUPPORT\n// Forward declaration\nclass ChineseConversion;\n#endif\n\n/// A model to be projected into the mediawikis view, according to Qt's MVC model\nclass MediaWikisModel: public QAbstractItemModel\n{\n  Q_OBJECT\n\npublic:\n\n  MediaWikisModel( QWidget * parent, Config::MediaWikis const & );\n\n  void removeWiki( int index );\n  void addNewWiki();\n\n  /// Returns the wikis the model currently has listed\n  Config::MediaWikis const & getCurrentWikis() const\n  { return mediawikis; }\n\n  QModelIndex index( int row, int column, QModelIndex const & parent ) const;\n  QModelIndex parent( QModelIndex const & parent ) const;\n  Qt::ItemFlags flags( QModelIndex const & index ) const;\n  int rowCount( QModelIndex const & parent ) const;\n  int columnCount( QModelIndex const & parent ) const;\n  QVariant headerData( int section, Qt::Orientation orientation, int role ) const;\n  QVariant data( QModelIndex const & index, int role ) const;\n  bool setData( QModelIndex const & index, const QVariant & value, int role );\n\nprivate:\n\n  Config::MediaWikis mediawikis;\n};\n\n/// A model to be projected into the webSites view, according to Qt's MVC model\nclass WebSitesModel: public QAbstractItemModel\n{\n  Q_OBJECT\n\npublic:\n\n  WebSitesModel( QWidget * parent, Config::WebSites const & );\n\n  void removeSite( int index );\n  void addNewSite();\n\n  /// Returns the sites the model currently has listed\n  Config::WebSites const & getCurrentWebSites() const\n  { return webSites; }\n\n  QModelIndex index( int row, int column, QModelIndex const & parent ) const;\n  QModelIndex parent( QModelIndex const & parent ) const;\n  Qt::ItemFlags flags( QModelIndex const & index ) const;\n  int rowCount( QModelIndex const & parent ) const;\n  int columnCount( QModelIndex const & parent ) const;\n  QVariant headerData( int section, Qt::Orientation orientation, int role ) const;\n  QVariant data( QModelIndex const & index, int role ) const;\n  bool setData( QModelIndex const & index, const QVariant & value, int role );\n\nprivate:\n\n  Config::WebSites webSites;\n};\n\n/// A model to be projected into the dictServers view, according to Qt's MVC model\nclass DictServersModel: public QAbstractItemModel\n{\n  Q_OBJECT\n\npublic:\n\n  DictServersModel( QWidget * parent, Config::DictServers const & );\n\n  void removeServer( int index );\n  void addNewServer();\n\n  /// Returns the sites the model currently has listed\n  Config::DictServers const & getCurrentDictServers() const\n  { return dictServers; }\n\n  QModelIndex index( int row, int column, QModelIndex const & parent ) const;\n  QModelIndex parent( QModelIndex const & parent ) const;\n  Qt::ItemFlags flags( QModelIndex const & index ) const;\n  int rowCount( QModelIndex const & parent ) const;\n  int columnCount( QModelIndex const & parent ) const;\n  QVariant headerData( int section, Qt::Orientation orientation, int role ) const;\n  QVariant data( QModelIndex const & index, int role ) const;\n  bool setData( QModelIndex const & index, const QVariant & value, int role );\n\nprivate:\n\n  Config::DictServers dictServers;\n};\n\n/// A model to be projected into the programs view, according to Qt's MVC model\nclass ProgramsModel: public QAbstractItemModel\n{\n  Q_OBJECT\n\npublic:\n\n  ProgramsModel( QWidget * parent, Config::Programs const & );\n\n  void removeProgram( int index );\n  void addNewProgram();\n\n  /// Returns the sites the model currently has listed\n  Config::Programs const & getCurrentPrograms() const\n  { return programs; }\n\n  QModelIndex index( int row, int column, QModelIndex const & parent ) const;\n  QModelIndex parent( QModelIndex const & parent ) const;\n  Qt::ItemFlags flags( QModelIndex const & index ) const;\n  int rowCount( QModelIndex const & parent ) const;\n  int columnCount( QModelIndex const & parent ) const;\n  QVariant headerData( int section, Qt::Orientation orientation, int role ) const;\n  QVariant data( QModelIndex const & index, int role ) const;\n  bool setData( QModelIndex const & index, const QVariant & value, int role );\n\nprivate:\n\n  Config::Programs programs;\n};\n\nclass ProgramTypeEditor: public QComboBox\n{\nQ_OBJECT\nQ_PROPERTY(int type READ getType WRITE setType USER true)\n\npublic:\n  ProgramTypeEditor( QWidget * widget = 0 );\n\n  // Returns localized name for the given program type\n  static QString getNameForType( int );\n\npublic:\n  int getType() const;\n  void setType( int );\n};\n\n/// A model to be projected into the paths view, according to Qt's MVC model\nclass PathsModel: public QAbstractItemModel\n{\n  Q_OBJECT\n\npublic:\n\n  PathsModel( QWidget * parent, Config::Paths const & );\n\n  void removePath( int index );\n  void addNewPath( QString const & );\n\n  /// Returns the paths the model currently has listed\n  Config::Paths const & getCurrentPaths() const\n  { return paths; }\n\n  QModelIndex index( int row, int column, QModelIndex const & parent ) const;\n  QModelIndex parent( QModelIndex const & parent ) const;\n  Qt::ItemFlags flags( QModelIndex const & index ) const;\n  int rowCount( QModelIndex const & parent ) const;\n  int columnCount( QModelIndex const & parent ) const;\n  QVariant headerData( int section, Qt::Orientation orientation, int role ) const;\n  QVariant data( QModelIndex const & index, int role ) const;\n  bool setData( QModelIndex const & index, const QVariant & value, int role );\n\nprivate:\n\n  Config::Paths paths;\n};\n\n/// A model to be projected into the soundDirs view, according to Qt's MVC model\nclass SoundDirsModel: public QAbstractItemModel\n{\n  Q_OBJECT\n\npublic:\n\n  SoundDirsModel( QWidget * parent, Config::SoundDirs const & );\n\n  void removeSoundDir( int index );\n  void addNewSoundDir( QString const & path, QString const & name );\n\n  /// Returns the soundDirs the model currently has listed\n  Config::SoundDirs const & getCurrentSoundDirs() const\n  { return soundDirs; }\n\n  QModelIndex index( int row, int column, QModelIndex const & parent ) const;\n  QModelIndex parent( QModelIndex const & parent ) const;\n  Qt::ItemFlags flags( QModelIndex const & index ) const;\n  int rowCount( QModelIndex const & parent ) const;\n  int columnCount( QModelIndex const & parent ) const;\n  QVariant headerData( int section, Qt::Orientation orientation, int role ) const;\n  QVariant data( QModelIndex const & index, int role ) const;\n  bool setData( QModelIndex const & index, const QVariant & value, int role );\n\nprivate:\n\n  Config::SoundDirs soundDirs;\n};\n\n/// A model to be projected into the hunspell dictionaries view, according to Qt's MVC model\nclass HunspellDictsModel: public QAbstractItemModel\n{\n  Q_OBJECT\n\npublic:\n\n  HunspellDictsModel( QWidget * parent, Config::Hunspell const & );\n\n  void changePath( QString const & newPath );\n\n  /// Returns the dictionaries currently enabled\n  Config::Hunspell::Dictionaries const & getEnabledDictionaries() const\n  { return enabledDictionaries; }\n\n  QModelIndex index( int row, int column, QModelIndex const & parent ) const;\n  QModelIndex parent( QModelIndex const & parent ) const;\n  Qt::ItemFlags flags( QModelIndex const & index ) const;\n  int rowCount( QModelIndex const & parent ) const;\n  int columnCount( QModelIndex const & parent ) const;\n  QVariant headerData( int section, Qt::Orientation orientation, int role ) const;\n  QVariant data( QModelIndex const & index, int role ) const;\n  bool setData( QModelIndex const & index, const QVariant & value, int role );\n\nprivate:\n\n  Config::Hunspell::Dictionaries enabledDictionaries;\n  std::vector< HunspellMorpho::DataFiles > dataFiles;\n};\n\n\nclass Sources: public QWidget\n{\n  Q_OBJECT\n\npublic:\n  Sources( QWidget * parent, Config::Class const &);\n\n  Config::Paths const & getPaths() const\n  { return pathsModel.getCurrentPaths(); }\n\n  Config::SoundDirs const & getSoundDirs() const\n  { return soundDirsModel.getCurrentSoundDirs(); }\n\n  Config::MediaWikis const & getMediaWikis() const\n  { return mediawikisModel.getCurrentWikis(); }\n\n  Config::WebSites const & getWebSites() const\n  { return webSitesModel.getCurrentWebSites(); }\n\n  Config::DictServers const & getDictServers() const\n  { return dictServersModel.getCurrentDictServers(); }\n\n  Config::Programs const & getPrograms() const\n  { return programsModel.getCurrentPrograms(); }\n\n  Config::VoiceEngines getVoiceEngines() const;\n\n  Config::Hunspell getHunspell() const;\n\n  Config::Transliteration getTransliteration() const;\n\n  Config::Forvo getForvo() const;\n\nsignals:\n\n  /// Emitted when a 'Rescan' button is clicked.\n  void rescan();\n\nprivate:\n  Ui::Sources ui;\n\n#ifdef MAKE_CHINESE_CONVERSION_SUPPORT\n  ChineseConversion *chineseConversion;\n#endif\n\n#if defined( Q_OS_WIN32 ) || defined( Q_OS_MAC )\n  TextToSpeechSource *textToSpeechSource;\n#endif\n\n  QItemDelegate * itemDelegate;\n  QItemEditorFactory * itemEditorFactory;\n\n  MediaWikisModel mediawikisModel;\n  WebSitesModel webSitesModel;\n  DictServersModel dictServersModel;\n  ProgramsModel programsModel;\n  PathsModel pathsModel;\n  SoundDirsModel soundDirsModel;\n  HunspellDictsModel hunspellDictsModel;\n\n  void fitPathsColumns();\n  void fitSoundDirsColumns();\n  void fitHunspellDictsColumns();\n\nprivate slots:\n\n  void on_addPath_clicked();\n  void on_removePath_clicked();\n\n  void on_addSoundDir_clicked();\n  void on_removeSoundDir_clicked();\n\n  void on_changeHunspellPath_clicked();\n\n  void on_addMediaWiki_clicked();\n  void on_removeMediaWiki_clicked();\n\n  void on_addWebSite_clicked();\n  void on_removeWebSite_clicked();\n\n  void on_removeDictServer_clicked();\n  void on_addDictServer_clicked();\n\n  void on_addProgram_clicked();\n  void on_removeProgram_clicked();\n\n  void on_rescan_clicked();\n};\n\n#endif\n"
        },
        {
          "name": "sources.ui",
          "type": "blob",
          "size": 28.439453125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ui version=\"4.0\">\n <class>Sources</class>\n <widget class=\"QWidget\" name=\"Sources\">\n  <property name=\"geometry\">\n   <rect>\n    <x>0</x>\n    <y>0</y>\n    <width>811</width>\n    <height>336</height>\n   </rect>\n  </property>\n  <property name=\"windowTitle\">\n   <string notr=\"true\">Sources</string>\n  </property>\n  <layout class=\"QVBoxLayout\" name=\"verticalLayout_5\">\n   <item>\n    <widget class=\"QTabWidget\" name=\"tabWidget\">\n     <property name=\"currentIndex\">\n      <number>0</number>\n     </property>\n     <property name=\"iconSize\">\n      <size>\n       <width>15</width>\n       <height>15</height>\n      </size>\n     </property>\n     <property name=\"usesScrollButtons\">\n      <bool>false</bool>\n     </property>\n     <widget class=\"QWidget\" name=\"filesTab\">\n      <attribute name=\"icon\">\n       <iconset resource=\"resources.qrc\">\n        <normaloff>:/icons/filesave.png</normaloff>:/icons/filesave.png</iconset>\n      </attribute>\n      <attribute name=\"title\">\n       <string>Files</string>\n      </attribute>\n      <layout class=\"QVBoxLayout\" name=\"verticalLayout_2\">\n       <item>\n        <widget class=\"QLabel\" name=\"portableModeNote\">\n         <property name=\"text\">\n          <string>&lt;b&gt;Dictionary paths cannot be added or removed, because GoldenDict is in portable mode. See the &lt;i&gt;Portable mode&lt;/i&gt; section in GoldenDict Help.&lt;/b&gt;</string>\n         </property>\n         <property name=\"wordWrap\">\n          <bool>true</bool>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <widget class=\"QLabel\" name=\"label\">\n         <property name=\"text\">\n          <string>Paths to search for the dictionary files:</string>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <layout class=\"QHBoxLayout\" name=\"horizontalLayout\">\n         <item>\n          <widget class=\"QTreeView\" name=\"paths\"/>\n         </item>\n         <item>\n          <layout class=\"QVBoxLayout\" name=\"verticalLayout\">\n           <item>\n            <widget class=\"QPushButton\" name=\"addPath\">\n             <property name=\"text\">\n              <string>&amp;Add...</string>\n             </property>\n            </widget>\n           </item>\n           <item>\n            <widget class=\"QPushButton\" name=\"removePath\">\n             <property name=\"text\">\n              <string>&amp;Remove</string>\n             </property>\n            </widget>\n           </item>\n           <item>\n            <spacer name=\"verticalSpacer\">\n             <property name=\"orientation\">\n              <enum>Qt::Vertical</enum>\n             </property>\n             <property name=\"sizeHint\" stdset=\"0\">\n              <size>\n               <width>17</width>\n               <height>68</height>\n              </size>\n             </property>\n            </spacer>\n           </item>\n           <item>\n            <widget class=\"QPushButton\" name=\"rescan\">\n             <property name=\"text\">\n              <string>Re&amp;scan now</string>\n             </property>\n            </widget>\n           </item>\n          </layout>\n         </item>\n        </layout>\n       </item>\n      </layout>\n     </widget>\n     <widget class=\"QWidget\" name=\"tab\">\n      <attribute name=\"icon\">\n       <iconset resource=\"resources.qrc\">\n        <normaloff>:/icons/fileopen.png</normaloff>:/icons/fileopen.png</iconset>\n      </attribute>\n      <attribute name=\"title\">\n       <string>Sound Dirs</string>\n      </attribute>\n      <layout class=\"QVBoxLayout\" name=\"verticalLayout_7\">\n       <item>\n        <widget class=\"QLabel\" name=\"label_3\">\n         <property name=\"text\">\n          <string>Make dictionaries from bunches of audiofiles by adding paths here:</string>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <layout class=\"QHBoxLayout\" name=\"horizontalLayout_3\">\n         <item>\n          <widget class=\"QTreeView\" name=\"soundDirs\"/>\n         </item>\n         <item>\n          <layout class=\"QVBoxLayout\" name=\"verticalLayout_6\">\n           <item>\n            <widget class=\"QPushButton\" name=\"addSoundDir\">\n             <property name=\"text\">\n              <string>&amp;Add...</string>\n             </property>\n            </widget>\n           </item>\n           <item>\n            <widget class=\"QPushButton\" name=\"removeSoundDir\">\n             <property name=\"text\">\n              <string>&amp;Remove</string>\n             </property>\n            </widget>\n           </item>\n           <item>\n            <spacer name=\"verticalSpacer_3\">\n             <property name=\"orientation\">\n              <enum>Qt::Vertical</enum>\n             </property>\n             <property name=\"sizeHint\" stdset=\"0\">\n              <size>\n               <width>20</width>\n               <height>40</height>\n              </size>\n             </property>\n            </spacer>\n           </item>\n          </layout>\n         </item>\n        </layout>\n       </item>\n      </layout>\n     </widget>\n     <widget class=\"QWidget\" name=\"tab_2\">\n      <attribute name=\"icon\">\n       <iconset resource=\"resources.qrc\">\n        <normaloff>:/icons/icon32_hunspell.png</normaloff>:/icons/icon32_hunspell.png</iconset>\n      </attribute>\n      <attribute name=\"title\">\n       <string>Morphology</string>\n      </attribute>\n      <layout class=\"QVBoxLayout\" name=\"verticalLayout_8\">\n       <item>\n        <widget class=\"QLabel\" name=\"label_4\">\n         <property name=\"text\">\n          <string>Path to a directory with Hunspell/Myspell dictionaries:</string>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <layout class=\"QHBoxLayout\" name=\"horizontalLayout_4\">\n         <item>\n          <widget class=\"QLineEdit\" name=\"hunspellPath\">\n           <property name=\"readOnly\">\n            <bool>true</bool>\n           </property>\n          </widget>\n         </item>\n         <item>\n          <widget class=\"QPushButton\" name=\"changeHunspellPath\">\n           <property name=\"text\">\n            <string>&amp;Change...</string>\n           </property>\n          </widget>\n         </item>\n        </layout>\n       </item>\n       <item>\n        <widget class=\"QLabel\" name=\"label_5\">\n         <property name=\"text\">\n          <string>Available morphology dictionaries:</string>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <layout class=\"QHBoxLayout\" name=\"horizontalLayout_5\">\n         <item>\n          <widget class=\"QTreeView\" name=\"hunspellDictionaries\"/>\n         </item>\n         <item>\n          <widget class=\"QLabel\" name=\"label_6\">\n           <property name=\"text\">\n            <string>Each morphology dictionary appears as a\nseparate auxiliary dictionary which\nprovides stem words for searches and\nspelling suggestions for mistyped words.\nAdd appropriate dictionaries to the bottoms\nof the appropriate groups to use them.</string>\n           </property>\n           <property name=\"textFormat\">\n            <enum>Qt::PlainText</enum>\n           </property>\n           <property name=\"wordWrap\">\n            <bool>false</bool>\n           </property>\n          </widget>\n         </item>\n        </layout>\n       </item>\n      </layout>\n     </widget>\n     <widget class=\"QWidget\" name=\"mediaWikisTab\">\n      <attribute name=\"icon\">\n       <iconset resource=\"resources.qrc\">\n        <normaloff>:/icons/icon32_wiki.png</normaloff>:/icons/icon32_wiki.png</iconset>\n      </attribute>\n      <attribute name=\"title\">\n       <string>Wikipedia</string>\n      </attribute>\n      <layout class=\"QVBoxLayout\" name=\"verticalLayout_4\">\n       <item>\n        <widget class=\"QLabel\" name=\"label_2\">\n         <property name=\"text\">\n          <string>Wikipedia (MediaWiki) sites:</string>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <layout class=\"QHBoxLayout\" name=\"horizontalLayout_2\">\n         <item>\n          <widget class=\"QTreeView\" name=\"mediaWikis\"/>\n         </item>\n         <item>\n          <layout class=\"QVBoxLayout\" name=\"verticalLayout_3\">\n           <item>\n            <widget class=\"QPushButton\" name=\"addMediaWiki\">\n             <property name=\"text\">\n              <string>&amp;Add...</string>\n             </property>\n            </widget>\n           </item>\n           <item>\n            <widget class=\"QPushButton\" name=\"removeMediaWiki\">\n             <property name=\"text\">\n              <string>&amp;Remove</string>\n             </property>\n            </widget>\n           </item>\n           <item>\n            <spacer name=\"verticalSpacer_2\">\n             <property name=\"orientation\">\n              <enum>Qt::Vertical</enum>\n             </property>\n             <property name=\"sizeType\">\n              <enum>QSizePolicy::Expanding</enum>\n             </property>\n             <property name=\"sizeHint\" stdset=\"0\">\n              <size>\n               <width>20</width>\n               <height>40</height>\n              </size>\n             </property>\n            </spacer>\n           </item>\n          </layout>\n         </item>\n        </layout>\n       </item>\n      </layout>\n     </widget>\n     <widget class=\"QWidget\" name=\"tab_4\">\n      <attribute name=\"icon\">\n       <iconset resource=\"resources.qrc\">\n        <normaloff>:/icons/internet.png</normaloff>:/icons/internet.png</iconset>\n      </attribute>\n      <attribute name=\"title\">\n       <string>Websites</string>\n      </attribute>\n      <layout class=\"QVBoxLayout\" name=\"verticalLayout_11\">\n       <item>\n        <widget class=\"QLabel\" name=\"label_9\">\n         <property name=\"text\">\n          <string>Any websites. A string %GDWORD% will be replaced with the query word:</string>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <layout class=\"QHBoxLayout\" name=\"horizontalLayout_6\">\n         <item>\n          <widget class=\"QTreeView\" name=\"webSites\"/>\n         </item>\n         <item>\n          <layout class=\"QVBoxLayout\" name=\"verticalLayout_10\">\n           <item>\n            <widget class=\"QPushButton\" name=\"addWebSite\">\n             <property name=\"text\">\n              <string>&amp;Add...</string>\n             </property>\n            </widget>\n           </item>\n           <item>\n            <widget class=\"QPushButton\" name=\"removeWebSite\">\n             <property name=\"text\">\n              <string>&amp;Remove</string>\n             </property>\n            </widget>\n           </item>\n           <item>\n            <spacer name=\"verticalSpacer_8\">\n             <property name=\"orientation\">\n              <enum>Qt::Vertical</enum>\n             </property>\n             <property name=\"sizeHint\" stdset=\"0\">\n              <size>\n               <width>20</width>\n               <height>40</height>\n              </size>\n             </property>\n            </spacer>\n           </item>\n          </layout>\n         </item>\n        </layout>\n       </item>\n       <item>\n        <widget class=\"QLabel\" name=\"label_10\">\n         <property name=\"text\">\n          <string>Alternatively, use %GD1251% for CP1251, %GDISO1%...%GDISO16% for ISO 8859-1...ISO 8859-16 respectively,\n%GDBIG5% for Big-5, %GDBIG5HKSCS% for Big5-HKSCS, %GDGBK% for GBK and GB18030, %GDSHIFTJIS% for Shift-JIS.</string>\n         </property>\n        </widget>\n       </item>\n      </layout>\n     </widget>\n     <widget class=\"QWidget\" name=\"dictdTab\">\n      <attribute name=\"icon\">\n       <iconset resource=\"resources.qrc\">\n        <normaloff>:/icons/network.png</normaloff>:/icons/network.png</iconset>\n      </attribute>\n      <attribute name=\"title\">\n       <string>DICT servers</string>\n      </attribute>\n      <layout class=\"QVBoxLayout\" name=\"verticalLayout_16\">\n       <item>\n        <widget class=\"QLabel\" name=\"label_116\">\n         <property name=\"text\">\n          <string>DICT servers:</string>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <layout class=\"QHBoxLayout\" name=\"horizontalLayout_16\">\n         <item>\n          <widget class=\"QTreeView\" name=\"dictServers\"/>\n         </item>\n         <item>\n          <layout class=\"QVBoxLayout\" name=\"verticalLayout_17\">\n           <item>\n            <widget class=\"QPushButton\" name=\"addDictServer\">\n             <property name=\"text\">\n              <string>&amp;Add...</string>\n             </property>\n            </widget>\n           </item>\n           <item>\n            <widget class=\"QPushButton\" name=\"removeDictServer\">\n             <property name=\"text\">\n              <string>&amp;Remove</string>\n             </property>\n            </widget>\n           </item>\n           <item>\n            <spacer name=\"verticalSpacer_18\">\n             <property name=\"orientation\">\n              <enum>Qt::Vertical</enum>\n             </property>\n             <property name=\"sizeHint\" stdset=\"0\">\n              <size>\n               <width>20</width>\n               <height>40</height>\n              </size>\n             </property>\n            </spacer>\n           </item>\n          </layout>\n         </item>\n        </layout>\n       </item>\n      </layout>\n     </widget>\n     <widget class=\"QWidget\" name=\"tab_6\">\n      <attribute name=\"icon\">\n       <iconset resource=\"resources.qrc\">\n        <normaloff>:/icons/programs.png</normaloff>:/icons/programs.png</iconset>\n      </attribute>\n      <attribute name=\"title\">\n       <string>Programs</string>\n      </attribute>\n      <layout class=\"QVBoxLayout\" name=\"verticalLayout_15\">\n       <item>\n        <widget class=\"QLabel\" name=\"label_16\">\n         <property name=\"text\">\n          <string>Any external programs. A string %GDWORD% will be replaced with the query word. If such string is not presented, the word will be fed into standard input.</string>\n         </property>\n         <property name=\"wordWrap\">\n          <bool>true</bool>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <layout class=\"QHBoxLayout\" name=\"horizontalLayout_7\">\n         <item>\n          <widget class=\"QTreeView\" name=\"programs\"/>\n         </item>\n         <item>\n          <layout class=\"QVBoxLayout\" name=\"verticalLayout_14\">\n           <item>\n            <widget class=\"QPushButton\" name=\"addProgram\">\n             <property name=\"text\">\n              <string>&amp;Add...</string>\n             </property>\n            </widget>\n           </item>\n           <item>\n            <widget class=\"QPushButton\" name=\"removeProgram\">\n             <property name=\"text\">\n              <string>&amp;Remove</string>\n             </property>\n            </widget>\n           </item>\n           <item>\n            <spacer name=\"verticalSpacer_12\">\n             <property name=\"orientation\">\n              <enum>Qt::Vertical</enum>\n             </property>\n             <property name=\"sizeHint\" stdset=\"0\">\n              <size>\n               <width>20</width>\n               <height>40</height>\n              </size>\n             </property>\n            </spacer>\n           </item>\n          </layout>\n         </item>\n        </layout>\n       </item>\n      </layout>\n     </widget>\n     <widget class=\"QWidget\" name=\"tab_5\">\n      <attribute name=\"icon\">\n       <iconset resource=\"resources.qrc\">\n        <normaloff>:/icons/forvo.png</normaloff>:/icons/forvo.png</iconset>\n      </attribute>\n      <attribute name=\"title\">\n       <string>Forvo</string>\n      </attribute>\n      <layout class=\"QVBoxLayout\" name=\"verticalLayout_13\">\n       <item>\n        <widget class=\"QLabel\" name=\"label_11\">\n         <property name=\"sizePolicy\">\n          <sizepolicy hsizetype=\"Preferred\" vsizetype=\"Preferred\">\n           <horstretch>0</horstretch>\n           <verstretch>0</verstretch>\n          </sizepolicy>\n         </property>\n         <property name=\"text\">\n          <string>Live pronunciations from &lt;a href=&quot;http://www.forvo.com/&quot;&gt;forvo.com&lt;/a&gt;. The site allows people to record and share word pronunciations. You can listen to them from GoldenDict.</string>\n         </property>\n         <property name=\"wordWrap\">\n          <bool>true</bool>\n         </property>\n         <property name=\"openExternalLinks\">\n          <bool>true</bool>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <widget class=\"QGroupBox\" name=\"forvoEnabled\">\n         <property name=\"title\">\n          <string>Enable pronunciations from Forvo</string>\n         </property>\n         <property name=\"checkable\">\n          <bool>true</bool>\n         </property>\n         <property name=\"checked\">\n          <bool>true</bool>\n         </property>\n         <layout class=\"QVBoxLayout\" name=\"verticalLayout_12\">\n          <item>\n           <spacer name=\"verticalSpacer_9\">\n            <property name=\"orientation\">\n             <enum>Qt::Vertical</enum>\n            </property>\n            <property name=\"sizeHint\" stdset=\"0\">\n             <size>\n              <width>20</width>\n              <height>40</height>\n             </size>\n            </property>\n           </spacer>\n          </item>\n          <item>\n           <layout class=\"QFormLayout\" name=\"formLayout\">\n            <property name=\"fieldGrowthPolicy\">\n             <enum>QFormLayout::ExpandingFieldsGrow</enum>\n            </property>\n            <item row=\"0\" column=\"0\">\n             <widget class=\"QLabel\" name=\"label_12\">\n              <property name=\"text\">\n               <string>API Key:</string>\n              </property>\n             </widget>\n            </item>\n            <item row=\"0\" column=\"1\">\n             <widget class=\"QLineEdit\" name=\"forvoApiKey\">\n              <property name=\"toolTip\">\n               <string>Use of Forvo currently requires an API key. Leave this field\nblank to use the default key, which may become unavailable\nin the future, or register on the site to get your own key.</string>\n              </property>\n             </widget>\n            </item>\n            <item row=\"1\" column=\"0\">\n             <spacer name=\"horizontalSpacer_2\">\n              <property name=\"orientation\">\n               <enum>Qt::Horizontal</enum>\n              </property>\n              <property name=\"sizeType\">\n               <enum>QSizePolicy::Fixed</enum>\n              </property>\n              <property name=\"sizeHint\" stdset=\"0\">\n               <size>\n                <width>18</width>\n                <height>20</height>\n               </size>\n              </property>\n             </spacer>\n            </item>\n            <item row=\"1\" column=\"1\">\n             <widget class=\"QLabel\" name=\"label_13\">\n              <property name=\"text\">\n               <string>Get your own key &lt;a href=&quot;http://api.forvo.com/key/&quot;&gt;here&lt;/a&gt;, or leave blank to use the default one.</string>\n              </property>\n              <property name=\"wordWrap\">\n               <bool>false</bool>\n              </property>\n              <property name=\"openExternalLinks\">\n               <bool>true</bool>\n              </property>\n             </widget>\n            </item>\n            <item row=\"3\" column=\"0\">\n             <widget class=\"QLabel\" name=\"label_14\">\n              <property name=\"text\">\n               <string>Language codes (comma-separated):</string>\n              </property>\n             </widget>\n            </item>\n            <item row=\"3\" column=\"1\">\n             <widget class=\"QLineEdit\" name=\"forvoLanguageCodes\">\n              <property name=\"toolTip\">\n               <string>List of language codes you would like to have. Example: &quot;en, ru&quot;.</string>\n              </property>\n             </widget>\n            </item>\n            <item row=\"4\" column=\"0\">\n             <spacer name=\"horizontalSpacer\">\n              <property name=\"orientation\">\n               <enum>Qt::Horizontal</enum>\n              </property>\n              <property name=\"sizeType\">\n               <enum>QSizePolicy::Fixed</enum>\n              </property>\n              <property name=\"sizeHint\" stdset=\"0\">\n               <size>\n                <width>18</width>\n                <height>20</height>\n               </size>\n              </property>\n             </spacer>\n            </item>\n            <item row=\"4\" column=\"1\">\n             <widget class=\"QLabel\" name=\"label_15\">\n              <property name=\"text\">\n               <string>Full list of language codes is available &lt;a href=&quot;http://www.forvo.com/languages-codes/&quot;&gt;here&lt;/a&gt;.</string>\n              </property>\n              <property name=\"openExternalLinks\">\n               <bool>true</bool>\n              </property>\n             </widget>\n            </item>\n            <item row=\"2\" column=\"0\">\n             <spacer name=\"verticalSpacer_11\">\n              <property name=\"orientation\">\n               <enum>Qt::Vertical</enum>\n              </property>\n              <property name=\"sizeHint\" stdset=\"0\">\n               <size>\n                <width>20</width>\n                <height>40</height>\n               </size>\n              </property>\n             </spacer>\n            </item>\n           </layout>\n          </item>\n          <item>\n           <spacer name=\"verticalSpacer_10\">\n            <property name=\"orientation\">\n             <enum>Qt::Vertical</enum>\n            </property>\n            <property name=\"sizeHint\" stdset=\"0\">\n             <size>\n              <width>20</width>\n              <height>40</height>\n             </size>\n            </property>\n           </spacer>\n          </item>\n         </layout>\n        </widget>\n       </item>\n      </layout>\n     </widget>\n     <widget class=\"QWidget\" name=\"tab_3\">\n      <attribute name=\"title\">\n       <string>Transliteration</string>\n      </attribute>\n      <layout class=\"QVBoxLayout\" name=\"transliterationLayout\">\n       <item>\n        <spacer name=\"verticalSpacer_5\">\n         <property name=\"orientation\">\n          <enum>Qt::Vertical</enum>\n         </property>\n         <property name=\"sizeHint\" stdset=\"0\">\n          <size>\n           <width>20</width>\n           <height>40</height>\n          </size>\n         </property>\n        </spacer>\n       </item>\n       <item>\n        <layout class=\"QGridLayout\" name=\"gridLayout_2\">\n         <item row=\"0\" column=\"0\">\n          <widget class=\"QCheckBox\" name=\"enableRussianTransliteration\">\n           <property name=\"text\">\n            <string>Russian transliteration</string>\n           </property>\n           <property name=\"icon\">\n            <iconset resource=\"flags.qrc\">\n             <normaloff>:/flags/ru.png</normaloff>:/flags/ru.png</iconset>\n           </property>\n          </widget>\n         </item>\n         <item row=\"0\" column=\"1\">\n          <widget class=\"QCheckBox\" name=\"enableGreekTransliteration\">\n           <property name=\"text\">\n            <string>Greek transliteration</string>\n           </property>\n           <property name=\"icon\">\n            <iconset resource=\"flags.qrc\">\n             <normaloff>:/flags/gr.png</normaloff>:/flags/gr.png</iconset>\n           </property>\n          </widget>\n         </item>\n         <item row=\"1\" column=\"0\">\n          <spacer name=\"verticalSpacer_6\">\n           <property name=\"orientation\">\n            <enum>Qt::Vertical</enum>\n           </property>\n           <property name=\"sizeHint\" stdset=\"0\">\n            <size>\n             <width>20</width>\n             <height>40</height>\n            </size>\n           </property>\n          </spacer>\n         </item>\n         <item row=\"2\" column=\"0\">\n          <widget class=\"QCheckBox\" name=\"enableGermanTransliteration\">\n           <property name=\"text\">\n            <string>German transliteration</string>\n           </property>\n           <property name=\"icon\">\n            <iconset resource=\"flags.qrc\">\n             <normaloff>:/flags/de.png</normaloff>:/flags/de.png</iconset>\n           </property>\n          </widget>\n         </item>\n         <item row=\"2\" column=\"1\">\n          <widget class=\"QCheckBox\" name=\"enableBelarusianTransliteration\">\n           <property name=\"text\">\n            <string>Belarusian transliteration</string>\n           </property>\n           <property name=\"icon\">\n            <iconset resource=\"flags.qrc\">\n             <normaloff>:/flags/by.png</normaloff>:/flags/by.png</iconset>\n           </property>\n          </widget>\n         </item>\n        </layout>\n       </item>\n       <item>\n        <spacer name=\"verticalSpacer_7\">\n         <property name=\"orientation\">\n          <enum>Qt::Vertical</enum>\n         </property>\n         <property name=\"sizeHint\" stdset=\"0\">\n          <size>\n           <width>20</width>\n           <height>40</height>\n          </size>\n         </property>\n        </spacer>\n       </item>\n       <item>\n        <widget class=\"QGroupBox\" name=\"enableRomaji\">\n         <property name=\"toolTip\">\n          <string>Enables to use the Latin alphabet to write the Japanese language</string>\n         </property>\n         <property name=\"title\">\n          <string>Japanese Romaji</string>\n         </property>\n         <property name=\"checkable\">\n          <bool>true</bool>\n         </property>\n         <property name=\"checked\">\n          <bool>true</bool>\n         </property>\n         <layout class=\"QGridLayout\" name=\"gridLayout\">\n          <item row=\"0\" column=\"0\">\n           <widget class=\"QLabel\" name=\"label_7\">\n            <property name=\"text\">\n             <string>Systems:</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"0\" column=\"1\">\n           <widget class=\"QCheckBox\" name=\"enableHepburn\">\n            <property name=\"toolTip\">\n             <string>The most widely used method of transcription of Japanese,\nbased on English phonology</string>\n            </property>\n            <property name=\"text\">\n             <string>Hepburn</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"0\" column=\"2\">\n           <widget class=\"QCheckBox\" name=\"enableNihonShiki\">\n            <property name=\"enabled\">\n             <bool>false</bool>\n            </property>\n            <property name=\"toolTip\">\n             <string>The most regular system, having a one-to-one relation to the\nkana writing systems. Standardized as ISO 3602\n\nNot implemented yet in GoldenDict.</string>\n            </property>\n            <property name=\"text\">\n             <string>Nihon-shiki</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"0\" column=\"3\">\n           <widget class=\"QCheckBox\" name=\"enableKunreiShiki\">\n            <property name=\"enabled\">\n             <bool>false</bool>\n            </property>\n            <property name=\"toolTip\">\n             <string>Based on Nihon-shiki system, but modified for modern standard Japanese.\nStandardized as ISO 3602\n\nNot implemented yet in GoldenDict.</string>\n            </property>\n            <property name=\"text\">\n             <string>Kunrei-shiki</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"1\" column=\"0\">\n           <widget class=\"QLabel\" name=\"label_8\">\n            <property name=\"text\">\n             <string>Syllabaries:</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"1\" column=\"2\">\n           <widget class=\"QCheckBox\" name=\"enableHiragana\">\n            <property name=\"toolTip\">\n             <string>Hiragana Japanese syllabary</string>\n            </property>\n            <property name=\"text\">\n             <string>Hiragana</string>\n            </property>\n           </widget>\n          </item>\n          <item row=\"1\" column=\"3\">\n           <widget class=\"QCheckBox\" name=\"enableKatakana\">\n            <property name=\"toolTip\">\n             <string>Katakana Japanese syllabary</string>\n            </property>\n            <property name=\"text\">\n             <string>Katakana</string>\n            </property>\n           </widget>\n          </item>\n         </layout>\n        </widget>\n       </item>\n       <item>\n        <spacer name=\"verticalSpacer_4\">\n         <property name=\"orientation\">\n          <enum>Qt::Vertical</enum>\n         </property>\n         <property name=\"sizeHint\" stdset=\"0\">\n          <size>\n           <width>20</width>\n           <height>40</height>\n          </size>\n         </property>\n        </spacer>\n       </item>\n      </layout>\n     </widget>\n    </widget>\n   </item>\n  </layout>\n </widget>\n <tabstops>\n  <tabstop>enableRussianTransliteration</tabstop>\n  <tabstop>enableGermanTransliteration</tabstop>\n  <tabstop>enableRomaji</tabstop>\n  <tabstop>enableHepburn</tabstop>\n  <tabstop>enableNihonShiki</tabstop>\n  <tabstop>enableKunreiShiki</tabstop>\n  <tabstop>enableHiragana</tabstop>\n  <tabstop>enableKatakana</tabstop>\n  <tabstop>hunspellPath</tabstop>\n  <tabstop>changeHunspellPath</tabstop>\n  <tabstop>hunspellDictionaries</tabstop>\n  <tabstop>mediaWikis</tabstop>\n  <tabstop>addMediaWiki</tabstop>\n  <tabstop>removeMediaWiki</tabstop>\n  <tabstop>tabWidget</tabstop>\n  <tabstop>addPath</tabstop>\n  <tabstop>removePath</tabstop>\n  <tabstop>rescan</tabstop>\n  <tabstop>soundDirs</tabstop>\n  <tabstop>addSoundDir</tabstop>\n  <tabstop>removeSoundDir</tabstop>\n  <tabstop>paths</tabstop>\n </tabstops>\n <resources>\n  <include location=\"flags.qrc\"/>\n  <include location=\"resources.qrc\"/>\n </resources>\n <connections/>\n</ui>\n"
        },
        {
          "name": "speechclient.hh",
          "type": "blob",
          "size": 0.994140625,
          "content": "#ifndef __SPEECHCLIENT_HH_INCLUDED__\n#define __SPEECHCLIENT_HH_INCLUDED__\n\n#include <QObject>\n#include \"config.hh\"\n\nclass SpeechClient: public QObject\n{\nQ_OBJECT\n\npublic:\n\n  struct Engine\n  {\n    QString id;\n    QString name;\n    // Volume and rate may vary from 0 to 100\n    int volume;\n    int rate;\n    Engine( Config::VoiceEngine const & e ) :\n      id( e.id )\n      , name( e.name )\n      , volume( e.volume )\n      , rate( e.rate )\n    {}\n  };\n\n  typedef QList<Engine> Engines;\n\n  SpeechClient( Config::VoiceEngine const & e, QObject * parent = 0L );\n  virtual ~SpeechClient();\n\n  static Engines availableEngines();\n\n  const Engine & engine() const;\n\n  bool tell( QString const & text, int volume = -1, int rate = -1 );\n  bool say( QString const & text, int volume = -1, int rate = -1 );\n\nsignals:\n  void started( bool ok );\n  void finished();\n\nprotected:\n  virtual void timerEvent( QTimerEvent * evt );\n\nprivate:\n  struct InternalData;\n  InternalData * internalData;\n\n};\n\n#endif // __SPEECHCLIENT_HH_INCLUDED__\n"
        },
        {
          "name": "speechclient_mac.mm",
          "type": "blob",
          "size": 4.7119140625,
          "content": "#include \"speechclient.hh\"\n\n#include <QtCore>\n#include <AppKit/NSSpeechSynthesizer.h>\n#include <Foundation/NSArray.h>\n#include <Foundation/NSError.h>\n#include <Foundation/NSString.h>\n#include <Foundation/NSAutoreleasePool.h>\n\nstatic QString NSStringToQString(const NSString * nsstr )\n{\n  return QString::fromUtf8( [ nsstr UTF8String ] );\n}\n\nstatic NSString * QStringToNSString( QString const & qstr, bool needAlloc = false )\n{\n  if( needAlloc )\n    return [ [ NSString alloc ] initWithUTF8String : qstr.toUtf8().data() ];\n  return [ NSString stringWithUTF8String : qstr.toUtf8().data() ];\n}\n\nstruct SpeechClient::InternalData\n{\n  InternalData( Config::VoiceEngine const & e ):\n    waitingFinish( false )\n    , engine( e )\n    , oldVolume( -1 )\n    , oldRate( -1 )\n    , stringToPlay( nil )\n  {\n    NSAutoreleasePool * pool = [ [ NSAutoreleasePool alloc ] init ];\n    sp = [ [ NSSpeechSynthesizer alloc ] initWithVoice : QStringToNSString( e.id ) ];\n    [ pool drain ];\n  }\n\n  ~InternalData()\n  {\n    [ sp release ];\n    if( stringToPlay != nil )\n      [ stringToPlay release ];\n  }\n\n  NSSpeechSynthesizer * sp;\n  bool waitingFinish;\n  SpeechClient::Engine engine;\n  float oldVolume;\n  float oldRate;\n  QString oldMode;\n  NSString * stringToPlay;\n};\n\nSpeechClient::SpeechClient( Config::VoiceEngine const & e, QObject * parent ):\n  QObject( parent ),\n  internalData( new InternalData( e ) )\n{\n}\n\nSpeechClient::~SpeechClient()\n{\n  delete internalData;\n}\n\nSpeechClient::Engines SpeechClient::availableEngines()\n{\n  Engines engines;\n  NSAutoreleasePool * pool = [ [ NSAutoreleasePool alloc ] init ];\n\n  NSArray * voices = [ NSSpeechSynthesizer availableVoices ];\n  int voicesNum = [ voices count ];\n  for( int i = 0; i < voicesNum; i++ )\n  {\n    QString id = NSStringToQString( [ voices objectAtIndex : i ] );\n    QString name;\n    int n = id.lastIndexOf( '.' );\n    if( n >= 0 )\n      name = id.right( id.size() - n - 1 );\n    else\n      name = id;\n    engines.push_back( SpeechClient::Engine( Config::VoiceEngine(\n                                             id, name, 50, 50 ) ) );\n  }\n\n  [ pool drain ];\n  return engines;\n}\n\nconst SpeechClient::Engine & SpeechClient::engine() const\n{\n  return internalData->engine;\n}\n\nbool SpeechClient::tell( QString const & text, int volume, int rate )\n{\n  if( !internalData->sp || [ NSSpeechSynthesizer isAnyApplicationSpeaking ] )\n    return false;\n\n  if ( internalData->waitingFinish )\n    return false;\n\n  if( volume < 0 )\n    volume = engine().volume;\n  if( rate < 0 )\n    rate = engine().rate;\n\n  NSAutoreleasePool * pool = [ [ NSAutoreleasePool alloc ] init ];\n\n  internalData->oldVolume = [ internalData->sp volume ];\n  [ internalData->sp setVolume : ( volume / 100.0 ) ];\n\n  internalData->oldRate = [ internalData->sp rate ];\n  [ internalData->sp setRate : ( rate * 2.0 + 100 ) ];\n\n  NSError * err = nil;\n  NSString * oldMode = [ internalData->sp objectForProperty : NSSpeechInputModeProperty error : &err ];\n  if( err == nil || [ err code ] == 0 )\n  {\n    internalData->oldMode = NSStringToQString( oldMode );\n    [ internalData->sp setObject : NSSpeechModeText forProperty : NSSpeechInputModeProperty error : &err ];\n  }\n  else\n    internalData->oldMode.clear();\n\n  internalData->stringToPlay = QStringToNSString( text, true );\n\n  bool ok = [ internalData->sp startSpeakingString : internalData->stringToPlay ];\n\n  emit started( ok );\n\n  if ( ok )\n  {\n    internalData->waitingFinish = true;\n    startTimer( 50 );\n  }\n  else\n  {\n    if( internalData->stringToPlay != nil )\n      [ internalData->stringToPlay release ];\n    internalData->stringToPlay = nil;\n    emit finished();\n  }\n\n  [ pool drain ];\n\n  return ok;\n}\n\nbool SpeechClient::say( QString const & text, int volume, int rate )\n{\n(void) text;\n(void) volume;\n(void) rate;\n  return false;\n}\n\nvoid SpeechClient::timerEvent( QTimerEvent * evt )\n{\n  QObject::timerEvent( evt );\n\n  if ( !internalData->waitingFinish )\n    return;\n\n  if ( ![ internalData->sp isSpeaking ] )\n  {\n    killTimer( evt->timerId() ) ;\n    internalData->waitingFinish = false;\n\n    NSAutoreleasePool * pool = [ [ NSAutoreleasePool alloc ] init ];\n\n    if( internalData->oldVolume >=0 )\n      [ internalData->sp setVolume : internalData->oldVolume ];\n    if( internalData->oldRate >=0 )\n      [ internalData->sp setRate : internalData->oldRate ];\n    internalData->oldVolume = -1;\n    internalData->oldRate = -1;\n\n    NSError * err;\n    if( !internalData->oldMode.isEmpty() )\n      [ internalData->sp setObject : QStringToNSString( internalData->oldMode )\n                         forProperty : NSSpeechInputModeProperty error : &err ];\n\n    internalData->oldMode.clear();\n\n    if( internalData->stringToPlay != nil )\n      [ internalData->stringToPlay release ];\n    internalData->stringToPlay = nil;\n\n    [ pool drain ];\n\n    emit finished();\n  }\n}\n"
        },
        {
          "name": "speechclient_win.cc",
          "type": "blob",
          "size": 3.103515625,
          "content": "#include \"speechclient.hh\"\n\n#include <windows.h>\n#include \"speechhlp.hh\"\n\n#include <QtCore>\n\nstruct SpeechClient::InternalData\n{\n  InternalData( Config::VoiceEngine const & e ):\n    waitingFinish( false )\n    , engine( e )\n    , oldVolume( -1 )\n    , oldRate( -1 )\n  {\n    sp = speechCreate( e.id.toStdWString().c_str() );\n  }\n\n  ~InternalData()\n  {\n    speechDestroy( sp );\n  }\n\n  SpeechHelper sp;\n  bool waitingFinish;\n  Engine engine;\n  int oldVolume;\n  int oldRate;\n};\n\nSpeechClient::SpeechClient( Config::VoiceEngine const & e, QObject * parent ):\n  QObject( parent ),\n  internalData( new InternalData( e ) )\n{\n}\n\nSpeechClient::~SpeechClient()\n{\n  delete internalData;\n}\n\nstatic bool enumEngines( void * /* token */,\n                         const wchar_t * id,\n                         const wchar_t * name,\n                         void * userData )\n{\n  SpeechClient::Engines * pEngines = ( SpeechClient::Engines * )userData;\n  SpeechClient::Engine engine( Config::VoiceEngine(\n    QString::fromWCharArray( id ),\n    QString::fromWCharArray( name ),\n    50, 50 ) );\n  pEngines->push_back( engine );\n  return true;\n}\n\nSpeechClient::Engines SpeechClient::availableEngines()\n{\n  Engines engines;\n  speechEnumerateAvailableEngines( enumEngines, &engines );\n  return engines;\n}\n\nconst SpeechClient::Engine & SpeechClient::engine() const\n{\n  return internalData->engine;\n}\n\nbool SpeechClient::tell( QString const & text, int volume, int rate )\n{\n  if ( !speechAvailable( internalData->sp ) )\n    return false;\n\n  if ( internalData->waitingFinish )\n    return false;\n\n  if( volume < 0 )\n    volume = engine().volume;\n  if( rate < 0 )\n    rate = engine().rate;\n\n  internalData->oldVolume = setSpeechVolume( internalData->sp, volume );\n  internalData->oldRate = setSpeechRate( internalData->sp, rate );\n\n  bool ok = speechTell( internalData->sp, text.toStdWString().c_str() );\n\n  emit started( ok );\n\n  if ( ok )\n  {\n    internalData->waitingFinish = true;\n    startTimer( 50 );\n  }\n  else\n  {\n    emit finished();\n  }\n  return ok;\n}\n\nbool SpeechClient::say( QString const & text, int volume, int rate )\n{\n  if ( !speechAvailable( internalData->sp ) )\n    return false;\n\n  if( volume < 0 )\n    volume = engine().volume;\n  if( rate < 0 )\n    rate = engine().rate;\n\n  int oldVolume = setSpeechVolume( internalData->sp, volume );\n  int oldRate = setSpeechRate( internalData->sp, rate );\n\n  bool ok = speechSay( internalData->sp, text.toStdWString().c_str() );\n\n  if( oldVolume >=0 )\n    setSpeechVolume( internalData->sp, oldVolume );\n  if( oldRate >=0 )\n    setSpeechRate( internalData->sp, oldRate );\n\n  return ok;\n}\n\nvoid SpeechClient::timerEvent( QTimerEvent * evt )\n{\n  QObject::timerEvent( evt );\n\n  if ( !internalData->waitingFinish )\n    return;\n\n  if ( speechTellFinished( internalData->sp ) )\n  {\n    killTimer( evt->timerId() ) ;\n    internalData->waitingFinish = false;\n\n    if( internalData->oldVolume >=0 )\n      setSpeechVolume( internalData->sp, internalData->oldVolume );\n    if( internalData->oldRate >=0 )\n      setSpeechRate( internalData->sp, internalData->oldRate );\n    internalData->oldVolume = -1;\n    internalData->oldRate = -1;\n\n    emit finished();\n  }\n}\n"
        },
        {
          "name": "speechhlp.cc",
          "type": "blob",
          "size": 4.2470703125,
          "content": "#define WINVER 0x0500 // At least WinXP required\n#include <windows.h>\n#include <limits.h>\n\n#include \"speechhlp.hh\"\n#include <string>\n#include \"sapi.hh\"\n#include \"sphelper.hh\"\n\nusing std::wstring;\n\nstruct _SpeechHelper\n{\n    ISpVoice * voice;\n    wstring engineId;\n    wstring engineName;\n    bool willInvokeCoUninitialize;\n\n    _SpeechHelper() :\n        willInvokeCoUninitialize(false)\n    {\n        HRESULT hr;\n        hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);\n        willInvokeCoUninitialize = (hr != RPC_E_CHANGED_MODE);\n        CoCreateInstance(CLSID_SpVoice, NULL, CLSCTX_INPROC_SERVER, IID_ISpVoice, (void**)&voice);\n    }\n\n    ~_SpeechHelper()\n    {\n        if (voice)\n            voice->Release();\n\n        if (willInvokeCoUninitialize)\n            CoUninitialize();\n    }\n};\n\nSpeechHelper speechCreate(const wchar_t *engineId)\n{\n    SpeechHelper sp = new _SpeechHelper();\n    HRESULT hr;\n    ISpObjectToken * spToken;\n\n    hr = SpGetTokenFromId(engineId, &spToken);\n\n    if (SUCCEEDED(hr))\n    {\n        if (SUCCEEDED(hr) && sp->voice)\n        {\n            sp->voice->SetVoice(spToken);\n\n            WCHAR * engineName = NULL;\n            SpGetDescription( spToken, &engineName );\n            sp->engineId = engineId;\n            if (engineName)\n            {\n                sp->engineName = engineName;\n                CoTaskMemFree(engineName);\n            }\n        }\n\n        spToken->Release();\n    }\n\n    return sp;\n}\n\nvoid speechDestroy(SpeechHelper sp)\n{\n    delete sp;\n}\n\nbool speechAvailable(SpeechHelper sp)\n{\n    if (!sp)\n        return false;\n\n    return !!(sp->voice);\n}\n\nvoid speechEnumerateAvailableEngines(EnumerateCallback callback, void *userData)\n{\n    HRESULT hr;\n    IEnumSpObjectTokens * enumSpTokens = NULL;\n    ULONG count = 0;\n    bool next = true;\n    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);\n    bool willInvokeCoUninitialize = (hr != RPC_E_CHANGED_MODE);\n    hr = SpEnumTokens(SPCAT_VOICES, NULL, NULL, &enumSpTokens);\n    if (SUCCEEDED(hr))\n        hr = enumSpTokens->GetCount(&count);\n\n    for (ULONG i = 0; i < count && next; i++)\n    {\n        ISpObjectToken * spToken = NULL;\n        WCHAR * engineName = NULL;\n        WCHAR * engineId = NULL;\n\n        if (SUCCEEDED(hr))\n            hr = enumSpTokens->Next(1, &spToken, NULL);\n        if (SUCCEEDED(hr))\n            hr = SpGetDescription(spToken, &engineName);\n        if (SUCCEEDED(hr))\n            hr = spToken->GetId(&engineId);\n\n        if (SUCCEEDED(hr))\n            next = callback(spToken, engineId, engineName, userData);\n\n        if( spToken )\n          spToken->Release();\n\n        if (engineName)\n            CoTaskMemFree(engineName);\n        if (engineId)\n            CoTaskMemFree(engineId);\n    }\n\n    if( enumSpTokens )\n      enumSpTokens->Release();\n\n    if (willInvokeCoUninitialize)\n        CoUninitialize();\n}\n\nconst wchar_t * speechEngineId(SpeechHelper sp)\n{\n    if (!sp)\n        return NULL;\n\n    return sp->engineId.c_str();\n}\n\nconst wchar_t * speechEngineName(SpeechHelper sp)\n{\n    if (!sp)\n        return NULL;\n\n    return sp->engineName.c_str();\n}\n\nbool speechTell(SpeechHelper sp, const wchar_t *text)\n{\n    if (!sp || !sp->voice || !text)\n        return false;\n\n    HRESULT hr = sp->voice->Speak(text, SPF_ASYNC | SPF_IS_NOT_XML, 0);\n    return !!SUCCEEDED(hr);\n}\n\nbool speechTellFinished(SpeechHelper sp)\n{\n    if (!sp || !sp->voice)\n        return true;\n\n    SPVOICESTATUS es;\n    sp->voice->GetStatus(&es, NULL);\n    return es.dwRunningState == SPRS_DONE;\n}\n\nbool speechSay(SpeechHelper sp, const wchar_t *text)\n{\n    if (!sp || !sp->voice || !text)\n        return false;\n\n    HRESULT hr = sp->voice->Speak(text, SPF_IS_NOT_XML, 0);\n    return !!SUCCEEDED(hr);\n}\n\nint setSpeechVolume( SpeechHelper sp, int newVolume )\n{\n  if( !sp || !sp->voice || newVolume < 0 || newVolume > 100 )\n    return -1;\n  unsigned short oldVolume;\n  HRESULT hr = sp->voice->GetVolume( &oldVolume );\n  if( !SUCCEEDED( hr ) )\n    return -1;\n  sp->voice->SetVolume( (unsigned short) newVolume );\n  return oldVolume;\n}\n\nint setSpeechRate( SpeechHelper sp, int newRate )\n{\n  if( !sp || !sp->voice || newRate < 0 || newRate > 100 )\n    return -1;\n  long oldRate;\n  HRESULT hr = sp->voice->GetRate( &oldRate );\n  if( !SUCCEEDED( hr ) )\n    return -1;\n  sp->voice->SetRate( ( newRate - 50 ) / 5 );\n  return oldRate * 5 + 50;\n}\n"
        },
        {
          "name": "speechhlp.hh",
          "type": "blob",
          "size": 0.8408203125,
          "content": "#ifndef __SPEECHHLP_H__\n#define __SPEECHHLP_H__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct _SpeechHelper *SpeechHelper;\ntypedef bool (*EnumerateCallback)(void *token, const wchar_t *id, const wchar_t *name, void *userData);\n\nSpeechHelper speechCreate(const wchar_t *engineId);\nvoid speechDestroy(SpeechHelper sp);\nbool speechAvailable(SpeechHelper sp);\nvoid speechEnumerateAvailableEngines(EnumerateCallback callback, void *userData);\nconst wchar_t * speechEngineId(SpeechHelper sp);\nconst wchar_t * speechEngineName(SpeechHelper sp);\nbool speechTell(SpeechHelper sp, const wchar_t *text);\nbool speechTellFinished(SpeechHelper sp);\nbool speechSay(SpeechHelper sp, const wchar_t *text);\nint setSpeechVolume( SpeechHelper sp, int newVolume );\nint setSpeechRate( SpeechHelper sp, int newRate );\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // __SPEECHHLP_H__\n"
        },
        {
          "name": "sphelper.hh",
          "type": "blob",
          "size": 7.4658203125,
          "content": "#ifndef __SPHELPER_HH_INCLUDED__\n#define __SPHELPER_HH_INCLUDED__\n\n#ifndef SR_LOCALIZED_DESCRIPTION\n#define SR_LOCALIZED_DESCRIPTION L\"Description\"\n#endif\n\n#ifndef REG_MUI_STRING_TRUNCATE\n#define REG_MUI_STRING_TRUNCATE     0x00000001\n#endif\n\n#ifndef SPERR_NOT_FOUND\n#define FACILITY_SAPI      FACILITY_ITF\n#define SAPI_ERROR_BASE    0x5000\n#define MAKE_SAPI_HRESULT(sev, err)    MAKE_HRESULT(sev, FACILITY_SAPI, err)\n#define MAKE_SAPI_ERROR(err)           MAKE_SAPI_HRESULT(SEVERITY_ERROR, err + SAPI_ERROR_BASE)\n#define SPERR_NOT_FOUND                MAKE_SAPI_ERROR(0x03a)\n#endif\n\n#ifdef _SAPI_VER\n#undef _SAPI_VER\n#endif\n#define _SAPI_VER 0x053\n\ninline void SpHexFromUlong(WCHAR * psz, ULONG ul)\n{\n    // If for some reason we cannot convert a number, set it to 0\n\n    if (_ultow(ul, psz, 16))\n    {\n        psz[0] = L'0';\n        psz[1] = 0;\n    }\n}\n\ninline HRESULT SpGetTokenFromId(\n    const WCHAR * pszTokenId,\n    ISpObjectToken ** ppToken,\n    BOOL fCreateIfNotExist = FALSE)\n{\n    HRESULT hr;\n    ISpObjectToken * cpToken;\n    hr = CoCreateInstance(CLSID_SpObjectToken, NULL, CLSCTX_INPROC_SERVER,\n                          IID_ISpObjectToken, (void**)&cpToken);\n\n    if (SUCCEEDED(hr))\n    {\n        hr = cpToken->SetId(NULL, pszTokenId, fCreateIfNotExist);\n        if (SUCCEEDED(hr))\n        {\n            *ppToken = cpToken;\n        }\n        else\n            cpToken->Release();\n    }\n\n    return hr;\n}\n\ninline HRESULT SpGetCategoryFromId(\n    const WCHAR * pszCategoryId,\n    ISpObjectTokenCategory ** ppCategory,\n    BOOL fCreateIfNotExist = FALSE)\n{\n    HRESULT hr;\n\n    ISpObjectTokenCategory * cpTokenCategory;\n    hr = CoCreateInstance(CLSID_SpObjectTokenCategory, NULL, CLSCTX_INPROC_SERVER,\n                          IID_ISpObjectTokenCategory, (void**)&cpTokenCategory );\n\n    if (SUCCEEDED(hr))\n    {\n      hr = cpTokenCategory->SetId(pszCategoryId, fCreateIfNotExist);\n      if (SUCCEEDED(hr))\n      {\n        *ppCategory = cpTokenCategory;\n      }\n      else\n        cpTokenCategory->Release();\n    }\n\n    return hr;\n}\n\nHRESULT SpEnumTokens(\n    const WCHAR * pszCategoryId,\n    const WCHAR * pszReqAttribs,\n    const WCHAR * pszOptAttribs,\n    IEnumSpObjectTokens ** ppEnum)\n{\n    HRESULT hr = S_OK;\n\n    ISpObjectTokenCategory * cpCategory;\n    hr = SpGetCategoryFromId(pszCategoryId, &cpCategory);\n\n    if (SUCCEEDED(hr))\n    {\n        hr = cpCategory->EnumTokens(\n                    pszReqAttribs,\n                    pszOptAttribs,\n                    ppEnum);\n        cpCategory->Release();\n    }\n\n    return hr;\n}\n\ninline HRESULT SpGetDescription(ISpObjectToken * pObjToken, WCHAR ** ppszDescription, LANGID Language = GetUserDefaultUILanguage())\n{\n    WCHAR szLangId[10];\n    HRESULT hr = S_OK;\n\n    if (ppszDescription == NULL)\n    {\n        return E_POINTER;\n    }\n    *ppszDescription = NULL;\n\n#if _SAPI_VER >= 0x053\n    WCHAR* pRegKeyPath = 0;\n    WCHAR* pszTemp = 0;\n    HKEY   Handle = NULL;\n\n    // Windows Vista does not encourage localized strings in the registry\n    // When running on Windows Vista query the localized engine name from a resource dll\n    OSVERSIONINFO ver;\n    ver.dwOSVersionInfoSize = sizeof( ver );\n\n    if( ( ::GetVersionEx( &ver ) == TRUE ) && ( ver.dwMajorVersion >= 6 ) )\n    {\n        // If we reach this code we are running under Windows Vista\n        HMODULE hmodAdvapi32Dll = NULL;\n        typedef HRESULT (WINAPI* LPFN_RegLoadMUIStringW)(HKEY, LPCWSTR, LPWSTR, DWORD, LPDWORD, DWORD, LPCWSTR);\n        LPFN_RegLoadMUIStringW pfnRegLoadMUIStringW = NULL;\n\n        // Delay bind with RegLoadMUIStringW since this function is not supported on previous versions of advapi32.dll\n        // RegLoadMUIStringW is supported only on advapi32.dll that ships with Windows Vista  and above\n        // Calling RegLoadMUIStringW directly makes the loader try to resolve the function reference at load time which breaks,\n        // hence we manually load advapi32.dll, query for the function pointer and invoke it.\n        hmodAdvapi32Dll = ::LoadLibrary(TEXT(\"advapi32.dll\"));\n        if(hmodAdvapi32Dll)\n        {\n            pfnRegLoadMUIStringW = (LPFN_RegLoadMUIStringW) ::GetProcAddress(hmodAdvapi32Dll, \"RegLoadMUIStringW\");\n            if (!pfnRegLoadMUIStringW)\n            {\n                // This should not happen in Vista\n                // _ASSERT (pfnRegLoadMUIStringW);\n                hr = TYPE_E_DLLFUNCTIONNOTFOUND;\n            }\n        }\n        else\n        {\n            hr = HRESULT_FROM_WIN32(ERROR_DLL_NOT_FOUND);\n        }\n\n        if (SUCCEEDED(hr))\n        {\n            hr = pObjToken->GetId(&pszTemp);\n        }\n\n        if (SUCCEEDED(hr))\n        {\n            LONG   lErrorCode = ERROR_SUCCESS;\n\n            pRegKeyPath = wcschr(pszTemp, L'\\\\');   // Find the first occurrence of '\\\\' in the absolute registry key path\n            if(pRegKeyPath)\n            {\n                *pRegKeyPath = L'\\0';\n                pRegKeyPath++;                         // pRegKeyPath now points to the path to the recognizer token under the HKLM or HKCR hive\n                *ppszDescription = 0;\n\n                // Open the registry key for read and get the handle\n                if (wcsncmp(pszTemp, L\"HKEY_LOCAL_MACHINE\", MAX_PATH) == 0)\n                {\n                    lErrorCode = RegOpenKeyExW(HKEY_LOCAL_MACHINE, pRegKeyPath, 0, KEY_QUERY_VALUE, &Handle);\n                }\n                else if (wcsncmp(pszTemp, L\"HKEY_CURRENT_USER\", MAX_PATH) == 0)\n                {\n                    lErrorCode = RegOpenKeyExW(HKEY_CURRENT_USER, pRegKeyPath, 0, KEY_QUERY_VALUE, &Handle);\n                }\n                else\n                {\n                    lErrorCode = ERROR_BAD_ARGUMENTS;\n                }\n\n                // Use MUI RegLoadMUIStringW API to load the localized string\n                if(ERROR_SUCCESS == lErrorCode)\n                {\n                    *ppszDescription = (WCHAR*) CoTaskMemAlloc(MAX_PATH * sizeof(WCHAR)); // This should be enough memory to allocate the localized Engine Name\n                    lErrorCode = (*pfnRegLoadMUIStringW) (Handle, SR_LOCALIZED_DESCRIPTION, *ppszDescription, MAX_PATH * sizeof(WCHAR), NULL, REG_MUI_STRING_TRUNCATE, NULL);\n                }\n            }\n            else\n            {\n                // pRegKeyPath should never be 0 if we are querying for relative hkey path\n                lErrorCode = ERROR_BAD_ARGUMENTS;\n            }\n\n            hr = HRESULT_FROM_WIN32(lErrorCode);\n        }\n\n        // Close registry key handle\n        if(Handle)\n        {\n            RegCloseKey(Handle);\n        }\n        // Free memory allocated to locals\n        if(pszTemp)\n        {\n            CoTaskMemFree(pszTemp);\n        }\n        if (hmodAdvapi32Dll)\n        {\n            ::FreeLibrary(hmodAdvapi32Dll);\n        }\n    }\n    else\n    {\n        hr = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);\n    }\n\n    // If running on OSes released before Windows Vista query the localized string from the registry\n    // If RegLoadMUIStringW failed to retrieved the localized Engine name retrieve the localized string from the fallback (Default) attribute\n#else\n    hr = E_FAIL;\n#endif // _SAPI_VER >= 0x053\n    if (FAILED(hr))\n    {\n        // Free memory allocated above if necessary\n        if (*ppszDescription != NULL)\n        {\n            CoTaskMemFree(*ppszDescription);\n            *ppszDescription = NULL;\n        }\n\n        SpHexFromUlong(szLangId, Language);\n        hr = pObjToken->GetStringValue(szLangId, ppszDescription);\n        if (hr == SPERR_NOT_FOUND)\n        {\n            hr = pObjToken->GetStringValue(NULL, ppszDescription);\n        }\n    }\n\n    return hr;\n}\n\n#endif\n"
        },
        {
          "name": "splitfile.cc",
          "type": "blob",
          "size": 2.35546875,
          "content": "/* This file is (c) 2017 Abs62\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"splitfile.hh\"\n#include \"fsencoding.hh\"\n\nnamespace SplitFile\n{\n\nSplitFile::SplitFile() :\n  currentFile( 0 )\n{\n}\n\nSplitFile::~SplitFile()\n{\n  close();\n}\n\nvoid SplitFile::appendFile( const QString & name )\n{\n  if( offsets.isEmpty() )\n    offsets.append( 0 );\n  else\n    offsets.append( offsets.last() + files.last()->size() );\n  files.append( new QFile( name ) );\n}\n\nvoid SplitFile::close()\n{\n  for( QVector< QFile * >::const_iterator i = files.begin(); i != files.end(); ++i )\n  {\n    (*i)->close();\n    delete (*i);\n  }\n\n  files.clear();\n  offsets.clear();\n\n  currentFile = 0;\n}\n\nvoid SplitFile::getFilenames( vector< string > &names ) const\n{\n  for( QVector< QFile const * >::const_iterator i = files.begin(); i != files.end(); ++i )\n    names.push_back( FsEncoding::encode( (*i)->fileName() ) );\n}\n\nbool SplitFile::open( QFile::OpenMode mode )\n{\n  for( QVector< QFile * >::iterator i = files.begin(); i != files.end(); ++i )\n    if( !(*i)->open( mode ) )\n    {\n      close();\n      return false;\n    }\n\n  return true;\n}\n\nbool SplitFile::seek( quint64 pos )\n{\n  if( offsets.isEmpty() )\n    return false;\n\n  int fileNom;\n\n  for( fileNom = 0; fileNom < offsets.size() - 1; fileNom++ )\n    if( pos < offsets.at( fileNom + 1 ) )\n      break;\n\n  pos -= offsets.at( fileNom );\n\n  currentFile = fileNom;\n  return files.at( fileNom )->seek( pos );\n}\n\nqint64 SplitFile::read( char *data, qint64 maxSize )\n{\n  if( offsets.isEmpty() )\n    return 0;\n\n  quint64 bytesReaded = 0;\n  for( int i = currentFile; i < files.size(); i++ )\n  {\n    if( i != currentFile )\n    {\n      files.at( i )->seek( 0 );\n      currentFile = i;\n    }\n\n    qint64 ret = files.at( i )->read( data + bytesReaded, maxSize );\n    if( ret < 0 )\n      break;\n\n    bytesReaded += ret;\n    maxSize -= ret;\n\n    if( maxSize <= 0 )\n      break;\n  }\n  return bytesReaded;\n}\n\nQByteArray SplitFile::read( qint64 maxSize )\n{\n  QByteArray data;\n  data.resize( maxSize );\n\n  qint64 ret = read( data.data(), maxSize );\n\n  if( ret != maxSize )\n    data.resize( ret );\n\n  return data;\n}\n\nbool SplitFile::getChar( char *c )\n{\n  char ch;\n  return read( c ? c : &ch, 1 ) == 1;\n}\n\nqint64 SplitFile::pos() const\n{\n  if( offsets.isEmpty() )\n    return 0;\n\n  return offsets.at( currentFile ) + files.at( currentFile )->pos();\n}\n\n} // namespace SplitFile\n"
        },
        {
          "name": "splitfile.hh",
          "type": "blob",
          "size": 0.970703125,
          "content": "#ifndef __SPLITFILE_HH_INCLUDED__\n#define __SPLITFILE_HH_INCLUDED__\n\n#include <QFile>\n#include <QVector>\n#include <QString>\n\n#include <vector>\n#include <string>\n\nnamespace SplitFile\n{\n\nusing std::vector;\nusing std::string;\n\n// Class for work with split files\n\nclass SplitFile\n{\nprotected:\n\n  QVector< QFile * > files;\n  QVector< quint64 > offsets;\n  int currentFile;\n\n  void appendFile( const QString & name );\n\npublic:\n\n  SplitFile();\n  ~SplitFile();\n\n  virtual void setFileName( const QString & name ) = 0;\n  void getFilenames( vector< string > & names ) const;\n  bool open( QFile::OpenMode mode );\n  void close();\n  bool seek( quint64 pos );\n  qint64 read(  char * data, qint64 maxSize );\n  QByteArray read( qint64 maxSize );\n  bool getChar( char * c );\n  qint64 size() const\n  { return files.isEmpty() ? 0 : offsets.last() + files.last()->size(); }\n  bool exists() const\n  { return !files.isEmpty(); }\n  qint64 pos() const;\n};\n\n} // namespace SplitFile\n\n#endif // __SPLITFILE_HH_INCLUDED__\n"
        },
        {
          "name": "sptr.hh",
          "type": "blob",
          "size": 2.8564453125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __SPTR_HH_INCLUDED__\n#define __SPTR_HH_INCLUDED__\n\n// A generic non-intrusive smart-pointer template. We could use boost::, tr1::\n// or whatever, but since there's no standard solution yet, it isn't worth\n// the dependency given the simplicity of the template.\n\ntemplate< class T >\nclass sptr_base\n{\n  template< class TT > friend class sptr_base;\n\n  T * p;\n  unsigned * count;\n\n\n  void increment()\n  {\n    if ( count )\n      ++*count;\n  }\n\npublic:\n\n  sptr_base(): p( 0 ), count( 0 ) {}\n\n  sptr_base( T * p_ ): p( p_ ), count( p ? new unsigned( 1 ) : 0 )\n  {\n  }\n\n  sptr_base( sptr_base< T > const & other ): p( other.p ), count( other.count )\n  { increment(); }\n\n  // TT is meant to be a derivative of T\n  template< class TT >\n  sptr_base( sptr_base< TT > const & other ): p( ( T * ) other.p ),\n    count( other.count )\n  { increment(); }\n\n  void reset()\n  {\n    if ( count )\n    {\n      if ( ! -- *count )\n      {\n        delete count;\n\n        count = 0;\n\n        if ( p )\n        {\n          T * p_ = p;\n  \n          p = 0;\n  \n          delete p_;\n        }\n      }\n      else\n      {\n        p = 0;\n        count = 0;\n      }\n    }\n  }\n\n  sptr_base & operator = ( sptr_base const & other )\n  { if ( &other != this ) { reset(); p = other.p; count = other.count; increment(); }\n    return * this; }\n\n  bool operator ! ( void ) const\n  { return !p; }\n\n  bool operator == ( sptr_base const & other ) const\n  { return p == other.p; }\n\n  bool operator != ( sptr_base const & other ) const\n  { return p != other.p; }\n\n  ~sptr_base()\n  { reset(); }\n\nprotected:\n\n  T * get_base( void ) const\n  { return p; }\n};\n\ntemplate< class T >\nclass sptr: public sptr_base< T >\n{\npublic:\n\n  sptr() {}\n\n  sptr( T * p ): sptr_base< T >( p ) {}\n  \n  // TT is meant to be a derivative of T\n  template< class TT >\n  sptr( sptr< TT > const & other ): sptr_base< T >( other ) {}\n    \n  // Retrieval\n\n  T * get( void ) const\n    { return sptr_base< T > :: get_base(); }\n\n  T * operator -> ( void ) const\n    { return get(); }\n\n  T & operator * ( void ) const\n    { return * get(); }\n\n  // Check\n\n  operator bool( void ) const\n    { return get();  }\n\n  bool operator ! ( void ) const\n    { return !get(); }\n};\n\ntemplate< class T >\nclass const_sptr: public sptr_base< T >\n{\npublic:\n\n  const_sptr() {}\n\n  const_sptr( T * p_ ): sptr_base< T >( p_ ) {}\n  \n  const_sptr( sptr< T > const & other ): sptr_base< T >( other ) {}\n  \n  // TT is meant to be a derivative of T\n  template< class TT >\n  const_sptr( sptr_base< TT > const & other ): sptr_base< T >( other ) {}\n    \n  // Retrieval\n\n  T const * get( void ) const\n    { return sptr_base< T > :: get_base(); }\n\n  T const * operator -> ( void ) const\n    { return get(); }\n\n  T const & operator * ( void ) const\n    { return * get(); }\n};\n\n\n#endif\n\n"
        },
        {
          "name": "stardict.cc",
          "type": "blob",
          "size": 71.966796875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"stardict.hh\"\n#include \"btreeidx.hh\"\n#include \"folding.hh\"\n#include \"utf8.hh\"\n#include \"chunkedstorage.hh\"\n#include \"dictzip.h\"\n#include \"xdxf2html.hh\"\n#include \"htmlescape.hh\"\n#include \"langcoder.hh\"\n#include \"categorized_logging.hh\"\n#include \"gddebug.hh\"\n#include \"fsencoding.hh\"\n#include \"filetype.hh\"\n#include \"indexedzip.hh\"\n#include \"tiff.hh\"\n#include \"ftshelpers.hh\"\n#include \"wstring_qt.hh\"\n#include \"audiolink.hh\"\n\n#include <zlib.h>\n#include <map>\n#include <set>\n#include <string>\n#ifndef __WIN32\n#include <arpa/inet.h>\n#else\n#include <winsock.h>\n#endif\n#include <stdlib.h>\n\n#ifdef _MSC_VER\n#include <stub_msvc.h>\n#endif\n\n#include <QString>\n#include <QSemaphore>\n#include <QThreadPool>\n#include <QAtomicInt>\n#include <QDebug>\n#include <QRegExp>\n#include <QStringList>\n#include <QDomDocument>\n#include <QDomNode>\n#include \"ufile.hh\"\n#include \"qt4x5.hh\"\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n#include <QRegularExpression>\n#endif\n\nnamespace Stardict {\n\nusing std::map;\nusing std::multimap;\nusing std::pair;\nusing std::set;\nusing std::string;\nusing gd::wstring;\n\nusing BtreeIndexing::WordArticleLink;\nusing BtreeIndexing::IndexedWords;\nusing BtreeIndexing::IndexInfo;\n\nnamespace {\n\nDEF_EX( exNotAnIfoFile, \"Not an .ifo file\", Dictionary::Ex )\nDEF_EX_STR( exBadFieldInIfo, \"Bad field in .ifo file encountered:\", Dictionary::Ex )\nDEF_EX_STR( exNoIdxFile, \"No corresponding .idx file was found for\", Dictionary::Ex )\nDEF_EX_STR( exNoDictFile, \"No corresponding .dict file was found for\", Dictionary::Ex )\nDEF_EX_STR( exNoSynFile, \"No corresponding .syn file was found for\", Dictionary::Ex )\n\nDEF_EX( ex64BitsNotSupported, \"64-bit indices are not presently supported, sorry\", Dictionary::Ex )\nDEF_EX( exDicttypeNotSupported, \"Dictionaries with dicttypes are not supported, sorry\", Dictionary::Ex )\n\nDEF_EX_STR( exCantReadFile, \"Can't read file\", Dictionary::Ex )\nDEF_EX_STR( exWordIsTooLarge, \"Enountered a word that is too large:\", Dictionary::Ex )\nDEF_EX_STR( exSuddenEndOfFile, \"Sudden end of file\", Dictionary::Ex )\nDEF_EX_STR( exDictzipError, \"DICTZIP error\", Dictionary::Ex )\n\nDEF_EX_STR( exIncorrectOffset, \"Incorrect offset encountered in file\", Dictionary::Ex )\n\n/// Contents of an ifo file\nstruct Ifo\n{\n  string version;\n  string bookname;\n  uint32_t wordcount, synwordcount, idxfilesize, idxoffsetbits;\n  string sametypesequence, dicttype, description;\n  string copyright, author, email, website, date;\n\n  Ifo( File::Class & );\n};\n\nenum\n{\n  Signature = 0x58444953, // SIDX on little-endian, XDIS on big-endian\n  CurrentFormatVersion = 9 + BtreeIndexing::FormatVersion + Folding::Version\n};\n\nstruct IdxHeader\n{\n  uint32_t signature; // First comes the signature, SIDX\n  uint32_t formatVersion; // File format version (CurrentFormatVersion)\n  uint32_t chunksOffset; // The offset to chunks' storage\n  uint32_t indexBtreeMaxElements; // Two fields from IndexInfo\n  uint32_t indexRootOffset;\n  uint32_t wordCount; // Saved from Ifo::wordcount\n  uint32_t synWordCount; // Saved from Ifo::synwordcount\n  uint32_t bookNameSize; // Book name's length. Used to read it then.\n  uint32_t sameTypeSequenceSize; // That string's size. Used to read it then.\n  uint32_t langFrom;  // Source language\n  uint32_t langTo;    // Target language\n  uint32_t hasZipFile; // Non-zero means there's a zip file with resources present\n  uint32_t zipIndexBtreeMaxElements; // Two fields from IndexInfo of the zip\n                                     // resource index.\n  uint32_t zipIndexRootOffset;\n}\n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\nbool indexIsOldOrBad( string const & indexFile )\n{\n  File::Class idx( indexFile, \"rb\" );\n\n  IdxHeader header;\n\n  return idx.readRecords( &header, sizeof( header ), 1 ) != 1 ||\n         header.signature != Signature ||\n         header.formatVersion != CurrentFormatVersion;\n}\n\nclass StardictDictionary: public BtreeIndexing::BtreeDictionary\n{\n  Mutex idxMutex;\n  File::Class idx;\n  IdxHeader idxHeader;\n  string bookName;\n  string sameTypeSequence;\n  ChunkedStorage::Reader chunks;\n  Mutex dzMutex;\n  dictData * dz;\n  Mutex resourceZipMutex;\n  IndexedZip resourceZip;\n\npublic:\n\n  StardictDictionary( string const & id, string const & indexFile,\n                      vector< string > const & dictionaryFiles );\n\n  ~StardictDictionary();\n\n  virtual string getName() throw()\n  { return bookName; }\n\n  virtual map< Dictionary::Property, string > getProperties() throw()\n  { return map< Dictionary::Property, string >(); }\n\n  virtual unsigned long getArticleCount() throw()\n  { return idxHeader.wordCount; }\n\n  virtual unsigned long getWordCount() throw()\n  { return idxHeader.wordCount + idxHeader.synWordCount; }\n\n  inline virtual quint32 getLangFrom() const\n  { return idxHeader.langFrom; }\n\n  inline virtual quint32 getLangTo() const\n  { return idxHeader.langTo; }\n\n  virtual sptr< Dictionary::WordSearchRequest > findHeadwordsForSynonym( wstring const & )\n    THROW_SPEC( std::exception );\n\n  virtual sptr< Dictionary::DataRequest > getArticle( wstring const &,\n                                                      vector< wstring > const & alts,\n                                                      wstring const &,\n                                                      bool ignoreDiacritics )\n    THROW_SPEC( std::exception );\n\n  virtual sptr< Dictionary::DataRequest > getResource( string const & name )\n    THROW_SPEC( std::exception );\n\n  virtual QString const& getDescription();\n\n  virtual QString getMainFilename();\n\n  virtual sptr< Dictionary::DataRequest > getSearchResults( QString const & searchString,\n                                                            int searchMode, bool matchCase,\n                                                            int distanceBetweenWords,\n                                                            int maxResults,\n                                                            bool ignoreWordsOrder,\n                                                            bool ignoreDiacritics,\n                                                            QThreadPool * ftsThreadPoolPtr );\n  virtual void getArticleText( uint32_t articleAddress, QString & headword, QString & text );\n\n  virtual void makeFTSIndex(QAtomicInt & isCancelled, bool firstIteration );\n\n  virtual void setFTSParameters( Config::FullTextSearch const & fts )\n  {\n    can_FTS = fts.enabled\n              && !fts.disabledTypes.contains( \"STARDICT\", Qt::CaseInsensitive )\n              && ( fts.maxDictionarySize == 0 || getArticleCount() <= fts.maxDictionarySize );\n  }\nprotected:\n\n  void loadIcon() throw();\n\nprivate:\n\n  /// Retrieves the article's offset/size in .dict file, and its headword.\n  void getArticleProps( uint32_t articleAddress,\n                        string & headword,\n                        uint32_t & offset, uint32_t & size );\n\n  /// Loads the article, storing its headword and formatting the data it has\n  /// into an html.\n  void loadArticle(  uint32_t address,\n                     string & headword,\n                     string & articleText );\n\n  string loadString( size_t size );\n\n  string handleResource( char type, char const * resource, size_t size );\n\n  void pangoToHtml( QString & text );\n\n  friend class StardictResourceRequest;\n  friend class StardictArticleRequest;\n  friend class StardictHeadwordsRequest;\n};\n\nStardictDictionary::StardictDictionary( string const & id,\n                                        string const & indexFile,\n                                        vector< string > const & dictionaryFiles ):\n  BtreeDictionary( id, dictionaryFiles ),\n  idx( indexFile, \"rb\" ),\n  idxHeader( idx.read< IdxHeader >() ),\n  bookName( loadString( idxHeader.bookNameSize ) ),\n  sameTypeSequence( loadString( idxHeader.sameTypeSequenceSize ) ),\n  chunks( idx, idxHeader.chunksOffset )\n{\n  // Open the .dict file\n\n  DZ_ERRORS error;\n  dz = dict_data_open( dictionaryFiles[ 2 ].c_str(), &error, 0 );\n\n  if ( !dz )\n    throw exDictzipError( string( dz_error_str( error ) )\n                          + \"(\" + dictionaryFiles[ 2 ] + \")\" );\n\n  // Initialize the index\n\n  openIndex( IndexInfo( idxHeader.indexBtreeMaxElements,\n                        idxHeader.indexRootOffset ),\n             idx, idxMutex );\n\n  // Open a resource zip file, if there's one\n\n  if ( idxHeader.hasZipFile &&\n       ( idxHeader.zipIndexBtreeMaxElements ||\n         idxHeader.zipIndexRootOffset ) )\n  {\n    resourceZip.openIndex( IndexInfo( idxHeader.zipIndexBtreeMaxElements,\n                                      idxHeader.zipIndexRootOffset ),\n                           idx, idxMutex );\n\n    QString zipName = QDir::fromNativeSeparators(\n        FsEncoding::decode( getDictionaryFilenames().back().c_str() ) );\n\n    if ( zipName.endsWith( \".zip\", Qt::CaseInsensitive ) ) // Sanity check\n      resourceZip.openZipFile( zipName );\n  }\n\n  // Full-text search parameters\n\n  can_FTS = true;\n\n  ftsIdxName = indexFile + \"_FTS\";\n\n  if( !Dictionary::needToRebuildIndex( dictionaryFiles, ftsIdxName )\n      && !FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) )\n    FTS_index_completed.ref();\n}\n\nStardictDictionary::~StardictDictionary()\n{\n  if ( dz )\n    dict_data_close( dz );\n}\n\nvoid StardictDictionary::loadIcon() throw()\n{\n  if ( dictionaryIconLoaded )\n    return;\n\n  QString fileName =\n    QDir::fromNativeSeparators( FsEncoding::decode( getDictionaryFilenames()[ 0 ].c_str() ) );\n\n  // Remove the extension\n  fileName.chop( 3 );\n\n  if( !loadIconFromFile( fileName ) )\n  {\n    // Load failed -- use default icons\n    dictionaryNativeIcon = dictionaryIcon = QIcon(\":/icons/icon32_stardict.png\");\n  }\n\n  dictionaryIconLoaded = true;\n}\n\nstring StardictDictionary::loadString( size_t size )\n{\n  if( size == 0 )\n    return string();\n\n  vector< char > data( size );\n\n  idx.read( &data.front(), data.size() );\n\n  return string( &data.front(), data.size() );\n}\n\nvoid StardictDictionary::getArticleProps( uint32_t articleAddress,\n                                          string & headword,\n                                          uint32_t & offset, uint32_t & size )\n{\n  vector< char > chunk;\n\n  Mutex::Lock _( idxMutex );\n\n  char * articleData = chunks.getBlock( articleAddress, chunk );\n\n  memcpy( &offset, articleData, sizeof( uint32_t ) );\n  articleData += sizeof( uint32_t );\n  memcpy( &size, articleData, sizeof( uint32_t ) );\n  articleData += sizeof( uint32_t );\n\n  headword = articleData;\n}\n\nclass PowerWordDataProcessor{\n    class PWSyntaxTranslate{\n    public:\n        PWSyntaxTranslate(const char* re, const char* replacement)\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n            : _re(re, QRegularExpression::UseUnicodePropertiesOption )\n#else\n            : _re(re)\n#endif\n            , _replacement(replacement)\n        {\n        }\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n        const QRegularExpression & re() const {\n#else\n        const QRegExp& re() const {\n#endif\n            return _re;\n        }\n        const QString & replacement() const {\n            return _replacement;\n        }\n    private:\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n        QRegularExpression _re;\n#else\n        QRegExp _re;\n#endif\n        QString _replacement;\n    };\npublic:\n    PowerWordDataProcessor(const char* resource, size_t size)\n        : _data(QString::fromUtf8(resource, size))\n    {\n    }\n\n    string process() {\n        QDomDocument doc;\n        QString ss;\n        ss = \"<div class=\\\"sdct_k\\\">\";\n        if (!doc.setContent(_data)) {\n            ss += _data ;\n        } else {\n            QStringList sl;\n            walkNode(doc.firstChild(), sl);\n\n            QStringListIterator itr(sl);\n            while (itr.hasNext()) {\n                QString s = itr.next();\n                translatePW(s);\n                ss += s;\n                ss += \"<br>\";\n            }\n        }\n        ss += \"</div>\";\n        QByteArray ba = ss.toUtf8();\n        return string(ba.data(), ba.size());\n    }\nprivate:\n    void walkNode(const QDomNode& e, QStringList& sl) {\n        if (e.isNull()) {\n            return;\n        }\n        if (e.isText()) {\n            sl.append(e.toText().data());\n        } else {\n            QDomNodeList l = e.childNodes();\n            for (int i = 0; i < l.size(); ++i) {\n                QDomNode n = l.at(i);\n                if (n.isText()) {\n                    sl.append(n.toText().data());\n                } else {\n                    walkNode(n, sl);\n                }\n            }\n        }\n    }\n\n    void translatePW(QString& s){\n        const int TRANSLATE_TBL_SIZE=5;\n        static PWSyntaxTranslate t[TRANSLATE_TBL_SIZE]={\n            PWSyntaxTranslate(\"&[bB]\\\\s*\\\\{([^\\\\{}&]+)\\\\}\", \"<B>\\\\1</B>\"),\n            PWSyntaxTranslate(\"&[iI]\\\\s*\\\\{([^\\\\{}&]+)\\\\}\", \"<I>\\\\1</I>\"),\n            PWSyntaxTranslate(\"&[uU]\\\\s*\\\\{([^\\\\{}&]+)\\\\}\", \"<U>\\\\1</U>\"),\n            PWSyntaxTranslate(\"&[lL]\\\\s*\\\\{([^\\\\{}&]+)\\\\}\", \"<SPAN style=\\\"color:#0000ff\\\">\\\\1</SPAN>\"),\n            PWSyntaxTranslate(\"&[2]\\\\s*\\\\{([^\\\\{}&]+)\\\\}\", \"<SPAN style=\\\"color:#0000ff\\\">\\\\1</SPAN>\")\n        };\n\n        QString old;\n        while (s.compare(old) != 0) {\n            for (int i = 0; i < TRANSLATE_TBL_SIZE; ++i) {\n                PWSyntaxTranslate& a = t[i];\n                s.replace(a.re(), a.replacement());\n            }\n            old = s;\n        }\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n        s.replace(QRegularExpression( \"&.\\\\s*\\\\{\",\n                                      QRegularExpression::UseUnicodePropertiesOption\n                                      | QRegularExpression::DotMatchesEverythingOption),\n                  \"\");\n#else\n        s.replace(QRegExp(\"&.\\\\s*\\\\{\"), \"\");\n#endif\n        s.replace(\"}\", \"\");\n    }\nprivate:\n    QString _data;\n};\n\n\n/// This function tries to make an html of the Stardict's resource typed\n/// 'type', contained in a block pointed to by 'resource', 'size' bytes long.\nstring StardictDictionary::handleResource( char type, char const * resource, size_t size )\n{\n  QString text;\n  switch( type )\n  {\n    case 'x': // Xdxf content\n      return Xdxf2Html::convert( string( resource, size ), Xdxf2Html::STARDICT, NULL, this, &resourceZip );\n    case 'h': // Html content\n    {\n      QString articleText = QString( \"<div class=\\\"sdct_h\\\">\" ) + QString::fromUtf8( resource, size ) + \"</div>\";\n\n      const QString srcRegexpStr(\n          \"(<\\\\s*(?:img|script)\\\\s(?:[^>]*\\\\s)?src\\\\s*=)(?!\\\\s*[\\\"']?(?:data|https?|ftp):)(\\\\s*[\\\"']?)\" );\n      const QString linkRegexpStr(\n          \"(<\\\\s*link\\\\s(?:[^>]*\\\\s)?href\\\\s*=)(?!\\\\s*[\\\"']?(?:data|https?|ftp):)(\\\\s*[\\\"']?)\" );\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n      QRegularExpression srcRe( srcRegexpStr,\n                                QRegularExpression::CaseInsensitiveOption );\n      QRegularExpression linkRe( linkRegexpStr,\n                                 QRegularExpression::CaseInsensitiveOption );\n#else\n      QRegExp srcRe( srcRegexpStr, Qt::CaseInsensitive );\n      QRegExp linkRe( linkRegexpStr, Qt::CaseInsensitive );\n#endif\n\n      articleText.replace( srcRe, \"\\\\1\\\\2bres://\" + QString::fromStdString( getId() ) + \"/\" )\n                 .replace( linkRe, \"\\\\1\\\\2bres://\" + QString::fromStdString( getId() ) + \"/\" );\n\n      // Handle links to articles\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n      QRegularExpression linksReg( \"<a(\\\\s*[^>]*)href\\\\s*=\\\\s*['\\\"](bword://)?([^'\\\"]+)['\\\"]\",\n                                   QRegularExpression::CaseInsensitiveOption );\n#else\n      QRegExp linksReg( \"<a(\\\\s*[^>]*)href\\\\s*=\\\\s*['\\\"](bword://)?([^'\\\"]+)['\\\"]\", Qt::CaseInsensitive );\n      linksReg.setMinimal( true );\n#endif\n\n      int pos = 0;\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n      QString articleNewText;\n      QRegularExpressionMatchIterator it = linksReg.globalMatch( articleText );\n      while( it.hasNext() )\n      {\n        QRegularExpressionMatch match = it.next();\n        articleNewText += articleText.midRef( pos, match.capturedStart() - pos );\n        pos = match.capturedEnd();\n\n        QString link = match.captured( 3 );\n#else\n      while( pos >= 0 )\n      {\n        pos = linksReg.indexIn( articleText, pos );\n        if( pos < 0 )\n          break;\n\n        QString link = linksReg.cap( 3 );\n#endif\n        if( link.indexOf( ':' ) < 0 )\n        {\n          QString newLink;\n          if( link.indexOf( '#' ) < 0 )\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n            newLink = QString( \"<a\" ) + match.captured( 1 ) + \"href=\\\"bword:\" + link + \"\\\"\";\n#else\n            newLink = QString( \"<a\" ) + linksReg.cap( 1 ) + \"href=\\\"bword:\" + link + \"\\\"\";\n#endif\n\n          // Anchors\n\n          if( link.indexOf( '#' ) > 0 )\n          {\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n            newLink = QString( \"<a\" ) + match.captured( 1 ) + \"href=\\\"gdlookup://localhost/\" + link + \"\\\"\";\n#else\n            newLink = QString( \"<a\" ) + linksReg.cap( 1 ) + \"href=\\\"gdlookup://localhost/\" + link + \"\\\"\";\n#endif\n            newLink.replace( \"#\", \"?gdanchor=\" );\n          }\n\n          if( !newLink.isEmpty() )\n          {\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n            articleNewText += newLink;\n#else\n            articleText.replace( pos, linksReg.cap( 0 ).size(), newLink );\n            pos += newLink.size();\n#endif\n          }\n          else\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n            articleNewText += match.captured();\n#else\n            pos += linksReg.cap( 0 ).size();\n#endif\n        }\n        else\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n          articleNewText += match.captured();\n      }\n      if( pos )\n      {\n        articleNewText += articleText.midRef( pos );\n        articleText = articleNewText;\n        articleNewText.clear();\n      }\n#else\n          pos += linksReg.cap( 0 ).size();\n      }\n#endif\n\n      // Handle \"audio\" tags\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n      QRegularExpression audioRe( \"<\\\\s*audio\\\\s*src\\\\s*=\\\\s*([\\\"']+)([^\\\"']+)([\\\"'])\\\\s*>(.*)</audio>\",\n                                  QRegularExpression::CaseInsensitiveOption\n                                  | QRegularExpression::DotMatchesEverythingOption\n                                  | QRegularExpression::InvertedGreedinessOption );\n#else\n      QRegExp audioRe( \"<\\\\s*audio\\\\s*src\\\\s*=\\\\s*([\\\"']+)([^\\\"']+)([\\\"'])\\\\s*>(.*)</audio>\", Qt::CaseInsensitive );\n      audioRe.setMinimal( true );\n#endif\n\n      pos = 0;\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n      it = audioRe.globalMatch( articleText );\n      while( it.hasNext() )\n      {\n        QRegularExpressionMatch match = it.next();\n        articleNewText += articleText.midRef( pos, match.capturedStart() - pos );\n        pos = match.capturedEnd();\n\n        QString src = match.captured( 2 );\n#else\n      while( pos >= 0 )\n      {\n        pos = audioRe.indexIn( articleText, pos );\n        if( pos < 0 )\n          break;\n\n        QString src = audioRe.cap( 2 );\n#endif\n        if( src.indexOf( \"://\" ) >= 0 )\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n          articleNewText += match.captured();\n#else\n          pos += audioRe.cap( 0 ).length();\n#endif\n        else\n        {\n          std::string href = \"\\\"gdau://\" + getId() + \"/\" + src.toUtf8().data() + \"\\\"\";\n          QString newTag = QString::fromUtf8( ( addAudioLink( href, getId() ) + \"<span class=\\\"sdict_h_wav\\\"><a href=\" + href + \">\" ).c_str() );\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n          newTag += match.captured( 4 );\n          if( match.captured( 4 ).indexOf( \"<img \" ) < 0 )\n#else\n          newTag += audioRe.cap( 4 );\n          if( audioRe.cap( 4 ).indexOf( \"<img \" ) < 0 )\n#endif\n            newTag += \" <img src=\\\"qrcx://localhost/icons/playsound.png\\\" border=\\\"0\\\" alt=\\\"Play\\\">\";\n          newTag += \"</a></span>\";\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n          articleNewText += newTag;\n#else\n          articleText.replace( pos, audioRe.cap( 0 ).length(), newTag );\n          pos += newTag.length();\n#endif\n        }\n      }\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n      if( pos )\n      {\n        articleNewText += articleText.midRef( pos );\n        articleText = articleNewText;\n        articleNewText.clear();\n      }\n#endif\n\n      return ( articleText.toUtf8().data() );\n    }\n    case 'm': // Pure meaning, usually means preformatted text\n      return \"<div class=\\\"sdct_m\\\">\" + Html::preformat( string( resource, size ), isToLanguageRTL() ) + \"</div>\";\n    case 'l': // Same as 'm', but not in utf8, instead in current locale's\n              // encoding.\n              // We just use Qt here, it should know better about system's\n              // locale.\n      return \"<div class=\\\"sdct_l\\\">\" + Html::preformat( QString::fromLocal8Bit( resource, size ).toUtf8().data(),\n                                                         isToLanguageRTL() )\n                                      + \"</div>\";\n    case 'g': // Pango markup.\n      text = QString::fromUtf8( resource, size );\n      pangoToHtml( text );\n      return \"<div class=\\\"sdct_g\\\">\" + string( text.toUtf8().data() ) + \"</div>\";\n    case 't': // Transcription\n      return \"<div class=\\\"sdct_t\\\">\" + Html::escape( string( resource, size ) ) + \"</div>\";\n    case 'y': // Chinese YinBiao or Japanese KANA. Examples are needed. For now,\n              // just output as pure escaped utf8.\n      return \"<div class=\\\"sdct_y\\\">\" + Html::escape( string( resource, size ) ) + \"</div>\";\n    case 'k': // KingSoft PowerWord data.\n    {\n      PowerWordDataProcessor pwdp(resource, size);\n      return pwdp.process();\n    }\n    case 'w': // MediaWiki markup. We don't handle this right now.\n      return \"<div class=\\\"sdct_w\\\">\" + Html::escape( string( resource, size ) ) + \"</div>\";\n    case 'n': // WordNet data. We don't know anything about it.\n      return \"<div class=\\\"sdct_n\\\">\" + Html::escape( string( resource, size ) ) + \"</div>\";\n\n    case 'r': // Resource file list. For now, resources aren't handled.\n      return \"<div class=\\\"sdct_r\\\">\" + Html::escape( string( resource, size ) ) + \"</div>\";\n\n    case 'W': // An embedded Wav file. Unhandled yet.\n      return \"<div class=\\\"sdct_W\\\">(an embedded .wav file)</div>\";\n    case 'P': // An embedded picture file. Unhandled yet.\n      return \"<div class=\\\"sdct_P\\\">(an embedded picture file)</div>\";\n  }\n\n  if ( islower( type ) )\n  {\n    return string( \"<b>Unknown textual entry type \" ) + string( 1, type ) + \":</b> \" + Html::escape( string( resource, size ) ) + \"<br>\";\n  }\n  else\n    return string( \"<b>Unknown blob entry type \" ) + string( 1, type ) + \"</b><br>\";\n}\n\nvoid StardictDictionary::pangoToHtml( QString & text )\n{\n/*\n * Partially support for Pango Markup Language\n * Attributes \"fallback\", \"lang\", \"gravity\", \"gravity_hint\" just ignored\n */\n\n  QRegExp spanRegex( \"<span\\\\s*([^>]*)>\", Qt::CaseInsensitive );\n  QRegExp styleRegex( \"(\\\\w+)=\\\"([^\\\"]*)\\\"\" );\n\n  text.replace( \"\\n\", \"<br>\" );\n\n  int pos = 0;\n  do\n  {\n    pos = spanRegex.indexIn( text, pos );\n    if( pos >= 0 )\n    {\n      QString styles = spanRegex.cap( 1 );\n      QString newSpan( \"<span style=\\\"\" );\n      int stylePos = 0;\n      do\n      {\n        stylePos = styleRegex.indexIn( styles, stylePos );\n        QString style = styleRegex.cap( 1 );\n        if( stylePos >= 0 )\n        {\n          if( style.compare( \"font_desc\", Qt::CaseInsensitive ) == 0\n              || style.compare( \"font\", Qt::CaseInsensitive ) == 0 )\n          {\n            // Parse font description\n\n            QStringList list = styleRegex.cap( 2 ).split( \" \", Qt4x5::skipEmptyParts() );\n            int n;\n            QString sizeStr, stylesStr, familiesStr;\n            for( n = list.size() - 1; n >= 0; n-- )\n            {\n              QString str = list.at( n );\n\n              // font size\n              if( str[ 0 ].isNumber() )\n              {\n                sizeStr = QString( \"font-size:\" ) + str + \";\";\n                continue;\n              }\n\n              // font style\n              if( str.compare( \"normal\", Qt::CaseInsensitive ) == 0\n                  || str.compare( \"oblique\", Qt::CaseInsensitive ) == 0\n                  || str.compare( \"italic\", Qt::CaseInsensitive ) == 0 )\n              {\n                if( !stylesStr.contains( \"font-style:\" ) )\n                  stylesStr += QString( \"font-style:\" ) + str + \";\";\n                continue;\n              }\n\n              // font variant\n              if( str.compare( \"smallcaps\", Qt::CaseInsensitive ) == 0 )\n              {\n                stylesStr += QString( \"font-variant:small-caps\" ) ;\n                continue;\n              }\n\n              // font weight\n              if( str.compare( \"ultralight\", Qt::CaseInsensitive ) == 0 )\n              {\n                stylesStr += QString( \"font-weight:100;\" );\n                continue;\n              }\n              if( str.compare( \"light\", Qt::CaseInsensitive ) == 0 )\n              {\n                stylesStr += QString( \"font-weight:200;\" );\n                continue;\n              }\n              if( str.compare( \"bold\", Qt::CaseInsensitive ) == 0 )\n              {\n                stylesStr += QString( \"font-weight:bold;\" );\n                continue;\n              }\n              if( str.compare( \"ultrabold\", Qt::CaseInsensitive ) == 0 )\n              {\n                stylesStr += QString( \"font-weight:800;\" );\n                continue;\n              }\n              if( str.compare( \"heavy\", Qt::CaseInsensitive ) == 0 )\n              {\n                stylesStr += QString( \"font-weight:900\" );\n                continue;\n              }\n\n              // font stretch\n              if( str.compare( \"ultracondensed\", Qt::CaseInsensitive ) == 0 )\n              {\n                stylesStr += QString( \"font-stretch:ultra-condensed;\" );\n                continue;\n              }\n              if( str.compare( \"extracondensed\", Qt::CaseInsensitive ) == 0 )\n              {\n                stylesStr += QString( \"font-stretch:extra-condensed;\" );\n                continue;\n              }\n              if( str.compare( \"semicondensed\", Qt::CaseInsensitive ) == 0 )\n              {\n                stylesStr += QString( \"font-stretch:semi-condensed;\" );\n                continue;\n              }\n              if( str.compare( \"semiexpanded\", Qt::CaseInsensitive ) == 0 )\n              {\n                stylesStr += QString( \"font-stretch:semi-expanded;\" );\n                continue;\n              }\n              if( str.compare( \"extraexpanded\", Qt::CaseInsensitive ) == 0 )\n              {\n                stylesStr += QString( \"font-stretch:extra-expanded;\" );\n                continue;\n              }\n              if( str.compare( \"ultraexpanded\", Qt::CaseInsensitive ) == 0 )\n              {\n                stylesStr += QString( \"font-stretch:ultra-expanded;\" );\n                continue;\n              }\n              if( str.compare( \"condensed\", Qt::CaseInsensitive ) == 0\n                  || str.compare( \"expanded\", Qt::CaseInsensitive ) == 0 )\n              {\n                stylesStr += QString( \"font-stretch:\" ) + str + \";\";\n                continue;\n              }\n\n              // gravity\n              if( str.compare( \"south\", Qt::CaseInsensitive ) == 0\n                  || str.compare( \"east\", Qt::CaseInsensitive ) == 0\n                  || str.compare( \"north\", Qt::CaseInsensitive ) == 0\n                  || str.compare( \"west\", Qt::CaseInsensitive ) == 0\n                  || str.compare( \"auto\", Qt::CaseInsensitive ) == 0 )\n              {\n                continue;\n              }\n              break;\n            }\n\n            // last words is families list\n            if( n >= 0 )\n            {\n              familiesStr = QString( \"font-family:\" );\n              for( int i = 0; i <= n; i++ )\n              {\n                if( i > 0 && !familiesStr.endsWith( ',' ) )\n                  familiesStr += \",\";\n                familiesStr += list.at( i );\n              }\n              familiesStr += \";\";\n            }\n\n            newSpan += familiesStr + stylesStr + sizeStr;\n          }\n          else if( style.compare( \"font_family\", Qt::CaseInsensitive ) == 0\n                   || style.compare( \"face\", Qt::CaseInsensitive ) == 0 )\n            newSpan += QString( \"font-family:\" ) + styleRegex.cap( 2 ) + \";\";\n          else if( style.compare( \"font_size\", Qt::CaseInsensitive ) == 0\n                   || style.compare( \"size\", Qt::CaseInsensitive ) == 0 )\n          {\n            if( styleRegex.cap( 2 )[ 0 ].isLetter()\n                || styleRegex.cap( 2 ).endsWith( \"px\", Qt::CaseInsensitive )\n                || styleRegex.cap( 2 ).endsWith( \"pt\", Qt::CaseInsensitive )\n                || styleRegex.cap( 2 ).endsWith( \"em\", Qt::CaseInsensitive )\n                || styleRegex.cap( 2 ).endsWith( \"%\" ) )\n              newSpan += QString( \"font-size:\" ) + styleRegex.cap( 2 ) +\";\";\n            else\n            {\n              int size = styleRegex.cap( 2 ).toInt();\n              if( size )\n                newSpan += QString( \"font-size:%1pt;\" ).arg( size / 1024.0, 0, 'f', 3 );\n            }\n          }\n          else if( style.compare( \"font_style\", Qt::CaseInsensitive ) == 0\n                   || style.compare( \"style\", Qt::CaseInsensitive ) == 0)\n            newSpan += QString( \"font-style:\" ) + styleRegex.cap( 2 ) + \";\";\n          else if( style.compare( \"weight\", Qt::CaseInsensitive ) == 0\n                   || style.compare( \"weight\", Qt::CaseInsensitive ) == 0)\n          {\n            QString str = styleRegex.cap( 2 );\n            if( str.compare( \"ultralight\", Qt::CaseInsensitive ) == 0 )\n              newSpan += QString( \"font-weight:100;\" );\n            else if( str.compare( \"light\", Qt::CaseInsensitive ) == 0 )\n              newSpan += QString( \"font-weight:200;\" );\n            else if( str.compare( \"ultrabold\", Qt::CaseInsensitive ) == 0 )\n              newSpan += QString( \"font-weight:800;\" );\n            else if( str.compare( \"heavy\", Qt::CaseInsensitive ) == 0 )\n              newSpan += QString( \"font-weight:900\" );\n            else\n              newSpan += QString( \"font-weight:\" ) + str + \";\";\n          }\n          else if( style.compare( \"font_variant\", Qt::CaseInsensitive ) == 0\n                   || style.compare( \"variant\", Qt::CaseInsensitive ) == 0 )\n          {\n            if( styleRegex.cap( 2 ).compare( \"smallcaps\", Qt::CaseInsensitive ) == 0 )\n              newSpan += QString( \"font-variant:small-caps\" );\n            else\n              newSpan += QString( \"font-variant:\" ) + styleRegex.cap( 2 ) + \";\";\n          }\n          else if( style.compare( \"font_stretch\", Qt::CaseInsensitive ) == 0\n                   || style.compare( \"stretch\", Qt::CaseInsensitive ) == 0 )\n          {\n            QString str = styleRegex.cap( 2 );\n            if( str.compare( \"ultracondensed\", Qt::CaseInsensitive ) == 0 )\n              newSpan += QString( \"font-stretch:ultra-condensed;\" );\n            else if( str.compare( \"extracondensed\", Qt::CaseInsensitive ) == 0 )\n              newSpan += QString( \"font-stretch:extra-condensed;\" );\n            else if( str.compare( \"semicondensed\", Qt::CaseInsensitive ) == 0 )\n              newSpan += QString( \"font-stretch:semi-condensed;\" );\n            else if( str.compare( \"semiexpanded\", Qt::CaseInsensitive ) == 0 )\n              newSpan += QString( \"font-stretch:semi-expanded;\" );\n            else if( str.compare( \"extraexpanded\", Qt::CaseInsensitive ) == 0 )\n              newSpan += QString( \"font-stretch:extra-expanded;\" );\n            else if( str.compare( \"ultraexpanded\", Qt::CaseInsensitive ) == 0 )\n              newSpan += QString( \"font-stretch:ultra-expanded;\" );\n            else\n              newSpan += QString( \"font-stretch:\" ) + str + \";\";\n          }\n          else if( style.compare( \"foreground\", Qt::CaseInsensitive ) == 0\n                   || style.compare( \"fgcolor\", Qt::CaseInsensitive ) == 0\n                   || style.compare( \"color\", Qt::CaseInsensitive ) == 0 )\n            newSpan += QString( \"color:\" ) + styleRegex.cap( 2 ) + \";\";\n          else if( style.compare( \"background\", Qt::CaseInsensitive ) == 0\n                   || style.compare( \"bgcolor\", Qt::CaseInsensitive ) == 0 )\n            newSpan += QString( \"background-color:\" ) + styleRegex.cap( 2 ) + \";\";\n          else if( style.compare( \"underline_color\", Qt::CaseInsensitive ) == 0\n                   || style.compare( \"strikethrough_color\", Qt::CaseInsensitive ) == 0 )\n            newSpan += QString( \"text-decoration-color:\" ) + styleRegex.cap( 2 ) + \";\";\n          else if( style.compare( \"underline\", Qt::CaseInsensitive ) == 0 )\n          {\n            if( styleRegex.cap( 2 ).compare( \"none\", Qt::CaseInsensitive ) )\n              newSpan += QString( \"text-decoration-line:none;\" );\n            else\n            {\n              newSpan += QString( \"text-decoration-line:underline; \" );\n              if( styleRegex.cap( 2 ).compare( \"low\", Qt::CaseInsensitive ) )\n                newSpan += QString( \"text-decoration-style:dotted;\" );\n              else if( styleRegex.cap( 2 ).compare( \"single\", Qt::CaseInsensitive ) )\n                newSpan += QString( \"text-decoration-style:solid;\" );\n              else if( styleRegex.cap( 2 ).compare( \"error\", Qt::CaseInsensitive ) )\n                newSpan += QString( \"text-decoration-style:wavy;\" );\n              else\n                newSpan += QString( \"text-decoration-style:\" ) + styleRegex.cap( 2 ) + \";\";\n            }\n          }\n          else if( style.compare( \"strikethrough\", Qt::CaseInsensitive ) == 0 )\n          {\n            if( styleRegex.cap( 2 ).compare( \"true\", Qt::CaseInsensitive ) )\n              newSpan += QString( \"text-decoration-line:line-through;\" );\n            else\n              newSpan += QString( \"text-decoration-line:none;\" );\n          }\n          else if( style.compare( \"rise\", Qt::CaseInsensitive ) == 0 )\n          {\n            if( styleRegex.cap( 2 ).endsWith( \"px\", Qt::CaseInsensitive )\n                || styleRegex.cap( 2 ).endsWith( \"pt\", Qt::CaseInsensitive )\n                || styleRegex.cap( 2 ).endsWith( \"em\", Qt::CaseInsensitive )\n                || styleRegex.cap( 2 ).endsWith( \"%\" ) )\n              newSpan += QString( \"vertical-align:\" ) + styleRegex.cap( 2 ) +\";\";\n            else\n            {\n              int riseValue = styleRegex.cap( 2 ).toInt();\n              if( riseValue )\n                newSpan += QString( \"vertical-align:%1pt;\" ).arg( riseValue / 1024.0, 0, 'f', 3 );\n            }\n          }\n          else if( style.compare( \"letter_spacing\", Qt::CaseInsensitive ) == 0 )\n          {\n            if( styleRegex.cap( 2 ).endsWith( \"px\", Qt::CaseInsensitive )\n                || styleRegex.cap( 2 ).endsWith( \"pt\", Qt::CaseInsensitive )\n                || styleRegex.cap( 2 ).endsWith( \"em\", Qt::CaseInsensitive )\n                || styleRegex.cap( 2 ).endsWith( \"%\" ) )\n              newSpan += QString( \"letter-spacing:\" ) + styleRegex.cap( 2 ) +\";\";\n            else\n            {\n              int spacing = styleRegex.cap( 2 ).toInt();\n              if( spacing )\n                newSpan += QString( \"letter-spacing:%1pt;\" ).arg( spacing / 1024.0, 0, 'f', 3 );\n            }\n          }\n\n          stylePos += styleRegex.matchedLength();\n        }\n      }\n      while( stylePos >= 0 );\n\n      newSpan += \"\\\">\";\n      text.replace( pos, spanRegex.matchedLength(), newSpan );\n      pos += newSpan.size();\n    }\n  }\n  while( pos >= 0 );\n\n  text.replace( \"  \", \"&nbsp;&nbsp;\" );\n}\n\nvoid StardictDictionary::loadArticle( uint32_t address,\n                                      string & headword,\n                                      string & articleText )\n{\n  uint32_t offset, size;\n\n  getArticleProps( address, headword, offset, size );\n\n  char * articleBody;\n\n  {\n    Mutex::Lock _( dzMutex );\n\n    // Note that the function always zero-pads the result.\n    articleBody = dict_data_read_( dz, offset, size, 0, 0 );\n  }\n\n  if ( !articleBody )\n  {\n//    throw exCantReadFile( getDictionaryFilenames()[ 2 ] );\n    articleText = string( \"<div class=\\\"sdict_m\\\">DICTZIP error: \" ) + dict_error_str( dz ) + \"</div>\";\n    return;\n  }\n\n  articleText.clear();\n\n  char * ptr = articleBody;\n\n  if ( sameTypeSequence.size() )\n  {\n    /// The sequence is known, it's not stored in the article itself\n    for( unsigned seq = 0; seq < sameTypeSequence.size(); ++seq )\n    {\n      // Last entry doesn't have size info -- it is inferred from\n      // the bytes left\n      bool entrySizeKnown = ( seq == sameTypeSequence.size() - 1 );\n\n      uint32_t entrySize = 0;\n\n      if ( entrySizeKnown )\n        entrySize = size;\n      else\n      if ( !size )\n      {\n        gdWarning( \"Stardict: short entry for the word %s encountered in \\\"%s\\\".\\n\", headword.c_str(), getName().c_str() );\n        break;\n      }\n\n      char type = sameTypeSequence[ seq ];\n\n      if ( islower( type ) )\n      {\n        // Zero-terminated entry, unless it's the last one\n        if ( !entrySizeKnown )\n          entrySize = strlen( ptr );\n\n        if ( size < entrySize )\n        {\n          gdWarning( \"Stardict: malformed entry for the word %s encountered in \\\"%s\\\".\\n\", headword.c_str(), getName().c_str() );\n          break;\n        }\n\n        articleText += handleResource( type, ptr, entrySize );\n\n        if ( !entrySizeKnown )\n          ++entrySize; // Need to skip the zero byte\n\n        ptr += entrySize;\n        size -= entrySize;\n      }\n      else\n      if ( isupper( *ptr ) )\n      {\n        // An entry which has its size before contents, unless it's the last one\n\n        if ( !entrySizeKnown )\n        {\n          if ( size < sizeof( uint32_t ) )\n          {\n            gdWarning( \"Stardict: malformed entry for the word %s encountered in \\\"%s\\\".\\n\", headword.c_str(), getName().c_str() );\n            break;\n          }\n\n          memcpy( &entrySize, ptr, sizeof( uint32_t ) );\n\n          entrySize = ntohl( entrySize );\n\n          ptr += sizeof( uint32_t );\n          size -= sizeof( uint32_t );\n        }\n\n        if ( size < entrySize )\n        {\n          gdWarning( \"Stardict: malformed entry for the word %s encountered in \\\"%s\\\".\\n\", headword.c_str(), getName().c_str() );\n          break;\n        }\n\n        articleText += handleResource( type, ptr, entrySize );\n\n        ptr += entrySize;\n        size -= entrySize;\n      }\n      else\n      {\n        gdWarning( \"Stardict: non-alpha entry type 0x%x for the word %s encountered in \\\"%s\\\".\\n\",\n                   type, headword.c_str(), getName().c_str() );\n        break;\n      }\n    }\n  }\n  else\n  {\n    // The sequence is stored in each article separately\n    while( size )\n    {\n      if ( islower( *ptr ) )\n      {\n        // Zero-terminated entry\n        size_t len = strlen( ptr + 1 );\n\n        if ( size < len + 2 )\n        {\n          gdWarning( \"Stardict: malformed entry for the word %s encountered in \\\"%s\\\".\\n\", headword.c_str(), getName().c_str() );\n          break;\n        }\n\n        articleText += handleResource( *ptr, ptr + 1, len );\n\n        ptr += len + 2;\n        size -= len + 2;\n      }\n      else\n      if ( isupper( *ptr ) )\n      {\n        // An entry which havs its size before contents\n        if ( size < sizeof( uint32_t ) + 1 )\n        {\n          gdWarning( \"Stardict: malformed entry for the word %s encountered in \\\"%s\\\".\\n\", headword.c_str(), getName().c_str() );\n          break;\n        }\n\n        uint32_t entrySize;\n\n        memcpy( &entrySize, ptr + 1, sizeof( uint32_t ) );\n\n        entrySize = ntohl( entrySize );\n\n        if ( size < sizeof( uint32_t ) + 1 + entrySize )\n        {\n          gdWarning( \"Stardict: malformed entry for the word %s encountered in \\\"%s\\\".\\n\", headword.c_str(), getName().c_str() );\n          break;\n        }\n\n        articleText += handleResource( *ptr, ptr + 1 + sizeof( uint32_t ), entrySize );\n\n        ptr += sizeof( uint32_t ) + 1 + entrySize;\n        size -= sizeof( uint32_t ) + 1 + entrySize;\n      }\n      else\n      {\n        gdWarning( \"Stardict: non-alpha entry type 0x%x for the word %s encountered in \\\"%s\\\".\\n\",\n                   (unsigned)*ptr, headword.c_str(), getName().c_str() );\n        break;\n      }\n    }\n  }\n\n  free( articleBody );\n}\n\nQString const& StardictDictionary::getDescription()\n{\n    if( !dictionaryDescription.isEmpty() )\n        return dictionaryDescription;\n\n    File::Class ifoFile( getDictionaryFilenames()[ 0 ], \"r\" );\n    Ifo ifo( ifoFile );\n\n    if( !ifo.copyright.empty() )\n    {\n      QString copyright = QString::fromUtf8( ifo.copyright.c_str() )\n                          .replace( \"<br>\", \"\\n\", Qt::CaseInsensitive );\n      dictionaryDescription += QString( QObject::tr( \"Copyright: %1%2\" ) )\n                              .arg( copyright )\n                              .arg( \"\\n\\n\" );\n    }\n\n    if( !ifo.author.empty() )\n    {\n      QString author = QString::fromUtf8( ifo.author.c_str() );\n      dictionaryDescription += QString( QObject::tr( \"Author: %1%2\" ) )\n                              .arg( author )\n                              .arg( \"\\n\\n\" );\n    }\n\n    if( !ifo.email.empty() )\n    {\n      QString email = QString::fromUtf8( ifo.email.c_str() );\n      dictionaryDescription += QString( QObject::tr( \"E-mail: %1%2\" ) )\n                               .arg( email )\n                               .arg( \"\\n\\n\" );\n    }\n\n    if( !ifo.website.empty() )\n    {\n      QString website = QString::fromUtf8( ifo.website.c_str() );\n      dictionaryDescription += QString( QObject::tr( \"Website: %1%2\" ) )\n                               .arg( website )\n                               .arg( \"\\n\\n\" );\n    }\n\n    if( !ifo.date.empty() )\n    {\n      QString date = QString::fromUtf8( ifo.date.c_str() );\n      dictionaryDescription += QString( QObject::tr( \"Date: %1%2\" ) )\n                               .arg( date )\n                               .arg( \"\\n\\n\" );\n    }\n\n    if( !ifo.description.empty() )\n    {\n      QString desc = QString::fromUtf8( ifo.description.c_str() );\n      desc.replace( \"\\t\", \"<br/>\" );\n      desc.replace( \"\\\\n\", \"<br/>\" );\n      desc.replace( \"<br>\", \"<br/>\", Qt::CaseInsensitive );\n      dictionaryDescription += Html::unescape( desc, true );\n    }\n\n    if( dictionaryDescription.isEmpty() )\n      dictionaryDescription = \"NONE\";\n\n    return dictionaryDescription;\n}\n\nQString StardictDictionary::getMainFilename()\n{\n  return FsEncoding::decode( getDictionaryFilenames()[ 0 ].c_str() );\n}\n\nvoid StardictDictionary::makeFTSIndex( QAtomicInt & isCancelled, bool firstIteration )\n{\n  if( !( Dictionary::needToRebuildIndex( getDictionaryFilenames(), ftsIdxName )\n         || FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) ) )\n    FTS_index_completed.ref();\n\n  if( haveFTSIndex() )\n    return;\n\n  if( ensureInitDone().size() )\n    return;\n\n  if( firstIteration && getArticleCount() > FTS::MaxDictionarySizeForFastSearch )\n    return;\n\n  gdDebug( \"Stardict: Building the full-text index for dictionary: %s\\n\",\n           getName().c_str() );\n\n  try\n  {\n    FtsHelpers::makeFTSIndex( this, isCancelled );\n    FTS_index_completed.ref();\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"Stardict: Failed building full-text search index for \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n    QFile::remove( FsEncoding::decode( ftsIdxName.c_str() ) );\n  }\n}\n\nvoid StardictDictionary::getArticleText( uint32_t articleAddress, QString & headword, QString & text )\n{\n  try\n  {\n    string headwordStr, articleStr;\n    loadArticle( articleAddress, headwordStr, articleStr );\n\n    headword = QString::fromUtf8( headwordStr.data(), headwordStr.size() );\n\n    wstring wstr = Utf8::decode( articleStr );\n\n    text = Html::unescape( gd::toQString( wstr ) );\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"Stardict: Failed retrieving article from \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n  }\n}\n\nsptr< Dictionary::DataRequest > StardictDictionary::getSearchResults( QString const & searchString,\n                                                                      int searchMode, bool matchCase,\n                                                                      int distanceBetweenWords,\n                                                                      int maxResults,\n                                                                      bool ignoreWordsOrder,\n                                                                      bool ignoreDiacritics,\n                                                                      QThreadPool * ftsThreadPoolPtr )\n{\n  return new FtsHelpers::FTSResultsRequest( *this, searchString,searchMode, matchCase, distanceBetweenWords, maxResults, ignoreWordsOrder, ignoreDiacritics, ftsThreadPoolPtr );\n}\n\n/// StardictDictionary::findHeadwordsForSynonym()\n\nclass StardictHeadwordsRequest;\n\nclass StardictHeadwordsRequestRunnable: public QRunnable\n{\n  StardictHeadwordsRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  StardictHeadwordsRequestRunnable( StardictHeadwordsRequest & r_,\n                                    QSemaphore & hasExited_ ): r( r_ ),\n                                                               hasExited( hasExited_ )\n  {}\n\n  ~StardictHeadwordsRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass StardictHeadwordsRequest: public Dictionary::WordSearchRequest\n{\n  friend class StardictHeadwordsRequestRunnable;\n\n  wstring word;\n  StardictDictionary & dict;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  StardictHeadwordsRequest( wstring const & word_,\n                            StardictDictionary & dict_ ):\n    word( word_ ), dict( dict_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new StardictHeadwordsRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by StardictHeadwordsRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~StardictHeadwordsRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid StardictHeadwordsRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid StardictHeadwordsRequest::run()\n{\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  try\n  {\n    vector< WordArticleLink > chain = dict.findArticles( word );\n\n    wstring caseFolded = Folding::applySimpleCaseOnly( word );\n\n    for( unsigned x = 0; x < chain.size(); ++x )\n    {\n      if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      {\n        finish();\n        return;\n      }\n\n      string headword, articleText;\n\n      dict.loadArticle( chain[ x ].articleOffset,\n                        headword, articleText );\n\n      wstring headwordDecoded = Utf8::decode( headword );\n\n      if ( caseFolded != Folding::applySimpleCaseOnly( headwordDecoded ) )\n      {\n        // The headword seems to differ from the input word, which makes the\n        // input word its synonym.\n        Mutex::Lock _( dataMutex );\n\n        matches.push_back( headwordDecoded );\n      }\n    }\n  }\n  catch( std::exception & e )\n  {\n    setErrorString( QString::fromUtf8( e.what() ) );\n  }\n\n  finish();\n}\n\nsptr< Dictionary::WordSearchRequest >\n  StardictDictionary::findHeadwordsForSynonym( wstring const & word )\n  THROW_SPEC( std::exception )\n{\n  return synonymSearchEnabled ? new StardictHeadwordsRequest( word, *this ) :\n                                Class::findHeadwordsForSynonym( word );\n}\n\n\n/// StardictDictionary::getArticle()\n\nclass StardictArticleRequest;\n\nclass StardictArticleRequestRunnable: public QRunnable\n{\n  StardictArticleRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  StardictArticleRequestRunnable( StardictArticleRequest & r_,\n                                  QSemaphore & hasExited_ ): r( r_ ),\n                                                             hasExited( hasExited_ )\n  {}\n\n  ~StardictArticleRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass StardictArticleRequest: public Dictionary::DataRequest\n{\n  friend class StardictArticleRequestRunnable;\n\n  wstring word;\n  vector< wstring > alts;\n  StardictDictionary & dict;\n  bool ignoreDiacritics;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  StardictArticleRequest( wstring const & word_,\n                     vector< wstring > const & alts_,\n                     StardictDictionary & dict_,\n                     bool ignoreDiacritics_ ):\n    word( word_ ), alts( alts_ ), dict( dict_ ), ignoreDiacritics( ignoreDiacritics_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new StardictArticleRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by StardictArticleRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~StardictArticleRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid StardictArticleRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid StardictArticleRequest::run()\n{\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  try\n  {\n    vector< WordArticleLink > chain = dict.findArticles( word, ignoreDiacritics );\n\n    for( unsigned x = 0; x < alts.size(); ++x )\n    {\n      /// Make an additional query for each alt\n\n      vector< WordArticleLink > altChain = dict.findArticles( alts[ x ], ignoreDiacritics );\n\n      chain.insert( chain.end(), altChain.begin(), altChain.end() );\n    }\n\n    multimap< wstring, pair< string, string > > mainArticles, alternateArticles;\n\n    set< uint32_t > articlesIncluded; // Some synonims make it that the articles\n                                      // appear several times. We combat this\n                                      // by only allowing them to appear once.\n\n    wstring wordCaseFolded = Folding::applySimpleCaseOnly( word );\n    if( ignoreDiacritics )\n      wordCaseFolded = Folding::applyDiacriticsOnly( wordCaseFolded );\n\n    for( unsigned x = 0; x < chain.size(); ++x )\n    {\n      if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      {\n        finish();\n        return;\n      }\n\n      if ( articlesIncluded.find( chain[ x ].articleOffset ) != articlesIncluded.end() )\n        continue; // We already have this article in the body.\n\n      // Now grab that article\n\n      string headword, articleText;\n\n      dict.loadArticle( chain[ x ].articleOffset, headword, articleText );\n\n      // Ok. Now, does it go to main articles, or to alternate ones? We list\n      // main ones first, and alternates after.\n\n      // We do the case-folded comparison here.\n\n      wstring headwordStripped =\n        Folding::applySimpleCaseOnly( Utf8::decode( headword ) );\n      if( ignoreDiacritics )\n        headwordStripped = Folding::applyDiacriticsOnly( headwordStripped );\n\n      multimap< wstring, pair< string, string > > & mapToUse =\n        ( wordCaseFolded == headwordStripped ) ?\n          mainArticles : alternateArticles;\n\n      mapToUse.insert( pair< wstring, pair< string, string > >(\n        Folding::applySimpleCaseOnly( Utf8::decode( headword ) ),\n        pair< string, string >( headword, articleText ) ) );\n\n      articlesIncluded.insert( chain[ x ].articleOffset );\n    }\n\n    if ( mainArticles.empty() && alternateArticles.empty() )\n    {\n      // No such word\n      finish();\n      return;\n    }\n\n    string result;\n\n    multimap< wstring, pair< string, string > >::const_iterator i;\n\n    string cleaner = \"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\n                     \"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\n                     \"</b></b></b></b></b></b></b></b>\"\n                     \"</i></i></i></i></i></i></i></i>\";\n\n    for( i = mainArticles.begin(); i != mainArticles.end(); ++i )\n    {\n        result += dict.isFromLanguageRTL() ? \"<h3 class=\\\"sdct_headwords\\\" dir=\\\"rtl\\\">\" : \"<h3 class=\\\"sdct_headwords\\\">\";\n        result += i->second.first;\n        result += \"</h3>\";\n        if( dict.isToLanguageRTL() )\n          result += \"<div style=\\\"display:inline;\\\" dir=\\\"rtl\\\">\";\n        result += i->second.second;\n        result += cleaner;\n        if( dict.isToLanguageRTL() )\n          result += \"</div>\";\n    }\n\n    for( i = alternateArticles.begin(); i != alternateArticles.end(); ++i )\n    {\n        result += dict.isFromLanguageRTL() ? \"<h3 class=\\\"sdct_headwords\\\" dir=\\\"rtl\\\">\" : \"<h3 class=\\\"sdct_headwords\\\">\";\n        result += i->second.first;\n        result += \"</h3>\";\n        if( dict.isToLanguageRTL() )\n          result += \"<div style=\\\"display:inline;\\\" dir=\\\"rtl\\\">\";\n        result += i->second.second;\n        result += cleaner;\n        if( dict.isToLanguageRTL() )\n          result += \"</div>\";\n    }\n\n    Mutex::Lock _( dataMutex );\n\n    data.resize( result.size() );\n\n    memcpy( &data.front(), result.data(), result.size() );\n\n    hasAnyData = true;\n  }\n  catch( std::exception & e )\n  {\n    setErrorString( QString::fromUtf8( e.what() ) );\n  }\n\n  finish();\n}\n\nsptr< Dictionary::DataRequest > StardictDictionary::getArticle( wstring const & word,\n                                                                vector< wstring > const & alts,\n                                                                wstring const &,\n                                                                bool ignoreDiacritics )\n  THROW_SPEC( std::exception )\n{\n  return new StardictArticleRequest( word, alts, *this, ignoreDiacritics );\n}\n\n\nstatic char const * beginsWith( char const * substr, char const * str )\n{\n  size_t len = strlen( substr );\n\n  return strncmp( str, substr, len ) == 0 ? str + len : 0;\n}\n\nIfo::Ifo( File::Class & f ):\n  wordcount( 0 ), synwordcount( 0 ), idxfilesize( 0 ), idxoffsetbits( 32 )\n{\n  static string const versionEq( \"version=\" );\n\n  static string const booknameEq( \"bookname=\" );\n\n  //DPRINTF( \"%s<\\n\", f.gets().c_str() );\n  //DPRINTF( \"%s<\\n\", f.gets().c_str() );\n\n  if ( QString::fromUtf8(f.gets().c_str()) != \"StarDict's dict ifo file\" ||\n       f.gets().compare( 0, versionEq.size(), versionEq ) )\n    throw exNotAnIfoFile();\n\n  /// Now go through the file and parse options\n\n  try\n  {\n    char option[ 16384 ];\n\n    for( ; ; )\n    {\n      if ( !f.gets( option, sizeof( option ), true ) )\n        break;\n\n      if ( char const * val = beginsWith( \"bookname=\", option ) )\n        bookname = val;\n      else\n      if ( char const * val = beginsWith( \"wordcount=\", option ) )\n      {\n        if ( sscanf( val, \"%u\", & wordcount ) != 1 )\n          throw exBadFieldInIfo( option );\n      }\n      else\n      if ( char const * val = beginsWith( \"synwordcount=\", option ) )\n      {\n        if ( sscanf( val, \"%u\", & synwordcount ) != 1 )\n          throw exBadFieldInIfo( option );\n      }\n      else\n      if ( char const * val = beginsWith( \"idxfilesize=\", option ) )\n      {\n        if ( sscanf( val, \"%u\", & idxfilesize ) != 1 )\n          throw exBadFieldInIfo( option );\n      }\n      else\n      if ( char const * val = beginsWith( \"idxoffsetbits=\", option ) )\n      {\n        if ( sscanf( val, \"%u\", & idxoffsetbits ) != 1 || ( idxoffsetbits != 32\n             && idxoffsetbits != 64 ) )\n          throw exBadFieldInIfo( option );\n      }\n      else\n      if ( char const * val = beginsWith( \"sametypesequence=\", option ) )\n        sametypesequence = val;\n      else\n      if ( char const * val = beginsWith( \"dicttype=\", option ) )\n        dicttype = val;\n      else\n      if ( char const * val = beginsWith( \"description=\", option ) )\n        description = val;\n      else\n      if ( char const * val = beginsWith( \"copyright=\", option ) )\n        copyright = val;\n      else\n      if ( char const * val = beginsWith( \"author=\", option ) )\n        author = val;\n      else\n      if ( char const * val = beginsWith( \"email=\", option ) )\n        email = val;\n      else\n      if ( char const * val = beginsWith( \"website=\", option ) )\n        website = val;\n      else\n      if ( char const * val = beginsWith( \"date=\", option ) )\n        date = val;\n    }\n  }\n  catch( File::exReadError & )\n  {\n  }\n}\n\n//// StardictDictionary::getResource()\n\nclass StardictResourceRequest;\n\nclass StardictResourceRequestRunnable: public QRunnable\n{\n  StardictResourceRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  StardictResourceRequestRunnable( StardictResourceRequest & r_,\n                               QSemaphore & hasExited_ ): r( r_ ),\n                                                          hasExited( hasExited_ )\n  {}\n\n  ~StardictResourceRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass StardictResourceRequest: public Dictionary::DataRequest\n{\n  friend class StardictResourceRequestRunnable;\n\n  StardictDictionary & dict;\n\n  string resourceName;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  StardictResourceRequest( StardictDictionary & dict_,\n                      string const & resourceName_ ):\n    dict( dict_ ),\n    resourceName( resourceName_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new StardictResourceRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by StardictResourceRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~StardictResourceRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid StardictResourceRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid StardictResourceRequest::run()\n{\n  // Some runnables linger enough that they are cancelled before they start\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  try\n  {\n    if( resourceName.at( 0 ) == '\\x1E' )\n      resourceName = resourceName.erase( 0, 1 );\n    if( resourceName.at( resourceName.length() - 1 ) == '\\x1F' )\n      resourceName.erase( resourceName.length() - 1, 1 );\n\n    string n =\n      FsEncoding::dirname( dict.getDictionaryFilenames()[ 0 ] ) +\n      FsEncoding::separator() +\n      \"res\" +\n      FsEncoding::separator() +\n      FsEncoding::encode( resourceName );\n\n    GD_DPRINTF( \"n is %s\\n\", n.c_str() );\n\n    try\n    {\n      Mutex::Lock _( dataMutex );\n\n      File::loadFromFile( n, data );\n    }\n    catch( File::exCantOpen & )\n    {\n      // Try reading from zip file\n\n      if ( dict.resourceZip.isOpen() )\n      {\n        Mutex::Lock _( dict.resourceZipMutex );\n\n        Mutex::Lock __( dataMutex );\n\n        if ( !dict.resourceZip.loadFile( Utf8::decode( resourceName ), data ) )\n          throw; // Make it fail since we couldn't read the archive\n      }\n      else\n        throw;\n    }\n\n    if ( Filetype::isNameOfTiff( resourceName ) )\n    {\n      // Convert it\n\n      dataMutex.lock();\n\n      QImage img = QImage::fromData( (unsigned char *) &data.front(),\n                                     data.size() );\n\n#ifdef MAKE_EXTRA_TIFF_HANDLER\n      if( img.isNull() )\n        GdTiff::tiffToQImage( &data.front(), data.size(), img );\n#endif\n\n      dataMutex.unlock();\n\n      if ( !img.isNull() )\n      {\n        // Managed to load -- now store it back as BMP\n\n        QByteArray ba;\n        QBuffer buffer( &ba );\n        buffer.open( QIODevice::WriteOnly );\n        img.save( &buffer, \"BMP\" );\n\n        Mutex::Lock _( dataMutex );\n\n        data.resize( buffer.size() );\n\n        memcpy( &data.front(), buffer.data(), data.size() );\n      }\n    }\n\n    if( Filetype::isNameOfCSS( resourceName ) )\n    {\n      Mutex::Lock _( dataMutex );\n\n      QString css = QString::fromUtf8( data.data(), data.size() );\n\n      // Correct some url's\n\n      QString id = QString::fromUtf8( dict.getId().c_str() );\n      int pos = 0;\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n      QRegularExpression links( \"url\\\\(\\\\s*(['\\\"]?)([^'\\\"]*)(['\\\"]?)\\\\s*\\\\)\",\n                                QRegularExpression::CaseInsensitiveOption );\n\n      QString newCSS;\n      QRegularExpressionMatchIterator it = links.globalMatch( css );\n      while( it.hasNext() )\n      {\n        QRegularExpressionMatch match = it.next();\n        newCSS += css.midRef( pos, match.capturedStart() - pos );\n        pos = match.capturedEnd();\n\n        QString url = match.captured( 2 );\n\n        if( url.indexOf( \":/\" ) >= 0 || url.indexOf( \"data:\" ) >= 0)\n        {\n          // External link\n          newCSS += match.captured();\n          continue;\n        }\n\n        QString newUrl = QString( \"url(\" ) + match.captured( 1 ) + \"bres://\"\n                                           + id + \"/\" + url + match.captured( 3 ) + \")\";\n        newCSS += newUrl;\n      }\n      if( pos )\n      {\n        newCSS += css.midRef( pos );\n        css = newCSS;\n        newCSS.clear();\n      }\n#else\n      QRegExp links( \"url\\\\(\\\\s*(['\\\"]?)([^'\\\"]*)(['\\\"]?)\\\\s*\\\\)\", Qt::CaseInsensitive, QRegExp::RegExp );\n      for( ; ; )\n      {\n        pos = links.indexIn( css, pos );\n        if( pos < 0 )\n          break;\n        QString url = links.cap( 2 );\n\n        if( url.indexOf( \":/\" ) >= 0 || url.indexOf( \"data:\" ) >= 0)\n        {\n          // External link\n          pos += links.cap().size();\n          continue;\n        }\n\n        QString newUrl = QString( \"url(\" ) + links.cap( 1 ) + \"bres://\"\n                                           + id + \"/\" + url + links.cap( 3 ) + \")\";\n        css.replace( pos, links.cap().size(), newUrl );\n        pos += newUrl.size();\n      }\n#endif\n\n      dict.isolateCSS( css );\n      QByteArray bytes = css.toUtf8();\n      data.resize( bytes.size() );\n      memcpy( &data.front(), bytes.constData(), bytes.size() );\n    }\n\n    Mutex::Lock _( dataMutex );\n    hasAnyData = true;\n  }\n  catch( std::exception &ex )\n  {\n    gdCWarning( dictionaryResourceLc, \"Stardict: Failed loading resource \\\"%s\\\" for \\\"%s\\\", reason: %s\\n\",\n               resourceName.c_str(), dict.getName().c_str(), ex.what() );\n    // Resource not loaded -- we don't set the hasAnyData flag then\n  }\n  catch( ... )\n  {\n  }\n\n  finish();\n}\n\nsptr< Dictionary::DataRequest > StardictDictionary::getResource( string const & name )\n  THROW_SPEC( std::exception )\n{\n  return new StardictResourceRequest( *this, name );\n}\n\n} // anonymous namespace\n\nstatic void findCorrespondingFiles( string const & ifo,\n                                    string & idx, string & dict, string & syn )\n{\n  string base( ifo, 0, ifo.size() - 3 );\n\n  if ( !(\n          File::tryPossibleName( base + \"idx\", idx ) ||\n          File::tryPossibleName( base + \"idx.gz\", idx ) ||\n          File::tryPossibleName( base + \"idx.dz\", idx ) ||\n          File::tryPossibleName( base + \"IDX\", idx ) ||\n          File::tryPossibleName( base + \"IDX.GZ\", idx ) ||\n          File::tryPossibleName( base + \"IDX.DZ\", idx )\n      ) )\n    throw exNoIdxFile( ifo );\n\n  if ( !(\n          File::tryPossibleName( base + \"dict\", dict ) ||\n          File::tryPossibleName( base + \"dict.dz\", dict ) ||\n          File::tryPossibleName( base + \"DICT\", dict ) ||\n          File::tryPossibleName( base + \"dict.DZ\", dict )\n      ) )\n    throw exNoDictFile( ifo );\n\n  if ( !(\n         File::tryPossibleName( base + \"syn\", syn ) ||\n         File::tryPossibleName( base + \"syn.gz\", syn ) ||\n         File::tryPossibleName( base + \"syn.dz\", syn ) ||\n         File::tryPossibleName( base + \"SYN\", syn ) ||\n         File::tryPossibleName( base + \"SYN.GZ\", syn ) ||\n         File::tryPossibleName( base + \"SYN.DZ\", syn )\n     ) )\n    syn.clear();\n}\n\nstatic void handleIdxSynFile( string const & fileName,\n                              IndexedWords & indexedWords,\n                              ChunkedStorage::Writer & chunks,\n                              vector< uint32_t > * articleOffsets,\n                              bool isSynFile, bool parseHeadwords )\n{\n  gzFile stardictIdx = gd_gzopen( fileName.c_str() );\n  if ( !stardictIdx )\n    throw exCantReadFile( fileName );\n\n  vector< char > image;\n\n  for( ; ; )\n  {\n    size_t oldSize = image.size();\n\n    image.resize( oldSize + 65536 );\n\n    int rd = gzread( stardictIdx, &image.front() + oldSize, 65536 );\n\n    if ( rd < 0 )\n    {\n      gzclose( stardictIdx );\n      throw exCantReadFile( fileName );\n    }\n\n    if ( rd != 65536 )\n    {\n      image.resize( oldSize + rd + 1 );\n      break;\n    }\n  }\n  gzclose( stardictIdx );\n\n  // We append one zero byte to catch runaway string at the end, if any\n\n  image.back() = 0;\n\n  // Now parse it\n\n  for( char const * ptr = &image.front(); ptr != &image.back(); )\n  {\n    size_t wordLen = strlen( ptr );\n\n    if ( ptr + wordLen + 1 + ( isSynFile ? sizeof( uint32_t ) :\n                                           sizeof( uint32_t ) * 2 ) >\n         &image.back() )\n    {\n      GD_FDPRINTF( stderr, \"Warning: sudden end of file %s\\n\", fileName.c_str() );\n      break;\n    }\n\n    char const * word = ptr;\n\n    ptr += wordLen + 1;\n\n    uint32_t offset;\n\n    if( strstr( word, \"&#\" ) )\n    {\n      // Decode some html-coded symbols in headword\n      string unescapedWord = Html::unescapeUtf8( word );\n      strncpy( (char *)word, unescapedWord.c_str(), wordLen );\n      wordLen = strlen( word );\n    }\n\n    if ( !isSynFile )\n    {\n      // We're processing the .idx file\n      uint32_t articleOffset, articleSize;\n\n      memcpy( &articleOffset, ptr, sizeof( uint32_t ) );\n      ptr += sizeof( uint32_t );\n      memcpy( &articleSize, ptr, sizeof( uint32_t ) );\n      ptr += sizeof( uint32_t );\n\n      articleOffset = ntohl( articleOffset );\n      articleSize = ntohl( articleSize );\n\n      // Create an entry for the article in the chunked storage\n\n      offset = chunks.startNewBlock();\n\n      if ( articleOffsets )\n        articleOffsets->push_back( offset );\n\n      chunks.addToBlock( &articleOffset, sizeof( uint32_t ) );\n      chunks.addToBlock( &articleSize, sizeof( uint32_t ) );\n      chunks.addToBlock( word, wordLen + 1 );\n    }\n    else\n    {\n      // We're processing the .syn file\n      uint32_t offsetInIndex;\n\n      memcpy( &offsetInIndex, ptr, sizeof( uint32_t ) );\n      ptr += sizeof( uint32_t );\n\n      offsetInIndex = ntohl( offsetInIndex );\n\n      if ( offsetInIndex >= articleOffsets->size() )\n        throw exIncorrectOffset( fileName );\n\n      offset = (*articleOffsets)[ offsetInIndex ];\n\n      // Some StarDict dictionaries are in fact badly converted Babylon ones.\n      // They contain a lot of superfluous slashed entries with dollar signs.\n      // We try to filter them out here, since those entries become much more\n      // apparent in GoldenDict than they were in StarDict because of\n      // punctuation folding. Hopefully there are not a whole lot of valid\n      // synonyms which really start from slash and contain dollar signs, or\n      // end with dollar and contain slashes.\n      if ( *word == '/' )\n      {\n        if ( strchr( word, '$' ) )\n          continue; // Skip this entry\n      }\n      else\n      if ( wordLen && word[ wordLen - 1 ] == '$' )\n      {\n        if ( strchr( word, '/' ) )\n          continue; // Skip this entry\n      }\n    }\n\n    // Insert new entry into an index\n\n    if( parseHeadwords )\n      indexedWords.addWord( Utf8::decode( word ), offset );\n    else\n      indexedWords.addSingleWord( Utf8::decode( word ), offset );\n  }\n\n  GD_DPRINTF( \"%u entires made\\n\", (unsigned) indexedWords.size() );\n}\n\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing & initializing,\n                                      unsigned maxHeadwordsToExpand )\n  THROW_SPEC( std::exception )\n{\n  vector< sptr< Dictionary::Class > > dictionaries;\n\n  for( vector< string >::const_iterator i = fileNames.begin(); i != fileNames.end();\n       ++i )\n  {\n    if ( i->size() < 4 ||\n        strcasecmp( i->c_str() + ( i->size() - 4 ), \".ifo\" ) != 0 )\n      continue;\n\n    try\n    {\n      vector< string > dictFiles( 1, *i );\n\n      string idxFileName, dictFileName, synFileName;\n\n      findCorrespondingFiles( *i, idxFileName, dictFileName, synFileName );\n\n      dictFiles.push_back( idxFileName );\n      dictFiles.push_back( dictFileName );\n\n      if ( synFileName.size() )\n        dictFiles.push_back( synFileName );\n\n      // See if there's a zip file with resources present. If so, include it.\n\n      string zipFileName;\n      string baseName = FsEncoding::dirname( idxFileName ) + FsEncoding::separator();\n\n      if ( File::tryPossibleZipName( baseName + \"res.zip\", zipFileName ) ||\n           File::tryPossibleZipName( baseName + \"RES.ZIP\", zipFileName ) ||\n           File::tryPossibleZipName( baseName + \"res\" + FsEncoding::separator() + \"res.zip\", zipFileName ) )\n        dictFiles.push_back( zipFileName );\n\n      string dictId = Dictionary::makeDictionaryId( dictFiles );\n\n      string indexFile = indicesDir + dictId;\n\n      if ( Dictionary::needToRebuildIndex( dictFiles, indexFile ) ||\n           indexIsOldOrBad( indexFile ) )\n      {\n        // Building the index\n\n        File::Class ifoFile( *i, \"r\" );\n\n        Ifo ifo( ifoFile );\n\n        gdDebug( \"Stardict: Building the index for dictionary: %s\\n\", ifo.bookname.c_str() );\n\n        if ( ifo.idxoffsetbits == 64 )\n          throw ex64BitsNotSupported();\n\n        if ( ifo.dicttype.size() )\n          throw exDicttypeNotSupported();\n\n        if( synFileName.empty() )\n        {\n          if ( ifo.synwordcount )\n          {\n            GD_DPRINTF( \"Warning: dictionary has synwordcount specified, but no \"\n                        \"corresponding .syn file was found\\n\" );\n            ifo.synwordcount = 0;  // Pretend it wasn't there\n          }\n        }\n        else\n        if ( !ifo.synwordcount )\n        {\n          GD_DPRINTF( \"Warning: ignoring .syn file %s, since there's no synwordcount in .ifo specified\\n\",\n                      synFileName.c_str() );\n        }\n\n\n        GD_DPRINTF( \"bookname = %s\\n\", ifo.bookname.c_str() );\n        GD_DPRINTF( \"wordcount = %u\\n\", ifo.wordcount );\n\n        initializing.indexingDictionary( ifo.bookname );\n\n        File::Class idx( indexFile, \"wb\" );\n\n        IdxHeader idxHeader;\n\n        memset( &idxHeader, 0, sizeof( idxHeader ) );\n\n        // We write a dummy header first. At the end of the process the header\n        // will be rewritten with the right values.\n\n        idx.write( idxHeader );\n\n        idx.write( ifo.bookname.data(), ifo.bookname.size() );\n        idx.write( ifo.sametypesequence.data(), ifo.sametypesequence.size() );\n\n        IndexedWords indexedWords;\n\n        ChunkedStorage::Writer chunks( idx );\n\n        // Load indices\n        if ( !ifo.synwordcount )\n          handleIdxSynFile( idxFileName, indexedWords, chunks, 0, false,\n                            !maxHeadwordsToExpand || ifo.wordcount < maxHeadwordsToExpand );\n        else\n        {\n          vector< uint32_t > articleOffsets;\n\n          articleOffsets.reserve( ifo.wordcount );\n\n          handleIdxSynFile( idxFileName, indexedWords, chunks, &articleOffsets,\n                            false,\n                            !maxHeadwordsToExpand || ( ifo.wordcount + ifo.synwordcount ) < maxHeadwordsToExpand );\n\n          handleIdxSynFile( synFileName, indexedWords, chunks, &articleOffsets,\n                            true,\n                            !maxHeadwordsToExpand || ( ifo.wordcount + ifo.synwordcount ) < maxHeadwordsToExpand );\n        }\n\n        // Finish with the chunks\n\n        idxHeader.chunksOffset = chunks.finish();\n\n        // Build index\n\n        IndexInfo idxInfo = BtreeIndexing::buildIndex( indexedWords, idx );\n\n        idxHeader.indexBtreeMaxElements = idxInfo.btreeMaxElements;\n        idxHeader.indexRootOffset = idxInfo.rootOffset;\n\n        // That concludes it. Update the header.\n\n        idxHeader.signature = Signature;\n        idxHeader.formatVersion = CurrentFormatVersion;\n\n        idxHeader.wordCount = ifo.wordcount;\n        idxHeader.synWordCount = ifo.synwordcount;\n        idxHeader.bookNameSize = ifo.bookname.size();\n        idxHeader.sameTypeSequenceSize = ifo.sametypesequence.size();\n\n        // read languages\n        QPair<quint32,quint32> langs =\n            LangCoder::findIdsForFilename( QString::fromStdString( dictFileName ) );\n\n        // if no languages found, try dictionary's name\n        if ( langs.first == 0 || langs.second == 0 )\n        {\n          langs =\n            LangCoder::findIdsForFilename( QString::fromStdString( ifo.bookname ) );\n        }\n\n        idxHeader.langFrom = langs.first;\n        idxHeader.langTo = langs.second;\n\n        // If there was a zip file, index it too\n\n        if ( zipFileName.size() )\n        {\n          GD_DPRINTF( \"Indexing zip file\\n\" );\n\n          idxHeader.hasZipFile = 1;\n\n          IndexedWords zipFileNames;\n          IndexedZip zipFile;\n          if( zipFile.openZipFile( QDir::fromNativeSeparators(\n                                   FsEncoding::decode( zipFileName.c_str() ) ) ) )\n              zipFile.indexFile( zipFileNames );\n\n          if( !zipFileNames.empty() )\n          {\n            // Build the resulting zip file index\n\n            IndexInfo idxInfo = BtreeIndexing::buildIndex( zipFileNames, idx );\n\n            idxHeader.zipIndexBtreeMaxElements = idxInfo.btreeMaxElements;\n            idxHeader.zipIndexRootOffset = idxInfo.rootOffset;\n          }\n          else\n          {\n            // Bad zip file -- no index (though the mark that we have one\n            // remains)\n            idxHeader.zipIndexBtreeMaxElements = 0;\n            idxHeader.zipIndexRootOffset = 0;\n          }\n        }\n        else\n          idxHeader.hasZipFile = 0;\n\n        // That concludes it. Update the header.\n\n        idx.rewind();\n\n        idx.write( &idxHeader, sizeof( idxHeader ) );\n      }\n\n      dictionaries.push_back( new StardictDictionary( dictId,\n                                                      indexFile,\n                                                      dictFiles ) );\n    }\n    catch( std::exception & e )\n    {\n      gdWarning( \"Stardict dictionary initializing failed: %s, error: %s\\n\",\n                 i->c_str(), e.what() );\n    }\n  }\n\n  return dictionaries;\n}\n\n\n}\n"
        },
        {
          "name": "stardict.hh",
          "type": "blob",
          "size": 0.720703125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __STARTDICT_HH_INCLUDED__\n#define __STARTDICT_HH_INCLUDED__\n\n#include \"dictionary.hh\"\n\n/// Support for the Stardict (ifo+dict+idx+syn) dictionaries.\nnamespace Stardict {\n\nusing std::vector;\nusing std::string;\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing &,\n                                      unsigned maxHeadwordsToExpand )\n  THROW_SPEC( std::exception );\n\n}\n\n#endif\n"
        },
        {
          "name": "stylescombobox.cc",
          "type": "blob",
          "size": 0.95703125,
          "content": "/* Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"stylescombobox.hh\"\n#include \"config.hh\"\n#include <QDir>\n\nStylesComboBox::StylesComboBox( QWidget * parent ):\n  QComboBox( parent )\n{\n  fill();\n  setVisible( count() > 1 );\n}\n\nvoid StylesComboBox::fill()\n{\n  clear();\n  addItem( tr( \"None\" ) );\n  QString stylesDir = Config::getStylesDir();\n  if( !stylesDir.isEmpty() )\n  {\n    QDir dir( stylesDir );\n    QStringList styles = dir.entryList( QDir::Dirs | QDir::NoDotAndDotDot, QDir::LocaleAware );\n    addItems( styles );\n  }\n}\n\nvoid StylesComboBox::setCurrentStyle( QString const & style )\n{\n  int nom = 0;\n  if( !style.isEmpty() )\n  {\n    for( int i = 1; i < count(); i++ )\n      if( style.compare( itemText( i ) ) == 0 )\n      {\n        nom = i;\n        break;\n      }\n  }\n  setCurrentIndex( nom );\n}\n\nQString StylesComboBox::getCurrentStyle() const\n{\n  if( currentIndex() == 0 )\n    return QString();\n  return itemText( currentIndex() );\n}\n"
        },
        {
          "name": "stylescombobox.hh",
          "type": "blob",
          "size": 0.6630859375,
          "content": "/* Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __STYLESCOMBOBOX_HH_INCLUDED__\n#define __STYLESCOMBOBOX_HH_INCLUDED__\n\n#include <QComboBox>\n#include <QString>\n\n/// This is a combo box which is for choosing the add-on styles\nclass StylesComboBox : public QComboBox\n{\n  Q_OBJECT\n\npublic:\n\n  StylesComboBox( QWidget * parent );\n\n  /// Fills combo-box with the given groups\n  void fill();\n\n  /// Chooses the given style in the combobox. If there's no such style,\n  /// set to \"None\".\n  void setCurrentStyle( QString const & style );\n\n  /// Returns current style.\n  QString getCurrentStyle() const;\n\n};\n\n#endif // __STYLESCOMBOBOX_HH_INCLUDED__\n"
        },
        {
          "name": "termination.cc",
          "type": "blob",
          "size": 2.8720703125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"termination.hh\"\n#include <exception>\n#include <typeinfo>\n\n#ifndef _MSC_VER\n#include <cxxabi.h>\n#endif\n\n#include <string>\n\n#ifndef __WIN32\n#include <execinfo.h>\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include <string.h>\n\n#include <QtCore>\n\nusing std::string;\n\nstatic void termHandler()\n{\n  if( logFilePtr && logFilePtr->isOpen() )\n    logFilePtr->close();\n\n  std::string message( \"GoldenDict has crashed with an unexpected exception\\n\\n\" );\n\n  int status;\n  char * function = 0;\n  size_t functionLength = 0;\n\n#ifdef _MSC_VER\n  std::type_info * ti = 0;\n#else\n  std::type_info * ti = __cxxabiv1::__cxa_current_exception_type();\n#endif\n\n  if ( ti )\n  {\n    char const * name = ti->name();\n\n#ifdef _MSC_VER\n    char * ret = 0;\n    // avoid 'unused' warnings\n    (void) status;\n    (void) functionLength;\n#else\n    char * ret = abi::__cxa_demangle( name, function, &functionLength, &status );\n#endif\n\n    if ( ret )\n    {\n      function = ret;\n      name = function;\n    }\n\n    message += \"Exception: \";\n    message += name;\n    message += '\\n';\n\n    try\n    {\n      throw;\n    }\n    catch( std::exception & e )\n    {\n      message += \"Message: \";\n      \n      message += e.what();\n      \n      message += '\\n';\n    }\n    catch( ... )\n    {\n    }\n  }\n  else\n  {\n    message += \"terminate() called without active exception\\n\";\n  }\n\n#ifndef __WIN32\n\n  message += \"\\nBacktrace:\\n\";\n\n  const size_t maxDepth = 200;\n  size_t stackDepth;\n  void * stackAddrs[ maxDepth ];\n  char ** stackStrings;\n\n  stackDepth = backtrace( stackAddrs, maxDepth );\n  stackStrings = backtrace_symbols( stackAddrs, stackDepth );\n\n  for (size_t i = 1; i < stackDepth; i++)\n  {\n    char * begin = 0, * end = 0;\n\n    for (char *j = stackStrings[i]; *j; ++j)\n    {\n      if (*j == '(')\n        begin = j + 1;\n      else if ( begin && ( *j == '+' || *j == ')' ) )\n      {\n        end = j;\n        break;\n      }\n    }\n\n    string line;\n\n    if ( end )\n    {\n      char endSymbol = *end;\n\n      *end = 0;\n\n      char * ret = abi::__cxa_demangle( begin, function, &functionLength, &status );\n\n      *end = endSymbol;\n\n      if ( ret )\n      {\n        function = ret;\n\n        line = string( stackStrings[ i ], begin );\n        line += function;\n        line += string( end );\n      }\n    }\n\n    message += \"  \";\n    message += line.size() ? line.c_str() : stackStrings[ i ];\n    message += '\\n';\n  }\n\n#endif\n\n  QTemporaryFile file;\n\n  if ( file.open() )\n  {\n    file.setAutoRemove( false );\n    file.write( message.data(), message.size() );\n\n    QStringList args;\n\n    args << \"--show-error-file\";\n    args << file.fileName();\n\n    file.close();\n\n    QProcess::execute( QCoreApplication::applicationFilePath(), args );\n\n    abort();\n  }\n}\n\nvoid installTerminationHandler()\n{\n  std::set_terminate( termHandler );\n}\n"
        },
        {
          "name": "termination.hh",
          "type": "blob",
          "size": 0.41796875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef TERMINATION_HH\n#define TERMINATION_HH\n\n#include <QFile>\n\nextern QFile * logFilePtr;\n\n// Installs the termination handler which attempts to pop Qt's dialog showing\n// the exception and backtrace, and then aborts.\nvoid installTerminationHandler();\n\n#endif // TERMINATION_HH\n"
        },
        {
          "name": "texttospeechsource.cc",
          "type": "blob",
          "size": 11.787109375,
          "content": "/* This file is (c) 2013 Timon Wong <timon86.wang@gmail.com>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"texttospeechsource.hh\"\n\n#include <QMessageBox>\n\nTextToSpeechSource::TextToSpeechSource( QWidget * parent,\n                                        Config::VoiceEngines voiceEngines ):\n  QWidget( parent ),\n  voiceEnginesModel( this, voiceEngines )\n{\n  ui.setupUi( this );\n\n  SpeechClient::Engines engines = SpeechClient::availableEngines();\n\n  ui.selectedVoiceEngines->setTabKeyNavigation( true );\n  ui.selectedVoiceEngines->setModel( &voiceEnginesModel );\n  ui.selectedVoiceEngines->hideColumn( VoiceEnginesModel::kColumnEngineId );\n  fitSelectedVoiceEnginesColumns();\n  ui.selectedVoiceEngines->setItemDelegateForColumn( VoiceEnginesModel::kColumnEngineName,\n                                                     new VoiceEngineItemDelegate( engines, this ) );\n\n  foreach ( SpeechClient::Engine engine, engines )\n  {\n    ui.availableVoiceEngines->addItem( engine.name, engine.id );\n  }\n\n  if( voiceEngines.count() > 0 )\n  {\n    QModelIndex const &idx = ui.selectedVoiceEngines->model()->index( 0, 0 );\n    if( idx.isValid() )\n      ui.selectedVoiceEngines->setCurrentIndex( idx );\n  }\n\n  adjustSliders();\n\n  connect( ui.volumeSlider, SIGNAL( valueChanged( int ) ),\n           this, SLOT( slidersChanged() ) );\n  connect( ui.rateSlider, SIGNAL( valueChanged( int ) ),\n           this, SLOT( slidersChanged() ) );\n  connect( ui.selectedVoiceEngines->selectionModel(), SIGNAL( selectionChanged( QItemSelection, QItemSelection ) ),\n           this, SLOT( selectionChanged() ) );\n}\n\nvoid TextToSpeechSource::slidersChanged()\n{\n  if( ui.selectedVoiceEngines->selectionModel()->hasSelection() )\n    voiceEnginesModel.setEngineParams( ui.selectedVoiceEngines->currentIndex(),\n                                       ui.volumeSlider->value(),\n                                       ui.rateSlider->value()) ;\n}\n\nvoid TextToSpeechSource::on_addVoiceEngine_clicked()\n{\n  if ( ui.availableVoiceEngines->count() == 0 )\n  {\n    QMessageBox::information( this, tr( \"No TTS voice available\" ),\n                              tr( \"Cannot find available TTS voice.<br>\"\n                                  \"Please make sure that at least one TTS engine installed on your computer already.\" ) );\n    return;\n  }\n\n  int idx = ui.availableVoiceEngines->currentIndex();\n  if( idx >= 0 )\n  {\n    QString name = ui.availableVoiceEngines->itemText( idx );\n    QString id = ui.availableVoiceEngines->itemData( idx ).toString();\n    voiceEnginesModel.addNewVoiceEngine( id, name, ui.volumeSlider->value(), ui.rateSlider->value() );\n    fitSelectedVoiceEnginesColumns();\n  }\n}\n\nvoid TextToSpeechSource::on_removeVoiceEngine_clicked()\n{\n  QModelIndex current = ui.selectedVoiceEngines->currentIndex();\n\n  if ( current.isValid() &&\n       QMessageBox::question( this, tr( \"Confirm removal\" ),\n                              tr( \"Remove voice engine <b>%1</b> from the list?\" ).arg(\n                                voiceEnginesModel.getCurrentVoiceEngines()[ current.row() ].name ),\n                              QMessageBox::Ok,\n                              QMessageBox::Cancel ) == QMessageBox::Ok )\n  {\n    voiceEnginesModel.removeVoiceEngine( current.row() );\n  }\n}\n\nvoid TextToSpeechSource::on_previewVoice_clicked()\n{\n  int idx = ui.availableVoiceEngines->currentIndex();\n  if ( idx < 0 )\n    return;\n\n  QString engineId = ui.availableVoiceEngines->itemData( idx ).toString();\n  QString name = ui.availableVoiceEngines->itemText( idx );\n  QString text = ui.previewText->text();\n  int volume = ui.volumeSlider->value();\n  int rate = ui.rateSlider->value();\n\n  SpeechClient * speechClient = new SpeechClient( Config::VoiceEngine( engineId, name, volume, rate ), this );\n\n  connect( speechClient, SIGNAL( started( bool ) ), ui.previewVoice, SLOT( setDisabled( bool ) ) );\n  connect( speechClient, SIGNAL( finished() ), this, SLOT( previewVoiceFinished() ) );\n  connect( speechClient, SIGNAL( finished() ), speechClient, SLOT( deleteLater() ) );\n  speechClient->tell( text );\n}\n\nvoid TextToSpeechSource::previewVoiceFinished()\n{\n  ui.previewVoice->setDisabled( false );\n}\n\nvoid TextToSpeechSource::fitSelectedVoiceEnginesColumns()\n{\n  ui.selectedVoiceEngines->resizeColumnToContents( VoiceEnginesModel::kColumnEnabled );\n  ui.selectedVoiceEngines->resizeColumnToContents( VoiceEnginesModel::kColumnEngineName );\n  ui.selectedVoiceEngines->resizeColumnToContents( VoiceEnginesModel::kColumnIcon );\n}\n\nvoid TextToSpeechSource::adjustSliders()\n{\n  QModelIndex const & index = ui.selectedVoiceEngines->currentIndex();\n  if ( index.isValid() )\n  {\n    Config::VoiceEngines const &engines = voiceEnginesModel.getCurrentVoiceEngines();\n    ui.volumeSlider->setValue( engines[ index.row() ].volume );\n    ui.rateSlider->setValue( engines[ index.row() ].rate );\n    return;\n  }\n  ui.volumeSlider->setValue( 50 );\n  ui.rateSlider->setValue( 50 );\n}\n\nvoid TextToSpeechSource::selectionChanged()\n{\n  disconnect( ui.volumeSlider, SIGNAL( valueChanged( int ) ),\n              this, SLOT( slidersChanged() ) );\n  disconnect( ui.rateSlider, SIGNAL( valueChanged( int ) ),\n              this, SLOT( slidersChanged() ) );\n\n  adjustSliders();\n\n  connect( ui.volumeSlider, SIGNAL( valueChanged( int ) ),\n           this, SLOT( slidersChanged() ) );\n  connect( ui.rateSlider, SIGNAL( valueChanged( int ) ),\n           this, SLOT( slidersChanged() ) );\n}\n\nVoiceEnginesModel::VoiceEnginesModel( QWidget * parent,\n                                      Config::VoiceEngines const & voiceEngines ):\n  QAbstractItemModel( parent ), voiceEngines( voiceEngines )\n{\n}\n\nvoid VoiceEnginesModel::removeVoiceEngine( int index )\n{\n  beginRemoveRows( QModelIndex(), index, index );\n  voiceEngines.erase( voiceEngines.begin() + index );\n  endRemoveRows();\n}\n\nvoid VoiceEnginesModel::addNewVoiceEngine( QString const & id, QString const & name,\n                                           int volume, int rate )\n{\n  if ( id.isEmpty() || name.isEmpty() )\n    return;\n\n  Config::VoiceEngine v;\n  v.enabled = true;\n  v.id = id;\n  v.name = name;\n  v.volume = volume;\n  v.rate = rate;\n\n  beginInsertRows( QModelIndex(), voiceEngines.size(), voiceEngines.size() );\n  voiceEngines.push_back( v );\n  endInsertRows();\n}\n\nQModelIndex VoiceEnginesModel::index( int row, int column, QModelIndex const & /*parent*/ ) const\n{\n  return createIndex( row, column );\n}\n\nQModelIndex VoiceEnginesModel::parent( QModelIndex const & /*parent*/ ) const\n{\n  return QModelIndex();\n}\n\nQt::ItemFlags VoiceEnginesModel::flags( QModelIndex const & index ) const\n{\n  Qt::ItemFlags result = QAbstractItemModel::flags( index );\n\n  if ( index.isValid() )\n  {\n    switch ( index.column() )\n    {\n      case kColumnEnabled:\n        result |= Qt::ItemIsUserCheckable;\n        break;\n      case kColumnEngineName:\n      case kColumnIcon:\n        result |= Qt::ItemIsEditable;\n        break;\n    }\n  }\n\n  return result;\n}\n\nint VoiceEnginesModel::rowCount( QModelIndex const & parent ) const\n{\n  if ( parent.isValid() )\n    return 0;\n  return voiceEngines.size();\n}\n\nint VoiceEnginesModel::columnCount( QModelIndex const & parent ) const\n{\n  if ( parent.isValid() )\n    return 0;\n  return kColumnCount;\n}\n\nQVariant VoiceEnginesModel::headerData( int section, Qt::Orientation /*orientation*/, int role ) const\n{\n  if ( role == Qt::DisplayRole )\n  {\n    switch ( section )\n    {\n      case kColumnEnabled:\n        return tr( \"Enabled\" );\n      case kColumnEngineName:\n        return tr( \"Name\" );\n      case kColumnEngineId:\n        return tr( \"Id\" );\n      case kColumnIcon:\n        return tr( \"Icon\" );\n    }\n  }\n\n  return QVariant();\n}\n\nQVariant VoiceEnginesModel::data( QModelIndex const & index, int role ) const\n{\n  if ( index.row() >= voiceEngines.size() )\n    return QVariant();\n\n  if ( role == Qt::DisplayRole || role == Qt::EditRole )\n  {\n    switch ( index.column() )\n    {\n      case kColumnEngineId:\n        return voiceEngines[ index.row() ].id;\n      case kColumnEngineName:\n        return voiceEngines[ index.row() ].name;\n      case kColumnIcon:\n        return voiceEngines[ index.row() ].iconFilename;\n      default:\n        return QVariant();\n    }\n  }\n\n  if ( role == Qt::CheckStateRole && index.column() == kColumnEnabled )\n    return voiceEngines[ index.row() ].enabled ? Qt::Checked : Qt::Unchecked;\n\n  return QVariant();\n}\n\nbool VoiceEnginesModel::setData( QModelIndex const & index, const QVariant & value,\n                                 int role )\n{\n  if ( index.row() >= voiceEngines.size() )\n    return false;\n\n  if ( role == Qt::CheckStateRole && index.column() == kColumnEnabled )\n  {\n    voiceEngines[ index.row() ].enabled = !voiceEngines[ index.row() ].enabled;\n    dataChanged( index, index );\n    return true;\n  }\n\n  if ( role == Qt::DisplayRole || role == Qt::EditRole )\n  {\n    switch ( index.column() )\n    {\n      case kColumnEngineId:\n        voiceEngines[ index.row() ].id = value.toString();\n        dataChanged( index, index );\n        return true;\n      case kColumnEngineName:\n        voiceEngines[ index.row() ].name = value.toString();\n        dataChanged( index, index );\n        return true;\n      case kColumnIcon:\n        voiceEngines[ index.row() ].iconFilename = value.toString();\n        dataChanged( index, index );\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  return false;\n}\n\nvoid VoiceEnginesModel::setEngineParams( QModelIndex idx, int volume, int rate )\n{\n  if ( idx.isValid() )\n  {\n    voiceEngines[ idx.row() ].volume = volume;\n    voiceEngines[ idx.row() ].rate = rate;\n  }\n}\n\nVoiceEngineEditor::VoiceEngineEditor( SpeechClient::Engines const & engines, QWidget * parent ):\n  QComboBox( parent )\n{\n  foreach ( SpeechClient::Engine engine, engines )\n  {\n    addItem( engine.name, engine.id );\n  }\n}\n\nQString VoiceEngineEditor::engineName() const\n{\n  int idx = currentIndex();\n  if ( idx < 0 )\n    return \"\";\n  return itemText( idx );\n}\n\nQString VoiceEngineEditor::engineId() const\n{\n  int idx = currentIndex();\n  if ( idx < 0 )\n    return \"\";\n  return itemData( idx ).toString();\n}\n\nvoid VoiceEngineEditor::setEngineId( QString const & engineId )\n{\n  // Find index for the id\n  int idx = -1;\n  for ( int i = 0; i < count(); ++i )\n  {\n    if ( engineId == itemData( i ).toString() )\n    {\n      idx = i;\n      break;\n    }\n  }\n  setCurrentIndex( idx );\n}\n\nVoiceEngineItemDelegate::VoiceEngineItemDelegate( SpeechClient::Engines const & engines, QObject * parent ) :\n  QStyledItemDelegate( parent ),\n  engines( engines )\n{\n}\n\nQWidget * VoiceEngineItemDelegate::createEditor( QWidget * parent,\n                                                 QStyleOptionViewItem const & option,\n                                                 QModelIndex const & index ) const\n{\n  if ( index.column() != VoiceEnginesModel::kColumnEngineName )\n    return QStyledItemDelegate::createEditor( parent, option, index );\n  return new VoiceEngineEditor( engines, parent );\n}\n\nvoid VoiceEngineItemDelegate::setEditorData( QWidget * uncastedEditor, const QModelIndex & index ) const\n{\n  VoiceEngineEditor * editor = qobject_cast< VoiceEngineEditor * >( uncastedEditor );\n  if ( !editor )\n    return;\n\n  int currentRow = index.row();\n  QModelIndex engineIdIndex = index.sibling( currentRow, VoiceEnginesModel::kColumnEngineId );\n  QString engineId = index.model()->data( engineIdIndex ).toString();\n  editor->setEngineId( engineId );\n}\n\nvoid VoiceEngineItemDelegate::setModelData( QWidget * uncastedEditor, QAbstractItemModel * model,\n                                            const QModelIndex & index ) const\n{\n  VoiceEngineEditor * editor = qobject_cast< VoiceEngineEditor * >( uncastedEditor );\n  if ( !editor )\n    return;\n\n  int currentRow = index.row();\n  QModelIndex engineIdIndex = index.sibling( currentRow, VoiceEnginesModel::kColumnEngineId );\n  QModelIndex engineNameIndex = index.sibling( currentRow, VoiceEnginesModel::kColumnEngineName );\n  model->setData( engineIdIndex, editor->engineId() );\n  model->setData( engineNameIndex, editor->engineName() );\n}\n"
        },
        {
          "name": "texttospeechsource.hh",
          "type": "blob",
          "size": 3.0859375,
          "content": "/* This file is (c) 2013 Timon Wong <timon86.wang@gmail.com>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __TEXTTOSPEECHSOURCE_HH_INCLUDED__\n#define __TEXTTOSPEECHSOURCE_HH_INCLUDED__\n\n#include \"ui_texttospeechsource.h\"\n#include \"config.hh\"\n#include \"speechclient.hh\"\n\n#include <QComboBox>\n#include <QStyledItemDelegate>\n\n/// A model to be projected into the text to speech view, according to Qt's MVC model\nclass VoiceEnginesModel: public QAbstractItemModel\n{\n  Q_OBJECT\n\npublic:\n\n  enum {\n    kColumnEnabled  = 0,\n    kColumnEngineId,\n    kColumnEngineName,\n    kColumnIcon,\n    kColumnCount\n  };\n\n  VoiceEnginesModel( QWidget * parent, Config::VoiceEngines const & voiceEngines );\n\n  void removeVoiceEngine( int index );\n  void addNewVoiceEngine( QString const & id, QString const & name,\n                          int volume, int rate );\n\n  Config::VoiceEngines const & getCurrentVoiceEngines() const\n  { return voiceEngines; }\n  void setEngineParams( QModelIndex idx, int volume, int rate );\n\n  QModelIndex index( int row, int column, QModelIndex const & parent ) const;\n  QModelIndex parent( QModelIndex const & parent ) const;\n  Qt::ItemFlags flags( QModelIndex const & index ) const;\n  int rowCount( QModelIndex const & parent ) const;\n  int columnCount( QModelIndex const & parent ) const;\n  QVariant headerData( int section, Qt::Orientation orientation, int role ) const;\n  QVariant data( QModelIndex const & index, int role ) const;\n  bool setData( QModelIndex const & index, const QVariant & value, int role );\n\nprivate:\n\n  Config::VoiceEngines voiceEngines;\n};\n\nclass VoiceEngineEditor: public QComboBox\n{\n  Q_OBJECT\n\npublic:\n  VoiceEngineEditor( SpeechClient::Engines const & engines, QWidget * parent = 0 );\n\npublic:\n  QString engineName() const;\n  QString engineId() const;\n  void setEngineId( QString const & engineId );\n};\n\nclass VoiceEngineItemDelegate: public QStyledItemDelegate\n{\n  Q_OBJECT\n\npublic:\n  VoiceEngineItemDelegate( SpeechClient::Engines const & engines, QObject * parent = 0 );\n\n  virtual QWidget * createEditor( QWidget *parent,\n                                  QStyleOptionViewItem const & option,\n                                  QModelIndex const & index ) const;\n  virtual void setEditorData( QWidget *uncastedEditor, const QModelIndex & index ) const;\n  virtual void setModelData( QWidget *uncastedEditor, QAbstractItemModel * model,\n                             const QModelIndex & index ) const;\n\nprivate:\n  SpeechClient::Engines engines;\n};\n\nclass TextToSpeechSource: public QWidget\n{\n  Q_OBJECT\n\npublic:\n  TextToSpeechSource( QWidget * parent, Config::VoiceEngines voiceEngines );\n\n  const VoiceEnginesModel & getVoiceEnginesModel() const\n  { return voiceEnginesModel; }\n\nprivate slots:\n  void on_addVoiceEngine_clicked();\n  void on_removeVoiceEngine_clicked();\n  void on_previewVoice_clicked();\n  void previewVoiceFinished();\n  void slidersChanged();\n  void selectionChanged();\n\nprivate:\n  Ui::TextToSpeechSource ui;\n  VoiceEnginesModel voiceEnginesModel;\n\n  void fitSelectedVoiceEnginesColumns();\n  void adjustSliders();\n};\n\n#endif // __TEXTTOSPEECHSOURCE_HH_INCLUDED__\n"
        },
        {
          "name": "texttospeechsource.ui",
          "type": "blob",
          "size": 6.6533203125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ui version=\"4.0\">\n <class>TextToSpeechSource</class>\n <widget class=\"QWidget\" name=\"TextToSpeechSource\">\n  <property name=\"geometry\">\n   <rect>\n    <x>0</x>\n    <y>0</y>\n    <width>498</width>\n    <height>393</height>\n   </rect>\n  </property>\n  <property name=\"windowTitle\">\n   <string notr=\"true\">Form</string>\n  </property>\n  <layout class=\"QVBoxLayout\" name=\"verticalLayout_3\">\n   <item>\n    <spacer name=\"verticalSpacer\">\n     <property name=\"orientation\">\n      <enum>Qt::Vertical</enum>\n     </property>\n     <property name=\"sizeHint\" stdset=\"0\">\n      <size>\n       <width>20</width>\n       <height>17</height>\n      </size>\n     </property>\n    </spacer>\n   </item>\n   <item>\n    <widget class=\"QLabel\" name=\"label_3\">\n     <property name=\"text\">\n      <string>Selected voice engines:</string>\n     </property>\n    </widget>\n   </item>\n   <item>\n    <layout class=\"QHBoxLayout\" name=\"horizontalLayout_3\">\n     <item>\n      <widget class=\"QTreeView\" name=\"selectedVoiceEngines\"/>\n     </item>\n     <item>\n      <layout class=\"QVBoxLayout\" name=\"verticalLayout\">\n       <item>\n        <widget class=\"QPushButton\" name=\"addVoiceEngine\">\n         <property name=\"maximumSize\">\n          <size>\n           <width>80</width>\n           <height>16777215</height>\n          </size>\n         </property>\n         <property name=\"text\">\n          <string>&amp;Add</string>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <widget class=\"QPushButton\" name=\"removeVoiceEngine\">\n         <property name=\"text\">\n          <string>&amp;Remove</string>\n         </property>\n        </widget>\n       </item>\n       <item>\n        <spacer name=\"verticalSpacer_3\">\n         <property name=\"orientation\">\n          <enum>Qt::Vertical</enum>\n         </property>\n         <property name=\"sizeHint\" stdset=\"0\">\n          <size>\n           <width>20</width>\n           <height>18</height>\n          </size>\n         </property>\n        </spacer>\n       </item>\n      </layout>\n     </item>\n    </layout>\n   </item>\n   <item>\n    <widget class=\"QGroupBox\" name=\"groupBox\">\n     <property name=\"title\">\n      <string>Preferences</string>\n     </property>\n     <layout class=\"QHBoxLayout\" name=\"horizontalLayout_5\">\n      <item>\n       <widget class=\"QLabel\" name=\"label_4\">\n        <property name=\"text\">\n         <string>Volume:</string>\n        </property>\n       </widget>\n      </item>\n      <item>\n       <widget class=\"QSlider\" name=\"volumeSlider\">\n        <property name=\"maximum\">\n         <number>100</number>\n        </property>\n        <property name=\"sliderPosition\">\n         <number>50</number>\n        </property>\n        <property name=\"tracking\">\n         <bool>false</bool>\n        </property>\n        <property name=\"orientation\">\n         <enum>Qt::Horizontal</enum>\n        </property>\n        <property name=\"tickPosition\">\n         <enum>QSlider::TicksAbove</enum>\n        </property>\n        <property name=\"tickInterval\">\n         <number>10</number>\n        </property>\n       </widget>\n      </item>\n      <item>\n       <widget class=\"QLabel\" name=\"label_5\">\n        <property name=\"text\">\n         <string>Rate:</string>\n        </property>\n       </widget>\n      </item>\n      <item>\n       <widget class=\"QSlider\" name=\"rateSlider\">\n        <property name=\"maximum\">\n         <number>100</number>\n        </property>\n        <property name=\"sliderPosition\">\n         <number>50</number>\n        </property>\n        <property name=\"tracking\">\n         <bool>false</bool>\n        </property>\n        <property name=\"orientation\">\n         <enum>Qt::Horizontal</enum>\n        </property>\n        <property name=\"tickPosition\">\n         <enum>QSlider::TicksAbove</enum>\n        </property>\n        <property name=\"tickInterval\">\n         <number>10</number>\n        </property>\n       </widget>\n      </item>\n     </layout>\n    </widget>\n   </item>\n   <item>\n    <widget class=\"QGroupBox\" name=\"groupBox_2\">\n     <property name=\"title\">\n      <string>Preview</string>\n     </property>\n     <layout class=\"QVBoxLayout\" name=\"verticalLayout_2\">\n      <item>\n       <layout class=\"QHBoxLayout\" name=\"horizontalLayout\">\n        <item>\n         <widget class=\"QLabel\" name=\"label_2\">\n          <property name=\"sizePolicy\">\n           <sizepolicy hsizetype=\"Fixed\" vsizetype=\"Preferred\">\n            <horstretch>0</horstretch>\n            <verstretch>0</verstretch>\n           </sizepolicy>\n          </property>\n          <property name=\"text\">\n           <string>Available voice engines:</string>\n          </property>\n         </widget>\n        </item>\n        <item>\n         <widget class=\"QComboBox\" name=\"availableVoiceEngines\"/>\n        </item>\n       </layout>\n      </item>\n      <item>\n       <widget class=\"QLabel\" name=\"label\">\n        <property name=\"sizePolicy\">\n         <sizepolicy hsizetype=\"Fixed\" vsizetype=\"Preferred\">\n          <horstretch>0</horstretch>\n          <verstretch>0</verstretch>\n         </sizepolicy>\n        </property>\n        <property name=\"text\">\n         <string>Text to be previewed:</string>\n        </property>\n       </widget>\n      </item>\n      <item>\n       <widget class=\"QLineEdit\" name=\"previewText\">\n        <property name=\"text\">\n         <string>Type text to be previewed here.</string>\n        </property>\n       </widget>\n      </item>\n      <item>\n       <layout class=\"QHBoxLayout\" name=\"horizontalLayout_2\">\n        <item>\n         <spacer name=\"horizontalSpacer\">\n          <property name=\"orientation\">\n           <enum>Qt::Horizontal</enum>\n          </property>\n          <property name=\"sizeHint\" stdset=\"0\">\n           <size>\n            <width>40</width>\n            <height>20</height>\n           </size>\n          </property>\n         </spacer>\n        </item>\n        <item>\n         <widget class=\"QPushButton\" name=\"previewVoice\">\n          <property name=\"sizePolicy\">\n           <sizepolicy hsizetype=\"Fixed\" vsizetype=\"Fixed\">\n            <horstretch>0</horstretch>\n            <verstretch>0</verstretch>\n           </sizepolicy>\n          </property>\n          <property name=\"minimumSize\">\n           <size>\n            <width>90</width>\n            <height>0</height>\n           </size>\n          </property>\n          <property name=\"text\">\n           <string>&amp;Preview</string>\n          </property>\n         </widget>\n        </item>\n       </layout>\n      </item>\n     </layout>\n    </widget>\n   </item>\n   <item>\n    <spacer name=\"verticalSpacer_2\">\n     <property name=\"orientation\">\n      <enum>Qt::Vertical</enum>\n     </property>\n     <property name=\"sizeHint\" stdset=\"0\">\n      <size>\n       <width>20</width>\n       <height>10</height>\n      </size>\n     </property>\n    </spacer>\n   </item>\n  </layout>\n </widget>\n <resources/>\n <connections/>\n</ui>\n"
        },
        {
          "name": "tiff.cc",
          "type": "blob",
          "size": 3.3662109375,
          "content": "/* This file is (c) 2014 Abs62\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifdef MAKE_EXTRA_TIFF_HANDLER\n\n#include \"tiff.hh\"\n\n#if defined (Q_OS_MAC) || defined (Q_OS_WIN)\n#include \"tiff/tiff.h\"\n#include \"tiff/tiffio.h\"\n#else\n#include \"tiff.h\"\n#include \"tiffio.h\"\n#endif\n\n#include <QBuffer>\n\n#if __cplusplus >= 201103L\n#include <cstdint>\ntypedef std::uint16_t Uint16;\ntypedef std::uint32_t Uint32;\n#else\n// Fall back to deprecated libtiff type aliases in C++98.\ntypedef uint16 Uint16;\ntypedef uint32 Uint32;\n#endif\n\nnamespace GdTiff\n{\n\ntsize_t tiffReadProc( thandle_t fd, tdata_t buf, tsize_t size )\n{\n  return static_cast< QIODevice * >( fd )->read( static_cast< char * >( buf ), size );\n}\n\ntsize_t tiffWriteProc( thandle_t fd, tdata_t buf, tsize_t size )\n{\nQ_UNUSED( fd )\nQ_UNUSED( buf )\nQ_UNUSED( size )\n  return 0;\n}\n\ntoff_t tiffSeekProc( thandle_t fd, toff_t off, int whence )\n{\n  QIODevice * device = static_cast< QIODevice * >( fd );\n  switch (whence) {\n    case SEEK_SET:\n        device->seek( off );\n        break;\n    case SEEK_CUR:\n        device->seek( device->pos() + off );\n        break;\n    case SEEK_END:\n        device->seek( device->size() + off );\n        break;\n  }\n\n  return device->pos();\n}\n\nint tiffCloseProc( thandle_t fd )\n{\nQ_UNUSED( fd )\n  return 0;\n}\n\ntoff_t tiffSizeProc( thandle_t fd )\n{\n  return static_cast< QIODevice * >( fd )->size();\n}\n\nint tiffMapProc( thandle_t fd, tdata_t * pbase, toff_t * psize )\n{\nQ_UNUSED( fd )\nQ_UNUSED( pbase )\nQ_UNUSED( psize )\n  return 0;\n}\n\nvoid tiffUnmapProc( thandle_t fd, tdata_t base, toff_t size )\n{\nQ_UNUSED( fd )\nQ_UNUSED( base )\nQ_UNUSED( size )\n}\n\n\nbool tiffToQImage( const char * data, int size, QImage & image )\n{\n  QByteArray arr = QByteArray::fromRawData( data, size );\n  QBuffer buf;\n  buf.setData( arr );\n  buf.open( QIODevice::ReadOnly );\n\n  TIFF *const tiff = TIFFClientOpen( \"foo\",\n                                     \"r\",\n                                     &buf,\n                                     tiffReadProc,\n                                     tiffWriteProc,\n                                     tiffSeekProc,\n                                     tiffCloseProc,\n                                     tiffSizeProc,\n                                     tiffMapProc,\n                                     tiffUnmapProc );\n  if( !tiff )\n    return false;\n\n  Uint32 width, height;\n  if( !TIFFGetField( tiff, TIFFTAG_IMAGEWIDTH, &width )\n      || !TIFFGetField( tiff, TIFFTAG_IMAGELENGTH, &height ) )\n  {\n    TIFFClose( tiff );\n    return false;\n  }\n\n  Uint16 bitPerSample;\n  if( !TIFFGetField( tiff, TIFFTAG_BITSPERSAMPLE, &bitPerSample ) )\n    bitPerSample = 1;\n\n  Uint16 samplesPerPixel; // they may be e.g. grayscale with 2 samples per pixel\n  if( !TIFFGetField( tiff, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel ) )\n    samplesPerPixel = 1;\n\n  if( bitPerSample == 1 && samplesPerPixel == 1 )\n  {\n    QImage tiffImage( width, height, QImage::Format_Mono );\n\n    QVector<QRgb> colortable( 2 );\n    colortable[0] = 0xffffffff;\n    colortable[1] = 0xff000000;\n    tiffImage.setColorTable( colortable );\n\n    for ( Uint32 y = 0; y < height; ++y )\n    {\n      if( TIFFReadScanline( tiff, tiffImage.scanLine( y ), y, 0 ) < 0 )\n      {\n        TIFFClose( tiff );\n        return false;\n      }\n    }\n\n    image = tiffImage;\n    TIFFClose( tiff );\n    return true;\n  }\n\n  TIFFClose( tiff );\n  return false;\n}\n\n} // namespace\n\n#endif\n"
        },
        {
          "name": "tiff.hh",
          "type": "blob",
          "size": 0.3515625,
          "content": "#ifndef __TIFF_HH_INCLUDED__\n#define __TIFF_HH_INCLUDED__\n\n#ifdef MAKE_EXTRA_TIFF_HANDLER\n\n#include <QImage>\n\nnamespace GdTiff\n{\n\n// QImage don't handle TIFF files if TIFFTAG_PHOTOMETRIC is not set\n// We will handle such 1-bit b/w images with default photometric\n\nbool tiffToQImage( const char * data, int size, QImage & image );\n\n}\n\n#endif\n\n#endif // TIFF_HH\n"
        },
        {
          "name": "translatebox.cc",
          "type": "blob",
          "size": 9.1376953125,
          "content": "/* This file is (c) 2012 Tvangeste <i.4m.l33t@yandex.ru>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"translatebox.hh\"\n\n#include <QHBoxLayout>\n#include <QEvent>\n#include <QKeyEvent>\n#include <QApplication>\n#include <QDebug>\n#include <QModelIndex>\n#include <QScrollBar>\n#include <QStyle>\n\n#ifdef Q_OS_WIN32\n#include <QDesktopWidget>\n#endif\n\nnamespace\n{\n#define MAX_POPUP_ROWS 17\n}\n\nCompletionList::CompletionList(TranslateBox * parent) : WordList(parent),\n  translateBox(parent)\n{\n#ifdef Q_OS_WIN\n  setWindowFlags(Qt::ToolTip);\n#else\n  setParent( parent->window() );\n  setAutoFillBackground( true );\n#endif\n\n  connect(this, SIGNAL( activated( QModelIndex ) ),\n          this, SLOT( acceptCurrentEntry() ) );\n\n  connect(this, SIGNAL( itemClicked( QListWidgetItem * ) ),\n          this, SLOT( acceptCurrentEntry() ) );\n\n  translateBox->window()->installEventFilter(this);\n}\n\nbool CompletionList::eventFilter( QObject * obj, QEvent * ev )\n{\n  // when the main window is moved or resized, hide the word list suggestions\n  if ( obj != this && !isAncestorOf( qobject_cast< QWidget * >( obj ) )\n       && ( ev->type() == QEvent::Move || ev->type() == QEvent::Resize ) )\n  {\n    translateBox->setPopupEnabled( false );\n    return false;\n  }\n\n  return QWidget::eventFilter( obj, ev );\n}\n\nint CompletionList::preferredHeight() const\n{\n  const QSize itemSizeHint = itemDelegate()->sizeHint(viewOptions(), model()->index( 0, 0 ) );\n  int rows = qMin( count(), MAX_POPUP_ROWS );\n\n  int scrollBarHeight = 0;\n\n  bool hBarIsVisible = horizontalScrollBar()->maximum() > 0;\n\n  if ( hBarIsVisible )\n    scrollBarHeight += QApplication::style()->pixelMetric( QStyle::PM_ScrollBarExtent );\n\n  return rows == 0 ? 0 : itemSizeHint.height() * rows + frameWidth() * 2 + scrollBarHeight;\n}\n\nbool CompletionList::acceptCurrentEntry()\n{\n  if (!isVisible())\n  {\n    return false;\n  }\n\n  const QModelIndex index = currentIndex();\n  if ( !index.isValid() )\n  {\n    return false;\n  }\n\n  emit doubleClicked(index);\n  translateBox->setPopupEnabled( false );\n\n  return true;\n}\n\nTranslateBox::TranslateBox(QWidget *parent) : QWidget(parent),\n  word_list(new CompletionList(this)), translate_line(new ExtLineEdit(this)), m_popupEnabled(false)\n{\n  // initially hidden\n  word_list->hide();\n\n  resize(200, 90);\n  QSizePolicy sizePolicy(QSizePolicy::Fixed, QSizePolicy::Preferred);\n  sizePolicy.setHorizontalStretch(0);\n  sizePolicy.setVerticalStretch(0);\n  setSizePolicy(sizePolicy);\n  // setMinimumSize(QSize(800, 0));\n\n  setFocusProxy(translate_line);\n  translate_line->setObjectName(\"translateLine\");\n#if QT_VERSION >= 0x040700\n  translate_line->setPlaceholderText( tr( \"Type a word or phrase to search dictionaries\" ) );\n#endif\n\n  word_list->setTranslateLine(translate_line);\n\n  // completer = new QCompleter(m_completionList->model(), this);\n  // completer->setCaseSensitivity(Qt::CaseInsensitive);\n  // completer->setCompletionMode(QCompleter::InlineCompletion);\n\n  QHBoxLayout *layout = new QHBoxLayout(this);\n  setLayout(layout);\n  layout->setMargin(0);\n  layout->addWidget(translate_line);\n\n  QPixmap image(\":/icons/system-search.png\");\n  translate_line->setButtonPixmap(ExtLineEdit::Left, image.scaled(18, 18, Qt::KeepAspectRatio, Qt::SmoothTransformation));\n  // translate_line->setButtonToolTip(ExtLineEdit::Left, tr(\"Options\"));\n  translate_line->setButtonVisible(ExtLineEdit::Left, true);\n  translate_line->setButtonFocusPolicy(ExtLineEdit::Left, Qt::ClickFocus);\n\n  QPixmap right(\":/icons/1downarrow.png\");\n  translate_line->setButtonPixmap(ExtLineEdit::Right, right);\n  translate_line->setButtonToolTip(ExtLineEdit::Right, tr(\"Drop-down\"));\n  translate_line->setButtonVisible(ExtLineEdit::Right, true);\n  translate_line->setButtonFocusPolicy(ExtLineEdit::Right, Qt::NoFocus);\n\n  translate_line->setFocusPolicy(Qt::ClickFocus);\n\n  translate_line->installEventFilter( this );\n  this->installEventFilter( this );\n\n  connect(translate_line, SIGNAL( textChanged( QString const & ) ),\n          this, SLOT( onTextEdit() ) );\n\n  connect(translate_line, SIGNAL( rightButtonClicked() ),\n          this, SLOT( rightButtonClicked() ) );\n\n  connect(word_list, SIGNAL( contentChanged() ),\n          this, SLOT( showPopup() ) );\n}\n\nbool TranslateBox::eventFilter(QObject *obj, QEvent *event)\n{\n    // hide the suggestions list when the window is not active\n    if ( event->type() == QEvent::WindowDeactivate )\n    {\n      if (!word_list->isActiveWindow())\n      {\n        setPopupEnabled( false );\n      }\n      return false;\n    }\n\n    if (obj == translate_line && event->type() == QEvent::KeyPress) {\n        QKeyEvent *keyEvent = static_cast<QKeyEvent *>(event);\n        switch (keyEvent->key()) {\n        case Qt::Key_Up:\n        case Qt::Key_Down:\n        case Qt::Key_PageUp:\n        case Qt::Key_PageDown:\n          if ( !word_list->isVisible() )\n          {\n            setPopupEnabled( true );\n          }\n          else\n          {\n            QApplication::sendEvent(word_list, event);\n          }\n          return true;\n        case Qt::Key_Enter:\n        case Qt::Key_Return:\n          return word_list->acceptCurrentEntry();\n        case Qt::Key_Escape:\n          setPopupEnabled( false );\n          return true;\n        case Qt::Key_Tab:\n          if ( !word_list->isVisible() )\n          {\n            setPopupEnabled( true );\n          }\n          else\n          {\n            QKeyEvent event( QEvent::KeyPress, Qt::Key_Down, Qt::NoModifier );\n            QApplication::sendEvent( word_list, &event );\n          }\n          return true;\n        case Qt::Key_Backtab:\n          if ( !word_list->isVisible() )\n          {\n            setPopupEnabled( true );\n          }\n          else\n          {\n            QKeyEvent event( QEvent::KeyPress, Qt::Key_Up, Qt::NoModifier );\n            QApplication::sendEvent( word_list, &event );\n          }\n          return true;\n        default:\n            break;\n        }\n    } else if (obj == translate_line && event->type() == QEvent::FocusOut) {\n#if defined(Q_OS_WIN)\n        QFocusEvent *fev = static_cast<QFocusEvent*>(event);\n        if (fev->reason() != Qt::ActiveWindowFocusReason ||\n            (fev->reason() == Qt::ActiveWindowFocusReason && !word_list->isActiveWindow()))\n#endif\n          setPopupEnabled( false );\n    } else if (obj == translate_line && event->type() == QEvent::FocusIn) {\n      // By default, focusing the traslate line does not show\n      // the popup window.\n    } else if (obj == this && event->type() == QEvent::ShortcutOverride) {\n        QKeyEvent *ke = static_cast<QKeyEvent *>(event);\n        if (ke->key() == Qt::Key_Escape && !ke->modifiers() && word_list->isVisible() ) {\n            event->accept();\n            return true;\n        }\n    }\n    return QWidget::eventFilter(obj, event);\n}\n\nvoid TranslateBox::setText( QString text, bool showPopup )\n{\n  setPopupEnabled( showPopup );\n  translate_line->setText( text );\n}\n\nvoid TranslateBox::setPopupEnabled( bool enable )\n{\n  m_popupEnabled = enable;\n  showPopup();\n}\n\nvoid TranslateBox::setSizePolicy( QSizePolicy policy )\n{\n  QWidget::setSizePolicy( policy );\n  if ( translate_line )\n    translate_line->setSizePolicy( policy );\n}\n\nvoid TranslateBox::showPopup()\n{\n  // completer->setCompletionPrefix( m_fileLineEdit->text() );\n  // qDebug() << \"COMPLETION:\" << completer->currentCompletion();\n\n  // Don't allow recursive call\n  if( translateBoxMutex.tryLock() )\n    translateBoxMutex.unlock();\n  else\n    return;\n  Mutex::Lock _( translateBoxMutex );\n\n  if (translate_line->text().trimmed().isEmpty() || word_list->count() == 0)\n  {\n    // nothing to show\n    if (word_list->isVisible())\n    {\n      word_list->hide();\n      translate_line->setFocus();\n    }\n    return;\n  }\n\n  if ( !m_popupEnabled )\n  {\n    word_list->hide();\n    return;\n  }\n\n  int preferredHeight = word_list->preferredHeight();\n\n  QPoint origin( translate_line->x(), translate_line->y() + translate_line->height() );\n\n  if ( word_list->isWindow() )\n  {\n    origin = mapToGlobal( origin );\n  }\n  else\n  {\n    origin = mapTo( window(), origin );\n//    preferredHeight = qMin( translate_line->window()->height() - origin.y(), preferredHeight );\n  }\n\n  const QSize size(width(), preferredHeight);\n  QRect rect( origin, size );\n#ifdef Q_OS_WIN32\n  QPoint topLeft = word_list->isWindow() ? rect.topLeft() : mapToGlobal( rect.topLeft() );\n  QPoint bottomLeft = word_list->isWindow() ? rect.bottomLeft() : mapToGlobal( rect.bottomLeft() );\n  if( bottomLeft.y() >= QApplication::desktop()->screenGeometry( topLeft ).bottom() )\n    rect.moveTop( rect.top() - preferredHeight - translate_line->height() );\n#else\n  if( !isWindow() )\n  {\n    if( rect.bottom() > window()->height() )\n    {\n      if( rect.top() - preferredHeight - translate_line->height() >= 0 )\n        rect.moveTop( rect.top() - preferredHeight - translate_line->height() );\n      else\n        rect.setBottom( window()->height() );\n    }\n  }\n#endif\n\n  word_list->setGeometry(rect);\n  word_list->show();\n  word_list->raise();\n  translate_line->setFocus();\n}\n\nQLineEdit * TranslateBox::translateLine()\n{\n  return translate_line;\n}\n\nWordList * TranslateBox::wordList()\n{\n  return word_list;\n}\n\nvoid TranslateBox::rightButtonClicked()\n{\n  setPopupEnabled( !m_popupEnabled );\n}\n\nvoid TranslateBox::onTextEdit()\n{\n  if ( translate_line->hasFocus() )\n    setPopupEnabled( true );\n}\n"
        },
        {
          "name": "translatebox.hh",
          "type": "blob",
          "size": 1.525390625,
          "content": "/* This file is (c) 2012 Tvangeste <i.4m.l33t@yandex.ru>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef TRANSLATEBOX_HH\n#define TRANSLATEBOX_HH\n\n#include \"extlineedit.hh\"\n#include \"wordlist.hh\"\n#include \"mutex.hh\"\n\n#include <QWidget>\n#include <QListWidget>\n#include <QFocusEvent>\n\nclass TranslateBox;\n\nclass CompletionList : public WordList\n{\n  Q_OBJECT\n\npublic:\n  CompletionList(TranslateBox * parent);\n  int preferredHeight() const;\n  virtual void setTranslateLine(QLineEdit * line)\n  {\n    WordList::setTranslateLine( line );\n    setFocusProxy( line );\n  }\n\npublic slots:\n  bool acceptCurrentEntry();\n\nprivate:\n  virtual bool eventFilter( QObject *, QEvent * );\n  TranslateBox * translateBox;\n};\n\nclass TranslateBox : public QWidget\n{\n  Q_OBJECT\n\npublic:\n  explicit TranslateBox(QWidget * parent = 0);\n  void setPlaceholderText(const QString &text);\n  QLineEdit * translateLine();\n  WordList * wordList();\n  void setText(QString text, bool showPopup=true);\n  void setSizePolicy(QSizePolicy policy);\n  inline void setSizePolicy(QSizePolicy::Policy hor, QSizePolicy::Policy ver)\n  { setSizePolicy(QSizePolicy(hor, ver)); }\n\nsignals:\n\npublic slots:\n  void setPopupEnabled(bool enable);\n\nprivate slots:\n  void showPopup();\n  void rightButtonClicked();\n  void onTextEdit();\n\nprivate:\n  bool eventFilter(QObject *obj, QEvent *event);\n  CompletionList * word_list;\n  ExtLineEdit * translate_line;\n  bool m_popupEnabled;\n  Mutex translateBoxMutex;\n  // QCompleter * completer; // disabled for now\n};\n\n#endif // TRANSLATEBOX_HH\n"
        },
        {
          "name": "transliteration.cc",
          "type": "blob",
          "size": 4.02734375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"transliteration.hh\"\n#include \"utf8.hh\"\n#include \"folding.hh\"\n#include \"gddebug.hh\"\n\nnamespace Transliteration {\n\nusing gd::wchar;\n\nBaseTransliterationDictionary::BaseTransliterationDictionary( string const & id,\n                                                              string const & name_,\n                                                              QIcon icon_,\n                                                              bool caseSensitive_ ):\n  Dictionary::Class( id, vector< string >() ),\n  name( name_ ),\n  caseSensitive( caseSensitive_ )\n{\n  dictionaryIcon = dictionaryNativeIcon = icon_;\n  dictionaryIconLoaded = true;\n}\n\nstring BaseTransliterationDictionary::getName() throw()\n{ return name; }\n\nmap< Dictionary::Property, string > BaseTransliterationDictionary::getProperties() throw()\n{ return map< Dictionary::Property, string >(); }\n\nunsigned long BaseTransliterationDictionary::getArticleCount() throw()\n{ return 0; }\n\nunsigned long BaseTransliterationDictionary::getWordCount() throw()\n{ return 0; }\n\nsptr< Dictionary::WordSearchRequest > BaseTransliterationDictionary::prefixMatch( wstring const &,\n                                                                                  unsigned long ) THROW_SPEC( std::exception )\n{ return new Dictionary::WordSearchRequestInstant(); }\n\nsptr< Dictionary::DataRequest > BaseTransliterationDictionary::getArticle( wstring const &,\n                                                                           vector< wstring > const &,\n                                                                           wstring const &, bool )\n  THROW_SPEC( std::exception )\n{ return new Dictionary::DataRequestInstant( false ); }\n\nsptr< Dictionary::WordSearchRequest > BaseTransliterationDictionary::findHeadwordsForSynonym( wstring const & str )\n  THROW_SPEC( std::exception )\n{\n  sptr< Dictionary::WordSearchRequestInstant > result = new Dictionary::WordSearchRequestInstant();\n\n  vector< wstring > alts = getAlternateWritings( str );\n\n  GD_DPRINTF( \"alts = %u\\n\", (unsigned) alts.size() );\n\n  for( unsigned x = 0; x < alts.size(); ++x )\n    result->getMatches().push_back( alts[ x ] );\n\n  return result;\n}\n\n\nvoid Table::ins( char const * from, char const * to )\n{\n  wstring fr = Utf8::decode( std::string( from ) );\n\n  if ( fr.size() > maxEntrySize )\n    maxEntrySize = fr.size();\n\n  insert( std::pair< wstring, wstring >( fr,\n                                         Utf8::decode( std::string( to ) ) ) );\n}\n\n\nTransliterationDictionary::TransliterationDictionary( string const & id,\n                                                      string const & name_,\n                                                      QIcon icon_,\n                                                      Table const & table_,\n                                                      bool caseSensitive_ ):\n  BaseTransliterationDictionary(id, name_, icon_, caseSensitive_),\n  table( table_ )\n{\n}\n\nvector< wstring > TransliterationDictionary::getAlternateWritings( wstring const & str )\n  throw()\n{\n  vector< wstring > results;\n\n  wstring result, folded;\n  wstring const * target;\n\n  if ( caseSensitive )\n  {\n    // Don't do any transform -- the transliteration is case-sensitive\n    target = &str;\n  }\n  else\n  {\n    folded = Folding::applySimpleCaseOnly( str );\n    target = &folded;\n  }\n\n  wchar const * ptr = target->c_str();\n  size_t left = target->size();\n\n  Table::const_iterator i;\n\n  while( left )\n  {\n    unsigned x;\n\n    for( x = table.getMaxEntrySize(); x >= 1; --x )\n    {\n      if ( left >= x )\n      {\n        i = table.find( wstring( ptr, x ) );\n\n        if ( i != table.end() )\n        {\n          result.append( i->second );\n          ptr += x;\n          left -= x;\n          break;\n        }\n      }\n    }\n\n    if ( !x )\n    {\n      // No matches -- add this char as it is\n      result.push_back( *ptr++ );\n      --left;\n    }\n  }\n\n  if ( result != *target )\n    results.push_back( result );\n\n  return results;\n}\n\n}\n"
        },
        {
          "name": "transliteration.hh",
          "type": "blob",
          "size": 2.3603515625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __TRANSLITERATION_HH_INCLUDED__\n#define __TRANSLITERATION_HH_INCLUDED__\n\n#include \"dictionary.hh\"\n#include <map>\n\nnamespace Transliteration {\n\nusing std::map;\nusing gd::wstring;\nusing std::string;\nusing std::vector;\n\n\n/// This is a base dictionary class for simple transliteratons\nclass BaseTransliterationDictionary: public Dictionary::Class\n{\n  string name;\n\nprotected:\n  bool caseSensitive;\n\npublic:\n\n  BaseTransliterationDictionary( string const & id, string const & name,\n                                 QIcon icon, bool caseSensitive = true );\n\n  virtual string getName() throw();\n\n  virtual map< Dictionary::Property, string > getProperties() throw();\n\n  virtual unsigned long getArticleCount() throw();\n\n  virtual unsigned long getWordCount() throw();\n\n  virtual vector< wstring > getAlternateWritings( wstring const & )\n    throw() = 0;\n\n  virtual sptr< Dictionary::WordSearchRequest > findHeadwordsForSynonym( wstring const & )\n    THROW_SPEC( std::exception );\n\n  virtual sptr< Dictionary::WordSearchRequest > prefixMatch( wstring const &,\n                                                             unsigned long ) THROW_SPEC( std::exception );\n\n  virtual sptr< Dictionary::DataRequest > getArticle( wstring const &,\n                                                      vector< wstring > const &,\n                                                      wstring const &, bool )\n    THROW_SPEC( std::exception );\n};\n\n\nclass Table: public map< wstring, wstring >\n{\n  unsigned maxEntrySize;\n\npublic:\n\n  Table(): maxEntrySize( 0 )\n  {}\n\n  unsigned getMaxEntrySize() const\n  { return maxEntrySize; }\n\nprotected:\n\n  /// Inserts new entry into index. from and to are UTF8-encoded strings.\n  /// Also updates maxEntrySize.\n  void ins( char const * from, char const * to );\n};\n\n\n/// A base dictionary class for table based transliteratons\nclass TransliterationDictionary: public BaseTransliterationDictionary\n{\n  Table const & table;\n\npublic:\n\n  TransliterationDictionary( string const & id, string const & name,\n                             QIcon icon,\n                             Table const & table,\n                             bool caseSensitive = true );\n\n  virtual vector< wstring > getAlternateWritings( wstring const & )\n    throw();\n};\n\n}\n\n#endif\n"
        },
        {
          "name": "treeview.cc",
          "type": "blob",
          "size": 0.4267578125,
          "content": "/* This file is (c) 2008-2018 Abs62\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include <QDropEvent>\n#include \"treeview.hh\"\n\nvoid TreeView::dropEvent( QDropEvent * event )\n{\n  QTreeView::dropEvent( event );\n\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n  // Qt 4 don't check success of drop operation. Add turnaround.\n\n  if( !event->isAccepted() )\n    event->setDropAction( Qt::IgnoreAction );\n#endif\n}\n"
        },
        {
          "name": "treeview.hh",
          "type": "blob",
          "size": 0.388671875,
          "content": "/* This file is (c) 2008-2018 Abs62\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __TREEVIEW_HH__INCLUDED\n#define __TREEVIEW_HH__INCLUDED\n\n#include <QTreeView>\n\nclass TreeView : public QTreeView\n{\npublic:\n  TreeView( QWidget * parent = 0 ) :\n    QTreeView( parent )\n  {}\n\nprotected:\n  virtual void dropEvent( QDropEvent * event );\n};\n\n#endif // TREEVIEW_HH\n"
        },
        {
          "name": "ufile.cc",
          "type": "blob",
          "size": 0.8486328125,
          "content": "#ifdef __WIN32\n\n#include <stdio.h>\n#include <io.h>\n#include <fcntl.h>\n#include <windows.h>\n\n#include \"ufile.hh\"\n\nFILE *gd_fopen( const char *filename, const char *mode)\n{\n    wchar_t wname[16384], wmode[32];\n\n    if( MultiByteToWideChar( CP_UTF8, 0, filename, -1, wname, 16384 ) == 0 )\n        return NULL;\n    if( MultiByteToWideChar( CP_UTF8, 0, mode, -1, wmode, 32 ) == 0 )\n        return NULL;\n    return _wfopen( wname, wmode );\n}\n\nint gd_open( const char *filename)\n{\n    wchar_t wname[16384];\n\n    if( MultiByteToWideChar( CP_UTF8, 0, filename, -1, wname, 16384 ) == 0 )\n        return -1;\n    return _wopen( wname, _O_RDONLY | _O_BINARY );\n}\n\ngzFile gd_gzopen( const char *filename )\n{\n    int id = gd_open( filename );\n    if( id == -1 )\n        return NULL;\n    gzFile f = gzdopen( id, \"rb\");\n    if( f == NULL )\n        _close( id );\n    return f;\n}\n\n#endif\n"
        },
        {
          "name": "ufile.hh",
          "type": "blob",
          "size": 0.49609375,
          "content": "#ifndef UFILE_HH_INCLUDED\n#define UFILE_HH_INCLUDED\n\n#ifdef __WIN32\n\n#include \"zlib.h\"\n\n// eliminate some VC++ warnings\n#ifdef _MSC_VER\n#define fileno _fileno\n#endif\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\nFILE *gd_fopen( const char *filename, const char *mode );\nint gd_open( const char *filename );\ngzFile gd_gzopen( const char *filename );\n\n#ifdef __cplusplus\n}  /* end extern \"C\" */\n#endif\n\n#else\n#define gd_fopen fopen\n#define gd_gzopen( filename )  gzopen( filename, \"rb\" )\n#endif\n\n#endif // UFILE_HH\n"
        },
        {
          "name": "uiauto.hh",
          "type": "blob",
          "size": 18.716796875,
          "content": "#ifndef __UIAUTO_HH_INCLUDED__\n#define __UIAUTO_HH_INCLUDED__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <oleacc.h>\n\nEXTERN_C const IID IID_IUIAutomation;\nEXTERN_C const IID CLSID_CUIAutomation;\nEXTERN_C const IID IID_IUIAutomationElement;\nEXTERN_C const IID IID_IUIAutomationTextPattern;\nEXTERN_C const IID IID_IUIAutomationTextRange;\nEXTERN_C const IID IID_IUIAutomationTreeWalker;\n\ntypedef interface IUIAutomationElement IUIAutomationElement;\ntypedef interface IUIAutomationElementArray IUIAutomationElementArray;\ntypedef interface IUIAutomationTextPattern IUIAutomationTextPattern;\ntypedef interface IUIAutomationTextRange IUIAutomationTextRange;\ntypedef interface IUIAutomationTextRangeArray IUIAutomationTextRangeArray;\ntypedef interface IUIAutomationCacheRequest IUIAutomationCacheRequest;\ntypedef interface IUIAutomationTreeWalker IUIAutomationTreeWalker;\ntypedef interface IUIAutomationCondition IUIAutomationCondition;\ntypedef interface IUIAutomationEventHandler IUIAutomationEventHandler;\ntypedef interface IUIAutomationPropertyChangedEventHandler IUIAutomationPropertyChangedEventHandler;\ntypedef interface IUIAutomationStructureChangedEventHandler IUIAutomationStructureChangedEventHandler;\ntypedef interface IUIAutomationFocusChangedEventHandler IUIAutomationFocusChangedEventHandler;\ntypedef interface IUIAutomationProxyFactory IUIAutomationProxyFactory;\ntypedef interface IUIAutomationProxyFactoryEntry IUIAutomationProxyFactoryEntry;\ntypedef interface IUIAutomationProxyFactoryMapping IUIAutomationProxyFactoryMapping;\n\ntypedef void *UIA_HWND;\ntypedef int PROPERTYID;\ntypedef int EVENTID;\ntypedef int PATTERNID;\ntypedef int CONTROLTYPEID;\ntypedef int TEXTATTRIBUTEID;\n\nenum TreeScope\n{\n    TreeScope_Element       = 0x1,\n    TreeScope_Children      = 0x2,\n    TreeScope_Descendants   = 0x4,\n    TreeScope_Parent        = 0x8,\n    TreeScope_Ancestors     = 0x10,\n    TreeScope_Subtree       = ( ( TreeScope_Element | TreeScope_Children )  | TreeScope_Descendants )\n};\n\nenum PropertyConditionFlags\n{\n    PropertyConditionFlags_None = 0,\n    PropertyConditionFlags_IgnoreCase = 0x1\n};\n\nenum OrientationType\n{\n    OrientationType_None        = 0,\n    OrientationType_Horizontal  = 1,\n    OrientationType_Vertical    = 2\n};\n\nenum SupportedTextSelection\n{\n    SupportedTextSelection_None     = 0,\n    SupportedTextSelection_Single   = 1,\n    SupportedTextSelection_Multiple = 2\n};\n\nenum TextPatternRangeEndpoint\n{\n    TextPatternRangeEndpoint_Start  = 0,\n    TextPatternRangeEndpoint_End    = 1\n};\n\nenum TextUnit\n{\n    TextUnit_Character  = 0,\n    TextUnit_Format     = 1,\n    TextUnit_Word       = 2,\n    TextUnit_Line       = 3,\n    TextUnit_Paragraph  = 4,\n    TextUnit_Page       = 5,\n    TextUnit_Document   = 6\n};\n\nenum ProviderOptions\n{\n    ProviderOptions_ClientSideProvider      = 0x1,\n    ProviderOptions_ServerSideProvider      = 0x2,\n    ProviderOptions_NonClientAreaProvider   = 0x4,\n    ProviderOptions_OverrideProvider        = 0x8,\n    ProviderOptions_ProviderOwnsSetFocus    = 0x10,\n    ProviderOptions_UseComThreading         = 0x20\n} ;\n\n/* UIA_PatternIds */\nconst long UIA_InvokePatternId              =   10000;\nconst long UIA_SelectionPatternId           =   10001;\nconst long UIA_ValuePatternId               =   10002;\nconst long UIA_RangeValuePatternId          =   10003;\nconst long UIA_ScrollPatternId              =   10004;\nconst long UIA_ExpandCollapsePatternId      =   10005;\nconst long UIA_GridPatternId                =   10006;\nconst long UIA_GridItemPatternId            =   10007;\nconst long UIA_MultipleViewPatternId        =   10008;\nconst long UIA_WindowPatternId              =   10009;\nconst long UIA_SelectionItemPatternId       =   10010;\nconst long UIA_DockPatternId                =   10011;\nconst long UIA_TablePatternId               =   10012;\nconst long UIA_TableItemPatternId           =   10013;\nconst long UIA_TextPatternId                =   10014;\nconst long UIA_TogglePatternId              =   10015;\nconst long UIA_TransformPatternId           =   10016;\nconst long UIA_ScrollItemPatternId          =   10017;\nconst long UIA_LegacyIAccessiblePatternId   =   10018;\nconst long UIA_ItemContainerPatternId       =   10019;\nconst long UIA_VirtualizedItemPatternId     =   10020;\nconst long UIA_SynchronizedInputPatternId   =   10021;\n\n#ifdef INTERFACE\n#undef INTERFACE\n#endif\n\n#define INTERFACE IUIAutomation\nDECLARE_INTERFACE_(IUIAutomation, IUnknown)\n{\n    STDMETHOD(CompareElements)(THIS_ IUIAutomationElement *, IUIAutomationElement *, BOOL *) PURE;\n    STDMETHOD(CompareRuntimeIds)(THIS_ SAFEARRAY *, SAFEARRAY *, BOOL *) PURE;\n    STDMETHOD(GetRootElement)(THIS_ IUIAutomationElement **) PURE;\n    STDMETHOD(ElementFromHandle)(THIS_ UIA_HWND, IUIAutomationElement **) PURE;\n    STDMETHOD(ElementFromPoint)(THIS_ POINT, IUIAutomationElement **) PURE;\n    STDMETHOD(GetFocusedElement)(THIS_ IUIAutomationElement **) PURE;\n    STDMETHOD(GetRootElementBuildCache)(THIS_ IUIAutomationCacheRequest *, IUIAutomationElement **) PURE;\n    STDMETHOD(ElementFromHandleBuildCache)(THIS_ UIA_HWND, IUIAutomationCacheRequest *, IUIAutomationElement **) PURE;\n    STDMETHOD(ElementFromPointBuildCache)(THIS_ POINT, IUIAutomationCacheRequest *, IUIAutomationElement **) PURE;\n    STDMETHOD(GetFocusedElementBuildCache)(THIS_ IUIAutomationCacheRequest *, IUIAutomationElement **) PURE;\n    STDMETHOD(CreateTreeWalker)(THIS_ IUIAutomationCondition *, IUIAutomationTreeWalker **) PURE;\n    STDMETHOD(get_ControlViewWalker)(THIS_ IUIAutomationTreeWalker **) PURE;\n    STDMETHOD(get_ContentViewWalker)(THIS_ IUIAutomationTreeWalker **) PURE;\n    STDMETHOD(get_RawViewWalker)(THIS_ IUIAutomationTreeWalker **) PURE;\n    STDMETHOD(get_RawViewCondition)(THIS_ IUIAutomationCondition **) PURE;\n    STDMETHOD(get_ControlViewCondition)(THIS_ IUIAutomationCondition **) PURE;\n    STDMETHOD(get_ContentViewCondition)(THIS_ IUIAutomationCondition **) PURE;\n    STDMETHOD(CreateCacheRequest)(THIS_ IUIAutomationCacheRequest **) PURE;\n    STDMETHOD(CreateTrueCondition)(THIS_ IUIAutomationCondition **) PURE;\n    STDMETHOD(CreateFalseCondition)(THIS_ IUIAutomationCondition **) PURE;\n    STDMETHOD(CreatePropertyCondition)(THIS_ PROPERTYID, VARIANT, IUIAutomationCondition **) PURE;\n    STDMETHOD(CreatePropertyConditionEx)(THIS_ PROPERTYID, VARIANT, enum PropertyConditionFlags, IUIAutomationCondition **) PURE;\n    STDMETHOD(CreateAndCondition)(THIS_ IUIAutomationCondition *, IUIAutomationCondition *, IUIAutomationCondition **) PURE;\n    STDMETHOD(CreateAndConditionFromArray)(THIS_ SAFEARRAY *, IUIAutomationCondition **) PURE;\n    STDMETHOD(CreateAndConditionFromNativeArray)(THIS_ IUIAutomationCondition **, int , IUIAutomationCondition **) PURE;\n    STDMETHOD(CreateOrCondition)(THIS_ IUIAutomationCondition *, IUIAutomationCondition *, IUIAutomationCondition **) PURE;\n    STDMETHOD(CreateOrConditionFromArray)(THIS_ SAFEARRAY *, IUIAutomationCondition **) PURE;\n    STDMETHOD(CreateOrConditionFromNativeArray)(THIS_ IUIAutomationCondition **, int , IUIAutomationCondition **) PURE;\n    STDMETHOD(CreateNotCondition)(THIS_ IUIAutomationCondition *, IUIAutomationCondition **) PURE;\n    STDMETHOD(AddAutomationEventHandler)(THIS_ EVENTID, IUIAutomationElement *, enum TreeScope, IUIAutomationCacheRequest *, IUIAutomationEventHandler *) PURE;\n    STDMETHOD(RemoveAutomationEventHandler)(THIS_ EVENTID, IUIAutomationElement *, IUIAutomationEventHandler *) PURE;\n    STDMETHOD(AddPropertyChangedEventHandlerNativeArray)(THIS_ IUIAutomationElement *, enum TreeScope, IUIAutomationCacheRequest *,\n                                                         IUIAutomationPropertyChangedEventHandler *, PROPERTYID *, int) PURE;\n    STDMETHOD(AddPropertyChangedEventHandler)(THIS_ IUIAutomationElement *, enum TreeScope, EVENTID, IUIAutomationCacheRequest *,\n                                              IUIAutomationPropertyChangedEventHandler *, SAFEARRAY *) PURE;\n    STDMETHOD(RemovePropertyChangedEventHandler)(THIS_ IUIAutomationElement *, IUIAutomationPropertyChangedEventHandler *) PURE;\n    STDMETHOD(AddStructureChangedEventHandler)(THIS_ IUIAutomationElement *, enum TreeScope, IUIAutomationCacheRequest *, IUIAutomationStructureChangedEventHandler *) PURE;\n    STDMETHOD(RemoveStructureChangedEventHandler)(THIS_ IUIAutomationElement *, IUIAutomationStructureChangedEventHandler *) PURE;\n    STDMETHOD(AddFocusChangedEventHandler)(THIS_ IUIAutomationCacheRequest *, IUIAutomationFocusChangedEventHandler *) PURE;\n    STDMETHOD(RemoveFocusChangedEventHandler)(THIS_ IUIAutomationFocusChangedEventHandler *) PURE;\n    STDMETHOD(RemoveAllEventHandlers)(THIS) PURE;\n    STDMETHOD(IntNativeArrayToSafeArray)(THIS_ int *, int, SAFEARRAY **) PURE;\n    STDMETHOD(IntSafeArrayToNativeArray)(THIS_ SAFEARRAY *, int **, int *) PURE;\n    STDMETHOD(RectToVariant)(THIS_ RECT, VARIANT *) PURE;\n    STDMETHOD(VariantToRect)(THIS_ VARIANT, RECT *) PURE;\n    STDMETHOD(SafeArrayToRectNativeArray)(THIS_ SAFEARRAY *, RECT **, int *) PURE;\n    STDMETHOD(CreateProxyFactoryEntry)(THIS_ IUIAutomationProxyFactory *, IUIAutomationProxyFactoryEntry **) PURE;\n    STDMETHOD(get_ProxyFactoryMapping)(THIS_ IUIAutomationProxyFactoryMapping **) PURE;\n    STDMETHOD(GetPropertyProgrammaticName)(THIS_ PROPERTYID, BSTR *) PURE;\n    STDMETHOD(GetPatternProgrammaticName)(THIS_ PATTERNID, BSTR *) PURE;\n    STDMETHOD(PollForPotentialSupportedPatterns)(THIS_ IUIAutomationElement *, SAFEARRAY **, SAFEARRAY **) PURE;\n    STDMETHOD(PollForPotentialSupportedProperties)(THIS_ IUIAutomationElement *, SAFEARRAY **, SAFEARRAY **) PURE;\n    STDMETHOD(CheckNotSupported)(THIS_ VARIANT, BOOL *) PURE;\n    STDMETHOD(get_ReservedNotSupportedValue)(THIS_ IUnknown **) PURE;\n    STDMETHOD(get_ReservedMixedAttributeValue)(THIS_ IUnknown **) PURE;\n    STDMETHOD(ElementFromIAccessible)(THIS_ IAccessible *, int, IUIAutomationElement **) PURE;\n    STDMETHOD(ElementFromIAccessibleBuildCache)(THIS_ IAccessible *, int, IUIAutomationCacheRequest *, IUIAutomationElement **) PURE;\n};\n#undef INTERFACE\n\n#define INTERFACE IUIAutomationElement\nDECLARE_INTERFACE_(IUIAutomationElement, IUnknown)\n{\n    STDMETHOD(SetFocus)(THIS) PURE;\n    STDMETHOD(GetRuntimeId)(THIS_ SAFEARRAY **) PURE;\n    STDMETHOD(FindFirst)(THIS_ enum TreeScope, IUIAutomationCondition *, IUIAutomationElement **) PURE;\n    STDMETHOD(FindAll)(THIS_ enum TreeScope, IUIAutomationCondition *, IUIAutomationElementArray **) PURE;\n    STDMETHOD(FindFirstBuildCache)(THIS_ enum TreeScope, IUIAutomationCondition *, IUIAutomationCacheRequest *, IUIAutomationElement **) PURE;\n    STDMETHOD(FindAllBuildCache)(THIS_ enum TreeScope, IUIAutomationCondition *, IUIAutomationCacheRequest *, IUIAutomationElementArray **) PURE;\n    STDMETHOD(BuildUpdatedCache)(THIS_ IUIAutomationCacheRequest *, IUIAutomationElement **) PURE;\n    STDMETHOD(GetCurrentPropertyValue)(THIS_ PROPERTYID, VARIANT *) PURE;\n    STDMETHOD(GetCurrentPropertyValueEx)(THIS_ PROPERTYID, BOOL, VARIANT *) PURE;\n    STDMETHOD(GetCachedPropertyValue)(THIS_ PROPERTYID, VARIANT *) PURE;\n    STDMETHOD(GetCachedPropertyValueEx)(THIS_ PROPERTYID, BOOL, VARIANT *) PURE;\n    STDMETHOD(GetCurrentPatternAs)(THIS_ PATTERNID, REFIID, void **) PURE;\n    STDMETHOD(GetCachedPatternAs)(THIS_ PATTERNID, REFIID, void **) PURE;\n    STDMETHOD(GetCurrentPattern)(THIS_ PATTERNID, IUnknown **) PURE;\n    STDMETHOD(GetCachedPattern)(THIS_ PATTERNID, IUnknown **) PURE;\n    STDMETHOD(GetCachedParent)(THIS_ IUIAutomationElement **) PURE;\n    STDMETHOD(GetCachedChildren)(THIS_ IUIAutomationElement **) PURE;\n    STDMETHOD(get_CurrentProcessId)(THIS_ int *) PURE;\n    STDMETHOD(get_CurrentControlType)(THIS_ CONTROLTYPEID *) PURE;\n    STDMETHOD(get_CurrentLocalizedControlType)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CurrentName)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CurrentAcceleratorKey)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CurrentAccessKey)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CurrentHasKeyboardFocus)(THIS_ BOOL *) PURE;\n    STDMETHOD(get_CurrentIsKeyboardFocusable)(THIS_ BOOL *) PURE;\n    STDMETHOD(get_CurrentIsEnabled)(THIS_ BOOL *) PURE;\n    STDMETHOD(get_CurrentAutomationId)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CurrentClassName)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CurrentHelpText)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CurrentCulture)(THIS_ int *) PURE;\n    STDMETHOD(get_CurrentIsControlElement)(THIS_ BOOL *) PURE;\n    STDMETHOD(get_CurrentIsContentElement)(THIS_ BOOL *) PURE;\n    STDMETHOD(get_CurrentIsPassword)(THIS_ BOOL *) PURE;\n    STDMETHOD(get_CurrentNativeWindowHandle)(THIS_ UIA_HWND *) PURE;\n    STDMETHOD(get_CurrentItemType)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CurrentIsOffscreen)(THIS_ BOOL *) PURE;\n    STDMETHOD(get_CurrentOrientation)(THIS_ enum OrientationType *) PURE;\n    STDMETHOD(get_CurrentFrameworkId)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CurrentIsRequiredForForm)(THIS_ BOOL *) PURE;\n    STDMETHOD(get_CurrentItemStatus)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CurrentBoundingRectangle)(THIS_ RECT *) PURE;\n    STDMETHOD(get_CurrentLabeledBy)(THIS_ IUIAutomationElement **) PURE;\n    STDMETHOD(get_CurrentAriaRole)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CurrentAriaProperties)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CurrentIsDataValidForForm)(THIS_ BOOL *) PURE;\n    STDMETHOD(get_CurrentControllerFor)(THIS_ IUIAutomationElementArray **) PURE;\n    STDMETHOD(get_CurrentDescribedBy)(THIS_ IUIAutomationElementArray **) PURE;\n    STDMETHOD(get_CurrentFlowsTo)(THIS_ IUIAutomationElementArray **) PURE;\n    STDMETHOD(get_CurrentProviderDescription)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CachedProcessId)(THIS_ int *) PURE;\n    STDMETHOD(get_CachedControlType)(THIS_ CONTROLTYPEID *) PURE;\n    STDMETHOD(get_CachedLocalizedControlType)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CachedName)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CachedAcceleratorKey)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CachedAccessKey)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CachedHasKeyboardFocus)(THIS_ BOOL *) PURE;\n    STDMETHOD(get_CachedIsKeyboardFocusable)(THIS_ BOOL *) PURE;\n    STDMETHOD(get_CachedIsEnabled)(THIS_ BOOL *) PURE;\n    STDMETHOD(get_CachedAutomationId)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CachedClassName)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CachedHelpText)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CachedCulture)(THIS_ int *) PURE;\n    STDMETHOD(get_CachedIsControlElement)(THIS_ BOOL *) PURE;\n    STDMETHOD(get_CachedIsContentElement)(THIS_ BOOL *) PURE;\n    STDMETHOD(get_CachedIsPassword)(THIS_ BOOL *) PURE;\n    STDMETHOD(get_CachedNativeWindowHandle)(THIS_ UIA_HWND *) PURE;\n    STDMETHOD(get_CachedItemType)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CachedIsOffscreen)(THIS_ BOOL *) PURE;\n    STDMETHOD(get_CachedOrientation)(THIS_ enum OrientationType *) PURE;\n    STDMETHOD(get_CachedFrameworkId)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CachedIsRequiredForForm)(THIS_ BOOL *) PURE;\n    STDMETHOD(get_CachedItemStatus)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CachedBoundingRectangle)(THIS_ RECT *) PURE;\n    STDMETHOD(get_CachedLabeledBy)(THIS_ IUIAutomationElement **) PURE;\n    STDMETHOD(get_CachedAriaRole)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CachedAriaProperties)(THIS_ BSTR *) PURE;\n    STDMETHOD(get_CachedIsDataValidForForm)(THIS_ BOOL *) PURE;\n    STDMETHOD(get_CachedControllerFor)(THIS_ IUIAutomationElementArray **) PURE;\n    STDMETHOD(get_CachedDescribedBy)(THIS_ IUIAutomationElementArray **) PURE;\n    STDMETHOD(get_CachedFlowsTo)(THIS_ IUIAutomationElementArray **) PURE;\n    STDMETHOD(get_CachedProviderDescription)(THIS_ BSTR *) PURE;\n};\n#undef INTERFACE\n\n#define INTERFACE IUIAutomationTextPattern\nDECLARE_INTERFACE_(IUIAutomationTextPattern, IUnknown)\n{\n    STDMETHOD(RangeFromPoint)(THIS_ POINT, IUIAutomationTextRange **) PURE;\n    STDMETHOD(RangeFromChild)(THIS_ IUIAutomationElement *, IUIAutomationTextRange **) PURE;\n    STDMETHOD(GetSelection)(THIS_ IUIAutomationTextRangeArray **) PURE;\n    STDMETHOD(GetVisibleRanges)(THIS_ IUIAutomationTextRangeArray **) PURE;\n    STDMETHOD(get_DocumentRange)(THIS_ IUIAutomationTextRange **) PURE;\n    STDMETHOD(get_SupportedTextSelection)(THIS_ enum SupportedTextSelection *) PURE;\n};\n#undef INTERFACE\n\n#define INTERFACE IUIAutomationTreeWalker\nDECLARE_INTERFACE_(IUIAutomationTreeWalker, IUnknown)\n{\n    STDMETHOD(GetParentElement)(THIS_ IUIAutomationElement *, IUIAutomationElement **) PURE;\n    STDMETHOD(GetFirstChildElement)(THIS_ IUIAutomationElement *, IUIAutomationElement **) PURE;\n    STDMETHOD(GetLastChildElement)(THIS_ IUIAutomationElement *, IUIAutomationElement **) PURE;\n    STDMETHOD(GetNextSiblingElement)(THIS_ IUIAutomationElement *, IUIAutomationElement **) PURE;\n    STDMETHOD(GetPreviousSiblingElement)(THIS_ IUIAutomationElement *, IUIAutomationElement **) PURE;\n    STDMETHOD(NormalizeElement)(THIS_ IUIAutomationElement *, IUIAutomationElement **) PURE;\n    STDMETHOD(GetParentElementBuildCache)(THIS_ IUIAutomationElement *, IUIAutomationCacheRequest *, IUIAutomationElement **) PURE;\n    STDMETHOD(GetFirstChildElementBuildCache)(THIS_ IUIAutomationElement *, IUIAutomationCacheRequest *, IUIAutomationElement **) PURE;\n    STDMETHOD(GetLastChildElementBuildCache)(THIS_ IUIAutomationElement *, IUIAutomationCacheRequest *, IUIAutomationElement **) PURE;\n    STDMETHOD(GetNextSiblingElementBuildCache)(THIS_ IUIAutomationElement *, IUIAutomationCacheRequest *, IUIAutomationElement **) PURE;\n    STDMETHOD(GetPreviousSiblingElementBuildCache)(THIS_ IUIAutomationElement *, IUIAutomationCacheRequest *, IUIAutomationElement **) PURE;\n    STDMETHOD(NormalizeElementBuildCache)(THIS_ IUIAutomationElement *, IUIAutomationCacheRequest *, IUIAutomationElement **) PURE;\n    STDMETHOD(get_Condition)(THIS_ IUIAutomationCondition **) PURE;\n};\n#undef INTERFACE\n\n#define INTERFACE IUIAutomationTextRange\nDECLARE_INTERFACE_(IUIAutomationTextRange, IUnknown)\n{\n    STDMETHOD(Clone)(THIS_ IUIAutomationTextRange **) PURE;\n    STDMETHOD(Compare)(THIS_ IUIAutomationTextRange *, BOOL *) PURE;\n    STDMETHOD(CompareEndpoints)(THIS_ enum TextPatternRangeEndpoint, IUIAutomationTextRange *, enum TextPatternRangeEndpoint, int *) PURE;\n    STDMETHOD(ExpandToEnclosingUnit)(THIS_ enum TextUnit) PURE;\n    STDMETHOD(FindAttribute)(THIS_ TEXTATTRIBUTEID, VARIANT, BOOL, IUIAutomationTextRange **) PURE;\n    STDMETHOD(FindText)(THIS_ BSTR, BOOL, BOOL, IUIAutomationTextRange **) PURE;\n    STDMETHOD(GetAttributeValue)(THIS_ TEXTATTRIBUTEID, VARIANT *) PURE;\n    STDMETHOD(GetBoundingRectangles)(THIS_ SAFEARRAY **) PURE;\n    STDMETHOD(GetEnclosingElement)(THIS_ IUIAutomationElement **) PURE;\n    STDMETHOD(GetText)(THIS_ int, BSTR *) PURE;\n    STDMETHOD(Move)(THIS_ enum TextUnit, int, int *) PURE;\n    STDMETHOD(MoveEndpointByUnit)(THIS_ enum TextPatternRangeEndpoint, enum TextUnit, int *) PURE;\n    STDMETHOD(MoveEndpointByRange)(THIS_ enum TextPatternRangeEndpoint, IUIAutomationTextRange *, enum TextPatternRangeEndpoint) PURE;\n    STDMETHOD(Select)(THIS) PURE;\n    STDMETHOD(AddToSelection)(THIS) PURE;\n    STDMETHOD(RemoveFromSelection)(THIS) PURE;\n    STDMETHOD(ScrollIntoView)(THIS_ BOOL) PURE;\n    STDMETHOD(GetChildren)(THIS_ IUIAutomationElementArray **) PURE;\n};\n#undef INTERFACE\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // UIAUTO_HH\n"
        },
        {
          "name": "utf8.cc",
          "type": "blob",
          "size": 3.51171875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"utf8.hh\"\n#include <vector>\n\nnamespace Utf8 {\n\nsize_t encode( wchar const * in, size_t inSize, char * out_ )\n{\n  unsigned char * out = (unsigned char *) out_;\n\n  while( inSize-- )\n  {\n    if ( *in < 0x80 )\n      *out++ = *in++;\n    else\n    if ( *in < 0x800 )\n    {\n      *out++ = 0xC0 | ( *in >> 6 );\n      *out++ = 0x80 | ( *in++ & 0x3F );\n    }\n    else\n    if ( *in < 0x10000 )\n    {\n      *out++ = 0xE0 | ( *in >> 12 );\n      *out++ = 0x80 | ( ( *in >> 6 ) & 0x3F );\n      *out++ = 0x80 | ( *in++ & 0x3F );\n    }\n    else\n    {\n      *out++ = 0xF0 | ( *in >> 18 );\n      *out++ = 0x80 | ( ( *in >> 12 ) & 0x3F );\n      *out++ = 0x80 | ( ( *in >> 6 ) & 0x3F );\n      *out++ = 0x80 | ( *in++ & 0x3F );\n    }\n  }\n\n  return out - (unsigned char *) out_;\n}\n\nlong decode( char const * in_, size_t inSize, wchar * out_ )\n{\n  unsigned char const * in = (unsigned char const *) in_;\n  wchar * out = out_;\n\n  while( inSize-- )\n  {\n    wchar result;\n\n    if ( *in & 0x80 )\n    {\n      if ( *in & 0x40 )\n      {\n        if ( *in & 0x20 )\n        {\n          if ( *in & 0x10 )\n          {\n            // Four-byte sequence\n            if ( *in & 8 )\n              // This can't be\n              return -1;\n\n            if ( inSize < 3 )\n              return -1;\n\n            inSize -= 3;\n\n            result = ( (wchar )*in++ & 7 ) << 18;\n\n            if ( ( *in & 0xC0 ) != 0x80 )\n              return -1;\n            result |= ( (wchar)*in++ & 0x3F ) << 12;\n\n            if ( ( *in & 0xC0 ) != 0x80 )\n              return -1;\n            result |= ( (wchar)*in++ & 0x3F ) << 6;\n\n            if ( ( *in & 0xC0 ) != 0x80 )\n              return -1;\n            result |= (wchar)*in++ & 0x3F;\n          }\n          else\n          {\n            // Three-byte sequence\n\n            if ( inSize < 2 )\n              return -1;\n\n            inSize -= 2;\n\n            result = ( (wchar )*in++ & 0xF ) << 12;\n\n            if ( ( *in & 0xC0 ) != 0x80 )\n              return -1;\n            result |= ( (wchar)*in++ & 0x3F ) << 6;\n\n            if ( ( *in & 0xC0 ) != 0x80 )\n              return -1;\n            result |= (wchar)*in++ & 0x3F;\n          }\n        }\n        else\n        {\n          // Two-byte sequence\n          if ( !inSize )\n            return -1;\n\n          --inSize;\n\n          result = ( (wchar )*in++ & 0x1F ) << 6;\n\n          if ( ( *in & 0xC0 ) != 0x80 )\n            return -1;\n          result |= (wchar)*in++ & 0x3F;\n        }\n      }\n      else\n      {\n        // This char is from the middle of encoding, it can't be leading\n        return -1;\n      }\n    }\n    else\n      // One-byte encoding\n      result = *in++;\n\n    *out++ = result;\n  }\n\n  return out - out_;\n}\n\nstring encode( wstring const & in ) throw()\n{\n  if( in.size() == 0 )\n    return string();\n\n  std::vector< char > buffer( in.size() * 4 );\n\n  return string( &buffer.front(),\n                 encode( in.data(), in.size(), &buffer.front() ) );\n}\n\nwstring decode( string const & in ) THROW_SPEC( exCantDecode )\n{\n  \n  if ( in.size() == 0 )\n    return wstring();\n\n  std::vector< wchar > buffer( in.size() );\n\n  long result = decode( in.data(),  in.size(), &buffer.front() );\n\n  if ( result < 0 )\n    throw exCantDecode( in );\n\n  return wstring( &buffer.front(), result );\n}\n\nbool isspace( int c )\n{\n  switch( c )\n  {\n    case ' ':\n    case '\\f':\n    case '\\n':\n    case '\\r':\n    case '\\t':\n    case '\\v':\n      return true;\n\n    default:\n      return false;\n  }\n}\n\n}\n"
        },
        {
          "name": "utf8.hh",
          "type": "blob",
          "size": 1.7578125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include <cstdio>\n#include <string>\n#include \"cpp_features.hh\"\n#include \"ex.hh\"\n#include \"wstring.hh\"\n\n/// A simple UTF-8 encoder/decoder. Some dictionary backends only require\n/// utf8, so we have this separately, removing the iconv dependency for them.\n/// Besides, utf8 is quite ubiquitous now, and its use is spreaded over many\n/// places.\nnamespace Utf8 {\n\nusing std::string;\nusing gd::wstring;\nusing gd::wchar;\n\nDEF_EX_STR( exCantDecode, \"Can't decode the given string from Utf8:\", std::exception )\n\n/// Encodes the given UCS-4 into UTF-8. The inSize specifies the number\n/// of wide characters the 'in' pointer points to. The 'out' buffer must be\n/// at least inSize * 4 bytes long. The function returns the number of chars\n/// stored in the 'out' buffer. The result is not 0-terminated.\nsize_t encode( wchar const * in, size_t inSize, char * out );\n/// Decodes the given UTF-8 into UCS-32. The inSize specifies the number\n/// of bytes the 'in' pointer points to. The 'out' buffer must be at least\n/// inSize wide characters long. If the given UTF-8 is invalid, the decode\n/// function returns -1, otherwise it returns the number of wide characters\n/// stored in the 'out' buffer. The result is not 0-terminated.\nlong decode( char const * in, size_t inSize, wchar * out );\n\n/// Versions for non time-critical code.\nstring encode( wstring const & ) throw();\nwstring decode( string const & ) THROW_SPEC( exCantDecode );\n\n/// Since the standard isspace() is locale-specific, we need something\n/// that would never mess up our utf8 input. The stock one worked fine under\n/// Linux but was messing up strings under Windows.\nbool isspace( int c );\n\n}\n"
        },
        {
          "name": "voiceengines.cc",
          "type": "blob",
          "size": 3.998046875,
          "content": "/* This file is (c) 2013 Timon Wong <timon86.wang@gmail.com>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"voiceengines.hh\"\n#include \"audiolink.hh\"\n#include \"htmlescape.hh\"\n#include \"utf8.hh\"\n#include \"wstring_qt.hh\"\n\n#include <string>\n#include <map>\n\n#include <QDir>\n#include <QFileInfo>\n#include <QCryptographicHash>\n\n#include \"qt4x5.hh\"\n\nnamespace VoiceEngines\n{\n\nusing namespace Dictionary;\nusing std::string;\nusing std::map;\n\ninline string toMd5( QByteArray const & b )\n{\n  return string( QCryptographicHash::hash( b, QCryptographicHash::Md5 ).toHex().constData() );\n}\n\nclass VoiceEnginesDictionary: public Dictionary::Class\n{\nprivate:\n\n  Config::VoiceEngine voiceEngine;\n\npublic:\n\n  VoiceEnginesDictionary( Config::VoiceEngine const & voiceEngine ):\n    Dictionary::Class(\n      toMd5( voiceEngine.id.toUtf8() ),\n      vector< string >() ),\n    voiceEngine( voiceEngine )\n  {\n  }\n\n  virtual string getName() throw()\n  { return voiceEngine.name.toUtf8().data(); }\n\n  virtual map< Property, string > getProperties() throw()\n  { return map< Property, string >(); }\n\n  virtual unsigned long getArticleCount() throw()\n  { return 0; }\n\n  virtual unsigned long getWordCount() throw()\n  { return 0; }\n\n  virtual sptr< WordSearchRequest > prefixMatch( wstring const & word,\n                                                 unsigned long maxResults )\n    THROW_SPEC( std::exception );\n\n  virtual sptr< DataRequest > getArticle( wstring const &,\n                                          vector< wstring > const & alts,\n                                          wstring const &, bool )\n    THROW_SPEC( std::exception );\n\nprotected:\n\n  virtual void loadIcon() throw();\n};\n\nsptr< WordSearchRequest > VoiceEnginesDictionary::prefixMatch( wstring const & /*word*/,\n                                                               unsigned long /*maxResults*/ )\n  THROW_SPEC( std::exception )\n{\n  WordSearchRequestInstant * sr = new WordSearchRequestInstant();\n  sr->setUncertain( true );\n  return sr;\n}\n\nsptr< Dictionary::DataRequest > VoiceEnginesDictionary::getArticle(\n  wstring const & word, vector< wstring > const &, wstring const &, bool )\n  THROW_SPEC( std::exception )\n{\n  string result;\n  string wordUtf8( Utf8::encode( word ) );\n\n  result += \"<table class=\\\"voiceengines_play\\\"><tr>\";\n\n  QUrl url;\n  url.setScheme( \"gdtts\" );\n  url.setHost( \"localhost\" );\n  url.setPath( Qt4x5::Url::ensureLeadingSlash( QString::fromUtf8( wordUtf8.c_str() ) ) );\n  QList< QPair<QString, QString> > query;\n  query.push_back( QPair<QString, QString>( \"engine\", QString::fromStdString( getId() ) ) );\n  Qt4x5::Url::setQueryItems( url, query );\n\n  string encodedUrl = url.toEncoded().data();\n  string ref = string( \"\\\"\" ) + encodedUrl + \"\\\"\";\n  result += addAudioLink( ref, getId() );\n\n  result += \"<td><a href=\" + ref + \"><img src=\\\"qrcx://localhost/icons/playsound.png\\\" border=\\\"0\\\" alt=\\\"Play\\\"/></a></td>\";\n  result += \"<td><a href=\" + ref + \">\" + Html::escape( wordUtf8 ) + \"</a></td>\";\n  result += \"</tr></table>\";\n\n  sptr< DataRequestInstant > ret = new DataRequestInstant( true );\n  ret->getData().resize( result.size() );\n  memcpy( &( ret->getData().front() ), result.data(), result.size() );\n  return ret;\n}\n\nvoid VoiceEnginesDictionary::loadIcon() throw()\n{\n  if ( dictionaryIconLoaded )\n    return;\n\n  if ( !voiceEngine.iconFilename.isEmpty() )\n  {\n    QFileInfo fInfo(  QDir( Config::getConfigDir() ), voiceEngine.iconFilename );\n    if ( fInfo.isFile() )\n      loadIconFromFile( fInfo.absoluteFilePath(), true );\n  }\n  if ( dictionaryIcon.isNull() )\n    dictionaryIcon = dictionaryNativeIcon = QIcon( \":/icons/playsound.png\" );\n  dictionaryIconLoaded = true;\n}\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n  Config::VoiceEngines const & voiceEngines )\n  THROW_SPEC( std::exception )\n{\n  vector< sptr< Dictionary::Class > > result;\n\n  for ( Config::VoiceEngines::const_iterator i = voiceEngines.begin(); i != voiceEngines.end(); ++i )\n  {\n    if ( i->enabled )\n      result.push_back( new VoiceEnginesDictionary( *i ) );\n  }\n\n  return result;\n}\n\n}\n"
        },
        {
          "name": "voiceengines.hh",
          "type": "blob",
          "size": 0.5263671875,
          "content": "/* This file is (c) 2013 Timon Wong <timon86.wang@gmail.com>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __VOICEENGINES_HH_INCLUDED__\n#define __VOICEENGINES_HH_INCLUDED__\n\n#include \"dictionary.hh\"\n#include \"config.hh\"\n#include \"wstring.hh\"\n\n#include <QCryptographicHash>\n\n\nnamespace VoiceEngines {\n\nusing std::vector;\nusing std::string;\nusing gd::wstring;\n\nvector< sptr< Dictionary::Class > > makeDictionaries(Config::VoiceEngines const & voiceEngines)\n  THROW_SPEC( std::exception );\n\n}\n\n#endif\n"
        },
        {
          "name": "webmultimediadownload.cc",
          "type": "blob",
          "size": 2.0751953125,
          "content": "#include \"webmultimediadownload.hh\"\n#include \"filetype.hh\"\n\nnamespace Dictionary {\n\n#define MAX_REDIRECTS 10\n\nWebMultimediaDownload::WebMultimediaDownload( QUrl const & url,\n                                              QNetworkAccessManager & _mgr ) :\nmgr( _mgr ),\nredirectCount( 0 )\n{\n  connect( &mgr, SIGNAL(finished(QNetworkReply*)),\n           this, SLOT(replyFinished(QNetworkReply*)), Qt::QueuedConnection );\n\n  reply = mgr.get( QNetworkRequest( url ) );\n\n#ifndef QT_NO_OPENSSL\n  connect( reply, SIGNAL( sslErrors( QList< QSslError > ) ),\n           reply, SLOT( ignoreSslErrors() ) );\n#endif\n}\n\nvoid WebMultimediaDownload::cancel()\n{\n  reply = NULL;\n\n  finish();\n}\n\nvoid WebMultimediaDownload::replyFinished( QNetworkReply * r )\n{\n  if ( !r || r != reply )\n    return; // Not our reply\n\n  if ( r->error() == QNetworkReply::NoError )\n  {\n    // Check for redirect reply\n\n    QVariant possibleRedirectUrl = reply->attribute( QNetworkRequest::RedirectionTargetAttribute );\n    QUrl redirectUrl = possibleRedirectUrl.toUrl();\n    if( !redirectUrl.isEmpty() )\n    {\n      disconnect( reply, 0, 0, 0 );\n      reply->deleteLater();\n\n      if( ++redirectCount > MAX_REDIRECTS )\n      {\n        setErrorString( \"Too many redirects detected\" );\n        finish();\n        return;\n      }\n\n      reply = mgr.get( QNetworkRequest( redirectUrl ) );\n#ifndef QT_NO_OPENSSL\n      connect( reply, SIGNAL( sslErrors( QList< QSslError > ) ),\n               reply, SLOT( ignoreSslErrors() ) );\n#endif\n      return;\n    }\n\n    // Handle reply data\n\n    Mutex::Lock _( dataMutex );\n\n    data.resize( r->bytesAvailable() );\n\n    r->read( data.data(), data.size() );\n\n    hasAnyData = true;\n  }\n  else\n    setErrorString( r->errorString() );\n\n  disconnect( r, 0, 0, 0 );\n  r->deleteLater();\n  reply = NULL;\n\n  finish();\n}\n\nbool WebMultimediaDownload::isAudioUrl( QUrl const & url )\n{\n  // Note: we check for forvo sound links explicitly, as they don't have extensions\n\n  return ( url.scheme() == \"http\" || url.scheme() == \"https\" ) && (\n      Filetype::isNameOfSound( url.path().toUtf8().data() ) || url.host() == \"apifree.forvo.com\" );\n}\n\n}\n"
        },
        {
          "name": "webmultimediadownload.hh",
          "type": "blob",
          "size": 0.7177734375,
          "content": "#ifndef WEBMULTIMEDIADOWNLOAD_HH\n#define WEBMULTIMEDIADOWNLOAD_HH\n\n#include \"dictionary.hh\"\n#include <QtNetwork>\n\nnamespace Dictionary {\n\n/// Downloads data from the web, wrapped as a dictionary's DataRequest. This\n/// is useful for multimedia files, like sounds and pronunciations.\nclass WebMultimediaDownload: public DataRequest\n{\n  Q_OBJECT\n\n  QNetworkReply * reply;\n  QNetworkAccessManager & mgr;\n  int redirectCount;\n\npublic:\n\n  WebMultimediaDownload( QUrl const &, QNetworkAccessManager & );\n\n  /// Checks if the given url is an http request for an audio file.\n  static bool isAudioUrl( QUrl const & );\n\n  virtual void cancel();\n\nprivate slots:\n\n  void replyFinished( QNetworkReply * );\n};\n\n}\n\n#endif // WEBMULTIMEDIADOWNLOAD_HH\n"
        },
        {
          "name": "website.cc",
          "type": "blob",
          "size": 19.4111328125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"website.hh\"\n#include \"wstring_qt.hh\"\n#include \"utf8.hh\"\n#include <QUrl>\n#include <QTextCodec>\n#include <QDir>\n#include <QFileInfo>\n#include \"gddebug.hh\"\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n#include <QRegularExpression>\n#else\n#include <QRegExp>\n#endif\n\nnamespace WebSite {\n\nusing namespace Dictionary;\n\nnamespace {\n\nclass WebSiteDictionary: public Dictionary::Class\n{\n  string name;\n  QByteArray urlTemplate;\n  QString iconFilename;\n  bool inside_iframe;\n  QNetworkAccessManager & netMgr;\n\npublic:\n\n  WebSiteDictionary( string const & id, string const & name_,\n                     QString const & urlTemplate_,\n                     QString const & iconFilename_,\n                     bool inside_iframe_,\n                     QNetworkAccessManager & netMgr_ ):\n    Dictionary::Class( id, vector< string >() ),\n    name( name_ ),\n    urlTemplate( QUrl( urlTemplate_ ).toEncoded() ),\n    iconFilename( iconFilename_ ),\n    inside_iframe( inside_iframe_ ),\n    netMgr( netMgr_ )\n  {\n    dictionaryDescription = urlTemplate_;\n  }\n\n  virtual string getName() throw()\n  { return name; }\n\n  virtual map< Property, string > getProperties() throw()\n  { return map< Property, string >(); }\n\n  virtual unsigned long getArticleCount() throw()\n  { return 0; }\n\n  virtual unsigned long getWordCount() throw()\n  { return 0; }\n\n  virtual sptr< WordSearchRequest > prefixMatch( wstring const & word,\n                                                 unsigned long ) THROW_SPEC( std::exception );\n\n  virtual sptr< DataRequest > getArticle( wstring const &,\n                                          vector< wstring > const & alts,\n                                          wstring const & context, bool )\n    THROW_SPEC( std::exception );\n\n  virtual sptr< Dictionary::DataRequest > getResource( string const & name ) THROW_SPEC( std::exception );\n\n  void isolateWebCSS( QString & css );\n\nprotected:\n\n  virtual void loadIcon() throw();\n};\n\nsptr< WordSearchRequest > WebSiteDictionary::prefixMatch( wstring const & /*word*/,\n                                                          unsigned long ) THROW_SPEC( std::exception )\n{\n  sptr< WordSearchRequestInstant > sr = new WordSearchRequestInstant;\n\n  sr->setUncertain( true );\n\n  return sr;\n}\n\nvoid WebSiteDictionary::isolateWebCSS( QString & css )\n{\n  isolateCSS( css, \".website\" );\n}\n\nclass WebSiteArticleRequest: public WebSiteDataRequestSlots\n{\n  QNetworkReply * netReply;\n  QString url;\n  Class * dictPtr;\n  QNetworkAccessManager & mgr;\n\npublic:\n\n  WebSiteArticleRequest( QString const & url, QNetworkAccessManager & _mgr,\n                         Class * dictPtr_ );\n  ~WebSiteArticleRequest()\n  {}\n\n  virtual void cancel();\n\nprivate:\n\n  virtual void requestFinished( QNetworkReply * );\n  static QTextCodec * codecForHtml( QByteArray const & ba );\n};\n\nvoid WebSiteArticleRequest::cancel()\n{\n  finish();\n}\n\nWebSiteArticleRequest::WebSiteArticleRequest( QString const & url_,\n                                              QNetworkAccessManager & _mgr,\n                                              Class * dictPtr_ ):\n  url( url_ ), dictPtr( dictPtr_ ), mgr( _mgr )\n{\n  connect( &mgr, SIGNAL( finished( QNetworkReply * ) ),\n           this, SLOT( requestFinished( QNetworkReply * ) ),\n           Qt::QueuedConnection );\n\n  QUrl reqUrl( url );\n\n  netReply = mgr.get( QNetworkRequest( reqUrl ) );\n\n#ifndef QT_NO_OPENSSL\n  connect( netReply, SIGNAL( sslErrors( QList< QSslError > ) ),\n           netReply, SLOT( ignoreSslErrors() ) );\n#endif\n}\n\nQTextCodec * WebSiteArticleRequest::codecForHtml( QByteArray const & ba )\n{\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  return QTextCodec::codecForHtml( ba, 0 );\n#else\n// Implementation taken from Qt 5 sources\n// Function from Qt 4 can't recognize charset name inside single quotes\n\n  QByteArray header = ba.left( 1024 ).toLower();\n  int pos = header.indexOf( \"meta \" );\n  if (pos != -1) {\n    pos = header.indexOf( \"charset=\", pos );\n    if (pos != -1) {\n      pos += qstrlen( \"charset=\" );\n\n      int pos2 = pos;\n      while ( ++pos2 < header.size() )\n      {\n        char ch = header.at( pos2 );\n        if( ch != '\\\"' && ch != '\\'' && ch != ' ' )\n          break;\n      }\n\n      // The attribute can be closed with either \"\"\", \"'\", \">\" or \"/\",\n      // none of which are valid charset characters.\n\n      while ( pos2++ < header.size() )\n      {\n        char ch = header.at( pos2 );\n        if( ch == '\\\"' || ch == '\\'' || ch == '>' || ch == '/' )\n        {\n          QByteArray name = header.mid( pos, pos2 - pos );\n          if ( name == \"unicode\" )\n            name = QByteArray( \"UTF-8\" );\n\n          return QTextCodec::codecForName(name);\n        }\n      }\n    }\n  }\n  return 0;\n#endif\n}\n\nvoid WebSiteArticleRequest::requestFinished( QNetworkReply * r )\n{\n  if ( isFinished() ) // Was cancelled\n    return;\n\n  if ( r != netReply )\n  {\n    // Well, that's not our reply, don't do anything\n    return;\n  }\n\n  if ( netReply->error() == QNetworkReply::NoError )\n  {\n    // Check for redirect reply\n\n    QVariant possibleRedirectUrl = netReply->attribute( QNetworkRequest::RedirectionTargetAttribute );\n    QUrl redirectUrl = possibleRedirectUrl.toUrl();\n    if( !redirectUrl.isEmpty() )\n    {\n      QUrl newUrl = netReply->url().resolved( redirectUrl );\n      disconnect( netReply, 0, 0, 0 );\n      netReply->deleteLater();\n      netReply = mgr.get( QNetworkRequest( newUrl ) );\n#ifndef QT_NO_OPENSSL\n      connect( netReply, SIGNAL( sslErrors( QList< QSslError > ) ),\n               netReply, SLOT( ignoreSslErrors() ) );\n#endif\n      return;\n    }\n\n    // Handle reply data\n\n    QByteArray replyData = netReply->readAll();\n    QString articleString;\n\n    QTextCodec * codec = WebSiteArticleRequest::codecForHtml( replyData );\n    if( codec )\n      articleString = codec->toUnicode( replyData );\n    else\n      articleString = QString::fromUtf8( replyData );\n\n    // Change links from relative to absolute\n\n    QString root = netReply->url().scheme() + \"://\" + netReply->url().host();\n    QString base = root + netReply->url().path();\n    while( !base.isEmpty() && !base.endsWith( \"/\" ) )\n      base.chop( 1 );\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n    QRegularExpression tags( \"<\\\\s*(a|link|img|script)\\\\s+[^>]*(src|href)\\\\s*=\\\\s*['\\\"][^>]+>\",\n                             QRegularExpression::CaseInsensitiveOption );\n    QRegularExpression links( \"\\\\b(src|href)\\\\s*=\\\\s*(['\\\"])([^'\\\"]+['\\\"])\",\n                              QRegularExpression::CaseInsensitiveOption );\n    int pos = 0;\n    QString articleNewString;\n    QRegularExpressionMatchIterator it = tags.globalMatch( articleString );\n    while( it.hasNext() )\n    {\n      QRegularExpressionMatch match = it.next();\n      articleNewString += articleString.midRef( pos, match.capturedStart() - pos );\n      pos = match.capturedEnd();\n\n      QString tag = match.captured();\n\n      QRegularExpressionMatch match_links = links.match( tag );\n      if( !match_links.hasMatch() )\n      {\n        articleNewString += tag;\n        continue;\n      }\n\n      QString url = match_links.captured( 3 );\n\n      if( url.indexOf( \":/\" ) >= 0 || url.indexOf( \"data:\" ) >= 0\n          || url.indexOf( \"mailto:\" ) >= 0 || url.startsWith( \"#\" )\n          || url.startsWith( \"javascript:\" ) )\n      {\n        // External link, anchor or base64-encoded data\n        articleNewString += tag;\n        continue;\n      }\n\n      QString newUrl = match_links.captured( 1 ) + \"=\" + match_links.captured( 2 );\n      if( url.startsWith( \"//\" ) )\n        newUrl += netReply->url().scheme() + \":\";\n      else\n      if( url.startsWith( \"/\" ) )\n        newUrl += root;\n      else\n        newUrl += base;\n      newUrl += match_links.captured( 3 );\n\n      tag.replace( match_links.capturedStart(), match_links.capturedLength(), newUrl );\n      articleNewString += tag;\n    }\n    if( pos )\n    {\n      articleNewString += articleString.midRef( pos );\n      articleString = articleNewString;\n      articleNewString.clear();\n    }\n\n    // Redirect CSS links to own handler\n\n    QString prefix = QString( \"bres://\" ) + dictPtr->getId().c_str() + \"/\";\n    QRegularExpression linkTags( \"(<\\\\s*link\\\\s[^>]*rel\\\\s*=\\\\s*['\\\"]stylesheet['\\\"]\\\\s+[^>]*href\\\\s*=\\\\s*['\\\"])([^'\\\"]+)://([^'\\\"]+['\\\"][^>]+>)\",\n                                 QRegularExpression::CaseInsensitiveOption );\n    pos = 0;\n    it = linkTags.globalMatch( articleString );\n    while( it.hasNext() )\n    {\n      QRegularExpressionMatch match = it.next();\n      articleNewString += articleString.midRef( pos, match.capturedStart() - pos );\n      pos = match.capturedEnd();\n\n      QString newTag = match.captured( 1 ) + prefix + match.captured( 2 )\n                       + \"/\" + match.captured( 3 );\n      articleNewString += newTag;\n    }\n    if( pos )\n    {\n      articleNewString += articleString.midRef( pos );\n      articleString = articleNewString;\n      articleNewString.clear();\n    }\n#else\n    QRegExp tags( \"<\\\\s*(a|link|img|script)\\\\s+[^>]*(src|href)\\\\s*=\\\\s*['\\\"][^>]+>\",\n                  Qt::CaseInsensitive, QRegExp::RegExp2 );\n    QRegExp links( \"\\\\b(src|href)\\\\s*=\\\\s*(['\\\"])([^'\\\"]+['\\\"])\",\n                   Qt::CaseInsensitive, QRegExp::RegExp2 );\n    int pos = 0;\n    while( pos >= 0 )\n    {\n      pos = articleString.indexOf( tags, pos );\n      if( pos < 0 )\n        break;\n\n      QString tag = tags.cap();\n\n      int linkPos = tag.indexOf( links );\n      if( linkPos < 0 )\n      {\n        pos += tag.size();\n        continue;\n      }\n\n      QString url = links.cap( 3 );\n\n      if( url.indexOf( \":/\" ) >= 0 || url.indexOf( \"data:\" ) >= 0\n          || url.indexOf( \"mailto:\" ) >= 0 || url.startsWith( \"#\" )\n          || url.startsWith( \"javascript:\" ) )\n      {\n        // External link, anchor or base64-encoded data\n        pos += tag.size();\n        continue;\n      }\n\n      QString newUrl = links.cap( 1 ) + \"=\" + links.cap( 2 );\n      if( url.startsWith( \"//\" ) )\n        newUrl += netReply->url().scheme() + \":\";\n      else\n      if( url.startsWith( \"/\" ) )\n        newUrl += root;\n      else\n        newUrl += base;\n      newUrl += links.cap( 3 );\n\n      tag.replace( linkPos, links.cap().size(), newUrl );\n      articleString.replace( pos, tags.cap().size(), tag );\n\n      pos += tag.size();\n    }\n\n    // Redirect CSS links to own handler\n\n    QString prefix = QString( \"bres://\" ) + dictPtr->getId().c_str() + \"/\";\n    QRegExp linkTags( \"(<\\\\s*link\\\\s[^>]*rel\\\\s*=\\\\s*['\\\"]stylesheet['\\\"]\\\\s+[^>]*href\\\\s*=\\\\s*['\\\"])([^'\\\"]+)://([^'\\\"]+['\\\"][^>]+>)\",\n                  Qt::CaseInsensitive, QRegExp::RegExp2 );\n    pos = 0;\n    while( pos >= 0 )\n    {\n      pos = articleString.indexOf( linkTags, pos );\n      if( pos < 0 )\n        break;\n\n      QString newTag = linkTags.cap( 1 ) + prefix + linkTags.cap( 2 )\n                       + \"/\" + linkTags.cap( 3 );\n      articleString.replace( pos, linkTags.cap().size(), newTag );\n      pos += newTag.size();\n    }\n#endif\n    // Check for unclosed <span> and <div>\n\n    int openTags = articleString.count( QRegExp( \"<\\\\s*span\\\\b\", Qt::CaseInsensitive ) );\n    int closedTags = articleString.count( QRegExp( \"<\\\\s*/span\\\\s*>\", Qt::CaseInsensitive ) );\n    while( openTags > closedTags )\n    {\n      articleString += \"</span>\";\n      closedTags += 1;\n    }\n\n    openTags = articleString.count( QRegExp( \"<\\\\s*div\\\\b\", Qt::CaseInsensitive ) );\n    closedTags = articleString.count( QRegExp( \"<\\\\s*/div\\\\s*>\", Qt::CaseInsensitive ) );\n    while( openTags > closedTags )\n    {\n      articleString += \"</div>\";\n      closedTags += 1;\n    }\n\n    // See Issue #271: A mechanism to clean-up invalid HTML cards.\n    articleString += \"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\n                     \"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\n                     \"</b></b></b></b></b></b></b></b>\"\n                     \"</i></i></i></i></i></i></i></i>\"\n                     \"</a></a></a></a></a></a></a></a>\";\n\n    QByteArray articleBody = articleString.toUtf8();\n\n    QString divStr = QString( \"<div class=\\\"website\\\"\" );\n    divStr += dictPtr->isToLanguageRTL() ? \" dir=\\\"rtl\\\">\" : \">\";\n\n    articleBody.prepend( divStr.toUtf8() );\n    articleBody.append( \"</div>\" );\n\n    articleBody.prepend( \"<div class=\\\"website_padding\\\"></div>\" );\n\n    Mutex::Lock _( dataMutex );\n\n    size_t prevSize = data.size();\n\n    data.resize( prevSize + articleBody.size() );\n\n    memcpy( &data.front() + prevSize, articleBody.data(), articleBody.size() );\n\n    hasAnyData = true;\n\n  }\n  else\n  {\n    if( netReply->url().scheme() == \"file\" )\n    {\n      gdWarning( \"WebSites: Failed loading article from \\\"%s\\\", reason: %s\\n\", dictPtr->getName().c_str(),\n                 netReply->errorString().toUtf8().data() );\n    }\n    else\n    {\n      setErrorString( netReply->errorString() );\n    }\n  }\n\n  disconnect( netReply, 0, 0, 0 );\n  netReply->deleteLater();\n\n  finish();\n}\n\nsptr< DataRequest > WebSiteDictionary::getArticle( wstring const & str,\n                                                   vector< wstring > const &,\n                                                   wstring const & context, bool )\n  THROW_SPEC( std::exception )\n{\n  QByteArray urlString;\n\n  // Context contains the right url to go to\n  if ( context.size() )\n    urlString = Utf8::encode( context ).c_str();\n  else\n  {\n    urlString = urlTemplate;\n\n    QString inputWord = gd::toQString( str );\n\n    urlString.replace( \"%25GDWORD%25\", inputWord.toUtf8().toPercentEncoding() );\n\n    QTextCodec *codec = QTextCodec::codecForName( \"Windows-1251\" );\n    if( codec )\n      urlString.replace( \"%25GD1251%25\", codec->fromUnicode( inputWord ).toPercentEncoding() );\n\n    codec = QTextCodec::codecForName( \"Big-5\" );\n    if( codec )\n      urlString.replace( \"%25GDBIG5%25\", codec->fromUnicode( inputWord ).toPercentEncoding() );\n\n    codec = QTextCodec::codecForName( \"Big5-HKSCS\" );\n    if( codec )\n      urlString.replace( \"%25GDBIG5HKSCS%25\", codec->fromUnicode( inputWord ).toPercentEncoding() );\n\n    codec = QTextCodec::codecForName( \"Shift-JIS\" );\n    if( codec )\n      urlString.replace( \"%25GDSHIFTJIS%25\", codec->fromUnicode( inputWord ).toPercentEncoding() );\n\n    codec = QTextCodec::codecForName( \"GB18030\" );\n    if( codec )\n      urlString.replace( \"%25GDGBK%25\", codec->fromUnicode( inputWord ).toPercentEncoding() );\n\n\n    // Handle all ISO-8859 encodings\n    for( int x = 1; x <= 16; ++x )\n    {\n      codec = QTextCodec::codecForName( QString( \"ISO 8859-%1\" ).arg( x ).toLatin1() );\n      if( codec )\n      {\n        urlString.replace( QString( \"%25GDISO%1%25\" ).arg( x ).toLatin1(),\n                           codec->fromUnicode( inputWord ).toPercentEncoding() );\n      }\n\n      if ( x == 10 )\n        x = 12; // Skip encodings 11..12, they don't exist\n    }\n  }\n\n  if( inside_iframe )\n  {\n    // Just insert link in <iframe> tag\n\n    sptr< DataRequestInstant > dr = new DataRequestInstant( true );\n\n    string result = \"<div class=\\\"website_padding\\\"></div>\";\n\n    result += string( \"<iframe id=\\\"gdexpandframe-\" ) + getId() +\n                      \"\\\" src=\\\"\" + urlString.data() +\n                      \"\\\" onmouseover=\\\"processIframeMouseOver('gdexpandframe-\" + getId() + \"');\\\" \"\n                      \"onmouseout=\\\"processIframeMouseOut();\\\" \"\n                      \"scrolling=\\\"no\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" \"\n                      \"frameborder=\\\"0\\\" vspace=\\\"0\\\" hspace=\\\"0\\\" \"\n                      \"style=\\\"overflow:visible; width:100%; display:none;\\\">\"\n                      \"</iframe>\";\n\n    dr->getData().resize( result.size() );\n\n    memcpy( &( dr->getData().front() ), result.data(), result.size() );\n\n    return dr;\n  }\n\n  // To load data from site\n\n  return new WebSiteArticleRequest( urlString, netMgr, this );\n}\n\nclass WebSiteResourceRequest: public WebSiteDataRequestSlots\n{\n  QNetworkReply * netReply;\n  QString url;\n  WebSiteDictionary * dictPtr;\n  QNetworkAccessManager & mgr;\n\npublic:\n\n  WebSiteResourceRequest( QString const & url_, QNetworkAccessManager & _mgr,\n                          WebSiteDictionary * dictPtr_ );\n  ~WebSiteResourceRequest()\n  {}\n\n  virtual void cancel();\n\nprivate:\n\n  virtual void requestFinished( QNetworkReply * );\n};\n\nWebSiteResourceRequest::WebSiteResourceRequest( QString const & url_,\n                                                QNetworkAccessManager & _mgr,\n                                                WebSiteDictionary * dictPtr_ ):\n  url( url_ ), dictPtr( dictPtr_ ), mgr( _mgr )\n{\n  connect( &mgr, SIGNAL( finished( QNetworkReply * ) ),\n           this, SLOT( requestFinished( QNetworkReply * ) ),\n           Qt::QueuedConnection );\n\n  QUrl reqUrl( url );\n\n  netReply = mgr.get( QNetworkRequest( reqUrl ) );\n\n#ifndef QT_NO_OPENSSL\n  connect( netReply, SIGNAL( sslErrors( QList< QSslError > ) ),\n           netReply, SLOT( ignoreSslErrors() ) );\n#endif\n}\n\nvoid WebSiteResourceRequest::cancel()\n{\n  finish();\n}\n\nvoid WebSiteResourceRequest::requestFinished( QNetworkReply * r )\n{\n  if ( isFinished() ) // Was cancelled\n    return;\n\n  if ( r != netReply )\n  {\n    // Well, that's not our reply, don't do anything\n    return;\n  }\n\n  if ( netReply->error() == QNetworkReply::NoError )\n  {\n    // Check for redirect reply\n\n    QVariant possibleRedirectUrl = netReply->attribute( QNetworkRequest::RedirectionTargetAttribute );\n    QUrl redirectUrl = possibleRedirectUrl.toUrl();\n    if( !redirectUrl.isEmpty() )\n    {\n      disconnect( netReply, 0, 0, 0 );\n      netReply->deleteLater();\n      netReply = mgr.get( QNetworkRequest( redirectUrl ) );\n#ifndef QT_NO_OPENSSL\n      connect( netReply, SIGNAL( sslErrors( QList< QSslError > ) ),\n               netReply, SLOT( ignoreSslErrors() ) );\n#endif\n      return;\n    }\n\n    // Handle reply data\n\n    QByteArray replyData = netReply->readAll();\n    QString cssString = QString::fromUtf8( replyData );\n\n    dictPtr->isolateWebCSS( cssString );\n\n    QByteArray cssData = cssString.toUtf8();\n\n    Mutex::Lock _( dataMutex );\n\n    size_t prevSize = data.size();\n\n    data.resize( prevSize + cssData.size() );\n\n    memcpy( &data.front() + prevSize, cssData.data(), cssData.size() );\n\n    hasAnyData = true;\n  }\n  else\n    setErrorString( netReply->errorString() );\n\n  disconnect( netReply, 0, 0, 0 );\n  netReply->deleteLater();\n\n  finish();\n}\n\nsptr< Dictionary::DataRequest > WebSiteDictionary::getResource( string const & name ) THROW_SPEC( std::exception )\n{\n  QString link = QString::fromUtf8( name.c_str() );\n  int pos = link.indexOf( '/' );\n  if( pos > 0 )\n    link.replace( pos, 1, \"://\" );\n  return new WebSiteResourceRequest( link, netMgr, this );\n}\n\nvoid WebSiteDictionary::loadIcon() throw()\n{\n  if ( dictionaryIconLoaded )\n    return;\n\n  if( !iconFilename.isEmpty() )\n  {\n    QFileInfo fInfo(  QDir( Config::getConfigDir() ), iconFilename );\n    if( fInfo.isFile() )\n      loadIconFromFile( fInfo.absoluteFilePath(), true );\n  }\n  if( dictionaryIcon.isNull() )\n    dictionaryIcon = dictionaryNativeIcon = QIcon(\":/icons/internet.png\");\n  dictionaryIconLoaded = true;\n}\n\n}\n\nvector< sptr< Dictionary::Class > > makeDictionaries( Config::WebSites const & ws,\n                                                      QNetworkAccessManager & mgr )\n  THROW_SPEC( std::exception )\n{\n  vector< sptr< Dictionary::Class > > result;\n\n  for( int x = 0; x < ws.size(); ++x )\n  {\n    if ( ws[ x ].enabled )\n      result.push_back( new WebSiteDictionary( ws[ x ].id.toUtf8().data(),\n                                               ws[ x ].name.toUtf8().data(),\n                                               ws[ x ].url,\n                                               ws[ x ].iconFilename,\n                                               ws[ x ].inside_iframe,\n                                               mgr )\n                      );\n  }\n\n  return result;\n}\n\n}\n"
        },
        {
          "name": "website.hh",
          "type": "blob",
          "size": 0.79296875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __WEBSITE_HH_INCLUDED__\n#define __WEBSITE_HH_INCLUDED__\n\n#include \"dictionary.hh\"\n#include \"config.hh\"\n#include <QNetworkAccessManager>\n#include <QNetworkReply>\n\n/// Support for any web sites via a templated url.\nnamespace WebSite {\n\nusing std::vector;\nusing std::string;\n\nvector< sptr< Dictionary::Class > > makeDictionaries( Config::WebSites const &,\n                                                      QNetworkAccessManager & )\n    THROW_SPEC( std::exception );\n\n/// Exposed here for moc\nclass WebSiteDataRequestSlots: public Dictionary::DataRequest\n{\n  Q_OBJECT\n\nprotected slots:\n\n  virtual void requestFinished( QNetworkReply * )\n  {}\n};\n\n}\n\n#endif\n"
        },
        {
          "name": "wildcard.cc",
          "type": "blob",
          "size": 2.744140625,
          "content": "#include <QRegularExpression>\n#include \"wildcard.hh\"\n\n/*\n  Modified function from Qt\n  Translates a wildcard pattern to an equivalent regular expression\n  pattern (e.g., *.cpp to .*\\.cpp).\n*/\n\nQString wildcardsToRegexp( const QString & wc_str )\n{\n    const int wclen = wc_str.length();\n    QString rx;\n    int i = 0;\n    bool isEscaping = false; // the previous character is '\\'\n    const QChar *wc = wc_str.unicode();\n\n    while( i < wclen ) {\n      const QChar c = wc[ i++ ];\n      switch( c.unicode() ) {\n        case '\\\\':\n            if( isEscaping ) {\n                rx += QLatin1String( \"\\\\\\\\\" );\n            } // we insert the \\\\ later if necessary\n            if( i == wclen ) { // the end\n                rx += QLatin1String( \"\\\\\\\\\" );\n            }\n            isEscaping = true;\n            break;\n\n        case '*':\n            if( isEscaping ) {\n                rx += QLatin1String( \"\\\\*\" );\n                isEscaping = false;\n            } else {\n                rx += QLatin1String( \".*\" );\n            }\n            break;\n\n        case '?':\n            if( isEscaping ) {\n                rx += QLatin1String( \"\\\\?\" );\n                isEscaping = false;\n            } else {\n                rx += QLatin1Char( '.' );\n            }\n\n            break;\n\n        case '$':\n        case '(':\n        case ')':\n        case '+':\n        case '.':\n        case '^':\n        case '{':\n        case '|':\n        case '}':\n            if( isEscaping ) {\n                isEscaping = false;\n                rx += QLatin1String( \"\\\\\\\\\" );\n            }\n            rx += QLatin1Char( '\\\\' );\n            rx += c;\n            break;\n         case '[':\n            if(isEscaping) {\n                isEscaping = false;\n                rx += QLatin1String( \"\\\\[\" );\n            } else {\n                QString tmp;\n                tmp += c;\n                if( i < wclen && wc[ i ] == QLatin1Char( '!' ) )\n                {\n                  tmp += QLatin1Char( '^' );\n                  ++i;\n                }\n                while( i < wclen && wc[ i ] != QLatin1Char( ']' ) ) {\n                    if( wc[ i ] == QLatin1Char( '\\\\' ) )\n                        tmp += QLatin1Char( '\\\\' );\n                    tmp += wc[ i++ ];\n                }\n                if( i < wclen )\n                    rx += tmp;\n                else\n                    rx += QRegularExpression::escape( tmp );\n            }\n            break;\n\n        case ']':\n            if( isEscaping ){\n                isEscaping = false;\n                rx += QLatin1String( \"\\\\\" );\n            }\n            rx += c;\n            break;\n\n        default:\n            if( isEscaping ){\n                isEscaping = false;\n                rx += QLatin1String( \"\\\\\\\\\" );\n            }\n            rx += c;\n      }\n    }\n    return rx;\n}\n"
        },
        {
          "name": "wildcard.hh",
          "type": "blob",
          "size": 0.142578125,
          "content": "#ifndef __WILCARD_HH_INCLUDED__\n#define __WILCARD_HH_INCLUDED__\n\n#include <QString>\n\nQString wildcardsToRegexp( const QString & wc_str );\n\n#endif\n"
        },
        {
          "name": "winlibs",
          "type": "tree",
          "content": null
        },
        {
          "name": "wordbyauto.cc",
          "type": "blob",
          "size": 2.939453125,
          "content": "#include <windows.h>\n#include <servprov.h>\n#include \"wordbyauto.hh\"\n#include \"uiauto.hh\"\n\n#include <cstdio>\n#include \"gddebug.hh\"\n\nclass GDAutomationClient {\npublic:\n    GDAutomationClient();\n    ~GDAutomationClient();\n    bool getWordAtPoint( POINT pt );\n    WCHAR *getText() { return buffer; }\nprivate:\n    WCHAR buffer[256];\n    IUIAutomation *pGDAutomation;\n    IUIAutomationTreeWalker *pTree;\n};\n\nGDAutomationClient gdAuto;\n\nGDAutomationClient::GDAutomationClient()\n{\nHRESULT hr;\n    CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );\n    hr = CoCreateInstance( CLSID_CUIAutomation , NULL, CLSCTX_INPROC_SERVER, IID_IUIAutomation, (void**)&pGDAutomation );\n    if( hr != S_OK ) pGDAutomation = NULL;\n    pTree = NULL;\n    if( pGDAutomation != NULL )\n        hr = pGDAutomation->get_RawViewWalker( &pTree );\n    memset( buffer, 0, sizeof(buffer) );\n}\n\nGDAutomationClient::~GDAutomationClient()\n{\n    if( pTree != NULL ) pTree->Release();\n    if( pGDAutomation != NULL ) pGDAutomation->Release();\n    CoUninitialize();\n}\n\nbool GDAutomationClient::getWordAtPoint( POINT pt )\n{\nHRESULT hr;\nIUIAutomationTextPattern *pTextPattern;\nIUIAutomationTextRange *pTextRange;\nIUIAutomationElement *pElement, *pParent;\nBSTR bstr;\nRECT r = { 0, 0, 0, 0 };\nbool bGoUp;\n\n    GD_DPRINTF(\"\\nEntering getWordAtPoint\\n\");\n\n    if( pGDAutomation == NULL ) return false;\n\n    buffer[0] = 0;\n    pElement = NULL;\n    hr = pGDAutomation->ElementFromPoint( pt, &pElement );\n    GD_DPRINTF(\"ElementFromPoint return hr=%08lX, ptr=%p\\n\", hr, pElement);\n    if( hr != S_OK || pElement == NULL )\n        return false;\n\n    pTextPattern = NULL;\n    bGoUp = false;\n    while( pElement != NULL ) {\n        hr = pElement->GetCurrentPatternAs( UIA_TextPatternId, IID_IUIAutomationTextPattern, (void**)&pTextPattern );\n        if( hr == S_OK && pTextPattern != NULL )\n            break;\n        if( pTree == NULL ) {\n            pElement->Release();\n            return false;\n        }\n        pParent = NULL;\n        hr = pTree->GetParentElement( pElement, &pParent );\n        pElement->Release();\n        pElement = pParent;\n        bGoUp = TRUE;\n    }\n    if( pElement == NULL )\n        return false;\n\n    if( !bGoUp ) {\n        hr = pElement->get_CurrentBoundingRectangle( &r );\n        if( hr == S_OK) {\n            pt.x -= r.left;\n            pt.y -= r.top;\n        }\n    }\n    pElement->Release();\n\n    pTextRange = NULL;\n    hr = pTextPattern->RangeFromPoint( pt, &pTextRange );\n    pTextPattern->Release();\n    if( hr != S_OK || pTextRange == NULL )\n        return false;\n\n    hr = pTextRange->ExpandToEnclosingUnit( TextUnit_Word );\n    if( hr == S_OK) {\n        hr = pTextRange->GetText( 255, &bstr );\n        if (hr == S_OK) {\n            wsprintfW( buffer, L\"%s\", (LPCWSTR)bstr );\n            SysFreeString( bstr );\n        }\n    }\n    pTextRange->Release();\n\n    return ( buffer[0] != 0 );\n}\n\nWCHAR *gdGetWordAtPointByAutomation( POINT pt )\n{\n    if( gdAuto.getWordAtPoint( pt ) ) return gdAuto.getText();\n    else return NULL;\n}\n"
        },
        {
          "name": "wordbyauto.hh",
          "type": "blob",
          "size": 0.125,
          "content": "#ifndef __WORD_BY_AUTO_HH_INCLUDED\n#define __WORD_BY_AUTO_HH_INCLUDED\n\nWCHAR *gdGetWordAtPointByAutomation( POINT pt );\n\n#endif\n"
        },
        {
          "name": "wordfinder.cc",
          "type": "blob",
          "size": 15.5224609375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"wordfinder.hh\"\n#include \"folding.hh\"\n#include \"wstring_qt.hh\"\n#include <QThreadPool>\n#include <map>\n#include \"gddebug.hh\"\n\nusing std::vector;\nusing std::list;\nusing gd::wstring;\nusing gd::wchar;\nusing std::map;\nusing std::pair;\n\nWordFinder::WordFinder( QObject * parent ):\n  QObject( parent ), searchInProgress( false ),\n  updateResultsTimer( this ),\n  searchQueued( false )\n{\n  updateResultsTimer.setInterval( 1000 ); // We use a one second update timer\n  updateResultsTimer.setSingleShot( true );\n\n  connect( &updateResultsTimer, SIGNAL( timeout() ),\n           this, SLOT( updateResults() ), Qt::QueuedConnection );\n}\n\nWordFinder::~WordFinder()\n{\n  clear();\n}\n\nvoid WordFinder::prefixMatch( QString const & str,\n                              std::vector< sptr< Dictionary::Class > > const & dicts,\n                              unsigned long maxResults,\n                              Dictionary::Features features )\n{\n  cancel();\n\n  searchQueued = true;\n  searchType = PrefixMatch;\n  inputWord = str;\n  inputDicts = &dicts;\n  requestedMaxResults = maxResults;\n  requestedFeatures = features;\n\n  resultsArray.clear();\n  resultsIndex.clear();\n  searchResults.clear();\n\n  if ( queuedRequests.empty() )\n  {\n    // No requests are queued, no need to wait for them to finish.\n    startSearch();\n  }\n\n  // Else some requests are still queued, last one to finish would trigger\n  // new search. This shouldn't take a lot of time, since they were all\n  // cancelled, but still it could take some time.\n}\nvoid WordFinder::stemmedMatch( QString const & str,\n                               std::vector< sptr< Dictionary::Class > > const & dicts,\n                               unsigned minLength,\n                               unsigned maxSuffixVariation,\n                               unsigned long maxResults,\n                               Dictionary::Features features )\n{\n  cancel();\n\n  searchQueued = true;\n  searchType = StemmedMatch;\n  inputWord = str;\n  inputDicts = &dicts;\n  requestedMaxResults = maxResults;\n  requestedFeatures = features;\n  stemmedMinLength = minLength;\n  stemmedMaxSuffixVariation = maxSuffixVariation;\n\n  resultsArray.clear();\n  resultsIndex.clear();\n  searchResults.clear();\n\n  if ( queuedRequests.empty() )\n    startSearch();\n}\n\nvoid WordFinder::expressionMatch( QString const & str,\n                                  std::vector< sptr< Dictionary::Class > > const & dicts,\n                                  unsigned long maxResults,\n                                  Dictionary::Features features )\n{\n  cancel();\n\n  searchQueued = true;\n  searchType = ExpressionMatch;\n  inputWord = str;\n  inputDicts = &dicts;\n  requestedMaxResults = maxResults;\n  requestedFeatures = features;\n\n  resultsArray.clear();\n  resultsIndex.clear();\n  searchResults.clear();\n\n  if ( queuedRequests.empty() )\n  {\n    // No requests are queued, no need to wait for them to finish.\n    startSearch();\n  }\n}\n\nvoid WordFinder::startSearch()\n{\n  if ( !searchQueued )\n    return; // Search was probably cancelled\n\n  // Clear the requests just in case\n  queuedRequests.clear();\n  finishedRequests.clear();\n\n  searchErrorString.clear();\n  searchResultsUncertain = false;\n\n  searchQueued = false;\n  searchInProgress = true;\n\n  // Gather all writings of the word\n\n  if ( allWordWritings.size() != 1 )\n    allWordWritings.resize( 1 );\n  \n  allWordWritings[ 0 ] = gd::toWString( inputWord );\n\n  for( size_t x = 0; x < inputDicts->size(); ++x )\n  {\n    vector< wstring > writings = (*inputDicts)[ x ]->getAlternateWritings( allWordWritings[ 0 ] );\n\n    allWordWritings.insert( allWordWritings.end(), writings.begin(), writings.end() );\n  }\n\n  // Query each dictionary for all word writings\n\n  for( size_t x = 0; x < inputDicts->size(); ++x )\n  {\n    if ( ( (*inputDicts)[ x ]->getFeatures() & requestedFeatures ) != requestedFeatures )\n      continue;\n\n    for( size_t y = 0; y < allWordWritings.size(); ++y )\n    {\n      try\n      {\n        sptr< Dictionary::WordSearchRequest > sr =\n          ( searchType == PrefixMatch || searchType == ExpressionMatch ) ?\n            (*inputDicts)[ x ]->prefixMatch( allWordWritings[ y ], requestedMaxResults ) :\n            (*inputDicts)[ x ]->stemmedMatch( allWordWritings[ y ], stemmedMinLength, stemmedMaxSuffixVariation, requestedMaxResults );\n\n        connect( sr.get(), SIGNAL( finished() ),\n                 this, SLOT( requestFinished() ), Qt::QueuedConnection );\n\n        queuedRequests.push_back( sr );\n      }\n      catch( std::exception & e )\n      {\n        gdWarning( \"Word \\\"%s\\\" search error (%s) in \\\"%s\\\"\\n\",\n                   inputWord.toUtf8().data(), e.what(), (*inputDicts)[ x ]->getName().c_str() );\n      }\n    }\n  }\n\n  // Handle any requests finished already\n\n  requestFinished();\n}\n\nvoid WordFinder::cancel()\n{\n  searchQueued = false;\n  searchInProgress = false;\n  \n  cancelSearches();\n}\n\nvoid WordFinder::clear()\n{\n  cancel();\n  queuedRequests.clear();\n  finishedRequests.clear();\n}\n\nvoid WordFinder::requestFinished()\n{\n  bool newResults = false;\n\n  // See how many new requests have finished, and if we have any new results\n  for( list< sptr< Dictionary::WordSearchRequest > >::iterator i =\n         queuedRequests.begin(); i != queuedRequests.end(); )\n  {\n    if ( (*i)->isFinished() )\n    {\n      if ( searchInProgress && !(*i)->getErrorString().isEmpty() )\n        searchErrorString = tr( \"Failed to query some dictionaries.\" );\n\n      if ( (*i)->isUncertain() )\n        searchResultsUncertain = true;\n\n      if ( (*i)->matchesCount() )\n      {\n        newResults = true;\n\n        // This list is handled by updateResults()\n        finishedRequests.splice( finishedRequests.end(), queuedRequests, i++ );\n      }\n      else // We won't do anything with it anymore, so we erase it\n        queuedRequests.erase( i++ );\n    }\n    else\n      ++i;\n  }\n\n  if ( !searchInProgress )\n  {\n    // There is no search in progress, so we just wait until there's\n    // no requests left\n    \n    if ( queuedRequests.empty() )\n    {\n      // We got rid of all queries, queued search can now start\n      finishedRequests.clear();\n  \n      if ( searchQueued )\n        startSearch();\n    }\n\n    return;\n  }\n\n  if ( newResults && queuedRequests.size() && !updateResultsTimer.isActive() )\n  {\n    // If we have got some new results, but not all of them, we would start a\n    // timer to update a user some time in the future\n    updateResultsTimer.start();\n  }\n\n  if ( queuedRequests.empty() )\n  {\n    // Search is finished.\n    updateResults();\n  }\n}\n\nnamespace {\n\n\nunsigned saturated( unsigned x )\n{\n  return x < 255 ? x : 255;\n}\n\n/// Checks whether the first string has the second one inside, surrounded from\n/// both sides by either whitespace, punctuation or begin/end of string.\n/// If true is returned, pos holds the offset in the haystack. If the offset\n/// is larger than 255, it is set to 255.\nbool hasSurroundedWithWs( wstring const & haystack, wstring const & needle,\n                          wstring::size_type & pos )\n{\n  if ( haystack.size() < needle.size() )\n    return false; // Needle won't even fit into a haystack\n\n  for( pos = 0; ; ++pos )\n  {\n    pos = haystack.find( needle, pos );\n  \n    if ( pos == wstring::npos )\n      return false; // Not found\n  \n    if ( ( !pos || Folding::isWhitespace( haystack[ pos - 1 ] ) ||\n           Folding::isPunct( haystack[ pos - 1 ] ) ) &&\n         ( ( pos + needle.size() == haystack.size() ) ||\n           Folding::isWhitespace( haystack[ pos + needle.size() ] ) ||\n           Folding::isPunct( haystack[ pos + needle.size() ] ) ) )\n    {\n      pos = saturated( pos );\n\n      return true;\n    }\n  }\n}\n\n}\n\nvoid WordFinder::updateResults()\n{\n  if ( !searchInProgress )\n    return; // Old queued signal\n\n  if ( updateResultsTimer.isActive() )\n    updateResultsTimer.stop(); // Can happen when we were done before it'd expire\n\n  wstring original = Folding::applySimpleCaseOnly( allWordWritings[ 0 ] );\n\n  for( list< sptr< Dictionary::WordSearchRequest > >::iterator i =\n         finishedRequests.begin(); i != finishedRequests.end(); )\n  {\n    for( size_t count = (*i)->matchesCount(), x = 0; x < count; ++x )\n    {\n      wstring match = (**i)[ x ].word;\n      int weight = (**i)[ x ].weight;\n      wstring lowerCased = Folding::applySimpleCaseOnly( match );\n\n      if( searchType == ExpressionMatch )\n      {\n        unsigned ws;\n\n        for( ws = 0; ws < allWordWritings.size(); ws++ )\n        {\n          if( ws == 0 )\n          {\n            // Check for prefix match with original expression\n            if( lowerCased.compare( 0, original.size(), original ) == 0 )\n              break;\n          }\n          else\n          if( lowerCased == Folding::applySimpleCaseOnly( allWordWritings[ ws ] ) )\n            break;\n        }\n\n        if( ws >= allWordWritings.size() )\n        {\n          // No exact matches found\n          continue;\n        }\n        weight = ws;\n      }\n      pair< ResultsIndex::iterator, bool > insertResult =\n        resultsIndex.insert( pair< wstring, ResultsArray::iterator >( lowerCased,\n                                                                      resultsArray.end() ) );\n\n      if ( !insertResult.second )\n      {\n        // Wasn't inserted since there was already an item -- check the case\n        if ( insertResult.first->second->word != match )\n        {\n          // The case is different -- agree on a lowercase version\n          insertResult.first->second->word = lowerCased;\n        }\n        if ( !weight && insertResult.first->second->wasSuggested )\n          insertResult.first->second->wasSuggested = false;\n      }\n      else\n      {\n        resultsArray.push_back( OneResult() );\n\n        resultsArray.back().word = match;\n        resultsArray.back().rank = INT_MAX;\n        resultsArray.back().wasSuggested = ( weight != 0 );\n\n        insertResult.first->second = --resultsArray.end();\n      }\n    }\n    finishedRequests.erase( i++ );\n  }\n\n  size_t maxSearchResults = 500;\n\n  if ( resultsArray.size() )\n  {\n    if ( searchType == PrefixMatch )\n    {\n      /// Assign each result a category, storing it in the rank's field\n  \n      enum Category\n      {\n        ExactMatch,\n        ExactNoFullCaseMatch,\n        ExactNoDiaMatch,\n        ExactNoPunctMatch,\n        ExactNoWsMatch,\n        ExactInsideMatch,\n        ExactNoDiaInsideMatch,\n        ExactNoPunctInsideMatch,\n        PrefixMatch,\n        PrefixNoDiaMatch,\n        PrefixNoPunctMatch,\n        PrefixNoWsMatch,\n        WorstMatch,\n        Multiplier = 256 // Categories should be multiplied by Multiplier\n      };\n\n      for( unsigned wr = 0; wr < allWordWritings.size(); ++wr )\n      {\n        wstring target = Folding::applySimpleCaseOnly( allWordWritings[ wr ] );\n        wstring targetNoFullCase = Folding::applyFullCaseOnly( target );\n        wstring targetNoDia = Folding::applyDiacriticsOnly( targetNoFullCase );\n        wstring targetNoPunct = Folding::applyPunctOnly( targetNoDia );\n        wstring targetNoWs = Folding::applyWhitespaceOnly( targetNoPunct );\n    \n        wstring::size_type matchPos = 0;\n    \n        for( ResultsIndex::const_iterator i = resultsIndex.begin(), j = resultsIndex.end();\n             i != j; ++i )\n        {\n          wstring resultNoFullCase, resultNoDia, resultNoPunct, resultNoWs;\n\n          int rank;\n          \n          if ( i->first == target )\n            rank = ExactMatch * Multiplier;\n          else\n          if ( ( resultNoFullCase = Folding::applyFullCaseOnly( i->first ) ) == targetNoFullCase )\n            rank = ExactNoFullCaseMatch * Multiplier;\n          else\n          if ( ( resultNoDia = Folding::applyDiacriticsOnly( resultNoFullCase ) ) == targetNoDia )\n            rank = ExactNoDiaMatch * Multiplier;\n          else\n          if ( ( resultNoPunct = Folding::applyPunctOnly( resultNoDia ) ) == targetNoPunct )\n            rank = ExactNoPunctMatch * Multiplier;\n          else\n          if ( ( resultNoWs = Folding::applyWhitespaceOnly( resultNoPunct ) ) == targetNoWs )\n            rank = ExactNoWsMatch * Multiplier;\n          else\n          if ( hasSurroundedWithWs( i->first, target, matchPos ) )\n            rank = ExactInsideMatch * Multiplier + matchPos;\n          else\n          if ( hasSurroundedWithWs( resultNoDia, targetNoDia, matchPos ) )\n            rank = ExactNoDiaInsideMatch * Multiplier + matchPos;\n          else\n          if ( hasSurroundedWithWs( resultNoPunct, targetNoPunct, matchPos ) )\n            rank = ExactNoPunctInsideMatch * Multiplier + matchPos;\n          else\n          if ( i->first.size() > target.size() && i->first.compare( 0, target.size(), target ) == 0 )\n            rank = PrefixMatch * Multiplier + saturated( i->first.size() );\n          else\n          if ( resultNoDia.size() > targetNoDia.size() && resultNoDia.compare( 0, targetNoDia.size(), targetNoDia ) == 0 )\n            rank = PrefixNoDiaMatch * Multiplier + saturated( i->first.size() );\n          else\n          if ( resultNoPunct.size() > targetNoPunct.size() && resultNoPunct.compare( 0, targetNoPunct.size(), targetNoPunct ) == 0 )\n            rank = PrefixNoPunctMatch * Multiplier + saturated( i->first.size() );\n          else\n          if ( resultNoWs.size() > targetNoWs.size() && resultNoWs.compare( 0, targetNoWs.size(), targetNoWs ) == 0 )\n            rank = PrefixNoWsMatch * Multiplier + saturated( i->first.size() );\n          else\n            rank = WorstMatch * Multiplier;\n\n          if ( i->second->rank > rank )\n            i->second->rank = rank; // We store the best rank of any writing\n        }\n      }\n  \n      resultsArray.sort( SortByRank() );\n    }\n    else\n    if( searchType == StemmedMatch )\n    {\n      // Handling stemmed matches\n\n      // We use two factors -- first is the number of characters strings share\n      // in their beginnings, and second, the length of the strings. Here we assign\n      // only the first one, storing it in rank. Then we sort the results using\n      // SortByRankAndLength.\n      for( unsigned wr = 0; wr < allWordWritings.size(); ++wr )\n      {\n        wstring target = Folding::apply( allWordWritings[ wr ] );\n  \n        for( ResultsIndex::const_iterator i = resultsIndex.begin(), j = resultsIndex.end();\n             i != j; ++i )\n        {\n          wstring resultFolded = Folding::apply( i->first );\n  \n          int charsInCommon = 0;\n  \n          for( wchar const * t = target.c_str(), * r = resultFolded.c_str();\n               *t && *t == *r; ++t, ++r, ++charsInCommon ) ;\n  \n          int rank = -charsInCommon; // Negated so the lesser-than\n                                     // comparison would yield right\n                                     // results.\n\n          if ( i->second->rank > rank )\n            i->second->rank = rank; // We store the best rank of any writing\n        }\n      }\n      \n      resultsArray.sort( SortByRankAndLength() );\n\n      maxSearchResults = 15;\n    }\n  }\n\n  searchResults.clear();\n  searchResults.reserve( resultsArray.size() < maxSearchResults ? resultsArray.size() : maxSearchResults );\n\n  for( ResultsArray::const_iterator i = resultsArray.begin(), j = resultsArray.end();\n       i != j; ++i )\n  {\n    //DPRINTF( \"%d: %ls\\n\", i->second, i->first.c_str() );\n\n    if ( searchResults.size() < maxSearchResults )\n      searchResults.push_back( std::pair< QString, bool >( gd::toQString( i->word ), i->wasSuggested ) );\n    else\n      break;\n  }\n\n  if ( queuedRequests.size() )\n  {\n    // There are still some unhandled results.\n    emit updated();\n  }\n  else\n  {\n    // That were all of them.\n    searchInProgress = false;\n    emit finished();\n  }\n}\n\nvoid WordFinder::cancelSearches()\n{\n  for( list< sptr< Dictionary::WordSearchRequest > >::iterator i =\n         queuedRequests.begin(); i != queuedRequests.end(); ++i )\n    (*i)->cancel();\n}\n\n"
        },
        {
          "name": "wordfinder.hh",
          "type": "blob",
          "size": 6.1005859375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __WORDFINDER_HH_INCLUDED__\n#define __WORDFINDER_HH_INCLUDED__\n\n#include <list>\n#include <map>\n#include <QObject>\n#include <QTimer>\n#include <QMutex>\n#include <QWaitCondition>\n#include <QRunnable>\n#include \"dictionary.hh\"\n\n/// This component takes care of finding words. The search is asynchronous.\n/// This means the GUI doesn't get blocked during the sometimes lenghtly\n/// process of finding words.\nclass WordFinder: public QObject\n{\n  Q_OBJECT\n\npublic:\n\n  typedef std::vector< std::pair< QString, bool > > SearchResults; // bool is a \"was suggested\" flag\n\nprivate:\n\n  SearchResults searchResults;\n  QString searchErrorString;\n  bool searchResultsUncertain;\n  std::list< sptr< Dictionary::WordSearchRequest > > queuedRequests,\n                                                     finishedRequests;\n  bool searchInProgress;\n\n  QTimer updateResultsTimer;\n\n  // Saved search params\n  bool searchQueued;\n  QString inputWord;\n  enum SearchType\n  {\n    PrefixMatch,\n    StemmedMatch,\n    ExpressionMatch\n  } searchType;\n  unsigned long requestedMaxResults;\n  Dictionary::Features requestedFeatures;\n  unsigned stemmedMinLength;\n  unsigned stemmedMaxSuffixVariation;\n\n  std::vector< sptr< Dictionary::Class > > const * inputDicts;\n\n  std::vector< gd::wstring > allWordWritings; // All writings of the inputWord\n  \n  struct OneResult\n  {\n    gd::wstring word;\n    int rank;\n    bool wasSuggested;\n  };\n\n  // Maps lowercased string to the original one. This catches all duplicates\n  // without case sensitivity. Made as an array and a map indexing that array.\n  typedef std::list< OneResult > ResultsArray;\n  typedef std::map< gd::wstring, ResultsArray::iterator > ResultsIndex;\n  ResultsArray resultsArray;\n  ResultsIndex resultsIndex;\n    \npublic:\n\n  WordFinder( QObject * parent );\n  ~WordFinder();\n\n  /// Do the standard prefix-match search in the given list of dictionaries.\n  /// Some dictionaries might only support exact matches -- for them, only\n  /// the exact matches would be found. All search results are put into a single\n  /// list containing the exact matches first, then the prefix ones. Duplicate\n  /// matches from different dictionaries are merged together.\n  /// If a list of features is specified, the search will only be performed in\n  /// the dictionaries which possess all the features requested.\n  /// If there already was a prefixMatch operation underway, it gets cancelled\n  /// and the new one replaces it.\n  void prefixMatch( QString const &,\n                    std::vector< sptr< Dictionary::Class > > const &,\n                    unsigned long maxResults = 40,\n                    Dictionary::Features = Dictionary::NoFeatures );\n\n  /// Do a stemmed-match search in the given list of dictionaries. All comments\n  /// from prefixMatch() generally apply as well.\n  void stemmedMatch( QString const &,\n                     std::vector< sptr< Dictionary::Class > > const &,\n                     unsigned minLength = 3,\n                     unsigned maxSuffixVariation = 3,\n                     unsigned long maxResults = 30,\n                     Dictionary::Features = Dictionary::NoFeatures );\n  \n  /// Do the expression-match search in the given list of dictionaries.\n  /// Function find exact matches for one of spelling suggestions.\n  void expressionMatch( QString const &,\n                        std::vector< sptr< Dictionary::Class > > const &,\n                        unsigned long maxResults = 40,\n                        Dictionary::Features = Dictionary::NoFeatures );\n\n  /// Returns the vector containing search results from the last operation.\n  /// If it didn't finish yet, the result is not final and may be changing\n  /// over time.\n  SearchResults const & getResults() const\n  { return searchResults; }\n\n  /// Returns a human-readable error string for the last finished request. Empty\n  /// string means it finished without any error.\n  QString const & getErrorString()\n  { return searchErrorString; }\n\n  /// Returns true if the search was inconclusive -- that is, there may be more\n  /// results than the ones returned.\n  bool wasSearchUncertain() const\n  { return searchResultsUncertain; }\n\n  /// Cancels any pending search operation, if any.\n  void cancel();\n\n  /// Cancels any pending search operation, if any, and makes sure no pending\n  /// requests exist, and hence no dictionaries are used anymore. Unlike\n  /// cancel(), this may take some time to finish.\n  void clear();\n\nsignals:\n\n  /// Indicates that the search has got some more results, and continues\n  /// searching.\n  void updated();\n\n  /// Indicates that the search has finished.\n  void finished();\n\nprivate slots:\n\n  /// Called each time one of the requests gets finished\n  void requestFinished();\n\n  /// Called by updateResultsTimer to update searchResults and signal updated()\n  void updateResults();\n\nprivate:\n\n  // Starts the previously queued search.\n  void startSearch();\n\n  // Cancels all searches. Useful to do before destroying them all, since they\n  // would cancel in parallel.\n  void cancelSearches();\n\n  /// Compares results based on their ranks\n  struct SortByRank\n  {\n    bool operator () ( OneResult const & first, OneResult const & second )\n    {\n      if ( first.rank < second.rank )\n        return true;\n  \n      if ( first.rank > second.rank )\n        return false;\n  \n      // Do any sort of collation here in the future. For now we just put the\n      // strings sorted lexicographically.\n      return first.word < second.word;\n    }\n  };\n\n  /// Compares results based on their ranks and lengths\n  struct SortByRankAndLength\n  {\n    bool operator () ( OneResult const & first, OneResult const & second )\n    {\n      if ( first.rank < second.rank )\n        return true;\n\n      if ( first.rank > second.rank )\n        return false;\n\n      if ( first.word.size() < second.word.size() )\n        return true;\n\n      if ( first.word.size() > second.word.size() )\n        return false;\n\n      // Do any sort of collation here in the future. For now we just put the\n      // strings sorted lexicographically.\n      return first.word < second.word;\n    }\n  };\n};\n\n#endif\n\n"
        },
        {
          "name": "wordlist.cc",
          "type": "blob",
          "size": 3.6494140625,
          "content": "/* This file is (c) 2013 Tvangeste <i.4m.l33t@yandex.ru>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include <QDebug>\n\n#include \"wordlist.hh\"\n\nWordList::WordList( QWidget * parent ) : QListWidget( parent )\n, listItemDelegate( itemDelegate() )\n{\n  wordFinder = 0;\n  translateLine = 0;\n  setItemDelegate( &listItemDelegate );\n}\n\nvoid WordList::attachFinder( WordFinder * finder )\n{\n  // qDebug() << \"Attaching the word finder...\" << finder;\n\n  if ( wordFinder == finder )\n    return;\n\n  if ( wordFinder )\n  {\n    disconnect( wordFinder, SIGNAL( updated() ),\n             this, SLOT( prefixMatchUpdated() ) );\n    disconnect( wordFinder, SIGNAL( finished() ),\n             this, SLOT( prefixMatchFinished() ) );\n  }\n\n  wordFinder = finder;\n\n  connect( wordFinder, SIGNAL( updated() ),\n           this, SLOT( prefixMatchUpdated() ) );\n  connect( wordFinder, SIGNAL( finished() ),\n           this, SLOT( prefixMatchFinished() ) );\n}\n\nvoid WordList::prefixMatchUpdated()\n{\n  updateMatchResults( false );\n}\n\nvoid WordList::prefixMatchFinished()\n{\n  updateMatchResults( true );\n}\n\nvoid WordList::updateMatchResults( bool finished )\n{\n  WordFinder::SearchResults const & results = wordFinder->getResults();\n\n  setUpdatesEnabled( false );\n\n  for( unsigned x = 0; x < results.size(); ++x )\n  {\n    QListWidgetItem * i = item( x );\n\n    if ( !i )\n    {\n      i = new QListWidgetItem( results[ x ].first, this );\n      i->setToolTip( results[ x ].first );\n\n      if ( results[ x ].second )\n      {\n        QFont f = i->font();\n        f.setItalic( true );\n        i->setFont( f );\n      }\n      addItem( i );\n    }\n    else\n    {\n      if ( i->text() != results[ x ].first )\n      {\n        i->setText( results[ x ].first );\n        i->setToolTip( results[ x ].first );\n      }\n\n      QFont f = i->font();\n      if ( f.italic() != results[ x ].second )\n      {\n        f.setItalic( results[ x ].second );\n        i->setFont( f );\n      }\n    }\n\n    i->setTextAlignment(Qt::AlignLeft);\n  }\n\n  while ( count() > (int) results.size() )\n  {\n    // Chop off any extra items that were there\n    QListWidgetItem * i = takeItem( count() - 1 );\n\n    if ( i )\n      delete i;\n    else\n      break;\n  }\n\n  if ( count() )\n  {\n    scrollToItem( item( 0 ), QAbstractItemView::PositionAtTop );\n    setCurrentItem( 0, QItemSelectionModel::Clear );\n  }\n\n  setUpdatesEnabled( true );\n\n  if ( finished )\n  {\n    unsetCursor();\n\n    refreshTranslateLine();\n\n    if ( !wordFinder->getErrorString().isEmpty() )\n      emit statusBarMessage( tr( \"WARNING: %1\" ).arg( wordFinder->getErrorString() ),\n                             20000 , QPixmap( \":/icons/error.png\" ) );\n  }\n\n  if( !results.empty() && results.front().first.isRightToLeft() )\n    setLayoutDirection( Qt::RightToLeft );\n  else\n    setLayoutDirection( Qt::LeftToRight );\n\n  emit contentChanged();\n}\n\nvoid WordList::refreshTranslateLine()\n{\n  if ( !translateLine )\n    return;\n\n  // Visually mark the input line to mark if there's no results\n  bool setMark = wordFinder->getResults().empty() && !wordFinder->wasSearchUncertain();\n\n  if ( translateLine->property( \"noResults\" ).toBool() != setMark )\n  {\n    translateLine->setProperty( \"noResults\", setMark );\n    translateLine->setStyleSheet( translateLine->styleSheet() );\n  }\n\n}\n\nvoid WordList::resizeEvent( QResizeEvent * ev )\n{\n  // In some rare cases Qt start send QResizeEvent recursively\n  // up to full stack depletion (tested on Qt 4.8.5, 4.8.6).\n  // We use this trick to break such suicidal process.\n\n  for( int x = 0; x < resizedSizes.size(); x++ )\n    if( resizedSizes.at( x ) == ev->size() )\n      return;\n\n  resizedSizes.push_back( ev->size() );\n\n  QListWidget::resizeEvent( ev );\n\n  resizedSizes.pop_back();\n}\n"
        },
        {
          "name": "wordlist.hh",
          "type": "blob",
          "size": 0.9990234375,
          "content": "/* This file is (c) 2013 Tvangeste <i.4m.l33t@yandex.ru>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef WORDLIST_HH\n#define WORDLIST_HH\n\n#include <QListWidget>\n#include <QLineEdit>\n\n#include \"wordfinder.hh\"\n#include \"delegate.hh\"\n\nclass WordList : public QListWidget\n{\n  Q_OBJECT\npublic:\n  explicit WordList(QWidget * parent = 0);\n  void attachFinder(WordFinder * finder);\n  virtual void setTranslateLine(QLineEdit * line)\n  { translateLine = line; }\n\nprotected:\n  virtual void resizeEvent( QResizeEvent * ev );\n\nsignals:\n  void statusBarMessage(QString const & message, int timeout = 0, QPixmap const & pixmap = QPixmap());\n  void contentChanged();\n\npublic slots:\n\nprivate slots:\n  void prefixMatchUpdated();\n  void prefixMatchFinished();\n  void updateMatchResults( bool finished );\n\nprivate:\n  void refreshTranslateLine();\n\n  WordFinder * wordFinder;\n  QLineEdit * translateLine;\n  WordListItemDelegate listItemDelegate;\n\n  QVector< QSize > resizedSizes;\n};\n\n#endif // WORDLIST_HH\n"
        },
        {
          "name": "wstring.cc",
          "type": "blob",
          "size": 0.234375,
          "content": "#ifdef __WIN32\n\n#include \"wstring.hh\"\n#include \"iconv.hh\"\n#include <wchar.h>\n\nnamespace gd\n{\n  wstring __nativeToWs( wchar_t const * str )\n  {\n    return Iconv::toWstring( \"WCHAR_T\", str, wcslen( str ) * sizeof( wchar_t ) );\n  }\n}\n\n#endif\n\n"
        },
        {
          "name": "wstring.hh",
          "type": "blob",
          "size": 2.962890625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __WSTRING_HH_INCLUDED__\n#define __WSTRING_HH_INCLUDED__\n\n#include <string>\n\n/// While most systems feature a 4-byte wchar_t and an UCS-4 Unicode\n/// characters representation for it, Windows uses 2-byte wchar_t and an UTF-16\n/// encoding. The use of UTF-16 on Windows is most probably a homeage to an\n/// ancient history dating back to when there was nothing but a BMP, and\n/// all Unicode chars were 2 bytes long. After the Unicode got expanded past\n/// two-byte representation, the guys at Microsoft had probably decided that\n/// the least painful way to go is to just switch to UTF-16. Or so's the theory.\n/// \n/// Now, the UTF family is an encoding, made for transit purposes -- is not a\n/// representation. While it's good for passthrough, it's not directly\n/// applicable for manipulation on Unicode symbols. It must be decoded first to\n/// a normal UCS. Think like this: UTF to UCS is something like Base64 to ASCII.\n/// \n/// The distinction between Microsoft platform and all other ones is that while\n/// the latters are stuck in an 8-bit era and use UTF-8 to pass unicode around\n/// through its venerable interfaces, the former one is stuck in a 16-bit era,\n/// and uses UTF-16 instead. Neither solution allows for direct processing of\n/// the symbols in those strings without decoding them first. And the 16-bit\n/// solution is even more ugly than the 8-bit one, because it doesn't have a\n/// benefit of ASCII compatibility, having a much more useless UCS-2\n/// compatibility instead. It's stuck in the middle of nowhere, really.\n/// \n/// The question is, what are we going to do with all this? When we do Unicode\n/// processing in GoldenDict, we want to use real Unicode characters, not some\n/// UTF-16 encoded ones. To that end, we have two options under Windows: first,\n/// use QString, and second, use basic_string< unsigned int >.\n/// While we use QStrings for the GUI and other non-critical code, there is a\n/// serious doubt on the efficiency of QStrings for bulk text processing. And\n/// since a lot of code uses wstring already, it would be much easier to convert\n/// it to use basic_string< unsigned int > instead, since it shares the same\n/// template, and therefore the interface too, with wstring. That's why we\n/// introduce our own gd::wstring and gd::wchar types here. On all systems but\n/// Windows, they are equivalent to std::wstring and wchar_t. On Windows, they\n/// are basic_string< unsigned int > and unsigned int.\n\nnamespace gd\n{\n  #ifdef __WIN32\n\n  typedef unsigned int wchar;\n  typedef std::basic_string< wchar > wstring;\n\n  // GD_NATIVE_TO_WS is used to convert L\"\" strings to a const pointer to\n  // wchar.\n  wstring __nativeToWs( wchar_t const * );\n  #define GD_NATIVE_TO_WS( str ) ( gd::__nativeToWs( ( str ) ).c_str() )\n\n  #else\n\n  typedef wchar_t wchar;\n  using std::wstring;\n  #define GD_NATIVE_TO_WS( str ) ( str )\n  #endif\n}\n\n#endif\n"
        },
        {
          "name": "wstring_qt.cc",
          "type": "blob",
          "size": 0.8974609375,
          "content": "#include \"wstring_qt.hh\"\n#include <QVector>\n\nnamespace gd\n{\n  #ifdef __WIN32\n\n  QString toQString( wstring const & in )\n  {\n    return QString::fromUcs4( in.c_str() );\n  }\n\n  #else\n\n  QString toQString( wstring const & in )\n  {\n    return QString::fromStdWString( in );\n  }\n\n  #endif\n\n  wstring toWString( QString const & in )\n  {\n    QVector< unsigned int > v = in.toUcs4();\n\n    // Fix for QString instance which contains non-BMP characters\n    // Qt will created unexpected null characters may confuse btree indexer.\n    // Related: https://bugreports.qt-project.org/browse/QTBUG-25536\n    int n = v.size();\n    while ( n > 0 && v[ n - 1 ] == 0 ) n--;\n    if ( n != v.size() )\n      v.resize( n );\n\n    return wstring( ( const wchar * ) v.constData(), v.size() );\n  }\n\n  wstring normalize( const wstring & str )\n  {\n    return gd::toWString( gd::toQString( str ).normalized( QString::NormalizationForm_C ) );\n  }\n\n}\n"
        },
        {
          "name": "wstring_qt.hh",
          "type": "blob",
          "size": 0.5107421875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __WSTRING_QT_HH_INCLUDED__\n#define __WSTRING_QT_HH_INCLUDED__\n\n/// This file adds conversions between gd::wstring and QString. See wstring.hh\n/// for more details on gd::wstring.\n\n#include \"wstring.hh\"\n#include <QString>\n\nnamespace gd\n{\n  QString toQString( wstring const & );\n  wstring toWString( QString const & );\n  wstring normalize( wstring const & );\n}\n\n#endif\n"
        },
        {
          "name": "x64.cc",
          "type": "blob",
          "size": 1.82421875,
          "content": "#include <QCoreApplication>\n#include <QDir>\n\n#ifndef _UNICODE\n#define _UNICODE\n#endif\n\n#include \"x64.hh\"\n#include <windows.h>\n#include <tchar.h>\n\ntypedef BOOL (WINAPI *LPFN_ISWOW64PROCESS) (HANDLE, PBOOL);\nPROCESS_INFORMATION pInfo;\n\n#ifndef Q_OS_WIN64\nbool isWow64()\n{\n    static LPFN_ISWOW64PROCESS fnIsWow64Process;\n    BOOL bIsWow64 = FALSE;\n\n    if( NULL == fnIsWow64Process )\n        fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress( GetModuleHandle( _T(\"kernel32\") ), \"IsWow64Process\" );\n    if( NULL != fnIsWow64Process )\n    {\n        if ( !fnIsWow64Process( GetCurrentProcess(), &bIsWow64 ) )\n            return false;\n    }\n    return bIsWow64;\n}\n#endif\n\nbool installx64Hooks()\n{\nSTARTUPINFO startup;\n#ifndef Q_OS_WIN64\n    if( !isWow64() )\n        return false;\n#endif\n    if( pInfo.hProcess != NULL )\n        removex64Hooks();\n    QDir dir =  QCoreApplication::applicationDirPath();\n#ifdef Q_OS_WIN64\n    if( !dir.cd(\"x86\") )\n        return false;\n    QString starterProc = QDir::toNativeSeparators( dir.filePath( \"x86helper.exe\" ) );\n#else\n    if( !dir.cd(\"x64\") )\n        return false;\n    QString starterProc = QDir::toNativeSeparators( dir.filePath( \"x64helper.exe\" ) );\n#endif\n\n    memset( &startup, 0, sizeof(startup) );\n    startup.cb = sizeof(startup);\n\n    BOOL b = CreateProcess( starterProc.toStdWString().c_str(), NULL, NULL, NULL, FALSE, CREATE_NO_WINDOW | DETACHED_PROCESS, NULL, NULL, &startup, &pInfo );\n    if( !b )\n        pInfo.hProcess = NULL;\n\n    return b;\n}\n\nvoid removex64Hooks()\n{\n    if( pInfo.hProcess == NULL )\n        return;\n    PostThreadMessage( pInfo.dwThreadId, WM_QUIT, 0, 0 );\n    DWORD res = WaitForSingleObject( pInfo.hProcess, 3000 );\n    if( res == WAIT_TIMEOUT )\n        TerminateProcess( pInfo.hProcess, 1 );\n    CloseHandle( pInfo.hProcess );\n    CloseHandle( pInfo.hThread );\n    pInfo.hProcess = NULL;\n}\n"
        },
        {
          "name": "x64.hh",
          "type": "blob",
          "size": 0.1474609375,
          "content": "#ifndef __X64_HH_INCLUDED__\n#define __X64_HH_INCLUDED__\n\nbool isWow64();\nbool installx64Hooks();\nvoid removex64Hooks();\n\n#endif // __X64_HH_INCLUDED__\n"
        },
        {
          "name": "xdxf.cc",
          "type": "blob",
          "size": 43.5703125,
          "content": "/* This file is (c) 2008-2009 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"xdxf.hh\"\n#include \"btreeidx.hh\"\n#include \"folding.hh\"\n#include \"utf8.hh\"\n#include \"chunkedstorage.hh\"\n#include \"dictzip.h\"\n#include \"htmlescape.hh\"\n#include \"fsencoding.hh\"\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\n#include <list>\n#include <wctype.h>\n#include <stdlib.h>\n#include \"categorized_logging.hh\"\n#include \"gddebug.hh\"\n#include \"wstring_qt.hh\"\n#include \"xdxf2html.hh\"\n#include \"ufile.hh\"\n#include \"dictzip.h\"\n#include \"langcoder.hh\"\n#include \"indexedzip.hh\"\n#include \"filetype.hh\"\n#include \"tiff.hh\"\n#include \"ftshelpers.hh\"\n\n#ifdef _MSC_VER\n#include <stub_msvc.h>\n#endif\n\n#include <QIODevice>\n#include <QXmlStreamReader>\n#include <QTextDocument>\n#include <QFileInfo>\n#include <QDir>\n#include <QPainter>\n#include <QDebug>\n#include <QRegExp>\n\n#include <QSemaphore>\n#include <QThreadPool>\n#include <QAtomicInt>\n\n#include \"qt4x5.hh\"\n\nnamespace Xdxf {\n\nusing std::map;\nusing std::multimap;\nusing std::pair;\nusing std::set;\nusing std::string;\nusing gd::wstring;\nusing std::vector;\nusing std::list;\n\nusing BtreeIndexing::WordArticleLink;\nusing BtreeIndexing::IndexedWords;\nusing BtreeIndexing::IndexInfo;\n\nquint32 getLanguageId( const QString & lang )\n{\n  QString lstr = lang.left( 3 );\n\n  if( lstr.endsWith( QChar( '-' ) ) )\n    lstr.chop( 1 );\n\n  switch( lstr.size() )\n  {\n    case 2: return LangCoder::code2toInt( lstr.toLatin1().data() );\n    case 3: return LangCoder::findIdForLanguageCode3( lstr.toLatin1().data() );\n  }\n\n  return 0;\n}\n\nnamespace {\n\nDEF_EX_STR( exCantReadFile, \"Can't read file\", Dictionary::Ex )\nDEF_EX_STR( exNotXdxfFile, \"The file is not an XDXF file:\", Dictionary::Ex )\nDEF_EX( exCorruptedIndex, \"The index file is corrupted\", Dictionary::Ex )\nDEF_EX_STR( exDictzipError, \"DICTZIP error\", Dictionary::Ex )\n\nenum\n{\n  Signature = 0x46584458, // XDXF on little-endian, FXDX on big-endian\n  CurrentFormatVersion = 6 + BtreeIndexing::FormatVersion + Folding::Version\n};\n\nenum ArticleFormat\n{\n  Default = 0,\n  Visual = 1,\n  Logical = 2\n};\n\nstruct IdxHeader\n{\n  uint32_t signature; // First comes the signature, XDXF\n  uint32_t formatVersion; // File format version (CurrentFormatVersion)\n  uint32_t articleFormat; // ArticleFormat value, except that 0 = bad file\n  uint32_t langFrom; // Source language\n  uint32_t langTo;   // Target language\n  uint32_t articleCount; // Total number of articles\n  uint32_t wordCount; // Total number of words\n  uint32_t nameAddress; // Address of an utf8 name string, in chunks\n  uint32_t nameSize; // And its size\n  uint32_t descriptionAddress; // Address of an utf8 description string, in chunks\n  uint32_t descriptionSize; // And its size\n  uint32_t hasAbrv; // Non-zero means file has abrvs at abrvAddress\n  uint32_t abrvAddress; // Address of abrv map in the chunked storage\n  uint32_t chunksOffset; // The offset to chunks' storage\n  uint32_t indexBtreeMaxElements; // Two fields from IndexInfo\n  uint32_t indexRootOffset;\n  uint32_t hasZipFile; // Non-zero means there's a zip file with resources\n                       // present\n  uint32_t zipIndexBtreeMaxElements; // Two fields from IndexInfo of the zip\n                                     // resource index.\n  uint32_t zipIndexRootOffset;\n  uint32_t revisionNumber; // Format revision \n}\n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\nbool indexIsOldOrBad( string const & indexFile )\n{\n  File::Class idx( indexFile, \"rb\" );\n\n  IdxHeader header;\n\n  return idx.readRecords( &header, sizeof( header ), 1 ) != 1 ||\n         header.signature != Signature ||\n         header.formatVersion != CurrentFormatVersion ||\n         !header.articleFormat;\n}\n\n\n\nclass XdxfDictionary: public BtreeIndexing::BtreeDictionary\n{\n  Mutex idxMutex;\n  File::Class idx;\n  IdxHeader idxHeader;\n  sptr< ChunkedStorage::Reader > chunks;\n  Mutex dzMutex;\n  dictData * dz;\n  Mutex resourceZipMutex;\n  IndexedZip resourceZip;\n  string dictionaryName;\n  map< string, string > abrv;\n\npublic:\n\n  XdxfDictionary( string const & id, string const & indexFile,\n                   vector< string > const & dictionaryFiles );\n\n  ~XdxfDictionary();\n\n  virtual string getName() throw()\n  { return dictionaryName; }\n\n  virtual map< Dictionary::Property, string > getProperties() throw()\n  { return map< Dictionary::Property, string >(); }\n\n  virtual unsigned long getArticleCount() throw()\n  { return idxHeader.articleCount; }\n\n  virtual unsigned long getWordCount() throw()\n  { return idxHeader.wordCount; }\n\n  inline virtual quint32 getLangFrom() const\n  { return idxHeader.langFrom; }\n\n  inline virtual quint32 getLangTo() const\n  { return idxHeader.langTo; }\n\n  virtual sptr< Dictionary::DataRequest > getArticle( wstring const &,\n                                                      vector< wstring > const & alts,\n                                                      wstring const &,\n                                                      bool ignoreDiacritics )\n    THROW_SPEC( std::exception );\n\n  virtual sptr< Dictionary::DataRequest > getResource( string const & name )\n    THROW_SPEC( std::exception );\n\n  virtual QString const& getDescription();\n\n  virtual QString getMainFilename();\n\n  virtual sptr< Dictionary::DataRequest > getSearchResults( QString const & searchString,\n                                                            int searchMode, bool matchCase,\n                                                            int distanceBetweenWords,\n                                                            int maxResults,\n                                                            bool ignoreWordsOrder,\n                                                            bool ignoreDiacritics,\n                                                            QThreadPool * ftsThreadPoolPtr );\n  virtual void getArticleText( uint32_t articleAddress, QString & headword, QString & text );\n\n  virtual void makeFTSIndex(QAtomicInt & isCancelled, bool firstIteration );\n\n  virtual void setFTSParameters( Config::FullTextSearch const & fts )\n  {\n    can_FTS = fts.enabled\n              && !fts.disabledTypes.contains( \"XDXF\", Qt::CaseInsensitive )\n              && ( fts.maxDictionarySize == 0 || getArticleCount() <= fts.maxDictionarySize );\n  }\n\n  virtual uint32_t getFtsIndexVersion()\n  { return 1; }\n\nprotected:\n\n  void loadIcon() throw();\n\nprivate:\n\n  // Loads the article, storing its headword and formatting article's data into an html.\n  void loadArticle( uint32_t address,\n                    string & articleText, QString * headword = 0 );\n\n  friend class XdxfArticleRequest;\n  friend class XdxfResourceRequest;\n};\n\nXdxfDictionary::XdxfDictionary( string const & id,\n                                string const & indexFile,\n                                vector< string > const & dictionaryFiles ):\n  BtreeDictionary( id, dictionaryFiles ),\n  idx( indexFile, \"rb\" ),\n  idxHeader( idx.read< IdxHeader >() )\n{\n  // Read the dictionary name\n\n  chunks = new ChunkedStorage::Reader( idx, idxHeader.chunksOffset );\n\n  if ( idxHeader.nameSize )\n  {\n    vector< char > chunk;\n\n    dictionaryName = string( chunks->getBlock( idxHeader.nameAddress, chunk ),\n                             idxHeader.nameSize );\n  }\n\n  // Open the file\n\n  DZ_ERRORS error;\n  dz = dict_data_open( dictionaryFiles[ 0 ].c_str(), &error, 0 );\n\n  if ( !dz )\n    throw exDictzipError( string( dz_error_str( error ) )\n                          + \"(\" + dictionaryFiles[ 0 ] + \")\" );\n\n  // Read the abrv, if any\n\n  if ( idxHeader.hasAbrv )\n  {\n    vector< char > chunk;\n\n    char * abrvBlock = chunks->getBlock( idxHeader.abrvAddress, chunk );\n\n    uint32_t total;\n    memcpy( &total, abrvBlock, sizeof( uint32_t ) );\n    abrvBlock += sizeof( uint32_t );\n\n    while( total-- )\n    {\n      uint32_t keySz;\n      memcpy( &keySz, abrvBlock, sizeof( uint32_t ) );\n      abrvBlock += sizeof( uint32_t );\n\n      char * key = abrvBlock;\n\n      abrvBlock += keySz;\n\n      uint32_t valueSz;\n      memcpy( &valueSz, abrvBlock, sizeof( uint32_t ) );\n      abrvBlock += sizeof( uint32_t );\n\n      abrv[ string( key, keySz ) ] = string( abrvBlock, valueSz );\n\n      abrvBlock += valueSz;\n    }\n\n    // Open a resource zip file, if there's one\n\n    if ( idxHeader.hasZipFile &&\n         ( idxHeader.zipIndexBtreeMaxElements ||\n           idxHeader.zipIndexRootOffset ) )\n    {\n      resourceZip.openIndex( IndexInfo( idxHeader.zipIndexBtreeMaxElements,\n                                        idxHeader.zipIndexRootOffset ),\n                             idx, idxMutex );\n\n      QString zipName = QDir::fromNativeSeparators(\n          FsEncoding::decode( getDictionaryFilenames().back().c_str() ) );\n\n      if ( zipName.endsWith( \".zip\", Qt::CaseInsensitive ) ) // Sanity check\n        resourceZip.openZipFile( zipName );\n    }\n  }\n\n  // Initialize the index\n\n  openIndex( IndexInfo( idxHeader.indexBtreeMaxElements,\n                        idxHeader.indexRootOffset ),\n             idx, idxMutex );\n\n  // Full-text search parameters\n\n  can_FTS = true;\n\n  ftsIdxName = indexFile + \"_FTS\";\n\n  if( !Dictionary::needToRebuildIndex( dictionaryFiles, ftsIdxName )\n      && !FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) )\n    FTS_index_completed.ref();\n}\n\nXdxfDictionary::~XdxfDictionary()\n{\n  if ( dz )\n    dict_data_close( dz );\n}\n\nvoid XdxfDictionary::loadIcon() throw()\n{\n  if ( dictionaryIconLoaded )\n    return;\n\n  QString fileName =\n    QDir::fromNativeSeparators( FsEncoding::decode( getDictionaryFilenames()[ 0 ].c_str() ) );\n\n  QFileInfo baseInfo( fileName );\n\n  fileName = baseInfo.absoluteDir().absoluteFilePath( \"icon32.png\" );\n  QFileInfo info( fileName );\n\n  if( !info.isFile() )\n  {\n      fileName = baseInfo.absoluteDir().absoluteFilePath( \"icon16.png\" );\n      info = QFileInfo( fileName );\n  }\n\n  if ( info.isFile() )\n    loadIconFromFile( fileName, true );\n\n  if ( dictionaryIcon.isNull() )\n  {\n    // Load failed -- use default icons\n\n    dictionaryIcon = QIcon(\":/icons/icon32_xdxf.png\");\n    dictionaryNativeIcon = QIcon(\":/icons/icon32_xdxf.png\");\n  }\n\n  dictionaryIconLoaded = true;\n}\n\nQString const& XdxfDictionary::getDescription()\n{\n    if( !dictionaryDescription.isEmpty() )\n        return dictionaryDescription;\n\n    if( idxHeader.descriptionAddress == 0 )\n        dictionaryDescription = \"NONE\";\n    else\n    {\n        try\n        {\n            vector< char > chunk;\n            char * descr;\n            {\n              Mutex::Lock _( idxMutex );\n              descr = chunks->getBlock( idxHeader.descriptionAddress, chunk );\n            }\n            dictionaryDescription = QString::fromUtf8( descr, idxHeader.descriptionSize );\n        }\n        catch(...)\n        {\n        }\n    }\n    return dictionaryDescription;\n}\n\nQString XdxfDictionary::getMainFilename()\n{\n  return FsEncoding::decode( getDictionaryFilenames()[ 0 ].c_str() );\n}\n\nvoid XdxfDictionary::makeFTSIndex( QAtomicInt & isCancelled, bool firstIteration )\n{\n  if( !( Dictionary::needToRebuildIndex( getDictionaryFilenames(), ftsIdxName )\n         || FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) ) )\n    FTS_index_completed.ref();\n\n  if( haveFTSIndex() )\n    return;\n\n  if( ensureInitDone().size() )\n    return;\n\n  if( firstIteration && getArticleCount() > FTS::MaxDictionarySizeForFastSearch )\n    return;\n\n  gdDebug( \"Xdxf: Building the full-text index for dictionary: %s\\n\",\n           getName().c_str() );\n\n  try\n  {\n    FtsHelpers::makeFTSIndex( this, isCancelled );\n    FTS_index_completed.ref();\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"Xdxf: Failed building full-text search index for \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n    QFile::remove( FsEncoding::decode( ftsIdxName.c_str() ) );\n  }\n}\n\nvoid XdxfDictionary::getArticleText( uint32_t articleAddress, QString & headword, QString & text )\n{\n  try\n  {\n    string articleStr;\n    loadArticle( articleAddress, articleStr, &headword );\n\n    wstring wstr = Utf8::decode( articleStr );\n\n    text = Html::unescape( gd::toQString( wstr ) );\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"Xdxf: Failed retrieving article from \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n  }\n}\n\nsptr< Dictionary::DataRequest > XdxfDictionary::getSearchResults( QString const & searchString,\n                                                                  int searchMode, bool matchCase,\n                                                                  int distanceBetweenWords,\n                                                                  int maxResults,\n                                                                  bool ignoreWordsOrder,\n                                                                  bool ignoreDiacritics,\n                                                                  QThreadPool * ftsThreadPoolPtr )\n{\n  return new FtsHelpers::FTSResultsRequest( *this, searchString,searchMode, matchCase, distanceBetweenWords, maxResults, ignoreWordsOrder, ignoreDiacritics, ftsThreadPoolPtr );\n}\n\n/// XdxfDictionary::getArticle()\n\nclass XdxfArticleRequest;\n\nclass XdxfArticleRequestRunnable: public QRunnable\n{\n  XdxfArticleRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  XdxfArticleRequestRunnable( XdxfArticleRequest & r_,\n                                  QSemaphore & hasExited_ ): r( r_ ),\n                                                             hasExited( hasExited_ )\n  {}\n\n  ~XdxfArticleRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass XdxfArticleRequest: public Dictionary::DataRequest\n{\n  friend class XdxfArticleRequestRunnable;\n\n  wstring word;\n  vector< wstring > alts;\n  XdxfDictionary & dict;\n  bool ignoreDiacritics;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  XdxfArticleRequest( wstring const & word_,\n                     vector< wstring > const & alts_,\n                     XdxfDictionary & dict_, bool ignoreDiacritics_ ):\n    word( word_ ), alts( alts_ ), dict( dict_ ), ignoreDiacritics( ignoreDiacritics_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new XdxfArticleRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by XdxfArticleRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~XdxfArticleRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid XdxfArticleRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid XdxfArticleRequest::run()\n{\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  vector< WordArticleLink > chain = dict.findArticles( word, ignoreDiacritics );\n\n  for( unsigned x = 0; x < alts.size(); ++x )\n  {\n    /// Make an additional query for each alt\n\n    vector< WordArticleLink > altChain = dict.findArticles( alts[ x ], ignoreDiacritics );\n\n    chain.insert( chain.end(), altChain.begin(), altChain.end() );\n  }\n\n  multimap< wstring, pair< string, string > > mainArticles, alternateArticles;\n\n  set< uint32_t > articlesIncluded; // Some synonims make it that the articles\n                                    // appear several times. We combat this\n                                    // by only allowing them to appear once.\n\n  wstring wordCaseFolded = Folding::applySimpleCaseOnly( word );\n  if( ignoreDiacritics )\n    wordCaseFolded = Folding::applyDiacriticsOnly( wordCaseFolded );\n\n  for( unsigned x = 0; x < chain.size(); ++x )\n  {\n    if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    {\n      finish();\n      return;\n    }\n\n    if ( articlesIncluded.find( chain[ x ].articleOffset ) != articlesIncluded.end() )\n      continue; // We already have this article in the body.\n\n    // Now grab that article\n\n    string headword, articleText;\n\n    headword = chain[ x ].word;\n\n    try\n    {\n      dict.loadArticle( chain[ x ].articleOffset, articleText );\n\n      // Ok. Now, does it go to main articles, or to alternate ones? We list\n      // main ones first, and alternates after.\n\n      // We do the case-folded comparison here.\n\n      wstring headwordStripped =\n        Folding::applySimpleCaseOnly( Utf8::decode( headword ) );\n      if( ignoreDiacritics )\n        headwordStripped = Folding::applyDiacriticsOnly( headwordStripped );\n\n      multimap< wstring, pair< string, string > > & mapToUse =\n        ( wordCaseFolded == headwordStripped ) ?\n          mainArticles : alternateArticles;\n\n      mapToUse.insert( pair< wstring, pair< string, string > >(\n        Folding::applySimpleCaseOnly( Utf8::decode( headword ) ),\n        pair< string, string >( headword, articleText ) ) );\n\n      articlesIncluded.insert( chain[ x ].articleOffset );\n    }\n    catch( std::exception &ex )\n    {\n      gdWarning( \"XDXF: Failed loading article from \\\"%s\\\", reason: %s\\n\", dict.getName().c_str(), ex.what() );\n    }\n  }\n\n  if ( mainArticles.empty() && alternateArticles.empty() )\n  {\n    // No such word\n    finish();\n    return;\n  }\n\n  string result;\n\n  multimap< wstring, pair< string, string > >::const_iterator i;\n\n  string cleaner = \"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\n                   \"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\n                   \"</b></b></b></b></b></b></b></b>\"\n                   \"</i></i></i></i></i></i></i></i>\";\n\n  for( i = mainArticles.begin(); i != mainArticles.end(); ++i )\n  {\n//      result += \"<h3>\";\n//      result += i->second.first;\n//      result += \"</h3>\";\n      result += i->second.second;\n      result += cleaner;\n  }\n\n  for( i = alternateArticles.begin(); i != alternateArticles.end(); ++i )\n  {\n//      result += \"<h3>\";\n//      result += i->second.first;\n//      result += \"</h3>\";\n      result += i->second.second;\n      result += cleaner;\n  }\n\n  Mutex::Lock _( dataMutex );\n\n  data.resize( result.size() );\n\n  memcpy( &data.front(), result.data(), result.size() );\n\n  hasAnyData = true;\n\n  finish();\n}\n\nsptr< Dictionary::DataRequest > XdxfDictionary::getArticle( wstring const & word,\n                                                            vector< wstring > const & alts,\n                                                            wstring const &,\n                                                            bool ignoreDiacritics )\n  THROW_SPEC( std::exception )\n{\n  return new XdxfArticleRequest( word, alts, *this, ignoreDiacritics );\n}\n\nvoid XdxfDictionary::loadArticle( uint32_t address,\n                                  string & articleText,\n                                  QString * headword )\n{\n  // Read the properties\n\n  vector< char > chunk;\n\n  char * propertiesData;\n\n  {\n    Mutex::Lock _( idxMutex );\n  \n    propertiesData = chunks->getBlock( address, chunk );\n  }\n\n  if ( &chunk.front() + chunk.size() - propertiesData < 9 )\n  {\n    articleText = string( \"<div class=\\\"xdxf\\\">Index seems corrupted</div>\" );\n    return;\n  }\n\n  unsigned char fType = (unsigned char) *propertiesData;\n\n  uint32_t articleOffset, articleSize;\n\n  memcpy( &articleOffset, propertiesData + 1, sizeof( uint32_t ) );\n  memcpy( &articleSize, propertiesData + 5, sizeof( uint32_t ) );\n\n  // Load the article\n\n  char * articleBody;\n\n  {\n    Mutex::Lock _( dzMutex );\n\n    // Note that the function always zero-pads the result.\n    articleBody = dict_data_read_( dz, articleOffset, articleSize, 0, 0 );\n  }\n\n  if ( !articleBody )\n  {\n//    throw exCantReadFile( getDictionaryFilenames()[ 0 ] );\n      articleText = string( \"<div class=\\\"xdxf\\\">DICTZIP error: \" ) + dict_error_str( dz ) + \"</div>\";\n    return;\n  }\n\n  articleText = Xdxf2Html::convert( string( articleBody ), Xdxf2Html::XDXF, idxHeader.hasAbrv ? &abrv : NULL, this,\n                                    &resourceZip, fType == Logical, idxHeader.revisionNumber, headword );\n\n  free( articleBody );\n}\n\nclass GzippedFile: public QIODevice\n{\n  gzFile gz;\n\npublic:\n\n  GzippedFile( char const * fileName ) THROW_SPEC( exCantReadFile );\n\n  ~GzippedFile();\n\n//  size_t gzTell();\n\n  char * readDataArray( unsigned long startPos, unsigned long size );\n\nprotected:\n\n  dictData *dz;\n\n  virtual bool isSequential () const\n  { return false; } // Which is a lie, but else pos() won't work\n\n  bool waitForReadyRead ( int )\n  { return !gzeof( gz ); }\n\n  qint64 bytesAvailable() const\n  {\n     return ( gzeof( gz ) ? 0 : 1 ) + QIODevice::bytesAvailable();\n  }\n\n  virtual qint64 readData( char * data, qint64 maxSize );\n\n  virtual bool atEnd() const;\n\n  virtual qint64 writeData ( const char * /*data*/, qint64 /*maxSize*/ )\n  { return -1; }\n};\n\nGzippedFile::GzippedFile( char const * fileName ) THROW_SPEC( exCantReadFile )\n{\n  gz = gd_gzopen( fileName );\n  if ( !gz )\n    throw exCantReadFile( fileName );\n\n  DZ_ERRORS error;\n  dz = dict_data_open( fileName, &error, 0 );\n}\n\nGzippedFile::~GzippedFile()\n{\n  gzclose( gz );\n  if( dz )\n      dict_data_close( dz );\n}\n\nbool GzippedFile::atEnd() const\n{\n  return gzeof( gz );\n}\n\n/*\nsize_t GzippedFile::gzTell()\n{\n  return gztell( gz );\n}\n*/\n\nqint64 GzippedFile::readData( char * data, qint64 maxSize )\n{\n  if ( maxSize > 1 )\n    maxSize = 1;\n\n  // The returning value translates directly to QIODevice semantics\n  int n = gzread( gz, data, maxSize );\n\n#if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)\n  // With QT 5.x QXmlStreamReader ask one byte instead of one UTF-8 char.\n  // We read and return all bytes for char.\n\n  if( n == 1 )\n  {\n    char ch = *data;\n    int addBytes = 0;\n    if( ch & 0x80 )\n    {\n      if( ( ch & 0xF8 ) == 0xF0 )\n        addBytes = 3;\n      else if( ( ch & 0xF0 ) == 0xE0 )\n        addBytes = 2;\n      else if( ( ch & 0xE0 ) == 0xC0 )\n        addBytes = 1;\n    }\n\n    if( addBytes )\n      n += gzread( gz, data + 1, addBytes );\n  }\n#endif\n\n  return n;\n}\n\nchar * GzippedFile::readDataArray( unsigned long startPos, unsigned long size )\n{\n  if( dz == NULL )\n      return NULL;\n  return dict_data_read_( dz, startPos, size, 0, 0 );\n}\n\nQString readXhtmlData( QXmlStreamReader & stream )\n{\n  QString result;\n\n  while( !stream.atEnd() )\n  {\n    stream.readNext();\n\n    if ( stream.isStartElement() )\n    {\n      QString name = stream.name().toString();\n\n      result += \"<\" + Qt4x5::escape( name ) + \" \";\n\n      QXmlStreamAttributes attrs = stream.attributes();\n\n      for( int x = 0; x < attrs.size(); ++x )\n      {\n        result += Qt4x5::escape( attrs[ x ].name().toString() );\n        result += \"=\\\"\" + Qt4x5::escape( attrs[ x ].value().toString() ) + \"\\\"\";\n      }\n\n      result += \">\";\n\n      result += readXhtmlData( stream );\n\n      result += \"</\" + Qt4x5::escape( name ) + \">\";\n    }\n    else\n    if ( stream.isCharacters() || stream.isWhitespace() || stream.isCDATA() )\n    {\n      result += stream.text();\n    }\n    else\n    if ( stream.isEndElement() )\n      break;\n  }\n\n  return result;\n}\n\nnamespace {\n\n/// Deal with Qt 4.5 incompatibility\nQString readElementText( QXmlStreamReader & stream )\n{\n#if QT_VERSION >= 0x040600\n    return stream.readElementText( QXmlStreamReader::SkipChildElements );\n#else\n    return stream.readElementText();\n#endif\n}\n\n}\n\n\nvoid addAllKeyTags( QXmlStreamReader & stream, list< QString > & words )\n{\n  // todo implement support for tag <srt>, that overrides the article sorting order \n  if ( stream.name() == \"k\" )\n  {\n    words.push_back( readElementText( stream ) );\n    return;\n  }\n\n  while( !stream.atEnd() )\n  {\n    stream.readNext();\n  \n    if ( stream.isStartElement() )\n      addAllKeyTags( stream, words );\n    else\n    if ( stream.isEndElement() )\n      return;\n  }\n}\n\nvoid checkArticlePosition( GzippedFile & gzFile,\n                           uint32_t *pOffset,\n                           uint32_t *pSize )\n{\n    char * data = gzFile.readDataArray( *pOffset, *pSize );\n    if( data == NULL )\n        return;\n    QString s = QString::fromUtf8( data );\n    free( data );\n    int n = s.lastIndexOf( \"</ar\" );\n    if( n > 0 )\n        *pSize -= s.size() - n;\n    if( s.at( 0 ) == '>')\n    {\n        *pOffset += 1;\n        *pSize -= 1;\n    }\n}\n\nvoid indexArticle( GzippedFile & gzFile,\n                   QXmlStreamReader & stream,\n                   IndexedWords & indexedWords,\n                   ChunkedStorage::Writer & chunks,\n                   unsigned & articleCount,\n                   unsigned & wordCount,\n                   ArticleFormat defaultFormat )\n{\n  ArticleFormat format( Default );\n\n  QStringRef formatValue = stream.attributes().value( \"f\" );\n\n  if ( formatValue == \"v\" )\n    format = Visual;\n  else\n  if ( formatValue == \"l\" )\n    format = Logical;\n  if( format == Default )\n    format = defaultFormat; \n  size_t articleOffset = gzFile.pos() - 1; // stream.characterOffset() is loony\n\n  // uint32_t lineNumber = stream.lineNumber();\n  // uint32_t columnNumber = stream.columnNumber();\n\n  list< QString > words;\n\n  while( !stream.atEnd() )\n  {\n    stream.readNext();\n\n    // Find any <k> tags and index them\n    if ( stream.isEndElement() )\n    {\n      // End of the <ar> tag\n\n      if ( words.empty() )\n      {\n        // Nothing to index, this article didn't have any tags\n        gdWarning( \"No <k> tags found in an article at offset 0x%x, article skipped.\\n\",\n                  (unsigned) articleOffset );\n      }\n      else\n      {\n        // Add an entry\n\n        uint32_t offset = chunks.startNewBlock();\n\n        uint32_t offs = articleOffset;\n        uint32_t size = gzFile.pos() - 1 - articleOffset;\n\n        checkArticlePosition( gzFile, &offs, &size );\n\n        unsigned char f = format;\n        chunks.addToBlock( &f, 1 );\n        chunks.addToBlock( &offs, sizeof( offs ) );\n        chunks.addToBlock( &size, sizeof( size ) );\n\n        // Add also first header - it's needed for full-text search\n        chunks.addToBlock( words.begin()->toUtf8().data(), words.begin()->toUtf8().length() + 1 );\n\n//        DPRINTF( \"%x: %s\\n\", articleOffset, words.begin()->toUtf8().data() );\n\n        // Add words to index\n\n        for( list< QString >::const_iterator i = words.begin(); i != words.end();\n             ++i )\n            indexedWords.addWord( gd::toWString( *i ), offset );\n\n        ++articleCount;\n\n        wordCount += words.size();\n      }\n\n      return;\n    }\n    else\n    if ( stream.isStartElement() )\n    {\n      addAllKeyTags( stream, words );\n    }\n  }\n}\n\n//// XdxfDictionary::getResource()\n\nclass XdxfResourceRequest;\n\nclass XdxfResourceRequestRunnable: public QRunnable\n{\n  XdxfResourceRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  XdxfResourceRequestRunnable( XdxfResourceRequest & r_,\n                               QSemaphore & hasExited_ ): r( r_ ),\n                                                          hasExited( hasExited_ )\n  {}\n\n  ~XdxfResourceRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass XdxfResourceRequest: public Dictionary::DataRequest\n{\n  friend class XdxfResourceRequestRunnable;\n\n  XdxfDictionary & dict;\n\n  string resourceName;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  XdxfResourceRequest( XdxfDictionary & dict_,\n                      string const & resourceName_ ):\n    dict( dict_ ),\n    resourceName( resourceName_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new XdxfResourceRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by XdxfResourceRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~XdxfResourceRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid XdxfResourceRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid XdxfResourceRequest::run()\n{\n  // Some runnables linger enough that they are cancelled before they start\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  if ( dict.ensureInitDone().size() )\n  {\n    setErrorString( QString::fromUtf8( dict.ensureInitDone().c_str() ) );\n    finish();\n    return;\n  }\n\n  string n =\n    FsEncoding::dirname( dict.getDictionaryFilenames()[ 0 ] ) +\n    FsEncoding::separator() +\n    FsEncoding::encode( resourceName );\n\n  GD_DPRINTF( \"n is %s\\n\", n.c_str() );\n\n  try\n  {\n    try\n    {\n      Mutex::Lock _( dataMutex );\n\n      File::loadFromFile( n, data );\n    }\n    catch( File::exCantOpen & )\n    {\n      n = dict.getDictionaryFilenames()[ 0 ] + \".files\" +\n          FsEncoding::separator() +\n          FsEncoding::encode( resourceName );\n\n      try\n      {\n        Mutex::Lock _( dataMutex );\n\n        File::loadFromFile( n, data );\n      }\n      catch( File::exCantOpen & )\n      {\n        // Try reading from zip file\n\n        if ( dict.resourceZip.isOpen() )\n        {\n          Mutex::Lock _( dict.resourceZipMutex );\n\n          Mutex::Lock __( dataMutex );\n\n          if ( !dict.resourceZip.loadFile( Utf8::decode( resourceName ), data ) )\n            throw; // Make it fail since we couldn't read the archive\n        }\n        else\n          throw;\n      }\n    }\n\n    if ( Filetype::isNameOfTiff( resourceName ) )\n    {\n      // Convert it\n\n      dataMutex.lock();\n\n      QImage img = QImage::fromData( (unsigned char *) &data.front(),\n                                     data.size() );\n\n#ifdef MAKE_EXTRA_TIFF_HANDLER\n      if( img.isNull() )\n        GdTiff::tiffToQImage( &data.front(), data.size(), img );\n#endif\n\n      dataMutex.unlock();\n\n      if ( !img.isNull() )\n      {\n        // Managed to load -- now store it back as BMP\n\n        QByteArray ba;\n        QBuffer buffer( &ba );\n        buffer.open( QIODevice::WriteOnly );\n        img.save( &buffer, \"BMP\" );\n\n        Mutex::Lock _( dataMutex );\n\n        data.resize( buffer.size() );\n\n        memcpy( &data.front(), buffer.data(), data.size() );\n      }\n    }\n\n    Mutex::Lock _( dataMutex );\n\n    hasAnyData = true;\n  }\n  catch( std::exception &ex )\n  {\n    gdCWarning( dictionaryResourceLc, \"XDXF: Failed loading resource \\\"%s\\\" for \\\"%s\\\", reason: %s\\n\",\n                resourceName.c_str(), dict.getName().c_str(), ex.what() );\n    // Resource not loaded -- we don't set the hasAnyData flag then\n  }\n\n  finish();\n}\n\nsptr< Dictionary::DataRequest > XdxfDictionary::getResource( string const & name )\n  THROW_SPEC( std::exception )\n{\n  return new XdxfResourceRequest( *this, name );\n}\n\n}\n// anonymous namespace - this section of file is devoted to rebuilding of dictionary articles index\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing & initializing )\n  THROW_SPEC( std::exception )\n{\n  vector< sptr< Dictionary::Class > > dictionaries;\n\n  for( vector< string >::const_iterator i = fileNames.begin(); i != fileNames.end();\n       ++i )\n  {\n    // Only allow .xdxf and .xdxf.dz suffixes\n\n    if ( ( i->size() < 5  || strcasecmp( i->c_str() + ( i->size() - 5 ), \".xdxf\" ) != 0 ) &&\n         ( i->size() < 8 ||\n           strcasecmp( i->c_str() + ( i->size() - 8 ), \".xdxf.dz\" ) != 0 ) )\n      continue;\n\n    try\n    {\n      vector< string > dictFiles( 1, *i );\n\n      string baseName = ( (*i)[ i->size() - 5 ] == '.' ) ?\n               string( *i, 0, i->size() - 5 ) : string( *i, 0, i->size() - 8 );\n\n      // See if there's a zip file with resources present. If so, include it.\n\n      string zipFileName;\n\n      if ( File::tryPossibleZipName( baseName + \".xdxf.files.zip\", zipFileName ) ||\n           File::tryPossibleZipName( baseName + \".xdxf.dz.files.zip\", zipFileName ) ||\n           File::tryPossibleZipName( baseName + \".XDXF.FILES.ZIP\", zipFileName ) ||\n           File::tryPossibleZipName( baseName + \".XDXF.DZ.FILES.ZIP\", zipFileName ) )\n        dictFiles.push_back( zipFileName );\n\n      string dictId = Dictionary::makeDictionaryId( dictFiles );\n\n      string indexFile = indicesDir + dictId;\n\n      if ( Dictionary::needToRebuildIndex( dictFiles, indexFile ) ||\n           indexIsOldOrBad( indexFile ) )\n      {\n        // Building the index\n\n        gdDebug( \"Xdxf: Building the index for dictionary: %s\\n\", i->c_str() );\n\n        //initializing.indexingDictionary( nameFromFileName( dictFiles[ 0 ] ) );\n\n        File::Class idx( indexFile, \"wb\" );\n\n        IdxHeader idxHeader;\n        map< string, string > abrv;\n\n        memset( &idxHeader, 0, sizeof( idxHeader ) );\n\n        // We write a dummy header first. At the end of the process the header\n        // will be rewritten with the right values.\n\n        idx.write( idxHeader );\n\n        IndexedWords indexedWords;\n\n        GzippedFile gzFile( dictFiles[ 0 ].c_str() );\n\n        if ( !gzFile.open( QIODevice::ReadOnly ) )\n          throw exCantReadFile( dictFiles[ 0 ] );\n\n        QXmlStreamReader stream( &gzFile );\n\n        QString dictionaryName, dictionaryDescription;\n\n        ChunkedStorage::Writer chunks( idx );\n\n        // Wait for the first element, which must be xdxf\n\n        bool hadXdxf = false;\n\n        while( !stream.atEnd() )\n        {\n          stream.readNext();\n\n          if ( stream.isStartElement() )\n          {\n            if ( stream.name() != \"xdxf\" )\n              throw exNotXdxfFile( dictFiles[ 0 ] );\n            else\n            {\n              // Read the xdxf\n\n              string str = stream.attributes().value( \"lang_from\" ).toString().toLatin1().data();\n              if( !str.empty() )\n                idxHeader.langFrom = getLanguageId( str.c_str() );\n\n              str = stream.attributes().value( \"lang_to\" ).toString().toLatin1().data();\n              if( !str.empty() )\n                idxHeader.langTo = getLanguageId( str.c_str() );\n\n              QRegExp regNum( \"\\\\d+\" );\n              regNum.indexIn( stream.attributes().value( \"revision\" ).toString() );\n              idxHeader.revisionNumber = regNum.cap().toUInt();\n\n              bool isLogical = ( stream.attributes().value( \"format\" ) == \"logical\" || idxHeader.revisionNumber >= 34 );\n\n              idxHeader.articleFormat = isLogical ? Logical : Visual;\n\n              unsigned articleCount = 0, wordCount = 0;\n\n              while( !stream.atEnd() )\n              {\n                stream.readNext();\n\n                if ( stream.isStartElement() )\n                {\n                  // todo implement using short <title> for denoting the dictionary in settings or dict list toolbar\n                  if ( stream.name() == \"full_name\" || stream.name() == \"full_title\" )\n                  {\n                    // That's our name\n\n                    QString name = stream.readElementText();\n\n                    if ( dictionaryName.isEmpty() )\n                    {\n                      dictionaryName = name;\n\n                      initializing.indexingDictionary( dictionaryName.toUtf8().data() );\n\n                      idxHeader.nameAddress = chunks.startNewBlock();\n\n                      QByteArray n = dictionaryName.toUtf8();\n\n                      idxHeader.nameSize = n.size();\n\n                      chunks.addToBlock( n.data(), n.size() );\n                    }\n                    else\n                    {\n                      GD_DPRINTF( \"Warning: duplicate full_name in %s\\n\", dictFiles[ 0 ].c_str() );\n                    }\n                  }\n                  else\n                  if ( stream.name() == \"description\" )\n                  {\n                    // todo implement adding other information to the description like <publisher>, <authors>, <file_ver>, <creation_date>, <last_edited_date>, <dict_edition>, <publishing_date>, <dict_src_url> \n                    QString desc = readXhtmlData( stream );\n\n                    if( isLogical )\n                    {\n                      desc = desc.simplified();\n                      desc.replace( QRegExp( \"<br\\\\s*>\\\\s*</br>\" ), QChar( '\\n' ) );\n                    }\n\n                    if ( dictionaryDescription.isEmpty() )\n                    {\n                      dictionaryDescription = desc;\n                      idxHeader.descriptionAddress = chunks.startNewBlock();\n\n                      QByteArray n = dictionaryDescription.toUtf8();\n\n                      idxHeader.descriptionSize = n.size();\n\n                      chunks.addToBlock( n.data(), n.size() );\n                    }\n                    else\n                    {\n                      GD_DPRINTF( \"Warning: duplicate description in %s\\n\", dictFiles[ 0 ].c_str() );\n                    }\n                  }\n                  else\n                  if( stream.name() == \"languages\" )\n                  {\n                    while( !( stream.isEndElement() && stream.name() == \"languages\" ) && !stream.atEnd() )\n                    {\n                      if( !stream.readNext() )\n                        break;\n                      if ( stream.isStartElement() )\n                      {\n                        if( stream.name() == \"from\" )\n                        {\n                          if( idxHeader.langFrom == 0 )\n                          {\n                            QString lang = stream.attributes().value( \"xml:lang\" ).toString();\n                            idxHeader.langFrom = getLanguageId( lang );\n                          }\n                        }\n                        else if( stream.name() == \"to\" )\n                        {\n                          if( idxHeader.langTo == 0 )\n                          {\n                            QString lang = stream.attributes().value( \"xml:lang\" ).toString();\n                            idxHeader.langTo = getLanguageId( lang );\n                          }\n                        }\n                      }\n                      else if ( stream.isEndElement() && stream.name() == \"languages\" )\n                        break;\n                    }\n                  }\n                  else\n                  if ( stream.name() == \"abbreviations\" )\n                  {\n                    QString s;\n                    string value;\n                    list < wstring > keys;\n                    while( !( stream.isEndElement() && stream.name() == \"abbreviations\" ) && !stream.atEnd() )\n                    {\n                      if( !stream.readNextStartElement() )\n                        break;\n                      // abbreviations tag set switch at format revision = 30\n                      if( idxHeader.revisionNumber >= 30 )\n                      {\n                        while ( !( stream.isEndElement() && stream.name() == \"abbr_def\" ) || !stream.atEnd() )\n                        {\n                          if ( stream.isStartElement() && stream.name() == \"abbr_k\" )\n                          {\n                            s = readElementText( stream );\n                            keys.push_back( gd::toWString( s ) );\n                          }\n                          else if ( stream.isStartElement() && stream.name() == \"abbr_v\" )\n                          {\n                            s =  readElementText( stream );\n                              value = Utf8::encode( Folding::trimWhitespace( gd::toWString( s ) ) );\n                              for( list< wstring >::iterator i = keys.begin(); i != keys.end(); ++i )\n                              {\n                                abrv[ Utf8::encode( Folding::trimWhitespace( *i ) ) ] = value;\n                              }\n                              keys.clear();\n                          }\n                          else if ( stream.isEndElement() && stream.name() == \"abbreviations\" )\n                            break;\n                          stream.readNext();\n                        }\n                      }\n                      else\n                      {\n                        while ( !( stream.isEndElement() && stream.name() == \"abr_def\" ) || !stream.atEnd() )\n                        {\n                          if ( stream.isStartElement() && stream.name() == \"k\" )\n                          {\n                            s = readElementText( stream );\n                            keys.push_back( gd::toWString( s ) );\n                          }\n                          else if ( stream.isStartElement() && stream.name() == \"v\" )\n                          {\n                            s =  readElementText( stream );\n                              value = Utf8::encode( Folding::trimWhitespace( gd::toWString( s ) ) );\n                              for( list< wstring >::iterator i = keys.begin(); i != keys.end(); ++i )\n                              {\n                                abrv[ Utf8::encode( Folding::trimWhitespace( *i ) ) ] = value;\n                              }\n                              keys.clear();\n                          }\n                          else if ( stream.isEndElement() && stream.name() == \"abbreviations\" )\n                            break;\n                          stream.readNext();\n                        }\n                      }\n                    }\n                  }\n                  else\n                  if ( stream.name() == \"ar\" )\n                  {\n                    indexArticle( gzFile, stream, indexedWords, chunks,\n                                  articleCount, wordCount, isLogical ? Logical : Visual );\n                  }\n                }\n              }\n\n              // Write abbreviations if presented\n\n              if( !abrv.empty() )\n              {\n                idxHeader.hasAbrv = 1;\n                idxHeader.abrvAddress = chunks.startNewBlock();\n\n                uint32_t sz = abrv.size();\n\n                chunks.addToBlock( &sz, sizeof( uint32_t ) );\n\n                for( map< string, string >::const_iterator i = abrv.begin();  i != abrv.end(); ++i )\n                {\n                  sz = i->first.size();\n                  chunks.addToBlock( &sz, sizeof( uint32_t ) );\n                  chunks.addToBlock( i->first.data(), sz );\n                  sz = i->second.size();\n                  chunks.addToBlock( &sz, sizeof( uint32_t ) );\n                  chunks.addToBlock( i->second.data(), sz );\n                }\n              }\n\n              // Finish with the chunks\n\n              idxHeader.chunksOffset = chunks.finish();\n\n              // Build index\n\n              IndexInfo idxInfo = BtreeIndexing::buildIndex( indexedWords, idx );\n\n              idxHeader.indexBtreeMaxElements = idxInfo.btreeMaxElements;\n              idxHeader.indexRootOffset = idxInfo.rootOffset;\n\n              indexedWords.clear(); // Release memory -- no need for this data\n\n              // If there was a zip file, index it too\n\n              if ( zipFileName.size() )\n              {\n                GD_DPRINTF( \"Indexing zip file\\n\" );\n\n                idxHeader.hasZipFile = 1;\n\n                IndexedWords zipFileNames;\n                IndexedZip zipFile;\n                if( zipFile.openZipFile( QDir::fromNativeSeparators(\n                                         FsEncoding::decode( zipFileName.c_str() ) ) ) )\n                    zipFile.indexFile( zipFileNames );\n\n                if( !zipFileNames.empty() )\n                {\n                  // Build the resulting zip file index\n\n                  IndexInfo idxInfo = BtreeIndexing::buildIndex( zipFileNames, idx );\n\n                  idxHeader.zipIndexBtreeMaxElements = idxInfo.btreeMaxElements;\n                  idxHeader.zipIndexRootOffset = idxInfo.rootOffset;\n                }\n                else\n                {\n                  // Bad zip file -- no index (though the mark that we have one\n                  // remains)\n                  idxHeader.zipIndexBtreeMaxElements = 0;\n                  idxHeader.zipIndexRootOffset = 0;\n                }\n              }\n              else\n                idxHeader.hasZipFile = 0;\n              // That concludes it. Update the header.\n\n              idxHeader.signature = Signature;\n              idxHeader.formatVersion = CurrentFormatVersion;\n\n              idxHeader.articleCount = articleCount;\n              idxHeader.wordCount = wordCount;\n\n              idx.rewind();\n\n              idx.write( &idxHeader, sizeof( idxHeader ) );\n\n              hadXdxf = true;\n            }\n            break;\n          }\n        }\n\n        if ( !hadXdxf )\n          throw exNotXdxfFile( dictFiles[ 0 ] );\n\n        if ( stream.hasError() )\n        {\n          gdWarning( \"%s had a parse error %s at line %lu, and therefore was indexed only up to the point of error.\",\n                      dictFiles[ 0 ].c_str(), stream.errorString().toUtf8().data(),\n                      (unsigned long) stream.lineNumber() );\n        }\n      }\n\n      dictionaries.push_back( new XdxfDictionary( dictId,\n                                                  indexFile,\n                                                  dictFiles ) );\n    }\n    catch( std::exception & e )\n    {\n      gdWarning( \"Xdxf dictionary initializing failed: %s, error: %s\\n\",\n                 i->c_str(), e.what() );\n    }\n  }\n\n  return dictionaries;\n}\n\n}\n"
        },
        {
          "name": "xdxf.hh",
          "type": "blob",
          "size": 0.671875,
          "content": "/* This file is (c) 2008-2009 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __XDXF_HH_INCLUDED__\n#define __XDXF_HH_INCLUDED__\n\n#include \"dictionary.hh\"\n\n/// Support for the XDXF (.xdxf(.dz)) files.\nnamespace Xdxf {\n\nusing std::vector;\nusing std::string;\n\nquint32 getLanguageId( const QString & lang );\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing & )\n    THROW_SPEC( std::exception );\n\n}\n\n#endif\n"
        },
        {
          "name": "xdxf2html.cc",
          "type": "blob",
          "size": 22.384765625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"xdxf2html.hh\"\n#include <QtXml>\n#include \"gddebug.hh\"\n#include \"utf8.hh\"\n#include \"wstring_qt.hh\"\n#include \"folding.hh\"\n#include \"fsencoding.hh\"\n#include \"audiolink.hh\"\n#include \"file.hh\"\n#include \"filetype.hh\"\n#include \"htmlescape.hh\"\n#include \"qt4x5.hh\"\n#include <QDebug>\n#include \"xdxf.hh\"\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n#include <QRegularExpression>\n#endif\n\nnamespace Xdxf2Html {\n\nstatic void fixLink( QDomElement & el, string const & dictId, const char *attrName )\n{\n  QUrl url;\n  url.setScheme( \"bres\" );\n  url.setHost( QString::fromStdString(dictId) );\n  url.setPath( Qt4x5::Url::ensureLeadingSlash( el.attribute(attrName) ) );\n\n  el.setAttribute( attrName, url.toEncoded().data() );\n}\n\n// converting a number into roman representation\nstring convertToRoman( int input, int lower_case )\n{\n    string romanvalue = \"\";\n    if( input >= 4000 )\n    {\n        int x = ( input - input % 4000 ) / 1000;\n        romanvalue = \"(\" + convertToRoman( x, lower_case ) + \")\" ;\n        input %= 4000;\n    }\n\n    const string roman[26] = { \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\",\n                               \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    const int decimal[13] =  {1000,  900, 500,  400, 100,   90,  50,   40,  10,    9,   5,    4,   1};\n\n    for( int i = 0; i < 13; i++ )\n    {\n      while( input >= decimal[ i ] )\n      {\n        input -= decimal[ i ];\n        if ( lower_case == 1 )\n          romanvalue += roman[ i + 13 ];\n        else\n          romanvalue += roman[ i ];\n      }\n    }\n    return romanvalue;\n}\n\nQDomElement fakeElement( QDomDocument & dom )\n{\n  // Create element which will be removed after\n  // We will insert it to empty elements to avoid output ones in <xxx/> form\n  return dom.createElement( \"b\" );\n}\n\nstring convert( string const & in, DICT_TYPE type, map < string, string > const * pAbrv,\n                Dictionary::Class *dictPtr,  IndexedZip * resourceZip,\n                bool isLogicalFormat, unsigned revisionNumber, QString * headword )\n{\n//  DPRINTF( \"Source>>>>>>>>>>: %s\\n\\n\\n\", in.c_str() );\n\n  // Convert spaces after each end of line to &nbsp;s, and then each end of\n  // line to a <br>\n\n  string inConverted;\n\n  inConverted.reserve( in.size() );\n\n  bool afterEol = false;\n\n  for( string::const_iterator i = in.begin(), j = in.end(); i != j; ++i )\n  {\n    switch( *i )\n    {\n      case '\\n':\n        afterEol = true;\n        if( !isLogicalFormat )\n          inConverted.append( \"<br/>\" );\n        break;\n\n      case '\\r':\n        break;\n\n      case ' ':\n        if ( afterEol )\n        {\n          if( !isLogicalFormat )\n            inConverted.append( \"&nbsp;\" ); \n          break;\n        }\n        // Fall-through\n\n      default:\n        inConverted.push_back( *i );\n        afterEol = false;\n    }\n  }\n\n  // Strip \"<nu />\" tags - QDomDocument don't handle it correctly\n  string::size_type n;\n  while( ( n = inConverted.find( \"<nu />\" ) ) != string::npos )\n      inConverted.erase( n, 6 );\n\n  // We build a dom representation of the given xml, then do some transforms\n  QDomDocument dd;\n\n  QString errorStr;\n  int errorLine, errorColumn;\n\n  string in_data;\n  if( type == XDXF )\n  {\n      in_data = \"<div class=\\\"xdxf\\\"\";\n      if( dictPtr->isToLanguageRTL() )\n        in_data += \" dir=\\\"rtl\\\"\";\n      in_data += \">\";\n  }\n  else\n      in_data = \"<div class=\\\"sdct_x\\\">\";\n  in_data += inConverted + \"</div>\";\n\n  if( !dd.setContent( QByteArray( in_data.c_str() ), false, &errorStr, &errorLine, &errorColumn  ) )\n  {\n    qWarning( \"Xdxf2html error, xml parse failed: %s at %d,%d\\n\", errorStr.toLocal8Bit().constData(),  errorLine,  errorColumn );\n    gdWarning( \"The input was: %s\\n\", in.c_str() );\n\n    return in;\n  }\n\n  QDomNodeList nodes = dd.elementsByTagName( \"ex\" ); // Example\n\n  while( nodes.size() )\n  {\n    QString author, source;\n    QDomElement el = nodes.at( 0 ).toElement();\n\n    author = el.attribute( \"author\", QString() );\n    source = el.attribute( \"source\", QString() );\n\n    if( el.hasChildNodes() )\n    {\n      QDomNodeList lst = el.childNodes();\n      for( int i = 0; i < lst.count(); ++i )\n      {\n        QDomElement el2 = el.childNodes().at( i ).toElement();\n        if( el2.tagName().compare( \"ex_orig\", Qt::CaseInsensitive ) == 0 )\n        {\n          el2.setTagName( \"span\" );\n          el2.setAttribute( \"class\", \"xdxf_ex_orig\" );\n        }\n        else if( el2.tagName().compare( \"ex_tran\", Qt::CaseInsensitive ) == 0 )\n        {\n          el2.setTagName( \"span\" );\n          el2.setAttribute( \"class\", \"xdxf_ex_tran\" );\n        }\n      }\n    }\n    if( ( !author.isEmpty() || !source.isEmpty() )\n        && ( !el.text().isEmpty() || !el.childNodes().isEmpty() ) )\n    {\n      QDomElement el2 = dd.createElement( \"span\" );\n      el2.setAttribute( \"class\", \"xdxf_ex_source\" );\n      QString text = author;\n      if( !source.isEmpty() )\n      {\n        if( !text.isEmpty() )\n          text += \", \";\n        text += source;\n      }\n      QDomText txtNode = dd.createTextNode( text );\n      el2.appendChild( txtNode );\n      el.appendChild( el2 );\n    }\n\n    if( el.text().isEmpty() && el.childNodes().isEmpty() )\n      el.appendChild( fakeElement( dd ) );\n\n    el.setTagName( \"span\" );\n    if( isLogicalFormat )\n      el.setAttribute( \"class\", \"xdxf_ex\" );\n    else\n      el.setAttribute( \"class\", \"xdxf_ex_old\" );\n  }\n  \n  nodes = dd.elementsByTagName( \"mrkd\" ); // marked out words in translations/examples of usage\n\n  while( nodes.size() )\n  {\n    QDomElement el = nodes.at( 0 ).toElement();\n\n    if( el.text().isEmpty() && el.childNodes().isEmpty() )\n      el.appendChild( fakeElement( dd ) );\n\n    el.setTagName( \"span\" );\n    el.setAttribute( \"class\", \"xdxf_ex_markd\" );\n  }\n\n  nodes = dd.elementsByTagName( \"k\" ); // Key\n\n  if( headword )\n    headword->clear();\n\n  while( nodes.size() )\n  {\n    QDomElement el = nodes.at( 0 ).toElement();\n\n    if( el.text().isEmpty() && el.childNodes().isEmpty() )\n      el.appendChild( fakeElement( dd ) );\n\n    if( type == STARDICT )\n    {\n        el.setTagName( \"span\" );\n        el.setAttribute( \"class\", \"xdxf_k\" );\n    }\n    else\n    {\n        if( headword && headword->isEmpty() )\n          *headword = el.text();\n\n        el.setTagName( \"div\" );\n        el.setAttribute( \"class\", \"xdxf_headwords\" );\n        bool isLanguageRtl = dictPtr->isFromLanguageRTL();\n        if( el.hasAttribute( \"xml:lang\" ) )\n        {\n          // Change xml-attribute \"xml:lang\" to html-attribute \"lang\"\n          QString lang = el.attribute( \"xml:lang\" );\n          el.removeAttribute( \"xml:lang\" );\n          el.setAttribute( \"lang\", lang );\n\n          quint32 langID = Xdxf::getLanguageId( lang );\n          if( langID )\n            isLanguageRtl = LangCoder::isLanguageRTL( langID );\n        }\n        if( isLanguageRtl != dictPtr->isToLanguageRTL() )\n          el.setAttribute( \"dir\", isLanguageRtl ? \"rtl\" : \"ltr\" );\n    }\n  }\n  \n  // processing of nested <def>s\n  if( isLogicalFormat ) // in articles with visual format <def> tags do not effect the formatting.\n  {\n    nodes = dd.elementsByTagName( \"def\" );\n    \n    // this is a logical type of XDXF, so we need to render proper numbering\n    // we will do it this way:\n    \n    // 1. we compute the maximum nesting depth of the article\n    int maxNestingDepth = 1; // maximum nesting depth of the article\n    for( int i = 0; i < nodes.size(); i++ )\n    {\n      QDomElement el = nodes.at( i ).toElement();\n      QDomElement nestingNode = el;\n      int nestingCount = 0;\n      while ( nestingNode.parentNode().toElement().tagName() == \"def\" )\n      {\n        nestingCount++;\n        nestingNode = nestingNode.parentNode().toElement();\n      }\n      if ( nestingCount > maxNestingDepth )\n        maxNestingDepth = nestingCount;\n    }\n    // 2. in this loop we go layer-by-layer through all <def> and insert proper numbers according to its structure\n    for( int j = maxNestingDepth; j > 0; j-- ) // j symbolizes special depth to be processed at this iteration\n    {\n      int siblingCount = 0; // this  that counts the number of among all siblings of this depth\n      QString numberText = \"\"; // the number to be inserted into the beginning of <def> (I,II,IV,1,2,3,a),b),c)...)\n      for( int i = 0; i < nodes.size(); i++ )\n      {\n        QDomElement el = nodes.at( i ).toElement();\n        QDomElement nestingNode = el;\n        // computing the depth @nestingDepth of a current node @el\n        int nestingDepth = 0;\n        while( nestingNode.parentNode().toElement().tagName() == \"def\" )\n        {\n          nestingDepth++;\n          nestingNode=nestingNode.parentNode().toElement();\n        } \n        // we process nodes on of current depth @j\n        // we do this in order not to break the numbering at this depth level\n        if (nestingDepth == j)\n        {\n          siblingCount++;\n          if( maxNestingDepth == 1 )\n          {\n            numberText = numberText.setNum( siblingCount ) + \". \";\n          }\n          else if( maxNestingDepth == 2 )\n          {\n            if( nestingDepth == 1 )\n              numberText = numberText.setNum( siblingCount ) + \". \";\n            if( nestingDepth == 2 )\n              numberText = numberText.setNum( siblingCount ) + \") \";\n          }\n          else\n          {\n            if( nestingDepth == 1 )\n              numberText = QString::fromStdString( convertToRoman(siblingCount,0) + \". \" );\n            if( nestingDepth == 2 )\n              numberText = numberText.setNum( siblingCount ) + \". \";\n            if( nestingDepth == 3 )\n              numberText = numberText.setNum( siblingCount ) + \") \";\n            if( nestingDepth == 4 )\n              numberText = QString::fromStdString( convertToRoman(siblingCount,1) + \") \" );\n          }\n          QDomElement numberNode = dd.createElement( \"span\" );\n          numberNode.setAttribute( \"class\", \"xdxf_num\" );\n          QDomText text_num = dd.createTextNode( numberText );\n          numberNode.appendChild( text_num );\n          el.insertBefore( numberNode, el.firstChild() );\n          \n          if ( el.hasAttribute( \"cmt\" ) )\n          {\n            QDomElement cmtNode = dd.createElement( \"span\" );\n            cmtNode.setAttribute( \"class\", \"xdxf_co\" );\n            QDomText text_num = dd.createTextNode( el.attribute( \"cmt\" ) );\n            cmtNode.appendChild( text_num );\n            el.insertAfter( cmtNode, el.firstChild() );\n          }\n        }\n        else if( nestingDepth < j ) // if it goes one level up @siblingCount needs to be reset\n          siblingCount = 0;\n      }\n    }\n    // we finally change all <def> tags into 'xdxf_def' <span>s\n    while( nodes.size() )\n    {\n      QDomElement el = nodes.at( 0 ).toElement();\n      el.setTagName( \"span\" );\n      el.setAttribute( \"class\", \"xdxf_def\" );\n      bool isLanguageRtl = dictPtr->isToLanguageRTL();\n      if( el.hasAttribute( \"xml:lang\" ) )\n      {\n        // Change xml-attribute \"xml:lang\" to html-attribute \"lang\"\n        QString lang = el.attribute( \"xml:lang\" );\n        el.removeAttribute( \"xml:lang\" );\n        el.setAttribute( \"lang\", lang );\n\n        quint32 langID = Xdxf::getLanguageId( lang );\n        if( langID )\n          isLanguageRtl = LangCoder::isLanguageRTL( langID );\n      }\n      if( isLanguageRtl != dictPtr->isToLanguageRTL() )\n        el.setAttribute( \"dir\", isLanguageRtl ? \"rtl\" : \"ltr\" );\n    }\n  }\n  \n  nodes = dd.elementsByTagName( \"opt\" ); // Optional headword part\n\n  while( nodes.size() )\n  {\n    QDomElement el = nodes.at( 0 ).toElement();\n\n    if( el.text().isEmpty() && el.childNodes().isEmpty() )\n      el.appendChild( fakeElement( dd ) );\n\n    el.setTagName( \"span\" );\n    el.setAttribute( \"class\", \"xdxf_opt\" );\n  }\n\n  nodes = dd.elementsByTagName( \"kref\" ); // Reference to another word\n\n  while( nodes.size() )\n  {\n    QDomElement el = nodes.at( 0 ).toElement();\n\n    if( el.text().isEmpty() && el.childNodes().isEmpty() )\n      el.appendChild( fakeElement( dd ) );\n\n    el.setTagName( \"a\" );\n    el.setAttribute( \"href\", QString( \"bword:\" ) + el.text() );\n    el.setAttribute( \"class\", \"xdxf_kref\" );\n    if ( el.hasAttribute( \"idref\" ) )\n    {\n      // todo implement support for referencing only specific parts of the article\n      el.setAttribute( \"href\", QString( \"bword:\" ) + el.text() + \"#\" + el.attribute( \"idref\" ));\n    }\n    if ( el.hasAttribute( \"kcmt\" ) )\n    {\n      QDomText kcmtText = dd.createTextNode( \" \" + el.attribute( \"kcmt\" ) );\n      el.parentNode().insertAfter( kcmtText, el );\n    }\n  }\n\n  nodes = dd.elementsByTagName( \"iref\" ); // Reference to internet site\n\n  while( nodes.size() )\n  {\n    QDomElement el = nodes.at( 0 ).toElement();\n\n    if( el.text().isEmpty() && el.childNodes().isEmpty() )\n      el.appendChild( fakeElement( dd ) );\n\n    QString ref = el.attribute( \"href\" );\n    if( ref.isEmpty() )\n      ref = el.text();\n\n    el.setAttribute( \"href\", ref );\n    el.setTagName( \"a\" );\n  }\n\n  // Abbreviations\n  if( revisionNumber < 29 )\n    nodes = dd.elementsByTagName( \"abr\" );\n  else\n    nodes = dd.elementsByTagName( \"abbr\" );\n\n  while( nodes.size() )\n  {\n    QDomElement el = nodes.at( 0 ).toElement();\n\n    if( el.text().isEmpty() && el.childNodes().isEmpty() )\n      el.appendChild( fakeElement( dd ) );\n\n    el.setTagName( \"span\" );\n    el.setAttribute( \"class\", \"xdxf_abbr\" );\n    if( type == XDXF && pAbrv != NULL )\n    {\n        string val = Utf8::encode( Folding::trimWhitespace( gd::toWString( el.text() ) ) );\n\n        // If we have such a key, display a title\n\n        map< string, string >::const_iterator i = pAbrv->find( val );\n\n        if ( i != pAbrv->end() )\n        {\n          string title;\n\n          if ( Utf8::decode( i->second ).size() < 70 )\n          {\n            // Replace all spaces with non-breakable ones, since that's how Lingvo shows tooltips\n            title.reserve( i->second.size() );\n\n            for( char const * c = i->second.c_str(); *c; ++c )\n            {\n              if ( *c == ' ' || *c == '\\t' )\n              {\n                // u00A0 in utf8\n                title.push_back( 0xC2 );\n                title.push_back( 0xA0 );\n              }\n              else\n              if( *c == '-' ) // Change minus to non-breaking hyphen (uE28091 in utf8)\n              {\n                title.push_back( 0xE2 );\n                title.push_back( 0x80 );\n                title.push_back( 0x91 );\n              }\n              else\n                title.push_back( *c );\n            }\n          }\n          else\n            title = i->second;\n          el.setAttribute( \"title\", gd::toQString( Utf8::decode( title ) ) );\n        }\n    }\n  }\n\n  nodes = dd.elementsByTagName( \"dtrn\" ); // Direct translation\n\n  while( nodes.size() )\n  {\n    QDomElement el = nodes.at( 0 ).toElement();\n\n    if( el.text().isEmpty() && el.childNodes().isEmpty() )\n      el.appendChild( fakeElement( dd ) );\n\n    el.setTagName( \"span\" );\n    el.setAttribute( \"class\", \"xdxf_dtrn\" );\n  }\n\n  nodes = dd.elementsByTagName( \"c\" ); // Color\n\n  while( nodes.size() )\n  {\n    QDomElement el = nodes.at( 0 ).toElement();\n\n    if( el.text().isEmpty() && el.childNodes().isEmpty() )\n      el.appendChild( fakeElement( dd ) );\n\n    el.setTagName( \"span\" );\n\n    if ( el.hasAttribute( \"c\" ) )\n    {\n      el.setAttribute( \"style\", \"color:\" + el.attribute( \"c\" ) );\n      el.removeAttribute( \"c\" );\n    }\n    else\n      el.setAttribute( \"style\", \"color:blue\" );\n  }\n\n  nodes = dd.elementsByTagName( \"co\" ); // Editorial comment\n\n  while( nodes.size() )\n  {\n    QDomElement el = nodes.at( 0 ).toElement();\n\n    if( el.text().isEmpty() && el.childNodes().isEmpty() )\n      el.appendChild( fakeElement( dd ) );\n\n    el.setTagName( \"span\" );\n    if( isLogicalFormat )\n      el.setAttribute( \"class\", \"xdxf_co\" );\n    else\n      el.setAttribute( \"class\", \"xdxf_co_old\" );\n  }\n\n  /* grammar information */\n  nodes = dd.elementsByTagName( \"gr\" ); // proper grammar tag\n  while( nodes.size() )\n  {\n    QDomElement el = nodes.at( 0 ).toElement();\n\n    if( el.text().isEmpty() && el.childNodes().isEmpty() )\n      el.appendChild( fakeElement( dd ) );\n\n    el.setTagName( \"span\" );\n    if( isLogicalFormat )\n      el.setAttribute( \"class\", \"xdxf_gr\" );\n    else\n      el.setAttribute( \"class\", \"xdxf_gr_old\" );\n  }\n  nodes = dd.elementsByTagName( \"pos\" ); // deprecated grammar tag\n  while( nodes.size() )\n  {\n    QDomElement el = nodes.at( 0 ).toElement();\n\n    if( el.text().isEmpty() && el.childNodes().isEmpty() )\n      el.appendChild( fakeElement( dd ) );\n\n    el.setTagName( \"span\" );\n    if( isLogicalFormat )\n      el.setAttribute( \"class\", \"xdxf_gr\" );\n    else\n      el.setAttribute( \"class\", \"xdxf_gr_old\" );\n  }\n  nodes = dd.elementsByTagName( \"tense\" ); // deprecated grammar tag\n  while( nodes.size() )\n  {\n    QDomElement el = nodes.at( 0 ).toElement();\n\n    if( el.text().isEmpty() && el.childNodes().isEmpty() )\n      el.appendChild( fakeElement( dd ) );\n\n    el.setTagName( \"span\" );\n    if( isLogicalFormat )\n      el.setAttribute( \"class\", \"xdxf_gr\" );\n    else\n      el.setAttribute( \"class\", \"xdxf_gr_old\" );\n  }\n  /* end of grammar generation */\n  \n  nodes = dd.elementsByTagName( \"tr\" ); // Transcription\n\n  while( nodes.size() )\n  {\n    QDomElement el = nodes.at( 0 ).toElement();\n\n    if( el.text().isEmpty() && el.childNodes().isEmpty() )\n      el.appendChild( fakeElement( dd ) );\n\n    el.setTagName( \"span\" );\n    if( isLogicalFormat )\n      el.setAttribute( \"class\", \"xdxf_tr\" );\n    else\n      el.setAttribute( \"class\", \"xdxf_tr_old\" );\n  }\n  \n  // Ensure that ArticleNetworkAccessManager can deal with XDXF images.\n  // We modify the URL by using the dictionary ID as the hostname.\n  // This is necessary to determine from which dictionary a requested\n  // image originates.\n  nodes = dd.elementsByTagName( \"img\" );\n\n  for( int i = 0; i < nodes.size(); i++ )\n  {\n    QDomElement el = nodes.at( i ).toElement();\n\n    if( el.text().isEmpty() && el.childNodes().isEmpty() )\n      el.appendChild( fakeElement( dd ) );\n\n    if ( el.hasAttribute( \"src\" ) )\n    {\n      fixLink( el, dictPtr->getId(), \"src\" );\n    }\n\n    if ( el.hasAttribute( \"losrc\" ) )\n    {\n      fixLink( el, dictPtr->getId(), \"losrc\" );\n    }\n\n    if ( el.hasAttribute( \"hisrc\" ) )\n    {\n      fixLink( el, dictPtr->getId(), \"hisrc\" );\n    }\n  }\n\n  nodes = dd.elementsByTagName( \"rref\" ); // Resource reference\n\n  while( nodes.size() )\n  {\n    QDomElement el = nodes.at( 0 ).toElement();\n\n    if( el.text().isEmpty() && el.childNodes().isEmpty() )\n      el.appendChild( fakeElement( dd ) );\n\n//    if( type == XDXF && dictPtr != NULL && !el.hasAttribute( \"start\" ) )\n    if( dictPtr != NULL && !el.hasAttribute( \"start\" ) )\n    {\n        string filename = Utf8::encode( gd::toWString( el.text() ) );\n\n        if ( Filetype::isNameOfPicture( filename ) )\n        {\n          QUrl url;\n          url.setScheme( \"bres\" );\n          url.setHost( QString::fromUtf8( dictPtr->getId().c_str() ) );\n          url.setPath( Qt4x5::Url::ensureLeadingSlash( QString::fromUtf8( filename.c_str() ) ) );\n\n          QDomElement newEl = dd.createElement( \"img\" );\n          newEl.setAttribute( \"src\", url.toEncoded().data() );\n          newEl.setAttribute( \"alt\", Html::escape( filename ).c_str() );\n\n          QDomNode parent = el.parentNode();\n          if( !parent.isNull() )\n          {\n            parent.replaceChild( newEl, el );\n            continue;\n          }\n        }\n        else if( Filetype::isNameOfSound( filename ) )\n        {\n\n          QDomElement el_script = dd.createElement( \"script\" );\n          QDomNode parent = el.parentNode();\n          if( !parent.isNull() )\n          {\n            bool search = false;\n            if( type == STARDICT )\n            {\n              string n = FsEncoding::dirname( dictPtr->getDictionaryFilenames()[ 0 ] ) +\n                         FsEncoding::separator() + string( \"res\" ) + FsEncoding::separator() +\n                         FsEncoding::encode( filename );\n              search = !File::exists( n ) &&\n                       ( !resourceZip ||\n                         !resourceZip->isOpen() ||\n                         !resourceZip->hasFile( Utf8::decode( filename ) ) );\n            }\n            else\n            {\n              string n = dictPtr->getDictionaryFilenames()[ 0 ] + \".files\" +\n                         FsEncoding::separator() +\n                         FsEncoding::encode( filename );\n              search = !File::exists( n ) && !File::exists( FsEncoding::dirname( dictPtr->getDictionaryFilenames()[ 0 ] ) +\n                                                            FsEncoding::separator() +\n                                                            FsEncoding::encode( filename ) ) &&\n                       ( !resourceZip ||\n                         !resourceZip->isOpen() ||\n                         !resourceZip->hasFile( Utf8::decode( filename ) ) );\n            }\n\n\n            QUrl url;\n            url.setScheme( \"gdau\" );\n            url.setHost( QString::fromUtf8( search ? \"search\" : dictPtr->getId().c_str() ) );\n            url.setPath( Qt4x5::Url::ensureLeadingSlash( QString::fromUtf8( filename.c_str() ) ) );\n\n            el_script.setAttribute( \"type\", \"text/javascript\" );\n            parent.replaceChild( el_script, el );\n\n            QDomText el_txt = dd.createTextNode( makeAudioLinkScript( string( \"\\\"\" ) + url.toEncoded().data() + \"\\\"\",\n                                                                      dictPtr->getId() ).c_str() );\n            el_script.appendChild( el_txt );\n\n            QDomElement el_span = dd.createElement( \"span\" );\n            el_span.setAttribute( \"class\", \"xdxf_wav\" );\n            parent.insertAfter( el_span, el_script );\n\n            QDomElement el_a = dd.createElement( \"a\" );\n            el_a.setAttribute( \"href\", url.toEncoded().data() );\n            el_span.appendChild( el_a );\n\n            QDomElement el_img = dd.createElement( \"img\");\n            el_img.setAttribute( \"src\", \"qrcx://localhost/icons/playsound.png\" );\n            el_img.setAttribute( \"border\", \"0\" );\n            el_img.setAttribute( \"align\", \"absmiddle\" );\n            el_img.setAttribute( \"alt\", \"Play\" );\n            el_a.appendChild( el_img );\n\n            continue;\n          }\n        }\n    }\n\n    // We don't really know how to handle this at the moment, so we'll just\n    // convert it to a span and leave it as is for now.\n\n    el.setTagName( \"span\" );\n    el.setAttribute( \"class\", \"xdxf_rref\" );\n  }\n\n//  GD_DPRINTF( \"Result>>>>>>>>>>: %s\\n\\n\\n\", dd.toByteArray( 0 ).data() );\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  return dd.toString( 1 ).remove('\\n').remove( QRegularExpression( \"<(b|blockquote|i)/>\" ) ).toUtf8().data();\n#else\n  return dd.toString( 1 ).remove('\\n').remove( QRegExp( \"<(b|blockquote|i)/>\" ) ).toUtf8().data();\n#endif\n}\n\n}\n\n"
        },
        {
          "name": "xdxf2html.hh",
          "type": "blob",
          "size": 0.8798828125,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __XDXF2HTML_HH_INCLUDED__\n#define __XDXF2HTML_HH_INCLUDED__\n\n#include <string>\n#include <map>\n#include \"dictionary.hh\"\n#include \"indexedzip.hh\"\n\n/// Xdxf is an xml file format. Since we display html, we'd like to be able\n/// to convert articles with such a markup to an html.\nnamespace Xdxf2Html {\n\nenum DICT_TYPE { STARDICT, XDXF };\n\nusing std::string;\nusing std::map;\n\n/// Converts the given xdxf markup to an html one. This is currently used\n/// for Stardict's 'x' records.\nstring convert( string const &, DICT_TYPE type, map < string, string > const * pAbrv,\n                Dictionary::Class *dictPtr, IndexedZip * resourceZip, bool isLogicalFormat = false,\n                unsigned revisionNumber = 0, QString * headword = 0 );\n\n}\n\n#endif\n"
        },
        {
          "name": "zim.cc",
          "type": "blob",
          "size": 54.7109375,
          "content": "/* This file is (c) 2012 Abs62\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifdef MAKE_ZIM_SUPPORT\n\n#include \"zim.hh\"\n#include \"btreeidx.hh\"\n#include \"fsencoding.hh\"\n#include \"folding.hh\"\n#include \"categorized_logging.hh\"\n#include \"gddebug.hh\"\n#include \"utf8.hh\"\n#include \"decompress.hh\"\n#include \"langcoder.hh\"\n#include \"wstring_qt.hh\"\n#include \"filetype.hh\"\n#include \"file.hh\"\n#include \"qt4x5.hh\"\n#include \"tiff.hh\"\n#include \"ftshelpers.hh\"\n#include \"htmlescape.hh\"\n#include \"splitfile.hh\"\n\n#ifdef _MSC_VER\n#include <stub_msvc.h>\n#endif\n\n#include <QByteArray>\n#include <QFile>\n#include <QFileInfo>\n#include <QString>\n#include <QRunnable>\n#include <QSemaphore>\n#include <QAtomicInt>\n#include <QImage>\n#include <QDir>\n#include <QDebug>\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n#include <QRegularExpression>\n#endif\n\n#include <string>\n#include <set>\n#include <map>\n#include <algorithm>\n\nnamespace Zim {\n\n#define CACHE_SIZE 3\n\nusing std::string;\nusing std::map;\nusing std::vector;\nusing std::multimap;\nusing std::pair;\nusing std::set;\nusing gd::wstring;\n\nusing BtreeIndexing::WordArticleLink;\nusing BtreeIndexing::IndexedWords;\nusing BtreeIndexing::IndexInfo;\n\nDEF_EX_STR( exNotZimFile, \"Not an Zim file\", Dictionary::Ex )\nDEF_EX_STR( exCantReadFile, \"Can't read file\", Dictionary::Ex )\nDEF_EX_STR( exInvalidZimHeader, \"Invalid Zim header\", Dictionary::Ex )\nDEF_EX( exUserAbort, \"User abort\", Dictionary::Ex )\n\n\n//namespace {\n\nclass ZimFile;\n\n#pragma pack( push, 1 )\n\nenum CompressionType\n{\n  Default = 0, None, Zlib, Bzip2, Lzma2, Zstd\n};\n\n/// Zim file header\nstruct ZIM_header\n{\n    quint32 magicNumber;\n    quint16 majorVersion;\n    quint16 minorVersion;\n    quint8 uuid[ 16 ];\n    quint32 articleCount;\n    quint32 clusterCount;\n    quint64 urlPtrPos;\n    quint64 titlePtrPos;\n    quint64 clusterPtrPos;\n    quint64 mimeListPos;\n    quint32 mainPage;\n    quint32 layoutPage;\n    quint64 checksumPos;\n}\n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\nstruct ArticleEntry\n{\n    quint16 mimetype;\n    quint8 parameterLen;\n    char nameSpace;\n    quint32 revision;\n    quint32 clusterNumber;\n    quint32 blobNumber;\n}\n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\nstruct RedirectEntry\n{\n    quint16 mimetype;\n    quint8 parameterLen;\n    char nameSpace;\n    quint32 revision;\n    quint32 redirectIndex;\n}\n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\nenum\n{\n  Signature = 0x584D495A, // ZIMX on little-endian, XMIZ on big-endian\n  CurrentFormatVersion = 4 + BtreeIndexing::FormatVersion + Folding::Version\n};\n\nstruct IdxHeader\n{\n  quint32 signature; // First comes the signature, ZIMX\n  quint32 formatVersion; // File format version (CurrentFormatVersion)\n  quint32 indexBtreeMaxElements; // Two fields from IndexInfo\n  quint32 indexRootOffset;\n  quint32 resourceIndexBtreeMaxElements; // Two fields from IndexInfo\n  quint32 resourceIndexRootOffset;\n  quint32 wordCount;\n  quint32 articleCount;\n  quint32 namePtr;\n  quint32 descriptionPtr;\n  quint32 langFrom;  // Source language\n  quint32 langTo;    // Target language\n  quint32 iconPtr;\n}\n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\n#pragma pack( pop )\n\n// Class for support of split zim files\n\nstruct Cache\n{\n  char * data;\n  quint32 clusterNumber;\n  int stamp;\n  int count, size;\n  unsigned blobs_offset_size;\n\n  Cache() :\n    data( 0 ),\n    clusterNumber( 0 ),\n    stamp( -1 ),\n    count( 0 ),\n    size( 0 ),\n    blobs_offset_size( 0 )\n  {}\n};\n\nclass ZimFile : public SplitFile::SplitFile\n{\npublic:\n  ZimFile();\n  ZimFile( const QString & name );\n  ~ZimFile();\n\n  virtual void setFileName( const QString & name );\n  bool open();\n  void close()\n  {\n    SplitFile::close();\n    clearCache();\n  }\n  const ZIM_header & header() const\n  { return zimHeader; }\n\n  string getClusterData( quint32 cluster_nom, unsigned & blob_offset_size );\n\n  const QString getMimeType( quint16 nom )\n  { return mimeTypes.value( nom ); }\n\n  bool isArticleMime( quint16 mime_type )\n  { return getMimeType( mime_type ).startsWith( \"text/html\", Qt::CaseInsensitive )\n           || getMimeType( mime_type ).startsWith( \"text/plain\", Qt::CaseInsensitive ); }\n\n\n  quint16 redirectedMimeType( RedirectEntry const & redEntry );\n\nprivate:\n  ZIM_header zimHeader;\n  Cache cache[ CACHE_SIZE ];\n  int stamp;\n  QVector< QPair< quint64, quint32 > > clusterOffsets;\n  QStringList mimeTypes;\n\n  void clearCache();\n};\n\nZimFile::ZimFile() :\n  stamp( 0 )\n{\n  memset( &zimHeader, 0, sizeof( zimHeader ) );\n}\n\nZimFile::ZimFile( const QString & name )\n{\n  setFileName( name );\n}\n\nZimFile::~ZimFile()\n{\n  clearCache();\n}\n\nvoid ZimFile::setFileName( const QString & name )\n{\n  close();\n  memset( &zimHeader, 0, sizeof( zimHeader ) );\n  clearCache();\n\n  appendFile( name );\n\n  if( name.endsWith( \".zimaa\", Qt::CaseInsensitive ) )\n  {\n    QString fname = name;\n\n    for( int i = 0; i < 26; i++ )\n    {\n      fname[ fname.size() - 2 ] = (char)( 'a' + i );\n\n      int j;\n      for( j = 1; j < 26; j++ )\n      {\n        fname[ fname.size() - 1 ] = (char)( 'a' + j );\n        if( !QFileInfo( fname ).isFile() )\n          break;\n\n        appendFile( fname );\n      }\n\n      if( j < 26 )\n        break;\n    }\n  }\n}\n\nvoid ZimFile::clearCache()\n{\n  for( int i = 0; i < CACHE_SIZE; i++ )\n  {\n    if( cache[ i ].data )\n    {\n      free( cache[ i ].data );\n      cache[ i ].data = 0;\n    }\n    cache[ i ].clusterNumber = 0;\n    cache[ i ].stamp = -1;\n    cache[ i ].count = 0;\n    cache[ i ].size = 0;\n  }\n  stamp = 0;\n}\n\nbool ZimFile::open()\n{\n  if( !SplitFile::open( QIODevice::ReadOnly ) )\n    return false;\n\n  memset( &zimHeader, 0, sizeof( zimHeader ) );\n\n  if( read( reinterpret_cast< char * >( &zimHeader ), sizeof( zimHeader ) ) != sizeof( zimHeader ) )\n    return false;\n\n  if( zimHeader.magicNumber != 0x44D495A || zimHeader.mimeListPos != sizeof( zimHeader ) )\n    return false;\n\n// Clusters in zim file may be placed in random order.\n// We create sorted offsets list to calculate clusters size.\n\n  clusterOffsets.resize( zimHeader.clusterCount );\n  QVector< quint64 > offs;\n  offs.resize( zimHeader.clusterCount );\n\n  seek( zimHeader.clusterPtrPos );\n  qint64 size = zimHeader.clusterCount * sizeof( quint64 );\n  if( read( reinterpret_cast< char * >( offs.data() ), size) != size )\n  {\n    vector< string > names;\n    getFilenames( names );\n    throw exCantReadFile( names[ 0 ] );\n  }\n\n  for( quint32 i = 0; i < zimHeader.clusterCount; i++ )\n    clusterOffsets[ i ] = QPair< quint64, quint32 >( offs.at( i ), i );\n\n  std::sort( clusterOffsets.begin(), clusterOffsets.end() );\n\n// Read mime types\n\n  string type;\n  char ch;\n\n  seek( zimHeader.mimeListPos );\n\n  for( ; ; )\n  {\n    type.clear();\n    while( getChar( &ch ) )\n    {\n      if( ch == 0 )\n        break;\n      type.push_back( ch );\n    }\n    if( type.empty() )\n      break;\n\n    QString s = QString::fromUtf8( type.c_str(), type.size() );\n    mimeTypes.append( s );\n  }\n\n  return true;\n}\n\nstring ZimFile::getClusterData( quint32 cluster_nom, unsigned & blobs_offset_size )\n{\n  // Check cache\n  int target = 0;\n  bool found = false;\n  int lastStamp = INT_MAX;\n\n  for( int i = 0; i < CACHE_SIZE; i++ )\n  {\n    if( cache[ i ].clusterNumber == cluster_nom && cache[ i ].count )\n    {\n      found = true;\n      target = i;\n      break;\n    }\n\n    if( cache[ i ].stamp < lastStamp )\n    {\n      lastStamp = cache[ i ].stamp;\n      target = i;\n    }\n  }\n\n  cache[ target ].stamp = ++stamp;\n  if( stamp < 0 )\n  {\n     stamp = 0;\n     for (int i = 0; i < CACHE_SIZE; i++)\n       cache[ i ].stamp = -1;\n  }\n\n  if( found )\n  {\n    // Cache hit\n    blobs_offset_size = cache[ target ].blobs_offset_size;\n    return string( cache[ target ].data, cache[ target ].count );\n  }\n\n  // Cache miss, read data from file\n\n  // Calculate cluster size\n\n  quint64 clusterSize;\n  quint32 nom;\n  for( nom = 0; nom < zimHeader.clusterCount; nom++ )\n    if( clusterOffsets.at( nom ).second == cluster_nom )\n      break;\n\n  if( nom >= zimHeader.clusterCount ) // Invalid cluster nom\n    return string();\n\n  if( nom < zimHeader.clusterCount - 1 )\n    clusterSize = clusterOffsets.at( nom + 1 ).first - clusterOffsets.at( nom ).first;\n  else\n    clusterSize = size() - clusterOffsets.at( nom ).first;\n\n  // Read cluster data\n\n  seek( clusterOffsets.at( nom ).first );\n\n  char compressionType, cluster_info;\n  if( !getChar( &cluster_info ) )\n    return string();\n  compressionType = cluster_info & 0x0F;\n  blobs_offset_size = cluster_info & 0x10 && zimHeader.majorVersion >= 6 ? 8 : 4;\n\n  string decompressedData;\n\n  QByteArray data = read( clusterSize );\n\n  if( compressionType == Default || compressionType == None )\n    decompressedData = string( data.data(), data.size() );\n  else\n  if( compressionType == Zlib )\n    decompressedData = decompressZlib( data.constData(), data.size() );\n  else\n  if( compressionType == Bzip2 )\n    decompressedData = decompressBzip2( data.constData(), data.size() );\n  else\n  if( compressionType == Lzma2 )\n    decompressedData = decompressLzma2( data.constData(), data.size() );\n  else\n  if( compressionType == Zstd )\n    decompressedData = decompressZstd( data.constData(), data.size() );\n  else\n    return string();\n\n  if( decompressedData.empty() )\n    return string();\n\n  // Check BLOBs number in the cluster\n  // We cache multi-element clusters only\n\n  quint32 firstOffset32;\n  quint64 firstOffset;\n  if( blobs_offset_size == 8 )\n    memcpy( &firstOffset, decompressedData.data(), sizeof(firstOffset) );\n  else\n  {\n    memcpy( &firstOffset32, decompressedData.data(), sizeof(firstOffset32) );\n    firstOffset = firstOffset32;\n  }\n  quint32 blobCount = ( firstOffset - blobs_offset_size ) / blobs_offset_size;\n\n  if( blobCount > 1 )\n  {\n    // Fill cache\n    int size = decompressedData.size();\n    if( cache[ target ].count < size )\n    {\n      if( cache[ target ].data )\n        free( cache[ target ].data );\n      cache[ target ].data = ( char * )malloc( size );\n      if( cache[ target ].data )\n        cache[ target ].size = size;\n      else\n      {\n        cache[ target ].size = 0;\n        cache[ target ].count = 0;\n      }\n    }\n    if( cache[ target ].size )\n    {\n      memcpy( cache[ target ].data, decompressedData.c_str(), size );\n      cache[ target ].count = size;\n      cache[ target ].clusterNumber = cluster_nom;\n      cache[ target ].blobs_offset_size = blobs_offset_size;\n    }\n  }\n\n  return decompressedData;\n}\n\nquint16 ZimFile::redirectedMimeType( RedirectEntry const & redEntry )\n{\n  RedirectEntry current_entry = redEntry;\n  quint64 current_pos = pos();\n  quint16 mimetype = 0xFFFF;\n\n  for( ; ; )\n  {\n    quint32 current_nom = current_entry.redirectIndex;\n\n    seek( zimHeader.urlPtrPos + (quint64)current_nom * 8 );\n    quint64 new_pos;\n    if( read( reinterpret_cast< char * >( &new_pos ), sizeof(new_pos) ) != sizeof(new_pos) )\n      break;\n\n    seek( new_pos );\n    quint16 new_mimetype;\n    if( read( reinterpret_cast< char * >( &new_mimetype ), sizeof(new_mimetype) ) != sizeof(new_mimetype) )\n      break;\n\n    if( new_mimetype == 0xFFFF ) // Redirect to other article\n    {\n      if( read( reinterpret_cast< char * >( &current_entry ) + 2, sizeof( current_entry ) - 2 ) != sizeof( current_entry ) - 2 )\n        break;\n      if( current_nom == current_entry.redirectIndex )\n        break;\n    }\n    else\n    {\n      mimetype = new_mimetype;\n      break;\n    }\n  }\n\n  seek( current_pos );\n  return mimetype;\n}\n\n\n// Some supporting functions\n\nbool indexIsOldOrBad( string const & indexFile )\n{\n  File::Class idx( indexFile, \"rb\" );\n\n  IdxHeader header;\n\n  return idx.readRecords( &header, sizeof( header ), 1 ) != 1 ||\n         header.signature != Signature ||\n         header.formatVersion != CurrentFormatVersion;\n}\n\nquint32 getArticleCluster( ZimFile & file, quint32 articleNumber )\n{\n  while( 1 )\n  {\n    ZIM_header const & header = file.header();\n    if( articleNumber >= header.articleCount )\n      break;\n\n    file.seek( header.urlPtrPos + (quint64)articleNumber * 8 );\n    quint64 pos;\n    if( file.read( reinterpret_cast< char * >( &pos ), sizeof(pos) ) != sizeof(pos) )\n      break;\n\n    // Read article info\n\n    quint16 mimetype;\n\n    file.seek( pos );\n    if( file.read( reinterpret_cast< char * >( &mimetype ), sizeof(mimetype) ) != sizeof(mimetype) )\n      break;\n\n    if( mimetype == 0xFFFF ) // Redirect to other article\n    {\n      RedirectEntry redEntry;\n      if( file.read( reinterpret_cast< char * >( &redEntry ) + 2, sizeof(redEntry) - 2 ) != sizeof(redEntry) - 2 )\n        break;\n      if( articleNumber == redEntry.redirectIndex )\n        break;\n      articleNumber = redEntry.redirectIndex;\n      continue;\n    }\n\n    ArticleEntry artEntry;\n    artEntry.mimetype = mimetype;\n    if( file.read( reinterpret_cast< char * >( &artEntry ) + 2, sizeof(artEntry) - 2 ) != sizeof(artEntry) - 2 )\n      break;\n\n    return artEntry.clusterNumber;\n  }\n  return 0xFFFFFFFF;\n}\n\nquint32 readArticle( ZimFile & file, quint32 articleNumber, string & result,\n                     set< quint32 > * loadedArticles = NULL )\n{\n  result.clear();\n\n  while( 1 )\n  {\n    ZIM_header const & header = file.header();\n    if( articleNumber >= header.articleCount )\n      break;\n\n    file.seek( header.urlPtrPos + (quint64)articleNumber * 8 );\n    quint64 pos;\n    if( file.read( reinterpret_cast< char * >( &pos ), sizeof(pos) ) != sizeof(pos) )\n      break;\n\n    // Read article info\n\n    quint16 mimetype;\n\n    file.seek( pos );\n    if( file.read( reinterpret_cast< char * >( &mimetype ), sizeof(mimetype) ) != sizeof(mimetype) )\n      break;\n\n    if( mimetype == 0xFFFF ) // Redirect to other article\n    {\n      RedirectEntry redEntry;\n      if( file.read( reinterpret_cast< char * >( &redEntry ) + 2, sizeof(redEntry) - 2 ) != sizeof(redEntry) - 2 )\n        break;\n      if( articleNumber == redEntry.redirectIndex )\n        break;\n      articleNumber = redEntry.redirectIndex;\n      continue;\n    }\n\n    if( loadedArticles && loadedArticles->find( articleNumber ) != loadedArticles->end() )\n      break;\n\n    ArticleEntry artEntry;\n    artEntry.mimetype = mimetype;\n    if( file.read( reinterpret_cast< char * >( &artEntry ) + 2, sizeof(artEntry) - 2 ) != sizeof(artEntry) - 2 )\n      break;\n\n    // Read cluster data\n\n    unsigned offset_size = 0;\n    string decompressedData = file.getClusterData( artEntry.clusterNumber, offset_size );\n    if( decompressedData.empty() )\n      break;\n\n    // Take article data from cluster\n\n    quint32 firstOffset32;\n    quint64 firstOffset;\n\n    if( offset_size == 8 )\n      memcpy( &firstOffset, decompressedData.data(), sizeof(firstOffset) );\n    else\n    {\n      memcpy( &firstOffset32, decompressedData.data(), sizeof(firstOffset32) );\n      firstOffset = firstOffset32;\n    }\n    quint32 blobCount = ( firstOffset - offset_size ) / offset_size;\n    if( artEntry.blobNumber > blobCount )\n      break;\n\n    quint32 size;\n    if( offset_size == 8 )\n    {\n      quint64 offsets[ 2 ];\n      memcpy( offsets, decompressedData.data() + artEntry.blobNumber * 8, sizeof(offsets) );\n      size = offsets[ 1 ] - offsets[ 0 ];\n      result.append( decompressedData, offsets[ 0 ], size );\n    }\n    else\n    {\n      quint32 offsets[ 2 ];\n      memcpy( offsets, decompressedData.data() + artEntry.blobNumber * 4, sizeof(offsets) );\n      size = offsets[ 1 ] - offsets[ 0 ];\n      result.append( decompressedData, offsets[ 0 ], size );\n    }\n\n    return articleNumber;\n  }\n  return 0xFFFFFFFF;\n}\n\n// ZimDictionary\n\nclass ZimDictionary: public BtreeIndexing::BtreeDictionary\n{\n    enum LINKS_TYPE { UNKNOWN, SLASH, NO_SLASH };\n\n    Mutex idxMutex;\n    Mutex zimMutex, idxResourceMutex;\n    File::Class idx;\n    BtreeIndex resourceIndex;\n    IdxHeader idxHeader;\n    string dictionaryName;\n    ZimFile df;\n    set< quint32 > articlesIndexedForFTS;\n    LINKS_TYPE linksType;\n\n  public:\n\n    ZimDictionary( string const & id, string const & indexFile,\n                     vector< string > const & dictionaryFiles );\n\n    ~ZimDictionary();\n\n    virtual string getName() throw()\n    { return dictionaryName; }\n\n    virtual map< Dictionary::Property, string > getProperties() throw()\n    { return map< Dictionary::Property, string >(); }\n\n    virtual unsigned long getArticleCount() throw()\n    { return idxHeader.articleCount; }\n\n    virtual unsigned long getWordCount() throw()\n    { return idxHeader.wordCount; }\n\n    inline virtual quint32 getLangFrom() const\n    { return idxHeader.langFrom; }\n\n    inline virtual quint32 getLangTo() const\n    { return idxHeader.langTo; }\n\n    virtual sptr< Dictionary::DataRequest > getArticle( wstring const &,\n                                                        vector< wstring > const & alts,\n                                                        wstring const &,\n                                                        bool ignoreDiacritics )\n      THROW_SPEC( std::exception );\n\n    virtual sptr< Dictionary::DataRequest > getResource( string const & name )\n      THROW_SPEC( std::exception );\n\n    virtual QString const& getDescription();\n\n    /// Loads the resource.\n    void loadResource( std::string &resourceName, string & data );\n\n    virtual sptr< Dictionary::DataRequest > getSearchResults( QString const & searchString,\n                                                              int searchMode, bool matchCase,\n                                                              int distanceBetweenWords,\n                                                              int maxResults,\n                                                              bool ignoreWordsOrder,\n                                                              bool ignoreDiacritics,\n                                                              QThreadPool * ftsThreadPoolPtr );\n    virtual void getArticleText( uint32_t articleAddress, QString & headword, QString & text );\n\n    quint32 getArticleText( uint32_t articleAddress, QString & headword, QString & text,\n                            set< quint32 > * loadedArticles );\n\n    virtual void makeFTSIndex(QAtomicInt & isCancelled, bool firstIteration );\n\n    virtual void setFTSParameters( Config::FullTextSearch const & fts )\n    {\n      can_FTS = fts.enabled\n                && !fts.disabledTypes.contains( \"ZIM\", Qt::CaseInsensitive )\n                && ( fts.maxDictionarySize == 0 || getArticleCount() <= fts.maxDictionarySize );\n    }\n\n    virtual void sortArticlesOffsetsForFTS( QVector< uint32_t > & offsets, QAtomicInt & isCancelled );\n\nprotected:\n\n    virtual void loadIcon() throw();\n\nprivate:\n\n    /// Loads the article.\n    quint32 loadArticle( quint32 address,\n                         string & articleText,\n                         set< quint32 > * loadedArticles,\n                         bool rawText = false );\n\n    string convert( string const & in_data );\n    friend class ZimArticleRequest;\n    friend class ZimResourceRequest;\n};\n\nZimDictionary::ZimDictionary( string const & id,\n                              string const & indexFile,\n                              vector< string > const & dictionaryFiles ):\n    BtreeDictionary( id, dictionaryFiles ),\n    idx( indexFile, \"rb\" ),\n    idxHeader( idx.read< IdxHeader >() ),\n    df( FsEncoding::decode( dictionaryFiles[ 0 ].c_str() ) ),\n    linksType( UNKNOWN )\n{\n    // Open data file\n\n    df.open();\n\n    // Initialize the indexes\n\n    openIndex( IndexInfo( idxHeader.indexBtreeMaxElements,\n                          idxHeader.indexRootOffset ),\n               idx, idxMutex );\n\n    resourceIndex.openIndex( IndexInfo( idxHeader.resourceIndexBtreeMaxElements,\n                                        idxHeader.resourceIndexRootOffset ),\n                             idx, idxResourceMutex );\n\n    // Read dictionary name\n\n    if( idxHeader.namePtr == 0xFFFFFFFF )\n    {\n      QString name = QDir::fromNativeSeparators( FsEncoding::decode( dictionaryFiles[ 0 ].c_str() ) );\n      int n = name.lastIndexOf( '/' );\n      dictionaryName = string( name.mid( n + 1 ).toUtf8().constData() );\n    }\n    else\n    {\n      readArticle( df, idxHeader.namePtr, dictionaryName );\n    }\n\n    // Full-text search parameters\n\n    can_FTS = true;\n\n    ftsIdxName = indexFile + \"_FTS\";\n\n    if( !Dictionary::needToRebuildIndex( dictionaryFiles, ftsIdxName )\n        && !FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) )\n      FTS_index_completed.ref();\n}\n\nZimDictionary::~ZimDictionary()\n{\n    df.close();\n}\n\nvoid ZimDictionary::loadIcon() throw()\n{\n  if ( dictionaryIconLoaded )\n    return;\n\n  QString fileName =\n    QDir::fromNativeSeparators( FsEncoding::decode( getDictionaryFilenames()[ 0 ].c_str() ) );\n\n  // Remove the extension\n  fileName.chop( 3 );\n\n  if( !loadIconFromFile( fileName ) )\n  {\n    // Load icon from dictionary\n    if( idxHeader.iconPtr != 0xFFFFFFFF )\n    {\n      string pngImage;\n      readArticle( df, idxHeader.iconPtr, pngImage );\n\n      QImage img = QImage::fromData( reinterpret_cast< const uchar *>( pngImage.data() ), pngImage.size() );\n      img.setAlphaChannel( img.createMaskFromColor( QColor( 192, 192, 192 ).rgb(),\n                                                    Qt::MaskOutColor ) );\n\n      dictionaryNativeIcon = dictionaryIcon = QIcon( QPixmap::fromImage( img ) );\n      if( dictionaryIcon.isNull() )\n        dictionaryNativeIcon = dictionaryIcon = QIcon(\":/icons/icon32_zim.png\");\n    }\n    else\n      // Load failed -- use default icons\n      dictionaryNativeIcon = dictionaryIcon = QIcon(\":/icons/icon32_zim.png\");\n  }\n\n  dictionaryIconLoaded = true;\n}\n\nquint32 ZimDictionary::loadArticle( quint32 address,\n                                    string & articleText,\n                                    set< quint32 > * loadedArticles,\n                                    bool rawText )\n{\nquint32 ret;\n  {\n    Mutex::Lock _( zimMutex );\n    ret = readArticle( df, address, articleText, loadedArticles );\n  }\n  if( !rawText )\n    articleText = convert( articleText );\n\n  return ret;\n}\n\nstring ZimDictionary::convert( const string & in )\n{\n  QString text = QString::fromUtf8( in.c_str() );\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  // replace background\n  text.replace( QRegularExpression( \"<\\\\s*body\\\\s+([^>]*)(background(|-color)):([^;\\\"]*(;|))\" ),\n                QString( \"<body \\\\1\" ) );\n\n  // pattern of img and script\n  text.replace( QRegularExpression( \"<\\\\s*(img|script)\\\\s+([^>]*)src=(\\\"|)(\\\\.\\\\.|)/\" ),\n                QString( \"<\\\\1 \\\\2src=\\\\3bres://%1/\").arg( getId().c_str() ) );\n\n  // Fix links without '\"'\n  text.replace( QRegularExpression( \"href=(\\\\.\\\\.|)/([^\\\\s>]+)\" ),\n                QString( \"href=\\\"\\\\1/\\\\2\\\"\" ) );\n\n  // pattern <link... href=\"...\" ...>\n  text.replace( QRegularExpression( \"<\\\\s*link\\\\s+([^>]*)href=\\\"(\\\\.\\\\.|)/\" ),\n                QString( \"<link \\\\1href=\\\"bres://%1/\").arg( getId().c_str() ) );\n\n  // localize the http://en.wiki***.com|org/wiki/<key> series links\n  // excluding those keywords that have \":\" in it\n  QString urlWiki = \"\\\"http(s|)://en\\\\.(wiki(pedia|books|news|quote|source|voyage|versity)|wiktionary)\\\\.(org|com)/wiki/([^:\\\"]*)\\\"\";\n  text.replace( QRegularExpression( \"<\\\\s*a\\\\s+(class=\\\"external\\\"\\\\s+|)href=\" + urlWiki ),\n                QString( \"<a href=\\\"gdlookup://localhost/\\\\6\\\"\" ) );\n#else\n  // replace background\n  text.replace( QRegExp( \"<\\\\s*body\\\\s+([^>]*)(background(|-color)):([^;\\\"]*(|;))\" ),\n                QString( \"<body \\\\1\" ) );\n\n  // pattern of img and script\n  text.replace( QRegExp( \"<\\\\s*(img|script)\\\\s+([^>]*)src=(\\\"|)(\\\\.\\\\.|)/\" ),\n                QString( \"<\\\\1 \\\\2src=\\\\3bres://%1/\").arg( getId().c_str() ) );\n\n  // Fix links without '\"'\n  text.replace( QRegExp( \"href=(\\\\.\\\\.|)/([^\\\\s>]+)\" ), QString( \"href=\\\"\\\\1/\\\\2\\\"\" ) );\n\n  // pattern <link... href=\"...\" ...>\n  text.replace( QRegExp( \"<\\\\s*link\\\\s+([^>]*)href=\\\"(\\\\.\\\\.|)/\" ),\n                QString( \"<link \\\\1href=\\\"bres://%1/\").arg( getId().c_str() ) );\n\n  // localize the http://en.wiki***.com|org/wiki/<key> series links\n  // excluding those keywords that have \":\" in it\n  QString urlWiki = \"\\\"http(s|)://en\\\\.(wiki(pedia|books|news|quote|source|voyage|versity)|wiktionary)\\\\.(org|com)/wiki/([^:\\\"]*)\\\"\";\n  text.replace( QRegExp( \"<\\\\s*a\\\\s+(class=\\\"external\\\"\\\\s+|)href=\" + urlWiki ),\n                QString( \"<a href=\\\"gdlookup://localhost/\\\\6\\\"\" ) );\n#endif\n\n  // pattern <a href=\"...\" ...>, excluding any known protocols such as http://, mailto:, #(comment)\n  // these links will be translated into local definitions\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  QRegularExpression rxLink( \"<\\\\s*a\\\\s+([^>]*)href=\\\"(?!(?:\\\\w+://|#|mailto:|tel:))(/|)([^\\\"]*)\\\"\\\\s*(title=\\\"[^\\\"]*\\\")?[^>]*>\" );\n  QRegularExpressionMatchIterator it = rxLink.globalMatch( text );\n  int pos = 0;\n  QString newText;\n  while( it.hasNext() )\n  {\n    QRegularExpressionMatch match = it.next();\n\n    newText += text.midRef( pos, match.capturedStart() - pos );\n    pos = match.capturedEnd();\n\n    QStringList list = match.capturedTexts();\n    // Add empty strings for compatibility with QRegExp behaviour\n    for( int i = match.lastCapturedIndex() + 1; i < 5; i++ )\n      list.append( QString() );\n#else\n  QRegExp rxLink( \"<\\\\s*a\\\\s+([^>]*)href=\\\"(?!(\\\\w+://|#|mailto:|tel:))(/|)([^\\\"]*)\\\"\\\\s*(title=\\\"[^\\\"]*\\\")?[^>]*>\",\n                       Qt::CaseSensitive,\n                       QRegExp::RegExp2 );\n  int pos = 0;\n  while( (pos = rxLink.indexIn( text, pos )) >= 0 )\n  {\n    QStringList list = rxLink.capturedTexts();\n#endif\n    QString tag = list[3];     // a url, ex: Precambrian_Chaotian.html\n    if ( !list[4].isEmpty() )  // a title, ex: title=\"Precambrian/Chaotian\"\n      tag = list[4].split(\"\\\"\")[1];\n\n\n    // Check type of links inside articles\n    if( linksType == UNKNOWN && tag.indexOf( '/' ) >= 0 )\n    {\n      QString word = QUrl::fromPercentEncoding( tag.toLatin1() );\n      word.remove( QRegExp( \"\\\\.(s|)htm(l|)$\", Qt::CaseInsensitive ) ).\n           replace( \"_\", \" \" );\n\n      vector< WordArticleLink > links;\n      links = findArticles( gd::toWString( word ) );\n\n      if( !links.empty() )\n      {\n        linksType = SLASH;\n      }\n      else\n      {\n        word.remove( QRegExp(\".*/\") );\n        links = findArticles( gd::toWString( word ) );\n        if( !links.empty() )\n        {\n          linksType = NO_SLASH;\n          links.clear();\n        }\n      }\n    }\n\n    if( linksType == SLASH || linksType == UNKNOWN )\n    {\n      tag.remove( QRegExp( \"\\\\.(s|)htm(l|)$\", Qt::CaseInsensitive ) ).\n          replace( \"_\", \"%20\" ).\n          prepend( \"<a href=\\\"gdlookup://localhost/\" ).\n          append( \"\\\" \" + list[4] + \">\" );\n    }\n    else\n    {\n      tag.remove( QRegExp(\".*/\") ).\n          remove( QRegExp( \"\\\\.(s|)htm(l|)$\", Qt::CaseInsensitive ) ).\n          replace( \"_\", \"%20\" ).\n          prepend( \"<a href=\\\"gdlookup://localhost/\" ).\n          append( \"\\\" \" + list[4] + \">\" );\n    }\n\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n    newText += tag;\n  }\n  if( pos )\n  {\n    newText += text.midRef( pos );\n    text = newText;\n  }\n  newText.clear();\n#else\n    text.replace( pos, list[0].length(), tag );\n    pos += tag.length() + 1;\n  }\n#endif\n\n  // Occasionally words needs to be displayed in vertical, but <br/> were changed to <br\\> somewhere\n  // proper style: <a href=\"gdlookup://localhost/Neoptera\" ... >N<br/>e<br/>o<br/>p<br/>t<br/>e<br/>r<br/>a</a>\n#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )\n  QRegularExpression rxBR( \"(<a href=\\\"gdlookup://localhost/[^\\\"]*\\\"\\\\s*[^>]*>)\\\\s*((\\\\w\\\\s*&lt;br(\\\\\\\\|/|)&gt;\\\\s*)+\\\\w)\\\\s*</a>\",\n                           QRegularExpression::UseUnicodePropertiesOption );\n  pos = 0;\n  QRegularExpressionMatchIterator it2 = rxLink.globalMatch( text );\n  while( it2.hasNext() )\n  {\n    QRegularExpressionMatch match = it.next();\n\n    newText += text.midRef( pos, match.capturedStart() - pos );\n    pos = match.capturedEnd();\n\n    QStringList list = match.capturedTexts();\n    // Add empty strings for compatibility with QRegExp behaviour\n    for( int i = match.lastCapturedIndex() + 1; i < 3; i++ )\n      list.append( QString() );\n\n    QString tag = list[2];\n    tag.replace( QRegExp( \"&lt;br( |)(\\\\\\\\|/|)&gt;\", Qt::CaseInsensitive ) , \"<br/>\" ).\n        prepend( list[1] ).\n        append( \"</a>\" );\n\n    newText += tag;\n  }\n  if( pos )\n  {\n    newText += text.midRef( pos );\n    text = newText;\n  }\n  newText.clear();\n#else\n  QRegExp rxBR( \"(<a href=\\\"gdlookup://localhost/[^\\\"]*\\\"\\\\s*[^>]*>)\\\\s*((\\\\w\\\\s*&lt;br(\\\\\\\\|/|)&gt;\\\\s*)+\\\\w)\\\\s*</a>\",\n                       Qt::CaseSensitive,\n                       QRegExp::RegExp2 );\n  pos = 0;\n  while( (pos = rxBR.indexIn( text, pos )) >= 0 )\n  {\n    QStringList list = rxBR.capturedTexts();\n    QString tag = list[2];\n    tag.replace( QRegExp( \"&lt;br( |)(\\\\\\\\|/|)&gt;\", Qt::CaseInsensitive ) , \"<br/>\" ).\n        prepend( list[1] ).\n        append( \"</a>\" );\n\n    text.replace( pos, list[0].length(), tag );\n    pos += tag.length() + 1;\n  }\n#endif\n\n  // // output all links in the page - only for analysis\n  // QRegExp rxPrintAllLinks( \"<\\\\s*a\\\\s+[^>]*href=\\\"[^\\\"]*\\\"[^>]*>\",\n  //                         Qt::CaseSensitive,\n  //                         QRegExp::RegExp2 );\n  // pos = 0;\n  // while( (pos = rxPrintAllLinks.indexIn( text, pos )) >= 0 )\n  // {\n  //   QStringList list = rxPrintAllLinks.capturedTexts();\n  //   qDebug() << \"\\n--Alllinks--\" << list[0];\n  //   pos += list[0].length() + 1;\n  // }\n\n  // Fix outstanding elements\n  text += \"<br style=\\\"clear:both;\\\" />\";\n\n  return text.toUtf8().data();\n}\n\nvoid ZimDictionary::loadResource( std::string & resourceName, string & data )\n{\n  vector< WordArticleLink > link;\n  string resData;\n\n  link = resourceIndex.findArticles( Utf8::decode( resourceName ) );\n\n  if( link.empty() )\n    return;\n\n  {\n    Mutex::Lock _( zimMutex );\n    readArticle( df, link[ 0 ].articleOffset, data );\n  }\n}\n\nQString const& ZimDictionary::getDescription()\n{\n    if( !dictionaryDescription.isEmpty() || idxHeader.descriptionPtr == 0xFFFFFFFF )\n        return dictionaryDescription;\n\n    string str;\n    {\n      Mutex::Lock _( zimMutex );\n      readArticle( df, idxHeader.descriptionPtr, str );\n    }\n\n    if( !str.empty() )\n      dictionaryDescription = QString::fromUtf8( str.c_str(), str.size() );\n\n    return dictionaryDescription;\n}\n\nvoid ZimDictionary::makeFTSIndex( QAtomicInt & isCancelled, bool firstIteration )\n{\n  if( !( Dictionary::needToRebuildIndex( getDictionaryFilenames(), ftsIdxName )\n         || FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) ) )\n    FTS_index_completed.ref();\n\n  if( haveFTSIndex() )\n    return;\n\n  if( ensureInitDone().size() )\n    return;\n\n  if( firstIteration )\n    return;\n\n  gdDebug( \"Zim: Building the full-text index for dictionary: %s\\n\",\n           getName().c_str() );\n\n  try\n  {\n    Mutex::Lock _( getFtsMutex() );\n\n    File::Class ftsIdx( ftsIndexName(), \"wb\" );\n\n    FtsHelpers::FtsIdxHeader ftsIdxHeader;\n    memset( &ftsIdxHeader, 0, sizeof( ftsIdxHeader ) );\n\n    // We write a dummy header first. At the end of the process the header\n    // will be rewritten with the right values.\n\n    ftsIdx.write( ftsIdxHeader );\n\n    ChunkedStorage::Writer chunks( ftsIdx );\n\n    BtreeIndexing::IndexedWords indexedWords;\n\n    QSet< uint32_t > setOfOffsets;\n    setOfOffsets.reserve( getWordCount() );\n\n    findArticleLinks( 0, &setOfOffsets, 0, &isCancelled );\n\n    if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      throw exUserAbort();\n\n    // We should sort articles order by cluster number\n    // to effective use clusters data caching\n\n    QVector< QPair< quint32, uint32_t > > offsetsWithClusters;\n    offsetsWithClusters.reserve( setOfOffsets.size() );\n\n    for( QSet< uint32_t >::ConstIterator it = setOfOffsets.constBegin();\n         it != setOfOffsets.constEnd(); ++it )\n    {\n      if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n        throw exUserAbort();\n\n      Mutex::Lock _( zimMutex );\n      offsetsWithClusters.append( QPair< uint32_t, quint32 >( getArticleCluster( df, *it ), *it ) );\n    }\n\n    // Free memory\n    setOfOffsets.clear();\n\n    if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      throw exUserAbort();\n\n    std::sort( offsetsWithClusters.begin(), offsetsWithClusters.end() );\n\n    QVector< uint32_t > offsets;\n    offsets.resize( offsetsWithClusters.size() );\n    for( int i = 0; i < offsetsWithClusters.size(); i++ )\n      offsets[ i ] = offsetsWithClusters.at( i ).second;\n\n    // Free memory\n    offsetsWithClusters.clear();\n    offsetsWithClusters.squeeze();\n\n    if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      throw exUserAbort();\n\n    QMap< QString, QVector< uint32_t > > ftsWords;\n\n    set< quint32 > indexedArticles;\n    quint32 articleNumber;\n\n    // index articles for full-text search\n    for( int i = 0; i < offsets.size(); i++ )\n    {\n      if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n        throw exUserAbort();\n\n      QString headword, articleStr;\n\n      articleNumber = getArticleText( offsets.at( i ), headword, articleStr,\n                                      &indexedArticles );\n      if( articleNumber == 0xFFFFFFFF )\n        continue;\n\n      indexedArticles.insert( articleNumber );\n\n      FtsHelpers::parseArticleForFts( offsets.at( i ), articleStr, ftsWords );\n    }\n\n    // Free memory\n    indexedArticles.clear();\n    offsets.clear();\n    offsets.squeeze();\n\n# define BUF_SIZE 20000\n    QVector< QPair< wstring, uint32_t > > wordsWithOffsets;\n    wordsWithOffsets.reserve( BUF_SIZE );\n\n    QMap< QString, QVector< uint32_t > >::iterator it = ftsWords.begin();\n    while( it != ftsWords.end() )\n    {\n      if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n        throw exUserAbort();\n\n      uint32_t offset = chunks.startNewBlock();\n      uint32_t size = it.value().size();\n\n      chunks.addToBlock( &size, sizeof(uint32_t) );\n      chunks.addToBlock( it.value().data(), size * sizeof(uint32_t) );\n\n      wordsWithOffsets.append( QPair< wstring, uint32_t >( gd::toWString( it.key() ), offset ) );\n\n      it = ftsWords.erase( it );\n\n      if( wordsWithOffsets.size() >= BUF_SIZE )\n      {\n        for( int i = 0; i < wordsWithOffsets.size(); i++ )\n        {\n          if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n            throw exUserAbort();\n          indexedWords.addSingleWord( wordsWithOffsets[ i ].first, wordsWithOffsets[ i ].second );\n        }\n        wordsWithOffsets.clear();\n      }\n    }\n\n    // Free memory\n    ftsWords.clear();\n\n    for( int i = 0; i < wordsWithOffsets.size(); i++ )\n    {\n      if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n        throw exUserAbort();\n      indexedWords.addSingleWord( wordsWithOffsets[ i ].first, wordsWithOffsets[ i ].second );\n    }\n#undef BUF_SIZE\n\n    // Free memory\n    wordsWithOffsets.clear();\n    wordsWithOffsets.squeeze();\n\n    if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      throw exUserAbort();\n\n    ftsIdxHeader.chunksOffset = chunks.finish();\n    ftsIdxHeader.wordCount = indexedWords.size();\n\n    if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      throw exUserAbort();\n\n    BtreeIndexing::IndexInfo ftsIdxInfo = BtreeIndexing::buildIndex( indexedWords, ftsIdx );\n\n    // Free memory\n    indexedWords.clear();\n\n    ftsIdxHeader.indexBtreeMaxElements = ftsIdxInfo.btreeMaxElements;\n    ftsIdxHeader.indexRootOffset = ftsIdxInfo.rootOffset;\n\n    ftsIdxHeader.signature = FtsHelpers::FtsSignature;\n    ftsIdxHeader.formatVersion = FtsHelpers::CurrentFtsFormatVersion + getFtsIndexVersion();\n\n    ftsIdx.rewind();\n    ftsIdx.writeRecords( &ftsIdxHeader, sizeof(ftsIdxHeader), 1 );\n\n    FTS_index_completed.ref();\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"Zim: Failed building full-text search index for \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n    QFile::remove( FsEncoding::decode( ftsIdxName.c_str() ) );\n  }\n}\n\nvoid ZimDictionary::sortArticlesOffsetsForFTS( QVector< uint32_t > & offsets,\n                                               QAtomicInt & isCancelled )\n{\n  QVector< QPair< quint32, uint32_t > > offsetsWithClusters;\n  offsetsWithClusters.reserve( offsets.size() );\n\n  for( QVector< uint32_t >::ConstIterator it = offsets.constBegin();\n       it != offsets.constEnd(); ++it )\n  {\n    if( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n      return;\n\n    Mutex::Lock _( zimMutex );\n    offsetsWithClusters.append( QPair< uint32_t, quint32 >( getArticleCluster( df, *it ), *it ) );\n  }\n\n  std::sort( offsetsWithClusters.begin(), offsetsWithClusters.end() );\n\n  for( int i = 0; i < offsetsWithClusters.size(); i++ )\n    offsets[ i ] = offsetsWithClusters.at( i ).second;\n}\n\nvoid ZimDictionary::getArticleText( uint32_t articleAddress, QString & headword, QString & text )\n{\n  try\n  {\n    headword.clear();\n    string articleText;\n\n    loadArticle( articleAddress, articleText, 0, true );\n    text = Html::unescape( QString::fromUtf8( articleText.data(), articleText.size() ) );\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"Zim: Failed retrieving article from \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n  }\n}\n\nquint32 ZimDictionary::getArticleText( uint32_t articleAddress, QString & headword, QString & text,\n                                    set< quint32 > * loadedArticles )\n{\n  quint32 articleNumber = 0xFFFFFFFF;\n  try\n  {\n    headword.clear();\n    string articleText;\n\n    articleNumber = loadArticle( articleAddress, articleText, loadedArticles, true );\n    text = Html::unescape( QString::fromUtf8( articleText.data(), articleText.size() ) );\n  }\n  catch( std::exception &ex )\n  {\n    gdWarning( \"Zim: Failed retrieving article from \\\"%s\\\", reason: %s\\n\", getName().c_str(), ex.what() );\n  }\n  return articleNumber;\n}\n\nsptr< Dictionary::DataRequest > ZimDictionary::getSearchResults( QString const & searchString,\n                                                                 int searchMode, bool matchCase,\n                                                                 int distanceBetweenWords,\n                                                                 int maxResults,\n                                                                 bool ignoreWordsOrder,\n                                                                 bool ignoreDiacritics,\n                                                                 QThreadPool * ftsThreadPoolPtr )\n{\n  return new FtsHelpers::FTSResultsRequest( *this, searchString,searchMode, matchCase, distanceBetweenWords, maxResults, ignoreWordsOrder, ignoreDiacritics, ftsThreadPoolPtr );\n}\n\n/// ZimDictionary::getArticle()\n\nclass ZimArticleRequest;\n\nclass ZimArticleRequestRunnable: public QRunnable\n{\n  ZimArticleRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  ZimArticleRequestRunnable( ZimArticleRequest & r_,\n                             QSemaphore & hasExited_ ): r( r_ ),\n                                                        hasExited( hasExited_ )\n  {}\n\n  ~ZimArticleRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass ZimArticleRequest: public Dictionary::DataRequest\n{\n  friend class ZimArticleRequestRunnable;\n\n  wstring word;\n  vector< wstring > alts;\n  ZimDictionary & dict;\n  bool ignoreDiacritics;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  ZimArticleRequest( wstring const & word_,\n                     vector< wstring > const & alts_,\n                     ZimDictionary & dict_, bool ignoreDiacritics_ ):\n    word( word_ ), alts( alts_ ), dict( dict_ ), ignoreDiacritics( ignoreDiacritics_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new ZimArticleRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by ZimArticleRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~ZimArticleRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid ZimArticleRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid ZimArticleRequest::run()\n{\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  vector< WordArticleLink > chain = dict.findArticles( word, ignoreDiacritics );\n\n  for( unsigned x = 0; x < alts.size(); ++x )\n  {\n    /// Make an additional query for each alt\n\n    vector< WordArticleLink > altChain = dict.findArticles( alts[ x ], ignoreDiacritics );\n\n    chain.insert( chain.end(), altChain.begin(), altChain.end() );\n  }\n\n  multimap< wstring, pair< string, string > > mainArticles, alternateArticles;\n\n  set< quint32 > articlesIncluded; // Some synonims make it that the articles\n                                    // appear several times. We combat this\n                                    // by only allowing them to appear once.\n\n  wstring wordCaseFolded = Folding::applySimpleCaseOnly( word );\n  if( ignoreDiacritics )\n    wordCaseFolded = Folding::applyDiacriticsOnly( wordCaseFolded );\n\n  for( unsigned x = 0; x < chain.size(); ++x )\n  {\n    if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n    {\n      finish();\n      return;\n    }\n\n    // Now grab that article\n\n    string headword, articleText;\n\n    headword = chain[ x ].word;\n\n    quint32 articleNumber = 0xFFFFFFFF;\n    try\n    {\n      articleNumber = dict.loadArticle( chain[ x ].articleOffset, articleText, &articlesIncluded );\n    }\n    catch(...)\n    {\n    }\n\n    if( articleNumber == 0xFFFFFFFF )\n      continue; // No article loaded\n\n    if ( articlesIncluded.find( articleNumber ) != articlesIncluded.end() )\n      continue; // We already have this article in the body.\n\n    // Ok. Now, does it go to main articles, or to alternate ones? We list\n    // main ones first, and alternates after.\n\n    // We do the case-folded comparison here.\n\n    wstring headwordStripped =\n      Folding::applySimpleCaseOnly( Utf8::decode( headword ) );\n    if( ignoreDiacritics )\n      headwordStripped = Folding::applyDiacriticsOnly( headwordStripped );\n\n    multimap< wstring, pair< string, string > > & mapToUse =\n      ( wordCaseFolded == headwordStripped ) ?\n        mainArticles : alternateArticles;\n\n    mapToUse.insert( pair< wstring, pair< string, string > >(\n      Folding::applySimpleCaseOnly( Utf8::decode( headword ) ),\n      pair< string, string >( headword, articleText ) ) );\n\n    articlesIncluded.insert( articleNumber );\n  }\n\n  if ( mainArticles.empty() && alternateArticles.empty() )\n  {\n    // No such word\n    finish();\n    return;\n  }\n\n  string result;\n\n  // See Issue #271: A mechanism to clean-up invalid HTML cards.\n  string cleaner = \"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\n                   \"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\"</font>\"\n                   \"</b></b></b></b></b></b></b></b>\"\n                   \"</i></i></i></i></i></i></i></i>\"\n                   \"</a></a></a></a></a></a></a></a>\";\n\n  multimap< wstring, pair< string, string > >::const_iterator i;\n\n\n  for( i = mainArticles.begin(); i != mainArticles.end(); ++i )\n  {\n      result += \"<div class=\\\"zimdict\\\">\";\n      result += \"<h2 class=\\\"zimdict_headword\\\">\";\n      result += i->second.first;\n      result += \"</h2>\";\n      result += i->second.second;\n      result += cleaner + \"</div>\";\n  }\n\n  for( i = alternateArticles.begin(); i != alternateArticles.end(); ++i )\n  {\n      result += \"<div class=\\\"zimdict\\\">\";\n      result += \"<h2 class=\\\"zimdict_headword\\\">\";\n      result += i->second.first;\n      result += \"</h2>\";\n      result += i->second.second;\n      result += cleaner + \"</div>\";\n  }\n\n  Mutex::Lock _( dataMutex );\n\n  data.resize( result.size() );\n\n  memcpy( &data.front(), result.data(), result.size() );\n\n  hasAnyData = true;\n\n  finish();\n}\n\nsptr< Dictionary::DataRequest > ZimDictionary::getArticle( wstring const & word,\n                                                           vector< wstring > const & alts,\n                                                           wstring const &,\n                                                           bool ignoreDiacritics )\n  THROW_SPEC( std::exception )\n{\n  return new ZimArticleRequest( word, alts, *this, ignoreDiacritics );\n}\n\n//// ZimDictionary::getResource()\n\nclass ZimResourceRequest;\n\nclass ZimResourceRequestRunnable: public QRunnable\n{\n  ZimResourceRequest & r;\n  QSemaphore & hasExited;\n\npublic:\n\n  ZimResourceRequestRunnable( ZimResourceRequest & r_,\n                              QSemaphore & hasExited_ ): r( r_ ),\n                                                         hasExited( hasExited_ )\n  {}\n\n  ~ZimResourceRequestRunnable()\n  {\n    hasExited.release();\n  }\n\n  virtual void run();\n};\n\nclass ZimResourceRequest: public Dictionary::DataRequest\n{\n  friend class ZimResourceRequestRunnable;\n\n  ZimDictionary & dict;\n\n  string resourceName;\n\n  QAtomicInt isCancelled;\n  QSemaphore hasExited;\n\npublic:\n\n  ZimResourceRequest( ZimDictionary & dict_,\n                      string const & resourceName_ ):\n    dict( dict_ ),\n    resourceName( resourceName_ )\n  {\n    QThreadPool::globalInstance()->start(\n      new ZimResourceRequestRunnable( *this, hasExited ) );\n  }\n\n  void run(); // Run from another thread by ZimResourceRequestRunnable\n\n  virtual void cancel()\n  {\n    isCancelled.ref();\n  }\n\n  ~ZimResourceRequest()\n  {\n    isCancelled.ref();\n    hasExited.acquire();\n  }\n};\n\nvoid ZimResourceRequestRunnable::run()\n{\n  r.run();\n}\n\nvoid ZimResourceRequest::run()\n{\n  // Some runnables linger enough that they are cancelled before they start\n  if ( Qt4x5::AtomicInt::loadAcquire( isCancelled ) )\n  {\n    finish();\n    return;\n  }\n\n  try\n  {\n    string resource;\n    dict.loadResource( resourceName, resource );\n    if( resource.empty() )\n      throw File::Ex();\n\n    if( Filetype::isNameOfCSS( resourceName ) )\n    {\n      QString css = QString::fromUtf8( resource.data(), resource.size() );\n      dict.isolateCSS( css, \".zimdict\" );\n      QByteArray bytes = css.toUtf8();\n\n      Mutex::Lock _( dataMutex );\n      data.resize( bytes.size() );\n      memcpy( &data.front(), bytes.constData(), bytes.size() );\n    }\n    else\n    if ( Filetype::isNameOfTiff( resourceName ) )\n    {\n      // Convert it\n\n      dataMutex.lock();\n\n      QImage img = QImage::fromData( reinterpret_cast< const uchar * >( resource.data() ), resource.size() );\n\n#ifdef MAKE_EXTRA_TIFF_HANDLER\n      if( img.isNull() )\n        GdTiff::tiffToQImage( &data.front(), data.size(), img );\n#endif\n\n      dataMutex.unlock();\n\n      if ( !img.isNull() )\n      {\n        // Managed to load -- now store it back as BMP\n\n        QByteArray ba;\n        QBuffer buffer( &ba );\n        buffer.open( QIODevice::WriteOnly );\n        img.save( &buffer, \"BMP\" );\n\n        Mutex::Lock _( dataMutex );\n\n        data.resize( buffer.size() );\n\n        memcpy( &data.front(), buffer.data(), data.size() );\n      }\n    }\n    else\n    {\n      Mutex::Lock _( dataMutex );\n      data.resize( resource.size() );\n      memcpy( &data.front(), resource.data(), data.size() );\n    }\n\n    Mutex::Lock _( dataMutex );\n    hasAnyData = true;\n  }\n  catch( std::exception &ex )\n  {\n    gdCWarning( dictionaryResourceLc, \"ZIM: Failed loading resource \\\"%s\\\" from \\\"%s\\\", reason: %s\\n\",\n                resourceName.c_str(), dict.getName().c_str(), ex.what() );\n    // Resource not loaded -- we don't set the hasAnyData flag then\n  }\n\n  finish();\n}\n\nsptr< Dictionary::DataRequest > ZimDictionary::getResource( string const & name )\n  THROW_SPEC( std::exception )\n{\n  return new ZimResourceRequest( *this, name );\n}\n\n//} // anonymous namespace\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing & initializing,\n                                      unsigned maxHeadwordsToExpand )\n  THROW_SPEC( std::exception )\n{\n  vector< sptr< Dictionary::Class > > dictionaries;\n\n  for( vector< string >::const_iterator i = fileNames.begin(); i != fileNames.end();\n       ++i )\n  {\n      // Skip files with the extensions different to .zim to speed up the\n      // scanning\n\n      QString firstName = QDir::fromNativeSeparators( FsEncoding::decode( i->c_str() ) );\n      if( !firstName.endsWith( \".zim\") && !firstName.endsWith( \".zimaa\" ) )\n        continue;\n\n      // Got the file -- check if we need to rebuid the index\n\n      ZimFile df( firstName );\n\n      vector< string > dictFiles;\n      df.getFilenames( dictFiles );\n\n      string dictId = Dictionary::makeDictionaryId( dictFiles );\n\n      string indexFile = indicesDir + dictId;\n\n      try\n      {\n        if ( Dictionary::needToRebuildIndex( dictFiles, indexFile ) ||\n             indexIsOldOrBad( indexFile ) )\n        {\n          gdDebug( \"Zim: Building the index for dictionary: %s\\n\", i->c_str() );\n\n\n          unsigned articleCount = 0;\n          unsigned wordCount = 0;\n\n          df.open();\n          ZIM_header const & zh = df.header();\n\n          if( zh.magicNumber != 0x44D495A )\n            throw exNotZimFile( i->c_str() );\n\n          if( zh.mimeListPos != sizeof( ZIM_header ) )\n            throw exInvalidZimHeader( i->c_str() );\n\n          bool new_namespaces = ( zh.majorVersion >= 6 && zh.minorVersion >= 1 );\n\n          {\n            int n = firstName.lastIndexOf( '/' );\n            initializing.indexingDictionary( firstName.mid( n + 1 ).toUtf8().constData() );\n          }\n\n          File::Class idx( indexFile, \"wb\" );\n          IdxHeader idxHeader;\n          memset( &idxHeader, 0, sizeof( idxHeader ) );\n          idxHeader.namePtr = 0xFFFFFFFF;\n          idxHeader.descriptionPtr = 0xFFFFFFFF;\n          idxHeader.iconPtr = 0xFFFFFFFF;\n\n          // We write a dummy header first. At the end of the process the header\n          // will be rewritten with the right values.\n\n          idx.write( idxHeader );\n\n          IndexedWords indexedWords, indexedResources;\n\n          QByteArray artEntries;\n          df.seek( zh.urlPtrPos );\n          artEntries = df.read( (quint64)zh.articleCount * 8 );\n\n          QVector< quint64 > clusters;\n          clusters.reserve( zh.clusterCount );\n          df.seek( zh.clusterPtrPos );\n          {\n            QByteArray data = df.read( (quint64)zh.clusterCount * 8 );\n            for( unsigned n = 0; n < zh.clusterCount; n++ )\n              clusters.append( *( reinterpret_cast< const quint64 * >( data.constData() ) + n ) );\n          }\n\n          const quint64 * ptr;\n          quint16 mimetype, redirected_mime = 0xFFFF;\n          ArticleEntry artEntry;\n          RedirectEntry redEntry;\n          string url, title;\n          char nameSpace;\n          for( unsigned n = 0; n < zh.articleCount; n++ )\n          {\n            ptr = reinterpret_cast< const quint64 * >( artEntries.constData() ) + n;\n            df.seek( *ptr );\n            df.read( reinterpret_cast< char * >( &mimetype ), sizeof(mimetype) );\n            if( mimetype == 0xFFFF )\n            {\n              redEntry.mimetype = mimetype;\n              qint64 ret = df.read( reinterpret_cast< char * >( &redEntry ) + 2, sizeof(RedirectEntry) - 2 );\n              if( ret != sizeof(RedirectEntry) - 2 )\n                throw exCantReadFile( i->c_str() );\n\n              redirected_mime = df.redirectedMimeType( redEntry );\n              nameSpace = redEntry.nameSpace;\n            }\n            else\n            {\n              artEntry.mimetype = mimetype;\n              qint64 ret = df.read( reinterpret_cast< char * >( &artEntry ) + 2, sizeof(ArticleEntry) - 2 );\n              if( ret != sizeof(ArticleEntry) - 2 )\n                throw exCantReadFile( i->c_str() );\n\n              nameSpace = artEntry.nameSpace;\n\n              if( ( nameSpace == 'A' || ( nameSpace == 'C' && new_namespaces ) ) && df.isArticleMime( mimetype ) )\n                articleCount++;\n            }\n\n            // Read article url and title\n            char ch;\n\n            url.clear();\n            while( df.getChar( &ch ) )\n            {\n              if( ch == 0 )\n                break;\n              url.push_back( ch );\n            }\n\n            title.clear();\n            while( df.getChar( &ch ) )\n            {\n              if( ch == 0 )\n                break;\n              title.push_back( ch );\n            }\n\n            if( nameSpace == 'A' || ( nameSpace == 'C' && new_namespaces && ( df.isArticleMime( mimetype )\n                                                                              || ( mimetype == 0xFFFF && df.isArticleMime( redirected_mime ) ) ) ) )\n            {\n              wstring word;\n              if( !title.empty() )\n                word = Utf8::decode( title );\n              else\n                word = Utf8::decode( url );\n\n              if( df.isArticleMime( mimetype )\n                  || ( mimetype == 0xFFFF && df.isArticleMime( redirected_mime ) ) )\n              {\n                if( maxHeadwordsToExpand && zh.articleCount >= maxHeadwordsToExpand )\n                  indexedWords.addSingleWord( word, n );\n                else\n                  indexedWords.addWord( word, n );\n                wordCount++;\n              }\n              else\n              {\n                url.insert( url.begin(), '/' );\n                url.insert( url.begin(), nameSpace );\n                indexedResources.addSingleWord( Utf8::decode( url ), n );\n              }\n            }\n            else\n            if( nameSpace == 'M' )\n            {\n              if( url.compare( \"Title\" ) == 0 )\n              {\n                idxHeader.namePtr = n;\n                string name;\n                readArticle( df, n, name );\n                initializing.indexingDictionary( name );\n              }\n              else\n              if( url.compare( \"Description\" ) == 0 )\n                idxHeader.descriptionPtr = n;\n              else\n              if( url.compare( \"Language\" ) == 0 )\n              {\n                string lang;\n                readArticle( df, n, lang );\n                if( lang.size() == 2 )\n                  idxHeader.langFrom = LangCoder::code2toInt( lang.c_str() );\n                else\n                if( lang.size() == 3 )\n                  idxHeader.langFrom = LangCoder::findIdForLanguageCode3( lang.c_str() );\n                idxHeader.langTo = idxHeader.langFrom;\n              }\n              else\n              if( url.compare( \"Illustration_48x48@1\" ) == 0 )\n                idxHeader.iconPtr = n;\n            }\n            else\n            if( nameSpace == 'X' )\n            {\n              continue;\n            }\n            else\n            {\n              if( nameSpace == '-' && idxHeader.iconPtr == 0xFFFFFFFF && url.compare( \"favicon\" ) == 0 )\n                idxHeader.iconPtr = n;\n\n              url.insert( url.begin(), '/' );\n              url.insert( url.begin(), nameSpace );\n              indexedResources.addSingleWord( Utf8::decode( url ), n );\n            }\n          }\n\n          // Build index\n\n          {\n            IndexInfo idxInfo = BtreeIndexing::buildIndex( indexedWords, idx );\n\n            idxHeader.indexBtreeMaxElements = idxInfo.btreeMaxElements;\n            idxHeader.indexRootOffset = idxInfo.rootOffset;\n\n            indexedWords.clear(); // Release memory -- no need for this data\n          }\n\n          {\n            IndexInfo idxInfo = BtreeIndexing::buildIndex( indexedResources, idx );\n\n            idxHeader.resourceIndexBtreeMaxElements = idxInfo.btreeMaxElements;\n            idxHeader.resourceIndexRootOffset = idxInfo.rootOffset;\n\n            indexedResources.clear(); // Release memory -- no need for this data\n          }\n\n          idxHeader.signature = Signature;\n          idxHeader.formatVersion = CurrentFormatVersion;\n\n          idxHeader.articleCount = articleCount;\n          idxHeader.wordCount = wordCount;\n\n          idx.rewind();\n\n          idx.write( &idxHeader, sizeof( idxHeader ) );\n        }\n\n        dictionaries.push_back( new ZimDictionary( dictId,\n                                                   indexFile,\n                                                   dictFiles ) );\n      }\n      catch( std::exception & e )\n      {\n        gdWarning( \"Zim dictionary initializing failed: %s, error: %s\\n\",\n                   i->c_str(), e.what() );\n        continue;\n      }\n      catch( ... )\n      {\n        qWarning( \"Zim dictionary initializing failed\\n\" );\n        continue;\n      }\n  }\n  return dictionaries;\n}\n\n} // namespace Zim\n\n#endif\n"
        },
        {
          "name": "zim.hh",
          "type": "blob",
          "size": 0.568359375,
          "content": "#ifndef __ZIM_HH_INCLUDED__\n#define __ZIM_HH_INCLUDED__\n\n#ifdef MAKE_ZIM_SUPPORT\n\n#include \"dictionary.hh\"\n\n/// Support for the Zim dictionaries.\nnamespace Zim {\n\nusing std::vector;\nusing std::string;\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing &,\n                                      unsigned maxHeadwordsToExpand )\n  THROW_SPEC( std::exception );\n\n}\n\n#endif\n\n#endif\n"
        },
        {
          "name": "zipfile.cc",
          "type": "blob",
          "size": 6.59375,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"zipfile.hh\"\n#include <QtEndian>\n#include <QByteArray>\n#include <QFileInfo>\n\nnamespace ZipFile {\n\n#pragma pack( push, 1 )\n\n/// End-of-central-directory record, as is\nstruct EndOfCdirRecord\n{\n  quint32 signature;\n  quint16 numDisk, numDiskCd, totalEntriesDisk, totalEntries;\n  quint32 size, offset;\n  quint16 commentLength;\n}\n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\nstruct CentralFileHeaderRecord\n{\n  quint32 signature;\n  quint16 verMadeBy, verNeeded, gpBits, compressionMethod, fileTime, fileDate;\n  quint32 crc32, compressedSize, uncompressedSize;\n  quint16 fileNameLength, extraFieldLength, fileCommentLength, diskNumberStart,\n          intFileAttrs;\n  quint32 externalFileAttrs, offsetOfLocalHeader;\n}\n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\nstruct LocalFileHeaderRecord\n{\n  quint32 signature;\n  quint16 verNeeded, gpBits, compressionMethod, fileTime, fileDate;\n  quint32 crc32, compressedSize, uncompressedSize;\n  quint16 fileNameLength, extraFieldLength;\n}\n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\n#pragma pack( pop )\n\nstatic quint32 const endOfCdirRecordSignatureValue = qToLittleEndian( 0x06054b50 );\nstatic quint32 const centralFileHeaderSignature = qToLittleEndian( 0x02014b50 );\nstatic quint32 const localFileHeaderSignature = qToLittleEndian( 0x04034b50 );\n\nstatic CompressionMethod getCompressionMethod( quint16 compressionMethod )\n{\n  switch( qFromLittleEndian( compressionMethod ) )\n  {\n  case 0:\n    return Uncompressed;\n  case 8:\n    return Deflated;\n  default:\n    return Unsupported;\n  }\n}\n\nbool positionAtCentralDir( SplitZipFile & zip )\n{\n  // Find the end-of-central-directory record\n\n  int maxEofBufferSize = 65535 + sizeof( EndOfCdirRecord );\n\n  if ( zip.size() > maxEofBufferSize )\n    zip.seek( zip.size() - maxEofBufferSize );\n  else\n  if ( (size_t) zip.size() < sizeof( EndOfCdirRecord ) )\n    return false;\n  else\n    zip.seek( 0 );\n\n  QByteArray eocBuffer = zip.read( maxEofBufferSize );\n\n  if ( eocBuffer.size() < (int)sizeof( EndOfCdirRecord ) )\n    return false;\n\n  int lastIndex = eocBuffer.size() - sizeof( EndOfCdirRecord );\n\n  QByteArray endOfCdirRecordSignature( (char const *)&endOfCdirRecordSignatureValue,\n                                       sizeof( endOfCdirRecordSignatureValue ) );\n\n  EndOfCdirRecord endOfCdirRecord;\n\n  quint32 cdir_offset;\n\n  for( ; ; --lastIndex )\n  {\n    lastIndex = eocBuffer.lastIndexOf( endOfCdirRecordSignature, lastIndex );\n\n    if ( lastIndex == -1 )\n      return false;\n\n    /// We need to copy it due to possible alignment issues on ARM etc\n    memcpy( &endOfCdirRecord, eocBuffer.data() + lastIndex,\n            sizeof( endOfCdirRecord ) );\n\n    /// Sanitize the record by checking the offset\n\n    cdir_offset = zip.calcAbsoluteOffset( qFromLittleEndian( endOfCdirRecord.offset ),\n                                          qFromLittleEndian( endOfCdirRecord.numDiskCd ) );\n\n    if ( !zip.seek( cdir_offset ) )\n      continue;\n\n    quint32 signature;\n\n    if ( zip.read( (char *)&signature, sizeof( signature ) ) != sizeof( signature ) )\n      continue;\n\n    if ( signature == centralFileHeaderSignature )\n      break;\n  }\n\n  // Found cdir -- position the file on the first header\n\n  return zip.seek( cdir_offset );\n}\n\nbool readNextEntry( SplitZipFile & zip, CentralDirEntry & entry )\n{\n  CentralFileHeaderRecord record;\n\n  if ( zip.read( (char *)&record, sizeof( record ) ) != sizeof( record ) )\n    return false;\n\n  if ( record.signature != centralFileHeaderSignature )\n    return false;\n\n  // Read file name\n\n  int fileNameLength = qFromLittleEndian( record.fileNameLength );\n  entry.fileName = zip.read( fileNameLength );\n\n  if ( entry.fileName.size() != fileNameLength )\n    return false;\n\n  // Skip extra fields\n\n  if ( !zip.seek( ( zip.pos() + qFromLittleEndian( record.extraFieldLength ) ) +\n                  qFromLittleEndian( record.fileCommentLength ) ) )\n    return false;\n\n  entry.localHeaderOffset = zip.calcAbsoluteOffset( qFromLittleEndian( record.offsetOfLocalHeader ),\n                                                    qFromLittleEndian( record.diskNumberStart ) );\n  entry.compressedSize = qFromLittleEndian( record.compressedSize );\n  entry.uncompressedSize = qFromLittleEndian( record.uncompressedSize );\n  entry.compressionMethod = getCompressionMethod( record.compressionMethod );\n  entry.fileNameInUTF8 = ( qFromLittleEndian( record.gpBits ) & 0x800 ) != 0;\n\n  return true;\n}\n\nbool readLocalHeader( SplitZipFile & zip, LocalFileHeader & entry )\n{\n  LocalFileHeaderRecord record;\n\n  if ( zip.read( (char *)&record, sizeof( record ) ) != sizeof( record ) )\n    return false;\n\n  if ( record.signature != localFileHeaderSignature )\n    return false;\n\n  // Read file name\n\n  int fileNameLength = qFromLittleEndian( record.fileNameLength );\n  entry.fileName = zip.read( fileNameLength );\n\n  if ( entry.fileName.size() != fileNameLength )\n    return false;\n\n  // Skip extra field\n\n  if ( !zip.seek( zip.pos() + qFromLittleEndian( record.extraFieldLength ) ) )\n    return false;\n\n  entry.compressedSize = qFromLittleEndian( record.compressedSize );\n  entry.uncompressedSize = qFromLittleEndian( record.uncompressedSize );\n  entry.compressionMethod = getCompressionMethod( record.compressionMethod );\n\n  return true;\n}\n\nSplitZipFile::SplitZipFile( const QString & name )\n{\n  setFileName( name );\n}\n\nvoid SplitZipFile::setFileName( const QString & name )\n{\n  {\n    QString lname = name.toLower();\n    if( lname.endsWith( \".zips\" ) )\n    {\n      appendFile( name );\n      return;\n    }\n\n    if( !lname.endsWith( \".zip\" ) )\n      return;\n  }\n\n  if( QFileInfo( name ).isFile() )\n  {\n    for( int i = 1; i < 100; i++ )\n    {\n      QString name2 = name.left( name.size() - 2 ) + QString( \"%1\" ).arg( i, 2, 10, QChar( '0' ) );\n      if( QFileInfo( name2 ).isFile() )\n        appendFile( name2 );\n      else\n        break;\n    }\n    appendFile( name );\n  }\n  else\n  {\n    for( int i = 1; i < 1000; i++ )\n    {\n      QString name2 = name + QString( \".%1\" ).arg( i, 3, 10, QChar( '0' ) );\n      if( QFileInfo( name2 ).isFile() )\n        appendFile( name2 );\n      else\n        break;\n    }\n  }\n}\n\nQDateTime SplitZipFile::lastModified() const\n{\n  unsigned long ts = 0;\n  for( QVector< QFile * >::const_iterator i = files.begin(); i != files.end(); ++i )\n  {\n    unsigned long t = QFileInfo( (*i)->fileName() ).lastModified().toTime_t();\n    if( t > ts )\n      ts = t;\n  }\n  return QDateTime::fromTime_t( ts );\n}\n\nqint64 SplitZipFile::calcAbsoluteOffset( qint64 offset, quint16 partNo )\n{\n  if( partNo >= offsets.size() )\n    return 0;\n\n  return offsets.at( partNo ) + offset;\n}\n\n}\n"
        },
        {
          "name": "zipfile.hh",
          "type": "blob",
          "size": 2.119140625,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef __ZIPFILE_HH_INCLUDED__\n#define __ZIPFILE_HH_INCLUDED__\n\n#include <QFile>\n#include <QDateTime>\n#include \"splitfile.hh\"\n\n/// Support for zip files in GoldenDict. Note that the implementation is\n/// strictly tailored to GoldenDict needs only.\nnamespace ZipFile {\n\n// Support for split zip files\nclass SplitZipFile : public SplitFile::SplitFile\n{\npublic:\n  SplitZipFile()\n  {}\n  SplitZipFile( const QString & name );\n\n  virtual void setFileName( const QString & name );\n\n  // Latest modified time for all parts\n  QDateTime lastModified() const;\n\n  // Calc absolute offset by relative offset in part and part nom\n  qint64 calcAbsoluteOffset( qint64 offset, quint16 partNo );\n};\n\nenum CompressionMethod\n{\n  Uncompressed,\n  Deflated,\n  Unsupported\n};\n\n/// Entry from central dir\nstruct CentralDirEntry\n{\n  QByteArray fileName;\n\n  quint32 localHeaderOffset, compressedSize, uncompressedSize;\n  CompressionMethod compressionMethod;\n  bool fileNameInUTF8;\n};\n\n/// Represents contents of the local file header -- that what CentralDirEntry::\n/// localHeaderOffset points at.\nstruct LocalFileHeader\n{\n  QByteArray fileName;\n\n  quint32 compressedSize, uncompressedSize;\n  CompressionMethod compressionMethod;\n};\n\n/// Finds the central directory in the given file and positions it at its\n/// beginning. Returns true if the file is positioned, false otherwise (not a\n/// zip file or other error).\n/// Once the file is positioned, entries may be read by constructing Entry\n/// objects.\nbool positionAtCentralDir( SplitZipFile & );\n\n/// Reads entry from the zip at its current offset. The file gets advanced\n/// by the size of entry, so it points to the next entry.\n/// Returns true on success, false otherwise.\nbool readNextEntry( SplitZipFile &, CentralDirEntry & );\n\n/// Reads loca file header from the zip at its current offset. The file gets\n/// advanced by the size of entry and starts pointing to file data.\n/// Returns true on success, false otherwise.\nbool readLocalHeader( SplitZipFile &, LocalFileHeader & );\n\n}\n\n#endif\n"
        },
        {
          "name": "zipsounds.cc",
          "type": "blob",
          "size": 14.9169921875,
          "content": "/* This file is (c) 2008-2012 Konstantin Isakov <ikm@goldendict.org>\n * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#include \"zipsounds.hh\"\n#include \"file.hh\"\n#include \"folding.hh\"\n#include \"utf8.hh\"\n#include \"btreeidx.hh\"\n#include \"fsencoding.hh\"\n#include \"audiolink.hh\"\n#include \"indexedzip.hh\"\n#include \"filetype.hh\"\n#include \"gddebug.hh\"\n#include \"chunkedstorage.hh\"\n#include \"htmlescape.hh\"\n\n#include <set>\n#include <string>\n#include <QFile>\n#include <QDir>\n#include <QDebug>\n\n#ifdef _MSC_VER\n#include <stub_msvc.h>\n#endif\n\n#include \"qt4x5.hh\"\n\nnamespace ZipSounds {\n\nusing std::string;\nusing gd::wstring;\nusing std::map;\nusing std::multimap;\nusing std::set;\nusing BtreeIndexing::WordArticleLink;\nusing BtreeIndexing::IndexedWords;\nusing BtreeIndexing::IndexInfo;\n\nnamespace {\n\nDEF_EX( exInvalidData, \"Invalid data encountered\", Dictionary::Ex )\n\nenum\n{\n  Signature = 0x5350495a, // ZIPS on little-endian, SPIZ on big-endian\n  CurrentFormatVersion = 6 + BtreeIndexing::FormatVersion\n};\n\nstruct IdxHeader\n{\n  uint32_t signature; // First comes the signature, ZIPS\n  uint32_t formatVersion; // File format version, currently 1.\n  uint32_t soundsCount; // Total number of sounds, for informative purposes only\n  uint32_t indexBtreeMaxElements; // Two fields from IndexInfo\n  uint32_t indexRootOffset;\n  uint32_t chunksOffset; // The offset to chunks' storage\n}\n#ifndef _MSC_VER\n__attribute__((packed))\n#endif\n;\n\nbool indexIsOldOrBad( string const & indexFile )\n{\n  File::Class idx( indexFile, \"rb\" );\n\n  IdxHeader header;\n\n  return idx.readRecords( &header, sizeof( header ), 1 ) != 1 ||\n         header.signature != Signature ||\n         header.formatVersion != CurrentFormatVersion;\n}\n\nwstring stripExtension( string const & str )\n{\n  wstring name;\n  try\n  {\n    name = Utf8::decode( str );\n  }\n  catch( Utf8::exCantDecode & )\n  {\n    return name;\n  }\n\n  if( Filetype::isNameOfSound( str ) )\n  {\n    wstring::size_type pos = name.rfind( L'.' );\n    if ( pos != wstring::npos )\n      name.erase( pos );\n\n    // Strip spaces at the end of name\n    string::size_type n = name.length();\n    while( n && name.at( n - 1 ) == L' ' )\n      n--;\n\n    if( n != name.length() )\n      name.erase( n );\n  }\n  return name;\n}\n\nclass ZipSoundsDictionary: public BtreeIndexing::BtreeDictionary\n{\n  Mutex idxMutex;\n  File::Class idx;\n  IdxHeader idxHeader;\n  sptr< ChunkedStorage::Reader > chunks;\n  IndexedZip zipsFile;\n\npublic:\n\n  ZipSoundsDictionary( string const & id, string const & indexFile,\n                       vector< string > const & dictionaryFiles );\n\n  virtual string getName() throw();\n\n  virtual map< Dictionary::Property, string > getProperties() throw()\n  { return map< Dictionary::Property, string >(); }\n\n  virtual unsigned long getArticleCount() throw()\n  { return idxHeader.soundsCount; }\n\n  virtual unsigned long getWordCount() throw()\n  { return getArticleCount(); }\n\n  virtual sptr< Dictionary::DataRequest > getArticle( wstring const &,\n                                                      vector< wstring > const & alts,\n                                                      wstring const &,\n                                                      bool ignoreDiacritics )\n    THROW_SPEC( std::exception );\n\n  virtual sptr< Dictionary::DataRequest > getResource( string const & name )\n    THROW_SPEC( std::exception );\n\nprotected:\n\n  virtual void loadIcon() throw();\n};\n\nZipSoundsDictionary::ZipSoundsDictionary( string const & id,\n                                          string const & indexFile,\n                                          vector< string > const & dictionaryFiles ):\n  BtreeDictionary( id, dictionaryFiles ),\n  idx( indexFile, \"rb\" ),\n  idxHeader( idx.read< IdxHeader >() )\n{\n  chunks = new ChunkedStorage::Reader( idx, idxHeader.chunksOffset );\n\n  // Initialize the index\n\n  openIndex( IndexInfo( idxHeader.indexBtreeMaxElements,\n                        idxHeader.indexRootOffset ),\n                        idx, idxMutex );\n\n  QString zipName = QDir::fromNativeSeparators(\n                    FsEncoding::decode( getDictionaryFilenames()[ 0 ].c_str() ) );\n\n  zipsFile.openZipFile( zipName );\n  zipsFile.openIndex( IndexInfo( idxHeader.indexBtreeMaxElements,\n                                 idxHeader.indexRootOffset ),\n                                 idx, idxMutex );\n\n}\n\nstring ZipSoundsDictionary::getName() throw()\n{\n  string result = FsEncoding::basename( getDictionaryFilenames()[ 0 ] );\n\n  // Strip the extension\n  result.erase( result.rfind( '.' ) );\n\n  return result;\n}\n\nsptr< Dictionary::DataRequest > ZipSoundsDictionary::getArticle( wstring const & word,\n                                                                 vector< wstring > const & alts,\n                                                                 wstring const &,\n                                                                 bool ignoreDiacritics )\n  THROW_SPEC( std::exception )\n{\n  vector< WordArticleLink > chain = findArticles( word, ignoreDiacritics );\n\n  for( unsigned x = 0; x < alts.size(); ++x )\n  {\n    /// Make an additional query for each alt\n\n    vector< WordArticleLink > altChain = findArticles( alts[ x ], ignoreDiacritics );\n\n    chain.insert( chain.end(), altChain.begin(), altChain.end() );\n  }\n\n  multimap< wstring, uint32_t > mainArticles, alternateArticles;\n\n  set< uint32_t > articlesIncluded; // Some synonims make it that the articles\n                                    // appear several times. We combat this\n                                    // by only allowing them to appear once.\n\n  wstring wordCaseFolded = Folding::applySimpleCaseOnly( word );\n  if( ignoreDiacritics )\n    wordCaseFolded = Folding::applyDiacriticsOnly( wordCaseFolded );\n\n  for( unsigned x = 0; x < chain.size(); ++x )\n  {\n    if ( articlesIncluded.find( chain[ x ].articleOffset ) != articlesIncluded.end() )\n      continue; // We already have this article in the body.\n\n    // Ok. Now, does it go to main articles, or to alternate ones? We list\n    // main ones first, and alternates after.\n\n    // We do the case-folded comparison here.\n\n    wstring headwordStripped =\n      Folding::applySimpleCaseOnly( Utf8::decode( chain[ x ].word ) );\n    if( ignoreDiacritics )\n      headwordStripped = Folding::applyDiacriticsOnly( headwordStripped );\n\n    multimap< wstring, uint32_t > & mapToUse =\n      ( wordCaseFolded == headwordStripped ) ?\n        mainArticles : alternateArticles;\n\n    mapToUse.insert( std::pair< wstring, uint32_t >(\n      Folding::applySimpleCaseOnly( Utf8::decode( chain[ x ].word ) ), chain[ x ].articleOffset ) );\n\n    articlesIncluded.insert( chain[ x ].articleOffset );\n  }\n\n  if ( mainArticles.empty() && alternateArticles.empty() )\n    return new Dictionary::DataRequestInstant( false ); // No such word\n\n  string result;\n\n  multimap< wstring, uint32_t >::const_iterator i;\n\n  result += \"<table class=\\\"lsa_play\\\">\";\n\n  vector< char > chunk;\n  char * nameBlock;\n\n  for( i = mainArticles.begin(); i != mainArticles.end(); ++i )\n  {\n    try\n    {\n      Mutex::Lock _( idxMutex );\n      nameBlock = chunks->getBlock( i->second, chunk );\n\n      if ( nameBlock >= &chunk.front() + chunk.size() )\n      {\n        // chunks reader thinks it's okay since zero-sized records can exist,\n        // but we don't allow that.\n        throw ChunkedStorage::exAddressOutOfRange();\n      }\n    }\n    catch(  ChunkedStorage::exAddressOutOfRange & )\n    {\n      // Bad address\n      continue;\n    }\n\n    uint16_t sz;\n    memcpy( &sz, nameBlock, sizeof( uint16_t ) );\n    nameBlock += sizeof( uint16_t );\n\n    string name( nameBlock, sz );\n    nameBlock += sz;\n\n    string displayedName = mainArticles.size() + alternateArticles.size() > 1 ?\n           name : Utf8::encode( stripExtension( name ) );\n\n    result += \"<tr>\";\n\n    QUrl url;\n    url.setScheme( \"gdau\" );\n    url.setHost( QString::fromUtf8( getId().c_str() ) );\n    url.setPath( Qt4x5::Url::ensureLeadingSlash( QString::fromUtf8( name.c_str() ) ) );\n\n    string ref = string( \"\\\"\" ) + url.toEncoded().data() + \"\\\"\";\n\n    result += addAudioLink( ref, getId() );\n\n    result += \"<td><a href=\" + ref + \"><img src=\\\"qrcx://localhost/icons/playsound.png\\\" border=\\\"0\\\" alt=\\\"Play\\\"/></a></td>\";\n    result += \"<td><a href=\" + ref + \">\" + Html::escape( displayedName ) + \"</a></td>\";\n    result += \"</tr>\";\n  }\n\n  for( i = alternateArticles.begin(); i != alternateArticles.end(); ++i )\n  {\n    try\n    {\n      Mutex::Lock _( idxMutex );\n      nameBlock = chunks->getBlock( i->second, chunk );\n\n      if ( nameBlock >= &chunk.front() + chunk.size() )\n      {\n        // chunks reader thinks it's okay since zero-sized records can exist,\n        // but we don't allow that.\n        throw ChunkedStorage::exAddressOutOfRange();\n      }\n    }\n    catch(  ChunkedStorage::exAddressOutOfRange & )\n    {\n      // Bad address\n      continue;\n    }\n\n    uint16_t sz;\n    memcpy( &sz, nameBlock, sizeof( uint16_t ) );\n    nameBlock += sizeof( uint16_t );\n\n    string name( nameBlock, sz );\n    nameBlock += sz;\n\n    string displayedName = mainArticles.size() + alternateArticles.size() > 1 ?\n           name : Utf8::encode( stripExtension( name ) );\n\n    result += \"<tr>\";\n\n    QUrl url;\n    url.setScheme( \"gdau\" );\n    url.setHost( QString::fromUtf8( getId().c_str() ) );\n    url.setPath( Qt4x5::Url::ensureLeadingSlash( QString::fromUtf8( name.c_str() ) ) );\n\n    string ref = string( \"\\\"\" ) + url.toEncoded().data() + \"\\\"\";\n\n    result += addAudioLink( ref, getId() );\n\n    result += \"<td><a href=\" + ref + \"><img src=\\\"qrcx://localhost/icons/playsound.png\\\" border=\\\"0\\\" alt=\\\"Play\\\"/></a></td>\";\n    result += \"<td><a href=\" + ref + \">\" + Html::escape( displayedName ) + \"</a></td>\";\n    result += \"</tr>\";\n  }\n\n  result += \"</table>\";\n\n  Dictionary::DataRequestInstant * ret =\n    new Dictionary::DataRequestInstant( true );\n\n  ret->getData().resize( result.size() );\n\n  memcpy( &(ret->getData().front()), result.data(), result.size() );\n\n  return ret;\n}\n\nsptr< Dictionary::DataRequest > ZipSoundsDictionary::getResource( string const & name )\n  THROW_SPEC( std::exception )\n{\n  // Remove extension for sound files (like in sound dirs)\n\n  wstring strippedName = stripExtension( name );\n\n  vector< WordArticleLink > chain = findArticles( strippedName );\n\n  if ( chain.empty() )\n    return new Dictionary::DataRequestInstant( false ); // No such resource\n\n  // Find sound\n\n  uint32_t dataOffset = 0;\n  for( int x = chain.size() - 1; x >= 0 ; x-- )\n  {\n    vector< char > chunk;\n    char * nameBlock = chunks->getBlock( chain[ x ].articleOffset, chunk );\n\n    uint16_t sz;\n    memcpy( &sz, nameBlock, sizeof( uint16_t ) );\n    nameBlock += sizeof( uint16_t );\n\n    string fileName( nameBlock, sz );\n    nameBlock += sz;\n\n    memcpy( &dataOffset, nameBlock, sizeof( uint32_t ) );\n\n    if( name.compare( fileName ) == 0 )\n      break;\n  }\n\n  sptr< Dictionary::DataRequestInstant > dr = new\n    Dictionary::DataRequestInstant( true );\n\n  if ( zipsFile.loadFile( dataOffset, dr->getData() ) )\n    return dr;\n\n  return new Dictionary::DataRequestInstant( false );\n}\n\nvoid ZipSoundsDictionary::loadIcon() throw()\n{\n  if ( dictionaryIconLoaded )\n    return;\n\n  QString fileName =\n    QDir::fromNativeSeparators( FsEncoding::decode( getDictionaryFilenames()[ 0 ].c_str() ) );\n\n  // Remove the extension\n  fileName.chop( 4 );\n\n  if( !loadIconFromFile( fileName ) )\n  {\n    // Load failed -- use default icons\n    dictionaryNativeIcon = dictionaryIcon = QIcon(\":/icons/playsound.png\");\n  }\n\n  dictionaryIconLoaded = true;\n}\n\n}\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing & initializing )\n  THROW_SPEC( std::exception )\n{\n  (void) initializing;\n  vector< sptr< Dictionary::Class > > dictionaries;\n\n  for( vector< string >::const_iterator i = fileNames.begin(); i != fileNames.end();\n       ++i )\n  {\n    /// Only allow .zips extension\n    if ( i->size() < 5 || strcasecmp( i->c_str() + ( i->size() - 5 ), \".zips\" ) != 0 )\n      continue;\n\n    try\n    {\n      vector< string > dictFiles( 1, *i );\n      string dictId = Dictionary::makeDictionaryId( dictFiles );\n      string indexFile = indicesDir + dictId;\n\n      if ( Dictionary::needToRebuildIndex( dictFiles, indexFile ) ||\n           indexIsOldOrBad( indexFile ) )\n      {\n        gdDebug( \"Zips: Building the index for dictionary: %s\\n\", i->c_str() );\n\n        File::Class idx( indexFile, \"wb\" );\n        IdxHeader idxHeader;\n\n        memset( &idxHeader, 0, sizeof( idxHeader ) );\n\n        // We write a dummy header first. At the end of the process the header\n        // will be rewritten with the right values.\n\n        idx.write( idxHeader );\n\n        IndexedWords names, zipFileNames;\n        ChunkedStorage::Writer chunks( idx );\n        quint32 namesCount;\n\n        IndexedZip zipFile;\n        if( zipFile.openZipFile( QDir::fromNativeSeparators(\n                                 FsEncoding::decode( i->c_str() ) ) ) )\n          zipFile.indexFile( zipFileNames, &namesCount );\n\n        if( !zipFileNames.empty() )\n        {\n          for( IndexedWords::iterator i = zipFileNames.begin(); i != zipFileNames.end(); ++i )\n          {\n            vector< WordArticleLink > links = i->second;\n            for( unsigned x = 0; x < links.size(); x++ )\n            {\n              // Save original name\n\n              uint32_t offset = chunks.startNewBlock();\n              uint16_t sz = links[ x ].word.size();\n              chunks.addToBlock( &sz, sizeof(uint16_t) );\n              chunks.addToBlock( links[ x ].word.c_str(), sz );\n              chunks.addToBlock( &links[ x ].articleOffset, sizeof( uint32_t ) );\n\n              // Remove extension for sound files (like in sound dirs)\n\n              wstring word = stripExtension( links[ x ].word );\n              if( !word.empty() )\n                names.addWord( word, offset );\n            }\n          }\n\n          // Finish with the chunks\n\n          idxHeader.chunksOffset = chunks.finish();\n\n          // Build the resulting zip file index\n\n          IndexInfo idxInfo = BtreeIndexing::buildIndex( names, idx );\n\n          // That concludes it. Update the header.\n\n          idxHeader.indexBtreeMaxElements = idxInfo.btreeMaxElements;\n          idxHeader.indexRootOffset = idxInfo.rootOffset;\n\n          idxHeader.signature = Signature;\n          idxHeader.formatVersion = CurrentFormatVersion;\n\n          idxHeader.soundsCount = namesCount;\n\n          idx.rewind();\n\n          idx.write( &idxHeader, sizeof( idxHeader ) );\n        }\n        else\n        {\n          idx.close();\n          QFile::remove( QDir::fromNativeSeparators(\n                         FsEncoding::decode( indexFile.c_str() ) ) );\n          throw exInvalidData();\n        }\n      }\n\n      dictionaries.push_back( new ZipSoundsDictionary( dictId,\n                                                       indexFile,\n                                                       dictFiles ) );\n    }\n    catch( std::exception & e )\n    {\n      gdWarning( \"Zipped sounds pack reading failed: %s, error: %s\\n\",\n                 i->c_str(), e.what() );\n    }\n  }\n\n  return dictionaries;\n}\n\n}\n"
        },
        {
          "name": "zipsounds.hh",
          "type": "blob",
          "size": 0.576171875,
          "content": "/* This file is part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */\n\n#ifndef ZIPSOUNDS_HH\n#define ZIPSOUNDS_HH\n\n#include \"dictionary.hh\"\n\n/// Support for compresses audio packs (.zips).\nnamespace ZipSounds {\n\nusing std::vector;\nusing std::string;\n\nvector< sptr< Dictionary::Class > > makeDictionaries(\n                                      vector< string > const & fileNames,\n                                      string const & indicesDir,\n                                      Dictionary::Initializing & )\n  THROW_SPEC( std::exception );\n\n}\n\n#endif // ZIPSOUNDS_HH\n"
        }
      ]
    }
  ]
}