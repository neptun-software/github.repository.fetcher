{
  "metadata": {
    "timestamp": 1736566396272,
    "page": 157,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "snowie2000/mactype",
      "stars": 10324,
      "defaultBranch": "directwrite",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.076171875,
          "content": ".vs/\n.vscode/\ndeps/\nlib/\nDebug*/\nRel*/\nx64/\n*.vcxproj.user\n*.DotSettings.user\n"
        },
        {
          "name": "EventLogging.cpp",
          "type": "blob",
          "size": 2.087890625,
          "content": "// EventLogging.cpp: implementation of the EventLogging class.\r\n//\r\n//////////////////////////////////////////////////////////////////////\r\n\r\n#include \"EventLogging.h\"\r\n\r\n#ifdef _DEBUG\r\n#undef THIS_FILE\r\nstatic char THIS_FILE[]=__FILE__;\r\n#define new DEBUG_NEW\r\n#endif\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// Construction/Destruction\r\n//////////////////////////////////////////////////////////////////////\r\n\r\nEventLogging::EventLogging()\r\n//*******************************************************************************\r\n//\tDefault Constructor is used register the event source\r\n//******************************************************************************\r\n{\r\n\t// returns a handle that links the source to the registry \r\n\tthis->m_hEventLinker = RegisterEventSource(NULL,L\"MacType\");\r\n\r\n}\r\n\r\nEventLogging::~EventLogging()\r\n//*******************************************************************************\r\n//\tDestructor is used deregister the event source\r\n//*******************************************************************************\r\n{\r\n\t// Releases the handle to the registry\r\n\tDeregisterEventSource(m_hEventLinker);\r\n}\r\n\r\n\r\n\r\nvoid EventLogging::LogIt(WORD CategoryID, DWORD EventID, LPCTSTR ArrayOfStrings[],\r\n\t\t\t\t\t\t UINT NumOfArrayStr,LPVOID RawData,DWORD RawDataSize)\r\n//*******************************************************************************\r\n//\tFunction is used to log the event into the .evt file.\r\n//\tInput:\tCategoryID is the events category classification\r\n//\t\t\tEventID is the events event classification\r\n//\t\t\tArrayOfStrings is an array of pointers to strings that are passed for additional information gathering\r\n//\t\t\tNumOfArrayStr is the number of of strings in ArrayOfStrings\r\n//\t\t\tRawData is a void pointer to hold additional raw data for event reporting\r\n//\t\t\tRawDataSize is the size of RawData in bytes\r\n//*******************************************************************************\r\n{\r\n\r\n\t// Writes data to the event log\r\n\tReportEvent(m_hEventLinker,EVENTLOG_INFORMATION_TYPE,CategoryID,\r\n\t\tEventID,NULL,NumOfArrayStr,RawDataSize,ArrayOfStrings,RawData);\t\r\n\r\n}\r\n"
        },
        {
          "name": "EventLogging.h",
          "type": "blob",
          "size": 0.837890625,
          "content": "// EventLogging.h: interface for the EventLogging class.\r\n//\r\n//////////////////////////////////////////////////////////////////////\r\n#include \"common.h\"\r\n#if !defined(AFX_EVENTLOGGING_H__4AED0DCC_4C48_4312_BA6F_E6B90AC47F32__INCLUDED_)\r\n#define AFX_EVENTLOGGING_H__4AED0DCC_4C48_4312_BA6F_E6B90AC47F32__INCLUDED_\r\n\r\n#if _MSC_VER > 1000\r\n#pragma once\r\n#endif // _MSC_VER > 1000\r\n\r\nclass EventLogging \r\n{\r\npublic:\r\n\tEventLogging();\r\n\tvirtual ~EventLogging();\r\n\r\n\t// Wrapper for ReportEvent that take care of Handle and EventType\r\n\tvirtual void LogIt(WORD CategoryID, DWORD EventID, LPCTSTR ArrayOfStrings[] = NULL,\r\n\t\tUINT NumOfArrayStr = 0,LPVOID RawData = NULL,DWORD RawDataSize = 0);\r\n\t// data member to contain handle to registry\r\n\tHANDLE m_hEventLinker;\r\n\r\n\r\n};\r\n\r\n#endif // !defined(AFX_EVENTLOGGING_H__4AED0DCC_4C48_4312_BA6F_E6B90AC47F32__INCLUDED_)\r\n"
        },
        {
          "name": "GdiPlusTypes2.h",
          "type": "blob",
          "size": 15.525390625,
          "content": "/**************************************************************************\\\n*\n* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.\n*\n* Module Name:\n*\n*   GdiplusTypes.h\n*\n* Abstract:\n*\n*   GDI+ Types\n*\n\\**************************************************************************/\n\n#ifndef _GDIPLUSTYPES_H\n#define _GDIPLUSTYPES_H\n\n//--------------------------------------------------------------------------\n// Callback functions\n//--------------------------------------------------------------------------\n\nextern \"C\" {\ntypedef BOOL (CALLBACK * ImageAbort)(VOID *);\ntypedef ImageAbort DrawImageAbort;\ntypedef ImageAbort GetThumbnailImageAbort;\n}\n\n// Callback for EnumerateMetafile methods.  The parameters are:\n\n//      recordType      WMF, EMF, or EMF+ record type\n//      flags           (always 0 for WMF/EMF records)\n//      dataSize        size of the record data (in bytes), or 0 if no data\n//      data            pointer to the record data, or NULL if no data\n//      callbackData    pointer to callbackData, if any\n\n// This method can then call Metafile::PlayRecord to play the\n// record that was just enumerated.  If this method  returns\n// FALSE, the enumeration process is aborted.  Otherwise, it continues.\n\n\n#if (GDIPVER >= 0x0110)\n// This is the main GDI+ Abort interface\n\nstruct __declspec(novtable) GdiplusAbort\n{\n    virtual HRESULT __stdcall Abort(void) = 0;\n};\n#endif //(GDIPVER >= 0x0110)\n\n//--------------------------------------------------------------------------\n// Primitive data types\n//\n// NOTE:\n//  Types already defined in standard header files:\n//      INT8\n//      UINT8\n//      INT16\n//      UINT16\n//      INT32\n//      UINT32\n//      INT64\n//      UINT64\n//\n//  Avoid using the following types:\n//      LONG - use INT\n//      ULONG - use UINT\n//      DWORD - use UINT32\n//--------------------------------------------------------------------------\n\ntypedef float REAL;\n\n#define REAL_MAX            FLT_MAX\n#define REAL_MIN            FLT_MIN\n#define REAL_TOLERANCE     (FLT_MIN * 100)\n#define REAL_EPSILON        1.192092896e-07F        /* FLT_EPSILON */\n\n//--------------------------------------------------------------------------\n// Forward declarations of common classes\n//--------------------------------------------------------------------------\n\nclass Size;\nclass SizeF;\nclass Point;\nclass PointF;\nclass Rect;\nclass RectF;\nclass CharacterRange;\n\n//--------------------------------------------------------------------------\n// Status return values from GDI+ methods\n//--------------------------------------------------------------------------\n\nenum Status\n{\n    Ok = 0,\n    GenericError = 1,\n    InvalidParameter = 2,\n    OutOfMemory = 3,\n    ObjectBusy = 4,\n    InsufficientBuffer = 5,\n    NotImplemented = 6,\n    Win32Error = 7,\n    WrongState = 8,\n    Aborted = 9,\n    FileNotFound = 10,\n    ValueOverflow = 11,\n    AccessDenied = 12,\n    UnknownImageFormat = 13,\n    FontFamilyNotFound = 14,\n    FontStyleNotFound = 15,\n    NotTrueTypeFont = 16,\n    UnsupportedGdiplusVersion = 17,\n    GdiplusNotInitialized = 18,\n    PropertyNotFound = 19,\n    PropertyNotSupported = 20,\n#if (GDIPVER >= 0x0110)\n    ProfileNotFound = 21,\n#endif //(GDIPVER >= 0x0110)\n};\n\n//--------------------------------------------------------------------------\n// Represents a dimension in a 2D coordinate system (floating-point coordinates)\n//--------------------------------------------------------------------------\n\nclass SizeF\n{\npublic:\n    SizeF()\n    {\n        Width = Height = 0.0f;\n    }\n\n    SizeF(IN const SizeF& size)\n    {\n        Width = size.Width;\n        Height = size.Height;\n    }\n\n    SizeF(IN REAL width,\n          IN REAL height)\n    {\n        Width = width;\n        Height = height;\n    }\n\n    SizeF operator+(IN const SizeF& sz) const\n    {\n        return SizeF(Width + sz.Width,\n                     Height + sz.Height);\n    }\n\n    SizeF operator-(IN const SizeF& sz) const\n    {\n        return SizeF(Width - sz.Width,\n                     Height - sz.Height);\n    }\n\n    BOOL Equals(IN const SizeF& sz) const\n    {\n        return (Width == sz.Width) && (Height == sz.Height);\n    }\n\n    BOOL Empty() const\n    {\n        return (Width == 0.0f && Height == 0.0f);\n    }\n\npublic:\n\n    REAL Width;\n    REAL Height;\n};\n\n//--------------------------------------------------------------------------\n// Represents a dimension in a 2D coordinate system (integer coordinates)\n//--------------------------------------------------------------------------\n\nclass Size\n{\npublic:\n    Size()\n    {\n        Width = Height = 0;\n    }\n\n    Size(IN const Size& size)\n    {\n        Width = size.Width;\n        Height = size.Height;\n    }\n\n    Size(IN INT width,\n         IN INT height)\n    {\n        Width = width;\n        Height = height;\n    }\n\n    Size operator+(IN const Size& sz) const\n    {\n        return Size(Width + sz.Width,\n                    Height + sz.Height);\n    }\n\n    Size operator-(IN const Size& sz) const\n    {\n        return Size(Width - sz.Width,\n                    Height - sz.Height);\n    }\n\n    BOOL Equals(IN const Size& sz) const\n    {\n        return (Width == sz.Width) && (Height == sz.Height);\n    }\n\n    BOOL Empty() const\n    {\n        return (Width == 0 && Height == 0);\n    }\n\npublic:\n\n    INT Width;\n    INT Height;\n};\n\n//--------------------------------------------------------------------------\n// Represents a location in a 2D coordinate system (floating-point coordinates)\n//--------------------------------------------------------------------------\n\nclass PointF\n{\npublic:\n   PointF()\n   {\n       X = Y = 0.0f;\n   }\n\n   PointF(IN const PointF &point)\n   {\n       X = point.X;\n       Y = point.Y;\n   }\n\n   PointF(IN const SizeF &size)\n   {\n       X = size.Width;\n       Y = size.Height;\n   }\n\n   PointF(IN REAL x,\n          IN REAL y)\n   {\n       X = x;\n       Y = y;\n   }\n\n   PointF operator+(IN const PointF& point) const\n   {\n       return PointF(X + point.X,\n                     Y + point.Y);\n   }\n\n   PointF operator-(IN const PointF& point) const\n   {\n       return PointF(X - point.X,\n                     Y - point.Y);\n   }\n\n   BOOL Equals(IN const PointF& point)\n   {\n       return (X == point.X) && (Y == point.Y);\n   }\n\npublic:\n\n    REAL X;\n    REAL Y;\n};\n\n//--------------------------------------------------------------------------\n// Represents a location in a 2D coordinate system (integer coordinates)\n//--------------------------------------------------------------------------\n\nclass Point\n{\npublic:\n   Point()\n   {\n       X = Y = 0;\n   }\n\n   Point(IN const Point &point)\n   {\n       X = point.X;\n       Y = point.Y;\n   }\n\n   Point(IN const Size &size)\n   {\n       X = size.Width;\n       Y = size.Height;\n   }\n\n   Point(IN INT x,\n         IN INT y)\n   {\n       X = x;\n       Y = y;\n   }\n\n   Point operator+(IN const Point& point) const\n   {\n       return Point(X + point.X,\n                    Y + point.Y);\n   }\n\n   Point operator-(IN const Point& point) const\n   {\n       return Point(X - point.X,\n                    Y - point.Y);\n   }\n\n   BOOL Equals(IN const Point& point)\n   {\n       return (X == point.X) && (Y == point.Y);\n   }\n\npublic:\n\n    INT X;\n    INT Y;\n};\n\n//--------------------------------------------------------------------------\n// Represents a rectangle in a 2D coordinate system (floating-point coordinates)\n//--------------------------------------------------------------------------\n\nclass RectF\n{\npublic:\n\n    RectF()\n    {\n        X = Y = Width = Height = 0.0f;\n    }\n\n    RectF(IN REAL x,\n          IN REAL y,\n          IN REAL width,\n          IN REAL height)\n    {\n        X = x;\n        Y = y;\n        Width = width;\n        Height = height;\n    }\n\n    RectF(IN const PointF& location,\n          IN const SizeF& size)\n    {\n        X = location.X;\n        Y = location.Y;\n        Width = size.Width;\n        Height = size.Height;\n    }\n\n    RectF* Clone() const\n    {\n        return new RectF(X, Y, Width, Height);\n    }\n\n    VOID GetLocation(OUT PointF* point) const\n    {\n        point->X = X;\n        point->Y = Y;\n    }\n\n    VOID GetSize(OUT SizeF* size) const\n    {\n        size->Width = Width;\n        size->Height = Height;\n    }\n\n    VOID GetBounds(OUT RectF* rect) const\n    {\n        rect->X = X;\n        rect->Y = Y;\n        rect->Width = Width;\n        rect->Height = Height;\n    }\n\n    REAL GetLeft() const\n    {\n        return X;\n    }\n\n    REAL GetTop() const\n    {\n        return Y;\n    }\n\n    REAL GetRight() const\n    {\n        return X+Width;\n    }\n\n    REAL GetBottom() const\n    {\n        return Y+Height;\n    }\n\n    BOOL IsEmptyArea() const\n    {\n        return (Width <= REAL_EPSILON) || (Height <= REAL_EPSILON);\n    }\n\n    BOOL Equals(IN const RectF & rect) const\n    {\n        return X == rect.X &&\n               Y == rect.Y &&\n               Width == rect.Width &&\n               Height == rect.Height;\n    }\n\n    BOOL Contains(IN REAL x,\n                  IN REAL y) const\n    {\n        return x >= X && x < X+Width &&\n               y >= Y && y < Y+Height;\n    }\n\n    BOOL Contains(IN const PointF& pt) const\n    {\n        return Contains(pt.X, pt.Y);\n    }\n\n    BOOL Contains(IN const RectF& rect) const\n    {\n        return (X <= rect.X) && (rect.GetRight() <= GetRight()) &&\n               (Y <= rect.Y) && (rect.GetBottom() <= GetBottom());\n    }\n\n    VOID Inflate(IN REAL dx,\n                 IN REAL dy)\n    {\n        X -= dx;\n        Y -= dy;\n        Width += 2*dx;\n        Height += 2*dy;\n    }\n\n    VOID Inflate(IN const PointF& point)\n    {\n        Inflate(point.X, point.Y);\n    }\n\n    BOOL Intersect(IN const RectF& rect)\n    {\n        return Intersect(*this, *this, rect);\n    }\n\n    static BOOL Intersect(OUT RectF& c,\n                          IN const RectF& a,\n                          IN const RectF& b)\n    {\n        REAL right = min(a.GetRight(), b.GetRight());\n        REAL bottom = min(a.GetBottom(), b.GetBottom());\n        REAL left = max(a.GetLeft(), b.GetLeft());\n        REAL top = max(a.GetTop(), b.GetTop());\n\n        c.X = left;\n        c.Y = top;\n        c.Width = right - left;\n        c.Height = bottom - top;\n        return !c.IsEmptyArea();\n    }\n\n    BOOL IntersectsWith(IN const RectF& rect) const\n    {\n        return (GetLeft() < rect.GetRight() &&\n                GetTop() < rect.GetBottom() &&\n                GetRight() > rect.GetLeft() &&\n                GetBottom() > rect.GetTop());\n    }\n\n    static BOOL Union(OUT RectF& c,\n                      IN const RectF& a,\n                      IN const RectF& b)\n    {\n        REAL right = max(a.GetRight(), b.GetRight());\n        REAL bottom = max(a.GetBottom(), b.GetBottom());\n        REAL left = min(a.GetLeft(), b.GetLeft());\n        REAL top = min(a.GetTop(), b.GetTop());\n\n        c.X = left;\n        c.Y = top;\n        c.Width = right - left;\n        c.Height = bottom - top;\n        return !c.IsEmptyArea();\n    }\n\n    VOID Offset(IN const PointF& point)\n    {\n        Offset(point.X, point.Y);\n    }\n\n    VOID Offset(IN REAL dx,\n                IN REAL dy)\n    {\n        X += dx;\n        Y += dy;\n    }\n\npublic:\n\n    REAL X;\n    REAL Y;\n    REAL Width;\n    REAL Height;\n};\n\n//--------------------------------------------------------------------------\n// Represents a rectangle in a 2D coordinate system (integer coordinates)\n//--------------------------------------------------------------------------\n\nclass Rect\n{\npublic:\n\n    Rect()\n    {\n        X = Y = Width = Height = 0;\n    }\n\n    Rect(IN INT x,\n         IN INT y,\n         IN INT width,\n         IN INT height)\n    {\n        X = x;\n        Y = y;\n        Width = width;\n        Height = height;\n    }\n\n    Rect(IN const Point& location,\n         IN const Size& size)\n    {\n        X = location.X;\n        Y = location.Y;\n        Width = size.Width;\n        Height = size.Height;\n    }\n\n    Rect* Clone() const\n    {\n        return new Rect(X, Y, Width, Height);\n    }\n\n    VOID GetLocation(OUT Point* point) const\n    {\n        point->X = X;\n        point->Y = Y;\n    }\n\n    VOID GetSize(OUT Size* size) const\n    {\n        size->Width = Width;\n        size->Height = Height;\n    }\n\n    VOID GetBounds(OUT Rect* rect) const\n    {\n        rect->X = X;\n        rect->Y = Y;\n        rect->Width = Width;\n        rect->Height = Height;\n    }\n\n    INT GetLeft() const\n    {\n        return X;\n    }\n\n    INT GetTop() const\n    {\n        return Y;\n    }\n\n    INT GetRight() const\n    {\n        return X+Width;\n    }\n\n    INT GetBottom() const\n    {\n        return Y+Height;\n    }\n\n    BOOL IsEmptyArea() const\n    {\n        return (Width <= 0) || (Height <= 0);\n    }\n\n    BOOL Equals(IN const Rect & rect) const\n    {\n        return X == rect.X &&\n               Y == rect.Y &&\n               Width == rect.Width &&\n               Height == rect.Height;\n    }\n\n    BOOL Contains(IN INT x,\n                  IN INT y) const\n    {\n        return x >= X && x < X+Width &&\n               y >= Y && y < Y+Height;\n    }\n\n    BOOL Contains(IN const Point& pt) const\n    {\n        return Contains(pt.X, pt.Y);\n    }\n\n    BOOL Contains(IN Rect& rect) const\n    {\n        return (X <= rect.X) && (rect.GetRight() <= GetRight()) &&\n               (Y <= rect.Y) && (rect.GetBottom() <= GetBottom());\n    }\n\n    VOID Inflate(IN INT dx,\n                 IN INT dy)\n    {\n        X -= dx;\n        Y -= dy;\n        Width += 2*dx;\n        Height += 2*dy;\n    }\n\n    VOID Inflate(IN const Point& point)\n    {\n        Inflate(point.X, point.Y);\n    }\n\n    BOOL Intersect(IN const Rect& rect)\n    {\n        return Intersect(*this, *this, rect);\n    }\n\n    static BOOL Intersect(OUT Rect& c,\n                          IN const Rect& a,\n                          IN const Rect& b)\n    {\n        INT right = min(a.GetRight(), b.GetRight());\n        INT bottom = min(a.GetBottom(), b.GetBottom());\n        INT left = max(a.GetLeft(), b.GetLeft());\n        INT top = max(a.GetTop(), b.GetTop());\n\n        c.X = left;\n        c.Y = top;\n        c.Width = right - left;\n        c.Height = bottom - top;\n        return !c.IsEmptyArea();\n    }\n\n    BOOL IntersectsWith(IN const Rect& rect) const\n    {\n        return (GetLeft() < rect.GetRight() &&\n                GetTop() < rect.GetBottom() &&\n                GetRight() > rect.GetLeft() &&\n                GetBottom() > rect.GetTop());\n    }\n\n    static BOOL Union(OUT Rect& c,\n                      IN const Rect& a,\n                      IN const Rect& b)\n    {\n        INT right = max(a.GetRight(), b.GetRight());\n        INT bottom = max(a.GetBottom(), b.GetBottom());\n        INT left = min(a.GetLeft(), b.GetLeft());\n        INT top = min(a.GetTop(), b.GetTop());\n\n        c.X = left;\n        c.Y = top;\n        c.Width = right - left;\n        c.Height = bottom - top;\n        return !c.IsEmptyArea();\n    }\n\n    VOID Offset(IN const Point& point)\n    {\n        Offset(point.X, point.Y);\n    }\n\n    VOID Offset(IN INT dx,\n                IN INT dy)\n    {\n        X += dx;\n        Y += dy;\n    }\n\npublic:\n\n    INT X;\n    INT Y;\n    INT Width;\n    INT Height;\n};\n\nclass PathData\n{\npublic:\n    PathData()\n    {\n        Count = 0;\n        Points = NULL;\n        Types = NULL;\n    }\n\n    ~PathData()\n    {\n        if (Points != NULL)\n        {\n            delete [] Points;\n        }\n\n        if (Types != NULL)\n        {\n            delete [] Types;\n        }\n    }\n\nprivate:\n    PathData(const PathData &);\n    PathData& operator=(const PathData &);\n\npublic:\n    INT Count;\n    PointF* Points;\n    __field_ecount_opt(Count) BYTE* Types;\n};\n\nclass CharacterRange\n{\npublic:\n    CharacterRange(\n        INT first,\n        INT length\n    ) :\n        First   (first),\n        Length  (length)\n    {}\n\n    CharacterRange() : First(0), Length(0)\n    {}\n\n    CharacterRange & operator = (const CharacterRange &rhs)\n    {\n        First  = rhs.First;\n        Length = rhs.Length;\n        return *this;\n    }\n\n    INT First;\n    INT Length;\n};\n\n#endif // !_GDIPLUSTYPES_HPP\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 34.3251953125,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<https://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<https://www.gnu.org/licenses/why-not-lgpl.html>.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 3.404296875,
          "content": "# usage:\n#  nmake            release build\n#  nmake debug=1    debug build\n#  nmake ddk=1      using DDK compiler\n#  nmake sse=1      build for SSE capable CPUs (uses with ddk=1)\n#  nmake clean      clean all file(s)\n#  nmake cleanobj   clean object file(s)\n\nGDI_PREFIX = ..\\gdi++\nGDI_PREFIX_DDK = ..\\gdi++\nGDI_PREFIX_SSE = ..\\gdi++_sse\n\nTARGET_EXE = $(GDI_PREFIX).exe\nTARGET_DLL = $(GDI_PREFIX).dll\n\nEXE_OBJS = run.obj gdiexe.res\nDLL_OBJS = hook.obj override.obj settings.obj cache.obj misc.obj expfunc.obj ft.obj fteng.obj ft2vert.obj gdidll.res\nLINK_LIBS  = memcpy_amd.lib\n\nEXE_PREFIX = ..\\gdiexe\nDLL_PREFIX = ..\\gdidll\n\n.SUFFIXES: .c .cpp .obj .rc .res\n\nCPPFLAGS   = /nologo /D \"WIN32\"\nLINKFLAGS  = /nologo\nLINK_EXE   = /map:$(EXE_PREFIX).map\nLINK_DLL   = /map:$(DLL_PREFIX).map\n\nCPPOPT     = /G6 /Gy /QI0f- /QIfdiv-\nLINKOPT    = /opt:nowin98 /opt:icf /opt:ref\n\n!ifdef ddk\nTARGET_DLL = $(GDI_PREFIX_DDK).dll\nDLL_PREFIX = ..\\gdidll\n\n!ifdef sse\nTARGET_EXE = $(GDI_PREFIX_SSE).exe\nTARGET_DLL = $(GDI_PREFIX_SSE).dll\nCPPOPT     = $(CPPOPT) /GL /arch:SSE\n!else\nCPPOPT     = /G7 /Gy /QI0f- /QIfdiv- /GL /arch:SSE2\n!endif\n\nLINKOPT    = $(LINKOPT) /ltcg /ignore:4070,4078 bufferoverflowU.lib\nLINK_LIBS  = detoured_.lib detours_.lib $(LINK_LIBS)\n\n!else\nLINK_LIBS  = detoured.lib detours.lib $(LINK_LIBS)\n!endif\n\n!ifdef ftstatic\nCPPFLAGS  = $(CPPFLAGS) /D \"FREETYPE_STATIC\"\nFTLIB     = freetypeMT\n!else\nFTLIB     = freetype\n!endif\n\n!ifdef debug\nCPPFLAGS  = $(CPPFLAGS) /Od /MDd /FD /GZ /Zi /D \"DEBUG\" /D \"_DEBUG\"\nLINKFLAGS = $(LINKFLAGS) /incremental:no /debug /machine:I386 /opt:ref /opt:noicf\nLINK_EXE  = $(LINK_EXE) /pdb:$(EXE_PREFIX).pdb\n#LINK_DLL  = $(LINK_DLL) $(FTLIB)D.lib /pdb:$(DLL_PREFIX).pdb\nLINK_DLL  = $(LINK_DLL) $(FTLIB).lib /pdb:$(DLL_PREFIX).pdb\n!else\nCPPFLAGS  = $(CPPFLAGS) $(CPPOPT) /O2 /MD\nLINK_DLL  = $(LINK_DLL) $(LINKOPT) $(FTLIB).lib\nLINK_EXE  = $(LINK_EXE) $(LINKOPT)\n!endif\n\nall: $(TARGET_EXE) $(TARGET_DLL)\n\n$(TARGET_EXE): $(EXE_OBJS)\n\tlink $(LINKFLAGS) $(LINK_EXE) $(LINK_LIBS) /out:$@ $(EXE_OBJS)\n\n$(TARGET_DLL): $(DLL_OBJS) expfunc.def\n\tlink /dll $(LINKFLAGS) $(LINK_DLL) $(LINK_LIBS) /def:expfunc.def /out:$@ $(DLL_OBJS)\n\n.c.obj:\n\tcl $(CPPFLAGS) /GF /GA /W3 /Fo$@ /c $<\n\n.cpp.obj:\n\tcl $(CPPFLAGS) /GF /GA /W3 /Fo$@ /c $<\n\n.rc.res:\n\trc /l 0x411 $<\n\nclean: cleanobj\n\t@-erase \"$(TARGET_EXE)\"\n\t@-erase \"$(TARGET_DLL)\"\n\ncleanobj:\n\t@-erase $(EXE_OBJS)\n\t@-erase $(DLL_OBJS)\n\t@-erase ..\\gdi???.map\n\t@-erase vc??.pdb\n\t@-erase vc??.idb\n\t@-erase \"$(EXE_PREFIX).pdb\"\n\t@-erase \"$(DLL_PREFIX).pdb\"\n\t@-erase \"$(GDI_PREFIX).exp\"\n\t@-erase \"$(GDI_PREFIX).lib\"\n\t@-erase \"$(GDI_PREFIX_DDK).exp\"\n\t@-erase \"$(GDI_PREFIX_DDK).lib\"\n\t@-erase \"$(GDI_PREFIX_SSE).exp\"\n\t@-erase \"$(GDI_PREFIX_SSE).lib\"\n\nhook.obj:     hook.cpp ft.h hooklist.h override.h common.h array.h cache.h settings.h tlsdata.h fteng.h\noverride.obj: override.cpp ft.h hooklist.h override.h common.h array.h cache.h settings.h tlsdata.h fteng.h supinfo.h\ncache.obj:    cache.cpp hooklist.h override.h common.h array.h cache.h\nmisc.obj:     misc.cpp common.h array.h\nsettings.obj: settings.cpp common.h array.h cache.h settings.h strtoken.h supinfo.h fteng.h\nexpfunc.obj:  expfunc.cpp common.h array.h cache.h settings.h\nft.obj:       ft.cpp ft.h override.h common.h array.h cache.h settings.h fteng.h ft2vert.h\nfteng.obj:    fteng.cpp ft.h override.h common.h array.h cache.h settings.h fteng.h\nft2vert.obj:  ft2vert.c ft2vert.h\nrun.obj:      run.cpp expfunc.cpp supinfo.h gdiexe.rc\ngdiexe.res:   gdiexe.rc gdidll.rc\n"
        },
        {
          "name": "Makefile.vc2005",
          "type": "blob",
          "size": 3.5859375,
          "content": "# usage:\n#  nmake            release build\n#  nmake debug=1    debug build\n#  nmake ddk=1      using DDK compiler\n#  nmake oldpsdk=1  using old platform sdk (dynamic load SHILCreateFromPath()/SHFree())\n#  nmake clean      clean all file(s)\n#  nmake cleanobj   clean object file(s)\n\nTARGET_EXE = ..\\gdi++.exe\nTARGET_DLL = ..\\gdi++.dll\n\nEXE_OBJS = run.obj gdiexe.res\nDLL_OBJS = hook.obj override.obj settings.obj cache.obj misc.obj expfunc.obj ft.obj fteng.obj ft2vert.obj gdidll.res memcpy_amd.obj\nDLL_LIBS = advapi32.lib\n\nGDI_PREFIX = ..\\gdi++\nEXE_PREFIX = ..\\gdiexe\nDLL_PREFIX = ..\\gdidll\n\n.SUFFIXES: .c .cpp .obj .rc .res\n\nCPPFLAGS  = /nologo /D \"WIN32\" /I. /EHsc /D\nLINKFLAGS = /nologo\nLINK_EXE  = /map:$(EXE_PREFIX).map\nLINK_DLL  = /map:$(DLL_PREFIX).map\n\nCPPOPT    = /Gy /arch:SSE\nLINKOPT   = /opt:nowin98 /opt:icf /opt:ref\n\n!ifdef ddk\nGDI_PREFIX = ..\\gdi++_G7-GS-SSE2_ddk\nTARGET_DLL = ..\\gdi++_G7-GS-SSE2_ddk.dll\nDLL_PREFIX = ..\\gdidll_G7-GS-SSE2_ddk\nCPPOPT     = /G7 /Gy /GL /GS /arch:SSE2\nLINKOPT    = $(LINKOPT) /ltcg /ignore:4070,4078 bufferoverflowU.lib\n!endif\n\n!ifdef oldpsdk\nCPPFLAGS  = $(CPPFLAGS) /D \"OLD_PSDK\"\n!endif\n\n!ifdef usetrace\nCPPFLAGS  = $(CPPFLAGS) /D \"USE_TRACE\"\n!endif\n\n!ifdef ftstatic\nCPPFLAGS  = $(CPPFLAGS) /D \"FREETYPE_STATIC\"\nFTLIB     = freetypeMT\n!else\nFTLIB     = freetype\n!endif\n\n!ifdef debug\nCPPFLAGS  = $(CPPFLAGS) /Od /MTd /FD /GZ /Zi /D \"DEBUG\" /D \"_DEBUG\"\nLINKFLAGS = $(LINKFLAGS) /incremental:no /debug /machine:I386 /opt:ref /opt:noicf /Fm\nLINK_EXE  = $(LINK_EXE) /pdb:$(EXE_PREFIX).pdb\nLINK_DLL  = $(LINK_DLL) $(FTLIB)D.lib /pdb:$(DLL_PREFIX).pdb\n!else\nCPPFLAGS  = $(CPPFLAGS) $(CPPOPT) /O2 /MT /GF /GL\nLINK_DLL  = $(LINK_DLL) $(LINKOPT) $(FTLIB).lib\nLINK_EXE  = $(LINK_EXE) $(LINKOPT)\n!endif\n\n!ifdef ddk\nall: $(TARGET_DLL)\n!else\nall: $(TARGET_EXE) $(TARGET_DLL)\n!endif\n\n$(TARGET_EXE): $(EXE_OBJS)\n\tlink $(LINKFLAGS) $(LINK_EXE) /LTCG /out:$@ $(EXE_OBJS)\n\n$(TARGET_DLL): $(DLL_OBJS) expfunc.def\n\tlink /dll $(LINKFLAGS) $(LINK_DLL) /LTCG /def:expfunc.def /out:$@ $(DLL_OBJS) $(DLL_LIBS)\n\tif exist $@.manifest mt -manifest $@.manifest -outputresource:$@;2\n\npgi:\n\t-del gdi++*.pg*\n\tlink /dll $(LINKFLAGS) $(LINK_DLL) /LTCG:PGI /def:expfunc.def /out:gdi++.dll $(DLL_OBJS) $(DLL_LIBS)\n\npgo:\n\tlink /dll $(LINKFLAGS) $(LINK_DLL) /LTCG:PGO /def:expfunc.def /out:gdi++.dll $(DLL_OBJS) $(DLL_LIBS)\n\n.c.obj:\n\tcl $(CPPFLAGS) /W3 /Fo$@ /c $<\n\n.cpp.obj:\n\tcl $(CPPFLAGS) /W3 /Fo$@ /c $<\n\n.rc.res:\n\trc /l 0x411 $<\n\nclean: cleanobj\n\t@-erase \"$(TARGET_EXE)\"\n\t@-erase \"$(TARGET_DLL)\"\n\ncleanobj:\n\t@-erase $(EXE_OBJS)\n\t@-erase $(DLL_OBJS)\n\t@-erase vc??.pdb\n\t@-erase vc??.idb\n\t@-erase \"$(EXE_PREFIX).pdb\"\n\t@-erase \"$(DLL_PREFIX).pdb\"\n\t@-erase \"$(EXE_PREFIX).map\"\n\t@-erase \"$(DLL_PREFIX).map\"\n\t@-erase \"$(GDI_PREFIX).exp\"\n\t@-erase \"$(GDI_PREFIX).lib\"\n\nmemcpy_amd.obj: optimize/memcpy__amd.cpp optimize/memcpy_amd.h\n\tcl $(CPPFLAGS) /W3 /Fomemcpy_amd.obj /c optimize/memcpy__amd.cpp\n\nhook.obj:     hook.cpp ft.h hooklist.h override.h common.h array.h cache.h settings.h tlsdata.h fteng.h\noverride.obj: override.cpp ft.h hooklist.h override.h common.h array.h cache.h settings.h tlsdata.h fteng.h\ncache.obj:    cache.cpp hooklist.h override.h common.h array.h cache.h\nmisc.obj:     misc.cpp common.h array.h\nsettings.obj: settings.cpp common.h array.h cache.h settings.h strtoken.h\nexpfunc.obj:  expfunc.cpp common.h array.h cache.h settings.h\nft.obj:       ft.cpp ft.h override.h common.h array.h cache.h settings.h fteng.h ft2vert.h\nfteng.obj:    fteng.cpp ft.h override.h common.h array.h cache.h settings.h fteng.h\nft2vert.obj:  ft2vert.c ft2vert.h\nrun.obj:      run.cpp expfunc.cpp gdiexe.rc\ngdiexe.res:   gdiexe.rc gdidll.rc\ngdidll.res:   gdidll.rc\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.822265625,
          "content": "MacType\n========================\n[日本語](./README_ja-JP.md)\n\nBetter font rendering for Windows.\n\nLatest build\n------------------\n\n[Download](https://github.com/snowie2000/mactype/releases/latest)\n\nOfficial site\n------------------\n\nMacType official site: \n\nhttp://www.mactype.net (An archived version is restored)\n\nWhat's new?\n------------------\n\n- Win11 compatible\n- CET compatible\n- Updated FreeType\n- Support for color fonts :sunglasses:\n- New installer\n- Lots of bug fixes\n- Updates for multi-monitor support\n- Tray app can intercept explorer in Service Mode now\n- Tweaks for diacritics\n- Updates to EasyHook\n- Lower CPU in Tray Mode\n- Better DirectWrite support thanks to [しらいと](http://silight.hatenablog.jp)\n- Separate DirectWrite parameter adjustment\n- Traditional Chinese localization greatly improved thanks to GT Wang\n- English localization improved\n- Added Korea localization, thanks to 조현희\n- MultiLang system improved\n\nDonation\n------------------\n\nMacType now accepts donations. \n\nPlease visit http://www.mactype.net and keep an eye on the bottom right corner :heart:\n\nThank you for your support! Your donations will keep the server running, keep me updating, and buy more coffees :coffee:\n\nKnown issues\n---------------\n\n- Please backup your profiles before upgrading!\n\n- Only Chinese simplified/Traditional and English are fully localized, some options may missing in MacType Tuner due to the strings missing in the language file. You can help with translations!\n\n- If you want to use MacType-patch together with MacType official release, remember to add DirectWrite=0 to your profile or you will have mysterious problems\n\n- If you're running 64 bit Windows, antimalware/antivirus software may conflict with MacType, because it sees MacType trying to modify running software. One possible workaround is to try running in Service Mode (recommended), or add HookChildProcesses=0 to your profile. See https://github.com/snowie2000/mactype/wiki/HookChildProcesses for an explanation\n\n- Office 2013 does not use DirectWrite or GDI (it uses its own custom rendering), so Office 2013 doesn't work with MacType. If this bothers you you can use Office 2010 which uses GDI or Office 2016+ which uses DirectWrite.\n\n- WPS has a built in defense that **UNLOADS** MacType automatically. The latest version has a workaround [here](https://github.com/snowie2000/mactype/wiki/WPS) thanks to wmjordan.\n\nHow to get registry mode back\n-------------\n\nIt is no longer possible to enable registry mode via the wizard in Windows 10. \n\nWe have a detailed guide on how you can enable the registry mode manually in [wiki](https://github.com/snowie2000/mactype/wiki/Enable-registry-mode-manually), get your screwdrivers ready before you head over to it.\n\nHow to build\n-------------\n\nCheck how to build [document](https://github.com/snowie2000/mactype/blob/directwrite/doc/HOWTOBUILD.md)\n\n"
        },
        {
          "name": "README_ja-JP.md",
          "type": "blob",
          "size": 3.736328125,
          "content": "MacType\n========================\n\nWindows のフォントレンダリングを改善。\n\n最新ビルド\n------------------\n\n[ダウンロード](https://github.com/snowie2000/mactype/releases/latest)\n\n公式サイト\n------------------\n\nMacType 公式サイト: \n\nhttp://www.mactype.net\n\nWhat's new?\n------------------\n\n- Win11 の互換性\n- CET の互換性\n- 更新された FreeType\n- カラーフォントのサポート :sunglasses:\n- 新しいインストーラー\n- 多くのバグ修正\n- マルチモニターのサポートを更新\n- サービスモードでエクスプローラーのトレイアプリを傍受\n- ダイアクリティカルマークの調整\n- EasyHook を更新\n- トレイモードで CPU の低負荷設定\n- [しらいと](http://silight.hatenablog.jp)氏による DirectWrite のサポートの向上\n- DirectWrite パラメータの個別調整 \n- GT Wang による繁体字中国語の大幅な改善\n- 英語訳の改善\n- 韓国語訳の追加、조현희に感謝\n- 多言語システムの改善\n\n寄付\n------------------\n\nMacType は現在寄付を受付中です。\n\nhttp://www.mactype.net にアクセスして右下の隅にご注目ください :heart:\n\nご支援ありがとうございます! 寄付金はサーバーの維持費、更新の継続、そしてコーヒーの購入に役立てられます :coffee:\n\n既知の問題\n---------------\n\n- 更新をする前にプロファイルをバックアップしてください。\n\n- 中国語 (繁体字/簡体字) と英語のみが完全にローカライズされており、言語ファイルに文字列の欠落があります。MacType Tuner で一部のオプションに欠落がある可能性があります。翻訳にご協力ください。\n\n- MacType-patch を MacType 公式ビルドと一緒に使用したい場合は、プロファイルに｢DirectWrite=0｣を追加することを忘れないでください。この操作を忘れると動作に問題が発生します。\n\n- 64 ビットの Windows を使用している場合、マルウェアまたはウィルス対策ソフトで MacType が競合する可能性があります。これは、MacType が実行中のソフトウェアを変更しようと認識するために発生します。回避策としてはサービスモード (推奨) で実行するか、プロファイルに｢HookChildProcesses=0｣を追加してください。<br>\n詳細な説明は https://github.com/snowie2000/mactype/wiki/HookChildProcesses を参照してください。\n\n- Office 2013 は DirectWrite または GDI を使用していません (独自のカスタムレンダリングを使用しています)。そのため、Office 2013 で MacType は動作しません。これが気になる方は、GDI を使用している Office 2010 か DirectWrite を使用している Office 2016 以降を使用してください。 \n\n- WPS には MacType を自動的に **アンロード** する防御機能が組み込まれています。最新のバージョンでは、wmjordan の協力により[こちら](https://github.com/snowie2000/mactype/wiki/WPS)の回避策が用意されています。\n\nレジストリモードを戻す方法\n-------------\n\nWindows 10 以降ではウィザードを使用したレジストリモードの有効化はできなくなりました。 \n\nレジストリモードを手動で有効化する方法については、[Wiki](https://github.com/snowie2000/mactype/wiki/Enable-registry-mode-manually) に詳しいガイドがあります。<br>\nアクセスする前にスクリュードライバーを準備してくださいね。\n\nビルドのやり方\n-------------\n\nビルドについては[ドキュメント](https://github.com/snowie2000/mactype/blob/directwrite/doc/HOWTOBUILD.md)をご確認ください。\n\n"
        },
        {
          "name": "VersionHelper.cpp",
          "type": "blob",
          "size": 10.2900390625,
          "content": "#include \"VersionHelper.h\"\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// Konstruktion/Destruktion\r\n//////////////////////////////////////////////////////////////////////\r\n\r\nCVersionHelper::CVersionHelper()\r\n{\r\n\r\n}\r\n\r\nCVersionHelper::~CVersionHelper()\r\n{\r\n\r\n}\r\n\r\n/***********************************************************************************/\r\n/*                                                                                 */\r\n/* Class:   CVersionHelper                                                       */\r\n/* Method:  GetVersionInfo                                                         */\r\n/*                                                                                 */\r\n/* Parameters:                                                                     */\r\n/* -----------                                                                     */\r\n/*   HMODULE hLib                                                                  */\r\n/*                Handle to the module that contains the resource (EXE or DLL)     */\r\n/*                A value of NULL specifies the current applications resources     */\r\n/*                                                                                 */\r\n/*   CString csEntry                                                               */\r\n/*                Specifies the name of the resource. For more information,        */\r\n/*                see the Remarks section.                                         */\r\n/*                                                                                 */\r\n/* Return Values:                                                                  */\r\n/* --------------                                                                  */\r\n/* If the function succeeds, the return value is a string containing the value     */\r\n/* of the specified resource.                                                      */\r\n/* If the function fails, the returned string is empty. To get extended error      */\r\n/* information, call GetLastError.                                                 */\r\n/*                                                                                 */\r\n/* Remarks:                                                                        */\r\n/* --------                                                                        */\r\n/* Since the Win32 API resource information is encoded in Unicode, this method     */\r\n/* also strips the strings from Unicode.                                           */\r\n/*                                                                                 */\r\n/* The following valid values for csEntry, as specified by Microsoft are:          */\r\n/*   CompanyName, FileDescription, FileVersion, InternalName, LegalCopyright,      */\r\n/*   OriginalFilename, ProductName, ProductVersion, Comments, LegalTrademarks,     */\r\n/*   PrivateBuild, SpecialBuild                                                    */\r\n/*                                                                                 */\r\n/* Opening the rc-file as \"text\" or with a text-editor allows you to add further   */\r\n/* entries to your version information structure and it is retrievable using       */\r\n/* this same method.                                                               */\r\n/*                                                                                 */\r\n/***********************************************************************************/\r\n\r\nwstring CVersionHelper::GetVersionInfo(HMODULE hLib, wstring csEntry)\r\n{\r\n\twstring csRet;\r\n\r\n\tif (hLib == NULL)\r\n\t\treturn TEXT(\"\");\r\n\r\n\tHRSRC hVersion = FindResource(hLib, MAKEINTRESOURCE(VS_VERSION_INFO), RT_VERSION);\r\n\tif (hVersion != NULL)\r\n\t{\r\n\t\tHGLOBAL hGlobal = LoadResource(hLib, hVersion);\r\n\t\tif (hGlobal != NULL)\r\n\t\t{\r\n\r\n\t\t\tLPVOID versionInfo = LockResource(hGlobal);\r\n\t\t\tif (versionInfo != NULL)\r\n\t\t\t{\r\n\r\n\t\t\t\tchar    *pchVI = (char*)versionInfo;\r\n\t\t\t\tint dwSize = SizeofResource(hLib, hVersion);\r\n\t\t\t\tif (IsBadReadPtr(versionInfo, dwSize))\r\n\t\t\t\t\tdwSize -= 4;\r\n\t\t\t\tchar    *pchVIcopy = new char[dwSize * 2 + 4];\r\n\r\n\t\t\t\tmemcpy(pchVIcopy, pchVI, (int)(dwSize * 2 + 4));\r\n\r\n\t\t\t\tDWORD vLen, langD;\r\n\t\t\t\tBOOL retVal;\r\n\r\n\t\t\t\tLPVOID retbuf = NULL;\r\n\r\n\t\t\t\tstatic TCHAR fileEntry[256];\r\n\r\n\t\t\t\twsprintf(fileEntry, TEXT(\"\\\\VarFileInfo\\\\Translation\"));\r\n\t\t\t\tretVal = VerQueryValue(pchVIcopy, fileEntry, &retbuf, (UINT *)&vLen);\r\n\t\t\t\tif (retVal && vLen == 4)\r\n\t\t\t\t{\r\n\t\t\t\t\tmemcpy(&langD, retbuf, 4);\r\n\t\t\t\t\twsprintf(fileEntry, TEXT(\"\\\\StringFileInfo\\\\%02X%02X%02X%02X\\\\%s\"),\r\n\t\t\t\t\t\t(langD & 0xff00) >> 8, langD & 0xff, (langD & 0xff000000) >> 24,\r\n\t\t\t\t\t\t(langD & 0xff0000) >> 16, csEntry);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\twsprintf(fileEntry, TEXT(\"\\\\StringFileInfo\\\\%04X04B0\\\\%s\"), GetUserDefaultLangID(), csEntry);\r\n\r\n\t\t\t\tif (VerQueryValue(pchVIcopy, fileEntry, &retbuf, (UINT *)&vLen))\r\n\t\t\t\t\tcsRet = (TCHAR*)retbuf;\r\n\t\t\t\tdelete pchVIcopy;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tUnlockResource(hGlobal);\r\n\t\tFreeResource(hGlobal);\r\n\t}\r\n\r\n\treturn csRet;\r\n}\r\n\r\n/***********************************************************************************/\r\n/*                                                                                 */\r\n/* Class:   CGlobalFunctions                                                       */\r\n/* Method:  FormatVersion                                                          */\r\n/*                                                                                 */\r\n/* Parameters:                                                                     */\r\n/* -----------                                                                     */\r\n/*   CString cs                                                                    */\r\n/*                Specifies a version number such as \"FileVersion\" or              */\r\n/*                \"ProductVersion\" in the format \"m, n, o, p\"                      */\r\n/*                (e.g. \"1, 2, 3, a\")                                              */\r\n/*                                                                                 */\r\n/* Return Values:                                                                  */\r\n/* --------------                                                                  */\r\n/* If the function succeeds, the return value is a string containing the version   */\r\n/* in the format \"m.nop\" (e.g. \"1.23a\")                                            */\r\n/*                                                                                 */\r\n/* If the function fails, the returned string is empty.                            */\r\n/*                                                                                 */\r\n/***********************************************************************************/\r\nwstring CVersionHelper::FormatVersion(wstring cs)\r\n{\r\n\twstring csRet;\r\n\tif (!cs.length())\r\n\t{\r\n\t\trtrim(cs);\r\n\t\tint iPos = cs.find(',');\r\n\t\tif (iPos == -1)\r\n\t\t\treturn TEXT(\"\");\r\n\t\tltrim(cs);\r\n\t\trtrim(cs);\r\n\t\tcsRet.Format(TEXT(\"%s.\"), cs.copy(iPos));\r\n\r\n\t\twhile (1)\r\n\t\t{\r\n\t\t\tcs = cs.Mid(iPos + 1);\r\n\t\t\tltrim(cs);\r\n\t\t\tiPos = cs.find(',');\r\n\t\t\tif (iPos == -1)\r\n\t\t\t{\r\n\t\t\t\tcsRet += cs;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcsRet += cs.Left(iPos);\r\n\t\t}\r\n\t}\r\n\r\n\treturn csRet;\r\n}\r\n\r\n/***********************************************************************************/\r\n/*                                                                                 */\r\n/* Class:   CGlobalFunctions                                                       */\r\n/* Method:  GetFileVersionX                                                        */\r\n/*                                                                                 */\r\n/* Parameters:                                                                     */\r\n/* -----------                                                                     */\r\n/*                                                                                 */\r\n/* Return Values:                                                                  */\r\n/* --------------                                                                  */\r\n/* If the function succeeds, the return value is a wstring containing the           */\r\n/* \"FileVersion\" in the format \"m.nop\" (e.g. \"1.23a\")                              */\r\n/*                                                                                 */\r\n/* If the function fails, the returned wstring is empty.                            */\r\n/*                                                                                 */\r\n/***********************************************************************************/\r\nwstring CVersionHelper::GetFileVersionX()\r\n{\r\n\tif (!m_csFileVersion.length())\r\n\t{\r\n\t\twstring csVersion = FormatVersion(GetVersionInfo(NULL, TEXT(\"FileVersion\")));\r\n\t\tm_csFileVersion.Format(TEXT(\"Version %s (Build %s)\"), csVersion, GetVersionInfo(NULL, TEXT(\"SpecialBuild\")));\r\n\t}\r\n\r\n\treturn m_csFileVersion;\r\n}\r\n\r\n/***********************************************************************************/\r\n/*                                                                                 */\r\n/* Class:   CGlobalFunctions                                                       */\r\n/* Method:  GetFileVersionX                                                        */\r\n/*                                                                                 */\r\n/* Parameters:                                                                     */\r\n/* -----------                                                                     */\r\n/*                                                                                 */\r\n/* Return Values:                                                                  */\r\n/* --------------                                                                  */\r\n/* If the function succeeds, the return value is a string containing the           */\r\n/* \"ProductVersion\" in the format \"m.nop\" (e.g. \"1.23a\")                           */\r\n/*                                                                                 */\r\n/* If the function fails, the returned string is empty.                            */\r\n/*                                                                                 */\r\n/***********************************************************************************/\r\nwstring CVersionHelper::GetProductVersionX()\r\n{\r\n\tif (!m_csProductVersion.length())\r\n\t\tm_csProductVersion = FormatVersion(GetVersionInfo(NULL, TEXT(\"ProductVersion\")));\r\n\r\n\treturn m_csProductVersion;\r\n}"
        },
        {
          "name": "VersionHelper.h",
          "type": "blob",
          "size": 0.8876953125,
          "content": "#pragma once\r\n#include <xstring>\r\n#include <windows.h>\r\n#include <algorithm>\r\n#include <cctype>\r\nusing namespace std;\r\n\r\nclass CVersionHelper\r\n{\r\npublic:\r\n\tCVersionHelper();\r\n\tvirtual ~CVersionHelper();\r\n\r\npublic:\r\n\twstring GetFileVersionX();\r\n\twstring GetProductVersionX();\r\n\twstring GetVersionInfo(HMODULE hLib, wstring csEntry);\r\n\twstring FormatVersion(wstring cs);\r\n\r\nprivate:\r\n\twstring m_csFileVersion;\r\n\twstring m_csProductVersion;\r\n\r\n};\r\n\r\n\r\n// cited: https://stackoverflow.com/questions/216823/whats-the-best-way-to-trim-stdstring\r\n// trim from start (in place)\r\nstatic inline void ltrim(std::wstring &s) {\r\n\ts.erase(s.begin(), std::find_if(s.begin(), s.end(), [](int ch) {\r\n\t\treturn !std::isspace(ch);\r\n\t}));\r\n}\r\n\r\n// trim from end (in place)\r\nstatic inline void rtrim(std::wstring &s) {\r\n\ts.erase(std::find_if(s.rbegin(), s.rend(), [](int ch) {\r\n\t\treturn !std::isspace(ch);\r\n\t}).base(), s.end());\r\n}"
        },
        {
          "name": "array.h",
          "type": "blob",
          "size": 1.0029296875,
          "content": "#pragma once\n\n#ifndef _INC_SHLWAPI\n#define NO_SHLWAPI_STRFCNS\n#define NO_SHLWAPI_PATH\n#define NO_SHLWAPI_REG\n#define NO_SHLWAPI_STREAM\n#define NO_SHLWAPI_GDI\n#include <shlwapi.h>\n#endif\n\n#if !defined(_INC_SHLWAPI) || defined(NOSHLWAPI) || defined(NO_SHLWAPI_PATH)\nBOOL WINAPI PathIsRelative(LPCTSTR pszPath);\nBOOL WINAPI PathRemoveFileSpec(LPTSTR pszPath);\nLPTSTR WINAPI PathFindExtension(LPCTSTR pszPath);\nLPTSTR WINAPI PathAddBackslash(LPTSTR pszPath);\nLPTSTR WINAPI PathCombine(LPTSTR pszDest, LPCTSTR pszDir, LPCTSTR pszFile);\n#endif\n\n#include <atlbase.h>\n\ntemplate <class T>\nclass CArray : public CSimpleArray<T>\n{\npublic:\n\tT* Begin() const\n\t{\n\t\treturn m_aT;\n\t}\n\tT* End() const\n\t{\n\t\treturn m_aT + m_nSize;\n\t}\n};\n\ntemplate <class T>\nclass CValArray : public CSimpleValArray<T>\n{\npublic:\n\tT* Begin() const\n\t{\n\t\treturn m_aT;\n\t}\n\tT* End() const\n\t{\n\t\treturn m_aT + m_nSize;\n\t}\n};\n\ntemplate <class T>\nclass CPtrArray : public CValArray<T*>\n{\n};\n\ntemplate <class TKey, class TVal>\nclass CMap : public CSimpleMap<TKey, TVal>\n{\n};\n"
        },
        {
          "name": "build.vc2005.bat",
          "type": "blob",
          "size": 0.197265625,
          "content": "@echo off\n\nsetlocal\n\nset INCLUDE=..\\..\\..\\freetype2\\include;%INCLUDE%\nset LIB=..\\..;%LIB%\n\n:go\nnmake -f Makefile.vc2005 %*\nif errorlevel 1 goto err\ngoto end\n\n:err\npause\ngoto go\n\n:end\nendlocal\nrem pause\n"
        },
        {
          "name": "cache.cpp",
          "type": "blob",
          "size": 3.619140625,
          "content": "#include \"override.h\"\n\n//CreateDIB计数，将在绘制下列次数后更新DIB区\n#define BITMAP_REDUCE_COUNTER\t256//默认1024\n\n\nHDC CBitmapCache::CreateDC(HDC dc)\n{\n\tif(!m_hdc) {\n\t\tm_hdc = CreateCompatibleDC(dc);\n\t\tm_exthdc = dc;\n\t}\n\treturn m_hdc;\n}\n\nHBITMAP CBitmapCache::CreateDIB(int width, int height, BYTE** lplpPixels)\n{\n\tSIZE& dibSize = m_dibSize;\n\twidth  = (width + 3) & ~3;\n\n\tif (dibSize.cx >= width && dibSize.cy >= height) {\n\t\tif (++m_counter < BITMAP_REDUCE_COUNTER) {\n\t\t\t*lplpPixels = m_lpPixels;\n\t\t\treturn m_hbmp;\n\t\t}\n\t\t//カウンタ超過\n\t\t//ただしサイズが全く同じなら再生成しない\n\t\tif (dibSize.cx == width && dibSize.cy == height) {\n\t\t\tm_counter   = 0;\n\t\t\t*lplpPixels = m_lpPixels;\n\t\t\treturn m_hbmp;\n\t\t}\n\t} else {\n\t\tif (dibSize.cx > width) {\n\t\t\twidth  = dibSize.cx;\n\t\t}\n\t\tif (dibSize.cy > height) {\n\t\t\theight = dibSize.cy;\n\t\t}\n\t}\n\n\tBITMAPINFOHEADER bmiHeader = { sizeof(BITMAPINFOHEADER), width, -height, 1, 32, BI_RGB };\n\tHBITMAP hbmpNew = CreateDIBSection(CreateDC(m_exthdc), (BITMAPINFO*)&bmiHeader, DIB_RGB_COLORS, (LPVOID*)lplpPixels, NULL, 0);\n\tif (!hbmpNew) {\n\t\treturn NULL;\n\t}\n\tTRACE(_T(\"width=%d, height=%d\\n\"), width, height);\n\n\t//メモリ不足等でhbmpNew==NULLの場合を想定し、\n\t//成功したときのみキャッシュを更新\n\tif (m_hbmp) {\n\t\tDeleteBitmap(m_hbmp);\n\t}\n\n\tm_hbmp\t\t= hbmpNew;\n\tdibSize.cx\t= width;\n\tdibSize.cy\t= height;\n\t//CreateDIBSectionは多分ページ境界かセグメント境界\n\tm_lpPixels\t= *lplpPixels;\n\tm_counter\t= 0;\n\treturn m_hbmp;\n}\n\nvoid CBitmapCache::FillSolidRect(COLORREF rgb, const RECT* lprc)\n{\n\n\tif (!m_brush || rgb!=m_bkColor)\n\t{\n\t\tif (m_brush)\n\t\t\tDeleteObject(m_brush);\n\t\tm_brush = CreateSolidBrush(rgb);\n\t\tm_bkColor = rgb;\n\t}\n\tFillRect(m_hdc, lprc, m_brush);\n\n\n\t//DrawHorizontalLine(lprc->left, lprc->top, lprc->right, rgb, lprc->bottom - lprc->top);\n/*\tLPBYTE lpPixels = m_lpPixels;\n\tconst DWORD dwBmpBytes\t\t= m_dibSize.cx * m_dibSize.cy;\n\trgb = RGB2DIB(rgb);\n\n\t//TODO: MMX or SSE化\n\t__asm {\n\t\tmov edi, dword ptr [lpPixels]\n\t\tmov ecx, dword ptr [dwBmpBytes]\n\t\tmov eax, dword ptr [rgb]\n\t\tcld\n\t\trep stosd\n\t}*/\n//\tDWORD* p = (DWORD*)m_lpPixels;\n//\tDWORD* const pend = p + dwBmpBytes;\n//\twhile (p < pend) {\n//\t\t*p++ = rgb;\n//\t}\n}\n\n//水平線を引く\n//(X1,Y1)           (X2,Y1)\n//   +-----------------+   ^\n//   |       rgb       |   | width\n//   +-----------------+   v\nvoid CBitmapCache::DrawHorizontalLine(int X1, int Y1, int X2, COLORREF rgb, int width)\n{\n\tif (!m_dibSize.cx || !m_dibSize.cy) {\n\t\treturn;\n\t}\n\n\tif (X1 > X2) {\n\t\tconst int xx = X1;\n\t\tX1 = X2;\n\t\tX2 = xx;\n\t}\n\n\t//クリッピング\n\tconst int xSize = m_dibSize.cx;\n\tconst int ySize = m_dibSize.cy;\n\tX1 = Bound(X1, 0, xSize);\n\tX2 = Bound(X2, 0, xSize);\n\tY1 = Bound(Y1, 0, ySize);\n\twidth = Max(width, 1);\n\tconst int Y2 = Bound(Y1 + width, 0, ySize);\n\n\trgb = RGB2DIB(rgb);\n\n\tDWORD* lpPixels = (DWORD*)m_lpPixels + (Y1 * xSize + X1);\n\tconst int Xd = X2 - X1;\n\tconst int Yd = Y2 - Y1;\n/*\tfor (int yy=Y1; yy<Y2; yy++) {\n\t\tfor (int xx=X1; xx<X2; xx++) {\n\t\t\t_SetPixelV(xx, yy, rgb);\n\t\t}\n\t}\n\n\tfor (int yy=Y1; yy<Y2; yy++, lpPixels += xSize) {\n\t\t__asm {\n\t\t\tmov edi, dword ptr [lpPixels]\n\t\t\tmov ecx, dword ptr [Xd]\n\t\t\tmov eax, dword ptr [rgb]\n\t\t\tcld\n\t\t\trep stosd\n\t\t}\n\t}*/\n\n/*#ifdef _M_IX86\n\t//無意味にアセンブリ化\n\t__asm {\n\t\tmov ebx, dword ptr [Yd]\n\t\tmov edx, dword ptr [lpPixels]\n\t\tmov esi, dword ptr [xSize]\n\t\tcld\nL1:\n\t\tmov edi, edx\n\t\tmov ecx, dword ptr [Xd]\n\t\tmov eax, dword ptr [rgb]\n\t\trep stosd\n\t\tlea edx, dword ptr [edx+esi*4]\n\t\tdec ebx\n\t\tjnz L1\n\t}\n#else*/\t//对于64位系统，使用C语言\n\tfor (int yy=Y1; yy<Y2; yy++) {\n\t\tfor (int xx=X1; xx<X2; xx++) {\n\t\t\t*( (DWORD*)m_lpPixels + (yy * xSize + xx) ) = rgb;\n\t\t}\n\t}\n//#endif\n\n}\n"
        },
        {
          "name": "cache.h",
          "type": "blob",
          "size": 2.8935546875,
          "content": "#pragma once\n\ntemplate <int BUFSIZE, bool ignoreCase>\nclass StringHashT\n{\nprivate:\n\tDWORD\tm_dwHash;\n\tTCHAR\tm_szBuffer[BUFSIZE];\n\n\tvoid UpdateHash()\n\t{\n\t\tDWORD dw = 0;\n\t\tLPWSTR p, end = m_szBuffer + BUFSIZE;\n\t\tfor (p = m_szBuffer; *p && p < end; p++) {\n\t\t\tdw <<= 3;\n\t\t\tif (ignoreCase) {\n\t\t\t\tdw ^= _totlower(*p);\n\t\t\t} else {\n\t\t\t\tdw ^= *p;\n\t\t\t}\n\t\t}\n\t\tm_dwHash = dw;\n\t}\n\npublic:\n\tStringHashT()\n\t\t: m_dwHash(0)\n\t{\n\t\tZeroMemory(m_szBuffer, sizeof(m_szBuffer));\n\t}\n\tStringHashT(LPCTSTR psz)\n\t{\n\t\tthis->StringHashT::StringHashT();\n\t\t_tcsncpy(m_szBuffer, psz, BUFSIZE - 1);\n\t\tUpdateHash();\n\t}\n\n\tbool operator ==(const StringHashT<BUFSIZE, ignoreCase>& x) const\n\t{\n\t\tif (ignoreCase) {\n\t\t\treturn !(m_dwHash != x.m_dwHash || _tcsicmp(m_szBuffer, x.m_szBuffer));\n\t\t} else {\n\t\t\treturn !(m_dwHash != x.m_dwHash || _tcscmp(m_szBuffer, x.m_szBuffer));\n\t\t}\n\t}\n\n\tDWORD Hash() const\n\t{\n\t\treturn m_dwHash;\n\t}\n\tLPCTSTR c_str() const\n\t{\n\t\treturn m_szBuffer;\n\t}\n};\n\ntypedef StringHashT<LF_FACESIZE,true>\tStringHashFont;\ntypedef StringHashT<MAX_PATH,true>\t\tStringHashModule;\n\n\n//COLORREF(RR GG BB 00) を DIB32(BB GG RR 00) に変換\n#define RGB2DIB(rgb)\tRGB(GetBValue(rgb), GetGValue(rgb), GetRValue(rgb))\n#define DIB2RGB(dib)\tRGB2DIB(dib)\n\n// ExtTextOutWのビットマップキャッシュ\nclass CBitmapCache\n{\nprivate:\n\tHBRUSH\tm_brush;\n\tHDC\t\tm_hdc;\n\tHDC\t\tm_exthdc;\n\tHBITMAP\tm_hbmp;\n\tBYTE*\tm_lpPixels;\n\tSIZE\tm_dibSize;\n\tint\t\tm_counter;\n\tDWORD*\tm_CurrentPixel;\n\tCOLORREF m_bkColor;\n\n\tNOCOPY(CBitmapCache);\n\npublic:\n\tCBitmapCache()\n\t\t: m_hdc(NULL)\n\t\t, m_hbmp(NULL)\n\t\t, m_lpPixels(NULL)\n\t\t, m_counter(0)\n\t\t, m_CurrentPixel(NULL)\n\t\t, m_exthdc(NULL)\n\t\t, m_brush(NULL)\n\t\t, m_bkColor(NULL)\n\t{\n\t\tm_dibSize.cx = m_dibSize.cy = 0;\n\t}\n\n\t~CBitmapCache()\n\t{\n\t\tif (m_hdc) {\n\t\t\tDeleteDC(m_hdc);\n\t\t}\n\t\tif (m_hbmp)\t{\n\t\t\tDeleteBitmap(m_hbmp);\n\t\t}\n\t\tif (m_brush) \n\t\t\tDeleteObject(m_brush);\n\t\tm_hdc = NULL;\n\t\tm_hbmp = NULL;\n\t\tm_brush = NULL;\n\t\tm_dibSize.cx = 0;\n\t\tm_dibSize.cy = 0;\n\t}\n\n\tconst SIZE& Size() const\n\t{\n\t\treturn m_dibSize;\n\t}\n\tBYTE* GetPixels()\n\t{\n\t\tAssert(m_lpPixels != NULL);\n\t\treturn m_lpPixels;\n\t}\n\n\tDWORD GetPixel(int X, int Y) {\n\t\tif ((unsigned)X >= (unsigned)m_dibSize.cx || (unsigned)Y >= (unsigned)m_dibSize.cy) {\n\t\t\treturn CLR_INVALID;\n\t\t}\n\t\tDWORD* lpPixels = (DWORD*)m_lpPixels;\n\t\tm_CurrentPixel = &lpPixels[Y * m_dibSize.cx + X];\n\t\tDWORD dib = *m_CurrentPixel;\n\t\treturn DIB2RGB(dib);\n\t}\n\n\tvoid SetPixelV(int X, int Y, COLORREF rgb) {\n\t\t// if ((unsigned)X >= (unsigned)m_dibSize.cx || (unsigned)Y >= (unsigned)m_dibSize.cy) {\n\t\t// \treturn;\n\t\t// }\n\t\tDWORD* lpPixels = (DWORD*)m_lpPixels;\n\t\tm_CurrentPixel = &lpPixels[Y * m_dibSize.cx + X];\n\t\tSetCurrentPixel(rgb);\n\t}\n\n\tvoid SetCurrentPixel(COLORREF rgb) {\n\t\t*m_CurrentPixel = RGB2DIB(rgb);\n\t}\n\n\t//本体はcache.cpp\n\tHDC CreateDC(HDC dc);\n\tHBITMAP CreateDIB(int width, int height, BYTE** lplpPixels);\n\tvoid FillSolidRect(COLORREF rgb, const RECT* lprc);\n\tvoid DrawHorizontalLine(int X1, int Y1, int X2, COLORREF rgb, int width);\n\n};\n"
        },
        {
          "name": "colorinvert.h",
          "type": "blob",
          "size": 1.0146484375,
          "content": "#pragma once\r\n//formula: (x+482)^2+(y+481)^2=880^2\r\nunsigned char InvertTable[260] = { 255,255,254,253,253,252,251,251,250,249,249,248,247,247,246,245,245,244,243,242,242,241,240,240,239,238,238,237,236,235,235,234,233,233,232,231,230,230,229,228,227,227,226,225,224,224,223,222,221,221,220,219,218,218,217,216,215,215,214,213,212,211,211,210,209,208,208,207,206,205,204,204,203,202,201,200,199,199,198,197,196,195,195,194,193,192,191,190,189,189,188,187,186,185,184,183,183,182,181,180,179,178,177,176,176,175,174,173,172,171,170,169,168,167,166,166,165,164,163,162,161,160,159,158,157,156,155,154,153,152,151,150,149,148,147,146,145,144,143,143,142,141,140,138,137,136,135,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,115,114,113,112,111,110,109,108,107,106,104,103,102,101,100,99,98,96,95,94,93,92,91,90,88,87,86,85,84,82,81,80,79,78,76,75,74,73,71,70,69,68,66,65,64,63,61,60,59,58,56,55,54,52,51,50,48,47,46,44,43,42,40,39,38,36,35,33,32,31,29,28,26,25,24,22,21,19,18,16,15,13,12,10,9,7,6,4,3,1,0,0,0,0,0};\r\n"
        },
        {
          "name": "common.h",
          "type": "blob",
          "size": 14.1552734375,
          "content": "#pragma once\n\n#define _CRT_SECURE_NO_DEPRECATE 1\n#ifdef _WIN64\n#define _WIN32_WINNT _WIN32_WINNT_WIN10\n#define WINVER _WIN32_WINNT_VISTA\n#else\n#define _WIN32_WINNT _WIN32_WINNT_WIN10\n#define WINVER _WIN32_WINNT_WIN10\n#endif\n#define NTDDI_VERSION NTDDI_WIN10_RS3\n#define WIN32_LEAN_AND_MEAN 1\n#define UNICODE  1\n#define _UNICODE 1\n\n#define NOMINMAX\n#include <Windows.h>\n#include <usp10.h>\n//#include <limits>\n#include <functional>\n//#include <iterator>\n#include <algorithm>\n#include <memory>\n#include \"array.h\"\n#include <set>\n#include \"ownedcs.h\"\n#include \"undocAPI.h\"\n#include <d2d1.h>\n#include <d2d1_1.h>\n#include <d2d1_3.h>\n#include <dwrite.h>\n#include <dwrite_1.h>\n#include <dwrite_2.h>\n#include <dwrite_3.h>\n#include <string>\n#include <locale>\n#include <codecvt>\n//#include <wincodec.h>\n//#include <wincodecsdk.h>\n\n#define for if(0);else for\n\n#include <tchar.h>\n#include <stddef.h>\n#define STRSAFE_NO_DEPRECATE\n#include <strsafe.h>\n\n#define _CRTDBG_MAP_ALLOC\n#include <cstdlib>\n#include <malloc.h>\n#include <crtdbg.h>\n\n#include <map>\n#include <string>\nusing namespace std;\n#ifdef _M_IX86\n//#include \"optimize/optimize.h\"\n#endif\n\n#define FONT_MAGIC_NUMBER 0xA8\n\n#define ASSERT\t\t\t_ASSERTE\n#define Assert\t\t\t_ASSERTE\n#ifdef _DEBUG\n#define new\t\t\t\tnew(_NORMAL_BLOCK, __FILE__, __LINE__)\n#endif\n\n#ifndef NOP_FUNCTION\n#if (_MSC_VER >= 1210)\n#define NOP_FUNCTION\t__noop\n#else\n#define NOP_FUNCTION\t(void)0\n#endif\t//_MSC_VER\n#endif\t//!NOP_FUNCTION\n#ifndef C_ASSERT\n#define C_ASSERT(e)\t\ttypedef char __C_ASSERT__[(e)?1:-1]\n#endif\t//!C_ASSERT\n#ifndef FORCEINLINE\n#if (_MSC_VER >= 1200)\n#define FORCEINLINE\t\t__forceinline\n#else\n#define FORCEINLINE\t\t__inline\n#endif\t//_MSC_VER\n#endif\t//!FORCEINLINE\n\n\nvoid Log(char* Msg);\nvoid Log(wchar_t* Msg);\n\n\n// convert string to wstring\ninline std::wstring to_wide_string(const std::string & input)\n{\n\tstd::wstring_convert<std::codecvt_utf8<wchar_t>> converter;\n\treturn converter.from_bytes(input);\n}\n// convert wstring to string \ninline std::string to_byte_string(const std::wstring & input)\n{\n\t//std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;\n\tstd::wstring_convert<std::codecvt_utf8<wchar_t>> converter;\n\treturn converter.to_bytes(input);\n}\n\n\nFORCEINLINE HINSTANCE GetDLLInstance()\n{\n\textern HINSTANCE g_hinstDLL;\n\treturn g_hinstDLL;\n}\n\n//排他制御\nclass CCriticalSectionLock\n{\n#define MAX_CRITICAL_COUNT 20\nprivate:\n\tstatic CRITICAL_SECTION m_cs[MAX_CRITICAL_COUNT];\n\tfriend class CCriticalSectionLockTry;\n\tint m_index;\npublic:\n\tenum {\n\t\tCS_LIBRARY,\n\t\tCS_CACHEDFONT,\n\t\tCS_FONTENG,\n\t\t//CS_CMAPCACHE,\n\t\t//CS_IMAGECACHE,\n\t\tCS_SETTING,\n\t\tCS_MAIN,\n\t\tCS_FONTCACHE,\n\t\tCS_MANAGER,\n\t\tCS_CREATEFONT,\n\t\tCS_FONTLINK,\n\t\tCS_FONTMAP,\n\t\tCS_OWNEDCS,\n\t\tCS_VIRTMEM,\n\t\tCS_DWRITE,\n\t};\n\tCCriticalSectionLock(int index=CS_LIBRARY):\n\t  m_index(index)\n\t{\n\t\t::EnterCriticalSection(&m_cs[index]);\n\t}\n\t~CCriticalSectionLock()\n\t{\n\t\t::LeaveCriticalSection(&m_cs[m_index]);\n\t}\n\tstatic void Init()\n\t{\n\t\tfor (int i=0;i<MAX_CRITICAL_COUNT;i++)\n\t\t\t::InitializeCriticalSection(&m_cs[i]);\n\t}\n\tstatic void Term()\n\t{\n\t\tfor (int i=0;i<MAX_CRITICAL_COUNT;i++)\n\t\t\t::DeleteCriticalSection(&m_cs[i]);\n\t}\n};\n\n#ifdef _DEBUG\n#define TRACE\t_Trace\n#include <stdarg.h>\t//va_list\n#include <stdio.h>\t//_vsnwprintf\n\nstatic void _Trace(LPCTSTR pszFormat, ...)\n{\n\tCCriticalSectionLock __lock;\n\tva_list argptr;\n\tva_start(argptr, pszFormat);\n\t//w(v)sprintfは1024文字以上返してこない\n\tTCHAR szBuffer[10240];\n\twvsprintf(szBuffer, pszFormat, argptr);\n\n\t//デバッガをアタッチしてる時はデバッガにメッセージを出す\n\t//if (IsDebuggerPresent()) {\n\tOutputDebugString(szBuffer);\n\treturn;\n\t//}\n\n\textern HANDLE g_hfDbgText;\n\tHANDLE hf = g_hfDbgText;\n\tif (!hf) {\n\t\tTCHAR szFileName[MAX_PATH+16];\n\t\tGetModuleFileName(GetDLLInstance(), szFileName, MAX_PATH);\n\t\tTCHAR *p1 = _tcsrchr(szFileName, _T('\\\\'));\n\t\tif (p1 && p1 > szFileName) {\n\t\t\t*p1 = 0;\n\t\t\tTCHAR *p2 = _tcsrchr(szFileName, _T('\\\\'));\n\t\t\tif (p2)\n\t\t\t\tmemmove(p2 + 1, p1 + 1, (_tcslen(p1) + 1) * sizeof(TCHAR));\n\t\t}\n\t\t_tcscpy(szFileName + _tcslen(szFileName) - 4, L\"_dbg.txt\");\n\t\tg_hfDbgText = hf = CreateFile(szFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);\n\t\tif(hf != INVALID_HANDLE_VALUE) {\n\t\t\tSetFilePointer(hf, 0, NULL, FILE_BEGIN);\n#ifdef _UNICODE\n\t\t\tWORD w = 0xfeff;\n\t\t\tDWORD cb;\n\t\t\tWriteFile(hf, &w, sizeof(WORD), &cb, NULL);\n#endif\n\t\t}\n\t}\n\tif(hf != INVALID_HANDLE_VALUE) {\n\t\tDWORD cb;\n\t\tWriteFile(hf, szBuffer, _tcslen(szBuffer) * sizeof(TCHAR), &cb, NULL);\n\t}\n}\n#else\t//!_DEBUG\n#define TRACE\tNOP_FUNCTION\n//↓PSDK 2003R2のwinnt.h\n//#ifndef NOP_FUNCTION\n//#if (_MSC_VER >= 1210)\n//#define NOP_FUNCTION __noop\n//#else\n//#define NOP_FUNCTION (void)0\n//#endif\n//#endif\n#endif\t//_DEBUG\n\n//TRACEマクロ\n//使用例: TRACE(_T(\"cx: %d\\n\"), cx);\n#ifdef USE_TRACE\n#define TRACE2\t_Trace2\n#define TRACE2_STR\t_Trace2_Str\n#define TRACE2_BIN\t_Trace2_Bin\n#include <stdarg.h>\t//va_list\n#include <stdio.h>\t//_vsnwprintf\n\nstatic void _Trace2(LPCTSTR pszFormat, ...)\n{\n\tCCriticalSectionLock __lock;\n\tva_list argptr;\n\tva_start(argptr, pszFormat);\n\t//w(v)sprintfは1024文字以上返してこない\n\tTCHAR szBuffer[1024];\n\twvsprintf(szBuffer, pszFormat, argptr);\n\tOutputDebugString(szBuffer);\n}\n\nstatic void _Trace2_Bin(LPWSTR func, int line, LPVOID lpString, UINT cbString)\n{\n\tconst PBYTE srcp = (const PBYTE)lpString;\n\tWCHAR buf[0x1000];\n\tLPWSTR p = buf;\n\tfor (UINT i = 0; i < 32 && i < cbString; ++i) {\n\t\twsprintf(p, L\"%02x \", srcp[i]);\n\t\tp += lstrlen(p);\n\t}\n\t*p = 0;\n\tTRACE(_T(\"%s %d: %d %08x %s\\n\"), func, line, cbString, lpString, buf);\n}\n\nstatic void _Trace2_Str(LPWSTR func, int line, LPCWSTR lpString, UINT cbString)\n{\n\tWCHAR buf[0x1000];\n\tUINT len = Min(cbString, countof(buf) - 1);\n\tlstrcpyn(buf, lpString, len + 1);\n\tbuf[countof(buf) - 1] = 0;\n\tTRACE(_T(\"%s %d: %d %s\\n\"), func, line, cbString, buf);\n\tLPWSTR p = buf;\n\tfor (UINT i = 0; i < 32 && i < cbString; ++i) {\n\t\twsprintf(p, L\"%04x \", lpString[i]);\n\t\tp += lstrlen(p);\n\t}\n\tTRACE(_T(\"%s %d: %d %08x %s\\n\"), func, line, cbString, lpString, buf);\n}\n\n#else\t//!USE_TRACE\n#define TRACE2\tNOP_FUNCTION\n#define TRACE2_STR\tNOP_FUNCTION\n#define TRACE2_BIN\tNOP_FUNCTION\n#endif\t//USE_TRACE\n\n\nclass COwnedCriticalSectionLock\n{\nprivate:\n\tstatic OWNED_CRITIAL_SECTION m_cs[2];\n\tWORD FOwner;\n\tint m_index;\npublic:\n\tenum {\n\t\tOCS_FREETYPE,\n\t\tOCS_DC\n\t};\n\tCOwnedCriticalSectionLock():FOwner(0), m_index(OCS_FREETYPE)\n\t{\n\t\tEnterOwnedCritialSection(&m_cs[m_index], FOwner);\n\t}\n\tCOwnedCriticalSectionLock(WORD Owner, int index=OCS_FREETYPE):FOwner(Owner), m_index(index)\n\t{\n\t\tEnterOwnedCritialSection(&m_cs[m_index], Owner);\n\t}\n\t~COwnedCriticalSectionLock()\n\t{\n\t\tLeaveOwnedCritialSection(&m_cs[m_index], FOwner);\n\t}\n\tstatic void Init()\n\t{\n\t\tfor (int i=0;i<2;i++)\n\t\t{\n\t\t\tInitializeOwnedCritialSection(&m_cs[i]);\n\t\t}\n\t}\n\tstatic void Term()\n\t{\n\t\tfor (int i=0;i<2;i++)\n\t\t{\n\t\t\tDeleteOwnedCritialSection(&m_cs[i]);\n\t\t}\n\t}\n};\n\nclass CThreadCounter\n{\nprivate:\n\tstatic LONG interlock;\npublic:\n\tCThreadCounter()\n\t{\n\t\tInterlockedIncrement(&interlock);\n\t}\n\t~CThreadCounter()\n\t{\n\t\tInterlockedDecrement(&interlock);\n\t}\n\tstatic void Init()\n\t{\n\t\tinterlock = 0;\n\t}\n\tstatic int Count()\n\t{\n\t\treturn InterlockedExchange(&interlock, interlock);\n\t}\n};\n\nclass CCriticalSectionLockTry\n{\npublic:\n\tBOOL TryEnter(int index=CCriticalSectionLock::CS_LIBRARY)\n\t{\n\t\treturn ::TryEnterCriticalSection(&CCriticalSectionLock::m_cs[index]);\n\t}\n\tint CritalCount(int index=CCriticalSectionLock::CS_LIBRARY)\n\t{\n\t\treturn CCriticalSectionLock::m_cs[index].RecursionCount;\n\t}\n\tvoid Leave(int index=CCriticalSectionLock::CS_LIBRARY)\n\t{\n\t\t::LeaveCriticalSection(&CCriticalSectionLock::m_cs[index]);\n\t}\n};\n\n// 使用後はfreeで開放する事\nLPWSTR _StrDupExAtoW(LPCSTR pszMB, int cchMB, LPWSTR pszStack, int cchStack, int* pcchWC, int nACP = CP_ACP);\nstatic inline LPWSTR _StrDupAtoW(LPCSTR pszMB, int cchMB = -1, int* pcchWC = NULL)\n{\n\treturn _StrDupExAtoW(pszMB, cchMB, NULL, 0, pcchWC);\n}\n\n// useful macros\n#define NOCOPY(T)\t\t\t\t\tT(const T&); T& operator=(const T&)\n#define countof(array)\t\t\t\t(sizeof(array)/sizeof(array[0]))\n#define sizeof_struct(s, m)\t\t\t(((int)((char*)(&((s*)0)->m) - ((char*)((s*)0)))) + sizeof(((s*)0)->m))\n#ifndef offsetof\n#define offsetof(s,m)\t\t\t\t(size_t)&(((s*)0)->m)\n#endif\n#ifdef _DEBUG\n#define Verify(expr)\t\t\t\t_ASSERTE(expr)\n#else\n#define Verify(expr)\t\t\t\t(expr)\n#endif\n\ntemplate<typename T> FORCEINLINE T Min(T x, T y) { return (x < y) ? x : y; }\ntemplate<typename T> FORCEINLINE T Max(T x, T y) { return (y < x) ? x : y; }\ntemplate<typename T> FORCEINLINE T Bound(T x, T m, T M) { return (x < m) ? m : ((x > M) ? M : x); }\ntemplate<typename T> FORCEINLINE int Sgn(T x, T y) { return (x > y) ? 1 : ((x < y) ? -1 : 0); }\n\n\n//型チェック機能つきDeleteXXX/SelectXXX\n//SelectObject/DeleteObjectは使用できなくなる\n\n#ifdef _DEBUG\n#undef DeletePen\n#undef DeleteBrush\n#undef DeleteRgn\n#undef DeleteFont\n#undef DeleteBitmap\n#undef SelectPen\n#undef SelectBrush\n#undef SelectRgn\n#undef SelectFont\n#undef SelectBitmap\n\n#define _IsValidPen(hPen)\t\t\\\n\t(hPen == NULL || ::GetObjectType(hPen) == OBJ_PEN || ::GetObjectType(hPen) == OBJ_EXTPEN)\n#define _IsValidBrush(hBrush)\t\\\n\t(hBrush == NULL || ::GetObjectType(hBrush) == OBJ_BRUSH)\n#define _IsValidRgn(hRgn)\t\t\\\n\t(hRgn == NULL || ::GetObjectType(hRgn) == OBJ_REGION)\n#define _IsValidFont(hFont)\t\t\\\n\t(hFont == NULL || ::GetObjectType(hFont) == OBJ_FONT)\n#define _IsValidBitmap(hBitmap)\t\\\n\t(hBitmap == NULL || ::GetObjectType(hBitmap) == OBJ_BITMAP)\n\n#define DEFINE_DELETE_FUNCTION(type, name) \\\n\tFORCEINLINE BOOL WINAPI Delete##name(type h##name) \\\n\t{ \\\n\t\t_ASSERTE(_IsValid##name(h##name)); \\\n\t\treturn ::DeleteObject(h##name); \\\n\t}\n\n#define DEFINE_SELECT_FUNCTION(type, name) \\\n\tFORCEINLINE type WINAPI Select##name(HDC hDC, type h##name) \\\n\t{ \\\n\t\t_ASSERTE(hDC != NULL); \\\n\t\tif (!_IsValid##name(h##name)) { \\\n\t\tTRACE(_T(\"Select object %x for DC %x\"), (DWORD)h##name, (DWORD)hDC); \\\n\t\t\t}; \\\n\t\treturn (type)::SelectObject(hDC, h##name); \\\n\t}\n\nDEFINE_DELETE_FUNCTION(HPEN,\tPen)\nDEFINE_DELETE_FUNCTION(HBRUSH,\tBrush)\nDEFINE_DELETE_FUNCTION(HRGN,\tRgn)\nDEFINE_DELETE_FUNCTION(HFONT,\tFont)\nDEFINE_DELETE_FUNCTION(HBITMAP,\tBitmap)\n\nDEFINE_SELECT_FUNCTION(HPEN,\tPen)\nDEFINE_SELECT_FUNCTION(HBRUSH,\tBrush)\nDEFINE_SELECT_FUNCTION(HRGN,\tRgn)\nDEFINE_SELECT_FUNCTION(HFONT,\tFont)\nDEFINE_SELECT_FUNCTION(HBITMAP,\tBitmap)\n\n#undef _IsValidPen\n#undef _IsValidBrush\n#undef _IsValidRgn\n#undef _IsValidFont\n#undef _IsValidBitmap\n#undef DEFINE_DELETE_FUNCTION\n#undef DEFINE_SELECT_FUNCTION\n\n#if (_MSC_VER >= 1300)\n#pragma deprecated(DeleteObject)\n#pragma deprecated(SelectObject)\n#else\t//_MSC_VER < 1300\n#undef DeleteObject\n#define DeleteObject\t\tDeleteObject_instead_use_DeleteXXX\n#undef SelectObject\n#define SelectObject\t\tSelectObject_instead_use_DeleteXXX\n#endif\t//_MSC_VER\n\n#else\t//!_DEBUG\n#ifndef _INC_WINDOWSX\n#define DeletePen\t\t\t::DeleteObject\n#define DeleteBrush\t\t\t::DeleteObject\n#define DeleteRgn\t\t\t::DeleteObject\n#define DeleteFont\t\t\t::DeleteObject\n#define DeleteBitmap\t\t::DeleteObject\n\n#define SelectPen(d,o)\t\t(HPEN)::SelectObject(d,o)\n#define SelectBrush(d,o)\t(HBRUSH)::SelectObject(d,o)\n#define SelectRgn(d,o)\t\t(HRGN)::SelectObject(d,o)\n#define SelectFont(d,o)\t\t(HFONT)::SelectObject(d,o)\n#define SelectBitmap(d,o)\t(HBITMAP)::SelectObject(d,o)\n#endif\t//!_INC_WINDOWSX\n#endif\t//_DEBUG\n\n\n//TRACEマクロ\n//使用例: TRACE(_T(\"cx: %d\\n\"), cx);\n#ifndef _WIN64\n#ifdef _DEBUG\nFORCEINLINE static __int64 GetClockCount()\n{\n\tLARGE_INTEGER cycles;\n\t__asm {\n\t\trdtsc\n\t\tmov cycles.LowPart,  eax\n\t\tmov cycles.HighPart, edx\n\t}\n\treturn cycles.QuadPart;\n}\n\n//使用例\n//{\n//   CDebugElapsedCounter _cntr(\"hogehoge\");\n//     : (適当な処理)\n//}\n//出力例: \"hogehoge: 10000 clocks\"\nclass CDebugElapsedCounter\n{\nprivate:\n\t__int64 m_ilClk;\n\tLPCSTR m_pszName;\npublic:\n\tCDebugElapsedCounter(LPCSTR psz)\n\t\t: m_ilClk(GetClockCount())\n\t\t, m_pszName(psz)\n\t{\n\t}\n\t~CDebugElapsedCounter()\n\t{\n\t\tTRACE(_T(\"%hs: %u clocks\\n\"), m_pszName, (DWORD)(GetClockCount() - m_ilClk));\n\t}\n};\n#else\nclass CDebugElapsedCounter\n{\npublic:\n\tCDebugElapsedCounter(LPCSTR psz)\n\t{\n\t}\n};\n#endif\n#endif\n\n\n//String to int等系列函数的定义\n/*\nint _StrToInt(LPCTSTR pStr, int nDefault)\n{\n#define isspace(ch)\t\t(ch == _T('\\t') || ch == _T(' '))\n#define isdigit(ch)\t\t((_TUCHAR)(ch - _T('0')) <= 9)\n\n\tint ret;\n\tbool neg = false;\n\tLPCTSTR pStart;\n\n\tfor (; isspace(*pStr); pStr++);\n\tswitch (*pStr) {\n\tcase _T('-'):\n\t\tneg = true;\n\tcase _T('+'):\n\t\tpStr++;\n\t\tbreak;\n\t}\n\n\tpStart = pStr;\n\tret = 0;\n\tfor (; isdigit(*pStr); pStr++) {\n\t\tret = 10 * ret + (*pStr - _T('0'));\n\t}\n\n\tif (pStr == pStart) {\n\t\treturn nDefault;\n\t}\n\treturn neg ? -ret : ret;\n\n#undef isspace\n#undef isdigit\n}\n\nint _httoi(const TCHAR *value)\n{\n\tstruct CHexMap\n\t{\n\t\tTCHAR chr;\n\t\tint value;\n\t};\n\tconst int HexMapL = 16;\n\tCHexMap HexMap[HexMapL] =\n\t{\n\t\t{'0', 0}, {'1', 1},\n\t\t{'2', 2}, {'3', 3},\n\t\t{'4', 4}, {'5', 5},\n\t\t{'6', 6}, {'7', 7},\n\t\t{'8', 8}, {'9', 9},\n\t\t{'A', 10}, {'B', 11},\n\t\t{'C', 12}, {'D', 13},\n\t\t{'E', 14}, {'F', 15}\n\t};\n\tTCHAR *mstr = _tcsupr(_tcsdup(value));\n\tTCHAR *s = mstr;\n\tint result = 0;\n\tif (*s == '0' && *(s + 1) == 'X') s += 2;\n\tbool firsttime = true;\n\twhile (*s != '\\0')\n\t{\n\t\tbool found = false;\n\t\tfor (int i = 0; i < HexMapL; i++)\n\t\t{\n\t\t\tif (*s == HexMap[i].chr)\n\t\t\t{\n\t\t\t\tif (!firsttime) result <<= 4;\n\t\t\t\tresult |= HexMap[i].value;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) break;\n\t\ts++;\n\t\tfirsttime = false;\n\t}\n\tfree(mstr);\n\treturn result;\n}\n\n//atofにデフォルト値を返せるようにしたような物\nfloat _StrToFloat(LPCTSTR pStr, float fDefault)\n{\n#define isspace(ch)\t\t(ch == _T('\\t') || ch == _T(' '))\n#define isdigit(ch)\t\t((_TUCHAR)(ch - _T('0')) <= 9)\n\n\tint ret_i;\n\tint ret_d;\n\tfloat ret;\n\tbool neg = false;\n\tLPCTSTR pStart;\n\n\tfor (; isspace(*pStr); pStr++);\n\tswitch (*pStr) {\n\tcase _T('-'):\n\t\tneg = true;\n\tcase _T('+'):\n\t\tpStr++;\n\t\tbreak;\n\t}\n\n\tpStart = pStr;\n\tret = 0;\n\tret_i = 0;\n\tret_d = 1;\n\tfor (; isdigit(*pStr); pStr++) {\n\t\tret_i = 10 * ret_i + (*pStr - _T('0'));\n\t}\n\tif (*pStr == _T('.')) {\n\t\tpStr++;\n\t\tfor (; isdigit(*pStr); pStr++) {\n\t\t\tret_i = 10 * ret_i + (*pStr - _T('0'));\n\t\t\tret_d *= 10;\n\t\t}\n\t}\n\tret = (float)ret_i / (float)ret_d;\n\n\tif (pStr == pStart) {\n\t\treturn fDefault;\n\t}\n\treturn neg ? -ret : ret;\n\n#undef isspace\n#undef isdigit\n}*/\n\nvoid HookD2DDll();\nbool HookD2D1();\nvoid HookGdiplus();\nvoid ChangeFileName(LPWSTR lpSrc, int nSize, LPCWSTR lpNewFileName);\nstd::wstring MakeUniqueFontName(const std::wstring strFullName, const std::wstring strFamilyName, const std::wstring strStyleName);\nstd::string WstringToString(const std::wstring str);\n"
        },
        {
          "name": "crc32.h",
          "type": "blob",
          "size": 3.4873046875,
          "content": "#pragma once\r\n#ifndef CRC32_H\r\n#define CRC32_H\r\n\r\nstatic unsigned int crc32_tab[] = {\r\n\t0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,\r\n\t0xe963a535, 0x9e6495a3,    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,\r\n\t0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,\r\n\t0xf3b97148, 0x84be41de,    0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\r\n\t0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,    0x14015c4f, 0x63066cd9,\r\n\t0xfa0f3d63, 0x8d080df5,    0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,\r\n\t0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,    0x35b5a8fa, 0x42b2986c,\r\n\t0xdbbbc9d6, 0xacbcf940,    0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\r\n\t0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,\r\n\t0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\r\n\t0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,    0x76dc4190, 0x01db7106,\r\n\t0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\r\n\t0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,\r\n\t0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,\r\n\t0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\r\n\t0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\r\n\t0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,\r\n\t0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,\r\n\t0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,\r\n\t0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\r\n\t0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,\r\n\t0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,\r\n\t0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,\r\n\t0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\r\n\t0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\r\n\t0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,\r\n\t0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,\r\n\t0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\r\n\t0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,\r\n\t0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\r\n\t0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,\r\n\t0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\r\n\t0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,\r\n\t0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,\r\n\t0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\r\n\t0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\r\n\t0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,\r\n\t0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,\r\n\t0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,\r\n\t0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\r\n\t0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,\r\n\t0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,\r\n\t0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d\r\n};\r\nclass crc32\r\n{\r\npublic:\r\n\tstatic const unsigned int getCrc32(unsigned int crc, const void *buf, int size) {\r\n\t\tconst unsigned char *p;\r\n\t\tp = (unsigned char *)buf;\r\n\t\tcrc = crc ^ ~0U;\r\n\t\twhile (size--) {\r\n\t\t\tcrc = crc32_tab[(crc ^ *p++) & 0xFF] ^ (crc >> 8);\r\n\t\t}\r\n\t\treturn crc ^ ~0U;\r\n\t}\r\n};\r\n#endif\r\n"
        },
        {
          "name": "detours.h",
          "type": "blob",
          "size": 36.6904296875,
          "content": "/////////////////////////////////////////////////////////////////////////////\n//\n//  Core Detours Functionality (detours.h of detours.lib)\n//\n//  Microsoft Research Detours Package, Version 4.0.1\n//\n//  Copyright (c) Microsoft Corporation.  All rights reserved.\n//\n\n#pragma once\n#ifndef _DETOURS_H_\n#define _DETOURS_H_\n\n#define DETOURS_VERSION     0x4c0c1   // 0xMAJORcMINORcPATCH\n\n//////////////////////////////////////////////////////////////////////////////\n//\n\n#undef DETOURS_X64\n#undef DETOURS_X86\n#undef DETOURS_IA64\n#undef DETOURS_ARM\n#undef DETOURS_ARM64\n#undef DETOURS_BITS\n#undef DETOURS_32BIT\n#undef DETOURS_64BIT\n\n#if defined(_X86_)\n#define DETOURS_X86\n#define DETOURS_OPTION_BITS 64\n\n#elif defined(_AMD64_)\n#define DETOURS_X64\n#define DETOURS_OPTION_BITS 32\n\n#elif defined(_IA64_)\n#define DETOURS_IA64\n#define DETOURS_OPTION_BITS 32\n\n#elif defined(_ARM_)\n#define DETOURS_ARM\n\n#elif defined(_ARM64_)\n#define DETOURS_ARM64\n\n#else\n#error Unknown architecture (x86, amd64, ia64, arm, arm64)\n#endif\n\n#ifdef _WIN64\n#undef DETOURS_32BIT\n#define DETOURS_64BIT 1\n#define DETOURS_BITS 64\n// If all 64bit kernels can run one and only one 32bit architecture.\n//#define DETOURS_OPTION_BITS 32\n#else\n#define DETOURS_32BIT 1\n#undef DETOURS_64BIT\n#define DETOURS_BITS 32\n// If all 64bit kernels can run one and only one 32bit architecture.\n//#define DETOURS_OPTION_BITS 32\n#endif\n\n#define VER_DETOURS_BITS    DETOUR_STRINGIFY(DETOURS_BITS)\n\n//////////////////////////////////////////////////////////////////////////////\n//\n\n#if (_MSC_VER < 1299)\ntypedef LONG LONG_PTR;\ntypedef ULONG ULONG_PTR;\n#endif\n\n///////////////////////////////////////////////// SAL 2.0 Annotations w/o SAL.\n//\n//  These definitions are include so that Detours will build even if the\n//  compiler doesn't have full SAL 2.0 support.\n//\n#ifndef DETOURS_DONT_REMOVE_SAL_20\n\n#ifdef DETOURS_TEST_REMOVE_SAL_20\n#undef _Analysis_assume_\n#undef _Benign_race_begin_\n#undef _Benign_race_end_\n#undef _Field_range_\n#undef _Field_size_\n#undef _In_\n#undef _In_bytecount_\n#undef _In_count_\n#undef _In_opt_\n#undef _In_opt_bytecount_\n#undef _In_opt_count_\n#undef _In_opt_z_\n#undef _In_range_\n#undef _In_reads_\n#undef _In_reads_bytes_\n#undef _In_reads_opt_\n#undef _In_reads_opt_bytes_\n#undef _In_reads_or_z_\n#undef _In_z_\n#undef _Inout_\n#undef _Inout_opt_\n#undef _Inout_z_count_\n#undef _Out_\n#undef _Out_opt_\n#undef _Out_writes_\n#undef _Outptr_result_maybenull_\n#undef _Readable_bytes_\n#undef _Success_\n#undef _Writable_bytes_\n#undef _Pre_notnull_\n#endif\n\n#if defined(_Deref_out_opt_z_) && !defined(_Outptr_result_maybenull_)\n#define _Outptr_result_maybenull_ _Deref_out_opt_z_\n#endif\n\n#if defined(_In_count_) && !defined(_In_reads_)\n#define _In_reads_(x) _In_count_(x)\n#endif\n\n#if defined(_In_opt_count_) && !defined(_In_reads_opt_)\n#define _In_reads_opt_(x) _In_opt_count_(x)\n#endif\n\n#if defined(_In_opt_bytecount_) && !defined(_In_reads_opt_bytes_)\n#define _In_reads_opt_bytes_(x) _In_opt_bytecount_(x)\n#endif\n\n#if defined(_In_bytecount_) && !defined(_In_reads_bytes_)\n#define _In_reads_bytes_(x) _In_bytecount_(x)\n#endif\n\n#ifndef _In_\n#define _In_\n#endif\n\n#ifndef _In_bytecount_\n#define _In_bytecount_(x)\n#endif\n\n#ifndef _In_count_\n#define _In_count_(x)\n#endif\n\n#ifndef _In_opt_\n#define _In_opt_\n#endif\n\n#ifndef _In_opt_bytecount_\n#define _In_opt_bytecount_(x)\n#endif\n\n#ifndef _In_opt_count_\n#define _In_opt_count_(x)\n#endif\n\n#ifndef _In_opt_z_\n#define _In_opt_z_\n#endif\n\n#ifndef _In_range_\n#define _In_range_(x,y)\n#endif\n\n#ifndef _In_reads_\n#define _In_reads_(x)\n#endif\n\n#ifndef _In_reads_bytes_\n#define _In_reads_bytes_(x)\n#endif\n\n#ifndef _In_reads_opt_\n#define _In_reads_opt_(x)\n#endif\n\n#ifndef _In_reads_opt_bytes_\n#define _In_reads_opt_bytes_(x)\n#endif\n\n#ifndef _In_reads_or_z_\n#define _In_reads_or_z_\n#endif\n\n#ifndef _In_z_\n#define _In_z_\n#endif\n\n#ifndef _Inout_\n#define _Inout_\n#endif\n\n#ifndef _Inout_opt_\n#define _Inout_opt_\n#endif\n\n#ifndef _Inout_z_count_\n#define _Inout_z_count_(x)\n#endif\n\n#ifndef _Out_\n#define _Out_\n#endif\n\n#ifndef _Out_opt_\n#define _Out_opt_\n#endif\n\n#ifndef _Out_writes_\n#define _Out_writes_(x)\n#endif\n\n#ifndef _Outptr_result_maybenull_\n#define _Outptr_result_maybenull_\n#endif\n\n#ifndef _Writable_bytes_\n#define _Writable_bytes_(x)\n#endif\n\n#ifndef _Readable_bytes_\n#define _Readable_bytes_(x)\n#endif\n\n#ifndef _Success_\n#define _Success_(x)\n#endif\n\n#ifndef _Pre_notnull_\n#define _Pre_notnull_\n#endif\n\n#ifdef DETOURS_INTERNAL\n\n#pragma warning(disable:4615) // unknown warning type (suppress with older compilers)\n\n#ifndef _Benign_race_begin_\n#define _Benign_race_begin_\n#endif\n\n#ifndef _Benign_race_end_\n#define _Benign_race_end_\n#endif\n\n#ifndef _Field_size_\n#define _Field_size_(x)\n#endif\n\n#ifndef _Field_range_\n#define _Field_range_(x,y)\n#endif\n\n#ifndef _Analysis_assume_\n#define _Analysis_assume_(x)\n#endif\n\n#endif // DETOURS_INTERNAL\n#endif // DETOURS_DONT_REMOVE_SAL_20\n\n//////////////////////////////////////////////////////////////////////////////\n//\n#ifndef GUID_DEFINED\n#define GUID_DEFINED\ntypedef struct  _GUID\n{\n    DWORD Data1;\n    WORD Data2;\n    WORD Data3;\n    BYTE Data4[ 8 ];\n} GUID;\n\n#ifdef INITGUID\n#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \\\n        const GUID name \\\n                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }\n#else\n#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \\\n    const GUID name\n#endif // INITGUID\n#endif // !GUID_DEFINED\n\n#if defined(__cplusplus)\n#ifndef _REFGUID_DEFINED\n#define _REFGUID_DEFINED\n#define REFGUID             const GUID &\n#endif // !_REFGUID_DEFINED\n#else // !__cplusplus\n#ifndef _REFGUID_DEFINED\n#define _REFGUID_DEFINED\n#define REFGUID             const GUID * const\n#endif // !_REFGUID_DEFINED\n#endif // !__cplusplus\n\n#ifndef ARRAYSIZE\n#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))\n#endif\n\n//\n//////////////////////////////////////////////////////////////////////////////\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // __cplusplus\n\n/////////////////////////////////////////////////// Instruction Target Macros.\n//\n#define DETOUR_INSTRUCTION_TARGET_NONE          ((PVOID)0)\n#define DETOUR_INSTRUCTION_TARGET_DYNAMIC       ((PVOID)(LONG_PTR)-1)\n#define DETOUR_SECTION_HEADER_SIGNATURE         0x00727444   // \"Dtr\\0\"\n\nextern const GUID DETOUR_EXE_RESTORE_GUID;\nextern const GUID DETOUR_EXE_HELPER_GUID;\n\n#define DETOUR_TRAMPOLINE_SIGNATURE             0x21727444  // Dtr!\ntypedef struct _DETOUR_TRAMPOLINE DETOUR_TRAMPOLINE, *PDETOUR_TRAMPOLINE;\n\n/////////////////////////////////////////////////////////// Binary Structures.\n//\n#pragma pack(push, 8)\ntypedef struct _DETOUR_SECTION_HEADER\n{\n    DWORD       cbHeaderSize;\n    DWORD       nSignature;\n    DWORD       nDataOffset;\n    DWORD       cbDataSize;\n\n    DWORD       nOriginalImportVirtualAddress;\n    DWORD       nOriginalImportSize;\n    DWORD       nOriginalBoundImportVirtualAddress;\n    DWORD       nOriginalBoundImportSize;\n\n    DWORD       nOriginalIatVirtualAddress;\n    DWORD       nOriginalIatSize;\n    DWORD       nOriginalSizeOfImage;\n    DWORD       cbPrePE;\n\n    DWORD       nOriginalClrFlags;\n    DWORD       reserved1;\n    DWORD       reserved2;\n    DWORD       reserved3;\n\n    // Followed by cbPrePE bytes of data.\n} DETOUR_SECTION_HEADER, *PDETOUR_SECTION_HEADER;\n\ntypedef struct _DETOUR_SECTION_RECORD\n{\n    DWORD       cbBytes;\n    DWORD       nReserved;\n    GUID        guid;\n} DETOUR_SECTION_RECORD, *PDETOUR_SECTION_RECORD;\n\ntypedef struct _DETOUR_CLR_HEADER\n{\n    // Header versioning\n    ULONG                   cb;\n    USHORT                  MajorRuntimeVersion;\n    USHORT                  MinorRuntimeVersion;\n\n    // Symbol table and startup information\n    IMAGE_DATA_DIRECTORY    MetaData;\n    ULONG                   Flags;\n\n    // Followed by the rest of the IMAGE_COR20_HEADER\n} DETOUR_CLR_HEADER, *PDETOUR_CLR_HEADER;\n\ntypedef struct _DETOUR_EXE_RESTORE\n{\n    DWORD               cb;\n    DWORD               cbidh;\n    DWORD               cbinh;\n    DWORD               cbclr;\n\n    PBYTE               pidh;\n    PBYTE               pinh;\n    PBYTE               pclr;\n\n    IMAGE_DOS_HEADER    idh;\n    union {\n        IMAGE_NT_HEADERS    inh;\n        IMAGE_NT_HEADERS32  inh32;\n        IMAGE_NT_HEADERS64  inh64;\n        BYTE                raw[sizeof(IMAGE_NT_HEADERS64) +\n                                sizeof(IMAGE_SECTION_HEADER) * 32];\n    };\n    DETOUR_CLR_HEADER   clr;\n\n} DETOUR_EXE_RESTORE, *PDETOUR_EXE_RESTORE;\n\ntypedef struct _DETOUR_EXE_HELPER\n{\n    DWORD               cb;\n    DWORD               pid;\n    DWORD               nDlls;\n    CHAR                rDlls[4];\n} DETOUR_EXE_HELPER, *PDETOUR_EXE_HELPER;\n\n#pragma pack(pop)\n\n#define DETOUR_SECTION_HEADER_DECLARE(cbSectionSize) \\\n{ \\\n      sizeof(DETOUR_SECTION_HEADER),\\\n      DETOUR_SECTION_HEADER_SIGNATURE,\\\n      sizeof(DETOUR_SECTION_HEADER),\\\n      (cbSectionSize),\\\n      \\\n      0,\\\n      0,\\\n      0,\\\n      0,\\\n      \\\n      0,\\\n      0,\\\n      0,\\\n      0,\\\n}\n\n/////////////////////////////////////////////////////////////// Helper Macros.\n//\n#define DETOURS_STRINGIFY(x)    DETOURS_STRINGIFY_(x)\n#define DETOURS_STRINGIFY_(x)    #x\n\n///////////////////////////////////////////////////////////// Binary Typedefs.\n//\ntypedef BOOL (CALLBACK *PF_DETOUR_BINARY_BYWAY_CALLBACK)(\n    _In_opt_ PVOID pContext,\n    _In_opt_ LPCSTR pszFile,\n    _Outptr_result_maybenull_ LPCSTR *ppszOutFile);\n\ntypedef BOOL (CALLBACK *PF_DETOUR_BINARY_FILE_CALLBACK)(\n    _In_opt_ PVOID pContext,\n    _In_ LPCSTR pszOrigFile,\n    _In_ LPCSTR pszFile,\n    _Outptr_result_maybenull_ LPCSTR *ppszOutFile);\n\ntypedef BOOL (CALLBACK *PF_DETOUR_BINARY_SYMBOL_CALLBACK)(\n    _In_opt_ PVOID pContext,\n    _In_ ULONG nOrigOrdinal,\n    _In_ ULONG nOrdinal,\n    _Out_ ULONG *pnOutOrdinal,\n    _In_opt_ LPCSTR pszOrigSymbol,\n    _In_opt_ LPCSTR pszSymbol,\n    _Outptr_result_maybenull_ LPCSTR *ppszOutSymbol);\n\ntypedef BOOL (CALLBACK *PF_DETOUR_BINARY_COMMIT_CALLBACK)(\n    _In_opt_ PVOID pContext);\n\ntypedef BOOL (CALLBACK *PF_DETOUR_ENUMERATE_EXPORT_CALLBACK)(_In_opt_ PVOID pContext,\n                                                             _In_ ULONG nOrdinal,\n                                                             _In_opt_ LPCSTR pszName,\n                                                             _In_opt_ PVOID pCode);\n\ntypedef BOOL (CALLBACK *PF_DETOUR_IMPORT_FILE_CALLBACK)(_In_opt_ PVOID pContext,\n                                                        _In_opt_ HMODULE hModule,\n                                                        _In_opt_ LPCSTR pszFile);\n\ntypedef BOOL (CALLBACK *PF_DETOUR_IMPORT_FUNC_CALLBACK)(_In_opt_ PVOID pContext,\n                                                        _In_ DWORD nOrdinal,\n                                                        _In_opt_ LPCSTR pszFunc,\n                                                        _In_opt_ PVOID pvFunc);\n\n// Same as PF_DETOUR_IMPORT_FUNC_CALLBACK but extra indirection on last parameter.\ntypedef BOOL (CALLBACK *PF_DETOUR_IMPORT_FUNC_CALLBACK_EX)(_In_opt_ PVOID pContext,\n                                                           _In_ DWORD nOrdinal,\n                                                           _In_opt_ LPCSTR pszFunc,\n                                                           _In_opt_ PVOID* ppvFunc);\n\ntypedef VOID * PDETOUR_BINARY;\ntypedef VOID * PDETOUR_LOADED_BINARY;\n\n//////////////////////////////////////////////////////////// Transaction APIs.\n//\nLONG WINAPI DetourTransactionBegin(VOID);\nLONG WINAPI DetourTransactionAbort(VOID);\nLONG WINAPI DetourTransactionCommit(VOID);\nLONG WINAPI DetourTransactionCommitEx(_Out_opt_ PVOID **pppFailedPointer);\n\nLONG WINAPI DetourUpdateThread(_In_ HANDLE hThread);\n\nLONG WINAPI DetourAttach(_Inout_ PVOID *ppPointer,\n                         _In_ PVOID pDetour);\n\nLONG WINAPI DetourAttachEx(_Inout_ PVOID *ppPointer,\n                           _In_ PVOID pDetour,\n                           _Out_opt_ PDETOUR_TRAMPOLINE *ppRealTrampoline,\n                           _Out_opt_ PVOID *ppRealTarget,\n                           _Out_opt_ PVOID *ppRealDetour);\n\nLONG WINAPI DetourDetach(_Inout_ PVOID *ppPointer,\n                         _In_ PVOID pDetour);\n\nBOOL WINAPI DetourSetIgnoreTooSmall(_In_ BOOL fIgnore);\nBOOL WINAPI DetourSetRetainRegions(_In_ BOOL fRetain);\nPVOID WINAPI DetourSetSystemRegionLowerBound(_In_ PVOID pSystemRegionLowerBound);\nPVOID WINAPI DetourSetSystemRegionUpperBound(_In_ PVOID pSystemRegionUpperBound);\n\n////////////////////////////////////////////////////////////// Code Functions.\n//\nPVOID WINAPI DetourFindFunction(_In_ LPCSTR pszModule,\n                                _In_ LPCSTR pszFunction);\nPVOID WINAPI DetourCodeFromPointer(_In_ PVOID pPointer,\n                                   _Out_opt_ PVOID *ppGlobals);\nPVOID WINAPI DetourCopyInstruction(_In_opt_ PVOID pDst,\n                                   _Inout_opt_ PVOID *ppDstPool,\n                                   _In_ PVOID pSrc,\n                                   _Out_opt_ PVOID *ppTarget,\n                                   _Out_opt_ LONG *plExtra);\nBOOL WINAPI DetourSetCodeModule(_In_ HMODULE hModule,\n                                _In_ BOOL fLimitReferencesToModule);\n\n///////////////////////////////////////////////////// Loaded Binary Functions.\n//\nHMODULE WINAPI DetourGetContainingModule(_In_ PVOID pvAddr);\nHMODULE WINAPI DetourEnumerateModules(_In_opt_ HMODULE hModuleLast);\nPVOID WINAPI DetourGetEntryPoint(_In_opt_ HMODULE hModule);\nULONG WINAPI DetourGetModuleSize(_In_opt_ HMODULE hModule);\nBOOL WINAPI DetourEnumerateExports(_In_ HMODULE hModule,\n                                   _In_opt_ PVOID pContext,\n                                   _In_ PF_DETOUR_ENUMERATE_EXPORT_CALLBACK pfExport);\nBOOL WINAPI DetourEnumerateImports(_In_opt_ HMODULE hModule,\n                                   _In_opt_ PVOID pContext,\n                                   _In_opt_ PF_DETOUR_IMPORT_FILE_CALLBACK pfImportFile,\n                                   _In_opt_ PF_DETOUR_IMPORT_FUNC_CALLBACK pfImportFunc);\n\nBOOL WINAPI DetourEnumerateImportsEx(_In_opt_ HMODULE hModule,\n                                     _In_opt_ PVOID pContext,\n                                     _In_opt_ PF_DETOUR_IMPORT_FILE_CALLBACK pfImportFile,\n                                     _In_opt_ PF_DETOUR_IMPORT_FUNC_CALLBACK_EX pfImportFuncEx);\n\n_Writable_bytes_(*pcbData)\n_Readable_bytes_(*pcbData)\n_Success_(return != NULL)\nPVOID WINAPI DetourFindPayload(_In_opt_ HMODULE hModule,\n                               _In_ REFGUID rguid,\n                               _Out_ DWORD *pcbData);\n\n_Writable_bytes_(*pcbData)\n_Readable_bytes_(*pcbData)\n_Success_(return != NULL)\nPVOID WINAPI DetourFindPayloadEx(_In_ REFGUID rguid,\n                                 _Out_ DWORD * pcbData);\n\nDWORD WINAPI DetourGetSizeOfPayloads(_In_opt_ HMODULE hModule);\n\n///////////////////////////////////////////////// Persistent Binary Functions.\n//\n\nPDETOUR_BINARY WINAPI DetourBinaryOpen(_In_ HANDLE hFile);\n\n_Writable_bytes_(*pcbData)\n_Readable_bytes_(*pcbData)\n_Success_(return != NULL)\nPVOID WINAPI DetourBinaryEnumeratePayloads(_In_ PDETOUR_BINARY pBinary,\n                                           _Out_opt_ GUID *pGuid,\n                                           _Out_ DWORD *pcbData,\n                                           _Inout_ DWORD *pnIterator);\n\n_Writable_bytes_(*pcbData)\n_Readable_bytes_(*pcbData)\n_Success_(return != NULL)\nPVOID WINAPI DetourBinaryFindPayload(_In_ PDETOUR_BINARY pBinary,\n                                     _In_ REFGUID rguid,\n                                     _Out_ DWORD *pcbData);\n\nPVOID WINAPI DetourBinarySetPayload(_In_ PDETOUR_BINARY pBinary,\n                                    _In_ REFGUID rguid,\n                                    _In_reads_opt_(cbData) PVOID pData,\n                                    _In_ DWORD cbData);\nBOOL WINAPI DetourBinaryDeletePayload(_In_ PDETOUR_BINARY pBinary, _In_ REFGUID rguid);\nBOOL WINAPI DetourBinaryPurgePayloads(_In_ PDETOUR_BINARY pBinary);\nBOOL WINAPI DetourBinaryResetImports(_In_ PDETOUR_BINARY pBinary);\nBOOL WINAPI DetourBinaryEditImports(_In_ PDETOUR_BINARY pBinary,\n                                    _In_opt_ PVOID pContext,\n                                    _In_opt_ PF_DETOUR_BINARY_BYWAY_CALLBACK pfByway,\n                                    _In_opt_ PF_DETOUR_BINARY_FILE_CALLBACK pfFile,\n                                    _In_opt_ PF_DETOUR_BINARY_SYMBOL_CALLBACK pfSymbol,\n                                    _In_opt_ PF_DETOUR_BINARY_COMMIT_CALLBACK pfCommit);\nBOOL WINAPI DetourBinaryWrite(_In_ PDETOUR_BINARY pBinary, _In_ HANDLE hFile);\nBOOL WINAPI DetourBinaryClose(_In_ PDETOUR_BINARY pBinary);\n\n/////////////////////////////////////////////////// Create Process & Load Dll.\n//\ntypedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEA)(\n    _In_opt_ LPCSTR lpApplicationName,\n    _Inout_opt_ LPSTR lpCommandLine,\n    _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,\n    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,\n    _In_ BOOL bInheritHandles,\n    _In_ DWORD dwCreationFlags,\n    _In_opt_ LPVOID lpEnvironment,\n    _In_opt_ LPCSTR lpCurrentDirectory,\n    _In_ LPSTARTUPINFOA lpStartupInfo,\n    _Out_ LPPROCESS_INFORMATION lpProcessInformation);\n\ntypedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEW)(\n    _In_opt_ LPCWSTR lpApplicationName,\n    _Inout_opt_ LPWSTR lpCommandLine,\n    _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,\n    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,\n    _In_ BOOL bInheritHandles,\n    _In_ DWORD dwCreationFlags,\n    _In_opt_ LPVOID lpEnvironment,\n    _In_opt_ LPCWSTR lpCurrentDirectory,\n    _In_ LPSTARTUPINFOW lpStartupInfo,\n    _Out_ LPPROCESS_INFORMATION lpProcessInformation);\n\nBOOL WINAPI DetourCreateProcessWithDllA(_In_opt_ LPCSTR lpApplicationName,\n                                        _Inout_opt_ LPSTR lpCommandLine,\n                                        _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,\n                                        _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,\n                                        _In_ BOOL bInheritHandles,\n                                        _In_ DWORD dwCreationFlags,\n                                        _In_opt_ LPVOID lpEnvironment,\n                                        _In_opt_ LPCSTR lpCurrentDirectory,\n                                        _In_ LPSTARTUPINFOA lpStartupInfo,\n                                        _Out_ LPPROCESS_INFORMATION lpProcessInformation,\n                                        _In_ LPCSTR lpDllName,\n                                        _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA);\n\nBOOL WINAPI DetourCreateProcessWithDllW(_In_opt_ LPCWSTR lpApplicationName,\n                                        _Inout_opt_ LPWSTR lpCommandLine,\n                                        _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,\n                                        _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,\n                                        _In_ BOOL bInheritHandles,\n                                        _In_ DWORD dwCreationFlags,\n                                        _In_opt_ LPVOID lpEnvironment,\n                                        _In_opt_ LPCWSTR lpCurrentDirectory,\n                                        _In_ LPSTARTUPINFOW lpStartupInfo,\n                                        _Out_ LPPROCESS_INFORMATION lpProcessInformation,\n                                        _In_ LPCSTR lpDllName,\n                                        _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW);\n\n#ifdef UNICODE\n#define DetourCreateProcessWithDll      DetourCreateProcessWithDllW\n#define PDETOUR_CREATE_PROCESS_ROUTINE  PDETOUR_CREATE_PROCESS_ROUTINEW\n#else\n#define DetourCreateProcessWithDll      DetourCreateProcessWithDllA\n#define PDETOUR_CREATE_PROCESS_ROUTINE  PDETOUR_CREATE_PROCESS_ROUTINEA\n#endif // !UNICODE\n\nBOOL WINAPI DetourCreateProcessWithDllExA(_In_opt_ LPCSTR lpApplicationName,\n                                          _Inout_opt_ LPSTR lpCommandLine,\n                                          _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,\n                                          _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,\n                                          _In_ BOOL bInheritHandles,\n                                          _In_ DWORD dwCreationFlags,\n                                          _In_opt_ LPVOID lpEnvironment,\n                                          _In_opt_ LPCSTR lpCurrentDirectory,\n                                          _In_ LPSTARTUPINFOA lpStartupInfo,\n                                          _Out_ LPPROCESS_INFORMATION lpProcessInformation,\n                                          _In_ LPCSTR lpDllName,\n                                          _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA);\n\nBOOL WINAPI DetourCreateProcessWithDllExW(_In_opt_ LPCWSTR lpApplicationName,\n                                          _Inout_opt_  LPWSTR lpCommandLine,\n                                          _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,\n                                          _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,\n                                          _In_ BOOL bInheritHandles,\n                                          _In_ DWORD dwCreationFlags,\n                                          _In_opt_ LPVOID lpEnvironment,\n                                          _In_opt_ LPCWSTR lpCurrentDirectory,\n                                          _In_ LPSTARTUPINFOW lpStartupInfo,\n                                          _Out_ LPPROCESS_INFORMATION lpProcessInformation,\n                                          _In_ LPCSTR lpDllName,\n                                          _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW);\n\n#ifdef UNICODE\n#define DetourCreateProcessWithDllEx    DetourCreateProcessWithDllExW\n#else\n#define DetourCreateProcessWithDllEx    DetourCreateProcessWithDllExA\n#endif // !UNICODE\n\nBOOL WINAPI DetourCreateProcessWithDllsA(_In_opt_ LPCSTR lpApplicationName,\n                                         _Inout_opt_ LPSTR lpCommandLine,\n                                         _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,\n                                         _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,\n                                         _In_ BOOL bInheritHandles,\n                                         _In_ DWORD dwCreationFlags,\n                                         _In_opt_ LPVOID lpEnvironment,\n                                         _In_opt_ LPCSTR lpCurrentDirectory,\n                                         _In_ LPSTARTUPINFOA lpStartupInfo,\n                                         _Out_ LPPROCESS_INFORMATION lpProcessInformation,\n                                         _In_ DWORD nDlls,\n                                         _In_reads_(nDlls) LPCSTR *rlpDlls,\n                                         _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA);\n\nBOOL WINAPI DetourCreateProcessWithDllsW(_In_opt_ LPCWSTR lpApplicationName,\n                                         _Inout_opt_ LPWSTR lpCommandLine,\n                                         _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,\n                                         _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,\n                                         _In_ BOOL bInheritHandles,\n                                         _In_ DWORD dwCreationFlags,\n                                         _In_opt_ LPVOID lpEnvironment,\n                                         _In_opt_ LPCWSTR lpCurrentDirectory,\n                                         _In_ LPSTARTUPINFOW lpStartupInfo,\n                                         _Out_ LPPROCESS_INFORMATION lpProcessInformation,\n                                         _In_ DWORD nDlls,\n                                         _In_reads_(nDlls) LPCSTR *rlpDlls,\n                                         _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW);\n\n#ifdef UNICODE\n#define DetourCreateProcessWithDlls     DetourCreateProcessWithDllsW\n#else\n#define DetourCreateProcessWithDlls     DetourCreateProcessWithDllsA\n#endif // !UNICODE\n\nBOOL WINAPI DetourProcessViaHelperA(_In_ DWORD dwTargetPid,\n                                    _In_ LPCSTR lpDllName,\n                                    _In_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA);\n\nBOOL WINAPI DetourProcessViaHelperW(_In_ DWORD dwTargetPid,\n                                    _In_ LPCSTR lpDllName,\n                                    _In_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW);\n\n#ifdef UNICODE\n#define DetourProcessViaHelper          DetourProcessViaHelperW\n#else\n#define DetourProcessViaHelper          DetourProcessViaHelperA\n#endif // !UNICODE\n\nBOOL WINAPI DetourProcessViaHelperDllsA(_In_ DWORD dwTargetPid,\n                                        _In_ DWORD nDlls,\n                                        _In_reads_(nDlls) LPCSTR *rlpDlls,\n                                        _In_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA);\n\nBOOL WINAPI DetourProcessViaHelperDllsW(_In_ DWORD dwTargetPid,\n                                        _In_ DWORD nDlls,\n                                        _In_reads_(nDlls) LPCSTR *rlpDlls,\n                                        _In_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW);\n\n#ifdef UNICODE\n#define DetourProcessViaHelperDlls      DetourProcessViaHelperDllsW\n#else\n#define DetourProcessViaHelperDlls      DetourProcessViaHelperDllsA\n#endif // !UNICODE\n\nBOOL WINAPI DetourUpdateProcessWithDll(_In_ HANDLE hProcess,\n                                       _In_reads_(nDlls) LPCSTR *rlpDlls,\n                                       _In_ DWORD nDlls);\n\nBOOL WINAPI DetourUpdateProcessWithDllEx(_In_ HANDLE hProcess,\n                                         _In_ HMODULE hImage,\n                                         _In_ BOOL bIs32Bit,\n                                         _In_reads_(nDlls) LPCSTR *rlpDlls,\n                                         _In_ DWORD nDlls);\n\nBOOL WINAPI DetourCopyPayloadToProcess(_In_ HANDLE hProcess,\n                                       _In_ REFGUID rguid,\n                                       _In_reads_bytes_(cbData) PVOID pvData,\n                                       _In_ DWORD cbData);\nBOOL WINAPI DetourRestoreAfterWith(VOID);\nBOOL WINAPI DetourRestoreAfterWithEx(_In_reads_bytes_(cbData) PVOID pvData,\n                                     _In_ DWORD cbData);\nBOOL WINAPI DetourIsHelperProcess(VOID);\nVOID CALLBACK DetourFinishHelperProcess(_In_ HWND,\n                                        _In_ HINSTANCE,\n                                        _In_ LPSTR,\n                                        _In_ INT);\n\n//\n//////////////////////////////////////////////////////////////////////////////\n#ifdef __cplusplus\n}\n#endif // __cplusplus\n\n//////////////////////////////////////////////// Detours Internal Definitions.\n//\n#ifdef __cplusplus\n#ifdef DETOURS_INTERNAL\n\n#define NOTHROW\n// #define NOTHROW (nothrow)\n\n//////////////////////////////////////////////////////////////////////////////\n//\n#if (_MSC_VER < 1299)\n#include <imagehlp.h>\ntypedef IMAGEHLP_MODULE IMAGEHLP_MODULE64;\ntypedef PIMAGEHLP_MODULE PIMAGEHLP_MODULE64;\ntypedef IMAGEHLP_SYMBOL SYMBOL_INFO;\ntypedef PIMAGEHLP_SYMBOL PSYMBOL_INFO;\n\nstatic inline\nLONG InterlockedCompareExchange(_Inout_ LONG *ptr, _In_ LONG nval, _In_ LONG oval)\n{\n    return (LONG)::InterlockedCompareExchange((PVOID*)ptr, (PVOID)nval, (PVOID)oval);\n}\n#else\n#pragma warning(push)\n#pragma warning(disable:4091) // empty typedef\n#include <dbghelp.h>\n#pragma warning(pop)\n#endif\n\n#ifdef IMAGEAPI // defined by DBGHELP.H\ntypedef LPAPI_VERSION (NTAPI *PF_ImagehlpApiVersionEx)(_In_ LPAPI_VERSION AppVersion);\n\ntypedef BOOL (NTAPI *PF_SymInitialize)(_In_ HANDLE hProcess,\n                                       _In_opt_ LPCSTR UserSearchPath,\n                                       _In_ BOOL fInvadeProcess);\ntypedef DWORD (NTAPI *PF_SymSetOptions)(_In_ DWORD SymOptions);\ntypedef DWORD (NTAPI *PF_SymGetOptions)(VOID);\ntypedef DWORD64 (NTAPI *PF_SymLoadModule64)(_In_ HANDLE hProcess,\n                                            _In_opt_ HANDLE hFile,\n                                            _In_ LPSTR ImageName,\n                                            _In_opt_ LPSTR ModuleName,\n                                            _In_ DWORD64 BaseOfDll,\n                                            _In_opt_ DWORD SizeOfDll);\ntypedef BOOL (NTAPI *PF_SymGetModuleInfo64)(_In_ HANDLE hProcess,\n                                            _In_ DWORD64 qwAddr,\n                                            _Out_ PIMAGEHLP_MODULE64 ModuleInfo);\ntypedef BOOL (NTAPI *PF_SymFromName)(_In_ HANDLE hProcess,\n                                     _In_ LPSTR Name,\n                                     _Out_ PSYMBOL_INFO Symbol);\n\ntypedef struct _DETOUR_SYM_INFO\n{\n    HANDLE                  hProcess;\n    HMODULE                 hDbgHelp;\n    PF_ImagehlpApiVersionEx pfImagehlpApiVersionEx;\n    PF_SymInitialize        pfSymInitialize;\n    PF_SymSetOptions        pfSymSetOptions;\n    PF_SymGetOptions        pfSymGetOptions;\n    PF_SymLoadModule64      pfSymLoadModule64;\n    PF_SymGetModuleInfo64   pfSymGetModuleInfo64;\n    PF_SymFromName          pfSymFromName;\n} DETOUR_SYM_INFO, *PDETOUR_SYM_INFO;\n\nPDETOUR_SYM_INFO DetourLoadImageHlp(VOID);\n\n#endif // IMAGEAPI\n\n#if defined(_INC_STDIO) && !defined(_CRT_STDIO_ARBITRARY_WIDE_SPECIFIERS)\n#error detours.h must be included before stdio.h (or at least define _CRT_STDIO_ARBITRARY_WIDE_SPECIFIERS earlier)\n#endif\n#define _CRT_STDIO_ARBITRARY_WIDE_SPECIFIERS 1\n\n#ifndef DETOUR_TRACE\n#if DETOUR_DEBUG\n#define DETOUR_TRACE(x) printf x\n#define DETOUR_BREAK()  __debugbreak()\n#include <stdio.h>\n#include <limits.h>\n#else\n#define DETOUR_TRACE(x)\n#define DETOUR_BREAK()\n#endif\n#endif\n\n#if 1 || defined(DETOURS_IA64)\n\n//\n// IA64 instructions are 41 bits, 3 per bundle, plus 5 bit bundle template => 128 bits per bundle.\n//\n\n#define DETOUR_IA64_INSTRUCTIONS_PER_BUNDLE (3)\n\n#define DETOUR_IA64_TEMPLATE_OFFSET (0)\n#define DETOUR_IA64_TEMPLATE_SIZE   (5)\n\n#define DETOUR_IA64_INSTRUCTION_SIZE (41)\n#define DETOUR_IA64_INSTRUCTION0_OFFSET (DETOUR_IA64_TEMPLATE_SIZE)\n#define DETOUR_IA64_INSTRUCTION1_OFFSET (DETOUR_IA64_TEMPLATE_SIZE + DETOUR_IA64_INSTRUCTION_SIZE)\n#define DETOUR_IA64_INSTRUCTION2_OFFSET (DETOUR_IA64_TEMPLATE_SIZE + DETOUR_IA64_INSTRUCTION_SIZE + DETOUR_IA64_INSTRUCTION_SIZE)\n\nC_ASSERT(DETOUR_IA64_TEMPLATE_SIZE + DETOUR_IA64_INSTRUCTIONS_PER_BUNDLE * DETOUR_IA64_INSTRUCTION_SIZE == 128);\n\n__declspec(align(16)) struct DETOUR_IA64_BUNDLE\n{\n  public:\n    union\n    {\n        BYTE    data[16];\n        UINT64  wide[2];\n    };\n\n    enum {\n        A_UNIT  = 1u,\n        I_UNIT  = 2u,\n        M_UNIT  = 3u,\n        B_UNIT  = 4u,\n        F_UNIT  = 5u,\n        L_UNIT  = 6u,\n        X_UNIT  = 7u,\n    };\n    struct DETOUR_IA64_METADATA\n    {\n        ULONG       nTemplate       : 8;    // Instruction template.\n        ULONG       nUnit0          : 4;    // Unit for slot 0\n        ULONG       nUnit1          : 4;    // Unit for slot 1\n        ULONG       nUnit2          : 4;    // Unit for slot 2\n    };\n\n  protected:\n    static const DETOUR_IA64_METADATA s_rceCopyTable[33];\n\n    UINT RelocateBundle(_Inout_ DETOUR_IA64_BUNDLE* pDst, _Inout_opt_ DETOUR_IA64_BUNDLE* pBundleExtra) const;\n\n    bool RelocateInstruction(_Inout_ DETOUR_IA64_BUNDLE* pDst,\n                             _In_ BYTE slot,\n                             _Inout_opt_ DETOUR_IA64_BUNDLE* pBundleExtra) const;\n\n    // 120 112 104 96 88 80 72 64 56 48 40 32 24 16  8  0\n    //  f.  e.  d. c. b. a. 9. 8. 7. 6. 5. 4. 3. 2. 1. 0.\n\n    //                                      00\n    // f.e. d.c. b.a. 9.8. 7.6. 5.4. 3.2. 1.0.\n    // 0000 0000 0000 0000 0000 0000 0000 001f : Template [4..0]\n    // 0000 0000 0000 0000 0000 03ff ffff ffe0 : Zero [ 41..  5]\n    // 0000 0000 0000 0000 0000 3c00 0000 0000 : Zero [ 45.. 42]\n    // 0000 0000 0007 ffff ffff c000 0000 0000 : One  [ 82.. 46]\n    // 0000 0000 0078 0000 0000 0000 0000 0000 : One  [ 86.. 83]\n    // 0fff ffff ff80 0000 0000 0000 0000 0000 : Two  [123.. 87]\n    // f000 0000 0000 0000 0000 0000 0000 0000 : Two  [127..124]\n    BYTE    GetTemplate() const;\n    // Get 4 bit opcodes.\n    BYTE    GetInst0() const;\n    BYTE    GetInst1() const;\n    BYTE    GetInst2() const;\n    BYTE    GetUnit(BYTE slot) const;\n    BYTE    GetUnit0() const;\n    BYTE    GetUnit1() const;\n    BYTE    GetUnit2() const;\n    // Get 37 bit data.\n    UINT64  GetData0() const;\n    UINT64  GetData1() const;\n    UINT64  GetData2() const;\n\n    // Get/set the full 41 bit instructions.\n    UINT64  GetInstruction(BYTE slot) const;\n    UINT64  GetInstruction0() const;\n    UINT64  GetInstruction1() const;\n    UINT64  GetInstruction2() const;\n    void    SetInstruction(BYTE slot, UINT64 instruction);\n    void    SetInstruction0(UINT64 instruction);\n    void    SetInstruction1(UINT64 instruction);\n    void    SetInstruction2(UINT64 instruction);\n\n    // Get/set bitfields.\n    static UINT64 GetBits(UINT64 Value, UINT64 Offset, UINT64 Count);\n    static UINT64 SetBits(UINT64 Value, UINT64 Offset, UINT64 Count, UINT64 Field);\n\n    // Get specific read-only fields.\n    static UINT64 GetOpcode(UINT64 instruction); // 4bit opcode\n    static UINT64 GetX(UINT64 instruction); // 1bit opcode extension\n    static UINT64 GetX3(UINT64 instruction); // 3bit opcode extension\n    static UINT64 GetX6(UINT64 instruction); // 6bit opcode extension\n\n    // Get/set specific fields.\n    static UINT64 GetImm7a(UINT64 instruction);\n    static UINT64 SetImm7a(UINT64 instruction, UINT64 imm7a);\n    static UINT64 GetImm13c(UINT64 instruction);\n    static UINT64 SetImm13c(UINT64 instruction, UINT64 imm13c);\n    static UINT64 GetSignBit(UINT64 instruction);\n    static UINT64 SetSignBit(UINT64 instruction, UINT64 signBit);\n    static UINT64 GetImm20a(UINT64 instruction);\n    static UINT64 SetImm20a(UINT64 instruction, UINT64 imm20a);\n    static UINT64 GetImm20b(UINT64 instruction);\n    static UINT64 SetImm20b(UINT64 instruction, UINT64 imm20b);\n\n    static UINT64 SignExtend(UINT64 Value, UINT64 Offset);\n\n    BOOL    IsMovlGp() const;\n\n    VOID    SetInst(BYTE Slot, BYTE nInst);\n    VOID    SetInst0(BYTE nInst);\n    VOID    SetInst1(BYTE nInst);\n    VOID    SetInst2(BYTE nInst);\n    VOID    SetData(BYTE Slot, UINT64 nData);\n    VOID    SetData0(UINT64 nData);\n    VOID    SetData1(UINT64 nData);\n    VOID    SetData2(UINT64 nData);\n    BOOL    SetNop(BYTE Slot);\n    BOOL    SetNop0();\n    BOOL    SetNop1();\n    BOOL    SetNop2();\n\n  public:\n    BOOL    IsBrl() const;\n    VOID    SetBrl();\n    VOID    SetBrl(UINT64 target);\n    UINT64  GetBrlTarget() const;\n    VOID    SetBrlTarget(UINT64 target);\n    VOID    SetBrlImm(UINT64 imm);\n    UINT64  GetBrlImm() const;\n\n    UINT64  GetMovlGp() const;\n    VOID    SetMovlGp(UINT64 gp);\n\n    VOID    SetStop();\n\n    UINT    Copy(_Out_ DETOUR_IA64_BUNDLE *pDst, _Inout_opt_ DETOUR_IA64_BUNDLE* pBundleExtra = NULL) const;\n};\n#endif // DETOURS_IA64\n\n#ifdef DETOURS_ARM\n\n#define DETOURS_PFUNC_TO_PBYTE(p)  ((PBYTE)(((ULONG_PTR)(p)) & ~(ULONG_PTR)1))\n#define DETOURS_PBYTE_TO_PFUNC(p)  ((PBYTE)(((ULONG_PTR)(p)) | (ULONG_PTR)1))\n\n#endif // DETOURS_ARM\n\n//////////////////////////////////////////////////////////////////////////////\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // __cplusplus\n\n#define DETOUR_OFFLINE_LIBRARY(x)                                       \\\nPVOID WINAPI DetourCopyInstruction##x(_In_opt_ PVOID pDst,              \\\n                                      _Inout_opt_ PVOID *ppDstPool,     \\\n                                      _In_ PVOID pSrc,                  \\\n                                      _Out_opt_ PVOID *ppTarget,        \\\n                                      _Out_opt_ LONG *plExtra);         \\\n                                                                        \\\nBOOL WINAPI DetourSetCodeModule##x(_In_ HMODULE hModule,                \\\n                                   _In_ BOOL fLimitReferencesToModule); \\\n\nDETOUR_OFFLINE_LIBRARY(X86)\nDETOUR_OFFLINE_LIBRARY(X64)\nDETOUR_OFFLINE_LIBRARY(ARM)\nDETOUR_OFFLINE_LIBRARY(ARM64)\nDETOUR_OFFLINE_LIBRARY(IA64)\n\n#undef DETOUR_OFFLINE_LIBRARY\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Helpers for manipulating page protection.\n//\n\n_Success_(return != FALSE)\nBOOL WINAPI DetourVirtualProtectSameExecuteEx(_In_  HANDLE hProcess,\n                                              _In_  PVOID pAddress,\n                                              _In_  SIZE_T nSize,\n                                              _In_  DWORD dwNewProtect,\n                                              _Out_ PDWORD pdwOldProtect);\n\n_Success_(return != FALSE)\nBOOL WINAPI DetourVirtualProtectSameExecute(_In_  PVOID pAddress,\n                                            _In_  SIZE_T nSize,\n                                            _In_  DWORD dwNewProtect,\n                                            _Out_ PDWORD pdwOldProtect);\n#ifdef __cplusplus\n}\n#endif // __cplusplus\n\n//////////////////////////////////////////////////////////////////////////////\n\n#define MM_ALLOCATION_GRANULARITY 0x10000\n\n//////////////////////////////////////////////////////////////////////////////\n\n#endif // DETOURS_INTERNAL\n#endif // __cplusplus\n\n#endif // _DETOURS_H_\n//\n////////////////////////////////////////////////////////////////  End of File.\n"
        },
        {
          "name": "directwrite.cpp",
          "type": "blob",
          "size": 55.1904296875,
          "content": "#include \"directwrite.h\"\r\n#include \"settings.h\"\r\n#include \"dynCodeHelper.h\"\r\n\r\nvoid MyDebug(const TCHAR * sz, ...)\r\n{\r\n#ifdef DEBUG\r\n\tTCHAR szData[512] = { 0 };\r\n\r\n\tva_list args;\r\n\tva_start(args, sz);\r\n\tStringCchVPrintf(szData, sizeof(szData)-1, sz, args);\r\n\tva_end(args);\r\n\r\n\tOutputDebugString(szData);\r\n#endif\r\n}\r\n\r\n#define SET_VAL(x, y) *(DWORD_PTR*)&(x) = *(DWORD_PTR*)&(y)\r\n// To hook a method, add HOOK_MANUALLY() in hooklist.h and use this.\r\n\r\n#ifdef EASYHOOK\r\n#define ISHOOKED(name) (!!HOOK_##name.Link)\r\n#else\r\n#define ISHOOKED(name) (IsHooked_##name)\r\n#endif\r\n\r\n#define HOOK(obj, name, index) { \\\r\n\tif (!ISHOOKED(name)) {  \\\r\n\t\tAutoEnableDynamicCodeGen dynHelper(true);  \\\r\n\t\tSET_VAL(ORIG_##name, (*reinterpret_cast<void***>(obj.p))[index]);  \\\r\n\t\thook_demand_##name(false);  \\\r\n\t\tif (!ISHOOKED(name)) { MyDebug(L\"##name hook failed\"); }  \\\r\n\t}  \\\r\n};\r\n\r\nstruct ComMethodHooker {\r\n\t// The target function if it has been hooked\r\n\tBOOL (*lpIsHooked)();\r\n\t// The method the vftable refers to\r\n\tvoid*(*lpGetMethod)(IUnknown* obj);\r\n\t// Hook the method\r\n\tvoid(*lpHookFunc)(IUnknown* obj);\r\n};\r\n\r\n#define COM_METHOD_HOOKER(type, name, index) ComMethodHooker { \\\r\n\t[]() -> BOOL { \\\r\n\t\treturn ISHOOKED(name); \\\r\n\t}, \\\r\n\t[](IUnknown* obj) -> void* { \\\r\n\t\treturn (*reinterpret_cast<void***>(obj))[index]; \\\r\n\t}, \\\r\n\t[](IUnknown* obj) -> void { \\\r\n\t\tCComPtr<type> ptr = (type*)obj; \\\r\n\t\tHOOK(ptr, name, index); \\\r\n\t} \\\r\n}\r\n\r\n#define COM_METHOD_HOOKER_EMPTY() ComMethodHooker { \\\r\n\t[]() -> BOOL { \\\r\n\t\treturn false; \\\r\n\t}, \\\r\n\t[](IUnknown* obj) -> void* { \\\r\n\t\treturn NULL; \\\r\n\t}, \\\r\n\t[](IUnknown* obj) -> void { \\\r\n\t\treturn; \\\r\n\t} \\\r\n}\r\n\r\nstruct Params {\r\n\tD2D1_TEXT_ANTIALIAS_MODE AntialiasMode;\r\n\t// Don't access directly. Use Get(D2D|DW)RenderingParams().\r\n\tIDWriteRenderingParams *RenderingParams;\r\n\r\n\tFLOAT Gamma;\r\n\tFLOAT EnhancedContrast;\r\n\tFLOAT ClearTypeLevel;\r\n\tDWRITE_PIXEL_GEOMETRY PixelGeometry;\r\n\t// RenderingMode=6 is invalid for DWrite interface\r\n\tDWRITE_RENDERING_MODE RenderingMode;\r\n\tFLOAT GrayscaleEnhancedContrast;\r\n\tDWRITE_GRID_FIT_MODE GridFitMode;\r\n\tDWRITE_RENDERING_MODE1 RenderingMode1;\r\n\r\n\tParams();\r\n\tvoid CreateParams(IDWriteFactory* dw_factory);\r\n};\r\n\r\n//IDWriteFactory* g_pDWriteFactory = NULL;\r\nCComPtr<IDWriteGdiInterop> g_pGdiInterop = NULL;\r\n\r\nenum D2D1RenderTargetCategory {\r\n\tD2D1_RENDER_TARGET_CATEGORY = 1,\r\n\t// ID2D1DCRenderTarget, ID2D1HwndRenderTarget, ID2D1BitmapRenderTarget\r\n\tD2D1_RENDER_TARGET1_CATEGORY,\r\n\tD2D1_DEVICE_CONTEXT_CATEGORY\r\n};\r\n\r\ntemplate<typename Intf>\r\ninline HRESULT IfSupport(IUnknown* pUnknown, void(*lpFunc)(Intf*)) {\r\n\tCComPtr<Intf> comObject;\r\n\tHRESULT hr = pUnknown->QueryInterface(&comObject);\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tlpFunc(comObject);\r\n\t}\r\n\treturn hr;\r\n}\r\n\r\nvoid Params::CreateParams(IDWriteFactory *dw_factory)\r\n{\r\n\tIDWriteFactory3* dw3 = NULL;\r\n\tIDWriteFactory2* dw2 = NULL;\r\n\tIDWriteFactory1* dw1 = NULL;\r\n\tIDWriteRenderingParams3* r3 = NULL;\r\n\tIDWriteRenderingParams2* r2 = NULL;\r\n\tIDWriteRenderingParams1* r1 = NULL;\r\n\tIDWriteRenderingParams* r0 = NULL;\r\n\r\n\tCComPtr<IDWriteFactory> pDWriteFactory;\r\n\tif (NULL == dw_factory) {\r\n\t\tORIG_DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED,\r\n\t\t\t__uuidof(IDWriteFactory),\r\n\t\t\treinterpret_cast<IUnknown**>(&pDWriteFactory));\r\n\t\tdw_factory = pDWriteFactory;\r\n\t}\r\n\r\n\tHRESULT hr = dw_factory->QueryInterface(&dw3);\r\n\tif SUCCEEDED(hr) {\r\n\t\thr = dw3->CreateCustomRenderingParams(\r\n\t\t\tthis->Gamma,\r\n\t\t\tthis->EnhancedContrast,\r\n\t\t\tthis->GrayscaleEnhancedContrast,\r\n\t\t\tthis->ClearTypeLevel,\r\n\t\t\tthis->PixelGeometry,\r\n\t\t\tthis->RenderingMode1,\r\n\t\t\tthis->GridFitMode,\r\n\t\t\t&r3);\r\n\t\tdw3->Release();\r\n\t\tif SUCCEEDED(hr) {\r\n\t\t\tRenderingParams = r3;\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\thr = dw_factory->QueryInterface(&dw2);\r\n\tif SUCCEEDED(hr) {\r\n\t\thr = dw2->CreateCustomRenderingParams(\r\n\t\t\tthis->Gamma,\r\n\t\t\tthis->EnhancedContrast,\r\n\t\t\tthis->GrayscaleEnhancedContrast,\r\n\t\t\tthis->ClearTypeLevel,\r\n\t\t\tthis->PixelGeometry,\r\n\t\t\tthis->RenderingMode,\r\n\t\t\tthis->GridFitMode,\r\n\t\t\t&r2);\r\n\t\tdw2->Release();\r\n\t\tif SUCCEEDED(hr) {\r\n\t\t\tRenderingParams = r2;\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\thr = dw_factory->QueryInterface(&dw1);\r\n\tif SUCCEEDED(hr) {\r\n\t\thr = dw1->CreateCustomRenderingParams(\r\n\t\t\tthis->Gamma,\r\n\t\t\tthis->EnhancedContrast,\r\n\t\t\tthis->GrayscaleEnhancedContrast,\r\n\t\t\tthis->ClearTypeLevel,\r\n\t\t\tthis->PixelGeometry,\r\n\t\t\tthis->RenderingMode,\r\n\t\t\t&r1);\r\n\t\tdw1->Release();\r\n\t\tif SUCCEEDED(hr) {\r\n\t\t\tRenderingParams = r1;\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\thr = dw_factory->CreateCustomRenderingParams(\r\n\t\tthis->Gamma,\r\n\t\tthis->EnhancedContrast,\r\n\t\tthis->ClearTypeLevel,\r\n\t\tthis->PixelGeometry,\r\n\t\tthis->RenderingMode,\r\n\t\t&r0);\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tRenderingParams = r0;\r\n\t\treturn;\r\n\t}\r\n\r\n\tRenderingParams = NULL;\r\n}\r\n\r\nParams::Params() {\r\n\t//MessageBox(NULL, L\"MakeParam\", NULL, MB_OK);\r\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstanceNoInit();\r\n\t//\r\n\tGamma = pSettings->GammaValueForDW();\t//user defined value preferred.\r\n\t//if (Gamma == 0)\r\n\t//\tGamma = pSettings->GammaValue()*pSettings->GammaValue() > 1.3 ? pSettings->GammaValue()*pSettings->GammaValue() / 2 : 0.7f;\r\n\tEnhancedContrast = pSettings->ContrastForDW();\r\n\tClearTypeLevel = pSettings->ClearTypeLevelForDW();\r\n\tAntialiasMode = (D2D1_TEXT_ANTIALIAS_MODE)D2D1_TEXT_ANTIALIAS_MODE_DEFAULT;\r\n\tswitch (pSettings->AntiAliasModeForDW())\r\n\t{\r\n\t\tcase 2:\r\n\t\tcase 4:\r\n\t\t\tPixelGeometry = DWRITE_PIXEL_GEOMETRY_RGB;\r\n\t\t\tbreak;\r\n\t\tcase 3:\r\n\t\tcase 5:\r\n\t\t\tPixelGeometry = DWRITE_PIXEL_GEOMETRY_BGR;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tPixelGeometry = DWRITE_PIXEL_GEOMETRY_FLAT;\r\n\t\t\tAntialiasMode = D2D1_TEXT_ANTIALIAS_MODE_GRAYSCALE;\r\n\t}\r\n\t\r\n\tRenderingMode = (DWRITE_RENDERING_MODE)pSettings->RenderingModeForDW();\r\n\tGrayscaleEnhancedContrast = pSettings->ContrastForDW();\r\n\tswitch (pSettings->GetFontSettings().GetHintingMode())\r\n\t{\r\n\t\tcase 0: GridFitMode = DWRITE_GRID_FIT_MODE_DEFAULT;\r\n\t\t\tbreak;\r\n\t\tcase 1: GridFitMode = DWRITE_GRID_FIT_MODE_DISABLED;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tGridFitMode = DWRITE_GRID_FIT_MODE_ENABLED;\r\n\t\t\tbreak;\r\n\t}\r\n\tRenderingMode1 = (DWRITE_RENDERING_MODE1)pSettings->RenderingModeForDW();\r\n\tRenderingParams = NULL;\r\n}\r\n\r\nParams* GetD2DParams() {\r\n\tstatic Params d2dParams;\r\n\treturn &d2dParams;\r\n}\r\n\r\nParams* GetDWParams() {\r\n\tstatic Params dwParams = [] {\r\n\t\tconst CGdippSettings* pSettings = CGdippSettings::GetInstanceNoInit();\r\n\r\n\t\tParams p;\r\n\t\tif (pSettings->RenderingModeForDW() == 6) {\t//DW rendering in mode6 is horrible\r\n\t\t\tp.RenderingMode = DWRITE_RENDERING_MODE_NATURAL_SYMMETRIC;\r\n\t\t\tp.RenderingMode1 = DWRITE_RENDERING_MODE1_NATURAL_SYMMETRIC;\r\n\t\t}\r\n\t\t//g_DWParams.Gamma = powf(g_D2DParams.Gamma, 1.0 / 3.0);\r\n\t\treturn p;\r\n\t}();\r\n\treturn &dwParams;\r\n}\r\n\r\nIDWriteRenderingParams* GetD2DRenderingParams(IDWriteRenderingParams* default) {\r\n\tParams* params = GetD2DParams();\r\n\tstatic bool inited = [&] {\r\n\t\tparams->CreateParams(NULL);\r\n\t\treturn true;\r\n\t}();\r\n\r\n\tif (params->RenderingParams)\r\n\t\treturn params->RenderingParams;\r\n\telse\r\n\t\treturn default;\r\n}\r\n\r\nIDWriteRenderingParams* GetDWRenderingParams(IDWriteRenderingParams* default) {\r\n\tParams* params = GetDWParams();\r\n\tstatic bool inited = [&] {\r\n\t\tparams->CreateParams(NULL);\r\n\t\treturn true;\r\n\t}();\r\n\r\n\tif (params->RenderingParams)\r\n\t\treturn params->RenderingParams;\r\n\telse\r\n\t\treturn default;\r\n}\r\n\r\n// Hook the implementation rather than an interface.\r\n// There are many versions but inside the DLL there's only one implementation\r\n// that supports the latest available one. Older versions are just upcasts,\r\n// they share the same vftable.\r\nvoid HookFactory(ID2D1Factory* pD2D1Factory) {\r\n\tstatic bool loaded = [&] {\r\n\t\tHRESULT hr;\r\n\t\tCComPtr<ID2D1Factory> ptr = pD2D1Factory;\r\n\t\t// index is the index in the vftable. Their order is the same as\r\n\t\t// methods declared in the header.\r\n\t\tHOOK(ptr, CreateWicBitmapRenderTarget, 13);\r\n\t\tHOOK(ptr, CreateHwndRenderTarget, 14);\r\n\t\tHOOK(ptr, CreateDxgiSurfaceRenderTarget, 15);\r\n\t\tHOOK(ptr, CreateDCRenderTarget, 16);\r\n\t\tMyDebug(L\"ID2D1Factory hooked\");\r\n\r\n\t\tCComPtr<ID2D1Factory1> ptr1;\r\n\t\thr = pD2D1Factory->QueryInterface(&ptr1);\r\n\t\tif (SUCCEEDED(hr)){\r\n\t\t\tHOOK(ptr1, CreateDevice1, 17);\r\n\t\t\tMyDebug(L\"ID2D1Factory1 hooked\");\r\n\t\t}\r\n\r\n\t\tCComPtr<ID2D1Factory2> ptr2;\r\n\t\thr = pD2D1Factory->QueryInterface(&ptr2);\r\n\t\tif (SUCCEEDED(hr)){\r\n\t\t\tHOOK(ptr2, CreateDevice2, 27);\r\n\t\t\tMyDebug(L\"ID2D1Factory2 hooked\");\r\n\t\t}\r\n\r\n\t\tCComPtr<ID2D1Factory3> ptr3;\r\n\t\thr = pD2D1Factory->QueryInterface(&ptr3);\r\n\t\tif (SUCCEEDED(hr)){\r\n\t\t\tHOOK(ptr3, CreateDevice3, 28);\r\n\t\t\tMyDebug(L\"ID2D1Factory3 hooked\");\r\n\t\t}\r\n\r\n\t\tCComPtr<ID2D1Factory4> ptr4;\r\n\t\thr = pD2D1Factory->QueryInterface(&ptr4);\r\n\t\tif (SUCCEEDED(hr)){\r\n\t\t\tHOOK(ptr4, CreateDevice4, 29);\r\n\t\t\tMyDebug(L\"ID2D1Factory4 hooked\");\r\n\t\t}\r\n\r\n\t\tCComPtr<ID2D1Factory5> ptr5;\r\n\t\thr = pD2D1Factory->QueryInterface(&ptr5);\r\n\t\tif (SUCCEEDED(hr)){\r\n\t\t\tHOOK(ptr5, CreateDevice5, 30);\r\n\t\t\tMyDebug(L\"ID2D1Factory5 hooked\");\r\n\t\t}\r\n\r\n\t\tCComPtr<ID2D1Factory6> ptr6;\r\n\t\thr = pD2D1Factory->QueryInterface(&ptr6);\r\n\t\tif (SUCCEEDED(hr)){\r\n\t\t\tHOOK(ptr6, CreateDevice6, 31);\r\n\t\t\tMyDebug(L\"ID2D1Factory6 hooked\");\r\n\t\t}\r\n\r\n\t\tCComPtr<ID2D1Factory7> ptr7;\r\n\t\thr = pD2D1Factory->QueryInterface(&ptr7);\r\n\t\tif (SUCCEEDED(hr)){\r\n\t\t\tHOOK(ptr7, CreateDevice7, 32);\r\n\t\t\tMyDebug(L\"ID2D1Factory7 hooked\");\r\n\t\t}\r\n\t\treturn true;\r\n\t}();\r\n}\r\n\r\nvoid HookDevice(ID2D1Device* d2dDevice){\r\n\tstatic bool loaded = [&] {\r\n\t\tCComPtr<ID2D1Device> ptr = d2dDevice;\r\n\t\tHOOK(ptr, CreateDeviceContext, 4);\r\n\t\tMyDebug(L\"ID2D1Device hooked\");\r\n\r\n\t\tCComPtr<ID2D1Device1> ptr2;\r\n\t\tHRESULT hr = (d2dDevice)->QueryInterface(&ptr2);\r\n\t\tif SUCCEEDED(hr) {\r\n\t\t\tHOOK(ptr2, CreateDeviceContext2, 11);\r\n\t\t\tMyDebug(L\"ID2D1Device1 hooked\");\r\n\t\t}\r\n\t\tCComPtr<ID2D1Device2> ptr3;\r\n\t\thr = (d2dDevice)->QueryInterface(&ptr3);\r\n\t\tif SUCCEEDED(hr) {\r\n\t\t\tHOOK(ptr3, CreateDeviceContext3, 12);\r\n\t\t\tMyDebug(L\"ID2D1Device2 hooked\");\r\n\t\t}\r\n\t\tCComPtr<ID2D1Device3> ptr4;\r\n\t\thr = (d2dDevice)->QueryInterface(&ptr4);\r\n\t\tif SUCCEEDED(hr) {\r\n\t\t\tHOOK(ptr4, CreateDeviceContext4, 15);\r\n\t\t\tMyDebug(L\"ID2D1Device3 hooked\");\r\n\t\t}\r\n\t\tCComPtr<ID2D1Device4> ptr5;\r\n\t\thr = (d2dDevice)->QueryInterface(&ptr5);\r\n\t\tif SUCCEEDED(hr) {\r\n\t\t\tHOOK(ptr5, CreateDeviceContext5, 16);\r\n\t\t\tMyDebug(L\"ID2D1Device4 hooked\");\r\n\t\t}\r\n\t\tCComPtr<ID2D1Device5> ptr6;\r\n\t\thr = (d2dDevice)->QueryInterface(&ptr6);\r\n\t\tif SUCCEEDED(hr) {\r\n\t\t\tHOOK(ptr6, CreateDeviceContext6, 19);\r\n\t\t\tMyDebug(L\"ID2D1Device5 hooked\");\r\n\t\t}\r\n\t\tCComPtr<ID2D1Device6> ptr7;\r\n\t\thr = (d2dDevice)->QueryInterface(&ptr7);\r\n\t\tif SUCCEEDED(hr) {\r\n\t\t\tHOOK(ptr7, CreateDeviceContext7, 20);\r\n\t\t\tMyDebug(L\"ID2D1Device6 hooked\");\r\n\t\t}\r\n\t\treturn true;\r\n\t}();\r\n}\r\n\r\n// Hook the method if it has not been hooked. It's not thread safe.\r\nvoid HookRenderTargetMethod(\r\n\tID2D1RenderTarget* pD2D1RenderTarget,\r\n\tD2D1RenderTargetCategory hookCategory,\r\n\tComMethodHooker methodHookers[]\r\n\t) {\r\n\tvoid* method = methodHookers[hookCategory].lpGetMethod(pD2D1RenderTarget);\r\n\tif (!method || methodHookers[hookCategory].lpIsHooked()) return;\t// fn is not available or already hooked\r\n\r\n\tmethodHookers[hookCategory].lpHookFunc(pD2D1RenderTarget);\r\n}\r\n\r\nvoid HookRenderTarget(\r\n\tID2D1RenderTarget* pD2D1RenderTarget,\r\n\tD2D1RenderTargetCategory hookCategory\r\n\t){\r\n\tMyDebug(L\"HookRenderTarget %d\", hookCategory);\r\n\tstatic bool loaded = [&] {\r\n\t\tCComPtr<ID2D1RenderTarget> ptr = pD2D1RenderTarget;\r\n\t\tHOOK(ptr, CreateCompatibleRenderTarget, 12);\r\n\t\tHOOK(ptr, D2D1RenderTarget_DrawTextLayout, 28);\r\n\r\n\t\tID2D1Factory* pD2D1Factory;\r\n\t\tpD2D1RenderTarget->GetFactory(&pD2D1Factory);\r\n\t\tif (pD2D1Factory)\r\n\t\t\tHookFactory(pD2D1Factory);\r\n\r\n\t\t// Actually it always implements ID2D1DeviceContext regardless of\r\n\t\t// hookCategory.\r\n\t\tCComPtr<ID2D1DeviceContext> ptr1;\r\n\t\tHRESULT hr = pD2D1RenderTarget->QueryInterface(&ptr1);\r\n\t\tif (SUCCEEDED(hr)) {\r\n\t\t\tID2D1Device* pD2D1Device;\r\n\t\t\tptr1->GetDevice(&pD2D1Device);\r\n\t\t\tif (pD2D1Device)\r\n\t\t\t\tHookDevice(pD2D1Device);\r\n\t\t}\r\n\t\treturn true;\r\n\t}();\r\n\r\n\t// Some methods are duplicated across interfaces. Hook them whenever they're\r\n\t// available from an instance. Make sure don't hook the same function\r\n\t// multiple times.\r\n\t//\r\n\t// Up to two instances of the same function\r\n\tstatic ComMethodHooker hookDrawText[] = {\r\n\t\tCOM_METHOD_HOOKER_EMPTY(),\r\n\t\tCOM_METHOD_HOOKER(ID2D1RenderTarget, D2D1RenderTarget_DrawText, 27),\r\n\t\tCOM_METHOD_HOOKER(ID2D1RenderTarget, D2D1RenderTarget_DrawText, 27),\r\n\t\tCOM_METHOD_HOOKER(ID2D1DeviceContext, D2D1DeviceContext_DrawText, 27)\r\n\t};\r\n\t// Up to three instances of the same function\r\n\tstatic ComMethodHooker hookDrawGlyphRun[] = {\r\n\t\tCOM_METHOD_HOOKER_EMPTY(),\r\n\t\tCOM_METHOD_HOOKER(ID2D1RenderTarget, D2D1RenderTarget_DrawGlyphRun, 29),\r\n\t\tCOM_METHOD_HOOKER(ID2D1RenderTarget, D2D1RenderTarget1_DrawGlyphRun, 29),\r\n\t\tCOM_METHOD_HOOKER(ID2D1DeviceContext, D2D1DeviceContext_DrawGlyphRun, 29)\r\n\t};\r\n\tstatic ComMethodHooker hookSetTextAntialiasMode[] = {\r\n\t\tCOM_METHOD_HOOKER_EMPTY(),\r\n\t\tCOM_METHOD_HOOKER(ID2D1RenderTarget, D2D1RenderTarget_SetTextAntialiasMode, 34),\r\n\t\tCOM_METHOD_HOOKER(ID2D1RenderTarget, D2D1RenderTarget_SetTextAntialiasMode, 34),\r\n\t\tCOM_METHOD_HOOKER(ID2D1DeviceContext, D2D1DeviceContext_SetTextAntialiasMode, 34)\r\n\t};\r\n\tstatic ComMethodHooker hookSetTextRenderingParams[] = {\r\n\t\tCOM_METHOD_HOOKER_EMPTY(),\r\n\t\tCOM_METHOD_HOOKER(ID2D1RenderTarget, D2D1RenderTarget_SetTextRenderingParams, 36),\r\n\t\tCOM_METHOD_HOOKER(ID2D1RenderTarget, D2D1RenderTarget_SetTextRenderingParams, 36),\r\n\t\tCOM_METHOD_HOOKER(ID2D1DeviceContext, D2D1DeviceContext_SetTextRenderingParams, 36)\r\n\t};\r\n\t// Note that there's a branch in the inheritance hierarchy in\r\n\t// ID2D1RenderTarget. But the implementation always supports\r\n\t// ID2D1DeviceContext, thus multiple inheritance should take place. The\r\n\t// vftable for ID2D1DeviceContext is different if hookCategory is not\r\n\t// D2D1_DEVICE_CONTEXT_CATEGORY. It consists of thunks each of which adjusts\r\n\t// the this pointer and then jumps to the corresponding method for\r\n\t// ID2D1RenderTarget (So we don't have to hook them as well), and the other\r\n\t// functions for ID2D1DeviceContext.\r\n\tstatic ComMethodHooker hookDrawGlyphRun1[] = {\r\n\t\tCOM_METHOD_HOOKER_EMPTY(),\r\n\t\tCOM_METHOD_HOOKER(ID2D1RenderTarget, D2D1RenderTarget_DrawGlyphRun1, 82),\r\n\t\tCOM_METHOD_HOOKER(ID2D1RenderTarget, D2D1RenderTarget1_DrawGlyphRun1, 82),\r\n\t\tCOM_METHOD_HOOKER(ID2D1DeviceContext, D2D1DeviceContext_DrawGlyphRun1, 82)\r\n\t};\r\n\r\n\tif (hookCategory == D2D1_RENDER_TARGET_CATEGORY) {\r\n\t\tstatic bool loaded1 = [&] {\t\t\t\r\n\t\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_DWRITE);\r\n\t\t\tHookRenderTargetMethod(pD2D1RenderTarget, hookCategory, hookDrawText);\r\n\t\t\tHookRenderTargetMethod(pD2D1RenderTarget, hookCategory, hookDrawGlyphRun);\r\n\t\t\tHookRenderTargetMethod(pD2D1RenderTarget, hookCategory, hookSetTextAntialiasMode);\r\n\t\t\tHookRenderTargetMethod(pD2D1RenderTarget, hookCategory, hookSetTextRenderingParams);\r\n\r\n\t\t\tCComPtr<ID2D1DeviceContext> ptr;\r\n\t\t\tHRESULT hr = pD2D1RenderTarget->QueryInterface(&ptr);\r\n\t\t\tif (SUCCEEDED(hr)) {\r\n\t\t\t\tHookRenderTargetMethod(ptr, hookCategory, hookDrawGlyphRun1);\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}();\r\n\t} else if (hookCategory == D2D1_RENDER_TARGET1_CATEGORY) {\r\n\t\tstatic bool loaded2 = [&] {\r\n\t\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_DWRITE);\r\n\t\t\tHookRenderTargetMethod(pD2D1RenderTarget, hookCategory, hookDrawText);\r\n\t\t\tHookRenderTargetMethod(pD2D1RenderTarget, hookCategory, hookDrawGlyphRun);\r\n\t\t\tHookRenderTargetMethod(pD2D1RenderTarget, hookCategory, hookSetTextAntialiasMode);\r\n\t\t\tHookRenderTargetMethod(pD2D1RenderTarget, hookCategory, hookSetTextRenderingParams);\r\n\r\n\t\t\tCComPtr<ID2D1DeviceContext> ptr;\r\n\t\t\tHRESULT hr = pD2D1RenderTarget->QueryInterface(&ptr);\r\n\t\t\tif (SUCCEEDED(hr)) {\r\n\t\t\t\tHookRenderTargetMethod(ptr, hookCategory, hookDrawGlyphRun1);\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}();\r\n\t} else if (hookCategory == D2D1_DEVICE_CONTEXT_CATEGORY) {\r\n\t\tstatic bool loaded3 = [&] {\r\n\t\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_DWRITE);\r\n\t\t\tHookRenderTargetMethod(pD2D1RenderTarget, hookCategory, hookDrawText);\r\n\t\t\tHookRenderTargetMethod(pD2D1RenderTarget, hookCategory, hookDrawGlyphRun);\r\n\t\t\tHookRenderTargetMethod(pD2D1RenderTarget, hookCategory, hookSetTextAntialiasMode);\r\n\t\t\tHookRenderTargetMethod(pD2D1RenderTarget, hookCategory, hookSetTextRenderingParams);\r\n\t\t\tHookRenderTargetMethod(pD2D1RenderTarget, hookCategory, hookDrawGlyphRun1);\r\n\t\t\treturn true;\r\n\t\t}();\r\n\t}\r\n\r\n\t//pD2D1RenderTarget->SetTextAntialiasMode(D2D1_TEXT_ANTIALIAS_MODE_DEFAULT);\r\n\tpD2D1RenderTarget->SetTextAntialiasMode(GetD2DParams()->AntialiasMode);\r\n\tif (GetD2DRenderingParams(NULL)) {\r\n\t\tpD2D1RenderTarget->SetTextRenderingParams(GetD2DRenderingParams(NULL));\r\n\t}\r\n}\r\n\r\n\r\n//DWrite hooks\r\nHRESULT WINAPI IMPL_CreateGlyphRunAnalysis(\r\n\tIDWriteFactory* This,\r\n\tDWRITE_GLYPH_RUN const* glyphRun,\r\n\tFLOAT pixelsPerDip,\r\n\tDWRITE_MATRIX const* transform,\r\n\tDWRITE_RENDERING_MODE renderingMode,\r\n\tDWRITE_MEASURING_MODE measuringMode,\r\n\tFLOAT baselineOriginX,\r\n\tFLOAT baselineOriginY,\r\n\tIDWriteGlyphRunAnalysis** glyphRunAnalysis)\r\n{\r\n\tHRESULT hr = E_FAIL;\r\n\tif (FAILED(hr) && renderingMode != DWRITE_RENDERING_MODE_ALIASED) {\r\n\t\tMyDebug(L\"Try DW2\");\r\n\t\tIDWriteFactory2* f;\r\n\t\thr = This->QueryInterface(&f);\r\n\t\tif (SUCCEEDED(hr)) {\r\n\t\t\tDWRITE_MATRIX m = {};\r\n\t\t\tif (transform) {\r\n\t\t\t\tm = *transform;\r\n\t\t\t\tm.m11 *= pixelsPerDip;\r\n\t\t\t\tm.m12 *= pixelsPerDip;\r\n\t\t\t\tm.m21 *= pixelsPerDip;\r\n\t\t\t\tm.m22 *= pixelsPerDip;\r\n\t\t\t\tm.dx *= pixelsPerDip;\r\n\t\t\t\tm.dy *= pixelsPerDip;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tm.m11 = pixelsPerDip;\r\n\t\t\t\tm.m22 = pixelsPerDip;\r\n\t\t\t}\r\n\t\t\thr = f->CreateGlyphRunAnalysis(\r\n\t\t\t\tglyphRun,\r\n\t\t\t\t&m,\r\n\t\t\t\trenderingMode,\r\n\t\t\t\tmeasuringMode,\r\n\t\t\t\tDWRITE_GRID_FIT_MODE_DEFAULT,\r\n\t\t\t\tDWRITE_TEXT_ANTIALIAS_MODE_CLEARTYPE,\r\n\t\t\t\tbaselineOriginX,\r\n\t\t\t\tbaselineOriginY,\r\n\t\t\t\tglyphRunAnalysis\r\n\t\t\t\t);\r\n\t\t\tf->Release();\r\n\t\t}\r\n\t}\r\n\r\n\tif (FAILED(hr) && renderingMode != DWRITE_RENDERING_MODE_ALIASED) {\r\n\t\tMyDebug(L\"Try DW1\");\r\n\t\tParams* dwParams = GetDWParams();\r\n\t\tDWRITE_MATRIX m;\r\n\t\tDWRITE_MATRIX const* pm = transform;\r\n\t\tif (dwParams->GridFitMode == DWRITE_GRID_FIT_MODE_DISABLED) {\r\n\t\t\tif (transform) {\r\n\t\t\t\tm = *transform;\r\n\t\t\t\tm.m12 += 1.0f / 0xFFFF;\r\n\t\t\t\tm.m21 += 1.0f / 0xFFFF;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tm = { 1, 1.0f / 0xFFFF, 1.0f / 0xFFFF, 1 };\r\n\t\t\t}\r\n\t\t\tpm = &m;\r\n\t\t}\r\n\t\thr = ORIG_CreateGlyphRunAnalysis(\r\n\t\t\tThis,\r\n\t\t\tglyphRun,\r\n\t\t\tpixelsPerDip,\r\n\t\t\tpm,\r\n\t\t\tdwParams->RenderingMode,\r\n\t\t\tmeasuringMode,\r\n\t\t\tbaselineOriginX,\r\n\t\t\tbaselineOriginY,\r\n\t\t\tglyphRunAnalysis\r\n\t\t\t);\r\n\t}\r\n\tif (FAILED(hr)) {\r\n\t\tMyDebug(L\"Try Original Params\");\r\n\t\thr = ORIG_CreateGlyphRunAnalysis(\r\n\t\t\tThis,\r\n\t\t\tglyphRun,\r\n\t\t\tpixelsPerDip,\r\n\t\t\ttransform,\r\n\t\t\trenderingMode,\r\n\t\t\tmeasuringMode,\r\n\t\t\tbaselineOriginX,\r\n\t\t\tbaselineOriginY,\r\n\t\t\tglyphRunAnalysis\r\n\t\t\t);\r\n\t}\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tMyDebug(L\"CreateGlyphRunAnalysis hooked\");\r\n\t\tstatic bool loaded = [&] {\r\n\t\t\tCComPtr<IDWriteGlyphRunAnalysis> ptr = *glyphRunAnalysis;\r\n\t\t\tHOOK(ptr, GetAlphaBlendParams, 5);\r\n\t\t\treturn true;\r\n\t\t}();\r\n\t}\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_GetGdiInterop(\r\n\tIDWriteFactory* This,\r\n\tIDWriteGdiInterop** gdiInterop\r\n\t) \r\n{\r\n\tHRESULT hr = ORIG_GetGdiInterop(This, gdiInterop);\r\n\tstatic bool loaded = [&] {\r\n\t\tCComPtr<IDWriteGdiInterop> gdip = *gdiInterop;\r\n\t\tHOOK(gdip, CreateBitmapRenderTarget, 7);\r\n\t\treturn true;\r\n\t}();\r\n\tMyDebug(L\"IMPL_GetGdiInterop hooked\");\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_CreateBitmapRenderTarget(\r\n\tIDWriteGdiInterop* This,\r\n\tHDC hdc,\r\n\tUINT32 width,\r\n\tUINT32 height,\r\n\tIDWriteBitmapRenderTarget** renderTarget\r\n\t)\r\n{\r\n\tHRESULT hr = ORIG_CreateBitmapRenderTarget(\r\n\t\tThis,\r\n\t\thdc,\r\n\t\twidth,\r\n\t\theight,\r\n\t\trenderTarget\r\n\t\t);\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tstatic bool loaded = [&] {\r\n\t\t\tCComPtr<IDWriteBitmapRenderTarget> ptr = *renderTarget;\r\n\t\t\tHOOK(ptr, BitmapRenderTarget_DrawGlyphRun, 3);\r\n\t\t\treturn true;\r\n\t\t}();\r\n\t}\r\n\tMyDebug(L\"CreateBitmapRenderTarget hooked\");\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_GetAlphaBlendParams(\r\n\tIDWriteGlyphRunAnalysis* This,\r\n\tIDWriteRenderingParams* renderingParams,\r\n\tFLOAT* blendGamma,\r\n\tFLOAT* blendEnhancedContrast,\r\n\tFLOAT* blendClearTypeLevel\r\n\t)\r\n{\r\n\tHRESULT hr = E_FAIL;\r\n\tif (FAILED(hr)) {\r\n\t\thr = ORIG_GetAlphaBlendParams(\r\n\t\t\tThis,\r\n\t\t\tGetDWRenderingParams(renderingParams),\r\n\t\t\tblendGamma,\r\n\t\t\tblendEnhancedContrast,\r\n\t\t\tblendClearTypeLevel\r\n\t\t\t);\r\n\t}\r\n\tif (FAILED(hr)) {\r\n\t\thr = ORIG_GetAlphaBlendParams(\r\n\t\t\tThis,\r\n\t\t\trenderingParams,\r\n\t\t\tblendGamma,\r\n\t\t\tblendEnhancedContrast,\r\n\t\t\tblendClearTypeLevel\r\n\t\t\t);\r\n\t}\r\n\tMyDebug(L\"GetAlphaBlendParams hooked\");\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_CreateGlyphRunAnalysis2(\r\n\tIDWriteFactory2* This,\r\n\tDWRITE_GLYPH_RUN const* glyphRun,\r\n\tDWRITE_MATRIX const* transform,\r\n\tDWRITE_RENDERING_MODE renderingMode,\r\n\tDWRITE_MEASURING_MODE measuringMode,\r\n\tDWRITE_GRID_FIT_MODE gridFitMode,\r\n\tDWRITE_TEXT_ANTIALIAS_MODE antialiasMode,\r\n\tFLOAT baselineOriginX,\r\n\tFLOAT baselineOriginY,\r\n\tIDWriteGlyphRunAnalysis** glyphRunAnalysis\r\n\t) \r\n{\r\n\tHRESULT hr = E_FAIL;\r\n\tif (FAILED(hr) && renderingMode != DWRITE_RENDERING_MODE_ALIASED) {\r\n\t\tIDWriteFactory3* f;\r\n\t\thr = This->QueryInterface(&f);\r\n\t\tif (SUCCEEDED(hr)) {\r\n\t\t\thr = f->CreateGlyphRunAnalysis(\r\n\t\t\t\tglyphRun,\r\n\t\t\t\ttransform,\r\n\t\t\t\t(DWRITE_RENDERING_MODE1)renderingMode,\r\n\t\t\t\tmeasuringMode,\r\n\t\t\t\tgridFitMode,\r\n\t\t\t\tantialiasMode,\r\n\t\t\t\tbaselineOriginX,\r\n\t\t\t\tbaselineOriginY,\r\n\t\t\t\tglyphRunAnalysis\r\n\t\t\t\t);\r\n\t\t\tf->Release();\r\n\t\t}\r\n\t}\r\n\r\n\tParams* dwParams = GetDWParams();\r\n\tif (FAILED(hr) && renderingMode != DWRITE_RENDERING_MODE_ALIASED) {\r\n\t\thr = ORIG_CreateGlyphRunAnalysis2(\r\n\t\t\tThis,\r\n\t\t\tglyphRun,\r\n\t\t\ttransform,\r\n\t\t\tdwParams->RenderingMode,\r\n\t\t\tmeasuringMode,\r\n\t\t\tdwParams->GridFitMode,\r\n\t\t\tantialiasMode,\r\n\t\t\tbaselineOriginX,\r\n\t\t\tbaselineOriginY,\r\n\t\t\tglyphRunAnalysis\r\n\t\t\t);\r\n\t}\r\n\tif (FAILED(hr)) {\r\n\t\tDWRITE_MATRIX m = {};\r\n\t\tDWRITE_MATRIX const* pm = transform;\r\n\t\tif (dwParams->GridFitMode == DWRITE_GRID_FIT_MODE_DISABLED) {\r\n\t\t\tif (transform) {\r\n\t\t\t\tm = *transform;\r\n\t\t\t\tm.m12 += 1.0f / 0xFFFF;\r\n\t\t\t\tm.m21 += 1.0f / 0xFFFF;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tm = { 1, 1.0f / 0xFFFF, 1.0f / 0xFFFF, 1 };\r\n\t\t\t}\r\n\t\t\tpm = &m;\r\n\t\t}\r\n\t\thr = ORIG_CreateGlyphRunAnalysis2(\r\n\t\t\tThis,\r\n\t\t\tglyphRun,\r\n\t\t\tpm,\r\n\t\t\trenderingMode,\r\n\t\t\tmeasuringMode,\r\n\t\t\tgridFitMode,\r\n\t\t\tantialiasMode,\r\n\t\t\tbaselineOriginX,\r\n\t\t\tbaselineOriginY,\r\n\t\t\tglyphRunAnalysis\r\n\t\t\t);\r\n\t}\r\n\tif (FAILED(hr)) {\r\n\t\thr = ORIG_CreateGlyphRunAnalysis2(\r\n\t\t\tThis,\r\n\t\t\tglyphRun,\r\n\t\t\ttransform,\r\n\t\t\trenderingMode,\r\n\t\t\tmeasuringMode,\r\n\t\t\tgridFitMode,\r\n\t\t\tantialiasMode,\r\n\t\t\tbaselineOriginX,\r\n\t\t\tbaselineOriginY,\r\n\t\t\tglyphRunAnalysis\r\n\t\t\t);\r\n\t}\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tMyDebug(L\"CreateGlyphRunAnalysis2 hooked\");\r\n\t\tstatic bool loaded = [&] {\r\n\t\t\tCComPtr<IDWriteGlyphRunAnalysis> ptr = *glyphRunAnalysis;\r\n\t\t\tHOOK(ptr, GetAlphaBlendParams, 5);\r\n\t\t\treturn true;\r\n\t\t}();\r\n\t}\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_CreateGlyphRunAnalysis3(\r\n\tIDWriteFactory3* This,\r\n\tDWRITE_GLYPH_RUN const* glyphRun,\r\n\tDWRITE_MATRIX const* transform,\r\n\tDWRITE_RENDERING_MODE1 renderingMode,\r\n\tDWRITE_MEASURING_MODE measuringMode,\r\n\tDWRITE_GRID_FIT_MODE gridFitMode,\r\n\tDWRITE_TEXT_ANTIALIAS_MODE antialiasMode,\r\n\tFLOAT baselineOriginX,\r\n\tFLOAT baselineOriginY,\r\n\tIDWriteGlyphRunAnalysis** glyphRunAnalysis\r\n\t)\r\n{\r\n\tMyDebug(L\"CreateGlyphRunAnalysis3 hooked\");\r\n\tParams* dwParams = GetDWParams();\r\n\tHRESULT hr = E_FAIL;\r\n\tif (FAILED(hr) && renderingMode != DWRITE_RENDERING_MODE1_ALIASED) {\r\n\t\thr = ORIG_CreateGlyphRunAnalysis3(\r\n\t\t\tThis,\r\n\t\t\tglyphRun,\r\n\t\t\ttransform,\r\n\t\t\tdwParams->RenderingMode1,\r\n\t\t\tmeasuringMode,\r\n\t\t\tdwParams->GridFitMode,\r\n\t\t\tantialiasMode,\r\n\t\t\tbaselineOriginX,\r\n\t\t\tbaselineOriginY,\r\n\t\t\tglyphRunAnalysis\r\n\t\t\t);\r\n\t}\r\n\tif (FAILED(hr)) {\r\n\t\tMyDebug(L\"try again with only transformation\");\r\n\t\tDWRITE_MATRIX m = {};\r\n\t\tDWRITE_MATRIX const* pm = transform;\r\n\t\tif (dwParams->GridFitMode == DWRITE_GRID_FIT_MODE_DISABLED) {\r\n\t\t\tif (transform) {\r\n\t\t\t\tm = *transform;\r\n\t\t\t\tm.m12 += 1.0f / 0xFFFF;\r\n\t\t\t\tm.m21 += 1.0f / 0xFFFF;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tm = { 1, 1.0f / 0xFFFF, 1.0f / 0xFFFF, 1 };\r\n\t\t\t}\r\n\t\t\tpm = &m;\r\n\t\t}\r\n\t\thr = ORIG_CreateGlyphRunAnalysis3(\r\n\t\t\tThis,\r\n\t\t\tglyphRun,\r\n\t\t\tpm,\r\n\t\t\trenderingMode,\r\n\t\t\tmeasuringMode,\r\n\t\t\tgridFitMode,\r\n\t\t\tantialiasMode,\r\n\t\t\tbaselineOriginX,\r\n\t\t\tbaselineOriginY,\r\n\t\t\tglyphRunAnalysis\r\n\t\t\t);\r\n\t}\r\n\tif (FAILED(hr)) {\r\n\t\tMyDebug(L\"fallback to original params\");\r\n\t\thr = ORIG_CreateGlyphRunAnalysis3(\r\n\t\t\tThis,\r\n\t\t\tglyphRun,\r\n\t\t\ttransform,\r\n\t\t\trenderingMode,\r\n\t\t\tmeasuringMode,\r\n\t\t\tgridFitMode,\r\n\t\t\tantialiasMode,\r\n\t\t\tbaselineOriginX,\r\n\t\t\tbaselineOriginY,\r\n\t\t\tglyphRunAnalysis\r\n\t\t\t);\r\n\t}\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tMyDebug(L\"CreateGlyphRunAnalysis3 hooked\");\r\n\t\tstatic bool loaded = [&] {\r\n\t\t\tCComPtr<IDWriteGlyphRunAnalysis> ptr = *glyphRunAnalysis;\r\n\t\t\tHOOK(ptr, GetAlphaBlendParams, 5);\r\n\t\t\treturn true;\r\n\t\t}();\r\n\t}\r\n\treturn hr;\r\n}\r\n\r\n\r\n//d2d1 hooks\r\nHRESULT WINAPI IMPL_D2D1CreateDevice(\r\n\tIDXGIDevice* dxgiDevice,\r\n\tCONST D2D1_CREATION_PROPERTIES* creationProperties,\r\n\tID2D1Device** d2dDevice) {\r\n\tHRESULT hr = ORIG_D2D1CreateDevice(\r\n\t\tdxgiDevice,\r\n\t\tcreationProperties,\r\n\t\td2dDevice\r\n\t\t);\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tHookDevice(*d2dDevice);\r\n\t}\r\n\tMyDebug(L\"IMPL_D2D1CreateDevice hooked\");\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_D2D1CreateDeviceContext(\r\n\tIDXGISurface* dxgiSurface,\r\n\tCONST D2D1_CREATION_PROPERTIES* creationProperties,\r\n\tID2D1DeviceContext** d2dDeviceContext){\r\n\tHRESULT hr = ORIG_D2D1CreateDeviceContext(\r\n\t\tdxgiSurface,\r\n\t\tcreationProperties,\r\n\t\td2dDeviceContext\r\n\t\t);\r\n\tif SUCCEEDED(hr) {\r\n\t\tHookRenderTarget(*d2dDeviceContext, D2D1_DEVICE_CONTEXT_CATEGORY);\r\n\t}\r\n\tMyDebug(L\"IMPL_D2D1CreateDeviceContext hooked\");\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_D2D1CreateFactory(\r\n\tD2D1_FACTORY_TYPE factoryType,\r\n\tREFIID riid,\r\n\tconst D2D1_FACTORY_OPTIONS* pFactoryOptions,\r\n\tvoid** ppIFactory){\r\n\tHRESULT hr = ORIG_D2D1CreateFactory(factoryType, riid, pFactoryOptions, ppIFactory);\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tauto pUnknown = reinterpret_cast<IUnknown*>(*ppIFactory);\r\n\t\tID2D1Factory* pD2D1Factory;\r\n\t\tHRESULT hr2 = pUnknown->QueryInterface(&pD2D1Factory);\r\n\t\tif (SUCCEEDED(hr2)) {\r\n\t\t\tHookFactory(pD2D1Factory);\r\n\t\t\tpD2D1Factory->Release();\r\n\t\t}\r\n\t}\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_CreateWicBitmapRenderTarget(\r\n\tID2D1Factory* This,\r\n\tIWICBitmap* target,\r\n\tconst D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,\r\n\tID2D1RenderTarget** renderTarget \r\n\t) {\r\n\tHRESULT hr = ORIG_CreateWicBitmapRenderTarget(\r\n\t\tThis,\r\n\t\ttarget,\r\n\t\trenderTargetProperties,\r\n\t\trenderTarget\r\n\t\t);\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tHookRenderTarget(*renderTarget, D2D1_RENDER_TARGET_CATEGORY);\r\n\t}\r\n\tMyDebug(L\"IMPL_CreateWicBitmapRenderTarget hooked\");\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_CreateHwndRenderTarget(\r\n\tID2D1Factory* This,\r\n\tconst D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,\r\n\tconst D2D1_HWND_RENDER_TARGET_PROPERTIES* hwndRenderTargetProperties,\r\n\tID2D1HwndRenderTarget** hwndRenderTarget\r\n\t) {\r\n\tHRESULT hr = ORIG_CreateHwndRenderTarget(\r\n\t\tThis,\r\n\t\trenderTargetProperties,\r\n\t\thwndRenderTargetProperties,\r\n\t\thwndRenderTarget\r\n\t\t);\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tHookRenderTarget(*hwndRenderTarget, D2D1_RENDER_TARGET1_CATEGORY);\r\n\t}\r\n\tMyDebug(L\"IMPL_CreateHwndRenderTarget hooked\");\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_CreateDxgiSurfaceRenderTarget(\r\n\tID2D1Factory* This,\r\n\tIDXGISurface* dxgiSurface,\r\n\tconst D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,\r\n\tID2D1RenderTarget** renderTarget\r\n\t) {\r\n\tHRESULT hr = ORIG_CreateDxgiSurfaceRenderTarget(\r\n\t\tThis,\r\n\t\tdxgiSurface,\r\n\t\trenderTargetProperties,\r\n\t\trenderTarget\r\n\t\t);\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tHookRenderTarget(*renderTarget, D2D1_RENDER_TARGET_CATEGORY);\r\n\t}\r\n\tMyDebug(L\"IMPL_CreateDxgiSurfaceRenderTarget hooked\");\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_CreateDCRenderTarget(\r\n\tID2D1Factory* This,\r\n\tconst D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,\r\n\tID2D1DCRenderTarget** dcRenderTarget\r\n\t) {\r\n\tHRESULT hr = ORIG_CreateDCRenderTarget(\r\n\t\tThis,\r\n\t\trenderTargetProperties,\r\n\t\tdcRenderTarget\r\n\t\t);\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tHookRenderTarget(*dcRenderTarget, D2D1_RENDER_TARGET1_CATEGORY);\r\n\t}\r\n\tMyDebug(L\"IMPL_CreateDCRenderTarget hooked\");\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_CreateCompatibleRenderTarget(\r\n\tID2D1RenderTarget* This,\r\n\tCONST D2D1_SIZE_F* desiredSize,\r\n\tCONST D2D1_SIZE_U* desiredPixelSize,\r\n\tCONST D2D1_PIXEL_FORMAT* desiredFormat,\r\n\tD2D1_COMPATIBLE_RENDER_TARGET_OPTIONS options,\r\n\tID2D1BitmapRenderTarget** bitmapRenderTarget\r\n\t) {\r\n\tHRESULT hr = ORIG_CreateCompatibleRenderTarget(\r\n\t\tThis,\r\n\t\tdesiredSize,\r\n\t\tdesiredPixelSize,\r\n\t\tdesiredFormat,\r\n\t\toptions,\r\n\t\tbitmapRenderTarget\r\n\t\t);\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tHookRenderTarget(*bitmapRenderTarget, D2D1_RENDER_TARGET1_CATEGORY);\r\n\t}\r\n\tMyDebug(L\"IMPL_CreateCompatibleRenderTarget hooked\");\r\n\treturn hr;\r\n}\r\n\r\nvoid WINAPI IMPL_D2D1RenderTarget_SetTextAntialiasMode(\r\n\tID2D1RenderTarget* This,\r\n\tD2D1_TEXT_ANTIALIAS_MODE textAntialiasMode\r\n\t) {\r\n\tMyDebug(L\"IMPL_D2D1RenderTarget_SetTextAntialiasMode hooked\");\r\n\tORIG_D2D1RenderTarget_SetTextAntialiasMode(This, GetD2DParams()->AntialiasMode);\r\n}\r\n\r\nvoid WINAPI IMPL_D2D1DeviceContext_SetTextAntialiasMode(\r\n\tID2D1DeviceContext* This,\r\n\tD2D1_TEXT_ANTIALIAS_MODE textAntialiasMode\r\n\t) {\r\n\tMyDebug(L\"IMPL_D2D1DeviceContext_SetTextAntialiasMode hooked\");\r\n\tORIG_D2D1DeviceContext_SetTextAntialiasMode(This, GetD2DParams()->AntialiasMode);\r\n}\r\n\r\nvoid WINAPI IMPL_D2D1RenderTarget_SetTextRenderingParams(\r\n\tID2D1RenderTarget* This,\r\n\t_In_opt_ IDWriteRenderingParams* textRenderingParams\r\n\t) {\r\n\tMyDebug(L\"IMPL_D2D1RenderTarget_SetTextRenderingParams hooked\");\r\n\tORIG_D2D1RenderTarget_SetTextRenderingParams(This, GetD2DRenderingParams(textRenderingParams));\r\n}\r\n\r\nvoid WINAPI IMPL_D2D1DeviceContext_SetTextRenderingParams(\r\n\tID2D1DeviceContext* This,\r\n\t_In_opt_ IDWriteRenderingParams* textRenderingParams\r\n\t) {\r\n\tMyDebug(L\"IMPL_D2D1DeviceContext_SetTextRenderingParams hooked\");\r\n\tORIG_D2D1DeviceContext_SetTextRenderingParams(This, GetD2DRenderingParams(textRenderingParams));\r\n}\r\n\r\nHRESULT WINAPI IMPL_CreateDeviceContext(\r\n\tID2D1Device* This,\r\n\tD2D1_DEVICE_CONTEXT_OPTIONS options,\r\n\tID2D1DeviceContext** deviceContext\r\n\t) {\r\n\tHRESULT hr = ORIG_CreateDeviceContext(\r\n\t\tThis,\r\n\t\toptions,\r\n\t\tdeviceContext\r\n\t\t);\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tHookRenderTarget(*deviceContext, D2D1_DEVICE_CONTEXT_CATEGORY);\r\n\t}\r\n\tMyDebug(L\"IMPL_CreateDeviceContext hooked\");\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_CreateDeviceContext2(\r\n\tID2D1Device1* This,\r\n\tD2D1_DEVICE_CONTEXT_OPTIONS options,\r\n\tID2D1DeviceContext1** deviceContext1\r\n\t) {\r\n\tHRESULT hr = ORIG_CreateDeviceContext2(\r\n\t\tThis,\r\n\t\toptions,\r\n\t\tdeviceContext1\r\n\t\t);\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tHookRenderTarget(*deviceContext1, D2D1_DEVICE_CONTEXT_CATEGORY);\r\n\t}\r\n\tMyDebug(L\"IMPL_CreateDeviceContext2 hooked\");\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_CreateDeviceContext3(\r\n\tID2D1Device2* This,\r\n\tD2D1_DEVICE_CONTEXT_OPTIONS options,\r\n\tID2D1DeviceContext2** deviceContext2\r\n\t) {\r\n\tHRESULT hr = ORIG_CreateDeviceContext3(\r\n\t\tThis,\r\n\t\toptions,\r\n\t\tdeviceContext2\r\n\t\t);\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tHookRenderTarget(*deviceContext2, D2D1_DEVICE_CONTEXT_CATEGORY);\r\n\t}\r\n\tMyDebug(L\"IMPL_CreateDeviceContext3 hooked\");\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_CreateDeviceContext4(\r\n\tID2D1Device3* This,\r\n\tD2D1_DEVICE_CONTEXT_OPTIONS options,\r\n\tID2D1DeviceContext3** deviceContext2\r\n\t) {\r\n\tHRESULT hr = ORIG_CreateDeviceContext4(\r\n\t\tThis,\r\n\t\toptions,\r\n\t\tdeviceContext2\r\n\t\t);\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tHookRenderTarget(*deviceContext2, D2D1_DEVICE_CONTEXT_CATEGORY);\r\n\t}\r\n\tMyDebug(L\"IMPL_CreateDeviceContext4 hooked\");\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_CreateDeviceContext5(\r\n\tID2D1Device4* This,\r\n\tD2D1_DEVICE_CONTEXT_OPTIONS options,\r\n\tID2D1DeviceContext4** deviceContext\r\n\t) {\r\n\tHRESULT hr = ORIG_CreateDeviceContext5(\r\n\t\tThis,\r\n\t\toptions,\r\n\t\tdeviceContext\r\n\t\t);\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tHookRenderTarget(*deviceContext, D2D1_DEVICE_CONTEXT_CATEGORY);\r\n\t}\r\n\tMyDebug(L\"IMPL_CreateDeviceContext5 hooked\");\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_CreateDeviceContext6(\r\n\tID2D1Device5* This,\r\n\tD2D1_DEVICE_CONTEXT_OPTIONS options,\r\n\tID2D1DeviceContext5** deviceContext\r\n\t) {\r\n\tHRESULT hr = ORIG_CreateDeviceContext6(\r\n\t\tThis,\r\n\t\toptions,\r\n\t\tdeviceContext\r\n\t\t);\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tHookRenderTarget(*deviceContext, D2D1_DEVICE_CONTEXT_CATEGORY);\r\n\t}\r\n\tMyDebug(L\"IMPL_CreateDeviceContext6 hooked\");\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_CreateDeviceContext7(\r\n\tID2D1Device6* This,\r\n\tD2D1_DEVICE_CONTEXT_OPTIONS options,\r\n\tID2D1DeviceContext6** deviceContext\r\n\t) {\r\n\tHRESULT hr = ORIG_CreateDeviceContext7(\r\n\t\tThis,\r\n\t\toptions,\r\n\t\tdeviceContext\r\n\t\t);\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tHookRenderTarget(*deviceContext, D2D1_DEVICE_CONTEXT_CATEGORY);\r\n\t}\r\n\tMyDebug(L\"IMPL_CreateDeviceContext7 hooked\");\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_CreateDevice1(\r\n\tID2D1Factory1* This,\r\n\tIDXGIDevice* dxgiDevice,\r\n\tID2D1Device** d2dDevice\r\n\t) {\r\n\tHRESULT hr = ORIG_CreateDevice1(\r\n\t\tThis,\r\n\t\tdxgiDevice,\r\n\t\td2dDevice\r\n\t\t);\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tHookDevice(*d2dDevice);\r\n\t}\r\n\tMyDebug(L\"IMPL_CreateDevice1 hooked\");\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_CreateDevice2(\r\n\tID2D1Factory2* This,\r\n\tIDXGIDevice* dxgiDevice,\r\n\tID2D1Device1** d2dDevice1\r\n\t){\r\n\tHRESULT hr = ORIG_CreateDevice2(\r\n\t\tThis,\r\n\t\tdxgiDevice,\r\n\t\td2dDevice1\r\n\t\t);\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tHookDevice(*d2dDevice1);\r\n\t}\r\n\tMyDebug(L\"IMPL_CreateDevice2 hooked\");\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_CreateDevice3(\r\n\tID2D1Factory3* This,\r\n\tIDXGIDevice* dxgiDevice,\r\n\tID2D1Device2** d2dDevice2\r\n\t){\r\n\tHRESULT hr = ORIG_CreateDevice3(\r\n\t\tThis,\r\n\t\tdxgiDevice,\r\n\t\td2dDevice2\r\n\t\t);\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tHookDevice(*d2dDevice2);\r\n\t}\r\n\tMyDebug(L\"IMPL_CreateDevice3 hooked\");\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_CreateDevice4(\r\n\tID2D1Factory4* This,\r\n\tIDXGIDevice* dxgiDevice,\r\n\tID2D1Device3** d2dDevice3\r\n\t){\r\n\tHRESULT hr = ORIG_CreateDevice4(\r\n\t\tThis,\r\n\t\tdxgiDevice,\r\n\t\td2dDevice3\r\n\t\t);\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tHookDevice(*d2dDevice3);\r\n\t}\r\n\tMyDebug(L\"IMPL_CreateDevice4 hooked\");\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_CreateDevice5(\r\n\tID2D1Factory5* This,\r\n\tIDXGIDevice* dxgiDevice,\r\n\tID2D1Device4** d2dDevice4\r\n\t){\r\n\tHRESULT hr = ORIG_CreateDevice5(\r\n\t\tThis,\r\n\t\tdxgiDevice,\r\n\t\td2dDevice4\r\n\t\t);\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tHookDevice(*d2dDevice4);\r\n\t}\r\n\tMyDebug(L\"IMPL_CreateDevice5 hooked\");\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_CreateDevice6(\r\n\tID2D1Factory6* This,\r\n\tIDXGIDevice* dxgiDevice,\r\n\tID2D1Device5** d2dDevice5\r\n\t){\r\n\tHRESULT hr = ORIG_CreateDevice6(\r\n\t\tThis,\r\n\t\tdxgiDevice,\r\n\t\td2dDevice5\r\n\t\t);\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tHookDevice(*d2dDevice5);\r\n\t}\r\n\tMyDebug(L\"IMPL_CreateDevice6 hooked\");\r\n\treturn hr;\r\n}\r\n\r\nHRESULT WINAPI IMPL_CreateDevice7(\r\n\tID2D1Factory7* This,\r\n\tIDXGIDevice* dxgiDevice,\r\n\tID2D1Device6** d2dDevice6\r\n\t){\r\n\tHRESULT hr = ORIG_CreateDevice7(\r\n\t\tThis,\r\n\t\tdxgiDevice,\r\n\t\td2dDevice6\r\n\t\t);\r\n\tif (SUCCEEDED(hr)) {\r\n\t\tHookDevice(*d2dDevice6);\r\n\t}\r\n\tMyDebug(L\"IMPL_CreateDevice7 hooked\");\r\n\treturn hr;\r\n}\r\n\r\n\r\n/*\r\nbool CreateFontFace(IDWriteGdiInterop* gdi, IDWriteFont*** dfont, LOGFONT* lf)\r\n{\r\n__try\r\n{\r\ngdi->CreateFontFromLOGFONT(lf, *dfont);\r\nreturn true;\r\n}\r\n__except(EXCEPTION_EXECUTE_HANDLER)\r\n{\r\nreturn false;\r\n}\r\n}*/\r\n\r\n/*\r\nvoid WINAPI IMPL_SetTextRenderingParams(ID2D1RenderTarget* self, __in_opt IDWriteRenderingParams *textRenderingParams = NULL)\r\n{\r\nreturn ORIG_SetTextRenderingParams(self, g_D2DParamsLarge.RenderingParams);\r\n}\r\n\r\nvoid WINAPI IMPL_SetTextAntialiasMode(ID2D1RenderTarget* self,  D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode)\r\n{\r\nreturn ORIG_SetTextAntialiasMode(self, g_D2DParamsLarge.AntialiasMode);\r\n}*/\r\n\r\nbool hookD2D1() {\r\n\t//MessageBox(NULL, L\"HookD2D1\", NULL, MB_OK);\r\n\tstatic bool loaded = [&] {\r\n\t\treturn true;\r\n\t}();\r\n\treturn loaded;\r\n}\r\n\r\n#define FAILEXIT { /*CoUninitialize();*/ return false;}\r\nbool hookFontCreation(CComPtr<IDWriteFactory>& pDWriteFactory) {\r\n\tif (FAILED(pDWriteFactory->GetGdiInterop(&g_pGdiInterop))) FAILEXIT;\t//判断不正确\r\n\r\n/*\r\n\tHDC dc = CreateCompatibleDC(0);\r\n\tCComQIPtr<IDWriteBitmapRenderTarget> rt;\r\n\tg_pGdiInterop->CreateBitmapRenderTarget(dc, 1, 1, &rt);\t//used to trigger CreateBitmapRenderTarget->DrawGlyphRun hook\r\n\trt.Release();\r\n\tDeleteDC(dc);*/\r\n\r\n\tHOOK(pDWriteFactory, CreateTextFormat, 15);\r\n\tCComPtr<IDWriteFont> dfont = NULL;\r\n\tCComPtr<IDWriteFontCollection> fontcollection = NULL;\r\n\tCComPtr<IDWriteFontFamily> ffamily = NULL;\r\n\tif (FAILED(pDWriteFactory->GetSystemFontCollection(&fontcollection, false))) FAILEXIT;\r\n\tif (FAILED(fontcollection->GetFontFamily(0, &ffamily))) FAILEXIT;\r\n\tif (FAILED(ffamily->GetFont(0, &dfont))) FAILEXIT;\r\n\r\n\tCComPtr<IDWriteFont3> dfont3 = NULL;\r\n\tHRESULT hr = dfont->QueryInterface(&dfont3);\r\n\tif (FAILED(hr)) {\r\n\t\tHOOK(dfont, CreateFontFace, 13);\r\n\t} else {\r\n\t\t// IDWriteFont::CreateFontFace just wraps this\r\n\t\tHOOK(dfont3, CreateFontFace, 19);\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nbool hookDirectWrite(IUnknown ** factory)\t//此函数需要改进以判断是否成功hook\r\n{\r\n\t//CoInitialize(NULL);\r\n#ifdef DEBUG\r\n\t//MessageBox(NULL, L\"HookDW\", NULL, MB_OK);\r\n#endif\r\n\tstatic bool loaded = [&] {\r\n\t\tCComPtr<IDWriteFactory> pDWriteFactory;\r\n\t\tHRESULT hr1 = (*factory)->QueryInterface(&pDWriteFactory);\r\n\t\tif (FAILED(hr1)) FAILEXIT;\r\n\t\tHOOK(pDWriteFactory, CreateGlyphRunAnalysis, 23);\r\n\t\tHOOK(pDWriteFactory, GetGdiInterop, 17);\r\n\t\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\t\t// Windows8/8.1 is too buggy, GDIinterpo doesn't work correctly\r\n\t\tif (!pSettings->IsWindows81() && !pSettings->IsWindows8() && pSettings->DelayedInited() && pSettings->GetFontSubstitutesInfo().GetSize())\r\n\t\t\thookFontCreation(pDWriteFactory);\r\n\t\tMyDebug(L\"DW1 hooked\");\r\n\r\n\t\tCComPtr<IDWriteFactory2> pDWriteFactory2;\r\n\t\tHRESULT hr2 = (*factory)->QueryInterface(&pDWriteFactory2);\r\n\t\tif (FAILED(hr2)) FAILEXIT;\r\n\t\tHOOK(pDWriteFactory2, CreateGlyphRunAnalysis2, 30);\r\n\t\tMyDebug(L\"DW2 hooked\");\r\n\r\n\t\tCComPtr<IDWriteFactory3> pDWriteFactory3;\r\n\t\tHRESULT hr3 = (*factory)->QueryInterface(&pDWriteFactory3);\r\n\t\tif (FAILED(hr3)) FAILEXIT;\r\n\t\tHOOK(pDWriteFactory3, CreateGlyphRunAnalysis3, 31);\r\n\t\tMyDebug(L\"DW3 hooked\");\r\n\t\treturn true;\r\n\t}();\r\n\treturn loaded;\r\n}\r\n\r\n#undef FAILEXIT\r\n#define FAILEXIT {return;}\r\nvoid TriggerHook(ID2D1Factory* d2d_factory) {\r\n\tconst D2D1_PIXEL_FORMAT format = D2D1::PixelFormat(DXGI_FORMAT_B8G8R8A8_UNORM, D2D1_ALPHA_MODE_PREMULTIPLIED);\r\n\tconst D2D1_RENDER_TARGET_PROPERTIES properties =\r\n\t\tD2D1::RenderTargetProperties(D2D1_RENDER_TARGET_TYPE_DEFAULT, format, 0.0f, 0.0f, D2D1_RENDER_TARGET_USAGE_NONE);\r\n\tCComPtr<ID2D1DCRenderTarget>target;\r\n\tif (FAILED(d2d_factory->CreateDCRenderTarget(&properties, &target))) FAILEXIT;\r\n}\r\n\r\n// The entry point of DirectWrite hooking\r\n\r\n// D2D1CreateFactory\r\n// \tHookFactory\r\n// \t\tID2D1Factory\r\n// \t\t\tCreateWicBitmapRenderTarget\r\n// \t\t\tCreateHwndRenderTarget\r\n// \t\t\tCreateDxgiSurfaceRenderTarget\r\n// \t\t\tCreateDCRenderTarget\r\n// \t\t\t\tHookRenderTarget ->\r\n// \t\tID2D1Factory<N>\r\n// \t\t\tCreateDevice<N>\r\n// \t\t\t\tHookDevice ->\r\n\r\n// D2D1CreateDevice\r\n// \tHookDevice\r\n// \t\tID2D1Device<N>\r\n// \t\t\tCreateDeviceContext<N>\r\n// \t\t\t\tHookRenderTarget ->\r\n\r\n// D2D1CreateDeviceContext\r\n// \tHookRenderTarget\r\n// \t\tID2D1RenderTarget\r\n// \t\t\tCreateCompatibleRenderTarget\r\n// \t\t\t\tHookRenderTarget ->\r\n// \t\t\tDrawText\r\n// \t\t\tDrawTextLayout\r\n// \t\t\tDrawGlyphRun\r\n// \t\t\tSetTextAntialiasMode\r\n// \t\t\tSetTextRenderingParams\r\n// \t\t\tGetFactory()\r\n// \t\t\t\tHookFactory ->\r\n\r\n// \t\tID2D1DeviceContext\r\n// \t\t\tDrawGlyphRun1\r\n// \t\t\tGetDevice()\r\n// \t\t\t\tHookDevice ->\r\n\r\n// DWriteCreateFactory\r\n// \thookDirectWrite\r\n// \t\tIDWriteFactory\r\n// \t\t\tGetGdiInterop\r\n// \t\t\t\tCreateBitmapRenderTarget\r\n// \t\t\t\t\tIDWriteBitmapRenderTarget\r\n// \t\t\t\t\t\tDrawGlyphRun\r\n\r\n// \t\t\tCreateGlyphRunAnalysis\r\n// \t\t\t\tIDWriteGlyphRunAnalysis\r\n// \t\t\t\t\tGetAlphaBlendParams\r\n\r\n// \t\t\thookFontCreation\r\n// \t\t\t\tCreateTextFormat\r\n// \t\t\t\t\tIDWriteTextFormat\r\n// \t\t\t\tIDWriteFont\r\n// \t\t\t\t\tCreateFontFace\r\n// \t\t\t\t\t\tIDWriteFontFace\r\n// \t\t\t\tIDWriteFont3\r\n// \t\t\t\t\t   CreateFontFace\r\n// \t\t\t\t\tGetFontFaceReference()\r\n// \t\t\t\t\t\tIDWriteFontFaceReference\r\n// \t\t\t\t\t\t\tCreateFontFace\r\n// \t\t\t\t\t\t\tCreateFontFaceWithSimulations\r\n\r\n// \t\tIDWriteFactory<N>\r\n// \t\t\tCreateGlyphRunAnalysis<N>\r\n// \t\t\t\tIDWriteGlyphRunAnalysis\r\n// \t\t\t\t\tGetAlphaBlendParams\r\nvoid HookD2DDll()\r\n{\r\n\ttypedef HRESULT (WINAPI *PFN_DWriteCreateFactory)(\r\n\t\t_In_ DWRITE_FACTORY_TYPE factoryType,\r\n\t\t_In_ REFIID iid,\r\n\t\t_COM_Outptr_ IUnknown **factory\r\n\t\t);\r\n\r\n\ttypedef HRESULT (WINAPI *PFN_D2D1CreateFactory)(\r\n\t\tD2D1_FACTORY_TYPE factoryType,\r\n\t\tREFIID riid,\r\n\t\tconst D2D1_FACTORY_OPTIONS* pFactoryOptions,\r\n\t\tvoid** ppIFactory\r\n\t\t);\r\n\t//Sleep(30 * 1000);\r\n#ifdef DEBUG\r\n\tMessageBox(0, L\"HookD2DDll\", NULL, MB_OK);\r\n#endif\r\n\tHMODULE d2d1 = GetModuleHandle(_T(\"d2d1.dll\"));\r\n\tHMODULE dw = GetModuleHandle(_T(\"dwrite.dll\"));\r\n\r\n\tif (!d2d1)\r\n\t\td2d1 = LoadLibrary(_T(\"d2d1.dll\"));\r\n\tif (!dw)\r\n\t\tdw = LoadLibrary(_T(\"dwrite.dll\"));\r\n\tvoid* D2D1Factory = GetProcAddress(d2d1, \"D2D1CreateFactory\");\r\n\tvoid* D2D1Device = GetProcAddress(d2d1, \"D2D1CreateDevice\");\r\n\tvoid* D2D1Context = GetProcAddress(d2d1, \"D2D1CreateDeviceContext\");\r\n\tvoid* DWFactory = GetProcAddress(dw, \"DWriteCreateFactory\");\r\n\t*(DWORD_PTR*)&ORIG_D2D1CreateFactory = (DWORD_PTR)D2D1Factory;\r\n\t*(DWORD_PTR*)&ORIG_D2D1CreateDevice = (DWORD_PTR)D2D1Device;\r\n\t*(DWORD_PTR*)&ORIG_D2D1CreateDeviceContext = (DWORD_PTR)D2D1Context;\r\n\t*(DWORD_PTR*)&ORIG_DWriteCreateFactory = (DWORD_PTR)DWFactory;\r\n\tif (DWFactory) {\r\n\t\thook_demand_DWriteCreateFactory();\r\n\t}\r\n\tif (D2D1Factory){\r\n\t\thook_demand_D2D1CreateFactory();\r\n\t}\r\n\tif (D2D1Device) {\r\n\t\thook_demand_D2D1CreateDevice();\r\n\t}\r\n\tif (D2D1Context) {\r\n\t\thook_demand_D2D1CreateDeviceContext();\r\n\t}\r\n}\r\n\r\n/*\r\nvoid HookGdiplus()\r\n{\r\nInitGdiplusFuncs();\r\n//*(DWORD_PTR*)&ORIG_D2D1CreateFactory = (DWORD_PTR)D2D1Factory;\r\n*(DWORD_PTR*)&ORIG_GdipDrawString = (DWORD_PTR)pfnGdipDrawString;\r\nhook_demand_GdipDrawString();\r\n}\r\n\r\nGpStatus WINAPI IMPL_GdipDrawString(\r\nGpGraphics               *graphics,\r\nGDIPCONST WCHAR          *string,\r\nINT                       length,\r\nGDIPCONST GpFont         *font,\r\nGDIPCONST RectF          *layoutRect,\r\nGDIPCONST GpStringFormat *stringFormat,\r\nGDIPCONST GpBrush        *brush\r\n)\r\n{\r\n#define GDIPEXEC ORIG_GdipDrawString(graphics, string, length, font, layoutRect, stringFormat, brush)\r\n#define GDIPCHECK(x) if ((x)!=Ok) return GDIPEXEC\r\nif (string)\r\n{\r\nHDC dc = NULL;\r\nLOGFONTW lf = {0};\r\nGpBrushType bt;\r\nARGB FontColor=0 ,bkColor = 0;\r\n//GDIPLUS to gdi32 data preparation\r\nGDIPCHECK(pfnGdipGetLogFontW((GpFont*)font, graphics, &lf));\r\nGDIPCHECK(pfnGdipGetBrushType((GpBrush*)brush, &bt));\r\nif (bt!=BrushTypeSolidColor) return GDIPEXEC; //only solid brush is supported by GDI32\r\nGDIPCHECK(pfnGdipGetSolidFillColor((GpSolidFill*)brush, &FontColor));\r\nif (FontColor>>24!=0xFF) return GDIPEXEC;\t//only transparent and Opaque is supported.\r\nGDIPCHECK(pfnGdipGetDC(graphics, &dc));\r\nHFONT ft = CreateFontIndirectW(&lf);\r\nHFONT oldfont = SelectFont(dc, ft);\r\n\r\nSetTextColor(dc, FontColor & 0x00FFFFFF);\r\nSetBkMode(dc, TRANSPARENT);\r\nRECT gdiRect = {ROUND(layoutRect->X), ROUND(layoutRect->Y), ROUND(layoutRect->X+layoutRect->Width), ROUND(layoutRect->Y+layoutRect->Height)};\r\nDrawText(dc, string, length, &gdiRect, DT_WORDBREAK);\r\n//ExtTextOutW(dc, gdiRect.left, gdiRect.top, 0, &gdiRect, string, wcslen(string), NULL);\r\n\r\nSelectObject(dc, oldfont);\r\nDeleteObject(ft);\r\npfnGdipReleaseDC(graphics, dc);\r\nreturn Ok;\r\n}\r\nelse\r\nreturn ORIG_GdipDrawString(graphics, string, length, font, layoutRect, stringFormat, brush);\r\n#undef GDIPCHECK\r\n#undef GDIPEXEC\r\n}\r\n*/\r\nHRESULT WINAPI IMPL_DWriteCreateFactory(__in DWRITE_FACTORY_TYPE factoryType,\r\n\t__in REFIID iid,\r\n\t__out IUnknown **factory)\r\n{\r\n\tHRESULT ret = ORIG_DWriteCreateFactory(factoryType, iid, factory); \r\n\tif (SUCCEEDED(ret))\r\n\t\thookDirectWrite(factory);\r\n\treturn ret;\r\n}\r\n\r\nHRESULT WINAPI IMPL_CreateFontFace(IDWriteFont* self,\r\n\t__out IDWriteFontFace** fontFace)\r\n{\r\n\tHRESULT ret = ORIG_CreateFontFace(self, fontFace);\r\n\tif (ret == S_OK)\r\n\t{\r\n\t\t/*static bool loaded = [&] {\r\n\t\t\tCComPtr<IDWriteFontFace3> dfont3 = NULL;\r\n\t\t\tHRESULT hr = self->QueryInterface(&dfont3);\r\n\t\t\tif (SUCCEEDED(hr)) {\r\n\t\t\t\tCComPtr<IDWriteFontFaceReference> ffref;\r\n\t\t\t\tif (SUCCEEDED(dfont3->GetFontFaceReference(&ffref)) && ffref) {\r\n\t\t\t\t\t// Same as IDWriteFontFaceReference1::CreateFontFace\r\n\t\t\t\t\tHOOK(ffref, DWriteFontFaceReference_CreateFontFace, 3);\r\n\t\t\t\t\tHOOK(ffref, DWriteFontFaceReference_CreateFontFaceWithSimulations, 4);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}();*/\r\n\r\n\t\tLOGFONT lf = { 0 };\r\n\t\tif (FAILED(g_pGdiInterop->ConvertFontFaceToLOGFONT(*fontFace, &lf)))\r\n\t\t\treturn ret;\r\n\t\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\t\tif (pSettings->CopyForceFont(lf, lf))\r\n\t\t{\r\n\t\t\tIDWriteFont* writefont = NULL;\r\n\t\t\tif (FAILED(g_pGdiInterop->CreateFontFromLOGFONT(&lf, &writefont)))\r\n\t\t\t\treturn ret;\r\n\t\t\t(*fontFace)->Release();\r\n\t\t\tORIG_CreateFontFace(writefont, fontFace);\r\n\t\t\twritefont->Release();\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nbool SubstituteDWriteFont3(__out IDWriteFontFace3** fontFace3)\r\n{\r\n\tLOGFONT lf = { 0 };\r\n\tif (FAILED(g_pGdiInterop->ConvertFontFaceToLOGFONT(*fontFace3, &lf)))\r\n\t\treturn false;\r\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\tif (pSettings->CopyForceFont(lf, lf))\r\n\t{\r\n\t\tCComPtr<IDWriteFont> writefont;\r\n\t\tif (FAILED(g_pGdiInterop->CreateFontFromLOGFONT(&lf, &writefont)))\r\n\t\t\treturn false;\r\n\r\n\t\tCComPtr<IDWriteFontFace> fontFaceOut;\r\n\t\tORIG_CreateFontFace(writefont, &fontFaceOut);\r\n\t\tIDWriteFontFace3* fontFace3Out;\r\n\t\tif (FAILED(fontFaceOut->QueryInterface(&fontFace3Out)))\r\n\t\t\treturn false;\r\n\t\t\r\n\t\t(*fontFace3)->Release();\r\n\t\t*fontFace3 = fontFace3Out;\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nHRESULT WINAPI IMPL_DWriteFontFaceReference_CreateFontFace(\r\n\tIDWriteFontFaceReference* self,\r\n\t__out IDWriteFontFace3** fontFace)\r\n{\r\n\tHRESULT ret = ORIG_DWriteFontFaceReference_CreateFontFace(self, fontFace);\r\n\tif (ret == S_OK) {\r\n\t\tSubstituteDWriteFont3(fontFace);\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nHRESULT WINAPI IMPL_DWriteFontFaceReference_CreateFontFaceWithSimulations(\r\n\tIDWriteFontFaceReference* self,\r\n\tDWRITE_FONT_SIMULATIONS fontFaceSimulationFlags,\r\n\t__out IDWriteFontFace3** fontFace)\r\n{\r\n\tHRESULT ret = ORIG_DWriteFontFaceReference_CreateFontFaceWithSimulations(self,\r\n\t\tfontFaceSimulationFlags, fontFace);\r\n\tif (ret == S_OK) {\r\n\t\tSubstituteDWriteFont3(fontFace);\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nHRESULT  WINAPI IMPL_CreateTextFormat(IDWriteFactory* self,\r\n\t__in_z WCHAR const* fontFamilyName,\r\n\t__maybenull IDWriteFontCollection* fontCollection,\r\n\tDWRITE_FONT_WEIGHT fontWeight,\r\n\tDWRITE_FONT_STYLE fontStyle,\r\n\tDWRITE_FONT_STRETCH fontStretch,\r\n\tFLOAT fontSize,\r\n\t__in_z WCHAR const* localeName,\r\n\t__out IDWriteTextFormat** textFormat)\r\n{\r\n\tLOGFONT lf = { 0 };\r\n\tStringCchCopy(lf.lfFaceName, LF_FACESIZE, fontFamilyName);\r\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\tif (pSettings->CopyForceFont(lf, lf))\r\n\t\treturn ORIG_CreateTextFormat(self, lf.lfFaceName, fontCollection, fontWeight, fontStyle, fontStretch, fontSize, localeName, textFormat);\r\n\telse\r\n\t\treturn ORIG_CreateTextFormat(self, fontFamilyName, fontCollection, fontWeight, fontStyle, fontStretch, fontSize, localeName, textFormat);\r\n}\r\n\r\nvoid WINAPI IMPL_D2D1RenderTarget_DrawGlyphRun1(\r\n\tID2D1DeviceContext *This,\r\n\tD2D1_POINT_2F baselineOrigin,\r\n\tCONST DWRITE_GLYPH_RUN *glyphRun,\r\n\tCONST DWRITE_GLYPH_RUN_DESCRIPTION *glyphRunDescription,\r\n\tID2D1Brush *foregroundBrush,\r\n\tDWRITE_MEASURING_MODE measuringMode\r\n\t) {\r\n\tParams* dwParams = GetDWParams();\r\n\tif (dwParams->GridFitMode == DWRITE_GRID_FIT_MODE_DISABLED) {\r\n\t\tD2D1_MATRIX_3X2_F prev;\r\n\t\tThis->GetTransform(&prev);\r\n\t\tD2D1_MATRIX_3X2_F rotate = prev;\r\n\t\trotate.m12 += 1.0f / 0xFFFF;\r\n\t\trotate.m21 += 1.0f / 0xFFFF;\r\n\t\tThis->SetTransform(&rotate);\r\n\t\tORIG_D2D1RenderTarget_DrawGlyphRun1(\r\n\t\t\tThis,\r\n\t\t\tbaselineOrigin,\r\n\t\t\tglyphRun,\r\n\t\t\tglyphRunDescription,\r\n\t\t\tforegroundBrush,\r\n\t\t\tmeasuringMode\r\n\t\t\t);\r\n\t\tThis->SetTransform(&prev);\r\n\t}\r\n\telse {\r\n\t\tORIG_D2D1RenderTarget_DrawGlyphRun1(\r\n\t\t\tThis,\r\n\t\t\tbaselineOrigin,\r\n\t\t\tglyphRun,\r\n\t\t\tglyphRunDescription,\r\n\t\t\tforegroundBrush,\r\n\t\t\tmeasuringMode\r\n\t\t\t);\r\n\t}\r\n}\r\n\r\nvoid WINAPI IMPL_D2D1RenderTarget1_DrawGlyphRun1(\r\n\tID2D1DeviceContext *This,\r\n\tD2D1_POINT_2F baselineOrigin,\r\n\tCONST DWRITE_GLYPH_RUN *glyphRun,\r\n\tCONST DWRITE_GLYPH_RUN_DESCRIPTION *glyphRunDescription,\r\n\tID2D1Brush *foregroundBrush,\r\n\tDWRITE_MEASURING_MODE measuringMode\r\n\t) {\r\n\tParams* dwParams = GetDWParams();\r\n\tif (dwParams->GridFitMode == DWRITE_GRID_FIT_MODE_DISABLED) {\r\n\t\tD2D1_MATRIX_3X2_F prev;\r\n\t\tThis->GetTransform(&prev);\r\n\t\tD2D1_MATRIX_3X2_F rotate = prev;\r\n\t\trotate.m12 += 1.0f / 0xFFFF;\r\n\t\trotate.m21 += 1.0f / 0xFFFF;\r\n\t\tThis->SetTransform(&rotate);\r\n\t\tORIG_D2D1RenderTarget1_DrawGlyphRun1(\r\n\t\t\tThis,\r\n\t\t\tbaselineOrigin,\r\n\t\t\tglyphRun,\r\n\t\t\tglyphRunDescription,\r\n\t\t\tforegroundBrush,\r\n\t\t\tmeasuringMode\r\n\t\t\t);\r\n\t\tThis->SetTransform(&prev);\r\n\t}\r\n\telse {\r\n\t\tORIG_D2D1RenderTarget1_DrawGlyphRun1(\r\n\t\t\tThis,\r\n\t\t\tbaselineOrigin,\r\n\t\t\tglyphRun,\r\n\t\t\tglyphRunDescription,\r\n\t\t\tforegroundBrush,\r\n\t\t\tmeasuringMode\r\n\t\t\t);\r\n\t}\r\n}\r\n\r\nvoid WINAPI IMPL_D2D1DeviceContext_DrawGlyphRun1(\r\n\tID2D1DeviceContext *This,\r\n\tD2D1_POINT_2F baselineOrigin,\r\n\tCONST DWRITE_GLYPH_RUN *glyphRun,\r\n\tCONST DWRITE_GLYPH_RUN_DESCRIPTION *glyphRunDescription,\r\n\tID2D1Brush *foregroundBrush,\r\n\tDWRITE_MEASURING_MODE measuringMode\r\n\t) {\r\n\tParams* dwParams = GetDWParams();\r\n\tif (dwParams->GridFitMode == DWRITE_GRID_FIT_MODE_DISABLED) {\r\n\t\tD2D1_MATRIX_3X2_F prev;\r\n\t\tThis->GetTransform(&prev);\r\n\t\tD2D1_MATRIX_3X2_F rotate = prev;\r\n\t\trotate.m12 += 1.0f / 0xFFFF;\r\n\t\trotate.m21 += 1.0f / 0xFFFF;\r\n\t\tThis->SetTransform(&rotate);\r\n\t\tORIG_D2D1DeviceContext_DrawGlyphRun1(\r\n\t\t\tThis,\r\n\t\t\tbaselineOrigin,\r\n\t\t\tglyphRun,\r\n\t\t\tglyphRunDescription,\r\n\t\t\tforegroundBrush,\r\n\t\t\tmeasuringMode\r\n\t\t\t);\r\n\t\tThis->SetTransform(&prev);\r\n\t}\r\n\telse {\r\n\t\tORIG_D2D1DeviceContext_DrawGlyphRun1(\r\n\t\t\tThis,\r\n\t\t\tbaselineOrigin,\r\n\t\t\tglyphRun,\r\n\t\t\tglyphRunDescription,\r\n\t\t\tforegroundBrush,\r\n\t\t\tmeasuringMode\r\n\t\t\t);\r\n\t}\r\n}\r\n\r\nvoid WINAPI IMPL_D2D1RenderTarget_DrawGlyphRun(\r\n\tID2D1RenderTarget* This,\r\n\tD2D1_POINT_2F baselineOrigin,\r\n\tCONST DWRITE_GLYPH_RUN *glyphRun,\r\n\tID2D1Brush *foregroundBrush,\r\n\tDWRITE_MEASURING_MODE measuringMode\r\n\t) {\r\n\tParams* dwParams = GetDWParams();\r\n\tif (dwParams->GridFitMode == DWRITE_GRID_FIT_MODE_DISABLED) {\r\n\t\tD2D1_MATRIX_3X2_F prev;\r\n\t\tThis->GetTransform(&prev);\r\n\t\tD2D1_MATRIX_3X2_F rotate = prev;\r\n\t\trotate.m12 += 1.0f / 0xFFFF;\r\n\t\trotate.m21 += 1.0f / 0xFFFF;\r\n\t\tThis->SetTransform(&rotate);\r\n\t\tORIG_D2D1RenderTarget_DrawGlyphRun(\r\n\t\t\tThis,\r\n\t\t\tbaselineOrigin,\r\n\t\t\tglyphRun,\r\n\t\t\tforegroundBrush,\r\n\t\t\tmeasuringMode\r\n\t\t\t);\r\n\t\tThis->SetTransform(&prev);\r\n\t}\r\n\telse {\r\n\t\tORIG_D2D1RenderTarget_DrawGlyphRun(\r\n\t\t\tThis,\r\n\t\t\tbaselineOrigin,\r\n\t\t\tglyphRun,\r\n\t\t\tforegroundBrush,\r\n\t\t\tmeasuringMode\r\n\t\t\t);\r\n\t}\r\n}\r\n\r\nvoid WINAPI IMPL_D2D1RenderTarget1_DrawGlyphRun(\r\n\tID2D1RenderTarget* This,\r\n\tD2D1_POINT_2F baselineOrigin,\r\n\tCONST DWRITE_GLYPH_RUN *glyphRun,\r\n\tID2D1Brush *foregroundBrush,\r\n\tDWRITE_MEASURING_MODE measuringMode\r\n\t) {\r\n\tParams* dwParams = GetDWParams();\r\n\tif (dwParams->GridFitMode == DWRITE_GRID_FIT_MODE_DISABLED) {\r\n\t\tD2D1_MATRIX_3X2_F prev;\r\n\t\tThis->GetTransform(&prev);\r\n\t\tD2D1_MATRIX_3X2_F rotate = prev;\r\n\t\trotate.m12 += 1.0f / 0xFFFF;\r\n\t\trotate.m21 += 1.0f / 0xFFFF;\r\n\t\tThis->SetTransform(&rotate);\r\n\t\tORIG_D2D1RenderTarget1_DrawGlyphRun(\r\n\t\t\tThis,\r\n\t\t\tbaselineOrigin,\r\n\t\t\tglyphRun,\r\n\t\t\tforegroundBrush,\r\n\t\t\tmeasuringMode\r\n\t\t\t);\r\n\t\tThis->SetTransform(&prev);\r\n\t}\r\n\telse {\r\n\t\tORIG_D2D1RenderTarget1_DrawGlyphRun(\r\n\t\t\tThis,\r\n\t\t\tbaselineOrigin,\r\n\t\t\tglyphRun,\r\n\t\t\tforegroundBrush,\r\n\t\t\tmeasuringMode\r\n\t\t\t);\r\n\t}\r\n}\r\n\r\nvoid WINAPI IMPL_D2D1DeviceContext_DrawGlyphRun(\r\n\tID2D1DeviceContext* This,\r\n\tD2D1_POINT_2F baselineOrigin,\r\n\tCONST DWRITE_GLYPH_RUN *glyphRun,\r\n\tID2D1Brush *foregroundBrush,\r\n\tDWRITE_MEASURING_MODE measuringMode\r\n\t) {\r\n\tParams* dwParams = GetDWParams();\r\n\tif (dwParams->GridFitMode == DWRITE_GRID_FIT_MODE_DISABLED) {\r\n\t\tD2D1_MATRIX_3X2_F prev;\r\n\t\tThis->GetTransform(&prev);\r\n\t\tD2D1_MATRIX_3X2_F rotate = prev;\r\n\t\trotate.m12 += 1.0f / 0xFFFF;\r\n\t\trotate.m21 += 1.0f / 0xFFFF;\r\n\t\tThis->SetTransform(&rotate);\r\n\t\tORIG_D2D1DeviceContext_DrawGlyphRun(\r\n\t\t\tThis,\r\n\t\t\tbaselineOrigin,\r\n\t\t\tglyphRun,\r\n\t\t\tforegroundBrush,\r\n\t\t\tmeasuringMode\r\n\t\t\t);\r\n\t\tThis->SetTransform(&prev);\r\n\t}\r\n\telse {\r\n\t\tORIG_D2D1DeviceContext_DrawGlyphRun(\r\n\t\t\tThis,\r\n\t\t\tbaselineOrigin,\r\n\t\t\tglyphRun,\r\n\t\t\tforegroundBrush,\r\n\t\t\tmeasuringMode\r\n\t\t\t);\r\n\t}\r\n}\r\n\r\nHRESULT WINAPI IMPL_BitmapRenderTarget_DrawGlyphRun(\r\n\tIDWriteBitmapRenderTarget* This,\r\n\tFLOAT baselineOriginX,\r\n\tFLOAT baselineOriginY,\r\n\tDWRITE_MEASURING_MODE measuringMode,\r\n\tDWRITE_GLYPH_RUN const* glyphRun,\r\n\tIDWriteRenderingParams* renderingParams,\r\n\tCOLORREF textColor,\r\n\tRECT* blackBoxRect)\r\n{\r\n\tParams* dwParams = GetDWParams();\r\n\tHRESULT hr = E_FAIL;\r\n\tif (dwParams->GridFitMode == DWRITE_GRID_FIT_MODE_DISABLED) {\r\n\t\tDWRITE_MATRIX prev;\r\n\t\thr = This->GetCurrentTransform(&prev);\r\n\t\tif (SUCCEEDED(hr)) {\r\n\t\t\tDWRITE_MATRIX rotate = prev;\r\n\t\t\trotate.m12 += 1.0f / 0xFFFF;\r\n\t\t\trotate.m21 += 1.0f / 0xFFFF;\r\n\t\t\thr = This->SetCurrentTransform(&rotate);\r\n\t\t\tif (SUCCEEDED(hr)) {\r\n\t\t\t\thr = ORIG_BitmapRenderTarget_DrawGlyphRun(\r\n\t\t\t\t\tThis,\r\n\t\t\t\t\tbaselineOriginX,\r\n\t\t\t\t\tbaselineOriginY,\r\n\t\t\t\t\tmeasuringMode,\r\n\t\t\t\t\tglyphRun,\r\n\t\t\t\t\tGetDWRenderingParams(renderingParams),\r\n\t\t\t\t\ttextColor,\r\n\t\t\t\t\tblackBoxRect\r\n\t\t\t\t\t);\r\n\t\t\t\tThis->SetCurrentTransform(&prev);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (FAILED(hr)) {\r\n\t\thr = ORIG_BitmapRenderTarget_DrawGlyphRun(\r\n\t\t\tThis,\r\n\t\t\tbaselineOriginX,\r\n\t\t\tbaselineOriginY,\r\n\t\t\tmeasuringMode,\r\n\t\t\tglyphRun,\r\n\t\t\tGetDWRenderingParams(renderingParams),\r\n\t\t\ttextColor,\r\n\t\t\tblackBoxRect\r\n\t\t\t);\r\n\t\tif SUCCEEDED(hr) {\r\n\t\t\tMyDebug(L\"DrawGlyphRun hooked\");\r\n\t\t}\r\n\t}\r\n\tif (FAILED(hr)) {\r\n\t\thr = ORIG_BitmapRenderTarget_DrawGlyphRun(\r\n\t\t\tThis,\r\n\t\t\tbaselineOriginX,\r\n\t\t\tbaselineOriginY,\r\n\t\t\tmeasuringMode,\r\n\t\t\tglyphRun,\r\n\t\t\trenderingParams,\r\n\t\t\ttextColor,\r\n\t\t\tblackBoxRect\r\n\t\t\t);\r\n\t\tif SUCCEEDED(hr) {\r\n\t\t\tMyDebug(L\"DrawGlyphRun failed\");\r\n\t\t}\r\n\t}\r\n\tMyDebug(L\"DrawGlyphRun hooked\");\r\n\treturn hr;\r\n}\r\n\r\n\r\nvoid WINAPI IMPL_D2D1RenderTarget_DrawText(\r\n\tID2D1RenderTarget* This,\r\n\tCONST WCHAR *string,\r\n\tUINT32 stringLength,\r\n\tIDWriteTextFormat *textFormat,\r\n\tCONST D2D1_RECT_F *layoutRect,\r\n\tID2D1Brush *defaultForegroundBrush,\r\n\tD2D1_DRAW_TEXT_OPTIONS options,\r\n\tDWRITE_MEASURING_MODE measuringMode\r\n\t) {\r\n\tParams* dwParams = GetDWParams();\r\n\tif (dwParams->GridFitMode == DWRITE_GRID_FIT_MODE_DISABLED) {\r\n\t\tD2D1_MATRIX_3X2_F prev;\r\n\t\tThis->GetTransform(&prev);\r\n\t\tD2D1_MATRIX_3X2_F rotate = prev;\r\n\t\trotate.m12 += 1.0f / 0xFFFF;\r\n\t\trotate.m21 += 1.0f / 0xFFFF;\r\n\t\tThis->SetTransform(&rotate);\r\n\t\tORIG_D2D1RenderTarget_DrawText(\r\n\t\t\tThis,\r\n\t\t\tstring,\r\n\t\t\tstringLength,\r\n\t\t\ttextFormat,\r\n\t\t\tlayoutRect,\r\n\t\t\tdefaultForegroundBrush,\r\n\t\t\toptions,\r\n\t\t\tmeasuringMode\r\n\t\t\t);\r\n\t\tThis->SetTransform(&prev);\r\n\t}\r\n\telse {\r\n\t\tORIG_D2D1RenderTarget_DrawText(\r\n\t\t\tThis,\r\n\t\t\tstring,\r\n\t\t\tstringLength,\r\n\t\t\ttextFormat,\r\n\t\t\tlayoutRect,\r\n\t\t\tdefaultForegroundBrush,\r\n\t\t\toptions,\r\n\t\t\tmeasuringMode\r\n\t\t\t);\r\n\t}\r\n}\r\n\r\nvoid WINAPI IMPL_D2D1DeviceContext_DrawText(\r\n\tID2D1DeviceContext* This,\r\n\tCONST WCHAR *string,\r\n\tUINT32 stringLength,\r\n\tIDWriteTextFormat *textFormat,\r\n\tCONST D2D1_RECT_F *layoutRect,\r\n\tID2D1Brush *defaultForegroundBrush,\r\n\tD2D1_DRAW_TEXT_OPTIONS options,\r\n\tDWRITE_MEASURING_MODE measuringMode\r\n\t) {\r\n\tParams* dwParams = GetDWParams();\r\n\tif (dwParams->GridFitMode == DWRITE_GRID_FIT_MODE_DISABLED) {\r\n\t\tD2D1_MATRIX_3X2_F prev;\r\n\t\tThis->GetTransform(&prev);\r\n\t\tD2D1_MATRIX_3X2_F rotate = prev;\r\n\t\trotate.m12 += 1.0f / 0xFFFF;\r\n\t\trotate.m21 += 1.0f / 0xFFFF;\r\n\t\tThis->SetTransform(&rotate);\r\n\t\tORIG_D2D1DeviceContext_DrawText(\r\n\t\t\tThis,\r\n\t\t\tstring,\r\n\t\t\tstringLength,\r\n\t\t\ttextFormat,\r\n\t\t\tlayoutRect,\r\n\t\t\tdefaultForegroundBrush,\r\n\t\t\toptions,\r\n\t\t\tmeasuringMode\r\n\t\t\t);\r\n\t\tThis->SetTransform(&prev);\r\n\t}\r\n\telse {\r\n\t\tORIG_D2D1DeviceContext_DrawText(\r\n\t\t\tThis,\r\n\t\t\tstring,\r\n\t\t\tstringLength,\r\n\t\t\ttextFormat,\r\n\t\t\tlayoutRect,\r\n\t\t\tdefaultForegroundBrush,\r\n\t\t\toptions,\r\n\t\t\tmeasuringMode\r\n\t\t\t);\r\n\t}\r\n}\r\n\r\nvoid WINAPI IMPL_D2D1RenderTarget_DrawTextLayout(\r\n\tID2D1RenderTarget* This,\r\n\tD2D1_POINT_2F origin,\r\n\tIDWriteTextLayout *textLayout,\r\n\tID2D1Brush *defaultForegroundBrush,\r\n\tD2D1_DRAW_TEXT_OPTIONS options\r\n\t) {\r\n\tParams* dwParams = GetDWParams();\r\n\tif (dwParams->GridFitMode == DWRITE_GRID_FIT_MODE_DISABLED) {\r\n\t\tD2D1_MATRIX_3X2_F prev;\r\n\t\tThis->GetTransform(&prev);\r\n\t\tD2D1_MATRIX_3X2_F rotate = prev;\r\n\t\trotate.m12 += 1.0f / 0xFFFF;\r\n\t\trotate.m21 += 1.0f / 0xFFFF;\r\n\t\tThis->SetTransform(&rotate);\r\n\t\tORIG_D2D1RenderTarget_DrawTextLayout(\r\n\t\t\tThis,\r\n\t\t\torigin,\r\n\t\t\ttextLayout,\r\n\t\t\tdefaultForegroundBrush,\r\n\t\t\toptions\r\n\t\t\t);\r\n\t\tThis->SetTransform(&prev);\r\n\t}\r\n\telse {\r\n\t\tORIG_D2D1RenderTarget_DrawTextLayout(\r\n\t\t\tThis,\r\n\t\t\torigin,\r\n\t\t\ttextLayout,\r\n\t\t\tdefaultForegroundBrush,\r\n\t\t\toptions\r\n\t\t\t);\r\n\t}\r\n}\r\n"
        },
        {
          "name": "directwrite.h",
          "type": "blob",
          "size": 1.05859375,
          "content": "#include \"common.h\"\r\n#include <VersionHelpers.h>\r\n\r\n#pragma once\r\n\r\n#ifdef EASYHOOK\r\n\r\n#include \"easyhook.h\"\r\n#define HOOK_MANUALLY HOOK_DEFINE\r\n#define HOOK_DEFINE(rettype, name, argtype, arglist) \\\r\n\textern rettype(WINAPI * ORIG_##name) argtype;  \\\r\n\textern HOOK_TRACE_INFO HOOK_##name;\r\n#include \"hooklist.h\"\r\n#undef HOOK_DEFINE\r\n#undef HOOK_MANUALLY\r\n\r\n#define HOOK_MANUALLY(rettype, name, argtype, arglist) \\\r\n\textern LONG hook_demand_##name(bool bForce = false);\r\n#define HOOK_DEFINE(rettype, name, argtype, arglist) ;\r\n#include \"hooklist.h\"\r\n#undef HOOK_DEFINE\r\n#undef HOOK_MANUALLY\r\n\r\n#else\r\n\r\n#define HOOK_MANUALLY HOOK_DEFINE\r\n#define HOOK_DEFINE(rettype, name, argtype, arglist) \\\r\n\textern rettype(WINAPI * ORIG_##name) argtype;  \\\r\n\textern BOOL IsHooked_##name;\r\n#include \"hooklist.h\"\r\n#undef HOOK_DEFINE\r\n#undef HOOK_MANUALLY\r\n\r\n#define HOOK_MANUALLY(rettype, name, argtype, arglist) \\\r\n\textern LONG hook_demand_##name(bool bForce = false);\r\n#define HOOK_DEFINE(rettype, name, argtype, arglist) ;\r\n#include \"hooklist.h\"\r\n#undef HOOK_DEFINE\r\n#undef HOOK_MANUALLY\r\n\r\n#endif"
        },
        {
          "name": "dll.cpp",
          "type": "blob",
          "size": 12.982421875,
          "content": "#include \"dll.h\"\n\nCMemLoadDll::CMemLoadDll():m_bInitDllMain(true)\n{\n isLoadOk = FALSE;\n pImageBase = NULL;\n pDllMain = NULL;\n}\nCMemLoadDll::~CMemLoadDll()\n{\n if(isLoadOk)\n {\n  //ASSERT(pImageBase != NULL);\n  //ASSERT(pDllMain   != NULL);\n  //脱钩，准备卸载dll\n  if (m_bInitDllMain)\n\t pDllMain((HINSTANCE)pImageBase,DLL_PROCESS_DETACH,0);\n  VirtualFree((LPVOID)pImageBase, 0, MEM_RELEASE);\n }\n}\n\n//MemLoadLibrary函数从内存缓冲区数据中加载一个dll到当前进程的地址空间，缺省位置0x10000000\n//返回值： 成功返回TRUE , 失败返回FALSE\n//lpFileData: 存放dll文件数据的缓冲区\n//DataLength: 缓冲区中数据的总长度\nBOOL CMemLoadDll::MemLoadLibrary(void* lpFileData, int DataLength, bool bInitDllMain, bool bFreeOnRavFail)\n{\n this->m_bInitDllMain = bInitDllMain;\n if(pImageBase != NULL)\n {\n  return FALSE;  //已经加载一个dll，还没有释放，不能加载新的dll\n }\n //检查数据有效性，并初始化\n if(!CheckDataValide(lpFileData, DataLength))return FALSE;\n //计算所需的加载空间\n int ImageSize = CalcTotalImageSize();\n if(ImageSize == 0) return FALSE;\n\n // 分配虚拟内存\n void *pMemoryAddress = VirtualAlloc((LPVOID)0, ImageSize,\n     MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE);\n if(pMemoryAddress == NULL) return FALSE;\n else\n {\n  CopyDllDatas(pMemoryAddress, lpFileData); //复制dll数据，并对齐每个段\n  //重定位信息\n  /*if(pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress >0\n   && pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size>0)\n  {\n   DoRelocation(pMemoryAddress);\n  }\n  //填充引入地址表\n  if(!FillRavAddress(pMemoryAddress) && bFreeOnRavFail) //修正引入地址表失败\n  {\n   VirtualFree(pMemoryAddress,0,MEM_RELEASE);\n   return FALSE;\n  }*/\n  //修改页属性。应该根据每个页的属性单独设置其对应内存页的属性。这里简化一下。\n  //统一设置成一个属性PAGE_EXECUTE_READWRITE\n  unsigned long old;\n  VirtualProtect(pMemoryAddress, ImageSize, PAGE_EXECUTE_READWRITE,&old);\n }\n //修正基地址\n pNTHeader->OptionalHeader.ImageBase = (DWORD)pMemoryAddress;\n\n //接下来要调用一下dll的入口函数，做初始化工作。\n pDllMain = (ProcDllMain)(pNTHeader->OptionalHeader.AddressOfEntryPoint +(DWORD_PTR) pMemoryAddress);\n BOOL InitResult = !bInitDllMain || pDllMain((HINSTANCE)pMemoryAddress,DLL_PROCESS_ATTACH,0);\n if(!InitResult) //初始化失败\n {\n  pDllMain((HINSTANCE)pMemoryAddress,DLL_PROCESS_DETACH,0);\n  VirtualFree(pMemoryAddress,0,MEM_RELEASE);\n  pDllMain = NULL;\n  return FALSE;\n }\n\n isLoadOk = TRUE;\n pImageBase = (DWORD_PTR)pMemoryAddress;\n return TRUE;\n}\n\n//MemGetProcAddress函数从dll中获取指定函数的地址\n//返回值： 成功返回函数地址 , 失败返回NULL\n//lpProcName: 要查找函数的名字或者序号\nFARPROC  CMemLoadDll::MemGetProcAddress(LPCSTR lpProcName)\n{\n if(pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress == 0 ||\n  pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size == 0)\n  return NULL;\n if(!isLoadOk) return NULL;\n\n DWORD OffsetStart = pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;\n DWORD Size = pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;\n\n PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)pImageBase + pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);\n DWORD iBase = pExport->Base;\n DWORD iNumberOfFunctions = pExport->NumberOfFunctions;\n DWORD iNumberOfNames = pExport->NumberOfNames; //<= iNumberOfFunctions\n LPDWORD pAddressOfFunctions = (LPDWORD)(pExport->AddressOfFunctions + pImageBase);\n LPWORD  pAddressOfOrdinals = (LPWORD)(pExport->AddressOfNameOrdinals + pImageBase);\n LPDWORD pAddressOfNames  = (LPDWORD)(pExport->AddressOfNames + pImageBase);\n\n int iOrdinal = -1;\n\n if(((DWORD)lpProcName & 0xFFFF0000) == 0) //IT IS A ORDINAL!\n {\n  iOrdinal = (DWORD)lpProcName & 0x0000FFFF - iBase;\n }\n else  //use name\n {\n  int iFound = -1;\n\n  for(int i=0;i<iNumberOfNames;i++)\n  {\n   char* pName= (char* )(pAddressOfNames[i] + pImageBase);\n   if(strcmp(pName, lpProcName) == 0)\n   {\n    iFound = i; break;\n   }\n  }\n  if(iFound >= 0)\n  {\n   iOrdinal = (DWORD)(pAddressOfOrdinals[iFound]);\n  }\n }\n\n if(iOrdinal < 0 || iOrdinal >= iNumberOfFunctions ) return NULL;\n else\n {\n  DWORD pFunctionOffset = pAddressOfFunctions[iOrdinal];\n  if(pFunctionOffset > OffsetStart && pFunctionOffset < (OffsetStart+Size))//maybe Export Forwarding\n   return NULL;\n  else return (FARPROC)(pFunctionOffset + pImageBase);\n }\n\n}\n\n\n// 重定向PE用到的地址\nvoid CMemLoadDll::DoRelocation( void *NewBase)\n{\n /* 重定位表的结构：\n // DWORD sectionAddress, DWORD size (包括本节需要重定位的数据)\n // 例如 1000节需要修正5个重定位数据的话，重定位表的数据是\n // 00 10 00 00   14 00 00 00      xxxx xxxx xxxx xxxx xxxx 0000\n // -----------   -----------      ----\n // 给出节的偏移  总尺寸=8+6*2     需要修正的地址           用于对齐4字节\n // 重定位表是若干个相连，如果address 和 size都是0 表示结束\n // 需要修正的地址是12位的，高4位是形态字，intel cpu下是3\n */\n //假设NewBase是0x600000,而文件中设置的缺省ImageBase是0x400000,则修正偏移量就是0x200000\n DWORD Delta = (DWORD)NewBase - pNTHeader->OptionalHeader.ImageBase;\n\n //注意重定位表的位置可能和硬盘文件中的偏移地址不同，应该使用加载后的地址\n PIMAGE_BASE_RELOCATION pLoc = (PIMAGE_BASE_RELOCATION)((DWORD_PTR)NewBase\n  + pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);\n while((pLoc->VirtualAddress + pLoc->SizeOfBlock) != 0) //开始扫描重定位表\n {\n  WORD *pLocData = (WORD *)((DWORD_PTR)pLoc + sizeof(IMAGE_BASE_RELOCATION));\n  //计算本节需要修正的重定位项（地址）的数目\n  int NumberOfReloc = (pLoc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION))/sizeof(WORD);\n  for( int i=0 ; i < NumberOfReloc; i++)\n  {\n   if( (DWORD)(pLocData[i] & 0xF000) == 0x00003000) //这是一个需要修正的地址\n   {\n    // 举例：\n    // pLoc->VirtualAddress = 0x1000;\n    // pLocData[i] = 0x313E; 表示本节偏移地址0x13E处需要修正\n    // 因此 pAddress = 基地址 + 0x113E\n    // 里面的内容是 A1 ( 0c d4 02 10)  汇编代码是： mov eax , [1002d40c]\n    // 需要修正1002d40c这个地址\n    DWORD * pAddress = (DWORD *)((DWORD_PTR)NewBase + pLoc->VirtualAddress + (pLocData[i] & 0x0FFF));\n    *pAddress += Delta;\n   }\n  }\n  //转移到下一个节进行处理\n  pLoc = (PIMAGE_BASE_RELOCATION)((DWORD)pLoc + pLoc->SizeOfBlock);\n }\n}\n\n//填充引入地址表\nBOOL CMemLoadDll::FillRavAddress(void *pImageBase)\n{\n // 引入表实际上是一个 IMAGE_IMPORT_DESCRIPTOR 结构数组，全部是0表示结束\n // 数组定义如下：\n //\n    // DWORD   OriginalFirstThunk;         // 0表示结束，否则指向未绑定的IAT结构数组\n    // DWORD   TimeDateStamp;\n    // DWORD   ForwarderChain;             // -1 if no forwarders\n    // DWORD   Name;                       // 给出dll的名字\n    // DWORD   FirstThunk;                 // 指向IAT结构数组的地址(绑定后，这些IAT里面就是实际的函数地址)\n unsigned long Offset = pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress ;\n if(Offset == 0) return TRUE; //No Import Table\n PIMAGE_IMPORT_DESCRIPTOR pID = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD_PTR) pImageBase + Offset);\n while(pID->Characteristics != 0 )\n {\n  PIMAGE_THUNK_DATA32 pRealIAT = (PIMAGE_THUNK_DATA32)((DWORD_PTR)pImageBase + pID->FirstThunk);\n  PIMAGE_THUNK_DATA32 pOriginalIAT = (PIMAGE_THUNK_DATA32)((DWORD_PTR)pImageBase + pID->OriginalFirstThunk);\n  //获取dll的名字\n  WCHAR buf[256]; //dll name;\n  BYTE* pName = (BYTE*)((DWORD_PTR)pImageBase + pID->Name);\n  int i;\n  for(i=0;i<256;i++)\n  {\n   if(pName[i] == 0)break;\n   buf[i] = pName[i];\n  }\n  if(i>=256) return FALSE;  // bad dll name\n  else buf[i] = 0;\n  HMODULE hDll = GetModuleHandle(buf);\n  if(hDll == NULL)return FALSE; //NOT FOUND DLL\n  //获取DLL中每个导出函数的地址，填入IAT\n  //每个IAT结构是 ：\n  // union { PBYTE  ForwarderString;\n        //   PDWORD Function;\n        //   DWORD Ordinal;\n        //   PIMAGE_IMPORT_BY_NAME  AddressOfData;\n  // } u1;\n  // 长度是一个DWORD ，正好容纳一个地址。\n  for(i=0; ;i++)\n  {\n   if(pOriginalIAT[i].u1.Function == 0)break;\n   FARPROC lpFunction = NULL;\n   if(pOriginalIAT[i].u1.Ordinal & IMAGE_ORDINAL_FLAG) //这里的值给出的是导出序号\n   {\n    lpFunction = GetProcAddress(hDll, (LPCSTR)(pOriginalIAT[i].u1.Ordinal & 0x0000FFFF));\n   }\n   else //按照名字导入\n   {\n    //获取此IAT项所描述的函数名称\n    PIMAGE_IMPORT_BY_NAME pByName = (PIMAGE_IMPORT_BY_NAME)\n     ((DWORD_PTR)pImageBase + (DWORD)(pOriginalIAT[i].u1.AddressOfData));\n//    if(pByName->Hint !=0)\n//     lpFunction = GetProcAddress(hDll, (LPCSTR)pByName->Hint);\n//    else\n     lpFunction = GetProcAddress(hDll, (char *)pByName->Name);\n   }\n   if(lpFunction != NULL)   //找到了！\n   {\n    pRealIAT[i].u1.Function = (DWORD) lpFunction;\n   }\n   else return FALSE;\n  }\n\n  //move to next\n  pID = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD_PTR)pID + sizeof(IMAGE_IMPORT_DESCRIPTOR));\n }\n return TRUE;\n}\n\n//CheckDataValide函数用于检查缓冲区中的数据是否有效的dll文件\n//返回值： 是一个可执行的dll则返回TRUE，否则返回FALSE。\n//lpFileData: 存放dll数据的内存缓冲区\n//DataLength: dll文件的长度\nBOOL CMemLoadDll::CheckDataValide(void* lpFileData, int DataLength)\n{\n //检查长度\n if(DataLength < sizeof(IMAGE_DOS_HEADER)) return FALSE;\n pDosHeader = (PIMAGE_DOS_HEADER)lpFileData;  // DOSͷ\n //检查dos头的标记\n if(pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) return FALSE;  //0x5A4D : MZ\n\n //检查长度\n if((DWORD)DataLength < (pDosHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS32)) ) return FALSE;\n //取得pe头\n pNTHeader = (PIMAGE_NT_HEADERS32)( (DWORD_PTR)lpFileData + (DWORD_PTR)pDosHeader->e_lfanew); // PEͷ\n //检查pe头的合法性\n if(pNTHeader->Signature != IMAGE_NT_SIGNATURE) return FALSE;  //0x00004550 : PE00\n if((pNTHeader->FileHeader.Characteristics & IMAGE_FILE_DLL) == 0) //0x2000  : File is a DLL\n  return FALSE; \n if((pNTHeader->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0) //0x0002 : 指出文件可以运行\n  return FALSE;\n if(pNTHeader->FileHeader.SizeOfOptionalHeader != sizeof(IMAGE_OPTIONAL_HEADER32)) return FALSE;\n\n \n //取得节表（段表）\n pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNTHeader + sizeof(IMAGE_NT_HEADERS32));\n //验证每个节表的空间\n for(int i=0; i< pNTHeader->FileHeader.NumberOfSections; i++)\n {\n  if((pSectionHeader[i].PointerToRawData + pSectionHeader[i].SizeOfRawData) > (DWORD)DataLength)return FALSE;\n }\n return TRUE;\n}\n\n//计算对齐边界\nint CMemLoadDll::GetAlignedSize(int Origin, int Alignment)\n{\n return (Origin + Alignment - 1) / Alignment * Alignment;\n}\n//计算整个dll映像文件的尺寸\nint CMemLoadDll::CalcTotalImageSize()\n{\n int Size;\n if(pNTHeader == NULL)return 0;\n int nAlign = pNTHeader->OptionalHeader.SectionAlignment; //段对齐字节数\n\n // 计算所有头的尺寸。包括dos, coff, pe头 和 段表的大小\n Size = GetAlignedSize(pNTHeader->OptionalHeader.SizeOfHeaders, nAlign);\n // 计算所有节的大小\n for(int i=0; i < pNTHeader->FileHeader.NumberOfSections; ++i)\n {\n  //得到该节的大小\n  int CodeSize = pSectionHeader[i].Misc.VirtualSize ;\n  int LoadSize = pSectionHeader[i].SizeOfRawData;\n  int MaxSize = (LoadSize > CodeSize)?(LoadSize):(CodeSize);\n\n  int SectionSize = GetAlignedSize(pSectionHeader[i].VirtualAddress + MaxSize, nAlign);\n  if(Size < SectionSize)\n   Size = SectionSize;  //Use the Max;\n }\n return Size;\n}\n//CopyDllDatas函数将dll数据复制到指定内存区域，并对齐所有节\n//pSrc: 存放dll数据的原始缓冲区\n//pDest:目标内存地址\nvoid CMemLoadDll::CopyDllDatas(void* pDest, void* pSrc)\n{\n // 计算需要复制的PE头+段表字节数\n int  HeaderSize = pNTHeader->OptionalHeader.SizeOfHeaders;\n int  SectionSize = pNTHeader->FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER);\n int  MoveSize = HeaderSize + SectionSize;\n //复制头和段信息\n memmove(pDest, pSrc, MoveSize);\n\n //复制每个节\n for(int i=0; i < pNTHeader->FileHeader.NumberOfSections; ++i)\n {\n  if(pSectionHeader[i].VirtualAddress == 0 || pSectionHeader[i].SizeOfRawData == 0)continue;\n  // 定位该节在内存中的位置\n  void *pSectionAddress = (void *)((DWORD_PTR)pDest + pSectionHeader[i].VirtualAddress);\n  // 复制段数据到虚拟内存\n  memmove((void *)pSectionAddress,\n       (void *)((DWORD_PTR)pSrc + pSectionHeader[i].PointerToRawData),\n    pSectionHeader[i].SizeOfRawData);\n }\n\n //修正指针，指向新分配的内存\n //新的dos头\n pDosHeader = (PIMAGE_DOS_HEADER)pDest;\n //新的pe头地址\n pNTHeader = (PIMAGE_NT_HEADERS32)((DWORD_PTR)pDest + (DWORD_PTR)(pDosHeader->e_lfanew));\n //新的节表地址\n pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNTHeader + sizeof(IMAGE_NT_HEADERS32));\n return ;\n}\n"
        },
        {
          "name": "dll.h",
          "type": "blob",
          "size": 0.8251953125,
          "content": "#include <windows.h>\n\ntypedef   BOOL (__stdcall *ProcDllMain)(HINSTANCE, DWORD,  LPVOID );\n\nclass CMemLoadDll\n{\npublic:\n\tCMemLoadDll();\n\t~CMemLoadDll();\n\tBOOL    MemLoadLibrary( void* lpFileData , int DataLength, bool bInitDllMain, bool bFreeOnRavFail);  // Dll file data buffer\n\tFARPROC MemGetProcAddress(LPCSTR lpProcName);\n\tDWORD_PTR\tGetImageBase() {return pImageBase;};\nprivate:\n\tBOOL isLoadOk;\n\tBOOL CheckDataValide(void* lpFileData, int DataLength);\n\tint  CalcTotalImageSize();\n\tvoid CopyDllDatas(void* pDest, void* pSrc);\n\tBOOL FillRavAddress(void* pBase);\n\tvoid DoRelocation(void* pNewBase);\n\tint  GetAlignedSize(int Origin, int Alignment);\nprivate:\n\tProcDllMain pDllMain;\n\n\nprivate:\n\tDWORD_PTR  pImageBase;\n\tbool   m_bInitDllMain;\n\tPIMAGE_DOS_HEADER pDosHeader;\n\tPIMAGE_NT_HEADERS32 pNTHeader;\n\tPIMAGE_SECTION_HEADER pSectionHeader;\n};\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "dynCodeHelper.cpp",
          "type": "blob",
          "size": 3.328125,
          "content": "#include \"dynCodeHelper.h\"\r\n\r\n/*\r\n* class AutoEnableDynamicCodeGen\r\n*/\r\n\r\ntypedef\r\nBOOL\r\n(WINAPI *PGET_PROCESS_MITIGATION_POLICY_PROC)(\r\n_In_  HANDLE                    hProcess,\r\n_In_  PROCESS_MITIGATION_POLICY MitigationPolicy,\r\n_Out_ PVOID                     lpBuffer,\r\n_In_  SIZE_T                    dwLength\r\n);\r\n\r\nAutoEnableDynamicCodeGen::PSET_THREAD_INFORMATION_PROC AutoEnableDynamicCodeGen::SetThreadInformationProc = nullptr;\r\nAutoEnableDynamicCodeGen::PGET_THREAD_INFORMATION_PROC AutoEnableDynamicCodeGen::GetThreadInformationProc = nullptr;\r\nPROCESS_MITIGATION_DYNAMIC_CODE_POLICY AutoEnableDynamicCodeGen::processPolicy;\r\nvolatile bool AutoEnableDynamicCodeGen::processPolicyObtained = false;\r\n\r\nAutoEnableDynamicCodeGen::AutoEnableDynamicCodeGen(bool enable) : enabled(false)\r\n{\r\n\tif (enable == false)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\t//\r\n\t// Snap the dynamic code generation policy for this process so that we\r\n\t// don't need to resolve APIs and query it each time. We expect the policy\r\n\t// to have been established upfront.\r\n\t//\r\n\r\n\tif (processPolicyObtained == false)\r\n\t{\r\n\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_VIRTMEM);\r\n\r\n\t\tif (processPolicyObtained == false)\r\n\t\t{\r\n\t\t\tPGET_PROCESS_MITIGATION_POLICY_PROC GetProcessMitigationPolicyProc = nullptr;\r\n\r\n\t\t\tHMODULE module = GetModuleHandleW(_T(\"api-ms-win-core-processthreads-l1-1-3.dll\"));\r\n\r\n\t\t\tif (module != nullptr)\r\n\t\t\t{\r\n\t\t\t\tGetProcessMitigationPolicyProc = (PGET_PROCESS_MITIGATION_POLICY_PROC)GetProcAddress(module, \"GetProcessMitigationPolicy\");\r\n\t\t\t\tSetThreadInformationProc = (PSET_THREAD_INFORMATION_PROC)GetProcAddress(module, \"SetThreadInformation\");\r\n\t\t\t\tGetThreadInformationProc = (PGET_THREAD_INFORMATION_PROC)GetProcAddress(module, \"GetThreadInformation\");\r\n\t\t\t}\r\n\r\n\t\t\tif ((GetProcessMitigationPolicyProc == nullptr) ||\r\n\t\t\t\t(!GetProcessMitigationPolicyProc(GetCurrentProcess(), ProcessDynamicCodePolicy, (PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY)&processPolicy, sizeof(processPolicy))))\r\n\t\t\t{\r\n\t\t\t\tprocessPolicy.ProhibitDynamicCode = 0;\r\n\t\t\t}\r\n\r\n\t\t\tprocessPolicyObtained = true;\r\n\t\t}\r\n\t}\r\n\r\n\t//\r\n\t// The process is not prohibiting dynamic code or does not allow threads\r\n\t// to opt out.  In either case, return to the caller.\r\n\t//\r\n\t// N.B. It is OK that this policy is mutable at runtime. If a process\r\n\t//      really does not allow thread opt-out, then the call below will fail\r\n\t//      benignly.\r\n\t//\r\n\r\n\tif ((processPolicy.ProhibitDynamicCode == 0) || (processPolicy.AllowThreadOptOut == 0))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (SetThreadInformationProc == nullptr || GetThreadInformationProc == nullptr)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\t// \r\n\t// If dynamic code is already allowed for this thread, then don't attempt to allow it again.\r\n\t//\r\n\r\n\tDWORD threadPolicy;\r\n\r\n\tif ((GetThreadInformationProc(GetCurrentThread(), ThreadDynamicCodePolicy, &threadPolicy, sizeof(DWORD))) &&\r\n\t\t(threadPolicy == THREAD_DYNAMIC_CODE_ALLOW))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tthreadPolicy = THREAD_DYNAMIC_CODE_ALLOW;\r\n\r\n\tBOOL result = SetThreadInformationProc(GetCurrentThread(), ThreadDynamicCodePolicy, &threadPolicy, sizeof(DWORD));\r\n\tAssert(result);\r\n\r\n\tenabled = true;\r\n}\r\n\r\nAutoEnableDynamicCodeGen::~AutoEnableDynamicCodeGen()\r\n{\r\n\tif (enabled)\r\n\t{\r\n\t\tDWORD threadPolicy = 0;\r\n\r\n\t\tBOOL result = SetThreadInformationProc(GetCurrentThread(), ThreadDynamicCodePolicy, &threadPolicy, sizeof(DWORD));\r\n\t\tAssert(result);\r\n\r\n\t\tenabled = false;\r\n\t}\r\n}\r\n"
        },
        {
          "name": "dynCodeHelper.h",
          "type": "blob",
          "size": 0.9775390625,
          "content": "#include \"common.h\"\r\n\r\nclass AutoEnableDynamicCodeGen\r\n{\r\npublic:\r\n\tAutoEnableDynamicCodeGen(bool enable = true);\r\n\t~AutoEnableDynamicCodeGen();\r\n\r\nprivate:\r\n\tbool enabled;\r\n\r\n\ttypedef\r\n\t\tBOOL\r\n\t\t(WINAPI *PSET_THREAD_INFORMATION_PROC)(\r\n\t\t_In_ HANDLE                   hThread,\r\n\t\t_In_ THREAD_INFORMATION_CLASS ThreadInformationClass,\r\n\t\t_In_reads_bytes_(ThreadInformationSize) PVOID ThreadInformation,\r\n\t\t_In_ DWORD                    ThreadInformationSize\r\n\t\t);\r\n\r\n\ttypedef\r\n\t\tBOOL\r\n\t\t(WINAPI *PGET_THREAD_INFORMATION_PROC)(\r\n\t\t_In_ HANDLE                   hThread,\r\n\t\t_In_ THREAD_INFORMATION_CLASS ThreadInformationClass,\r\n\t\t_Out_writes_bytes_(ThreadInformationSize) PVOID ThreadInformation,\r\n\t\t_In_ DWORD                    ThreadInformationSize\r\n\t\t);\r\n\r\n\tstatic PSET_THREAD_INFORMATION_PROC SetThreadInformationProc;\r\n\tstatic PGET_THREAD_INFORMATION_PROC GetThreadInformationProc;\r\n\tstatic PROCESS_MITIGATION_DYNAMIC_CODE_POLICY processPolicy;\r\n\tstatic volatile bool processPolicyObtained;\r\n};\r\n"
        },
        {
          "name": "easyhook.h",
          "type": "blob",
          "size": 12.037109375,
          "content": "/*\n    EasyHook - The reinvention of Windows API hooking\n \n    Copyright (C) 2009 Christoph Husse\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n    Please visit http://www.codeplex.com/easyhook for more information\n    about the project and latest updates.\n*/\n\n#ifndef _EASYHOOK_H_\n#define _EASYHOOK_H_\n\n#ifdef DRIVER\n\n    #include <ntddk.h>\n    #include <ntstrsafe.h>\n\n\ttypedef int BOOL;\n\ttypedef void* HMODULE;\n\n#else\n\n//    #define NTDDI_VERSION           NTDDI_WIN2KSP4\n  //  #define _WIN32_WINNT            0x500\n    #define _WIN32_IE_              _WIN32_IE_WIN2KSP4\n\n    #include <windows.h>\n    #include <winnt.h>\n    #include <winternl.h>\n\n#endif\n\n\n#ifdef __cplusplus\nextern \"C\"{\n#endif\n\n#ifdef EASYHOOK_EXPORTS\n    #define EASYHOOK_API\t\t\t\t\t\t__declspec(dllexport) __stdcall\n\t#define DRIVER_SHARED_API(type, decl)\t\tEXTERN_C type EASYHOOK_API decl\n#else\n    #ifndef DRIVER\n\t\t#ifdef STATIC_LIB \n\t\t\t#define EASYHOOK_API\t\t\t\t\t__stdcall\n\t\t#else\n\t\t\t#define EASYHOOK_API\t\t\t\t\t__declspec(dllimport) __stdcall\n\t\t#endif\n\t\t#define DRIVER_SHARED_API(type, decl)\tEXTERN_C type EASYHOOK_API decl\n    #else\n        #define EASYHOOK_API\t\t\t\t\t__stdcall\n\t\t#define DRIVER_SHARED_API(type, decl)\ttypedef type EASYHOOK_API PROC_##decl; EXTERN_C type EASYHOOK_API decl\n    #endif\n#endif\n\n/* \n    This is the typical sign that a defined method is exported...\n\n    Methods marked with this attribute need special attention\n    during parameter validation and documentation.\n*/\n#define EASYHOOK_NT_EXPORT          EXTERN_C NTSTATUS EASYHOOK_API\n#define EASYHOOK_BOOL_EXPORT        EXTERN_C BOOL EASYHOOK_API\n\n#define MAX_HOOK_COUNT              128\n#define MAX_ACE_COUNT               128\n#define MAX_THREAD_COUNT            128\n#define MAX_PASSTHRU_SIZE           1024 * 64\n\ntypedef struct _HOOK_ACL_\n{\n\tULONG                   Count;\n\tBOOL                    IsExclusive;\n\tULONG                   Entries[MAX_ACE_COUNT];\n}HOOK_ACL;\n\ntypedef struct _LOCAL_HOOK_INFO_* PLOCAL_HOOK_INFO;\n\ntypedef struct _HOOK_TRACE_INFO_\n{\n    PLOCAL_HOOK_INFO        Link;\n}HOOK_TRACE_INFO, *TRACED_HOOK_HANDLE;\n\ntypedef struct _LOCAL_HOOK_INFO_\n{\n\tPLOCAL_HOOK_INFO        Next;\n\tULONG\t\t\t\t\tNativeSize;\n\tUCHAR*\t\t\t\t\tTargetProc;\n\tULONGLONG\t\t\t\tTargetBackup;\n\tULONGLONG\t\t\t\tTargetBackup_x64;\n\tULONGLONG\t\t\t\tHookCopy;\n\tULONG\t\t\t\t\tEntrySize;\n\tUCHAR*\t\t\t\t\tTrampoline;\n\tULONG\t\t\t\t\tHLSIndex;\n\tULONG\t\t\t\t\tHLSIdent;\n\tvoid*\t\t\t\t\tCallback;\n\tHOOK_ACL\t\t\t\tLocalACL;\n\tULONG                   Signature;\n\tTRACED_HOOK_HANDLE      Tracking;\n\n\tvoid*\t\t\t\t\tRandomValue; // fixed\n\tvoid*\t\t\t\t\tHookIntro; // fixed\n\tUCHAR*\t\t\t\t\tOldProc; // fixed\n\tUCHAR*\t\t\t\t\tHookProc; // fixed\n\tvoid*\t\t\t\t\tHookOutro; // fixed\n\tint*\t\t\t\t\tIsExecutedPtr; // fixed\n}LOCAL_HOOK_INFO, *PLOCAL_HOOK_INFO;\n\nDRIVER_SHARED_API(NTSTATUS, RtlGetLastError());\n\nDRIVER_SHARED_API(PWCHAR, RtlGetLastErrorString());\n\nDRIVER_SHARED_API(NTSTATUS, LhInstallHook(\n            void* InEntryPoint,\n            void* InHookProc,\n            void* InCallback,\n            TRACED_HOOK_HANDLE OutHandle));\n\nDRIVER_SHARED_API(NTSTATUS, LhUninstallAllHooks());\n\nDRIVER_SHARED_API(NTSTATUS, LhUninstallHook(TRACED_HOOK_HANDLE InHandle));\n\nDRIVER_SHARED_API(NTSTATUS, LhWaitForPendingRemovals());\n\n#ifdef STATIC_LIB\nBOOL APIENTRY EasyHookDllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved);\n#endif\n\n/*\n    Setup the ACLs after hook installation. Please note that every\n    hook starts suspended. You will have to set a proper ACL to\n    make it active!\n*/\n#ifdef DRIVER\n\n\tDRIVER_SHARED_API(NTSTATUS, LhSetInclusiveACL(\n\t\t\t\tULONG* InProcessIdList,\n\t\t\t\tULONG InProcessCount,\n\t\t\t\tTRACED_HOOK_HANDLE InHandle));\n\n\tDRIVER_SHARED_API(NTSTATUS, LhSetExclusiveACL(\n\t\t\t\tULONG* InProcessIdList,\n\t\t\t\tULONG InProcessCount,\n\t\t\t\tTRACED_HOOK_HANDLE InHandle));\n\n\tDRIVER_SHARED_API(NTSTATUS, LhSetGlobalInclusiveACL(\n\t\t\t\tULONG* InProcessIdList,\n\t\t\t\tULONG InProcessCount));\n\n\tDRIVER_SHARED_API(NTSTATUS, LhSetGlobalExclusiveACL(\n\t\t\t\tULONG* InProcessIdList,\n\t\t\t\tULONG InProcessCount));\n\n\tDRIVER_SHARED_API(NTSTATUS, LhIsProcessIntercepted(\n\t\t\t\tTRACED_HOOK_HANDLE InHook,\n\t\t\t\tULONG InProcessID,\n\t\t\t\tBOOL* OutResult));\n\n#else\n\n\tEASYHOOK_NT_EXPORT LhSetInclusiveACL(\n\t\t\t\tULONG* InThreadIdList,\n\t\t\t\tULONG InThreadCount,\n\t\t\t\tTRACED_HOOK_HANDLE InHandle);\n\n\tEASYHOOK_NT_EXPORT LhSetExclusiveACL(\n\t\t\t\tULONG* InThreadIdList,\n\t\t\t\tULONG InThreadCount,\n\t\t\t\tTRACED_HOOK_HANDLE InHandle);\n\n\tEASYHOOK_NT_EXPORT LhSetGlobalInclusiveACL(\n\t\t\t\tULONG* InThreadIdList,\n\t\t\t\tULONG InThreadCount);\n\n\tEASYHOOK_NT_EXPORT LhSetGlobalExclusiveACL(\n\t\t\t\tULONG* InThreadIdList,\n\t\t\t\tULONG InThreadCount);\n\n\tEASYHOOK_NT_EXPORT LhIsThreadIntercepted(\n\t\t\t\tTRACED_HOOK_HANDLE InHook,\n\t\t\t\tULONG InThreadID,\n\t\t\t\tBOOL* OutResult);\n\n#endif // !DRIVER\n\n/*\n    The following barrier methods are meant to be used in hook handlers only!\n\n    They will all fail with STATUS_NOT_SUPPORTED if called outside a\n    valid hook handler...\n*/\nDRIVER_SHARED_API(NTSTATUS, LhBarrierGetCallback(PVOID* OutValue));\n\nDRIVER_SHARED_API(NTSTATUS, LhBarrierGetReturnAddress(PVOID* OutValue));\n\nDRIVER_SHARED_API(NTSTATUS, LhBarrierGetAddressOfReturnAddress(PVOID** OutValue));\n\nDRIVER_SHARED_API(NTSTATUS, LhBarrierBeginStackTrace(PVOID* OutBackup));\n\nDRIVER_SHARED_API(NTSTATUS, LhBarrierEndStackTrace(PVOID InBackup));\n\ntypedef struct _MODULE_INFORMATION_* PMODULE_INFORMATION;\n\ntypedef struct _MODULE_INFORMATION_\n{\t\n\tPMODULE_INFORMATION\t\tNext;\n\tUCHAR*\t\t\t\t\tBaseAddress;\n\tULONG\t\t\t\t\tImageSize;\n\tCHAR\t\t\t\t\tPath[256];\n\tPCHAR\t\t\t\t\tModuleName;\n}MODULE_INFORMATION;\n\nEASYHOOK_NT_EXPORT LhUpdateModuleInformation();\n\nDRIVER_SHARED_API(NTSTATUS, LhBarrierPointerToModule(\n\t\t\tPVOID InPointer,\n\t\t\tMODULE_INFORMATION* OutModule));\n\nDRIVER_SHARED_API(NTSTATUS, LhEnumModules(\n\t\t\tHMODULE* OutModuleArray, \n            ULONG InMaxModuleCount,\n            ULONG* OutModuleCount));\n\nDRIVER_SHARED_API(NTSTATUS, LhBarrierGetCallingModule(MODULE_INFORMATION* OutModule));\n\nDRIVER_SHARED_API(NTSTATUS, LhBarrierCallStackTrace(\n            PVOID* OutMethodArray, \n            ULONG InMaxMethodCount,\n            ULONG* OutMethodCount));\n\n#ifdef DRIVER\n\n\t#define DRIVER_EXPORT(proc)\t\t\t\tPROC_##proc * proc\n\n\t#define EASYHOOK_INTERFACE_v_1\t\t\t0x0001\n\n\t#define EASYHOOK_WIN32_DEVICE_NAME\t\tL\"\\\\\\\\.\\\\EasyHook\"\n\t#define EASYHOOK_DEVICE_NAME\t\t\tL\"\\\\Device\\\\EasyHook\"\n\t#define EASYHOOK_DOS_DEVICE_NAME\t\tL\"\\\\DosDevices\\\\EasyHook\"\n\t#define FILE_DEVICE_EASYHOOK\t\t\t0x893F\n\n\ttypedef struct _EASYHOOK_INTERFACE_API_v_1_\n\t{\n\t\tDRIVER_EXPORT(RtlGetLastError);\n\t\tDRIVER_EXPORT(RtlGetLastErrorString);\n\t\tDRIVER_EXPORT(LhInstallHook);\n\t\tDRIVER_EXPORT(LhUninstallHook);\n\t\tDRIVER_EXPORT(LhWaitForPendingRemovals);\n\t\tDRIVER_EXPORT(LhBarrierGetCallback);\n\t\tDRIVER_EXPORT(LhBarrierGetReturnAddress);\n\t\tDRIVER_EXPORT(LhBarrierGetAddressOfReturnAddress);\n\t\tDRIVER_EXPORT(LhBarrierBeginStackTrace);\n\t\tDRIVER_EXPORT(LhBarrierEndStackTrace);\n\t\tDRIVER_EXPORT(LhBarrierPointerToModule);\n\t\tDRIVER_EXPORT(LhBarrierGetCallingModule);\n\t\tDRIVER_EXPORT(LhBarrierCallStackTrace);\n\t\tDRIVER_EXPORT(LhSetGlobalExclusiveACL);\n\t\tDRIVER_EXPORT(LhSetGlobalInclusiveACL);\n\t\tDRIVER_EXPORT(LhSetExclusiveACL);\n\t\tDRIVER_EXPORT(LhSetInclusiveACL);\n\t\tDRIVER_EXPORT(LhIsProcessIntercepted);\n\t}EASYHOOK_INTERFACE_API_v_1, *PEASYHOOK_INTERFACE_API_v_1;\n\n\ttypedef struct _EASYHOOK_DEVICE_EXTENSION_\n\t{\n\t\tULONG\t\t\t\t\t\t\t\tMaxVersion;\n\t\t// enumeration of APIs\n\t\tEASYHOOK_INTERFACE_API_v_1\t\t\tAPI_v_1;\n\t}EASYHOOK_DEVICE_EXTENSION, *PEASYHOOK_DEVICE_EXTENSION;\n\n\tstatic NTSTATUS EasyHookQueryInterface(\n\t\tULONG InInterfaceVersion,\n\t\tPVOID OutInterface,\n\t\tPFILE_OBJECT* OutEasyHookDrv)\n\t{\n\t/*\n\t\tDescription:\n\t\t\t\n\t\t\tProvides a convenient way to load the desired EasyHook interface.\n\t\t\tThe method will only work if the EasyHook support driver is loaded, of course.\n\t\t\tIf you don't need the interface anymore, you have to release the\n\t\t\tfile object with ObDereferenceObject().\n\n\t\tParameters:\n\t\t\t\n\t\t\t- InInterfaceVersion\n\n\t\t\t\tThe desired interface version. Any future EasyHook driver will ALWAYS\n\t\t\t\tbe backward compatible. This is the reason why I provide such a flexible\n\t\t\t\tinterface mechanism. \n\n\t\t\t- OutInterface\n\n\t\t\t\tA pointer to the interface structure to be filled with data. If you specify\n\t\t\t\tEASYHOOK_INTERFACE_v_1 as InInterfaceVersion, you will have to provide a\n\t\t\t\tpointer to a EASYHOOK_INTERFACE_API_v_1 structure, for example...\n\n\t\t\t- OutEasyHookDrv\n\n\t\t\t\tA reference to the EasyHook driver. Make sure that you dereference it if\n\t\t\t\tyou don't need the interface any longer! As long as you keep this handle,\n\t\t\t\tthe EasyHook driver CAN'T be unloaded...\n\n\t*/\n\t\tUNICODE_STRING\t\t\t\tDeviceName;\n\t\tPDEVICE_OBJECT\t\t\t\thEasyHookDrv = NULL;\n\t\tNTSTATUS\t\t\t\t\tNtStatus = STATUS_INTERNAL_ERROR;\n\t\tEASYHOOK_DEVICE_EXTENSION*\tDevExt;\n\n\t\t/*\n\t\t\tOpen log file...\n\t\t*/\n\t\tRtlInitUnicodeString(&DeviceName, EASYHOOK_DEVICE_NAME);\n\n\t\tif(!NT_SUCCESS(NtStatus = IoGetDeviceObjectPointer(&DeviceName, FILE_READ_DATA, OutEasyHookDrv, &hEasyHookDrv)))\n\t\t\treturn NtStatus;\n\n\t\t__try\n\t\t{\n\t\t\tDevExt = (EASYHOOK_DEVICE_EXTENSION*)hEasyHookDrv->DeviceExtension;\n\n\t\t\tif(DevExt->MaxVersion < InInterfaceVersion)\n\t\t\t\treturn STATUS_NOT_SUPPORTED;\n\n\t\t\tswitch(InInterfaceVersion)\n\t\t\t{\n\t\t\tcase EASYHOOK_INTERFACE_v_1: memcpy(OutInterface, &DevExt->API_v_1, sizeof(DevExt->API_v_1)); break;\n\t\t\tdefault: \n\t\t\t\treturn STATUS_INVALID_PARAMETER_1;\n\t\t\t}\n\n\t\t\treturn STATUS_SUCCESS;\n\t\t}\n\t\t__except(EXCEPTION_EXECUTE_HANDLER)\n\t\t{\n\t\t\tObDereferenceObject(*OutEasyHookDrv);\n\n\t\t\treturn NtStatus;\n\t\t}\n\t}\n\n\n#endif // DRIVER\n\n#ifndef DRIVER\n\t/*\n\t\tDebug helper API.\n\t*/\n\tEASYHOOK_BOOL_EXPORT DbgIsAvailable();\n\n\tEASYHOOK_BOOL_EXPORT DbgIsEnabled();\n\n\tEASYHOOK_NT_EXPORT DbgAttachDebugger();\n\n\tEASYHOOK_NT_EXPORT DbgDetachDebugger();\n\n\tEASYHOOK_NT_EXPORT DbgGetThreadIdByHandle(\n\t\t\t\tHANDLE InThreadHandle,\n\t\t\t\tULONG* OutThreadId);\n\n\tEASYHOOK_NT_EXPORT DbgGetProcessIdByHandle(\n\t\t\t\tHANDLE InProcessHandle,\n\t\t\t\tULONG* OutProcessId);\n\n\tEASYHOOK_NT_EXPORT DbgHandleToObjectName(\n\t\t\t\tHANDLE InNamedHandle,\n\t\t\t\tUNICODE_STRING* OutNameBuffer,\n\t\t\t\tULONG InBufferSize,\n\t\t\t\tULONG* OutRequiredSize);\n\n\n\t/*\n\t\tInjection support API.\n\t*/\n\ttypedef struct _REMOTE_ENTRY_INFO_\n\t{\n\t\tULONG           HostPID;\n\t\tUCHAR*          UserData;\n\t\tULONG           UserDataSize;\n\t}REMOTE_ENTRY_INFO;\n\n\ttypedef void __stdcall REMOTE_ENTRY_POINT(REMOTE_ENTRY_INFO* InRemoteInfo);\n\n\t#define EASYHOOK_INJECT_DEFAULT\t\t\t\t0x00000000\n\t#define EASYHOOK_INJECT_STEALTH\t\t\t\t0x10000000 // (experimental)\n\t#define EASYHOOK_INJECT_NET_DEFIBRILLATOR\t0x20000000 // USE THIS ONLY IN UNMANAGED CODE AND ONLY WITH CreateAndInject() FOR MANAGED PROCESSES!!\n\n\tEASYHOOK_NT_EXPORT RhCreateStealthRemoteThread(\n\t\t\t\tULONG InTargetPID,\n\t\t\t\tLPTHREAD_START_ROUTINE InRemoteRoutine,\n\t\t\t\tPVOID InRemoteParam,\n\t\t\t\tHANDLE* OutRemoteThread);\n\n\tEASYHOOK_NT_EXPORT RhInjectLibrary(\n\t\t\t\tULONG InTargetPID,\n\t\t\t\tULONG InWakeUpTID,\n\t\t\t\tULONG InInjectionOptions,\n\t\t\t\tWCHAR* InLibraryPath_x86,\n\t\t\t\tWCHAR* InLibraryPath_x64,\n\t\t\t\tPVOID InPassThruBuffer,\n\t\t\t\tULONG InPassThruSize);\n\n\tEASYHOOK_NT_EXPORT RhCreateAndInject(\n\t\t\t\tWCHAR* InEXEPath,\n\t\t\t\tWCHAR* InCommandLine,\n\t\t\t\tULONG InProcessCreationFlags,\n\t\t\t\tULONG InInjectionOptions,\n\t\t\t\tWCHAR* InLibraryPath_x86,\n\t\t\t\tWCHAR* InLibraryPath_x64,\n\t\t\t\tPVOID InPassThruBuffer,\n\t\t\t\tULONG InPassThruSize,\n\t\t\t\tULONG* OutProcessId);\n\n\tEASYHOOK_BOOL_EXPORT RhIsX64System();\n\n\tEASYHOOK_NT_EXPORT RhIsX64Process(\n\t\t\t\tULONG InProcessId,\n\t\t\t\tBOOL* OutResult);\n\n\tEASYHOOK_BOOL_EXPORT RhIsAdministrator();\n\n\tEASYHOOK_NT_EXPORT RhWakeUpProcess();\n\n\tEASYHOOK_NT_EXPORT RhInstallSupportDriver();\n\n\tEASYHOOK_NT_EXPORT RhInstallDriver(\n\t\t\tWCHAR* InDriverPath,\n\t\t\tWCHAR* InDriverName);\n\n\ttypedef struct _GACUTIL_INFO_* HGACUTIL;\n\n\n#endif // !DRIVER\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif\n"
        },
        {
          "name": "expfunc.cpp",
          "type": "blob",
          "size": 27.51953125,
          "content": "#ifndef _GDIPP_EXE\r\n#include \"settings.h\"\r\n#include \"override.h\"\r\n#include <tlhelp32.h>\r\n#include <shlwapi.h>\t//DLLVERSIONINFO\r\n#include \"undocAPI.h\"\r\n#include <windows.h>\r\n#include <dwrite_1.h>\r\n#include <dwrite_2.h>\r\n#include <dwrite_3.h>\r\n#include <locale>\r\n#include \"wow64ext.h\"\r\n#include <VersionHelpers.h>\r\n#include \"crc32.h\"\r\n\r\n// win2k以降\r\n//#pragma comment(linker, \"/subsystem:windows,5.0\")\r\n#ifndef _WIN64\r\n#ifdef DEBUG\r\n#pragma comment(lib, \"wow64ext_dbg.lib\")\r\n#else\r\n#pragma comment(lib, \"wow64ext.lib\")\r\n#endif\r\n#endif\r\n\r\nEXTERN_C LRESULT CALLBACK GetMsgProc(int code, WPARAM wParam, LPARAM lParam)\r\n{\r\n\t//何もしない\r\n\treturn CallNextHookEx(NULL, code, wParam, lParam);\r\n}\r\n\r\nEXTERN_C HRESULT WINAPI GdippDllGetVersion(DLLVERSIONINFO* pdvi)\r\n{\r\n\tif (!pdvi || pdvi->cbSize < sizeof(DLLVERSIONINFO)) {\r\n\t\treturn E_INVALIDARG;\r\n\t}\r\n\r\n\tconst UINT cbSize = pdvi->cbSize;\r\n\tZeroMemory(pdvi, cbSize);\r\n\tpdvi->cbSize = cbSize;\r\n\r\n\tHRSRC hRsrc = FindResource(GetDLLInstance(), MAKEINTRESOURCE(VS_VERSION_INFO), RT_VERSION);\r\n\tif (!hRsrc) {\r\n\t\treturn E_FAIL;\r\n\t}\r\n\r\n\tHGLOBAL hGlobal = LoadResource(GetDLLInstance(), hRsrc);\r\n\tif (!hGlobal) {\r\n\t\treturn E_FAIL;\r\n\t}\r\n\r\n\tconst WORD* lpwPtr = (const WORD*)LockResource(hGlobal);\r\n\tif (lpwPtr[1] != sizeof(VS_FIXEDFILEINFO)) {\r\n\t\treturn E_FAIL;\r\n\t}\r\n\r\n\tconst VS_FIXEDFILEINFO* pvffi = (const VS_FIXEDFILEINFO*)(lpwPtr + 20);\r\n\tif (pvffi->dwSignature != VS_FFI_SIGNATURE ||\r\n\t\t\tpvffi->dwStrucVersion != VS_FFI_STRUCVERSION) {\r\n\t\treturn E_FAIL;\r\n\t}\r\n\r\n\t//8.0.2006.1027\r\n\t// -> Major: 8, Minor: 2006, Build: 1027\r\n\tpdvi->dwMajorVersion\t= HIWORD(pvffi->dwFileVersionMS);\r\n\tpdvi->dwMinorVersion\t= LOWORD(pvffi->dwFileVersionMS) * 10 + HIWORD(pvffi->dwFileVersionLS);\r\n\tpdvi->dwBuildNumber\t\t= LOWORD(pvffi->dwFileVersionLS);\r\n\tpdvi->dwPlatformID\t\t= DLLVER_PLATFORM_NT;\r\n\r\n\tif (pdvi->cbSize < sizeof(DLLVERSIONINFO2)) {\r\n\t\treturn S_OK;\r\n\t}\r\n\r\n\tDLLVERSIONINFO2* pdvi2 = (DLLVERSIONINFO2*)pdvi;\r\n\tpdvi2->ullVersion\t\t= MAKEDLLVERULL(pdvi->dwMajorVersion, pdvi->dwMinorVersion, pdvi->dwBuildNumber, 2);\r\n\treturn S_OK;\r\n}\r\n\r\n#endif\t//!_GDIPP_EXE\r\n\r\nextern LONG interlock;\r\nextern LONG g_bHookEnabled;\r\n#include \"gdiPlusFlat2.h\"\r\n\r\n#ifdef USE_DETOURS\r\n//detours\r\n#include \"detours.h\"\r\n//\r\n#define HOOK_MANUALLY(rettype, name, argtype, arglist) ;\r\n#define HOOK_DEFINE(rettype, name, argtype, arglist) \\\r\n\tDetourDetach(&(PVOID&)ORIG_##name, IMPL_##name);\r\nLONG hook_term()\r\n{\r\n\tDetourTransactionBegin();\r\n\tDetourUpdateThread(GetCurrentThread());\r\n\r\n#include \"hooklist.h\"\r\n\r\n\tLONG error = DetourTransactionCommit();\r\n\r\n\tif (error != NOERROR) {\r\n\t\tTRACE(_T(\"hook_term error: %#x\\n\"), error);\r\n\t}\r\n\treturn error;\r\n}\r\n#undef HOOK_DEFINE\r\n#undef HOOK_MANUALLY\r\n\r\n#else\r\n#include \"easyhook.h\"\r\n#define HOOK_MANUALLY(rettype, name, argtype, arglist) ;\r\n#define HOOK_DEFINE(rettype, name, argtype, arglist) \\\r\n\tORIG_##name = name;\r\n#pragma optimize(\"s\", on)\r\nstatic LONG hook_term()\r\n{\r\n#include \"hooklist.h\"\r\n\tLhUninstallAllHooks();\r\n\treturn LhWaitForPendingRemovals();\r\n}\r\n#pragma optimize(\"\", on)\r\n#undef HOOK_DEFINE\r\n#undef HOOK_MANUALLY\r\n#endif\r\n\r\nHMODULE GetSelfModuleHandle()\r\n{\r\n\tMEMORY_BASIC_INFORMATION mbi;\r\n\r\n\treturn ((::VirtualQuery(GetSelfModuleHandle, &mbi, sizeof(mbi)) != 0) \r\n\t\t? (HMODULE) mbi.AllocationBase : NULL);\r\n}\r\n\r\nEXTERN_C void WINAPI CreateControlCenter(IControlCenter** ret)\r\n{\r\n\t*ret = (IControlCenter*)new CControlCenter;\r\n}\r\n\r\nEXTERN_C void WINAPI ReloadConfig()\r\n{\r\n\tCControlCenter::ReloadConfig();\r\n}\r\n\r\nextern HINSTANCE g_dllInstance;\r\nEXTERN_C void SafeUnload()\r\n{\r\n\tstatic BOOL bInited = false;\r\n\tif (bInited)\r\n\t\treturn;\t//防重入\r\n\tbInited = true;\r\n\twhile (CThreadCounter::Count())\r\n\t\tSleep(0);\r\n\tCCriticalSectionLock * lock = new CCriticalSectionLock;\r\n\tBOOL last;\r\n\tif (last=InterlockedExchange(&g_bHookEnabled, FALSE)) {\r\n\t\tif (hook_term()!=NOERROR)\r\n\t\t{\r\n\t\t\tInterlockedExchange(&g_bHookEnabled, last);\r\n\t\t\tbInited = false;\r\n\t\t\tdelete lock;\r\n\t\t\tExitThread(ERROR_ACCESS_DENIED);\r\n\t\t}\r\n\t}\r\n\tdelete lock;\r\n\twhile (CThreadCounter::Count())\r\n\t\tSleep(10);\r\n\tSleep(0);\r\n\tdo \r\n\t{\r\n\t\tSleep(10);\r\n\t} while (CThreadCounter::Count());\t//double check for xp\r\n\t\t\r\n\tbInited = false; \r\n\tFreeLibraryAndExitThread(g_dllInstance, 0);\r\n}\r\n\r\nvoid ChangeFileName(LPWSTR lpSrc, int nSize, LPCWSTR lpNewFileName) {\r\n\tfor (int i = nSize; i > 0; --i){\r\n\t\tif (lpSrc[i] == L'\\\\') {\r\n\t\t\tlpSrc[i + 1] = L'\\0';\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\twcscat(lpSrc, lpNewFileName);\r\n}\r\n\r\nstd::string WstringToString(const std::wstring str)\r\n{// wstringתstring\r\n\tunsigned len = str.size() * 4;\r\n\tsetlocale(LC_CTYPE, \"\");\r\n\tchar *p = new char[len];\r\n\twcstombs(p, str.c_str(), len);\r\n\tstd::string str1(p);\r\n\tdelete[] p;\r\n\treturn str1;\r\n}\r\n\r\n// make a unique name with fullname + crc32_of_fullname + familyname +stylename\r\nstd::wstring MakeUniqueFontName(const std::wstring strFullName, const std::wstring strFamilyName, const std::wstring strStyleName)\r\n{\r\n\treturn strFullName + to_wstring(crc32::getCrc32(0, strFullName.c_str(), strFullName.length() * sizeof(WCHAR))) + strFamilyName + strStyleName;\r\n}\r\n\r\n#ifndef Assert\r\n#include <crtdbg.h>\r\n#define Assert\t_ASSERTE\r\n#endif\t//!Assert\r\n\r\n#include \"array.h\"\r\n#include <strsafe.h>\r\n#include <shlwapi.h>\r\n#include \"dll.h\"\r\n\r\n//kernel32専用GetProcAddressモドキ\r\nFARPROC K32GetProcAddress(LPCSTR lpProcName)\r\n{\r\n#ifndef _WIN64\r\n\t//序数渡しには対応しない\r\n\tAssert(!IS_INTRESOURCE(lpProcName));\r\n\r\n\t//kernel32のベースアドレス取得\r\n\tLPBYTE pBase = (LPBYTE)GetModuleHandleA(\"kernel32.dll\");\r\n\r\n\t//この辺は100%成功するはずなのでエラーチェックしない\r\n\tPIMAGE_DOS_HEADER pdosh = (PIMAGE_DOS_HEADER)pBase;\r\n\tAssert(pdosh->e_magic == IMAGE_DOS_SIGNATURE);\r\n\tPIMAGE_NT_HEADERS pnth = (PIMAGE_NT_HEADERS)(pBase + pdosh->e_lfanew);\r\n\tAssert(pnth->Signature == IMAGE_NT_SIGNATURE);\r\n\r\n\tconst DWORD offs = pnth->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;\r\n\tconst DWORD size = pnth->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;\r\n\tif (offs == 0 || size == 0) {\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tPIMAGE_EXPORT_DIRECTORY pdir = (PIMAGE_EXPORT_DIRECTORY)(pBase + offs);\r\n\tDWORD*\tpFunc = (DWORD*)(pBase + pdir->AddressOfFunctions);\r\n\tWORD*\tpOrd  = (WORD*)(pBase + pdir->AddressOfNameOrdinals);\r\n\tDWORD*\tpName = (DWORD*)(pBase + pdir->AddressOfNames);\r\n\r\n\tfor(DWORD i=0; i<pdir->NumberOfFunctions; i++) {\r\n\t\tfor(DWORD j=0; j<pdir->NumberOfNames; j++) {\r\n\t\t\tif(pOrd[j] != i)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tif(strcmp((LPCSTR)pBase + pName[j], lpProcName) != 0)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\treturn (FARPROC)(pBase + pFunc[i]);\r\n\t\t}\r\n\t}\r\n\treturn NULL;\r\n#else\r\n\tAssert(!IS_INTRESOURCE(lpProcName));\r\n\r\n\t//kernel32のベースアドレス取得\r\n\tWCHAR sysdir[MAX_PATH];\r\n\tGetWindowsDirectory(sysdir, MAX_PATH);\r\n\tif (GetModuleHandle(_T(\"kernelbase.dll\")))\t//查看自己是否加载了Kernelbase.dll文件，存在则说明是win7系统\r\n\t\twcscat(sysdir, L\"\\\\SysWow64\\\\kernelbase.dll\");\r\n\telse\r\n\t\twcscat(sysdir, L\"\\\\SysWow64\\\\kernel32.dll\");\t//不存在就是vista\r\n\tHANDLE hFile = CreateFile(sysdir, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);\r\n\tif (hFile == INVALID_HANDLE_VALUE)\r\n\t\treturn NULL;\r\n\tDWORD dwSize = GetFileSize(hFile, NULL);\r\n\tBYTE* pMem = new BYTE[dwSize];\t//分配内存\r\n\tReadFile(hFile, pMem, dwSize, &dwSize, NULL);//读取文件\r\n\tCloseHandle(hFile);\r\n\r\n\tCMemLoadDll MemDll;\r\n\tMemDll.MemLoadLibrary(pMem, dwSize, false, false);\r\n\tdelete[] pMem;\r\n\treturn FARPROC((DWORD_PTR)MemDll.MemGetProcAddress(lpProcName)-MemDll.GetImageBase());\t//返回偏移值\r\n\r\n#endif\r\n}\r\n\r\ntypedef struct _UNICODE_STRING64 {\r\n\tUSHORT Length;\r\n\tUSHORT MaximumLength;\r\n\tDWORD64  Buffer;\r\n} UNICODE_STRING64, *PUNICODE_STRING64;\r\n\r\n#include <pshpack1.h>\r\nclass opcode_data {\r\nprivate:\r\n\tBYTE\tcode[0x100];\r\n\r\n\t//注: dllpathをWORD境界にしないと場合によっては正常に動作しない\r\n\tWCHAR\tdllpath[MAX_PATH];\r\n\tUNICODE_STRING64 uniDllPath;\r\n\tDWORD64 hDumyDllHandle;\r\n\r\npublic:\r\n\topcode_data()\r\n\t{\r\n\t\t//int 03hで埋める\r\n\t\tFillMemory(this, sizeof(*this), 0xcc);\r\n\t}\r\n\tbool initWow64(LPDWORD remoteaddr, LONG orgEIP)\t//Wow64初始化\r\n\t{\r\n\t\t//WORD境界チェック\r\n\t\tC_ASSERT((offsetof(opcode_data, dllpath) & 1) == 0);\r\n\r\n\t\tregister BYTE* p = code;\r\n\r\n#define emit_(t,x)\t*(t* UNALIGNED)p = (t)(x); p += sizeof(t)\r\n#define emit_db(b)\temit_(BYTE, b)\r\n#define emit_dw(w)\temit_(WORD, w)\r\n#define emit_dd(d)\temit_(DWORD, d)\r\n\r\n\t\t//なぜかGetProcAddressでLoadLibraryWのアドレスが正しく取れないことがあるので\r\n\t\t//kernel32のヘッダから自前で取得する\r\n\t\tFARPROC pfn = K32GetProcAddress(\"LoadLibraryExW\");\r\n\t\tif(!pfn)\r\n\t\t\treturn false;\r\n\r\n\t\temit_db(0x60);\t\t//pushad\r\n\r\n\t\t/*\r\n\t\t\tmov eax,fs:[0x30]\r\n\t\t\tmov eax,[eax+0x0c]\r\n\t\t\tmov esi,[eax+0x1c]\r\n\t\t\tlodsd\r\n\t\t\tmove ax,[eax+$08]//这个时候eax中保存的就是k32的基址了\r\n\t\t\t在win7获得的是KernelBase.dll的地址\r\n\t\t*/\r\n\t\temit_db(0x64); \r\n\t\temit_db(0xA1); \r\n\t\temit_db(0x30); \r\n\t\temit_db(00); \r\n\t\temit_db(00); \r\n\t\temit_db(00); \r\n\t\temit_db(0x8B); \r\n\t\temit_db(0x40); \r\n\t\temit_db(0x0C); \r\n\t\temit_db(0x8B); \r\n\t\temit_db(0x70); \r\n\t\temit_db(0x1C); \r\n\t\temit_db(0xAD); \r\n\t\temit_db(0x8B); \r\n\t\temit_db(0x40);\r\n\t\temit_db(0x08);\t\t//use assemble to fetch kernel base\r\n\r\n\t\temit_dw(0x006A);\t//push 0\r\n\t\temit_dw(0x006A);\t//push 0\r\n\t\temit_db(0x68);\t\t//push dllpath\r\n\t\temit_dd((LONG)remoteaddr + offsetof(opcode_data, dllpath));\r\n\t\temit_db(0x05);\t\t//add eax, LoadLibraryExW offset\r\n\t\temit_dd(pfn);\r\n\t\temit_dw(0xD0FF);\t//call eax\r\n\r\n\t\temit_db(0x61);\t\t//popad\r\n\t\temit_db(0xE9);\t\t//jmp original_EIP\r\n\t\temit_dd(orgEIP - (LONG)remoteaddr - (p - code) - sizeof(LONG));\r\n\r\n\t\t// gdi++.dllのパス\r\n\t\tint nSize = GetModuleFileNameW(GetDLLInstance(), dllpath, MAX_PATH);\r\n\t\tif (nSize) {\r\n\t\t\tChangeFileName(dllpath, nSize, L\"MTBootStrap.dll\");\r\n\t\t}\r\n\t\treturn !!nSize;\r\n\t}\r\n\tbool init32(LPDWORD remoteaddr, LONG orgEIP)\t//32位程序初始化\r\n\t{\r\n\t\t//WORD境界チェック\r\n\t\tC_ASSERT((offsetof(opcode_data, dllpath) & 1) == 0);\r\n\r\n\t\tregister BYTE* p = code;\r\n\r\n#define emit_(t,x)\t*(t* UNALIGNED)p = (t)(x); p += sizeof(t)\r\n#define emit_db(b)\temit_(BYTE, b)\r\n#define emit_dw(w)\temit_(WORD, w)\r\n#define emit_dd(d)\temit_(DWORD, d)\r\n\r\n\t\t//なぜかGetProcAddressでLoadLibraryWのアドレスが正しく取れないことがあるので\r\n\t\t//kernel32のヘッダから自前で取得する\r\n\t\tFARPROC pfn = K32GetProcAddress(\"LoadLibraryW\");\r\n\t\tif(!pfn)\r\n\t\t\treturn false;\r\n\r\n\t\temit_db(0x60);\t\t//pushad\r\n#if _DEBUG\r\nemit_dw(0xC033);\t//xor eax, eax\r\nemit_db(0x50);\t\t//push eax\r\nemit_db(0x50);\t\t//push eax\r\nemit_db(0x68);\t\t//push dllpath\r\nemit_dd((LONG)remoteaddr + offsetof(opcode_data, dllpath));\r\nemit_db(0x50);\t\t//push eax\r\nemit_db(0xB8);\t\t//mov eax, MessageBoxW\r\nemit_dd((LONG)MessageBoxW);\r\nemit_dw(0xD0FF);\t//call eax\r\n#endif\r\n\r\n\t\temit_db(0x68);\t\t//push dllpath\r\n\t\temit_dd((LONG)remoteaddr + offsetof(opcode_data, dllpath));\r\n\t\temit_db(0xB8);\t\t//mov eax, LoadLibraryW\r\n\t\temit_dd(pfn);\r\n\t\temit_dw(0xD0FF);\t//call eax\r\n\r\n\t\temit_db(0x61);\t\t//popad\r\n\t\temit_db(0xE9);\t\t//jmp original_EIP\r\n\t\temit_dd(orgEIP - (LONG)remoteaddr - (p - code) - sizeof(LONG));\r\n\r\n\t\t// gdi++.dllのパス\r\n\t\tint nSize = GetModuleFileNameW(GetDLLInstance(), dllpath, MAX_PATH);\r\n\t\tif (nSize) {\r\n\t\t\tChangeFileName(dllpath, nSize, L\"MTBootStrap.dll\");\r\n\t\t}\r\n\t\treturn !!nSize;\r\n\t}\r\n\tbool init64From32(DWORD64 remoteaddr, DWORD64 orgEIP)\r\n\t{\r\n\t\tC_ASSERT((offsetof(opcode_data, dllpath) & 1) == 0);\r\n\r\n\t\tregister BYTE* p = code;\r\n\r\n#define emit_(t,x)\t*(t* UNALIGNED)p = (t)(x); p += sizeof(t)\r\n#define emit_db(b)\temit_(BYTE, b)\r\n#define emit_dw(w)\temit_(WORD, w)\r\n#define emit_dd(d)\temit_(DWORD, d)\r\n#define emit_ddp(dp) emit_(DWORD64, dp)\r\n\r\n\t\t//なぜかGetProcAddressでLoadLibraryWのアドレスが正しく取れないことがあるので\r\n\t\t//kernel32のヘッダから自前で取得する\r\n\t\tWCHAR x64Addr[30] = { 0 };\r\n\t\tif (!GetEnvironmentVariable(L\"MACTYPE_X64ADDR\", x64Addr, 29)) return false;\r\n\t\tDWORD64 pfn = wcstoull(x64Addr, NULL, 10);\r\n\t\t//DWORD64 pfn = getenv(\"MACTYPE_X64ADDR\"); //GetProcAddress64(GetModuleHandle64(L\"kernelbase.dll\"), \"LoadLibraryW\");\r\n\t\tif (!pfn)\r\n\t\t\treturn false;\r\n\r\n\t\temit_db(0x50);\t\t//push rax\r\n\t\temit_db(0x51);\t\t//push rcx\r\n\t\temit_db(0x52);\t\t//push rdx\r\n\t\temit_db(0x53);\t\t//push rbx\r\n\t\temit_dd(0x28ec8348);\t//sub rsp,28h\r\n\t\temit_db(0x48);\t\t//mov rcx, dllpath\r\n\t\temit_db(0xB9);\r\n\t\temit_ddp((DWORD64)remoteaddr + offsetof(opcode_data, dllpath));\r\n\t\temit_db(0x48);\t\t//mov rsi, LoadLibraryW\r\n\t\temit_db(0xBE);\r\n\t\temit_ddp(pfn);\r\n\t\t//emit_db(0x48);\r\n\t\temit_db(0xFF);\t//call rdi\r\n\t\temit_db(0xD6);\r\n\r\n\t\temit_dd(0x28c48348);\t//add rsp,28h\r\n\t\temit_db(0x5B);\r\n\t\temit_db(0x5A);\r\n\t\temit_db(0x59);\r\n\t\temit_db(0x58);\t\t//popad\t\t\r\n\r\n\t\temit_db(0x48);\t\t//mov rdi, orgRip\r\n\t\temit_db(0xBE);\r\n\t\temit_ddp(orgEIP);\r\n\t\temit_db(0xFF);\t\t//jmp rdi\r\n\t\temit_db(0xE6);\r\n\r\n\t\t// gdi++.dllのパス\r\n\r\n\t\tint nSize = GetModuleFileNameW(GetDLLInstance(), dllpath, MAX_PATH);\r\n\t\tif (nSize) {\r\n\t\t\tChangeFileName(dllpath, nSize, L\"MTBootStrap64.dll\");\r\n\t\t}\r\n\t\treturn !!nSize;\r\n\t}\r\n\r\n\tbool init64From32(DWORD64 remoteaddr, DWORD64 orgEIP, DWORD dwLoaderOffset)\r\n\t{\r\n\t\tC_ASSERT((offsetof(opcode_data, dllpath) & 1) == 0);\r\n\r\n\t\tint nSize = GetModuleFileNameW(GetDLLInstance(), dllpath, MAX_PATH);\r\n\t\tif (nSize) {\r\n\t\t\tChangeFileName(dllpath, nSize, L\"MTBootStrap64.dll\");\r\n\t\t}\r\n\t\tif (!nSize)\r\n\t\t\treturn false;\r\n\t\tuniDllPath.Length = wcslen(dllpath)*sizeof(WCHAR);\r\n\t\tuniDllPath.MaximumLength = uniDllPath.Length+2;\r\n\t\tuniDllPath.Buffer = remoteaddr + (DWORD64)offsetof(opcode_data, dllpath);\t//prepare PUNICODE_STRING for remote process\r\n\t\tregister BYTE* p = code;\r\n\r\n#define emit_(t,x)\t*(t* UNALIGNED)p = (t)(x); p += sizeof(t)\r\n#define emit_db(b)\temit_(BYTE, b)\r\n#define emit_dw(w)\temit_(WORD, w)\r\n#define emit_dd(d)\temit_(DWORD, d)\r\n#define emit_ddp(dp) emit_(DWORD64, dp)\r\n\r\n//get ntdll.dll imagebase\r\n//credit to http://www.52pojie.cn/thread-162625-1-1.html\r\n/*asm:\r\n\tmov rsi, [gs:60h]   ;     peb from teb\r\n\tmov rsi, [rsi+18h]    ;_peb_ldr_data from peb\r\n\tmov rsi, [rsi+30h]   ;InInitializationOrderModuleList.Flink, ntdll.dll\r\n\t;mov rsi, [rsi]  ;kernelbase.dll\r\n\t;mov rsi, [rsi]      ;kernel32.dll (not used for win7+)\r\n\tmov rsi, [rsi+10h]\r\n*/\r\n\r\n// emit_db(0xEB);\r\n// emit_db(0xFE);\t// make a dead loop\r\n\t\temit_db(0x65);\r\n\t\temit_db(0x48);\r\n\t\temit_db(0x8B);\r\n\t\temit_db(0x34);\r\n\t\temit_db(0x25);\r\n\t\temit_db(0x60);\r\n\t\temit_db(0x00);\r\n\t\temit_db(0x00);\r\n\t\temit_db(0x00);\r\n\t\temit_db(0x48);\r\n\t\temit_db(0x8B);\r\n\t\temit_db(0x76);\r\n\t\temit_db(0x18);\r\n\t\temit_db(0x48);\r\n\t\temit_db(0x8B);\r\n\t\temit_db(0x76);\r\n\t\temit_db(0x30);\r\n// \t\temit_db(0x48);\r\n// \t\temit_db(0x8B);\r\n// \t\temit_db(0x36);\r\n\t\temit_db(0x48);\r\n\t\temit_db(0x8B);\r\n\t\temit_db(0x76);\r\n\t\temit_db(0x10);\r\n//rsi = ntdll.dll baseaddress\r\n\r\n\t\temit_db(0x50);\t\t//push rax\r\n\t\temit_db(0x51);\t\t//push rcx\r\n\t\temit_db(0x52);\t\t//push rdx\r\n\t\temit_db(0x53);\t\t//push rbx\r\n\t\temit_dd(0x28ec8348);\t//sub rsp,28h\r\n\t\temit_db(0x48);\r\n\t\temit_db(0x31);\r\n\t\temit_db(0xc9);\t//xor rcx, rcx\r\n\t\temit_db(0x48);\r\n\t\temit_db(0x31);\r\n\t\temit_db(0xd2);\t//xor rdx, rdx\r\n\t\temit_db(0x49);\t\t\r\n\t\temit_db(0xB8);\r\n\t\temit_ddp((DWORD64)remoteaddr + offsetof(opcode_data, uniDllPath));//mov r8, uniDllPath\r\n\t\temit_db(0x49);\r\n\t\temit_db(0xB9);\r\n\t\temit_ddp((DWORD64)remoteaddr + offsetof(opcode_data, hDumyDllHandle));//mov r9, hDumyDllHandle\r\n\t\t//emit_db(0x48);\t\t//mov rsi, LdrLoadDll\r\n\t\t//emit_db(0xBE);\r\n\t\temit_db(0x48);\r\n\t\temit_db(0x81);\r\n\t\temit_db(0xC6);\t//add rsi, offset LdrLoadDll\r\n\t\temit_dd(dwLoaderOffset);\r\n\t\t//emit_db(0x48);\r\n\t\temit_db(0xFF);\t//call rsi\r\n\t\temit_db(0xD6);\r\n\r\n\t\temit_dd(0x28c48348);\t//add rsp,28h\r\n\t\temit_db(0x5B);\r\n\t\temit_db(0x5A);\r\n\t\temit_db(0x59);\r\n\t\temit_db(0x58);\t\t//popad\t\t\r\n\r\n\t\temit_db(0x48);\t\t//mov rdi, orgRip\r\n\t\temit_db(0xBE);\r\n\t\temit_ddp(orgEIP);\r\n\t\temit_db(0xFF);\t\t//jmp rdi\r\n\t\temit_db(0xE6);\r\n\r\n\t\t// gdi++.dllのパス\r\n\r\n\t\treturn !!nSize;\r\n\t}\r\n\r\n\tbool init(DWORD_PTR* remoteaddr, DWORD_PTR orgEIP)\r\n\t{\r\n\t\t//WORD境界チェック\r\n\t\tC_ASSERT((offsetof(opcode_data, dllpath) & 1) == 0);\r\n\r\n\t\tregister BYTE* p = code;\r\n#undef emit_ddp\r\n\r\n#define emit_(t,x)\t*(t* UNALIGNED)p = (t)(x); p += sizeof(t)\r\n#define emit_db(b)\temit_(BYTE, b)\r\n#define emit_dw(w)\temit_(WORD, w)\r\n#define emit_dd(d)\temit_(DWORD, d)\r\n#define emit_ddp(dp) emit_(DWORD_PTR, dp)\r\n\r\n\t\t//なぜかGetProcAddressでLoadLibraryWのアドレスが正しく取れないことがあるので\r\n\t\t//kernel32のヘッダから自前で取得する\r\n\t\tFARPROC pfn = GetProcAddress(GetModuleHandle(L\"kernel32.dll\"), \"LoadLibraryW\");\r\n\t\t//if(!pfn)\r\n\t\t//\treturn false;\r\n\t\t//emit_db(0xEB);\r\n\t\t//emit_db(0xFE);\t// make a dead loop\r\n\r\n\t\temit_db(0x50);\t\t//push rax\r\n\t\temit_db(0x51);\t\t//push rcx\r\n\t\temit_db(0x52);\t\t//push rdx\r\n\t\temit_db(0x53);\t\t//push rbx\r\n\t\t/*\r\n#ifdef DEBUG\r\n\t\temit_dd(0x28ec8348);\r\n\t\temit_db(0x48);\r\n\t\temit_db(0x31);\r\n\t\temit_db(0xD0);\t//xor rax,rax\r\n\t\temit_db(0x48);\r\n\t\temit_db(0x31);\r\n\t\temit_db(0xC9);\t//xor rcx,rcx\r\n\t\temit_db(0x48);\r\n\t\temit_db(0x31);\r\n\t\temit_db(0xD2);\t//xor rdx,rdx\r\n\t\temit_db(0x45);\r\n\t\temit_db(0x31);\r\n\t\temit_db(0xC0);\t//xor r8d,r8d\r\n\t\temit_db(0x45);\r\n\t\temit_db(0x31);\r\n\t\temit_db(0xC9);\t//xor r9d,r9d\r\n\r\n\t\temit_db(0x48);\t\t//mov rsi, MessageBoxW\r\n\t\temit_db(0xBE);\r\n\t\temit_ddp((DWORD_PTR)MessageBoxW);\r\n\t\temit_db(0xFF);\r\n\t\temit_db(0xD6);\r\n\t\temit_dd(0x28c48348);\r\n#endif*/\r\n/*\t\r\n//Debug function2, Sleep for 10sec.\r\n\t\temit_dd(0x28ec8348);\r\n\t\temit_db(0x48);\t\t//mov rsi, MessageBoxW\r\n\t\temit_db(0xBE);\r\n\t\temit_ddp((DWORD_PTR)Sleep);\r\n\t\temit_db(0x48); emit_db(0xc7); emit_db(0xc1); emit_db(0x10); emit_db(0x27); emit_db(0x00); emit_db(0x00);\r\n\t\temit_db(0xFF);\r\n\t\temit_db(0xD6);\r\n\t\temit_dd(0x28c48348);\r\n*/\r\n\t\temit_dd(0x28ec8348);\t//sub rsp,28h\r\n\t\temit_db(0x48);\t\t//mov rcx, dllpath\r\n\t\temit_db(0xB9);\r\n\t\temit_ddp((DWORD_PTR)remoteaddr + offsetof(opcode_data, dllpath));\r\n\t\temit_db(0x48);\t\t//mov rsi, LoadLibraryW\r\n\t\temit_db(0xBE);\t\t\r\n\t\temit_ddp(pfn);\r\n\t\t//emit_db(0x48);\r\n\t\temit_db(0xFF);\t//call rdi\r\n\t\temit_db(0xD6);\r\n\r\n\t\temit_dd(0x28c48348);\t//add rsp,28h\r\n\t\temit_db(0x5B);\t\r\n\t\temit_db(0x5A);\t\r\n\t\temit_db(0x59);\t\r\n\t\temit_db(0x58);\t\t//popad\t\t\r\n\t\t\r\n\t\temit_db(0x48);\t\t//mov rdi, orgRip\r\n\t\temit_db(0xBE);\r\n\t\temit_ddp(orgEIP);\r\n\t\temit_db(0xFF);\t\t//jmp rdi\r\n\t\temit_db(0xE6);\r\n\r\n\t\t// gdi++.dllのパス\r\n\t\tint nSize = GetModuleFileNameW(GetDLLInstance(), dllpath, MAX_PATH);\r\n\t\tif (nSize) {\r\n\t\t\tChangeFileName(dllpath, nSize, L\"MTBootStrap64.dll\");\r\n\t\t}\r\n\t\treturn !!nSize;\r\n\t}\r\n\r\n};\r\n#include <poppack.h>\r\n\r\n// 安全的取得真实系统信息\r\nVOID SafeGetNativeSystemInfo(__out LPSYSTEM_INFO lpSystemInfo)\r\n{\r\n\tif (NULL == lpSystemInfo)    return;\r\n\ttypedef VOID(WINAPI *LPFN_GetNativeSystemInfo)(LPSYSTEM_INFO lpSystemInfo);\r\n\tLPFN_GetNativeSystemInfo fnGetNativeSystemInfo = (LPFN_GetNativeSystemInfo)GetProcAddress(GetModuleHandle(_T(\"kernel32\")), \"GetNativeSystemInfo\");;\r\n\tif (NULL != fnGetNativeSystemInfo)\r\n\t{\r\n\t\tfnGetNativeSystemInfo(lpSystemInfo);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tGetSystemInfo(lpSystemInfo);\r\n\t}\r\n}\r\n\r\n// 获取操作系统位数\r\nint GetSystemBits()\r\n{\r\n\tSYSTEM_INFO si;\r\n\tSafeGetNativeSystemInfo(&si);\r\n\tif (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64 ||\r\n\t\tsi.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64)\r\n\t{\r\n\t\treturn 64;\r\n\t}\r\n\treturn 32;\r\n}\r\n\r\nstatic bool bIsOS64 = GetSystemBits() == 64;\t// check if running in a x64 system.\r\n\r\n#ifdef _M_IX86\r\n// 止めているプロセスにLoadLibraryするコードを注入\r\nEXTERN_C BOOL WINAPI GdippInjectDLL(const PROCESS_INFORMATION* ppi)\r\n{\r\n\tBOOL bIsX64Proc = false;\r\n\tif (bIsOS64 && IsWow64Process(ppi->hProcess, &bIsX64Proc) && !bIsX64Proc)\r\n\t{\r\n\t\t//x86 process launches a x64 process\r\n\t\t_CONTEXT64 ctx = { 0 };\r\n\t\tctx.ContextFlags = CONTEXT_CONTROL;\r\n\t\tif (!GetThreadContext64(ppi->hThread, &ctx))\r\n\t\t\treturn false;\r\n\t\tstatic bool bTryLoadDll64 = false;\r\n\t\tstatic DWORD dwLoaderOffset = 0;\r\n\t\tif (!bTryLoadDll64) {\r\n\t\t\tbTryLoadDll64 = true;\r\n\t\t\tGetEnvironmentVariable(L\"MACTYPE_X64ADDR\", NULL, 0);\r\n\t\t\tif (GetLastError() == ERROR_ENVVAR_NOT_FOUND) {\r\n\t\t\t\tDWORD64 hNtdll = 0;\r\n\t\t\t\thNtdll = GetModuleHandle64(L\"ntdll.dll\");\r\n\t\t\t\tif (hNtdll) {\r\n\t\t\t\t\tDWORD64 pfnLdrAddr = GetProcAddress64(hNtdll, \"LdrLoadDll\");\r\n\t\t\t\t\tif (pfnLdrAddr) {\r\n\t\t\t\t\t\tdwLoaderOffset = (DWORD)(pfnLdrAddr - hNtdll);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\topcode_data local;\r\n\t\tDWORD64 remote = VirtualAllocEx64(ppi->hProcess, NULL, sizeof(opcode_data), MEM_COMMIT, PAGE_EXECUTE_READWRITE);\r\n\t\tif (!remote)\r\n\t\t\treturn false;\r\n\t\tbool basmIniter = dwLoaderOffset ? local.init64From32(remote, ctx.Rip, dwLoaderOffset) : local.init64From32(remote, ctx.Rip);\r\n\t\tif (!basmIniter\t|| !WriteProcessMemory64(ppi->hProcess, remote, &local, sizeof(opcode_data), NULL)) {\r\n\t\t\tVirtualFreeEx64(ppi->hProcess, remote, 0, MEM_RELEASE);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t//FlushInstructionCache64(ppi->hProcess, remote, sizeof(opcode_data));\r\n\t\t//FARPROC a=(FARPROC)remote;\r\n\t\t//a();\r\n\t\tctx.Rip = (DWORD64)remote;\r\n\t\treturn !!SetThreadContext64(ppi->hThread, &ctx);\r\n\t}\r\n\telse {\r\n\t\tCONTEXT ctx = { 0 };\r\n\t\tctx.ContextFlags = CONTEXT_CONTROL;\r\n\t\tif (!GetThreadContext(ppi->hThread, &ctx))\r\n\t\t\treturn false;\r\n\r\n\t\topcode_data local;\r\n\t\topcode_data* remote = (opcode_data*)VirtualAllocEx(ppi->hProcess, NULL, sizeof(opcode_data), MEM_COMMIT, PAGE_EXECUTE_READWRITE);\r\n\t\tif (!remote)\r\n\t\t\treturn false;\r\n\r\n\t\tif (!local.init32((LPDWORD)remote, ctx.Eip)\r\n\t\t\t|| !WriteProcessMemory(ppi->hProcess, remote, &local, sizeof(opcode_data), NULL)) {\r\n\t\t\tVirtualFreeEx(ppi->hProcess, remote, 0, MEM_RELEASE);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tFlushInstructionCache(ppi->hProcess, remote, sizeof(opcode_data));\r\n\t\tctx.Eip = (DWORD)remote;\r\n\t\treturn !!SetThreadContext(ppi->hThread, &ctx);\r\n\t}\r\n}\r\n#else\r\nEXTERN_C BOOL WINAPI GdippInjectDLL(const PROCESS_INFORMATION* ppi)\r\n{\r\n\tBOOL bWow64 = false;\r\n\tIsWow64Process(ppi->hProcess, &bWow64);\r\n\tif (bWow64)\r\n\t{\r\n\t\tWOW64_CONTEXT ctx = { 0 };\r\n\t\tctx.ContextFlags = CONTEXT_CONTROL;\r\n\t\t//CREATE_SUSPENDEDなので基本的に成功するはず\r\n\t\tif(!Wow64GetThreadContext(ppi->hThread, &ctx))\r\n\t\t\treturn false;\r\n\r\n\t\topcode_data local;\r\n\t\tLPVOID remote = VirtualAllocEx(ppi->hProcess, NULL, sizeof(opcode_data), MEM_COMMIT, PAGE_EXECUTE_READWRITE);\r\n\t\tif(!remote)\r\n\t\t\treturn false;\r\n\r\n\t\tif(!local.initWow64((LPDWORD)remote, ctx.Eip)\r\n\t\t\t|| !WriteProcessMemory(ppi->hProcess, remote, &local, sizeof(opcode_data), NULL)) {\r\n\t\t\t\tVirtualFreeEx(ppi->hProcess, remote, 0, MEM_RELEASE);\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tFlushInstructionCache(ppi->hProcess, remote, sizeof(opcode_data));\r\n\t\t//FARPROC a=(FARPROC)remote;\r\n\t\t//a();\r\n\t\tctx.Eip = (DWORD)remote;\r\n\t\treturn !!Wow64SetThreadContext(ppi->hThread, &ctx);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tCONTEXT ctx = { 0 };\r\n\t\tctx.ContextFlags = CONTEXT_CONTROL;\r\n\t\t//CREATE_SUSPENDEDなので基本的に成功するはず\r\n\t\tif(!GetThreadContext(ppi->hThread, &ctx))\r\n\t\t\treturn false;\r\n\r\n\t\topcode_data local;\r\n\t\tLPVOID remote = VirtualAllocEx(ppi->hProcess, NULL, sizeof(opcode_data), MEM_COMMIT, PAGE_EXECUTE_READWRITE);\r\n\t\tif(!remote)\r\n\t\t\treturn false;\r\n\r\n\t\tif(!local.init((DWORD_PTR*)remote, ctx.Rip)\r\n\t\t\t|| !WriteProcessMemory(ppi->hProcess, remote, &local, sizeof(opcode_data), NULL)) {\r\n\t\t\t\tVirtualFreeEx(ppi->hProcess, remote, 0, MEM_RELEASE);\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tFlushInstructionCache(ppi->hProcess, remote, sizeof(opcode_data));\r\n\t\t//FARPROC a=(FARPROC)remote;\r\n\t\t//a();\r\n\t\tctx.Rip = (DWORD_PTR)remote;\r\n\t\treturn !!SetThreadContext(ppi->hThread, &ctx);\r\n\t}\r\n}\r\n\r\n#endif\r\n\r\ntemplate <typename _TCHAR>\r\nint strlendb(const _TCHAR* psz)\r\n{\r\n\tconst _TCHAR* p = psz;\r\n\twhile (*p) {\r\n\t\tfor (; *p; p++);\r\n\t\tp++;\r\n\t}\r\n\treturn p - psz + 1;\r\n}\r\n\r\ntemplate <typename _TCHAR>\r\n_TCHAR* strdupdb(const _TCHAR* psz, int pad)\r\n{\r\n\tint len = strlendb(psz);\r\n\t_TCHAR* p = (_TCHAR*)calloc(sizeof(_TCHAR), len + pad);\r\n\tif(p) {\r\n\t\tmemcpy(p, psz, sizeof(_TCHAR) * len);\r\n\t}\r\n\treturn p;\r\n}\r\n\r\n\r\n\r\nbool MultiSzToArray(LPWSTR p, CArray<LPWSTR>& arr)\r\n{\r\n\tfor (; *p; ) {\r\n\t\tLPWSTR cp = _wcsdup(p);\r\n\t\tif(!cp || !arr.Add(cp)) {\r\n\t\t\tfree(cp);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tfor (; *p; p++);\r\n\t\tp++;\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nLPWSTR ArrayToMultiSz(CArray<LPWSTR>& arr)\r\n{\r\n\tsize_t cch = 1;\r\n\tfor (int i=0; i<arr.GetSize(); i++) {\r\n\t\tcch += wcslen(arr[i]) + 1;\r\n\t}\r\n\r\n\tLPWSTR pmsz = (LPWSTR)calloc(sizeof(WCHAR), cch);\r\n\tif (!pmsz)\r\n\t\treturn NULL;\r\n\r\n\tLPWSTR p = pmsz;\r\n\tfor (int i=0; i<arr.GetSize(); i++) {\r\n\t\tStringCchCopyExW(p, cch, arr[i], &p, &cch, STRSAFE_NO_TRUNCATION);\r\n\t\tp++;\r\n\t}\r\n\t*p = 0;\r\n\treturn pmsz;\r\n}\r\n\r\nbool AddPathEnv(CArray<LPWSTR>& arr, LPWSTR dir, int dirlen)\r\n{\r\n\tfor (int i=0; i<arr.GetSize(); i++) {\r\n\t\tLPWSTR env = arr[i];\r\n\t\tif (_wcsnicmp(env, L\"PATH=\", 5)) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tLPWSTR p = env + 5;\r\n\t\tLPWSTR pp = p;\r\n\t\tfor (; ;) {\r\n\t\t\tfor (; *p && *p != L';'; p++);\r\n\t\t\tint len = p - pp;\r\n\t\t\tif (len == dirlen && !_wcsnicmp(pp, dir, dirlen)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif (!*p)\r\n\t\t\t\tbreak;\r\n\t\t\tpp = p + 1;\r\n\t\t\tp++;\r\n\t\t}\r\n\r\n\t\tsize_t cch = wcslen(env) + MAX_PATH + 4;\r\n\t\tenv = (LPWSTR)realloc(env, sizeof(WCHAR) * cch);\r\n\t\tif(env) {\r\n\t\t\tStringCchCatW(env, cch, L\";\");\r\n\t\t\tStringCchCatW(env, cch, dir);\r\n\t\t\tarr[i] = env;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tsize_t cch = dirlen + sizeof(\"PATH=\") + 1;\r\n\tLPWSTR p = (LPWSTR)calloc(sizeof(WCHAR), cch);\r\n\tif(p) {\r\n\t\tStringCchCopyW(p, cch, L\"PATH=\");\r\n\t\tStringCchCatW(p, cch, dir);\r\n\t\tif (arr.Add(p)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tfree(p);\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nbool AddX64Env(CArray<LPWSTR>& arr)\r\n{\r\n\tFARPROC k32 = GetProcAddress(GetModuleHandle(L\"kernel32.dll\"), \"LoadLibraryW\");\r\n\tWCHAR szAddr[20] = { 0 };\r\n\t_ui64tow((DWORD64)k32, szAddr, 10);\r\n\t//wsprintf(szAddr, L\"%Ld\", (DWORD_PTR)k32);\r\n\tsize_t cch = wcslen(szAddr) + sizeof(\"MACTYPE_X64ADDR=\") + 1;\r\n\tLPWSTR p = (LPWSTR)calloc(sizeof(WCHAR), cch);\r\n\tif (p) {\r\n\t\tStringCchCopyW(p, cch, L\"MACTYPE_X64ADDR=\");\r\n\t\tStringCchCatW(p, cch, szAddr);\r\n\t\tif (arr.Add(p)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tfree(p);\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nEXTERN_C LPWSTR WINAPI GdippEnvironment(DWORD& dwCreationFlags, LPVOID lpEnvironment)\r\n{\r\n#ifndef _WIN64\r\n\treturn NULL;\r\n#endif\r\n\r\n\tTCHAR dir[MAX_PATH];\r\n\tint dirlen = GetModuleFileName(GetDLLInstance(), dir, MAX_PATH);\r\n\tLPTSTR lpfilename=dir+dirlen;\r\n\twhile (lpfilename>dir && *lpfilename!=_T('\\\\') && *lpfilename!=_T('/')) --lpfilename;\r\n\t*lpfilename = 0;\r\n\tdirlen = wcslen(dir);\r\n\r\n\tLPWSTR pEnvW = NULL;\r\n\tif (lpEnvironment) {\r\n\t\tif (dwCreationFlags & CREATE_UNICODE_ENVIRONMENT) {\r\n\t\t\tpEnvW = strdupdb((LPCWSTR)lpEnvironment, MAX_PATH + 1);\r\n\t\t} else {\r\n\t\t\tint alen = strlendb((LPCSTR)lpEnvironment);\r\n\t\t\tint wlen = MultiByteToWideChar(CP_ACP, 0, (LPCSTR)lpEnvironment, alen, NULL, 0) + 1;\r\n\t\t\tpEnvW = (LPWSTR)calloc(sizeof(WCHAR), wlen + MAX_PATH + 1);\r\n\t\t\tif (pEnvW) {\r\n\t\t\t\tMultiByteToWideChar(CP_ACP, 0, (LPCSTR)lpEnvironment, alen, pEnvW, wlen);\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\tLPWSTR block = (LPWSTR)GetEnvironmentStringsW();\r\n\t\tif (block) {\r\n\t\t\tpEnvW = strdupdb(block, MAX_PATH + 1);\r\n\t\t\tFreeEnvironmentStrings(block);\r\n\t\t}\r\n\t}\r\n\r\n\tif (!pEnvW) {\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tCArray<LPWSTR> envs;\r\n\tbool ret = MultiSzToArray(pEnvW, envs);\r\n\tfree(pEnvW);\r\n\tpEnvW = NULL;\r\n\t\r\n\t/*if (ret) {\r\n\t\tret = AddPathEnv(envs, dir, dirlen);\r\n\t}*/\r\n#ifdef _WIN64\r\n\t{\r\n\t\tGetEnvironmentVariableW(L\"MACTYPE_X64ADDR\", NULL, 0);\r\n\t\tif (GetLastError() == ERROR_ENVVAR_NOT_FOUND) {\r\n\t\t\tret = AddX64Env(envs);\r\n\t\t}\r\n\t}\r\n#endif\r\n\tif (ret) {\r\n\t\tpEnvW = ArrayToMultiSz(envs);\r\n\t}\r\n\r\n\tfor (int i=0; i<envs.GetSize(); free(envs[i++]));\r\n\r\n\tif (!pEnvW) {\r\n\t\treturn NULL;\r\n\t}\r\n\r\n#ifdef _DEBUG\r\n\t{\r\n\t\tLPWSTR tmp = strdupdb(pEnvW, 0);\r\n\t\tLPWSTR tmpe = tmp + strlendb(tmp);\r\n\t\tPathRemoveFileSpec(dir);\r\n\t\tfor (LPWSTR z=tmp; z<tmpe; z++)if(!*z)*z=L'\\n';\r\n\t\t\tStringCchCatW(dir,MAX_PATH,L\"\\\\\");\r\n\t\t\tStringCchCatW(dir,MAX_PATH,L\"gdienv.txt\");\r\n\t\t\tHANDLE hf = CreateFileW(dir,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,0,NULL);\r\n\t\t\tif(hf) {\r\n\t\t\tDWORD cb;\r\n\t\t\tWORD w = 0xfeff;\r\n\t\t\tWriteFile(hf,&w, sizeof(WORD), &cb, 0);\r\n\t\t\tWriteFile(hf,tmp, sizeof(WCHAR) * (tmpe - tmp), &cb, 0);\r\n\t\t\tSetEndOfFile(hf);\r\n\t\t\tCloseHandle(hf);\r\n\t\t\tfree(tmp);\r\n\t\t}\r\n\t}\r\n#endif\r\n\r\n\tdwCreationFlags |= CREATE_UNICODE_ENVIRONMENT;\r\n\treturn pEnvW;\r\n}\r\n\r\nvoid DebugOut(const WCHAR* szFormat, ...) {\r\n#ifdef TRACE\r\n\tva_list args;\r\n\tva_start(args, szFormat);\r\n\tWCHAR buffer[1024] = { 0 };\r\n\tvswprintf(buffer, szFormat, args);\r\n\tstd::wstring fullmsg = L\"[MTCore] \" + std::wstring(buffer);\r\n\tOutputDebugString(fullmsg.c_str());\r\n#endif\r\n}"
        },
        {
          "name": "expfunc.def",
          "type": "blob",
          "size": 0.2587890625,
          "content": ";LIBRARY MacType.dll\nEXPORTS\n\tGetMsgProc @1\n\tDllGetVersion = GdippDllGetVersion @2\n;\tSafeUnload @3\n\tCreateControlCenter @4\n\tReloadConfig @5\n;;\tGdippInjectDLL\n;\tGdippInstallHook\n;\tGdippRemoveHook\n;\tGdippUnloadALL\n;\tGdippApplyNewSettings\n;\tGdippApplyNewSettingsToALL\n"
        },
        {
          "name": "ft - non-ref.cpp",
          "type": "blob",
          "size": 86.9521484375,
          "content": "/* 2006-10-23(by 555)\n * http://hp.vector.co.jp/authors/VA028002/winfreetype.c (higambana(菅野友紀))\n * を丸写し\n */\n/* 2006-10-27(by 555)\n * http://hp.vector.co.jp/authors/VA028002/freetype.html (higambana(菅野友紀))\n * を参考にしてやり直し\n */\n/* 2006-10-29(by 555)\n * 693氏(と呼ぶことにする)の精力的な活動によって出来上がったウハウハソースと\n * 上記サイトの変更点を元にみみっちい修正。(ベースgdi0164)\n */\n/* (by 555)\n * さらに線引きもウハウハにしてもらったgdi0168を元に\n * イタリックとボールドを追加。\n */\n/* (by sy567)\n * 太字のアルゴリズムを変更。\n * ガンマ補正を実装してみる。\n */\n#include \"override.h\"\n#include \"ft.h\"\n#include <windows.h>\n//#include <windowsx.h>\n#include <tchar.h>\n\n#include <math.h>\n\n#include <ft2build.h>\n#include <tttables.h>\n#include <freetype.h>\t/* FT_FREETYPE_H */\n#include <ftcache.h>\t/* FT_CACHE_H */\n//#include <tttags.h>\t// FT_TRUETYPE_TAGS_H\n//#include <tttables.h>\t// FT_TRUETYPE_TABLES_H\n#include <ftoutln.h>\t// FT_OUTLINE_H\n#include <fttrigon.h>\t//FT_TRIGONOMETRY_H\n\n#ifdef FT_LCD_FILTER_H\n#include <ftlcdfil.h>\t// FT_LCD_FILTER_H\n#endif\n\n#include \"fteng.h\"\n\n#include \"ft2vert.h\"\n\nFT_BitmapGlyphRec empty_glyph = {};//优化控制字\n\n#define FT_BOLD_LOW 15\n#define IsFontBold(lf)\t\t((lf).lfWeight >= FW_BOLD)\n#define FT_FixedToInt(x)\t(FT_RoundFix(x) >> 16)\n#define FT_PosToInt(x)\t\t(((x) + (1 << 5)) >> 6)\n#define RESOLUTION_X 72\n#define RESOLUTION_Y 72\nFT_Error New_FT_Outline_Embolden( FT_Outline*  outline, FT_Pos str_h, FT_Pos str_v, FT_Int font_size);\nFT_Error Old_FT_Outline_Embolden( FT_Outline*  outline, FT_Pos strength );\nFT_Error Vert_FT_Outline_Embolden( FT_Outline*  outline, FT_Pos strength );\nControlIder CID;\n\n#if _MSC_VER <= 1200\n#pragma warning(disable: 4786)\n#endif\n\n\n//更新\n#define RGBA(r,g,b,a)          ((COLORREF)(((BYTE)(r)|((WORD)((BYTE)(g))<<8))|(((DWORD)(BYTE)(b))<<16)|(((DWORD)(BYTE)(a))<<24)))\n//!!Snowie\n\nCOLORREF GetPaletteColor(HDC hdc, UINT paletteindex)\n{\n\t//if ((paletteindex>>28)%2) return 0;\n\tHPALETTE hpal=(HPALETTE)GetCurrentObject(hdc, OBJ_PAL);\n\tPALETTEENTRY lppe={};\n\tmemset(&lppe, 0, sizeof(lppe));\n\tGetPaletteEntries(hpal, paletteindex&0xffff, 1, &lppe);\n\treturn RGB(lppe.peRed, lppe.peGreen, lppe.peBlue);\n}\n\n\nvoid Log(char* Msg)\n{\t\n#ifndef _DEBUG\n\treturn;\n#endif\n\tFILE* f=fopen(\".\\\\gdipp.log\",\"a\");\n\tfputs(Msg, f);\n\tfclose(f);\n}\n\nvoid Log(wchar_t* Msg)\n{\t\n#ifndef _DEBUG\n\treturn;\n#endif\n\tFILE* f=_wfopen(L\".\\\\gdipp.log\",L\"a,ccs=UNICODE\");\n\tfputws(Msg, f);\n\tfclose(f);\n}\n\nclass CAlphaBlend\n{\nprivate:\n\tint alphatbl[256];\n\tint tbl1[257];\n\tBYTE tbl2[256 * 16 + 1];\n\t// 通常のアルファ値補正\n\tint tunetbl[256];\n\tint tunetblR[256];\n\tint tunetblG[256];\n\tint tunetblB[256];\n\t// 影文字用のアルファ値補正\n\tint tunetblS[256];\n\tint tunetblRS[256];\n\tint tunetblGS[256];\n\tint tunetblBS[256];\n\n\tint tunetblLS[256];\n\tint tunetblLRS[256];\n\tint tunetblLGS[256];\n\tint tunetblLBS[256];\n\t//Snowie!!\n\tdouble RGB2CRT[256];\t//table used for RGB<->Lab\npublic:\n\tstatic const int BASE;\npublic:\n\tCAlphaBlend() { }\n\t~CAlphaBlend() {}\n\tvoid init();\n\tvoid initRGB();\n\tdouble* GetRGBTable() { return RGB2CRT; }\n\tBYTE doAB(BYTE fg, BYTE bg, int alpha);\n\tvoid gettunetbl(int paramalpha, BOOL lcd, BOOL dark, const int * &tblR, const int * &tblG, const int * &tblB) const;\n\tinline int conv1(BYTE n) {\n\t\treturn tbl1[n];\n\t}\n\tinline BYTE conv2(int n) {\n\t\treturn tbl2[n / (BASE * BASE / (sizeof tbl2 - 1))];\n\t}\nprivate:\n\tinline int convalpha(int alpha) {\n\t\treturn alphatbl[alpha];\n\t}\n\tinline BYTE rconv1(int n);\n};\nconst int CAlphaBlend::BASE = 0x4000;\n\nstatic CAlphaBlend s_AlphaBlendTable;\n\nvoid CAlphaBlend::gettunetbl(int paramalpha, BOOL lcd, BOOL dark, const int * &tblR, const int * &tblG, const int * &tblB) const\n{\n\tif (paramalpha == 1) {\t//获取文字混合表\n\t\tif (lcd) {\n\t\t\ttblR = tunetblR;\n\t\t\ttblG = tunetblG;\n\t\t\ttblB = tunetblB;\n\t\t} else {\n\t\t\ttblR = tblG = tblB = tunetbl;\n\t\t}\n\t} else {\t//获取阴影混合表\n\t\tif (dark)\n\t\t{\n\t\t\tif (lcd) {\n\t\t\t\ttblR = tunetblRS;\n\t\t\t\ttblG = tunetblGS;\n\t\t\t\ttblB = tunetblBS;\n\t\t\t} else {\n\t\t\t\ttblR = tblG = tblB = tunetblS;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (lcd) {\n\t\t\t\ttblR = tunetblLRS;\n\t\t\t\ttblG = tunetblLGS;\n\t\t\t\ttblB = tunetblLBS;\n\t\t\t} else {\n\t\t\t\ttblR = tblG = tblB = tunetblLS;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid CAlphaBlend::initRGB()\n{\n\tfor (int i=0; i<256; i++)\n\t\tRGB2CRT[i] = pow(i/255.0, 2.2);\n}\n\nvoid CAlphaBlend::init()\n{\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\n\tconst float gamma = pSettings->GammaValue();\n\tconst float weight = pSettings->RenderWeight();\n\tconst float contrast = pSettings->Contrast();\n\tconst int mode = pSettings->GammaMode();\n\t\n\tint i;\n\tfloat temp, alpha;\n\t\n\tfor (i = 0; i < 256; ++i) {\n\t\ttemp = pow((1.0f / 255.0f) * i, 1.0f / weight);\n\n\t\tif  (temp < 0.5f) {\n\t\t\talpha = pow(temp * 2, contrast) / 2.0f;\n\t\t} else {\n\t\t\talpha = 1.0f - pow((1.0f - temp) * 2, contrast) / 2.0f;\n\t\t}\n\t\talphatbl[i] = (int)(alpha * BASE);\n\n\t\tif (mode < 0) {\n\t\t\ttemp = (1.0f / 255.0f) * i;\n\t\t} else {\n\t\t\tif (mode == 1) {\n\t\t\t\tif (i <= 10) {\n\t\t\t\t\ttemp = (float)i / (12.92f * 255.0f);\n\t\t\t\t} else {\n\t\t\t\t\ttemp = pow(((1.0f / 255.0f) * i + 0.055f) / 1.055f, 2.4f);\n\t\t\t\t}\n\t\t\t} else if (mode == 2) {\n\t\t\t\tif (i <= 10) {\n\t\t\t\t\ttemp = ((float)i / (12.92f * 255.0f) + (float)i / 255.0f) / 2;\n\t\t\t\t} else {\n\t\t\t\t\ttemp = (pow(((1.0f / 255.0f) * i + 0.055f) / 1.055f, 2.4f) + (float)i / 255.0f) / 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttemp = pow((1.0f / 255.0f) * i, gamma);\n\t\t\t}\n\t\t}\n\t\ttbl1[i] = (int)(temp * BASE);\n\t}\n\n\ttbl1[i] = BASE;\n\n\tfor (i = 0; i <= sizeof tbl2 - 1; ++i) {\n\t\ttbl2[i] = rconv1(i * (BASE / (sizeof tbl2 - 1)));\n\t}\n\n\tconst int* table = pSettings->GetTuneTable();\n\tconst int* tableR = pSettings->GetTuneTableR();\n\tconst int* tableG = pSettings->GetTuneTableG();\n\tconst int* tableB = pSettings->GetTuneTableB();\n\tconst int* shadow = pSettings->GetShadowParams();\n\tconst int paramalpha = Max(shadow[2], 1);\n\tconst int lightparamalpha = Max(shadow[3], 1);\n\n\tfor (i = 0; i < 256; ++i) {\n\t\ttunetbl[i] = Bound(0, alphatbl[Bound(table[i], 0, 255)], CAlphaBlend::BASE);\n\t\ttunetblR[i] = Bound(0, alphatbl[Bound(tableR[i], 0, 255)], CAlphaBlend::BASE);\n\t\ttunetblG[i] = Bound(0, alphatbl[Bound(tableG[i], 0, 255)], CAlphaBlend::BASE);\n\t\ttunetblB[i] = Bound(0, alphatbl[Bound(tableB[i], 0, 255)], CAlphaBlend::BASE);\n\t\ttunetblS[i] = Bound(0, alphatbl[Bound(table[i] * paramalpha /100, 0, 255)], CAlphaBlend::BASE);\n\t\ttunetblRS[i] = Bound(0, alphatbl[Bound(tableR[i] * paramalpha/100, 0, 255)], CAlphaBlend::BASE);\n\t\ttunetblGS[i] = Bound(0, alphatbl[Bound(tableG[i] * paramalpha/100, 0, 255)], CAlphaBlend::BASE);\n\t\ttunetblBS[i] =Bound(0,  alphatbl[Bound(tableB[i] * paramalpha/100, 0, 255)], CAlphaBlend::BASE);\t//浅色混合表\n\n\t\ttunetblLS[i] = Bound(0, alphatbl[Bound(table[i] * lightparamalpha/100, 0, 255)], CAlphaBlend::BASE);\n\t\ttunetblLRS[i] = Bound(0, alphatbl[Bound(tableR[i] * lightparamalpha/100, 0, 255)], CAlphaBlend::BASE);\n\t\ttunetblLGS[i] = Bound(0, alphatbl[Bound(tableG[i] * lightparamalpha/100, 0, 255)], CAlphaBlend::BASE);\n\t\ttunetblLBS[i] =Bound(0,  alphatbl[Bound(tableB[i] * lightparamalpha/100, 0, 255)], CAlphaBlend::BASE);\t//深色混合表\n\t}\n}\n\nBYTE CAlphaBlend::rconv1(int n)\n{\n\tint pos = 0x80;\n\tint i = pos >> 1;\n\twhile (i > 0) {\n\t\tif (n >= tbl1[pos]) {\n\t\t\tpos += i;\n\t\t} else {\n\t\t\tpos -= i;\n\t\t}\n\t\ti >>= 1;\n\t}\n\tif (n >= tbl1[pos]) {\n\t\t++pos;\n\t}\n\treturn (BYTE)(pos - 1);\n}\n\nclass CAlphaBlendColorOne\n{\nprivate:\n\tBYTE fg;\n\tint temp_fg;\n\tconst int *tunetbl;\n\tBYTE bg0;\n\tint alpha0;\n\tBYTE c0;\npublic:\n\tCAlphaBlendColorOne()\n\t\t: fg(0), temp_fg(0), tunetbl(NULL), bg0(0), alpha0(0), c0(0) {}\n\tvoid init(BYTE f, const int *tbl);\n\t~CAlphaBlendColorOne() {};\n\tBYTE doAB(BYTE bg, int alpha);\n};\n\nFORCEINLINE void CAlphaBlendColorOne::init(BYTE f, const int *tbl)\n{\n\tfg = f;\n\ttemp_fg = s_AlphaBlendTable.conv1(fg);\n\ttunetbl = tbl;\n}\n\nFORCEINLINE BYTE CAlphaBlendColorOne::doAB(BYTE bg, int alpha)\n{\n\tint temp_alpha = tunetbl[alpha];\n\n\treturn temp_alpha ? s_AlphaBlendTable.conv2(s_AlphaBlendTable.conv1(bg) * (s_AlphaBlendTable.BASE - tunetbl[alpha]) +\n\t\t\t\ttemp_fg * tunetbl[alpha]) : bg;\n\t\n}\n\nclass CAlphaBlendColor\n{\nprivate:\n\tCAlphaBlendColorOne r;\n\tCAlphaBlendColorOne g;\n\tCAlphaBlendColorOne b;\npublic:\n\tCAlphaBlendColor( COLORREF newColor, int paramalpha, BOOL lcd, BOOL dark, bool gbr = false);\n\t~CAlphaBlendColor() { }\n\tBYTE doABsub(BYTE fg, int temp_fg, BYTE bg, int temp_alpha) const;\n\tCOLORREF doAB(COLORREF baseColor, int alphaR, int alphaG, int alphaB, BOOL bClearAlpha);\n\tCOLORREF doAB(COLORREF baseColor, int alpha, BOOL bClearAlpha) {\n\t\treturn doAB(baseColor, alpha, alpha, alpha, bClearAlpha);\n\t}\nprivate:\n\tCAlphaBlendColor() { }\n};\n\nFORCEINLINE CAlphaBlendColor::CAlphaBlendColor( COLORREF newColor, int paramalpha, BOOL lcd, BOOL dark, bool gbr)\n{\n\tconst int *tblR;\n\tconst int *tblG;\n\tconst int *tblB;\n\ts_AlphaBlendTable.gettunetbl(paramalpha, lcd, dark, tblR, tblG, tblB);\n\tif (!gbr) {\n\t\tr.init(GetRValue(newColor), tblR);\n\t\tb.init(GetBValue(newColor), tblB);\n\t} else {\n\t\tr.init(GetBValue(newColor), tblB);\n\t\tb.init(GetRValue(newColor), tblR);\n\t}\n\tg.init(GetGValue(newColor), tblG);\n}\n\nFORCEINLINE COLORREF CAlphaBlendColor::doAB(COLORREF baseColor, int alphaR, int alphaG, int alphaB, BOOL bClearAlpha)\n{\n\tif (alphaB | alphaG | alphaR)\n\t{\n\t\tif (bClearAlpha)\n\t\t\treturn RGB(r.doAB(GetRValue(baseColor), alphaR),\n\t\t\t\t\tg.doAB(GetGValue(baseColor), alphaG),\n\t\t\t\t\tb.doAB(GetBValue(baseColor), alphaB));\n\t\telse\n\t\t\treturn RGBA(r.doAB(GetRValue(baseColor), alphaR),\n\t\t\t\t\tg.doAB(GetGValue(baseColor), alphaG),\n\t\t\t\t\tb.doAB(GetBValue(baseColor), alphaB),\n\t\t\t\t\tbaseColor>>24);\n\t}\n\telse\n\t\treturn baseColor;\n}\n\nFORCEINLINE BYTE CAlphaBlend::doAB(BYTE fg, BYTE bg, int alpha)\n{\n\tif (fg == bg || alpha <= 0) return bg;\n\tif (alpha >= 255) return fg;\n\tint temp_alpha = convalpha(alpha);\n\tint temp_bg = conv1(bg);\n\tint temp_fg = conv1(fg);\n\tint temp = temp_bg * (BASE - temp_alpha) +\n\t\t\ttemp_fg * temp_alpha;\n\treturn conv2(temp);\n}\n\nFORCEINLINE BYTE DoAlphaBlend(BYTE fg, BYTE bg, int alpha)\n{\n\treturn s_AlphaBlendTable.doAB(fg, bg, alpha);\n}\n\n// LCD(液晶)用のアルファブレンド(サブピクセルレンダリング)\nstatic FORCEINLINE\nCOLORREF AlphaBlendColorLCD(\n\t\tCOLORREF baseColor,\n\t\tCOLORREF newColor,\n\t\tint alphaR, int alphaG, int alphaB,\n\t\tconst int* tableR, const int* tableG, const int* tableB,\n\t\tconst FreeTypeDrawInfo& ftdi)\n{\n\tconst BYTE rs = GetRValue(baseColor);\n\tconst BYTE gs = GetGValue(baseColor);\n\tconst BYTE bs = GetBValue(baseColor);\n\tBYTE rd = GetRValue(newColor);\n\tBYTE gd = GetGValue(newColor);\n\tBYTE bd = GetBValue(newColor);\n\t// アルファ値を補正\n\talphaR = tableR[alphaR] / ftdi.params->alpha;\n\talphaG = tableG[alphaG] / ftdi.params->alpha;\n\talphaB = tableB[alphaB] / ftdi.params->alpha;\n//\trd = (((rd - rs) * alphaR) / 255) + rs;\n//\tgd = (((gd - gs) * alphaG) / 255) + gs;\n//\tbd = (((bd - bs) * alphaB) / 255) + bs;\n\trd = DoAlphaBlend(rd, rs, alphaR);\n\tgd = DoAlphaBlend(gd, gs, alphaG);\n\tbd = DoAlphaBlend(bd, bs, alphaB);\n\treturn RGB(rd, gd, bd);\n}\n\n// アルファブレンド(256階調)\nstatic FORCEINLINE\nCOLORREF AlphaBlendColor(\n\t\tCOLORREF baseColor,\n\t\tCOLORREF newColor,\n\t\tint alpha, const int* table,\n\t\tconst FreeTypeDrawInfo& ftdi)\n{\n\tconst BYTE rs = GetRValue(baseColor);\n\tconst BYTE gs = GetGValue(baseColor);\n\tconst BYTE bs = GetBValue(baseColor);\n\tBYTE rd = GetRValue(newColor);\n\tBYTE gd = GetGValue(newColor);\n\tBYTE bd = GetBValue(newColor);\n\t// アルファ値を補正\n\talpha = table[alpha] / ftdi.params->alpha;\n//\trd = (rs * (255 - alpha) + rd * alpha) / 255;\n//\tgd = (gs * (255 - alpha) + gd * alpha) / 255;\n//\tbd = (bs * (255 - alpha) + bd * alpha) / 255;\n\n//\trd = (((rd - rs) * alpha) / 255) + rs;\n//\tgd = (((gd - gs) * alpha) / 255) + gs;\n//\tbd = (((bd - bs) * alpha) / 255) + bs;\n\trd = DoAlphaBlend(rd, rs, alpha);\n\tgd = DoAlphaBlend(gd, gs, alpha);\n\tbd = DoAlphaBlend(bd, bs, alpha);\n\treturn RGB(rd, gd, bd);\n}\n\ntypedef struct  \n{\n\tFreeTypeDrawInfo* FTInfo;\t\t\t//orignal draw information\n\tWCHAR wch;\t\t\t\t\t\t\t//text to draw\n\tFT_BitmapGlyph FTGlyph;\t\t\t//glyph\n\tint\tAAMode;\t\t\t\t\t\t\t//antialiased mode for every char\n\tCAlphaBlendColor* solid;\n\tCAlphaBlendColor* shadow;\t//alpha blender\n} FreeTypeGlyphInfo, *PFreeTypeGlyphInfo;\n\n\n// 2階調\nstatic void FreeTypeDrawBitmapPixelModeMono(FreeTypeGlyphInfo& FTGInfo,\n\t\t\t\t\t\t\t\t\t\t\tCAlphaBlendColor& ab, int x, int y)\n{\n\tCBitmapCache& cache = *FTGInfo.FTInfo->pCache;\n\tconst FT_Bitmap *bitmap = &FTGInfo.FTGlyph->bitmap;\n\tBYTE alphatuner = FTGInfo.FTInfo->params->alphatuner;\n\tint i, j;\n\tint dx, dy;\t// display\n\tFT_Bytes p;\n\n\tif(bitmap->pixel_mode != FT_PIXEL_MODE_MONO){\n\t\treturn;\n\t}\n\n\tconst COLORREF color = RGB2DIB(FTGInfo.FTInfo->Color());\n\n\tconst SIZE cachebufsize = cache.Size();\n\tDWORD * const cachebufp = (DWORD *)cache.GetPixels();\n\tDWORD * cachebufrowp;\n\n\tint left, top, width, height;\n\tif (x < 0) {\n\t\tleft = -x;\n\t\tx = 0;\n\t} else {\n\t\tleft = 0;\n\t}\n\twidth = Min((int)bitmap->width, (int)(cachebufsize.cx - x));\n\ttop = 0;\n\theight = bitmap->rows;\n\n\tfor(j = top, dy = y; j < height; ++j, ++dy){\n\t\tif ((unsigned int)dy >= (unsigned int)cachebufsize.cy) continue;\n\t\tp = bitmap->pitch < 0 ?\n\t\t\t&bitmap->buffer[(-bitmap->pitch * bitmap->rows) - bitmap->pitch * j] :\t// up-flow\n\t\t\t&bitmap->buffer[bitmap->pitch * j];\t// down-flow\n\t\tcachebufrowp = &cachebufp[dy * cachebufsize.cx];\n\t\tfor(i = left, dx = x; i < width; ++i, ++dx){\n\t\t\tif((p[i / 8] & (1 << (7 - (i % 8)))) != 0){\n\t\t\t\tcachebufrowp[dx] = color;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// LCD(液晶)用描画(サブピクセルレンダリング)\n// RGB順(のはず)\nstatic void FreeTypeDrawBitmapPixelModeLCD(FreeTypeGlyphInfo& FTGInfo,\n\t\tCAlphaBlendColor& ab, int x, int y)\n{\n\tCBitmapCache& cache = *FTGInfo.FTInfo->pCache;\n\tconst FT_Bitmap *bitmap = &FTGInfo.FTGlyph->bitmap;\n\tBYTE alphatuner = FTGInfo.FTInfo->params->alphatuner;\n\tint AAMode = FTGInfo.AAMode;\n\tint i, j;\n\tint dx, dy;\t// display\n\tFT_Bytes p;\n\n\tif(bitmap->pixel_mode != FT_PIXEL_MODE_LCD){\n\t\treturn;\n\t}\n\n\tconst COLORREF color = FTGInfo.FTInfo->Color();\n\n\tconst SIZE cachebufsize = cache.Size();\n\tDWORD * const cachebufp = (DWORD *)cache.GetPixels();\n\tDWORD * cachebufrowp;\n\n\t// LCDは3サブピクセル分ある\n\tint left, top, width, height;\n\tif (x < 0) {\n\t\tleft = -x * 3;\n\t\tx = 0;\n\t} else {\n\t\tleft = 0;\n\t}\n\twidth = Min((int)bitmap->width, (int)(cachebufsize.cx - x) * 3);\n\ttop = 0;\n\theight = bitmap->rows;\n\t//CAlphaBlendColor ab(color, ftdi.params->alpha, true, true);\n\n\tCOLORREF backColor, newColor;\n\tunsigned int alphaR, alphaG, alphaB;\n\tBOOL bAlphaDraw = FTGInfo.FTInfo->params->alpha!=1;\n\n\tif (bAlphaDraw)\n\t\tfor(j = 0, dy = y; j < height; ++j, ++dy){\n\t\tif ((unsigned int)dy >= (unsigned int)cachebufsize.cy) continue;\n\n\t\tp = bitmap->pitch < 0 ?\n\t\t\t&bitmap->buffer[(-bitmap->pitch * bitmap->rows) - bitmap->pitch * j] :\t// up-flow\n\t\t\t&bitmap->buffer[bitmap->pitch * j];\t// down-flow\n\n\t\tcachebufrowp = &cachebufp[dy * cachebufsize.cx];\n\t\tfor(i = left, dx = x; i < width; i += 3, ++dx){\n\t\t\tbackColor = cachebufrowp[dx];\n\t\t\tCOLORREF last=0xFFFFFFFF;\n\t\t\tif(AAMode == 2 || AAMode == 4){\n\t\t\t\t// これはRGBの順にサブピクセルがあるディスプレイ用\n\t\t\t\t// これはRGBの順にサブピクセルがあるディスプレイ用\n\t\t\t\talphaR = p[i + 0] / alphatuner; \n\t\t\t\talphaG = p[i + 1] / alphatuner;\n\t\t\t\talphaB = p[i + 2] / alphatuner;\n\t\t\t}else{\n\t\t\t\t// BGR\n\t\t\t\talphaR = p[i + 2] / alphatuner;\n\t\t\t\talphaG = p[i + 1] / alphatuner;\n\t\t\t\talphaB = p[i + 0] / alphatuner;\n\t\t\t}\n/*\n\t\t\tif (bAlphaDraw)\n\t\t\t{\n\t\t\t\tif (alphaB && alphaG && alphaR)\n\t\t\t\t\tbackColor &= 0x00ffffff;\n\t\t\t}\n\t\t\telse*/\n\n\t\t\t//if ((alphaB || alphaG || alphaR))\n\t\t\t//\tbackColor &= 0x00ffffff;\n\t\t\t newColor = ab.doAB(backColor, alphaB, alphaG, alphaR, !bAlphaDraw);\n\t\t\t cachebufrowp[dx] = newColor;\n\t\t}\n\t}\n\telse\n\tfor(j = 0, dy = y; j < height; ++j, ++dy){\n\t\tif ((unsigned int)dy >= (unsigned int)cachebufsize.cy) continue;\n\n\t\tp = bitmap->pitch < 0 ?\n\t\t\t&bitmap->buffer[(-bitmap->pitch * bitmap->rows) - bitmap->pitch * j] :\t// up-flow\n\t\t\t&bitmap->buffer[bitmap->pitch * j];\t// down-flow\n\n\t\tcachebufrowp = &cachebufp[dy * cachebufsize.cx];\n\t\tfor(i = left, dx = x; i < width; i += 3, ++dx){\n\t\t\tbackColor = cachebufrowp[dx];\n\t\t\tCOLORREF last=0xFFFFFFFF;\n\t\t\tif(AAMode == 2 || AAMode == 4){\n\t\t\t\t// これはRGBの順にサブピクセルがあるディスプレイ用\n\t\t\t\t// これはRGBの順にサブピクセルがあるディスプレイ用\n\t\t\t\talphaR = p[i + 0]; \n\t\t\t\talphaG = p[i + 1];\n\t\t\t\talphaB = p[i + 2];\n\t\t\t}else{\n\t\t\t\t// BGR\n\t\t\t\talphaR = p[i + 2];\n\t\t\t\talphaG = p[i + 1];\n\t\t\t\talphaB = p[i + 0];\n\t\t\t}\n/*\n\t\t\tif (bAlphaDraw)\n\t\t\t{\n\t\t\t\tif (alphaB && alphaG && alphaR)\n\t\t\t\t\tbackColor &= 0x00ffffff;\n\t\t\t}\n\t\t\telse*/\n\n\t\t\t//if ((alphaB || alphaG || alphaR))\n\t\t\t//\tbackColor &= 0x00ffffff;\n\t\t\t newColor = ab.doAB(backColor, alphaB, alphaG, alphaR, !bAlphaDraw);\n\t\t\t cachebufrowp[dx] = newColor;\n\t\t}\n\t}\n}\n\nstatic void FreeTypeDrawBitmapGray(FreeTypeGlyphInfo& FTGInfo, CAlphaBlendColor& ab, int x, int y)\n{\n\tint i, j;\n\tint dx, dy;\t// display\n\tCOLORREF c;\n\tFT_Bytes p;\n\n\tCBitmapCache& cache = *FTGInfo.FTInfo->pCache;\n\tconst FT_Bitmap *bitmap = &FTGInfo.FTGlyph->bitmap;\n\tBYTE alphatuner = FTGInfo.FTInfo->params->alphatuner;\n\n\tBOOL bAlphaDraw = FTGInfo.FTInfo->params->alpha!=1;\n\tconst COLORREF color = FTGInfo.FTInfo->Color();\n\tconst SIZE cachebufsize = cache.Size();\n\tDWORD * const cachebufp = (DWORD *)cache.GetPixels();\n\tDWORD * cachebufrowp;\n\n\tint left, top, width, height;\n\tif (x < 0) {\n\t\tleft = -x;\n\t\tx = 0;\n\t} else {\n\t\tleft = 0;\n\t}\n\twidth = Min((int)bitmap->width, (int)(cachebufsize.cx - x));\n\ttop = 0;\n\theight = bitmap->rows;\n\n\t//\tCAlphaBlendColor ab(color, ftdi.params->alpha, false, true);\n\n\tCOLORREF backColor;\n\tint alpha;\n\n\tfor(j = top, dy = y; j < height; ++j, ++dy){\n\t\tif ((unsigned int)dy >= (unsigned int)cachebufsize.cy) continue;\n\t\tp = bitmap->pitch < 0 ?\n\t\t\t&bitmap->buffer[(-bitmap->pitch * bitmap->rows) - bitmap->pitch * j] :\t// up-flow\n\t\t&bitmap->buffer[bitmap->pitch * j];\t// down-flow\n\t\tcachebufrowp = &cachebufp[dy * cachebufsize.cx];\n\t\tfor(i = left, dx = x; i < width; ++i, ++dx){\n\t\t\talpha = p[i];\n\t\t\tbackColor = cachebufrowp[dx];\n\t\t\tc = ab.doAB(backColor, alpha, !bAlphaDraw);\n\t\t\tcachebufrowp[dx] = c;\n\t\t}\n\t}\n}\n\n// グリフビットマップのレンダリング\nstatic void FreeTypeDrawBitmap(\n\t\tFreeTypeGlyphInfo& FTGInfo,\n\t\tCAlphaBlendColor& ab,\n\t\tint x, int y)\n{\n\tif(FTGInfo.FTGlyph->bitmap.pixel_mode != FT_PIXEL_MODE_GRAY){\n\t\t// この関数自体はFT_PIXEL_MODE_GRAYにのみ対応し他に委譲する\n\t\tswitch(FTGInfo.FTGlyph->bitmap.pixel_mode){\n\t\tcase FT_PIXEL_MODE_MONO:\n\t\t\tFreeTypeDrawBitmapPixelModeMono(FTGInfo, ab, x, y);\n\t\t\tbreak;\n\t\tcase FT_PIXEL_MODE_LCD:\n\t\t\tFreeTypeDrawBitmapPixelModeLCD(FTGInfo, ab, x, y);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\t\t// 未対応\n\t\t}\n\t\treturn;\n\t}\n\tFreeTypeDrawBitmapGray(FTGInfo, ab, x, y);\n}\n\n// 縦書き用のレンダリング(コピペ手抜き)\n// 2階調\nstatic void FreeTypeDrawBitmapPixelModeMonoV(FreeTypeGlyphInfo& FTGInfo,\n\t\t\t\t\t\t\t\t\t\t\t CAlphaBlendColor& ab, int x, int y)\n{\n\tCBitmapCache& cache = *FTGInfo.FTInfo->pCache;\n\tFT_Bitmap *bitmap = &FTGInfo.FTGlyph->bitmap;\n\tint i, j;\n\tint dx, dy;\t// display\n\tFT_Bytes p;\n\n\tif(bitmap->pixel_mode != FT_PIXEL_MODE_MONO){\n\t\treturn;\n\t}\n\n\tconst COLORREF color = FTGInfo.FTInfo->Color();\n\n\tconst int width = bitmap->width;\n\tconst int height = bitmap->rows;\n\n\tfor(j = 0, dy = x; j < height; ++j, ++dy){\n\t\tp = bitmap->pitch < 0 ?\n\t\t\t&bitmap->buffer[(-bitmap->pitch * bitmap->rows) - bitmap->pitch * j] :\t// up-flow\n\t\t\t&bitmap->buffer[bitmap->pitch * j];\t// down-flow\n\t\tfor(i = 0, dx = y+width; i < width; ++i, --dx){\n\t\t\tif((p[i / 8] & (1 << (7 - (i % 8)))) != 0){\n\t\t\t\tif (cache.GetPixel(dx, dy) != CLR_INVALID) { // dx dy エラーチェック\n\t\t\t\t\tcache.SetCurrentPixel(color);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// LCD(液晶)用描画(サブピクセルレンダリング)\n// RGB順(のはず)\nstatic void FreeTypeDrawBitmapPixelModeLCDV(FreeTypeGlyphInfo& FTGInfo,\n\t\t\t\t\t\t\t\t\t\t\tCAlphaBlendColor& ab, int x, int y)\n{\n\tCBitmapCache& cache = *FTGInfo.FTInfo->pCache;\n\tconst FT_Bitmap *bitmap = &FTGInfo.FTGlyph->bitmap;\n\tBYTE alphatuner = FTGInfo.FTInfo->params->alphatuner;\n\tint AAMode = FTGInfo.AAMode;\n\tint i, j;\n\tint dx, dy;\t// display\n\tCOLORREF c;\n\tFT_Bytes p;\n\n\tif(bitmap->pixel_mode != FT_PIXEL_MODE_LCD_V){\n\t\treturn;\n\t}\n\n\tconst COLORREF color = FTGInfo.FTInfo->Color();\n\n\t// LCDは3サブピクセル分ある\n\tconst int width = bitmap->width;\n\tconst int height = bitmap->rows;\n\tconst int pitch = bitmap->pitch;\n\tconst int pitchabs = pitch < 0 ? -pitch : pitch;\n\tBOOL bAlphaDraw = FTGInfo.FTInfo->params->alpha!=1;\n\t//CAlphaBlendColor ab(color, ftdi.params->alpha, true);\n\n\tif (bAlphaDraw)\n\t\tfor(j = 0, dy = x; j < height; j += 3, ++dy){\n\t\t\tp = pitch < 0 ?\n\t\t\t\t&bitmap->buffer[(pitchabs * bitmap->rows) + pitchabs * j] :\t// up-flow\n\t\t\t\t&bitmap->buffer[pitchabs * j];\t// down-flow\n\n\t\t\tint alphaR, alphaG, alphaB;\n\t\t\tfor(i = 0, dx = y+width; i < width; ++i, --dx){\n\t\t\t\tCOLORREF backColor = cache.GetPixel(dy, dx);\n\n\t\t\t\tif (backColor == color || backColor == CLR_INVALID) continue;\n\t\t\t\tif(AAMode == 2 || AAMode == 4){\n\t\t\t\t\t// これはRGBの順にサブピクセルがあるディスプレイ用\n\t\t\t\t\talphaR = p[i + 0] / alphatuner;\n\t\t\t\t\talphaG = p[i + pitch] / alphatuner;\n\t\t\t\t\talphaB = p[i + pitch * 2] / alphatuner;\n\t\t\t\t}else{\n\t\t\t\t\t// BGR\n\t\t\t\t\talphaR = p[i + pitch * 2]/ alphatuner;\n\t\t\t\t\talphaG = p[i + pitch]/ alphatuner;\n\t\t\t\t\talphaB = p[i + 0]/ alphatuner;\n\t\t\t\t}\n\n\t\t\t\tc = ab.doAB(backColor, alphaR, alphaG, alphaB, !bAlphaDraw);\n\t\t\t\tcache.SetCurrentPixel(c);\n\t\t\t}\n\n\t\t\tif (i >= width)\n\t\t\t\tcontinue;\n\t\t}\n\telse\n\t\tfor(j = 0, dy = x; j < height; j += 3, ++dy){\n\t\t\tp = pitch < 0 ?\n\t\t\t\t&bitmap->buffer[(pitchabs * bitmap->rows) + pitchabs * j] :\t// up-flow\n\t\t\t&bitmap->buffer[pitchabs * j];\t// down-flow\n\n\t\t\tint alphaR, alphaG, alphaB;\n\t\t\tfor(i = 0, dx = y+width; i < width; ++i, --dx){\n\t\t\t\tCOLORREF backColor = cache.GetPixel(dy, dx);\n\n\t\t\t\tif (backColor == color || backColor == CLR_INVALID) continue;\n\t\t\t\tif(AAMode == 2 || AAMode == 4){\n\t\t\t\t\t// これはRGBの順にサブピクセルがあるディスプレイ用\n\t\t\t\t\talphaR = p[i + 0];\n\t\t\t\t\talphaG = p[i + pitch];\n\t\t\t\t\talphaB = p[i + pitch * 2];\n\t\t\t\t}else{\n\t\t\t\t\t// BGR\n\t\t\t\t\talphaR = p[i + pitch * 2];\n\t\t\t\t\talphaG = p[i + pitch];\n\t\t\t\t\talphaB = p[i + 0];\n\t\t\t\t}\n\n\t\t\t\tc = ab.doAB(backColor, alphaR, alphaG, alphaB, !bAlphaDraw);\n\t\t\t\tcache.SetCurrentPixel(c);\n\t\t\t}\n\n\t\t\tif (i >= width)\n\t\t\t\tcontinue;\n\t\t}\n}\n\nvoid FreeTypeDrawBitmapGrayV(FreeTypeGlyphInfo& FTGInfo, CAlphaBlendColor& ab, int x, int y)\n{\n\tCBitmapCache& cache = *FTGInfo.FTInfo->pCache;\n\tconst FT_Bitmap *bitmap = &FTGInfo.FTGlyph->bitmap;\n\tBYTE alphatuner = FTGInfo.FTInfo->params->alphatuner;\n\tint i, j;\n\tint dx, dy;\t// display\n\tint width, height;\n\tCOLORREF c;\n\tFT_Bytes p;\n\n\n\tconst COLORREF color = FTGInfo.FTInfo->Color();\n\t//const CGdippSettings* pSettings = CGdippSettings::GetInstance();\n\t//const int* table = pSettings->GetTuneTable();\n\twidth = bitmap->width;\n\theight = bitmap->rows;\n\n\t//\tCAlphaBlendColor ab(color, ftdi.params->alpha, false);\n\n\tfor(j = 0, dy = x; j < height; ++j, ++dy){\n\t\tp = bitmap->pitch < 0 ?\n\t\t\t&bitmap->buffer[(-bitmap->pitch * bitmap->rows) - bitmap->pitch * j] :\t// up-flow\n\t\t&bitmap->buffer[bitmap->pitch * j];\t// down-flow\n\t\tfor(i = 0, dx = y+width; i < width; ++i, --dx){\n\t\t\tconst COLORREF backColor = cache.GetPixel(dy, dx);\n\t\t\tif (backColor == color || backColor == CLR_INVALID) continue;\n\t\t\tc = ab.doAB(backColor, p[i], true);\n\t\t\tcache.SetPixelV(dy, dx, c);\n\t\t}\n\t}\n}\n\nstatic void FreeTypeDrawBitmapV(FreeTypeGlyphInfo& FTGInfo, CAlphaBlendColor& ab, const int x, const int y)\n{\n\tif(FTGInfo.FTGlyph->bitmap.pixel_mode != FT_PIXEL_MODE_GRAY){\n\t\t// この関数自体はFT_PIXEL_MODE_GRAYにのみ対応し他に委譲する\n\t\tswitch(FTGInfo.FTGlyph->bitmap.pixel_mode){\n\t\tcase FT_PIXEL_MODE_MONO:\n\t\t\tFreeTypeDrawBitmapPixelModeMonoV(FTGInfo, ab, x, y);\n\t\t\tbreak;\n\t\tcase FT_PIXEL_MODE_LCD_V:\n\t\t\tFreeTypeDrawBitmapPixelModeLCDV(FTGInfo, ab, x, y);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\t\t// 未対応\n\t\t}\n\t\treturn;\n\t}\n}\n\nclass CGGOGlyphLoader\n{\nprivate:\n\tFT_Library m_lib;\n\tconst FT_Glyph_Class *m_clazz;\n\tBYTE bgtbl[0x41];\n\tstatic int CALLBACK EnumFontFamProc(const LOGFONT* lplf, const TEXTMETRIC* lptm, DWORD FontType, LPARAM lParam);\npublic:\n\tCGGOGlyphLoader() : m_lib(NULL), m_clazz(NULL) {}\n\t~CGGOGlyphLoader() {}\n\tbool init(FT_Library freetype_library);\n\tFT_Library getlib() { return m_lib; }\n\tconst FT_Glyph_Class * getclazz() { return m_clazz; }\n\tBYTE convbgpixel(BYTE val) { return bgtbl[val]; }\n};\nstatic CGGOGlyphLoader s_GGOGlyphLoader;\n\nint CALLBACK CGGOGlyphLoader::EnumFontFamProc(const LOGFONT* lplf, const TEXTMETRIC* lptm, DWORD FontType, LPARAM lParam)\n{\n\tCGGOGlyphLoader* pThis = reinterpret_cast<CGGOGlyphLoader*>(lParam);\n\tif (FontType != TRUETYPE_FONTTYPE || lplf->lfCharSet == SYMBOL_CHARSET) {\n\t\treturn TRUE;\n\t}\n\n\tTRACE(_T(\"Face: %s\\n\"), lplf->lfFaceName);\n\tFreeTypeSysFontData* pFont = FreeTypeSysFontData::CreateInstance(lplf->lfFaceName, 0, false);\n\tif (!pFont) {\n\t\treturn TRUE;\n\t}\n\n\tconst FT_Glyph_Class *clazz = NULL;\n\tFT_Face face = pFont->GetFace();\n\tFT_Error err = FT_Set_Pixel_Sizes(face, 0, 12);//optimized\n\tif (!err) {\n\t\terr = FT_Load_Char(face, lptm->tmDefaultChar, FT_LOAD_NO_BITMAP);\n\t\tif (!err) {\n\t\t\tFT_Glyph glyph;\n\t\t\terr = FT_Get_Glyph(face->glyph, &glyph);\n\t\t\tif (!err) {\n\t\t\t\tif (glyph->format == FT_GLYPH_FORMAT_OUTLINE) {\n\t\t\t\t\tclazz = glyph->clazz;\n\t\t\t\t}\n\t\t\t\tFT_Done_Glyph(glyph);\n\t\t\t}\n\t\t}\n\t}\n\n\tFT_Done_Face(face);\n\n\tif (clazz) {\n\t\tpThis->m_clazz = clazz;\n\t\t//列挙中止\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nbool\nCGGOGlyphLoader::init(FT_Library freetype_library)\n{\n\tif (m_lib) {\n\t\treturn true;\n\t}\n\t\n\tif (!freetype_library) {\n\t\treturn false;\n\t}\n\n\tfor (BYTE val = 0; val <= 0x40; ++val) {\n\t\tBYTE t = (BYTE)(((DWORD)val * 256) / 65);\n\t\tbgtbl[val] = t + (t >> 6);\n\t}\n\n\tm_lib = freetype_library;\n\tm_clazz = NULL;\n\n\t//前の方法だと、arial.ttfが無いとまずそうなので\n\t//適当に使えるアウトラインフォントを探す\n\tHDC hdc = CreateCompatibleDC(NULL);\n\tEnumFontFamilies(hdc, NULL, EnumFontFamProc, reinterpret_cast<LPARAM>(this));\n\tDeleteDC(hdc);\n\n\tif (m_clazz != NULL) {\n\t\treturn true;\n\t}\n\tm_lib = NULL;\n\treturn false;\n}\n\nclass CGGOOutlineGlyph\n{\nprivate:\n\tFT_OutlineGlyph m_ptr;\n\tstatic FT_F26Dot6 toF26Dot6(const FIXED& fx) {\n\t\treturn *(LONG *)(&fx) >> 10;\n\t}\n\tstatic FT_Fixed toFixed(const short n) {\n\t\treturn (FT_Fixed)n << 16;\n\t}\n\tstatic char getTag(char tag, const FT_Vector& point) {\n\t\tif ((point.x & 0x0f) != 0) {\n\t\t\ttag |= FT_CURVE_TAG_TOUCH_X;\n\t\t}\n\t\tif ((point.y & 0x0f) != 0) {\n\t\t\ttag |= FT_CURVE_TAG_TOUCH_Y;\n\t\t}\n\t\treturn tag;\n\t}\npublic:\n\tCGGOOutlineGlyph() : m_ptr(NULL) { _ASSERTE(s_GGOGlyphLoader.getlib()); }\n\t~CGGOOutlineGlyph() { done(); };\n\tbool init(DWORD bufsize, PVOID bufp, const GLYPHMETRICS& gm);\n\tvoid done();\n\toperator FT_Glyph () { return (FT_Glyph)m_ptr; }\n};\n\nvoid\nCGGOOutlineGlyph::done()\n{\n\tif (m_ptr) {\n\t\tfree(m_ptr->outline.points);\n\t\tfree(m_ptr->outline.tags);\n\t\tfree(m_ptr->outline.contours);\n\t}\n\tfree(m_ptr);\n\tm_ptr = NULL;\n}\n\nbool\nCGGOOutlineGlyph::init(DWORD bufsize, PVOID bufp, const GLYPHMETRICS& gm)\n{\n\tdone();\n\tm_ptr = (FT_OutlineGlyph)calloc(1, sizeof *m_ptr);\n\tif (!m_ptr) {\n\t\treturn false;\n\t}\n\n\tFT_GlyphRec& root = m_ptr->root;\n\tFT_Outline& outline = m_ptr->outline;\n\n\troot.library = s_GGOGlyphLoader.getlib();\n\troot.clazz = s_GGOGlyphLoader.getclazz();\n\troot.format = FT_GLYPH_FORMAT_OUTLINE;\n\troot.advance.x = toFixed(gm.gmCellIncX);\n\troot.advance.y = toFixed(gm.gmCellIncY);\n\n\toutline.n_contours = 0;\n\toutline.n_points = 0;\n\toutline.flags = 0; //FT_OUTLINE_HIGH_PRECISION;\n\n\tLPTTPOLYGONHEADER ttphp = (LPTTPOLYGONHEADER)bufp;\n\tLPTTPOLYGONHEADER ttphpend = (LPTTPOLYGONHEADER)((PBYTE)ttphp + bufsize);\n\n\twhile (ttphp < ttphpend) {\n\t\tLPTTPOLYCURVE ttpcp = (LPTTPOLYCURVE)(ttphp + 1);\n\t\tLPTTPOLYCURVE ttpcpend = (LPTTPOLYCURVE)((PBYTE)ttphp + ttphp->cb);\n\t\tif ((PVOID)ttpcpend > (PVOID)ttphpend) {\n\t\t\tbreak;\n\t\t}\n\t\t++outline.n_points;\n\t\t++outline.n_contours;\n\t\twhile (ttpcp < ttpcpend) {\n\t\t\tLPPOINTFX pfxp = &ttpcp->apfx[0];\n\t\t\toutline.n_points += ttpcp->cpfx;\n\t\t\tttpcp = (LPTTPOLYCURVE)(pfxp + ttpcp->cpfx);\n\t\t}\n\t\tttphp = (LPTTPOLYGONHEADER)ttpcp;\n\t}\n\n\tif (ttphp != ttphpend) {\n\t\treturn false;\n\t}\n\toutline.points = (FT_Vector *)calloc(outline.n_points, sizeof *outline.points);\n\toutline.tags = (char *)calloc(outline.n_points, sizeof *outline.tags);\n\toutline.contours = (short *)calloc(outline.n_contours, sizeof *outline.contours);\n\tif (!outline.points || !outline.tags || !outline.contours) {\n\t\tdone();\n\t\treturn false;\n\t}\n\n\tshort *cp = outline.contours;\n\tshort ppos = 0;\n\n\tttphp = (LPTTPOLYGONHEADER)bufp;\n\twhile (ttphp < ttphpend) {\n\t\tLPTTPOLYCURVE ttpcp = (LPTTPOLYCURVE)(ttphp + 1);\n\t\tLPTTPOLYCURVE ttpcpend = (LPTTPOLYCURVE)((PBYTE)ttphp + ttphp->cb);\n\n\t\tLPPOINTFX pfxp0 = &ttpcp->apfx[0];\n\t\twhile (ttpcp < ttpcpend) {\n\t\t\tLPPOINTFX pfxp = &ttpcp->apfx[0];\n\t\t\tpfxp0 = pfxp + (ttpcp->cpfx - 1);\n\t\t\tttpcp = (LPTTPOLYCURVE)(pfxp + ttpcp->cpfx);\n\t\t}\n\t\tttpcp = (LPTTPOLYCURVE)(ttphp + 1);\n\n\t\tif (pfxp0->x.value != ttphp->pfxStart.x.value || pfxp0->x.fract != ttphp->pfxStart.x.fract ||\n\t\t\tpfxp0->y.value != ttphp->pfxStart.y.value || pfxp0->y.fract != ttphp->pfxStart.y.fract) {\n\t\t\toutline.points[ppos].x = toF26Dot6(ttphp->pfxStart.x);\n\t\t\toutline.points[ppos].y = toF26Dot6(ttphp->pfxStart.y);\n\t\t\toutline.tags[ppos] = getTag(FT_CURVE_TAG_ON, outline.points[ppos]);\n\t\t\t++ppos;\n\t\t}\n\t\twhile (ttpcp < ttpcpend) {\n\t\t\tchar tag;\n\t\t\tswitch (ttpcp->wType) {\n\t\t\tcase TT_PRIM_LINE:\n\t\t\t\ttag = FT_CURVE_TAG_ON;\n\t\t\t\tbreak;\n\t\t\tcase TT_PRIM_QSPLINE:\n\t\t\t\ttag = FT_CURVE_TAG_CONIC;\n\t\t\t\tbreak;\n\t\t\tcase TT_PRIM_CSPLINE:\n\t\t\t\ttag = FT_CURVE_TAG_CONIC;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttag = 0;\n\t\t\t}\n\n\t\t\tLPPOINTFX pfxp = &ttpcp->apfx[0];\n\t\t\tfor (WORD cnt = 0; cnt < ttpcp->cpfx; ++cnt) {\n\t\t\t\toutline.points[ppos].x = toF26Dot6(pfxp->x);\n\t\t\t\toutline.points[ppos].y = toF26Dot6(pfxp->y);\n\t\t\t\toutline.tags[ppos] = tag;\n\t\t\t\t++ppos;\n\t\t\t\t++pfxp;\n\t\t\t}\n\t\t\toutline.tags[ppos - 1] = getTag(FT_CURVE_TAG_ON, outline.points[ppos - 1]);\n\t\t\tttpcp = (LPTTPOLYCURVE)pfxp;\n\t\t}\n\t\t*cp++ = ppos - 1;\n\t\tttphp = (LPTTPOLYGONHEADER)ttpcp;\n\t}\n\toutline.n_points = ppos;\n\treturn true;\n}\n\ntemplate<typename T>\nclass CTempMem\n{\nprivate:\n\tchar m_localbuf[0x0f80];\n\tDWORD m_size;\n\tT m_ptr;\npublic:\n\tCTempMem() : m_size(sizeof m_localbuf), m_ptr((T)m_localbuf) {\n\t}\n\t~CTempMem() {\n\t\tdone();\n\t}\n\tT init(DWORD size) {\n\t\tdone();\n\t\tif (m_size > size) {\n\t\t\tm_size = size;\n\t\t\tm_ptr = (T)malloc(m_size);\n\t\t}\n\t\treturn m_ptr;\n\t}\n\tvoid done() {\n\t\tif (m_ptr != (T)m_localbuf) {\n\t\t\tfree(m_ptr);\n\t\t}\n\t\tm_size = sizeof m_localbuf;\n\t\tm_ptr = (T)m_localbuf;\n\t}\n\toperator T () { return m_ptr; }\n\tbool operator ! () { return !m_ptr; }\n\tDWORD getsize() { return m_size; }\n};\n\nBOOL FreeTypePrepare(FreeTypeDrawInfo& FTInfo)\n{\n//CDebugElapsedCounter cntr(\"FreeTypePrepare\");\n#ifdef _DEBUG\n\tFTInfo.Validate();\n#endif\n\n\tFT_Face& freetype_face\t\t\t= FTInfo.freetype_face;\n\tFT_Int& cmap_index\t\t\t\t= FTInfo.cmap_index;\n\tFT_Render_Mode& render_mode\t\t= FTInfo.render_mode;\n\tFTC_ImageTypeRec& font_type\t\t= FTInfo.font_type;\n\tFreeTypeFontInfo*& pfi\t\t\t= FTInfo.pfi;\n\tconst CFontSettings*& pfs\t\t= FTInfo.pfs;\n\tFreeTypeFontCache*& pftCache\t= FTInfo.pftCache;\n\tFTC_ScalerRec& scaler\t\t\t= FTInfo.scaler;\n\tTEXTMETRIC& tm\t\t\t\t\t= FTInfo.params->otm->otmTextMetrics;\n\n\tFTC_FaceID face_id = NULL;\n\tint height = 0;\n\n\tconst LOGFONTW& lf = FTInfo.LogFont();\n\trender_mode\t\t= FT_RENDER_MODE_NORMAL;\n\tif (FTInfo.params->alpha < 1)\n\t\tFTInfo.params->alpha = 1;\n\n\tif (lf.lfFaceName == NULL)\n\t\treturn FALSE;\t//optimized\n\tFTInfo.face_id_list_num = 0;\n\t//Assert(_tcsicmp(lf.lfFaceName, _T(\"@Arial Unicode MS\")) != 0);\n\tpfi = NULL;\n\tCGdippSettings* pSettings = CGdippSettings::GetInstance();\n\tconst bool bVertical = pSettings->FontLoader()==SETTING_FONTLOADER_FREETYPE? lf.lfFaceName[0] == _T('@'):false;\n\n\tFreeTypeFontInfo* pfitemp = g_pFTEngine->FindFont(FTInfo.params);\n\tif (pfitemp) {\n\t\tif (!pfi) pfi = pfitemp;\n\t\tFTInfo.face_id_list_num = pfi->GetFTLink(&FTInfo.face_id_list);\n\t\tpfi->GetGGOLink(&FTInfo.ggo_font_list);\n\t\tFTInfo.face_id_simsun = pfi->GetSimSunID();\n\t}\n\tif (!(freetype_face = FTInfo.GetFace(0)))\n\t{\n\t\tpSettings->AddFontExclude(lf.lfFaceName);\n\t\treturn FALSE;\n\t}\n\n\tif (!pfi) {\n\t\treturn FALSE;\n\t}\n\n\tFTInfo.params->lplf->lfWeight = FTInfo.params->otm->otmTextMetrics.tmWeight;\t//更新到标准weight\n\tpfs = &pfi->GetFontSettings();\n\n\tcmap_index = -1;\t\n\tswitch (pSettings->FontLoader()) {\n\tcase SETTING_FONTLOADER_FREETYPE:\n\t\t{\n\t\t\tface_id = (FTC_FaceID)pfi->GetId();\n\n\t\t\tscaler.face_id\t= face_id;\n\n\t\t\theight = FTInfo.params->otm->otmTextMetrics.tmHeight - FTInfo.params->otm->otmTextMetrics.tmInternalLeading;\t//Snowie!!剪掉空白高度，bugfix。\n// \t\t\t\tif(lf.lfHeight > 0){\n// \t\t\t\t\tscaler.height = height;\n// \t\t\t\t}\n// \t\t\t\telse{\n\t\t\tscaler.height = height;\n//\t\t\t\t}\n\t\t\t//Snowie!!\n\t\t\tTT_OS2* os2_table = pfitemp->GetOS2Table();\n\n\t\t\tif (lf.lfQuality && os2_table->xAvgCharWidth)\n\t\t\t{\n\t\t\t\tif (!(freetype_face->style_flags & FT_STYLE_FLAG_BOLD) && tm.tmWeight>= FW_BOLD)\n\t\t\t\t\t--FTInfo.params->otm->otmTextMetrics.tmAveCharWidth;\n\t\t\t\tscaler.width = MulDiv(FTInfo.params->otm->otmTextMetrics.tmAveCharWidth, FTInfo.params->otm->otmEMSquare, os2_table->xAvgCharWidth);\n\t\t\t}\n\t\t\telse\n\t\t\t\tscaler.width = scaler.height;\n\t\t\tif (bVertical)\n\t\t\t\tswap(scaler.width, scaler.height);//如果是竖向字体，交换宽高\n\t\t\t//!!Snowie\n\t\t\tscaler.pixel = 1;\n\t\t\tscaler.x_res = 0;\n\t\t\tscaler.y_res = 0;\n/*\n\t\t\tFT_Size font_size;\n\t\t\t{\n\t\t\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_MANAGER);\n\t\t\t\tif(FTC_Manager_LookupSize(cache_man, &scaler, &font_size))\n\t\t\t\t\treturn FALSE;\n\t\t\t}*/\n\t\t\theight = scaler.height;\n\t\t\tbreak;\n\t\t}\n\tcase SETTING_FONTLOADER_WIN32:\n\t\t{\n\t\t\t/*\n\t\t\tOUTLINETEXTMETRIC otm;\n\t\t\t\t\t\tif (GetOutlineTextMetrics(FTInfo.hdc, sizeof otm, &otm) != sizeof otm) {\n\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t\t}*/\n\t\t\theight = -lf.lfHeight;\n\t\t\tscaler.height = height;\n\t\t\tscaler.width = lf.lfWidth;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn FALSE;\n\t}\n// \tif (!(freetype_face = FTInfo.GetFace(0)))\n// \t{\n// \t\tpSettings->AddFontExclude(lf.lfFaceName);\n// \t\treturn FALSE;\n// \t}\n\n\tpftCache = pfi->GetCache(scaler, lf);\n\tif(!pftCache)\n\t\treturn FALSE;\n\n\t/*FT_Size_RequestRec size_request;\n\tsize_request.width = lf.lfWidth;\n\tsize_request.horiResolution = 0;\n\tsize_request.vertResolution = 0;\n\tif(lf.lfHeight > 0){\n\t\t// セル高さ\n\t\tsize_request.type = FT_SIZE_REQUEST_TYPE_CELL;\n\t\tsize_request.height = lf.lfHeight * 64;\n\t}\n\telse{\n\t\t// 文字高さ\n\t\tsize_request.type = FT_SIZE_REQUEST_TYPE_NOMINAL;\n\t\tsize_request.height = (-lf.lfHeight) * 64;\n\t}\n\tif(FT_Request_Size(freetype_face, &size_request))\n\t\tgoto Exit2;*/\n\n\tswitch (pSettings->FontLoader()) {\n\tcase SETTING_FONTLOADER_FREETYPE:\n\t\t// font_typeを設定\n\t\tfont_type.face_id = face_id;\n\t\tfont_type.width   = scaler.width;//freetype_face->size->metrics.x_ppem;\n\t\tfont_type.height  = scaler.height;//freetype_face->size->metrics.y_ppem;\n\t\t//Snowie!!\n\t\tFTInfo.height = font_type.height;\n\t\tFTInfo.width = font_type.width;\n\n\t\t/* ビットマップまでキャッシュする場合はFT_LOAD_RENDER | FT_LOAD_TARGET_*\n\t\t * とする。ただし途中でTARGETを変更した場合等はキャッシュが邪魔する。\n\t\t * そういう時はFT_LOAD_DEFAULTにしてFTC_ImageCache_Lookup後に\n\t\t * FT_Glyph_To_Bitmapしたほうが都合がいいと思う。\n\t\t */\n\t\t// Boldは太り具合というものがあるので本当はこれだけでは足りない気がする。\n\t\t/*if(IsFontBold(lf) && !(freetype_face->style_flags & FT_STYLE_FLAG_BOLD) ||\n\t\t\tlf.lfItalic && !(freetype_face->style_flags & FT_STYLE_FLAG_ITALIC)){\n\t\t\t// ボールド、イタリックは後でレンダリングする\n\t\t\t// 多少速度は劣化するだろうけど仕方ない。\n\t\t\tfont_type.flags = FT_LOAD_NO_BITMAP;\n\t\t}\n\t\telse{\n\t\t\tfont_type.flags = FT_LOAD_RENDER | FT_LOAD_NO_BITMAP;\n\t\t}*/\n\t\tbreak;\n\tcase SETTING_FONTLOADER_WIN32:\n\t\tfont_type.face_id = face_id;\n\t\tfont_type.width   = -1;\n\t\tfont_type.height  = -1;\n\t\tbreak;\n\n\tDEFAULT_UNREACHABLE;\n\t}\n\tfont_type.flags = FT_LOAD_NO_BITMAP | FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH;\n\n\t// ヒンティング\n\tswitch (pfs->GetHintingMode()) {\n\tcase 0:\n\t\t// ignore.\n\t\tbreak;\n\tcase 1:\n\t\tfont_type.flags |= FT_LOAD_NO_HINTING;\n\t\tbreak;\n\tcase 2:\n\t\tfont_type.flags |= FT_LOAD_FORCE_AUTOHINT;\n\t\tbreak;\n\t}\n\n\t\t//如果含有内置hinting则启用default模式，否则使用autohint模式，以保证效果\n\t\t// アンチエイリアス\n\tif (FTInfo.IsMono()) {\n\t\tfont_type.flags |= FT_LOAD_TARGET_MONO;\n\t\trender_mode = FT_RENDER_MODE_MONO;\n\t} else {\n\t\tswitch (pfs->GetAntiAliasMode()) {\n\t\tcase -1:\n\t\t\tfont_type.flags |= FT_LOAD_TARGET_MONO;\n\t\t\trender_mode = FT_RENDER_MODE_MONO;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tfont_type.flags |= FT_LOAD_TARGET_NORMAL;\n\t\t\trender_mode = FT_RENDER_MODE_NORMAL;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfont_type.flags |= FT_LOAD_TARGET_LIGHT;\n\t\t\trender_mode = FT_RENDER_MODE_LIGHT;\n\t\t\tbreak;\n\t\tcase 2:\n\t\tcase 3:\n\t\t\tfont_type.flags |= FT_LOAD_TARGET_LCD;\n\t\t\trender_mode = FT_RENDER_MODE_LCD;\n\t\t\tbreak;\n\t\tcase 4:\n\t\tcase 5:\n\t\t\tfont_type.flags |= FT_LOAD_TARGET_LIGHT;\n\t\t\trender_mode = FT_RENDER_MODE_LCD;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (pSettings->HintSmallFont() && font_type.flags & FT_LOAD_TARGET_LIGHT && font_type.height!=-1 && font_type.height<12)  //通用设置不使用hinting，但是打开了小字体hinting开关\n\t{\t\n\t\t/*\n\t\tif (!(freetype_face->face_flags & FT_FACE_FLAG_TRICKY))\t//如果不是tricky字体\n\t\t\t\t\tfont_type.flags = font_type.flags & (~FT_LOAD_NO_HINTING) | (pfi->FontHasHinting() ? FT_LOAD_NO_AUTOHINT : FT_LOAD_FORCE_AUTOHINT);\n\t\t\t\telse*/\n\t\t\n\t\t\tfont_type.flags = font_type.flags & (~FT_LOAD_NO_HINTING)/* | (pfi->FontHasHinting() ? FT_LOAD_DEFAULT : FT_LOAD_FORCE_AUTOHINT)*/; \n\t}\n\n\tFTInfo.useKerning = FALSE;\n\tif (pfs->GetKerning()) {\n\t\tswitch (pSettings->FontLoader()) {\n\t\tcase SETTING_FONTLOADER_FREETYPE:\n\t\t\tFTInfo.useKerning = !!FT_HAS_KERNING(freetype_face);\n\t\t\tbreak;\n\t\tcase SETTING_FONTLOADER_WIN32:\n\t\t\t{\n\t\t\t\tDWORD rc = GetFontLanguageInfo(FTInfo.hdc);\n\t\t\t\tif (rc != GCP_ERROR) {\n\t\t\t\t\tFTInfo.useKerning = !!(rc & GCP_USEKERNING);\n\t\t\t\t\tFTInfo.ggokerning.init(FTInfo.hdc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tDEFAULT_UNREACHABLE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n\n// 縦にするやつはtrue(ASCIIと半角カナはfalse)\ninline bool IsVerticalChar(WCHAR wch){\n\tif(wch < 0x80)\n\t\treturn false;\n\tif(0xFF61 <= wch && wch <= 0xFF9F)\n\t\treturn false;\n\t// 本当はもっと真面目にやらないとまずいが。\n\treturn true;\n}\n\nstruct CGGOFont\n{\n\tHDC m_hdc;\n\tHFONT m_hfont;\n\tHFONT m_hprevfont;\n\tCGGOFont(HDC hdc, const LOGFONT& olf) : m_hdc(hdc), m_hfont(NULL), m_hprevfont(NULL) {\n\t\tLOGFONT lf = olf;\n\t\tlf.lfWeight = FW_REGULAR;\n\t\tlf.lfItalic = FALSE;\n\t\tlf.lfStrikeOut = FALSE;\n\t\tm_hfont = CreateFontIndirect(&lf);\n\t}\n\t~CGGOFont() {\n\t\tif (m_hprevfont) {\n\t\t\tSelectFont(m_hdc, m_hprevfont);\n\t\t}\n\t\tDeleteFont(m_hfont);\n\t}\n\tvoid change() {\n\t\tm_hprevfont = SelectFont(m_hdc, m_hfont);\n\t}\n\tvoid restore() {\n\t\tSelectFont(m_hdc, m_hprevfont);\n\t\tm_hprevfont = NULL;\n\t}\n\toperator HFONT () { return m_hfont; }\n};\n\nclass ClpDx\n{\nprivate:\n\tconst INT *p;\n\tconst INT step;\npublic:\n\tClpDx(const INT *lpDx, UINT etoOptions) : p(lpDx), step((etoOptions & ETO_PDY) ? 2 : 1) {\n\t}\n\t~ClpDx() {\n\t}\n\tint get(int val) {\n\t\tint result;\n\t\tif (p) {\n\t\t\tresult = *p;\n\t\t\tp += step;\n\t\t} else {\n\t\t\tresult = val;\n\t\t}\n\t\treturn result;\n\t}\n};\n/*\nFT_UInt FTC_CMapCache_Lookup2( FTC_CMapCache  cache,\n\t\t\t\t\t FTC_FaceID     face_id,\n\t\t\t\t\t FT_Int         cmap_index,\n\t\t\t\t\t FT_UInt32      char_code,\n\t\t\t\t\t FT_Face\t\tfreetype_face)\n{\t\n\tif ((int)face_id >= charmapCacheSize)\n\t{\n\t\tint oldsize = charmapCacheSize;\n\t\tcharmapCacheSize = ((int)face_id / 100 + 1)*100;\n\t    g_charmapCache = (FT_Int*)realloc(g_charmapCache, charmapCacheSize*sizeof(FT_Int));\n\t\tmemset(&g_charmapCache[oldsize], 0xff, (charmapCacheSize-oldsize)*sizeof(FT_Int));\n\t}\n\tif (g_charmapCache[(int)face_id]==-1) \n\t\tif (!FTC_Manager_LookupFace(cache_man, face_id, &freetype_face))\n\t\t{\n\t\t\tg_charmapCache[(int)face_id] = FT_Get_Charmap_Index(freetype_face->charmap);\n\t\t\tcmap_index = g_charmapCache[(int)face_id];\n\t\t}\n\t\telse\n\t\t\tcmap_index = 0;\n\treturn FTC_CMapCache_Lookup(cache, face_id, cmap_index, char_code);\n}*/\n\n\nBOOL ForEachGetGlyphFT(FreeTypeDrawInfo& FTInfo, LPCTSTR lpString, int cbString, FT_Glyph* GlyphArray, FT_DRAW_STATE* drState)\n{\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\n\t//Snowie!!\n\tBOOL bIsSymbol = GetTextCharsetInfo(FTInfo.hdc, NULL, 0) == SYMBOL_CHARSET;\n\tBOOL bAllowDefaultLink = pSettings->GetFontLinkInfo().IsAllowFontLink((BYTE)GetTextCharsetInfo(FTInfo.hdc, NULL, 0));\t//是否为符号\n\tBOOL nRet = true;\n\tBOOL bWindowsLink = pSettings->FontLink()==2;\n\t//!!Snowie\n\n\t/*const*/ FT_Face freetype_face = FTInfo.freetype_face;\t//去掉常量属性，下面要改他\n\tconst FT_Int cmap_index = FTInfo.cmap_index;\n\tconst FT_Bool useKerning = FTInfo.useKerning;\n\tFT_Render_Mode render_mode = FTInfo.render_mode;\n\tconst int LinkNum = FTInfo.face_id_list_num;\n\tint AAMode = FTInfo.pfs->GetAntiAliasMode();\n\tint* AAList = FTInfo.AAModes;\n\tconst LOGFONTW& lf = FTInfo.LogFont();\n\tFreeTypeFontCache* pftCache = FTInfo.pftCache;\n\tconst CFontSettings*& pfs = FTInfo.pfs;\n\tFreeTypeFontInfo*& pfi\t= FTInfo.pfi;\n\tconst bool bGlyphIndex = FTInfo.IsGlyphIndex();\n\t//const bool bSizeOnly = FTInfo.IsSizeOnly();\n\t//const bool bOwnCache = !(FTInfo.font_type.flags & FT_LOAD_RENDER);\n\tconst LPCTSTR lpStart = lpString;\n\tconst LPCTSTR lpEnd = lpString + cbString;\n\tFT_UInt previous = 0;\n\tWCHAR previouswch = 0;\n\tconst bool bVertical = lf.lfFaceName[0] == _T('@');\n\tbool bLcdMode = render_mode == FT_RENDER_MODE_LCD;\n\tbool bLightLcdMode = (AAMode == 4) || (AAMode == 5);\n\tClpDx clpdx(FTInfo.lpDx, FTInfo.params->etoOptions);\n\tconst bool bWidthGDI32 = true;\n\tconst int ggoformatbase = (FTInfo.font_type.flags & FT_LOAD_NO_HINTING) ? GGO_UNHINTED | GGO_NATIVE : GGO_NATIVE;\n\n\tif (!s_GGOGlyphLoader.init(freetype_library)) {\n\t\treturn FALSE;\n\t}\n\t\n\n\tWORD * gi = new WORD[cbString];\n\tWORD * ggi=gi;\n\n\n//Snowie!!\n\n//Fast fontlink\n\tWORD ** lpfontlink = NULL;\n\tHFONT hOldFont = NULL;\n\tif (!bGlyphIndex && bWindowsLink)\t//使用Windows fontlink\n\t{\n\t\tlpfontlink = (WORD**)new LPVOID[FTInfo.face_id_list_num];\n\t\tfor (int i=0;i<LinkNum;i++)\n\t\t{\n\t\t\tlpfontlink[i] = new WORD[cbString];\n\t\t\tZeroMemory(lpfontlink[i], sizeof(WORD)*cbString);\t//初始化为无链接\n\t\t}\n\t\t//\n\t\thOldFont = (HFONT)GetCurrentObject(FTInfo.hdc, OBJ_FONT);\t//加载第一个字体\n\t}\n//fontlink\n\n\tint* Dx= FTInfo.Dx;\n\tif (!bAllowDefaultLink && FTInfo.face_id_list_num > 1)\n\t\tFTInfo.face_id_list_num--;\t//如果是symbol页那就不链接到宋体\n\n\tbool bUnicodePlane = false;\n\tfor (int i=0 ; lpString < lpEnd; ++lpString, ++gi, ++GlyphArray, ++drState, ++AAList, /*ggdi32++,*/ i++){\n\t\tif (bUnicodePlane)\n\t\t{\n\t\t\t*drState = FT_DRAW_NOTFOUND;\n\t\t\tbUnicodePlane = false;\n\t\t\tclpdx.get(0);\n\t\t\tFTInfo.px = FTInfo.x;\n\t\t\tgoto cont;\n\t\t}\n\t\tWCHAR wch = *lpString;\n\t\tif (!bGlyphIndex && bIsSymbol && !bWindowsLink)\n\t\t\twch |= 0xF000;\n\t\tFT_Glyph* glyph_bitmap = GlyphArray;\n\t\tint gdi32x = 0;// = *ggdi32;\n\t\tFTInfo.font_type.face_id = FTInfo.face_id_list[0];\n\t\tFreeTypeCharData* chData = NULL;\n\t\tFT_UInt glyph_index = 0;\n\t\tBOOL bIsBold = false, bIsIndivBold = false;\n\n\t\t{\n\t\t\t\n\t\t\tchData = bGlyphIndex\n\t\t\t\t? pftCache->FindGlyphIndex(wch)\n\t\t\t\t: pftCache->FindChar(wch);\n\n\t\t\tif (chData/* && FTInfo.width==chData->GetWidth()*/) {\n\n\t\t\t\tgdi32x = chData->GetGDIWidth();\n\t\t\t\t*AAList = chData->GetAAMode();\n\t\t\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_LIBRARY);\n\t\t\t\tFT_Glyph_Copy((FT_Glyph)chData->GetGlyph(render_mode), glyph_bitmap);\n\t\t\t\t//TRACE(_T(\"Cache Hit: %wc, size:%d, 0x%8.8X\\n\"), wch, chData->GetWidth(), glyph_bitmap);\n\t\t\t}\n\t\t}\n\t\tif (!*glyph_bitmap) {\n\t\t\tFT_Glyph glyph = NULL;\n\t\t\tbool f_glyph = false;\n\t\t\t//GLYPHMETRICS gm;\n\t\t\tconst MAT2 mat2 = {{0, 1}, {0, 0}, {0, 0}, {0, 1}};\n\t\t\tUINT ggoformat = ggoformatbase;\n\t\t\tCTempMem<PVOID> ggobuf;\n\t\t\tDWORD outlinesize = 0;\n\n\t\t\tif (bGlyphIndex) {\n\t\t\t\tf_glyph = !!wch;\n\t\t\t\tglyph_index = wch;\n\t\t\t\t*AAList = AAMode;\n\t\t\t\tGetCharWidthI(FTInfo.hdc, wch, 1, (LPWORD)&wch, &gdi32x);\t//index的文字必须计算宽度\n\t\t\t\tif (FTInfo.font_type.height<=pSettings->BitmapHeight() && pfi->EmbeddedBmpExist(FTInfo.font_type.height))\n\t\t\t\t{\n\t\t\t\t\tf_glyph=false;\t//使用点阵，不绘图\n\t\t\t\t\t*drState=FT_DRAW_EMBEDDED_BITMAP;\t//设置为点阵绘图方式\n\t\t\t\t}\n\t\t\t} else\n\t\t\tif (wch && !CID.myiswcntrl(lpString[0])) {\n\t\t\t\t\n\t\t\t\tfor (int j = 0; j < FTInfo.face_id_list_num; ++j) {\n\t\t\t\t\tif (bWindowsLink)\t//使用Windows函数进行fontlink\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!lpfontlink[j][i])\t//还没初始化该字体的fontlink\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSelectFont(FTInfo.hdc, FTInfo.ggo_font_list[j]);\t//加载ggo字体\n\t\t\t\t\t\t\tGetGlyphIndices(FTInfo.hdc, lpString, cbString-i, &lpfontlink[j][i], GGI_MARK_NONEXISTING_GLYPHS);\t//进行fontlink\n\t\t\t\t\t\t\tSelectFont(FTInfo.hdc, hOldFont);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tglyph_index = lpfontlink[j][i];\n\t\t\t\t\t\tif (glyph_index==0xffff)\n\t\t\t\t\t\t\tglyph_index = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\t\t//使用freetype进行fontlink\n\t\t\t\t\t{\n\t\t\t\t\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_MANAGER);\n\t\t\t\t\t\tglyph_index = FTC_CMapCache_Lookup(cmap_cache,FTInfo.face_id_list[j],-1,wch);\n\t\t\t\t\t}\n\t\t\t\t\tif (glyph_index) {\n\t\t\t\t\t\tGetCharWidth32W(FTInfo.hdc, wch, wch, &gdi32x);\t//有效文字，计算宽度\n\t\t\t\t\t\tf_glyph = true;\n\t\t\t\t\t\tFTInfo.font_type.face_id = FTInfo.face_id_list[j];\n\t\t\t\t\t\tfreetype_face = FTInfo.GetFace(j);\t//同时更新对应faceid的实际face\n\t\t\t\t\t\t//接下来更新对应的fontsetting\n\t\t\t\t\t\tFTInfo.font_type.flags = FT_LOAD_NO_BITMAP | FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH;\n\t\t\t\t\t\t// ヒンティング\n\t\t\t\t\t\t//extern CFontSetCache g_fsetcache;\n\t\t\t\t\t\t//pfs = g_fsetcache.Get(FTInfo.font_type.face_id);\n\t\t\t\t\t\tif (FTInfo.font_type.face_id==FTInfo.face_id_simsun && j>0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswitch (FTInfo.font_type.height)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 11:{FTInfo.font_type.height=12; FTInfo.font_type.width++; break;}\t//对宋体进行特殊处理\n\t\t\t\t\t\t\tcase 13:{FTInfo.font_type.height=15; FTInfo.font_type.width+=2; break;}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpfi = g_pFTEngine->FindFont((int)FTInfo.font_type.face_id);\n\t\t\t\t\t\tif (pfi)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpfs = &pfi->GetFontSettings();\n\t\t\t\t\t\t\tswitch (pfs->GetHintingMode()) {\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t// ignore.\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_NO_HINTING;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_FORCE_AUTOHINT;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// アンチエイリアス\n\t\t\t\t\t\t\tif (FTInfo.IsMono()) {\n\t\t\t\t\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_TARGET_MONO;\n\t\t\t\t\t\t\t\trender_mode = FT_RENDER_MODE_MONO;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tswitch (*AAList = pfs->GetAntiAliasMode()) {\n\t\t\t\t\t\t\t\tcase -1:\n\t\t\t\t\t\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_TARGET_MONO;\n\t\t\t\t\t\t\t\t\trender_mode = FT_RENDER_MODE_MONO;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_TARGET_NORMAL;\n\t\t\t\t\t\t\t\t\trender_mode = FT_RENDER_MODE_NORMAL;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_TARGET_LIGHT;\n\t\t\t\t\t\t\t\t\trender_mode = FT_RENDER_MODE_LIGHT;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_TARGET_LCD;\n\t\t\t\t\t\t\t\t\trender_mode = FT_RENDER_MODE_LCD;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_TARGET_LIGHT;\n\t\t\t\t\t\t\t\t\trender_mode = FT_RENDER_MODE_LCD;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (pSettings->HintSmallFont() && FTInfo.font_type.flags & FT_LOAD_TARGET_LIGHT && FTInfo.font_type.height!=-1 && FTInfo.font_type.height<12)  //通用设置不使用hinting，但是打开了小字体hinting开关\n\t\t\t\t\t\t\t\tFTInfo.font_type.flags = FTInfo.font_type.flags & (~FT_LOAD_NO_HINTING)/* | (pfi->FontHasHinting() ? FT_LOAD_DEFAULT : FT_LOAD_FORCE_AUTOHINT)*/;\n\n\t\t\t\t\t\t\tAAMode = *AAList/*pfs->GetAntiAliasMode()*/;\n\t\t\t\t\t\t\tbLcdMode = render_mode == FT_RENDER_MODE_LCD;\n\t\t\t\t\t\t\tbLightLcdMode = (AAMode == 4) || (AAMode == 5);\n\t\t\t\t\t\t\t//更新完成\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (FTInfo.font_type.height<=pSettings->BitmapHeight() && pfi->EmbeddedBmpExist(FTInfo.font_type.height))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tf_glyph=false;\t//使用点阵，不绘图\n\t\t\t\t\t\t\t*drState=FT_DRAW_EMBEDDED_BITMAP;\t//设置为点阵绘图方式\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\n\t\t\tif (!f_glyph) {\t//glyphindex的文字上面已经计算过了\n#ifdef _DEBUG\n\t\t\t\tGdiSetBatchLimit(0);\n#endif\n\t\t\t\tif (*drState==FT_DRAW_NORMAL || bGlyphIndex)\n\t\t\t\t\t*drState = FT_DRAW_NOTFOUND;\t//找不到文字\n\t\t\t\tif ((!FTInfo.lpDx || lpString == lpEnd - 1) && !bGlyphIndex)\t//无效文字，而且没有事先排版或者是排版的最后一个字符了\n\t\t\t\t{\n\t\t\t\t\tGetCharWidth32W(FTInfo.hdc, wch, wch, &gdi32x);\n\t\t\t\t}\n\t\t\t\tint cx = gdi32x;\n/*\n\t\t\t\tif (bSizeOnly) {\n\t\t\t\t\tFTInfo.x += cx;\n\t\t\t\t} else*/\n\t\t\t\t\n\t\t\t\t{\n\t\t\t\t\tif (wch) {\n\t\t\t\t\t\t*glyph_bitmap = NULL;\t//无效文字\n\t\t\t\t\t\t//ORIG_ExtTextOutW(FTInfo.hdc, FTInfo.x, FTInfo.yTop, FTInfo.GetETO(), NULL, &wch, 1, NULL);\n\t\t\t\t\t}\n\t\t\t\t\tBOOL isc = bGlyphIndex ? false : (CID.myiswcntrl(*lpString));\n\t\t\t\t\tif (isc == CNTRL_UNICODE_PLANE)\n\t\t\t\t\t\tbUnicodePlane = true;\n// \t\t\t\t\telse\n// \t\t\t\t\t\tif (isc == CNTRL_ZERO_WIDTH)\t//预计算的无宽度控制字\n// \t\t\t\t\t\t\tcx = 0;\n\t\t\t\t\tint dxWidth = clpdx.get(cx);\n\t\t\t\t\tif (isc == CNTRL_COMPLEX_TEXT)\t//控制字\n\t\t\t\t\t{\n\t\t\t\t\t\tcx = dxWidth;\t//服从windows的宽度调度\n\t\t\t\t\t\t//if (!dxWidth)\n\t\t\t\t\t\t//\tCID.setcntrlAttribute(wch, CNTRL_ZERO_WIDTH);\n\t\t\t\t\t}\n\t\t\t\t\tif (lpString < lpEnd - 1) {\n\t\t\t\t\t\tFTInfo.x += dxWidth;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//if (gdi32x)\n\t\t\t\t\t\t//{\n\t\t\t\t\t\t\t\n\t/*\t\t\t\t\t\tABC abc = {0, cx, 0};\n\t\t\t\t\t\t\tif (bGlyphIndex)\n\t\t\t\t\t\t\t\tGetCharABCWidthsI(FTInfo.hdc, wch, 1, NULL, &abc);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tGetCharABCWidths(FTInfo.hdc, wch, wch, &abc);*/\n\t\t\t\t\t\t\t//FTInfo.px = FTInfo.x+Max(clpdx.get(cx), abc.abcA+(int)abc.abcB+abc.abcC);\t//无效文字的情况下，绘图宽度=鼠标位置\n\t\t\t\t\t\t\tFTInfo.px = FTInfo.x + cx;\t\n\t\t\t\t\t\t\tFTInfo.x += dxWidth;//Max(clpdx.get(cx), cx);/*(int)abc.abcB+abc.abcC*///Max(clpdx.get(cx), abc.abcB? abc.abcA:0);\n\t\t\t\t\t\t//}\n\t\t\t\t\t}\n\t\t\t\tif (!isc)\n\t\t\t\t\tFTInfo.x += FTInfo.params->charExtra;\n\t\t\t\t}\n\t\t\t\tgoto cont;\n\t\t\t}\n\n\t\t\t\t// 縦書き\n\t\t\t\tif(bVertical){\n\t\t\t\t\tglyph_index = ft2vert_get_gid(\n\t\t\t\t\t\t(struct ft2vert_st *)freetype_face->generic.data,\n\t\t\t\t\t\tglyph_index);\n\t\t\t\t}\n\n\t\t\t\t// カーニング\n\t\t\t\tif(useKerning){\n\t\t\t\t\tif(previous != 0 && glyph_index){\n\t\t\t\t\t\tFT_Vector delta;\n\t\t\t\t\t\tFT_Get_Kerning(freetype_face,\n\t\t\t\t\t\t\t\t\t   previous, glyph_index,\n\t\t\t\t\t\t\t\t\t   ft_kerning_default, &delta);\n\t\t\t\t\t\tFTInfo.x += FT_PosToInt(delta.x);\n\t\t\t\t\t}\n\t\t\t\t\tprevious = glyph_index;\n\t\t\t\t}\n\n\n\t\t\t// 縦横\n\t\t\tif(bVertical && IsVerticalChar(wch)){\n\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_VERTICAL_LAYOUT;\n\t\t\t\tif(bLcdMode){\n\t\t\t\t\tif(!bLightLcdMode){\n\t\t\t\t\t\tFTInfo.font_type.flags &= ~FT_LOAD_TARGET_LCD;\n\t\t\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_TARGET_LCD_V;\n\t\t\t\t\t}\n\t\t\t\t\trender_mode             = FT_RENDER_MODE_LCD_V;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif (bVertical)\n\t\t\t\t\tswap(FTInfo.font_type.height, FTInfo.font_type.width);\t//交换无法旋转的文字宽高\n\t\t\t\tFTInfo.font_type.flags &=~FT_LOAD_VERTICAL_LAYOUT;\n\t\t\t\tif(bLcdMode){\n\t\t\t\t\tif(!bLightLcdMode){\n\t\t\t\t\t\tFTInfo.font_type.flags &= ~FT_LOAD_TARGET_LCD_V;\n\t\t\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_TARGET_LCD;\n\t\t\t\t\t}\n\t\t\t\t\trender_mode             = FT_RENDER_MODE_LCD;\n\t\t\t\t}\n\t\t\t}\n\n\t\t{\n\t\t\t\n\t\t\tbool bRequiredownsize;\n\n\t\t\t\tbIsIndivBold = freetype_face->style_flags & FT_STYLE_FLAG_BOLD;\t//是独立粗体\n\t\t\t\tbIsBold = (IsFontBold(lf) && !bIsIndivBold);\t//是仿粗体\n\t\t\t\tbRequiredownsize = bIsBold && /*(pSettings->BolderMode()==2 || (*/pSettings->BolderMode()!=1 /*&& FTInfo.height>FT_BOLD_LOW))*/;\n\t\t\t\tif (bRequiredownsize)\n\t\t\t\t{\t\t\t\t\n\t\t\t\t\tFTInfo.font_type.width -= (FTInfo.font_type.width)/36;\n\t\t\t\t\tFTInfo.font_type.height -= (FTInfo.font_type.height)/36;\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_MANAGER);\n\t\t\t\t\tif(FTC_ImageCache_Lookup(\n\t\t\t\t\t\timage_cache,\n\t\t\t\t\t\t&FTInfo.font_type,\n\t\t\t\t\t\tglyph_index,\n\t\t\t\t\t\t&glyph,\n\t\t\t\t\t\tNULL)) {\n\t\t\t\t\t\t\tnRet= false;\n\t\t\t\t\t\t\tgoto gdiexit;\n\t\t\t\t\t}\n\t\t\t\t\t//glyph = New_FT_Glyph();\n\t\t\t\t}\n\n\t\t\t\tFTInfo.font_type.height = FTInfo.height;\n\t\t\t\tFTInfo.font_type.width = FTInfo.width;\n\t\t\t\t\n\t\t}\n\t\t{\n\t\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_LIBRARY);\n\t\t\tif (FT_Glyph_Copy(glyph, glyph_bitmap))\n\t\t\t{\t\n\t\t\t\t//FT_Done_Glyph(glyph);\n\t\t\t\tnRet = FALSE;\n\t\t\t\tgoto gdiexit;\n\t\t\t}\n\t\t\t//FT_Done_Glyph(glyph);\n\t\t}\n\t\t\tif((*glyph_bitmap)->format != FT_GLYPH_FORMAT_BITMAP){\n\t\t\t\tint str_h;\n\t\t\t\tint str_v;\n\t\t\t\tbool fbold = false;\n\t\t\t\tstr_h = str_v = FTInfo.pfi->CalcNormalWeight();\n\t\t\t\tif (bIsIndivBold)\n\t\t\t\t\tstr_h = str_v = FTInfo.pfi->GetExactBoldWeight()<<2;\n\t\t\t\tif (bIsBold) {\n\t\t\t\t\tfbold = true;\n\t\t\t\t\tstr_h += FTInfo.font_type.height<24 ? FTInfo.pfi->GetFTWeight(): (FTInfo.pfi->GetFTWeight()*FTInfo.font_type.height/24);\n\t\t\t\t\tstr_v = str_h;\n\t\t\t\t}\n\t\t\t\tif((str_h || str_v) && New_FT_Outline_Embolden(\n\t\t\t\t\t   &((FT_OutlineGlyph)(*glyph_bitmap))->outline,\n\t\t\t\t\t   str_h, str_v, FTInfo.height))\n\t\t\t\t\t{\n\t\t\t\t\t\tFT_Done_Glyph(*glyph_bitmap);\n\t\t\t\t\t\tnRet= false;\n\t\t\t\t\t\tgoto gdiexit;\n\t\t\t\t\t}\n\n\t\t\t\tif (fbold) {\n\t\t\t\t\t((FT_BitmapGlyph)(*glyph_bitmap))->root.advance.x += 0x10000;\n\t\t\t\t}\n\t\t\t\tif(lf.lfItalic &&\n\t\t\t\t\t!(freetype_face->style_flags & FT_STYLE_FLAG_ITALIC)){\n\t\t\t\t\tFT_Matrix matrix;\n\t\t\t\t\tFTInfo.pfi->CalcItalicSlant(matrix);\n\t\t\t\t\tFT_Outline_Transform(\n\t\t\t\t\t\t&((FT_OutlineGlyph)((*glyph_bitmap)))->outline,\n\t\t\t\t\t\t&matrix);\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_LIBRARY);\n\t\t\t\t\tif(FT_Glyph_To_Bitmap(&((*glyph_bitmap)), render_mode, 0, 1)){\n\t\t\t\t\t\tFT_Done_Glyph(*glyph_bitmap);\n\t\t\t\t\t\tnRet= false;\n\t\t\t\t\t\tgoto gdiexit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint cx = (bVertical && IsVerticalChar(wch)) ?\n\t\t\t\tFT_FixedToInt(FT_BitmapGlyph((*glyph_bitmap))->root.advance.y) :\n\t\t\t\tFT_FixedToInt(FT_BitmapGlyph((*glyph_bitmap))->root.advance.x);\n\n{\n\t\t\tint dx = clpdx.get(bWidthGDI32 ? gdi32x : cx);\t//获得宽度\n\t\t\tint left = FT_BitmapGlyph((*glyph_bitmap))->left;\n\t\t\tif (FTInfo.x + left< FTInfo.xBase)\n\t\t\t\tFTInfo.xBase = FTInfo.x + left;\t//如果有字符是负数起始位置的（合成符号）， 调整文字的起始位置\n\n\t\t\tif (lpString < lpEnd - 1) {\n\t\t\t\tFTInfo.x += dx;\n\t\t\t} else {\n\t\t\t\t\tint bx = FT_BitmapGlyph((*glyph_bitmap))->bitmap.width;\n\t\t\t\t\tif (render_mode == FT_RENDER_MODE_LCD) bx /= 3;\n\t\t\t\t\tbx += left;\n\t\t\t\t\tFTInfo.px = FTInfo.x + Max(Max(dx, bx), cx);\t//有文字的情况下,绘图宽度=ft计算的宽度，鼠标位置=win宽度\n\t\t\t\t\tFTInfo.x += dx;//Max(dx, gdi32x);//Max(Max(dx, bx), cx);\n\t\t\t}\n\n\t\t}\n\t\tFTInfo.x += FTInfo.params->charExtra;\n\n\t\t//if (bSizeOnly || bOwnCache) {\n\t\t\t//キャッシュ化\n\t\tif (glyph_index) {\n\t\t\t\n\t\t\tif (bGlyphIndex) {\n\t\t\t\tpftCache->AddGlyphData(glyph_index, /*cx*/FTInfo.width, gdi32x, (FT_BitmapGlyph)*glyph_bitmap, render_mode, AAMode);\n\t\t\t} else {\n\t\t\t\tpftCache->AddCharData(wch, glyph_index, /*cx*/FTInfo.width, gdi32x, (FT_BitmapGlyph)*glyph_bitmap, render_mode, AAMode);\n\t\t\t}\n\t\t}\n\ncont:\n\t\t*Dx = FTInfo.x;\t\t//Dx的位置是下一个字符开始的基准位置，并不是下一个字符开始画的位置\n\t\t++Dx;\n\t}\ngdiexit:\n\tdelete[] ggi;\n//\tdelete[] gdi32w;\n\n\tif (!bGlyphIndex && bWindowsLink)\n\t{\n\t\tfor (int i=0;i<LinkNum;i++)\n\t\t\tdelete lpfontlink[i];\n\t\tdelete lpfontlink;\n\t}\n\treturn nRet;\n}\n\n\nBOOL ForEachGetGlyphGGO(FreeTypeDrawInfo& FTInfo, LPCTSTR lpString, int cbString, FT_Glyph* GlyphArray, FT_DRAW_STATE* drState)\n{\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\n\t//Snowie!!\n\tBOOL bIsSymbol = GetTextCharsetInfo(FTInfo.hdc, NULL, 0) == SYMBOL_CHARSET;\n\tBOOL bAllowDefaultLink = pSettings->GetFontLinkInfo().IsAllowFontLink((BYTE)GetTextCharsetInfo(FTInfo.hdc, NULL, 0));\t//是否为符号\n\tBOOL nRet = true;\n\tBOOL bWindowsLink = pSettings->FontLink()==2;\n\t//!!Snowie\n\n\t/*const*/ FT_Face freetype_face = FTInfo.freetype_face;\t//去掉常量属性，下面要改他\n\tconst FT_Int cmap_index = FTInfo.cmap_index;\n\tconst FT_Bool useKerning = FTInfo.useKerning;\n\tFT_Render_Mode render_mode = FTInfo.render_mode;\n\tconst int LinkNum = FTInfo.face_id_list_num;\n\tint AAMode = FTInfo.pfs->GetAntiAliasMode();\n\tint* AAList = FTInfo.AAModes;\n\tconst LOGFONTW& lf = FTInfo.LogFont();\n\tFreeTypeFontCache* pftCache = FTInfo.pftCache;\n\tconst CFontSettings*& pfs = FTInfo.pfs;\n\tFreeTypeFontInfo*& pfi\t= FTInfo.pfi;\n\tconst bool bGlyphIndex = FTInfo.IsGlyphIndex();\n\t//const bool bSizeOnly = FTInfo.IsSizeOnly();\n\t//const bool bOwnCache = !(FTInfo.font_type.flags & FT_LOAD_RENDER);\n\tconst LPCTSTR lpStart = lpString;\n\tconst LPCTSTR lpEnd = lpString + cbString;\n\tFT_UInt previous = 0;\n\tWCHAR previouswch = 0;\n\tconst bool bVertical = false;\n\tbool bLcdMode = render_mode == FT_RENDER_MODE_LCD;\n\tbool bLightLcdMode = (AAMode == 4) || (AAMode == 5);\n\tClpDx clpdx(FTInfo.lpDx, FTInfo.params->etoOptions);\n\tconst bool bWidthGDI32 = pSettings->WidthMode() == SETTING_WIDTHMODE_GDI32;\n\tconst int ggoformatbase = (FTInfo.font_type.flags & FT_LOAD_NO_HINTING) ? GGO_UNHINTED | GGO_NATIVE : GGO_NATIVE;\n\n\tif (!s_GGOGlyphLoader.init(freetype_library)) {\n\t\treturn FALSE;\n\t}\n// \tLPCTSTR dumy = lpString;\n// \tif (!bGlyphIndex)\n// \t for (; dumy<lpEnd;dumy++)\n// \t\tif (iswcntrl(*dumy))\n// \t\t{\n// \t\t\treturn false;\n// \t\t}\t\t\n\n\tWORD * gi = new WORD[cbString];\n\tWORD * ggi=gi;\n\t//int* gdi32w = new int[cbString];\n\t//int* ggdi32 = gdi32w;\n\t//SIZE* szSize =new SIZE[cbString];\n\t//SIZE* sSize = szSize;\n\n//Snowie!!\n\n//Fast fontlink\n\tWORD ** lpfontlink = NULL;\n\tHFONT hOldFont = NULL;\n\tif (!bGlyphIndex && bWindowsLink)\t//使用Windows fontlink\n\t{\n\t\tlpfontlink = (WORD**)new LPVOID[FTInfo.face_id_list_num];\n\t\tfor (int i=0;i<LinkNum;i++)\n\t\t{\n\t\t\tlpfontlink[i] = new WORD[cbString];\n\t\t\tZeroMemory(lpfontlink[i], sizeof(WORD)*cbString);\t//初始化为无链接\n\t\t}\n\t\t//\n\t\thOldFont = (HFONT)GetCurrentObject(FTInfo.hdc, OBJ_FONT);\t//加载第一个字体\n\t}\n//fontlink\n\n\t/*\n\tif (!FTInfo.lpDx)\t//没有预先计算排版，需要获得每个文字的宽度信息\n\t\t{\n\t\t\tif (bGlyphIndex)\n\t\t\t{\n\t\t\t\t(GetCharWidthI(FTInfo.hdc, *(LPWORD)lpString, cbString, (LPWORD)lpString, gdi32w));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int i=0;i<cbString;i++, ggdi32++)\n\t\t\t\t\tGetCharWidth32W(FTInfo.hdc, lpString[i], lpString[i], ggdi32);\n\t\t\t\tggdi32 = gdi32w;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//预先计算好了排版，只需要获得最后一个字的信息就可以了\n\t\t\tif (bGlyphIndex)\n\t\t\t{\n\t\t\t\t(GetCharWidthI(FTInfo.hdc, *(((LPWORD)lpString)+cbString-1), 1, (((LPWORD)lpString)+cbString-1), gdi32w+cbString-1));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tGetCharWidth32W(FTInfo.hdc, lpString[cbString-1], lpString[cbString-1], ggdi32+cbString-1);\n\t\t\t\tggdi32 = gdi32w;\n\t\t\t}\n\t\t}*/\n\t\n\tif (!bGlyphIndex)  \t//仅对win32情况进行优化，ft情况另议\n\t\tif (GetGlyphIndices(FTInfo.hdc, lpString, cbString, gi, GGI_MARK_NONEXISTING_GLYPHS)!=cbString) \n\t\t{\n\t\t\tnRet = false;\n\t\t\tgoto gdiexit;\n\t\t}\n//!!Snowie\n\tint* Dx= FTInfo.Dx;\n\tif (!bAllowDefaultLink && FTInfo.face_id_list_num > 1)\n\t\tFTInfo.face_id_list_num--;\t//如果是symbol页那就不链接到宋体\n\n\tfor (int i=0 ; lpString < lpEnd; ++lpString, gi++, GlyphArray++, drState++, ++AAList,/*ggdi32++,*/ i++){\n\t\tWCHAR wch = *lpString;\n\t\tif (!bGlyphIndex && bIsSymbol && !bWindowsLink)\n\t\t\twch |= 0xF000;\n\t\tFT_Glyph* glyph_bitmap = GlyphArray;\n\t\tint gdi32x = 0;// = *ggdi32;\n\t\tFTInfo.font_type.face_id = FTInfo.face_id_list[0];\n\t\tFreeTypeCharData* chData = NULL;\n\t\tFT_UInt glyph_index = 0;\n\t\tBOOL bIsBold = false, bIsIndivBold = false;\n\n\t\t{\n\t\t\t\n\t\t\tchData = bGlyphIndex\n\t\t\t\t? pftCache->FindGlyphIndex(wch)\n\t\t\t\t: pftCache->FindChar(wch);\n\n\t\t\tif (chData && FTInfo.width==chData->GetWidth()) {\n/*\n\t\t\t\tif (bSizeOnly) {\n\t\t\t\t\t//TRACE(_T(\"Cache hit: GetCharWidth [%c]\\n\"), *lpString);\n\t\t\t\t\tint cx = chData->GetWidth();\n\t\t\t\t\tFTInfo.x += (bWidthGDI32 ? gdi32x : cx) + FTInfo.params->charExtra;\n\t\t\t\t\tgoto cont;\n\t\t\t\t}*/\n\t\t\t\tgdi32x = chData->GetGDIWidth();\n\t\t\t\t*AAList = chData->GetAAMode();\n\t\t\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_LIBRARY);\n\t\t\t\tFT_Glyph_Copy((FT_Glyph)chData->GetGlyph(render_mode), glyph_bitmap);\n\t\t\t\t//TRACE(_T(\"Cache Hit: %wc, size:%d, 0x%8.8X\\n\"), wch, chData->GetWidth(), glyph_bitmap);\n\t\t\t}\n\t\t}\n\t\tif (!*glyph_bitmap) {\n\t\t\tFT_Glyph glyph = NULL;\n\t\t\tbool f_glyph = false;\n\t\t\tGLYPHMETRICS gm;\n\t\t\tconst MAT2 mat2 = {{0, 1}, {0, 0}, {0, 0}, {0, 1}};\n\t\t\tUINT ggoformat = ggoformatbase;\n\t\t\tCTempMem<PVOID> ggobuf;\n\t\t\tDWORD outlinesize = 0;\n\n\t\t\t\n\t\t\t\tif (bGlyphIndex) {\n\t\t\t\t\tf_glyph = true;\n\t\t\t\t\t*AAList = AAMode;\n\t\t\t\t\tglyph_index = wch;\n\t\t\t\t\tggoformat |= GGO_GLYPH_INDEX;\n\t\t\t\t\tGetCharWidthI(FTInfo.hdc, wch, 1, (LPWORD)&wch, &gdi32x);\t//index的文字必须计算宽度\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tif (*(gi) != 0xffff) {\n\t\t\t\t\t\t\tglyph_index = *(gi);\n\t\t\t\t\t\t\tf_glyph = true;\n\t\t\t\t\t\t\t*AAList = AAMode;\n\t\t\t\t\t\t}\n\t\t\t\t\tGetCharWidth32W(FTInfo.hdc, wch, wch, &gdi32x);\t//有效文字，计算宽度\n\t\t\t\t}\n\t\t\t\tif (lpString == lpStart && FTInfo.font_type.flags & FT_LOAD_FORCE_AUTOHINT) {\n\t\t\t\t\t// FORCE_AUTOHINT \n\t\t\t\t\tGetGlyphOutlineW(FTInfo.hdc, 0, GGO_METRICS | GGO_GLYPH_INDEX | GGO_NATIVE | GGO_UNHINTED, &gm, 0, NULL, &mat2);\n\t\t\t\t}\n\t\t\t\toutlinesize = GetGlyphOutlineW(FTInfo.hdc, wch, ggoformat, &gm, ggobuf.getsize(), ggobuf, &mat2);\n\n\t\t\t\tif (outlinesize == GDI_ERROR || outlinesize == 0){\n\t\t\t\t\tglyph_index = 0;\n\t\t\t\t\tf_glyph = false;\n\t\t\t\t} else \n\t\t\t\t{\n\t\t\t\t\tglyph_index = wch;\n\t\t\t\t\tf_glyph = true;\n\t\t\t\t}\n\n\n\t\t\tif (!f_glyph) {\t//glyphindex的文字上面已经计算过了\n#ifdef _DEBUG\n\t\t\t\tGdiSetBatchLimit(0);\n#endif\n\t\t\t\tif (*drState==FT_DRAW_NORMAL || bGlyphIndex)\n\t\t\t\t\t*drState = FT_DRAW_NOTFOUND;\t//找不到文字\n\t\t\t\tif ((!FTInfo.lpDx || lpString == lpEnd - 1) && !bGlyphIndex)\t//无效文字，而且没有事先排版或者是排版的最后一个字符了\n\t\t\t\t{\n\t\t\t\t\tGetCharWidth32W(FTInfo.hdc, wch, wch, &gdi32x);\n\t\t\t\t}\n\t\t\t\tint cx = gdi32x;\n/*\n\t\t\t\tif (bSizeOnly) {\n\t\t\t\t\tFTInfo.x += cx;\n\t\t\t\t} else*/\n\t\t\t\t\n\t\t\t\t{\n\t\t\t\t\tif (wch) {\n\t\t\t\t\t\t*glyph_bitmap = NULL;\t//无效文字\n\t\t\t\t\t\t//ORIG_ExtTextOutW(FTInfo.hdc, FTInfo.x, FTInfo.yTop, FTInfo.GetETO(), NULL, &wch, 1, NULL);\n\t\t\t\t\t}\n\t\t\t\t\tBOOL isc = bGlyphIndex ? false : (CID.myiswcntrl(*lpString));\n\t\t\t\t\tif (isc)\n\t\t\t\t\t\tcx = 0;\n\t\t\t\t\tif (lpString < lpEnd - 1) {\n\t\t\t\t\t\tFTInfo.x += clpdx.get(cx);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//if (gdi32x)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\n\t/*\t\t\t\t\t\tABC abc = {0, cx, 0};\n\t\t\t\t\t\t\tif (bGlyphIndex)\n\t\t\t\t\t\t\t\tGetCharABCWidthsI(FTInfo.hdc, wch, 1, NULL, &abc);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tGetCharABCWidths(FTInfo.hdc, wch, wch, &abc);*/\n\t\t\t\t\t\t\t//FTInfo.px = FTInfo.x+Max(clpdx.get(cx), abc.abcA+(int)abc.abcB+abc.abcC);\t//无效文字的情况下，绘图宽度=鼠标位置\n\t\t\t\t\t\t\tFTInfo.px = FTInfo.x + cx;\t\n\t\t\t\t\t\t\tFTInfo.x += clpdx.get(cx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif (!isc)\n\t\t\t\t\tFTInfo.x += FTInfo.params->charExtra;\n\t\t\t\t}\n\t\t\t\tgoto cont;\n\t\t\t}\n\n\t\t\t\n\t\t\t\tif(useKerning && !bGlyphIndex){\n\t\t\t\t\tif (previouswch && wch) {\n\t\t\t\t\t\tFTInfo.x += FTInfo.ggokerning.get(previouswch, wch);\n\t\t\t\t\t}\n\t\t\t\t\tpreviouswch = wch;\n\t\t\t\t}\n\n\n\t\t\t// 縦横\n\t\t\tif(bVertical && IsVerticalChar(wch)){\n\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_VERTICAL_LAYOUT;\n\t\t\t\tif(bLcdMode){\n\t\t\t\t\tif(!bLightLcdMode){\n\t\t\t\t\t\tFTInfo.font_type.flags &= ~FT_LOAD_TARGET_LCD;\n\t\t\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_TARGET_LCD_V;\n\t\t\t\t\t}\n\t\t\t\t\trender_mode             = FT_RENDER_MODE_LCD_V;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif (bVertical)\n\t\t\t\t\tswap(FTInfo.font_type.height, FTInfo.font_type.width);\t//交换无法旋转的文字宽高\n\t\t\t\tFTInfo.font_type.flags &=~FT_LOAD_VERTICAL_LAYOUT;\n\t\t\t\tif(bLcdMode){\n\t\t\t\t\tif(!bLightLcdMode){\n\t\t\t\t\t\tFTInfo.font_type.flags &= ~FT_LOAD_TARGET_LCD_V;\n\t\t\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_TARGET_LCD;\n\t\t\t\t\t}\n\t\t\t\t\trender_mode             = FT_RENDER_MODE_LCD;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCGGOOutlineGlyph ggoog;\n\t\t{\n\t\t\t\n\t\t\t\tif (outlinesize > ggobuf.getsize()) {\n\t\t\t\t\tif (!ggobuf.init(outlinesize)) {\n\t\t\t\t\t\tnRet= false;\n\t\t\t\t\t\tgoto gdiexit;\n\t\t\t\t\t}\n\t\t\t\t\t//ggofont.change();\n\t\t\t\t\toutlinesize = GetGlyphOutlineW(FTInfo.hdc, wch, ggoformat, &gm, ggobuf.getsize(), ggobuf, &mat2);\n\t\t\t\t\t//ggofont.restore();\n\t\t\t\t}\n\t\t\t\tif (outlinesize > ggobuf.getsize()) {\n\t\t\t\t\tnRet= false;\n\t\t\t\t\tgoto gdiexit;\n\t\t\t\t}\n\t\t\t\tif (!ggoog.init(outlinesize, ggobuf, gm)) {\n\t\t\t\t\tnRet= false;\n\t\t\t\t\tgoto gdiexit;\n\t\t\t\t}\n\t\t\t\t//glyph = New_FT_Ref_Glyph();\n\t\t\t\t//FT_Glyph_Copy((FT_Glyph)ggoog, &glyph);\n\t\t\t\tglyph = ggoog;\n\t\t}\n\t\t{\n\t\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_LIBRARY);\n\t\t\tif (FT_Glyph_Copy(glyph, glyph_bitmap))\n\t\t\t{\t\n\t\t\t\t//FT_Done_Glyph(glyph);\n\t\t\t\tnRet = FALSE;\n\t\t\t\tgoto gdiexit;\n\t\t\t}\n\t\t\t//FT_Done_Glyph(glyph);\n\t\t}\n\t\t\tif((*glyph_bitmap)->format != FT_GLYPH_FORMAT_BITMAP){\n\t\t\t\tint str_h;\n\t\t\t\tint str_v;\n\t\t\t\tbool fbold = false;\n\t\t\t\tstr_h = str_v = FTInfo.pfi->CalcNormalWeight();\n\t\t\t\tif (bIsIndivBold)\n\t\t\t\t\tstr_h = str_v = FTInfo.pfi->GetExactBoldWeight()<<2;\n\t\t\t\tif (bIsBold) {\n\t\t\t\t\tfbold = true;\n\t\t\t\t\tstr_h += FTInfo.font_type.height<24 ? FTInfo.pfi->GetFTWeight(): (FTInfo.pfi->GetFTWeight()*FTInfo.font_type.height/24);\n\t\t\t\t\tstr_v = str_h;\n\t\t\t\t}\n\t\t\t\tif((str_h || str_v) && New_FT_Outline_Embolden(\n\t\t\t\t\t   &((FT_OutlineGlyph)((*glyph_bitmap)))->outline,\n\t\t\t\t\t   str_h, str_v, FTInfo.height))\n\t\t\t\t\t{\n\t\t\t\t\t\tFT_Done_Glyph(*glyph_bitmap);\n\t\t\t\t\t\tnRet= false;\n\t\t\t\t\t\tgoto gdiexit;\n\t\t\t\t\t}\n\n\t\t\t\tif (fbold) {\n\t\t\t\t\t((FT_BitmapGlyph)((*glyph_bitmap)))->root.advance.x += 0x10000;\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_LIBRARY);\n\t\t\t\t\tif(FT_Glyph_To_Bitmap(&((*glyph_bitmap)), render_mode, 0, 1)){\n\t\t\t\t\t\tFT_Done_Glyph(*glyph_bitmap);\n\t\t\t\t\t\tnRet= false;\n\t\t\t\t\t\tgoto gdiexit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint cx = (bVertical && IsVerticalChar(wch)) ?\n\t\t\t\tFT_FixedToInt(FT_BitmapGlyph((*glyph_bitmap))->root.advance.y) :\n\t\t\t\tFT_FixedToInt(FT_BitmapGlyph((*glyph_bitmap))->root.advance.x);\n//done\n/*\n\t\tif (bSizeOnly) {\n\t\t\tFTInfo.x += bWidthGDI32 ? gdi32x : cx;\n\t\t} else */\n\t\t{\n\t\t\tint dx = clpdx.get(bWidthGDI32 ? gdi32x : cx);\t//获得宽度\n\t\t\tint left = FT_BitmapGlyph((*glyph_bitmap))->left;\n\t\t\tif (FTInfo.x + left< FTInfo.xBase)\n\t\t\t\tFTInfo.xBase = FTInfo.x + left;\t//如果有字符是负数起始位置的（合成符号）， 调整文字的起始位置\n\n\t\t\tif (lpString < lpEnd - 1) {\n\t\t\t\tFTInfo.x += dx;\n\t\t\t} else {\n\t\t\t\tint bx = FT_BitmapGlyph((*glyph_bitmap))->bitmap.width;\n\t\t\t\tif (render_mode == FT_RENDER_MODE_LCD) bx /= 3;\n\t\t\t\tbx += left;\n\t\t\t\tFTInfo.px = FTInfo.x + Max(Max(dx, bx), cx);\t//有文字的情况下,绘图宽度=ft计算的宽度，鼠标位置=win宽度\n\t\t\t\tFTInfo.x += dx;//Max(dx, gdi32x);//Max(Max(dx, bx), cx);\n\t\t\t}\n\n\t\t}\n\t\tFTInfo.x += FTInfo.params->charExtra;\n\n\t\t//if (bSizeOnly || bOwnCache) {\n\t\t\t//キャッシュ化\n\t\tif (glyph_index) {\n\t\t\t\n\t\t\tif (bGlyphIndex) {\n\t\t\t\tpftCache->AddGlyphData(glyph_index, /*cx*/FTInfo.width, gdi32x, (FT_BitmapGlyph)*glyph_bitmap, render_mode, AAMode);\n\t\t\t} else {\n\t\t\t\tpftCache->AddCharData(wch, glyph_index, /*cx*/FTInfo.width, gdi32x, (FT_BitmapGlyph)*glyph_bitmap, render_mode, AAMode);\n\t\t\t}\n\t\t}\n\t\t//}\n// \t\tif (!bGlyphIndex && iswcntrl(wch) && *glyph_bitmap)\n// \t\t{\n// \t\t\t\n// \t\t\tFT_Done_Glyph(*glyph_bitmap);\n// \t\t\t*glyph_bitmap = NULL;\n// \t\t}\ncont:\n\t\t*Dx = FTInfo.x;\n\t\tDx++;\n\t}\ngdiexit:\n\tdelete[] ggi;\n//\tdelete[] gdi32w;\n\n\tif (!bGlyphIndex && bWindowsLink)\n\t{\n\t\tfor (int i=0;i<LinkNum;i++)\n\t\t\tdelete lpfontlink[i];\n\t\tdelete lpfontlink;\n\t}\n\treturn nRet;\n}\n\n\nBOOL GetLogFontFromDC(HDC hdc, LOGFONT& lf)\n{\n\tLOGFONTW lfForce = { 0 };\n\tHFONT hf = GetCurrentFont(hdc);\n\tif (!ORIG_GetObjectW(hf, sizeof(LOGFONTW), &lf))\n\t\treturn FALSE;\n\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\n\t//if (pSettings->CopyForceFont(lfForce, lf))\n\t//\tlf = lfForce;\n\n\tif(pSettings->LoadOnDemand()) {\n\t\t//AddFontToFT(lf.lfFaceName, lf.lfWeight, !!lf.lfItalic);\n\t}\n\treturn TRUE;\n}\n\nBOOL CALLBACK TextOutCallback(FreeTypeGlyphInfo& FTGInfo)\n{\n\tFreeTypeDrawInfo* FTInfo = FTGInfo.FTInfo;\n\tFT_BitmapGlyph& glyph_bitmap = FTGInfo.FTGlyph;\n\tconst bool bVertical = FTInfo->LogFont().lfFaceName[0] == _T('@');\n\tint nOldAlpha = FTInfo->params->alpha;\n\n\tif (!FTGInfo.FTGlyph->bitmap.buffer) {\n\t\t//if (FTInfo->params->alpha == 1) {\n// \t\tif (!(FTInfo->GetETO() & ETO_GLYPH_INDEX) && wch==32)\t//空格\n// \t\t\tORIG_ExtTextOutW(FTInfo->hdc, FTInfo->x, FTInfo->yTop, FTInfo->GetETO() & ETO_IGNORELANGUAGE, NULL, &wch, 1, NULL);\n// \t\telse\n\t\t\tORIG_ExtTextOutW(FTInfo->hdc, FTInfo->x, FTInfo->yTop, FTInfo->GetETO(), NULL, &FTGInfo.wch, 1, NULL);\n\t\t//}\n\t} else {\n\t\t\n\t\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\n\t\tif (bVertical && IsVerticalChar(FTGInfo.wch) &&\n\t\t\tpSettings->FontLoader() == SETTING_FONTLOADER_FREETYPE) {\n\t\t\tif (FTInfo->params->alpha>1)\n\t\t\t{\n\t\t\t\tFreeTypeDrawBitmapV(FTGInfo, *FTGInfo.shadow, FTInfo->x + FTInfo->sx, \n\t\t\t\t\tFTInfo->params->otm->otmTextMetrics.tmHeight - (glyph_bitmap->left+glyph_bitmap->bitmap.width) -1 + FTInfo->sy);//画阴影\n\t\t\t\tFTInfo->params->alpha = 1;\n\t\t\t}\n\t\t\tFreeTypeDrawBitmapV(FTGInfo,*FTGInfo.solid,\tFTInfo->x,\n\t\t\t\tFTInfo->params->otm->otmTextMetrics.tmHeight - (glyph_bitmap->left+glyph_bitmap->bitmap.width) -1);\t//画文字\t\n\t\t}else{\n\t\t\tif (FTInfo->params->alpha>1)\n\t\t\t{\n\t\t\t\tFreeTypeDrawBitmap(FTGInfo,*FTGInfo.shadow,\n\t\t\t\t\tFTInfo->x + glyph_bitmap->left + FTInfo->sx,\n\t\t\t\t\tFTInfo->yBase - glyph_bitmap->top + FTInfo->sy);\t//画阴影\n\t\t\t\tFTInfo->params->alpha = 1;\n\t\t\t}\n\t\t\tFreeTypeDrawBitmap(FTGInfo,*FTGInfo.solid,\n\t\t\t\tFTInfo->x + glyph_bitmap->left,\n\t\t\t\tFTInfo->yBase - glyph_bitmap->top);\t//画文字\n\n\t\t}\n\t}\n\tFTInfo->params->alpha = nOldAlpha;\n\treturn TRUE;\n}\n\nint IsColorDark(DWORD Color, double Gamma) \n{\n\t//return (GetRValue(Color)*0.299 + GetGValue(Color)*0.587 + GetBValue(Color)*0.114);\t//原始算法\n\t//===============================================================\n\t//采用Photoshop sRGB的RGB->Lab算法进行换算，L为色彩视觉亮度\n\t//感谢 西安理工大学 贾婉丽 的分析\n\t//===============================================================\n\tstatic double s_multipler = 116/pow(100,(double)1.0/3.0);\t//预计算常数,强制使用double版本\n\tdouble* RGBTable = s_AlphaBlendTable.GetRGBTable();\t//获得显示器转换表\n\tdouble ret = pow(23.9746*RGBTable[GetRValue(Color)] + 73.0653*RGBTable[GetGValue(Color)] + 6.13799*RGBTable[GetBValue(Color)] , 1.0/3.0)*s_multipler-16;\n\treturn max(int(ret + 0.499),0);\n\t\n\t/*double r = GetRValue(Color)/255.0;\n\tdouble g = GetGValue(Color)/255.0;\n\tdouble b = GetBValue(Color)/255.0;\n\tdouble v;\n\tdouble m;\n\tdouble vm;\n\tdouble r2, g2, b2;\n\n\tdouble h = 0; // default to black\n\tdouble s = 0;\n\tdouble l = 0;\n\tv = Max(r,g);\n\tv = Max(v,b);\n\tm = Min(r,g);\n\tm = Min(m,b);\n\tl = (m + v) / 2.0;\n\tif (l <= 0.0)\n\t{\n\t\treturn 0;\n\t}\n\tvm = v - m;\n\ts = vm;\n\tif (s > 0.0)\n\t{\n\t\ts /= (l <= 0.5) ? (v + m ) : (2.0 - v - m) ;\n\t}\n\telse\n\t{\n\t\treturn l;\n\t}\n\tr2 = (v - r) / vm;\n\tg2 = (v - g) / vm;\n\tb2 = (v - b) / vm;\n\tif (r == v)\n\t{\n\t\th = (g == m ? 5.0 + b2 : 1.0 - g2);\n\t}\n\telse if (g == v)\n\t{\n\t\th = (b == m ? 1.0 + r2 : 3.0 - b2);\n\t}\n\telse\n\t{\n\t\th = (r == m ? 3.0 + g2 : 5.0 - r2);\n\t}\n\th /= 6.0;\n\treturn l;*/\n}\n\n/*\nBOOL GetColorDiff(DWORD Color)\n{\n\t/ *const CGdippSettings* pSettings = CGdippSettings::GetInstance();\n\tDWORD ShadowColorD = pSettings->ShadowDarkColor();\n\tDWORD ShadowColorL = pSettings->ShadowLightColor();\n\tDWORD ColorDiffD = RGBA(abs(GetRValue(Color)-GetRValue(ShadowColorD)),abs(GetGValue(Color)-GetGValue(ShadowColorD)),abs(GetBValue(Color)-GetBValue(ShadowColorD)),0);\n\tDWORD ColorDiffL = RGBA(abs(GetRValue(Color)-GetRValue(ShadowColorL)),abs(GetGValue(Color)-GetGValue(ShadowColorL)),abs(GetBValue(Color)-GetBValue(ShadowColorL)),0);\n\tdouble cd = IsColorDark(ColorDiffD), cl = IsColorDark(ColorDiffL);\n\treturn cd==cl ? IsColorDark(Color)<0.7 : cd>cl;* /\n}*/\n\nBOOL FreeTypeTextOut(\n\tconst HDC hdc,     // デバイスコンテキストのハンドル\n\tCBitmapCache& cache,\n\tLPCWSTR lpString,  // 文字列\n\tint cbString,      // 文字数\n\tFreeTypeDrawInfo& FTInfo,\n\tFT_Glyph * Glyphs,\n\tFT_DRAW_STATE* drState\n\t)\n{\n\tif(cbString <= 0 || lpString == NULL)\n\t\treturn FALSE;\n\tCAlphaBlendColor * solid = NULL;\n\tCAlphaBlendColor * shadow = NULL;\n\t\n\t//CCriticalSectionLock __lock;\n\n\tFT_Face freetype_face = FTInfo.freetype_face;\n\tconst LOGFONT& lf = FTInfo.LogFont();\n\n\tFTInfo.x     = -FTInfo.xBase;\n\tFTInfo.yTop  = 0;\n\n\tconst TEXTMETRIC& tm = FTInfo.params->otm->otmTextMetrics;\n\tFTInfo.yBase = tm.tmAscent;\n\n//===============计算颜色缓存======================\n\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\n\tint lightdiff, darkdiff, bDarkColor=0, ShadowColor=0;\n\tif (FTInfo.params->alpha!=1)\n\t{\n\t\tfloat Gamma = pSettings->GammaValue();\n\t\tbDarkColor = IsColorDark(FTInfo.params->color, Gamma);\n\t\tint diff = max(darkdiff=abs(IsColorDark(pSettings->ShadowDarkColor(), Gamma)-bDarkColor), lightdiff=abs(IsColorDark(pSettings->ShadowLightColor(), Gamma)-bDarkColor));\n\t\tShadowColor = lightdiff<=darkdiff ? pSettings->ShadowDarkColor() : pSettings->ShadowLightColor();\n\t\tbDarkColor = lightdiff<=darkdiff;\n\t\tif (/*diff<10 || abs(lightdiff-darkdiff)<20 &&*/ pSettings->ShadowDarkColor()==pSettings->ShadowLightColor())\n\t\t{\n\t\t//无视底色问题，强制开启阴影\n\t\t\tFTInfo.params->alphatuner = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdiff = abs(lightdiff-darkdiff);\n\t\t\tif (diff<10)\n\t\t\t\tFTInfo.params->alpha = 1;\n\t\t\telse\n\t\t\t\tFTInfo.params->alphatuner = max(1, 100/diff);\t//根据色差调整阴影浓度\n\t\t}\n\t}\n\tchar mode = (*Glyphs)? FT_BitmapGlyph((*Glyphs))->bitmap.pixel_mode:FT_PIXEL_MODE_LCD;\n\tswitch(mode){\n\t\t\tcase FT_PIXEL_MODE_MONO:\n\t\t\t\treturn false;\n\t\t\t\t//break;\n\t\t\tcase FT_PIXEL_MODE_LCD:\n\t\t\t\tsolid = new CAlphaBlendColor( FTInfo.params->color, 1, true, true,true);\n\t\t\t\tshadow = new CAlphaBlendColor( /*FTInfo.params->color*/ShadowColor, FTInfo.params->alpha, true, bDarkColor, true);\n\t\t\t\tbreak;\n\t\t\tcase FT_PIXEL_MODE_LCD_V:\n\t\t\t\tsolid = new CAlphaBlendColor( FTInfo.params->color, 1, true, true,false);\n\t\t\t\tshadow = new CAlphaBlendColor( /*FTInfo.params->color*/ShadowColor, FTInfo.params->alpha, true, bDarkColor, false);\n\t\t\t\tbreak;\n\t\t\tcase FT_PIXEL_MODE_GRAY:\n\t\t\t\tsolid = new CAlphaBlendColor( FTInfo.params->color, 1, false,true, true);\n\t\t\t\tshadow = new CAlphaBlendColor( /*FTInfo.params->color*/ShadowColor, FTInfo.params->alpha, false, bDarkColor, true);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsolid = new CAlphaBlendColor( FTInfo.params->color, 1, pSettings->LcdFilter(),true);\n\t\t\t\tshadow = new CAlphaBlendColor( /*FTInfo.params->color*/ShadowColor, FTInfo.params->alpha, pSettings->LcdFilter(), bDarkColor);\n\t\t\t\tbreak;\n\t}\n\n//===============计算完成==========================\n\n\tFreeTypeGlyphInfo FTGInfo = {&FTInfo, 0, 0, 0, solid, shadow};\n\tfor (int i=0; i<cbString; ++i, ++lpString)\n\t{\n\t\tWCHAR wch = *lpString;\n\t\tif (Glyphs[i])\n\t\t{\n\t\t\tFTGInfo.wch = wch;\n\t\t\tFTGInfo.FTGlyph = (FT_BitmapGlyph)(Glyphs[i]);\n\t\t\tFTGInfo.AAMode = FTInfo.AAModes[i];\n\t\t\tTextOutCallback(FTGInfo);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint j = i;\n\t\t\tFT_DRAW_STATE st= drState[i];\n\t\t\twhile (++j<cbString && !Glyphs[j] && drState[j]==st){};\n\t\t\tif (st==FT_DRAW_EMBEDDED_BITMAP)\n\t\t\t\tORIG_ExtTextOutW(hdc, FTInfo.x, FTInfo.yTop, FTInfo.GetETO() & ETO_IGNORELANGUAGE, NULL, lpString, j-i, FTInfo.lpDx ? FTInfo.lpDx + i:NULL);\n\t\t\telse\n\t\t\t\tORIG_ExtTextOutW(hdc, FTInfo.x, FTInfo.yTop, FTInfo.GetETO(), NULL, lpString, j-i, FTInfo.lpDx ? FTInfo.lpDx + i:NULL);\n\t\t\tlpString += --j - i;\n\t\t\ti = j;\n\t\t}\n\t\tFTInfo.x=FTInfo.Dx[i];\n\t}\n\n\tif (shadow)\n\t\tdelete shadow;\n\tif (solid)\n\t\tdelete solid;\n\n\tint x = FTInfo.x;\n\tint y = FTInfo.yBase;\n\n\t// 下線を(あれば)引く\n\n\tif(lf.lfUnderline || lf.lfStrikeOut) {\n\t\tOUTLINETEXTMETRIC &otm = *FTInfo.params->otm;\n\t\tif(lf.lfUnderline){\n\t\t\tint yPos = 0; //下線の位置\n\t\t\tint height = 0;\n\t\t\tint thickness = 0; // 適当な太さ\n\t\t\tswitch (pSettings->FontLoader()) {\n\t\t\tcase SETTING_FONTLOADER_FREETYPE:\n\t\t\t\tyPos = y - otm.otmsUnderscorePosition;\n\t\t\t\theight = otm.otmTextMetrics.tmHeight; //FT_PosToInt(freetype_face->size->metrics.height);\n\t\t\t\tthickness =\n\t\t\t\t\tMulDiv(freetype_face->underline_thickness,\n\t\t\t\t\t\tFTInfo.font_type.height/*freetype_face->size->metrics.y_ppem*/,\n\t\t\t\t\t\tfreetype_face->units_per_EM);\n\t\t\t\tbreak;\n\t\t\tcase SETTING_FONTLOADER_WIN32:\n\t\t\t\tyPos = y - otm.otmsUnderscorePosition;\n\t\t\t\theight = otm.otmTextMetrics.tmHeight;\n\t\t\t\tthickness = otm.otmsUnderscoreSize;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (yPos >= height) {\n\t\t\t\tyPos = height - 1;\n\t\t\t}\n\t\t\tcache.DrawHorizontalLine(0, yPos, x, FTInfo.Color(), thickness);\n\t\t}\n\n\t\tif(lf.lfStrikeOut){\n\t\t\tint yPos = y - otm.otmsStrikeoutPosition; \n\t\t\tint thickness = 0; \n\t\t\tswitch (pSettings->FontLoader()) {\n\t\t\tcase SETTING_FONTLOADER_FREETYPE:\n\t\t\t\tthickness =\n\t\t\t\t\tMulDiv(freetype_face->underline_thickness,\n\t\t\t\t\t\tFTInfo.font_type.height,// freetype_face->size->metrics.y_ppem,\n\t\t\t\t\t\tfreetype_face->units_per_EM);\n\t\t\t\tbreak;\n\t\t\tcase SETTING_FONTLOADER_WIN32:\n\t\t\t\tthickness = otm.otmsStrikeoutSize;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcache.DrawHorizontalLine(0, yPos, x, FTInfo.Color(), thickness);\n\t\t}\n\t}\n\treturn TRUE;\n}\n\nBOOL FreeTypeGetGlyph(\t//获得所有图形和需要的宽度\n\t\t\t\t\t FreeTypeDrawInfo& FTInfo,\n\t\t\t\t\t LPCWSTR lpString,  \n\t\t\t\t\t int cbString,     \n\t\t\t\t\t int& width,\n\t\t\t\t\t FT_Glyph* Glyphs,\n\t\t\t\t\t FT_DRAW_STATE* drState\n\t\t\t\t\t )\n{\n\tCOwnedCriticalSectionLock __lock(1);\n\t{\n\t\t//CCriticalSectionLock __lock;\n\t\tif (!FreeTypePrepare(FTInfo))\n\t\t\treturn false;\n\t}\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\n\tBOOL nRet = false;\n\tswitch (pSettings->FontLoader()) {\n\t\t\tcase SETTING_FONTLOADER_FREETYPE:\n\t\t\t\tnRet = ForEachGetGlyphFT(FTInfo,lpString,cbString,Glyphs,drState);\n\t\t\t\tbreak;\n\t\t\tcase SETTING_FONTLOADER_WIN32:\n\t\t\t\tnRet = ForEachGetGlyphGGO(FTInfo,lpString,cbString,Glyphs,drState);\n\t\t\t\tbreak;\n\t}\n\twidth = FTInfo.px;\t//获得了宽度\n\treturn nRet;\n}\n\n\n\nvoid VertFinalizer(void *object){\n\tFT_Face face = (FT_Face)object;\n\tft2vert_final(face, (struct ft2vert_st *)face->generic.data);\n}\n//\n// グリフをIVSで指定された字形をサポートするかどうか調べ、\n// サポートしている場合はグリフを置換する。\n// サポートしていなければ何もしない。\n//\n/*\nvoid FreeTypeSubstGlyph(const HDC hdc, \n\t\t\t\t\t\tconst WORD vsindex,\n\t\t\t\t\t\tconst int baseChar,\n\t\t\t\t\t\tint cChars, \n\t\t\t\t\t\tSCRIPT_ANALYSIS* psa, \n\t\t\t\t\t\tWORD* pwOutGlyphs, \n\t\t\t\t\t\tWORD* pwLogClust, \n\t\t\t\t\t\tSCRIPT_VISATTR* psva, \n\t\t\t\t\t\tint* pcGlyphs \n\t\t\t\t\t\t)\n{\n\tCThreadLocalInfo* pTLInfo = g_TLInfo.GetPtr();\n\tCBitmapCache& cache = pTLInfo->BitmapCache();\n\tCCriticalSectionLock __lock;\n\n\tLOGFONT lf;\n\tif (!GetLogFontFromDC(hdc, lf))\n\t\treturn;\n\n\tFREETYPE_PARAMS params(0, hdc);\n\tFreeTypeDrawInfo FTInfo(params, hdc, &lf, &cache);\n\tif(!FreeTypePrepare(FTInfo))\n\t\treturn;\n\n\tFT_UInt glyph_index = ft2_subst_uvs(FTInfo.freetype_face, pwOutGlyphs[*pcGlyphs - 1], vsindex, baseChar);\n\tTRACE(_T(\"FreeTypeSubstGlyph: %04X->%04X\\n\"), pwOutGlyphs[*pcGlyphs - 1], glyph_index);\n\tif (glyph_index) {\n\t\tpwOutGlyphs[*pcGlyphs - 1] = glyph_index; // 置換を実行\n\t\t// ASCII空白のグリフを取得\n\t\tglyph_index = FTC_CMapCache_Lookup(\n\t\t\tcmap_cache,\n\t\t\tFTInfo.font_type.face_id,\n\t\t\tFTInfo.cmap_index,\n\t\t\t' ');\n\t\t// ゼロ幅グリフにする\n\t\tpwOutGlyphs[*pcGlyphs] = glyph_index;\n\t\tpsva[*pcGlyphs].uJustification = SCRIPT_JUSTIFY_NONE;\n\t\tpsva[*pcGlyphs].fClusterStart = 0;\n\t\tpsva[*pcGlyphs].fDiacritic = 0;\n\t\tpsva[*pcGlyphs].fZeroWidth = 1;\n\t\tpsva[*pcGlyphs].fReserved = 0;\n\t\tpsva[*pcGlyphs].fShapeReserved = 0;\n\t} else {\n\t\t// フォントは指定された字形を持たない。IVSのグリフを取得\n\t\tglyph_index = FTC_CMapCache_Lookup(\n\t\t\tcmap_cache,\n\t\t\tFTInfo.font_type.face_id,\n\t\t\tFTInfo.cmap_index,\n\t\t\tvsindex + 0xE0100);\n\t\t// IVSをサポートしていないフォントはIVSのグリフを持っている可能性もほとんどない。\n\t\t// missing glyphを返すとフォールバックされてしまうため確実に持っていそうなグリフを拾う\n\t\tif (!glyph_index)\n\t\t\tglyph_index = FTC_CMapCache_Lookup(\n\t\t\tcmap_cache,\n\t\t\tFTInfo.font_type.face_id,\n\t\t\tFTInfo.cmap_index,\n\t\t\t0x30FB);\n\t\tpwOutGlyphs[*pcGlyphs] = glyph_index;\n\t\tpsva[*pcGlyphs] = psva[*pcGlyphs - 1];\n\t\tpsva[*pcGlyphs].fClusterStart = 0;\n\t}\n\tpwLogClust[cChars - 2] = *pcGlyphs;\n\tpwLogClust[cChars - 1] = *pcGlyphs;\n\t++*pcGlyphs;\n}*/\n\n\nFT_Error face_requester(\n\t\tFTC_FaceID face_id,\n\t\tFT_Library /*library*/,\n\t\tFT_Pointer /*request_data*/,\n\t\tFT_Face* aface)\n{\n\tFT_Error ret;\n\tFT_Face face;\n\n\tFreeTypeFontInfo* pfi = g_pFTEngine->FindFont((int)face_id);\n\tAssert(pfi);\n\tif (!pfi) {\n\t\treturn FT_Err_Invalid_Argument;\n\t}\n\tLPCTSTR fontname = pfi->GetName();\n\n\t// 名称を指定してフォントを取得\n\tFreeTypeSysFontData* pData = FreeTypeSysFontData::CreateInstance(fontname, pfi->GetFontWeight(), pfi->IsItalic());\n\tif(pData == NULL){\n\t\treturn FT_Err_Cannot_Open_Resource;\n\t}\n\n\tface = pData->GetFace();\n\tAssert(face != NULL);\n\n\t// Charmapを設定しておく\n\tret = FT_Select_Charmap(face, FT_ENCODING_UNICODE);\n\tif(ret != FT_Err_Ok)\n\t\tret = FT_Select_Charmap(face, FT_ENCODING_MS_SYMBOL);\n/*\n\tif(ret != FT_Err_Ok)\n\t\tret = FT_Select_Charmap(face, FT_ENCODING_SJIS);\n\tif(ret != FT_Err_Ok)\n\t\tret = FT_Select_Charmap(face, FT_ENCODING_GB2312);\n\tif(ret != FT_Err_Ok)\n\t\tret = FT_Select_Charmap(face, FT_ENCODING_BIG5);\n\tif(ret != FT_Err_Ok)\n\t\tret = FT_Select_Charmap(face, FT_ENCODING_WANSUNG);\n\tif(ret != FT_Err_Ok)\n\t\tret = FT_Select_Charmap(face, FT_ENCODING_JOHAB);\n\tif(ret != FT_Err_Ok)\n\t\tret = FT_Select_Charmap(face, FT_ENCODING_ADOBE_STANDARD);\n\tif(ret != FT_Err_Ok)\n\t\tret = FT_Select_Charmap(face, FT_ENCODING_ADOBE_EXPERT);\n\tif(ret != FT_Err_Ok)\n\t\tret = FT_Select_Charmap(face, FT_ENCODING_ADOBE_CUSTOM);\n\tif(ret != FT_Err_Ok)\n\t\tret = FT_Select_Charmap(face, FT_ENCODING_ADOBE_LATIN_1);\n\tif(ret != FT_Err_Ok)\n\t\tret = FT_Select_Charmap(face, FT_ENCODING_OLD_LATIN_2);\n\tif(ret != FT_Err_Ok)\n\t\tret = FT_Select_Charmap(face, FT_ENCODING_APPLE_ROMAN); */\n\n\tif(ret != FT_Err_Ok)\n\t{\n\t\tFT_Done_Face(face);\n\t\treturn ret;\n\t}\n\tstruct ft2vert_st *vert = ft2vert_init(face);\n\tface->generic.data = vert;\n\tface->generic.finalizer = VertFinalizer;\n\n\t*aface = face;\n\treturn 0;\n}\n\n\n/*\nDWORD FreeTypeGetVersion()\n{\n\tint major = 0, minor = 0, patch = 0;\n\tFT_Library_Version(freetype_library, &major, &minor, &patch);\n\t//面倒なのでRGBマクロ使用\n\treturn RGB(major, minor, patch);\n}*/\n\n\n//新太字アルゴリズム\nFT_Error New_FT_Outline_Embolden( FT_Outline*  outline, FT_Pos str_h, FT_Pos str_v, FT_Int font_size )\n{\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\n\tint orientation = 0;\n\tswitch (pSettings->BolderMode()) {\n\tcase 1:\n\t\treturn FT_Outline_EmboldenXY( outline, str_h, 0);\n\n\tcase 2:\n\t\treturn FT_Outline_Embolden( outline, str_h );\n\n\tdefault:\n\t\t{\n\t\t\tif ( !outline ) return FT_Err_Invalid_Argument;\n\t\t\t//orientation = FT_Outline_Get_Orientation( outline );\n\t\t\t//if ( orientation == FT_ORIENTATION_NONE )\n\t\t\t//\tif ( outline->n_contours ) return FT_Err_Invalid_Argument;\n/*\n\t\t\tif (font_size>FT_BOLD_LOW || str_h<16)\n\t\t\t\tVert_FT_Outline_Embolden( outline, str_v );\n\t\t\tOld_FT_Outline_Embolden( outline, str_h );*/\n\t\t\tif (font_size<FT_BOLD_LOW && str_h>32)\n\t\t\t{\n\t\t\t\tFT_Outline_EmboldenXY(outline, str_h, Min(long(32), str_v));\n\t\t\t}\n\t\t\telse\n\t\t\t\tFT_Outline_Embolden(outline, str_h);\n\t\t\treturn FT_Err_Ok;\n\t\t}\n\t}\n}\n\n//横方向だけ太らせるFT_Outline_Embolden\nFT_Error Old_FT_Outline_Embolden( FT_Outline*  outline, FT_Pos strength )\n{\n\tFT_Vector*\tpoints;\n\tFT_Vector\tv_prev, v_first, v_next, v_cur;\n\tFT_Angle\trotate, angle_in, angle_out;\n\tFT_Int\t\tc, n, first;\n\tFT_Int\t\torientation;\n\n\tif ( !outline )\n\t\treturn FT_Err_Invalid_Argument;\n\n\tstrength /= 2;\n\tif ( strength == 0 )\n\t\treturn FT_Err_Ok;\n\n\torientation = FT_Outline_Get_Orientation( outline );\n\tif ( orientation == FT_ORIENTATION_NONE )\n\t{\n\t\tif ( outline->n_contours )\n\t\t\treturn FT_Err_Invalid_Argument;\n\t\telse\n\t\t\treturn FT_Err_Ok;\n\t}\n\n\tif ( orientation == FT_ORIENTATION_TRUETYPE )\n\t\trotate = -FT_ANGLE_PI2;\n\telse\n\t\trotate = FT_ANGLE_PI2;\n\n\tpoints = outline->points;\n\n\tfirst = 0;\n\tfor ( c = 0; c < outline->n_contours; c++ )\n\t{\n\t\tint  last = outline->contours[c];\n\n\t\tv_first = points[first];\n\t\tv_prev  = points[last];\n\t\tv_cur   = v_first;\n\n\t\tfor ( n = first; n <= last; n++ )\n\t\t{\n\t\t\tFT_Vector\tin, out;\n\t\t\tFT_Angle\tangle_diff;\n\t\t\tFT_Pos\t\td;\n\t\t\tFT_Fixed\tscale;\n\n\t\t\tif ( n < last )\n\t\t\t\tv_next = points[n + 1];\n\t\t\telse\n\t\t\t\tv_next = v_first;\n\n\t\t\t/* compute the in and out vectors */\n\t\t\tin.x = v_cur.x - v_prev.x;\n\t\t\tin.y = v_cur.y - v_prev.y;\n\n\t\t\tout.x = v_next.x - v_cur.x;\n\t\t\tout.y = v_next.y - v_cur.y;\n\n\t\t\tangle_in   = FT_Atan2( in.x, in.y );\n\t\t\tangle_out  = FT_Atan2( out.x, out.y );\n\t\t\tangle_diff = FT_Angle_Diff( angle_in, angle_out );\n\t\t\tscale      = FT_Cos( angle_diff / 2 );\n\n\t\t\tif ( scale < 0x4000L && scale > -0x4000L )\n\t\t\t\tin.x = in.y = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\td = FT_DivFix( strength, scale );\n\n\t\t\t\tFT_Vector_From_Polar( &in, d, angle_in + angle_diff / 2 - rotate );\n\t\t\t}\n\n\t\t\toutline->points[n].x = v_cur.x + strength + in.x;\n\t\t\t//↓これをコメントアウトしただけ\n\t\t\t//outline->points[n].y = v_cur.y + strength + in.y;\n\n\t\t\tv_prev = v_cur;\n\t\t\tv_cur  = v_next;\n\t\t}\n\n\t\tfirst = last + 1;\n\t}\n\n\treturn FT_Err_Ok;\n}\n\n//こっちは縦方向\nFT_Error Vert_FT_Outline_Embolden( FT_Outline*  outline, FT_Pos strength )\n{\n\tFT_Vector*\tpoints;\n\tFT_Vector\tv_prev, v_first, v_next, v_cur;\n\tFT_Angle\trotate, angle_in, angle_out;\n\tFT_Int\t\tc, n, first;\n\tFT_Int\t\torientation;\n\n\tif ( !outline )\n\t\treturn FT_Err_Invalid_Argument;\n\n\tstrength /= 2;\n\tif ( strength == 0 )\n\t\treturn FT_Err_Ok;\n\n\torientation = FT_Outline_Get_Orientation( outline );\n\tif ( orientation == FT_ORIENTATION_NONE )\n\t{\n\t\tif ( outline->n_contours )\n\t\t\treturn FT_Err_Invalid_Argument;\n\t\telse\n\t\t\treturn FT_Err_Ok;\n\t}\n\n\tif ( orientation == FT_ORIENTATION_TRUETYPE )\n\t\trotate = -FT_ANGLE_PI2;\n\telse\n\t\trotate = FT_ANGLE_PI2;\n\n\tpoints = outline->points;\n\n\tfirst = 0;\n\tfor ( c = 0; c < outline->n_contours; c++ )\n\t{\n\t\tint  last = outline->contours[c];\n\n\t\tv_first = points[first];\n\t\tv_prev  = points[last];\n\t\tv_cur   = v_first;\n\n\t\tfor ( n = first; n <= last; n++ )\n\t\t{\n\t\t\tFT_Vector\tin, out;\n\t\t\tFT_Angle\tangle_diff;\n\t\t\tFT_Pos\t\td;\n\t\t\tFT_Fixed\tscale;\n\n\t\t\tif ( n < last )\n\t\t\t\tv_next = points[n + 1];\n\t\t\telse\n\t\t\t\tv_next = v_first;\n\n\t\t\t/* compute the in and out vectors */\n\t\t\tin.x = v_cur.x - v_prev.x;\n\t\t\tin.y = v_cur.y - v_prev.y;\n\n\t\t\tout.x = v_next.x - v_cur.x;\n\t\t\tout.y = v_next.y - v_cur.y;\n\n\t\t\tangle_in   = FT_Atan2( in.x, in.y );\n\t\t\tangle_out  = FT_Atan2( out.x, out.y );\n\t\t\tangle_diff = FT_Angle_Diff( angle_in, angle_out );\n\t\t\tscale      = FT_Cos( angle_diff / 2 );\n\n\t\t\tif ( scale < 0x4000L && scale > -0x4000L )\n\t\t\t\tin.x = in.y = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\td = FT_DivFix( strength, scale );\n\n\t\t\t\tFT_Vector_From_Polar( &in, d, angle_in + angle_diff / 2 - rotate );\n\t\t\t}\n\n\t\t\t//outline->points[n].x = v_cur.x + strength + in.x;\n\t\t\t//↑これをコメントアウトしただけ\n\t\t\toutline->points[n].y = v_cur.y + strength + in.y;\n\n\t\t\tv_prev = v_cur;\n\t\t\tv_cur  = v_next;\n\t\t}\n\n\t\tfirst = last + 1;\n\t}\n\n\treturn FT_Err_Ok;\n}\n\n//ダミー\nFT_EXPORT( FT_Error )\nFT_Library_SetLcdFilter_Dummy( FT_Library    /*library*/,\n                               FT_LcdFilter  /*filter*/ )\n{\n\treturn 0;\n}\n\nBOOL FontLInit(void){\n\tCCriticalSectionLock __lock;\n\n\tif(FT_Init_FreeType(&freetype_library)){\n\t\treturn FALSE;\n\t}\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\n\tif(FTC_Manager_New(freetype_library,\n\t\tpSettings->CacheMaxFaces(),\n\t\tpSettings->CacheMaxSizes(),\n\t\tpSettings->CacheMaxBytes(),\n\t\tface_requester, NULL,\n\t\t&cache_man))\n\t{\n\t\tFontLFree();\n\t\treturn FALSE;\n\t}\n\tif(FTC_CMapCache_New(cache_man, &cmap_cache)){\n\t\tFontLFree();\n\t\treturn FALSE;\n\t}\n\tif(FTC_ImageCache_New(cache_man, &image_cache)){\n\t\tFontLFree();\n\t\treturn FALSE;\n\t}\n\n\tconst int nLcdFilter = pSettings->LcdFilter();\n\tif ((int)FT_LCD_FILTER_NONE < nLcdFilter && nLcdFilter < (int)FT_LCD_FILTER_MAX) {\n\t\tFT_Library_SetLcdFilter(freetype_library, (FT_LcdFilter)nLcdFilter);\n\t\tif (pSettings->UseCustomLcdFilter())\n\t\t{\n\t\t\tunsigned char buff[5];\n\t\t\tmemcpy(buff, pSettings->LcdFilterWeights(), sizeof(buff));\n\t\t\tFT_Library_SetLcdFilterWeights(freetype_library, buff);\n\t\t}\n\t\telse\n\t\t\tswitch (nLcdFilter)\n\t\t\t{\n\t\t\tcase FT_LCD_FILTER_NONE:\n\t\t\tcase FT_LCD_FILTER_DEFAULT:\n\t\t\tcase FT_LCD_FILTER_LEGACY:\n\t\t\t\t{\n\t\t\t\t\tFT_Library_SetLcdFilterWeights(freetype_library,\n\t\t\t\t\t\t(unsigned char*)\"\\x00\\x55\\x56\\x55\\x00\" );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase FT_LCD_FILTER_LIGHT:\n\t\t\tdefault:\n\t\t\t\tFT_Library_SetLcdFilterWeights(freetype_library,\n\t\t\t\t\t(unsigned char*)\"\\x10\\x40\\x70\\x40\\x10\" );\n\t\t\t}\n\t}\n\ts_AlphaBlendTable.init();\n\ts_AlphaBlendTable.initRGB();\n\n\treturn TRUE;\n}\n\nvoid FontLFree(void){\n\tCCriticalSectionLock __lock;\n\n\tif(cache_man != NULL)\n\t\tFTC_Manager_Done(cache_man);\n\tif(freetype_library != NULL)\n\t\tFT_Done_FreeType(freetype_library);\n\tcache_man = NULL;\n\tfreetype_library = NULL;\n}\n\n//Snowie\nvoid RefreshAlphaTable()\n{\n\ts_AlphaBlendTable.init();\n}\n\nvoid UpdateLcdFilter()\n{\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\n\tconst int nLcdFilter = pSettings->LcdFilter();\n\tif ((int)FT_LCD_FILTER_NONE < nLcdFilter && nLcdFilter < (int)FT_LCD_FILTER_MAX) {\n\t\tFT_Library_SetLcdFilter(freetype_library, (FT_LcdFilter)nLcdFilter);\n\t\tif (pSettings->UseCustomLcdFilter())\n\t\t{\n\t\t\tunsigned char buff[5];\n\t\t\tmemcpy(buff, pSettings->LcdFilterWeights(), sizeof(buff));\n\t\t\tFT_Library_SetLcdFilterWeights(freetype_library, buff);\n\t\t}\n/*\n\t\telse\n\t\t\tswitch (nLcdFilter)\n\t\t{\n\t\t\tcase FT_LCD_FILTER_NONE:\n\t\t\tcase FT_LCD_FILTER_DEFAULT:\n\t\t\tcase FT_LCD_FILTER_LEGACY:\n\t\t\t\t{\n\t\t\t\t\tFT_Library_SetLcdFilterWeights(freetype_library,\n\t\t\t\t\t\t(unsigned char*)\"\\x10\\x40\\x70\\x40\\x10\" );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase FT_LCD_FILTER_LIGHT:\n\t\t\tdefault:\n\t\t\t\tFT_Library_SetLcdFilterWeights(freetype_library,\n\t\t\t\t\t(unsigned char*)\"\\x00\\x55\\x56\\x55\\x00\" );\n\t\t}*/\n\n\t}\n}\n"
        },
        {
          "name": "ft.cpp",
          "type": "blob",
          "size": 98.25390625,
          "content": "/* 2006-10-23(by 555)\r\n* http://hp.vector.co.jp/authors/VA028002/winfreetype.c (higambana(菅野友紀))\r\n* を丸写し\r\n*/\r\n/* 2006-10-27(by 555)\r\n* http://hp.vector.co.jp/authors/VA028002/freetype.html (higambana(菅野友紀))\r\n* を参考にしてやり直し\r\n*/\r\n/* 2006-10-29(by 555)\r\n* 693氏(と呼ぶことにする)の精力的な活動によって出来上がったウハウハソースと\r\n* 上記サイトの変更点を元にみみっちい修正。(ベースgdi0164)\r\n*/\r\n/* (by 555)\r\n* さらに線引きもウハウハにしてもらったgdi0168を元に\r\n* イタリックとボールドを追加。\r\n*/\r\n/* (by sy567)\r\n* 太字のアルゴリズムを変更。\r\n* ガンマ補正を実装してみる。\r\n*/\r\n#include \"override.h\"\r\n#include \"ft.h\"\r\n#include <windows.h>\r\n//#include <windowsx.h>\r\n#include <tchar.h>\r\n\r\n#include <math.h>\r\n\r\n#include <ft2build.h>\r\n#include <freetype/tttables.h>\r\n#include <freetype/ftmodapi.h>\r\n#include <freetype/freetype.h>\t/* FT_FREETYPE_H */\r\n#include <freetype/ftcache.h>\t/* FT_CACHE_H */\r\n//#include <tttags.h>\t// FT_TRUETYPE_TAGS_H\r\n//#include <tttables.h>\t// FT_TRUETYPE_TABLES_H\r\n#include <freetype/ftoutln.h>\t// FT_OUTLINE_H\r\n#include <freetype/fttrigon.h>\t//FT_TRIGONOMETRY_H\r\n\r\n#ifdef FT_LCD_FILTER_H\r\n#include <freetype/ftlcdfil.h>\t// FT_LCD_FILTER_H\r\n#endif\r\n\r\n#include \"fteng.h\"\r\n\r\n#include \"ft2vert.h\"\r\n\r\n#include \"colorinvert.h\"\r\n\r\nFT_BitmapGlyphRec empty_glyph = {};//优化控制字\r\n\r\n#define FT_BOLD_LOW 15\r\n#define IsFontBold(lf)\t\t((lf).lfWeight >= FW_BOLD)\r\n#define FT_FixedToInt(x)\t(FT_RoundFix(x) >> 16)\r\n#define FT_PosToInt(x)\t\t(((x) + (1 << 5)) >> 6)\r\n#define RESOLUTION_X 72\r\n#define RESOLUTION_Y 72\r\nFT_Error New_FT_Outline_Embolden(FT_Outline*  outline, FT_Pos str_h, FT_Pos str_v, FT_Int font_size);\r\nFT_Error Old_FT_Outline_Embolden(FT_Outline*  outline, FT_Pos strength);\r\nFT_Error Vert_FT_Outline_Embolden(FT_Outline*  outline, FT_Pos strength);\r\nControlIder CID;\r\n\r\n#if _MSC_VER <= 1200\r\n#pragma warning(disable: 4786)\r\n#endif\r\n\r\n\r\n//更新\r\n#define RGBA(r,g,b,a)          ((COLORREF)(((BYTE)(r)|((WORD)((BYTE)(g))<<8))|(((DWORD)(BYTE)(b))<<16)|(((DWORD)(BYTE)(a))<<24)))\r\n//!!Snowie\r\n\r\nCOLORREF GetPaletteColor(HDC hdc, UINT paletteindex)\r\n{\r\n\t//if ((paletteindex>>28)%2) return 0;\r\n\tHPALETTE hpal = (HPALETTE)GetCurrentObject(hdc, OBJ_PAL);\r\n\tPALETTEENTRY lppe = {};\r\n\tmemset(&lppe, 0, sizeof(lppe));\r\n\tGetPaletteEntries(hpal, paletteindex & 0xffff, 1, &lppe);\r\n\treturn RGB(lppe.peRed, lppe.peGreen, lppe.peBlue);\r\n}\r\n\r\n\r\nvoid Log(char* Msg)\r\n{\r\n#ifndef _DEBUG\r\n\treturn;\r\n#endif\r\n\tFILE* f = fopen(\".\\\\gdipp.log\", \"a\");\r\n\tfputs(Msg, f);\r\n\tfclose(f);\r\n}\r\n\r\nvoid Log(wchar_t* Msg)\r\n{\r\n#ifndef _DEBUG\r\n\treturn;\r\n#endif\r\n\tFILE* f = _wfopen(L\".\\\\gdipp.log\", L\"a,ccs=UNICODE\");\r\n\tfputws(Msg, f);\r\n\tfclose(f);\r\n}\r\n\r\nextern \"C\" FT_Error FT_Glyph_To_BitmapEx(FT_Glyph* the_glyph,\r\n\tFT_Render_Mode  render_mode,\r\n\tFT_Vector* origin,\r\n\tFT_Bool         destroy,\r\n\tFT_Bool\t\t\tloadcolor,\r\n\tFT_UInt\t\t\tglyphindex,\r\n\tFT_Face\t\t\tface);\r\n\r\n\r\nclass CAlphaBlend\r\n{\r\nprivate:\r\n\tstd::vector<int> alphatbl;\r\n\tstd::vector<int> tbl1;\r\n\tstd::vector<BYTE> tbl2;\r\n\t// 通常のアルファ値補正\r\n\tstd::vector<int> tunetbl;\r\n\tstd::vector<int> tunetblR;\r\n\tstd::vector<int> tunetblG;\r\n\tstd::vector<int> tunetblB;\r\n\t// 影文字用のアルファ値補正\r\n\tstd::vector<int> tunetblS;\r\n\tstd::vector<int> tunetblRS;\r\n\tstd::vector<int> tunetblGS;\r\n\tstd::vector<int> tunetblBS;\r\n\r\n\tstd::vector<int> tunetblLS;\r\n\tstd::vector<int> tunetblLRS;\r\n\tstd::vector<int> tunetblLGS;\r\n\tstd::vector<int> tunetblLBS;\r\n\t//Snowie!!\r\n\tstd::vector<double> RGB2CRT;\t//table used for RGB<->Lab\r\npublic:\r\n\tstatic const int BASE;\r\npublic:\r\n\tCAlphaBlend() :\r\n\t\talphatbl(256),\r\n\t\ttbl1(257),\r\n\t\ttbl2(256 * 16 + 1),\r\n\t\ttunetbl(256),\r\n\t\ttunetblR(256),\r\n\t\ttunetblG(256),\r\n\t\ttunetblB(256),\r\n\t\ttunetblS(256),\r\n\t\ttunetblRS(256),\r\n\t\ttunetblGS(256),\r\n\t\ttunetblBS(256),\r\n\t\ttunetblLS(256),\r\n\t\ttunetblLRS(256),\r\n\t\ttunetblLGS(256),\r\n\t\ttunetblLBS(256),\r\n\t\tRGB2CRT(256) {}\r\n\t~CAlphaBlend() {}\r\n\tvoid init();\r\n\tvoid initRGB();\r\n\tdouble* GetRGBTable() { return RGB2CRT.data(); }\r\n\tBYTE doAB(BYTE fg, BYTE bg, int alpha);\r\n\tvoid gettunetbl(int paramalpha, BOOL lcd, BOOL dark, const int * &tblR, const int * &tblG, const int * &tblB) const;\r\n\tinline int conv1(BYTE n) {\r\n\t\treturn tbl1[n];\r\n\t}\r\n\tinline BYTE conv2(int n) {\r\n\t\treturn tbl2[n / (BASE * BASE / (tbl2.size() - 1))];\r\n\t}\r\nprivate:\r\n\tinline int convalpha(int alpha) {\r\n\t\treturn alphatbl[alpha];\r\n\t}\r\n\tinline BYTE rconv1(int n);\r\n};\r\nconst int CAlphaBlend::BASE = 0x4000;\r\n\r\nstatic CAlphaBlend s_AlphaBlendTable;\r\n\r\nvoid CAlphaBlend::gettunetbl(int paramalpha, BOOL lcd, BOOL dark, const int * &tblR, const int * &tblG, const int * &tblB) const\r\n{\r\n\tif (paramalpha == 1) {\t//获取文字混合表\r\n\t\tif (lcd) {\r\n\t\t\ttblR = tunetblR.data();\r\n\t\t\ttblG = tunetblG.data();\r\n\t\t\ttblB = tunetblB.data();\r\n\t\t}\r\n\t\telse {\r\n\t\t\ttblR = tblG = tblB = tunetbl.data();\r\n\t\t}\r\n\t}\r\n\telse {\t//获取阴影混合表\r\n\t\tif (dark)\r\n\t\t{\r\n\t\t\tif (lcd) {\r\n\t\t\t\ttblR = tunetblRS.data();\r\n\t\t\t\ttblG = tunetblGS.data();\r\n\t\t\t\ttblB = tunetblBS.data();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ttblR = tblG = tblB = tunetblS.data();\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (lcd) {\r\n\t\t\t\ttblR = tunetblLRS.data();\r\n\t\t\t\ttblG = tunetblLGS.data();\r\n\t\t\t\ttblB = tunetblLBS.data();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ttblR = tblG = tblB = tunetblLS.data();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CAlphaBlend::initRGB()\r\n{\r\n\tfor (int i = 0; i<256; i++)\r\n\t\tRGB2CRT[i] = pow(i / 255.0, 2.2);\r\n}\r\n\r\nvoid CAlphaBlend::init()\r\n{\r\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\tconst float gamma = pSettings->GammaValue();\r\n\tconst float weight = pSettings->RenderWeight();\r\n\tconst float contrast = pSettings->Contrast();\r\n\tconst int mode = pSettings->GammaMode();\r\n\r\n\tint i;\r\n\tfloat temp, alpha;\r\n\r\n\tfor (i = 0; i < 256; ++i) {\r\n\t\ttemp = pow((1.0f / 255.0f) * i, 1.0f / weight);\r\n\r\n\t\tif (temp < 0.5f) {\r\n\t\t\talpha = pow(temp * 2, contrast) / 2.0f;\r\n\t\t}\r\n\t\telse {\r\n\t\t\talpha = 1.0f - pow((1.0f - temp) * 2, contrast) / 2.0f;\r\n\t\t}\r\n\t\talphatbl[i] = (int)(alpha * BASE);\r\n\r\n\t\tif (mode < 0) {\r\n\t\t\ttemp = (1.0f / 255.0f) * i;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (mode == 1) {\r\n\t\t\t\tif (i <= 10) {\r\n\t\t\t\t\ttemp = (float)i / (12.92f * 255.0f);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\ttemp = pow(((1.0f / 255.0f) * i + 0.055f) / 1.055f, 2.4f);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (mode == 2) {\r\n\t\t\t\tif (i <= 10) {\r\n\t\t\t\t\ttemp = ((float)i / (12.92f * 255.0f) + (float)i / 255.0f) / 2;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\ttemp = (pow(((1.0f / 255.0f) * i + 0.055f) / 1.055f, 2.4f) + (float)i / 255.0f) / 2;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ttemp = pow((1.0f / 255.0f) * i, gamma);\r\n\t\t\t}\r\n\t\t}\r\n\t\ttbl1[i] = (int)(temp * BASE);\r\n\t}\r\n\r\n\ttbl1[i] = BASE;\r\n\r\n\tfor (i = 0; i <= tbl2.size() - 1; ++i) {\r\n\t\ttbl2[i] = rconv1(i * (BASE / (tbl2.size() - 1)));\r\n\t}\r\n\r\n\tconst int* table = pSettings->GetTuneTable();\r\n\tconst int* tableR = pSettings->GetTuneTableR();\r\n\tconst int* tableG = pSettings->GetTuneTableG();\r\n\tconst int* tableB = pSettings->GetTuneTableB();\r\n\tconst int* shadow = pSettings->GetShadowParams();\r\n\tconst int paramalpha = Max(shadow[2], 1);\r\n\tconst int lightparamalpha = Max(shadow[3], 1);\r\n\r\n\tfor (i = 0; i < 256; ++i) {\r\n\t\ttunetbl[i] = Bound(0, alphatbl[Bound(table[i], 0, 255)], CAlphaBlend::BASE);\r\n\t\ttunetblR[i] = Bound(0, alphatbl[Bound(tableR[i], 0, 255)], CAlphaBlend::BASE);\r\n\t\ttunetblG[i] = Bound(0, alphatbl[Bound(tableG[i], 0, 255)], CAlphaBlend::BASE);\r\n\t\ttunetblB[i] = Bound(0, alphatbl[Bound(tableB[i], 0, 255)], CAlphaBlend::BASE);\r\n\t\ttunetblS[i] = Bound(0, alphatbl[Bound(table[i] * paramalpha / 100, 0, 255)], CAlphaBlend::BASE);\r\n\t\ttunetblRS[i] = Bound(0, alphatbl[Bound(tableR[i] * paramalpha / 100, 0, 255)], CAlphaBlend::BASE);\r\n\t\ttunetblGS[i] = Bound(0, alphatbl[Bound(tableG[i] * paramalpha / 100, 0, 255)], CAlphaBlend::BASE);\r\n\t\ttunetblBS[i] = Bound(0, alphatbl[Bound(tableB[i] * paramalpha / 100, 0, 255)], CAlphaBlend::BASE);\t//浅色混合表\r\n\r\n\t\ttunetblLS[i] = Bound(0, alphatbl[Bound(table[i] * lightparamalpha / 100, 0, 255)], CAlphaBlend::BASE);\r\n\t\ttunetblLRS[i] = Bound(0, alphatbl[Bound(tableR[i] * lightparamalpha / 100, 0, 255)], CAlphaBlend::BASE);\r\n\t\ttunetblLGS[i] = Bound(0, alphatbl[Bound(tableG[i] * lightparamalpha / 100, 0, 255)], CAlphaBlend::BASE);\r\n\t\ttunetblLBS[i] = Bound(0, alphatbl[Bound(tableB[i] * lightparamalpha / 100, 0, 255)], CAlphaBlend::BASE);\t//深色混合表\r\n\t}\r\n}\r\n\r\nBYTE CAlphaBlend::rconv1(int n)\r\n{\r\n\tint pos = 0x80;\r\n\tint i = pos >> 1;\r\n\twhile (i > 0) {\r\n\t\tif (n >= tbl1[pos]) {\r\n\t\t\tpos += i;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tpos -= i;\r\n\t\t}\r\n\t\ti >>= 1;\r\n\t}\r\n\tif (n >= tbl1[pos]) {\r\n\t\t++pos;\r\n\t}\r\n\treturn (BYTE)(pos - 1);\r\n}\r\n\r\nclass CAlphaBlendColorOne\r\n{\r\nprivate:\r\n\tBYTE fg;\r\n\tint temp_fg;\r\n\tconst int *tunetbl;\r\n\tBYTE bg0;\r\n\tint alpha0;\r\n\tBYTE c0;\r\npublic:\r\n\tCAlphaBlendColorOne()\r\n\t\t: fg(0), temp_fg(0), tunetbl(NULL), bg0(0), alpha0(0), c0(0) {}\r\n\tvoid init(BYTE f, const int *tbl);\r\n\t~CAlphaBlendColorOne() {};\r\n\tBYTE doAB(BYTE bg, int alpha);\r\n};\r\n\r\nFORCEINLINE void CAlphaBlendColorOne::init(BYTE f, const int *tbl)\r\n{\r\n\tfg = f;\r\n\ttemp_fg = s_AlphaBlendTable.conv1(fg);\r\n\ttunetbl = tbl;\r\n}\r\n\r\nFORCEINLINE BYTE CAlphaBlendColorOne::doAB(BYTE bg, int alpha)\r\n{\r\n\tint temp_alpha = tunetbl[alpha];\r\n\r\n\treturn temp_alpha ? s_AlphaBlendTable.conv2(s_AlphaBlendTable.conv1(bg) * (s_AlphaBlendTable.BASE - tunetbl[alpha]) +\r\n\t\ttemp_fg * tunetbl[alpha]) : bg;\r\n\r\n}\r\n\r\nclass CAlphaBlendColor\r\n{\r\nprivate:\r\n\tCAlphaBlendColorOne r;\r\n\tCAlphaBlendColorOne g;\r\n\tCAlphaBlendColorOne b;\r\npublic:\r\n\tCAlphaBlendColor(COLORREF newColor, int paramalpha, BOOL lcd, BOOL dark, BOOL gbr = false);\r\n\t~CAlphaBlendColor() { }\r\n\tBYTE doABsub(BYTE fg, int temp_fg, BYTE bg, int temp_alpha) const;\r\n\tCOLORREF doAB(COLORREF baseColor, int alphaR, int alphaG, int alphaB, BOOL bClearAlpha);\r\n\tCOLORREF doAB(COLORREF baseColor, int alpha, BOOL bClearAlpha) {\r\n\t\treturn doAB(baseColor, alpha, alpha, alpha, bClearAlpha);\r\n\t}\r\nprivate:\r\n\tCAlphaBlendColor() { }\r\n};\r\n\r\nFORCEINLINE CAlphaBlendColor::CAlphaBlendColor(COLORREF newColor, int paramalpha, BOOL lcd, BOOL dark, BOOL gbr)\r\n{\r\n\tconst int *tblR;\r\n\tconst int *tblG;\r\n\tconst int *tblB;\r\n\ts_AlphaBlendTable.gettunetbl(paramalpha, lcd, dark, tblR, tblG, tblB);\r\n\tif (!gbr) {\r\n\t\tr.init(GetRValue(newColor), tblR);\r\n\t\tb.init(GetBValue(newColor), tblB);\r\n\t}\r\n\telse {\r\n\t\tr.init(GetBValue(newColor), tblB);\r\n\t\tb.init(GetRValue(newColor), tblR);\r\n\t}\r\n\tg.init(GetGValue(newColor), tblG);\r\n}\r\n\r\nFORCEINLINE COLORREF CAlphaBlendColor::doAB(COLORREF baseColor, int alphaR, int alphaG, int alphaB, BOOL bClearAlpha)\r\n{\r\n\tif (alphaB | alphaG | alphaR)\r\n\t{\r\n\t\tif (bClearAlpha)\r\n\t\t\treturn RGB(r.doAB(GetRValue(baseColor), alphaR),\r\n\t\t\t\tg.doAB(GetGValue(baseColor), alphaG),\r\n\t\t\t\tb.doAB(GetBValue(baseColor), alphaB));\r\n\t\telse\r\n\t\t\treturn RGBA(r.doAB(GetRValue(baseColor), alphaR),\r\n\t\t\t\tg.doAB(GetGValue(baseColor), alphaG),\r\n\t\t\t\tb.doAB(GetBValue(baseColor), alphaB),\r\n\t\t\t\tbaseColor >> 24);\r\n\t}\r\n\telse\r\n\t\treturn baseColor;\r\n}\r\n\r\nFORCEINLINE BYTE CAlphaBlend::doAB(BYTE fg, BYTE bg, int alpha)\r\n{\r\n\tif (fg == bg || alpha <= 0) return bg;\r\n\tif (alpha >= 255) return fg;\r\n\tint temp_alpha = convalpha(alpha);\r\n\tint temp_bg = conv1(bg);\r\n\tint temp_fg = conv1(fg);\r\n\tint temp = temp_bg * (BASE - temp_alpha) +\r\n\t\ttemp_fg * temp_alpha;\r\n\treturn conv2(temp);\r\n}\r\n\r\nFORCEINLINE BYTE DoAlphaBlend(BYTE fg, BYTE bg, int alpha)\r\n{\r\n\treturn s_AlphaBlendTable.doAB(fg, bg, alpha);\r\n}\r\n\r\n// LCD(液晶)用のアルファブレンド(サブピクセルレンダリング)\r\nstatic FORCEINLINE\r\nCOLORREF AlphaBlendColorLCD(\r\n\tCOLORREF baseColor,\r\n\tCOLORREF newColor,\r\n\tint alphaR, int alphaG, int alphaB,\r\n\tconst int* tableR, const int* tableG, const int* tableB,\r\n\tconst FreeTypeDrawInfo& ftdi)\r\n{\r\n\tconst BYTE rs = GetRValue(baseColor);\r\n\tconst BYTE gs = GetGValue(baseColor);\r\n\tconst BYTE bs = GetBValue(baseColor);\r\n\tBYTE rd = GetRValue(newColor);\r\n\tBYTE gd = GetGValue(newColor);\r\n\tBYTE bd = GetBValue(newColor);\r\n\t// アルファ値を補正\r\n\talphaR = tableR[alphaR] / ftdi.params->alpha;\r\n\talphaG = tableG[alphaG] / ftdi.params->alpha;\r\n\talphaB = tableB[alphaB] / ftdi.params->alpha;\r\n\t//\trd = (((rd - rs) * alphaR) / 255) + rs;\r\n\t//\tgd = (((gd - gs) * alphaG) / 255) + gs;\r\n\t//\tbd = (((bd - bs) * alphaB) / 255) + bs;\r\n\trd = DoAlphaBlend(rd, rs, alphaR);\r\n\tgd = DoAlphaBlend(gd, gs, alphaG);\r\n\tbd = DoAlphaBlend(bd, bs, alphaB);\r\n\treturn RGB(rd, gd, bd);\r\n}\r\n\r\n// アルファブレンド(256階調)\r\nstatic FORCEINLINE\r\nCOLORREF AlphaBlendColor(\r\n\tCOLORREF baseColor,\r\n\tCOLORREF newColor,\r\n\tint alpha, const int* table,\r\n\tconst FreeTypeDrawInfo& ftdi)\r\n{\r\n\tconst BYTE rs = GetRValue(baseColor);\r\n\tconst BYTE gs = GetGValue(baseColor);\r\n\tconst BYTE bs = GetBValue(baseColor);\r\n\tBYTE rd = GetRValue(newColor);\r\n\tBYTE gd = GetGValue(newColor);\r\n\tBYTE bd = GetBValue(newColor);\r\n\t// アルファ値を補正\r\n\talpha = table[alpha] / ftdi.params->alpha;\r\n\t//\trd = (rs * (255 - alpha) + rd * alpha) / 255;\r\n\t//\tgd = (gs * (255 - alpha) + gd * alpha) / 255;\r\n\t//\tbd = (bs * (255 - alpha) + bd * alpha) / 255;\r\n\r\n\t//\trd = (((rd - rs) * alpha) / 255) + rs;\r\n\t//\tgd = (((gd - gs) * alpha) / 255) + gs;\r\n\t//\tbd = (((bd - bs) * alpha) / 255) + bs;\r\n\trd = DoAlphaBlend(rd, rs, alpha);\r\n\tgd = DoAlphaBlend(gd, gs, alpha);\r\n\tbd = DoAlphaBlend(bd, bs, alpha);\r\n\treturn RGB(rd, gd, bd);\r\n}\r\n\r\ntypedef struct\r\n{\r\n\tFreeTypeDrawInfo* FTInfo;\t\t\t//orignal draw information\r\n\tWCHAR wch;\t\t\t\t\t\t\t//text to draw\r\n\tFT_BitmapGlyph FTGlyph;\t\t\t//glyph\r\n\tint\tAAMode;\t\t\t\t\t\t\t//antialiased mode for every char\r\n\tCAlphaBlendColor* solid;\r\n\tCAlphaBlendColor* shadow;\t//alpha blender\r\n\tbool bInvertColor;\t// invert color for chrome/skia\r\n} FreeTypeGlyphInfo, *PFreeTypeGlyphInfo;\r\n\r\n\r\n// 2階調\r\nstatic void FreeTypeDrawBitmapPixelModeMono(FreeTypeGlyphInfo& FTGInfo,\r\n\tCAlphaBlendColor& ab, int x, int y)\r\n{\r\n\tCBitmapCache& cache = *FTGInfo.FTInfo->pCache;\r\n\tconst FT_Bitmap *bitmap = &FTGInfo.FTGlyph->bitmap;\r\n\tBYTE alphatuner = FTGInfo.FTInfo->params->alphatuner;\r\n\tint i, j;\r\n\tint dx, dy;\t// display\r\n\tFT_Bytes p;\r\n\r\n\tif (bitmap->pixel_mode != FT_PIXEL_MODE_MONO) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst COLORREF color = RGB2DIB(FTGInfo.FTInfo->Color());\r\n\r\n\tconst SIZE cachebufsize = cache.Size();\r\n\tDWORD * const cachebufp = (DWORD *)cache.GetPixels();\r\n\tDWORD * cachebufrowp;\r\n\r\n\tint left, top, width, height;\r\n\tif (x < 0) {\r\n\t\tleft = -x;\r\n\t\tx = 0;\r\n\t}\r\n\telse {\r\n\t\tleft = 0;\r\n\t}\r\n\twidth = Min((int)bitmap->width, (int)(cachebufsize.cx - x));\r\n\ttop = 0;\r\n\theight = bitmap->rows;\r\n\r\n\tfor (j = top, dy = y; j < height; ++j, ++dy) {\r\n\t\tif ((unsigned int)dy >= (unsigned int)cachebufsize.cy) continue;\r\n\t\tp = bitmap->pitch < 0 ?\r\n\t\t\t&bitmap->buffer[(-bitmap->pitch * bitmap->rows) - bitmap->pitch * j] :\t// up-flow\r\n\t\t\t&bitmap->buffer[bitmap->pitch * j];\t// down-flow\r\n\t\tcachebufrowp = &cachebufp[dy * cachebufsize.cx];\r\n\t\tfor (i = left, dx = x; i < width; ++i, ++dx) {\r\n\t\t\tif ((p[i / 8] & (1 << (7 - (i % 8)))) != 0) {\r\n\t\t\t\tcachebufrowp[dx] = color;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// LCD(液晶)用描画(サブピクセルレンダリング)\r\n// RGB順(のはず)\r\nstatic void FreeTypeDrawBitmapPixelModeLCD(FreeTypeGlyphInfo& FTGInfo,\r\n\tCAlphaBlendColor& ab, int x, int y)\r\n{\r\n\tCBitmapCache& cache = *FTGInfo.FTInfo->pCache;\r\n\tconst FT_Bitmap *bitmap = &FTGInfo.FTGlyph->bitmap;\r\n\tBYTE alphatuner = FTGInfo.FTInfo->params->alphatuner;\r\n\tint AAMode = FTGInfo.AAMode;\r\n\tint i, j;\r\n\tint dx, dy;\t// display\r\n\tFT_Bytes p;\r\n\r\n\tif (bitmap->pixel_mode != FT_PIXEL_MODE_LCD) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst COLORREF color = FTGInfo.FTInfo->Color();\r\n\r\n\tconst SIZE cachebufsize = cache.Size();\r\n\tDWORD * const cachebufp = (DWORD *)cache.GetPixels();\r\n\tDWORD * cachebufrowp;\r\n\r\n\t// LCDは3サブピクセル分ある\r\n\tint left, top, width, height;\r\n\tif (x < 0) {\r\n\t\tleft = -x * 3;\r\n\t\tx = 0;\r\n\t}\r\n\telse {\r\n\t\tleft = 0;\r\n\t}\r\n\twidth = Min((int)bitmap->width, (int)(cachebufsize.cx - x) * 3);\r\n\ttop = 0;\r\n\theight = bitmap->rows;\r\n\t//CAlphaBlendColor ab(color, ftdi.params->alpha, true, true);\r\n\r\n\tCOLORREF backColor, newColor;\r\n\tunsigned int alphaR, alphaG, alphaB;\r\n\tBOOL bAlphaDraw = FTGInfo.FTInfo->params->alpha != 1;\r\n\r\n\tif (bAlphaDraw)\r\n\t\tfor (j = 0, dy = y; j < height; ++j, ++dy) {\r\n\t\t\tif ((unsigned int)dy >= (unsigned int)cachebufsize.cy) continue;\r\n\r\n\t\t\tp = bitmap->pitch < 0 ?\r\n\t\t\t\t&bitmap->buffer[(-bitmap->pitch * bitmap->rows) - bitmap->pitch * j] :\t// up-flow\r\n\t\t\t\t&bitmap->buffer[bitmap->pitch * j];\t// down-flow\r\n\r\n\t\t\tcachebufrowp = &cachebufp[dy * cachebufsize.cx];\r\n\t\t\tfor (i = left, dx = x; i < width; i += 3, ++dx) {\r\n\t\t\t\tbackColor = cachebufrowp[dx];\r\n\t\t\t\tCOLORREF last = 0xFFFFFFFF;\r\n\t\t\t\tif (AAMode == 2 || AAMode == 4) {\r\n\t\t\t\t\t// This is for displays with subpixels in RGB order\r\n\t\t\t\t\talphaR = p[i + 0] / alphatuner;\r\n\t\t\t\t\talphaG = p[i + 1] / alphatuner;\r\n\t\t\t\t\talphaB = p[i + 2] / alphatuner;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// BGR\r\n\t\t\t\t\talphaR = p[i + 2] / alphatuner;\r\n\t\t\t\t\talphaG = p[i + 1] / alphatuner;\r\n\t\t\t\t\talphaB = p[i + 0] / alphatuner;\r\n\t\t\t\t}\r\n\t\t\t\t/*\r\n\t\t\t\tif (bAlphaDraw)\r\n\t\t\t\t{\r\n\t\t\t\tif (alphaB && alphaG && alphaR)\r\n\t\t\t\tbackColor &= 0x00ffffff;\r\n\t\t\t\t}\r\n\t\t\t\telse*/\r\n\r\n\t\t\t\t//if ((alphaB || alphaG || alphaR))\r\n\t\t\t\t//\tbackColor &= 0x00ffffff;\r\n\t\t\t\tnewColor = ab.doAB(backColor, alphaB, alphaG, alphaR, !bAlphaDraw);\r\n\t\t\t\tcachebufrowp[dx] = newColor;\r\n\t\t\t}\r\n\t\t}\r\n\telse\r\n\t\tfor (j = 0, dy = y; j < height; ++j, ++dy) {\r\n\t\t\tif ((unsigned int)dy >= (unsigned int)cachebufsize.cy) continue;\r\n\r\n\t\t\tp = bitmap->pitch < 0 ?\r\n\t\t\t\t&bitmap->buffer[(-bitmap->pitch * bitmap->rows) - bitmap->pitch * j] :\t// up-flow\r\n\t\t\t\t&bitmap->buffer[bitmap->pitch * j];\t// down-flow\r\n\r\n\t\t\tcachebufrowp = &cachebufp[dy * cachebufsize.cx];\r\n\t\t\tfor (i = left, dx = x; i < width; i += 3, ++dx) {\r\n\t\t\t\tbackColor = cachebufrowp[dx];\r\n\t\t\t\tCOLORREF last = 0xFFFFFFFF;\r\n\t\t\t\tif (AAMode == 2 || AAMode == 4) {\r\n\t\t\t\t\t// これはRGBの順にサブピクセルがあるディスプレイ用\r\n\t\t\t\t\t// これはRGBの順にサブピクセルがあるディスプレイ用\r\n\t\t\t\t\talphaR = p[i + 0];\r\n\t\t\t\t\talphaG = p[i + 1];\r\n\t\t\t\t\talphaB = p[i + 2];\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// BGR\r\n\t\t\t\t\talphaR = p[i + 2];\r\n\t\t\t\t\talphaG = p[i + 1];\r\n\t\t\t\t\talphaB = p[i + 0];\r\n\t\t\t\t}\r\n\t\t\t\t/*\r\n\t\t\t\tif (bAlphaDraw)\r\n\t\t\t\t{\r\n\t\t\t\tif (alphaB && alphaG && alphaR)\r\n\t\t\t\tbackColor &= 0x00ffffff;\r\n\t\t\t\t}\r\n\t\t\t\telse*/\r\n\r\n\t\t\t\t//if ((alphaB || alphaG || alphaR))\r\n\t\t\t\t//\tbackColor &= 0x00ffffff;\r\n\t\t\t\tnewColor = ab.doAB(backColor, alphaB, alphaG, alphaR, !bAlphaDraw);\r\n\t\t\t\tcachebufrowp[dx] = newColor;\r\n\t\t\t}\r\n\t\t}\r\n}\r\n\r\nCOLORREF _rgbamixer(COLORREF bkColor, int b, int g, int r, int a) {\r\n\tint bkr = GetRValue(bkColor), bkg = GetGValue(bkColor), bkb = GetBValue(bkColor);\r\n\treturn a << 24 | (bkb - a*bkb / 255 + b) << 16 | (bkg - a*bkg / 255 + g) << 8 | (bkr - a*bkr / 255 + r);\r\n}\r\n\r\n// color blender for color font\r\nCOLORREF _invert_rgbamixer(COLORREF bkColor, int b, int g, int r, int a) {\r\n\tif (!a)\r\n\t\treturn bkColor;\r\n\tint invertr, invertg, invertb;\r\n\tif (a == 255) {\r\n\t\tinvertr = InvertTable[r];\r\n\t\tinvertg = InvertTable[g];\r\n\t\tinvertb = InvertTable[b];\r\n\t}\r\n\telse {\r\n\t\tinvertr = InvertTable[r * 255 / a] * a / 255;\r\n\t\tinvertg = InvertTable[g * 255 / a] * a / 255;\r\n\t\tinvertb = InvertTable[b * 255 / a] * a / 255;\r\n\t}\r\n\treturn _rgbamixer(bkColor, invertb, invertg, invertr, a);\r\n}\r\n\r\n// draw color emoji\r\nstatic void FreeTypeDrawBitmapPixelModeBGRA(FreeTypeGlyphInfo& FTGInfo, int x, int y)\r\n{\r\n\tCBitmapCache& cache = *FTGInfo.FTInfo->pCache;\r\n\tconst FT_Bitmap *bitmap = &FTGInfo.FTGlyph->bitmap;\r\n\tBYTE alphatuner = FTGInfo.FTInfo->params->alphatuner;\r\n\tBOOL bAlphaDraw = FTGInfo.FTInfo->params->alpha != 1;\r\n\tint AAMode = FTGInfo.AAMode;\r\n\tint i, j;\r\n\tint dx, dy;\t// display\r\n\tFT_Bytes p;\r\n\r\n\tif (bAlphaDraw) {\t// no shadow for color font\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (bitmap->pixel_mode != FT_PIXEL_MODE_BGRA) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst COLORREF color = FTGInfo.FTInfo->Color();\r\n\r\n\tconst SIZE cachebufsize = cache.Size();\r\n\tDWORD * const cachebufp = (DWORD *)cache.GetPixels();\r\n\tDWORD * cachebufrowp;\r\n\ttypedef COLORREF(*pfnmixer) (COLORREF bkColor, int b, int g, int r, int a);\r\n\r\n\tpfnmixer mixer = FTGInfo.bInvertColor ? _invert_rgbamixer : _rgbamixer;\r\n\r\n\tint left, top, width, height;\r\n\tif (x < 0) {\r\n\t\tleft = -x * 4;\r\n\t\tx = 0;\r\n\t}\r\n\telse {\r\n\t\tleft = 0;\r\n\t}\r\n\twidth = Min((int)bitmap->width * 4, (int)(cachebufsize.cx - x) * 4);\r\n\ttop = 0;\r\n\theight = bitmap->rows;\r\n\r\n\tCOLORREF backColor, newColor;\r\n\tunsigned int alphaR, alphaG, alphaB, alpha;\r\n\r\n\tfor (j = 0, dy = y; j < height; ++j, ++dy) {\r\n\t\tif ((unsigned int)dy >= (unsigned int)cachebufsize.cy) continue;\r\n\r\n\t\tp = bitmap->pitch < 0 ?\r\n\t\t\t&bitmap->buffer[(-bitmap->pitch * bitmap->rows) - bitmap->pitch * j] :\t// up-flow\r\n\t\t\t&bitmap->buffer[bitmap->pitch * j];\t// down-flow\r\n\r\n\t\tcachebufrowp = &cachebufp[dy * cachebufsize.cx];\r\n\t\tfor (i = left, dx = x; i < width; i += 4, ++dx) {\r\n\t\t\tbackColor = cachebufrowp[dx];\r\n\t\t\tCOLORREF last = 0xFFFFFFFF;\r\n\t\t\t// always RGB\r\n\t\t\talphaR = p[i + 0];\r\n\t\t\talphaG = p[i + 1];\r\n\t\t\talphaB = p[i + 2];\r\n\t\t\talpha = p[i + 3];\r\n\t\t\tnewColor = mixer(backColor, alphaB, alphaG, alphaR, alpha);\r\n\t\t\tcachebufrowp[dx] = newColor;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic void FreeTypeDrawBitmapGray(FreeTypeGlyphInfo& FTGInfo, CAlphaBlendColor& ab, int x, int y)\r\n{\r\n\tint i, j;\r\n\tint dx, dy;\t// display\r\n\tCOLORREF c;\r\n\tFT_Bytes p;\r\n\r\n\tCBitmapCache& cache = *FTGInfo.FTInfo->pCache;\r\n\tconst FT_Bitmap *bitmap = &FTGInfo.FTGlyph->bitmap;\r\n\tBYTE alphatuner = FTGInfo.FTInfo->params->alphatuner;\r\n\r\n\tBOOL bAlphaDraw = FTGInfo.FTInfo->params->alpha != 1;\r\n\tconst COLORREF color = FTGInfo.FTInfo->Color();\r\n\tconst SIZE cachebufsize = cache.Size();\r\n\tDWORD * const cachebufp = (DWORD *)cache.GetPixels();\r\n\tDWORD * cachebufrowp;\r\n\r\n\tint left, top, width, height;\r\n\tif (x < 0) {\r\n\t\tleft = -x;\r\n\t\tx = 0;\r\n\t}\r\n\telse {\r\n\t\tleft = 0;\r\n\t}\r\n\twidth = Min((int)bitmap->width, (int)(cachebufsize.cx - x));\r\n\ttop = 0;\r\n\theight = bitmap->rows;\r\n\r\n\t//\tCAlphaBlendColor ab(color, ftdi.params->alpha, false, true);\r\n\r\n\tCOLORREF backColor;\r\n\tint alpha;\r\n\r\n\tfor (j = top, dy = y; j < height; ++j, ++dy) {\r\n\t\tif ((unsigned int)dy >= (unsigned int)cachebufsize.cy) continue;\r\n\t\tp = bitmap->pitch < 0 ?\r\n\t\t\t&bitmap->buffer[(-bitmap->pitch * bitmap->rows) - bitmap->pitch * j] :\t// up-flow\r\n\t\t\t&bitmap->buffer[bitmap->pitch * j];\t// down-flow\r\n\t\tcachebufrowp = &cachebufp[dy * cachebufsize.cx];\r\n\t\tfor (i = left, dx = x; i < width; ++i, ++dx) {\r\n\t\t\talpha = p[i];\r\n\t\t\tbackColor = cachebufrowp[dx];\r\n\t\t\tc = ab.doAB(backColor, alpha, !bAlphaDraw);\r\n\t\t\tcachebufrowp[dx] = c;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// グリフビットマップのレンダリング\r\nstatic bool FreeTypeDrawBitmap(\r\n\tFreeTypeGlyphInfo& FTGInfo,\r\n\tCAlphaBlendColor& ab,\r\n\tint x, int y)\r\n{\r\n\tif (FTGInfo.FTGlyph->bitmap.pixel_mode != FT_PIXEL_MODE_GRAY) {\r\n\t\t// この関数自体はFT_PIXEL_MODE_GRAYにのみ対応し他に委譲する\r\n\t\tswitch (FTGInfo.FTGlyph->bitmap.pixel_mode) {\r\n\t\tcase FT_PIXEL_MODE_MONO:\r\n\t\t\tFreeTypeDrawBitmapPixelModeMono(FTGInfo, ab, x, y);\r\n\t\t\tbreak;\r\n\t\tcase FT_PIXEL_MODE_LCD:\r\n\t\t\tFreeTypeDrawBitmapPixelModeLCD(FTGInfo, ab, x, y);\r\n\t\t\tbreak;\r\n\t\tcase FT_PIXEL_MODE_BGRA:\r\n\t\t\tFreeTypeDrawBitmapPixelModeBGRA(FTGInfo, x, y);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\treturn false;\t\t// 未対応\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\tFreeTypeDrawBitmapGray(FTGInfo, ab, x, y);\r\n\treturn true;\r\n}\r\n\r\n// 縦書き用のレンダリング(コピペ手抜き)\r\n// 2階調\r\nstatic void FreeTypeDrawBitmapPixelModeMonoV(FreeTypeGlyphInfo& FTGInfo,\r\n\tCAlphaBlendColor& ab, int x, int y)\r\n{\r\n\tCBitmapCache& cache = *FTGInfo.FTInfo->pCache;\r\n\tFT_Bitmap *bitmap = &FTGInfo.FTGlyph->bitmap;\r\n\tint i, j;\r\n\tint dx, dy;\t// display\r\n\tFT_Bytes p;\r\n\r\n\tif (bitmap->pixel_mode != FT_PIXEL_MODE_MONO) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst COLORREF color = FTGInfo.FTInfo->Color();\r\n\r\n\tconst int width = bitmap->width;\r\n\tconst int height = bitmap->rows;\r\n\r\n\tfor (j = 0, dy = x; j < height; ++j, ++dy) {\r\n\t\tp = bitmap->pitch < 0 ?\r\n\t\t\t&bitmap->buffer[(-bitmap->pitch * bitmap->rows) - bitmap->pitch * j] :\t// up-flow\r\n\t\t\t&bitmap->buffer[bitmap->pitch * j];\t// down-flow\r\n\t\tfor (i = 0, dx = y + width; i < width; ++i, --dx) {\r\n\t\t\tif ((p[i / 8] & (1 << (7 - (i % 8)))) != 0) {\r\n\t\t\t\tif (cache.GetPixel(dx, dy) != CLR_INVALID) { // dx dy エラーチェック\r\n\t\t\t\t\tcache.SetCurrentPixel(color);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// LCD(液晶)用描画(サブピクセルレンダリング)\r\n// RGB順(のはず)\r\nstatic void FreeTypeDrawBitmapPixelModeLCDV(FreeTypeGlyphInfo& FTGInfo,\r\n\tCAlphaBlendColor& ab, int x, int y)\r\n{\r\n\tCBitmapCache& cache = *FTGInfo.FTInfo->pCache;\r\n\tconst FT_Bitmap *bitmap = &FTGInfo.FTGlyph->bitmap;\r\n\tBYTE alphatuner = FTGInfo.FTInfo->params->alphatuner;\r\n\tint AAMode = FTGInfo.AAMode;\r\n\tint i, j;\r\n\tint dx, dy;\t// display\r\n\tCOLORREF c;\r\n\tFT_Bytes p;\r\n\r\n\tif (bitmap->pixel_mode != FT_PIXEL_MODE_LCD_V) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst COLORREF color = FTGInfo.FTInfo->Color();\r\n\r\n\t// LCDは3サブピクセル分ある\r\n\tconst int width = bitmap->width;\r\n\tconst int height = bitmap->rows;\r\n\tconst int pitch = bitmap->pitch;\r\n\tconst int pitchabs = pitch < 0 ? -pitch : pitch;\r\n\tBOOL bAlphaDraw = FTGInfo.FTInfo->params->alpha != 1;\r\n\t//CAlphaBlendColor ab(color, ftdi.params->alpha, true);\r\n\r\n\tif (bAlphaDraw)\r\n\t\tfor (j = 0, dy = x; j < height; j += 3, ++dy) {\r\n\t\t\tp = pitch < 0 ?\r\n\t\t\t\t&bitmap->buffer[(pitchabs * bitmap->rows) + pitchabs * j] :\t// up-flow\r\n\t\t\t\t&bitmap->buffer[pitchabs * j];\t// down-flow\r\n\r\n\t\t\tint alphaR, alphaG, alphaB;\r\n\t\t\tfor (i = 0, dx = y + width; i < width; ++i, --dx) {\r\n\t\t\t\tCOLORREF backColor = cache.GetPixel(dy, dx);\r\n\r\n\t\t\t\tif (backColor == color || backColor == CLR_INVALID) continue;\r\n\t\t\t\tif (AAMode == 2 || AAMode == 4) {\r\n\t\t\t\t\t// これはRGBの順にサブピクセルがあるディスプレイ用\r\n\t\t\t\t\talphaR = p[i + 0] / alphatuner;\r\n\t\t\t\t\talphaG = p[i + pitch] / alphatuner;\r\n\t\t\t\t\talphaB = p[i + pitch * 2] / alphatuner;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// BGR\r\n\t\t\t\t\talphaR = p[i + pitch * 2] / alphatuner;\r\n\t\t\t\t\talphaG = p[i + pitch] / alphatuner;\r\n\t\t\t\t\talphaB = p[i + 0] / alphatuner;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tc = ab.doAB(backColor, alphaR, alphaG, alphaB, !bAlphaDraw);\r\n\t\t\t\tcache.SetCurrentPixel(c);\r\n\t\t\t}\r\n\r\n\t\t\tif (i >= width)\r\n\t\t\t\tcontinue;\r\n\t\t}\r\n\telse\r\n\t\tfor (j = 0, dy = x; j < height; j += 3, ++dy) {\r\n\t\t\tp = pitch < 0 ?\r\n\t\t\t\t&bitmap->buffer[(pitchabs * bitmap->rows) + pitchabs * j] :\t// up-flow\r\n\t\t\t\t&bitmap->buffer[pitchabs * j];\t// down-flow\r\n\r\n\t\t\tint alphaR, alphaG, alphaB;\r\n\t\t\tfor (i = 0, dx = y + width; i < width; ++i, --dx) {\r\n\t\t\t\tCOLORREF backColor = cache.GetPixel(dy, dx);\r\n\r\n\t\t\t\tif (backColor == color || backColor == CLR_INVALID) continue;\r\n\t\t\t\tif (AAMode == 2 || AAMode == 4) {\r\n\t\t\t\t\t// これはRGBの順にサブピクセルがあるディスプレイ用\r\n\t\t\t\t\talphaR = p[i + 0];\r\n\t\t\t\t\talphaG = p[i + pitch];\r\n\t\t\t\t\talphaB = p[i + pitch * 2];\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// BGR\r\n\t\t\t\t\talphaR = p[i + pitch * 2];\r\n\t\t\t\t\talphaG = p[i + pitch];\r\n\t\t\t\t\talphaB = p[i + 0];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tc = ab.doAB(backColor, alphaR, alphaG, alphaB, !bAlphaDraw);\r\n\t\t\t\tcache.SetCurrentPixel(c);\r\n\t\t\t}\r\n\r\n\t\t\tif (i >= width)\r\n\t\t\t\tcontinue;\r\n\t\t}\r\n}\r\n\r\nvoid FreeTypeDrawBitmapGrayV(FreeTypeGlyphInfo& FTGInfo, CAlphaBlendColor& ab, int x, int y)\r\n{\r\n\tCBitmapCache& cache = *FTGInfo.FTInfo->pCache;\r\n\tconst FT_Bitmap *bitmap = &FTGInfo.FTGlyph->bitmap;\r\n\tBYTE alphatuner = FTGInfo.FTInfo->params->alphatuner;\r\n\tint i, j;\r\n\tint dx, dy;\t// display\r\n\tint width, height;\r\n\tCOLORREF c;\r\n\tFT_Bytes p;\r\n\r\n\r\n\tconst COLORREF color = FTGInfo.FTInfo->Color();\r\n\t//const CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\t//const int* table = pSettings->GetTuneTable();\r\n\twidth = bitmap->width;\r\n\theight = bitmap->rows;\r\n\r\n\t//\tCAlphaBlendColor ab(color, ftdi.params->alpha, false);\r\n\r\n\tfor (j = 0, dy = x; j < height; ++j, ++dy) {\r\n\t\tp = bitmap->pitch < 0 ?\r\n\t\t\t&bitmap->buffer[(-bitmap->pitch * bitmap->rows) - bitmap->pitch * j] :\t// up-flow\r\n\t\t\t&bitmap->buffer[bitmap->pitch * j];\t// down-flow\r\n\t\tfor (i = 0, dx = y + width; i < width; ++i, --dx) {\r\n\t\t\tconst COLORREF backColor = cache.GetPixel(dy, dx);\r\n\t\t\tif (backColor == color || backColor == CLR_INVALID) continue;\r\n\t\t\tc = ab.doAB(backColor, p[i], true);\r\n\t\t\tcache.SetPixelV(dy, dx, c);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic bool FreeTypeDrawBitmapV(FreeTypeGlyphInfo& FTGInfo, CAlphaBlendColor& ab, const int x, const int y)\r\n{\r\n\tif (FTGInfo.FTGlyph->bitmap.pixel_mode != FT_PIXEL_MODE_GRAY) {\r\n\t\t// この関数自体はFT_PIXEL_MODE_GRAYにのみ対応し他に委譲する\r\n\t\tswitch (FTGInfo.FTGlyph->bitmap.pixel_mode) {\r\n\t\tcase FT_PIXEL_MODE_MONO:\r\n\t\t\tFreeTypeDrawBitmapPixelModeMonoV(FTGInfo, ab, x, y);\r\n\t\t\tbreak;\r\n\t\tcase FT_PIXEL_MODE_LCD_V:\r\n\t\t\tFreeTypeDrawBitmapPixelModeLCDV(FTGInfo, ab, x, y);\r\n\t\t\tbreak;\r\n\t\tcase FT_PIXEL_MODE_BGRA:\r\n\t\t\tFreeTypeDrawBitmapPixelModeBGRA(FTGInfo, x, y);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\treturn false;\t\t// 未対応\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\tFreeTypeDrawBitmapGrayV(FTGInfo, ab, x, y);\r\n\treturn true;\r\n}\r\n\r\nclass CGGOGlyphLoader\r\n{\r\nprivate:\r\n\tFT_Library m_lib;\r\n\tconst FT_Glyph_Class *m_clazz;\r\n\tBYTE bgtbl[0x41];\r\n\tstatic int CALLBACK EnumFontFamProc(const LOGFONT* lplf, const TEXTMETRIC* lptm, DWORD FontType, LPARAM lParam);\r\npublic:\r\n\tCGGOGlyphLoader() : m_lib(NULL), m_clazz(NULL) {}\r\n\t~CGGOGlyphLoader() {}\r\n\tbool init(FT_Library freetype_library);\r\n\tFT_Library getlib() { return m_lib; }\r\n\tconst FT_Glyph_Class * getclazz() { return m_clazz; }\r\n\tBYTE convbgpixel(BYTE val) { return bgtbl[val]; }\r\n};\r\nstatic CGGOGlyphLoader s_GGOGlyphLoader;\r\n\r\nint CALLBACK CGGOGlyphLoader::EnumFontFamProc(const LOGFONT* lplf, const TEXTMETRIC* lptm, DWORD FontType, LPARAM lParam)\r\n{\r\n\tCGGOGlyphLoader* pThis = reinterpret_cast<CGGOGlyphLoader*>(lParam);\r\n\tif (FontType != TRUETYPE_FONTTYPE || lplf->lfCharSet == SYMBOL_CHARSET) {\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n\tTRACE(_T(\"Face: %s\\n\"), lplf->lfFaceName);\r\n\tFreeTypeSysFontData* pFont = FreeTypeSysFontData::CreateInstance(lplf->lfFaceName, 0, false);\r\n\tif (!pFont) {\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n\tconst FT_Glyph_Class *clazz = NULL;\r\n\tFT_Face face = pFont->GetFace();\r\n\tFT_Error err = FT_Set_Pixel_Sizes(face, 0, 12);//optimized\r\n\tif (!err) {\r\n\t\terr = FT_Load_Char(face, lptm->tmDefaultChar, FT_LOAD_NO_BITMAP);\r\n\t\tif (!err) {\r\n\t\t\tFT_Glyph glyph;\r\n\t\t\terr = FT_Get_Glyph(face->glyph, &glyph);\r\n\t\t\tif (!err) {\r\n\t\t\t\tif (glyph->format == FT_GLYPH_FORMAT_OUTLINE) {\r\n\t\t\t\t\tclazz = glyph->clazz;\r\n\t\t\t\t}\r\n\t\t\t\tFT_Done_Glyph(glyph);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tFT_Done_Face(face);\r\n\r\n\tif (clazz) {\r\n\t\tpThis->m_clazz = clazz;\r\n\t\t//列挙中止\r\n\t\treturn FALSE;\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nbool\r\nCGGOGlyphLoader::init(FT_Library freetype_library)\r\n{\r\n\tif (m_lib) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\tif (!freetype_library) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfor (BYTE val = 0; val <= 0x40; ++val) {\r\n\t\tBYTE t = (BYTE)(((DWORD)val * 256) / 65);\r\n\t\tbgtbl[val] = t + (t >> 6);\r\n\t}\r\n\r\n\tm_lib = freetype_library;\r\n\tm_clazz = NULL;\r\n\r\n\t//前の方法だと、arial.ttfが無いとまずそうなので\r\n\t//適当に使えるアウトラインフォントを探す\r\n\tHDC hdc = CreateCompatibleDC(NULL);\r\n\tEnumFontFamilies(hdc, NULL, EnumFontFamProc, reinterpret_cast<LPARAM>(this));\r\n\tDeleteDC(hdc);\r\n\r\n\tif (m_clazz != NULL) {\r\n\t\treturn true;\r\n\t}\r\n\tm_lib = NULL;\r\n\treturn false;\r\n}\r\n\r\nclass CGGOOutlineGlyph\r\n{\r\nprivate:\r\n\tFT_OutlineGlyph m_ptr;\r\n\tstatic FT_F26Dot6 toF26Dot6(const FIXED& fx) {\r\n\t\treturn *(LONG *)(&fx) >> 10;\r\n\t}\r\n\tstatic FT_Fixed toFixed(const short n) {\r\n\t\treturn (FT_Fixed)n << 16;\r\n\t}\r\n\tstatic char getTag(char tag, const FT_Vector& point) {\r\n\t\tif ((point.x & 0x0f) != 0) {\r\n\t\t\ttag |= FT_CURVE_TAG_TOUCH_X;\r\n\t\t}\r\n\t\tif ((point.y & 0x0f) != 0) {\r\n\t\t\ttag |= FT_CURVE_TAG_TOUCH_Y;\r\n\t\t}\r\n\t\treturn tag;\r\n\t}\r\npublic:\r\n\tCGGOOutlineGlyph() : m_ptr(NULL) { _ASSERTE(s_GGOGlyphLoader.getlib()); }\r\n\t~CGGOOutlineGlyph() { done(); };\r\n\tbool init(DWORD bufsize, PVOID bufp, const GLYPHMETRICS& gm);\r\n\tvoid done();\r\n\toperator FT_Glyph () { return (FT_Glyph)m_ptr; }\r\n};\r\n\r\nvoid\r\nCGGOOutlineGlyph::done()\r\n{\r\n\tif (m_ptr) {\r\n\t\tfree(m_ptr->outline.points);\r\n\t\tfree(m_ptr->outline.tags);\r\n\t\tfree(m_ptr->outline.contours);\r\n\t}\r\n\tfree(m_ptr);\r\n\tm_ptr = NULL;\r\n}\r\n\r\nbool\r\nCGGOOutlineGlyph::init(DWORD bufsize, PVOID bufp, const GLYPHMETRICS& gm)\r\n{\r\n\tdone();\r\n\tm_ptr = (FT_OutlineGlyph)calloc(1, sizeof *m_ptr);\r\n\tif (!m_ptr) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tFT_GlyphRec& root = m_ptr->root;\r\n\tFT_Outline& outline = m_ptr->outline;\r\n\r\n\troot.library = s_GGOGlyphLoader.getlib();\r\n\troot.clazz = s_GGOGlyphLoader.getclazz();\r\n\troot.format = FT_GLYPH_FORMAT_OUTLINE;\r\n\troot.advance.x = toFixed(gm.gmCellIncX);\r\n\troot.advance.y = toFixed(gm.gmCellIncY);\r\n\r\n\toutline.n_contours = 0;\r\n\toutline.n_points = 0;\r\n\toutline.flags = 0; //FT_OUTLINE_HIGH_PRECISION;\r\n\r\n\tLPTTPOLYGONHEADER ttphp = (LPTTPOLYGONHEADER)bufp;\r\n\tLPTTPOLYGONHEADER ttphpend = (LPTTPOLYGONHEADER)((PBYTE)ttphp + bufsize);\r\n\r\n\twhile (ttphp < ttphpend) {\r\n\t\tLPTTPOLYCURVE ttpcp = (LPTTPOLYCURVE)(ttphp + 1);\r\n\t\tLPTTPOLYCURVE ttpcpend = (LPTTPOLYCURVE)((PBYTE)ttphp + ttphp->cb);\r\n\t\tif ((PVOID)ttpcpend >(PVOID)ttphpend) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t++outline.n_points;\r\n\t\t++outline.n_contours;\r\n\t\twhile (ttpcp < ttpcpend) {\r\n\t\t\tLPPOINTFX pfxp = &ttpcp->apfx[0];\r\n\t\t\toutline.n_points += ttpcp->cpfx;\r\n\t\t\tttpcp = (LPTTPOLYCURVE)(pfxp + ttpcp->cpfx);\r\n\t\t}\r\n\t\tttphp = (LPTTPOLYGONHEADER)ttpcp;\r\n\t}\r\n\r\n\tif (ttphp != ttphpend) {\r\n\t\treturn false;\r\n\t}\r\n\toutline.points = (FT_Vector *)calloc(outline.n_points, sizeof *outline.points);\r\n\toutline.tags = (unsigned char *)calloc(outline.n_points, sizeof *outline.tags);\r\n\toutline.contours = (unsigned short *)calloc(outline.n_contours, sizeof *outline.contours);\r\n\tif (!outline.points || !outline.tags || !outline.contours) {\r\n\t\tdone();\r\n\t\treturn false;\r\n\t}\r\n\r\n\tunsigned short *cp = outline.contours;\r\n\tshort ppos = 0;\r\n\r\n\tttphp = (LPTTPOLYGONHEADER)bufp;\r\n\twhile (ttphp < ttphpend) {\r\n\t\tLPTTPOLYCURVE ttpcp = (LPTTPOLYCURVE)(ttphp + 1);\r\n\t\tLPTTPOLYCURVE ttpcpend = (LPTTPOLYCURVE)((PBYTE)ttphp + ttphp->cb);\r\n\r\n\t\tLPPOINTFX pfxp0 = &ttpcp->apfx[0];\r\n\t\twhile (ttpcp < ttpcpend) {\r\n\t\t\tLPPOINTFX pfxp = &ttpcp->apfx[0];\r\n\t\t\tpfxp0 = pfxp + (ttpcp->cpfx - 1);\r\n\t\t\tttpcp = (LPTTPOLYCURVE)(pfxp + ttpcp->cpfx);\r\n\t\t}\r\n\t\tttpcp = (LPTTPOLYCURVE)(ttphp + 1);\r\n\r\n\t\tif (pfxp0->x.value != ttphp->pfxStart.x.value || pfxp0->x.fract != ttphp->pfxStart.x.fract ||\r\n\t\t\tpfxp0->y.value != ttphp->pfxStart.y.value || pfxp0->y.fract != ttphp->pfxStart.y.fract) {\r\n\t\t\toutline.points[ppos].x = toF26Dot6(ttphp->pfxStart.x);\r\n\t\t\toutline.points[ppos].y = toF26Dot6(ttphp->pfxStart.y);\r\n\t\t\toutline.tags[ppos] = getTag(FT_CURVE_TAG_ON, outline.points[ppos]);\r\n\t\t\t++ppos;\r\n\t\t}\r\n\t\twhile (ttpcp < ttpcpend) {\r\n\t\t\tchar tag;\r\n\t\t\tswitch (ttpcp->wType) {\r\n\t\t\tcase TT_PRIM_LINE:\r\n\t\t\t\ttag = FT_CURVE_TAG_ON;\r\n\t\t\t\tbreak;\r\n\t\t\tcase TT_PRIM_QSPLINE:\r\n\t\t\t\ttag = FT_CURVE_TAG_CONIC;\r\n\t\t\t\tbreak;\r\n\t\t\tcase TT_PRIM_CSPLINE:\r\n\t\t\t\ttag = FT_CURVE_TAG_CONIC;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\ttag = 0;\r\n\t\t\t}\r\n\r\n\t\t\tLPPOINTFX pfxp = &ttpcp->apfx[0];\r\n\t\t\tfor (WORD cnt = 0; cnt < ttpcp->cpfx; ++cnt) {\r\n\t\t\t\toutline.points[ppos].x = toF26Dot6(pfxp->x);\r\n\t\t\t\toutline.points[ppos].y = toF26Dot6(pfxp->y);\r\n\t\t\t\toutline.tags[ppos] = tag;\r\n\t\t\t\t++ppos;\r\n\t\t\t\t++pfxp;\r\n\t\t\t}\r\n\t\t\toutline.tags[ppos - 1] = getTag(FT_CURVE_TAG_ON, outline.points[ppos - 1]);\r\n\t\t\tttpcp = (LPTTPOLYCURVE)pfxp;\r\n\t\t}\r\n\t\t*cp++ = ppos - 1;\r\n\t\tttphp = (LPTTPOLYGONHEADER)ttpcp;\r\n\t}\r\n\toutline.n_points = ppos;\r\n\treturn true;\r\n}\r\n\r\ntemplate<typename T>\r\nclass CTempMem\r\n{\r\nprivate:\r\n\tchar m_localbuf[0x0f80];\r\n\tDWORD m_size;\r\n\tT m_ptr;\r\npublic:\r\n\tCTempMem() : m_size(sizeof m_localbuf), m_ptr((T)m_localbuf) {\r\n\t}\r\n\t~CTempMem() {\r\n\t\tdone();\r\n\t}\r\n\tT init(DWORD size) {\r\n\t\tdone();\r\n\t\tif (m_size > size) {\r\n\t\t\tm_size = size;\r\n\t\t\tm_ptr = (T)malloc(m_size);\r\n\t\t}\r\n\t\treturn m_ptr;\r\n\t}\r\n\tvoid done() {\r\n\t\tif (m_ptr != (T)m_localbuf) {\r\n\t\t\tfree(m_ptr);\r\n\t\t}\r\n\t\tm_size = sizeof m_localbuf;\r\n\t\tm_ptr = (T)m_localbuf;\r\n\t}\r\n\toperator T () { return m_ptr; }\r\n\tbool operator ! () { return !m_ptr; }\r\n\tDWORD getsize() { return m_size; }\r\n};\r\n\r\nBOOL FreeTypePrepare(FreeTypeDrawInfo& FTInfo)\r\n{\r\n\t//CDebugElapsedCounter cntr(\"FreeTypePrepare\");\r\n#ifdef _DEBUG\r\n\tFTInfo.Validate();\r\n#endif\r\n\r\n\tFT_Face& freetype_face = FTInfo.freetype_face;\r\n\tFT_Int& cmap_index = FTInfo.cmap_index;\r\n\tFT_Render_Mode& render_mode = FTInfo.render_mode;\r\n\tFTC_ImageTypeRec& font_type = FTInfo.font_type;\r\n\tFreeTypeFontInfo*& pfi = FTInfo.pfi;\r\n\tconst CFontSettings*& pfs = FTInfo.pfs;\r\n\tFreeTypeFontCache*& pftCache = FTInfo.pftCache;\r\n\tFTC_ScalerRec& scaler = FTInfo.scaler;\r\n\tTEXTMETRIC& tm = FTInfo.params->otm->otmTextMetrics;\r\n\r\n\tFTC_FaceID face_id = NULL;\r\n\tint height = 0;\r\n\r\n\tconst LOGFONTW& lf = FTInfo.LogFont();\r\n\trender_mode = FT_RENDER_MODE_NORMAL;\r\n\tif (FTInfo.params->alpha < 1)\r\n\t\tFTInfo.params->alpha = 1;\r\n\r\n\tif (!*lf.lfFaceName)\r\n\t\treturn FALSE;\t//optimized\r\n\tFTInfo.face_id_list_num = 0;\r\n\t//Assert(_tcsicmp(lf.lfFaceName, _T(\"@Arial Unicode MS\")) != 0);\r\n\tpfi = NULL;\r\n\tCGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\tconst bool bVertical = pSettings->FontLoader() == SETTING_FONTLOADER_FREETYPE ? lf.lfFaceName[0] == _T('@') : false;\r\n\r\n\tFreeTypeFontInfo* pfitemp = g_pFTEngine->FindFont(FTInfo.params);\r\n\tif (pfitemp) {\r\n\t\tif (!pfi) pfi = pfitemp;\r\n\t\tFTInfo.face_id_list_num = pfi->GetFTLink(&FTInfo.face_id_list);\r\n\t\tpfi->GetGGOLink(&FTInfo.ggo_font_list);\r\n\t\tFTInfo.face_id_simsun = pfi->GetSimSunID();\r\n\t}\r\n\telse\r\n\t\treturn FALSE;\r\n\tif (!(freetype_face = FTInfo.GetFace(0)))\r\n\t{\r\n\t\tpSettings->AddFontExclude(lf.lfFaceName);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tif (!pfi) {\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tFTInfo.params->lplf->lfWeight = FTInfo.params->otm->otmTextMetrics.tmWeight;\t//更新到标准weight\r\n\tpfs = &pfi->GetFontSettings();\r\n\r\n\tcmap_index = -1;\r\n\tswitch (pSettings->FontLoader()) {\r\n\tcase SETTING_FONTLOADER_FREETYPE:\r\n\t{\r\n\t\tface_id = (FTC_FaceID)pfi->GetId();\r\n\r\n\t\tscaler.face_id = face_id;\r\n\r\n\t\theight = FTInfo.params->otm->otmTextMetrics.tmHeight - FTInfo.params->otm->otmTextMetrics.tmInternalLeading;\t//Snowie!!剪掉空白高度，bugfix。\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// \t\t\t\tif(lf.lfHeight > 0){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// \t\t\t\t\tscaler.height = height;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// \t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// \t\t\t\telse{\r\n\t\tscaler.height = height;\r\n\t\t//\t\t\t\t}\r\n\t\t//Snowie!!\r\n\t\tTT_OS2* os2_table = pfitemp->GetOS2Table();\r\n\r\n\t\tif (lf.lfQuality && os2_table->xAvgCharWidth)\r\n\t\t{\r\n\t\t\tif (!(freetype_face->style_flags & FT_STYLE_FLAG_BOLD) && tm.tmWeight >= FW_BOLD)\r\n\t\t\t\t--FTInfo.params->otm->otmTextMetrics.tmAveCharWidth;\r\n\t\t\tscaler.width = MulDiv(FTInfo.params->otm->otmTextMetrics.tmAveCharWidth, FTInfo.params->otm->otmEMSquare, os2_table->xAvgCharWidth);\r\n\t\t}\r\n\t\telse\r\n\t\t\tscaler.width = scaler.height;\r\n\t\tif (bVertical)\r\n\t\t\tswap(scaler.width, scaler.height);//如果是竖向字体，交换宽高\r\n\t\t\t\t\t\t\t\t\t\t\t  //!!Snowie\r\n\t\tscaler.pixel = 1;\r\n\t\tscaler.x_res = 0;\r\n\t\tscaler.y_res = 0;\r\n\t\t/*\r\n\t\tFT_Size font_size;\r\n\t\t{\r\n\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_MANAGER);\r\n\t\tif(FTC_Manager_LookupSize(cache_man, &scaler, &font_size))\r\n\t\treturn FALSE;\r\n\t\t}*/\r\n\t\theight = scaler.height;\r\n\t\tbreak;\r\n\t}\r\n\tcase SETTING_FONTLOADER_WIN32:\r\n\t{\r\n\t\t/*\r\n\t\tOUTLINETEXTMETRIC otm;\r\n\t\tif (GetOutlineTextMetrics(FTInfo.hdc, sizeof otm, &otm) != sizeof otm) {\r\n\t\treturn FALSE;\r\n\t\t}*/\r\n\t\theight = -lf.lfHeight;\r\n\t\tscaler.height = height;\r\n\t\tscaler.width = lf.lfWidth;\r\n\t}\r\n\tbreak;\r\n\tdefault:\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\t// fetch face again to get the correct one.\r\n\tif (!(freetype_face = FTInfo.GetFace(0)))\r\n\t{\r\n\t\tpSettings->AddFontExclude(lf.lfFaceName);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tpftCache = pfi->GetCache(scaler, lf);\r\n\tif (!pftCache)\r\n\t\treturn FALSE;\r\n\r\n\t/*FT_Size_RequestRec size_request;\r\n\tsize_request.width = lf.lfWidth;\r\n\tsize_request.horiResolution = 0;\r\n\tsize_request.vertResolution = 0;\r\n\tif(lf.lfHeight > 0){\r\n\t// セル高さ\r\n\tsize_request.type = FT_SIZE_REQUEST_TYPE_CELL;\r\n\tsize_request.height = lf.lfHeight * 64;\r\n\t}\r\n\telse{\r\n\t// 文字高さ\r\n\tsize_request.type = FT_SIZE_REQUEST_TYPE_NOMINAL;\r\n\tsize_request.height = (-lf.lfHeight) * 64;\r\n\t}\r\n\tif(FT_Request_Size(freetype_face, &size_request))\r\n\tgoto Exit2;*/\r\n\r\n\tswitch (pSettings->FontLoader()) {\r\n\tcase SETTING_FONTLOADER_FREETYPE:\r\n\t\t// font_typeを設定\r\n\t\tfont_type.face_id = face_id;\r\n\t\tfont_type.width = scaler.width;//freetype_face->size->metrics.x_ppem;\r\n\t\tfont_type.height = scaler.height;//freetype_face->size->metrics.y_ppem;\r\n\t\t\t\t\t\t\t\t\t\t //Snowie!!\r\n\t\tFTInfo.height = font_type.height;\r\n\t\tFTInfo.width = font_type.width;\r\n\r\n\t\t/* ビットマップまでキャッシュする場合はFT_LOAD_RENDER | FT_LOAD_TARGET_*\r\n\t\t* とする。ただし途中でTARGETを変更した場合等はキャッシュが邪魔する。\r\n\t\t* そういう時はFT_LOAD_DEFAULTにしてFTC_ImageCache_Lookup後に\r\n\t\t* FT_Glyph_To_Bitmapしたほうが都合がいいと思う。\r\n\t\t*/\r\n\t\t// Boldは太り具合というものがあるので本当はこれだけでは足りない気がする。\r\n\t\t/*if(IsFontBold(lf) && !(freetype_face->style_flags & FT_STYLE_FLAG_BOLD) ||\r\n\t\tlf.lfItalic && !(freetype_face->style_flags & FT_STYLE_FLAG_ITALIC)){\r\n\t\t// ボールド、イタリックは後でレンダリングする\r\n\t\t// 多少速度は劣化するだろうけど仕方ない。\r\n\t\tfont_type.flags = FT_LOAD_NO_BITMAP;\r\n\t\t}\r\n\t\telse{\r\n\t\tfont_type.flags = FT_LOAD_RENDER | FT_LOAD_NO_BITMAP;\r\n\t\t}*/\r\n\t\tbreak;\r\n\tcase SETTING_FONTLOADER_WIN32:\r\n\t\tfont_type.face_id = face_id;\r\n\t\tfont_type.width = -1;\r\n\t\tfont_type.height = -1;\r\n\t\tbreak;\r\n\r\n\t\tDEFAULT_UNREACHABLE;\r\n\t}\r\n\tfont_type.flags = FT_LOAD_NO_BITMAP | FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH;\r\n\r\n\t// ヒンティング\r\n\tswitch (pfs->GetHintingMode()) {\r\n\tcase 0:\r\n\t\t// ignore.\r\n\t\tbreak;\r\n\tcase 1:\r\n\t\tfont_type.flags |= FT_LOAD_NO_HINTING;\r\n\t\tbreak;\r\n\tcase 2:\r\n\t\tfont_type.flags |= FT_LOAD_FORCE_AUTOHINT;\r\n\t\tbreak;\r\n\t}\r\n\r\n\t//如果含有内置hinting则启用default模式，否则使用autohint模式，以保证效果\r\n\t// アンチエイリアス\r\n\tif (FTInfo.IsMono()) {\r\n\t\tfont_type.flags |= FT_LOAD_TARGET_MONO;\r\n\t\trender_mode = FT_RENDER_MODE_MONO;\r\n\t}\r\n\telse {\r\n\t\tswitch (pfs->GetAntiAliasMode()) {\r\n\t\tcase -1:\r\n\t\t\tfont_type.flags |= FT_LOAD_TARGET_MONO;\r\n\t\t\trender_mode = FT_RENDER_MODE_MONO;\r\n\t\t\tbreak;\r\n\t\tcase 0:\r\n\t\t\tfont_type.flags |= FT_LOAD_TARGET_NORMAL;\r\n\t\t\trender_mode = FT_RENDER_MODE_NORMAL;\r\n\t\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tfont_type.flags |= FT_LOAD_TARGET_LIGHT;\r\n\t\t\trender_mode = FT_RENDER_MODE_LIGHT;\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\tcase 3:\r\n\t\t\tfont_type.flags |= FT_LOAD_TARGET_LCD;\r\n\t\t\trender_mode = FT_RENDER_MODE_LCD;\r\n\t\t\tbreak;\r\n\t\tcase 4:\r\n\t\tcase 5:\r\n\t\t\tfont_type.flags |= FT_LOAD_TARGET_LIGHT;\r\n\t\t\trender_mode = FT_RENDER_MODE_LCD;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tif (pSettings->HintSmallFont() /*&& font_type.flags & FT_LOAD_TARGET_LIGHT*/ && font_type.height != -1 && font_type.height<12)  //通用设置不使用hinting，但是打开了小字体hinting开关\r\n\t{\r\n\t\t/*\r\n\t\tif (!(freetype_face->face_flags & FT_FACE_FLAG_TRICKY))\t//如果不是tricky字体\r\n\t\tfont_type.flags = font_type.flags & (~FT_LOAD_NO_HINTING) | (pfi->FontHasHinting() ? FT_LOAD_NO_AUTOHINT : FT_LOAD_FORCE_AUTOHINT);\r\n\t\telse*/\r\n\r\n\t\tfont_type.flags = font_type.flags & (~FT_LOAD_NO_HINTING)/* | (pfi->FontHasHinting() ? FT_LOAD_DEFAULT : FT_LOAD_FORCE_AUTOHINT)*/;\r\n\t}\r\n\r\n\tFTInfo.useKerning = FALSE;\r\n\tif (pfs->GetKerning()) {\r\n\t\tswitch (pSettings->FontLoader()) {\r\n\t\tcase SETTING_FONTLOADER_FREETYPE:\r\n\t\t\tFTInfo.useKerning = !!FT_HAS_KERNING(freetype_face);\r\n\t\t\tbreak;\r\n\t\tcase SETTING_FONTLOADER_WIN32:\r\n\t\t{\r\n\t\t\tDWORD rc = GetFontLanguageInfo(FTInfo.hdc);\r\n\t\t\tif (rc != GCP_ERROR) {\r\n\t\t\t\tFTInfo.useKerning = !!(rc & GCP_USEKERNING);\r\n\t\t\t\tFTInfo.ggokerning.init(FTInfo.hdc);\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\t\tDEFAULT_UNREACHABLE;\r\n\t\t}\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\n// 縦にするやつはtrue(ASCIIと半角カナはfalse)\r\ninline bool IsVerticalChar(WCHAR wch) {\r\n\tif (wch < 0x80)\r\n\t\treturn false;\r\n\tif (0xFF61 <= wch && wch <= 0xFF9F)\r\n\t\treturn false;\r\n\t// 本当はもっと真面目にやらないとまずいが。\r\n\treturn true;\r\n}\r\n\r\nstruct CGGOFont\r\n{\r\n\tHDC m_hdc;\r\n\tHFONT m_hfont;\r\n\tHFONT m_hprevfont;\r\n\tCGGOFont(HDC hdc, const LOGFONT& olf) : m_hdc(hdc), m_hfont(NULL), m_hprevfont(NULL) {\r\n\t\tLOGFONT lf = olf;\r\n\t\tlf.lfWeight = FW_REGULAR;\r\n\t\tlf.lfItalic = FALSE;\r\n\t\tlf.lfStrikeOut = FALSE;\r\n\t\tm_hfont = CreateFontIndirect(&lf);\r\n\t}\r\n\t~CGGOFont() {\r\n\t\tif (m_hprevfont) {\r\n\t\t\tSelectFont(m_hdc, m_hprevfont);\r\n\t\t}\r\n\t\tDeleteFont(m_hfont);\r\n\t}\r\n\tvoid change() {\r\n\t\tm_hprevfont = SelectFont(m_hdc, m_hfont);\r\n\t}\r\n\tvoid restore() {\r\n\t\tSelectFont(m_hdc, m_hprevfont);\r\n\t\tm_hprevfont = NULL;\r\n\t}\r\n\toperator HFONT () { return m_hfont; }\r\n};\r\n\r\nclass ClpDx\r\n{\r\nprivate:\r\n\tconst INT *p;\r\n\tconst INT step;\r\npublic:\r\n\tClpDx(const INT *lpDx, UINT etoOptions) : p(lpDx), step((etoOptions & ETO_PDY) ? 2 : 1) {\r\n\t}\r\n\t~ClpDx() {\r\n\t}\r\n\tint get(int val) {\r\n\t\tint result;\r\n\t\tif (p) {\r\n\t\t\tresult = *p;\r\n\t\t\tp += step;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tresult = val;\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\tint gety(int val) {\t// you must call gety BEFORE call get, gety won't move the pointer, thus has no side effect\r\n\t\tint result;\r\n\t\tif (step == 1) return val;\t//only search for values in ETO_PDY mode.\r\n\t\tif (p) {\r\n\t\t\tresult = *(p + 1);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tresult = val;\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n};\r\n/*\r\nFT_UInt FTC_CMapCache_Lookup2( FTC_CMapCache  cache,\r\nFTC_FaceID     face_id,\r\nFT_Int         cmap_index,\r\nFT_UInt32      char_code,\r\nFT_Face\t\tfreetype_face)\r\n{\r\nif ((int)face_id >= charmapCacheSize)\r\n{\r\nint oldsize = charmapCacheSize;\r\ncharmapCacheSize = ((int)face_id / 100 + 1)*100;\r\ng_charmapCache = (FT_Int*)realloc(g_charmapCache, charmapCacheSize*sizeof(FT_Int));\r\nmemset(&g_charmapCache[oldsize], 0xff, (charmapCacheSize-oldsize)*sizeof(FT_Int));\r\n}\r\nif (g_charmapCache[(int)face_id]==-1)\r\nif (!FTC_Manager_LookupFace(cache_man, face_id, &freetype_face))\r\n{\r\ng_charmapCache[(int)face_id] = FT_Get_Charmap_Index(freetype_face->charmap);\r\ncmap_index = g_charmapCache[(int)face_id];\r\n}\r\nelse\r\ncmap_index = 0;\r\nreturn FTC_CMapCache_Lookup(cache, face_id, cmap_index, char_code);\r\n}*/\r\n\r\n\r\nBOOL ForEachGetGlyphFT(FreeTypeDrawInfo& FTInfo, LPCTSTR lpString, int cbString, FT_Referenced_Glyph* GlyphArray, FT_DRAW_STATE* drState)\r\n{\r\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\t//Snowie!!\r\n\tBOOL bIsSymbol = GetTextCharsetInfo(FTInfo.hdc, NULL, 0) == SYMBOL_CHARSET;\r\n\tBOOL bAllowDefaultLink = pSettings->GetFontLinkInfo().IsAllowFontLink((BYTE)GetTextCharsetInfo(FTInfo.hdc, NULL, 0));\t//是否为符号\r\n\tBOOL nRet = true;\r\n\tBOOL bWindowsLink = pSettings->FontLink() == 2;\r\n\t//!!Snowie\r\n\r\n\t/*const*/ FT_Face freetype_face = FTInfo.freetype_face;\t//去掉常量属性，下面要改他\r\n\tconst FT_Int cmap_index = FTInfo.cmap_index;\r\n\tconst FT_Bool useKerning = FTInfo.useKerning;\r\n\tFT_Render_Mode render_mode = FTInfo.render_mode;\r\n\tconst int LinkNum = FTInfo.face_id_list_num;\r\n\tint AAMode = FTInfo.pfs->GetAntiAliasMode();\r\n\t// fix AAMode to LCD if harmony lcd is enabled. This is will not affect directwrite output.\r\n\tif (AAMode > 2 && pSettings->HarmonyLCD()) {\r\n\t\tAAMode = 2;\r\n\t}\r\n\tint* AAList = FTInfo.AAModes;\r\n\tconst LOGFONTW& lf = FTInfo.LogFont();\r\n\tFreeTypeFontCache* pftCache = FTInfo.pftCache;\r\n\tconst CFontSettings*& pfs = FTInfo.pfs;\r\n\tFreeTypeFontInfo*& pfi = FTInfo.pfi;\r\n\tconst bool bLoadColor = pSettings->LoadColorFont();\r\n\tconst bool bGlyphIndex = FTInfo.IsGlyphIndex();\r\n\t//const bool bSizeOnly = FTInfo.IsSizeOnly();\r\n\t//const bool bOwnCache = !(FTInfo.font_type.flags & FT_LOAD_RENDER);\r\n\tconst LPCTSTR lpStart = lpString;\r\n\tconst LPCTSTR lpEnd = lpString + cbString;\r\n\tFT_UInt previous = 0;\r\n\tWCHAR previouswch = 0;\r\n\tconst bool bVertical = lf.lfFaceName[0] == _T('@');\r\n\tbool bLcdMode = render_mode == FT_RENDER_MODE_LCD;\r\n\tbool bLightLcdMode = (AAMode == 4) || (AAMode == 5);\r\n\tClpDx clpdx(FTInfo.lpDx, FTInfo.params->etoOptions);\r\n\tconst bool bWidthGDI32 = true;\r\n\tconst int ggoformatbase = (FTInfo.font_type.flags & FT_LOAD_NO_HINTING) ? GGO_UNHINTED | GGO_NATIVE : GGO_NATIVE;\r\n\r\n\tif (!s_GGOGlyphLoader.init(freetype_library)) {\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\r\n\tWORD * gi = new WORD[cbString];\r\n\tWORD * ggi = gi;\r\n\r\n\r\n\t//Snowie!!\r\n\r\n\t//Fast fontlink\r\n\tWORD ** lpfontlink = NULL;\r\n\tHFONT hOldFont = NULL;\r\n\tif (!bGlyphIndex && bWindowsLink)\t//使用Windows fontlink\r\n\t{\r\n\t\tlpfontlink = (WORD**)new LPVOID[FTInfo.face_id_list_num];\r\n\t\tfor (int i = 0; i<LinkNum; i++)\r\n\t\t{\r\n\t\t\tlpfontlink[i] = new WORD[cbString];\r\n\t\t\tZeroMemory(lpfontlink[i], sizeof(WORD)*cbString);\t//初始化为无链接\r\n\t\t}\r\n\t\t//\r\n\t\thOldFont = (HFONT)GetCurrentObject(FTInfo.hdc, OBJ_FONT);\t//加载第一个字体\r\n\t}\r\n\t//fontlink\r\n\r\n\tint* Dx = FTInfo.Dx;\r\n\tint* Dy = FTInfo.Dy;\r\n\tif (!bAllowDefaultLink && FTInfo.face_id_list_num > 1)\r\n\t\tFTInfo.face_id_list_num--;\t//如果是symbol页那就不链接到宋体\r\n\r\n\tbool bUnicodePlane = false;\r\n\tfor (int i = 0; lpString < lpEnd; ++lpString, ++gi, ++GlyphArray, ++drState, ++AAList, /*ggdi32++,*/ i++) {\r\n\t\tWCHAR wch = *lpString;\r\n\t\tif (bUnicodePlane)\r\n\t\t{\r\n\t\t\t*drState = FT_DRAW_NOTFOUND;\r\n\t\t\tbUnicodePlane = false;\r\n\t\t\tif (lpString < lpEnd - 1) {\r\n\t\t\t\tFTInfo.y -= clpdx.gety(0);\r\n\t\t\t\tFTInfo.x += clpdx.get(0);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tint gdi32x = 0;\r\n\t\t\t\tGetCharWidth32W(FTInfo.hdc, wch, wch, &gdi32x);\r\n\t\t\t\tFTInfo.y -= clpdx.gety(0);\r\n\t\t\t\tFTInfo.x += clpdx.get(gdi32x);\r\n\t\t\t\tFTInfo.px = FTInfo.x;\r\n\t\t\t}\r\n\t\t\tgoto cont;\r\n\t\t}\r\n\t\tif (!bGlyphIndex && bIsSymbol && !bWindowsLink)\r\n\t\t\twch |= 0xF000;\r\n\t\tFT_Referenced_Glyph* glyph_bitmap = GlyphArray;\r\n\t\tint gdi32x = 0;// = *ggdi32;\r\n\t\tFTInfo.font_type.face_id = FTInfo.face_id_list[0];\r\n\t\tFreeTypeCharData* chData = NULL;\r\n\t\tFT_UInt glyph_index = 0;\r\n\t\tBOOL bIsBold = false, bIsIndivBold = false;\r\n\r\n\t\t{\r\n\r\n\t\t\tchData = bGlyphIndex\r\n\t\t\t\t? pftCache->FindGlyphIndex(wch)\r\n\t\t\t\t: pftCache->FindChar(wch);\t//looking for wch in char cache and glyph cache\r\n\r\n\t\t\tif (chData/* && FTInfo.width==chData->GetWidth()*/) {\t// found cache\r\n\r\n\t\t\t\tgdi32x = chData->GetGDIWidth();\r\n\t\t\t\t*AAList = chData->GetAAMode();\r\n\t\t\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_LIBRARY);\r\n\t\t\t\tFT_Glyph_Ref_Copy((FT_Referenced_Glyph)chData->GetGlyph(render_mode), glyph_bitmap);\t// cached img-> glyph_bitmap\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//TRACE(_T(\"Cache Hit: %wc, size:%d, 0x%8.8X\\n\"), wch, chData->GetWidth(), glyph_bitmap);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!*glyph_bitmap) {\t// case: no cache found\r\n\t\t\tFT_Referenced_Glyph glyph = NULL;\r\n\t\t\tbool f_glyph = false;\r\n\t\t\t//GLYPHMETRICS gm;\r\n\t\t\tconst MAT2 mat2 = { { 0, 1 },{ 0, 0 },{ 0, 0 },{ 0, 1 } };\r\n\t\t\tUINT ggoformat = ggoformatbase;\r\n\t\t\tCTempMem<PVOID> ggobuf;\r\n\t\t\tDWORD outlinesize = 0;\r\n\r\n\t\t\tif (bGlyphIndex) {\t// glyph index doesn't require any font linking\r\n\t\t\t\tf_glyph = !!wch;\r\n\t\t\t\tglyph_index = wch;\r\n\t\t\t\t*AAList = AAMode;\r\n\t\t\t\tGetCharWidthI(FTInfo.hdc, wch, 1, (LPWORD)&wch, &gdi32x);\t//index的文字必须计算宽度\r\n\t\t\t\tif (FTInfo.font_type.height <= pSettings->BitmapHeight() && pfi->EmbeddedBmpExist(FTInfo.font_type.height))\r\n\t\t\t\t{\r\n\t\t\t\t\tf_glyph = false;\t//使用点阵，不绘图\r\n\t\t\t\t\t*drState = FT_DRAW_EMBEDDED_BITMAP;\t//设置为点阵绘图方式\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tif (wch && !CID.myiswcntrl(lpString[0])) {\t// need to draw a non-control character\t\t\t\t\r\n\t\t\t\t\tfor (int j = 0; j < FTInfo.face_id_list_num; ++j) {\r\n\t\t\t\t\t\tfreetype_face = NULL;\t// reinitialize it in case no fontlinking is available.\r\n\t\t\t\t\t\tif (bWindowsLink)\t//使用Windows函数进行fontlink\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (!lpfontlink[j][i])\t//还没初始化该字体的fontlink\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tSelectFont(FTInfo.hdc, FTInfo.ggo_font_list[j]);\t//加载ggo字体\r\n\t\t\t\t\t\t\t\tGetGlyphIndices(FTInfo.hdc, lpString, cbString - i, &lpfontlink[j][i], GGI_MARK_NONEXISTING_GLYPHS);\t//进行fontlink\r\n\t\t\t\t\t\t\t\tSelectFont(FTInfo.hdc, hOldFont);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tglyph_index = lpfontlink[j][i];\r\n\t\t\t\t\t\t\tif (glyph_index == 0xffff)\r\n\t\t\t\t\t\t\t\tglyph_index = 0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\t\t//使用freetype进行fontlink\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_MANAGER);\r\n\t\t\t\t\t\t\tglyph_index = FTC_CMapCache_Lookup(cmap_cache, FTInfo.face_id_list[j], -1, wch);\r\n\t\t\t\t\t\t\t//glyph_index = FT_Get_Char_Index(FTInfo.GetFace(j), wch);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (glyph_index) {\r\n\t\t\t\t\t\t\tGetCharWidth32W(FTInfo.hdc, wch, wch, &gdi32x);\t//有效文字，计算宽度\r\n\t\t\t\t\t\t\tf_glyph = true;\r\n\t\t\t\t\t\t\tFTInfo.font_type.face_id = FTInfo.face_id_list[j];\r\n\t\t\t\t\t\t\tfreetype_face = FTInfo.GetFace(j);\t//同时更新对应faceid的实际face\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//接下来更新对应的fontsetting\r\n\t\t\t\t\t\t\tFTInfo.font_type.flags = FT_LOAD_NO_BITMAP | FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH;\r\n\t\t\t\t\t\t\t// ヒンティング\r\n\t\t\t\t\t\t\t//extern CFontSetCache g_fsetcache;\r\n\t\t\t\t\t\t\t//pfs = g_fsetcache.Get(FTInfo.font_type.face_id);\r\n\t\t\t\t\t\t\tif (FTInfo.font_type.face_id == FTInfo.face_id_simsun && j>0)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tswitch (FTInfo.font_type.height)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tcase 11: {FTInfo.font_type.height = 12; FTInfo.font_type.width++; break; }\t//对宋体进行特殊处理\r\n\t\t\t\t\t\t\t\tcase 13: {FTInfo.font_type.height = 15; FTInfo.font_type.width += 2; break; }\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tpfi = g_pFTEngine->FindFont((int)FTInfo.font_type.face_id);\r\n\t\t\t\t\t\t\tif (pfi)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tpfs = &pfi->GetFontSettings();\r\n\t\t\t\t\t\t\t\tswitch (pfs->GetHintingMode()) {\r\n\t\t\t\t\t\t\t\tcase 0:\r\n\t\t\t\t\t\t\t\t\t// ignore.\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_NO_HINTING;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_FORCE_AUTOHINT;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// アンチエイリアス\r\n\t\t\t\t\t\t\t\tif (FTInfo.IsMono()) {\r\n\t\t\t\t\t\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_TARGET_MONO;\r\n\t\t\t\t\t\t\t\t\trender_mode = FT_RENDER_MODE_MONO;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\tswitch (*AAList = pfs->GetAntiAliasMode()) {\r\n\t\t\t\t\t\t\t\t\tcase -1:\r\n\t\t\t\t\t\t\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_TARGET_MONO;\r\n\t\t\t\t\t\t\t\t\t\trender_mode = FT_RENDER_MODE_MONO;\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\tcase 0:\r\n\t\t\t\t\t\t\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_TARGET_NORMAL;\r\n\t\t\t\t\t\t\t\t\t\trender_mode = FT_RENDER_MODE_NORMAL;\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\t\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_TARGET_LIGHT;\r\n\t\t\t\t\t\t\t\t\t\trender_mode = FT_RENDER_MODE_LIGHT;\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_TARGET_LCD;\r\n\t\t\t\t\t\t\t\t\t\trender_mode = FT_RENDER_MODE_LCD;\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\t\t\t\tcase 5:\r\n\t\t\t\t\t\t\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_TARGET_LIGHT;\r\n\t\t\t\t\t\t\t\t\t\trender_mode = FT_RENDER_MODE_LCD;\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (pSettings->HintSmallFont() && FTInfo.font_type.flags & FT_LOAD_TARGET_LIGHT && FTInfo.font_type.height != -1 && FTInfo.font_type.height<12)  //通用设置不使用hinting，但是打开了小字体hinting开关\r\n\t\t\t\t\t\t\t\t\tFTInfo.font_type.flags = FTInfo.font_type.flags & (~FT_LOAD_NO_HINTING)/* | (pfi->FontHasHinting() ? FT_LOAD_DEFAULT : FT_LOAD_FORCE_AUTOHINT)*/;\r\n\r\n\t\t\t\t\t\t\t\tAAMode = *AAList/*pfs->GetAntiAliasMode()*/;\r\n\t\t\t\t\t\t\t\tbLcdMode = render_mode == FT_RENDER_MODE_LCD;\r\n\t\t\t\t\t\t\t\tbLightLcdMode = (AAMode == 4) || (AAMode == 5);\r\n\t\t\t\t\t\t\t\t//更新完成\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (FTInfo.font_type.height <= pSettings->BitmapHeight() && pfi->EmbeddedBmpExist(FTInfo.font_type.height))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tf_glyph = false;\t//使用点阵，不绘图\r\n\t\t\t\t\t\t\t\t*drState = FT_DRAW_EMBEDDED_BITMAP;\t//设置为点阵绘图方式\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\r\n\r\n\t\t\tif (!f_glyph || !freetype_face) {\t//can't find suitable fontface, glyphindex case is already calculated.\r\n#ifdef _DEBUG\r\n\t\t\t\tGdiSetBatchLimit(0);\r\n#endif\r\n\t\t\t\tif (*drState == FT_DRAW_NORMAL || bGlyphIndex)\r\n\t\t\t\t\t*drState = FT_DRAW_NOTFOUND;\t//找不到文字\r\n\t\t\t\tif ((!FTInfo.lpDx || lpString == lpEnd - 1) && !bGlyphIndex)\t//无效文字，而且没有事先排版或者是排版的最后一个字符了\r\n\t\t\t\t{\r\n\t\t\t\t\tGetCharWidth32W(FTInfo.hdc, wch, wch, &gdi32x);\r\n\t\t\t\t}\r\n\t\t\t\tint cx = gdi32x;\r\n\t\t\t\t/*\r\n\t\t\t\tif (bSizeOnly) {\r\n\t\t\t\tFTInfo.x += cx;\r\n\t\t\t\t} else*/\r\n\r\n\t\t\t\t{\r\n\t\t\t\t\tif (wch) {\r\n\t\t\t\t\t\t*glyph_bitmap = NULL;\t//无效文字\r\n\t\t\t\t\t\t\t\t\t\t\t\t//ORIG_ExtTextOutW(FTInfo.hdc, FTInfo.x, FTInfo.yTop, FTInfo.GetETO(), NULL, &wch, 1, NULL);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tBOOL isc = bGlyphIndex ? false : (CID.myiswcntrl(*lpString));\r\n\t\t\t\t\tif (isc == CNTRL_UNICODE_PLANE)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (!FTInfo.lpDx) {\r\n\t\t\t\t\t\t\tSIZE p = { 0 };\r\n\t\t\t\t\t\t\tif (GetTextExtentExPointW(FTInfo.hdc, lpString, 2, 99999, NULL, NULL, &p)) {\r\n\t\t\t\t\t\t\t\tgdi32x = p.cx;\r\n\t\t\t\t\t\t\t\tcx = gdi32x;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbUnicodePlane = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// \t\t\t\t\telse\r\n\t\t\t\t\t// \t\t\t\t\t\tif (isc == CNTRL_ZERO_WIDTH)\t//预计算的无宽度控制字\r\n\t\t\t\t\t// \t\t\t\t\t\t\tcx = 0;\r\n\t\t\t\t\tint dyHeight = clpdx.gety(0);\r\n\t\t\t\t\tint dxWidth = clpdx.get(cx);\r\n\r\n\t\t\t\t\tif (isc == CNTRL_COMPLEX_TEXT)\t//控制字\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcx = dxWidth;\t//服从windows的宽度调度\r\n\t\t\t\t\t\t\t\t\t\t//if (!dxWidth)\r\n\t\t\t\t\t\t\t\t\t\t//\tCID.setcntrlAttribute(wch, CNTRL_ZERO_WIDTH);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (lpString < lpEnd - 1) {\r\n\t\t\t\t\t\tFTInfo.x += dxWidth;\r\n\t\t\t\t\t\tFTInfo.y -= dyHeight;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t//if (gdi32x)\r\n\t\t\t\t\t\t//{\r\n\r\n\t\t\t\t\t\t/*\t\t\t\t\t\tABC abc = {0, cx, 0};\r\n\t\t\t\t\t\tif (bGlyphIndex)\r\n\t\t\t\t\t\tGetCharABCWidthsI(FTInfo.hdc, wch, 1, NULL, &abc);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\tGetCharABCWidths(FTInfo.hdc, wch, wch, &abc);*/\r\n\t\t\t\t\t\t//FTInfo.px = FTInfo.x+Max(clpdx.get(cx), abc.abcA+(int)abc.abcB+abc.abcC);\t//无效文字的情况下，绘图宽度=鼠标位置\r\n\t\t\t\t\t\tFTInfo.px = FTInfo.x + cx;\r\n\t\t\t\t\t\tFTInfo.x += dxWidth;//Max(clpdx.get(cx), cx);/*(int)abc.abcB+abc.abcC*///Max(clpdx.get(cx), abc.abcB? abc.abcA:0);\r\n\t\t\t\t\t\t\t\t\t\t\t//}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!isc)\r\n\t\t\t\t\t\tFTInfo.x += FTInfo.params->charExtra;\r\n\t\t\t\t}\r\n\t\t\t\tgoto cont;\r\n\t\t\t}\r\n\r\n\t\t\t// 縦書き\r\n\t\t\tif (bVertical) {\r\n\t\t\t\tglyph_index = ft2vert_get_gid(\r\n\t\t\t\t\t(struct ft2vert_st *)freetype_face->generic.data,\r\n\t\t\t\t\tglyph_index);\r\n\t\t\t}\r\n\r\n\t\t\t// カーニング\r\n\t\t\tif (useKerning) {\r\n\t\t\t\tif (previous != 0 && glyph_index) {\r\n\t\t\t\t\tFT_Vector delta;\r\n\t\t\t\t\tFT_Get_Kerning(freetype_face,\r\n\t\t\t\t\t\tprevious, glyph_index,\r\n\t\t\t\t\t\tft_kerning_default, &delta);\r\n\t\t\t\t\tFTInfo.x += FT_PosToInt(delta.x);\r\n\t\t\t\t}\r\n\t\t\t\tprevious = glyph_index;\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// 縦横\r\n\t\t\tif (bVertical && IsVerticalChar(wch)) {\r\n\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_VERTICAL_LAYOUT;\r\n\t\t\t\tif (bLcdMode) {\r\n\t\t\t\t\tif (FTInfo.font_type.flags&FT_LOAD_TARGET_LCD == FT_LOAD_TARGET_LCD) {\r\n\t\t\t\t\t\tFTInfo.font_type.flags &= ~FT_LOAD_TARGET_LCD;\r\n\t\t\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_TARGET_LCD_V;\r\n\t\t\t\t\t}\r\n\t\t\t\t\trender_mode = FT_RENDER_MODE_LCD_V;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (bVertical)\r\n\t\t\t\t\tswap(FTInfo.font_type.height, FTInfo.font_type.width);\t//交换无法旋转的文字宽高\r\n\t\t\t\tFTInfo.font_type.flags &= ~FT_LOAD_VERTICAL_LAYOUT;\r\n\t\t\t\tif (bLcdMode) {\r\n\t\t\t\t\tif (FTInfo.font_type.flags&FT_LOAD_TARGET_LCD_V == FT_LOAD_TARGET_LCD_V) {\r\n\t\t\t\t\t\tFTInfo.font_type.flags &= ~FT_LOAD_TARGET_LCD_V;\r\n\t\t\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_TARGET_LCD;\r\n\t\t\t\t\t}\r\n\t\t\t\t\trender_mode = FT_RENDER_MODE_LCD;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t{\r\n\r\n\t\t\t\tbool bRequiredownsize;\r\n\r\n\t\t\t\tbIsIndivBold = freetype_face->style_flags & FT_STYLE_FLAG_BOLD;\t//是独立粗体\r\n\t\t\t\tbIsBold = (IsFontBold(lf) && !bIsIndivBold);\t//是仿粗体\r\n\t\t\t\tbRequiredownsize = bIsBold && /*(pSettings->BolderMode()==2 || (*/pSettings->BolderMode() != 1 /*&& FTInfo.height>FT_BOLD_LOW))*/;\r\n\t\t\t\tif (bRequiredownsize)\r\n\t\t\t\t{\r\n\t\t\t\t\tFTInfo.font_type.width -= (FTInfo.font_type.width) / 36;\r\n\t\t\t\t\tFTInfo.font_type.height -= (FTInfo.font_type.height) / 36;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t{\r\n\t\t\t\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_MANAGER);\r\n\t\t\t\t\tFT_Glyph temp_glyph = NULL;\r\n\t\t\t\t\tif (FTC_ImageCache_Lookup(\r\n\t\t\t\t\t\timage_cache,\r\n\t\t\t\t\t\t&FTInfo.font_type,\r\n\t\t\t\t\t\tglyph_index,\r\n\t\t\t\t\t\t&temp_glyph,\r\n\t\t\t\t\t\tNULL)) {\r\n\t\t\t\t\t\tnRet = false;\r\n\t\t\t\t\t\tgoto gdiexit;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tglyph = New_FT_Ref_Glyph();\r\n\t\t\t\t\tFT_Glyph_Copy(temp_glyph, &(glyph->ft_glyph));\t//转换为ref_glyph\r\n\t\t\t\t}\r\n\r\n\t\t\t\tFTInfo.font_type.height = FTInfo.height;\r\n\t\t\t\tFTInfo.font_type.width = FTInfo.width;\r\n\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_LIBRARY);\r\n\t\t\t\tif (FT_Glyph_Ref_Copy(glyph, glyph_bitmap))\r\n\t\t\t\t{\r\n\t\t\t\t\tFT_Done_Ref_Glyph(&glyph);\r\n\t\t\t\t\tnRet = FALSE;\r\n\t\t\t\t\tgoto gdiexit;\r\n\t\t\t\t}\r\n\t\t\t\tFT_Done_Ref_Glyph(&glyph);\r\n\t\t\t}\r\n\t\t\tif ((*glyph_bitmap)->ft_glyph->format != FT_GLYPH_FORMAT_BITMAP) {\r\n\t\t\t\tint str_h;\r\n\t\t\t\tint str_v;\r\n\t\t\t\tbool fbold = false;\r\n\t\t\t\tstr_h = str_v = FTInfo.pfi->CalcNormalWeight();\r\n\t\t\t\tif (bIsIndivBold)\r\n\t\t\t\t\tstr_h = str_v = FTInfo.pfi->GetExactBoldWeight() << 2;\r\n\t\t\t\tif (bIsBold) {\r\n\t\t\t\t\tfbold = true;\r\n\t\t\t\t\tstr_h += FTInfo.font_type.height<24 ? FTInfo.pfi->GetFTWeight() : (FTInfo.pfi->GetFTWeight()*FTInfo.font_type.height / 24);\r\n\t\t\t\t\tstr_v = str_h;\r\n\t\t\t\t}\r\n\t\t\t\tif ((str_h || str_v) && New_FT_Outline_Embolden(\r\n\t\t\t\t\t&((FT_OutlineGlyph)((*glyph_bitmap)->ft_glyph))->outline,\r\n\t\t\t\t\tstr_h, str_v, FTInfo.height))\r\n\t\t\t\t{\r\n\t\t\t\t\tFT_Done_Ref_Glyph(glyph_bitmap);\r\n\t\t\t\t\tnRet = false;\r\n\t\t\t\t\tgoto gdiexit;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (fbold) {\r\n\t\t\t\t\t((FT_BitmapGlyph)((*glyph_bitmap)->ft_glyph))->root.advance.x += 0x10000;\r\n\t\t\t\t}\r\n\t\t\t\tif (lf.lfItalic &&\r\n\t\t\t\t\t!(freetype_face->style_flags & FT_STYLE_FLAG_ITALIC)) {\r\n\t\t\t\t\tFT_Matrix matrix;\r\n\t\t\t\t\tFTInfo.pfi->CalcItalicSlant(matrix);\r\n\t\t\t\t\tFT_Outline_Transform(\r\n\t\t\t\t\t\t&((FT_OutlineGlyph)((*glyph_bitmap)->ft_glyph))->outline,\r\n\t\t\t\t\t\t&matrix);\r\n\t\t\t\t}\r\n\t\t\t\t{\r\n\t\t\t\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_LIBRARY);\r\n\t\t\t\t\tif (bLoadColor && FT_HAS_COLOR(freetype_face)) {\r\n\t\t\t\t\t\t// use custom API to get color bitmap\r\n\t\t\t\t\t\tif (FT_Glyph_To_BitmapEx(&((*glyph_bitmap)->ft_glyph), render_mode, 0, 1, 1, glyph_index, freetype_face)) {\r\n\t\t\t\t\t\t\tFT_Done_Ref_Glyph(glyph_bitmap);\r\n\t\t\t\t\t\t\tnRet = false;\r\n\t\t\t\t\t\t\tgoto gdiexit;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tif (FT_Glyph_To_Bitmap(&((*glyph_bitmap)->ft_glyph), render_mode, 0, 1)) {\r\n\t\t\t\t\t\t\tFT_Done_Ref_Glyph(glyph_bitmap);\r\n\t\t\t\t\t\t\tnRet = false;\r\n\t\t\t\t\t\t\tgoto gdiexit;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\t// end of \"case: no cache found\"\r\n\r\n\t\tint cx = (bVertical && IsVerticalChar(wch)) ?\r\n\t\t\tFT_FixedToInt(FT_BitmapGlyph((*glyph_bitmap)->ft_glyph)->root.advance.y) :\r\n\t\t\tFT_FixedToInt(FT_BitmapGlyph((*glyph_bitmap)->ft_glyph)->root.advance.x);\r\n\r\n\t\t{\r\n\t\t\tint dy = clpdx.gety(0);\t//获得高度\r\n\t\t\tint dx = clpdx.get(bWidthGDI32 ? gdi32x : cx);\t//获得宽度\r\n\t\t\tint left = FT_BitmapGlyph((*glyph_bitmap)->ft_glyph)->left;\r\n\t\t\tif (gdi32x == 0) {\t// zero width text (most likely a diacritic)\r\n\t\t\t\tif (FTInfo.x + dx + left < FTInfo.xBase)\r\n\t\t\t\t\tFTInfo.xBase = FTInfo.x + dx + left;\r\n\t\t\t\t//it needs to be drawn at the end of the offset (Windows specific, Windows will \"share\" half of letter's width to the diacritic)\r\n\t\t\t\tif (i > 0) {\r\n\t\t\t\t\t// we need to update the logical start position of the previous letter to compensate the strange behavior.\r\n\t\t\t\t\t*(Dx - 1) = FTInfo.x + dx;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (FTInfo.x + left < FTInfo.xBase)\r\n\t\t\t\t\tFTInfo.xBase = FTInfo.x + left;\t//如果有字符是负数起始位置的（合成符号）， 调整文字的起始位置\r\n\t\t\t}\r\n\r\n\t\t\tif (lpString < lpEnd - 1) {\r\n\t\t\t\tFTInfo.x += dx;\r\n\t\t\t\tFTInfo.y -= dy;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tint bx = FT_BitmapGlyph((*glyph_bitmap)->ft_glyph)->bitmap.width;\r\n\t\t\t\tif (render_mode == FT_RENDER_MODE_LCD && FT_BitmapGlyph((*glyph_bitmap)->ft_glyph)->bitmap.pixel_mode != FT_PIXEL_MODE_BGRA) bx /= 3;\r\n\t\t\t\tbx += left;\r\n\t\t\t\tFTInfo.px = FTInfo.x + Max(Max(dx, bx), cx);\t//有文字的情况下,绘图宽度=ft计算的宽度，鼠标位置=win宽度\r\n\t\t\t\tFTInfo.x += dx;//Max(dx, gdi32x);//Max(Max(dx, bx), cx);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\tFTInfo.x += FTInfo.params->charExtra;\r\n\r\n\t\t//if (bSizeOnly || bOwnCache) {\r\n\t\t//キャッシュ化\r\n\t\tif (glyph_index) {\r\n\r\n\t\t\tif (bGlyphIndex) {\r\n\t\t\t\tpftCache->AddGlyphData(glyph_index, /*cx*/FTInfo.width, gdi32x, (FT_Referenced_BitmapGlyph)*glyph_bitmap, render_mode, AAMode);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tpftCache->AddCharData(wch, glyph_index, /*cx*/FTInfo.width, gdi32x, (FT_Referenced_BitmapGlyph)*glyph_bitmap, render_mode, AAMode);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\tcont:\r\n\t\t*Dx = FTInfo.x;\t\t//Dx的位置是下一个字符开始的基准位置，并不是下一个字符开始画的位置\r\n\t\t*Dy = FTInfo.y;\t\t//Dy的位置是下一个字符的y坐标\r\n\t\t++Dx;\r\n\t\t++Dy;\r\n\t}\r\ngdiexit:\r\n\tdelete[] ggi;\r\n\t//\tdelete[] gdi32w;\r\n\r\n\tif (!bGlyphIndex && bWindowsLink)\r\n\t{\r\n\t\tfor (int i = 0; i<LinkNum; i++)\r\n\t\t\tdelete lpfontlink[i];\r\n\t\tdelete lpfontlink;\r\n\t}\r\n\treturn nRet;\r\n}\r\n\r\n\r\nBOOL ForEachGetGlyphGGO(FreeTypeDrawInfo& FTInfo, LPCTSTR lpString, int cbString, FT_Referenced_Glyph* GlyphArray, FT_DRAW_STATE* drState)\r\n{\r\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\t//Snowie!!\r\n\tBOOL bIsSymbol = GetTextCharsetInfo(FTInfo.hdc, NULL, 0) == SYMBOL_CHARSET;\r\n\tBOOL bAllowDefaultLink = pSettings->GetFontLinkInfo().IsAllowFontLink((BYTE)GetTextCharsetInfo(FTInfo.hdc, NULL, 0));\t//是否为符号\r\n\tBOOL nRet = true;\r\n\tBOOL bWindowsLink = pSettings->FontLink() == 2;\r\n\t//!!Snowie\r\n\r\n\t/*const*/ FT_Face freetype_face = FTInfo.freetype_face;\t//去掉常量属性，下面要改他\r\n\tconst FT_Int cmap_index = FTInfo.cmap_index;\r\n\tconst FT_Bool useKerning = FTInfo.useKerning;\r\n\tFT_Render_Mode render_mode = FTInfo.render_mode;\r\n\tconst int LinkNum = FTInfo.face_id_list_num;\r\n\tint AAMode = FTInfo.pfs->GetAntiAliasMode();\r\n\tint* AAList = FTInfo.AAModes;\r\n\tconst LOGFONTW& lf = FTInfo.LogFont();\r\n\tFreeTypeFontCache* pftCache = FTInfo.pftCache;\r\n\tconst CFontSettings*& pfs = FTInfo.pfs;\r\n\tFreeTypeFontInfo*& pfi = FTInfo.pfi;\r\n\tconst bool bGlyphIndex = FTInfo.IsGlyphIndex();\r\n\t//const bool bSizeOnly = FTInfo.IsSizeOnly();\r\n\t//const bool bOwnCache = !(FTInfo.font_type.flags & FT_LOAD_RENDER);\r\n\tconst LPCTSTR lpStart = lpString;\r\n\tconst LPCTSTR lpEnd = lpString + cbString;\r\n\tFT_UInt previous = 0;\r\n\tWCHAR previouswch = 0;\r\n\tconst bool bVertical = false;\r\n\tbool bLcdMode = render_mode == FT_RENDER_MODE_LCD;\r\n\tbool bLightLcdMode = (AAMode == 4) || (AAMode == 5);\r\n\tClpDx clpdx(FTInfo.lpDx, FTInfo.params->etoOptions);\r\n\tconst bool bWidthGDI32 = pSettings->WidthMode() == SETTING_WIDTHMODE_GDI32;\r\n\tconst int ggoformatbase = (FTInfo.font_type.flags & FT_LOAD_NO_HINTING) ? GGO_UNHINTED | GGO_NATIVE : GGO_NATIVE;\r\n\r\n\tif (!s_GGOGlyphLoader.init(freetype_library)) {\r\n\t\treturn FALSE;\r\n\t}\r\n\t// \tLPCTSTR dumy = lpString;\r\n\t// \tif (!bGlyphIndex)\r\n\t// \t for (; dumy<lpEnd;dumy++)\r\n\t// \t\tif (iswcntrl(*dumy))\r\n\t// \t\t{\r\n\t// \t\t\treturn false;\r\n\t// \t\t}\t\t\r\n\r\n\tWORD * gi = new WORD[cbString];\r\n\tWORD * ggi = gi;\r\n\t//int* gdi32w = new int[cbString];\r\n\t//int* ggdi32 = gdi32w;\r\n\t//SIZE* szSize =new SIZE[cbString];\r\n\t//SIZE* sSize = szSize;\r\n\r\n\t//Snowie!!\r\n\r\n\t//Fast fontlink\r\n\tWORD ** lpfontlink = NULL;\r\n\tHFONT hOldFont = NULL;\r\n\tif (!bGlyphIndex && bWindowsLink)\t//使用Windows fontlink\r\n\t{\r\n\t\tlpfontlink = (WORD**)new LPVOID[FTInfo.face_id_list_num];\r\n\t\tfor (int i = 0; i<LinkNum; i++)\r\n\t\t{\r\n\t\t\tlpfontlink[i] = new WORD[cbString];\r\n\t\t\tZeroMemory(lpfontlink[i], sizeof(WORD)*cbString);\t//初始化为无链接\r\n\t\t}\r\n\t\t//\r\n\t\thOldFont = (HFONT)GetCurrentObject(FTInfo.hdc, OBJ_FONT);\t//加载第一个字体\r\n\t}\r\n\t//fontlink\r\n\r\n\t/*\r\n\tif (!FTInfo.lpDx)\t//没有预先计算排版，需要获得每个文字的宽度信息\r\n\t{\r\n\tif (bGlyphIndex)\r\n\t{\r\n\t(GetCharWidthI(FTInfo.hdc, *(LPWORD)lpString, cbString, (LPWORD)lpString, gdi32w));\r\n\t}\r\n\telse\r\n\t{\r\n\tfor (int i=0;i<cbString;i++, ggdi32++)\r\n\tGetCharWidth32W(FTInfo.hdc, lpString[i], lpString[i], ggdi32);\r\n\tggdi32 = gdi32w;\r\n\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t//预先计算好了排版，只需要获得最后一个字的信息就可以了\r\n\tif (bGlyphIndex)\r\n\t{\r\n\t(GetCharWidthI(FTInfo.hdc, *(((LPWORD)lpString)+cbString-1), 1, (((LPWORD)lpString)+cbString-1), gdi32w+cbString-1));\r\n\t}\r\n\telse\r\n\t{\r\n\tGetCharWidth32W(FTInfo.hdc, lpString[cbString-1], lpString[cbString-1], ggdi32+cbString-1);\r\n\tggdi32 = gdi32w;\r\n\t}\r\n\t}*/\r\n\r\n\tif (!bGlyphIndex)  \t//仅对win32情况进行优化，ft情况另议\r\n\t\tif (GetGlyphIndices(FTInfo.hdc, lpString, cbString, gi, GGI_MARK_NONEXISTING_GLYPHS) != cbString)\r\n\t\t{\r\n\t\t\tnRet = false;\r\n\t\t\tgoto gdiexit;\r\n\t\t}\r\n\t//!!Snowie\r\n\tint* Dx = FTInfo.Dx;\r\n\tint* Dy = FTInfo.Dy;\r\n\tif (!bAllowDefaultLink && FTInfo.face_id_list_num > 1)\r\n\t\tFTInfo.face_id_list_num--;\t//如果是symbol页那就不链接到宋体\r\n\r\n\tfor (int i = 0; lpString < lpEnd; ++lpString, gi++, GlyphArray++, drState++, ++AAList,/*ggdi32++,*/ i++) {\r\n\t\tWCHAR wch = *lpString;\r\n\t\tif (!bGlyphIndex && bIsSymbol && !bWindowsLink)\r\n\t\t\twch |= 0xF000;\r\n\t\tFT_Referenced_Glyph* glyph_bitmap = GlyphArray;\r\n\t\tint gdi32x = 0;// = *ggdi32;\r\n\t\tFTInfo.font_type.face_id = FTInfo.face_id_list[0];\r\n\t\tFreeTypeCharData* chData = NULL;\r\n\t\tFT_UInt glyph_index = 0;\r\n\t\tBOOL bIsBold = false, bIsIndivBold = false;\r\n\r\n\t\t{\r\n\r\n\t\t\tchData = bGlyphIndex\r\n\t\t\t\t? pftCache->FindGlyphIndex(wch)\r\n\t\t\t\t: pftCache->FindChar(wch);\r\n\r\n\t\t\tif (chData && FTInfo.width == chData->GetWidth()) {\r\n\t\t\t\t/*\r\n\t\t\t\tif (bSizeOnly) {\r\n\t\t\t\t//TRACE(_T(\"Cache hit: GetCharWidth [%c]\\n\"), *lpString);\r\n\t\t\t\tint cx = chData->GetWidth();\r\n\t\t\t\tFTInfo.x += (bWidthGDI32 ? gdi32x : cx) + FTInfo.params->charExtra;\r\n\t\t\t\tgoto cont;\r\n\t\t\t\t}*/\r\n\t\t\t\tgdi32x = chData->GetGDIWidth();\r\n\t\t\t\t*AAList = chData->GetAAMode();\r\n\t\t\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_LIBRARY);\r\n\t\t\t\tFT_Glyph_Ref_Copy((FT_Referenced_Glyph)chData->GetGlyph(render_mode), glyph_bitmap);\r\n\t\t\t\t//TRACE(_T(\"Cache Hit: %wc, size:%d, 0x%8.8X\\n\"), wch, chData->GetWidth(), glyph_bitmap);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!*glyph_bitmap) {\r\n\t\t\tFT_Referenced_Glyph glyph = NULL;\r\n\t\t\tbool f_glyph = false;\r\n\t\t\tGLYPHMETRICS gm;\r\n\t\t\tconst MAT2 mat2 = { { 0, 1 },{ 0, 0 },{ 0, 0 },{ 0, 1 } };\r\n\t\t\tUINT ggoformat = ggoformatbase;\r\n\t\t\tCTempMem<PVOID> ggobuf;\r\n\t\t\tDWORD outlinesize = 0;\r\n\r\n\r\n\t\t\tif (bGlyphIndex) {\r\n\t\t\t\tf_glyph = true;\r\n\t\t\t\t*AAList = AAMode;\r\n\t\t\t\tglyph_index = wch;\r\n\t\t\t\tggoformat |= GGO_GLYPH_INDEX;\r\n\t\t\t\tGetCharWidthI(FTInfo.hdc, wch, 1, (LPWORD)&wch, &gdi32x);\t//index的文字必须计算宽度\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (*(gi) != 0xffff) {\r\n\t\t\t\t\tglyph_index = *(gi);\r\n\t\t\t\t\tf_glyph = true;\r\n\t\t\t\t\t*AAList = AAMode;\r\n\t\t\t\t}\r\n\t\t\t\tGetCharWidth32W(FTInfo.hdc, wch, wch, &gdi32x);\t//有效文字，计算宽度\r\n\t\t\t}\r\n\t\t\tif (lpString == lpStart && FTInfo.font_type.flags & FT_LOAD_FORCE_AUTOHINT) {\r\n\t\t\t\t// FORCE_AUTOHINT \r\n\t\t\t\tGetGlyphOutlineW(FTInfo.hdc, 0, GGO_METRICS | GGO_GLYPH_INDEX | GGO_NATIVE | GGO_UNHINTED, &gm, 0, NULL, &mat2);\r\n\t\t\t}\r\n\t\t\toutlinesize = GetGlyphOutlineW(FTInfo.hdc, wch, ggoformat, &gm, ggobuf.getsize(), ggobuf, &mat2);\r\n\r\n\t\t\tif (outlinesize == GDI_ERROR || outlinesize == 0) {\r\n\t\t\t\tglyph_index = 0;\r\n\t\t\t\tf_glyph = false;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tglyph_index = wch;\r\n\t\t\t\tf_glyph = true;\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif (!f_glyph) {\t//glyphindex的文字上面已经计算过了\r\n#ifdef _DEBUG\r\n\t\t\t\tGdiSetBatchLimit(0);\r\n#endif\r\n\t\t\t\tif (*drState == FT_DRAW_NORMAL || bGlyphIndex)\r\n\t\t\t\t\t*drState = FT_DRAW_NOTFOUND;\t//找不到文字\r\n\t\t\t\tif ((!FTInfo.lpDx || lpString == lpEnd - 1) && !bGlyphIndex)\t//无效文字，而且没有事先排版或者是排版的最后一个字符了\r\n\t\t\t\t{\r\n\t\t\t\t\tGetCharWidth32W(FTInfo.hdc, wch, wch, &gdi32x);\r\n\t\t\t\t}\r\n\t\t\t\tint cx = gdi32x;\r\n\t\t\t\t/*\r\n\t\t\t\tif (bSizeOnly) {\r\n\t\t\t\tFTInfo.x += cx;\r\n\t\t\t\t} else*/\r\n\r\n\t\t\t\t{\r\n\t\t\t\t\tif (wch) {\r\n\t\t\t\t\t\t*glyph_bitmap = NULL;\t//无效文字\r\n\t\t\t\t\t\t\t\t\t\t\t\t//ORIG_ExtTextOutW(FTInfo.hdc, FTInfo.x, FTInfo.yTop, FTInfo.GetETO(), NULL, &wch, 1, NULL);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tBOOL isc = bGlyphIndex ? false : (CID.myiswcntrl(*lpString));\r\n\t\t\t\t\tif (isc)\r\n\t\t\t\t\t\tcx = 0;\r\n\t\t\t\t\tif (lpString < lpEnd - 1) {\r\n\t\t\t\t\t\tFTInfo.y -= clpdx.gety(0);\r\n\t\t\t\t\t\tFTInfo.x += clpdx.get(cx);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t//if (gdi32x)\r\n\t\t\t\t\t\t{\r\n\r\n\t\t\t\t\t\t\t/*\t\t\t\t\t\tABC abc = {0, cx, 0};\r\n\t\t\t\t\t\t\tif (bGlyphIndex)\r\n\t\t\t\t\t\t\tGetCharABCWidthsI(FTInfo.hdc, wch, 1, NULL, &abc);\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tGetCharABCWidths(FTInfo.hdc, wch, wch, &abc);*/\r\n\t\t\t\t\t\t\t//FTInfo.px = FTInfo.x+Max(clpdx.get(cx), abc.abcA+(int)abc.abcB+abc.abcC);\t//无效文字的情况下，绘图宽度=鼠标位置\r\n\t\t\t\t\t\t\tFTInfo.px = FTInfo.x + cx;\r\n\t\t\t\t\t\t\tFTInfo.x += clpdx.get(cx);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!isc)\r\n\t\t\t\t\t\tFTInfo.x += FTInfo.params->charExtra;\r\n\t\t\t\t}\r\n\t\t\t\tgoto cont;\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif (useKerning && !bGlyphIndex) {\r\n\t\t\t\tif (previouswch && wch) {\r\n\t\t\t\t\tFTInfo.x += FTInfo.ggokerning.get(previouswch, wch);\r\n\t\t\t\t}\r\n\t\t\t\tpreviouswch = wch;\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// 縦横\r\n\t\t\tif (bVertical && IsVerticalChar(wch)) {\r\n\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_VERTICAL_LAYOUT;\r\n\t\t\t\tif (bLcdMode) {\r\n\t\t\t\t\tif (FTInfo.font_type.flags&FT_LOAD_TARGET_LCD == FT_LOAD_TARGET_LCD) {\r\n\t\t\t\t\t\tFTInfo.font_type.flags &= ~FT_LOAD_TARGET_LCD;\r\n\t\t\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_TARGET_LCD_V;\r\n\t\t\t\t\t}\r\n\t\t\t\t\trender_mode = FT_RENDER_MODE_LCD_V;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (bVertical)\r\n\t\t\t\t\tswap(FTInfo.font_type.height, FTInfo.font_type.width);\t//交换无法旋转的文字宽高\r\n\t\t\t\tFTInfo.font_type.flags &= ~FT_LOAD_VERTICAL_LAYOUT;\r\n\t\t\t\tif (bLcdMode) {\r\n\t\t\t\t\tif (FTInfo.font_type.flags&FT_LOAD_TARGET_LCD_V == FT_LOAD_TARGET_LCD_V) {\r\n\t\t\t\t\t\tFTInfo.font_type.flags &= ~FT_LOAD_TARGET_LCD_V;\r\n\t\t\t\t\t\tFTInfo.font_type.flags |= FT_LOAD_TARGET_LCD;\r\n\t\t\t\t\t}\r\n\t\t\t\t\trender_mode = FT_RENDER_MODE_LCD;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tCGGOOutlineGlyph ggoog;\r\n\t\t\t{\r\n\r\n\t\t\t\tif (outlinesize > ggobuf.getsize()) {\r\n\t\t\t\t\tif (!ggobuf.init(outlinesize)) {\r\n\t\t\t\t\t\tnRet = false;\r\n\t\t\t\t\t\tgoto gdiexit;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//ggofont.change();\r\n\t\t\t\t\toutlinesize = GetGlyphOutlineW(FTInfo.hdc, wch, ggoformat, &gm, ggobuf.getsize(), ggobuf, &mat2);\r\n\t\t\t\t\t//ggofont.restore();\r\n\t\t\t\t}\r\n\t\t\t\tif (outlinesize > ggobuf.getsize()) {\r\n\t\t\t\t\tnRet = false;\r\n\t\t\t\t\tgoto gdiexit;\r\n\t\t\t\t}\r\n\t\t\t\tif (!ggoog.init(outlinesize, ggobuf, gm)) {\r\n\t\t\t\t\tnRet = false;\r\n\t\t\t\t\tgoto gdiexit;\r\n\t\t\t\t}\r\n\t\t\t\tglyph = New_FT_Ref_Glyph();\r\n\t\t\t\tFT_Glyph_Copy((FT_Glyph)ggoog, &(glyph->ft_glyph));\r\n\t\t\t\t//glyph = ggoog;\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_LIBRARY);\r\n\t\t\t\tif (FT_Glyph_Ref_Copy(glyph, glyph_bitmap))\r\n\t\t\t\t{\r\n\t\t\t\t\tFT_Done_Ref_Glyph(&glyph);\r\n\t\t\t\t\tnRet = FALSE;\r\n\t\t\t\t\tgoto gdiexit;\r\n\t\t\t\t}\r\n\t\t\t\tFT_Done_Ref_Glyph(&glyph);\r\n\t\t\t}\r\n\t\t\tif ((*glyph_bitmap)->ft_glyph->format != FT_GLYPH_FORMAT_BITMAP) {\r\n\t\t\t\tint str_h;\r\n\t\t\t\tint str_v;\r\n\t\t\t\tbool fbold = false;\r\n\t\t\t\tstr_h = str_v = FTInfo.pfi->CalcNormalWeight();\r\n\t\t\t\tif (bIsIndivBold)\r\n\t\t\t\t\tstr_h = str_v = FTInfo.pfi->GetExactBoldWeight() << 2;\r\n\t\t\t\tif (bIsBold) {\r\n\t\t\t\t\tfbold = true;\r\n\t\t\t\t\tstr_h += FTInfo.font_type.height<24 ? FTInfo.pfi->GetFTWeight() : (FTInfo.pfi->GetFTWeight()*FTInfo.font_type.height / 24);\r\n\t\t\t\t\tstr_v = str_h;\r\n\t\t\t\t}\r\n\t\t\t\tif ((str_h || str_v) && New_FT_Outline_Embolden(\r\n\t\t\t\t\t&((FT_OutlineGlyph)((*glyph_bitmap)->ft_glyph))->outline,\r\n\t\t\t\t\tstr_h, str_v, FTInfo.height))\r\n\t\t\t\t{\r\n\t\t\t\t\tFT_Done_Ref_Glyph(glyph_bitmap);\r\n\t\t\t\t\tnRet = false;\r\n\t\t\t\t\tgoto gdiexit;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (fbold) {\r\n\t\t\t\t\t((FT_BitmapGlyph)((*glyph_bitmap)->ft_glyph))->root.advance.x += 0x10000;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t{\r\n\t\t\t\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_LIBRARY);\r\n\t\t\t\t\tif (FT_Glyph_To_Bitmap(&((*glyph_bitmap)->ft_glyph), render_mode, 0, 1)) {\r\n\t\t\t\t\t\tFT_Done_Ref_Glyph(glyph_bitmap);\r\n\t\t\t\t\t\tnRet = false;\r\n\t\t\t\t\t\tgoto gdiexit;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tint cx = (bVertical && IsVerticalChar(wch)) ?\r\n\t\t\tFT_FixedToInt(FT_BitmapGlyph((*glyph_bitmap)->ft_glyph)->root.advance.y) :\r\n\t\t\tFT_FixedToInt(FT_BitmapGlyph((*glyph_bitmap)->ft_glyph)->root.advance.x);\r\n\t\t//done\r\n\t\t/*\r\n\t\tif (bSizeOnly) {\r\n\t\tFTInfo.x += bWidthGDI32 ? gdi32x : cx;\r\n\t\t} else */\r\n\t\t{\r\n\t\t\tint dy = clpdx.gety(0);\r\n\t\t\tint dx = clpdx.get(bWidthGDI32 ? gdi32x : cx);\t//获得宽度\r\n\t\t\tint left = FT_BitmapGlyph((*glyph_bitmap)->ft_glyph)->left;\r\n\t\t\tif (FTInfo.x + left< FTInfo.xBase)\r\n\t\t\t\tFTInfo.xBase = FTInfo.x + left;\t//如果有字符是负数起始位置的（合成符号）， 调整文字的起始位置\r\n\r\n\t\t\tif (lpString < lpEnd - 1) {\r\n\t\t\t\tFTInfo.x += dx;\r\n\t\t\t\tFTInfo.y -= dy;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tint bx = FT_BitmapGlyph((*glyph_bitmap)->ft_glyph)->bitmap.width;\r\n\t\t\t\tif (render_mode == FT_RENDER_MODE_LCD) bx /= 3;\r\n\t\t\t\tbx += left;\r\n\t\t\t\tFTInfo.px = FTInfo.x + Max(Max(dx, bx), cx);\t//有文字的情况下,绘图宽度=ft计算的宽度，鼠标位置=win宽度\r\n\t\t\t\tFTInfo.x += dx;//Max(dx, gdi32x);//Max(Max(dx, bx), cx);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\tFTInfo.x += FTInfo.params->charExtra;\r\n\r\n\t\t//if (bSizeOnly || bOwnCache) {\r\n\t\t//キャッシュ化\r\n\t\tif (glyph_index) {\r\n\r\n\t\t\tif (bGlyphIndex) {\r\n\t\t\t\tpftCache->AddGlyphData(glyph_index, /*cx*/FTInfo.width, gdi32x, (FT_Referenced_BitmapGlyph)*glyph_bitmap, render_mode, AAMode);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tpftCache->AddCharData(wch, glyph_index, /*cx*/FTInfo.width, gdi32x, (FT_Referenced_BitmapGlyph)*glyph_bitmap, render_mode, AAMode);\r\n\t\t\t}\r\n\t\t}\r\n\t\t//}\r\n\t\t// \t\tif (!bGlyphIndex && iswcntrl(wch) && *glyph_bitmap)\r\n\t\t// \t\t{\r\n\t\t// \t\t\t\r\n\t\t// \t\t\tFT_Done_Glyph(*glyph_bitmap);\r\n\t\t// \t\t\t*glyph_bitmap = NULL;\r\n\t\t// \t\t}\r\n\tcont:\r\n\t\t*Dx = FTInfo.x;\r\n\t\t*Dy = FTInfo.y;\r\n\t\t++Dx;\r\n\t\t++Dy;\r\n\t}\r\ngdiexit:\r\n\tdelete[] ggi;\r\n\t//\tdelete[] gdi32w;\r\n\r\n\tif (!bGlyphIndex && bWindowsLink)\r\n\t{\r\n\t\tfor (int i = 0; i<LinkNum; i++)\r\n\t\t\tdelete lpfontlink[i];\r\n\t\tdelete lpfontlink;\r\n\t}\r\n\treturn nRet;\r\n}\r\n\r\n\r\nBOOL GetLogFontFromDC(HDC hdc, LOGFONT& lf)\r\n{\r\n\tLOGFONTW lfForce = { 0 };\r\n\tHFONT hf = GetCurrentFont(hdc);\r\n\tif (!ORIG_GetObjectW(hf, sizeof(LOGFONTW), &lf))\r\n\t\treturn FALSE;\r\n\r\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\t//if (pSettings->CopyForceFont(lfForce, lf))\r\n\t//\tlf = lfForce;\r\n\r\n\tif (pSettings->LoadOnDemand()) {\r\n\t\t//AddFontToFT(lf.lfFaceName, lf.lfWeight, !!lf.lfItalic);\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nBOOL CALLBACK TextOutCallback(FreeTypeGlyphInfo& FTGInfo)\r\n{\r\n\tFreeTypeDrawInfo* FTInfo = FTGInfo.FTInfo;\r\n\tFT_BitmapGlyph& glyph_bitmap = FTGInfo.FTGlyph;\r\n\tconst bool bVertical = FTInfo->LogFont().lfFaceName[0] == _T('@');\r\n\tint nOldAlpha = FTInfo->params->alpha;\r\n\r\n\tif (!FTGInfo.FTGlyph->bitmap.buffer) {\r\n\t\t//if (FTInfo->params->alpha == 1) {\r\n\t\t// \t\tif (!(FTInfo->GetETO() & ETO_GLYPH_INDEX) && wch==32)\t//空格\r\n\t\t// \t\t\tORIG_ExtTextOutW(FTInfo->hdc, FTInfo->x, FTInfo->yTop, FTInfo->GetETO() & ETO_IGNORELANGUAGE, NULL, &wch, 1, NULL);\r\n\t\t// \t\telse\r\n\t\tORIG_ExtTextOutW(FTInfo->hdc, FTInfo->x, FTInfo->yTop, FTInfo->GetETO(), NULL, &FTGInfo.wch, 1, NULL);\r\n\t\t//}\r\n\t}\r\n\telse {\r\n\r\n\t\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\t\tif (bVertical && IsVerticalChar(FTGInfo.wch) &&\r\n\t\t\tpSettings->FontLoader() == SETTING_FONTLOADER_FREETYPE) {\r\n\t\t\tif (FTInfo->params->alpha>1)\r\n\t\t\t{\r\n\t\t\t\tFreeTypeDrawBitmapV(FTGInfo, *FTGInfo.shadow, FTInfo->x + FTInfo->sx,\r\n\t\t\t\t\tFTInfo->yTop + FTInfo->params->otm->otmTextMetrics.tmHeight - (glyph_bitmap->left + glyph_bitmap->bitmap.width) - 1 + FTInfo->sy);//画阴影\r\n\t\t\t\tFTInfo->params->alpha = 1;\r\n\t\t\t}\r\n\t\t\tif (!FreeTypeDrawBitmapV(FTGInfo, *FTGInfo.solid, FTInfo->x,\r\n\t\t\t\tFTInfo->yTop + FTInfo->params->otm->otmTextMetrics.tmHeight - (glyph_bitmap->left + glyph_bitmap->bitmap.width) - 1))\t//画文字\t\r\n\t\t\t{\r\n\t\t\t\t// fallback to GDI when fail to draw with FT\r\n\t\t\t\tORIG_ExtTextOutW(FTInfo->hdc, FTInfo->x, FTInfo->yTop, FTInfo->GetETO(), NULL, &FTGInfo.wch, 1, NULL);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (FTInfo->params->alpha>1)\r\n\t\t\t{\r\n\t\t\t\tFreeTypeDrawBitmap(FTGInfo, *FTGInfo.shadow,\r\n\t\t\t\t\tFTInfo->x + glyph_bitmap->left + FTInfo->sx,\r\n\t\t\t\t\tFTInfo->yTop + FTInfo->yBase - glyph_bitmap->top + FTInfo->sy);\t//画阴影\r\n\t\t\t\tFTInfo->params->alpha = 1;\r\n\t\t\t}\r\n\t\t\tif (!FreeTypeDrawBitmap(FTGInfo, *FTGInfo.solid,\r\n\t\t\t\tFTInfo->x + glyph_bitmap->left,\r\n\t\t\t\tFTInfo->yTop + FTInfo->yBase - glyph_bitmap->top))\t//画文字\r\n\t\t\t{\r\n\t\t\t\t// fallback to GDI when fail to draw with FT\r\n\t\t\t\tORIG_ExtTextOutW(FTInfo->hdc, FTInfo->x, FTInfo->yTop, FTInfo->GetETO(), NULL, &FTGInfo.wch, 1, NULL);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t}\r\n\tFTInfo->params->alpha = nOldAlpha;\r\n\treturn TRUE;\r\n}\r\n\r\nint IsColorDark(DWORD Color, double Gamma)\r\n{\r\n\t//return (GetRValue(Color)*0.299 + GetGValue(Color)*0.587 + GetBValue(Color)*0.114);\t//原始算法\r\n\t//===============================================================\r\n\t//采用Photoshop sRGB的RGB->Lab算法进行换算，L为色彩视觉亮度\r\n\t//感谢 西安理工大学 贾婉丽 的分析\r\n\t//===============================================================\r\n\tstatic double s_multipler = 116 / pow(100, (double)1.0 / 3.0);\t//预计算常数,强制使用double版本\r\n\tdouble* RGBTable = s_AlphaBlendTable.GetRGBTable();\t//获得显示器转换表\r\n\tdouble ret = pow(23.9746*RGBTable[GetRValue(Color)] + 73.0653*RGBTable[GetGValue(Color)] + 6.13799*RGBTable[GetBValue(Color)], 1.0 / 3.0)*s_multipler - 16;\r\n\treturn max(int(ret + 0.499), 0);\r\n\r\n\t/*double r = GetRValue(Color)/255.0;\r\n\tdouble g = GetGValue(Color)/255.0;\r\n\tdouble b = GetBValue(Color)/255.0;\r\n\tdouble v;\r\n\tdouble m;\r\n\tdouble vm;\r\n\tdouble r2, g2, b2;\r\n\r\n\tdouble h = 0; // default to black\r\n\tdouble s = 0;\r\n\tdouble l = 0;\r\n\tv = Max(r,g);\r\n\tv = Max(v,b);\r\n\tm = Min(r,g);\r\n\tm = Min(m,b);\r\n\tl = (m + v) / 2.0;\r\n\tif (l <= 0.0)\r\n\t{\r\n\treturn 0;\r\n\t}\r\n\tvm = v - m;\r\n\ts = vm;\r\n\tif (s > 0.0)\r\n\t{\r\n\ts /= (l <= 0.5) ? (v + m ) : (2.0 - v - m) ;\r\n\t}\r\n\telse\r\n\t{\r\n\treturn l;\r\n\t}\r\n\tr2 = (v - r) / vm;\r\n\tg2 = (v - g) / vm;\r\n\tb2 = (v - b) / vm;\r\n\tif (r == v)\r\n\t{\r\n\th = (g == m ? 5.0 + b2 : 1.0 - g2);\r\n\t}\r\n\telse if (g == v)\r\n\t{\r\n\th = (b == m ? 1.0 + r2 : 3.0 - b2);\r\n\t}\r\n\telse\r\n\t{\r\n\th = (r == m ? 3.0 + g2 : 5.0 - r2);\r\n\t}\r\n\th /= 6.0;\r\n\treturn l;*/\r\n}\r\n\r\n/*\r\nBOOL GetColorDiff(DWORD Color)\r\n{\r\n/ *const CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\nDWORD ShadowColorD = pSettings->ShadowDarkColor();\r\nDWORD ShadowColorL = pSettings->ShadowLightColor();\r\nDWORD ColorDiffD = RGBA(abs(GetRValue(Color)-GetRValue(ShadowColorD)),abs(GetGValue(Color)-GetGValue(ShadowColorD)),abs(GetBValue(Color)-GetBValue(ShadowColorD)),0);\r\nDWORD ColorDiffL = RGBA(abs(GetRValue(Color)-GetRValue(ShadowColorL)),abs(GetGValue(Color)-GetGValue(ShadowColorL)),abs(GetBValue(Color)-GetBValue(ShadowColorL)),0);\r\ndouble cd = IsColorDark(ColorDiffD), cl = IsColorDark(ColorDiffL);\r\nreturn cd==cl ? IsColorDark(Color)<0.7 : cd>cl;* /\r\n}*/\r\n\r\nBOOL FreeTypeTextOut(\r\n\tconst HDC hdc,     // デバイスコンテキストのハンドル\r\n\tCBitmapCache& cache,\r\n\tLPCWSTR lpString,  // 文字列\r\n\tint cbString,      // 文字数\r\n\tFreeTypeDrawInfo& FTInfo,\r\n\tFT_Referenced_Glyph * Glyphs,\r\n\tFT_DRAW_STATE* drState\r\n)\r\n{\r\n\tif (cbString <= 0 || lpString == NULL)\r\n\t\treturn FALSE;\r\n\tCAlphaBlendColor * solid = NULL;\r\n\tCAlphaBlendColor * shadow = NULL;\r\n\r\n\t//CCriticalSectionLock __lock;\r\n\r\n\tFT_Face freetype_face = FTInfo.freetype_face;\r\n\tconst LOGFONT& lf = FTInfo.LogFont();\r\n\r\n\tFTInfo.x = -FTInfo.xBase;\r\n\tFTInfo.yTop = 0;\r\n\r\n\tconst TEXTMETRIC& tm = FTInfo.params->otm->otmTextMetrics;\r\n\tFTInfo.yBase = tm.tmAscent;\r\n\r\n\t//===============计算颜色缓存======================\r\n\r\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\tint lightdiff, darkdiff, bDarkColor = 0, ShadowColor = 0;\r\n\tif (FTInfo.params->alpha != 1)\r\n\t{\r\n\t\tfloat Gamma = pSettings->GammaValue();\r\n\t\tbDarkColor = IsColorDark(FTInfo.params->color, Gamma);\r\n\t\tint diff = max(darkdiff = abs(IsColorDark(pSettings->ShadowDarkColor(), Gamma) - bDarkColor), lightdiff = abs(IsColorDark(pSettings->ShadowLightColor(), Gamma) - bDarkColor));\r\n\t\tShadowColor = lightdiff <= darkdiff ? pSettings->ShadowDarkColor() : pSettings->ShadowLightColor();\r\n\t\tbDarkColor = lightdiff <= darkdiff;\r\n\t\tif (/*diff<10 || abs(lightdiff-darkdiff)<20 &&*/ pSettings->ShadowDarkColor() == pSettings->ShadowLightColor())\r\n\t\t{\r\n\t\t\t//无视底色问题，强制开启阴影\r\n\t\t\tFTInfo.params->alphatuner = 1;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tdiff = abs(lightdiff - darkdiff);\r\n\t\t\tif (diff<10)\r\n\t\t\t\tFTInfo.params->alpha = 1;\r\n\t\t\telse\r\n\t\t\t\tFTInfo.params->alphatuner = max(1, 100 / diff);\t//根据色差调整阴影浓度\r\n\t\t}\r\n\t}\r\n\tchar mode = (*Glyphs) ? FT_BitmapGlyph((*Glyphs)->ft_glyph)->bitmap.pixel_mode : FT_PIXEL_MODE_LCD;\r\n\tswitch (mode) {\r\n\tcase FT_PIXEL_MODE_MONO:\r\n\t\treturn false;\r\n\t\t//break;\r\n\tcase FT_PIXEL_MODE_LCD:\r\n\t\tsolid = new CAlphaBlendColor(FTInfo.params->color, 1, true, true, true);\r\n\t\tshadow = new CAlphaBlendColor( /*FTInfo.params->color*/ShadowColor, FTInfo.params->alpha, true, bDarkColor, true);\r\n\t\tbreak;\r\n\tcase FT_PIXEL_MODE_LCD_V:\r\n\t\tsolid = new CAlphaBlendColor(FTInfo.params->color, 1, true, true, false);\r\n\t\tshadow = new CAlphaBlendColor( /*FTInfo.params->color*/ShadowColor, FTInfo.params->alpha, true, bDarkColor, false);\r\n\t\tbreak;\r\n\tcase FT_PIXEL_MODE_GRAY:\r\n\t\tsolid = new CAlphaBlendColor(FTInfo.params->color, 1, false, true, true);\r\n\t\tshadow = new CAlphaBlendColor( /*FTInfo.params->color*/ShadowColor, FTInfo.params->alpha, false, bDarkColor, true);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tsolid = new CAlphaBlendColor(FTInfo.params->color, 1, pSettings->LcdFilter(), true);\r\n\t\tshadow = new CAlphaBlendColor( /*FTInfo.params->color*/ShadowColor, FTInfo.params->alpha, pSettings->LcdFilter(), bDarkColor);\r\n\t\tbreak;\r\n\t}\r\n\r\n\t//计算下划线或删除线的信息\r\n\tint decorationInfo_height;\r\n\tint decorationInfo_thickness;\r\n\tOUTLINETEXTMETRIC &decorationInfo_otm = *FTInfo.params->otm;\r\n\tif (lf.lfUnderline || lf.lfStrikeOut) {\r\n\r\n\t\tif (lf.lfUnderline) {\r\n\t\t\tswitch (pSettings->FontLoader()) {\r\n\t\t\tcase SETTING_FONTLOADER_FREETYPE:\r\n\t\t\t\tdecorationInfo_height = decorationInfo_otm.otmTextMetrics.tmHeight; //FT_PosToInt(freetype_face->size->metrics.height);\r\n\t\t\t\tdecorationInfo_thickness =\r\n\t\t\t\t\tMulDiv(freetype_face->underline_thickness,\r\n\t\t\t\t\t\tFTInfo.font_type.height/*freetype_face->size->metrics.y_ppem*/,\r\n\t\t\t\t\t\tfreetype_face->units_per_EM);\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_FONTLOADER_WIN32:\r\n\t\t\t\tdecorationInfo_height = decorationInfo_otm.otmTextMetrics.tmHeight;\r\n\t\t\t\tdecorationInfo_thickness = decorationInfo_otm.otmsUnderscoreSize;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (lf.lfStrikeOut) {\r\n\t\t\tswitch (pSettings->FontLoader()) {\r\n\t\t\tcase SETTING_FONTLOADER_FREETYPE:\r\n\t\t\t\tdecorationInfo_thickness =\r\n\t\t\t\t\tMulDiv(freetype_face->underline_thickness,\r\n\t\t\t\t\t\tFTInfo.font_type.height,// freetype_face->size->metrics.y_ppem,\r\n\t\t\t\t\t\tfreetype_face->units_per_EM);\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_FONTLOADER_WIN32:\r\n\t\t\t\tdecorationInfo_thickness = decorationInfo_otm.otmsStrikeoutSize;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t//===============计算完成==========================\r\n\r\n\tFreeTypeGlyphInfo FTGInfo = { &FTInfo, 0, 0, 0, solid, shadow, pSettings->InvertColor() };\r\n\tfor (int i = 0; i<cbString; ++i, ++lpString)\r\n\t{\r\n\t\tWCHAR wch = *lpString;\r\n\t\tif (Glyphs[i])\t// paint text with FreeType\r\n\t\t{\r\n\t\t\tFTGInfo.wch = wch;\r\n\t\t\tFTGInfo.FTGlyph = (FT_BitmapGlyph)(Glyphs[i]->ft_glyph);\r\n\t\t\tFTGInfo.AAMode = FTInfo.AAModes[i];\r\n\t\t\tTextOutCallback(FTGInfo);\r\n\t\t}\r\n\t\telse // paint text(bitmap) with gdi\r\n\t\t{\r\n\t\t\tint j = i;\r\n\t\t\tFT_DRAW_STATE st = drState[i];\r\n\t\t\twhile (++j<cbString && !Glyphs[j] && drState[j] == st) {};\r\n\t\t\tif (st == FT_DRAW_EMBEDDED_BITMAP)\r\n\t\t\t\tORIG_ExtTextOutW(hdc, FTInfo.x, FTInfo.yTop, FTInfo.GetETO() & ETO_IGNORELANGUAGE, NULL, lpString, j - i, FTInfo.lpDx ? FTInfo.lpDx + i : NULL);\r\n\t\t\telse\r\n\t\t\t\tORIG_ExtTextOutW(hdc, FTInfo.x, FTInfo.yTop, FTInfo.GetETO(), NULL, lpString, j - i, FTInfo.lpDx ? FTInfo.lpDx + i : NULL);\r\n\t\t\tlpString += --j - i;\r\n\t\t\ti = j;\r\n\t\t}\r\n\t\t//draw underline or strikeline separated\r\n\r\n\t\tif (lf.lfUnderline) {\r\n\t\t\tint yPos = FTInfo.yBase - decorationInfo_otm.otmsUnderscorePosition + FTInfo.yTop;\r\n\t\t\tif (yPos >= decorationInfo_height) {\r\n\t\t\t\tyPos = decorationInfo_height - 1;\r\n\t\t\t}\r\n\t\t\tcache.DrawHorizontalLine(FTInfo.x, yPos, FTInfo.Dx[i], FTInfo.Color(), decorationInfo_thickness);\r\n\t\t}\r\n\r\n\t\tif (lf.lfStrikeOut) {\r\n\t\t\tint yPos = FTInfo.yBase - decorationInfo_otm.otmsStrikeoutPosition + FTInfo.yTop;\r\n\t\t\tcache.DrawHorizontalLine(FTInfo.x, yPos, FTInfo.Dx[i], FTInfo.Color(), decorationInfo_thickness);\r\n\t\t}\r\n\r\n\r\n\t\t//draw line end.\r\n\t\tFTInfo.x = FTInfo.Dx[i];\r\n\t\tFTInfo.yTop = FTInfo.Dy[i];\r\n\t}\r\n\r\n\tif (shadow)\r\n\t\tdelete shadow;\r\n\tif (solid)\r\n\t\tdelete solid;\r\n\r\n\tint x = FTInfo.x;\r\n\tint y = FTInfo.yBase;\r\n\r\n\t// 下線を(あれば)引く\r\n\r\n\t// \tif(lf.lfUnderline || lf.lfStrikeOut) {\r\n\t// \t\tOUTLINETEXTMETRIC &otm = *FTInfo.params->otm;\r\n\t// \t\tif(lf.lfUnderline){\r\n\t// \t\t\tint yPos = 0; //下線の位置\r\n\t// \t\t\tint height = 0;\r\n\t// \t\t\tint thickness = 0; // 適当な太さ\r\n\t// \t\t\tswitch (pSettings->FontLoader()) {\r\n\t// \t\t\tcase SETTING_FONTLOADER_FREETYPE:\r\n\t// \t\t\t\tyPos = y - otm.otmsUnderscorePosition;\r\n\t// \t\t\t\theight = otm.otmTextMetrics.tmHeight; //FT_PosToInt(freetype_face->size->metrics.height);\r\n\t// \t\t\t\tthickness =\r\n\t// \t\t\t\t\tMulDiv(freetype_face->underline_thickness,\r\n\t// \t\t\t\t\t\tFTInfo.font_type.height/*freetype_face->size->metrics.y_ppem*/,\r\n\t// \t\t\t\t\t\tfreetype_face->units_per_EM);\r\n\t// \t\t\t\tbreak;\r\n\t// \t\t\tcase SETTING_FONTLOADER_WIN32:\r\n\t// \t\t\t\tyPos = y - otm.otmsUnderscorePosition;\r\n\t// \t\t\t\theight = otm.otmTextMetrics.tmHeight;\r\n\t// \t\t\t\tthickness = otm.otmsUnderscoreSize;\r\n\t// \t\t\t\tbreak;\r\n\t// \t\t\t}\r\n\t// \t\t\tif (yPos >= height) {\r\n\t// \t\t\t\tyPos = height - 1;\r\n\t// \t\t\t}\r\n\t// \t\t\tcache.DrawHorizontalLine(0, yPos, x, FTInfo.Color(), thickness);\r\n\t// \t\t}\r\n\t// \r\n\t// \t\tif(lf.lfStrikeOut){\r\n\t// \t\t\tint yPos = y - otm.otmsStrikeoutPosition; \r\n\t// \t\t\tint thickness = 0; \r\n\t// \t\t\tswitch (pSettings->FontLoader()) {\r\n\t// \t\t\tcase SETTING_FONTLOADER_FREETYPE:\r\n\t// \t\t\t\tthickness =\r\n\t// \t\t\t\t\tMulDiv(freetype_face->underline_thickness,\r\n\t// \t\t\t\t\t\tFTInfo.font_type.height,// freetype_face->size->metrics.y_ppem,\r\n\t// \t\t\t\t\t\tfreetype_face->units_per_EM);\r\n\t// \t\t\t\tbreak;\r\n\t// \t\t\tcase SETTING_FONTLOADER_WIN32:\r\n\t// \t\t\t\tthickness = otm.otmsStrikeoutSize;\r\n\t// \t\t\t\tbreak;\r\n\t// \t\t\t}\r\n\t// \t\t\tcache.DrawHorizontalLine(0, yPos, x, FTInfo.Color(), thickness);\r\n\t// \t\t}\r\n\t// \t}\r\n\treturn TRUE;\r\n}\r\n\r\nBOOL FreeTypeGetGlyph(\t//获得所有图形和需要的宽度\r\n\tFreeTypeDrawInfo& FTInfo,\r\n\tLPCWSTR lpString,\r\n\tint cbString,\r\n\tint& width,\r\n\tFT_Referenced_Glyph* Glyphs,\r\n\tFT_DRAW_STATE* drState\r\n)\r\n{\r\n\tCOwnedCriticalSectionLock __lock(1);\r\n\t{\r\n\t\t//CCriticalSectionLock __lock;\r\n\t\tif (!FreeTypePrepare(FTInfo))\r\n\t\t\treturn false;\r\n\t}\r\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\tBOOL nRet = false;\r\n\tswitch (pSettings->FontLoader()) {\r\n\tcase SETTING_FONTLOADER_FREETYPE:\r\n\t\tnRet = ForEachGetGlyphFT(FTInfo, lpString, cbString, Glyphs, drState);\r\n\t\tbreak;\r\n\tcase SETTING_FONTLOADER_WIN32:\r\n\t\tnRet = ForEachGetGlyphGGO(FTInfo, lpString, cbString, Glyphs, drState);\r\n\t\tbreak;\r\n\t}\r\n\twidth = FTInfo.px;\t//获得了宽度\r\n\treturn nRet;\r\n}\r\n\r\n\r\n\r\nvoid VertFinalizer(void *object) {\r\n\tFT_Face face = (FT_Face)object;\r\n\tft2vert_final(face, (struct ft2vert_st *)face->generic.data);\r\n}\r\n//\r\n// グリフをIVSで指定された字形をサポートするかどうか調べ、\r\n// サポートしている場合はグリフを置換する。\r\n// サポートしていなければ何もしない。\r\n//\r\n/*\r\nvoid FreeTypeSubstGlyph(const HDC hdc,\r\nconst WORD vsindex,\r\nconst int baseChar,\r\nint cChars,\r\nSCRIPT_ANALYSIS* psa,\r\nWORD* pwOutGlyphs,\r\nWORD* pwLogClust,\r\nSCRIPT_VISATTR* psva,\r\nint* pcGlyphs\r\n)\r\n{\r\nCThreadLocalInfo* pTLInfo = g_TLInfo.GetPtr();\r\nCBitmapCache& cache = pTLInfo->BitmapCache();\r\nCCriticalSectionLock __lock;\r\n\r\nLOGFONT lf;\r\nif (!GetLogFontFromDC(hdc, lf))\r\nreturn;\r\n\r\nFREETYPE_PARAMS params(0, hdc);\r\nFreeTypeDrawInfo FTInfo(params, hdc, &lf, &cache);\r\nif(!FreeTypePrepare(FTInfo))\r\nreturn;\r\n\r\nFT_UInt glyph_index = ft2_subst_uvs(FTInfo.freetype_face, pwOutGlyphs[*pcGlyphs - 1], vsindex, baseChar);\r\nTRACE(_T(\"FreeTypeSubstGlyph: %04X->%04X\\n\"), pwOutGlyphs[*pcGlyphs - 1], glyph_index);\r\nif (glyph_index) {\r\npwOutGlyphs[*pcGlyphs - 1] = glyph_index; // 置換を実行\r\n// ASCII空白のグリフを取得\r\nglyph_index = FTC_CMapCache_Lookup(\r\ncmap_cache,\r\nFTInfo.font_type.face_id,\r\nFTInfo.cmap_index,\r\n' ');\r\n// ゼロ幅グリフにする\r\npwOutGlyphs[*pcGlyphs] = glyph_index;\r\npsva[*pcGlyphs].uJustification = SCRIPT_JUSTIFY_NONE;\r\npsva[*pcGlyphs].fClusterStart = 0;\r\npsva[*pcGlyphs].fDiacritic = 0;\r\npsva[*pcGlyphs].fZeroWidth = 1;\r\npsva[*pcGlyphs].fReserved = 0;\r\npsva[*pcGlyphs].fShapeReserved = 0;\r\n} else {\r\n// フォントは指定された字形を持たない。IVSのグリフを取得\r\nglyph_index = FTC_CMapCache_Lookup(\r\ncmap_cache,\r\nFTInfo.font_type.face_id,\r\nFTInfo.cmap_index,\r\nvsindex + 0xE0100);\r\n// IVSをサポートしていないフォントはIVSのグリフを持っている可能性もほとんどない。\r\n// missing glyphを返すとフォールバックされてしまうため確実に持っていそうなグリフを拾う\r\nif (!glyph_index)\r\nglyph_index = FTC_CMapCache_Lookup(\r\ncmap_cache,\r\nFTInfo.font_type.face_id,\r\nFTInfo.cmap_index,\r\n0x30FB);\r\npwOutGlyphs[*pcGlyphs] = glyph_index;\r\npsva[*pcGlyphs] = psva[*pcGlyphs - 1];\r\npsva[*pcGlyphs].fClusterStart = 0;\r\n}\r\npwLogClust[cChars - 2] = *pcGlyphs;\r\npwLogClust[cChars - 1] = *pcGlyphs;\r\n++*pcGlyphs;\r\n}*/\r\n\r\n\r\nFT_Error face_requester(\r\n\tFTC_FaceID face_id,\r\n\tFT_Library /*library*/,\r\n\tFT_Pointer /*request_data*/,\r\n\tFT_Face* aface)\r\n{\r\n\tFT_Error ret = FT_Err_Ok;\r\n\tFT_Face face;\r\n\r\n\tFreeTypeFontInfo* pfi = g_pFTEngine->FindFont((int)face_id);\r\n\tAssert(pfi);\r\n\tif (!pfi) {\r\n\t\treturn FT_Err_Invalid_Argument;\r\n\t}\r\n\tLPCTSTR fontname = pfi->GetName();\r\n\r\n\t// 名称を指定してフォントを取得\r\n\tFreeTypeSysFontData* pData = FreeTypeSysFontData::CreateInstance(fontname, pfi->GetFontWeight(), pfi->IsItalic());\r\n\tif (pData == NULL) {\r\n\t\treturn FT_Err_Cannot_Open_Resource;\r\n\t}\r\n\r\n\tface = pData->GetFace();\r\n\tif (!face)\r\n\t\treturn 0x6;\t//something wrong with the freetype that we aren't clear yet.\r\n\t\t\t\t\t//Assert(face != NULL);\r\n\r\n\t\t\t\t\t// Charmapを設定しておく\r\n\tret = FT_Select_Charmap(face, FT_ENCODING_UNICODE);\r\n\tif (ret != FT_Err_Ok)\r\n\t\tret = FT_Select_Charmap(face, FT_ENCODING_MS_SYMBOL);\r\n\t/*\r\n\tif(ret != FT_Err_Ok)\r\n\tret = FT_Select_Charmap(face, FT_ENCODING_SJIS);\r\n\tif(ret != FT_Err_Ok)\r\n\tret = FT_Select_Charmap(face, FT_ENCODING_GB2312);\r\n\tif(ret != FT_Err_Ok)\r\n\tret = FT_Select_Charmap(face, FT_ENCODING_BIG5);\r\n\tif(ret != FT_Err_Ok)\r\n\tret = FT_Select_Charmap(face, FT_ENCODING_WANSUNG);\r\n\tif(ret != FT_Err_Ok)\r\n\tret = FT_Select_Charmap(face, FT_ENCODING_JOHAB);\r\n\tif(ret != FT_Err_Ok)\r\n\tret = FT_Select_Charmap(face, FT_ENCODING_ADOBE_STANDARD);\r\n\tif(ret != FT_Err_Ok)\r\n\tret = FT_Select_Charmap(face, FT_ENCODING _ADOBE_EXPERT);\r\n\tif(ret != FT_Err_Ok)\r\n\tret = FT_Select_Charmap(face, FT_ENCODING_ADOBE_CUSTOM);\r\n\tif(ret != FT_Err_Ok)\r\n\tret = FT_Select_Charmap(face, FT_ENCODING_ADOBE_LATIN_1);\r\n\tif(ret != FT_Err_Ok)\r\n\tret = FT_Select_Charmap(face, FT_ENCODING_OLD_LATIN_2);\r\n\tif(ret != FT_Err_Ok)\r\n\tret = FT_Select_Charmap(face, FT_ENCODING_APPLE_ROMAN); */\r\n\r\n\tif (ret != FT_Err_Ok)\r\n\t{\r\n\t\tFT_Done_Face(face);\r\n\t\treturn ret;\r\n\t}\r\n\tstruct ft2vert_st *vert = ft2vert_init(face);\r\n\tface->generic.data = vert;\r\n\tface->generic.finalizer = VertFinalizer;\r\n\r\n\t*aface = face;\r\n\treturn 0;\r\n}\r\n\r\n\r\n/*\r\nDWORD FreeTypeGetVersion()\r\n{\r\nint major = 0, minor = 0, patch = 0;\r\nFT_Library_Version(freetype_library, &major, &minor, &patch);\r\n//面倒なのでRGBマクロ使用\r\nreturn RGB(major, minor, patch);\r\n}*/\r\n\r\n\r\n//新太字アルゴリズム\r\nFT_Error New_FT_Outline_Embolden(FT_Outline*  outline, FT_Pos str_h, FT_Pos str_v, FT_Int font_size)\r\n{\r\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\tint orientation = 0;\r\n\tswitch (pSettings->BolderMode()) {\r\n\tcase 1:\r\n\t\treturn FT_Outline_EmboldenXY(outline, str_h, 0);\r\n\r\n\tcase 2:\r\n\t\treturn FT_Outline_Embolden(outline, str_h);\r\n\r\n\tdefault:\r\n\t{\r\n\t\tif (!outline) return FT_Err_Invalid_Argument;\r\n\t\t//orientation = FT_Outline_Get_Orientation( outline );\r\n\t\t//if ( orientation == FT_ORIENTATION_NONE )\r\n\t\t//\tif ( outline->n_contours ) return FT_Err_Invalid_Argument;\r\n\t\t/*\r\n\t\tif (font_size>FT_BOLD_LOW || str_h<16)\r\n\t\tVert_FT_Outline_Embolden( outline, str_v );\r\n\t\tOld_FT_Outline_Embolden( outline, str_h );*/\r\n\t\tif (font_size<FT_BOLD_LOW && str_h>32)\r\n\t\t{\r\n\t\t\tFT_Outline_EmboldenXY(outline, str_h, Min(long(32), str_v));\r\n\t\t}\r\n\t\telse\r\n\t\t\tFT_Outline_Embolden(outline, str_h);\r\n\t\treturn FT_Err_Ok;\r\n\t}\r\n\t}\r\n}\r\n\r\n//横方向だけ太らせるFT_Outline_Embolden\r\nFT_Error Old_FT_Outline_Embolden(FT_Outline*  outline, FT_Pos strength)\r\n{\r\n\tFT_Vector*\tpoints;\r\n\tFT_Vector\tv_prev, v_first, v_next, v_cur;\r\n\tFT_Angle\trotate, angle_in, angle_out;\r\n\tFT_Int\t\tc, n, first;\r\n\tFT_Int\t\torientation;\r\n\r\n\tif (!outline)\r\n\t\treturn FT_Err_Invalid_Argument;\r\n\r\n\tstrength /= 2;\r\n\tif (strength == 0)\r\n\t\treturn FT_Err_Ok;\r\n\r\n\torientation = FT_Outline_Get_Orientation(outline);\r\n\tif (orientation == FT_ORIENTATION_NONE)\r\n\t{\r\n\t\tif (outline->n_contours)\r\n\t\t\treturn FT_Err_Invalid_Argument;\r\n\t\telse\r\n\t\t\treturn FT_Err_Ok;\r\n\t}\r\n\r\n\tif (orientation == FT_ORIENTATION_TRUETYPE)\r\n\t\trotate = -FT_ANGLE_PI2;\r\n\telse\r\n\t\trotate = FT_ANGLE_PI2;\r\n\r\n\tpoints = outline->points;\r\n\r\n\tfirst = 0;\r\n\tfor (c = 0; c < outline->n_contours; c++)\r\n\t{\r\n\t\tint  last = outline->contours[c];\r\n\r\n\t\tv_first = points[first];\r\n\t\tv_prev = points[last];\r\n\t\tv_cur = v_first;\r\n\r\n\t\tfor (n = first; n <= last; n++)\r\n\t\t{\r\n\t\t\tFT_Vector\tin, out;\r\n\t\t\tFT_Angle\tangle_diff;\r\n\t\t\tFT_Pos\t\td;\r\n\t\t\tFT_Fixed\tscale;\r\n\r\n\t\t\tif (n < last)\r\n\t\t\t\tv_next = points[n + 1];\r\n\t\t\telse\r\n\t\t\t\tv_next = v_first;\r\n\r\n\t\t\t/* compute the in and out vectors */\r\n\t\t\tin.x = v_cur.x - v_prev.x;\r\n\t\t\tin.y = v_cur.y - v_prev.y;\r\n\r\n\t\t\tout.x = v_next.x - v_cur.x;\r\n\t\t\tout.y = v_next.y - v_cur.y;\r\n\r\n\t\t\tangle_in = FT_Atan2(in.x, in.y);\r\n\t\t\tangle_out = FT_Atan2(out.x, out.y);\r\n\t\t\tangle_diff = FT_Angle_Diff(angle_in, angle_out);\r\n\t\t\tscale = FT_Cos(angle_diff / 2);\r\n\r\n\t\t\tif (scale < 0x4000L && scale > -0x4000L)\r\n\t\t\t\tin.x = in.y = 0;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\td = FT_DivFix(strength, scale);\r\n\r\n\t\t\t\tFT_Vector_From_Polar(&in, d, angle_in + angle_diff / 2 - rotate);\r\n\t\t\t}\r\n\r\n\t\t\toutline->points[n].x = v_cur.x + strength + in.x;\r\n\t\t\t//↓これをコメントアウトしただけ\r\n\t\t\t//outline->points[n].y = v_cur.y + strength + in.y;\r\n\r\n\t\t\tv_prev = v_cur;\r\n\t\t\tv_cur = v_next;\r\n\t\t}\r\n\r\n\t\tfirst = last + 1;\r\n\t}\r\n\r\n\treturn FT_Err_Ok;\r\n}\r\n\r\n//こっちは縦方向\r\nFT_Error Vert_FT_Outline_Embolden(FT_Outline*  outline, FT_Pos strength)\r\n{\r\n\tFT_Vector*\tpoints;\r\n\tFT_Vector\tv_prev, v_first, v_next, v_cur;\r\n\tFT_Angle\trotate, angle_in, angle_out;\r\n\tFT_Int\t\tc, n, first;\r\n\tFT_Int\t\torientation;\r\n\r\n\tif (!outline)\r\n\t\treturn FT_Err_Invalid_Argument;\r\n\r\n\tstrength /= 2;\r\n\tif (strength == 0)\r\n\t\treturn FT_Err_Ok;\r\n\r\n\torientation = FT_Outline_Get_Orientation(outline);\r\n\tif (orientation == FT_ORIENTATION_NONE)\r\n\t{\r\n\t\tif (outline->n_contours)\r\n\t\t\treturn FT_Err_Invalid_Argument;\r\n\t\telse\r\n\t\t\treturn FT_Err_Ok;\r\n\t}\r\n\r\n\tif (orientation == FT_ORIENTATION_TRUETYPE)\r\n\t\trotate = -FT_ANGLE_PI2;\r\n\telse\r\n\t\trotate = FT_ANGLE_PI2;\r\n\r\n\tpoints = outline->points;\r\n\r\n\tfirst = 0;\r\n\tfor (c = 0; c < outline->n_contours; c++)\r\n\t{\r\n\t\tint  last = outline->contours[c];\r\n\r\n\t\tv_first = points[first];\r\n\t\tv_prev = points[last];\r\n\t\tv_cur = v_first;\r\n\r\n\t\tfor (n = first; n <= last; n++)\r\n\t\t{\r\n\t\t\tFT_Vector\tin, out;\r\n\t\t\tFT_Angle\tangle_diff;\r\n\t\t\tFT_Pos\t\td;\r\n\t\t\tFT_Fixed\tscale;\r\n\r\n\t\t\tif (n < last)\r\n\t\t\t\tv_next = points[n + 1];\r\n\t\t\telse\r\n\t\t\t\tv_next = v_first;\r\n\r\n\t\t\t/* compute the in and out vectors */\r\n\t\t\tin.x = v_cur.x - v_prev.x;\r\n\t\t\tin.y = v_cur.y - v_prev.y;\r\n\r\n\t\t\tout.x = v_next.x - v_cur.x;\r\n\t\t\tout.y = v_next.y - v_cur.y;\r\n\r\n\t\t\tangle_in = FT_Atan2(in.x, in.y);\r\n\t\t\tangle_out = FT_Atan2(out.x, out.y);\r\n\t\t\tangle_diff = FT_Angle_Diff(angle_in, angle_out);\r\n\t\t\tscale = FT_Cos(angle_diff / 2);\r\n\r\n\t\t\tif (scale < 0x4000L && scale > -0x4000L)\r\n\t\t\t\tin.x = in.y = 0;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\td = FT_DivFix(strength, scale);\r\n\r\n\t\t\t\tFT_Vector_From_Polar(&in, d, angle_in + angle_diff / 2 - rotate);\r\n\t\t\t}\r\n\r\n\t\t\t//outline->points[n].x = v_cur.x + strength + in.x;\r\n\t\t\t//↑これをコメントアウトしただけ\r\n\t\t\toutline->points[n].y = v_cur.y + strength + in.y;\r\n\r\n\t\t\tv_prev = v_cur;\r\n\t\t\tv_cur = v_next;\r\n\t\t}\r\n\r\n\t\tfirst = last + 1;\r\n\t}\r\n\r\n\treturn FT_Err_Ok;\r\n}\r\n\r\nBOOL FontLInit(void) {\r\n\tCCriticalSectionLock __lock;\r\n\r\n\tif (FT_Init_FreeType(&freetype_library)) {\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n#ifdef INFINALITY\r\n#define TT_INTERPRETER_VERSION_35  35\r\n#define TT_INTERPRETER_VERSION_38  38\r\n#define TT_INTERPRETER_VERSION_40  40\r\n\tFT_UInt     interpreter_version = TT_INTERPRETER_VERSION_38;\r\n\tFT_Property_Set(freetype_library, \"truetype\", \"interpreter-version\", &interpreter_version);\r\n#endif\r\n\r\n\t//enable stem darkening feature introduced in 2.6.2\r\n\tFT_Bool     no_stem_darkening = FALSE;\r\n\tFT_Property_Set(freetype_library, \"cff\", \"no-stem-darkening\", &no_stem_darkening);\r\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\tif (FTC_Manager_New(freetype_library,\r\n\t\tpSettings->CacheMaxFaces(),\r\n\t\tpSettings->CacheMaxSizes(),\r\n\t\tpSettings->CacheMaxBytes(),\r\n\t\tface_requester, NULL,\r\n\t\t&cache_man))\r\n\t{\r\n\t\tFontLFree();\r\n\t\treturn FALSE;\r\n\t}\r\n\tif (FTC_CMapCache_New(cache_man, &cmap_cache)) {\r\n\t\tFontLFree();\r\n\t\treturn FALSE;\r\n\t}\r\n\tif (FTC_ImageCache_New(cache_man, &image_cache)) {\r\n\t\tFontLFree();\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\t//s_AlphaBlendTable.init();\r\n\ts_AlphaBlendTable.initRGB();\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid FontLFree(void) {\r\n\tCCriticalSectionLock __lock;\r\n\r\n\tif (cache_man != NULL)\r\n\t\tFTC_Manager_Done(cache_man);\r\n\tif (freetype_library != NULL)\r\n\t\tFT_Done_FreeType(freetype_library);\r\n\tcache_man = NULL;\r\n\tfreetype_library = NULL;\r\n}\r\n\r\n//Snowie\r\nvoid RefreshAlphaTable()\r\n{\r\n\ts_AlphaBlendTable.init();\r\n}\r\n"
        },
        {
          "name": "ft.h",
          "type": "blob",
          "size": 10.63671875,
          "content": "#ifndef FT_H\n#define FT_H\n\n#define FTO_MONO\t\t0x0001\n#define FTO_SIZE_ONLY\t0x0002\n\n#define CACHE_SIZE 20\n#define MAX_CACHE_SIZE 1024\n#define CNTRL_UNICODE_PLANE 2\n#define CNTRL_COMPLEX_TEXT 1\n#define CNTRL_ZERO_WIDTH 4\ntypedef char (*COLORCACHE)[3][256][256];\n\n#include \"fteng.h\"\n\nenum FT_DRAW_STATE{\n\tFT_DRAW_NORMAL = 0,\n\tFT_DRAW_EMBEDDED_BITMAP = 1,\n\tFT_DRAW_NOTFOUND = 2\n};\n\nBOOL FontLInit(void);\nvoid FontLFree(void);\n\nCOLORREF GetPaletteColor(HDC hdc, UINT paletteindex);\n\n#define ROUND(x) ((x)>0? int(x+0.5):int(x-0.5))\t// a special round method used by windows\nclass CDCTransformer {\nprivate:\n\tfloat fXZoomFactor, fYZoomFactor;\n\tXFORM m_xfm;\n\tbool bZoomMode;\n\tbool bMirrorX, bMirrorY;\npublic:\n\tCDCTransformer():bMirrorY(false), bMirrorX(false), bZoomMode(false), fXZoomFactor(0), fYZoomFactor(0) {};\n\tvoid init(XFORM& xfm)\n\t{\n\t\tmemcpy(&m_xfm, &xfm, sizeof(XFORM));\n\t\tif (xfm.eM11<0)\n\t\t{\n\t\t\tbMirrorX = true;\n\t\t\tm_xfm.eM11 = -m_xfm.eM11;\n\t\t}\n\t\tif (xfm.eM22<0)\n\t\t{\n\t\t\tbMirrorY = true;\n\t\t\tm_xfm.eM11 = -m_xfm.eM22;\n\t\t}\n\t\tfXZoomFactor = m_xfm.eM11;\n\t\tfYZoomFactor = m_xfm.eM22;\n\t\tm_xfm.eDx=0;\n\t\tm_xfm.eDy=0;\n\t\tbZoomMode = fXZoomFactor==fYZoomFactor;\n\t}\n\tvoid SetSourceOffset(int X, int Y)\n\t{\n\t\tfloat temp = float(X)*m_xfm.eM11+m_xfm.eDx;\n\t\tm_xfm.eDx = temp-(int)temp;\n\t\tif (ROUND(m_xfm.eDx)<0)\t// change negive offset to positive\n\t\t\tm_xfm.eDx+=1;\n\t\ttemp = float(Y)*m_xfm.eM22+m_xfm.eDy;\n\t\tm_xfm.eDy = temp-(int)temp;\n\t\tif (ROUND(m_xfm.eDy)<0)\n\t\t\tm_xfm.eDy+=1;\n\t}\n\tint XInit() {return ROUND(m_xfm.eDx);}\n\tint YInit() {return ROUND(m_xfm.eDy);}\n\tint GetXCeilingIntAB(int X)\n\t{\n\t\treturn ROUND(ROUND((X-m_xfm.eDx)/m_xfm.eM11)*m_xfm.eM11+m_xfm.eDx);\n\t}\n\tint GetYCeilingIntAB(int Y)\n\t{\n\t\treturn ROUND(ROUND((Y-m_xfm.eDy)/m_xfm.eM22)*m_xfm.eM22+m_xfm.eDy);\n\t}\n\t~CDCTransformer() {};\n\tvoid TransformRectAB(const RECT* lpInRect, PRECT lpOutRect)\n\t{\n\t\tlpOutRect->bottom = TransformYCoordinateAB(lpInRect->bottom);\n\t\tlpOutRect->left = TransformXCoordinateAB(lpInRect->left);\n\t\tlpOutRect->right = TransformXCoordinateAB(lpInRect->right);\n\t\tlpOutRect->top = TransformYCoordinateAB(lpInRect->top);\n\t}\n\tvoid TransformRectBA(const RECT* lpInRect, PRECT lpOutRect)\n\t{\n\t\tlpOutRect->bottom = ROUND(lpInRect->bottom/fYZoomFactor);\n\t\tlpOutRect->left = ROUND(lpInRect->left/fXZoomFactor);\n\t\tlpOutRect->right = ROUND(lpInRect->right/fXZoomFactor);\n\t\tlpOutRect->top = ROUND(lpInRect->top/fYZoomFactor);\n\t}\n\tint TransformXAB(int nX)\n\t{\n\t\treturn ROUND(nX*fXZoomFactor);\n\t}\n\tint TransformXCoordinateAB(int nX)\n\t{\n\t\treturn ROUND((float(nX))*fXZoomFactor/*+m_xfm.eDx*/);\n\t}\n\tint TransformXBA(int nX)\n\t{\n\t\treturn ROUND(nX/fXZoomFactor);\n\t}\n\tint TransformXCoordinateBA(int nX)\n\t{\n\t\treturn ROUND((float(nX)/*-m_xfm.eDx*/)/fXZoomFactor);\n\t}\n\tint TransformYAB(int nY)\n\t{\n\t\treturn ROUND(nY*fYZoomFactor);\n\t}\n\tint TransformYCoordinateAB(int nY)\n\t{\n\t\treturn ROUND((float(nY))*fYZoomFactor/*+m_xfm.eDy*/);\n\t}\n\tint TransformYBA(int nY)\n\t{\n\t\treturn ROUND(nY/fYZoomFactor);\n\t}\n\tint TransformYCoordinateBA(int nY)\n\t{\n\t\treturn ROUND((float(nY)/*-m_xfm.eDy*/)/fYZoomFactor);\n\t}\n\tvoid TransformlpDx(const int* lpDx, int* outlpDx, int szDx)\n\t{\n\t\tint LastPos = 0, LPCurPos = 0;\n\t\tdouble fDPLastPos = 0, fDPCurPos = 0;\n\t\tfor (;szDx>0;--szDx)\n\t\t{\n\t\t\tLPCurPos += *lpDx++;\t\t\t\t\t\t// the logical position the letter belongs to\n\t\t\tfDPCurPos = LPCurPos*fXZoomFactor;\t\t\t// the device position the letter belongs to\n\t\t\t*outlpDx = ROUND(fDPCurPos-fDPLastPos);\t\t// the device coord\n\t\t\tfDPLastPos += *outlpDx++;\t\t\t\t\t// the coord after this letter is painted. In order to calculate the pos of the next letter.\n\t\t}\n\t}\n\tbool TransformMode() { return bZoomMode; }\n\tXFORM* GetTransform() { return &m_xfm; }\n\tbool MirrorX() { return bMirrorX; }\n\tbool MirrorY() { return bMirrorY; }\n};\n\nclass ControlIder\n{\nprivate:\n\tchar* unicode;\npublic:\n\tControlIder()\n\t{\n\t\tunicode = new char[0xffff];\n\t\tmemset(unicode, 0, sizeof(char)*0xffff);\t// non-control char by default\n\t\t//memset(unicode, 2, sizeof(char)*32);\n\t\tfor (int i=0;i<0x3000;i++)\n\t\t\tunicode[i]=!!iswcntrl(i);\n\t\tfor (int i=0xa000;i<0xffff;i++)\n\t\t\tunicode[i]=!!iswcntrl(i);\t\t\t// Chinese\n\t\tmemset(&unicode[0xd800],CNTRL_UNICODE_PLANE,sizeof(char)*(0xdfff-0xd800+1));\t\t//unicode plane\n\t\tmemset(&unicode[0x0590],CNTRL_COMPLEX_TEXT,sizeof(char)*(0x05FF-0x0590+1));\t\t//hebrew\n\t\tmemset(&unicode[0x0600],CNTRL_COMPLEX_TEXT,sizeof(char)*(0x06FF-0x0600+1));\t\t//arabic\n\t\tmemset(&unicode[0xFB50],CNTRL_COMPLEX_TEXT,sizeof(char)*(0xFDFF-0xFB50+1));\t\t//Arabic Presentation Forms-A\n\t\tmemset(&unicode[0xFE70],CNTRL_COMPLEX_TEXT,sizeof(char)*(0xFEFF-0xFE70+1));\t\t//Arabic Presentation Forms-B\n\t\tmemset(&unicode[0x0E00],CNTRL_COMPLEX_TEXT,sizeof(char)*(0x0E7F-0x0E00+1));\t\t//thai\n//\t\tunicode[0xa] = 0;\n// \t\tunicode[0xd] = 0;\n// \t\tunicode[0x9] = 0;\n\t\t// Set width for some special control chars. They have zero width, but GetCharABCWidth gives wrong results for them.\n\t}\n\t~ControlIder()\n\t{\n\t\tdelete unicode;\n\t}\n\tvoid setcntrlAttribute(WCHAR wch, int cnType)\n\t{\n\t\tunicode[wch] = cnType;\n\t}\n\tchar myiswcntrl(WCHAR str)\n\t{\n\t\treturn unicode[str];\n\t}\n\tbool myiscomplexscript(LPCWSTR lpString, int cbString)\n\t{\n\t\tfor (;cbString>0;++lpString,--cbString)\n\t\t{\n\t\t\tif (unicode[*lpString]==CNTRL_COMPLEX_TEXT)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstruct FREETYPE_PARAMS\n{\n\tUINT etoOptions;\n\tUINT ftOptions;\n\tint charExtra;\n\tCOLORREF color;\n\tint alpha;\n\tBYTE alphatuner;\n\tLOGFONTW* lplf;\n\tOUTLINETEXTMETRIC* otm;\n\twstring strFamilyName, strFullName;\n\n\tFREETYPE_PARAMS()\n\t{\n\t\tZeroMemory(this, sizeof(*this));\n\t}\n\n\t//FreeTypeTextOut用 (サイズ計算＋文字描画)\n\tFREETYPE_PARAMS(UINT eto, HDC hdc, LOGFONTW* p, OUTLINETEXTMETRIC* lpotm = NULL)\n\t\t: etoOptions(eto)\n\t\t, ftOptions(0)\n\t\t, charExtra(GetTextCharacterExtra(hdc))\n\t\t, color(GetTextColor(hdc))\n\t\t, alpha(0)\n\t\t, lplf(p)\n\t\t, otm(lpotm)\n\t\t, alphatuner(1)\n\t{\n\t\tif ((color>>24)%2 || (color>>28)%2)\n\t\t{\n\t\t\tcolor = GetPaletteColor(hdc, color);\n\t\t}\n\t\tif (otm)\n\t\t{\n\t\t\tstrFamilyName = (LPWSTR)((DWORD_PTR)otm + (DWORD_PTR)otm->otmpFamilyName);\n\t\t\tstrFullName = wstring((LPWSTR)((DWORD_PTR)otm + (DWORD_PTR)otm->otmpFullName));\n\t\t\tstd::wstring strStyleName = wstring((LPWSTR)((DWORD_PTR)otm + (DWORD_PTR)otm->otmpStyleName));\n\n\t\t\tstrFullName = MakeUniqueFontName(strFullName, strFamilyName, strStyleName);\n\t\t\tif (strFamilyName.size() > 0 && strFamilyName.c_str()[0] == L'@')\n\t\t\t\tstrFullName = L'@' + strFullName;\n\t\t}\n\t}\n\n\tbool IsMono() const\n\t{\n\t\treturn (ftOptions & FTO_MONO);\n\t}\n};\n\nclass CGGOKerning : public CMap<DWORD, int>\n{\nprivate:\n\tDWORD makekey(WORD first, WORD second) {\n\t\treturn ((DWORD)first << 16) | second;\n\t}\npublic:\n\tvoid init(HDC hdc)\n\t{\n\t\tDWORD rc;\n\t\trc = GetKerningPairs(hdc, 0, NULL);\n\t\tif (rc <= 0) return;\n\t\tDWORD kpcnt = rc;\n\t\tLPKERNINGPAIR kpp = (LPKERNINGPAIR)calloc(kpcnt, sizeof *kpp);\n\t\tif (!kpp) return;\n\t\trc = GetKerningPairs(hdc, kpcnt, kpp);\n\t\tfor (DWORD i = 0; i < rc; ++i) {\n\t\t\tAdd(makekey(kpp[i].wFirst, kpp[i].wSecond), kpp[i].iKernAmount);\n\t\t}\n\t\tfree(kpp);\n\t}\n\tint get(WORD first, WORD second) {\n\t\tDWORD key = makekey(first, second);\n\t\tint x = FindKey(key);\n\t\treturn (x >= 0) ? GetValueAt(x) : 0;\n\t}\n};\n\n\n//fteng.cpp variables\n// forward declaration\nextern FT_Library     freetype_library;\nextern FTC_Manager    cache_man;\nextern FTC_CMapCache  cmap_cache;\nextern FTC_ImageCache image_cache;\n\nstruct FreeTypeDrawInfo\n{\n\tFT_FaceRec_ dummy_freetype_face;\n\n\t//FreeTypePrepareが設定する\n\tint sx,sy;\n\tFT_Face freetype_face;\n\tFT_Int cmap_index;\n\tFT_Bool useKerning;\n\tFT_Render_Mode render_mode;\n\tFTC_ImageTypeRec font_type;\n\tFTC_ScalerRec scaler;\n\tFreeTypeFontInfo* pfi;\n\tconst CFontSettings* pfs;\n\tFreeTypeFontCache* pftCache;\n\tFTC_FaceID* face_id_list;\n\tHFONT* ggo_font_list;\t// for faster GGO fontlinking\n\tFTC_FaceID face_id_simsun;\n\tFT_Face freetype_face_list[CFontLinkInfo::FONTMAX * 2 + 1];\t// in order to solve italic issues.\n\tint face_id_list_num;\n\tint* Dx;\n\tint* Dy;\n\n\t//呼び出し前に自分で設定する\n\tHDC hdc;\n\tint xBase;\n\tint y;//coord height, calculated by ETO_PDY, 0 if not provided\n\tint x;//coord width, calculated by win32 API\n\tint px;\t//x of paint, the real text width\n\tint yBase;\n\tint yTop;\n\n\tint height; //original width\n\tint width;\n\n\tconst int* lpDx;\n\tCBitmapCache* pCache;\n\tFREETYPE_PARAMS* params;\n\tint* AAModes;\n\n\n\tFreeTypeDrawInfo(FREETYPE_PARAMS& fp, HDC dc, LOGFONTW* lf = NULL, CBitmapCache* ca = NULL, const int* dx = NULL, int cbString =0, int xs=0, int ys = 0)\n\t\t: freetype_face(&dummy_freetype_face), cmap_index(0), useKerning(0)\n\t\t, pfi(NULL), pfs(NULL), pftCache(NULL), face_id_list_num(0), ggo_font_list(NULL)\n\t\t, hdc(dc), x(0), y(0), yBase(0), yTop(0), face_id_simsun(NULL), px(0), xBase(0)\n\t{\n\t\trender_mode = FT_RENDER_MODE_NORMAL;\n\t\tZeroMemory(&scaler, sizeof(scaler));\n\t\tZeroMemory(&font_type, sizeof(font_type));\n\t\tZeroMemory(&face_id_list, sizeof face_id_list);\n\t\t// init face list\n\t\tZeroMemory(&freetype_face_list, sizeof freetype_face_list);\n\t\tlpDx   = dx;\n\t\tpCache = ca;\n\t\tparams = &fp;\n\t\theight = 0;\n\t\twidth = 0;\n\t\tsx = xs;\n\t\tsy = ys;\n\t\tif(lf) params->lplf = lf;\n\t\tmemset(&dummy_freetype_face, 0, sizeof dummy_freetype_face);\n\t\tDx = new int[cbString];\n\t\tDy = new int[cbString];\n\t\tAAModes = new int[cbString];\n\t\tscaler.height = 12;\n\t\tscaler.width = 12;\n\t\tscaler.pixel = 1;\n\t}\n\t~FreeTypeDrawInfo()\n\t{\n\t\tdelete Dx;\n\t\tdelete Dy;\n\t\tdelete[] AAModes;\n\t}\n\n\tconst LOGFONTW& LogFont() const { return *params->lplf; }\n\tCOLORREF Color() const { return params->color; }\n\tUINT GetETO() const { return params->etoOptions; }\n\tbool IsGlyphIndex() const { return !!(params->etoOptions & ETO_GLYPH_INDEX); }\n\tbool IsMono() const { return !!(params->ftOptions & FTO_MONO); }\n\tbool IsSizeOnly() const { return !!(params->ftOptions & FTO_SIZE_ONLY); }\n\tCGGOKerning ggokerning;\n\n\tFT_Face GetFace(int index)\t// get face list\n\t{\n\t\tif (!freetype_face_list[index])\n\t\t{\n\t\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_MANAGER);\n\t\t\tFT_Size font_size;\n\t\t\t//FTC_ScalerRec fscaler={face_id_list[index], 1,1,1,0,0};\n\t\t\tscaler.face_id = face_id_list[index];\n\t\t\tif (FTC_Manager_LookupSize(cache_man, &scaler, &font_size))\n\t\t\t//if (FTC_Manager_LookupFace(cache_man, face_id_list[index], &freetype_face_list[index]))\n\t\t\t\tfreetype_face_list[index] = NULL;\n\t\t\telse {\n\t\t\t\tif (scaler.height == 0)\n\t\t\t\t\treturn font_size->face;\t// return without save, because the scaler is not prepared yet.\n\t\t\t\tfreetype_face_list[index] = font_size->face;\n\t\t\t}\n\n\t\t}\n\t\treturn freetype_face_list[index];\n\t}\n\n#ifdef _DEBUG\n\tvoid Validate()\n\t{\n\t\tAssert(params->lplf);\n\t};\n#endif\n};\n\nBOOL FreeTypeTextOut(\n\tconst HDC hdc,\n\tCBitmapCache& cache,\n\tLPCWSTR lpString,\n\tint cbString,\n\tFreeTypeDrawInfo& FTInfo,\n\tFT_Referenced_Glyph * Glyphs,\n\tFT_DRAW_STATE* drState\n\t);\n\n\nBOOL FreeTypeGetGlyph(\t// Get all the glyphs and widths needed.\n\t\t\t\t\t  FreeTypeDrawInfo& FTInfo,\n\t\t\t\t\t  LPCWSTR lpString,  \n\t\t\t\t\t  int cbString,     \n\t\t\t\t\t  int& width,\n\t\t\t\t\t  FT_Referenced_Glyph* Glyphs,\n\t\t\t\t\t  FT_DRAW_STATE* drState\n\t\t\t\t\t  );\nvoid RefreshAlphaTable();\n\n#endif\n"
        },
        {
          "name": "ft2build.h",
          "type": "blob",
          "size": 2.125,
          "content": "/***************************************************************************/\n/*                                                                         */\n/*  ft2build.h                                                             */\n/*                                                                         */\n/*    FreeType 2 build and setup macros.                                   */\n/*    (Generic version)                                                    */\n/*                                                                         */\n/*  Copyright 1996-2001, 2006 by                                           */\n/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */\n/*                                                                         */\n/*  This file is part of the FreeType project, and may only be used,       */\n/*  modified, and distributed under the terms of the FreeType project      */\n/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */\n/*  this file you indicate that you have read the license and              */\n/*  understand and accept it fully.                                        */\n/*                                                                         */\n/***************************************************************************/\n\n\n  /*************************************************************************/\n  /*                                                                       */\n  /* This file corresponds to the default `ft2build.h' file for            */\n  /* FreeType 2.  It uses the `freetype' include root.                     */\n  /*                                                                       */\n  /* Note that specific platforms might use a different configuration.     */\n  /* See builds/unix/ft2unix.h for an example.                             */\n  /*                                                                       */\n  /*************************************************************************/\n\n\n#ifndef __FT2_BUILD_GENERIC_H__\n#define __FT2_BUILD_GENERIC_H__\n\n#include <config/ftheader.h>\n\n#endif /* __FT2_BUILD_GENERIC_H__ */\n\n\n/* END */\n"
        },
        {
          "name": "ft2vert.c",
          "type": "blob",
          "size": 16.5537109375,
          "content": "/*\n * \"ft2vert.c\"\n * \n * Converter to vertical glyph ID by handling GSUB vrt2/vert feature\n * requires FreeType-2.1.10 or latter\n *\n * (C) 2005 Nobuyuki TSUCHIMURA\n *\n * using such Lookup\n *   ScriptTag == 'kana'\n *   DefaultLangSys or LangSysTag == 'JAN '\n *   FeatureTag == 'vrt2' or 'vert'\n *\n * [reference]\n * http://partners.adobe.com/public/developer/opentype/index_table_formats1.html\n * http://partners.adobe.com/public/developer/opentype/index_table_formats.html\n * http://partners.adobe.com/public/developer/opentype/index_tag9.html#vrt2\n */\n\n//#include \"xdvi-config.h\"\n//#include \"xdvi.h\"\n//#ifdef        USE_ZEIT\n//#include <windows.h>\n#include <ft2build.h>\n#include FT_FREETYPE_H\n#include FT_OPENTYPE_VALIDATE_H\n\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ft2vert.h\"\nconst struct ivs_otft_desc {\n\tint baseChar;\n\tint otft_index;\n} ivs_otft[] = {\n#define OTFT_DEF_BEGIN(index) /**/\n#define OTFT_DEF(baseChar, otft_index) { baseChar, otft_index },\n#define OTFT_DEF_END(count) /**/\n#include \"ivs_otft.h\"\n#undef OTFT_DEF_BEGIN\n#undef OTFT_DEF\n#undef OTFT_DEF_END\n};\nconst int ivs_otft_index[] = {\n#define OTFT_DEF_BEGIN(index) index,\n#define OTFT_DEF(baseChar, otft_index) /**/\n#define OTFT_DEF_END(count) /**/\n#include \"ivs_otft.h\"\n#undef OTFT_DEF_BEGIN\n#undef OTFT_DEF\n#undef OTFT_DEF_END\n};\nconst int ivs_otft_count[] = {\n#define OTFT_DEF_BEGIN(index) /**/\n#define OTFT_DEF(baseChar, otft_index) /**/\n#define OTFT_DEF_END(count) count,\n#include \"ivs_otft.h\"\n#undef OTFT_DEF_BEGIN\n#undef OTFT_DEF\n#undef OTFT_DEF_END\n};\n\n#define TAG_KANA FT_MAKE_TAG('k', 'a', 'n', 'a')\n#define TAG_HANI FT_MAKE_TAG('h', 'a', 'n', 'i')\n#define TAG_JAN  FT_MAKE_TAG('J', 'A', 'N', ' ')\n#define TAG_VERT FT_MAKE_TAG('v', 'e', 'r', 't')\n#define TAG_VRT2 FT_MAKE_TAG('v', 'r', 't', '2')\n#define TAG_JP78 FT_MAKE_TAG('j', 'p', '7', '8')\n#define TAG_JP90 FT_MAKE_TAG('j', 'p', '9', '0')\n#define TAG_JP04 FT_MAKE_TAG('j', 'p', '0', '4')\n\n#define VERT_LOOKUP_INDEX 0\n#define JP78_LOOKUP_INDEX 1\n#define JP90_LOOKUP_INDEX 2\n#define JP04_LOOKUP_INDEX 3\n\n#define MALLOC(ptr, size) ptr = malloc(sizeof((ptr)[0]) * (size))\n#define BYTE2(p) ((p) += 2, (int)(p)[-2] << 8  | (p)[-1])\n#define BYTE4(p) ((p) += 4, (int)(p)[-4] << 24 | (int)(p)[-3] << 16 | \\\n                  (int)(p)[-2] << 8 | (p)[-1])\n\nstruct ft2vert_st {\n    struct Lookup_st {\n        int SubTableCount;\n        struct SubTable_st {\n            struct SingleSubst_st {\n                FT_UInt SubstFormat;\n                FT_UInt DeltaGlyphID; /* SubstFormat == 1 */\n                int     GlyphCount;   /* SubstFormat == 2 */\n                FT_UInt *Substitute;  /* SubstFormat == 2 */\n            } SingleSubst;\n            struct Coverage_st {\n                FT_UInt CoverageFormat;\n                int     GlyphCount;   /* CoverageFormat == 1 */\n                FT_UInt *GlyphArray;  /* CoverageFormat == 1 */\n                int     RangeCount;   /* CoverageFormat == 2 */\n                struct  RangeRecord_st\n                       *RangeRecord;  /* CoverageFormat == 2 */\n            } Coverage;\n        } *SubTable;\n    } Lookup[4];\n    FT_Bytes GSUB_table;\n    FT_Bytes kanaFeature, haniFeature;\n    FT_Bytes vertLookup, vrt2Lookup;\n    FT_Bytes jp78Lookup, jp90Lookup, jp04Lookup;\n    FT_UInt32* variantSelectors;\n};\n\nstruct RangeRecord_st {\n    FT_UInt Start;\n    FT_UInt End;\n};\n\n\nint isInIndex(FT_Bytes s, int index) {\n    int i, count;\n\n    if (s == NULL) return 0;\n    count = BYTE2(s);\n    for (i = 0; i < count; i++) {\n        if (index == BYTE2(s)) return 1;\n    }\n    return 0;\n}\n\n\n/**********  Debug ***************/\n\n#ifdef DEBUG\nstatic FT_Bytes gsub_top;\n\nvoid print_offset(char *message, const FT_Bytes ptr) {\n    printf(\"%s offset = %x\\n\", message, ptr - gsub_top);\n}\n\nchar *tag_to_string(FT_Tag tag) {\n    static char str[5];\n    str[0] = tag >> 24;\n    str[1] = tag >> 16;\n    str[2] = tag >> 8;\n    str[3] = tag;\n    return str;\n}\n\nvoid hex_dump(const FT_Bytes top) {\n    int i, j;\n    FT_Bytes s = top;\n\n    for (j = 0; j < 100; j++) {\n        printf(\"%04x : \", j*8);\n        for (i = 0; i < 8; i++) {\n            printf(\"%02x \", s[i+j*8]);\n        }\n        printf(\"\\n\");\n    }\n}\n#endif /* DEBUG */\n\n/**********  Lookup part ***************/\n\nvoid scan_Coverage(struct ft2vert_st *ret, const FT_Bytes top, const int l) {\n    int i;\n    FT_Bytes s = top;\n    struct Coverage_st *t;\n\n    t = &ret->Lookup[l].SubTable[ret->Lookup[l].SubTableCount].Coverage;\n    t->CoverageFormat = BYTE2(s);\n    switch (t->CoverageFormat) {\n    case 1: \n        t->GlyphCount = BYTE2(s);\n        MALLOC(t->GlyphArray, t->GlyphCount);\n        memset(t->GlyphArray, 0, sizeof(t->GlyphArray[0]) * t->GlyphCount);\n        for (i = 0; i < t->GlyphCount; i++) {\n            t->GlyphArray[i] = BYTE2(s);\n        }\n        break;\n    case 2:\n        t->RangeCount = BYTE2(s);\n        MALLOC(t->RangeRecord, t->RangeCount);\n        memset(t->RangeRecord, 0, sizeof(t->RangeRecord[0]) * t->RangeCount);\n        for (i = 0; i < t->RangeCount; i++) {\n            t->RangeRecord[i].Start = BYTE2(s);\n            t->RangeRecord[i].End   = BYTE2(s);\n            s += 2; /* drop StartCoverageIndex */\n        }\n        break;\n    default:\n#ifdef _DEBUG\n        fprintf(stderr, \"scan_Coverage: unknown CoverageFormat (%d).\",\n                t->CoverageFormat);\n#endif\n\t\treturn;\n    }\n    ret->Lookup[l].SubTableCount++;\n}\n\nvoid scan_SubTable(struct ft2vert_st *ret, const FT_Bytes top, const int l) {\n    int i;\n    FT_Bytes s = top;\n    FT_Offset Coverage;\n    struct SingleSubst_st *t;\n\n    t = &ret->Lookup[l].SubTable[ret->Lookup[l].SubTableCount].SingleSubst;\n    t->SubstFormat = BYTE2(s);\n    Coverage       = BYTE2(s);\n    scan_Coverage(ret, top + Coverage, l);\n    switch (t->SubstFormat) {\n    case 1: /* SingleSubstFormat1 */\n        t->DeltaGlyphID = BYTE2(s);\n        break;\n    case 2: /* SingleSubstFormat2 */\n        t->GlyphCount   = BYTE2(s);\n        MALLOC(t->Substitute, t->GlyphCount);\n        memset(t->Substitute, 0, sizeof(t->Substitute[0]) * t->GlyphCount);\n        for (i = 0; i < t->GlyphCount; i++) {\n            t->Substitute[i] = BYTE2(s);\n        }\n        break;\n#ifdef _DEBUG    \n\tdefault:\n\n        fprintf(stderr, \"scan_SubTable: unknown SubstFormat (%d).\",\n                t->SubstFormat);\n#endif\n\t\t\n    }\n}\n\nvoid scan_Lookup(struct ft2vert_st *ret, const FT_Bytes top, const int l) {\n    int i;\n    FT_Bytes s = top;\n    FT_UShort LookupType;\n    FT_UShort LookupFlag;\n    FT_UShort SubTableCount;\n    FT_UShort SubTable;\n\n    LookupType    = BYTE2(s);\n    LookupFlag    = BYTE2(s);\n    SubTableCount = BYTE2(s);\n    SubTable      = BYTE2(s);\n\n    MALLOC(ret->Lookup[l].SubTable, SubTableCount);\n    memset(ret->Lookup[l].SubTable, 0, sizeof(ret->Lookup[l].SubTable[0]) * SubTableCount);\n    for (i = 0; i < SubTableCount; i++) {\n        scan_SubTable(ret, top + SubTable, l);\n    }\n    if (ret->Lookup[l].SubTableCount != SubTableCount) {\n\n#ifdef _DEBUG\n        fprintf(stderr, \"warning (scan_Lookup): \"\n                \"SubTableCount (=%d) is not expected (=%d).\\n\",\n                ret->Lookup[l].SubTableCount, SubTableCount);\n#endif\n    }\n}\n\n\nvoid scan_LookupList(struct ft2vert_st *ret, const FT_Bytes top) {\n    int i;\n    FT_Bytes s = top;\n    int LookupCount;\n\n    LookupCount = BYTE2(s);\n\n    for (i = 0; i < LookupCount; i++) {\n        FT_Bytes t = top + BYTE2(s);\n        if (isInIndex(ret->vertLookup, i)) {\n            scan_Lookup(ret, t, VERT_LOOKUP_INDEX);\n        } else if (isInIndex(ret->jp78Lookup, i)) {\n            scan_Lookup(ret, t, JP78_LOOKUP_INDEX);\n        } else if (isInIndex(ret->jp90Lookup, i)) {\n            scan_Lookup(ret, t, JP90_LOOKUP_INDEX);\n        } else if (isInIndex(ret->jp04Lookup, i)) {\n            scan_Lookup(ret, t, JP04_LOOKUP_INDEX);\n        }\n    }\n}\n\n/********** Feature part ****************/\n\nvoid scan_FeatureList(struct ft2vert_st *ret, const FT_Bytes top) {\n    int i;\n    FT_Bytes s = top;\n    int FeatureCount;\n\n    FeatureCount = BYTE2(s);\n\n    for (i = 0; i < FeatureCount; i++) {\n        FT_Tag FeatureTag = BYTE4(s);\n        FT_Offset Feature = BYTE2(s);\n        if (isInIndex(ret->kanaFeature, i)) {\n            switch (FeatureTag) {\n            case TAG_VERT:\n                ret->vertLookup = top + Feature + 2;\n                break;\n            case TAG_VRT2:\n                ret->vrt2Lookup = top + Feature + 2;\n                break;\n            }\n        } else if (isInIndex(ret->haniFeature, i)) {\n            switch (FeatureTag) {\n            case TAG_JP78:\n                ret->jp78Lookup = top + Feature + 2;\n                break;\n            case TAG_JP90:\n                ret->jp90Lookup = top + Feature + 2;\n                break;\n            case TAG_JP04:\n                ret->jp04Lookup = top + Feature + 2;\n                break;\n            }\n        }\n    }\n}\n\n/********** Script part ****************/\n\nvoid scan_LangSys(struct ft2vert_st *ret, const FT_Bytes top, const FT_Tag ScriptTag) {\n    if (ScriptTag == TAG_KANA && ret->kanaFeature == NULL) ret->kanaFeature = top + 4;\n    if (ScriptTag == TAG_HANI && ret->haniFeature == NULL) ret->haniFeature = top + 4;\n}\n\nvoid scan_Script(struct ft2vert_st *ret, const FT_Bytes top, const FT_Tag ScriptTag) {\n    int i;\n    FT_Bytes s = top;\n    FT_Offset DefaultLangSys;\n    int LangSysCount;\n\n    DefaultLangSys = BYTE2(s);\n    if (DefaultLangSys != 0) {\n        scan_LangSys(ret, top + DefaultLangSys, ScriptTag);\n    }\n    LangSysCount = BYTE2(s);\n\n    for (i = 0; i < LangSysCount; i++) {\n        FT_Tag LangSysTag = BYTE4(s);\n        FT_Bytes t = top + BYTE2(s);\n        if (LangSysTag == TAG_JAN) {\n            scan_LangSys(ret, t, ScriptTag);\n        }\n    }\n}\n\nvoid scan_ScriptList(struct ft2vert_st *ret, const FT_Bytes top) {\n    int i;\n    FT_Bytes s = top;\n    int ScriptCount;\n\n    ScriptCount = BYTE2(s);\n\n    for (i = 0; i < ScriptCount; i++) {\n        FT_Tag ScriptTag = BYTE4(s);\n        FT_Bytes t = top + BYTE2(s);\n        if (ScriptTag == TAG_KANA || ScriptTag == TAG_HANI) {\n            scan_Script(ret, t, ScriptTag);\n        }\n    }\n}\n\n/********** header part *****************/\n\nvoid scan_GSUB_Header(struct ft2vert_st *ret, const FT_Bytes top) {\n    FT_Bytes s = top;\n    FT_Fixed  Version;\n    FT_Offset ScriptList;\n    FT_Offset FeatureList;\n    FT_Offset LookupList;\n\n#ifdef DEBUG\n    gsub_top    = top;\n#endif /* DEBUG */\n    Version     = BYTE4(s);\n    ScriptList  = BYTE2(s);\n    FeatureList = BYTE2(s);\n    LookupList  = BYTE2(s);\n\n    if (Version != 0x00010000) {\n#ifdef _DEBUG\n        fprintf(stderr, \"warning: GSUB Version (=%.1f) is not 1.0\\n\",\n                (double)Version / 0x10000);\n#endif\n    }\n\n    scan_ScriptList(ret, top + ScriptList);\n    scan_FeatureList(ret, top + FeatureList);\n    /* vrt2 has higher priority over vert */\n    if (ret->vrt2Lookup != NULL) ret->vertLookup = ret->vrt2Lookup;\n    scan_LookupList(ret, top + LookupList);\n}\n\nstruct ft2vert_st *ft2vert_init(FT_Face face) {\n    struct ft2vert_st *ret;\n    int ft_error, i;\n    FT_Bytes base = NULL;\n    FT_Bytes gdef = NULL;\n    FT_Bytes gpos = NULL;\n    FT_Bytes jstf = NULL;\n\n    MALLOC(ret, 1);\n    memset(ret, 0, sizeof(ret[0]));\n    for (i = 0; i < sizeof(ret->Lookup) / sizeof(ret->Lookup[0]); i++) {\n        ret->Lookup[i].SubTableCount = 0;\n    }\n    ret->vertLookup  = NULL;\n    ret->vrt2Lookup  = NULL;\n    ret->jp78Lookup  = NULL;\n    ret->jp90Lookup  = NULL;\n    ret->jp04Lookup  = NULL;\n    ret->kanaFeature = NULL;\n    ret->haniFeature = NULL;\n    ret->GSUB_table  = NULL;\n    ret->variantSelectors = FT_Face_GetVariantSelectors(face);\n    ft_error = FT_OpenType_Validate(\n                face, FT_VALIDATE_GSUB,\n                &base, &gdef, &gpos, &ret->GSUB_table, &jstf);\n    if (ft_error == FT_Err_Unimplemented_Feature) {\n#ifdef _DEBUG\n\t\tfprintf(stderr, \"warning: FT_OpenType_Validate is disabled. \"\n                \"Replace FreeType2 with otvalid-enabled version.\\n\");\n#endif        \n\t\treturn ret;\n    } else if (ft_error != 0 || ret->GSUB_table == 0) {\n#ifdef _DEBUG\n        fprintf(stderr, \"warning: %s has no GSUB table.\\n\",\n                face->family_name);\n#endif  \n        return ret;\n    }\n    scan_GSUB_Header(ret, ret->GSUB_table);\n    if (ret->Lookup[VERT_LOOKUP_INDEX].SubTableCount == 0) {\n#ifdef _DEBUG\n        fprintf(stderr, \"warning: %s has no vrt2/vert feature.\\n\",\n                face->family_name);\n#endif\n    }\n//    free((void*)GSUB_table);\n    return ret;\n}\n\nvoid ft2vert_final(FT_Face face, struct ft2vert_st *vert){\n    int i, j;\n    for (i = 0; i < sizeof(vert->Lookup) / sizeof(vert->Lookup[0]); i++) {\n        for (j = 0; j < vert->Lookup[i].SubTableCount; j++) {\n            free(vert->Lookup[i].SubTable[j].SingleSubst.Substitute);\n            free(vert->Lookup[i].SubTable[j].Coverage.GlyphArray);\n            free(vert->Lookup[i].SubTable[j].Coverage.RangeRecord);\n        }\n        free(vert->Lookup[i].SubTable);\n    }\n    FT_OpenType_Free(face, vert->GSUB_table);\n    free(vert);\n//    FT_Bytes kanaFeature;\n//    FT_Bytes haniFeature;\n//    FT_Bytes vertLookup;\n//    FT_Bytes vrt2Lookup;\n//    FT_Bytes jp78Lookup;\n//    FT_Bytes jp90Lookup;\n//    FT_Bytes jp04Lookup;\n//    FT_UInt32* variantSelectors;\n}\n\n/********** converting part *****************/\n\nstatic FT_UInt get_vert_nth_gid(struct SubTable_st *t, FT_UInt gid, int n) {\n    switch (t->SingleSubst.SubstFormat) {\n    case 1:\n        return gid + t->SingleSubst.DeltaGlyphID;\n    case 2:\n        return t->SingleSubst.Substitute[n];\n    }\n#ifdef _DEBUG\n    fprintf(stderr, \"get_vert_nth_gid: internal error\");\n#endif\n    return 0;\n}\n\n\nFT_UInt ft2gsub_get_gid(const struct ft2vert_st *ft2vert, const FT_UInt gid, const int l) {\n    int i, k;\n    int j = 0; /* StartCoverageIndex */\n\n    for (k = 0; k < ft2vert->Lookup[l].SubTableCount; k++) {\n        struct SubTable_st *t = &ft2vert->Lookup[l].SubTable[k];\n        switch (t->Coverage.CoverageFormat) {\n        case 1:\n            for (i = 0; i < t->Coverage.GlyphCount; i++) {\n                if (t->Coverage.GlyphArray[i] == gid) {\n                    return get_vert_nth_gid(t, gid, i);\n                }\n            }\n            break;\n        case 2:\n            for (i = 0; i < t->Coverage.RangeCount; i++) {\n                struct RangeRecord_st *r = &t->Coverage.RangeRecord[i];\n                if (r->Start <= gid && gid <= r->End) {\n                    return get_vert_nth_gid(t, gid, gid - r->Start + j);\n                }\n                j += r->End - r->Start + 1;\n            }\n            break;\n#ifdef _DEBUG        \n\t\tdefault:\n\n            fprintf(stderr, \"ft2vert_get_gid: internal error\");\n#endif\n        }\n    }\n    return 0;\n}\n\nFT_UInt ft2vert_get_gid(const struct ft2vert_st *ft2vert, const FT_UInt gid) {\n    FT_UInt tmp = ft2gsub_get_gid(ft2vert, gid, VERT_LOOKUP_INDEX);\n    return tmp ? tmp : gid;\n}\n\nint glyphs_comp(const void *_a, const void *_b) {\n\tconst struct ivs_otft_desc *a = (const struct ivs_otft_desc *)_a;\n\tconst struct ivs_otft_desc *b = (const struct ivs_otft_desc *)_b;\n\n\tif (a->baseChar < b->baseChar)\n\t\treturn -1;\n\telse if (a->baseChar > b->baseChar)\n\t\treturn 1;\n\treturn 0;\n}\n\nFT_UInt ft2_subst_uvs(const FT_Face face, const FT_UInt gid, const FT_UInt vsindex, const FT_UInt baseChar)\n{\n\tFT_UInt newglyph;\n\tconst struct ivs_otft_desc key = { baseChar }, *found;\n\tstruct ft2vert_st *ft2vert = (struct ft2vert_st *)face->generic.data;\n\tif (!ft2vert)\n\t\treturn 0;\n\n\t// 存在するならUVS Subtableから探す\n\tif (ft2vert->variantSelectors)\n\t\treturn FT_Face_GetCharVariantIndex(face, baseChar, 0xE0100 + vsindex);\n\n\t// GSUBテーブルのOpenType featureによりシミュレートする\n\tif (vsindex >= sizeof ivs_otft_index / sizeof ivs_otft_index[0])\n\t\treturn 0;\n\tfound = (const struct ivs_otft_desc *)bsearch(&key, ivs_otft + ivs_otft_index[vsindex], ivs_otft_count[vsindex], sizeof(struct ivs_otft_desc), glyphs_comp);\n\tif (!found)\n\t\treturn 0;\n\n\t// シミュレートできるfeatureが見つかったので置換を試みる。\n\tnewglyph = ft2gsub_get_gid(ft2vert, gid, found->otft_index);\n\t// 置換に成功したらそれを返す\n\tif (newglyph)\n\t\treturn newglyph;\n\t// フォントがGSUBテーブルに置換定義を持っていない。\n\t// 'jp04'を持っているが'jp90'を持っていないときはJIS90フォントとみなし、\n\t// 'jp90'を持っているが'jp04'を持っていないときはJIS2004フォントとみなす。\n\t// JIS90フォントに'jp90'を要求された場合とJIS2004フォント'jp04'を要求された場合は\n\t// デフォルト字形が要求された字形であるとみなしてそのまま返す。\n\tif (ft2vert->jp04Lookup && !ft2vert->jp90Lookup && found->otft_index == JP90_LOOKUP_INDEX\n\t\t|| ft2vert->jp90Lookup && !ft2vert->jp04Lookup && found->otft_index == JP04_LOOKUP_INDEX)\n\t\treturn gid;\n\t// どちらでもなければフォントは要求された字形を持っていないとみなす。\n\treturn 0;\n}\n\n//#endif        /* USE_ZEIT */\n"
        },
        {
          "name": "ft2vert.h",
          "type": "blob",
          "size": 0.4501953125,
          "content": "\n#ifdef __cplusplus\nextern \"C\"{\n#endif\n\n/* store GSUB feature vert/vrt2 */\nstruct ft2vert_st *ft2vert_init(FT_Face face);\nvoid ft2vert_final(FT_Face face, struct ft2vert_st *vert);\n\n/* convert horizontal glyph index to vertical glyph index\n */\nFT_UInt ft2vert_get_gid(const struct ft2vert_st *ft2vert, const FT_UInt gid);\nFT_UInt ft2_subst_uvs(const FT_Face face, const FT_UInt gid, const FT_UInt vsindex, const FT_UInt baseChar);\n\n#ifdef __cplusplus\n}\n#endif\n\n"
        },
        {
          "name": "fteng.cpp",
          "type": "blob",
          "size": 28.6953125,
          "content": "#include \"override.h\"\n#include \"ft.h\"\n#include <windows.h>\n#include <tchar.h>\n#include \"fteng.h\"\n\n#ifdef _DLL\n#pragma comment(linker, \"/nod:msvcprt.lib /nod:msvcprtd.lib\")\n#endif\n\n#if 0\n#define FREETYPE_REQCOUNTMAX\t10\n#define GC_TRACE\t\t\t\tTRACE\n#define FREETYPE_GC_COUNTER\t\t128\n#else\n#define FREETYPE_REQCOUNTMAX\t2048//默认4096,每缓存该数量的文字将刷新缓存降低内存占用\n#define GC_TRACE\t\t\t\tNOP_FUNCTION\n#define FREETYPE_GC_COUNTER\t\t1024//刷新缓存后保留文字数量\n#endif\n\nFreeTypeFontEngine* g_pFTEngine;\nFT_Library     freetype_library;\nFTC_Manager    cache_man;\nFTC_CMapCache  cmap_cache;\nFTC_ImageCache image_cache;\nCTLSDCArray TLSDCArray;\n\nint CALLBACK EnumFontCallBack(const LOGFONT *lplf, const TEXTMETRIC *lptm, DWORD /*FontType*/, LPARAM lParam)\n{\t\n\tLOGFONT * lf=(LOGFONT *)lParam;\n\tStringCchCopy(lf->lfFaceName, LF_FACESIZE, lplf->lfFaceName);\n\tlf->lfQuality=0x2d;\t//magic number\n\treturn 0;\n}\n\n\n\nbool GetFontLocalName(TCHAR* pszFontName, __out TCHAR* pszNameOut)\t//获得字体的本地化名称,返回值为字体是否存在\n{\n\tLOGFONT lf = {0};\n\tTCHAR* ret;\n\tlf.lfQuality = 0x2d;\n\tif (!(ret = FontNameCache.Find((TCHAR*)pszFontName)))\n\t{\n\t\tStringCchCopy(lf.lfFaceName, LF_FACESIZE, pszFontName);\n\t\tlf.lfCharSet=DEFAULT_CHARSET;\n\t\tHDC dc=GetDC(NULL);\n\t\tlf.lfQuality=0;\n\t\tEnumFontFamiliesEx(dc, &lf, &EnumFontCallBack, (LPARAM)&lf, 0);\n\t\tReleaseDC(NULL, dc);\n\t\tif (lf.lfQuality==0x2d)\n\t\t\tFontNameCache.Add((TCHAR*)pszFontName, lf.lfFaceName);\n\t\tret=lf.lfFaceName;\n\t}\n\tStringCchCopy(pszNameOut, LF_FACESIZE, ret);\n\treturn lf.lfQuality == 0x2d;\n}\n\nLOGFONTW* GetFontNameFromFile(LPCWSTR Filename)\t//获得一个字体文件内包含的所有字体名称s\n{\n\tLOGFONTW* logfonts = NULL;\n\tDWORD bufsize=0;\n\tif (GetFontResourceInfo(Filename, &bufsize, NULL, 2))\n\t{\n\t\tlogfonts = (LOGFONTW*)malloc(bufsize+1);\n\t\tif (GetFontResourceInfo(Filename, &bufsize, logfonts, 2))\n\t\t{\n\t\t\t((char*)logfonts)[bufsize]=0;\n\t\t\treturn logfonts;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfree(logfonts);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse\n\t{\n\t\tAddFontResourceW(Filename);\n\t\tif (GetFontResourceInfo(Filename, &bufsize, NULL, 2))\n\t\t{\n\t\t\tlogfonts = (LOGFONTW*)malloc(bufsize+1);\n\t\t\tif (GetFontResourceInfo(Filename, &bufsize, logfonts, 2))\n\t\t\t{\n\t\t\t\t((char*)logfonts)[bufsize]=0;\n\t\t\t\tORIG_RemoveFontResourceExW(Filename,0,NULL);\n\t\t\t\treturn logfonts;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfree(logfonts);\n\t\t\t\tORIG_RemoveFontResourceExW(Filename,0,NULL);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tORIG_RemoveFontResourceExW(Filename,0,NULL);\n\t\treturn NULL;\n\t}\n}\n\ntemplate <class T>\nstruct GCCounterSortFunc : public std::binary_function<const T*, const T*, bool>\n{\n\tbool operator()(const T* arg1, const T* arg2) const\n\t{\n\t\tconst int cnt1 = arg1 ? arg1->GetMruCounter() : -1;\n\t\tconst int cnt2 = arg2 ? arg2->GetMruCounter() : -1;\n\t\treturn cnt1 > cnt2;\n\t}\n};\n\nstruct DeleteCharFunc : public std::unary_function<FreeTypeCharData*&, void>\n{\n\tvoid operator()(FreeTypeCharData*& arg) const\n\t{\n\t\tif (!arg)\n\t\t\treturn;\n\t\tdelete arg;\n\t\targ = NULL;\n\t}\n};\n\ntemplate <class T>\nvoid CompactMap(T& pp, int count, int reduce)\n{\n\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_FONTCACHE);\n\tint reducecount = pp.size() - reduce;\n\tT::iterator it= pp.begin();\n\tfor (int i=0;i<reducecount;i++) //删除超过FREETYPE_GC_COUNTER之后的缓存\n\t{\n\t\t//it->second->Erase();\n\t\tdelete it->second;\n\t\tpp.erase(it++);\n\t}\n\treturn;\n}\n\ntemplate <class T>\nvoid Compact(T** pp, int count, int reduce)\n{\n\tAssert(count >= 0);\n\tAssert(reduce > 0);\n\tif (!pp || !count || count < reduce) {\n\t\treturn;\n\t}\n\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_FONTCACHE);\n\tTRACE(_T(\"Compact(0x%p, %d, %d)\\n\"), pp, count, reduce);\n\t//GCモドキ\n\t//T::m_mrucounterの降順に並ぶので\n\t//reduceを超える部分を削除する\n\n\tT** ppTemp = (T**)malloc(sizeof(T*) * count);\n\tif (!ppTemp) {\n\t\treturn;\n\t}\n\tmemcpy(ppTemp, pp, sizeof(T*) * count);\n\n\tstd::sort(ppTemp, ppTemp + count, GCCounterSortFunc<T>());\n\tint i;\n\tfor (i=0; i<reduce; i++) {\n\t\tif (!ppTemp[i])\n\t\t\tbreak;\n\t\tppTemp[i]->ResetMruCounter();\n\t}\n\n\t//GC_TRACE(_T(\"GC:\"));\n\tfor (i=reduce; i<count; i++) {\n\t\tif (!ppTemp[i])\n\t\t\tbreak;\n\t\t//GC_TRACE(_T(\" %wc\"), ppTemp[i]->GetChar());\n\t\tppTemp[i]->Erase();\n\t}\n\t//GC_TRACE(_T(\"\\n\"));\n\tfree(ppTemp);\n}\n\n//FreeTypeCharData\nFreeTypeCharData::FreeTypeCharData(FreeTypeCharData** ppCh, FreeTypeCharData** ppGl, WCHAR wch, UINT glyphindex, int width, int mru, int gdiWidth, int AAMode)\n\t: m_ppSelfGlyph(ppGl), m_glyphindex(glyphindex), m_width(width)\n\t, m_glyph(NULL), m_glyphMono(NULL), m_bmpSize(0), m_bmpMonoSize(0)\n\t, FreeTypeMruCounter(mru), m_gdiWidth(gdiWidth), m_AAMode(AAMode)\n{\n\tg_pFTEngine->AddMemUsedObj(this);\n\tAddChar(ppCh);\n#ifdef _DEBUG\n\tm_wch = wch;\n#endif\n}\n\nFreeTypeCharData::~FreeTypeCharData()\n{\n\tCharDataArray& arr = m_arrSelfChar;\n\tint n = arr.GetSize();\n\twhile (n--) {\n\t\tFreeTypeCharData** pp = arr[n];\n\t\tAssert(*pp == this);\n\t\t*pp = NULL;\n\t}\n\tif(m_ppSelfGlyph) {\n\t\tAssert(*m_ppSelfGlyph == this);\n\t\t*m_ppSelfGlyph = NULL;\n\t}\n\tif(m_glyph){\n\t\tFT_Done_Ref_Glyph((FT_Referenced_Glyph*)&m_glyph);\n\t}\n\tif(m_glyphMono){\n\t\tFT_Done_Ref_Glyph((FT_Referenced_Glyph*)&m_glyphMono);\n\t}\n\n\tg_pFTEngine->SubMemUsed(m_bmpSize);\n\tg_pFTEngine->SubMemUsed(m_bmpMonoSize);\n\tg_pFTEngine->SubMemUsedObj(this);\n}\n\nvoid FreeTypeCharData::SetGlyph(FT_Render_Mode render_mode, FT_Referenced_BitmapGlyph glyph)\n{\n\tconst bool bMono = (render_mode == FT_RENDER_MODE_MONO);\n\tFT_Referenced_BitmapGlyph& gl = bMono ? m_glyphMono : m_glyph;\n\tif (gl) \n\t\tFT_Done_Ref_Glyph((FT_Referenced_Glyph*)&gl);\n\t{\n\t\tFT_Glyph_Ref_Copy((FT_Referenced_Glyph)glyph, (FT_Referenced_Glyph*)&gl);\n\t\tif (gl) {\n\t\t\tint& size = bMono ? m_bmpMonoSize : m_bmpSize;\n\t\t\tsize  = FT_Bitmap_CalcSize(gl->ft_glyph);\n\t\t\tsize += sizeof(FT_BitmapGlyphRec);\n\t\t\tg_pFTEngine->AddMemUsed(size);\n\t\t}\n\t}\n}\n\n\n//FreeTypeFontCache\nFreeTypeFontCache::FreeTypeFontCache(/*int px, int weight, bool italic, */int mru)\n\t: /*m_px(px), m_weight(weight), m_italic(italic), */m_active(false)\n\t, FreeTypeMruCounter(mru)\n{\n#ifdef _USE_ARRAY\n\tZeroMemory(&m_tm, sizeof(TEXTMETRIC));\n\tZeroMemory(m_chars, sizeof(m_chars));\n\tZeroMemory(m_glyphs, sizeof(m_glyphs));\n#else\n\tm_GlyphCache.clear();\n#endif\n\tg_pFTEngine->AddMemUsedObj(this);\n}\n\nFreeTypeFontCache::~FreeTypeFontCache()\n{\n\tErase();\n\tg_pFTEngine->SubMemUsedObj(this);\n}\n\nvoid FreeTypeFontCache::Compact()\n{\n\t//TRACE(_T(\"FreeTypeFontCache::Compact: %d > %d\\n\"), countof(m_chars), FREETYPE_GC_COUNTER);\n\tResetGCCounter();\n#ifdef _USE_ARRAY\n\t::Compact(m_glyphs, countof(m_glyphs), FREETYPE_GC_COUNTER);\n#else\n\t::CompactMap(m_GlyphCache, m_GlyphCache.size(), FREETYPE_GC_COUNTER);\n#endif\n\t//GlyphCache::const_iterator it=m_GlyphCache.begin();\n}\n\nvoid FreeTypeFontCache::Erase()\n{\n\tm_active = false;\n#ifdef _USE_ARRAY\n\tstd::for_each(m_chars,  m_chars  + FT_MAX_CHARS, DeleteCharFunc());\n\tstd::for_each(m_glyphs, m_glyphs + FT_MAX_CHARS, DeleteCharFunc());\n#else\n\tGlyphCache::iterator it=m_GlyphCache.begin();\n\tfor (;it!=m_GlyphCache.end();++it)\n\t\tdelete it->second;\n\tm_GlyphCache.clear();\n#endif\n}\n\nvoid FreeTypeFontCache::AddCharData(WCHAR wch, UINT glyphindex, int width, int gdiWidth, FT_Referenced_BitmapGlyph glyph, FT_Render_Mode render_mode, int AAMode)\n{\n\tif (glyphindex & 0xffff0000 /*|| !g_ccbCache*/) {\n\t\treturn;\n\t}\n\tif (AddIncrement() >= FREETYPE_REQCOUNTMAX) {\t//先压缩，避免压缩后丢失的问题\n\t\tCompact();\n\t}\n\n#ifdef _USE_ARRAY\n\tFreeTypeCharData** ppChar  = _GetChar(wch);\n\tif (*ppChar) {\n\t\t(*ppChar)->SetGlyph(render_mode, glyph);\n\t\t(*ppChar)->SetMruCounter(this);\n\t\treturn;\n\t}\n#else\n\tGlyphCache::iterator it=m_GlyphCache.find(wch);\n\tif (it!=m_GlyphCache.end())\t//找到了旧数据\n\t{\n\t\tFreeTypeCharData* ppChar  = it->second;\n\t\tif (ppChar) {\n\t\t\tppChar->SetGlyph(render_mode, glyph);\n\t\t\tppChar->SetMruCounter(this);\n\t\t\tppChar->SetWidth(width);\n\t\t\tppChar->SetGDIWidth(gdiWidth);\n\t\t\treturn;\n\t\t}\t\n\t}\n#endif\n\tFreeTypeCharData* p = new FreeTypeCharData(/*ppChar*/NULL, NULL, wch, glyphindex, width, MruIncrement(), gdiWidth, AAMode);\n\tif (p == NULL) {\n\t\treturn;\n\t}\n\tp->SetGlyph(render_mode, glyph);\n\n#ifdef _USE_ARRAY\n\t*ppChar = p;\n#else\n\tm_GlyphCache[wch]=p;\n#endif\n\n}\n\nvoid FreeTypeFontCache::AddGlyphData(UINT glyphindex, int width, int gdiWidth, FT_Referenced_BitmapGlyph glyph, FT_Render_Mode render_mode, int AAMode)\n{\n\tif (glyphindex & 0xffff0000 /*|| !g_ccbCache*/) {\n\t\treturn;\n\t}\n\t//GC\n\tif (AddIncrement() >= FREETYPE_REQCOUNTMAX) {\n\t\t//TRACE(_T(\"Compact(0x%p)\\n\"), this);\n\t\tCompact();\n\t}\n\n#ifdef _USE_ARRAY\n\tFreeTypeCharData** ppGlyph  = _GetGlyph(glyphindex);\n\tif (*ppGlyph) {\n\t\t(*ppGlyph)->SetGlyph(render_mode, glyph);\n\t\t(*ppGlyph)->SetMruCounter(this);\n\t\treturn;\n\t}\n#else\n\tGlyphCache::iterator it=m_GlyphCache.find(-(int)glyphindex);\n\tif (it!=m_GlyphCache.end())\t//找到了旧数据\n\t{\n\t\tFreeTypeCharData* ppChar  = it->second;\n\t\tif (ppChar) {\n\t\t\t(ppChar)->SetGlyph(render_mode, glyph);\n\t\t\t(ppChar)->SetMruCounter(this);\n\t\t\tppChar->SetWidth(width);\n\t\t\tppChar->SetGDIWidth(gdiWidth);\n\t\t\treturn;\n\t\t}\t\n\t}\n#endif\n\n\t//追加(glyphのみ)\n\tFreeTypeCharData* p = new FreeTypeCharData(NULL, /*ppGlyph*/NULL, 0, glyphindex, width, MruIncrement(), gdiWidth, AAMode);\n\tif (p == NULL) {\n\t\treturn;\n\t}\n\tp->SetGlyph(render_mode, glyph);\n\n#ifdef _USE_ARRAY\n\t*ppGlyph = p;\n#else\n\tm_GlyphCache[-(int)glyphindex]=p;\n#endif\n}\n\n\n//FreeTypeFontInfo\nvoid FreeTypeFontInfo::Compact()\n{\n\t//TRACE(_T(\"FreeTypeFontInfo::Compact: %d > %d\\n\"), m_cache.GetSize(), m_nMaxSizes);\n\tResetGCCounter();\n\t::CompactMap(m_cache, m_cache.size(), m_nMaxSizes);\n\tCacheArray::const_iterator it=m_cache.begin();\n\tfor (;it!=m_cache.end();++it)\n\t\tit->second->Deactive();\n}\n\nvoid FreeTypeFontInfo::Createlink()\n{\n\tCFontFaceNamesEnumerator fn(m_hash.c_str(), m_nFontFamily);\n\tstd::set<int> linkset;\t//链接字体集合，防止重复链接，降低效率\n\tlinkset.insert(m_id);\n\tface_id_link[m_linknum] = (FTC_FaceID)m_id;\n\tggo_link[m_linknum++] = m_ggoFont;\t//第一个链接一定是自己，不需要获取\n\tLOGFONT lf;\n\tBOOL IsSimSun = false;\n\tmemset(&lf, 0, sizeof(LOGFONT));\n\tlf.lfCharSet=DEFAULT_CHARSET;\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\n\tfor (fn.next() ; !fn.atend(); fn.next()) {\t//跳过第一个链接\n\t\t//FreeTypeFontInfo* pfitemp = g_pFTEngine->FindFont(fn, m_weight, m_italic);\n\t\t//if (pfitemp && pfitemp->m_isSimSun)\n\t\t//\tIsSimSun = true;\n\t\tif (!m_SimSunID)\n\t\t\tIsSimSun = (_wcsicmp(fn,L\"宋体\")==0 || _wcsicmp(fn,L\"SimSun\")==0);\n\t\tStringCchCopy(lf.lfFaceName, LF_FACESIZE, fn);\n\t\tif (!_wcsicmp(fn, m_familyname.c_str()))\t// allow font link to itself\n\t\t\tpSettings->CopyForceFont(lf,lf);\n\t\tFreeTypeFontInfo* pfitemp = g_pFTEngine->FindFont(lf.lfFaceName, /*m_weight*/0, /*m_italic*/false);\n\t\tif (pfitemp && linkset.find(pfitemp->GetId())==linkset.end()) {\n\t\t\tlinkset.insert(pfitemp->GetId());\n\t\t\tface_id_link[m_linknum] = (FTC_FaceID)pfitemp->GetId();\n\t\t\tggo_link[m_linknum++] = pfitemp->GetGGOFont();\n\t\tif (!m_SimSunID && IsSimSun)\n\t\t\tm_SimSunID = (FTC_FaceID)pfitemp->GetId();\n\t\t}\n\t}\n}\n\nbool FreeTypeFontInfo::EmbeddedBmpExist(int px)\n{\n\tif (px>=256 || px<0)\n\t\treturn false;\n\tif (m_ebmps[px]!=-1)\n\t\treturn !!m_ebmps[px];\n\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_MANAGER);\n\tFTC_ImageTypeRec imgtype={(FTC_FaceID)m_id, px, px, FT_LOAD_DEFAULT};\t//构造一个当前大小的imagetype\n\tFT_Glyph temp_glyph=NULL;\n\tFT_UInt gindex = FTC_CMapCache_Lookup(cmap_cache, (FTC_FaceID)m_id, -1, FT_UInt32(L'0'));\t//获得0的索引值\n\tFTC_ImageCache_Lookup(image_cache, &imgtype, gindex, &temp_glyph, NULL);\n\tif (temp_glyph && temp_glyph->format==FT_GLYPH_FORMAT_BITMAP)\t//如果可以读到0的点阵\n\t\tm_ebmps[px]=1;\t//则该字号存在点阵\n\telse\n\t{\n\t\tgindex = FTC_CMapCache_Lookup(cmap_cache, (FTC_FaceID)m_id, -1, FT_UInt32(L'的'));\t//获得\"的\"的索引值\n\t\tif (gindex)\n\t\t\tFTC_ImageCache_Lookup(image_cache, &imgtype, gindex, &temp_glyph, NULL);\t//读取“的”的点阵\n\t\tif (temp_glyph && temp_glyph->format==FT_GLYPH_FORMAT_BITMAP)\t//如果可以读到0的点阵\n\t\t\tm_ebmps[px]=1;\t//则该字号存在点阵\n\t\telse\n\t\t\tm_ebmps[px]=0;\n\t}\n\treturn !!m_ebmps[px];\n}\n\nFreeTypeFontCache* FreeTypeFontInfo::GetCache(FTC_ScalerRec& scaler, const LOGFONT& lf)\n{\n\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_FONTCACHE);\n\n\tif (AddIncrement() > m_nMaxSizes) {\t//先压缩\n\t\tCompact();\n\t}\n\tint weight = lf.lfWeight;\n\tweight = weight < FW_BOLD ? 0: 1/*FW_BOLD*/;\n\tconst bool italic = !!lf.lfItalic;\n\tif (scaler.height>0xfff || scaler.width>0xfff/* || scaler.height<0 || scaler.width<0*/)\t//超大字体不渲染\n\t\treturn NULL;\n\tFreeTypeFontCache* p = NULL;\n\tUINT hash=getCacheHash(scaler.height, weight, italic, lf.lfWidth ? scaler.width : 0);\t//计算hash\n\tCacheArray::iterator it=m_cache.find(hash); //寻找cache\n\tif (it!=m_cache.end())//cache存在\n\t{\n\t\tp = it->second;\n\t\tgoto OK; //返回cache\n\t}\n\t\n\tp = new FreeTypeFontCache(/*scaler.height, weight, italic,*/ MruIncrement());\n\tif (!p) {\n\t\treturn NULL;\n\t}\n\tif (m_cache[hash]=p) {\n\t\tgoto OK;\n\t}\n\tdelete p;\n\treturn NULL;\n\nOK:\n\tAssert(p != NULL);\n\tif (p && p->Activate()) {\n\t\tDecIncrement();\t//重复使用则减计数值\n\t}\n\treturn p;\n}\n\n\n//FreeTypeFontEngine\nvoid FreeTypeFontEngine::Compact()\n{\n\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_FONTENG);\n\n\tTRACE(_T(\"FreeTypeFontEngine::Compact: %d > %d\\n\"), m_mfontMap.size(), m_nMaxFaces);\n\tResetGCCounter();\n\t//memset(m_arrFace, 0, sizeof(FT_Face)*m_nFaceCount);\t//超过最大face数了，老的face会被ft释放掉，所以需要全部重新获取\n\t//FontListArray& arr = m_arrFontList;\n\t//::Compact(arr.GetData(), arr.GetSize(), m_nMaxFaces);\n}\n\nBOOL FreeTypeFontEngine::RemoveFont(FreeTypeFontInfo* fontinfo)\n{\n\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_FONTMAP);\n\t{\n\t\tFontMap::const_iterator iter=m_mfontMap.begin();\t//遍历fontmap\n\t\twhile (iter!=m_mfontMap.end())\n\t\t{\n\t\t\tFreeTypeFontInfo* p = iter->second;\n\t\t\tif (p==fontinfo)\n\t\t\t\tm_mfontMap.erase(iter++);\t//删除引用\n\t\t\telse\n\t\t\t\t++iter;\n\t\t}\n\t}\n\t{\n\t\tFullNameMap::const_iterator iter=m_mfullMap.begin();\t//遍历fullmap\n\t\twhile (iter!=m_mfullMap.end())\n\t\t{\n\t\t\tFreeTypeFontInfo* p = iter->second;\n\t\t\tif (p==fontinfo)\n\t\t\t\tm_mfullMap.erase(iter++);\t//删除引用\n\t\t\telse\n\t\t\t{\n\t\t\t\titer->second->UpdateFontSetting();\n\t\t\t\t++iter;\n\t\t\t}\n\t\t}\n\t}\n\tdelete fontinfo;\n\treturn true;\n}\n\nBOOL FreeTypeFontEngine::RemoveThisFont(FreeTypeFontInfo* fontinfo, LOGFONT* lg)\n{\n\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_FONTMAP);\n\t{\n\t\tFontMap::const_iterator iter=m_mfontMap.find(myfont(lg->lfFaceName, CalcBoldWeight(lg->lfWeight), lg->lfItalic));\t//遍历fontmap\n\t\tif (iter!=m_mfontMap.end())\n\t\t\tm_mfontMap.erase(iter);\t//删除引用\n\t}\n\t{\n\t\tFullNameMap::const_iterator iter=m_mfullMap.find(fontinfo->GetFullName());\t//遍历fullmap\n\t\tif (iter!=m_mfullMap.end())\n\t\t\tm_mfullMap.erase(iter);\t//删除引用\n\t}\n\tdelete fontinfo;\n\treturn true;\n}\n\nBOOL FreeTypeFontEngine::RemoveFont(LPCWSTR FontName)\n{\n\tif (!FontName) return false;\n\tLOGFONTW* fontarray = GetFontNameFromFile(FontName);\n\tLOGFONTW* c_fontarray = fontarray;\t//记录原始指针\n\tif (!fontarray) return false;\n\tFTC_FaceID fid = NULL;\n\tBOOL bIsFontLoaded, bIsFontFileLoaded = false;\n\tCOwnedCriticalSectionLock __lock2(2, COwnedCriticalSectionLock::OCS_DC);\t//获取所有权，现在要处理DC，禁止所有绘图函数访问\n\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_MANAGER);\n\twhile (*(char*)fontarray)\n\t{\n\t\tbIsFontLoaded = false;\n\t\tFreeTypeFontInfo* result = FindFont(fontarray->lfFaceName, fontarray->lfWeight, !!fontarray->lfItalic, false, &bIsFontLoaded);\n\t\tif (result)\n\t\t{\n\t\t\tfid = (FTC_FaceID)result->GetId();\n\t\t\tif (bIsFontLoaded)\t//该字体已经被使用过\n\t\t\t{\n\t\t\t\tRemoveFont(result);\t//枚举字体信息全部删除\n\t\t\t\tbIsFontFileLoaded = true;\t//设置字体文件也被使用过\n\t\t\t}\n\t\t\telse\n\t\t\t\tRemoveThisFont(result, fontarray);\n\t\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_FONTENG);\n\t\t\tFTC_Manager_RemoveFaceID(cache_man, fid);\n\t\t\tm_mfontList[(int)fid-1]=NULL;\n\t\t}\n\t\tfontarray++;\n\t}\n\tfree(c_fontarray); //利用原始指针释放\n\tif (bIsFontFileLoaded)\t//若字体文件被使用过，则需要清楚所有DC\n\t{\n\t\tCTLSDCArray::iterator iter = TLSDCArray.begin();\n\t\twhile (iter!=TLSDCArray.end())\n\t\t{\n\t\t\t((CBitmapCache*)*iter)->~CBitmapCache();\t//清除掉所有使用中的DC\n\t\t\t++iter;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int FaceIDHolder = 0;\nint GetFaceID(void)\n{\n\treturn (int)InterlockedIncrement((LONG volatile*)&FaceIDHolder);\n}\n\nvoid ReleaseFaceID(void)\n{\n\tInterlockedDecrement((LONG volatile*)&FaceIDHolder);\n}\n\nFreeTypeFontInfo* FreeTypeFontEngine::AddFont(void* lpparams)\n{\n\tFREETYPE_PARAMS* params = (FREETYPE_PARAMS*)lpparams;\n\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_FONTENG);\n\tconst LOGFONT& lplf = *params->lplf;\n\tif(!*lplf.lfFaceName || _tcslen(lplf.lfFaceName) == 0)\n\t\treturn NULL;\n\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\n\t//const CFontSettings& fs = pSettings->FindIndividual(params->strFamilyName.c_str());\n\tFreeTypeFontInfo* pfi = new FreeTypeFontInfo(/*m_mfullMap.size() + 1*/GetFaceID(), lplf.lfFaceName, lplf.lfWeight, !!lplf.lfItalic, MruIncrement(), params->strFullName, params->strFamilyName);\n\tif (!pfi)\n\t\treturn NULL;\n\t\n\tif (pfi->GetFullName().size()==0)\t//点阵字\n\t\t{\n\t\t\tdelete pfi;\n\t\t\tReleaseFaceID();\n\t\t\treturn NULL;\n\t\t}\n/*\n\tTCHAR buff[255]={0};\n\tif (params->strFamilyName.length()==8)\n\t{\n\t\twsprintf(buff, L\"Adding familiyname \\\"%s\\\" fullname \\\"%s\\\" weight %d\\n\\result: \\\"%s\\\"\\n\", params->strFamilyName.c_str(), params->strFullName.c_str(),\n\t\t\tparams->lplf->lfWeight, pfi->GetFullName().c_str());\n\t\tLog(buff);\n\t}*/\n\n\tFullNameMap::const_iterator it = m_mfullMap.find(pfi->GetFullName());\n\tif (it!=m_mfullMap.end())\t//是已经存在的字体了,原因是字体替换使两种名字指向一个字体\n\t{\n\t\tdelete pfi;\t//删除刚才创建的字体\n\t\tReleaseFaceID();\n\t\tpfi = it->second;//指向原字体\n\t}\n\telse\n\t{\n\t\tm_mfullMap[pfi->GetFullName()]=pfi;\t//不存在，添加到map表\n\t\tm_mfontList.push_back(pfi);\n\t}\n\n\tif (pfi->GetFullName()!=params->strFullName)\t//如果目标字体的真实名称和需要的名称不一样，说明是字体替换\n\t{\n\t\tpfi->AddRef();\t//增加引用计数\n\t\tm_mfullMap[params->strFullName] = pfi;\t//双重引用，指向同一个字体\n\t}\n\t\t\n\t//bool ret = !!arr.Add(pfi);\n\t//weight = weight < FW_BOLD ? 0: FW_BOLD;\n\tmyfont font(lplf.lfFaceName, lplf.lfWeight, !!params->otm->otmTextMetrics.tmItalic);\n\t/*\n\tFontMap::const_iterator it = m_mfontMap.find(font);\n\t\tif (it!=m_mfontMap.end())\n\t\t{\n\t\t\tit->second->Release();\n\t\t}*/\n\t\n\tm_mfontMap[font]=pfi;\n\t/*\n\tif (!ret) {\n\tdelete pfi;\n\treturn NULL;\n\t}*/\n\n\n#ifdef _DEBUG\n\t{\n\t\tconst CFontSettings& fs = pfi->GetFontSettings();\n\t\tTRACE(_T(\"AddFont: %s, %d, %d, %d, %d, %d, %d\\n\"), pfi->GetName(),\n\t\t\tfs.GetParam(0), fs.GetParam(1), fs.GetParam(2), fs.GetParam(3), fs.GetParam(4), fs.GetParam(5));\n\t}\n#endif\n\treturn pfi;\n}\n\nFreeTypeFontInfo* FreeTypeFontEngine::AddFont(LPCTSTR lpFaceName, int weight, bool italic, BOOL* bIsFontLoaded)\n{\n\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_FONTENG);\n\tif(lpFaceName == NULL || _tcslen(lpFaceName) == 0/* || FontExists(lpFaceName, weight, italic)*/)\n\t\treturn NULL;\n\n\t//FontListArray& arr = m_arrFontList;\n\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\n\t//const CFontSettings& fs = pSettings->FindIndividual(lpFaceName);\n\twstring dumy;\n\t//dumy.clear();\n\tFreeTypeFontInfo* pfi = new FreeTypeFontInfo(/*m_mfullMap.size() + 1*/GetFaceID(), lpFaceName, weight, italic, MruIncrement(), dumy, dumy);\n\tif (!pfi)\n\t\treturn NULL;\n\tif (pfi->GetFullName().size()==0)\t//点阵字\n\t{\n\t\tdelete pfi;\n\t\tReleaseFaceID();\n\t\treturn NULL;\n\t}\n\n\tFullNameMap::const_iterator it = m_mfullMap.find(pfi->GetFullName()); //是否在主map表中存在了\n\tif (it!=m_mfullMap.end())\t//已经存在\n\t{\n\t\tdelete pfi;\t//删除创建出来的字体\n\t\tReleaseFaceID();\n\t\tpfi = it->second;\t//指向已经存在的字体\n\t\tif (bIsFontLoaded)\n\t\t\t*bIsFontLoaded = true;\n\t\t//pfi->AddRef();\n\t}\n\telse\n\t{\n\t\tm_mfullMap[pfi->GetFullName()]=pfi;\t//不存在，添加到map表\n\t\tm_mfontList.push_back(pfi);\n\t\tif (bIsFontLoaded)\n\t\t\t*bIsFontLoaded = false;\n\t}\n\n\t//bool ret = !!arr.Add(pfi);\n\t//weight = weight < FW_BOLD ? 0: FW_BOLD;\n\tmyfont font(lpFaceName, weight, italic);\n\tm_mfontMap[font]=pfi;\t\t//添加在次要map表\n/*\n\tif (!ret) {\n\t\tdelete pfi;\n\t\treturn NULL;\n\t}*/\n\n\t\n#ifdef _DEBUG\n\t{\n\t\tconst CFontSettings& fs = pfi->GetFontSettings();\n\t\tTRACE(_T(\"AddFont: %s, %d, %d, %d, %d, %d, %d\\n\"), pfi->GetName(),\n\t\t\t\tfs.GetParam(0), fs.GetParam(1), fs.GetParam(2), fs.GetParam(3), fs.GetParam(4), fs.GetParam(5));\n\t}\n#endif\n\treturn pfi;\n}\n\nint FreeTypeFontEngine::GetFontIdByName(LPCTSTR lpFaceName, int weight, bool italic)\n{\n\tconst FreeTypeFontInfo* pfi = FindFont(lpFaceName, weight, italic);\n\treturn pfi ? pfi->GetId() : 0;\n}\n\n/*\nLPCTSTR FreeTypeFontEngine::GetFontById(int faceid, int& weight, bool& italic)\n{\n\tCCriticalSectionLock __lock;\n\n\tFreeTypeFontInfo** pp\t= m_arrFontList.Begin();\n\tFreeTypeFontInfo** end\t= m_arrFontList.End();\n\tfor(; pp != end; ++pp) {\n\t\tFreeTypeFontInfo* p = *pp;\n\t\tif (p->GetId() == faceid) {\n\t\t\tp->SetMruCounter(this);\n\t\t\tweight = p->GetWeight();\n\t\t\titalic = p->IsItalic();\n\t\t\treturn p->GetName();\n\t\t}\n\t}\n\treturn NULL;\n}\n*/\nFreeTypeFontInfo* FreeTypeFontEngine::FindFont(void* lpparams)\n{\n\tFREETYPE_PARAMS* params = (FREETYPE_PARAMS*)lpparams;\n\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_FONTMAP);\n\tFullNameMap::const_iterator iter=m_mfullMap.find(params->strFullName);\n\tif (iter!=m_mfullMap.end())\n\t{\n\t\tFreeTypeFontInfo* p = iter->second;\n\t\tif (p->GetFullName()!=params->strFullName)\t//属于替换字体\n\t\t\treturn FindFont(params->lplf->lfFaceName, params->lplf->lfWeight, !!params->lplf->lfItalic);\n\t\tp->SetMruCounter(this);\n\t\treturn p;\n\t}\n\t//m_bAddOnFind = true;\n\treturn AddFont(params);\n}\n\nFreeTypeFontInfo* FreeTypeFontEngine::FindFont(LPCTSTR lpFaceName, int weight, bool italic, bool AddOnFind, BOOL* bIsFontLoaded)\n{\n/*\n\tif (m_bAddOnFind) \n\t{\n\t\tm_bAddOnFind = false;\n\t\treturn NULL;\n\t}*/\n\n\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_FONTMAP);\n\tweight = CalcBoldWeight(weight);\n\tmyfont font(lpFaceName, weight, italic);\n\tFontMap::const_iterator iter=m_mfontMap.find(font);\n\tif (iter!=m_mfontMap.end())\n\t{\n\t\tFreeTypeFontInfo* p = iter->second;\n\t\tp->SetMruCounter(this);\n/*\n\t\tTCHAR buff[255]={0};\n\t\tif (wcslen(lpFaceName)==8)\n\t\t{\n\t\t\twsprintf(buff, L\"Finding familiyname \\\"%s\\\" weight %d\\n\\tFound: \\\"%s\\\"\\n\", lpFaceName,\n\t\t\t\tweight, p->GetFullName().c_str());\n\t\t\tLog(buff);\n\t\t}*/\n\t\tif (bIsFontLoaded)\n\t\t\t*bIsFontLoaded = true;\n\t\treturn p;\n\t}\n\t//m_bAddOnFind = true;\n\treturn AddFont(lpFaceName, weight, italic, bIsFontLoaded);\n}\n\nFreeTypeFontInfo* FreeTypeFontEngine::FindFont(int faceid)\n{\n\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_FONTMAP);\n\tif (faceid>m_mfontList.size())\n\t\treturn NULL;\n\telse\n\t\treturn m_mfontList[faceid-1];\t//存在bug！！！\n\t/*\n\tFullNameMap::const_iterator iter=m_mfullMap.begin();\n\t\tfor(; iter != m_mfullMap.end(); ++iter) {\n\t\t\tFreeTypeFontInfo* p = iter->second;\n\t\t\tif (p->GetId() == faceid) {\n\t\t\t\tp->SetMruCounter(this);\n\t\t\t\treturn p;\n\t\t\t}\n\t\t}\n\t\treturn NULL;*/\n\t\n}\n\n\n//FreeTypeSysFontData\n// http://kikyou.info/diary/?200510#i10 を参考にした\n#include <freetype/tttables.h>\t// FT_TRUETYPE_TABLES_H\n#include <mmsystem.h>\t//mmioFOURCC\n#define TVP_TT_TABLE_ttcf\tmmioFOURCC('t', 't', 'c', 'f')\n#define TVP_TT_TABLE_name\tmmioFOURCC('n', 'a', 'm', 'e')\n\n// Windowsに登録されているフォントのバイナリデータを名称から取得\nFreeTypeSysFontData* FreeTypeSysFontData::CreateInstance(LPCTSTR name, int weight, bool italic)\n{\n\tFreeTypeSysFontData* pData = new FreeTypeSysFontData;\n\tif (!pData) {\n\t\treturn NULL;\n\t}\n\tif (!pData->Init(name, weight, italic)) {\n\t\tdelete pData;\n\t\treturn NULL;\n\t}\n\treturn pData;\n}\n\nbool FreeTypeSysFontData::Init(LPCTSTR name, int weight, bool italic)\n{\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\n\tvoid* pNameFromGDI\t\t= NULL; // Windows から取得した name タグの内容\n\tvoid* pNameFromFreeType\t= NULL; // FreeType から取得した name タグの内容\n\tHFONT hf = NULL;\n\tDWORD cbNameTable;\n\tDWORD cbFontData;\n\tint index;\n\tDWORD buf;\n\tFT_StreamRec& fsr = m_ftStream;\n\tm_name.assign(name);\n\tm_hdc = CreateCompatibleDC(NULL);\n\tif(m_hdc == NULL) {\n\t\treturn false;\n\t}\n\t// 名前以外適当\n\tif (pSettings->FontSubstitutes() < SETTING_FONTSUBSTITUTE_ALL)\n\t{\n\t\thf = CreateFont(\n\t\t\t\t\t12, 0, 0, 0, weight,\n\t\t\t\t\titalic, FALSE, FALSE,\n\t\t\t\t\tDEFAULT_CHARSET,\n\t\t\t\t\tOUT_DEFAULT_PRECIS,\n\t\t\t\t\tFONT_MAGIC_NUMBER,\n\t\t\t\t\tDEFAULT_QUALITY,\n\t\t\t\t\tDEFAULT_PITCH | FF_DONTCARE,\n\t\t\t\t\tname);\n\t}\n\telse\n\t\thf = CreateFont(\n\t\t\t\t\t12, 0, 0, 0, weight,\n\t\t\t\t\titalic, FALSE, FALSE,\n\t\t\t\t\tDEFAULT_CHARSET,\n\t\t\t\t\tOUT_DEFAULT_PRECIS,\n\t\t\t\t\tCLIP_DEFAULT_PRECIS,\n\t\t\t\t\tDEFAULT_QUALITY,\n\t\t\t\t\tDEFAULT_PITCH | FF_DONTCARE,\n\t\t\t\t\tname);\n\n\tif(hf == NULL){\n\t\treturn false;\n\t}\n\n\tm_hOldFont = SelectFont(m_hdc, hf);\n\t// フォントデータが得られそうかチェック\n\tcbNameTable = ORIG_GetFontData(m_hdc, TVP_TT_TABLE_name, 0, NULL, 0);\n\tif(cbNameTable == GDI_ERROR){\n\t\tgoto ERROR_Init;\n\t}\n\n\tpNameFromGDI\t\t= malloc(cbNameTable);\n\tif (!pNameFromGDI) {\n\t\tgoto ERROR_Init;\n\t}\n\tpNameFromFreeType\t= malloc(cbNameTable);\n\tif (!pNameFromFreeType) {\n\t\tgoto ERROR_Init;\n\t}\n\n\t//- name タグの内容をメモリに読み込む\n\tif(ORIG_GetFontData(m_hdc, TVP_TT_TABLE_name, 0, pNameFromGDI, cbNameTable) == GDI_ERROR){\n\t\tgoto ERROR_Init;\n\t}\n\n\t// フォントサイズ取得処理\n\tcbFontData = ORIG_GetFontData(m_hdc, TVP_TT_TABLE_ttcf, 0, &buf, 1);\n\tif(cbFontData == 1){\n\t\t// TTC ファイルだと思われる\n\t\tcbFontData = ORIG_GetFontData(m_hdc, TVP_TT_TABLE_ttcf, 0, NULL, 0);\n\t\tm_isTTC = true;\n\t}\n\telse{\n\t\tcbFontData = ORIG_GetFontData(m_hdc, 0, 0, NULL, 0);\n\t}\n\tif(cbFontData == GDI_ERROR){\n\t\t// エラー; GetFontData では扱えなかった\n\t\tgoto ERROR_Init;\n\t}\n\n\tif (pSettings->UseMapping()) {\n\t\tHANDLE hmap = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE | SEC_COMMIT | SEC_NOCACHE, 0, cbFontData, NULL);\n\t\tif (!hmap) {\n\t\t\tgoto ERROR_Init;\n\t\t}\n\t\tm_pMapping = MapViewOfFile(hmap, FILE_MAP_ALL_ACCESS, 0, 0, cbFontData);\n\t\tm_dwSize = cbFontData;\n\t\tCloseHandle(hmap);\n\n\t\tif (m_pMapping) {\n\t\t\tORIG_GetFontData(m_hdc, m_isTTC ? TVP_TT_TABLE_ttcf : 0, 0, m_pMapping, cbFontData);\n\t\t}\n\t}\n\n\t// FT_StreamRec の各フィールドを埋める\n\tfsr.base\t\t\t\t= 0;\n\tfsr.size\t\t\t\t= cbFontData;\n\tfsr.pos\t\t\t\t\t= 0;\n\tfsr.descriptor.pointer\t= this;\n\tfsr.pathname.pointer\t= NULL;\n\tfsr.read\t\t\t\t= IoFunc;\n\tfsr.close\t\t\t\t= CloseFunc;\n\n\tindex = 0;\n\tm_locked = true;\n\tif(!OpenFaceByIndex(index)){\n\t\tgoto ERROR_Init;\n\t}\n\n\tfor(;;) {\n\t\t// FreeType から、name タグのサイズを取得する\n\t\tFT_ULong length = 0;\n\t\tFT_Error err = FT_Load_Sfnt_Table(m_ftFace, TTAG_name, 0, NULL, &length);\n\t\tif(err){\n\t\t\tgoto ERROR_Init;\n\t\t}\n\n\t\t// FreeType から得た name タグの長さを Windows から得た長さと比較\n\t\tif(length == cbNameTable){\n\t\t\t// FreeType から name タグを取得\n\t\t\terr = FT_Load_Sfnt_Table(m_ftFace, TTAG_name, 0, (unsigned char*)pNameFromFreeType, &length);\n\t\t\tif(err){\n\t\t\t\tgoto ERROR_Init;\n\t\t\t}\n\t\t\t// FreeType から読み込んだ name タグの内容と、Windows から読み込んだ\n\t\t\t// name タグの内容を比較する。\n\t\t\t// 一致していればその index のフォントを使う。\n\t\t\tif(!memcmp(pNameFromGDI, pNameFromFreeType, cbNameTable)){\n\t\t\t\t// 一致した\n\t\t\t\t// face は開いたまま\n\t\t\t\tbreak; // ループを抜ける\n\t\t\t}\n\t\t}\n\n\t\t// 一致しなかった\n\t\t// インデックスを一つ増やし、その face を開く\n\t\tindex ++;\n\n\t\tif(!OpenFaceByIndex(index)){\n\t\t\t// 一致する face がないまま インデックスが範囲を超えたと見られる\n\t\t\t// index を 0 に設定してその index を開き、ループを抜ける\n\t\t\tindex = 0;\n\t\t\tif(!OpenFaceByIndex(index)){\n\t\t\t\tgoto ERROR_Init;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(pNameFromGDI);\n\tfree(pNameFromFreeType);\n\tm_locked = false;\n\treturn true;\n\nERROR_Init:\n\tm_locked = false;\n\tif (hf) {\n\t\tSelectFont(m_hdc, m_hOldFont);\n\t\tDeleteFont(hf);\n\t\tm_hOldFont = NULL;\n\t}\n\tfree(pNameFromGDI);\n\tfree(pNameFromFreeType);\n\treturn false;\n}\n\nunsigned long FreeTypeSysFontData::IoFunc(\n\t\t\tFT_Stream\t\tstream,\n\t\t\tunsigned long\toffset,\n\t\t\tunsigned char*\tbuffer,\n\t\t\tunsigned long\tcount )\n{\n\tif(count == 0){\n\t\treturn 0;\n\t}\n\n\tFreeTypeSysFontData * pThis = reinterpret_cast<FreeTypeSysFontData*>(stream->descriptor.pointer);\n\tAssert(pThis != NULL);\n\n\tDWORD result = 0;\n\tif (pThis->m_pMapping) {\n\t\tresult = Min(pThis->m_dwSize - offset, count);\n\t\tmemcpy(buffer, (const BYTE*)pThis->m_pMapping + offset, result);\n\t} else {\n\t\tresult = ::GetFontData(pThis->m_hdc, pThis->m_isTTC ? TVP_TT_TABLE_ttcf : 0, offset, buffer, count);\n\t\tif(result == GDI_ERROR) {\n\t\t\t// エラー\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn result;\n}\n\nvoid FreeTypeSysFontData::CloseFunc(FT_Stream stream)\n{\n\tFreeTypeSysFontData * pThis = reinterpret_cast<FreeTypeSysFontData*>(stream->descriptor.pointer);\n\tAssert(pThis != NULL);\n\n\tif(!pThis->m_locked)\n\t\tdelete pThis;\n}\n\nbool FreeTypeSysFontData::OpenFaceByIndex(int index)\n{\n\tif(m_ftFace) {\n\t\tFT_Done_Face(m_ftFace);\n\t\tm_ftFace = NULL;\n\t}\n\n\tFT_Open_Args args = { 0 };\n\targs.flags\t\t= FT_OPEN_STREAM;\n\targs.stream\t\t= &m_ftStream;\n\n\t// FreeType で扱えるか？\n\tFT_Error ftErrCode = FT_Open_Face(freetype_library, &args, index, &m_ftFace);\n#ifdef DEBUG\n\tif (ftErrCode!=0)\n\t\tTRACE(L\"Open face failed, error = %d\\n\", ftErrCode);\n#endif\n\treturn (ftErrCode == 0);\n}\n"
        },
        {
          "name": "fteng.h",
          "type": "blob",
          "size": 19.7490234375,
          "content": "#pragma once\n\n#include <ft2build.h>\n#include <freetype/freetype.h>\t/* FT_FREETYPE_H */\n#include <freetype/ftcache.h>\t/* FT_CACHE_H */\n#include <freetype/tttables.h>\n#include <freetype/tttags.h>\t// FT_TRUETYPE_TAGS_H\n#include <freetype/ftoutln.h>\n#include <vector>\n#include \"ftref.h\"\n#include <math.h>\n#include \"undocAPI.h\"\n\nclass FreeTypeFontEngine;\nextern FreeTypeFontEngine* g_pFTEngine;\nextern BOOL g_ccbCache;\nextern BOOL g_ccbIndividual;\nextern FTC_Manager    cache_man;\n\ntypedef set<CBitmapCache*> CTLSDCArray;\nextern CTLSDCArray TLSDCArray;\n\nLOGFONTW* GetFontNameFromFile(LPCTSTR Filename);\nbool GetFontLocalName(TCHAR* pszFontName, __out TCHAR* pszNameOut);\t//获得字体的本地化名称\n\nstruct CFontSetCache\n{\n\tconst CFontSettings** fontsetlist;\n\tint  fontsetsize;\n\tCFontSetCache()\n\t\t:fontsetsize(0)\n\t{\n\t\tfontsetsize=64;\n\t\tfontsetlist = (const CFontSettings**)malloc(fontsetsize * sizeof(void*));\n\t}\n\t~CFontSetCache()\n\t{\n\t\tfree(fontsetlist);\n\t}\n\tvoid Set(FTC_FaceID faceid, const CFontSettings& fset)\n\t{\n\t\twhile ((INT_PTR)faceid>=fontsetsize)\n\t\t{\n\t\t\tfontsetsize+=64;\n\t\t\tfontsetlist = (const CFontSettings**)realloc(fontsetlist, fontsetsize);\n\t\t}\n\t\tfontsetlist[(INT_PTR)faceid]=&fset;\n\t}\n\tconst CFontSettings*& Get(FTC_FaceID faceid) const\n\t{\n\t\treturn fontsetlist[(INT_PTR)faceid];\n\t}\n};\n\nstruct myfont\n{\n\twstring name;\n\tint hash;\n\tbool operator < (const myfont& mf) const {\n\t\treturn name==mf.name? hash<mf.hash: name<mf.name;\n\t}\npublic:\n\tmyfont(LPCWSTR lpFaceName, int nweight, int nitalic):\n\tname(lpFaceName),hash((nitalic<<31) | nweight)\n\t{}\n};\n\nenum FT_EngineConstants {\n\tFT_MAX_CHARS\t= 65536,\n};\n\n/*\n  FreeTypeに文字幅、太字、斜体をキャッシュする機構が無いのでそれらを補う\n\n  1. まずDllMain(DLL_PROCESS_ATTACH)でFreeTypeFontEngineのインスタンスが生成される。\n     (順番はCGdiPPSettings→FontLInit(FreeType)→FreeTypeFontEngine→フック)\n     ForceChangeFontもここで処理する。\n\n  2. CreateFontでFreeTypeFontEngine::AddFontが呼び出され、FreeTypeFontInfoと\n     フォント名を結びつける。\n     ついでにFreeTypeFontInfoはIndividualの設定をコピーして持つ。\n\n  3. ExtTextOutやGetTextExtentなどからFreeTypePrepare関数が呼び出されると\n     さらに内部でFreeTypeFontInfo::GetCacheが呼び出され、フォントサイズなどから\n     FreeTypeFontCacheを得る。無ければ生成する。\n     FreeTypeFontCacheは内部にFreeTypeCharDataのテーブル(UCS2なので2^16個)を\n     持っていて、FreeTypeCharDataには文字毎にキャッシュデータを保管する。\n\n  4. FreeTypeFontCacheから、文字またはグリフ番号を元にFreeTypeCharDataを得る。\n     キャッシュがあれば(メモリ中に残っていれば)、MRUカウンタをセットする。\n     無い場合は一旦スルーし、後でAddCharDataでキャッシュを追加する。\n\n  5. 追加しまくるとメモリを喰らうので、追加が一定数(FREETYPE_REQCOUNTMAX)を超えると\n     GCモドキで最近参照されたキャッシュデータをFREETYPE_GC_COUNTER個だけ残し、\n     それ以外のデータ(FreeTypeCharData)は開放される。\n     この2つの定数はiniで設定変更できた方がいいような気もする。\n\n  6. 最後に、DllMain(DLL_PROCESS_DETACH)でFreeTypeFontEngineのインスタンスが破棄され、\n     全てのキャッシュメモリが開放される。\n\n */\n\nclass FreeTypeGCCounter\n{\nprivate:\n\tint m_addcount;\t\t//追加用\n\tint m_mrucount;\t\t//MRU用\n\npublic:\n\tFreeTypeGCCounter()\n\t\t: m_addcount(0), m_mrucount(0)\n\t{\n\t}\n\tint AddIncrement() { return ++m_addcount; }\n\tint DecIncrement() { return --m_addcount; }\n\tint MruIncrement() { return ++m_mrucount; }\n\n\tvoid ResetGCCounter()\n\t{\n\t\tm_mrucount = 0;\n\t\tm_addcount = 0;\n\t}\n};\n\nclass FreeTypeMruCounter\n{\nprivate:\n\tint m_mrucounter;\t//GC用\n\npublic:\n\tFreeTypeMruCounter(int n)\n\t\t: m_mrucounter(n)\n\t{\n\t}\n\n\t//GC用MRUカウンタ\n\tint GetMruCounter() const { return m_mrucounter; }\n\tvoid ResetMruCounter() { m_mrucounter = 0; }\n\tvoid SetMruCounter(FreeTypeGCCounter* p) { m_mrucounter = p->MruIncrement(); }\n};\n\n//文字幅、(glyph index)、FT_BitmapGlyph(太字、斜体のみ)をキャッシュする\nclass FreeTypeCharData : public FreeTypeMruCounter\n{\nprivate:\n\ttypedef CValArray<FreeTypeCharData**>\tCharDataArray;\n\tCharDataArray\t\tm_arrSelfChar;\t//自分自身の保存元(Char)\n\tFreeTypeCharData**\tm_ppSelfGlyph;\t//(Glyph)\n\tUINT\t\t\t\tm_glyphindex;\t//グリフ番号\n\tint\t\t\t\t\tm_width;\t\t//文字幅\n\tint\t\t\t\t\tm_gdiWidth;\t\t//使用GetCharWidth获得的GDI宽度\n\tFT_Referenced_BitmapGlyph\t\tm_glyph;\t\t//カラー用\n\tFT_Referenced_BitmapGlyph\t\tm_glyphMono;\t//モノクロ用\n\tint\t\t\t\t\tm_bmpSize;\t\t//ビットマップサイズ\n\tint\t\t\t\t\tm_bmpMonoSize;\t// 〃\n\tint\t\t\t\t\tm_AAMode;\n//\tLONG\t\t\t\tm_refcounter;\t//参照カウンタ\n\n#ifdef _DEBUG\n\tWCHAR\t\t\t\tm_wch;\t\t\t//UCS2文字\n#endif\n\tNOCOPY(FreeTypeCharData);\n\n\t//FT_Bitmap::bufferのサイズを返す\n\tstatic inline int FT_Bitmap_CalcSize(FT_BitmapGlyph gl)\n\t{\n\t\treturn gl->bitmap.pitch * gl->bitmap.rows;\n\t}\n\npublic:\n\tFreeTypeCharData(FreeTypeCharData** ppCh, FreeTypeCharData** ppGl, WCHAR wch, UINT glyphindex, int width, int mru, int gdiWidth, int AAMode);\n\t~FreeTypeCharData();\n\n#ifdef _DEBUG\n\tWCHAR GetChar() const { return m_wch; }\n#else\n\tWCHAR GetChar() const { return L'?'; }\n#endif\n\tUINT GetGlyphIndex() const { return m_glyphindex; }\n\tint GetWidth() const { return m_width; }\n\tvoid SetWidth(int width) { m_width = width; }\n\tvoid SetGDIWidth(int width) { m_gdiWidth = width; }\n\tint GetGDIWidth() const {return m_gdiWidth; }\n\tint GetAAMode() const {return m_AAMode; }\n\tvoid AddChar(FreeTypeCharData** ppCh)\n\t{\n\t\tif (ppCh)\n\t\t\tm_arrSelfChar.Add(ppCh);\n\t}\n\tFT_Referenced_BitmapGlyph GetGlyph(FT_Render_Mode render_mode) const\n\t{\n\t\treturn (render_mode == FT_RENDER_MODE_MONO) ? m_glyphMono : m_glyph;\n\t}\n\tvoid SetGlyph(FT_Render_Mode render_mode, FT_Referenced_BitmapGlyph glyph);\n\n\tvoid Erase()\n\t{\n\t\t//delete this;\n\t}\n};\nstatic INT_PTR NULL_INT = NULL;\nclass FreeTypeFontCache : public FreeTypeMruCounter, public FreeTypeGCCounter\n{\n\ttypedef map<int, FreeTypeCharData*> GlyphCache;\n\nprivate:\n\tint  m_px;\n\tint  m_weight;\n\tbool m_italic;\n\tbool m_active;\n\tTEXTMETRIC m_tm;\n\n\t//4×65536×2＝512KBぐらいたかが知れてるので固定配列で問題無し\n#ifdef _USE_ARRAY\n\tFreeTypeCharData*\tm_chars[FT_MAX_CHARS];\n\tFreeTypeCharData*\tm_glyphs[FT_MAX_CHARS];\n#else\n\tGlyphCache m_GlyphCache;\n#endif\n\tNOCOPY(FreeTypeFontCache);\n\tvoid Compact();\n\n\tFreeTypeCharData** _GetChar(WCHAR wch)\n\t{\n#ifdef _USE_ARRAY\n\t\treturn m_chars + wch;\n#else\n\t\tGlyphCache::iterator it=m_GlyphCache.find(wch);\n\t\treturn it==m_GlyphCache.end()? reinterpret_cast<FreeTypeCharData**>(&NULL_INT): &(it->second);\n#endif\n\t}\n\tFreeTypeCharData** _GetGlyph(UINT glyph)\n\t{\n#ifdef _USE_ARRAY\n\t\treturn m_glyphs + glyph;\n#else\n\t\tGlyphCache::iterator it=m_GlyphCache.find(-(int)glyph);\n\t\treturn it == m_GlyphCache.end() ? reinterpret_cast<FreeTypeCharData**>(&NULL_INT) : &(it->second);\n#endif\n\t}\n\npublic:\n\tFreeTypeFontCache(/*int px, int weight, bool italic, */int mru);\n\t~FreeTypeFontCache();\n\n\tconst TEXTMETRIC& GetTextMetric(HDC hdc)\n\t{\n\t\tif (m_tm.tmHeight == 0) {\n\t\t\t::GetTextMetrics(hdc, &m_tm);\n\t\t}\n\t\treturn m_tm;\n\t}\n\n\tbool Equals(int px, int weight, bool italic) const\n\t{\n\t\treturn (m_px == px && m_weight == weight && m_italic == italic);\n\t}\n\tFreeTypeCharData* FindChar(WCHAR wch)\n\t{\n\t\t/*if (!g_ccbCache) return NULL;*/\n\t\tFreeTypeCharData* p = *_GetChar(wch);\n\t\tif(p) {\n\t\t\tp->SetMruCounter(this);\n\t\t}\n\t\treturn p;\n\t}\n\n\tFreeTypeCharData* FindGlyphIndex(UINT glyph)\n\t{\n\t\t/*if (!g_ccbCache) return NULL;*/\n\t\tFreeTypeCharData* p = (glyph & 0xffff0000) ? NULL : *_GetGlyph(glyph);\n\t\tif(p) {\n\t\t\tp->SetMruCounter(this);\n\t\t}\n\t\treturn p;\n\t}\n\n\tbool Activate()\n\t{\n\t\tif (!m_active) {\n\t\t\tm_active = true;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid Erase();\n\tvoid Deactive() { m_active = false; };\n\tvoid AddCharData(WCHAR wch, UINT glyphindex, int width, int gdiWidth, FT_Referenced_BitmapGlyph glyph, FT_Render_Mode render_mode, int AAMode);\n\tvoid AddGlyphData(UINT glyphindex, int width, int gdiWidth, FT_Referenced_BitmapGlyph glyph, FT_Render_Mode render_mode, int AAMode);\n};\n\n\n// フォント名とFaceID(intを使うことにする)\n//extern CFontSetCache g_fsetcache;\nextern CHashedStringList FontNameCache;\nclass FreeTypeFontInfo : public FreeTypeMruCounter, public FreeTypeGCCounter\n{\nprivate:\n\tINT_PTR  m_id;\n\tint  m_weight;\n\tbool m_italic;\n\tchar m_hashinting;\n\tint  m_ftWeight;\n\tint  m_os2Weight;\n\tint  m_nMaxSizes;\n\tint\t m_nFontFamily;\n\tHFONT m_ggoFont;\n\tTT_OS2* m_OS2Table;\n\tchar m_ebmps[256];\n\tLONG volatile count;\n\tCFontSettings m_set;\n\tStringHashFont m_hash;\n\twstring\tm_fullname, m_familyname;\n\ttypedef map<UINT, FreeTypeFontCache*>\tCacheArray;\n\tCacheArray m_cache;\n\t//快速链接\n\tFTC_FaceID face_id_link[CFontLinkInfo::FONTMAX * 2 + 1];\n\tHFONT ggo_link[CFontLinkInfo::FONTMAX * 2 + 1];\n\tbool m_linkinited;\n\tint m_linknum;\n\tFTC_FaceID m_SimSunID;\n\tNOCOPY(FreeTypeFontInfo);\n\tvoid Compact();\n\tvoid Createlink();\n\npublic:\n\tvoid AddRef() {InterlockedIncrement(&count);};\n\tvoid Release() {\n\t\tif (InterlockedDecrement(&count)==0)\n\t\t\tdelete this;\n\t}\n\tTT_OS2* GetOS2Table()\n\t{\n\t\tif (!m_OS2Table)\n\t\t{\n\t\t\tTT_OS2 * os2_table = NULL;\n\t\t\tFT_Face freetype_face;\n\t\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_MANAGER);\n\t\t\tif (FTC_Manager_LookupFace(cache_man, (FTC_FaceID)m_id, &freetype_face)) \n\t\t\t\treturn NULL;\n\t\t\tos2_table = (TT_OS2*) FT_Get_Sfnt_Table(freetype_face, ft_sfnt_os2);\n\t\t\tif (!os2_table) return NULL;\n\t\t\tm_OS2Table = new TT_OS2;\n\t\t\tmemcpy(m_OS2Table, os2_table, sizeof(TT_OS2));\n\t\t}\n\t\treturn m_OS2Table;\n\t}\n\tBOOL FontHasHinting()\n\t{\n\t\tif (m_hashinting==3)\n\t\t{\n\t\t\tFT_Face freetype_face;\n\t\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_MANAGER);\n\t\t\tif (FTC_Manager_LookupFace(cache_man, (FTC_FaceID)m_id, &freetype_face))\t//查询ft face\n\t\t\t{\n\t\t\t\tm_hashinting = false;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tFT_ULong length = 0;\n\t\t\tFT_Error err = FT_Load_Sfnt_Table(freetype_face, TTAG_fpgm, 0, NULL, &length);\t//获取fpgm表长度\n\t\t\tif (!err && length>50)\t\t//成功读取表，并且长度较长\n\t\t\t\tm_hashinting = true;\t\t//字体存在hinting\n\t\t\telse\n\t\t\t\tm_hashinting = false;\n\t\t}\n\t\treturn m_hashinting;\n\t}\n\twstring GetFullName() {return m_fullname;};\n\tbool m_isSimSun;\n\tbool IsPixel;\n\tUINT getCacheHash(int px, int weight, bool italic, int width) {return ((px<<20)|(width<<8)|(weight<<1)|(int)italic); };\t//计算一个hash值来定位cache\n\tFreeTypeFontInfo(int n, LPCTSTR name, int weight, bool italic, int mru, wstring fullname, wstring familyname)\n\t\t: m_id(n), m_weight(weight), m_italic(italic), m_OS2Table(NULL), IsPixel(false)\n\t\t, FreeTypeMruCounter(mru), m_isSimSun(false), m_ggoFont(NULL), m_linkinited(false), m_linknum(0), m_os2Weight(0)\n\t\t, m_SimSunID(0), count(1), m_fullname(fullname), m_familyname(familyname), m_hashinting(3), m_nFontFamily(0)\n\t{\n\t\t//m_set = set;\n\t\tmemset(m_ebmps, 0xff, sizeof(m_ebmps));\n\t\t\n\t\tenum { FTC_MAX_SIZES_DEFAULT = 4 };\n\t\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\n\t\tm_nMaxSizes = pSettings->CacheMaxSizes();\n\t\tif (!m_nMaxSizes)\n\t\t\tm_nMaxSizes = FTC_MAX_SIZES_DEFAULT;\n\t\t//extern BOOL g_EngineCreateFont;\n\t\t\tif (pSettings->FontSubstitutes() < SETTING_FONTSUBSTITUTE_ALL)\n\t\t\t\tm_ggoFont = CreateFont(10,0,0,0,weight,italic,0,0,DEFAULT_CHARSET,0,FONT_MAGIC_NUMBER,0,0,name);\t\n\t\t\t\t\t//use magic number to create unsubstitud font\n\t\t\telse\n\t\t\t\tm_ggoFont = CreateFont(10,0,0,0,weight,italic,0,0,DEFAULT_CHARSET,0,0,0,0,name);\n\t\t\tHDC hdc = CreateCompatibleDC(NULL);\n\t\t\tHFONT old = SelectFont(hdc, m_ggoFont);\n\t\t\t//获得字体的全称\n\t\t\n\t\t\tint nSize=GetOutlineTextMetrics(hdc, 0, NULL);\n\t\t\tif (nSize==0)\n\t\t\t\tm_fullname = L\"\";\n\t\t\telse\n\t\t\t//if (m_fullname.size()==0)\t//构造函数中不提供，自己获取\n\t\t\t{\n\t\t\t\tLPOUTLINETEXTMETRIC otm = (LPOUTLINETEXTMETRIC)malloc(nSize);\n\t\t\t\tmemset(otm, 0, nSize);\n\t\t\t\totm->otmSize = nSize;\n\t\t\t\tGetOutlineTextMetrics(hdc, nSize, otm);\n\t\t\t\tm_fullname = (wstring)(LPWSTR)((DWORD_PTR)otm + (DWORD_PTR)otm->otmpFullName);\n\t\t\t\tTCHAR * localname = (LPWSTR)((DWORD_PTR)otm+(DWORD_PTR)otm->otmpFamilyName);\n\t\t\t\twstring styleName = (wstring)(LPWSTR)((DWORD_PTR)otm + (DWORD_PTR)otm->otmpStyleName);\n\t\t\t\tm_fullname = MakeUniqueFontName(m_fullname, localname, styleName);\n\n\t\t\t\tTCHAR buff[LF_FACESIZE+1];\t\t\t\t\n\t\t\t\tGetFontLocalName(localname, buff);\n\t\t\t\tm_nFontFamily = otm->otmTextMetrics.tmPitchAndFamily & 0xF0;\t//获取字体家族，家族对应使用什么默认链接字体\n\t\t\t\tm_familyname = (wstring)buff;\n\t\t\t\tm_set = pSettings->FindIndividual(m_familyname.c_str());\n\t\t\t\tm_ftWeight = CalcBoldWeight(/*weight*/700);\n\t\t\t\tm_hash = StringHashFont(name);\n\t\t\t\tif (m_familyname.size()>0 && m_familyname.c_str()[0]==L'@')\t//附加一个@\n\t\t\t\t\tm_fullname = L'@'+m_fullname;\n\t\t\t\tfree(otm);\n\t\t\t}\n\t\t\tSelectFont(hdc, old);\n\t\t\tDeleteDC(hdc);\n\t\t\n\t\t\t//完成\n//\t\tg_EngineCreateFont = false;\n\t\tface_id_link[0]=(FTC_FaceID)NULL;\n\t\tggo_link[0] = NULL;\n\t\t//g_fsetcache.Set((FTC_FaceID)n, set);\n\t}\n\t~FreeTypeFontInfo()\n\t{\n\t\tErase();\n\t\tDeleteFont(m_ggoFont);\n\t\tif (m_OS2Table)\n\t\t\tdelete m_OS2Table;\n\t}\n\n\tHFONT GetGGOFont(){return m_ggoFont;};\n\tint CalcNormalWeight() const\n\t{\n\t\treturn m_set.GetNormalWeight();\n\t}\n\tint CalcBoldWeight(int weight) const\n\t{\n//\t\treturn weight - FW_NORMAL) / 8;\n//\t\treturn ((weight - FW_NORMAL) / 12) + (m_set.GetBoldWeight() << 2);\n\t\tweight = weight < FW_BOLD ? 0: /*(weight > FW_BOLD ?*/ 612;\n\t\tif (weight <= FW_NORMAL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn ((weight - FW_NORMAL) / 8) + (m_set.GetBoldWeight() << 2);\n\t}\n\tint CalcBoldWeight(const LOGFONT& lf) const\n\t{\n\t\treturn CalcBoldWeight(lf.lfWeight);\n\t}\n\tvoid CalcItalicSlant(FT_Matrix& matrix) const\n\t{\n\t\tmatrix.xx = 1 << 16;\n//\t\tmatrix.xy = 0x5800;\n\t\tmatrix.xy = (5 + m_set.GetItalicSlant()) << 12;\n\t\tmatrix.yx = 0;\n\t\tmatrix.yy = 1 << 16;\n\t}\n\n\tbool Equals(const StringHashFont& hash, int weight, bool italic) const\n\t{\n\t\tweight = CalcBoldWeight(weight);\n\t\treturn (m_ftWeight == weight && m_italic == italic && m_hash == hash);\n\t}\n\tvoid UpdateFontSetting()\n\t{\n\t\tm_ftWeight = CalcBoldWeight(700/*m_weight*/);\n\t\t//清除字体链接\n\t\tface_id_link[0]=NULL;\n\t\tggo_link[0]=NULL;\n\t\tm_linknum = 0;\n\t\tm_linkinited = false;\n\t\tm_SimSunID = 0;\n\t}\n\tint GetFTLink(FTC_FaceID** llplink)\n\t{\n\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_FONTLINK);\n\t\tif (!*face_id_link)\n\t\t\tCreatelink();\n\t\t*llplink = face_id_link;\n\t\treturn m_linknum;\n\t}\n\tint GetGGOLink(HFONT** llplink)\n\t{\n\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_FONTLINK);\n\t\tif (!*ggo_link)\n\t\t\tCreatelink();\n\t\t*llplink = ggo_link;\n\t\treturn m_linknum;\n\t}\n\tFTC_FaceID GetSimSunID() {return m_SimSunID;}\n\n\tINT_PTR GetId() const { return m_id; }\n\tLPCTSTR GetName() const { return m_hash.c_str(); }\n\tint GetFontWeight() const { return m_weight; }\n\tint GetExactBoldWeight() const {return m_set.GetBoldWeight(); }\n\tint GetFTWeight() const { return m_ftWeight; }\n\tbool IsItalic() const { return m_italic; }\n\tconst StringHashFont& GetHash() const { return m_hash; }\n\n\tconst CFontSettings& GetFontSettings() const { return m_set; }\n\tvoid SetFontSettings(const CFontSettings& set) { m_set = set;};\n\tbool operator ==(const FreeTypeFontInfo& x) const { return (m_hash == x.m_hash); }\n\n\tFreeTypeFontCache* GetCache(FTC_ScalerRec& scaler, const LOGFONT& lf);\n\tbool EmbeddedBmpExist(int px);\n\tvoid Erase()\n\t{\n\t\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_FONTCACHE);\n\t\tCacheArray::iterator it = m_cache.begin();\n\t\tfor (;it!=m_cache.end();++it)\n\t\t{\n\t\t\tdelete it->second;\n\t\t}\n\t\tm_cache.clear();\n\t}\n};\n\nclass FreeTypeFontEngine : public FreeTypeGCCounter\n{\nprivate:\n\t//typedef CArray<FreeTypeFontInfo*>\tFontListArray;\n\ttypedef map<myfont, FreeTypeFontInfo*> FontMap;\n\ttypedef map<wstring, FreeTypeFontInfo*> FullNameMap;\n\ttypedef vector<FreeTypeFontInfo*> FontList;\n\t//FontListArray\tm_arrFontList;\n\tint\t\t\t\tm_nMaxFaces;\n\tint\t\t\t\tm_nMemUsed;\n\tbool\t\t\tm_bAddOnFind;\n\tFontMap\t\t\tm_mfontMap;\n\tFullNameMap\t\tm_mfullMap;\n\tFontList\t\tm_mfontList;\n\tFT_Face*\t\tm_arrFace;\n\tint\t\t\t\tm_nFaceCount;\n\tvoid Compact();\n\tint GrowFace()\n\t{\n\t\tFT_Face* a=(FT_Face*)malloc(m_nFaceCount*sizeof(FT_Face));\n\t\tmemcpy(a, m_arrFace, sizeof(FT_Face)*m_nFaceCount);\n\t\tm_nFaceCount+=64;\n\t\tm_arrFace = (FT_Face*)realloc(m_arrFace, sizeof(FT_Face) * m_nFaceCount);\n\t\tmemset(m_arrFace+m_nFaceCount-64, 0, sizeof(FT_Face)*64);\n\t\tfor (int i=0;i<m_nFaceCount-64;i++)\n\t\t\tAssert(a[i]==m_arrFace[i]);\n\t\tfree(a);\n\t\treturn m_nFaceCount;\n\t}\n\npublic:\n\tFreeTypeFontEngine()\n\t\t: m_nMemUsed(0), m_nMaxFaces(0), m_bAddOnFind(false), m_nFaceCount(64)\n\t{\n\t\tenum { FTC_MAX_FACES_DEFAULT = 2 };\n\t\tconst CGdippSettings* pSettings = CGdippSettings::GetInstanceNoInit();\n\t\tm_nMaxFaces = pSettings->CacheMaxFaces();\n\t\tif (m_nMaxFaces == 0)\n\t\t\tm_nMaxFaces = FTC_MAX_FACES_DEFAULT;\n\t\t//m_arrFace = (FT_Face*)malloc(m_nFaceCount*sizeof(FT_Face));\n\t\t//memset(m_arrFace, 0, sizeof(FT_Face)*m_nFaceCount);\n\t}\n\t~FreeTypeFontEngine()\n\t{\n\t\tTRACE(_T(\"MaxFaces: %d\\n\"), m_mfontMap.size());\n\t\tTRACE(_T(\"MemUsed : %d\\n\"), m_nMemUsed);\n\t\t//FontListArray& arr = m_arrFontList;\n\t\tFullNameMap::const_iterator iter=m_mfullMap.begin();\n\t\tfor (;iter!=m_mfullMap.end();++iter)\n\t\t\titer->second->Release();\n\t\t//free(m_arrFace);\n\t}\n\tint CalcBoldWeight(int weight) const\n\t{\n\t\treturn weight < FW_BOLD ? 0: FW_BOLD;\n\t}\n\tFreeTypeFontInfo* AddFont(LPCTSTR lpFaceName, int weight, bool italic, BOOL* bIsFontLoaded = NULL);\n\tFreeTypeFontInfo* AddFont(void* lpparams);\n\tint  GetFontIdByName(LPCTSTR lpFaceName, int weight, bool italic);\n//\tLPCTSTR GetFontById(int faceid, int& weight, bool& italic);\n\tFreeTypeFontInfo* FindFont(LPCTSTR lpFaceName, int weight, bool italic, bool AddOnFind = true, BOOL* bIsFontLoaded=NULL);\n\tFreeTypeFontInfo* FindFont(int faceid);\n\tFreeTypeFontInfo* FindFont(void* lpparams);\n\n\tbool FontExists(LPCTSTR lpFaceName, int weight, bool italic)\n\t{\n\t\treturn !!FindFont(lpFaceName, weight, italic);\n\t}\n\tBOOL RemoveFont(LPCWSTR FontName);\n\tBOOL RemoveFont(FreeTypeFontInfo* fontinfo);\n\tBOOL RemoveThisFont(FreeTypeFontInfo* fontinfo, LOGFONT* lg);\n\t//メモリ使用量カウンタ\n\tvoid AddMemUsed(int x)\n\t{\n\t\tm_nMemUsed += x;\n\t}\n\tvoid SubMemUsed(int x)\n\t{\n\t\tm_nMemUsed -= x;\n\t\tif (m_nMemUsed < 0)\n\t\t\tm_nMemUsed = 0;\n\t}\n\ttemplate <class T>\n\tvoid AddMemUsedObj(T* /*p*/)\n\t{\n\t\tAddMemUsed(sizeof(T));\n\t}\n\ttemplate <class T>\n\tvoid SubMemUsedObj(T* /*p*/)\n\t{\n\t\tSubMemUsed(sizeof(T));\n\t}\n\tvoid ReloadAll()\n\t{\n\t\t//重新载入全部字体，即清空所有字体缓存\n\t\tCOwnedCriticalSectionLock __olock(2);\n\t\tCCriticalSectionLock __lock;\n\t\tCGdippSettings* pSettings = CGdippSettings::GetInstance();\n\t\t\n\t\tFullNameMap::const_iterator iter=m_mfullMap.begin();\n\t\tfor (;iter!=m_mfullMap.end();)\n\t\t{\n\t\t\tFreeTypeFontInfo* p =iter->second;\n\t\t\tif (p)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t\t\t\t\tif (p->GetFullName()!=iter->first)\t//是替换字体\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tp->Release();\t//释放掉多重引用\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tm_mfullMap.erase(iter++);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}*/\n\t\t\n\t\t\t\tp->Erase();\n\t\t\t\tp->SetFontSettings(pSettings->FindIndividual(p->GetName()));\n\t\t\t\tp->UpdateFontSetting();\n\t\t\t}\n\t\t\t++iter;\n\t\t}\n\t\t//m_mfontMap.clear();\n\t}\n};\n\n//GetFontDataのメモリストリーム\nclass FreeTypeSysFontData\n{\nprivate:\n\tHDC\t\tm_hdc;\n\tHFONT\tm_hOldFont;\n\tbool\tm_isTTC;\n\tbool\tm_locked;\n\tvoid*\tm_pMapping;\n\tDWORD\tm_dwSize;\n\tFT_Face\tm_ftFace;\n\twstring m_name;\n\tFT_StreamRec m_ftStream;\n\n\tFreeTypeSysFontData()\n\t\t: m_hdc(NULL)\n\t\t, m_hOldFont(NULL)\n\t\t, m_isTTC(false)\n\t\t, m_locked(false)\n\t\t, m_pMapping(NULL)\n\t\t, m_dwSize(0)\n\t\t, m_ftFace(NULL)\n\t{\n\t\tZeroMemory(&m_ftStream, sizeof(FT_StreamRec));\n\t}\n\n\tstatic unsigned long IoFunc(FT_Stream stream, unsigned long offset, unsigned char* buffer, unsigned long count);\n\tstatic void CloseFunc(FT_Stream  stream);\n\tbool OpenFaceByIndex(int index);\n\tbool Init(LPCTSTR name, int weight, bool italic);\n\npublic:\n\tstatic FreeTypeSysFontData* CreateInstance(LPCTSTR name, int weight, bool italic);\n\t~FreeTypeSysFontData()\n\t{\n\t\tif (m_pMapping) {\n\t\t\tUnmapViewOfFile(m_pMapping);\n\t\t}\n\t\tif (m_hOldFont) {\n\t\t\tDeleteFont(SelectFont(m_hdc, m_hOldFont));\n\t\t}\n\t\tif (m_hdc) {\n\t\t\tDeleteDC(m_hdc);\n\t\t}\n\t}\n\n\tFT_Face GetFace()\n\t{\n\t\tFT_Face face = m_ftFace;\n\t\tm_ftFace = NULL;\n\t\treturn face;\n\t}\n};\n"
        },
        {
          "name": "ftref.c",
          "type": "blob",
          "size": 1.1552734375,
          "content": "#include \"ftref.h\"\n\n#define InterlockedIncrementInt(x) InterlockedIncrement((volatile LONG *)&(x))\n#define InterlockedDecrementInt(x) InterlockedDecrement((volatile LONG *)&(x))\n#define InterlockedExchangeInt(x, y) InterlockedExchange((volatile LONG *)&(x), LONG(y))\n\nFT_Error FT_Glyph_Ref_Copy( FT_Referenced_Glyph source,  FT_Referenced_Glyph *target )\n{\n\tif (source->refcount<0)\n\t\treturn 1;\n\tif (source->ft_glyph->format == FT_GLYPH_FORMAT_NONE)\n\t\treturn 2;\n\tInterlockedIncrementInt(source->refcount);\n\t*target = source;\n\treturn 0;\n}\n\nvoid FT_Done_Ref_Glyph( FT_Referenced_Glyph *glyph )\n{\n\tif (InterlockedDecrementInt((*glyph)->refcount) == 0)\n\t{\n\t\tif ((*glyph)->ft_glyph && (*glyph)->ft_glyph->library)\n\t\t\tFT_Done_Glyph((*glyph)->ft_glyph);\n\t\tfree(*glyph);\n\t}\n\t*glyph = NULL;\n}\n\nvoid FT_Glyph_To_Ref_Glyph( FT_Glyph source, FT_Referenced_Glyph *target)\n{\n\t*target = (FT_Referenced_Glyph)malloc(sizeof(FT_Referenced_GlyphRec));\n\t(*target)->ft_glyph = source;\n\t(*target)->refcount = 1;\n}\n\nFT_Referenced_Glyph New_FT_Ref_Glyph()\n{\n\tFT_Referenced_Glyph copy = (FT_Referenced_Glyph)malloc(sizeof(FT_Referenced_GlyphRec));\n\tcopy->ft_glyph = NULL;\n\tcopy->refcount = 1;\n\treturn copy;\n}\n"
        },
        {
          "name": "ftref.h",
          "type": "blob",
          "size": 0.5859375,
          "content": "#include <freetype/ftglyph.h>\n#include <Windows.h>\n\n#ifdef __cplusplus\nextern \"C\"{\n#endif\n\ntypedef struct  \n{\n\tFT_Glyph ft_glyph;\n\tint refcount;\n}FT_Referenced_GlyphRec, *FT_Referenced_Glyph;\n\ntypedef struct  \n{\n\tFT_BitmapGlyph ft_glyph;\n\tint refcount;\n}FT_Referenced_BitmapGlyphRec, *FT_Referenced_BitmapGlyph;\n\nFT_Error FT_Glyph_Ref_Copy( FT_Referenced_Glyph source,  FT_Referenced_Glyph *target );\nvoid FT_Done_Ref_Glyph( FT_Referenced_Glyph  *glyph );\nvoid FT_Glyph_To_Ref_Glyph( FT_Glyph source, FT_Referenced_Glyph *target);\nFT_Referenced_Glyph New_FT_Ref_Glyph();\n\n#ifdef __cplusplus\n}\n#endif\n"
        },
        {
          "name": "gdiPlusFlat2.cpp",
          "type": "blob",
          "size": 1.6162109375,
          "content": "#include \"gdiPlusFlat2.h\"\n#include <tchar.h>\n\n\nGdipDrawString pfnGdipDrawString = NULL;\nGdipGetBrushType pfnGdipGetBrushType = NULL;\nGdipGetDC pfnGdipGetDC = NULL;\nGdipGetLogFontW pfnGdipGetLogFontW = NULL;\nGdipGetSolidFillColor pfnGdipGetSolidFillColor = NULL;\nGdipGetStringFormatAlign pfnGdipGetStringFormatAlign = NULL;\nGdipGetStringFormatHotkeyPrefix pfnGdipGetStringFormatHotkeyPrefix = NULL;\nGdipGetStringFormatTrimming pfnGdipGetStringFormatTrimming = NULL;\nGdipReleaseDC pfnGdipReleaseDC = NULL;\n\nbool InitGdiplusFuncs(){\n\tstatic bool bInited = false;\n\tif (!bInited)\n\t{\n\t\tbInited = true;\n\t\tHMODULE\thGdiplusDll = GetModuleHandle(_T(\"Gdiplus.dll\"));\n\t\tif (hGdiplusDll)\n\t\t{\n\t\t\tpfnGdipDrawString = (GdipDrawString)GetProcAddress(hGdiplusDll, \"GdipDrawString\");\n\t\t\tpfnGdipGetBrushType = (GdipGetBrushType)GetProcAddress(hGdiplusDll, \"GdipGetBrushType\");\n\t\t\tpfnGdipGetDC = (GdipGetDC)GetProcAddress(hGdiplusDll, \"GdipGetDC\");\n\t\t\tpfnGdipGetLogFontW = (GdipGetLogFontW)GetProcAddress(hGdiplusDll, \"GdipGetLogFontW\");\n\t\t\tpfnGdipGetSolidFillColor = (GdipGetSolidFillColor)GetProcAddress(hGdiplusDll, \"GdipGetSolidFillColor\");\n\t\t\tpfnGdipGetStringFormatAlign = (GdipGetStringFormatAlign)GetProcAddress(hGdiplusDll, \"GdipGetStringFormatAlign\");\n\t\t\tpfnGdipGetStringFormatHotkeyPrefix = (GdipGetStringFormatHotkeyPrefix)GetProcAddress(hGdiplusDll, \"GdipGetStringFormatHotkeyPrefix\");\n\t\t\tpfnGdipGetStringFormatTrimming = (GdipGetStringFormatTrimming)GetProcAddress(hGdiplusDll, \"GdipGetStringFormatTrimming\");\n\t\t\tpfnGdipReleaseDC = (GdipReleaseDC)GetProcAddress(hGdiplusDll, \"GdipReleaseDC\");\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\treturn false;\n\t}\n\telse\n\t\treturn true;\n}\n"
        },
        {
          "name": "gdiPlusFlat2.h",
          "type": "blob",
          "size": 2.2705078125,
          "content": "#ifndef _GDIPLUSFLAT_H\n#define _GDIPLUSFLAT_H\n\n#include <Windows.h>\n#include \"GdiPlusTypes2.h\"\n#include <GdiPlusEnums.h>\n#include <GdiplusGpStubs.h>\n#include <GdiPlusPixelFormats.h>\n\n#define GDIPCONST const\n#define WINGDIPAPI __stdcall\ntypedef Status GpStatus;\n\ntypedef GpStatus (WINGDIPAPI*\nGdipDrawString)(\n\t\t\t   GpGraphics               *graphics,\n\t\t\t   GDIPCONST WCHAR          *string,\n\t\t\t   INT                       length,\n\t\t\t   GDIPCONST GpFont         *font,\n\t\t\t   GDIPCONST RectF          *layoutRect,\n\t\t\t   GDIPCONST GpStringFormat *stringFormat,\n\t\t\t   GDIPCONST GpBrush        *brush\n\t\t\t   );//绘制文字的函数\n\ntypedef GpStatus (WINGDIPAPI*\nGdipGetLogFontW)(GpFont * font, GpGraphics *graphics, LOGFONTW * logfontW);//从GPFont获取Logfont\n\ntypedef GpStatus (WINGDIPAPI*\nGdipGetDC)(GpGraphics* graphics, HDC * hdc);\t//从GPGraphic获取HDC\n\ntypedef GpStatus (WINGDIPAPI*\nGdipReleaseDC)(GpGraphics* graphics, HDC hdc);\n\ntypedef GpStatus (WINGDIPAPI*\nGdipGetStringFormatAlign)(GDIPCONST GpStringFormat *format, \n\t\t\t\t\t\t StringAlignment *align);\n\ntypedef GpStatus (WINGDIPAPI*\nGdipGetStringFormatTrimming)(\n\t\t\t\t\t\t\tGDIPCONST GpStringFormat *format,\n\t\t\t\t\t\t\tStringTrimming       *trimming\n\t\t\t\t\t\t\t);\t//获取字符串的缩略方式。当字符串长度超过矩形长度时，将使用设置的方式删除中间的部分文字。\n\t\t\t\t\t\t\t\t//转换成GDI后应使用DrawText来模拟。\ntypedef GpStatus (WINGDIPAPI*\nGdipGetStringFormatHotkeyPrefix)(GDIPCONST GpStringFormat *format, \n\t\t\t\t\t\t\t\tINT *hotkeyPrefix);\t//获取&符号的显示方式，隐藏，显示下划线或者不处理&。由DrawText模拟。\n\ntypedef GpStatus (WINGDIPAPI*\nGdipGetBrushType)(GpBrush *brush, GpBrushType *type);\n\ntypedef GpStatus (WINGDIPAPI*\nGdipGetSolidFillColor)(GpSolidFill *brush, ARGB *color);\t//获取单色Brush的颜色\n\nextern GdipDrawString pfnGdipDrawString ;\nextern GdipGetBrushType pfnGdipGetBrushType ;\nextern GdipGetDC pfnGdipGetDC ;\nextern GdipGetLogFontW pfnGdipGetLogFontW ;\nextern GdipGetSolidFillColor pfnGdipGetSolidFillColor ;\nextern GdipGetStringFormatAlign pfnGdipGetStringFormatAlign ;\nextern GdipGetStringFormatHotkeyPrefix pfnGdipGetStringFormatHotkeyPrefix ;\nextern GdipGetStringFormatTrimming pfnGdipGetStringFormatTrimming ;\nextern GdipReleaseDC pfnGdipReleaseDC ;\n\nbool InitGdiplusFuncs();\n\n#endif\n"
        },
        {
          "name": "gdidll.rc",
          "type": "blob",
          "size": 2.9375,
          "content": "// Microsoft Visual C++ generated resource script.\r\n//\r\n#pragma code_page(65001)\r\n\r\n#include \"resource.\"\r\n\r\n#define APSTUDIO_READONLY_SYMBOLS\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Generated from the TEXTINCLUDE 2 resource.\r\n//\r\n#include \"afxres.h\"\r\r\n/////////////////////////////////////////////////////////////////////////////\r\n#undef APSTUDIO_READONLY_SYMBOLS\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Neutral (Sys. Default) resources\r\n\r\n#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_NEUSD)\r\nLANGUAGE LANG_NEUTRAL, SUBLANG_SYS_DEFAULT\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Version\r\n//\r\n\r\nVS_VERSION_INFO VERSIONINFO\r\n FILEVERSION 1,2024,815,1\r\n PRODUCTVERSION 1,2024,815,1\r\n FILEFLAGSMASK 0x8L\r\n#ifdef _DEBUG\r\n FILEFLAGS 0xbL\r\n#else\r\n FILEFLAGS 0xaL\r\n#endif\r\n FILEOS 0x40004L\r\n FILETYPE 0x2L\r\n FILESUBTYPE 0x0L\r\nBEGIN\r\n    BLOCK \"StringFileInfo\"\r\n    BEGIN\r\n        BLOCK \"000004b0\"\r\n        BEGIN\r\n            VALUE \"Comments\", \"Portions of this software are copyright (c) 2005-2021 The FreeType Project (www.freetype.org). All rights reserved.\"\r\n            VALUE \"CompanyName\", \"2ch & THEMEX & everyone\"\r\n            VALUE \"FileDescription\", \"The Ultimate Font Rasterizer\"\r\n            VALUE \"FileVersion\", \"1.2024.815.1\"\r\n            VALUE \"InternalName\", \"MacType\"\r\n            VALUE \"LegalCopyright\", \"(C) 460, 168, Higambana, 555 and sy567. All rights reserved. FlyingSnow republished\"\r\n            VALUE \"OriginalFilename\", \"MacType.dll\"\r\n            VALUE \"ProductName\", \"The Ultimate Font Rasterizer\"\r\n            VALUE \"ProductVersion\", \"1.2024.815.1\"\r\n            VALUE \"URL\", \"http://www.mactype.net http://drwatson.nobody.jp/gdi++/\"\r\n        END\r\n    END\r\n    BLOCK \"VarFileInfo\"\r\n    BEGIN\r\n        VALUE \"Translation\", 0x0, 1200\r\n    END\r\nEND\r\n\r\n#endif    // Neutral (Sys. Default) resources\r\n/////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Chinese (Simplified, China) resources\r\n\r\n#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)\r\nLANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED\r\n\r\n#ifdef APSTUDIO_INVOKED\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// TEXTINCLUDE\r\n//\r\n\r\n1 TEXTINCLUDE \r\nBEGIN\r\n    \"resource.\\0\"\r\nEND\r\n\r\n3 TEXTINCLUDE \r\nBEGIN\r\n    \"\\r\\0\"\r\nEND\r\n\r\n2 TEXTINCLUDE \r\nBEGIN\r\n    \"#include \"\"afxres.h\"\"\\r\\0\"\r\nEND\r\n\r\n#endif    // APSTUDIO_INVOKED\r\n\r\n#endif    // Chinese (Simplified, China) resources\r\n/////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n#ifndef APSTUDIO_INVOKED\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Generated from the TEXTINCLUDE 3 resource.\r\n//\r\n\r\r\n/////////////////////////////////////////////////////////////////////////////\r\n#endif    // not APSTUDIO_INVOKED\r\n\r\n"
        },
        {
          "name": "gdipp.icproj",
          "type": "blob",
          "size": 0.6005859375,
          "content": "<?xml version=\"1.0\" encoding=\"gb2312\"?>\n<VisualStudioProject\n\tProjectType=\"Intel C++ Project\"\n\tVersion=\"11.1\"\n\tName=\"MacType\"\n\tProjectGUID=\"{DC95DDFA-6291-4CEC-A3B8-FF825137805B}\"\n\tVCNestedProjectGUID=\"{15C33FD9-0811-4981-B08F-E0BAD74A3028}\"\n\tVCNestedProjectFileName=\"gdipp.vcproj\">\n\t<Configurations>\n\t\t<Configuration\n\t\t\tName=\"Release|Win32\">\n\t\t\t<Tool\n\t\t\t\tName=\"CppCmplrTool\"\n\t\t\t\tEnableEnhancedInstructionSet=\"1000\"\n\t\t\t\tGenerateAlternateCodePaths=\"2\"\n\t\t\t\tUseProcessorExtensions=\"2\"\n\t\t\t\tCpp0xSupport=\"true\"\n\t\t\t\tRecognizeRestrictKeyword=\"true\"/>\n\t\t</Configuration>\n\t</Configurations>\n\t<Files/>\n</VisualStudioProject>\n"
        },
        {
          "name": "gdipp.sln",
          "type": "blob",
          "size": 6.1064453125,
          "content": "Microsoft Visual Studio Solution File, Format Version 12.00\r\n# Visual Studio Version 17\r\nVisualStudioVersion = 17.4.33103.184\r\nMinimumVisualStudioVersion = 10.0.40219.1\r\nProject(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"MacType\", \"gdipp.vcxproj\", \"{15C33FD9-0811-4981-B08F-E0BAD74A3028}\"\r\nEndProject\r\nProject(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"macloader\", \"macloader.vcxproj\", \"{6D6AC860-BA16-4BE7-9169-21787F21CB6F}\"\r\nEndProject\r\nGlobal\r\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\r\n\t\tDebug Infinality|Win32 = Debug Infinality|Win32\r\n\t\tDebug Infinality|x64 = Debug Infinality|x64\r\n\t\tDebug|Win32 = Debug|Win32\r\n\t\tDebug|x64 = Debug|x64\r\n\t\tRel+Detours|Win32 = Rel+Detours|Win32\r\n\t\tRel+Detours|x64 = Rel+Detours|x64\r\n\t\tRel+Trace|Win32 = Rel+Trace|Win32\r\n\t\tRel+Trace|x64 = Rel+Trace|x64\r\n\t\tRelease Infinality|Win32 = Release Infinality|Win32\r\n\t\tRelease Infinality|x64 = Release Infinality|x64\r\n\t\tRelease|Win32 = Release|Win32\r\n\t\tRelease|x64 = Release|x64\r\n\t\tRelease+StaticHook|Win32 = Release+StaticHook|Win32\r\n\t\tRelease+StaticHook|x64 = Release+StaticHook|x64\r\n\tEndGlobalSection\r\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Debug Infinality|Win32.ActiveCfg = Debug Infinality|Win32\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Debug Infinality|Win32.Build.0 = Debug Infinality|Win32\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Debug Infinality|x64.ActiveCfg = Debug Infinality|x64\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Debug Infinality|x64.Build.0 = Debug Infinality|x64\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Debug|Win32.ActiveCfg = Debug|Win32\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Debug|Win32.Build.0 = Debug|Win32\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Debug|x64.ActiveCfg = Debug|x64\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Debug|x64.Build.0 = Debug|x64\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Rel+Detours|Win32.ActiveCfg = Rel+Detours|Win32\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Rel+Detours|Win32.Build.0 = Rel+Detours|Win32\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Rel+Detours|x64.ActiveCfg = Rel+Detours|x64\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Rel+Detours|x64.Build.0 = Rel+Detours|x64\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Rel+Trace|Win32.ActiveCfg = Rel+Trace|Win32\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Rel+Trace|Win32.Build.0 = Rel+Trace|Win32\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Rel+Trace|x64.ActiveCfg = Rel+Trace|x64\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Rel+Trace|x64.Build.0 = Rel+Trace|x64\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Release Infinality|Win32.ActiveCfg = Release Infinality|Win32\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Release Infinality|Win32.Build.0 = Release Infinality|Win32\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Release Infinality|x64.ActiveCfg = Release Infinality|x64\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Release Infinality|x64.Build.0 = Release Infinality|x64\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Release|Win32.ActiveCfg = Release|Win32\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Release|Win32.Build.0 = Release|Win32\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Release|x64.ActiveCfg = Release|x64\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Release|x64.Build.0 = Release|x64\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Release+StaticHook|Win32.ActiveCfg = Release+StaticHook|Win32\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Release+StaticHook|Win32.Build.0 = Release+StaticHook|Win32\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Release+StaticHook|x64.ActiveCfg = Release+StaticHook|x64\r\n\t\t{15C33FD9-0811-4981-B08F-E0BAD74A3028}.Release+StaticHook|x64.Build.0 = Release+StaticHook|x64\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Debug Infinality|Win32.ActiveCfg = Debug|Win32\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Debug Infinality|Win32.Build.0 = Debug|Win32\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Debug Infinality|x64.ActiveCfg = Debug|x64\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Debug Infinality|x64.Build.0 = Debug|x64\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Debug|Win32.ActiveCfg = Debug|Win32\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Debug|Win32.Build.0 = Debug|Win32\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Debug|x64.ActiveCfg = Debug|x64\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Debug|x64.Build.0 = Debug|x64\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Rel+Detours|Win32.ActiveCfg = Release|Win32\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Rel+Detours|Win32.Build.0 = Release|Win32\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Rel+Detours|x64.ActiveCfg = Release|x64\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Rel+Detours|x64.Build.0 = Release|x64\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Rel+Trace|Win32.ActiveCfg = Release|Win32\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Rel+Trace|Win32.Build.0 = Release|Win32\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Rel+Trace|x64.ActiveCfg = Release|x64\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Rel+Trace|x64.Build.0 = Release|x64\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Release Infinality|Win32.ActiveCfg = Release|Win32\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Release Infinality|Win32.Build.0 = Release|Win32\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Release Infinality|x64.ActiveCfg = Release|x64\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Release Infinality|x64.Build.0 = Release|x64\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Release|Win32.ActiveCfg = Release|Win32\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Release|Win32.Build.0 = Release|Win32\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Release|x64.ActiveCfg = Release|x64\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Release|x64.Build.0 = Release|x64\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Release+StaticHook|Win32.ActiveCfg = Release|Win32\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Release+StaticHook|Win32.Build.0 = Release|Win32\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Release+StaticHook|x64.ActiveCfg = Release|x64\r\n\t\t{6D6AC860-BA16-4BE7-9169-21787F21CB6F}.Release+StaticHook|x64.Build.0 = Release|x64\r\n\tEndGlobalSection\r\n\tGlobalSection(SolutionProperties) = preSolution\r\n\t\tHideSolutionNode = FALSE\r\n\tEndGlobalSection\r\n\tGlobalSection(ExtensibilityGlobals) = postSolution\r\n\t\tSolutionGuid = {3F209D78-C531-4FA9-941E-68BEF65161FD}\r\n\tEndGlobalSection\r\nEndGlobal\r\n"
        },
        {
          "name": "gdipp.vcxproj",
          "type": "blob",
          "size": 48.380859375,
          "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n  <ItemGroup Label=\"ProjectConfigurations\">\r\n    <ProjectConfiguration Include=\"Debug Infinality|Win32\">\r\n      <Configuration>Debug Infinality</Configuration>\r\n      <Platform>Win32</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Debug Infinality|x64\">\r\n      <Configuration>Debug Infinality</Configuration>\r\n      <Platform>x64</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Debug|Win32\">\r\n      <Configuration>Debug</Configuration>\r\n      <Platform>Win32</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Debug|x64\">\r\n      <Configuration>Debug</Configuration>\r\n      <Platform>x64</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"EXE|Win32\">\r\n      <Configuration>EXE</Configuration>\r\n      <Platform>Win32</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"EXE|x64\">\r\n      <Configuration>EXE</Configuration>\r\n      <Platform>x64</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Rel+Detours|Win32\">\r\n      <Configuration>Rel+Detours</Configuration>\r\n      <Platform>Win32</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Rel+Detours|x64\">\r\n      <Configuration>Rel+Detours</Configuration>\r\n      <Platform>x64</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Rel+Trace|Win32\">\r\n      <Configuration>Rel+Trace</Configuration>\r\n      <Platform>Win32</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Rel+Trace|x64\">\r\n      <Configuration>Rel+Trace</Configuration>\r\n      <Platform>x64</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Release Infinality|Win32\">\r\n      <Configuration>Release Infinality</Configuration>\r\n      <Platform>Win32</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Release Infinality|x64\">\r\n      <Configuration>Release Infinality</Configuration>\r\n      <Platform>x64</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Release+StaticHook|Win32\">\r\n      <Configuration>Release+StaticHook</Configuration>\r\n      <Platform>Win32</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Release+StaticHook|x64\">\r\n      <Configuration>Release+StaticHook</Configuration>\r\n      <Platform>x64</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Release|Win32\">\r\n      <Configuration>Release</Configuration>\r\n      <Platform>Win32</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Release|x64\">\r\n      <Configuration>Release</Configuration>\r\n      <Platform>x64</Platform>\r\n    </ProjectConfiguration>\r\n  </ItemGroup>\r\n  <PropertyGroup Label=\"Globals\">\r\n    <ProjectName>MacType</ProjectName>\r\n    <ProjectGuid>{15C33FD9-0811-4981-B08F-E0BAD74A3028}</ProjectGuid>\r\n    <RootNamespace>gdipp</RootNamespace>\r\n    <Keyword>Win32Proj</Keyword>\r\n    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>\r\n  </PropertyGroup>\r\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\" Label=\"Configuration\">\r\n    <ConfigurationType>Application</ConfigurationType>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n    <WholeProgramOptimization>true</WholeProgramOptimization>\r\n    <PlatformToolset>v143</PlatformToolset>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Rel+Detours|Win32'\" Label=\"Configuration\">\r\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n    <WholeProgramOptimization>true</WholeProgramOptimization>\r\n    <PlatformToolset>v143</PlatformToolset>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release+StaticHook|Win32'\" Label=\"Configuration\">\r\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n    <WholeProgramOptimization>true</WholeProgramOptimization>\r\n    <PlatformToolset>v143</PlatformToolset>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Rel+Trace|Win32'\" Label=\"Configuration\">\r\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n    <WholeProgramOptimization>true</WholeProgramOptimization>\r\n    <PlatformToolset>v143</PlatformToolset>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release Infinality|Win32'\" Label=\"Configuration\">\r\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\r\n    <PlatformToolset>v143</PlatformToolset>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n    <WholeProgramOptimization>true</WholeProgramOptimization>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\" Label=\"Configuration\">\r\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\r\n    <PlatformToolset>v143</PlatformToolset>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug Infinality|Win32'\" Label=\"Configuration\">\r\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\r\n    <PlatformToolset>v143</PlatformToolset>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\r\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\r\n    <PlatformToolset>v143</PlatformToolset>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n    <WholeProgramOptimization>true</WholeProgramOptimization>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Rel+Detours|x64'\" Label=\"Configuration\">\r\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\r\n    <PlatformToolset>v143</PlatformToolset>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n    <WholeProgramOptimization>true</WholeProgramOptimization>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release+StaticHook|x64'\" Label=\"Configuration\">\r\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\r\n    <PlatformToolset>v143</PlatformToolset>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n    <WholeProgramOptimization>true</WholeProgramOptimization>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Rel+Trace|x64'\" Label=\"Configuration\">\r\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\r\n    <PlatformToolset>v143</PlatformToolset>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n    <WholeProgramOptimization>true</WholeProgramOptimization>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release Infinality|x64'\" Label=\"Configuration\">\r\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\r\n    <PlatformToolset>v143</PlatformToolset>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n    <WholeProgramOptimization>true</WholeProgramOptimization>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"Configuration\">\r\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\r\n    <PlatformToolset>v143</PlatformToolset>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug Infinality|x64'\" Label=\"Configuration\">\r\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\r\n    <PlatformToolset>v143</PlatformToolset>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n  </PropertyGroup>\r\n  <PropertyGroup Label=\"Configuration\" Condition=\"'$(Configuration)|$(Platform)'=='EXE|Win32'\">\r\n    <PlatformToolset>v143</PlatformToolset>\r\n  </PropertyGroup>\r\n  <PropertyGroup Label=\"Configuration\" Condition=\"'$(Configuration)|$(Platform)'=='EXE|x64'\">\r\n    <PlatformToolset>v143</PlatformToolset>\r\n  </PropertyGroup>\r\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\r\n  <ImportGroup Label=\"ExtensionSettings\">\r\n  </ImportGroup>\r\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\" Label=\"PropertySheets\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n  </ImportGroup>\r\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Rel+Detours|Win32'\" Label=\"PropertySheets\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n  </ImportGroup>\r\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release+StaticHook|Win32'\" Label=\"PropertySheets\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n  </ImportGroup>\r\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Rel+Trace|Win32'\" Label=\"PropertySheets\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n  </ImportGroup>\r\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release Infinality|Win32'\" Label=\"PropertySheets\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n  </ImportGroup>\r\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\" Label=\"PropertySheets\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n  </ImportGroup>\r\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug Infinality|Win32'\" Label=\"PropertySheets\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n  </ImportGroup>\r\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"PropertySheets\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n  </ImportGroup>\r\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Rel+Detours|x64'\" Label=\"PropertySheets\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n  </ImportGroup>\r\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release+StaticHook|x64'\" Label=\"PropertySheets\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n  </ImportGroup>\r\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Rel+Trace|x64'\" Label=\"PropertySheets\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n  </ImportGroup>\r\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release Infinality|x64'\" Label=\"PropertySheets\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n  </ImportGroup>\r\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"PropertySheets\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n  </ImportGroup>\r\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug Infinality|x64'\" Label=\"PropertySheets\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n  </ImportGroup>\r\n  <PropertyGroup Label=\"UserMacros\" />\r\n  <PropertyGroup>\r\n    <_ProjectFileVersion>12.0.21005.1</_ProjectFileVersion>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\r\n    <OutDir>$(SolutionDir)$(Configuration)\\</OutDir>\r\n    <IntDir>$(Configuration)\\</IntDir>\r\n    <LinkIncremental>true</LinkIncremental>\r\n    <GenerateManifest>false</GenerateManifest>\r\n    <TargetName>$(ProjectName).Core</TargetName>\r\n    <IncludePath>$(INI_PARSER_PATH);$(FREETYPE_PATH)\\include;$(IncludePath)</IncludePath>\r\n    <LibraryPath>$(SolutionDir)lib;$(LibraryPath)</LibraryPath>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug Infinality|Win32'\">\r\n    <OutDir>$(SolutionDir)$(Configuration)\\</OutDir>\r\n    <IntDir>$(Configuration)\\</IntDir>\r\n    <LinkIncremental>true</LinkIncremental>\r\n    <GenerateManifest>false</GenerateManifest>\r\n    <TargetName>$(ProjectName).Core</TargetName>\r\n    <IncludePath>$(INI_PARSER_PATH);$(FREETYPE_PATH)\\include;$(IncludePath)</IncludePath>\r\n    <LibraryPath>$(SolutionDir)lib;$(LibraryPath)</LibraryPath>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\r\n    <OutDir>$(SolutionDir)$(Platform)\\$(Configuration)\\</OutDir>\r\n    <IntDir>$(Platform)\\$(Configuration)\\</IntDir>\r\n    <LinkIncremental>true</LinkIncremental>\r\n    <GenerateManifest>false</GenerateManifest>\r\n    <TargetName>$(ProjectName)64.Core</TargetName>\r\n    <IncludePath>$(INI_PARSER_PATH);$(FREETYPE_PATH)\\include;$(IncludePath)</IncludePath>\r\n    <LibraryPath>$(SolutionDir)lib;$(LibraryPath)</LibraryPath>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug Infinality|x64'\">\r\n    <OutDir>$(SolutionDir)$(Platform)\\$(Configuration)\\</OutDir>\r\n    <IntDir>$(Platform)\\$(Configuration)\\</IntDir>\r\n    <LinkIncremental>true</LinkIncremental>\r\n    <GenerateManifest>false</GenerateManifest>\r\n    <TargetName>$(ProjectName)64.Core</TargetName>\r\n    <IncludePath>$(INI_PARSER_PATH);$(FREETYPE_PATH)\\include;$(IncludePath)</IncludePath>\r\n    <LibraryPath>$(SolutionDir)lib;$(LibraryPath)</LibraryPath>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\r\n    <OutDir>$(SolutionDir)$(Configuration)\\</OutDir>\r\n    <IntDir>$(Configuration)\\</IntDir>\r\n    <LinkIncremental>false</LinkIncremental>\r\n    <GenerateManifest>false</GenerateManifest>\r\n    <TargetName>$(ProjectName).Core</TargetName>\r\n    <IncludePath>$(INI_PARSER_PATH);$(FREETYPE_PATH)\\include;$(IncludePath)</IncludePath>\r\n    <LibraryPath>$(SolutionDir)lib;$(LibraryPath)</LibraryPath>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Rel+Detours|Win32'\">\r\n    <OutDir>$(SolutionDir)$(Configuration)\\</OutDir>\r\n    <IntDir>$(Configuration)\\</IntDir>\r\n    <LinkIncremental>false</LinkIncremental>\r\n    <GenerateManifest>false</GenerateManifest>\r\n    <TargetName>$(ProjectName).Core</TargetName>\r\n    <IncludePath>$(INI_PARSER_PATH);$(FREETYPE_PATH)\\include;$(IncludePath)</IncludePath>\r\n    <LibraryPath>$(SolutionDir)lib;$(LibraryPath)</LibraryPath>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release+StaticHook|Win32'\">\r\n    <OutDir>$(SolutionDir)$(Configuration)\\</OutDir>\r\n    <IntDir>$(Configuration)\\</IntDir>\r\n    <LinkIncremental>false</LinkIncremental>\r\n    <GenerateManifest>false</GenerateManifest>\r\n    <TargetName>$(ProjectName).Core</TargetName>\r\n    <IncludePath>$(INI_PARSER_PATH);$(FREETYPE_PATH)\\include;$(IncludePath)</IncludePath>\r\n    <LibraryPath>$(SolutionDir)lib;$(LibraryPath)</LibraryPath>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Rel+Trace|Win32'\">\r\n    <OutDir>$(SolutionDir)$(Configuration)\\</OutDir>\r\n    <IntDir>$(Configuration)\\</IntDir>\r\n    <LinkIncremental>false</LinkIncremental>\r\n    <GenerateManifest>false</GenerateManifest>\r\n    <TargetName>$(ProjectName).Core</TargetName>\r\n    <IncludePath>$(INI_PARSER_PATH);$(FREETYPE_PATH)\\include;$(IncludePath)</IncludePath>\r\n    <LibraryPath>$(SolutionDir)lib;$(LibraryPath)</LibraryPath>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release Infinality|Win32'\">\r\n    <OutDir>$(SolutionDir)$(Configuration)\\</OutDir>\r\n    <IntDir>$(Configuration)\\</IntDir>\r\n    <LinkIncremental>false</LinkIncremental>\r\n    <GenerateManifest>false</GenerateManifest>\r\n    <TargetName>$(ProjectName).Core</TargetName>\r\n    <IncludePath>$(INI_PARSER_PATH);$(FREETYPE_PATH)\\include;$(IncludePath)</IncludePath>\r\n    <LibraryPath>$(SolutionDir)lib;$(LibraryPath)</LibraryPath>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\r\n    <OutDir>$(SolutionDir)$(Platform)\\$(Configuration)\\</OutDir>\r\n    <IntDir>$(Platform)\\$(Configuration)\\</IntDir>\r\n    <LinkIncremental>false</LinkIncremental>\r\n    <GenerateManifest>false</GenerateManifest>\r\n    <TargetName>$(ProjectName)64.Core</TargetName>\r\n    <IncludePath>$(INI_PARSER_PATH);$(FREETYPE_PATH)\\include;$(IncludePath)</IncludePath>\r\n    <LibraryPath>$(SolutionDir)lib;$(LibraryPath)</LibraryPath>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Rel+Detours|x64'\">\r\n    <OutDir>$(SolutionDir)$(Platform)\\$(Configuration)\\</OutDir>\r\n    <IntDir>$(Platform)\\$(Configuration)\\</IntDir>\r\n    <LinkIncremental>false</LinkIncremental>\r\n    <GenerateManifest>false</GenerateManifest>\r\n    <TargetName>$(ProjectName)64.Core</TargetName>\r\n    <IncludePath>$(INI_PARSER_PATH);$(FREETYPE_PATH)\\include;$(IncludePath)</IncludePath>\r\n    <LibraryPath>$(SolutionDir)lib;$(LibraryPath)</LibraryPath>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release+StaticHook|x64'\">\r\n    <OutDir>$(SolutionDir)$(Platform)\\$(Configuration)\\</OutDir>\r\n    <IntDir>$(Platform)\\$(Configuration)\\</IntDir>\r\n    <LinkIncremental>false</LinkIncremental>\r\n    <GenerateManifest>false</GenerateManifest>\r\n    <TargetName>$(ProjectName)64.Core</TargetName>\r\n    <IncludePath>$(INI_PARSER_PATH);$(FREETYPE_PATH)\\include;$(IncludePath)</IncludePath>\r\n    <LibraryPath>$(SolutionDir)lib;$(LibraryPath)</LibraryPath>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Rel+Trace|x64'\">\r\n    <OutDir>$(SolutionDir)$(Platform)\\$(Configuration)\\</OutDir>\r\n    <IntDir>$(Platform)\\$(Configuration)\\</IntDir>\r\n    <LinkIncremental>false</LinkIncremental>\r\n    <GenerateManifest>false</GenerateManifest>\r\n    <TargetName>$(ProjectName)64.Core</TargetName>\r\n    <IncludePath>$(INI_PARSER_PATH);$(FREETYPE_PATH)\\include;$(IncludePath)</IncludePath>\r\n    <LibraryPath>$(SolutionDir)lib;$(LibraryPath)</LibraryPath>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release Infinality|x64'\">\r\n    <OutDir>$(SolutionDir)$(Platform)\\$(Configuration)\\</OutDir>\r\n    <IntDir>$(Platform)\\$(Configuration)\\</IntDir>\r\n    <LinkIncremental>false</LinkIncremental>\r\n    <GenerateManifest>false</GenerateManifest>\r\n    <TargetName>$(ProjectName)64.Core</TargetName>\r\n    <IncludePath>$(INI_PARSER_PATH);$(FREETYPE_PATH)\\include;$(IncludePath)</IncludePath>\r\n    <LibraryPath>$(SolutionDir)lib;$(LibraryPath)</LibraryPath>\r\n  </PropertyGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\r\n    <ClCompile>\r\n      <Optimization>Disabled</Optimization>\r\n      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>\r\n      <EnableFiberSafeOptimizations>false</EnableFiberSafeOptimizations>\r\n      <WholeProgramOptimization>false</WholeProgramOptimization>\r\n      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;GDIPP_EXPORTS;_GDIPP_DLL;EASYHOOK;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <MinimalRebuild>true</MinimalRebuild>\r\n      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>\r\n      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\r\n      <PrecompiledHeader />\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>\r\n      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>\r\n    </ClCompile>\r\n    <Link>\r\n      <AdditionalDependencies>freetype.lib;usp10.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n      <IgnoreSpecificDefaultLibraries>LIBCMT;%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>\r\n      <ModuleDefinitionFile>expfunc.def</ModuleDefinitionFile>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n      <SubSystem>Windows</SubSystem>\r\n      <SupportUnloadOfDelayLoadedDLL>true</SupportUnloadOfDelayLoadedDLL>\r\n      <TargetMachine>MachineX86</TargetMachine>\r\n      <AdditionalOptions>/DEBUG</AdditionalOptions>\r\n      <DelayLoadDLLs>easyhk32.dll</DelayLoadDLLs>\r\n    </Link>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug Infinality|Win32'\">\r\n    <ClCompile>\r\n      <Optimization>Disabled</Optimization>\r\n      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>\r\n      <EnableFiberSafeOptimizations>false</EnableFiberSafeOptimizations>\r\n      <WholeProgramOptimization>false</WholeProgramOptimization>\r\n      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;GDIPP_EXPORTS;_GDIPP_DLL;INFINALITY;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <MinimalRebuild>true</MinimalRebuild>\r\n      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>\r\n      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\r\n      <PrecompiledHeader>\r\n      </PrecompiledHeader>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>\r\n      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>\r\n    </ClCompile>\r\n    <Link>\r\n      <AdditionalDependencies>freetype_inf.lib;usp10.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n      <IgnoreSpecificDefaultLibraries>LIBCMT;%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>\r\n      <ModuleDefinitionFile>expfunc.def</ModuleDefinitionFile>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n      <SubSystem>Windows</SubSystem>\r\n      <SupportUnloadOfDelayLoadedDLL>true</SupportUnloadOfDelayLoadedDLL>\r\n      <TargetMachine>MachineX86</TargetMachine>\r\n      <AdditionalOptions>/DEBUG</AdditionalOptions>\r\n      <DelayLoadDLLs>easyhook32.dll</DelayLoadDLLs>\r\n    </Link>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\r\n    <Midl>\r\n      <TargetEnvironment>X64</TargetEnvironment>\r\n    </Midl>\r\n    <ClCompile>\r\n      <Optimization>Disabled</Optimization>\r\n      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>\r\n      <EnableFiberSafeOptimizations>false</EnableFiberSafeOptimizations>\r\n      <WholeProgramOptimization>false</WholeProgramOptimization>\r\n      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;GDIPP_EXPORTS;_GDIPP_DLL;EASYHOOK;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <MinimalRebuild>true</MinimalRebuild>\r\n      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>\r\n      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\r\n      <PrecompiledHeader />\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\r\n      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>\r\n    </ClCompile>\r\n    <Link>\r\n      <AdditionalDependencies>freetype64.lib;usp10.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n      <IgnoreSpecificDefaultLibraries>LIBCMT;%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>\r\n      <ModuleDefinitionFile>expfunc.def</ModuleDefinitionFile>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n      <SubSystem>Windows</SubSystem>\r\n      <SupportUnloadOfDelayLoadedDLL>true</SupportUnloadOfDelayLoadedDLL>\r\n      <TargetMachine>MachineX64</TargetMachine>\r\n      <AdditionalOptions>/DEBUG %(AdditionalOptions)</AdditionalOptions>\r\n      <DelayLoadDLLs>easyhook64.dll</DelayLoadDLLs>\r\n    </Link>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug Infinality|x64'\">\r\n    <Midl>\r\n      <TargetEnvironment>X64</TargetEnvironment>\r\n    </Midl>\r\n    <ClCompile>\r\n      <Optimization>Disabled</Optimization>\r\n      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>\r\n      <EnableFiberSafeOptimizations>false</EnableFiberSafeOptimizations>\r\n      <WholeProgramOptimization>false</WholeProgramOptimization>\r\n      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;GDIPP_EXPORTS;_GDIPP_DLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <MinimalRebuild>true</MinimalRebuild>\r\n      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>\r\n      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\r\n      <PrecompiledHeader>\r\n      </PrecompiledHeader>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\r\n      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>\r\n    </ClCompile>\r\n    <Link>\r\n      <AdditionalDependencies>freetype64.lib;usp10.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n      <IgnoreSpecificDefaultLibraries>LIBCMT;%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>\r\n      <ModuleDefinitionFile>expfunc.def</ModuleDefinitionFile>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n      <SubSystem>Windows</SubSystem>\r\n      <SupportUnloadOfDelayLoadedDLL>true</SupportUnloadOfDelayLoadedDLL>\r\n      <TargetMachine>MachineX64</TargetMachine>\r\n      <AdditionalOptions>/DEBUG %(AdditionalOptions)</AdditionalOptions>\r\n      <DelayLoadDLLs>easyhook64.dll</DelayLoadDLLs>\r\n    </Link>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\r\n    <ClCompile>\r\n      <Optimization>MaxSpeed</Optimization>\r\n      <IntrinsicFunctions>true</IntrinsicFunctions>\r\n      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>\r\n      <EnableFiberSafeOptimizations>false</EnableFiberSafeOptimizations>\r\n      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;GDIPP_EXPORTS;_GDIPP_EXE;EASYHOOK;STATIC_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <ExceptionHandling>Sync</ExceptionHandling>\r\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\r\n      <BufferSecurityCheck>false</BufferSecurityCheck>\r\n      <FunctionLevelLinking>false</FunctionLevelLinking>\r\n      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>\r\n      <FloatingPointModel>Precise</FloatingPointModel>\r\n      <PrecompiledHeader />\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\r\n      <AdditionalIncludeDirectories>$(SolutionDir)deps\\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalOptions>/Zc:threadSafeInit- /utf-8 %(AdditionalOptions)</AdditionalOptions>\r\n    </ClCompile>\r\n    <Link>\r\n      <AdditionalDependencies>freetype.lib;usp10.lib;dwrite.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>\r\n      <ModuleDefinitionFile>expfunc.def</ModuleDefinitionFile>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n      <SubSystem>Windows</SubSystem>\r\n      <OptimizeReferences>true</OptimizeReferences>\r\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\r\n      <RandomizedBaseAddress>true</RandomizedBaseAddress>\r\n      <SupportUnloadOfDelayLoadedDLL>true</SupportUnloadOfDelayLoadedDLL>\r\n      <TargetMachine>MachineX86</TargetMachine>\r\n      <DelayLoadDLLs>easyhk32.dll</DelayLoadDLLs>\r\n      <AdditionalLibraryDirectories>$(SolutionDir)deps\\lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>\r\n      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>\r\n      <ImageHasSafeExceptionHandlers />\r\n    </Link>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Rel+Detours|Win32'\">\r\n    <ClCompile>\r\n      <Optimization>MaxSpeed</Optimization>\r\n      <IntrinsicFunctions>true</IntrinsicFunctions>\r\n      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>\r\n      <EnableFiberSafeOptimizations>false</EnableFiberSafeOptimizations>\r\n      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;GDIPP_EXPORTS;_GDIPP_DLL;USE_DETOURS;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <ExceptionHandling>Sync</ExceptionHandling>\r\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\r\n      <BufferSecurityCheck>false</BufferSecurityCheck>\r\n      <FunctionLevelLinking>false</FunctionLevelLinking>\r\n      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>\r\n      <FloatingPointModel>Precise</FloatingPointModel>\r\n      <PrecompiledHeader>\r\n      </PrecompiledHeader>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\r\n      <AdditionalIncludeDirectories>$(SolutionDir)deps\\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalOptions>/Zc:threadSafeInit- /utf-8 %(AdditionalOptions)</AdditionalOptions>\r\n    </ClCompile>\r\n    <Link>\r\n      <AdditionalDependencies>freetype.lib;usp10.lib;dwrite.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>\r\n      <ModuleDefinitionFile>expfunc.def</ModuleDefinitionFile>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n      <SubSystem>Windows</SubSystem>\r\n      <OptimizeReferences>true</OptimizeReferences>\r\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\r\n      <RandomizedBaseAddress>true</RandomizedBaseAddress>\r\n      <TargetMachine>MachineX86</TargetMachine>\r\n      <DelayLoadDLLs>\r\n      </DelayLoadDLLs>\r\n      <AdditionalLibraryDirectories>$(SolutionDir)deps\\lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>\r\n      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>\r\n      <ImageHasSafeExceptionHandlers>\r\n      </ImageHasSafeExceptionHandlers>\r\n    </Link>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release+StaticHook|Win32'\">\r\n    <ClCompile>\r\n      <Optimization>MaxSpeed</Optimization>\r\n      <IntrinsicFunctions>true</IntrinsicFunctions>\r\n      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>\r\n      <EnableFiberSafeOptimizations>false</EnableFiberSafeOptimizations>\r\n      <PreprocessorDefinitions>STATIC_LIB;EASYHOOK;WIN32;NDEBUG;_WINDOWS;_USRDLL;GDIPP_EXPORTS;_GDIPP_DLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <ExceptionHandling>Sync</ExceptionHandling>\r\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\r\n      <BufferSecurityCheck>false</BufferSecurityCheck>\r\n      <FunctionLevelLinking>false</FunctionLevelLinking>\r\n      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>\r\n      <FloatingPointModel>Precise</FloatingPointModel>\r\n      <PrecompiledHeader>\r\n      </PrecompiledHeader>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\r\n      <AdditionalIncludeDirectories>$(SolutionDir)deps\\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalOptions>/Zc:threadSafeInit- /utf-8 %(AdditionalOptions)</AdditionalOptions>\r\n    </ClCompile>\r\n    <Link>\r\n      <AdditionalDependencies>freetype.lib;usp10.lib;dwrite.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>\r\n      <ModuleDefinitionFile>expfunc.def</ModuleDefinitionFile>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n      <SubSystem>Windows</SubSystem>\r\n      <OptimizeReferences>true</OptimizeReferences>\r\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\r\n      <RandomizedBaseAddress>true</RandomizedBaseAddress>\r\n      <TargetMachine>MachineX86</TargetMachine>\r\n      <DelayLoadDLLs>\r\n      </DelayLoadDLLs>\r\n      <AdditionalLibraryDirectories>$(SolutionDir)deps\\lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>\r\n      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>\r\n      <ImageHasSafeExceptionHandlers>\r\n      </ImageHasSafeExceptionHandlers>\r\n    </Link>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Rel+Trace|Win32'\">\r\n    <ClCompile>\r\n      <Optimization>MaxSpeed</Optimization>\r\n      <IntrinsicFunctions>true</IntrinsicFunctions>\r\n      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>\r\n      <EnableFiberSafeOptimizations>false</EnableFiberSafeOptimizations>\r\n      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;GDIPP_EXPORTS;_GDIPP_DLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <ExceptionHandling>Sync</ExceptionHandling>\r\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\r\n      <BufferSecurityCheck>false</BufferSecurityCheck>\r\n      <FunctionLevelLinking>false</FunctionLevelLinking>\r\n      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>\r\n      <FloatingPointModel>Precise</FloatingPointModel>\r\n      <PrecompiledHeader>\r\n      </PrecompiledHeader>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\r\n      <AdditionalIncludeDirectories>$(SolutionDir)deps\\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalOptions>/Zc:threadSafeInit- /utf-8 %(AdditionalOptions)</AdditionalOptions>\r\n    </ClCompile>\r\n    <Link>\r\n      <AdditionalDependencies>freetype.lib;usp10.lib;dwrite.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>\r\n      <ModuleDefinitionFile>expfunc.def</ModuleDefinitionFile>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n      <SubSystem>Windows</SubSystem>\r\n      <OptimizeReferences>true</OptimizeReferences>\r\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\r\n      <RandomizedBaseAddress>true</RandomizedBaseAddress>\r\n      <SupportUnloadOfDelayLoadedDLL>true</SupportUnloadOfDelayLoadedDLL>\r\n      <TargetMachine>MachineX86</TargetMachine>\r\n      <DelayLoadDLLs>easyhk32.dll</DelayLoadDLLs>\r\n      <AdditionalLibraryDirectories>$(SolutionDir)deps\\lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>\r\n      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>\r\n    </Link>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release Infinality|Win32'\">\r\n    <ClCompile>\r\n      <Optimization>MaxSpeed</Optimization>\r\n      <IntrinsicFunctions>true</IntrinsicFunctions>\r\n      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>\r\n      <EnableFiberSafeOptimizations>false</EnableFiberSafeOptimizations>\r\n      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;GDIPP_EXPORTS;_GDIPP_DLL;INFINALITY;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <ExceptionHandling>Sync</ExceptionHandling>\r\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\r\n      <BufferSecurityCheck>false</BufferSecurityCheck>\r\n      <FunctionLevelLinking>false</FunctionLevelLinking>\r\n      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>\r\n      <FloatingPointModel>Precise</FloatingPointModel>\r\n      <PrecompiledHeader>\r\n      </PrecompiledHeader>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\r\n      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>\r\n    </ClCompile>\r\n    <Link>\r\n      <AdditionalDependencies>freetype_inf.lib;usp10.lib;dwrite.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>\r\n      <ModuleDefinitionFile>expfunc.def</ModuleDefinitionFile>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n      <SubSystem>Windows</SubSystem>\r\n      <OptimizeReferences>true</OptimizeReferences>\r\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\r\n      <RandomizedBaseAddress>true</RandomizedBaseAddress>\r\n      <SupportUnloadOfDelayLoadedDLL>true</SupportUnloadOfDelayLoadedDLL>\r\n      <TargetMachine>MachineX86</TargetMachine>\r\n      <DelayLoadDLLs>easyhook32.dll</DelayLoadDLLs>\r\n    </Link>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\r\n    <Midl>\r\n      <TargetEnvironment>X64</TargetEnvironment>\r\n    </Midl>\r\n    <ClCompile>\r\n      <Optimization>MaxSpeed</Optimization>\r\n      <IntrinsicFunctions>true</IntrinsicFunctions>\r\n      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>\r\n      <PreprocessorDefinitions>NDEBUG;_WINDOWS;_USRDLL;GDIPP_EXPORTS;_GDIPP_DLL;EASYHOOK;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <ExceptionHandling>Sync</ExceptionHandling>\r\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\r\n      <BufferSecurityCheck>false</BufferSecurityCheck>\r\n      <FunctionLevelLinking>true</FunctionLevelLinking>\r\n      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>\r\n      <PrecompiledHeader />\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\r\n      <AdditionalIncludeDirectories>$(SolutionDir)deps\\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>\r\n    </ClCompile>\r\n    <Link>\r\n      <AdditionalDependencies>freetype64.lib;usp10.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>\r\n      <ModuleDefinitionFile>expfunc.def</ModuleDefinitionFile>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n      <SubSystem>Windows</SubSystem>\r\n      <OptimizeReferences>true</OptimizeReferences>\r\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\r\n      <RandomizedBaseAddress>true</RandomizedBaseAddress>\r\n      <SupportUnloadOfDelayLoadedDLL>true</SupportUnloadOfDelayLoadedDLL>\r\n      <TargetMachine>MachineX64</TargetMachine>\r\n      <DelayLoadDLLs>easyhk64.dll</DelayLoadDLLs>\r\n      <AdditionalLibraryDirectories>$(SolutionDir)deps\\lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>\r\n      <CETCompat>true</CETCompat>\r\n    </Link>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Rel+Detours|x64'\">\r\n    <Midl>\r\n      <TargetEnvironment>X64</TargetEnvironment>\r\n    </Midl>\r\n    <ClCompile>\r\n      <Optimization>MaxSpeed</Optimization>\r\n      <IntrinsicFunctions>true</IntrinsicFunctions>\r\n      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>\r\n      <PreprocessorDefinitions>NDEBUG;_WINDOWS;_USRDLL;GDIPP_EXPORTS;_GDIPP_DLL;USE_DETOURS;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <ExceptionHandling>Sync</ExceptionHandling>\r\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\r\n      <BufferSecurityCheck>false</BufferSecurityCheck>\r\n      <FunctionLevelLinking>true</FunctionLevelLinking>\r\n      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>\r\n      <PrecompiledHeader>\r\n      </PrecompiledHeader>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\r\n      <AdditionalIncludeDirectories>$(SolutionDir)deps\\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>\r\n    </ClCompile>\r\n    <Link>\r\n      <AdditionalDependencies>freetype64.lib;usp10.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>\r\n      <ModuleDefinitionFile>expfunc.def</ModuleDefinitionFile>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n      <SubSystem>Windows</SubSystem>\r\n      <OptimizeReferences>true</OptimizeReferences>\r\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\r\n      <RandomizedBaseAddress>true</RandomizedBaseAddress>\r\n      <TargetMachine>MachineX64</TargetMachine>\r\n      <DelayLoadDLLs>\r\n      </DelayLoadDLLs>\r\n      <AdditionalLibraryDirectories>$(SolutionDir)deps\\lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>\r\n      <CETCompat>true</CETCompat>\r\n    </Link>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release+StaticHook|x64'\">\r\n    <Midl>\r\n      <TargetEnvironment>X64</TargetEnvironment>\r\n    </Midl>\r\n    <ClCompile>\r\n      <Optimization>MaxSpeed</Optimization>\r\n      <IntrinsicFunctions>true</IntrinsicFunctions>\r\n      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>\r\n      <PreprocessorDefinitions>STATIC_LIB;EASYHOOK;NDEBUG;_WINDOWS;_USRDLL;GDIPP_EXPORTS;_GDIPP_DLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <ExceptionHandling>Sync</ExceptionHandling>\r\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\r\n      <BufferSecurityCheck>false</BufferSecurityCheck>\r\n      <FunctionLevelLinking>true</FunctionLevelLinking>\r\n      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>\r\n      <PrecompiledHeader>\r\n      </PrecompiledHeader>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\r\n      <AdditionalIncludeDirectories>$(SolutionDir)deps\\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>\r\n    </ClCompile>\r\n    <Link>\r\n      <AdditionalDependencies>freetype64.lib;usp10.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>\r\n      <ModuleDefinitionFile>expfunc.def</ModuleDefinitionFile>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n      <SubSystem>Windows</SubSystem>\r\n      <OptimizeReferences>true</OptimizeReferences>\r\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\r\n      <RandomizedBaseAddress>true</RandomizedBaseAddress>\r\n      <TargetMachine>MachineX64</TargetMachine>\r\n      <DelayLoadDLLs>\r\n      </DelayLoadDLLs>\r\n      <AdditionalLibraryDirectories>$(SolutionDir)deps\\lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>\r\n      <CETCompat>true</CETCompat>\r\n    </Link>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Rel+Trace|x64'\">\r\n    <Midl>\r\n      <TargetEnvironment>X64</TargetEnvironment>\r\n    </Midl>\r\n    <ClCompile>\r\n      <Optimization>MaxSpeed</Optimization>\r\n      <IntrinsicFunctions>true</IntrinsicFunctions>\r\n      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>\r\n      <PreprocessorDefinitions>NDEBUG;_WINDOWS;_USRDLL;GDIPP_EXPORTS;_GDIPP_DLL;TRACE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <ExceptionHandling>Sync</ExceptionHandling>\r\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\r\n      <BufferSecurityCheck>false</BufferSecurityCheck>\r\n      <FunctionLevelLinking>true</FunctionLevelLinking>\r\n      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>\r\n      <PrecompiledHeader>\r\n      </PrecompiledHeader>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\r\n      <AdditionalIncludeDirectories>$(SolutionDir)deps\\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>\r\n    </ClCompile>\r\n    <Link>\r\n      <AdditionalDependencies>freetype64.lib;usp10.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>\r\n      <ModuleDefinitionFile>expfunc.def</ModuleDefinitionFile>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n      <SubSystem>Windows</SubSystem>\r\n      <OptimizeReferences>true</OptimizeReferences>\r\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\r\n      <RandomizedBaseAddress>true</RandomizedBaseAddress>\r\n      <SupportUnloadOfDelayLoadedDLL>true</SupportUnloadOfDelayLoadedDLL>\r\n      <TargetMachine>MachineX64</TargetMachine>\r\n      <DelayLoadDLLs>easyhk64.dll</DelayLoadDLLs>\r\n      <AdditionalLibraryDirectories>$(SolutionDir)deps\\lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>\r\n      <CETCompat>true</CETCompat>\r\n    </Link>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release Infinality|x64'\">\r\n    <Midl>\r\n      <TargetEnvironment>X64</TargetEnvironment>\r\n    </Midl>\r\n    <ClCompile>\r\n      <Optimization>MaxSpeed</Optimization>\r\n      <IntrinsicFunctions>true</IntrinsicFunctions>\r\n      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>\r\n      <PreprocessorDefinitions>NDEBUG;_WINDOWS;_USRDLL;GDIPP_EXPORTS;_GDIPP_DLL;INFINALITY;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <ExceptionHandling>Sync</ExceptionHandling>\r\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\r\n      <BufferSecurityCheck>false</BufferSecurityCheck>\r\n      <FunctionLevelLinking>true</FunctionLevelLinking>\r\n      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>\r\n      <PrecompiledHeader>\r\n      </PrecompiledHeader>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\r\n      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>\r\n    </ClCompile>\r\n    <Link>\r\n      <AdditionalDependencies>freetype64_inf.lib;usp10.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>\r\n      <ModuleDefinitionFile>expfunc.def</ModuleDefinitionFile>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n      <SubSystem>Windows</SubSystem>\r\n      <OptimizeReferences>true</OptimizeReferences>\r\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\r\n      <RandomizedBaseAddress>true</RandomizedBaseAddress>\r\n      <SupportUnloadOfDelayLoadedDLL>true</SupportUnloadOfDelayLoadedDLL>\r\n      <TargetMachine>MachineX64</TargetMachine>\r\n      <DelayLoadDLLs>easyhook64.dll</DelayLoadDLLs>\r\n    </Link>\r\n  </ItemDefinitionGroup>\r\n  <ItemGroup>\r\n    <ClCompile Include=\"cache.cpp\" />\r\n    <ClCompile Include=\"directwrite.cpp\" />\r\n    <ClCompile Include=\"dll.cpp\" />\r\n    <ClCompile Include=\"dynCodeHelper.cpp\" />\r\n    <ClCompile Include=\"EventLogging.cpp\" />\r\n    <ClCompile Include=\"expfunc.cpp\" />\r\n    <ClCompile Include=\"ft.cpp\" />\r\n    <ClCompile Include=\"ft2vert.c\" />\r\n    <ClCompile Include=\"fteng.cpp\" />\r\n    <ClCompile Include=\"ftref.c\" />\r\n    <ClCompile Include=\"gdiPlusFlat2.cpp\" />\r\n    <ClCompile Include=\"hash_list.cpp\" />\r\n    <ClCompile Include=\"hook.cpp\" />\r\n    <ClCompile Include=\"hookCounter.cpp\" />\r\n    <ClCompile Include=\"misc.cpp\" />\r\n    <ClCompile Include=\"override.cpp\">\r\n      <ExceptionHandling Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">Sync</ExceptionHandling>\r\n      <ExceptionHandling Condition=\"'$(Configuration)|$(Platform)'=='Rel+Detours|Win32'\">Sync</ExceptionHandling>\r\n      <ExceptionHandling Condition=\"'$(Configuration)|$(Platform)'=='Release+StaticHook|Win32'\">Sync</ExceptionHandling>\r\n      <ExceptionHandling Condition=\"'$(Configuration)|$(Platform)'=='Rel+Trace|Win32'\">Sync</ExceptionHandling>\r\n      <ExceptionHandling Condition=\"'$(Configuration)|$(Platform)'=='Release Infinality|Win32'\">Sync</ExceptionHandling>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ownedcs.cpp\" />\r\n    <ClCompile Include=\"settings.cpp\" />\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <None Include=\"expfunc.def\" />\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <ClInclude Include=\"array.h\" />\r\n    <ClInclude Include=\"cache.h\" />\r\n    <ClInclude Include=\"common.h\" />\r\n    <ClInclude Include=\"crc32.h\" />\r\n    <ClInclude Include=\"directwrite.h\" />\r\n    <ClInclude Include=\"dll.h\" />\r\n    <ClInclude Include=\"dynCodeHelper.h\" />\r\n    <ClInclude Include=\"EventLogging.h\" />\r\n    <ClInclude Include=\"ft.h\" />\r\n    <ClInclude Include=\"ft2build.h\" />\r\n    <ClInclude Include=\"ft2vert.h\" />\r\n    <ClInclude Include=\"fteng.h\" />\r\n    <ClInclude Include=\"ftref.h\" />\r\n    <ClInclude Include=\"gdiPlusFlat2.h\" />\r\n    <ClInclude Include=\"hash_list.h\" />\r\n    <ClInclude Include=\"hookCounter.h\" />\r\n    <ClInclude Include=\"hooklist.h\" />\r\n    <ClInclude Include=\"ivs_otft.h\" />\r\n    <ClInclude Include=\"json.hpp\" />\r\n    <ClInclude Include=\"override.h\" />\r\n    <ClInclude Include=\"ownedcs.h\" />\r\n    <ClInclude Include=\"resource.h\" />\r\n    <ClInclude Include=\"settings.h\" />\r\n    <ClInclude Include=\"stdint.h\" />\r\n    <ClInclude Include=\"strtoken.h\" />\r\n    <ClInclude Include=\"supinfo.h\" />\r\n    <ClInclude Include=\"tlsdata.h\" />\r\n    <ClInclude Include=\"undocAPI.h\" />\r\n    <ClInclude Include=\"wow64ext.h\" />\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <ResourceCompile Include=\"gdidll.rc\" />\r\n  </ItemGroup>\r\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\r\n  <ImportGroup Label=\"ExtensionTargets\">\r\n  </ImportGroup>\r\n</Project>"
        },
        {
          "name": "gdipp.vcxproj.filters",
          "type": "blob",
          "size": 5.3759765625,
          "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n  <ItemGroup>\r\n    <Filter Include=\"Source Files\">\r\n      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>\r\n      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>\r\n    </Filter>\r\n    <Filter Include=\"Header Files\">\r\n      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>\r\n      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>\r\n    </Filter>\r\n    <Filter Include=\"Resource Files\">\r\n      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>\r\n      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav</Extensions>\r\n    </Filter>\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <ClCompile Include=\"cache.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"dll.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"expfunc.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ft.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ft2vert.c\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"fteng.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ftref.c\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"gdiPlusFlat2.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"hash_list.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"hook.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"misc.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"override.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ownedcs.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"settings.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"directwrite.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"dynCodeHelper.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"EventLogging.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"hookCounter.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <None Include=\"expfunc.def\">\r\n      <Filter>Source Files</Filter>\r\n    </None>\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <ClInclude Include=\"array.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"cache.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"common.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"dll.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ft.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ft2build.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ft2vert.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"fteng.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ftref.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"gdiPlusFlat2.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"hash_list.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"hooklist.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ivs_otft.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"override.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ownedcs.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"resource.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"settings.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"stdint.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"strtoken.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"supinfo.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"tlsdata.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"undocAPI.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"directwrite.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"dynCodeHelper.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"EventLogging.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"wow64ext.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"crc32.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"json.hpp\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"hookCounter.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <ResourceCompile Include=\"gdidll.rc\">\r\n      <Filter>Resource Files</Filter>\r\n    </ResourceCompile>\r\n  </ItemGroup>\r\n</Project>"
        },
        {
          "name": "hash_list.cpp",
          "type": "blob",
          "size": 0.8056640625,
          "content": "#include \"hash_list.h\"\n#include <cwctype>\n#include <algorithm>\n\nvoid CHashedStringList::Add(TCHAR * String, TCHAR * Value)\n{\n\tstd::wstring buff = String;\n\tif (!m_bCaseSense)\n\t\tstd::transform(buff.begin(), buff.end(), buff.begin(), ::towlower);\n\n\tstrmap::iterator it = stringmap.find(buff);\n\tif (it == stringmap.end()) {\n\t\tstringmap[buff] = _wcsdup(Value);\n\t}\n}\n\nvoid CHashedStringList::Delete(TCHAR * String)\n{\n\tstd::wstring buff = String;\n\tif (!m_bCaseSense)\n\t\tstd::transform(buff.begin(), buff.end(), buff.begin(), ::towlower);\n\tstringmap.erase(buff);\n}\n\nTCHAR * CHashedStringList::Find(TCHAR * String)\n{\n\tTCHAR* b = _wcsdup(String);\n\tif (!m_bCaseSense)\n\t\tb = _wcslwr(b);\n\tstd::wstring buff = b;\n\tfree(b);\n\tstrmap::iterator it = stringmap.find(buff);\n\tif (it != stringmap.end())\n\t\treturn it->second;\n\telse\n\t\treturn NULL;\n}\n"
        },
        {
          "name": "hash_list.h",
          "type": "blob",
          "size": 0.6044921875,
          "content": "//#include \"stdint.h\"\n#include \"malloc.h\"\n#include \"string.h\"\n#include \"windows.h\"\n#include <map>\n#include <string>\n\ntypedef std::map<std::wstring, LPTSTR> strmap;\n\nclass CHashedStringList\n{\npublic:\n\tvoid Add(TCHAR * String, TCHAR * Value);\n\tvoid Delete(TCHAR * String);\n\tTCHAR * Find(TCHAR * String);\n\tCHashedStringList() : m_bCaseSense(false){}\n\tCHashedStringList(BOOL bCaseSensative) : m_bCaseSense(bCaseSensative){}\n\t~CHashedStringList(){\n\t\tstrmap::iterator it = stringmap.begin();\n\t\twhile (it != stringmap.end()) {\n\t\t\tfree(it->second);\n\t\t\t++it;\n\t\t}\n\t}\nprotected:\nprivate:\n\tstrmap stringmap;\n\tBOOL m_bCaseSense;\n};\n"
        },
        {
          "name": "hook.cpp",
          "type": "blob",
          "size": 18.2470703125,
          "content": "// API hook\r\n//\r\n// GetProcAddressで得たcall先（関数本体）を直接書き換え、\r\n// 自分のフック関数にjmpさせる。\r\n//\r\n// 内部で元のAPIを使う時は、コードを一度戻してからcall。\r\n// すぐにjmpコードに戻す。\r\n//\r\n// マルチスレッドで 書き換え中にcallされると困るので、\r\n// CriticalSectionで排他制御しておく。\r\n//\r\n\r\n#include \"override.h\"\r\n#include \"ft.h\"\r\n#include \"fteng.h\"\r\n#include <locale.h>\r\n#include \"undocAPI.h\"\r\n#include \"delayimp.h\"\r\n#include <dwrite_2.h>\r\n#include <dwrite_3.h>\r\n#include <VersionHelpers.h>\r\n#include \"EventLogging.h\"\r\n#include \"hookCounter.h\"\r\n\r\n#ifdef STATIC_LIB\r\n\t#include <aux_ulib.h>\r\n\t#include <psapi.h>\r\n\r\n\t#pragma comment(lib, \"aux_ulib.lib\")\r\n\t#pragma comment(lib, \"psapi.lib\")\r\n#endif\r\n\r\n#ifndef _WIN64\r\n#include \"wow64ext.h\"\r\n#endif\r\n#ifdef INFINALITY\r\n#include <freetype/ftenv.h>\r\n#endif\r\n#pragma comment(lib, \"delayimp\")\r\n\r\nHINSTANCE g_dllInstance;\r\n\r\n//PFNLdrGetProcedureAddress LdrGetProcedureAddress = (PFNLdrGetProcedureAddress)GetProcAddress(LoadLibrary(_T(\"ntdll.dll\")),\"LdrGetProcedureAddress\");\r\n//PFNCreateProcessW nCreateProcessW = (PFNCreateProcessW)MyGetProcAddress(LoadLibrary(_T(\"kernel32.dll\")),\"CreateProcessW\");\r\n//PFNCreateProcessA nCreateProcessA = (PFNCreateProcessA)MyGetProcAddress(LoadLibrary(_T(\"kernel32.dll\")),\"CreateProcessA\");\r\n// HMODULE hGDIPP = GetModuleHandleW(L\"gdiplus.dll\");\r\n// typedef int (WINAPI *PFNGdipCreateFontFamilyFromName)(const WCHAR *name, void *fontCollection, void **FontFamily);\r\n// PFNGdipCreateFontFamilyFromName GdipCreateFontFamilyFromName = hGDIPP? (PFNGdipCreateFontFamilyFromName)GetProcAddress(hGDIPP, \"GdipCreateFontFamilyFromName\"):0;\r\n\r\n#ifdef USE_DETOURS\r\n\r\n#include \"detours.h\"\r\n#ifdef _M_IX86\r\n#pragma comment (lib, \"detours.lib\")\r\n#else\r\n#pragma comment (lib, \"detours64.lib\")\r\n#endif\r\n// DATA_foo、ORIG_foo の２つをまとめて定義するマクロ\r\n#define HOOK_MANUALLY HOOK_DEFINE\r\n#define HOOK_DEFINE(rettype, name, argtype, arglist) \\\r\n\trettype (WINAPI * ORIG_##name) argtype; \\\r\n\tBOOL IsHooked_##name = false; \\\r\n\trettype WINAPI REF_##name argtype { \\\r\n\t\tHCounter _; \\\r\n\t\treturn IMPL_##name arglist; \\\r\n\t}\r\n\r\n#include \"hooklist.h\"\r\n\r\n#undef HOOK_DEFINE\r\n#undef HOOK_MANUALLY\r\n\r\n//\r\n#define HOOK_MANUALLY(rettype, name, argtype, arglist) ;\r\n#define HOOK_DEFINE(rettype, name, argtype, arglist) \\\r\n\tORIG_##name = name;\r\n#pragma optimize(\"s\", on)\r\nstatic void hook_initinternal()\r\n{\r\n#include \"hooklist.h\"\r\n}\r\n#pragma optimize(\"\", on)\r\n#undef HOOK_DEFINE\r\n#undef HOOK_MANUALLY\r\n\r\n#define HOOK_MANUALLY(rettype, name, argtype, arglist) ;\r\n#define HOOK_DEFINE(rettype, name, argtype, arglist) \\\r\n\tif (&ORIG_##name && !IsHooked_##name) { \\\r\n\t\tif (DetourAttach(&(PVOID&)ORIG_##name, REF_##name) == NOERROR) IsHooked_##name = true; \\\r\n\t}\r\n\r\nstatic LONG hook_init()\r\n{\r\n\tDetourRestoreAfterWith();\r\n\r\n\tDetourTransactionBegin();\r\n\tDetourUpdateThread(GetCurrentThread());\r\n\r\n#include \"hooklist.h\"\r\n\r\n\tLONG error = DetourTransactionCommit();\r\n\r\n\tif (error != NOERROR) {\r\n\t\tTRACE(_T(\"hook_init error: %#x\\n\"), error);\r\n\t}\r\n\treturn error;\r\n}\r\n#undef HOOK_DEFINE\r\n#undef HOOK_MANUALLY\r\n\r\n#define HOOK_DEFINE(rettype, name, argtype, arglist);\r\n#define HOOK_MANUALLY(rettype, name, argtype, arglist) \\\r\n\tLONG hook_demand_##name(bool bForce = false){ \\\r\n\tDetourRestoreAfterWith(); \\\r\n\tDetourTransactionBegin(); \\\r\n\tDetourUpdateThread(GetCurrentThread()); \\\r\n\tif (&ORIG_##name && (bForce || !IsHooked_##name)) { DetourAttach(&(PVOID&)ORIG_##name, REF_##name); IsHooked_##name = true; } \\\r\n\tLONG error = DetourTransactionCommit(); \\\r\n\tif (error != NOERROR) { \\\r\n\t    TRACE(_T(\"hook_init error: %#x\\n\"), error); \\\r\n    } \\\r\n\treturn error; \\\r\n}\r\n\r\n#include \"hooklist.h\"\r\n#undef HOOK_MANUALLY\r\n#undef HOOK_DEFINE\r\n\r\n//\r\n#define HOOK_MANUALLY HOOK_DEFINE\r\n#define HOOK_DEFINE(rettype, name, argtype, arglist) \\\r\n\tif (IsHooked_##name) DetourDetach(&(PVOID&)ORIG_##name, REF_##name); \\\r\n\tIsHooked_##name = false;\r\nstatic void hook_term()\r\n{\r\n\tDetourTransactionBegin();\r\n\tDetourUpdateThread(GetCurrentThread());\r\n\r\n#include \"hooklist.h\"\r\n\r\n\tLONG error = DetourTransactionCommit();\r\n\r\n\tif (error != NOERROR) {\r\n\t\tTRACE(_T(\"hook_term error: %#x\\n\"), error);\r\n\t}\r\n\tHCounter::wait(3000);\r\n}\r\n#undef HOOK_DEFINE\r\n#undef HOOK_MANUALLY\r\n\r\n#else\r\n#include \"easyhook.h\"\r\n#ifdef _M_IX86\r\n#pragma comment (lib, \"easyhk32.lib\")\r\n#else\r\n#pragma comment (lib, \"easyhk64.lib\")\r\n#endif\r\n\r\n#define HOOK_MANUALLY HOOK_DEFINE\r\n#define HOOK_DEFINE(rettype, name, argtype, arglist) \\\r\n\trettype (WINAPI * ORIG_##name) argtype; \\\r\n\tHOOK_TRACE_INFO HOOK_##name = {0};\t//建立hook结构\r\n\r\n#include \"hooklist.h\"\r\n#undef HOOK_DEFINE\r\n#undef HOOK_MANUALLY\r\n\r\n//\r\n#define HOOK_MANUALLY(rettype, name, argtype, arglist) ;\r\n#define HOOK_DEFINE(rettype, name, argtype, arglist) \\\r\n\tORIG_##name = name;\r\n#pragma optimize(\"s\", on)\r\nstatic void hook_initinternal()\r\n{\r\n#include \"hooklist.h\"\r\n}\r\n#pragma optimize(\"\", on)\r\n#undef HOOK_DEFINE\r\n#undef HOOK_MANUALLY\r\n\r\n#define FORCE(expr) {if(!SUCCEEDED(NtStatus = (expr))) goto ERROR_ABORT;}\r\n\r\n#define HOOK_DEFINE(rettype, name, argtype, arglist) \\\r\n\tif (&ORIG_##name) { \\\r\n\tFORCE(LhInstallHook((PVOID&)ORIG_##name, IMPL_##name, (PVOID)0, &HOOK_##name)); \\\r\n\t*(void**)&ORIG_##name =  (void*)HOOK_##name.Link->OldProc; \\\r\n\tFORCE(LhSetExclusiveACL(ACLEntries, 0, &HOOK_##name)); }\r\n#define HOOK_MANUALLY(rettype, name, argtype, arglist) ;\r\n\r\nstatic LONG hook_init()\r\n{\r\n\tULONG ACLEntries[1] = {0};\r\n\tNTSTATUS NtStatus;\r\n\r\n#include \"hooklist.h\"\r\n#undef HOOK_DEFINE\r\n\r\n\tFORCE(LhSetGlobalExclusiveACL(ACLEntries, 0));\r\n\treturn NOERROR;\r\n\r\nERROR_ABORT:\r\n\tTRACE(_T(\"hook_init error: %#x\\n\"), NtStatus);\r\n\treturn 1;\r\n}\r\n#undef HOOK_DEFINE\r\n#undef HOOK_MANUALLY\r\n\r\n#define HOOK_DEFINE(rettype, name, argtype, arglist);\r\n#define HOOK_MANUALLY(rettype, name, argtype, arglist) \\\r\n\tLONG hook_demand_##name(bool bForce = false){ \\\r\n\tNTSTATUS NtStatus; \\\r\n\tULONG ACLEntries[1] = { 0 }; \\\r\n\tif (bForce) {  \\\r\n\t\tmemset((void*)&HOOK_##name, 0, sizeof(HOOK_TRACE_INFO));  \\\r\n\t}  \\\r\n\tif (&ORIG_##name) {\t\\\r\n\tFORCE(LhInstallHook((PVOID&)ORIG_##name, IMPL_##name, (PVOID)0, &HOOK_##name)); \\\r\n\t*(void**)&ORIG_##name =  (void*)HOOK_##name.Link->OldProc; \\\r\n\tFORCE(LhSetExclusiveACL(ACLEntries, 0, &HOOK_##name)); } \\\r\n\treturn NOERROR; \\\r\n\tERROR_ABORT: \\\r\n\tTRACE(_T(\"hook_init error: %#x\\n\"), NtStatus); \\\r\n\treturn 1; \\\r\n\t}\r\n\r\n#include \"hooklist.h\"\r\n#undef HOOK_MANUALLY\r\n\r\n\r\n#undef HOOK_MANUALLY\r\n#undef HOOK_DEFINE\r\n\r\n#define HOOK_MANUALLY(rettype, name, argtype, arglist) ;\r\n#define HOOK_DEFINE(rettype, name, argtype, arglist) \\\r\n\tORIG_##name = name;\r\n#pragma optimize(\"s\", on)\r\nstatic LONG hook_term()\r\n{\r\n\t#include \"hooklist.h\"\r\n\tLhUninstallAllHooks();\r\n\treturn LhWaitForPendingRemovals();\r\n}\r\n#endif\r\n#pragma optimize(\"\", on)\r\n#undef HOOK_DEFINE\r\n#undef HOOK_MANUALLY\r\n\r\n//---\r\n\r\nCTlsData<CThreadLocalInfo>\tg_TLInfo;\r\nHINSTANCE\t\t\t\t\tg_hinstDLL;\r\nLONG\t\t\t\t\t\tg_bHookEnabled;\r\n#ifdef _DEBUG\r\nHANDLE\t\t\t\t\t\tg_hfDbgText;\r\n#endif\r\n\r\n//void InstallManagerHook();\r\n//void RemoveManagerHook();\r\n\r\n//#include \"APITracer.hpp\"\r\n\r\n//ベースアドレスを変えた方がロードが早くなる\r\n#if _DLL\r\n#pragma comment(linker, \"/base:0x06540000\")\r\n#endif\r\n\r\ntypedef BOOL(WINAPI *TIsImmersiveProcess)(_In_ HANDLE hProcess);\r\n\r\nTIsImmersiveProcess IsUWP = (TIsImmersiveProcess)GetProcAddress(GetModuleHandle(L\"user32.dll\"), \"IsImmersiveProcess\");\r\n\r\nBOOL WINAPI IsRunAsUser(VOID)\r\n{\r\n\tif (IsUWP && IsUWP(GetCurrentProcess())) return true;\t// treat all UWP apps as user exe\r\n\tHANDLE hProcessToken = NULL;\r\n\tDWORD groupLength = 50;\r\n\r\n\tPTOKEN_GROUPS groupInfo = (PTOKEN_GROUPS)LocalAlloc(0,\r\n\t\tgroupLength);\r\n\r\n\tSID_IDENTIFIER_AUTHORITY siaNt = SECURITY_NT_AUTHORITY;\r\n\tPSID InteractiveSid = NULL;\r\n\tPSID ServiceSid = NULL;\r\n\tDWORD i;\r\n\r\n\t// Start with assumption that process is an SERVICE, not a EXE;\r\n\tBOOL fExe = FALSE;\r\n\r\n\r\n\tif (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY,\r\n\t\t&hProcessToken))\r\n\t\tgoto ret;\r\n\r\n\tif (groupInfo == NULL)\r\n\t\tgoto ret;\r\n\r\n\tif (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo,\r\n\t\tgroupLength, &groupLength))\r\n\t{\r\n\t\tif (GetLastError() != ERROR_INSUFFICIENT_BUFFER)\r\n\t\t\tgoto ret;\r\n\r\n\t\tLocalFree(groupInfo);\r\n\t\tgroupInfo = NULL;\r\n\r\n\t\tgroupInfo = (PTOKEN_GROUPS)LocalAlloc(0, groupLength);\r\n\r\n\t\tif (groupInfo == NULL)\r\n\t\t\tgoto ret;\r\n\r\n\t\tif (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo,\r\n\t\t\tgroupLength, &groupLength))\r\n\t\t{\r\n\t\t\tgoto ret;\r\n\t\t}\r\n\t}\r\n\r\n\t//\r\n\t//  We now know the groups associated with this token.  We want to look to\tsee if\r\n\t\t//  the interactive group is active in the token, and if so, we know that\r\n\t\t//  this is an interactive process.\r\n\t\t//\r\n\t\t//  We also look for the \"service\" SID, and if it's present, we know we're a service.\r\n\t\t//\r\n\t\t//  The service SID will be present iff the service is running in a\r\n\t\t//  user account (and was invoked by the service controller).\r\n\t\t//\r\n\r\n\r\n\tif (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_INTERACTIVE_RID, 0,\r\n\t\t0,\r\n\t\t0, 0, 0, 0, 0, &InteractiveSid))\r\n\t{\r\n\t\tgoto ret;\r\n\t}\r\n\r\n\tif (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_SERVICE_RID, 0, 0, 0,\r\n\t\t0, 0, 0, 0, &ServiceSid))\r\n\t{\r\n\t\tgoto ret;\r\n\t}\r\n\r\n\tfor (i = 0; i < groupInfo->GroupCount; i += 1)\r\n\t{\r\n\t\tSID_AND_ATTRIBUTES sanda = groupInfo->Groups[i];\r\n\t\tPSID Sid = sanda.Sid;\r\n\r\n\t\t//\r\n\t\t//  Check to see if the group we're looking at is one of\r\n\t\t//  the 2 groups we're interested in.\r\n\t\t//\r\n\r\n\t\tif (EqualSid(Sid, InteractiveSid))\r\n\t\t{\r\n\t\t\t//\r\n\t\t\t//  This process has the Interactive SID in its\r\n\t\t\t//  token.  This means that the process is running as\r\n\t\t\t//  an EXE.\r\n\t\t\t//\r\n\t\t\tfExe = true;\r\n\t\t\tgoto ret;\r\n\t\t}\r\n\t\telse if (EqualSid(Sid, ServiceSid))\r\n\t\t{\r\n\t\t\t//\r\n\t\t\t//  This process has the Service SID in its\r\n\t\t\t//  token.  This means that the process is running as\r\n\t\t\t//  a service running in a user account.\r\n\t\t\t//\r\n\t\t\tfExe = FALSE;\r\n\t\t\tgoto ret;\r\n\t\t}\r\n\t}\r\n\r\n\t//\r\n\t//  Neither Interactive or Service was present in the current users token,\r\n\t//  This implies that the process is running as a service, most likely\r\n\t//  running as LocalSystem.\r\n\t//\r\n\tfExe = FALSE;\r\n\r\nret:\r\n\r\n\tif (InteractiveSid)\r\n\t\tFreeSid(InteractiveSid);\r\n\r\n\tif (ServiceSid)\r\n\t\tFreeSid(ServiceSid);\r\n\r\n\tif (groupInfo)\r\n\t\tLocalFree(groupInfo);\r\n\r\n\tif (hProcessToken)\r\n\t\tCloseHandle(hProcessToken);\r\n\r\n// \tEventLogging logger;\r\n// \tTCHAR s[100] = { 0 };\r\n// \twsprintf(s, L\"Loading processid %d, isUserProcess=%d\", GetCurrentProcessId(), (int)fExe);\r\n// \tLPCTSTR lpStrings[] = {s}; \r\n// \tlogger.LogIt(1, 1, lpStrings, 1);\r\n\treturn(fExe);\r\n}\r\n\r\nBOOL AddEasyHookEnv()\r\n{\r\n\tTCHAR dir[MAX_PATH];\r\n\tint dirlen = GetModuleFileName(GetDLLInstance(), dir, MAX_PATH);\r\n\tLPTSTR lpfilename=dir+dirlen;\r\n\twhile (lpfilename>dir && *lpfilename!=_T('\\\\') && *lpfilename!=_T('/')) --lpfilename;\r\n\t*lpfilename = 0;\r\n\t_tcscat(dir, _T(\";\"));\r\n\tdirlen = _tcslen(dir);\r\n\tint sz=GetEnvironmentVariable(_T(\"path\"), NULL, 0);\r\n\tLPTSTR lpPath = (LPTSTR)malloc((sz+dirlen+2)*sizeof(TCHAR));\r\n\tGetEnvironmentVariable(_T(\"path\"), lpPath, sz);\r\n\tif (!_tcsstr(lpPath, dir))\r\n\t{\r\n\t\tif (lpPath[sz-2]!=_T(';'))\r\n\t\t\t_tcscat(lpPath, _T(\";\"));\r\n\t\t_tcscat(lpPath, dir);\r\n\t\tSetEnvironmentVariable(_T(\"path\"), lpPath);\r\n\t}\r\n\tfree(lpPath);\r\n\treturn true;\r\n}\r\n\r\nvoid HookFontCreation() {\r\n\tHMODULE gdi32 = GetModuleHandle(L\"gdi32full.dll\");\t// prefer to hook deeply\r\n\tif (!gdi32) {\r\n\t\tgdi32 = GetModuleHandle(L\"gdi32.dll\");\r\n\t}\r\n\tif (gdi32) {\r\n\t\tvoid* CreateFontIndirectW = GetProcAddress(gdi32, \"CreateFontIndirectWImpl\");\r\n\t\tvoid* CreateFontIndirectExW = GetProcAddress(gdi32, \"CreateFontIndirectExW\");\r\n\t\tif (!CreateFontIndirectW) {\r\n\t\t\tCreateFontIndirectW = GetProcAddress(gdi32, \"CreateFontIndirectW\");\r\n\t\t}\r\n\t\t*(DWORD_PTR*)&ORIG_CreateFontIndirectW = (DWORD_PTR)CreateFontIndirectW;\r\n\t\t*(DWORD_PTR*)&ORIG_CreateFontIndirectExW = (DWORD_PTR)CreateFontIndirectExW;\r\n\r\n\t\thook_demand_CreateFontIndirectExW();\r\n\t\thook_demand_CreateFontIndirectW();\r\n\t}\r\n}\r\n\r\nextern FT_Int * g_charmapCache;\r\nextern BYTE* AACache, *AACacheFull;\t\r\nextern HFONT g_alterGUIFont;\r\nextern void DebugOut(const WCHAR* szFormat, ...);\r\n\r\n\r\nvoid EZHookMain(HINSTANCE instance, DWORD reason, LPVOID lpReserved) {\r\n#ifdef STATIC_LIB\r\n\tswitch (reason) {\r\n\tcase DLL_PROCESS_ATTACH:\r\n\tcase DLL_THREAD_ATTACH:\r\n\tcase DLL_THREAD_DETACH:\r\n\t\tEasyHookDllMain(instance, reason, lpReserved);\r\n\t}\r\n#else\r\n\tswitch (reason) {\r\n\tcase DLL_PROCESS_ATTACH:\r\n\t{\r\n\t\tLPWSTR dllPath = new WCHAR[MAX_PATH + 1];\r\n\t\tint nSize = GetModuleFileName(g_dllInstance, dllPath, MAX_PATH + 1);\r\n\t\tWCHAR* p = &dllPath[nSize];\r\n\t\twhile (*--p != L'\\\\');\r\n\t\t*p = L'\\0';\r\n#ifdef _WIN64\r\n\t\twcscat(dllPath, L\"\\\\easyhk64.dll\");\r\n#else\r\n\t\twcscat(dllPath, L\"\\\\easyhk32.dll\");\r\n#endif\r\n\t\tHMODULE hEasyhk = LoadLibrary(dllPath);\r\n\t\tdelete[]dllPath;\r\n\t\tif (!hEasyhk) {\r\n\t\t\tDebugOut(L\"Failed to load Easyhook, exiting\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t}\r\n#endif\r\n}\r\n\r\nextern COLORCACHE* g_AACache2[MAX_CACHE_SIZE]; \r\nHANDLE hDelayHook = 0;\r\nBOOL WINAPI  DllMain(HINSTANCE instance, DWORD reason, LPVOID lpReserved)\r\n{\r\n\ttry {\r\n\t\tstatic bool bDllInited = false;\r\n\t\tBOOL IsUnload = false, bEnableDW = true, bUseFontSubstitute = false;\r\n\r\n\r\n\t\tswitch (reason) {\r\n\t\tcase DLL_PROCESS_ATTACH:\r\n#ifdef DEBUG\r\n\t\t\tMessageBox(0, L\"Load\", NULL, MB_OK);\r\n#endif\r\n\t\t\tDebugOut(L\"Begin core loading stage, pid %d\", ::GetCurrentProcessId());\r\n\t\t\tif (bDllInited)\r\n\t\t\t\treturn true;\r\n\t\t\tg_dllInstance = instance;\r\n#ifdef EASYHOOK\r\n\t\t\tEZHookMain(instance, reason, lpReserved);\r\n#endif\r\n\t\t\t//初期化順序\r\n\t\t\t//DLL_PROCESS_DETACHではこれの逆順にする\r\n\t\t\t//1. CRT関数の初期化\r\n\t\t\t//2. クリティカルセクションの初期化\r\n\t\t\t//3. TLSの準備\r\n\t\t\t//4. CGdippSettingsのインスタンス生成、INI読み込み\r\n\t\t\t//5. ExcludeModuleチェック\r\n\t\t\t// 6. FreeTypeライブラリの初期化\r\n\t\t\t// 7. FreeTypeFontEngineのインスタンス生成\r\n\t\t\t// 8. APIをフック\r\n\t\t\t// 9. ManagerのGetProcAddressをフック\r\n\r\n\t\t\t//1\r\n\t\t\t_CrtSetDbgFlag(_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) | _CRTDBG_LEAK_CHECK_DF);\r\n\t\t\t_CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG | _CRTDBG_MODE_WNDW);\r\n\t\t\t//_CrtSetBreakAlloc(100);\r\n\r\n\t\t\t//Operaよ止まれ～\r\n\t\t\t//Assert(GetModuleHandleA(\"opera.exe\") == NULL);\r\n\r\n\t\t\t//setlocale(LC_ALL, \"\");\r\n\t\t\tg_hinstDLL = instance;\r\n\r\n\r\n\t\t\t//APITracer::Start(instance, APITracer::OutputFile);\r\n\r\n\t\t\t\t\t//2, 3\r\n\t\t\tCCriticalSectionLock::Init();\r\n\t\t\tCOwnedCriticalSectionLock::Init();\r\n\t\t\tCThreadCounter::Init();\r\n\t\t\tif (!g_TLInfo.ProcessInit()) {\r\n\t\t\t\tDebugOut(L\"Can't initialize process, exiting\");\r\n\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\r\n\t\t\t// Above classes are heavily referenced and must be initialized as early as possible.\r\n\t\t\t// Unload dll is not safe until their initialization is complete.\r\n\t\t\tbDllInited = true;\r\n\r\n\t\t\t//4\r\n\t\t\t{\r\n#ifdef INFINALITY \r\n\t\t\t\t// enable infinality exclusive features\r\n\t\t\t\tFT_initEnv();\r\n#endif\r\n\t\t\t\tCGdippSettings* pSettings = CGdippSettings::CreateInstance();\r\n\t\t\t\tif (!pSettings || !pSettings->LoadSettings(instance)) {\r\n\t\t\t\t\tCGdippSettings::DestroyInstance();\r\n\t\t\t\t\treturn FALSE;\r\n\t\t\t\t}\r\n\t\t\t\tIsUnload = IsProcessUnload();\r\n\t\t\t\tbEnableDW = pSettings->DirectWrite();\r\n\t\t\t\tbUseFontSubstitute = !!pSettings->FontSubstitutes();\r\n\t\t\t}\r\n\t\t\tif (!IsUnload) hook_initinternal();\t//不加载的模块就不做任何事莵E\r\n\t\t\t//5\r\n\t\t\tif (!IsProcessExcluded() && !IsUnload) {\r\n#ifndef _WIN64\r\n\t\t\t\tInitWow64ext();\r\n#endif\r\n\t\t\t\tif (!FontLInit()) {\r\n\t\t\t\t\tDebugOut(L\"FreeType failed to initialize, exiting\");\r\n\t\t\t\t\treturn FALSE;\r\n\t\t\t\t}\r\n\t\t\t\tg_pFTEngine = new FreeTypeFontEngine;\r\n\t\t\t\tif (!g_pFTEngine) {\r\n\t\t\t\t\treturn FALSE;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//if (!AddEasyHookEnv()) return FALSE;\t//fail to load easyhook\r\n\t\t\t\tInterlockedExchange(&g_bHookEnabled, TRUE);\r\n\t\t\t\tif (hook_init() != NOERROR) {\r\n\t\t\t\t\tDebugOut(L\"Can't do hooking, exiting\");\r\n\t\t\t\t\treturn FALSE;\r\n\t\t\t\t}\r\n\t\t\t\t//hook d2d if already loaded\r\n\t/*\r\n\t\t\t\tDWORD dwSessionID = 0;\r\n\t\t\t\tif (ProcessIdToSessionIdProc)\r\n\t\t\t\t\tProcessIdToSessionIdProc(GetCurrentThreadId(), &dwSessionID);\r\n\t\t\t\telse\r\n\t\t\t\t\tdwSessionID = 1;*/\r\n\t\t\t\tif (IsRunAsUser() && bEnableDW && IsWindowsVistaOrGreater())\t//vista or later\r\n\t\t\t\t{\r\n\t\t\t\t\tHookD2DDll();\r\n\t\t\t\t\t//hook_demand_LdrLoadDll();\r\n\t\t\t\t}\r\n\t\t\t\t// only hook font creation funcs if font substition is set.\r\n\t\t\t\tif (bUseFontSubstitute) {\r\n\t\t\t\t\tHookFontCreation();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t//获得当前加载模式\r\n\r\n\t\t\tif (IsUnload)\r\n\t\t\t{\r\n\t\t\t\tHANDLE mutex_offical = OpenMutex(MUTEX_ALL_ACCESS, false, _T(\"{46AD3688-30D0-411e-B2AA-CB177818F428}\"));\r\n\t\t\t\tHANDLE mutex_gditray2 = OpenMutex(MUTEX_ALL_ACCESS, false, _T(\"Global\\\\MacType\"));\r\n\t\t\t\tif (!mutex_gditray2)\r\n\t\t\t\t\tmutex_gditray2 = OpenMutex(MUTEX_ALL_ACCESS, false, _T(\"MacType\"));\r\n\t\t\t\tHANDLE mutex_CompMode = OpenMutex(MUTEX_ALL_ACCESS, false, _T(\"Global\\\\MacTypeCompMode\"));\r\n\t\t\t\tif (!mutex_CompMode)\r\n\t\t\t\t\tmutex_CompMode = OpenMutex(MUTEX_ALL_ACCESS, false, _T(\"MacTypeCompMode\"));\r\n\t\t\t\tBOOL HookMode = (mutex_offical || (mutex_gditray2 && mutex_CompMode)) || (!mutex_offical && !mutex_gditray2);\t//是否在兼容模式下\r\n\t\t\t\tCloseHandle(mutex_CompMode);\r\n\t\t\t\tCloseHandle(mutex_gditray2);\r\n\t\t\t\tCloseHandle(mutex_offical);\r\n\t\t\t\tif (!HookMode) {\t//非兼容模式下，拒绝加载\r\n\t\t\t\t\tDebugOut(L\"Process is in unloaddll list, exiting\");\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//APITracer::Finish();\r\n\t\t\tbreak;\r\n\t\tcase DLL_THREAD_ATTACH:\r\n#ifdef EASYHOOK\r\n\t\t\tEZHookMain(instance, reason, lpReserved);\r\n#endif\r\n\t\t\tbreak;\r\n\t\tcase DLL_THREAD_DETACH:\r\n\t\t\tg_TLInfo.ThreadTerm();\r\n#ifdef EASYHOOK\r\n\t\t\tEZHookMain(instance, reason, lpReserved);\r\n#endif\r\n\t\t\tbreak;\r\n\t\tcase DLL_PROCESS_DETACH:\r\n\t\t\t//\t\tRemoveManagerHook();\r\n\t\t\tif (!bDllInited)\r\n\t\t\t\treturn true;\r\n\t\t\tbDllInited = false;\r\n\t\t\tif (InterlockedExchange(&g_bHookEnabled, FALSE) && lpReserved == NULL) {\t//如果是进程终止，则不需要释放\r\n\t\t\t\thook_term();\r\n\t\t\t\t//delete AACacheFull;\r\n\t\t\t\t//delete AACache;\r\n\t// \t\t\tfor (int i=0;i<CACHE_SIZE;i++)\r\n\t// \t\t\t\tdelete g_AACache2[i];\t//清除缓磥E\r\n\t\t\t\t//free(g_charmapCache);\r\n\t\t\t}\r\n#ifndef DEBUG\r\n\t\t\tif (lpReserved != NULL) return true;\r\n#endif\r\n\r\n\t\t\tif (g_pFTEngine) {\r\n\t\t\t\tdelete g_pFTEngine;\r\n\t\t\t}\r\n\r\n#ifdef INFINALITY \r\n\t\t\t// enable infinality exclusive features\r\n\t\t\tFT_freeEnv();\r\n#endif\r\n\t\t\t//if (g_alterGUIFont)\r\n\t\t\t//\tDeleteObject(g_alterGUIFont);\r\n\t\t\tFontLFree();\r\n\t\t\t/*\r\n\t\t\t#ifndef _WIN64\r\n\t\t\t\t\t__FUnloadDelayLoadedDLL2(\"easyhook32.dll\");\r\n\t\t\t#else\r\n\t\t\t\t\t__FUnloadDelayLoadedDLL2(\"easyhook64.dll\");\r\n\t\t\t#endif*/\r\n\r\n\t\t\tCGdippSettings::DestroyInstance();\r\n\t\t\tg_TLInfo.ProcessTerm();\r\n\t\t\tCCriticalSectionLock::Term();\r\n\t\t\tCOwnedCriticalSectionLock::Term();\r\n#ifdef EASYHOOK\r\n\t\t\tEZHookMain(instance, reason, lpReserved);\r\n#endif\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\treturn TRUE;\r\n\t}\r\n\tcatch(...) {\r\n\t\treturn FALSE;\r\n\t}\r\n}\r\n//EOF\r\n"
        },
        {
          "name": "hookCounter.cpp",
          "type": "blob",
          "size": 0.0791015625,
          "content": "#include \"hookCounter.h\"\r\n#include <atomic>\r\n\r\nstd::atomic<int> HCounter::ref(0);"
        },
        {
          "name": "hookCounter.h",
          "type": "blob",
          "size": 0.3798828125,
          "content": "#pragma once\r\n#include <atomic>\r\n#include <thread>\r\n#include <chrono>\r\n\r\nclass HCounter {\r\n\tstatic std::atomic<int> ref;\r\n\r\npublic:\r\n\tHCounter() {\r\n\t\t++this->ref;\r\n\t}\r\n\r\n\t~HCounter() {\r\n\t\t--this->ref;\r\n\t}\r\n\r\n\tstatic bool wait(int nCount) {\r\n\t\twhile (--nCount && HCounter::ref.load()) {\r\n\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(1));\r\n\t\t}\r\n\t\treturn !HCounter::ref;\r\n\t}\r\n};\r\n"
        },
        {
          "name": "hooklist.h",
          "type": "blob",
          "size": 16.3515625,
          "content": "HOOK_DEFINE(int, GetObjectW,  (__in HANDLE h, __in int c, __out_bcount_opt(c) LPVOID pv), (h, c, pv))\r\nHOOK_DEFINE(int, GetObjectA,  (__in HANDLE h, __in int c, __out_bcount_opt(c) LPVOID pv), (h, c, pv))\r\nHOOK_DEFINE(int, GetTextFaceAliasW, (HDC hdc, int nLen, LPWSTR lpAliasW), (hdc, nLen, lpAliasW))\r\nHOOK_DEFINE(BOOL, DeleteObject, ( HGDIOBJ hObject),(hObject))\r\nHOOK_DEFINE(int, GetTextFaceW, ( __in HDC hdc, __in int c, __out_ecount_part_opt(c, return)  LPWSTR lpName), (hdc, c, lpName))\r\nHOOK_DEFINE(int, GetTextFaceA, ( __in HDC hdc, __in int c, __out_ecount_part_opt(c, return)  LPSTR lpName), (hdc, c, lpName))\r\nHOOK_DEFINE(DWORD, GetGlyphOutlineW, (    __in HDC hdc, \\\r\n\t\t\t__in UINT uChar, \\\r\n\t\t\t__in UINT fuFormat, \\\r\n\t\t\t__out LPGLYPHMETRICS lpgm, \\\r\n\t\t\t__in DWORD cjBuffer, \\\r\n\t\t\t__out_bcount_opt(cjBuffer) LPVOID pvBuffer, \\\r\n\t\t\t__in CONST MAT2 *lpmat2 \\\r\n\t\t\t), (hdc, uChar, fuFormat, lpgm, cjBuffer, pvBuffer, lpmat2))\r\nHOOK_DEFINE(DWORD, GetGlyphOutlineA, (__in HDC hdc, \\\r\n\t\t\t__in UINT uChar, \\\r\n\t\t\t__in UINT fuFormat, \\\r\n\t\t\t__out LPGLYPHMETRICS lpgm, \\\r\n\t\t\t__in DWORD cjBuffer, \\\r\n\t\t\t__out_bcount_opt(cjBuffer) LPVOID pvBuffer, \\\r\n\t\t\t__in CONST MAT2 *lpmat2), \\\r\n\t\t\t(hdc, uChar, fuFormat, lpgm, cjBuffer, pvBuffer, lpmat2))\r\n\r\n\r\n// DrawTextA,W\r\n// DrawTextExA,W\r\n// TabbedTextOutA,W\r\n// TextOutA,W\r\n// ExtTextOutA\r\n// は内部で ExtTextOutWを呼んでるから ExtTextOutW だけ実装すればOK。←XPの場合\r\n// Windows 2000 でも動くようにその他のAPIもフックを掛けておく。\r\n\r\nHOOK_MANUALLY(HFONT, CreateFontIndirectW, (CONST LOGFONTW *lplf), (lplf))\r\nHOOK_MANUALLY(HFONT, CreateFontIndirectExW, (CONST ENUMLOGFONTEXDV *penumlfex), (penumlfex))\r\n\r\n// HOOK_DEFINE(BOOL, GetCharWidthW, (HDC hdc, UINT iFirstChar, UINT iLastChar, LPINT lpBuffer))\r\n// HOOK_DEFINE(BOOL, GetCharWidth32W, (HDC hdc, UINT iFirstChar, UINT iLastChar, LPINT lpBuffer))\r\n\r\n\r\nHOOK_DEFINE(BOOL, TextOutA, (HDC hdc, int nXStart, int nYStart, LPCSTR  lpString, int cbString), (hdc, nXStart, nYStart, lpString, cbString))\r\nHOOK_DEFINE(BOOL, TextOutW, (HDC hdc, int nXStart, int nYStart, LPCWSTR lpString, int cbString), (hdc, nXStart, nYStart, lpString, cbString))\r\n\r\nHOOK_DEFINE(BOOL, ExtTextOutA, (HDC hdc, int nXStart, int nYStart, UINT fuOptions, CONST RECT *lprc, LPCSTR  lpString, UINT cbString, CONST INT *lpDx), \r\n\t(hdc, nXStart, nYStart, fuOptions, lprc, lpString, cbString, lpDx))\r\n\r\nHOOK_DEFINE(BOOL, ExtTextOutW, (HDC hdc, int nXStart, int nYStart, UINT fuOptions, CONST RECT *lprc, LPCWSTR lpString, UINT cbString, CONST INT *lpDx), \r\n\t(hdc, nXStart, nYStart, fuOptions, lprc, lpString, cbString, lpDx))\r\n\r\nHOOK_DEFINE(BOOL, RemoveFontResourceExW, (__in LPCWSTR name, __in DWORD fl, __reserved PVOID pdv), (name, fl, pdv))\r\n//HOOK_DEFINE(BOOL, RemoveFontResourceW, (__in LPCWSTR lpFileName))\r\nHOOK_DEFINE(HGDIOBJ, GetStockObject, (__in int i), (i))\r\nHOOK_DEFINE(BOOL, BeginPath, (HDC hdc), (hdc))\r\nHOOK_DEFINE(BOOL, EndPath, (HDC hdc), (hdc))\r\nHOOK_DEFINE(BOOL, AbortPath, (HDC hdc), (hdc));\r\nHOOK_DEFINE(DWORD, GetFontData, (_In_ HDC     hdc,\r\n\t_In_ DWORD   dwTable,\r\n\t_In_ DWORD   dwOffset,\r\n\t_Out_writes_bytes_to_opt_(cjBuffer, return) PVOID pvBuffer,\r\n\t_In_ DWORD   cjBuffer\r\n\t), (hdc, dwTable, dwOffset, pvBuffer, cjBuffer));\r\n\r\nHOOK_MANUALLY(HRESULT, BitmapRenderTarget_DrawGlyphRun, (\r\n\tIDWriteBitmapRenderTarget* This,\r\n\tFLOAT baselineOriginX,\r\n\tFLOAT baselineOriginY,\r\n\tDWRITE_MEASURING_MODE measuringMode,\r\n\tDWRITE_GLYPH_RUN const* glyphRun,\r\n\tIDWriteRenderingParams* renderingParams,\r\n\tCOLORREF textColor,\r\n\tRECT* blackBoxRect),\r\n\t(This, baselineOriginX, baselineOriginY, measuringMode, glyphRun, renderingParams, textColor, blackBoxRect))\r\n\r\n/*\r\nHOOK_MANUALLY(void, SetTextAntialiasMode, (\r\n\t\t\t   ID2D1RenderTarget* self,\r\n\t\t\t   D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode))\r\n\r\nHOOK_MANUALLY(void, SetTextRenderingParams, (\r\n\t\t\t   ID2D1RenderTarget* self,\r\n\t\t\t   __in_opt IDWriteRenderingParams *textRenderingParams ))*/\r\n\r\nHOOK_MANUALLY(HRESULT, DWriteCreateFactory,  (\r\n\t\t\t  __in DWRITE_FACTORY_TYPE factoryType,\r\n\t\t\t  __in REFIID iid,\r\n\t\t\t  __out IUnknown **factory), (factoryType, iid, factory))\r\n\r\nHOOK_MANUALLY(HRESULT, D2D1CreateDevice, (\r\n\t\t\t  IDXGIDevice* dxgiDevice,\r\n\t\t\t  CONST D2D1_CREATION_PROPERTIES* creationProperties,\r\n\t\t\t  ID2D1Device** d2dDevice), (dxgiDevice, creationProperties, d2dDevice))\r\n\r\nHOOK_MANUALLY(HRESULT, D2D1CreateDeviceContext, (\r\n\t\t\t  IDXGISurface* dxgiSurface,\r\n\t\t\t  CONST D2D1_CREATION_PROPERTIES* creationProperties,\r\n\t\t\t  ID2D1DeviceContext** d2dDeviceContext), (dxgiSurface, creationProperties, d2dDeviceContext))\r\n\r\nHOOK_MANUALLY(HRESULT, D2D1CreateFactory, (\r\n\t\t\t\tD2D1_FACTORY_TYPE factoryType,\r\n\t\t\t\tREFIID riid,\r\n\t\t\t\tconst D2D1_FACTORY_OPTIONS* pFactoryOptions,\r\n\t\t\t\tvoid** ppIFactory), (factoryType, riid, pFactoryOptions, ppIFactory))\r\n\r\nHOOK_MANUALLY(HRESULT, GetGdiInterop, (\r\n\t\t\t  IDWriteFactory* This,\r\n\t\t\t  IDWriteGdiInterop** gdiInterop\r\n\t\t\t  ), (This, gdiInterop))\r\n\r\nHOOK_MANUALLY(HRESULT, CreateGlyphRunAnalysis, (\r\n\t\t\t  IDWriteFactory* This,\r\n\t\t\t  DWRITE_GLYPH_RUN const* glyphRun,\r\n\t\t\t  FLOAT pixelsPerDip,\r\n\t\t\t  DWRITE_MATRIX const* transform,\r\n\t\t\t  DWRITE_RENDERING_MODE renderingMode,\r\n\t\t\t  DWRITE_MEASURING_MODE measuringMode,\r\n\t\t\t  FLOAT baselineOriginX,\r\n\t\t\t  FLOAT baselineOriginY,\r\n\t\t\t  IDWriteGlyphRunAnalysis** glyphRunAnalysis\r\n\t\t\t  ), (This, glyphRun, pixelsPerDip, transform, renderingMode, measuringMode, baselineOriginX, baselineOriginY, glyphRunAnalysis))\r\n\t\r\nHOOK_MANUALLY(HRESULT, CreateGlyphRunAnalysis2, (\r\n\t\t\t  IDWriteFactory2* This,\r\n\t\t\t  DWRITE_GLYPH_RUN const* glyphRun,\r\n\t\t\t  DWRITE_MATRIX const* transform,\r\n\t\t\t  DWRITE_RENDERING_MODE renderingMode,\r\n\t\t\t  DWRITE_MEASURING_MODE measuringMode,\r\n\t\t\t  DWRITE_GRID_FIT_MODE gridFitMode,\r\n\t\t\t  DWRITE_TEXT_ANTIALIAS_MODE antialiasMode,\r\n\t\t\t  FLOAT baselineOriginX,\r\n\t\t\t  FLOAT baselineOriginY,\r\n\t\t\t  IDWriteGlyphRunAnalysis** glyphRunAnalysis\r\n\t\t\t  ), (This, glyphRun, transform, renderingMode, measuringMode, gridFitMode, antialiasMode, baselineOriginX, baselineOriginY, glyphRunAnalysis))\r\n\r\nHOOK_MANUALLY(HRESULT, CreateGlyphRunAnalysis3, (\r\n\t\t\t  IDWriteFactory3* This,\r\n\t\t\t  DWRITE_GLYPH_RUN const* glyphRun,\r\n\t\t\t  DWRITE_MATRIX const* transform,\r\n\t\t\t  DWRITE_RENDERING_MODE1 renderingMode,\r\n\t\t\t  DWRITE_MEASURING_MODE measuringMode,\r\n\t\t\t  DWRITE_GRID_FIT_MODE gridFitMode,\r\n\t\t\t  DWRITE_TEXT_ANTIALIAS_MODE antialiasMode,\r\n\t\t\t  FLOAT baselineOriginX,\r\n\t\t\t  FLOAT baselineOriginY,\r\n\t\t\t  IDWriteGlyphRunAnalysis** glyphRunAnalysis\r\n\t\t\t  ), (This, glyphRun, transform, renderingMode, measuringMode, gridFitMode, antialiasMode, baselineOriginX, baselineOriginY, glyphRunAnalysis))\r\n\r\nHOOK_MANUALLY(HRESULT, GetAlphaBlendParams, (\r\n\t\t\t  IDWriteGlyphRunAnalysis* This,\r\n\t\t\t  IDWriteRenderingParams* renderingParams,\r\n\t\t\t  FLOAT* blendGamma,\r\n\t\t\t  FLOAT* blendEnhancedContrast,\r\n\t\t\t  FLOAT* blendClearTypeLevel\r\n\t\t\t  ), (This, renderingParams, blendGamma, blendEnhancedContrast, blendClearTypeLevel))\r\n\t\t\t  \r\nHOOK_MANUALLY(HRESULT, CreateDeviceContext, (\r\n\t\t\t  ID2D1Device* This,\r\n\t\t\t  D2D1_DEVICE_CONTEXT_OPTIONS options,\r\n\t\t\t  ID2D1DeviceContext** deviceContext\r\n\t\t\t  ), (This, options, deviceContext))\r\n\r\nHOOK_MANUALLY(HRESULT, CreateDeviceContext2, (\r\n\t\t\t  ID2D1Device1* This,\r\n\t\t\t  D2D1_DEVICE_CONTEXT_OPTIONS options,\r\n\t\t\t  ID2D1DeviceContext1** deviceContext\r\n\t\t\t  ), (This, options, deviceContext))\r\n\r\nHOOK_MANUALLY(HRESULT, CreateDeviceContext3, (\r\n\t\t\t  ID2D1Device2* This,\r\n\t\t\t  D2D1_DEVICE_CONTEXT_OPTIONS options,\r\n\t\t\t  ID2D1DeviceContext2** deviceContext\r\n\t\t\t  ), (This, options, deviceContext))\r\n\r\nHOOK_MANUALLY(HRESULT, CreateDeviceContext4, (\r\n\t\t\t  ID2D1Device3* This,\r\n\t\t\t  D2D1_DEVICE_CONTEXT_OPTIONS options,\r\n\t\t\t  ID2D1DeviceContext3** deviceContext\r\n\t\t\t  ), (This, options, deviceContext))\r\n\r\nHOOK_MANUALLY(HRESULT, CreateDeviceContext5, (\r\n\t\t\t  ID2D1Device4* This,\r\n\t\t\t  D2D1_DEVICE_CONTEXT_OPTIONS options,\r\n\t\t\t  ID2D1DeviceContext4** deviceContext\r\n\t\t\t  ), (This, options, deviceContext))\r\n\r\nHOOK_MANUALLY(HRESULT, CreateDeviceContext6, (\r\n\t\t\t  ID2D1Device5* This,\r\n\t\t\t  D2D1_DEVICE_CONTEXT_OPTIONS options,\r\n\t\t\t  ID2D1DeviceContext5** deviceContext\r\n\t\t\t  ), (This, options, deviceContext))\r\n\r\nHOOK_MANUALLY(HRESULT, CreateDeviceContext7, (\r\n\t\t\t  ID2D1Device6* This,\r\n\t\t\t  D2D1_DEVICE_CONTEXT_OPTIONS options,\r\n\t\t\t  ID2D1DeviceContext6** deviceContext\r\n\t\t\t  ), (This, options, deviceContext))\r\n\r\nHOOK_MANUALLY(HRESULT, CreateTextFormat, (\r\n\t\t\t   IDWriteFactory* self,\r\n\t\t\t   __in_z WCHAR const* fontFamilyName,\r\n\t\t\t   __maybenull IDWriteFontCollection* fontCollection,\r\n\t\t\t   DWRITE_FONT_WEIGHT fontWeight,\r\n\t\t\t   DWRITE_FONT_STYLE fontStyle,\r\n\t\t\t   DWRITE_FONT_STRETCH fontStretch,\r\n\t\t\t   FLOAT fontSize,\r\n\t\t\t   __in_z WCHAR const* localeName,\r\n\t\t\t   __out IDWriteTextFormat** textFormat), \r\n\t\t\t\t (self, fontFamilyName, fontCollection, fontWeight, fontStyle, fontStretch, fontSize, localeName, textFormat))\r\n\r\nHOOK_MANUALLY(HRESULT, CreateFontFace, (\r\n\t\t\t  IDWriteFont* self,\r\n\t\t\t  __out IDWriteFontFace** fontFace\r\n\t\t\t  ), (self, fontFace))\r\n\r\nHOOK_MANUALLY(HRESULT, DWriteFontFaceReference_CreateFontFace, (\r\n\t\t\t  IDWriteFontFaceReference* self,\r\n\t\t\t  __out IDWriteFontFace3** fontFace\r\n\t\t\t  ), (self, fontFace))\r\n\r\nHOOK_MANUALLY(HRESULT, DWriteFontFaceReference_CreateFontFaceWithSimulations, (\r\n\t\t\t  IDWriteFontFaceReference* self,\r\n\t\t\t  DWRITE_FONT_SIMULATIONS fontFaceSimulationFlags,\r\n\t\t\t  __out IDWriteFontFace3** fontFace\r\n\t\t\t  ), (self, fontFaceSimulationFlags, fontFace))\r\n\r\nHOOK_MANUALLY(HRESULT, CreateBitmapRenderTarget, (\r\n\t\t\t  IDWriteGdiInterop* This,\r\n\t\t\t  HDC hdc,\r\n\t\t\t  UINT32 width,\r\n\t\t\t  UINT32 height,\r\n\t\t\t  IDWriteBitmapRenderTarget** renderTarget\r\n\t\t\t  ), (This, hdc, width, height, renderTarget))\r\n\r\nHOOK_MANUALLY(HRESULT, CreateCompatibleRenderTarget, (\r\n\t\t\t  ID2D1RenderTarget* This,\r\n\t\t\t  CONST D2D1_SIZE_F* desiredSize,\r\n\t\t\t  CONST D2D1_SIZE_U* desiredPixelSize,\r\n\t\t\t  CONST D2D1_PIXEL_FORMAT* desiredFormat,\r\n\t\t\t  D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS options,\r\n\t\t\t  ID2D1BitmapRenderTarget** bitmapRenderTarget\r\n\t\t\t  ), (This, desiredSize, desiredPixelSize, desiredFormat, options, bitmapRenderTarget))\r\n\r\nHOOK_MANUALLY(void, D2D1RenderTarget_SetTextAntialiasMode, (\r\n\t\t\t  ID2D1RenderTarget* This,\r\n\t\t\t  D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode), (This, textAntialiasMode));\r\n\r\nHOOK_MANUALLY(void, D2D1DeviceContext_SetTextAntialiasMode, (\r\n\t\t\t  ID2D1DeviceContext* This,\r\n\t\t\t  D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode), (This, textAntialiasMode));\r\n\r\nHOOK_MANUALLY(void, D2D1RenderTarget_SetTextRenderingParams, (\r\n\t\t\t\t  ID2D1RenderTarget* This,\r\n\t\t\t\t  _In_opt_ IDWriteRenderingParams* textRenderingParams), (This, textRenderingParams));\r\n\r\nHOOK_MANUALLY(void, D2D1DeviceContext_SetTextRenderingParams, (\r\n\t\t\t\t  ID2D1DeviceContext* This,\r\n\t\t\t\t  _In_opt_ IDWriteRenderingParams* textRenderingParams), (This, textRenderingParams));\r\n\r\n\t\t\t  /*\r\nHOOK_MANUALLY(GpStatus, GdipDrawString, (\r\n\t\t\t  GpGraphics               *graphics,\r\n\t\t\t  GDIPCONST WCHAR          *string,\r\n\t\t\t  INT                       length,\r\n\t\t\t  GDIPCONST GpFont         *font,\r\n\t\t\t  GDIPCONST RectF          *layoutRect,\r\n\t\t\t  GDIPCONST GpStringFormat *stringFormat,\r\n\t\t\t  GDIPCONST GpBrush        *brush\r\n\t\t\t  ))*/\r\n\r\nHOOK_MANUALLY(HRESULT, CreateWicBitmapRenderTarget, (\r\n\tID2D1Factory* This,\r\n\tIWICBitmap* target,\r\n\tconst D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,\r\n\tID2D1RenderTarget** renderTarget), (This, target, renderTargetProperties, renderTarget));\r\n\r\nHOOK_MANUALLY(HRESULT, CreateHwndRenderTarget, (\r\n\tID2D1Factory* This,\r\n\tconst D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,\r\n\tconst D2D1_HWND_RENDER_TARGET_PROPERTIES* hwndRenderTargetProperties,\r\n\tID2D1HwndRenderTarget** hwndRenderTarget), (This, renderTargetProperties, hwndRenderTargetProperties, hwndRenderTarget));\r\n\r\nHOOK_MANUALLY(HRESULT, CreateDxgiSurfaceRenderTarget, (\r\n\tID2D1Factory* This,\r\n\tIDXGISurface* dxgiSurface,\r\n\tconst D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,\r\n\tID2D1RenderTarget** renderTarget), (This, dxgiSurface, renderTargetProperties, renderTarget));\r\n\r\nHOOK_MANUALLY(HRESULT, CreateDCRenderTarget, (\r\n\tID2D1Factory* This,\r\n\tconst D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,\r\n\tID2D1DCRenderTarget** dcRenderTarget), (This, renderTargetProperties, dcRenderTarget));\r\n\r\nHOOK_MANUALLY(HRESULT, CreateDevice1, (\r\n\tID2D1Factory1* This,\r\n\tIDXGIDevice* dxgiDevice,\r\n\tID2D1Device** d2dDevice), (This, dxgiDevice, d2dDevice));\r\n\r\nHOOK_MANUALLY(HRESULT, CreateDevice2, (\r\n\tID2D1Factory2* This,\r\n\tIDXGIDevice* dxgiDevice,\r\n\tID2D1Device1** d2dDevice1\r\n\t), (This, dxgiDevice, d2dDevice1));\r\n\r\nHOOK_MANUALLY(HRESULT, CreateDevice3, (\r\n\tID2D1Factory3* This,\r\n\tIDXGIDevice* dxgiDevice,\r\n\tID2D1Device2** d2dDevice2\r\n\t), (This, dxgiDevice, d2dDevice2));\r\n\r\nHOOK_MANUALLY(HRESULT, CreateDevice4, (\r\n\tID2D1Factory4* This,\r\n\tIDXGIDevice* dxgiDevice,\r\n\tID2D1Device3** d2dDevice3\r\n\t), (This, dxgiDevice, d2dDevice3));\r\n\r\nHOOK_MANUALLY(HRESULT, CreateDevice5, (\r\n\tID2D1Factory5* This,\r\n\tIDXGIDevice* dxgiDevice,\r\n\tID2D1Device4** d2dDevice4\r\n\t), (This, dxgiDevice, d2dDevice4));\r\n\r\nHOOK_MANUALLY(HRESULT, CreateDevice6, (\r\n\tID2D1Factory6* This,\r\n\tIDXGIDevice* dxgiDevice,\r\n\tID2D1Device5** d2dDevice5\r\n\t), (This, dxgiDevice, d2dDevice5));\r\n\r\nHOOK_MANUALLY(HRESULT, CreateDevice7, (\r\n\tID2D1Factory7* This,\r\n\tIDXGIDevice* dxgiDevice,\r\n\tID2D1Device6** d2dDevice6\r\n\t), (This, dxgiDevice, d2dDevice6));\r\n\r\nHOOK_MANUALLY(BOOL, MySetProcessMitigationPolicy, (\r\n\t_In_ PROCESS_MITIGATION_POLICY MitigationPolicy,\r\n\t_In_ PVOID                     lpBuffer,\r\n\t_In_ SIZE_T                    dwLength\r\n\t), (MitigationPolicy, lpBuffer, dwLength));\r\n\r\nHOOK_MANUALLY(void, D2D1RenderTarget_DrawGlyphRun1, (\r\n\tID2D1DeviceContext *This,\r\n\tD2D1_POINT_2F baselineOrigin,\r\n\tCONST DWRITE_GLYPH_RUN *glyphRun,\r\n\tCONST DWRITE_GLYPH_RUN_DESCRIPTION *glyphRunDescription,\r\n\tID2D1Brush *foregroundBrush,\r\n\tDWRITE_MEASURING_MODE measuringMode), (This, baselineOrigin, glyphRun, glyphRunDescription, foregroundBrush, measuringMode));\r\n\r\nHOOK_MANUALLY(void, D2D1RenderTarget1_DrawGlyphRun1, (\r\n\tID2D1DeviceContext *This,\r\n\tD2D1_POINT_2F baselineOrigin,\r\n\tCONST DWRITE_GLYPH_RUN *glyphRun,\r\n\tCONST DWRITE_GLYPH_RUN_DESCRIPTION *glyphRunDescription,\r\n\tID2D1Brush *foregroundBrush,\r\n\tDWRITE_MEASURING_MODE measuringMode), (This, baselineOrigin, glyphRun, glyphRunDescription, foregroundBrush, measuringMode));\r\n\r\nHOOK_MANUALLY(void, D2D1DeviceContext_DrawGlyphRun1, (\r\n\tID2D1DeviceContext *This,\r\n\tD2D1_POINT_2F baselineOrigin,\r\n\tCONST DWRITE_GLYPH_RUN *glyphRun,\r\n\tCONST DWRITE_GLYPH_RUN_DESCRIPTION *glyphRunDescription,\r\n\tID2D1Brush *foregroundBrush,\r\n\tDWRITE_MEASURING_MODE measuringMode), (This, baselineOrigin, glyphRun, glyphRunDescription, foregroundBrush, measuringMode));\r\n\r\nHOOK_MANUALLY(void, D2D1RenderTarget_DrawGlyphRun, (\r\n\tID2D1RenderTarget* This,\r\n\tD2D1_POINT_2F baselineOrigin,\r\n\tCONST DWRITE_GLYPH_RUN *glyphRun,\r\n\tID2D1Brush *foregroundBrush,\r\n\tDWRITE_MEASURING_MODE measuringMode\r\n\t), (This, baselineOrigin, glyphRun, foregroundBrush, measuringMode));\r\n\r\nHOOK_MANUALLY(void, D2D1RenderTarget1_DrawGlyphRun, (\r\n\tID2D1RenderTarget* This,\r\n\tD2D1_POINT_2F baselineOrigin,\r\n\tCONST DWRITE_GLYPH_RUN *glyphRun,\r\n\tID2D1Brush *foregroundBrush,\r\n\tDWRITE_MEASURING_MODE measuringMode\r\n\t), (This, baselineOrigin, glyphRun, foregroundBrush, measuringMode));\r\n\r\nHOOK_MANUALLY(void, D2D1DeviceContext_DrawGlyphRun, (\r\n\tID2D1DeviceContext* This,\r\n\tD2D1_POINT_2F baselineOrigin,\r\n\tCONST DWRITE_GLYPH_RUN *glyphRun,\r\n\tID2D1Brush *foregroundBrush,\r\n\tDWRITE_MEASURING_MODE measuringMode\r\n\t), (This, baselineOrigin, glyphRun, foregroundBrush, measuringMode));\r\n\r\nHOOK_MANUALLY(void, D2D1RenderTarget_DrawText, (\r\n\tID2D1RenderTarget* This,\r\n\tCONST WCHAR *string,\r\n\tUINT32 stringLength,\r\n\tIDWriteTextFormat *textFormat,\r\n\tCONST D2D1_RECT_F *layoutRect,\r\n\tID2D1Brush *defaultForegroundBrush,\r\n\tD2D1_DRAW_TEXT_OPTIONS options,\r\n\tDWRITE_MEASURING_MODE measuringMode), \r\n\t(This, string, stringLength, textFormat, layoutRect, defaultForegroundBrush, options, measuringMode));\r\n\r\nHOOK_MANUALLY(void, D2D1DeviceContext_DrawText, (\r\n\tID2D1DeviceContext* This,\r\n\tCONST WCHAR *string,\r\n\tUINT32 stringLength,\r\n\tIDWriteTextFormat *textFormat,\r\n\tCONST D2D1_RECT_F *layoutRect,\r\n\tID2D1Brush *defaultForegroundBrush,\r\n\tD2D1_DRAW_TEXT_OPTIONS options,\r\n\tDWRITE_MEASURING_MODE measuringMode),\r\n\t(This, string, stringLength, textFormat, layoutRect, defaultForegroundBrush, options, measuringMode));\r\n\r\nHOOK_MANUALLY(void, D2D1RenderTarget_DrawTextLayout, (\r\n\tID2D1RenderTarget* This,\r\n\tD2D1_POINT_2F origin,\r\n\tIDWriteTextLayout *textLayout,\r\n\tID2D1Brush *defaultForegroundBrush,\r\n\tD2D1_DRAW_TEXT_OPTIONS options\r\n\t),\r\n\t(This, origin, textLayout, defaultForegroundBrush, options));\r\n\r\n\r\n//EOF\r\n"
        },
        {
          "name": "ivs_otft.h",
          "type": "blob",
          "size": 14.5341796875,
          "content": "OTFT_DEF_BEGIN(0) /* E0100 */\n\tOTFT_DEF(0x5026, 2) /* jp90 */\n\tOTFT_DEF(0x50C5, 2) /* jp90 */\n\tOTFT_DEF(0x5132, 2) /* jp90 */\n\tOTFT_DEF(0x514E, 2) /* jp90 */\n\tOTFT_DEF(0x5154, 1) /* jp78 */\n\tOTFT_DEF(0x5195, 1) /* jp78 */\n\tOTFT_DEF(0x51A4, 2) /* jp90 */\n\tOTFT_DEF(0x53A9, 2) /* jp90 */\n\tOTFT_DEF(0x53C9, 2) /* jp90 */\n\tOTFT_DEF(0x53DB, 2) /* jp90 */\n\tOTFT_DEF(0x53DF, 2) /* jp90 */\n\tOTFT_DEF(0x54AC, 2) /* jp90 */\n\tOTFT_DEF(0x54E8, 2) /* jp90 */\n\tOTFT_DEF(0x55B0, 2) /* jp90 */\n\tOTFT_DEF(0x5632, 2) /* jp90 */\n\tOTFT_DEF(0x5642, 2) /* jp90 */\n\tOTFT_DEF(0x564C, 2) /* jp90 */\n\tOTFT_DEF(0x56C0, 2) /* jp90 */\n\tOTFT_DEF(0x5835, 2) /* jp90 */\n\tOTFT_DEF(0x5906, 2) /* jp90 */\n\tOTFT_DEF(0x5A29, 2) /* jp90 */\n\tOTFT_DEF(0x5C51, 2) /* jp90 */\n\tOTFT_DEF(0x5C60, 2) /* jp90 */\n\tOTFT_DEF(0x5DF7, 2) /* jp90 */\n\tOTFT_DEF(0x5DFD, 1) /* jp78 */\n\tOTFT_DEF(0x5E96, 2) /* jp90 */\n\tOTFT_DEF(0x5EDF, 2) /* jp90 */\n\tOTFT_DEF(0x5EFB, 2) /* jp90 */\n\tOTFT_DEF(0x5F98, 2) /* jp90 */\n\tOTFT_DEF(0x5FBD, 2) /* jp90 */\n\tOTFT_DEF(0x6062, 2) /* jp90 */\n\tOTFT_DEF(0x609E, 2) /* jp90 */\n\tOTFT_DEF(0x6108, 2) /* jp90 */\n\tOTFT_DEF(0x6241, 2) /* jp90 */\n\tOTFT_DEF(0x633A, 2) /* jp90 */\n\tOTFT_DEF(0x633D, 2) /* jp90 */\n\tOTFT_DEF(0x6357, 2) /* jp90 */\n\tOTFT_DEF(0x6372, 2) /* jp90 */\n\tOTFT_DEF(0x63C3, 2) /* jp90 */\n\tOTFT_DEF(0x646F, 2) /* jp90 */\n\tOTFT_DEF(0x647A, 2) /* jp90 */\n\tOTFT_DEF(0x64B0, 2) /* jp90 */\n\tOTFT_DEF(0x64E2, 2) /* jp90 */\n\tOTFT_DEF(0x65A7, 2) /* jp90 */\n\tOTFT_DEF(0x6666, 2) /* jp90 */\n\tOTFT_DEF(0x66B5, 2) /* jp90 */\n\tOTFT_DEF(0x6753, 2) /* jp90 */\n\tOTFT_DEF(0x6756, 2) /* jp90 */\n\tOTFT_DEF(0x6897, 2) /* jp90 */\n\tOTFT_DEF(0x6962, 2) /* jp90 */\n\tOTFT_DEF(0x696F, 2) /* jp90 */\n\tOTFT_DEF(0x698A, 2) /* jp90 */\n\tOTFT_DEF(0x6994, 2) /* jp90 */\n\tOTFT_DEF(0x69CC, 2) /* jp90 */\n\tOTFT_DEF(0x6A0B, 2) /* jp90 */\n\tOTFT_DEF(0x6A3D, 2) /* jp90 */\n\tOTFT_DEF(0x6A9C, 1) /* jp78 */\n\tOTFT_DEF(0x6ADB, 1) /* jp78 */\n\tOTFT_DEF(0x6B4E, 2) /* jp90 */\n\tOTFT_DEF(0x6C72, 2) /* jp90 */\n\tOTFT_DEF(0x6DEB, 2) /* jp90 */\n\tOTFT_DEF(0x6E1A, 1) /* jp78 */\n\tOTFT_DEF(0x6EA2, 2) /* jp90 */\n\tOTFT_DEF(0x6EBA, 2) /* jp90 */\n\tOTFT_DEF(0x6F23, 1) /* jp78 */\n\tOTFT_DEF(0x6F51, 1) /* jp78 */\n\tOTFT_DEF(0x7015, 2) /* jp90 */\n\tOTFT_DEF(0x701E, 2) /* jp90 */\n\tOTFT_DEF(0x7026, 2) /* jp90 */\n\tOTFT_DEF(0x7058, 2) /* jp90 */\n\tOTFT_DEF(0x7078, 2) /* jp90 */\n\tOTFT_DEF(0x707C, 2) /* jp90 */\n\tOTFT_DEF(0x7149, 1) /* jp78 */\n\tOTFT_DEF(0x714E, 2) /* jp90 */\n\tOTFT_DEF(0x7152, 2) /* jp90 */\n\tOTFT_DEF(0x717D, 2) /* jp90 */\n\tOTFT_DEF(0x7228, 1) /* jp78 */\n\tOTFT_DEF(0x723A, 2) /* jp90 */\n\tOTFT_DEF(0x724C, 2) /* jp90 */\n\tOTFT_DEF(0x7259, 2) /* jp90 */\n\tOTFT_DEF(0x72E1, 2) /* jp90 */\n\tOTFT_DEF(0x7337, 2) /* jp90 */\n\tOTFT_DEF(0x7422, 1) /* jp78 */\n\tOTFT_DEF(0x7511, 2) /* jp90 */\n\tOTFT_DEF(0x7515, 2) /* jp90 */\n\tOTFT_DEF(0x7526, 2) /* jp90 */\n\tOTFT_DEF(0x75BC, 2) /* jp90 */\n\tOTFT_DEF(0x77A5, 2) /* jp90 */\n\tOTFT_DEF(0x783A, 1) /* jp78 */\n\tOTFT_DEF(0x792A, 1) /* jp78 */\n\tOTFT_DEF(0x7941, 2) /* jp90 */\n\tOTFT_DEF(0x7947, 2) /* jp90 */\n\tOTFT_DEF(0x79B0, 2) /* jp90 */\n\tOTFT_DEF(0x79B1, 1) /* jp78 */\n\tOTFT_DEF(0x79E4, 2) /* jp90 */\n\tOTFT_DEF(0x7A17, 2) /* jp90 */\n\tOTFT_DEF(0x7A7F, 2) /* jp90 */\n\tOTFT_DEF(0x7AC8, 2) /* jp90 */\n\tOTFT_DEF(0x7B08, 2) /* jp90 */\n\tOTFT_DEF(0x7B75, 2) /* jp90 */\n\tOTFT_DEF(0x7BAD, 2) /* jp90 */\n\tOTFT_DEF(0x7BB8, 2) /* jp90 */\n\tOTFT_DEF(0x7BC7, 2) /* jp90 */\n\tOTFT_DEF(0x7BDD, 2) /* jp90 */\n\tOTFT_DEF(0x7C3E, 2) /* jp90 */\n\tOTFT_DEF(0x7C7E, 2) /* jp90 */\n\tOTFT_DEF(0x7C82, 2) /* jp90 */\n\tOTFT_DEF(0x7FEB, 2) /* jp90 */\n\tOTFT_DEF(0x7FF0, 2) /* jp90 */\n\tOTFT_DEF(0x8171, 2) /* jp90 */\n\tOTFT_DEF(0x817F, 2) /* jp90 */\n\tOTFT_DEF(0x8258, 2) /* jp90 */\n\tOTFT_DEF(0x8292, 2) /* jp90 */\n\tOTFT_DEF(0x82A6, 2) /* jp90 */\n\tOTFT_DEF(0x8328, 2) /* jp90 */\n\tOTFT_DEF(0x845B, 2) /* jp90 */\n\tOTFT_DEF(0x84EC, 2) /* jp90 */\n\tOTFT_DEF(0x84EE, 1) /* jp78 */\n\tOTFT_DEF(0x8511, 2) /* jp90 */\n\tOTFT_DEF(0x853D, 2) /* jp90 */\n\tOTFT_DEF(0x85A9, 2) /* jp90 */\n\tOTFT_DEF(0x85AF, 2) /* jp90 */\n\tOTFT_DEF(0x85F7, 2) /* jp90 */\n\tOTFT_DEF(0x8654, 2) /* jp90 */\n\tOTFT_DEF(0x86F8, 2) /* jp90 */\n\tOTFT_DEF(0x8703, 2) /* jp90 */\n\tOTFT_DEF(0x8755, 2) /* jp90 */\n\tOTFT_DEF(0x8805, 2) /* jp90 */\n\tOTFT_DEF(0x8956, 2) /* jp90 */\n\tOTFT_DEF(0x8A0A, 2) /* jp90 */\n\tOTFT_DEF(0x8A1D, 2) /* jp90 */\n\tOTFT_DEF(0x8A3B, 2) /* jp90 */\n\tOTFT_DEF(0x8A6E, 2) /* jp90 */\n\tOTFT_DEF(0x8AB9, 2) /* jp90 */\n\tOTFT_DEF(0x8AFA, 2) /* jp90 */\n\tOTFT_DEF(0x8B0E, 2) /* jp90 */\n\tOTFT_DEF(0x8B2C, 2) /* jp90 */\n\tOTFT_DEF(0x8B7F, 2) /* jp90 */\n\tOTFT_DEF(0x8C79, 2) /* jp90 */\n\tOTFT_DEF(0x8CED, 2) /* jp90 */\n\tOTFT_DEF(0x8FBB, 2) /* jp90 */\n\tOTFT_DEF(0x8FBF, 2) /* jp90 */\n\tOTFT_DEF(0x8FC2, 2) /* jp90 */\n\tOTFT_DEF(0x8FC4, 2) /* jp90 */\n\tOTFT_DEF(0x8FE6, 2) /* jp90 */\n\tOTFT_DEF(0x9017, 2) /* jp90 */\n\tOTFT_DEF(0x9019, 2) /* jp90 */\n\tOTFT_DEF(0x9022, 2) /* jp90 */\n\tOTFT_DEF(0x903C, 2) /* jp90 */\n\tOTFT_DEF(0x9041, 2) /* jp90 */\n\tOTFT_DEF(0x905C, 2) /* jp90 */\n\tOTFT_DEF(0x9061, 2) /* jp90 */\n\tOTFT_DEF(0x9087, 1) /* jp78 */\n\tOTFT_DEF(0x912D, 2) /* jp90 */\n\tOTFT_DEF(0x914B, 2) /* jp90 */\n\tOTFT_DEF(0x91B1, 1) /* jp78 */\n\tOTFT_DEF(0x91DC, 2) /* jp90 */\n\tOTFT_DEF(0x9306, 2) /* jp90 */\n\tOTFT_DEF(0x9375, 2) /* jp90 */\n\tOTFT_DEF(0x939A, 2) /* jp90 */\n\tOTFT_DEF(0x9453, 2) /* jp90 */\n\tOTFT_DEF(0x9699, 2) /* jp90 */\n\tOTFT_DEF(0x9771, 2) /* jp90 */\n\tOTFT_DEF(0x9784, 2) /* jp90 */\n\tOTFT_DEF(0x9798, 2) /* jp90 */\n\tOTFT_DEF(0x97AD, 2) /* jp90 */\n\tOTFT_DEF(0x983B, 1) /* jp78 */\n\tOTFT_DEF(0x98F4, 2) /* jp90 */\n\tOTFT_DEF(0x9905, 2) /* jp90 */\n\tOTFT_DEF(0x990C, 2) /* jp90 */\n\tOTFT_DEF(0x9910, 2) /* jp90 */\n\tOTFT_DEF(0x9957, 2) /* jp90 */\n\tOTFT_DEF(0x99C1, 2) /* jp90 */\n\tOTFT_DEF(0x9A19, 2) /* jp90 */\n\tOTFT_DEF(0x9A4A, 2) /* jp90 */\n\tOTFT_DEF(0x9BAB, 2) /* jp90 */\n\tOTFT_DEF(0x9BD6, 2) /* jp90 */\n\tOTFT_DEF(0x9C2F, 2) /* jp90 */\n\tOTFT_DEF(0x9C52, 2) /* jp90 */\n\tOTFT_DEF(0x9D09, 2) /* jp90 */\n\tOTFT_DEF(0x9D60, 2) /* jp90 */\nOTFT_DEF_END(181)\nOTFT_DEF_BEGIN(181) /* E0101 */\n\tOTFT_DEF(0x5026, 3) /* jp04 */\n\tOTFT_DEF(0x50C5, 3) /* jp04 */\n\tOTFT_DEF(0x5132, 3) /* jp04 */\n\tOTFT_DEF(0x514E, 3) /* jp04 */\n\tOTFT_DEF(0x5189, 1) /* jp78 */\n\tOTFT_DEF(0x51A4, 1) /* jp78 */\n\tOTFT_DEF(0x51CB, 1) /* jp78 */\n\tOTFT_DEF(0x5275, 1) /* jp78 */\n\tOTFT_DEF(0x537F, 2) /* jp90 */\n\tOTFT_DEF(0x53A9, 1) /* jp78 */\n\tOTFT_DEF(0x53C9, 3) /* jp04 */\n\tOTFT_DEF(0x53DB, 3) /* jp04 */\n\tOTFT_DEF(0x53DF, 3) /* jp04 */\n\tOTFT_DEF(0x54AC, 3) /* jp04 */\n\tOTFT_DEF(0x54E8, 3) /* jp04 */\n\tOTFT_DEF(0x5533, 1) /* jp78 */\n\tOTFT_DEF(0x5539, 1) /* jp78 */\n\tOTFT_DEF(0x5544, 1) /* jp78 */\n\tOTFT_DEF(0x559D, 1) /* jp78 */\n\tOTFT_DEF(0x55B0, 3) /* jp04 */\n\tOTFT_DEF(0x5632, 3) /* jp04 */\n\tOTFT_DEF(0x5642, 3) /* jp04 */\n\tOTFT_DEF(0x564C, 3) /* jp04 */\n\tOTFT_DEF(0x5678, 1) /* jp78 */\n\tOTFT_DEF(0x56A5, 1) /* jp78 */\n\tOTFT_DEF(0x56C0, 3) /* jp04 */\n\tOTFT_DEF(0x580B, 1) /* jp78 */\n\tOTFT_DEF(0x5835, 3) /* jp04 */\n\tOTFT_DEF(0x5858, 1) /* jp78 */\n\tOTFT_DEF(0x585A, 1) /* jp78 */\n\tOTFT_DEF(0x5906, 3) /* jp04 */\n\tOTFT_DEF(0x5A29, 3) /* jp04 */\n\tOTFT_DEF(0x5A9B, 1) /* jp78 */\n\tOTFT_DEF(0x5ABE, 1) /* jp78 */\n\tOTFT_DEF(0x5ACC, 1) /* jp78 */\n\tOTFT_DEF(0x5C51, 3) /* jp04 */\n\tOTFT_DEF(0x5C60, 1) /* jp78 */\n\tOTFT_DEF(0x5DF7, 3) /* jp04 */\n\tOTFT_DEF(0x5E96, 3) /* jp04 */\n\tOTFT_DEF(0x5EDF, 3) /* jp04 */\n\tOTFT_DEF(0x5EE0, 1) /* jp78 */\n\tOTFT_DEF(0x5EFB, 3) /* jp04 */\n\tOTFT_DEF(0x5F98, 3) /* jp04 */\n\tOTFT_DEF(0x5FBD, 3) /* jp04 */\n\tOTFT_DEF(0x6062, 1) /* jp78 */\n\tOTFT_DEF(0x6097, 1) /* jp78 */\n\tOTFT_DEF(0x609E, 3) /* jp04 */\n\tOTFT_DEF(0x6108, 3) /* jp04 */\n\tOTFT_DEF(0x6167, 1) /* jp78 */\n\tOTFT_DEF(0x61F2, 2) /* jp90 */\n\tOTFT_DEF(0x6241, 3) /* jp04 */\n\tOTFT_DEF(0x6248, 1) /* jp78 */\n\tOTFT_DEF(0x6249, 1) /* jp78 */\n\tOTFT_DEF(0x62D0, 1) /* jp78 */\n\tOTFT_DEF(0x633A, 3) /* jp04 */\n\tOTFT_DEF(0x633D, 3) /* jp04 */\n\tOTFT_DEF(0x6357, 3) /* jp04 */\n\tOTFT_DEF(0x6369, 1) /* jp78 */\n\tOTFT_DEF(0x6372, 3) /* jp04 */\n\tOTFT_DEF(0x63C3, 3) /* jp04 */\n\tOTFT_DEF(0x6406, 1) /* jp78 */\n\tOTFT_DEF(0x646F, 3) /* jp04 */\n\tOTFT_DEF(0x647A, 3) /* jp04 */\n\tOTFT_DEF(0x64B0, 3) /* jp04 */\n\tOTFT_DEF(0x64E2, 3) /* jp04 */\n\tOTFT_DEF(0x6583, 1) /* jp78 */\n\tOTFT_DEF(0x65A7, 3) /* jp04 */\n\tOTFT_DEF(0x6666, 3) /* jp04 */\n\tOTFT_DEF(0x66B5, 3) /* jp04 */\n\tOTFT_DEF(0x66D9, 1) /* jp78 */\n\tOTFT_DEF(0x6753, 1) /* jp78 */\n\tOTFT_DEF(0x6756, 3) /* jp04 */\n\tOTFT_DEF(0x67A6, 1) /* jp78 */\n\tOTFT_DEF(0x67CA, 1) /* jp78 */\n\tOTFT_DEF(0x6813, 1) /* jp78 */\n\tOTFT_DEF(0x6897, 3) /* jp04 */\n\tOTFT_DEF(0x689B, 1) /* jp78 */\n\tOTFT_DEF(0x68A2, 1) /* jp78 */\n\tOTFT_DEF(0x68DA, 1) /* jp78 */\n\tOTFT_DEF(0x6962, 3) /* jp04 */\n\tOTFT_DEF(0x696F, 3) /* jp04 */\n\tOTFT_DEF(0x698A, 3) /* jp04 */\n\tOTFT_DEF(0x6994, 3) /* jp04 */\n\tOTFT_DEF(0x69CC, 3) /* jp04 */\n\tOTFT_DEF(0x6A0B, 3) /* jp04 */\n\tOTFT_DEF(0x6A3D, 3) /* jp04 */\n\tOTFT_DEF(0x6ADB, 2) /* jp90 */\n\tOTFT_DEF(0x6B1D, 1) /* jp78 */\n\tOTFT_DEF(0x6B4E, 3) /* jp04 */\n\tOTFT_DEF(0x6C72, 3) /* jp04 */\n\tOTFT_DEF(0x6CE1, 1) /* jp78 */\n\tOTFT_DEF(0x6DEB, 3) /* jp04 */\n\tOTFT_DEF(0x6E6E, 1) /* jp78 */\n\tOTFT_DEF(0x6E9D, 1) /* jp78 */\n\tOTFT_DEF(0x6EA2, 3) /* jp04 */\n\tOTFT_DEF(0x6EBA, 1) /* jp78 */\n\tOTFT_DEF(0x6F23, 2) /* jp90 */\n\tOTFT_DEF(0x6FEF, 1) /* jp78 */\n\tOTFT_DEF(0x7015, 3) /* jp04 */\n\tOTFT_DEF(0x701E, 3) /* jp04 */\n\tOTFT_DEF(0x7026, 3) /* jp04 */\n\tOTFT_DEF(0x7058, 3) /* jp04 */\n\tOTFT_DEF(0x7078, 3) /* jp04 */\n\tOTFT_DEF(0x707C, 3) /* jp04 */\n\tOTFT_DEF(0x7149, 2) /* jp90 */\n\tOTFT_DEF(0x714E, 3) /* jp04 */\n\tOTFT_DEF(0x7152, 3) /* jp04 */\n\tOTFT_DEF(0x717D, 1) /* jp78 */\n\tOTFT_DEF(0x7194, 1) /* jp78 */\n\tOTFT_DEF(0x723A, 3) /* jp04 */\n\tOTFT_DEF(0x724C, 3) /* jp04 */\n\tOTFT_DEF(0x7259, 3) /* jp04 */\n\tOTFT_DEF(0x72E1, 3) /* jp04 */\n\tOTFT_DEF(0x7337, 1) /* jp78 */\n\tOTFT_DEF(0x73CA, 1) /* jp78 */\n\tOTFT_DEF(0x73CE, 1) /* jp78 */\n\tOTFT_DEF(0x7504, 1) /* jp78 */\n\tOTFT_DEF(0x750D, 1) /* jp78 */\n\tOTFT_DEF(0x7511, 1) /* jp78 */\n\tOTFT_DEF(0x7515, 1) /* jp78 */\n\tOTFT_DEF(0x7526, 3) /* jp04 */\n\tOTFT_DEF(0x75BC, 3) /* jp04 */\n\tOTFT_DEF(0x7626, 1) /* jp78 */\n\tOTFT_DEF(0x7652, 1) /* jp78 */\n\tOTFT_DEF(0x7693, 1) /* jp78 */\n\tOTFT_DEF(0x77A5, 3) /* jp04 */\n\tOTFT_DEF(0x787C, 1) /* jp78 */\n\tOTFT_DEF(0x7941, 3) /* jp04 */\n\tOTFT_DEF(0x7947, 3) /* jp04 */\n\tOTFT_DEF(0x79B0, 3) /* jp04 */\n\tOTFT_DEF(0x79E4, 3) /* jp04 */\n\tOTFT_DEF(0x7A17, 3) /* jp04 */\n\tOTFT_DEF(0x7A31, 1) /* jp78 */\n\tOTFT_DEF(0x7A7F, 3) /* jp04 */\n\tOTFT_DEF(0x7AC8, 3) /* jp04 */\n\tOTFT_DEF(0x7B75, 3) /* jp04 */\n\tOTFT_DEF(0x7B99, 1) /* jp78 */\n\tOTFT_DEF(0x7BAD, 3) /* jp04 */\n\tOTFT_DEF(0x7BB8, 3) /* jp04 */\n\tOTFT_DEF(0x7BC7, 3) /* jp04 */\n\tOTFT_DEF(0x7BDD, 3) /* jp04 */\n\tOTFT_DEF(0x7C7E, 1) /* jp78 */\n\tOTFT_DEF(0x7C82, 3) /* jp04 */\n\tOTFT_DEF(0x7C90, 1) /* jp78 */\n\tOTFT_DEF(0x7CAE, 1) /* jp78 */\n\tOTFT_DEF(0x7D9B, 1) /* jp78 */\n\tOTFT_DEF(0x7D9F, 1) /* jp78 */\n\tOTFT_DEF(0x7DAE, 1) /* jp78 */\n\tOTFT_DEF(0x7FD4, 1) /* jp78 */\n\tOTFT_DEF(0x7FE0, 1) /* jp78 */\n\tOTFT_DEF(0x7FEB, 3) /* jp04 */\n\tOTFT_DEF(0x7FF0, 3) /* jp04 */\n\tOTFT_DEF(0x8000, 1) /* jp78 */\n\tOTFT_DEF(0x8171, 3) /* jp04 */\n\tOTFT_DEF(0x817F, 3) /* jp04 */\n\tOTFT_DEF(0x822E, 1) /* jp78 */\n\tOTFT_DEF(0x8258, 3) /* jp04 */\n\tOTFT_DEF(0x828D, 1) /* jp78 */\n\tOTFT_DEF(0x8292, 3) /* jp04 */\n\tOTFT_DEF(0x82A6, 3) /* jp04 */\n\tOTFT_DEF(0x82D2, 1) /* jp78 */\n\tOTFT_DEF(0x8323, 1) /* jp78 */\n\tOTFT_DEF(0x8328, 3) /* jp04 */\n\tOTFT_DEF(0x8375, 1) /* jp78 */\n\tOTFT_DEF(0x83DF, 1) /* jp78 */\n\tOTFT_DEF(0x845B, 3) /* jp04 */\n\tOTFT_DEF(0x84EC, 3) /* jp04 */\n\tOTFT_DEF(0x8511, 3) /* jp04 */\n\tOTFT_DEF(0x8517, 1) /* jp78 */\n\tOTFT_DEF(0x853D, 3) /* jp04 */\n\tOTFT_DEF(0x85A9, 3) /* jp04 */\n\tOTFT_DEF(0x85AF, 3) /* jp04 */\n\tOTFT_DEF(0x85F7, 3) /* jp04 */\n\tOTFT_DEF(0x8612, 2) /* jp90 */\n\tOTFT_DEF(0x8654, 3) /* jp04 */\n\tOTFT_DEF(0x86F8, 3) /* jp04 */\n\tOTFT_DEF(0x8703, 3) /* jp04 */\n\tOTFT_DEF(0x8755, 3) /* jp04 */\n\tOTFT_DEF(0x8782, 1) /* jp78 */\n\tOTFT_DEF(0x87D2, 1) /* jp78 */\n\tOTFT_DEF(0x890A, 1) /* jp78 */\n\tOTFT_DEF(0x8956, 3) /* jp04 */\n\tOTFT_DEF(0x89AF, 1) /* jp78 */\n\tOTFT_DEF(0x8A0A, 3) /* jp04 */\n\tOTFT_DEF(0x8A3B, 3) /* jp04 */\n\tOTFT_DEF(0x8A6E, 3) /* jp04 */\n\tOTFT_DEF(0x8AB9, 3) /* jp04 */\n\tOTFT_DEF(0x8ADE, 1) /* jp78 */\n\tOTFT_DEF(0x8AFA, 3) /* jp04 */\n\tOTFT_DEF(0x8B0E, 3) /* jp04 */\n\tOTFT_DEF(0x8B2C, 3) /* jp04 */\n\tOTFT_DEF(0x8B41, 1) /* jp78 */\n\tOTFT_DEF(0x8B7F, 3) /* jp04 */\n\tOTFT_DEF(0x8C79, 3) /* jp04 */\n\tOTFT_DEF(0x8CED, 3) /* jp04 */\n\tOTFT_DEF(0x8DDA, 1) /* jp78 */\n\tOTFT_DEF(0x8E09, 1) /* jp78 */\n\tOTFT_DEF(0x8F13, 1) /* jp78 */\n\tOTFT_DEF(0x8FBF, 3) /* jp04 */\n\tOTFT_DEF(0x8FC2, 3) /* jp04 */\n\tOTFT_DEF(0x8FC4, 3) /* jp04 */\n\tOTFT_DEF(0x8FE6, 3) /* jp04 */\n\tOTFT_DEF(0x8FE9, 1) /* jp78 */\n\tOTFT_DEF(0x8FEA, 1) /* jp78 */\n\tOTFT_DEF(0x9017, 3) /* jp04 */\n\tOTFT_DEF(0x9019, 3) /* jp04 */\n\tOTFT_DEF(0x901D, 1) /* jp78 */\n\tOTFT_DEF(0x903C, 3) /* jp04 */\n\tOTFT_DEF(0x9041, 1) /* jp78 */\n\tOTFT_DEF(0x9058, 1) /* jp78 */\n\tOTFT_DEF(0x905C, 3) /* jp04 */\n\tOTFT_DEF(0x9061, 3) /* jp04 */\n\tOTFT_DEF(0x906E, 1) /* jp78 */\n\tOTFT_DEF(0x907C, 1) /* jp78 */\n\tOTFT_DEF(0x90A3, 1) /* jp78 */\n\tOTFT_DEF(0x912D, 3) /* jp04 */\n\tOTFT_DEF(0x914B, 3) /* jp04 */\n\tOTFT_DEF(0x91C1, 1) /* jp78 */\n\tOTFT_DEF(0x91C7, 1) /* jp78 */\n\tOTFT_DEF(0x91DC, 3) /* jp04 */\n\tOTFT_DEF(0x9306, 3) /* jp04 */\n\tOTFT_DEF(0x9375, 3) /* jp04 */\n\tOTFT_DEF(0x939A, 3) /* jp04 */\n\tOTFT_DEF(0x9453, 3) /* jp04 */\n\tOTFT_DEF(0x9699, 3) /* jp04 */\n\tOTFT_DEF(0x9724, 1) /* jp78 */\n\tOTFT_DEF(0x9760, 1) /* jp78 */\n\tOTFT_DEF(0x976D, 1) /* jp78 */\n\tOTFT_DEF(0x9771, 1) /* jp78 */\n\tOTFT_DEF(0x9774, 1) /* jp78 */\n\tOTFT_DEF(0x9784, 3) /* jp04 */\n\tOTFT_DEF(0x9798, 3) /* jp04 */\n\tOTFT_DEF(0x97AD, 3) /* jp04 */\n\tOTFT_DEF(0x9813, 1) /* jp78 */\n\tOTFT_DEF(0x9824, 1) /* jp78 */\n\tOTFT_DEF(0x98F4, 3) /* jp04 */\n\tOTFT_DEF(0x9905, 3) /* jp04 */\n\tOTFT_DEF(0x990C, 1) /* jp78 */\n\tOTFT_DEF(0x9910, 3) /* jp04 */\n\tOTFT_DEF(0x9957, 3) /* jp04 */\n\tOTFT_DEF(0x99C1, 3) /* jp04 */\n\tOTFT_DEF(0x9A19, 3) /* jp04 */\n\tOTFT_DEF(0x9A4A, 3) /* jp04 */\n\tOTFT_DEF(0x9B2E, 1) /* jp78 */\n\tOTFT_DEF(0x9B97, 1) /* jp78 */\n\tOTFT_DEF(0x9BAB, 3) /* jp04 */\n\tOTFT_DEF(0x9BD6, 3) /* jp04 */\n\tOTFT_DEF(0x9BF2, 1) /* jp78 */\n\tOTFT_DEF(0x9C2F, 3) /* jp04 */\n\tOTFT_DEF(0x9C48, 1) /* jp78 */\n\tOTFT_DEF(0x9C52, 3) /* jp04 */\n\tOTFT_DEF(0x9D07, 1) /* jp78 */\n\tOTFT_DEF(0x9D09, 3) /* jp04 */\n\tOTFT_DEF(0x9D60, 3) /* jp04 */\n\tOTFT_DEF(0x9EAA, 1) /* jp78 */\n\tOTFT_DEF(0x9EDB, 1) /* jp78 */\n\tOTFT_DEF(0x9F9C, 1) /* jp78 */\n\tOTFT_DEF(0x9F9D, 1) /* jp78 */\nOTFT_DEF_END(258)\nOTFT_DEF_BEGIN(439) /* E0102 */\n\tOTFT_DEF(0x537F, 3) /* jp04 */\n\tOTFT_DEF(0x6062, 3) /* jp04 */\n\tOTFT_DEF(0x717D, 3) /* jp04 */\n\tOTFT_DEF(0x7337, 3) /* jp04 */\n\tOTFT_DEF(0x7515, 3) /* jp04 */\n\tOTFT_DEF(0x7B08, 3) /* jp04 */\n\tOTFT_DEF(0x7C3E, 3) /* jp04 */\n\tOTFT_DEF(0x7C7E, 3) /* jp04 */\n\tOTFT_DEF(0x8612, 3) /* jp04 */\n\tOTFT_DEF(0x8805, 3) /* jp04 */\n\tOTFT_DEF(0x8A1D, 3) /* jp04 */\n\tOTFT_DEF(0x9041, 3) /* jp04 */\n\tOTFT_DEF(0x9771, 3) /* jp04 */\nOTFT_DEF_END(13)\nOTFT_DEF_BEGIN(452) /* E0103 */\n\tOTFT_DEF(0x61F2, 3) /* jp04 */\n\tOTFT_DEF(0x7511, 3) /* jp04 */\n\tOTFT_DEF(0x990C, 3) /* jp04 */\nOTFT_DEF_END(3)\nOTFT_DEF_BEGIN(455) /* E0104 */\nOTFT_DEF_END(0)\nOTFT_DEF_BEGIN(455) /* E0105 */\n\tOTFT_DEF(0x53A9, 3) /* jp04 */\nOTFT_DEF_END(1)\n"
        },
        {
          "name": "json.hpp",
          "type": "blob",
          "size": 785.27734375,
          "content": "/*\n    __ _____ _____ _____\n __|  |   __|     |   | |  JSON for Modern C++\n|  |  |__   |  |  | | | |  version 3.10.5\n|_____|_____|_____|_|___|  https://github.com/nlohmann/json\n\nLicensed under the MIT License <http://opensource.org/licenses/MIT>.\nSPDX-License-Identifier: MIT\nCopyright (c) 2013-2022 Niels Lohmann <http://nlohmann.me>.\n\nPermission is hereby  granted, free of charge, to any  person obtaining a copy\nof this software and associated  documentation files (the \"Software\"), to deal\nin the Software  without restriction, including without  limitation the rights\nto  use, copy,  modify, merge,  publish, distribute,  sublicense, and/or  sell\ncopies  of  the Software,  and  to  permit persons  to  whom  the Software  is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE  IS PROVIDED \"AS  IS\", WITHOUT WARRANTY  OF ANY KIND,  EXPRESS OR\nIMPLIED,  INCLUDING BUT  NOT  LIMITED TO  THE  WARRANTIES OF  MERCHANTABILITY,\nFITNESS FOR  A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT  SHALL THE\nAUTHORS  OR COPYRIGHT  HOLDERS  BE  LIABLE FOR  ANY  CLAIM,  DAMAGES OR  OTHER\nLIABILITY, WHETHER IN AN ACTION OF  CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE  OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n/****************************************************************************\\\n * Note on documentation: The source files contain links to the online      *\n * documentation of the public API at https://json.nlohmann.me. This URL    *\n * contains the most recent documentation and should also be applicable to  *\n * previous versions; documentation for deprecated functions is not         *\n * removed, but marked deprecated. See \"Generate documentation\" section in  *\n * file doc/README.md.                                                      *\n\\****************************************************************************/\n\n#ifndef INCLUDE_NLOHMANN_JSON_HPP_\n#define INCLUDE_NLOHMANN_JSON_HPP_\n\n#define NLOHMANN_JSON_VERSION_MAJOR 3\n#define NLOHMANN_JSON_VERSION_MINOR 10\n#define NLOHMANN_JSON_VERSION_PATCH 5\n\n#include <algorithm> // all_of, find, for_each\n#include <cstddef> // nullptr_t, ptrdiff_t, size_t\n#include <functional> // hash, less\n#include <initializer_list> // initializer_list\n#ifndef JSON_NO_IO\n    #include <iosfwd> // istream, ostream\n#endif  // JSON_NO_IO\n#include <iterator> // random_access_iterator_tag\n#include <memory> // unique_ptr\n#include <numeric> // accumulate\n#include <string> // string, stoi, to_string\n#include <utility> // declval, forward, move, pair, swap\n#include <vector> // vector\n\n// #include <nlohmann/adl_serializer.hpp>\n\n\n#include <type_traits>\n#include <utility>\n\n// #include <nlohmann/detail/conversions/from_json.hpp>\n\n\n#include <algorithm> // transform\n#include <array> // array\n#include <forward_list> // forward_list\n#include <iterator> // inserter, front_inserter, end\n#include <map> // map\n#include <string> // string\n#include <tuple> // tuple, make_tuple\n#include <type_traits> // is_arithmetic, is_same, is_enum, underlying_type, is_convertible\n#include <unordered_map> // unordered_map\n#include <utility> // pair, declval\n#include <valarray> // valarray\n\n// #include <nlohmann/detail/exceptions.hpp>\n\n\n#include <exception> // exception\n#include <stdexcept> // runtime_error\n#include <string> // to_string\n#include <vector> // vector\n\n// #include <nlohmann/detail/value_t.hpp>\n\n\n#include <array> // array\n#include <cstddef> // size_t\n#include <cstdint> // uint8_t\n#include <string> // string\n\nnamespace nlohmann\n{\nnamespace detail\n{\n///////////////////////////\n// JSON type enumeration //\n///////////////////////////\n\n/*!\n@brief the JSON type enumeration\n\nThis enumeration collects the different JSON types. It is internally used to\ndistinguish the stored values, and the functions @ref basic_json::is_null(),\n@ref basic_json::is_object(), @ref basic_json::is_array(),\n@ref basic_json::is_string(), @ref basic_json::is_boolean(),\n@ref basic_json::is_number() (with @ref basic_json::is_number_integer(),\n@ref basic_json::is_number_unsigned(), and @ref basic_json::is_number_float()),\n@ref basic_json::is_discarded(), @ref basic_json::is_primitive(), and\n@ref basic_json::is_structured() rely on it.\n\n@note There are three enumeration entries (number_integer, number_unsigned, and\nnumber_float), because the library distinguishes these three types for numbers:\n@ref basic_json::number_unsigned_t is used for unsigned integers,\n@ref basic_json::number_integer_t is used for signed integers, and\n@ref basic_json::number_float_t is used for floating-point numbers or to\napproximate integers which do not fit in the limits of their respective type.\n\n@sa see @ref basic_json::basic_json(const value_t value_type) -- create a JSON\nvalue with the default value for a given type\n\n@since version 1.0.0\n*/\nenum class value_t : std::uint8_t\n{\n    null,             ///< null value\n    object,           ///< object (unordered set of name/value pairs)\n    array,            ///< array (ordered collection of values)\n    string,           ///< string value\n    boolean,          ///< boolean value\n    number_integer,   ///< number value (signed integer)\n    number_unsigned,  ///< number value (unsigned integer)\n    number_float,     ///< number value (floating-point)\n    binary,           ///< binary array (ordered collection of bytes)\n    discarded         ///< discarded by the parser callback function\n};\n\n/*!\n@brief comparison operator for JSON types\n\nReturns an ordering that is similar to Python:\n- order: null < boolean < number < object < array < string < binary\n- furthermore, each type is not smaller than itself\n- discarded values are not comparable\n- binary is represented as a b\"\" string in python and directly comparable to a\n  string; however, making a binary array directly comparable with a string would\n  be surprising behavior in a JSON file.\n\n@since version 1.0.0\n*/\ninline bool operator<(const value_t lhs, const value_t rhs) noexcept\n{\n    static constexpr std::array<std::uint8_t, 9> order = {{\n            0 /* null */, 3 /* object */, 4 /* array */, 5 /* string */,\n            1 /* boolean */, 2 /* integer */, 2 /* unsigned */, 2 /* float */,\n            6 /* binary */\n        }\n    };\n\n    const auto l_index = static_cast<std::size_t>(lhs);\n    const auto r_index = static_cast<std::size_t>(rhs);\n    return l_index < order.size() && r_index < order.size() && order[l_index] < order[r_index];\n}\n}  // namespace detail\n}  // namespace nlohmann\n\n// #include <nlohmann/detail/string_escape.hpp>\n\n\n#include <string>\n// #include <nlohmann/detail/macro_scope.hpp>\n\n\n#include <utility> // declval, pair\n// #include <nlohmann/thirdparty/hedley/hedley.hpp>\n\n\n/* Hedley - https://nemequ.github.io/hedley\n * Created by Evan Nemerson <evan@nemerson.com>\n *\n * To the extent possible under law, the author(s) have dedicated all\n * copyright and related and neighboring rights to this software to\n * the public domain worldwide. This software is distributed without\n * any warranty.\n *\n * For details, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n * SPDX-License-Identifier: CC0-1.0\n */\n\n#if !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION < 15)\n#if defined(JSON_HEDLEY_VERSION)\n    #undef JSON_HEDLEY_VERSION\n#endif\n#define JSON_HEDLEY_VERSION 15\n\n#if defined(JSON_HEDLEY_STRINGIFY_EX)\n    #undef JSON_HEDLEY_STRINGIFY_EX\n#endif\n#define JSON_HEDLEY_STRINGIFY_EX(x) #x\n\n#if defined(JSON_HEDLEY_STRINGIFY)\n    #undef JSON_HEDLEY_STRINGIFY\n#endif\n#define JSON_HEDLEY_STRINGIFY(x) JSON_HEDLEY_STRINGIFY_EX(x)\n\n#if defined(JSON_HEDLEY_CONCAT_EX)\n    #undef JSON_HEDLEY_CONCAT_EX\n#endif\n#define JSON_HEDLEY_CONCAT_EX(a,b) a##b\n\n#if defined(JSON_HEDLEY_CONCAT)\n    #undef JSON_HEDLEY_CONCAT\n#endif\n#define JSON_HEDLEY_CONCAT(a,b) JSON_HEDLEY_CONCAT_EX(a,b)\n\n#if defined(JSON_HEDLEY_CONCAT3_EX)\n    #undef JSON_HEDLEY_CONCAT3_EX\n#endif\n#define JSON_HEDLEY_CONCAT3_EX(a,b,c) a##b##c\n\n#if defined(JSON_HEDLEY_CONCAT3)\n    #undef JSON_HEDLEY_CONCAT3\n#endif\n#define JSON_HEDLEY_CONCAT3(a,b,c) JSON_HEDLEY_CONCAT3_EX(a,b,c)\n\n#if defined(JSON_HEDLEY_VERSION_ENCODE)\n    #undef JSON_HEDLEY_VERSION_ENCODE\n#endif\n#define JSON_HEDLEY_VERSION_ENCODE(major,minor,revision) (((major) * 1000000) + ((minor) * 1000) + (revision))\n\n#if defined(JSON_HEDLEY_VERSION_DECODE_MAJOR)\n    #undef JSON_HEDLEY_VERSION_DECODE_MAJOR\n#endif\n#define JSON_HEDLEY_VERSION_DECODE_MAJOR(version) ((version) / 1000000)\n\n#if defined(JSON_HEDLEY_VERSION_DECODE_MINOR)\n    #undef JSON_HEDLEY_VERSION_DECODE_MINOR\n#endif\n#define JSON_HEDLEY_VERSION_DECODE_MINOR(version) (((version) % 1000000) / 1000)\n\n#if defined(JSON_HEDLEY_VERSION_DECODE_REVISION)\n    #undef JSON_HEDLEY_VERSION_DECODE_REVISION\n#endif\n#define JSON_HEDLEY_VERSION_DECODE_REVISION(version) ((version) % 1000)\n\n#if defined(JSON_HEDLEY_GNUC_VERSION)\n    #undef JSON_HEDLEY_GNUC_VERSION\n#endif\n#if defined(__GNUC__) && defined(__GNUC_PATCHLEVEL__)\n    #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)\n#elif defined(__GNUC__)\n    #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, 0)\n#endif\n\n#if defined(JSON_HEDLEY_GNUC_VERSION_CHECK)\n    #undef JSON_HEDLEY_GNUC_VERSION_CHECK\n#endif\n#if defined(JSON_HEDLEY_GNUC_VERSION)\n    #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GNUC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))\n#else\n    #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (0)\n#endif\n\n#if defined(JSON_HEDLEY_MSVC_VERSION)\n    #undef JSON_HEDLEY_MSVC_VERSION\n#endif\n#if defined(_MSC_FULL_VER) && (_MSC_FULL_VER >= 140000000) && !defined(__ICL)\n    #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 10000000, (_MSC_FULL_VER % 10000000) / 100000, (_MSC_FULL_VER % 100000) / 100)\n#elif defined(_MSC_FULL_VER) && !defined(__ICL)\n    #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 1000000, (_MSC_FULL_VER % 1000000) / 10000, (_MSC_FULL_VER % 10000) / 10)\n#elif defined(_MSC_VER) && !defined(__ICL)\n    #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_VER / 100, _MSC_VER % 100, 0)\n#endif\n\n#if defined(JSON_HEDLEY_MSVC_VERSION_CHECK)\n    #undef JSON_HEDLEY_MSVC_VERSION_CHECK\n#endif\n#if !defined(JSON_HEDLEY_MSVC_VERSION)\n    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (0)\n#elif defined(_MSC_VER) && (_MSC_VER >= 1400)\n    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER >= ((major * 10000000) + (minor * 100000) + (patch)))\n#elif defined(_MSC_VER) && (_MSC_VER >= 1200)\n    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER >= ((major * 1000000) + (minor * 10000) + (patch)))\n#else\n    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_VER >= ((major * 100) + (minor)))\n#endif\n\n#if defined(JSON_HEDLEY_INTEL_VERSION)\n    #undef JSON_HEDLEY_INTEL_VERSION\n#endif\n#if defined(__INTEL_COMPILER) && defined(__INTEL_COMPILER_UPDATE) && !defined(__ICL)\n    #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, __INTEL_COMPILER_UPDATE)\n#elif defined(__INTEL_COMPILER) && !defined(__ICL)\n    #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, 0)\n#endif\n\n#if defined(JSON_HEDLEY_INTEL_VERSION_CHECK)\n    #undef JSON_HEDLEY_INTEL_VERSION_CHECK\n#endif\n#if defined(JSON_HEDLEY_INTEL_VERSION)\n    #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_INTEL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))\n#else\n    #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (0)\n#endif\n\n#if defined(JSON_HEDLEY_INTEL_CL_VERSION)\n    #undef JSON_HEDLEY_INTEL_CL_VERSION\n#endif\n#if defined(__INTEL_COMPILER) && defined(__INTEL_COMPILER_UPDATE) && defined(__ICL)\n    #define JSON_HEDLEY_INTEL_CL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER, __INTEL_COMPILER_UPDATE, 0)\n#endif\n\n#if defined(JSON_HEDLEY_INTEL_CL_VERSION_CHECK)\n    #undef JSON_HEDLEY_INTEL_CL_VERSION_CHECK\n#endif\n#if defined(JSON_HEDLEY_INTEL_CL_VERSION)\n    #define JSON_HEDLEY_INTEL_CL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_INTEL_CL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))\n#else\n    #define JSON_HEDLEY_INTEL_CL_VERSION_CHECK(major,minor,patch) (0)\n#endif\n\n#if defined(JSON_HEDLEY_PGI_VERSION)\n    #undef JSON_HEDLEY_PGI_VERSION\n#endif\n#if defined(__PGI) && defined(__PGIC__) && defined(__PGIC_MINOR__) && defined(__PGIC_PATCHLEVEL__)\n    #define JSON_HEDLEY_PGI_VERSION JSON_HEDLEY_VERSION_ENCODE(__PGIC__, __PGIC_MINOR__, __PGIC_PATCHLEVEL__)\n#endif\n\n#if defined(JSON_HEDLEY_PGI_VERSION_CHECK)\n    #undef JSON_HEDLEY_PGI_VERSION_CHECK\n#endif\n#if defined(JSON_HEDLEY_PGI_VERSION)\n    #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PGI_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))\n#else\n    #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (0)\n#endif\n\n#if defined(JSON_HEDLEY_SUNPRO_VERSION)\n    #undef JSON_HEDLEY_SUNPRO_VERSION\n#endif\n#if defined(__SUNPRO_C) && (__SUNPRO_C > 0x1000)\n    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_C >> 16) & 0xf) * 10) + ((__SUNPRO_C >> 12) & 0xf), (((__SUNPRO_C >> 8) & 0xf) * 10) + ((__SUNPRO_C >> 4) & 0xf), (__SUNPRO_C & 0xf) * 10)\n#elif defined(__SUNPRO_C)\n    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_C >> 8) & 0xf, (__SUNPRO_C >> 4) & 0xf, (__SUNPRO_C) & 0xf)\n#elif defined(__SUNPRO_CC) && (__SUNPRO_CC > 0x1000)\n    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_CC >> 16) & 0xf) * 10) + ((__SUNPRO_CC >> 12) & 0xf), (((__SUNPRO_CC >> 8) & 0xf) * 10) + ((__SUNPRO_CC >> 4) & 0xf), (__SUNPRO_CC & 0xf) * 10)\n#elif defined(__SUNPRO_CC)\n    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_CC >> 8) & 0xf, (__SUNPRO_CC >> 4) & 0xf, (__SUNPRO_CC) & 0xf)\n#endif\n\n#if defined(JSON_HEDLEY_SUNPRO_VERSION_CHECK)\n    #undef JSON_HEDLEY_SUNPRO_VERSION_CHECK\n#endif\n#if defined(JSON_HEDLEY_SUNPRO_VERSION)\n    #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_SUNPRO_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))\n#else\n    #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (0)\n#endif\n\n#if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)\n    #undef JSON_HEDLEY_EMSCRIPTEN_VERSION\n#endif\n#if defined(__EMSCRIPTEN__)\n    #define JSON_HEDLEY_EMSCRIPTEN_VERSION JSON_HEDLEY_VERSION_ENCODE(__EMSCRIPTEN_major__, __EMSCRIPTEN_minor__, __EMSCRIPTEN_tiny__)\n#endif\n\n#if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK)\n    #undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK\n#endif\n#if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)\n    #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_EMSCRIPTEN_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))\n#else\n    #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (0)\n#endif\n\n#if defined(JSON_HEDLEY_ARM_VERSION)\n    #undef JSON_HEDLEY_ARM_VERSION\n#endif\n#if defined(__CC_ARM) && defined(__ARMCOMPILER_VERSION)\n    #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCOMPILER_VERSION / 1000000, (__ARMCOMPILER_VERSION % 1000000) / 10000, (__ARMCOMPILER_VERSION % 10000) / 100)\n#elif defined(__CC_ARM) && defined(__ARMCC_VERSION)\n    #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCC_VERSION / 1000000, (__ARMCC_VERSION % 1000000) / 10000, (__ARMCC_VERSION % 10000) / 100)\n#endif\n\n#if defined(JSON_HEDLEY_ARM_VERSION_CHECK)\n    #undef JSON_HEDLEY_ARM_VERSION_CHECK\n#endif\n#if defined(JSON_HEDLEY_ARM_VERSION)\n    #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_ARM_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))\n#else\n    #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (0)\n#endif\n\n#if defined(JSON_HEDLEY_IBM_VERSION)\n    #undef JSON_HEDLEY_IBM_VERSION\n#endif\n#if defined(__ibmxl__)\n    #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ibmxl_version__, __ibmxl_release__, __ibmxl_modification__)\n#elif defined(__xlC__) && defined(__xlC_ver__)\n    #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, (__xlC_ver__ >> 8) & 0xff)\n#elif defined(__xlC__)\n    #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, 0)\n#endif\n\n#if defined(JSON_HEDLEY_IBM_VERSION_CHECK)\n    #undef JSON_HEDLEY_IBM_VERSION_CHECK\n#endif\n#if defined(JSON_HEDLEY_IBM_VERSION)\n    #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IBM_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))\n#else\n    #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (0)\n#endif\n\n#if defined(JSON_HEDLEY_TI_VERSION)\n    #undef JSON_HEDLEY_TI_VERSION\n#endif\n#if \\\n    defined(__TI_COMPILER_VERSION__) && \\\n    ( \\\n      defined(__TMS470__) || defined(__TI_ARM__) || \\\n      defined(__MSP430__) || \\\n      defined(__TMS320C2000__) \\\n    )\n#if (__TI_COMPILER_VERSION__ >= 16000000)\n    #define JSON_HEDLEY_TI_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))\n#endif\n#endif\n\n#if defined(JSON_HEDLEY_TI_VERSION_CHECK)\n    #undef JSON_HEDLEY_TI_VERSION_CHECK\n#endif\n#if defined(JSON_HEDLEY_TI_VERSION)\n    #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))\n#else\n    #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (0)\n#endif\n\n#if defined(JSON_HEDLEY_TI_CL2000_VERSION)\n    #undef JSON_HEDLEY_TI_CL2000_VERSION\n#endif\n#if defined(__TI_COMPILER_VERSION__) && defined(__TMS320C2000__)\n    #define JSON_HEDLEY_TI_CL2000_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))\n#endif\n\n#if defined(JSON_HEDLEY_TI_CL2000_VERSION_CHECK)\n    #undef JSON_HEDLEY_TI_CL2000_VERSION_CHECK\n#endif\n#if defined(JSON_HEDLEY_TI_CL2000_VERSION)\n    #define JSON_HEDLEY_TI_CL2000_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL2000_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))\n#else\n    #define JSON_HEDLEY_TI_CL2000_VERSION_CHECK(major,minor,patch) (0)\n#endif\n\n#if defined(JSON_HEDLEY_TI_CL430_VERSION)\n    #undef JSON_HEDLEY_TI_CL430_VERSION\n#endif\n#if defined(__TI_COMPILER_VERSION__) && defined(__MSP430__)\n    #define JSON_HEDLEY_TI_CL430_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))\n#endif\n\n#if defined(JSON_HEDLEY_TI_CL430_VERSION_CHECK)\n    #undef JSON_HEDLEY_TI_CL430_VERSION_CHECK\n#endif\n#if defined(JSON_HEDLEY_TI_CL430_VERSION)\n    #define JSON_HEDLEY_TI_CL430_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL430_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))\n#else\n    #define JSON_HEDLEY_TI_CL430_VERSION_CHECK(major,minor,patch) (0)\n#endif\n\n#if defined(JSON_HEDLEY_TI_ARMCL_VERSION)\n    #undef JSON_HEDLEY_TI_ARMCL_VERSION\n#endif\n#if defined(__TI_COMPILER_VERSION__) && (defined(__TMS470__) || defined(__TI_ARM__))\n    #define JSON_HEDLEY_TI_ARMCL_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))\n#endif\n\n#if defined(JSON_HEDLEY_TI_ARMCL_VERSION_CHECK)\n    #undef JSON_HEDLEY_TI_ARMCL_VERSION_CHECK\n#endif\n#if defined(JSON_HEDLEY_TI_ARMCL_VERSION)\n    #define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_ARMCL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))\n#else\n    #define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(major,minor,patch) (0)\n#endif\n\n#if defined(JSON_HEDLEY_TI_CL6X_VERSION)\n    #undef JSON_HEDLEY_TI_CL6X_VERSION\n#endif\n#if defined(__TI_COMPILER_VERSION__) && defined(__TMS320C6X__)\n    #define JSON_HEDLEY_TI_CL6X_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))\n#endif\n\n#if defined(JSON_HEDLEY_TI_CL6X_VERSION_CHECK)\n    #undef JSON_HEDLEY_TI_CL6X_VERSION_CHECK\n#endif\n#if defined(JSON_HEDLEY_TI_CL6X_VERSION)\n    #define JSON_HEDLEY_TI_CL6X_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL6X_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))\n#else\n    #define JSON_HEDLEY_TI_CL6X_VERSION_CHECK(major,minor,patch) (0)\n#endif\n\n#if defined(JSON_HEDLEY_TI_CL7X_VERSION)\n    #undef JSON_HEDLEY_TI_CL7X_VERSION\n#endif\n#if defined(__TI_COMPILER_VERSION__) && defined(__C7000__)\n    #define JSON_HEDLEY_TI_CL7X_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))\n#endif\n\n#if defined(JSON_HEDLEY_TI_CL7X_VERSION_CHECK)\n    #undef JSON_HEDLEY_TI_CL7X_VERSION_CHECK\n#endif\n#if defined(JSON_HEDLEY_TI_CL7X_VERSION)\n    #define JSON_HEDLEY_TI_CL7X_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL7X_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))\n#else\n    #define JSON_HEDLEY_TI_CL7X_VERSION_CHECK(major,minor,patch) (0)\n#endif\n\n#if defined(JSON_HEDLEY_TI_CLPRU_VERSION)\n    #undef JSON_HEDLEY_TI_CLPRU_VERSION\n#endif\n#if defined(__TI_COMPILER_VERSION__) && defined(__PRU__)\n    #define JSON_HEDLEY_TI_CLPRU_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))\n#endif\n\n#if defined(JSON_HEDLEY_TI_CLPRU_VERSION_CHECK)\n    #undef JSON_HEDLEY_TI_CLPRU_VERSION_CHECK\n#endif\n#if defined(JSON_HEDLEY_TI_CLPRU_VERSION)\n    #define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CLPRU_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))\n#else\n    #define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(major,minor,patch) (0)\n#endif\n\n#if defined(JSON_HEDLEY_CRAY_VERSION)\n    #undef JSON_HEDLEY_CRAY_VERSION\n#endif\n#if defined(_CRAYC)\n    #if defined(_RELEASE_PATCHLEVEL)\n        #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, _RELEASE_PATCHLEVEL)\n    #else\n        #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, 0)\n    #endif\n#endif\n\n#if defined(JSON_HEDLEY_CRAY_VERSION_CHECK)\n    #undef JSON_HEDLEY_CRAY_VERSION_CHECK\n#endif\n#if defined(JSON_HEDLEY_CRAY_VERSION)\n    #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_CRAY_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))\n#else\n    #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (0)\n#endif\n\n#if defined(JSON_HEDLEY_IAR_VERSION)\n    #undef JSON_HEDLEY_IAR_VERSION\n#endif\n#if defined(__IAR_SYSTEMS_ICC__)\n    #if __VER__ > 1000\n        #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE((__VER__ / 1000000), ((__VER__ / 1000) % 1000), (__VER__ % 1000))\n    #else\n        #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE(__VER__ / 100, __VER__ % 100, 0)\n    #endif\n#endif\n\n#if defined(JSON_HEDLEY_IAR_VERSION_CHECK)\n    #undef JSON_HEDLEY_IAR_VERSION_CHECK\n#endif\n#if defined(JSON_HEDLEY_IAR_VERSION)\n    #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IAR_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))\n#else\n    #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (0)\n#endif\n\n#if defined(JSON_HEDLEY_TINYC_VERSION)\n    #undef JSON_HEDLEY_TINYC_VERSION\n#endif\n#if defined(__TINYC__)\n    #define JSON_HEDLEY_TINYC_VERSION JSON_HEDLEY_VERSION_ENCODE(__TINYC__ / 1000, (__TINYC__ / 100) % 10, __TINYC__ % 100)\n#endif\n\n#if defined(JSON_HEDLEY_TINYC_VERSION_CHECK)\n    #undef JSON_HEDLEY_TINYC_VERSION_CHECK\n#endif\n#if defined(JSON_HEDLEY_TINYC_VERSION)\n    #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TINYC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))\n#else\n    #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (0)\n#endif\n\n#if defined(JSON_HEDLEY_DMC_VERSION)\n    #undef JSON_HEDLEY_DMC_VERSION\n#endif\n#if defined(__DMC__)\n    #define JSON_HEDLEY_DMC_VERSION JSON_HEDLEY_VERSION_ENCODE(__DMC__ >> 8, (__DMC__ >> 4) & 0xf, __DMC__ & 0xf)\n#endif\n\n#if defined(JSON_HEDLEY_DMC_VERSION_CHECK)\n    #undef JSON_HEDLEY_DMC_VERSION_CHECK\n#endif\n#if defined(JSON_HEDLEY_DMC_VERSION)\n    #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_DMC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))\n#else\n    #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (0)\n#endif\n\n#if defined(JSON_HEDLEY_COMPCERT_VERSION)\n    #undef JSON_HEDLEY_COMPCERT_VERSION\n#endif\n#if defined(__COMPCERT_VERSION__)\n    #define JSON_HEDLEY_COMPCERT_VERSION JSON_HEDLEY_VERSION_ENCODE(__COMPCERT_VERSION__ / 10000, (__COMPCERT_VERSION__ / 100) % 100, __COMPCERT_VERSION__ % 100)\n#endif\n\n#if defined(JSON_HEDLEY_COMPCERT_VERSION_CHECK)\n    #undef JSON_HEDLEY_COMPCERT_VERSION_CHECK\n#endif\n#if defined(JSON_HEDLEY_COMPCERT_VERSION)\n    #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_COMPCERT_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))\n#else\n    #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (0)\n#endif\n\n#if defined(JSON_HEDLEY_PELLES_VERSION)\n    #undef JSON_HEDLEY_PELLES_VERSION\n#endif\n#if defined(__POCC__)\n    #define JSON_HEDLEY_PELLES_VERSION JSON_HEDLEY_VERSION_ENCODE(__POCC__ / 100, __POCC__ % 100, 0)\n#endif\n\n#if defined(JSON_HEDLEY_PELLES_VERSION_CHECK)\n    #undef JSON_HEDLEY_PELLES_VERSION_CHECK\n#endif\n#if defined(JSON_HEDLEY_PELLES_VERSION)\n    #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PELLES_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))\n#else\n    #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (0)\n#endif\n\n#if defined(JSON_HEDLEY_MCST_LCC_VERSION)\n    #undef JSON_HEDLEY_MCST_LCC_VERSION\n#endif\n#if defined(__LCC__) && defined(__LCC_MINOR__)\n    #define JSON_HEDLEY_MCST_LCC_VERSION JSON_HEDLEY_VERSION_ENCODE(__LCC__ / 100, __LCC__ % 100, __LCC_MINOR__)\n#endif\n\n#if defined(JSON_HEDLEY_MCST_LCC_VERSION_CHECK)\n    #undef JSON_HEDLEY_MCST_LCC_VERSION_CHECK\n#endif\n#if defined(JSON_HEDLEY_MCST_LCC_VERSION)\n    #define JSON_HEDLEY_MCST_LCC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_MCST_LCC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))\n#else\n    #define JSON_HEDLEY_MCST_LCC_VERSION_CHECK(major,minor,patch) (0)\n#endif\n\n#if defined(JSON_HEDLEY_GCC_VERSION)\n    #undef JSON_HEDLEY_GCC_VERSION\n#endif\n#if \\\n    defined(JSON_HEDLEY_GNUC_VERSION) && \\\n    !defined(__clang__) && \\\n    !defined(JSON_HEDLEY_INTEL_VERSION) && \\\n    !defined(JSON_HEDLEY_PGI_VERSION) && \\\n    !defined(JSON_HEDLEY_ARM_VERSION) && \\\n    !defined(JSON_HEDLEY_CRAY_VERSION) && \\\n    !defined(JSON_HEDLEY_TI_VERSION) && \\\n    !defined(JSON_HEDLEY_TI_ARMCL_VERSION) && \\\n    !defined(JSON_HEDLEY_TI_CL430_VERSION) && \\\n    !defined(JSON_HEDLEY_TI_CL2000_VERSION) && \\\n    !defined(JSON_HEDLEY_TI_CL6X_VERSION) && \\\n    !defined(JSON_HEDLEY_TI_CL7X_VERSION) && \\\n    !defined(JSON_HEDLEY_TI_CLPRU_VERSION) && \\\n    !defined(__COMPCERT__) && \\\n    !defined(JSON_HEDLEY_MCST_LCC_VERSION)\n    #define JSON_HEDLEY_GCC_VERSION JSON_HEDLEY_GNUC_VERSION\n#endif\n\n#if defined(JSON_HEDLEY_GCC_VERSION_CHECK)\n    #undef JSON_HEDLEY_GCC_VERSION_CHECK\n#endif\n#if defined(JSON_HEDLEY_GCC_VERSION)\n    #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GCC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))\n#else\n    #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (0)\n#endif\n\n#if defined(JSON_HEDLEY_HAS_ATTRIBUTE)\n    #undef JSON_HEDLEY_HAS_ATTRIBUTE\n#endif\n#if \\\n  defined(__has_attribute) && \\\n  ( \\\n    (!defined(JSON_HEDLEY_IAR_VERSION) || JSON_HEDLEY_IAR_VERSION_CHECK(8,5,9)) \\\n  )\n#  define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) __has_attribute(attribute)\n#else\n#  define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) (0)\n#endif\n\n#if defined(JSON_HEDLEY_GNUC_HAS_ATTRIBUTE)\n    #undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE\n#endif\n#if defined(__has_attribute)\n    #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)\n#else\n    #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)\n#endif\n\n#if defined(JSON_HEDLEY_GCC_HAS_ATTRIBUTE)\n    #undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE\n#endif\n#if defined(__has_attribute)\n    #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)\n#else\n    #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)\n#endif\n\n#if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE)\n    #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE\n#endif\n#if \\\n    defined(__has_cpp_attribute) && \\\n    defined(__cplusplus) && \\\n    (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0))\n    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) __has_cpp_attribute(attribute)\n#else\n    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) (0)\n#endif\n\n#if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS)\n    #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS\n#endif\n#if !defined(__cplusplus) || !defined(__has_cpp_attribute)\n    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) (0)\n#elif \\\n    !defined(JSON_HEDLEY_PGI_VERSION) && \\\n    !defined(JSON_HEDLEY_IAR_VERSION) && \\\n    (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0)) && \\\n    (!defined(JSON_HEDLEY_MSVC_VERSION) || JSON_HEDLEY_MSVC_VERSION_CHECK(19,20,0))\n    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(ns::attribute)\n#else\n    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) (0)\n#endif\n\n#if defined(JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE)\n    #undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE\n#endif\n#if defined(__has_cpp_attribute) && defined(__cplusplus)\n    #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)\n#else\n    #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)\n#endif\n\n#if defined(JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE)\n    #undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE\n#endif\n#if defined(__has_cpp_attribute) && defined(__cplusplus)\n    #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)\n#else\n    #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)\n#endif\n\n#if defined(JSON_HEDLEY_HAS_BUILTIN)\n    #undef JSON_HEDLEY_HAS_BUILTIN\n#endif\n#if defined(__has_builtin)\n    #define JSON_HEDLEY_HAS_BUILTIN(builtin) __has_builtin(builtin)\n#else\n    #define JSON_HEDLEY_HAS_BUILTIN(builtin) (0)\n#endif\n\n#if defined(JSON_HEDLEY_GNUC_HAS_BUILTIN)\n    #undef JSON_HEDLEY_GNUC_HAS_BUILTIN\n#endif\n#if defined(__has_builtin)\n    #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)\n#else\n    #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)\n#endif\n\n#if defined(JSON_HEDLEY_GCC_HAS_BUILTIN)\n    #undef JSON_HEDLEY_GCC_HAS_BUILTIN\n#endif\n#if defined(__has_builtin)\n    #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)\n#else\n    #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)\n#endif\n\n#if defined(JSON_HEDLEY_HAS_FEATURE)\n    #undef JSON_HEDLEY_HAS_FEATURE\n#endif\n#if defined(__has_feature)\n    #define JSON_HEDLEY_HAS_FEATURE(feature) __has_feature(feature)\n#else\n    #define JSON_HEDLEY_HAS_FEATURE(feature) (0)\n#endif\n\n#if defined(JSON_HEDLEY_GNUC_HAS_FEATURE)\n    #undef JSON_HEDLEY_GNUC_HAS_FEATURE\n#endif\n#if defined(__has_feature)\n    #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)\n#else\n    #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)\n#endif\n\n#if defined(JSON_HEDLEY_GCC_HAS_FEATURE)\n    #undef JSON_HEDLEY_GCC_HAS_FEATURE\n#endif\n#if defined(__has_feature)\n    #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)\n#else\n    #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)\n#endif\n\n#if defined(JSON_HEDLEY_HAS_EXTENSION)\n    #undef JSON_HEDLEY_HAS_EXTENSION\n#endif\n#if defined(__has_extension)\n    #define JSON_HEDLEY_HAS_EXTENSION(extension) __has_extension(extension)\n#else\n    #define JSON_HEDLEY_HAS_EXTENSION(extension) (0)\n#endif\n\n#if defined(JSON_HEDLEY_GNUC_HAS_EXTENSION)\n    #undef JSON_HEDLEY_GNUC_HAS_EXTENSION\n#endif\n#if defined(__has_extension)\n    #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)\n#else\n    #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)\n#endif\n\n#if defined(JSON_HEDLEY_GCC_HAS_EXTENSION)\n    #undef JSON_HEDLEY_GCC_HAS_EXTENSION\n#endif\n#if defined(__has_extension)\n    #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)\n#else\n    #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)\n#endif\n\n#if defined(JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE)\n    #undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE\n#endif\n#if defined(__has_declspec_attribute)\n    #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) __has_declspec_attribute(attribute)\n#else\n    #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) (0)\n#endif\n\n#if defined(JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE)\n    #undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE\n#endif\n#if defined(__has_declspec_attribute)\n    #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)\n#else\n    #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)\n#endif\n\n#if defined(JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE)\n    #undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE\n#endif\n#if defined(__has_declspec_attribute)\n    #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)\n#else\n    #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)\n#endif\n\n#if defined(JSON_HEDLEY_HAS_WARNING)\n    #undef JSON_HEDLEY_HAS_WARNING\n#endif\n#if defined(__has_warning)\n    #define JSON_HEDLEY_HAS_WARNING(warning) __has_warning(warning)\n#else\n    #define JSON_HEDLEY_HAS_WARNING(warning) (0)\n#endif\n\n#if defined(JSON_HEDLEY_GNUC_HAS_WARNING)\n    #undef JSON_HEDLEY_GNUC_HAS_WARNING\n#endif\n#if defined(__has_warning)\n    #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)\n#else\n    #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)\n#endif\n\n#if defined(JSON_HEDLEY_GCC_HAS_WARNING)\n    #undef JSON_HEDLEY_GCC_HAS_WARNING\n#endif\n#if defined(__has_warning)\n    #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)\n#else\n    #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)\n#endif\n\n#if \\\n    (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \\\n    defined(__clang__) || \\\n    JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \\\n    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\\n    JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \\\n    JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \\\n    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\\n    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\\n    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,7,0) || \\\n    JSON_HEDLEY_TI_CL430_VERSION_CHECK(2,0,1) || \\\n    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,1,0) || \\\n    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,0,0) || \\\n    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\\n    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \\\n    JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0) || \\\n    JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,17) || \\\n    JSON_HEDLEY_SUNPRO_VERSION_CHECK(8,0,0) || \\\n    (JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) && defined(__C99_PRAGMA_OPERATOR))\n    #define JSON_HEDLEY_PRAGMA(value) _Pragma(#value)\n#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)\n    #define JSON_HEDLEY_PRAGMA(value) __pragma(value)\n#else\n    #define JSON_HEDLEY_PRAGMA(value)\n#endif\n\n#if defined(JSON_HEDLEY_DIAGNOSTIC_PUSH)\n    #undef JSON_HEDLEY_DIAGNOSTIC_PUSH\n#endif\n#if defined(JSON_HEDLEY_DIAGNOSTIC_POP)\n    #undef JSON_HEDLEY_DIAGNOSTIC_POP\n#endif\n#if defined(__clang__)\n    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma(\"clang diagnostic push\")\n    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma(\"clang diagnostic pop\")\n#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma(\"warning(push)\")\n    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma(\"warning(pop)\")\n#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma(\"GCC diagnostic push\")\n    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma(\"GCC diagnostic pop\")\n#elif \\\n    JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0) || \\\n    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_PUSH __pragma(warning(push))\n    #define JSON_HEDLEY_DIAGNOSTIC_POP __pragma(warning(pop))\n#elif JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma(\"push\")\n    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma(\"pop\")\n#elif \\\n    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\\n    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \\\n    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,4,0) || \\\n    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,1,0) || \\\n    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\\n    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma(\"diag_push\")\n    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma(\"diag_pop\")\n#elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma(\"warning(push)\")\n    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma(\"warning(pop)\")\n#else\n    #define JSON_HEDLEY_DIAGNOSTIC_PUSH\n    #define JSON_HEDLEY_DIAGNOSTIC_POP\n#endif\n\n/* JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_ is for\n   HEDLEY INTERNAL USE ONLY.  API subject to change without notice. */\n#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)\n    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_\n#endif\n#if defined(__cplusplus)\n#  if JSON_HEDLEY_HAS_WARNING(\"-Wc++98-compat\")\n#    if JSON_HEDLEY_HAS_WARNING(\"-Wc++17-extensions\")\n#      if JSON_HEDLEY_HAS_WARNING(\"-Wc++1z-extensions\")\n#        define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \\\n    JSON_HEDLEY_DIAGNOSTIC_PUSH \\\n    _Pragma(\"clang diagnostic ignored \\\"-Wc++98-compat\\\"\") \\\n    _Pragma(\"clang diagnostic ignored \\\"-Wc++17-extensions\\\"\") \\\n    _Pragma(\"clang diagnostic ignored \\\"-Wc++1z-extensions\\\"\") \\\n    xpr \\\n    JSON_HEDLEY_DIAGNOSTIC_POP\n#      else\n#        define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \\\n    JSON_HEDLEY_DIAGNOSTIC_PUSH \\\n    _Pragma(\"clang diagnostic ignored \\\"-Wc++98-compat\\\"\") \\\n    _Pragma(\"clang diagnostic ignored \\\"-Wc++17-extensions\\\"\") \\\n    xpr \\\n    JSON_HEDLEY_DIAGNOSTIC_POP\n#      endif\n#    else\n#      define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \\\n    JSON_HEDLEY_DIAGNOSTIC_PUSH \\\n    _Pragma(\"clang diagnostic ignored \\\"-Wc++98-compat\\\"\") \\\n    xpr \\\n    JSON_HEDLEY_DIAGNOSTIC_POP\n#    endif\n#  endif\n#endif\n#if !defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(x) x\n#endif\n\n#if defined(JSON_HEDLEY_CONST_CAST)\n    #undef JSON_HEDLEY_CONST_CAST\n#endif\n#if defined(__cplusplus)\n#  define JSON_HEDLEY_CONST_CAST(T, expr) (const_cast<T>(expr))\n#elif \\\n  JSON_HEDLEY_HAS_WARNING(\"-Wcast-qual\") || \\\n  JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0) || \\\n  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)\n#  define JSON_HEDLEY_CONST_CAST(T, expr) (__extension__ ({ \\\n        JSON_HEDLEY_DIAGNOSTIC_PUSH \\\n        JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL \\\n        ((T) (expr)); \\\n        JSON_HEDLEY_DIAGNOSTIC_POP \\\n    }))\n#else\n#  define JSON_HEDLEY_CONST_CAST(T, expr) ((T) (expr))\n#endif\n\n#if defined(JSON_HEDLEY_REINTERPRET_CAST)\n    #undef JSON_HEDLEY_REINTERPRET_CAST\n#endif\n#if defined(__cplusplus)\n    #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) (reinterpret_cast<T>(expr))\n#else\n    #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) ((T) (expr))\n#endif\n\n#if defined(JSON_HEDLEY_STATIC_CAST)\n    #undef JSON_HEDLEY_STATIC_CAST\n#endif\n#if defined(__cplusplus)\n    #define JSON_HEDLEY_STATIC_CAST(T, expr) (static_cast<T>(expr))\n#else\n    #define JSON_HEDLEY_STATIC_CAST(T, expr) ((T) (expr))\n#endif\n\n#if defined(JSON_HEDLEY_CPP_CAST)\n    #undef JSON_HEDLEY_CPP_CAST\n#endif\n#if defined(__cplusplus)\n#  if JSON_HEDLEY_HAS_WARNING(\"-Wold-style-cast\")\n#    define JSON_HEDLEY_CPP_CAST(T, expr) \\\n    JSON_HEDLEY_DIAGNOSTIC_PUSH \\\n    _Pragma(\"clang diagnostic ignored \\\"-Wold-style-cast\\\"\") \\\n    ((T) (expr)) \\\n    JSON_HEDLEY_DIAGNOSTIC_POP\n#  elif JSON_HEDLEY_IAR_VERSION_CHECK(8,3,0)\n#    define JSON_HEDLEY_CPP_CAST(T, expr) \\\n    JSON_HEDLEY_DIAGNOSTIC_PUSH \\\n    _Pragma(\"diag_suppress=Pe137\") \\\n    JSON_HEDLEY_DIAGNOSTIC_POP\n#  else\n#    define JSON_HEDLEY_CPP_CAST(T, expr) ((T) (expr))\n#  endif\n#else\n#  define JSON_HEDLEY_CPP_CAST(T, expr) (expr)\n#endif\n\n#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED)\n    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED\n#endif\n#if JSON_HEDLEY_HAS_WARNING(\"-Wdeprecated-declarations\")\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(\"clang diagnostic ignored \\\"-Wdeprecated-declarations\\\"\")\n#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(\"warning(disable:1478 1786)\")\n#elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable:1478 1786))\n#elif JSON_HEDLEY_PGI_VERSION_CHECK(20,7,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(\"diag_suppress 1215,1216,1444,1445\")\n#elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(\"diag_suppress 1215,1444\")\n#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(\"GCC diagnostic ignored \\\"-Wdeprecated-declarations\\\"\")\n#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable:4996))\n#elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(\"diag_suppress 1215,1444\")\n#elif \\\n    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\\n    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \\\n    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \\\n    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \\\n    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \\\n    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\\n    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(\"diag_suppress 1291,1718\")\n#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) && !defined(__cplusplus)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(\"error_messages(off,E_DEPRECATED_ATT,E_DEPRECATED_ATT_MESS)\")\n#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) && defined(__cplusplus)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(\"error_messages(off,symdeprecated,symdeprecated2)\")\n#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(\"diag_suppress=Pe1444,Pe1215\")\n#elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(\"warn(disable:2241)\")\n#else\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED\n#endif\n\n#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS)\n    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS\n#endif\n#if JSON_HEDLEY_HAS_WARNING(\"-Wunknown-pragmas\")\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma(\"clang diagnostic ignored \\\"-Wunknown-pragmas\\\"\")\n#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma(\"warning(disable:161)\")\n#elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS __pragma(warning(disable:161))\n#elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma(\"diag_suppress 1675\")\n#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma(\"GCC diagnostic ignored \\\"-Wunknown-pragmas\\\"\")\n#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS __pragma(warning(disable:4068))\n#elif \\\n    JSON_HEDLEY_TI_VERSION_CHECK(16,9,0) || \\\n    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0) || \\\n    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\\n    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,3,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma(\"diag_suppress 163\")\n#elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma(\"diag_suppress 163\")\n#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma(\"diag_suppress=Pe161\")\n#elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma(\"diag_suppress 161\")\n#else\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS\n#endif\n\n#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES)\n    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES\n#endif\n#if JSON_HEDLEY_HAS_WARNING(\"-Wunknown-attributes\")\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(\"clang diagnostic ignored \\\"-Wunknown-attributes\\\"\")\n#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(\"GCC diagnostic ignored \\\"-Wdeprecated-declarations\\\"\")\n#elif JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(\"warning(disable:1292)\")\n#elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES __pragma(warning(disable:1292))\n#elif JSON_HEDLEY_MSVC_VERSION_CHECK(19,0,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES __pragma(warning(disable:5030))\n#elif JSON_HEDLEY_PGI_VERSION_CHECK(20,7,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(\"diag_suppress 1097,1098\")\n#elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(\"diag_suppress 1097\")\n#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) && defined(__cplusplus)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(\"error_messages(off,attrskipunsup)\")\n#elif \\\n    JSON_HEDLEY_TI_VERSION_CHECK(18,1,0) || \\\n    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,3,0) || \\\n    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(\"diag_suppress 1173\")\n#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(\"diag_suppress=Pe1097\")\n#elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(\"diag_suppress 1097\")\n#else\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES\n#endif\n\n#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL)\n    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL\n#endif\n#if JSON_HEDLEY_HAS_WARNING(\"-Wcast-qual\")\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma(\"clang diagnostic ignored \\\"-Wcast-qual\\\"\")\n#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma(\"warning(disable:2203 2331)\")\n#elif JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma(\"GCC diagnostic ignored \\\"-Wcast-qual\\\"\")\n#else\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL\n#endif\n\n#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION)\n    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION\n#endif\n#if JSON_HEDLEY_HAS_WARNING(\"-Wunused-function\")\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma(\"clang diagnostic ignored \\\"-Wunused-function\\\"\")\n#elif JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma(\"GCC diagnostic ignored \\\"-Wunused-function\\\"\")\n#elif JSON_HEDLEY_MSVC_VERSION_CHECK(1,0,0)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION __pragma(warning(disable:4505))\n#elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma(\"diag_suppress 3142\")\n#else\n    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION\n#endif\n\n#if defined(JSON_HEDLEY_DEPRECATED)\n    #undef JSON_HEDLEY_DEPRECATED\n#endif\n#if defined(JSON_HEDLEY_DEPRECATED_FOR)\n    #undef JSON_HEDLEY_DEPRECATED_FOR\n#endif\n#if \\\n    JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \\\n    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)\n    #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated(\"Since \" # since))\n    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated(\"Since \" #since \"; use \" #replacement))\n#elif \\\n    (JSON_HEDLEY_HAS_EXTENSION(attribute_deprecated_with_message) && !defined(JSON_HEDLEY_IAR_VERSION)) || \\\n    JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \\\n    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\\n    JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \\\n    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) || \\\n    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \\\n    JSON_HEDLEY_TI_VERSION_CHECK(18,1,0) || \\\n    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(18,1,0) || \\\n    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,3,0) || \\\n    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\\n    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,3,0) || \\\n    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)\n    #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__(\"Since \" #since)))\n    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__(\"Since \" #since \"; use \" #replacement)))\n#elif defined(__cplusplus) && (__cplusplus >= 201402L)\n    #define JSON_HEDLEY_DEPRECATED(since) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated(\"Since \" #since)]])\n    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated(\"Since \" #since \"; use \" #replacement)]])\n#elif \\\n    JSON_HEDLEY_HAS_ATTRIBUTE(deprecated) || \\\n    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \\\n    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\\n    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\\n    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \\\n    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \\\n    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \\\n    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \\\n    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\\n    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \\\n    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \\\n    JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)\n    #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__))\n    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__))\n#elif \\\n    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \\\n    JSON_HEDLEY_PELLES_VERSION_CHECK(6,50,0) || \\\n    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)\n    #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated)\n    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated)\n#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)\n    #define JSON_HEDLEY_DEPRECATED(since) _Pragma(\"deprecated\")\n    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) _Pragma(\"deprecated\")\n#else\n    #define JSON_HEDLEY_DEPRECATED(since)\n    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement)\n#endif\n\n#if defined(JSON_HEDLEY_UNAVAILABLE)\n    #undef JSON_HEDLEY_UNAVAILABLE\n#endif\n#if \\\n    JSON_HEDLEY_HAS_ATTRIBUTE(warning) || \\\n    JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0) || \\\n    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\\n    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)\n    #define JSON_HEDLEY_UNAVAILABLE(available_since) __attribute__((__warning__(\"Not available until \" #available_since)))\n#else\n    #define JSON_HEDLEY_UNAVAILABLE(available_since)\n#endif\n\n#if defined(JSON_HEDLEY_WARN_UNUSED_RESULT)\n    #undef JSON_HEDLEY_WARN_UNUSED_RESULT\n#endif\n#if defined(JSON_HEDLEY_WARN_UNUSED_RESULT_MSG)\n    #undef JSON_HEDLEY_WARN_UNUSED_RESULT_MSG\n#endif\n#if \\\n    JSON_HEDLEY_HAS_ATTRIBUTE(warn_unused_result) || \\\n    JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \\\n    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\\n    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\\n    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \\\n    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \\\n    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \\\n    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \\\n    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\\n    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \\\n    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) && defined(__cplusplus)) || \\\n    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \\\n    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)\n    #define JSON_HEDLEY_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) __attribute__((__warn_unused_result__))\n#elif (JSON_HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard) >= 201907L)\n    #define JSON_HEDLEY_WARN_UNUSED_RESULT JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])\n    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard(msg)]])\n#elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard)\n    #define JSON_HEDLEY_WARN_UNUSED_RESULT JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])\n    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])\n#elif defined(_Check_return_) /* SAL */\n    #define JSON_HEDLEY_WARN_UNUSED_RESULT _Check_return_\n    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) _Check_return_\n#else\n    #define JSON_HEDLEY_WARN_UNUSED_RESULT\n    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg)\n#endif\n\n#if defined(JSON_HEDLEY_SENTINEL)\n    #undef JSON_HEDLEY_SENTINEL\n#endif\n#if \\\n    JSON_HEDLEY_HAS_ATTRIBUTE(sentinel) || \\\n    JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \\\n    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\\n    JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0) || \\\n    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)\n    #define JSON_HEDLEY_SENTINEL(position) __attribute__((__sentinel__(position)))\n#else\n    #define JSON_HEDLEY_SENTINEL(position)\n#endif\n\n#if defined(JSON_HEDLEY_NO_RETURN)\n    #undef JSON_HEDLEY_NO_RETURN\n#endif\n#if JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)\n    #define JSON_HEDLEY_NO_RETURN __noreturn\n#elif \\\n    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\\n    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)\n    #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))\n#elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L\n    #define JSON_HEDLEY_NO_RETURN _Noreturn\n#elif defined(__cplusplus) && (__cplusplus >= 201103L)\n    #define JSON_HEDLEY_NO_RETURN JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[noreturn]])\n#elif \\\n    JSON_HEDLEY_HAS_ATTRIBUTE(noreturn) || \\\n    JSON_HEDLEY_GCC_VERSION_CHECK(3,2,0) || \\\n    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \\\n    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\\n    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \\\n    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\\n    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \\\n    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \\\n    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \\\n    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \\\n    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\\n    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \\\n    JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)\n    #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))\n#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)\n    #define JSON_HEDLEY_NO_RETURN _Pragma(\"does_not_return\")\n#elif \\\n    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \\\n    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)\n    #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)\n#elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,0,0) && defined(__cplusplus)\n    #define JSON_HEDLEY_NO_RETURN _Pragma(\"FUNC_NEVER_RETURNS;\")\n#elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)\n    #define JSON_HEDLEY_NO_RETURN __attribute((noreturn))\n#elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)\n    #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)\n#else\n    #define JSON_HEDLEY_NO_RETURN\n#endif\n\n#if defined(JSON_HEDLEY_NO_ESCAPE)\n    #undef JSON_HEDLEY_NO_ESCAPE\n#endif\n#if JSON_HEDLEY_HAS_ATTRIBUTE(noescape)\n    #define JSON_HEDLEY_NO_ESCAPE __attribute__((__noescape__))\n#else\n    #define JSON_HEDLEY_NO_ESCAPE\n#endif\n\n#if defined(JSON_HEDLEY_UNREACHABLE)\n    #undef JSON_HEDLEY_UNREACHABLE\n#endif\n#if defined(JSON_HEDLEY_UNREACHABLE_RETURN)\n    #undef JSON_HEDLEY_UNREACHABLE_RETURN\n#endif\n#if defined(JSON_HEDLEY_ASSUME)\n    #undef JSON_HEDLEY_ASSUME\n#endif\n#if \\\n    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \\\n    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\\n    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)\n    #define JSON_HEDLEY_ASSUME(expr) __assume(expr)\n#elif JSON_HEDLEY_HAS_BUILTIN(__builtin_assume)\n    #define JSON_HEDLEY_ASSUME(expr) __builtin_assume(expr)\n#elif \\\n    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \\\n    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0)\n    #if defined(__cplusplus)\n        #define JSON_HEDLEY_ASSUME(expr) std::_nassert(expr)\n    #else\n        #define JSON_HEDLEY_ASSUME(expr) _nassert(expr)\n    #endif\n#endif\n#if \\\n    (JSON_HEDLEY_HAS_BUILTIN(__builtin_unreachable) && (!defined(JSON_HEDLEY_ARM_VERSION))) || \\\n    JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \\\n    JSON_HEDLEY_PGI_VERSION_CHECK(18,10,0) || \\\n    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\\n    JSON_HEDLEY_IBM_VERSION_CHECK(13,1,5) || \\\n    JSON_HEDLEY_CRAY_VERSION_CHECK(10,0,0) || \\\n    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)\n    #define JSON_HEDLEY_UNREACHABLE() __builtin_unreachable()\n#elif defined(JSON_HEDLEY_ASSUME)\n    #define JSON_HEDLEY_UNREACHABLE() JSON_HEDLEY_ASSUME(0)\n#endif\n#if !defined(JSON_HEDLEY_ASSUME)\n    #if defined(JSON_HEDLEY_UNREACHABLE)\n        #define JSON_HEDLEY_ASSUME(expr) JSON_HEDLEY_STATIC_CAST(void, ((expr) ? 1 : (JSON_HEDLEY_UNREACHABLE(), 1)))\n    #else\n        #define JSON_HEDLEY_ASSUME(expr) JSON_HEDLEY_STATIC_CAST(void, expr)\n    #endif\n#endif\n#if defined(JSON_HEDLEY_UNREACHABLE)\n    #if  \\\n        JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \\\n        JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0)\n        #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return (JSON_HEDLEY_STATIC_CAST(void, JSON_HEDLEY_ASSUME(0)), (value))\n    #else\n        #define JSON_HEDLEY_UNREACHABLE_RETURN(value) JSON_HEDLEY_UNREACHABLE()\n    #endif\n#else\n    #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return (value)\n#endif\n#if !defined(JSON_HEDLEY_UNREACHABLE)\n    #define JSON_HEDLEY_UNREACHABLE() JSON_HEDLEY_ASSUME(0)\n#endif\n\nJSON_HEDLEY_DIAGNOSTIC_PUSH\n#if JSON_HEDLEY_HAS_WARNING(\"-Wpedantic\")\n    #pragma clang diagnostic ignored \"-Wpedantic\"\n#endif\n#if JSON_HEDLEY_HAS_WARNING(\"-Wc++98-compat-pedantic\") && defined(__cplusplus)\n    #pragma clang diagnostic ignored \"-Wc++98-compat-pedantic\"\n#endif\n#if JSON_HEDLEY_GCC_HAS_WARNING(\"-Wvariadic-macros\",4,0,0)\n    #if defined(__clang__)\n        #pragma clang diagnostic ignored \"-Wvariadic-macros\"\n    #elif defined(JSON_HEDLEY_GCC_VERSION)\n        #pragma GCC diagnostic ignored \"-Wvariadic-macros\"\n    #endif\n#endif\n#if defined(JSON_HEDLEY_NON_NULL)\n    #undef JSON_HEDLEY_NON_NULL\n#endif\n#if \\\n    JSON_HEDLEY_HAS_ATTRIBUTE(nonnull) || \\\n    JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \\\n    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\\n    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)\n    #define JSON_HEDLEY_NON_NULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n#else\n    #define JSON_HEDLEY_NON_NULL(...)\n#endif\nJSON_HEDLEY_DIAGNOSTIC_POP\n\n#if defined(JSON_HEDLEY_PRINTF_FORMAT)\n    #undef JSON_HEDLEY_PRINTF_FORMAT\n#endif\n#if defined(__MINGW32__) && JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) && !defined(__USE_MINGW_ANSI_STDIO)\n    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(ms_printf, string_idx, first_to_check)))\n#elif defined(__MINGW32__) && JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) && defined(__USE_MINGW_ANSI_STDIO)\n    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(gnu_printf, string_idx, first_to_check)))\n#elif \\\n    JSON_HEDLEY_HAS_ATTRIBUTE(format) || \\\n    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \\\n    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\\n    JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \\\n    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \\\n    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\\n    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \\\n    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \\\n    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \\\n    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \\\n    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\\n    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \\\n    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)\n    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(__printf__, string_idx, first_to_check)))\n#elif JSON_HEDLEY_PELLES_VERSION_CHECK(6,0,0)\n    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __declspec(vaformat(printf,string_idx,first_to_check))\n#else\n    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check)\n#endif\n\n#if defined(JSON_HEDLEY_CONSTEXPR)\n    #undef JSON_HEDLEY_CONSTEXPR\n#endif\n#if defined(__cplusplus)\n    #if __cplusplus >= 201103L\n        #define JSON_HEDLEY_CONSTEXPR JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(constexpr)\n    #endif\n#endif\n#if !defined(JSON_HEDLEY_CONSTEXPR)\n    #define JSON_HEDLEY_CONSTEXPR\n#endif\n\n#if defined(JSON_HEDLEY_PREDICT)\n    #undef JSON_HEDLEY_PREDICT\n#endif\n#if defined(JSON_HEDLEY_LIKELY)\n    #undef JSON_HEDLEY_LIKELY\n#endif\n#if defined(JSON_HEDLEY_UNLIKELY)\n    #undef JSON_HEDLEY_UNLIKELY\n#endif\n#if defined(JSON_HEDLEY_UNPREDICTABLE)\n    #undef JSON_HEDLEY_UNPREDICTABLE\n#endif\n#if JSON_HEDLEY_HAS_BUILTIN(__builtin_unpredictable)\n    #define JSON_HEDLEY_UNPREDICTABLE(expr) __builtin_unpredictable((expr))\n#endif\n#if \\\n  (JSON_HEDLEY_HAS_BUILTIN(__builtin_expect_with_probability) && !defined(JSON_HEDLEY_PGI_VERSION)) || \\\n  JSON_HEDLEY_GCC_VERSION_CHECK(9,0,0) || \\\n  JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)\n#  define JSON_HEDLEY_PREDICT(expr, value, probability) __builtin_expect_with_probability(  (expr), (value), (probability))\n#  define JSON_HEDLEY_PREDICT_TRUE(expr, probability)   __builtin_expect_with_probability(!!(expr),    1   , (probability))\n#  define JSON_HEDLEY_PREDICT_FALSE(expr, probability)  __builtin_expect_with_probability(!!(expr),    0   , (probability))\n#  define JSON_HEDLEY_LIKELY(expr)                      __builtin_expect                 (!!(expr),    1                  )\n#  define JSON_HEDLEY_UNLIKELY(expr)                    __builtin_expect                 (!!(expr),    0                  )\n#elif \\\n  (JSON_HEDLEY_HAS_BUILTIN(__builtin_expect) && !defined(JSON_HEDLEY_INTEL_CL_VERSION)) || \\\n  JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \\\n  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\\n  (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) && defined(__cplusplus)) || \\\n  JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\\n  JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \\\n  JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\\n  JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,7,0) || \\\n  JSON_HEDLEY_TI_CL430_VERSION_CHECK(3,1,0) || \\\n  JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,1,0) || \\\n  JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \\\n  JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\\n  JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \\\n  JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,27) || \\\n  JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \\\n  JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)\n#  define JSON_HEDLEY_PREDICT(expr, expected, probability) \\\n    (((probability) >= 0.9) ? __builtin_expect((expr), (expected)) : (JSON_HEDLEY_STATIC_CAST(void, expected), (expr)))\n#  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) \\\n    (__extension__ ({ \\\n        double hedley_probability_ = (probability); \\\n        ((hedley_probability_ >= 0.9) ? __builtin_expect(!!(expr), 1) : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 0) : !!(expr))); \\\n    }))\n#  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) \\\n    (__extension__ ({ \\\n        double hedley_probability_ = (probability); \\\n        ((hedley_probability_ >= 0.9) ? __builtin_expect(!!(expr), 0) : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 1) : !!(expr))); \\\n    }))\n#  define JSON_HEDLEY_LIKELY(expr)   __builtin_expect(!!(expr), 1)\n#  define JSON_HEDLEY_UNLIKELY(expr) __builtin_expect(!!(expr), 0)\n#else\n#  define JSON_HEDLEY_PREDICT(expr, expected, probability) (JSON_HEDLEY_STATIC_CAST(void, expected), (expr))\n#  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) (!!(expr))\n#  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) (!!(expr))\n#  define JSON_HEDLEY_LIKELY(expr) (!!(expr))\n#  define JSON_HEDLEY_UNLIKELY(expr) (!!(expr))\n#endif\n#if !defined(JSON_HEDLEY_UNPREDICTABLE)\n    #define JSON_HEDLEY_UNPREDICTABLE(expr) JSON_HEDLEY_PREDICT(expr, 1, 0.5)\n#endif\n\n#if defined(JSON_HEDLEY_MALLOC)\n    #undef JSON_HEDLEY_MALLOC\n#endif\n#if \\\n    JSON_HEDLEY_HAS_ATTRIBUTE(malloc) || \\\n    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \\\n    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\\n    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \\\n    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\\n    JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \\\n    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\\n    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \\\n    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \\\n    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \\\n    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \\\n    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\\n    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \\\n    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)\n    #define JSON_HEDLEY_MALLOC __attribute__((__malloc__))\n#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)\n    #define JSON_HEDLEY_MALLOC _Pragma(\"returns_new_memory\")\n#elif \\\n    JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \\\n    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)\n    #define JSON_HEDLEY_MALLOC __declspec(restrict)\n#else\n    #define JSON_HEDLEY_MALLOC\n#endif\n\n#if defined(JSON_HEDLEY_PURE)\n    #undef JSON_HEDLEY_PURE\n#endif\n#if \\\n  JSON_HEDLEY_HAS_ATTRIBUTE(pure) || \\\n  JSON_HEDLEY_GCC_VERSION_CHECK(2,96,0) || \\\n  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\\n  JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \\\n  JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\\n  JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \\\n  JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\\n  (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n  JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \\\n  (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n  JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \\\n  (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n  JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \\\n  (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n  JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \\\n  JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\\n  JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \\\n  JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \\\n  JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)\n#  define JSON_HEDLEY_PURE __attribute__((__pure__))\n#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)\n#  define JSON_HEDLEY_PURE _Pragma(\"does_not_write_global_data\")\n#elif defined(__cplusplus) && \\\n    ( \\\n      JSON_HEDLEY_TI_CL430_VERSION_CHECK(2,0,1) || \\\n      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0) || \\\n      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) \\\n    )\n#  define JSON_HEDLEY_PURE _Pragma(\"FUNC_IS_PURE;\")\n#else\n#  define JSON_HEDLEY_PURE\n#endif\n\n#if defined(JSON_HEDLEY_CONST)\n    #undef JSON_HEDLEY_CONST\n#endif\n#if \\\n    JSON_HEDLEY_HAS_ATTRIBUTE(const) || \\\n    JSON_HEDLEY_GCC_VERSION_CHECK(2,5,0) || \\\n    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\\n    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \\\n    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\\n    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \\\n    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\\n    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \\\n    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \\\n    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \\\n    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \\\n    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\\n    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \\\n    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \\\n    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)\n    #define JSON_HEDLEY_CONST __attribute__((__const__))\n#elif \\\n    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)\n    #define JSON_HEDLEY_CONST _Pragma(\"no_side_effect\")\n#else\n    #define JSON_HEDLEY_CONST JSON_HEDLEY_PURE\n#endif\n\n#if defined(JSON_HEDLEY_RESTRICT)\n    #undef JSON_HEDLEY_RESTRICT\n#endif\n#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && !defined(__cplusplus)\n    #define JSON_HEDLEY_RESTRICT restrict\n#elif \\\n    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \\\n    JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \\\n    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\\n    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \\\n    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\\n    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \\\n    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \\\n    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \\\n    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,4) || \\\n    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,1,0) || \\\n    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\\n    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) && defined(__cplusplus)) || \\\n    JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \\\n    defined(__clang__) || \\\n    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)\n    #define JSON_HEDLEY_RESTRICT __restrict\n#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,3,0) && !defined(__cplusplus)\n    #define JSON_HEDLEY_RESTRICT _Restrict\n#else\n    #define JSON_HEDLEY_RESTRICT\n#endif\n\n#if defined(JSON_HEDLEY_INLINE)\n    #undef JSON_HEDLEY_INLINE\n#endif\n#if \\\n    (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \\\n    (defined(__cplusplus) && (__cplusplus >= 199711L))\n    #define JSON_HEDLEY_INLINE inline\n#elif \\\n    defined(JSON_HEDLEY_GCC_VERSION) || \\\n    JSON_HEDLEY_ARM_VERSION_CHECK(6,2,0)\n    #define JSON_HEDLEY_INLINE __inline__\n#elif \\\n    JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0) || \\\n    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \\\n    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\\n    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,1,0) || \\\n    JSON_HEDLEY_TI_CL430_VERSION_CHECK(3,1,0) || \\\n    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \\\n    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0) || \\\n    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\\n    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \\\n    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)\n    #define JSON_HEDLEY_INLINE __inline\n#else\n    #define JSON_HEDLEY_INLINE\n#endif\n\n#if defined(JSON_HEDLEY_ALWAYS_INLINE)\n    #undef JSON_HEDLEY_ALWAYS_INLINE\n#endif\n#if \\\n  JSON_HEDLEY_HAS_ATTRIBUTE(always_inline) || \\\n  JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \\\n  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\\n  JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \\\n  JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\\n  JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \\\n  JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\\n  (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n  JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \\\n  (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n  JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \\\n  (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n  JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \\\n  (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n  JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \\\n  JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\\n  JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \\\n  JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \\\n  JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)\n#  define JSON_HEDLEY_ALWAYS_INLINE __attribute__((__always_inline__)) JSON_HEDLEY_INLINE\n#elif \\\n  JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0) || \\\n  JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)\n#  define JSON_HEDLEY_ALWAYS_INLINE __forceinline\n#elif defined(__cplusplus) && \\\n    ( \\\n      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \\\n      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \\\n      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \\\n      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \\\n      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\\n      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) \\\n    )\n#  define JSON_HEDLEY_ALWAYS_INLINE _Pragma(\"FUNC_ALWAYS_INLINE;\")\n#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)\n#  define JSON_HEDLEY_ALWAYS_INLINE _Pragma(\"inline=forced\")\n#else\n#  define JSON_HEDLEY_ALWAYS_INLINE JSON_HEDLEY_INLINE\n#endif\n\n#if defined(JSON_HEDLEY_NEVER_INLINE)\n    #undef JSON_HEDLEY_NEVER_INLINE\n#endif\n#if \\\n    JSON_HEDLEY_HAS_ATTRIBUTE(noinline) || \\\n    JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \\\n    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\\n    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \\\n    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\\n    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \\\n    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\\n    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \\\n    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \\\n    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \\\n    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \\\n    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\\n    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \\\n    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \\\n    JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)\n    #define JSON_HEDLEY_NEVER_INLINE __attribute__((__noinline__))\n#elif \\\n    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \\\n    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)\n    #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)\n#elif JSON_HEDLEY_PGI_VERSION_CHECK(10,2,0)\n    #define JSON_HEDLEY_NEVER_INLINE _Pragma(\"noinline\")\n#elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,0,0) && defined(__cplusplus)\n    #define JSON_HEDLEY_NEVER_INLINE _Pragma(\"FUNC_CANNOT_INLINE;\")\n#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)\n    #define JSON_HEDLEY_NEVER_INLINE _Pragma(\"inline=never\")\n#elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)\n    #define JSON_HEDLEY_NEVER_INLINE __attribute((noinline))\n#elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)\n    #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)\n#else\n    #define JSON_HEDLEY_NEVER_INLINE\n#endif\n\n#if defined(JSON_HEDLEY_PRIVATE)\n    #undef JSON_HEDLEY_PRIVATE\n#endif\n#if defined(JSON_HEDLEY_PUBLIC)\n    #undef JSON_HEDLEY_PUBLIC\n#endif\n#if defined(JSON_HEDLEY_IMPORT)\n    #undef JSON_HEDLEY_IMPORT\n#endif\n#if defined(_WIN32) || defined(__CYGWIN__)\n#  define JSON_HEDLEY_PRIVATE\n#  define JSON_HEDLEY_PUBLIC   __declspec(dllexport)\n#  define JSON_HEDLEY_IMPORT   __declspec(dllimport)\n#else\n#  if \\\n    JSON_HEDLEY_HAS_ATTRIBUTE(visibility) || \\\n    JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \\\n    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \\\n    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\\n    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\\n    JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \\\n    ( \\\n      defined(__TI_EABI__) && \\\n      ( \\\n        (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\\n        JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) \\\n      ) \\\n    ) || \\\n    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)\n#    define JSON_HEDLEY_PRIVATE __attribute__((__visibility__(\"hidden\")))\n#    define JSON_HEDLEY_PUBLIC  __attribute__((__visibility__(\"default\")))\n#  else\n#    define JSON_HEDLEY_PRIVATE\n#    define JSON_HEDLEY_PUBLIC\n#  endif\n#  define JSON_HEDLEY_IMPORT    extern\n#endif\n\n#if defined(JSON_HEDLEY_NO_THROW)\n    #undef JSON_HEDLEY_NO_THROW\n#endif\n#if \\\n    JSON_HEDLEY_HAS_ATTRIBUTE(nothrow) || \\\n    JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \\\n    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\\n    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)\n    #define JSON_HEDLEY_NO_THROW __attribute__((__nothrow__))\n#elif \\\n    JSON_HEDLEY_MSVC_VERSION_CHECK(13,1,0) || \\\n    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \\\n    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)\n    #define JSON_HEDLEY_NO_THROW __declspec(nothrow)\n#else\n    #define JSON_HEDLEY_NO_THROW\n#endif\n\n#if defined(JSON_HEDLEY_FALL_THROUGH)\n    #undef JSON_HEDLEY_FALL_THROUGH\n#endif\n#if \\\n    JSON_HEDLEY_HAS_ATTRIBUTE(fallthrough) || \\\n    JSON_HEDLEY_GCC_VERSION_CHECK(7,0,0) || \\\n    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)\n    #define JSON_HEDLEY_FALL_THROUGH __attribute__((__fallthrough__))\n#elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(clang,fallthrough)\n    #define JSON_HEDLEY_FALL_THROUGH JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[clang::fallthrough]])\n#elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE(fallthrough)\n    #define JSON_HEDLEY_FALL_THROUGH JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[fallthrough]])\n#elif defined(__fallthrough) /* SAL */\n    #define JSON_HEDLEY_FALL_THROUGH __fallthrough\n#else\n    #define JSON_HEDLEY_FALL_THROUGH\n#endif\n\n#if defined(JSON_HEDLEY_RETURNS_NON_NULL)\n    #undef JSON_HEDLEY_RETURNS_NON_NULL\n#endif\n#if \\\n    JSON_HEDLEY_HAS_ATTRIBUTE(returns_nonnull) || \\\n    JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0) || \\\n    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)\n    #define JSON_HEDLEY_RETURNS_NON_NULL __attribute__((__returns_nonnull__))\n#elif defined(_Ret_notnull_) /* SAL */\n    #define JSON_HEDLEY_RETURNS_NON_NULL _Ret_notnull_\n#else\n    #define JSON_HEDLEY_RETURNS_NON_NULL\n#endif\n\n#if defined(JSON_HEDLEY_ARRAY_PARAM)\n    #undef JSON_HEDLEY_ARRAY_PARAM\n#endif\n#if \\\n    defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && \\\n    !defined(__STDC_NO_VLA__) && \\\n    !defined(__cplusplus) && \\\n    !defined(JSON_HEDLEY_PGI_VERSION) && \\\n    !defined(JSON_HEDLEY_TINYC_VERSION)\n    #define JSON_HEDLEY_ARRAY_PARAM(name) (name)\n#else\n    #define JSON_HEDLEY_ARRAY_PARAM(name)\n#endif\n\n#if defined(JSON_HEDLEY_IS_CONSTANT)\n    #undef JSON_HEDLEY_IS_CONSTANT\n#endif\n#if defined(JSON_HEDLEY_REQUIRE_CONSTEXPR)\n    #undef JSON_HEDLEY_REQUIRE_CONSTEXPR\n#endif\n/* JSON_HEDLEY_IS_CONSTEXPR_ is for\n   HEDLEY INTERNAL USE ONLY.  API subject to change without notice. */\n#if defined(JSON_HEDLEY_IS_CONSTEXPR_)\n    #undef JSON_HEDLEY_IS_CONSTEXPR_\n#endif\n#if \\\n    JSON_HEDLEY_HAS_BUILTIN(__builtin_constant_p) || \\\n    JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \\\n    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\\n    JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,19) || \\\n    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\\n    JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \\\n    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \\\n    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0) && !defined(__cplusplus)) || \\\n    JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \\\n    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)\n    #define JSON_HEDLEY_IS_CONSTANT(expr) __builtin_constant_p(expr)\n#endif\n#if !defined(__cplusplus)\n#  if \\\n       JSON_HEDLEY_HAS_BUILTIN(__builtin_types_compatible_p) || \\\n       JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \\\n       JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\\n       JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \\\n       JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \\\n       JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0) || \\\n       JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,24)\n#if defined(__INTPTR_TYPE__)\n    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0)), int*)\n#else\n    #include <stdint.h>\n    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((intptr_t) ((expr) * 0)) : (int*) 0)), int*)\n#endif\n#  elif \\\n       ( \\\n          defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) && \\\n          !defined(JSON_HEDLEY_SUNPRO_VERSION) && \\\n          !defined(JSON_HEDLEY_PGI_VERSION) && \\\n          !defined(JSON_HEDLEY_IAR_VERSION)) || \\\n       (JSON_HEDLEY_HAS_EXTENSION(c_generic_selections) && !defined(JSON_HEDLEY_IAR_VERSION)) || \\\n       JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0) || \\\n       JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0) || \\\n       JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \\\n       JSON_HEDLEY_ARM_VERSION_CHECK(5,3,0)\n#if defined(__INTPTR_TYPE__)\n    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) _Generic((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0), int*: 1, void*: 0)\n#else\n    #include <stdint.h>\n    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) _Generic((1 ? (void*) ((intptr_t) * 0) : (int*) 0), int*: 1, void*: 0)\n#endif\n#  elif \\\n       defined(JSON_HEDLEY_GCC_VERSION) || \\\n       defined(JSON_HEDLEY_INTEL_VERSION) || \\\n       defined(JSON_HEDLEY_TINYC_VERSION) || \\\n       defined(JSON_HEDLEY_TI_ARMCL_VERSION) || \\\n       JSON_HEDLEY_TI_CL430_VERSION_CHECK(18,12,0) || \\\n       defined(JSON_HEDLEY_TI_CL2000_VERSION) || \\\n       defined(JSON_HEDLEY_TI_CL6X_VERSION) || \\\n       defined(JSON_HEDLEY_TI_CL7X_VERSION) || \\\n       defined(JSON_HEDLEY_TI_CLPRU_VERSION) || \\\n       defined(__clang__)\n#    define JSON_HEDLEY_IS_CONSTEXPR_(expr) ( \\\n        sizeof(void) != \\\n        sizeof(*( \\\n                  1 ? \\\n                  ((void*) ((expr) * 0L) ) : \\\n((struct { char v[sizeof(void) * 2]; } *) 1) \\\n                ) \\\n              ) \\\n                                            )\n#  endif\n#endif\n#if defined(JSON_HEDLEY_IS_CONSTEXPR_)\n    #if !defined(JSON_HEDLEY_IS_CONSTANT)\n        #define JSON_HEDLEY_IS_CONSTANT(expr) JSON_HEDLEY_IS_CONSTEXPR_(expr)\n    #endif\n    #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (JSON_HEDLEY_IS_CONSTEXPR_(expr) ? (expr) : (-1))\n#else\n    #if !defined(JSON_HEDLEY_IS_CONSTANT)\n        #define JSON_HEDLEY_IS_CONSTANT(expr) (0)\n    #endif\n    #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (expr)\n#endif\n\n#if defined(JSON_HEDLEY_BEGIN_C_DECLS)\n    #undef JSON_HEDLEY_BEGIN_C_DECLS\n#endif\n#if defined(JSON_HEDLEY_END_C_DECLS)\n    #undef JSON_HEDLEY_END_C_DECLS\n#endif\n#if defined(JSON_HEDLEY_C_DECL)\n    #undef JSON_HEDLEY_C_DECL\n#endif\n#if defined(__cplusplus)\n    #define JSON_HEDLEY_BEGIN_C_DECLS extern \"C\" {\n    #define JSON_HEDLEY_END_C_DECLS }\n    #define JSON_HEDLEY_C_DECL extern \"C\"\n#else\n    #define JSON_HEDLEY_BEGIN_C_DECLS\n    #define JSON_HEDLEY_END_C_DECLS\n    #define JSON_HEDLEY_C_DECL\n#endif\n\n#if defined(JSON_HEDLEY_STATIC_ASSERT)\n    #undef JSON_HEDLEY_STATIC_ASSERT\n#endif\n#if \\\n  !defined(__cplusplus) && ( \\\n      (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)) || \\\n      (JSON_HEDLEY_HAS_FEATURE(c_static_assert) && !defined(JSON_HEDLEY_INTEL_CL_VERSION)) || \\\n      JSON_HEDLEY_GCC_VERSION_CHECK(6,0,0) || \\\n      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\\n      defined(_Static_assert) \\\n    )\n#  define JSON_HEDLEY_STATIC_ASSERT(expr, message) _Static_assert(expr, message)\n#elif \\\n  (defined(__cplusplus) && (__cplusplus >= 201103L)) || \\\n  JSON_HEDLEY_MSVC_VERSION_CHECK(16,0,0) || \\\n  JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)\n#  define JSON_HEDLEY_STATIC_ASSERT(expr, message) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(static_assert(expr, message))\n#else\n#  define JSON_HEDLEY_STATIC_ASSERT(expr, message)\n#endif\n\n#if defined(JSON_HEDLEY_NULL)\n    #undef JSON_HEDLEY_NULL\n#endif\n#if defined(__cplusplus)\n    #if __cplusplus >= 201103L\n        #define JSON_HEDLEY_NULL JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(nullptr)\n    #elif defined(NULL)\n        #define JSON_HEDLEY_NULL NULL\n    #else\n        #define JSON_HEDLEY_NULL JSON_HEDLEY_STATIC_CAST(void*, 0)\n    #endif\n#elif defined(NULL)\n    #define JSON_HEDLEY_NULL NULL\n#else\n    #define JSON_HEDLEY_NULL ((void*) 0)\n#endif\n\n#if defined(JSON_HEDLEY_MESSAGE)\n    #undef JSON_HEDLEY_MESSAGE\n#endif\n#if JSON_HEDLEY_HAS_WARNING(\"-Wunknown-pragmas\")\n#  define JSON_HEDLEY_MESSAGE(msg) \\\n    JSON_HEDLEY_DIAGNOSTIC_PUSH \\\n    JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \\\n    JSON_HEDLEY_PRAGMA(message msg) \\\n    JSON_HEDLEY_DIAGNOSTIC_POP\n#elif \\\n  JSON_HEDLEY_GCC_VERSION_CHECK(4,4,0) || \\\n  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)\n#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message msg)\n#elif JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0)\n#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(_CRI message msg)\n#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)\n#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))\n#elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,0,0)\n#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))\n#else\n#  define JSON_HEDLEY_MESSAGE(msg)\n#endif\n\n#if defined(JSON_HEDLEY_WARNING)\n    #undef JSON_HEDLEY_WARNING\n#endif\n#if JSON_HEDLEY_HAS_WARNING(\"-Wunknown-pragmas\")\n#  define JSON_HEDLEY_WARNING(msg) \\\n    JSON_HEDLEY_DIAGNOSTIC_PUSH \\\n    JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \\\n    JSON_HEDLEY_PRAGMA(clang warning msg) \\\n    JSON_HEDLEY_DIAGNOSTIC_POP\n#elif \\\n  JSON_HEDLEY_GCC_VERSION_CHECK(4,8,0) || \\\n  JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \\\n  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)\n#  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(GCC warning msg)\n#elif \\\n  JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0) || \\\n  JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)\n#  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(message(msg))\n#else\n#  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_MESSAGE(msg)\n#endif\n\n#if defined(JSON_HEDLEY_REQUIRE)\n    #undef JSON_HEDLEY_REQUIRE\n#endif\n#if defined(JSON_HEDLEY_REQUIRE_MSG)\n    #undef JSON_HEDLEY_REQUIRE_MSG\n#endif\n#if JSON_HEDLEY_HAS_ATTRIBUTE(diagnose_if)\n#  if JSON_HEDLEY_HAS_WARNING(\"-Wgcc-compat\")\n#    define JSON_HEDLEY_REQUIRE(expr) \\\n    JSON_HEDLEY_DIAGNOSTIC_PUSH \\\n    _Pragma(\"clang diagnostic ignored \\\"-Wgcc-compat\\\"\") \\\n    __attribute__((diagnose_if(!(expr), #expr, \"error\"))) \\\n    JSON_HEDLEY_DIAGNOSTIC_POP\n#    define JSON_HEDLEY_REQUIRE_MSG(expr,msg) \\\n    JSON_HEDLEY_DIAGNOSTIC_PUSH \\\n    _Pragma(\"clang diagnostic ignored \\\"-Wgcc-compat\\\"\") \\\n    __attribute__((diagnose_if(!(expr), msg, \"error\"))) \\\n    JSON_HEDLEY_DIAGNOSTIC_POP\n#  else\n#    define JSON_HEDLEY_REQUIRE(expr) __attribute__((diagnose_if(!(expr), #expr, \"error\")))\n#    define JSON_HEDLEY_REQUIRE_MSG(expr,msg) __attribute__((diagnose_if(!(expr), msg, \"error\")))\n#  endif\n#else\n#  define JSON_HEDLEY_REQUIRE(expr)\n#  define JSON_HEDLEY_REQUIRE_MSG(expr,msg)\n#endif\n\n#if defined(JSON_HEDLEY_FLAGS)\n    #undef JSON_HEDLEY_FLAGS\n#endif\n#if JSON_HEDLEY_HAS_ATTRIBUTE(flag_enum) && (!defined(__cplusplus) || JSON_HEDLEY_HAS_WARNING(\"-Wbitfield-enum-conversion\"))\n    #define JSON_HEDLEY_FLAGS __attribute__((__flag_enum__))\n#else\n    #define JSON_HEDLEY_FLAGS\n#endif\n\n#if defined(JSON_HEDLEY_FLAGS_CAST)\n    #undef JSON_HEDLEY_FLAGS_CAST\n#endif\n#if JSON_HEDLEY_INTEL_VERSION_CHECK(19,0,0)\n#  define JSON_HEDLEY_FLAGS_CAST(T, expr) (__extension__ ({ \\\n        JSON_HEDLEY_DIAGNOSTIC_PUSH \\\n        _Pragma(\"warning(disable:188)\") \\\n        ((T) (expr)); \\\n        JSON_HEDLEY_DIAGNOSTIC_POP \\\n    }))\n#else\n#  define JSON_HEDLEY_FLAGS_CAST(T, expr) JSON_HEDLEY_STATIC_CAST(T, expr)\n#endif\n\n#if defined(JSON_HEDLEY_EMPTY_BASES)\n    #undef JSON_HEDLEY_EMPTY_BASES\n#endif\n#if \\\n    (JSON_HEDLEY_MSVC_VERSION_CHECK(19,0,23918) && !JSON_HEDLEY_MSVC_VERSION_CHECK(20,0,0)) || \\\n    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)\n    #define JSON_HEDLEY_EMPTY_BASES __declspec(empty_bases)\n#else\n    #define JSON_HEDLEY_EMPTY_BASES\n#endif\n\n/* Remaining macros are deprecated. */\n\n#if defined(JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK)\n    #undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK\n#endif\n#if defined(__clang__)\n    #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) (0)\n#else\n    #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)\n#endif\n\n#if defined(JSON_HEDLEY_CLANG_HAS_ATTRIBUTE)\n    #undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE\n#endif\n#define JSON_HEDLEY_CLANG_HAS_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)\n\n#if defined(JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE)\n    #undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE\n#endif\n#define JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute)\n\n#if defined(JSON_HEDLEY_CLANG_HAS_BUILTIN)\n    #undef JSON_HEDLEY_CLANG_HAS_BUILTIN\n#endif\n#define JSON_HEDLEY_CLANG_HAS_BUILTIN(builtin) JSON_HEDLEY_HAS_BUILTIN(builtin)\n\n#if defined(JSON_HEDLEY_CLANG_HAS_FEATURE)\n    #undef JSON_HEDLEY_CLANG_HAS_FEATURE\n#endif\n#define JSON_HEDLEY_CLANG_HAS_FEATURE(feature) JSON_HEDLEY_HAS_FEATURE(feature)\n\n#if defined(JSON_HEDLEY_CLANG_HAS_EXTENSION)\n    #undef JSON_HEDLEY_CLANG_HAS_EXTENSION\n#endif\n#define JSON_HEDLEY_CLANG_HAS_EXTENSION(extension) JSON_HEDLEY_HAS_EXTENSION(extension)\n\n#if defined(JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE)\n    #undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE\n#endif\n#define JSON_HEDLEY_CLANG_HAS_DECLSPEC_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute)\n\n#if defined(JSON_HEDLEY_CLANG_HAS_WARNING)\n    #undef JSON_HEDLEY_CLANG_HAS_WARNING\n#endif\n#define JSON_HEDLEY_CLANG_HAS_WARNING(warning) JSON_HEDLEY_HAS_WARNING(warning)\n\n#endif /* !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION < X) */\n\n// #include <nlohmann/detail/meta/detected.hpp>\n\n\n#include <type_traits>\n\n// #include <nlohmann/detail/meta/void_t.hpp>\n\n\nnamespace nlohmann\n{\nnamespace detail\n{\ntemplate<typename ...Ts> struct make_void\n{\n    using type = void;\n};\ntemplate<typename ...Ts> using void_t = typename make_void<Ts...>::type;\n} // namespace detail\n}  // namespace nlohmann\n\n\n// https://en.cppreference.com/w/cpp/experimental/is_detected\nnamespace nlohmann\n{\nnamespace detail\n{\nstruct nonesuch\n{\n    nonesuch() = delete;\n    ~nonesuch() = delete;\n    nonesuch(nonesuch const&) = delete;\n    nonesuch(nonesuch const&&) = delete;\n    void operator=(nonesuch const&) = delete;\n    void operator=(nonesuch&&) = delete;\n};\n\ntemplate<class Default,\n         class AlwaysVoid,\n         template<class...> class Op,\n         class... Args>\nstruct detector\n{\n    using value_t = std::false_type;\n    using type = Default;\n};\n\ntemplate<class Default, template<class...> class Op, class... Args>\nstruct detector<Default, void_t<Op<Args...>>, Op, Args...>\n{\n    using value_t = std::true_type;\n    using type = Op<Args...>;\n};\n\ntemplate<template<class...> class Op, class... Args>\nusing is_detected = typename detector<nonesuch, void, Op, Args...>::value_t;\n\ntemplate<template<class...> class Op, class... Args>\nstruct is_detected_lazy : is_detected<Op, Args...> { };\n\ntemplate<template<class...> class Op, class... Args>\nusing detected_t = typename detector<nonesuch, void, Op, Args...>::type;\n\ntemplate<class Default, template<class...> class Op, class... Args>\nusing detected_or = detector<Default, void, Op, Args...>;\n\ntemplate<class Default, template<class...> class Op, class... Args>\nusing detected_or_t = typename detected_or<Default, Op, Args...>::type;\n\ntemplate<class Expected, template<class...> class Op, class... Args>\nusing is_detected_exact = std::is_same<Expected, detected_t<Op, Args...>>;\n\ntemplate<class To, template<class...> class Op, class... Args>\nusing is_detected_convertible =\n    std::is_convertible<detected_t<Op, Args...>, To>;\n}  // namespace detail\n}  // namespace nlohmann\n\n\n// This file contains all internal macro definitions\n// You MUST include macro_unscope.hpp at the end of json.hpp to undef all of them\n\n// exclude unsupported compilers\n#if !defined(JSON_SKIP_UNSUPPORTED_COMPILER_CHECK)\n    #if defined(__clang__)\n        #if (__clang_major__ * 10000 + __clang_minor__ * 100 + __clang_patchlevel__) < 30400\n            #error \"unsupported Clang version - see https://github.com/nlohmann/json#supported-compilers\"\n        #endif\n    #elif defined(__GNUC__) && !(defined(__ICC) || defined(__INTEL_COMPILER))\n        #if (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) < 40800\n            #error \"unsupported GCC version - see https://github.com/nlohmann/json#supported-compilers\"\n        #endif\n    #endif\n#endif\n\n// C++ language standard detection\n// if the user manually specified the used c++ version this is skipped\n#if !defined(JSON_HAS_CPP_20) && !defined(JSON_HAS_CPP_17) && !defined(JSON_HAS_CPP_14) && !defined(JSON_HAS_CPP_11)\n    #if (defined(__cplusplus) && __cplusplus >= 202002L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 202002L)\n        #define JSON_HAS_CPP_20\n        #define JSON_HAS_CPP_17\n        #define JSON_HAS_CPP_14\n    #elif (defined(__cplusplus) && __cplusplus >= 201703L) || (defined(_HAS_CXX17) && _HAS_CXX17 == 1) // fix for issue #464\n        #define JSON_HAS_CPP_17\n        #define JSON_HAS_CPP_14\n    #elif (defined(__cplusplus) && __cplusplus >= 201402L) || (defined(_HAS_CXX14) && _HAS_CXX14 == 1)\n        #define JSON_HAS_CPP_14\n    #endif\n    // the cpp 11 flag is always specified because it is the minimal required version\n    #define JSON_HAS_CPP_11\n#endif\n\n#if !defined(JSON_HAS_FILESYSTEM) && !defined(JSON_HAS_EXPERIMENTAL_FILESYSTEM)\n    #ifdef JSON_HAS_CPP_17\n        #if defined(__cpp_lib_filesystem)\n            #define JSON_HAS_FILESYSTEM 1\n        #elif defined(__cpp_lib_experimental_filesystem)\n            #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 1\n        #elif !defined(__has_include)\n            #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 1\n        #elif __has_include(<filesystem>)\n            #define JSON_HAS_FILESYSTEM 1\n        #elif __has_include(<experimental/filesystem>)\n            #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 1\n        #endif\n\n        // std::filesystem does not work on MinGW GCC 8: https://sourceforge.net/p/mingw-w64/bugs/737/\n        #if defined(__MINGW32__) && defined(__GNUC__) && __GNUC__ == 8\n            #undef JSON_HAS_FILESYSTEM\n            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM\n        #endif\n\n        // no filesystem support before GCC 8: https://en.cppreference.com/w/cpp/compiler_support\n        #if defined(__GNUC__) && !defined(__clang__) && __GNUC__ < 8\n            #undef JSON_HAS_FILESYSTEM\n            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM\n        #endif\n\n        // no filesystem support before Clang 7: https://en.cppreference.com/w/cpp/compiler_support\n        #if defined(__clang_major__) && __clang_major__ < 7\n            #undef JSON_HAS_FILESYSTEM\n            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM\n        #endif\n\n        // no filesystem support before MSVC 19.14: https://en.cppreference.com/w/cpp/compiler_support\n        #if defined(_MSC_VER) && _MSC_VER < 1940\n            #undef JSON_HAS_FILESYSTEM\n            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM\n        #endif\n\n        // no filesystem support before iOS 13\n        #if defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED < 130000\n            #undef JSON_HAS_FILESYSTEM\n            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM\n        #endif\n\n        // no filesystem support before macOS Catalina\n        #if defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED < 101500\n            #undef JSON_HAS_FILESYSTEM\n            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM\n        #endif\n    #endif\n#endif\n\n#ifndef JSON_HAS_EXPERIMENTAL_FILESYSTEM\n    #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 0\n#endif\n\n#ifndef JSON_HAS_FILESYSTEM\n    #define JSON_HAS_FILESYSTEM 0\n#endif\n\n// disable documentation warnings on clang\n#if defined(__clang__)\n    #pragma clang diagnostic push\n    #pragma clang diagnostic ignored \"-Wdocumentation\"\n    #pragma clang diagnostic ignored \"-Wdocumentation-unknown-command\"\n#endif\n\n// allow disabling exceptions\n#if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)) && !defined(JSON_NOEXCEPTION)\n    #define JSON_THROW(exception) throw exception\n    #define JSON_TRY try\n    #define JSON_CATCH(exception) catch(exception)\n    #define JSON_INTERNAL_CATCH(exception) catch(exception)\n#else\n    #include <cstdlib>\n    #define JSON_THROW(exception) std::abort()\n    #define JSON_TRY if(true)\n    #define JSON_CATCH(exception) if(false)\n    #define JSON_INTERNAL_CATCH(exception) if(false)\n#endif\n\n// override exception macros\n#if defined(JSON_THROW_USER)\n    #undef JSON_THROW\n    #define JSON_THROW JSON_THROW_USER\n#endif\n#if defined(JSON_TRY_USER)\n    #undef JSON_TRY\n    #define JSON_TRY JSON_TRY_USER\n#endif\n#if defined(JSON_CATCH_USER)\n    #undef JSON_CATCH\n    #define JSON_CATCH JSON_CATCH_USER\n    #undef JSON_INTERNAL_CATCH\n    #define JSON_INTERNAL_CATCH JSON_CATCH_USER\n#endif\n#if defined(JSON_INTERNAL_CATCH_USER)\n    #undef JSON_INTERNAL_CATCH\n    #define JSON_INTERNAL_CATCH JSON_INTERNAL_CATCH_USER\n#endif\n\n// allow overriding assert\n#if !defined(JSON_ASSERT)\n    #include <cassert> // assert\n    #define JSON_ASSERT(x) assert(x)\n#endif\n\n// allow to access some private functions (needed by the test suite)\n#if defined(JSON_TESTS_PRIVATE)\n    #define JSON_PRIVATE_UNLESS_TESTED public\n#else\n    #define JSON_PRIVATE_UNLESS_TESTED private\n#endif\n\n/*!\n@brief macro to briefly define a mapping between an enum and JSON\n@def NLOHMANN_JSON_SERIALIZE_ENUM\n@since version 3.4.0\n*/\n#define NLOHMANN_JSON_SERIALIZE_ENUM(ENUM_TYPE, ...)                                            \\\n    template<typename BasicJsonType>                                                            \\\n    inline void to_json(BasicJsonType& j, const ENUM_TYPE& e)                                   \\\n    {                                                                                           \\\n        static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE \" must be an enum!\");          \\\n        static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                     \\\n        auto it = std::find_if(std::begin(m), std::end(m),                                      \\\n                               [e](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool  \\\n        {                                                                                       \\\n            return ej_pair.first == e;                                                          \\\n        });                                                                                     \\\n        j = ((it != std::end(m)) ? it : std::begin(m))->second;                                 \\\n    }                                                                                           \\\n    template<typename BasicJsonType>                                                            \\\n    inline void from_json(const BasicJsonType& j, ENUM_TYPE& e)                                 \\\n    {                                                                                           \\\n        static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE \" must be an enum!\");          \\\n        static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                     \\\n        auto it = std::find_if(std::begin(m), std::end(m),                                      \\\n                               [&j](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool \\\n        {                                                                                       \\\n            return ej_pair.second == j;                                                         \\\n        });                                                                                     \\\n        e = ((it != std::end(m)) ? it : std::begin(m))->first;                                  \\\n    }\n\n// Ugly macros to avoid uglier copy-paste when specializing basic_json. They\n// may be removed in the future once the class is split.\n\n#define NLOHMANN_BASIC_JSON_TPL_DECLARATION                                \\\n    template<template<typename, typename, typename...> class ObjectType,   \\\n             template<typename, typename...> class ArrayType,              \\\n             class StringType, class BooleanType, class NumberIntegerType, \\\n             class NumberUnsignedType, class NumberFloatType,              \\\n             template<typename> class AllocatorType,                       \\\n             template<typename, typename = void> class JSONSerializer,     \\\n             class BinaryType>\n\n#define NLOHMANN_BASIC_JSON_TPL                                            \\\n    basic_json<ObjectType, ArrayType, StringType, BooleanType,             \\\n    NumberIntegerType, NumberUnsignedType, NumberFloatType,                \\\n    AllocatorType, JSONSerializer, BinaryType>\n\n// Macros to simplify conversion from/to types\n\n#define NLOHMANN_JSON_EXPAND( x ) x\n#define NLOHMANN_JSON_GET_MACRO(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, NAME,...) NAME\n#define NLOHMANN_JSON_PASTE(...) NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_GET_MACRO(__VA_ARGS__, \\\n        NLOHMANN_JSON_PASTE64, \\\n        NLOHMANN_JSON_PASTE63, \\\n        NLOHMANN_JSON_PASTE62, \\\n        NLOHMANN_JSON_PASTE61, \\\n        NLOHMANN_JSON_PASTE60, \\\n        NLOHMANN_JSON_PASTE59, \\\n        NLOHMANN_JSON_PASTE58, \\\n        NLOHMANN_JSON_PASTE57, \\\n        NLOHMANN_JSON_PASTE56, \\\n        NLOHMANN_JSON_PASTE55, \\\n        NLOHMANN_JSON_PASTE54, \\\n        NLOHMANN_JSON_PASTE53, \\\n        NLOHMANN_JSON_PASTE52, \\\n        NLOHMANN_JSON_PASTE51, \\\n        NLOHMANN_JSON_PASTE50, \\\n        NLOHMANN_JSON_PASTE49, \\\n        NLOHMANN_JSON_PASTE48, \\\n        NLOHMANN_JSON_PASTE47, \\\n        NLOHMANN_JSON_PASTE46, \\\n        NLOHMANN_JSON_PASTE45, \\\n        NLOHMANN_JSON_PASTE44, \\\n        NLOHMANN_JSON_PASTE43, \\\n        NLOHMANN_JSON_PASTE42, \\\n        NLOHMANN_JSON_PASTE41, \\\n        NLOHMANN_JSON_PASTE40, \\\n        NLOHMANN_JSON_PASTE39, \\\n        NLOHMANN_JSON_PASTE38, \\\n        NLOHMANN_JSON_PASTE37, \\\n        NLOHMANN_JSON_PASTE36, \\\n        NLOHMANN_JSON_PASTE35, \\\n        NLOHMANN_JSON_PASTE34, \\\n        NLOHMANN_JSON_PASTE33, \\\n        NLOHMANN_JSON_PASTE32, \\\n        NLOHMANN_JSON_PASTE31, \\\n        NLOHMANN_JSON_PASTE30, \\\n        NLOHMANN_JSON_PASTE29, \\\n        NLOHMANN_JSON_PASTE28, \\\n        NLOHMANN_JSON_PASTE27, \\\n        NLOHMANN_JSON_PASTE26, \\\n        NLOHMANN_JSON_PASTE25, \\\n        NLOHMANN_JSON_PASTE24, \\\n        NLOHMANN_JSON_PASTE23, \\\n        NLOHMANN_JSON_PASTE22, \\\n        NLOHMANN_JSON_PASTE21, \\\n        NLOHMANN_JSON_PASTE20, \\\n        NLOHMANN_JSON_PASTE19, \\\n        NLOHMANN_JSON_PASTE18, \\\n        NLOHMANN_JSON_PASTE17, \\\n        NLOHMANN_JSON_PASTE16, \\\n        NLOHMANN_JSON_PASTE15, \\\n        NLOHMANN_JSON_PASTE14, \\\n        NLOHMANN_JSON_PASTE13, \\\n        NLOHMANN_JSON_PASTE12, \\\n        NLOHMANN_JSON_PASTE11, \\\n        NLOHMANN_JSON_PASTE10, \\\n        NLOHMANN_JSON_PASTE9, \\\n        NLOHMANN_JSON_PASTE8, \\\n        NLOHMANN_JSON_PASTE7, \\\n        NLOHMANN_JSON_PASTE6, \\\n        NLOHMANN_JSON_PASTE5, \\\n        NLOHMANN_JSON_PASTE4, \\\n        NLOHMANN_JSON_PASTE3, \\\n        NLOHMANN_JSON_PASTE2, \\\n        NLOHMANN_JSON_PASTE1)(__VA_ARGS__))\n#define NLOHMANN_JSON_PASTE2(func, v1) func(v1)\n#define NLOHMANN_JSON_PASTE3(func, v1, v2) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE2(func, v2)\n#define NLOHMANN_JSON_PASTE4(func, v1, v2, v3) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE3(func, v2, v3)\n#define NLOHMANN_JSON_PASTE5(func, v1, v2, v3, v4) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE4(func, v2, v3, v4)\n#define NLOHMANN_JSON_PASTE6(func, v1, v2, v3, v4, v5) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE5(func, v2, v3, v4, v5)\n#define NLOHMANN_JSON_PASTE7(func, v1, v2, v3, v4, v5, v6) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE6(func, v2, v3, v4, v5, v6)\n#define NLOHMANN_JSON_PASTE8(func, v1, v2, v3, v4, v5, v6, v7) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE7(func, v2, v3, v4, v5, v6, v7)\n#define NLOHMANN_JSON_PASTE9(func, v1, v2, v3, v4, v5, v6, v7, v8) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE8(func, v2, v3, v4, v5, v6, v7, v8)\n#define NLOHMANN_JSON_PASTE10(func, v1, v2, v3, v4, v5, v6, v7, v8, v9) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE9(func, v2, v3, v4, v5, v6, v7, v8, v9)\n#define NLOHMANN_JSON_PASTE11(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE10(func, v2, v3, v4, v5, v6, v7, v8, v9, v10)\n#define NLOHMANN_JSON_PASTE12(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE11(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)\n#define NLOHMANN_JSON_PASTE13(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE12(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12)\n#define NLOHMANN_JSON_PASTE14(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE13(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13)\n#define NLOHMANN_JSON_PASTE15(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE14(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14)\n#define NLOHMANN_JSON_PASTE16(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE15(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)\n#define NLOHMANN_JSON_PASTE17(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE16(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16)\n#define NLOHMANN_JSON_PASTE18(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE17(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17)\n#define NLOHMANN_JSON_PASTE19(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE18(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18)\n#define NLOHMANN_JSON_PASTE20(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE19(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19)\n#define NLOHMANN_JSON_PASTE21(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE20(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20)\n#define NLOHMANN_JSON_PASTE22(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE21(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21)\n#define NLOHMANN_JSON_PASTE23(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE22(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22)\n#define NLOHMANN_JSON_PASTE24(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE23(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23)\n#define NLOHMANN_JSON_PASTE25(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE24(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24)\n#define NLOHMANN_JSON_PASTE26(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE25(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25)\n#define NLOHMANN_JSON_PASTE27(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE26(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26)\n#define NLOHMANN_JSON_PASTE28(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE27(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27)\n#define NLOHMANN_JSON_PASTE29(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE28(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28)\n#define NLOHMANN_JSON_PASTE30(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE29(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29)\n#define NLOHMANN_JSON_PASTE31(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE30(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30)\n#define NLOHMANN_JSON_PASTE32(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE31(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31)\n#define NLOHMANN_JSON_PASTE33(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE32(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32)\n#define NLOHMANN_JSON_PASTE34(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE33(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33)\n#define NLOHMANN_JSON_PASTE35(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE34(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34)\n#define NLOHMANN_JSON_PASTE36(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE35(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35)\n#define NLOHMANN_JSON_PASTE37(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE36(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36)\n#define NLOHMANN_JSON_PASTE38(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE37(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37)\n#define NLOHMANN_JSON_PASTE39(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE38(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38)\n#define NLOHMANN_JSON_PASTE40(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE39(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39)\n#define NLOHMANN_JSON_PASTE41(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE40(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40)\n#define NLOHMANN_JSON_PASTE42(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE41(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41)\n#define NLOHMANN_JSON_PASTE43(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE42(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42)\n#define NLOHMANN_JSON_PASTE44(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE43(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43)\n#define NLOHMANN_JSON_PASTE45(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE44(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44)\n#define NLOHMANN_JSON_PASTE46(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE45(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45)\n#define NLOHMANN_JSON_PASTE47(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE46(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46)\n#define NLOHMANN_JSON_PASTE48(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE47(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47)\n#define NLOHMANN_JSON_PASTE49(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE48(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48)\n#define NLOHMANN_JSON_PASTE50(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE49(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49)\n#define NLOHMANN_JSON_PASTE51(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE50(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50)\n#define NLOHMANN_JSON_PASTE52(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE51(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51)\n#define NLOHMANN_JSON_PASTE53(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE52(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52)\n#define NLOHMANN_JSON_PASTE54(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE53(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53)\n#define NLOHMANN_JSON_PASTE55(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE54(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54)\n#define NLOHMANN_JSON_PASTE56(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE55(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55)\n#define NLOHMANN_JSON_PASTE57(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE56(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56)\n#define NLOHMANN_JSON_PASTE58(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE57(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57)\n#define NLOHMANN_JSON_PASTE59(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE58(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58)\n#define NLOHMANN_JSON_PASTE60(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE59(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59)\n#define NLOHMANN_JSON_PASTE61(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE60(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60)\n#define NLOHMANN_JSON_PASTE62(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE61(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61)\n#define NLOHMANN_JSON_PASTE63(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE62(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62)\n#define NLOHMANN_JSON_PASTE64(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE63(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63)\n\n#define NLOHMANN_JSON_TO(v1) nlohmann_json_j[#v1] = nlohmann_json_t.v1;\n#define NLOHMANN_JSON_FROM(v1) nlohmann_json_j.at(#v1).get_to(nlohmann_json_t.v1);\n\n/*!\n@brief macro\n@def NLOHMANN_DEFINE_TYPE_INTRUSIVE\n@since version 3.9.0\n*/\n#define NLOHMANN_DEFINE_TYPE_INTRUSIVE(Type, ...)  \\\n    friend void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \\\n    friend void from_json(const nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }\n\n/*!\n@brief macro\n@def NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE\n@since version 3.9.0\n*/\n#define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(Type, ...)  \\\n    inline void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \\\n    inline void from_json(const nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }\n\n\n// inspired from https://stackoverflow.com/a/26745591\n// allows to call any std function as if (e.g. with begin):\n// using std::begin; begin(x);\n//\n// it allows using the detected idiom to retrieve the return type\n// of such an expression\n#define NLOHMANN_CAN_CALL_STD_FUNC_IMPL(std_name)                                 \\\n    namespace detail {                                                            \\\n    using std::std_name;                                                          \\\n    \\\n    template<typename... T>                                                       \\\n    using result_of_##std_name = decltype(std_name(std::declval<T>()...));        \\\n    }                                                                             \\\n    \\\n    namespace detail2 {                                                           \\\n    struct std_name##_tag                                                         \\\n    {                                                                             \\\n    };                                                                            \\\n    \\\n    template<typename... T>                                                       \\\n    std_name##_tag std_name(T&&...);                                              \\\n    \\\n    template<typename... T>                                                       \\\n    using result_of_##std_name = decltype(std_name(std::declval<T>()...));        \\\n    \\\n    template<typename... T>                                                       \\\n    struct would_call_std_##std_name                                              \\\n    {                                                                             \\\n        static constexpr auto const value = ::nlohmann::detail::                  \\\n                                            is_detected_exact<std_name##_tag, result_of_##std_name, T...>::value; \\\n    };                                                                            \\\n    } /* namespace detail2 */ \\\n    \\\n    template<typename... T>                                                       \\\n    struct would_call_std_##std_name : detail2::would_call_std_##std_name<T...>   \\\n    {                                                                             \\\n    }\n\n#ifndef JSON_USE_IMPLICIT_CONVERSIONS\n    #define JSON_USE_IMPLICIT_CONVERSIONS 1\n#endif\n\n#if JSON_USE_IMPLICIT_CONVERSIONS\n    #define JSON_EXPLICIT\n#else\n    #define JSON_EXPLICIT explicit\n#endif\n\n#ifndef JSON_DIAGNOSTICS\n    #define JSON_DIAGNOSTICS 0\n#endif\n\n\nnamespace nlohmann\n{\nnamespace detail\n{\n\n/*!\n@brief replace all occurrences of a substring by another string\n\n@param[in,out] s  the string to manipulate; changed so that all\n               occurrences of @a f are replaced with @a t\n@param[in]     f  the substring to replace with @a t\n@param[in]     t  the string to replace @a f\n\n@pre The search string @a f must not be empty. **This precondition is\nenforced with an assertion.**\n\n@since version 2.0.0\n*/\ninline void replace_substring(std::string& s, const std::string& f,\n                              const std::string& t)\n{\n    JSON_ASSERT(!f.empty());\n    for (auto pos = s.find(f);                // find first occurrence of f\n            pos != std::string::npos;         // make sure f was found\n            s.replace(pos, f.size(), t),      // replace with t, and\n            pos = s.find(f, pos + t.size()))  // find next occurrence of f\n    {}\n}\n\n/*!\n * @brief string escaping as described in RFC 6901 (Sect. 4)\n * @param[in] s string to escape\n * @return    escaped string\n *\n * Note the order of escaping \"~\" to \"~0\" and \"/\" to \"~1\" is important.\n */\ninline std::string escape(std::string s)\n{\n    replace_substring(s, \"~\", \"~0\");\n    replace_substring(s, \"/\", \"~1\");\n    return s;\n}\n\n/*!\n * @brief string unescaping as described in RFC 6901 (Sect. 4)\n * @param[in] s string to unescape\n * @return    unescaped string\n *\n * Note the order of escaping \"~1\" to \"/\" and \"~0\" to \"~\" is important.\n */\nstatic void unescape(std::string& s)\n{\n    replace_substring(s, \"~1\", \"/\");\n    replace_substring(s, \"~0\", \"~\");\n}\n\n} // namespace detail\n} // namespace nlohmann\n\n// #include <nlohmann/detail/input/position_t.hpp>\n\n\n#include <cstddef> // size_t\n\nnamespace nlohmann\n{\nnamespace detail\n{\n/// struct to capture the start position of the current token\nstruct position_t\n{\n    /// the total number of characters read\n    std::size_t chars_read_total = 0;\n    /// the number of characters read in the current line\n    std::size_t chars_read_current_line = 0;\n    /// the number of lines read\n    std::size_t lines_read = 0;\n\n    /// conversion to size_t to preserve SAX interface\n    constexpr operator size_t() const\n    {\n        return chars_read_total;\n    }\n};\n\n} // namespace detail\n} // namespace nlohmann\n\n// #include <nlohmann/detail/macro_scope.hpp>\n\n\nnamespace nlohmann\n{\nnamespace detail\n{\n////////////////\n// exceptions //\n////////////////\n\n/// @brief general exception of the @ref basic_json class\n/// @sa https://json.nlohmann.me/api/basic_json/exception/\nclass exception : public std::exception\n{\n  public:\n    /// returns the explanatory string\n    const char* what() const noexcept override\n    {\n        return m.what();\n    }\n\n    /// the id of the exception\n    const int id; // NOLINT(cppcoreguidelines-non-private-member-variables-in-classes)\n\n  protected:\n    JSON_HEDLEY_NON_NULL(3)\n    exception(int id_, const char* what_arg) : id(id_), m(what_arg) {} // NOLINT(bugprone-throw-keyword-missing)\n\n    static std::string name(const std::string& ename, int id_)\n    {\n        return \"[json.exception.\" + ename + \".\" + std::to_string(id_) + \"] \";\n    }\n\n    template<typename BasicJsonType>\n    static std::string diagnostics(const BasicJsonType& leaf_element)\n    {\n#if JSON_DIAGNOSTICS\n        std::vector<std::string> tokens;\n        for (const auto* current = &leaf_element; current->m_parent != nullptr; current = current->m_parent)\n        {\n            switch (current->m_parent->type())\n            {\n                case value_t::array:\n                {\n                    for (std::size_t i = 0; i < current->m_parent->m_value.array->size(); ++i)\n                    {\n                        if (&current->m_parent->m_value.array->operator[](i) == current)\n                        {\n                            tokens.emplace_back(std::to_string(i));\n                            break;\n                        }\n                    }\n                    break;\n                }\n\n                case value_t::object:\n                {\n                    for (const auto& element : *current->m_parent->m_value.object)\n                    {\n                        if (&element.second == current)\n                        {\n                            tokens.emplace_back(element.first.c_str());\n                            break;\n                        }\n                    }\n                    break;\n                }\n\n                case value_t::null: // LCOV_EXCL_LINE\n                case value_t::string: // LCOV_EXCL_LINE\n                case value_t::boolean: // LCOV_EXCL_LINE\n                case value_t::number_integer: // LCOV_EXCL_LINE\n                case value_t::number_unsigned: // LCOV_EXCL_LINE\n                case value_t::number_float: // LCOV_EXCL_LINE\n                case value_t::binary: // LCOV_EXCL_LINE\n                case value_t::discarded: // LCOV_EXCL_LINE\n                default:   // LCOV_EXCL_LINE\n                    break; // LCOV_EXCL_LINE\n            }\n        }\n\n        if (tokens.empty())\n        {\n            return \"\";\n        }\n\n        return \"(\" + std::accumulate(tokens.rbegin(), tokens.rend(), std::string{},\n                                     [](const std::string & a, const std::string & b)\n        {\n            return a + \"/\" + detail::escape(b);\n        }) + \") \";\n#else\n        static_cast<void>(leaf_element);\n        return \"\";\n#endif\n    }\n\n  private:\n    /// an exception object as storage for error messages\n    std::runtime_error m;\n};\n\n/// @brief exception indicating a parse error\n/// @sa https://json.nlohmann.me/api/basic_json/parse_error/\nclass parse_error : public exception\n{\n  public:\n    /*!\n    @brief create a parse error exception\n    @param[in] id_       the id of the exception\n    @param[in] pos       the position where the error occurred (or with\n                         chars_read_total=0 if the position cannot be\n                         determined)\n    @param[in] what_arg  the explanatory string\n    @return parse_error object\n    */\n    template<typename BasicJsonType>\n    static parse_error create(int id_, const position_t& pos, const std::string& what_arg, const BasicJsonType& context)\n    {\n        std::string w = exception::name(\"parse_error\", id_) + \"parse error\" +\n                        position_string(pos) + \": \" + exception::diagnostics(context) + what_arg;\n        return {id_, pos.chars_read_total, w.c_str()};\n    }\n\n    template<typename BasicJsonType>\n    static parse_error create(int id_, std::size_t byte_, const std::string& what_arg, const BasicJsonType& context)\n    {\n        std::string w = exception::name(\"parse_error\", id_) + \"parse error\" +\n                        (byte_ != 0 ? (\" at byte \" + std::to_string(byte_)) : \"\") +\n                        \": \" + exception::diagnostics(context) + what_arg;\n        return {id_, byte_, w.c_str()};\n    }\n\n    /*!\n    @brief byte index of the parse error\n\n    The byte index of the last read character in the input file.\n\n    @note For an input with n bytes, 1 is the index of the first character and\n          n+1 is the index of the terminating null byte or the end of file.\n          This also holds true when reading a byte vector (CBOR or MessagePack).\n    */\n    const std::size_t byte;\n\n  private:\n    parse_error(int id_, std::size_t byte_, const char* what_arg)\n        : exception(id_, what_arg), byte(byte_) {}\n\n    static std::string position_string(const position_t& pos)\n    {\n        return \" at line \" + std::to_string(pos.lines_read + 1) +\n               \", column \" + std::to_string(pos.chars_read_current_line);\n    }\n};\n\n/// @brief exception indicating errors with iterators\n/// @sa https://json.nlohmann.me/api/basic_json/invalid_iterator/\nclass invalid_iterator : public exception\n{\n  public:\n    template<typename BasicJsonType>\n    static invalid_iterator create(int id_, const std::string& what_arg, const BasicJsonType& context)\n    {\n        std::string w = exception::name(\"invalid_iterator\", id_) + exception::diagnostics(context) + what_arg;\n        return {id_, w.c_str()};\n    }\n\n  private:\n    JSON_HEDLEY_NON_NULL(3)\n    invalid_iterator(int id_, const char* what_arg)\n        : exception(id_, what_arg) {}\n};\n\n/// @brief exception indicating executing a member function with a wrong type\n/// @sa https://json.nlohmann.me/api/basic_json/type_error/\nclass type_error : public exception\n{\n  public:\n    template<typename BasicJsonType>\n    static type_error create(int id_, const std::string& what_arg, const BasicJsonType& context)\n    {\n        std::string w = exception::name(\"type_error\", id_) + exception::diagnostics(context) + what_arg;\n        return {id_, w.c_str()};\n    }\n\n  private:\n    JSON_HEDLEY_NON_NULL(3)\n    type_error(int id_, const char* what_arg) : exception(id_, what_arg) {}\n};\n\n/// @brief exception indicating access out of the defined range\n/// @sa https://json.nlohmann.me/api/basic_json/out_of_range/\nclass out_of_range : public exception\n{\n  public:\n    template<typename BasicJsonType>\n    static out_of_range create(int id_, const std::string& what_arg, const BasicJsonType& context)\n    {\n        std::string w = exception::name(\"out_of_range\", id_) + exception::diagnostics(context) + what_arg;\n        return {id_, w.c_str()};\n    }\n\n  private:\n    JSON_HEDLEY_NON_NULL(3)\n    out_of_range(int id_, const char* what_arg) : exception(id_, what_arg) {}\n};\n\n/// @brief exception indicating other library errors\n/// @sa https://json.nlohmann.me/api/basic_json/other_error/\nclass other_error : public exception\n{\n  public:\n    template<typename BasicJsonType>\n    static other_error create(int id_, const std::string& what_arg, const BasicJsonType& context)\n    {\n        std::string w = exception::name(\"other_error\", id_) + exception::diagnostics(context) + what_arg;\n        return {id_, w.c_str()};\n    }\n\n  private:\n    JSON_HEDLEY_NON_NULL(3)\n    other_error(int id_, const char* what_arg) : exception(id_, what_arg) {}\n};\n\n}  // namespace detail\n}  // namespace nlohmann\n\n// #include <nlohmann/detail/macro_scope.hpp>\n\n// #include <nlohmann/detail/meta/cpp_future.hpp>\n\n\n#include <cstddef> // size_t\n#include <type_traits> // conditional, enable_if, false_type, integral_constant, is_constructible, is_integral, is_same, remove_cv, remove_reference, true_type\n#include <utility> // index_sequence, make_index_sequence, index_sequence_for\n\n// #include <nlohmann/detail/macro_scope.hpp>\n\n\nnamespace nlohmann\n{\nnamespace detail\n{\n\ntemplate<typename T>\nusing uncvref_t = typename std::remove_cv<typename std::remove_reference<T>::type>::type;\n\n#ifdef JSON_HAS_CPP_14\n\n// the following utilities are natively available in C++14\nusing std::enable_if_t;\nusing std::index_sequence;\nusing std::make_index_sequence;\nusing std::index_sequence_for;\n\n#else\n\n// alias templates to reduce boilerplate\ntemplate<bool B, typename T = void>\nusing enable_if_t = typename std::enable_if<B, T>::type;\n\n// The following code is taken from https://github.com/abseil/abseil-cpp/blob/10cb35e459f5ecca5b2ff107635da0bfa41011b4/absl/utility/utility.h\n// which is part of Google Abseil (https://github.com/abseil/abseil-cpp), licensed under the Apache License 2.0.\n\n//// START OF CODE FROM GOOGLE ABSEIL\n\n// integer_sequence\n//\n// Class template representing a compile-time integer sequence. An instantiation\n// of `integer_sequence<T, Ints...>` has a sequence of integers encoded in its\n// type through its template arguments (which is a common need when\n// working with C++11 variadic templates). `absl::integer_sequence` is designed\n// to be a drop-in replacement for C++14's `std::integer_sequence`.\n//\n// Example:\n//\n//   template< class T, T... Ints >\n//   void user_function(integer_sequence<T, Ints...>);\n//\n//   int main()\n//   {\n//     // user_function's `T` will be deduced to `int` and `Ints...`\n//     // will be deduced to `0, 1, 2, 3, 4`.\n//     user_function(make_integer_sequence<int, 5>());\n//   }\ntemplate <typename T, T... Ints>\nstruct integer_sequence\n{\n    using value_type = T;\n    static constexpr std::size_t size() noexcept\n    {\n        return sizeof...(Ints);\n    }\n};\n\n// index_sequence\n//\n// A helper template for an `integer_sequence` of `size_t`,\n// `absl::index_sequence` is designed to be a drop-in replacement for C++14's\n// `std::index_sequence`.\ntemplate <size_t... Ints>\nusing index_sequence = integer_sequence<size_t, Ints...>;\n\nnamespace utility_internal\n{\n\ntemplate <typename Seq, size_t SeqSize, size_t Rem>\nstruct Extend;\n\n// Note that SeqSize == sizeof...(Ints). It's passed explicitly for efficiency.\ntemplate <typename T, T... Ints, size_t SeqSize>\nstruct Extend<integer_sequence<T, Ints...>, SeqSize, 0>\n{\n    using type = integer_sequence < T, Ints..., (Ints + SeqSize)... >;\n};\n\ntemplate <typename T, T... Ints, size_t SeqSize>\nstruct Extend<integer_sequence<T, Ints...>, SeqSize, 1>\n{\n    using type = integer_sequence < T, Ints..., (Ints + SeqSize)..., 2 * SeqSize >;\n};\n\n// Recursion helper for 'make_integer_sequence<T, N>'.\n// 'Gen<T, N>::type' is an alias for 'integer_sequence<T, 0, 1, ... N-1>'.\ntemplate <typename T, size_t N>\nstruct Gen\n{\n    using type =\n        typename Extend < typename Gen < T, N / 2 >::type, N / 2, N % 2 >::type;\n};\n\ntemplate <typename T>\nstruct Gen<T, 0>\n{\n    using type = integer_sequence<T>;\n};\n\n}  // namespace utility_internal\n\n// Compile-time sequences of integers\n\n// make_integer_sequence\n//\n// This template alias is equivalent to\n// `integer_sequence<int, 0, 1, ..., N-1>`, and is designed to be a drop-in\n// replacement for C++14's `std::make_integer_sequence`.\ntemplate <typename T, T N>\nusing make_integer_sequence = typename utility_internal::Gen<T, N>::type;\n\n// make_index_sequence\n//\n// This template alias is equivalent to `index_sequence<0, 1, ..., N-1>`,\n// and is designed to be a drop-in replacement for C++14's\n// `std::make_index_sequence`.\ntemplate <size_t N>\nusing make_index_sequence = make_integer_sequence<size_t, N>;\n\n// index_sequence_for\n//\n// Converts a typename pack into an index sequence of the same length, and\n// is designed to be a drop-in replacement for C++14's\n// `std::index_sequence_for()`\ntemplate <typename... Ts>\nusing index_sequence_for = make_index_sequence<sizeof...(Ts)>;\n\n//// END OF CODE FROM GOOGLE ABSEIL\n\n#endif\n\n// dispatch utility (taken from ranges-v3)\ntemplate<unsigned N> struct priority_tag : priority_tag < N - 1 > {};\ntemplate<> struct priority_tag<0> {};\n\n// taken from ranges-v3\ntemplate<typename T>\nstruct static_const\n{\n    static constexpr T value{};\n};\n\ntemplate<typename T>\nconstexpr T static_const<T>::value; // NOLINT(readability-redundant-declaration)\n\n}  // namespace detail\n}  // namespace nlohmann\n\n// #include <nlohmann/detail/meta/identity_tag.hpp>\n\n\nnamespace nlohmann\n{\nnamespace detail\n{\n// dispatching helper struct\ntemplate <class T> struct identity_tag {};\n}  // namespace detail\n}  // namespace nlohmann\n\n// #include <nlohmann/detail/meta/type_traits.hpp>\n\n\n#include <limits> // numeric_limits\n#include <type_traits> // false_type, is_constructible, is_integral, is_same, true_type\n#include <utility> // declval\n#include <tuple> // tuple\n\n// #include <nlohmann/detail/macro_scope.hpp>\n\n\n// #include <nlohmann/detail/iterators/iterator_traits.hpp>\n\n\n#include <iterator> // random_access_iterator_tag\n\n// #include <nlohmann/detail/meta/void_t.hpp>\n\n// #include <nlohmann/detail/meta/cpp_future.hpp>\n\n\nnamespace nlohmann\n{\nnamespace detail\n{\ntemplate<typename It, typename = void>\nstruct iterator_types {};\n\ntemplate<typename It>\nstruct iterator_types <\n    It,\n    void_t<typename It::difference_type, typename It::value_type, typename It::pointer,\n    typename It::reference, typename It::iterator_category >>\n{\n    using difference_type = typename It::difference_type;\n    using value_type = typename It::value_type;\n    using pointer = typename It::pointer;\n    using reference = typename It::reference;\n    using iterator_category = typename It::iterator_category;\n};\n\n// This is required as some compilers implement std::iterator_traits in a way that\n// doesn't work with SFINAE. See https://github.com/nlohmann/json/issues/1341.\ntemplate<typename T, typename = void>\nstruct iterator_traits\n{\n};\n\ntemplate<typename T>\nstruct iterator_traits < T, enable_if_t < !std::is_pointer<T>::value >>\n            : iterator_types<T>\n{\n};\n\ntemplate<typename T>\nstruct iterator_traits<T*, enable_if_t<std::is_object<T>::value>>\n{\n    using iterator_category = std::random_access_iterator_tag;\n    using value_type = T;\n    using difference_type = ptrdiff_t;\n    using pointer = T*;\n    using reference = T&;\n};\n} // namespace detail\n} // namespace nlohmann\n\n// #include <nlohmann/detail/meta/call_std/begin.hpp>\n\n\n// #include <nlohmann/detail/macro_scope.hpp>\n\n\nnamespace nlohmann\n{\nNLOHMANN_CAN_CALL_STD_FUNC_IMPL(begin);\n} // namespace nlohmann\n\n// #include <nlohmann/detail/meta/call_std/end.hpp>\n\n\n// #include <nlohmann/detail/macro_scope.hpp>\n\n\nnamespace nlohmann\n{\nNLOHMANN_CAN_CALL_STD_FUNC_IMPL(end);\n}  // namespace nlohmann\n\n// #include <nlohmann/detail/meta/cpp_future.hpp>\n\n// #include <nlohmann/detail/meta/detected.hpp>\n\n// #include <nlohmann/json_fwd.hpp>\n#ifndef INCLUDE_NLOHMANN_JSON_FWD_HPP_\n#define INCLUDE_NLOHMANN_JSON_FWD_HPP_\n\n#include <cstdint> // int64_t, uint64_t\n#include <map> // map\n#include <memory> // allocator\n#include <string> // string\n#include <vector> // vector\n\n/*!\n@brief namespace for Niels Lohmann\n@see https://github.com/nlohmann\n@since version 1.0.0\n*/\nnamespace nlohmann\n{\n/*!\n@brief default JSONSerializer template argument\n\nThis serializer ignores the template arguments and uses ADL\n([argument-dependent lookup](https://en.cppreference.com/w/cpp/language/adl))\nfor serialization.\n*/\ntemplate<typename T = void, typename SFINAE = void>\nstruct adl_serializer;\n\n/// a class to store JSON values\n/// @sa https://json.nlohmann.me/api/basic_json/\ntemplate<template<typename U, typename V, typename... Args> class ObjectType =\n         std::map,\n         template<typename U, typename... Args> class ArrayType = std::vector,\n         class StringType = std::string, class BooleanType = bool,\n         class NumberIntegerType = std::int64_t,\n         class NumberUnsignedType = std::uint64_t,\n         class NumberFloatType = double,\n         template<typename U> class AllocatorType = std::allocator,\n         template<typename T, typename SFINAE = void> class JSONSerializer =\n         adl_serializer,\n         class BinaryType = std::vector<std::uint8_t>>\nclass basic_json;\n\n/// @brief JSON Pointer defines a string syntax for identifying a specific value within a JSON document\n/// @sa https://json.nlohmann.me/api/json_pointer/\ntemplate<typename BasicJsonType>\nclass json_pointer;\n\n/*!\n@brief default specialization\n@sa https://json.nlohmann.me/api/json/\n*/\nusing json = basic_json<>;\n\n/// @brief a minimal map-like container that preserves insertion order\n/// @sa https://json.nlohmann.me/api/ordered_map/\ntemplate<class Key, class T, class IgnoredLess, class Allocator>\nstruct ordered_map;\n\n/// @brief specialization that maintains the insertion order of object keys\n/// @sa https://json.nlohmann.me/api/ordered_json/\nusing ordered_json = basic_json<nlohmann::ordered_map>;\n\n}  // namespace nlohmann\n\n#endif  // INCLUDE_NLOHMANN_JSON_FWD_HPP_\n\n\nnamespace nlohmann\n{\n/*!\n@brief detail namespace with internal helper functions\n\nThis namespace collects functions that should not be exposed,\nimplementations of some @ref basic_json methods, and meta-programming helpers.\n\n@since version 2.1.0\n*/\nnamespace detail\n{\n/////////////\n// helpers //\n/////////////\n\n// Note to maintainers:\n//\n// Every trait in this file expects a non CV-qualified type.\n// The only exceptions are in the 'aliases for detected' section\n// (i.e. those of the form: decltype(T::member_function(std::declval<T>())))\n//\n// In this case, T has to be properly CV-qualified to constraint the function arguments\n// (e.g. to_json(BasicJsonType&, const T&))\n\ntemplate<typename> struct is_basic_json : std::false_type {};\n\nNLOHMANN_BASIC_JSON_TPL_DECLARATION\nstruct is_basic_json<NLOHMANN_BASIC_JSON_TPL> : std::true_type {};\n\n//////////////////////\n// json_ref helpers //\n//////////////////////\n\ntemplate<typename>\nclass json_ref;\n\ntemplate<typename>\nstruct is_json_ref : std::false_type {};\n\ntemplate<typename T>\nstruct is_json_ref<json_ref<T>> : std::true_type {};\n\n//////////////////////////\n// aliases for detected //\n//////////////////////////\n\ntemplate<typename T>\nusing mapped_type_t = typename T::mapped_type;\n\ntemplate<typename T>\nusing key_type_t = typename T::key_type;\n\ntemplate<typename T>\nusing value_type_t = typename T::value_type;\n\ntemplate<typename T>\nusing difference_type_t = typename T::difference_type;\n\ntemplate<typename T>\nusing pointer_t = typename T::pointer;\n\ntemplate<typename T>\nusing reference_t = typename T::reference;\n\ntemplate<typename T>\nusing iterator_category_t = typename T::iterator_category;\n\ntemplate<typename T, typename... Args>\nusing to_json_function = decltype(T::to_json(std::declval<Args>()...));\n\ntemplate<typename T, typename... Args>\nusing from_json_function = decltype(T::from_json(std::declval<Args>()...));\n\ntemplate<typename T, typename U>\nusing get_template_function = decltype(std::declval<T>().template get<U>());\n\n// trait checking if JSONSerializer<T>::from_json(json const&, udt&) exists\ntemplate<typename BasicJsonType, typename T, typename = void>\nstruct has_from_json : std::false_type {};\n\n// trait checking if j.get<T> is valid\n// use this trait instead of std::is_constructible or std::is_convertible,\n// both rely on, or make use of implicit conversions, and thus fail when T\n// has several constructors/operator= (see https://github.com/nlohmann/json/issues/958)\ntemplate <typename BasicJsonType, typename T>\nstruct is_getable\n{\n    static constexpr bool value = is_detected<get_template_function, const BasicJsonType&, T>::value;\n};\n\ntemplate<typename BasicJsonType, typename T>\nstruct has_from_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>\n{\n    using serializer = typename BasicJsonType::template json_serializer<T, void>;\n\n    static constexpr bool value =\n        is_detected_exact<void, from_json_function, serializer,\n        const BasicJsonType&, T&>::value;\n};\n\n// This trait checks if JSONSerializer<T>::from_json(json const&) exists\n// this overload is used for non-default-constructible user-defined-types\ntemplate<typename BasicJsonType, typename T, typename = void>\nstruct has_non_default_from_json : std::false_type {};\n\ntemplate<typename BasicJsonType, typename T>\nstruct has_non_default_from_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>\n{\n    using serializer = typename BasicJsonType::template json_serializer<T, void>;\n\n    static constexpr bool value =\n        is_detected_exact<T, from_json_function, serializer,\n        const BasicJsonType&>::value;\n};\n\n// This trait checks if BasicJsonType::json_serializer<T>::to_json exists\n// Do not evaluate the trait when T is a basic_json type, to avoid template instantiation infinite recursion.\ntemplate<typename BasicJsonType, typename T, typename = void>\nstruct has_to_json : std::false_type {};\n\ntemplate<typename BasicJsonType, typename T>\nstruct has_to_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>\n{\n    using serializer = typename BasicJsonType::template json_serializer<T, void>;\n\n    static constexpr bool value =\n        is_detected_exact<void, to_json_function, serializer, BasicJsonType&,\n        T>::value;\n};\n\n\n///////////////////\n// is_ functions //\n///////////////////\n\n// https://en.cppreference.com/w/cpp/types/conjunction\ntemplate<class...> struct conjunction : std::true_type { };\ntemplate<class B1> struct conjunction<B1> : B1 { };\ntemplate<class B1, class... Bn>\nstruct conjunction<B1, Bn...>\n: std::conditional<bool(B1::value), conjunction<Bn...>, B1>::type {};\n\n// https://en.cppreference.com/w/cpp/types/negation\ntemplate<class B> struct negation : std::integral_constant < bool, !B::value > { };\n\n// Reimplementation of is_constructible and is_default_constructible, due to them being broken for\n// std::pair and std::tuple until LWG 2367 fix (see https://cplusplus.github.io/LWG/lwg-defects.html#2367).\n// This causes compile errors in e.g. clang 3.5 or gcc 4.9.\ntemplate <typename T>\nstruct is_default_constructible : std::is_default_constructible<T> {};\n\ntemplate <typename T1, typename T2>\nstruct is_default_constructible<std::pair<T1, T2>>\n            : conjunction<is_default_constructible<T1>, is_default_constructible<T2>> {};\n\ntemplate <typename T1, typename T2>\nstruct is_default_constructible<const std::pair<T1, T2>>\n            : conjunction<is_default_constructible<T1>, is_default_constructible<T2>> {};\n\ntemplate <typename... Ts>\nstruct is_default_constructible<std::tuple<Ts...>>\n            : conjunction<is_default_constructible<Ts>...> {};\n\ntemplate <typename... Ts>\nstruct is_default_constructible<const std::tuple<Ts...>>\n            : conjunction<is_default_constructible<Ts>...> {};\n\n\ntemplate <typename T, typename... Args>\nstruct is_constructible : std::is_constructible<T, Args...> {};\n\ntemplate <typename T1, typename T2>\nstruct is_constructible<std::pair<T1, T2>> : is_default_constructible<std::pair<T1, T2>> {};\n\ntemplate <typename T1, typename T2>\nstruct is_constructible<const std::pair<T1, T2>> : is_default_constructible<const std::pair<T1, T2>> {};\n\ntemplate <typename... Ts>\nstruct is_constructible<std::tuple<Ts...>> : is_default_constructible<std::tuple<Ts...>> {};\n\ntemplate <typename... Ts>\nstruct is_constructible<const std::tuple<Ts...>> : is_default_constructible<const std::tuple<Ts...>> {};\n\n\ntemplate<typename T, typename = void>\nstruct is_iterator_traits : std::false_type {};\n\ntemplate<typename T>\nstruct is_iterator_traits<iterator_traits<T>>\n{\n  private:\n    using traits = iterator_traits<T>;\n\n  public:\n    static constexpr auto value =\n        is_detected<value_type_t, traits>::value &&\n        is_detected<difference_type_t, traits>::value &&\n        is_detected<pointer_t, traits>::value &&\n        is_detected<iterator_category_t, traits>::value &&\n        is_detected<reference_t, traits>::value;\n};\n\ntemplate<typename T>\nstruct is_range\n{\n  private:\n    using t_ref = typename std::add_lvalue_reference<T>::type;\n\n    using iterator = detected_t<result_of_begin, t_ref>;\n    using sentinel = detected_t<result_of_end, t_ref>;\n\n    // to be 100% correct, it should use https://en.cppreference.com/w/cpp/iterator/input_or_output_iterator\n    // and https://en.cppreference.com/w/cpp/iterator/sentinel_for\n    // but reimplementing these would be too much work, as a lot of other concepts are used underneath\n    static constexpr auto is_iterator_begin =\n        is_iterator_traits<iterator_traits<iterator>>::value;\n\n  public:\n    static constexpr bool value = !std::is_same<iterator, nonesuch>::value && !std::is_same<sentinel, nonesuch>::value && is_iterator_begin;\n};\n\ntemplate<typename R>\nusing iterator_t = enable_if_t<is_range<R>::value, result_of_begin<decltype(std::declval<R&>())>>;\n\ntemplate<typename T>\nusing range_value_t = value_type_t<iterator_traits<iterator_t<T>>>;\n\n// The following implementation of is_complete_type is taken from\n// https://blogs.msdn.microsoft.com/vcblog/2015/12/02/partial-support-for-expression-sfinae-in-vs-2015-update-1/\n// and is written by Xiang Fan who agreed to using it in this library.\n\ntemplate<typename T, typename = void>\nstruct is_complete_type : std::false_type {};\n\ntemplate<typename T>\nstruct is_complete_type<T, decltype(void(sizeof(T)))> : std::true_type {};\n\ntemplate<typename BasicJsonType, typename CompatibleObjectType,\n         typename = void>\nstruct is_compatible_object_type_impl : std::false_type {};\n\ntemplate<typename BasicJsonType, typename CompatibleObjectType>\nstruct is_compatible_object_type_impl <\n    BasicJsonType, CompatibleObjectType,\n    enable_if_t < is_detected<mapped_type_t, CompatibleObjectType>::value&&\n    is_detected<key_type_t, CompatibleObjectType>::value >>\n{\n    using object_t = typename BasicJsonType::object_t;\n\n    // macOS's is_constructible does not play well with nonesuch...\n    static constexpr bool value =\n        is_constructible<typename object_t::key_type,\n        typename CompatibleObjectType::key_type>::value &&\n        is_constructible<typename object_t::mapped_type,\n        typename CompatibleObjectType::mapped_type>::value;\n};\n\ntemplate<typename BasicJsonType, typename CompatibleObjectType>\nstruct is_compatible_object_type\n    : is_compatible_object_type_impl<BasicJsonType, CompatibleObjectType> {};\n\ntemplate<typename BasicJsonType, typename ConstructibleObjectType,\n         typename = void>\nstruct is_constructible_object_type_impl : std::false_type {};\n\ntemplate<typename BasicJsonType, typename ConstructibleObjectType>\nstruct is_constructible_object_type_impl <\n    BasicJsonType, ConstructibleObjectType,\n    enable_if_t < is_detected<mapped_type_t, ConstructibleObjectType>::value&&\n    is_detected<key_type_t, ConstructibleObjectType>::value >>\n{\n    using object_t = typename BasicJsonType::object_t;\n\n    static constexpr bool value =\n        (is_default_constructible<ConstructibleObjectType>::value &&\n         (std::is_move_assignable<ConstructibleObjectType>::value ||\n          std::is_copy_assignable<ConstructibleObjectType>::value) &&\n         (is_constructible<typename ConstructibleObjectType::key_type,\n          typename object_t::key_type>::value &&\n          std::is_same <\n          typename object_t::mapped_type,\n          typename ConstructibleObjectType::mapped_type >::value)) ||\n        (has_from_json<BasicJsonType,\n         typename ConstructibleObjectType::mapped_type>::value ||\n         has_non_default_from_json <\n         BasicJsonType,\n         typename ConstructibleObjectType::mapped_type >::value);\n};\n\ntemplate<typename BasicJsonType, typename ConstructibleObjectType>\nstruct is_constructible_object_type\n    : is_constructible_object_type_impl<BasicJsonType,\n      ConstructibleObjectType> {};\n\ntemplate<typename BasicJsonType, typename CompatibleStringType>\nstruct is_compatible_string_type\n{\n    static constexpr auto value =\n        is_constructible<typename BasicJsonType::string_t, CompatibleStringType>::value;\n};\n\ntemplate<typename BasicJsonType, typename ConstructibleStringType>\nstruct is_constructible_string_type\n{\n    static constexpr auto value =\n        is_constructible<ConstructibleStringType,\n        typename BasicJsonType::string_t>::value;\n};\n\ntemplate<typename BasicJsonType, typename CompatibleArrayType, typename = void>\nstruct is_compatible_array_type_impl : std::false_type {};\n\ntemplate<typename BasicJsonType, typename CompatibleArrayType>\nstruct is_compatible_array_type_impl <\n    BasicJsonType, CompatibleArrayType,\n    enable_if_t <\n    is_detected<iterator_t, CompatibleArrayType>::value&&\n    is_iterator_traits<iterator_traits<detected_t<iterator_t, CompatibleArrayType>>>::value&&\n// special case for types like std::filesystem::path whose iterator's value_type are themselves\n// c.f. https://github.com/nlohmann/json/pull/3073\n    !std::is_same<CompatibleArrayType, detected_t<range_value_t, CompatibleArrayType>>::value >>\n{\n    static constexpr bool value =\n        is_constructible<BasicJsonType,\n        range_value_t<CompatibleArrayType>>::value;\n};\n\ntemplate<typename BasicJsonType, typename CompatibleArrayType>\nstruct is_compatible_array_type\n    : is_compatible_array_type_impl<BasicJsonType, CompatibleArrayType> {};\n\ntemplate<typename BasicJsonType, typename ConstructibleArrayType, typename = void>\nstruct is_constructible_array_type_impl : std::false_type {};\n\ntemplate<typename BasicJsonType, typename ConstructibleArrayType>\nstruct is_constructible_array_type_impl <\n    BasicJsonType, ConstructibleArrayType,\n    enable_if_t<std::is_same<ConstructibleArrayType,\n    typename BasicJsonType::value_type>::value >>\n            : std::true_type {};\n\ntemplate<typename BasicJsonType, typename ConstructibleArrayType>\nstruct is_constructible_array_type_impl <\n    BasicJsonType, ConstructibleArrayType,\n    enable_if_t < !std::is_same<ConstructibleArrayType,\n    typename BasicJsonType::value_type>::value&&\n    !is_compatible_string_type<BasicJsonType, ConstructibleArrayType>::value&&\n    is_default_constructible<ConstructibleArrayType>::value&&\n(std::is_move_assignable<ConstructibleArrayType>::value ||\n std::is_copy_assignable<ConstructibleArrayType>::value)&&\nis_detected<iterator_t, ConstructibleArrayType>::value&&\nis_iterator_traits<iterator_traits<detected_t<iterator_t, ConstructibleArrayType>>>::value&&\nis_detected<range_value_t, ConstructibleArrayType>::value&&\n// special case for types like std::filesystem::path whose iterator's value_type are themselves\n// c.f. https://github.com/nlohmann/json/pull/3073\n!std::is_same<ConstructibleArrayType, detected_t<range_value_t, ConstructibleArrayType>>::value&&\n        is_complete_type <\n        detected_t<range_value_t, ConstructibleArrayType >>::value >>\n{\n    using value_type = range_value_t<ConstructibleArrayType>;\n\n    static constexpr bool value =\n        std::is_same<value_type,\n        typename BasicJsonType::array_t::value_type>::value ||\n        has_from_json<BasicJsonType,\n        value_type>::value ||\n        has_non_default_from_json <\n        BasicJsonType,\n        value_type >::value;\n};\n\ntemplate<typename BasicJsonType, typename ConstructibleArrayType>\nstruct is_constructible_array_type\n    : is_constructible_array_type_impl<BasicJsonType, ConstructibleArrayType> {};\n\ntemplate<typename RealIntegerType, typename CompatibleNumberIntegerType,\n         typename = void>\nstruct is_compatible_integer_type_impl : std::false_type {};\n\ntemplate<typename RealIntegerType, typename CompatibleNumberIntegerType>\nstruct is_compatible_integer_type_impl <\n    RealIntegerType, CompatibleNumberIntegerType,\n    enable_if_t < std::is_integral<RealIntegerType>::value&&\n    std::is_integral<CompatibleNumberIntegerType>::value&&\n    !std::is_same<bool, CompatibleNumberIntegerType>::value >>\n{\n    // is there an assert somewhere on overflows?\n    using RealLimits = std::numeric_limits<RealIntegerType>;\n    using CompatibleLimits = std::numeric_limits<CompatibleNumberIntegerType>;\n\n    static constexpr auto value =\n        is_constructible<RealIntegerType,\n        CompatibleNumberIntegerType>::value &&\n        CompatibleLimits::is_integer &&\n        RealLimits::is_signed == CompatibleLimits::is_signed;\n};\n\ntemplate<typename RealIntegerType, typename CompatibleNumberIntegerType>\nstruct is_compatible_integer_type\n    : is_compatible_integer_type_impl<RealIntegerType,\n      CompatibleNumberIntegerType> {};\n\ntemplate<typename BasicJsonType, typename CompatibleType, typename = void>\nstruct is_compatible_type_impl: std::false_type {};\n\ntemplate<typename BasicJsonType, typename CompatibleType>\nstruct is_compatible_type_impl <\n    BasicJsonType, CompatibleType,\n    enable_if_t<is_complete_type<CompatibleType>::value >>\n{\n    static constexpr bool value =\n        has_to_json<BasicJsonType, CompatibleType>::value;\n};\n\ntemplate<typename BasicJsonType, typename CompatibleType>\nstruct is_compatible_type\n    : is_compatible_type_impl<BasicJsonType, CompatibleType> {};\n\ntemplate<typename T1, typename T2>\nstruct is_constructible_tuple : std::false_type {};\n\ntemplate<typename T1, typename... Args>\nstruct is_constructible_tuple<T1, std::tuple<Args...>> : conjunction<is_constructible<T1, Args>...> {};\n\n// a naive helper to check if a type is an ordered_map (exploits the fact that\n// ordered_map inherits capacity() from std::vector)\ntemplate <typename T>\nstruct is_ordered_map\n{\n    using one = char;\n\n    struct two\n    {\n        char x[2]; // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)\n    };\n\n    template <typename C> static one test( decltype(&C::capacity) ) ;\n    template <typename C> static two test(...);\n\n    enum { value = sizeof(test<T>(nullptr)) == sizeof(char) }; // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)\n};\n\n// to avoid useless casts (see https://github.com/nlohmann/json/issues/2893#issuecomment-889152324)\ntemplate < typename T, typename U, enable_if_t < !std::is_same<T, U>::value, int > = 0 >\nT conditional_static_cast(U value)\n{\n    return static_cast<T>(value);\n}\n\ntemplate<typename T, typename U, enable_if_t<std::is_same<T, U>::value, int> = 0>\nT conditional_static_cast(U value)\n{\n    return value;\n}\n\n}  // namespace detail\n}  // namespace nlohmann\n\n// #include <nlohmann/detail/value_t.hpp>\n\n\n#if JSON_HAS_EXPERIMENTAL_FILESYSTEM\n#include <experimental/filesystem>\nnamespace nlohmann::detail\n{\nnamespace std_fs = std::experimental::filesystem;\n} // namespace nlohmann::detail\n#elif JSON_HAS_FILESYSTEM\n#include <filesystem>\nnamespace nlohmann::detail\n{\nnamespace std_fs = std::filesystem;\n} // namespace nlohmann::detail\n#endif\n\nnamespace nlohmann\n{\nnamespace detail\n{\ntemplate<typename BasicJsonType>\nvoid from_json(const BasicJsonType& j, typename std::nullptr_t& n)\n{\n    if (JSON_HEDLEY_UNLIKELY(!j.is_null()))\n    {\n        JSON_THROW(type_error::create(302, \"type must be null, but is \" + std::string(j.type_name()), j));\n    }\n    n = nullptr;\n}\n\n// overloads for basic_json template parameters\ntemplate < typename BasicJsonType, typename ArithmeticType,\n           enable_if_t < std::is_arithmetic<ArithmeticType>::value&&\n                         !std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,\n                         int > = 0 >\nvoid get_arithmetic_value(const BasicJsonType& j, ArithmeticType& val)\n{\n    switch (static_cast<value_t>(j))\n    {\n        case value_t::number_unsigned:\n        {\n            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());\n            break;\n        }\n        case value_t::number_integer:\n        {\n            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());\n            break;\n        }\n        case value_t::number_float:\n        {\n            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());\n            break;\n        }\n\n        case value_t::null:\n        case value_t::object:\n        case value_t::array:\n        case value_t::string:\n        case value_t::boolean:\n        case value_t::binary:\n        case value_t::discarded:\n        default:\n            JSON_THROW(type_error::create(302, \"type must be number, but is \" + std::string(j.type_name()), j));\n    }\n}\n\ntemplate<typename BasicJsonType>\nvoid from_json(const BasicJsonType& j, typename BasicJsonType::boolean_t& b)\n{\n    if (JSON_HEDLEY_UNLIKELY(!j.is_boolean()))\n    {\n        JSON_THROW(type_error::create(302, \"type must be boolean, but is \" + std::string(j.type_name()), j));\n    }\n    b = *j.template get_ptr<const typename BasicJsonType::boolean_t*>();\n}\n\ntemplate<typename BasicJsonType>\nvoid from_json(const BasicJsonType& j, typename BasicJsonType::string_t& s)\n{\n    if (JSON_HEDLEY_UNLIKELY(!j.is_string()))\n    {\n        JSON_THROW(type_error::create(302, \"type must be string, but is \" + std::string(j.type_name()), j));\n    }\n    s = *j.template get_ptr<const typename BasicJsonType::string_t*>();\n}\n\ntemplate <\n    typename BasicJsonType, typename ConstructibleStringType,\n    enable_if_t <\n        is_constructible_string_type<BasicJsonType, ConstructibleStringType>::value&&\n        !std::is_same<typename BasicJsonType::string_t,\n                      ConstructibleStringType>::value,\n        int > = 0 >\nvoid from_json(const BasicJsonType& j, ConstructibleStringType& s)\n{\n    if (JSON_HEDLEY_UNLIKELY(!j.is_string()))\n    {\n        JSON_THROW(type_error::create(302, \"type must be string, but is \" + std::string(j.type_name()), j));\n    }\n\n    s = *j.template get_ptr<const typename BasicJsonType::string_t*>();\n}\n\ntemplate<typename BasicJsonType>\nvoid from_json(const BasicJsonType& j, typename BasicJsonType::number_float_t& val)\n{\n    get_arithmetic_value(j, val);\n}\n\ntemplate<typename BasicJsonType>\nvoid from_json(const BasicJsonType& j, typename BasicJsonType::number_unsigned_t& val)\n{\n    get_arithmetic_value(j, val);\n}\n\ntemplate<typename BasicJsonType>\nvoid from_json(const BasicJsonType& j, typename BasicJsonType::number_integer_t& val)\n{\n    get_arithmetic_value(j, val);\n}\n\ntemplate<typename BasicJsonType, typename EnumType,\n         enable_if_t<std::is_enum<EnumType>::value, int> = 0>\nvoid from_json(const BasicJsonType& j, EnumType& e)\n{\n    typename std::underlying_type<EnumType>::type val;\n    get_arithmetic_value(j, val);\n    e = static_cast<EnumType>(val);\n}\n\n// forward_list doesn't have an insert method\ntemplate<typename BasicJsonType, typename T, typename Allocator,\n         enable_if_t<is_getable<BasicJsonType, T>::value, int> = 0>\nvoid from_json(const BasicJsonType& j, std::forward_list<T, Allocator>& l)\n{\n    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))\n    {\n        JSON_THROW(type_error::create(302, \"type must be array, but is \" + std::string(j.type_name()), j));\n    }\n    l.clear();\n    std::transform(j.rbegin(), j.rend(),\n                   std::front_inserter(l), [](const BasicJsonType & i)\n    {\n        return i.template get<T>();\n    });\n}\n\n// valarray doesn't have an insert method\ntemplate<typename BasicJsonType, typename T,\n         enable_if_t<is_getable<BasicJsonType, T>::value, int> = 0>\nvoid from_json(const BasicJsonType& j, std::valarray<T>& l)\n{\n    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))\n    {\n        JSON_THROW(type_error::create(302, \"type must be array, but is \" + std::string(j.type_name()), j));\n    }\n    l.resize(j.size());\n    std::transform(j.begin(), j.end(), std::begin(l),\n                   [](const BasicJsonType & elem)\n    {\n        return elem.template get<T>();\n    });\n}\n\ntemplate<typename BasicJsonType, typename T, std::size_t N>\nauto from_json(const BasicJsonType& j, T (&arr)[N])  // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)\n-> decltype(j.template get<T>(), void())\n{\n    for (std::size_t i = 0; i < N; ++i)\n    {\n        arr[i] = j.at(i).template get<T>();\n    }\n}\n\ntemplate<typename BasicJsonType>\nvoid from_json_array_impl(const BasicJsonType& j, typename BasicJsonType::array_t& arr, priority_tag<3> /*unused*/)\n{\n    arr = *j.template get_ptr<const typename BasicJsonType::array_t*>();\n}\n\ntemplate<typename BasicJsonType, typename T, std::size_t N>\nauto from_json_array_impl(const BasicJsonType& j, std::array<T, N>& arr,\n                          priority_tag<2> /*unused*/)\n-> decltype(j.template get<T>(), void())\n{\n    for (std::size_t i = 0; i < N; ++i)\n    {\n        arr[i] = j.at(i).template get<T>();\n    }\n}\n\ntemplate<typename BasicJsonType, typename ConstructibleArrayType,\n         enable_if_t<\n             std::is_assignable<ConstructibleArrayType&, ConstructibleArrayType>::value,\n             int> = 0>\nauto from_json_array_impl(const BasicJsonType& j, ConstructibleArrayType& arr, priority_tag<1> /*unused*/)\n-> decltype(\n    arr.reserve(std::declval<typename ConstructibleArrayType::size_type>()),\n    j.template get<typename ConstructibleArrayType::value_type>(),\n    void())\n{\n    using std::end;\n\n    ConstructibleArrayType ret;\n    ret.reserve(j.size());\n    std::transform(j.begin(), j.end(),\n                   std::inserter(ret, end(ret)), [](const BasicJsonType & i)\n    {\n        // get<BasicJsonType>() returns *this, this won't call a from_json\n        // method when value_type is BasicJsonType\n        return i.template get<typename ConstructibleArrayType::value_type>();\n    });\n    arr = std::move(ret);\n}\n\ntemplate<typename BasicJsonType, typename ConstructibleArrayType,\n         enable_if_t<\n             std::is_assignable<ConstructibleArrayType&, ConstructibleArrayType>::value,\n             int> = 0>\nvoid from_json_array_impl(const BasicJsonType& j, ConstructibleArrayType& arr,\n                          priority_tag<0> /*unused*/)\n{\n    using std::end;\n\n    ConstructibleArrayType ret;\n    std::transform(\n        j.begin(), j.end(), std::inserter(ret, end(ret)),\n        [](const BasicJsonType & i)\n    {\n        // get<BasicJsonType>() returns *this, this won't call a from_json\n        // method when value_type is BasicJsonType\n        return i.template get<typename ConstructibleArrayType::value_type>();\n    });\n    arr = std::move(ret);\n}\n\ntemplate < typename BasicJsonType, typename ConstructibleArrayType,\n           enable_if_t <\n               is_constructible_array_type<BasicJsonType, ConstructibleArrayType>::value&&\n               !is_constructible_object_type<BasicJsonType, ConstructibleArrayType>::value&&\n               !is_constructible_string_type<BasicJsonType, ConstructibleArrayType>::value&&\n               !std::is_same<ConstructibleArrayType, typename BasicJsonType::binary_t>::value&&\n               !is_basic_json<ConstructibleArrayType>::value,\n               int > = 0 >\nauto from_json(const BasicJsonType& j, ConstructibleArrayType& arr)\n-> decltype(from_json_array_impl(j, arr, priority_tag<3> {}),\nj.template get<typename ConstructibleArrayType::value_type>(),\nvoid())\n{\n    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))\n    {\n        JSON_THROW(type_error::create(302, \"type must be array, but is \" + std::string(j.type_name()), j));\n    }\n\n    from_json_array_impl(j, arr, priority_tag<3> {});\n}\n\ntemplate < typename BasicJsonType, typename T, std::size_t... Idx >\nstd::array<T, sizeof...(Idx)> from_json_inplace_array_impl(BasicJsonType&& j,\n        identity_tag<std::array<T, sizeof...(Idx)>> /*unused*/, index_sequence<Idx...> /*unused*/)\n{\n    return { { std::forward<BasicJsonType>(j).at(Idx).template get<T>()... } };\n}\n\ntemplate < typename BasicJsonType, typename T, std::size_t N >\nauto from_json(BasicJsonType&& j, identity_tag<std::array<T, N>> tag)\n-> decltype(from_json_inplace_array_impl(std::forward<BasicJsonType>(j), tag, make_index_sequence<N> {}))\n{\n    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))\n    {\n        JSON_THROW(type_error::create(302, \"type must be array, but is \" + std::string(j.type_name()), j));\n    }\n\n    return from_json_inplace_array_impl(std::forward<BasicJsonType>(j), tag, make_index_sequence<N> {});\n}\n\ntemplate<typename BasicJsonType>\nvoid from_json(const BasicJsonType& j, typename BasicJsonType::binary_t& bin)\n{\n    if (JSON_HEDLEY_UNLIKELY(!j.is_binary()))\n    {\n        JSON_THROW(type_error::create(302, \"type must be binary, but is \" + std::string(j.type_name()), j));\n    }\n\n    bin = *j.template get_ptr<const typename BasicJsonType::binary_t*>();\n}\n\ntemplate<typename BasicJsonType, typename ConstructibleObjectType,\n         enable_if_t<is_constructible_object_type<BasicJsonType, ConstructibleObjectType>::value, int> = 0>\nvoid from_json(const BasicJsonType& j, ConstructibleObjectType& obj)\n{\n    if (JSON_HEDLEY_UNLIKELY(!j.is_object()))\n    {\n        JSON_THROW(type_error::create(302, \"type must be object, but is \" + std::string(j.type_name()), j));\n    }\n\n    ConstructibleObjectType ret;\n    const auto* inner_object = j.template get_ptr<const typename BasicJsonType::object_t*>();\n    using value_type = typename ConstructibleObjectType::value_type;\n    std::transform(\n        inner_object->begin(), inner_object->end(),\n        std::inserter(ret, ret.begin()),\n        [](typename BasicJsonType::object_t::value_type const & p)\n    {\n        return value_type(p.first, p.second.template get<typename ConstructibleObjectType::mapped_type>());\n    });\n    obj = std::move(ret);\n}\n\n// overload for arithmetic types, not chosen for basic_json template arguments\n// (BooleanType, etc..); note: Is it really necessary to provide explicit\n// overloads for boolean_t etc. in case of a custom BooleanType which is not\n// an arithmetic type?\ntemplate < typename BasicJsonType, typename ArithmeticType,\n           enable_if_t <\n               std::is_arithmetic<ArithmeticType>::value&&\n               !std::is_same<ArithmeticType, typename BasicJsonType::number_unsigned_t>::value&&\n               !std::is_same<ArithmeticType, typename BasicJsonType::number_integer_t>::value&&\n               !std::is_same<ArithmeticType, typename BasicJsonType::number_float_t>::value&&\n               !std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,\n               int > = 0 >\nvoid from_json(const BasicJsonType& j, ArithmeticType& val)\n{\n    switch (static_cast<value_t>(j))\n    {\n        case value_t::number_unsigned:\n        {\n            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());\n            break;\n        }\n        case value_t::number_integer:\n        {\n            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());\n            break;\n        }\n        case value_t::number_float:\n        {\n            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());\n            break;\n        }\n        case value_t::boolean:\n        {\n            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::boolean_t*>());\n            break;\n        }\n\n        case value_t::null:\n        case value_t::object:\n        case value_t::array:\n        case value_t::string:\n        case value_t::binary:\n        case value_t::discarded:\n        default:\n            JSON_THROW(type_error::create(302, \"type must be number, but is \" + std::string(j.type_name()), j));\n    }\n}\n\ntemplate<typename BasicJsonType, typename... Args, std::size_t... Idx>\nstd::tuple<Args...> from_json_tuple_impl_base(BasicJsonType&& j, index_sequence<Idx...> /*unused*/)\n{\n    return std::make_tuple(std::forward<BasicJsonType>(j).at(Idx).template get<Args>()...);\n}\n\ntemplate < typename BasicJsonType, class A1, class A2 >\nstd::pair<A1, A2> from_json_tuple_impl(BasicJsonType&& j, identity_tag<std::pair<A1, A2>> /*unused*/, priority_tag<0> /*unused*/)\n{\n    return {std::forward<BasicJsonType>(j).at(0).template get<A1>(),\n            std::forward<BasicJsonType>(j).at(1).template get<A2>()};\n}\n\ntemplate<typename BasicJsonType, typename A1, typename A2>\nvoid from_json_tuple_impl(BasicJsonType&& j, std::pair<A1, A2>& p, priority_tag<1> /*unused*/)\n{\n    p = from_json_tuple_impl(std::forward<BasicJsonType>(j), identity_tag<std::pair<A1, A2>> {}, priority_tag<0> {});\n}\n\ntemplate<typename BasicJsonType, typename... Args>\nstd::tuple<Args...> from_json_tuple_impl(BasicJsonType&& j, identity_tag<std::tuple<Args...>> /*unused*/, priority_tag<2> /*unused*/)\n{\n    return from_json_tuple_impl_base<BasicJsonType, Args...>(std::forward<BasicJsonType>(j), index_sequence_for<Args...> {});\n}\n\ntemplate<typename BasicJsonType, typename... Args>\nvoid from_json_tuple_impl(BasicJsonType&& j, std::tuple<Args...>& t, priority_tag<3> /*unused*/)\n{\n    t = from_json_tuple_impl_base<BasicJsonType, Args...>(std::forward<BasicJsonType>(j), index_sequence_for<Args...> {});\n}\n\ntemplate<typename BasicJsonType, typename TupleRelated>\nauto from_json(BasicJsonType&& j, TupleRelated&& t)\n-> decltype(from_json_tuple_impl(std::forward<BasicJsonType>(j), std::forward<TupleRelated>(t), priority_tag<3> {}))\n{\n    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))\n    {\n        JSON_THROW(type_error::create(302, \"type must be array, but is \" + std::string(j.type_name()), j));\n    }\n\n    return from_json_tuple_impl(std::forward<BasicJsonType>(j), std::forward<TupleRelated>(t), priority_tag<3> {});\n}\n\ntemplate < typename BasicJsonType, typename Key, typename Value, typename Compare, typename Allocator,\n           typename = enable_if_t < !std::is_constructible <\n                                        typename BasicJsonType::string_t, Key >::value >>\nvoid from_json(const BasicJsonType& j, std::map<Key, Value, Compare, Allocator>& m)\n{\n    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))\n    {\n        JSON_THROW(type_error::create(302, \"type must be array, but is \" + std::string(j.type_name()), j));\n    }\n    m.clear();\n    for (const auto& p : j)\n    {\n        if (JSON_HEDLEY_UNLIKELY(!p.is_array()))\n        {\n            JSON_THROW(type_error::create(302, \"type must be array, but is \" + std::string(p.type_name()), j));\n        }\n        m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());\n    }\n}\n\ntemplate < typename BasicJsonType, typename Key, typename Value, typename Hash, typename KeyEqual, typename Allocator,\n           typename = enable_if_t < !std::is_constructible <\n                                        typename BasicJsonType::string_t, Key >::value >>\nvoid from_json(const BasicJsonType& j, std::unordered_map<Key, Value, Hash, KeyEqual, Allocator>& m)\n{\n    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))\n    {\n        JSON_THROW(type_error::create(302, \"type must be array, but is \" + std::string(j.type_name()), j));\n    }\n    m.clear();\n    for (const auto& p : j)\n    {\n        if (JSON_HEDLEY_UNLIKELY(!p.is_array()))\n        {\n            JSON_THROW(type_error::create(302, \"type must be array, but is \" + std::string(p.type_name()), j));\n        }\n        m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());\n    }\n}\n\n#if JSON_HAS_FILESYSTEM || JSON_HAS_EXPERIMENTAL_FILESYSTEM\ntemplate<typename BasicJsonType>\nvoid from_json(const BasicJsonType& j, std_fs::path& p)\n{\n    if (JSON_HEDLEY_UNLIKELY(!j.is_string()))\n    {\n        JSON_THROW(type_error::create(302, \"type must be string, but is \" + std::string(j.type_name()), j));\n    }\n    p = *j.template get_ptr<const typename BasicJsonType::string_t*>();\n}\n#endif\n\nstruct from_json_fn\n{\n    template<typename BasicJsonType, typename T>\n    auto operator()(const BasicJsonType& j, T&& val) const\n    noexcept(noexcept(from_json(j, std::forward<T>(val))))\n    -> decltype(from_json(j, std::forward<T>(val)))\n    {\n        return from_json(j, std::forward<T>(val));\n    }\n};\n}  // namespace detail\n\n/// namespace to hold default `from_json` function\n/// to see why this is required:\n/// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html\nnamespace // NOLINT(cert-dcl59-cpp,fuchsia-header-anon-namespaces,google-build-namespaces)\n{\nconstexpr const auto& from_json = detail::static_const<detail::from_json_fn>::value; // NOLINT(misc-definitions-in-headers)\n} // namespace\n} // namespace nlohmann\n\n// #include <nlohmann/detail/conversions/to_json.hpp>\n\n\n#include <algorithm> // copy\n#include <iterator> // begin, end\n#include <string> // string\n#include <tuple> // tuple, get\n#include <type_traits> // is_same, is_constructible, is_floating_point, is_enum, underlying_type\n#include <utility> // move, forward, declval, pair\n#include <valarray> // valarray\n#include <vector> // vector\n\n// #include <nlohmann/detail/macro_scope.hpp>\n\n// #include <nlohmann/detail/iterators/iteration_proxy.hpp>\n\n\n#include <cstddef> // size_t\n#include <iterator> // input_iterator_tag\n#include <string> // string, to_string\n#include <tuple> // tuple_size, get, tuple_element\n#include <utility> // move\n\n// #include <nlohmann/detail/meta/type_traits.hpp>\n\n// #include <nlohmann/detail/value_t.hpp>\n\n\nnamespace nlohmann\n{\nnamespace detail\n{\ntemplate<typename string_type>\nvoid int_to_string( string_type& target, std::size_t value )\n{\n    // For ADL\n    using std::to_string;\n    target = to_string(value);\n}\ntemplate<typename IteratorType> class iteration_proxy_value\n{\n  public:\n    using difference_type = std::ptrdiff_t;\n    using value_type = iteration_proxy_value;\n    using pointer = value_type * ;\n    using reference = value_type & ;\n    using iterator_category = std::input_iterator_tag;\n    using string_type = typename std::remove_cv< typename std::remove_reference<decltype( std::declval<IteratorType>().key() ) >::type >::type;\n\n  private:\n    /// the iterator\n    IteratorType anchor;\n    /// an index for arrays (used to create key names)\n    std::size_t array_index = 0;\n    /// last stringified array index\n    mutable std::size_t array_index_last = 0;\n    /// a string representation of the array index\n    mutable string_type array_index_str = \"0\";\n    /// an empty string (to return a reference for primitive values)\n    const string_type empty_str{};\n\n  public:\n    explicit iteration_proxy_value(IteratorType it) noexcept\n        : anchor(std::move(it))\n    {}\n\n    /// dereference operator (needed for range-based for)\n    iteration_proxy_value& operator*()\n    {\n        return *this;\n    }\n\n    /// increment operator (needed for range-based for)\n    iteration_proxy_value& operator++()\n    {\n        ++anchor;\n        ++array_index;\n\n        return *this;\n    }\n\n    /// equality operator (needed for InputIterator)\n    bool operator==(const iteration_proxy_value& o) const\n    {\n        return anchor == o.anchor;\n    }\n\n    /// inequality operator (needed for range-based for)\n    bool operator!=(const iteration_proxy_value& o) const\n    {\n        return anchor != o.anchor;\n    }\n\n    /// return key of the iterator\n    const string_type& key() const\n    {\n        JSON_ASSERT(anchor.m_object != nullptr);\n\n        switch (anchor.m_object->type())\n        {\n            // use integer array index as key\n            case value_t::array:\n            {\n                if (array_index != array_index_last)\n                {\n                    int_to_string( array_index_str, array_index );\n                    array_index_last = array_index;\n                }\n                return array_index_str;\n            }\n\n            // use key from the object\n            case value_t::object:\n                return anchor.key();\n\n            // use an empty key for all primitive types\n            case value_t::null:\n            case value_t::string:\n            case value_t::boolean:\n            case value_t::number_integer:\n            case value_t::number_unsigned:\n            case value_t::number_float:\n            case value_t::binary:\n            case value_t::discarded:\n            default:\n                return empty_str;\n        }\n    }\n\n    /// return value of the iterator\n    typename IteratorType::reference value() const\n    {\n        return anchor.value();\n    }\n};\n\n/// proxy class for the items() function\ntemplate<typename IteratorType> class iteration_proxy\n{\n  private:\n    /// the container to iterate\n    typename IteratorType::reference container;\n\n  public:\n    /// construct iteration proxy from a container\n    explicit iteration_proxy(typename IteratorType::reference cont) noexcept\n        : container(cont) {}\n\n    /// return iterator begin (needed for range-based for)\n    iteration_proxy_value<IteratorType> begin() noexcept\n    {\n        return iteration_proxy_value<IteratorType>(container.begin());\n    }\n\n    /// return iterator end (needed for range-based for)\n    iteration_proxy_value<IteratorType> end() noexcept\n    {\n        return iteration_proxy_value<IteratorType>(container.end());\n    }\n};\n// Structured Bindings Support\n// For further reference see https://blog.tartanllama.xyz/structured-bindings/\n// And see https://github.com/nlohmann/json/pull/1391\ntemplate<std::size_t N, typename IteratorType, enable_if_t<N == 0, int> = 0>\nauto get(const nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> decltype(i.key())\n{\n    return i.key();\n}\n// Structured Bindings Support\n// For further reference see https://blog.tartanllama.xyz/structured-bindings/\n// And see https://github.com/nlohmann/json/pull/1391\ntemplate<std::size_t N, typename IteratorType, enable_if_t<N == 1, int> = 0>\nauto get(const nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> decltype(i.value())\n{\n    return i.value();\n}\n}  // namespace detail\n}  // namespace nlohmann\n\n// The Addition to the STD Namespace is required to add\n// Structured Bindings Support to the iteration_proxy_value class\n// For further reference see https://blog.tartanllama.xyz/structured-bindings/\n// And see https://github.com/nlohmann/json/pull/1391\nnamespace std\n{\n#if defined(__clang__)\n    // Fix: https://github.com/nlohmann/json/issues/1401\n    #pragma clang diagnostic push\n    #pragma clang diagnostic ignored \"-Wmismatched-tags\"\n#endif\ntemplate<typename IteratorType>\nclass tuple_size<::nlohmann::detail::iteration_proxy_value<IteratorType>>\n            : public std::integral_constant<std::size_t, 2> {};\n\ntemplate<std::size_t N, typename IteratorType>\nclass tuple_element<N, ::nlohmann::detail::iteration_proxy_value<IteratorType >>\n{\n  public:\n    using type = decltype(\n                     get<N>(std::declval <\n                            ::nlohmann::detail::iteration_proxy_value<IteratorType >> ()));\n};\n#if defined(__clang__)\n    #pragma clang diagnostic pop\n#endif\n} // namespace std\n\n// #include <nlohmann/detail/meta/cpp_future.hpp>\n\n// #include <nlohmann/detail/meta/type_traits.hpp>\n\n// #include <nlohmann/detail/value_t.hpp>\n\n\n#if JSON_HAS_EXPERIMENTAL_FILESYSTEM\n#include <experimental/filesystem>\nnamespace nlohmann::detail\n{\nnamespace std_fs = std::experimental::filesystem;\n} // namespace nlohmann::detail\n#elif JSON_HAS_FILESYSTEM\n#include <filesystem>\nnamespace nlohmann::detail\n{\nnamespace std_fs = std::filesystem;\n} // namespace nlohmann::detail\n#endif\n\nnamespace nlohmann\n{\nnamespace detail\n{\n//////////////////\n// constructors //\n//////////////////\n\n/*\n * Note all external_constructor<>::construct functions need to call\n * j.m_value.destroy(j.m_type) to avoid a memory leak in case j contains an\n * allocated value (e.g., a string). See bug issue\n * https://github.com/nlohmann/json/issues/2865 for more information.\n */\n\ntemplate<value_t> struct external_constructor;\n\ntemplate<>\nstruct external_constructor<value_t::boolean>\n{\n    template<typename BasicJsonType>\n    static void construct(BasicJsonType& j, typename BasicJsonType::boolean_t b) noexcept\n    {\n        j.m_value.destroy(j.m_type);\n        j.m_type = value_t::boolean;\n        j.m_value = b;\n        j.assert_invariant();\n    }\n};\n\ntemplate<>\nstruct external_constructor<value_t::string>\n{\n    template<typename BasicJsonType>\n    static void construct(BasicJsonType& j, const typename BasicJsonType::string_t& s)\n    {\n        j.m_value.destroy(j.m_type);\n        j.m_type = value_t::string;\n        j.m_value = s;\n        j.assert_invariant();\n    }\n\n    template<typename BasicJsonType>\n    static void construct(BasicJsonType& j, typename BasicJsonType::string_t&& s)\n    {\n        j.m_value.destroy(j.m_type);\n        j.m_type = value_t::string;\n        j.m_value = std::move(s);\n        j.assert_invariant();\n    }\n\n    template < typename BasicJsonType, typename CompatibleStringType,\n               enable_if_t < !std::is_same<CompatibleStringType, typename BasicJsonType::string_t>::value,\n                             int > = 0 >\n    static void construct(BasicJsonType& j, const CompatibleStringType& str)\n    {\n        j.m_value.destroy(j.m_type);\n        j.m_type = value_t::string;\n        j.m_value.string = j.template create<typename BasicJsonType::string_t>(str);\n        j.assert_invariant();\n    }\n};\n\ntemplate<>\nstruct external_constructor<value_t::binary>\n{\n    template<typename BasicJsonType>\n    static void construct(BasicJsonType& j, const typename BasicJsonType::binary_t& b)\n    {\n        j.m_value.destroy(j.m_type);\n        j.m_type = value_t::binary;\n        j.m_value = typename BasicJsonType::binary_t(b);\n        j.assert_invariant();\n    }\n\n    template<typename BasicJsonType>\n    static void construct(BasicJsonType& j, typename BasicJsonType::binary_t&& b)\n    {\n        j.m_value.destroy(j.m_type);\n        j.m_type = value_t::binary;\n        j.m_value = typename BasicJsonType::binary_t(std::move(b));\n        j.assert_invariant();\n    }\n};\n\ntemplate<>\nstruct external_constructor<value_t::number_float>\n{\n    template<typename BasicJsonType>\n    static void construct(BasicJsonType& j, typename BasicJsonType::number_float_t val) noexcept\n    {\n        j.m_value.destroy(j.m_type);\n        j.m_type = value_t::number_float;\n        j.m_value = val;\n        j.assert_invariant();\n    }\n};\n\ntemplate<>\nstruct external_constructor<value_t::number_unsigned>\n{\n    template<typename BasicJsonType>\n    static void construct(BasicJsonType& j, typename BasicJsonType::number_unsigned_t val) noexcept\n    {\n        j.m_value.destroy(j.m_type);\n        j.m_type = value_t::number_unsigned;\n        j.m_value = val;\n        j.assert_invariant();\n    }\n};\n\ntemplate<>\nstruct external_constructor<value_t::number_integer>\n{\n    template<typename BasicJsonType>\n    static void construct(BasicJsonType& j, typename BasicJsonType::number_integer_t val) noexcept\n    {\n        j.m_value.destroy(j.m_type);\n        j.m_type = value_t::number_integer;\n        j.m_value = val;\n        j.assert_invariant();\n    }\n};\n\ntemplate<>\nstruct external_constructor<value_t::array>\n{\n    template<typename BasicJsonType>\n    static void construct(BasicJsonType& j, const typename BasicJsonType::array_t& arr)\n    {\n        j.m_value.destroy(j.m_type);\n        j.m_type = value_t::array;\n        j.m_value = arr;\n        j.set_parents();\n        j.assert_invariant();\n    }\n\n    template<typename BasicJsonType>\n    static void construct(BasicJsonType& j, typename BasicJsonType::array_t&& arr)\n    {\n        j.m_value.destroy(j.m_type);\n        j.m_type = value_t::array;\n        j.m_value = std::move(arr);\n        j.set_parents();\n        j.assert_invariant();\n    }\n\n    template < typename BasicJsonType, typename CompatibleArrayType,\n               enable_if_t < !std::is_same<CompatibleArrayType, typename BasicJsonType::array_t>::value,\n                             int > = 0 >\n    static void construct(BasicJsonType& j, const CompatibleArrayType& arr)\n    {\n        using std::begin;\n        using std::end;\n\n        j.m_value.destroy(j.m_type);\n        j.m_type = value_t::array;\n        j.m_value.array = j.template create<typename BasicJsonType::array_t>(begin(arr), end(arr));\n        j.set_parents();\n        j.assert_invariant();\n    }\n\n    template<typename BasicJsonType>\n    static void construct(BasicJsonType& j, const std::vector<bool>& arr)\n    {\n        j.m_value.destroy(j.m_type);\n        j.m_type = value_t::array;\n        j.m_value = value_t::array;\n        j.m_value.array->reserve(arr.size());\n        for (const bool x : arr)\n        {\n            j.m_value.array->push_back(x);\n            j.set_parent(j.m_value.array->back());\n        }\n        j.assert_invariant();\n    }\n\n    template<typename BasicJsonType, typename T,\n             enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>\n    static void construct(BasicJsonType& j, const std::valarray<T>& arr)\n    {\n        j.m_value.destroy(j.m_type);\n        j.m_type = value_t::array;\n        j.m_value = value_t::array;\n        j.m_value.array->resize(arr.size());\n        if (arr.size() > 0)\n        {\n            std::copy(std::begin(arr), std::end(arr), j.m_value.array->begin());\n        }\n        j.set_parents();\n        j.assert_invariant();\n    }\n};\n\ntemplate<>\nstruct external_constructor<value_t::object>\n{\n    template<typename BasicJsonType>\n    static void construct(BasicJsonType& j, const typename BasicJsonType::object_t& obj)\n    {\n        j.m_value.destroy(j.m_type);\n        j.m_type = value_t::object;\n        j.m_value = obj;\n        j.set_parents();\n        j.assert_invariant();\n    }\n\n    template<typename BasicJsonType>\n    static void construct(BasicJsonType& j, typename BasicJsonType::object_t&& obj)\n    {\n        j.m_value.destroy(j.m_type);\n        j.m_type = value_t::object;\n        j.m_value = std::move(obj);\n        j.set_parents();\n        j.assert_invariant();\n    }\n\n    template < typename BasicJsonType, typename CompatibleObjectType,\n               enable_if_t < !std::is_same<CompatibleObjectType, typename BasicJsonType::object_t>::value, int > = 0 >\n    static void construct(BasicJsonType& j, const CompatibleObjectType& obj)\n    {\n        using std::begin;\n        using std::end;\n\n        j.m_value.destroy(j.m_type);\n        j.m_type = value_t::object;\n        j.m_value.object = j.template create<typename BasicJsonType::object_t>(begin(obj), end(obj));\n        j.set_parents();\n        j.assert_invariant();\n    }\n};\n\n/////////////\n// to_json //\n/////////////\n\ntemplate<typename BasicJsonType, typename T,\n         enable_if_t<std::is_same<T, typename BasicJsonType::boolean_t>::value, int> = 0>\nvoid to_json(BasicJsonType& j, T b) noexcept\n{\n    external_constructor<value_t::boolean>::construct(j, b);\n}\n\ntemplate<typename BasicJsonType, typename CompatibleString,\n         enable_if_t<std::is_constructible<typename BasicJsonType::string_t, CompatibleString>::value, int> = 0>\nvoid to_json(BasicJsonType& j, const CompatibleString& s)\n{\n    external_constructor<value_t::string>::construct(j, s);\n}\n\ntemplate<typename BasicJsonType>\nvoid to_json(BasicJsonType& j, typename BasicJsonType::string_t&& s)\n{\n    external_constructor<value_t::string>::construct(j, std::move(s));\n}\n\ntemplate<typename BasicJsonType, typename FloatType,\n         enable_if_t<std::is_floating_point<FloatType>::value, int> = 0>\nvoid to_json(BasicJsonType& j, FloatType val) noexcept\n{\n    external_constructor<value_t::number_float>::construct(j, static_cast<typename BasicJsonType::number_float_t>(val));\n}\n\ntemplate<typename BasicJsonType, typename CompatibleNumberUnsignedType,\n         enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType>::value, int> = 0>\nvoid to_json(BasicJsonType& j, CompatibleNumberUnsignedType val) noexcept\n{\n    external_constructor<value_t::number_unsigned>::construct(j, static_cast<typename BasicJsonType::number_unsigned_t>(val));\n}\n\ntemplate<typename BasicJsonType, typename CompatibleNumberIntegerType,\n         enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType>::value, int> = 0>\nvoid to_json(BasicJsonType& j, CompatibleNumberIntegerType val) noexcept\n{\n    external_constructor<value_t::number_integer>::construct(j, static_cast<typename BasicJsonType::number_integer_t>(val));\n}\n\ntemplate<typename BasicJsonType, typename EnumType,\n         enable_if_t<std::is_enum<EnumType>::value, int> = 0>\nvoid to_json(BasicJsonType& j, EnumType e) noexcept\n{\n    using underlying_type = typename std::underlying_type<EnumType>::type;\n    external_constructor<value_t::number_integer>::construct(j, static_cast<underlying_type>(e));\n}\n\ntemplate<typename BasicJsonType>\nvoid to_json(BasicJsonType& j, const std::vector<bool>& e)\n{\n    external_constructor<value_t::array>::construct(j, e);\n}\n\ntemplate < typename BasicJsonType, typename CompatibleArrayType,\n           enable_if_t < is_compatible_array_type<BasicJsonType,\n                         CompatibleArrayType>::value&&\n                         !is_compatible_object_type<BasicJsonType, CompatibleArrayType>::value&&\n                         !is_compatible_string_type<BasicJsonType, CompatibleArrayType>::value&&\n                         !std::is_same<typename BasicJsonType::binary_t, CompatibleArrayType>::value&&\n                         !is_basic_json<CompatibleArrayType>::value,\n                         int > = 0 >\nvoid to_json(BasicJsonType& j, const CompatibleArrayType& arr)\n{\n    external_constructor<value_t::array>::construct(j, arr);\n}\n\ntemplate<typename BasicJsonType>\nvoid to_json(BasicJsonType& j, const typename BasicJsonType::binary_t& bin)\n{\n    external_constructor<value_t::binary>::construct(j, bin);\n}\n\ntemplate<typename BasicJsonType, typename T,\n         enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>\nvoid to_json(BasicJsonType& j, const std::valarray<T>& arr)\n{\n    external_constructor<value_t::array>::construct(j, std::move(arr));\n}\n\ntemplate<typename BasicJsonType>\nvoid to_json(BasicJsonType& j, typename BasicJsonType::array_t&& arr)\n{\n    external_constructor<value_t::array>::construct(j, std::move(arr));\n}\n\ntemplate < typename BasicJsonType, typename CompatibleObjectType,\n           enable_if_t < is_compatible_object_type<BasicJsonType, CompatibleObjectType>::value&& !is_basic_json<CompatibleObjectType>::value, int > = 0 >\nvoid to_json(BasicJsonType& j, const CompatibleObjectType& obj)\n{\n    external_constructor<value_t::object>::construct(j, obj);\n}\n\ntemplate<typename BasicJsonType>\nvoid to_json(BasicJsonType& j, typename BasicJsonType::object_t&& obj)\n{\n    external_constructor<value_t::object>::construct(j, std::move(obj));\n}\n\ntemplate <\n    typename BasicJsonType, typename T, std::size_t N,\n    enable_if_t < !std::is_constructible<typename BasicJsonType::string_t,\n                  const T(&)[N]>::value, // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)\n                  int > = 0 >\nvoid to_json(BasicJsonType& j, const T(&arr)[N]) // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)\n{\n    external_constructor<value_t::array>::construct(j, arr);\n}\n\ntemplate < typename BasicJsonType, typename T1, typename T2, enable_if_t < std::is_constructible<BasicJsonType, T1>::value&& std::is_constructible<BasicJsonType, T2>::value, int > = 0 >\nvoid to_json(BasicJsonType& j, const std::pair<T1, T2>& p)\n{\n    j = { p.first, p.second };\n}\n\n// for https://github.com/nlohmann/json/pull/1134\ntemplate<typename BasicJsonType, typename T,\n         enable_if_t<std::is_same<T, iteration_proxy_value<typename BasicJsonType::iterator>>::value, int> = 0>\nvoid to_json(BasicJsonType& j, const T& b)\n{\n    j = { {b.key(), b.value()} };\n}\n\ntemplate<typename BasicJsonType, typename Tuple, std::size_t... Idx>\nvoid to_json_tuple_impl(BasicJsonType& j, const Tuple& t, index_sequence<Idx...> /*unused*/)\n{\n    j = { std::get<Idx>(t)... };\n}\n\ntemplate<typename BasicJsonType, typename T, enable_if_t<is_constructible_tuple<BasicJsonType, T>::value, int > = 0>\nvoid to_json(BasicJsonType& j, const T& t)\n{\n    to_json_tuple_impl(j, t, make_index_sequence<std::tuple_size<T>::value> {});\n}\n\n#if JSON_HAS_FILESYSTEM || JSON_HAS_EXPERIMENTAL_FILESYSTEM\ntemplate<typename BasicJsonType>\nvoid to_json(BasicJsonType& j, const std_fs::path& p)\n{\n    j = p.string();\n}\n#endif\n\nstruct to_json_fn\n{\n    template<typename BasicJsonType, typename T>\n    auto operator()(BasicJsonType& j, T&& val) const noexcept(noexcept(to_json(j, std::forward<T>(val))))\n    -> decltype(to_json(j, std::forward<T>(val)), void())\n    {\n        return to_json(j, std::forward<T>(val));\n    }\n};\n}  // namespace detail\n\n/// namespace to hold default `to_json` function\n/// to see why this is required:\n/// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html\nnamespace // NOLINT(cert-dcl59-cpp,fuchsia-header-anon-namespaces,google-build-namespaces)\n{\nconstexpr const auto& to_json = detail::static_const<detail::to_json_fn>::value; // NOLINT(misc-definitions-in-headers)\n} // namespace\n} // namespace nlohmann\n\n// #include <nlohmann/detail/meta/identity_tag.hpp>\n\n// #include <nlohmann/detail/meta/type_traits.hpp>\n\n\nnamespace nlohmann\n{\n\n/// @sa https://json.nlohmann.me/api/adl_serializer/\ntemplate<typename ValueType, typename>\nstruct adl_serializer\n{\n    /// @brief convert a JSON value to any value type\n    /// @sa https://json.nlohmann.me/api/adl_serializer/from_json/\n    template<typename BasicJsonType, typename TargetType = ValueType>\n    static auto from_json(BasicJsonType && j, TargetType& val) noexcept(\n        noexcept(::nlohmann::from_json(std::forward<BasicJsonType>(j), val)))\n    -> decltype(::nlohmann::from_json(std::forward<BasicJsonType>(j), val), void())\n    {\n        ::nlohmann::from_json(std::forward<BasicJsonType>(j), val);\n    }\n\n    /// @brief convert a JSON value to any value type\n    /// @sa https://json.nlohmann.me/api/adl_serializer/from_json/\n    template<typename BasicJsonType, typename TargetType = ValueType>\n    static auto from_json(BasicJsonType && j) noexcept(\n    noexcept(::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> {})))\n    -> decltype(::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> {}))\n    {\n        return ::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> {});\n    }\n\n    /// @brief convert any value type to a JSON value\n    /// @sa https://json.nlohmann.me/api/adl_serializer/to_json/\n    template<typename BasicJsonType, typename TargetType = ValueType>\n    static auto to_json(BasicJsonType& j, TargetType && val) noexcept(\n        noexcept(::nlohmann::to_json(j, std::forward<TargetType>(val))))\n    -> decltype(::nlohmann::to_json(j, std::forward<TargetType>(val)), void())\n    {\n        ::nlohmann::to_json(j, std::forward<TargetType>(val));\n    }\n};\n}  // namespace nlohmann\n\n// #include <nlohmann/byte_container_with_subtype.hpp>\n\n\n#include <cstdint> // uint8_t, uint64_t\n#include <tuple> // tie\n#include <utility> // move\n\nnamespace nlohmann\n{\n\n/// @brief an internal type for a backed binary type\n/// @sa https://json.nlohmann.me/api/byte_container_with_subtype/\ntemplate<typename BinaryType>\nclass byte_container_with_subtype : public BinaryType\n{\n  public:\n    using container_type = BinaryType;\n    using subtype_type = std::uint64_t;\n\n    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/\n    byte_container_with_subtype() noexcept(noexcept(container_type()))\n        : container_type()\n    {}\n\n    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/\n    byte_container_with_subtype(const container_type& b) noexcept(noexcept(container_type(b)))\n        : container_type(b)\n    {}\n\n    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/\n    byte_container_with_subtype(container_type&& b) noexcept(noexcept(container_type(std::move(b))))\n        : container_type(std::move(b))\n    {}\n\n    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/\n    byte_container_with_subtype(const container_type& b, subtype_type subtype_) noexcept(noexcept(container_type(b)))\n        : container_type(b)\n        , m_subtype(subtype_)\n        , m_has_subtype(true)\n    {}\n\n    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/\n    byte_container_with_subtype(container_type&& b, subtype_type subtype_) noexcept(noexcept(container_type(std::move(b))))\n        : container_type(std::move(b))\n        , m_subtype(subtype_)\n        , m_has_subtype(true)\n    {}\n\n    bool operator==(const byte_container_with_subtype& rhs) const\n    {\n        return std::tie(static_cast<const BinaryType&>(*this), m_subtype, m_has_subtype) ==\n               std::tie(static_cast<const BinaryType&>(rhs), rhs.m_subtype, rhs.m_has_subtype);\n    }\n\n    bool operator!=(const byte_container_with_subtype& rhs) const\n    {\n        return !(rhs == *this);\n    }\n\n    /// @brief sets the binary subtype\n    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/set_subtype/\n    void set_subtype(subtype_type subtype_) noexcept\n    {\n        m_subtype = subtype_;\n        m_has_subtype = true;\n    }\n\n    /// @brief return the binary subtype\n    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/subtype/\n    constexpr subtype_type subtype() const noexcept\n    {\n        return m_has_subtype ? m_subtype : static_cast<subtype_type>(-1);\n    }\n\n    /// @brief return whether the value has a subtype\n    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/has_subtype/\n    constexpr bool has_subtype() const noexcept\n    {\n        return m_has_subtype;\n    }\n\n    /// @brief clears the binary subtype\n    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/clear_subtype/\n    void clear_subtype() noexcept\n    {\n        m_subtype = 0;\n        m_has_subtype = false;\n    }\n\n  private:\n    subtype_type m_subtype = 0;\n    bool m_has_subtype = false;\n};\n\n}  // namespace nlohmann\n\n// #include <nlohmann/detail/conversions/from_json.hpp>\n\n// #include <nlohmann/detail/conversions/to_json.hpp>\n\n// #include <nlohmann/detail/exceptions.hpp>\n\n// #include <nlohmann/detail/hash.hpp>\n\n\n#include <cstdint> // uint8_t\n#include <cstddef> // size_t\n#include <functional> // hash\n\n// #include <nlohmann/detail/macro_scope.hpp>\n\n// #include <nlohmann/detail/value_t.hpp>\n\n\nnamespace nlohmann\n{\nnamespace detail\n{\n\n// boost::hash_combine\ninline std::size_t combine(std::size_t seed, std::size_t h) noexcept\n{\n    seed ^= h + 0x9e3779b9 + (seed << 6U) + (seed >> 2U);\n    return seed;\n}\n\n/*!\n@brief hash a JSON value\n\nThe hash function tries to rely on std::hash where possible. Furthermore, the\ntype of the JSON value is taken into account to have different hash values for\nnull, 0, 0U, and false, etc.\n\n@tparam BasicJsonType basic_json specialization\n@param j JSON value to hash\n@return hash value of j\n*/\ntemplate<typename BasicJsonType>\nstd::size_t hash(const BasicJsonType& j)\n{\n    using string_t = typename BasicJsonType::string_t;\n    using number_integer_t = typename BasicJsonType::number_integer_t;\n    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;\n    using number_float_t = typename BasicJsonType::number_float_t;\n\n    const auto type = static_cast<std::size_t>(j.type());\n    switch (j.type())\n    {\n        case BasicJsonType::value_t::null:\n        case BasicJsonType::value_t::discarded:\n        {\n            return combine(type, 0);\n        }\n\n        case BasicJsonType::value_t::object:\n        {\n            auto seed = combine(type, j.size());\n            for (const auto& element : j.items())\n            {\n                const auto h = std::hash<string_t> {}(element.key());\n                seed = combine(seed, h);\n                seed = combine(seed, hash(element.value()));\n            }\n            return seed;\n        }\n\n        case BasicJsonType::value_t::array:\n        {\n            auto seed = combine(type, j.size());\n            for (const auto& element : j)\n            {\n                seed = combine(seed, hash(element));\n            }\n            return seed;\n        }\n\n        case BasicJsonType::value_t::string:\n        {\n            const auto h = std::hash<string_t> {}(j.template get_ref<const string_t&>());\n            return combine(type, h);\n        }\n\n        case BasicJsonType::value_t::boolean:\n        {\n            const auto h = std::hash<bool> {}(j.template get<bool>());\n            return combine(type, h);\n        }\n\n        case BasicJsonType::value_t::number_integer:\n        {\n            const auto h = std::hash<number_integer_t> {}(j.template get<number_integer_t>());\n            return combine(type, h);\n        }\n\n        case BasicJsonType::value_t::number_unsigned:\n        {\n            const auto h = std::hash<number_unsigned_t> {}(j.template get<number_unsigned_t>());\n            return combine(type, h);\n        }\n\n        case BasicJsonType::value_t::number_float:\n        {\n            const auto h = std::hash<number_float_t> {}(j.template get<number_float_t>());\n            return combine(type, h);\n        }\n\n        case BasicJsonType::value_t::binary:\n        {\n            auto seed = combine(type, j.get_binary().size());\n            const auto h = std::hash<bool> {}(j.get_binary().has_subtype());\n            seed = combine(seed, h);\n            seed = combine(seed, static_cast<std::size_t>(j.get_binary().subtype()));\n            for (const auto byte : j.get_binary())\n            {\n                seed = combine(seed, std::hash<std::uint8_t> {}(byte));\n            }\n            return seed;\n        }\n\n        default:                   // LCOV_EXCL_LINE\n            JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE\n            return 0;              // LCOV_EXCL_LINE\n    }\n}\n\n}  // namespace detail\n}  // namespace nlohmann\n\n// #include <nlohmann/detail/input/binary_reader.hpp>\n\n\n#include <algorithm> // generate_n\n#include <array> // array\n#include <cmath> // ldexp\n#include <cstddef> // size_t\n#include <cstdint> // uint8_t, uint16_t, uint32_t, uint64_t\n#include <cstdio> // snprintf\n#include <cstring> // memcpy\n#include <iterator> // back_inserter\n#include <limits> // numeric_limits\n#include <string> // char_traits, string\n#include <utility> // make_pair, move\n#include <vector> // vector\n\n// #include <nlohmann/detail/exceptions.hpp>\n\n// #include <nlohmann/detail/input/input_adapters.hpp>\n\n\n#include <array> // array\n#include <cstddef> // size_t\n#include <cstring> // strlen\n#include <iterator> // begin, end, iterator_traits, random_access_iterator_tag, distance, next\n#include <memory> // shared_ptr, make_shared, addressof\n#include <numeric> // accumulate\n#include <string> // string, char_traits\n#include <type_traits> // enable_if, is_base_of, is_pointer, is_integral, remove_pointer\n#include <utility> // pair, declval\n\n#ifndef JSON_NO_IO\n    #include <cstdio>   // FILE *\n    #include <istream>  // istream\n#endif                  // JSON_NO_IO\n\n// #include <nlohmann/detail/iterators/iterator_traits.hpp>\n\n// #include <nlohmann/detail/macro_scope.hpp>\n\n\nnamespace nlohmann\n{\nnamespace detail\n{\n/// the supported input formats\nenum class input_format_t { json, cbor, msgpack, ubjson, bson };\n\n////////////////////\n// input adapters //\n////////////////////\n\n#ifndef JSON_NO_IO\n/*!\nInput adapter for stdio file access. This adapter read only 1 byte and do not use any\n buffer. This adapter is a very low level adapter.\n*/\nclass file_input_adapter\n{\n  public:\n    using char_type = char;\n\n    JSON_HEDLEY_NON_NULL(2)\n    explicit file_input_adapter(std::FILE* f) noexcept\n        : m_file(f)\n    {}\n\n    // make class move-only\n    file_input_adapter(const file_input_adapter&) = delete;\n    file_input_adapter(file_input_adapter&&) noexcept = default;\n    file_input_adapter& operator=(const file_input_adapter&) = delete;\n    file_input_adapter& operator=(file_input_adapter&&) = delete;\n    ~file_input_adapter() = default;\n\n    std::char_traits<char>::int_type get_character() noexcept\n    {\n        return std::fgetc(m_file);\n    }\n\n  private:\n    /// the file pointer to read from\n    std::FILE* m_file;\n};\n\n\n/*!\nInput adapter for a (caching) istream. Ignores a UFT Byte Order Mark at\nbeginning of input. Does not support changing the underlying std::streambuf\nin mid-input. Maintains underlying std::istream and std::streambuf to support\nsubsequent use of standard std::istream operations to process any input\ncharacters following those used in parsing the JSON input.  Clears the\nstd::istream flags; any input errors (e.g., EOF) will be detected by the first\nsubsequent call for input from the std::istream.\n*/\nclass input_stream_adapter\n{\n  public:\n    using char_type = char;\n\n    ~input_stream_adapter()\n    {\n        // clear stream flags; we use underlying streambuf I/O, do not\n        // maintain ifstream flags, except eof\n        if (is != nullptr)\n        {\n            is->clear(is->rdstate() & std::ios::eofbit);\n        }\n    }\n\n    explicit input_stream_adapter(std::istream& i)\n        : is(&i), sb(i.rdbuf())\n    {}\n\n    // delete because of pointer members\n    input_stream_adapter(const input_stream_adapter&) = delete;\n    input_stream_adapter& operator=(input_stream_adapter&) = delete;\n    input_stream_adapter& operator=(input_stream_adapter&&) = delete;\n\n    input_stream_adapter(input_stream_adapter&& rhs) noexcept\n        : is(rhs.is), sb(rhs.sb)\n    {\n        rhs.is = nullptr;\n        rhs.sb = nullptr;\n    }\n\n    // std::istream/std::streambuf use std::char_traits<char>::to_int_type, to\n    // ensure that std::char_traits<char>::eof() and the character 0xFF do not\n    // end up as the same value, e.g. 0xFFFFFFFF.\n    std::char_traits<char>::int_type get_character()\n    {\n        auto res = sb->sbumpc();\n        // set eof manually, as we don't use the istream interface.\n        if (JSON_HEDLEY_UNLIKELY(res == std::char_traits<char>::eof()))\n        {\n            is->clear(is->rdstate() | std::ios::eofbit);\n        }\n        return res;\n    }\n\n  private:\n    /// the associated input stream\n    std::istream* is = nullptr;\n    std::streambuf* sb = nullptr;\n};\n#endif  // JSON_NO_IO\n\n// General-purpose iterator-based adapter. It might not be as fast as\n// theoretically possible for some containers, but it is extremely versatile.\ntemplate<typename IteratorType>\nclass iterator_input_adapter\n{\n  public:\n    using char_type = typename std::iterator_traits<IteratorType>::value_type;\n\n    iterator_input_adapter(IteratorType first, IteratorType last)\n        : current(std::move(first)), end(std::move(last))\n    {}\n\n    typename std::char_traits<char_type>::int_type get_character()\n    {\n        if (JSON_HEDLEY_LIKELY(current != end))\n        {\n            auto result = std::char_traits<char_type>::to_int_type(*current);\n            std::advance(current, 1);\n            return result;\n        }\n\n        return std::char_traits<char_type>::eof();\n    }\n\n  private:\n    IteratorType current;\n    IteratorType end;\n\n    template<typename BaseInputAdapter, size_t T>\n    friend struct wide_string_input_helper;\n\n    bool empty() const\n    {\n        return current == end;\n    }\n};\n\n\ntemplate<typename BaseInputAdapter, size_t T>\nstruct wide_string_input_helper;\n\ntemplate<typename BaseInputAdapter>\nstruct wide_string_input_helper<BaseInputAdapter, 4>\n{\n    // UTF-32\n    static void fill_buffer(BaseInputAdapter& input,\n                            std::array<std::char_traits<char>::int_type, 4>& utf8_bytes,\n                            size_t& utf8_bytes_index,\n                            size_t& utf8_bytes_filled)\n    {\n        utf8_bytes_index = 0;\n\n        if (JSON_HEDLEY_UNLIKELY(input.empty()))\n        {\n            utf8_bytes[0] = std::char_traits<char>::eof();\n            utf8_bytes_filled = 1;\n        }\n        else\n        {\n            // get the current character\n            const auto wc = input.get_character();\n\n            // UTF-32 to UTF-8 encoding\n            if (wc < 0x80)\n            {\n                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);\n                utf8_bytes_filled = 1;\n            }\n            else if (wc <= 0x7FF)\n            {\n                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xC0u | ((static_cast<unsigned int>(wc) >> 6u) & 0x1Fu));\n                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));\n                utf8_bytes_filled = 2;\n            }\n            else if (wc <= 0xFFFF)\n            {\n                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xE0u | ((static_cast<unsigned int>(wc) >> 12u) & 0x0Fu));\n                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));\n                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));\n                utf8_bytes_filled = 3;\n            }\n            else if (wc <= 0x10FFFF)\n            {\n                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xF0u | ((static_cast<unsigned int>(wc) >> 18u) & 0x07u));\n                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 12u) & 0x3Fu));\n                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));\n                utf8_bytes[3] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));\n                utf8_bytes_filled = 4;\n            }\n            else\n            {\n                // unknown character\n                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);\n                utf8_bytes_filled = 1;\n            }\n        }\n    }\n};\n\ntemplate<typename BaseInputAdapter>\nstruct wide_string_input_helper<BaseInputAdapter, 2>\n{\n    // UTF-16\n    static void fill_buffer(BaseInputAdapter& input,\n                            std::array<std::char_traits<char>::int_type, 4>& utf8_bytes,\n                            size_t& utf8_bytes_index,\n                            size_t& utf8_bytes_filled)\n    {\n        utf8_bytes_index = 0;\n\n        if (JSON_HEDLEY_UNLIKELY(input.empty()))\n        {\n            utf8_bytes[0] = std::char_traits<char>::eof();\n            utf8_bytes_filled = 1;\n        }\n        else\n        {\n            // get the current character\n            const auto wc = input.get_character();\n\n            // UTF-16 to UTF-8 encoding\n            if (wc < 0x80)\n            {\n                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);\n                utf8_bytes_filled = 1;\n            }\n            else if (wc <= 0x7FF)\n            {\n                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xC0u | ((static_cast<unsigned int>(wc) >> 6u)));\n                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));\n                utf8_bytes_filled = 2;\n            }\n            else if (0xD800 > wc || wc >= 0xE000)\n            {\n                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xE0u | ((static_cast<unsigned int>(wc) >> 12u)));\n                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));\n                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));\n                utf8_bytes_filled = 3;\n            }\n            else\n            {\n                if (JSON_HEDLEY_UNLIKELY(!input.empty()))\n                {\n                    const auto wc2 = static_cast<unsigned int>(input.get_character());\n                    const auto charcode = 0x10000u + (((static_cast<unsigned int>(wc) & 0x3FFu) << 10u) | (wc2 & 0x3FFu));\n                    utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xF0u | (charcode >> 18u));\n                    utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((charcode >> 12u) & 0x3Fu));\n                    utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | ((charcode >> 6u) & 0x3Fu));\n                    utf8_bytes[3] = static_cast<std::char_traits<char>::int_type>(0x80u | (charcode & 0x3Fu));\n                    utf8_bytes_filled = 4;\n                }\n                else\n                {\n                    utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);\n                    utf8_bytes_filled = 1;\n                }\n            }\n        }\n    }\n};\n\n// Wraps another input apdater to convert wide character types into individual bytes.\ntemplate<typename BaseInputAdapter, typename WideCharType>\nclass wide_string_input_adapter\n{\n  public:\n    using char_type = char;\n\n    wide_string_input_adapter(BaseInputAdapter base)\n        : base_adapter(base) {}\n\n    typename std::char_traits<char>::int_type get_character() noexcept\n    {\n        // check if buffer needs to be filled\n        if (utf8_bytes_index == utf8_bytes_filled)\n        {\n            fill_buffer<sizeof(WideCharType)>();\n\n            JSON_ASSERT(utf8_bytes_filled > 0);\n            JSON_ASSERT(utf8_bytes_index == 0);\n        }\n\n        // use buffer\n        JSON_ASSERT(utf8_bytes_filled > 0);\n        JSON_ASSERT(utf8_bytes_index < utf8_bytes_filled);\n        return utf8_bytes[utf8_bytes_index++];\n    }\n\n  private:\n    BaseInputAdapter base_adapter;\n\n    template<size_t T>\n    void fill_buffer()\n    {\n        wide_string_input_helper<BaseInputAdapter, T>::fill_buffer(base_adapter, utf8_bytes, utf8_bytes_index, utf8_bytes_filled);\n    }\n\n    /// a buffer for UTF-8 bytes\n    std::array<std::char_traits<char>::int_type, 4> utf8_bytes = {{0, 0, 0, 0}};\n\n    /// index to the utf8_codes array for the next valid byte\n    std::size_t utf8_bytes_index = 0;\n    /// number of valid bytes in the utf8_codes array\n    std::size_t utf8_bytes_filled = 0;\n};\n\n\ntemplate<typename IteratorType, typename Enable = void>\nstruct iterator_input_adapter_factory\n{\n    using iterator_type = IteratorType;\n    using char_type = typename std::iterator_traits<iterator_type>::value_type;\n    using adapter_type = iterator_input_adapter<iterator_type>;\n\n    static adapter_type create(IteratorType first, IteratorType last)\n    {\n        return adapter_type(std::move(first), std::move(last));\n    }\n};\n\ntemplate<typename T>\nstruct is_iterator_of_multibyte\n{\n    using value_type = typename std::iterator_traits<T>::value_type;\n    enum\n    {\n        value = sizeof(value_type) > 1\n    };\n};\n\ntemplate<typename IteratorType>\nstruct iterator_input_adapter_factory<IteratorType, enable_if_t<is_iterator_of_multibyte<IteratorType>::value>>\n{\n    using iterator_type = IteratorType;\n    using char_type = typename std::iterator_traits<iterator_type>::value_type;\n    using base_adapter_type = iterator_input_adapter<iterator_type>;\n    using adapter_type = wide_string_input_adapter<base_adapter_type, char_type>;\n\n    static adapter_type create(IteratorType first, IteratorType last)\n    {\n        return adapter_type(base_adapter_type(std::move(first), std::move(last)));\n    }\n};\n\n// General purpose iterator-based input\ntemplate<typename IteratorType>\ntypename iterator_input_adapter_factory<IteratorType>::adapter_type input_adapter(IteratorType first, IteratorType last)\n{\n    using factory_type = iterator_input_adapter_factory<IteratorType>;\n    return factory_type::create(first, last);\n}\n\n// Convenience shorthand from container to iterator\n// Enables ADL on begin(container) and end(container)\n// Encloses the using declarations in namespace for not to leak them to outside scope\n\nnamespace container_input_adapter_factory_impl\n{\n\nusing std::begin;\nusing std::end;\n\ntemplate<typename ContainerType, typename Enable = void>\nstruct container_input_adapter_factory {};\n\ntemplate<typename ContainerType>\nstruct container_input_adapter_factory< ContainerType,\n       void_t<decltype(begin(std::declval<ContainerType>()), end(std::declval<ContainerType>()))>>\n       {\n           using adapter_type = decltype(input_adapter(begin(std::declval<ContainerType>()), end(std::declval<ContainerType>())));\n\n           static adapter_type create(const ContainerType& container)\n{\n    return input_adapter(begin(container), end(container));\n}\n       };\n\n} // namespace container_input_adapter_factory_impl\n\ntemplate<typename ContainerType>\ntypename container_input_adapter_factory_impl::container_input_adapter_factory<ContainerType>::adapter_type input_adapter(const ContainerType& container)\n{\n    return container_input_adapter_factory_impl::container_input_adapter_factory<ContainerType>::create(container);\n}\n\n#ifndef JSON_NO_IO\n// Special cases with fast paths\ninline file_input_adapter input_adapter(std::FILE* file)\n{\n    return file_input_adapter(file);\n}\n\ninline input_stream_adapter input_adapter(std::istream& stream)\n{\n    return input_stream_adapter(stream);\n}\n\ninline input_stream_adapter input_adapter(std::istream&& stream)\n{\n    return input_stream_adapter(stream);\n}\n#endif  // JSON_NO_IO\n\nusing contiguous_bytes_input_adapter = decltype(input_adapter(std::declval<const char*>(), std::declval<const char*>()));\n\n// Null-delimited strings, and the like.\ntemplate < typename CharT,\n           typename std::enable_if <\n               std::is_pointer<CharT>::value&&\n               !std::is_array<CharT>::value&&\n               std::is_integral<typename std::remove_pointer<CharT>::type>::value&&\n               sizeof(typename std::remove_pointer<CharT>::type) == 1,\n               int >::type = 0 >\ncontiguous_bytes_input_adapter input_adapter(CharT b)\n{\n    auto length = std::strlen(reinterpret_cast<const char*>(b));\n    const auto* ptr = reinterpret_cast<const char*>(b);\n    return input_adapter(ptr, ptr + length);\n}\n\ntemplate<typename T, std::size_t N>\nauto input_adapter(T (&array)[N]) -> decltype(input_adapter(array, array + N)) // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)\n{\n    return input_adapter(array, array + N);\n}\n\n// This class only handles inputs of input_buffer_adapter type.\n// It's required so that expressions like {ptr, len} can be implicitly cast\n// to the correct adapter.\nclass span_input_adapter\n{\n  public:\n    template < typename CharT,\n               typename std::enable_if <\n                   std::is_pointer<CharT>::value&&\n                   std::is_integral<typename std::remove_pointer<CharT>::type>::value&&\n                   sizeof(typename std::remove_pointer<CharT>::type) == 1,\n                   int >::type = 0 >\n    span_input_adapter(CharT b, std::size_t l)\n        : ia(reinterpret_cast<const char*>(b), reinterpret_cast<const char*>(b) + l) {}\n\n    template<class IteratorType,\n             typename std::enable_if<\n                 std::is_same<typename iterator_traits<IteratorType>::iterator_category, std::random_access_iterator_tag>::value,\n                 int>::type = 0>\n    span_input_adapter(IteratorType first, IteratorType last)\n        : ia(input_adapter(first, last)) {}\n\n    contiguous_bytes_input_adapter&& get()\n    {\n        return std::move(ia); // NOLINT(hicpp-move-const-arg,performance-move-const-arg)\n    }\n\n  private:\n    contiguous_bytes_input_adapter ia;\n};\n}  // namespace detail\n}  // namespace nlohmann\n\n// #include <nlohmann/detail/input/json_sax.hpp>\n\n\n#include <cstddef>\n#include <string> // string\n#include <utility> // move\n#include <vector> // vector\n\n// #include <nlohmann/detail/exceptions.hpp>\n\n// #include <nlohmann/detail/macro_scope.hpp>\n\n\nnamespace nlohmann\n{\n\n/*!\n@brief SAX interface\n\nThis class describes the SAX interface used by @ref nlohmann::json::sax_parse.\nEach function is called in different situations while the input is parsed. The\nboolean return value informs the parser whether to continue processing the\ninput.\n*/\ntemplate<typename BasicJsonType>\nstruct json_sax\n{\n    using number_integer_t = typename BasicJsonType::number_integer_t;\n    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;\n    using number_float_t = typename BasicJsonType::number_float_t;\n    using string_t = typename BasicJsonType::string_t;\n    using binary_t = typename BasicJsonType::binary_t;\n\n    /*!\n    @brief a null value was read\n    @return whether parsing should proceed\n    */\n    virtual bool null() = 0;\n\n    /*!\n    @brief a boolean value was read\n    @param[in] val  boolean value\n    @return whether parsing should proceed\n    */\n    virtual bool boolean(bool val) = 0;\n\n    /*!\n    @brief an integer number was read\n    @param[in] val  integer value\n    @return whether parsing should proceed\n    */\n    virtual bool number_integer(number_integer_t val) = 0;\n\n    /*!\n    @brief an unsigned integer number was read\n    @param[in] val  unsigned integer value\n    @return whether parsing should proceed\n    */\n    virtual bool number_unsigned(number_unsigned_t val) = 0;\n\n    /*!\n    @brief a floating-point number was read\n    @param[in] val  floating-point value\n    @param[in] s    raw token value\n    @return whether parsing should proceed\n    */\n    virtual bool number_float(number_float_t val, const string_t& s) = 0;\n\n    /*!\n    @brief a string value was read\n    @param[in] val  string value\n    @return whether parsing should proceed\n    @note It is safe to move the passed string value.\n    */\n    virtual bool string(string_t& val) = 0;\n\n    /*!\n    @brief a binary value was read\n    @param[in] val  binary value\n    @return whether parsing should proceed\n    @note It is safe to move the passed binary value.\n    */\n    virtual bool binary(binary_t& val) = 0;\n\n    /*!\n    @brief the beginning of an object was read\n    @param[in] elements  number of object elements or -1 if unknown\n    @return whether parsing should proceed\n    @note binary formats may report the number of elements\n    */\n    virtual bool start_object(std::size_t elements) = 0;\n\n    /*!\n    @brief an object key was read\n    @param[in] val  object key\n    @return whether parsing should proceed\n    @note It is safe to move the passed string.\n    */\n    virtual bool key(string_t& val) = 0;\n\n    /*!\n    @brief the end of an object was read\n    @return whether parsing should proceed\n    */\n    virtual bool end_object() = 0;\n\n    /*!\n    @brief the beginning of an array was read\n    @param[in] elements  number of array elements or -1 if unknown\n    @return whether parsing should proceed\n    @note binary formats may report the number of elements\n    */\n    virtual bool start_array(std::size_t elements) = 0;\n\n    /*!\n    @brief the end of an array was read\n    @return whether parsing should proceed\n    */\n    virtual bool end_array() = 0;\n\n    /*!\n    @brief a parse error occurred\n    @param[in] position    the position in the input where the error occurs\n    @param[in] last_token  the last read token\n    @param[in] ex          an exception object describing the error\n    @return whether parsing should proceed (must return false)\n    */\n    virtual bool parse_error(std::size_t position,\n                             const std::string& last_token,\n                             const detail::exception& ex) = 0;\n\n    json_sax() = default;\n    json_sax(const json_sax&) = default;\n    json_sax(json_sax&&) noexcept = default;\n    json_sax& operator=(const json_sax&) = default;\n    json_sax& operator=(json_sax&&) noexcept = default;\n    virtual ~json_sax() = default;\n};\n\n\nnamespace detail\n{\n/*!\n@brief SAX implementation to create a JSON value from SAX events\n\nThis class implements the @ref json_sax interface and processes the SAX events\nto create a JSON value which makes it basically a DOM parser. The structure or\nhierarchy of the JSON value is managed by the stack `ref_stack` which contains\na pointer to the respective array or object for each recursion depth.\n\nAfter successful parsing, the value that is passed by reference to the\nconstructor contains the parsed value.\n\n@tparam BasicJsonType  the JSON type\n*/\ntemplate<typename BasicJsonType>\nclass json_sax_dom_parser\n{\n  public:\n    using number_integer_t = typename BasicJsonType::number_integer_t;\n    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;\n    using number_float_t = typename BasicJsonType::number_float_t;\n    using string_t = typename BasicJsonType::string_t;\n    using binary_t = typename BasicJsonType::binary_t;\n\n    /*!\n    @param[in,out] r  reference to a JSON value that is manipulated while\n                       parsing\n    @param[in] allow_exceptions_  whether parse errors yield exceptions\n    */\n    explicit json_sax_dom_parser(BasicJsonType& r, const bool allow_exceptions_ = true)\n        : root(r), allow_exceptions(allow_exceptions_)\n    {}\n\n    // make class move-only\n    json_sax_dom_parser(const json_sax_dom_parser&) = delete;\n    json_sax_dom_parser(json_sax_dom_parser&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)\n    json_sax_dom_parser& operator=(const json_sax_dom_parser&) = delete;\n    json_sax_dom_parser& operator=(json_sax_dom_parser&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)\n    ~json_sax_dom_parser() = default;\n\n    bool null()\n    {\n        handle_value(nullptr);\n        return true;\n    }\n\n    bool boolean(bool val)\n    {\n        handle_value(val);\n        return true;\n    }\n\n    bool number_integer(number_integer_t val)\n    {\n        handle_value(val);\n        return true;\n    }\n\n    bool number_unsigned(number_unsigned_t val)\n    {\n        handle_value(val);\n        return true;\n    }\n\n    bool number_float(number_float_t val, const string_t& /*unused*/)\n    {\n        handle_value(val);\n        return true;\n    }\n\n    bool string(string_t& val)\n    {\n        handle_value(val);\n        return true;\n    }\n\n    bool binary(binary_t& val)\n    {\n        handle_value(std::move(val));\n        return true;\n    }\n\n    bool start_object(std::size_t len)\n    {\n        ref_stack.push_back(handle_value(BasicJsonType::value_t::object));\n\n        if (JSON_HEDLEY_UNLIKELY(len != static_cast<std::size_t>(-1) && len > ref_stack.back()->max_size()))\n        {\n            JSON_THROW(out_of_range::create(408, \"excessive object size: \" + std::to_string(len), *ref_stack.back()));\n        }\n\n        return true;\n    }\n\n    bool key(string_t& val)\n    {\n        // add null at given key and store the reference for later\n        object_element = &(ref_stack.back()->m_value.object->operator[](val));\n        return true;\n    }\n\n    bool end_object()\n    {\n        ref_stack.back()->set_parents();\n        ref_stack.pop_back();\n        return true;\n    }\n\n    bool start_array(std::size_t len)\n    {\n        ref_stack.push_back(handle_value(BasicJsonType::value_t::array));\n\n        if (JSON_HEDLEY_UNLIKELY(len != static_cast<std::size_t>(-1) && len > ref_stack.back()->max_size()))\n        {\n            JSON_THROW(out_of_range::create(408, \"excessive array size: \" + std::to_string(len), *ref_stack.back()));\n        }\n\n        return true;\n    }\n\n    bool end_array()\n    {\n        ref_stack.back()->set_parents();\n        ref_stack.pop_back();\n        return true;\n    }\n\n    template<class Exception>\n    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/,\n                     const Exception& ex)\n    {\n        errored = true;\n        static_cast<void>(ex);\n        if (allow_exceptions)\n        {\n            JSON_THROW(ex);\n        }\n        return false;\n    }\n\n    constexpr bool is_errored() const\n    {\n        return errored;\n    }\n\n  private:\n    /*!\n    @invariant If the ref stack is empty, then the passed value will be the new\n               root.\n    @invariant If the ref stack contains a value, then it is an array or an\n               object to which we can add elements\n    */\n    template<typename Value>\n    JSON_HEDLEY_RETURNS_NON_NULL\n    BasicJsonType* handle_value(Value&& v)\n    {\n        if (ref_stack.empty())\n        {\n            root = BasicJsonType(std::forward<Value>(v));\n            return &root;\n        }\n\n        JSON_ASSERT(ref_stack.back()->is_array() || ref_stack.back()->is_object());\n\n        if (ref_stack.back()->is_array())\n        {\n            ref_stack.back()->m_value.array->emplace_back(std::forward<Value>(v));\n            return &(ref_stack.back()->m_value.array->back());\n        }\n\n        JSON_ASSERT(ref_stack.back()->is_object());\n        JSON_ASSERT(object_element);\n        *object_element = BasicJsonType(std::forward<Value>(v));\n        return object_element;\n    }\n\n    /// the parsed JSON value\n    BasicJsonType& root;\n    /// stack to model hierarchy of values\n    std::vector<BasicJsonType*> ref_stack {};\n    /// helper to hold the reference for the next object element\n    BasicJsonType* object_element = nullptr;\n    /// whether a syntax error occurred\n    bool errored = false;\n    /// whether to throw exceptions in case of errors\n    const bool allow_exceptions = true;\n};\n\ntemplate<typename BasicJsonType>\nclass json_sax_dom_callback_parser\n{\n  public:\n    using number_integer_t = typename BasicJsonType::number_integer_t;\n    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;\n    using number_float_t = typename BasicJsonType::number_float_t;\n    using string_t = typename BasicJsonType::string_t;\n    using binary_t = typename BasicJsonType::binary_t;\n    using parser_callback_t = typename BasicJsonType::parser_callback_t;\n    using parse_event_t = typename BasicJsonType::parse_event_t;\n\n    json_sax_dom_callback_parser(BasicJsonType& r,\n                                 const parser_callback_t cb,\n                                 const bool allow_exceptions_ = true)\n        : root(r), callback(cb), allow_exceptions(allow_exceptions_)\n    {\n        keep_stack.push_back(true);\n    }\n\n    // make class move-only\n    json_sax_dom_callback_parser(const json_sax_dom_callback_parser&) = delete;\n    json_sax_dom_callback_parser(json_sax_dom_callback_parser&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)\n    json_sax_dom_callback_parser& operator=(const json_sax_dom_callback_parser&) = delete;\n    json_sax_dom_callback_parser& operator=(json_sax_dom_callback_parser&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)\n    ~json_sax_dom_callback_parser() = default;\n\n    bool null()\n    {\n        handle_value(nullptr);\n        return true;\n    }\n\n    bool boolean(bool val)\n    {\n        handle_value(val);\n        return true;\n    }\n\n    bool number_integer(number_integer_t val)\n    {\n        handle_value(val);\n        return true;\n    }\n\n    bool number_unsigned(number_unsigned_t val)\n    {\n        handle_value(val);\n        return true;\n    }\n\n    bool number_float(number_float_t val, const string_t& /*unused*/)\n    {\n        handle_value(val);\n        return true;\n    }\n\n    bool string(string_t& val)\n    {\n        handle_value(val);\n        return true;\n    }\n\n    bool binary(binary_t& val)\n    {\n        handle_value(std::move(val));\n        return true;\n    }\n\n    bool start_object(std::size_t len)\n    {\n        // check callback for object start\n        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::object_start, discarded);\n        keep_stack.push_back(keep);\n\n        auto val = handle_value(BasicJsonType::value_t::object, true);\n        ref_stack.push_back(val.second);\n\n        // check object limit\n        if (ref_stack.back() && JSON_HEDLEY_UNLIKELY(len != static_cast<std::size_t>(-1) && len > ref_stack.back()->max_size()))\n        {\n            JSON_THROW(out_of_range::create(408, \"excessive object size: \" + std::to_string(len), *ref_stack.back()));\n        }\n\n        return true;\n    }\n\n    bool key(string_t& val)\n    {\n        BasicJsonType k = BasicJsonType(val);\n\n        // check callback for key\n        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::key, k);\n        key_keep_stack.push_back(keep);\n\n        // add discarded value at given key and store the reference for later\n        if (keep && ref_stack.back())\n        {\n            object_element = &(ref_stack.back()->m_value.object->operator[](val) = discarded);\n        }\n\n        return true;\n    }\n\n    bool end_object()\n    {\n        if (ref_stack.back())\n        {\n            if (!callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::object_end, *ref_stack.back()))\n            {\n                // discard object\n                *ref_stack.back() = discarded;\n            }\n            else\n            {\n                ref_stack.back()->set_parents();\n            }\n        }\n\n        JSON_ASSERT(!ref_stack.empty());\n        JSON_ASSERT(!keep_stack.empty());\n        ref_stack.pop_back();\n        keep_stack.pop_back();\n\n        if (!ref_stack.empty() && ref_stack.back() && ref_stack.back()->is_structured())\n        {\n            // remove discarded value\n            for (auto it = ref_stack.back()->begin(); it != ref_stack.back()->end(); ++it)\n            {\n                if (it->is_discarded())\n                {\n                    ref_stack.back()->erase(it);\n                    break;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    bool start_array(std::size_t len)\n    {\n        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::array_start, discarded);\n        keep_stack.push_back(keep);\n\n        auto val = handle_value(BasicJsonType::value_t::array, true);\n        ref_stack.push_back(val.second);\n\n        // check array limit\n        if (ref_stack.back() && JSON_HEDLEY_UNLIKELY(len != static_cast<std::size_t>(-1) && len > ref_stack.back()->max_size()))\n        {\n            JSON_THROW(out_of_range::create(408, \"excessive array size: \" + std::to_string(len), *ref_stack.back()));\n        }\n\n        return true;\n    }\n\n    bool end_array()\n    {\n        bool keep = true;\n\n        if (ref_stack.back())\n        {\n            keep = callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::array_end, *ref_stack.back());\n            if (keep)\n            {\n                ref_stack.back()->set_parents();\n            }\n            else\n            {\n                // discard array\n                *ref_stack.back() = discarded;\n            }\n        }\n\n        JSON_ASSERT(!ref_stack.empty());\n        JSON_ASSERT(!keep_stack.empty());\n        ref_stack.pop_back();\n        keep_stack.pop_back();\n\n        // remove discarded value\n        if (!keep && !ref_stack.empty() && ref_stack.back()->is_array())\n        {\n            ref_stack.back()->m_value.array->pop_back();\n        }\n\n        return true;\n    }\n\n    template<class Exception>\n    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/,\n                     const Exception& ex)\n    {\n        errored = true;\n        static_cast<void>(ex);\n        if (allow_exceptions)\n        {\n            JSON_THROW(ex);\n        }\n        return false;\n    }\n\n    constexpr bool is_errored() const\n    {\n        return errored;\n    }\n\n  private:\n    /*!\n    @param[in] v  value to add to the JSON value we build during parsing\n    @param[in] skip_callback  whether we should skip calling the callback\n               function; this is required after start_array() and\n               start_object() SAX events, because otherwise we would call the\n               callback function with an empty array or object, respectively.\n\n    @invariant If the ref stack is empty, then the passed value will be the new\n               root.\n    @invariant If the ref stack contains a value, then it is an array or an\n               object to which we can add elements\n\n    @return pair of boolean (whether value should be kept) and pointer (to the\n            passed value in the ref_stack hierarchy; nullptr if not kept)\n    */\n    template<typename Value>\n    std::pair<bool, BasicJsonType*> handle_value(Value&& v, const bool skip_callback = false)\n    {\n        JSON_ASSERT(!keep_stack.empty());\n\n        // do not handle this value if we know it would be added to a discarded\n        // container\n        if (!keep_stack.back())\n        {\n            return {false, nullptr};\n        }\n\n        // create value\n        auto value = BasicJsonType(std::forward<Value>(v));\n\n        // check callback\n        const bool keep = skip_callback || callback(static_cast<int>(ref_stack.size()), parse_event_t::value, value);\n\n        // do not handle this value if we just learnt it shall be discarded\n        if (!keep)\n        {\n            return {false, nullptr};\n        }\n\n        if (ref_stack.empty())\n        {\n            root = std::move(value);\n            return {true, &root};\n        }\n\n        // skip this value if we already decided to skip the parent\n        // (https://github.com/nlohmann/json/issues/971#issuecomment-413678360)\n        if (!ref_stack.back())\n        {\n            return {false, nullptr};\n        }\n\n        // we now only expect arrays and objects\n        JSON_ASSERT(ref_stack.back()->is_array() || ref_stack.back()->is_object());\n\n        // array\n        if (ref_stack.back()->is_array())\n        {\n            ref_stack.back()->m_value.array->emplace_back(std::move(value));\n            return {true, &(ref_stack.back()->m_value.array->back())};\n        }\n\n        // object\n        JSON_ASSERT(ref_stack.back()->is_object());\n        // check if we should store an element for the current key\n        JSON_ASSERT(!key_keep_stack.empty());\n        const bool store_element = key_keep_stack.back();\n        key_keep_stack.pop_back();\n\n        if (!store_element)\n        {\n            return {false, nullptr};\n        }\n\n        JSON_ASSERT(object_element);\n        *object_element = std::move(value);\n        return {true, object_element};\n    }\n\n    /// the parsed JSON value\n    BasicJsonType& root;\n    /// stack to model hierarchy of values\n    std::vector<BasicJsonType*> ref_stack {};\n    /// stack to manage which values to keep\n    std::vector<bool> keep_stack {};\n    /// stack to manage which object keys to keep\n    std::vector<bool> key_keep_stack {};\n    /// helper to hold the reference for the next object element\n    BasicJsonType* object_element = nullptr;\n    /// whether a syntax error occurred\n    bool errored = false;\n    /// callback function\n    const parser_callback_t callback = nullptr;\n    /// whether to throw exceptions in case of errors\n    const bool allow_exceptions = true;\n    /// a discarded value for the callback\n    BasicJsonType discarded = BasicJsonType::value_t::discarded;\n};\n\ntemplate<typename BasicJsonType>\nclass json_sax_acceptor\n{\n  public:\n    using number_integer_t = typename BasicJsonType::number_integer_t;\n    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;\n    using number_float_t = typename BasicJsonType::number_float_t;\n    using string_t = typename BasicJsonType::string_t;\n    using binary_t = typename BasicJsonType::binary_t;\n\n    bool null()\n    {\n        return true;\n    }\n\n    bool boolean(bool /*unused*/)\n    {\n        return true;\n    }\n\n    bool number_integer(number_integer_t /*unused*/)\n    {\n        return true;\n    }\n\n    bool number_unsigned(number_unsigned_t /*unused*/)\n    {\n        return true;\n    }\n\n    bool number_float(number_float_t /*unused*/, const string_t& /*unused*/)\n    {\n        return true;\n    }\n\n    bool string(string_t& /*unused*/)\n    {\n        return true;\n    }\n\n    bool binary(binary_t& /*unused*/)\n    {\n        return true;\n    }\n\n    bool start_object(std::size_t /*unused*/ = static_cast<std::size_t>(-1))\n    {\n        return true;\n    }\n\n    bool key(string_t& /*unused*/)\n    {\n        return true;\n    }\n\n    bool end_object()\n    {\n        return true;\n    }\n\n    bool start_array(std::size_t /*unused*/ = static_cast<std::size_t>(-1))\n    {\n        return true;\n    }\n\n    bool end_array()\n    {\n        return true;\n    }\n\n    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/, const detail::exception& /*unused*/)\n    {\n        return false;\n    }\n};\n}  // namespace detail\n\n}  // namespace nlohmann\n\n// #include <nlohmann/detail/input/lexer.hpp>\n\n\n#include <array> // array\n#include <clocale> // localeconv\n#include <cstddef> // size_t\n#include <cstdio> // snprintf\n#include <cstdlib> // strtof, strtod, strtold, strtoll, strtoull\n#include <initializer_list> // initializer_list\n#include <string> // char_traits, string\n#include <utility> // move\n#include <vector> // vector\n\n// #include <nlohmann/detail/input/input_adapters.hpp>\n\n// #include <nlohmann/detail/input/position_t.hpp>\n\n// #include <nlohmann/detail/macro_scope.hpp>\n\n\nnamespace nlohmann\n{\nnamespace detail\n{\n///////////\n// lexer //\n///////////\n\ntemplate<typename BasicJsonType>\nclass lexer_base\n{\n  public:\n    /// token types for the parser\n    enum class token_type\n    {\n        uninitialized,    ///< indicating the scanner is uninitialized\n        literal_true,     ///< the `true` literal\n        literal_false,    ///< the `false` literal\n        literal_null,     ///< the `null` literal\n        value_string,     ///< a string -- use get_string() for actual value\n        value_unsigned,   ///< an unsigned integer -- use get_number_unsigned() for actual value\n        value_integer,    ///< a signed integer -- use get_number_integer() for actual value\n        value_float,      ///< an floating point number -- use get_number_float() for actual value\n        begin_array,      ///< the character for array begin `[`\n        begin_object,     ///< the character for object begin `{`\n        end_array,        ///< the character for array end `]`\n        end_object,       ///< the character for object end `}`\n        name_separator,   ///< the name separator `:`\n        value_separator,  ///< the value separator `,`\n        parse_error,      ///< indicating a parse error\n        end_of_input,     ///< indicating the end of the input buffer\n        literal_or_value  ///< a literal or the begin of a value (only for diagnostics)\n    };\n\n    /// return name of values of type token_type (only used for errors)\n    JSON_HEDLEY_RETURNS_NON_NULL\n    JSON_HEDLEY_CONST\n    static const char* token_type_name(const token_type t) noexcept\n    {\n        switch (t)\n        {\n            case token_type::uninitialized:\n                return \"<uninitialized>\";\n            case token_type::literal_true:\n                return \"true literal\";\n            case token_type::literal_false:\n                return \"false literal\";\n            case token_type::literal_null:\n                return \"null literal\";\n            case token_type::value_string:\n                return \"string literal\";\n            case token_type::value_unsigned:\n            case token_type::value_integer:\n            case token_type::value_float:\n                return \"number literal\";\n            case token_type::begin_array:\n                return \"'['\";\n            case token_type::begin_object:\n                return \"'{'\";\n            case token_type::end_array:\n                return \"']'\";\n            case token_type::end_object:\n                return \"'}'\";\n            case token_type::name_separator:\n                return \"':'\";\n            case token_type::value_separator:\n                return \"','\";\n            case token_type::parse_error:\n                return \"<parse error>\";\n            case token_type::end_of_input:\n                return \"end of input\";\n            case token_type::literal_or_value:\n                return \"'[', '{', or a literal\";\n            // LCOV_EXCL_START\n            default: // catch non-enum values\n                return \"unknown token\";\n                // LCOV_EXCL_STOP\n        }\n    }\n};\n/*!\n@brief lexical analysis\n\nThis class organizes the lexical analysis during JSON deserialization.\n*/\ntemplate<typename BasicJsonType, typename InputAdapterType>\nclass lexer : public lexer_base<BasicJsonType>\n{\n    using number_integer_t = typename BasicJsonType::number_integer_t;\n    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;\n    using number_float_t = typename BasicJsonType::number_float_t;\n    using string_t = typename BasicJsonType::string_t;\n    using char_type = typename InputAdapterType::char_type;\n    using char_int_type = typename std::char_traits<char_type>::int_type;\n\n  public:\n    using token_type = typename lexer_base<BasicJsonType>::token_type;\n\n    explicit lexer(InputAdapterType&& adapter, bool ignore_comments_ = false) noexcept\n        : ia(std::move(adapter))\n        , ignore_comments(ignore_comments_)\n        , decimal_point_char(static_cast<char_int_type>(get_decimal_point()))\n    {}\n\n    // delete because of pointer members\n    lexer(const lexer&) = delete;\n    lexer(lexer&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)\n    lexer& operator=(lexer&) = delete;\n    lexer& operator=(lexer&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)\n    ~lexer() = default;\n\n  private:\n    /////////////////////\n    // locales\n    /////////////////////\n\n    /// return the locale-dependent decimal point\n    JSON_HEDLEY_PURE\n    static char get_decimal_point() noexcept\n    {\n        const auto* loc = localeconv();\n        JSON_ASSERT(loc != nullptr);\n        return (loc->decimal_point == nullptr) ? '.' : *(loc->decimal_point);\n    }\n\n    /////////////////////\n    // scan functions\n    /////////////////////\n\n    /*!\n    @brief get codepoint from 4 hex characters following `\\u`\n\n    For input \"\\u c1 c2 c3 c4\" the codepoint is:\n      (c1 * 0x1000) + (c2 * 0x0100) + (c3 * 0x0010) + c4\n    = (c1 << 12) + (c2 << 8) + (c3 << 4) + (c4 << 0)\n\n    Furthermore, the possible characters '0'..'9', 'A'..'F', and 'a'..'f'\n    must be converted to the integers 0x0..0x9, 0xA..0xF, 0xA..0xF, resp. The\n    conversion is done by subtracting the offset (0x30, 0x37, and 0x57)\n    between the ASCII value of the character and the desired integer value.\n\n    @return codepoint (0x0000..0xFFFF) or -1 in case of an error (e.g. EOF or\n            non-hex character)\n    */\n    int get_codepoint()\n    {\n        // this function only makes sense after reading `\\u`\n        JSON_ASSERT(current == 'u');\n        int codepoint = 0;\n\n        const auto factors = { 12u, 8u, 4u, 0u };\n        for (const auto factor : factors)\n        {\n            get();\n\n            if (current >= '0' && current <= '9')\n            {\n                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x30u) << factor);\n            }\n            else if (current >= 'A' && current <= 'F')\n            {\n                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x37u) << factor);\n            }\n            else if (current >= 'a' && current <= 'f')\n            {\n                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x57u) << factor);\n            }\n            else\n            {\n                return -1;\n            }\n        }\n\n        JSON_ASSERT(0x0000 <= codepoint && codepoint <= 0xFFFF);\n        return codepoint;\n    }\n\n    /*!\n    @brief check if the next byte(s) are inside a given range\n\n    Adds the current byte and, for each passed range, reads a new byte and\n    checks if it is inside the range. If a violation was detected, set up an\n    error message and return false. Otherwise, return true.\n\n    @param[in] ranges  list of integers; interpreted as list of pairs of\n                       inclusive lower and upper bound, respectively\n\n    @pre The passed list @a ranges must have 2, 4, or 6 elements; that is,\n         1, 2, or 3 pairs. This precondition is enforced by an assertion.\n\n    @return true if and only if no range violation was detected\n    */\n    bool next_byte_in_range(std::initializer_list<char_int_type> ranges)\n    {\n        JSON_ASSERT(ranges.size() == 2 || ranges.size() == 4 || ranges.size() == 6);\n        add(current);\n\n        for (auto range = ranges.begin(); range != ranges.end(); ++range)\n        {\n            get();\n            if (JSON_HEDLEY_LIKELY(*range <= current && current <= *(++range)))\n            {\n                add(current);\n            }\n            else\n            {\n                error_message = \"invalid string: ill-formed UTF-8 byte\";\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /*!\n    @brief scan a string literal\n\n    This function scans a string according to Sect. 7 of RFC 8259. While\n    scanning, bytes are escaped and copied into buffer token_buffer. Then the\n    function returns successfully, token_buffer is *not* null-terminated (as it\n    may contain \\0 bytes), and token_buffer.size() is the number of bytes in the\n    string.\n\n    @return token_type::value_string if string could be successfully scanned,\n            token_type::parse_error otherwise\n\n    @note In case of errors, variable error_message contains a textual\n          description.\n    */\n    token_type scan_string()\n    {\n        // reset token_buffer (ignore opening quote)\n        reset();\n\n        // we entered the function by reading an open quote\n        JSON_ASSERT(current == '\\\"');\n\n        while (true)\n        {\n            // get next character\n            switch (get())\n            {\n                // end of file while parsing string\n                case std::char_traits<char_type>::eof():\n                {\n                    error_message = \"invalid string: missing closing quote\";\n                    return token_type::parse_error;\n                }\n\n                // closing quote\n                case '\\\"':\n                {\n                    return token_type::value_string;\n                }\n\n                // escapes\n                case '\\\\':\n                {\n                    switch (get())\n                    {\n                        // quotation mark\n                        case '\\\"':\n                            add('\\\"');\n                            break;\n                        // reverse solidus\n                        case '\\\\':\n                            add('\\\\');\n                            break;\n                        // solidus\n                        case '/':\n                            add('/');\n                            break;\n                        // backspace\n                        case 'b':\n                            add('\\b');\n                            break;\n                        // form feed\n                        case 'f':\n                            add('\\f');\n                            break;\n                        // line feed\n                        case 'n':\n                            add('\\n');\n                            break;\n                        // carriage return\n                        case 'r':\n                            add('\\r');\n                            break;\n                        // tab\n                        case 't':\n                            add('\\t');\n                            break;\n\n                        // unicode escapes\n                        case 'u':\n                        {\n                            const int codepoint1 = get_codepoint();\n                            int codepoint = codepoint1; // start with codepoint1\n\n                            if (JSON_HEDLEY_UNLIKELY(codepoint1 == -1))\n                            {\n                                error_message = \"invalid string: '\\\\u' must be followed by 4 hex digits\";\n                                return token_type::parse_error;\n                            }\n\n                            // check if code point is a high surrogate\n                            if (0xD800 <= codepoint1 && codepoint1 <= 0xDBFF)\n                            {\n                                // expect next \\uxxxx entry\n                                if (JSON_HEDLEY_LIKELY(get() == '\\\\' && get() == 'u'))\n                                {\n                                    const int codepoint2 = get_codepoint();\n\n                                    if (JSON_HEDLEY_UNLIKELY(codepoint2 == -1))\n                                    {\n                                        error_message = \"invalid string: '\\\\u' must be followed by 4 hex digits\";\n                                        return token_type::parse_error;\n                                    }\n\n                                    // check if codepoint2 is a low surrogate\n                                    if (JSON_HEDLEY_LIKELY(0xDC00 <= codepoint2 && codepoint2 <= 0xDFFF))\n                                    {\n                                        // overwrite codepoint\n                                        codepoint = static_cast<int>(\n                                                        // high surrogate occupies the most significant 22 bits\n                                                        (static_cast<unsigned int>(codepoint1) << 10u)\n                                                        // low surrogate occupies the least significant 15 bits\n                                                        + static_cast<unsigned int>(codepoint2)\n                                                        // there is still the 0xD800, 0xDC00 and 0x10000 noise\n                                                        // in the result, so we have to subtract with:\n                                                        // (0xD800 << 10) + DC00 - 0x10000 = 0x35FDC00\n                                                        - 0x35FDC00u);\n                                    }\n                                    else\n                                    {\n                                        error_message = \"invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF\";\n                                        return token_type::parse_error;\n                                    }\n                                }\n                                else\n                                {\n                                    error_message = \"invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF\";\n                                    return token_type::parse_error;\n                                }\n                            }\n                            else\n                            {\n                                if (JSON_HEDLEY_UNLIKELY(0xDC00 <= codepoint1 && codepoint1 <= 0xDFFF))\n                                {\n                                    error_message = \"invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF\";\n                                    return token_type::parse_error;\n                                }\n                            }\n\n                            // result of the above calculation yields a proper codepoint\n                            JSON_ASSERT(0x00 <= codepoint && codepoint <= 0x10FFFF);\n\n                            // translate codepoint into bytes\n                            if (codepoint < 0x80)\n                            {\n                                // 1-byte characters: 0xxxxxxx (ASCII)\n                                add(static_cast<char_int_type>(codepoint));\n                            }\n                            else if (codepoint <= 0x7FF)\n                            {\n                                // 2-byte characters: 110xxxxx 10xxxxxx\n                                add(static_cast<char_int_type>(0xC0u | (static_cast<unsigned int>(codepoint) >> 6u)));\n                                add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));\n                            }\n                            else if (codepoint <= 0xFFFF)\n                            {\n                                // 3-byte characters: 1110xxxx 10xxxxxx 10xxxxxx\n                                add(static_cast<char_int_type>(0xE0u | (static_cast<unsigned int>(codepoint) >> 12u)));\n                                add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 6u) & 0x3Fu)));\n                                add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));\n                            }\n                            else\n                            {\n                                // 4-byte characters: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n                                add(static_cast<char_int_type>(0xF0u | (static_cast<unsigned int>(codepoint) >> 18u)));\n                                add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 12u) & 0x3Fu)));\n                                add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 6u) & 0x3Fu)));\n                                add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));\n                            }\n\n                            break;\n                        }\n\n                        // other characters after escape\n                        default:\n                            error_message = \"invalid string: forbidden character after backslash\";\n                            return token_type::parse_error;\n                    }\n\n                    break;\n                }\n\n                // invalid control characters\n                case 0x00:\n                {\n                    error_message = \"invalid string: control character U+0000 (NUL) must be escaped to \\\\u0000\";\n                    return token_type::parse_error;\n                }\n\n                case 0x01:\n                {\n                    error_message = \"invalid string: control character U+0001 (SOH) must be escaped to \\\\u0001\";\n                    return token_type::parse_error;\n                }\n\n                case 0x02:\n                {\n                    error_message = \"invalid string: control character U+0002 (STX) must be escaped to \\\\u0002\";\n                    return token_type::parse_error;\n                }\n\n                case 0x03:\n                {\n                    error_message = \"invalid string: control character U+0003 (ETX) must be escaped to \\\\u0003\";\n                    return token_type::parse_error;\n                }\n\n                case 0x04:\n                {\n                    error_message = \"invalid string: control character U+0004 (EOT) must be escaped to \\\\u0004\";\n                    return token_type::parse_error;\n                }\n\n                case 0x05:\n                {\n                    error_message = \"invalid string: control character U+0005 (ENQ) must be escaped to \\\\u0005\";\n                    return token_type::parse_error;\n                }\n\n                case 0x06:\n                {\n                    error_message = \"invalid string: control character U+0006 (ACK) must be escaped to \\\\u0006\";\n                    return token_type::parse_error;\n                }\n\n                case 0x07:\n                {\n                    error_message = \"invalid string: control character U+0007 (BEL) must be escaped to \\\\u0007\";\n                    return token_type::parse_error;\n                }\n\n                case 0x08:\n                {\n                    error_message = \"invalid string: control character U+0008 (BS) must be escaped to \\\\u0008 or \\\\b\";\n                    return token_type::parse_error;\n                }\n\n                case 0x09:\n                {\n                    error_message = \"invalid string: control character U+0009 (HT) must be escaped to \\\\u0009 or \\\\t\";\n                    return token_type::parse_error;\n                }\n\n                case 0x0A:\n                {\n                    error_message = \"invalid string: control character U+000A (LF) must be escaped to \\\\u000A or \\\\n\";\n                    return token_type::parse_error;\n                }\n\n                case 0x0B:\n                {\n                    error_message = \"invalid string: control character U+000B (VT) must be escaped to \\\\u000B\";\n                    return token_type::parse_error;\n                }\n\n                case 0x0C:\n                {\n                    error_message = \"invalid string: control character U+000C (FF) must be escaped to \\\\u000C or \\\\f\";\n                    return token_type::parse_error;\n                }\n\n                case 0x0D:\n                {\n                    error_message = \"invalid string: control character U+000D (CR) must be escaped to \\\\u000D or \\\\r\";\n                    return token_type::parse_error;\n                }\n\n                case 0x0E:\n                {\n                    error_message = \"invalid string: control character U+000E (SO) must be escaped to \\\\u000E\";\n                    return token_type::parse_error;\n                }\n\n                case 0x0F:\n                {\n                    error_message = \"invalid string: control character U+000F (SI) must be escaped to \\\\u000F\";\n                    return token_type::parse_error;\n                }\n\n                case 0x10:\n                {\n                    error_message = \"invalid string: control character U+0010 (DLE) must be escaped to \\\\u0010\";\n                    return token_type::parse_error;\n                }\n\n                case 0x11:\n                {\n                    error_message = \"invalid string: control character U+0011 (DC1) must be escaped to \\\\u0011\";\n                    return token_type::parse_error;\n                }\n\n                case 0x12:\n                {\n                    error_message = \"invalid string: control character U+0012 (DC2) must be escaped to \\\\u0012\";\n                    return token_type::parse_error;\n                }\n\n                case 0x13:\n                {\n                    error_message = \"invalid string: control character U+0013 (DC3) must be escaped to \\\\u0013\";\n                    return token_type::parse_error;\n                }\n\n                case 0x14:\n                {\n                    error_message = \"invalid string: control character U+0014 (DC4) must be escaped to \\\\u0014\";\n                    return token_type::parse_error;\n                }\n\n                case 0x15:\n                {\n                    error_message = \"invalid string: control character U+0015 (NAK) must be escaped to \\\\u0015\";\n                    return token_type::parse_error;\n                }\n\n                case 0x16:\n                {\n                    error_message = \"invalid string: control character U+0016 (SYN) must be escaped to \\\\u0016\";\n                    return token_type::parse_error;\n                }\n\n                case 0x17:\n                {\n                    error_message = \"invalid string: control character U+0017 (ETB) must be escaped to \\\\u0017\";\n                    return token_type::parse_error;\n                }\n\n                case 0x18:\n                {\n                    error_message = \"invalid string: control character U+0018 (CAN) must be escaped to \\\\u0018\";\n                    return token_type::parse_error;\n                }\n\n                case 0x19:\n                {\n                    error_message = \"invalid string: control character U+0019 (EM) must be escaped to \\\\u0019\";\n                    return token_type::parse_error;\n                }\n\n                case 0x1A:\n                {\n                    error_message = \"invalid string: control character U+001A (SUB) must be escaped to \\\\u001A\";\n                    return token_type::parse_error;\n                }\n\n                case 0x1B:\n                {\n                    error_message = \"invalid string: control character U+001B (ESC) must be escaped to \\\\u001B\";\n                    return token_type::parse_error;\n                }\n\n                case 0x1C:\n                {\n                    error_message = \"invalid string: control character U+001C (FS) must be escaped to \\\\u001C\";\n                    return token_type::parse_error;\n                }\n\n                case 0x1D:\n                {\n                    error_message = \"invalid string: control character U+001D (GS) must be escaped to \\\\u001D\";\n                    return token_type::parse_error;\n                }\n\n                case 0x1E:\n                {\n                    error_message = \"invalid string: control character U+001E (RS) must be escaped to \\\\u001E\";\n                    return token_type::parse_error;\n                }\n\n                case 0x1F:\n                {\n                    error_message = \"invalid string: control character U+001F (US) must be escaped to \\\\u001F\";\n                    return token_type::parse_error;\n                }\n\n                // U+0020..U+007F (except U+0022 (quote) and U+005C (backspace))\n                case 0x20:\n                case 0x21:\n                case 0x23:\n                case 0x24:\n                case 0x25:\n                case 0x26:\n                case 0x27:\n                case 0x28:\n                case 0x29:\n                case 0x2A:\n                case 0x2B:\n                case 0x2C:\n                case 0x2D:\n                case 0x2E:\n                case 0x2F:\n                case 0x30:\n                case 0x31:\n                case 0x32:\n                case 0x33:\n                case 0x34:\n                case 0x35:\n                case 0x36:\n                case 0x37:\n                case 0x38:\n                case 0x39:\n                case 0x3A:\n                case 0x3B:\n                case 0x3C:\n                case 0x3D:\n                case 0x3E:\n                case 0x3F:\n                case 0x40:\n                case 0x41:\n                case 0x42:\n                case 0x43:\n                case 0x44:\n                case 0x45:\n                case 0x46:\n                case 0x47:\n                case 0x48:\n                case 0x49:\n                case 0x4A:\n                case 0x4B:\n                case 0x4C:\n                case 0x4D:\n                case 0x4E:\n                case 0x4F:\n                case 0x50:\n                case 0x51:\n                case 0x52:\n                case 0x53:\n                case 0x54:\n                case 0x55:\n                case 0x56:\n                case 0x57:\n                case 0x58:\n                case 0x59:\n                case 0x5A:\n                case 0x5B:\n                case 0x5D:\n                case 0x5E:\n                case 0x5F:\n                case 0x60:\n                case 0x61:\n                case 0x62:\n                case 0x63:\n                case 0x64:\n                case 0x65:\n                case 0x66:\n                case 0x67:\n                case 0x68:\n                case 0x69:\n                case 0x6A:\n                case 0x6B:\n                case 0x6C:\n                case 0x6D:\n                case 0x6E:\n                case 0x6F:\n                case 0x70:\n                case 0x71:\n                case 0x72:\n                case 0x73:\n                case 0x74:\n                case 0x75:\n                case 0x76:\n                case 0x77:\n                case 0x78:\n                case 0x79:\n                case 0x7A:\n                case 0x7B:\n                case 0x7C:\n                case 0x7D:\n                case 0x7E:\n                case 0x7F:\n                {\n                    add(current);\n                    break;\n                }\n\n                // U+0080..U+07FF: bytes C2..DF 80..BF\n                case 0xC2:\n                case 0xC3:\n                case 0xC4:\n                case 0xC5:\n                case 0xC6:\n                case 0xC7:\n                case 0xC8:\n                case 0xC9:\n                case 0xCA:\n                case 0xCB:\n                case 0xCC:\n                case 0xCD:\n                case 0xCE:\n                case 0xCF:\n                case 0xD0:\n                case 0xD1:\n                case 0xD2:\n                case 0xD3:\n                case 0xD4:\n                case 0xD5:\n                case 0xD6:\n                case 0xD7:\n                case 0xD8:\n                case 0xD9:\n                case 0xDA:\n                case 0xDB:\n                case 0xDC:\n                case 0xDD:\n                case 0xDE:\n                case 0xDF:\n                {\n                    if (JSON_HEDLEY_UNLIKELY(!next_byte_in_range({0x80, 0xBF})))\n                    {\n                        return token_type::parse_error;\n                    }\n                    break;\n                }\n\n                // U+0800..U+0FFF: bytes E0 A0..BF 80..BF\n                case 0xE0:\n                {\n                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0xA0, 0xBF, 0x80, 0xBF}))))\n                    {\n                        return token_type::parse_error;\n                    }\n                    break;\n                }\n\n                // U+1000..U+CFFF: bytes E1..EC 80..BF 80..BF\n                // U+E000..U+FFFF: bytes EE..EF 80..BF 80..BF\n                case 0xE1:\n                case 0xE2:\n                case 0xE3:\n                case 0xE4:\n                case 0xE5:\n                case 0xE6:\n                case 0xE7:\n                case 0xE8:\n                case 0xE9:\n                case 0xEA:\n                case 0xEB:\n                case 0xEC:\n                case 0xEE:\n                case 0xEF:\n                {\n                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0xBF, 0x80, 0xBF}))))\n                    {\n                        return token_type::parse_error;\n                    }\n                    break;\n                }\n\n                // U+D000..U+D7FF: bytes ED 80..9F 80..BF\n                case 0xED:\n                {\n                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0x9F, 0x80, 0xBF}))))\n                    {\n                        return token_type::parse_error;\n                    }\n                    break;\n                }\n\n                // U+10000..U+3FFFF F0 90..BF 80..BF 80..BF\n                case 0xF0:\n                {\n                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x90, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))\n                    {\n                        return token_type::parse_error;\n                    }\n                    break;\n                }\n\n                // U+40000..U+FFFFF F1..F3 80..BF 80..BF 80..BF\n                case 0xF1:\n                case 0xF2:\n                case 0xF3:\n                {\n                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))\n                    {\n                        return token_type::parse_error;\n                    }\n                    break;\n                }\n\n                // U+100000..U+10FFFF F4 80..8F 80..BF 80..BF\n                case 0xF4:\n                {\n                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0x8F, 0x80, 0xBF, 0x80, 0xBF}))))\n                    {\n                        return token_type::parse_error;\n                    }\n                    break;\n                }\n\n                // remaining bytes (80..C1 and F5..FF) are ill-formed\n                default:\n                {\n                    error_message = \"invalid string: ill-formed UTF-8 byte\";\n                    return token_type::parse_error;\n                }\n            }\n        }\n    }\n\n    /*!\n     * @brief scan a comment\n     * @return whether comment could be scanned successfully\n     */\n    bool scan_comment()\n    {\n        switch (get())\n        {\n            // single-line comments skip input until a newline or EOF is read\n            case '/':\n            {\n                while (true)\n                {\n                    switch (get())\n                    {\n                        case '\\n':\n                        case '\\r':\n                        case std::char_traits<char_type>::eof():\n                        case '\\0':\n                            return true;\n\n                        default:\n                            break;\n                    }\n                }\n            }\n\n            // multi-line comments skip input until */ is read\n            case '*':\n            {\n                while (true)\n                {\n                    switch (get())\n                    {\n                        case std::char_traits<char_type>::eof():\n                        case '\\0':\n                        {\n                            error_message = \"invalid comment; missing closing '*/'\";\n                            return false;\n                        }\n\n                        case '*':\n                        {\n                            switch (get())\n                            {\n                                case '/':\n                                    return true;\n\n                                default:\n                                {\n                                    unget();\n                                    continue;\n                                }\n                            }\n                        }\n\n                        default:\n                            continue;\n                    }\n                }\n            }\n\n            // unexpected character after reading '/'\n            default:\n            {\n                error_message = \"invalid comment; expecting '/' or '*' after '/'\";\n                return false;\n            }\n        }\n    }\n\n    JSON_HEDLEY_NON_NULL(2)\n    static void strtof(float& f, const char* str, char** endptr) noexcept\n    {\n        f = std::strtof(str, endptr);\n    }\n\n    JSON_HEDLEY_NON_NULL(2)\n    static void strtof(double& f, const char* str, char** endptr) noexcept\n    {\n        f = std::strtod(str, endptr);\n    }\n\n    JSON_HEDLEY_NON_NULL(2)\n    static void strtof(long double& f, const char* str, char** endptr) noexcept\n    {\n        f = std::strtold(str, endptr);\n    }\n\n    /*!\n    @brief scan a number literal\n\n    This function scans a string according to Sect. 6 of RFC 8259.\n\n    The function is realized with a deterministic finite state machine derived\n    from the grammar described in RFC 8259. Starting in state \"init\", the\n    input is read and used to determined the next state. Only state \"done\"\n    accepts the number. State \"error\" is a trap state to model errors. In the\n    table below, \"anything\" means any character but the ones listed before.\n\n    state    | 0        | 1-9      | e E      | +       | -       | .        | anything\n    ---------|----------|----------|----------|---------|---------|----------|-----------\n    init     | zero     | any1     | [error]  | [error] | minus   | [error]  | [error]\n    minus    | zero     | any1     | [error]  | [error] | [error] | [error]  | [error]\n    zero     | done     | done     | exponent | done    | done    | decimal1 | done\n    any1     | any1     | any1     | exponent | done    | done    | decimal1 | done\n    decimal1 | decimal2 | decimal2 | [error]  | [error] | [error] | [error]  | [error]\n    decimal2 | decimal2 | decimal2 | exponent | done    | done    | done     | done\n    exponent | any2     | any2     | [error]  | sign    | sign    | [error]  | [error]\n    sign     | any2     | any2     | [error]  | [error] | [error] | [error]  | [error]\n    any2     | any2     | any2     | done     | done    | done    | done     | done\n\n    The state machine is realized with one label per state (prefixed with\n    \"scan_number_\") and `goto` statements between them. The state machine\n    contains cycles, but any cycle can be left when EOF is read. Therefore,\n    the function is guaranteed to terminate.\n\n    During scanning, the read bytes are stored in token_buffer. This string is\n    then converted to a signed integer, an unsigned integer, or a\n    floating-point number.\n\n    @return token_type::value_unsigned, token_type::value_integer, or\n            token_type::value_float if number could be successfully scanned,\n            token_type::parse_error otherwise\n\n    @note The scanner is independent of the current locale. Internally, the\n          locale's decimal point is used instead of `.` to work with the\n          locale-dependent converters.\n    */\n    token_type scan_number()  // lgtm [cpp/use-of-goto]\n    {\n        // reset token_buffer to store the number's bytes\n        reset();\n\n        // the type of the parsed number; initially set to unsigned; will be\n        // changed if minus sign, decimal point or exponent is read\n        token_type number_type = token_type::value_unsigned;\n\n        // state (init): we just found out we need to scan a number\n        switch (current)\n        {\n            case '-':\n            {\n                add(current);\n                goto scan_number_minus;\n            }\n\n            case '0':\n            {\n                add(current);\n                goto scan_number_zero;\n            }\n\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            {\n                add(current);\n                goto scan_number_any1;\n            }\n\n            // all other characters are rejected outside scan_number()\n            default:            // LCOV_EXCL_LINE\n                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE\n        }\n\nscan_number_minus:\n        // state: we just parsed a leading minus sign\n        number_type = token_type::value_integer;\n        switch (get())\n        {\n            case '0':\n            {\n                add(current);\n                goto scan_number_zero;\n            }\n\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            {\n                add(current);\n                goto scan_number_any1;\n            }\n\n            default:\n            {\n                error_message = \"invalid number; expected digit after '-'\";\n                return token_type::parse_error;\n            }\n        }\n\nscan_number_zero:\n        // state: we just parse a zero (maybe with a leading minus sign)\n        switch (get())\n        {\n            case '.':\n            {\n                add(decimal_point_char);\n                goto scan_number_decimal1;\n            }\n\n            case 'e':\n            case 'E':\n            {\n                add(current);\n                goto scan_number_exponent;\n            }\n\n            default:\n                goto scan_number_done;\n        }\n\nscan_number_any1:\n        // state: we just parsed a number 0-9 (maybe with a leading minus sign)\n        switch (get())\n        {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            {\n                add(current);\n                goto scan_number_any1;\n            }\n\n            case '.':\n            {\n                add(decimal_point_char);\n                goto scan_number_decimal1;\n            }\n\n            case 'e':\n            case 'E':\n            {\n                add(current);\n                goto scan_number_exponent;\n            }\n\n            default:\n                goto scan_number_done;\n        }\n\nscan_number_decimal1:\n        // state: we just parsed a decimal point\n        number_type = token_type::value_float;\n        switch (get())\n        {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            {\n                add(current);\n                goto scan_number_decimal2;\n            }\n\n            default:\n            {\n                error_message = \"invalid number; expected digit after '.'\";\n                return token_type::parse_error;\n            }\n        }\n\nscan_number_decimal2:\n        // we just parsed at least one number after a decimal point\n        switch (get())\n        {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            {\n                add(current);\n                goto scan_number_decimal2;\n            }\n\n            case 'e':\n            case 'E':\n            {\n                add(current);\n                goto scan_number_exponent;\n            }\n\n            default:\n                goto scan_number_done;\n        }\n\nscan_number_exponent:\n        // we just parsed an exponent\n        number_type = token_type::value_float;\n        switch (get())\n        {\n            case '+':\n            case '-':\n            {\n                add(current);\n                goto scan_number_sign;\n            }\n\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            {\n                add(current);\n                goto scan_number_any2;\n            }\n\n            default:\n            {\n                error_message =\n                    \"invalid number; expected '+', '-', or digit after exponent\";\n                return token_type::parse_error;\n            }\n        }\n\nscan_number_sign:\n        // we just parsed an exponent sign\n        switch (get())\n        {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            {\n                add(current);\n                goto scan_number_any2;\n            }\n\n            default:\n            {\n                error_message = \"invalid number; expected digit after exponent sign\";\n                return token_type::parse_error;\n            }\n        }\n\nscan_number_any2:\n        // we just parsed a number after the exponent or exponent sign\n        switch (get())\n        {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            {\n                add(current);\n                goto scan_number_any2;\n            }\n\n            default:\n                goto scan_number_done;\n        }\n\nscan_number_done:\n        // unget the character after the number (we only read it to know that\n        // we are done scanning a number)\n        unget();\n\n        char* endptr = nullptr; // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)\n        errno = 0;\n\n        // try to parse integers first and fall back to floats\n        if (number_type == token_type::value_unsigned)\n        {\n            const auto x = std::strtoull(token_buffer.data(), &endptr, 10);\n\n            // we checked the number format before\n            JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());\n\n            if (errno == 0)\n            {\n                value_unsigned = static_cast<number_unsigned_t>(x);\n                if (value_unsigned == x)\n                {\n                    return token_type::value_unsigned;\n                }\n            }\n        }\n        else if (number_type == token_type::value_integer)\n        {\n            const auto x = std::strtoll(token_buffer.data(), &endptr, 10);\n\n            // we checked the number format before\n            JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());\n\n            if (errno == 0)\n            {\n                value_integer = static_cast<number_integer_t>(x);\n                if (value_integer == x)\n                {\n                    return token_type::value_integer;\n                }\n            }\n        }\n\n        // this code is reached if we parse a floating-point number or if an\n        // integer conversion above failed\n        strtof(value_float, token_buffer.data(), &endptr);\n\n        // we checked the number format before\n        JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());\n\n        return token_type::value_float;\n    }\n\n    /*!\n    @param[in] literal_text  the literal text to expect\n    @param[in] length        the length of the passed literal text\n    @param[in] return_type   the token type to return on success\n    */\n    JSON_HEDLEY_NON_NULL(2)\n    token_type scan_literal(const char_type* literal_text, const std::size_t length,\n                            token_type return_type)\n    {\n        JSON_ASSERT(std::char_traits<char_type>::to_char_type(current) == literal_text[0]);\n        for (std::size_t i = 1; i < length; ++i)\n        {\n            if (JSON_HEDLEY_UNLIKELY(std::char_traits<char_type>::to_char_type(get()) != literal_text[i]))\n            {\n                error_message = \"invalid literal\";\n                return token_type::parse_error;\n            }\n        }\n        return return_type;\n    }\n\n    /////////////////////\n    // input management\n    /////////////////////\n\n    /// reset token_buffer; current character is beginning of token\n    void reset() noexcept\n    {\n        token_buffer.clear();\n        token_string.clear();\n        token_string.push_back(std::char_traits<char_type>::to_char_type(current));\n    }\n\n    /*\n    @brief get next character from the input\n\n    This function provides the interface to the used input adapter. It does\n    not throw in case the input reached EOF, but returns a\n    `std::char_traits<char>::eof()` in that case.  Stores the scanned characters\n    for use in error messages.\n\n    @return character read from the input\n    */\n    char_int_type get()\n    {\n        ++position.chars_read_total;\n        ++position.chars_read_current_line;\n\n        if (next_unget)\n        {\n            // just reset the next_unget variable and work with current\n            next_unget = false;\n        }\n        else\n        {\n            current = ia.get_character();\n        }\n\n        if (JSON_HEDLEY_LIKELY(current != std::char_traits<char_type>::eof()))\n        {\n            token_string.push_back(std::char_traits<char_type>::to_char_type(current));\n        }\n\n        if (current == '\\n')\n        {\n            ++position.lines_read;\n            position.chars_read_current_line = 0;\n        }\n\n        return current;\n    }\n\n    /*!\n    @brief unget current character (read it again on next get)\n\n    We implement unget by setting variable next_unget to true. The input is not\n    changed - we just simulate ungetting by modifying chars_read_total,\n    chars_read_current_line, and token_string. The next call to get() will\n    behave as if the unget character is read again.\n    */\n    void unget()\n    {\n        next_unget = true;\n\n        --position.chars_read_total;\n\n        // in case we \"unget\" a newline, we have to also decrement the lines_read\n        if (position.chars_read_current_line == 0)\n        {\n            if (position.lines_read > 0)\n            {\n                --position.lines_read;\n            }\n        }\n        else\n        {\n            --position.chars_read_current_line;\n        }\n\n        if (JSON_HEDLEY_LIKELY(current != std::char_traits<char_type>::eof()))\n        {\n            JSON_ASSERT(!token_string.empty());\n            token_string.pop_back();\n        }\n    }\n\n    /// add a character to token_buffer\n    void add(char_int_type c)\n    {\n        token_buffer.push_back(static_cast<typename string_t::value_type>(c));\n    }\n\n  public:\n    /////////////////////\n    // value getters\n    /////////////////////\n\n    /// return integer value\n    constexpr number_integer_t get_number_integer() const noexcept\n    {\n        return value_integer;\n    }\n\n    /// return unsigned integer value\n    constexpr number_unsigned_t get_number_unsigned() const noexcept\n    {\n        return value_unsigned;\n    }\n\n    /// return floating-point value\n    constexpr number_float_t get_number_float() const noexcept\n    {\n        return value_float;\n    }\n\n    /// return current string value (implicitly resets the token; useful only once)\n    string_t& get_string()\n    {\n        return token_buffer;\n    }\n\n    /////////////////////\n    // diagnostics\n    /////////////////////\n\n    /// return position of last read token\n    constexpr position_t get_position() const noexcept\n    {\n        return position;\n    }\n\n    /// return the last read token (for errors only).  Will never contain EOF\n    /// (an arbitrary value that is not a valid char value, often -1), because\n    /// 255 may legitimately occur.  May contain NUL, which should be escaped.\n    std::string get_token_string() const\n    {\n        // escape control characters\n        std::string result;\n        for (const auto c : token_string)\n        {\n            if (static_cast<unsigned char>(c) <= '\\x1F')\n            {\n                // escape control characters\n                std::array<char, 9> cs{{}};\n                static_cast<void>((std::snprintf)(cs.data(), cs.size(), \"<U+%.4X>\", static_cast<unsigned char>(c))); // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)\n                result += cs.data();\n            }\n            else\n            {\n                // add character as is\n                result.push_back(static_cast<std::string::value_type>(c));\n            }\n        }\n\n        return result;\n    }\n\n    /// return syntax error message\n    JSON_HEDLEY_RETURNS_NON_NULL\n    constexpr const char* get_error_message() const noexcept\n    {\n        return error_message;\n    }\n\n    /////////////////////\n    // actual scanner\n    /////////////////////\n\n    /*!\n    @brief skip the UTF-8 byte order mark\n    @return true iff there is no BOM or the correct BOM has been skipped\n    */\n    bool skip_bom()\n    {\n        if (get() == 0xEF)\n        {\n            // check if we completely parse the BOM\n            return get() == 0xBB && get() == 0xBF;\n        }\n\n        // the first character is not the beginning of the BOM; unget it to\n        // process is later\n        unget();\n        return true;\n    }\n\n    void skip_whitespace()\n    {\n        do\n        {\n            get();\n        }\n        while (current == ' ' || current == '\\t' || current == '\\n' || current == '\\r');\n    }\n\n    token_type scan()\n    {\n        // initially, skip the BOM\n        if (position.chars_read_total == 0 && !skip_bom())\n        {\n            error_message = \"invalid BOM; must be 0xEF 0xBB 0xBF if given\";\n            return token_type::parse_error;\n        }\n\n        // read next character and ignore whitespace\n        skip_whitespace();\n\n        // ignore comments\n        while (ignore_comments && current == '/')\n        {\n            if (!scan_comment())\n            {\n                return token_type::parse_error;\n            }\n\n            // skip following whitespace\n            skip_whitespace();\n        }\n\n        switch (current)\n        {\n            // structural characters\n            case '[':\n                return token_type::begin_array;\n            case ']':\n                return token_type::end_array;\n            case '{':\n                return token_type::begin_object;\n            case '}':\n                return token_type::end_object;\n            case ':':\n                return token_type::name_separator;\n            case ',':\n                return token_type::value_separator;\n\n            // literals\n            case 't':\n            {\n                std::array<char_type, 4> true_literal = {{static_cast<char_type>('t'), static_cast<char_type>('r'), static_cast<char_type>('u'), static_cast<char_type>('e')}};\n                return scan_literal(true_literal.data(), true_literal.size(), token_type::literal_true);\n            }\n            case 'f':\n            {\n                std::array<char_type, 5> false_literal = {{static_cast<char_type>('f'), static_cast<char_type>('a'), static_cast<char_type>('l'), static_cast<char_type>('s'), static_cast<char_type>('e')}};\n                return scan_literal(false_literal.data(), false_literal.size(), token_type::literal_false);\n            }\n            case 'n':\n            {\n                std::array<char_type, 4> null_literal = {{static_cast<char_type>('n'), static_cast<char_type>('u'), static_cast<char_type>('l'), static_cast<char_type>('l')}};\n                return scan_literal(null_literal.data(), null_literal.size(), token_type::literal_null);\n            }\n\n            // string\n            case '\\\"':\n                return scan_string();\n\n            // number\n            case '-':\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                return scan_number();\n\n            // end of input (the null byte is needed when parsing from\n            // string literals)\n            case '\\0':\n            case std::char_traits<char_type>::eof():\n                return token_type::end_of_input;\n\n            // error\n            default:\n                error_message = \"invalid literal\";\n                return token_type::parse_error;\n        }\n    }\n\n  private:\n    /// input adapter\n    InputAdapterType ia;\n\n    /// whether comments should be ignored (true) or signaled as errors (false)\n    const bool ignore_comments = false;\n\n    /// the current character\n    char_int_type current = std::char_traits<char_type>::eof();\n\n    /// whether the next get() call should just return current\n    bool next_unget = false;\n\n    /// the start position of the current token\n    position_t position {};\n\n    /// raw input token string (for error messages)\n    std::vector<char_type> token_string {};\n\n    /// buffer for variable-length tokens (numbers, strings)\n    string_t token_buffer {};\n\n    /// a description of occurred lexer errors\n    const char* error_message = \"\";\n\n    // number values\n    number_integer_t value_integer = 0;\n    number_unsigned_t value_unsigned = 0;\n    number_float_t value_float = 0;\n\n    /// the decimal point\n    const char_int_type decimal_point_char = '.';\n};\n}  // namespace detail\n}  // namespace nlohmann\n\n// #include <nlohmann/detail/macro_scope.hpp>\n\n// #include <nlohmann/detail/meta/is_sax.hpp>\n\n\n#include <cstdint> // size_t\n#include <utility> // declval\n#include <string> // string\n\n// #include <nlohmann/detail/meta/detected.hpp>\n\n// #include <nlohmann/detail/meta/type_traits.hpp>\n\n\nnamespace nlohmann\n{\nnamespace detail\n{\ntemplate<typename T>\nusing null_function_t = decltype(std::declval<T&>().null());\n\ntemplate<typename T>\nusing boolean_function_t =\n    decltype(std::declval<T&>().boolean(std::declval<bool>()));\n\ntemplate<typename T, typename Integer>\nusing number_integer_function_t =\n    decltype(std::declval<T&>().number_integer(std::declval<Integer>()));\n\ntemplate<typename T, typename Unsigned>\nusing number_unsigned_function_t =\n    decltype(std::declval<T&>().number_unsigned(std::declval<Unsigned>()));\n\ntemplate<typename T, typename Float, typename String>\nusing number_float_function_t = decltype(std::declval<T&>().number_float(\n                                    std::declval<Float>(), std::declval<const String&>()));\n\ntemplate<typename T, typename String>\nusing string_function_t =\n    decltype(std::declval<T&>().string(std::declval<String&>()));\n\ntemplate<typename T, typename Binary>\nusing binary_function_t =\n    decltype(std::declval<T&>().binary(std::declval<Binary&>()));\n\ntemplate<typename T>\nusing start_object_function_t =\n    decltype(std::declval<T&>().start_object(std::declval<std::size_t>()));\n\ntemplate<typename T, typename String>\nusing key_function_t =\n    decltype(std::declval<T&>().key(std::declval<String&>()));\n\ntemplate<typename T>\nusing end_object_function_t = decltype(std::declval<T&>().end_object());\n\ntemplate<typename T>\nusing start_array_function_t =\n    decltype(std::declval<T&>().start_array(std::declval<std::size_t>()));\n\ntemplate<typename T>\nusing end_array_function_t = decltype(std::declval<T&>().end_array());\n\ntemplate<typename T, typename Exception>\nusing parse_error_function_t = decltype(std::declval<T&>().parse_error(\n        std::declval<std::size_t>(), std::declval<const std::string&>(),\n        std::declval<const Exception&>()));\n\ntemplate<typename SAX, typename BasicJsonType>\nstruct is_sax\n{\n  private:\n    static_assert(is_basic_json<BasicJsonType>::value,\n                  \"BasicJsonType must be of type basic_json<...>\");\n\n    using number_integer_t = typename BasicJsonType::number_integer_t;\n    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;\n    using number_float_t = typename BasicJsonType::number_float_t;\n    using string_t = typename BasicJsonType::string_t;\n    using binary_t = typename BasicJsonType::binary_t;\n    using exception_t = typename BasicJsonType::exception;\n\n  public:\n    static constexpr bool value =\n        is_detected_exact<bool, null_function_t, SAX>::value &&\n        is_detected_exact<bool, boolean_function_t, SAX>::value &&\n        is_detected_exact<bool, number_integer_function_t, SAX, number_integer_t>::value &&\n        is_detected_exact<bool, number_unsigned_function_t, SAX, number_unsigned_t>::value &&\n        is_detected_exact<bool, number_float_function_t, SAX, number_float_t, string_t>::value &&\n        is_detected_exact<bool, string_function_t, SAX, string_t>::value &&\n        is_detected_exact<bool, binary_function_t, SAX, binary_t>::value &&\n        is_detected_exact<bool, start_object_function_t, SAX>::value &&\n        is_detected_exact<bool, key_function_t, SAX, string_t>::value &&\n        is_detected_exact<bool, end_object_function_t, SAX>::value &&\n        is_detected_exact<bool, start_array_function_t, SAX>::value &&\n        is_detected_exact<bool, end_array_function_t, SAX>::value &&\n        is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value;\n};\n\ntemplate<typename SAX, typename BasicJsonType>\nstruct is_sax_static_asserts\n{\n  private:\n    static_assert(is_basic_json<BasicJsonType>::value,\n                  \"BasicJsonType must be of type basic_json<...>\");\n\n    using number_integer_t = typename BasicJsonType::number_integer_t;\n    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;\n    using number_float_t = typename BasicJsonType::number_float_t;\n    using string_t = typename BasicJsonType::string_t;\n    using binary_t = typename BasicJsonType::binary_t;\n    using exception_t = typename BasicJsonType::exception;\n\n  public:\n    static_assert(is_detected_exact<bool, null_function_t, SAX>::value,\n                  \"Missing/invalid function: bool null()\");\n    static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,\n                  \"Missing/invalid function: bool boolean(bool)\");\n    static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,\n                  \"Missing/invalid function: bool boolean(bool)\");\n    static_assert(\n        is_detected_exact<bool, number_integer_function_t, SAX,\n        number_integer_t>::value,\n        \"Missing/invalid function: bool number_integer(number_integer_t)\");\n    static_assert(\n        is_detected_exact<bool, number_unsigned_function_t, SAX,\n        number_unsigned_t>::value,\n        \"Missing/invalid function: bool number_unsigned(number_unsigned_t)\");\n    static_assert(is_detected_exact<bool, number_float_function_t, SAX,\n                  number_float_t, string_t>::value,\n                  \"Missing/invalid function: bool number_float(number_float_t, const string_t&)\");\n    static_assert(\n        is_detected_exact<bool, string_function_t, SAX, string_t>::value,\n        \"Missing/invalid function: bool string(string_t&)\");\n    static_assert(\n        is_detected_exact<bool, binary_function_t, SAX, binary_t>::value,\n        \"Missing/invalid function: bool binary(binary_t&)\");\n    static_assert(is_detected_exact<bool, start_object_function_t, SAX>::value,\n                  \"Missing/invalid function: bool start_object(std::size_t)\");\n    static_assert(is_detected_exact<bool, key_function_t, SAX, string_t>::value,\n                  \"Missing/invalid function: bool key(string_t&)\");\n    static_assert(is_detected_exact<bool, end_object_function_t, SAX>::value,\n                  \"Missing/invalid function: bool end_object()\");\n    static_assert(is_detected_exact<bool, start_array_function_t, SAX>::value,\n                  \"Missing/invalid function: bool start_array(std::size_t)\");\n    static_assert(is_detected_exact<bool, end_array_function_t, SAX>::value,\n                  \"Missing/invalid function: bool end_array()\");\n    static_assert(\n        is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value,\n        \"Missing/invalid function: bool parse_error(std::size_t, const \"\n        \"std::string&, const exception&)\");\n};\n}  // namespace detail\n}  // namespace nlohmann\n\n// #include <nlohmann/detail/meta/type_traits.hpp>\n\n// #include <nlohmann/detail/value_t.hpp>\n\n\nnamespace nlohmann\n{\nnamespace detail\n{\n\n/// how to treat CBOR tags\nenum class cbor_tag_handler_t\n{\n    error,   ///< throw a parse_error exception in case of a tag\n    ignore,  ///< ignore tags\n    store    ///< store tags as binary type\n};\n\n/*!\n@brief determine system byte order\n\n@return true if and only if system's byte order is little endian\n\n@note from https://stackoverflow.com/a/1001328/266378\n*/\nstatic inline bool little_endianness(int num = 1) noexcept\n{\n    return *reinterpret_cast<char*>(&num) == 1;\n}\n\n\n///////////////////\n// binary reader //\n///////////////////\n\n/*!\n@brief deserialization of CBOR, MessagePack, and UBJSON values\n*/\ntemplate<typename BasicJsonType, typename InputAdapterType, typename SAX = json_sax_dom_parser<BasicJsonType>>\nclass binary_reader\n{\n    using number_integer_t = typename BasicJsonType::number_integer_t;\n    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;\n    using number_float_t = typename BasicJsonType::number_float_t;\n    using string_t = typename BasicJsonType::string_t;\n    using binary_t = typename BasicJsonType::binary_t;\n    using json_sax_t = SAX;\n    using char_type = typename InputAdapterType::char_type;\n    using char_int_type = typename std::char_traits<char_type>::int_type;\n\n  public:\n    /*!\n    @brief create a binary reader\n\n    @param[in] adapter  input adapter to read from\n    */\n    explicit binary_reader(InputAdapterType&& adapter) noexcept : ia(std::move(adapter))\n    {\n        (void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};\n    }\n\n    // make class move-only\n    binary_reader(const binary_reader&) = delete;\n    binary_reader(binary_reader&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)\n    binary_reader& operator=(const binary_reader&) = delete;\n    binary_reader& operator=(binary_reader&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)\n    ~binary_reader() = default;\n\n    /*!\n    @param[in] format  the binary format to parse\n    @param[in] sax_    a SAX event processor\n    @param[in] strict  whether to expect the input to be consumed completed\n    @param[in] tag_handler  how to treat CBOR tags\n\n    @return whether parsing was successful\n    */\n    JSON_HEDLEY_NON_NULL(3)\n    bool sax_parse(const input_format_t format,\n                   json_sax_t* sax_,\n                   const bool strict = true,\n                   const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)\n    {\n        sax = sax_;\n        bool result = false;\n\n        switch (format)\n        {\n            case input_format_t::bson:\n                result = parse_bson_internal();\n                break;\n\n            case input_format_t::cbor:\n                result = parse_cbor_internal(true, tag_handler);\n                break;\n\n            case input_format_t::msgpack:\n                result = parse_msgpack_internal();\n                break;\n\n            case input_format_t::ubjson:\n                result = parse_ubjson_internal();\n                break;\n\n            case input_format_t::json: // LCOV_EXCL_LINE\n            default:            // LCOV_EXCL_LINE\n                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE\n        }\n\n        // strict mode: next byte must be EOF\n        if (result && strict)\n        {\n            if (format == input_format_t::ubjson)\n            {\n                get_ignore_noop();\n            }\n            else\n            {\n                get();\n            }\n\n            if (JSON_HEDLEY_UNLIKELY(current != std::char_traits<char_type>::eof()))\n            {\n                return sax->parse_error(chars_read, get_token_string(),\n                                        parse_error::create(110, chars_read, exception_message(format, \"expected end of input; last byte: 0x\" + get_token_string(), \"value\"), BasicJsonType()));\n            }\n        }\n\n        return result;\n    }\n\n  private:\n    //////////\n    // BSON //\n    //////////\n\n    /*!\n    @brief Reads in a BSON-object and passes it to the SAX-parser.\n    @return whether a valid BSON-value was passed to the SAX parser\n    */\n    bool parse_bson_internal()\n    {\n        std::int32_t document_size{};\n        get_number<std::int32_t, true>(input_format_t::bson, document_size);\n\n        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(static_cast<std::size_t>(-1))))\n        {\n            return false;\n        }\n\n        if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_list(/*is_array*/false)))\n        {\n            return false;\n        }\n\n        return sax->end_object();\n    }\n\n    /*!\n    @brief Parses a C-style string from the BSON input.\n    @param[in,out] result  A reference to the string variable where the read\n                            string is to be stored.\n    @return `true` if the \\x00-byte indicating the end of the string was\n             encountered before the EOF; false` indicates an unexpected EOF.\n    */\n    bool get_bson_cstr(string_t& result)\n    {\n        auto out = std::back_inserter(result);\n        while (true)\n        {\n            get();\n            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::bson, \"cstring\")))\n            {\n                return false;\n            }\n            if (current == 0x00)\n            {\n                return true;\n            }\n            *out++ = static_cast<typename string_t::value_type>(current);\n        }\n    }\n\n    /*!\n    @brief Parses a zero-terminated string of length @a len from the BSON\n           input.\n    @param[in] len  The length (including the zero-byte at the end) of the\n                    string to be read.\n    @param[in,out] result  A reference to the string variable where the read\n                            string is to be stored.\n    @tparam NumberType The type of the length @a len\n    @pre len >= 1\n    @return `true` if the string was successfully parsed\n    */\n    template<typename NumberType>\n    bool get_bson_string(const NumberType len, string_t& result)\n    {\n        if (JSON_HEDLEY_UNLIKELY(len < 1))\n        {\n            auto last_token = get_token_string();\n            return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::bson, \"string length must be at least 1, is \" + std::to_string(len), \"string\"), BasicJsonType()));\n        }\n\n        return get_string(input_format_t::bson, len - static_cast<NumberType>(1), result) && get() != std::char_traits<char_type>::eof();\n    }\n\n    /*!\n    @brief Parses a byte array input of length @a len from the BSON input.\n    @param[in] len  The length of the byte array to be read.\n    @param[in,out] result  A reference to the binary variable where the read\n                            array is to be stored.\n    @tparam NumberType The type of the length @a len\n    @pre len >= 0\n    @return `true` if the byte array was successfully parsed\n    */\n    template<typename NumberType>\n    bool get_bson_binary(const NumberType len, binary_t& result)\n    {\n        if (JSON_HEDLEY_UNLIKELY(len < 0))\n        {\n            auto last_token = get_token_string();\n            return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::bson, \"byte array length cannot be negative, is \" + std::to_string(len), \"binary\"), BasicJsonType()));\n        }\n\n        // All BSON binary values have a subtype\n        std::uint8_t subtype{};\n        get_number<std::uint8_t>(input_format_t::bson, subtype);\n        result.set_subtype(subtype);\n\n        return get_binary(input_format_t::bson, len, result);\n    }\n\n    /*!\n    @brief Read a BSON document element of the given @a element_type.\n    @param[in] element_type The BSON element type, c.f. http://bsonspec.org/spec.html\n    @param[in] element_type_parse_position The position in the input stream,\n               where the `element_type` was read.\n    @warning Not all BSON element types are supported yet. An unsupported\n             @a element_type will give rise to a parse_error.114:\n             Unsupported BSON record type 0x...\n    @return whether a valid BSON-object/array was passed to the SAX parser\n    */\n    bool parse_bson_element_internal(const char_int_type element_type,\n                                     const std::size_t element_type_parse_position)\n    {\n        switch (element_type)\n        {\n            case 0x01: // double\n            {\n                double number{};\n                return get_number<double, true>(input_format_t::bson, number) && sax->number_float(static_cast<number_float_t>(number), \"\");\n            }\n\n            case 0x02: // string\n            {\n                std::int32_t len{};\n                string_t value;\n                return get_number<std::int32_t, true>(input_format_t::bson, len) && get_bson_string(len, value) && sax->string(value);\n            }\n\n            case 0x03: // object\n            {\n                return parse_bson_internal();\n            }\n\n            case 0x04: // array\n            {\n                return parse_bson_array();\n            }\n\n            case 0x05: // binary\n            {\n                std::int32_t len{};\n                binary_t value;\n                return get_number<std::int32_t, true>(input_format_t::bson, len) && get_bson_binary(len, value) && sax->binary(value);\n            }\n\n            case 0x08: // boolean\n            {\n                return sax->boolean(get() != 0);\n            }\n\n            case 0x0A: // null\n            {\n                return sax->null();\n            }\n\n            case 0x10: // int32\n            {\n                std::int32_t value{};\n                return get_number<std::int32_t, true>(input_format_t::bson, value) && sax->number_integer(value);\n            }\n\n            case 0x12: // int64\n            {\n                std::int64_t value{};\n                return get_number<std::int64_t, true>(input_format_t::bson, value) && sax->number_integer(value);\n            }\n\n            default: // anything else not supported (yet)\n            {\n                std::array<char, 3> cr{{}};\n                static_cast<void>((std::snprintf)(cr.data(), cr.size(), \"%.2hhX\", static_cast<unsigned char>(element_type))); // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)\n                return sax->parse_error(element_type_parse_position, std::string(cr.data()), parse_error::create(114, element_type_parse_position, \"Unsupported BSON record type 0x\" + std::string(cr.data()), BasicJsonType()));\n            }\n        }\n    }\n\n    /*!\n    @brief Read a BSON element list (as specified in the BSON-spec)\n\n    The same binary layout is used for objects and arrays, hence it must be\n    indicated with the argument @a is_array which one is expected\n    (true --> array, false --> object).\n\n    @param[in] is_array Determines if the element list being read is to be\n                        treated as an object (@a is_array == false), or as an\n                        array (@a is_array == true).\n    @return whether a valid BSON-object/array was passed to the SAX parser\n    */\n    bool parse_bson_element_list(const bool is_array)\n    {\n        string_t key;\n\n        while (auto element_type = get())\n        {\n            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::bson, \"element list\")))\n            {\n                return false;\n            }\n\n            const std::size_t element_type_parse_position = chars_read;\n            if (JSON_HEDLEY_UNLIKELY(!get_bson_cstr(key)))\n            {\n                return false;\n            }\n\n            if (!is_array && !sax->key(key))\n            {\n                return false;\n            }\n\n            if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_internal(element_type, element_type_parse_position)))\n            {\n                return false;\n            }\n\n            // get_bson_cstr only appends\n            key.clear();\n        }\n\n        return true;\n    }\n\n    /*!\n    @brief Reads an array from the BSON input and passes it to the SAX-parser.\n    @return whether a valid BSON-array was passed to the SAX parser\n    */\n    bool parse_bson_array()\n    {\n        std::int32_t document_size{};\n        get_number<std::int32_t, true>(input_format_t::bson, document_size);\n\n        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(static_cast<std::size_t>(-1))))\n        {\n            return false;\n        }\n\n        if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_list(/*is_array*/true)))\n        {\n            return false;\n        }\n\n        return sax->end_array();\n    }\n\n    //////////\n    // CBOR //\n    //////////\n\n    /*!\n    @param[in] get_char  whether a new character should be retrieved from the\n                         input (true) or whether the last read character should\n                         be considered instead (false)\n    @param[in] tag_handler how CBOR tags should be treated\n\n    @return whether a valid CBOR value was passed to the SAX parser\n    */\n    bool parse_cbor_internal(const bool get_char,\n                             const cbor_tag_handler_t tag_handler)\n    {\n        switch (get_char ? get() : current)\n        {\n            // EOF\n            case std::char_traits<char_type>::eof():\n                return unexpect_eof(input_format_t::cbor, \"value\");\n\n            // Integer 0x00..0x17 (0..23)\n            case 0x00:\n            case 0x01:\n            case 0x02:\n            case 0x03:\n            case 0x04:\n            case 0x05:\n            case 0x06:\n            case 0x07:\n            case 0x08:\n            case 0x09:\n            case 0x0A:\n            case 0x0B:\n            case 0x0C:\n            case 0x0D:\n            case 0x0E:\n            case 0x0F:\n            case 0x10:\n            case 0x11:\n            case 0x12:\n            case 0x13:\n            case 0x14:\n            case 0x15:\n            case 0x16:\n            case 0x17:\n                return sax->number_unsigned(static_cast<number_unsigned_t>(current));\n\n            case 0x18: // Unsigned integer (one-byte uint8_t follows)\n            {\n                std::uint8_t number{};\n                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);\n            }\n\n            case 0x19: // Unsigned integer (two-byte uint16_t follows)\n            {\n                std::uint16_t number{};\n                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);\n            }\n\n            case 0x1A: // Unsigned integer (four-byte uint32_t follows)\n            {\n                std::uint32_t number{};\n                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);\n            }\n\n            case 0x1B: // Unsigned integer (eight-byte uint64_t follows)\n            {\n                std::uint64_t number{};\n                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);\n            }\n\n            // Negative integer -1-0x00..-1-0x17 (-1..-24)\n            case 0x20:\n            case 0x21:\n            case 0x22:\n            case 0x23:\n            case 0x24:\n            case 0x25:\n            case 0x26:\n            case 0x27:\n            case 0x28:\n            case 0x29:\n            case 0x2A:\n            case 0x2B:\n            case 0x2C:\n            case 0x2D:\n            case 0x2E:\n            case 0x2F:\n            case 0x30:\n            case 0x31:\n            case 0x32:\n            case 0x33:\n            case 0x34:\n            case 0x35:\n            case 0x36:\n            case 0x37:\n                return sax->number_integer(static_cast<std::int8_t>(0x20 - 1 - current));\n\n            case 0x38: // Negative integer (one-byte uint8_t follows)\n            {\n                std::uint8_t number{};\n                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);\n            }\n\n            case 0x39: // Negative integer -1-n (two-byte uint16_t follows)\n            {\n                std::uint16_t number{};\n                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);\n            }\n\n            case 0x3A: // Negative integer -1-n (four-byte uint32_t follows)\n            {\n                std::uint32_t number{};\n                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);\n            }\n\n            case 0x3B: // Negative integer -1-n (eight-byte uint64_t follows)\n            {\n                std::uint64_t number{};\n                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1)\n                        - static_cast<number_integer_t>(number));\n            }\n\n            // Binary data (0x00..0x17 bytes follow)\n            case 0x40:\n            case 0x41:\n            case 0x42:\n            case 0x43:\n            case 0x44:\n            case 0x45:\n            case 0x46:\n            case 0x47:\n            case 0x48:\n            case 0x49:\n            case 0x4A:\n            case 0x4B:\n            case 0x4C:\n            case 0x4D:\n            case 0x4E:\n            case 0x4F:\n            case 0x50:\n            case 0x51:\n            case 0x52:\n            case 0x53:\n            case 0x54:\n            case 0x55:\n            case 0x56:\n            case 0x57:\n            case 0x58: // Binary data (one-byte uint8_t for n follows)\n            case 0x59: // Binary data (two-byte uint16_t for n follow)\n            case 0x5A: // Binary data (four-byte uint32_t for n follow)\n            case 0x5B: // Binary data (eight-byte uint64_t for n follow)\n            case 0x5F: // Binary data (indefinite length)\n            {\n                binary_t b;\n                return get_cbor_binary(b) && sax->binary(b);\n            }\n\n            // UTF-8 string (0x00..0x17 bytes follow)\n            case 0x60:\n            case 0x61:\n            case 0x62:\n            case 0x63:\n            case 0x64:\n            case 0x65:\n            case 0x66:\n            case 0x67:\n            case 0x68:\n            case 0x69:\n            case 0x6A:\n            case 0x6B:\n            case 0x6C:\n            case 0x6D:\n            case 0x6E:\n            case 0x6F:\n            case 0x70:\n            case 0x71:\n            case 0x72:\n            case 0x73:\n            case 0x74:\n            case 0x75:\n            case 0x76:\n            case 0x77:\n            case 0x78: // UTF-8 string (one-byte uint8_t for n follows)\n            case 0x79: // UTF-8 string (two-byte uint16_t for n follow)\n            case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)\n            case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)\n            case 0x7F: // UTF-8 string (indefinite length)\n            {\n                string_t s;\n                return get_cbor_string(s) && sax->string(s);\n            }\n\n            // array (0x00..0x17 data items follow)\n            case 0x80:\n            case 0x81:\n            case 0x82:\n            case 0x83:\n            case 0x84:\n            case 0x85:\n            case 0x86:\n            case 0x87:\n            case 0x88:\n            case 0x89:\n            case 0x8A:\n            case 0x8B:\n            case 0x8C:\n            case 0x8D:\n            case 0x8E:\n            case 0x8F:\n            case 0x90:\n            case 0x91:\n            case 0x92:\n            case 0x93:\n            case 0x94:\n            case 0x95:\n            case 0x96:\n            case 0x97:\n                return get_cbor_array(static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x1Fu), tag_handler);\n\n            case 0x98: // array (one-byte uint8_t for n follows)\n            {\n                std::uint8_t len{};\n                return get_number(input_format_t::cbor, len) && get_cbor_array(static_cast<std::size_t>(len), tag_handler);\n            }\n\n            case 0x99: // array (two-byte uint16_t for n follow)\n            {\n                std::uint16_t len{};\n                return get_number(input_format_t::cbor, len) && get_cbor_array(static_cast<std::size_t>(len), tag_handler);\n            }\n\n            case 0x9A: // array (four-byte uint32_t for n follow)\n            {\n                std::uint32_t len{};\n                return get_number(input_format_t::cbor, len) && get_cbor_array(static_cast<std::size_t>(len), tag_handler);\n            }\n\n            case 0x9B: // array (eight-byte uint64_t for n follow)\n            {\n                std::uint64_t len{};\n                return get_number(input_format_t::cbor, len) && get_cbor_array(detail::conditional_static_cast<std::size_t>(len), tag_handler);\n            }\n\n            case 0x9F: // array (indefinite length)\n                return get_cbor_array(static_cast<std::size_t>(-1), tag_handler);\n\n            // map (0x00..0x17 pairs of data items follow)\n            case 0xA0:\n            case 0xA1:\n            case 0xA2:\n            case 0xA3:\n            case 0xA4:\n            case 0xA5:\n            case 0xA6:\n            case 0xA7:\n            case 0xA8:\n            case 0xA9:\n            case 0xAA:\n            case 0xAB:\n            case 0xAC:\n            case 0xAD:\n            case 0xAE:\n            case 0xAF:\n            case 0xB0:\n            case 0xB1:\n            case 0xB2:\n            case 0xB3:\n            case 0xB4:\n            case 0xB5:\n            case 0xB6:\n            case 0xB7:\n                return get_cbor_object(static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x1Fu), tag_handler);\n\n            case 0xB8: // map (one-byte uint8_t for n follows)\n            {\n                std::uint8_t len{};\n                return get_number(input_format_t::cbor, len) && get_cbor_object(static_cast<std::size_t>(len), tag_handler);\n            }\n\n            case 0xB9: // map (two-byte uint16_t for n follow)\n            {\n                std::uint16_t len{};\n                return get_number(input_format_t::cbor, len) && get_cbor_object(static_cast<std::size_t>(len), tag_handler);\n            }\n\n            case 0xBA: // map (four-byte uint32_t for n follow)\n            {\n                std::uint32_t len{};\n                return get_number(input_format_t::cbor, len) && get_cbor_object(static_cast<std::size_t>(len), tag_handler);\n            }\n\n            case 0xBB: // map (eight-byte uint64_t for n follow)\n            {\n                std::uint64_t len{};\n                return get_number(input_format_t::cbor, len) && get_cbor_object(detail::conditional_static_cast<std::size_t>(len), tag_handler);\n            }\n\n            case 0xBF: // map (indefinite length)\n                return get_cbor_object(static_cast<std::size_t>(-1), tag_handler);\n\n            case 0xC6: // tagged item\n            case 0xC7:\n            case 0xC8:\n            case 0xC9:\n            case 0xCA:\n            case 0xCB:\n            case 0xCC:\n            case 0xCD:\n            case 0xCE:\n            case 0xCF:\n            case 0xD0:\n            case 0xD1:\n            case 0xD2:\n            case 0xD3:\n            case 0xD4:\n            case 0xD8: // tagged item (1 bytes follow)\n            case 0xD9: // tagged item (2 bytes follow)\n            case 0xDA: // tagged item (4 bytes follow)\n            case 0xDB: // tagged item (8 bytes follow)\n            {\n                switch (tag_handler)\n                {\n                    case cbor_tag_handler_t::error:\n                    {\n                        auto last_token = get_token_string();\n                        return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::cbor, \"invalid byte: 0x\" + last_token, \"value\"), BasicJsonType()));\n                    }\n\n                    case cbor_tag_handler_t::ignore:\n                    {\n                        // ignore binary subtype\n                        switch (current)\n                        {\n                            case 0xD8:\n                            {\n                                std::uint8_t subtype_to_ignore{};\n                                get_number(input_format_t::cbor, subtype_to_ignore);\n                                break;\n                            }\n                            case 0xD9:\n                            {\n                                std::uint16_t subtype_to_ignore{};\n                                get_number(input_format_t::cbor, subtype_to_ignore);\n                                break;\n                            }\n                            case 0xDA:\n                            {\n                                std::uint32_t subtype_to_ignore{};\n                                get_number(input_format_t::cbor, subtype_to_ignore);\n                                break;\n                            }\n                            case 0xDB:\n                            {\n                                std::uint64_t subtype_to_ignore{};\n                                get_number(input_format_t::cbor, subtype_to_ignore);\n                                break;\n                            }\n                            default:\n                                break;\n                        }\n                        return parse_cbor_internal(true, tag_handler);\n                    }\n\n                    case cbor_tag_handler_t::store:\n                    {\n                        binary_t b;\n                        // use binary subtype and store in binary container\n                        switch (current)\n                        {\n                            case 0xD8:\n                            {\n                                std::uint8_t subtype{};\n                                get_number(input_format_t::cbor, subtype);\n                                b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));\n                                break;\n                            }\n                            case 0xD9:\n                            {\n                                std::uint16_t subtype{};\n                                get_number(input_format_t::cbor, subtype);\n                                b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));\n                                break;\n                            }\n                            case 0xDA:\n                            {\n                                std::uint32_t subtype{};\n                                get_number(input_format_t::cbor, subtype);\n                                b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));\n                                break;\n                            }\n                            case 0xDB:\n                            {\n                                std::uint64_t subtype{};\n                                get_number(input_format_t::cbor, subtype);\n                                b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));\n                                break;\n                            }\n                            default:\n                                return parse_cbor_internal(true, tag_handler);\n                        }\n                        get();\n                        return get_cbor_binary(b) && sax->binary(b);\n                    }\n\n                    default:                 // LCOV_EXCL_LINE\n                        JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE\n                        return false;        // LCOV_EXCL_LINE\n                }\n            }\n\n            case 0xF4: // false\n                return sax->boolean(false);\n\n            case 0xF5: // true\n                return sax->boolean(true);\n\n            case 0xF6: // null\n                return sax->null();\n\n            case 0xF9: // Half-Precision Float (two-byte IEEE 754)\n            {\n                const auto byte1_raw = get();\n                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, \"number\")))\n                {\n                    return false;\n                }\n                const auto byte2_raw = get();\n                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, \"number\")))\n                {\n                    return false;\n                }\n\n                const auto byte1 = static_cast<unsigned char>(byte1_raw);\n                const auto byte2 = static_cast<unsigned char>(byte2_raw);\n\n                // code from RFC 7049, Appendix D, Figure 3:\n                // As half-precision floating-point numbers were only added\n                // to IEEE 754 in 2008, today's programming platforms often\n                // still only have limited support for them. It is very\n                // easy to include at least decoding support for them even\n                // without such support. An example of a small decoder for\n                // half-precision floating-point numbers in the C language\n                // is shown in Fig. 3.\n                const auto half = static_cast<unsigned int>((byte1 << 8u) + byte2);\n                const double val = [&half]\n                {\n                    const int exp = (half >> 10u) & 0x1Fu;\n                    const unsigned int mant = half & 0x3FFu;\n                    JSON_ASSERT(0 <= exp&& exp <= 32);\n                    JSON_ASSERT(mant <= 1024);\n                    switch (exp)\n                    {\n                        case 0:\n                            return std::ldexp(mant, -24);\n                        case 31:\n                            return (mant == 0)\n                            ? std::numeric_limits<double>::infinity()\n                            : std::numeric_limits<double>::quiet_NaN();\n                        default:\n                            return std::ldexp(mant + 1024, exp - 25);\n                    }\n                }();\n                return sax->number_float((half & 0x8000u) != 0\n                                         ? static_cast<number_float_t>(-val)\n                                         : static_cast<number_float_t>(val), \"\");\n            }\n\n            case 0xFA: // Single-Precision Float (four-byte IEEE 754)\n            {\n                float number{};\n                return get_number(input_format_t::cbor, number) && sax->number_float(static_cast<number_float_t>(number), \"\");\n            }\n\n            case 0xFB: // Double-Precision Float (eight-byte IEEE 754)\n            {\n                double number{};\n                return get_number(input_format_t::cbor, number) && sax->number_float(static_cast<number_float_t>(number), \"\");\n            }\n\n            default: // anything else (0xFF is handled inside the other types)\n            {\n                auto last_token = get_token_string();\n                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::cbor, \"invalid byte: 0x\" + last_token, \"value\"), BasicJsonType()));\n            }\n        }\n    }\n\n    /*!\n    @brief reads a CBOR string\n\n    This function first reads starting bytes to determine the expected\n    string length and then copies this number of bytes into a string.\n    Additionally, CBOR's strings with indefinite lengths are supported.\n\n    @param[out] result  created string\n\n    @return whether string creation completed\n    */\n    bool get_cbor_string(string_t& result)\n    {\n        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, \"string\")))\n        {\n            return false;\n        }\n\n        switch (current)\n        {\n            // UTF-8 string (0x00..0x17 bytes follow)\n            case 0x60:\n            case 0x61:\n            case 0x62:\n            case 0x63:\n            case 0x64:\n            case 0x65:\n            case 0x66:\n            case 0x67:\n            case 0x68:\n            case 0x69:\n            case 0x6A:\n            case 0x6B:\n            case 0x6C:\n            case 0x6D:\n            case 0x6E:\n            case 0x6F:\n            case 0x70:\n            case 0x71:\n            case 0x72:\n            case 0x73:\n            case 0x74:\n            case 0x75:\n            case 0x76:\n            case 0x77:\n            {\n                return get_string(input_format_t::cbor, static_cast<unsigned int>(current) & 0x1Fu, result);\n            }\n\n            case 0x78: // UTF-8 string (one-byte uint8_t for n follows)\n            {\n                std::uint8_t len{};\n                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);\n            }\n\n            case 0x79: // UTF-8 string (two-byte uint16_t for n follow)\n            {\n                std::uint16_t len{};\n                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);\n            }\n\n            case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)\n            {\n                std::uint32_t len{};\n                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);\n            }\n\n            case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)\n            {\n                std::uint64_t len{};\n                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);\n            }\n\n            case 0x7F: // UTF-8 string (indefinite length)\n            {\n                while (get() != 0xFF)\n                {\n                    string_t chunk;\n                    if (!get_cbor_string(chunk))\n                    {\n                        return false;\n                    }\n                    result.append(chunk);\n                }\n                return true;\n            }\n\n            default:\n            {\n                auto last_token = get_token_string();\n                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::cbor, \"expected length specification (0x60-0x7B) or indefinite string type (0x7F); last byte: 0x\" + last_token, \"string\"), BasicJsonType()));\n            }\n        }\n    }\n\n    /*!\n    @brief reads a CBOR byte array\n\n    This function first reads starting bytes to determine the expected\n    byte array length and then copies this number of bytes into the byte array.\n    Additionally, CBOR's byte arrays with indefinite lengths are supported.\n\n    @param[out] result  created byte array\n\n    @return whether byte array creation completed\n    */\n    bool get_cbor_binary(binary_t& result)\n    {\n        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, \"binary\")))\n        {\n            return false;\n        }\n\n        switch (current)\n        {\n            // Binary data (0x00..0x17 bytes follow)\n            case 0x40:\n            case 0x41:\n            case 0x42:\n            case 0x43:\n            case 0x44:\n            case 0x45:\n            case 0x46:\n            case 0x47:\n            case 0x48:\n            case 0x49:\n            case 0x4A:\n            case 0x4B:\n            case 0x4C:\n            case 0x4D:\n            case 0x4E:\n            case 0x4F:\n            case 0x50:\n            case 0x51:\n            case 0x52:\n            case 0x53:\n            case 0x54:\n            case 0x55:\n            case 0x56:\n            case 0x57:\n            {\n                return get_binary(input_format_t::cbor, static_cast<unsigned int>(current) & 0x1Fu, result);\n            }\n\n            case 0x58: // Binary data (one-byte uint8_t for n follows)\n            {\n                std::uint8_t len{};\n                return get_number(input_format_t::cbor, len) &&\n                       get_binary(input_format_t::cbor, len, result);\n            }\n\n            case 0x59: // Binary data (two-byte uint16_t for n follow)\n            {\n                std::uint16_t len{};\n                return get_number(input_format_t::cbor, len) &&\n                       get_binary(input_format_t::cbor, len, result);\n            }\n\n            case 0x5A: // Binary data (four-byte uint32_t for n follow)\n            {\n                std::uint32_t len{};\n                return get_number(input_format_t::cbor, len) &&\n                       get_binary(input_format_t::cbor, len, result);\n            }\n\n            case 0x5B: // Binary data (eight-byte uint64_t for n follow)\n            {\n                std::uint64_t len{};\n                return get_number(input_format_t::cbor, len) &&\n                       get_binary(input_format_t::cbor, len, result);\n            }\n\n            case 0x5F: // Binary data (indefinite length)\n            {\n                while (get() != 0xFF)\n                {\n                    binary_t chunk;\n                    if (!get_cbor_binary(chunk))\n                    {\n                        return false;\n                    }\n                    result.insert(result.end(), chunk.begin(), chunk.end());\n                }\n                return true;\n            }\n\n            default:\n            {\n                auto last_token = get_token_string();\n                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::cbor, \"expected length specification (0x40-0x5B) or indefinite binary array type (0x5F); last byte: 0x\" + last_token, \"binary\"), BasicJsonType()));\n            }\n        }\n    }\n\n    /*!\n    @param[in] len  the length of the array or static_cast<std::size_t>(-1) for an\n                    array of indefinite size\n    @param[in] tag_handler how CBOR tags should be treated\n    @return whether array creation completed\n    */\n    bool get_cbor_array(const std::size_t len,\n                        const cbor_tag_handler_t tag_handler)\n    {\n        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(len)))\n        {\n            return false;\n        }\n\n        if (len != static_cast<std::size_t>(-1))\n        {\n            for (std::size_t i = 0; i < len; ++i)\n            {\n                if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))\n                {\n                    return false;\n                }\n            }\n        }\n        else\n        {\n            while (get() != 0xFF)\n            {\n                if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(false, tag_handler)))\n                {\n                    return false;\n                }\n            }\n        }\n\n        return sax->end_array();\n    }\n\n    /*!\n    @param[in] len  the length of the object or static_cast<std::size_t>(-1) for an\n                    object of indefinite size\n    @param[in] tag_handler how CBOR tags should be treated\n    @return whether object creation completed\n    */\n    bool get_cbor_object(const std::size_t len,\n                         const cbor_tag_handler_t tag_handler)\n    {\n        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(len)))\n        {\n            return false;\n        }\n\n        if (len != 0)\n        {\n            string_t key;\n            if (len != static_cast<std::size_t>(-1))\n            {\n                for (std::size_t i = 0; i < len; ++i)\n                {\n                    get();\n                    if (JSON_HEDLEY_UNLIKELY(!get_cbor_string(key) || !sax->key(key)))\n                    {\n                        return false;\n                    }\n\n                    if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))\n                    {\n                        return false;\n                    }\n                    key.clear();\n                }\n            }\n            else\n            {\n                while (get() != 0xFF)\n                {\n                    if (JSON_HEDLEY_UNLIKELY(!get_cbor_string(key) || !sax->key(key)))\n                    {\n                        return false;\n                    }\n\n                    if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))\n                    {\n                        return false;\n                    }\n                    key.clear();\n                }\n            }\n        }\n\n        return sax->end_object();\n    }\n\n    /////////////\n    // MsgPack //\n    /////////////\n\n    /*!\n    @return whether a valid MessagePack value was passed to the SAX parser\n    */\n    bool parse_msgpack_internal()\n    {\n        switch (get())\n        {\n            // EOF\n            case std::char_traits<char_type>::eof():\n                return unexpect_eof(input_format_t::msgpack, \"value\");\n\n            // positive fixint\n            case 0x00:\n            case 0x01:\n            case 0x02:\n            case 0x03:\n            case 0x04:\n            case 0x05:\n            case 0x06:\n            case 0x07:\n            case 0x08:\n            case 0x09:\n            case 0x0A:\n            case 0x0B:\n            case 0x0C:\n            case 0x0D:\n            case 0x0E:\n            case 0x0F:\n            case 0x10:\n            case 0x11:\n            case 0x12:\n            case 0x13:\n            case 0x14:\n            case 0x15:\n            case 0x16:\n            case 0x17:\n            case 0x18:\n            case 0x19:\n            case 0x1A:\n            case 0x1B:\n            case 0x1C:\n            case 0x1D:\n            case 0x1E:\n            case 0x1F:\n            case 0x20:\n            case 0x21:\n            case 0x22:\n            case 0x23:\n            case 0x24:\n            case 0x25:\n            case 0x26:\n            case 0x27:\n            case 0x28:\n            case 0x29:\n            case 0x2A:\n            case 0x2B:\n            case 0x2C:\n            case 0x2D:\n            case 0x2E:\n            case 0x2F:\n            case 0x30:\n            case 0x31:\n            case 0x32:\n            case 0x33:\n            case 0x34:\n            case 0x35:\n            case 0x36:\n            case 0x37:\n            case 0x38:\n            case 0x39:\n            case 0x3A:\n            case 0x3B:\n            case 0x3C:\n            case 0x3D:\n            case 0x3E:\n            case 0x3F:\n            case 0x40:\n            case 0x41:\n            case 0x42:\n            case 0x43:\n            case 0x44:\n            case 0x45:\n            case 0x46:\n            case 0x47:\n            case 0x48:\n            case 0x49:\n            case 0x4A:\n            case 0x4B:\n            case 0x4C:\n            case 0x4D:\n            case 0x4E:\n            case 0x4F:\n            case 0x50:\n            case 0x51:\n            case 0x52:\n            case 0x53:\n            case 0x54:\n            case 0x55:\n            case 0x56:\n            case 0x57:\n            case 0x58:\n            case 0x59:\n            case 0x5A:\n            case 0x5B:\n            case 0x5C:\n            case 0x5D:\n            case 0x5E:\n            case 0x5F:\n            case 0x60:\n            case 0x61:\n            case 0x62:\n            case 0x63:\n            case 0x64:\n            case 0x65:\n            case 0x66:\n            case 0x67:\n            case 0x68:\n            case 0x69:\n            case 0x6A:\n            case 0x6B:\n            case 0x6C:\n            case 0x6D:\n            case 0x6E:\n            case 0x6F:\n            case 0x70:\n            case 0x71:\n            case 0x72:\n            case 0x73:\n            case 0x74:\n            case 0x75:\n            case 0x76:\n            case 0x77:\n            case 0x78:\n            case 0x79:\n            case 0x7A:\n            case 0x7B:\n            case 0x7C:\n            case 0x7D:\n            case 0x7E:\n            case 0x7F:\n                return sax->number_unsigned(static_cast<number_unsigned_t>(current));\n\n            // fixmap\n            case 0x80:\n            case 0x81:\n            case 0x82:\n            case 0x83:\n            case 0x84:\n            case 0x85:\n            case 0x86:\n            case 0x87:\n            case 0x88:\n            case 0x89:\n            case 0x8A:\n            case 0x8B:\n            case 0x8C:\n            case 0x8D:\n            case 0x8E:\n            case 0x8F:\n                return get_msgpack_object(static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x0Fu));\n\n            // fixarray\n            case 0x90:\n            case 0x91:\n            case 0x92:\n            case 0x93:\n            case 0x94:\n            case 0x95:\n            case 0x96:\n            case 0x97:\n            case 0x98:\n            case 0x99:\n            case 0x9A:\n            case 0x9B:\n            case 0x9C:\n            case 0x9D:\n            case 0x9E:\n            case 0x9F:\n                return get_msgpack_array(static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x0Fu));\n\n            // fixstr\n            case 0xA0:\n            case 0xA1:\n            case 0xA2:\n            case 0xA3:\n            case 0xA4:\n            case 0xA5:\n            case 0xA6:\n            case 0xA7:\n            case 0xA8:\n            case 0xA9:\n            case 0xAA:\n            case 0xAB:\n            case 0xAC:\n            case 0xAD:\n            case 0xAE:\n            case 0xAF:\n            case 0xB0:\n            case 0xB1:\n            case 0xB2:\n            case 0xB3:\n            case 0xB4:\n            case 0xB5:\n            case 0xB6:\n            case 0xB7:\n            case 0xB8:\n            case 0xB9:\n            case 0xBA:\n            case 0xBB:\n            case 0xBC:\n            case 0xBD:\n            case 0xBE:\n            case 0xBF:\n            case 0xD9: // str 8\n            case 0xDA: // str 16\n            case 0xDB: // str 32\n            {\n                string_t s;\n                return get_msgpack_string(s) && sax->string(s);\n            }\n\n            case 0xC0: // nil\n                return sax->null();\n\n            case 0xC2: // false\n                return sax->boolean(false);\n\n            case 0xC3: // true\n                return sax->boolean(true);\n\n            case 0xC4: // bin 8\n            case 0xC5: // bin 16\n            case 0xC6: // bin 32\n            case 0xC7: // ext 8\n            case 0xC8: // ext 16\n            case 0xC9: // ext 32\n            case 0xD4: // fixext 1\n            case 0xD5: // fixext 2\n            case 0xD6: // fixext 4\n            case 0xD7: // fixext 8\n            case 0xD8: // fixext 16\n            {\n                binary_t b;\n                return get_msgpack_binary(b) && sax->binary(b);\n            }\n\n            case 0xCA: // float 32\n            {\n                float number{};\n                return get_number(input_format_t::msgpack, number) && sax->number_float(static_cast<number_float_t>(number), \"\");\n            }\n\n            case 0xCB: // float 64\n            {\n                double number{};\n                return get_number(input_format_t::msgpack, number) && sax->number_float(static_cast<number_float_t>(number), \"\");\n            }\n\n            case 0xCC: // uint 8\n            {\n                std::uint8_t number{};\n                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);\n            }\n\n            case 0xCD: // uint 16\n            {\n                std::uint16_t number{};\n                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);\n            }\n\n            case 0xCE: // uint 32\n            {\n                std::uint32_t number{};\n                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);\n            }\n\n            case 0xCF: // uint 64\n            {\n                std::uint64_t number{};\n                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);\n            }\n\n            case 0xD0: // int 8\n            {\n                std::int8_t number{};\n                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);\n            }\n\n            case 0xD1: // int 16\n            {\n                std::int16_t number{};\n                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);\n            }\n\n            case 0xD2: // int 32\n            {\n                std::int32_t number{};\n                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);\n            }\n\n            case 0xD3: // int 64\n            {\n                std::int64_t number{};\n                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);\n            }\n\n            case 0xDC: // array 16\n            {\n                std::uint16_t len{};\n                return get_number(input_format_t::msgpack, len) && get_msgpack_array(static_cast<std::size_t>(len));\n            }\n\n            case 0xDD: // array 32\n            {\n                std::uint32_t len{};\n                return get_number(input_format_t::msgpack, len) && get_msgpack_array(static_cast<std::size_t>(len));\n            }\n\n            case 0xDE: // map 16\n            {\n                std::uint16_t len{};\n                return get_number(input_format_t::msgpack, len) && get_msgpack_object(static_cast<std::size_t>(len));\n            }\n\n            case 0xDF: // map 32\n            {\n                std::uint32_t len{};\n                return get_number(input_format_t::msgpack, len) && get_msgpack_object(static_cast<std::size_t>(len));\n            }\n\n            // negative fixint\n            case 0xE0:\n            case 0xE1:\n            case 0xE2:\n            case 0xE3:\n            case 0xE4:\n            case 0xE5:\n            case 0xE6:\n            case 0xE7:\n            case 0xE8:\n            case 0xE9:\n            case 0xEA:\n            case 0xEB:\n            case 0xEC:\n            case 0xED:\n            case 0xEE:\n            case 0xEF:\n            case 0xF0:\n            case 0xF1:\n            case 0xF2:\n            case 0xF3:\n            case 0xF4:\n            case 0xF5:\n            case 0xF6:\n            case 0xF7:\n            case 0xF8:\n            case 0xF9:\n            case 0xFA:\n            case 0xFB:\n            case 0xFC:\n            case 0xFD:\n            case 0xFE:\n            case 0xFF:\n                return sax->number_integer(static_cast<std::int8_t>(current));\n\n            default: // anything else\n            {\n                auto last_token = get_token_string();\n                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::msgpack, \"invalid byte: 0x\" + last_token, \"value\"), BasicJsonType()));\n            }\n        }\n    }\n\n    /*!\n    @brief reads a MessagePack string\n\n    This function first reads starting bytes to determine the expected\n    string length and then copies this number of bytes into a string.\n\n    @param[out] result  created string\n\n    @return whether string creation completed\n    */\n    bool get_msgpack_string(string_t& result)\n    {\n        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::msgpack, \"string\")))\n        {\n            return false;\n        }\n\n        switch (current)\n        {\n            // fixstr\n            case 0xA0:\n            case 0xA1:\n            case 0xA2:\n            case 0xA3:\n            case 0xA4:\n            case 0xA5:\n            case 0xA6:\n            case 0xA7:\n            case 0xA8:\n            case 0xA9:\n            case 0xAA:\n            case 0xAB:\n            case 0xAC:\n            case 0xAD:\n            case 0xAE:\n            case 0xAF:\n            case 0xB0:\n            case 0xB1:\n            case 0xB2:\n            case 0xB3:\n            case 0xB4:\n            case 0xB5:\n            case 0xB6:\n            case 0xB7:\n            case 0xB8:\n            case 0xB9:\n            case 0xBA:\n            case 0xBB:\n            case 0xBC:\n            case 0xBD:\n            case 0xBE:\n            case 0xBF:\n            {\n                return get_string(input_format_t::msgpack, static_cast<unsigned int>(current) & 0x1Fu, result);\n            }\n\n            case 0xD9: // str 8\n            {\n                std::uint8_t len{};\n                return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);\n            }\n\n            case 0xDA: // str 16\n            {\n                std::uint16_t len{};\n                return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);\n            }\n\n            case 0xDB: // str 32\n            {\n                std::uint32_t len{};\n                return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);\n            }\n\n            default:\n            {\n                auto last_token = get_token_string();\n                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::msgpack, \"expected length specification (0xA0-0xBF, 0xD9-0xDB); last byte: 0x\" + last_token, \"string\"), BasicJsonType()));\n            }\n        }\n    }\n\n    /*!\n    @brief reads a MessagePack byte array\n\n    This function first reads starting bytes to determine the expected\n    byte array length and then copies this number of bytes into a byte array.\n\n    @param[out] result  created byte array\n\n    @return whether byte array creation completed\n    */\n    bool get_msgpack_binary(binary_t& result)\n    {\n        // helper function to set the subtype\n        auto assign_and_return_true = [&result](std::int8_t subtype)\n        {\n            result.set_subtype(static_cast<std::uint8_t>(subtype));\n            return true;\n        };\n\n        switch (current)\n        {\n            case 0xC4: // bin 8\n            {\n                std::uint8_t len{};\n                return get_number(input_format_t::msgpack, len) &&\n                       get_binary(input_format_t::msgpack, len, result);\n            }\n\n            case 0xC5: // bin 16\n            {\n                std::uint16_t len{};\n                return get_number(input_format_t::msgpack, len) &&\n                       get_binary(input_format_t::msgpack, len, result);\n            }\n\n            case 0xC6: // bin 32\n            {\n                std::uint32_t len{};\n                return get_number(input_format_t::msgpack, len) &&\n                       get_binary(input_format_t::msgpack, len, result);\n            }\n\n            case 0xC7: // ext 8\n            {\n                std::uint8_t len{};\n                std::int8_t subtype{};\n                return get_number(input_format_t::msgpack, len) &&\n                       get_number(input_format_t::msgpack, subtype) &&\n                       get_binary(input_format_t::msgpack, len, result) &&\n                       assign_and_return_true(subtype);\n            }\n\n            case 0xC8: // ext 16\n            {\n                std::uint16_t len{};\n                std::int8_t subtype{};\n                return get_number(input_format_t::msgpack, len) &&\n                       get_number(input_format_t::msgpack, subtype) &&\n                       get_binary(input_format_t::msgpack, len, result) &&\n                       assign_and_return_true(subtype);\n            }\n\n            case 0xC9: // ext 32\n            {\n                std::uint32_t len{};\n                std::int8_t subtype{};\n                return get_number(input_format_t::msgpack, len) &&\n                       get_number(input_format_t::msgpack, subtype) &&\n                       get_binary(input_format_t::msgpack, len, result) &&\n                       assign_and_return_true(subtype);\n            }\n\n            case 0xD4: // fixext 1\n            {\n                std::int8_t subtype{};\n                return get_number(input_format_t::msgpack, subtype) &&\n                       get_binary(input_format_t::msgpack, 1, result) &&\n                       assign_and_return_true(subtype);\n            }\n\n            case 0xD5: // fixext 2\n            {\n                std::int8_t subtype{};\n                return get_number(input_format_t::msgpack, subtype) &&\n                       get_binary(input_format_t::msgpack, 2, result) &&\n                       assign_and_return_true(subtype);\n            }\n\n            case 0xD6: // fixext 4\n            {\n                std::int8_t subtype{};\n                return get_number(input_format_t::msgpack, subtype) &&\n                       get_binary(input_format_t::msgpack, 4, result) &&\n                       assign_and_return_true(subtype);\n            }\n\n            case 0xD7: // fixext 8\n            {\n                std::int8_t subtype{};\n                return get_number(input_format_t::msgpack, subtype) &&\n                       get_binary(input_format_t::msgpack, 8, result) &&\n                       assign_and_return_true(subtype);\n            }\n\n            case 0xD8: // fixext 16\n            {\n                std::int8_t subtype{};\n                return get_number(input_format_t::msgpack, subtype) &&\n                       get_binary(input_format_t::msgpack, 16, result) &&\n                       assign_and_return_true(subtype);\n            }\n\n            default:           // LCOV_EXCL_LINE\n                return false;  // LCOV_EXCL_LINE\n        }\n    }\n\n    /*!\n    @param[in] len  the length of the array\n    @return whether array creation completed\n    */\n    bool get_msgpack_array(const std::size_t len)\n    {\n        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(len)))\n        {\n            return false;\n        }\n\n        for (std::size_t i = 0; i < len; ++i)\n        {\n            if (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))\n            {\n                return false;\n            }\n        }\n\n        return sax->end_array();\n    }\n\n    /*!\n    @param[in] len  the length of the object\n    @return whether object creation completed\n    */\n    bool get_msgpack_object(const std::size_t len)\n    {\n        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(len)))\n        {\n            return false;\n        }\n\n        string_t key;\n        for (std::size_t i = 0; i < len; ++i)\n        {\n            get();\n            if (JSON_HEDLEY_UNLIKELY(!get_msgpack_string(key) || !sax->key(key)))\n            {\n                return false;\n            }\n\n            if (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))\n            {\n                return false;\n            }\n            key.clear();\n        }\n\n        return sax->end_object();\n    }\n\n    ////////////\n    // UBJSON //\n    ////////////\n\n    /*!\n    @param[in] get_char  whether a new character should be retrieved from the\n                         input (true, default) or whether the last read\n                         character should be considered instead\n\n    @return whether a valid UBJSON value was passed to the SAX parser\n    */\n    bool parse_ubjson_internal(const bool get_char = true)\n    {\n        return get_ubjson_value(get_char ? get_ignore_noop() : current);\n    }\n\n    /*!\n    @brief reads a UBJSON string\n\n    This function is either called after reading the 'S' byte explicitly\n    indicating a string, or in case of an object key where the 'S' byte can be\n    left out.\n\n    @param[out] result   created string\n    @param[in] get_char  whether a new character should be retrieved from the\n                         input (true, default) or whether the last read\n                         character should be considered instead\n\n    @return whether string creation completed\n    */\n    bool get_ubjson_string(string_t& result, const bool get_char = true)\n    {\n        if (get_char)\n        {\n            get();  // TODO(niels): may we ignore N here?\n        }\n\n        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, \"value\")))\n        {\n            return false;\n        }\n\n        switch (current)\n        {\n            case 'U':\n            {\n                std::uint8_t len{};\n                return get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);\n            }\n\n            case 'i':\n            {\n                std::int8_t len{};\n                return get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);\n            }\n\n            case 'I':\n            {\n                std::int16_t len{};\n                return get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);\n            }\n\n            case 'l':\n            {\n                std::int32_t len{};\n                return get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);\n            }\n\n            case 'L':\n            {\n                std::int64_t len{};\n                return get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);\n            }\n\n            default:\n                auto last_token = get_token_string();\n                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::ubjson, \"expected length type specification (U, i, I, l, L); last byte: 0x\" + last_token, \"string\"), BasicJsonType()));\n        }\n    }\n\n    /*!\n    @param[out] result  determined size\n    @return whether size determination completed\n    */\n    bool get_ubjson_size_value(std::size_t& result)\n    {\n        switch (get_ignore_noop())\n        {\n            case 'U':\n            {\n                std::uint8_t number{};\n                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))\n                {\n                    return false;\n                }\n                result = static_cast<std::size_t>(number);\n                return true;\n            }\n\n            case 'i':\n            {\n                std::int8_t number{};\n                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))\n                {\n                    return false;\n                }\n                result = static_cast<std::size_t>(number); // NOLINT(bugprone-signed-char-misuse,cert-str34-c): number is not a char\n                return true;\n            }\n\n            case 'I':\n            {\n                std::int16_t number{};\n                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))\n                {\n                    return false;\n                }\n                result = static_cast<std::size_t>(number);\n                return true;\n            }\n\n            case 'l':\n            {\n                std::int32_t number{};\n                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))\n                {\n                    return false;\n                }\n                result = static_cast<std::size_t>(number);\n                return true;\n            }\n\n            case 'L':\n            {\n                std::int64_t number{};\n                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))\n                {\n                    return false;\n                }\n                result = static_cast<std::size_t>(number);\n                return true;\n            }\n\n            default:\n            {\n                auto last_token = get_token_string();\n                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::ubjson, \"expected length type specification (U, i, I, l, L) after '#'; last byte: 0x\" + last_token, \"size\"), BasicJsonType()));\n            }\n        }\n    }\n\n    /*!\n    @brief determine the type and size for a container\n\n    In the optimized UBJSON format, a type and a size can be provided to allow\n    for a more compact representation.\n\n    @param[out] result  pair of the size and the type\n\n    @return whether pair creation completed\n    */\n    bool get_ubjson_size_type(std::pair<std::size_t, char_int_type>& result)\n    {\n        result.first = string_t::npos; // size\n        result.second = 0; // type\n\n        get_ignore_noop();\n\n        if (current == '$')\n        {\n            result.second = get();  // must not ignore 'N', because 'N' maybe the type\n            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, \"type\")))\n            {\n                return false;\n            }\n\n            get_ignore_noop();\n            if (JSON_HEDLEY_UNLIKELY(current != '#'))\n            {\n                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, \"value\")))\n                {\n                    return false;\n                }\n                auto last_token = get_token_string();\n                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::ubjson, \"expected '#' after type information; last byte: 0x\" + last_token, \"size\"), BasicJsonType()));\n            }\n\n            return get_ubjson_size_value(result.first);\n        }\n\n        if (current == '#')\n        {\n            return get_ubjson_size_value(result.first);\n        }\n\n        return true;\n    }\n\n    /*!\n    @param prefix  the previously read or set type prefix\n    @return whether value creation completed\n    */\n    bool get_ubjson_value(const char_int_type prefix)\n    {\n        switch (prefix)\n        {\n            case std::char_traits<char_type>::eof():  // EOF\n                return unexpect_eof(input_format_t::ubjson, \"value\");\n\n            case 'T':  // true\n                return sax->boolean(true);\n            case 'F':  // false\n                return sax->boolean(false);\n\n            case 'Z':  // null\n                return sax->null();\n\n            case 'U':\n            {\n                std::uint8_t number{};\n                return get_number(input_format_t::ubjson, number) && sax->number_unsigned(number);\n            }\n\n            case 'i':\n            {\n                std::int8_t number{};\n                return get_number(input_format_t::ubjson, number) && sax->number_integer(number);\n            }\n\n            case 'I':\n            {\n                std::int16_t number{};\n                return get_number(input_format_t::ubjson, number) && sax->number_integer(number);\n            }\n\n            case 'l':\n            {\n                std::int32_t number{};\n                return get_number(input_format_t::ubjson, number) && sax->number_integer(number);\n            }\n\n            case 'L':\n            {\n                std::int64_t number{};\n                return get_number(input_format_t::ubjson, number) && sax->number_integer(number);\n            }\n\n            case 'd':\n            {\n                float number{};\n                return get_number(input_format_t::ubjson, number) && sax->number_float(static_cast<number_float_t>(number), \"\");\n            }\n\n            case 'D':\n            {\n                double number{};\n                return get_number(input_format_t::ubjson, number) && sax->number_float(static_cast<number_float_t>(number), \"\");\n            }\n\n            case 'H':\n            {\n                return get_ubjson_high_precision_number();\n            }\n\n            case 'C':  // char\n            {\n                get();\n                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, \"char\")))\n                {\n                    return false;\n                }\n                if (JSON_HEDLEY_UNLIKELY(current > 127))\n                {\n                    auto last_token = get_token_string();\n                    return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::ubjson, \"byte after 'C' must be in range 0x00..0x7F; last byte: 0x\" + last_token, \"char\"), BasicJsonType()));\n                }\n                string_t s(1, static_cast<typename string_t::value_type>(current));\n                return sax->string(s);\n            }\n\n            case 'S':  // string\n            {\n                string_t s;\n                return get_ubjson_string(s) && sax->string(s);\n            }\n\n            case '[':  // array\n                return get_ubjson_array();\n\n            case '{':  // object\n                return get_ubjson_object();\n\n            default: // anything else\n            {\n                auto last_token = get_token_string();\n                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::ubjson, \"invalid byte: 0x\" + last_token, \"value\"), BasicJsonType()));\n            }\n        }\n    }\n\n    /*!\n    @return whether array creation completed\n    */\n    bool get_ubjson_array()\n    {\n        std::pair<std::size_t, char_int_type> size_and_type;\n        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type)))\n        {\n            return false;\n        }\n\n        if (size_and_type.first != string_t::npos)\n        {\n            if (JSON_HEDLEY_UNLIKELY(!sax->start_array(size_and_type.first)))\n            {\n                return false;\n            }\n\n            if (size_and_type.second != 0)\n            {\n                if (size_and_type.second != 'N')\n                {\n                    for (std::size_t i = 0; i < size_and_type.first; ++i)\n                    {\n                        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))\n                        {\n                            return false;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                for (std::size_t i = 0; i < size_and_type.first; ++i)\n                {\n                    if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))\n                    {\n                        return false;\n                    }\n                }\n            }\n        }\n        else\n        {\n            if (JSON_HEDLEY_UNLIKELY(!sax->start_array(static_cast<std::size_t>(-1))))\n            {\n                return false;\n            }\n\n            while (current != ']')\n            {\n                if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal(false)))\n                {\n                    return false;\n                }\n                get_ignore_noop();\n            }\n        }\n\n        return sax->end_array();\n    }\n\n    /*!\n    @return whether object creation completed\n    */\n    bool get_ubjson_object()\n    {\n        std::pair<std::size_t, char_int_type> size_and_type;\n        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type)))\n        {\n            return false;\n        }\n\n        string_t key;\n        if (size_and_type.first != string_t::npos)\n        {\n            if (JSON_HEDLEY_UNLIKELY(!sax->start_object(size_and_type.first)))\n            {\n                return false;\n            }\n\n            if (size_and_type.second != 0)\n            {\n                for (std::size_t i = 0; i < size_and_type.first; ++i)\n                {\n                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key) || !sax->key(key)))\n                    {\n                        return false;\n                    }\n                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))\n                    {\n                        return false;\n                    }\n                    key.clear();\n                }\n            }\n            else\n            {\n                for (std::size_t i = 0; i < size_and_type.first; ++i)\n                {\n                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key) || !sax->key(key)))\n                    {\n                        return false;\n                    }\n                    if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))\n                    {\n                        return false;\n                    }\n                    key.clear();\n                }\n            }\n        }\n        else\n        {\n            if (JSON_HEDLEY_UNLIKELY(!sax->start_object(static_cast<std::size_t>(-1))))\n            {\n                return false;\n            }\n\n            while (current != '}')\n            {\n                if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key, false) || !sax->key(key)))\n                {\n                    return false;\n                }\n                if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))\n                {\n                    return false;\n                }\n                get_ignore_noop();\n                key.clear();\n            }\n        }\n\n        return sax->end_object();\n    }\n\n    // Note, no reader for UBJSON binary types is implemented because they do\n    // not exist\n\n    bool get_ubjson_high_precision_number()\n    {\n        // get size of following number string\n        std::size_t size{};\n        auto res = get_ubjson_size_value(size);\n        if (JSON_HEDLEY_UNLIKELY(!res))\n        {\n            return res;\n        }\n\n        // get number string\n        std::vector<char> number_vector;\n        for (std::size_t i = 0; i < size; ++i)\n        {\n            get();\n            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, \"number\")))\n            {\n                return false;\n            }\n            number_vector.push_back(static_cast<char>(current));\n        }\n\n        // parse number string\n        using ia_type = decltype(detail::input_adapter(number_vector));\n        auto number_lexer = detail::lexer<BasicJsonType, ia_type>(detail::input_adapter(number_vector), false);\n        const auto result_number = number_lexer.scan();\n        const auto number_string = number_lexer.get_token_string();\n        const auto result_remainder = number_lexer.scan();\n\n        using token_type = typename detail::lexer_base<BasicJsonType>::token_type;\n\n        if (JSON_HEDLEY_UNLIKELY(result_remainder != token_type::end_of_input))\n        {\n            return sax->parse_error(chars_read, number_string, parse_error::create(115, chars_read, exception_message(input_format_t::ubjson, \"invalid number text: \" + number_lexer.get_token_string(), \"high-precision number\"), BasicJsonType()));\n        }\n\n        switch (result_number)\n        {\n            case token_type::value_integer:\n                return sax->number_integer(number_lexer.get_number_integer());\n            case token_type::value_unsigned:\n                return sax->number_unsigned(number_lexer.get_number_unsigned());\n            case token_type::value_float:\n                return sax->number_float(number_lexer.get_number_float(), std::move(number_string));\n            case token_type::uninitialized:\n            case token_type::literal_true:\n            case token_type::literal_false:\n            case token_type::literal_null:\n            case token_type::value_string:\n            case token_type::begin_array:\n            case token_type::begin_object:\n            case token_type::end_array:\n            case token_type::end_object:\n            case token_type::name_separator:\n            case token_type::value_separator:\n            case token_type::parse_error:\n            case token_type::end_of_input:\n            case token_type::literal_or_value:\n            default:\n                return sax->parse_error(chars_read, number_string, parse_error::create(115, chars_read, exception_message(input_format_t::ubjson, \"invalid number text: \" + number_lexer.get_token_string(), \"high-precision number\"), BasicJsonType()));\n        }\n    }\n\n    ///////////////////////\n    // Utility functions //\n    ///////////////////////\n\n    /*!\n    @brief get next character from the input\n\n    This function provides the interface to the used input adapter. It does\n    not throw in case the input reached EOF, but returns a -'ve valued\n    `std::char_traits<char_type>::eof()` in that case.\n\n    @return character read from the input\n    */\n    char_int_type get()\n    {\n        ++chars_read;\n        return current = ia.get_character();\n    }\n\n    /*!\n    @return character read from the input after ignoring all 'N' entries\n    */\n    char_int_type get_ignore_noop()\n    {\n        do\n        {\n            get();\n        }\n        while (current == 'N');\n\n        return current;\n    }\n\n    /*\n    @brief read a number from the input\n\n    @tparam NumberType the type of the number\n    @param[in] format   the current format (for diagnostics)\n    @param[out] result  number of type @a NumberType\n\n    @return whether conversion completed\n\n    @note This function needs to respect the system's endianness, because\n          bytes in CBOR, MessagePack, and UBJSON are stored in network order\n          (big endian) and therefore need reordering on little endian systems.\n    */\n    template<typename NumberType, bool InputIsLittleEndian = false>\n    bool get_number(const input_format_t format, NumberType& result)\n    {\n        // step 1: read input into array with system's byte order\n        std::array<std::uint8_t, sizeof(NumberType)> vec{};\n        for (std::size_t i = 0; i < sizeof(NumberType); ++i)\n        {\n            get();\n            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, \"number\")))\n            {\n                return false;\n            }\n\n            // reverse byte order prior to conversion if necessary\n            if (is_little_endian != InputIsLittleEndian)\n            {\n                vec[sizeof(NumberType) - i - 1] = static_cast<std::uint8_t>(current);\n            }\n            else\n            {\n                vec[i] = static_cast<std::uint8_t>(current); // LCOV_EXCL_LINE\n            }\n        }\n\n        // step 2: convert array into number of type T and return\n        std::memcpy(&result, vec.data(), sizeof(NumberType));\n        return true;\n    }\n\n    /*!\n    @brief create a string by reading characters from the input\n\n    @tparam NumberType the type of the number\n    @param[in] format the current format (for diagnostics)\n    @param[in] len number of characters to read\n    @param[out] result string created by reading @a len bytes\n\n    @return whether string creation completed\n\n    @note We can not reserve @a len bytes for the result, because @a len\n          may be too large. Usually, @ref unexpect_eof() detects the end of\n          the input before we run out of string memory.\n    */\n    template<typename NumberType>\n    bool get_string(const input_format_t format,\n                    const NumberType len,\n                    string_t& result)\n    {\n        bool success = true;\n        for (NumberType i = 0; i < len; i++)\n        {\n            get();\n            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, \"string\")))\n            {\n                success = false;\n                break;\n            }\n            result.push_back(static_cast<typename string_t::value_type>(current));\n        }\n        return success;\n    }\n\n    /*!\n    @brief create a byte array by reading bytes from the input\n\n    @tparam NumberType the type of the number\n    @param[in] format the current format (for diagnostics)\n    @param[in] len number of bytes to read\n    @param[out] result byte array created by reading @a len bytes\n\n    @return whether byte array creation completed\n\n    @note We can not reserve @a len bytes for the result, because @a len\n          may be too large. Usually, @ref unexpect_eof() detects the end of\n          the input before we run out of memory.\n    */\n    template<typename NumberType>\n    bool get_binary(const input_format_t format,\n                    const NumberType len,\n                    binary_t& result)\n    {\n        bool success = true;\n        for (NumberType i = 0; i < len; i++)\n        {\n            get();\n            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, \"binary\")))\n            {\n                success = false;\n                break;\n            }\n            result.push_back(static_cast<std::uint8_t>(current));\n        }\n        return success;\n    }\n\n    /*!\n    @param[in] format   the current format (for diagnostics)\n    @param[in] context  further context information (for diagnostics)\n    @return whether the last read character is not EOF\n    */\n    JSON_HEDLEY_NON_NULL(3)\n    bool unexpect_eof(const input_format_t format, const char* context) const\n    {\n        if (JSON_HEDLEY_UNLIKELY(current == std::char_traits<char_type>::eof()))\n        {\n            return sax->parse_error(chars_read, \"<end of file>\",\n                                    parse_error::create(110, chars_read, exception_message(format, \"unexpected end of input\", context), BasicJsonType()));\n        }\n        return true;\n    }\n\n    /*!\n    @return a string representation of the last read byte\n    */\n    std::string get_token_string() const\n    {\n        std::array<char, 3> cr{{}};\n        static_cast<void>((std::snprintf)(cr.data(), cr.size(), \"%.2hhX\", static_cast<unsigned char>(current))); // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)\n        return std::string{cr.data()};\n    }\n\n    /*!\n    @param[in] format   the current format\n    @param[in] detail   a detailed error message\n    @param[in] context  further context information\n    @return a message string to use in the parse_error exceptions\n    */\n    std::string exception_message(const input_format_t format,\n                                  const std::string& detail,\n                                  const std::string& context) const\n    {\n        std::string error_msg = \"syntax error while parsing \";\n\n        switch (format)\n        {\n            case input_format_t::cbor:\n                error_msg += \"CBOR\";\n                break;\n\n            case input_format_t::msgpack:\n                error_msg += \"MessagePack\";\n                break;\n\n            case input_format_t::ubjson:\n                error_msg += \"UBJSON\";\n                break;\n\n            case input_format_t::bson:\n                error_msg += \"BSON\";\n                break;\n\n            case input_format_t::json: // LCOV_EXCL_LINE\n            default:            // LCOV_EXCL_LINE\n                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE\n        }\n\n        return error_msg + \" \" + context + \": \" + detail;\n    }\n\n  private:\n    /// input adapter\n    InputAdapterType ia;\n\n    /// the current character\n    char_int_type current = std::char_traits<char_type>::eof();\n\n    /// the number of characters read\n    std::size_t chars_read = 0;\n\n    /// whether we can assume little endianness\n    const bool is_little_endian = little_endianness();\n\n    /// the SAX parser\n    json_sax_t* sax = nullptr;\n};\n}  // namespace detail\n}  // namespace nlohmann\n\n// #include <nlohmann/detail/input/input_adapters.hpp>\n\n// #include <nlohmann/detail/input/lexer.hpp>\n\n// #include <nlohmann/detail/input/parser.hpp>\n\n\n#include <cmath> // isfinite\n#include <cstdint> // uint8_t\n#include <functional> // function\n#include <string> // string\n#include <utility> // move\n#include <vector> // vector\n\n// #include <nlohmann/detail/exceptions.hpp>\n\n// #include <nlohmann/detail/input/input_adapters.hpp>\n\n// #include <nlohmann/detail/input/json_sax.hpp>\n\n// #include <nlohmann/detail/input/lexer.hpp>\n\n// #include <nlohmann/detail/macro_scope.hpp>\n\n// #include <nlohmann/detail/meta/is_sax.hpp>\n\n// #include <nlohmann/detail/value_t.hpp>\n\n\nnamespace nlohmann\n{\nnamespace detail\n{\n////////////\n// parser //\n////////////\n\nenum class parse_event_t : std::uint8_t\n{\n    /// the parser read `{` and started to process a JSON object\n    object_start,\n    /// the parser read `}` and finished processing a JSON object\n    object_end,\n    /// the parser read `[` and started to process a JSON array\n    array_start,\n    /// the parser read `]` and finished processing a JSON array\n    array_end,\n    /// the parser read a key of a value in an object\n    key,\n    /// the parser finished reading a JSON value\n    value\n};\n\ntemplate<typename BasicJsonType>\nusing parser_callback_t =\n    std::function<bool(int /*depth*/, parse_event_t /*event*/, BasicJsonType& /*parsed*/)>;\n\n/*!\n@brief syntax analysis\n\nThis class implements a recursive descent parser.\n*/\ntemplate<typename BasicJsonType, typename InputAdapterType>\nclass parser\n{\n    using number_integer_t = typename BasicJsonType::number_integer_t;\n    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;\n    using number_float_t = typename BasicJsonType::number_float_t;\n    using string_t = typename BasicJsonType::string_t;\n    using lexer_t = lexer<BasicJsonType, InputAdapterType>;\n    using token_type = typename lexer_t::token_type;\n\n  public:\n    /// a parser reading from an input adapter\n    explicit parser(InputAdapterType&& adapter,\n                    const parser_callback_t<BasicJsonType> cb = nullptr,\n                    const bool allow_exceptions_ = true,\n                    const bool skip_comments = false)\n        : callback(cb)\n        , m_lexer(std::move(adapter), skip_comments)\n        , allow_exceptions(allow_exceptions_)\n    {\n        // read first token\n        get_token();\n    }\n\n    /*!\n    @brief public parser interface\n\n    @param[in] strict      whether to expect the last token to be EOF\n    @param[in,out] result  parsed JSON value\n\n    @throw parse_error.101 in case of an unexpected token\n    @throw parse_error.102 if to_unicode fails or surrogate error\n    @throw parse_error.103 if to_unicode fails\n    */\n    void parse(const bool strict, BasicJsonType& result)\n    {\n        if (callback)\n        {\n            json_sax_dom_callback_parser<BasicJsonType> sdp(result, callback, allow_exceptions);\n            sax_parse_internal(&sdp);\n\n            // in strict mode, input must be completely read\n            if (strict && (get_token() != token_type::end_of_input))\n            {\n                sdp.parse_error(m_lexer.get_position(),\n                                m_lexer.get_token_string(),\n                                parse_error::create(101, m_lexer.get_position(),\n                                                    exception_message(token_type::end_of_input, \"value\"), BasicJsonType()));\n            }\n\n            // in case of an error, return discarded value\n            if (sdp.is_errored())\n            {\n                result = value_t::discarded;\n                return;\n            }\n\n            // set top-level value to null if it was discarded by the callback\n            // function\n            if (result.is_discarded())\n            {\n                result = nullptr;\n            }\n        }\n        else\n        {\n            json_sax_dom_parser<BasicJsonType> sdp(result, allow_exceptions);\n            sax_parse_internal(&sdp);\n\n            // in strict mode, input must be completely read\n            if (strict && (get_token() != token_type::end_of_input))\n            {\n                sdp.parse_error(m_lexer.get_position(),\n                                m_lexer.get_token_string(),\n                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input, \"value\"), BasicJsonType()));\n            }\n\n            // in case of an error, return discarded value\n            if (sdp.is_errored())\n            {\n                result = value_t::discarded;\n                return;\n            }\n        }\n\n        result.assert_invariant();\n    }\n\n    /*!\n    @brief public accept interface\n\n    @param[in] strict  whether to expect the last token to be EOF\n    @return whether the input is a proper JSON text\n    */\n    bool accept(const bool strict = true)\n    {\n        json_sax_acceptor<BasicJsonType> sax_acceptor;\n        return sax_parse(&sax_acceptor, strict);\n    }\n\n    template<typename SAX>\n    JSON_HEDLEY_NON_NULL(2)\n    bool sax_parse(SAX* sax, const bool strict = true)\n    {\n        (void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};\n        const bool result = sax_parse_internal(sax);\n\n        // strict mode: next byte must be EOF\n        if (result && strict && (get_token() != token_type::end_of_input))\n        {\n            return sax->parse_error(m_lexer.get_position(),\n                                    m_lexer.get_token_string(),\n                                    parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input, \"value\"), BasicJsonType()));\n        }\n\n        return result;\n    }\n\n  private:\n    template<typename SAX>\n    JSON_HEDLEY_NON_NULL(2)\n    bool sax_parse_internal(SAX* sax)\n    {\n        // stack to remember the hierarchy of structured values we are parsing\n        // true = array; false = object\n        std::vector<bool> states;\n        // value to avoid a goto (see comment where set to true)\n        bool skip_to_state_evaluation = false;\n\n        while (true)\n        {\n            if (!skip_to_state_evaluation)\n            {\n                // invariant: get_token() was called before each iteration\n                switch (last_token)\n                {\n                    case token_type::begin_object:\n                    {\n                        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(static_cast<std::size_t>(-1))))\n                        {\n                            return false;\n                        }\n\n                        // closing } -> we are done\n                        if (get_token() == token_type::end_object)\n                        {\n                            if (JSON_HEDLEY_UNLIKELY(!sax->end_object()))\n                            {\n                                return false;\n                            }\n                            break;\n                        }\n\n                        // parse key\n                        if (JSON_HEDLEY_UNLIKELY(last_token != token_type::value_string))\n                        {\n                            return sax->parse_error(m_lexer.get_position(),\n                                                    m_lexer.get_token_string(),\n                                                    parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string, \"object key\"), BasicJsonType()));\n                        }\n                        if (JSON_HEDLEY_UNLIKELY(!sax->key(m_lexer.get_string())))\n                        {\n                            return false;\n                        }\n\n                        // parse separator (:)\n                        if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))\n                        {\n                            return sax->parse_error(m_lexer.get_position(),\n                                                    m_lexer.get_token_string(),\n                                                    parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator, \"object separator\"), BasicJsonType()));\n                        }\n\n                        // remember we are now inside an object\n                        states.push_back(false);\n\n                        // parse values\n                        get_token();\n                        continue;\n                    }\n\n                    case token_type::begin_array:\n                    {\n                        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(static_cast<std::size_t>(-1))))\n                        {\n                            return false;\n                        }\n\n                        // closing ] -> we are done\n                        if (get_token() == token_type::end_array)\n                        {\n                            if (JSON_HEDLEY_UNLIKELY(!sax->end_array()))\n                            {\n                                return false;\n                            }\n                            break;\n                        }\n\n                        // remember we are now inside an array\n                        states.push_back(true);\n\n                        // parse values (no need to call get_token)\n                        continue;\n                    }\n\n                    case token_type::value_float:\n                    {\n                        const auto res = m_lexer.get_number_float();\n\n                        if (JSON_HEDLEY_UNLIKELY(!std::isfinite(res)))\n                        {\n                            return sax->parse_error(m_lexer.get_position(),\n                                                    m_lexer.get_token_string(),\n                                                    out_of_range::create(406, \"number overflow parsing '\" + m_lexer.get_token_string() + \"'\", BasicJsonType()));\n                        }\n\n                        if (JSON_HEDLEY_UNLIKELY(!sax->number_float(res, m_lexer.get_string())))\n                        {\n                            return false;\n                        }\n\n                        break;\n                    }\n\n                    case token_type::literal_false:\n                    {\n                        if (JSON_HEDLEY_UNLIKELY(!sax->boolean(false)))\n                        {\n                            return false;\n                        }\n                        break;\n                    }\n\n                    case token_type::literal_null:\n                    {\n                        if (JSON_HEDLEY_UNLIKELY(!sax->null()))\n                        {\n                            return false;\n                        }\n                        break;\n                    }\n\n                    case token_type::literal_true:\n                    {\n                        if (JSON_HEDLEY_UNLIKELY(!sax->boolean(true)))\n                        {\n                            return false;\n                        }\n                        break;\n                    }\n\n                    case token_type::value_integer:\n                    {\n                        if (JSON_HEDLEY_UNLIKELY(!sax->number_integer(m_lexer.get_number_integer())))\n                        {\n                            return false;\n                        }\n                        break;\n                    }\n\n                    case token_type::value_string:\n                    {\n                        if (JSON_HEDLEY_UNLIKELY(!sax->string(m_lexer.get_string())))\n                        {\n                            return false;\n                        }\n                        break;\n                    }\n\n                    case token_type::value_unsigned:\n                    {\n                        if (JSON_HEDLEY_UNLIKELY(!sax->number_unsigned(m_lexer.get_number_unsigned())))\n                        {\n                            return false;\n                        }\n                        break;\n                    }\n\n                    case token_type::parse_error:\n                    {\n                        // using \"uninitialized\" to avoid \"expected\" message\n                        return sax->parse_error(m_lexer.get_position(),\n                                                m_lexer.get_token_string(),\n                                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::uninitialized, \"value\"), BasicJsonType()));\n                    }\n\n                    case token_type::uninitialized:\n                    case token_type::end_array:\n                    case token_type::end_object:\n                    case token_type::name_separator:\n                    case token_type::value_separator:\n                    case token_type::end_of_input:\n                    case token_type::literal_or_value:\n                    default: // the last token was unexpected\n                    {\n                        return sax->parse_error(m_lexer.get_position(),\n                                                m_lexer.get_token_string(),\n                                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::literal_or_value, \"value\"), BasicJsonType()));\n                    }\n                }\n            }\n            else\n            {\n                skip_to_state_evaluation = false;\n            }\n\n            // we reached this line after we successfully parsed a value\n            if (states.empty())\n            {\n                // empty stack: we reached the end of the hierarchy: done\n                return true;\n            }\n\n            if (states.back())  // array\n            {\n                // comma -> next value\n                if (get_token() == token_type::value_separator)\n                {\n                    // parse a new value\n                    get_token();\n                    continue;\n                }\n\n                // closing ]\n                if (JSON_HEDLEY_LIKELY(last_token == token_type::end_array))\n                {\n                    if (JSON_HEDLEY_UNLIKELY(!sax->end_array()))\n                    {\n                        return false;\n                    }\n\n                    // We are done with this array. Before we can parse a\n                    // new value, we need to evaluate the new state first.\n                    // By setting skip_to_state_evaluation to false, we\n                    // are effectively jumping to the beginning of this if.\n                    JSON_ASSERT(!states.empty());\n                    states.pop_back();\n                    skip_to_state_evaluation = true;\n                    continue;\n                }\n\n                return sax->parse_error(m_lexer.get_position(),\n                                        m_lexer.get_token_string(),\n                                        parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_array, \"array\"), BasicJsonType()));\n            }\n\n            // states.back() is false -> object\n\n            // comma -> next value\n            if (get_token() == token_type::value_separator)\n            {\n                // parse key\n                if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::value_string))\n                {\n                    return sax->parse_error(m_lexer.get_position(),\n                                            m_lexer.get_token_string(),\n                                            parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string, \"object key\"), BasicJsonType()));\n                }\n\n                if (JSON_HEDLEY_UNLIKELY(!sax->key(m_lexer.get_string())))\n                {\n                    return false;\n                }\n\n                // parse separator (:)\n                if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))\n                {\n                    return sax->parse_error(m_lexer.get_position(),\n                                            m_lexer.get_token_string(),\n                                            parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator, \"object separator\"), BasicJsonType()));\n                }\n\n                // parse values\n                get_token();\n                continue;\n            }\n\n            // closing }\n            if (JSON_HEDLEY_LIKELY(last_token == token_type::end_object))\n            {\n                if (JSON_HEDLEY_UNLIKELY(!sax->end_object()))\n                {\n                    return false;\n                }\n\n                // We are done with this object. Before we can parse a\n                // new value, we need to evaluate the new state first.\n                // By setting skip_to_state_evaluation to false, we\n                // are effectively jumping to the beginning of this if.\n                JSON_ASSERT(!states.empty());\n                states.pop_back();\n                skip_to_state_evaluation = true;\n                continue;\n            }\n\n            return sax->parse_error(m_lexer.get_position(),\n                                    m_lexer.get_token_string(),\n                                    parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_object, \"object\"), BasicJsonType()));\n        }\n    }\n\n    /// get next token from lexer\n    token_type get_token()\n    {\n        return last_token = m_lexer.scan();\n    }\n\n    std::string exception_message(const token_type expected, const std::string& context)\n    {\n        std::string error_msg = \"syntax error \";\n\n        if (!context.empty())\n        {\n            error_msg += \"while parsing \" + context + \" \";\n        }\n\n        error_msg += \"- \";\n\n        if (last_token == token_type::parse_error)\n        {\n            error_msg += std::string(m_lexer.get_error_message()) + \"; last read: '\" +\n                         m_lexer.get_token_string() + \"'\";\n        }\n        else\n        {\n            error_msg += \"unexpected \" + std::string(lexer_t::token_type_name(last_token));\n        }\n\n        if (expected != token_type::uninitialized)\n        {\n            error_msg += \"; expected \" + std::string(lexer_t::token_type_name(expected));\n        }\n\n        return error_msg;\n    }\n\n  private:\n    /// callback function\n    const parser_callback_t<BasicJsonType> callback = nullptr;\n    /// the type of the last read token\n    token_type last_token = token_type::uninitialized;\n    /// the lexer\n    lexer_t m_lexer;\n    /// whether to throw exceptions in case of errors\n    const bool allow_exceptions = true;\n};\n\n}  // namespace detail\n}  // namespace nlohmann\n\n// #include <nlohmann/detail/iterators/internal_iterator.hpp>\n\n\n// #include <nlohmann/detail/iterators/primitive_iterator.hpp>\n\n\n#include <cstddef> // ptrdiff_t\n#include <limits>  // numeric_limits\n\n// #include <nlohmann/detail/macro_scope.hpp>\n\n\nnamespace nlohmann\n{\nnamespace detail\n{\n/*\n@brief an iterator for primitive JSON types\n\nThis class models an iterator for primitive JSON types (boolean, number,\nstring). It's only purpose is to allow the iterator/const_iterator classes\nto \"iterate\" over primitive values. Internally, the iterator is modeled by\na `difference_type` variable. Value begin_value (`0`) models the begin,\nend_value (`1`) models past the end.\n*/\nclass primitive_iterator_t\n{\n  private:\n    using difference_type = std::ptrdiff_t;\n    static constexpr difference_type begin_value = 0;\n    static constexpr difference_type end_value = begin_value + 1;\n\n  JSON_PRIVATE_UNLESS_TESTED:\n    /// iterator as signed integer type\n    difference_type m_it = (std::numeric_limits<std::ptrdiff_t>::min)();\n\n  public:\n    constexpr difference_type get_value() const noexcept\n    {\n        return m_it;\n    }\n\n    /// set iterator to a defined beginning\n    void set_begin() noexcept\n    {\n        m_it = begin_value;\n    }\n\n    /// set iterator to a defined past the end\n    void set_end() noexcept\n    {\n        m_it = end_value;\n    }\n\n    /// return whether the iterator can be dereferenced\n    constexpr bool is_begin() const noexcept\n    {\n        return m_it == begin_value;\n    }\n\n    /// return whether the iterator is at end\n    constexpr bool is_end() const noexcept\n    {\n        return m_it == end_value;\n    }\n\n    friend constexpr bool operator==(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept\n    {\n        return lhs.m_it == rhs.m_it;\n    }\n\n    friend constexpr bool operator<(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept\n    {\n        return lhs.m_it < rhs.m_it;\n    }\n\n    primitive_iterator_t operator+(difference_type n) noexcept\n    {\n        auto result = *this;\n        result += n;\n        return result;\n    }\n\n    friend constexpr difference_type operator-(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept\n    {\n        return lhs.m_it - rhs.m_it;\n    }\n\n    primitive_iterator_t& operator++() noexcept\n    {\n        ++m_it;\n        return *this;\n    }\n\n    primitive_iterator_t const operator++(int) noexcept // NOLINT(readability-const-return-type)\n    {\n        auto result = *this;\n        ++m_it;\n        return result;\n    }\n\n    primitive_iterator_t& operator--() noexcept\n    {\n        --m_it;\n        return *this;\n    }\n\n    primitive_iterator_t const operator--(int) noexcept // NOLINT(readability-const-return-type)\n    {\n        auto result = *this;\n        --m_it;\n        return result;\n    }\n\n    primitive_iterator_t& operator+=(difference_type n) noexcept\n    {\n        m_it += n;\n        return *this;\n    }\n\n    primitive_iterator_t& operator-=(difference_type n) noexcept\n    {\n        m_it -= n;\n        return *this;\n    }\n};\n}  // namespace detail\n}  // namespace nlohmann\n\n\nnamespace nlohmann\n{\nnamespace detail\n{\n/*!\n@brief an iterator value\n\n@note This structure could easily be a union, but MSVC currently does not allow\nunions members with complex constructors, see https://github.com/nlohmann/json/pull/105.\n*/\ntemplate<typename BasicJsonType> struct internal_iterator\n{\n    /// iterator for JSON objects\n    typename BasicJsonType::object_t::iterator object_iterator {};\n    /// iterator for JSON arrays\n    typename BasicJsonType::array_t::iterator array_iterator {};\n    /// generic iterator for all other types\n    primitive_iterator_t primitive_iterator {};\n};\n}  // namespace detail\n}  // namespace nlohmann\n\n// #include <nlohmann/detail/iterators/iter_impl.hpp>\n\n\n#include <iterator> // iterator, random_access_iterator_tag, bidirectional_iterator_tag, advance, next\n#include <type_traits> // conditional, is_const, remove_const\n\n// #include <nlohmann/detail/exceptions.hpp>\n\n// #include <nlohmann/detail/iterators/internal_iterator.hpp>\n\n// #include <nlohmann/detail/iterators/primitive_iterator.hpp>\n\n// #include <nlohmann/detail/macro_scope.hpp>\n\n// #include <nlohmann/detail/meta/cpp_future.hpp>\n\n// #include <nlohmann/detail/meta/type_traits.hpp>\n\n// #include <nlohmann/detail/value_t.hpp>\n\n\nnamespace nlohmann\n{\nnamespace detail\n{\n// forward declare, to be able to friend it later on\ntemplate<typename IteratorType> class iteration_proxy;\ntemplate<typename IteratorType> class iteration_proxy_value;\n\n/*!\n@brief a template for a bidirectional iterator for the @ref basic_json class\nThis class implements a both iterators (iterator and const_iterator) for the\n@ref basic_json class.\n@note An iterator is called *initialized* when a pointer to a JSON value has\n      been set (e.g., by a constructor or a copy assignment). If the iterator is\n      default-constructed, it is *uninitialized* and most methods are undefined.\n      **The library uses assertions to detect calls on uninitialized iterators.**\n@requirement The class satisfies the following concept requirements:\n-\n[BidirectionalIterator](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator):\n  The iterator that can be moved can be moved in both directions (i.e.\n  incremented and decremented).\n@since version 1.0.0, simplified in version 2.0.9, change to bidirectional\n       iterators in version 3.0.0 (see https://github.com/nlohmann/json/issues/593)\n*/\ntemplate<typename BasicJsonType>\nclass iter_impl // NOLINT(cppcoreguidelines-special-member-functions,hicpp-special-member-functions)\n{\n    /// the iterator with BasicJsonType of different const-ness\n    using other_iter_impl = iter_impl<typename std::conditional<std::is_const<BasicJsonType>::value, typename std::remove_const<BasicJsonType>::type, const BasicJsonType>::type>;\n    /// allow basic_json to access private members\n    friend other_iter_impl;\n    friend BasicJsonType;\n    friend iteration_proxy<iter_impl>;\n    friend iteration_proxy_value<iter_impl>;\n\n    using object_t = typename BasicJsonType::object_t;\n    using array_t = typename BasicJsonType::array_t;\n    // make sure BasicJsonType is basic_json or const basic_json\n    static_assert(is_basic_json<typename std::remove_const<BasicJsonType>::type>::value,\n                  \"iter_impl only accepts (const) basic_json\");\n\n  public:\n\n    /// The std::iterator class template (used as a base class to provide typedefs) is deprecated in C++17.\n    /// The C++ Standard has never required user-defined iterators to derive from std::iterator.\n    /// A user-defined iterator should provide publicly accessible typedefs named\n    /// iterator_category, value_type, difference_type, pointer, and reference.\n    /// Note that value_type is required to be non-const, even for constant iterators.\n    using iterator_category = std::bidirectional_iterator_tag;\n\n    /// the type of the values when the iterator is dereferenced\n    using value_type = typename BasicJsonType::value_type;\n    /// a type to represent differences between iterators\n    using difference_type = typename BasicJsonType::difference_type;\n    /// defines a pointer to the type iterated over (value_type)\n    using pointer = typename std::conditional<std::is_const<BasicJsonType>::value,\n          typename BasicJsonType::const_pointer,\n          typename BasicJsonType::pointer>::type;\n    /// defines a reference to the type iterated over (value_type)\n    using reference =\n        typename std::conditional<std::is_const<BasicJsonType>::value,\n        typename BasicJsonType::const_reference,\n        typename BasicJsonType::reference>::type;\n\n    iter_impl() = default;\n    ~iter_impl() = default;\n    iter_impl(iter_impl&&) noexcept = default;\n    iter_impl& operator=(iter_impl&&) noexcept = default;\n\n    /*!\n    @brief constructor for a given JSON instance\n    @param[in] object  pointer to a JSON object for this iterator\n    @pre object != nullptr\n    @post The iterator is initialized; i.e. `m_object != nullptr`.\n    */\n    explicit iter_impl(pointer object) noexcept : m_object(object)\n    {\n        JSON_ASSERT(m_object != nullptr);\n\n        switch (m_object->m_type)\n        {\n            case value_t::object:\n            {\n                m_it.object_iterator = typename object_t::iterator();\n                break;\n            }\n\n            case value_t::array:\n            {\n                m_it.array_iterator = typename array_t::iterator();\n                break;\n            }\n\n            case value_t::null:\n            case value_t::string:\n            case value_t::boolean:\n            case value_t::number_integer:\n            case value_t::number_unsigned:\n            case value_t::number_float:\n            case value_t::binary:\n            case value_t::discarded:\n            default:\n            {\n                m_it.primitive_iterator = primitive_iterator_t();\n                break;\n            }\n        }\n    }\n\n    /*!\n    @note The conventional copy constructor and copy assignment are implicitly\n          defined. Combined with the following converting constructor and\n          assignment, they support: (1) copy from iterator to iterator, (2)\n          copy from const iterator to const iterator, and (3) conversion from\n          iterator to const iterator. However conversion from const iterator\n          to iterator is not defined.\n    */\n\n    /*!\n    @brief const copy constructor\n    @param[in] other const iterator to copy from\n    @note This copy constructor had to be defined explicitly to circumvent a bug\n          occurring on msvc v19.0 compiler (VS 2015) debug build. For more\n          information refer to: https://github.com/nlohmann/json/issues/1608\n    */\n    iter_impl(const iter_impl<const BasicJsonType>& other) noexcept\n        : m_object(other.m_object), m_it(other.m_it)\n    {}\n\n    /*!\n    @brief converting assignment\n    @param[in] other const iterator to copy from\n    @return const/non-const iterator\n    @note It is not checked whether @a other is initialized.\n    */\n    iter_impl& operator=(const iter_impl<const BasicJsonType>& other) noexcept\n    {\n        if (&other != this)\n        {\n            m_object = other.m_object;\n            m_it = other.m_it;\n        }\n        return *this;\n    }\n\n    /*!\n    @brief converting constructor\n    @param[in] other  non-const iterator to copy from\n    @note It is not checked whether @a other is initialized.\n    */\n    iter_impl(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept\n        : m_object(other.m_object), m_it(other.m_it)\n    {}\n\n    /*!\n    @brief converting assignment\n    @param[in] other  non-const iterator to copy from\n    @return const/non-const iterator\n    @note It is not checked whether @a other is initialized.\n    */\n    iter_impl& operator=(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept // NOLINT(cert-oop54-cpp)\n    {\n        m_object = other.m_object;\n        m_it = other.m_it;\n        return *this;\n    }\n\n  JSON_PRIVATE_UNLESS_TESTED:\n    /*!\n    @brief set the iterator to the first value\n    @pre The iterator is initialized; i.e. `m_object != nullptr`.\n    */\n    void set_begin() noexcept\n    {\n        JSON_ASSERT(m_object != nullptr);\n\n        switch (m_object->m_type)\n        {\n            case value_t::object:\n            {\n                m_it.object_iterator = m_object->m_value.object->begin();\n                break;\n            }\n\n            case value_t::array:\n            {\n                m_it.array_iterator = m_object->m_value.array->begin();\n                break;\n            }\n\n            case value_t::null:\n            {\n                // set to end so begin()==end() is true: null is empty\n                m_it.primitive_iterator.set_end();\n                break;\n            }\n\n            case value_t::string:\n            case value_t::boolean:\n            case value_t::number_integer:\n            case value_t::number_unsigned:\n            case value_t::number_float:\n            case value_t::binary:\n            case value_t::discarded:\n            default:\n            {\n                m_it.primitive_iterator.set_begin();\n                break;\n            }\n        }\n    }\n\n    /*!\n    @brief set the iterator past the last value\n    @pre The iterator is initialized; i.e. `m_object != nullptr`.\n    */\n    void set_end() noexcept\n    {\n        JSON_ASSERT(m_object != nullptr);\n\n        switch (m_object->m_type)\n        {\n            case value_t::object:\n            {\n                m_it.object_iterator = m_object->m_value.object->end();\n                break;\n            }\n\n            case value_t::array:\n            {\n                m_it.array_iterator = m_object->m_value.array->end();\n                break;\n            }\n\n            case value_t::null:\n            case value_t::string:\n            case value_t::boolean:\n            case value_t::number_integer:\n            case value_t::number_unsigned:\n            case value_t::number_float:\n            case value_t::binary:\n            case value_t::discarded:\n            default:\n            {\n                m_it.primitive_iterator.set_end();\n                break;\n            }\n        }\n    }\n\n  public:\n    /*!\n    @brief return a reference to the value pointed to by the iterator\n    @pre The iterator is initialized; i.e. `m_object != nullptr`.\n    */\n    reference operator*() const\n    {\n        JSON_ASSERT(m_object != nullptr);\n\n        switch (m_object->m_type)\n        {\n            case value_t::object:\n            {\n                JSON_ASSERT(m_it.object_iterator != m_object->m_value.object->end());\n                return m_it.object_iterator->second;\n            }\n\n            case value_t::array:\n            {\n                JSON_ASSERT(m_it.array_iterator != m_object->m_value.array->end());\n                return *m_it.array_iterator;\n            }\n\n            case value_t::null:\n                JSON_THROW(invalid_iterator::create(214, \"cannot get value\", *m_object));\n\n            case value_t::string:\n            case value_t::boolean:\n            case value_t::number_integer:\n            case value_t::number_unsigned:\n            case value_t::number_float:\n            case value_t::binary:\n            case value_t::discarded:\n            default:\n            {\n                if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))\n                {\n                    return *m_object;\n                }\n\n                JSON_THROW(invalid_iterator::create(214, \"cannot get value\", *m_object));\n            }\n        }\n    }\n\n    /*!\n    @brief dereference the iterator\n    @pre The iterator is initialized; i.e. `m_object != nullptr`.\n    */\n    pointer operator->() const\n    {\n        JSON_ASSERT(m_object != nullptr);\n\n        switch (m_object->m_type)\n        {\n            case value_t::object:\n            {\n                JSON_ASSERT(m_it.object_iterator != m_object->m_value.object->end());\n                return &(m_it.object_iterator->second);\n            }\n\n            case value_t::array:\n            {\n                JSON_ASSERT(m_it.array_iterator != m_object->m_value.array->end());\n                return &*m_it.array_iterator;\n            }\n\n            case value_t::null:\n            case value_t::string:\n            case value_t::boolean:\n            case value_t::number_integer:\n            case value_t::number_unsigned:\n            case value_t::number_float:\n            case value_t::binary:\n            case value_t::discarded:\n            default:\n            {\n                if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))\n                {\n                    return m_object;\n                }\n\n                JSON_THROW(invalid_iterator::create(214, \"cannot get value\", *m_object));\n            }\n        }\n    }\n\n    /*!\n    @brief post-increment (it++)\n    @pre The iterator is initialized; i.e. `m_object != nullptr`.\n    */\n    iter_impl const operator++(int) // NOLINT(readability-const-return-type)\n    {\n        auto result = *this;\n        ++(*this);\n        return result;\n    }\n\n    /*!\n    @brief pre-increment (++it)\n    @pre The iterator is initialized; i.e. `m_object != nullptr`.\n    */\n    iter_impl& operator++()\n    {\n        JSON_ASSERT(m_object != nullptr);\n\n        switch (m_object->m_type)\n        {\n            case value_t::object:\n            {\n                std::advance(m_it.object_iterator, 1);\n                break;\n            }\n\n            case value_t::array:\n            {\n                std::advance(m_it.array_iterator, 1);\n                break;\n            }\n\n            case value_t::null:\n            case value_t::string:\n            case value_t::boolean:\n            case value_t::number_integer:\n            case value_t::number_unsigned:\n            case value_t::number_float:\n            case value_t::binary:\n            case value_t::discarded:\n            default:\n            {\n                ++m_it.primitive_iterator;\n                break;\n            }\n        }\n\n        return *this;\n    }\n\n    /*!\n    @brief post-decrement (it--)\n    @pre The iterator is initialized; i.e. `m_object != nullptr`.\n    */\n    iter_impl const operator--(int) // NOLINT(readability-const-return-type)\n    {\n        auto result = *this;\n        --(*this);\n        return result;\n    }\n\n    /*!\n    @brief pre-decrement (--it)\n    @pre The iterator is initialized; i.e. `m_object != nullptr`.\n    */\n    iter_impl& operator--()\n    {\n        JSON_ASSERT(m_object != nullptr);\n\n        switch (m_object->m_type)\n        {\n            case value_t::object:\n            {\n                std::advance(m_it.object_iterator, -1);\n                break;\n            }\n\n            case value_t::array:\n            {\n                std::advance(m_it.array_iterator, -1);\n                break;\n            }\n\n            case value_t::null:\n            case value_t::string:\n            case value_t::boolean:\n            case value_t::number_integer:\n            case value_t::number_unsigned:\n            case value_t::number_float:\n            case value_t::binary:\n            case value_t::discarded:\n            default:\n            {\n                --m_it.primitive_iterator;\n                break;\n            }\n        }\n\n        return *this;\n    }\n\n    /*!\n    @brief comparison: equal\n    @pre The iterator is initialized; i.e. `m_object != nullptr`.\n    */\n    template < typename IterImpl, detail::enable_if_t < (std::is_same<IterImpl, iter_impl>::value || std::is_same<IterImpl, other_iter_impl>::value), std::nullptr_t > = nullptr >\n    bool operator==(const IterImpl& other) const\n    {\n        // if objects are not the same, the comparison is undefined\n        if (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))\n        {\n            JSON_THROW(invalid_iterator::create(212, \"cannot compare iterators of different containers\", *m_object));\n        }\n\n        JSON_ASSERT(m_object != nullptr);\n\n        switch (m_object->m_type)\n        {\n            case value_t::object:\n                return (m_it.object_iterator == other.m_it.object_iterator);\n\n            case value_t::array:\n                return (m_it.array_iterator == other.m_it.array_iterator);\n\n            case value_t::null:\n            case value_t::string:\n            case value_t::boolean:\n            case value_t::number_integer:\n            case value_t::number_unsigned:\n            case value_t::number_float:\n            case value_t::binary:\n            case value_t::discarded:\n            default:\n                return (m_it.primitive_iterator == other.m_it.primitive_iterator);\n        }\n    }\n\n    /*!\n    @brief comparison: not equal\n    @pre The iterator is initialized; i.e. `m_object != nullptr`.\n    */\n    template < typename IterImpl, detail::enable_if_t < (std::is_same<IterImpl, iter_impl>::value || std::is_same<IterImpl, other_iter_impl>::value), std::nullptr_t > = nullptr >\n    bool operator!=(const IterImpl& other) const\n    {\n        return !operator==(other);\n    }\n\n    /*!\n    @brief comparison: smaller\n    @pre The iterator is initialized; i.e. `m_object != nullptr`.\n    */\n    bool operator<(const iter_impl& other) const\n    {\n        // if objects are not the same, the comparison is undefined\n        if (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))\n        {\n            JSON_THROW(invalid_iterator::create(212, \"cannot compare iterators of different containers\", *m_object));\n        }\n\n        JSON_ASSERT(m_object != nullptr);\n\n        switch (m_object->m_type)\n        {\n            case value_t::object:\n                JSON_THROW(invalid_iterator::create(213, \"cannot compare order of object iterators\", *m_object));\n\n            case value_t::array:\n                return (m_it.array_iterator < other.m_it.array_iterator);\n\n            case value_t::null:\n            case value_t::string:\n            case value_t::boolean:\n            case value_t::number_integer:\n            case value_t::number_unsigned:\n            case value_t::number_float:\n            case value_t::binary:\n            case value_t::discarded:\n            default:\n                return (m_it.primitive_iterator < other.m_it.primitive_iterator);\n        }\n    }\n\n    /*!\n    @brief comparison: less than or equal\n    @pre The iterator is initialized; i.e. `m_object != nullptr`.\n    */\n    bool operator<=(const iter_impl& other) const\n    {\n        return !other.operator < (*this);\n    }\n\n    /*!\n    @brief comparison: greater than\n    @pre The iterator is initialized; i.e. `m_object != nullptr`.\n    */\n    bool operator>(const iter_impl& other) const\n    {\n        return !operator<=(other);\n    }\n\n    /*!\n    @brief comparison: greater than or equal\n    @pre The iterator is initialized; i.e. `m_object != nullptr`.\n    */\n    bool operator>=(const iter_impl& other) const\n    {\n        return !operator<(other);\n    }\n\n    /*!\n    @brief add to iterator\n    @pre The iterator is initialized; i.e. `m_object != nullptr`.\n    */\n    iter_impl& operator+=(difference_type i)\n    {\n        JSON_ASSERT(m_object != nullptr);\n\n        switch (m_object->m_type)\n        {\n            case value_t::object:\n                JSON_THROW(invalid_iterator::create(209, \"cannot use offsets with object iterators\", *m_object));\n\n            case value_t::array:\n            {\n                std::advance(m_it.array_iterator, i);\n                break;\n            }\n\n            case value_t::null:\n            case value_t::string:\n            case value_t::boolean:\n            case value_t::number_integer:\n            case value_t::number_unsigned:\n            case value_t::number_float:\n            case value_t::binary:\n            case value_t::discarded:\n            default:\n            {\n                m_it.primitive_iterator += i;\n                break;\n            }\n        }\n\n        return *this;\n    }\n\n    /*!\n    @brief subtract from iterator\n    @pre The iterator is initialized; i.e. `m_object != nullptr`.\n    */\n    iter_impl& operator-=(difference_type i)\n    {\n        return operator+=(-i);\n    }\n\n    /*!\n    @brief add to iterator\n    @pre The iterator is initialized; i.e. `m_object != nullptr`.\n    */\n    iter_impl operator+(difference_type i) const\n    {\n        auto result = *this;\n        result += i;\n        return result;\n    }\n\n    /*!\n    @brief addition of distance and iterator\n    @pre The iterator is initialized; i.e. `m_object != nullptr`.\n    */\n    friend iter_impl operator+(difference_type i, const iter_impl& it)\n    {\n        auto result = it;\n        result += i;\n        return result;\n    }\n\n    /*!\n    @brief subtract from iterator\n    @pre The iterator is initialized; i.e. `m_object != nullptr`.\n    */\n    iter_impl operator-(difference_type i) const\n    {\n        auto result = *this;\n        result -= i;\n        return result;\n    }\n\n    /*!\n    @brief return difference\n    @pre The iterator is initialized; i.e. `m_object != nullptr`.\n    */\n    difference_type operator-(const iter_impl& other) const\n    {\n        JSON_ASSERT(m_object != nullptr);\n\n        switch (m_object->m_type)\n        {\n            case value_t::object:\n                JSON_THROW(invalid_iterator::create(209, \"cannot use offsets with object iterators\", *m_object));\n\n            case value_t::array:\n                return m_it.array_iterator - other.m_it.array_iterator;\n\n            case value_t::null:\n            case value_t::string:\n            case value_t::boolean:\n            case value_t::number_integer:\n            case value_t::number_unsigned:\n            case value_t::number_float:\n            case value_t::binary:\n            case value_t::discarded:\n            default:\n                return m_it.primitive_iterator - other.m_it.primitive_iterator;\n        }\n    }\n\n    /*!\n    @brief access to successor\n    @pre The iterator is initialized; i.e. `m_object != nullptr`.\n    */\n    reference operator[](difference_type n) const\n    {\n        JSON_ASSERT(m_object != nullptr);\n\n        switch (m_object->m_type)\n        {\n            case value_t::object:\n                JSON_THROW(invalid_iterator::create(208, \"cannot use operator[] for object iterators\", *m_object));\n\n            case value_t::array:\n                return *std::next(m_it.array_iterator, n);\n\n            case value_t::null:\n                JSON_THROW(invalid_iterator::create(214, \"cannot get value\", *m_object));\n\n            case value_t::string:\n            case value_t::boolean:\n            case value_t::number_integer:\n            case value_t::number_unsigned:\n            case value_t::number_float:\n            case value_t::binary:\n            case value_t::discarded:\n            default:\n            {\n                if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.get_value() == -n))\n                {\n                    return *m_object;\n                }\n\n                JSON_THROW(invalid_iterator::create(214, \"cannot get value\", *m_object));\n            }\n        }\n    }\n\n    /*!\n    @brief return the key of an object iterator\n    @pre The iterator is initialized; i.e. `m_object != nullptr`.\n    */\n    const typename object_t::key_type& key() const\n    {\n        JSON_ASSERT(m_object != nullptr);\n\n        if (JSON_HEDLEY_LIKELY(m_object->is_object()))\n        {\n            return m_it.object_iterator->first;\n        }\n\n        JSON_THROW(invalid_iterator::create(207, \"cannot use key() for non-object iterators\", *m_object));\n    }\n\n    /*!\n    @brief return the value of an iterator\n    @pre The iterator is initialized; i.e. `m_object != nullptr`.\n    */\n    reference value() const\n    {\n        return operator*();\n    }\n\n  JSON_PRIVATE_UNLESS_TESTED:\n    /// associated JSON instance\n    pointer m_object = nullptr;\n    /// the actual iterator of the associated instance\n    internal_iterator<typename std::remove_const<BasicJsonType>::type> m_it {};\n};\n} // namespace detail\n} // namespace nlohmann\n\n// #include <nlohmann/detail/iterators/iteration_proxy.hpp>\n\n// #include <nlohmann/detail/iterators/json_reverse_iterator.hpp>\n\n\n#include <cstddef> // ptrdiff_t\n#include <iterator> // reverse_iterator\n#include <utility> // declval\n\nnamespace nlohmann\n{\nnamespace detail\n{\n//////////////////////\n// reverse_iterator //\n//////////////////////\n\n/*!\n@brief a template for a reverse iterator class\n\n@tparam Base the base iterator type to reverse. Valid types are @ref\niterator (to create @ref reverse_iterator) and @ref const_iterator (to\ncreate @ref const_reverse_iterator).\n\n@requirement The class satisfies the following concept requirements:\n-\n[BidirectionalIterator](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator):\n  The iterator that can be moved can be moved in both directions (i.e.\n  incremented and decremented).\n- [OutputIterator](https://en.cppreference.com/w/cpp/named_req/OutputIterator):\n  It is possible to write to the pointed-to element (only if @a Base is\n  @ref iterator).\n\n@since version 1.0.0\n*/\ntemplate<typename Base>\nclass json_reverse_iterator : public std::reverse_iterator<Base>\n{\n  public:\n    using difference_type = std::ptrdiff_t;\n    /// shortcut to the reverse iterator adapter\n    using base_iterator = std::reverse_iterator<Base>;\n    /// the reference type for the pointed-to element\n    using reference = typename Base::reference;\n\n    /// create reverse iterator from iterator\n    explicit json_reverse_iterator(const typename base_iterator::iterator_type& it) noexcept\n        : base_iterator(it) {}\n\n    /// create reverse iterator from base class\n    explicit json_reverse_iterator(const base_iterator& it) noexcept : base_iterator(it) {}\n\n    /// post-increment (it++)\n    json_reverse_iterator const operator++(int) // NOLINT(readability-const-return-type)\n    {\n        return static_cast<json_reverse_iterator>(base_iterator::operator++(1));\n    }\n\n    /// pre-increment (++it)\n    json_reverse_iterator& operator++()\n    {\n        return static_cast<json_reverse_iterator&>(base_iterator::operator++());\n    }\n\n    /// post-decrement (it--)\n    json_reverse_iterator const operator--(int) // NOLINT(readability-const-return-type)\n    {\n        return static_cast<json_reverse_iterator>(base_iterator::operator--(1));\n    }\n\n    /// pre-decrement (--it)\n    json_reverse_iterator& operator--()\n    {\n        return static_cast<json_reverse_iterator&>(base_iterator::operator--());\n    }\n\n    /// add to iterator\n    json_reverse_iterator& operator+=(difference_type i)\n    {\n        return static_cast<json_reverse_iterator&>(base_iterator::operator+=(i));\n    }\n\n    /// add to iterator\n    json_reverse_iterator operator+(difference_type i) const\n    {\n        return static_cast<json_reverse_iterator>(base_iterator::operator+(i));\n    }\n\n    /// subtract from iterator\n    json_reverse_iterator operator-(difference_type i) const\n    {\n        return static_cast<json_reverse_iterator>(base_iterator::operator-(i));\n    }\n\n    /// return difference\n    difference_type operator-(const json_reverse_iterator& other) const\n    {\n        return base_iterator(*this) - base_iterator(other);\n    }\n\n    /// access to successor\n    reference operator[](difference_type n) const\n    {\n        return *(this->operator+(n));\n    }\n\n    /// return the key of an object iterator\n    auto key() const -> decltype(std::declval<Base>().key())\n    {\n        auto it = --this->base();\n        return it.key();\n    }\n\n    /// return the value of an iterator\n    reference value() const\n    {\n        auto it = --this->base();\n        return it.operator * ();\n    }\n};\n}  // namespace detail\n}  // namespace nlohmann\n\n// #include <nlohmann/detail/iterators/primitive_iterator.hpp>\n\n// #include <nlohmann/detail/json_pointer.hpp>\n\n\n#include <algorithm> // all_of\n#include <cctype> // isdigit\n#include <limits> // max\n#include <numeric> // accumulate\n#include <string> // string\n#include <utility> // move\n#include <vector> // vector\n\n// #include <nlohmann/detail/exceptions.hpp>\n\n// #include <nlohmann/detail/macro_scope.hpp>\n\n// #include <nlohmann/detail/string_escape.hpp>\n\n// #include <nlohmann/detail/value_t.hpp>\n\n\nnamespace nlohmann\n{\n\n/// @brief JSON Pointer defines a string syntax for identifying a specific value within a JSON document\n/// @sa https://json.nlohmann.me/api/json_pointer/\ntemplate<typename BasicJsonType>\nclass json_pointer\n{\n    // allow basic_json to access private members\n    NLOHMANN_BASIC_JSON_TPL_DECLARATION\n    friend class basic_json;\n\n  public:\n    /// @brief create JSON pointer\n    /// @sa https://json.nlohmann.me/api/json_pointer/json_pointer/\n    explicit json_pointer(const std::string& s = \"\")\n        : reference_tokens(split(s))\n    {}\n\n    /// @brief return a string representation of the JSON pointer\n    /// @sa https://json.nlohmann.me/api/json_pointer/to_string/\n    std::string to_string() const\n    {\n        return std::accumulate(reference_tokens.begin(), reference_tokens.end(),\n                               std::string{},\n                               [](const std::string & a, const std::string & b)\n        {\n            return a + \"/\" + detail::escape(b);\n        });\n    }\n\n    /// @brief return a string representation of the JSON pointer\n    /// @sa https://json.nlohmann.me/api/json_pointer/operator_string/\n    operator std::string() const\n    {\n        return to_string();\n    }\n\n    /// @brief append another JSON pointer at the end of this JSON pointer\n    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slasheq/\n    json_pointer& operator/=(const json_pointer& ptr)\n    {\n        reference_tokens.insert(reference_tokens.end(),\n                                ptr.reference_tokens.begin(),\n                                ptr.reference_tokens.end());\n        return *this;\n    }\n\n    /// @brief append an unescaped reference token at the end of this JSON pointer\n    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slasheq/\n    json_pointer& operator/=(std::string token)\n    {\n        push_back(std::move(token));\n        return *this;\n    }\n\n    /// @brief append an array index at the end of this JSON pointer\n    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slasheq/\n    json_pointer& operator/=(std::size_t array_idx)\n    {\n        return *this /= std::to_string(array_idx);\n    }\n\n    /// @brief create a new JSON pointer by appending the right JSON pointer at the end of the left JSON pointer\n    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slash/\n    friend json_pointer operator/(const json_pointer& lhs,\n                                  const json_pointer& rhs)\n    {\n        return json_pointer(lhs) /= rhs;\n    }\n\n    /// @brief create a new JSON pointer by appending the unescaped token at the end of the JSON pointer\n    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slash/\n    friend json_pointer operator/(const json_pointer& lhs, std::string token) // NOLINT(performance-unnecessary-value-param)\n    {\n        return json_pointer(lhs) /= std::move(token);\n    }\n\n    /// @brief create a new JSON pointer by appending the array-index-token at the end of the JSON pointer\n    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slash/\n    friend json_pointer operator/(const json_pointer& lhs, std::size_t array_idx)\n    {\n        return json_pointer(lhs) /= array_idx;\n    }\n\n    /// @brief returns the parent of this JSON pointer\n    /// @sa https://json.nlohmann.me/api/json_pointer/parent_pointer/\n    json_pointer parent_pointer() const\n    {\n        if (empty())\n        {\n            return *this;\n        }\n\n        json_pointer res = *this;\n        res.pop_back();\n        return res;\n    }\n\n    /// @brief remove last reference token\n    /// @sa https://json.nlohmann.me/api/json_pointer/pop_back/\n    void pop_back()\n    {\n        if (JSON_HEDLEY_UNLIKELY(empty()))\n        {\n            JSON_THROW(detail::out_of_range::create(405, \"JSON pointer has no parent\", BasicJsonType()));\n        }\n\n        reference_tokens.pop_back();\n    }\n\n    /// @brief return last reference token\n    /// @sa https://json.nlohmann.me/api/json_pointer/back/\n    const std::string& back() const\n    {\n        if (JSON_HEDLEY_UNLIKELY(empty()))\n        {\n            JSON_THROW(detail::out_of_range::create(405, \"JSON pointer has no parent\", BasicJsonType()));\n        }\n\n        return reference_tokens.back();\n    }\n\n    /// @brief append an unescaped token at the end of the reference pointer\n    /// @sa https://json.nlohmann.me/api/json_pointer/push_back/\n    void push_back(const std::string& token)\n    {\n        reference_tokens.push_back(token);\n    }\n\n    /// @brief append an unescaped token at the end of the reference pointer\n    /// @sa https://json.nlohmann.me/api/json_pointer/push_back/\n    void push_back(std::string&& token)\n    {\n        reference_tokens.push_back(std::move(token));\n    }\n\n    /// @brief return whether pointer points to the root document\n    /// @sa https://json.nlohmann.me/api/json_pointer/empty/\n    bool empty() const noexcept\n    {\n        return reference_tokens.empty();\n    }\n\n  private:\n    /*!\n    @param[in] s  reference token to be converted into an array index\n\n    @return integer representation of @a s\n\n    @throw parse_error.106  if an array index begins with '0'\n    @throw parse_error.109  if an array index begins not with a digit\n    @throw out_of_range.404 if string @a s could not be converted to an integer\n    @throw out_of_range.410 if an array index exceeds size_type\n    */\n    static typename BasicJsonType::size_type array_index(const std::string& s)\n    {\n        using size_type = typename BasicJsonType::size_type;\n\n        // error condition (cf. RFC 6901, Sect. 4)\n        if (JSON_HEDLEY_UNLIKELY(s.size() > 1 && s[0] == '0'))\n        {\n            JSON_THROW(detail::parse_error::create(106, 0, \"array index '\" + s + \"' must not begin with '0'\", BasicJsonType()));\n        }\n\n        // error condition (cf. RFC 6901, Sect. 4)\n        if (JSON_HEDLEY_UNLIKELY(s.size() > 1 && !(s[0] >= '1' && s[0] <= '9')))\n        {\n            JSON_THROW(detail::parse_error::create(109, 0, \"array index '\" + s + \"' is not a number\", BasicJsonType()));\n        }\n\n        std::size_t processed_chars = 0;\n        unsigned long long res = 0;  // NOLINT(runtime/int)\n        JSON_TRY\n        {\n            res = std::stoull(s, &processed_chars);\n        }\n        JSON_CATCH(std::out_of_range&)\n        {\n            JSON_THROW(detail::out_of_range::create(404, \"unresolved reference token '\" + s + \"'\", BasicJsonType()));\n        }\n\n        // check if the string was completely read\n        if (JSON_HEDLEY_UNLIKELY(processed_chars != s.size()))\n        {\n            JSON_THROW(detail::out_of_range::create(404, \"unresolved reference token '\" + s + \"'\", BasicJsonType()));\n        }\n\n        // only triggered on special platforms (like 32bit), see also\n        // https://github.com/nlohmann/json/pull/2203\n        if (res >= static_cast<unsigned long long>((std::numeric_limits<size_type>::max)()))  // NOLINT(runtime/int)\n        {\n            JSON_THROW(detail::out_of_range::create(410, \"array index \" + s + \" exceeds size_type\", BasicJsonType())); // LCOV_EXCL_LINE\n        }\n\n        return static_cast<size_type>(res);\n    }\n\n  JSON_PRIVATE_UNLESS_TESTED:\n    json_pointer top() const\n    {\n        if (JSON_HEDLEY_UNLIKELY(empty()))\n        {\n            JSON_THROW(detail::out_of_range::create(405, \"JSON pointer has no parent\", BasicJsonType()));\n        }\n\n        json_pointer result = *this;\n        result.reference_tokens = {reference_tokens[0]};\n        return result;\n    }\n\n  private:\n    /*!\n    @brief create and return a reference to the pointed to value\n\n    @complexity Linear in the number of reference tokens.\n\n    @throw parse_error.109 if array index is not a number\n    @throw type_error.313 if value cannot be unflattened\n    */\n    BasicJsonType& get_and_create(BasicJsonType& j) const\n    {\n        auto* result = &j;\n\n        // in case no reference tokens exist, return a reference to the JSON value\n        // j which will be overwritten by a primitive value\n        for (const auto& reference_token : reference_tokens)\n        {\n            switch (result->type())\n            {\n                case detail::value_t::null:\n                {\n                    if (reference_token == \"0\")\n                    {\n                        // start a new array if reference token is 0\n                        result = &result->operator[](0);\n                    }\n                    else\n                    {\n                        // start a new object otherwise\n                        result = &result->operator[](reference_token);\n                    }\n                    break;\n                }\n\n                case detail::value_t::object:\n                {\n                    // create an entry in the object\n                    result = &result->operator[](reference_token);\n                    break;\n                }\n\n                case detail::value_t::array:\n                {\n                    // create an entry in the array\n                    result = &result->operator[](array_index(reference_token));\n                    break;\n                }\n\n                /*\n                The following code is only reached if there exists a reference\n                token _and_ the current value is primitive. In this case, we have\n                an error situation, because primitive values may only occur as\n                single value; that is, with an empty list of reference tokens.\n                */\n                case detail::value_t::string:\n                case detail::value_t::boolean:\n                case detail::value_t::number_integer:\n                case detail::value_t::number_unsigned:\n                case detail::value_t::number_float:\n                case detail::value_t::binary:\n                case detail::value_t::discarded:\n                default:\n                    JSON_THROW(detail::type_error::create(313, \"invalid value to unflatten\", j));\n            }\n        }\n\n        return *result;\n    }\n\n    /*!\n    @brief return a reference to the pointed to value\n\n    @note This version does not throw if a value is not present, but tries to\n          create nested values instead. For instance, calling this function\n          with pointer `\"/this/that\"` on a null value is equivalent to calling\n          `operator[](\"this\").operator[](\"that\")` on that value, effectively\n          changing the null value to an object.\n\n    @param[in] ptr  a JSON value\n\n    @return reference to the JSON value pointed to by the JSON pointer\n\n    @complexity Linear in the length of the JSON pointer.\n\n    @throw parse_error.106   if an array index begins with '0'\n    @throw parse_error.109   if an array index was not a number\n    @throw out_of_range.404  if the JSON pointer can not be resolved\n    */\n    BasicJsonType& get_unchecked(BasicJsonType* ptr) const\n    {\n        for (const auto& reference_token : reference_tokens)\n        {\n            // convert null values to arrays or objects before continuing\n            if (ptr->is_null())\n            {\n                // check if reference token is a number\n                const bool nums =\n                    std::all_of(reference_token.begin(), reference_token.end(),\n                                [](const unsigned char x)\n                {\n                    return std::isdigit(x);\n                });\n\n                // change value to array for numbers or \"-\" or to object otherwise\n                *ptr = (nums || reference_token == \"-\")\n                       ? detail::value_t::array\n                       : detail::value_t::object;\n            }\n\n            switch (ptr->type())\n            {\n                case detail::value_t::object:\n                {\n                    // use unchecked object access\n                    ptr = &ptr->operator[](reference_token);\n                    break;\n                }\n\n                case detail::value_t::array:\n                {\n                    if (reference_token == \"-\")\n                    {\n                        // explicitly treat \"-\" as index beyond the end\n                        ptr = &ptr->operator[](ptr->m_value.array->size());\n                    }\n                    else\n                    {\n                        // convert array index to number; unchecked access\n                        ptr = &ptr->operator[](array_index(reference_token));\n                    }\n                    break;\n                }\n\n                case detail::value_t::null:\n                case detail::value_t::string:\n                case detail::value_t::boolean:\n                case detail::value_t::number_integer:\n                case detail::value_t::number_unsigned:\n                case detail::value_t::number_float:\n                case detail::value_t::binary:\n                case detail::value_t::discarded:\n                default:\n                    JSON_THROW(detail::out_of_range::create(404, \"unresolved reference token '\" + reference_token + \"'\", *ptr));\n            }\n        }\n\n        return *ptr;\n    }\n\n    /*!\n    @throw parse_error.106   if an array index begins with '0'\n    @throw parse_error.109   if an array index was not a number\n    @throw out_of_range.402  if the array index '-' is used\n    @throw out_of_range.404  if the JSON pointer can not be resolved\n    */\n    BasicJsonType& get_checked(BasicJsonType* ptr) const\n    {\n        for (const auto& reference_token : reference_tokens)\n        {\n            switch (ptr->type())\n            {\n                case detail::value_t::object:\n                {\n                    // note: at performs range check\n                    ptr = &ptr->at(reference_token);\n                    break;\n                }\n\n                case detail::value_t::array:\n                {\n                    if (JSON_HEDLEY_UNLIKELY(reference_token == \"-\"))\n                    {\n                        // \"-\" always fails the range check\n                        JSON_THROW(detail::out_of_range::create(402,\n                                                                \"array index '-' (\" + std::to_string(ptr->m_value.array->size()) +\n                                                                \") is out of range\", *ptr));\n                    }\n\n                    // note: at performs range check\n                    ptr = &ptr->at(array_index(reference_token));\n                    break;\n                }\n\n                case detail::value_t::null:\n                case detail::value_t::string:\n                case detail::value_t::boolean:\n                case detail::value_t::number_integer:\n                case detail::value_t::number_unsigned:\n                case detail::value_t::number_float:\n                case detail::value_t::binary:\n                case detail::value_t::discarded:\n                default:\n                    JSON_THROW(detail::out_of_range::create(404, \"unresolved reference token '\" + reference_token + \"'\", *ptr));\n            }\n        }\n\n        return *ptr;\n    }\n\n    /*!\n    @brief return a const reference to the pointed to value\n\n    @param[in] ptr  a JSON value\n\n    @return const reference to the JSON value pointed to by the JSON\n    pointer\n\n    @throw parse_error.106   if an array index begins with '0'\n    @throw parse_error.109   if an array index was not a number\n    @throw out_of_range.402  if the array index '-' is used\n    @throw out_of_range.404  if the JSON pointer can not be resolved\n    */\n    const BasicJsonType& get_unchecked(const BasicJsonType* ptr) const\n    {\n        for (const auto& reference_token : reference_tokens)\n        {\n            switch (ptr->type())\n            {\n                case detail::value_t::object:\n                {\n                    // use unchecked object access\n                    ptr = &ptr->operator[](reference_token);\n                    break;\n                }\n\n                case detail::value_t::array:\n                {\n                    if (JSON_HEDLEY_UNLIKELY(reference_token == \"-\"))\n                    {\n                        // \"-\" cannot be used for const access\n                        JSON_THROW(detail::out_of_range::create(402, \"array index '-' (\" + std::to_string(ptr->m_value.array->size()) + \") is out of range\", *ptr));\n                    }\n\n                    // use unchecked array access\n                    ptr = &ptr->operator[](array_index(reference_token));\n                    break;\n                }\n\n                case detail::value_t::null:\n                case detail::value_t::string:\n                case detail::value_t::boolean:\n                case detail::value_t::number_integer:\n                case detail::value_t::number_unsigned:\n                case detail::value_t::number_float:\n                case detail::value_t::binary:\n                case detail::value_t::discarded:\n                default:\n                    JSON_THROW(detail::out_of_range::create(404, \"unresolved reference token '\" + reference_token + \"'\", *ptr));\n            }\n        }\n\n        return *ptr;\n    }\n\n    /*!\n    @throw parse_error.106   if an array index begins with '0'\n    @throw parse_error.109   if an array index was not a number\n    @throw out_of_range.402  if the array index '-' is used\n    @throw out_of_range.404  if the JSON pointer can not be resolved\n    */\n    const BasicJsonType& get_checked(const BasicJsonType* ptr) const\n    {\n        for (const auto& reference_token : reference_tokens)\n        {\n            switch (ptr->type())\n            {\n                case detail::value_t::object:\n                {\n                    // note: at performs range check\n                    ptr = &ptr->at(reference_token);\n                    break;\n                }\n\n                case detail::value_t::array:\n                {\n                    if (JSON_HEDLEY_UNLIKELY(reference_token == \"-\"))\n                    {\n                        // \"-\" always fails the range check\n                        JSON_THROW(detail::out_of_range::create(402,\n                                                                \"array index '-' (\" + std::to_string(ptr->m_value.array->size()) +\n                                                                \") is out of range\", *ptr));\n                    }\n\n                    // note: at performs range check\n                    ptr = &ptr->at(array_index(reference_token));\n                    break;\n                }\n\n                case detail::value_t::null:\n                case detail::value_t::string:\n                case detail::value_t::boolean:\n                case detail::value_t::number_integer:\n                case detail::value_t::number_unsigned:\n                case detail::value_t::number_float:\n                case detail::value_t::binary:\n                case detail::value_t::discarded:\n                default:\n                    JSON_THROW(detail::out_of_range::create(404, \"unresolved reference token '\" + reference_token + \"'\", *ptr));\n            }\n        }\n\n        return *ptr;\n    }\n\n    /*!\n    @throw parse_error.106   if an array index begins with '0'\n    @throw parse_error.109   if an array index was not a number\n    */\n    bool contains(const BasicJsonType* ptr) const\n    {\n        for (const auto& reference_token : reference_tokens)\n        {\n            switch (ptr->type())\n            {\n                case detail::value_t::object:\n                {\n                    if (!ptr->contains(reference_token))\n                    {\n                        // we did not find the key in the object\n                        return false;\n                    }\n\n                    ptr = &ptr->operator[](reference_token);\n                    break;\n                }\n\n                case detail::value_t::array:\n                {\n                    if (JSON_HEDLEY_UNLIKELY(reference_token == \"-\"))\n                    {\n                        // \"-\" always fails the range check\n                        return false;\n                    }\n                    if (JSON_HEDLEY_UNLIKELY(reference_token.size() == 1 && !(\"0\" <= reference_token && reference_token <= \"9\")))\n                    {\n                        // invalid char\n                        return false;\n                    }\n                    if (JSON_HEDLEY_UNLIKELY(reference_token.size() > 1))\n                    {\n                        if (JSON_HEDLEY_UNLIKELY(!('1' <= reference_token[0] && reference_token[0] <= '9')))\n                        {\n                            // first char should be between '1' and '9'\n                            return false;\n                        }\n                        for (std::size_t i = 1; i < reference_token.size(); i++)\n                        {\n                            if (JSON_HEDLEY_UNLIKELY(!('0' <= reference_token[i] && reference_token[i] <= '9')))\n                            {\n                                // other char should be between '0' and '9'\n                                return false;\n                            }\n                        }\n                    }\n\n                    const auto idx = array_index(reference_token);\n                    if (idx >= ptr->size())\n                    {\n                        // index out of range\n                        return false;\n                    }\n\n                    ptr = &ptr->operator[](idx);\n                    break;\n                }\n\n                case detail::value_t::null:\n                case detail::value_t::string:\n                case detail::value_t::boolean:\n                case detail::value_t::number_integer:\n                case detail::value_t::number_unsigned:\n                case detail::value_t::number_float:\n                case detail::value_t::binary:\n                case detail::value_t::discarded:\n                default:\n                {\n                    // we do not expect primitive values if there is still a\n                    // reference token to process\n                    return false;\n                }\n            }\n        }\n\n        // no reference token left means we found a primitive value\n        return true;\n    }\n\n    /*!\n    @brief split the string input to reference tokens\n\n    @note This function is only called by the json_pointer constructor.\n          All exceptions below are documented there.\n\n    @throw parse_error.107  if the pointer is not empty or begins with '/'\n    @throw parse_error.108  if character '~' is not followed by '0' or '1'\n    */\n    static std::vector<std::string> split(const std::string& reference_string)\n    {\n        std::vector<std::string> result;\n\n        // special case: empty reference string -> no reference tokens\n        if (reference_string.empty())\n        {\n            return result;\n        }\n\n        // check if nonempty reference string begins with slash\n        if (JSON_HEDLEY_UNLIKELY(reference_string[0] != '/'))\n        {\n            JSON_THROW(detail::parse_error::create(107, 1, \"JSON pointer must be empty or begin with '/' - was: '\" + reference_string + \"'\", BasicJsonType()));\n        }\n\n        // extract the reference tokens:\n        // - slash: position of the last read slash (or end of string)\n        // - start: position after the previous slash\n        for (\n            // search for the first slash after the first character\n            std::size_t slash = reference_string.find_first_of('/', 1),\n            // set the beginning of the first reference token\n            start = 1;\n            // we can stop if start == 0 (if slash == std::string::npos)\n            start != 0;\n            // set the beginning of the next reference token\n            // (will eventually be 0 if slash == std::string::npos)\n            start = (slash == std::string::npos) ? 0 : slash + 1,\n            // find next slash\n            slash = reference_string.find_first_of('/', start))\n        {\n            // use the text between the beginning of the reference token\n            // (start) and the last slash (slash).\n            auto reference_token = reference_string.substr(start, slash - start);\n\n            // check reference tokens are properly escaped\n            for (std::size_t pos = reference_token.find_first_of('~');\n                    pos != std::string::npos;\n                    pos = reference_token.find_first_of('~', pos + 1))\n            {\n                JSON_ASSERT(reference_token[pos] == '~');\n\n                // ~ must be followed by 0 or 1\n                if (JSON_HEDLEY_UNLIKELY(pos == reference_token.size() - 1 ||\n                                         (reference_token[pos + 1] != '0' &&\n                                          reference_token[pos + 1] != '1')))\n                {\n                    JSON_THROW(detail::parse_error::create(108, 0, \"escape character '~' must be followed with '0' or '1'\", BasicJsonType()));\n                }\n            }\n\n            // finally, store the reference token\n            detail::unescape(reference_token);\n            result.push_back(reference_token);\n        }\n\n        return result;\n    }\n\n  private:\n    /*!\n    @param[in] reference_string  the reference string to the current value\n    @param[in] value             the value to consider\n    @param[in,out] result        the result object to insert values to\n\n    @note Empty objects or arrays are flattened to `null`.\n    */\n    static void flatten(const std::string& reference_string,\n                        const BasicJsonType& value,\n                        BasicJsonType& result)\n    {\n        switch (value.type())\n        {\n            case detail::value_t::array:\n            {\n                if (value.m_value.array->empty())\n                {\n                    // flatten empty array as null\n                    result[reference_string] = nullptr;\n                }\n                else\n                {\n                    // iterate array and use index as reference string\n                    for (std::size_t i = 0; i < value.m_value.array->size(); ++i)\n                    {\n                        flatten(reference_string + \"/\" + std::to_string(i),\n                                value.m_value.array->operator[](i), result);\n                    }\n                }\n                break;\n            }\n\n            case detail::value_t::object:\n            {\n                if (value.m_value.object->empty())\n                {\n                    // flatten empty object as null\n                    result[reference_string] = nullptr;\n                }\n                else\n                {\n                    // iterate object and use keys as reference string\n                    for (const auto& element : *value.m_value.object)\n                    {\n                        flatten(reference_string + \"/\" + detail::escape(element.first), element.second, result);\n                    }\n                }\n                break;\n            }\n\n            case detail::value_t::null:\n            case detail::value_t::string:\n            case detail::value_t::boolean:\n            case detail::value_t::number_integer:\n            case detail::value_t::number_unsigned:\n            case detail::value_t::number_float:\n            case detail::value_t::binary:\n            case detail::value_t::discarded:\n            default:\n            {\n                // add primitive value with its reference string\n                result[reference_string] = value;\n                break;\n            }\n        }\n    }\n\n    /*!\n    @param[in] value  flattened JSON\n\n    @return unflattened JSON\n\n    @throw parse_error.109 if array index is not a number\n    @throw type_error.314  if value is not an object\n    @throw type_error.315  if object values are not primitive\n    @throw type_error.313  if value cannot be unflattened\n    */\n    static BasicJsonType\n    unflatten(const BasicJsonType& value)\n    {\n        if (JSON_HEDLEY_UNLIKELY(!value.is_object()))\n        {\n            JSON_THROW(detail::type_error::create(314, \"only objects can be unflattened\", value));\n        }\n\n        BasicJsonType result;\n\n        // iterate the JSON object values\n        for (const auto& element : *value.m_value.object)\n        {\n            if (JSON_HEDLEY_UNLIKELY(!element.second.is_primitive()))\n            {\n                JSON_THROW(detail::type_error::create(315, \"values in object must be primitive\", element.second));\n            }\n\n            // assign value to reference pointed to by JSON pointer; Note that if\n            // the JSON pointer is \"\" (i.e., points to the whole value), function\n            // get_and_create returns a reference to result itself. An assignment\n            // will then create a primitive value.\n            json_pointer(element.first).get_and_create(result) = element.second;\n        }\n\n        return result;\n    }\n\n    /*!\n    @brief compares two JSON pointers for equality\n\n    @param[in] lhs  JSON pointer to compare\n    @param[in] rhs  JSON pointer to compare\n    @return whether @a lhs is equal to @a rhs\n\n    @complexity Linear in the length of the JSON pointer\n\n    @exceptionsafety No-throw guarantee: this function never throws exceptions.\n    */\n    friend bool operator==(json_pointer const& lhs,\n                           json_pointer const& rhs) noexcept\n    {\n        return lhs.reference_tokens == rhs.reference_tokens;\n    }\n\n    /*!\n    @brief compares two JSON pointers for inequality\n\n    @param[in] lhs  JSON pointer to compare\n    @param[in] rhs  JSON pointer to compare\n    @return whether @a lhs is not equal @a rhs\n\n    @complexity Linear in the length of the JSON pointer\n\n    @exceptionsafety No-throw guarantee: this function never throws exceptions.\n    */\n    friend bool operator!=(json_pointer const& lhs,\n                           json_pointer const& rhs) noexcept\n    {\n        return !(lhs == rhs);\n    }\n\n    /// the reference tokens\n    std::vector<std::string> reference_tokens;\n};\n}  // namespace nlohmann\n\n// #include <nlohmann/detail/json_ref.hpp>\n\n\n#include <initializer_list>\n#include <utility>\n\n// #include <nlohmann/detail/meta/type_traits.hpp>\n\n\nnamespace nlohmann\n{\nnamespace detail\n{\ntemplate<typename BasicJsonType>\nclass json_ref\n{\n  public:\n    using value_type = BasicJsonType;\n\n    json_ref(value_type&& value)\n        : owned_value(std::move(value))\n    {}\n\n    json_ref(const value_type& value)\n        : value_ref(&value)\n    {}\n\n    json_ref(std::initializer_list<json_ref> init)\n        : owned_value(init)\n    {}\n\n    template <\n        class... Args,\n        enable_if_t<std::is_constructible<value_type, Args...>::value, int> = 0 >\n    json_ref(Args && ... args)\n        : owned_value(std::forward<Args>(args)...)\n    {}\n\n    // class should be movable only\n    json_ref(json_ref&&) noexcept = default;\n    json_ref(const json_ref&) = delete;\n    json_ref& operator=(const json_ref&) = delete;\n    json_ref& operator=(json_ref&&) = delete;\n    ~json_ref() = default;\n\n    value_type moved_or_copied() const\n    {\n        if (value_ref == nullptr)\n        {\n            return std::move(owned_value);\n        }\n        return *value_ref;\n    }\n\n    value_type const& operator*() const\n    {\n        return value_ref ? *value_ref : owned_value;\n    }\n\n    value_type const* operator->() const\n    {\n        return &** this;\n    }\n\n  private:\n    mutable value_type owned_value = nullptr;\n    value_type const* value_ref = nullptr;\n};\n}  // namespace detail\n}  // namespace nlohmann\n\n// #include <nlohmann/detail/macro_scope.hpp>\n\n// #include <nlohmann/detail/string_escape.hpp>\n\n// #include <nlohmann/detail/meta/cpp_future.hpp>\n\n// #include <nlohmann/detail/meta/type_traits.hpp>\n\n// #include <nlohmann/detail/output/binary_writer.hpp>\n\n\n#include <algorithm> // reverse\n#include <array> // array\n#include <cmath> // isnan, isinf\n#include <cstdint> // uint8_t, uint16_t, uint32_t, uint64_t\n#include <cstring> // memcpy\n#include <limits> // numeric_limits\n#include <string> // string\n#include <utility> // move\n\n// #include <nlohmann/detail/input/binary_reader.hpp>\n\n// #include <nlohmann/detail/macro_scope.hpp>\n\n// #include <nlohmann/detail/output/output_adapters.hpp>\n\n\n#include <algorithm> // copy\n#include <cstddef> // size_t\n#include <iterator> // back_inserter\n#include <memory> // shared_ptr, make_shared\n#include <string> // basic_string\n#include <vector> // vector\n\n#ifndef JSON_NO_IO\n    #include <ios>      // streamsize\n    #include <ostream>  // basic_ostream\n#endif  // JSON_NO_IO\n\n// #include <nlohmann/detail/macro_scope.hpp>\n\n\nnamespace nlohmann\n{\nnamespace detail\n{\n/// abstract output adapter interface\ntemplate<typename CharType> struct output_adapter_protocol\n{\n    virtual void write_character(CharType c) = 0;\n    virtual void write_characters(const CharType* s, std::size_t length) = 0;\n    virtual ~output_adapter_protocol() = default;\n\n    output_adapter_protocol() = default;\n    output_adapter_protocol(const output_adapter_protocol&) = default;\n    output_adapter_protocol(output_adapter_protocol&&) noexcept = default;\n    output_adapter_protocol& operator=(const output_adapter_protocol&) = default;\n    output_adapter_protocol& operator=(output_adapter_protocol&&) noexcept = default;\n};\n\n/// a type to simplify interfaces\ntemplate<typename CharType>\nusing output_adapter_t = std::shared_ptr<output_adapter_protocol<CharType>>;\n\n/// output adapter for byte vectors\ntemplate<typename CharType, typename AllocatorType = std::allocator<CharType>>\nclass output_vector_adapter : public output_adapter_protocol<CharType>\n{\n  public:\n    explicit output_vector_adapter(std::vector<CharType, AllocatorType>& vec) noexcept\n        : v(vec)\n    {}\n\n    void write_character(CharType c) override\n    {\n        v.push_back(c);\n    }\n\n    JSON_HEDLEY_NON_NULL(2)\n    void write_characters(const CharType* s, std::size_t length) override\n    {\n        std::copy(s, s + length, std::back_inserter(v));\n    }\n\n  private:\n    std::vector<CharType, AllocatorType>& v;\n};\n\n#ifndef JSON_NO_IO\n/// output adapter for output streams\ntemplate<typename CharType>\nclass output_stream_adapter : public output_adapter_protocol<CharType>\n{\n  public:\n    explicit output_stream_adapter(std::basic_ostream<CharType>& s) noexcept\n        : stream(s)\n    {}\n\n    void write_character(CharType c) override\n    {\n        stream.put(c);\n    }\n\n    JSON_HEDLEY_NON_NULL(2)\n    void write_characters(const CharType* s, std::size_t length) override\n    {\n        stream.write(s, static_cast<std::streamsize>(length));\n    }\n\n  private:\n    std::basic_ostream<CharType>& stream;\n};\n#endif  // JSON_NO_IO\n\n/// output adapter for basic_string\ntemplate<typename CharType, typename StringType = std::basic_string<CharType>>\nclass output_string_adapter : public output_adapter_protocol<CharType>\n{\n  public:\n    explicit output_string_adapter(StringType& s) noexcept\n        : str(s)\n    {}\n\n    void write_character(CharType c) override\n    {\n        str.push_back(c);\n    }\n\n    JSON_HEDLEY_NON_NULL(2)\n    void write_characters(const CharType* s, std::size_t length) override\n    {\n        str.append(s, length);\n    }\n\n  private:\n    StringType& str;\n};\n\ntemplate<typename CharType, typename StringType = std::basic_string<CharType>>\nclass output_adapter\n{\n  public:\n    template<typename AllocatorType = std::allocator<CharType>>\n    output_adapter(std::vector<CharType, AllocatorType>& vec)\n        : oa(std::make_shared<output_vector_adapter<CharType, AllocatorType>>(vec)) {}\n\n#ifndef JSON_NO_IO\n    output_adapter(std::basic_ostream<CharType>& s)\n        : oa(std::make_shared<output_stream_adapter<CharType>>(s)) {}\n#endif  // JSON_NO_IO\n\n    output_adapter(StringType& s)\n        : oa(std::make_shared<output_string_adapter<CharType, StringType>>(s)) {}\n\n    operator output_adapter_t<CharType>()\n    {\n        return oa;\n    }\n\n  private:\n    output_adapter_t<CharType> oa = nullptr;\n};\n}  // namespace detail\n}  // namespace nlohmann\n\n\nnamespace nlohmann\n{\nnamespace detail\n{\n///////////////////\n// binary writer //\n///////////////////\n\n/*!\n@brief serialization to CBOR and MessagePack values\n*/\ntemplate<typename BasicJsonType, typename CharType>\nclass binary_writer\n{\n    using string_t = typename BasicJsonType::string_t;\n    using binary_t = typename BasicJsonType::binary_t;\n    using number_float_t = typename BasicJsonType::number_float_t;\n\n  public:\n    /*!\n    @brief create a binary writer\n\n    @param[in] adapter  output adapter to write to\n    */\n    explicit binary_writer(output_adapter_t<CharType> adapter) : oa(std::move(adapter))\n    {\n        JSON_ASSERT(oa);\n    }\n\n    /*!\n    @param[in] j  JSON value to serialize\n    @pre       j.type() == value_t::object\n    */\n    void write_bson(const BasicJsonType& j)\n    {\n        switch (j.type())\n        {\n            case value_t::object:\n            {\n                write_bson_object(*j.m_value.object);\n                break;\n            }\n\n            case value_t::null:\n            case value_t::array:\n            case value_t::string:\n            case value_t::boolean:\n            case value_t::number_integer:\n            case value_t::number_unsigned:\n            case value_t::number_float:\n            case value_t::binary:\n            case value_t::discarded:\n            default:\n            {\n                JSON_THROW(type_error::create(317, \"to serialize to BSON, top-level type must be object, but is \" + std::string(j.type_name()), j));\n            }\n        }\n    }\n\n    /*!\n    @param[in] j  JSON value to serialize\n    */\n    void write_cbor(const BasicJsonType& j)\n    {\n        switch (j.type())\n        {\n            case value_t::null:\n            {\n                oa->write_character(to_char_type(0xF6));\n                break;\n            }\n\n            case value_t::boolean:\n            {\n                oa->write_character(j.m_value.boolean\n                                    ? to_char_type(0xF5)\n                                    : to_char_type(0xF4));\n                break;\n            }\n\n            case value_t::number_integer:\n            {\n                if (j.m_value.number_integer >= 0)\n                {\n                    // CBOR does not differentiate between positive signed\n                    // integers and unsigned integers. Therefore, we used the\n                    // code from the value_t::number_unsigned case here.\n                    if (j.m_value.number_integer <= 0x17)\n                    {\n                        write_number(static_cast<std::uint8_t>(j.m_value.number_integer));\n                    }\n                    else if (j.m_value.number_integer <= (std::numeric_limits<std::uint8_t>::max)())\n                    {\n                        oa->write_character(to_char_type(0x18));\n                        write_number(static_cast<std::uint8_t>(j.m_value.number_integer));\n                    }\n                    else if (j.m_value.number_integer <= (std::numeric_limits<std::uint16_t>::max)())\n                    {\n                        oa->write_character(to_char_type(0x19));\n                        write_number(static_cast<std::uint16_t>(j.m_value.number_integer));\n                    }\n                    else if (j.m_value.number_integer <= (std::numeric_limits<std::uint32_t>::max)())\n                    {\n                        oa->write_character(to_char_type(0x1A));\n                        write_number(static_cast<std::uint32_t>(j.m_value.number_integer));\n                    }\n                    else\n                    {\n                        oa->write_character(to_char_type(0x1B));\n                        write_number(static_cast<std::uint64_t>(j.m_value.number_integer));\n                    }\n                }\n                else\n                {\n                    // The conversions below encode the sign in the first\n                    // byte, and the value is converted to a positive number.\n                    const auto positive_number = -1 - j.m_value.number_integer;\n                    if (j.m_value.number_integer >= -24)\n                    {\n                        write_number(static_cast<std::uint8_t>(0x20 + positive_number));\n                    }\n                    else if (positive_number <= (std::numeric_limits<std::uint8_t>::max)())\n                    {\n                        oa->write_character(to_char_type(0x38));\n                        write_number(static_cast<std::uint8_t>(positive_number));\n                    }\n                    else if (positive_number <= (std::numeric_limits<std::uint16_t>::max)())\n                    {\n                        oa->write_character(to_char_type(0x39));\n                        write_number(static_cast<std::uint16_t>(positive_number));\n                    }\n                    else if (positive_number <= (std::numeric_limits<std::uint32_t>::max)())\n                    {\n                        oa->write_character(to_char_type(0x3A));\n                        write_number(static_cast<std::uint32_t>(positive_number));\n                    }\n                    else\n                    {\n                        oa->write_character(to_char_type(0x3B));\n                        write_number(static_cast<std::uint64_t>(positive_number));\n                    }\n                }\n                break;\n            }\n\n            case value_t::number_unsigned:\n            {\n                if (j.m_value.number_unsigned <= 0x17)\n                {\n                    write_number(static_cast<std::uint8_t>(j.m_value.number_unsigned));\n                }\n                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())\n                {\n                    oa->write_character(to_char_type(0x18));\n                    write_number(static_cast<std::uint8_t>(j.m_value.number_unsigned));\n                }\n                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())\n                {\n                    oa->write_character(to_char_type(0x19));\n                    write_number(static_cast<std::uint16_t>(j.m_value.number_unsigned));\n                }\n                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())\n                {\n                    oa->write_character(to_char_type(0x1A));\n                    write_number(static_cast<std::uint32_t>(j.m_value.number_unsigned));\n                }\n                else\n                {\n                    oa->write_character(to_char_type(0x1B));\n                    write_number(static_cast<std::uint64_t>(j.m_value.number_unsigned));\n                }\n                break;\n            }\n\n            case value_t::number_float:\n            {\n                if (std::isnan(j.m_value.number_float))\n                {\n                    // NaN is 0xf97e00 in CBOR\n                    oa->write_character(to_char_type(0xF9));\n                    oa->write_character(to_char_type(0x7E));\n                    oa->write_character(to_char_type(0x00));\n                }\n                else if (std::isinf(j.m_value.number_float))\n                {\n                    // Infinity is 0xf97c00, -Infinity is 0xf9fc00\n                    oa->write_character(to_char_type(0xf9));\n                    oa->write_character(j.m_value.number_float > 0 ? to_char_type(0x7C) : to_char_type(0xFC));\n                    oa->write_character(to_char_type(0x00));\n                }\n                else\n                {\n                    write_compact_float(j.m_value.number_float, detail::input_format_t::cbor);\n                }\n                break;\n            }\n\n            case value_t::string:\n            {\n                // step 1: write control byte and the string length\n                const auto N = j.m_value.string->size();\n                if (N <= 0x17)\n                {\n                    write_number(static_cast<std::uint8_t>(0x60 + N));\n                }\n                else if (N <= (std::numeric_limits<std::uint8_t>::max)())\n                {\n                    oa->write_character(to_char_type(0x78));\n                    write_number(static_cast<std::uint8_t>(N));\n                }\n                else if (N <= (std::numeric_limits<std::uint16_t>::max)())\n                {\n                    oa->write_character(to_char_type(0x79));\n                    write_number(static_cast<std::uint16_t>(N));\n                }\n                else if (N <= (std::numeric_limits<std::uint32_t>::max)())\n                {\n                    oa->write_character(to_char_type(0x7A));\n                    write_number(static_cast<std::uint32_t>(N));\n                }\n                // LCOV_EXCL_START\n                else if (N <= (std::numeric_limits<std::uint64_t>::max)())\n                {\n                    oa->write_character(to_char_type(0x7B));\n                    write_number(static_cast<std::uint64_t>(N));\n                }\n                // LCOV_EXCL_STOP\n\n                // step 2: write the string\n                oa->write_characters(\n                    reinterpret_cast<const CharType*>(j.m_value.string->c_str()),\n                    j.m_value.string->size());\n                break;\n            }\n\n            case value_t::array:\n            {\n                // step 1: write control byte and the array size\n                const auto N = j.m_value.array->size();\n                if (N <= 0x17)\n                {\n                    write_number(static_cast<std::uint8_t>(0x80 + N));\n                }\n                else if (N <= (std::numeric_limits<std::uint8_t>::max)())\n                {\n                    oa->write_character(to_char_type(0x98));\n                    write_number(static_cast<std::uint8_t>(N));\n                }\n                else if (N <= (std::numeric_limits<std::uint16_t>::max)())\n                {\n                    oa->write_character(to_char_type(0x99));\n                    write_number(static_cast<std::uint16_t>(N));\n                }\n                else if (N <= (std::numeric_limits<std::uint32_t>::max)())\n                {\n                    oa->write_character(to_char_type(0x9A));\n                    write_number(static_cast<std::uint32_t>(N));\n                }\n                // LCOV_EXCL_START\n                else if (N <= (std::numeric_limits<std::uint64_t>::max)())\n                {\n                    oa->write_character(to_char_type(0x9B));\n                    write_number(static_cast<std::uint64_t>(N));\n                }\n                // LCOV_EXCL_STOP\n\n                // step 2: write each element\n                for (const auto& el : *j.m_value.array)\n                {\n                    write_cbor(el);\n                }\n                break;\n            }\n\n            case value_t::binary:\n            {\n                if (j.m_value.binary->has_subtype())\n                {\n                    if (j.m_value.binary->subtype() <= (std::numeric_limits<std::uint8_t>::max)())\n                    {\n                        write_number(static_cast<std::uint8_t>(0xd8));\n                        write_number(static_cast<std::uint8_t>(j.m_value.binary->subtype()));\n                    }\n                    else if (j.m_value.binary->subtype() <= (std::numeric_limits<std::uint16_t>::max)())\n                    {\n                        write_number(static_cast<std::uint8_t>(0xd9));\n                        write_number(static_cast<std::uint16_t>(j.m_value.binary->subtype()));\n                    }\n                    else if (j.m_value.binary->subtype() <= (std::numeric_limits<std::uint32_t>::max)())\n                    {\n                        write_number(static_cast<std::uint8_t>(0xda));\n                        write_number(static_cast<std::uint32_t>(j.m_value.binary->subtype()));\n                    }\n                    else if (j.m_value.binary->subtype() <= (std::numeric_limits<std::uint64_t>::max)())\n                    {\n                        write_number(static_cast<std::uint8_t>(0xdb));\n                        write_number(static_cast<std::uint64_t>(j.m_value.binary->subtype()));\n                    }\n                }\n\n                // step 1: write control byte and the binary array size\n                const auto N = j.m_value.binary->size();\n                if (N <= 0x17)\n                {\n                    write_number(static_cast<std::uint8_t>(0x40 + N));\n                }\n                else if (N <= (std::numeric_limits<std::uint8_t>::max)())\n                {\n                    oa->write_character(to_char_type(0x58));\n                    write_number(static_cast<std::uint8_t>(N));\n                }\n                else if (N <= (std::numeric_limits<std::uint16_t>::max)())\n                {\n                    oa->write_character(to_char_type(0x59));\n                    write_number(static_cast<std::uint16_t>(N));\n                }\n                else if (N <= (std::numeric_limits<std::uint32_t>::max)())\n                {\n                    oa->write_character(to_char_type(0x5A));\n                    write_number(static_cast<std::uint32_t>(N));\n                }\n                // LCOV_EXCL_START\n                else if (N <= (std::numeric_limits<std::uint64_t>::max)())\n                {\n                    oa->write_character(to_char_type(0x5B));\n                    write_number(static_cast<std::uint64_t>(N));\n                }\n                // LCOV_EXCL_STOP\n\n                // step 2: write each element\n                oa->write_characters(\n                    reinterpret_cast<const CharType*>(j.m_value.binary->data()),\n                    N);\n\n                break;\n            }\n\n            case value_t::object:\n            {\n                // step 1: write control byte and the object size\n                const auto N = j.m_value.object->size();\n                if (N <= 0x17)\n                {\n                    write_number(static_cast<std::uint8_t>(0xA0 + N));\n                }\n                else if (N <= (std::numeric_limits<std::uint8_t>::max)())\n                {\n                    oa->write_character(to_char_type(0xB8));\n                    write_number(static_cast<std::uint8_t>(N));\n                }\n                else if (N <= (std::numeric_limits<std::uint16_t>::max)())\n                {\n                    oa->write_character(to_char_type(0xB9));\n                    write_number(static_cast<std::uint16_t>(N));\n                }\n                else if (N <= (std::numeric_limits<std::uint32_t>::max)())\n                {\n                    oa->write_character(to_char_type(0xBA));\n                    write_number(static_cast<std::uint32_t>(N));\n                }\n                // LCOV_EXCL_START\n                else if (N <= (std::numeric_limits<std::uint64_t>::max)())\n                {\n                    oa->write_character(to_char_type(0xBB));\n                    write_number(static_cast<std::uint64_t>(N));\n                }\n                // LCOV_EXCL_STOP\n\n                // step 2: write each element\n                for (const auto& el : *j.m_value.object)\n                {\n                    write_cbor(el.first);\n                    write_cbor(el.second);\n                }\n                break;\n            }\n\n            case value_t::discarded:\n            default:\n                break;\n        }\n    }\n\n    /*!\n    @param[in] j  JSON value to serialize\n    */\n    void write_msgpack(const BasicJsonType& j)\n    {\n        switch (j.type())\n        {\n            case value_t::null: // nil\n            {\n                oa->write_character(to_char_type(0xC0));\n                break;\n            }\n\n            case value_t::boolean: // true and false\n            {\n                oa->write_character(j.m_value.boolean\n                                    ? to_char_type(0xC3)\n                                    : to_char_type(0xC2));\n                break;\n            }\n\n            case value_t::number_integer:\n            {\n                if (j.m_value.number_integer >= 0)\n                {\n                    // MessagePack does not differentiate between positive\n                    // signed integers and unsigned integers. Therefore, we used\n                    // the code from the value_t::number_unsigned case here.\n                    if (j.m_value.number_unsigned < 128)\n                    {\n                        // positive fixnum\n                        write_number(static_cast<std::uint8_t>(j.m_value.number_integer));\n                    }\n                    else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())\n                    {\n                        // uint 8\n                        oa->write_character(to_char_type(0xCC));\n                        write_number(static_cast<std::uint8_t>(j.m_value.number_integer));\n                    }\n                    else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())\n                    {\n                        // uint 16\n                        oa->write_character(to_char_type(0xCD));\n                        write_number(static_cast<std::uint16_t>(j.m_value.number_integer));\n                    }\n                    else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())\n                    {\n                        // uint 32\n                        oa->write_character(to_char_type(0xCE));\n                        write_number(static_cast<std::uint32_t>(j.m_value.number_integer));\n                    }\n                    else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())\n                    {\n                        // uint 64\n                        oa->write_character(to_char_type(0xCF));\n                        write_number(static_cast<std::uint64_t>(j.m_value.number_integer));\n                    }\n                }\n                else\n                {\n                    if (j.m_value.number_integer >= -32)\n                    {\n                        // negative fixnum\n                        write_number(static_cast<std::int8_t>(j.m_value.number_integer));\n                    }\n                    else if (j.m_value.number_integer >= (std::numeric_limits<std::int8_t>::min)() &&\n                             j.m_value.number_integer <= (std::numeric_limits<std::int8_t>::max)())\n                    {\n                        // int 8\n                        oa->write_character(to_char_type(0xD0));\n                        write_number(static_cast<std::int8_t>(j.m_value.number_integer));\n                    }\n                    else if (j.m_value.number_integer >= (std::numeric_limits<std::int16_t>::min)() &&\n                             j.m_value.number_integer <= (std::numeric_limits<std::int16_t>::max)())\n                    {\n                        // int 16\n                        oa->write_character(to_char_type(0xD1));\n                        write_number(static_cast<std::int16_t>(j.m_value.number_integer));\n                    }\n                    else if (j.m_value.number_integer >= (std::numeric_limits<std::int32_t>::min)() &&\n                             j.m_value.number_integer <= (std::numeric_limits<std::int32_t>::max)())\n                    {\n                        // int 32\n                        oa->write_character(to_char_type(0xD2));\n                        write_number(static_cast<std::int32_t>(j.m_value.number_integer));\n                    }\n                    else if (j.m_value.number_integer >= (std::numeric_limits<std::int64_t>::min)() &&\n                             j.m_value.number_integer <= (std::numeric_limits<std::int64_t>::max)())\n                    {\n                        // int 64\n                        oa->write_character(to_char_type(0xD3));\n                        write_number(static_cast<std::int64_t>(j.m_value.number_integer));\n                    }\n                }\n                break;\n            }\n\n            case value_t::number_unsigned:\n            {\n                if (j.m_value.number_unsigned < 128)\n                {\n                    // positive fixnum\n                    write_number(static_cast<std::uint8_t>(j.m_value.number_integer));\n                }\n                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())\n                {\n                    // uint 8\n                    oa->write_character(to_char_type(0xCC));\n                    write_number(static_cast<std::uint8_t>(j.m_value.number_integer));\n                }\n                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())\n                {\n                    // uint 16\n                    oa->write_character(to_char_type(0xCD));\n                    write_number(static_cast<std::uint16_t>(j.m_value.number_integer));\n                }\n                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())\n                {\n                    // uint 32\n                    oa->write_character(to_char_type(0xCE));\n                    write_number(static_cast<std::uint32_t>(j.m_value.number_integer));\n                }\n                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())\n                {\n                    // uint 64\n                    oa->write_character(to_char_type(0xCF));\n                    write_number(static_cast<std::uint64_t>(j.m_value.number_integer));\n                }\n                break;\n            }\n\n            case value_t::number_float:\n            {\n                write_compact_float(j.m_value.number_float, detail::input_format_t::msgpack);\n                break;\n            }\n\n            case value_t::string:\n            {\n                // step 1: write control byte and the string length\n                const auto N = j.m_value.string->size();\n                if (N <= 31)\n                {\n                    // fixstr\n                    write_number(static_cast<std::uint8_t>(0xA0 | N));\n                }\n                else if (N <= (std::numeric_limits<std::uint8_t>::max)())\n                {\n                    // str 8\n                    oa->write_character(to_char_type(0xD9));\n                    write_number(static_cast<std::uint8_t>(N));\n                }\n                else if (N <= (std::numeric_limits<std::uint16_t>::max)())\n                {\n                    // str 16\n                    oa->write_character(to_char_type(0xDA));\n                    write_number(static_cast<std::uint16_t>(N));\n                }\n                else if (N <= (std::numeric_limits<std::uint32_t>::max)())\n                {\n                    // str 32\n                    oa->write_character(to_char_type(0xDB));\n                    write_number(static_cast<std::uint32_t>(N));\n                }\n\n                // step 2: write the string\n                oa->write_characters(\n                    reinterpret_cast<const CharType*>(j.m_value.string->c_str()),\n                    j.m_value.string->size());\n                break;\n            }\n\n            case value_t::array:\n            {\n                // step 1: write control byte and the array size\n                const auto N = j.m_value.array->size();\n                if (N <= 15)\n                {\n                    // fixarray\n                    write_number(static_cast<std::uint8_t>(0x90 | N));\n                }\n                else if (N <= (std::numeric_limits<std::uint16_t>::max)())\n                {\n                    // array 16\n                    oa->write_character(to_char_type(0xDC));\n                    write_number(static_cast<std::uint16_t>(N));\n                }\n                else if (N <= (std::numeric_limits<std::uint32_t>::max)())\n                {\n                    // array 32\n                    oa->write_character(to_char_type(0xDD));\n                    write_number(static_cast<std::uint32_t>(N));\n                }\n\n                // step 2: write each element\n                for (const auto& el : *j.m_value.array)\n                {\n                    write_msgpack(el);\n                }\n                break;\n            }\n\n            case value_t::binary:\n            {\n                // step 0: determine if the binary type has a set subtype to\n                // determine whether or not to use the ext or fixext types\n                const bool use_ext = j.m_value.binary->has_subtype();\n\n                // step 1: write control byte and the byte string length\n                const auto N = j.m_value.binary->size();\n                if (N <= (std::numeric_limits<std::uint8_t>::max)())\n                {\n                    std::uint8_t output_type{};\n                    bool fixed = true;\n                    if (use_ext)\n                    {\n                        switch (N)\n                        {\n                            case 1:\n                                output_type = 0xD4; // fixext 1\n                                break;\n                            case 2:\n                                output_type = 0xD5; // fixext 2\n                                break;\n                            case 4:\n                                output_type = 0xD6; // fixext 4\n                                break;\n                            case 8:\n                                output_type = 0xD7; // fixext 8\n                                break;\n                            case 16:\n                                output_type = 0xD8; // fixext 16\n                                break;\n                            default:\n                                output_type = 0xC7; // ext 8\n                                fixed = false;\n                                break;\n                        }\n\n                    }\n                    else\n                    {\n                        output_type = 0xC4; // bin 8\n                     "
        },
        {
          "name": "macloader.rc",
          "type": "blob",
          "size": 5.69921875,
          "content": "﻿// Microsoft Visual C++ generated resource script.\r\n//\r\n#define APSTUDIO_READONLY_SYMBOLS\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Generated from the TEXTINCLUDE 2 resource.\r\n//\r\n#include \"winres.h\"\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n#undef APSTUDIO_READONLY_SYMBOLS\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Chinese (Simplified, China) resources\r\n\r\n#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)\r\nLANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED\r\n\r\n#ifdef APSTUDIO_INVOKED\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// TEXTINCLUDE\r\n//\r\n\r\n\r\n#endif    // APSTUDIO_INVOKED\r\n\r\n#endif    // Chinese (Simplified, China) resources\r\n/////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// English (United States) resources\r\n\r\n#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)\r\nLANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Version\r\n//\r\n\r\nVS_VERSION_INFO VERSIONINFO\r\n FILEVERSION 1,2024,8,15\r\n PRODUCTVERSION 1,2024,8,15\r\n FILEFLAGSMASK 0x3fL\r\n#ifdef _DEBUG\r\n FILEFLAGS 0x1L\r\n#else\r\n FILEFLAGS 0x0L\r\n#endif\r\n FILEOS 0x40004L\r\n FILETYPE 0x1L\r\n FILESUBTYPE 0x0L\r\nBEGIN\r\n    BLOCK \"StringFileInfo\"\r\n    BEGIN\r\n        BLOCK \"080404b0\"\r\n        BEGIN\r\n            VALUE \"CompanyName\", \"2ch\"\r\n            VALUE \"FileDescription\", \"GDI++ Font Rasterizer Driver\"\r\n            VALUE \"FileVersion\", \"1.2024.8.15\"\r\n            VALUE \"InternalName\", \"gdi++\"\r\n            VALUE \"LegalCopyright\", \"(C) 仧0x0D/0x20I, 460. All rights reserved.\"\r\n            VALUE \"OriginalFilename\", \"gdi++.exe\"\r\n            VALUE \"ProductVersion\", \"1.2024.8.15\"\r\n            VALUE \"URL\", \"http://drwatson.nobody.jp/gdi++/\"\r\n        END\r\n    END\r\n    BLOCK \"VarFileInfo\"\r\n    BEGIN\r\n        VALUE \"Translation\", 0x804, 1200\r\n    END\r\nEND\r\n\r\n\r\n#define IDS_USAGE\t\t101\r\n#define IDS_DLL\t\t\t102\r\n#define IDC_EXEC\t\t103\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// String Table\r\n//\r\n\r\nSTRINGTABLE\r\nBEGIN\r\n    IDS_USAGE\t\"macloader.exe <file> argument ...\\n\\nPlease drag and drop executable files or shortcut files.\"\r\n    IDS_DLL\t\t\"error: 0x%08x\\nCannot find a DLL.\"\r\n    IDC_EXEC\t\"error: 0x%08x\\nCannot execute.\"\r\nEND\r\n\r\n#endif    // English (United States) resources\r\n/////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n#ifndef APSTUDIO_INVOKED\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Generated from the TEXTINCLUDE 3 resource.\r\n//\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n#endif    // not APSTUDIO_INVOKED\r\n\r\n"
        },
        {
          "name": "macloader.vcxproj",
          "type": "blob",
          "size": 7.103515625,
          "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<Project DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n  <ItemGroup Label=\"ProjectConfigurations\">\r\n    <ProjectConfiguration Include=\"Debug|Win32\">\r\n      <Configuration>Debug</Configuration>\r\n      <Platform>Win32</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Release|Win32\">\r\n      <Configuration>Release</Configuration>\r\n      <Platform>Win32</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Debug|x64\">\r\n      <Configuration>Debug</Configuration>\r\n      <Platform>x64</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Release|x64\">\r\n      <Configuration>Release</Configuration>\r\n      <Platform>x64</Platform>\r\n    </ProjectConfiguration>\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <ClCompile Include=\"run.cpp\" />\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <ResourceCompile Include=\"macloader.rc\" />\r\n  </ItemGroup>\r\n  <PropertyGroup Label=\"Globals\">\r\n    <VCProjectVersion>17.0</VCProjectVersion>\r\n    <Keyword>Win32Proj</Keyword>\r\n    <ProjectGuid>{6d6ac860-ba16-4be7-9169-21787f21cb6f}</ProjectGuid>\r\n    <RootNamespace>macloader</RootNamespace>\r\n    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>\r\n  </PropertyGroup>\r\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\" Label=\"Configuration\">\r\n    <ConfigurationType>Application</ConfigurationType>\r\n    <UseDebugLibraries>true</UseDebugLibraries>\r\n    <PlatformToolset>v143</PlatformToolset>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\" Label=\"Configuration\">\r\n    <ConfigurationType>Application</ConfigurationType>\r\n    <UseDebugLibraries>false</UseDebugLibraries>\r\n    <PlatformToolset>v143</PlatformToolset>\r\n    <WholeProgramOptimization>true</WholeProgramOptimization>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"Configuration\">\r\n    <ConfigurationType>Application</ConfigurationType>\r\n    <UseDebugLibraries>true</UseDebugLibraries>\r\n    <PlatformToolset>v143</PlatformToolset>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\r\n    <ConfigurationType>Application</ConfigurationType>\r\n    <UseDebugLibraries>false</UseDebugLibraries>\r\n    <PlatformToolset>v143</PlatformToolset>\r\n    <WholeProgramOptimization>true</WholeProgramOptimization>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n  </PropertyGroup>\r\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\r\n  <ImportGroup Label=\"ExtensionSettings\">\r\n  </ImportGroup>\r\n  <ImportGroup Label=\"Shared\">\r\n  </ImportGroup>\r\n  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n  </ImportGroup>\r\n  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n  </ImportGroup>\r\n  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n  </ImportGroup>\r\n  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n  </ImportGroup>\r\n  <PropertyGroup Label=\"UserMacros\" />\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\r\n    <TargetName>$(ProjectName)64</TargetName>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\r\n    <TargetName>$(ProjectName)64</TargetName>\r\n  </PropertyGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\r\n    <ClCompile>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <SDLCheck>true</SDLCheck>\r\n      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;USE_DETOURS;_GDIPP_EXE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <ConformanceMode>Default</ConformanceMode>\r\n      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>\r\n    </ClCompile>\r\n    <Link>\r\n      <SubSystem>Windows</SubSystem>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n    </Link>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\r\n    <ClCompile>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <FunctionLevelLinking>true</FunctionLevelLinking>\r\n      <IntrinsicFunctions>true</IntrinsicFunctions>\r\n      <SDLCheck>true</SDLCheck>\r\n      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;USE_DETOURS;_GDIPP_EXE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <ConformanceMode>Default</ConformanceMode>\r\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\r\n    </ClCompile>\r\n    <Link>\r\n      <SubSystem>Windows</SubSystem>\r\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\r\n      <OptimizeReferences>true</OptimizeReferences>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n    </Link>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\r\n    <ClCompile>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <SDLCheck>true</SDLCheck>\r\n      <PreprocessorDefinitions>_DEBUG;_WINDOWS;USE_DETOURS;_GDIPP_EXE;_WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <ConformanceMode>Default</ConformanceMode>\r\n    </ClCompile>\r\n    <Link>\r\n      <SubSystem>Windows</SubSystem>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n    </Link>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\r\n    <ClCompile>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <FunctionLevelLinking>true</FunctionLevelLinking>\r\n      <IntrinsicFunctions>true</IntrinsicFunctions>\r\n      <SDLCheck>true</SDLCheck>\r\n      <PreprocessorDefinitions>NDEBUG;_WINDOWS;USE_DETOURS;_GDIPP_EXE;_WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <ConformanceMode>Default</ConformanceMode>\r\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\r\n    </ClCompile>\r\n    <Link>\r\n      <SubSystem>Windows</SubSystem>\r\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\r\n      <OptimizeReferences>true</OptimizeReferences>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n    </Link>\r\n  </ItemDefinitionGroup>\r\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\r\n  <ImportGroup Label=\"ExtensionTargets\">\r\n  </ImportGroup>\r\n</Project>"
        },
        {
          "name": "makelib.cmd",
          "type": "blob",
          "size": 0.158203125,
          "content": "@echo off\ncl /c /MD /GA /GF /Gy /O2 /arch:SSE optimize/memcpy__amd.cpp optimize/memcpy_amd.c\nlib /machine:ix86 /out:memcpy_amd.lib memcpy__amd.obj memcpy_amd.obj\n"
        },
        {
          "name": "misc.cpp",
          "type": "blob",
          "size": 7.4462890625,
          "content": "#include \"common.h\"\n#include \"settings.h\"\nCRITICAL_SECTION CCriticalSectionLock::m_cs[20];\nOWNED_CRITIAL_SECTION COwnedCriticalSectionLock::m_cs[2];\nLONG CThreadCounter::interlock;\t//snowie!! C++还需要额外申明，汗\nTCHAR CGdippSettings::m_szexeName[MAX_PATH+1] = {0};\n\n#ifdef _UNICODE\n#undef CharPrev\n#define CharPrev(s, c)\t((c) - 1)\n#endif\n\n//手抜きのパス操作関数群\nBOOL WINAPI PathIsRelative(LPCTSTR pszPath)\n{\n\tif (!pszPath || !*pszPath) {\n\t\treturn FALSE;\n\t}\n\n\tconst TCHAR ch1 = pszPath[0];\n\tconst TCHAR ch2 = pszPath[1];\n\tif (ch1 == _T('\\\\') && ch2 == _T('\\\\')) {\n\t\t//UNC\n\t\treturn FALSE;\n\t}\n\tif (ch1 == _T('\\\\') || (ch1 && ch2 == _T(':'))) {\n\t\t//絶対パス\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nBOOL WINAPI PathRemoveFileSpec(LPTSTR pszPath)\n{\n\tif (!pszPath) {\n\t\treturn FALSE;\n\t}\n\tLPTSTR p = pszPath + _tcslen(pszPath);\n\n\twhile (p >= pszPath) {\n\t\tswitch (*p) {\n\t\tcase _T('\\\\'):\n\t\tcase _T('/'):\n\t\t\tif (p > pszPath) {\n\t\t\t\t//c:\\aaa -> c:\\   <\n\t\t\t\t//c:\\    -> c:\\   <\n\t\t\t\tswitch (*(p - 1)) {\n\t\t\t\tcase _T('\\\\'):\n\t\t\t\tcase _T('/'):\n\t\t\t\tcase _T(':'):\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tgoto END;\n\t\t\t\t}\n\t\t\t}\n\t\tcase _T(':'):\n\t\t\t// c:aaa -> c:\n\t\t\tp++;\n\t\t\tgoto END;\n\t\t}\n\t\tif (p <= pszPath) {\n\t\t\tbreak;\n\t\t}\n\t\tp = CharPrev(NULL, p);\n\t}\n\nEND:\n\tif (*p) {\n\t\t*p = _T('\\0');\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nLPTSTR WINAPI PathFindExtension(LPCTSTR pszPath)\n{\n\tif (!pszPath) {\n\t\treturn NULL;\n\t}\n\n\tLPCTSTR p, pszEnd;\n\tp = pszEnd = pszPath + _tcslen(pszPath);\n\n\twhile (p > pszPath) {\n\t\tswitch (*p) {\n\t\tcase _T('.'):\n\t\t\treturn (LPTSTR)p;\n\t\tcase _T('\\\\'):\n\t\tcase _T('/'):\n\t\tcase _T(':'):\n\t\t\treturn (LPTSTR)pszEnd;\n\t\t}\n\t\tp = CharPrev(pszPath, p);\n\t}\n\treturn (LPTSTR)pszEnd;\n}\n\nLPTSTR WINAPI PathAddBackslash(LPTSTR pszPath)\n{\n\tif (!pszPath) {\n\t\treturn NULL;\n\t}\n\n\tint cch = _tcslen(pszPath);\n\tif (cch + 1 >= MAX_PATH) {\n\t\treturn NULL;\n\t}\n\n\tLPTSTR p = pszPath + cch;\n\tswitch (*CharPrev(pszPath, p)) {\n\tcase _T('\\\\'):\n\tcase _T('/'):\n\t\tbreak;\n\tdefault:\n\t\tp[0] = _T('\\\\');\n\t\tp[1] = _T('\\0');\n\t\tbreak;\n\t}\n\treturn pszPath;\n}\n\nLPTSTR WINAPI PathCombine(LPTSTR pszDest, LPCTSTR pszDir, LPCTSTR pszFile)\n{\n\tif (!pszDest || !pszDir || !pszFile) {\n\t\treturn NULL;\n\t}\n\n\t//かなり手抜き\n\tTCHAR szCurDir[MAX_PATH], szDir[MAX_PATH+1];\n\tGetCurrentDirectory(MAX_PATH, szCurDir);\n\t_tcsncpy(szDir, pszDir, MAX_PATH - 1);\n\tszDir[MAX_PATH - 1] = _T('\\0');\n\tPathAddBackslash(szDir);\n\tif (!SetCurrentDirectory(szDir)) {\n\t\t*pszDest = _T('\\0');\n\t\treturn NULL;\n\t}\n\tTCHAR szFile[MAX_PATH];\n\t_tcsncpy(szFile, pszFile, MAX_PATH - 1);\n\tszFile[MAX_PATH - 1] = _T('\\0');\n\tGetFullPathName(szFile, MAX_PATH, pszDest, NULL);\n\tSetCurrentDirectory(szCurDir);\nTRACE(_T(\"PathCombine: %s\\n\"), pszDest);\n\treturn pszDest;\n}\n\nLPWSTR _StrDupExAtoW(LPCSTR pszMB, int cchMB /*= -1*/, LPWSTR pszStack /*= NULL*/, int cchStack /*= 0*/, int* pcchWC /*= NULL*/, int nACP)\n{\n\tint _cchWC;\n\tif (!pcchWC) {\n\t\tpcchWC = &_cchWC;\n\t}\n\t*pcchWC = 0;\n\n\tif (!pszMB) {\n\t\treturn NULL;\n\t}\n\tif (cchMB == -1) {\n\t\tcchMB = strlen(pszMB);\n\t}\n\tconst int cchWC = MultiByteToWideChar(nACP, 0, pszMB, cchMB, NULL, 0);\n\tif(cchWC < 0) {\n\t\treturn NULL;\n\t}\n\n\tLPWSTR pszWC;\n\tif(cchWC < cchStack && pszStack) {\n\t\tpszWC = pszStack;\n\t\tZeroMemory(pszWC, sizeof(WCHAR) * (cchWC + 1));\n\t} else {\n\t\tpszWC = (LPWSTR)calloc(sizeof(WCHAR), cchWC + 1);\n\t\tif (!pszWC) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tMultiByteToWideChar(nACP, 0, pszMB, cchMB, pszWC, cchWC);\n\tpszWC[cchWC] = L'\\0';\n\t*pcchWC = cchWC;\n\treturn pszWC;\n}\n\n#ifdef _DEBUG\ntypedef struct {\n\tLPCSTR\t\tname;\n\tUINT\t\tflag;\n\tUINT\t\tmask;\n\tUINT\t\txor;\n} FLAG_NAME_MAP;\n#define DEF_FLAG_NAME(f,m,x)\t{ #f, f, m, x }\n#define END_FLAG()\t\t\t\t{ NULL }\n\nLPCSTR Dbg_GetFlagNames(UINT flags, const FLAG_NAME_MAP* p, LPSTR worker)\n{\n\tif (!worker)\n\t\treturn \"\";\n\tif (!flags || !p)\n\t\treturn \"0\";\n\n\tLPSTR wk = worker;\n\t*wk = '\\0';\n\twhile (p->name) {\n\t\tif (((flags & p->mask) ^ p->xor) == p->flag) {\n\t\t\tif (wk != worker) {\n\t\t\t\tmemcpy(wk, \" | \", 4);\n\t\t\t\twk += 3;\n\t\t\t}\n\t\t\tstrcpy(wk, p->name);\n\t\t\twk += strlen(p->name);\n\t\t\tflags &= ~p->mask;\n\t\t}\n\t\tp++;\n\t}\n\tif (flags) {\n\t\tif (wk != worker) {\n\t\t\tmemcpy(wk, \" | \", 4);\n\t\t\twk += 3;\n\t\t}\n\t\tsprintf(wk, \"%04X\", flags);\n\t}\n\treturn *worker ? worker : \"0\";\n}\n\nvoid Dbg_TraceExtTextOutW(int nXStart, int nYStart, UINT fuOptions, LPCWSTR lpString, int cbString, const int* lpDx)\n{\n\tLPWSTR p;\n\tif (fuOptions & ETO_GLYPH_INDEX) {\n\t\tp = (LPWSTR)_alloca((cbString * 5 + 1) * sizeof(WCHAR));\n\t\tLPWSTR q = p;\n\t\tfor (int i = 0; i < cbString; ++i) {\n\t\t\tq += wsprintf(q, _T(\" %04X\"), lpString[i]);\n\t\t}\n\t} else {\n\t\tp = (LPWSTR)_alloca((cbString + 1) * sizeof(WCHAR));\n\t\tmemcpy(p, lpString, cbString * sizeof(WCHAR));\n\t\tp[cbString] = 0;\n\t}\n\n\tstatic const FLAG_NAME_MAP c_map[] = {\n\t\tDEF_FLAG_NAME(ETO_OPAQUE, ETO_OPAQUE, 0),\n\t\tDEF_FLAG_NAME(ETO_CLIPPED, ETO_CLIPPED, 0),\n\t\tDEF_FLAG_NAME(ETO_GLYPH_INDEX, ETO_GLYPH_INDEX, 0),\n\t\tDEF_FLAG_NAME(ETO_RTLREADING, ETO_RTLREADING, 0),\n\t\tDEF_FLAG_NAME(ETO_NUMERICSLOCAL, ETO_NUMERICSLOCAL, 0),\n\t\tDEF_FLAG_NAME(ETO_NUMERICSLATIN, ETO_NUMERICSLATIN, 0),\n\t\tDEF_FLAG_NAME(ETO_IGNORELANGUAGE, ETO_IGNORELANGUAGE, 0),\n\t\tDEF_FLAG_NAME(ETO_PDY, ETO_PDY, 0),\n\t\tEND_FLAG(),\n\t};\n\tCHAR wk[1024];\n\tTRACE(_T(\"ExtTextOutW(%d, %d, %hs, \\\"%ls\\\", %d, %hs)\\n\")\n\t\t\t, nXStart, nYStart, Dbg_GetFlagNames(fuOptions, c_map, wk), p, cbString, lpDx ? \"{...}\" : \"NULL\");\n}\n\nvoid Dbg_TraceScriptItemize(const WCHAR* pwcInChars, int cInChars)\n{\n\tLPWSTR p = (LPWSTR)_alloca((cInChars + 1) * sizeof(WCHAR));\n\tmemcpy(p, pwcInChars, cInChars * sizeof(WCHAR));\n\tp[cInChars] = 0;\n\n\tTRACE(_T(\"ScriptItemize(\\\"%ls\\\", %d)\\n\"), p, cInChars);\n}\n\nvoid Dbg_TraceScriptShape(const WCHAR* pwcChars, int cChars, const SCRIPT_ANALYSIS* psa, const WORD* pwOutGlyphs, int cGlyphs)\n{\n\tLPWSTR pc = (LPWSTR)_alloca((cChars + 1) * sizeof(WCHAR));\n\tmemcpy(pc, pwcChars, cChars * sizeof(WCHAR));\n\tpc[cChars] = 0;\n\tLPWSTR pg;\n\tif (pwOutGlyphs) {\n\t\tif (psa->fNoGlyphIndex) {\n\t\t\tpg = (LPWSTR)_alloca((cGlyphs + 1) * sizeof(WCHAR));\n\t\t\tmemcpy(pg, pwOutGlyphs, cGlyphs * sizeof(WCHAR));\n\t\t\tpg[cGlyphs] = 0;\n\t\t} else {\n\t\t\tpg = (LPWSTR)_alloca((cGlyphs * 5 + 1) * sizeof(WCHAR));\n\t\t\tLPWSTR q = pg;\n\t\t\tfor (int i = 0; i < cGlyphs; ++i) {\n\t\t\t\tq += wsprintf(q, _T(\" %04X\"), pwOutGlyphs[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tTRACE(_T(\"ScriptShape(\\\"%ls\\\", %d, Script=%d%S%S%S%S%S%S, BidiLevel=%d%S%S%S%S%S%S%S%S\"), \n\t\tpc, cChars,\n\t\tpsa->eScript, psa->fRTL ? \", RTL\" : \"\", psa->fLayoutRTL ? \", LayoutRTL\" : \"\", \n\t\tpsa->fLinkBefore ? \", LinkBefore\" : \"\", psa->fLinkAfter ? \", LinkAfter\" : \"\", \n\t\tpsa->fLogicalOrder ? \", LogicalOrder\" : \"\", psa->fNoGlyphIndex ? \", NoGlyphIndex\" : \"\", \n\t\tpsa->s.uBidiLevel, psa->s.fOverrideDirection ? \", OverrideDirection\" : \"\", \n\t\tpsa->s.fInhibitSymSwap ? \", InhibitSymSwap\" : \"\", psa->s.fCharShape ? \", CharShape\" : \"\", \n\t\tpsa->s.fDigitSubstitute ? \", DigitSubstitute\" : \"\", psa->s.fInhibitLigate ? \", InhibitLigate\" : \"\", \n\t\tpsa->s.fDisplayZWG ? \", DisplayZWG\" : \"\", psa->s.fArabicNumContext ? \", ArabicNumContext\" : \"\", \n\t\tpsa->s.fGcpClusters ? \", GcpClusters\" : \"\"\n\t);\n\n\tif (pwOutGlyphs) {\n\t\tTRACE(_T(\", \\\"%ls\\\", %d\"), pg, cGlyphs);\n\t}\n\n\tTRACE(_T(\")\\n\"));\n}\n\nvoid Dbg_TractGetTextExtent(LPCSTR lpString, int cbString, LPSIZE lpSize)\n{\n\tLPSTR p = (LPSTR)_alloca((cbString + 1) * sizeof(CHAR));\n\tmemcpy(p, lpString, cbString * sizeof(CHAR));\n\tp[cbString] = 0;\n\tTRACE(_T(\"GetTextExtentA(\\\"%hs\\\", %d) = { %d, %d }\\n\")\n\t\t\t, p, cbString, lpSize->cx, lpSize->cy);\n}\n\nvoid Dbg_TractGetTextExtent(LPCWSTR lpString, int cbString, LPSIZE lpSize)\n{\n\tLPWSTR p = (LPWSTR)_alloca((cbString + 1) * sizeof(WCHAR));\n\tmemcpy(p, lpString, cbString * sizeof(WCHAR));\n\tp[cbString] = 0;\n\tTRACE(_T(\"GetTextExtentW(\\\"%ls\\\", %d) = { %d, %d }\\n\")\n\t\t\t, p, cbString, lpSize->cx, lpSize->cy);\n}\n#endif\n"
        },
        {
          "name": "optimize",
          "type": "tree",
          "content": null
        },
        {
          "name": "override.cpp",
          "type": "blob",
          "size": 53.0234375,
          "content": "// override.cpp - キレイなTextOut\r\n// 2006/09/27\r\n\r\n#include \"override.h\"\r\n#include \"ft.h\"\r\n#include \"fteng.h\"\r\n#include \"supinfo.h\"\r\n#include \"undocAPI.h\"\r\n//#include \"lrucache.hpp\"\r\n\r\n#include <malloc.h>\t\t// _alloca\r\n#include <mbctype.h>\t// _getmbcp\r\n\r\n#pragma comment(lib, \"Gdi32.lib\")\r\n#pragma comment(lib, \"User32.lib\")\r\n#pragma comment(lib, \"WindowsCodecs.lib\")\r\n#pragma comment (lib, \"dwrite.lib\")\r\n\r\n#if defined(_DEBUG)\r\nvoid Dbg_TractGetTextExtent(LPCSTR lpString, int cbString, LPSIZE lpSize);\r\nvoid Dbg_TractGetTextExtent(LPCWSTR lpString, int cbString, LPSIZE lpSize);\r\nvoid Dbg_TraceExtTextOutW(int nXStart, int nYStart, UINT fuOptions, LPCWSTR lpString, int cbString, const int* lpDx);\r\nvoid Dbg_TraceScriptItemize(const WCHAR* pwcInChars, int cInChars);\r\nvoid Dbg_TraceScriptShape(const WCHAR* pwcChars, int cChars, const SCRIPT_ANALYSIS* psa, const WORD* pwOutGlyphs, int cGlyphs);\r\n#else\r\n#define Dbg_TraceExtTextOutW(x,y,f,s,c,p)\r\n#define Dbg_TractGetTextExtent(s,c,p)\r\n#define Dbg_TraceScriptItemize(s,c)\r\n#define Dbg_TraceScriptShape(s,c,p,g,o)\r\n#endif\r\n#define CCH_MAX_STACK\t256\r\n\r\ntypedef HRESULT (WINAPI * __D2D1CreateFactory)(\r\n\t\t\t\t\t\t\t\t\t\tD2D1_FACTORY_TYPE factoryType,\r\n\t\t\t\t\t\t\t\t\t\tREFIID riid,\r\n\t\t\t\t\t\t\t\t\t\tconst D2D1_FACTORY_OPTIONS *pFactoryOptions,\r\n\t\t\t\t\t\t\t\t\t\tvoid **ppIFactory);\r\ntypedef HRESULT (WINAPI* __DWriteCreateFactory)(\r\n\t\t\t\t\t\t\t\t\t\t__in DWRITE_FACTORY_TYPE factoryType,\r\n\t\t\t\t\t\t\t\t\t\t__in REFIID iid,\r\n\t\t\t\t\t\t\t\t\t\t__out IUnknown **factory\r\n\t\t\t\t\t\t\t\t\t\t);\r\n\r\n\r\nCFontCache FontCache;\r\nCDCArray DCArray;\r\nwstring nullstring;\r\nBOOL g_ccbRender = true;\r\nBOOL g_ccbCache = true;\r\nHFONT g_alterGUIFont = NULL;\r\nHFONT g_alterSysFont = NULL;\r\n\r\n//BOOL FreeTypeGetTextExtentPoint(HDC hdc, LPCSTR lpString, int cbString, LPSIZE lpSize, const FREETYPE_PARAMS* params);\r\n\r\nHFONT GetCurrentFont(HDC hdc)\r\n{\r\n\tHFONT hCurFont = (HFONT)GetCurrentObject(hdc, OBJ_FONT);\r\n\tif (!hCurFont) {\r\n\t\t// NULLの場合はSystemを設定しておく\r\n\t\thCurFont = (HFONT)GetStockObject(SYSTEM_FONT);\r\n\t}\r\n\treturn hCurFont;\r\n}\r\n\r\n//判断是否是有效普通显示DC，用于跳过字幕\r\nBOOL IsValidDC(HDC hdc)\t\r\n{\r\n\tif (GetDeviceCaps(hdc, TECHNOLOGY) != DT_RASDISPLAY) {\r\n\t\treturn FALSE;\r\n\t}\r\n\treturn TRUE;\r\n\r\n}\r\n\r\nBOOL IsProcessExcluded()\r\n{\r\n//\tif (GetModuleHandle(NULL) == GetModuleHandle(_T(\"gdi++.exe\"))) {\r\n//\t\treturn TRUE;\r\n//\t}\r\n\r\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstanceNoInit();\r\n\tif (pSettings->IsInclude()) {\r\n\t\tif (pSettings->IsProcessIncluded()) {\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n\tif (pSettings->IsProcessExcluded()) {\r\n\t\treturn TRUE;\r\n\t}\r\n\treturn FALSE;\r\n}\r\n\r\nBOOL IsProcessUnload()\r\n{\r\n//\tif (GetModuleHandle(NULL) == GetModuleHandle(_T(\"gdi++.exe\"))) {\r\n//\t\treturn TRUE;\r\n//\t}\r\n\r\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstanceNoInit();\r\n\tif (pSettings->IsInclude()) {\r\n\t\tif (pSettings->IsProcessIncluded()) {\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n\tif (pSettings->IsProcessUnload()) {\r\n\t\treturn TRUE;\r\n\t}\r\n\treturn FALSE;\r\n}\r\n\r\nBOOL IsExeUnload(LPCTSTR lpApp)\r\n{\r\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstanceNoInit();\r\n\tif (pSettings->IsInclude()) {\r\n\t\tif (pSettings->IsExeInclude(lpApp)) {\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n\tif (pSettings->IsExeUnload(lpApp)) {\r\n\t\treturn TRUE;\r\n\t}\r\n\treturn FALSE;\r\n}\r\n\r\n//切り上げ除算\r\nint div_ceil(int a, int b)\r\n{\r\n\tif(a % b)\r\n\t\treturn (a>0)? (a/b+1): (a/b-1);\r\n\treturn a / b;\r\n}\r\n\r\ntemplate <typename _TCHAR>\t//修改这个函数，使它在失败的时候返回false，由调用者负责调用Windows原函数，实现线程安全。\r\nBOOL _GetTextExtentPoint32AorW(HDC hdc, _TCHAR* lpString, int cbString, LPSIZE lpSize)\r\n{\r\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\tif (pSettings->WidthMode() == SETTING_WIDTHMODE_GDI32\r\n\t\t|| !IsValidDC(hdc) || !lpString || cbString <= 0) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tFREETYPE_PARAMS params(0, hdc);\r\n\r\n\tif(FreeTypeGetTextExtentPoint(hdc, lpString, cbString, lpSize, &params)) {\r\n\t\tDbg_TractGetTextExtent(lpString, cbString, lpSize);\r\n\t\treturn TRUE;\r\n\t}\r\n\telse\r\n\t\treturn false;\r\n}\r\n\r\n//firefox\r\n/*\r\nBOOL WINAPI IMPL_GetTextExtentPoint32A(HDC hdc, LPCSTR lpString, int cbString, LPSIZE lpSize)\r\n{\r\n\t//CThreadCounter __counter;\r\n\t//CCriticalSectionLock __lock;\r\n\treturn _GetTextExtentPoint32AorW(hdc, lpString, cbString, lpSize) || ORIG_GetTextExtentPoint32A(hdc, lpString, cbString, lpSize);\r\n}\r\n\r\nBOOL WINAPI IMPL_GetTextExtentPoint32W(HDC hdc, LPCWSTR lpString, int cbString, LPSIZE lpSize)\r\n{\r\n\t//CThreadCounter __counter;\r\n\t//CCriticalSectionLock __lock;\r\n\treturn _GetTextExtentPoint32AorW(hdc, lpString, cbString, lpSize) || ORIG_GetTextExtentPoint32W(hdc, lpString, cbString, lpSize);\r\n}\r\n\r\nBOOL WINAPI IMPL_GetTextExtentPointA(HDC hdc, LPCSTR lpString, int cbString, LPSIZE lpSize)\r\n{\r\n\t//CThreadCounter __counter;\r\n\t//CCriticalSectionLock __lock;\r\n\treturn _GetTextExtentPoint32AorW(hdc, lpString, cbString, lpSize) || ORIG_GetTextExtentPoint32A(hdc, lpString, cbString, lpSize);\r\n}\r\n\r\nBOOL WINAPI IMPL_GetTextExtentPointW(HDC hdc, LPCWSTR lpString, int cbString, LPSIZE lpSize)\r\n{\r\n\t//CThreadCounter __counter;\r\n\t//CCriticalSectionLock __lock;\r\n\treturn _GetTextExtentPoint32AorW(hdc, lpString, cbString, lpSize) || ORIG_GetTextExtentPoint32W(hdc, lpString, cbString, lpSize);\r\n}\r\n\r\nBOOL WINAPI IMPL_GetCharWidthW(HDC hdc, UINT iFirstChar, UINT iLastChar, LPINT lpBuffer)\r\n{\r\n\t//CThreadCounter __counter;\r\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\tif (pSettings->WidthMode() == SETTING_WIDTHMODE_GDI32\r\n\t\t|| !IsValidDC(hdc) || !lpBuffer || !FreeTypeGetCharWidth(hdc, iFirstChar, iLastChar, lpBuffer)) {\r\n\t\treturn ORIG_GetCharWidthW(hdc, iFirstChar, iLastChar, lpBuffer);\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nBOOL WINAPI IMPL_GetCharWidth32W(HDC hdc, UINT iFirstChar, UINT iLastChar, LPINT lpBuffer)\r\n{\r\n\t//CThreadCounter __counter;\r\n\tTRACE(_T(\"GetCharWidth32W(%u, %u, {...})\\n\"), iFirstChar, iLastChar);\r\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\tif (pSettings->WidthMode() == SETTING_WIDTHMODE_GDI32\r\n\t\t|| !IsValidDC(hdc) || !lpBuffer || !FreeTypeGetCharWidth(hdc, iFirstChar, iLastChar, lpBuffer)) {\r\n\t\treturn ORIG_GetCharWidth32W(hdc, iFirstChar, iLastChar, lpBuffer);\r\n\t}\r\n\treturn TRUE;\r\n}*/\r\n/*\r\nextern PFNLdrGetProcedureAddress LdrGetProcedureAddress;\r\nint MyGetProcAddress(HMODULE dll, LPSTR funcname)\r\n{\r\n\tANSI_STRING dumy;\r\n\tdumy.Length = strlen(funcname);\r\n\tdumy.MaximumLength = strlen(funcname);\r\n\tdumy.Buffer = funcname;\r\n\tint nRet;\r\n\tLdrGetProcedureAddress(dll,&dumy,0,(void**)&nRet);\r\n\treturn nRet;\r\n}*/\r\n\r\n\r\n/*\r\nLONG WINAPI IMPL_LdrLoadDll(IN PWCHAR PathToFile OPTIONAL, IN ULONG Flags OPTIONAL, IN UNICODE_STRING2* ModuleFileName, OUT HANDLE* ModuleHandle)\r\n{\r\n\tstatic bool bFisrtTimeHook = GetModuleHandle(_T(\"d2d1.dll\"))!=0;\r\n\tif (!bD2D1Loaded)\r\n\t{\r\n\t\twstring filename = wstring(ModuleFileName->Buffer);\r\n\t\tint last_slash=filename.find_last_of('\\\\');\r\n\t\tif (last_slash!=-1)\r\n\t\t\tfilename.erase(0,last_slash+1);\t//删除路径\r\n\t\tif (_wcsicmp(filename.c_str(), L\"d2d1.dll\")==0)\t//正在载入d2d1.dll\r\n\t\t{\r\n\t\t\tbD2D1Loaded = true;\r\n\t\t\tLONG result = ORIG_LdrLoadDll(PathToFile, Flags, ModuleFileName, ModuleHandle);\r\n\t\t\tHookD2D1((HMODULE)*ModuleHandle);\r\n\t\t\treturn result;\r\n\t\t}\r\n\t\tif (bFisrtTimeHook)\r\n\t\t{\r\n\t\t\tbFisrtTimeHook = false;\r\n\t\t\tbD2D1Loaded = true;\r\n\t\t\tHookD2D1(GetModuleHandle(_T(\"d2d1.dll\")));\r\n\t\t}\r\n\t}\r\n\treturn ORIG_LdrLoadDll(PathToFile, Flags, ModuleFileName, ModuleHandle);\r\n}*/\r\n\r\n\r\n/*\r\nBOOL WINAPI IMPL_CreateProcessInternalW( HANDLE hToken, LPCTSTR lpApplicationName, LPTSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, \\\r\n\t\t\t\t\t\t\t\t\t\tDWORD dwCreationFlags, LPVOID lpEnvironment, LPCTSTR lpCurrentDirectory, LPSTARTUPINFO lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation , PHANDLE hNewToken)\r\n{\r\n\t//CThreadCounter __counter;\r\n\tCCriticalSectionLock __lock;\r\n\treturn _CreateProcessInternalW(hToken, lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation, hNewToken, ORIG_CreateProcessInternalW);\r\n}*/\r\n\r\n/*\r\nBOOL WINAPI IMPL_nCreateProcessA(LPCSTR lpApp, LPSTR lpCmd, LPSECURITY_ATTRIBUTES pa, LPSECURITY_ATTRIBUTES ta, BOOL bInherit, DWORD dwFlags, LPVOID lpEnv, LPCSTR lpDir, LPSTARTUPINFOA psi, LPPROCESS_INFORMATION ppi)\r\n{\r\n\t//CThreadCounter __counter;\r\n\tCCriticalSectionLock __lock;\r\n\tTRACE(_T(\"CreateProcessA(\\\"%hs\\\", \\\"%hs\\\", ...)\\n\"), lpApp, lpCmd);\r\n\treturn _CreateProcessAorW(lpApp, lpCmd, pa, ta, bInherit, dwFlags, lpEnv, lpDir, psi, ppi, ORIG_nCreateProcessA);\r\n}\r\n\r\nBOOL WINAPI IMPL_nCreateProcessW(LPCWSTR lpApp, LPWSTR lpCmd, LPSECURITY_ATTRIBUTES pa, LPSECURITY_ATTRIBUTES ta, BOOL bInherit, DWORD dwFlags, LPVOID lpEnv, LPCWSTR lpDir, LPSTARTUPINFOW psi, LPPROCESS_INFORMATION ppi)\r\n{\r\n\t//CThreadCounter __counter;\r\n\tCCriticalSectionLock __lock;\r\n\tTRACE(_T(\"CreateProcessW(\\\"%ls\\\", \\\"%ls\\\", ...)\\n\"), lpApp, lpCmd);\r\n\treturn _CreateProcessAorW(lpApp, lpCmd, pa, ta, bInherit, dwFlags, lpEnv, lpDir, psi, ppi, ORIG_nCreateProcessW);\r\n}\r\n\r\n\r\nBOOL WINAPI IMPL_CreateProcessAsUserA(HANDLE hToken, LPCSTR lpApp, LPSTR lpCmd, LPSECURITY_ATTRIBUTES pa, LPSECURITY_ATTRIBUTES ta, BOOL bInherit, DWORD dwFlags, LPVOID lpEnv, LPCSTR lpDir, LPSTARTUPINFOA psi, LPPROCESS_INFORMATION ppi)\r\n{\r\n\t//CThreadCounter __counter;\r\n\tCCriticalSectionLock __lock;\r\n\tTRACE(_T(\"CreateProcessA(\\\"%hs\\\", \\\"%hs\\\", ...)\\n\"), lpApp, lpCmd);\r\n\treturn _CreateProcessAsUserAorW(hToken, lpApp, lpCmd, pa, ta, bInherit, dwFlags, lpEnv, lpDir, psi, ppi, ORIG_CreateProcessAsUserA);\r\n}\r\n\r\nBOOL WINAPI IMPL_CreateProcessAsUserW(HANDLE hToken, LPCWSTR lpApp, LPWSTR lpCmd, LPSECURITY_ATTRIBUTES pa, LPSECURITY_ATTRIBUTES ta, BOOL bInherit, DWORD dwFlags, LPVOID lpEnv, LPCWSTR lpDir, LPSTARTUPINFOW psi, LPPROCESS_INFORMATION ppi)\r\n{\r\n\t//CThreadCounter __counter;\r\n\tCCriticalSectionLock __lock;\r\n\tTRACE(_T(\"CreateProcessW(\\\"%ls\\\", \\\"%ls\\\", ...)\\n\"), lpApp, lpCmd);\r\n\treturn _CreateProcessAsUserAorW(hToken, lpApp, lpCmd, pa, ta, bInherit, dwFlags, lpEnv, lpDir, psi, ppi, ORIG_CreateProcessAsUserW);\r\n}*/\r\n\r\n/*\r\nHOOK_DEFINE(user32.dll, DWORD, GetTabbedTextExtentA, (HDC hdc, LPCSTR lpString, int nCount, int nTabPositions, CONST LPINT lpnTabStopPositions), (hdc, lpString, nCount, nTabPositions, lpnTabStopPositions))\r\nHOOK_DEFINE(user32.dll, DWORD, GetTabbedTextExtentW, (HDC hdc, LPCWSTR lpString, int nCount, int nTabPositions, CONST LPINT lpnTabStopPositions), (hdc, lpString, nCount, nTabPositions, lpnTabStopPositions))\r\nHOOK_DEFINE(gdi32.dll, BOOL, GetTextExtentExPointA, (HDC hdc, LPCSTR lpszStr, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpDx, LPSIZE lpSize), (hdc, lpszStr, cchString, nMaxExtent, lpnFit, lpDx, lpSize))\r\nHOOK_DEFINE(gdi32.dll, BOOL, GetTextExtentExPointW, (HDC hdc, LPCWSTR lpszStr, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpDx, LPSIZE lpSize), (hdc, lpszStr, cchString, nMaxExtent, lpnFit, lpDx, lpSize))\r\nHOOK_DEFINE(gdi32.dll, BOOL, GetTextExtentExPointI, (HDC hdc, LPWORD pgiIn, int cgi, int nMaxExtent, LPINT lpnFit, LPINT lpDx, LPSIZE lpSize), (hdc, pgiIn, cgi, nMaxExtent, lpnFit, lpDx, lpSize))\r\nHOOK_DEFINE(gdi32.dll, BOOL, GetTextExtentPointA, (HDC hdc, LPCSTR lpString, int cbString, LPSIZE lpSize), (hdc, lpString, cbString, lpSize))\r\nHOOK_DEFINE(gdi32.dll, BOOL, GetTextExtentPointW, (HDC hdc, LPCWSTR lpString, int cbString, LPSIZE lpSize), (hdc, lpString, cbString, lpSize))\r\nHOOK_DEFINE(gdi32.dll, BOOL, GetTextExtentPointI, (HDC hdc, LPWORD pgiIn, int cgi, LPSIZE lpSize), (hdc, pgiIn, cgi, lpSize))\r\n*/\r\n\r\n\r\n/*\r\nHFONT WINAPI IMPL_CreateFontA(int nHeight, int nWidth, int nEscapement, int nOrientation, int fnWeight, DWORD fdwItalic, DWORD fdwUnderline, DWORD fdwStrikeOut, DWORD fdwCharSet, DWORD fdwOutputPrecision, DWORD fdwClipPrecision, DWORD fdwQuality, DWORD fdwPitchAndFamily, LPCSTR  lpszFace)\r\n{\r\n\tLOGFONTA lf = {\r\n\t\tnHeight,\r\n\t\tnWidth,\r\n\t\tnEscapement,\r\n\t\tnOrientation,\r\n\t\tfnWeight,\r\n\t\t!!fdwItalic,\r\n\t\t!!fdwUnderline,\r\n\t\t!!fdwStrikeOut,\r\n\t\t(BYTE)fdwCharSet,\r\n\t\t(BYTE)fdwOutputPrecision,\r\n\t\t(BYTE)fdwClipPrecision,\r\n\t\t(BYTE)fdwQuality,\r\n\t\t(BYTE)fdwPitchAndFamily,\r\n\t};\r\n\tif (lpszFace)\r\n\t\tstrncpy(lf.lfFaceName, lpszFace, LF_FACESIZE - 1);\r\n\treturn IMPL_CreateFontIndirectA(&lf);\r\n}\r\n\r\nHFONT WINAPI IMPL_CreateFontW(int nHeight, int nWidth, int nEscapement, int nOrientation, int fnWeight, DWORD fdwItalic, DWORD fdwUnderline, DWORD fdwStrikeOut, DWORD fdwCharSet, DWORD fdwOutputPrecision, DWORD fdwClipPrecision, DWORD fdwQuality, DWORD fdwPitchAndFamily, LPCWSTR lpszFace)\r\n{\r\n\tLOGFONTW lf = {\r\n\t\tnHeight,\r\n\t\tnWidth,\r\n\t\tnEscapement,\r\n\t\tnOrientation,\r\n\t\tfnWeight,\r\n\t\t!!fdwItalic,\r\n\t\t!!fdwUnderline,\r\n\t\t!!fdwStrikeOut,\r\n\t\t(BYTE)fdwCharSet,\r\n\t\t(BYTE)fdwOutputPrecision,\r\n\t\t(BYTE)fdwClipPrecision,\r\n\t\t(BYTE)fdwQuality,\r\n\t\t(BYTE)fdwPitchAndFamily,\r\n\t};\r\n\tif (lpszFace)\r\n\t\twcsncpy(lf.lfFaceName, lpszFace, LF_FACESIZE - 1);\r\n\treturn IMPL_CreateFontIndirectW(&lf);\r\n}\r\n\r\nHFONT WINAPI IMPL_CreateFontIndirectA(CONST LOGFONTA *lplfA)\r\n{\r\n\tif(!lplfA) {\r\n\t\tSetLastError(ERROR_INVALID_PARAMETER);\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\tif (pSettings->IsFontExcluded(lplfA->lfFaceName)) {\r\n\t\treturn ORIG_CreateFontIndirectA(lplfA);\r\n\t}\r\n\r\n\tLOGFONT lf = {\r\n\t\tlplfA->lfHeight,\r\n\t\tlplfA->lfWidth,\r\n\t\tlplfA->lfEscapement,\r\n\t\tlplfA->lfOrientation,\r\n\t\tlplfA->lfWeight,\r\n\t\tlplfA->lfItalic,\r\n\t\tlplfA->lfUnderline,\r\n\t\tlplfA->lfStrikeOut,\r\n\t\tlplfA->lfCharSet,\r\n\t\tlplfA->lfOutPrecision,\r\n\t\tlplfA->lfClipPrecision,\r\n\t\tlplfA->lfQuality,\r\n\t\tlplfA->lfPitchAndFamily,\r\n\t};\r\n\tMultiByteToWideChar(CP_ACP, 0, lplfA->lfFaceName, LF_FACESIZE, lf.lfFaceName, LF_FACESIZE);\r\n\r\n\tLOGFONT* lplf = &lf;\r\n\tif (pSettings->CopyForceFont(lf, lf)) {\r\n\t\tlplf = &lf;\r\n\t}\r\n\tHFONT hf = IMPL_CreateFontIndirectW(lplf);\r\n//\tif(hf && lplf && !pSettings->LoadOnDemand()) {\r\n//\t\tAddFontToFT(lplf->lfFaceName, lplf->lfWeight, !!lplf->lfItalic);\r\n//\t}\r\n\treturn hf;\r\n}\r\n*/\r\n\r\n//Snowie!!\r\nLPCWSTR GetCachedFont(HFONT lFont)\r\n{\r\n\tCFontCache::const_iterator it= FontCache.find(lFont);\r\n\tif (it==FontCache.end())\r\n\t\treturn NULL;\r\n\telse\r\n\t\treturn it->second->lpRealName;\r\n}\r\n\r\nLPCWSTR GetCachedFontLocale(HFONT lFont)\r\n{\r\n\tCFontCache::const_iterator it= FontCache.find(lFont);\r\n\tif (it==FontCache.end())\r\n\t\treturn NULL;\r\n\telse\r\n\t\treturn it->second->lpGDIName;\r\n}\r\n\r\nvoid AddToCachedFont(HFONT lfont, LPWSTR lpFaceName, LPWSTR lpGDIName)\r\n{\r\n\tif (!lfont) return;\t//不可以添加空节点\r\n\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_CACHEDFONT);\r\n\tif (GetCachedFont(lfont)) return;\t//已经存在的字体\r\n\tFontCache[lfont] = new CFontSubResult(lpFaceName, lpGDIName);\r\n}\r\n\r\nvoid DeleteCachedFont(HFONT lfont)\r\n{\r\n\tif (!lfont) return;\t//不可以删除头结点\r\n\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_CACHEDFONT);\r\n\tCFontCache::iterator it= FontCache.find(lfont);\r\n\tif (it!=FontCache.end())\r\n\t{\r\n\t\tdelete it->second;\r\n\t\tFontCache.erase(it);\r\n\t}\r\n}\r\n\r\nint WINAPI IMPL_GetTextFaceAliasW(HDC hdc, int nLen, LPWSTR lpAliasW)\r\n{\r\n\t//CThreadCounter __counter;\r\n\tint bResult = ORIG_GetTextFaceAliasW(hdc, nLen, lpAliasW);\r\n\t//LOGFONT lf, lf2;\r\n\t//StringCchCopy(lf.lfFaceName, LF_FACESIZE, lpAliasW);\r\n\t//LOGFONT * lplf = &lf;\r\n\tLPCWSTR fontcache=GetCachedFont(GetCurrentFont(hdc));\r\n\tif (fontcache){\r\n\t\tif (lpAliasW)\r\n\t\t\tStringCchCopy(lpAliasW, LF_FACESIZE, fontcache);\r\n\t\tbResult = wcslen(fontcache)+1;\r\n\t}\r\n\treturn bResult;\r\n}\r\n\r\n// Won't get any better for clipbox, obsolete.\r\n/*\r\ncache::lru_cache<HFONT, int> FontHeightCache(200);\t// cache 200 most frequently used fonts' height\r\nconst WCHAR TEST_ALPHABET_SEQUENCE[] = L\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n\r\nint GetFontMaxAlphabetHeight(HDC dc, MAT2 *lpmt2) {\r\n\tHFONT ft = GetCurrentFont(dc);\r\n\tif (FontHeightCache.exists(ft))\r\n\t\treturn FontHeightCache.get(ft);\r\n\tGLYPHMETRICS lppm = { 0 };\r\n\tint nHeight = 0;\r\n\tfor (int i = 0; i < 26; ++i) {\r\n\t\tORIG_GetGlyphOutlineW(dc, TEST_ALPHABET_SEQUENCE[i], GGO_METRICS, &lppm, 0, 0, lpmt2);\r\n\t\tif (lppm.gmptGlyphOrigin.y>nHeight)\r\n\t\t\tnHeight = lppm.gmptGlyphOrigin.y;\r\n\t}\r\n\tFontHeightCache.put(ft, nHeight);\r\n\treturn nHeight;\r\n}*/\r\n\r\nDWORD WINAPI IMPL_GetGlyphOutlineW(__in HDC hdc, __in UINT uChar, __in UINT fuFormat, __out LPGLYPHMETRICS lpgm, __in DWORD cjBuffer, __out_bcount_opt(cjBuffer) LPVOID pvBuffer, __in CONST MAT2 *lpmat2)\r\n{\r\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\tDWORD ret= ORIG_GetGlyphOutlineW(hdc, uChar, fuFormat, lpgm, cjBuffer, pvBuffer, lpmat2);\r\n\tif (pSettings->EnableClipBoxFix() && (!cjBuffer || !pvBuffer)) {\r\n\t\tif (!(fuFormat & (GGO_BITMAP | GGO_GRAY2_BITMAP | GGO_GRAY4_BITMAP | GGO_GRAY8_BITMAP | GGO_NATIVE))) {\r\n\t\t\t//lpgm->gmptGlyphOrigin.x -= 1;\r\n\t\t\t//lpgm->gmptGlyphOrigin.y += 1;\r\n\t\t\t//lpgm->gmBlackBoxX += 3;\r\n\t\t\t//lpgm->gmBlackBoxY += 2;\r\n\r\n\t\t\tstatic int n = (int)floor(1.5*pSettings->ScreenDpi() / 96);\r\n\t\t\tint nDeltaY = n, nDeltaBlackY = n;\r\n\t\t\tTEXTMETRIC tm = { 0 };\r\n\t\t\tGetTextMetrics(hdc, &tm);\r\n\t\t\tif (lpgm->gmptGlyphOrigin.y < tm.tmAscent) {\t// origin out of the top of the box\r\n\t\t\t\tif (lpgm->gmptGlyphOrigin.y + nDeltaY>tm.tmAscent) {\r\n\t\t\t\t\tnDeltaY = tm.tmAscent - lpgm->gmptGlyphOrigin.y;\t// limit the top position of the origin\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse nDeltaY = 0;\r\n\t\t\tlpgm->gmptGlyphOrigin.y += nDeltaY;\r\n\t\t\t/*if (lpgm->gmptGlyphOrigin.x > 0)\r\n\t\t\t\tlpgm->gmBlackBoxX += n; // increase blackbox width if it's not a ligature\r\n\t\t\tif (lpgm->gmBlackBoxX > tm.tmMaxCharWidth) {\r\n\t\t\t\tlpgm->gmBlackBoxX = tm.tmMaxCharWidth;\r\n\t\t\t}*/\r\n\t\t\tlpgm->gmBlackBoxY += nDeltaY;\r\n\t\t\tif (tm.tmAscent - lpgm->gmptGlyphOrigin.y + lpgm->gmBlackBoxY - 1 < tm.tmHeight)\t// still has some room to scale up\r\n\t\t\t{\r\n\t\t\t\tif (tm.tmAscent - lpgm->gmptGlyphOrigin.y + lpgm->gmBlackBoxY + 1 + nDeltaBlackY > tm.tmHeight)\r\n\t\t\t\t\tlpgm->gmBlackBoxY = tm.tmHeight - tm.tmAscent + lpgm->gmptGlyphOrigin.y + 1;\r\n\t\t\t\telse\r\n\t\t\t\t\tlpgm->gmBlackBoxY += nDeltaBlackY;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n// \tTEXTMETRIC tm;\r\n// \tGetTextMetrics(hdc, &tm);\r\n\r\n\treturn ret;\r\n}\r\n\r\nDWORD WINAPI IMPL_GetGlyphOutlineA(__in HDC hdc, __in UINT uChar, __in UINT fuFormat, __out LPGLYPHMETRICS lpgm, __in DWORD cjBuffer, __out_bcount_opt(cjBuffer) LPVOID pvBuffer, __in CONST MAT2 *lpmat2)\r\n{\r\n\t//fuFormat |= GGO_UNHINTED;\r\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\tDWORD ret=  ORIG_GetGlyphOutlineA(hdc, uChar, fuFormat, lpgm, cjBuffer, pvBuffer, lpmat2);\r\n// \tif (pSettings->EnableClipBoxFix())\r\n// \t{\r\n// \t\tlpgm->gmptGlyphOrigin.y+=1;\r\n// \t\tlpgm->gmBlackBoxY+=1;\r\n// \t}\r\n\tif (pSettings->EnableClipBoxFix() && (!cjBuffer || !pvBuffer)) {\r\n\t\tif (!(fuFormat & (GGO_BITMAP | GGO_GRAY2_BITMAP | GGO_GRAY4_BITMAP | GGO_GRAY8_BITMAP | GGO_NATIVE))) {\r\n\t\t\tstatic int n = (int)floor(1.5*pSettings->ScreenDpi() / 96);\r\n\t\t\tint nDeltaY = n, nDeltaBlackY = n;\r\n\t\t\tTEXTMETRIC tm = { 0 };\r\n\t\t\tGetTextMetrics(hdc, &tm);\r\n\t\t\tif (lpgm->gmptGlyphOrigin.y < tm.tmAscent) {\t// origin out of the top of the box\r\n\t\t\t\tif (lpgm->gmptGlyphOrigin.y + nDeltaY>tm.tmAscent) {\r\n\t\t\t\t\tnDeltaY = tm.tmAscent - lpgm->gmptGlyphOrigin.y;\t// limit the top position of the origin\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse nDeltaY = 0;\r\n\t\t\t/*if (lpgm->gmptGlyphOrigin.x > 0)\r\n\t\t\t\tlpgm->gmBlackBoxX += n; // increase blackbox width if it's not a ligature\r\n\t\t\tif (lpgm->gmBlackBoxX > tm.tmMaxCharWidth) {\r\n\t\t\t\tlpgm->gmBlackBoxX = tm.tmMaxCharWidth;\r\n\t\t\t}*/\r\n\t\t\tlpgm->gmptGlyphOrigin.y += nDeltaY;\t\r\n\r\n\t\t\tlpgm->gmBlackBoxY += nDeltaY;\r\n\t\t\tif (tm.tmAscent - lpgm->gmptGlyphOrigin.y + lpgm->gmBlackBoxY - 1 < tm.tmHeight)\r\n\t\t\t{\r\n\t\t\t\tif (tm.tmAscent - lpgm->gmptGlyphOrigin.y + lpgm->gmBlackBoxY + 1 + nDeltaBlackY > tm.tmHeight)\r\n\t\t\t\t\tlpgm->gmBlackBoxY = tm.tmHeight - tm.tmAscent + lpgm->gmptGlyphOrigin.y + 1;\r\n\t\t\t\telse\r\n\t\t\t\t\tlpgm->gmBlackBoxY += nDeltaBlackY;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n\r\n\r\nint WINAPI IMPL_GetTextFaceW( __in HDC hdc, __in int c, __out_ecount_part_opt(c, return)  LPWSTR lpName)\r\n{\r\n\tint nSize = ORIG_GetTextFaceW(hdc, c, lpName);\r\n\tLPCWSTR fontcache=GetCachedFontLocale(GetCurrentFont(hdc));\r\n\t\r\n\tif (fontcache){\r\n\t\tif (lpName) {\r\n\t\t\tint len = Min(LF_FACESIZE, c);\r\n\t\t\tStringCchCopy(lpName, len, fontcache);\r\n\t\t\tnSize = (int)wcslen(fontcache) > len ? len : wcslen(fontcache) + 1;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// a request for the size of font\r\n\t\t\tnSize = Min(LF_FACESIZE, (int)wcslen(fontcache)+1);\r\n\t\t}\r\n\t}\r\n\treturn nSize;\r\n}\r\n\r\nint WINAPI IMPL_GetTextFaceA( __in HDC hdc, __in int c, __out_ecount_part_opt(c, return)  LPSTR lpName)\r\n{\r\n\tint nSize = ORIG_GetTextFaceA(hdc, c, lpName);\r\n\tLPCWSTR fontcache=GetCachedFontLocale(GetCurrentFont(hdc));\r\n\tif (fontcache){\r\n\t\t//int len=Min(LF_FACESIZE, c);\r\n\t\tsize_t _Dsize = 2 * wcslen(fontcache) + 1;\r\n\t\tchar *_Dest = new char[_Dsize];\r\n\t\tmemset(_Dest,0,_Dsize);\r\n\t\tint len =wcstombs(_Dest, fontcache, _Dsize);\r\n\t\tif (lpName)\r\n\t\t\tStringCchCopyA(lpName, LF_FACESIZE, _Dest);\r\n\t\tdelete[] _Dest;\r\n\t\tnSize = len+1;\r\n\t}\r\n\treturn nSize;\r\n}\r\n\r\nHGDIOBJ WINAPI IMPL_GetStockObject(__in int i)\r\n{\r\n\tswitch (i)\r\n\t{\r\n\t\tcase DEFAULT_GUI_FONT:\r\n\t\t\t{\r\n\t\t\t\tstatic const CGdippSettings* pSetting = CGdippSettings::GetInstance();\r\n\t\t\t\tif (g_alterGUIFont)\r\n\t\t\t\t\treturn g_alterGUIFont;\r\n\t\t\t\telse\r\n\t\t\t\t\treturn ORIG_GetStockObject(i);\r\n\t\t\t}\r\n/*\r\n\t\tcase SYSTEM_FONT:\r\n\t\t\t{\r\n\t\t\t\tif (g_alterSysFont)\r\n\t\t\t\t\treturn g_alterSysFont;\r\n\t\t\t\tbreak;\r\n\t\t\t}*/\r\n\r\n\t\tdefault: return ORIG_GetStockObject(i);\r\n\t}\r\n\treturn ORIG_GetStockObject(i);\r\n\r\n}\r\n\r\nBOOL WINAPI IMPL_BeginPath(HDC hdc)\r\n{\r\n\t//CThreadCounter __counter;\r\n\tBOOL ret=ORIG_BeginPath(hdc);\r\n\tif (ret)\r\n\t{\r\n\t\tDCArray.insert(hdc);\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nBOOL WINAPI IMPL_EndPath(HDC hdc)\r\n{\r\n\t//CThreadCounter __counter;\r\n\tBOOL ret=ORIG_EndPath(hdc);\r\n\tif (ret)\r\n\t{\r\n\t\tDCArray.erase(hdc);\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nBOOL WINAPI IMPL_AbortPath(HDC hdc)\r\n{\r\n\t//CThreadCounter __counter;\r\n\tBOOL ret=ORIG_AbortPath(hdc);\r\n\tif (ret)\r\n\t{\r\n\t\tDCArray.erase(hdc);\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nint WINAPI IMPL_GetObjectA(__in HANDLE h, __in int c, __out_bcount_opt(c) LPVOID pv)\r\n{\r\n\tint ret = ORIG_GetObjectA(h, c, pv);\r\n\tif (ret==sizeof(LOGFONTA))\r\n\t{\r\n\t\tLPCWSTR fontcache = GetCachedFont((HFONT)h);\r\n\t\tif (fontcache && pv)\r\n\t\t{\r\n\t\t\tsize_t _Dsize = 2 * wcslen(fontcache) + 1;\r\n\t\t\tchar *_Dest = new char[_Dsize];\r\n\t\t\tmemset(_Dest,0,_Dsize);\r\n\t\t\twcstombs(_Dest,fontcache,_Dsize);\r\n\t\t\tStringCchCopyA(((LOGFONTA*)pv)->lfFaceName, LF_FACESIZE, _Dest);\r\n\t\t\tdelete []_Dest;\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nint WINAPI IMPL_GetObjectW(__in HANDLE h, __in int c, __out_bcount_opt(c) LPVOID pv)\r\n{\r\n\tint ret = ORIG_GetObjectW(h, c, pv);\r\n\tif (ret==sizeof(LOGFONTW))\r\n\t{\r\n\t\tLPCWSTR fontcache = GetCachedFont((HFONT)h);\r\n\t\tif (fontcache && pv)\r\n\t\t{\r\n\t\t\tStringCchCopyW(((LOGFONTW*)pv)->lfFaceName, LF_FACESIZE, fontcache);\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nHFONT WINAPI IMPL_CreateFontIndirectExW(CONST ENUMLOGFONTEXDV *penumlfex)\r\n{\r\n\tif (!penumlfex) return NULL;\r\n\tTRACE(L\"Creating font \\\"%s\\\"\\n\", penumlfex->elfEnumLogfontEx.elfLogFont.lfFaceName);\r\n\t{\r\n\t\tif (penumlfex->elfEnumLogfontEx.elfLogFont.lfClipPrecision == FONT_MAGIC_NUMBER)\r\n\t\t{\t\t\r\n\t\t\tTRACE(L\"Engine font, Ignored, \");\r\n\t\t\t((ENUMLOGFONTEXDV *)penumlfex)->elfEnumLogfontEx.elfLogFont.lfClipPrecision = 0;\r\n\t\t\treturn ORIG_CreateFontIndirectExW(penumlfex);\r\n\t\t}\r\n\t}\r\n\r\n\t/*\r\n\t\tGetEnvironmentVariableW(L\"MACTYPE_FONTSUBSTITUTES_ENV\", NULL, 0);\r\n\t\t\tif (GetLastError()!=ERROR_ENVVAR_NOT_FOUND)\r\n\t\t\t\treturn ORIG_CreateFontIndirectExW(penumlfex);*/\r\n\t\t\r\n\r\n\tif(!penumlfex) {\r\n\t\t\tSetLastError(ERROR_INVALID_PARAMETER);\r\n\t\t\treturn NULL;\r\n\t\t}\r\n\t\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\t\tif (pSettings->IsFontExcluded(penumlfex->elfEnumLogfontEx.elfLogFont.lfFaceName)) {\r\n\t\t\tTRACE(L\"Font exception! \");\r\n\t\t\treturn ORIG_CreateFontIndirectExW(penumlfex);\r\n\t\t\t//TRACE(L\"Handle = %x\\n\" , (int)h);\r\n\t\t}\r\n\r\n\r\n\t\tENUMLOGFONTEXDV mfont(*penumlfex);\r\n\t\tLOGFONT& lf = mfont.elfEnumLogfontEx.elfLogFont;\r\n\t\tLOGFONT lfOrg(lf);\r\n\t\tBOOL bForced = false;\r\n\t\tif (bForced = pSettings->CopyForceFont(lf, lfOrg)) {\r\n/*\r\n\t\t\tmfont->elfEnumLogfontEx.elfLogFont.lfHeight\t\t\t= lf.lfHeight;\r\n\t//\t\t\tmfont->elfEnumLogfontEx.elfLogFont.lfWidth\t\t\t= lfOrg.lfWidth;\r\n\t\t\tmfont->elfEnumLogfontEx.elfLogFont.lfWidth\t\t\t= lf.lfWidth;\r\n\t\t\tmfont->elfEnumLogfontEx.elfLogFont.lfEscapement\t\t= lf.lfEscapement;\r\n\t\t\tmfont->elfEnumLogfontEx.elfLogFont.lfOrientation\t= lf.lfOrientation;\r\n\t\t\tmfont->elfEnumLogfontEx.elfLogFont.lfWeight\t\t\t= lf.lfWeight;\r\n\t\t\tmfont->elfEnumLogfontEx.elfLogFont.lfItalic\t\t\t= lf.lfItalic;\r\n\t\t\tmfont->elfEnumLogfontEx.elfLogFont.lfUnderline\t\t= lf.lfUnderline;\r\n\t\t\tmfont->elfEnumLogfontEx.elfLogFont.lfStrikeOut\t\t= lf.lfStrikeOut;\r\n\t\t\tmfont->elfEnumLogfontEx.elfLogFont.lfCharSet\t\t= lf.lfCharSet;\r\n\t\t\tmfont->elfEnumLogfontEx.elfLogFont.lfOutPrecision\t= 0;\r\n\t\t\tmfont->elfEnumLogfontEx.elfLogFont.lfClipPrecision\t= 0;\r\n\t\t\tmfont->elfEnumLogfontEx.elfLogFont.lfQuality\t\t= 0;\r\n\t\t\tmfont->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily\t= 0;\r\n\t\t\tStringCchCopy(mfont->elfEnumLogfontEx.elfLogFont.lfFaceName, LF_FACESIZE, lf.lfFaceName);*/\r\n\r\n\t\t\tTRACE(L\"Font substitutes to \\\"%s\\\"\\n\", lf.lfFaceName);\r\n\t\t}\r\n\t\telse\r\n\t\t\tTRACE(L\"Normal font\\n\");\r\n\t\t//bypass = true;\r\n\t\tHFONT hf = ORIG_CreateFontIndirectExW(&mfont);\r\n\t\t//ORIG_CreateFontIndirectExW(\r\n\t\t//if(hf && lplf && !pSettings->LoadOnDemand()) {\r\n\t\t//\tAddFontToFT(lplf->lfFaceName, lplf->lfWeight, !!lplf->lfItalic);\r\n\t\t//}\r\n\t\tif (hf && bForced) {\t\r\n\t\t\tAddToCachedFont(hf, (WCHAR*)penumlfex->elfEnumLogfontEx.elfLogFont.lfFaceName, (WCHAR *)lfOrg.lfFaceName);\r\n\t\t}\r\n\t\t//bypass = false;\r\n\t\tTRACE(L\"Create font %s handle %x\\n\", lfOrg.lfFaceName, (int)hf);\r\n\t\treturn hf;\r\n}\r\n\r\nBOOL WINAPI IMPL_DeleteObject(HGDIOBJ hObject)\r\n{\r\n\t//CThreadCounter __counter;\r\n\tif (hObject == g_alterGUIFont)\t//我的系统字体，不可以释放掉\r\n\t\treturn true;\r\n\tBOOL bResult = ORIG_DeleteObject(hObject);\r\n\tif (bResult) DeleteCachedFont((HFONT)hObject);\r\n\treturn bResult;\r\n}\r\n\r\n\r\nHFONT WINAPI IMPL_CreateFontIndirectW(CONST LOGFONTW *lplf)\t//重新启用这个hook，只为兼容搜狗输入法\r\n{\r\n\tENUMLOGFONTEXDVW envlf = {0};\r\n\tmemcpy(&envlf.elfEnumLogfontEx.elfLogFont, lplf, sizeof(LOGFONTW));\r\n\treturn IMPL_CreateFontIndirectExW(&envlf);\r\n}\r\n\r\n\r\n/*\r\nBOOL WINAPI IMPL_DrawStateA(HDC hdc, HBRUSH hbr, DRAWSTATEPROC lpOutputFunc, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags)\r\n{\r\n\t//CThreadCounter __counter;\r\n\tint cchW;\r\n\tLPWSTR lpStringW;\r\n\r\n\tif(lData && uFlags & DSS_DISABLED) {\r\n\t\tswitch(uFlags & 0x0f) {\r\n\t\tcase DST_TEXT:\r\n\t\tcase DST_PREFIXTEXT:\r\n\t\t\tlpStringW = _StrDupAtoW((LPCSTR)lData, wData ? wData : -1, &cchW);\r\n\t\t\tif(lpStringW) {\r\n\t\t\t\tBOOL ret = IMPL_DrawStateW(hdc, hbr, lpOutputFunc, (LPARAM)lpStringW, cchW, x, y, cx, cy, uFlags);\r\n\t\t\t\tfree(lpStringW);\r\n\t\t\t\treturn ret;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn ORIG_DrawStateA(hdc, hbr, lpOutputFunc, lData, wData, x, y, cx, cy, uFlags);\r\n}\r\n\r\n//灰色描画をDrawTextへ投げる\r\n//DrawTextは内部でExtTextOutしてくれるので問題なし\r\nBOOL WINAPI IMPL_DrawStateW(HDC hdc, HBRUSH hbr, DRAWSTATEPROC lpOutputFunc, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags)\r\n{\r\n\t//CThreadCounter __counter;\r\n\tif(lData && uFlags & DSS_DISABLED) {\r\n\t\tswitch(uFlags & 0x0f) {\r\n\t\tcase DST_TEXT:\r\n\t\tcase DST_PREFIXTEXT:\r\n\t\t\t{\r\n\t\t\t//wData==0の時に文字数自動計算\r\n\t\t\t//他のAPIと違って-1の時ではない\r\n\t\t\tif(wData == 0) {\r\n\t\t\t\twData = wcslen((LPCWSTR)lData);\r\n\t\t\t}\r\n\t\t\tRECT rect = { x, y, x + 10000, y + 10000 };\r\n\t\t\t//どうやら3DHighLightの上に1pxずらして3DShadowを重ねてるらしい\r\n\t\t\tint oldbm = SetBkMode(hdc, TRANSPARENT);\r\n\t\t\tCOLORREF oldfg = SetTextColor(hdc, GetSysColor(COLOR_3DHIGHLIGHT));\r\n\t\t\t//DrawStateとDrawTextではprefixのフラグが逆(APIの設計ダメすぎ)\r\n\t\t\tconst UINT uDTFlags = DT_SINGLELINE | DT_NOCLIP | (uFlags & DST_PREFIXTEXT ? 0 : DT_NOPREFIX);\r\n\r\n\t\t\tOffsetRect(&rect, 1, 1);\r\n\t\t\tDrawTextW(hdc, (LPCWSTR)lData, wData, &rect, uDTFlags);\r\n\t\t\tSetTextColor(hdc, GetSysColor(COLOR_3DSHADOW));\r\n\t\t\tOffsetRect(&rect, -1, -1);\r\n\t\t\tDrawTextW(hdc, (LPCWSTR)lData, wData, &rect, uDTFlags);\r\n\t\t\tSetTextColor(hdc, oldfg);\r\n\t\t\tSetBkMode(hdc, oldbm);\r\n\t\t\t}\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n\treturn ORIG_DrawStateW(hdc, hbr, lpOutputFunc, lData, wData, x, y, cx, cy, uFlags);\r\n}*/\r\n\r\n\r\nclass FreeTypeFontEngine;\r\nextern FreeTypeFontEngine* g_pFTEngine;\r\n\r\n\r\nBOOL __stdcall IMPL_RemoveFontResourceExW(__in LPCWSTR name, __in DWORD fl, __reserved PVOID pdv)\r\n{\r\n\tg_pFTEngine->RemoveFont(name);\r\n\treturn ORIG_RemoveFontResourceExW(name, fl, pdv);\r\n}\r\n\r\n/*\r\nBOOL __stdcall IMPL_RemoveFontResourceW(__in LPCWSTR lpFileName)\r\n{\r\n\tg_pFTEngine->RemoveFont(lpFileName);\r\n\treturn ORIG_RemoveFontResourceW(lpFileName);\r\n}*/\r\n\r\nBOOL WINAPI IMPL_TextOutA(HDC hdc, int nXStart, int nYStart, LPCSTR lpString, int cbString)\r\n{\r\n\t//CThreadCounter __counter;\r\n\treturn IMPL_ExtTextOutA(hdc, nXStart, nYStart, NULL, NULL, lpString, cbString, NULL);\r\n}\r\n\r\n\r\n\r\nBOOL WINAPI IMPL_TextOutW(HDC hdc, int nXStart, int nYStart, LPCWSTR lpString, int cbString)\r\n{\r\n\t//CThreadCounter __counter;\r\n\treturn IMPL_ExtTextOutW(hdc, nXStart, nYStart, NULL, NULL, lpString, cbString, NULL);\r\n}\r\n\r\n\r\n\r\n\r\nvoid AnsiDxToUnicodeDx(LPCSTR lpStringA, int cbString, const int* lpDxA, int* lpDxW, int ACP)\r\n{\r\n\tLPCSTR lpEndA = lpStringA + cbString;\r\n\twhile(lpStringA < lpEndA) {\r\n\t\t*lpDxW = *lpDxA++;\r\n\t\tif(IsDBCSLeadByteEx(ACP, *lpStringA)) {\r\n\t\t\t*lpDxW += *lpDxA++;\r\n\t\t\tlpStringA++;\r\n\t\t}\r\n\t\tlpDxW++;\r\n\t\tlpStringA++;\r\n\t}\r\n}\r\n\r\n// ANSI->Unicodeに変換してExtTextOutWに投げるExtTextOutA\r\n\r\nBOOL WINAPI IMPL_ExtTextOutA(HDC hdc, int nXStart, int nYStart, UINT fuOptions, CONST RECT *lprc, LPCSTR lpString, UINT cbString, CONST INT *lpDx)\r\n{\r\n\t//CThreadCounter __counter;\r\n\tif (!hdc || !lpString || !cbString || !g_ccbRender || !(fuOptions & ETO_IGNORELANGUAGE)) {\r\n\t\treturn ORIG_ExtTextOutA(hdc, nXStart, nYStart, fuOptions, lprc, lpString, cbString, lpDx);\r\n\t}\r\n\r\n\t//However, if the ANSI version of ExtTextOut is called with ETO_GLYPH_INDEX,\r\n\t//the function returns TRUE even though the function does nothing.\r\n\t//とりあえずオリジナルに飛ばす\r\n\tif (fuOptions & ETO_GLYPH_INDEX)\r\n\t\treturn ORIG_ExtTextOutA(hdc, nXStart, nYStart, fuOptions, lprc, lpString, cbString, lpDx);\r\n\r\n\t//HDBENCHチート\r\n//\tif (lpString && cbString == 7 && pSettings->IsHDBench() && (memcmp(lpString, \"HDBENCH\", 7) == 0 || memcmp(lpString, \"       \", 7) == 0))\r\n//\t\treturn ORIG_ExtTextOutA(hdc, nXStart, nYStart, fuOptions, lprc, lpString, cbString, lpDx);\r\n\r\n\tLPWSTR lpszUnicode;\r\n\tint bufferLength;\r\n\tBOOL result;\r\n\tWCHAR szStack[CCH_MAX_STACK];\r\n\tint dxStack[CCH_MAX_STACK];\r\n\tint nACP = GdiGetCodePage(hdc);//CP_ACP;\r\n\t//DWORD nCharset = GetTextCharsetInfo(hdc, NULL, 0);\r\n\r\n\t/*\r\n\tswitch (nCharset)\r\n\t\t{\r\n\t\tcase 0:\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\tcase SYMBOL_CHARSET:\r\n\t\t\t{\r\n\t\t\t\tnACP = CP_SYMBOL;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\tcase MAC_CHARSET:\r\n\t\t\t{\r\n\t\t\t\tnACP = CP_MACCP;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\tcase OEM_CHARSET:\r\n\t\t\t{\r\n\t\t\t\tnACP = CP_OEMCP;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\tdefault:\r\n\t\t\t{\r\n\t\t\t\tCHARSETINFO Cs={0,CP_ACP,0};\r\n\t\t\t\tTranslateCharsetInfo((DWORD*)nCharset, &Cs, TCI_SRCCHARSET);\r\n\t\t\t\tnACP = Cs.ciACP;\r\n\t\t\t}\r\n\t\t}*/\r\n\t\r\n\r\n\tlpszUnicode = _StrDupExAtoW(lpString, cbString, szStack, CCH_MAX_STACK, &bufferLength, nACP);\r\n\tif(!lpszUnicode) {\r\n\t\t//メモリ不足: 一応オリジナルに投げとく\r\n\t\treturn ORIG_ExtTextOutA(hdc, nXStart, nYStart, fuOptions, lprc, lpString, cbString, lpDx);\r\n\t}\r\n\r\n\tint* lpDxW = NULL;\r\n\tresult = FALSE;\r\n\tif(lpDx && cbString && _getmbcp()) {\r\n\t\tif (cbString < CCH_MAX_STACK) {\r\n\t\t\tlpDxW = dxStack;\r\n\t\t\tZeroMemory(lpDxW, sizeof(int) * cbString);\r\n\t\t} else {\r\n\t\t\tlpDxW = (int*)calloc(sizeof(int), cbString);\r\n\t\t\tif (!lpDxW) {\r\n\t\t\t\tgoto CleanUp;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (nACP!=CP_SYMBOL)\r\n\t\t{\r\n\t\t\tAnsiDxToUnicodeDx(lpString, cbString, lpDx, lpDxW, nACP);\r\n\t\t\tlpDx = lpDxW;\r\n\t\t}\r\n\t}\r\n\r\n\tresult = IMPL_ExtTextOutW(hdc, nXStart, nYStart, fuOptions, lprc, (LPCWSTR)lpszUnicode, bufferLength, lpDx);\r\n\r\nCleanUp:\r\n\tif (lpszUnicode != szStack)\r\n\t\tfree(lpszUnicode);\r\n\tif (lpDxW != dxStack)\r\n\t\tfree(lpDxW);\r\n\treturn result;\r\n}\r\n\r\n\r\n\r\n\r\ntypedef enum {\r\n\tETOE_OK\t\t\t\t= 0,\r\n\tETOE_CREATEDC\t\t= 1,\r\n\tETOE_SETFONT\t\t= 2,\r\n\tETOE_CREATEDIB\t\t= 3,\r\n\tETOE_FREETYPE\t\t= 4,\r\n\tETOE_INVALIDARG\t\t= 11,\r\n\tETOE_ROTATION\t\t= 12,\r\n\tETOE_LARGESIZE\t\t= 13,\r\n\tETOE_INVALIDHDC\t\t= 14,\r\n\tETOE_ROTATEFONT\t\t= 15,\r\n\tETOE_NOAREA\t\t\t= 16,\r\n\tETOE_GETTEXTEXTENT\t= 17,\r\n\tETOE_MONO\t\t\t= 18,\r\n\tETOE_GENERAL\t\t= 19,\r\n} ExtTextOut_ErrorCode;\r\n\r\n//例外モドキ\r\n#define ETO_TRY()\t\tExtTextOut_ErrorCode error = ETOE_OK; {\r\n#define ETO_THROW(code)\terror = (code); goto _EXCEPTION_THRU\r\n#define ETO_CATCH()\t\t} _EXCEPTION_THRU:\r\n\r\n/*\r\nBOOL FreeTypeGetTextExtentPoint(HDC hdc, LPCSTR lpString, int cbString, LPSIZE lpSize, const FREETYPE_PARAMS* params)\r\n{\r\n\tWCHAR szStack[CCH_MAX_STACK];\r\n\r\n\tint cchStringW;\r\n\tLPWSTR lpStringW = _StrDupExAtoW(lpString, cbString, szStack, CCH_MAX_STACK, &cchStringW);\r\n\tif(!lpStringW) {\r\n\t\tSetLastError(ERROR_NOT_ENOUGH_MEMORY);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tBOOL ret = FreeTypeGetTextExtentPoint(hdc, lpStringW, cchStringW, lpSize, params);\r\n\tif (lpStringW != szStack)\r\n\t\tfree(lpStringW);\r\n\treturn ret;\r\n}*/\r\n\r\n\r\nclass CETOBitmap\r\n{\r\nprivate:\r\n\tCBitmapCache&\tm_cache;\r\n\tHDC\t\t\t\tm_hdc;\r\n\tHBITMAP\t\t\tm_hPrevBmp;\r\n\tHBITMAP\t\t\tm_hBmp;\r\n\tBYTE*\t\t\tm_lpPixels;\r\n\r\npublic:\r\n\tCETOBitmap(CBitmapCache& cache)\r\n\t\t: m_cache(cache)\r\n\t\t, m_hdc(NULL)\r\n\t\t, m_hPrevBmp(NULL)\r\n\t\t, m_hBmp(NULL)\r\n\t\t, m_lpPixels(NULL)\r\n\t{\r\n\t}\r\n\tHDC CreateDC(HDC dc)\r\n\t{\r\n\t\tm_hdc = m_cache.CreateDC(dc);\r\n\t\treturn m_hdc;\r\n\t}\r\n\tbool CreateDIBandSelect(int cx, int cy)\r\n\t{\r\n\t\tm_hBmp = m_cache.CreateDIB(cx, cy, &m_lpPixels);\r\n\t\tif (!m_hBmp) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tm_hPrevBmp = SelectBitmap(m_hdc, m_hBmp);\r\n\t\treturn true;\r\n\t}\r\n\tvoid RestoreBitmap()\r\n\t{\r\n\t\tif (m_hPrevBmp) {\r\n\t\t\tSelectBitmap(m_hdc, m_hPrevBmp);\r\n\t\t\tm_hPrevBmp = NULL;\r\n\t\t}\r\n\t}\r\n};\r\n\r\nextern ControlIder CID;\r\n// 取代Windows的ExtTextOutW\r\nBOOL WINAPI IMPL_ExtTextOutW(HDC hdc, int nXStart, int nYStart, UINT fuOptions, CONST RECT *lprc, LPCWSTR lpString, UINT cbString, CONST INT *SyslpDx)\r\n{\r\n\t//CThreadCounter __counter;\t\t//用于安全退出的计数器\r\n\tINT* lpDx = const_cast<INT*>(SyslpDx);\r\n\r\n\tif (!hdc || !lpString || !cbString || !g_ccbRender || cbString>8192) {\t\t//no valid param or rendering is disabled from control center.\r\n\t\treturn ORIG_ExtTextOutW(hdc, nXStart, nYStart, fuOptions, lprc, lpString, cbString, lpDx);\r\n\t}\r\n\tif (!(fuOptions & ETO_GLYPH_INDEX) && cbString==1 && *lpString==32)\t//空格\r\n\t\treturn ORIG_ExtTextOutW(hdc, nXStart, nYStart, fuOptions | ETO_IGNORELANGUAGE, lprc, lpString, cbString, lpDx);\t//空格就不用处理了。。。反正都一样\r\n\r\n\tCThreadLocalInfo* pTLInfo = g_TLInfo.GetPtr();\t\t\r\n\tif(!pTLInfo) {\r\n\t\treturn ORIG_ExtTextOutW(hdc, nXStart, nYStart, fuOptions, lprc, lpString, cbString, lpDx);\r\n\t}\r\n\r\n\tif (DCArray.find(hdc)!=DCArray.end())\r\n\t\treturn ORIG_ExtTextOutW(hdc, nXStart, nYStart, fuOptions, lprc, lpString, cbString, lpDx);\r\n\tCAutoVectorPtr<INT> newdx;\r\n\tif (!lpDx) {\r\n\t\tnewdx.Allocate(cbString);\r\n\t\tSIZE p = { 0 };\r\n\t\tBOOL r = false;\r\n\t\tif (fuOptions & ETO_GLYPH_INDEX)\r\n\t\t\tr = GetTextExtentExPointI(hdc, (LPWORD)lpString, cbString, 0, NULL, newdx, &p);\r\n\t\telse\r\n\t\t\tr = GetTextExtentExPointW(hdc, lpString, cbString, 0, NULL, newdx, &p);\r\n\t\tif (r) {\r\n\t\t\tfor (int i = cbString - 1; i > 0; --i) {\r\n\t\t\t\tnewdx[i] -= newdx[i - 1];\r\n\t\t\t}\r\n\t\t\tlpDx = newdx;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tnewdx.Free();\r\n\t\t}\r\n\t}\r\n\r\n\tif (!(fuOptions & ETO_GLYPH_INDEX) && !(fuOptions & ETO_IGNORELANGUAGE) && !lpDx && CID.myiscomplexscript(lpString,cbString))\t\t//complex script\r\n\t\treturn ORIG_ExtTextOutW(hdc, nXStart, nYStart, fuOptions, lprc, lpString, cbString, lpDx);\r\n\tCGdippSettings* pSettings = CGdippSettings::GetInstance(); //获得一个配置文件实例\r\n\r\n/*\r\n\r\n#ifndef _DEBUG\t\t//debug模式下此参数有问题\r\n\tif (pSettings->FontLoader()==SETTING_FONTLOADER_WIN32)\r\n\t{\r\n\t\tif (!(fuOptions & ETO_GLYPH_INDEX) \t//复杂文件，不进行渲染\r\n\t\t&& !(fuOptions & ETO_IGNORELANGUAGE) && ScriptIsComplex(lpString, cbString, SIC_COMPLEX) == S_OK) {\r\n\t\t\treturn ORIG_ExtTextOutW(hdc, nXStart, nYStart, fuOptions, lprc, lpString, cbString, lpDx);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t\tif (!(fuOptions & ETO_GLYPH_INDEX) && / *iswcntrl(lpString[0])* /CID.myiswcntrl(lpString[0])) {\r\n\t\t\treturn ORIG_ExtTextOutW(hdc, nXStart, nYStart, fuOptions, lprc, lpString, cbString, lpDx);\r\n\t\t}\r\n#endif\r\n\r\n*/\r\n\r\n\r\n\t\r\n\tif (pTLInfo->InExtTextOut()) {\t//是异常之后的自动还原执行\r\n\t\treturn ORIG_ExtTextOutW(hdc, nXStart, nYStart, fuOptions, lprc, lpString, cbString, lpDx);\r\n\t}\r\n\r\n\tXFORM xfm;\r\n\tstatic XFORM stdXfm = {1.0,0,0,1.0,0,0};\r\n\tbool bZoomedDC = false;\r\n\tCDCTransformer* DCTrans = NULL;\r\n\tif (GetTransform)\r\n\t{\r\n\t\tGetTransform(hdc, GT_WORLD_TO_DEVICE, &xfm);\r\n\t\tif (memcmp(&xfm, &stdXfm, sizeof(XFORM)-sizeof(FLOAT)*2)) //(xfm.eM11!=1.0 || xfm.eM22!=1.0)\t//如果存在坐标转换\r\n\t\t{\r\n\t\t\tbool bZoomInOut = (xfm.eM12==0 && xfm.eM21==0 && xfm.eM11>0 && xfm.eM22>0);\t//只是缩放,且是正数缩放\r\n\t\t\tif (!bZoomInOut)\r\n\t\t\t\treturn ORIG_ExtTextOutW(hdc, nXStart, nYStart, fuOptions, lprc, lpString, cbString, lpDx);\t//放弃渲染\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tbZoomedDC = true;\r\n\t\t\t\tDCTrans = new CDCTransformer;\r\n\t\t\t\tDCTrans->init(xfm);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n/*\r\n\tint mm = GetMapMode(hdc);\r\n\tif (mm!=MM_TEXT)\r\n\t{\r\n\t\tSIZE size;\r\n\t\tGetWindowExtEx(hdc, &size);\r\n\t\tif (size.cx!=1 || size.cy!=1)\r\n\t\t\treturn ORIG_ExtTextOutW(hdc, nXStart, nYStart, fuOptions, lprc, lpString, cbString, lpDx);\r\n\t}\r\n\tif (GetGraphicsMode(hdc)==GM_ADVANCED)\r\n\t{\r\n\t\tXFORM xfm;\r\n\t\tGetWorldTransform(hdc, &xfm);\r\n\t\tif (xfm.eM11!=1.0 || xfm.eM22!=1.0)\r\n\t\t\treturn ORIG_ExtTextOutW(hdc, nXStart, nYStart, fuOptions, lprc, lpString, cbString, lpDx);\r\n\t}*/\r\n\t\r\n\t//if (GetROP2(hdc)!=13)\r\n\t//\treturn ORIG_ExtTextOutW(hdc, nXStart, nYStart, fuOptions, lprc, lpString, cbString, lpDx);\r\n\t//if (GetStretchBltMode(hdc)!=BLACKONWHITE)\r\n\t//\treturn ORIG_ExtTextOutW(hdc, nXStart, nYStart, fuOptions, lprc, lpString, cbString, lpDx);\r\n\r\n/*\r\n\tSIZE size;\r\n\tif (fuOptions & ETO_GLYPH_INDEX)\r\n\t\tGetTextExtentPointI(hdc,(LPWORD)lpString, cbString,&size);\r\n\telse\r\n\t\tGetTextExtentPoint(hdc, lpString, cbString, &size);\r\n\tif (!size.cx)\r\n\t\treturn ORIG_ExtTextOutW(hdc, nXStart, nYStart, fuOptions, lprc, lpString, cbString, lpDx);*/\r\n\r\n\tCOwnedCriticalSectionLock __lock2(1, COwnedCriticalSectionLock::OCS_DC);\t//获取所有权，防止冲突\r\n\tCBitmapCache& cache\t= pTLInfo->BitmapCache();\r\n\tCETOBitmap bmp(cache);\r\n\r\n\tHDC\t\thCanvasDC\t\t= NULL;\r\n\tHFONT\thPrevFont\t\t= NULL;\r\n\tHFONT\thMyCurFont\t\t= NULL;\r\n\tHFONT\thZoomedFont = NULL, hOldMDCFont = NULL;\r\n\tBOOL\tbForceFont = false;\r\n\tint * outlpDx = NULL;\r\n\tFT_Referenced_Glyph* GlyphArray = new FT_Referenced_Glyph[cbString];\r\n\tFT_DRAW_STATE* ftDrawState = new FT_DRAW_STATE[cbString];\r\n\tmemset(GlyphArray, 0, sizeof(FT_Referenced_Glyph)*cbString);\r\n\tmemset(ftDrawState, 0, sizeof(FT_DRAW_STATE)*cbString);\r\n\tOUTLINETEXTMETRIC* otm = NULL;\r\n\r\nETO_TRY();\r\n\t//设置标志，\r\n\tpTLInfo->InExtTextOut(true);\r\n\r\n\tPOINT\tcurPos = { nXStart, nYStart };\t//记录开始的位置\r\n\tPOINT\tdestPos;\r\n\tSIZE\tdrawSize;\r\n\r\n\tHFONT\thCurFont\t\t= NULL;\r\n\tBOOL\tbShadow\t\t\t= FALSE;\r\n\r\n\tUINT\talign;\r\n\tSIZE\ttextSize;\r\n\tSIZE\trealSize = { 0 };\r\n\r\n//================ Is valid DC? =====================\r\n\tif (!IsValidDC(hdc)) {\t\r\n\t\tETO_THROW(ETOE_INVALIDHDC);\t// hdc is invalid\r\n\t}\r\n\r\n\tint nSize=GetOutlineTextMetrics(hdc, 0, NULL);\r\n\tif (!nSize) {\r\n\t\t//nSize = sizeof(OUTLINETEXTMETRIC);\r\n\t\tETO_THROW(ETOE_INVALIDHDC);\r\n\t}\t//耗时50-100ms\r\n\r\n\totm = (OUTLINETEXTMETRIC*)malloc(nSize);\r\n\tmemset(otm, 0, nSize);\r\n\totm->otmSize = nSize;\r\n\tTEXTMETRIC& tm = otm->otmTextMetrics;\r\n\tLOGFONT\tlf = { 0 };\r\n\twstring strFamilyName;\r\n\tGetOutlineTextMetrics(hdc, nSize, otm);\r\n\r\n\tstrFamilyName = (LPWSTR)((DWORD_PTR)otm+(DWORD_PTR)otm->otmpFamilyName);\t//Get TTF font info\r\n\r\n\tconst bool bVertical = pSettings->FontLoader()==SETTING_FONTLOADER_FREETYPE?  strFamilyName.c_str()[0]==L'@' :false;\r\n\r\n\tint nFontHeight = bZoomedDC ? DCTrans->TransformYAB(tm.tmHeight) : tm.tmHeight;\r\n\tif ((pSettings->MaxHeight() && nFontHeight > pSettings->MaxHeight()) || (pSettings->MinHeight() && nFontHeight < pSettings->MinHeight()))  {\r\n\t\tETO_THROW(ETOE_INVALIDHDC);\t//Font size too small or too big.\r\n\t}\r\n\r\n\tif (pSettings->IsFontExcluded(strFamilyName.c_str())) {\t// check if it's excluded\r\n\t\tETO_THROW(ETOE_INVALIDHDC);\r\n\t}\t//20-50ms\r\n\r\n\t// check pitch to make sure it's truetype or opentype\r\n\tif ((otm->otmTextMetrics.tmPitchAndFamily & (TMPF_TRUETYPE | TMPF_VECTOR)) == 0) {\t//opentype (collection) sets the vector bit, truetype sets the truetype bit\r\n\t\tpSettings->AddFontExclude(strFamilyName.c_str());\r\n\t\tETO_THROW(ETOE_INVALIDHDC);\t// set the font as an exclusion and exit\r\n\t}\r\n//====================end================================\r\n\r\n\thCanvasDC = bmp.CreateDC(hdc);\r\n\tif(!hCanvasDC) {\r\n\t\tETO_THROW(ETOE_CREATEDC);\r\n\t}\t//0ms\r\n\r\n\talign = GetTextAlign(hdc);\t// Get align\r\n\t//if (pTLInfo->InUniscribe() && !(fuOptions & ETO_IGNORELANGUAGE))\r\n\t//\talign &= ~TA_UPDATECP;\r\n\tif(align & TA_UPDATECP) {\r\n\t\tGetCurrentPositionEx(hdc, &curPos);\r\n\t}\r\n/*\r\n\tif (!align && lpDx && !fuOptions)\t//optimized\r\n\t{\r\n\t//\tETO_THROW(ETOE_FREETYPE);\r\n\t}//0ms*/\r\n\r\n\r\n\thCurFont = GetCurrentFont(hdc);\t// get font name of current DC, warning: the font name is potaintially incorrect.\r\n\tif (!hCurFont) {\t\t// failed\r\n\t\tETO_THROW(ETOE_SETFONT);\r\n\t}\r\n\tTRACE(L\"Draw text \\\"%s\\\", font=\\\"%s\\\", handle=%x\\n\", lpString, strFamilyName.c_str(), (int)hCurFont);\r\n\tif (!ORIG_GetObjectW(hCurFont, sizeof(LOGFONT), &lf)) {\r\n\t\tETO_THROW(ETOE_SETFONT);\r\n\t}//30ms\r\n\tStringCchCopy(lf.lfFaceName, LF_FACESIZE, (LPWSTR)((DWORD_PTR)otm+(DWORD_PTR)otm->otmpFamilyName));\t// copy the correct font name from otm info to lf\r\n\tif (lf.lfEscapement != 0) {\r\n\t\tETO_THROW(ETOE_ROTATEFONT);// rotated font\r\n\t}\r\n\thPrevFont = SelectFont(hCanvasDC, hCurFont);\r\n\tif (!hPrevFont)\r\n\t{\r\n\t\thMyCurFont = CreateFontIndirect(&lf);\r\n\t\thPrevFont = SelectFont(hCanvasDC, hMyCurFont);\r\n\t}\r\n\r\n\tif (lf.lfHeight >= 0) {\r\n\t\t// use height from tm if not specified in lf\r\n\t\tlf.lfHeight = -(tm.tmHeight-tm.tmInternalLeading);\t//optimized\r\n\t}\r\n\r\n\tif (bZoomedDC)\r\n\t{\r\n\t\t//DCTrans->SetSourceOffset(curPos.x, curPos.y);\r\n\t\tcurPos.x = DCTrans->TransformXAB(curPos.x);\r\n\t\tcurPos.y = DCTrans->TransformYAB(curPos.y);\r\n\t\tlf.lfHeight = DCTrans->TransformYAB(lf.lfHeight);\r\n\t\tlf.lfWidth = DCTrans->TransformXAB(lf.lfWidth);\r\n\t\ttm.tmHeight = abs(DCTrans->TransformYAB(tm.tmHeight));\r\n\t\ttm.tmInternalLeading = abs(DCTrans->TransformYAB(tm.tmInternalLeading));\r\n\t\ttm.tmAscent = DCTrans->TransformYAB(tm.tmAscent);\r\n\t\ttm.tmDescent = DCTrans->TransformYAB(tm.tmDescent);\r\n\t\ttm.tmAveCharWidth = DCTrans->TransformXAB(tm.tmAveCharWidth);\r\n// \t\tif (!DCTrans->TransformMode() && !lf.lfWidth && DCTrans->MirrorX()) \r\n// \t\t\tlf.lfWidth = tm.tmAveCharWidth; \r\n\t\tif (lpDx && cbString)\t//firefox uses coord Y of ETO_PDY to print vertical text\r\n\t\t{\r\n\t\t\tint szDx=fuOptions&ETO_PDY ? cbString*2:cbString;\r\n\t\t\toutlpDx = new int[szDx];\r\n\t\t\tDCTrans->TransformlpDx(lpDx, outlpDx, szDx);\t//lpDx has a size of cbString -1\r\n\t\t}\r\n\t}\r\n\tFREETYPE_PARAMS params(fuOptions & ~ETO_OPAQUE, hdc, &lf, otm);\r\n\tif (bZoomedDC)\r\n\t\tparams.charExtra = DCTrans->TransformXAB(params.charExtra);\r\n\tSetTextCharacterExtra(hCanvasDC, params.charExtra);\r\n\tBITMAP bm;\r\n\tHBITMAP hbmpSrc = (HBITMAP)GetCurrentObject(hdc, OBJ_BITMAP);\r\n\r\n\tif(hbmpSrc && ORIG_GetObjectW(hbmpSrc, sizeof(BITMAP), &bm) && bm.bmBitsPixel <= 16) {\r\n\t\tETO_THROW(ETOE_MONO);\t// ignore monochrome font, since freetype has really bad support of it.\r\n\t\t//params.ftOptions |= FTO_MONO;\r\n\t}\r\n\r\n\tif(!params.IsMono() && pSettings->EnableShadow()) {\r\n\t\tbShadow = true;\r\n\t}\r\n\tint xs = 0, ys=0;\r\n\tif (bShadow) {\r\n\t\tconst int* shadow = pSettings->GetShadowParams();\r\n\t\txs = shadow[0], ys = shadow[1];\r\n\t\tparams.alpha = shadow[2] | shadow[3];\r\n\t}\r\n\telse\r\n\t\tparams.alpha = 1;\r\n\r\n\tint width=0;\r\n\r\n\tFreeTypeDrawInfo FTInfo(params, bZoomedDC ? hCanvasDC : hdc, (LOGFONT*)&lf, &cache, bZoomedDC ? outlpDx : lpDx, cbString, xs, ys);\r\n\r\n\tlf.lfQuality = 0;\t//magic number means this is a non scaled font;\r\n\tif (lf.lfWidth)\r\n\t\t++lf.lfQuality;\r\n\tif (bZoomedDC)\r\n\t{\r\n\t\thZoomedFont = CreateFontIndirect(&lf);\r\n\t\tif (!DCTrans->TransformMode() || lf.lfWidth) \r\n\t\t\t++lf.lfQuality;\t//scaled font\r\n\t\thOldMDCFont = SelectFont(hCanvasDC, hZoomedFont);\r\n\t\tSetGraphicsMode(hCanvasDC, GM_ADVANCED);\r\n\t}\r\n\r\n\tif (!FreeTypeGetGlyph(FTInfo, lpString, cbString, width, GlyphArray, ftDrawState))\r\n\t{\r\n\t\tETO_THROW(ETOE_FREETYPE);\r\n\t}\r\n\tif (FTInfo.xBase<0)\t// Change start position if diacritics are found\r\n\t{\r\n\t\twidth-=FTInfo.xBase;\t// increase width\r\n\t\tFTInfo.x -= FTInfo.xBase;\t// increase width for cursor\r\n\t\tcurPos.x+=FTInfo.xBase;\t// change cursor position\r\n\t\tfor (int i=0;i<cbString;++i)\r\n\t\t\tFTInfo.Dx[i]-=FTInfo.xBase;\t// modify the start position of painting\r\n\t}\r\n\r\n\t/*if (bZoomedDC && DCTrans->MirrorX())\t//左右反向，RGB和BGR要相反\r\n\t\tfor (int i=0; i<cbString; ++i)\r\n\t\t{\r\n\t\t\tswitch (FTInfo.AAModes[i])\r\n\t\t\t{\r\n\t\t\tcase 2:\r\n\t\t\t\tFTInfo.AAModes[i] = 3;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tFTInfo.AAModes[i] = 2;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 4:\r\n\t\t\t\tFTInfo.AAModes[i] = 5;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 5:\r\n\t\t\t\tFTInfo.AAModes[i] = 4;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}*/\r\n\t//POINT destSize;\t//LP下的大小和起始位置\r\n\t/*\r\n\tif (bZoomedDC)\r\n\t\t{\r\n\t\t\tif (hOldMDCFont)\r\n\t\t\t{\r\n\t\t\t\tSelectFont(hCanvasDC, hOldMDCFont);\r\n\t\t\t\tDeleteFont(hZoomedFont);\r\n\t\t\t\thZoomedFont = NULL;\r\n\t\t\t\thOldMDCFont = NULL;\r\n\t\t\t}\r\n\t\t}*/\r\n\t\r\n\ttextSize.cx = width;\r\n\ttextSize.cy = FTInfo.y + tm.tmHeight;\r\n\trealSize.cx = FTInfo.x;\r\n\trealSize.cy = FTInfo.y + tm.tmHeight;\r\n\r\n\t//******************\r\n\r\n\t{\r\n\t\tRECT rc = { 0 };\r\n\t\tconst UINT horiz = align & (TA_LEFT|TA_RIGHT|TA_CENTER);\r\n\t\tconst UINT vert  = align & (TA_BASELINE|TA_TOP|TA_BOTTOM);\r\n\r\n\t\tswitch (horiz) {\r\n\t\tcase TA_CENTER:\r\n\t\t\trc.left  = curPos.x - div_ceil(textSize.cx, 2);\r\n\t\t\trc.right = curPos.x + div_ceil(textSize.cx, 2);\r\n\t\t\t//no move\r\n\t\t\tbreak;\r\n\t\tcase TA_RIGHT:\r\n\t\t\trc.left  = curPos.x - textSize.cx;\r\n\t\t\trc.right = curPos.x;\r\n\t\t\tcurPos.x -= realSize.cx;//move pos\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\trc.left  = curPos.x;\r\n\t\t\trc.right = curPos.x + textSize.cx;\r\n\t\t\tcurPos.x += realSize.cx;//move pos\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tswitch (vert) {\r\n\t\tcase TA_BASELINE:\r\n\t\t\trc.top = curPos.y - tm.tmAscent;\r\n\t\t\trc.bottom = curPos.y + tm.tmDescent + FTInfo.y;\r\n\t\t\t//trace(L\"ascent=%d descent=%d\\n\", metric.tmAscent, metric.tmDescent);\r\n\t\t\tbreak;\r\n\t\tcase TA_BOTTOM:\r\n\t\t\trc.top = curPos.y - textSize.cy;\r\n\t\t\trc.bottom = curPos.y;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\trc.top = curPos.y;\r\n\t\t\trc.bottom = curPos.y + textSize.cy;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t//rc.bottom++;\r\n\t\tdestPos.x = rc.left;\r\n\t\tdestPos.y = rc.top;\r\n\t\tdrawSize.cx = textSize.cx;\r\n\t\tdrawSize.cy = rc.bottom - rc.top;\r\n\t}\r\n\r\n\t//trace(L\"MovedCursor=%d %d\\n\", curPos.x, curPos.y);\r\n\t//trace(L\"TargetRect=%d %d %d %d\\n\", rc.left, rc.top, rc.right, rc.bottom);\r\n\t//trace(L\"DestPos=%dx%d Size=%dx%d\\n\", destPos.x, destPos.y, destSize.cx, destSize.cy);\r\n\t//trace(L\"CanvasPos=%dx%d Size=%dx%d\\n\", canvasPos.x, canvasPos.y, canvasSize.cx, canvasSize.cy);\r\n\r\n\tif(drawSize.cx < 1 || drawSize.cy < 1) {\r\n\t\tETO_THROW(ETOE_NOAREA); //throw no area\r\n\t}\r\n\t//drawSize.cx += tm.tmMaxCharWidth;\t//加上一个最大字体宽度\r\n\r\n\t//bitmap\r\n\r\n\tif (!bmp.CreateDIBandSelect(drawSize.cx+4, drawSize.cy+4)) {\r\n\t\tETO_THROW(ETOE_CREATEDIB);\r\n\t}\r\n\r\n\tint xorg=0, yorg=0;\r\n\tif\t(lprc && (fuOptions & ETO_CLIPPED)) {\r\n\t\tconst RECT rcBlt = { destPos.x, destPos.y, destPos.x + drawSize.cx, destPos.y + drawSize.cy };\r\n\t\tRECT rcClip = { 0 };\r\n\t\tif (bZoomedDC)\r\n\t\t{\r\n\t\t\tRECT rcTrans;\r\n\t\t\tDCTrans->TransformRectAB(lprc, &rcTrans);\r\n\t\t\tIntersectRect(&rcClip, &rcBlt, &rcTrans);\r\n\t\t}\r\n\t\telse\r\n\t\t\tIntersectRect(&rcClip, &rcBlt, lprc);\r\n\t\txorg = rcClip.left-destPos.x; //计算偏移\r\n\t\tyorg = rcClip.top-destPos.y;\r\n\t\tdestPos.x = rcClip.left;\r\n\t\tdestPos.y = rcClip.top;\r\n\t\tdrawSize.cx = rcClip.right-rcClip.left;\r\n\t\tdrawSize.cy = rcClip.bottom-rcClip.top;\r\n\t}\r\n\r\n\t{\r\n\t\tconst BOOL fillrect = (lprc && (fuOptions & ETO_OPAQUE));\r\n\t\t//clear bitmap\r\n\r\n\t\tif(fillrect || GetBkMode(hdc) == OPAQUE) {\r\n\t\t\tCOLORREF  bgcolor = GetBkColor(hdc); //両方とも同じ背景色に\r\n\t\t\t//if ((bgcolor>>24)%2 || (bgcolor>>28)%2)\r\n\t\t\t//\tbgcolor = 0;\r\n\t\t\tif ((bgcolor>>24)%2 || (bgcolor>>28)%2)\r\n\t\t\t\tbgcolor = GetPaletteColor(hdc, bgcolor);\r\n\t\t\tSetBkMode(hCanvasDC, OPAQUE);\r\n\t\t\tSetBkColor(hCanvasDC, bgcolor);\r\n\r\n\t\t\tRECT rc = { xorg, yorg, drawSize.cx+ xorg, drawSize.cy+ yorg };\r\n\t\t\tif (bZoomedDC)\r\n\t\t\t{\r\n\t\t\t\trc.right+=2;\r\n\t\t\t\trc.bottom+=2;\r\n\t\t\t}\r\n\t\t\tcache.FillSolidRect(bgcolor, &rc);\r\n\r\n\t\t\tif(fillrect) {\r\n\t\t\t\t//FillRect(hdc, lprc, (HBRUSH)GetCurrentObject(hdc, OBJ_BRUSH));\r\n\t\t\t\tORIG_ExtTextOutW(hdc, 0, 0, ETO_OPAQUE, lprc, NULL, 0, NULL);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (!bZoomedDC)\r\n\t\t\t{\r\n\t\t\t\tif (!(BitBlt(hCanvasDC, xorg, yorg, drawSize.cx, drawSize.cy, hdc, destPos.x, destPos.y, SRCCOPY)))\r\n\t\t\t\t{\r\n\t\t\t\t\tETO_THROW(ETOE_FREETYPE);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tSetWorldTransform(hCanvasDC, DCTrans->GetTransform());\r\n\t\t\t\tif (!(BitBlt(hCanvasDC, DCTrans->TransformXCoordinateBA(xorg), DCTrans->TransformYCoordinateBA(yorg), \r\n\t\t\t\t\tDCTrans->TransformXCoordinateBA(drawSize.cx+4), DCTrans->TransformYCoordinateBA(drawSize.cy+4), hdc, \r\n\t\t\t\t\tDCTrans->TransformXCoordinateBA(destPos.x), DCTrans->TransformYCoordinateBA(destPos.y), SRCCOPY)))\r\n\t\t\t\t{\r\n\t\t\t\t\tSetWorldTransform(hCanvasDC, &stdXfm);\r\n\t\t\t\t\tETO_THROW(ETOE_FREETYPE);\r\n\t\t\t\t}\r\n\t\t\t\tSetWorldTransform(hCanvasDC, &stdXfm);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t//setup\r\n\tSetTextAlign(hCanvasDC, TA_LEFT | TA_TOP);\r\n\t//debug\r\n\t//Dbg_TraceExtTextOutW(nXStart, nYStart, fuOptions, lpString, cbString, lpDx);\r\n\r\n\t//textout\r\n\tSetTextColor(hCanvasDC, FTInfo.params->color);\r\n\tSetBkMode(hCanvasDC, TRANSPARENT);\r\n\tFTInfo.hdc = hCanvasDC;\r\n\r\n\tif (!FreeTypeTextOut(hCanvasDC, cache, lpString, cbString, FTInfo, GlyphArray, ftDrawState)) {\r\n\t\tETO_THROW(ETOE_FREETYPE);\r\n\t}\r\n\r\n\t//blt + clipping\r\n\t/*\r\n\tif(lprc && (fuOptions & ETO_CLIPPED)) {\r\n\t\t\t//TRACE(_T(\"ClipRect={%d %d %d %d}, pos = (%d,%d)\\n\"), lprc->left, lprc->top, lprc->right, lprc->bottom,\r\n\t\t\t//\tnXStart, nYStart);\r\n\t\t\t//trace(L\"ClipRect=%d %d %d %d\\n\", lprc->left, lprc->top, lprc->right, lprc->bottom);\r\n\t\t\tconst RECT rcBlt = { destPos.x, destPos.y, destPos.x + drawSize.cx, destPos.y + drawSize.cy };\r\n\t\t\tRECT rcClip = { 0 };\r\n\t\t\tIntersectRect(&rcClip, &rcBlt, lprc);\r\n\t\t\tBitBlt(hdc, rcClip.left, rcClip.top, rcClip.right - rcClip.left, rcClip.bottom - rcClip.top,\r\n\t\t\t\t\thCanvasDC, rcClip.left - rcBlt.left, rcClip.top - rcBlt.top, SRCCOPY);\r\n\t\t} else {*/\r\n\tif (!bZoomedDC)\r\n\t\tBitBlt(hdc, destPos.x, destPos.y, drawSize.cx, drawSize.cy, hCanvasDC, xorg, yorg, SRCCOPY);\r\n\telse\r\n\t{\r\n\t\tSetWorldTransform(hCanvasDC, DCTrans->GetTransform());\r\n\t\tBitBlt(hdc, DCTrans->TransformXCoordinateBA(destPos.x), DCTrans->TransformYCoordinateBA(destPos.y), \r\n\t\t\tDCTrans->TransformXCoordinateBA(drawSize.cx), DCTrans->TransformYCoordinateBA(drawSize.cy), hCanvasDC, \r\n\t\t\tDCTrans->TransformXCoordinateBA(xorg), DCTrans->TransformYCoordinateBA(yorg), SRCCOPY);\r\n\t\tSetWorldTransform(hCanvasDC, &stdXfm);\r\n\t}\r\n\r\n\t//}\r\n\t//GdiFlush();\r\n\tif(align & TA_UPDATECP) {\r\n\t\tif (!bZoomedDC)\r\n\t\t\tMoveToEx(hdc, curPos.x, curPos.y, NULL);\r\n\t\telse\r\n\t\t\tMoveToEx(hdc, DCTrans->TransformXCoordinateBA(curPos.x), DCTrans->TransformYCoordinateBA(curPos.y), NULL);\r\n\t}\r\n\r\nETO_CATCH();\r\n\tif (otm)\r\n\t\tfree(otm);\r\n\tbmp.RestoreBitmap();\r\n\tif (hOldMDCFont)\r\n\t{\r\n\t\tSelectFont(hCanvasDC, hOldMDCFont);\r\n\t\tDeleteFont(hZoomedFont);\r\n\t\thZoomedFont = NULL;\r\n\t\thOldMDCFont = NULL;\r\n\t}\r\n\tif(hPrevFont) {\r\n\t\tSelectFont(hCanvasDC, hPrevFont);\r\n\t}\r\n\tif (hMyCurFont)\r\n\t\tDeleteFont(hMyCurFont);\r\n\t{\r\n\t\t//CCriticalSectionLock __lock;\r\n\t\tfor (UINT i=0;i<cbString;i++)\r\n\t\t{\r\n\t\t\tif (GlyphArray[i])\r\n\t\t\t{\r\n\t\t\t\tFT_Done_Ref_Glyph(&GlyphArray[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tdelete[] GlyphArray;\r\n\tdelete[] ftDrawState;\r\n\tif (DCTrans)\r\n\t\tdelete DCTrans;\r\n\tif (outlpDx)\r\n\t\tdelete[] outlpDx;\r\n\tif(error == ETOE_OK) {\r\n\t\tpTLInfo->InExtTextOut(false);\r\n\t\treturn TRUE;\r\n\t}\r\n\tint ret = ORIG_ExtTextOutW(hdc, nXStart, nYStart, fuOptions, lprc, lpString, cbString, lpDx);\r\n\tpTLInfo->InExtTextOut(false);\r\n\treturn ret;\r\n}\r\n\r\nBOOL WINAPI IMPL_MySetProcessMitigationPolicy(\r\n\t_In_ PROCESS_MITIGATION_POLICY MitigationPolicy,\r\n\t_In_ PVOID                     lpBuffer,\r\n\t_In_ SIZE_T                    dwLength\r\n\t)\r\n{\r\n\tif (MitigationPolicy == ProcessDynamicCodePolicy) {\r\n\t\tPPROCESS_MITIGATION_DYNAMIC_CODE_POLICY(lpBuffer)->ProhibitDynamicCode = false;\r\n\t}\r\n\treturn ORIG_MySetProcessMitigationPolicy(MitigationPolicy, lpBuffer, dwLength);\r\n}\r\n\r\n\r\n//HFONT dummy=NULL;\r\n/*\r\nint WINAPI IMPL_GdipCreateFontFamilyFromName(const WCHAR *name, void *fontCollection, void **FontFamily)\r\n{\r\n\tLOGFONT lf={};\r\n\tmemset(&lf, 0, sizeof lf);\r\n\tStringCchCopy(lf.lfFaceName, LF_FACESIZE, name);\r\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\tif (pSettings->CopyForceFont(lf, lf))\r\n\t{\r\n\t\t//dummy = CreateFont(1,0,0,0,0,0,0,0,DEFAULT_CHARSET,0,0,0,0,lf.lfFaceName);\r\n\t\treturn ORIG_GdipCreateFontFamilyFromName(lf.lfFaceName, fontCollection, FontFamily);\r\n\t}\r\n\treturn ORIG_GdipCreateFontFamilyFromName(name, fontCollection, FontFamily);\r\n}*/\r\n\r\n\r\nDWORD WINAPI IMPL_GetFontData(_In_ HDC     hdc,\r\n\t_In_ DWORD   dwTable,\r\n\t_In_ DWORD   dwOffset,\r\n\t_Out_writes_bytes_to_opt_(cjBuffer, return) PVOID pvBuffer,\r\n\t_In_ DWORD   cjBuffer\r\n) {\r\n\tif (dwTable != 0x656d616e)\t// we only simulate the name table, for other tables, use the substituted font data\r\n\t\treturn ORIG_GetFontData(hdc, dwTable, dwOffset, pvBuffer, cjBuffer);\r\n\r\n\tDWORD ret = GDI_ERROR;\r\n\tENUMLOGFONTEXDVW envlf = { 0 };\r\n\tHFONT hCurFont = GetCurrentFont(hdc);\r\n\tif (GetCachedFontLocale(hCurFont) && GetObjectW(hCurFont, sizeof(LOGFONT), &envlf.elfEnumLogfontEx.elfLogFont)) {// call hooked version of GetObject to retrieve font info that the app originally want to create\r\n\t\tHDC memdc = CreateCompatibleDC(hdc);\r\n\t\tHFONT hRealFont = ORIG_CreateFontIndirectExW(&envlf);\t// create memorydc and a real font so that we can run GetFontData on it\r\n\t\tif (hRealFont) {\r\n\t\t\tHFONT hOldFont = SelectFont(memdc, hRealFont);\r\n\t\t\tret = ORIG_GetFontData(memdc, dwTable, dwOffset, pvBuffer, cjBuffer);\t// get font data from the real font\r\n\t\t\tSelectFont(memdc, hOldFont);\r\n\t\t\tDeleteFont(hRealFont);\r\n\t\t}\r\n\t\tDeleteDC(memdc);\r\n\t}\r\n\tif (ret == GDI_ERROR)\t// any of the above operations failed or the font is not substituted\r\n\t\tret = ORIG_GetFontData(hdc, dwTable, dwOffset, pvBuffer, cjBuffer);\t // fallback to original\r\n\treturn ret;\r\n}\r\n\r\n\r\n\r\n\r\n//EOF\r\n"
        },
        {
          "name": "override.h",
          "type": "blob",
          "size": 2.6396484375,
          "content": "\n#pragma once\n\n#include \"common.h\"\n#include \"tlsdata.h\"\n#include \"undocAPI.h\"\n#include \"gdiPlusFlat2.h\"\n\n#include \"cache.h\"\n#include \"settings.h\"\n#include <set>\n#include <dwrite_1.h>\n#include <dwrite_2.h>\n#include <dwrite_3.h>\n\nusing namespace std;\n\n\n/*\ntypedef struct _STRING {\n\tUSHORT  Length;\n\tUSHORT  MaximumLength;\n\tPCHAR  Buffer;\n} ANSI_STRING, *PANSI_STRING;\n\ntypedef int \n(WINAPI *PFNLdrGetProcedureAddress)(\n\t\t\t\t\t\t\t\t\tIN HMODULE              ModuleHandle,\n\t\t\t\t\t\t\t\t\tIN PANSI_STRING         FunctionName OPTIONAL,\n\t\t\t\t\t\t\t\t\tIN WORD                 Oridinal OPTIONAL,\n\t\t\t\t\t\t\t\t\tOUT PVOID               *FunctionAddress );\n*/\n\nstruct CFontSubResult\n{\npublic:\n\tLPWSTR lpRealName;\n\tLPWSTR lpGDIName;\n\tCFontSubResult(LPCWSTR RealName, LPCWSTR GDIName)\n\t{\n\t\tlpRealName = _wcsdup(RealName);\n\t\tlpGDIName = _wcsdup(GDIName);\n\t}\n\t~CFontSubResult()\n\t{\n\t\tif (lpRealName)\n\t\t\tfree(lpRealName);\n\t\tif (lpGDIName)\n\t\t\tfree(lpGDIName);\n\t}\n};\n\ntypedef map<HFONT, CFontSubResult*> CFontCache;\ntypedef set<HDC> CDCArray;\n\nclass CThreadLocalInfo\n{\nprivate:\n\tCBitmapCache\tm_bmpCache;\n\tbool\t\t\tm_bInExtTextOut;\n\tbool\t\t\tm_bInUniscribe;\n\tbool\t\t\tm_bInUniTextOut;\n\tbool\t\t\tm_bPadding[2];\n\tbool\t\t\tm_bInPath;\n\npublic:\n\tCThreadLocalInfo()\n\t\t: m_bInExtTextOut(false), m_bInUniscribe(false), m_bInPath(false), m_bInUniTextOut(false)\n\t{\n\t\tTLSDCArray.insert(&m_bmpCache);\n\t}\n\t~CThreadLocalInfo()\n\t{\n\t\tTLSDCArray.erase(&m_bmpCache);\n\t}\n\n\tCBitmapCache& BitmapCache()\n\t{\n\t\treturn m_bmpCache;\n\t}\n\n\tvoid InExtTextOut(bool b)\n\t{\n\t\tm_bInExtTextOut = b;\n\t}\n\tbool InExtTextOut() const\n\t{\n\t\treturn m_bInExtTextOut;\n\t}\n\n\tvoid InUniscribe(bool b)\n\t{\n\t\tm_bInUniscribe = b;\n\t}\n\tbool InUniscribe() const\n\t{\n\t\treturn m_bInUniscribe;\n\t}\n\tvoid InUniTextOut(bool b)\n\t{\n\t\tm_bInUniTextOut = b;\n\t}\n\tbool InUniTextOut() const\n\t{\n\t\treturn m_bInUniTextOut;\n\t}\n\tvoid InPath(bool b)\n\t{\n\t\tm_bInPath = b;\n\t}\n\tbool Path() const\n\t{\n\t\treturn m_bInPath;\n\t}\n};\n\nextern CTlsData<CThreadLocalInfo>\tg_TLInfo;\n\nBOOL IsProcessExcluded();\nBOOL IsProcessUnload();\nBOOL IsExeUnload(LPCTSTR lpApp);\n\n#define HOOK_MANUALLY HOOK_DEFINE\n#define HOOK_DEFINE(rettype, name, argtype, arglist) \\\n\textern rettype (WINAPI * ORIG_##name) argtype; \\\n\textern rettype WINAPI IMPL_##name argtype;\n#include \"hooklist.h\"\n#undef HOOK_DEFINE\n#undef HOOK_MANUALLY\n\nHFONT GetCurrentFont(HDC hdc);\nvoid AddFontToFT(HFONT hf, LPCTSTR lpszFace, int weight, bool italic);\nvoid AddFontToFT(LPCTSTR lpszFace, int weight, bool italic);\nint MyGetProcAddress(HMODULE dll, LPSTR funcname);\n\n#define HOOK_MANUALLY(rettype, name, argtype, arglist) \\\n\tLONG hook_demand_##name(bool bForce);\n#define HOOK_DEFINE(rettype, name, argtype, arglist) ;\n#include \"hooklist.h\"\n#undef HOOK_DEFINE\n#undef HOOK_MANUALLY\n//EOF\n"
        },
        {
          "name": "ownedcs.cpp",
          "type": "blob",
          "size": 1.6748046875,
          "content": "#include \"ownedcs.h\"\n#include \"windows.h\"\n\n#define InterlockedIncrementInt(x) InterlockedIncrement((volatile LONG *)&(x))\n#define InterlockedDecrementInt(x) InterlockedDecrement((volatile LONG *)&(x))\n#define InterlockedExchangeInt(x, y) InterlockedExchange((volatile LONG *)&(x), LONG(y))\n\nvoid WINAPI InitializeOwnedCritialSection(POWNED_CRITIAL_SECTION cs)\n{\n\tcs->nOwner = -1;\n\tcs->nRecursiveCount = 0;\n\tcs->nRequests = -1;\n\tcs->hEvent = CreateEvent(NULL, false, false, NULL);\n\tInitializeCriticalSection(&cs->threadLock);\n}\n\nvoid WINAPI DeleteOwnedCritialSection(POWNED_CRITIAL_SECTION cs)\n{\n\tCloseHandle(cs->hEvent);\n\tDeleteCriticalSection(&cs->threadLock);\n}\n\n\nvoid WINAPI EnterOwnedCritialSection(POWNED_CRITIAL_SECTION cs, WORD Owner)\n{\n\tEnterCriticalSection(&cs->threadLock);\n\tif (cs->nOwner == Owner)\n\t{\n\t\tInterlockedIncrementInt(cs->nRecursiveCount);\n\t\tLeaveCriticalSection(&cs->threadLock);\n\t}\n\telse\n\t{\n\t\tif (InterlockedIncrementInt(cs->nRequests)>0)  //等待获取所有权\n\t\t{\n\t\t\tLeaveCriticalSection(&cs->threadLock);\n\t\t\tWaitForSingleObject(cs->hEvent, INFINITE);\n\t\t}\n\t\telse\n\t\t\tLeaveCriticalSection(&cs->threadLock);\n\t\tInterlockedExchangeInt(cs->nOwner, Owner);//更改所有者\n\t\tInterlockedExchangeInt(cs->nRecursiveCount, 1);//增加占用计数\n\t}\n}\n\nvoid WINAPI LeaveOwnedCritialSection(POWNED_CRITIAL_SECTION cs, WORD Owner)\n{\n\tEnterCriticalSection(&cs->threadLock);\n\tif (cs->nOwner == Owner)\n\t{\n\t\tif (InterlockedDecrementInt(cs->nRecursiveCount)<=0)\n\t\t{\n\t\t\tInterlockedExchangeInt(cs->nOwner, -1);//归还所有权\n\t\t\tif (InterlockedDecrementInt(cs->nRequests)>=0)\n\t\t\t\tSetEvent(cs->hEvent);\n\t\t}\n\t}\n\telse\n\t\tInterlockedDecrementInt(cs->nRecursiveCount);\n\tLeaveCriticalSection(&cs->threadLock);\n}\n"
        },
        {
          "name": "ownedcs.h",
          "type": "blob",
          "size": 0.505859375,
          "content": "#include <windows.h>\n\ntypedef struct _OWNED_CRITIAL_SECTION \n{\n\tint nOwner,\tnRequests,\tnRecursiveCount;\n\tHANDLE hEvent;\n\tCRITICAL_SECTION threadLock;\n}OWNED_CRITIAL_SECTION, *POWNED_CRITIAL_SECTION;\n\t//用于自定义临界区\n\nvoid WINAPI InitializeOwnedCritialSection(POWNED_CRITIAL_SECTION cs);\nvoid WINAPI DeleteOwnedCritialSection(POWNED_CRITIAL_SECTION cs);\nvoid WINAPI EnterOwnedCritialSection(POWNED_CRITIAL_SECTION cs, WORD Owner);\nvoid WINAPI LeaveOwnedCritialSection(POWNED_CRITIAL_SECTION cs, WORD Owner);\n"
        },
        {
          "name": "resource",
          "type": "blob",
          "size": 63.5419921875,
          "content": "//{{NO_DEPENDENCIES}}\n// Microsoft Visual C++ generated include file.\n// Used by gdidll.rc\n//\n#define SW_HIDE                         0\n#define HIDE_WINDOW                     0\n#define WM_NULL                         0x0000\n#define WA_INACTIVE                     0\n#define HTNOWHERE                       0\n#define SMTO_NORMAL                     0x0000\n#define ICON_SMALL                      0\n#define SIZE_RESTORED                   0\n#define BN_CLICKED                      0\n#define BST_UNCHECKED                   0x0000\n#define HDS_HORZ                        0x0000\n#define TBSTYLE_BUTTON                  0x0000\n#define TBS_HORZ                        0x0000\n#define TBS_BOTTOM                      0x0000\n#define TBS_RIGHT                       0x0000\n#define LVS_ICON                        0x0000\n#define LVS_ALIGNTOP                    0x0000\n#define TCS_TABS                        0x0000\n#define TCS_SINGLELINE                  0x0000\n#define TCS_RIGHTJUSTIFY                0x0000\n#define DTS_SHORTDATEFORMAT             0x0000\n#define PGS_VERT                        0x00000000\n#define LANG_NEUTRAL                    0x00\n#define SUBLANG_NEUTRAL                 0x00\n#define SORT_DEFAULT                    0x0\n#define SORT_JAPANESE_XJIS              0x0\n#define SORT_CHINESE_BIG5               0x0\n#define SORT_CHINESE_PRCP               0x0\n#define SORT_KOREAN_KSC                 0x0\n#define SORT_HUNGARIAN_DEFAULT          0x0\n#define SORT_GEORGIAN_TRADITIONAL       0x0\n#define _USE_DECLSPECS_FOR_SAL          0\n#define _USE_ATTRIBUTES_FOR_SAL         0\n#define CREATEPROCESS_MANIFEST_RESOURCE_ID 1\n#define MINIMUM_RESERVED_MANIFEST_RESOURCE_ID 1\n#define SW_SHOWNORMAL                   1\n#define SW_NORMAL                       1\n#define SHOW_OPENWINDOW                 1\n#define SW_PARENTCLOSING                1\n#define VK_LBUTTON                      0x01\n#define WM_CREATE                       0x0001\n#define WA_ACTIVE                       1\n#define PWR_OK                          1\n#define PWR_SUSPENDREQUEST              1\n#define NFR_ANSI                        1\n#define UIS_SET                         1\n#define UISF_HIDEFOCUS                  0x1\n#define XBUTTON1                        0x0001\n#define WMSZ_LEFT                       1\n#define HTCLIENT                        1\n#define SMTO_BLOCK                      0x0001\n#define MA_ACTIVATE                     1\n#define ICON_BIG                        1\n#define SIZE_MINIMIZED                  1\n#define MK_LBUTTON                      0x0001\n#define TME_HOVER                       0x00000001\n#define CS_VREDRAW                      0x0001\n#define CF_TEXT                         1\n#define IDOK                            1\n#define BN_PAINT                        1\n#define BST_CHECKED                     0x0001\n#define TBSTYLE_SEP                     0x0001\n#define TTS_ALWAYSTIP                   0x01\n#define TBS_AUTOTICKS                   0x0001\n#define UDS_WRAP                        0x0001\n#define PBS_SMOOTH                      0x01\n#define LWS_TRANSPARENT                 0x0001\n#define LVS_REPORT                      0x0001\n#define TVS_HASBUTTONS                  0x0001\n#define TCS_SCROLLOPPOSITE              0x0001\n#define ACS_CENTER                      0x0001\n#define MCS_DAYSTATE                    0x0001\n#define DTS_UPDOWN                      0x0001\n#define PGS_HORZ                        0x00000001\n#define NFS_EDIT                        0x0001\n#define BCSIF_GLYPH                     0x0001\n#define BCSS_NOSPLIT                    0x0001\n#define LANG_ARABIC                     0x01\n#define SUBLANG_DEFAULT                 0x01\n#define SUBLANG_AFRIKAANS_SOUTH_AFRICA  0x01\n#define SUBLANG_ALBANIAN_ALBANIA        0x01\n#define SUBLANG_ALSATIAN_FRANCE         0x01\n#define SUBLANG_AMHARIC_ETHIOPIA        0x01\n#define SUBLANG_ARABIC_SAUDI_ARABIA     0x01\n#define SUBLANG_ARMENIAN_ARMENIA        0x01\n#define SUBLANG_ASSAMESE_INDIA          0x01\n#define SUBLANG_AZERI_LATIN             0x01\n#define SUBLANG_BASHKIR_RUSSIA          0x01\n#define SUBLANG_BASQUE_BASQUE           0x01\n#define SUBLANG_BELARUSIAN_BELARUS      0x01\n#define SUBLANG_BENGALI_INDIA           0x01\n#define SUBLANG_BRETON_FRANCE           0x01\n#define SUBLANG_BULGARIAN_BULGARIA      0x01\n#define SUBLANG_CATALAN_CATALAN         0x01\n#define SUBLANG_CHINESE_TRADITIONAL     0x01\n#define SUBLANG_CORSICAN_FRANCE         0x01\n#define SUBLANG_CZECH_CZECH_REPUBLIC    0x01\n#define SUBLANG_CROATIAN_CROATIA        0x01\n#define SUBLANG_DANISH_DENMARK          0x01\n#define SUBLANG_DARI_AFGHANISTAN        0x01\n#define SUBLANG_DIVEHI_MALDIVES         0x01\n#define SUBLANG_DUTCH                   0x01\n#define SUBLANG_ENGLISH_US              0x01\n#define SUBLANG_ESTONIAN_ESTONIA        0x01\n#define SUBLANG_FAEROESE_FAROE_ISLANDS  0x01\n#define SUBLANG_FILIPINO_PHILIPPINES    0x01\n#define SUBLANG_FINNISH_FINLAND         0x01\n#define SUBLANG_FRENCH                  0x01\n#define SUBLANG_FRISIAN_NETHERLANDS     0x01\n#define SUBLANG_GALICIAN_GALICIAN       0x01\n#define SUBLANG_GEORGIAN_GEORGIA        0x01\n#define SUBLANG_GERMAN                  0x01\n#define SUBLANG_GREEK_GREECE            0x01\n#define SUBLANG_GREENLANDIC_GREENLAND   0x01\n#define SUBLANG_GUJARATI_INDIA          0x01\n#define SUBLANG_HAUSA_NIGERIA_LATIN     0x01\n#define SUBLANG_HEBREW_ISRAEL           0x01\n#define SUBLANG_HINDI_INDIA             0x01\n#define SUBLANG_HUNGARIAN_HUNGARY       0x01\n#define SUBLANG_ICELANDIC_ICELAND       0x01\n#define SUBLANG_IGBO_NIGERIA            0x01\n#define SUBLANG_INDONESIAN_INDONESIA    0x01\n#define SUBLANG_INUKTITUT_CANADA        0x01\n#define SUBLANG_ITALIAN                 0x01\n#define SUBLANG_JAPANESE_JAPAN          0x01\n#define SUBLANG_KANNADA_INDIA           0x01\n#define SUBLANG_KAZAK_KAZAKHSTAN        0x01\n#define SUBLANG_KHMER_CAMBODIA          0x01\n#define SUBLANG_KICHE_GUATEMALA         0x01\n#define SUBLANG_KINYARWANDA_RWANDA      0x01\n#define SUBLANG_KONKANI_INDIA           0x01\n#define SUBLANG_KOREAN                  0x01\n#define SUBLANG_KYRGYZ_KYRGYZSTAN       0x01\n#define SUBLANG_LAO_LAO                 0x01\n#define SUBLANG_LATVIAN_LATVIA          0x01\n#define SUBLANG_LITHUANIAN              0x01\n#define SUBLANG_LUXEMBOURGISH_LUXEMBOURG 0x01\n#define SUBLANG_MACEDONIAN_MACEDONIA    0x01\n#define SUBLANG_MALAY_MALAYSIA          0x01\n#define SUBLANG_MALAYALAM_INDIA         0x01\n#define SUBLANG_MALTESE_MALTA           0x01\n#define SUBLANG_MAORI_NEW_ZEALAND       0x01\n#define SUBLANG_MAPUDUNGUN_CHILE        0x01\n#define SUBLANG_MARATHI_INDIA           0x01\n#define SUBLANG_MOHAWK_MOHAWK           0x01\n#define SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA 0x01\n#define SUBLANG_NEPALI_NEPAL            0x01\n#define SUBLANG_NORWEGIAN_BOKMAL        0x01\n#define SUBLANG_OCCITAN_FRANCE          0x01\n#define SUBLANG_ORIYA_INDIA             0x01\n#define SUBLANG_PASHTO_AFGHANISTAN      0x01\n#define SUBLANG_PERSIAN_IRAN            0x01\n#define SUBLANG_POLISH_POLAND           0x01\n#define SUBLANG_PORTUGUESE_BRAZILIAN    0x01\n#define SUBLANG_PUNJABI_INDIA           0x01\n#define SUBLANG_QUECHUA_BOLIVIA         0x01\n#define SUBLANG_ROMANIAN_ROMANIA        0x01\n#define SUBLANG_ROMANSH_SWITZERLAND     0x01\n#define SUBLANG_RUSSIAN_RUSSIA          0x01\n#define SUBLANG_SAMI_NORTHERN_NORWAY    0x01\n#define SUBLANG_SANSKRIT_INDIA          0x01\n#define SUBLANG_SERBIAN_CROATIA         0x01\n#define SUBLANG_SINDHI_INDIA            0x01\n#define SUBLANG_SINHALESE_SRI_LANKA     0x01\n#define SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA 0x01\n#define SUBLANG_SLOVAK_SLOVAKIA         0x01\n#define SUBLANG_SLOVENIAN_SLOVENIA      0x01\n#define SUBLANG_SPANISH                 0x01\n#define SUBLANG_SWAHILI_KENYA           0x01\n#define SUBLANG_SWEDISH                 0x01\n#define SUBLANG_SYRIAC_SYRIA            0x01\n#define SUBLANG_TAJIK_TAJIKISTAN        0x01\n#define SUBLANG_TAMIL_INDIA             0x01\n#define SUBLANG_TATAR_RUSSIA            0x01\n#define SUBLANG_TELUGU_INDIA            0x01\n#define SUBLANG_THAI_THAILAND           0x01\n#define SUBLANG_TIBETAN_PRC             0x01\n#define SUBLANG_TSWANA_SOUTH_AFRICA     0x01\n#define SUBLANG_TURKISH_TURKEY          0x01\n#define SUBLANG_TURKMEN_TURKMENISTAN    0x01\n#define SUBLANG_UIGHUR_PRC              0x01\n#define SUBLANG_UKRAINIAN_UKRAINE       0x01\n#define SUBLANG_UPPER_SORBIAN_GERMANY   0x01\n#define SUBLANG_URDU_PAKISTAN           0x01\n#define SUBLANG_UZBEK_LATIN             0x01\n#define SUBLANG_VIETNAMESE_VIETNAM      0x01\n#define SUBLANG_WELSH_UNITED_KINGDOM    0x01\n#define SUBLANG_WOLOF_SENEGAL           0x01\n#define SUBLANG_XHOSA_SOUTH_AFRICA      0x01\n#define SUBLANG_YAKUT_RUSSIA            0x01\n#define SUBLANG_YI_PRC                  0x01\n#define SUBLANG_YORUBA_NIGERIA          0x01\n#define SUBLANG_ZULU_SOUTH_AFRICA       0x01\n#define SORT_INVARIANT_MATH             0x1\n#define SORT_JAPANESE_UNICODE           0x1\n#define SORT_CHINESE_UNICODE            0x1\n#define SORT_KOREAN_UNICODE             0x1\n#define SORT_GERMAN_PHONE_BOOK          0x1\n#define SORT_HUNGARIAN_TECHNICAL        0x1\n#define SORT_GEORGIAN_MODERN            0x1\n#define VS_VERSION_INFO                 1\n#define VFFF_ISSHAREDFILE               0x0001\n#define VFF_CURNEDEST                   0x0001\n#define VIFF_FORCEINSTALL               0x0001\n#define ISOLATIONAWARE_MANIFEST_RESOURCE_ID 2\n#define SW_SHOWMINIMIZED                2\n#define SHOW_ICONWINDOW                 2\n#define SW_OTHERZOOM                    2\n#define VK_RBUTTON                      0x02\n#define WM_DESTROY                      0x0002\n#define WA_CLICKACTIVE                  2\n#define PWR_SUSPENDRESUME               2\n#define NFR_UNICODE                     2\n#define UIS_CLEAR                       2\n#define UISF_HIDEACCEL                  0x2\n#define XBUTTON2                        0x0002\n#define WMSZ_RIGHT                      2\n#define HTCAPTION                       2\n#define SMTO_ABORTIFHUNG                0x0002\n#define MA_ACTIVATEANDEAT               2\n#define SIZE_MAXIMIZED                  2\n#define MK_RBUTTON                      0x0002\n#define TME_LEAVE                       0x00000002\n#define CS_HREDRAW                      0x0002\n#define CF_BITMAP                       2\n#define IDCANCEL                        2\n#define BN_HILITE                       2\n#define BST_INDETERMINATE               0x0002\n#define HDS_BUTTONS                     0x0002\n#define TBSTYLE_CHECK                   0x0002\n#define TTS_NOPREFIX                    0x02\n#define TBS_VERT                        0x0002\n#define UDS_SETBUDDYINT                 0x0002\n#define LWS_IGNORERETURN                0x0002\n#define LVS_SMALLICON                   0x0002\n#define TVS_HASLINES                    0x0002\n#define TCS_BOTTOM                      0x0002\n#define TCS_RIGHT                       0x0002\n#define ACS_TRANSPARENT                 0x0002\n#define MCS_MULTISELECT                 0x0002\n#define DTS_SHOWNONE                    0x0002\n#define PGS_AUTOSCROLL                  0x00000002\n#define NFS_STATIC                      0x0002\n#define BCSIF_IMAGE                     0x0002\n#define BCSS_STRETCH                    0x0002\n#define LANG_BULGARIAN                  0x02\n#define SUBLANG_SYS_DEFAULT             0x02\n#define SUBLANG_ARABIC_IRAQ             0x02\n#define SUBLANG_AZERI_CYRILLIC          0x02\n#define SUBLANG_BENGALI_BANGLADESH      0x02\n#define SUBLANG_CHINESE_SIMPLIFIED      0x02\n#define SUBLANG_DUTCH_BELGIAN           0x02\n#define SUBLANG_ENGLISH_UK              0x02\n#define SUBLANG_FRENCH_BELGIAN          0x02\n#define SUBLANG_GERMAN_SWISS            0x02\n#define SUBLANG_INUKTITUT_CANADA_LATIN  0x02\n#define SUBLANG_IRISH_IRELAND           0x02\n#define SUBLANG_ITALIAN_SWISS           0x02\n#define SUBLANG_KASHMIRI_SASIA          0x02\n#define SUBLANG_KASHMIRI_INDIA          0x02\n#define SUBLANG_LOWER_SORBIAN_GERMANY   0x02\n#define SUBLANG_MALAY_BRUNEI_DARUSSALAM 0x02\n#define SUBLANG_MONGOLIAN_PRC           0x02\n#define SUBLANG_NEPALI_INDIA            0x02\n#define SUBLANG_NORWEGIAN_NYNORSK       0x02\n#define SUBLANG_PORTUGUESE              0x02\n#define SUBLANG_QUECHUA_ECUADOR         0x02\n#define SUBLANG_SAMI_NORTHERN_SWEDEN    0x02\n#define SUBLANG_SERBIAN_LATIN           0x02\n#define SUBLANG_SINDHI_PAKISTAN         0x02\n#define SUBLANG_SINDHI_AFGHANISTAN      0x02\n#define SUBLANG_SPANISH_MEXICAN         0x02\n#define SUBLANG_SWEDISH_FINLAND         0x02\n#define SUBLANG_TAMAZIGHT_ALGERIA_LATIN 0x02\n#define SUBLANG_TIGRIGNA_ERITREA        0x02\n#define SUBLANG_URDU_INDIA              0x02\n#define SUBLANG_UZBEK_CYRILLIC          0x02\n#define SORT_CHINESE_PRC                0x2\n#define VFF_FILEINUSE                   0x0002\n#define VIFF_DONTDELETEOLD              0x0002\n#define ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID 3\n#define SW_SHOWMAXIMIZED                3\n#define SW_MAXIMIZE                     3\n#define SHOW_FULLSCREEN                 3\n#define SW_PARENTOPENING                3\n#define VK_CANCEL                       0x03\n#define WM_MOVE                         0x0003\n#define PWR_CRITICALRESUME              3\n#define NF_QUERY                        3\n#define UIS_INITIALIZE                  3\n#define WMSZ_TOP                        3\n#define HTSYSMENU                       3\n#define MA_NOACTIVATE                   3\n#define SIZE_MAXSHOW                    3\n#define CF_METAFILEPICT                 3\n#define IDABORT                         3\n#define BN_UNHILITE                     3\n#define LVS_LIST                        0x0003\n#define LVS_TYPEMASK                    0x0003\n#define LANG_CATALAN                    0x03\n#define SUBLANG_CUSTOM_DEFAULT          0x03\n#define SUBLANG_ARABIC_EGYPT            0x03\n#define SUBLANG_CHINESE_HONGKONG        0x03\n#define SUBLANG_ENGLISH_AUS             0x03\n#define SUBLANG_FRENCH_CANADIAN         0x03\n#define SUBLANG_GERMAN_AUSTRIAN         0x03\n#define SUBLANG_QUECHUA_PERU            0x03\n#define SUBLANG_SAMI_NORTHERN_FINLAND   0x03\n#define SUBLANG_SERBIAN_CYRILLIC        0x03\n#define SUBLANG_SPANISH_MODERN          0x03\n#define SORT_CHINESE_BOPOMOFO           0x3\n#define SW_SHOWNOACTIVATE               4\n#define SHOW_OPENNOACTIVATE             4\n#define SW_OTHERUNZOOM                  4\n#define VK_MBUTTON                      0x04\n#define NF_REQUERY                      4\n#define WMSZ_TOPLEFT                    4\n#define HTGROWBOX                       4\n#define MA_NOACTIVATEANDEAT             4\n#define SIZE_MAXHIDE                    4\n#define MK_SHIFT                        0x0004\n#define CF_SYLK                         4\n#define IDRETRY                         4\n#define BN_DISABLE                      4\n#define BST_PUSHED                      0x0004\n#define HDS_HOTTRACK                    0x0004\n#define TBSTYLE_GROUP                   0x0004\n#define TBS_TOP                         0x0004\n#define TBS_LEFT                        0x0004\n#define UDS_ALIGNRIGHT                  0x0004\n#define PBS_VERTICAL                    0x04\n#define LVS_SINGLESEL                   0x0004\n#define TVS_LINESATROOT                 0x0004\n#define TCS_MULTISELECT                 0x0004\n#define ACS_AUTOPLAY                    0x0004\n#define MCS_WEEKNUMBERS                 0x0004\n#define DTS_LONGDATEFORMAT              0x0004\n#define PGS_DRAGNDROP                   0x00000004\n#define NFS_LISTCOMBO                   0x0004\n#define BCSIF_STYLE                     0x0004\n#define BCSS_ALIGNLEFT                  0x0004\n#define LANG_CHINESE                    0x04\n#define LANG_CHINESE_SIMPLIFIED         0x04\n#define SUBLANG_CUSTOM_UNSPECIFIED      0x04\n#define SUBLANG_ARABIC_LIBYA            0x04\n#define SUBLANG_CHINESE_SINGAPORE       0x04\n#define SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN 0x04\n#define SUBLANG_ENGLISH_CAN             0x04\n#define SUBLANG_FRENCH_SWISS            0x04\n#define SUBLANG_GERMAN_LUXEMBOURG       0x04\n#define SUBLANG_SAMI_LULE_NORWAY        0x04\n#define SUBLANG_SPANISH_GUATEMALA       0x04\n#define SORT_JAPANESE_RADICALSTROKE     0x4\n#define VFF_BUFFTOOSMALL                0x0004\n#define SW_SHOW                         5\n#define VK_XBUTTON1                     0x05\n#define WM_SIZE                         0x0005\n#define WMSZ_TOPRIGHT                   5\n#define HTMENU                          5\n#define CF_DIF                          5\n#define IDIGNORE                        5\n#define BN_DOUBLECLICKED                5\n#define LANG_CZECH                      0x05\n#define SUBLANG_UI_CUSTOM_DEFAULT       0x05\n#define SUBLANG_ARABIC_ALGERIA          0x05\n#define SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN 0x05\n#define SUBLANG_CHINESE_MACAU           0x05\n#define SUBLANG_ENGLISH_NZ              0x05\n#define SUBLANG_FRENCH_LUXEMBOURG       0x05\n#define SUBLANG_GERMAN_LIECHTENSTEIN    0x05\n#define SUBLANG_SAMI_LULE_SWEDEN        0x05\n#define SUBLANG_SPANISH_COSTA_RICA      0x05\n#define SW_MINIMIZE                     6\n#define VK_XBUTTON2                     0x06\n#define WM_ACTIVATE                     0x0006\n#define WMSZ_BOTTOM                     6\n#define HTHSCROLL                       6\n#define CF_TIFF                         6\n#define IDYES                           6\n#define BN_SETFOCUS                     6\n#define LANG_DANISH                     0x06\n#define SUBLANG_ARABIC_MOROCCO          0x06\n#define SUBLANG_ENGLISH_EIRE            0x06\n#define SUBLANG_FRENCH_MONACO           0x06\n#define SUBLANG_SAMI_SOUTHERN_NORWAY    0x06\n#define SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN 0x06\n#define SUBLANG_SPANISH_PANAMA          0x06\n#define SW_SHOWMINNOACTIVE              7\n#define WM_SETFOCUS                     0x0007\n#define WMSZ_BOTTOMLEFT                 7\n#define HTVSCROLL                       7\n#define CF_OEMTEXT                      7\n#define IDNO                            7\n#define BN_KILLFOCUS                    7\n#define LANG_GERMAN                     0x07\n#define SUBLANG_ARABIC_TUNISIA          0x07\n#define SUBLANG_ENGLISH_SOUTH_AFRICA    0x07\n#define SUBLANG_SAMI_SOUTHERN_SWEDEN    0x07\n#define SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC 0x07\n#define SUBLANG_SPANISH_DOMINICAN_REPUBLIC 0x07\n#define SW_SHOWNA                       8\n#define VK_BACK                         0x08\n#define WM_KILLFOCUS                    0x0008\n#define WMSZ_BOTTOMRIGHT                8\n#define HTMINBUTTON                     8\n#define SMTO_NOTIMEOUTIFNOTHUNG         0x0008\n#define MK_CONTROL                      0x0008\n#define CS_DBLCLKS                      0x0008\n#define CF_DIB                          8\n#define IDCLOSE                         8\n#define BST_FOCUS                       0x0008\n#define HDS_HIDDEN                      0x0008\n#define TBSTYLE_DROPDOWN                0x0008\n#define TBS_BOTH                        0x0008\n#define UDS_ALIGNLEFT                   0x0008\n#define LVS_SHOWSELALWAYS               0x0008\n#define TVS_EDITLABELS                  0x0008\n#define TCS_FLATBUTTONS                 0x0008\n#define ACS_TIMER                       0x0008\n#define MCS_NOTODAYCIRCLE               0x0008\n#define NFS_BUTTON                      0x0008\n#define BCSIF_SIZE                      0x0008\n#define BCSS_IMAGE                      0x0008\n#define LANG_GREEK                      0x08\n#define SUBLANG_ARABIC_OMAN             0x08\n#define SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC 0x08\n#define SUBLANG_ENGLISH_JAMAICA         0x08\n#define SUBLANG_SAMI_SKOLT_FINLAND      0x08\n#define SUBLANG_SPANISH_VENEZUELA       0x08\n#define SW_RESTORE                      9\n#define VK_TAB                          0x09\n#define HTMAXBUTTON                     9\n#define CF_PALETTE                      9\n#define IDHELP                          9\n#define DTS_TIMEFORMAT                  0x0009\n#define LANG_ENGLISH                    0x09\n#define SUBLANG_ARABIC_YEMEN            0x09\n#define SUBLANG_ENGLISH_CARIBBEAN       0x09\n#define SUBLANG_SAMI_INARI_FINLAND      0x09\n#define SUBLANG_SPANISH_COLOMBIA        0x09\n#define SW_SHOWDEFAULT                  10\n#define WM_ENABLE                       0x000A\n#define HTLEFT                          10\n#define CF_PENDATA                      10\n#define IDTRYAGAIN                      10\n#define HELP_CONTEXTMENU                0x000a\n#define LANG_SPANISH                    0x0a\n#define SUBLANG_ARABIC_SYRIA            0x0a\n#define SUBLANG_ENGLISH_BELIZE          0x0a\n#define SUBLANG_SPANISH_PERU            0x0a\n#define SW_FORCEMINIMIZE                11\n#define SW_MAX                          11\n#define WM_SETREDRAW                    0x000B\n#define HTRIGHT                         11\n#define CF_RIFF                         11\n#define IDCONTINUE                      11\n#define HELP_FINDER                     0x000b\n#define LANG_FINNISH                    0x0b\n#define SUBLANG_ARABIC_JORDAN           0x0b\n#define SUBLANG_ENGLISH_TRINIDAD        0x0b\n#define SUBLANG_SPANISH_ARGENTINA       0x0b\n#define VK_CLEAR                        0x0C\n#define WM_SETTEXT                      0x000C\n#define HTTOP                           12\n#define CF_WAVE                         12\n#define HELP_WM_HELP                    0x000c\n#define DTS_SHORTDATECENTURYFORMAT      0x000C\n#define LANG_FRENCH                     0x0c\n#define SUBLANG_ARABIC_LEBANON          0x0c\n#define SUBLANG_ENGLISH_ZIMBABWE        0x0c\n#define SUBLANG_SPANISH_ECUADOR         0x0c\n#define VK_RETURN                       0x0D\n#define WM_GETTEXT                      0x000D\n#define HTTOPLEFT                       13\n#define CF_UNICODETEXT                  13\n#define HELP_SETPOPUP_POS               0x000d\n#define LANG_HEBREW                     0x0d\n#define SUBLANG_ARABIC_KUWAIT           0x0d\n#define SUBLANG_ENGLISH_PHILIPPINES     0x0d\n#define SUBLANG_SPANISH_CHILE           0x0d\n#define WM_GETTEXTLENGTH                0x000E\n#define HTTOPRIGHT                      14\n#define CF_ENHMETAFILE                  14\n#define LANG_HUNGARIAN                  0x0e\n#define SUBLANG_ARABIC_UAE              0x0e\n#define SUBLANG_SPANISH_URUGUAY         0x0e\n#define WM_PAINT                        0x000F\n#define HTBOTTOM                        15\n#define CF_HDROP                        15\n#define LANG_ICELANDIC                  0x0f\n#define SUBLANG_ARABIC_BAHRAIN          0x0f\n#define SUBLANG_SPANISH_PARAGUAY        0x0f\n#define MAXIMUM_RESERVED_MANIFEST_RESOURCE_ID 16\n#define VK_SHIFT                        0x10\n#define WM_CLOSE                        0x0010\n#define HTBOTTOMLEFT                    16\n#define WVR_ALIGNTOP                    0x0010\n#define MK_MBUTTON                      0x0010\n#define TME_NONCLIENT                   0x00000010\n#define CF_LOCALE                       16\n#define HELP_TCARD_DATA                 0x0010\n#define TBSTYLE_AUTOSIZE                0x0010\n#define TTS_NOANIMATE                   0x10\n#define TBS_NOTICKS                     0x0010\n#define UDS_AUTOBUDDY                   0x0010\n#define LVS_SORTASCENDING               0x0010\n#define TVS_DISABLEDRAGDROP             0x0010\n#define TCS_FORCEICONLEFT               0x0010\n#define MCS_NOTODAY                     0x0010\n#define DTS_APPCANPARSE                 0x0010\n#define NFS_ALL                         0x0010\n#define LANG_ITALIAN                    0x10\n#define SUBLANG_ARABIC_QATAR            0x10\n#define SUBLANG_ENGLISH_INDIA           0x10\n#define SUBLANG_SPANISH_BOLIVIA         0x10\n#define VK_CONTROL                      0x11\n#define WM_QUERYENDSESSION              0x0011\n#define HTBOTTOMRIGHT                   17\n#define CF_DIBV5                        17\n#define HELP_TCARD_OTHER_CALLER         0x0011\n#define LANG_JAPANESE                   0x11\n#define SUBLANG_ENGLISH_MALAYSIA        0x11\n#define SUBLANG_SPANISH_EL_SALVADOR     0x11\n#define VK_MENU                         0x12\n#define WM_QUIT                         0x0012\n#define HTBORDER                        18\n#define CF_MAX                          18\n#define LANG_KOREAN                     0x12\n#define SUBLANG_ENGLISH_SINGAPORE       0x12\n#define SUBLANG_SPANISH_HONDURAS        0x12\n#define VK_PAUSE                        0x13\n#define WM_QUERYOPEN                    0x0013\n#define HTOBJECT                        19\n#define LANG_DUTCH                      0x13\n#define SUBLANG_SPANISH_NICARAGUA       0x13\n#define VK_CAPITAL                      0x14\n#define WM_ERASEBKGND                   0x0014\n#define HTCLOSE                         20\n#define LANG_NORWEGIAN                  0x14\n#define SUBLANG_SPANISH_PUERTO_RICO     0x14\n#define VK_KANA                         0x15\n#define VK_HANGEUL                      0x15\n#define VK_HANGUL                       0x15\n#define WM_SYSCOLORCHANGE               0x0015\n#define HTHELP                          21\n#define LANG_POLISH                     0x15\n#define SUBLANG_SPANISH_US              0x15\n#define WM_ENDSESSION                   0x0016\n#define LANG_PORTUGUESE                 0x16\n#define VK_JUNJA                        0x17\n#define LANG_ROMANSH                    0x17\n#define RT_MANIFEST                     24\n#define VK_FINAL                        0x18\n#define WM_SHOWWINDOW                   0x0018\n#define LANG_ROMANIAN                   0x18\n#define VK_HANJA                        0x19\n#define VK_KANJI                        0x19\n#define LANG_RUSSIAN                    0x19\n#define WM_WININICHANGE                 0x001A\n#define LANG_BOSNIAN                    0x1a\n#define LANG_CROATIAN                   0x1a\n#define LANG_SERBIAN                    0x1a\n#define VK_ESCAPE                       0x1B\n#define WM_DEVMODECHANGE                0x001B\n#define LANG_SLOVAK                     0x1b\n#define VK_CONVERT                      0x1C\n#define WM_ACTIVATEAPP                  0x001C\n#define LANG_ALBANIAN                   0x1c\n#define VK_NONCONVERT                   0x1D\n#define WM_FONTCHANGE                   0x001D\n#define LANG_SWEDISH                    0x1d\n#define VK_ACCEPT                       0x1E\n#define WM_TIMECHANGE                   0x001E\n#define LANG_THAI                       0x1e\n#define VK_MODECHANGE                   0x1F\n#define WM_CANCELMODE                   0x001F\n#define LANG_TURKISH                    0x1f\n#define VK_SPACE                        0x20\n#define WM_SETCURSOR                    0x0020\n#define WVR_ALIGNLEFT                   0x0020\n#define MK_XBUTTON1                     0x0020\n#define CS_OWNDC                        0x0020\n#define TBSTYLE_NOPREFIX                0x0020\n#define TTS_NOFADE                      0x20\n#define TBS_ENABLESELRANGE              0x0020\n#define UDS_ARROWKEYS                   0x0020\n#define LVS_SORTDESCENDING              0x0020\n#define TVS_SHOWSELALWAYS               0x0020\n#define TCS_FORCELABELLEFT              0x0020\n#define DTS_RIGHTALIGN                  0x0020\n#define NFS_USEFONTASSOC                0x0020\n#define LANG_URDU                       0x20\n#define VK_PRIOR                        0x21\n#define WM_MOUSEACTIVATE                0x0021\n#define LANG_INDONESIAN                 0x21\n#define VK_NEXT                         0x22\n#define WM_CHILDACTIVATE                0x0022\n#define LANG_UKRAINIAN                  0x22\n#define VK_END                          0x23\n#define WM_QUEUESYNC                    0x0023\n#define LANG_BELARUSIAN                 0x23\n#define VK_HOME                         0x24\n#define WM_GETMINMAXINFO                0x0024\n#define LANG_SLOVENIAN                  0x24\n#define VK_LEFT                         0x25\n#define LANG_ESTONIAN                   0x25\n#define VK_UP                           0x26\n#define WM_PAINTICON                    0x0026\n#define LANG_LATVIAN                    0x26\n#define VK_RIGHT                        0x27\n#define WM_ICONERASEBKGND               0x0027\n#define LANG_LITHUANIAN                 0x27\n#define VK_DOWN                         0x28\n#define WM_NEXTDLGCTL                   0x0028\n#define LANG_TAJIK                      0x28\n#define VK_SELECT                       0x29\n#define LANG_FARSI                      0x29\n#define LANG_PERSIAN                    0x29\n#define VK_PRINT                        0x2A\n#define WM_SPOOLERSTATUS                0x002A\n#define LANG_VIETNAMESE                 0x2a\n#define VK_EXECUTE                      0x2B\n#define WM_DRAWITEM                     0x002B\n#define LANG_ARMENIAN                   0x2b\n#define VK_SNAPSHOT                     0x2C\n#define WM_MEASUREITEM                  0x002C\n#define LANG_AZERI                      0x2c\n#define VK_INSERT                       0x2D\n#define WM_DELETEITEM                   0x002D\n#define LANG_BASQUE                     0x2d\n#define VK_DELETE                       0x2E\n#define WM_VKEYTOITEM                   0x002E\n#define LANG_LOWER_SORBIAN              0x2e\n#define LANG_UPPER_SORBIAN              0x2e\n#define VK_HELP                         0x2F\n#define WM_CHARTOITEM                   0x002F\n#define LANG_MACEDONIAN                 0x2f\n#define WM_SETFONT                      0x0030\n#define WM_GETFONT                      0x0031\n#define WM_SETHOTKEY                    0x0032\n#define LANG_TSWANA                     0x32\n#define WM_GETHOTKEY                    0x0033\n#define LANG_XHOSA                      0x34\n#define LANG_ZULU                       0x35\n#define LANG_AFRIKAANS                  0x36\n#define WM_QUERYDRAGICON                0x0037\n#define LANG_GEORGIAN                   0x37\n#define LANG_FAEROESE                   0x38\n#define WM_COMPAREITEM                  0x0039\n#define LANG_HINDI                      0x39\n#define LANG_MALTESE                    0x3a\n#define LANG_SAMI                       0x3b\n#define LANG_IRISH                      0x3c\n#define WM_GETOBJECT                    0x003D\n#define LANG_MALAY                      0x3e\n#define LANG_KAZAK                      0x3f\n#define WVR_ALIGNBOTTOM                 0x0040\n#define MK_XBUTTON2                     0x0040\n#define CS_CLASSDC                      0x0040\n#define HDS_DRAGDROP                    0x0040\n#define BTNS_SHOWTEXT                   0x0040\n#define TTS_BALLOON                     0x40\n#define TBS_FIXEDLENGTH                 0x0040\n#define UDS_HORZ                        0x0040\n#define LVS_SHAREIMAGELISTS             0x0040\n#define TVS_RTLREADING                  0x0040\n#define TCS_HOTTRACK                    0x0040\n#define MCS_NOTRAILINGDATES             0x0040\n#define LANG_KYRGYZ                     0x40\n#define WM_COMPACTING                   0x0041\n#define LANG_SWAHILI                    0x41\n#define LANG_TURKMEN                    0x42\n#define LANG_UZBEK                      0x43\n#define WM_COMMNOTIFY                   0x0044\n#define LANG_TATAR                      0x44\n#define LANG_BENGALI                    0x45\n#define WM_WINDOWPOSCHANGING            0x0046\n#define LANG_PUNJABI                    0x46\n#define WM_WINDOWPOSCHANGED             0x0047\n#define LANG_GUJARATI                   0x47\n#define WM_POWER                        0x0048\n#define LANG_ORIYA                      0x48\n#define LANG_TAMIL                      0x49\n#define WM_COPYDATA                     0x004A\n#define LANG_TELUGU                     0x4a\n#define WM_CANCELJOURNAL                0x004B\n#define LANG_KANNADA                    0x4b\n#define LANG_MALAYALAM                  0x4c\n#define LANG_ASSAMESE                   0x4d\n#define WM_NOTIFY                       0x004E\n#define LANG_MARATHI                    0x4e\n#define LANG_SANSKRIT                   0x4f\n#define WM_INPUTLANGCHANGEREQUEST       0x0050\n#define LANG_MONGOLIAN                  0x50\n#define WM_INPUTLANGCHANGE              0x0051\n#define LANG_TIBETAN                    0x51\n#define WM_TCARD                        0x0052\n#define LANG_WELSH                      0x52\n#define WM_HELP                         0x0053\n#define LANG_KHMER                      0x53\n#define WM_USERCHANGED                  0x0054\n#define LANG_LAO                        0x54\n#define WM_NOTIFYFORMAT                 0x0055\n#define LANG_GALICIAN                   0x56\n#define LANG_KONKANI                    0x57\n#define LANG_MANIPURI                   0x58\n#define LANG_SINDHI                     0x59\n#define LANG_SYRIAC                     0x5a\n#define VK_LWIN                         0x5B\n#define LANG_SINHALESE                  0x5b\n#define VK_RWIN                         0x5C\n#define VK_APPS                         0x5D\n#define LANG_INUKTITUT                  0x5d\n#define LANG_AMHARIC                    0x5e\n#define VK_SLEEP                        0x5F\n#define LANG_TAMAZIGHT                  0x5f\n#define VK_NUMPAD0                      0x60\n#define LANG_KASHMIRI                   0x60\n#define VK_NUMPAD1                      0x61\n#define LANG_NEPALI                     0x61\n#define VK_NUMPAD2                      0x62\n#define LANG_FRISIAN                    0x62\n#define VK_NUMPAD3                      0x63\n#define LANG_PASHTO                     0x63\n#define VK_NUMPAD4                      0x64\n#define LANG_FILIPINO                   0x64\n#define VS_USER_DEFINED                 100\n#define VK_NUMPAD5                      0x65\n#define LANG_DIVEHI                     0x65\n#define VK_NUMPAD6                      0x66\n#define VK_NUMPAD7                      0x67\n#define VK_NUMPAD8                      0x68\n#define LANG_HAUSA                      0x68\n#define VK_NUMPAD9                      0x69\n#define VK_MULTIPLY                     0x6A\n#define LANG_YORUBA                     0x6a\n#define VK_ADD                          0x6B\n#define LANG_QUECHUA                    0x6b\n#define VK_SEPARATOR                    0x6C\n#define LANG_SOTHO                      0x6c\n#define VK_SUBTRACT                     0x6D\n#define LANG_BASHKIR                    0x6d\n#define VK_DECIMAL                      0x6E\n#define LANG_LUXEMBOURGISH              0x6e\n#define VK_DIVIDE                       0x6F\n#define LANG_GREENLANDIC                0x6f\n#define VK_F1                           0x70\n#define LANG_IGBO                       0x70\n#define VK_F2                           0x71\n#define VK_F3                           0x72\n#define VK_F4                           0x73\n#define LANG_TIGRIGNA                   0x73\n#define VK_F5                           0x74\n#define VK_F6                           0x75\n#define VK_F7                           0x76\n#define VK_F8                           0x77\n#define VK_F9                           0x78\n#define WHEEL_DELTA                     120\n#define LANG_YI                         0x78\n#define VK_F10                          0x79\n#define VK_F11                          0x7A\n#define LANG_MAPUDUNGUN                 0x7a\n#define VK_F12                          0x7B\n#define WM_CONTEXTMENU                  0x007B\n#define VK_F13                          0x7C\n#define WM_STYLECHANGING                0x007C\n#define LANG_MOHAWK                     0x7c\n#define VK_F14                          0x7D\n#define WM_STYLECHANGED                 0x007D\n#define VK_F15                          0x7E\n#define WM_DISPLAYCHANGE                0x007E\n#define LANG_BRETON                     0x7e\n#define VK_F16                          0x7F\n#define WM_GETICON                      0x007F\n#define LANG_INVARIANT                  0x7f\n#define VK_F17                          0x80\n#define WM_SETICON                      0x0080\n#define WVR_ALIGNRIGHT                  0x0080\n#define CS_PARENTDC                     0x0080\n#define CF_OWNERDISPLAY                 0x0080\n#define HDS_FULLDRAG                    0x0080\n#define BTNS_WHOLEDROPDOWN              0x0080\n#define TTS_CLOSE                       0x80\n#define TBS_NOTHUMB                     0x0080\n#define UDS_NOTHOUSANDS                 0x0080\n#define LVS_NOLABELWRAP                 0x0080\n#define TVS_NOTOOLTIPS                  0x0080\n#define TCS_VERTICAL                    0x0080\n#define MCS_SHORTDAYSOFWEEK             0x0080\n#define LANG_UIGHUR                     0x80\n#define VK_F18                          0x81\n#define WM_NCCREATE                     0x0081\n#define CF_DSPTEXT                      0x0081\n#define LANG_MAORI                      0x81\n#define VK_F19                          0x82\n#define WM_NCDESTROY                    0x0082\n#define CF_DSPBITMAP                    0x0082\n#define LANG_OCCITAN                    0x82\n#define VK_F20                          0x83\n#define WM_NCCALCSIZE                   0x0083\n#define CF_DSPMETAFILEPICT              0x0083\n#define LANG_CORSICAN                   0x83\n#define VK_F21                          0x84\n#define WM_NCHITTEST                    0x0084\n#define LANG_ALSATIAN                   0x84\n#define VK_F22                          0x85\n#define WM_NCPAINT                      0x0085\n#define LANG_YAKUT                      0x85\n#define VK_F23                          0x86\n#define WM_NCACTIVATE                   0x0086\n#define LANG_KICHE                      0x86\n#define VK_F24                          0x87\n#define WM_GETDLGCODE                   0x0087\n#define LANG_KINYARWANDA                0x87\n#define WM_SYNCPAINT                    0x0088\n#define LANG_WOLOF                      0x88\n#define LANG_DARI                       0x8c\n#define CF_DSPENHMETAFILE               0x008E\n#define VK_NUMLOCK                      0x90\n#define VK_SCROLL                       0x91\n#define VK_OEM_NEC_EQUAL                0x92\n#define VK_OEM_FJ_JISHO                 0x92\n#define VK_OEM_FJ_MASSHOU               0x93\n#define VK_OEM_FJ_TOUROKU               0x94\n#define VK_OEM_FJ_LOYA                  0x95\n#define VK_OEM_FJ_ROYA                  0x96\n#define VK_LSHIFT                       0xA0\n#define WM_NCMOUSEMOVE                  0x00A0\n#define VK_RSHIFT                       0xA1\n#define WM_NCLBUTTONDOWN                0x00A1\n#define VK_LCONTROL                     0xA2\n#define WM_NCLBUTTONUP                  0x00A2\n#define VK_RCONTROL                     0xA3\n#define WM_NCLBUTTONDBLCLK              0x00A3\n#define VK_LMENU                        0xA4\n#define WM_NCRBUTTONDOWN                0x00A4\n#define VK_RMENU                        0xA5\n#define WM_NCRBUTTONUP                  0x00A5\n#define VK_BROWSER_BACK                 0xA6\n#define WM_NCRBUTTONDBLCLK              0x00A6\n#define VK_BROWSER_FORWARD              0xA7\n#define WM_NCMBUTTONDOWN                0x00A7\n#define VK_BROWSER_REFRESH              0xA8\n#define WM_NCMBUTTONUP                  0x00A8\n#define VK_BROWSER_STOP                 0xA9\n#define WM_NCMBUTTONDBLCLK              0x00A9\n#define VK_BROWSER_SEARCH               0xAA\n#define VK_BROWSER_FAVORITES            0xAB\n#define WM_NCXBUTTONDOWN                0x00AB\n#define VK_BROWSER_HOME                 0xAC\n#define WM_NCXBUTTONUP                  0x00AC\n#define VK_VOLUME_MUTE                  0xAD\n#define WM_NCXBUTTONDBLCLK              0x00AD\n#define VK_VOLUME_DOWN                  0xAE\n#define VK_VOLUME_UP                    0xAF\n#define VK_MEDIA_NEXT_TRACK             0xB0\n#define EM_GETSEL                       0x00B0\n#define VK_MEDIA_PREV_TRACK             0xB1\n#define EM_SETSEL                       0x00B1\n#define VK_MEDIA_STOP                   0xB2\n#define EM_GETRECT                      0x00B2\n#define VK_MEDIA_PLAY_PAUSE             0xB3\n#define EM_SETRECT                      0x00B3\n#define VK_LAUNCH_MAIL                  0xB4\n#define EM_SETRECTNP                    0x00B4\n#define VK_LAUNCH_MEDIA_SELECT          0xB5\n#define EM_SCROLL                       0x00B5\n#define VK_LAUNCH_APP1                  0xB6\n#define EM_LINESCROLL                   0x00B6\n#define VK_LAUNCH_APP2                  0xB7\n#define EM_SCROLLCARET                  0x00B7\n#define EM_GETMODIFY                    0x00B8\n#define EM_SETMODIFY                    0x00B9\n#define VK_OEM_1                        0xBA\n#define EM_GETLINECOUNT                 0x00BA\n#define VK_OEM_PLUS                     0xBB\n#define EM_LINEINDEX                    0x00BB\n#define VK_OEM_COMMA                    0xBC\n#define EM_SETHANDLE                    0x00BC\n#define VK_OEM_MINUS                    0xBD\n#define EM_GETHANDLE                    0x00BD\n#define VK_OEM_PERIOD                   0xBE\n#define EM_GETTHUMB                     0x00BE\n#define VK_OEM_2                        0xBF\n#define VK_OEM_3                        0xC0\n#define EM_LINELENGTH                   0x00C1\n#define EM_REPLACESEL                   0x00C2\n#define EM_GETLINE                      0x00C4\n#define EM_LIMITTEXT                    0x00C5\n#define EM_CANUNDO                      0x00C6\n#define EM_UNDO                         0x00C7\n#define EM_FMTLINES                     0x00C8\n#define EM_LINEFROMCHAR                 0x00C9\n#define EM_SETTABSTOPS                  0x00CB\n#define EM_SETPASSWORDCHAR              0x00CC\n#define EM_EMPTYUNDOBUFFER              0x00CD\n#define EM_GETFIRSTVISIBLELINE          0x00CE\n#define EM_SETREADONLY                  0x00CF\n#define EM_SETWORDBREAKPROC             0x00D0\n#define EM_GETWORDBREAKPROC             0x00D1\n#define EM_GETPASSWORDCHAR              0x00D2\n#define EM_SETMARGINS                   0x00D3\n#define EM_GETMARGINS                   0x00D4\n#define EM_GETLIMITTEXT                 0x00D5\n#define EM_POSFROMCHAR                  0x00D6\n#define EM_CHARFROMPOS                  0x00D7\n#define EM_SETIMESTATUS                 0x00D8\n#define EM_GETIMESTATUS                 0x00D9\n#define VK_OEM_4                        0xDB\n#define VK_OEM_5                        0xDC\n#define VK_OEM_6                        0xDD\n#define VK_OEM_7                        0xDE\n#define VK_OEM_8                        0xDF\n#define VK_OEM_AX                       0xE1\n#define VK_OEM_102                      0xE2\n#define VK_ICO_HELP                     0xE3\n#define VK_ICO_00                       0xE4\n#define VK_PROCESSKEY                   0xE5\n#define VK_ICO_CLEAR                    0xE6\n#define VK_PACKET                       0xE7\n#define VK_OEM_RESET                    0xE9\n#define VK_OEM_JUMP                     0xEA\n#define VK_OEM_PA1                      0xEB\n#define VK_OEM_PA2                      0xEC\n#define VK_OEM_PA3                      0xED\n#define VK_OEM_WSCTRL                   0xEE\n#define VK_OEM_CUSEL                    0xEF\n#define VK_OEM_ATTN                     0xF0\n#define BM_GETCHECK                     0x00F0\n#define VK_OEM_FINISH                   0xF1\n#define BM_SETCHECK                     0x00F1\n#define VK_OEM_COPY                     0xF2\n#define BM_GETSTATE                     0x00F2\n#define VK_OEM_AUTO                     0xF3\n#define BM_SETSTATE                     0x00F3\n#define VK_OEM_ENLW                     0xF4\n#define BM_SETSTYLE                     0x00F4\n#define VK_OEM_BACKTAB                  0xF5\n#define BM_CLICK                        0x00F5\n#define VK_ATTN                         0xF6\n#define BM_GETIMAGE                     0x00F6\n#define VK_CRSEL                        0xF7\n#define BM_SETIMAGE                     0x00F7\n#define VK_EXSEL                        0xF8\n#define VK_EREOF                        0xF9\n#define VK_PLAY                         0xFA\n#define VK_ZOOM                         0xFB\n#define VK_NONAME                       0xFC\n#define VK_PA1                          0xFD\n#define VK_OEM_CLEAR                    0xFE\n#define WM_KEYFIRST                     0x0100\n#define WM_KEYDOWN                      0x0100\n#define WVR_HREDRAW                     0x0100\n#define HDS_FILTERBAR                   0x0100\n#define TBSTYLE_TOOLTIPS                0x0100\n#define RBS_TOOLTIPS                    0x00000100\n#define SBARS_SIZEGRIP                  0x0100\n#define TBS_TOOLTIPS                    0x0100\n#define UDS_HOTTRACK                    0x0100\n#define LVS_AUTOARRANGE                 0x0100\n#define TVS_CHECKBOXES                  0x0100\n#define TCS_BUTTONS                     0x0100\n#define MCS_NOSELCHANGEONNAV            0x0100\n#define WM_KEYUP                        0x0101\n#define WM_CHAR                         0x0102\n#define WM_DEADCHAR                     0x0103\n#define WM_SYSKEYDOWN                   0x0104\n#define WM_SYSKEYUP                     0x0105\n#define WM_SYSCHAR                      0x0106\n#define WM_SYSDEADCHAR                  0x0107\n#define WM_KEYLAST                      0x0108\n#define WM_IME_STARTCOMPOSITION         0x010D\n#define WM_IME_ENDCOMPOSITION           0x010E\n#define WM_IME_COMPOSITION              0x010F\n#define WM_IME_KEYLAST                  0x010F\n#define WM_INITDIALOG                   0x0110\n#define WM_COMMAND                      0x0111\n#define WM_SYSCOMMAND                   0x0112\n#define WM_TIMER                        0x0113\n#define WM_HSCROLL                      0x0114\n#define WM_VSCROLL                      0x0115\n#define WM_INITMENU                     0x0116\n#define WM_INITMENUPOPUP                0x0117\n#define WM_MENUSELECT                   0x011F\n#define WM_MENUCHAR                     0x0120\n#define WM_ENTERIDLE                    0x0121\n#define WM_MENURBUTTONUP                0x0122\n#define WM_MENUDRAG                     0x0123\n#define WM_MENUGETOBJECT                0x0124\n#define WM_UNINITMENUPOPUP              0x0125\n#define WM_MENUCOMMAND                  0x0126\n#define WM_CHANGEUISTATE                0x0127\n#define WM_UPDATEUISTATE                0x0128\n#define WM_QUERYUISTATE                 0x0129\n#define WM_CTLCOLORMSGBOX               0x0132\n#define WM_CTLCOLOREDIT                 0x0133\n#define WM_CTLCOLORLISTBOX              0x0134\n#define WM_CTLCOLORBTN                  0x0135\n#define WM_CTLCOLORDLG                  0x0136\n#define WM_CTLCOLORSCROLLBAR            0x0137\n#define WM_CTLCOLORSTATIC               0x0138\n#define MN_GETHMENU                     0x01E1\n#define WM_MOUSEFIRST                   0x0200\n#define WM_MOUSEMOVE                    0x0200\n#define WVR_VREDRAW                     0x0200\n#define CS_NOCLOSE                      0x0200\n#define CF_PRIVATEFIRST                 0x0200\n#define TBSTYLE_WRAPABLE                0x0200\n#define RBS_VARHEIGHT                   0x00000200\n#define TBS_REVERSED                    0x0200\n#define LVS_EDITLABELS                  0x0200\n#define TVS_TRACKSELECT                 0x0200\n#define TCS_MULTILINE                   0x0200\n#define WM_LBUTTONDOWN                  0x0201\n#define WM_LBUTTONUP                    0x0202\n#define WM_LBUTTONDBLCLK                0x0203\n#define WM_RBUTTONDOWN                  0x0204\n#define WM_RBUTTONUP                    0x0205\n#define WM_RBUTTONDBLCLK                0x0206\n#define WM_MBUTTONDOWN                  0x0207\n#define WM_MBUTTONUP                    0x0208\n#define WM_MBUTTONDBLCLK                0x0209\n#define WM_MOUSEWHEEL                   0x020A\n#define WM_XBUTTONDOWN                  0x020B\n#define WM_XBUTTONUP                    0x020C\n#define WM_XBUTTONDBLCLK                0x020D\n#define WM_MOUSELAST                    0x020D\n#define WM_PARENTNOTIFY                 0x0210\n#define WM_ENTERMENULOOP                0x0211\n#define WM_EXITMENULOOP                 0x0212\n#define WM_NEXTMENU                     0x0213\n#define WM_SIZING                       0x0214\n#define WM_CAPTURECHANGED               0x0215\n#define WM_MOVING                       0x0216\n#define WM_POWERBROADCAST               0x0218\n#define WM_DEVICECHANGE                 0x0219\n#define WM_MDICREATE                    0x0220\n#define WM_MDIDESTROY                   0x0221\n#define WM_MDIACTIVATE                  0x0222\n#define WM_MDIRESTORE                   0x0223\n#define WM_MDINEXT                      0x0224\n#define WM_MDIMAXIMIZE                  0x0225\n#define WM_MDITILE                      0x0226\n#define WM_MDICASCADE                   0x0227\n#define WM_MDIICONARRANGE               0x0228\n#define WM_MDIGETACTIVE                 0x0229\n#define WM_MDISETMENU                   0x0230\n#define WM_ENTERSIZEMOVE                0x0231\n#define WM_EXITSIZEMOVE                 0x0232\n#define WM_DROPFILES                    0x0233\n#define WM_MDIREFRESHMENU               0x0234\n#define WM_IME_SETCONTEXT               0x0281\n#define WM_IME_NOTIFY                   0x0282\n#define WM_IME_CONTROL                  0x0283\n#define WM_IME_COMPOSITIONFULL          0x0284\n#define WM_IME_SELECT                   0x0285\n#define WM_IME_CHAR                     0x0286\n#define WM_IME_REQUEST                  0x0288\n#define WM_IME_KEYDOWN                  0x0290\n#define WM_IME_KEYUP                    0x0291\n#define WM_NCMOUSEHOVER                 0x02A0\n#define WM_MOUSEHOVER                   0x02A1\n#define WM_NCMOUSELEAVE                 0x02A2\n#define WM_MOUSELEAVE                   0x02A3\n#define CF_PRIVATELAST                  0x02FF\n#define WM_CUT                          0x0300\n#define CF_GDIOBJFIRST                  0x0300\n#define WM_COPY                         0x0301\n#define WM_PASTE                        0x0302\n#define WM_CLEAR                        0x0303\n#define WM_UNDO                         0x0304\n#define WM_RENDERFORMAT                 0x0305\n#define WM_RENDERALLFORMATS             0x0306\n#define WM_DESTROYCLIPBOARD             0x0307\n#define WM_DRAWCLIPBOARD                0x0308\n#define WM_PAINTCLIPBOARD               0x0309\n#define WM_VSCROLLCLIPBOARD             0x030A\n#define WM_SIZECLIPBOARD                0x030B\n#define WM_ASKCBFORMATNAME              0x030C\n#define WM_CHANGECBCHAIN                0x030D\n#define WM_HSCROLLCLIPBOARD             0x030E\n#define WM_QUERYNEWPALETTE              0x030F\n#define WM_PALETTEISCHANGING            0x0310\n#define WM_PALETTECHANGED               0x0311\n#define WM_HOTKEY                       0x0312\n#define WM_PRINT                        0x0317\n#define WM_PRINTCLIENT                  0x0318\n#define WM_APPCOMMAND                   0x0319\n#define WM_HANDHELDFIRST                0x0358\n#define WM_HANDHELDLAST                 0x035F\n#define WM_AFXFIRST                     0x0360\n#define WM_AFXLAST                      0x037F\n#define WM_PENWINFIRST                  0x0380\n#define WM_PENWINLAST                   0x038F\n#define WM_DDE_FIRST                    0x03E0\n#define CF_GDIOBJLAST                   0x03FF\n#define WM_USER                         0x0400\n#define WVR_VALIDRECTS                  0x0400\n#define TBSTYLE_ALTDRAG                 0x0400\n#define RBS_BANDBORDERS                 0x00000400\n#define TBS_DOWNISLEFT                  0x0400\n#define LVS_OWNERDRAWFIXED              0x0400\n#define TVS_SINGLEEXPAND                0x0400\n#define TCS_FIXEDWIDTH                  0x0400\n#define ctlFirst                        0x0400\n#define psh1                            0x0400\n#define psh2                            0x0401\n#define psh3                            0x0402\n#define psh4                            0x0403\n#define psh5                            0x0404\n#define psh6                            0x0405\n#define psh7                            0x0406\n#define psh8                            0x0407\n#define psh9                            0x0408\n#define psh10                           0x0409\n#define psh11                           0x040a\n#define psh12                           0x040b\n#define psh13                           0x040c\n#define psh14                           0x040d\n#define psh15                           0x040e\n#define psh16                           0x040f\n#define _WIN32_WINDOWS                  0x0410\n#define chx1                            0x0410\n#define chx2                            0x0411\n#define chx3                            0x0412\n#define chx4                            0x0413\n#define chx5                            0x0414\n#define chx6                            0x0415\n#define chx7                            0x0416\n#define chx8                            0x0417\n#define chx9                            0x0418\n#define chx10                           0x0419\n#define chx11                           0x041a\n#define chx12                           0x041b\n#define chx13                           0x041c\n#define chx14                           0x041d\n#define chx15                           0x041e\n#define chx16                           0x041f\n#define rad1                            0x0420\n#define rad2                            0x0421\n#define rad3                            0x0422\n#define rad4                            0x0423\n#define rad5                            0x0424\n#define rad6                            0x0425\n#define rad7                            0x0426\n#define rad8                            0x0427\n#define rad9                            0x0428\n#define rad10                           0x0429\n#define rad11                           0x042a\n#define rad12                           0x042b\n#define rad13                           0x042c\n#define rad14                           0x042d\n#define rad15                           0x042e\n#define rad16                           0x042f\n#define grp1                            0x0430\n#define grp2                            0x0431\n#define grp3                            0x0432\n#define grp4                            0x0433\n#define frm1                            0x0434\n#define frm2                            0x0435\n#define frm3                            0x0436\n#define frm4                            0x0437\n#define rct1                            0x0438\n#define rct2                            0x0439\n#define rct3                            0x043a\n#define rct4                            0x043b\n#define ico1                            0x043c\n#define ico2                            0x043d\n#define ico3                            0x043e\n#define ico4                            0x043f\n#define stc1                            0x0440\n#define stc2                            0x0441\n#define stc3                            0x0442\n#define stc4                            0x0443\n#define stc5                            0x0444\n#define stc6                            0x0445\n#define stc7                            0x0446\n#define stc8                            0x0447\n#define stc9                            0x0448\n#define stc10                           0x0449\n#define stc11                           0x044a\n#define stc12                           0x044b\n#define stc13                           0x044c\n#define stc14                           0x044d\n#define stc15                           0x044e\n#define stc16                           0x044f\n#define stc17                           0x0450\n#define stc18                           0x0451\n#define stc19                           0x0452\n#define stc20                           0x0453\n#define stc21                           0x0454\n#define stc22                           0x0455\n#define stc23                           0x0456\n#define stc24                           0x0457\n#define stc25                           0x0458\n#define stc26                           0x0459\n#define stc27                           0x045a\n#define stc28                           0x045b\n#define stc29                           0x045c\n#define stc30                           0x045d\n#define stc31                           0x045e\n#define stc32                           0x045f\n#define lst1                            0x0460\n#define lst2                            0x0461\n#define lst3                            0x0462\n#define lst4                            0x0463\n#define lst5                            0x0464\n#define lst6                            0x0465\n#define lst7                            0x0466\n#define lst8                            0x0467\n#define lst9                            0x0468\n#define lst10                           0x0469\n#define lst11                           0x046a\n#define lst12                           0x046b\n#define lst13                           0x046c\n#define lst14                           0x046d\n#define lst15                           0x046e\n#define lst16                           0x046f\n#define cmb1                            0x0470\n#define cmb2                            0x0471\n#define cmb3                            0x0472\n#define cmb4                            0x0473\n#define cmb5                            0x0474\n#define cmb6                            0x0475\n#define cmb7                            0x0476\n#define cmb8                            0x0477\n#define cmb9                            0x0478\n#define cmb10                           0x0479\n#define cmb11                           0x047a\n#define cmb12                           0x047b\n#define cmb13                           0x047c\n#define cmb14                           0x047d\n#define cmb15                           0x047e\n#define cmb16                           0x047f\n#define edt1                            0x0480\n#define edt2                            0x0481\n#define edt3                            0x0482\n#define edt4                            0x0483\n#define edt5                            0x0484\n#define edt6                            0x0485\n#define edt7                            0x0486\n#define edt8                            0x0487\n#define edt9                            0x0488\n#define edt10                           0x0489\n#define edt11                           0x048a\n#define edt12                           0x048b\n#define edt13                           0x048c\n#define edt14                           0x048d\n#define edt15                           0x048e\n#define edt16                           0x048f\n#define scr1                            0x0490\n#define scr2                            0x0491\n#define scr3                            0x0492\n#define scr4                            0x0493\n#define scr5                            0x0494\n#define scr6                            0x0495\n#define scr7                            0x0496\n#define scr8                            0x0497\n#define ctl1                            0x04A0\n#define ctlLast                         0x04ff\n#define WINVER                          0x0500\n#define _WIN32_WINNT                    0x0500\n#define _WIN32_IE                       0x0501\n#define FILEOPENORD                     1536\n#define MULTIFILEOPENORD                1537\n#define PRINTDLGORD                     1538\n#define PRNSETUPDLGORD                  1539\n#define FINDDLGORD                      1540\n#define REPLACEDLGORD                   1541\n#define FONTDLGORD                      1542\n#define FORMATDLGORD31                  1543\n#define FORMATDLGORD30                  1544\n#define RUNDLGORD                       1545\n#define PAGESETUPDLGORD                 1546\n#define NEWFILEOPENORD                  1547\n#define PRINTDLGEXORD                   1549\n#define PAGESETUPDLGORDMOTIF            1550\n#define COLORMGMTDLGORD                 1551\n#define NEWFILEOPENV2ORD                1552\n#define NEWFILEOPENV3ORD                1553\n#define CS_SAVEBITS                     0x0800\n#define TBSTYLE_FLAT                    0x0800\n#define RBS_FIXEDORDER                  0x00000800\n#define SBARS_TOOLTIPS                  0x0800\n#define SBT_TOOLTIPS                    0x0800\n#define LVS_ALIGNLEFT                   0x0800\n#define TVS_INFOTIP                     0x0800\n#define TCS_RAGGEDRIGHT                 0x0800\n#define LVS_ALIGNMASK                   0x0c00\n#define CS_BYTEALIGNCLIENT              0x1000\n#define TBSTYLE_LIST                    0x1000\n#define RBS_REGISTERDROP                0x00001000\n#define TBS_TRANSPARENTBKGND            0x1000\n#define LVS_OWNERDATA                   0x1000\n#define TVS_FULLROWSELECT               0x1000\n#define TCS_FOCUSONBUTTONDOWN           0x1000\n#define CS_BYTEALIGNWINDOW              0x2000\n#define TBSTYLE_CUSTOMERASE             0x2000\n#define RBS_AUTOSIZE                    0x00002000\n#define LVS_NOSCROLL                    0x2000\n#define TVS_NOSCROLL                    0x2000\n#define TCS_OWNERDRAWFIXED              0x2000\n#define CS_GLOBALCLASS                  0x4000\n#define TBSTYLE_REGISTERDROP            0x4000\n#define RBS_VERTICALGRIPPER             0x00004000\n#define LVS_NOCOLUMNHEADER              0x4000\n#define TVS_NONEVENHEIGHT               0x4000\n#define TCS_TOOLTIPS                    0x4000\n#define IDH_NO_HELP                     28440\n#define IDH_MISSING_CONTEXT             28441\n#define IDH_GENERIC_HELP_BUTTON         28442\n#define IDH_OK                          28443\n#define IDH_CANCEL                      28444\n#define IDH_HELP                        28445\n#define LANG_BOSNIAN_NEUTRAL            0x781a\n#define LANG_CHINESE_TRADITIONAL        0x7c04\n#define LANG_SERBIAN_NEUTRAL            0x7c1a\n#define OCR_NORMAL                      32512\n#define OIC_SAMPLE                      32512\n#define IDI_APPLICATION                 32512\n#define OCR_IBEAM                       32513\n#define OIC_HAND                        32513\n#define IDI_HAND                        32513\n#define OCR_WAIT                        32514\n#define OIC_QUES                        32514\n#define IDI_QUESTION                    32514\n#define OCR_CROSS                       32515\n#define OIC_BANG                        32515\n#define IDI_EXCLAMATION                 32515\n#define OCR_UP                          32516\n#define OIC_NOTE                        32516\n#define IDI_ASTERISK                    32516\n#define OIC_WINLOGO                     32517\n#define IDI_WINLOGO                     32517\n#define OCR_SIZE                        32640\n#define OCR_ICON                        32641\n#define OCR_SIZENWSE                    32642\n#define OCR_SIZENESW                    32643\n#define OCR_SIZEWE                      32644\n#define OCR_SIZENS                      32645\n#define OCR_SIZEALL                     32646\n#define OCR_ICOCUR                      32647\n#define OCR_NO                          32648\n#define OCR_HAND                        32649\n#define OCR_APPSTARTING                 32650\n#define OBM_LFARROWI                    32734\n#define OBM_RGARROWI                    32735\n#define OBM_DNARROWI                    32736\n#define OBM_UPARROWI                    32737\n#define OBM_COMBO                       32738\n#define OBM_MNARROW                     32739\n#define OBM_LFARROWD                    32740\n#define OBM_RGARROWD                    32741\n#define OBM_DNARROWD                    32742\n#define OBM_UPARROWD                    32743\n#define OBM_RESTORED                    32744\n#define OBM_ZOOMD                       32745\n#define OBM_REDUCED                     32746\n#define OBM_RESTORE                     32747\n#define OBM_ZOOM                        32748\n#define OBM_REDUCE                      32749\n#define OBM_LFARROW                     32750\n#define OBM_RGARROW                     32751\n#define OBM_DNARROW                     32752\n#define OBM_UPARROW                     32753\n#define OBM_CLOSE                       32754\n#define OBM_OLD_RESTORE                 32755\n#define OBM_OLD_ZOOM                    32756\n#define OBM_OLD_REDUCE                  32757\n#define OBM_BTNCORNERS                  32758\n#define OBM_CHECKBOXES                  32759\n#define OBM_CHECK                       32760\n#define OBM_BTSIZE                      32761\n#define OBM_OLD_LFARROW                 32762\n#define OBM_OLD_RGARROW                 32763\n#define OBM_OLD_DNARROW                 32764\n#define OBM_OLD_UPARROW                 32765\n#define OBM_SIZE                        32766\n#define OBM_OLD_CLOSE                   32767\n#define WM_APP                          0x8000\n#define HELP_TCARD                      0x8000\n#define TBSTYLE_TRANSPARENT             0x8000\n#define RBS_DBLCLKTOGGLE                0x00008000\n#define LVS_NOSORTHEADER                0x8000\n#define TVS_NOHSCROLL                   0x8000\n#define TCS_FOCUSNEVER                  0x8000\n#define SC_SIZE                         0xF000\n#define SC_SEPARATOR                    0xF00F\n#define SC_MOVE                         0xF010\n#define SC_MINIMIZE                     0xF020\n#define SC_MAXIMIZE                     0xF030\n#define SC_NEXTWINDOW                   0xF040\n#define SC_PREVWINDOW                   0xF050\n#define SC_CLOSE                        0xF060\n#define SC_VSCROLL                      0xF070\n#define SC_HSCROLL                      0xF080\n#define SC_MOUSEMENU                    0xF090\n#define SC_KEYMENU                      0xF100\n#define SC_ARRANGE                      0xF110\n#define SC_RESTORE                      0xF120\n#define SC_TASKLIST                     0xF130\n#define SC_SCREENSAVE                   0xF140\n#define SC_HOTKEY                       0xF150\n#define SC_DEFAULT                      0xF160\n#define SC_MONITORPOWER                 0xF170\n#define SC_CONTEXTHELP                  0xF180\n#define LVS_TYPESTYLEMASK               0xfc00\n//#define HTERROR                         -2\n//#define PWR_FAIL                        -1\n//#define HTTRANSPARENT                   -1\n\n// Next default values for new objects\n// \n#ifdef APSTUDIO_INVOKED\n#ifndef APSTUDIO_READONLY_SYMBOLS\n#define _APS_NO_MFC                     1\n#define _APS_NEXT_RESOURCE_VALUE        101\n#define _APS_NEXT_COMMAND_VALUE         40001\n#define _APS_NEXT_CONTROL_VALUE         1000\n#define _APS_NEXT_SYMED_VALUE           101\n#endif\n#endif\n"
        },
        {
          "name": "resource.h",
          "type": "blob",
          "size": 63.9375,
          "content": "//{{NO_DEPENDENCIES}}\n// Microsoft Visual C++ generated include file.\n// Used by gdidll.rc\n//\n#define SW_HIDE                         0\n#define HIDE_WINDOW                     0\n#define WM_NULL                         0x0000\n#define WA_INACTIVE                     0\n#define HTNOWHERE                       0\n#define SMTO_NORMAL                     0x0000\n#define ICON_SMALL                      0\n#define SIZE_RESTORED                   0\n#define BN_CLICKED                      0\n#define BST_UNCHECKED                   0x0000\n#define HDS_HORZ                        0x0000\n#define TBSTYLE_BUTTON                  0x0000\n#define TBS_HORZ                        0x0000\n#define TBS_BOTTOM                      0x0000\n#define TBS_RIGHT                       0x0000\n#define LVS_ICON                        0x0000\n#define LVS_ALIGNTOP                    0x0000\n#define TCS_TABS                        0x0000\n#define TCS_SINGLELINE                  0x0000\n#define TCS_RIGHTJUSTIFY                0x0000\n#define DTS_SHORTDATEFORMAT             0x0000\n#define PGS_VERT                        0x00000000\n#define LANG_NEUTRAL                    0x00\n#define SUBLANG_NEUTRAL                 0x00\n#define SORT_DEFAULT                    0x0\n#define SORT_JAPANESE_XJIS              0x0\n#define SORT_CHINESE_BIG5               0x0\n#define SORT_CHINESE_PRCP               0x0\n#define SORT_KOREAN_KSC                 0x0\n#define SORT_HUNGARIAN_DEFAULT          0x0\n#define SORT_GEORGIAN_TRADITIONAL       0x0\n#define _USE_DECLSPECS_FOR_SAL          0\n#define _USE_ATTRIBUTES_FOR_SAL         0\n#define CREATEPROCESS_MANIFEST_RESOURCE_ID 1\n#define MINIMUM_RESERVED_MANIFEST_RESOURCE_ID 1\n#define SW_SHOWNORMAL                   1\n#define SW_NORMAL                       1\n#define SHOW_OPENWINDOW                 1\n#define SW_PARENTCLOSING                1\n#define VK_LBUTTON                      0x01\n#define WM_CREATE                       0x0001\n#define WA_ACTIVE                       1\n#define PWR_OK                          1\n#define PWR_SUSPENDREQUEST              1\n#define NFR_ANSI                        1\n#define UIS_SET                         1\n#define UISF_HIDEFOCUS                  0x1\n#define XBUTTON1                        0x0001\n#define WMSZ_LEFT                       1\n#define HTCLIENT                        1\n#define SMTO_BLOCK                      0x0001\n#define MA_ACTIVATE                     1\n#define ICON_BIG                        1\n#define SIZE_MINIMIZED                  1\n#define MK_LBUTTON                      0x0001\n#define TME_HOVER                       0x00000001\n#define CS_VREDRAW                      0x0001\n#define CF_TEXT                         1\n#define IDOK                            1\n#define BN_PAINT                        1\n#define BST_CHECKED                     0x0001\n#define TBSTYLE_SEP                     0x0001\n#define TTS_ALWAYSTIP                   0x01\n#define TBS_AUTOTICKS                   0x0001\n#define UDS_WRAP                        0x0001\n#define PBS_SMOOTH                      0x01\n#define LWS_TRANSPARENT                 0x0001\n#define LVS_REPORT                      0x0001\n#define TVS_HASBUTTONS                  0x0001\n#define TCS_SCROLLOPPOSITE              0x0001\n#define ACS_CENTER                      0x0001\n#define MCS_DAYSTATE                    0x0001\n#define DTS_UPDOWN                      0x0001\n#define PGS_HORZ                        0x00000001\n#define NFS_EDIT                        0x0001\n#define BCSIF_GLYPH                     0x0001\n#define BCSS_NOSPLIT                    0x0001\n#define LANG_ARABIC                     0x01\n#define SUBLANG_DEFAULT                 0x01\n#define SUBLANG_AFRIKAANS_SOUTH_AFRICA  0x01\n#define SUBLANG_ALBANIAN_ALBANIA        0x01\n#define SUBLANG_ALSATIAN_FRANCE         0x01\n#define SUBLANG_AMHARIC_ETHIOPIA        0x01\n#define SUBLANG_ARABIC_SAUDI_ARABIA     0x01\n#define SUBLANG_ARMENIAN_ARMENIA        0x01\n#define SUBLANG_ASSAMESE_INDIA          0x01\n#define SUBLANG_AZERI_LATIN             0x01\n#define SUBLANG_BASHKIR_RUSSIA          0x01\n#define SUBLANG_BASQUE_BASQUE           0x01\n#define SUBLANG_BELARUSIAN_BELARUS      0x01\n#define SUBLANG_BENGALI_INDIA           0x01\n#define SUBLANG_BRETON_FRANCE           0x01\n#define SUBLANG_BULGARIAN_BULGARIA      0x01\n#define SUBLANG_CATALAN_CATALAN         0x01\n#define SUBLANG_CHINESE_TRADITIONAL     0x01\n#define SUBLANG_CORSICAN_FRANCE         0x01\n#define SUBLANG_CZECH_CZECH_REPUBLIC    0x01\n#define SUBLANG_CROATIAN_CROATIA        0x01\n#define SUBLANG_DANISH_DENMARK          0x01\n#define SUBLANG_DARI_AFGHANISTAN        0x01\n#define SUBLANG_DIVEHI_MALDIVES         0x01\n#define SUBLANG_DUTCH                   0x01\n#define SUBLANG_ENGLISH_US              0x01\n#define SUBLANG_ESTONIAN_ESTONIA        0x01\n#define SUBLANG_FAEROESE_FAROE_ISLANDS  0x01\n#define SUBLANG_FILIPINO_PHILIPPINES    0x01\n#define SUBLANG_FINNISH_FINLAND         0x01\n#define SUBLANG_FRENCH                  0x01\n#define SUBLANG_FRISIAN_NETHERLANDS     0x01\n#define SUBLANG_GALICIAN_GALICIAN       0x01\n#define SUBLANG_GEORGIAN_GEORGIA        0x01\n#define SUBLANG_GERMAN                  0x01\n#define SUBLANG_GREEK_GREECE            0x01\n#define SUBLANG_GREENLANDIC_GREENLAND   0x01\n#define SUBLANG_GUJARATI_INDIA          0x01\n#define SUBLANG_HAUSA_NIGERIA_LATIN     0x01\n#define SUBLANG_HEBREW_ISRAEL           0x01\n#define SUBLANG_HINDI_INDIA             0x01\n#define SUBLANG_HUNGARIAN_HUNGARY       0x01\n#define SUBLANG_ICELANDIC_ICELAND       0x01\n#define SUBLANG_IGBO_NIGERIA            0x01\n#define SUBLANG_INDONESIAN_INDONESIA    0x01\n#define SUBLANG_INUKTITUT_CANADA        0x01\n#define SUBLANG_ITALIAN                 0x01\n#define SUBLANG_JAPANESE_JAPAN          0x01\n#define SUBLANG_KANNADA_INDIA           0x01\n#define SUBLANG_KAZAK_KAZAKHSTAN        0x01\n#define SUBLANG_KHMER_CAMBODIA          0x01\n#define SUBLANG_KICHE_GUATEMALA         0x01\n#define SUBLANG_KINYARWANDA_RWANDA      0x01\n#define SUBLANG_KONKANI_INDIA           0x01\n#define SUBLANG_KOREAN                  0x01\n#define SUBLANG_KYRGYZ_KYRGYZSTAN       0x01\n#define SUBLANG_LAO_LAO                 0x01\n#define SUBLANG_LATVIAN_LATVIA          0x01\n#define SUBLANG_LITHUANIAN              0x01\n#define SUBLANG_LUXEMBOURGISH_LUXEMBOURG 0x01\n#define SUBLANG_MACEDONIAN_MACEDONIA    0x01\n#define SUBLANG_MALAY_MALAYSIA          0x01\n#define SUBLANG_MALAYALAM_INDIA         0x01\n#define SUBLANG_MALTESE_MALTA           0x01\n#define SUBLANG_MAORI_NEW_ZEALAND       0x01\n#define SUBLANG_MAPUDUNGUN_CHILE        0x01\n#define SUBLANG_MARATHI_INDIA           0x01\n#define SUBLANG_MOHAWK_MOHAWK           0x01\n#define SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA 0x01\n#define SUBLANG_NEPALI_NEPAL            0x01\n#define SUBLANG_NORWEGIAN_BOKMAL        0x01\n#define SUBLANG_OCCITAN_FRANCE          0x01\n#define SUBLANG_ORIYA_INDIA             0x01\n#define SUBLANG_PASHTO_AFGHANISTAN      0x01\n#define SUBLANG_PERSIAN_IRAN            0x01\n#define SUBLANG_POLISH_POLAND           0x01\n#define SUBLANG_PORTUGUESE_BRAZILIAN    0x01\n#define SUBLANG_PUNJABI_INDIA           0x01\n#define SUBLANG_QUECHUA_BOLIVIA         0x01\n#define SUBLANG_ROMANIAN_ROMANIA        0x01\n#define SUBLANG_ROMANSH_SWITZERLAND     0x01\n#define SUBLANG_RUSSIAN_RUSSIA          0x01\n#define SUBLANG_SAMI_NORTHERN_NORWAY    0x01\n#define SUBLANG_SANSKRIT_INDIA          0x01\n#define SUBLANG_SERBIAN_CROATIA         0x01\n#define SUBLANG_SINDHI_INDIA            0x01\n#define SUBLANG_SINHALESE_SRI_LANKA     0x01\n#define SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA 0x01\n#define SUBLANG_SLOVAK_SLOVAKIA         0x01\n#define SUBLANG_SLOVENIAN_SLOVENIA      0x01\n#define SUBLANG_SPANISH                 0x01\n#define SUBLANG_SWAHILI_KENYA           0x01\n#define SUBLANG_SWEDISH                 0x01\n#define SUBLANG_SYRIAC_SYRIA            0x01\n#define SUBLANG_TAJIK_TAJIKISTAN        0x01\n#define SUBLANG_TAMIL_INDIA             0x01\n#define SUBLANG_TATAR_RUSSIA            0x01\n#define SUBLANG_TELUGU_INDIA            0x01\n#define SUBLANG_THAI_THAILAND           0x01\n#define SUBLANG_TIBETAN_PRC             0x01\n#define SUBLANG_TSWANA_SOUTH_AFRICA     0x01\n#define SUBLANG_TURKISH_TURKEY          0x01\n#define SUBLANG_TURKMEN_TURKMENISTAN    0x01\n#define SUBLANG_UIGHUR_PRC              0x01\n#define SUBLANG_UKRAINIAN_UKRAINE       0x01\n#define SUBLANG_UPPER_SORBIAN_GERMANY   0x01\n#define SUBLANG_URDU_PAKISTAN           0x01\n#define SUBLANG_UZBEK_LATIN             0x01\n#define SUBLANG_VIETNAMESE_VIETNAM      0x01\n#define SUBLANG_WELSH_UNITED_KINGDOM    0x01\n#define SUBLANG_WOLOF_SENEGAL           0x01\n#define SUBLANG_XHOSA_SOUTH_AFRICA      0x01\n#define SUBLANG_YAKUT_RUSSIA            0x01\n#define SUBLANG_YI_PRC                  0x01\n#define SUBLANG_YORUBA_NIGERIA          0x01\n#define SUBLANG_ZULU_SOUTH_AFRICA       0x01\n#define SORT_INVARIANT_MATH             0x1\n#define SORT_JAPANESE_UNICODE           0x1\n#define SORT_CHINESE_UNICODE            0x1\n#define SORT_KOREAN_UNICODE             0x1\n#define SORT_GERMAN_PHONE_BOOK          0x1\n#define SORT_HUNGARIAN_TECHNICAL        0x1\n#define SORT_GEORGIAN_MODERN            0x1\n#define VS_VERSION_INFO                 1\n#define VFFF_ISSHAREDFILE               0x0001\n#define VFF_CURNEDEST                   0x0001\n#define VIFF_FORCEINSTALL               0x0001\n#define ISOLATIONAWARE_MANIFEST_RESOURCE_ID 2\n#define SW_SHOWMINIMIZED                2\n#define SHOW_ICONWINDOW                 2\n#define SW_OTHERZOOM                    2\n#define VK_RBUTTON                      0x02\n#define WM_DESTROY                      0x0002\n#define WA_CLICKACTIVE                  2\n#define PWR_SUSPENDRESUME               2\n#define NFR_UNICODE                     2\n#define UIS_CLEAR                       2\n#define UISF_HIDEACCEL                  0x2\n#define XBUTTON2                        0x0002\n#define WMSZ_RIGHT                      2\n#define HTCAPTION                       2\n#define SMTO_ABORTIFHUNG                0x0002\n#define MA_ACTIVATEANDEAT               2\n#define SIZE_MAXIMIZED                  2\n#define MK_RBUTTON                      0x0002\n#define TME_LEAVE                       0x00000002\n#define CS_HREDRAW                      0x0002\n#define CF_BITMAP                       2\n#define IDCANCEL                        2\n#define BN_HILITE                       2\n#define BST_INDETERMINATE               0x0002\n#define HDS_BUTTONS                     0x0002\n#define TBSTYLE_CHECK                   0x0002\n#define TTS_NOPREFIX                    0x02\n#define TBS_VERT                        0x0002\n#define UDS_SETBUDDYINT                 0x0002\n#define LWS_IGNORERETURN                0x0002\n#define LVS_SMALLICON                   0x0002\n#define TVS_HASLINES                    0x0002\n#define TCS_BOTTOM                      0x0002\n#define TCS_RIGHT                       0x0002\n#define ACS_TRANSPARENT                 0x0002\n#define MCS_MULTISELECT                 0x0002\n#define DTS_SHOWNONE                    0x0002\n#define PGS_AUTOSCROLL                  0x00000002\n#define NFS_STATIC                      0x0002\n#define BCSIF_IMAGE                     0x0002\n#define BCSS_STRETCH                    0x0002\n#define LANG_BULGARIAN                  0x02\n#define SUBLANG_SYS_DEFAULT             0x02\n#define SUBLANG_ARABIC_IRAQ             0x02\n#define SUBLANG_AZERI_CYRILLIC          0x02\n#define SUBLANG_BENGALI_BANGLADESH      0x02\n#define SUBLANG_CHINESE_SIMPLIFIED      0x02\n#define SUBLANG_DUTCH_BELGIAN           0x02\n#define SUBLANG_ENGLISH_UK              0x02\n#define SUBLANG_FRENCH_BELGIAN          0x02\n#define SUBLANG_GERMAN_SWISS            0x02\n#define SUBLANG_INUKTITUT_CANADA_LATIN  0x02\n#define SUBLANG_IRISH_IRELAND           0x02\n#define SUBLANG_ITALIAN_SWISS           0x02\n#define SUBLANG_KASHMIRI_SASIA          0x02\n#define SUBLANG_KASHMIRI_INDIA          0x02\n#define SUBLANG_LOWER_SORBIAN_GERMANY   0x02\n#define SUBLANG_MALAY_BRUNEI_DARUSSALAM 0x02\n#define SUBLANG_MONGOLIAN_PRC           0x02\n#define SUBLANG_NEPALI_INDIA            0x02\n#define SUBLANG_NORWEGIAN_NYNORSK       0x02\n#define SUBLANG_PORTUGUESE              0x02\n#define SUBLANG_QUECHUA_ECUADOR         0x02\n#define SUBLANG_SAMI_NORTHERN_SWEDEN    0x02\n#define SUBLANG_SERBIAN_LATIN           0x02\n#define SUBLANG_SINDHI_PAKISTAN         0x02\n#define SUBLANG_SINDHI_AFGHANISTAN      0x02\n#define SUBLANG_SPANISH_MEXICAN         0x02\n#define SUBLANG_SWEDISH_FINLAND         0x02\n#define SUBLANG_TAMAZIGHT_ALGERIA_LATIN 0x02\n#define SUBLANG_TIGRIGNA_ERITREA        0x02\n#define SUBLANG_URDU_INDIA              0x02\n#define SUBLANG_UZBEK_CYRILLIC          0x02\n#define SORT_CHINESE_PRC                0x2\n#define VFF_FILEINUSE                   0x0002\n#define VIFF_DONTDELETEOLD              0x0002\n#define ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID 3\n#define SW_SHOWMAXIMIZED                3\n#define SW_MAXIMIZE                     3\n#define SHOW_FULLSCREEN                 3\n#define SW_PARENTOPENING                3\n#define VK_CANCEL                       0x03\n#define WM_MOVE                         0x0003\n#define PWR_CRITICALRESUME              3\n#define NF_QUERY                        3\n#define UIS_INITIALIZE                  3\n#define WMSZ_TOP                        3\n#define HTSYSMENU                       3\n#define MA_NOACTIVATE                   3\n#define SIZE_MAXSHOW                    3\n#define CF_METAFILEPICT                 3\n#define IDABORT                         3\n#define BN_UNHILITE                     3\n#define LVS_LIST                        0x0003\n#define LVS_TYPEMASK                    0x0003\n#define LANG_CATALAN                    0x03\n#define SUBLANG_CUSTOM_DEFAULT          0x03\n#define SUBLANG_ARABIC_EGYPT            0x03\n#define SUBLANG_CHINESE_HONGKONG        0x03\n#define SUBLANG_ENGLISH_AUS             0x03\n#define SUBLANG_FRENCH_CANADIAN         0x03\n#define SUBLANG_GERMAN_AUSTRIAN         0x03\n#define SUBLANG_QUECHUA_PERU            0x03\n#define SUBLANG_SAMI_NORTHERN_FINLAND   0x03\n#define SUBLANG_SERBIAN_CYRILLIC        0x03\n#define SUBLANG_SPANISH_MODERN          0x03\n#define SORT_CHINESE_BOPOMOFO           0x3\n#define SW_SHOWNOACTIVATE               4\n#define SHOW_OPENNOACTIVATE             4\n#define SW_OTHERUNZOOM                  4\n#define VK_MBUTTON                      0x04\n#define NF_REQUERY                      4\n#define WMSZ_TOPLEFT                    4\n#define HTGROWBOX                       4\n#define MA_NOACTIVATEANDEAT             4\n#define SIZE_MAXHIDE                    4\n#define MK_SHIFT                        0x0004\n#define CF_SYLK                         4\n#define IDRETRY                         4\n#define BN_DISABLE                      4\n#define BST_PUSHED                      0x0004\n#define HDS_HOTTRACK                    0x0004\n#define TBSTYLE_GROUP                   0x0004\n#define TBS_TOP                         0x0004\n#define TBS_LEFT                        0x0004\n#define UDS_ALIGNRIGHT                  0x0004\n#define PBS_VERTICAL                    0x04\n#define LVS_SINGLESEL                   0x0004\n#define TVS_LINESATROOT                 0x0004\n#define TCS_MULTISELECT                 0x0004\n#define ACS_AUTOPLAY                    0x0004\n#define MCS_WEEKNUMBERS                 0x0004\n#define DTS_LONGDATEFORMAT              0x0004\n#define PGS_DRAGNDROP                   0x00000004\n#define NFS_LISTCOMBO                   0x0004\n#define BCSIF_STYLE                     0x0004\n#define BCSS_ALIGNLEFT                  0x0004\n#define LANG_CHINESE                    0x04\n#define LANG_CHINESE_SIMPLIFIED         0x04\n#define SUBLANG_CUSTOM_UNSPECIFIED      0x04\n#define SUBLANG_ARABIC_LIBYA            0x04\n#define SUBLANG_CHINESE_SINGAPORE       0x04\n#define SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN 0x04\n#define SUBLANG_ENGLISH_CAN             0x04\n#define SUBLANG_FRENCH_SWISS            0x04\n#define SUBLANG_GERMAN_LUXEMBOURG       0x04\n#define SUBLANG_SAMI_LULE_NORWAY        0x04\n#define SUBLANG_SPANISH_GUATEMALA       0x04\n#define SORT_JAPANESE_RADICALSTROKE     0x4\n#define VFF_BUFFTOOSMALL                0x0004\n#define SW_SHOW                         5\n#define VK_XBUTTON1                     0x05\n#define WM_SIZE                         0x0005\n#define WMSZ_TOPRIGHT                   5\n#define HTMENU                          5\n#define CF_DIF                          5\n#define IDIGNORE                        5\n#define BN_DOUBLECLICKED                5\n#define LANG_CZECH                      0x05\n#define SUBLANG_UI_CUSTOM_DEFAULT       0x05\n#define SUBLANG_ARABIC_ALGERIA          0x05\n#define SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN 0x05\n#define SUBLANG_CHINESE_MACAU           0x05\n#define SUBLANG_ENGLISH_NZ              0x05\n#define SUBLANG_FRENCH_LUXEMBOURG       0x05\n#define SUBLANG_GERMAN_LIECHTENSTEIN    0x05\n#define SUBLANG_SAMI_LULE_SWEDEN        0x05\n#define SUBLANG_SPANISH_COSTA_RICA      0x05\n#define SW_MINIMIZE                     6\n#define VK_XBUTTON2                     0x06\n#define WM_ACTIVATE                     0x0006\n#define WMSZ_BOTTOM                     6\n#define HTHSCROLL                       6\n#define CF_TIFF                         6\n#define IDYES                           6\n#define BN_SETFOCUS                     6\n#define LANG_DANISH                     0x06\n#define SUBLANG_ARABIC_MOROCCO          0x06\n#define SUBLANG_ENGLISH_EIRE            0x06\n#define SUBLANG_FRENCH_MONACO           0x06\n#define SUBLANG_SAMI_SOUTHERN_NORWAY    0x06\n#define SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN 0x06\n#define SUBLANG_SPANISH_PANAMA          0x06\n#define SW_SHOWMINNOACTIVE              7\n#define WM_SETFOCUS                     0x0007\n#define WMSZ_BOTTOMLEFT                 7\n#define HTVSCROLL                       7\n#define CF_OEMTEXT                      7\n#define IDNO                            7\n#define BN_KILLFOCUS                    7\n#define LANG_GERMAN                     0x07\n#define SUBLANG_ARABIC_TUNISIA          0x07\n#define SUBLANG_ENGLISH_SOUTH_AFRICA    0x07\n#define SUBLANG_SAMI_SOUTHERN_SWEDEN    0x07\n#define SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC 0x07\n#define SUBLANG_SPANISH_DOMINICAN_REPUBLIC 0x07\n#define SW_SHOWNA                       8\n#define VK_BACK                         0x08\n#define WM_KILLFOCUS                    0x0008\n#define WMSZ_BOTTOMRIGHT                8\n#define HTMINBUTTON                     8\n#define SMTO_NOTIMEOUTIFNOTHUNG         0x0008\n#define MK_CONTROL                      0x0008\n#define CS_DBLCLKS                      0x0008\n#define CF_DIB                          8\n#define IDCLOSE                         8\n#define BST_FOCUS                       0x0008\n#define HDS_HIDDEN                      0x0008\n#define TBSTYLE_DROPDOWN                0x0008\n#define TBS_BOTH                        0x0008\n#define UDS_ALIGNLEFT                   0x0008\n#define LVS_SHOWSELALWAYS               0x0008\n#define TVS_EDITLABELS                  0x0008\n#define TCS_FLATBUTTONS                 0x0008\n#define ACS_TIMER                       0x0008\n#define MCS_NOTODAYCIRCLE               0x0008\n#define NFS_BUTTON                      0x0008\n#define BCSIF_SIZE                      0x0008\n#define BCSS_IMAGE                      0x0008\n#define LANG_GREEK                      0x08\n#define SUBLANG_ARABIC_OMAN             0x08\n#define SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC 0x08\n#define SUBLANG_ENGLISH_JAMAICA         0x08\n#define SUBLANG_SAMI_SKOLT_FINLAND      0x08\n#define SUBLANG_SPANISH_VENEZUELA       0x08\n#define SW_RESTORE                      9\n#define VK_TAB                          0x09\n#define HTMAXBUTTON                     9\n#define CF_PALETTE                      9\n#define IDHELP                          9\n#define DTS_TIMEFORMAT                  0x0009\n#define LANG_ENGLISH                    0x09\n#define SUBLANG_ARABIC_YEMEN            0x09\n#define SUBLANG_ENGLISH_CARIBBEAN       0x09\n#define SUBLANG_SAMI_INARI_FINLAND      0x09\n#define SUBLANG_SPANISH_COLOMBIA        0x09\n#define SW_SHOWDEFAULT                  10\n#define WM_ENABLE                       0x000A\n#define HTLEFT                          10\n#define CF_PENDATA                      10\n#define IDTRYAGAIN                      10\n#define HELP_CONTEXTMENU                0x000a\n#define LANG_SPANISH                    0x0a\n#define SUBLANG_ARABIC_SYRIA            0x0a\n#define SUBLANG_ENGLISH_BELIZE          0x0a\n#define SUBLANG_SPANISH_PERU            0x0a\n#define SW_FORCEMINIMIZE                11\n#define SW_MAX                          11\n#define WM_SETREDRAW                    0x000B\n#define HTRIGHT                         11\n#define CF_RIFF                         11\n#define IDCONTINUE                      11\n#define HELP_FINDER                     0x000b\n#define LANG_FINNISH                    0x0b\n#define SUBLANG_ARABIC_JORDAN           0x0b\n#define SUBLANG_ENGLISH_TRINIDAD        0x0b\n#define SUBLANG_SPANISH_ARGENTINA       0x0b\n#define VK_CLEAR                        0x0C\n#define WM_SETTEXT                      0x000C\n#define HTTOP                           12\n#define CF_WAVE                         12\n#define HELP_WM_HELP                    0x000c\n#define DTS_SHORTDATECENTURYFORMAT      0x000C\n#define LANG_FRENCH                     0x0c\n#define SUBLANG_ARABIC_LEBANON          0x0c\n#define SUBLANG_ENGLISH_ZIMBABWE        0x0c\n#define SUBLANG_SPANISH_ECUADOR         0x0c\n#define VK_RETURN                       0x0D\n#define WM_GETTEXT                      0x000D\n#define HTTOPLEFT                       13\n#define CF_UNICODETEXT                  13\n#define HELP_SETPOPUP_POS               0x000d\n#define LANG_HEBREW                     0x0d\n#define SUBLANG_ARABIC_KUWAIT           0x0d\n#define SUBLANG_ENGLISH_PHILIPPINES     0x0d\n#define SUBLANG_SPANISH_CHILE           0x0d\n#define WM_GETTEXTLENGTH                0x000E\n#define HTTOPRIGHT                      14\n#define CF_ENHMETAFILE                  14\n#define LANG_HUNGARIAN                  0x0e\n#define SUBLANG_ARABIC_UAE              0x0e\n#define SUBLANG_SPANISH_URUGUAY         0x0e\n#define WM_PAINT                        0x000F\n#define HTBOTTOM                        15\n#define CF_HDROP                        15\n#define LANG_ICELANDIC                  0x0f\n#define SUBLANG_ARABIC_BAHRAIN          0x0f\n#define SUBLANG_SPANISH_PARAGUAY        0x0f\n#define MAXIMUM_RESERVED_MANIFEST_RESOURCE_ID 16\n#define VK_SHIFT                        0x10\n#define WM_CLOSE                        0x0010\n#define HTBOTTOMLEFT                    16\n#define WVR_ALIGNTOP                    0x0010\n#define MK_MBUTTON                      0x0010\n#define TME_NONCLIENT                   0x00000010\n#define CF_LOCALE                       16\n#define HELP_TCARD_DATA                 0x0010\n#define TBSTYLE_AUTOSIZE                0x0010\n#define TTS_NOANIMATE                   0x10\n#define TBS_NOTICKS                     0x0010\n#define UDS_AUTOBUDDY                   0x0010\n#define LVS_SORTASCENDING               0x0010\n#define TVS_DISABLEDRAGDROP             0x0010\n#define TCS_FORCEICONLEFT               0x0010\n#define MCS_NOTODAY                     0x0010\n#define DTS_APPCANPARSE                 0x0010\n#define NFS_ALL                         0x0010\n#define LANG_ITALIAN                    0x10\n#define SUBLANG_ARABIC_QATAR            0x10\n#define SUBLANG_ENGLISH_INDIA           0x10\n#define SUBLANG_SPANISH_BOLIVIA         0x10\n#define VK_CONTROL                      0x11\n#define WM_QUERYENDSESSION              0x0011\n#define HTBOTTOMRIGHT                   17\n#define CF_DIBV5                        17\n#define HELP_TCARD_OTHER_CALLER         0x0011\n#define LANG_JAPANESE                   0x11\n#define SUBLANG_ENGLISH_MALAYSIA        0x11\n#define SUBLANG_SPANISH_EL_SALVADOR     0x11\n#define VK_MENU                         0x12\n#define WM_QUIT                         0x0012\n#define HTBORDER                        18\n#define CF_MAX                          18\n#define LANG_KOREAN                     0x12\n#define SUBLANG_ENGLISH_SINGAPORE       0x12\n#define SUBLANG_SPANISH_HONDURAS        0x12\n#define VK_PAUSE                        0x13\n#define WM_QUERYOPEN                    0x0013\n#define HTOBJECT                        19\n#define LANG_DUTCH                      0x13\n#define SUBLANG_SPANISH_NICARAGUA       0x13\n#define VK_CAPITAL                      0x14\n#define WM_ERASEBKGND                   0x0014\n#define HTCLOSE                         20\n#define LANG_NORWEGIAN                  0x14\n#define SUBLANG_SPANISH_PUERTO_RICO     0x14\n#define VK_KANA                         0x15\n#define VK_HANGEUL                      0x15\n#define VK_HANGUL                       0x15\n#define WM_SYSCOLORCHANGE               0x0015\n#define HTHELP                          21\n#define LANG_POLISH                     0x15\n#define SUBLANG_SPANISH_US              0x15\n#define WM_ENDSESSION                   0x0016\n#define LANG_PORTUGUESE                 0x16\n#define VK_JUNJA                        0x17\n#define LANG_ROMANSH                    0x17\n#define RT_MANIFEST                     24\n#define VK_FINAL                        0x18\n#define WM_SHOWWINDOW                   0x0018\n#define LANG_ROMANIAN                   0x18\n#define VK_HANJA                        0x19\n#define VK_KANJI                        0x19\n#define LANG_RUSSIAN                    0x19\n#define WM_WININICHANGE                 0x001A\n#define LANG_BOSNIAN                    0x1a\n#define LANG_CROATIAN                   0x1a\n#define LANG_SERBIAN                    0x1a\n#define VK_ESCAPE                       0x1B\n#define WM_DEVMODECHANGE                0x001B\n#define LANG_SLOVAK                     0x1b\n#define VK_CONVERT                      0x1C\n#define WM_ACTIVATEAPP                  0x001C\n#define LANG_ALBANIAN                   0x1c\n#define VK_NONCONVERT                   0x1D\n#define WM_FONTCHANGE                   0x001D\n#define LANG_SWEDISH                    0x1d\n#define VK_ACCEPT                       0x1E\n#define WM_TIMECHANGE                   0x001E\n#define LANG_THAI                       0x1e\n#define VK_MODECHANGE                   0x1F\n#define WM_CANCELMODE                   0x001F\n#define LANG_TURKISH                    0x1f\n#define VK_SPACE                        0x20\n#define WM_SETCURSOR                    0x0020\n#define WVR_ALIGNLEFT                   0x0020\n#define MK_XBUTTON1                     0x0020\n#define CS_OWNDC                        0x0020\n#define TBSTYLE_NOPREFIX                0x0020\n#define TTS_NOFADE                      0x20\n#define TBS_ENABLESELRANGE              0x0020\n#define UDS_ARROWKEYS                   0x0020\n#define LVS_SORTDESCENDING              0x0020\n#define TVS_SHOWSELALWAYS               0x0020\n#define TCS_FORCELABELLEFT              0x0020\n#define DTS_RIGHTALIGN                  0x0020\n#define NFS_USEFONTASSOC                0x0020\n#define LANG_URDU                       0x20\n#define VK_PRIOR                        0x21\n#define WM_MOUSEACTIVATE                0x0021\n#define LANG_INDONESIAN                 0x21\n#define VK_NEXT                         0x22\n#define WM_CHILDACTIVATE                0x0022\n#define LANG_UKRAINIAN                  0x22\n#define VK_END                          0x23\n#define WM_QUEUESYNC                    0x0023\n#define LANG_BELARUSIAN                 0x23\n#define VK_HOME                         0x24\n#define WM_GETMINMAXINFO                0x0024\n#define LANG_SLOVENIAN                  0x24\n#define VK_LEFT                         0x25\n#define LANG_ESTONIAN                   0x25\n#define VK_UP                           0x26\n#define WM_PAINTICON                    0x0026\n#define LANG_LATVIAN                    0x26\n#define VK_RIGHT                        0x27\n#define WM_ICONERASEBKGND               0x0027\n#define LANG_LITHUANIAN                 0x27\n#define VK_DOWN                         0x28\n#define WM_NEXTDLGCTL                   0x0028\n#define LANG_TAJIK                      0x28\n#define VK_SELECT                       0x29\n#define LANG_FARSI                      0x29\n#define LANG_PERSIAN                    0x29\n#define VK_PRINT                        0x2A\n#define WM_SPOOLERSTATUS                0x002A\n#define LANG_VIETNAMESE                 0x2a\n#define VK_EXECUTE                      0x2B\n#define WM_DRAWITEM                     0x002B\n#define LANG_ARMENIAN                   0x2b\n#define VK_SNAPSHOT                     0x2C\n#define WM_MEASUREITEM                  0x002C\n#define LANG_AZERI                      0x2c\n#define VK_INSERT                       0x2D\n#define WM_DELETEITEM                   0x002D\n#define LANG_BASQUE                     0x2d\n#define VK_DELETE                       0x2E\n#define WM_VKEYTOITEM                   0x002E\n#define LANG_LOWER_SORBIAN              0x2e\n#define LANG_UPPER_SORBIAN              0x2e\n#define VK_HELP                         0x2F\n#define WM_CHARTOITEM                   0x002F\n#define LANG_MACEDONIAN                 0x2f\n#define WM_SETFONT                      0x0030\n#define WM_GETFONT                      0x0031\n#define WM_SETHOTKEY                    0x0032\n#define LANG_TSWANA                     0x32\n#define WM_GETHOTKEY                    0x0033\n#define LANG_XHOSA                      0x34\n#define LANG_ZULU                       0x35\n#define LANG_AFRIKAANS                  0x36\n#define WM_QUERYDRAGICON                0x0037\n#define LANG_GEORGIAN                   0x37\n#define LANG_FAEROESE                   0x38\n#define WM_COMPAREITEM                  0x0039\n#define LANG_HINDI                      0x39\n#define LANG_MALTESE                    0x3a\n#define LANG_SAMI                       0x3b\n#define LANG_IRISH                      0x3c\n#define WM_GETOBJECT                    0x003D\n#define LANG_MALAY                      0x3e\n#define LANG_KAZAK                      0x3f\n#define WVR_ALIGNBOTTOM                 0x0040\n#define MK_XBUTTON2                     0x0040\n#define CS_CLASSDC                      0x0040\n#define HDS_DRAGDROP                    0x0040\n#define BTNS_SHOWTEXT                   0x0040\n#define TTS_BALLOON                     0x40\n#define TBS_FIXEDLENGTH                 0x0040\n#define UDS_HORZ                        0x0040\n#define LVS_SHAREIMAGELISTS             0x0040\n#define TVS_RTLREADING                  0x0040\n#define TCS_HOTTRACK                    0x0040\n#define MCS_NOTRAILINGDATES             0x0040\n#define LANG_KYRGYZ                     0x40\n#define WM_COMPACTING                   0x0041\n#define LANG_SWAHILI                    0x41\n#define LANG_TURKMEN                    0x42\n#define LANG_UZBEK                      0x43\n#define WM_COMMNOTIFY                   0x0044\n#define LANG_TATAR                      0x44\n#define LANG_BENGALI                    0x45\n#define WM_WINDOWPOSCHANGING            0x0046\n#define LANG_PUNJABI                    0x46\n#define WM_WINDOWPOSCHANGED             0x0047\n#define LANG_GUJARATI                   0x47\n#define WM_POWER                        0x0048\n#define LANG_ORIYA                      0x48\n#define LANG_TAMIL                      0x49\n#define WM_COPYDATA                     0x004A\n#define LANG_TELUGU                     0x4a\n#define WM_CANCELJOURNAL                0x004B\n#define LANG_KANNADA                    0x4b\n#define LANG_MALAYALAM                  0x4c\n#define LANG_ASSAMESE                   0x4d\n#define WM_NOTIFY                       0x004E\n#define LANG_MARATHI                    0x4e\n#define LANG_SANSKRIT                   0x4f\n#define WM_INPUTLANGCHANGEREQUEST       0x0050\n#define LANG_MONGOLIAN                  0x50\n#define WM_INPUTLANGCHANGE              0x0051\n#define LANG_TIBETAN                    0x51\n#define WM_TCARD                        0x0052\n#define LANG_WELSH                      0x52\n#define WM_HELP                         0x0053\n#define LANG_KHMER                      0x53\n#define WM_USERCHANGED                  0x0054\n#define LANG_LAO                        0x54\n#define WM_NOTIFYFORMAT                 0x0055\n#define LANG_GALICIAN                   0x56\n#define LANG_KONKANI                    0x57\n#define LANG_MANIPURI                   0x58\n#define LANG_SINDHI                     0x59\n#define LANG_SYRIAC                     0x5a\n#define VK_LWIN                         0x5B\n#define LANG_SINHALESE                  0x5b\n#define VK_RWIN                         0x5C\n#define VK_APPS                         0x5D\n#define LANG_INUKTITUT                  0x5d\n#define LANG_AMHARIC                    0x5e\n#define VK_SLEEP                        0x5F\n#define LANG_TAMAZIGHT                  0x5f\n#define VK_NUMPAD0                      0x60\n#define LANG_KASHMIRI                   0x60\n#define VK_NUMPAD1                      0x61\n#define LANG_NEPALI                     0x61\n#define VK_NUMPAD2                      0x62\n#define LANG_FRISIAN                    0x62\n#define VK_NUMPAD3                      0x63\n#define LANG_PASHTO                     0x63\n#define VK_NUMPAD4                      0x64\n#define LANG_FILIPINO                   0x64\n#define VS_USER_DEFINED                 100\n#define VK_NUMPAD5                      0x65\n#define LANG_DIVEHI                     0x65\n#define VK_NUMPAD6                      0x66\n#define VK_NUMPAD7                      0x67\n#define VK_NUMPAD8                      0x68\n#define LANG_HAUSA                      0x68\n#define VK_NUMPAD9                      0x69\n#define VK_MULTIPLY                     0x6A\n#define LANG_YORUBA                     0x6a\n#define VK_ADD                          0x6B\n#define LANG_QUECHUA                    0x6b\n#define VK_SEPARATOR                    0x6C\n#define LANG_SOTHO                      0x6c\n#define VK_SUBTRACT                     0x6D\n#define LANG_BASHKIR                    0x6d\n#define VK_DECIMAL                      0x6E\n#define LANG_LUXEMBOURGISH              0x6e\n#define VK_DIVIDE                       0x6F\n#define LANG_GREENLANDIC                0x6f\n#define VK_F1                           0x70\n#define LANG_IGBO                       0x70\n#define VK_F2                           0x71\n#define VK_F3                           0x72\n#define VK_F4                           0x73\n#define LANG_TIGRIGNA                   0x73\n#define VK_F5                           0x74\n#define VK_F6                           0x75\n#define VK_F7                           0x76\n#define VK_F8                           0x77\n#define VK_F9                           0x78\n#define WHEEL_DELTA                     120\n#define LANG_YI                         0x78\n#define VK_F10                          0x79\n#define VK_F11                          0x7A\n#define LANG_MAPUDUNGUN                 0x7a\n#define VK_F12                          0x7B\n#define WM_CONTEXTMENU                  0x007B\n#define VK_F13                          0x7C\n#define WM_STYLECHANGING                0x007C\n#define LANG_MOHAWK                     0x7c\n#define VK_F14                          0x7D\n#define WM_STYLECHANGED                 0x007D\n#define VK_F15                          0x7E\n#define WM_DISPLAYCHANGE                0x007E\n#define LANG_BRETON                     0x7e\n#define VK_F16                          0x7F\n#define WM_GETICON                      0x007F\n#define LANG_INVARIANT                  0x7f\n#define VK_F17                          0x80\n#define WM_SETICON                      0x0080\n#define WVR_ALIGNRIGHT                  0x0080\n#define CS_PARENTDC                     0x0080\n#define CF_OWNERDISPLAY                 0x0080\n#define HDS_FULLDRAG                    0x0080\n#define BTNS_WHOLEDROPDOWN              0x0080\n#define TTS_CLOSE                       0x80\n#define TBS_NOTHUMB                     0x0080\n#define UDS_NOTHOUSANDS                 0x0080\n#define LVS_NOLABELWRAP                 0x0080\n#define TVS_NOTOOLTIPS                  0x0080\n#define TCS_VERTICAL                    0x0080\n#define MCS_SHORTDAYSOFWEEK             0x0080\n#define LANG_UIGHUR                     0x80\n#define VK_F18                          0x81\n#define WM_NCCREATE                     0x0081\n#define CF_DSPTEXT                      0x0081\n#define LANG_MAORI                      0x81\n#define VK_F19                          0x82\n#define WM_NCDESTROY                    0x0082\n#define CF_DSPBITMAP                    0x0082\n#define LANG_OCCITAN                    0x82\n#define VK_F20                          0x83\n#define WM_NCCALCSIZE                   0x0083\n#define CF_DSPMETAFILEPICT              0x0083\n#define LANG_CORSICAN                   0x83\n#define VK_F21                          0x84\n#define WM_NCHITTEST                    0x0084\n#define LANG_ALSATIAN                   0x84\n#define VK_F22                          0x85\n#define WM_NCPAINT                      0x0085\n#define LANG_YAKUT                      0x85\n#define VK_F23                          0x86\n#define WM_NCACTIVATE                   0x0086\n#define LANG_KICHE                      0x86\n#define VK_F24                          0x87\n#define WM_GETDLGCODE                   0x0087\n#define LANG_KINYARWANDA                0x87\n#define WM_SYNCPAINT                    0x0088\n#define LANG_WOLOF                      0x88\n#define LANG_DARI                       0x8c\n#define CF_DSPENHMETAFILE               0x008E\n#define VK_NUMLOCK                      0x90\n#define VK_SCROLL                       0x91\n#define VK_OEM_NEC_EQUAL                0x92\n#define VK_OEM_FJ_JISHO                 0x92\n#define VK_OEM_FJ_MASSHOU               0x93\n#define VK_OEM_FJ_TOUROKU               0x94\n#define VK_OEM_FJ_LOYA                  0x95\n#define VK_OEM_FJ_ROYA                  0x96\n#define VK_LSHIFT                       0xA0\n#define WM_NCMOUSEMOVE                  0x00A0\n#define VK_RSHIFT                       0xA1\n#define WM_NCLBUTTONDOWN                0x00A1\n#define VK_LCONTROL                     0xA2\n#define WM_NCLBUTTONUP                  0x00A2\n#define VK_RCONTROL                     0xA3\n#define WM_NCLBUTTONDBLCLK              0x00A3\n#define VK_LMENU                        0xA4\n#define WM_NCRBUTTONDOWN                0x00A4\n#define VK_RMENU                        0xA5\n#define WM_NCRBUTTONUP                  0x00A5\n#define VK_BROWSER_BACK                 0xA6\n#define WM_NCRBUTTONDBLCLK              0x00A6\n#define VK_BROWSER_FORWARD              0xA7\n#define WM_NCMBUTTONDOWN                0x00A7\n#define VK_BROWSER_REFRESH              0xA8\n#define WM_NCMBUTTONUP                  0x00A8\n#define VK_BROWSER_STOP                 0xA9\n#define WM_NCMBUTTONDBLCLK              0x00A9\n#define VK_BROWSER_SEARCH               0xAA\n#define VK_BROWSER_FAVORITES            0xAB\n#define WM_NCXBUTTONDOWN                0x00AB\n#define VK_BROWSER_HOME                 0xAC\n#define WM_NCXBUTTONUP                  0x00AC\n#define VK_VOLUME_MUTE                  0xAD\n#define WM_NCXBUTTONDBLCLK              0x00AD\n#define VK_VOLUME_DOWN                  0xAE\n#define VK_VOLUME_UP                    0xAF\n#define VK_MEDIA_NEXT_TRACK             0xB0\n#define EM_GETSEL                       0x00B0\n#define VK_MEDIA_PREV_TRACK             0xB1\n#define EM_SETSEL                       0x00B1\n#define VK_MEDIA_STOP                   0xB2\n#define EM_GETRECT                      0x00B2\n#define VK_MEDIA_PLAY_PAUSE             0xB3\n#define EM_SETRECT                      0x00B3\n#define VK_LAUNCH_MAIL                  0xB4\n#define EM_SETRECTNP                    0x00B4\n#define VK_LAUNCH_MEDIA_SELECT          0xB5\n#define EM_SCROLL                       0x00B5\n#define VK_LAUNCH_APP1                  0xB6\n#define EM_LINESCROLL                   0x00B6\n#define VK_LAUNCH_APP2                  0xB7\n#define EM_SCROLLCARET                  0x00B7\n#define EM_GETMODIFY                    0x00B8\n#define EM_SETMODIFY                    0x00B9\n#define VK_OEM_1                        0xBA\n#define EM_GETLINECOUNT                 0x00BA\n#define VK_OEM_PLUS                     0xBB\n#define EM_LINEINDEX                    0x00BB\n#define VK_OEM_COMMA                    0xBC\n#define EM_SETHANDLE                    0x00BC\n#define VK_OEM_MINUS                    0xBD\n#define EM_GETHANDLE                    0x00BD\n#define VK_OEM_PERIOD                   0xBE\n#define EM_GETTHUMB                     0x00BE\n#define VK_OEM_2                        0xBF\n#define VK_OEM_3                        0xC0\n#define EM_LINELENGTH                   0x00C1\n#define EM_REPLACESEL                   0x00C2\n#define EM_GETLINE                      0x00C4\n#define EM_LIMITTEXT                    0x00C5\n#define EM_CANUNDO                      0x00C6\n#define EM_UNDO                         0x00C7\n#define EM_FMTLINES                     0x00C8\n#define EM_LINEFROMCHAR                 0x00C9\n#define EM_SETTABSTOPS                  0x00CB\n#define EM_SETPASSWORDCHAR              0x00CC\n#define EM_EMPTYUNDOBUFFER              0x00CD\n#define EM_GETFIRSTVISIBLELINE          0x00CE\n#define EM_SETREADONLY                  0x00CF\n#define EM_SETWORDBREAKPROC             0x00D0\n#define EM_GETWORDBREAKPROC             0x00D1\n#define EM_GETPASSWORDCHAR              0x00D2\n#define EM_SETMARGINS                   0x00D3\n#define EM_GETMARGINS                   0x00D4\n#define EM_GETLIMITTEXT                 0x00D5\n#define EM_POSFROMCHAR                  0x00D6\n#define EM_CHARFROMPOS                  0x00D7\n#define EM_SETIMESTATUS                 0x00D8\n#define EM_GETIMESTATUS                 0x00D9\n#define VK_OEM_4                        0xDB\n#define VK_OEM_5                        0xDC\n#define VK_OEM_6                        0xDD\n#define VK_OEM_7                        0xDE\n#define VK_OEM_8                        0xDF\n#define VK_OEM_AX                       0xE1\n#define VK_OEM_102                      0xE2\n#define VK_ICO_HELP                     0xE3\n#define VK_ICO_00                       0xE4\n#define VK_PROCESSKEY                   0xE5\n#define VK_ICO_CLEAR                    0xE6\n#define VK_PACKET                       0xE7\n#define VK_OEM_RESET                    0xE9\n#define VK_OEM_JUMP                     0xEA\n#define VK_OEM_PA1                      0xEB\n#define VK_OEM_PA2                      0xEC\n#define VK_OEM_PA3                      0xED\n#define VK_OEM_WSCTRL                   0xEE\n#define VK_OEM_CUSEL                    0xEF\n#define VK_OEM_ATTN                     0xF0\n#define BM_GETCHECK                     0x00F0\n#define VK_OEM_FINISH                   0xF1\n#define BM_SETCHECK                     0x00F1\n#define VK_OEM_COPY                     0xF2\n#define BM_GETSTATE                     0x00F2\n#define VK_OEM_AUTO                     0xF3\n#define BM_SETSTATE                     0x00F3\n#define VK_OEM_ENLW                     0xF4\n#define BM_SETSTYLE                     0x00F4\n#define VK_OEM_BACKTAB                  0xF5\n#define BM_CLICK                        0x00F5\n#define VK_ATTN                         0xF6\n#define BM_GETIMAGE                     0x00F6\n#define VK_CRSEL                        0xF7\n#define BM_SETIMAGE                     0x00F7\n#define VK_EXSEL                        0xF8\n#define VK_EREOF                        0xF9\n#define VK_PLAY                         0xFA\n#define VK_ZOOM                         0xFB\n#define VK_NONAME                       0xFC\n#define VK_PA1                          0xFD\n#define VK_OEM_CLEAR                    0xFE\n#define WM_KEYFIRST                     0x0100\n#define WM_KEYDOWN                      0x0100\n#define WVR_HREDRAW                     0x0100\n#define HDS_FILTERBAR                   0x0100\n#define TBSTYLE_TOOLTIPS                0x0100\n#define RBS_TOOLTIPS                    0x00000100\n#define SBARS_SIZEGRIP                  0x0100\n#define TBS_TOOLTIPS                    0x0100\n#define UDS_HOTTRACK                    0x0100\n#define LVS_AUTOARRANGE                 0x0100\n#define TVS_CHECKBOXES                  0x0100\n#define TCS_BUTTONS                     0x0100\n#define MCS_NOSELCHANGEONNAV            0x0100\n#define WM_KEYUP                        0x0101\n#define WM_CHAR                         0x0102\n#define WM_DEADCHAR                     0x0103\n#define WM_SYSKEYDOWN                   0x0104\n#define WM_SYSKEYUP                     0x0105\n#define WM_SYSCHAR                      0x0106\n#define WM_SYSDEADCHAR                  0x0107\n#define WM_KEYLAST                      0x0108\n#define WM_IME_STARTCOMPOSITION         0x010D\n#define WM_IME_ENDCOMPOSITION           0x010E\n#define WM_IME_COMPOSITION              0x010F\n#define WM_IME_KEYLAST                  0x010F\n#define WM_INITDIALOG                   0x0110\n#define WM_COMMAND                      0x0111\n#define WM_SYSCOMMAND                   0x0112\n#define WM_TIMER                        0x0113\n#define WM_HSCROLL                      0x0114\n#define WM_VSCROLL                      0x0115\n#define WM_INITMENU                     0x0116\n#define WM_INITMENUPOPUP                0x0117\n#define WM_MENUSELECT                   0x011F\n#define WM_MENUCHAR                     0x0120\n#define WM_ENTERIDLE                    0x0121\n#define WM_MENURBUTTONUP                0x0122\n#define WM_MENUDRAG                     0x0123\n#define WM_MENUGETOBJECT                0x0124\n#define WM_UNINITMENUPOPUP              0x0125\n#define WM_MENUCOMMAND                  0x0126\n#define WM_CHANGEUISTATE                0x0127\n#define WM_UPDATEUISTATE                0x0128\n#define WM_QUERYUISTATE                 0x0129\n#define WM_CTLCOLORMSGBOX               0x0132\n#define WM_CTLCOLOREDIT                 0x0133\n#define WM_CTLCOLORLISTBOX              0x0134\n#define WM_CTLCOLORBTN                  0x0135\n#define WM_CTLCOLORDLG                  0x0136\n#define WM_CTLCOLORSCROLLBAR            0x0137\n#define WM_CTLCOLORSTATIC               0x0138\n#define MN_GETHMENU                     0x01E1\n#define WM_MOUSEFIRST                   0x0200\n#define WM_MOUSEMOVE                    0x0200\n#define WVR_VREDRAW                     0x0200\n#define CS_NOCLOSE                      0x0200\n#define CF_PRIVATEFIRST                 0x0200\n#define TBSTYLE_WRAPABLE                0x0200\n#define RBS_VARHEIGHT                   0x00000200\n#define TBS_REVERSED                    0x0200\n#define LVS_EDITLABELS                  0x0200\n#define TVS_TRACKSELECT                 0x0200\n#define TCS_MULTILINE                   0x0200\n#define WM_LBUTTONDOWN                  0x0201\n#define WM_LBUTTONUP                    0x0202\n#define WM_LBUTTONDBLCLK                0x0203\n#define WM_RBUTTONDOWN                  0x0204\n#define WM_RBUTTONUP                    0x0205\n#define WM_RBUTTONDBLCLK                0x0206\n#define WM_MBUTTONDOWN                  0x0207\n#define WM_MBUTTONUP                    0x0208\n#define WM_MBUTTONDBLCLK                0x0209\n#define WM_MOUSEWHEEL                   0x020A\n#define WM_XBUTTONDOWN                  0x020B\n#define WM_XBUTTONUP                    0x020C\n#define WM_XBUTTONDBLCLK                0x020D\n#define WM_MOUSELAST                    0x020D\n#define WM_PARENTNOTIFY                 0x0210\n#define WM_ENTERMENULOOP                0x0211\n#define WM_EXITMENULOOP                 0x0212\n#define WM_NEXTMENU                     0x0213\n#define WM_SIZING                       0x0214\n#define WM_CAPTURECHANGED               0x0215\n#define WM_MOVING                       0x0216\n#define WM_POWERBROADCAST               0x0218\n#define WM_DEVICECHANGE                 0x0219\n#define WM_MDICREATE                    0x0220\n#define WM_MDIDESTROY                   0x0221\n#define WM_MDIACTIVATE                  0x0222\n#define WM_MDIRESTORE                   0x0223\n#define WM_MDINEXT                      0x0224\n#define WM_MDIMAXIMIZE                  0x0225\n#define WM_MDITILE                      0x0226\n#define WM_MDICASCADE                   0x0227\n#define WM_MDIICONARRANGE               0x0228\n#define WM_MDIGETACTIVE                 0x0229\n#define WM_MDISETMENU                   0x0230\n#define WM_ENTERSIZEMOVE                0x0231\n#define WM_EXITSIZEMOVE                 0x0232\n#define WM_DROPFILES                    0x0233\n#define WM_MDIREFRESHMENU               0x0234\n#define WM_IME_SETCONTEXT               0x0281\n#define WM_IME_NOTIFY                   0x0282\n#define WM_IME_CONTROL                  0x0283\n#define WM_IME_COMPOSITIONFULL          0x0284\n#define WM_IME_SELECT                   0x0285\n#define WM_IME_CHAR                     0x0286\n#define WM_IME_REQUEST                  0x0288\n#define WM_IME_KEYDOWN                  0x0290\n#define WM_IME_KEYUP                    0x0291\n#define WM_NCMOUSEHOVER                 0x02A0\n#define WM_MOUSEHOVER                   0x02A1\n#define WM_NCMOUSELEAVE                 0x02A2\n#define WM_MOUSELEAVE                   0x02A3\n#define CF_PRIVATELAST                  0x02FF\n#define WM_CUT                          0x0300\n#define CF_GDIOBJFIRST                  0x0300\n#define WM_COPY                         0x0301\n#define WM_PASTE                        0x0302\n#define WM_CLEAR                        0x0303\n#define WM_UNDO                         0x0304\n#define WM_RENDERFORMAT                 0x0305\n#define WM_RENDERALLFORMATS             0x0306\n#define WM_DESTROYCLIPBOARD             0x0307\n#define WM_DRAWCLIPBOARD                0x0308\n#define WM_PAINTCLIPBOARD               0x0309\n#define WM_VSCROLLCLIPBOARD             0x030A\n#define WM_SIZECLIPBOARD                0x030B\n#define WM_ASKCBFORMATNAME              0x030C\n#define WM_CHANGECBCHAIN                0x030D\n#define WM_HSCROLLCLIPBOARD             0x030E\n#define WM_QUERYNEWPALETTE              0x030F\n#define WM_PALETTEISCHANGING            0x0310\n#define WM_PALETTECHANGED               0x0311\n#define WM_HOTKEY                       0x0312\n#define WM_PRINT                        0x0317\n#define WM_PRINTCLIENT                  0x0318\n#define WM_APPCOMMAND                   0x0319\n#define WM_HANDHELDFIRST                0x0358\n#define WM_HANDHELDLAST                 0x035F\n#define WM_AFXFIRST                     0x0360\n#define WM_AFXLAST                      0x037F\n#define WM_PENWINFIRST                  0x0380\n#define WM_PENWINLAST                   0x038F\n#define WM_DDE_FIRST                    0x03E0\n#define CF_GDIOBJLAST                   0x03FF\n#define WM_USER                         0x0400\n#define WVR_VALIDRECTS                  0x0400\n#define TBSTYLE_ALTDRAG                 0x0400\n#define RBS_BANDBORDERS                 0x00000400\n#define TBS_DOWNISLEFT                  0x0400\n#define LVS_OWNERDRAWFIXED              0x0400\n#define TVS_SINGLEEXPAND                0x0400\n#define TCS_FIXEDWIDTH                  0x0400\n#define ctlFirst                        0x0400\n#define psh1                            0x0400\n#define psh2                            0x0401\n#define psh3                            0x0402\n#define psh4                            0x0403\n#define psh5                            0x0404\n#define psh6                            0x0405\n#define psh7                            0x0406\n#define psh8                            0x0407\n#define psh9                            0x0408\n#define psh10                           0x0409\n#define psh11                           0x040a\n#define psh12                           0x040b\n#define psh13                           0x040c\n#define psh14                           0x040d\n#define psh15                           0x040e\n#define psh16                           0x040f\n#define _WIN32_WINDOWS                  0x0410\n#define chx1                            0x0410\n#define chx2                            0x0411\n#define chx3                            0x0412\n#define chx4                            0x0413\n#define chx5                            0x0414\n#define chx6                            0x0415\n#define chx7                            0x0416\n#define chx8                            0x0417\n#define chx9                            0x0418\n#define chx10                           0x0419\n#define chx11                           0x041a\n#define chx12                           0x041b\n#define chx13                           0x041c\n#define chx14                           0x041d\n#define chx15                           0x041e\n#define chx16                           0x041f\n#define rad1                            0x0420\n#define rad2                            0x0421\n#define rad3                            0x0422\n#define rad4                            0x0423\n#define rad5                            0x0424\n#define rad6                            0x0425\n#define rad7                            0x0426\n#define rad8                            0x0427\n#define rad9                            0x0428\n#define rad10                           0x0429\n#define rad11                           0x042a\n#define rad12                           0x042b\n#define rad13                           0x042c\n#define rad14                           0x042d\n#define rad15                           0x042e\n#define rad16                           0x042f\n#define grp1                            0x0430\n#define grp2                            0x0431\n#define grp3                            0x0432\n#define grp4                            0x0433\n#define frm1                            0x0434\n#define frm2                            0x0435\n#define frm3                            0x0436\n#define frm4                            0x0437\n#define rct1                            0x0438\n#define rct2                            0x0439\n#define rct3                            0x043a\n#define rct4                            0x043b\n#define ico1                            0x043c\n#define ico2                            0x043d\n#define ico3                            0x043e\n#define ico4                            0x043f\n#define stc1                            0x0440\n#define stc2                            0x0441\n#define stc3                            0x0442\n#define stc4                            0x0443\n#define stc5                            0x0444\n#define stc6                            0x0445\n#define stc7                            0x0446\n#define stc8                            0x0447\n#define stc9                            0x0448\n#define stc10                           0x0449\n#define stc11                           0x044a\n#define stc12                           0x044b\n#define stc13                           0x044c\n#define stc14                           0x044d\n#define stc15                           0x044e\n#define stc16                           0x044f\n#define stc17                           0x0450\n#define stc18                           0x0451\n#define stc19                           0x0452\n#define stc20                           0x0453\n#define stc21                           0x0454\n#define stc22                           0x0455\n#define stc23                           0x0456\n#define stc24                           0x0457\n#define stc25                           0x0458\n#define stc26                           0x0459\n#define stc27                           0x045a\n#define stc28                           0x045b\n#define stc29                           0x045c\n#define stc30                           0x045d\n#define stc31                           0x045e\n#define stc32                           0x045f\n#define lst1                            0x0460\n#define lst2                            0x0461\n#define lst3                            0x0462\n#define lst4                            0x0463\n#define lst5                            0x0464\n#define lst6                            0x0465\n#define lst7                            0x0466\n#define lst8                            0x0467\n#define lst9                            0x0468\n#define lst10                           0x0469\n#define lst11                           0x046a\n#define lst12                           0x046b\n#define lst13                           0x046c\n#define lst14                           0x046d\n#define lst15                           0x046e\n#define lst16                           0x046f\n#define cmb1                            0x0470\n#define cmb2                            0x0471\n#define cmb3                            0x0472\n#define cmb4                            0x0473\n#define cmb5                            0x0474\n#define cmb6                            0x0475\n#define cmb7                            0x0476\n#define cmb8                            0x0477\n#define cmb9                            0x0478\n#define cmb10                           0x0479\n#define cmb11                           0x047a\n#define cmb12                           0x047b\n#define cmb13                           0x047c\n#define cmb14                           0x047d\n#define cmb15                           0x047e\n#define cmb16                           0x047f\n#define edt1                            0x0480\n#define edt2                            0x0481\n#define edt3                            0x0482\n#define edt4                            0x0483\n#define edt5                            0x0484\n#define edt6                            0x0485\n#define edt7                            0x0486\n#define edt8                            0x0487\n#define edt9                            0x0488\n#define edt10                           0x0489\n#define edt11                           0x048a\n#define edt12                           0x048b\n#define edt13                           0x048c\n#define edt14                           0x048d\n#define edt15                           0x048e\n#define edt16                           0x048f\n#define scr1                            0x0490\n#define scr2                            0x0491\n#define scr3                            0x0492\n#define scr4                            0x0493\n#define scr5                            0x0494\n#define scr6                            0x0495\n#define scr7                            0x0496\n#define scr8                            0x0497\n#define ctl1                            0x04A0\n#define ctlLast                         0x04ff\n#define WINVER                          0x0500\n#define _WIN32_WINNT                    0x0500\n#define _WIN32_IE                       0x0501\n#define FILEOPENORD                     1536\n#define MULTIFILEOPENORD                1537\n#define PRINTDLGORD                     1538\n#define PRNSETUPDLGORD                  1539\n#define FINDDLGORD                      1540\n#define REPLACEDLGORD                   1541\n#define FONTDLGORD                      1542\n#define FORMATDLGORD31                  1543\n#define FORMATDLGORD30                  1544\n#define RUNDLGORD                       1545\n#define PAGESETUPDLGORD                 1546\n#define NEWFILEOPENORD                  1547\n#define PRINTDLGEXORD                   1549\n#define PAGESETUPDLGORDMOTIF            1550\n#define COLORMGMTDLGORD                 1551\n#define NEWFILEOPENV2ORD                1552\n#define NEWFILEOPENV3ORD                1553\n#define CS_SAVEBITS                     0x0800\n#define TBSTYLE_FLAT                    0x0800\n#define RBS_FIXEDORDER                  0x00000800\n#define SBARS_TOOLTIPS                  0x0800\n#define SBT_TOOLTIPS                    0x0800\n#define LVS_ALIGNLEFT                   0x0800\n#define TVS_INFOTIP                     0x0800\n#define TCS_RAGGEDRIGHT                 0x0800\n#define LVS_ALIGNMASK                   0x0c00\n#define CS_BYTEALIGNCLIENT              0x1000\n#define TBSTYLE_LIST                    0x1000\n#define RBS_REGISTERDROP                0x00001000\n#define TBS_TRANSPARENTBKGND            0x1000\n#define LVS_OWNERDATA                   0x1000\n#define TVS_FULLROWSELECT               0x1000\n#define TCS_FOCUSONBUTTONDOWN           0x1000\n#define CS_BYTEALIGNWINDOW              0x2000\n#define TBSTYLE_CUSTOMERASE             0x2000\n#define RBS_AUTOSIZE                    0x00002000\n#define LVS_NOSCROLL                    0x2000\n#define TVS_NOSCROLL                    0x2000\n#define TCS_OWNERDRAWFIXED              0x2000\n#define CS_GLOBALCLASS                  0x4000\n#define TBSTYLE_REGISTERDROP            0x4000\n#define RBS_VERTICALGRIPPER             0x00004000\n#define LVS_NOCOLUMNHEADER              0x4000\n#define TVS_NONEVENHEIGHT               0x4000\n#define TCS_TOOLTIPS                    0x4000\n#define IDH_NO_HELP                     28440\n#define IDH_MISSING_CONTEXT             28441\n#define IDH_GENERIC_HELP_BUTTON         28442\n#define IDH_OK                          28443\n#define IDH_CANCEL                      28444\n#define IDH_HELP                        28445\n#define LANG_BOSNIAN_NEUTRAL            0x781a\n#define LANG_CHINESE_TRADITIONAL        0x7c04\n#define LANG_SERBIAN_NEUTRAL            0x7c1a\n#define OCR_NORMAL                      32512\n#define OIC_SAMPLE                      32512\n#define IDI_APPLICATION                 32512\n#define OCR_IBEAM                       32513\n#define OIC_HAND                        32513\n#define IDI_HAND                        32513\n#define OCR_WAIT                        32514\n#define OIC_QUES                        32514\n#define IDI_QUESTION                    32514\n#define OCR_CROSS                       32515\n#define OIC_BANG                        32515\n#define IDI_EXCLAMATION                 32515\n#define OCR_UP                          32516\n#define OIC_NOTE                        32516\n#define IDI_ASTERISK                    32516\n#define OIC_WINLOGO                     32517\n#define IDI_WINLOGO                     32517\n#define OCR_SIZE                        32640\n#define OCR_ICON                        32641\n#define OCR_SIZENWSE                    32642\n#define OCR_SIZENESW                    32643\n#define OCR_SIZEWE                      32644\n#define OCR_SIZENS                      32645\n#define OCR_SIZEALL                     32646\n#define OCR_ICOCUR                      32647\n#define OCR_NO                          32648\n#define OCR_HAND                        32649\n#define OCR_APPSTARTING                 32650\n#define OBM_LFARROWI                    32734\n#define OBM_RGARROWI                    32735\n#define OBM_DNARROWI                    32736\n#define OBM_UPARROWI                    32737\n#define OBM_COMBO                       32738\n#define OBM_MNARROW                     32739\n#define OBM_LFARROWD                    32740\n#define OBM_RGARROWD                    32741\n#define OBM_DNARROWD                    32742\n#define OBM_UPARROWD                    32743\n#define OBM_RESTORED                    32744\n#define OBM_ZOOMD                       32745\n#define OBM_REDUCED                     32746\n#define OBM_RESTORE                     32747\n#define OBM_ZOOM                        32748\n#define OBM_REDUCE                      32749\n#define OBM_LFARROW                     32750\n#define OBM_RGARROW                     32751\n#define OBM_DNARROW                     32752\n#define OBM_UPARROW                     32753\n#define OBM_CLOSE                       32754\n#define OBM_OLD_RESTORE                 32755\n#define OBM_OLD_ZOOM                    32756\n#define OBM_OLD_REDUCE                  32757\n#define OBM_BTNCORNERS                  32758\n#define OBM_CHECKBOXES                  32759\n#define OBM_CHECK                       32760\n#define OBM_BTSIZE                      32761\n#define OBM_OLD_LFARROW                 32762\n#define OBM_OLD_RGARROW                 32763\n#define OBM_OLD_DNARROW                 32764\n#define OBM_OLD_UPARROW                 32765\n#define OBM_SIZE                        32766\n#define OBM_OLD_CLOSE                   32767\n#define WM_APP                          0x8000\n#define HELP_TCARD                      0x8000\n#define TBSTYLE_TRANSPARENT             0x8000\n#define RBS_DBLCLKTOGGLE                0x00008000\n#define LVS_NOSORTHEADER                0x8000\n#define TVS_NOHSCROLL                   0x8000\n#define TCS_FOCUSNEVER                  0x8000\n#define SC_SIZE                         0xF000\n#define SC_SEPARATOR                    0xF00F\n#define SC_MOVE                         0xF010\n#define SC_MINIMIZE                     0xF020\n#define SC_MAXIMIZE                     0xF030\n#define SC_NEXTWINDOW                   0xF040\n#define SC_PREVWINDOW                   0xF050\n#define SC_CLOSE                        0xF060\n#define SC_VSCROLL                      0xF070\n#define SC_HSCROLL                      0xF080\n#define SC_MOUSEMENU                    0xF090\n#define SC_KEYMENU                      0xF100\n#define SC_ARRANGE                      0xF110\n#define SC_RESTORE                      0xF120\n#define SC_TASKLIST                     0xF130\n#define SC_SCREENSAVE                   0xF140\n#define SC_HOTKEY                       0xF150\n#define SC_DEFAULT                      0xF160\n#define SC_MONITORPOWER                 0xF170\n#define SC_CONTEXTHELP                  0xF180\n#define LVS_TYPESTYLEMASK               0xfc00\n// #define HTERROR                         -2\n// #define PWR_FAIL                        -1\n// #define HTTRANSPARENT                   -1\n\n// Next default values for new objects\n// \n#ifdef APSTUDIO_INVOKED\n#ifndef APSTUDIO_READONLY_SYMBOLS\n#define _APS_NO_MFC                     1\n#define _APS_NEXT_RESOURCE_VALUE        101\n#define _APS_NEXT_COMMAND_VALUE         40001\n#define _APS_NEXT_CONTROL_VALUE         1000\n#define _APS_NEXT_SYMED_VALUE           101\n#endif\n#endif\n//{{NO_DEPENDENCIES}}\r\n// Microsoft Visual C++ generated include file.\r\n// Used by Resource.rc\r\n\r\n// Next default values for new objects\r\n// \r\n#ifdef APSTUDIO_INVOKED\r\n#ifndef APSTUDIO_READONLY_SYMBOLS\r\n#define _APS_NEXT_RESOURCE_VALUE        101\r\n#define _APS_NEXT_COMMAND_VALUE         40001\r\n#define _APS_NEXT_CONTROL_VALUE         1001\r\n#define _APS_NEXT_SYMED_VALUE           101\r\n#endif\r\n#endif\r\n"
        },
        {
          "name": "run.cpp",
          "type": "blob",
          "size": 7.3212890625,
          "content": "﻿// dll injection\n#define _CRT_SECURE_NO_DEPRECATE 1\n#define WINVER 0x500\n#define _WIN32_WINNT 0x500\n#define _WIN32_IE 0x601\n#define WIN32_LEAN_AND_MEAN 1\n#define UNICODE  1\n#define _UNICODE 1\n#include <Windows.h>\n#include <ShellApi.h>\n#include <ComDef.h>\n#include <ShlObj.h>\n#include <ShLwApi.h>\n#include <tchar.h>\n#include \"array.h\"\n#include <strsafe.h>\n\n// _vsnwprintf用\n#include <wchar.h>\t\t\n#include <stdarg.h>\n\n#define _CRTDBG_MAP_ALLOC\n#include <cstdlib>\n#include <malloc.h>\n#include <crtdbg.h>\n\n#define for if(0);else for\n#ifndef _countof\n#define _countof(array)\t\t(sizeof(array) / sizeof((array)[0]))\n#endif\n\n#pragma comment(linker, \"/subsystem:windows,5.0\")\n#pragma comment(lib, \"Kernel32.lib\")\n#pragma comment(lib, \"User32.lib\")\n#pragma comment(lib, \"Shell32.lib\")\n#pragma comment(lib, \"ShLwApi.lib\")\n#pragma comment(lib, \"Ole32.lib\")\n\n#define IDS_USAGE\t\t101\n#define IDS_DLL\t\t\t102\n#define IDC_EXEC\t\t103\n\nstatic void showmsg(LPCSTR msg) {\n\tMessageBoxA(NULL, msg, \"MacType ERROR\", MB_OK | MB_ICONSTOP);\n}\n\nstatic void errmsg(UINT id, DWORD code)\n{\n\tchar  buffer[512];\n\tchar  format[128];\n\tLoadStringA(GetModuleHandleA(NULL), id, format, 128);\n\twnsprintfA(buffer, 512, format, code);\n\tshowmsg(buffer);\n}\n\ninline HRESULT HresultFromLastError()\n{\n\tDWORD dwErr = GetLastError();\n\treturn HRESULT_FROM_WIN32(dwErr);\n}\n\n\n#include \"detours.h\"\n#ifdef _M_IX86\n#pragma comment (lib, \"detours.lib\")\nconst auto MacTypeDll = L\"MacType.dll\";\nconst auto MacTypeDllA = \"MacType.dll\";\n#else\n#pragma comment (lib, \"detours64.lib\")\nconst auto MacTypeDll = L\"MacType64.dll\";\nconst auto MacTypeDllA = \"MacType64.dll\";\n#endif\n\n\nHINSTANCE hinstDLL;\n\n#include <stddef.h>\n#define GetDLLInstance()\t(hinstDLL)\n\n#define _GDIPP_EXE\n#define _GDIPP_RUN_CPP\n//#include \"supinfo.h\"\n\n//#define OLD_PSDK\n\n#ifdef OLD_PSDK\nextern \"C\" {\n\tHRESULT WINAPI _SHILCreateFromPath(LPCWSTR pszPath, LPITEMIDLIST* ppidl, DWORD* rgflnOut)\n\t{\n\t\tif (!pszPath || !ppidl) {\n\t\t\treturn E_INVALIDARG;\n\t\t}\n\n\t\tLPSHELLFOLDER psf;\n\t\tHRESULT hr = ::SHGetDesktopFolder(&psf);\n\t\tif (hr != NOERROR) {\n\t\t\treturn hr;\n\t\t}\n\n\t\tULONG chEaten;\n\t\tLPOLESTR lpszDisplayName = ::StrDupW(pszPath);\n\t\thr = psf->ParseDisplayName(NULL, NULL, lpszDisplayName, &chEaten, ppidl, rgflnOut);\n\t\t::LocalFree(lpszDisplayName);\n\t\tpsf->Release();\n\t\treturn hr;\n\t}\n\n\tvoid WINAPI _SHFree(void* pv)\n\t{\n\t\tif (!pv) {\n\t\t\treturn;\n\t\t}\n\n\t\tLPMALLOC pMalloc = NULL;\n\t\tif (::SHGetMalloc(&pMalloc) == NOERROR) {\n\t\t\tpMalloc->Free(pv);\n\t\t\tpMalloc->Release();\n\t\t}\n\t}\n}\n#else\n#define _SHILCreateFromPath\tSHILCreateFromPath\n#define _SHFree\t\t\t\tSHFree\n#endif\n\n\nbool isX64PE(const TCHAR* file_path) {\n\tHANDLE hFile = CreateFile(file_path, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n\tif (hFile == INVALID_HANDLE_VALUE) {\n\t\tshowmsg(\"Error opening file\");\n\t\treturn false;\n\t}\n\n\tIMAGE_DOS_HEADER dosHeader;\n\tDWORD bytesRead;\n\tif (!ReadFile(hFile, &dosHeader, sizeof(IMAGE_DOS_HEADER), &bytesRead, NULL)) {\n\t\tshowmsg(\"Error reading file\");\n\t\tCloseHandle(hFile);\n\t\treturn false;\n\t}\n\n\t// Check if it's a PE file\n\tif (dosHeader.e_magic != IMAGE_DOS_SIGNATURE) {\n\t\tshowmsg(\"Not a PE file\");\n\t\tCloseHandle(hFile);\n\t\treturn false;\n\t}\n\n\tIMAGE_NT_HEADERS ntHeaders;\n\t// Seek to the PE header offset\n\tSetFilePointer(hFile, dosHeader.e_lfanew, NULL, FILE_BEGIN);\n\tif (!ReadFile(hFile, &ntHeaders, sizeof(IMAGE_NT_HEADERS), &bytesRead, NULL)) {\n\t\tshowmsg(\"Error reading PE header\");\n\t\tCloseHandle(hFile);\n\t\treturn false;\n\t}\n\n\tif (ntHeaders.FileHeader.Machine == IMAGE_FILE_MACHINE_I386) {\n\t\tCloseHandle(hFile);\n\t\treturn false;\n\t}\n\telse if (ntHeaders.FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) {\n\t\tCloseHandle(hFile);\n\t\treturn true;\n\t}\n\telse {\n\t\tCloseHandle(hFile);\n\t\treturn false;\n\t}\n}\n\n\n// １つ目の引数だけファイルとして扱い、実行する。\n//\n// コマンドは こんな感じで連結されます。\n//  exe linkpath linkarg cmdarg2 cmdarg3 cmdarg4 ...\n//\nstatic HRESULT HookAndExecute(int show)\n{\n\tint     argc = 0;\n\tLPWSTR* argv = CommandLineToArgvW(GetCommandLineW(), &argc);\n\tif (!argv) {\n\t\treturn HresultFromLastError();\n\t}\n\tif (argc <= 1) {\n\t\tchar buffer[256];\n\t\tLoadStringA(GetModuleHandleA(NULL), IDS_USAGE, buffer, 256);\n\t\tMessageBoxA(NULL,\n\t\t\tbuffer\n\t\t\t, \"MacType\", MB_OK | MB_ICONINFORMATION);\n\t\tLocalFree(argv);\n\t\treturn S_OK;\n\t}\n\n\n\tint i;\n\tsize_t length = 1;\n\tfor (i = 1; i < argc; i++) {\n\t\tlength += wcslen(argv[i]) + 3;\n\t}\n\n\tLPWSTR cmdline = (WCHAR*)calloc(sizeof(WCHAR), length);\n\tif (!cmdline) {\n\t\tLocalFree(argv);\n\t\treturn E_OUTOFMEMORY;\n\t}\n\n\tLPWSTR p = cmdline;\n\t*p = L'\\0';\n\tfor (i = 1; i < argc; i++) {\n\t\tconst bool dq = !!wcschr(argv[i], L' ');\n\t\tif (dq) {\n\t\t\t*p++ = '\"';\n\t\t\tlength--;\n\t\t}\n\t\tStringCchCopyExW(p, length, argv[i], &p, &length, STRSAFE_NO_TRUNCATION);\n\t\tif (dq) {\n\t\t\t*p++ = '\"';\n\t\t\tlength--;\n\t\t}\n\t\t*p++ = L' ';\n\t\tlength--;\n\t}\n\n\t*CharPrevW(cmdline, p) = L'\\0';\n\n// now we got the full cmdline for external exetuble. let's check if we can hook into it\n#ifdef _M_IX86\n\tif (isX64PE(argv[1])) {\n\t\tShellExecute(NULL, NULL, L\"macloader64.exe\", cmdline, NULL, SW_SHOW);\n\t\treturn S_OK;\n\t}\n#else\n\tif (!isX64PE(argv[1])) {\n\t\tShellExecute(NULL, NULL, L\"macloader.exe\", cmdline, NULL, SW_SHOW);\n\t\treturn S_OK;\n\t}\n#endif\n\n\tWCHAR file[MAX_PATH], dir[MAX_PATH];\n\tGetCurrentDirectoryW(_countof(dir), dir);\n\tStringCchCopyW(file, _countof(file), argv[1]);\n\tif (PathIsRelativeW(file)) {\n\t\tPathCombineW(file, dir, file);\n\t}\n\telse {\n\t\tWCHAR gdippDir[MAX_PATH];\n\t\tGetModuleFileNameW(NULL, gdippDir, _countof(gdippDir));\n\t\tPathRemoveFileSpec(gdippDir);\n\n\t\t// カレントディレクトリがgdi++.exeの置かれているディレクトリと同じだったら、\n\t\t// 起動しようとしているEXEのフルパスから抜き出したディレクトリ名をカレント\n\t\t// ディレクトリとして起動する。(カレントディレクトリがEXEと同じ場所である\n\t\t// 前提で作られているアプリ対策)\n\t\tif (wcscmp(dir, gdippDir) == 0) {\n\t\t\tStringCchCopyW(dir, _countof(dir), argv[1]);\n\t\t\tPathRemoveFileSpec(dir);\n\t\t}\n\t}\n\n#ifdef _DEBUG\n\tif ((GetAsyncKeyState(VK_CONTROL) & 0x8000)\n\t\t&& MessageBoxW(NULL, cmdline, NULL, MB_YESNO) != IDYES) {\n\t\tfree(cmdline);\n\t\treturn NOERROR;\n\t}\n#endif\n\n\n\tPROCESS_INFORMATION processInfo;\n\tSTARTUPINFO startupInfo = { 0 };\n\tstartupInfo.cb = sizeof(startupInfo);\n\n\t// get current directory and append mactype dll \n\tchar path[MAX_PATH] = { 0 };\n\tif (GetModuleFileNameA(NULL, path, _countof(path))) {\n\t\tPathRemoveFileSpecA(path);\n\t\tstrcat(path, \"\\\\\");\n\t}\n\tstrcat(path, MacTypeDllA);\n\n\tauto ret = DetourCreateProcessWithDllEx(NULL, cmdline, NULL, NULL, false, 0, NULL, dir, &startupInfo, &processInfo, path, NULL);\n\n\tfree(cmdline);\n\tLocalFree(argv);\n\targv = NULL;\n\treturn ret ? S_OK : E_ACCESSDENIED;\n}\n\nint WINAPI wWinMain(HINSTANCE ins, HINSTANCE prev, LPWSTR cmd, int show)\n{\n\t_CrtSetDbgFlag(_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) | _CRTDBG_LEAK_CHECK_DF);\n\tOleInitialize(NULL);\n\n\tWCHAR path[MAX_PATH];\n\tif (GetModuleFileNameW(NULL, path, _countof(path))) {\n\t\tPathRemoveFileSpec(path);\n\t\twcscat(path, L\"\\\\\");\n\t\twcscat(path, MacTypeDll);\n\t\t//DONT_RESOLVE_DLL_REFERENCESを指定すると依存関係の解決や\n\t\t//DllMainの呼び出しが行われない\n\t\thinstDLL = LoadLibraryExW(path, NULL, DONT_RESOLVE_DLL_REFERENCES);\n\t}\n\tif (!hinstDLL) {\n\t\terrmsg(IDS_DLL, HresultFromLastError());\n\t}\n\telse {\n\t\tPathRemoveFileSpecW(path);\n\t\tSetCurrentDirectoryW(path);\n\n\t\tHRESULT hr = HookAndExecute(show);\n\t\tif (hr != S_OK) {\n\t\t\terrmsg(IDC_EXEC, hr);\n\t\t}\n\t}\n\n\tOleUninitialize();\n\treturn 0;\n}\n\n//EOF\n"
        },
        {
          "name": "settings.cpp",
          "type": "blob",
          "size": 55.8837890625,
          "content": "#include \"settings.h\"\r\n#include \"strtoken.h\"\r\n#include <math.h>\t//pow\r\n#include \"supinfo.h\"\r\n#include \"fteng.h\"\r\n#include <stdlib.h>\r\n#include <freetype/ftmodapi.h>\r\n#ifdef INFINALITY\r\n#include <freetype/ftenv.h>\r\n#endif\r\n\r\nCControlCenter* g_ControlCenter = NULL;\r\n\r\ninline BOOL IsFolder(LPCTSTR pszPath) {\r\n\treturn pszPath && *pszPath && *(pszPath + wcslen(pszPath) - 1) == '\\\\';\r\n}\r\n\r\nwstring LowerCase(wstring str) {\r\n\ttransform(str.begin(), str.end(), str.begin(), ::tolower);\r\n\treturn str;\r\n}\r\n\r\nconst wstring GetAppDir() {\r\n\tstatic wstring AppDir;\r\n\tif (AppDir.length()) {\r\n\t\treturn AppDir;\r\n\t}\r\n\tWCHAR name[MAX_PATH] = { 0 };\r\n\r\n\tint nSize = GetModuleFileName(NULL, name, MAX_PATH + 1);\r\n\tPathRemoveFileSpec(name);\r\n\tAppDir = wstring(name) + L\"\\\\\"; // path should always end with a \"\\\"\r\n\tAppDir = LowerCase(AppDir);\r\n\treturn AppDir;\r\n}\r\n\r\nCGdippSettings* CGdippSettings::s_pInstance;\r\nCParseIni CGdippSettings::m_Config;\r\nCHashedStringList FontNameCache;\r\n\r\nstatic const TCHAR c_szGeneral[]  = _T(\"General\");\r\nstatic const TCHAR c_szFreeType[] = _T(\"FreeType\");\r\nstatic const TCHAR c_szDirectWrite[] = _T(\"DirectWrite\");\r\n#define HINTING_MIN\t\t\t0\r\n#define HINTING_MAX\t\t\t2\r\n#define AAMODE_MIN\t\t\t-1\r\n#define AAMODE_MAX\t\t\t6\r\n#define GAMMAVALUE_MIN\t\t0.0625f\r\n#define GAMMAVALUE_MAX\t\t20.0f\r\n#define CONTRAST_MIN\t\t0.0625f\r\n#define CONTRAST_MAX\t\t10.0f\r\n#define RENDERWEIGHT_MIN\t0.0625f\r\n#define RENDERWEIGHT_MAX\t10.0f\r\n#define NWEIGHT_MIN\t\t\t-64\r\n#define NWEIGHT_MAX\t\t\t+64\r\n#define BWEIGHT_MIN\t\t\t-32\r\n#define BWEIGHT_MAX\t\t\t+32\r\n#define SLANT_MIN\t\t\t-32\r\n#define SLANT_MAX\t\t\t+32\r\n\r\nCGdippSettings* CGdippSettings::CreateInstance()\r\n{\r\n\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_SETTING);\r\n\tCGdippSettings* pSettings = new CGdippSettings;\r\n\tCGdippSettings* pOldSettings = reinterpret_cast<CGdippSettings*>(InterlockedExchangePointer(reinterpret_cast<void**>(&s_pInstance), pSettings));\r\n\t_ASSERTE(pOldSettings == NULL);\r\n\tint nSize = GetModuleFileName(NULL, pSettings->m_szexeName, MAX_PATH);\r\n\tfor (int i = nSize; i > 0; --i) {\r\n\t\tif (pSettings->m_szexeName[i] == _T('\\\\')) {\r\n\t\t\tStringCchCopy(pSettings->m_szexeName, nSize - i, pSettings->m_szexeName + i + 1);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn pSettings;\r\n}\r\n\r\nvoid CGdippSettings::DestroyInstance()\r\n{\r\n\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_SETTING);\r\n\r\n\tCGdippSettings* pSettings = reinterpret_cast<CGdippSettings*>(InterlockedExchangePointer(reinterpret_cast<void**>(&s_pInstance), NULL));\r\n\tif (pSettings) {\r\n\t\tdelete pSettings;\r\n\t}\r\n}\r\n\r\nCGdippSettings* CGdippSettings::GetInstance()\r\n{\r\n\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_SETTING);\r\n\tCGdippSettings* pSettings = s_pInstance;\r\n\t_ASSERTE(pSettings != NULL);\r\n\r\n\tif (!pSettings->m_bDelayedInit) {\r\n\t\tpSettings->DelayedInit();\r\n\t}\r\n\treturn pSettings;\r\n}\r\n\r\nconst CGdippSettings* CGdippSettings::GetInstanceNoInit()\r\n{\r\n\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_SETTING);\r\n\tCGdippSettings* pSettings = s_pInstance;\r\n\t_ASSERTE(pSettings != NULL);\r\n\treturn pSettings;\r\n}\r\n\r\nvoid CGdippSettings::DelayedInit()\r\n{\r\n\tif (!g_pFTEngine) {\r\n\t\treturn;\r\n\t}\r\n\tif (IsBadCodePtr((FARPROC)RegOpenKeyExW) || *(DWORD_PTR*)RegOpenKeyExW==0)\r\n\t\treturn;\r\n\t/*\r\n\tIn Windows 8, this call will fail in restricted environment\r\n\tif GetDC failed, we are in a restricted environment where features like font subsitutations doesn't work properly.\r\n\tBecause these features requires DC to get the real font name and we don't have access to any DC, even CreateCompatibleDC(null) fails (it will succeed, but DeleteDC will fail)\r\n\tSo it is better exit than doing initialization.\r\n\t*/\r\n\tm_bDelayedInit = true;\r\n\r\n\tHDC hdcScreen = GetDC(NULL);\r\n\tif (!hdcScreen) {\r\n\t\treturn;\t\r\n\t}\t\r\n\r\n\t//ForceChangeFont\r\n\t//if (m_szForceChangeFont[0]) {\r\n\t//\tEnumFontFamilies(hdcScreen, m_szForceChangeFont, EnumFontFamProc, reinterpret_cast<LPARAM>(this));\r\n\t//}\r\n\t//fetch screen dpi\r\n\tm_nScreenDpi = GetDeviceCaps(hdcScreen, LOGPIXELSX);\r\n\tReleaseDC(NULL, hdcScreen);\r\n\r\n// \t//FontLink\r\n// \tif (FontLink()) {\r\n// \t\tm_fontlinkinfo.init();\r\n// \t}\r\n\r\n\r\n\tconst int nTextTuning = _GetFreeTypeProfileInt(_T(\"TextTuning\"), 0, NULL),\r\n\t\tnTextTuningR = _GetFreeTypeProfileInt(_T(\"TextTuningR\"), 0, NULL),\r\n\t\tnTextTuningG = _GetFreeTypeProfileInt(_T(\"TextTuningG\"), 0, NULL),\r\n\t\tnTextTuningB = _GetFreeTypeProfileInt(_T(\"TextTuningB\"), 0, NULL);\r\n\tInitInitTuneTable();\r\n\tInitTuneTable(nTextTuning,  m_nTuneTable);\r\n\tInitTuneTable(nTextTuningR, m_nTuneTableR);\r\n\tInitTuneTable(nTextTuningG, m_nTuneTableG);\r\n\tInitTuneTable(nTextTuningB, m_nTuneTableB);\r\n\tRefreshAlphaTable();\r\n\r\n\t//FontSubstitutes\r\n\tCFontSubstitutesIniArray arrFontSubstitutes;\r\n\twstring names = _T(\"FontSubstitutes@\") + wstring(m_szexeName);\r\n\tif (_IsFreeTypeProfileSectionExists(names.c_str(), m_szFileName))\r\n\t\tAddListFromSection(names.c_str(), m_szFileName, arrFontSubstitutes);\r\n\telse\r\n\t\tAddListFromSection(_T(\"FontSubstitutes\"), m_szFileName, arrFontSubstitutes);\r\n\tm_FontSubstitutesInfo.init(m_nFontSubstitutes, arrFontSubstitutes);\r\n\r\n\tnames = _T(\"Individual@\") + wstring(m_szexeName);\r\n\tif (_IsFreeTypeProfileSectionExists(names.c_str(), NULL))\r\n\t\tAddIndividualFromSection(names.c_str(), NULL, m_arrIndividual);\r\n\telse\r\n\t\tAddIndividualFromSection(_T(\"Individual\"), NULL, m_arrIndividual);\r\n\r\n\tAddExcludeListFromSection(_T(\"Exclude\"), NULL, m_arrExcludeFont);\r\n\tAddExcludeListFromSection(_T(\"Include\"), NULL, m_arrIncludeFont);\t//I know it's include not exclude, but they share the same logic.\r\n\t//WritePrivateProfileString(NULL, NULL, NULL, m_szFileName);\r\n\r\n\t//m_bDelayedInit = true;\r\n\r\n\t//FontLink\r\n\tif (FontLink()) {\r\n\t\tm_fontlinkinfo.init();\r\n\t}\r\n\r\n\t// check wheteher harmony LCD should be used over ClearType\r\n\tFT_LCDMode_Set(freetype_library, this->HarmonyLCD() ? 1 : 0);\r\n\r\n\t// Init LCD settings\r\n\t// this->m_bHarmonyLCDRendering = FT_Library_SetLcdFilter(NULL, FT_LCD_FILTER_NONE) == FT_Err_Unimplemented_Feature; // official method of detecting freetype mode.\r\n\tif (this->HarmonyLCD()) {\r\n\t\tFT_Library_SetLcdFilter(NULL, FT_LCD_FILTER_NONE);\r\n\t\t// Harmony LCD rendering\r\n\t\tif (m_bUseCustomPixelLayout) {\r\n\t\t\tFT_Vector  sub[3] = { { m_arrPixelLayout[0], m_arrPixelLayout[1]}, \r\n\t\t\t\t\t\t\t\t\t{m_arrPixelLayout[2], m_arrPixelLayout[3]},\t \r\n\t\t\t\t\t\t\t\t\t{m_arrPixelLayout[4], m_arrPixelLayout[5]}};\t// custom layout\r\n\t\t\tFT_Library_SetLcdGeometry(freetype_library, sub);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tswitch (this->m_FontSettings.GetAntiAliasMode()) {\r\n\t\t\tcase 0:\r\n\t\t\tcase 1: {\r\n\t\t\t\tFT_Vector  sub[3] = { { 0, 0 }, { 0, 0 },\t { 0, 0 } };\t// gray scale\r\n\t\t\t\tFT_Library_SetLcdGeometry(freetype_library, sub);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 2: //RGB\r\n\t\t\tcase 4: {\r\n\t\t\t\tFT_Vector  sub[3] = { { -21, 0 }, { 0, 0 },\t { 21, 0 } };\r\n\t\t\t\tFT_Library_SetLcdGeometry(freetype_library, sub);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 3:\t//BGR\r\n\t\t\tcase 5: {\r\n\t\t\t\tFT_Vector  sub[3] = { { 21, 0 }, { 0, 0 },\t { -21, 0 } };\r\n\t\t\t\tFT_Library_SetLcdGeometry(freetype_library, sub);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 6: {\r\n\t\t\t\t//Pentile\r\n\t\t\t\tFT_Vector  sub[3] = { {-11, 16}, {-11, -16}, {22, 0} };\r\n\t\t\t\tFT_Library_SetLcdGeometry(freetype_library, sub);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (m_FontSettings.GetAntiAliasMode() > 2)\r\n\t\t\t\tm_FontSettings.SetAntiAliasMode(2);\t// all non-grayscale panel should use DrawLCD routine as its output.\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tint nLcdFilter = LcdFilter();\r\n\t\tif ((int)FT_LCD_FILTER_NONE <= nLcdFilter && nLcdFilter < (int)FT_LCD_FILTER_MAX) {\r\n\t\t\tswitch (GetFontSettings().GetAntiAliasMode()) {\r\n\t\t\tcase 1:\r\n\t\t\tcase 4:\r\n\t\t\tcase 5:\r\n\t\t\t\tnLcdFilter = FT_LCD_FILTER_LIGHT;\t// now we apply a light filter to lcd based on AA mode automatically, unless a custom lcd filter is defined.\r\n\t\t\t}\r\n\t\t\tFT_Library_SetLcdFilter(freetype_library, (FT_LcdFilter)nLcdFilter);\r\n\t\t\tif (UseCustomLcdFilter())\r\n\t\t\t{\r\n\t\t\t\tunsigned char buff[5];\r\n\t\t\t\tmemcpy(buff, LcdFilterWeights(), sizeof(buff));\r\n\t\t\t\tFT_Library_SetLcdFilterWeights(freetype_library, buff);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t//強制フォント\r\n/*\r\n\tLPCTSTR lpszFace = GetForceFontName();\r\n\tif (lpszFace)\r\n\t\tg_pFTEngine->AddFont(lpszFace, FW_NORMAL, false);*/\r\n\r\n\r\n/*\tDWORD dwVersion = GetVersion();\r\n\r\n\tif (m_bDirectWrite && (DWORD)(LOBYTE(LOWORD(dwVersion)))>5)\t//vista or later\r\n\t{\r\n\t\tif (GetModuleHandle(_T(\"d2d1.dll\")))\t//directwrite support\r\n\t\t\tHookD2D1();\r\n\t}*/\r\n}\r\n\r\nbool CGdippSettings::LoadSettings(HINSTANCE hModule)\r\n{\r\n\tCCriticalSectionLock __lock(CCriticalSectionLock::CS_SETTING);\r\n\tint nSize = ::GetModuleFileName(hModule, m_szFileName, MAX_PATH - sizeof(\".ini\") + 1); \r\n\tif (!nSize) {\r\n\t\treturn false;\r\n\t}\r\n\tChangeFileName(m_szFileName, nSize, L\"MacType.ini\");\r\n\t\r\n\treturn LoadAppSettings(m_szFileName);\r\n}\r\n\r\nint CGdippSettings::_GetFreeTypeProfileIntFromSection(LPCTSTR lpszSection, LPCTSTR lpszKey, int nDefault, LPCTSTR lpszFile)\r\n{\r\n\twstring names = wstring((LPTSTR)lpszSection) + _T(\"@\") + wstring((LPTSTR)m_szexeName);\r\n\tif (m_Config.IsPartExists(names.c_str()) && m_Config[names.c_str()].IsValueExists(lpszKey))\r\n\t\treturn m_Config[names.c_str()][lpszKey].ToInt();\r\n\telse\r\n\tif (m_Config[lpszSection].IsValueExists(lpszKey))\r\n\t\treturn m_Config[lpszSection][lpszKey].ToInt();\r\n\telse\r\n\t\treturn nDefault;\r\n}\r\n\r\nbool CGdippSettings::_GetFreeTypeProfileBoolFromSection(LPCTSTR lpszSection, LPCTSTR lpszKey, bool nDefault, LPCTSTR lpszFile)\r\n{\r\n\twstring names = wstring((LPTSTR)lpszSection) + _T(\"@\") + wstring((LPTSTR)m_szexeName);\r\n\tif (m_Config.IsPartExists(names.c_str()) && m_Config[names.c_str()].IsValueExists(lpszKey))\r\n\t\treturn m_Config[names.c_str()][lpszKey].ToBool();\r\n\telse\r\n\tif (m_Config[lpszSection].IsValueExists(lpszKey))\r\n\t\treturn m_Config[lpszSection][lpszKey].ToBool();\r\n\telse\r\n\t\treturn nDefault;\r\n}\r\n\r\nwstring CGdippSettings::_GetFreeTypeProfileStrFromSection(LPCTSTR lpszSection, LPCTSTR lpszKey, const TCHAR* nDefault, LPCTSTR lpszFile)\r\n{\r\n\twstring names = wstring((LPTSTR)lpszSection) + _T(\"@\") + wstring((LPTSTR)m_szexeName);\r\n\tif (m_Config.IsPartExists(names.c_str()) && m_Config[names.c_str()].IsValueExists(lpszKey))\r\n\t\treturn m_Config[names.c_str()][lpszKey].ToString();\r\n\telse\r\n\tif (m_Config[lpszSection].IsValueExists(lpszKey))\r\n\t\treturn m_Config[lpszSection][lpszKey].ToString();\r\n\telse\r\n\t\treturn nDefault;\r\n}\r\n\r\nint CGdippSettings::_GetFreeTypeProfileInt(LPCTSTR lpszKey, int nDefault, LPCTSTR lpszFile)\r\n{\r\n\tint ret = _GetFreeTypeProfileIntFromSection(c_szFreeType, lpszKey, nDefault, lpszFile);\r\n\tif (ret == nDefault)\r\n\t\treturn _GetFreeTypeProfileIntFromSection(c_szGeneral, lpszKey, nDefault, lpszFile);\r\n\telse\r\n\t\treturn ret;\r\n}\r\n\r\nint CGdippSettings::_GetFreeTypeProfileBoundInt(LPCTSTR lpszKey, int nDefault, int nMin, int nMax, LPCTSTR lpszFile)\r\n{\r\n\tconst int ret = _GetFreeTypeProfileInt(lpszKey, nDefault, lpszFile);\r\n\treturn Bound(ret, nMin, nMax);\r\n}\r\n\r\nbool CGdippSettings::_IsFreeTypeProfileSectionExists(LPCTSTR lpszKey, LPCTSTR lpszFile)\r\n{\r\n\treturn m_Config.IsPartExists(lpszKey);\r\n}\r\n\r\nfloat CGdippSettings::FastGetProfileFloat(LPCTSTR lpszSection, LPCTSTR lpszKey, float fDefault)\r\n{\r\n\twstring names = wstring((LPTSTR)lpszSection) + _T(\"@\") + wstring((LPTSTR)m_szexeName);\r\n\tif (m_Config.IsPartExists(names.c_str()) && m_Config[names.c_str()].IsValueExists(lpszKey))\r\n\t\treturn m_Config[names.c_str()][lpszKey].ToDouble();\r\n\telse\r\n\tif (m_Config[lpszSection].IsValueExists(lpszKey))\r\n\t\treturn m_Config[lpszSection][lpszKey].ToDouble();\r\n\telse\r\n\t\treturn fDefault;\r\n}\r\n\r\nint CGdippSettings::FastGetProfileInt(LPCTSTR lpszSection, LPCTSTR lpszKey, int nDefault)\r\n{\r\n\twstring names = wstring((LPTSTR)lpszSection) + _T(\"@\") + wstring((LPTSTR)m_szexeName);\r\n\tif (m_Config.IsPartExists(names.c_str()) && m_Config[names.c_str()].IsValueExists(lpszKey))\r\n\t\treturn m_Config[names.c_str()][lpszKey].ToInt();\r\n\telse\r\n\tif (m_Config[lpszSection].IsValueExists(lpszKey))\r\n\t\treturn m_Config[lpszSection][lpszKey].ToInt();\r\n\telse\r\n\t\treturn nDefault;\r\n}\r\n\r\nfloat CGdippSettings::_GetFreeTypeProfileFloat(LPCTSTR lpszKey, float fDefault, LPCTSTR lpszFile)\r\n{\r\n\twstring names = wstring((LPTSTR)c_szFreeType) + _T(\"@\") + wstring((LPTSTR)m_szexeName);\r\n\tif (m_Config.IsPartExists(names.c_str()) && m_Config[names.c_str()].IsValueExists(lpszKey))\r\n\t\treturn m_Config[names.c_str()][lpszKey].ToInt();\r\n\telse\r\n\t{\r\n\t\tnames = wstring((LPTSTR)c_szGeneral) + _T(\"@\") + wstring((LPTSTR)m_szexeName);\r\n\t\tif (m_Config.IsPartExists(names.c_str()) && m_Config[names.c_str()].IsValueExists(lpszKey))\r\n\t\t\treturn m_Config[names.c_str()][lpszKey].ToDouble();\r\n\t\telse\r\n\t\tif (m_Config[c_szFreeType].IsValueExists(lpszKey))\r\n\t\t\treturn m_Config[c_szFreeType][lpszKey].ToDouble();\r\n\t\tif (m_Config[c_szGeneral].IsValueExists(lpszKey))\r\n\t\t\treturn m_Config[c_szGeneral][lpszKey].ToDouble();\r\n\t\telse\r\n\t\t\treturn fDefault;\r\n\t}\r\n}\r\n\r\nfloat CGdippSettings::_GetFreeTypeProfileBoundFloat(LPCTSTR lpszKey, float fDefault, float fMin, float fMax, LPCTSTR lpszFile)\r\n{\r\n\tconst float ret = _GetFreeTypeProfileFloat(lpszKey, fDefault, lpszFile);\r\n\treturn Bound(ret, fMin, fMax);\r\n}\r\n\r\nDWORD CGdippSettings::FastGetProfileString(LPCTSTR lpszSection, LPCTSTR lpszKey, LPCTSTR lpszDefault, LPTSTR lpszRet, DWORD cch)\r\n{\r\n\twstring names = wstring((LPTSTR)lpszSection) + _T(\"@\") + wstring((LPTSTR)m_szexeName);\r\n\tif (m_Config.IsPartExists(names.c_str()) && m_Config[names.c_str()].IsValueExists(lpszKey))\r\n\t{\r\n\t\tLPCTSTR p = m_Config[names.c_str()][lpszKey];\r\n\t\tStringCchCopy(lpszRet, cch, p);\r\n\t\treturn wcslen(p);\r\n\t}\r\n\telse\r\n\tif (m_Config[lpszSection].IsValueExists(lpszKey))\r\n\t{\r\n\t\tLPCTSTR p = m_Config[lpszSection][lpszKey];\r\n\t\tStringCchCopy(lpszRet, cch, p);\r\n\t\treturn wcslen(p);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (lpszDefault) {\r\n\t\t\tStringCchCopy(lpszRet, cch, lpszDefault);\r\n\t\t\treturn wcslen(lpszDefault);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlpszRet = NULL;\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\nDWORD CGdippSettings::_GetFreeTypeProfileString(LPCTSTR lpszKey, LPCTSTR lpszDefault, LPTSTR lpszRet, DWORD cch, LPCTSTR lpszFile)\r\n{\r\n\twstring names = wstring((LPTSTR)c_szFreeType) + _T(\"@\") + wstring((LPTSTR)m_szexeName);\r\n\tif (m_Config.IsPartExists(names.c_str()) && m_Config[names.c_str()].IsValueExists(lpszKey))\r\n\t{\r\n\t\tLPCTSTR p = m_Config[names.c_str()][lpszKey];\r\n\t\tStringCchCopy(lpszRet, cch, p);\r\n\t\treturn wcslen(p);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tnames = wstring((LPTSTR)c_szGeneral) + _T(\"@\") + wstring((LPTSTR)m_szexeName);\r\n\t\tif (m_Config.IsPartExists(names.c_str()) && m_Config[names.c_str()].IsValueExists(lpszKey))\r\n\t\t{\r\n\t\t\tLPCTSTR p = m_Config[names.c_str()][lpszKey];\r\n\t\t\tStringCchCopy(lpszRet, cch, p);\r\n\t\t\treturn wcslen(p);\r\n\t\t}\r\n\t\telse\r\n\t\tif (m_Config[c_szFreeType].IsValueExists(lpszKey))\r\n\t\t{\r\n\t\t\tLPCTSTR p = m_Config[c_szFreeType][lpszKey];\r\n\t\t\tStringCchCopy(lpszRet, cch, p);\r\n\t\t\treturn wcslen(p);\r\n\t\t}\r\n\t\telse\r\n\t\tif (m_Config[c_szGeneral].IsValueExists(lpszKey))\r\n\t\t{\r\n\t\t\tLPCTSTR p = m_Config[c_szGeneral][lpszKey];\r\n\t\t\tStringCchCopy(lpszRet, cch, p);\r\n\t\t\treturn wcslen(p);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tStringCchCopy(lpszRet, cch, lpszDefault);\r\n\t\t\treturn wcslen(lpszDefault);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CGdippSettings::GetOSVersion() {\r\n\tOSVERSIONINFO info;\r\n\tmemset(&info, 0, sizeof(OSVERSIONINFO));\r\n\tinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);\r\n\r\n\tGetVersionEx(&info);\r\n\tm_dwOSMajorVer = info.dwMajorVersion;\r\n\tm_dwOSMinorVer = info.dwMinorVersion;\r\n}\r\n\r\nbool CGdippSettings::LoadAppSettings(LPCTSTR lpszFile)\r\n{\r\n\t// 各種設定読み込み\r\n\t// INIファイルの例:\r\n\t// [General]\r\n\t// HookChildProcesses=0\r\n\t// HintingMode=0\r\n\t// AntiAliasMode=0\r\n\t// NormalWeight=0\r\n\t// BoldWeight=0\r\n\t// ItalicSlant=0\r\n\t// EnableKerning=0\r\n\t// MaxHeight=0\r\n\t// ForceChangeFont=ＭＳ Ｐゴシック\r\n\t// TextTuning=0\r\n\t// TextTuningR=0\r\n\t// TextTuningG=0\r\n\t// TextTuningB=0\r\n\t// CacheMaxFaces=0\r\n\t// CacheMaxSizes=0\r\n\t// CacheMaxBytes=0\r\n\t// AlternativeFile=\r\n\t// LoadOnDemand=0\r\n\t// UseMapping=0\r\n\t// LcdFilter=0\r\n\t// Shadow=1,1,4\r\n\t// [Individual]\r\n\t// ＭＳ Ｐゴシック=0,1,2,3,4,5\r\n\tGetOSVersion();\r\n\tWritePrivateProfileString(NULL, NULL, NULL, lpszFile);\r\n\r\n\tm_Config.Clear();\r\n\tm_Config.LoadFromFile(lpszFile);\r\n\r\n\tTCHAR szAlternative[MAX_PATH], szMainFile[MAX_PATH];\r\n\tif (FastGetProfileString(c_szGeneral, _T(\"AlternativeFile\"), _T(\"\"), szAlternative, MAX_PATH)) {\r\n\t\tif (PathIsRelative(szAlternative)) {\r\n\t\t\tTCHAR szDir[MAX_PATH];\r\n\t\t\tStringCchCopy(szDir, MAX_PATH, lpszFile);\r\n\t\t\tPathRemoveFileSpec(szDir);\r\n\t\t\tPathCombine(szAlternative, szDir, szAlternative);\r\n\t\t}\r\n\t\tStringCchCopy(szMainFile, MAX_PATH, lpszFile);\t//把原始文件名保存下来\r\n\t\tStringCchCopy(m_szFileName, MAX_PATH, szAlternative);\t\r\n\t\tlpszFile = m_szFileName;\r\n\t\tm_Config.Clear();\r\n\t\tm_Config.LoadFromFile(lpszFile);\r\n\t}\r\n\r\n\t_GetAlternativeProfileName(m_szexeName, lpszFile);\r\n\tCFontSettings& fs = m_FontSettings;\r\n\tfs.Clear();\r\n\tfs.SetHintingMode(_GetFreeTypeProfileBoundInt(_T(\"HintingMode\"), 0, HINTING_MIN, HINTING_MAX, lpszFile));\r\n\tfs.SetAntiAliasMode(_GetFreeTypeProfileBoundInt(_T(\"AntiAliasMode\"), 0, AAMODE_MIN, AAMODE_MAX, lpszFile));\r\n\tfs.SetNormalWeight(_GetFreeTypeProfileBoundInt(_T(\"NormalWeight\"), 0, NWEIGHT_MIN, NWEIGHT_MAX, lpszFile));\r\n\tfs.SetBoldWeight(_GetFreeTypeProfileBoundInt(_T(\"BoldWeight\"), 0, BWEIGHT_MIN, BWEIGHT_MAX, lpszFile));\r\n\tfs.SetItalicSlant(_GetFreeTypeProfileBoundInt(_T(\"ItalicSlant\"), 0, SLANT_MIN, SLANT_MAX, lpszFile));\r\n\tfs.SetKerning(!!_GetFreeTypeProfileInt(_T(\"EnableKerning\"), 0, lpszFile));\r\n\tm_nAntiAliasModeForDW = fs.GetAntiAliasMode();\t// DirectWrite always use the user defined AA mode.\r\n\t{\r\n\t\tTCHAR szShadow[256];\r\n\t\tCStringTokenizer token;\r\n\t\tm_bEnableShadow = false;\r\n\t\tif (!_GetFreeTypeProfileString(_T(\"Shadow\"), _T(\"\"), szShadow, countof(szShadow), lpszFile)\r\n\t\t\t\t|| token.Parse(szShadow) < 3) {\r\n\t\t\tgoto SKIP;\r\n\t\t}\r\n\t\tfor (int i=0; i<3; i++) {\r\n\t\t\tm_nShadow[i] = _StrToInt(token.GetArgument(i), 0);\r\n\t\t\t/*if (m_nShadow[i] <= 0) {\r\n\t\t\t\tgoto SKIP;\r\n\t\t\t}*/\r\n\t\t}\r\n\t\tm_bEnableShadow = true;\r\n\t\tif (token.GetCount()>=4)\t//如果指定了浅色阴影\r\n\t\t\tm_nShadowDarkColor = _httoi(token.GetArgument(3));\t//读取阴影\r\n\t\telse\r\n\t\t\tm_nShadowDarkColor = 0;\t//否则为黑色\r\n\t\tif (token.GetCount()>=6)\t//如果指定了甥瀚阴影\r\n\t\t{\r\n\t\t\tm_nShadowLightColor = _httoi(token.GetArgument(5));\t//读取阴影\r\n\t\t\tm_nShadow[3] = _StrToInt(token.GetArgument(4), m_nShadow[2]); //读取甥胰\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tm_nShadowLightColor = m_nShadowDarkColor;\t\t//否则和浅色阴影相同\r\n\t\t\tm_nShadow[3] = m_nShadow[2];\t\t//甥胰也相同\r\n\t\t}\r\nSKIP:\r\n\t\t;\r\n\t}\r\n\r\n\tm_bHookChildProcesses = !!_GetFreeTypeProfileInt(_T(\"HookChildProcesses\"), false, lpszFile);\r\n\tm_bUseMapping\t= !!_GetFreeTypeProfileInt(_T(\"UseMapping\"), false, lpszFile);\r\n\tm_nBolderMode\t= _GetFreeTypeProfileInt(_T(\"BolderMode\"), 0, lpszFile);\r\n\tm_nGammaMode\t= _GetFreeTypeProfileInt(_T(\"GammaMode\"), -1, lpszFile);\r\n\tm_fGammaValue\t= _GetFreeTypeProfileBoundFloat(_T(\"GammaValue\"), 1.0f, GAMMAVALUE_MIN, GAMMAVALUE_MAX, lpszFile);\r\n\tm_fRenderWeight\t= _GetFreeTypeProfileBoundFloat(_T(\"RenderWeight\"), 1.0f, RENDERWEIGHT_MIN, RENDERWEIGHT_MAX, lpszFile);\r\n\tm_fContrast\t\t= _GetFreeTypeProfileBoundFloat(_T(\"Contrast\"), 1.0f, CONTRAST_MIN, CONTRAST_MAX, lpszFile);\r\n\r\n//DirectWrite/Direct2D exclusive settings\r\n\tfloat fCalculatedDWGamma = m_fGammaValue*m_fGammaValue > 1.3 ? m_fGammaValue * m_fGammaValue / 2 : 0.7f;\r\n\t// if not set, use calculated gamma as DW gamma\r\n\tm_fGammaValueForDW = Bound(FastGetProfileFloat(c_szDirectWrite, _T(\"GammaValue\"), fCalculatedDWGamma), 0.0f, GAMMAVALUE_MAX);\r\n\tm_fContrastForDW = Bound(FastGetProfileFloat(c_szDirectWrite, _T(\"Contrast\"), 1.0f), CONTRAST_MIN, CONTRAST_MAX);\r\n\tm_nRenderingModeForDW = Bound(FastGetProfileInt(c_szDirectWrite, _T(\"RenderingMode\"), 5), 0, 6);\r\n\tm_fClearTypeLevelForDW = Bound(FastGetProfileFloat(c_szDirectWrite, _T(\"ClearTypeLevel\"), 1.0f), 0.0f, 1.0f);\r\n\r\n#ifdef _DEBUG\r\n\t// GammaValue検証用\r\n\t//CHAR GammaValueTest[1025];\r\n\t//sprintf(GammaValueTest, \"GammaValue=%.6f\\nContrast=%.6f\\n\", m_fGammaValue, m_fContrast);\r\n\t//MessageBoxA(NULL, GammaValueTest, \"GammaValueテスト\", 0);\r\n#endif\r\n\tm_bLoadOnDemand\t= !!_GetFreeTypeProfileInt(_T(\"LoadOnDemand\"), false, lpszFile);\r\n\tm_bFontLink\t\t= _GetFreeTypeProfileInt(_T(\"FontLink\"), 0, lpszFile);\r\n\r\n\tm_bIsInclude\t= !!_GetFreeTypeProfileInt(_T(\"UseInclude\"), false, lpszFile);\r\n\tm_nMaxHeight\t= _GetFreeTypeProfileBoundInt(_T(\"MaxHeight\"), 0, 0, 0xfff, lpszFile);\t//赃只能到65535，cache的限制，而且大字体无实际价值\r\n\tm_nMinHeight = _GetFreeTypeProfileBoundInt(_T(\"MinHeight\"), 0, 0,\r\n\t\t\t\t(m_nMaxHeight) ? m_nMaxHeight : 0xfff,  // shouldn't be greater than MaxHeight unless it is undefined\r\n\t\t\t\tlpszFile);\t//Minimum size of rendered font. DPI aware alternative.\r\n\t\t\t\t//patched by krrr https://github.com/krrr/mactype/commit/146a213e2304208cb3c1a3e6fa941a386d908761\r\n\tm_nBitmapHeight = _GetFreeTypeProfileBoundInt(_T(\"MaxBitmap\"), 0, 0, 255, lpszFile);\r\n\tm_bHintSmallFont = _GetFreeTypeProfileInt(_T(\"HintSmallFont\"), 0, lpszFile);\r\n\tm_bDirectWrite = _GetFreeTypeProfileInt(_T(\"DirectWrite\"), 0, lpszFile);\r\n\tm_nLcdFilter\t= _GetFreeTypeProfileInt(_T(\"LcdFilter\"), 0, lpszFile);\r\n\tm_nFontSubstitutes = _GetFreeTypeProfileBoundInt(_T(\"FontSubstitutes\"),\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t SETTING_FONTSUBSTITUTE_DISABLE,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t SETTING_FONTSUBSTITUTE_DISABLE,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t SETTING_FONTSUBSTITUTE_ALL,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lpszFile);\r\n\tm_nWidthMode = SETTING_WIDTHMODE_GDI32;\r\n/*\r\n\t_GetFreeTypeProfileBoundInt(_T(\"WidthMode\"),\r\n\t\t\t\t\t\t\t\t\t\t\t   SETTING_WIDTHMODE_GDI32,\r\n\t\t\t\t\t\t\t\t\t\t\t   SETTING_WIDTHMODE_GDI32,\r\n\t\t\t\t\t\t\t\t\t\t\t   SETTING_WIDTHMODE_FREETYPE,\r\n\t\t\t\t\t\t\t\t\t\t\t   lpszFile);*/\r\n\r\n\tm_nFontLoader = _GetFreeTypeProfileBoundInt(_T(\"FontLoader\"),\r\n\t\t\t\t\t\t\t\t\t\t\t\tSETTING_FONTLOADER_FREETYPE,\r\n\t\t\t\t\t\t\t\t\t\t\t\tSETTING_FONTLOADER_FREETYPE,\r\n\t\t\t\t\t\t\t\t\t\t\t\tSETTING_FONTLOADER_WIN32,\r\n\t\t\t\t\t\t\t\t\t\t\t\tlpszFile);\r\n\tm_nCacheMaxFaces = _GetFreeTypeProfileInt(_T(\"CacheMaxFaces\"), 64, lpszFile);\r\n\tm_nCacheMaxFaces = m_nCacheMaxFaces > 64 ? m_nCacheMaxFaces : 64;\r\n\tm_nCacheMaxSizes = _GetFreeTypeProfileInt(_T(\"CacheMaxSizes\"), 1200, lpszFile);\r\n\tm_nCacheMaxBytes = _GetFreeTypeProfileInt(_T(\"CacheMaxBytes\"), 10485760, lpszFile);\r\n\r\n\t//experimental settings:\r\n\tm_bEnableClipBoxFix = !!_GetFreeTypeProfileIntFromSection(_T(\"Experimental\"), _T(\"ClipBoxFix\"), 1, lpszFile);\r\n\tm_bColorFont = !!_GetFreeTypeProfileIntFromSection(_T(\"Experimental\"), _T(\"ColorFont\"), 0, lpszFile);\r\n\tm_bInvertColor = !!_GetFreeTypeProfileIntFromSection(_T(\"Experimental\"), _T(\"InvertColor\"), 0, lpszFile);\r\n#ifdef INFINALITY\r\n\t// define some macros\r\n#define INF_INT_ENV(y, def) \\\r\n\tnTemp = _GetFreeTypeProfileIntFromSection(_T(\"Infinality\"), _T(y), def, lpszFile); \\\r\n\tFT_PutEnv(y, _ltoa(nTemp, buff, 10));\r\n#define INF_BOOL_ENV(y, def) \\\r\n\tbTemp = _GetFreeTypeProfileBoolFromSection(_T(\"Infinality\"), _T(y), def, lpszFile); \\\r\n\tFT_PutEnv(y, bTemp?\"true\":\"false\");\r\n#define INF_STR_ENV(y, def) \\\r\n\tsTemp = _GetFreeTypeProfileStrFromSection(_T(\"Infinality\"), _T(y), def, lpszFile); \\\r\n\tFT_PutEnv(y, WstringToString(sTemp).c_str());\r\n\r\n\tchar* buff = (char*)malloc(256);\r\n\tint nTemp; bool bTemp; wstring sTemp;\r\n\r\n\t// INFINALITY settings:\r\n\tINF_INT_ENV( \"INFINALITY_FT_CHROMEOS_STYLE_SHARPENING_STRENGTH\", 0);\r\n\tINF_INT_ENV( \"INFINALITY_FT_CONTRAST\", 0);\r\n\tINF_INT_ENV( \"INFINALITY_FT_STEM_FITTING_STRENGTH\", 25);\r\n\tINF_INT_ENV( \"INFINALITY_FT_AUTOHINT_SNAP_STEM_HEIGHT\", 100);\r\n\tINF_INT_ENV( \"INFINALITY_FT_GRAYSCALE_FILTER_STRENGTH\", 0);\r\n\tINF_INT_ENV( \"INFINALITY_FT_WINDOWS_STYLE_SHARPENING_STRENGTH\", 20);\r\n\tINF_INT_ENV( \"INFINALITY_FT_BRIGHTNESS\", 0);\r\n\tINF_INT_ENV( \"INFINALITY_FT_AUTOHINT_HORIZONTAL_STEM_DARKEN_STRENGTH\", 10);\r\n\tINF_INT_ENV( \"INFINALITY_FT_STEM_ALIGNMENT_STRENGTH\", 25);\r\n\tINF_INT_ENV( \"INFINALITY_FT_AUTOHINT_VERTICAL_STEM_DARKEN_STRENGTH\", 25);\r\n\tINF_INT_ENV( \"INFINALITY_FT_FRINGE_FILTER_STRENGTH\", 0);\r\n\tINF_INT_ENV(\"INFINALITY_FT_GLOBAL_EMBOLDEN_X_VALUE\", 0);\r\n\tINF_INT_ENV(\"INFINALITY_FT_GLOBAL_EMBOLDEN_Y_VALUE\", 0);\r\n\tINF_INT_ENV(\"INFINALITY_FT_BOLD_EMBOLDEN_X_VALUE\", 0);\r\n\tINF_INT_ENV(\"INFINALITY_FT_BOLD_EMBOLDEN_Y_VALUE\", 0);\r\n\tINF_INT_ENV(\"INFINALITY_FT_STEM_SNAPPING_SLIDING_SCALE\", 0);\r\n\r\n\tINF_BOOL_ENV(\"INFINALITY_FT_USE_KNOWN_SETTINGS_ON_SELECTED_FONTS\", true);\r\n\tINF_BOOL_ENV( \"INFINALITY_FT_AUTOFIT_ADJUST_HEIGHTS\", true);\r\n\tINF_BOOL_ENV( \"INFINALITY_FT_USE_VARIOUS_TWEAKS\", true);\r\n\tINF_BOOL_ENV( \"INFINALITY_FT_AUTOHINT_INCREASE_GLYPH_HEIGHTS\", true);\r\n\tINF_BOOL_ENV( \"INFINALITY_FT_STEM_DARKENING_CFF\", true);\r\n\tINF_BOOL_ENV( \"INFINALITY_FT_STEM_DARKENING_AUTOFIT\", true);\r\n\r\n\tINF_STR_ENV( \"INFINALITY_FT_GAMMA_CORRECTION\", _T(\"0 100\"));\r\n\tINF_STR_ENV( \"INFINALITY_FT_FILTER_PARAMS\", _T(\"11 22 38 22 11\"));\r\n\r\n\tfree(buff);\r\n#endif\r\n\r\n\tif (m_nFontLoader == SETTING_FONTLOADER_WIN32) {\r\n\t\t// APIが処理してくれるはずなので自前処理は無効化\r\n\t\tif (m_nFontSubstitutes == SETTING_FONTSUBSTITUTE_ALL) {\r\n\t\t\tm_nFontSubstitutes = SETTING_FONTSUBSTITUTE_DISABLE;\r\n\t\t}\r\n\t\tm_bFontLink = 0;\r\n\t}\r\n\r\n\t// フォント指定\r\n\tZeroMemory(&m_lfForceFont, sizeof(LOGFONT));\r\n\tm_szForceChangeFont[0] = _T('\\0');\r\n\t//_GetFreeTypeProfileString(_T(\"ForceChangeFont\"), _T(\"\"), m_szForceChangeFont, LF_FACESIZE, lpszFile);\r\n\r\n\t// OSのバージョンがXP以降かどうか\r\n\t//OSVERSIONINFO osvi = { sizeof(OSVERSIONINFO) };\r\n\t//GetVersionEx(&osvi);\r\n\tm_bIsWinXPorLater = IsWindowsXPOrGreater(); \r\n\r\n\tSTARTUPINFO si = { sizeof(STARTUPINFO) };\r\n\tGetStartupInfo(&si);\r\n\tm_bRunFromGdiExe = IsGdiPPStartupInfo(si);\r\n//\tif (!m_bRunFromGdiExe) {\r\n//\t\tm_bHookChildProcesses = false;\r\n//\t}\r\n/*\r\n\tconst int nTextTuning = _GetFreeTypeProfileInt(_T(\"TextTuning\"), 0, lpszFile),\r\n\t\tnTextTuningR = _GetFreeTypeProfileInt(_T(\"TextTuningR\"), 0, lpszFile),\r\n\t\tnTextTuningG = _GetFreeTypeProfileInt(_T(\"TextTuningG\"), 0, lpszFile),\r\n\t\tnTextTuningB = _GetFreeTypeProfileInt(_T(\"TextTuningB\"), 0, lpszFile);\r\n\tInitInitTuneTable();\r\n\tInitTuneTable(nTextTuning, m_nTuneTable);\r\n\tInitTuneTable(nTextTuningR, m_nTuneTableR);\r\n\tInitTuneTable(nTextTuningG, m_nTuneTableG);\r\n\tInitTuneTable(nTextTuningB, m_nTuneTableB);*/\r\n//\tm_bIsHDBench = (GetModuleHandle(_T(\"HDBENCH.EXE\")) == GetModuleHandle(NULL));\r\n\r\n\tm_arrExcludeFont.clear();\r\n\tm_arrIncludeFont.clear();\r\n\tm_arrExcludeModule.clear();\r\n\tm_arrIncludeModule.clear();\r\n\tm_arrUnloadModule.clear();\r\n\tm_arrUnFontSubModule.clear();\r\n\r\n\t// [Exclude]セクションから除外フォントリストを読み込む\r\n\t// [ExcludeModule]セクションから除外モジュールリストを読み込む\r\n\tAddListFromSection(_T(\"ExcludeModule\"), lpszFile, m_arrExcludeModule);\r\n\t//AddListFromSection(_T(\"ExcludeModule\"), szMainFile, m_arrExcludeModule);\r\n\t// [IncludeModule]セクションから対象モジュールリストを読み込む\r\n\tAddListFromSection(_T(\"IncludeModule\"), lpszFile, m_arrIncludeModule);\r\n\t//AddListFromSection(_T(\"IncludeModule\"), szMainFile, m_arrIncludeModule);\r\n\t// [UnloadDLL]蛠E患釉氐哪？丒\r\n\tAddListFromSection(_T(\"UnloadDLL\"), lpszFile, m_arrUnloadModule);\r\n\t//AddListFromSection(_T(\"UnloadDLL\"), szMainFile, m_arrUnloadModule);\r\n\t// [ExcludeSub]不进行字体替换的模縼E\r\n\tAddListFromSection(L\"ExcludeSub\", lpszFile, m_arrUnFontSubModule);\r\n\t//AddListFromSection(L\"ExcludeSub\", szMainFile, m_arrUnFontSubModule);\r\n\t//如果是排除的模块，则关闭字体替换\r\n\tif (m_nFontSubstitutes)\r\n\t{\r\n\t\tModuleHashMap::const_iterator it=m_arrUnFontSubModule.begin();\r\n\t\twhile (it!=m_arrUnFontSubModule.end())\r\n\t\t{\r\n\t\t\tif (GetModuleHandle(it->c_str()))\r\n\t\t\t{\r\n\t\t\t\tm_nFontSubstitutes = 0;\t//关闭替换\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t++it;\r\n\t\t}\r\n\t}\r\n\r\n\t// [Individual]セクションからフォント別設定を読み込む\r\n\twstring names = _T(\"LcdFilterWeight@\") + wstring(m_szexeName);\r\n\tif (_IsFreeTypeProfileSectionExists(names.c_str(), lpszFile))\r\n\t\tm_bUseCustomLcdFilter = AddLcdFilterFromSection(names.c_str(), lpszFile, m_arrLcdFilterWeights);\r\n\telse\r\n\t\tm_bUseCustomLcdFilter = AddLcdFilterFromSection(_T(\"LcdFilterWeight\"), lpszFile, m_arrLcdFilterWeights);\r\n\t\r\n\tm_bUseCustomPixelLayout = AddPixelModeFromSection(_T(\"PixelLayout\"), lpszFile, m_arrPixelLayout);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CGdippSettings::AddExcludeListFromSection(LPCTSTR lpszSection, LPCTSTR lpszFile, set<wstring> & arr)\r\n{\r\n\tLPTSTR  buffer = _GetPrivateProfileSection(lpszSection, lpszFile);\r\n\tif (buffer == NULL) {\r\n\t\tSetLastError(ERROR_NOT_ENOUGH_MEMORY);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tLPTSTR p = buffer;\r\n\tTCHAR buff[LF_FACESIZE+1];\r\n\tLOGFONT truefont={0};\r\n\twhile (*p) {\r\n\t\tbool b = false;\r\n\t\tGetFontLocalName(p, buff);//转换字体脕E\r\n\t\tset<wstring>::const_iterator it = arr.find(buff);\r\n\t\tif (it==arr.end())\r\n\t\t\tarr.insert(buff);\r\n\t\tfor (; *p; p++);\t//来到下一行\r\n\t\tp++;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\n//template <typename T>\r\nbool CGdippSettings::AddListFromSection(LPCTSTR lpszSection, LPCTSTR lpszFile, set<wstring> & arr)\r\n{\r\n\tLPTSTR  buffer = _GetPrivateProfileSection(lpszSection, lpszFile);\r\n\tif (buffer == NULL) {\r\n\t\tSetLastError(ERROR_NOT_ENOUGH_MEMORY);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tLPTSTR p = buffer;\r\n\twhile (*p) {\r\n\t\tbool b = false;\r\n\t\tset<wstring>::const_iterator it = arr.find(p);\r\n\t\tif (it==arr.end())\r\n\t\t\tarr.insert(p);\r\n\t\tfor (; *p; p++);\t//来到下一行\r\n\t\t\tp++;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nbool CGdippSettings::AddLcdFilterFromSection(LPCTSTR lpszKey, LPCTSTR lpszFile, unsigned char* arr)\r\n{\r\n\tTCHAR buffer[100];\r\n\t_GetFreeTypeProfileString(lpszKey, _T(\"\\0\"), buffer, sizeof(buffer), lpszFile);\r\n\tif (buffer[0] == '\\0') {\r\n\t\tSetLastError(ERROR_NOT_ENOUGH_MEMORY);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tLPTSTR p = buffer;\r\n\tCStringTokenizer token;\r\n\tint argc = 0;\r\n\targc = token.Parse(buffer);\r\n\r\n\tfor (int i = 0; i < 5; i++) {\r\n\t\tLPCTSTR arg = token.GetArgument(i);\r\n\t\tif (!arg)\r\n\t\t\treturn false;\t//参数少于5个则视为不使用此参数\r\n\t\tarr[i] = _StrToInt(arg, arr[i]);\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CGdippSettings::AddPixelModeFromSection(LPCTSTR lpszKey, LPCTSTR lpszFile, char* arr)\r\n{\r\n\tTCHAR buffer[100];\r\n\t_GetFreeTypeProfileString(lpszKey, _T(\"\\0\"), buffer, sizeof(buffer), lpszFile);\r\n\tif (buffer[0] == '\\0') {\r\n\t\tSetLastError(ERROR_NOT_ENOUGH_MEMORY);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tLPTSTR p = buffer;\r\n\tCStringTokenizer token;\r\n\tint argc = 0;\r\n\targc = token.Parse(buffer);\r\n\r\n\tfor (int i = 0; i < 6; i++) {\r\n\t\tLPCTSTR arg = token.GetArgument(i);\r\n\t\tif (!arg)\r\n\t\t\treturn false;\t\r\n\t\tarr[i] = _StrToInt(arg, arr[i]);\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CGdippSettings::AddIndividualFromSection(LPCTSTR lpszSection, LPCTSTR lpszFile, IndividualArray& arr)\r\n{\r\n\tLPTSTR  buffer = _GetPrivateProfileSection(lpszSection, lpszFile);\r\n\tif (buffer == NULL) {\r\n\t\tSetLastError(ERROR_NOT_ENOUGH_MEMORY);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tLPTSTR p = buffer;\r\n\tTCHAR buff[LF_FACESIZE+1];\r\n\tLOGFONT truefont={0};\r\n\twhile (*p) {\r\n\t\tbool b = false;\r\n\r\n\t\tLPTSTR pnext = p;\r\n\t\tfor (; *pnext; pnext++);\r\n\r\n\t\t//\"ＭＳ Ｐゴシック=0,0\" みたいな文字列を分割\r\n\t\tLPTSTR value = _tcschr(p, _T('='));\r\n\t\tCStringTokenizer token;\r\n\t\tint argc = 0;\r\n\t\tif (value) {\r\n\t\t\t*value++ = _T('\\0');\r\n\t\t\targc = token.Parse(value);\r\n\t\t}\r\n\r\n\t\tGetFontLocalName(p, buff);//转换字体脕E\r\n\r\n\t\tCFontIndividual fi(buff);\r\n\t\tconst CFontSettings& fsCommon = m_FontSettings;\r\n\t\tCFontSettings& fs = fi.GetIndividual();\r\n\t\t//Individualが無ければ共通設定を使う\r\n\t\tfs = fsCommon;\r\n\t\tfor (int i = 0; i < MAX_FONT_SETTINGS; i++) {\r\n\t\t\tLPCTSTR arg = token.GetArgument(i);\r\n\t\t\tif (!arg)\r\n\t\t\t\tbreak;\r\n\t\t\tconst int n = _StrToInt(arg, fsCommon.GetParam(i));\r\n\t\t\tfs.SetParam(i, n);\r\n\t\t}\r\n\r\n\t\tfor (int i = 0 ; i < arr.GetSize(); i++) {\r\n\t\t\tif (arr[i] == fi) {\r\n\t\t\t\tb = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!b) {\r\n\t\t\tarr.Add(fi);\r\n#ifdef _DEBUG\r\n\t\t\tTRACE(_T(\"Individual: %s, %d, %d, %d, %d, %d, %d\\n\"), fi.GetName(),\r\n\t\t\t\t\tfs.GetParam(0), fs.GetParam(1), fs.GetParam(2), fs.GetParam(3), fs.GetParam(4), fs.GetParam(5));\r\n#endif\r\n\t\t}\r\n\t\tp = pnext;\r\n\t\tp++;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nLPTSTR CGdippSettings::_GetPrivateProfileSection(LPCTSTR lpszSection, LPCTSTR lpszFile)\r\n{\r\n\treturn const_cast<LPTSTR>((LPCTSTR)m_Config[lpszSection]);\r\n}\r\n\r\n//atolにデフォルト値を返せるようにしたような物\r\nint CGdippSettings::_StrToInt(LPCTSTR pStr, int nDefault)\r\n{\r\n#define isspace(ch)\t\t(ch == _T('\\t') || ch == _T(' '))\r\n#define isdigit(ch)\t\t((_TUCHAR)(ch - _T('0')) <= 9)\r\n\r\n\tint ret;\r\n\tbool neg = false;\r\n\tLPCTSTR pStart;\r\n\r\n\tfor (; isspace(*pStr); pStr++);\r\n\tswitch (*pStr) {\r\n\tcase _T('-'):\r\n\t\tneg = true;\r\n\tcase _T('+'):\r\n\t\tpStr++;\r\n\t\tbreak;\r\n\t}\r\n\r\n\tpStart = pStr;\r\n\tret = 0;\r\n\tfor (; isdigit(*pStr); pStr++) {\r\n\t\tret = 10 * ret + (*pStr - _T('0'));\r\n\t}\r\n\r\n\tif (pStr == pStart) {\r\n\t\treturn nDefault;\r\n\t}\r\n\treturn neg ? -ret : ret;\r\n\r\n#undef isspace\r\n#undef isdigit\r\n}\r\n\r\nint CGdippSettings::_httoi(const TCHAR *value)\r\n{\r\n\tstruct CHexMap\r\n\t{\r\n\t\tTCHAR chr;\r\n\t\tint value;\r\n\t};\r\n\tconst int HexMapL = 16;\r\n\tCHexMap HexMap[HexMapL] =\r\n\t{\r\n\t\t{'0', 0}, {'1', 1},\r\n\t\t{'2', 2}, {'3', 3},\r\n\t\t{'4', 4}, {'5', 5},\r\n\t\t{'6', 6}, {'7', 7},\r\n\t\t{'8', 8}, {'9', 9},\r\n\t\t{'A', 10}, {'B', 11},\r\n\t\t{'C', 12}, {'D', 13},\r\n\t\t{'E', 14}, {'F', 15}\r\n\t};\r\n\tTCHAR *mstr = _tcsupr(_tcsdup(value));\r\n\tTCHAR *s = mstr;\r\n\tint result = 0;\r\n\tif (*s == '0' && *(s + 1) == 'X') s += 2;\r\n\tbool firsttime = true;\r\n\twhile (*s != '\\0')\r\n\t{\r\n\t\tbool found = false;\r\n\t\tfor (int i = 0; i < HexMapL; i++)\r\n\t\t{\r\n\t\t\tif (*s == HexMap[i].chr)\r\n\t\t\t{\r\n\t\t\t\tif (!firsttime) result <<= 4;\r\n\t\t\t\tresult |= HexMap[i].value;\r\n\t\t\t\tfound = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!found) break;\r\n\t\ts++;\r\n\t\tfirsttime = false;\r\n\t}\r\n\tfree(mstr);\r\n\treturn result;\r\n}\r\n\r\n//atofにデフォルト値を返せるようにしたような物\r\nfloat CGdippSettings::_StrToFloat(LPCTSTR pStr, float fDefault)\r\n{\r\n#define isspace(ch)\t\t(ch == _T('\\t') || ch == _T(' '))\r\n#define isdigit(ch)\t\t((_TUCHAR)(ch - _T('0')) <= 9)\r\n\r\n\tint ret_i;\r\n\tint ret_d;\r\n\tfloat ret;\r\n\tbool neg = false;\r\n\tLPCTSTR pStart;\r\n\r\n\tfor (; isspace(*pStr); pStr++);\r\n\tswitch (*pStr) {\r\n\tcase _T('-'):\r\n\t\tneg = true;\r\n\tcase _T('+'):\r\n\t\tpStr++;\r\n\t\tbreak;\r\n\t}\r\n\r\n\tpStart = pStr;\r\n\tret = 0;\r\n\tret_i = 0;\r\n\tret_d = 1;\r\n\tfor (; isdigit(*pStr); pStr++) {\r\n\t\tret_i = 10 * ret_i + (*pStr - _T('0'));\r\n\t}\r\n\tif (*pStr == _T('.')) {\r\n\t\tpStr++;\r\n\t\tfor (; isdigit(*pStr); pStr++) {\r\n\t\t\tret_i = 10 * ret_i + (*pStr - _T('0'));\r\n\t\t\tret_d *= 10;\r\n\t\t}\r\n\t}\r\n\tret = (float)ret_i / (float)ret_d;\r\n\r\n\tif (pStr == pStart) {\r\n\t\treturn fDefault;\r\n\t}\r\n\treturn neg ? -ret : ret;\r\n\r\n#undef isspace\r\n#undef isdigit\r\n}\r\n\r\nbool CGdippSettings::IsFontExcluded(LPCSTR lpFaceName) const\r\n{\r\n\tWCHAR szStack[LF_FACESIZE];\r\n\tLPWSTR lpUnicode = _StrDupExAtoW(lpFaceName, -1, szStack, LF_FACESIZE, NULL);\r\n\tif (!lpUnicode) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tbool b = IsFontExcluded(lpUnicode);\r\n\tif (lpUnicode != szStack)\r\n\t\tfree(lpUnicode);\r\n\treturn b;\r\n}\r\n\r\nbool CGdippSettings::IsFontExcluded(LPCWSTR lpFaceName) const\r\n{\r\n\tFontHashMap::const_iterator it = m_arrExcludeFont.find(lpFaceName);\r\n\tbool bExcluded = it != m_arrExcludeFont.end();\t// if it's excluded, true\r\n\tif (!bExcluded && m_arrIncludeFont.size() != 0) {\t// if it's not excluded, and includefont enabled\r\n\t\tFontHashMap::const_iterator it = m_arrIncludeFont.find(lpFaceName);\r\n\t\tbExcluded = it == m_arrIncludeFont.end();\t// check if it's included\r\n\t}\r\n\treturn bExcluded;\r\n}\r\n\r\nvoid CGdippSettings::AddFontExclude(LPCWSTR lpFaceName)\r\n{\r\n\tif (!IsFontExcluded(lpFaceName))\r\n\t\tm_arrExcludeFont.insert(lpFaceName);\r\n}\r\n\r\nbool CGdippSettings::IsProcessUnload() const\r\n{\r\n\tif (m_bRunFromGdiExe) {\r\n\t\treturn false;\r\n\t}\r\n\tGetEnvironmentVariableW(L\"MACTYPE_FORCE_LOAD\", NULL, 0);\r\n\tif (GetLastError()!=ERROR_ENVVAR_NOT_FOUND)\r\n\t\treturn false;\r\n\tModuleHashMap::const_iterator it = m_arrUnloadModule.begin();\r\n\tfor(; it != m_arrUnloadModule.end(); ++it) {\r\n\t\tif (IsFolder(it->c_str())) {\r\n\t\t\t// if the user is trying to include a folder instead of a single executable.\r\n\t\t\tif (GetAppDir() == LowerCase(*it)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\tif (GetModuleHandleW(it->c_str())) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nbool CGdippSettings::IsExeUnload(LPCTSTR lpApp) const\t//紒E槭欠裨诤诿チ斜?\r\n{\r\n\tif (m_bRunFromGdiExe) {\r\n\t\treturn false;\r\n\t}\r\n\tGetEnvironmentVariableW(L\"MACTYPE_FORCE_LOAD\", NULL, 0);\r\n\tif (GetLastError()!=ERROR_ENVVAR_NOT_FOUND)\r\n\t\treturn false;\r\n\tModuleHashMap::const_iterator it = m_arrUnloadModule.begin();\r\n\tfor(; it != m_arrUnloadModule.end(); ++it) {\r\n\t\tif (!lstrcmpi(lpApp, it->c_str())) {\t//匹配排除蟻E\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nbool CGdippSettings::IsExeInclude(LPCTSTR lpApp) const\t//紒E槭欠裨诎酌チ斜?\r\n{\r\n\tif (m_bRunFromGdiExe) {\r\n\t\treturn false;\r\n\t}\r\n\tGetEnvironmentVariableW(L\"MACTYPE_FORCE_LOAD\", NULL, 0);\r\n\tif (GetLastError()!=ERROR_ENVVAR_NOT_FOUND)\r\n\t\treturn false;\r\n\tModuleHashMap::const_iterator it = m_arrIncludeModule.begin();\r\n\tfor(; it != m_arrIncludeModule.end(); ++it) {\r\n\t\tif (!lstrcmpi(lpApp, it->c_str())) {\t//匹配排除蟻E\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nbool CGdippSettings::IsProcessExcluded() const\r\n{\r\n\tif (m_bRunFromGdiExe) {\r\n\t\treturn false;\r\n\t}\r\n\tGetEnvironmentVariableW(L\"MACTYPE_FORCE_EXCLUDE\", NULL, 0);\r\n\tif (GetLastError() != ERROR_ENVVAR_NOT_FOUND)\r\n\t\treturn true;\r\n\tGetEnvironmentVariableW(L\"MACTYPE_FORCE_LOAD\", NULL, 0);\r\n\tif (GetLastError()!=ERROR_ENVVAR_NOT_FOUND)\r\n\t\treturn false;\r\n\tModuleHashMap::const_iterator it = m_arrExcludeModule.begin();\r\n\tfor(; it != m_arrExcludeModule.end(); ++it) {\r\n\t\tif (IsFolder(it->c_str())) {\r\n\t\t\t// if the user is trying to exclude a folder instead of a single executable.\r\n\t\t\tif (GetAppDir().find(LowerCase(*it)) == 0) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\tif (GetModuleHandleW(it->c_str())) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nbool CGdippSettings::IsProcessIncluded() const\r\n{\r\n\tif (m_bRunFromGdiExe) {\r\n\t\treturn true;\r\n\t}\r\n\tGetEnvironmentVariableW(L\"MACTYPE_FORCE_LOAD\", NULL, 0);\r\n\tif (GetLastError()!=ERROR_ENVVAR_NOT_FOUND)\r\n\t\treturn true;\r\n\tModuleHashMap::const_iterator it = m_arrIncludeModule.begin();\r\n\tfor(; it != m_arrIncludeModule.end(); ++it) {\r\n\t\tif (IsFolder(it->c_str())) {\r\n\t\t\t// if the user is trying to include a folder instead of a single executable.\r\n\t\t\tif (GetAppDir() == LowerCase(*it)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\tif (GetModuleHandleW(it->c_str())) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nvoid CGdippSettings::InitInitTuneTable()\r\n{\r\n\tint i, *table;\r\n#define init_table(name) \\\r\n\t\tfor (i=0,table=name; i<256; i++) table[i] = i\r\n\tinit_table(m_nTuneTable);\r\n\tinit_table(m_nTuneTableR);\r\n\tinit_table(m_nTuneTableG);\r\n\tinit_table(m_nTuneTableB);\r\n#undef init_table\r\n}\r\n\r\n// テーブル初期化関数 0 - 12まで\r\n// LCD用テーブル初期化関数 各0 - 12まで\r\nvoid CGdippSettings::InitTuneTable(int v, int* table)\r\n{\r\n\tint i;\r\n\tint col;\r\n\tdouble tmp, p;\r\n\r\n\tif (v < 0) {\r\n\t\treturn;\r\n\t}\r\n\tv = Min(v, 12);\r\n\tp = (double)v;\r\n\tp = 1 - (p / (p + 10.0));\r\n\tfor(i = 0;i < 256;i++){\r\n\t    tmp = (double)i / 255.0;\r\n        tmp = pow(tmp, p);\r\n\t    col = 255 - (int)(tmp * 255.0 + 0.5);\r\n\t\ttable[255 - i] = col;\r\n\t}\r\n}\r\n\r\n//見つからない場合は共通設定を返す\r\nextern BOOL g_ccbIndividual;\r\nconst CFontSettings& CGdippSettings::FindIndividual(LPCTSTR lpFaceName) const\r\n{\r\n\tCFontIndividual* p\t\t= m_arrIndividual.Begin();\r\n\tCFontIndividual* end\t= m_arrIndividual.End();\r\n\tif (lpFaceName && *lpFaceName==L'@')\r\n\t\t++lpFaceName;\t//纵向字体使用横向的设定\r\n\tStringHashFont hash(lpFaceName);\r\n\r\n\tfor(; p != end; ++p) {\r\n\t\tif (p->GetHash() == hash) {\r\n\t\t\tCFontSettings& result = p->GetIndividual();\r\n\t\t\tif (result.GetAntiAliasMode() > 2 && HarmonyLCD())\r\n\t\t\t\tresult.SetAntiAliasMode(2);\r\n\t\t\treturn result;\r\n\t\t}\r\n\t}\r\n\treturn GetFontSettings();\r\n}\r\n\r\nint CGdippSettings::_GetAlternativeProfileName(LPTSTR lpszName, LPCTSTR lpszFile)\r\n{\r\n\tTCHAR szexe[MAX_PATH + 1];\r\n\tTCHAR* pexe = szexe + GetModuleFileName(NULL, szexe, MAX_PATH);\r\n\twhile (pexe >= szexe && *pexe != '\\\\')\r\n\t\tpexe--;\r\n\tpexe++;\r\n\twstring exename = _T(\"General@\") + wstring((LPTSTR)pexe);\r\n\tif (FastGetProfileString(exename.c_str(), _T(\"Alternative\"), NULL, lpszName, MAX_PATH))\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\telse\r\n\t{\r\n\t\t//StringCchCopy(lpszName, MAX_PATH + 1, pexe);\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\nbool CGdippSettings::CopyForceFont(LOGFONT& lf, const LOGFONT& lfOrg) const\r\n{\r\n\t_ASSERTE(m_bDelayedInit);\r\n\t//__asm{ int 3 }\r\n\tGetEnvironmentVariableW(L\"MACTYPE_FONTSUBSTITUTES_ENV\", NULL, 0);\r\n\tif (GetLastError()!=ERROR_ENVVAR_NOT_FOUND)\r\n\t\treturn false;\r\n\t//&lf == &lfOrgも可\r\n\tbool bForceFont = false;\r\n\tBOOL bFontExist = true;\r\n\tconst LOGFONT *lplf;\r\n\tlplf = GetFontSubstitutesInfo().lookup((LOGFONT&)lfOrg);\r\n\tif (lplf) bForceFont = true;\r\n\r\n\tif (bForceFont) {\r\n\t\tmemcpy(&lf, &lfOrg, sizeof(LOGFONT)-sizeof(lf.lfFaceName));\r\n\t\tStringCchCopy(lf.lfFaceName, LF_FACESIZE, lplf->lfFaceName);\r\n\t}\r\n\treturn bForceFont;\r\n}\r\n\r\n//値的にchar(-128～127)で十分\r\nconst char CFontSettings::m_bound[MAX_FONT_SETTINGS][2] = {\r\n\t{ HINTING_MIN,\tHINTING_MAX\t},\t//Hinting\r\n\t{ AAMODE_MIN,\tAAMODE_MAX\t},\t//AAMode\r\n\t{ NWEIGHT_MIN,\tNWEIGHT_MAX\t},\t//NormalWeight\r\n\t{ BWEIGHT_MIN,\tBWEIGHT_MAX\t},\t//BoldWeight\r\n\t{ SLANT_MIN,\tSLANT_MAX\t},\t//ItalicSlant\r\n\t{ 0,\t\t\t1\t\t\t},\t//Kerning\r\n};\r\n\r\nCFontLinkInfo::CFontLinkInfo()\r\n{\r\n\tmemset(&info, 0, sizeof info);\r\n\tmemset(AllowDefaultLink, 1, sizeof(AllowDefaultLink));\t//默认允喧笾体链接\r\n}\r\n\r\nCFontLinkInfo::~CFontLinkInfo()\r\n{\r\n\tclear();\r\n}\r\n\r\n/*\r\nstatic int CALLBACK EnumFontCallBack(const LOGFONT *lplf, const TEXTMETRIC *lptm, DWORD / *FontType* /, LPARAM lParam)\r\n{\t\r\n\tLOGFONT * lf=(LOGFONT *)lParam;\r\n\tStringCchCopy(lf->lfFaceName, LF_FACESIZE, lplf->lfFaceName);\r\n\treturn 0;\r\n}\r\n\r\nstatic void GetFontLocalName(LOGFONT& lf)\t//获得字体的本地化名称\r\n{\r\n\tHDC dc=GetDC(NULL);\r\n\tEnumFontFamiliesEx(dc, &lf, &EnumFontCallBack, (LPARAM)&lf, 0);\r\n\tReleaseDC(NULL, dc);\r\n}*/\r\n\r\n\r\nvoid CFontLinkInfo::init()\r\n{\r\n\tconst TCHAR REGKEY1[] = _T(\"SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\FontLink\\\\SystemLink\");\r\n\tconst TCHAR REGKEY2[] = _T(\"SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Fonts\");\r\n\tconst TCHAR REGKEY3[] = _T(\"SYSTEM\\\\CurrentControlSet\\\\Control\\\\FontAssoc\\\\Associated DefaultFonts\");\r\n\tconst TCHAR REGKEY4[] = _T(\"SYSTEM\\\\CurrentControlSet\\\\Control\\\\FontAssoc\\\\Associated Charset\");\r\n\r\n\tHKEY h1;\r\n\tHKEY h2;\r\n\tif (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY1, 0, KEY_QUERY_VALUE, &h1)) return;\r\n\tif (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY2, 0, KEY_QUERY_VALUE, &h2)) {\r\n\t\tRegCloseKey(h1);\r\n\t\treturn;\r\n\t}\r\n\t//OSVERSIONINFO sOsVinfo={sizeof(OSVERSIONINFO),0,0,0,0,{0}};\r\n\t//GetVersionEx(&sOsVinfo);\t//获得操作系统版本号\r\n\t//const CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\r\n\tWCHAR* name = new WCHAR[0x2000];\r\n\tDWORD namesz;\r\n\tDWORD valuesz;\r\n\tWCHAR* value = new WCHAR[0x2000];\r\n\tWCHAR* buf = new WCHAR[0x2000];\r\n\tconst DWORD nBufSize = 0x2000 * sizeof(WCHAR);\r\n\tLONG rc;\r\n\tDWORD regtype;\r\n\r\n\tfor (int k = 0; ; ++k) {\t//获得字体柄蛐的所有字虂E\r\n\t\tnamesz = nBufSize;\r\n\t\tvaluesz = nBufSize;\r\n\t\trc = RegEnumValue(h2, k, name, &namesz, 0, &regtype, (LPBYTE)value, &valuesz);\t\t//从字体柄蛐寻找\r\n\t\tif (rc == ERROR_NO_MORE_ITEMS) break;\r\n\t\tif (rc != ERROR_SUCCESS) break;\r\n\t\tif (regtype != REG_SZ) continue;\r\n\t\tStringCchCopy(buf, nBufSize / sizeof(buf[0]), name);\r\n\t\tif (buf[wcslen(buf) - 1] == L')') {\t\t\t\t//去掉括号\r\n\t\t\tLPWSTR p;\r\n\t\t\tif ((p = wcsrchr(buf, L'(')) != NULL) {\r\n\t\t\t\t*p = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile (buf[wcslen(buf)-1] == L' ')\r\n\t\t\tbuf[wcslen(buf)-1] = 0;\r\n\t\t//获得的对应的字体脕E\r\n\t\tFontNameCache.Add(value, buf);\r\n\t}\r\n\r\n\tint row = 0;\r\n\tLOGFONT truefont;\r\n\tmemset(&truefont, 0, sizeof(truefont));\r\n\tfor (int i = 0; row < INFOMAX; ++i) {\r\n\t\tint col = 0;\r\n\r\n\t\tnamesz = nBufSize;\r\n\t\tvaluesz = nBufSize;\r\n\t\trc = RegEnumValue(h1, i, name, &namesz, 0, &regtype, (LPBYTE)value, &valuesz);\t//获得一个字体的字体链接\r\n\t\tif (rc == ERROR_NO_MORE_ITEMS) break;\r\n\t\tif (rc != ERROR_SUCCESS) break;\r\n\t\tif (regtype != REG_MULTI_SZ) continue;\t\t//有效的字体链接\r\n\t\t//获得字体的真实名字\r\n\t\t\r\n\t\tTCHAR buff[LF_FACESIZE];\r\n\t\tGetFontLocalName(name, buff);\r\n\r\n\t\tinfo[row][col] = _wcsdup(buff);\t\t//第一消戟字体脕E\r\n\t\t++col;\r\n\r\n\t\tfor (LPCWSTR linep = value; col < FONTMAX && *linep; linep += wcslen(linep) + 1) {\r\n\t\t\tLPCWSTR valp = NULL;\r\n\t\t\tfor (LPCWSTR p = linep; *p; ++p) {\r\n\t\t\t\tif (*p == L',' && ((char)*(p+1)<0x30 || (char)*(p+1)>0x39))\t\t//尝试寻找字体链接中“，”后提供的字体名称\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tLPWSTR lp;\r\n\t\t\t\t\t\tStringCchCopy(buf, nBufSize / sizeof(buf[0]), p + 1);\r\n\t\t\t\t\t\tif (lp=wcschr(buf, L','))\r\n\t\t\t\t\t\t\t*lp = 0;\r\n\t\t\t\t\t\tvalp = buf;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!valp) {\t\t//没找到字体链接中提供的名称\r\n\t\t\t\t/*for (int k = 0; ; ++k) {\r\n\t\t\t\t\tnamesz = sizeof name;\r\n\t\t\t\t\tvalue2sz = sizeof value2;\r\n\t\t\t\t\trc = RegEnumValue(h2, k, name, &namesz, 0, &regtype, (LPBYTE)value2, &value2sz);\t\t//从字体柄蛐寻找\r\n\t\t\t\t\tif (rc == ERROR_NO_MORE_ITEMS) break;\r\n\t\t\t\t\tif (rc != ERROR_SUCCESS) break;\r\n\t\t\t\t\tif (regtype != REG_SZ) continue;\r\n\t\t\t\t\tif (lstrcmpi(value2, linep) != 0) continue;\t\t//寻找字体链接中字体文件对应的字体脕E\r\n\r\n\t\t\t\t\tStringCchCopyW(buf, sizeof(buf)/sizeof(buf[0]), name);\r\n\t\t\t\t\tif (buf[wcslen(buf) - 1] == L')') {\t\t\t\t//去掉括号\r\n\t\t\t\t\t\tLPWSTR p;\r\n\t\t\t\t\t\tif ((p = wcsrchr(buf, L'(')) != NULL) {\r\n\t\t\t\t\t\t\t*p = 0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\twhile (buf[wcslen(buf)-1] == L' ')\r\n\t\t\t\t\t\tbuf[wcslen(buf)-1] = 0;\r\n\t\t\t\t\tvalp = buf;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}*/\r\n\t\t\t\tLPWSTR lp;\r\n\t\t\t\tStringCchCopy(buf, nBufSize / sizeof(buf[0]), linep);\r\n\t\t\t\tif (lp=wcschr(buf, L','))\r\n\t\t\t\t\t*lp = 0;\r\n\r\n\t\t\t\tvalp = FontNameCache.Find((TCHAR*)buf);\r\n\t\t\t}\r\n\t\t\tif (valp) {\r\n\t\t\t\tGetFontLocalName((TCHAR*)valp, buff);;\r\n\t\t\t\t//StringCchCopy(truefont.lfFaceName, LF_FACESIZE, buff);\t//复制到结构中\r\n\t\t\t\t//pSettings->CopyForceFont(truefont, truefont);\t\t//获得替换字虂E\r\n\t\t\t\tinfo[row][col] = _wcsdup(buff);//truefont.lfFaceName);\t\t\t//复制到链接柄蛐\r\n\t\t\t\t++col;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (col == 1) {\t\t\t//只有一消楷即没有链接，删掉。\r\n\t\t\tfree(info[row][0]);\r\n\t\t\tinfo[row][0] = NULL;\r\n\t\t} else {\r\n\t\t\t/*if (sOsVinfo.dwMajorVersion>=6 && sOsVinfo.dwMinorVersion>=1)\t//版本号>=6.1，是Win7系列\r\n\t\t\t{\r\n\t\t\t\t//对字体链接柄篥逆向处纴E\r\n\t\t\t\tLPWSTR swapbuff[32];\r\n\t\t\t\tmemcpy(swapbuff, info[row], 32*sizeof(LPWSTR));\t//整个柄源制过来\r\n\t\t\t\tfor (int i=1; i<col; i++)\r\n\t\t\t\t\tinfo[row][i]=swapbuff[col-i];\t//逆序字体链接眮E\r\n\t\t\t}*/\r\n\t\t\t++row;\r\n\t\t}\r\n\t}\r\n\tRegCloseKey(h1);\r\n\tRegCloseKey(h2);\r\n\tLOGFONT syslf = {0};\r\n\tHGDIOBJ h = ORIG_GetStockObject(DEFAULT_GUI_FONT);\r\n\tif (h) {\r\n\t\tORIG_GetObjectW(h, sizeof syslf, &syslf);\r\n\t\tGetFontLocalName(syslf.lfFaceName, syslf.lfFaceName);\r\n\t}\r\n\r\n\textern HFONT g_alterGUIFont;\r\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\tif (pSettings->FontSubstitutes()>=SETTING_FONTSUBSTITUTE_SAFE && pSettings->CopyForceFont(truefont, syslf))\t//使用蛠E婊荒Ｊ绞保婊坏粝低匙痔丒\r\n\t{\r\n\t\tWCHAR envname[30] = L\"MT_SYSFONT\";\r\n\t\tWCHAR envvalue[30] = { 0 };\r\n\t\tHFONT tempfont;\r\n\t\tif (GetEnvironmentVariable(L\"MT_SYSFONT\", envvalue, 29) && GetObjectType(tempfont = (HFONT)wcstoull(envvalue, 0 ,10)) == OBJ_FONT)//已经有字体存在\r\n\t\t{\r\n\t\t\tg_alterGUIFont = tempfont;\t//直接使用先前的字虂E\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tg_alterGUIFont = CreateFontIndirectW(&truefont);\t//创建一个新的替换字虂E\r\n\t\t\t_ui64tow((ULONG_PTR)g_alterGUIFont, envvalue, 10);\t//转换为字符串\r\n\t\t\tSetEnvironmentVariable(envname, envvalue);\t\t//写葋E肪潮淞?\r\n\t\t}\r\n\t}\r\n\r\n\t//现在获取对应字体类型的默认字体链接\r\n\tmemset(DefaultFontLink, 0, sizeof(TCHAR)*(FF_DECORATIVE+1)*(LF_FACESIZE+1));\t//初始化为0\r\n\tHKEY h3;\r\n\tDWORD len;\r\n\tif (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY3, 0, KEY_QUERY_VALUE, &h3)) return;\r\n\tlen = (LF_FACESIZE+1)*sizeof(TCHAR);\r\n\tRegQueryValueEx(h3, _T(\"FontPackage\"), 0, &regtype, (LPBYTE)DefaultFontLink[1], &len);\r\n\tlen = (LF_FACESIZE+1)*sizeof(TCHAR);\r\n\tRegQueryValueEx(h3, _T(\"FontPackageDecorative\"), 0, &regtype, (LPBYTE)DefaultFontLink[FF_DECORATIVE], &len);\r\n\tlen = (LF_FACESIZE+1)*sizeof(TCHAR);\r\n\tRegQueryValueEx(h3, _T(\"FontPackageDontCare\"), 0, &regtype, (LPBYTE)DefaultFontLink[FF_DONTCARE], &len);\r\n\tlen = (LF_FACESIZE+1)*sizeof(TCHAR);\r\n\tRegQueryValueEx(h3, _T(\"FontPackageModern\"), 0, &regtype, (LPBYTE)DefaultFontLink[FF_MODERN], &len);\r\n\tlen = (LF_FACESIZE+1)*sizeof(TCHAR);\r\n\tRegQueryValueEx(h3, _T(\"FontPackageRoman\"), 0, &regtype, (LPBYTE)DefaultFontLink[FF_ROMAN], &len);\r\n\tlen = (LF_FACESIZE+1)*sizeof(TCHAR);\r\n\tRegQueryValueEx(h3, _T(\"FontPackageScript\"), 0, &regtype, (LPBYTE)DefaultFontLink[FF_SCRIPT], &len);\r\n\tlen = (LF_FACESIZE+1)*sizeof(TCHAR);\r\n\tRegQueryValueEx(h3, _T(\"FontPackageSwiss\"), 0, &regtype, (LPBYTE)DefaultFontLink[FF_SWISS], &len);\r\n\tRegCloseKey(h3);\r\n\t\r\n\tfor (int i=0; i<FF_DECORATIVE+1; ++i)\t//转换字体名称\r\n\t{\r\n\t\tif (!*DefaultFontLink[i])\r\n\t\t\tGetFontLocalName(DefaultFontLink[i], DefaultFontLink[i]);\r\n\t}\r\n\r\n\t//现在获取对应的CodePage是否需要进行fontlink。默认都需要进行链接。\r\n\tHKEY h4;\r\n\tif (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY4, 0, KEY_QUERY_VALUE, &h4)) return;\r\n\r\n\tfor (int i=0; i<0xff; ++i)\r\n\t{\r\n\t\tnamesz = nBufSize;\r\n\t\tvaluesz = nBufSize;\r\n\t\trc = RegEnumValue(h4, i, name, &namesz, 0, &regtype, (LPBYTE)value, &valuesz);\t//获得一个charset的值\r\n\t\tif (rc == ERROR_NO_MORE_ITEMS) break;\r\n\t\tif (rc != ERROR_SUCCESS) break;\r\n\t\tif (regtype != REG_SZ) continue;\r\n\t\tif (_tcsicmp(value, _T(\"YES\")))\r\n\t\t{\r\n\t\t\tTCHAR* p = name;\r\n\t\t\twhile (*p!=_T('(') && p-name<(int)namesz) ++p;\r\n\t\t\t++p;\r\n\t\t\tAllowDefaultLink[_tcstol(p,NULL,16)]=false;\r\n\t\t}\r\n\t}\r\n\tRegCloseKey(h4);\r\n\tdelete[]name;\r\n\tdelete[]value;\r\n\tdelete[]buf;\r\n}\r\n\r\nvoid CFontLinkInfo::clear()\r\n{\r\n\tfor (int i = 0; i < INFOMAX; ++i) {\r\n\t\tfor (int j = 0; j < FONTMAX; ++j) {\r\n\t\t\tfree(info[i][j]);\r\n\t\t\tinfo[i][j] = NULL;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nconst LPCWSTR * CFontLinkInfo::lookup(LPCWSTR fontname) const\r\n{\r\n\tfor (int i = 0; i < INFOMAX && info[i][0]; ++i) {\r\n\t\tif (_wcsicmp(fontname, info[i][0]) == 0) {\r\n\t\t\treturn &info[i][1];\r\n\t\t}\r\n\t}\r\n\treturn NULL;\r\n}\r\n\r\nLPCWSTR CFontLinkInfo::get(int row, int col) const\r\n{\r\n\tif ((unsigned int)row >= (unsigned int)INFOMAX || (unsigned int)col >= (unsigned int)FONTMAX) {\r\n\t\treturn NULL;\r\n\t}\r\n\treturn info[row][col];\r\n}\r\n\r\nCFontSubstituteData::CFontSubstituteData()\r\n{\r\n\tmemset(this, 0, sizeof *this);\r\n}\r\n\r\nint CALLBACK\r\nCFontSubstituteData::EnumFontFamProc(const LOGFONT *lplf, const TEXTMETRIC *lptm, DWORD /*FontType*/, LPARAM lParam)\r\n{\r\n\tCFontSubstituteData& self = *(CFontSubstituteData *)lParam;\r\n\tself.m_lf = *lplf;\r\n\treturn 0;\r\n}\r\n\r\nbool CFontSubstituteData::initnocheck(LPCTSTR config) {\r\n\tmemset(this, 0, sizeof *this);\r\n\r\n\tTCHAR buf[LF_FACESIZE + 20];\r\n\tStringCchCopy(buf, countof(buf), config);\r\n\r\n\tmemset(&m_lf, 0, sizeof m_lf);\r\n\r\n\tLPTSTR p;\r\n\tfor (p = buf + lstrlen(buf) - 1; p >= buf; --p) {\r\n\t\tif (*p == _T(',')) {\r\n\t\t\t*p++ = 0;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif (p >= buf) {\r\n\t\tStringCchCopy(m_lf.lfFaceName, countof(m_lf.lfFaceName), buf);\r\n\t\tm_lf.lfCharSet = (BYTE)CGdippSettings::_StrToInt(p + 1, 0);\r\n\t\tm_bCharSet = true;\r\n\t}\r\n\telse {\r\n\t\tStringCchCopy(m_lf.lfFaceName, LF_FACESIZE, buf);\r\n\t\tm_lf.lfCharSet = DEFAULT_CHARSET;\r\n\t\tm_bCharSet = false;\r\n\t}\r\n\treturn m_lf.lfFaceName[0] != 0;\r\n}\r\n\r\nbool CFontSubstituteData::init(LPCTSTR config)\r\n{\r\n\tmemset(this, 0, sizeof *this);\r\n\r\n\tTCHAR buf[LF_FACESIZE + 20];\r\n\tStringCchCopy(buf, countof(buf), config);\r\n\r\n\tLOGFONT lf;\r\n\tmemset(&lf, 0, sizeof lf);\r\n\r\n\tLPTSTR p;\r\n\tfor (p = buf + lstrlen(buf) - 1; p >= buf; --p ) {\r\n\t\tif (*p == _T(',')) {\r\n\t\t\t*p++ = 0;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif (p >= buf) {\r\n\t\tStringCchCopy(lf.lfFaceName, countof(lf.lfFaceName), buf);\r\n\t\tlf.lfCharSet = (BYTE)CGdippSettings::_StrToInt(p + 1, 0);\r\n\t\tm_bCharSet = true;\r\n\t} else {\r\n\t\tStringCchCopy(lf.lfFaceName, LF_FACESIZE, buf);\r\n\t\tlf.lfCharSet = DEFAULT_CHARSET;\r\n\t\tm_bCharSet = false;\r\n\t}\r\n\r\n\tHDC hdc = GetDC(NULL);\r\n\tEnumFontFamiliesEx(hdc, &lf, &CFontSubstituteData::EnumFontFamProc, (LPARAM)this, 0);\r\n\tReleaseDC(NULL, hdc);\r\n\r\n\treturn m_lf.lfFaceName[0] != 0;\r\n}\r\n\r\nbool\r\nCFontSubstituteData::operator == (const CFontSubstituteData& o) const\r\n{\r\n\tif (m_bCharSet != o.m_bCharSet) return false;\r\n\tif (m_bCharSet) {\r\n\t\tif (m_lf.lfCharSet != o.m_lf.lfCharSet) return false;\r\n\t}\r\n\tif (_wcsicmp(m_lf.lfFaceName, o.m_lf.lfFaceName) == 0) return true;\r\n\treturn false;\r\n}\r\n\r\n// We scan the registry and see if there is any font mapping whose mapping target is also one of our substitution source, \r\n// and we add them as our rules.\r\nvoid CFontSubstitutesInfo::initreg()\r\n{\r\n\tconst LPCTSTR REGKEY = _T(\"SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\FontSubstitutes\");\r\n\tHKEY h;\r\n\tif (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY, 0, KEY_QUERY_VALUE, &h)) return;\r\n\tCFontSubstituteData k;\r\n\tCFontSubstituteData v;\r\n\r\n\tstd::vector<WCHAR> name(0x2000);\r\n\tstd::vector<WCHAR> value(0x2000);\r\n\tDWORD namesz, valuesz;\r\n\tDWORD regtype;\r\n\r\n\tfor (int i = 0; ; ++i) {\r\n\t\tnamesz = name.size();\r\n\t\tvaluesz = value.size();\r\n\t\tLONG rc = RegEnumValue(h, i, name.data(), &namesz, 0, &regtype, (LPBYTE)value.data(), &valuesz);\r\n\t\tif (rc == ERROR_NO_MORE_ITEMS) break;\r\n\t\tif (rc != ERROR_SUCCESS) break;\r\n\t\tif (regtype != REG_SZ) continue;\r\n\r\n\t\tif (k.initnocheck(name.data()) && v.init(value.data())) {\t// init k and v (k is a virtual font)\r\n\t\t\tint pos = FindKey(v);\r\n\t\t\tif ( pos >= 0) {\t// check if v is substituted to another font x\r\n\t\t\t\tAdd(k, GetValueAt(pos));\t// add k=>x as well\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tRegCloseKey(h);\r\n}\r\n\r\nvoid\r\nCFontSubstitutesInfo::initini(const CFontSubstitutesIniArray& iniarray)\r\n{\r\n\tCFontSubstitutesIniArray::const_iterator it=iniarray.begin();\r\n//\tLOGFONT truefont={0}, truefont2={0};\r\n//\tTCHAR* buff, *buff2;\r\n\tfor (; it!=iniarray.end(); ++it) {\r\n\t\tLPCTSTR inistr = it->c_str();\r\n\t\tLPTSTR buf = _tcsdup(inistr);\r\n\t\tfor (LPTSTR vp = buf; *vp; ++vp) {\r\n\t\t\tif (*vp == _T('=')) {\r\n\t\t\t\t*vp++ = 0;\r\n\t\t\t\tCFontSubstituteData k;\r\n\t\t\t\tCFontSubstituteData v;\r\n\t\t\t\tif (k.init(buf) && v.init(vp)) {\r\n\t\t\t\tif (FindKey(k) < 0 && k.m_bCharSet == v.m_bCharSet) Add(k, v);\r\n\t\t\t\t}\r\n/*\t\t\t\t\tStringCchCopy(truefont.lfFaceName, LF_FACESIZE, buf);\r\n\t\t\t\t\ttruefont.lfCharSet=DEFAULT_CHARSET;\r\n\t\t\t\t\tif (!GetFontLocalName(truefont))\r\n\t\t\t\t\t\tcontinue;\t//没有此字虂E\r\n\t\t\t\t\tbuff = truefont.lfFaceName;\r\n\r\n\t\t\t\t\tStringCchCopy(truefont2.lfFaceName, LF_FACESIZE, vp);\r\n\t\t\t\t\ttruefont2.lfCharSet=DEFAULT_CHARSET;\r\n\t\t\t\t\tif (!GetFontLocalName(truefont2))\r\n\t\t\t\t\t\tcontinue;\t//没有此字虂E\r\n\t\t\t\t\tbuff2 = truefont2.lfFaceName;\r\n\r\n\t\t\t\tif (m_mfontsub.find(buff)==m_mfontsub.end())\r\n\t\t\t\t\tm_mfontsub[buff]=wstring(buff2);\r\n*/\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfree(buf);\r\n\t}\r\n}\r\n\r\nvoid\r\nCFontSubstitutesInfo::init(int nFontSubstitutes, const CFontSubstitutesIniArray& iniarray)\r\n{\r\n\tif (nFontSubstitutes >= SETTING_FONTSUBSTITUTE_SAFE) {\r\n\t\tinitini(iniarray);\t// init substitution from ini array\r\n\t\tinitreg(); // add more substitutions from registry\r\n\t}\r\n}\r\n\r\nvoid GetMacTypeInternalFontName(LOGFONT* lf, LPTSTR fn)\r\n{\r\n\tStringCchCopy(fn, 9, _T(\"MACTYPE_\"));\r\n\tfn+=8;\r\n\tTCHAR* lfbyte=(TCHAR*)lf;\r\n\tfor (int i=0;i<(sizeof(LOGFONT)-sizeof(TCHAR)*LF_FACESIZE+1)/sizeof(TCHAR);i++)\r\n\t\t*fn++=_T('0') + *lfbyte++;\r\n\t*fn=0;\r\n}\r\n\r\nconst LOGFONT *\r\nCFontSubstitutesInfo::lookup(LOGFONT& lf) const\r\n{\r\n\tif (GetSize() <= 0) return NULL;\r\n\t//bFontExist = true;\r\n\tCFontSubstituteData v;\r\n\tCFontSubstituteData k;\r\n\r\n\tk.m_bCharSet = true;\r\n\tk.m_lf = lf;\r\n\r\n\tTCHAR * buff;\t//縼E倩竦米痔宓恼媸得?\r\n\tLOGFONT mylf(lf);\r\n\tif (!(buff = FontNameCache.Find((TCHAR*)lf.lfFaceName)))\r\n\t{\r\n\t\tTCHAR localname[LF_FACESIZE+1];\r\n\t\tif (GetFontLocalName(mylf.lfFaceName, localname)) {\r\n\t\t\tFontNameCache.Add((TCHAR*)lf.lfFaceName, localname);\r\n\t\t\tStringCchCopy(mylf.lfFaceName, LF_FACESIZE, localname);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tTCHAR inName[LF_FACESIZE];\r\n\t\t\tGetMacTypeInternalFontName(&mylf, inName);\r\n\t\t\tif (!(buff = FontNameCache.Find(inName)))\r\n\t\t\t{\r\n\t\t\t\tmylf.lfClipPrecision = FONT_MAGIC_NUMBER;\r\n\t\t\t\tHFONT tempfont = CreateFontIndirect(&mylf);\r\n\t\t\t\tHDC dc=CreateCompatibleDC(NULL);\r\n\t\t\t\tHFONT oldfont = SelectFont(dc, tempfont);\r\n\t\t\t\tORIG_GetTextFaceW(dc, LF_FACESIZE, mylf.lfFaceName);\r\n\t\t\t\tSelectFont(dc, oldfont);\r\n\t\t\t\tDeleteFont(tempfont);\r\n\t\t\t\tDeleteDC(dc);\r\n\t\t\t\tFontNameCache.Add(inName, mylf.lfFaceName);\r\n\t\t\t}\r\n\t\t}\r\n\t\tbuff = mylf.lfFaceName;\r\n\t}\r\n\tStringCchCopy(k.m_lf.lfFaceName, LF_FACESIZE, buff);\r\n\tStringCchCopy(lf.lfFaceName, LF_FACESIZE, buff);\r\n\r\n\tint pos = FindKey(k);\r\n\tif (pos < 0) {\r\n\t\tk.m_bCharSet = false;\r\n\t\tpos = FindKey(k);\r\n\t}\r\n\tif (pos >= 0) {\r\n\t\treturn (const LOGFONT *)&GetValueAt(pos);\r\n\t}\r\n\treturn NULL;\r\n}\r\n\r\nCFontFaceNamesEnumerator::CFontFaceNamesEnumerator(LPCWSTR facename, int nFontFamily) : m_pos(0)\r\n{\r\n\t//CCriticalSectionLock __lock;\r\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\tTCHAR  buff[LF_FACESIZE+1];\r\n\tGetFontLocalName((TCHAR*)facename, buff);\r\n\tLPCWSTR srcfacenames[] = {\r\n\t\tbuff, NULL, NULL\r\n\t};\r\n\r\n\tint destpos = 0;\r\n\tfor (const LPCWSTR *p = srcfacenames; *p && destpos < MAXFACENAMES; ++p) {\r\n\t\tm_facenames[destpos++] = *p;\r\n\t\tif (pSettings->FontLink()) {\r\n\t\t\tconst LPCWSTR *facenamep = pSettings->GetFontLinkInfo().lookup(*p);\r\n\t\t\tif (facenamep) {\r\n\t\t\t\tfor ( ; *facenamep && **facenamep && destpos < MAXFACENAMES; ++facenamep) {\r\n\t\t\t\t\tm_facenames[destpos++] = *facenamep;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tm_facenames[0] = facename;\r\n\tif (pSettings->IsWinXPorLater() && pSettings->FontLink() &&\r\n\t\tpSettings->FontLoader() == SETTING_FONTLOADER_FREETYPE) {\r\n\t\t\tm_facenames[destpos++] = pSettings->GetFontLinkInfo().sysfn(nFontFamily);\r\n\t}\r\n\tm_endpos = destpos;\r\n}\r\n"
        },
        {
          "name": "settings.h",
          "type": "blob",
          "size": 31.37109375,
          "content": "#pragma once\n\n#include \"common.h\"\n#include \"gdiPlusFlat2.h\"\n#include \"cache.h\"\n#include \"hash_list.h\"\n#include <VersionHelpers.h>\n#include <freetype/ftmodapi.h>\n#include <IniParser/ParseIni.h>\n#include \"json.hpp\"\n#include <thread>\n\nusing json = nlohmann::json;\n\n#ifdef _WIN64\n#ifdef DEBUG\n#pragma comment (lib, \"iniparser64_dbg.lib\")\n#else\n#pragma comment (lib, \"iniparser64.lib\")\n#endif\n#else\n#ifdef DEBUG\n#pragma comment (lib, \"iniparser_dbg.lib\")\n#else\n#pragma comment (lib, \"iniparser.lib\")\n#endif\n#endif\n\n#define MACTYPE_VERSION\t\t20220712\n#define MAX_FONT_SETTINGS\t16\n#define DEFINE_FS_MEMBER(name, param) \\\n\tint  Get##name() const { return GetParam(param); } \\\n\tvoid Set##name(int n)  { SetParam(param, n); }\n\n#define HOOK_MANUALLY HOOK_DEFINE\n#define HOOK_DEFINE(rettype, name, argtype, arglist) \\\n\textern rettype (WINAPI * ORIG_##name) argtype; \\\n\textern rettype WINAPI IMPL_##name argtype;\n#include \"hooklist.h\"\n#undef HOOK_DEFINE\t//为了确保此文件也能直接使用正确的函数，需要申明。\n#undef HOOK_MANUALLY\n\n/*\nstruct CFontName  \n{\n\tLPWSTR content;\npublic:\n\tbool operator < (const CFontName fn) const {\n\t\treturn wcscmp(content, fn.content)>0;\n\t}\n\tCFontName(LPCWSTR fontname)\n\t{\n\t\tcontent = _wcsdup(fontname);\n\t\twcsupr(content);\n\t}\n\t~CFontName()\n\t{\n\t\tfree(content);\n\t}\n};\n\nstruct CFontSubResult\n{\npublic:\n\tLPWSTR lpRealName;\n\tLPWSTR lpGDIName;\n\tCFontSubResult(LPCWSTR RealName, LPCWSTR GDIName)\n\t{\n\t\tlpRealName = _wcsdup(RealName);\n\t\tlpGDIName = _wcsdup(GDIName);\n\t}\n\t~CFontSubResult()\n\t{\n\t\tfree(lpRealName);\n\t\tfree(lpGDIName);\n\t}\n};\n\ntypedef map<CFontName,CFontSubResult> CFontNameCache;*/\n\n\nclass CFontSettings\n{\nprivate:\n\tint m_settings[MAX_FONT_SETTINGS];\n\tstatic const char m_bound[MAX_FONT_SETTINGS][2];\n\n\tenum _FontSettingsParams {\n\t\tFSP_HINTING\t\t\t= 0,\n\t\tFSP_AAMODE\t\t\t= 1,\n\t\tFSP_NORMAL_WEIGHT\t= 2,\n\t\tFSP_BOLD_WEIGHT\t\t= 3,\n\t\tFSP_ITALIC_SLANT\t= 4,\n\t\tFSP_KERNING\t\t\t= 5,\n\t};\n\npublic:\n\tCFontSettings()\n\t{\n\t\tClear();\n\t}\n\n\tDEFINE_FS_MEMBER(HintingMode,\tFSP_HINTING);\n\tDEFINE_FS_MEMBER(AntiAliasMode,\tFSP_AAMODE);\n\tDEFINE_FS_MEMBER(NormalWeight,\tFSP_NORMAL_WEIGHT);\n\tDEFINE_FS_MEMBER(BoldWeight,\tFSP_BOLD_WEIGHT);\n\tDEFINE_FS_MEMBER(ItalicSlant,\tFSP_ITALIC_SLANT);\n\tDEFINE_FS_MEMBER(Kerning,\t\tFSP_KERNING);\n\n\tint GetParam(int x) const\n\t{\n\t\tAssert(0 <= x && x < MAX_FONT_SETTINGS);\n\t\treturn m_settings[x];\n\t}\n\tvoid SetParam(int x, int n)\n\t{\n\t\tAssert(0 <= x && x < MAX_FONT_SETTINGS);\n\t\tm_settings[x] = Bound<int>(n, m_bound[x][0], m_bound[x][1]);\n\t}\n\tvoid Clear()\n\t{\n\t\tZeroMemory(m_settings, sizeof(m_settings));\n\t}\n\n\tvoid SetSettings(const int* p, int count)\n\t{\n\t\tcount = Min(count, MAX_FONT_SETTINGS);\n\t\tmemcpy(m_settings, p, count * sizeof(int));\n\t}\n};\n\n#undef DEFINE_FS_MEMBER\n\n\nclass CFontIndividual\n{\n\tCFontSettings\tm_set;\n\tStringHashFont\tm_hash;\n\npublic:\n\tCFontIndividual()\n\t{\n\t}\n\tCFontIndividual(LPCTSTR name)\n\t\t: m_hash(name)\n\t{\n\t}\n\n\tCFontSettings& GetIndividual() { return m_set; }\n\tLPCTSTR GetName() const { return m_hash.c_str(); }\n\tconst StringHashFont& GetHash() const { return m_hash; }\n\tbool operator ==(const CFontIndividual& x) const { return (m_hash == x.m_hash); }\n};\n\nclass CFontLinkInfo\n{\npublic:\n\tenum {\n\t\tINFOMAX = 180,\t//源文件=15\n\t\tFONTMAX = 31,\n\t};\nprivate:\n\tLPWSTR info[INFOMAX + 1][FONTMAX + 1];\n\tbool AllowDefaultLink[256];\n\tWCHAR DefaultFontLink[FF_DECORATIVE + 1][LF_FACESIZE + 1];\t//存放对应字体类型的默认链接\npublic:\n\tCFontLinkInfo();\n\t~CFontLinkInfo();\n\tvoid init();\n\tvoid clear();\n\tconst bool IsAllowFontLink(BYTE aCharset) const { return AllowDefaultLink[aCharset]; }\n\tconst LPCWSTR sysfn(int nFontFamily) const { \n\t\treturn *DefaultFontLink[nFontFamily] ? DefaultFontLink[nFontFamily] : DefaultFontLink[1];\t}\n\tconst LPCWSTR * lookup(LPCWSTR fontname) const;\n\tLPCWSTR get(int row, int col) const;\n};\n\nclass CFontSubstitutesInfo;\n\nclass CFontSubstituteData\n{\n\tfriend CFontSubstitutesInfo;\nprivate:\n\tLOGFONT m_lf;\n\tbool m_bCharSet;\n\t//TCHAR CustomName[LF_FACESIZE];\npublic:\n\tbool operator == (const CFontSubstituteData& o) const;\nprivate:\n\tCFontSubstituteData();\n\tbool initnocheck(LPCTSTR config);\t//init data w/o checking the font existence.\n\tbool init(LPCTSTR config);\n\tstatic int CALLBACK EnumFontFamProc(const LOGFONT *lplf, const TEXTMETRIC *lptm, DWORD FontType, LPARAM lParam);\n\n};\n\ntypedef StringHashT<LF_FACESIZE + 10,true> CFontSubstitutesHash;\ntypedef set<wstring> CFontSubstitutesIniArray;\n\nclass CFontSubstitutesInfo : public CSimpleMap<CFontSubstituteData, CFontSubstituteData>\n{\nprivate:\n\t//typedef map<wstring, wstring> FontSubMap; \n\t//FontSubMap m_mfontsub;\n\tvoid initini(const CFontSubstitutesIniArray& iniarray);\n\tvoid initreg();\npublic:\n\tvoid init(int nFontSubstitutes, const CFontSubstitutesIniArray& iniarray);\n\tconst LOGFONT * lookup(LOGFONT &lf) const;\n\t//void RemoveAll() {m_mfontsub.clear();};\n\t//bool TrySub(LPCTSTR lpFacename) {return m_mfontsub.find(lpFacename)!=m_mfontsub.end(); };\n};\n\n#define SETTING_FONTSUBSTITUTE_DISABLE\t(0)\n#define SETTING_FONTSUBSTITUTE_SAFE\t\t(1)\r\n#define SETTING_FONTSUBSTITUTE_ALL\t\t(2)\n\n#define SETTING_WIDTHMODE_GDI32    (0)\n#define SETTING_WIDTHMODE_FREETYPE (1)\n\n#define SETTING_FONTLOADER_FREETYPE  (0)\n#define SETTING_FONTLOADER_WIN32     (1)\n\nclass CGdippSettings;\n\ninterface IControlCenter\n{\n\tvirtual HRESULT STDMETHODCALLTYPE QueryInterface( \n\t\t/* [in] */ REFIID riid,\n\t\t/* [iid_is][out] */ __RPC__deref_out void __RPC_FAR *__RPC_FAR *ppvObject) = 0;\n\tvirtual ULONG STDMETHODCALLTYPE AddRef( void) = 0;\n\tvirtual ULONG STDMETHODCALLTYPE Release( void) = 0;\n\tvirtual ULONG WINAPI GetVersion(void) = 0;\n\tvirtual BOOL WINAPI SetIntAttribute(int eSet, int nValue) = 0;\n\tvirtual BOOL WINAPI SetFloatAttribute(int eSet, float nValue) = 0;\n\tvirtual int WINAPI GetIntAttribute(int eSet) = 0;\n\tvirtual float WINAPI GetFloatAttribute(int eSet) = 0;\n\tvirtual BOOL WINAPI RefreshSetting(void) = 0;\n\tvirtual BOOL WINAPI EnableRender(BOOL bEnable) = 0;\n\tvirtual BOOL WINAPI EnableCache(BOOL bEnable) = 0;\n\tvirtual BOOL WINAPI ClearIndividual() = 0;\n\tvirtual BOOL WINAPI AddIndividual(WCHAR* fontSetting) = 0;\n\tvirtual BOOL WINAPI DelIndividual(WCHAR* lpFaceName) = 0;\n\tvirtual void WINAPI LoadSetting(const WCHAR* lpFileName) = 0;\n\tvirtual HWND WINAPI CreateMessageWnd() = 0;\n\tvirtual void WINAPI DestroyMessageWnd() = 0;\n};\nclass CControlCenter;\n\nclass CGdippSettings\n{\n\tfriend CControlCenter;\n\tfriend CFontSubstituteData;\n\tfriend BOOL WINAPI DllMain(HINSTANCE, DWORD, LPVOID);\nprivate:\n\tstatic CGdippSettings* s_pInstance;\n\t//INI用\r\n\tCFontSettings m_FontSettings;\n\tstatic CParseIni m_Config;\n\tbool m_bHookChildProcesses\t\t: 1;\n\tbool m_bUseMapping\t\t\t\t: 1;\n\tbool m_bLoadOnDemand\t\t\t: 1;\n\tbool m_bEnableShadow\t\t\t: 1;\n\n\t//それ以外\r\n\tbool m_bIsWinXPorLater\t\t\t: 1;\n\tbool m_bRunFromGdiExe\t\t\t: 1;\n\tbool m_bIsInclude\t\t\t\t: 1;\n\tbool m_bDelayedInit\t\t\t\t: 1;\n//\tbool m_bIsHDBench\t\t\t\t: 1;\n//\tbool m_bHaveNewerFreeType\t\t: 1;\n\tbool\t\t\t\t\t\t\t: 0;\n\tbool m_bUseCustomLcdFilter;\t// use custom lcdfilter\n\tbool m_bUseCustomPixelLayout;\n\n\tBOOL m_bHintSmallFont;\n\tBOOL m_bDirectWrite;\n\tint  m_nBolderMode;\n\tint  m_nGammaMode;\n\tfloat m_fGammaValue;\n\tfloat m_fRenderWeight;\n\tfloat m_fContrast;\n\tint  m_nMaxHeight;\n\tint  m_nMinHeight;\n\tint  m_nBitmapHeight;\n\tint  m_nLcdFilter;\n\tint  m_nShadow[4];\n\tint  m_nFontSubstitutes;\n\tint\t m_bFontLink;\t//改为可以使用多种参数\n\tint  m_nWidthMode;\n\n\tint  m_nFontLoader;\n\tint\t m_nScreenDpi;\t// screen dpi\n\tDWORD m_nShadowLightColor;\n\tDWORD m_nShadowDarkColor;\n\tunsigned char m_arrLcdFilterWeights[5];\n\tchar m_arrPixelLayout[6];\n\n\t//settings for experimental\n\tbool m_bEnableClipBoxFix;\n\tbool m_bColorFont;\n\tbool m_bInvertColor;\n\n\n\t//settings for directwrite\n\tfloat m_fGammaValueForDW;\n\tfloat m_fContrastForDW;\n\tfloat m_fClearTypeLevelForDW;\n\tint\tm_nRenderingModeForDW;\n\tint m_nAntiAliasModeForDW;\n    CFontSubstitutesInfo m_FontSubstitutesInfoForDW;\n\n\t//FTC_Manager_Newに渡すパラメータ\n\tint  m_nCacheMaxFaces;\n\tint  m_nCacheMaxSizes;\n\tint  m_nCacheMaxBytes;\n\tint\t m_dwOSMajorVer;\n\tint\t m_dwOSMinorVer;\n\n\t// アンチエイリアス調整用テーブル\n\tint  m_nTuneTable[256];\n\t// LCD用\n\tint  m_nTuneTableR[256];\n\tint  m_nTuneTableG[256];\n\tint  m_nTuneTableB[256];\n\tstatic TCHAR m_szexeName[MAX_PATH+1];\n\n\ttypedef set<wstring>\tFontHashMap;\n\ttypedef set<wstring>\tModuleHashMap;\n\ttypedef set<wstring> FontSubSet;\n\ttypedef CArray<CFontIndividual>\tIndividualArray;\n\tFontHashMap\t\tm_arrExcludeFont;\n\tFontHashMap\t\tm_arrIncludeFont;\n\tModuleHashMap\tm_arrExcludeModule;\n\tModuleHashMap\tm_arrIncludeModule;\n\tModuleHashMap\tm_arrUnloadModule;\n\tModuleHashMap\tm_arrUnFontSubModule;\n\tIndividualArray\tm_arrIndividual;\n\n\t// 指定フォント\n\tLOGFONT m_lfForceFont;\n\tTCHAR m_szForceChangeFont[LF_FACESIZE];\n\n\t//INIファイル名\n\tTCHAR m_szFileName[MAX_PATH];\n\n\t//INIからの読み込み処理\n\tbool LoadAppSettings(LPCTSTR lpszFile);\n\tvoid GetOSVersion();\n\tfloat FastGetProfileFloat(LPCTSTR lpszSection, LPCTSTR lpszKey, float fDefault);\n\tint FastGetProfileInt(LPCTSTR lpszSection, LPCTSTR lpszKey, int nDefault);\n\tDWORD FastGetProfileString(LPCTSTR lpszSection, LPCTSTR lpszKey, LPCTSTR lpszDefault, LPTSTR lpszRet, DWORD cch);\n\tstatic bool\t\t_IsFreeTypeProfileSectionExists(LPCTSTR lpszKey, LPCTSTR lpszFile);\n\tstatic LPTSTR _GetPrivateProfileSection    (LPCTSTR lpszSection, LPCTSTR lpszFile);\n\tstatic int    _GetFreeTypeProfileInt       (LPCTSTR lpszKey, int nDefault, LPCTSTR lpszFile);\n\tstatic int\t  _GetFreeTypeProfileIntFromSection(LPCTSTR lpszSection, LPCTSTR lpszKey, int nDefault, LPCTSTR lpszFile);\n\tstatic bool   _GetFreeTypeProfileBoolFromSection(LPCTSTR lpszSection, LPCTSTR lpszKey, bool nDefault, LPCTSTR lpszFile);\n\tstatic wstring _GetFreeTypeProfileStrFromSection(LPCTSTR lpszSection, LPCTSTR lpszKey, const TCHAR* nDefault, LPCTSTR lpszFile);\n\tstatic int    _GetFreeTypeProfileBoundInt  (LPCTSTR lpszKey, int nDefault, int nMin, int nMax, LPCTSTR lpszFile);\n\tstatic float  _GetFreeTypeProfileFloat     (LPCTSTR lpszKey, float fDefault, LPCTSTR lpszFile);\n\tstatic float  _GetFreeTypeProfileBoundFloat(LPCTSTR lpszKey, float fDefault, float fMin, float fMax, LPCTSTR lpszFile);\n\tstatic DWORD  _GetFreeTypeProfileString    (LPCTSTR lpszKey, LPCTSTR lpszDefault, LPTSTR lpszRet, DWORD cch, LPCTSTR lpszFile);\n\t//template <typename T>\n\tstatic bool AddListFromSection(LPCTSTR lpszSection, LPCTSTR lpszFile, set<wstring> & arr);\n\tstatic bool AddExcludeListFromSection(LPCTSTR lpszSection, LPCTSTR lpszFile, set<wstring> & arr);\n\tbool AddIndividualFromSection(LPCTSTR lpszSection, LPCTSTR lpszFile, IndividualArray& arr);\n\tbool AddLcdFilterFromSection(LPCTSTR lpszKey, LPCTSTR lpszFile, unsigned char* arr);\n\tbool AddPixelModeFromSection(LPCTSTR lpszKey, LPCTSTR lpszFile, char* arr);\n\tstatic int   _StrToInt(LPCTSTR pStr, int nDefault);\n\tstatic float _StrToFloat(LPCTSTR pStr, float fDefault);\n\tstatic int _httoi(const TCHAR *value);\n\tvoid InitInitTuneTable();\n\tstatic void InitTuneTable(int v, int* table);\n\tvoid DelayedInit();\n\tint\t_GetAlternativeProfileName(LPTSTR lpszName, LPCTSTR lpszFile);\n\n\tCFontLinkInfo m_fontlinkinfo;\n\tCFontSubstitutesInfo m_FontSubstitutesInfo;\n\n\tCGdippSettings()\n\t\t: m_bHookChildProcesses(false)\n\t\t, m_bUseMapping(false)\n\t\t, m_bLoadOnDemand(false)\n\t\t, m_bEnableShadow(false)\n\t\t, m_bFontLink(0)\n//\t\t, m_bEnableKerning(false)\n\t\t, m_bIsWinXPorLater(false)\n\t\t, m_bRunFromGdiExe(false)\n\t\t, m_bIsInclude(false)\n\t\t, m_bDelayedInit(false)\n//\t\t, m_bIsHDBench(false)\n//\t\t, m_bHaveNewerFreeType(false)\n\t\t, m_nBolderMode(0)\n\t\t, m_nGammaMode(0)\n\t\t, m_fGammaValue(1.0f)\n\t\t, m_fGammaValueForDW(0.0f)\n\t\t, m_nAntiAliasModeForDW(0)\n\t\t, m_fRenderWeight(1.0f)\n\t\t, m_fContrast(1.0f)\n\t\t, m_nMaxHeight(0)\n\t\t, m_nMinHeight(0)\n\t\t, m_nBitmapHeight(0)\n\t\t, m_nLcdFilter(0)\n\t\t, m_nCacheMaxFaces(0)\n\t\t, m_nCacheMaxSizes(0)\n\t\t, m_nCacheMaxBytes(0)\n\t\t, m_bHintSmallFont(true)\n\t\t, m_bDirectWrite(true)\n\t\t, m_nScreenDpi(96)\n\t\t, m_bUseCustomPixelLayout(false)\n\t{\n\t\tZeroMemory(m_nTuneTable,\t\tsizeof(m_nTuneTable));\n\t\tZeroMemory(m_nTuneTableR,\t\tsizeof(m_nTuneTableR));\n\t\tZeroMemory(m_nTuneTableG,\t\tsizeof(m_nTuneTableG));\n\t\tZeroMemory(m_nTuneTableB,\t\tsizeof(m_nTuneTableB));\n\t\tZeroMemory(&m_lfForceFont,\t\tsizeof(LOGFONT));\n\t\tZeroMemory(m_nShadow,\t\t\tsizeof(m_nShadow));\n\t\tZeroMemory(m_szFileName,\t\tsizeof(m_szFileName));\n\t\tZeroMemory(m_szForceChangeFont,\tsizeof(m_szForceChangeFont));\n\t}\n\n\t~CGdippSettings()\n\t{\n\n\t}\n\n\tstatic CGdippSettings* CreateInstance();\n\tstatic void DestroyInstance();\n\npublic:\n\tstatic CGdippSettings* GetInstance();\n\tstatic const CGdippSettings* GetInstanceNoInit();\t//FreeTypeFontEngine\n\n\t//INI用\r\n\tconst CFontSettings& GetFontSettings() const { return m_FontSettings; }\n\tbool HookChildProcesses() const { return m_bHookChildProcesses; }\n\tbool UseMapping() const { return m_bUseMapping; }\n\tbool LoadOnDemand() const { return m_bLoadOnDemand; }\n\tchar FontLink() const { return m_bFontLink; }\n\tBOOL DirectWrite() const { return m_bDirectWrite; }\n\tBOOL HintSmallFont() const { return m_bHintSmallFont; }\n//\tbool EnableKerning() const { return m_bEnableKerning; }\n\n\tint BolderMode() const { return m_nBolderMode; }\n\tint GammaMode() const { return m_nGammaMode; }\n\tfloat GammaValue() const { return m_fGammaValue; }\n\t// Only fallback to tranditional ClearType mode when Custom LCD Filter is defined, and pixelLayout is not defined and AAMode is not in pentile.\n\tbool HarmonyLCD() const { return m_bUseCustomPixelLayout || m_FontSettings.GetAntiAliasMode() == 6 || !m_bUseCustomLcdFilter; }\n\n\t//DW options\n\tfloat GammaValueForDW() const {\treturn m_fGammaValueForDW;\t}\n\tfloat ContrastForDW() const { return m_fContrastForDW;  }\n\tfloat ClearTypeLevelForDW() const { return m_fClearTypeLevelForDW;  }\n\tint RenderingModeForDW() const { return m_nRenderingModeForDW; }\n\tint AntiAliasModeForDW() const { return m_nAntiAliasModeForDW; }\n\t/*const CFontSubstitutesInfo& GetFontSubstitutesInfoForDW() const\n\t\t{ _ASSERTE(m_bDelayedInit); return m_FontSubstitutesInfoForDW; }*/\n\n\tfloat RenderWeight() const { return m_fRenderWeight; }\n\tfloat Contrast() const { return m_fContrast; }\n\tint MaxHeight() const { return m_nMaxHeight; }\n\tint MinHeight() const { return m_nMinHeight; }\n\tint BitmapHeight() const { return m_nBitmapHeight; }\n\tint ScreenDpi() const { return m_nScreenDpi;  }\n\tint LcdFilter() const { return m_nLcdFilter; }\n\tconst unsigned char* LcdFilterWeights() const { return m_arrLcdFilterWeights; }\n\tbool UseCustomLcdFilter() const { return m_bUseCustomLcdFilter; }\n\tint WidthMode() const { return m_nWidthMode; }\n\tint FontLoader() const { return m_nFontLoader; }\n\tbool EnableClipBoxFix() const { return m_bEnableClipBoxFix; }\n\tbool LoadColorFont() const { return m_bColorFont; }\n\tbool InvertColor() const { return m_bInvertColor; }\n\tDWORD ShadowLightColor() const { return m_nShadowLightColor; }\n\tDWORD ShadowDarkColor() const { return m_nShadowDarkColor; }\n\tint FontSubstitutes() const { return m_nFontSubstitutes; }\t//判断替换模式\n\tint CacheMaxFaces() const { return m_nCacheMaxFaces; }\n\tint CacheMaxSizes() const { return m_nCacheMaxSizes; }\n\tint CacheMaxBytes() const { return m_nCacheMaxBytes; }\n\n\tbool EnableShadow()  const { return m_bEnableShadow; }\n\tconst int* GetShadowParams() const { return m_nShadow; }\n\tbool DelayedInited() const { return m_bDelayedInit; }\t// return the delayedinit status\n\n// OS version comparsion for magic code\n\tbool IsWindows8() const { return m_dwOSMajorVer == 6 && m_dwOSMinorVer == 2; }\n\tbool IsWindows81() const { return m_dwOSMajorVer == 6 && m_dwOSMinorVer == 3; }\n\n\tbool CopyForceFont(LOGFONT& lf, const LOGFONT& lfOrg) const;\n\n\t//それ以外\n\tbool IsWinXPorLater() const { return m_bIsWinXPorLater; }\n\tbool IsInclude() const { return m_bIsInclude; }\n//\tbool IsHDBench() const { return m_bIsHDBench; }\n\tbool RunFromGdiExe() const { return m_bRunFromGdiExe; }\n//\tbool HaveNewerFreeType() const { return m_bHaveNewerFreeType; }\n\tconst int* GetTuneTable() const { return m_nTuneTable; }\n\tconst int* GetTuneTableR() const { return m_nTuneTableR; }\n\tconst int* GetTuneTableG() const { return m_nTuneTableG; }\n\tconst int* GetTuneTableB() const { return m_nTuneTableB; }\n\n\tbool LoadSettings(HINSTANCE hModule);\n\n\tbool IsFontExcluded(LPCSTR lpFaceName) const;\n\tbool IsFontExcluded(LPCWSTR lpFaceName) const;\n\n\t//Snowie!!\n\tbool IsProcessUnload() const;\n\tbool IsExeUnload(LPCTSTR lpApp) const;\n\tbool IsExeInclude(LPCTSTR lpApp) const;\n\tvoid AddFontExclude(LPCWSTR lpFaceName);\t//点阵字体直接自动添加到此列表\n\tbool IsProcessExcluded() const;\n\tbool IsProcessIncluded() const;\n\tconst CFontSettings& FindIndividual(LPCTSTR lpFaceName) const;\n\n\tconst CFontLinkInfo& GetFontLinkInfo() const\n\t\t{ _ASSERTE(m_bDelayedInit); return m_fontlinkinfo; }\n\tconst CFontSubstitutesInfo& GetFontSubstitutesInfo() const\n\t\t{ _ASSERTE(m_bDelayedInit); return m_FontSubstitutesInfo; }\n};\n\nclass CFontFaceNamesEnumerator\n{\nprivate:\n\tenum {\n\t\tMAXFACENAMES = CFontLinkInfo::FONTMAX * 2 + 1,\n\t};\n\tLPCWSTR m_facenames[MAXFACENAMES];\n\tint m_pos;\n\tint m_endpos;\n\tCFontFaceNamesEnumerator();\npublic:\n\tCFontFaceNamesEnumerator(LPCWSTR facename, int nFontFamily);\n\toperator LPCWSTR () {\n\t\treturn m_facenames[m_pos];\n\t}\n\tLPCWSTR getname()\n\t{\n\t\treturn m_facenames[m_pos];\n\t}\n\tvoid next() {\n\t\t++m_pos;\n\t}\n\tvoid prev() {\n\t\tm_pos>0?--m_pos:0;\n\t}\n\tbool atend() {\n\t\treturn !!(m_pos >= m_endpos);\n\t}\n};\n#include \"fteng.h\"\n#include \"ft.h\"\n#include <freetype/ftlcdfil.h>\n#include \"strtoken.h\"\nextern FreeTypeFontEngine* g_pFTEngine;\nextern BOOL g_ccbCache;\nextern BOOL g_ccbRender;\n\nextern CControlCenter* g_ControlCenter;\n\nclass CControlCenter: public IControlCenter\n{\nprivate:\n\tint m_nRefCount;\n\tbool m_bDirty;\n\tHWND m_msgwnd;\n\tenum eMTSettings{\n\t\tATTR_HINTINGMODE,\n\t\tATTR_ANTIALIASMODE,\n\t\tATTR_NormalWeight,\n\t\tATTR_BoldWeight,\n\t\tATTR_ItalicSlant,\n\t\tATTR_EnableKerning,\n\t\tATTR_GammaMode,\n\t\tATTR_LcdFilter,\n\t\tATTR_BolderMode,\n\t\tATTR_TextTuning,\n\t\tATTR_TextTuningR,\n\t\tATTR_TextTuningG,\n\t\tATTR_TextTuningB,\n\t\tATTR_GammaValue,\n\t\tATTR_Contrast,\n\t\tATTR_RenderWeight,\n\t\tATTR_ShadowAlpha,\n\t\tATTR_ShadowOffset,\n\t\tATTR_Fontlink,\n\t\tATTR_HookChildProcess,\n\t\tATTR_LoadOnDemand,\n\t\tATTR_FontLoader,\n\t\tATTR_FontSubstitute,\n\t\tATTR_LcdFilterWeight,\n\t\tATTR_ShadowBuffer,\n\t\tATTR_MaxBitmap, \n\t\tATTR_DirectWrite, \n\t\tATTR_HintSmallFont\n\t};\n\ttypedef CArray<CFontIndividual>\t\tIndividualArray;\npublic:\n\tHRESULT STDMETHODCALLTYPE QueryInterface( \n\t\t/* [in] */ REFIID riid,\n\t\t/* [iid_is][out] */ __RPC__deref_out void __RPC_FAR *__RPC_FAR *ppvObject)\n\t{\n\t\tppvObject = (void**)this;\n\t\treturn 0;\n\t}\n\tULONG STDMETHODCALLTYPE AddRef( void) {return InterlockedIncrement((LONG*)&m_nRefCount);};\n\tULONG STDMETHODCALLTYPE Release( void) { \n\t\tint result = InterlockedDecrement((LONG*)&m_nRefCount);\n\t\tif (!result)\n\t\t\tdelete this;\n\t\treturn result;\n\t}\n\tULONG WINAPI GetVersion(void){ return MACTYPE_VERSION; };\n\tstatic void UpdateLcdFilter()\r\n\t{\r\n\t\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\r\n\t\tif (pSettings->HarmonyLCD()) {\r\n\t\t\tFT_LCDMode_Set(freetype_library, 1);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tFT_LCDMode_Set(freetype_library, 0);\r\n\t\tconst int nLcdFilter = pSettings->LcdFilter();\r\n\t\tif ((int)FT_LCD_FILTER_NONE <= nLcdFilter && nLcdFilter < (int)FT_LCD_FILTER_MAX) {\r\n\t\t\tFT_Library_SetLcdFilter(freetype_library, (FT_LcdFilter)nLcdFilter);\r\n\t\t\tif (pSettings->UseCustomLcdFilter())\r\n\t\t\t{\r\n\t\t\t\tunsigned char buff[5];\r\n\t\t\t\tmemcpy(buff, pSettings->LcdFilterWeights(), sizeof(buff));\r\n\t\t\t\tFT_Library_SetLcdFilterWeights(freetype_library, buff);\r\n\t\t\t}\r\n\t\t\t/*\r\n\t\t\telse\r\n\t\t\tswitch (nLcdFilter)\r\n\t\t\t{\r\n\t\t\tcase FT_LCD_FILTER_NONE:\r\n\t\t\tcase FT_LCD_FILTER_DEFAULT:\r\n\t\t\tcase FT_LCD_FILTER_LEGACY:\r\n\t\t\t{\r\n\t\t\tFT_Library_SetLcdFilterWeights(freetype_library,\r\n\t\t\t(unsigned char*)\"\\x10\\x40\\x70\\x40\\x10\" );\r\n\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase FT_LCD_FILTER_LIGHT:\r\n\t\t\tdefault:\r\n\t\t\tFT_Library_SetLcdFilterWeights(freetype_library,\r\n\t\t\t(unsigned char*)\"\\x00\\x55\\x56\\x55\\x00\" );\r\n\t\t\t}*/\r\n\r\n\t\t}\r\n\t}\r\n\n\tBOOL WINAPI SetIntAttribute(int eSet, int nValue)\n\t{\n\t\tCGdippSettings* pSettings = CGdippSettings::GetInstance();\n\t\tswitch ((eMTSettings)eSet)\n\t\t{\n\t\tcase ATTR_HINTINGMODE:\n\t\t\tpSettings->m_FontSettings.SetHintingMode(nValue);\n\t\t\tbreak;\n\t\tcase ATTR_ANTIALIASMODE:\n\t\t\tpSettings->m_FontSettings.SetAntiAliasMode(nValue);\n\t\t\tbreak;\n\t\tcase ATTR_NormalWeight:\n\t\t\tpSettings->m_FontSettings.SetNormalWeight(nValue);\n\t\t\tbreak;\n\t\tcase ATTR_BoldWeight:\n\t\t\tpSettings->m_FontSettings.SetBoldWeight(nValue);\n\t\t\tbreak;\n\t\tcase ATTR_ItalicSlant:\n\t\t\tpSettings->m_FontSettings.SetItalicSlant(nValue);\n\t\t\tbreak;\n\t\tcase ATTR_EnableKerning:\n\t\t\tpSettings->m_FontSettings.SetKerning(nValue);\n\t\t\tbreak;\n\t\tcase ATTR_GammaMode:\n\t\t\tpSettings->m_nGammaMode = nValue;\n\t\t\tRefreshAlphaTable();\n\t\t\tbreak;\n\t\tcase ATTR_LcdFilter:\n\t\t\tpSettings->m_nLcdFilter = nValue;\n\t\t\tUpdateLcdFilter();\n\t\t\tbreak;\n\t\tcase ATTR_BolderMode:\n\t\t\tpSettings->m_nBolderMode = nValue;\n\t\t\tbreak;\n\t\tcase ATTR_TextTuning:\n\t\t\tpSettings->InitTuneTable(nValue,  pSettings->m_nTuneTable);\n\t\t\tRefreshAlphaTable();\n\t\t\tbreak;\n\t\tcase ATTR_TextTuningR:\n\t\t\tpSettings->InitTuneTable(nValue,  pSettings->m_nTuneTableR);\n\t\t\tRefreshAlphaTable();\n\t\t\tbreak;\n\t\tcase ATTR_TextTuningG:\n\t\t\tpSettings->InitTuneTable(nValue,  pSettings->m_nTuneTableG);\n\t\t\tRefreshAlphaTable();\n\t\t\tbreak;\n\t\tcase ATTR_TextTuningB:\n\t\t\tpSettings->InitTuneTable(nValue,  pSettings->m_nTuneTableB);\n\t\t\tRefreshAlphaTable();\n\t\t\tbreak;\n\t\tcase ATTR_LoadOnDemand:\n\t\t\tpSettings->m_bLoadOnDemand = !!nValue;\n\t\t\tbreak;\n\t\tcase ATTR_ShadowAlpha:\n\t\t\tpSettings->m_nShadow[2] = nValue;\n\t\t\tpSettings->m_bEnableShadow = (nValue!=1);\n\t\t\tRefreshAlphaTable();\n\t\t\tbreak;\n\t\tcase ATTR_ShadowOffset:\n\t\t\tpSettings->m_nShadow[1] = nValue;\n\t\t\tpSettings->m_nShadow[0] = nValue;\n\t\tcase ATTR_Fontlink:\n\t\t\tif (!!pSettings->m_bFontLink != !!nValue)\n\t\t\t{\n\t\t\t\tpSettings->m_fontlinkinfo.clear();\n\t\t\t\tif (nValue)\n\t\t\t\t\tpSettings->m_fontlinkinfo.init();\n\t\t\t}\n\t\t\tpSettings->m_bFontLink = nValue;\n\t\t\tbreak;\t\n\t\tcase ATTR_FontLoader:\n\t\t\tpSettings->m_nFontLoader = nValue;\n\t\t\tbreak;\n\t\tcase ATTR_LcdFilterWeight:\n\t\t\tif (!nValue)\n\t\t\t\tpSettings->m_bUseCustomLcdFilter = false;\t//传NULL过来就是关闭自定义过滤器\n\t\t\telse\n\t\t\t{\n\t\t\t\tpSettings->m_bUseCustomLcdFilter = true;\t//否则打开过滤器\n\t\t\t\tif (!IsBadReadPtr((void*)nValue, sizeof(pSettings->m_arrLcdFilterWeights)))\t//如果指针有效\n\t\t\t\t\tmemcpy(pSettings->m_arrLcdFilterWeights, (void*)nValue, sizeof(pSettings->m_arrLcdFilterWeights));\t//复制数据\n\t\t\t}\n\t\t\tUpdateLcdFilter();\t//刷新过滤器\n\t\t\tbreak;\n\t\tcase ATTR_HintSmallFont:\n\t\t\tpSettings->m_bHintSmallFont = !!nValue;\n\t\t\tbreak;\n\t\tcase ATTR_MaxBitmap:\n\t\t\tpSettings->m_nBitmapHeight = nValue;\n\t\t\tbreak;\n\t\tcase ATTR_ShadowBuffer:\n\t\t\tif (nValue && !IsBadReadPtr((void*)nValue, sizeof(pSettings->m_nShadow)))\t//指针有效\n\t\t\t{\n\t\t\t\tLPCTSTR szShadow = (LPCTSTR)nValue;\n\t\t\t\tCStringTokenizer token;\n\n\t\t\t\tif (token.Parse(szShadow) < 3) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int i=0; i<3; i++) {\n\t\t\t\t\tpSettings->m_nShadow[i] = pSettings->_StrToInt(token.GetArgument(i), 0);\n\t\t\t\t\t/*if (m_nShadow[i] <= 0) {\n\t\t\t\t\t\tgoto SKIP;\n\t\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t\tpSettings->m_bEnableShadow = true;\n\t\t\t\tif (token.GetCount()>=4)\t//如果指定了浅色阴影\n\t\t\t\t\tpSettings->m_nShadowDarkColor = pSettings->_httoi(token.GetArgument(3));\t//读取阴影\n\t\t\t\telse\n\t\t\t\t\tpSettings->m_nShadowDarkColor = 0;\t//否则为黑色\n\t\t\t\tif (token.GetCount()>=6)\t//如果指定了深色阴影\n\t\t\t\t{\n\t\t\t\t\tpSettings->m_nShadowLightColor = pSettings->_httoi(token.GetArgument(5));\t//读取阴影\n\t\t\t\t\tpSettings->m_nShadow[3] = pSettings->_StrToInt(token.GetArgument(4), pSettings->m_nShadow[2]); //读取深度\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//pSettings->m_nShadowLightColor = pSettings->m_nShadowLightColor;\t\t//否则和浅色阴影相同\n\t\t\t\t\tpSettings->m_nShadow[3] = pSettings->m_nShadow[2];\t\t//深度也相同\n\t\t\t\t}\n\t\t\t\tRefreshAlphaTable();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn FALSE;\n\t\t}\t\n\t\tm_bDirty = true;\n\t\treturn true;\n\t}\n\tBOOL WINAPI SetFloatAttribute(int eSet, float nValue)\n\t{\n\t\tCGdippSettings* pSettings = CGdippSettings::GetInstance();\n\t\tswitch ((eMTSettings)eSet)\n\t\t{\n\t\t\tcase ATTR_GammaValue:\n\t\t\t\tpSettings->m_fGammaValue = nValue;\n\t\t\t\tRefreshAlphaTable();\n\t\t\t\tbreak;\n\t\t\tcase ATTR_Contrast:\n\t\t\t\tpSettings->m_fContrast = nValue;\n\t\t\t\tRefreshAlphaTable();\n\t\t\t\tbreak;\n\t\t\tcase ATTR_RenderWeight:\n\t\t\t\tpSettings->m_fRenderWeight = nValue;\n\t\t\t\tRefreshAlphaTable();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn FALSE;\n\t\t}\t\n\t\tm_bDirty = true;\n\t\treturn true;\n\t};\n\tint WINAPI GetIntAttribute(int eSet) {\n\t\tCGdippSettings* pSettings = CGdippSettings::GetInstance();\n\t\tswitch ((eMTSettings)eSet)\n\t\t{\n\t\tcase ATTR_HINTINGMODE:\n\t\t\treturn pSettings->m_FontSettings.GetHintingMode();\n\t\tcase ATTR_ANTIALIASMODE:\n\t\t\treturn pSettings->m_FontSettings.GetAntiAliasMode();\n\t\tcase ATTR_NormalWeight:\n\t\t\treturn pSettings->m_FontSettings.GetNormalWeight();\n\t\tcase ATTR_BoldWeight:\n\t\t\treturn pSettings->m_FontSettings.GetBoldWeight();\n\t\tcase ATTR_ItalicSlant:\n\t\t\treturn pSettings->m_FontSettings.GetItalicSlant();\n\t\tcase ATTR_EnableKerning:\n\t\t\treturn pSettings->m_FontSettings.GetKerning();\n\t\tcase ATTR_GammaMode:\n\t\t\treturn pSettings->m_nGammaMode;\n\t\tcase ATTR_HintSmallFont:\n\t\t\treturn pSettings->m_bHintSmallFont;\n\t\tcase ATTR_MaxBitmap:\n\t\t\treturn pSettings->m_nBitmapHeight;\n\t\tcase ATTR_LcdFilter:\n\t\t\treturn pSettings->m_nLcdFilter;\n\t\tcase ATTR_BolderMode:\n\t\t\treturn pSettings->m_nBolderMode;\n\t\tcase ATTR_TextTuning:\n\t\t\treturn 0;\n\t\tcase ATTR_TextTuningR:\n\t\t\treturn 0;\n\t\tcase ATTR_TextTuningG:\n\t\t\treturn 0;\n\t\tcase ATTR_TextTuningB:\n\t\t\treturn 0;\n\t\tcase ATTR_LoadOnDemand:\n\t\t\treturn pSettings->m_bLoadOnDemand;\n\t\tcase ATTR_ShadowAlpha:\n\t\t\treturn pSettings->EnableShadow()? pSettings->m_nShadow[2] : 1;\n\t\tcase ATTR_ShadowOffset:\n\t\t\treturn pSettings->EnableShadow()? pSettings->m_nShadow[0] : 1;\n\t\tcase ATTR_Fontlink:\n\t\t\treturn pSettings->m_bFontLink;\n\t\tcase ATTR_LcdFilterWeight:\n\t\t\treturn pSettings->m_bUseCustomLcdFilter? (int)pSettings->m_arrLcdFilterWeights:NULL;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\t\n\t\treturn 0;\n\t};\n\tfloat WINAPI GetFloatAttribute(int eSet) {\n\t\tCGdippSettings* pSettings = CGdippSettings::GetInstance();\n\t\tswitch ((eMTSettings)eSet)\n\t\t{\n\t\tcase ATTR_GammaValue:\n\t\t\treturn pSettings->m_fGammaValue;\n\t\tcase ATTR_Contrast:\n\t\t\treturn pSettings->m_fContrast;\n\t\tcase ATTR_RenderWeight:\n\t\t\treturn pSettings->m_fRenderWeight;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\t\n\t\treturn 0;\n\t};\n\tBOOL WINAPI RefreshSetting(void) {\n\t\tif (m_bDirty)\n\t\t\tg_pFTEngine->ReloadAll();\n\t\tm_bDirty = false;\n\t\treturn true;\n\t};\n\tBOOL WINAPI EnableRender(BOOL bEnable){g_ccbRender = bEnable; return true;};\n\tBOOL WINAPI EnableCache(BOOL bEnable){g_ccbCache = bEnable; return true;};\n\tBOOL WINAPI ClearIndividual(){\n\t\tCGdippSettings* pSettings = CGdippSettings::GetInstance();\n\t\tpSettings->m_arrIndividual.RemoveAll();\n\t\tm_bDirty = true;\n\t\treturn true;\n\t};\n\tBOOL WINAPI AddIndividual(WCHAR* fontSetting) \n\t{ \n\t\tCGdippSettings* pSettings = CGdippSettings::GetInstance();\n\t\tIndividualArray& arr = pSettings->m_arrIndividual;\n\t\tLPTSTR p = fontSetting;\n\t\tLOGFONT truefont={0};\n\t\tif (*p) {\n\t\t\tbool b = false;\n\n\t\t\tLPTSTR pnext = p;\n\t\t\tfor (; *pnext; pnext++);\n\n\t\t\t//\"ＭＳ Ｐゴシック=0,0\" みたいな文字列を分割\r\n\t\t\tLPTSTR value = _tcschr(p, _T('='));\n\t\t\tCStringTokenizer token;\n\t\t\tint argc = 0;\n\t\t\tif (value) {\n\t\t\t\t*value++ = _T('\\0');\n\t\t\t\targc = token.Parse(value);\n\t\t\t}\n\t\t\tTCHAR buff[LF_FACESIZE+1];\t\t\t\t\n\t\t\tGetFontLocalName(p, buff); //转换字体名\n\n\t\t\tCFontIndividual fi(buff);\n\t\t\tconst CFontSettings& fsCommon = pSettings->m_FontSettings;\n\t\t\tCFontSettings& fs = fi.GetIndividual();\n\t\t\t//Individualが無ければ共通設定を使う\r\n\t\t\tfs = fsCommon;\n\t\t\tfor (int i = 0; i < MAX_FONT_SETTINGS; i++) {\n\t\t\t\tLPCTSTR arg = token.GetArgument(i);\n\t\t\t\tif (!arg)\n\t\t\t\t\tbreak;\n\t\t\t\tconst int n = pSettings->_StrToInt(arg, fsCommon.GetParam(i));\n\t\t\t\tfs.SetParam(i, n);\n\t\t\t}\n\n\t\t\tfor (int i = 0 ; i < arr.GetSize(); i++) {\n\t\t\t\tif (arr[i] == fi) {\n\t\t\t\t\tb = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!b) {\n\t\t\t\tarr.Add(fi);\n\t\t\t}\n\t\t}\n\t\tm_bDirty = true;\n\t\treturn true; };\n\tBOOL WINAPI DelIndividual(WCHAR* lpFaceName) { \n\t\tCGdippSettings* pSettings = CGdippSettings::GetInstance();\n\t\tCFontIndividual* p\t\t= pSettings->m_arrIndividual.Begin();\n\t\tCFontIndividual* end\t= pSettings->m_arrIndividual.End();\n\t\tStringHashFont hash(lpFaceName);\n\n\t\tfor(; p != end; ++p) {\n\t\t\tif (p->GetHash() == hash) {\n\t\t\t\tpSettings->m_arrIndividual.Remove(*p);\n\t\t\t}\n\t\t}\n\t\tm_bDirty = true;\n\t\treturn true;};\n\tvoid WINAPI LoadSetting(const WCHAR* lpFileName)\n\t{\n\t\tCGdippSettings* pSettings = CGdippSettings::GetInstance();\n\t\tClearIndividual();\n\t\tpSettings->m_FontSubstitutesInfoForDW.RemoveAll();\n\t\tpSettings->m_FontSubstitutesInfo.RemoveAll();\n\t\tpSettings->m_fontlinkinfo.clear();\n\t\tpSettings->LoadAppSettings(lpFileName);\n\t\tpSettings->m_bDelayedInit = false;\n\t\tm_bDirty = true;\n\t\tRefreshAlphaTable();\n\t\tRefreshSetting();\n\t}\n\tCControlCenter():m_nRefCount(1), m_bDirty(false), m_msgwnd(NULL) {\n\t\tg_ControlCenter = this;\n\t};\n\t~CControlCenter(){\n\t\tg_ControlCenter = NULL;\n\t};\n\tstatic void WINAPI ReloadConfig()\n\t{\n\t\t//CCriticalSectionLock __lock(CCriticalSectionLock::CS_LIBRARY);\n\t\tCGdippSettings* pSettings = CGdippSettings::GetInstance();\n\t\textern HINSTANCE g_dllInstance;\n\t\tpSettings->m_arrIndividual.RemoveAll();\n\t\tpSettings->m_FontSubstitutesInfoForDW.RemoveAll();\n\t\tpSettings->m_FontSubstitutesInfo.RemoveAll();\n\t\tpSettings->m_fontlinkinfo.clear();\n\t\tpSettings->LoadSettings(g_dllInstance);\n\t\tpSettings->m_bDelayedInit = false;\n\t\tRefreshAlphaTable();\n\t\tUpdateLcdFilter();\n\t\tif (g_pFTEngine)\n\t\t\tg_pFTEngine->ReloadAll();\n\t}\n\tHWND WINAPI CreateMessageWnd() {\n\t\tHANDLE event = CreateEvent(NULL, true, false, NULL);\n\r\n\t\tauto run = [&]() -> void {\r\n\t\t\tif (this->m_msgwnd) {\r\n\t\t\t\tSendMessage(this->m_msgwnd, WM_CLOSE, 0, 0);\r\n\t\t\t}\r\n\t\t\tWNDCLASS wndclass;\r\n\t\t\twndclass.style = 0;\r\n\t\t\twndclass.lpfnWndProc = [](HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) -> LRESULT {\r\n\t\t\t\treturn g_ControlCenter ? g_ControlCenter->MsgProc(hwnd, message, wParam, lParam) : DefWindowProc(hwnd, message, wParam, lParam);\r\n\t\t\t};\r\n\t\t\twndclass.cbClsExtra = 0;\r\n\t\t\twndclass.cbWndExtra = 0;\r\n\t\t\twndclass.hInstance = 0;\r\n\t\t\twndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);\r\n\t\t\twndclass.hCursor = LoadCursor(NULL, IDC_ARROW);\r\n\t\t\twndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);\r\n\t\t\twndclass.lpszMenuName = NULL;\r\n\t\t\twndclass.lpszClassName = L\"MT_CMSGWND\";\r\n\t\t\tRegisterClass(&wndclass);\r\n\t\t\tthis->m_msgwnd = CreateWindow(L\"MT_CMSGWND\", NULL, 0, 0, 0, 0, 0, HWND_MESSAGE, 0, 0, NULL);\r\n\t\t\tSetEvent(event);\r\n\r\n\t\t\tMSG msg;\r\n\t\t\twhile (GetMessage(&msg, NULL, 0, 0)) //消息循环\r\n\t\t\t{\r\n\t\t\t\tTranslateMessage(&msg);\r\n\t\t\t\tDispatchMessage(&msg);\r\n\t\t\t}\n\t\t\tDestroyWindow(this->m_msgwnd);\n\t\t};\n\t\tauto wndThread = thread(run);\n\t\twndThread.detach();\n\t\tWaitForSingleObject(event, 10000);\n\t\tCloseHandle(event);\n\t\treturn this->m_msgwnd;\n\t}\n\n\tvoid RedrawCurrentApp() {\n\t\tauto EnumCurrentProcWindow = [](HWND hwnd, LPARAM lparam)->BOOL {\r\n\t\t\tDWORD pid = 0;\r\n\t\t\tGetWindowThreadProcessId(hwnd, &pid);\r\n\t\t\tif (pid == lparam) {\r\n\t\t\t\tRedrawWindow(hwnd, NULL, 0, RDW_ALLCHILDREN | RDW_INVALIDATE | RDW_UPDATENOW | RDW_NOERASE);\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t};\r\n\r\n\t\tEnumWindows(EnumCurrentProcWindow, GetCurrentProcessId());\n\t}\n\n\tLRESULT WINAPI MsgProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam) {\n\t\tswitch (msg) {\n\t\t\tcase WM_COPYDATA: {\n\t\t\t\tCOPYDATASTRUCT* data = (COPYDATASTRUCT*)lparam;\n\t\t\t\tif (data->cbData && data->lpData) {\t// ignore invalid request.\n\t\t\t\t\tstring json;\n\t\t\t\t\tjson.resize(data->cbData);\n\t\t\t\t\tmemcpy((void*)json.c_str(), data->lpData, data->cbData);\n\t\t\t\t\t// now parse the json string\n\t\t\t\t\tauto jsonobj = json::parse(json.begin(), json.end());\n\t\t\t\t\tstring command = jsonobj[\"command\"].get<std::string>();\n\t\t\t\t\t// various command dispatch\n\t\t\t\t\tif (command == \"loadprofile\") {\t// load target profile from disk\n\t\t\t\t\t\tstring filename = jsonobj[\"file\"].get<std::string>();\n\t\t\t\t\t\tif (filename.length()) {\n\t\t\t\t\t\t\tthis->LoadSetting(to_wide_string(filename).c_str());\n\t\t\t\t\t\t\tRedrawCurrentApp();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn ERROR_SUCCESS;\n\t\t\t\t\t}\n\t\t\t\t\tif (command == \"ping\") {\n\t\t\t\t\t\t//__asm db 0xcc;\t// cause debugger to break\n\t\t\t\t\t\t//DebugBreak();\n\t\t\t\t\t\treturn ERROR_SUCCESS;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\treturn DefWindowProc(hwnd, msg, wparam, lparam);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tvoid WINAPI DestroyMessageWnd() {\n\t\tif (m_msgwnd) {\n\t\t\tDestroyWindow(m_msgwnd);\n\t\t\tm_msgwnd = NULL;\n\t\t}\n\t}\n};\n"
        },
        {
          "name": "stdint.h",
          "type": "blob",
          "size": 4.59375,
          "content": "/*  stdint.h\n\n    Integer types - c99 7.18\n*/\n\n/*\n *      C/C++ Run Time Library - Version 13.0\n *\n *      Copyright (c) 2002, 2007 by CodeGear\n *      All Rights Reserved.\n *\n */\n\n\n#ifndef __STDINT_H\n#define __STDINT_H\n\n/* 7.18.1.1 Exact-width integer types */\n\ntypedef __int8 int8_t;\ntypedef __int16 int16_t;\ntypedef __int32 int32_t;\ntypedef __int64 int64_t;\n\ntypedef unsigned __int8 uint8_t;\ntypedef unsigned __int16 uint16_t;\ntypedef unsigned __int32 uint32_t;\ntypedef unsigned __int64 uint64_t;\n\n\n\n/* 7.18.1.2 Minimum-width integer types */\n\ntypedef __int8 int_least8_t;\ntypedef __int16 int_least16_t;\ntypedef __int32 int_least32_t;\ntypedef __int64 int_least64_t;\n\ntypedef unsigned __int8 uint_least8_t;\ntypedef unsigned __int16 uint_least16_t;\ntypedef unsigned __int32 uint_least32_t;\ntypedef unsigned __int64 uint_least64_t;\n\n\n\n/* 7.18.1.3 Fastest minimum-width integer types */\n\ntypedef __int8 int_fast8_t;\ntypedef __int16 int_fast16_t;\ntypedef __int32 int_fast32_t;\ntypedef __int64 int_fast64_t;\n\ntypedef unsigned __int8 uint_fast8_t;\ntypedef unsigned __int16 uint_fast16_t;\ntypedef unsigned __int32 uint_fast32_t;\ntypedef unsigned __int64 uint_fast64_t;\n\n\n\n/* 7.18.1.4 Integer types capable of holding object pointers */\n\ntypedef int32_t intptr_t;\ntypedef uint32_t uintptr_t;\n\n\n\n/* 7.18.1.5 Greatest-width integer types */\n\ntypedef int64_t intmax_t;\ntypedef uint64_t uintmax_t;\n\n\n\n/* 7.18.2.1 Limits of exact-width integer types */\n\n#define INT8_MIN ((int8_t) -128)\n#define INT16_MIN ((int16_t) -32768)\n#define INT32_MIN ((int32_t) -2147483647L - 1) \n#define INT64_MIN ((int64_t) -9223372036854775807LL - 1)\n\n#define INT8_MAX ((int8_t) 127)\n#define INT16_MAX ((int16_t) 32767)\n#define INT32_MAX ((int32_t) 2147483647L)\n#define INT64_MAX ((int64_t) 9223372036854775807LL)\n\n#define UINT8_MAX ((uint8_t) 255)\n#define UINT16_MAX ((uint16_t) 65535)\n#define UINT32_MAX ((uint32_t) 4294967295UL)\n#define UINT64_MAX ((uint64_t) 18446744073709551615ULL)\n\n\n\n/* 7.18.2.2 Limits of minimum-width integer types */\n\n#define INT_LEAST8_MIN ((int_least8_t) -128)\n#define INT_LEAST16_MIN ((int_least16_t) -32768)\n#define INT_LEAST32_MIN ((int_least32_t) -2147483647L - 1)\n#define INT_LEAST64_MIN ((int_least64_t) -9223372036854775807LL - 1)\n\n#define INT_LEAST8_MAX ((int_least8_t) 127)\n#define INT_LEAST16_MAX ((int_least16_t) 32767)\n#define INT_LEAST32_MAX ((int_least32_t) 2147483647L)\n#define INT_LEAST64_MAX ((int_least64_t) 9223372036854775807LL)\n\n#define UINT_LEAST8_MAX ((uint_least8_t) 255)\n#define UINT_LEAST16_MAX ((uint_least16_t) 65535)\n#define UINT_LEAST32_MAX ((uint_least32_t) 4294967295UL)\n#define UINT_LEAST64_MAX ((uint_least64_t) 18446744073709551615ULL)\n\n\n\n/* 7.18.2.3 Limits of fastest minimum-width integer types */\n\n#define INT_FAST8_MIN ((int_fast8_t) -128)\n#define INT_FAST16_MIN ((int_fast16_t) -32768)\n#define INT_FAST32_MIN ((int_fast32_t) -2147483647L - 1)\n#define INT_FAST64_MIN ((int_fast64_t) -9223372036854775807LL - 1)\n\n#define INT_FAST8_MAX ((int_fast8_t) 127)\n#define INT_FAST16_MAX ((int_fast16_t) 32767)\n#define INT_FAST32_MAX ((int_fast32_t) 2147483647L)\n#define INT_FAST64_MAX ((int_fast64_t) 9223372036854775807LL)\n\n#define UINT_FAST8_MAX ((uint_fast8_t) 255)\n#define UINT_FAST16_MAX ((uint_fast16_t) 65535)\n#define UINT_FAST32_MAX ((uint_fast32_t) 4294967295UL)\n#define UINT_FAST64_MAX ((uint_fast64_t) 18446744073709551615ULL)\n\n\n\n/* 7.18.2.4 Limits of integer types capable of holding object pointers */\n\n#define INTPTR_MIN ((intptr_t) -2147483647L - 1)\n#define INTPTR_MAX ((intptr_t) 2147483647L)\n#define UINTPTR_MAX ((intptr_t) 4294967295UL)\n\n\n\n/* 7.18.2.5 Limits of greatest-width integer types */\n\n#define INTMAX_MIN ((intmax_t) -9223372036854775807LL - 1)\n#define INTMAX_MAX ((intmax_t) 9223372036854775807LL)\n#define UINTMAX_MAX ((uintmax_t) 18446744073709551615ULL)\n\n\n\n/* 7.18.3 Limits of other integer types */\n\n#define PTRDIFF_MIN ((int32_t) -2147483647L - 1)\n#define PTRDIFF_MAX ((int32_t) 2147483647L)\n\n#ifdef __STDC_LIMIT_MACROS\n#define SIG_ATOMIC_MIN INT32_MIN\n#define SIG_ATOMIC_MAX INT32_MAX\n#endif\n\n#define SIZE_MAX UINT32_MAX\n\n#ifdef __STDC_CONSTANT_MACROS\n#define WCHAR_MIN 0\n#define WCHAR_MAX UINT16_MAX\n#define WINT_MIN 0\n#define WINT_MAX UINT16_MAX\n#endif\n\n\n\n/* 7.18.4.1 Macros for minimum-width integer constants */\n\n#define INT8_C(x) ((int8_t) x)\n#define INT16_C(x) ((int16_t) x)\n#define INT32_C(x) ((int32_t) x)\n#define INT64_C(x) ((int64_t) x)\n\n#define UINT8_C(x) ((uint8_t) x)\n#define UINT16_C(x) ((uint16_t) x)\n#define UINT32_C(x) ((uint32_t) x)\n#define UINT64_C(x) ((uint64_t) x)\n\n\n\n/* 7.18.4.2 Macros for greatest-width integer constants */\n\n#define INTMAX_C(x) ((intmax_t) x)\n#define UINTMAX_C(x) ((uintmax_t) x)\n\n#endif /* __STDINT_H */\n"
        },
        {
          "name": "strtoken.h",
          "type": "blob",
          "size": 2.0380859375,
          "content": "#pragma once\n\n//例\n// 'a,b,c,d'\t\t{ \"a\", \"b\", \"c\", \"d\" }\n// 'a,,b,c,'\t\t{ \"a\", \"\", \"b\", \"c\", \"\" }\n// '\"a,b\",c'\t\t{ \"\"a,b\"\", \"c\" }\nclass CStringTokenizer\n{\nprivate:\n\tenum _Const {\n\t\tMAX_ARGUMENTS\t= 16,\n\t};\n\tint\t\tm_nNumArgs;\n\tLPTSTR\tm_ppszArgv[MAX_ARGUMENTS + 1];\n\tLPTSTR\tm_pszBuffer;\n\n\tvoid Clear()\n\t{\n\t\tm_nNumArgs = 0;\n\t\tZeroMemory(m_ppszArgv, sizeof(m_ppszArgv));\n\t\tfree(m_pszBuffer);\n\t\tm_pszBuffer = NULL;\n\t}\n\npublic:\n\tCStringTokenizer()\n\t\t: m_pszBuffer(NULL)\n\t{\n\t\tClear();\n\t}\n\t~CStringTokenizer()\n\t{\n\t\tfree(m_pszBuffer);\n\t}\n\n\tint GetCount() const\n\t{\n\t\treturn m_nNumArgs;\n\t}\n\tLPCTSTR GetArgument(int x) const\n\t{\n\t\tAssert(0 <= x && x <= GetCount());\n\t\treturn m_ppszArgv[x];\n\t}\n\n\tint Parse(LPCTSTR pszStr)\n\t{\n\t\tClear();\n\n\t\tif (!pszStr || !*pszStr) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tm_pszBuffer = _tcsdup(pszStr);\n\t\tif (!m_pszBuffer) {\n\t\t\treturn 0;\n\t\t}\n\t\tLPTSTR p = m_pszBuffer, ps;\n\t\tint nNumArgs = 0;\n\t\tLPTSTR* ppszArgv = m_ppszArgv;\n\n#define _isspace(ch)\t(ch == _T('\\t') || ch == _T(' '))\n\t\tfor (;;) {\nCONT:\n\t\t\tif (nNumArgs >= MAX_ARGUMENTS) {\n\t\t\t\tTRACE(_T(\"Too many arguments (> %d)\\n\"), MAX_ARGUMENTS);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (*p == _T('\\0')) {\n\t\t\t\tppszArgv[nNumArgs++] = p;\n\t\t\t\tgoto EXIT;\n\t\t\t}\n\t\t\tfor (; _isspace(*p); *p++);\n\t\t\tif (*p == _T('\\0')) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (*p) {\n\t\t\tcase _T(','):\n\t\t\t\t*p = _T('\\0');\n\t\t\t\tppszArgv[nNumArgs++] = p++;\n\t\t\t\tgoto CONT;\n\t\t\tcase _T('\"'):\n\t\t\t\tp++;\n\t\t\t\tppszArgv[nNumArgs++] = p++;\n\t\t\t\tfor (; *p && *p != _T('\"'); p++);\n\t\t\t\tif (*p == _T('\\0')) {\n\t\t\t\t\tTRACE(_T(\"Unterminated string\\n\"));\n\t\t\t\t\tgoto EXIT;\n\t\t\t\t}\n\t\t\t\t*p++ = _T('\\0');\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tppszArgv[nNumArgs++] = p++;\n\t\t\t\tps = p;\n\t\t\t\tfor (; *p && *p != _T(','); p++);\n\t\t\t\tif (*p == _T('\\0')) {\n\t\t\t\t\tgoto EXIT;\n\t\t\t\t}\n\t\t\t\tfor (p--; _isspace(*p) && p >= ps; p--);\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (_isspace(*p)) {\n\t\t\t\tfor (*p++ = _T('\\0'); *p && _isspace(*p); p++);\n\t\t\t\tif (*p == _T('\\0')) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (; *p && *p != _T(','); p++);\n\t\t\tif (*p == _T('\\0')) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*p++ = _T('\\0');\n\t\t}\n#undef _isspace\n\nEXIT:\n\t\tm_nNumArgs = nNumArgs;\n\t\treturn nNumArgs;\n\t}\n};\n"
        },
        {
          "name": "supinfo.h",
          "type": "blob",
          "size": 9.1064453125,
          "content": "#pragma once\n\n#include <mmsystem.h>\t//mmioFOURCC\n#define FOURCC_GDIPP\tmmioFOURCC('G', 'D', 'I', 'P')\n\ntypedef struct {\n\tint dummy;\n\tFOURCC magic;\n//\tBYTE reserved[256];\n} GDIPP_CREATE_MAGIC;\n\n//参照\n//http://www.catch22.net/tuts/undoc01.asp\n\n#ifdef _GDIPP_EXE\ntemplate <typename _STARTUPINFO>\nvoid FillGdiPPStartupInfo(_STARTUPINFO& si, GDIPP_CREATE_MAGIC& gppcm)\n{\n\tZeroMemory(&gppcm, sizeof(GDIPP_CREATE_MAGIC));\n\tgppcm.magic = FOURCC_GDIPP;\n\tsi.cbReserved2 = sizeof(GDIPP_CREATE_MAGIC);\n\tsi.lpReserved2 = (LPBYTE)&gppcm;\n}\n#endif\n\n#ifdef _GDIPP_DLL\ntemplate <typename _STARTUPINFO>\nbool IsGdiPPStartupInfo(const _STARTUPINFO& si)\n{\n\tif(si.cbReserved2 >= sizeof(int) + sizeof(FOURCC)) {\n\t\tGDIPP_CREATE_MAGIC* pMagic = (GDIPP_CREATE_MAGIC*)si.lpReserved2;\n\t\tif (pMagic->dummy == 0 && pMagic->magic == FOURCC_GDIPP) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n#endif\n\nEXTERN_C BOOL WINAPI GdippInjectDLL(const PROCESS_INFORMATION* ppi);\nEXTERN_C LPWSTR WINAPI GdippEnvironment(DWORD& dwCreationFlags, LPVOID lpEnvironment);\n\n\n\n//子プロセスにも自動でgdi++適用\ntemplate <typename _TCHAR, typename _STARTUPINFO, class _Function>\nBOOL _CreateProcessAorW(const _TCHAR* lpApp, _TCHAR* lpCmd, LPSECURITY_ATTRIBUTES pa, LPSECURITY_ATTRIBUTES ta, BOOL bInherit, DWORD dwFlags, LPVOID lpEnv, const _TCHAR* lpDir, _STARTUPINFO* psi, LPPROCESS_INFORMATION ppi, _Function fn)\n{\n#ifdef _GDIPP_RUN_CPP\n\tconst bool hookCP = true;\n\tconst bool runGdi = true;\n#else\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\n\tconst bool hookCP = pSettings->HookChildProcesses();\n\tconst bool runGdi = pSettings->RunFromGdiExe();\n#endif\n\t\n\tif (!hookCP || (!lpApp && !lpCmd) || (dwFlags & (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS | DETACHED_PROCESS))/* || !psi || psi->cb < sizeof(_STARTUPINFO)*/) {\n\t\treturn fn(lpApp, lpCmd, pa, ta, bInherit, dwFlags, lpEnv, lpDir, psi, ppi);\n\t}\n\n\tPROCESS_INFORMATION _pi = { 0 };\n\tif (!ppi) {\n\t\tppi = &_pi;\n\t}\n\n\tint szpsi = psi ? (psi->cb ? psi->cb: sizeof(_STARTUPINFO)) : sizeof(_STARTUPINFO);\n\t_STARTUPINFO& si = *(_STARTUPINFO*)_alloca(szpsi);\n\tmemset(&si, 0, sizeof(si));\n\tsi.cb=szpsi;\n\tif (psi && psi->cb)\n\t\tmemcpy(&si, psi, psi->cb);\n\tpsi = &si;\n\n\tGDIPP_CREATE_MAGIC gppcm;\n\tif (runGdi && !si.cbReserved2) {\n\t\tFillGdiPPStartupInfo(si, gppcm);\n\t}\n\n\tLPWSTR pEnvW = GdippEnvironment(dwFlags, lpEnv);\n\tif (pEnvW) {\n\t\tlpEnv = pEnvW;\n\t}\n\n\tif (!fn(lpApp, lpCmd, pa, ta, bInherit, dwFlags | CREATE_SUSPENDED, lpEnv, lpDir, &si, ppi)) {\n\t\tZeroMemory(ppi, sizeof(*ppi));\n\t\tfree(pEnvW);\n\t\treturn FALSE;\n\t}\n\n\tGdippInjectDLL(ppi);\n\tif (!(dwFlags & CREATE_SUSPENDED)) {\n\t\tResumeThread(ppi->hThread);\n\t}\n\tfree(pEnvW);\n\treturn TRUE;\n}\n\ntemplate <typename _TCHAR, typename _STARTUPINFO, class _Function>\nBOOL _CreateProcessAsUserAorW(HANDLE hToken, const _TCHAR* lpApp, _TCHAR* lpCmd, LPSECURITY_ATTRIBUTES pa, LPSECURITY_ATTRIBUTES ta, BOOL bInherit, DWORD dwFlags, LPVOID lpEnv, const _TCHAR* lpDir, _STARTUPINFO* psi, LPPROCESS_INFORMATION ppi, _Function fn)\n{\n#ifdef _GDIPP_RUN_CPP\n\tconst bool hookCP = true;\n\tconst bool runGdi = true;\n#else\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstance();\n\tconst bool hookCP = pSettings->HookChildProcesses();\n\tconst bool runGdi = pSettings->RunFromGdiExe();\n#endif\n\n\tif (!hookCP || (!lpApp && !lpCmd) || (dwFlags & (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS))/* || !psi || psi->cb < sizeof(_STARTUPINFO)*/) {\n\t\treturn fn(hToken, lpApp, lpCmd, pa, ta, bInherit, dwFlags, lpEnv, lpDir, psi, ppi);\n\t}\n\n\tPROCESS_INFORMATION _pi = { 0 };\n\tif (!ppi) {\n\t\tppi = &_pi;\n\t}\n\tint szpsi = psi ? (psi->cb ? psi->cb: sizeof(_STARTUPINFO)) : sizeof(_STARTUPINFO);\n\t_STARTUPINFO& si = *(_STARTUPINFO*)_alloca(szpsi);\n\tmemset(&si, 0, sizeof(si));\n\tsi.cb=szpsi;\n\tif (psi && psi->cb)\n\t\tmemcpy(&si, psi, psi->cb);\n\tpsi = &si;\n\n\tGDIPP_CREATE_MAGIC gppcm;\n\tif (runGdi && !si.cbReserved2) {\n\t\tFillGdiPPStartupInfo(si, gppcm);\n\t}\n\n\tLPWSTR pEnvW = GdippEnvironment(dwFlags, lpEnv);\n\tif (pEnvW) {\n\t\tlpEnv = pEnvW;\n\t}\n\n\tif (!fn(hToken, lpApp, lpCmd, pa, ta, bInherit, dwFlags | CREATE_SUSPENDED, lpEnv, lpDir, &si, ppi)) {\n\t\tZeroMemory(ppi, sizeof(*ppi));\n\t\tfree(pEnvW);\n\t\treturn FALSE;\n\t}\n\n\tGdippInjectDLL(ppi);\n\tif (!(dwFlags & CREATE_SUSPENDED)) {\n\t\tResumeThread(ppi->hThread);\n\t}\n\tfree(pEnvW);\n\treturn TRUE;\n}\n\nstatic wstring GetExeName(LPCTSTR lpApp, LPTSTR lpCmd)\n{\n// \tHANDLE logfile = CreateFile(_T(\"C:\\\\mt.log\"), FILE_ALL_ACCESS, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, NULL, NULL);\n// \tSetFilePointer(logfile,0,NULL, FILE_END);\n\n\twstring ret;\n// \tDWORD aa=0;\n// \tif (GetFileSize(logfile, NULL)==0)\n// \t\tWriteFile(logfile, \"\\xff\\xfe\", 2, &aa, NULL);\n\tLPTSTR vlpApp = (LPTSTR)lpApp;\t//变成可以操作的参数\n\tif (lpApp)\n\t{\n\t\tdo \n\t\t{\n// \t\t\tWriteFile(logfile, L\"lpApp=\", 12, &aa, NULL);\n// \t\t\tWriteFile(logfile, lpApp, _tcslen(lpApp)*2, &aa, NULL);\n// \t\t\tWriteFile(logfile, _T(\"\\n\"), 2, &aa, NULL);\n\t\t\tvlpApp = _tcsstr(vlpApp+1, _T(\" \"));\t//获得第一个空格所在的位置\n\t\t\tret.assign(lpApp);\n\t\t\tif (vlpApp)\n\t\t\t\tret.resize(vlpApp-lpApp);\n// \t\t\tWriteFile(logfile, ret.c_str(), ret.length()*2, &aa, NULL);\n// \t\t\tWriteFile(logfile, _T(\"\\n\"), 2, &aa, NULL);\n\t\t\tDWORD fa = GetFileAttributes(ret.c_str()); \n\t\t\tif (fa!=INVALID_FILE_ATTRIBUTES && fa!=FILE_ATTRIBUTE_DIRECTORY)\t//文件是否存在\n\t\t\t{\t\t\n\t\t\t\tint p = ret.find_last_of(_T(\"\\\\\"));\n\t\t\t\tif (p!=-1)\n\t\t\t\t\tret.erase(0, p+1);\t//如果有路径就删掉路径\n// \t\t\t\tWriteFile(logfile, ret.c_str(), ret.length()*2, &aa, NULL);\n// \t\t\t\tWriteFile(logfile, _T(\"\\n\"), 2, &aa, NULL);\n// \t\t\t\tWriteFile(logfile, _T(\"==========\\n\"), 24, &aa, NULL);\n// \t\t\t\tCloseHandle(logfile);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tret+=_T(\".exe\");\t//加上.exe扩展名再试\n\t\t\t\tDWORD fa = GetFileAttributes(ret.c_str()); \n\t\t\t\tif (fa!=INVALID_FILE_ATTRIBUTES && fa!=FILE_ATTRIBUTE_DIRECTORY)\n\t\t\t\t{\t\t\n\t\t\t\t\tint p = ret.find_last_of(_T(\"\\\\\"));\n\t\t\t\t\tif (p!=-1)\n\t\t\t\t\t\tret.erase(0, p+1);\t//如果有路径就删掉路径\n// \t\t\t\t\tWriteFile(logfile, ret.c_str(), ret.length()*2, &aa, NULL);\n// \t\t\t\t\tWriteFile(logfile, _T(\"\\n\"), 2, &aa, NULL);\n// \t\t\t\t\tWriteFile(logfile, _T(\"==========\\n\"), 24, &aa, NULL);\n// \t\t\t\t\tCloseHandle(logfile);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (vlpApp);\n\t}\n\n\tif (lpCmd)\n\t{\n// \t\tWriteFile(logfile, L\"lpCmd=\", 10, &aa, NULL);\n// \t\tWriteFile(logfile, lpCmd, _tcslen(lpCmd)*2, &aa, NULL);\n\t\tret.assign(lpCmd);\n\t\tint p=0;\n\t\tif ((*lpCmd)==_T('\\\"'))\n\t\t{\n\t\t\tret.erase(0,1);\t//删除第一个引号\n\t\t\tp=ret.find_first_of(_T(\"\\\"\"));\t//查找下一个引号\n\t\t}\n\t\telse\n\t\t\tp=ret.find_first_of(_T(\" \"));\n\t\tif (p>0)\n\t\t\tret.resize(p);\t//获得Cmd里面的文件名\n// \t\tWriteFile(logfile, ret.c_str(), ret.length()*2, &aa, NULL);\n// \t\tWriteFile(logfile, _T(\"\\n\"), 2, &aa, NULL);\n\t\tp = ret.find_last_of(_T(\"\\\\\"));\n\t\tif (p>0)\n\t\t\tret.erase(0, p+1);\t//如果有路径就删掉路径\n// \t\tWriteFile(logfile, ret.c_str(), ret.length()*2, &aa, NULL);\n// \t\tWriteFile(logfile, _T(\"\\n\"), 2, &aa, NULL);\n// \t\tWriteFile(logfile, _T(\"==========\\n\"), 24, &aa, NULL);\n// \t\tCloseHandle(logfile);\n\t\treturn ret;\n\t}\n// \tWriteFile(logfile, ret.c_str(), ret.length()*2, &aa, NULL);\n// \tWriteFile(logfile, _T(\"\\n\"), 2, &aa, NULL);\n// \tWriteFile(logfile, _T(\"==========\\n\"), 24, &aa, NULL);\n// \tCloseHandle(logfile);\n\treturn ret;\n}\n\ntemplate <class _Function>\nBOOL _CreateProcessInternalW(HANDLE hToken, LPCTSTR lpApp, LPTSTR lpCmd, LPSECURITY_ATTRIBUTES pa, LPSECURITY_ATTRIBUTES ta, BOOL bInherit, \\\n\t\t\t\t\t\t\t DWORD dwFlags, LPVOID lpEnv, LPCTSTR lpDir, LPSTARTUPINFO psi, LPPROCESS_INFORMATION ppi , PHANDLE hNewToken, _Function fn)\n{\n#ifdef _GDIPP_RUN_CPP\n\tconst bool hookCP = true;\n\tconst bool runGdi = true;\n#else\n\tconst CGdippSettings* pSettings = CGdippSettings::GetInstanceNoInit();\n\tconst bool hookCP = pSettings->HookChildProcesses();\n\tconst bool runGdi = pSettings->RunFromGdiExe();\n#endif\n\n#ifdef _GDIPP_EXE\n\tif (!hookCP || (!lpApp && !lpCmd) || (dwFlags & (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS))\t|| !psi || psi->cb < sizeof(STARTUPINFO)) {\n\t\t\treturn fn(hToken, lpApp, lpCmd, pa, ta, bInherit, dwFlags, lpEnv, lpDir, psi, ppi, hNewToken);\n\t}\n\n\tSTARTUPINFO& si = *(STARTUPINFO*)_alloca(psi->cb);\n\tmemcpy(&si, psi, psi->cb);\n\tpsi = &si;\n\n\tGDIPP_CREATE_MAGIC gppcm;\n\tif (runGdi && !si.cbReserved2) {\n\t\tFillGdiPPStartupInfo(si, gppcm);\n\t}\n\n\tPROCESS_INFORMATION _pi = { 0 };\n\tif (!ppi) {\n\t\tppi = &_pi;\n\t}\n\n\tLPWSTR pEnvW = GdippEnvironment(dwFlags, lpEnv);\n\tif (pEnvW) {\n\t\tlpEnv = pEnvW;\n\t}\n\tif (!fn(hToken, lpApp, lpCmd, pa, ta, bInherit, dwFlags | CREATE_SUSPENDED, lpEnv, lpDir, psi, ppi, hNewToken)) {\n\t\tZeroMemory(ppi, sizeof(*ppi));\n\t\tfree(pEnvW);\n\t\treturn FALSE;\n\t}\n\tGdippInjectDLL(ppi);\n\tif (!(dwFlags & CREATE_SUSPENDED)) {\n\t\tResumeThread(ppi->hThread);\n\t}\n\tfree(pEnvW);\n#else\n\twstring exe_name = GetExeName(lpApp, lpCmd);\n\tif (!hookCP || (!lpApp && !lpCmd) || (dwFlags & (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS)) || IsExeUnload(exe_name.c_str())) {\n\t\t\treturn fn(hToken, lpApp, lpCmd, pa, ta, bInherit, dwFlags, lpEnv, lpDir, psi, ppi, hNewToken);\n\t}\n\tLPWSTR pEnvW = GdippEnvironment(dwFlags, lpEnv);\n\tif (pEnvW) {\n\t\tlpEnv = pEnvW;\n\t}\n\tif (!fn(hToken, lpApp, lpCmd, pa, ta, bInherit, dwFlags | CREATE_SUSPENDED, lpEnv, lpDir, psi, ppi, hNewToken)) {\n\t\tfree(pEnvW);\n\t\treturn FALSE;\n\t}\n\tGdippInjectDLL(ppi);\n\tif (!(dwFlags & CREATE_SUSPENDED)) {\n\t\tResumeThread(ppi->hThread);\n\t}\n\tfree(pEnvW);\n#endif\n\n\treturn TRUE;\n}\n"
        },
        {
          "name": "tlsdata.h",
          "type": "blob",
          "size": 1.2548828125,
          "content": "#pragma once\n\ntemplate <class T>\nclass CTlsData\n{\nprivate:\n\tDWORD tlsindex;\n\tCPtrArray<T>* pArray;\n\tenum { INVALID_TLS_VALUE = 0xffffffff };\n\npublic:\n\tT* GetPtr() const\n\t{\n\t\tif(tlsindex == INVALID_TLS_VALUE)\n\t\t\treturn NULL;\n\n\t\tT* pT = reinterpret_cast<T*>(::TlsGetValue(tlsindex));\n\t\tif(pT)\n\t\t\treturn pT;\n\n\t\tpT = new T;\n \t\tif(!pT)\n \t\t\treturn NULL;\n\n\t\tif(!::TlsSetValue(tlsindex, pT)) {\n\t\t\tdelete pT;\n\t\t\treturn NULL;\n\t\t}\n\t\tif(pArray) {\n\t\t\tpArray->Add(pT);\n\t\t}\n\t\treturn pT;\n\t}\n\tbool ProcessInit()\n\t{\n\t\ttlsindex = ::TlsAlloc();\n\t\tif (tlsindex == INVALID_TLS_VALUE) {\n\t\t\treturn false;\n\t\t}\n\n\t\tpArray = new CPtrArray<T>;\n\t\tif (!pArray) {\n\t\t\t::TlsFree(tlsindex);\n\t\t\ttlsindex = INVALID_TLS_VALUE;\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tvoid ProcessTerm()\n\t{\n\t\tif(tlsindex == INVALID_TLS_VALUE) {\n\t\t\treturn;\n\t\t}\n\t\tThreadTerm();\t//これ入れないとリークする\n\t\t::TlsFree(tlsindex);\n\t\ttlsindex = INVALID_TLS_VALUE;\n\n\t\tif (pArray) {\n\t\t\tfor(int i = 0; i < pArray->GetSize(); i++) {\n\t\t\t\tdelete pArray->operator[](i);\n\t\t\t}\n\t\t\tdelete pArray;\n\t\t\tpArray = NULL;\n\t\t}\n\t}\n//\tbool ThreadInit()\n//\t{\n//\t}\n\tvoid ThreadTerm()\n\t{\n\t\tT* pT = reinterpret_cast<T*>(::TlsGetValue(tlsindex));\n\t\tif(pT) {\n\t\t\tif (pArray) {\n\t\t\t\tpArray->Remove(pT);\n\t\t\t}\n\t\t\tdelete pT;\n\t\t}\n\t\t::TlsSetValue(tlsindex, NULL);\n\t}\n};\n"
        },
        {
          "name": "undocAPI.h",
          "type": "blob",
          "size": 4.419921875,
          "content": "#pragma once\r\n\r\ntypedef struct _UNICODE_STRING2 {\r\n\tUSHORT Length;\r\n\tUSHORT MaximumLength;\r\n\tPWSTR  Buffer;\r\n} UNICODE_STRING2;\r\ntypedef UNICODE_STRING2 *PUNICODE_STRING2;\r\ntypedef const UNICODE_STRING2 *PCUNICODE_STRING2;\r\n\r\nconst DWORD GT_DEVICE_TO_WORLD = 0x0402;\r\nconst DWORD GT_WORLD_TO_DEVICE = 0x0204;\r\nconst DWORD GT_WORLD_TO_PAGE = 0x0203;\r\nconst DWORD GT_PAGE_TO_DEVICE = 0x0304;\r\n\r\ntypedef int(__stdcall * TGetTextFA)(HDC, int, LPWSTR);\r\ntypedef BOOL (__stdcall *PFNCreateProcessInternalW) \r\n( \r\n HANDLE hToken, \r\n LPCTSTR lpApplicationName,        \r\n LPTSTR lpCommandLine,        \r\n LPSECURITY_ATTRIBUTES lpProcessAttributes, \r\n LPSECURITY_ATTRIBUTES lpThreadAttributes,        \r\n BOOL bInheritHandles,        \r\n DWORD dwCreationFlags, \r\n LPVOID lpEnvironment,        \r\n LPCTSTR lpCurrentDirectory,        \r\n LPSTARTUPINFO lpStartupInfo,        \r\n LPPROCESS_INFORMATION lpProcessInformation , \r\n PHANDLE hNewToken \r\n ); \r\ntypedef BOOL\r\n(WINAPI *PFNCreateProcessW)(\r\n\t\t\t\t\t\t\t__in_opt    LPCWSTR lpApplicationName,\r\n\t\t\t\t\t\t\t__inout_opt LPWSTR lpCommandLine,\r\n\t\t\t\t\t\t\t__in_opt    LPSECURITY_ATTRIBUTES lpProcessAttributes,\r\n\t\t\t\t\t\t\t__in_opt    LPSECURITY_ATTRIBUTES lpThreadAttributes,\r\n\t\t\t\t\t\t\t__in        BOOL bInheritHandles,\r\n\t\t\t\t\t\t\t__in        DWORD dwCreationFlags,\r\n\t\t\t\t\t\t\t__in_opt    LPVOID lpEnvironment,\r\n\t\t\t\t\t\t\t__in_opt    LPCWSTR lpCurrentDirectory,\r\n\t\t\t\t\t\t\t__in        LPSTARTUPINFOW lpStartupInfo,\r\n\t\t\t\t\t\t\t__out       LPPROCESS_INFORMATION lpProcessInformation\r\n\t\t\t\t\t\t\t);\r\ntypedef BOOL\r\n(WINAPI *PFNCreateProcessA)(\r\n\t\t\t\t\t\t\t__in_opt    LPCSTR lpApplicationName,\r\n\t\t\t\t\t\t\t__inout_opt LPSTR lpCommandLine,\r\n\t\t\t\t\t\t\t__in_opt    LPSECURITY_ATTRIBUTES lpProcessAttributes,\r\n\t\t\t\t\t\t\t__in_opt    LPSECURITY_ATTRIBUTES lpThreadAttributes,\r\n\t\t\t\t\t\t\t__in        BOOL bInheritHandles,\r\n\t\t\t\t\t\t\t__in        DWORD dwCreationFlags,\r\n\t\t\t\t\t\t\t__in_opt    LPVOID lpEnvironment,\r\n\t\t\t\t\t\t\t__in_opt    LPCSTR lpCurrentDirectory,\r\n\t\t\t\t\t\t\t__in        LPSTARTUPINFOA lpStartupInfo,\r\n\t\t\t\t\t\t\t__out       LPPROCESS_INFORMATION lpProcessInformation\r\n\t\t\t\t\t\t\t);\r\ntypedef BOOL (WINAPI *PFNIsWow64Process)(HANDLE hProcess, PBOOL Wow64Process );\r\ntypedef int (WINAPI * TGdiGetCodePage)(HDC);\r\ntypedef BOOL (WINAPI * TGetTransform)(HDC, DWORD, XFORM*);\r\ntypedef BOOL (WINAPI * PFNGetFontResourceInfo)(LPCWSTR, DWORD*, VOID*, DWORD);\r\ntypedef LONG (WINAPI * PFNLdrLoadDll)(\r\n\t\t\t\t\t\t IN PWCHAR               PathToFile OPTIONAL,\r\n\t\t\t\t\t\t IN ULONG                Flags OPTIONAL,\r\n\t\t\t\t\t\t IN UNICODE_STRING2*      ModuleFileName,\r\n\t\t\t\t\t\t OUT HANDLE*             ModuleHandle \r\n\t\t\t\t\t\t );\r\ntypedef BOOL(WINAPI * PFNSetProcessMitigationPolicy)(\r\n\t_In_ PROCESS_MITIGATION_POLICY MitigationPolicy,\r\n\t_In_ PVOID                     lpBuffer,\r\n\t_In_ SIZE_T                    dwLength);\r\nstatic TGetTransform GetTransform = (TGetTransform)GetProcAddress(LoadLibrary(_T(\"gdi32.dll\")), \"GetTransform\");\r\n /***********************************************************************\r\n  *           GetTransform    (GDI32.@)\r\n+ *\r\n+ * Undocumented\r\n+ *\r\n+ * Returns one of the co-ordinate space transforms\r\n+ *\r\n+ * PARAMS\r\n+ *    hdc   [I] Device context.\r\n+ *    which [I] Which xform to return:\r\n+ *                  0x203 World -> Page transform (that set by SetWorldTransform).\r\n+ *                  0x304 Page -> Device transform (the mapping mode transform).\r\n+ *                  0x204 World -> Device transform (the combination of the above two).\r\n+ *                  0x402 Device -> World transform (the inversion of the above).\r\n+ *    xform [O] The xform.\r\n+ *\r\n  ************************************************************************/\r\n\r\nstatic TGdiGetCodePage GdiGetCodePage = (TGdiGetCodePage)GetProcAddress(LoadLibrary(_T(\"gdi32.dll\")),\"GdiGetCodePage\");\r\nstatic TGetTextFA GetTextFaceAliasW= (TGetTextFA)GetProcAddress(LoadLibrary(_T(\"gdi32.dll\")),\"GetTextFaceAliasW\");\r\nstatic PFNCreateProcessInternalW CreateProcessInternalW_KernelBase = (PFNCreateProcessInternalW)GetProcAddress(GetModuleHandle(_T(\"kernelbase.dll\")),\"CreateProcessInternalW\");\r\nstatic PFNCreateProcessInternalW CreateProcessInternalW = CreateProcessInternalW_KernelBase ? CreateProcessInternalW_KernelBase:(PFNCreateProcessInternalW)GetProcAddress(GetModuleHandle(_T(\"kernel32.dll\")),\"CreateProcessInternalW\");\r\n//static PFNIsWow64Process IsWow64Process=(PFNIsWow64Process)GetProcAddress(LoadLibrary(L\"Kernel32.dll\"), \"IsWow64Process\");\r\nstatic PFNGetFontResourceInfo GetFontResourceInfo=(PFNGetFontResourceInfo)GetProcAddress(LoadLibrary(L\"gdi32.dll\"), \"GetFontResourceInfoW\");\r\n"
        },
        {
          "name": "wow64ext.h",
          "type": "blob",
          "size": 9.62890625,
          "content": "/**\r\n *\r\n * WOW64Ext Library\r\n *\r\n * Copyright (c) 2014 ReWolf\r\n * http://blog.rewolf.pl/\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published\r\n * by the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n *\r\n */\r\n#pragma once\r\n\r\n#include <windows.h>\r\n\r\n#ifndef STATUS_SUCCESS\r\n#   define STATUS_SUCCESS 0\r\n#endif\r\n\r\n#pragma pack(push)\r\n#pragma pack(1)\r\ntemplate <class T>\r\nstruct _LIST_ENTRY_T\r\n{\r\n    T Flink;\r\n    T Blink;\r\n};\r\n\r\ntemplate <class T>\r\nstruct _UNICODE_STRING_T\r\n{\r\n    union\r\n    {\r\n        struct\r\n        {\r\n            WORD Length;\r\n            WORD MaximumLength;\r\n        };\r\n        T dummy;\r\n    };\r\n    T Buffer;\r\n};\r\n\r\ntemplate <class T>\r\nstruct _NT_TIB_T\r\n{\r\n    T ExceptionList;\r\n    T StackBase;\r\n    T StackLimit;\r\n    T SubSystemTib;\r\n    T FiberData;\r\n    T ArbitraryUserPointer;\r\n    T Self;\r\n};\r\n\r\ntemplate <class T>\r\nstruct _WOW64_CLIENT_ID\r\n{\r\n    T UniqueProcess;\r\n    T UniqueThread;\r\n};\r\n\r\ntemplate <class T>\r\nstruct _TEB_T_\r\n{\r\n    _NT_TIB_T<T> NtTib;\r\n    T EnvironmentPointer;\r\n\t_WOW64_CLIENT_ID<T> ClientId;\r\n    T ActiveRpcHandle;\r\n    T ThreadLocalStoragePointer;\r\n    T ProcessEnvironmentBlock;\r\n    DWORD LastErrorValue;\r\n    DWORD CountOfOwnedCriticalSections;\r\n    T CsrClientThread;\r\n    T Win32ThreadInfo;\r\n    DWORD User32Reserved[26];\r\n    //rest of the structure is not defined for now, as it is not needed\r\n};\r\n\r\ntemplate <class T>\r\nstruct _LDR_DATA_TABLE_ENTRY_T\r\n{\r\n    _LIST_ENTRY_T<T> InLoadOrderLinks;\r\n    _LIST_ENTRY_T<T> InMemoryOrderLinks;\r\n    _LIST_ENTRY_T<T> InInitializationOrderLinks;\r\n    T DllBase;\r\n    T EntryPoint;\r\n    union\r\n    {\r\n        DWORD SizeOfImage;\r\n        T dummy01;\r\n    };\r\n    _UNICODE_STRING_T<T> FullDllName;\r\n    _UNICODE_STRING_T<T> BaseDllName;\r\n    DWORD Flags;\r\n    WORD LoadCount;\r\n    WORD TlsIndex;\r\n    union\r\n    {\r\n        _LIST_ENTRY_T<T> HashLinks;\r\n        struct \r\n        {\r\n            T SectionPointer;\r\n            T CheckSum;\r\n        };\r\n    };\r\n    union\r\n    {\r\n        T LoadedImports;\r\n        DWORD TimeDateStamp;\r\n    };\r\n    T EntryPointActivationContext;\r\n    T PatchInformation;\r\n    _LIST_ENTRY_T<T> ForwarderLinks;\r\n    _LIST_ENTRY_T<T> ServiceTagLinks;\r\n    _LIST_ENTRY_T<T> StaticLinks;\r\n    T ContextInformation;\r\n    T OriginalBase;\r\n    _LARGE_INTEGER LoadTime;\r\n};\r\n\r\ntemplate <class T>\r\nstruct _PEB_LDR_DATA_T\r\n{\r\n    DWORD Length;\r\n    DWORD Initialized;\r\n    T SsHandle;\r\n    _LIST_ENTRY_T<T> InLoadOrderModuleList;\r\n    _LIST_ENTRY_T<T> InMemoryOrderModuleList;\r\n    _LIST_ENTRY_T<T> InInitializationOrderModuleList;\r\n    T EntryInProgress;\r\n    DWORD ShutdownInProgress;\r\n    T ShutdownThreadId;\r\n\r\n};\r\n\r\ntemplate <class T, class NGF, int A>\r\nstruct _PEB_T\r\n{\r\n    union\r\n    {\r\n        struct\r\n        {\r\n            BYTE InheritedAddressSpace;\r\n            BYTE ReadImageFileExecOptions;\r\n            BYTE BeingDebugged;\r\n            BYTE BitField;\r\n        };\r\n        T dummy01;\r\n    };\r\n    T Mutant;\r\n    T ImageBaseAddress;\r\n    T Ldr;\r\n    T ProcessParameters;\r\n    T SubSystemData;\r\n    T ProcessHeap;\r\n    T FastPebLock;\r\n    T AtlThunkSListPtr;\r\n    T IFEOKey;\r\n    T CrossProcessFlags;\r\n    T UserSharedInfoPtr;\r\n    DWORD SystemReserved;\r\n    DWORD AtlThunkSListPtr32;\r\n    T ApiSetMap;\r\n    T TlsExpansionCounter;\r\n    T TlsBitmap;\r\n    DWORD TlsBitmapBits[2];\r\n    T ReadOnlySharedMemoryBase;\r\n    T HotpatchInformation;\r\n    T ReadOnlyStaticServerData;\r\n    T AnsiCodePageData;\r\n    T OemCodePageData;\r\n    T UnicodeCaseTableData;\r\n    DWORD NumberOfProcessors;\r\n    union\r\n    {\r\n        DWORD NtGlobalFlag;\r\n        NGF dummy02;\r\n    };\r\n    LARGE_INTEGER CriticalSectionTimeout;\r\n    T HeapSegmentReserve;\r\n    T HeapSegmentCommit;\r\n    T HeapDeCommitTotalFreeThreshold;\r\n    T HeapDeCommitFreeBlockThreshold;\r\n    DWORD NumberOfHeaps;\r\n    DWORD MaximumNumberOfHeaps;\r\n    T ProcessHeaps;\r\n    T GdiSharedHandleTable;\r\n    T ProcessStarterHelper;\r\n    T GdiDCAttributeList;\r\n    T LoaderLock;\r\n    DWORD OSMajorVersion;\r\n    DWORD OSMinorVersion;\r\n    WORD OSBuildNumber;\r\n    WORD OSCSDVersion;\r\n    DWORD OSPlatformId;\r\n    DWORD ImageSubsystem;\r\n    DWORD ImageSubsystemMajorVersion;\r\n    T ImageSubsystemMinorVersion;\r\n    T ActiveProcessAffinityMask;\r\n    T GdiHandleBuffer[A];\r\n    T PostProcessInitRoutine; \r\n    T TlsExpansionBitmap; \r\n    DWORD TlsExpansionBitmapBits[32];\r\n    T SessionId;\r\n    ULARGE_INTEGER AppCompatFlags;\r\n    ULARGE_INTEGER AppCompatFlagsUser;\r\n    T pShimData;\r\n    T AppCompatInfo;\r\n    _UNICODE_STRING_T<T> CSDVersion;\r\n    T ActivationContextData;\r\n    T ProcessAssemblyStorageMap;\r\n    T SystemDefaultActivationContextData;\r\n    T SystemAssemblyStorageMap;\r\n    T MinimumStackCommit;\r\n    T FlsCallback;\r\n    _LIST_ENTRY_T<T> FlsListHead;\r\n    T FlsBitmap;\r\n    DWORD FlsBitmapBits[4];\r\n    T FlsHighIndex;\r\n    T WerRegistrationData;\r\n    T WerShipAssertPtr;\r\n    T pContextData;\r\n    T pImageHeaderHash;\r\n    T TracingFlags;\r\n};\r\n\r\ntypedef _LDR_DATA_TABLE_ENTRY_T<DWORD> LDR_DATA_TABLE_ENTRY32;\r\ntypedef _LDR_DATA_TABLE_ENTRY_T<DWORD64> LDR_DATA_TABLE_ENTRY64;\r\n\r\ntypedef _TEB_T_<DWORD> TEB32;\r\ntypedef _TEB_T_<DWORD64> TEB64;\r\n\r\ntypedef _PEB_LDR_DATA_T<DWORD> PEB_LDR_DATA32;\r\ntypedef _PEB_LDR_DATA_T<DWORD64> PEB_LDR_DATA64;\r\n\r\ntypedef _PEB_T<DWORD, DWORD64, 34> PEB32;\r\ntypedef _PEB_T<DWORD64, DWORD, 30> PEB64;\r\n\r\nstruct _XSAVE_FORMAT64\r\n{\r\n    WORD ControlWord;\r\n    WORD StatusWord;\r\n    BYTE TagWord;\r\n    BYTE Reserved1;\r\n    WORD ErrorOpcode;\r\n    DWORD ErrorOffset;\r\n    WORD ErrorSelector;\r\n    WORD Reserved2;\r\n    DWORD DataOffset;\r\n    WORD DataSelector;\r\n    WORD Reserved3;\r\n    DWORD MxCsr;\r\n    DWORD MxCsr_Mask;\r\n    _M128A FloatRegisters[8];\r\n    _M128A XmmRegisters[16];\r\n    BYTE Reserved4[96];\r\n};\r\n\r\nstruct _CONTEXT64\r\n{\r\n    DWORD64 P1Home;\r\n    DWORD64 P2Home;\r\n    DWORD64 P3Home;\r\n    DWORD64 P4Home;\r\n    DWORD64 P5Home;\r\n    DWORD64 P6Home;\r\n    DWORD ContextFlags;\r\n    DWORD MxCsr;\r\n    WORD SegCs;\r\n    WORD SegDs;\r\n    WORD SegEs;\r\n    WORD SegFs;\r\n    WORD SegGs;\r\n    WORD SegSs;\r\n    DWORD EFlags;\r\n    DWORD64 Dr0;\r\n    DWORD64 Dr1;\r\n    DWORD64 Dr2;\r\n    DWORD64 Dr3;\r\n    DWORD64 Dr6;\r\n    DWORD64 Dr7;\r\n    DWORD64 Rax;\r\n    DWORD64 Rcx;\r\n    DWORD64 Rdx;\r\n    DWORD64 Rbx;\r\n    DWORD64 Rsp;\r\n    DWORD64 Rbp;\r\n    DWORD64 Rsi;\r\n    DWORD64 Rdi;\r\n    DWORD64 R8;\r\n    DWORD64 R9;\r\n    DWORD64 R10;\r\n    DWORD64 R11;\r\n    DWORD64 R12;\r\n    DWORD64 R13;\r\n    DWORD64 R14;\r\n    DWORD64 R15;\r\n    DWORD64 Rip;\r\n    _XSAVE_FORMAT64 FltSave;\r\n    _M128A Header[2];\r\n    _M128A Legacy[8];\r\n    _M128A Xmm0;\r\n    _M128A Xmm1;\r\n    _M128A Xmm2;\r\n    _M128A Xmm3;\r\n    _M128A Xmm4;\r\n    _M128A Xmm5;\r\n    _M128A Xmm6;\r\n    _M128A Xmm7;\r\n    _M128A Xmm8;\r\n    _M128A Xmm9;\r\n    _M128A Xmm10;\r\n    _M128A Xmm11;\r\n    _M128A Xmm12;\r\n    _M128A Xmm13;\r\n    _M128A Xmm14;\r\n    _M128A Xmm15;\r\n    _M128A VectorRegister[26];\r\n    DWORD64 VectorControl;\r\n    DWORD64 DebugControl;\r\n    DWORD64 LastBranchToRip;\r\n    DWORD64 LastBranchFromRip;\r\n    DWORD64 LastExceptionToRip;\r\n    DWORD64 LastExceptionFromRip;\r\n};\r\n\r\n// Below defines for .ContextFlags field are taken from WinNT.h\r\n#ifndef CONTEXT_AMD64\r\n#define CONTEXT_AMD64 0x100000\r\n#endif\r\n\r\n#define CONTEXT64_CONTROL (CONTEXT_AMD64 | 0x1L)\r\n#define CONTEXT64_INTEGER (CONTEXT_AMD64 | 0x2L)\r\n#define CONTEXT64_SEGMENTS (CONTEXT_AMD64 | 0x4L)\r\n#define CONTEXT64_FLOATING_POINT  (CONTEXT_AMD64 | 0x8L)\r\n#define CONTEXT64_DEBUG_REGISTERS (CONTEXT_AMD64 | 0x10L)\r\n#define CONTEXT64_FULL (CONTEXT64_CONTROL | CONTEXT64_INTEGER | CONTEXT64_FLOATING_POINT)\r\n#define CONTEXT64_ALL (CONTEXT64_CONTROL | CONTEXT64_INTEGER | CONTEXT64_SEGMENTS | CONTEXT64_FLOATING_POINT | CONTEXT64_DEBUG_REGISTERS)\r\n#define CONTEXT64_XSTATE (CONTEXT_AMD64 | 0x20L)\r\n\r\n#pragma pack(pop)\r\n\r\n#ifdef WOW64EXT_EXPORTS\r\n#   define SPEC dllexport\r\n#define WOW_EXPORT extern \"C\" __declspec(SPEC)\r\n#else\r\n#   define SPEC dllimport\r\n#define WOW_EXPORT extern \"C\" \r\n#endif\r\n\r\nWOW_EXPORT DWORD64 __cdecl X64Call(DWORD64 func, int argC, ...);\r\nWOW_EXPORT DWORD64 __cdecl GetModuleHandle64(wchar_t* lpModuleName);\r\nWOW_EXPORT DWORD64 __cdecl GetProcAddress64(DWORD64 hModule, char* funcName);\r\nWOW_EXPORT SIZE_T __cdecl VirtualQueryEx64(HANDLE hProcess, DWORD64 lpAddress, MEMORY_BASIC_INFORMATION64* lpBuffer, SIZE_T dwLength);\r\nWOW_EXPORT DWORD64 __cdecl VirtualAllocEx64(HANDLE hProcess, DWORD64 lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);\r\nWOW_EXPORT BOOL __cdecl VirtualFreeEx64(HANDLE hProcess, DWORD64 lpAddress, SIZE_T dwSize, DWORD dwFreeType);\r\nWOW_EXPORT BOOL __cdecl VirtualProtectEx64(HANDLE hProcess, DWORD64 lpAddress, SIZE_T dwSize, DWORD flNewProtect, DWORD* lpflOldProtect);\r\nWOW_EXPORT BOOL __cdecl ReadProcessMemory64(HANDLE hProcess, DWORD64 lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead);\r\nWOW_EXPORT BOOL __cdecl WriteProcessMemory64(HANDLE hProcess, DWORD64 lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten);\r\nWOW_EXPORT BOOL __cdecl GetThreadContext64(HANDLE hThread, _CONTEXT64* lpContext);\r\nWOW_EXPORT BOOL __cdecl SetThreadContext64(HANDLE hThread, _CONTEXT64* lpContext);\r\nWOW_EXPORT VOID __cdecl SetLastErrorFromX64Call(DWORD64 status);\r\nWOW_EXPORT DWORD64 __cdecl LoadLibraryW64(LPWSTR lpLibFileName);\r\nWOW_EXPORT void __cdecl InitWow64ext();\r\n\r\n"
        },
        {
          "name": "wow64layer.h",
          "type": "blob",
          "size": 5.1787109375,
          "content": "/*\n#ifndef CONTEXT_i386\n#define CONTEXT_i386    0x00010000    // this assumes that i386 and\n#define CONTEXT_i486    0x00010000    // i486 have identical context records\n#endif\n\n#define WOW64_CS32   0x23*/\n#include <Windows.h>\n\nBOOL XP_GetThreadWow64Context(\n\t\t\t\t\t  __in HANDLE Thread,\n\t\t\t\t\t  __in_opt HANDLE Process,\n\t\t\t\t\t  __inout PWOW64_CONTEXT Ctx32\n\t\t\t\t\t  )\n{\n\tTHREAD_BASIC_INFORMATION ThreadInfo;\n\tPWOW64_CONTEXT           RemoteCtx;\n\tCONTEXT                  Ctx64;\n\tSIZE_T                   Transferred;\n\tULONG                    ContextFlags;\n\tBOOLEAN                  CloseProcess;\n\tULONG                    LastError;\n\n\tCloseProcess       = FALSE;\n\n\tCtx64.ContextFlags = CONTEXT_ALL;\n\n\t//\n\t// Determine whether the thread is running in 64-bit mode or not.  If it is\n\t// running in 64-bit mode then we'll get the saved 32-bit context out of\n\t// the pointer in the 64-bit TEB's TLS slot.\n\t//\n\t// If, however, the thread is running in 32-bit mode, then we'll need to be\n\t// converting the 32-bit halves of the 64-bit registers into the\n\t// appropriate fields of the WOW64_CONTEXT structure.\n\t//\n\n\tif (!GetThreadContext(\n\t\tThread,\n\t\t&Ctx64))\n\t\treturn FALSE;\n\n\tif (Ctx64.SegCs != WOW64_CS32)\n\t{\n\t\twprintf(L\" -- Target is in 64-bit mode, returning saved 32-bit context\\n\");\n\n\t\t//\n\t\t// The thread is running in 64-bit mode.  We'll need to find the base\n\t\t// address of the thread's TEB and from there, read the remote TLS\n\t\t// slots and then the actual WOW64_CONTEXT structure residing within\n\t\t// the target.\n\t\t//\n\t\t// Also, if the caller didn't supply a process handle, then we'll\n\t\t// attempt to open one now using the thread's associated process ID in\n\t\t// the THREAD_BASIC_INFORMATION structure.  This is the typical\n\t\t// behavior of the Wow64 implementation of GetThreadContext.\n\t\t//\n\n\t\tif (!NT_SUCCESS(NtQueryInformationThread(\n\t\t\tThread,\n\t\t\tThreadBasicInformation,\n\t\t\t&ThreadInfo,\n\t\t\tsizeof( THREAD_BASIC_INFORMATION ),\n\t\t\t0\n\t\t\t)))\n\t\t{\n\t\t\tSetLastError( ERROR_INVALID_HANDLE );\n\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t//\n\t\t// If we don't have a process handle then we'll need to be opening one\n\t\t// ourselves for the VM read operation.\n\t\t//\n\n\t\tif (!Process)\n\t\t{\n\t\t\tProcess = OpenProcess(\n\t\t\t\tPROCESS_VM_READ,\n\t\t\t\tFALSE,\n\t\t\t\tHandleToUlong(ThreadInfo.ClientId.UniqueProcess)\n\t\t\t\t);\n\n\t\t\tif (!Process)\n\t\t\t\treturn FALSE;\n\n\t\t\tCloseProcess = TRUE;\n\t\t}\n\n\t\t//\n\t\t// Fetch the second TLS slot.  Wow64 assumes (hardcoded) that the\n\t\t// second TLS slot is the WOW64_CONTEXT.  This is a bit sloppy, but it\n\t\t// works out as there's not a 64-bit kernel32.dll loaded in a Wow64\n\t\t// process, so there won't be anyone calling TlsAlloc anyway.\n\t\t//\n\n\t\tif (!ReadProcessMemory(\n\t\t\tProcess,\n\t\t\t&((PTEB)ThreadInfo.TebBaseAddress)->TlsSlots[ 1 ],\n\t\t\t&RemoteCtx,\n\t\t\tsizeof( PWOW64_CONTEXT ),\n\t\t\t&Transferred))\n\t\t{\n\t\t\tif (CloseProcess)\n\t\t\t{\n\t\t\t\tLastError = GetLastError();\n\n\t\t\t\tCloseHandle( Process );\n\n\t\t\t\tSetLastError( LastError );\n\t\t\t}\n\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (Transferred != sizeof( PWOW64_CONTEXT ))\n\t\t{\n\t\t\tif (CloseProcess)\n\t\t\t\tCloseHandle( Process );\n\n\t\t\tSetLastError( ERROR_PARTIAL_COPY );\n\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t//\n\t\t// Now that we've got the PWOW64_CONTEXT pointer, let's read the memory\n\t\t// where the actual context is stored.\n\t\t//\n\t\t// Note that this is unreliable if the remote thread is still running\n\t\t// when we make the call.\n\t\t//\n\n\t\t//\n\t\t// TODO: Pay attention to the caller's requested context flags and\n\t\t// filter the returned context appropriately.\n\t\t//\n\n\t\tif (!ReadProcessMemory(\n\t\t\tProcess,\n\t\t\t(PUCHAR)(RemoteCtx) + sizeof( ULONG ),\n\t\t\tCtx32,\n\t\t\tsizeof( WOW64_CONTEXT ),\n\t\t\t&Transferred\n\t\t\t))\n\t\t{\n\t\t\tif (CloseProcess)\n\t\t\t{\n\t\t\t\tLastError = GetLastError();\n\n\t\t\t\tCloseHandle( Process );\n\n\t\t\t\tSetLastError( LastError );\n\t\t\t}\n\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (Transferred != sizeof( WOW64_CONTEXT ))\n\t\t{\n\t\t\tif (CloseProcess)\n\t\t\t\tCloseHandle( Process );\n\n\t\t\tSetLastError( ERROR_PARTIAL_COPY );\n\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t//\n\t\t// All done.\n\t\t//\n\t}\n\telse\n\t{\n\t\twprintf(L\" -- Target is in 32-bit mode, truncating 64-bit registers\\n\");\n\n\t\t//\n\t\t// The requested thread is executing 32-bit instructions and is not in\n\t\t// the Wow64 layer (e.g. a system call).  This means that the 64-bit\n\t\t// thread context is actually reflective of the Wow64 context, except\n\t\t// that we need to convert from an x64 context strucuture to the\n\t\t// WOW64_CONTEXT structure (the high halves of registers are discarded\n\t\t// here).\n\t\t//\n\n\t\tContextFlags = Ctx32->ContextFlags | CONTEXT_i386;\n\n\t\tZeroMemory(\n\t\t\tCtx32,\n\t\t\tsizeof( WOW64_CONTEXT )\n\t\t\t);\n\n\t\tCtx32->ContextFlags = ContextFlags;\n\n\t\tif (ContextFlags & CONTEXT_CONTROL)\n\t\t{\n\t\t\tCtx32->Eip    = (ULONG)Ctx64.Rip;\n\t\t\tCtx32->EFlags = (ULONG)Ctx64.EFlags;\n\t\t\tCtx32->Esp    = (ULONG)Ctx64.Rsp;\n\t\t\tCtx32->Ebp    = (ULONG)Ctx64.Rbp;\n\t\t}\n\n\t\tif (ContextFlags & CONTEXT_INTEGER)\n\t\t{\n\t\t\tCtx32->Eax = (ULONG)Ctx64.Rax;\n\t\t\tCtx32->Ebx = (ULONG)Ctx64.Rbx;\n\t\t\tCtx32->Ecx = (ULONG)Ctx64.Rcx;\n\t\t\tCtx32->Edx = (ULONG)Ctx64.Rdx;\n\t\t\tCtx32->Edi = (ULONG)Ctx64.Rdi;\n\t\t\tCtx32->Esi = (ULONG)Ctx64.Rsi;\n\t\t}\n\n\t\t//\n\t\t// TODO: Convert other registers, pay attention to the caller's\n\t\t// requested context flags.  For example, floating point registers\n\t\t// would need to be handled here if support for them is desired.\n\t\t//\n\n\t\t//\n\t\t// All done.\n\t\t//\n\t}\n\n\tif (CloseProcess)\n\t\tCloseHandle( Process );\n\n\treturn TRUE;\n}\n"
        }
      ]
    }
  ]
}