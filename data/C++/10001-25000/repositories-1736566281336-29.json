{
  "metadata": {
    "timestamp": 1736566281336,
    "page": 29,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "xbmc/xbmc",
      "stars": 18754,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 2.9365234375,
          "content": "---\n# BasedOnStyle:  LLVM\nAccessModifierOffset: -2\nAlignAfterOpenBracket: Align\nAlignConsecutiveAssignments: false\nAlignConsecutiveDeclarations: false\nAlignEscapedNewlines: DontAlign\nAlignOperands:   true\nAlignTrailingComments: false\nAllowAllParametersOfDeclarationOnNextLine: true\nAllowShortBlocksOnASingleLine: false\nAllowShortCaseLabelsOnASingleLine: false\nAllowShortFunctionsOnASingleLine: InlineOnly\nAllowShortIfStatementsOnASingleLine: false\nAllowShortLoopsOnASingleLine: false\nAlwaysBreakAfterDefinitionReturnType: None\nAlwaysBreakAfterReturnType: None\nAlwaysBreakBeforeMultilineStrings: false\nAlwaysBreakTemplateDeclarations: true\nBinPackArguments: true\nBinPackParameters: false\nBreakBeforeBinaryOperators: None\nBreakBeforeBraces: Allman\nBreakBeforeTernaryOperators: true\nBreakConstructorInitializersBeforeComma: false\nBreakConstructorInitializers: BeforeColon\nBreakAfterJavaFieldAnnotations: false\nBreakStringLiterals: true\nColumnLimit:     100\nCommentPragmas:  '^ IWYU pragma:'\nConstructorInitializerAllOnOneLineOrOnePerLine: true\nConstructorInitializerIndentWidth: 2\nContinuationIndentWidth: 4\nCpp11BracedListStyle: true\nDerivePointerAlignment: false\nDisableFormat:   false\nExperimentalAutoDetectBinPacking: false\nForEachMacros:   [ foreach, Q_FOREACH, BOOST_FOREACH ]\nIncludeBlocks: Regroup\nIncludeCategories:\n  - Regex:           '<EGL/.*\\.h>'\n    Priority:        6\n  - Regex:           '([\"/]PlatformDefs|\"(system|system_gl|system_egl))\\.h\"'\n    Priority:        5\n  - Regex:           '\"platform/[^/]+/'\n    Priority:        2\n  - Regex:           '^<[a-z0-9_]+>$'\n    Priority:        3\n  - Regex:           '^<(assert|complex|ctype|errno|fenv|float|inttypes|iso646|limits|locale|math|setjmp|signal|stdalign|stdarg|stdatomic|stdbool|stddef|stdint|stdio|stdlib|stdnoreturn|string|tgmath|threads|time|uchar|wchar|wctype)\\.h>$'\n    Priority:        3\n  - Regex:           '^<'\n    Priority:        4\n  - Regex:           '.*'\n    Priority:        1\nIncludeIsMainRegex: '$'\nIndentCaseLabels: true\nIndentWidth:     2\nIndentWrappedFunctionNames: false\nJavaScriptQuotes: Leave\nJavaScriptWrapImports: true\nKeepEmptyLinesAtTheStartOfBlocks: true\nMacroBlockBegin: ''\nMacroBlockEnd:   ''\nMaxEmptyLinesToKeep: 1\nNamespaceIndentation: None\nObjCBlockIndentWidth: 2\nObjCSpaceAfterProperty: false\nObjCSpaceBeforeProtocolList: true\nPenaltyBreakBeforeFirstCallParameter: 19\nPenaltyBreakComment: 300\nPenaltyBreakFirstLessLess: 120\nPenaltyBreakString: 1000\nPenaltyExcessCharacter: 1000000\nPenaltyReturnTypeOnItsOwnLine: 60000\nPointerAlignment: Left\nReflowComments:  false\nSortIncludes:    true\nSpaceAfterCStyleCast: false\nSpaceAfterTemplateKeyword: false\nSpaceBeforeAssignmentOperators: true\nSpaceBeforeParens: ControlStatements\nSpaceInEmptyParentheses: false\nSpacesBeforeTrailingComments: 1\nSpacesInAngles:  false\nSpacesInContainerLiterals: true\nSpacesInCStyleCastParentheses: false\nSpacesInParentheses: false\nSpacesInSquareBrackets: false\nStandard:        Cpp11\nTabWidth:        8\nUseTab:          Never\n...\n"
        },
        {
          "name": ".clang-tidy",
          "type": "blob",
          "size": 0.66015625,
          "content": "Checks: \"\\\n  modernize-make-shared,\\\n  modernize-make-unique,\\\n  modernize-use-default-member-init,\\\n  modernize-use-emplace,\\\n  performance-faster-string-find,\\\n  performance-for-range-copy,\\\n  performance-implicit-conversion-in-loop,\\\n  performance-inefficient-algorithm,\\\n  performance-inefficient-vector-operation,\\\n  performance-move-const-arg,\\\n  performance-move-constructor-init,\\\n  performance-no-automatic-move,\\\n  performance-noexcept-move-constructor,\\\n  performance-trivially-destructible,\\\n  performance-type-promotion-in-math-fn,\\\n  performance-unnecessary-copy-initialization,\\\n  performance-unnecessary-value-param,\\\n\"\nHeaderFilterRegex: '(^|/)(tools|xbmc)/'\n"
        },
        {
          "name": ".git-blame-ignore-revs",
          "type": "blob",
          "size": 0.6806640625,
          "content": "# Since version 2.23 (released in August 2019), git-blame has a feature\n# to ignore or bypass certain commits.\n#\n# This file contains a list of commits that are not likely what you\n# are looking for in a blame, such as mass reformatting or renaming.\n# You can set this file as a default ignore file for blame by running\n# the following command.\n#\n# $ git config blame.ignoreRevsFile .git-blame-ignore-revs\n\n# PR 17922: Clang-format our Game/Input code for GSoC\n838cf16f17a7fcf5d49ac0b3d51d9826a9fb7a6e\nd1e6fff19c1cf2a266f0429c8d0ddea3195ddcce\n0b34dc7e6f61424c8cce7249cdcd6060b8eada9e\n71a2c6b734420f540b0d06f6e3334ffe5a9e8225\n\n# formatting JSON-RPC schemas\n537d5e552f68e5cb851ad97b15ec785f73adae60\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 7.662109375,
          "content": "# global patterns\ntestMain\n\n# commonly used editors\n# vim\n*.swp\n# Eclipse\n*.project\n*.cproject\n.classpath\n*.sublime-*\n# KDevelop 4\n*.kdev4\n# gedit\n*~\n# CLion\n/.idea\n.vscode/\n# Created in vs2017 when using open folder\n.vs/\n\n# Created in vs2017 when using open folder with cmake tools\nCMakeSettings.json\n\n# Created in vscode when using cmake-tools\ncmake-variants.yaml\ncmake-kits.json\n\n# generated files etc\n.last_success_revision\n*.d\n*.depend\n*.pc\n*.P\n*.[oa]\n*.l[oa]\n*.so\n*.so.*\n*.dylib\n*.lineno\n*.py[co]\n*.ver\n*.rej\n*.orig\n*.bak\n*.apk\n*.class\n*.dwo\n*.wget-hsts\n\n# Windows specific generated files\n*.appx\n*.appxsym\n*.msix\n*.cer\n*.exp\n*.ilk\n*.ncb\n*.pdb\n*.suo\n*.sdf\n*.opensdf\n*.vcproj.*.user\n*.vcxproj.*.user\n*.vcxproj.user\n*.obj\n*.idb\n*ReSharper*\n*.idb\n*.diagsession\n\n# osx specifics\n/kodi.build/\n/Debug/\n/Release/\n.DS_Store\n*.dSYM\n._*\n*.mode1v3\n*.pbxuser\n*project.xcworkspace\n*xcuserdata\n.libs/\n.deps/\n__.SYMDEF*\n\n# CMake project files\nCMakeCache.txt\nCMakeFiles\nCMakeScripts\nCTestTestfile.cmake\ncmake_install.cmake\n\n# Eclipse project files. Not needed as they are generated in two clicks if needed.\n.settings\n.project\n.cproject\n\n/nbproject\n\n# /\n/kodi.log\n/kodi.old.log\n/kodi.bin\n/kodi-test\n/kodi-xrandr\n/*.diff\n/*.patch\n/kodi-build*/\n/gtestresults.xml\n\n# /addons/\n/addons/packages\n/addons/skin.estuary/media/Makefile\n/addons/skin.estuary/media/*.xbt\n/addons/skin.pm3-hd/media/Textures.xbt\n/addons/audioencoder.*\n/addons/pvr.*\n/addons/peripheral.*\n/addons/game.*\n/addons/kodi.binary.global.audioengine/addon.xml\n/addons/kodi.binary.global.filesystem/addon.xml\n/addons/kodi.binary.global.general/addon.xml\n/addons/kodi.binary.global.gui/addon.xml\n/addons/kodi.binary.global.main/addon.xml\n/addons/kodi.binary.global.network/addon.xml\n/addons/kodi.binary.global.tools/addon.xml\n/addons/kodi.binary.instance.audiodecoder/addon.xml\n/addons/kodi.binary.instance.audioencoder/addon.xml\n/addons/kodi.binary.instance.game/addon.xml\n/addons/kodi.binary.instance.imagedecoder/addon.xml\n/addons/kodi.binary.instance.inputstream/addon.xml\n/addons/kodi.binary.instance.peripheral/addon.xml\n/addons/kodi.binary.instance.pvr/addon.xml\n/addons/kodi.binary.instance.screensaver/addon.xml\n/addons/kodi.binary.instance.vfs/addon.xml\n/addons/kodi.binary.instance.videocodec/addon.xml\n/addons/kodi.binary.instance.visualization/addon.xml\n/addons/xbmc.addon/addon.xml\n/addons/xbmc.json/addon.xml\n/addons/audiodecoder.*\n/addons/visualization.*\n/addons/screensaver.*\n/addons/inputstream.*\n/addons/vfs.*\n\n# /lib/\n/lib/Makefile\n/lib/*/1\n/lib/*/win32/1\n\n# /lib/gtest\n/lib/gtest/Makefile.in\n/lib/gtest/aclocal.m4\n/lib/gtest/build-aux/compile\n/lib/gtest/build-aux/config.guess\n/lib/gtest/build-aux/config.h.in\n/lib/gtest/build-aux/config.sub\n/lib/gtest/build-aux/depcomp\n/lib/gtest/build-aux/install-sh\n/lib/gtest/build-aux/ltmain.sh\n/lib/gtest/build-aux/missing\n/lib/gtest/configure\n/lib/gtest/config.cache\n/lib/gtest/config.log\n/lib/gtest/config.status\n/lib/gtest/m4/libtool.m4\n/lib/gtest/m4/ltoptions.m4\n/lib/gtest/m4/ltsugar.m4\n/lib/gtest/m4/ltversion.m4\n/lib/gtest/m4/lt~obsolete.m4\n/lib/gtest/Makefile\n/lib/gtest/build-aux/config.h\n/lib/gtest/build-aux/config.h.in~\n/lib/gtest/build-aux/stamp-h1\n/lib/gtest/build-aux/test-driver\n/lib/gtest/fused-src/\n/lib/gtest/lib/\n/lib/gtest/libtool\n/lib/gtest/samples/.dirstamp\n/lib/gtest/scripts/gtest-config\n/lib/gtest/src/.dirstamp\n\n# /project\n/project/obj\n/project/output\n\n# /cmake\n/cmake/KodiConfig.cmake\n/cmake/addons/*.error\n/cmake/addons/.failure\n/cmake/addons/.success\n/cmake/addons/addons\n/cmake/addons/build\n/cmake/addons/depends/build\n/cmake/addons/output\n\n# /project/Win32BuildSetup/\n/project/Win32BuildSetup/*.log\n/project/Win32BuildSetup/*.exe\n/project/Win32BuildSetup/*.pdb\n/project/Win32BuildSetup/*-addons.nsi\n/project/Win32BuildSetup/bgprocess\n/project/Win32BuildSetup/exclude.txt\n/project/Win32BuildSetup/makeclean\n/project/Win32BuildSetup/noprompt\n/project/Win32BuildSetup/BUILD_WIN32/\n\n# /project/BuildDependencies\n/project/BuildDependencies/downloads\n/project/BuildDependencies/downloads2\n/project/BuildDependencies/msys32\n/project/BuildDependencies/msys64\n/project/BuildDependencies/locals\n/project/BuildDependencies/build\n/project/BuildDependencies/scripts/tmp\n/project/BuildDependencies/src\n/project/BuildDependencies/tools\n/project/BuildDependencies/bin/swig\n/project/BuildDependencies/bin/doxygen\n/project/BuildDependencies/bin/json-rpc\n/project/BuildDependencies/mingwlibs\n/project/BuildDependencies/x64\n/project/BuildDependencies/win10-arm\n/project/BuildDependencies/win10-x64\n/project/BuildDependencies/win10-win32\n/project/BuildDependencies/win32\n\n# /system/players/VideoPlayer\n/system/players/VideoPlayer/*\n\n# /system\n/system/profiles.xml\n\n# /system/python\n/system/python/\n\n# /system/webserver\n/system/webserver\n\n/system/airplay\n\n#/tools/android\n/tools/android/packaging/Makefile\n/tools/android/packaging/xbmc/activity_main.xml\n/tools/android/packaging/xbmc/AndroidManifest.xml\n/tools/android/packaging/xbmc/src/org/xbmc/kodi/Main.java\n/tools/android/packaging/xbmc/src/org/xbmc/kodi/Splash.java\n/tools/android/packaging/xbmc/src/org/xbmc/kodi/XBMCBroadcastReceiver.java\n/tools/android/packaging/xbmc/src/org/xbmc/kodi/XBMCInputDeviceListener.java\n/tools/android/packaging/xbmc/src/org/xbmc/kodi/XBMCOnAudioFocusChangeListener.java\n/tools/android/packaging/xbmc/src/org/xbmc/kodi/XBMCOnFrameAvailableListener.java\n/tools/android/packaging/xbmc/src/org/xbmc/kodi/XBMCSettingsContentObserver.java\n/tools/android/packaging/xbmc/src/org/xbmc/kodi/XBMCVideoView.java\n/tools/android/packaging/xbmc/strings.xml\n\n#/tools/depends\n/tools/depends/**/config.cache\n/tools/depends/**/config.log\n/tools/depends/**/config.status\n/tools/depends/native/*/*native/\n/tools/depends/native/JsonSchemaBuilder/bin/\n/tools/depends/native/TexturePacker/bin/\n/tools/depends/target/ffmpeg/.ffmpeg-installed\n/tools/depends/target/ffmpeg/ffmpeg-*.tar.gz*\n/tools/depends/target/ffmpeg/ffmpeg-*-*/\n/tools/depends/target/ffmpeg/ffmpeg-install/\n/tools/depends/target/ffmpeg/ffmpeg-release/\n/tools/depends/target/dav1d/dav1d-*.tar.*\n/tools/depends/target/libdvdcss/dvdcss-install/\n/tools/depends/target/libdvdcss/libdvdcss-*.tar.gz\n/tools/depends/target/libdvdcss/native/\n/tools/depends/target/libdvdnav/dvdnav-install/\n/tools/depends/target/libdvdnav/libdvdnav-*.tar.gz\n/tools/depends/target/libdvdnav/native/\n/tools/depends/target/libdvdread/dvdread-install/\n/tools/depends/target/libdvdread/libdvdread-*.tar.gz\n/tools/depends/target/libdvdread/native/\n/tools/depends/target/Toolchain_binaddons.cmake\n/tools/depends/target/config-binaddons.site\n/tools/depends/target/binary-addons/native\n\n# /tools/EventClients/\n/tools/EventClients/*.pyc\n/tools/EventClients/Makefile\n/tools/EventClients/Clients/OSXRemote/Makefile\n/tools/EventClients/Clients/OSXRemote/build/\n/tools/EventClients/Clients/WiiRemote/WiiRemote\n\n# /tools/darwin/\n/tools/darwin/Configurations/App.xcconfig\n/tools/darwin/Configurations/Common.xcconfig\n/tools/darwin/packaging/darwin_embedded/mkdeb-darwin_embedded.sh\n/tools/darwin/packaging/osx/mkdmg-osx.sh\n/tools/darwin/packaging/osx/VolumeIcon.icns\n/tools/darwin/packaging/seatbeltunlock/mkdeb-seatbeltunlock.sh\n/tools/darwin/runtime/XBMCHelper\n\n# /tools/Linux/\n/tools/Linux/kodi.sh\n/tools/Linux/kodi-standalone.sh\n/tools/Linux/kodi-xsession.desktop\n\n# /tools/osx\n/tools/osx/XBMCHelper\n\n# /tools/TexturePacker\n/tools/TexturePacker/TexturePacker*\n/tools/TexturePacker/Makefile\n\n# /userdata/\n/userdata/Database\n/userdata/playlists\n/userdata/Thumbnails\n/userdata/cache\n/userdata/guisettings.xml\n\n#/lib/win32\n/lib/win32/*.tar*\n/lib/win32/pax_global_header\n\n/lib/libUPnP/Makefile\n\n# /portable_data\n/portable_data\n\n/pvr-addons\n\n# Doxygen generated files\n/docs/html\nexclude_dll.txt\n\n# VS git tools doesn't work for true out of tree builds and it's\n# useful to be able to work on multiple configs\n/build*/\n\n# clangd index\n.cache/\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 29.630859375,
          "content": "cmake_minimum_required(VERSION 3.16)\nif(WIN32)\n  # Version 3.20 is required for multi-config generator expressions to work\n  cmake_minimum_required(VERSION 3.20)\nendif()\nproject(kodi LANGUAGES CXX C ASM)\n\nif(POLICY CMP0069)\n  set(CMAKE_POLICY_DEFAULT_CMP0069 NEW)\n  cmake_policy(SET CMP0069 NEW)\nendif()\n\n# https://cmake.org/cmake/help/latest/policy/CMP0074.html\n# find_package() uses <PackageName>_ROOT variables\nif(POLICY CMP0074)\n  set(CMAKE_POLICY_DEFAULT_CMP0074 NEW)\n  cmake_policy(SET CMP0074 NEW)\nendif()\n\nif(POLICY CMP0079)\n  set(CMAKE_POLICY_DEFAULT_CMP0079 NEW)\n  cmake_policy(SET CMP0079 NEW)\nendif()\n\nif(POLICY CMP0135)\n  set(CMAKE_POLICY_DEFAULT_CMP0135 NEW)\n  cmake_policy(SET CMP0135 NEW)\nendif()\n\n# https://cmake.org/cmake/help/latest/policy/CMP0144.html\n# find_package() uses upper-case <PACKAGENAME>_ROOT variables\nif(POLICY CMP0144)\n  set(CMAKE_POLICY_DEFAULT_CMP0144 NEW)\n  cmake_policy(SET CMP0144 NEW)\nendif()\n\nlist(APPEND CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake/modules)\nlist(APPEND CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake/modules/buildtools)\nif(DEPENDS_DIR)\n  list(APPEND CMAKE_PREFIX_PATH ${DEPENDS_DIR})\nendif()\n\n# Variable to indicate if the project is targeting a Multi Config Generator (VS/Xcode primarily)\nget_property(_multiconfig_generator GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)\nif(_multiconfig_generator)\n  # Target to encompass an optional way to build all internal dependencies\n  # Must set EXCLUDE_FROM_ALL property so the ALL target doesnt include this, and therefore\n  # build all internal dependencies\n  add_custom_target(build_internal_depends)\n  set_target_properties(build_internal_depends PROPERTIES EXCLUDE_FROM_ALL TRUE)\nendif()\n\n# Set CORE_BUILD_DIR\nset(CORE_BUILD_DIR build)\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n\n# set KODI_MIRROR to the default if not already set\nif(NOT DEFINED KODI_MIRROR)\n  set(KODI_MIRROR \"http://mirrors.kodi.tv\")\nendif()\n\nmessage(STATUS \"Mirror download location: ${KODI_MIRROR}\")\nmessage(STATUS \"Source directory: ${CMAKE_SOURCE_DIR}\")\nmessage(STATUS \"Build directory: ${CMAKE_BINARY_DIR}\")\nif(CMAKE_BINARY_DIR STREQUAL CMAKE_SOURCE_DIR)\n  message(WARNING \"In-source build detected. It is recommended to build out-of-source.\")\nendif()\n\n# Hide messages from Check*.cmake (e.g. CheckCSourceCompiles)\nif(NOT VERBOSE)\n  set(CMAKE_REQUIRED_QUIET ON)\nendif()\n\n# Includes\ninclude(cmake/modules/extra/ECMEnableSanitizers.cmake)\ninclude(cmake/scripts/common/GeneratorSetup.cmake)\ninclude(cmake/scripts/common/AddOptions.cmake)\ninclude(cmake/scripts/common/Platform.cmake)\ninclude(cmake/scripts/common/ArchSetup.cmake)\ninclude(cmake/scripts/common/Macros.cmake)\ninclude(cmake/scripts/common/ProjectMacros.cmake)\ncore_find_versions()\ninclude(cmake/scripts/common/PathSetup.cmake)\ninclude(cmake/scripts/common/CompilerSettings.cmake)\ninclude(ExternalProject)\ninclude(CMakeDependentOption)\ninclude(cmake/scripts/common/DependencyOptions.cmake)\n\n# general\noption(VERBOSE            \"Enable verbose output?\" OFF)\noption(ENABLE_CLANGTIDY   \"Enable clang-tidy support?\" OFF)\noption(ENABLE_CPPCHECK    \"Enable cppcheck support?\" OFF)\noption(ENABLE_DVDCSS      \"Enable libdvdcss support?\" ON)\noption(ENABLE_INCLUDEWHATYOUUSE \"Enable include-what-you-use support?\" OFF)\noption(ENABLE_UPNP        \"Enable UPnP support?\" ON)\noption(ENABLE_AIRTUNES    \"Enable AirTunes support?\" ON)\noption(ENABLE_OPTICAL     \"Enable optical support?\" ON)\noption(ENABLE_PYTHON      \"Enable python support?\" ON)\noption(ENABLE_TESTING     \"Enable testing support?\" ON)\n\n# Internal Depends - supported on all platforms\n\n# These are required enabled for all CI platforms, and recommended for all builds\noption(ENABLE_INTERNAL_CROSSGUID \"Enable internal crossguid?\" ON)\n\n# use ffmpeg from depends or system\noption(ENABLE_INTERNAL_FFMPEG \"Enable internal ffmpeg?\" OFF)\n\n# These are built for all platforms not using system libs or disabled by user\ndependent_option(ENABLE_INTERNAL_ASS \"Enable internal libass?\")\ndependent_option(ENABLE_INTERNAL_CEC \"Enable internal libcec?\")\ndependent_option(ENABLE_INTERNAL_CURL \"Enable internal libcurl?\")\ndependent_option(ENABLE_INTERNAL_EXIV2 \"Enable internal exiv2?\")\ndependent_option(ENABLE_INTERNAL_FLATBUFFERS \"Enable internal flatbuffers?\")\ndependent_option(ENABLE_INTERNAL_FMT \"Enable internal fmt?\")\ndependent_option(ENABLE_INTERNAL_NFS \"Enable internal libnfs?\")\ndependent_option(ENABLE_INTERNAL_PCRE2 \"Enable internal pcre2?\")\ndependent_option(ENABLE_INTERNAL_RapidJSON \"Enable internal rapidjson?\")\n\n# If ENABLE_INTERNAL_FMT is ON, we force ENABLE_INTERNAL_SPDLOG ON as it has a hard\n# dependency on fmt\nif(ENABLE_INTERNAL_FMT)\n  option(ENABLE_INTERNAL_SPDLOG \"Enable internal spdlog Forced\" ON)\nelse()\n  dependent_option(ENABLE_INTERNAL_SPDLOG \"Enable internal spdlog?\")\nendif()\n\ndependent_option(ENABLE_INTERNAL_TAGLIB \"Enable internal taglib?\")\n\nif(KODI_DEPENDSBUILD OR WIN32 OR WINDOWS_STORE)\n  dependent_option(ENABLE_INTERNAL_TINYXML2 \"Enable internal TinyXML2?\")\nendif()\n\n# Internal Depends - supported on UNIX platforms\nif(UNIX)\n  option(FFMPEG_PATH        \"Path to external ffmpeg?\" \"\")\n  option(ENABLE_INTERNAL_FSTRCMP \"Enable internal fstrcmp?\" OFF)\n  option(ENABLE_INTERNAL_DAV1D \"Enable internal dav1d?\" OFF)\n  option(ENABLE_INTERNAL_GTEST \"Enable internal gtest?\" OFF)\n  option(ENABLE_INTERNAL_UDFREAD \"Enable internal udfread?\" OFF)\nendif()\n\n# System options\nif(NOT WIN32)\n  option(WITH_ARCH              \"build with given arch\" OFF)\n  option(WITH_CPU               \"build with given cpu\" OFF)\nendif()\nif(CORE_SYSTEM_NAME STREQUAL linux)\n  option(ENABLE_EVENTCLIENTS    \"Enable event clients support?\" OFF)\n  option(ADDONS_CONFIGURE_AT_STARTUP \"Configure binary addons at startup?\" ON)\nendif()\n\n# Build static libraries per directory\nif(NOT CMAKE_GENERATOR MATCHES \"Visual Studio\" AND NOT CMAKE_GENERATOR STREQUAL Xcode)\n  set(ENABLE_STATIC_LIBS TRUE)\nelse()\n  set(ENABLE_STATIC_LIBS FALSE)\nendif()\n\ncore_find_git_rev(APP_SCMID FULL)\n\nset(AUDIO_BACKENDS_LIST \"\" CACHE STRING \"Available audio backends\")\nset(GL_INTERFACES_LIST \"\" CACHE STRING \"Available GL interfaces\")\n\n# Dynamically loaded libraries built with the project\nadd_custom_target(${APP_NAME_LC}-libraries)\nset(LIBRARY_FILES \"\" CACHE STRING \"\" FORCE)\nmark_as_advanced(LIBRARY_FILES)\n\nset(INCLUDES ${CMAKE_SOURCE_DIR}\n             ${CMAKE_SOURCE_DIR}/lib\n             ${CMAKE_SOURCE_DIR}/xbmc\n             ${CMAKE_SOURCE_DIR}/xbmc/${PLATFORM_DIR}\n             ${CMAKE_SOURCE_DIR}/xbmc/cores/VideoPlayer\n             ${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}\n             ${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}/include)\n\nif (NOT PLATFORMDEFS_DIR STREQUAL \"\")\n  list(APPEND INCLUDES ${CMAKE_SOURCE_DIR}/xbmc/${PLATFORMDEFS_DIR})\nendif()\n\nfind_package(PkgConfig QUIET)\nset(THREADS_PREFER_PTHREAD_FLAG ON)\nfind_package(Threads REQUIRED QUIET)\nlist(APPEND DEPLIBS ${CMAKE_THREAD_LIBS_INIT})\n\n# Clean any existing generated build dir cmake files\nfile(REMOVE ${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}/ExportFiles.cmake)\nfile(REMOVE ${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}/GeneratedPackSkins.cmake)\n\nforeach(depspec ${PLATFORM_REQUIRED_DEPS})\n  # We need to specify ENABLE_${PLATFORM_REQUIRED_DEPS} in order for the\n  # optional subdirectory for the specified platform to get built.\n  split_dependency_specification(${depspec} dep version)\n  string(TOUPPER ${dep} depup)\n  if(NOT ${ENABLE_${depup}} STREQUAL AUTO AND NOT ${ENABLE_${depup}})\n    message(WARNING \"Your request to disable the dependency ${dep} required on platform ${CORE_PLATFORM_NAME} was ignored. Please choose another platform or add \\\"-DENABLE_${depup}=ON\\\" to your CMake command line to resolve this warning.\")\n  endif()\n  set(ENABLE_${depup} \"ON\" CACHE BOOL \"Force enabling required ${depup} support\" FORCE)\nendforeach()\n\n# Required tools. Keep in alphabetical order please\nset(required_buildtools FlatC\n                        JsonSchemaBuilder\n                        TexturePacker\n                        ${PLATFORM_REQUIRED_TOOLS}\n)\n\n# Optional build tools\nset(optional_buildtools CCache\n                        ClangFormat\n                        ClangTidy\n                        Cppcheck\n                        IncludeWhatYouUse)\n\n# Find build tools - Optional and required\ncore_optional_dep(${optional_buildtools})\ncore_require_dep(${required_buildtools})\n\n# We want to explicitly ignore NATIVEPREFIX for any find calls to build target dependencies\nif(NATIVEPREFIX)\n  set(CMAKE_IGNORE_PREFIX_PATH ${NATIVEPREFIX})\nendif()\n\n# Required dependencies. Keep in alphabetical order please\nset(required_deps ASS>=0.15.0\n                  Cdio\n                  CrossGUID\n                  Curl\n                  Exiv2\n                  FFMPEG\n                  FlatBuffers\n                  Fmt\n                  FreeType\n                  FriBidi\n                  Fstrcmp\n                  HarfBuzz\n                  Iconv\n                  LibDvd\n                  Lzo2\n                  OpenSSL>=1.1.0\n                  PCRE2\n                  RapidJSON>=1.0.2\n                  Spdlog\n                  Sqlite3\n                  TagLib>=1.9.0\n                  TinyXML\n                  TinyXML2\n                  ZLIB\n                  ${PLATFORM_REQUIRED_DEPS})\n\n# Optional dependencies. Keep in alphabetical order please\nset(optional_deps Alsa>=1.0.27\n                  Avahi\n                  Bluetooth\n                  Bluray>=0.9.3\n                  CAP\n                  CEC>=4.0.0\n                  Dav1d\n                  DBus\n                  Iso9660pp>=2.1.0\n                  LCMS2>=2.10\n                  LircClient\n                  MDNS\n                  MicroHttpd>=0.9.40\n                  NFS>=3.0.0\n                  Pipewire>=0.3.50\n                  Plist\n                  PulseAudio>=11.0.0\n                  Python\n                  SmbClient\n                  Sndio\n                  UDEV\n                  Udfread\n                  XSLT\n                  ${PLATFORM_OPTIONAL_DEPS})\n\n# Remove excluded platform specific optional_deps\nforeach(excludedep ${PLATFORM_OPTIONAL_DEPS_EXCLUDE})\n  list(FILTER optional_deps EXCLUDE REGEX ${excludedep})\nendforeach()\n\n# Check optional deps first, since their availability can influence required ones, e.g. ffmpeg\ncore_optional_dep(${optional_deps})\ncore_require_dep(${required_deps})\n\nif(ENABLE_MARIADBCLIENT AND NOT ENABLE_MARIADBCLIENT STREQUAL AUTO AND ENABLE_MYSQLCLIENT AND NOT ENABLE_MYSQLCLIENT STREQUAL AUTO)\n  MESSAGE(FATAL_ERROR \"You can not use MySql and MariaDB at the same time. Disable one by adding -DENABLE_MYSQLCLIENT=OFF or -DENABLE_MARIADBCLIENT=OFF.\")\nelseif(ENABLE_MYSQLCLIENT AND NOT ENABLE_MYSQLCLIENT STREQUAL AUTO)\n  set(ENABLE_MARIADBCLIENT OFF CACHE BOOL \"\")\nendif()\n\ncore_optional_dep(MariaDBClient)\nif(NOT TARGET ${APP_NAME_LC}::MariaDBClient)\n  core_optional_dep(MySqlClient)\nendif()\n\nif(NOT TARGET ${APP_NAME_LC}::UDEV)\n  core_optional_dep(LibUSB)\nendif()\n\nif(ENABLE_UPNP)\n  list(APPEND DEP_DEFINES \"-DHAS_UPNP=1\")\nendif()\n\nif(ENABLE_OPTICAL)\n  list(APPEND DEP_DEFINES -DHAS_OPTICAL_DRIVE -DHAS_CDDA_RIPPER)\nendif()\n\nif(ENABLE_AIRTUNES)\n  find_package(Shairplay)\n  if(TARGET ${APP_NAME_LC}::Shairplay)\n    core_require_dep(Shairplay)\n  endif()\nendif()\n\n# We unset this after the bulk of our find calls are complete. Ideally we would want this enabled\n# for anything that is build target related, and only remove for native buildtools, however\n# thats more complicated for the need right now.\nif(NATIVEPREFIX)\n  unset(CMAKE_IGNORE_PREFIX_PATH)\nendif()\n\n# find all folders containing addon.xml.in\n# used to define ADDON_XML_OUTPUTS, ADDON_XML_DEPENDS and ADDON_INSTALL_DATA\n# Function defined in ./cmake/scripts/common/Macros.cmake\nset(outputFilterRegex \"addons/xbmc.json\")\nfind_addon_xml_in_files(${outputFilterRegex})\n\nif(TARGET ${APP_NAME_LC}::Alsa AND TARGET ${APP_NAME_LC}::PulseAudio)\n  list(APPEND AUDIO_BACKENDS_LIST \"alsa+pulseaudio\")\nendif()\n\n# Compile Info\nadd_custom_command(OUTPUT ${CORE_BUILD_DIR}/xbmc/CompileInfo.cpp\n                   COMMAND ${CMAKE_COMMAND} -DCORE_SOURCE_DIR=${CMAKE_SOURCE_DIR}\n                                            -DCORE_SYSTEM_NAME=${CORE_SYSTEM_NAME}\n                                            -DCORE_PLATFORM_NAME_LC=\"${CORE_PLATFORM_NAME_LC}\"\n                                            -DAUDIO_BACKENDS=\"${AUDIO_BACKENDS_LIST}\"\n                                            -DGL_INTERFACES=\"${GL_INTERFACES_LIST}\"\n                                            -DCORE_BUILD_DIR=${CORE_BUILD_DIR}\n                                            -DCMAKE_BINARY_DIR=${CMAKE_BINARY_DIR}\n                                            -DARCH_DEFINES=\"${ARCH_DEFINES}\"\n                                            -DAPP_SCMID=${APP_SCMID}\n                                            -DAPP_COPYRIGHT_YEARS=${APP_COPYRIGHT_YEARS}\n                                            -DAPP_BUILD_DATE=${APP_BUILD_DATE}\n                                            -DAPP_SHARED_LIBRARY_SUFFIX=\"${APP_SHARED_LIBRARY_SUFFIX}\"\n                                            -DPYTHON_VERSION=${PYTHON_VERSION}\n                                            -Dprefix=${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}\n                                            -DKODI_WEBSERVER_EXTRA_WHITELIST=\"${KODI_WEBSERVER_EXTRA_WHITELIST}\"\n                                            -P ${CMAKE_SOURCE_DIR}/cmake/scripts/common/GenerateCompileInfo.cmake\n                   DEPENDS ${CMAKE_SOURCE_DIR}/version.txt\n                           ${CMAKE_SOURCE_DIR}/xbmc/CompileInfo.cpp.in)\nlist(APPEND install_data ${ADDON_INSTALL_DATA})\nadd_library(compileinfo OBJECT ${CORE_BUILD_DIR}/xbmc/CompileInfo.cpp)\nset_target_properties(compileinfo PROPERTIES FOLDER \"Build Utilities\")\ntarget_compile_options(compileinfo PRIVATE ${SYSTEM_DEFINES} ${ARCH_DEFINES})\ntarget_link_libraries(compileinfo PRIVATE ${APP_NAME_LC}::Fmt)\n\nif(NOT MSVC)\n  target_compile_options(compileinfo PUBLIC ${CORE_COMPILE_OPTIONS})\nendif()\n\n# RC File\nif(WIN32)\n  configure_file(${CMAKE_SOURCE_DIR}/xbmc/platform/win32/XBMC_PC.rc.in\n                 ${CORE_BUILD_DIR}/xbmc/platform/win32/XBMC_PC.rc @ONLY)\n  add_library(resources OBJECT ${CORE_BUILD_DIR}/xbmc/platform/win32/XBMC_PC.rc)\n  set_target_properties(resources PROPERTIES FOLDER \"Build Utilities\")\n  target_include_directories(resources PRIVATE ${CMAKE_SOURCE_DIR}/tools/windows/packaging/media)\n  set(RESOURCES $<TARGET_OBJECTS:resources>)\nendif()\n\n# Generate messages\ncore_add_subdirs_from_filelist(${CMAKE_SOURCE_DIR}/cmake/messages/flatbuffers/*.txt)\n\ninclude_directories(${INCLUDES})\nadd_compile_options(${ARCH_DEFINES} \"${SYSTEM_DEFINES}\" ${DEP_DEFINES} ${PATH_DEFINES})\n\nset(core_DEPENDS \"\" CACHE STRING \"\" FORCE)\nset(test_archives \"\" CACHE STRING \"\" FORCE)\nset(test_sources \"\" CACHE STRING \"\" FORCE)\nmark_as_advanced(core_DEPENDS)\nmark_as_advanced(test_archives)\nmark_as_advanced(test_sources)\n\n# copy files to build tree\ncopy_files_from_filelist_to_buildtree(${CMAKE_SOURCE_DIR}/cmake/installdata/common/*.txt\n                                      ${CMAKE_SOURCE_DIR}/cmake/installdata/${CORE_SYSTEM_NAME}/*.txt)\n\nlist(APPEND SKINS \"${CMAKE_SOURCE_DIR}/addons/skin.estuary\\;${CMAKE_SOURCE_DIR}\")\n\nif(NOT ${CORE_SYSTEM_NAME} MATCHES \"windows\")\n  file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/system/players/VideoPlayer)\nendif()\n\nif(NOT CORE_SYSTEM_NAME STREQUAL windows AND NOT CORE_SYSTEM_NAME STREQUAL android AND NOT CORE_SYSTEM_NAME STREQUAL windowsstore)\n  configure_file(${CMAKE_SOURCE_DIR}/xbmc/DllPaths_generated.h.in\n                 ${CORE_BUILD_DIR}/DllPaths_generated.h @ONLY)\nelseif(CORE_SYSTEM_NAME STREQUAL android)\n  configure_file(${CMAKE_SOURCE_DIR}/xbmc/DllPaths_generated_android.h.in\n                 ${CORE_BUILD_DIR}/DllPaths_generated_android.h @ONLY)\nendif()\n\n# main library (used for main binary and tests)\nif(CORE_SYSTEM_NAME STREQUAL \"darwin_embedded\")\n  # $<TARGET_OBJECTS:> as at 3.26.4 provides incorrect paths for ios/tvos platforms\n  # Even if XCODE_EMIT_EFFECTIVE_PLATFORM_NAME global property is used, the xcode project\n  # still sets int dir paths to $(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME) and the generator\n  # expression only provides a path using $(CONFIGURATION)\n  add_library(compileinfo_obj OBJECT IMPORTED)\n  set_property(TARGET compileinfo_obj PROPERTY IMPORTED_OBJECTS\n    \"${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}/compileinfo.build/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)/$(OBJECT_FILE_DIR_normal:base)/$(CURRENT_ARCH)/CompileInfo.o\"\n  )\n  add_library(lib${APP_NAME_LC} STATIC)\n  add_dependencies(lib${APP_NAME_LC} compileinfo)\n  target_link_libraries(lib${APP_NAME_LC} PUBLIC compileinfo_obj)\nelse()\n  add_library(lib${APP_NAME_LC} STATIC $<TARGET_OBJECTS:compileinfo>)\nendif()\nset_target_properties(lib${APP_NAME_LC} PROPERTIES PREFIX \"\")\n\n# Other files (IDE)\nset(OTHER_FILES cmake/README.md)\n\n# Subdirs\nforeach(CORE_PLATFORM_LC ${CORE_PLATFORM_NAME_LC})\n  core_add_subdirs_from_filelist(${CMAKE_SOURCE_DIR}/cmake/treedata/common/${CORE_PLATFORM_LC}/*.txt\n                                 ${CMAKE_SOURCE_DIR}/cmake/treedata/${CORE_SYSTEM_NAME}/${CORE_PLATFORM_LC}/*.txt)\nendforeach()\n\ncore_add_subdirs_from_filelist(${CMAKE_SOURCE_DIR}/cmake/treedata/common/*.txt\n                               ${CMAKE_SOURCE_DIR}/cmake/treedata/${CORE_SYSTEM_NAME}/*.txt)\ncore_add_optional_subdirs_from_filelist(${CMAKE_SOURCE_DIR}/cmake/treedata/optional/common/*.txt\n                                        ${CMAKE_SOURCE_DIR}/cmake/treedata/optional/${CORE_SYSTEM_NAME}/*.txt)\n\n# core_DEPENDS: these are the artifact/object files of /xbmc/*\n# SYSTEM_LDFLAGS: system linker flags\n# DEPLIBS: system libraries for linking\ntarget_link_libraries(lib${APP_NAME_LC} PUBLIC ${core_DEPENDS} ${SYSTEM_LDFLAGS} ${DEPLIBS} ${CMAKE_DL_LIBS})\ncore_target_link_libraries(lib${APP_NAME_LC})\nset_target_properties(lib${APP_NAME_LC} PROPERTIES PROJECT_LABEL \"xbmc\")\nsource_group_by_folder(lib${APP_NAME_LC} RELATIVE ${CMAKE_SOURCE_DIR}/xbmc)\nif(WIN32)\n  add_precompiled_header(lib${APP_NAME_LC} pch.h ${CMAKE_SOURCE_DIR}/xbmc/platform/win32/pch.cpp)\nendif()\n\n# main binary\nif(NOT CORE_SYSTEM_NAME STREQUAL android)\n  if(CORE_SYSTEM_NAME STREQUAL windowsstore)\n    winstore_add_target_properties(${APP_NAME_LC})\n  endif()\n  add_executable(${APP_NAME_LC} ${CORE_MAIN_SOURCE} \"${RESOURCES}\" ${OTHER_FILES})\n  set_target_properties(${APP_NAME_LC} PROPERTIES ENABLE_EXPORTS ON)\nelse()\n  set(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} -Wl,--no-undefined\")\n  add_library(${APP_NAME_LC} SHARED ${CORE_MAIN_SOURCE} \"${RESOURCES}\" ${OTHER_FILES})\n\n  # Statically resolve global references to shared library (ie. ffmpeg) definitions.\n  # Related to https://stackoverflow.com/questions/46307266/including-objects-to-a-shared-library-from-a-c-archive-a\n  set_target_properties(${APP_NAME_LC} PROPERTIES LINK_FLAGS \"-Wl,-Bsymbolic\")\nendif()\nadd_dependencies(${APP_NAME_LC} ${APP_NAME_LC}-libraries)\n\nwhole_archive(_MAIN_LIBRARIES ${core_DEPENDS})\ntarget_link_libraries(${APP_NAME_LC} ${_MAIN_LIBRARIES} lib${APP_NAME_LC} ${DEPLIBS})\nunset(_MAIN_LIBRARIES)\n\nif(${CORE_SYSTEM_NAME} MATCHES \"windows\")\n  set(_bundle_dir $<TARGET_FILE_DIR:${APP_NAME_LC}>)\nelse()\n  set(_bundle_dir ${CMAKE_BINARY_DIR})\nendif()\n\n# These are skins that are copied into place from the source tree\nset(XBT_SOURCE_FILELIST \"\")\nforeach(skin ${SKINS})\n  list(GET skin 0 dir)\n  list(GET skin 1 relative)\n  copy_skin_to_buildtree(${dir} ${relative})\nendforeach()\n\n# Generate system addons\nadd_custom_target(gen_system_addons\n                    COMMAND ${CMAKE_COMMAND} -DCORE_SOURCE_DIR=${CMAKE_SOURCE_DIR}\n                                             -DCORE_SYSTEM_NAME=${CORE_SYSTEM_NAME}\n                                             -DCORE_PLATFORM_NAME_LC=\"${CORE_PLATFORM_NAME_LC}\"\n                                             -DCORE_BUILD_DIR=${CORE_BUILD_DIR}\n                                             -DCMAKE_BINARY_DIR=${CMAKE_BINARY_DIR}\n                                             -DBUNDLEDIR=${_bundle_dir}\n                                             -P ${CMAKE_SOURCE_DIR}/cmake/scripts/common/GenerateSystemAddons.cmake\n                    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR})\n\nif(_multiconfig_generator)\n  # Generator expressions in add_custom_command(OUTPUT) are only available in cmake 3.20+\n  # we dont really need config aware locations for a single config generator, so we only\n  # set this for multi config generators who all use newer cmake\n  set(CONFIG_VAR $<CONFIG>)\nendif()\n\n# Pack skins and copy to correct build dir (MultiConfig Generator aware)\nadd_custom_command(\n  OUTPUT ${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}/${CONFIG_VAR}/gen_skin.timestamp\n  COMMAND ${CMAKE_COMMAND} -DBUNDLEDIR=${_bundle_dir}\n                           -DTEXTUREPACKER_EXECUTABLE=$<TARGET_FILE:TexturePacker::TexturePacker::Executable>\n                           -P ${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}/GeneratedPackSkins.cmake\n  COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}/${CONFIG_VAR}\n  COMMAND ${CMAKE_COMMAND} -E touch ${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}/${CONFIG_VAR}/gen_skin.timestamp\n  DEPENDS ${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}/GeneratedPackSkins.cmake\n          ${XBT_SOURCE_FILELIST}\n  WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}\n  COMMENT \"Generating skin xbt\"\n)\nadd_custom_target(gen_skin_pack DEPENDS ${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}/${CONFIG_VAR}/gen_skin.timestamp)\n\n# Packaging target. This generates system addon, xbt creation, copy files to build tree\nadd_custom_target(generate-packaging ALL\n                  DEPENDS TexturePacker::TexturePacker::Executable export-files gen_skin_pack gen_system_addons)\n\ncore_target_add_dependencies(export-files)\n\n# Add to lib${APP_NAME_LC} solely for Win UWP. msix building doesnt seem to pick up the\n# generated buildtree if we do it later. Other platforms dont care when this happens.\nadd_dependencies(lib${APP_NAME_LC} generate-packaging)\n\nset_target_properties(generate-packaging PROPERTIES FOLDER \"Build Utilities\")\n\nif(WIN32)\n  set_target_properties(${APP_NAME_LC} PROPERTIES WIN32_EXECUTABLE ON)\n  set_property(DIRECTORY PROPERTY VS_STARTUP_PROJECT ${APP_NAME_LC})\n  if(NOT CORE_SYSTEM_NAME STREQUAL windowsstore)\n    target_sources(${APP_NAME_LC} PRIVATE ${CMAKE_SOURCE_DIR}/xbmc/platform/win32/app.manifest)\n  else()\n    set_target_properties(${APP_NAME_LC} PROPERTIES VS_USER_PROPS ${VCPROJECT_PROPS_FILE}\n                          VS_WINDOWS_TARGET_PLATFORM_MIN_VERSION ${VS_MINIMUM_SDK_VERSION})\n  endif()\nelseif(CORE_SYSTEM_NAME STREQUAL android)\n  # Nothing\nelseif(CORE_SYSTEM_NAME STREQUAL darwin_embedded OR CORE_SYSTEM_NAME STREQUAL osx)\n  # Build all apple app target as bundled and dont sign.\n  # We do all signing post build of the app target manually\n  set_target_properties(${APP_NAME_LC} PROPERTIES OUTPUT_NAME ${APP_NAME}\n                                                  MACOSX_BUNDLE YES\n                                                  MACOSX_BUNDLE_INFO_PLIST ${PLATFORM_BUNDLE_INFO_PLIST}\n                                                  XCODE_ATTRIBUTE_CODE_SIGNING_REQUIRED \"NO\"\n                                                  XCODE_ATTRIBUTE_CODE_SIGN_IDENTITY \"\")\nelse()\n  set_target_properties(${APP_NAME_LC} PROPERTIES SUFFIX ${APP_BINARY_SUFFIX})\nendif()\n\n# testing\nif(HOST_CAN_EXECUTE_TARGET AND ENABLE_TESTING)\n  find_package(Gtest 1.10.0 REQUIRED)\n\n  copy_files_from_filelist_to_buildtree(${CMAKE_SOURCE_DIR}/cmake/installdata/test-reference-data.txt NO_INSTALL)\n  add_executable(${APP_NAME_LC}-test EXCLUDE_FROM_ALL ${CMAKE_SOURCE_DIR}/xbmc/test/xbmc-test.cpp ${test_sources})\n\n  set_target_properties(PROPERTIES ENABLE_EXPORTS ON)\n\n  whole_archive(_TEST_LIBRARIES ${core_DEPENDS} ${GTEST_LIBRARY})\n  target_link_libraries(${APP_NAME_LC}-test PRIVATE ${SYSTEM_LDFLAGS} ${_TEST_LIBRARIES} lib${APP_NAME_LC} ${DEPLIBS} ${CMAKE_DL_LIBS})\n  unset(_TEST_LIBRARIES)\n\n  if (ENABLE_INTERNAL_GTEST)\n    add_dependencies(${APP_NAME_LC}-test ${APP_NAME_LC}-libraries generate-packaging gtest)\n  endif()\n\n  # Enable unit-test related targets\n  enable_testing()\n  gtest_add_tests(${APP_NAME_LC}-test \"\" ${test_sources})\n  add_custom_target(check ${CMAKE_CTEST_COMMAND} WORKING_DIRECTORY ${PROJECT_BINARY_DIR})\n  add_dependencies(check ${APP_NAME_LC}-test)\n\n  # Valgrind (memcheck)\n  find_program(VALGRIND_EXECUTABLE NAMES valgrind)\n  if(VALGRIND_EXECUTABLE)\n    set(CTEST_MEMORYCHECK_COMMAND ${VALGRIND_EXECUTABLE})\n    set(CTEST_MEMORYCHECK_COMMAND_OPTIONS \"-q --trace-children=yes --leak-check=yes --track-origins=yes\")\n    include(CTest)\n    add_custom_target(check-valgrind ${CMAKE_CTEST_COMMAND} -D ExperimentalMemCheck \\${ARGS} WORKING_DIRECTORY ${PROJECT_BINARY_DIR})\n    add_dependencies(check-valgrind ${APP_NAME_LC}-test)\n  endif()\n\n  # For testing commit series\n  add_custom_target(check-commits ${CMAKE_COMMAND} -P ${CMAKE_SOURCE_DIR}/cmake/scripts/common/CheckCommits.cmake\n                                                   -DCMAKE_BINARY_DIR=${CMAKE_BINARY_DIR})\n  set_target_properties(check-commits PROPERTIES FOLDER \"Build Utilities\")\n\n  include(${CMAKE_SOURCE_DIR}/cmake/scripts/common/StaticAnalysis.cmake)\n\n  # code coverage\n  if(CMAKE_BUILD_TYPE STREQUAL Coverage)\n    if(EXISTS ${CMAKE_SOURCE_DIR}/cmake/scripts/${CORE_SYSTEM_NAME}/CodeCoverage.cmake)\n      include(${CMAKE_SOURCE_DIR}/cmake/scripts/${CORE_SYSTEM_NAME}/CodeCoverage.cmake)\n    else()\n      message(FATAL_ERROR \"Code coverage not (yet) implemented for platform ${CORE_SYSTEM_NAME}\")\n    endif()\n  endif()\nendif()\n\n# Documentation\nfind_package(Doxygen)\nif(DOXYGEN_FOUND)\n  add_custom_target(doc\n                    COMMAND ${DOXYGEN_EXECUTABLE} ${CMAKE_SOURCE_DIR}/docs/doxygen/Doxyfile.doxy\n                    COMMAND ${CMAKE_COMMAND} -E echo \"Documentation built to: file://${CMAKE_SOURCE_DIR}/docs/html/index.html\"\n                    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/docs/doxygen\n                    COMMENT \"Generating Doxygen documentation\" VERBATIM)\nendif()\n\n# link wrapper\nif(FFMPEG_LINK_EXECUTABLE)\n  set(CMAKE_CXX_LINK_EXECUTABLE \"${FFMPEG_LINK_EXECUTABLE}\")\nendif()\nif(FFMPEG_CREATE_SHARED_LIBRARY)\n  set(CMAKE_CXX_CREATE_SHARED_LIBRARY \"${FFMPEG_CREATE_SHARED_LIBRARY}\")\nendif()\n\n# Platform specific additional extra targets\nif(EXISTS ${CMAKE_SOURCE_DIR}/cmake/scripts/${CORE_SYSTEM_NAME}/ExtraTargets.cmake)\n  include(${CMAKE_SOURCE_DIR}/cmake/scripts/${CORE_SYSTEM_NAME}/ExtraTargets.cmake)\nendif()\n\ninclude(cmake/scripts/${CORE_SYSTEM_NAME}/Install.cmake)\n\n# Add uninstall target\nif(CMAKE_GENERATOR MATCHES Makefile)\n  add_custom_target(uninstall COMMAND ${CMAKE_COMMAND} -P ${CMAKE_SOURCE_DIR}/cmake/scripts/common/Uninstall.cmake)\n  set_target_properties(uninstall PROPERTIES FOLDER \"Build Utilities\")\nendif()\n\n# Create target that allows to build binary-addons.\n# Use make binary-addons ADDONS=\"visualization.spectrum\" to select the addons to build.\nif(CMAKE_GENERATOR STREQUAL \"Unix Makefiles\")\n  if(CMAKE_CROSSCOMPILING)\n    set(_cross_args CROSS_COMPILING=yes)\n  endif()\n  if(NOT CORE_SYSTEM_NAME STREQUAL android)\n    set(_prefix ${CMAKE_BINARY_DIR}/addons)\n    set(_extra \"CMAKE_EXTRA=-DPACKAGE_ZIP=ON\")\n  else()\n    set(_prefix ${CMAKE_INSTALL_PREFIX})\n  endif()\n  add_custom_target(binary-addons\n    COMMAND $(MAKE) -C ${CMAKE_SOURCE_DIR}/tools/depends/target/binary-addons clean\n    COMMAND $(MAKE) -C ${CMAKE_SOURCE_DIR}/tools/depends/target/binary-addons VERBOSE=1 V=99\n                    PREFIX=${_prefix} INSTALL_PREFIX=${_prefix} ${_cross_args} ${_extra})\n  unset(_cross_args)\n  unset(_prefix)\nendif()\n\n# Prepare add-on build env\ninclude(${CORE_SOURCE_DIR}/xbmc/addons/AddonBindings.cmake)\nfile(COPY ${CORE_ADDON_BINDINGS_FILES} ${CORE_ADDON_BINDINGS_DIRS}/\n     DESTINATION ${CORE_BUILD_DIR}/include/${APP_NAME_LC}\n     REGEX \".txt\" EXCLUDE)\n\nset(APP_LIB_DIR ${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}/lib/${APP_NAME_LC})\nset(APP_INCLUDE_DIR ${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}/include/${APP_NAME_LC})\nconfigure_file(${CMAKE_SOURCE_DIR}/cmake/KodiConfig.cmake.in\n               ${CORE_BUILD_DIR}/lib/${APP_NAME_LC}/${APP_NAME}Config.cmake @ONLY)\nconfigure_file(${CMAKE_SOURCE_DIR}/cmake/scripts/common/AddonHelpers.cmake\n               ${CORE_BUILD_DIR}/lib/${APP_NAME_LC}/AddonHelpers.cmake COPYONLY)\nconfigure_file(${CMAKE_SOURCE_DIR}/cmake/scripts/common/AddOptions.cmake\n               ${CORE_BUILD_DIR}/lib/${APP_NAME_LC}/AddOptions.cmake COPYONLY)\n\n# Status\nmessage(STATUS \"#---- CONFIGURATION ----#\")\nforeach(msg ${final_message})\n  message(STATUS ${msg})\nendforeach()\n\nif(VERBOSE)\n  message(STATUS \"\\n#--------------- Internal Variables -------------#\")\n  message(STATUS \"DEPLIBS: ${DEPLIBS}\")\n  message(STATUS \"core_DEPENDS: ${core_DEPENDS}\")\n  message(STATUS \"#---------------------------------------------#\")\n  message(STATUS \"SYSTEM_LDFLAGS        : ${SYSTEM_LDFLAGS}\")\n  message(STATUS \"CMAKE_DL_LIBS         : ${CMAKE_DL_LIBS}\")\n  message(STATUS \"CMAKE_C_FLAGS         : ${CMAKE_C_FLAGS}\")\n  message(STATUS \"CMAKE_CXX_FLAGS       : ${CMAKE_CXX_FLAGS}\")\n  message(STATUS \"CMAKE_EXE_LINKER_FLAGS: ${CMAKE_EXE_LINKER_FLAGS}\")\n  message(STATUS \"LTO_OPTIMIZATION      : ${CMAKE_INTERPROCEDURAL_OPTIMIZATION}\")\n  if(CMAKE_INTERPROCEDURAL_OPTIMIZATION)\n    message(STATUS \"CMAKE_CXX_COMPILE_OPTIONS_IPO: ${CMAKE_CXX_COMPILE_OPTIONS_IPO}\")\n    message(STATUS \"CMAKE_C_COMPILE_OPTIONS_IPO  : ${CMAKE_C_COMPILE_OPTIONS_IPO}\")\n    message(STATUS \"CMAKE_AR                     : ${CMAKE_AR}\")\n    message(STATUS \"CMAKE_NM                     : ${CMAKE_NM}\")\n    message(STATUS \"CMAKE_LINKER                 : ${CMAKE_LINKER}\")\n  endif()\n  message(STATUS \"#---------------------------------------------#\")\n  message(STATUS \"bindir     : ${bindir}\")\n  message(STATUS \"includedir : ${includedir}\")\n  message(STATUS \"libdir     : ${libdir}\")\n  message(STATUS \"datarootdir: ${datarootdir}\")\n  message(STATUS \"#---------------------------------------------#\")\n  message(STATUS \"BINARY: ${APP_NAME_LC}${APP_BINARY_SUFFIX}\")\n  message(STATUS \"#---------------------------------------------#\")\n  message(STATUS \"GIT_REV: ${APP_SCMID}\")\n  message(STATUS \"Build date: ${APP_BUILD_DATE}\")\n  message(STATUS \"#---------------------------------------------#\")\n  message(STATUS \"CPACK_GENERATOR       : ${CPACK_GENERATOR}\")\n  message(STATUS \"CPACK_SOURCE_GENERATOR: ${CPACK_SOURCE_GENERATOR}\")\n  message(STATUS \"#---------------------------------------------#\")\nendif()\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 0.283203125,
          "content": "Kodi is provided under\n\n    SPDX-License-Identifier: GPL-2.0-or-later\n\n\nBeing under the terms of the GNU General Public License v2.0 or later, according with\n\n    LICENSES/GPL-2.0-or-later\n\n\nIn addition, other licenses may also apply. Please see\n\n    LICENSES/README.md\n\nfor more details.\n\n"
        },
        {
          "name": "LICENSES",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.919921875,
          "content": "![Kodi Logo](docs/resources/banner.png)\n\n<p align=\"center\">\n  <strong>\n    <a href=\"https://kodi.tv/\">website</a>\n    •\n    <a href=\"https://kodi.wiki/view/Main_Page\">docs</a>\n    •\n    <a href=\"https://forum.kodi.tv/\">community</a>\n    •\n    <a href=\"https://kodi.tv/addons\">add-ons</a>\n  </strong>\n</p>\n\n<p align=\"center\">\n  <a href=\"LICENSE.md\"><img alt=\"License\" src=\"https://img.shields.io/badge/license-GPLv2-blue.svg?style=flat-square\"></a>\n  <a href=\"https://docs.kodi.tv/\"><img alt=\"Documentation\" src=\"https://img.shields.io/badge/code-documented-brightgreen.svg?style=flat-square\"></a>\n  <a href=\"https://github.com/xbmc/xbmc/pulls\"><img alt=\"PRs Welcome\" src=\"https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square\"></a>\n  <a href=\"#how-to-contribute\"><img alt=\"Contributions Welcome\" src=\"https://img.shields.io/badge/contributions-welcome-brightgreen.svg?style=flat-square\"></a>\n  <a href=\"http://jenkins.kodi.tv/\"><img alt=\"Build\" src=\"https://img.shields.io/badge/CI-jenkins-brightgreen.svg?style=flat-square\"></a>\n  <a href=\"https://github.com/xbmc/xbmc/commits/master\"><img alt=\"Commits\" src=\"https://img.shields.io/github/commits-since/xbmc/xbmc/latest.svg?style=flat-square\"></a>\n</p>\n\n<a href=\"https://play.google.com/store/apps/details?id=org.xbmc.kodi\" target=\"_blank\">\n  <img src=\"https://play.google.com/intl/en_us/badges/images/generic/en-play-badge.png\" height=\"80\"/>\n</a>\n\n<h1 align=\"center\">\n  Welcome to Kodi Home Theater Software!\n</h1>\n\nKodi is an award-winning **free and open source** software media player and entertainment hub for digital media. Available as a native application for **Android, Linux, BSD, macOS, iOS, tvOS and Windows operating systems**, Kodi runs on most common processor architectures.\n\nCreated in 2003 by a group of like minded programmers, Kodi is a non-profit project run by the XBMC Foundation and developed by volunteers located around the world. More than 500 software developers have contributed to Kodi to date, and 100-plus translators have worked to expand its reach, making it available in more than 70 languages.\n\nWhile Kodi functions very well as a standard media player application for your computer, it has been designed to be the perfect companion for your HTPC. With its **beautiful interface and powerful skinning engine**, Kodi feels very natural to use from the couch with a remote control and is the ideal solution for your home theater.\n\n## Give your media the love it deserves\nKodi can be used to play almost all popular audio and video formats around. It was designed for network playback, so you can stream your multimedia from anywhere in the house or directly from the internet using practically any protocol available.\n\nPoint Kodi to your media and watch it **scan and automagically create a personalized library** complete with box covers, descriptions, and fanart. There are playlist and slideshow functions, a weather forecast feature and many audio visualizations. Once installed, your computer or HTPC will become a fully functional multimedia jukebox.\n\n<p align=\"center\">\n  <img src=\"docs/resources/kodi.gif\" alt=\"Kodi\">\n</p>\n\n## Getting Started\nKodi's developers work hard to make it support a large range of devices and operating systems. We provide final as well as development builds. To get started, head over to the **[downloads section](https://kodi.tv/download)** and simply select the platform that you want to install it on. A **[quick start guide](https://kodi.wiki/view/quick_start_guide)** to help you get acquainted with Kodi is available in our wiki.\n\n## How to Contribute\nKodi is created by users for users and **we welcome every contribution**. There are no highly paid developers or poorly paid support personnel on the phones ready to take your call. There are only users who have seen a problem and done their best to fix it. This means Kodi will always need the contributions of users like you. How can you get involved?\n\n* **Coding:** Developers can help Kodi by **[fixing a bug](https://github.com/xbmc/xbmc/issues)**, adding new features, making our technology smaller and faster and making development easier for others. Kodi's codebase consists mainly of C++ with small parts written in a variety of coding languages. Our add-ons mainly consist of python and XML. For more information, please have a look at our **[contributing guide](docs/CONTRIBUTING.md)**.\n* **Helping users:** Our support process relies on enthusiastic contributors like you to help others get the most out of Kodi. The #1 priority is always answering questions in our **[support forums](https://forum.kodi.tv/)**. Everyday new people discover Kodi, and everyday they are virtually guaranteed to have questions.\n* **Localization:** Translate **[Kodi](https://kodi.weblate.cloud/projects/kodi-core/kodi-main/)**, **[add-ons, skins etc.](https://kodi.weblate.cloud/)** into your native language.\n* **Add-ons:** **[Add-ons](https://kodi.tv/addons)** are what make Kodi the most extensible and customizable entertainment hub available. **[Get started building an add-on](https://kodi.tv/create-an-addon)**.\n* **Documentation:** Kodi's **[wiki pages](https://kodi.wiki/)** are the hub for information about Kodi and surrounding ecosystem. Help make our documentation better by writing new content or correcting existing material.\n\n**Not enough free time?** No problem! There are other ways to help Kodi.\n\n* **Spread the word:** Share Kodi with the world! Tell your friends and family about how Kodi creates an amazing entertainment experience. Stay up to date on the latest stories about Kodi reading our **[news](https://kodi.tv/blog)** section, follow us on **[Twitter](https://twitter.com/koditv)** and **[Facebook](https://www.facebook.com/XBMC/)**, or **star Kodi's repo** if you want to follow development.\n* **Donate:** We are always happy to receive a **[donation](https://kodi.tv/contribute/donate)**. Donations are typically used for travel to attend conferences, any necessary paperwork and legal fees, and the yearly XBMC Foundation Developers Conference, where a great deal of coding and planning for the following year occurs. Donations may also be used to purchase necessary hardware and licenses for developers, along with t-shirts, stickers, and other accessories for conferences.\n* **Buy Kodi merchandise:** Purchasing Kodi gear helps just as much as a donation, and you get something in return! Checkout our **[store](https://kodi.tv/store)** for Kodi branded gear. We regularly add new products so check back often.\n\n## Building\nKodi uses CMake as its building system but instructions are highly dependent on your operating system and target platform. Fortunately **[we've got you covered](docs/README.md)**.\n\n## Acknowledgements\nKodi couldn't exist without\n\n* All the **[contributors](https://github.com/xbmc/xbmc/graphs/contributors)**. Big or small a change, it does make a difference.\n* All the developers that write the fantastic **software and libraries** that Kodi uses. We stand on the shoulders of giants.\n* Our **[fantastic community](https://forum.kodi.tv/)** for the never ending support, inspiration, feedback, and for keeping us on our toes when we screw up!\n* **[Our sponsors](https://kodi.tv/sponsors)**. Without them, keeping a huge project like this alive would be next to impossible.\n\n## License\nKodi is **[GPLv2 licensed](LICENSE.md)**. You may use, distribute and copy it under the license terms.\n\n<a href=\"https://github.com/xbmc/xbmc/graphs/contributors\"><img src=\"https://forthebadge.com/images/badges/built-by-developers.svg\" height=\"25\"></a>\n<a href=\"https://github.com/xbmc/xbmc\"><img src=\"https://forthebadge.com/images/badges/certified-cousin-terio.svg\" height=\"25\"></a>\n<a href=\"https://github.com/xbmc/xbmc\"><img src=\"https://forthebadge.com/images/badges/approved-by-george-costanza.svg\" height=\"25\"></a>\n<a href=\"https://kodi.tv/download\"><img src=\"https://forthebadge.com/images/badges/check-it-out.svg\" height=\"25\"></a>\n<a href=\"https://github.com/xbmc/xbmc\"><img src=\"https://forthebadge.com/images/badges/winter-is-coming.svg\" height=\"25\"></a>\n"
        },
        {
          "name": "addons",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "media",
          "type": "tree",
          "content": null
        },
        {
          "name": "privacy-policy.txt",
          "type": "blob",
          "size": 5.015625,
          "content": "[B]Kodi Privacy Policy[/B]\n[I]2016 Oct 23[/I]\n\nYour privacy is an important factor that the XBMC Foundation and Team Kodi considers in the development of all of our software and services. We are committed to being transparent and open. This Privacy Policy explains generally how we receive information about you, and what we do with that information once we have it.\n\n\n[B]What do we mean by “personal information?”[/B]\n\nFor us, “personal information” means information which identifies you, like your name or email address.\n\nAny information that falls outside of this is “non-personal information.”\n\nIf we store your personal information with information that is non-personal, we will consider the combination as personal information. If we remove all personal information from a set of data then the remaining is non-personal information.\n\n\n[B]How do we learn information about you?[/B]\n\nWe learn information about you when:\n\n    • you give it to us directly (e.g., when you choose to send us logs in the forums);\n    • we collect it automatically through our software and services (e.g., when your Kodi connects with our servers to update add-ons, or in download statistics provided by Google Play);\n    • when we try and understand more about you based on information you’ve given to us (e.g., when we use your platform information provided to the add-on server to figure out which platforms use Kodi the most, to better understand where we should focus our efforts).\n\n\n[B]What do we do with your information once we have it?[/B]\n\nGenerally, we use your information to help us provide and improve our software and services for you (e.g., we use a log you send us to figure out why Kodi isn’t playing a video right or why it might have crashed, or we determine how many active users are using each platform in order to determine how to allocate resources per platform).\n\n\n[B]When do we share your information with others?[/B]\n\n    • When we have asked and received your permission to share it.\n    • When we are fulfilling our educational purpose. We sometimes publicly release information to make our software better and foster an open web, but when we do so, we will remove your personal information and try to disclose it in a way that minimizes the risk of you being re-identified. For example, in a blog post we might attempt to analyze from available data how many active users of Kodi existed at the time and share that info with the community.\n    • When the law requires it. To date, this has never happened, and we do not anticipate it happening in the future, as the majority of the information we collect is already almost entirely anonymous and never shows unique user behavior, except in voluntarily submitted logs on our forum.\n    • If our organizational structure or status changes (if we undergo a restructuring, are acquired, or go bankrupt) we may pass your information to a successor or affiliate.\n\n\n[B]How do we store and protect your personal information?[/B]\n\nWe are committed to protecting your personal information once we have it. We implement physical, business and technical security measures. Despite our efforts, if we learn of a security breach, we’ll notify you so that you can take appropriate protective steps.\n\nWe also don’t want your personal information for any longer than we need it, so we only keep it long enough to do what we collected it for. Once we don’t need it, we take steps to destroy it unless we are required by law to keep it longer. In the case of logs provided to us in the forums, our servers do not store those logs, and we rely on the users submitting those logs to remove the links when they deem appropriate.\n\n\n[B]What else should you know?[/B]\n\nWe’re a global organization and our computers are in several different places around the world. We also use service providers whose computers may also be in various countries. This means that your information might end up on one of those computers in another country, and that country may have a different level of data protection regulation than yours. By giving us information, you consent to this kind of transfer of your information. No matter what country your information is in, we comply with applicable law and will also abide by the commitments we make in this privacy policy.\n\nIf you are under 13, we don’t want your personal information, and you must not provide it to us. If you are a parent and believe that your child who is under 13 has provided us with personal information, please contact us to have your child’s information removed.\n\n\n[B]What if we change this privacy policy or any of our privacy notices?[/B]\n\nWe may need to change this policy and our notices. The updates will be posted online. If the changes are substantive, we will announce the update through Kodi’s usual channels for such announcements such as blog posts and forums. Your continued use of the product or service after the effective date of such changes constitutes your acceptance of such changes. To make your review more convenient, we will post an effective date at the top of the page.\n\n"
        },
        {
          "name": "project",
          "type": "tree",
          "content": null
        },
        {
          "name": "system",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "userdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "version.txt",
          "type": "blob",
          "size": 0.5966796875,
          "content": "APP_NAME Kodi\nCOMPANY_NAME XBMC Foundation\nDEV_NAME Team Kodi\nABOUT_WEBSITE https://kodi.tv/about/\nFORUM_WEBSITE https://forum.kodi.tv/\nDOCS_WEBSITE https://kodi.wiki/\nCOPYRIGHT_YEARS 2005-2021\nWEBSITE http://kodi.tv\nVERSION_MAJOR 22\nVERSION_MINOR 0\nVERSION_TAG ALPHA1\nVERSION_CODE 21.90.700\nADDON_API 21.90.700\nADDON_REPOS repository.xbmc.org|https://mirrors.kodi.tv\nAPP_PACKAGE org.xbmc.kodi\nPACKAGE_IDENTITY XBMCFoundation.Kodi\nPACKAGE_PUBLISHER C62BD90A-CDD8-477F-96C3-B25992247B97\nPACKAGE_DESCRIPTION Kodi is an open source (GPL) software media center for playing videos, music, pictures, games, and more.\n"
        },
        {
          "name": "xbmc-xrandr.c",
          "type": "blob",
          "size": 91.548828125,
          "content": "/*\n * Copyright © 2001 Keith Packard, member of The XFree86 Project, Inc.\n * Copyright © 2002 Hewlett Packard Company, Inc.\n * Copyright © 2006 Intel Corporation\n *\n * Permission to use, copy, modify, distribute, and sell this software and its\n * documentation for any purpose is hereby granted without fee, provided that\n * the above copyright notice appear in all copies and that both that copyright\n * notice and this permission notice appear in supporting documentation, and\n * that the name of the copyright holders not be used in advertising or\n * publicity pertaining to distribution of the software without specific,\n * written prior permission.  The copyright holders make no representations\n * about the suitability of this software for any purpose.  It is provided \"as\n * is\" without express or implied warranty.\n *\n * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE\n * OF THIS SOFTWARE.\n *\n * Thanks to Jim Gettys who wrote most of the client side code,\n * and part of the server code for randr.\n */\n\n#include <math.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <X11/Xatom.h>\n#include <X11/Xlib.h>\n#include <X11/Xlibint.h>\n#include <X11/Xproto.h>\n#include <X11/extensions/Xrandr.h>\n#include <X11/extensions/Xrender.h> /* we share subpixel information */\n#include <strings.h>\n\n#ifndef _X_NORETURN\n#if defined(__GNUC__) && ((__GNUC__ * 100 + __GNUC_MINOR__) >= 205)\n#define _X_NORETURN __attribute((noreturn))\n#else\n#define _X_NORETURN\n#endif\n#endif\n\nstatic char* program_name;\nstatic Display* dpy;\nstatic Window root;\nstatic int screen = -1;\nstatic Bool verbose = False;\nstatic Bool automatic = False;\nstatic Bool properties = False;\nstatic Bool grab_server = True;\nstatic Bool no_primary = False;\n\nstatic char* direction[5] = {\"normal\", \"left\", \"inverted\", \"right\", \"\\n\"};\n\nstatic char* reflections[5] = {\"normal\", \"x\", \"y\", \"xy\", \"\\n\"};\n\n/* subpixel order */\nstatic char* order[6] = {\"unknown\",      \"horizontal rgb\", \"horizontal bgr\",\n                         \"vertical rgb\", \"vertical bgr\",   \"no subpixels\"};\n\nstatic const struct\n{\n  char* string;\n  unsigned long flag;\n} mode_flags[] = {{\"+HSync\", RR_HSyncPositive}, {\"-HSync\", RR_HSyncNegative},\n                  {\"+VSync\", RR_VSyncPositive}, {\"-VSync\", RR_VSyncNegative},\n                  {\"Interlace\", RR_Interlace},  {\"DoubleScan\", RR_DoubleScan},\n                  {\"CSync\", RR_CSync},          {\"+CSync\", RR_CSyncPositive},\n                  {\"-CSync\", RR_CSyncNegative}, {NULL, 0}};\n\nstatic void _X_NORETURN usage(void)\n{\n  fprintf(stderr, \"usage: %s [options]\\n\", program_name);\n  fprintf(stderr, \"  where options are:\\n\");\n  fprintf(stderr, \"  -display <display> or -d <display>\\n\");\n  fprintf(stderr, \"  -help\\n\");\n  fprintf(stderr, \"  -o <normal,inverted,left,right,0,1,2,3>\\n\");\n  fprintf(stderr, \"            or --orientation <normal,inverted,left,right,0,1,2,3>\\n\");\n  fprintf(stderr, \"  -q        or --query\\n\");\n  fprintf(stderr, \"  -s <size>/<width>x<height> or --size <size>/<width>x<height>\\n\");\n  fprintf(stderr, \"  -r <rate> or --rate <rate> or --refresh <rate>\\n\");\n  fprintf(stderr, \"  -v        or --version\\n\");\n  fprintf(stderr, \"  -x        (reflect in x)\\n\");\n  fprintf(stderr, \"  -y        (reflect in y)\\n\");\n  fprintf(stderr, \"  --screen <screen>\\n\");\n  fprintf(stderr, \"  --verbose\\n\");\n  fprintf(stderr, \"  --current\\n\");\n  fprintf(stderr, \"  --dryrun\\n\");\n  fprintf(stderr, \"  --nograb\\n\");\n  fprintf(stderr, \"  --prop or --properties\\n\");\n  fprintf(stderr, \"  --fb <width>x<height>\\n\");\n  fprintf(stderr, \"  --fbmm <width>x<height>\\n\");\n  fprintf(stderr, \"  --dpi <dpi>/<output>\\n\");\n  fprintf(stderr, \"  --output <output>\\n\");\n  fprintf(stderr, \"      --auto\\n\");\n  fprintf(stderr, \"      --mode <mode>\\n\");\n  fprintf(stderr, \"      --preferred\\n\");\n  fprintf(stderr, \"      --pos <x>x<y>\\n\");\n  fprintf(stderr, \"      --rate <rate> or --refresh <rate>\\n\");\n  fprintf(stderr, \"      --reflect normal,x,y,xy\\n\");\n  fprintf(stderr, \"      --rotate normal,inverted,left,right\\n\");\n  fprintf(stderr, \"      --left-of <output>\\n\");\n  fprintf(stderr, \"      --right-of <output>\\n\");\n  fprintf(stderr, \"      --above <output>\\n\");\n  fprintf(stderr, \"      --below <output>\\n\");\n  fprintf(stderr, \"      --same-as <output>\\n\");\n  fprintf(stderr, \"      --set <property> <value>\\n\");\n  fprintf(stderr, \"      --scale <x>x<y>\\n\");\n  fprintf(stderr, \"      --scale-from <w>x<h>\\n\");\n  fprintf(stderr, \"      --transform <a>,<b>,<c>,<d>,<e>,<f>,<g>,<h>,<i>\\n\");\n  fprintf(stderr, \"      --off\\n\");\n  fprintf(stderr, \"      --crtc <crtc>\\n\");\n  fprintf(stderr,\n          \"      --panning <w>x<h>[+<x>+<y>[/<track:w>x<h>+<x>+<y>[/<border:l>/<t>/<r>/<b>]]]\\n\");\n  fprintf(stderr, \"      --gamma <r>:<g>:<b>\\n\");\n  fprintf(stderr, \"      --primary\\n\");\n  fprintf(stderr, \"  --noprimary\\n\");\n  fprintf(stderr, \"  --newmode <name> <clock MHz>\\n\");\n  fprintf(stderr, \"            <hdisp> <hsync-start> <hsync-end> <htotal>\\n\");\n  fprintf(stderr, \"            <vdisp> <vsync-start> <vsync-end> <vtotal>\\n\");\n  fprintf(stderr, \"            [flags...]\\n\");\n  fprintf(stderr, \"            Valid flags: +HSync -HSync +VSync -VSync\\n\");\n  fprintf(stderr, \"                         +CSync -CSync CSync Interlace DoubleScan\\n\");\n  fprintf(stderr, \"  --rmmode <name>\\n\");\n  fprintf(stderr, \"  --addmode <output> <name>\\n\");\n  fprintf(stderr, \"  --delmode <output> <name>\\n\");\n\n  exit(1);\n  /*NOTREACHED*/\n}\n\nstatic void _X_NORETURN fatal(const char* format, ...)\n{\n  va_list ap;\n\n  va_start(ap, format);\n  fprintf(stderr, \"%s: \", program_name);\n  vfprintf(stderr, format, ap);\n  va_end(ap);\n  exit(1);\n  /*NOTREACHED*/\n}\n\nstatic void warning(const char* format, ...)\n{\n  va_list ap;\n\n  va_start(ap, format);\n  fprintf(stderr, \"%s: \", program_name);\n  vfprintf(stderr, format, ap);\n  va_end(ap);\n}\n\nstatic char* rotation_name(Rotation rotation)\n{\n  int i;\n\n  if ((rotation & 0xf) == 0)\n    return \"normal\";\n  for (i = 0; i < 4; i++)\n    if (rotation & (1 << i))\n      return direction[i];\n  return \"invalid rotation\";\n}\n\nstatic char* reflection_name(Rotation rotation)\n{\n  rotation &= (RR_Reflect_X | RR_Reflect_Y);\n  switch (rotation)\n  {\n    case 0:\n      return \"none\";\n    case RR_Reflect_X:\n      return \"X axis\";\n    case RR_Reflect_Y:\n      return \"Y axis\";\n    case RR_Reflect_X | RR_Reflect_Y:\n      return \"X and Y axis\";\n  }\n  return \"invalid reflection\";\n}\n\ntypedef enum _relation\n{\n  relation_left_of,\n  relation_right_of,\n  relation_above,\n  relation_below,\n  relation_same_as,\n} relation_t;\n\ntypedef struct\n{\n  int x, y, width, height;\n} rectangle_t;\n\ntypedef struct\n{\n  int x1, y1, x2, y2;\n} box_t;\n\ntypedef struct\n{\n  int x, y;\n} point_t;\n\ntypedef enum _changes\n{\n  changes_none = 0,\n  changes_crtc = (1 << 0),\n  changes_mode = (1 << 1),\n  changes_relation = (1 << 2),\n  changes_position = (1 << 3),\n  changes_rotation = (1 << 4),\n  changes_reflection = (1 << 5),\n  changes_automatic = (1 << 6),\n  changes_refresh = (1 << 7),\n  changes_property = (1 << 8),\n  changes_transform = (1 << 9),\n  changes_panning = (1 << 10),\n  changes_gamma = (1 << 11),\n  changes_primary = (1 << 12),\n} changes_t;\n\ntypedef enum _name_kind\n{\n  name_none = 0,\n  name_string = (1 << 0),\n  name_xid = (1 << 1),\n  name_index = (1 << 2),\n  name_preferred = (1 << 3),\n} name_kind_t;\n\ntypedef struct\n{\n  name_kind_t kind;\n  char* string;\n  XID xid;\n  int index;\n} name_t;\n\ntypedef struct _crtc crtc_t;\ntypedef struct _output output_t;\ntypedef struct _transform transform_t;\ntypedef struct _umode umode_t;\ntypedef struct _output_prop output_prop_t;\n\nstruct _transform\n{\n  XTransform transform;\n  char* filter;\n  int nparams;\n  XFixed* params;\n};\n\nstruct _crtc\n{\n  name_t crtc;\n  Bool changing;\n  XRRCrtcInfo* crtc_info;\n\n  XRRModeInfo* mode_info;\n  XRRPanning* panning_info;\n  int x;\n  int y;\n  Rotation rotation;\n  output_t** outputs;\n  int noutput;\n  transform_t current_transform, pending_transform;\n};\n\nstruct _output_prop\n{\n  struct _output_prop* next;\n  char* name;\n  char* value;\n};\n\nstruct _output\n{\n  struct _output* next;\n\n  changes_t changes;\n\n  output_prop_t* props;\n\n  name_t output;\n  XRROutputInfo* output_info;\n\n  name_t crtc;\n  crtc_t* crtc_info;\n  crtc_t* current_crtc_info;\n\n  name_t mode;\n  double refresh;\n  XRRModeInfo* mode_info;\n\n  name_t addmode;\n\n  relation_t relation;\n  char* relative_to;\n\n  int x, y;\n  Rotation rotation;\n\n  XRRPanning panning;\n\n  Bool automatic;\n  int scale_from_w, scale_from_h;\n  transform_t transform;\n\n  struct\n  {\n    float red;\n    float green;\n    float blue;\n  } gamma;\n\n  float brightness;\n\n  Bool primary;\n\n  Bool found;\n};\n\ntypedef enum _umode_action\n{\n  umode_create,\n  umode_destroy,\n  umode_add,\n  umode_delete\n} umode_action_t;\n\n\nstruct _umode\n{\n  struct _umode* next;\n\n  umode_action_t action;\n  XRRModeInfo mode;\n  name_t output;\n  name_t name;\n};\n\n/*\n\nstatic char *connection[3] = {\n    \"connected\",\n    \"disconnected\",\n    \"unknown connection\"};\n\n*/\n\nstatic char* connection[3] = {\"true\", \"false\", \"unknown\"};\n\n#define OUTPUT_NAME 1\n\n#define CRTC_OFF 2\n#define CRTC_UNSET 3\n#define CRTC_INDEX 0x40000000\n\n#define MODE_NAME 1\n#define MODE_OFF 2\n#define MODE_UNSET 3\n#define MODE_PREF 4\n\n#define POS_UNSET -1\n\nstatic output_t* outputs = NULL;\nstatic output_t** outputs_tail = &outputs;\nstatic crtc_t* crtcs;\nstatic umode_t* umodes;\nstatic int num_crtcs;\nstatic XRRScreenResources* res;\nstatic int fb_width = 0, fb_height = 0;\nstatic int fb_width_mm = 0, fb_height_mm = 0;\nstatic double dpi = 0;\nstatic char* dpi_output = NULL;\nstatic Bool dryrun = False;\nstatic int minWidth, maxWidth, minHeight, maxHeight;\nstatic Bool has_1_2 = False;\nstatic Bool has_1_3 = False;\n\nstatic int mode_height(XRRModeInfo* mode_info, Rotation rotation)\n{\n  switch (rotation & 0xf)\n  {\n    case RR_Rotate_0:\n    case RR_Rotate_180:\n      return mode_info->height;\n    case RR_Rotate_90:\n    case RR_Rotate_270:\n      return mode_info->width;\n    default:\n      return 0;\n  }\n}\n\nstatic int mode_width(XRRModeInfo* mode_info, Rotation rotation)\n{\n  switch (rotation & 0xf)\n  {\n    case RR_Rotate_0:\n    case RR_Rotate_180:\n      return mode_info->width;\n    case RR_Rotate_90:\n    case RR_Rotate_270:\n      return mode_info->height;\n    default:\n      return 0;\n  }\n}\n\nstatic Bool transform_point(XTransform* transform, double* xp, double* yp)\n{\n  double vector[3];\n  double result[3];\n  int i, j;\n  double v;\n\n  vector[0] = *xp;\n  vector[1] = *yp;\n  vector[2] = 1;\n  for (j = 0; j < 3; j++)\n  {\n    v = 0;\n    for (i = 0; i < 3; i++)\n      v += (XFixedToDouble(transform->matrix[j][i]) * vector[i]);\n    result[j] = v;\n  }\n  if (!result[2])\n    return False;\n  for (j = 0; j < 2; j++)\n  {\n    vector[j] = result[j] / result[2];\n    if (vector[j] > 32767 || vector[j] < -32767)\n      return False;\n  }\n  *xp = vector[0];\n  *yp = vector[1];\n  return True;\n}\n\nstatic void path_bounds(XTransform* transform, point_t* points, int npoints, box_t* box)\n{\n  int i;\n  box_t point;\n\n  for (i = 0; i < npoints; i++)\n  {\n    double x, y;\n    x = points[i].x;\n    y = points[i].y;\n    transform_point(transform, &x, &y);\n    point.x1 = floor(x);\n    point.y1 = floor(y);\n    point.x2 = ceil(x);\n    point.y2 = ceil(y);\n    if (i == 0)\n      *box = point;\n    else\n    {\n      if (point.x1 < box->x1)\n        box->x1 = point.x1;\n      if (point.y1 < box->y1)\n        box->y1 = point.y1;\n      if (point.x2 > box->x2)\n        box->x2 = point.x2;\n      if (point.y2 > box->y2)\n        box->y2 = point.y2;\n    }\n  }\n}\n\nstatic void mode_geometry(XRRModeInfo* mode_info,\n                          Rotation rotation,\n                          XTransform* transform,\n                          box_t* bounds)\n{\n  point_t rect[4];\n  int width = mode_width(mode_info, rotation);\n  int height = mode_height(mode_info, rotation);\n\n  rect[0].x = 0;\n  rect[0].y = 0;\n  rect[1].x = width;\n  rect[1].y = 0;\n  rect[2].x = width;\n  rect[2].y = height;\n  rect[3].x = 0;\n  rect[3].y = height;\n  path_bounds(transform, rect, 4, bounds);\n}\n\n/* v refresh frequency in Hz */\nstatic double mode_refresh(XRRModeInfo* mode_info)\n{\n  double rate;\n\n  if (mode_info->hTotal && mode_info->vTotal)\n    rate = ((double)mode_info->dotClock / ((double)mode_info->hTotal * (double)mode_info->vTotal));\n  else\n    rate = 0;\n  return rate;\n}\n\n/* h sync frequency in Hz */\nstatic double mode_hsync(XRRModeInfo* mode_info)\n{\n  double rate;\n\n  if (mode_info->hTotal)\n    rate = (double)mode_info->dotClock / (double)mode_info->hTotal;\n  else\n    rate = 0;\n  return rate;\n}\n\nstatic void init_name(name_t* name)\n{\n  name->kind = name_none;\n}\n\nstatic void set_name_string(name_t* name, char* string)\n{\n  name->kind |= name_string;\n  name->string = string;\n}\n\nstatic void set_name_xid(name_t* name, XID xid)\n{\n  name->kind |= name_xid;\n  name->xid = xid;\n}\n\nstatic void set_name_index(name_t* name, int index)\n{\n  name->kind |= name_index;\n  name->index = index;\n}\n\nstatic void set_name_preferred(name_t* name)\n{\n  name->kind |= name_preferred;\n}\n\nstatic void set_name_all(name_t* name, name_t* old)\n{\n  if (old->kind & name_xid)\n    name->xid = old->xid;\n  if (old->kind & name_string)\n    name->string = old->string;\n  if (old->kind & name_index)\n    name->index = old->index;\n  name->kind |= old->kind;\n}\n\nstatic void set_name(name_t* name, char* string, name_kind_t valid)\n{\n  unsigned int xid; /* don't make it XID (which is unsigned long):\n\t\t\t scanf() takes unsigned int */\n  int index;\n\n  if ((valid & name_xid) && sscanf(string, \"0x%x\", &xid) == 1)\n    set_name_xid(name, xid);\n  else if ((valid & name_index) && sscanf(string, \"%d\", &index) == 1)\n    set_name_index(name, index);\n  else if (valid & name_string)\n    set_name_string(name, string);\n  else\n    usage();\n}\n\nstatic void init_transform(transform_t* transform)\n{\n  int x;\n  memset(&transform->transform, '\\0', sizeof(transform->transform));\n  for (x = 0; x < 3; x++)\n    transform->transform.matrix[x][x] = XDoubleToFixed(1.0);\n  transform->filter = \"\";\n  transform->nparams = 0;\n  transform->params = NULL;\n}\n\nstatic void set_transform(\n    transform_t* dest, XTransform* transform, char* filter, XFixed* params, int nparams)\n{\n  dest->transform = *transform;\n  dest->filter = strdup(filter);\n  dest->nparams = nparams;\n  if (nparams)\n  {\n    dest->params = malloc(nparams * sizeof(XFixed));\n    memcpy(dest->params, params, nparams * sizeof(XFixed));\n  }\n  else\n    dest->params = NULL;\n}\n\nstatic void copy_transform(transform_t* dest, transform_t* src)\n{\n  set_transform(dest, &src->transform, src->filter, src->params, src->nparams);\n}\n\nstatic Bool equal_transform(transform_t* a, transform_t* b)\n{\n  if (memcmp(&a->transform, &b->transform, sizeof(XTransform)) != 0)\n    return False;\n  if (strcmp(a->filter, b->filter) != 0)\n    return False;\n  if (a->nparams != b->nparams)\n    return False;\n  if (memcmp(a->params, b->params, a->nparams * sizeof(XFixed)) != 0)\n    return False;\n  return True;\n}\n\nstatic output_t* add_output(void)\n{\n  output_t* output = calloc(1, sizeof(output_t));\n\n  if (!output)\n    fatal(\"out of memory\\n\");\n  output->next = NULL;\n  output->found = False;\n  output->brightness = 1.0;\n  *outputs_tail = output;\n  outputs_tail = &output->next;\n  return output;\n}\n\nstatic output_t* find_output(name_t* name)\n{\n  output_t* output;\n\n  for (output = outputs; output; output = output->next)\n  {\n    name_kind_t common = name->kind & output->output.kind;\n\n    if ((common & name_xid) && name->xid == output->output.xid)\n      break;\n    if ((common & name_string) && !strcmp(name->string, output->output.string))\n      break;\n    if ((common & name_index) && name->index == output->output.index)\n      break;\n  }\n  return output;\n}\n\nstatic output_t* find_output_by_xid(RROutput output)\n{\n  name_t output_name;\n\n  init_name(&output_name);\n  set_name_xid(&output_name, output);\n  return find_output(&output_name);\n}\n\nstatic output_t* find_output_by_name(char* name)\n{\n  name_t output_name;\n\n  init_name(&output_name);\n  set_name_string(&output_name, name);\n  return find_output(&output_name);\n}\n\nstatic crtc_t* find_crtc(name_t* name)\n{\n  int c;\n  crtc_t* crtc = NULL;\n\n  for (c = 0; c < num_crtcs; c++)\n  {\n    name_kind_t common;\n\n    crtc = &crtcs[c];\n    common = name->kind & crtc->crtc.kind;\n\n    if ((common & name_xid) && name->xid == crtc->crtc.xid)\n      break;\n    if ((common & name_string) && !strcmp(name->string, crtc->crtc.string))\n      break;\n    if ((common & name_index) && name->index == crtc->crtc.index)\n      break;\n    crtc = NULL;\n  }\n  return crtc;\n}\n\nstatic crtc_t* find_crtc_by_xid(RRCrtc crtc)\n{\n  name_t crtc_name;\n\n  init_name(&crtc_name);\n  set_name_xid(&crtc_name, crtc);\n  return find_crtc(&crtc_name);\n}\n\nstatic XRRModeInfo* find_mode(name_t* name, double refresh)\n{\n  int m;\n  XRRModeInfo* best = NULL;\n  double bestDist = 0;\n\n  for (m = 0; m < res->nmode; m++)\n  {\n    XRRModeInfo* mode = &res->modes[m];\n    if ((name->kind & name_xid) && name->xid == mode->id)\n    {\n      best = mode;\n      break;\n    }\n    if ((name->kind & name_string) && !strcmp(name->string, mode->name))\n    {\n      double dist;\n\n      if (refresh)\n        dist = fabs(mode_refresh(mode) - refresh);\n      else\n        dist = 0;\n      if (!best || dist < bestDist)\n      {\n        bestDist = dist;\n        best = mode;\n      }\n    }\n  }\n  return best;\n}\n\nstatic XRRModeInfo* find_mode_by_xid(RRMode mode)\n{\n  name_t mode_name;\n\n  init_name(&mode_name);\n  set_name_xid(&mode_name, mode);\n  return find_mode(&mode_name, 0);\n}\n\n#if 0\nstatic XRRModeInfo *\nfind_mode_by_name (char *name)\n{\n    name_t  mode_name;\n    init_name (&mode_name);\n    set_name_string (&mode_name, name);\n    return find_mode (&mode_name, 0);\n}\n#endif\n\nstatic XRRModeInfo* find_mode_for_output(output_t* output, name_t* name)\n{\n  XRROutputInfo* output_info = output->output_info;\n  int m;\n  XRRModeInfo* best = NULL;\n  double bestDist = 0;\n\n  for (m = 0; m < output_info->nmode; m++)\n  {\n    XRRModeInfo* mode;\n\n    mode = find_mode_by_xid(output_info->modes[m]);\n    if (!mode)\n      continue;\n    if ((name->kind & name_xid) && name->xid == mode->id)\n    {\n      best = mode;\n      break;\n    }\n    if ((name->kind & name_string) && !strcmp(name->string, mode->name))\n    {\n      double dist;\n\n      /* Stay away from doublescan modes unless refresh rate is specified. */\n      if (!output->refresh && (mode->modeFlags & RR_DoubleScan))\n        continue;\n\n      if (output->refresh)\n        dist = fabs(mode_refresh(mode) - output->refresh);\n      else\n        dist = 0;\n      if (!best || dist < bestDist)\n      {\n        bestDist = dist;\n        best = mode;\n      }\n    }\n  }\n  return best;\n}\n\nstatic XRRModeInfo* preferred_mode(output_t* output)\n{\n  XRROutputInfo* output_info = output->output_info;\n  int m;\n  XRRModeInfo* best;\n  int bestDist;\n\n  best = NULL;\n  bestDist = 0;\n  for (m = 0; m < output_info->nmode; m++)\n  {\n    XRRModeInfo* mode_info = find_mode_by_xid(output_info->modes[m]);\n    int dist;\n\n    if (m < output_info->npreferred)\n      dist = 0;\n    else if (output_info->mm_height)\n      dist = (1000 * DisplayHeight(dpy, screen) / DisplayHeightMM(dpy, screen) -\n              1000 * mode_info->height / output_info->mm_height);\n    else\n      dist = DisplayHeight(dpy, screen) - mode_info->height;\n\n    if (dist < 0)\n      dist = -dist;\n    if (!best || dist < bestDist)\n    {\n      best = mode_info;\n      bestDist = dist;\n    }\n  }\n  return best;\n}\n\nstatic Bool output_can_use_crtc(output_t* output, crtc_t* crtc)\n{\n  XRROutputInfo* output_info = output->output_info;\n  int c;\n\n  for (c = 0; c < output_info->ncrtc; c++)\n    if (output_info->crtcs[c] == crtc->crtc.xid)\n      return True;\n  return False;\n}\n\nstatic Bool output_can_use_mode(output_t* output, XRRModeInfo* mode)\n{\n  XRROutputInfo* output_info = output->output_info;\n  int m;\n\n  for (m = 0; m < output_info->nmode; m++)\n    if (output_info->modes[m] == mode->id)\n      return True;\n  return False;\n}\n\nstatic Bool crtc_can_use_rotation(crtc_t* crtc, Rotation rotation)\n{\n  Rotation rotations = crtc->crtc_info->rotations;\n  Rotation dir = rotation & (RR_Rotate_0 | RR_Rotate_90 | RR_Rotate_180 | RR_Rotate_270);\n  Rotation reflect = rotation & (RR_Reflect_X | RR_Reflect_Y);\n  if (((rotations & dir) != 0) && ((rotations & reflect) == reflect))\n    return True;\n  return False;\n}\n\n#if 0\nstatic Bool\ncrtc_can_use_transform (crtc_t *crtc, XTransform *transform)\n{\n    int\tmajor, minor;\n\n    XRRQueryVersion (dpy, &major, &minor);\n    if (major > 1 || (major == 1 && minor >= 3))\n\treturn True;\n    return False;\n}\n\n/*\n * Report only rotations that are supported by all crtcs\n */\nstatic Rotation\noutput_rotations (output_t *output)\n{\n    Bool\t    found = False;\n    Rotation\t    rotation = RR_Rotate_0;\n    XRROutputInfo   *output_info = output->output_info;\n    int\t\t    c;\n\n    for (c = 0; c < output_info->ncrtc; c++)\n    {\n\tcrtc_t\t*crtc = find_crtc_by_xid (output_info->crtcs[c]);\n\tif (crtc)\n\t{\n\t    if (!found) {\n\t\trotation = crtc->crtc_info->rotations;\n\t\tfound = True;\n\t    } else\n\t\trotation &= crtc->crtc_info->rotations;\n\t}\n    }\n    return rotation;\n}\n#endif\n\nstatic Bool output_can_use_rotation(output_t* output, Rotation rotation)\n{\n  XRROutputInfo* output_info = output->output_info;\n  int c;\n\n  /* make sure all of the crtcs can use this rotation.\n     * yes, this is not strictly necessary, but it is\n     * simpler,and we expect most drivers to either\n     * support rotation everywhere or nowhere\n     */\n  for (c = 0; c < output_info->ncrtc; c++)\n  {\n    crtc_t* crtc = find_crtc_by_xid(output_info->crtcs[c]);\n    if (crtc && !crtc_can_use_rotation(crtc, rotation))\n      return False;\n  }\n  return True;\n}\n\nstatic Bool output_is_primary(output_t* output)\n{\n  if (has_1_3)\n    return XRRGetOutputPrimary(dpy, root) == output->output.xid;\n  return False;\n}\n\n/* Returns the index of the last value in an array < 0xffff */\nstatic int find_last_non_clamped(CARD16 array[], int size)\n{\n  int i;\n  for (i = size - 1; i > 0; i--)\n  {\n    if (array[i] < 0xffff)\n      return i;\n  }\n  return 0;\n}\n\nstatic void set_gamma_info(output_t* output)\n{\n  XRRCrtcGamma* gamma;\n  double i1, v1, i2, v2;\n  int size, middle, last_best, last_red, last_green, last_blue;\n  CARD16* best_array;\n\n  if (!output->crtc_info)\n    return;\n\n  size = XRRGetCrtcGammaSize(dpy, output->crtc_info->crtc.xid);\n  if (!size)\n  {\n    warning(\"Failed to get size of gamma for output %s\\n\", output->output.string);\n    return;\n  }\n\n  gamma = XRRGetCrtcGamma(dpy, output->crtc_info->crtc.xid);\n  if (!gamma)\n  {\n    warning(\"Failed to get gamma for output %s\\n\", output->output.string);\n    return;\n  }\n\n  /*\n     * Here is a bit tricky because gamma is a whole curve for each\n     * color.  So, typically, we need to represent 3 * 256 values as 3 + 1\n     * values.  Therefore, we approximate the gamma curve (v) by supposing\n     * it always follows the way we set it: a power function (i^g)\n     * multiplied by a brightness (b).\n     * v = i^g * b\n     * so g = (ln(v) - ln(b))/ln(i)\n     * and b can be found using two points (v1,i1) and (v2, i2):\n     * b = e^((ln(v2)*ln(i1) - ln(v1)*ln(i2))/ln(i1/i2))\n     * For the best resolution, we select i2 at the highest place not\n     * clamped and i1 at i2/2. Note that if i2 = 1 (as in most normal\n     * cases), then b = v2.\n     */\n  last_red = find_last_non_clamped(gamma->red, size);\n  last_green = find_last_non_clamped(gamma->green, size);\n  last_blue = find_last_non_clamped(gamma->blue, size);\n  best_array = gamma->red;\n  last_best = last_red;\n  if (last_green > last_best)\n  {\n    last_best = last_green;\n    best_array = gamma->green;\n  }\n  if (last_blue > last_best)\n  {\n    last_best = last_blue;\n    best_array = gamma->blue;\n  }\n  if (last_best == 0)\n    last_best = 1;\n\n  middle = last_best / 2;\n  i1 = (double)(middle + 1) / size;\n  v1 = (double)(best_array[middle]) / 65535;\n  i2 = (double)(last_best + 1) / size;\n  v2 = (double)(best_array[last_best]) / 65535;\n  if (v2 < 0.0001)\n  { /* The screen is black */\n    output->brightness = 0;\n    output->gamma.red = 1;\n    output->gamma.green = 1;\n    output->gamma.blue = 1;\n  }\n  else\n  {\n    if ((last_best + 1) == size)\n      output->brightness = v2;\n    else\n      output->brightness = exp((log(v2) * log(i1) - log(v1) * log(i2)) / log(i1 / i2));\n    output->gamma.red = logf((gamma->red[last_red / 2]) / output->brightness / 65535) /\n                        logf(((last_red / 2) + 1) / size);\n    output->gamma.green = logf((gamma->green[last_green / 2]) / output->brightness / 65535) /\n                          logf(((last_green / 2) + 1) / size);\n    output->gamma.blue = logf((gamma->blue[last_blue / 2]) / output->brightness / 65535) /\n                         logf(((last_blue / 2) + 1) / size);\n  }\n\n  XRRFreeGamma(gamma);\n}\n\nstatic void set_output_info(output_t* output, RROutput xid, XRROutputInfo* output_info)\n{\n  /* sanity check output info */\n  if (output_info->connection != RR_Disconnected && !output_info->nmode)\n    warning(\"Output %s is not disconnected but has no modes\\n\", output_info->name);\n\n  /* set output name and info */\n  if (!(output->output.kind & name_xid))\n    set_name_xid(&output->output, xid);\n  if (!(output->output.kind & name_string))\n    set_name_string(&output->output, output_info->name);\n  output->output_info = output_info;\n\n  /* set crtc name and info */\n  if (!(output->changes & changes_crtc))\n    set_name_xid(&output->crtc, output_info->crtc);\n\n  if (output->crtc.kind == name_xid && output->crtc.xid == None)\n    output->crtc_info = NULL;\n  else\n  {\n    output->crtc_info = find_crtc(&output->crtc);\n    if (!output->crtc_info)\n    {\n      if (output->crtc.kind & name_xid)\n        fatal(\"cannot find crtc 0x%x\\n\", output->crtc.xid);\n      if (output->crtc.kind & name_index)\n        fatal(\"cannot find crtc %d\\n\", output->crtc.index);\n    }\n    if (!output_can_use_crtc(output, output->crtc_info))\n      fatal(\"output %s cannot use crtc 0x%x\\n\", output->output.string, output->crtc_info->crtc.xid);\n  }\n\n  /* set mode name and info */\n  if (!(output->changes & changes_mode))\n  {\n    crtc_t* crtc = NULL;\n\n    if (output_info->crtc)\n      crtc = find_crtc_by_xid(output_info->crtc);\n    if (crtc && crtc->crtc_info)\n      set_name_xid(&output->mode, crtc->crtc_info->mode);\n    else if (output->crtc_info)\n      set_name_xid(&output->mode, output->crtc_info->crtc_info->mode);\n    else\n      set_name_xid(&output->mode, None);\n    if (output->mode.xid)\n    {\n      output->mode_info = find_mode_by_xid(output->mode.xid);\n      if (!output->mode_info)\n        fatal(\"server did not report mode 0x%x for output %s\\n\", output->mode.xid,\n              output->output.string);\n    }\n    else\n      output->mode_info = NULL;\n  }\n  else if (output->mode.kind == name_xid && output->mode.xid == None)\n    output->mode_info = NULL;\n  else\n  {\n    if (output->mode.kind == name_preferred)\n      output->mode_info = preferred_mode(output);\n    else\n      output->mode_info = find_mode_for_output(output, &output->mode);\n    if (!output->mode_info)\n    {\n      if (output->mode.kind & name_preferred)\n        fatal(\"cannot find preferred mode\\n\");\n      if (output->mode.kind & name_string)\n        fatal(\"cannot find mode %s\\n\", output->mode.string);\n      if (output->mode.kind & name_xid)\n        fatal(\"cannot find mode 0x%x\\n\", output->mode.xid);\n    }\n    if (!output_can_use_mode(output, output->mode_info))\n      fatal(\"output %s cannot use mode %s\\n\", output->output.string, output->mode_info->name);\n  }\n\n  /* set position */\n  if (!(output->changes & changes_position))\n  {\n    if (output->crtc_info)\n    {\n      output->x = output->crtc_info->crtc_info->x;\n      output->y = output->crtc_info->crtc_info->y;\n    }\n    else\n    {\n      output->x = 0;\n      output->y = 0;\n    }\n  }\n\n  /* set rotation */\n  if (!(output->changes & changes_rotation))\n  {\n    output->rotation &= ~0xf;\n    if (output->crtc_info)\n      output->rotation |= (output->crtc_info->crtc_info->rotation & 0xf);\n    else\n      output->rotation = RR_Rotate_0;\n  }\n  if (!(output->changes & changes_reflection))\n  {\n    output->rotation &= ~(RR_Reflect_X | RR_Reflect_Y);\n    if (output->crtc_info)\n      output->rotation |= (output->crtc_info->crtc_info->rotation & (RR_Reflect_X | RR_Reflect_Y));\n  }\n  if (!output_can_use_rotation(output, output->rotation))\n    fatal(\"output %s cannot use rotation \\\"%s\\\" reflection \\\"%s\\\"\\n\", output->output.string,\n          rotation_name(output->rotation), reflection_name(output->rotation));\n\n  /* set gamma */\n  if (!(output->changes & changes_gamma))\n    set_gamma_info(output);\n\n  /* set transformation */\n  if (!(output->changes & changes_transform))\n  {\n    if (output->crtc_info)\n      copy_transform(&output->transform, &output->crtc_info->current_transform);\n    else\n      init_transform(&output->transform);\n  }\n  else\n  {\n    /* transform was already set for --scale or --transform */\n\n    /* for --scale-from, figure out the mode size and compute the transform\n\t * for the target framebuffer area */\n    if (output->scale_from_w > 0 && output->mode_info)\n    {\n      double sx = (double)output->scale_from_w / output->mode_info->width;\n      double sy = (double)output->scale_from_h / output->mode_info->height;\n      if (verbose)\n        printf(\"scaling %s by %lfx%lf\\n\", output->output.string, sx, sy);\n      init_transform(&output->transform);\n      output->transform.transform.matrix[0][0] = XDoubleToFixed(sx);\n      output->transform.transform.matrix[1][1] = XDoubleToFixed(sy);\n      output->transform.transform.matrix[2][2] = XDoubleToFixed(1.0);\n      if (sx != 1 || sy != 1)\n        output->transform.filter = \"bilinear\";\n      else\n        output->transform.filter = \"nearest\";\n      output->transform.nparams = 0;\n      output->transform.params = NULL;\n    }\n  }\n\n  /* set primary */\n  if (!(output->changes & changes_primary))\n    output->primary = output_is_primary(output);\n}\n\nstatic void get_screen(Bool current)\n{\n  if (!has_1_2)\n    fatal(\"Server RandR version before 1.2\\n\");\n\n  XRRGetScreenSizeRange(dpy, root, &minWidth, &minHeight, &maxWidth, &maxHeight);\n\n  if (current)\n    res = XRRGetScreenResourcesCurrent(dpy, root);\n  else\n    res = XRRGetScreenResources(dpy, root);\n  if (!res)\n    fatal(\"could not get screen resources\");\n}\n\nstatic void get_crtcs(void)\n{\n  int c;\n\n  num_crtcs = res->ncrtc;\n  crtcs = calloc(num_crtcs, sizeof(crtc_t));\n  if (!crtcs)\n    fatal(\"out of memory\\n\");\n\n  for (c = 0; c < res->ncrtc; c++)\n  {\n    XRRCrtcInfo* crtc_info = XRRGetCrtcInfo(dpy, res, res->crtcs[c]);\n    XRRCrtcTransformAttributes* attr;\n    XRRPanning* panning_info = NULL;\n\n    if (has_1_3)\n    {\n      XRRPanning zero;\n      memset(&zero, 0, sizeof(zero));\n      panning_info = XRRGetPanning(dpy, res, res->crtcs[c]);\n      zero.timestamp = panning_info->timestamp;\n      if (!memcmp(panning_info, &zero, sizeof(zero)))\n      {\n        Xfree(panning_info);\n        panning_info = NULL;\n      }\n    }\n\n    set_name_xid(&crtcs[c].crtc, res->crtcs[c]);\n    set_name_index(&crtcs[c].crtc, c);\n    if (!crtc_info)\n      fatal(\"could not get crtc 0x%x information\\n\", res->crtcs[c]);\n    crtcs[c].crtc_info = crtc_info;\n    crtcs[c].panning_info = panning_info;\n    if (crtc_info->mode == None)\n    {\n      crtcs[c].mode_info = NULL;\n      crtcs[c].x = 0;\n      crtcs[c].y = 0;\n      crtcs[c].rotation = RR_Rotate_0;\n    }\n    if (XRRGetCrtcTransform(dpy, res->crtcs[c], &attr) && attr)\n    {\n      set_transform(&crtcs[c].current_transform, &attr->currentTransform, attr->currentFilter,\n                    attr->currentParams, attr->currentNparams);\n      XFree(attr);\n    }\n    else\n    {\n      init_transform(&crtcs[c].current_transform);\n    }\n    copy_transform(&crtcs[c].pending_transform, &crtcs[c].current_transform);\n  }\n}\n\nstatic void crtc_add_output(crtc_t* crtc, output_t* output)\n{\n  if (crtc->outputs)\n    crtc->outputs = realloc(crtc->outputs, (crtc->noutput + 1) * sizeof(output_t*));\n  else\n  {\n    crtc->outputs = malloc(sizeof(output_t*));\n    crtc->x = output->x;\n    crtc->y = output->y;\n    crtc->rotation = output->rotation;\n    crtc->mode_info = output->mode_info;\n    copy_transform(&crtc->pending_transform, &output->transform);\n  }\n  if (!crtc->outputs)\n    fatal(\"out of memory\\n\");\n  crtc->outputs[crtc->noutput++] = output;\n}\n\nstatic void set_crtcs(void)\n{\n  output_t* output;\n\n  for (output = outputs; output; output = output->next)\n  {\n    if (!output->mode_info)\n      continue;\n    crtc_add_output(output->crtc_info, output);\n  }\n}\n\nstatic void set_panning(void)\n{\n  output_t* output;\n\n  for (output = outputs; output; output = output->next)\n  {\n    if (!output->crtc_info)\n      continue;\n    if (!(output->changes & changes_panning))\n      continue;\n    if (!output->crtc_info->panning_info)\n      output->crtc_info->panning_info = malloc(sizeof(XRRPanning));\n    memcpy(output->crtc_info->panning_info, &output->panning, sizeof(XRRPanning));\n    output->crtc_info->changing = 1;\n  }\n}\n\nstatic void set_gamma(void)\n{\n  output_t* output;\n\n  for (output = outputs; output; output = output->next)\n  {\n    int i, size;\n    crtc_t* crtc;\n    XRRCrtcGamma* gamma;\n\n    if (!(output->changes & changes_gamma))\n      continue;\n\n    if (!output->crtc_info)\n    {\n      fatal(\"Need crtc to set gamma on.\\n\");\n      continue;\n    }\n\n    crtc = output->crtc_info;\n\n    size = XRRGetCrtcGammaSize(dpy, crtc->crtc.xid);\n\n    if (!size)\n    {\n      fatal(\"Gamma size is 0.\\n\");\n      continue;\n    }\n\n    gamma = XRRAllocGamma(size);\n    if (!gamma)\n    {\n      fatal(\"Gamma allocation failed.\\n\");\n      continue;\n    }\n\n    if (output->gamma.red == 0.0f && output->gamma.green == 0.0f && output->gamma.blue == 0.0f)\n      output->gamma.red = output->gamma.green = output->gamma.blue = 1.0f;\n\n    for (i = 0; i < size; i++)\n    {\n      if (output->gamma.red == 1.0f && output->brightness == 1.0f)\n        gamma->red[i] = (i << 8) + i;\n      else\n        gamma->red[i] =\n            min(powf((float)i / (float)(size - 1), output->gamma.red) * output->brightness, 1.0f) *\n            65535.0f;\n\n      if (output->gamma.green == 1.0f && output->brightness == 1.0f)\n        gamma->green[i] = (i << 8) + i;\n      else\n        gamma->green[i] =\n            min(powf((float)i / (float)(size - 1), output->gamma.green) * output->brightness,\n                1.0f) *\n            65535.0f;\n\n      if (output->gamma.blue == 1.0f && output->brightness == 1.0f)\n        gamma->blue[i] = (i << 8) + i;\n      else\n        gamma->blue[i] =\n            min(powf((float)i / (float)(size - 1), output->gamma.blue) * output->brightness, 1.0f) *\n            65535.0f;\n    }\n\n    XRRSetCrtcGamma(dpy, crtc->crtc.xid, gamma);\n\n    free(gamma);\n  }\n}\n\nstatic void set_primary(void)\n{\n  output_t* output;\n\n  if (no_primary)\n  {\n    XRRSetOutputPrimary(dpy, root, None);\n  }\n  else\n  {\n    for (output = outputs; output; output = output->next)\n    {\n      if (!(output->changes & changes_primary))\n        continue;\n      if (output->primary)\n        XRRSetOutputPrimary(dpy, root, output->output.xid);\n    }\n  }\n}\n\nstatic Status crtc_disable(crtc_t* crtc)\n{\n  if (verbose)\n    printf(\"crtc %d: disable\\n\", crtc->crtc.index);\n\n  if (dryrun)\n    return RRSetConfigSuccess;\n  return XRRSetCrtcConfig(dpy, res, crtc->crtc.xid, CurrentTime, 0, 0, None, RR_Rotate_0, NULL, 0);\n}\n\nstatic void crtc_set_transform(crtc_t* crtc, transform_t* transform)\n{\n  int major, minor;\n\n  XRRQueryVersion(dpy, &major, &minor);\n  if (major > 1 || (major == 1 && minor >= 3))\n    XRRSetCrtcTransform(dpy, crtc->crtc.xid, &transform->transform, transform->filter,\n                        transform->params, transform->nparams);\n}\n\nstatic Status crtc_revert(crtc_t* crtc)\n{\n  XRRCrtcInfo* crtc_info = crtc->crtc_info;\n\n  if (verbose)\n    printf(\"crtc %d: revert\\n\", crtc->crtc.index);\n\n  if (dryrun)\n    return RRSetConfigSuccess;\n\n  if (!equal_transform(&crtc->current_transform, &crtc->pending_transform))\n    crtc_set_transform(crtc, &crtc->current_transform);\n  return XRRSetCrtcConfig(dpy, res, crtc->crtc.xid, CurrentTime, crtc_info->x, crtc_info->y,\n                          crtc_info->mode, crtc_info->rotation, crtc_info->outputs,\n                          crtc_info->noutput);\n}\n\nstatic Status crtc_apply(crtc_t* crtc)\n{\n  RROutput* rr_outputs;\n  int o;\n  Status s;\n  RRMode mode = None;\n\n  if (!crtc->changing || !crtc->mode_info)\n    return RRSetConfigSuccess;\n\n  rr_outputs = calloc(crtc->noutput, sizeof(RROutput));\n  if (!rr_outputs)\n    return BadAlloc;\n  for (o = 0; o < crtc->noutput; o++)\n    rr_outputs[o] = crtc->outputs[o]->output.xid;\n  mode = crtc->mode_info->id;\n  if (verbose)\n  {\n    printf(\"crtc %d: %12s %6.1f +%d+%d\", crtc->crtc.index, crtc->mode_info->name,\n           mode_refresh(crtc->mode_info), crtc->x, crtc->y);\n    for (o = 0; o < crtc->noutput; o++)\n      printf(\" \\\"%s\\\"\", crtc->outputs[o]->output.string);\n    printf(\"\\n\");\n  }\n\n  if (dryrun)\n    s = RRSetConfigSuccess;\n  else\n  {\n    if (!equal_transform(&crtc->current_transform, &crtc->pending_transform))\n      crtc_set_transform(crtc, &crtc->pending_transform);\n    s = XRRSetCrtcConfig(dpy, res, crtc->crtc.xid, CurrentTime, crtc->x, crtc->y, mode,\n                         crtc->rotation, rr_outputs, crtc->noutput);\n    if (s == RRSetConfigSuccess && crtc->panning_info)\n    {\n      if (has_1_3)\n        s = XRRSetPanning(dpy, res, crtc->crtc.xid, crtc->panning_info);\n      else\n        fatal(\"panning needs RandR 1.3\\n\");\n    }\n  }\n  free(rr_outputs);\n  return s;\n}\n\nstatic void screen_revert(void)\n{\n  if (verbose)\n    printf(\"screen %d: revert\\n\", screen);\n\n  if (dryrun)\n    return;\n  XRRSetScreenSize(dpy, root, DisplayWidth(dpy, screen), DisplayHeight(dpy, screen),\n                   DisplayWidthMM(dpy, screen), DisplayHeightMM(dpy, screen));\n}\n\nstatic void screen_apply(void)\n{\n  if (fb_width == DisplayWidth(dpy, screen) && fb_height == DisplayHeight(dpy, screen) &&\n      fb_width_mm == DisplayWidthMM(dpy, screen) && fb_height_mm == DisplayHeightMM(dpy, screen))\n  {\n    return;\n  }\n  if (verbose)\n    printf(\"screen %d: %dx%d %dx%d mm %6.2fdpi\\n\", screen, fb_width, fb_height, fb_width_mm,\n           fb_height_mm, dpi);\n  if (dryrun)\n    return;\n  XRRSetScreenSize(dpy, root, fb_width, fb_height, fb_width_mm, fb_height_mm);\n}\n\nstatic void revert(void)\n{\n  int c;\n\n  /* first disable all crtcs */\n  for (c = 0; c < res->ncrtc; c++)\n    crtc_disable(&crtcs[c]);\n  /* next reset screen size */\n  screen_revert();\n  /* now restore all crtcs */\n  for (c = 0; c < res->ncrtc; c++)\n    crtc_revert(&crtcs[c]);\n}\n\n/*\n * uh-oh, something bad happened in the middle of changing\n * the configuration. Revert to the previous configuration\n * and bail\n */\nstatic void _X_NORETURN panic(Status s, crtc_t* crtc)\n{\n  int c = crtc->crtc.index;\n  char* message;\n\n  switch (s)\n  {\n    case RRSetConfigSuccess:\n      message = \"succeeded\";\n      break;\n    case BadAlloc:\n      message = \"out of memory\";\n      break;\n    case RRSetConfigFailed:\n      message = \"failed\";\n      break;\n    case RRSetConfigInvalidConfigTime:\n      message = \"invalid config time\";\n      break;\n    case RRSetConfigInvalidTime:\n      message = \"invalid time\";\n      break;\n    default:\n      message = \"unknown failure\";\n      break;\n  }\n\n  fprintf(stderr, \"%s: Configure crtc %d %s\\n\", program_name, c, message);\n  revert();\n  exit(1);\n}\n\nstatic void apply(void)\n{\n  Status s;\n  int c;\n\n  /*\n     * Hold the server grabbed while messing with\n     * the screen so that apps which notice the resize\n     * event and ask for xinerama information from the server\n     * receive up-to-date information\n     */\n  if (grab_server)\n    XGrabServer(dpy);\n\n  /*\n     * Turn off any crtcs which are to be disabled or which are\n     * larger than the target size\n     */\n  for (c = 0; c < res->ncrtc; c++)\n  {\n    crtc_t* crtc = &crtcs[c];\n    XRRCrtcInfo* crtc_info = crtc->crtc_info;\n\n    /* if this crtc is already disabled, skip it */\n    if (crtc_info->mode == None)\n      continue;\n\n    /*\n\t * If this crtc is to be left enabled, make\n\t * sure the old size fits then new screen\n\t */\n    if (crtc->mode_info)\n    {\n      XRRModeInfo* old_mode = find_mode_by_xid(crtc_info->mode);\n      int x, y, w, h;\n      box_t bounds;\n\n      if (!old_mode)\n        panic(RRSetConfigFailed, crtc);\n\n      /* old position and size information */\n      mode_geometry(old_mode, crtc_info->rotation, &crtc->current_transform.transform, &bounds);\n\n      x = crtc_info->x + bounds.x1;\n      y = crtc_info->y + bounds.y1;\n      w = bounds.x2 - bounds.x1;\n      h = bounds.y2 - bounds.y1;\n\n      /* if it fits, skip it */\n      if (x + w <= fb_width && y + h <= fb_height)\n        continue;\n      crtc->changing = True;\n    }\n    s = crtc_disable(crtc);\n    if (s != RRSetConfigSuccess)\n      panic(s, crtc);\n  }\n\n  /*\n     * Set the screen size\n     */\n  screen_apply();\n\n  /*\n     * Set crtcs\n     */\n\n  for (c = 0; c < res->ncrtc; c++)\n  {\n    crtc_t* crtc = &crtcs[c];\n\n    s = crtc_apply(crtc);\n    if (s != RRSetConfigSuccess)\n      panic(s, crtc);\n  }\n\n  set_primary();\n\n  /*\n     * Release the server grab and let all clients\n     * respond to the updated state\n     */\n  if (grab_server)\n    XUngrabServer(dpy);\n}\n\n/*\n * Use current output state to complete the output list\n */\nstatic void get_outputs(void)\n{\n  int o;\n  output_t* q;\n\n  for (o = 0; o < res->noutput; o++)\n  {\n    XRROutputInfo* output_info = XRRGetOutputInfo(dpy, res, res->outputs[o]);\n    output_t* output;\n    name_t output_name;\n    if (!output_info)\n      fatal(\"could not get output 0x%x information\\n\", res->outputs[o]);\n    init_name(&output_name);\n    set_name_xid(&output_name, res->outputs[o]);\n    set_name_index(&output_name, o);\n    set_name_string(&output_name, output_info->name);\n    output = find_output(&output_name);\n    if (!output)\n    {\n      output = add_output();\n      set_name_all(&output->output, &output_name);\n      /*\n\t     * When global --automatic mode is set, turn on connected but off\n\t     * outputs, turn off disconnected but on outputs\n\t     */\n      if (automatic)\n      {\n        switch (output_info->connection)\n        {\n          case RR_Connected:\n            if (!output_info->crtc)\n            {\n              output->changes |= changes_automatic;\n              output->automatic = True;\n            }\n            break;\n          case RR_Disconnected:\n            if (output_info->crtc)\n            {\n              output->changes |= changes_automatic;\n              output->automatic = True;\n            }\n            break;\n        }\n      }\n    }\n    output->found = True;\n\n    /*\n\t * Automatic mode -- track connection state and enable/disable outputs\n\t * as necessary\n\t */\n    if (output->automatic)\n    {\n      switch (output_info->connection)\n      {\n        case RR_Connected:\n        case RR_UnknownConnection:\n          if ((!(output->changes & changes_mode)))\n          {\n            set_name_preferred(&output->mode);\n            output->changes |= changes_mode;\n          }\n          break;\n        case RR_Disconnected:\n          if ((!(output->changes & changes_mode)))\n          {\n            set_name_xid(&output->mode, None);\n            set_name_xid(&output->crtc, None);\n            output->changes |= changes_mode;\n            output->changes |= changes_crtc;\n          }\n          break;\n      }\n    }\n\n    set_output_info(output, res->outputs[o], output_info);\n  }\n  for (q = outputs; q; q = q->next)\n  {\n    if (!q->found)\n    {\n      fprintf(stderr, \"warning: output %s not found; ignoring\\n\", q->output.string);\n    }\n  }\n}\n\nstatic void mark_changing_crtcs(void)\n{\n  int c;\n\n  for (c = 0; c < num_crtcs; c++)\n  {\n    crtc_t* crtc = &crtcs[c];\n    int o;\n    output_t* output;\n\n    /* walk old output list (to catch disables) */\n    for (o = 0; o < crtc->crtc_info->noutput; o++)\n    {\n      output = find_output_by_xid(crtc->crtc_info->outputs[o]);\n      if (!output)\n        fatal(\"cannot find output 0x%x\\n\", crtc->crtc_info->outputs[o]);\n      if (output->changes)\n        crtc->changing = True;\n    }\n    /* walk new output list */\n    for (o = 0; o < crtc->noutput; o++)\n    {\n      output = crtc->outputs[o];\n      if (output->changes)\n        crtc->changing = True;\n    }\n  }\n}\n\n/*\n * Test whether 'crtc' can be used for 'output'\n */\nstatic Bool check_crtc_for_output(crtc_t* crtc, output_t* output)\n{\n  int c;\n  int l;\n  output_t* other;\n\n  for (c = 0; c < output->output_info->ncrtc; c++)\n    if (output->output_info->crtcs[c] == crtc->crtc.xid)\n      break;\n  if (c == output->output_info->ncrtc)\n    return False;\n  for (other = outputs; other; other = other->next)\n  {\n    if (other == output)\n      continue;\n\n    if (other->mode_info == NULL)\n      continue;\n\n    if (other->crtc_info != crtc)\n      continue;\n\n    /* see if the output connected to the crtc can clone to this output */\n    for (l = 0; l < output->output_info->nclone; l++)\n      if (output->output_info->clones[l] == other->output.xid)\n        break;\n    /* not on the list, can't clone */\n    if (l == output->output_info->nclone)\n      return False;\n  }\n\n  if (crtc->noutput)\n  {\n    /* make sure the state matches */\n    if (crtc->mode_info != output->mode_info)\n      return False;\n    if (crtc->x != output->x)\n      return False;\n    if (crtc->y != output->y)\n      return False;\n    if (crtc->rotation != output->rotation)\n      return False;\n    if (!equal_transform(&crtc->current_transform, &output->transform))\n      return False;\n  }\n  else if (crtc->crtc_info->noutput)\n  {\n    /* make sure the state matches the already used state */\n    XRRModeInfo* mode = find_mode_by_xid(crtc->crtc_info->mode);\n\n    if (mode != output->mode_info)\n      return False;\n    if (crtc->crtc_info->x != output->x)\n      return False;\n    if (crtc->crtc_info->y != output->y)\n      return False;\n    if (crtc->crtc_info->rotation != output->rotation)\n      return False;\n  }\n  return True;\n}\n\nstatic crtc_t* find_crtc_for_output(output_t* output)\n{\n  int c;\n\n  for (c = 0; c < output->output_info->ncrtc; c++)\n  {\n    crtc_t* crtc;\n\n    crtc = find_crtc_by_xid(output->output_info->crtcs[c]);\n    if (!crtc)\n      fatal(\"cannot find crtc 0x%x\\n\", output->output_info->crtcs[c]);\n\n    if (check_crtc_for_output(crtc, output))\n      return crtc;\n  }\n  return NULL;\n}\n\nstatic void set_positions(void)\n{\n  output_t* output;\n  Bool keep_going;\n  Bool any_set;\n  int min_x, min_y;\n\n  for (;;)\n  {\n    any_set = False;\n    keep_going = False;\n    for (output = outputs; output; output = output->next)\n    {\n      output_t* relation;\n      name_t relation_name;\n\n      if (!(output->changes & changes_relation))\n        continue;\n\n      if (output->mode_info == NULL)\n        continue;\n\n      init_name(&relation_name);\n      set_name_string(&relation_name, output->relative_to);\n      relation = find_output(&relation_name);\n      if (!relation)\n        fatal(\"cannot find output \\\"%s\\\"\\n\", output->relative_to);\n\n      if (relation->mode_info == NULL)\n      {\n        output->x = 0;\n        output->y = 0;\n        output->changes |= changes_position;\n        any_set = True;\n        continue;\n      }\n      /*\n\t     * Make sure the dependent object has been set in place\n\t     */\n      if ((relation->changes & changes_relation) && !(relation->changes & changes_position))\n      {\n        keep_going = True;\n        continue;\n      }\n\n      switch (output->relation)\n      {\n        case relation_left_of:\n          output->y = relation->y;\n          output->x = relation->x - mode_width(output->mode_info, output->rotation);\n          break;\n        case relation_right_of:\n          output->y = relation->y;\n          output->x = relation->x + mode_width(relation->mode_info, relation->rotation);\n          break;\n        case relation_above:\n          output->x = relation->x;\n          output->y = relation->y - mode_height(output->mode_info, output->rotation);\n          break;\n        case relation_below:\n          output->x = relation->x;\n          output->y = relation->y + mode_height(relation->mode_info, relation->rotation);\n          break;\n        case relation_same_as:\n          output->x = relation->x;\n          output->y = relation->y;\n      }\n      output->changes |= changes_position;\n      any_set = True;\n    }\n    if (!keep_going)\n      break;\n    if (!any_set)\n      fatal(\"loop in relative position specifications\\n\");\n  }\n\n  /*\n     * Now normalize positions so the upper left corner of all outputs is at 0,0\n     */\n  min_x = 32768;\n  min_y = 32768;\n  for (output = outputs; output; output = output->next)\n  {\n    if (output->mode_info == NULL)\n      continue;\n\n    if (output->x < min_x)\n      min_x = output->x;\n    if (output->y < min_y)\n      min_y = output->y;\n  }\n  if (min_x || min_y)\n  {\n    /* move all outputs */\n    for (output = outputs; output; output = output->next)\n    {\n      if (output->mode_info == NULL)\n        continue;\n\n      output->x -= min_x;\n      output->y -= min_y;\n      output->changes |= changes_position;\n    }\n  }\n}\n\nstatic void set_screen_size(void)\n{\n  output_t* output;\n  Bool fb_specified = fb_width != 0 && fb_height != 0;\n\n  for (output = outputs; output; output = output->next)\n  {\n    XRRModeInfo* mode_info = output->mode_info;\n    int x, y, w, h;\n    box_t bounds;\n\n    if (!mode_info)\n      continue;\n\n    mode_geometry(mode_info, output->rotation, &output->transform.transform, &bounds);\n    x = output->x + bounds.x1;\n    y = output->y + bounds.y1;\n    w = bounds.x2 - bounds.x1;\n    h = bounds.y2 - bounds.y1;\n    /* make sure output fits in specified size */\n    if (fb_specified)\n    {\n      if (x + w > fb_width || y + h > fb_height)\n        warning(\"specified screen %dx%d not large enough for output %s (%dx%d+%d+%d)\\n\", fb_width,\n                fb_height, output->output.string, w, h, x, y);\n    }\n    /* fit fb to output */\n    else\n    {\n      XRRPanning* pan;\n      if (x + w > fb_width)\n        fb_width = x + w;\n      if (y + h > fb_height)\n        fb_height = y + h;\n      if (output->changes & changes_panning)\n        pan = &output->panning;\n      else\n        pan = output->crtc_info ? output->crtc_info->panning_info : NULL;\n      if (pan && pan->left + pan->width > (unsigned int)fb_width)\n        fb_width = pan->left + pan->width;\n      if (pan && pan->top + pan->height > (unsigned int)fb_height)\n        fb_height = pan->top + pan->height;\n    }\n  }\n\n  if (fb_width > maxWidth || fb_height > maxHeight)\n    fatal(\"screen cannot be larger than %dx%d (desired size %dx%d)\\n\", maxWidth, maxHeight,\n          fb_width, fb_height);\n  if (fb_specified)\n  {\n    if (fb_width < minWidth || fb_height < minHeight)\n      fatal(\"screen must be at least %dx%d\\n\", minWidth, minHeight);\n  }\n  else\n  {\n    if (fb_width < minWidth)\n      fb_width = minWidth;\n    if (fb_height < minHeight)\n      fb_height = minHeight;\n  }\n}\n\n\nstatic void disable_outputs(output_t* outputs)\n{\n  while (outputs)\n  {\n    outputs->crtc_info = NULL;\n    outputs = outputs->next;\n  }\n}\n\n/*\n * find the best mapping from output to crtc available\n */\nstatic int pick_crtcs_score(output_t* outputs)\n{\n  output_t* output;\n  int best_score;\n  int my_score;\n  int score;\n  crtc_t* best_crtc;\n  int c;\n\n  if (!outputs)\n    return 0;\n\n  output = outputs;\n  outputs = outputs->next;\n  /*\n     * Score with this output disabled\n     */\n  output->crtc_info = NULL;\n  best_score = pick_crtcs_score(outputs);\n  if (output->mode_info == NULL)\n    return best_score;\n\n  best_crtc = NULL;\n  /*\n     * Now score with this output any valid crtc\n     */\n  for (c = 0; c < output->output_info->ncrtc; c++)\n  {\n    crtc_t* crtc;\n\n    crtc = find_crtc_by_xid(output->output_info->crtcs[c]);\n    if (!crtc)\n      fatal(\"cannot find crtc 0x%x\\n\", output->output_info->crtcs[c]);\n\n    /* reset crtc allocation for following outputs */\n    disable_outputs(outputs);\n    if (!check_crtc_for_output(crtc, output))\n      continue;\n\n    my_score = 1000;\n    /* slight preference for existing connections */\n    if (crtc == output->current_crtc_info)\n      my_score++;\n\n    output->crtc_info = crtc;\n    score = my_score + pick_crtcs_score(outputs);\n    if (score > best_score)\n    {\n      best_crtc = crtc;\n      best_score = score;\n    }\n  }\n  if (output->crtc_info != best_crtc)\n    output->crtc_info = best_crtc;\n  /*\n     * Reset other outputs based on this one using the best crtc\n     */\n  (void)pick_crtcs_score(outputs);\n\n  return best_score;\n}\n\n/*\n * Pick crtcs for any changing outputs that don't have one\n */\nstatic void pick_crtcs(void)\n{\n  output_t* output;\n\n  /*\n     * First try to match up newly enabled outputs with spare crtcs\n     */\n  for (output = outputs; output; output = output->next)\n  {\n    if (output->changes && output->mode_info)\n    {\n      if (output->crtc_info)\n      {\n        if (output->crtc_info->crtc_info->noutput > 0 &&\n            (output->crtc_info->crtc_info->noutput > 1 ||\n             output != find_output_by_xid(output->crtc_info->crtc_info->outputs[0])))\n          break;\n      }\n      else\n      {\n        output->crtc_info = find_crtc_for_output(output);\n        if (!output->crtc_info)\n          break;\n      }\n    }\n  }\n  /*\n     * Everyone is happy\n     */\n  if (!output)\n    return;\n  /*\n     * When the simple way fails, see if there is a way\n     * to swap crtcs around and make things work\n     */\n  for (output = outputs; output; output = output->next)\n    output->current_crtc_info = output->crtc_info;\n  pick_crtcs_score(outputs);\n  for (output = outputs; output; output = output->next)\n  {\n    if (output->mode_info && !output->crtc_info)\n      fatal(\"cannot find crtc for output %s\\n\", output->output.string);\n    if (!output->changes && output->crtc_info != output->current_crtc_info)\n      output->changes |= changes_crtc;\n  }\n}\n\nstatic int check_strtol(char* s)\n{\n  char* endptr;\n  int result = strtol(s, &endptr, 10);\n  if (s == endptr)\n    usage();\n  return result;\n}\n\nstatic double check_strtod(char* s)\n{\n  char* endptr;\n  double result = strtod(s, &endptr);\n  if (s == endptr)\n    usage();\n  return result;\n}\n\nint main(int argc, char** argv)\n{\n  XRRScreenSize* sizes;\n  XRRScreenConfiguration* sc;\n  int nsize;\n  int nrate;\n  short* rates;\n  Status status = RRSetConfigFailed;\n  int rot = -1;\n  int query = False;\n  int action_requested = False;\n  Rotation rotation, current_rotation, rotations;\n  XRRScreenChangeNotifyEvent event;\n  XRRScreenChangeNotifyEvent* sce;\n  char* display_name = NULL;\n  int i, j;\n  SizeID current_size;\n  short current_rate;\n  double rate = -1;\n  int size = -1;\n  int dirind = 0;\n  Bool setit = False;\n  Bool version = False;\n  int event_base, error_base;\n  int reflection = 0;\n  int width = 0, height = 0;\n  Bool have_pixel_size = False;\n  int ret = 0;\n  output_t* output = NULL;\n  Bool setit_1_2 = False;\n  Bool query_1_2 = False;\n  Bool modeit = False;\n  Bool propit = False;\n  Bool query_1 = False;\n  int major, minor;\n  Bool current = False;\n\n  program_name = argv[0];\n  for (i = 1; i < argc; i++)\n  {\n    if (!strcmp(\"-display\", argv[i]) || !strcmp(\"-d\", argv[i]))\n    {\n      if (++i >= argc)\n        usage();\n      display_name = argv[i];\n      continue;\n    }\n    if (!strcmp(\"-help\", argv[i]))\n    {\n      usage();\n      action_requested = True;\n      continue;\n    }\n    if (!strcmp(\"--verbose\", argv[i]))\n    {\n      verbose = True;\n      continue;\n    }\n    if (!strcmp(\"--dryrun\", argv[i]))\n    {\n      dryrun = True;\n      verbose = True;\n      continue;\n    }\n    if (!strcmp(\"--nograb\", argv[i]))\n    {\n      grab_server = False;\n      continue;\n    }\n    if (!strcmp(\"--current\", argv[i]))\n    {\n      current = True;\n      continue;\n    }\n\n    if (!strcmp(\"-s\", argv[i]) || !strcmp(\"--size\", argv[i]))\n    {\n      if (++i >= argc)\n        usage();\n      if (sscanf(argv[i], \"%dx%d\", &width, &height) == 2)\n      {\n        have_pixel_size = True;\n      }\n      else\n      {\n        size = check_strtol(argv[i]);\n        if (size < 0)\n          usage();\n      }\n      setit = True;\n      action_requested = True;\n      continue;\n    }\n\n    if (!strcmp(\"-r\", argv[i]) || !strcmp(\"--rate\", argv[i]) || !strcmp(\"--refresh\", argv[i]))\n    {\n      if (++i >= argc)\n        usage();\n      rate = check_strtod(argv[i]);\n      setit = True;\n      if (output)\n      {\n        output->refresh = rate;\n        output->changes |= changes_refresh;\n        setit_1_2 = True;\n      }\n      action_requested = True;\n      continue;\n    }\n\n    if (!strcmp(\"-v\", argv[i]) || !strcmp(\"--version\", argv[i]))\n    {\n      version = True;\n      action_requested = True;\n      continue;\n    }\n\n    if (!strcmp(\"-x\", argv[i]))\n    {\n      reflection |= RR_Reflect_X;\n      setit = True;\n      action_requested = True;\n      continue;\n    }\n    if (!strcmp(\"-y\", argv[i]))\n    {\n      reflection |= RR_Reflect_Y;\n      setit = True;\n      action_requested = True;\n      continue;\n    }\n    if (!strcmp(\"--screen\", argv[i]))\n    {\n      if (++i >= argc)\n        usage();\n      screen = check_strtol(argv[i]);\n      if (screen < 0)\n        usage();\n      continue;\n    }\n    if (!strcmp(\"-q\", argv[i]) || !strcmp(\"--query\", argv[i]))\n    {\n      query = True;\n      continue;\n    }\n    if (!strcmp(\"-o\", argv[i]) || !strcmp(\"--orientation\", argv[i]))\n    {\n      char* endptr;\n      if (++i >= argc)\n        usage();\n      dirind = strtol(argv[i], &endptr, 10);\n      if (argv[i] == endptr)\n      {\n        for (dirind = 0; dirind < 4; dirind++)\n        {\n          if (strcmp(direction[dirind], argv[i]) == 0)\n            break;\n        }\n        if ((dirind < 0) || (dirind > 3))\n          usage();\n      }\n      rot = dirind;\n      setit = True;\n      action_requested = True;\n      continue;\n    }\n    if (!strcmp(\"--prop\", argv[i]) || !strcmp(\"--props\", argv[i]) ||\n        !strcmp(\"--madprops\", argv[i]) || !strcmp(\"--properties\", argv[i]))\n    {\n      query_1_2 = True;\n      properties = True;\n      action_requested = True;\n      continue;\n    }\n    if (!strcmp(\"--output\", argv[i]))\n    {\n      if (++i >= argc)\n        usage();\n\n      output = find_output_by_name(argv[i]);\n      if (!output)\n      {\n        output = add_output();\n        set_name(&output->output, argv[i], name_string | name_xid);\n      }\n\n      setit_1_2 = True;\n      action_requested = True;\n      continue;\n    }\n    if (!strcmp(\"--crtc\", argv[i]))\n    {\n      if (++i >= argc)\n        usage();\n      if (!output)\n        usage();\n      set_name(&output->crtc, argv[i], name_xid | name_index);\n      output->changes |= changes_crtc;\n      continue;\n    }\n    if (!strcmp(\"--mode\", argv[i]))\n    {\n      if (++i >= argc)\n        usage();\n      if (!output)\n        usage();\n      set_name(&output->mode, argv[i], name_string | name_xid);\n      output->changes |= changes_mode;\n      continue;\n    }\n    if (!strcmp(\"--preferred\", argv[i]))\n    {\n      if (!output)\n        usage();\n      set_name_preferred(&output->mode);\n      output->changes |= changes_mode;\n      continue;\n    }\n    if (!strcmp(\"--pos\", argv[i]))\n    {\n      if (++i >= argc)\n        usage();\n      if (!output)\n        usage();\n      if (sscanf(argv[i], \"%dx%d\", &output->x, &output->y) != 2)\n        usage();\n      output->changes |= changes_position;\n      continue;\n    }\n    if (!strcmp(\"--rotation\", argv[i]) || !strcmp(\"--rotate\", argv[i]))\n    {\n      if (++i >= argc)\n        usage();\n      if (!output)\n        usage();\n      for (dirind = 0; dirind < 4; dirind++)\n      {\n        if (strcmp(direction[dirind], argv[i]) == 0)\n          break;\n      }\n      if (dirind == 4)\n        usage();\n      output->rotation &= ~0xf;\n      output->rotation |= 1 << dirind;\n      output->changes |= changes_rotation;\n      continue;\n    }\n    if (!strcmp(\"--reflect\", argv[i]) || !strcmp(\"--reflection\", argv[i]))\n    {\n      if (++i >= argc)\n        usage();\n      if (!output)\n        usage();\n      for (dirind = 0; dirind < 4; dirind++)\n      {\n        if (strcmp(reflections[dirind], argv[i]) == 0)\n          break;\n      }\n      if (dirind == 4)\n        usage();\n      output->rotation &= ~(RR_Reflect_X | RR_Reflect_Y);\n      output->rotation |= dirind * RR_Reflect_X;\n      output->changes |= changes_reflection;\n      continue;\n    }\n    if (!strcmp(\"--left-of\", argv[i]))\n    {\n      if (++i >= argc)\n        usage();\n      if (!output)\n        usage();\n      output->relation = relation_left_of;\n      output->relative_to = argv[i];\n      output->changes |= changes_relation;\n      continue;\n    }\n    if (!strcmp(\"--right-of\", argv[i]))\n    {\n      if (++i >= argc)\n        usage();\n      if (!output)\n        usage();\n      output->relation = relation_right_of;\n      output->relative_to = argv[i];\n      output->changes |= changes_relation;\n      continue;\n    }\n    if (!strcmp(\"--above\", argv[i]))\n    {\n      if (++i >= argc)\n        usage();\n      if (!output)\n        usage();\n      output->relation = relation_above;\n      output->relative_to = argv[i];\n      output->changes |= changes_relation;\n      continue;\n    }\n    if (!strcmp(\"--below\", argv[i]))\n    {\n      if (++i >= argc)\n        usage();\n      if (!output)\n        usage();\n      output->relation = relation_below;\n      output->relative_to = argv[i];\n      output->changes |= changes_relation;\n      continue;\n    }\n    if (!strcmp(\"--same-as\", argv[i]))\n    {\n      if (++i >= argc)\n        usage();\n      if (!output)\n        usage();\n      output->relation = relation_same_as;\n      output->relative_to = argv[i];\n      output->changes |= changes_relation;\n      continue;\n    }\n    if (!strcmp(\"--panning\", argv[i]))\n    {\n      XRRPanning* pan;\n      if (++i >= argc)\n        usage();\n      if (!output)\n        usage();\n      pan = &output->panning;\n      switch (sscanf(argv[i], \"%dx%d+%d+%d/%dx%d+%d+%d/%d/%d/%d/%d\", &pan->width, &pan->height,\n                     &pan->left, &pan->top, &pan->track_width, &pan->track_height, &pan->track_left,\n                     &pan->track_top, &pan->border_left, &pan->border_top, &pan->border_right,\n                     &pan->border_bottom))\n      {\n        case 2:\n          pan->left = pan->top = 0;\n          /* fall through */\n          __attribute__((fallthrough));\n        case 4:\n          pan->track_left = pan->track_top = pan->track_width = pan->track_height = 0;\n          /* fall through */\n          __attribute__((fallthrough));\n        case 8:\n          pan->border_left = pan->border_top = pan->border_right = pan->border_bottom = 0;\n          /* fall through */\n          __attribute__((fallthrough));\n        case 12:\n          break;\n        default:\n          usage();\n      }\n      output->changes |= changes_panning;\n      continue;\n    }\n    if (!strcmp(\"--gamma\", argv[i]))\n    {\n      if (!output)\n        usage();\n      if (++i >= argc)\n        usage();\n      if (sscanf(argv[i], \"%f:%f:%f\", &output->gamma.red, &output->gamma.green,\n                 &output->gamma.blue) != 3)\n        usage();\n      output->changes |= changes_gamma;\n      setit_1_2 = True;\n      continue;\n    }\n    if (!strcmp(\"--brightness\", argv[i]))\n    {\n      if (!output)\n        usage();\n      if (++i >= argc)\n        usage();\n      if (sscanf(argv[i], \"%f\", &output->brightness) != 1)\n        usage();\n      output->changes |= changes_gamma;\n      setit_1_2 = True;\n      continue;\n    }\n    if (!strcmp(\"--primary\", argv[i]))\n    {\n      if (!output)\n        usage();\n      output->changes |= changes_primary;\n      output->primary = True;\n      setit_1_2 = True;\n      continue;\n    }\n    if (!strcmp(\"--noprimary\", argv[i]))\n    {\n      no_primary = True;\n      setit_1_2 = True;\n      continue;\n    }\n    if (!strcmp(\"--set\", argv[i]))\n    {\n      output_prop_t* prop;\n      if (!output)\n        usage();\n      prop = malloc(sizeof(output_prop_t));\n      prop->next = output->props;\n      output->props = prop;\n      if (++i >= argc)\n        usage();\n      prop->name = argv[i];\n      if (++i >= argc)\n        usage();\n      prop->value = argv[i];\n      propit = True;\n      output->changes |= changes_property;\n      setit_1_2 = True;\n      continue;\n    }\n    if (!strcmp(\"--scale\", argv[i]))\n    {\n      double sx, sy;\n      if (!output)\n        usage();\n      if (++i >= argc)\n        usage();\n      if (sscanf(argv[i], \"%lfx%lf\", &sx, &sy) != 2)\n        usage();\n      init_transform(&output->transform);\n      output->transform.transform.matrix[0][0] = XDoubleToFixed(sx);\n      output->transform.transform.matrix[1][1] = XDoubleToFixed(sy);\n      output->transform.transform.matrix[2][2] = XDoubleToFixed(1.0);\n      if (sx != 1 || sy != 1)\n        output->transform.filter = \"bilinear\";\n      else\n        output->transform.filter = \"nearest\";\n      output->transform.nparams = 0;\n      output->transform.params = NULL;\n      output->changes |= changes_transform;\n      continue;\n    }\n    if (!strcmp(\"--scale-from\", argv[i]))\n    {\n      int w, h;\n      if (!output)\n        usage();\n      if (++i >= argc)\n        usage();\n      if (sscanf(argv[i], \"%dx%d\", &w, &h) != 2)\n        usage();\n      if (w <= 0 || h <= 0)\n        usage();\n      output->scale_from_w = w;\n      output->scale_from_h = h;\n      output->changes |= changes_transform;\n      continue;\n    }\n    if (!strcmp(\"--transform\", argv[i]))\n    {\n      double transform[3][3];\n      int k, l;\n      if (!output)\n        usage();\n      if (++i >= argc)\n        usage();\n      init_transform(&output->transform);\n      if (strcmp(argv[i], \"none\") != 0)\n      {\n        if (sscanf(argv[i], \"%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf\", &transform[0][0],\n                   &transform[0][1], &transform[0][2], &transform[1][0], &transform[1][1],\n                   &transform[1][2], &transform[2][0], &transform[2][1], &transform[2][2]) != 9)\n          usage();\n        init_transform(&output->transform);\n        for (k = 0; k < 3; k++)\n          for (l = 0; l < 3; l++)\n          {\n            output->transform.transform.matrix[k][l] = XDoubleToFixed(transform[k][l]);\n          }\n        output->transform.filter = \"bilinear\";\n        output->transform.nparams = 0;\n        output->transform.params = NULL;\n      }\n      output->changes |= changes_transform;\n      continue;\n    }\n    if (!strcmp(\"--off\", argv[i]))\n    {\n      if (!output)\n        usage();\n      set_name_xid(&output->mode, None);\n      set_name_xid(&output->crtc, None);\n      output->changes |= changes_mode;\n      continue;\n    }\n    if (!strcmp(\"--fb\", argv[i]))\n    {\n      if (++i >= argc)\n        usage();\n      if (sscanf(argv[i], \"%dx%d\", &fb_width, &fb_height) != 2)\n        usage();\n      setit_1_2 = True;\n      action_requested = True;\n      continue;\n    }\n    if (!strcmp(\"--fbmm\", argv[i]))\n    {\n      if (++i >= argc)\n        usage();\n      if (sscanf(argv[i], \"%dx%d\", &fb_width_mm, &fb_height_mm) != 2)\n        usage();\n      setit_1_2 = True;\n      action_requested = True;\n      continue;\n    }\n    if (!strcmp(\"--dpi\", argv[i]))\n    {\n      char* strtod_error;\n      if (++i >= argc)\n        usage();\n      dpi = strtod(argv[i], &strtod_error);\n      if (argv[i] == strtod_error)\n      {\n        dpi = 0.0;\n        dpi_output = argv[i];\n      }\n      setit_1_2 = True;\n      action_requested = True;\n      continue;\n    }\n    if (!strcmp(\"--auto\", argv[i]))\n    {\n      if (output)\n      {\n        output->automatic = True;\n        output->changes |= changes_automatic;\n      }\n      else\n        automatic = True;\n      setit_1_2 = True;\n      action_requested = True;\n      continue;\n    }\n    if (!strcmp(\"--q12\", argv[i]))\n    {\n      query_1_2 = True;\n      continue;\n    }\n    if (!strcmp(\"--q1\", argv[i]))\n    {\n      query_1 = True;\n      continue;\n    }\n    if (!strcmp(\"--newmode\", argv[i]))\n    {\n      umode_t* m = malloc(sizeof(umode_t));\n      double clock;\n\n      ++i;\n      if (i + 9 >= argc)\n        usage();\n      m->mode.name = argv[i];\n      m->mode.nameLength = strlen(argv[i]);\n      i++;\n      clock = check_strtod(argv[i++]);\n      m->mode.dotClock = clock * 1e6;\n\n      m->mode.width = check_strtol(argv[i++]);\n      m->mode.hSyncStart = check_strtol(argv[i++]);\n      m->mode.hSyncEnd = check_strtol(argv[i++]);\n      m->mode.hTotal = check_strtol(argv[i++]);\n      m->mode.height = check_strtol(argv[i++]);\n      m->mode.vSyncStart = check_strtol(argv[i++]);\n      m->mode.vSyncEnd = check_strtol(argv[i++]);\n      m->mode.vTotal = check_strtol(argv[i++]);\n      m->mode.modeFlags = 0;\n      while (i < argc)\n      {\n        int f;\n\n        for (f = 0; mode_flags[f].string; f++)\n          if (!strcasecmp(mode_flags[f].string, argv[i]))\n            break;\n\n        if (!mode_flags[f].string)\n          break;\n        m->mode.modeFlags |= mode_flags[f].flag;\n        i++;\n      }\n      m->next = umodes;\n      m->action = umode_create;\n      umodes = m;\n      modeit = True;\n      action_requested = True;\n      continue;\n    }\n    if (!strcmp(\"--rmmode\", argv[i]))\n    {\n      umode_t* m = malloc(sizeof(umode_t));\n\n      if (++i >= argc)\n        usage();\n      set_name(&m->name, argv[i], name_string | name_xid);\n      m->action = umode_destroy;\n      m->next = umodes;\n      umodes = m;\n      modeit = True;\n      action_requested = True;\n      continue;\n    }\n    if (!strcmp(\"--addmode\", argv[i]))\n    {\n      umode_t* m = malloc(sizeof(umode_t));\n\n      if (++i >= argc)\n        usage();\n      set_name(&m->output, argv[i], name_string | name_xid);\n      if (++i >= argc)\n        usage();\n      set_name(&m->name, argv[i], name_string | name_xid);\n      m->action = umode_add;\n      m->next = umodes;\n      umodes = m;\n      modeit = True;\n      action_requested = True;\n      continue;\n    }\n    if (!strcmp(\"--delmode\", argv[i]))\n    {\n      umode_t* m = malloc(sizeof(umode_t));\n\n      if (++i >= argc)\n        usage();\n      set_name(&m->output, argv[i], name_string | name_xid);\n      if (++i >= argc)\n        usage();\n      set_name(&m->name, argv[i], name_string | name_xid);\n      m->action = umode_delete;\n      m->next = umodes;\n      umodes = m;\n      modeit = True;\n      action_requested = True;\n      continue;\n    }\n    usage();\n  }\n  if (!action_requested)\n    query = True;\n  if (verbose)\n  {\n    query = True;\n    if (setit && !setit_1_2)\n      query_1 = True;\n  }\n\n  /*\n    if (version)\n\tprintf(\"xrandr program version       \" VERSION \"\\n\");\n*/\n\n  dpy = XOpenDisplay(display_name);\n\n  if (dpy == NULL)\n  {\n    fprintf(stderr, \"Can't open display %s\\n\", XDisplayName(display_name));\n    exit(1);\n  }\n  if (screen < 0)\n    screen = DefaultScreen(dpy);\n  if (screen >= ScreenCount(dpy))\n  {\n    fprintf(stderr, \"Invalid screen number %d (display has %d)\\n\", screen, ScreenCount(dpy));\n    exit(1);\n  }\n\n  root = RootWindow(dpy, screen);\n\n  if (!XRRQueryExtension(dpy, &event_base, &error_base) || !XRRQueryVersion(dpy, &major, &minor))\n  {\n    fprintf(stderr, \"RandR extension missing\\n\");\n    exit(1);\n  }\n  if (major > 1 || (major == 1 && minor >= 2))\n    has_1_2 = True;\n  if (major > 1 || (major == 1 && minor >= 3))\n    has_1_3 = True;\n\n  if (has_1_2 && modeit)\n  {\n    umode_t* m;\n\n    get_screen(current);\n    get_crtcs();\n    get_outputs();\n\n    for (m = umodes; m; m = m->next)\n    {\n      XRRModeInfo* e;\n      output_t* o;\n\n      switch (m->action)\n      {\n        case umode_create:\n          XRRCreateMode(dpy, root, &m->mode);\n          break;\n        case umode_destroy:\n          e = find_mode(&m->name, 0);\n          if (!e)\n            fatal(\"cannot find mode \\\"%s\\\"\\n\", m->name.string);\n          XRRDestroyMode(dpy, e->id);\n          break;\n        case umode_add:\n          o = find_output(&m->output);\n          if (!o)\n            fatal(\"cannot find output \\\"%s\\\"\\n\", m->output.string);\n          e = find_mode(&m->name, 0);\n          if (!e)\n            fatal(\"cannot find mode \\\"%s\\\"\\n\", m->name.string);\n          XRRAddOutputMode(dpy, o->output.xid, e->id);\n          break;\n        case umode_delete:\n          o = find_output(&m->output);\n          if (!o)\n            fatal(\"cannot find output \\\"%s\\\"\\n\", m->output.string);\n          e = find_mode(&m->name, 0);\n          if (!e)\n            fatal(\"cannot find mode \\\"%s\\\"\\n\", m->name.string);\n          XRRDeleteOutputMode(dpy, o->output.xid, e->id);\n          break;\n      }\n    }\n    if (!setit_1_2)\n    {\n      XSync(dpy, False);\n      exit(0);\n    }\n  }\n  if (has_1_2 && propit)\n  {\n\n    get_screen(current);\n    get_crtcs();\n    get_outputs();\n\n    for (output = outputs; output; output = output->next)\n    {\n      output_prop_t* prop;\n\n      for (prop = output->props; prop; prop = prop->next)\n      {\n        Atom name = XInternAtom(dpy, prop->name, False);\n        Atom type;\n        int format = 0;\n        unsigned char* data;\n        int nelements;\n        int int_value;\n        unsigned long ulong_value;\n        unsigned char* prop_data;\n        int actual_format;\n        unsigned long nitems, bytes_after;\n        Atom actual_type;\n        XRRPropertyInfo* propinfo;\n\n        type = AnyPropertyType;\n\n        if (XRRGetOutputProperty(dpy, output->output.xid, name, 0, 100, False, False,\n                                 AnyPropertyType, &actual_type, &actual_format, &nitems,\n                                 &bytes_after, &prop_data) == Success &&\n\n            (propinfo = XRRQueryOutputProperty(dpy, output->output.xid, name)))\n        {\n          type = actual_type;\n          format = actual_format;\n        }\n\n        if ((type == XA_INTEGER || type == AnyPropertyType) &&\n            (sscanf(prop->value, \"%d\", &int_value) == 1 ||\n             sscanf(prop->value, \"0x%x\", &int_value) == 1))\n        {\n          type = XA_INTEGER;\n          ulong_value = int_value;\n          data = (unsigned char*)&ulong_value;\n          nelements = 1;\n          format = 32;\n        }\n        else if (type == XA_ATOM)\n        {\n          ulong_value = XInternAtom(dpy, prop->value, False);\n          data = (unsigned char*)&ulong_value;\n          nelements = 1;\n        }\n        else if ((type == XA_STRING || type == AnyPropertyType))\n        {\n          type = XA_STRING;\n          data = (unsigned char*)prop->value;\n          nelements = strlen(prop->value);\n          format = 8;\n        }\n        else\n          continue;\n        XRRChangeOutputProperty(dpy, output->output.xid, name, type, format, PropModeReplace, data,\n                                nelements);\n      }\n    }\n    if (!setit_1_2)\n    {\n      XSync(dpy, False);\n      exit(0);\n    }\n  }\n  if (setit_1_2)\n  {\n    get_screen(current);\n    get_crtcs();\n    get_outputs();\n    set_positions();\n    set_screen_size();\n\n    pick_crtcs();\n\n    /*\n\t * Assign outputs to crtcs\n\t */\n    set_crtcs();\n\n    /*\n\t * Mark changing crtcs\n\t */\n    mark_changing_crtcs();\n\n    /*\n\t * If an output was specified to track dpi, use it\n\t */\n    if (dpi_output)\n    {\n      output_t* output = find_output_by_name(dpi_output);\n      XRROutputInfo* output_info;\n      XRRModeInfo* mode_info;\n      if (!output)\n        fatal(\"Cannot find output %s\\n\", dpi_output);\n      output_info = output->output_info;\n      mode_info = output->mode_info;\n      if (output_info && mode_info && output_info->mm_height)\n      {\n        /*\n\t\t * When this output covers the whole screen, just use\n\t\t * the known physical size\n\t\t */\n        if ((unsigned int)fb_width == mode_info->width &&\n            (unsigned int)fb_height == mode_info->height)\n        {\n          fb_width_mm = output_info->mm_width;\n          fb_height_mm = output_info->mm_height;\n        }\n        else\n        {\n          dpi = (25.4 * mode_info->height) / output_info->mm_height;\n        }\n      }\n    }\n\n    /*\n\t * Compute physical screen size\n\t */\n    if (fb_width_mm == 0 || fb_height_mm == 0)\n    {\n      if (fb_width != DisplayWidth(dpy, screen) || fb_height != DisplayHeight(dpy, screen) ||\n          dpi != 0.0)\n      {\n        if (dpi <= 0)\n          dpi = (25.4 * DisplayHeight(dpy, screen)) / DisplayHeightMM(dpy, screen);\n\n        fb_width_mm = (25.4 * fb_width) / dpi;\n        fb_height_mm = (25.4 * fb_height) / dpi;\n      }\n      else\n      {\n        fb_width_mm = DisplayWidthMM(dpy, screen);\n        fb_height_mm = DisplayHeightMM(dpy, screen);\n      }\n    }\n\n    /*\n\t * Set panning\n\t */\n    set_panning();\n\n    /*\n\t * Set gamma on crtc's that belong to the outputs.\n\t */\n    set_gamma();\n\n    /*\n\t * Now apply all of the changes\n\t */\n    apply();\n\n    XSync(dpy, False);\n    exit(0);\n  }\n  if (query_1_2 || (query && has_1_2 && !query_1))\n  {\n    output_t* output;\n\n#define ModeShown 0x80000000\n\n    get_screen(current);\n    get_crtcs();\n    get_outputs();\n\n    printf(\"<screen id=\\\"%d\\\" minimum_w=\\\"%d\\\" minimum_h=\\\"%d\\\" current_w=\\\"%d\\\" current_h=\\\"%d\\\" \"\n           \"maximum_w=\\\"%d\\\" maximum_h=\\\"%d\\\">\\n\",\n           screen, minWidth, minHeight, DisplayWidth(dpy, screen), DisplayHeight(dpy, screen),\n           maxWidth, maxHeight);\n\n    for (output = outputs; output; output = output->next)\n    {\n      XRROutputInfo* output_info = output->output_info;\n      crtc_t* crtc = output->crtc_info;\n      XRRCrtcInfo* crtc_info = crtc ? crtc->crtc_info : NULL;\n      XRRModeInfo* mode = output->mode_info;\n      Atom* props;\n      int j, k, nprop;\n      Bool* mode_shown;\n      //\t    Rotation\t    rotations = output_rotations (output);\n\n      printf(\"  <output name=\\\"%s\\\" connected=\\\"%s\\\"\", output_info->name,\n             connection[output_info->connection]);\n      if (mode)\n      {\n        if (crtc_info)\n        {\n          printf(\" w=\\\"%d\\\" h=\\\"%d\\\" x=\\\"%d\\\" y=\\\"%d\\\" crtc=\\\"%d\\\"\", crtc_info->width,\n                 crtc_info->height, crtc_info->x, crtc_info->y, crtc->crtc.index);\n        }\n        else\n        {\n          printf(\" w=\\\"%d\\\" h=\\\"%d\\\" x=\\\"%d\\\" y=\\\"%d\\\"\", mode->width, mode->height, output->x,\n                 output->y);\n        }\n        if (verbose)\n          printf(\" id=\\\"%lx\\\"\", mode->id);\n        if (output->rotation != RR_Rotate_0 || verbose)\n        {\n          printf(\" rotation=\\\"%s\\\"\", rotation_name(output->rotation));\n          if (output->rotation & (RR_Reflect_X | RR_Reflect_Y))\n            printf(\" reflection=\\\"%s\\\"\", reflection_name(output->rotation));\n        }\n      }\n      /*\n\t    if (rotations != RR_Rotate_0 || verbose)\n\t    {\n\t\tBool    first = True;\n\t\tprintf (\" (\");\n\t\tfor (i = 0; i < 4; i ++) {\n\t\t    if ((rotations >> i) & 1) {\n\t\t\tif (!first) printf (\" \"); first = False;\n\t\t\tprintf(\"%s\", direction[i]);\n\t\t    }\n\t\t}\n\t\tif (rotations & RR_Reflect_X)\n\t\t{\n\t\t    if (!first) printf (\" \"); first = False;\n\t\t    printf (\"x axis\");\n\t\t}\n\t\tif (rotations & RR_Reflect_Y)\n\t\t{\n\t\t    if (!first) printf (\" \");\n\t\t    printf (\"y axis\");\n\t\t}\n\t\tprintf (\")\");\n\t    }\n*/\n\n      if (mode)\n      {\n        printf(\" wmm=\\\"%d\\\" hmm=\\\"%d\\\"\", (int)output_info->mm_width, (int)output_info->mm_height);\n      }\n\n      if (crtc && crtc->panning_info && crtc->panning_info->width > 0)\n      {\n        XRRPanning* pan = crtc->panning_info;\n        printf(\" panning %dx%d+%d+%d\", pan->width, pan->height, pan->left, pan->top);\n        if ((pan->track_width != 0 &&\n             (pan->track_left != pan->left || pan->track_width != pan->width ||\n              pan->border_left != 0 || pan->border_right != 0)) ||\n            (pan->track_height != 0 &&\n             (pan->track_top != pan->top || pan->track_height != pan->height ||\n              pan->border_top != 0 || pan->border_bottom != 0)))\n          printf(\" tracking %dx%d+%d+%d border %d/%d/%d/%d\", pan->track_width, pan->track_height,\n                 pan->track_left, pan->track_top, pan->border_left, pan->border_top,\n                 pan->border_right, pan->border_bottom);\n      }\n      printf(\">\\n\");\n\n      if (verbose)\n      {\n        printf(\"\\tIdentifier: 0x%x\\n\", (int)output->output.xid);\n        printf(\"\\tTimestamp:  %d\\n\", (int)output_info->timestamp);\n        printf(\"\\tSubpixel:   %s\\n\", order[output_info->subpixel_order]);\n        if (output->gamma.red != 0.0f && output->gamma.green != 0.0f && output->gamma.blue != 0.0f)\n        {\n          printf(\"\\tGamma:      %#.2g:%#.2g:%#.2g\\n\", (double)output->gamma.red,\n                 (double)output->gamma.green, (double)output->gamma.blue);\n          printf(\"\\tBrightness: %#.2g\\n\", (double)output->brightness);\n        }\n        printf(\"\\tClones:    \");\n        for (j = 0; j < output_info->nclone; j++)\n        {\n          output_t* clone = find_output_by_xid(output_info->clones[j]);\n\n          if (clone)\n            printf(\" %s\", clone->output.string);\n        }\n        printf(\"\\n\");\n        if (output->crtc_info)\n          printf(\"\\tCRTC:       %d\\n\", output->crtc_info->crtc.index);\n        printf(\"\\tCRTCs:     \");\n        for (j = 0; j < output_info->ncrtc; j++)\n        {\n          crtc_t* crtc = find_crtc_by_xid(output_info->crtcs[j]);\n          if (crtc)\n            printf(\" %d\", crtc->crtc.index);\n        }\n        printf(\"\\n\");\n        if (output->crtc_info && output->crtc_info->panning_info)\n        {\n          XRRPanning* pan = output->crtc_info->panning_info;\n          printf(\"\\tPanning:    %dx%d+%d+%d\\n\", pan->width, pan->height, pan->left, pan->top);\n          printf(\"\\tTracking:   %dx%d+%d+%d\\n\", pan->track_width, pan->track_height,\n                 pan->track_left, pan->track_top);\n          printf(\"\\tBorder:     %d/%d/%d/%d\\n\", pan->border_left, pan->border_top,\n                 pan->border_right, pan->border_bottom);\n        }\n      }\n      if (verbose)\n      {\n        int x, y;\n\n        printf(\"\\tTransform: \");\n        for (y = 0; y < 3; y++)\n        {\n          for (x = 0; x < 3; x++)\n            printf(\" %f\", XFixedToDouble(output->transform.transform.matrix[y][x]));\n          if (y < 2)\n            printf(\"\\n\\t           \");\n        }\n        if (output->transform.filter)\n          printf(\"\\n\\t           filter: %s\", output->transform.filter);\n        printf(\"\\n\");\n      }\n      if (verbose || properties)\n      {\n        props = XRRListOutputProperties(dpy, output->output.xid, &nprop);\n        for (j = 0; j < nprop; j++)\n        {\n          unsigned char* prop;\n          int actual_format;\n          unsigned long nitems, bytes_after;\n          Atom actual_type;\n          XRRPropertyInfo* propinfo;\n\n          XRRGetOutputProperty(dpy, output->output.xid, props[j], 0, 100, False, False,\n                               AnyPropertyType, &actual_type, &actual_format, &nitems, &bytes_after,\n                               &prop);\n\n          propinfo = XRRQueryOutputProperty(dpy, output->output.xid, props[j]);\n\n          if (actual_type == XA_INTEGER && actual_format == 8)\n          {\n            int k;\n\n            printf(\"\\t%s:\\n\", XGetAtomName(dpy, props[j]));\n            for (k = 0; k < (long)nitems; k++)\n            {\n              if (k % 16 == 0)\n                printf(\"\\t\\t\");\n              printf(\"%02x\", (unsigned char)prop[k]);\n              if (k % 16 == 15)\n                printf(\"\\n\");\n            }\n          }\n          else if (actual_type == XA_INTEGER && actual_format == 32)\n          {\n            printf(\"\\t%s: \", XGetAtomName(dpy, props[j]));\n            for (k = 0; k < (long)nitems; k++)\n            {\n              if (k > 0)\n                printf(\"\\n\\t\\t\\t\");\n              printf(\"%d (0x%08x)\", (int)((INT32*)prop)[k], (int)((INT32*)prop)[k]);\n            }\n\n            if (propinfo->range && propinfo->num_values > 0)\n            {\n              if (nitems > 1)\n                printf(\"\\n\\t\\t\");\n              printf(\"\\trange%s: \", (propinfo->num_values == 2) ? \"\" : \"s\");\n\n              for (k = 0; k < propinfo->num_values / 2; k++)\n                printf(\" (%d,%d)\", (int)propinfo->values[k * 2], (int)propinfo->values[k * 2 + 1]);\n            }\n\n            printf(\"\\n\");\n          }\n          else if (actual_type == XA_ATOM && actual_format == 32)\n          {\n            printf(\"\\t%s:\", XGetAtomName(dpy, props[j]));\n            for (k = 0; k < (long)nitems; k++)\n            {\n              if (k > 0 && (k & 1) == 0)\n                printf(\"\\n\\t\\t\");\n              printf(\"\\t%s\", XGetAtomName(dpy, ((Atom*)prop)[k]));\n            }\n\n            if (!propinfo->range && propinfo->num_values > 0)\n            {\n              printf(\"\\n\\t\\tsupported:\");\n\n              for (k = 0; k < propinfo->num_values; k++)\n              {\n                printf(\" %-12.12s\", XGetAtomName(dpy, propinfo->values[k]));\n                if (k % 4 == 3 && k < propinfo->num_values - 1)\n                  printf(\"\\n\\t\\t          \");\n              }\n            }\n            printf(\"\\n\");\n          }\n          else if (actual_format == 8)\n          {\n            printf(\"\\t%s: %s%s\\n\", XGetAtomName(dpy, props[j]), prop, bytes_after ? \"...\" : \"\");\n          }\n          else\n          {\n            char* type = actual_type ? XGetAtomName(dpy, actual_type) : \"none\";\n            printf(\"\\t%s: %s(%d) (format %d items %d) ????\\n\", XGetAtomName(dpy, props[j]), type,\n                   (int)actual_type, actual_format, (int)nitems);\n          }\n\n          free(propinfo);\n        }\n      }\n\n      if (verbose)\n      {\n        for (j = 0; j < output_info->nmode; j++)\n        {\n          XRRModeInfo* mode = find_mode_by_xid(output_info->modes[j]);\n          int f;\n\n          printf(\"  %s (0x%x) %6.1fMHz\", mode->name, (int)mode->id,\n                 (double)mode->dotClock / 1000000.0);\n          for (f = 0; mode_flags[f].flag; f++)\n            if (mode->modeFlags & mode_flags[f].flag)\n              printf(\" %s\", mode_flags[f].string);\n          if (mode == output->mode_info)\n            printf(\" *current\");\n          if (j < output_info->npreferred)\n            printf(\" +preferred\");\n          printf(\"\\n\");\n          printf(\"        h: width  %4d start %4d end %4d total %4d skew %4d clock %6.1fKHz\\n\",\n                 mode->width, mode->hSyncStart, mode->hSyncEnd, mode->hTotal, mode->hSkew,\n                 mode_hsync(mode) / 1000);\n          printf(\"        v: height %4d start %4d end %4d total %4d           clock %6.1fHz\\n\",\n                 mode->height, mode->vSyncStart, mode->vSyncEnd, mode->vTotal, mode_refresh(mode));\n          mode->modeFlags |= ModeShown;\n        }\n      }\n      else\n      {\n        mode_shown = calloc(output_info->nmode, sizeof(Bool));\n        if (!mode_shown)\n          fatal(\"out of memory\\n\");\n        for (j = 0; j < output_info->nmode; j++)\n        {\n          XRRModeInfo *jmode, *kmode;\n\n          if (mode_shown[j])\n            continue;\n\n          jmode = find_mode_by_xid(output_info->modes[j]);\n          for (k = j; k < output_info->nmode; k++)\n          {\n            if (mode_shown[k])\n              continue;\n            kmode = find_mode_by_xid(output_info->modes[k]);\n            if (strcmp(jmode->name, kmode->name) != 0)\n              continue;\n            mode_shown[k] = True;\n            kmode->modeFlags |= ModeShown;\n            printf(\"    <mode id=\\\"0x%lx\\\" name=\\\"%s\\\" w=\\\"%d\\\" h=\\\"%d\\\" hz=\\\"%.5f\\\"\", kmode->id,\n                   kmode->name, kmode->width, kmode->height, mode_refresh(kmode));\n            if (kmode == output->mode_info)\n              printf(\" current=\\\"true\\\"\");\n            else\n              printf(\" current=\\\"false\\\"\");\n            if (k < output_info->npreferred)\n              printf(\" preferred=\\\"true\\\"\");\n            else\n              printf(\" preferred=\\\"false\\\"\");\n            printf(\"/>\\n\");\n          }\n        }\n        free(mode_shown);\n      }\n      printf(\"  </output>\\n\");\n    }\n\n    /*\n\tfor (m = 0; m < res->nmode; m++)\n\t{\n\t    XRRModeInfo\t*mode = &res->modes[m];\n\n\t    if (!(mode->modeFlags & ModeShown))\n\t    {\n\t\tprintf (\"  %s (0x%x) %6.1fMHz\\n\",\n\t\t\tmode->name, (int)mode->id,\n\t\t\t(double)mode->dotClock / 1000000.0);\n\t\tprintf (\"        h: width  %4d start %4d end %4d total %4d skew %4d clock %6.1fKHz\\n\",\n\t\t\tmode->width, mode->hSyncStart, mode->hSyncEnd,\n\t\t\tmode->hTotal, mode->hSkew, mode_hsync (mode) / 1000);\n\t\tprintf (\"        v: height %4d start %4d end %4d total %4d           clock %6.1fHz\\n\",\n\t\t\tmode->height, mode->vSyncStart, mode->vSyncEnd, mode->vTotal,\n\t\t\tmode_refresh (mode));\n\t    }\n\t}\n*/\n    printf(\"</screen>\\n\");\n    exit(0);\n  }\n\n  sc = XRRGetScreenInfo(dpy, root);\n\n  if (sc == NULL)\n    exit(1);\n\n  current_size = XRRConfigCurrentConfiguration(sc, &current_rotation);\n\n  sizes = XRRConfigSizes(sc, &nsize);\n\n  if (have_pixel_size)\n  {\n    for (size = 0; size < nsize; size++)\n    {\n      if (sizes[size].width == width && sizes[size].height == height)\n        break;\n    }\n    if (size >= nsize)\n    {\n      fprintf(stderr, \"Size %dx%d not found in available modes\\n\", width, height);\n      exit(1);\n    }\n  }\n  else if (size < 0)\n    size = current_size;\n  else if (size >= nsize)\n  {\n    fprintf(stderr, \"Size index %d is too large, there are only %d sizes\\n\", size, nsize);\n    exit(1);\n  }\n\n  if (rot < 0)\n  {\n    for (rot = 0; rot < 4; rot++)\n      if (1 << rot == (current_rotation & 0xf))\n        break;\n  }\n\n  current_rate = XRRConfigCurrentRate(sc);\n\n  if (rate < 0)\n  {\n    if (size == current_size)\n      rate = current_rate;\n    else\n      rate = 0;\n  }\n  else\n  {\n    rates = XRRConfigRates(sc, size, &nrate);\n    for (i = 0; i < nrate; i++)\n      if (rate == rates[i])\n        break;\n    if (i == nrate)\n    {\n      fprintf(stderr, \"Rate %.1f Hz not available for this size\\n\", rate);\n      exit(1);\n    }\n  }\n\n  if (version)\n  {\n    int major_version, minor_version;\n    XRRQueryVersion(dpy, &major_version, &minor_version);\n    printf(\"Server reports RandR version %d.%d\\n\", major_version, minor_version);\n  }\n\n  if (query || query_1)\n  {\n    printf(\" SZ:    Pixels          Physical       Refresh\\n\");\n    for (i = 0; i < nsize; i++)\n    {\n      printf(\"%c%-2d %5d x %-5d  (%4dmm x%4dmm )\", i == current_size ? '*' : ' ', i, sizes[i].width,\n             sizes[i].height, sizes[i].mwidth, sizes[i].mheight);\n      rates = XRRConfigRates(sc, i, &nrate);\n      if (nrate)\n        printf(\"  \");\n      for (j = 0; j < nrate; j++)\n        printf(\"%c%-4d\", i == current_size && rates[j] == current_rate ? '*' : ' ', rates[j]);\n      printf(\"\\n\");\n    }\n  }\n\n  rotations = XRRConfigRotations(sc, &current_rotation);\n\n  rotation = 1 << rot;\n  if (query)\n  {\n    printf(\"Current rotation - %s\\n\", rotation_name(current_rotation));\n\n    printf(\"Current reflection - %s\\n\", reflection_name(current_rotation));\n\n    printf(\"Rotations possible - \");\n    for (i = 0; i < 4; i++)\n    {\n      if ((rotations >> i) & 1)\n        printf(\"%s \", direction[i]);\n    }\n    printf(\"\\n\");\n\n    printf(\"Reflections possible - \");\n    if (rotations & (RR_Reflect_X | RR_Reflect_Y))\n    {\n      if (rotations & RR_Reflect_X)\n        printf(\"X Axis \");\n      if (rotations & RR_Reflect_Y)\n        printf(\"Y Axis\");\n    }\n    else\n      printf(\"none\");\n    printf(\"\\n\");\n  }\n\n  if (verbose)\n  {\n    printf(\"Setting size to %d, rotation to %s\\n\", size, direction[rot]);\n\n    printf(\"Setting reflection on \");\n    if (reflection)\n    {\n      if (reflection & RR_Reflect_X)\n        printf(\"X Axis \");\n      if (reflection & RR_Reflect_Y)\n        printf(\"Y Axis\");\n    }\n    else\n      printf(\"neither axis\");\n    printf(\"\\n\");\n\n    if (reflection & RR_Reflect_X)\n      printf(\"Setting reflection on X axis\\n\");\n\n    if (reflection & RR_Reflect_Y)\n      printf(\"Setting reflection on Y axis\\n\");\n  }\n\n  /* we should test configureNotify on the root window */\n  XSelectInput(dpy, root, StructureNotifyMask);\n\n  if (setit && !dryrun)\n    XRRSelectInput(dpy, root, RRScreenChangeNotifyMask);\n  if (setit && !dryrun)\n    status = XRRSetScreenConfigAndRate(dpy, sc, root, (SizeID)size,\n                                       (Rotation)(rotation | reflection), rate, CurrentTime);\n\n  if (setit && !dryrun && status == RRSetConfigFailed)\n  {\n    printf(\"Failed to change the screen configuration!\\n\");\n    ret = 1;\n  }\n\n  if (verbose && setit && !dryrun && size != current_size)\n  {\n    if (status == RRSetConfigSuccess)\n    {\n      Bool seen_screen = False;\n      while (!seen_screen)\n      {\n        int spo;\n        XNextEvent(dpy, (XEvent*)&event);\n\n        printf(\"Event received, type = %d\\n\", event.type);\n        /* update Xlib's knowledge of the event */\n        XRRUpdateConfiguration((XEvent*)&event);\n        if (event.type == ConfigureNotify)\n          printf(\"Received ConfigureNotify Event!\\n\");\n\n        switch (event.type - event_base)\n        {\n          case RRScreenChangeNotify:\n            sce = (XRRScreenChangeNotifyEvent*)&event;\n\n            printf(\"Got a screen change notify event!\\n\");\n            printf(\" window = %d\\n root = %d\\n size_index = %d\\n rotation %d\\n\", (int)sce->window,\n                   (int)sce->root, sce->size_index, sce->rotation);\n            printf(\" timestamp = %ld, config_timestamp = %ld\\n\", sce->timestamp,\n                   sce->config_timestamp);\n            printf(\" Rotation = %x\\n\", sce->rotation);\n            printf(\" %d X %d pixels, %d X %d mm\\n\", sce->width, sce->height, sce->mwidth,\n                   sce->mheight);\n            printf(\"Display width   %d, height   %d\\n\", DisplayWidth(dpy, screen),\n                   DisplayHeight(dpy, screen));\n            printf(\"Display widthmm %d, heightmm %d\\n\", DisplayWidthMM(dpy, screen),\n                   DisplayHeightMM(dpy, screen));\n            spo = sce->subpixel_order;\n            if ((spo < 0) || (spo > 5))\n              printf(\"Unknown subpixel order, value = %d\\n\", spo);\n            else\n              printf(\"new Subpixel rendering model is %s\\n\", order[spo]);\n            seen_screen = True;\n            break;\n          default:\n            if (event.type != ConfigureNotify)\n              printf(\"unknown event received, type = %d!\\n\", event.type);\n        }\n      }\n    }\n  }\n  XRRFreeScreenConfigInfo(sc);\n  return (ret);\n}\n"
        },
        {
          "name": "xbmc",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}