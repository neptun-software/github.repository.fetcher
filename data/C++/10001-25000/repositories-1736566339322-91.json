{
  "metadata": {
    "timestamp": 1736566339322,
    "page": 91,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "davisking/dlib",
      "stars": 13681,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2509765625,
          "content": "**/.idea\n*~\n*.swp\n*.o\n*.so\n*.pyc\nbuild\nbuild2\ndist\n*.egg-info/\ndocs/release/\ndocs/docs/web/\ndocs/docs/chm/\ndocs/docs/cache/\ndocs/docs/git-logs.xml\ndocs/docs/python/classes.txt\ndocs/docs/python/functions.txt\ndocs/docs/python/constants.txt\n**/.vscode\n**/venv\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 1.6142578125,
          "content": "cmake_minimum_required(VERSION 3.8.0)\n\nproject(dlib_project)\n\n\n\n#############################################################################\n#                                                                           #\n#  READ examples/CMakeLists.txt TO SEE HOW TO USE DLIB FROM C++ WITH CMAKE  #\n#                                                                           #\n#############################################################################\n\n\n\n\n\nget_directory_property(has_parent PARENT_DIRECTORY)\nif(NOT has_parent)\n   # When you call add_subdirectory(dlib) from a parent CMake project dlib's\n   # CMake scripts will assume you want to statically compile dlib into\n   # whatever you are building rather than create a standalone copy of dlib.\n   # This means CMake will build dlib as a static library, disable dlib's\n   # install targets so they don't clutter your project, and adjust a few other\n   # minor things that are convenient when statically building dlib as part of\n   # your own projects.\n   #\n   # On the other hand, if there is no parent CMake project or if\n   # DLIB_IN_PROJECT_BUILD is set to false, CMake will compile dlib as a normal\n   # standalone library (either shared or static, based on the state of CMake's\n   # BUILD_SHARED_LIBS flag), and include the usual install targets so you can\n   # install dlib on your computer via `make install`.  Since the only reason\n   # to build this CMakeLists.txt (the one you are reading right now) by itself\n   # is if you want to install dlib, we indicate as such by setting\n   # DLIB_IN_PROJECT_BUILD to false.\n   set(DLIB_IN_PROJECT_BUILD false)\nendif()\nadd_subdirectory(dlib)\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.3056640625,
          "content": "Boost Software License - Version 1.0 - August 17th, 2003\n\nPermission is hereby granted, free of charge, to any person or organization\nobtaining a copy of the software and accompanying documentation covered by\nthis license (the \"Software\") to use, reproduce, display, distribute,\nexecute, and transmit the Software, and to prepare derivative works of the\nSoftware, and to permit third-parties to whom the Software is furnished to\ndo so, all subject to the following:\n\nThe copyright notices in the Software and this entire statement, including\nthe above license grant, this restriction and the following disclaimer,\nmust be included in all copies of the Software, in whole or in part, and\nall derivative works of the Software, unless such copies or derivative\nworks are solely in the form of machine-executable object code generated by\na source language processor.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT\nSHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE\nFOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE."
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.3427734375,
          "content": "#\n# MANIFEST.in\n#\n# Manifest template for creating the dlib source distribution.\n\ninclude MANIFEST.in\ninclude setup.py\ninclude README.md\n\n# sources\nrecursive-include dlib **\nrecursive-include python_examples *.txt *.py \nrecursive-include tools/python **\n\nprune tools/python/build*\nprune dlib/cmake_utils/*/build*\nprune dlib/test\n\nglobal-exclude *.pyc\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.3046875,
          "content": "# dlib C++ library  [![GitHub Actions C++ Status](https://github.com/davisking/dlib/actions/workflows/build_cpp.yml/badge.svg)](https://github.com/davisking/dlib/actions/workflows/build_cpp.yml) [![GitHub Actions Python Status](https://github.com/davisking/dlib/actions/workflows/build_python.yml/badge.svg)](https://github.com/davisking/dlib/actions/workflows/build_python.yml)\n\nDlib is a modern C++ toolkit containing machine learning algorithms and tools for creating complex software in C++ to solve real world problems. See [http://dlib.net](http://dlib.net) for the main project documentation and API reference.\n\n\n\n## Compiling dlib C++ example programs\n\nGo into the examples folder and type:\n\n```bash\nmkdir build; cd build; cmake .. ; cmake --build .\n```\n\nThat will build all the examples.\nIf you have a CPU that supports AVX instructions then turn them on like this:\n\n```bash\nmkdir build; cd build; cmake .. -DUSE_AVX_INSTRUCTIONS=1; cmake --build .\n```\n\nDoing so will make some things run faster.\n\nFinally, Visual Studio users should usually do everything in 64bit mode.  By default Visual Studio is 32bit, both in its outputs and its own execution, so you have to explicitly tell it to use 64bits.  Since it's not the 1990s anymore you probably want to use 64bits.  Do that with a cmake invocation like this:\n```bash\ncmake .. -G \"Visual Studio 14 2015 Win64\" -T host=x64 \n```\n\n## Compiling your own C++ programs that use dlib\n\nThe examples folder has a [CMake tutorial](https://github.com/davisking/dlib/blob/master/examples/CMakeLists.txt) that tells you what to do.  There are also additional instructions on the [dlib web site](http://dlib.net/compile.html).\n\nAlternatively, if you are using the [vcpkg](https://github.com/Microsoft/vcpkg/) dependency manager you can download and install dlib with CMake integration in a single command:\n```bash\nvcpkg install dlib\n```\n\n## Compiling dlib Python API\n\nBefore you can run the Python example programs you must install the build requirement.\n```bash\npython -m venv venv\npip install build\n```\n\nThen you must compile dlib and install it in your environment. Type:\n```bash\npython -m build --wheel\npip install dist/dlib-<version>.whl\n```\n\nOr download dlib using PyPi:\n```bash\npip install dlib\n```\n\n## Running the unit test suite\n\nType the following to compile and run the dlib unit test suite:\n\n```bash\ncd dlib/test\nmkdir build\ncd build\ncmake ..\ncmake --build . --config Release\n./dtest --runall\n```\n\nNote that on windows your compiler might put the test executable in a subfolder called `Release`. If that's the case then you have to go to that folder before running the test.\n\nThis library is licensed under the Boost Software License, which can be found in [dlib/LICENSE.txt](https://github.com/davisking/dlib/blob/master/dlib/LICENSE.txt).  The long and short of the license is that you can use dlib however you like, even in closed source commercial software.\n\n## dlib sponsors\n\nThis research is based in part upon work supported by the Office of the Director of National Intelligence (ODNI), Intelligence Advanced Research Projects Activity (IARPA) under contract number 2014-14071600010. The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of ODNI, IARPA, or the U.S. Government.\n\n"
        },
        {
          "name": "dlib",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 0.087890625,
          "content": "[build-system]\nrequires = [\"setuptools\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n"
        },
        {
          "name": "python_examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 11.21484375,
          "content": "\"\"\"setup for the dlib project\n Copyright (C) 2015  Ehsan Azar (dashesy@linux.com)\n License: Boost Software License   See LICENSE.txt for the full license.\n\nThis file basically just uses CMake to compile the dlib python bindings project\nlocated in the tools/python folder and then puts the outputs into standard\npython packages.\n\nTo build dlib:\n    python setup.py build\nTo build and install:\n    python setup.py install\nTo upload the source distribution to PyPi\n    python setup.py sdist \n    twine upload dist/dlib-*.tar.gz\nTo exclude certain options in the cmake config use --no:\n    for example:\n    --no USE_AVX_INSTRUCTIONS: will set -DUSE_AVX_INSTRUCTIONS=no\nAdditional options:\n    --compiler-flags: pass flags onto the compiler, e.g. --compiler-flags \"-Os -Wall\" passes -Os -Wall onto GCC.\n    -G: Set the CMake generator.  E.g. -G \"Visual Studio 14 2015\"\n    --clean: delete any previous build folders and rebuild.  You should do this if you change any build options\n             by setting --compiler-flags or --no since the last time you ran a build.  This will\n             ensure the changes take effect.\n    --set: set arbitrary cmake options e.g. --set CUDA_HOST_COMPILER=/usr/bin/gcc-6.4.0\n           passes -DCUDA_HOST_COMPILER=/usr/bin/gcc-6.4.0 to CMake.\n\"\"\"\nimport os\nimport re\nimport sys\nimport shutil\nimport platform\nimport subprocess\nimport multiprocessing\nfrom distutils import log\nfrom math import ceil,floor\n\nfrom setuptools import find_packages, setup, Extension\nfrom setuptools.command.build_ext import build_ext\nfrom distutils.version import LooseVersion\n\n\ndef get_extra_cmake_options():\n    \"\"\"read --clean, --no, --set, --compiler-flags, and -G options from the command line and add them as cmake switches.\n    \"\"\"\n    _cmake_extra_options = []\n    _clean_build_folder = False\n\n    opt_key = None\n\n    argv = [arg for arg in sys.argv]  # take a copy\n    # parse command line options and consume those we care about\n    for arg in argv:\n        if opt_key == 'compiler-flags':\n            _cmake_extra_options.append('-DCMAKE_CXX_FLAGS={arg}'.format(arg=arg.strip()))\n        elif opt_key == 'G':\n            _cmake_extra_options += ['-G', arg.strip()]\n        elif opt_key == 'no':\n            _cmake_extra_options.append('-D{arg}=no'.format(arg=arg.strip()))\n        elif opt_key == 'set':\n            _cmake_extra_options.append('-D{arg}'.format(arg=arg.strip()))\n\n        if opt_key:\n            sys.argv.remove(arg)\n            opt_key = None\n            continue\n\n        if arg == '--clean':\n            _clean_build_folder = True\n            sys.argv.remove(arg)\n            continue\n\n        if arg == '--yes':\n            print(\"The --yes options to dlib's setup.py don't do anything since all these options \")\n            print(\"are on by default.  So --yes has been removed.  Do not give it to setup.py.\")\n            sys.exit(1)\n        if arg in ['--no', '--set', '--compiler-flags']:\n            opt_key = arg[2:].lower()\n            sys.argv.remove(arg)\n            continue\n        if arg in ['-G']:\n            opt_key = arg[1:]\n            sys.argv.remove(arg)\n            continue\n\n    return _cmake_extra_options, _clean_build_folder\n\ncmake_extra_options,clean_build_folder = get_extra_cmake_options()\n\n\nclass CMakeExtension(Extension):\n    def __init__(self, name, sourcedir=''):\n        Extension.__init__(self, name, sources=[])\n        self.sourcedir = os.path.abspath(sourcedir)\n\ndef rmtree(name):\n    \"\"\"remove a directory and its subdirectories.\n    \"\"\"\n    def remove_read_only(func, path, exc):\n        excvalue = exc[1]\n        if func in (os.rmdir, os.remove) and excvalue.errno == errno.EACCES:\n            os.chmod(path, stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO)\n            func(path)\n        else:\n            raise\n\n    if os.path.exists(name):\n        log.info('Removing old directory {}'.format(name))\n        shutil.rmtree(name, ignore_errors=False, onerror=remove_read_only)\n\n\nclass CMakeBuild(build_ext):\n\n    def get_cmake_version(self):\n        try:\n            out = subprocess.check_output(['cmake', '--version'])\n        except:\n            sys.stderr.write(\"\"\"\n================================================================================\n================================================================================\n================================================================================\n\n                   CMake is not installed on your system!\n\n    Or it is possible some broken copy of cmake is installed on your system.\n    It is unfortunately very common for python package managers to include\n    broken copies of cmake.  So if the error above this refers to some file\n    path to a cmake file inside a python or anaconda or miniconda path then you\n    should delete that broken copy of cmake from your computer.\n\n    Instead, please get an official copy of cmake from one of these known good\n    sources of an official cmake:\n        - cmake.org (this is how windows users should get cmake)\n        - apt install cmake (for Ubuntu or Debian based systems)\n        - yum install cmake (for Redhat or CenOS based systems)\n\n    On a linux machine you can run `which cmake` to see what cmake you are\n    actually using.  If it tells you it's some cmake from any kind of python\n    packager delete it and install an official cmake.\n\n    More generally, cmake is not installed if when you open a terminal window\n    and type \n       cmake --version\n    you get an error.  So you can use that as a very basic test to see if you\n    have cmake installed.  That is, if cmake --version doesn't run from the\n    same terminal window from which you are reading this error message, then\n    you have not installed cmake.  Windows users should take note that they\n    need to tell the cmake installer to add cmake to their PATH.  Since you\n    can't run commands that are not in your PATH.  This is how the PATH works\n    on Linux as well, but failing to add cmake to the PATH is a particularly\n    common problem on windows and rarely a problem on Linux.\n\n================================================================================\n================================================================================\n================================================================================\n\"\"\") \n            sys.exit(1)\n        return re.search(r'version\\s*([\\d.]+)', out.decode()).group(1)\n\n    def run(self):\n        cmake_version = self.get_cmake_version()\n        if platform.system() == \"Windows\":\n            if LooseVersion(cmake_version) < '3.1.0':\n                sys.stderr.write(\"\\nERROR: CMake >= 3.1.0 is required on Windows\\n\\n\")\n                sys.exit(1)\n\n        for ext in self.extensions:\n            self.build_extension(ext)\n\n    def build_extension(self, ext):\n        extdir = os.path.abspath(os.path.dirname(self.get_ext_fullpath(ext.name)))\n\n        cmake_args = ['-DCMAKE_LIBRARY_OUTPUT_DIRECTORY=' + extdir,\n                      '-DPYTHON_EXECUTABLE=' + sys.executable,\n                      '-DDLIB_USE_FFMPEG=OFF',]\n\n        cmake_args += cmake_extra_options \n\n        cfg = 'Debug' if self.debug else 'Release'\n        build_args = ['--config', cfg]\n\n        if platform.system() == \"Windows\":\n            cmake_args += ['-DCMAKE_LIBRARY_OUTPUT_DIRECTORY_{}={}'.format(cfg.upper(), extdir)]\n            if sys.maxsize > 2**32:\n                cmake_args += ['-A', 'x64']\n            # Do a parallel build\n            build_args += ['--', '/m'] \n        else:\n            cmake_args += ['-DCMAKE_BUILD_TYPE=' + cfg]\n            # Do a parallel build\n            build_args += ['--', '-j'+str(num_available_cpu_cores(2))]\n\n        build_folder = os.path.abspath(self.build_temp)\n\n        if clean_build_folder:\n            rmtree(build_folder)\n        if not os.path.exists(build_folder):\n            os.makedirs(build_folder)\n\n        cmake_setup = ['cmake', ext.sourcedir] + cmake_args\n        cmake_build = ['cmake', '--build', '.'] + build_args\n\n        print(\"Building extension for Python {}\".format(sys.version.split('\\n',1)[0]))\n        print(\"Invoking CMake setup: '{}'\".format(' '.join(cmake_setup)))\n        sys.stdout.flush()\n        subprocess.check_call(cmake_setup, cwd=build_folder)\n        print(\"Invoking CMake build: '{}'\".format(' '.join(cmake_build)))\n        sys.stdout.flush()\n        subprocess.check_call(cmake_build, cwd=build_folder)\n\ndef num_available_cpu_cores(ram_per_build_process_in_gb):\n    if 'TRAVIS' in os.environ and os.environ['TRAVIS']=='true':\n        # When building on travis-ci, just use 2 cores since travis-ci limits\n        # you to that regardless of what the hardware might suggest.\n        return 2\n    elif 'CMAKE_BUILD_PARALLEL_LEVEL' in os.environ and os.environ['CMAKE_BUILD_PARALLEL_LEVEL'].isnumeric():\n        return int(os.environ['CMAKE_BUILD_PARALLEL_LEVEL'])\n    try:\n        mem_bytes = os.sysconf('SC_PAGE_SIZE') * os.sysconf('SC_PHYS_PAGES')  \n        mem_gib = mem_bytes/(1024.**3)\n        num_cores = multiprocessing.cpu_count() \n        # make sure we have enough ram for each build process.\n        mem_cores = int(floor(mem_gib/float(ram_per_build_process_in_gb)+0.5));\n        # We are limited either by RAM or CPU cores.  So pick the limiting amount\n        # and return that.\n        return max(min(num_cores, mem_cores), 1)\n    except ValueError:\n        return 2 # just assume 2 if we can't get the os to tell us the right answer.\n\n\ndef read_version_from_cmakelists(cmake_file):\n    \"\"\"Read version information\n    \"\"\"\n    major = re.findall(\"set\\(CPACK_PACKAGE_VERSION_MAJOR.*\\\"(.*)\\\"\", open(cmake_file).read())[0]\n    minor = re.findall(\"set\\(CPACK_PACKAGE_VERSION_MINOR.*\\\"(.*)\\\"\", open(cmake_file).read())[0]\n    patch = re.findall(\"set\\(CPACK_PACKAGE_VERSION_PATCH.*\\\"(.*)\\\"\", open(cmake_file).read())[0]\n    return major + '.' + minor + '.' + patch\n\ndef read_entire_file(fname):\n    \"\"\"Read text out of a file relative to setup.py.  \"\"\"\n    return open(os.path.join(fname)).read()\n\nsetup(\n    name='dlib',\n    version=read_version_from_cmakelists('dlib/CMakeLists.txt'),\n    description='A toolkit for making real world machine learning and data analysis applications',\n    long_description='See http://dlib.net for documentation.',\n    author='Davis King',\n    author_email='davis@dlib.net',\n    url='https://github.com/davisking/dlib',\n    license='Boost Software License',\n    ext_modules=[CMakeExtension('_dlib_pybind11','tools/python')],\n    cmdclass=dict(build_ext=CMakeBuild),\n    zip_safe=False,\n    #install_requires=['cmake'], # removed because the pip cmake package is busted, maybe someday it will be usable.\n    packages=find_packages(exclude=['python_examples']),\n    package_dir={'': 'tools/python'},\n    keywords=['dlib', 'Computer Vision', 'Machine Learning'],\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'Intended Audience :: Science/Research',\n        'Intended Audience :: Developers',\n        'Operating System :: MacOS :: MacOS X',\n        'Operating System :: POSIX',\n        'Operating System :: POSIX :: Linux',\n        'Operating System :: Microsoft',\n        'Operating System :: Microsoft :: Windows',\n        'Programming Language :: C++',\n        'Programming Language :: Python',\n        'Topic :: Scientific/Engineering',\n        'Topic :: Scientific/Engineering :: Artificial Intelligence',\n        'Topic :: Scientific/Engineering :: Image Recognition',\n        'Topic :: Software Development',\n    ],\n)\n"
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}