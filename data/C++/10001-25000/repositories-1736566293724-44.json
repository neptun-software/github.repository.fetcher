{
  "metadata": {
    "timestamp": 1736566293724,
    "page": 44,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "qinguoyi/TinyWebServer",
      "stars": 17229,
      "defaultBranch": "master",
      "files": [
        {
          "name": "CGImysql",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.8984375,
          "content": "\n\nTinyWebServer\n===============\nLinux下C++轻量级Web服务器，助力初学者快速实践网络编程，搭建属于自己的服务器.\n\n* 使用 **线程池 + 非阻塞socket + epoll(ET和LT均实现) + 事件处理(Reactor和模拟Proactor均实现)** 的并发模型\n* 使用**状态机**解析HTTP请求报文，支持解析**GET和POST**请求\n* 访问服务器数据库实现web端用户**注册、登录**功能，可以请求服务器**图片和视频文件**\n* 实现**同步/异步日志系统**，记录服务器运行状态\n* 经Webbench压力测试可以实现**上万的并发连接**数据交换\n\n\n写在前面\n----\n* 本项目开发维护过程中，很多童鞋曾发红包支持，我都一一谢绝。我现在不会，将来也不会将本项目包装成任何课程售卖，更不会开通任何支持通道。\n* 目前网络上有人或对本项目，或对游双大佬的项目包装成课程售卖。请各位童鞋擦亮眼，辨识各大学习/求职网站的C++服务器项目，不要盲目付费。\n* 有面试官大佬通过项目信息在公司内找到我，发现很多童鞋简历上都用了这个项目。但，在面试过程中发现`很多童鞋通过本项目入门了，但是对于一些东西还是属于知其然不知其所以然的状态，需要加强下基础知识的学习`，推荐认真阅读下\n    * 《unix环境高级编程》\n    * 《unix网络编程》\n* 感谢各位大佬，各位朋友，各位童鞋的认可和支持。如果本项目能带你入门，将是我莫大的荣幸。\n\n\n目录\n-----\n\n| [概述](#概述) | [框架](#框架) | [Demo演示](#Demo演示) | [压力测试](#压力测试) |[更新日志](#更新日志) |[源码下载](#源码下载) | [快速运行](#快速运行) | [个性化运行](#个性化运行) | [庖丁解牛](#庖丁解牛) | [CPP11实现](#CPP11实现) |[致谢](#致谢) |\n|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n\n\n概述\n----------\n\n> * C/C++\n> * B/S模型\n> * [线程同步机制包装类](https://github.com/qinguoyi/TinyWebServer/tree/master/lock)\n> * [http连接请求处理类](https://github.com/qinguoyi/TinyWebServer/tree/master/http)\n> * [半同步/半反应堆线程池](https://github.com/qinguoyi/TinyWebServer/tree/master/threadpool)\n> * [定时器处理非活动连接](https://github.com/qinguoyi/TinyWebServer/tree/master/timer)\n> * [同步/异步日志系统 ](https://github.com/qinguoyi/TinyWebServer/tree/master/log)  \n> * [数据库连接池](https://github.com/qinguoyi/TinyWebServer/tree/master/CGImysql) \n> * [同步线程注册和登录校验](https://github.com/qinguoyi/TinyWebServer/tree/master/CGImysql) \n> * [简易服务器压力测试](https://github.com/qinguoyi/TinyWebServer/tree/master/test_presure)\n\n\n框架\n-------------\n<div align=center><img src=\"http://ww1.sinaimg.cn/large/005TJ2c7ly1ge0j1atq5hj30g60lm0w4.jpg\" height=\"765\"/> </div>\n\nDemo演示\n----------\n> * 注册演示\n\n<div align=center><img src=\"http://ww1.sinaimg.cn/large/005TJ2c7ly1ge0iz0dkleg30m80bxjyj.gif\" height=\"429\"/> </div>\n\n> * 登录演示\n\n<div align=center><img src=\"https://github.com/qinguoyi/TinyWebServer/blob/master/root/login.gif\" height=\"429\"/> </div>\n\n> * 请求图片文件演示(6M)\n\n<div align=center><img src=\"http://ww1.sinaimg.cn/large/005TJ2c7ly1ge0juxrnlfg30go07x4qr.gif\" height=\"429\"/> </div>\n\n> * 请求视频文件演示(39M)\n\n<div align=center><img src=\"http://ww1.sinaimg.cn/large/005TJ2c7ly1ge0jtxie8ng30go07xb2b.gif\" height=\"429\"/> </div>\n\n\n压力测试\n-------------\n在关闭日志后，使用Webbench对服务器进行压力测试，对listenfd和connfd分别采用ET和LT模式，均可实现上万的并发连接，下面列出的是两者组合后的测试结果. \n\n> * Proactor，LT + LT，93251 QPS\n\n<div align=center><img src=\"http://ww1.sinaimg.cn/large/005TJ2c7ly1gfjqu2hptkj30gz07474n.jpg\" height=\"201\"/> </div>\n\n> * Proactor，LT + ET，97459 QPS\n\n<div align=center><img src=\"http://ww1.sinaimg.cn/large/005TJ2c7ly1gfjr1xppdgj30h206zdg6.jpg\" height=\"201\"/> </div>\n\n> * Proactor，ET + LT，80498 QPS\n\n<div align=center><img src=\"http://ww1.sinaimg.cn/large/005TJ2c7ly1gfjr24vmjtj30gz0720t3.jpg\" height=\"201\"/> </div>\n\n> * Proactor，ET + ET，92167 QPS\n\n<div align=center><img src=\"http://ww1.sinaimg.cn/large/005TJ2c7ly1gfjrflrebdj30gz06z0t3.jpg\" height=\"201\"/> </div>\n\n> * Reactor，LT + ET，69175 QPS\n\n<div align=center><img src=\"http://ww1.sinaimg.cn/large/005TJ2c7ly1gfjr1humcbj30h207474n.jpg\" height=\"201\"/> </div>\n\n> * 并发连接总数：10500\n> * 访问服务器时间：5s\n> * 所有访问均成功\n\n**注意：** 使用本项目的webbench进行压测时，若报错显示webbench命令找不到，将可执行文件webbench删除后，重新编译即可。\n\n更新日志\n-------\n- [x] 解决请求服务器上大文件的Bug\n- [x] 增加请求视频文件的页面\n- [x] 解决数据库同步校验内存泄漏\n- [x] 实现非阻塞模式下的ET和LT触发，并完成压力测试\n- [x] 完善`lock.h`中的封装类，统一使用该同步机制\n- [x] 改进代码结构，更新局部变量懒汉单例模式\n- [x] 优化数据库连接池信号量与代码结构\n- [x] 使用RAII机制优化数据库连接的获取与释放\n- [x] 优化代码结构，封装工具类以减少全局变量\n- [x] 编译一次即可，命令行进行个性化测试更加友好\n- [x] main函数封装重构\n- [x] 新增命令行日志开关，关闭日志后更新压力测试结果\n- [x] 改进编译方式，只配置一次SQL信息即可\n- [x] 新增Reactor模式，并完成压力测试\n\n源码下载\n-------\n目前有两个版本，版本间的代码结构有较大改动，文档和代码运行方法也不一致。重构版本更简洁，原始版本(raw_version)更大保留游双代码的原汁原味，从原始版本更容易入手.\n\n如果遇到github代码下载失败，或访问太慢，可以从以下链接下载，与Github最新提交同步.\n\n* 重构版本下载地址 : [BaiduYun](https://pan.baidu.com/s/1PozKji8Oop-1BYcfixZR0g)\n    *  提取码 : vsqq\n* 原始版本(raw_version)下载地址 : [BaiduYun](https://pan.baidu.com/s/1asMNDW-zog92DZY1Oa4kaQ)\n    * 提取码 : 9wye\n    * 原始版本运行请参考[原始文档](https://github.com/qinguoyi/TinyWebServer/tree/raw_version)\n\n快速运行\n------------\n* 服务器测试环境\n\t* Ubuntu版本16.04\n\t* MySQL版本5.7.29\n* 浏览器测试环境\n\t* Windows、Linux均可\n\t* Chrome\n\t* FireFox\n\t* 其他浏览器暂无测试\n\n* 测试前确认已安装MySQL数据库\n\n    ```C++\n    // 建立yourdb库\n    create database yourdb;\n\n    // 创建user表\n    USE yourdb;\n    CREATE TABLE user(\n        username char(50) NULL,\n        passwd char(50) NULL\n    )ENGINE=InnoDB;\n\n    // 添加数据\n    INSERT INTO user(username, passwd) VALUES('name', 'passwd');\n    ```\n\n* 修改main.cpp中的数据库初始化信息\n\n    ```C++\n    //数据库登录名,密码,库名\n    string user = \"root\";\n    string passwd = \"root\";\n    string databasename = \"yourdb\";\n    ```\n\n* build\n\n    ```C++\n    sh ./build.sh\n    ```\n\n* 启动server\n\n    ```C++\n    ./server\n    ```\n\n* 浏览器端\n\n    ```C++\n    ip:9006\n    ```\n\n个性化运行\n------\n\n```C++\n./server [-p port] [-l LOGWrite] [-m TRIGMode] [-o OPT_LINGER] [-s sql_num] [-t thread_num] [-c close_log] [-a actor_model]\n```\n\n温馨提示:以上参数不是非必须，不用全部使用，根据个人情况搭配选用即可.\n\n* -p，自定义端口号\n\t* 默认9006\n* -l，选择日志写入方式，默认同步写入\n\t* 0，同步写入\n\t* 1，异步写入\n* -m，listenfd和connfd的模式组合，默认使用LT + LT\n\t* 0，表示使用LT + LT\n\t* 1，表示使用LT + ET\n    * 2，表示使用ET + LT\n    * 3，表示使用ET + ET\n* -o，优雅关闭连接，默认不使用\n\t* 0，不使用\n\t* 1，使用\n* -s，数据库连接数量\n\t* 默认为8\n* -t，线程数量\n\t* 默认为8\n* -c，关闭日志，默认打开\n\t* 0，打开日志\n\t* 1，关闭日志\n* -a，选择反应堆模型，默认Proactor\n\t* 0，Proactor模型\n\t* 1，Reactor模型\n\n测试示例命令与含义\n\n```C++\n./server -p 9007 -l 1 -m 0 -o 1 -s 10 -t 10 -c 1 -a 1\n```\n\n- [x] 端口9007\n- [x] 异步写入日志\n- [x] 使用LT + LT组合\n- [x] 使用优雅关闭连接\n- [x] 数据库连接池内有10条连接\n- [x] 线程池内有10条线程\n- [x] 关闭日志\n- [x] Reactor反应堆模型\n\n庖丁解牛\n------------\n近期版本迭代较快，以下内容多以旧版本(raw_version)代码为蓝本进行详解.\n\n* [小白视角：一文读懂社长的TinyWebServer](https://huixxi.github.io/2020/06/02/%E5%B0%8F%E7%99%BD%E8%A7%86%E8%A7%92%EF%BC%9A%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82%E7%A4%BE%E9%95%BF%E7%9A%84TinyWebServer/#more)\n* [最新版Web服务器项目详解 - 01 线程同步机制封装类](https://mp.weixin.qq.com/s?__biz=MzAxNzU2MzcwMw==&mid=2649274278&idx=3&sn=5840ff698e3f963c7855d702e842ec47&chksm=83ffbefeb48837e86fed9754986bca6db364a6fe2e2923549a378e8e5dec6e3cf732cdb198e2&scene=0&xtrack=1#rd)\n* [最新版Web服务器项目详解 - 02 半同步半反应堆线程池（上）](https://mp.weixin.qq.com/s?__biz=MzAxNzU2MzcwMw==&mid=2649274278&idx=4&sn=caa323faf0c51d882453c0e0c6a62282&chksm=83ffbefeb48837e841a6dbff292217475d9075e91cbe14042ad6e55b87437dcd01e6d9219e7d&scene=0&xtrack=1#rd)\n* [最新版Web服务器项目详解 - 03 半同步半反应堆线程池（下）](https://mp.weixin.qq.com/s/PB8vMwi8sB4Jw3WzAKpWOQ)\n* [最新版Web服务器项目详解 - 04 http连接处理（上）](https://mp.weixin.qq.com/s/BfnNl-3jc_x5WPrWEJGdzQ)\n* [最新版Web服务器项目详解 - 05 http连接处理（中）](https://mp.weixin.qq.com/s/wAQHU-QZiRt1VACMZZjNlw)\n* [最新版Web服务器项目详解 - 06 http连接处理（下）](https://mp.weixin.qq.com/s/451xNaSFHxcxfKlPBV3OCg)\n* [最新版Web服务器项目详解 - 07 定时器处理非活动连接（上）](https://mp.weixin.qq.com/s/mmXLqh_NywhBXJvI45hchA)\n* [最新版Web服务器项目详解 - 08 定时器处理非活动连接（下）](https://mp.weixin.qq.com/s/fb_OUnlV1SGuOUdrGrzVgg)\n* [最新版Web服务器项目详解 - 09 日志系统（上）](https://mp.weixin.qq.com/s/IWAlPzVDkR2ZRI5iirEfCg)\n* [最新版Web服务器项目详解 - 10 日志系统（下）](https://mp.weixin.qq.com/s/f-ujwFyCe1LZa3EB561ehA)\n* [最新版Web服务器项目详解 - 11 数据库连接池](https://mp.weixin.qq.com/s?__biz=MzAxNzU2MzcwMw==&mid=2649274326&idx=1&sn=5af78e2bf6552c46ae9ab2aa22faf839&chksm=83ffbe8eb4883798c3abb82ddd124c8100a39ef41ab8d04abe42d344067d5e1ac1b0cac9d9a3&token=1450918099&lang=zh_CN#rd)\n* [最新版Web服务器项目详解 - 12 注册登录](https://mp.weixin.qq.com/s?__biz=MzAxNzU2MzcwMw==&mid=2649274431&idx=4&sn=7595a70f06a79cb7abaebcd939e0cbee&chksm=83ffb167b4883871ce110aeb23e04acf835ef41016517247263a2c3ab6f8e615607858127ea6&token=1686112912&lang=zh_CN#rd)\n* [最新版Web服务器项目详解 - 13 踩坑与面试题](https://mp.weixin.qq.com/s?__biz=MzAxNzU2MzcwMw==&mid=2649274431&idx=1&sn=2dd28c92f5d9704a57c001a3d2630b69&chksm=83ffb167b48838715810b27b8f8b9a576023ee5c08a8e5d91df5baf396732de51268d1bf2a4e&token=1686112912&lang=zh_CN#rd)\n* 已更新完毕\n\nStar History\n---------\n[![Star History Chart](https://api.star-history.com/svg?repos=qinguoyi/TinyWebServer&type=Date)](https://star-history.com/#qinguoyi/TinyWebServer&Date)\n\nCPP11实现\n------------\n更简洁，更优雅的CPP11实现：[Webserver](https://github.com/markparticle/WebServer)\n\n\n致谢\n------------\nLinux高性能服务器编程，游双著.\n\n感谢以下朋友的PR和帮助: [@RownH](https://github.com/RownH)，[@mapleFU](https://github.com/mapleFU)，[@ZWiley](https://github.com/ZWiley)，[@zjuHong](https://github.com/zjuHong)，[@mamil](https://github.com/mamil)，[@byfate](https://github.com/byfate)，[@MaJun827](https://github.com/MaJun827)，[@BBLiu-coder](https://github.com/BBLiu-coder)，[@smoky96](https://github.com/smoky96)，[@yfBong](https://github.com/yfBong)，[@liuwuyao](https://github.com/liuwuyao)，[@Huixxi](https://github.com/Huixxi)，[@markparticle](https://github.com/markparticle)，[@blogg9ggg](https://github.com/Blogg9ggg).\n"
        },
        {
          "name": "build.sh",
          "type": "blob",
          "size": 0.0234375,
          "content": "#!/bin/bash\n\nmake server"
        },
        {
          "name": "config.cpp",
          "type": "blob",
          "size": 1.59765625,
          "content": "#include \"config.h\"\n\nConfig::Config(){\n    //端口号,默认9006\n    PORT = 9006;\n\n    //日志写入方式，默认同步\n    LOGWrite = 0;\n\n    //触发组合模式,默认listenfd LT + connfd LT\n    TRIGMode = 0;\n\n    //listenfd触发模式，默认LT\n    LISTENTrigmode = 0;\n\n    //connfd触发模式，默认LT\n    CONNTrigmode = 0;\n\n    //优雅关闭链接，默认不使用\n    OPT_LINGER = 0;\n\n    //数据库连接池数量,默认8\n    sql_num = 8;\n\n    //线程池内的线程数量,默认8\n    thread_num = 8;\n\n    //关闭日志,默认不关闭\n    close_log = 0;\n\n    //并发模型,默认是proactor\n    actor_model = 0;\n}\n\nvoid Config::parse_arg(int argc, char*argv[]){\n    int opt;\n    const char *str = \"p:l:m:o:s:t:c:a:\";\n    while ((opt = getopt(argc, argv, str)) != -1)\n    {\n        switch (opt)\n        {\n        case 'p':\n        {\n            PORT = atoi(optarg);\n            break;\n        }\n        case 'l':\n        {\n            LOGWrite = atoi(optarg);\n            break;\n        }\n        case 'm':\n        {\n            TRIGMode = atoi(optarg);\n            break;\n        }\n        case 'o':\n        {\n            OPT_LINGER = atoi(optarg);\n            break;\n        }\n        case 's':\n        {\n            sql_num = atoi(optarg);\n            break;\n        }\n        case 't':\n        {\n            thread_num = atoi(optarg);\n            break;\n        }\n        case 'c':\n        {\n            close_log = atoi(optarg);\n            break;\n        }\n        case 'a':\n        {\n            actor_model = atoi(optarg);\n            break;\n        }\n        default:\n            break;\n        }\n    }\n}"
        },
        {
          "name": "config.h",
          "type": "blob",
          "size": 0.634765625,
          "content": "#ifndef CONFIG_H\n#define CONFIG_H\n\n#include \"webserver.h\"\n\nusing namespace std;\n\nclass Config\n{\npublic:\n    Config();\n    ~Config(){};\n\n    void parse_arg(int argc, char*argv[]);\n\n    //端口号\n    int PORT;\n\n    //日志写入方式\n    int LOGWrite;\n\n    //触发组合模式\n    int TRIGMode;\n\n    //listenfd触发模式\n    int LISTENTrigmode;\n\n    //connfd触发模式\n    int CONNTrigmode;\n\n    //优雅关闭链接\n    int OPT_LINGER;\n\n    //数据库连接池数量\n    int sql_num;\n\n    //线程池内的线程数量\n    int thread_num;\n\n    //是否关闭日志\n    int close_log;\n\n    //并发模型选择\n    int actor_model;\n};\n\n#endif"
        },
        {
          "name": "http",
          "type": "tree",
          "content": null
        },
        {
          "name": "lock",
          "type": "tree",
          "content": null
        },
        {
          "name": "log",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.cpp",
          "type": "blob",
          "size": 0.787109375,
          "content": "#include \"config.h\"\n\nint main(int argc, char *argv[])\n{\n    //需要修改的数据库信息,登录名,密码,库名\n    string user = \"root\";\n    string passwd = \"root\";\n    string databasename = \"qgydb\";\n\n    //命令行解析\n    Config config;\n    config.parse_arg(argc, argv);\n\n    WebServer server;\n\n    //初始化\n    server.init(config.PORT, user, passwd, databasename, config.LOGWrite, \n                config.OPT_LINGER, config.TRIGMode,  config.sql_num,  config.thread_num, \n                config.close_log, config.actor_model);\n    \n\n    //日志\n    server.log_write();\n\n    //数据库\n    server.sql_pool();\n\n    //线程池\n    server.thread_pool();\n\n    //触发模式\n    server.trig_mode();\n\n    //监听\n    server.eventListen();\n\n    //运行\n    server.eventLoop();\n\n    return 0;\n}"
        },
        {
          "name": "makefile",
          "type": "blob",
          "size": 0.3037109375,
          "content": "CXX ?= g++\n\nDEBUG ?= 1\nifeq ($(DEBUG), 1)\n    CXXFLAGS += -g\nelse\n    CXXFLAGS += -O2\n\nendif\n\nserver: main.cpp  ./timer/lst_timer.cpp ./http/http_conn.cpp ./log/log.cpp ./CGImysql/sql_connection_pool.cpp  webserver.cpp config.cpp\n\t$(CXX) -o server  $^ $(CXXFLAGS) -lpthread -lmysqlclient\n\nclean:\n\trm  -r server\n"
        },
        {
          "name": "root",
          "type": "tree",
          "content": null
        },
        {
          "name": "test_pressure",
          "type": "tree",
          "content": null
        },
        {
          "name": "threadpool",
          "type": "tree",
          "content": null
        },
        {
          "name": "timer",
          "type": "tree",
          "content": null
        },
        {
          "name": "webserver.cpp",
          "type": "blob",
          "size": 10.7421875,
          "content": "#include \"webserver.h\"\n\nWebServer::WebServer()\n{\n    //http_conn类对象\n    users = new http_conn[MAX_FD];\n\n    //root文件夹路径\n    char server_path[200];\n    getcwd(server_path, 200);\n    char root[6] = \"/root\";\n    m_root = (char *)malloc(strlen(server_path) + strlen(root) + 1);\n    strcpy(m_root, server_path);\n    strcat(m_root, root);\n\n    //定时器\n    users_timer = new client_data[MAX_FD];\n}\n\nWebServer::~WebServer()\n{\n    close(m_epollfd);\n    close(m_listenfd);\n    close(m_pipefd[1]);\n    close(m_pipefd[0]);\n    delete[] users;\n    delete[] users_timer;\n    delete m_pool;\n}\n\nvoid WebServer::init(int port, string user, string passWord, string databaseName, int log_write, \n                     int opt_linger, int trigmode, int sql_num, int thread_num, int close_log, int actor_model)\n{\n    m_port = port;\n    m_user = user;\n    m_passWord = passWord;\n    m_databaseName = databaseName;\n    m_sql_num = sql_num;\n    m_thread_num = thread_num;\n    m_log_write = log_write;\n    m_OPT_LINGER = opt_linger;\n    m_TRIGMode = trigmode;\n    m_close_log = close_log;\n    m_actormodel = actor_model;\n}\n\nvoid WebServer::trig_mode()\n{\n    //LT + LT\n    if (0 == m_TRIGMode)\n    {\n        m_LISTENTrigmode = 0;\n        m_CONNTrigmode = 0;\n    }\n    //LT + ET\n    else if (1 == m_TRIGMode)\n    {\n        m_LISTENTrigmode = 0;\n        m_CONNTrigmode = 1;\n    }\n    //ET + LT\n    else if (2 == m_TRIGMode)\n    {\n        m_LISTENTrigmode = 1;\n        m_CONNTrigmode = 0;\n    }\n    //ET + ET\n    else if (3 == m_TRIGMode)\n    {\n        m_LISTENTrigmode = 1;\n        m_CONNTrigmode = 1;\n    }\n}\n\nvoid WebServer::log_write()\n{\n    if (0 == m_close_log)\n    {\n        //初始化日志\n        if (1 == m_log_write)\n            Log::get_instance()->init(\"./ServerLog\", m_close_log, 2000, 800000, 800);\n        else\n            Log::get_instance()->init(\"./ServerLog\", m_close_log, 2000, 800000, 0);\n    }\n}\n\nvoid WebServer::sql_pool()\n{\n    //初始化数据库连接池\n    m_connPool = connection_pool::GetInstance();\n    m_connPool->init(\"localhost\", m_user, m_passWord, m_databaseName, 3306, m_sql_num, m_close_log);\n\n    //初始化数据库读取表\n    users->initmysql_result(m_connPool);\n}\n\nvoid WebServer::thread_pool()\n{\n    //线程池\n    m_pool = new threadpool<http_conn>(m_actormodel, m_connPool, m_thread_num);\n}\n\nvoid WebServer::eventListen()\n{\n    //网络编程基础步骤\n    m_listenfd = socket(PF_INET, SOCK_STREAM, 0);\n    assert(m_listenfd >= 0);\n\n    //优雅关闭连接\n    if (0 == m_OPT_LINGER)\n    {\n        struct linger tmp = {0, 1};\n        setsockopt(m_listenfd, SOL_SOCKET, SO_LINGER, &tmp, sizeof(tmp));\n    }\n    else if (1 == m_OPT_LINGER)\n    {\n        struct linger tmp = {1, 1};\n        setsockopt(m_listenfd, SOL_SOCKET, SO_LINGER, &tmp, sizeof(tmp));\n    }\n\n    int ret = 0;\n    struct sockaddr_in address;\n    bzero(&address, sizeof(address));\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = htonl(INADDR_ANY);\n    address.sin_port = htons(m_port);\n\n    int flag = 1;\n    setsockopt(m_listenfd, SOL_SOCKET, SO_REUSEADDR, &flag, sizeof(flag));\n    ret = bind(m_listenfd, (struct sockaddr *)&address, sizeof(address));\n    assert(ret >= 0);\n    ret = listen(m_listenfd, 5);\n    assert(ret >= 0);\n\n    utils.init(TIMESLOT);\n\n    //epoll创建内核事件表\n    epoll_event events[MAX_EVENT_NUMBER];\n    m_epollfd = epoll_create(5);\n    assert(m_epollfd != -1);\n\n    utils.addfd(m_epollfd, m_listenfd, false, m_LISTENTrigmode);\n    http_conn::m_epollfd = m_epollfd;\n\n    ret = socketpair(PF_UNIX, SOCK_STREAM, 0, m_pipefd);\n    assert(ret != -1);\n    utils.setnonblocking(m_pipefd[1]);\n    utils.addfd(m_epollfd, m_pipefd[0], false, 0);\n\n    utils.addsig(SIGPIPE, SIG_IGN);\n    utils.addsig(SIGALRM, utils.sig_handler, false);\n    utils.addsig(SIGTERM, utils.sig_handler, false);\n\n    alarm(TIMESLOT);\n\n    //工具类,信号和描述符基础操作\n    Utils::u_pipefd = m_pipefd;\n    Utils::u_epollfd = m_epollfd;\n}\n\nvoid WebServer::timer(int connfd, struct sockaddr_in client_address)\n{\n    users[connfd].init(connfd, client_address, m_root, m_CONNTrigmode, m_close_log, m_user, m_passWord, m_databaseName);\n\n    //初始化client_data数据\n    //创建定时器，设置回调函数和超时时间，绑定用户数据，将定时器添加到链表中\n    users_timer[connfd].address = client_address;\n    users_timer[connfd].sockfd = connfd;\n    util_timer *timer = new util_timer;\n    timer->user_data = &users_timer[connfd];\n    timer->cb_func = cb_func;\n    time_t cur = time(NULL);\n    timer->expire = cur + 3 * TIMESLOT;\n    users_timer[connfd].timer = timer;\n    utils.m_timer_lst.add_timer(timer);\n}\n\n//若有数据传输，则将定时器往后延迟3个单位\n//并对新的定时器在链表上的位置进行调整\nvoid WebServer::adjust_timer(util_timer *timer)\n{\n    time_t cur = time(NULL);\n    timer->expire = cur + 3 * TIMESLOT;\n    utils.m_timer_lst.adjust_timer(timer);\n\n    LOG_INFO(\"%s\", \"adjust timer once\");\n}\n\nvoid WebServer::deal_timer(util_timer *timer, int sockfd)\n{\n    timer->cb_func(&users_timer[sockfd]);\n    if (timer)\n    {\n        utils.m_timer_lst.del_timer(timer);\n    }\n\n    LOG_INFO(\"close fd %d\", users_timer[sockfd].sockfd);\n}\n\nbool WebServer::dealclientdata()\n{\n    struct sockaddr_in client_address;\n    socklen_t client_addrlength = sizeof(client_address);\n    if (0 == m_LISTENTrigmode)\n    {\n        int connfd = accept(m_listenfd, (struct sockaddr *)&client_address, &client_addrlength);\n        if (connfd < 0)\n        {\n            LOG_ERROR(\"%s:errno is:%d\", \"accept error\", errno);\n            return false;\n        }\n        if (http_conn::m_user_count >= MAX_FD)\n        {\n            utils.show_error(connfd, \"Internal server busy\");\n            LOG_ERROR(\"%s\", \"Internal server busy\");\n            return false;\n        }\n        timer(connfd, client_address);\n    }\n\n    else\n    {\n        while (1)\n        {\n            int connfd = accept(m_listenfd, (struct sockaddr *)&client_address, &client_addrlength);\n            if (connfd < 0)\n            {\n                LOG_ERROR(\"%s:errno is:%d\", \"accept error\", errno);\n                break;\n            }\n            if (http_conn::m_user_count >= MAX_FD)\n            {\n                utils.show_error(connfd, \"Internal server busy\");\n                LOG_ERROR(\"%s\", \"Internal server busy\");\n                break;\n            }\n            timer(connfd, client_address);\n        }\n        return false;\n    }\n    return true;\n}\n\nbool WebServer::dealwithsignal(bool &timeout, bool &stop_server)\n{\n    int ret = 0;\n    int sig;\n    char signals[1024];\n    ret = recv(m_pipefd[0], signals, sizeof(signals), 0);\n    if (ret == -1)\n    {\n        return false;\n    }\n    else if (ret == 0)\n    {\n        return false;\n    }\n    else\n    {\n        for (int i = 0; i < ret; ++i)\n        {\n            switch (signals[i])\n            {\n            case SIGALRM:\n            {\n                timeout = true;\n                break;\n            }\n            case SIGTERM:\n            {\n                stop_server = true;\n                break;\n            }\n            }\n        }\n    }\n    return true;\n}\n\nvoid WebServer::dealwithread(int sockfd)\n{\n    util_timer *timer = users_timer[sockfd].timer;\n\n    //reactor\n    if (1 == m_actormodel)\n    {\n        if (timer)\n        {\n            adjust_timer(timer);\n        }\n\n        //若监测到读事件，将该事件放入请求队列\n        m_pool->append(users + sockfd, 0);\n\n        while (true)\n        {\n            if (1 == users[sockfd].improv)\n            {\n                if (1 == users[sockfd].timer_flag)\n                {\n                    deal_timer(timer, sockfd);\n                    users[sockfd].timer_flag = 0;\n                }\n                users[sockfd].improv = 0;\n                break;\n            }\n        }\n    }\n    else\n    {\n        //proactor\n        if (users[sockfd].read_once())\n        {\n            LOG_INFO(\"deal with the client(%s)\", inet_ntoa(users[sockfd].get_address()->sin_addr));\n\n            //若监测到读事件，将该事件放入请求队列\n            m_pool->append_p(users + sockfd);\n\n            if (timer)\n            {\n                adjust_timer(timer);\n            }\n        }\n        else\n        {\n            deal_timer(timer, sockfd);\n        }\n    }\n}\n\nvoid WebServer::dealwithwrite(int sockfd)\n{\n    util_timer *timer = users_timer[sockfd].timer;\n    //reactor\n    if (1 == m_actormodel)\n    {\n        if (timer)\n        {\n            adjust_timer(timer);\n        }\n\n        m_pool->append(users + sockfd, 1);\n\n        while (true)\n        {\n            if (1 == users[sockfd].improv)\n            {\n                if (1 == users[sockfd].timer_flag)\n                {\n                    deal_timer(timer, sockfd);\n                    users[sockfd].timer_flag = 0;\n                }\n                users[sockfd].improv = 0;\n                break;\n            }\n        }\n    }\n    else\n    {\n        //proactor\n        if (users[sockfd].write())\n        {\n            LOG_INFO(\"send data to the client(%s)\", inet_ntoa(users[sockfd].get_address()->sin_addr));\n\n            if (timer)\n            {\n                adjust_timer(timer);\n            }\n        }\n        else\n        {\n            deal_timer(timer, sockfd);\n        }\n    }\n}\n\nvoid WebServer::eventLoop()\n{\n    bool timeout = false;\n    bool stop_server = false;\n\n    while (!stop_server)\n    {\n        int number = epoll_wait(m_epollfd, events, MAX_EVENT_NUMBER, -1);\n        if (number < 0 && errno != EINTR)\n        {\n            LOG_ERROR(\"%s\", \"epoll failure\");\n            break;\n        }\n\n        for (int i = 0; i < number; i++)\n        {\n            int sockfd = events[i].data.fd;\n\n            //处理新到的客户连接\n            if (sockfd == m_listenfd)\n            {\n                bool flag = dealclientdata();\n                if (false == flag)\n                    continue;\n            }\n            else if (events[i].events & (EPOLLRDHUP | EPOLLHUP | EPOLLERR))\n            {\n                //服务器端关闭连接，移除对应的定时器\n                util_timer *timer = users_timer[sockfd].timer;\n                deal_timer(timer, sockfd);\n            }\n            //处理信号\n            else if ((sockfd == m_pipefd[0]) && (events[i].events & EPOLLIN))\n            {\n                bool flag = dealwithsignal(timeout, stop_server);\n                if (false == flag)\n                    LOG_ERROR(\"%s\", \"dealclientdata failure\");\n            }\n            //处理客户连接上接收到的数据\n            else if (events[i].events & EPOLLIN)\n            {\n                dealwithread(sockfd);\n            }\n            else if (events[i].events & EPOLLOUT)\n            {\n                dealwithwrite(sockfd);\n            }\n        }\n        if (timeout)\n        {\n            utils.timer_handler();\n\n            LOG_INFO(\"%s\", \"timer tick\");\n\n            timeout = false;\n        }\n    }\n}\n"
        },
        {
          "name": "webserver.h",
          "type": "blob",
          "size": 1.9208984375,
          "content": "#ifndef WEBSERVER_H\n#define WEBSERVER_H\n\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <cassert>\n#include <sys/epoll.h>\n\n#include \"./threadpool/threadpool.h\"\n#include \"./http/http_conn.h\"\n\nconst int MAX_FD = 65536;           //最大文件描述符\nconst int MAX_EVENT_NUMBER = 10000; //最大事件数\nconst int TIMESLOT = 5;             //最小超时单位\n\nclass WebServer\n{\npublic:\n    WebServer();\n    ~WebServer();\n\n    void init(int port , string user, string passWord, string databaseName,\n              int log_write , int opt_linger, int trigmode, int sql_num,\n              int thread_num, int close_log, int actor_model);\n\n    void thread_pool();\n    void sql_pool();\n    void log_write();\n    void trig_mode();\n    void eventListen();\n    void eventLoop();\n    void timer(int connfd, struct sockaddr_in client_address);\n    void adjust_timer(util_timer *timer);\n    void deal_timer(util_timer *timer, int sockfd);\n    bool dealclientdata();\n    bool dealwithsignal(bool& timeout, bool& stop_server);\n    void dealwithread(int sockfd);\n    void dealwithwrite(int sockfd);\n\npublic:\n    //基础\n    int m_port;\n    char *m_root;\n    int m_log_write;\n    int m_close_log;\n    int m_actormodel;\n\n    int m_pipefd[2];\n    int m_epollfd;\n    http_conn *users;\n\n    //数据库相关\n    connection_pool *m_connPool;\n    string m_user;         //登陆数据库用户名\n    string m_passWord;     //登陆数据库密码\n    string m_databaseName; //使用数据库名\n    int m_sql_num;\n\n    //线程池相关\n    threadpool<http_conn> *m_pool;\n    int m_thread_num;\n\n    //epoll_event相关\n    epoll_event events[MAX_EVENT_NUMBER];\n\n    int m_listenfd;\n    int m_OPT_LINGER;\n    int m_TRIGMode;\n    int m_LISTENTrigmode;\n    int m_CONNTrigmode;\n\n    //定时器相关\n    client_data *users_timer;\n    Utils utils;\n};\n#endif\n"
        }
      ]
    }
  ]
}