{
  "metadata": {
    "timestamp": 1736566320753,
    "page": 75,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "rui314/mold",
      "stars": 14661,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0771484375,
          "content": "*.o\n*.so\n*~\n**/.DS_Store\n.cache\ncore\ngentoo\n/mold-*.tar.gz\n/build*\n/mold\n/dist\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 14.0927734375,
          "content": "# You can customize a build by specifying CMake options. An option may be\n# given in the -Dvariable=value form. For a boolean variable, `ON` or `1`\n# means true, while `OFF` or `0` means false.\n#\n# Here are a couple of common cmake options:\n#\n#  -DCMAKE_C_COMPILER=<command-name>\n#\n#   Specifies the C compiler name to use. The default value is `cc`.\n#\n#  -DCMAKE_CXX_COMPILER=<command-name>\n#\n#   Specifies the C++ compiler name to use. The default value is `c++`.\n#\n#  -DCMAKE_INSTALL_PREFIX=<directory>\n#\n#   Specifies the install target directory. The default value is `/usr/local`.\n#\n#  -DCMAKE_BUILD_TYPE=[Debug | Release | RelWithDebInfo | MinSizeRel]\n#\n#   Specifies the build type. The default is `Release`, which is the right\n#   option unless you are debugging mold.\n#\n# An example of a cmake command line is shown below:\n#\n#   $ cmake -DCMAKE_INSTALL_PREFIX=/usr -DCMAKE_CXX_COMPILER=g++-12 ..\n#\n# where `..` refers to this directory.\n#\n# With cmake, you may run `cmake --install .` instead of `make install` to\n# install build artifacts to system directories. If you want to install\n# artifacts to a temporary target directory, run `cmake --install . --prefix\n# <dir>`.\n#\n# You can see the current cmake variables and their values by running\n# `cmake -N -L .` in a build directory.\n#\n# Note that in this file, we provide various dials and knobs to configure\n# how to build mold. However, as a policy, we do not provide a way to\n# enable/disable any individual mold's feature. In other words, we do not\n# provide options like `--enable-foo` or `--disable-foo`. The motivation\n# behind this is build reproducibility. We want to guarantee that all builds\n# of the mold linker of the same version will have the exact same set of\n# features and behave exactly the same.\n\ncmake_minimum_required(VERSION 3.14)\nproject(mold VERSION 2.36.0)\n\ninclude(CMakeDependentOption)\ninclude(CheckSymbolExists)\ninclude(GNUInstallDirs)\n\nadd_executable(mold)\ntarget_compile_features(mold PRIVATE cxx_std_20)\n\nif(MINGW)\n  target_link_libraries(mold PRIVATE dl)\nelse()\n  target_link_libraries(mold PRIVATE ${CMAKE_DL_LIBS})\nendif()\n\n# Build mold itself using mold if -DMOLD_USE_MOLD=ON\noption(MOLD_USE_MOLD \"Use mold to build mold\" OFF)\nif(MOLD_USE_MOLD)\n  target_link_options(mold PRIVATE -fuse-ld=mold -Wl,--gdb-index)\n\n  if(CMAKE_BUILD_TYPE MATCHES \"^Rel\")\n    target_link_options(mold PRIVATE -Wl,--gc-sections,--icf=safe)\n  endif()\nendif()\n\nif(NOT \"${CMAKE_CXX_COMPILER_FRONTEND_VARIANT}\" STREQUAL \"MSVC\")\n  target_compile_options(mold PRIVATE\n    -fno-exceptions\n    -fno-unwind-tables\n    -fno-asynchronous-unwind-tables\n    -ffunction-sections\n    -fdata-sections\n    -Wall\n    -Wextra\n    -Wno-sign-compare\n    -Wno-unused-function\n    -Wno-unused-parameter\n    -Wno-missing-field-initializers\n    -ggnu-pubnames)\nendif()\n\nif(CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n  target_compile_options(mold PRIVATE -D_GLIBCXX_ASSERTIONS)\nendif()\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"OpenBSD\")\n  set(OPENBSD ON)\nendif()\n\n# Build mold with -flto if -DMOLD_LTO=ON\noption(MOLD_LTO \"Build mold with link-time optimization enabled\")\nif(MOLD_LTO)\n  set_property(TARGET mold PROPERTY INTERPROCEDURAL_OPTIMIZATION ON)\nendif()\n\n# Enable AddressSanitizer if -DMOLD_USE_ASAN=ON\noption(MOLD_USE_ASAN \"Build mold with AddressSanitizer\" OFF)\nif(MOLD_USE_ASAN)\n  target_compile_options(mold PRIVATE -fsanitize=address -fsanitize=undefined)\n  target_link_options(mold PRIVATE -fsanitize=address -fsanitize=undefined)\nendif()\n\n# Enabled ThreadSanitizer if -DMOLD_USE_TSAN=ON\noption(MOLD_USE_TSAN \"Build mold with ThreadSanitizer\" OFF)\nif(MOLD_USE_TSAN)\n  target_compile_options(mold PRIVATE -fsanitize=thread)\n  target_link_options(mold PRIVATE -fsanitize=thread)\nendif()\n\n# Statically-link libstdc++ if -DMOLD_MOSTLY_STATIC=ON.\n#\n# This option is intended to be used by `./dist.sh` script to create a\n# mold binary that works on various Linux distros. You probably don't\n# need nor want to set this to ON.\noption(MOLD_MOSTLY_STATIC \"Statically link libstdc++ and some other libraries\" OFF)\nif(MOLD_MOSTLY_STATIC)\n  target_link_options(mold PRIVATE -static-libstdc++)\nendif()\n\n# Find zlib. If libz.so is not found, we compile a bundled one and\n# statically-link it to mold.\nfind_package(ZLIB QUIET)\nif(ZLIB_FOUND AND NOT MOLD_MOSTLY_STATIC)\n  target_link_libraries(mold PRIVATE ZLIB::ZLIB)\nelse()\n  set(ZLIB_BUILD_EXAMPLES OFF CACHE INTERNAL \"\")\n  add_subdirectory(third-party/zlib EXCLUDE_FROM_ALL)\n  target_include_directories(zlibstatic INTERFACE third-party/zlib\n    $<TARGET_PROPERTY:zlibstatic,BINARY_DIR>)\n  target_link_libraries(mold PRIVATE zlibstatic)\nendif()\n\n# Find BLAKE3 cryptographic hash library. Just like zlib, if libblkae3.so\n# is not found, we compile a bundled one and statically-link it to mold.\nfind_package(BLAKE3 QUIET)\nif(BLAKE3_FOUND AND NOT MOLD_MOSTLY_STATIC)\n  target_link_libraries(mold PRIVATE BLAKE3::blake3)\nelse()\n  function(mold_add_blake3)\n    set(BUILD_SHARED_LIBS OFF)\n    add_subdirectory(third-party/blake3/c EXCLUDE_FROM_ALL)\n    target_link_libraries(mold PRIVATE blake3)\n    target_include_directories(mold PUBLIC third-party/blake3/c)\n  endfunction()\n\n  mold_add_blake3()\nendif()\n\n# Find zstd compression library. If zstd.h is not found, we compile a\n# bundled one and statically-link it to mold.\ninclude(CheckIncludeFile)\ncheck_include_file(zstd.h HAVE_ZSTD_H)\n\nif(HAVE_ZSTD_H AND NOT MOLD_MOSTLY_STATIC)\n  target_link_libraries(mold PRIVATE zstd)\nelse()\n  add_subdirectory(third-party/zstd/build/cmake EXCLUDE_FROM_ALL)\n  target_compile_definitions(libzstd_static PRIVATE\n    ZSTD_BUILD_STATIC=1\n    ZSTD_BUILD_SHARED=0\n    ZSTD_BUILD_PROGRAMS=0\n    ZSTD_MULTITHREAD_SUPPORT=0\n    ZSTD_BUILD_TESTS=0)\n  target_include_directories(mold PUBLIC third-party/zstd/lib)\n  target_link_libraries(mold PRIVATE libzstd_static)\nendif()\n\n# Find mimalloc. mimalloc is an alternative malloc implementation\n# optimized for multi-threaded applications.\n#\n# If you want to use the usual libc's malloc, pass -DMOLD_USE_MIMALLOC=OFF.\n#\n# We enable mimalloc by default for 64-bit targets. It doesn't seem to\n# be stable on 32-bit targets.\ncmake_dependent_option(\n  MOLD_USE_MIMALLOC \"Use mimalloc\" ON\n  \"CMAKE_SIZEOF_VOID_P EQUAL 8; NOT APPLE; NOT ANDROID; NOT OPENBSD; NOT MOLD_USE_ASAN; NOT MOLD_USE_TSAN\" OFF)\n\ncmake_dependent_option(\n  MOLD_USE_SYSTEM_MIMALLOC \"Use system or vendored mimalloc\" OFF\n  MOLD_USE_MIMALLOC OFF)\n\n# By default, we build a bundled mimalloc and statically-link it to\n# mold. If you want to dynamically link to the system's\n# libmimalloc.so, pass -DMOLD_USE_SYSTEM_MIMALLOC=ON.\nif(MOLD_USE_MIMALLOC)\n  if(MOLD_USE_SYSTEM_MIMALLOC)\n    find_package(mimalloc REQUIRED)\n    target_link_libraries(mold PRIVATE mimalloc)\n  else()\n    function(mold_add_mimalloc)\n      set(MI_BUILD_STATIC ON CACHE INTERNAL \"\")\n      set(MI_BUILD_TESTS OFF CACHE INTERNAL \"\")\n      add_subdirectory(third-party/mimalloc EXCLUDE_FROM_ALL)\n      target_compile_definitions(mimalloc-static PRIVATE MI_USE_ENVIRON=0)\n      target_link_libraries(mold PRIVATE mimalloc-static)\n    endfunction()\n\n    mold_add_mimalloc()\n  endif()\nendif()\n\n# Find TBB. TBB (OneTBB or Intel TBB) is a high-level threading library.\n# Use of this library is mandatory.\n#\n# By default, we build a bundled one and statically-link the library\n# to mold. If you want to link to the system's libtbb2.so, pass\n# -DMOLD_USE_SYSTEM_TBB=ON.\noption(MOLD_USE_SYSTEM_TBB \"Use system or vendored TBB\" OFF)\nif(MOLD_USE_SYSTEM_TBB)\n  find_package(TBB REQUIRED)\n  target_link_libraries(mold PRIVATE TBB::tbb)\nelse()\n  function(mold_add_tbb)\n    set(BUILD_SHARED_LIBS OFF)\n    set(TBB_TEST OFF CACHE INTERNAL \"\")\n    set(TBB_STRICT OFF CACHE INTERNAL \"\")\n    add_subdirectory(third-party/tbb EXCLUDE_FROM_ALL)\n    target_compile_definitions(tbb PRIVATE __TBB_DYNAMIC_LOAD_ENABLED=0)\n    target_link_libraries(mold PRIVATE TBB::tbb)\n  endfunction()\n\n  mold_add_tbb()\nendif()\n\n# We always use Clang to build mold on Windows. MSVC can't compile mold.\nif(WIN32)\n  if(MSVC AND NOT CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n    message(FATAL_ERROR\n      \"Your compiler is not supported; install Clang from Visual Studio Installer and re-run cmake with '-T clangcl'\")\n  endif()\n\n  target_compile_definitions(mold PRIVATE NOGDI NOMINMAX)\n  if(MINGW)\n    target_compile_definitions(mold PRIVATE _WIN32_WINNT=0xA00)\n    target_link_libraries(mold PRIVATE bcrypt)\n  endif()\nelse()\n  include(CheckLibraryExists)\n  check_library_exists(m pow \"\" LIBM_FOUND)\n  if(LIBM_FOUND)\n    target_link_libraries(mold PRIVATE m)\n  endif()\nendif()\n\n# Build mold-wrapper.so\nif(NOT APPLE AND NOT WIN32)\n  add_library(mold-wrapper SHARED)\n  install(TARGETS mold-wrapper DESTINATION ${CMAKE_INSTALL_LIBDIR}/mold)\n\n  # Remove the default `lib` prefix\n  set_target_properties(mold-wrapper PROPERTIES PREFIX \"\")\n  target_link_libraries(mold-wrapper PRIVATE ${CMAKE_DL_LIBS})\n  target_sources(mold-wrapper PRIVATE src/mold-wrapper.c)\nendif()\n\n# If atomics doesn't work by default, add -latomic.\n# We need the flag on riscv, armv6 and m68k.\ninclude(CheckCXXSourceCompiles)\ncheck_cxx_source_compiles(\"#include <atomic>\nint main() {\n  std::atomic_uint8_t  a;\n  std::atomic_uint16_t b;\n  std::atomic_uint32_t c;\n  std::atomic_uint64_t d;\n  return ++a + ++b + ++c + ++d;\n}\" HAVE_FULL_ATOMIC_SUPPORT)\n\nif(NOT HAVE_FULL_ATOMIC_SUPPORT)\n  target_link_libraries(mold PRIVATE atomic)\nendif()\n\n# Add -pthread\nif(NOT APPLE AND NOT MSVC)\n  target_compile_options(mold PRIVATE -pthread)\n  target_link_options(mold PRIVATE -pthread)\nendif()\n\ncheck_symbol_exists(madvise sys/mman.h HAVE_MADVISE)\ncheck_symbol_exists(uname sys/utsname.h HAVE_UNAME)\n\n# Create a .cc file containing the current git hash for `mold --version`.\nadd_custom_target(git_hash\n  COMMAND ${CMAKE_COMMAND}\n    -DSOURCE_DIR=${CMAKE_SOURCE_DIR}\n    -DOUTPUT_FILE=${CMAKE_BINARY_DIR}/git-hash.cc\n    -P ${CMAKE_SOURCE_DIR}/lib/update-git-hash.cmake\n  DEPENDS lib/update-git-hash.cmake\n  BYPRODUCTS git-hash.cc\n  VERBATIM)\n\nadd_dependencies(mold git_hash)\n\n# Create config.h file\nconfigure_file(lib/config.h.in config.h)\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\n\n# Almost all functions are template in mold which take a target type\n# (e.g. X86_64) as its type parameter. Since we suport more than 10\n# targets, compiling a single source file for all the targets is very\n# slow.\n#\n# As a workaround, we create a .cc file for each target and spawn many\n# compiler instances. This is hacky but greatly reduces compile time\n# on a multicore machine.\nlist(APPEND MOLD_ELF_TARGETS\n  X86_64 I386 ARM64LE ARM64BE ARM32 RV32LE RV32BE RV64LE RV64BE PPC32\n  PPC64V1 PPC64V2 S390X SPARC64 M68K SH4LE SH4BE LOONGARCH32 LOONGARCH64)\n\nlist(APPEND MOLD_ELF_TEMPLATE_FILES\n  src/arch-arm64.cc\n  src/arch-loongarch.cc\n  src/arch-riscv.cc\n  src/arch-sh4.cc\n  src/cmdline.cc\n  src/filetype.cc\n  src/gc-sections.cc\n  src/gdb-index.cc\n  src/icf.cc\n  src/input-files.cc\n  src/input-sections.cc\n  src/linker-script.cc\n  src/main.cc\n  src/mapfile.cc\n  src/output-chunks.cc\n  src/passes.cc\n  src/relocatable.cc\n  src/shrink-sections.cc\n  src/thunks.cc\n  src/tls.cc\n  )\n\nif(WIN32 AND NOT MINGW)\n  list(APPEND MOLD_ELF_TEMPLATE_FILES src/lto-win32.cc)\nelse()\n  list(APPEND MOLD_ELF_TEMPLATE_FILES src/lto-unix.cc)\nendif()\n\nif(WIN32)\n  list(APPEND MOLD_ELF_TEMPLATE_FILES\n    src/output-file-win32.cc\n    src/subprocess-win32.cc\n    )\nelse()\n  list(APPEND MOLD_ELF_TEMPLATE_FILES\n    src/output-file-unix.cc\n    src/subprocess-unix.cc\n  )\nendif()\n\nfunction(mold_instantiate_templates SOURCE TARGET)\n  set(PATH ${CMAKE_BINARY_DIR}/${SOURCE}.${TARGET}.cc)\n  if(NOT EXISTS ${PATH})\n    file(WRITE ${PATH} \"#define MOLD_${TARGET} 1\n#define MOLD_TARGET ${TARGET}\n#include \\\"${CMAKE_SOURCE_DIR}/${SOURCE}\\\"\n\")\n  endif()\n  target_sources(mold PRIVATE ${PATH})\nendfunction()\n\nforeach (SOURCE IN LISTS MOLD_ELF_TEMPLATE_FILES)\n  foreach(TARGET IN LISTS MOLD_ELF_TARGETS)\n    mold_instantiate_templates(${SOURCE} ${TARGET})\n  endforeach()\nendforeach()\n\n# Add other non-template source files.\ntarget_sources(mold PRIVATE\n  git-hash.cc\n  lib/compress.cc\n  lib/crc32.cc\n  lib/demangle.cc\n  lib/filepath.cc\n  lib/glob.cc\n  lib/hyperloglog.cc\n  lib/mimalloc.cc\n  lib/multi-glob.cc\n  lib/perf.cc\n  lib/random.cc\n  lib/tar.cc\n  src/arch-arm32.cc\n  src/arch-i386.cc\n  src/arch-m68k.cc\n  src/arch-ppc32.cc\n  src/arch-ppc64v1.cc\n  src/arch-ppc64v2.cc\n  src/arch-s390x.cc\n  src/arch-sparc64.cc\n  src/arch-x86-64.cc\n  src/config.cc\n  src/elf.cc\n  third-party/rust-demangle/rust-demangle.c\n  )\n\nif(WIN32)\n  target_sources(mold PRIVATE\n    lib/jobs-win32.cc\n    lib/mapped-file-win32.cc\n    lib/signal-win32.cc\n    )\nelse()\n  target_sources(mold PRIVATE\n    lib/jobs-unix.cc\n    lib/mapped-file-unix.cc\n    lib/signal-unix.cc\n    )\nendif()\n\ninclude(CTest)\n\nif(BUILD_TESTING)\n  # Create the ld symlinks required for testing\n  if(NOT WIN32)\n    add_custom_command(\n      TARGET mold POST_BUILD\n      COMMAND ${CMAKE_COMMAND} -E create_symlink mold ld\n      BYPRODUCTS ld\n      WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}\n      VERBATIM)\n  endif()\n\n  if(${UNIX})\n    add_subdirectory(test)\n  endif()\nendif()\n\nif(NOT CMAKE_SKIP_INSTALL_RULES)\n  install(TARGETS mold RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\n  install(FILES docs/mold.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1/)\n  install(FILES LICENSE DESTINATION ${CMAKE_INSTALL_DOCDIR})\n\n  function(mold_install_relative_symlink OLD NEW)\n    install(CODE \"\n      get_filename_component(PREFIX_ABS \\${CMAKE_INSTALL_PREFIX}/ ABSOLUTE)\n      get_filename_component(OLD_ABS ${OLD} ABSOLUTE BASE_DIR \\${PREFIX_ABS})\n      get_filename_component(NEW_ABS ${NEW} ABSOLUTE BASE_DIR \\${PREFIX_ABS})\n      get_filename_component(NEW_DIR \\${NEW_ABS} DIRECTORY)\n      file(RELATIVE_PATH OLD_REL \\${NEW_DIR} \\${OLD_ABS})\n      message(STATUS \\\"Installing symlink: \\$ENV{DESTDIR}\\${NEW_ABS} -> \\${OLD_REL}\\\")\n      file(MAKE_DIRECTORY \\$ENV{DESTDIR}\\${NEW_DIR})\n      file(CREATE_LINK \\${OLD_REL} \\$ENV{DESTDIR}\\${NEW_ABS} SYMBOLIC)\")\n  endfunction()\n\n  mold_install_relative_symlink(${CMAKE_INSTALL_BINDIR}/mold${CMAKE_EXECUTABLE_SUFFIX}\n    ${CMAKE_INSTALL_LIBEXECDIR}/mold/ld${CMAKE_EXECUTABLE_SUFFIX})\n  mold_install_relative_symlink(${CMAKE_INSTALL_BINDIR}/mold${CMAKE_EXECUTABLE_SUFFIX}\n    ${CMAKE_INSTALL_BINDIR}/ld.mold${CMAKE_EXECUTABLE_SUFFIX})\n  mold_install_relative_symlink(${CMAKE_INSTALL_MANDIR}/man1/mold.1\n    ${CMAKE_INSTALL_MANDIR}/man1/ld.mold.1)\nendif()\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0419921875,
          "content": "MIT License\n\nCopyright (c) 2023 Rui Ueyama\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.29296875,
          "content": "# mold: A Modern Linker\n\nmold is a faster drop-in replacement for existing Unix linkers. It is several\ntimes quicker than the LLVM lld linker, the second-fastest open-source linker,\nwhich I initially developed a few years ago. mold aims to enhance developer\nproductivity by minimizing build time, particularly in rapid\ndebug-edit-rebuild cycles.\n\nHere is a performance comparison of GNU ld, GNU gold, LLVM lld, and\nmold when linking final debuginfo-enabled executables for major large\nprograms on a simulated 16-core, 32-thread machine.\n\n![Link speed comparison](docs/chart.svg)\n\n| Program (linker output size)  | GNU ld | GNU gold | LLVM lld | mold\n|-------------------------------|--------|----------|----------|------\n| MySQL 8.3 (0.47 GiB)          | 10.84s | 7.47s    | 1.64s    | 0.46s\n| Clang 19 (1.56 GiB)           | 42.07s | 33.13s   | 5.20s    | 1.35s\n| Chromium 124 (1.35 GiB)       | N/A    | 27.40s   | 6.10s    | 1.52s\n\nmold is so fast that it is only 2x _slower_ than the `cp` command on the same\nmachine. If you find that mold is not faster than other linkers, feel\nfree to [file a bug report](https://github.com/rui314/mold/issues).\n\nmold supports x86-64, i386, ARM64, ARM32, 64-bit/32-bit little/big-endian\nRISC-V, 32-bit PowerPC, 64-bit big-endian PowerPC ELFv1, 64-bit little-endian\nPowerPC ELFv2, s390x, 64-bit/32-bit LoongArch, SPARC64, m68k, and SH-4.\n\n## Why does linking speed matter?\n\nIf you are using a compiled language such as C, C++, or Rust, a build consists\nof two phases. In the first phase, a compiler compiles source files into\nobject files (`.o` files). In the second phase, a linker takes all object\nfiles and combines them into a single executable or shared library file.\n\nThe second phase can be time-consuming if your build output is large. mold can\nspeed up this process, saving you time and preventing distractions while\nwaiting for a lengthy build to finish. The difference is most noticeable\nduring rapid debug-edit-rebuild cycles.\n\n## Installation\n\nBinary packages for the following systems are currently available:\n\n[![Packaging status](https://repology.org/badge/vertical-allrepos/mold.svg)](https://repology.org/project/mold/versions)\n\n## How to Build\n\nmold is written in C++20, so if you build mold yourself, you will need a\nrecent version of a C++ compiler and a C++ standard library. We recommend GCC\n10.2 or Clang 12.0.0 (or later) and libstdc++ 10 or libc++ 7 (or later).\n\n### Install Dependencies\n\nTo install build dependencies, run `./install-build-deps.sh` in this\ndirectory. It will detect your Linux distribution and attempt to install the\nnecessary packages. You may need to run it as root.\n\n### Compile mold\n\n```shell\ngit clone --branch stable https://github.com/rui314/mold.git\ncd mold\n./install-build-deps.sh\ncmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_COMPILER=c++ -B build\ncmake --build build -j$(nproc)\nsudo cmake --build build --target install\n```\n\nYou might need to pass a C++20 compiler command name to `cmake`. In the\nexample above, `c++` is passed. If that doesn't work for you, try a specific\nversion of a compiler, such as `g++-10` or `clang++-12`.\n\nBy default, `mold` is installed to `/usr/local/bin`. You can change the\ninstallation location by passing `-DCMAKE_INSTALL_PREFIX=<directory>`.\nFor other cmake options, see the comments in `CMakeLists.txt`.\n\nIf you are not using a recent enough Linux distribution, or if `cmake` does\nnot work for you for any reason, you can use Docker to build mold in a Docker\nenvironment. To do so, run `./dist.sh` in this directory instead of using\n`cmake`. The shell script will pull a Docker image, build mold and auxiliary\nfiles inside it, and package them into a single tar file named\n`mold-$version-$arch-linux.tar.gz`. You can extract the tar file anywhere and\nuse the mold executable within it.\n\n## How to use\n\n<details><summary>A classic way to use mold</summary>\n\nOn Unix, the linker command (usually `/usr/bin/ld`) is indirectly invoked by\nthe compiler driver (typically `cc`, `gcc`, or `clang`), which is in turn\nindirectly invoked by `make` or other build system commands.\n\nIf you can specify an additional command line option for your compiler driver\nby modifying the build system's config files, add one of the following flags\nto use mold instead of `/usr/bin/ld`:\n\n- For Clang: pass `-fuse-ld=mold`\n\n- For GCC 12.1.0 or later: pass `-fuse-ld=mold`\n\n- For GCC before 12.1.0: the `-fuse-ld` option does not accept `mold` as a\n  valid argument, so you need to use the `-B` option instead. The `-B` option\n  tells GCC where to look for external commands like `ld`.\n\n  If you have installed mold with `make install`, there should be a directory\n  named `/usr/libexec/mold` (or `/usr/local/libexec/mold`, depending on your\n  `$PREFIX`), and the `ld` command should be there. The `ld` is actually a\n  symlink to `mold`. So, all you need is to pass `-B/usr/libexec/mold` (or\n  `-B/usr/local/libexec/mold`) to GCC.\n\nIf you haven't installed `ld.mold` to any `$PATH`, you can still pass\n`-fuse-ld=/absolute/path/to/mold` to clang to use mold. However, GCC does not\naccept an absolute path as an argument for `-fuse-ld`.\n\n</details>\n\n<details><summary>If you are using Rust</summary>\n\nCreate `.cargo/config.toml` in your project directory with the following:\n\n```toml\n[target.x86_64-unknown-linux-gnu]\nlinker = \"clang\"\nrustflags = [\"-C\", \"link-arg=-fuse-ld=/path/to/mold\"]\n```\n\nwhere `/path/to/mold` is an absolute path to the mold executable. In the\nexample above, we use `clang` as a linker driver since it always accepts the\n`-fuse-ld` option. If your GCC is recent enough to recognize the option, you\nmay be able to remove the `linker = \"clang\"` line.\n\n```toml\n[target.x86_64-unknown-linux-gnu]\nrustflags = [\"-C\", \"link-arg=-fuse-ld=mold\"]\n```\n\nIf you want to use mold for all projects, add the above snippet to\n`~/.cargo/config.toml`.\n\n</details>\n\n<details><summary>If you are using Nim</summary>\n\nCreate `config.nims` in your project directory with the following:\n\n```nim\nwhen findExe(\"mold\").len > 0 and defined(linux):\n  switch(\"passL\", \"-fuse-ld=mold\")\n```\n\nwhere `mold` must be included in the `PATH` environment variable. In this\nexample, `gcc` is used as the linker driver. Use the `-fuse-ld` option if your\nGCC is recent enough to recognize this option.\n\nIf you want to use mold for all projects, add the above snippet to\n`~/.config/config.nims`.\n\n</details>\n\n<details><summary>mold -run</summary>\n\nIt is sometimes very hard to pass an appropriate command line option to `cc`\nto specify an alternative linker. To address this situation, mold has a\nfeature to intercept all invocations of `ld`, `ld.bfd`, `ld.lld`, or `ld.gold`\nand redirect them to itself. To use this feature, run `make` (or another build\ncommand) as a subcommand of mold as follows:\n\n```shell\nmold -run make <make-options-if-any>\n```\n\nInternally, mold invokes a given command with the `LD_PRELOAD` environment\nvariable set to its companion shared object file. The shared object file\nintercepts all function calls to `exec(3)`-family functions to replace\n`argv[0]` with `mold` if it is `ld`, `ld.bf`, `ld.gold`, or `ld.lld`.\n\n</details>\n\n<details><summary>GitHub Actions</summary>\n\nYou can use our [setup-mold](https://github.com/rui314/setup-mold) GitHub\nAction to speed up GitHub-hosted continuous builds. Although GitHub Actions\nrun on a 4 core machine, mold is still significantly faster than the default\nGNU linker, especially when linking large programs.\n\n</details>\n\n<details><summary>Verify that you are using mold</summary>\n\nmold leaves its identification string in the `.comment` section of an output\nfile. You can print it out to verify that you are actually using mold.\n\n```shell\n$ readelf -p .comment <executable-file>\n\nString dump of section '.comment':\n  [     0]  GCC: (Ubuntu 10.2.0-5ubuntu1~20.04) 10.2.0\n  [    2b]  mold 9a1679b47d9b22012ec7dfbda97c8983956716f7\n```\n\nIf `mold` is present in the `.comment` section, the file was created by mold.\n\n</details>\n\n<details><summary>Online manual</summary>\n\nSince mold is a drop-in replacement, you should be able to use it without\nreading its manual. However, if you need it, [mold's man page](docs/mold.md)\nis available online. You can read the same manual by running `man mold`.\n\n</details>\n\n## Why is mold so fast?\n\nOne reason is that it utilizes faster algorithms and more efficient data\nstructures compared to other linkers. Another reason is that mold is highly\nparallelized.\n\nHere is a side-by-side comparison of per-core CPU usage for lld (left) and\nmold (right), linking the same program, a Chromium executable.\n\n![CPU usage comparison in htop animation](docs/htop.gif)\n\nAs you can see, mold uses all available cores throughout its execution and\nfinishes quickly. In contrast, lld fails to utilize available cores most of\nthe time. In this demo, the maximum parallelism is artificially capped at 16,\nso that the bars fit in the GIF.\n\nFor details, please see the [design notes](docs/design.md).\n\n## Sponsors\n\nIt is taken for granted nowadays that compiler toolchains can be easily\ninstalled and used for free, and people may not think too much about the\nindividuals behind these \"free tools\". mold supports many projects, but it\nis essentially a one-person project. This situation is similar to the one\ndepicted in the following xkcd illustration.\n\n[![xkcd 2347](https://imgs.xkcd.com/comics/dependency.png)](https://xkcd.com/2347)\n\nIf you think that the \"Nebraska guy\" should be rewarded, please consider\nbecoming our [GitHub sponsor](https://github.com/sponsors/rui314)!\n\nWe thank everyone who sponsors our project. In particular, we'd like to acknowledge\nthe following people and organizations who have sponsored $128/month or more:\n\n### Corporate sponsors\n\n<a href=\"https://mercury.com\"><img src=\"docs/mercury-logo.png\" align=center height=120 width=400 alt=Mercury></a>\n\n<a href=\"https://cybozu-global.com\"><img src=\"docs/cyboze-logo.png\" align=center height=120 width=133 alt=Cybozu></a>\n\n<a href=\"https://www.emergetools.com\"><img src=\"docs/emerge-tools-logo.png\" align=center height=120 width=240 alt=\"Emerge Tools\"></a><br>\n\n- [G-Research](https://www.gresearch.co.uk)\n- [Signal Slot Inc.](https://github.com/signal-slot)\n- [GlareDB](https://github.com/GlareDB)\n\n### Individual sponsors\n\n- [Wei Wu](https://github.com/lazyparser)\n- [kyle-elliott](https://github.com/kyle-elliott)\n- [Bryant Biggs](https://github.com/bryantbiggs)\n- [kraptor23](https://github.com/kraptor23)\n- [Jinkyu Yi](https://github.com/jincreator)\n- [Pedro Navarro](https://github.com/pedronavf)\n"
        },
        {
          "name": "dist.sh",
          "type": "blob",
          "size": 8.376953125,
          "content": "#!/bin/bash\n#\n# This script creates a mold binary distribution. The output is written in\n# this directory as `mold-$version-$arch-linux.tar.gz` (e.g.,\n# `mold-1.0.3-x86_64-linux.tar.gz`).\n#\n# The mold executable created by this script is statically linked to\n# libstdc++ but dynamically linked to libc, libm, libz, and librt, as\n# these libraries almost always exist on any Linux system. We can't\n# statically link libc because doing so would disable dlopen(), which is\n# necessary to open the LTO linker plugin.\n#\n# This script aims to produce reproducible outputs. That means if you run\n# the script twice on the same git commit, it should produce bit-by-bit\n# identical binary files. This property is crucial as a countermeasure\n# against supply chain attacks. With this, you can verify that the binary\n# files distributed on the GitHub release pages are created from the\n# commit with release tags by rebuilding the binaries yourself.\n#\n# Debian provides snapshot.debian.org to host all historical binary\n# packages. We use it to construct Podman images pinned to a\n# particular timestamp.\n#\n# We aim to use a reasonably old Debian version because we'll dynamically\n# link glibc to mold, and a binary linked against a newer version of glibc\n# won't work on a system with an older version of glibc.\n#\n# We want to build mold with Clang rather than GCC because mold's\n# Identical Code Folding works best with the LLVM address significance\n# table (.llvm_addrsig). Building a release binary with GCC yields a\n# slightly larger binary than Clang's.\n#\n# We need a recent version of Clang to build mold. If it's not available\n# via apt-get, we'll build it ourselves.\n#\n# You may need to install qemu-user-static package to build non-native\n# binaries.\n\nset -e -x\ncd \"$(dirname $0)\"\n\nusage() {\n  echo \"Usage: $0 [ x86_64 | aarch64 | arm | riscv64 | ppc64le | s390x | loongarch64 ]\"\n  exit 1\n}\n\ncase $# in\n0)\n  arch=$(uname -m)\n  if [ $arch = arm64 ]; then\n    arch=aarch64\n  elif [[ $arch = arm* ]]; then\n    arch=arm\n  fi\n  ;;\n1)\n  arch=\"$1\"\n  ;;\n*)\n  usage\nesac\n\n# Create a Podman image.\nif [ \"$GITHUB_REPOSITORY\" = '' ]; then\n  image=mold-builder-$arch\n  image_build=\"podman build --arch $arch -t $image -\"\nelse\n  # If this script is running on GitHub Actions, we want to cache\n  # the created container image in GitHub's container repostiory.\n  image=ghcr.io/$GITHUB_REPOSITORY/mold-builder-$arch\n  image_build=\"podman build --arch $arch -t $image --output=type=registry --layers --cache-to $image --cache-from $image -\"\nfi\n\ncase $arch in\nx86_64)\n  # Debian 8 (Jessie) released in April 2015\n  cat <<EOF | $image_build\nFROM debian:jessie-20210326@sha256:32ad5050caffb2c7e969dac873bce2c370015c2256ff984b70c1c08b3a2816a0\nENV DEBIAN_FRONTEND=noninteractive TZ=UTC\nRUN sed -i -e '/^deb/d' -e 's/^# deb /deb [trusted=yes] /g' /etc/apt/sources.list && \\\n  echo 'Acquire::Retries \"10\"; Acquire::http::timeout \"10\"; Acquire::Check-Valid-Until \"false\";' > /etc/apt/apt.conf.d/80-retries && \\\n  apt-get update && \\\n  apt-get install -y --no-install-recommends wget bzip2 file make autoconf gcc g++ libssl-dev && \\\n  rm -rf /var/lib/apt/lists\n\n# Build CMake 3.27\nRUN mkdir /build && \\\n  cd /build && \\\n  wget -O- --no-check-certificate https://cmake.org/files/v3.27/cmake-3.27.7.tar.gz | tar xzf - --strip-components=1 && \\\n  ./bootstrap --parallel=\\$(nproc) && \\\n  make -j\\$(nproc) && \\\n  make install && \\\n  rm -rf /build\n\n# Build GCC 10\nRUN mkdir /build && \\\n  cd /build && \\\n  wget -O- --no-check-certificate https://ftpmirror.gnu.org/gnu/gcc/gcc-10.5.0/gcc-10.5.0.tar.gz | tar xzf - --strip-components=1 && \\\n  mkdir isl gmp mpc mpfr && \\\n  wget -O- --no-check-certificate https://gcc.gnu.org/pub/gcc/infrastructure/isl-0.18.tar.bz2 | tar xjf - --strip-components=1 -C isl && \\\n  wget -O- --no-check-certificate https://ftpmirror.gnu.org/gnu/gmp/gmp-6.1.2.tar.bz2 | tar xjf - --strip-components=1 -C gmp && \\\n  wget -O- --no-check-certificate https://ftpmirror.gnu.org/gnu/mpc/mpc-1.2.1.tar.gz | tar xzf - --strip-components=1 -C mpc && \\\n  wget -O- --no-check-certificate https://ftpmirror.gnu.org/gnu/mpfr/mpfr-4.1.0.tar.gz | tar xzf - --strip-components=1 -C mpfr && \\\n  ./configure --prefix=/usr --enable-languages=c,c++ --disable-bootstrap --disable-multilib && \\\n  make -j\\$(nproc) && \\\n  make install && \\\n  ln -sf /usr/lib64/libstdc++.so.6 /usr/lib/x86_64-linux-gnu/libstdc++.so.6 && \\\n  rm -rf /build\n\n# Build GNU binutils 2.43\nRUN mkdir /build && \\\n  cd /build && \\\n  wget -O- --no-check-certificate https://ftp.gnu.org/gnu/binutils/binutils-2.43.tar.gz | tar xzf - --strip-components=1 && \\\n  ./configure --prefix=/usr && \\\n  make -j\\$(nproc) && \\\n  make install && \\\n  rm -fr /build\n\n# Build Python 3.12.7\nRUN mkdir /build && \\\n  cd /build && \\\n  wget -O- --no-check-certificate https://www.python.org/ftp/python/3.12.7/Python-3.12.7.tgz | tar xzf - --strip-components=1 && \\\n  ./configure && \\\n  make -j\\$(nproc) && \\\n  make install && \\\n  ln -sf /usr/local/bin/python3 /usr/local/bin/python && \\\n  rm -rf /build\n\n# Build LLVM 19\nRUN mkdir /build && \\\n  cd /build && \\\n  wget -O- --no-check-certificate https://github.com/llvm/llvm-project/archive/refs/tags/llvmorg-19.1.6.tar.gz | tar xzf - --strip-components=1 && \\\n  mkdir b && \\\n  cd b && \\\n  cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=clang ../llvm && \\\n  cmake --build . -j\\$(nproc) && \\\n  cmake --install . --strip && \\\n  rm -rf /build\nEOF\n  ;;\naarch64 | arm | ppc64le | s390x)\n  # Debian 11 (Bullseye) released in August 2021\n  #\n  # We don't want to build Clang for these targets with Qemu becuase\n  # that'd take extremely long time. Also I believe old build machines\n  # are usually x86-64.\n  cat <<EOF | $image_build\nFROM debian:bullseye-20240904@sha256:8ccc486c29a3ad02ad5af7f1156e2152dff3ba5634eec9be375269ef123457d8\nENV DEBIAN_FRONTEND=noninteractive TZ=UTC\nRUN sed -i -e '/^deb/d' -e 's/^# deb /deb [trusted=yes] /g' /etc/apt/sources.list && \\\n  echo 'Acquire::Retries \"10\"; Acquire::http::timeout \"10\"; Acquire::Check-Valid-Until \"false\";' > /etc/apt/apt.conf.d/80-retries && \\\n  apt-get update && \\\n  apt-get install -y --no-install-recommends build-essential gcc-10 g++-10 clang-16 cmake && \\\n  ln -sf /usr/bin/clang-16 /usr/bin/clang && \\\n  ln -sf /usr/bin/clang++-16 /usr/bin/clang++ && \\\n  rm -rf /var/lib/apt/lists\nEOF\n  ;;\nriscv64)\n  cat <<EOF | $image_build\nFROM docker.io/riscv64/debian:unstable-20240926@sha256:25654919c2926f38952cdd14b3300d83d13f2d820715f78c9f4b7a1d9399bf48\nENV DEBIAN_FRONTEND=noninteractive TZ=UTC\nRUN sed -i -e '/^URIs/d' -e 's/^# http/URIs: http/' /etc/apt/sources.list.d/debian.sources && \\\n  echo 'Acquire::Retries \"10\"; Acquire::http::timeout \"10\"; Acquire::Check-Valid-Until \"false\";' > /etc/apt/apt.conf.d/80-retries && \\\n  apt-get update && \\\n  apt-get install -y --no-install-recommends build-essential gcc-14 g++-14 clang-18 cmake && \\\n  ln -sf /usr/bin/clang-18 /usr/bin/clang && \\\n  ln -sf /usr/bin/clang++-18 /usr/bin/clang++ && \\\n  rm -rf /var/lib/apt/lists\nEOF\n  ;;\nloongarch64)\n  # LoongArch build is not reproducible yet\n  cat <<EOF | $image_build\nFROM docker.io/loongarch64/debian:sid\nENV DEBIAN_FRONTEND=noninteractive TZ=UTC\nRUN apt-get update && \\\n  apt-get install -y --no-install-recommends build-essential gcc-14 g++-14 clang-19 cmake && \\\n  ln -sf /usr/bin/clang-19 /usr/bin/clang && \\\n  ln -sf /usr/bin/clang++-19 /usr/bin/clang++ && \\\n  rm -rf /var/lib/apt/lists\nEOF\n  ;;\n*)\n  usage\n  ;;\nesac\n\nversion=$(sed -n 's/^project(mold VERSION \\(.*\\))/\\1/p' CMakeLists.txt)\ndest=mold-$version-$arch-linux\n\n# Source tarballs available on GitHub don't contain .git history.\n# Clone the repo if missing.\n[ -d .git ] || git clone --branch v$version --depth 1 --bare https://github.com/rui314/mold .git\n\n# We use the timestamp of the last Git commit as the file timestamp\n# for build artifacts.\ntimestamp=\"$(git log -1 --format=%ci)\"\n\n# Build mold in a container.\nmkdir -p dist\n\npodman run --arch $arch -it --rm --userns=host --pids-limit=-1 \\\n  -v \"$(pwd):/mold:ro\" -v \"$(pwd)/dist:/dist\" $image bash -c \"\nset -e\nmkdir /build\ncd /build\ncmake -DCMAKE_BUILD_TYPE=Release -DMOLD_MOSTLY_STATIC=1 -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ /mold\ncmake --build . -j\\$(nproc)\ncmake --install .\ncmake -DMOLD_USE_MOLD=1 .\ncmake --build . -j\\$(nproc)\nctest --output-on-failure -j\\$(nproc)\ncmake --install . --prefix $dest --strip\nfind $dest -print | xargs touch --no-dereference --date='$timestamp'\nfind $dest -print | sort | tar -cf - --no-recursion --files-from=- | gzip -9nc > /dist/$dest.tar.gz\ncp mold /dist\nsha256sum /dist/$dest.tar.gz\n\"\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "install-build-deps.sh",
          "type": "blob",
          "size": 1.2490234375,
          "content": "#!/bin/sh\n# This script installs binary packages needed to build mold.\n# Feel free to send me a PR if your OS is not on this list.\n\nset -e\n. /etc/os-release\n\nset -x\n\ncase \"$ID\" in\nubuntu | pop | linuxmint | debian | raspbian | neon)\n  apt-get update\n  apt-get install -y cmake gcc g++\n  if [ \"$ID-$VERSION_ID\" = ubuntu-20.04 ]; then apt-get install -y g++-10; fi\n  ;;\nfedora | amzn | rhel)\n  dnf install -y gcc-g++ cmake glibc-static libstdc++-static diffutils util-linux\n  ;;\nopensuse-*)\n  zypper install -y make cmake gcc-c++ glibc-devel-static tar diffutils util-linux\n  ;;\ngentoo)\n  emerge-webrsync\n  FEATURES='getbinpkg binpkg-request-signature' emerge dev-build/cmake\n  ;;\narch | archarm | artix | endeavouros)\n  pacman -Sy --needed --noconfirm base-devel cmake util-linux\n  ;;\nvoid)\n  xbps-install -Sy xbps bash make cmake gcc tar diffutils util-linux\n  ;;\nalpine)\n  apk update\n  apk add bash make linux-headers cmake gcc g++\n  ;;\nclear-linux-os)\n  swupd update\n  swupd bundle-add c-basic diffutils\n  ;;\nalmalinux)\n  dnf install -y gcc-toolset-13-gcc-c++ gcc-toolset-13-libstdc++-devel cmake diffutils\n  ;;\nfreebsd)\n  pkg update\n  pkg install -y cmake bash binutils gcc\n  ;;\n*)\n  echo \"Error: don't know anything about build dependencies on $ID-$VERSION_ID\"\n  exit 1\nesac\n"
        },
        {
          "name": "install-cross-tools.sh",
          "type": "blob",
          "size": 0.509765625,
          "content": "#!/bin/bash\nset -e\n. /etc/os-release\n\nset -x\n\n# This script install packages for -DMOLD_ENABLE_QEMU_TESTS=1\n# to enable cross-target tests.\n#\n# Feel free to send me a PR if your OS is not on this list.\n\ncase \"$ID\" in\nubuntu | pop | linuxmint | debian | raspbian)\n  apt-get install -y qemu-user {gcc,g++}-{i686,aarch64,riscv64,powerpc,powerpc64,powerpc64le,s390x,sparc64,m68k,sh4}-linux-gnu {gcc,g++}-arm-linux-gnueabihf\n  ;;\n*)\n  echo \"Error: don't know anything about build dependencies on $ID-$VERSION_ID\"\n  exit 1\nesac\n"
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "third-party",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}