{
  "metadata": {
    "timestamp": 1736566271452,
    "page": 20,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ssloy/tinyrenderer",
      "stars": 21007,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0224609375,
          "content": "build/\nframebuffer.tga\n"
        },
        {
          "name": ".gitpod.yml",
          "type": "blob",
          "size": 0.2734375,
          "content": "image:\n  file: Dockerfile\ntasks:\n- command: >\n    mkdir --parents build &&\n    cd build &&\n    cmake .. &&\n    make &&\n    ./tinyrenderer ../obj/diablo3_pose/diablo3_pose.obj ../obj/floor.obj &&\n    convert framebuffer.tga framebuffer.png &&\n    open framebuffer.png &&\n    cd ..\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 0.505859375,
          "content": "cmake_minimum_required (VERSION 3.1)\nproject(tinyrenderer)\n\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\nfind_package(OpenMP)\nif(OPENMP_FOUND)\n  set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} ${OpenMP_C_FLAGS}\")\n  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}\")\n  set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} ${OpenMP_EXE_LINKER_FLAGS}\")\nendif()\n\nif(NOT CMAKE_BUILD_TYPE)\n  set(CMAKE_BUILD_TYPE Release)\nendif()\n\nfile(GLOB SOURCES *.h *.cpp)\n\nadd_executable(${PROJECT_NAME} ${SOURCES})\n\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.1142578125,
          "content": "FROM gitpod/workspace-full\n\nUSER root\n# add your tools here\nRUN apt-get update && apt-get install -y \\\n  imagemagick\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 0.8671875,
          "content": "Tiny Renderer, https://github.com/ssloy/tinyrenderer\nCopyright Dmitry V. Sokolov\n\nThis software is provided 'as-is', without any express or implied warranty.\nIn no event will the authors be held liable for any damages arising from the use of this software.\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it freely,\nsubject to the following restrictions:\n\n1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.\n2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.\n3. This notice may not be removed or altered from any source distribution.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.0263671875,
          "content": "# Tiny Renderer or how OpenGL works: software rendering in 500 lines of code\n\n# Check [the wiki](https://github.com/ssloy/tinyrenderer/wiki) for the detailed lessons.\n\n## compilation\n```sh\ngit clone https://github.com/ssloy/tinyrenderer.git &&\ncd tinyrenderer &&\nmkdir build &&\ncd build &&\ncmake .. &&\ncmake --build . -j &&\n./tinyrenderer ../obj/diablo3_pose/diablo3_pose.obj ../obj/floor.obj\n```\nThe rendered image is saved to `framebuffer.tga`.\n\nYou can open the project in Gitpod, a free online dev environment for GitHub:\n[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/ssloy/tinyrenderer)\n\nOn open, the editor will compile & run the program as well as open the resulting image in the editor's preview.\nJust change the code in the editor and rerun the script (use the terminal's history) to see updated images.\n\n## The main idea\n\n**My source code is irrelevant. Read the wiki and implement your own renderer. Only when you suffer through all the tiny details, you will learn what is going on.**\n\nIn [this series of articles](https://github.com/ssloy/tinyrenderer/wiki), I want to show how OpenGL works by writing its clone (a much simplified one). Surprisingly enough, I often meet people who cannot overcome the initial hurdle of learning OpenGL / DirectX. Thus, I have prepared a short series of lectures, after which my students show quite good renderers.\n\nSo, the task is formulated as follows: using no third-party libraries (especially graphic ones), get something like this picture:\n\n![](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/00-home/africanhead.png)\n\n_Warning: this is a training material that will loosely repeat the structure of the OpenGL library. It will be a software renderer. **I do not want to show how to write applications for OpenGL. I want to show how OpenGL works.** I am deeply convinced that it is impossible to write efficient applications using 3D libraries without understanding this._\n\nI will try to make the final code about 500 lines. My students need 10 to 20 programming hours to begin making such renderers. At the input, we get a test file with a polygonal wire + pictures with textures. At the output, we’ll get a rendered model-no graphical interface, and the program simply generates an image.\n\n\nSince the goal is to minimize external dependencies, I give my students just one class that allows working with [TGA](http://en.wikipedia.org/wiki/Truevision_TGA) files. It’s one of the simplest formats that supports images in RGB/RGBA/black and white formats. So, as a starting point, we’ll obtain a simple way to work with pictures. You should note that the only functionality available at the very beginning (in addition to loading and saving images) is the ability to set one pixel's color.\n\nThere are no functions for drawing line segments and triangles. We’ll have to do all of this by hand. I provide my source code that I write in parallel with students. But I would not recommend using it, as this doesn’t make sense. The entire code is available on GitHub, and [here](https://github.com/ssloy/tinyrenderer/tree/909fe20934ba5334144d2c748805690a1fa4c89f) you will find the source code I give to my students.\n\n```C++\n#include \"tgaimage.h\"\nconst TGAColor white = TGAColor(255, 255, 255, 255);\nconst TGAColor red   = TGAColor(255, 0,   0,   255);\nint main(int argc, char** argv) {\n        TGAImage image(100, 100, TGAImage::RGB);\n        image.set(52, 41, red);\n        image.write_tga_file(\"output.tga\");`\n        return 0;\n}\n```\n\noutput.tga should look something like this:\n\n![](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/00-home/reddot.png)\n\n\n# Teaser: few examples made with the renderer\n\n![](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/00-home/demon.png)\n\n![](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/00-home/diablo-glow.png)\n\n![](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/00-home/boggie.png) \n\n![](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/00-home/diablo-ssao.png)\n"
        },
        {
          "name": "geometry.cpp",
          "type": "blob",
          "size": 0.1552734375,
          "content": "#include \"geometry.h\"\n\nvec3 cross(const vec3 &v1, const vec3 &v2) {\n    return vec<3>{v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x};\n}\n\n"
        },
        {
          "name": "geometry.h",
          "type": "blob",
          "size": 6.212890625,
          "content": "#pragma once\n#include <cmath>\n#include <cassert>\n#include <iostream>\n\ntemplate<int n> struct vec {\n    double data[n] = {0};\n    double& operator[](const int i)       { assert(i>=0 && i<n); return data[i]; }\n    double  operator[](const int i) const { assert(i>=0 && i<n); return data[i]; }\n    double norm2() const { return *this * *this; }\n    double norm()  const { return std::sqrt(norm2()); }\n};\n\ntemplate<int n> double operator*(const vec<n>& lhs, const vec<n>& rhs) {\n    double ret = 0;\n    for (int i=n; i--; ret+=lhs[i]*rhs[i]);\n    return ret;\n}\n\ntemplate<int n> vec<n> operator+(const vec<n>& lhs, const vec<n>& rhs) {\n    vec<n> ret = lhs;\n    for (int i=n; i--; ret[i]+=rhs[i]);\n    return ret;\n}\n\ntemplate<int n> vec<n> operator-(const vec<n>& lhs, const vec<n>& rhs) {\n    vec<n> ret = lhs;\n    for (int i=n; i--; ret[i]-=rhs[i]);\n    return ret;\n}\n\ntemplate<int n> vec<n> operator*(const double& rhs, const vec<n> &lhs) {\n    vec<n> ret = lhs;\n    for (int i=n; i--; ret[i]*=rhs);\n    return ret;\n}\n\ntemplate<int n> vec<n> operator*(const vec<n>& lhs, const double& rhs) {\n    vec<n> ret = lhs;\n    for (int i=n; i--; ret[i]*=rhs);\n    return ret;\n}\n\ntemplate<int n> vec<n> operator/(const vec<n>& lhs, const double& rhs) {\n    vec<n> ret = lhs;\n    for (int i=n; i--; ret[i]/=rhs);\n    return ret;\n}\n\ntemplate<int n1,int n2> vec<n1> embed(const vec<n2> &v, double fill=1) {\n    vec<n1> ret;\n    for (int i=n1; i--; ret[i]=(i<n2?v[i]:fill));\n    return ret;\n}\n\ntemplate<int n1,int n2> vec<n1> proj(const vec<n2> &v) {\n    vec<n1> ret;\n    for (int i=n1; i--; ret[i]=v[i]);\n    return ret;\n}\n\ntemplate<int n> std::ostream& operator<<(std::ostream& out, const vec<n>& v) {\n    for (int i=0; i<n; i++) out << v[i] << \" \";\n    return out;\n}\n\ntemplate<> struct vec<2> {\n    double x = 0, y = 0;\n    double& operator[](const int i)       { assert(i>=0 && i<2); return i ? y : x; }\n    double  operator[](const int i) const { assert(i>=0 && i<2); return i ? y : x; }\n    double norm2() const { return *this * *this; }\n    double norm()  const { return std::sqrt(norm2()); }\n    vec<2> normalized() { return (*this)/norm(); }\n};\n\ntemplate<> struct vec<3> {\n    double x = 0, y = 0, z = 0;\n    double& operator[](const int i)       { assert(i>=0 && i<3); return i ? (1==i ? y : z) : x; }\n    double  operator[](const int i) const { assert(i>=0 && i<3); return i ? (1==i ? y : z) : x; }\n    double norm2() const { return *this * *this; }\n    double norm()  const { return std::sqrt(norm2()); }\n    vec<3> normalized() { return (*this)/norm(); }\n};\n\ntypedef vec<2> vec2;\ntypedef vec<3> vec3;\ntypedef vec<4> vec4;\nvec3 cross(const vec3 &v1, const vec3 &v2);\n\ntemplate<int n> struct dt;\n\ntemplate<int nrows,int ncols> struct mat {\n    vec<ncols> rows[nrows] = {{}};\n\n          vec<ncols>& operator[] (const int idx)       { assert(idx>=0 && idx<nrows); return rows[idx]; }\n    const vec<ncols>& operator[] (const int idx) const { assert(idx>=0 && idx<nrows); return rows[idx]; }\n\n    vec<nrows> col(const int idx) const {\n        assert(idx>=0 && idx<ncols);\n        vec<nrows> ret;\n        for (int i=nrows; i--; ret[i]=rows[i][idx]);\n        return ret;\n    }\n\n    void set_col(const int idx, const vec<nrows> &v) {\n        assert(idx>=0 && idx<ncols);\n        for (int i=nrows; i--; rows[i][idx]=v[i]);\n    }\n\n    static mat<nrows,ncols> identity() {\n        mat<nrows,ncols> ret;\n        for (int i=nrows; i--; )\n            for (int j=ncols;j--; ret[i][j]=(i==j));\n        return ret;\n    }\n\n    double det() const {\n        return dt<ncols>::det(*this);\n    }\n\n    mat<nrows-1,ncols-1> get_minor(const int row, const int col) const {\n        mat<nrows-1,ncols-1> ret;\n        for (int i=nrows-1; i--; )\n            for (int j=ncols-1;j--; ret[i][j]=rows[i<row?i:i+1][j<col?j:j+1]);\n        return ret;\n    }\n\n    double cofactor(const int row, const int col) const {\n        return get_minor(row,col).det()*((row+col)%2 ? -1 : 1);\n    }\n\n    mat<nrows,ncols> adjugate() const {\n        mat<nrows,ncols> ret;\n        for (int i=nrows; i--; )\n            for (int j=ncols; j--; ret[i][j]=cofactor(i,j));\n        return ret;\n    }\n\n    mat<nrows,ncols> invert_transpose() const {\n        mat<nrows,ncols> ret = adjugate();\n        return ret/(ret[0]*rows[0]);\n    }\n\n    mat<nrows,ncols> invert() const {\n        return invert_transpose().transpose();\n    }\n\n    mat<ncols,nrows> transpose() const {\n        mat<ncols,nrows> ret;\n        for (int i=ncols; i--; ret[i]=this->col(i));\n        return ret;\n    }\n};\n\ntemplate<int nrows,int ncols> vec<nrows> operator*(const mat<nrows,ncols>& lhs, const vec<ncols>& rhs) {\n    vec<nrows> ret;\n    for (int i=nrows; i--; ret[i]=lhs[i]*rhs);\n    return ret;\n}\n\ntemplate<int R1,int C1,int C2>mat<R1,C2> operator*(const mat<R1,C1>& lhs, const mat<C1,C2>& rhs) {\n    mat<R1,C2> result;\n    for (int i=R1; i--; )\n        for (int j=C2; j--; result[i][j]=lhs[i]*rhs.col(j));\n    return result;\n}\n\ntemplate<int nrows,int ncols>mat<nrows,ncols> operator*(const mat<nrows,ncols>& lhs, const double& val) {\n    mat<nrows,ncols> result;\n    for (int i=nrows; i--; result[i] = lhs[i]*val);\n    return result;\n}\n\ntemplate<int nrows,int ncols>mat<nrows,ncols> operator/(const mat<nrows,ncols>& lhs, const double& val) {\n    mat<nrows,ncols> result;\n    for (int i=nrows; i--; result[i] = lhs[i]/val);\n    return result;\n}\n\ntemplate<int nrows,int ncols>mat<nrows,ncols> operator+(const mat<nrows,ncols>& lhs, const mat<nrows,ncols>& rhs) {\n    mat<nrows,ncols> result;\n    for (int i=nrows; i--; )\n        for (int j=ncols; j--; result[i][j]=lhs[i][j]+rhs[i][j]);\n    return result;\n}\n\ntemplate<int nrows,int ncols>mat<nrows,ncols> operator-(const mat<nrows,ncols>& lhs, const mat<nrows,ncols>& rhs) {\n    mat<nrows,ncols> result;\n    for (int i=nrows; i--; )\n        for (int j=ncols; j--; result[i][j]=lhs[i][j]-rhs[i][j]);\n    return result;\n}\n\ntemplate<int nrows,int ncols> std::ostream& operator<<(std::ostream& out, const mat<nrows,ncols>& m) {\n    for (int i=0; i<nrows; i++) out << m[i] << std::endl;\n    return out;\n}\n\ntemplate<int n> struct dt {\n    static double det(const mat<n,n>& src) {\n        double ret = 0;\n        for (int i=n; i--; ret += src[0][i]*src.cofactor(0,i));\n        return ret;\n    }\n};\n\ntemplate<> struct dt<1> {\n    static double det(const mat<1,1>& src) {\n        return src[0][0];\n    }\n};\n\n"
        },
        {
          "name": "main.cpp",
          "type": "blob",
          "size": 4.1640625,
          "content": "#include <limits>\n#include \"model.h\"\n#include \"our_gl.h\"\n\nconstexpr int width  = 800; // output image size\nconstexpr int height = 800;\nconstexpr vec3 light_dir{1,1,1}; // light source\nconstexpr vec3       eye{1,1,3}; // camera position\nconstexpr vec3    center{0,0,0}; // camera direction\nconstexpr vec3        up{0,1,0}; // camera up vector\n\nextern mat<4,4> ModelView; // \"OpenGL\" state matrices\nextern mat<4,4> Projection;\n\nstruct Shader : IShader {\n    const Model &model;\n    vec3 uniform_l;       // light direction in view coordinates\n    mat<2,3> varying_uv;  // triangle uv coordinates, written by the vertex shader, read by the fragment shader\n    mat<3,3> varying_nrm; // normal per vertex to be interpolated by FS\n    mat<3,3> view_tri;    // triangle in view coordinates\n\n    Shader(const Model &m) : model(m) {\n        uniform_l = proj<3>((ModelView*embed<4>(light_dir, 0.))).normalized(); // transform the light vector to view coordinates\n    }\n\n    virtual void vertex(const int iface, const int nthvert, vec4& gl_Position) {\n        varying_uv.set_col(nthvert, model.uv(iface, nthvert));\n        varying_nrm.set_col(nthvert, proj<3>((ModelView).invert_transpose()*embed<4>(model.normal(iface, nthvert), 0.)));\n        gl_Position= ModelView*embed<4>(model.vert(iface, nthvert));\n        view_tri.set_col(nthvert, proj<3>(gl_Position));\n        gl_Position = Projection*gl_Position;\n    }\n\n    virtual bool fragment(const vec3 bar, TGAColor &gl_FragColor) {\n        vec3 bn = (varying_nrm*bar).normalized(); // per-vertex normal interpolation\n        vec2 uv = varying_uv*bar; // tex coord interpolation\n\n        // for the math refer to the tangent space normal mapping lecture\n        // https://github.com/ssloy/tinyrenderer/wiki/Lesson-6bis-tangent-space-normal-mapping\n        mat<3,3> AI = mat<3,3>{ {view_tri.col(1) - view_tri.col(0), view_tri.col(2) - view_tri.col(0), bn} }.invert();\n        vec3 i = AI * vec3{varying_uv[0][1] - varying_uv[0][0], varying_uv[0][2] - varying_uv[0][0], 0};\n        vec3 j = AI * vec3{varying_uv[1][1] - varying_uv[1][0], varying_uv[1][2] - varying_uv[1][0], 0};\n        mat<3,3> B = mat<3,3>{ {i.normalized(), j.normalized(), bn} }.transpose();\n\n        vec3 n = (B * model.normal(uv)).normalized(); // transform the normal from the texture to the tangent space\n        double diff = std::max(0., n*uniform_l); // diffuse light intensity\n        vec3 r = (n*(n*uniform_l)*2 - uniform_l).normalized(); // reflected light direction, specular mapping is described here: https://github.com/ssloy/tinyrenderer/wiki/Lesson-6-Shaders-for-the-software-renderer\n        double spec = std::pow(std::max(-r.z, 0.), 5+sample2D(model.specular(), uv)[0]); // specular intensity, note that the camera lies on the z-axis (in view), therefore simple -r.z\n\n        TGAColor c = sample2D(model.diffuse(), uv);\n        for (int i : {0,1,2})\n            gl_FragColor[i] = std::min<int>(10 + c[i]*(diff + spec), 255); // (a bit of ambient light, diff + spec), clamp the result\n\n        return false; // the pixel is not discarded\n    }\n};\n\nint main(int argc, char** argv) {\n    if (2>argc) {\n        std::cerr << \"Usage: \" << argv[0] << \" obj/model.obj\" << std::endl;\n        return 1;\n    }\n    TGAImage framebuffer(width, height, TGAImage::RGB); // the output image\n    lookat(eye, center, up);                            // build the ModelView matrix\n    viewport(width/8, height/8, width*3/4, height*3/4); // build the Viewport matrix\n    projection((eye-center).norm());                    // build the Projection matrix\n    std::vector<double> zbuffer(width*height, std::numeric_limits<double>::max());\n\n    for (int m=1; m<argc; m++) { // iterate through all input objects\n        Model model(argv[m]);\n        Shader shader(model);\n        for (int i=0; i<model.nfaces(); i++) { // for every triangle\n            vec4 clip_vert[3]; // triangle coordinates (clip coordinates), written by VS, read by FS\n            for (int j : {0,1,2})\n                shader.vertex(i, j, clip_vert[j]); // call the vertex shader for each triangle vertex\n            triangle(clip_vert, shader, framebuffer, zbuffer); // actual rasterization routine call\n        }\n    }\n    framebuffer.write_tga_file(\"framebuffer.tga\");\n    return 0;\n}\n\n"
        },
        {
          "name": "model.cpp",
          "type": "blob",
          "size": 2.763671875,
          "content": "#include <iostream>\n#include <sstream>\n#include \"model.h\"\n\nModel::Model(const std::string filename) {\n    std::ifstream in;\n    in.open(filename, std::ifstream::in);\n    if (in.fail()) return;\n    std::string line;\n    while (!in.eof()) {\n        std::getline(in, line);\n        std::istringstream iss(line.c_str());\n        char trash;\n        if (!line.compare(0, 2, \"v \")) {\n            iss >> trash;\n            vec3 v;\n            for (int i=0;i<3;i++) iss >> v[i];\n            verts.push_back(v);\n        } else if (!line.compare(0, 3, \"vn \")) {\n            iss >> trash >> trash;\n            vec3 n;\n            for (int i=0;i<3;i++) iss >> n[i];\n            norms.push_back(n.normalized());\n        } else if (!line.compare(0, 3, \"vt \")) {\n            iss >> trash >> trash;\n            vec2 uv;\n            for (int i=0;i<2;i++) iss >> uv[i];\n            tex_coord.push_back({uv.x, 1-uv.y});\n        }  else if (!line.compare(0, 2, \"f \")) {\n            int f,t,n;\n            iss >> trash;\n            int cnt = 0;\n            while (iss >> f >> trash >> t >> trash >> n) {\n                facet_vrt.push_back(--f);\n                facet_tex.push_back(--t);\n                facet_nrm.push_back(--n);\n                cnt++;\n            }\n            if (3!=cnt) {\n                std::cerr << \"Error: the obj file is supposed to be triangulated\" << std::endl;\n                return;\n            }\n        }\n    }\n    std::cerr << \"# v# \" << nverts() << \" f# \"  << nfaces() << \" vt# \" << tex_coord.size() << \" vn# \" << norms.size() << std::endl;\n    load_texture(filename, \"_diffuse.tga\",    diffusemap );\n    load_texture(filename, \"_nm_tangent.tga\", normalmap  );\n    load_texture(filename, \"_spec.tga\",       specularmap);\n}\n\nint Model::nverts() const {\n    return verts.size();\n}\n\nint Model::nfaces() const {\n    return facet_vrt.size()/3;\n}\n\nvec3 Model::vert(const int i) const {\n    return verts[i];\n}\n\nvec3 Model::vert(const int iface, const int nthvert) const {\n    return verts[facet_vrt[iface*3+nthvert]];\n}\n\nvoid Model::load_texture(std::string filename, const std::string suffix, TGAImage &img) {\n    size_t dot = filename.find_last_of(\".\");\n    if (dot==std::string::npos) return;\n    std::string texfile = filename.substr(0,dot) + suffix;\n    std::cerr << \"texture file \" << texfile << \" loading \" << (img.read_tga_file(texfile.c_str()) ? \"ok\" : \"failed\") << std::endl;\n}\n\nvec3 Model::normal(const vec2 &uvf) const {\n    TGAColor c = normalmap.get(uvf[0]*normalmap.width(), uvf[1]*normalmap.height());\n    return vec3{(double)c[2],(double)c[1],(double)c[0]}*2./255. - vec3{1,1,1};\n}\n\nvec2 Model::uv(const int iface, const int nthvert) const {\n    return tex_coord[facet_tex[iface*3+nthvert]];\n}\n\nvec3 Model::normal(const int iface, const int nthvert) const {\n    return norms[facet_nrm[iface*3+nthvert]];\n}\n\n"
        },
        {
          "name": "model.h",
          "type": "blob",
          "size": 1.2548828125,
          "content": "#include <vector>\n#include <string>\n#include \"geometry.h\"\n#include \"tgaimage.h\"\n\nclass Model {\n    std::vector<vec3> verts{};     // array of vertices\n    std::vector<vec2> tex_coord{}; // per-vertex array of tex coords\n    std::vector<vec3> norms{};     // per-vertex array of normal vectors\n    std::vector<int> facet_vrt{};\n    std::vector<int> facet_tex{};  // per-triangle indices in the above arrays\n    std::vector<int> facet_nrm{};\n    TGAImage diffusemap{};         // diffuse color texture\n    TGAImage normalmap{};          // normal map texture\n    TGAImage specularmap{};        // specular map texture\n    void load_texture(const std::string filename, const std::string suffix, TGAImage &img);\npublic:\n    Model(const std::string filename);\n    int nverts() const;\n    int nfaces() const;\n    vec3 normal(const int iface, const int nthvert) const; // per triangle corner normal vertex\n    vec3 normal(const vec2 &uv) const;                     // fetch the normal vector from the normal map texture\n    vec3 vert(const int i) const;\n    vec3 vert(const int iface, const int nthvert) const;\n    vec2 uv(const int iface, const int nthvert) const;\n    const TGAImage& diffuse()  const { return diffusemap;  }\n    const TGAImage& specular() const { return specularmap; }\n};\n\n"
        },
        {
          "name": "obj",
          "type": "tree",
          "content": null
        },
        {
          "name": "our_gl.cpp",
          "type": "blob",
          "size": 2.912109375,
          "content": "#include \"our_gl.h\"\n\nmat<4,4> ModelView;\nmat<4,4> Viewport;\nmat<4,4> Projection;\n\nvoid viewport(const int x, const int y, const int w, const int h) {\n    Viewport = {{{w/2., 0, 0, x+w/2.}, {0, h/2., 0, y+h/2.}, {0,0,1,0}, {0,0,0,1}}};\n}\n\nvoid projection(const double f) { // check https://en.wikipedia.org/wiki/Camera_matrix\n    Projection = {{{1,0,0,0}, {0,-1,0,0}, {0,0,1,0}, {0,0,-1/f,0}}};\n}\n\nvoid lookat(const vec3 eye, const vec3 center, const vec3 up) { // check https://github.com/ssloy/tinyrenderer/wiki/Lesson-5-Moving-the-camera\n    vec3 z = (center-eye).normalized();\n    vec3 x =  cross(up,z).normalized();\n    vec3 y =  cross(z, x).normalized();\n    mat<4,4> Minv = {{{x.x,x.y,x.z,0},   {y.x,y.y,y.z,0},   {z.x,z.y,z.z,0},   {0,0,0,1}}};\n    mat<4,4> Tr   = {{{1,0,0,-eye.x}, {0,1,0,-eye.y}, {0,0,1,-eye.z}, {0,0,0,1}}};\n    ModelView = Minv*Tr;\n}\n\nvec3 barycentric(const vec2 tri[3], const vec2 P) {\n    mat<3,3> ABC = {{embed<3>(tri[0]), embed<3>(tri[1]), embed<3>(tri[2])}};\n    if (ABC.det()<1e-3) return {-1,1,1}; // for a degenerate triangle generate negative coordinates, it will be thrown away by the rasterizator\n    return ABC.invert_transpose() * embed<3>(P);\n}\n\nvoid triangle(const vec4 clip_verts[3], IShader &shader, TGAImage &image, std::vector<double> &zbuffer) {\n    vec4 pts[3]  = { Viewport*clip_verts[0],    Viewport*clip_verts[1],    Viewport*clip_verts[2]    };  // triangle screen coordinates before persp. division\n    vec2 pts2[3] = { proj<2>(pts[0]/pts[0][3]), proj<2>(pts[1]/pts[1][3]), proj<2>(pts[2]/pts[2][3]) };  // triangle screen coordinates after  perps. division\n\n    int bboxmin[2] = {image.width()-1, image.height()-1};\n    int bboxmax[2] = {0, 0};\n    for (int i=0; i<3; i++)\n        for (int j=0; j<2; j++) {\n            bboxmin[j] = std::min(bboxmin[j], static_cast<int>(pts2[i][j]));\n            bboxmax[j] = std::max(bboxmax[j], static_cast<int>(pts2[i][j]));\n        }\n#pragma omp parallel for\n    for (int x=std::max(bboxmin[0], 0); x<=std::min(bboxmax[0], image.width()-1); x++) {\n        for (int y=std::max(bboxmin[1], 0); y<=std::min(bboxmax[1], image.height()-1); y++) {\n            vec3 bc_screen = barycentric(pts2, {static_cast<double>(x), static_cast<double>(y)});\n            vec3 bc_clip   = {bc_screen.x/pts[0][3], bc_screen.y/pts[1][3], bc_screen.z/pts[2][3]};\n            bc_clip = bc_clip/(bc_clip.x+bc_clip.y+bc_clip.z); // check https://github.com/ssloy/tinyrenderer/wiki/Technical-difficulties-linear-interpolation-with-perspective-deformations\n            double frag_depth = vec3{clip_verts[0][2], clip_verts[1][2], clip_verts[2][2]}*bc_clip;\n            if (bc_screen.x<0 || bc_screen.y<0 || bc_screen.z<0 || frag_depth > zbuffer[x+y*image.width()]) continue;\n            TGAColor color;\n            if (shader.fragment(bc_clip, color)) continue; // fragment shader can discard current fragment\n            zbuffer[x+y*image.width()] = frag_depth;\n            image.set(x, y, color);\n        }\n    }\n}\n\n"
        },
        {
          "name": "our_gl.h",
          "type": "blob",
          "size": 0.546875,
          "content": "#include \"tgaimage.h\"\n#include \"geometry.h\"\n\nvoid viewport(const int x, const int y, const int w, const int h);\nvoid projection(const double coeff=0); // coeff = -1/c\nvoid lookat(const vec3 eye, const vec3 center, const vec3 up);\n\nstruct IShader {\n    static TGAColor sample2D(const TGAImage &img, vec2 &uvf) {\n        return img.get(uvf[0] * img.width(), uvf[1] * img.height());\n    }\n    virtual bool fragment(const vec3 bar, TGAColor &color) = 0;\n};\n\nvoid triangle(const vec4 clip_verts[3], IShader &shader, TGAImage &image, std::vector<double> &zbuffer);\n\n"
        },
        {
          "name": "tgaimage.cpp",
          "type": "blob",
          "size": 7.537109375,
          "content": "#include <iostream>\n#include <cstring>\n#include \"tgaimage.h\"\n\nTGAImage::TGAImage(const int w, const int h, const int bpp) : w(w), h(h), bpp(bpp), data(w*h*bpp, 0) {}\n\nbool TGAImage::read_tga_file(const std::string filename) {\n    std::ifstream in;\n    in.open(filename, std::ios::binary);\n    if (!in.is_open()) {\n        std::cerr << \"can't open file \" << filename << \"\\n\";\n        return false;\n    }\n    TGAHeader header;\n    in.read(reinterpret_cast<char *>(&header), sizeof(header));\n    if (!in.good()) {\n        std::cerr << \"an error occured while reading the header\\n\";\n        return false;\n    }\n    w   = header.width;\n    h   = header.height;\n    bpp = header.bitsperpixel>>3;\n    if (w<=0 || h<=0 || (bpp!=GRAYSCALE && bpp!=RGB && bpp!=RGBA)) {\n        std::cerr << \"bad bpp (or width/height) value\\n\";\n        return false;\n    }\n    size_t nbytes = bpp*w*h;\n    data = std::vector<std::uint8_t>(nbytes, 0);\n    if (3==header.datatypecode || 2==header.datatypecode) {\n        in.read(reinterpret_cast<char *>(data.data()), nbytes);\n        if (!in.good()) {\n            std::cerr << \"an error occured while reading the data\\n\";\n            return false;\n        }\n    } else if (10==header.datatypecode||11==header.datatypecode) {\n        if (!load_rle_data(in)) {\n            std::cerr << \"an error occured while reading the data\\n\";\n            return false;\n        }\n    } else {\n        std::cerr << \"unknown file format \" << (int)header.datatypecode << \"\\n\";\n        return false;\n    }\n    if (!(header.imagedescriptor & 0x20))\n        flip_vertically();\n    if (header.imagedescriptor & 0x10)\n        flip_horizontally();\n    std::cerr << w << \"x\" << h << \"/\" << bpp*8 << \"\\n\";\n    return true;\n}\n\nbool TGAImage::load_rle_data(std::ifstream &in) {\n    size_t pixelcount = w*h;\n    size_t currentpixel = 0;\n    size_t currentbyte  = 0;\n    TGAColor colorbuffer;\n    do {\n        std::uint8_t chunkheader = 0;\n        chunkheader = in.get();\n        if (!in.good()) {\n            std::cerr << \"an error occured while reading the data\\n\";\n            return false;\n        }\n        if (chunkheader<128) {\n            chunkheader++;\n            for (int i=0; i<chunkheader; i++) {\n                in.read(reinterpret_cast<char *>(colorbuffer.bgra), bpp);\n                if (!in.good()) {\n                    std::cerr << \"an error occured while reading the header\\n\";\n                    return false;\n                }\n                for (int t=0; t<bpp; t++)\n                    data[currentbyte++] = colorbuffer.bgra[t];\n                currentpixel++;\n                if (currentpixel>pixelcount) {\n                    std::cerr << \"Too many pixels read\\n\";\n                    return false;\n                }\n            }\n        } else {\n            chunkheader -= 127;\n            in.read(reinterpret_cast<char *>(colorbuffer.bgra), bpp);\n            if (!in.good()) {\n                std::cerr << \"an error occured while reading the header\\n\";\n                return false;\n            }\n            for (int i=0; i<chunkheader; i++) {\n                for (int t=0; t<bpp; t++)\n                    data[currentbyte++] = colorbuffer.bgra[t];\n                currentpixel++;\n                if (currentpixel>pixelcount) {\n                    std::cerr << \"Too many pixels read\\n\";\n                    return false;\n                }\n            }\n        }\n    } while (currentpixel < pixelcount);\n    return true;\n}\n\nbool TGAImage::write_tga_file(const std::string filename, const bool vflip, const bool rle) const {\n    constexpr std::uint8_t developer_area_ref[4] = {0, 0, 0, 0};\n    constexpr std::uint8_t extension_area_ref[4] = {0, 0, 0, 0};\n    constexpr std::uint8_t footer[18] = {'T','R','U','E','V','I','S','I','O','N','-','X','F','I','L','E','.','\\0'};\n    std::ofstream out;\n    out.open(filename, std::ios::binary);\n    if (!out.is_open()) {\n        std::cerr << \"can't open file \" << filename << \"\\n\";\n        return false;\n    }\n    TGAHeader header = {};\n    header.bitsperpixel = bpp<<3;\n    header.width  = w;\n    header.height = h;\n    header.datatypecode = (bpp==GRAYSCALE?(rle?11:3):(rle?10:2));\n    header.imagedescriptor = vflip ? 0x00 : 0x20; // top-left or bottom-left origin\n    out.write(reinterpret_cast<const char *>(&header), sizeof(header));\n    if (!out.good()) {\n        std::cerr << \"can't dump the tga file\\n\";\n        return false;\n    }\n    if (!rle) {\n        out.write(reinterpret_cast<const char *>(data.data()), w*h*bpp);\n        if (!out.good()) {\n            std::cerr << \"can't unload raw data\\n\";\n            return false;\n        }\n    } else if (!unload_rle_data(out)) {\n            std::cerr << \"can't unload rle data\\n\";\n            return false;\n        }\n    out.write(reinterpret_cast<const char *>(developer_area_ref), sizeof(developer_area_ref));\n    if (!out.good()) {\n        std::cerr << \"can't dump the tga file\\n\";\n        return false;\n    }\n    out.write(reinterpret_cast<const char *>(extension_area_ref), sizeof(extension_area_ref));\n    if (!out.good()) {\n        std::cerr << \"can't dump the tga file\\n\";\n        return false;\n    }\n    out.write(reinterpret_cast<const char *>(footer), sizeof(footer));\n    if (!out.good()) {\n        std::cerr << \"can't dump the tga file\\n\";\n        return false;\n    }\n    return true;\n}\n\n// TODO: it is not necessary to break a raw chunk for two equal pixels (for the matter of the resulting size)\nbool TGAImage::unload_rle_data(std::ofstream &out) const {\n    const std::uint8_t max_chunk_length = 128;\n    size_t npixels = w*h;\n    size_t curpix = 0;\n    while (curpix<npixels) {\n        size_t chunkstart = curpix*bpp;\n        size_t curbyte = curpix*bpp;\n        std::uint8_t run_length = 1;\n        bool raw = true;\n        while (curpix+run_length<npixels && run_length<max_chunk_length) {\n            bool succ_eq = true;\n            for (int t=0; succ_eq && t<bpp; t++)\n                succ_eq = (data[curbyte+t]==data[curbyte+t+bpp]);\n            curbyte += bpp;\n            if (1==run_length)\n                raw = !succ_eq;\n            if (raw && succ_eq) {\n                run_length--;\n                break;\n            }\n            if (!raw && !succ_eq)\n                break;\n            run_length++;\n        }\n        curpix += run_length;\n        out.put(raw?run_length-1:run_length+127);\n        if (!out.good()) {\n            std::cerr << \"can't dump the tga file\\n\";\n            return false;\n        }\n        out.write(reinterpret_cast<const char *>(data.data()+chunkstart), (raw?run_length*bpp:bpp));\n        if (!out.good()) {\n            std::cerr << \"can't dump the tga file\\n\";\n            return false;\n        }\n    }\n    return true;\n}\n\nTGAColor TGAImage::get(const int x, const int y) const {\n    if (!data.size() || x<0 || y<0 || x>=w || y>=h)\n        return {};\n    TGAColor ret = {0, 0, 0, 0, bpp};\n    const std::uint8_t *p = data.data()+(x+y*w)*bpp;\n    for (int i=bpp; i--; ret.bgra[i] = p[i]);\n    return ret;\n}\n\nvoid TGAImage::set(int x, int y, const TGAColor &c) {\n    if (!data.size() || x<0 || y<0 || x>=w || y>=h) return;\n    memcpy(data.data()+(x+y*w)*bpp, c.bgra, bpp);\n}\n\nvoid TGAImage::flip_horizontally() {\n    int half = w>>1;\n    for (int i=0; i<half; i++)\n        for (int j=0; j<h; j++)\n            for (int b=0; b<bpp; b++)\n                std::swap(data[(i+j*w)*bpp+b], data[(w-1-i+j*w)*bpp+b]);\n}\n\nvoid TGAImage::flip_vertically() {\n    int half = h>>1;\n    for (int i=0; i<w; i++)\n        for (int j=0; j<half; j++)\n            for (int b=0; b<bpp; b++)\n                std::swap(data[(i+j*w)*bpp+b], data[(i+(h-1-j)*w)*bpp+b]);\n}\n\nint TGAImage::width() const {\n    return w;\n}\n\nint TGAImage::height() const {\n    return h;\n}\n\n\n"
        },
        {
          "name": "tgaimage.h",
          "type": "blob",
          "size": 1.392578125,
          "content": "#pragma once\n#include <cstdint>\n#include <fstream>\n#include <vector>\n\n#pragma pack(push,1)\nstruct TGAHeader {\n    std::uint8_t  idlength = 0;\n    std::uint8_t  colormaptype = 0;\n    std::uint8_t  datatypecode = 0;\n    std::uint16_t colormaporigin = 0;\n    std::uint16_t colormaplength = 0;\n    std::uint8_t  colormapdepth = 0;\n    std::uint16_t x_origin = 0;\n    std::uint16_t y_origin = 0;\n    std::uint16_t width = 0;\n    std::uint16_t height = 0;\n    std::uint8_t  bitsperpixel = 0;\n    std::uint8_t  imagedescriptor = 0;\n};\n#pragma pack(pop)\n\nstruct TGAColor {\n    std::uint8_t bgra[4] = {0,0,0,0};\n    std::uint8_t bytespp = 4;\n    std::uint8_t& operator[](const int i) { return bgra[i]; }\n};\n\nstruct TGAImage {\n    enum Format { GRAYSCALE=1, RGB=3, RGBA=4 };\n\n    TGAImage() = default;\n    TGAImage(const int w, const int h, const int bpp);\n    bool  read_tga_file(const std::string filename);\n    bool write_tga_file(const std::string filename, const bool vflip=true, const bool rle=true) const;\n    void flip_horizontally();\n    void flip_vertically();\n    TGAColor get(const int x, const int y) const;\n    void set(const int x, const int y, const TGAColor &c);\n    int width()  const;\n    int height() const;\nprivate:\n    bool   load_rle_data(std::ifstream &in);\n    bool unload_rle_data(std::ofstream &out) const;\n\n    int w = 0;\n    int h = 0;\n    std::uint8_t bpp = 0;\n    std::vector<std::uint8_t> data = {};\n};\n\n"
        }
      ]
    }
  ]
}