{
  "metadata": {
    "timestamp": 1736557274805,
    "page": 156,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "kdn251/interviews",
      "stars": 63790,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".DS_Store",
          "type": "blob",
          "size": 6,
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.01,
          "content": "/bin/\n.idea\n"
        },
        {
          "name": ".project",
          "type": "blob",
          "size": 0.2,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<projectDescription>\n\t<name>interviews</name>\n\t<comment></comment>\n\t<projects>\n\t</projects>\n\t<buildSpec>\n\t</buildSpec>\n\t<natures>\n\t</natures>\n</projectDescription>\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.05,
          "content": "MIT License\n\nCopyright (c) 2018 Kevin Naughton Jr.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README-zh-cn.md",
          "type": "blob",
          "size": 18.2,
          "content": "> * 原文地址：[github.com/kdn251/interviews](https://github.com/kdn251/interviews)\n> * 译文出自：[掘金翻译计划](https://github.com/xitu/gold-miner)\n> * 译者：[王下邀月熊](https://github.com/wxyyxc1992)\n> * 校对者：[PhxNirvana](https://github.com/phxnirvana)、[根号三](https://github.com/sqrthree)\n> * 这个 [链接](https://github.com/xitu/interviews/compare/master...kdn251:master) 用来查看本翻译与英文版是否有差别（如果你没有看到 README.md 发生变化，那就意味着这份翻译文档是最新的）。\n\n# Interviews\n> 软件工程技术面试个人指南。\n>\n> Maintainer - [Kevin Naughton Jr.](https://github.com/kdn251)\n\n## 其他语言版本\n\n- [English](./README.md)\n\n## 目录\n- [在线练习](#在线练习)\n- [在线面试编程](#在线面试编程)\n- [数据结构](#数据结构)\n- [算法](#算法)\n- [位运算](#位运算)\n- [算法复杂度分析](#算法复杂度分析)\n- [视频教程](#视频教程)\n- [面试书籍](#面试书籍)\n- [计算机科学与技术资讯](#计算机科学与技术资讯)\n- [文件结构](#文件结构)\n\n## 在线练习\n* [LeetCode](https://leetcode.com/)\n* [Virtual Judge](https://vjudge.net/)\n* [CareerCup](https://www.careercup.com/)\n* [HackerRank](https://www.hackerrank.com/)\n* [CodeFights](https://codefights.com/)\n* [Kattis](https://open.kattis.com/)\n* [HackerEarth](https://www.hackerearth.com)\n* [Codility](https://codility.com/programmers/lessons/1-iterations/)\n* [Code Forces](http://codeforces.com/)\n* [Code Chef](https://www.codechef.com/)\n* [Sphere Online Judge - SPOJ](http://www.spoj.com/)\n* [InterviewBit](https://www.interviewbit.com/)\n\n## 在线面试编程\n* [Pramp](https://www.pramp.com/ref/gt4-cn)\n* [Gainlo](http://www.gainlo.co/#!/)\n* [Refdash](https://refdash.com/)\n* [Interviewing.io](https://www.interviewing.io/)\n\n## 数据结构\n### Linked List\n * 链表即是由节点（Node）组成的线性集合，每个节点可以利用指针指向其他节点。它是一种包含了多个节点的、能够用于表示序列的数据结构。\n * **单向链表**: 链表中的节点仅指向下一个节点，并且最后一个节点指向空。\n * **双向链表**: 其中每个节点具有两个指针 p、n，使得 p 指向先前节点并且 n 指向下一个节点；最后一个节点的 n 指针指向 null。\n * **循环链表**：每个节点指向下一个节点并且最后一个节点指向第一个节点的链表。\n * 时间复杂度:\n   * 索引: `O(n)`\n   * 搜索: `O(n)`\n   * 插入: `O(1)`\n   * 移除: `O(1)`\n\n### Stack\n * 栈是元素的集合，其包含了两个基本操作：push 操作可以用于将元素压入栈，pop 操作可以将栈顶元素移除。\n * 遵循后入先出（LIFO）原则。\n * 时间复杂度:\n  * 索引: `O(n)`\n  * 搜索: `O(n)`\n  * 插入: `O(1)`\n  * 移除: `O(1)`\n\n### Queue\n * 队列是元素的集合，其包含了两个基本操作：enqueue 操作可以用于将元素插入到队列中，而 dequeue 操作则是将元素从队列中移除。\n * 遵循先入先出原则 (FIFO)。\n * 时间复杂度:\n  * 索引: `O(n)`\n  * 搜索: `O(n)`\n  * 插入: `O(1)`\n  * 移除: `O(1)`\n\n### Tree\n* 树是无向、连通的无环图。\n\n### Binary Tree\n * 二叉树即是每个节点最多包含左子节点与右子节点这两个节点的树形数据结构。\n * **满二叉树**: 树中的每个节点仅包含 0 或 2 个节点。\n * **完美二叉树（Perfect Binary Tree）**: 二叉树中的每个叶节点都拥有两个子节点，并且具有相同的高度。\n * **完全二叉树**: 除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点。\n\n### Binary Search Tree\n\n* 二叉搜索树（BST）是一种特殊的二叉树，其任何节点中的值都会大于或者等于其左子树中存储的值并且小于或者等于其右子树中存储的值。\n* 时间复杂度:\n  * 索引: `O(log(n))`\n  * 搜索: `O(log(n))`\n  * 插入: `O(log(n))`\n  * 删除: `O(log(n))`\n\n<img src=\"/images/BST.png?raw=true\" alt=\"Binary Search Tree\" width=\"400\" height=\"500\">\n\n### Trie\n* 字典树，又称基数树或者前缀树，能够用于存储键为字符串的动态集合或者关联数组的搜索树。树中的节点并没有直接存储关联键值，而是该节点在树中的挂载位置决定了其关联键值。某个节点的所有子节点都拥有相同的前缀，整棵树的根节点则是空字符串。\n\n![Alt text](/images/trie.png?raw=true \"Trie\")\n\n### Fenwick Tree\n* 树状数组又称 Binary Indexed Tree，其表现形式为树，不过本质上是以数组实现。数组中的下标代表着树中的顶点，每个顶点的父节点或者子节点的下标能够通过位运算获得。数组中的每个元素包含了预计算的区间值之和，在整棵树更新的过程中同样会更新这些预计算的值。\n* 时间复杂度:\n  * 区间求值: `O(log(n))`\n  * 更新: `O(log(n))`\n\n![Alt text](/images/fenwickTree.png?raw=true \"Fenwick Tree\")\n\n### Segment Tree\n* 线段树是用于存放间隔或者线段的树形数据结构，它允许快速的查找某一个节点在若干条线段中出现的次数.\n* 时间复杂度:\n  * 区间查询: `O(log(n))`\n  * 更新: `O(log(n))`\n\n![Alt text](/images/segmentTree.png?raw=true \"Segment Tree\")\n\n### Heap\n* 堆是一种特殊的基于树的满足某些特性的数据结构，整个堆中的所有父子节点的键值都会满足相同的排序条件。堆更准确地可以分为最大堆与最小堆，在最大堆中，父节点的键值永远大于或者等于子节点的值，并且整个堆中的最大值存储于根节点；而最小堆中，父节点的键值永远小于或者等于其子节点的键值，并且整个堆中的最小值存储于根节点。\n* 时间复杂度:\n  * 访问最大值 / 最小值: `O(1)`\n  * 插入: `O(log(n))`\n  * 移除最大值 / 最小值: `O(log(n))`\n\n<img src=\"/images/heap.png?raw=true\" alt=\"Max Heap\" width=\"400\" height=\"500\">\n\n\n### Hashing\n* 哈希能够将任意长度的数据映射到固定长度的数据。哈希函数返回的即是哈希值，如果两个不同的键得到相同的哈希值，即将这种现象称为碰撞。\n* **Hash Map**: Hash Map 是一种能够建立起键与值之间关系的数据结构，Hash Map 能够使用哈希函数将键转化为桶或者槽中的下标，从而优化对于目标值的搜索速度。\n* 碰撞解决\n  * **链地址法（Separate Chaining）**: 链地址法中，每个桶是相互独立的，包含了一系列索引的列表。搜索操作的时间复杂度即是搜索桶的时间（固定时间）与遍历列表的时间之和。\n  * **开地址法（Open Addressing）**: 在开地址法中，当插入新值时，会判断该值对应的哈希桶是否存在，如果存在则根据某种算法依次选择下一个可能的位置，直到找到一个尚未被占用的地址。所谓开地址法也是指某个元素的位置并不永远由其哈希值决定。\n\n![Alt text](/images/hash.png?raw=true \"Hashing\")\n\n### Graph\n* 图是一种数据元素间为多对多关系的数据结构，加上一组基本操作构成的抽象数据类型。\n    * **无向图（Undirected Graph）**: 无向图具有对称的邻接矩阵，因此如果存在某条从节点 u 到节点 v 的边，反之从 v 到 u 的边也存在。\n    * **有向图（Directed Graph）**: 有向图的邻接矩阵是非对称的，即如果存在从 u 到 v 的边并不意味着一定存在从 v 到 u 的边。\n\n<img src=\"/images/graph.png?raw=true\" alt=\"Graph\" width=\"400\" height=\"500\">\n\n## 算法\n\n### 排序\n\n#### 快速排序\n* 稳定: 否\n* 时间复杂度:\n  * 最优时间: `O(nlog(n))`\n  * 最坏时间: `O(n^2)`\n  * 平均时间: `O(nlog(n))`\n\n![Alt text](/images/quicksort.gif?raw=true \"Quicksort\")\n\n#### 归并排序\n* 归并排序是典型的分治算法，它不断地将某个数组分为两个部分，分别对左子数组与右子数组进行排序，然后将两个数组合并为新的有序数组。\n* 稳定: 是\n* 时间复杂度:\n  * 最优时间: `O(nlog(n))`\n  * 最坏时间: `O(nlog(n))`\n  * 平均时间: `O(nlog(n))`\n\n![Alt text](/images/mergesort.gif?raw=true \"Mergesort\")\n\n#### 桶排序\n* 桶排序将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。\n* 时间复杂度:\n  * 最优时间: `Ω(n + k)`\n  * 最坏时间: `O(n^2)`\n  * 平均时间:`Θ(n + k)`\n\n\n![Alt text](/images/bucketsort.png?raw=true \"Bucket Sort\")\n\n#### 基数排序\n* 基数排序类似于桶排序，将数组分割到有限数目的桶中；不过其在分割之后并没有让每个桶单独地进行排序，而是直接进行了合并操作。\n* 时间复杂度:\n  * 最优时间: `Ω(nk)`\n  * 最坏时间: `O(nk)`\n  * 平均时间: `Θ(nk)`\n\n### 图算法\n\n#### 深度优先搜索\n* 深度优先算法是一种优先遍历子节点而不是回溯的算法。\n* 时间复杂度: `O(|V| + |E|)`\n\n![Alt text](/images/dfsbfs.gif?raw=true \"DFS / BFS Traversal\")\n\n#### 广度优先搜索\n* 广度优先搜索是优先遍历邻居节点而不是子节点的图遍历算法。\n* 时间复杂度: `O(|V| + |E|)`\n\n![Alt text](/images/dfsbfs.gif?raw=true \"DFS / BFS Traversal\")\n\n#### 拓扑排序\n* 拓扑排序是对于有向图节点的线性排序，如果存在某条从 u 到 v 的边，则认为 u 的下标先于 v。\n* 时间复杂度: `O(|V| + |E|)`\n\n#### Dijkstra 算法\n* **Dijkstra 算法** 用于计算有向图中单源最短路径问题。\n* 时间复杂度: `O(|V|^2)`\n\n![Alt text](/images/dijkstra.gif?raw=true \"Dijkstra's\")\n\n#### Bellman-Ford 算法\n* **Bellman-Ford 算法**是在带权图中计算从单一源点出发到其他节点的最短路径的算法。\n* 尽管算法复杂度大于 Dijkstra 算法，但是它适用于包含了负值边的图。\n* 时间复杂度:\n  * 最优时间: `O(|E|)`\n  - 最坏时间: `O(|V||E|)`\n\n![Alt text](/images/bellman-ford.gif?raw=true \"Bellman-Ford\")\n\n#### Floyd-Warshall 算法\n* **Floyd-Warshall 算法** 能够用于在无环带权图中寻找任意节点的最短路径。\n* 时间复杂度:\n  * 最优时间: `O(|V|^3)`\n  * 最坏时间: `O(|V|^3)`\n  * 平均时间: `O(|V|^3)`\n\n#### Prim 算法\n* **Prim 算法**是用于在带权无向图中计算最小生成树的贪婪算法。换言之，Prim 算法能够在图中抽取出连接所有节点的边的最小代价子集。\n* 时间复杂度: `O(|V|^2)`\n\n![Alt text](/images/prim.gif?raw=true \"Prim's Algorithm\")\n\n#### Kruskal 算法\n* **Kruskal 算法**同样是计算图的最小生成树的算法，与 Prim 的区别在于并不需要图是连通的。\n* 时间复杂度: `O(|E|log|V|)`\n\n![Alt text](/images/kruskal.gif?raw=true \"Kruskal's Algorithm\")\n\n## 位运算\n* 位运算即是在位级别进行操作的技术，合适的位运算能够帮助我们得到更快地运算速度与更小的内存使用。\n* 测试第 k 位: `s & (1 << k)`\n* 设置第 k 位: `s |= (1 << k)`\n* 第 k 位置零: `s &= ~(1 << k)`\n* 切换第 k 位值: `s ^= ~(1 << k)`\n* 乘以 2<sup>n</sup>: `s << n`\n* 除以 2<sup>n</sup>: `s >> n`\n* 交集: `s & t`\n* 并集: `s | t`\n* 减法: `s & ~t`\n* 交换 `x = x ^ y ^ (y = x)`\n* 取出最小非 0 位（Extract lowest set bit）: `s & (-s)`\n* 取出最小 0 位（Extract lowest unset bit）: `~s & (s + 1)`\n* 交换值:\n             ```\n                x ^= y;\n                y ^= x;\n                x ^= y;\n             ```\n\n## 算法复杂度分析\n\n#### 大 O 表示\n* **大 O 表示** 用于表示某个算法的上限，往往用于描述最坏的情况。\n\n![Alt text](/images/bigO.png?raw=true \"Theta Notation\")\n\n#### 小 O 表示\n* **小 O 表示**用于描述某个算法的渐进上界，不过二者要更为紧密。\n\n#### 大 Ω 表示\n* **大 Ω 表示**用于描述某个算法的渐进下界。\n\n![Alt text](/images/bigOmega.png?raw=true \"Theta Notation\")\n\n#### 小 ω 表示\n* **Little Omega Notation**用于描述某个特定算法的下界，不过不一定很靠近。\n\n#### Theta Θ 表示\n* **Theta Notation**用于描述某个确定算法的确界。\n\n![Alt text](/images/theta.png?raw=true \"Theta Notation\")\n\n## 视频教程\n* Data Structures\n  * [UC Berkeley Data Structures](https://www.youtube.com/watch?v=mFPmKGIrQs4&index=1&list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd)\n  * [MIT Advanced Data Structures](https://www.youtube.com/watch?v=T0yzrZL1py0&list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf&index=1)\n* Algorithms\n  * [MIT Introduction to Algorithms](https://www.youtube.com/watch?v=HtSuA80QTyo&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=1)\n  * [MIT Advanced Algorithms](https://www.youtube.com/playlist?list=PL6ogFv-ieghdoGKGg2Bik3Gl1glBTEu8c)\n\n## 面试书籍\n* Competitive Programming 3 - Steven Halim & Felix Halim\n* Cracking The Coding Interview - Gayle Laakmann McDowell\n* Cracking The PM Interview - Gayle Laakmann McDowell & Jackie Bavaro\n\n## 计算机科学与技术资讯\n* [Hacker News](https://news.ycombinator.com/)\n* [Lobsters](https://lobste.rs/)\n\n## 文件结构\n\n```\n.\n├── Array\n│   ├── bestTimeToBuyAndSellStock.java\n│   ├── findTheCelebrity.java\n│   ├── gameOfLife.java\n│   ├── increasingTripletSubsequence.java\n│   ├── insertInterval.java\n│   ├── longestConsecutiveSequence.java\n│   ├── maximumProductSubarray.java\n│   ├── maximumSubarray.java\n│   ├── mergeIntervals.java\n│   ├── missingRanges.java\n│   ├── productOfArrayExceptSelf.java\n│   ├── rotateImage.java\n│   ├── searchInRotatedSortedArray.java\n│   ├── spiralMatrixII.java\n│   ├── subsetsII.java\n│   ├── subsets.java\n│   ├── summaryRanges.java\n│   ├── wiggleSort.java\n│   └── wordSearch.java\n├── Backtracking\n│   ├── androidUnlockPatterns.java\n│   ├── generalizedAbbreviation.java\n│   └── letterCombinationsOfAPhoneNumber.java\n├── BinarySearch\n│   ├── closestBinarySearchTreeValue.java\n│   ├── firstBadVersion.java\n│   ├── guessNumberHigherOrLower.java\n│   ├── pow(x,n).java\n│   └── sqrt(x).java\n├── BitManipulation\n│   ├── binaryWatch.java\n│   ├── countingBits.java\n│   ├── hammingDistance.java\n│   ├── maximumProductOfWordLengths.java\n│   ├── numberOf1Bits.java\n│   ├── sumOfTwoIntegers.java\n│   └── utf-8Validation.java\n├── BreadthFirstSearch\n│   ├── binaryTreeLevelOrderTraversal.java\n│   ├── cloneGraph.java\n│   ├── pacificAtlanticWaterFlow.java\n│   ├── removeInvalidParentheses.java\n│   ├── shortestDistanceFromAllBuildings.java\n│   ├── symmetricTree.java\n│   └── wallsAndGates.java\n├── DepthFirstSearch\n│   ├── balancedBinaryTree.java\n│   ├── battleshipsInABoard.java\n│   ├── convertSortedArrayToBinarySearchTree.java\n│   ├── maximumDepthOfABinaryTree.java\n│   ├── numberOfIslands.java\n│   ├── populatingNextRightPointersInEachNode.java\n│   └── sameTree.java\n├── Design\n│   └── zigzagIterator.java\n├── DivideAndConquer\n│   ├── expressionAddOperators.java\n│   └── kthLargestElementInAnArray.java\n├── DynamicProgramming\n│   ├── bombEnemy.java\n│   ├── climbingStairs.java\n│   ├── combinationSumIV.java\n│   ├── countingBits.java\n│   ├── editDistance.java\n│   ├── houseRobber.java\n│   ├── paintFence.java\n│   ├── paintHouseII.java\n│   ├── regularExpressionMatching.java\n│   ├── sentenceScreenFitting.java\n│   ├── uniqueBinarySearchTrees.java\n│   └── wordBreak.java\n├── HashTable\n│   ├── binaryTreeVerticalOrderTraversal.java\n│   ├── findTheDifference.java\n│   ├── groupAnagrams.java\n│   ├── groupShiftedStrings.java\n│   ├── islandPerimeter.java\n│   ├── loggerRateLimiter.java\n│   ├── maximumSizeSubarraySumEqualsK.java\n│   ├── minimumWindowSubstring.java\n│   ├── sparseMatrixMultiplication.java\n│   ├── strobogrammaticNumber.java\n│   ├── twoSum.java\n│   └── uniqueWordAbbreviation.java\n├── LinkedList\n│   ├── addTwoNumbers.java\n│   ├── deleteNodeInALinkedList.java\n│   ├── mergeKSortedLists.java\n│   ├── palindromeLinkedList.java\n│   ├── plusOneLinkedList.java\n│   ├── README.md\n│   └── reverseLinkedList.java\n├── Queue\n│   └── movingAverageFromDataStream.java\n├── README.md\n├── Sort\n│   ├── meetingRoomsII.java\n│   └── meetingRooms.java\n├── Stack\n│   ├── binarySearchTreeIterator.java\n│   ├── decodeString.java\n│   ├── flattenNestedListIterator.java\n│   └── trappingRainWater.java\n├── String\n│   ├── addBinary.java\n│   ├── countAndSay.java\n│   ├── decodeWays.java\n│   ├── editDistance.java\n│   ├── integerToEnglishWords.java\n│   ├── longestPalindrome.java\n│   ├── longestSubstringWithAtMostKDistinctCharacters.java\n│   ├── minimumWindowSubstring.java\n│   ├── multiplyString.java\n│   ├── oneEditDistance.java\n│   ├── palindromePermutation.java\n│   ├── README.md\n│   ├── reverseVowelsOfAString.java\n│   ├── romanToInteger.java\n│   ├── validPalindrome.java\n│   └── validParentheses.java\n├── Tree\n│   ├── binaryTreeMaximumPathSum.java\n│   ├── binaryTreePaths.java\n│   ├── inorderSuccessorInBST.java\n│   ├── invertBinaryTree.java\n│   ├── lowestCommonAncestorOfABinaryTree.java\n│   ├── sumOfLeftLeaves.java\n│   └── validateBinarySearchTree.java\n├── Trie\n│   ├── addAndSearchWordDataStructureDesign.java\n│   ├── implementTrie.java\n│   └── wordSquares.java\n└── TwoPointers\n    ├── 3Sum.java\n    ├── 3SumSmaller.java\n    ├── mergeSortedArray.java\n    ├── minimumSizeSubarraySum.java\n    ├── moveZeros.java\n    ├── removeDuplicatesFromSortedArray.java\n    ├── reverseString.java\n    └── sortColors.java\n\n18 directories, 124 files\n```\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 22.59,
          "content": "# Interviews\n> Your personal guide to Software Engineering technical interviews. Video\n> solutions to the following interview problems with detailed explanations can be found [here](https://www.youtube.com/channel/UCKvwPt6BifPP54yzH99ff1g).\n<a href=\"https://www.youtube.com/channel/UCKvwPt6BifPP54yzH99ff1g\" style=\"display:block;\"><img src=\"/images/youtube.png?raw=true\"></a>\n>\n> Maintainer - [Kevin Naughton Jr.](https://github.com/kdn251)\n\n## Translations\n\n- [简体中文](./README-zh-cn.md)\n\n## Table of Contents\n- [YouTube](#youtube)\n- [The Daily Byte](#the-daily-byte)\n- [Instagram](#instagram)\n- [Articles](#articles)\n- [Online Judges](#online-judges)\n- [Live Coding Practice](#live-coding-practice)\n- [Data Structures](#data-structures)\n- [Algorithms](#algorithms)\n- [Greedy Algorithms](#greedy-algorithms)\n- [Bitmasks](#bitmasks)\n- [Runtime Analysis](#runtime-analysis)\n- [Video Lectures](#video-lectures)\n- [Interview Books](#interview-books)\n- [Computer Science News](#computer-science-news)\n- [Directory Tree](#directory-tree)\n\n## YouTube\n* [Kevin Naughton Jr.](https://www.youtube.com/channel/UCKvwPt6BifPP54yzH99ff1g)\n\n## The Daily Byte\n* [FAANG Interview Prep](https://bit.ly/2BaaSaK)\n\n## Instagram \n* [Kevin Naughton Jr.](https://bit.ly/2SM8SLZ)\n\n## Articles\n* [Starting Work](https://medium.com/@Naughton/starting-work-b06e10f6007e)\n\n## Online Judges\n* [LeetCode](https://leetcode.com/)\n* [Virtual Judge](https://vjudge.net/)\n* [CareerCup](https://www.careercup.com/)\n* [HackerRank](https://www.hackerrank.com/)\n* [CodeFights](https://codefights.com/)\n* [Kattis](https://open.kattis.com/)\n* [HackerEarth](https://www.hackerearth.com)\n* [Codility](https://codility.com/programmers/lessons/1-iterations/)\n* [Code Forces](http://codeforces.com/)\n* [Code Chef](https://www.codechef.com/)\n* [Sphere Online Judge - SPOJ](http://www.spoj.com/)\n* [InterviewBit](https://www.interviewbit.com/)\n\n## Live Coding Practice\n* [Pramp](https://www.pramp.com/ref/gt4)\n* [Gainlo](http://www.gainlo.co/#!/)\n* [Refdash](https://refdash.com/)\n* [Interviewing.io](https://www.interviewing.io/)\n\n## Data Structures\n### Linked List\n * A *Linked List* is a linear collection of data elements, called nodes, each\n   pointing to the next node by means of a pointer. It is a data structure\n   consisting of a group of nodes which together represent a sequence.\n * **Singly-linked list**: linked list in which each node points to the next node and the last node points to null\n * **Doubly-linked list**: linked list in which each node has two pointers, p and n, such that p points to the previous node and n points to the next node; the last node's n pointer points to null\n * **Circular-linked list**: linked list in which each node points to the next node and the last node points back to the first node\n * Time Complexity:\n   * Access: `O(n)`\n   * Search: `O(n)`\n   * Insert: `O(1)`\n   * Remove: `O(1)`\n\n### Stack\n * A *Stack* is a collection of elements, with two principle operations: *push*, which adds to the collection, and\n   *pop*, which removes the most recently added element\n * **Last in, first out data structure (LIFO)**: the most recently added object is the first to be removed\n * Time Complexity:\n   * Access: `O(n)`\n   * Search: `O(n)`\n   * Insert: `O(1)`\n   * Remove: `O(1)`\n\n### Queue\n * A *Queue* is a collection of elements, supporting two principle operations: *enqueue*, which inserts an element\n   into the queue, and *dequeue*, which removes an element from the queue\n * **First in, first out data structure (FIFO)**: the oldest added object is the first to be removed\n * Time Complexity:\n   * Access: `O(n)`\n   * Search: `O(n)`\n   * Insert: `O(1)`\n   * Remove: `O(1)`\n\n### Tree\n * A *Tree* is an undirected, connected, acyclic graph\n\n### Binary Tree\n * A *Binary Tree* is a tree data structure in which each node has at most two children, which are referred to as\n   the *left child* and *right child*\n * **Full Tree**: a tree in which every node has either 0 or 2 children\n * **Perfect Binary Tree**: a binary tree in which all interior nodes have two children and all leave have the same depth\n * **Complete Tree**: a binary tree in which every level *except possibly the last* is full and all nodes in the last\n   level are as far left as possible\n\n### Binary Search Tree\n * A binary search tree, sometimes called BST, is a type of binary tree which maintains the property that the value in each\n   node must be greater than or equal to any value stored in the left sub-tree, and less than or equal to any value stored\n   in the right sub-tree\n * Time Complexity:\n   * Access: `O(log(n))`\n   * Search: `O(log(n))`\n   * Insert: `O(log(n))`\n   * Remove: `O(log(n))`\n\n<img src=\"/images/BST.png?raw=true\" alt=\"Binary Search Tree\" width=\"400\" height=\"500\">\n\n### Trie\n* A trie, sometimes called a radix or prefix tree, is a kind of search tree that is used to store a dynamic set or associative\n  array where the keys are usually Strings. No node in the tree stores the key associated with that node; instead, its position \n  in the tree defines the key with which it is associated. All the descendants of a node have a common prefix of the String associated \n  with that node, and the root is associated with the empty String.\n\n![Alt text](/images/trie.png?raw=true \"Trie\")\n\n### Fenwick Tree\n* A Fenwick tree, sometimes called a binary indexed tree, is a tree in concept, but in practice is implemented as an implicit data\n  structure using an array. Given an index in the array representing a vertex, the index of a vertex's parent or child is calculated\n  through bitwise operations on the binary representation of its index. Each element of the array contains the pre-calculated sum of\n  a range of values, and by combining that sum with additional ranges encountered during an upward traversal to the root, the prefix\n  sum is calculated\n* Time Complexity:\n  * Range Sum: `O(log(n))`\n  * Update: `O(log(n))`\n\n![Alt text](/images/fenwickTree.png?raw=true \"Fenwick Tree\")\n\n### Segment Tree\n* A Segment tree, is a tree data structure for storing intervals, or segments. It allows querying which of the stored segments contain\n  a given point\n* Time Complexity:\n  * Range Query: `O(log(n))`\n  * Update: `O(log(n))`\n\n![Alt text](/images/segmentTree.png?raw=true \"Segment Tree\")\n\n### Heap\n* A *Heap* is a specialized tree based structure data structure that satisfies the *heap* property: if A is a parent node of\nB, then the key (the value) of node A is ordered with respect to the key of node B with the same ordering applying across the entire heap.\nA heap can be classified further as either a \"max heap\" or a \"min heap\". In a max heap, the keys of parent nodes are always greater\nthan or equal to those of the children and the highest key is in the root node. In a min heap, the keys of parent nodes are less than\nor equal to those of the children and the lowest key is in the root node\n* Time Complexity:\n  * Access Max / Min: `O(1)`\n  * Insert: `O(log(n))`\n  * Remove Max / Min: `O(log(n))`\n\n<img src=\"/images/heap.png?raw=true\" alt=\"Max Heap\" width=\"400\" height=\"500\">\n\n\n### Hashing\n* *Hashing* is used to map data of an arbitrary size to data of a fixed size. The values returned by a hash\n  function are called hash values, hash codes, or simply hashes. If two keys map to the same value, a collision occurs\n* **Hash Map**: a *hash map* is a structure that can map keys to values. A hash map uses a hash function to compute\n  an index into an array of buckets or slots, from which the desired value can be found.\n* Collision Resolution\n * **Separate Chaining**: in *separate chaining*, each bucket is independent, and contains a list of entries for each index. The\n time for hash map operations is the time to find the bucket (constant time), plus the time to iterate through the list\n * **Open Addressing**: in *open addressing*, when a new entry is inserted, the buckets are examined, starting with the\n hashed-to-slot and proceeding in some sequence, until an unoccupied slot is found. The name open addressing refers to\n the fact that the location of an item is not always determined by its hash value\n\n\n![Alt text](/images/hash.png?raw=true \"Hashing\")\n\n### Graph\n* A *Graph* is an ordered pair of G = (V, E) comprising a set V of vertices or nodes together with a set E of edges or arcs,\n  which are 2-element subsets of V (i.e. an edge is associated with two vertices, and that association takes the form of the\n  unordered pair comprising those two vertices)\n * **Undirected Graph**: a graph in which the adjacency relation is symmetric. So if there exists an edge from node u to node\n v (u -> v), then it is also the case that there exists an edge from node v to node u (v -> u)\n * **Directed Graph**: a graph in which the adjacency relation is not symmetric. So if there exists an edge from node u to node v\n (u -> v), this does *not* imply that there exists an edge from node v to node u (v -> u)\n\n\n<img src=\"/images/graph.png?raw=true\" alt=\"Graph\" width=\"400\" height=\"500\">\n\n## Algorithms\n\n### Sorting\n\n#### Quicksort\n* Stable: `No`\n* Time Complexity:\n  * Best Case: `O(nlog(n))`\n  * Worst Case: `O(n^2)`\n  * Average Case: `O(nlog(n))`\n\n![Alt text](/images/quicksort.gif?raw=true \"Quicksort\")\n\n#### Mergesort\n* *Mergesort* is also a divide and conquer algorithm. It continuously divides an array into two halves, recurses on both the\n  left subarray and right subarray and then merges the two sorted halves\n* Stable: `Yes`\n* Time Complexity:\n  * Best Case: `O(nlog(n))`\n  * Worst Case: `O(nlog(n))`\n  * Average Case: `O(nlog(n))`\n\n![Alt text](/images/mergesort.gif?raw=true \"Mergesort\")\n\n#### Bucket Sort\n* *Bucket Sort* is a sorting algorithm that works by distributing the elements of an array into a number of buckets. Each bucket\n  is then sorted individually, either using a different sorting algorithm, or by recursively applying the bucket sorting algorithm\n* Time Complexity:\n  * Best Case: `Ω(n + k)`\n  * Worst Case: `O(n^2)`\n  * Average Case:`Θ(n + k)`\n\n![Alt text](/images/bucketsort.png?raw=true \"Bucket Sort\")\n\n#### Radix Sort\n* *Radix Sort* is a sorting algorithm that like bucket sort, distributes elements of an array into a number of buckets. However, radix\n  sort differs from bucket sort by 're-bucketing' the array after the initial pass as opposed to sorting each bucket and merging\n* Time Complexity:\n  * Best Case: `Ω(nk)`\n  * Worst Case: `O(nk)`\n  * Average Case: `Θ(nk)`\n\n### Graph Algorithms\n\n#### Depth First Search\n* *Depth First Search* is a graph traversal algorithm which explores as far as possible along each branch before backtracking\n* Time Complexity: `O(|V| + |E|)`\n\n![Alt text](/images/dfsbfs.gif?raw=true \"DFS / BFS Traversal\")\n\n#### Breadth First Search\n* *Breadth First Search* is a graph traversal algorithm which explores the neighbor nodes first, before moving to the next\n  level neighbors\n* Time Complexity: `O(|V| + |E|)`\n\n![Alt text](/images/dfsbfs.gif?raw=true \"DFS / BFS Traversal\")\n\n#### Topological Sort\n* *Topological Sort* is the linear ordering of a directed graph's nodes such that for every edge from node u to node v, u\n  comes before v in the ordering\n* Time Complexity: `O(|V| + |E|)`\n\n#### Dijkstra's Algorithm\n* *Dijkstra's Algorithm* is an algorithm for finding the shortest path between nodes in a graph\n* Time Complexity: `O(|V|^2)`\n\n![Alt text](/images/dijkstra.gif?raw=true \"Dijkstra's\")\n\n#### Bellman-Ford Algorithm\n* *Bellman-Ford Algorithm* is an algorithm that computes the shortest paths from a single source node to all other nodes in a weighted graph\n* Although it is slower than Dijkstra's, it is more versatile, as it is capable of handling graphs in which some of the edge weights are\n  negative numbers\n* Time Complexity:\n  * Best Case: `O(|E|)`\n  * Worst Case: `O(|V||E|)`\n\n![Alt text](/images/bellman-ford.gif?raw=true \"Bellman-Ford\")\n\n#### Floyd-Warshall Algorithm\n* *Floyd-Warshall Algorithm* is an algorithm for finding the shortest paths in a weighted graph with positive or negative edge weights, but\n  no negative cycles\n* A single execution of the algorithm will find the lengths (summed weights) of the shortest paths between *all* pairs of nodes\n* Time Complexity:\n  * Best Case: `O(|V|^3)`\n  * Worst Case: `O(|V|^3)`\n  * Average Case: `O(|V|^3)`\n\n#### Prim's Algorithm\n* *Prim's Algorithm* is a greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. In other words, Prim's find a\n  subset of edges that forms a tree that includes every node in the graph\n* Time Complexity: `O(|V|^2)`\n\n![Alt text](/images/prim.gif?raw=true \"Prim's Algorithm\")\n\n#### Kruskal's Algorithm\n* *Kruskal's Algorithm* is also a greedy algorithm that finds a minimum spanning tree in a graph. However, in Kruskal's, the graph does not\n  have to be connected\n* Time Complexity: `O(|E|log|V|)`\n\n![Alt text](/images/kruskal.gif?raw=true \"Kruskal's Algorithm\")\n\n## Greedy Algorithms\n* *Greedy Algorithms* are algorithms that make locally optimal choices at each step in the hope of eventually reaching the globally optimal solution\n* Problems must exhibit two properties in order to implement a Greedy solution:\n * Optimal Substructure\n    * An optimal solution to the problem contains optimal solutions to the given problem's subproblems\n * The Greedy Property\n    * An optimal solution is reached by \"greedily\" choosing the locally optimal choice without ever reconsidering previous choices\n* Example - Coin Change\n    * Given a target amount V cents and a list of denominations of n coins, i.e. we have coinValue[i] (in cents) for coin types i from [0...n - 1],\n      what is the minimum number of coins that we must use to represent amount V? Assume that we have an unlimited supply of coins of any type\n    * Coins - Penny (1 cent), Nickel (5 cents), Dime (10 cents), Quarter (25 cents)\n    * Assume V = 41. We can use the Greedy algorithm of continuously selecting the largest coin denomination less than or equal to V, subtract that\n      coin's value from V, and repeat.\n    * V = 41 | 0 coins used\n    * V = 16 | 1 coin used (41 - 25 = 16)\n    * V = 6  | 2 coins used (16 - 10 = 6)\n    * V = 1  | 3 coins used (6 - 5 = 1)\n    * V = 0  | 4 coins used (1 - 1 = 0)\n    * Using this algorithm, we arrive at a total of 4 coins which is optimal\n\n## Bitmasks\n* Bitmasking is a technique used to perform operations at the bit level. Leveraging bitmasks often leads to faster runtime complexity and\n  helps limit memory usage\n* Test kth bit: `s & (1 << k);`\n* Set kth bit: `s |= (1 << k);`\n* Turn off kth bit: `s &= ~(1 << k);`\n* Toggle kth bit: `s ^= (1 << k);`\n* Multiple by 2<sup>n</sup>: `s << n;`\n* Divide by 2<sup>n</sup>: `s >> n;`\n* Intersection: `s & t;`\n* Union: `s | t;`\n* Set Subtraction: `s & ~t;`\n* Extract lowest set bit: `s & (-s);`\n* Extract lowest unset bit: `~s & (s + 1);`\n* Swap Values:\n             ```\n                x ^= y;\n                y ^= x;\n                x ^= y;\n             ```\n\n## Runtime Analysis\n\n#### Big O Notation\n* *Big O Notation* is used to describe the upper bound of a particular algorithm. Big O is used to describe worst case scenarios\n\n![Alt text](/images/bigO.png?raw=true \"Theta Notation\")\n\n#### Little O Notation\n* *Little O Notation* is also used to describe an upper bound of a particular algorithm; however, Little O provides a bound\n  that is not asymptotically tight\n\n#### Big Ω Omega Notation\n* *Big Omega Notation* is used to provide an asymptotic lower bound on a particular algorithm\n\n![Alt text](/images/bigOmega.png?raw=true \"Theta Notation\")\n\n#### Little ω Omega Notation\n* *Little Omega Notation* is used to provide a lower bound on a particular algorithm that is not asymptotically tight\n\n#### Theta Θ Notation\n* *Theta Notation* is used to provide a bound on a particular algorithm such that it can be \"sandwiched\" between\n  two constants (one for an upper limit and one for a lower limit) for sufficiently large values\n\n![Alt text](/images/theta.png?raw=true \"Theta Notation\")\n\n## Video Lectures\n* Data Structures\n    * [UC Berkeley Data Structures](https://archive.org/details/ucberkeley-webcast?&and[]=subject%3A%22Computer%20Science%22&and[]=subject%3A%22CS%22)\n    * [MIT Advanced Data Structures](https://www.youtube.com/watch?v=T0yzrZL1py0&list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf&index=1)\n* Algorithms\n    * [MIT Introduction to Algorithms](https://www.youtube.com/watch?v=HtSuA80QTyo&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=1)\n    * [MIT Advanced Algorithms](https://www.youtube.com/playlist?list=PL6ogFv-ieghdoGKGg2Bik3Gl1glBTEu8c)\n    * [UC Berkeley Algorithms](https://archive.org/details/ucberkeley-webcast?&and[]=subject%3A%22Computer%20Science%22&and[]=subject%3A%22CS%22)\n\n## Interview Books\n* [Competitive Programming 3 - Steven Halim & Felix Halim](https://www.amazon.com/Competitive-Programming-3rd-Steven-Halim/dp/B00FG8MNN8) \n* [Cracking The Coding Interview - Gayle Laakmann McDowell](https://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/0984782850/ref=sr_1_1?s=books&ie=UTF8)\n* [Cracking The PM Interview - Gayle Laakmann McDowell & Jackie Bavaro](https://www.amazon.com/Cracking-PM-Interview-Product-Technology-ebook/dp/B00ISYMUR6/ref=sr_1_1?s=books&ie=UTF8)\n* [Introduction to Algorithms -  Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest & Clifford Stein](https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844/ref=sr_1_1?ie=UTF8&qid=1490295989&sr=8-1&keywords=Introduction+to+Algorithms)\n\n## Computer Science News\n* [Hacker News](https://news.ycombinator.com/)\n* [Lobsters](https://lobste.rs/)\n\n## Directory Tree\n\n```\n.\n├── Array\n│   ├── bestTimeToBuyAndSellStock.java\n│   ├── findTheCelebrity.java\n│   ├── gameOfLife.java\n│   ├── increasingTripletSubsequence.java\n│   ├── insertInterval.java\n│   ├── longestConsecutiveSequence.java\n│   ├── maximumProductSubarray.java\n│   ├── maximumSubarray.java\n│   ├── mergeIntervals.java\n│   ├── missingRanges.java\n│   ├── productOfArrayExceptSelf.java\n│   ├── rotateImage.java\n│   ├── searchInRotatedSortedArray.java\n│   ├── spiralMatrixII.java\n│   ├── subsetsII.java\n│   ├── subsets.java\n│   ├── summaryRanges.java\n│   ├── wiggleSort.java\n│   └── wordSearch.java\n├── Backtracking\n│   ├── androidUnlockPatterns.java\n│   ├── generalizedAbbreviation.java\n│   └── letterCombinationsOfAPhoneNumber.java\n├── BinarySearch\n│   ├── closestBinarySearchTreeValue.java\n│   ├── firstBadVersion.java\n│   ├── guessNumberHigherOrLower.java\n│   ├── pow(x,n).java\n│   └── sqrt(x).java\n├── BitManipulation\n│   ├── binaryWatch.java\n│   ├── countingBits.java\n│   ├── hammingDistance.java\n│   ├── maximumProductOfWordLengths.java\n│   ├── numberOf1Bits.java\n│   ├── sumOfTwoIntegers.java\n│   └── utf-8Validation.java\n├── BreadthFirstSearch\n│   ├── binaryTreeLevelOrderTraversal.java\n│   ├── cloneGraph.java\n│   ├── pacificAtlanticWaterFlow.java\n│   ├── removeInvalidParentheses.java\n│   ├── shortestDistanceFromAllBuildings.java\n│   ├── symmetricTree.java\n│   └── wallsAndGates.java\n├── DepthFirstSearch\n│   ├── balancedBinaryTree.java\n│   ├── battleshipsInABoard.java\n│   ├── convertSortedArrayToBinarySearchTree.java\n│   ├── maximumDepthOfABinaryTree.java\n│   ├── numberOfIslands.java\n│   ├── populatingNextRightPointersInEachNode.java\n│   └── sameTree.java\n├── Design\n│   └── zigzagIterator.java\n├── DivideAndConquer\n│   ├── expressionAddOperators.java\n│   └── kthLargestElementInAnArray.java\n├── DynamicProgramming\n│   ├── bombEnemy.java\n│   ├── climbingStairs.java\n│   ├── combinationSumIV.java\n│   ├── countingBits.java\n│   ├── editDistance.java\n│   ├── houseRobber.java\n│   ├── paintFence.java\n│   ├── paintHouseII.java\n│   ├── regularExpressionMatching.java\n│   ├── sentenceScreenFitting.java\n│   ├── uniqueBinarySearchTrees.java\n│   └── wordBreak.java\n├── HashTable\n│   ├── binaryTreeVerticalOrderTraversal.java\n│   ├── findTheDifference.java\n│   ├── groupAnagrams.java\n│   ├── groupShiftedStrings.java\n│   ├── islandPerimeter.java\n│   ├── loggerRateLimiter.java\n│   ├── maximumSizeSubarraySumEqualsK.java\n│   ├── minimumWindowSubstring.java\n│   ├── sparseMatrixMultiplication.java\n│   ├── strobogrammaticNumber.java\n│   ├── twoSum.java\n│   └── uniqueWordAbbreviation.java\n├── LinkedList\n│   ├── addTwoNumbers.java\n│   ├── deleteNodeInALinkedList.java\n│   ├── mergeKSortedLists.java\n│   ├── palindromeLinkedList.java\n│   ├── plusOneLinkedList.java\n│   ├── README.md\n│   └── reverseLinkedList.java\n├── Queue\n│   └── movingAverageFromDataStream.java\n├── README.md\n├── Sort\n│   ├── meetingRoomsII.java\n│   └── meetingRooms.java\n├── Stack\n│   ├── binarySearchTreeIterator.java\n│   ├── decodeString.java\n│   ├── flattenNestedListIterator.java\n│   └── trappingRainWater.java\n├── String\n│   ├── addBinary.java\n│   ├── countAndSay.java\n│   ├── decodeWays.java\n│   ├── editDistance.java\n│   ├── integerToEnglishWords.java\n│   ├── longestPalindrome.java\n│   ├── longestSubstringWithAtMostKDistinctCharacters.java\n│   ├── minimumWindowSubstring.java\n│   ├── multiplyString.java\n│   ├── oneEditDistance.java\n│   ├── palindromePermutation.java\n│   ├── README.md\n│   ├── reverseVowelsOfAString.java\n│   ├── romanToInteger.java\n│   ├── validPalindrome.java\n│   └── validParentheses.java\n├── Tree\n│   ├── binaryTreeMaximumPathSum.java\n│   ├── binaryTreePaths.java\n│   ├── inorderSuccessorInBST.java\n│   ├── invertBinaryTree.java\n│   ├── lowestCommonAncestorOfABinaryTree.java\n│   ├── sumOfLeftLeaves.java\n│   └── validateBinarySearchTree.java\n├── Trie\n│   ├── addAndSearchWordDataStructureDesign.java\n│   ├── implementTrie.java\n│   └── wordSquares.java\n└── TwoPointers\n    ├── 3Sum.java\n    ├── 3SumSmaller.java\n    ├── mergeSortedArray.java\n    ├── minimumSizeSubarraySum.java\n    ├── moveZeros.java\n    ├── removeDuplicatesFromSortedArray.java\n    ├── reverseString.java\n    └── sortColors.java\n\n18 directories, 124 files\n```\n"
        },
        {
          "name": "company",
          "type": "tree",
          "content": null
        },
        {
          "name": "cracking-the-coding-interview",
          "type": "tree",
          "content": null
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "interviews.iml",
          "type": "blob",
          "size": 0.33,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<module type=\"JAVA_MODULE\" version=\"4\">\n  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"false\">\n    <output url=\"file://$MODULE_DIR$/bin\" />\n    <exclude-output />\n    <content url=\"file://$MODULE_DIR$\" />\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n  </component>\n</module>"
        },
        {
          "name": "leetcode",
          "type": "tree",
          "content": null
        },
        {
          "name": "uva",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}