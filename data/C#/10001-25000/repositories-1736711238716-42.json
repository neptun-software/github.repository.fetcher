{
  "metadata": {
    "timestamp": 1736711238716,
    "page": 42,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "dotnet/csharplang",
      "stars": 11686,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.01171875,
          "content": "* text=auto\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0419921875,
          "content": ".vscode/*\n\n# Ignore temporary files\n~$*\n*~\n"
        },
        {
          "name": "CODE-OF-CONDUCT.md",
          "type": "blob",
          "size": 0.2529296875,
          "content": "# Code of Conduct\n\nThis project has adopted the code of conduct defined by the Contributor Covenant\nto clarify expected behavior in our community.\n\nFor more information, see the [.NET Foundation Code of Conduct](https://dotnetfoundation.org/code-of-conduct).\n"
        },
        {
          "name": "Communities.md",
          "type": "blob",
          "size": 1.876953125,
          "content": "**Disclaimer**: This document is maintained by the C# community and not the responsibility of the C# Language Design Team (LDT). Please do not contact the LDT for any errors in this document; however, PRs are welcome. \n\n**Channels:**\n\n- [Dotnet Discord](https://aka.ms/dotnet-discord-csharp) - github.com/dotnet discord for discussing dotnet repositories (including csharplang).\n\n    [![Chat on Discord](https://discordapp.com/api/guilds/143867839282020352/widget.png)](https://aka.ms/dotnet-discord-csharp)\n\n- [C# Discord](https://aka.ms/csharp-discord) - General C# discussion not limited to the dotnet repositories.\n\n    [![Chat on Discord](https://discordapp.com/api/guilds/102860784329052160/widget.png)](https://aka.ms/csharp-discord)\n\n- IRC - Any discussion related to the C# language up to the application level.\n\n    [![Join the chat at https://www.irccloud.com/invite?channel=%23%23csharp&amp;hostname=irc.freenode.net&amp;port=6697&amp;ssl=1](https://img.shields.io/badge/IRC-%23%23csharp-1e72ff.svg?style=flat)](https://www.irccloud.com/invite?channel=%23%23csharp&amp;hostname=irc.freenode.net&amp;port=6697&amp;ssl=1) \n\n    Servers: irc.freenode.net, chat.freenode.net\n    \n    Channel: ##csharp\n\n    [![Join the chat at https://www.irccloud.com/invite?channel=%23c%23&amp;hostname=irc.quakenet.org&amp;port=6697&amp;ssl=1](https://img.shields.io/badge/IRC-%23c%23-1e72ff.svg?style=flat)](https://www.irccloud.com/invite?channel=%23c%23&amp;hostname=irc.quakenet.org&amp;port=6697&amp;ssl=1) \n\n    Servers: irc.quakenet.org\n    \n    Channel: #c#\n\n    Recommended IRC Clients: HexChat, mIRC.\n\n**Forums:**\n\n- [Stack Overflow](https://stackoverflow.com)\n\n    Please read [this](https://stackoverflow.com/help/dont-ask) before posting.\n\n- [Reddit](https://www.reddit.com/r/csharp/)\n\n    Please read [this](https://www.reddit.com/r/csharp/comments/3xn6sm/welcome_to_rcsharp_read_this_post_before) before posting.\n"
        },
        {
          "name": "Design-Process.md",
          "type": "blob",
          "size": 18.6689453125,
          "content": "# Language Design Process\n\nThe language design process is the steps that a proposal takes throughout its life, going from an initial seed of an idea, to a championed proposal that is being considered\nfor inclusion in the language, all the way to the final specification representing a feature that has been shipped as part of a .NET release. It is very important to the\nlanguage design team that we have a clear process and organization for this, for multiple reasons:\n\n* Our community is very active and vocal on this repo, and we want to make sure that feedback can be heard and impact the design and direction of the language, as well as\n  ensuring that the community can follow the state of designs.\n* We want to make sure that we are using our design energy effectively, and that we can see the status of previous meetings as we drive a feature to completion.\n* We want to be able to look back historically to use previous design decisions to inform new language features, as well as to ensure that when a feature is incorporated into\n  the ECMA spec, it captures the full nuances of what was designed.\n\nTo achieve these goals, this repository covers the actual proposed text for new language features (often called speclets), notes from language design meetings (called LDM),\nintermediate documents being worked on as part of the development of proposals, issues tracking features that we want to include in the C# language (champion issues), and\ndiscussion topics for those features. In order to keep things organized, we keep discussion of proposals to actual discussions; issues are for tracking purposes only. This\npolicy is changed from previous history in the csharplang repo, so many (most) issues will have some historical discussion in them. However, threaded discussion topics are\nbetter for the types of branching conversations that language features have, so all new discussion will happen in the Discussion forum, rather than on issues.\n\n## Steps of the process\n\nThere are a few steps along the path from the seed of an idea all the way to an implemented language feature that is in an official ECMA specification. While much of that\nprocess takes place outside of this repository (https://github.com/dotnet/roslyn for the language feature implementation, https://github.com/dotnet/runtime for supporting\nBCL APIs and runtime changes, https://github.com/dotnet/csharpstandard/ for the specification changes, just to name a few), we track the overall implementation of the feature\nin this repository, and take the following steps to make understanding the current status easier.\n\n### Proposed feature\n\nNew ideas are submitted as [discussions](https://github.com/dotnet/csharplang/discussions). These ideas can be very freeform, though we ask that you search for duplicates\nbefore opening a new discussion, as the most common first comment on new discussions is one or more links to existing discussions that cover the idea. While ideas are welcome,\nthere is no guarantee that an idea will be adopted into the language; even among things that have been triaged for eventual inclusion in the language, there is more work\nthan can be done in a single lifetime. In order to move forward, a member of the language design team (LDT) has to decide to \"champion\" the idea. This is effectively the\nLDT member deciding to sponsor the idea, and to bring it forward at a future LDM. Most features do not make it out of this stage.\n\nIn order to move to the next stage, there needs to be enough detail to fill out the [proposal template](proposals/proposal-template.md) with at least some amount of detail.\nWhile we do not need exact spec language at this point, there should be enough information that other LDT members can get a general idea of the feature, what areas of the\nlanguage it will impact, and where the complicated aspects are likely to be. In order to be triaged as part of an LDM, this template will need to be checked into the repo.\n\n#### Stage Lifecycle\n\n* Starts when a new discussion is opened\n* Moves to [Championed feature](#championed-feature) when an LDT member decides to champion\n    * For LDT members, see [these instructions](#steps-to-move-a-discussion-to-a-champion-feature) for how to move to the next stage.\n\n### Championed feature\n\nA championed feature is an idea for a C# language feature that an LDT member has decided to sponsor, or \"champion\", for possible inclusion into C#. You can identify issues\nin this category by looking for issues with\n[this query](https://github.com/dotnet/csharplang/issues?q=is%3Aissue%20state%3Aopen%20no%3Amilestone%20label%3A%22Proposal%20champion%22), issues with the `Proposal Champion`\nlabel and no milestone. For these issues, one or more LDT members have indicated that they are interested in the idea, but the entire LDM has not met to discuss the idea and\ngive an official blessing. We try to triage these every few months, though when we start wrapping up a particular release and design time is needed for active questions on\nfeatures currently under development, we can lag behind here.\n\n#### Stage Lifecycle\n\n* Starts when an LDT member decides to champion a [proposed feature](#proposed-feature)\n* Moves to [rejected feature](#rejected-feature) if rejected at LDM\n* Moves to [triaged feature](#triaged-feature) if approved at LDM and assigned to a development milestone\n\n### Triaged feature\n\nA triaged feature is a championed issue that has been approved at LDM for inclusion in a future release of C#. We have quite a few issues in this bucket; they are visible\nby looking at any issues labeled `Proposal Champion` that have been assigned to one of the development milestones, `Any Time`, `Backlog`, `Needs More Work`, or `Working Set`.\n[This query](https://github.com/dotnet/csharplang/issues?q=is%3Aissue%20state%3Aopen%20label%3A%22Proposal%20champion%22%20(milestone%3ABacklog%20OR%20milestone%3A%22Any%20Time%22%20OR%20milestone%3A%22Needs%20More%20Work%22%20OR%20milestone%3A%22Working%20Set%22%20))\nshows these issues. The development milestones mean the following:\n\n* `Working Set` - These are features that are being actively worked on by LDT and/or Roslyn compiler members in some form; whether that's design work behind the scenes,\n  active LDMs discussing the topics, or other actions.\n* `Backlog` - These are features that have been approved for inclusion in C# at some LDM in the past, but are not currently being actively worked on. These are not open to\n  community implementation; they are usually too large or involved to devote LDM time to unless we're willing to make an active effort to get them into the language.\n* `Needs More Work` - These are features that have been approved for inclusion in C# at some LDM in the past, but there are currently design aspects or blocking issues that\n  prevent active work from proceeding at this point.\n* `Any Time` - These are features that have been approved for inclusion in C# at some LDM in the past that are open for community members to contribute to C#. Please do keep\n  in mind that the C# compiler team is constrained by resource limits, and will need to devote significant time to helping get even the simplest of features into the language;\n  please ask _before_ starting to work on one of these features to make sure the team is currently able to devote that time. Features in this category can be in one of two states,\n  denoted by labels on the issue:\n    * `Needs Approved Specification` - LDT has approved this in theory, but has not been presented with a precise specification for how the feature will work. Before implementation\n      can proceed, a complete specification needs to be created and approved at an LDM.\n    * `Needs Implementation` - A specification for this feature has been approved at a previous LDM, and needs to be implemented in the C# compiler.\n\nThis state is the one that will consume most of an approved feature's lifecycle, on average. It is not uncommon for a feature that is approved in theory to spend years in the\nbacklog and/or working set before being implemented.\n\n#### Stage Lifecycle\n\n* Starts when a [championed feature](#championed-feature) is approved at LDM and assigned to a development milestone\n* Ends when the feature is [implemented](#implemented-feature) as part of a C# release\n    * For LDT members, see [these instructions](#steps-to-move-a-triaged-feature-to-an-implemented-feature) for steps to take when shipping a feature.\n* Ends if the feature is reconsidered at an LDM and then [rejected](#rejected-feature)\n\n### Implemented feature\n\nOnce a feature has been implemented in the [Roslyn](https://github.com/dotnet/roslyn) C# compiler and been released as part of an official C# release, it is considered implemented.\nAt this point, it will have a complete speclet available in the [proposals/csharp-\\<release version\\>](proposals) folder (note that some older C# features, particularly the C# 7.X\nand prior features, did not follow this, and have incomplete or non-existent speclets). At this point, the issue will be labeled `Implemented Needs ECMA Specification`, but it will\nnot be closed until the ECMA-334 specification is updated with the feature. This can take some time; the ECMA-334 committee is working on catching up as fast as they can, but is\nseveral years behind the language implementation.\n\n#### Stage Lifecycle\n\n* Starts when a [triaged feature](#triaged-feature) is shipped as part of a C# release\n* Ends when the feature is fully incorporated into a version of the ECMA-334 specification\n\n### ECMA-specified feature\n\nAt this point, the feature has been fully incorporated by ECMA-TC49-TG2, the C# standards committee, into the\n[official C# ECMA specification](https://github.com/dotnet/csharpstandard/). When this happens, we close the issue as completed, and all development work on the feature is\ncomplete.\n\n#### Stage Lifecycle\n\n* Starts when an [implemented feature](#implemented-feature) is shipped as part of a C# release\n* This is the final state for a feature that is included in C#, no further state changes occur\n\n### Rejected feature\n\nWhen a feature is explicitly considered during an LDM, and the LDT decides as a group to reject it, it moves to this state. At this point, close the champion issue as not planned\nand set the milestone to `Likely Never`. It's not impossible for an issue to be pulled back out of this state and included in the language in the future, but generally, this state\nmeans that the feature will never be part of C#.\n\n#### Stage Lifecycle\n\n* Starts when a [championed feature](#championed-feature) is considered at LDM and rejected\n* While it is possible that some rejected features end up getting reconsidered, this is generally the final state for language features that are explicitly considered and\n  rejected during LDM\n\n## Language Design Team processes\n\nThese are various processes and actions taken by LDT members during the development of a feature. Community members should not perform these actions unless invited to do so\nby an LDT member.\n\n### Steps to move a [Discussion](#proposed-feature) to a [Champion feature](#championed-feature)\n\nWhen an LDT member decides to champion a discussion, they take the following steps:\n\n1. Create a new proposal champion issue.\n    * If preferred, the LDT member can ask the original proposer to create this issue.\n    * Note: it can be easier to create the PR for step 6 first, get that into a ready-to-merge state, and then create the champion issue at that point, depending on the complexity\n      of the feature.\n    * The champion issue should have a short summary of the feature, but not the full proposal; there should be enough detail to jog the memory and/or get someone interested in reading the full\n      specification, but should not have detail that will end up needing to be edited often as a proposal evolves.\n2. Assign themselves to the champion issue.\n3. Apply the `Proposal Champion` label to the new issue, as well as to the original discussion.\n4. Link to the original discussion from the champion issue.\n5. Lock the proposal champion issue for comments to ensure that discussion continues in the discussion area, rather than on the champion issue.\n6. Fill out and check in a [proposal template](proposals/proposal-template.md) for the feature. Exact spec language is not required, but there should be enough detail to have a\n   meaningful triage session.\n    * This is also something the LDT member can ask a community member to open a PR for, if they are willing.\n    * The filled out proposal should include a link to the champion issue for easy navigation.\n\n### Bringing open questions to LDM\n\nDuring the course of development of a feature, there are several different types of questions that need to get brought to LDM for answers. The most important overriding factor\nfor any question is that there is a checked-in commit that contains the question. The document and commit will be linked as part of the notes so that future readers of the notes\ncan understand the full context in which the question was asked.\n\n#### Alternative proposals, supplemental documentation\n\nAs part of the initial design of a feature, a number of different proposals may be brought as part of the design process, either as alternatives to an initial design, or as\nsupplemental materials to an existing design to help drive conversation in LDM. We want to keep these \"supplemental\" materials in one place, rather than scattered throughout\nthe repo as different issues, discussions, and other documents. For such material, they should go in the [working group folder](meetings/working-groups/) for that feature. Not\nall features will have such a folder; indeed, most will not. For these documents, please check them in _before_ bringing them to an LDM. The LDM organizer should be able to\nlink to an exact document, not to a PR. In the event the proposer wants to solicit input before LDM, they can leave the PR open until a day or two before LDM; in such a case the\nLDM organizer may decide to link to the PR in the schedule instead of a specific document. However, the PR must be merged before LDM.\n\n#### Specific implementation questions\n\nDuring the implementation process, we will often come up with specific scenarios that need to be brought to an LDM and discussed. These questions should be placed in the proposal\nspecification, in an `Open Questions` section below the main specification text. Each question should have a _linkable_ header, such that the notes that go over the question can\nlink to the exact question being asked. For these questions, please check them in _before_ bringing them to an LDM. The LDM organizer should be able to link to a specific heading\nin a specific document, not to a PR. In the event the questioner wants to solicit input before LDM, they can leave the PR open until a day or two before LDM; in such a case the\nLDM organizer may decide to link to the PR in the schedule instead of a specific document. However, the PR must be merged before LDM.\n\nOnce a question has been answered, the specification should be updated to include any changes required, and the question should be removed. We link to exact commits in the notes\nto ensure that questions can still be found, while keep speclets neat and free of potentially confusing syntax examples that may be rejected at LDM.\n\n#### Proposed specification updates\n\nSometimes during implementation, a specification needs to be updated. These updates are often best viewed by looking at a PR diff; however, PRs present a problem for historical\nrecording keeping. While GitHub does keep around commits that were only ever part of a PR (either because the PR was closed, or because it was squashed/rebased), reusing a PR\nacross multiple LDM sessions can make it difficult to understand the exact state of the PR when it was reviewed by LDM. Whenever possible, do not reuse PRs between multiple LDM\nsessions. When a PR is reviewed by LDM, either close or merge it, and make a new PR for the next LDM to pick up where it left off. This is a guideline, not a rule; there will be\ntimes this cannot happen for whatever reason. But the following rules _must_ be followed:\n\n1. Do not force push over commits that have been reviewed by LDM.\n2. When scheduling your topic for LDM, please use GitHub commit URL or commit range URL. The PR link can be included as well, but the commit (range) is required for inclusion in\n   the notes. The LDM organizer should be able to link to exactly what will be reviewed in the LDM session.\n\n### Steps to move a [triaged feature](#triaged-feature) to an [implemented feature](#implemented-feature)\n\nOnce a feature has been implemented and has or soon will be shipped, take the following steps (these are usually done in bulk when a release nears):\n\n1. If a folder for the C# release does not exist yet, create it.\n2. Move the specification for the feature into that folder.\n3. Update the champion issue as follows:\n   1. Update the specification link to point at the new location.\n   2. Update the milestone of the issue to be the C# release it has shipped/will ship in, creating it if it doesn't exist.\n   3. Add the version of .NET and VS it will/did ship in to the issue title.\n        * As an example, `[Proposal]: Params Collections` became `[Proposal]: Params Collections (VS 17.10, .NET 9)`\n   4. Add the `Implemented Needs ECMA Spec` label to the issue.\n4. Add the feature to the [language version history](Language-Version-History.md) document.\n\n### Publishing notes\n\nWhen publishing a set of notes, take the following steps:\n\n1. Put the notes in the appropriate `meetings/<year>` folder. Notes should follow the `LDM-<year>-<month>-<date>.md` format.\n   1. Any supplemental documents for the meeting are also included here with the same prefix to ensure good sorting.\n   2. Include an agenda at the top with document-relative links to each topic discussed during LDM.\n2. Update the `meetings/<year>/README.md` to:\n   1. Move the date into the `C# Language Design Notes for <year>` section\n   2. Update the agenda to be the final agenda from the meeting notes. Remove document-relative links.\n   3. Include a link to the notes. This format is usually `[C# Language Design Meeting for <month> <day>, <year>](absolute-note-link)`.\n   4. If a topic was not discussed during LDM, or not fully finished, move the topic line back to `Schedule ASAP`.\n3. Commit the updates. Prefer using spelled out dates (ie, January 1st, 1970), rather than abbreviations, to avoid confusion.\n4. Update the champion issues of discussed topics with a link to the notes. Prefer using an exact link to the heading for that set of notes.\n5. Create a discussion for the new notes. The title format is `LDM Notes for <month> <day>, <year>`. Set the category to `LDM Notes`.\n   1. The discussion should link to the full notes, and copy the agenda from the README.\n6. Post the discussion to various communities to let people know the notes are up; at a minimum, to the C# LDM teams chat. We often post to\n   discord as well, but that is dependent on people being who are on discord not being on vacation.\n"
        },
        {
          "name": "Language-Version-History.md",
          "type": "blob",
          "size": 29.2919921875,
          "content": "Features Added in C# Language Versions\n====================\n\n# C# 13.0 - .NET 9 and Visual Studio 2022 version 17.12\n- [ESC escape sequence](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/esc-escape-sequence.md): introduces the `\\e` escape sequence to represent the ESCAPE/ESC character (U+001B).\n- [Method group natural type improvements](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/method-group-natural-type-improvements.md): look scope-by-scope and prune inapplicable candidates early when determining the natural type of a method group.\n- [`Lock` object](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/lock-object.md): allow performing a `lock` on `System.Threading.Lock` instances.\n- Implicit indexer access in object initializers: allows indexers in object initializers to use implicit Index/Range indexers (`new C { [^1] = 2 }`).\n- [`params` collections](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/params-collections.md): extends `params` support to collection types (`void M(params ReadOnlySpan<int> s)`).\n- [`ref`/`unsafe` in iterators/async](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-unsafe-in-iterators-async.md): allows using `ref`/`ref struct` locals and `unsafe` blocks in iterators and async methods between suspension points.\n- [`ref struct` interfaces](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-struct-interfaces.md): allows `ref struct` types to implement interfaces and introduces the `allows ref struct` constraint.\n- [Overload resolution priority](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/overload-resolution-priority.md): allows API authors to adjust the relative priority of overloads within a type using `System.Runtime.CompilerServices.OverloadResolutionPriority`.\n- [Partial properties](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/partial-properties.md): allows splitting a property into multiple parts using the `partial` modifier.\n- [Better conversion from collection expression element](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/collection-expressions-better-conversion.md): improves overload resolution to account for the element type of collection expressions.\n\n# C# 12.0 - .NET 8 and Visual Studio 2022 version 17.8\n\n- [Collection expressions](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md): provides a uniform and efficient way of creating collections using collection-like types (`List<int> list = [1, 2, 3];`)\n- [Primary Constructors](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/primary-constructors.md): helps reduce field and constructor boilerplate (`class Point(int x, int y);`)\n- [Inline Arrays](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/inline-arrays.md): provides a general-purpose and safe mechanism for declaring arrays using the `[InlineArray(size)]` attribute.\n- [Using aliases for any type](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/using-alias-types.md): relaxes many restrictions on `using` alias declarations, allowing built-in types, tuple types, pointer types, array types (`using Point = (int x, int y);`)\n- [Ref readonly parameters](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/ref-readonly-parameters.md): `ref readonly` parameters mandate that arguments are passed by reference instead of potentially copied, can’t be modified, and warn if a temporary variable must be created.\n- [Nameof accessing instance members](https://github.com/dotnet/csharplang/issues/4037): relaxes some restrictions on usage of instance members inside `nameof` (`nameof(field.ToString)`)\n- [Lambda optional parameters](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/lambda-method-group-defaults.md): allows lambda parameters to declare default values (`(int i = 42) => { }`)\n\n# C# 11.0 - .NET 7 and Visual Studio 2022 version 17.4\n\n- [Raw string literals](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/raw-string-literal.md): introduces a string literal where the content never needs escaping (`var json = \"\"\"{ \"summary\": \"text\" }\"\"\";` or `var json = $$\"\"\"{ \"summary\": \"text\", \"length\": {{length}} }\"\"\";`).\n- [UTF-8 string literals](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/utf8-string-literals.md): UTF-8 string literals with the `u8` suffix (`ReadOnlySpan<byte> s = \"hello\"u8;`)\n- [Pattern match `Span<char>` on a constant string](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/pattern-match-span-of-char-on-string.md): an input value of type `Span<char>` or `ReadonlySpan<char>` can be matched with a constant string pattern (`span is \"123\"`).\n- [Newlines in interpolations](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/new-line-in-interpolation.md): allows newline characters in single-line interpolated strings.\n- [List patterns](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/list-patterns.md): allows matching indexable types (`list is [1, 2, ..]`).\n- [File-local types](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/file-local-types.md): introduces the `file` type modifier (`file class C { ... }`).\n- [Ref fields](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md): allows `ref` field declarations in a `ref struct` (`ref struct S { ref int field; ... }`), introduces `scoped` modifier and `[UnscopedRef]` attribute.\n- [Required members](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/required-members.md): introduces the `required` field and property modifier and `[SetsRequiredMembers]` attribute.\n- [Static abstract members in interfaces](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/static-abstracts-in-interfaces.md): allows an interface to specify abstract static members.\n- [Unsigned right-shift operator](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/unsigned-right-shift-operator.md): introduces the `>>>` operator and `>>>=`.\n- [`checked` user-defined operators](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/checked-user-defined-operators.md): numeric and conversion operators support defining `checked` variants (`public static Int128 operator checked +(Int128 lhs, Int128 rhs) { ... }`).\n- [Relaxing shift operator requirements](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/relaxing_shift_operator_requirements.md): the right-hand-side operand of a shift operator is no longer restricted to only be `int`\n- [Numeric IntPtr](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/numeric-intptr.md): `nint`/`nuint` become simple types aliasing `System.IntPtr`/`System.UIntPtr`.\n- [Auto-default structs](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/auto-default-structs.md): struct constructors automatically default fields that are not explicitly assigned.\n- [Generic attributes](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/generic-attributes.md): allows attributes to be generic (`[MyAttribute<int>]`).\n- [Extended `nameof` scope in attributes](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/extended-nameof-scope.md): allows `nameof(parameter)` inside an attribute on a method or parameter (`[MyAttribute(nameof(parameter))] void M(int parameter) { }`).\n\n# C# 10.0 - .NET 6 and Visual Studio 2022 version 17.0\n\n- [Record structs](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-10.0/record-structs.md) (`record struct Point(int X, int Y);`, `var newPoint = point with { X = 100 };`).\n- [With expression](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/record-structs.md#allow-with-expression-on-structs) on structs and anonymous types.\n- [Global using directives](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-10.0/GlobalUsingDirective.md): `global using` directives avoid repeating the same `using` directives across many files in your program.\n- [Improved definite assignment](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-definite-assignment.md): definite assignment and nullability analysis better handle common patterns such as `dictionary?.TryGetValue(key, out value) == true`.\n- [Constant interpolated strings](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/constant_interpolated_strings.md): interpolated strings composed of constants are themselves constants.\n- [Extended property patterns](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/extended-property-patterns.md): property patterns allow accessing nested members (`if (e is MethodCallExpression { Method.Name: \"MethodName\" })`).\n- [Sealed record ToString](https://github.com/dotnet/csharplang/issues/4174): a record can inherit a base record with a sealed `ToString`.\n- [Incremental source generators](https://github.com/dotnet/roslyn/blob/main/docs/features/incremental-generators.md): improve the source generation experience in large projects by breaking down the source generation pipeline and caching intermediate results.\n- [Mixed deconstructions](https://github.com/dotnet/csharplang/issues/125): deconstruction-assignments and deconstruction-declarations can be blended together (`(existingLocal, var declaredLocal) = expression`).\n- [Method-level AsyncMethodBuilder](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/async-method-builders.md): the AsyncMethodBuilder used to compile an `async` method can be overridden locally.\n- [#line span directive](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/enhanced-line-directives.md): allow source generators like Razor fine-grained control of the line mapping with `#line` directives that specify the destination span (`#line (startLine, startChar) - (endLine, endChar) charOffset \"fileName\"`).\n- [Lambda improvements](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/lambda-improvements.md): attributes and return types are allowed on lambdas; lambdas and method groups have a natural delegate type (`var f = short () => 1;`).\n- [Interpolated string handlers](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-interpolated-strings.md): interpolated string handler types allow efficient formatting of interpolated strings in assignments and invocations.\n- [File-scoped namespaces](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/file-scoped-namespaces.md): files with a single namespace don't need extra braces or indentation (`namespace X.Y.Z;`).\n- [Parameterless struct constructors](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/parameterless-struct-constructors.md): support parameterless constructors and instance field initializers for struct types.\n- [CallerArgumentExpression](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/caller-argument-expression.md): this attribute allows capturing the expressions passed to a method as strings.\n\n# C# 9.0 - .NET 5 and Visual Studio 2019 version 16.8 \n- [Records](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-9.0/records.md) and `with` expressions: succinctly declare reference types with value semantics (`record Point(int X, int Y);`, `var newPoint = point with { X = 100 };`).\n- [Init-only setters](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-9.0/init.md): init-only properties can be set during object creation (`int Property { get; init; }`).\n- [Top-level statements](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-9.0/top-level-statements.md): the entry point logic of a program can be written without declaring an explicit type or `Main` method.\n- [Pattern matching enhancements](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-9.0/patterns3.md): relational patterns (`is < 30`), combinator patterns (`is >= 0 and <= 100`, `case 3 or 4:`, `is not null`), parenthesized patterns (`is int and (< 0 or > 100)`), type patterns (`case Type:`).\n- [Native sized integers](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-9.0/native-integers.md): the numeric types `nint` and `nuint` match the platform memory size.\n- [Function pointers](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-9.0/function-pointers.md): enable high-performance code leveraging IL instructions `ldftn` and `calli` (`delegate* <int, void> local;`)\n- [Suppress emitting `localsinit` flag](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-9.0/skip-localsinit.md): attributing a method with `[SkipLocalsInit]` will suppress emitting the `localsinit` flag to reduce cost of zero-initialization.\n- [Target-typed new expressions](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-9.0/target-typed-new.md): `Point p = new(42, 43);`.\n- [Static anonymous functions](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-9.0/static-anonymous-functions.md): ensure that anonymous functions don't capture `this` or local variables (`static () => { ... };`).\n- [Target-typed conditional expressions](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-9.0/target-typed-conditional-expression.md): conditional expressions which lack a natural type can be target-typed (`int? x = b ? 1 : null;`).\n- [Covariant return types](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-9.0/covariant-returns.md): a method override on reference types can declare a more derived return type.\n- [Lambda discard parameters](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-9.0/lambda-discard-parameters.md): multiple parameters `_` appearing in a lambda are allowed and are discards.\n- [Attributes on local functions](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-9.0/local-function-attributes.md).\n- [Module initializers](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-9.0/module-initializers.md): a method attributed with `[ModuleInitializer]` will be executed before any other code in the assembly.\n- [Extension `GetEnumerator`](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-9.0/extension-getenumerator.md): an extension `GetEnumerator` method can be used in a `foreach`.\n- [Partial methods with returned values](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-9.0/extending-partial-methods.md): partial methods can have any accessibility, return a type other than `void` and use `out` parameters, but must be implemented.\n- [Source Generators](https://devblogs.microsoft.com/dotnet/introducing-c-source-generators/)\n\n# C# 8.0 - .NET Core 3.0 and Visual Studio 2019 version 16.3 \n- [Nullable reference types](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-8.0/nullable-reference-types-specification.md): express nullability intent on reference types with `?`, `notnull` constraint and annotations attributes in APIs, the compiler will use those to try and detect possible `null` values being dereferenced or passed to unsuitable APIs.\n- [Default interface members](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-8.0/default-interface-methods.md): interfaces can now have members with default implementations, as well as static/private/protected/internal members except for state (ie. no fields).\n- [Recursive patterns](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-8.0/patterns.md): positional and property patterns allow testing deeper into an object, and switch expressions allow for testing multiple patterns and producing corresponding results in a compact fashion.\n- [Async streams](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-8.0/async-streams.md): `await foreach` and `await using` allow for asynchronous enumeration and disposal of `IAsyncEnumerable<T>` collections and `IAsyncDisposable` resources, and async-iterator methods allow convenient implementation of such asynchronous streams.\n- [Enhanced using](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-8.0/using.md): a `using` declaration is added with an implicit scope and `using` statements and declarations allow disposal of `ref` structs using a pattern.\n- [Ranges and indexes](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-8.0/ranges.md): the `i..j` syntax allows constructing `System.Range` instances, the `^k` syntax allows constructing `System.Index` instances, and those can be used to index/slice collections.\n- [Null-coalescing assignment](https://github.com/dotnet/csharplang/issues/34): `??=` allows conditionally assigning when the value is null.\n- [Static local functions](https://github.com/dotnet/csharplang/issues/1565): local functions modified with `static` cannot capture `this` or local variables, and local function parameters now shadow locals in parent scopes.\n- [Unmanaged generic structs](https://github.com/dotnet/csharplang/issues/1744): generic struct types that only have unmanaged fields are now considered unmanaged (ie. they satisfy the `unmanaged` constraint).\n- [Readonly members](https://github.com/dotnet/csharplang/issues/1710): individual members can now be marked as `readonly` to indicate and enforce that they do not modify instance state.\n- [Stackalloc in nested contexts](https://github.com/dotnet/csharplang/issues/1412): `stackalloc` expressions are now allowed in more expression contexts.\n- [Alternative interpolated verbatim strings](https://github.com/dotnet/csharplang/issues/1630): `@$\"...\"` strings are recognized as interpolated verbatim strings just like `$@\"...\"`.\n- [Obsolete on property accessors](https://github.com/dotnet/csharplang/issues/2152): property accessors can now be individually marked as obsolete.\n- [Permit `t is null` on unconstrained type parameter](https://github.com/dotnet/csharplang/issues/1284)\n\n# C# 7.3 - Visual Studio 2017 version 15.7\n- `System.Enum`, `System.Delegate` and [`unmanaged`](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.3/blittable.md) constraints.\n- [Ref local re-assignment](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.3/ref-local-reassignment.md): Ref locals and ref parameters can now be reassigned with the ref assignment operator (`= ref`).\n- [Stackalloc initializers](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.3/stackalloc-array-initializers.md): Stack-allocated arrays can now be initialized, e.g. `Span<int> x = stackalloc[] { 1, 2, 3 };`.\n- [Indexing movable fixed buffers](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.3/indexing-movable-fixed-fields.md): Fixed buffers can be indexed into without first being pinned.\n- [Custom `fixed` statement](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.3/pattern-based-fixed.md): Types that implement a suitable `GetPinnableReference` can be used in a `fixed` statement.\n- [Improved overload candidates](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.3/improved-overload-candidates.md): Some overload resolution candidates can be ruled out early, thus reducing ambiguities.\n- [Expression variables in initializers and queries](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.3/expression-variables-in-initializers.md): Expression variables like `out var` and pattern variables are allowed in field initializers, constructor initializers and LINQ queries.\n-\t[Tuple comparison](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.3/tuple-equality.md): Tuples can now be compared with `==` and `!=`.\n-\t[Attributes on backing fields](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.3/auto-prop-field-attrs.md): Allows `[field: …]` attributes on an auto-implemented property to target its backing field.\n\n# [C# 7.2](https://blogs.msdn.microsoft.com/dotnet/2017/11/15/welcome-to-c-7-2-and-span/) - Visual Studio 2017 version 15.5\n- [Span and ref-like types](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.2/span-safety.md)\n- [In parameters and readonly references](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.2/readonly-ref.md)\n- [Ref conditional](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.2/conditional-ref.md)\n- [Non-trailing named arguments](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.2/non-trailing-named-arguments.md)\n- [Private protected accessibility](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.2/private-protected.md)\n- [Digit separator after base specifier](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.2/leading-separator.md)\n\n# [C# 7.1](https://blogs.msdn.microsoft.com/dotnet/2017/10/31/welcome-to-c-7-1/) - Visual Studio 2017 version 15.3\n- [Async main](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.1/async-main.md)\n- [Default expressions](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.1/target-typed-default.md)\n- [Reference assemblies](https://github.com/dotnet/roslyn/blob/master/docs/features/refout.md)\n- [Inferred tuple element names](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.1/infer-tuple-names.md)\n- [Pattern-matching with generics](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.1/generics-pattern-match.md)\n\n# [C# 7.0](https://blogs.msdn.microsoft.com/dotnet/2017/03/09/new-features-in-c-7-0/) - Visual Studio 2017\n- [Out variables](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.0/out-var.md)\n- [Pattern matching](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.0/pattern-matching.md)\n- [Tuples](https://github.com/dotnet/roslyn/blob/master/docs/features/tuples.md)\n- [Deconstruction](https://github.com/dotnet/roslyn/blob/master/docs/features/deconstruction.md)\n- [Discards](https://github.com/dotnet/roslyn/blob/master/docs/features/discards.md)\n- [Local Functions](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.0/local-functions.md)\n- [Binary Literals](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.0/binary-literals.md)\n- [Digit Separators](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.0/digit-separators.md)\n- [Ref returns and locals](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/ref-returns)\n- [Generalized async return types](https://github.com/dotnet/roslyn/blob/master/docs/features/task-types.md)\n- [More expression-bodied members](https://docs.microsoft.com/dotnet/csharp/programming-guide/statements-expressions-operators/expression-bodied-members)\n- [Throw expressions](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.0/throw-expression.md)\n\n# [C# 6](https://github.com/dotnet/roslyn/blob/master/docs/wiki/New-Language-Features-in-C%23-6.md) - Visual Studio 2015\n- [Draft Specification online](https://github.com/dotnet/csharpstandard/blob/draft-v6/standard/README.md)\n- Compiler-as-a-service (Roslyn)\n- [Import of static type members into namespace](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/using-static)\n- [Exception filters](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/when)\n- Await in catch/finally blocks\n- Auto property initializers\n- Default values for getter-only properties\n- [Expression-bodied members](https://docs.microsoft.com/dotnet/csharp/programming-guide/statements-expressions-operators/expression-bodied-members)\n- Null propagator (null-conditional operator, succinct null checking)\n- [String interpolation](https://docs.microsoft.com/dotnet/csharp/language-reference/tokens/interpolated)\n- [nameof operator](https://docs.microsoft.com/dotnet/csharp/language-reference/operators/nameof)\n- Dictionary initializer\n\n# [C# 5](https://blogs.msdn.microsoft.com/mvpawardprogram/2012/03/26/an-introduction-to-new-features-in-c-5-0/) - Visual Studio 2012\n- [Asynchronous methods](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/async/)\n- [Caller info attributes](https://docs.microsoft.com/dotnet/csharp/language-reference/attributes/caller-information)\n- foreach loop was changed to generates a new loop variable rather than closing over the same variable every time\n\n# [C# 4](https://msdn.microsoft.com/magazine/ff796223.aspx) - Visual Studio 2010\n- [Dynamic binding](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/using-type-dynamic)\n- [Named and optional arguments](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments)\n- [Co- and Contra-variance for generic delegates and interfaces](https://docs.microsoft.com/dotnet/standard/generics/covariance-and-contravariance)\n- [Embedded interop types (\"NoPIA\")](https://docs.microsoft.com/dotnet/framework/interop/type-equivalence-and-embedded-interop-types)\n\n# [C# 3](https://msdn.microsoft.com/library/bb308966.aspx) - Visual Studio 2008\n- [Implicitly typed local variables](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables)\n- [Object and collection initializers](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/object-and-collection-initializers)\n- [Auto-Implemented properties](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/auto-implemented-properties)\n- [Anonymous types](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/anonymous-types)\n- [Extension methods](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/extension-methods)\n- [Query expressions, a.k.a LINQ (Language Integrated Query)](https://docs.microsoft.com/dotnet/csharp/linq/query-expression-basics)\n- [Lambda expression](https://docs.microsoft.com/dotnet/csharp/programming-guide/statements-expressions-operators/lambda-expressions)\n- [Expression trees](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/expression-trees/)\n- [Partial methods](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/partial-method)\n- [Lock statement](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/lock-statement)\n\n# [C# 2](https://msdn.microsoft.com/library/7cz8t42e(v=vs.80).aspx) - Visual Studio 2005\n- [Generics](https://docs.microsoft.com/dotnet/csharp/programming-guide/generics/)\n- [Partial types](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/partial-type)\n- [Anonymous methods](https://docs.microsoft.com/dotnet/csharp/programming-guide/statements-expressions-operators/anonymous-functions)\n- [Iterators, a.k.a yield statement](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/yield)\n- [Nullable types](https://docs.microsoft.com/dotnet/csharp/language-reference/builtin-types/nullable-value-types)\n- Getter/setter separate accessibility\n- Method group conversions (delegates)\n- [Static classes](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/static-classes-and-static-class-members)\n- Delegate inference\n- Type and namespace aliases\n- [Covariance and contravariance](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/covariance-contravariance/)\n\n# [C# 1.2](https://docs.microsoft.com/dotnet/csharp/whats-new/csharp-version-history#c-version-12) - Visual Studio .NET 2003\n- Dispose in foreach\n- foreach over string specialization\n\n# [C# 1.0](https://en.wikipedia.org/wiki/Microsoft_Visual_Studio#.NET_.282002.29) - Visual Studio .NET 2002\n- [Classes](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/classes)\n- [Structs](https://docs.microsoft.com/dotnet/csharp/language-reference/builtin-types/struct)\n- [Enums](https://docs.microsoft.com/dotnet/csharp/language-reference/builtin-types/enum)\n- [Interfaces](https://docs.microsoft.com/dotnet/csharp/programming-guide/interfaces/)\n- [Events](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/event)\n- [Operator overloading](https://docs.microsoft.com/dotnet/csharp/language-reference/operators/operator-overloading)\n- [User-defined conversion operators](https://docs.microsoft.com/dotnet/csharp/language-reference/operators/user-defined-conversion-operators)\n- [Properties](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/properties)\n- [Indexers](https://docs.microsoft.com/dotnet/csharp/programming-guide/indexers/)\n- Output parameters ([out](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/out) and [ref](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/ref))\n- [`params` arrays](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/params)\n- [Delegates](https://docs.microsoft.com/dotnet/csharp/programming-guide/delegates/)\n- Expressions\n- [using statement](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/using-statement)\n- [goto statement](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/goto)\n- [Preprocessor directives](https://docs.microsoft.com/dotnet/csharp/language-reference/preprocessor-directives/)\n- [Unsafe code and pointers](https://docs.microsoft.com/dotnet/csharp/programming-guide/unsafe-code-pointers/)\n- [Attributes](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/attributes/)\n- Literals\n- [Verbatim identifier](https://docs.microsoft.com/dotnet/csharp/language-reference/tokens/verbatim)\n- Unsigned integer types\n- [Boxing and unboxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.642578125,
          "content": "# C# Language Design\n\n[![Join the chat at https://gitter.im/dotnet/csharplang](https://badges.gitter.im/dotnet/csharplang.svg)](https://gitter.im/dotnet/csharplang?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge) [![Chat on Discord](https://discordapp.com/api/guilds/143867839282020352/widget.png)](https://aka.ms/dotnet-discord-csharp)\n\nWelcome to the official repo for C# language design. This is where new C# language features are developed, adopted and specified.\n\nC# is designed by the C# Language Design Team (LDT) in close coordination with the [Roslyn](https://github.com/dotnet/roslyn) project, which implements the language.\n\nYou can find:\n\n- Active C# language feature proposals in the [proposals folder](proposals)\n- Notes from C# language design meetings in the [meetings folder](meetings)\n- Summary of the [language version history here](Language-Version-History.md).\n\nIf you discover bugs or deficiencies in the above, please leave an issue to raise them, or even better: a pull request to fix them.\n\nFor *new feature proposals*, however, please raise them for [discussion](https://github.com/dotnet/csharplang/labels/Discussion), and *only* submit a proposal as an issue or pull request if invited to do so by a member of the Language Design Team (a \"champion\").\n\nThe complete design process is described [here](Design-Process.md). A shorter overview is below.\n\n## Discussions\n\nDebate pertaining to language features takes place in the form of [Discussions](https://github.com/dotnet/csharplang/discussions) in this repo.\n\nIf you want to suggest a feature, discuss current design notes or proposals, etc., please [open a new Discussion topic](https://github.com/dotnet/csharplang/discussions/new).\n\nDiscussions that are short and stay on topic are much more likely to be read. If you leave comment number fifty, chances are that only a few people will read it. To make discussions easier to navigate and benefit from, please observe a few rules of thumb:\n\n- Discussion should be relevant to C# language design. If they are not, they will be summarily closed.\n- Choose a descriptive topic that clearly communicates the scope of discussion.\n- Stick to the topic of the discussion. If a comment is tangential, or goes into detail on a subtopic, start a new discussion and link back.\n- Is your comment useful for others to read, or can it be adequately expressed with an emoji reaction to an existing comment?\n\nLanguage proposals which prevent specific syntax from occurring can be achieved with a [Roslyn analyzer](https://docs.microsoft.com/visualstudio/extensibility/getting-started-with-roslyn-analyzers). Proposals that only make existing syntax optionally illegal will be rejected by the language design committee to prevent increased language complexity.\n\n## Proposals\n\nWhen a member of the C# LDM finds that a proposal merits consideration by the broader team, they can [Champion](https://github.com/dotnet/csharplang/issues?q=is%3Aopen+is%3Aissue+label%3A%22Proposal+champion%22) it, which means that they will bring it to the C# Language Design Meeting. Proposals are always discussed in linked discussions, not in the champion issue. We didn't always follow this policy, so many champion issues will have discussion on them; we now lock issues to prevent new discussion from occurring on them. Each champion issue will have a discussion link on it.\n\n## Design Process\n\n[Proposals](proposals) evolve as a result of decisions in [Language Design Meetings](meetings), which are informed by [discussions](https://github.com/dotnet/csharplang/discussions), experiments, and offline design work.\n\nIn many cases it will be necessary to implement and share a prototype of a feature in order to land on the right design, and ultimately decide whether to adopt the feature. Prototypes help discover both implementation and usability issues of a feature. A prototype should be implemented in a fork of the [Roslyn repo](https://github.com/dotnet/roslyn) and meet the following bar:\n\n- Parsing (if applicable) should be resilient to experimentation: typing should not cause crashes.\n- Include minimal tests demonstrating the feature at work end-to-end.\n- Include minimal IDE support (keyword coloring, formatting, completion).\n\nOnce approved, a feature should be fully implemented in [Roslyn](https://github.com/dotnet/roslyn), and fully specified in the [language specification](spec), whereupon the proposal is moved into the appropriate folder for a completed feature, e.g. [C# 7.1 proposals](proposals/csharp-7.1).\n\n**DISCLAIMER**: An active proposal is under active consideration for inclusion into a future version of the C# programming language but is not in any way guaranteed to ultimately be included in the next or any version of the language. A proposal may be postponed or rejected at any time during any phase of the above process based on feedback from the design team, community, code reviewers, or testing.\n\n### Milestones\n\nWe have a few different milestones for issues on the repo:\n* [Working Set](https://github.com/dotnet/csharplang/milestone/19) is the set of championed proposals that are currently being actively worked on. Not everything in this milestone will make the next version of C#, but it will get design time during the upcoming release.\n* [Backlog](https://github.com/dotnet/csharplang/milestone/10) is the set of championed proposals that have been triaged, but are not being actively worked on. While discussion and ideas from the community are welcomed on these proposals, the cost of the design work and implementation review on these features are too high for us to consider community implementation until we are ready for it.\n* [Any Time](https://github.com/dotnet/csharplang/milestone/14) is the set of championed proposals that have been triaged, but are not being actively worked on and are open to community implementation. Issues in this can be in one of 2 states: needs approved specification, and needs implementation. Those that need a specification still need to be presented during LDM for approval of the spec, but we are willing to take the time to do so at our earliest convenience.\n* [Likely Never](https://github.com/dotnet/csharplang/milestone/13) is the set of proposals that the LDM has rejected from the language. Without strong need or community feedback, these proposals will not be considered in the future.\n* Numbered milestones are the set of features that have been implemented for that particular language version. For closed milestones, these are the set of things that shipped with that release. For open milestones, features can be potentially pulled later if we discover compatibility or other issues as we near release.\n\n## Language Design Meetings\n\nLanguage Design Meetings (LDMs) are held by the LDT and occasional invited guests, and are documented in Design Meeting Notes in the [meetings](meetings) folder, organized in folders by year. The lifetime of a design meeting note is described in [meetings/README.md](meetings/README.md). LDMs are where decisions about future C# versions are made, including which proposals to work on, how to evolve the proposals, and whether and when to adopt them.\n\n## Language Specification\n\nThe current ECMA-334 specification can be found in markdown form on the [C# Language Standard](https://github.com/dotnet/csharpstandard/) repository.\n\n## Implementation\n\nThe reference implementation of the C# language can be found in the [Roslyn repository](https://github.com/dotnet/roslyn). This repository also tracks the [implementation status for language features](https://github.com/dotnet/roslyn/blob/main/docs/Language%20Feature%20Status.md). Until recently, that was also where language design artifacts were tracked. Please allow a little time as we move over active proposals.\n"
        },
        {
          "name": "meetings",
          "type": "tree",
          "content": null
        },
        {
          "name": "proposals",
          "type": "tree",
          "content": null
        },
        {
          "name": "spec",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}