{
  "metadata": {
    "timestamp": 1736711161448,
    "page": 42,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "davidfowl/AspNetCoreDiagnosticScenarios",
      "stars": 8174,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.84375,
          "content": "*.doc  diff=astextplain\n*.DOC\tdiff=astextplain\n*.docx\tdiff=astextplain\n*.DOCX\tdiff=astextplain\n*.dot\tdiff=astextplain\n*.DOT\tdiff=astextplain\n*.pdf\tdiff=astextplain\n*.PDF\tdiff=astextplain\n*.rtf\tdiff=astextplain\n*.RTF\tdiff=astextplain\n\n*.jpg  \tbinary\n*.png \tbinary\n*.gif \tbinary\n\n*.cs text=auto diff=csharp \n*.vb text=auto\n*.resx text=auto\n*.c text=auto\n*.cpp text=auto\n*.cxx text=auto\n*.h text=auto\n*.hxx text=auto\n*.py text=auto\n*.rb text=auto\n*.java text=auto\n*.html text=auto\n*.htm text=auto\n*.css text=auto\n*.scss text=auto\n*.sass text=auto\n*.less text=auto\n*.js text=auto\n*.lisp text=auto\n*.clj text=auto\n*.sql text=auto\n*.php text=auto\n*.lua text=auto\n*.m text=auto\n*.asm text=auto\n*.erl text=auto\n*.fs text=auto\n*.fsx text=auto\n*.hs text=auto\n\n*.csproj text=auto\n*.vbproj text=auto\n*.fsproj text=auto\n*.dbproj text=auto\n*.sln text=auto eol=crlf\n\n*.sh eol=lf\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.435546875,
          "content": "[Oo]bj/\n[Bb]in/\nTestResults/\n.nuget/\n.build/\n.testPublish/\npublish/\n*.sln.ide/\n_ReSharper.*/\npackages/\nshared/\nartifacts/\nPublishProfiles/\n.vs/\nbower_components/\nnode_modules/\ndebugSettings.json\nproject.lock.json\n*.user\n*.suo\n*.cache\n*.docstates\n_ReSharper.*\nnuget.exe\n*net45.csproj\n*net451.csproj\n*k10.csproj\n*.psess\n*.vsp\n*.pidb\n*.userprefs\n*DS_Store\n*.ncrunchsolution\n*.*sdf\n*.ipch\n.settings\n*.sln.ide\nnode_modules\n*launchSettings.json\n*.orig\n"
        },
        {
          "name": "AspNetCoreDiagnosticScenarios.sln",
          "type": "blob",
          "size": 1.0751953125,
          "content": "﻿\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio 15\nVisualStudioVersion = 15.0.28010.2036\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Scenarios\", \"Scenarios\\Scenarios.csproj\", \"{D05E3242-E5ED-493F-B75D-48A494C6CE4B}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|Any CPU = Debug|Any CPU\n\t\tRelease|Any CPU = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{D05E3242-E5ED-493F-B75D-48A494C6CE4B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{D05E3242-E5ED-493F-B75D-48A494C6CE4B}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{D05E3242-E5ED-493F-B75D-48A494C6CE4B}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{D05E3242-E5ED-493F-B75D-48A494C6CE4B}.Release|Any CPU.Build.0 = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {F02E06C8-1856-4E32-A48C-3C827878CD3A}\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "AspNetCoreGuidance.md",
          "type": "blob",
          "size": 17.1875,
          "content": "# Table of contents\n - [ASP.NET Core Guidance](#aspnet-core-guidance)\n   - [Avoid using synchronous Read/Write overloads on HttpRequest.Body and HttpResponse.Body](#avoid-using-synchronous-readwrite-overloads-on-httprequestbody-and-httpresponsebody)\n   - [Prefer using HttpRequest.ReadFormAsync() over HttpRequest.Form](#prefer-using-httprequestreadformasync-over-httprequestform)\n   - [Avoid reading large request bodies or response bodies into memory](#avoid-reading-large-request-bodies-or-response-bodies-into-memory)\n   - [Use buffered and synchronous reads and writes as an alternative to asynchronous reading and writing](#use-buffered-and-synchronous-reads-and-writes-as-an-alternative-to-asynchronous-reading-and-writing)\n   - [Do not store IHttpContextAccessor.HttpContext in a field](#do-not-store-ihttpcontextaccessorhttpcontext-in-a-field)\n   - [Do not access the HttpContext from multiple threads in parallel. It is not thread safe.](#do-not-access-the-httpcontext-from-multiple-threads-in-parallel-it-is-not-thread-safe)\n   - [Do not use the HttpContext after the request is complete](#do-not-use-the-httpcontext-after-the-request-is-complete)\n   - [Do not capture the HttpContext in background threads](#do-not-capture-the-httpcontext-in-background-threads)\n   - [Do not capture services injected into the controllers on background threads](#do-not-capture-services-injected-into-the-controllers-on-background-threads)\n   - [Avoid adding headers after the HttpResponse has started](#avoid-adding-headers-after-the-httpresponse-has-started)\n\n# ASP.NET Core Guidance\n\nASP.NET Core is a cross-platform, high-performance, open-source framework for building modern, cloud-based, Internet-connected applications. This guide captures some of the common pitfalls and practices when writing scalable server applications.\n\n## Avoid using synchronous Read/Write overloads on HttpRequest.Body and HttpResponse.Body\n\nAll IO in ASP.NET Core is asynchronous. Servers implement the `Stream` interface which has both synchronous and asynchronous overloads. The asynchronous ones should be preferred to avoid blocking thread pool threads (this could lead to thread pool starvation).\n\n❌ **BAD** This example uses the `StreamReader.ReadToEnd` and as a result blocks the current thread to wait for the result. This is an example of [sync over async](AsyncGuidance.md#avoid-using-taskresult-and-taskwait).\n\n```C#\npublic class MyController : Controller\n{\n    [HttpGet(\"/pokemon\")]\n    public ActionResult<PokemonData> Get()\n    {\n        // This synchronously reads the entire http request body into memory.\n        // If the client is slowly uploading, we're doing sync over async because Kestrel does *NOT* support synchronous reads.\n        var json = new StreamReader(Request.Body).ReadToEnd();\n\n        return JsonConvert.DeserializeObject<PokemonData>(json);\n    }\n}\n```\n\n:white_check_mark: **GOOD** This example uses `StreamReader.ReadToEndAsync` and as a result, does not block the thread while reading.\n\n```C#\npublic class MyController : Controller\n{\n    [HttpGet(\"/pokemon\")]\n    public async Task<ActionResult<PokemonData>> Get()\n    {\n        // This asynchronously reads the entire http request body into memory.\n        var json = await new StreamReader(Request.Body).ReadToEndAsync();\n\n        return JsonConvert.DeserializeObject<PokemonData>(json);\n    }\n}\n```\n\n:bulb:**NOTE: If the request is large it could lead to out of memory problems which can result in a Denial Of Service. See [this](#avoid-reading-large-request-bodies-or-response-bodies-into-memory) for more information.**\n\n## Prefer using HttpRequest.ReadFormAsync() over HttpRequest.Form\n\nYou should always prefer `HttpRequest.ReadFormAsync()` over `HttpRequest.Form`. The only time it is safe to use `HttpRequest.Form` is the form has already been read by a call to `HttpRequest.ReadFormAsync()` and the cached form value is being read using `HttpRequest.Form`. \n\n❌ **BAD** This example uses HttpRequest.Form uses [sync over async](AsyncGuidance.md#avoid-using-taskresult-and-taskwait) under the covers and can lead to thread pool starvation (in some cases).\n\n```C#\npublic class MyController : Controller\n{\n    [HttpPost(\"/form-body\")]\n    public IActionResult Post()\n    {\n        var form = HttpRequest.Form;\n        \n        Process(form[\"id\"], form[\"name\"]);\n\n        return Accepted();\n    }\n}\n```\n\n:white_check_mark: **GOOD** This example uses `HttpRequest.ReadFormAsync()` to read the form body asynchronously.\n\n```C#\npublic class MyController : Controller\n{\n    [HttpPost(\"/form-body\")]\n    public async Task<IActionResult> Post()\n    {\n        var form = await HttpRequest.ReadFormAsync();\n        \n        Process(form[\"id\"], form[\"name\"]);\n\n        return Accepted();\n    }\n}\n```\n\n## Avoid reading large request bodies or response bodies into memory\n\nIn .NET any single object allocation greater than 85KB ends up in the large object heap ([LOH](https://blogs.msdn.microsoft.com/maoni/2006/04/19/large-object-heap/)). Large objects are expensive in 2 ways:\n\n- The allocation cost is high because the memory for a newly allocated large object has to be cleared (the CLR guarantees that memory for all newly allocated objects is cleared)\n- LOH is collected with the rest of the heap (it requires a \"full garbage collection\" or Gen2 collection)\n\nThis [blog post](https://adamsitnik.com/Array-Pool/#the-problem) describes the problem succinctly:\n\n> When a large object is allocated, it’s marked as Gen 2 object. Not Gen 0 as for small objects. The consequences are that if you run out of memory in LOH, GC cleans up whole managed heap, not only LOH. So it cleans up Gen 0, Gen 1 and Gen 2 including LOH. This is called full garbage collection and is the most time-consuming garbage collection. For many applications, it can be acceptable. But definitely not for high-performance web servers, where few big memory buffers are needed to handle an average web request (read from a socket, decompress, decode JSON & more).\n\nNaively storing a large request or response body into a single `byte[]` or `string` may result in quickly running out of space in the LOH and may cause performance issues for your application because of full GCs running. \n\n## Use buffered and synchronous reads and writes as an alternative to asynchronous reading and writing\n\nWhen using a serializer/de-serializer that only supports synchronous reads and writes (like JSON.NET) then prefer buffering the data into memory before passing data into the serializer/de-serializer.\n\n:bulb:**NOTE: If the request is large it could lead to out of memory problems which can result in a Denial Of Service. See [this](#avoid-reading-large-request-bodies-or-response-bodies-into-memory) for more information.**\n\n## Do not store IHttpContextAccessor.HttpContext in a field\n\nThe `IHttpContextAccessor.HttpContext` will return the `HttpContext` of the active request when accessed from the request thread. It should not be stored in a field or variable.\n\n❌ **BAD** This example stores the `HttpContext` in a field then attempts to use it later.\n\n```C#\npublic class MyType\n{\n    private readonly HttpContext _context;\n    public MyType(IHttpContextAccessor accessor)\n    {\n        _context = accessor.HttpContext;\n    }\n    \n    public void CheckAdmin()\n    {\n        if (!_context.User.IsInRole(\"admin\"))\n        {\n            throw new UnauthorizedAccessException(\"The current user isn't an admin\");\n        }\n    }\n}\n```\n\nThe above logic will likely capture a null or bogus `HttpContext` in the constructor for later use.\n\n:white_check_mark: **GOOD** This example stores the `IHttpContextAccessor` itself in a field and uses the `HttpContext` field at the correct time (checking for null).\n\n```C#\npublic class MyType\n{\n    private readonly IHttpContextAccessor _accessor;\n    public MyType(IHttpContextAccessor accessor)\n    {\n        _accessor = accessor;\n    }\n    \n    public void CheckAdmin()\n    {\n        var context = _accessor.HttpContext;\n        if (context != null && !context.User.IsInRole(\"admin\"))\n        {\n            throw new UnauthorizedAccessException(\"The current user isn't an admin\");\n        }\n    }\n}\n```\n\n## Do not access the HttpContext from multiple threads in parallel. It is not thread safe.\n\nThe `HttpContext` is *NOT* threadsafe. Accessing it from multiple threads in parallel can cause corruption resulting in undefined behavior (hangs, crashes, data corruption).\n\n❌ **BAD** This example makes 3 parallel requests and logs the incoming request path before and after the outgoing http request. This accesses the request path from multiple threads potentially in parallel.\n\n```C#\npublic class AsyncController : Controller\n{\n    [HttpGet(\"/search\")]\n    public async Task<SearchResults> Get(string query)\n    {\n        var query1 = SearchAsync(SearchEngine.Google, query);\n        var query2 = SearchAsync(SearchEngine.Bing, query);\n        var query3 = SearchAsync(SearchEngine.DuckDuckGo, query);\n\n        await Task.WhenAll(query1, query2, query3);\n        \n        var results1 = await query1;\n        var results2 = await query2;\n        var results3 = await query3;\n\n        return SearchResults.Combine(results1, results2, results3);\n    }\n\n    private async Task<SearchResults> SearchAsync(SearchEngine engine, string query)\n    {\n        var searchResults = SearchResults.Empty;\n        try\n        {\n            _logger.LogInformation(\"Starting search query from {path}.\", HttpContext.Request.Path);\n            searchResults = await _searchService.SearchAsync(engine, query);\n            _logger.LogInformation(\"Finishing search query from {path}.\", HttpContext.Request.Path);\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Failed query from {path}\", HttpContext.Request.Path);\n        }\n\n        return searchResults;\n    }\n}\n```\n\n:white_check_mark: **GOOD** This example copies all data from the incoming request before making the 3 parallel requests.\n\n```C#\npublic class AsyncController : Controller\n{\n    [HttpGet(\"/search\")]\n    public async Task<SearchResults> Get(string query)\n    {\n        string path = HttpContext.Request.Path;\n        var query1 = SearchAsync(SearchEngine.Google, query, path);\n        var query2 = SearchAsync(SearchEngine.Bing, query, path);\n        var query3 = SearchAsync(SearchEngine.DuckDuckGo, query, path);\n\n        await Task.WhenAll(query1, query2, query3);\n        \n        var results1 = await query1;\n        var results2 = await query2;\n        var results3 = await query3;\n\n        return SearchResults.Combine(results1, results2, results3);\n    }\n\n    private async Task<SearchResults> SearchAsync(SearchEngine engine, string query, string path)\n    {\n        var searchResults = SearchResults.Empty;\n        try\n        {\n            _logger.LogInformation(\"Starting search query from {path}.\", path);\n            searchResults = await _searchService.SearchAsync(engine, query);\n            _logger.LogInformation(\"Finishing search query from {path}.\", path);\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Failed query from {path}\", path);\n        }\n\n        return searchResults;\n    }\n}\n```\n\n## Do not use the HttpContext after the request is complete\n\nThe `HttpContext` is only valid as long as there is an active http request in flight. The entire ASP.NET Core pipeline is an asynchronous chain of delegates that executes every request. When the `Task` returned from this chain completes, the `HttpContext` is recycled. \n\n❌ **BAD** This example uses async void (which is a **ALWAYS** bad in ASP.NET Core applications) and as a result, accesses the `HttpResponse` after the http request is complete. It will crash the process as a result.\n\n```C#\npublic class AsyncVoidController : Controller\n{\n    [HttpGet(\"/async\")]\n    public async void Get()\n    {\n        await Task.Delay(1000);\n\n        // THIS will crash the process since we're writing after the response has completed on a background thread\n        await Response.WriteAsync(\"Hello World\");\n    }\n}\n```\n\n:white_check_mark: **GOOD** This example returns a `Task` to the framework so the http request doesn't complete until the entire action completes.\n\n```C#\npublic class AsyncController : Controller\n{\n    [HttpGet(\"/async\")]\n    public async Task Get()\n    {\n        await Task.Delay(1000);\n        \n        await Response.WriteAsync(\"Hello World\");\n    }\n}\n```\n\n## Do not capture the HttpContext in background threads\n\n❌ **BAD** This example shows a closure is capturing the `HttpContext` from the Controller property. This is bad because this work item could run\noutside of the request scope and as a result, could lead to reading a bogus `HttpContext`.\n\n```C#\n[HttpGet(\"/fire-and-forget-1\")]\npublic IActionResult FireAndForget1()\n{\n    _ = Task.Run(() =>\n    {\n        await Task.Delay(1000);\n\n        // This closure is capturing the context from the Controller property. This is bad because this work item could run\n        // outside of the http request leading to reading of bogus data.\n        var path = HttpContext.Request.Path;\n        Log(path);\n    });\n\n    return Accepted();\n}\n```\n\n\n:white_check_mark: **GOOD** This example copies the data required in the background task during the request explicitly and does not reference\nanything from the controller itself.\n\n```C#\n[HttpGet(\"/fire-and-forget-3\")]\npublic IActionResult FireAndForget3()\n{\n    string path = HttpContext.Request.Path;\n    _ = Task.Run(async () =>\n    {\n        await Task.Delay(1000);\n\n        // This captures just the path\n        Log(path);\n    });\n\n    return Accepted();\n}\n```\n\n## Do not capture services injected into the controllers on background threads\n\n❌ **BAD** This example shows a closure is capturing the `DbContext` from the Controller action parameter. This is bad because this work item could run\noutside of the request scope and the `PokemonDbContext` is scoped to the request. As a result, this will end up with an `ObjectDisposedException`.\n\n```C#\n[HttpGet(\"/fire-and-forget-1\")]\npublic IActionResult FireAndForget1([FromServices]PokemonDbContext context)\n{\n    _ = Task.Run(() =>\n    {\n        await Task.Delay(1000);\n\n        // This closure is capturing the context from the Controller action parameter. This is bad because this work item could run\n        // outside of the request scope and the PokemonDbContext is scoped to the request. As a result, this throws an ObjectDisposedException\n        context.Pokemon.Add(new Pokemon());\n        await context.SaveChangesAsync();\n    });\n\n    return Accepted();\n}\n```\n\n:white_check_mark: **GOOD** This example injects an `IServiceScopeFactory` and creates a new dependency injection scope in the background thread and does not reference\nanything from the controller itself.\n\n```C#\n[HttpGet(\"/fire-and-forget-3\")]\npublic IActionResult FireAndForget3([FromServices]IServiceScopeFactory serviceScopeFactory)\n{\n    // This version of fire and forget adds some exception handling. We're also no longer capturing the PokemonDbContext from the incoming request.\n    // Instead, we're injecting an IServiceScopeFactory (which is a singleton) in order to create a scope in the background work item.\n    _ = Task.Run(async () =>\n    {\n        await Task.Delay(1000);\n\n        // Create a scope for the lifetime of the background operation and resolve services from it\n        using (var scope = serviceScopeFactory.CreateScope())\n        {\n            // This will resolve a PokemonDbContext from the correct scope and the operation will succeed\n            var context = scope.ServiceProvider.GetRequiredService<PokemonDbContext>();\n\n            context.Pokemon.Add(new Pokemon());\n            await context.SaveChangesAsync();\n        }\n    });\n\n    return Accepted();\n}\n```\n\n## Avoid adding headers after the HttpResponse has started\n\nASP.NET Core does not buffer the http response body. This means that the very first time the response is written, the headers are sent along with that chunk of the body to the client. When this happens, it's no longer possible to change response headers.\n\n❌ **BAD** This logic tries to add response headers after the response has already started.\n\n```C#\napp.Use(async (next, context) =>\n{\n    await context.Response.WriteAsync(\"Hello \");\n    \n    await next();\n    \n    // This may fail if next() already wrote to the response\n    context.Response.Headers[\"test\"] = \"value\";    \n});\n```\n\n:white_check_mark: **GOOD** This example checks if the http response has started before writing to the body.\n\n```C#\napp.Use(async (next, context) =>\n{\n    await context.Response.WriteAsync(\"Hello \");\n    \n    await next();\n    \n    // Check if the response has already started before adding header and writing\n    if (!context.Response.HasStarted)\n    {\n        context.Response.Headers[\"test\"] = \"value\";\n    }\n});\n```\n\n:white_check_mark: **GOOD** This example uses `HttpResponse.OnStarting` to set the headers before the response headers are flushed to the client.\n\nIt allows you to register a callback that will be invoked just before response headers are written to the client. It gives you the ability to append or override headers just in time, without requiring knowledge of the next middleware in the pipeline.\n\n```C#\napp.Use(async (next, context) =>\n{\n    // Wire up the callback that will fire just before the response headers are sent to the client.\n    context.Response.OnStarting(() => \n    {       \n        context.Response.Headers[\"someheader\"] = \"somevalue\"; \n        return Task.CompletedTask;\n    });\n    \n    await next();\n});\n```\n"
        },
        {
          "name": "AsyncGuidance.md",
          "type": "blob",
          "size": 52.451171875,
          "content": "# Table of contents\n - [Asynchronous Programming](#asynchronous-programming)\n   - [Asynchrony is viral](#asynchrony-is-viral)\n   - [Async void](#async-void)\n   - [Prefer Task.FromResult over Task.Run for pre-computed or trivially computed data](#prefer-taskfromresult-over-taskrun-for-pre-computed-or-trivially-computed-data)\n   - [Avoid using Task.Run for long-running work that blocks the thread](#avoid-using-taskrun-for-long-running-work-that-blocks-the-thread)\n   - [Avoid using Task.Result and Task.Wait](#avoid-using-taskresult-and-taskwait)\n   - [Prefer await over ContinueWith](#prefer-await-over-continuewith)\n   - [Always create TaskCompletionSource\\<T\\> with TaskCreationOptions.RunContinuationsAsynchronously](#always-create-taskcompletionsourcet-with-taskcreationoptionsruncontinuationsasynchronously)\n   - [Always dispose CancellationTokenSource(s) used for timeouts](#always-dispose-cancellationtokensources-used-for-timeouts)\n   - [Always flow CancellationToken(s) to APIs that take a CancellationToken](#always-flow-cancellationtokens-to-apis-that-take-a-cancellationtoken)\n   - [Cancelling uncancellable operations](#cancelling-uncancellable-operations)\n   - [Always call FlushAsync on StreamWriter(s) or Stream(s) before calling Dispose](#always-call-flushasync-on-streamwriters-or-streams-before-calling-dispose)\n   - [Prefer async/await over directly returning Task](#prefer-asyncawait-over-directly-returning-task)\n   - [AsyncLocal\\<T\\>](#asynclocalt)\n   - [ConfigureAwait](#configureawait)\n   - [Scenarios](#scenarios)\n   - [Timer callbacks](#timer-callbacks)\n   - [Implicit async void delegates](#implicit-async-void-delegates)\n   - [ConcurrentDictionary.GetOrAdd](#concurrentdictionarygetoradd)\n   - [Constructors](#constructors)\n   - [WindowsIdentity.RunImpersonated](#windowsidentityrunimpersonated)\n \n# Asynchronous Programming\n\nAsynchronous programming has been around for several years on the .NET platform but has historically been very difficult to do well. Since the introduction of async/await\nin C# 5 asynchronous programming has become mainstream. Modern frameworks (like ASP.NET Core) are fully asynchronous and it's very hard to avoid the async keyword when writing\nweb services. As a result, there's been lots of confusion on the best practices for async and how to use it properly. This section will try to lay out some guidance with examples of bad and good patterns of how to write asynchronous code.\n\n## Asynchrony is viral \n\nOnce you go async, all of your callers **SHOULD** be async, since efforts to be async amount to nothing unless the entire call stack is async. In many cases, being partially asynchronous can be worse than being entirely synchronous. Therefore it is best to go all in, and make everything async at once.\n\n❌ **BAD** This example uses the `Task.Result` and as a result blocks the current thread to wait for the result. This is an example of [sync over async](#avoid-using-taskresult-and-taskwait).\n\n```C#\npublic int DoSomethingAsync()\n{\n    var result = CallDependencyAsync().Result;\n    return result + 1;\n}\n```\n\n:white_check_mark: **GOOD** This example uses the await keyword to get the result from `CallDependencyAsync`.\n\n```C#\npublic async Task<int> DoSomethingAsync()\n{\n    var result = await CallDependencyAsync();\n    return result + 1;\n}\n```\n\n## Async void\n\nThe use of async void in ASP.NET Core applications is **ALWAYS** bad. Avoid it, never do it. Typically, it's used when developers are trying to implement fire-and-forget patterns triggered by a controller action. Async void methods will crash the process if an exception is thrown. We'll look at more of the patterns that cause developers to do this in ASP.NET Core applications but here's a simple example:\n\n❌ **BAD** Async void methods can't be tracked and therefore unhandled exceptions can result in application crashes.\n\n```C#\npublic class MyController : Controller\n{\n    [HttpPost(\"/start\")]\n    public IActionResult Post()\n    {\n        BackgroundOperationAsync();\n        return Accepted();\n    }\n    \n    public async void BackgroundOperationAsync()\n    {\n        var result = await CallDependencyAsync();\n        DoSomething(result);\n    }\n}\n```\n\n:white_check_mark: **GOOD** `Task`-returning methods are better since unhandled exceptions trigger the [`TaskScheduler.UnobservedTaskException`](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler.unobservedtaskexception?view=netframework-4.7.2).\n\n```C#\npublic class MyController : Controller\n{\n    [HttpPost(\"/start\")]\n    public IActionResult Post()\n    {\n        Task.Run(BackgroundOperationAsync);\n        return Accepted();\n    }\n    \n    public async Task BackgroundOperationAsync()\n    {\n        var result = await CallDependencyAsync();\n        DoSomething(result);\n    }\n}\n```\n\n## Prefer `Task.FromResult` over `Task.Run` for pre-computed or trivially computed data\n\nFor pre-computed results, there's no need to call `Task.Run`, which will end up queuing a work item to the thread pool that will immediately complete with the pre-computed value. Instead, use `Task.FromResult`, to create a task wrapping already computed data.\n\n❌ **BAD** This example wastes a thread-pool thread to return a trivially computed value.\n\n```C#\npublic class MyLibrary\n{\n   public Task<int> AddAsync(int a, int b)\n   {\n       return Task.Run(() => a + b);\n   }\n}\n```\n\n:white_check_mark: **GOOD** This example uses `Task.FromResult` to return the trivially computed value. It does not use any extra threads as a result.\n\n```C#\npublic class MyLibrary\n{\n   public Task<int> AddAsync(int a, int b)\n   {\n       return Task.FromResult(a + b);\n   }\n}\n```\n\n:bulb:**NOTE: Using `Task.FromResult` will result in a `Task` allocation. Using `ValueTask<T>` can completely remove that allocation.**\n\n:white_check_mark: **GOOD** This example uses a `ValueTask<int>` to return the trivially computed value. It does not use any extra threads as a result. It also does not allocate an object on the managed heap.\n\n```C#\npublic class MyLibrary\n{\n   public ValueTask<int> AddAsync(int a, int b)\n   {\n       return new ValueTask<int>(a + b);\n   }\n}\n```\n\n## Avoid using Task.Run for long-running work that blocks the thread\n\nLong-running work in this context refers to a thread that's running for the lifetime of the application doing background work (like processing queue items, or sleeping and waking up to process some data). `Task.Run` will queue a work item to the thread pool. The assumption is that that work will finish quickly (or quickly enough to allow reusing that thread within some reasonable timeframe). Stealing a thread-pool thread for long-running work is bad since it takes that thread away from other work that could be done (timer callbacks, task continuations, etc). Instead, spawn a new thread manually to do long-running blocking work.\n\n:bulb: **NOTE: The thread pool grows if you block threads but it's bad practice to do so.**\n\n:bulb: **NOTE:`Task.Factory.StartNew` has an option `TaskCreationOptions.LongRunning` that under the covers creates a new thread and returns a Task that represents the execution. Using this properly requires several non-obvious parameters to be passed in to get the right behavior on all platforms.**\n\n:bulb: **NOTE: Don't use `TaskCreationOptions.LongRunning` with async code as this will create a new thread which will be destroyed after first `await`.**\n\n\n❌ **BAD** This example steals a thread-pool thread forever, to execute queued work on a `BlockingCollection<T>`.\n\n```C#\npublic class QueueProcessor\n{\n    private readonly BlockingCollection<Message> _messageQueue = new BlockingCollection<Message>();\n    \n    public void StartProcessing()\n    {\n        Task.Run(ProcessQueue);\n    }\n    \n    public void Enqueue(Message message)\n    {\n        _messageQueue.Add(message);\n    }\n    \n    private void ProcessQueue()\n    {\n        foreach (var item in _messageQueue.GetConsumingEnumerable())\n        {\n             ProcessItem(item);\n        }\n    }\n    \n    private void ProcessItem(Message message) { }\n}\n```\n\n:white_check_mark: **GOOD** This example uses a dedicated thread to process the message queue instead of a thread-pool thread.\n\n```C#\npublic class QueueProcessor\n{\n    private readonly BlockingCollection<Message> _messageQueue = new BlockingCollection<Message>();\n    \n    public void StartProcessing()\n    {\n        var thread = new Thread(ProcessQueue) \n        {\n            // This is important as it allows the process to exit while this thread is running\n            IsBackground = true\n        };\n        thread.Start();\n    }\n    \n    public void Enqueue(Message message)\n    {\n        _messageQueue.Add(message);\n    }\n    \n    private void ProcessQueue()\n    {\n        foreach (var item in _messageQueue.GetConsumingEnumerable())\n        {\n             ProcessItem(item);\n        }\n    }\n    \n    private void ProcessItem(Message message) { }\n}\n```\n\n:white_check_mark: **GOOD** This example utilizes a `TaskFactory` with `TaskCreationOptions.LongRunning` to process the message queue instead of creating a thread manually.\n\n```C#\npublic class QueueProcessor\n{\n    private readonly BlockingCollection<Message> _messageQueue = new BlockingCollection<Message>();\n\n    public Task StartProcessing() => Task.Factory.StartNew(ProcessQueue, TaskCreationOptions.LongRunning);\n\n    public void Enqueue(Message message)\n    {\n        _messageQueue.Add(message);\n    }\n\n    private void ProcessQueue()\n    {\n        foreach (var item in _messageQueue.GetConsumingEnumerable())\n        {\n            ProcessItem(item);\n        }\n    }\n\n    private void ProcessItem(Message message) { }\n}\n```\n\nUtilizing `TaskCreationOptions.LongRunning` introduces several advantages in comparison with manual thread creation:\n\n- It can be easily combined with `await` and TPL APIs, such as `Task.WhenAll`, amongst others.\n- It provides a superior exception-handling mechanism. For instance, in the event of an unhandled exception in a manually created thread, the application will crash (unless handled via `AppDomain.CurrentDomain.UnhandledException`), but with `.LongRunning`, it will be wrapped into a `Task` as an `AggregateException`.\n\n:bulb: **NOTE: The `TaskCreationOptions.LongRunning` option is essentially a recommendation to the `TaskScheduler`, which may interpret it differently in custom `TaskScheduler` applications or runtimes, or future updates to the .NET runtime libraries. If your primary goal is to spawn a new dedicated thread, then you might consider using the manual thread creation approach discussed previously.**\n\n\n## Avoid using `Task.Result` and `Task.Wait`\n\nThere are very few ways to use `Task.Result` and `Task.Wait` correctly so the general advice is to completely avoid using them in your code. \n\n### :warning: Sync over `async`\n\nUsing `Task.Result` or `Task.Wait` to block waiting on an asynchronous operation to complete is *MUCH* worse than calling a truly synchronous API to block. This phenomenon is dubbed \"Sync over async\". Here is what happens at a very high level:\n\n- An asynchronous operation is kicked off.\n- The calling thread is blocked waiting for that operation to complete.\n- When the asynchronous operation completes, it unblocks the code waiting on that operation. This takes place on another thread.\n\nThe result is that we need to use 2 threads instead of 1 to complete synchronous operations. This usually leads to [thread-pool starvation](https://blogs.msdn.microsoft.com/vancem/2018/10/16/diagnosing-net-core-threadpool-starvation-with-perfview-why-my-service-is-not-saturating-all-cores-or-seems-to-stall/) and results in service outages.\n\n### :warning: Deadlocks\n\nThe `SynchronizationContext` is an abstraction that gives application models a chance to control where asynchronous continuations run. ASP.NET (non-core), WPF, and Windows Forms each have an implementation that will result in a deadlock if Task.Wait or Task.Result is used on the main thread. This behavior has led to a bunch of \"clever\" code snippets that show the \"right\" way to block waiting for a Task. The truth is, there's no good way to block waiting for a Task to complete.\n\n:bulb:**NOTE: ASP.NET Core does not have a `SynchronizationContext` and is not prone to the deadlock problem.**\n\n❌ **BAD** The below are all examples that are, in one way or another, trying to avoid the deadlock situation but still succumb to \"sync over async\" problems.\n\n```C#\npublic string DoOperationBlocking()\n{\n    // Bad - Blocking the thread that enters.\n    // DoAsyncOperation will be scheduled on the default task scheduler, and remove the risk of deadlocking.\n    // In the case of an exception, this method will throw an AggregateException wrapping the original exception.\n    return Task.Run(() => DoAsyncOperation()).Result;\n}\n\npublic string DoOperationBlocking2()\n{\n    // Bad - Blocking the thread that enters.\n    // DoAsyncOperation will be scheduled on the default task scheduler, and remove the risk of deadlocking.\n    // In the case of an exception, this method will throw the exception without wrapping it in an AggregateException.\n    return Task.Run(() => DoAsyncOperation()).GetAwaiter().GetResult();\n}\n\npublic string DoOperationBlocking3()\n{\n    // Bad - Blocking the thread that enters, and blocking the threadpool thread inside.\n    // In the case of an exception, this method will throw an AggregateException containing another AggregateException, containing the original exception.\n    return Task.Run(() => DoAsyncOperation().Result).Result;\n}\n\npublic string DoOperationBlocking4()\n{\n    // Bad - Blocking the thread that enters, and blocking the threadpool thread inside.\n    return Task.Run(() => DoAsyncOperation().GetAwaiter().GetResult()).GetAwaiter().GetResult();\n}\n\npublic string DoOperationBlocking5()\n{\n    // Bad - Blocking the thread that enters.\n    // Bad - No effort has been made to prevent a present SynchonizationContext from becoming deadlocked.\n    // In the case of an exception, this method will throw an AggregateException wrapping the original exception.\n    return DoAsyncOperation().Result;\n}\n\npublic string DoOperationBlocking6()\n{\n    // Bad - Blocking the thread that enters.\n    // Bad - No effort has been made to prevent a present SynchonizationContext from becoming deadlocked.\n    return DoAsyncOperation().GetAwaiter().GetResult();\n}\n\npublic string DoOperationBlocking7()\n{\n    // Bad - Blocking the thread that enters.\n    // Bad - No effort has been made to prevent a present SynchonizationContext from becoming deadlocked.\n    var task = DoAsyncOperation();\n    task.Wait();\n    return task.GetAwaiter().GetResult();\n}\n```\n\n## Prefer `await` over `ContinueWith`\n\n`Task` existed before the async/await keywords were introduced and as such provided ways to execute continuations without relying on the language. Although these methods are still valid to use, we generally recommend that you prefer `async`/`await` to using `ContinueWith`. `ContinueWith` also does not capture the `SynchronizationContext` and as a result is actually semantically different to `async`/`await`.\n\n❌ **BAD** The example uses `ContinueWith` instead of `async`\n\n```C#\npublic Task<int> DoSomethingAsync()\n{\n    return CallDependencyAsync().ContinueWith(task =>\n    {\n        return task.Result + 1;\n    });\n}\n```\n\n:white_check_mark: **GOOD** This example uses the `await` keyword to get the result from `CallDependencyAsync`.\n\n```C#\npublic async Task<int> DoSomethingAsync()\n{\n    var result = await CallDependencyAsync();\n    return result + 1;\n}\n```\n\n## Always create `TaskCompletionSource<T>` with `TaskCreationOptions.RunContinuationsAsynchronously`\n\n`TaskCompletionSource<T>` is an important building block for libraries trying to adapt things that are not inherently awaitable to be awaitable via a `Task`. It is also commonly used to build higher-level operations (such as batching and other combinators) on top of existing asynchronous APIs. By default, `Task` continuations will run *inline* on the same thread that calls Try/Set(Result/Exception/Canceled). As a library author, this means having to understand that calling code can resume directly on your thread. This is extremely dangerous and can result in deadlocks, thread-pool starvation, corruption of state (if code runs unexpectedly) and more. \n\nAlways use `TaskCreationOptions.RunContinuationsAsynchronously` when creating the `TaskCompletionSource<T>`. This will dispatch the continuation onto the thread pool instead of executing it inline.\n\n❌ **BAD** This example does not use `TaskCreationOptions.RunContinuationsAsynchronously` when creating the `TaskCompletionSource<T>`.\n\n```C#\npublic Task<int> DoSomethingAsync()\n{\n    var tcs = new TaskCompletionSource<int>();\n    \n    var operation = new LegacyAsyncOperation();\n    operation.Completed += result =>\n    {\n        // Code awaiting on this task will resume on this thread!\n        tcs.SetResult(result);\n    };\n    \n    return tcs.Task;\n}\n```\n\n:white_check_mark: **GOOD** This example uses `TaskCreationOptions.RunContinuationsAsynchronously` when creating the `TaskCompletionSource<T>`.\n\n```C#\npublic Task<int> DoSomethingAsync()\n{\n    var tcs = new TaskCompletionSource<int>(TaskCreationOptions.RunContinuationsAsynchronously);\n    \n    var operation = new LegacyAsyncOperation();\n    operation.Completed += result =>\n    {\n        // Code awaiting on this task will resume on a different thread-pool thread\n        tcs.SetResult(result);\n    };\n    \n    return tcs.Task;\n}\n```\n\n:bulb:**NOTE: There are 2 enums that look alike. [`TaskCreationOptions.RunContinuationsAsynchronously`](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcreationoptions?view=netcore-2.0#System_Threading_Tasks_TaskCreationOptions_RunContinuationsAsynchronously) and [`TaskContinuationOptions.RunContinuationsAsynchronously`](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions?view=netcore-2.0). Be careful not to confuse their usage.** \n\n## Always dispose `CancellationTokenSource`(s) used for timeouts\n\n`CancellationTokenSource` objects that are used for timeouts (are created with timers or use the `CancelAfter` method), can put pressure on the timer queue if not disposed.\n\n❌ **BAD** This example does not dispose of the `CancellationTokenSource` and as a result, the timer stays in the queue for 10 seconds after each request is made.\n\n```C#\npublic async Task<Stream> HttpClientAsyncWithCancellationBad()\n{\n    var cts = new CancellationTokenSource(TimeSpan.FromSeconds(10));\n\n    using (var client = _httpClientFactory.CreateClient())\n    {\n        var response = await client.GetAsync(\"http://backend/api/1\", cts.Token);\n        return await response.Content.ReadAsStreamAsync();\n    }\n}\n```\n\n:white_check_mark: **GOOD** This example disposes of the `CancellationTokenSource` and properly removes the timer from the queue.\n\n```C#\npublic async Task<Stream> HttpClientAsyncWithCancellationGood()\n{\n    using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(10)))\n    {\n        using (var client = _httpClientFactory.CreateClient())\n        {\n            var response = await client.GetAsync(\"http://backend/api/1\", cts.Token);\n            return await response.Content.ReadAsStreamAsync();\n        }\n    }\n}\n```\n\n## Always flow `CancellationToken`(s) to APIs that take a `CancellationToken`\n\nCancellation is cooperative in .NET. Everything in the call chain has to be explicitly passed the `CancellationToken` in order for it to work well. This means you need to explicitly pass the token into other APIs that take a token if you want cancellation to be most effective.\n\n❌ **BAD** This example neglects to pass the `CancellationToken` to `Stream.ReadAsync` making the operation effectively not cancellable.\n\n```C#\npublic async Task<string> DoAsyncThing(CancellationToken cancellationToken = default)\n{\n   byte[] buffer = new byte[1024];\n   // We forgot to pass flow cancellationToken to ReadAsync\n   int read = await _stream.ReadAsync(buffer, 0, buffer.Length);\n   return Encoding.UTF8.GetString(buffer, 0, read);\n}\n```\n\n:white_check_mark: **GOOD** This example passes the `CancellationToken` into `Stream.ReadAsync`.\n\n```C#\npublic async Task<string> DoAsyncThing(CancellationToken cancellationToken = default)\n{\n   byte[] buffer = new byte[1024];\n   // This properly flows cancellationToken to ReadAsync\n   int read = await _stream.ReadAsync(buffer, 0, buffer.Length, cancellationToken);\n   return Encoding.UTF8.GetString(buffer, 0, read);\n}\n```\n\n## Cancelling uncancellable operations\n\nOne of the coding patterns that appears when doing asynchronous programming is canceling an uncancellable operation. This usually means creating another task that completes when a timeout or `CancellationToken` fires, and then using `Task.WhenAny` to detect a complete or cancelled operation.\n\n### Using CancellationTokens\n\n❌ **BAD** This example uses `Task.Delay(-1, token)` to create a `Task` that completes when the `CancellationToken` fires, but if it doesn't fire, there's no way to dispose of the `CancellationTokenRegistration` created inside of `Task.Delay`. This can lead to a memory leak.\n\n```C#\npublic static async Task<T> WithCancellation<T>(this Task<T> task, CancellationToken cancellationToken)\n{\n    // There's no way to dispose of the registration\n    var delayTask = Task.Delay(-1, cancellationToken);\n\n    var resultTask = await Task.WhenAny(task, delayTask);\n    if (resultTask == delayTask)\n    {\n        // Operation cancelled\n        throw new OperationCanceledException();\n    }\n\n    return await task;\n}\n```\n\n:white_check_mark: **GOOD** This example disposes of the `CancellationTokenRegistration` when one of the `Task(s)` is complete.\n\n```C#\npublic static async Task<T> WithCancellation<T>(this Task<T> task, CancellationToken cancellationToken)\n{\n    var tcs = new TaskCompletionSource<object>(TaskCreationOptions.RunContinuationsAsynchronously);\n\n    // This disposes the registration as soon as one of the tasks trigger\n    using (cancellationToken.Register(state =>\n    {\n        ((TaskCompletionSource<object>)state).TrySetResult(null);\n    },\n    tcs))\n    {\n        var resultTask = await Task.WhenAny(task, tcs.Task);\n        if (resultTask == tcs.Task)\n        {\n            // Operation cancelled\n            throw new OperationCanceledException(cancellationToken);\n        }\n\n        return await task;\n    }\n}\n```\n\n:white_check_mark: **GOOD** Prefer [`Task.WaitAsync`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.waitasync?view=net-6.0) on .NET >= 6;\n\n### Using a timeout\n\n❌ **BAD** This example does not cancel the timer even if the operation successfully completes. This means you could end up with lots of timers, which can flood the timer queue. \n\n```C#\npublic static async Task<T> TimeoutAfter<T>(this Task<T> task, TimeSpan timeout)\n{\n    var delayTask = Task.Delay(timeout);\n\n    var resultTask = await Task.WhenAny(task, delayTask);\n    if (resultTask == delayTask)\n    {\n        // Operation cancelled\n        throw new OperationCanceledException();\n    }\n\n    return await task;\n}\n```\n\n:white_check_mark: **GOOD** This example cancels the timer if the operation successfully completes.\n\n```C#\npublic static async Task<T> TimeoutAfter<T>(this Task<T> task, TimeSpan timeout)\n{\n    using (var cts = new CancellationTokenSource())\n    {\n        var delayTask = Task.Delay(timeout, cts.Token);\n\n        var resultTask = await Task.WhenAny(task, delayTask);\n        if (resultTask == delayTask)\n        {\n            // Operation cancelled\n            throw new OperationCanceledException();\n        }\n        else\n        {\n            // Cancel the timer task so that it does not fire\n            cts.Cancel();\n        }\n\n        return await task;\n    }\n}\n```\n\n:white_check_mark: **GOOD** Prefer [`Task.WaitAsync`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.waitasync?view=net-6.0) on .NET >= 6;\n\n## Always call `FlushAsync` on `StreamWriter`(s) or `Stream`(s) before calling `Dispose`\n\nWhen writing to a `Stream` or `StreamWriter`, even if the asynchronous overloads are used for writing, the underlying data might be buffered. When data is buffered, disposing the `Stream` or `StreamWriter` via the `Dispose` method will synchronously write/flush, which results in blocking the thread and could lead to thread-pool starvation. Either use the asynchronous `DisposeAsync` method (for example via `await using`) or call `FlushAsync` before calling `Dispose`.\n\n:bulb:**NOTE: This is only problematic if the underlying subsystem does IO.**\n\n❌ **BAD** This example ends up blocking the request by writing synchronously to the HTTP-response body.\n\n```C#\napp.Run(async context =>\n{\n    // The implicit Dispose call will synchronously write to the response body\n    using (var streamWriter = new StreamWriter(context.Response.Body))\n    {\n        await streamWriter.WriteAsync(\"Hello World\");\n    }\n});\n```\n\n:white_check_mark: **GOOD** This example asynchronously flushes any buffered data while disposing the `StreamWriter`.\n\n```C#\napp.Run(async context =>\n{\n    // The implicit AsyncDispose call will flush asynchronously\n    await using (var streamWriter = new StreamWriter(context.Response.Body))\n    {\n        await streamWriter.WriteAsync(\"Hello World\");\n    }\n});\n```\n\n:white_check_mark: **GOOD** This example asynchronously flushes any buffered data before disposing the `StreamWriter`.\n\n```C#\napp.Run(async context =>\n{\n    using (var streamWriter = new StreamWriter(context.Response.Body))\n    {\n        await streamWriter.WriteAsync(\"Hello World\");\n\n        // Force an asynchronous flush\n        await streamWriter.FlushAsync();\n    }\n});\n```\n\n## Prefer `async`/`await` over directly returning `Task`\n\nThere are benefits to using the `async`/`await` keyword instead of directly returning the `Task`:\n- Asynchronous and synchronous exceptions are normalized to always be asynchronous.\n- The code is easier to modify (consider adding a `using`, for example).\n- Diagnostics of asynchronous methods are easier (debugging hangs etc).\n- Exceptions thrown will be automatically wrapped in the returned `Task` instead of surprising the caller with an actual exception.\n- Async locals will not leak out of async methods. If you set an async local in a non-async method, it will \"leak\" out of that call.\n\n❌ **BAD** This example directly returns the `Task` to the caller.\n\n```C#\npublic Task<int> DoSomethingAsync()\n{\n    return CallDependencyAsync();\n}\n```\n\n:white_check_mark: **GOOD** This example uses async/await instead of directly returning the Task.\n\n```C#\npublic async Task<int> DoSomethingAsync()\n{\n    return await CallDependencyAsync();\n}\n```\n\n:bulb:**NOTE: There are performance considerations when using an async state machine over directly returning the `Task`. It's always faster to directly return the `Task` since it does less work but you end up changing the behavior and potentially losing some of the benefits of the async state machine.**\n\n## AsyncLocal\\<T\\>\n\nAsync locals are a way to store/retrieve ambient state throughout an application. This can be a *very* useful alternative to flowing explicit state everywhere, especially through call sites that you do not have much control over. While it is powerful, it is also dangerous if used incorrectly. Async locals are attached to the [execution context](https://docs.microsoft.com/en-us/dotnet/api/system.threading.executioncontext) which flows *everywhere implicitly*. Disabling execution context flow requires the use of advanced APIs (typically prefixed with the Unsafe name). As such, there's very little control over what code will attempt to access these values. \n\n### Creating an AsyncLocal\\<T\\>\n\nIf you can avoid async locals, do so by explicitly passing state around or using techniques like inversion of control.\n\nIf you cannot avoid it, it's best to make sure that anything put into an async local is:\n\n1. Not disposable\n2. Immutable/read-only/thread-safe\n\nLet's look at 2 examples:\n\n1. ❌ **BAD** A disposable object stored in an async local\n\n```C#\nusing (var thing = new DisposableThing())\n{\n    // Make the disposable object available ambiently\n    DisposableThing.Current = thing;\n\n    Dispatch();\n\n    // We're about to dispose the object so make sure nobody else captures this instance\n    DisposableThing.Current = null;\n}\n\nvoid Dispatch()\n{\n    // Task.Run will capture the current execution context (which means async locals are captured in the callback)\n    _ = Task.Run(async () =>\n    {\n        // Delay for a second then log\n        await Task.Delay(1000);\n\n        Log();\n    });\n}\n\nvoid Log()\n{\n    try\n    {\n        // Get the current value and make sure it's not null before reading the value\n        var thing = DisposableThing.Current;\n        if (thing is not null)\n        {\n            Console.WriteLine($\"Logging ambient value {thing.Value}\");\n        }\n    }\n    catch (Exception ex)\n    {\n        Console.WriteLine(ex);\n    }\n}\n\nConsole.ReadLine();\n\nclass DisposableThing : IDisposable\n{\n    private static readonly AsyncLocal<DisposableThing?> _current = new();\n\n    private bool _disposed;\n\n    public static DisposableThing? Current\n    {\n        get => _current.Value;\n        set\n        {\n            _current.Value = value;\n        }\n    }\n\n    public int Value\n    {\n        get\n        {\n            if (_disposed) throw new ObjectDisposedException(GetType().FullName);\n            return 1;\n        }\n    }\n\n    public void Dispose()\n    {\n        _disposed = true;\n    }\n}\n```\n\nThis above example will always result in an `ObjectDisposedException` being thrown. Even though the `Log` method defensively checks for null before logging the value, it has a reference to the disposed of `DisposableThing`. Setting the `AsyncLocal<DisposableThing>` to null does not affect the code inside of `Log`, this is because the execution context is copy on write. This means that all future reads `DisposableThing.Current` will be null, but it won't affect any of the previous reads.\n\nWhen we set `DisposableThing.Current = null;` we are making a new execution context, not mutating the one that was captured by `Task.Run`. To get a better understanding of this run the following code:\n\n```C#\nDisposableThing.Current = new DisposableThing();\n\nConsole.WriteLine(\"After setting thing \" + ExecutionContext.Capture().GetHashCode());\n\nDisposableThing.Current = null;\n\nConsole.WriteLine(\"After setting Current to null \" + ExecutionContext.Capture().GetHashCode());\n```\n\nThe hash code of the execution context is different each time we set a new value.\n\n⚠️ It might be tempting to update the logic in `DisposableThing.Current` to mutate the original execution context instead of setting the async local directly ([StrongBox\\<T\\>](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.strongbox-1) is a reference type that stores the underlying T in a mutable field):\n\n```C#\nclass DisposableThing : IDisposable\n{\n    private static readonly AsyncLocal<StrongBox<DisposableThing?>> _current = new();\n\n    private bool _disposed;\n\n    public static DisposableThing? Current\n    {\n        get => _current.Value?.Value;\n        set\n        {\n            var box = _current.Value;\n            if (box is not null)\n            {\n                // Mutate the value in any execution context that was copied\n                box.Value = null;\n            }\n\n            if (value is not null)\n            {\n                _current.Value = new StrongBox<DisposableThing?>(value);\n            }\n        }\n    }\n\n    public int Value\n    {\n        get\n        {\n            if (_disposed) throw new ObjectDisposedException(GetType().FullName);\n            return 1;\n        }\n    }\n\n    public void Dispose()\n    {\n        _disposed = true;\n    }\n}\n```\n\nThis will have the desired effect and will set the value to null in any execution context that references this async local value.\n\n```C#\nDisposableThing.Current = new DisposableThing();\n\nConsole.WriteLine(\"After setting thing \" + ExecutionContext.Capture().GetHashCode());\n\nDisposableThing.Current = null;\n\nConsole.WriteLine(\"After setting Current to null \" + ExecutionContext.Capture().GetHashCode());\n```\n\n⚠️ While this looks attractive, the reference to `DisposableThing.Current` might have still been captured before the value was set to null:\n\n```C#\nvoid Dispatch()\n{\n    // Task.Run will capture the current execution context (which means async locals are captured in the callback)\n    _ = Task.Run(async () =>\n    {\n        // Get the current reference\n        var current = DisposableThing.Current;\n\n        // Delay for a second then log\n        await Task.Delay(1000);\n\n        Log(current);\n    });\n}\n\nvoid Log(DisposableThing thing)\n{\n    try\n    {\n        Console.WriteLine($\"Logging ambient value {thing.Value}\");\n    }\n    catch (Exception ex)\n    {\n        Console.WriteLine(ex);\n    }\n}\n```\n\nThere's a race condition between the capture of the `DisposableThing`, the disposal of `DisposableThing` and setting `DisposableThing.Current` it to null. In the end, the code is unreliable and may fail at random. Don't store disposable objects in async locals.\n\n2. ❌ **BAD** A non-thread-safe object stored in an async local\n\n```C#\nAmbientValues.Current = new Dictionary<int, string>();\n\nParallel.For(0, 10, i =>\n{\n    AmbientValues.Current[i] = \"processing\";\n    LogCurrentValues();\n    AmbientValues.Current[i] = \"done\";\n});\n\n\nvoid LogCurrentValues()\n{\n    foreach (var pair in AmbientValues.Current)\n    {\n        Console.WriteLine(pair);\n    }\n}\n\nclass AmbientValues\n{\n    private static readonly AsyncLocal<Dictionary<int, string>> _current = new();\n\n    public static Dictionary<int, string> Current\n    {\n        get => _current.Value!;\n        set => _current.Value = value;\n    }\n}\n```\n\nThe above example stores a normal `Dictionary<int, string>` in an async local and does some parallel processing on it. While this may be obvious from the above example, async locals allow arbitrary code on arbitrary threads to access the execution context and thus any async locals associated with said context. As a result, it is important to assume that data can be accessed concurrently and should be made thread-safe as a result.\n\n```C#\nclass AmbientValues\n{\n    private static readonly AsyncLocal<ConcurrentDictionary<int, string>> _current = new();\n\n    public static ConcurrentDictionary<int, string> Current\n    {\n        get => _current.Value!;\n        set => _current.Value = value;\n    }\n}\n```\n\n:white_check_mark: **GOOD** The above uses a `ConcurrentDictionary<int, string>` which is thread safe.\n\n### Don't leak your AsyncLocal\\<T\\>\n\nAsync locals flow across awaits automatically and can be captured by any API that explicitly calls `ExecutionContext.Capture`. The latter can lead to memory leaks in certain situations.\n\n#### Common APIs that capture the ExecutionContext\n\nAPIs that run user callbacks usually capture the current execution context in order to preserve async locals between callback registration and execution. Here are examples of some APIs that do this:\n\n- `Timer`\n- `CancellationToken.Register`\n- `new FileSystemWatcher`\n- `SocketAsyncEventArgs`\n- `Task.Run`\n- `ThreadPool.QueueUserWorkItem`\n\n❌ **BAD** Here's an example of an execution context leak that causes memory pressure because of a lifetime mismatch between the API capturing the execution context, and the lifetime of the data stored in the async local.\n\n```C#\nusing System.Collections.Concurrent;\n\n// Singleton cache\nvar cache = new NumberCache(TimeSpan.FromHours(1));\n\nvar executionContext = ExecutionContext.Capture();\n\n// Simulate 10000 concurrent requests\nParallel.For(0, 10000, i =>\n{\n    // Restore the initial ExecutionContext per \"request\"\n    ExecutionContext.Restore(executionContext!);\n\n    ChunkyObject.Current = new ChunkyObject();\n\n    cache.Add(i);\n});\n\nConsole.WriteLine(\"Before GC: \" + BytesAsString(GC.GetGCMemoryInfo().HeapSizeBytes));\nConsole.ReadLine();\n\nGC.Collect();\nGC.WaitForPendingFinalizers();\n\nConsole.WriteLine(\"After GC: \" + BytesAsString(GC.GetGCMemoryInfo().HeapSizeBytes));\nConsole.ReadLine();\n\nstatic string BytesAsString(long bytes)\n{\n    string[] suffix = { \"B\", \"KB\", \"MB\", \"GB\", \"TB\" };\n    int i;\n    double doubleBytes = 0;\n\n    for (i = 0; bytes / 1024 > 0; i++, bytes /= 1024)\n    {\n        doubleBytes = bytes / 1024.0;\n    }\n\n    return string.Format(\"{0:0.00} {1}\", doubleBytes, suffix[i]);\n}\n\npublic class NumberCache\n{\n    private readonly ConcurrentDictionary<int, CancellationTokenSource> _cache = new ConcurrentDictionary<int, CancellationTokenSource>();\n    private TimeSpan _timeSpan;\n\n    public NumberCache(TimeSpan timeSpan)\n    {\n        _timeSpan = timeSpan;\n    }\n\n    public void Add(int key)\n    {\n        var cts = _cache.GetOrAdd(key, _ => new CancellationTokenSource());\n        // Delete entry on expiration\n        cts.Token.Register((_, _) => _cache.TryRemove(key, out _), null);\n\n        // Start count down\n        cts.CancelAfter(_timeSpan);\n    }\n}\n\nclass ChunkyObject\n{\n    private static readonly AsyncLocal<ChunkyObject?> _current = new();\n\n    // Stores lots of data (but it should be gen0)\n    private readonly string _data = new string('A', 1024 * 32);\n\n    public static ChunkyObject? Current\n    {\n        get => _current.Value;\n        set => _current.Value = value;\n    }\n\n    public string Data => _data;\n}\n```\n\nThe above example has a singleton `NumberCache` that stores numbers for an hour. We have a `ChunkyObject` which stores a 32K string in a field, and has an async local so that any code running may access the current `ChunkyObject`. This object should be collected when the `GC` runs, but instead, we're implicitly capturing the `ChunkyObject` in the `NumberCache` via `CancellationToken.Register`. \n\n**Instead of just caching the number and a `CancellationTokenSource`, we're implicitly capturing and storing all async locals attached to the current execution context for an hour!**\n\nTry running the sample locally. Running this on my machine reports numbers like this:\n\n```\nBefore GC: 654.65 MB\nAfter GC: 659.68 MB\n```\n\nHere's a look at the heap with those objects. You can see we have stored 10,000 ChunkyObjects, strings rooted by those chunky objects. The object graph looks like\nCancellationTokenSource -> ExecutionContext -> AsyncLocalValueMap -> ChunkObject -> string.\n\n<img width=\"758\" alt=\"image\" src=\"https://user-images.githubusercontent.com/95136/188351756-967f3d37-b302-49d3-ba04-595433c6949c.png\">\n\n\nWith one small tweak to this code, we can avoid the implicit execution context capture.\n\n:white_check_mark: **GOOD** Use `CancellationToken.UnsafeRegister` to avoid capturing the execution context and any async locals as part of the `NumberCache`:\n\n```C#\npublic class NumberCache\n{\n    private readonly ConcurrentDictionary<int, CancellationTokenSource> _cache = new ConcurrentDictionary<int, CancellationTokenSource>();\n    private TimeSpan _timeSpan;\n\n    public NumberCache(TimeSpan timeSpan)\n    {\n        _timeSpan = timeSpan;\n    }\n\n    public void Add(int key)\n    {\n        var cts = _cache.GetOrAdd(key, _ => new CancellationTokenSource());\n        // Delete entry on expiration\n        cts.Token.UnsafeRegister((_, _) => _cache.TryRemove(key, out _), null);\n\n        // Start count down\n        cts.CancelAfter(_timeSpan);\n    }\n}\n```\n\nThe GC numbers after this change:\n\n```\nBefore GC: 10.32 MB\nAfter GC: 5.10 MB\n```\n\nThe heap looks like we'd expect. There's no execution context capture, so the `ChunkyObject` isn't stored.\n\n<img width=\"752\" alt=\"image\" src=\"https://user-images.githubusercontent.com/95136/188352462-d7d627c6-e4e0-4487-b783-30880cc4916f.png\">\n\n\n:bulb: **NOTE: You have NO control over how APIs decide to store the execution context, but with this understanding, you should be able to minimize memory leaks by clearing the memory using the technique described in [Creating an AsyncLocal\\<T\\>](#creating-an-asynclocalt) section.**\n\n```C#\nusing System.Collections.Concurrent;\n\n// Singleton cache\nvar cache = new NumberCache(TimeSpan.FromHours(1));\n\nvar executionContext = ExecutionContext.Capture();\n\n// Simulate 10000 concurrent requests\nParallel.For(0, 10000, i =>\n{\n    // Restore the initial ExecutionContext per \"request\"\n    ExecutionContext.Restore(executionContext!);\n\n    ChunkyObject.Current = new ChunkyObject();\n\n    cache.Add(i);\n\n    // Null out the chunky object so the GC can release the memory\n    ChunkyObject.Current = default;\n});\n\nclass ChunkyObject\n{\n    private static readonly AsyncLocal<StrongBox<ChunkyObject?>> _current = new();\n\n    // Stores lots of data (but it should be gen0)\n    private readonly string _data = new string('A', 1024 * 32);\n\n    public static ChunkyObject? Current\n    {\n        get => _current.Value?.Value;\n        set\n        {\n            var box = _current.Value;\n            if (box is not null)\n            {\n                // Mutate the value in any execution context that was copied\n                box.Value = null;\n            }\n\n            if (value is not null)\n            {\n                _current.Value = new StrongBox<ChunkyObject?>(value);\n            }\n        }\n    }\n\n    public string Data => _data;\n}\n```\n\nThis technique reduces the heap memory **significantly**:\n\n```\nBefore GC: 7.91 MB\nAfter GC: 5.66 MB\n```\n\nThe execution context is storing `StrongBox<ChunkyObject>` with a null reference to the `ChunkyObject`. This is technically still a \"leak\" but we've reduced the impact significantly. Here's a look at the memory profile showing objects with 10,000 allocations (the number of requests we created). You can see the GC has collected `ChunkObject` instances but there are still 10,000 references to `StrongBox<ChunkyObject>`.\n\n<img width=\"760\" alt=\"image\" src=\"https://user-images.githubusercontent.com/95136/188351308-b174f843-0435-46db-8f31-b4d78c740947.png\">\n\n### Avoid setting AsyncLocal\\<T\\> values outside of async methods\n\nAsync methods have a special behavior for async locals that makes sure values do not propagate outside of the async method.\n\n❌ **BAD** Avoid setting async local values outside of async methods:\n\n```C#\nvar local = new AsyncLocal<int>();\nMethodA();\nConsole.WriteLine(local.Value);\n\nvoid MethodA()\n{\n    local.Value = 1;\n    MethodB();\n    Console.WriteLine(local.Value);\n}\n\nvoid MethodB()\n{\n    local.Value = 2;\n    Console.WriteLine(local.Value);\n}\n```\n\nThe above prints 2, 2, 2. The execution context mutations are being propagated outside of the method. This can lead to extremely confusing behavior and hard-to-track down bugs.\n\n:white_check_mark: **GOOD** Set async locals in async methods:\n\n```C#\nvar local = new AsyncLocal<int>();\nawait MethodA();\nConsole.WriteLine(local.Value);\n\nasync Task MethodA()\n{\n    local.Value = 1;\n    await MethodB();\n    Console.WriteLine(local.Value);\n}\n\nasync Task MethodB()\n{\n    local.Value = 2;\n    Console.WriteLine(local.Value);\n}\n```\n\nThe above will print 2, 1, 0. This is because the async method restores the original execution context on exit.\n\n## ConfigureAwait\n\nTBD\n\n# Scenarios\n\nThe above tries to distill general guidance but doesn't do justice to the kinds of real-world situations that cause code like this to be written in the first place (bad code). This section tries to take concrete examples from real applications and turn them into something simple to help you relate these problems to existing codebases.\n\n## `Timer` callbacks\n\n❌ **BAD** The `Timer` callback is `void`-returning and we have asynchronous work to execute. This example uses `async void` to accomplish it and as a result, can crash the process if an exception occurs.\n\n```C#\npublic class Pinger\n{\n    private readonly Timer _timer;\n    private readonly HttpClient _client;\n    \n    public Pinger(HttpClient client)\n    {\n        _client = client;\n        _timer = new Timer(Heartbeat, null, 1000, 1000);\n    }\n\n    public async void Heartbeat(object state)\n    {\n        await _client.GetAsync(\"http://mybackend/api/ping\");\n    }\n}\n```\n\n❌ **BAD** This attempts to block the `Timer` callback. This may result in thread-pool starvation and is an example of [sync over async](#warning-sync-over-async)\n\n```C#\npublic class Pinger\n{\n    private readonly Timer _timer;\n    private readonly HttpClient _client;\n    \n    public Pinger(HttpClient client)\n    {\n        _client = client;\n        _timer = new Timer(Heartbeat, null, 1000, 1000);\n    }\n\n    public void Heartbeat(object state)\n    {\n        _client.GetAsync(\"http://mybackend/api/ping\").GetAwaiter().GetResult();\n    }\n}\n```\n\n:white_check_mark: **GOOD** This example uses an `async Task`-based method and discards the `Task` in the `Timer` callback. If this method fails, it will not crash the process. Instead, it will fire the [`TaskScheduler.UnobservedTaskException`](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler.unobservedtaskexception) event.\n\n```C#\npublic class Pinger\n{\n    private readonly Timer _timer;\n    private readonly HttpClient _client;\n    \n    public Pinger(HttpClient client)\n    {\n        _client = client;\n        _timer = new Timer(Heartbeat, null, 1000, 1000);\n    }\n\n    public void Heartbeat(object state)\n    {\n        // Discard the result\n        _ = DoAsyncPing();\n    }\n\n    private async Task DoAsyncPing()\n    {\n        await _client.GetAsync(\"http://mybackend/api/ping\");\n    }\n}\n```\n\n:white_check_mark: **GOOD** This example uses the new [`PeriodicTimer`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.periodictimer) introduced in .NET 6:\n\n```C#\npublic class Pinger : IDisposable\n{\n    private readonly PeriodicTimer _timer;\n    private readonly HttpClient _client;\n\n    public Pinger(HttpClient client)\n    {\n        _client = client;\n        _timer = new PeriodicTimer(TimeSpan.FromSeconds(1));\n        _ = Task.Run(DoAsyncPings);\n    }\n\n    public void Dispose()\n    {\n        _timer.Dispose();\n    }\n\n    private async Task DoAsyncPings()\n    {\n        while (await _timer.WaitForNextTickAsync())\n        {\n            // TODO: Handle exceptions\n            await _client.GetAsync(\"http://mybackend/api/ping\");\n        }\n    }\n}\n```\n\n## Implicit `async void` delegates\n\nImagine a `BackgroundQueue` with a `FireAndForget` that takes a callback. This method will execute the callback at some time in the future.\n\n❌ **BAD** This will force callers to either block in the callback or use an `async void` delegate.\n\n```C#\npublic class BackgroundQueue\n{\n    public static void FireAndForget(Action action) { }\n}\n```\n\n❌ **BAD** This calling code is creating an `async void` method implicitly. The compiler fully supports this today.\n\n```C#\npublic class Program\n{\n    public void Main(string[] args)\n    {\n        var httpClient = new HttpClient();\n        BackgroundQueue.FireAndForget(async () =>\n        {\n            await httpClient.GetAsync(\"http://pinger/api/1\");\n        });\n        \n        Console.ReadLine();\n    }\n}\n```\n\n:white_check_mark: **GOOD** This BackgroundQueue implementation offers both sync and `async` callback overloads.\n\n```C#\npublic class BackgroundQueue\n{\n    public static void FireAndForget(Action action) { }\n    public static void FireAndForget(Func<Task> action) { }\n}\n```\n\n## `ConcurrentDictionary.GetOrAdd`\n\nIt's pretty common to cache the result of an asynchronous operation and `ConcurrentDictionary` is a good data structure for doing that. `GetOrAdd` is a convenience API for trying to get an item if it's already there or adding it if it isn't. The callback is synchronous so it's tempting to write code that uses `Task.Result` to produce the value of an asynchronous process but that can lead to thread-pool starvation.\n\n❌ **BAD** This may result in thread-pool starvation since we're blocking the request thread if the person data is not cached.\n\n```C#\npublic class PersonController : Controller\n{\n   private AppDbContext _db;\n   \n   // This cache needs expiration\n   private static ConcurrentDictionary<int, Person> _cache = new ConcurrentDictionary<int, Person>();\n   \n   public PersonController(AppDbContext db)\n   {\n      _db = db;\n   }\n   \n   public IActionResult Get(int id)\n   {\n       var person = _cache.GetOrAdd(id, (key) => _db.People.FindAsync(key).Result);\n       return Ok(person);\n   }\n}\n```\n\n:white_check_mark: **GOOD** This implementation won't result in thread-pool starvation since we're storing a task instead of the result itself.\n\n:warning: `ConcurrentDictionary.GetOrAdd`, when accessed concurrently, may run the value-constructing delegate multiple times. This can result in needlessly kicking off the same potentially expensive computation multiple times.\n\n```C#\npublic class PersonController : Controller\n{\n   private AppDbContext _db;\n   \n   // This cache needs expiration\n   private static ConcurrentDictionary<int, Task<Person>> _cache = new ConcurrentDictionary<int, Task<Person>>();\n   \n   public PersonController(AppDbContext db)\n   {\n      _db = db;\n   }\n   \n   public async Task<IActionResult> Get(int id)\n   {\n       var person = await _cache.GetOrAdd(id, (key) => _db.People.FindAsync(key));\n       return Ok(person);\n   }\n}\n```\n\n:white_check_mark: **GOOD** This implementation prevents the delegate from being executed multiple times, by using the `async` lazy pattern: even if construction of the AsyncLazy instance happens multiple times (\"cheap\" operation), the delegate will be called only once.\n\n```C#\npublic class PersonController : Controller\n{\n   private AppDbContext _db;\n   \n   // This cache needs expiration\n   private static ConcurrentDictionary<int, AsyncLazy<Person>> _cache = new ConcurrentDictionary<int, AsyncLazy<Person>>();\n   \n   public PersonController(AppDbContext db)\n   {\n      _db = db;\n   }\n   \n   public async Task<IActionResult> Get(int id)\n   {\n       var person = await _cache.GetOrAdd(id, (key) => new AsyncLazy<Person>(() => _db.People.FindAsync(key))).Value;\n       return Ok(person);\n   }\n   \n   private class AsyncLazy<T> : Lazy<Task<T>>\n   {\n      public AsyncLazy(Func<Task<T>> valueFactory) : base(valueFactory)\n      {\n      }\n   }\n}\n```\n\n## Constructors\n\nConstructors are synchronous. If you need to initialize some logic that may be asynchronous, there are a couple of patterns for dealing with this.\n\nHere's an example of using a client API that needs to connect asynchronously before use.\n\n```C#\npublic interface IRemoteConnectionFactory\n{\n   Task<IRemoteConnection> ConnectAsync();\n}\n\npublic interface IRemoteConnection\n{\n    Task PublishAsync(string channel, string message);\n    Task DisposeAsync();\n}\n```\n\n\n❌ **BAD** This example uses `Task.Result` to get the connection in the constructor. This could lead to thread-pool starvation and deadlocks.\n\n```C#\npublic class Service : IService\n{\n    private readonly IRemoteConnection _connection;\n    \n    public Service(IRemoteConnectionFactory connectionFactory)\n    {\n        _connection = connectionFactory.ConnectAsync().Result;\n    }\n}\n```\n\n:white_check_mark: **GOOD** This implementation uses a static factory pattern in order to allow asynchronous construction:\n\n```C#\npublic class Service : IService\n{\n    private readonly IRemoteConnection _connection;\n\n    private Service(IRemoteConnection connection)\n    {\n        _connection = connection;\n    }\n\n    public static async Task<Service> CreateAsync(IRemoteConnectionFactory connectionFactory)\n    {\n        return new Service(await connectionFactory.ConnectAsync());\n    }\n}\n```\n\n## WindowsIdentity.RunImpersonated\n\nThis API runs the specified action as the impersonated Windows identity. An [asynchronous version of the callback](https://docs.microsoft.com/en-us/dotnet/api/system.security.principal.windowsidentity.runimpersonatedasync) was introduced in .NET 5.0.\n\n❌ **BAD** This example tries to execute the query asynchronously, and then wait for it outside of the call to `RunImpersonated`. This will throw because the query might be executing outside of the impersonation context.\n\n```C#\npublic async Task<IEnumerable<Product>> GetDataImpersonatedAsync(SafeAccessTokenHandle safeAccessTokenHandle)\n{\n    Task<IEnumerable<Product>> products = null;\n    WindowsIdentity.RunImpersonated(\n        safeAccessTokenHandle,\n        context =>\n        {\n            products = _db.QueryAsync(\"SELECT Name from Products\");\n        });\n    return await products;\n}\n```\n\n❌ **BAD** This example uses `Task.Result` to execute the query synchronously (sync over async). This could lead to thread-pool starvation and deadlocks.\n\n```C#\npublic IEnumerable<Product> GetDataImpersonated(SafeAccessTokenHandle safeAccessTokenHandle)\n{\n    return WindowsIdentity.RunImpersonated(\n        safeAccessTokenHandle,\n        context => _db.QueryAsync(\"SELECT Name from Products\").Result);\n}\n```\n\n:white_check_mark: **GOOD** This example awaits the result of `RunImpersonated` (the delegate is `Func<Task<IEnumerable<Product>>>` in this case). It is the recommended practice in frameworks earlier than .NET 5.0.\n\n```C#\npublic async Task<IEnumerable<Product>> GetDataImpersonatedAsync(SafeAccessTokenHandle safeAccessTokenHandle)\n{\n    return await WindowsIdentity.RunImpersonated(\n        safeAccessTokenHandle, \n        context => _db.QueryAsync(\"SELECT Name from Products\"));\n}\n```\n\n:white_check_mark: **GOOD** This example uses the asynchronous `RunImpersonatedAsync` function and awaits its result. It is available in .NET 5.0 or newer.\n\n```C#\npublic async Task<IEnumerable<Product>> GetDataImpersonatedAsync(SafeAccessTokenHandle safeAccessTokenHandle)\n{\n    return await WindowsIdentity.RunImpersonatedAsync(\n        safeAccessTokenHandle, \n        context => _db.QueryAsync(\"SELECT Name from Products\"));\n}\n```\n"
        },
        {
          "name": "Gotchas.md",
          "type": "blob",
          "size": 0.0009765625,
          "content": "\n"
        },
        {
          "name": "Guidance.md",
          "type": "blob",
          "size": 0.4853515625,
          "content": "# Common Pitfalls writing scalable services in ASP.NET Core\n\nThis document serves as a guide for writing scalable services in ASP.NET Core. Some of the guidance is general purpose but will be explained through the lens of writing \nweb services. The examples shown here are based on experiences with customer applications and issues found on Github and Stack Overflow.\n\n- [General ASP.NET Core](AspNetCoreGuidance.md)\n- [Asynchronous Programming](AsyncGuidance.md)\n- [.NET API Gotchas](Gotchas.md)\n"
        },
        {
          "name": "HttpClientGuidance.md",
          "type": "blob",
          "size": 1.5576171875,
          "content": "# Table of contents\n - [Using HttpClient](#using-httpclient)\n - [Different platform implementations](#different-platform-implementations)\n - [A note about WebClient](#a-note-about-webclient)\n   \n## Using HttpClient\n\n[HttpClient](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=net-5.0) is the primary API for making outbound HTTP requests in .NET. \n\n## Different Platform Implementations\n\n`HttpClient` is a wrapper API around an `HttpMessageHandler`. The most inner `HttpMessageHandler` is the one that's responsible for making the HTTP request. There are several implementations on various .NET platforms. This document is focused on server applications and will focus on 2-3 main implementations:\n- HttpClientHandler/WebRequestHandler on .NET Framework\n- SocketHttpHandler on .NET Core/5\n- WinHttpHandler on .NET Framework or .NET Core/5 (runs on both but is Windows-specific)\n\n## A note about WebClient\n\nWebClient is considered a legacy .NET API at this point and has been completely superseded by HttpClient. New code should be written with HttpClient.\n\n❌ **BAD** This example uses the legacy WebClient to make a synchronous HTTP request.\n\n```C#\npublic string DoSomethingAsync()\n{\n    var client = new WebClient();\n    return client.DownloadString(\"http://www.google.com\");\n}\n```\n\n:white_check_mark: **GOOD** This example uses an HttpClient to asynchronously make an HTTP request.\n\n```C#\nstatic readonly HttpClient client = new HttpClient();\n\npublic async Task<string> DoSomethingAsync()\n{\n    return await client.GetStringAsync(\"http://www.google.com\");\n}\n```\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.9912109375,
          "content": "﻿# ASP.NET Core Diagnostic Scenarios\r\n \r\nThe goal of this repository is to show problematic application patterns for ASP.NET Core applications and a walk-through on how to solve those issues.\r\nIt shall serve as a collection of knowledge from real-life application issues our customers have encountered.\r\n\r\n## Common Pitfalls Writing scalable services in ASP.NET Core\r\n\r\nNext, you can find some guides for writing scalable services in ASP.NET Core. Some of the guidance is general purpose but will be explained through the lens of writing web services. \r\n\r\n- [General ASP.NET Core](AspNetCoreGuidance.md)\r\n- [Asynchronous Programming](AsyncGuidance.md)\r\n\r\n*NOTE:* The examples shown here are based on experiences with customer applications and issues found on Github and Stack Overflow.\r\n\r\n### All Thanks to Our Contributors:\r\n<a href=\"https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/graphs/contributors\">\r\n  <img src=\"https://contrib.rocks/image?repo=davidfowl/AspNetCoreDiagnosticScenarios\" />\r\n</a>\r\n"
        },
        {
          "name": "Scenarios",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}