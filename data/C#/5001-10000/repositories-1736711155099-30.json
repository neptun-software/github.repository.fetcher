{
  "metadata": {
    "timestamp": 1736711155099,
    "page": 30,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Humanizr/Humanizer",
      "stars": 8737,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 1.5439453125,
          "content": "* text=auto\n\n# Custom for Visual Studio\n*.cs     diff=csharp\n*.sln    merge=union\n*.csproj merge=union\n*.vbproj merge=union\n*.fsproj merge=union\n*.dbproj merge=union\n\n*.snk binary\n\n# Normalise endings to CRLF\n*.cs              eol=crlf\n*.xml             eol=crlf\n*.xaml            eol=crlf\n*.xsl             eol=crlf\n*.xsd             eol=crlf\n*.cshtml          eol=crlf\n*.css             eol=crlf\n*.js              eol=crlf\n*.txt             eol=crlf\n*.config          eol=crlf\n*.sql             eol=crlf\n*.sln             eol=crlf\n*.csproj          eol=crlf\n*.vbproj          eol=crlf\n*.fsproj          eol=crlf\n*.dbproj          eol=crlf\n*.nunit           eol=crlf\n*.html            eol=crlf\n*.md              eol=crlf\n*.proj            eol=crlf\n*.bat             eol=crlf\n*.cmd             eol=crlf\n*.nuspec          eol=crlf\n*.targets         eol=crlf\n*.conf            eol=crlf\n*.manifest        eol=crlf\n*.ps1             eol=crlf\n*.resx            eol=crlf\n*.asax            eol=crlf\n*.aspx            eol=crlf\n*.ncrunchproject  eol=crlf\n*.ncrunchsolution eol=crlf\n*.msbuild         eol=crlf\n*.template        eol=crlf\n*.settings        eol=crlf\n*.java            eol=crlf\n.gitattributes    eol=crlf\n.classpath        eol=crlf\n.project          eol=crlf\n\n# Standard to msysgit\n*.doc  diff=astextplain\n*.DOC  diff=astextplain\n*.docx diff=astextplain\n*.DOCX diff=astextplain\n*.dot  diff=astextplain\n*.DOT  diff=astextplain\n*.pdf  diff=astextplain\n*.PDF  diff=astextplain\n*.rtf  diff=astextplain\n*.RTF  diff=astextplain\n\n\n*.verified.txt text eol=lf working-tree-encoding=UTF-8"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.6279296875,
          "content": "## --------------------------------------------\n##  xUnit.net specific ignores\n\nTest*.html\nTest*.xml\n*.zip\n*.exe\n*.nuget.props\n*.nuget.targets\n\n## --------------------------------------------\n##  Adapted from https://raw.githubusercontent.com/github/gitignore/a4ec7f03ca5ae0bf09fad42c0fb7d1e8346bcf25/VisualStudio.gitignore\n\n# User-specific files\n*.suo\n*.user\n*.userosscache\n*.sln.docstates\n\n# User-specific files (MonoDevelop/Xamarin Studio)\n*.userprefs\n\n# Build results\n[Dd]ebug/\n[Dd]ebugPublic/\n[Rr]elease/\n[Rr]eleases/\nx64/\nx86/\n[Bb]in/\n[Oo]bj/\n\n# Visual Studio 2015 cache/options directory\n.vs/\n\n# Visual Studio test runner\n[Tt]est[Rr]esult*/\nIndex.dat\nStorage.dat\n\n# DNX\nproject.lock.json\n*.lock.json\nartifacts/\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n\n# ReSharper is a .NET coding add-in\n_ReSharper*/\n*.[Rr]e[Ss]harper\n*.DotSettings.user\n\n# JetBrains IDE\n.idea/\n\n# JustCode is a .NET coding add-in\n.JustCode\n\n# TeamCity is a build add-in\n_TeamCity*\n\n# DotCover is a Code Coverage Tool\n*.dotCover\n\n# NCrunch\n_NCrunch_*\n.*crunch*.local.xml\n\n# NuGet Packages\n*.nupkg\n**/packages/*\n#!**/packages/build/\n\n# Windows Store app package directory\nAppPackages/\n\n# Visual Studio cache files\n*.[Cc]ache\n!*.[Cc]ache/\n\n# Backup & report files from converting an old project file\n# to a newer Visual Studio version. Backup files are not needed,\n# because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\nUpgradeLog*.htm\n\n# local tools\n.store/\n\nsrc/Humanizer.Tests/ApiApprover/PublicApiApprovalTest.approve_public_api.received.txt\n\n.DS_Store\n/samples/Humanizer.MvcSample/Humanizer.MvcSample.sln\n/src/Humanizer/Properties/launchSettings.json\n\n\n*.received.*"
        },
        {
          "name": "NuSpecs",
          "type": "tree",
          "content": null
        },
        {
          "name": "azure-pipelines.yml",
          "type": "blob",
          "size": 4.3896484375,
          "content": "trigger:\n- main\n- rel/*\n\npr:\n- main\n- rel/*\n\nvariables:\n  BuildConfiguration: Release\n  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true\n  disable.coverage.autogenerate: 'true'\n\nstages:\n- stage: Build\n  variables:\n   - group: 'Report Generator License Key'\n\n  jobs:\n  - job: Build\n    pool:\n      vmImage: windows-latest\n\n    steps:\n    - task: UseDotNet@2\n      displayName: 'Use .NET Core SDK 8.x'\n      inputs:\n        version: 8.x\n\n    - task: DotNetCoreCLI@2\n      inputs:\n        command: custom\n        custom: tool\n        arguments: install --tool-path . nbgv\n      displayName: Install NBGV tool\n\n    - script: nbgv cloud\n      displayName: Set Version\n\n    - task: DotNetCoreCLI@2\n      inputs:\n        command: restore\n        projects: .\\src\\Humanizer.sln\n        arguments: -c $(BuildConfiguration)\n      displayName: Restore\n\n    - task: VSBuild@1\n      inputs:\n        solution: .\\src\\Humanizer.sln\n        configuration: $(BuildConfiguration)\n\n    - task: NuGetToolInstaller@1\n\n    - pwsh: |\n        mkdir $(Build.ArtifactStagingDirectory)\\Packages\n        $version = .\\nbgv get-version -f json | ConvertFrom-Json\n        $nuspecs = gci .\\NuSpecs\\*.nuspec \n        foreach ($item in $nuspecs) {\n          nuget pack $($item.FullName) `\n                    -outputdirectory $(Build.ArtifactStagingDirectory)\\Packages `\n                    -basepath $(System.DefaultWorkingDirectory)\\src\\ `\n                    -NoPackageAnalysis `\n                    -Properties \"version=$($version.NuGetPackageVersion);RepositoryType=git;RepositoryCommit=$($version.GitCommitId);RepositoryUrl=https://github.com/Humanizr/Humanizer\" \n        }\n      displayName: Create packages\n\n    - task: DotNetCoreCLI@2\n      inputs:\n        command: test\n        projects: .\\src\\Humanizer.Tests\\Humanizer.Tests.csproj\n        arguments: -c $(BuildConfiguration) --no-build --collect:\"XPlat code coverage\" -s $(System.DefaultWorkingDirectory)/src/CodeCoverage.runsettings -- RunConfiguration.DisableAppDomain=true\n      displayName: Run Tests\n\n    # Generate code coverage report\n    # https://danielpalme.github.io/ReportGenerator/\n    - task: reportgenerator@5\n      displayName: Generate Code Coverage Report\n      inputs:\n        reports: '$(Agent.TempDirectory)/**/coverage.cobertura.xml'\n        targetdir: $(Build.ArtifactStagingDirectory)/coverageReports/ \n        reporttypes: HtmlInline_AzurePipelines;Cobertura;Badges\n        license: '$(ReportGeneratorLicenseKey)'\n    \n    # Publish Code Coverage results\n    - task: PublishCodeCoverageResults@1\n      displayName: 'Publish Code Coverage Results'\n      inputs:\n        codeCoverageTool: cobertura\n        summaryFileLocation: $(Build.ArtifactStagingDirectory)/coverageReports/Cobertura.xml\n        reportDirectory: $(Build.ArtifactStagingDirectory)/coverageReports/        \n      \n    - publish: $(Build.ArtifactStagingDirectory)\\Packages\n      displayName: Publish build packages\n      artifact: BuildPackages\n  \n\n- stage: CodeSign\n  dependsOn: Build\n  condition: and(succeeded('Build'), not(eq(variables['build.reason'], 'PullRequest')))\n  jobs:\n  - job: CodeSign\n    displayName: Code Signing\n    pool:\n      vmImage: windows-latest\n    variables:\n    - group: SignCLI Creds\n\n    steps:\n\n    # Retreive unsigned artifacts \n    - download: current\n      artifact: BuildPackages\n      displayName: Download build artifacts\n\n    - task: UseDotNet@2\n      displayName: 'Use .NET SDK 8.x'\n      inputs:\n        version: 8.x\n\n    # Install the code signing tool\n    - task: DotNetCoreCLI@2\n      inputs:\n        command: custom\n        custom: tool\n        arguments: install --tool-path . --prerelease sign \n      displayName: Install SignTool tool\n\n    # Run the signing command\n    - pwsh: |\n        .\\sign code azure-key-vault `\n        \"**/*.nupkg\" `\n        --base-directory \"$(Pipeline.Workspace)\\BuildPackages\" `\n        --publisher-name \"Humanizer\" `\n        --description \"Humanizer\" `\n        --description-url \"https://github.com/Humanizr/Humanizer\" `\n        --azure-key-vault-tenant-id \"$(SignTenantId)\" `\n        --azure-key-vault-client-id \"$(SignClientId)\" `\n        --azure-key-vault-client-secret '$(SignClientSecret)' `\n        --azure-key-vault-certificate \"$(SignKeyVaultCertificate)\" `\n        --azure-key-vault-url \"$(SignKeyVaultUrl)\"\n      displayName: Sign packages\n    \n    # Publish the signed packages\n    - publish: $(Pipeline.Workspace)/BuildPackages\n      displayName: Publish Signed Packages\n      artifact: SignedPackages"
        },
        {
          "name": "license.txt",
          "type": "blob",
          "size": 1.5283203125,
          "content": "The MIT License (MIT)\n\nCopyright (c) .NET Foundation and Contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n==============================================================================\n\nInflector (https://github.com/srkirkland/Inflector)\nThe MIT License (MIT)\nCopyright (c) 2013 Scott Kirkland\n\n==============================================================================\n\nByteSize (https://github.com/omar/ByteSize)\nThe MIT License (MIT)\nCopyright (c) 2013-2014 Omar Khudeira (http://omar.io)\n\n==============================================================================\n"
        },
        {
          "name": "logo.png",
          "type": "blob",
          "size": 6.7587890625,
          "content": null
        },
        {
          "name": "readme.md",
          "type": "blob",
          "size": 50.0048828125,
          "content": "﻿# <img width=\"30px\" src=\"logo.png\" /> Humanizer\n\nHumanizer meets all your .NET needs for manipulating and displaying strings, enums, dates, times, timespans, numbers and quantities.\n\n\n## Install</a>\n\nYou can install Humanizer as [a nuget package](https://nuget.org/packages/Humanizer):\n\n**English only**: `Humanizer.Core`\n\nAll languages: `Humanizer`\n\n\n### Supported frameworks\n\nThe following frameworks are supported: net4.8, net6, net7, and net8\n\nNote: The nuget also targets netstandard2. This is to enable scenario where netstandard2 is required. For example Roslyn Analyzers or MSBuild tasks. Other frameworks (other than listed above) that can consume netstandard2 (example net4.6.1 through to net 4.7.2) are not supported. For example net4.6.1 through to net4.7.2 are not supported.\n\nAlso Humanizer symbols are source indexed with [SourceLink](https://github.com/dotnet/sourcelink) and are included in the package so you can step through Humanizer code while debugging your code.\n\n\n### Specify Languages (Optional)\n\nYou choose which packages based on what NuGet package(s) you install. By default, the main `Humanizer` 2.0 package installs all supported languages exactly like it does in 1.x. If you're not sure, then just use the main `Humanizer` package.\n\nHere are the options:\n\n  - **All languages**: use the main `Humanizer` package. This pulls in `Humanizer.Core` and all language packages.\n  - **English**: use the `Humanizer.Core` package. Only the English language resources will be available\n  - **Specific languages**: Use the language specific packages you'd like. For example for French, use `Humanizer.Core.fr`. You can include multiple languages by installing however many language packages you want.\n\nThe detailed explanation for how this works is in the comments [here](https://github.com/Humanizr/Humanizer/issues/59#issuecomment-152546079).\n\n\n## Features\n\n\n### Humanize String\n\n`Humanize` string extensions allow you turn an otherwise computerized string into a more readable human-friendly one.\nThe foundation of this was set in the [BDDfy framework](https://github.com/TestStack/TestStack.BDDfy) where class names, method names and properties are turned into human readable sentences.\n\n```C#\n\"PascalCaseInputStringIsTurnedIntoSentence\".Humanize() => \"Pascal case input string is turned into sentence\"\n\n\"Underscored_input_string_is_turned_into_sentence\".Humanize() => \"Underscored input string is turned into sentence\"\n\n\"Underscored_input_String_is_turned_INTO_sentence\".Humanize() => \"Underscored input String is turned INTO sentence\"\n```\n\nNote that a string that contains only upper case letters, and consists only of one word, is always treated as an acronym (regardless of its length). To guarantee that any arbitrary string will always be humanized you must use a transform (see `Transform` method below):\n\n```C#\n// acronyms are left intact\n\"HTML\".Humanize() => \"HTML\"\n\n// any unbroken upper case string is treated as an acronym\n\"HUMANIZER\".Humanize() => \"HUMANIZER\"\n\"HUMANIZER\".Transform(To.LowerCase, To.TitleCase) => \"Humanizer\"\n```\n\nYou may also specify the desired letter casing:\n\n```C#\n\"CanReturnTitleCase\".Humanize(LetterCasing.Title) => \"Can Return Title Case\"\n\n\"Can_return_title_Case\".Humanize(LetterCasing.Title) => \"Can Return Title Case\"\n\n\"CanReturnLowerCase\".Humanize(LetterCasing.LowerCase) => \"can return lower case\"\n\n\"CanHumanizeIntoUpperCase\".Humanize(LetterCasing.AllCaps) => \"CAN HUMANIZE INTO UPPER CASE\"\n```\n\n > The `LetterCasing` API and the methods accepting it are legacy from V0.2 era and will be deprecated in the future. Instead of that, you can use `Transform` method explained below.\n\n\n### Dehumanize String\n\nMuch like you can humanize a computer friendly into human friendly string you can dehumanize a human friendly string into a computer friendly one:\n\n```C#\n\"Pascal case input string is turned into sentence\".Dehumanize() => \"PascalCaseInputStringIsTurnedIntoSentence\"\n```\n\n\n### Transform String\n\nThere is a `Transform` method that supersedes `LetterCasing`, `ApplyCase` and `Humanize` overloads that accept `LetterCasing`.\nTransform method signature is as follows:\n\n```C#\nstring Transform(this string input, params IStringTransformer[] transformers)\n```\n\nAnd there are some out of the box implementations of `IStringTransformer` for letter casing:\n\n```C#\n\"Sentence casing\".Transform(To.LowerCase) => \"sentence casing\"\n\"Sentence casing\".Transform(To.SentenceCase) => \"Sentence casing\"\n\"Sentence casing\".Transform(To.TitleCase) => \"Sentence Casing\"\n\"Sentence casing\".Transform(To.UpperCase) => \"SENTENCE CASING\"\n```\n\n`LowerCase` is a public static property on `To` class that returns an instance of private `ToLowerCase` class that implements `IStringTransformer` and knows how to turn a string into lower case.\n\nThe benefit of using `Transform` and `IStringTransformer` over `ApplyCase` and `LetterCasing` is that `LetterCasing` is an enum and you're limited to use what's in the framework\nwhile `IStringTransformer` is an interface you can implement in your codebase once and use it with `Transform` method allowing for easy extension.\n\n\n### Truncate String\n\nYou can truncate a `string` using the `Truncate` method:\n\n```c#\n\"Long text to truncate\".Truncate(10) => \"Long text…\"\n```\n\nBy default the `'…'` character is used to truncate strings. The advantage of using the `'…'` character instead of `\"...\"` is that the former only takes a single character and thus allows more text to be shown before truncation. If you want, you can also provide your own truncation string:\n\n```c#\n\"Long text to truncate\".Truncate(10, \"---\") => \"Long te---\"\n```\n\nThe default truncation strategy, `Truncator.FixedLength`, is to truncate the input string to a specific length, including the truncation string length.\nThere are two more truncator strategies available: one for a fixed number of (alpha-numerical) characters and one for a fixed number of words.\nTo use a specific truncator when truncating, the two `Truncate` methods shown in the previous examples all have an overload that allow you to specify the `ITruncator` instance to use for the truncation.\nHere are examples on how to use the three provided truncators:\n\n```c#\n\"Long text to truncate\".Truncate(10, Truncator.FixedLength) => \"Long text…\"\n\"Long text to truncate\".Truncate(10, \"---\", Truncator.FixedLength) => \"Long te---\"\n\n\"Long text to truncate\".Truncate(6, Truncator.FixedNumberOfCharacters) => \"Long t…\"\n\"Long text to truncate\".Truncate(6, \"---\", Truncator.FixedNumberOfCharacters) => \"Lon---\"\n\n\"Long text to truncate\".Truncate(2, Truncator.FixedNumberOfWords) => \"Long text…\"\n\"Long text to truncate\".Truncate(2, \"---\", Truncator.FixedNumberOfWords) => \"Long text---\"\n```\n\nNote that you can also use create your own truncator by implementing the `ITruncator` interface.\n\nThere is also an option to choose whether to truncate the string from the beginning (`TruncateFrom.Left`) or the end (`TruncateFrom.Right`).\nDefault is the right as shown in the examples above. The examples below show how to truncate from the beginning of the string:\n\n```c#\n\"Long text to truncate\".Truncate(10, Truncator.FixedLength, TruncateFrom.Left) => \"… truncate\"\n\"Long text to truncate\".Truncate(10, \"---\", Truncator.FixedLength, TruncateFrom.Left) => \"---runcate\"\n\n\"Long text to truncate\".Truncate(10, Truncator.FixedNumberOfCharacters, TruncateFrom.Left) => \"…o truncate\"\n\"Long text to truncate\".Truncate(16, \"---\", Truncator.FixedNumberOfCharacters, TruncateFrom.Left) => \"---ext to truncate\"\n\n\"Long text to truncate\".Truncate(2, Truncator.FixedNumberOfWords, TruncateFrom.Left) => \"…to truncate\"\n\"Long text to truncate\".Truncate(2, \"---\", Truncator.FixedNumberOfWords, TruncateFrom.Left) => \"---to truncate\"\n```\n\n\n### Humanize Enums\n\nCalling `ToString` directly on enum members usually results in less than ideal output for users. The solution to this is usually to use `DescriptionAttribute` data annotation and then read that at runtime to get a more friendly output. That is a great solution; but more often than not we only need to put some space between words of an enum member - which is what `String.Humanize()` does well. For an enum like:\n\n```C#\npublic enum EnumUnderTest\n{\n    [Description(\"Custom description\")]\n    MemberWithDescriptionAttribute,\n    MemberWithoutDescriptionAttribute,\n    ALLCAPITALS\n}\n```\n\nYou will get:\n\n```C#\n// DescriptionAttribute is honored\nEnumUnderTest.MemberWithDescriptionAttribute.Humanize() => \"Custom description\"\n\n// In the absence of Description attribute string.Humanizer kicks in\nEnumUnderTest.MemberWithoutDescriptionAttribute.Humanize() => \"Member without description attribute\"\n\n// Of course you can still apply letter casing\nEnumUnderTest.MemberWithoutDescriptionAttribute.Humanize().Transform(To.TitleCase) => \"Member Without Description Attribute\"\n```\n\nYou are not limited to `DescriptionAttribute` for custom description. Any attribute applied on enum members with a `string Description` property counts.\nThis is to help with platforms with missing `DescriptionAttribute` and also for allowing subclasses of the `DescriptionAttribute`.\n\nYou can even configure the name of the property of attibute to use as description.\n\n`Configurator.EnumDescriptionPropertyLocator = p => p.Name == \"Info\"`\n\nIf you need to provide localised descriptions you can use `DisplayAttribute` data annotation instead.\n\n```C#\npublic enum EnumUnderTest\n{\n    [Display(Description = \"EnumUnderTest_Member\", ResourceType = typeof(Project.Resources))]\n    Member\n}\n```\n\nYou will get:\n\n```C#\nEnumUnderTest.Member.Humanize() => \"content\" // from Project.Resources found under \"EnumUnderTest_Member\" resource key\n```\n\nHopefully this will help avoid littering enums with unnecessary attributes!\n\n\n### Dehumanize Enums\n\nDehumanizes a string into the Enum it was originally Humanized from! The API looks like:\n\n```C#\npublic static TTargetEnum DehumanizeTo<TTargetEnum>(this string input)\n```\n\nAnd the usage is:\n\n```C#\n\"Member without description attribute\".DehumanizeTo<EnumUnderTest>() => EnumUnderTest.MemberWithoutDescriptionAttribute\n```\n\nAnd just like the Humanize API it honors the `Description` attribute. You don't have to provide the casing you provided during humanization: it figures it out.\n\nThere is also a non-generic counterpart for when the original Enum is not known at compile time:\n\n```C#\npublic static Enum DehumanizeTo(this string input, Type targetEnum, NoMatch onNoMatch = NoMatch.ThrowsException)\n```\n\nwhich can be used like:\n\n```C#\n\"Member without description attribute\".DehumanizeTo(typeof(EnumUnderTest)) => EnumUnderTest.MemberWithoutDescriptionAttribute\n```\n\nBy default both methods throw a `NoMatchFoundException` when they cannot match the provided input against the target enum.\nIn the non-generic method you can also ask the method to return null by setting the second optional parameter to `NoMatch.ReturnsNull`.\n\n\n### Humanize DateTime\n\nYou can `Humanize` an instance of `DateTime` or `DateTimeOffset` and get back a string telling how far back or forward in time that is:\n\n```C#\nDateTime.UtcNow.AddHours(-30).Humanize() => \"yesterday\"\nDateTime.UtcNow.AddHours(-2).Humanize() => \"2 hours ago\"\n\nDateTime.UtcNow.AddHours(30).Humanize() => \"tomorrow\"\nDateTime.UtcNow.AddHours(2).Humanize() => \"2 hours from now\"\n\nDateTimeOffset.UtcNow.AddHours(1).Humanize() => \"an hour from now\"\n```\n\nHumanizer supports both local and UTC dates as well as dates with offset (`DateTimeOffset`). You could also provide the date you want the input date to be compared against. If null, it will use the current date as comparison base.\nAlso, culture to use can be specified explicitly. If it is not, current thread's current UI culture is used.\nHere is the API signature:\n\n```C#\npublic static string Humanize(this DateTime input, bool utcDate = true, DateTime? dateToCompareAgainst = null, CultureInfo culture = null)\npublic static string Humanize(this DateTimeOffset input, DateTimeOffset? dateToCompareAgainst = null, CultureInfo culture = null)\n```\n\nMany localizations are available for this method. Here is a few examples:\n\n```C#\n// In ar culture\nDateTime.UtcNow.AddDays(-1).Humanize() => \"أمس\"\nDateTime.UtcNow.AddDays(-2).Humanize() => \"منذ يومين\"\nDateTime.UtcNow.AddDays(-3).Humanize() => \"منذ 3 أيام\"\nDateTime.UtcNow.AddDays(-11).Humanize() => \"منذ 11 يوم\"\n\n// In ru-RU culture\nDateTime.UtcNow.AddMinutes(-1).Humanize() => \"минуту назад\"\nDateTime.UtcNow.AddMinutes(-2).Humanize() => \"2 минуты назад\"\nDateTime.UtcNow.AddMinutes(-10).Humanize() => \"10 минут назад\"\nDateTime.UtcNow.AddMinutes(-21).Humanize() => \"21 минуту назад\"\nDateTime.UtcNow.AddMinutes(-22).Humanize() => \"22 минуты назад\"\nDateTime.UtcNow.AddMinutes(-40).Humanize() => \"40 минут назад\"\n```\n\nThere are two strategies for `DateTime.Humanize`: the default one as seen above and a precision based one.\nTo use the precision based strategy you need to configure it:\n\n```C#\nConfigurator.DateTimeHumanizeStrategy = new PrecisionDateTimeHumanizeStrategy(precision: .75);\nConfigurator.DateTimeOffsetHumanizeStrategy = new PrecisionDateTimeOffsetHumanizeStrategy(precision: .75); // configure when humanizing DateTimeOffset\n```\n\nThe default precision is set to .75 but you can pass your desired precision too. With precision set to 0.75:\n\n```C#\n44 seconds => 44 seconds ago/from now\n45 seconds => one minute ago/from now\n104 seconds => one minute ago/from now\n105 seconds => two minutes ago/from now\n\n25 days => a month ago/from now\n```\n\n**No dehumanization for dates as `Humanize` is a lossy transformation and the human friendly date is not reversible**\n\n\n### Humanize TimeSpan\n\nYou can call `Humanize` on a `TimeSpan` to a get human friendly representation for it:\n\n```C#\nTimeSpan.FromMilliseconds(1).Humanize() => \"1 millisecond\"\nTimeSpan.FromMilliseconds(2).Humanize() => \"2 milliseconds\"\nTimeSpan.FromDays(1).Humanize() => \"1 day\"\nTimeSpan.FromDays(16).Humanize() => \"2 weeks\"\n```\n\nThere is an optional `precision` parameter for `TimeSpan.Humanize` which allows you to specify the precision of the returned value.\nThe default value of `precision` is 1 which means only the largest time unit is returned like you saw in `TimeSpan.FromDays(16).Humanize()`.\nHere is a few examples of specifying precision:\n\n```C#\nTimeSpan.FromDays(1).Humanize(precision:2) => \"1 day\" // no difference when there is only one unit in the provided TimeSpan\nTimeSpan.FromDays(16).Humanize(2) => \"2 weeks, 2 days\"\n\n// the same TimeSpan value with different precision returns different results\nTimeSpan.FromMilliseconds(1299630020).Humanize() => \"2 weeks\"\nTimeSpan.FromMilliseconds(1299630020).Humanize(3) => \"2 weeks, 1 day, 1 hour\"\nTimeSpan.FromMilliseconds(1299630020).Humanize(4) => \"2 weeks, 1 day, 1 hour, 30 seconds\"\nTimeSpan.FromMilliseconds(1299630020).Humanize(5) => \"2 weeks, 1 day, 1 hour, 30 seconds, 20 milliseconds\"\n```\n\nBy default when using `precision` parameter empty time units are not counted towards the precision of the returned value.\nIf this behavior isn't desired for you, you can use the overloaded `TimeSpan.Humanize` method with `countEmptyUnits` parameter. Leading empty time units never count.\nHere is an example showing the difference of counting empty units:\n\n```C#\nTimeSpan.FromMilliseconds(3603001).Humanize(3) => \"1 hour, 3 seconds, 1 millisecond\"\nTimeSpan.FromMilliseconds(3603001).Humanize(3, countEmptyUnits:true) => \"1 hour, 3 seconds\"\n```\n\nMany localizations are available for this method:\n\n```C#\n// in de-DE culture\nTimeSpan.FromDays(1).Humanize() => \"Ein Tag\"\nTimeSpan.FromDays(2).Humanize() => \"2 Tage\"\n\n// in sk-SK culture\nTimeSpan.FromMilliseconds(1).Humanize() => \"1 milisekunda\"\nTimeSpan.FromMilliseconds(2).Humanize() => \"2 milisekundy\"\nTimeSpan.FromMilliseconds(5).Humanize() => \"5 milisekúnd\"\n```\n\nCulture to use can be specified explicitly. If it is not, current thread's current UI culture is used. Example:\n\n```C#\nTimeSpan.FromDays(1).Humanize(culture: \"ru-RU\") => \"один день\"\n```\n\nIn addition, a minimum unit of time may be specified to avoid rolling down to a smaller unit. For example:\n  ```C#\n  TimeSpan.FromMilliseconds(122500).Humanize(minUnit: TimeUnit.Second) => \"2 minutes, 2 seconds\"    // instead of 2 minutes, 2 seconds, 500 milliseconds\n  TimeSpan.FromHours(25).Humanize(minUnit: TimeUnit.Day) => \"1 Day\"   //instead of 1 Day, 1 Hour\n  ```\n\nIn addition, a maximum unit of time may be specified to avoid rolling up to the next largest unit. For example:\n```C#\nTimeSpan.FromDays(7).Humanize(maxUnit: TimeUnit.Day) => \"7 days\"    // instead of 1 week\nTimeSpan.FromMilliseconds(2000).Humanize(maxUnit: TimeUnit.Millisecond) => \"2000 milliseconds\"    // instead of 2 seconds\n```\nThe default maxUnit is `TimeUnit.Week` because it gives exact results. You can increase this value to `TimeUnit.Month` or `TimeUnit.Year` which will give you an approximation based on 365.2425 days a year and 30.436875 days a month. Therefore the months are alternating between 30 and 31 days in length and every fourth year is 366 days long.\n```C#\nTimeSpan.FromDays(486).Humanize(maxUnit: TimeUnit.Year, precision: 7) => \"1 year, 3 months, 29 days\" // One day further is 1 year, 4 month\nTimeSpan.FromDays(517).Humanize(maxUnit: TimeUnit.Year, precision: 7) => \"1 year, 4 months, 30 days\" // This month has 30 days and one day further is 1 year, 5 months\n```\n\nWhen there are multiple time units, they are combined using the `\", \"` string:\n\n```C#\nTimeSpan.FromMilliseconds(1299630020).Humanize(3) => \"2 weeks, 1 day, 1 hour\"\n```\n\nWhen `TimeSpan` is zero, the default behavior will return \"0\" plus whatever the minimum time unit is. However, if you assign `true` to `toWords` when calling `Humanize`, then the method returns \"no time\". For example:\n```C#\nTimeSpan.Zero.Humanize(1) => \"0 milliseconds\"\nTimeSpan.Zero.Humanize(1, toWords: true) => \"no time\"\nTimeSpan.Zero.Humanize(1, minUnit: Humanizer.Localisation.TimeUnit.Second) => \"0 seconds\"\n```\n\nUsing the `collectionSeparator` parameter, you can specify your own separator string:\n\n```C#\nTimeSpan.FromMilliseconds(1299630020).Humanize(3, collectionSeparator: \" - \") => \"2 weeks - 1 day - 1 hour\"\n````\n\nIt is also possible to use the current culture's collection formatter to combine the time units. To do so, specify `null` as the `collectionSeparator` parameter:\n\n```C#\n// in en-US culture\nTimeSpan.FromMilliseconds(1299630020).Humanize(3, collectionSeparator: null) => \"2 weeks, 1 day, and 1 hour\"\n\n// in de-DE culture\nTimeSpan.FromMilliseconds(1299630020).Humanize(3, collectionSeparator: null) => \"2 Wochen, Ein Tag und Eine Stunde\"\n```\n\nIf words are preferred to numbers, a `toWords: true` parameter can be set to convert the numbers in a humanized TimeSpan to words:\n```C#\nTimeSpan.FromMilliseconds(1299630020).Humanize(3, toWords: true) => \"two weeks, one day, one hour\"\n```\n\nBy calling `ToAge`, a `TimeSpan` can also be expressed as an age.\nFor cultures that do not define an age expression, the result will be the same as calling `Humanize` _(but with a default `maxUnit` equal to `TimeUnit.Year`)_. \n\n```C#\n// in en-US culture\nTimeSpan.FromDays(750).ToAge() => \"2 years old\"\n\n// in fr culture\nTimeSpan.FromDays(750).ToAge() => \"2 ans\"\n```\n\n\n### Humanize Collections\n\nYou can call `Humanize` on any `IEnumerable` to get a nicely formatted string representing the objects in the collection. By default `ToString()` will be called on each item to get its representation but a formatting function may be passed to `Humanize` instead. Additionally, a default separator is provided (\"and\" in English), but a different separator may be passed into `Humanize`.\n\nFor instance:\n\n```C#\nclass SomeClass\n{\n    public string SomeString;\n    public int SomeInt;\n    public override string ToString()\n    {\n        return \"Specific String\";\n    }\n}\n\nstring FormatSomeClass(SomeClass sc)\n{\n    return string.Format(\"SomeObject #{0} - {1}\", sc.SomeInt, sc.SomeString);\n}\n\nvar collection = new List<SomeClass>\n{\n    new SomeClass { SomeInt = 1, SomeString = \"One\" },\n    new SomeClass { SomeInt = 2, SomeString = \"Two\" },\n    new SomeClass { SomeInt = 3, SomeString = \"Three\" }\n};\n\ncollection.Humanize()                                    // \"Specific String, Specific String, and Specific String\"\ncollection.Humanize(\"or\")                                // \"Specific String, Specific String, or Specific String\"\ncollection.Humanize(FormatSomeClass)                     // \"SomeObject #1 - One, SomeObject #2 - Two, and SomeObject #3 - Three\"\ncollection.Humanize(sc => sc.SomeInt.Ordinalize(), \"or\") // \"1st, 2nd, or 3rd\"\n```\n\nItems are trimmed and blank (NullOrWhitespace) items are skipped. This results in clean comma punctuation. (If there is a custom formatter function, this applies only to the formatter's output.)\n\nYou can provide your own collection formatter by implementing `ICollectionFormatter` and registering it with `Configurator.CollectionFormatters`.\n\n\n### Inflector methods\n\nThere are also a few inflector methods:\n\n\n#### Pluralize\n\n`Pluralize` pluralizes the provided input while taking irregular and uncountable words into consideration:\n\n```C#\n\"Man\".Pluralize() => \"Men\"\n\"string\".Pluralize() => \"strings\"\n```\n\nNormally you would call `Pluralize` on a singular word but if you're unsure about the singularity of the word you can call the method with the optional `inputIsKnownToBeSingular` argument:\n\n```C#\n\"Men\".Pluralize(inputIsKnownToBeSingular: false) => \"Men\"\n\"Man\".Pluralize(inputIsKnownToBeSingular: false) => \"Men\"\n\"string\".Pluralize(inputIsKnownToBeSingular: false) => \"strings\"\n```\n\n\nThe overload of `Pluralize` with `plurality` argument is obsolete and was removed in version 2.0.\n\n\n#### Singularize\n\n`Singularize` singularizes the provided input while taking irregular and uncountable words into consideration:\n\n```C#\n\"Men\".Singularize() => \"Man\"\n\"strings\".Singularize() => \"string\"\n```\n\nNormally you would call `Singularize` on a plural word but if you're unsure about the plurality of the word you can call the method with the optional `inputIsKnownToBePlural` argument:\n\n```C#\n\"Men\".Singularize(inputIsKnownToBePlural: false) => \"Man\"\n\"Man\".Singularize(inputIsKnownToBePlural: false) => \"Man\"\n\"strings\".Singularize(inputIsKnownToBePlural: false) => \"string\"\n```\n\n\nThe overload of `Singularize` with `plurality` argument is obsolete and was removed in version 2.0.\n\n\n## Adding Words\n\nSometimes, you may need to add a rule from the singularization/pluralization vocabulary (the examples below are already in the `DefaultVocabulary` used by `Inflector`):\n\n```C#\n// Adds a word to the vocabulary which cannot easily be pluralized/singularized by RegEx.\n// Will match both \"salesperson\" and \"person\".\nVocabularies.Default.AddIrregular(\"person\", \"people\");\n\n// To only match \"person\" and not \"salesperson\" you would pass false for the 'matchEnding' parameter.\nVocabularies.Default.AddIrregular(\"person\", \"people\", matchEnding: false);\n\n// Adds an uncountable word to the vocabulary.  Will be ignored when plurality is changed:\nVocabularies.Default.AddUncountable(\"fish\");\n\n// Adds a rule to the vocabulary that does not follow trivial rules for pluralization:\nVocabularies.Default.AddPlural(\"bus\", \"buses\");\n\n// Adds a rule to the vocabulary that does not follow trivial rules for singularization\n// (will match both \"vertices\" -> \"vertex\" and \"indices\" -> \"index\"):\nVocabularies.Default.AddSingular(\"(vert|ind)ices$\", \"$1ex\");\n\n```\n\n\n#### ToQuantity\n\nMany times you want to call `Singularize` and `Pluralize` to prefix a word with a number; e.g. \"2 requests\", \"3 men\". `ToQuantity` prefixes the provided word with the number and accordingly pluralizes or singularizes the word:\n\n```C#\n\"case\".ToQuantity(0) => \"0 cases\"\n\"case\".ToQuantity(1) => \"1 case\"\n\"case\".ToQuantity(5) => \"5 cases\"\n\"man\".ToQuantity(0) => \"0 men\"\n\"man\".ToQuantity(1) => \"1 man\"\n\"man\".ToQuantity(2) => \"2 men\"\n```\n\n`ToQuantity` can figure out whether the input word is singular or plural and will singularize or pluralize as necessary:\n\n```C#\n\"men\".ToQuantity(2) => \"2 men\"\n\"process\".ToQuantity(2) => \"2 processes\"\n\"process\".ToQuantity(1) => \"1 process\"\n\"processes\".ToQuantity(2) => \"2 processes\"\n\"processes\".ToQuantity(1) => \"1 process\"\n```\n\nYou can also pass a second argument, `ShowQuantityAs`, to `ToQuantity` to specify how you want the provided quantity to be outputted. The default value is `ShowQuantityAs.Numeric` which is what we saw above. The other two values are `ShowQuantityAs.Words` and `ShowQuantityAs.None`.\n\n```C#\n\"case\".ToQuantity(5, ShowQuantityAs.Words) => \"five cases\"\n\"case\".ToQuantity(5, ShowQuantityAs.None) => \"cases\"\n```\n\nThere is also an overload that allows you to format the number. You can pass in the format and the culture to be used.\n\n```C#\n\"dollar\".ToQuantity(2, \"C0\", new CultureInfo(\"en-US\")) => \"$2 dollars\"\n\"dollar\".ToQuantity(2, \"C2\", new CultureInfo(\"en-US\")) => \"$2.00 dollars\"\n\"cases\".ToQuantity(12000, \"N0\") => \"12,000 cases\"\n```\n\n\n#### Ordinalize\n\n`Ordinalize` turns a number into an ordinal string used to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th:\n\n```C#\n1.Ordinalize() => \"1st\"\n5.Ordinalize() => \"5th\"\n```\n\nYou can also call `Ordinalize` on a numeric string and achieve the same result: `\"21\".Ordinalize()` => `\"21st\"`\n\n`Ordinalize` also supports grammatical gender for both forms.\nYou can pass an argument to `Ordinalize` to specify which gender the number should be outputted in.\nThe possible values are `GrammaticalGender.Masculine`, `GrammaticalGender.Feminine` and `GrammaticalGender.Neuter`:\n\n```C#\n// for Brazilian Portuguese locale\n1.Ordinalize(GrammaticalGender.Masculine) => \"1º\"\n1.Ordinalize(GrammaticalGender.Feminine) => \"1ª\"\n1.Ordinalize(GrammaticalGender.Neuter) => \"1º\"\n\"2\".Ordinalize(GrammaticalGender.Masculine) => \"2º\"\n\"2\".Ordinalize(GrammaticalGender.Feminine) => \"2ª\"\n\"2\".Ordinalize(GrammaticalGender.Neuter) => \"2º\"\n```\n\nObviously this only applies to some cultures. For others passing gender in or not passing at all doesn't make any difference in the result.\n\nIn addition, `Ordinalize` supports variations some cultures apply depending on the position of the ordinalized number in a sentence.\nUse the argument `wordForm` to get one result or another. Possible values are `WordForm.Abbreviation` and `WordForm.Normal`.\nYou can combine `wordForm` argument with gender but passing this argument in when it is not applicable will not make any difference in the result.\n\n```C#\n// Spanish locale\n1.Ordinalize(WordForm.Abbreviation) => \"1.er\" // As in \"Vivo en el 1.er piso\"\n1.Ordinalize(WordForm.Normal) => \"1.º\" // As in \"He llegado el 1º\"\n\"3\".Ordinalize(GrammaticalGender.Feminine, WordForm.Abbreviation) => \"3.ª\"\n\"3\".Ordinalize(GrammaticalGender.Feminine, WordForm.Normal) => \"3.ª\"\n\"3\".Ordinalize(GrammaticalGender.Masculine, WordForm.Abbreviation) => \"3.er\"\n\"3\".Ordinalize(GrammaticalGender.Masculine, WordForm.Normal) => \"3.º\"\n```\n\n\n#### Titleize\n\n`Titleize` converts the input words to Title casing; equivalent to `\"some title\".Humanize(LetterCasing.Title)`\n\n\n#### Pascalize\n\n`Pascalize` converts the input words to UpperCamelCase, also removing underscores and spaces:\n\n```C#\n\"some_title for something\".Pascalize() => \"SomeTitleForSomething\"\n```\n\n\n#### Camelize\n\n`Camelize` behaves identically to `Pascalize`, except that the first character is lower case:\n\n```C#\n\"some_title for something\".Camelize() => \"someTitleForSomething\"\n```\n\n\n#### Underscore\n\n`Underscore` separates the input words with underscore:\n\n```C#\n\"SomeTitle\".Underscore() => \"some_title\"\n```\n\n\n#### Dasherize & Hyphenate\n\n`Dasherize` and `Hyphenate` replace underscores with dashes in the string:\n\n```C#\n\"some_title\".Dasherize() => \"some-title\"\n\"some_title\".Hyphenate() => \"some-title\"\n```\n\n\n#### Kebaberize\n\n`Kebaberize` separates the input words with hyphens and all words are converted to lowercase\n\n```C#\n\"SomeText\".Kebaberize() => \"some-text\"\n```\n\n\n### Fluent Date\n\nHumanizer provides a fluent API to deal with `DateTime` and `TimeSpan` as follows:\n\n`TimeSpan` methods:\n\n```C#\n2.Milliseconds() => TimeSpan.FromMilliseconds(2)\n2.Seconds() => TimeSpan.FromSeconds(2)\n2.Minutes() => TimeSpan.FromMinutes(2)\n2.Hours() => TimeSpan.FromHours(2)\n2.Days() => TimeSpan.FromDays(2)\n2.Weeks() => TimeSpan.FromDays(14)\n```\n\n<small>There are no fluent APIs for month or year as a month could have between 28 to 31 days and a year could be 365 or 366 days.</small>\n\nYou could use these methods to, for example, replace\n\n```C#\nDateTime.Now.AddDays(2).AddHours(3).AddMinutes(-5)\n```\n\nwith\n\n```C#\nDateTime.Now + 2.Days() + 3.Hours() - 5.Minutes()\n```\n\nThere are also three categories of fluent methods to deal with `DateTime`:\n\n```C#\nIn.TheYear(2010) // Returns the first of January of 2010\nIn.January // Returns 1st of January of the current year\nIn.FebruaryOf(2009) // Returns 1st of February of 2009\n\nIn.One.Second //  DateTime.UtcNow.AddSeconds(1);\nIn.Two.SecondsFrom(DateTime dateTime)\nIn.Three.Minutes // With corresponding From method\nIn.Three.Hours // With corresponding From method\nIn.Three.Days // With corresponding From method\nIn.Three.Weeks // With corresponding From method\nIn.Three.Months // With corresponding From method\nIn.Three.Years // With corresponding From method\n\nOn.January.The4th // Returns 4th of January of the current year\nOn.February.The(12) // Returns 12th of Feb of the current year\n```\n\nand some extension methods:\n\n```C#\nvar someDateTime = new DateTime(2011, 2, 10, 5, 25, 45, 125);\n\n// Returns new DateTime(2008, 2, 10, 5, 25, 45, 125) changing the year to 2008\nsomeDateTime.In(2008)\n\n// Returns new DateTime(2011, 2, 10, 2, 25, 45, 125) changing the hour to 2:25:45.125\nsomeDateTime.At(2)\n\n// Returns new DateTime(2011, 2, 10, 2, 20, 15, 125) changing the time to 2:20:15.125\nsomeDateTime.At(2, 20, 15)\n\n// Returns new DateTime(2011, 2, 10, 12, 0, 0) changing the time to 12:00:00.000\nsomeDateTime.AtNoon()\n\n// Returns new DateTime(2011, 2, 10, 0, 0, 0) changing the time to 00:00:00.000\nsomeDateTime.AtMidnight()\n```\n\nObviously you could chain the methods too; e.g. `On.November.The13th.In(2010).AtNoon + 5.Minutes()`\n\n\n### Number to numbers\n\nHumanizer provides a fluent API that produces (usually big) numbers in a clearer fashion:\n\n```C#\n1.25.Billions() => 1250000000\n3.Hundreds().Thousands() => 300000\n```\n\n\n### Number to words\n\nHumanizer can change numbers to words using the `ToWords` extension:\n\n```C#\n1.ToWords() => \"one\"\n10.ToWords() => \"ten\"\n11.ToWords() => \"eleven\"\n122.ToWords() => \"one hundred and twenty-two\"\n3501.ToWords() => \"three thousand five hundred and one\"\n```\n\nYou can also pass a second argument, `GrammaticalGender`, to `ToWords` to specify which gender the number should be outputted in.\nThe possible values are `GrammaticalGender.Masculine`, `GrammaticalGender.Feminine` and `GrammaticalGender.Neuter`:\n\n```C#\n// for Russian locale\n1.ToWords(GrammaticalGender.Masculine) => \"один\"\n1.ToWords(GrammaticalGender.Feminine) => \"одна\"\n1.ToWords(GrammaticalGender.Neuter) => \"одно\"\n```\n\n```C#\n// for Arabic locale\n1.ToWords(GrammaticalGender.Masculine) => \"واحد\"\n1.ToWords(GrammaticalGender.Feminine) => \"واحدة\"\n1.ToWords(GrammaticalGender.Neuter) => \"واحد\"\n(-1).ToWords() => \"ناقص واحد\"\n```\n\nObviously this only applies to some cultures. For others passing gender in doesn't make any difference in the result.\n\nAlso, culture to use can be specified explicitly. If it is not, current thread's current UI culture is used. Here's an example:\n\n```C#\n11.ToWords(new CultureInfo(\"en\")) => \"eleven\"\n1.ToWords(GrammaticalGender.Masculine, new CultureInfo(\"ru\")) => \"один\"\n```\n\nAnother overload of the method allow you to pass a bool to remove the \"And\" that can be added before the last number:\n\n```C#\n3501.ToWords(false) => \"three thousand five hundred one\"\n102.ToWords(false) => \"one hundred two\"\n```\nThis method can be useful for writing checks for example.\n\nFurthermore, `ToWords` supports variations some cultures apply depending on the position of the number in a sentence.\nUse the argument `wordForm` to get one result or another. Possible values are `WordForm.Abbreviation` and `WordForm.Normal`.\nThis argument can be combined with the rest of the arguments presented above.\nPassing `wordForm` argument in when it is not applicable will not make any difference in the result.\n\n```C#\n// Spanish locale\n21501.ToWords(WordForm.Abbreviation, GrammaticalGender.Masculine) => \"veintiún mil quinientos un\"\n21501.ToWords(WordForm.Normal, GrammaticalGender.Masculine) => \"veintiún mil quinientos uno\"\n21501.ToWords(WordForm.Abbreviation, GrammaticalGender.Feminine) => \"veintiuna mil quinientas una\"\n// English US locale\n21501.ToWords(WordForm.Abbreviation, GrammaticalGender.Masculine, new CultureInfo(\"en-US\")) => \"twenty-one thousand five hundred and one\"\n```\n\n\n### Number to ordinal words\n\nThis is kind of mixing `ToWords` with `Ordinalize`. You can call `ToOrdinalWords` on a number to get an ordinal representation of the number in words! For example:\n\n```C#\n0.ToOrdinalWords() => \"zeroth\"\n1.ToOrdinalWords() => \"first\"\n2.ToOrdinalWords() => \"second\"\n8.ToOrdinalWords() => \"eighth\"\n10.ToOrdinalWords() => \"tenth\"\n11.ToOrdinalWords() => \"eleventh\"\n12.ToOrdinalWords() => \"twelfth\"\n20.ToOrdinalWords() => \"twentieth\"\n21.ToOrdinalWords() => \"twenty first\"\n121.ToOrdinalWords() => \"hundred and twenty first\"\n```\n\n`ToOrdinalWords` also supports grammatical gender.\nYou can pass a second argument to `ToOrdinalWords` to specify the gender of the output.\nThe possible values are `GrammaticalGender.Masculine`, `GrammaticalGender.Feminine` and `GrammaticalGender.Neuter`:\n\n```C#\n// for Brazilian Portuguese locale\n1.ToOrdinalWords(GrammaticalGender.Masculine) => \"primeiro\"\n1.ToOrdinalWords(GrammaticalGender.Feminine) => \"primeira\"\n1.ToOrdinalWords(GrammaticalGender.Neuter) => \"primeiro\"\n2.ToOrdinalWords(GrammaticalGender.Masculine) => \"segundo\"\n2.ToOrdinalWords(GrammaticalGender.Feminine) => \"segunda\"\n2.ToOrdinalWords(GrammaticalGender.Neuter) => \"segundo\"\n```\n\n```C#\n// for Arabic locale\n1.ToOrdinalWords(GrammaticalGender.Masculine) => \"الأول\"\n1.ToOrdinalWords(GrammaticalGender.Feminine) => \"الأولى\"\n1.ToOrdinalWords(GrammaticalGender.Neuter) => \"الأول\"\n2.ToOrdinalWords(GrammaticalGender.Masculine) => \"الثاني\"\n2.ToOrdinalWords(GrammaticalGender.Feminine) => \"الثانية\"\n2.ToOrdinalWords(GrammaticalGender.Neuter) => \"الثاني\"\n```\n\nObviously this only applies to some cultures. For others passing gender in doesn't make any difference in the result.\n\nAlso, culture to use can be specified explicitly. If it is not, current thread's current UI culture is used. Here's an example:\n\n```C#\n10.ToOrdinalWords(new CultureInfo(\"en-US\")) => \"tenth\"\n1.ToOrdinalWords(GrammaticalGender.Masculine, new CulureInfo(\"pt-BR\")) => \"primeiro\"\n```\n\n`ToOrdinalWords` also supports variations some cultures apply depending on the position of the ordinalized number in a sentence.\nUse the argument `wordForm` to get one result or another. Possible values are `WordForm.Abbreviation` and `WordForm.Normal`.\nCombine this argument with the rest of the arguments presented above.\nPassing `wordForm` argument in when it is not applicable will not make any difference in the result.\n\n```C#\n// Spanish locale\n43.ToOrdinalWords(WordForm.Normal, GrammaticalGender.Masculine) => \"cuadragésimo tercero\"\n43.ToOrdinalWords(WordForm.Abbreviation, GrammaticalGender.Masculine) => \"cuadragésimo tercer\"\n43.ToOrdinalWords(WordForm.Abbreviation, GrammaticalGender.Feminine) => \"cuadragésima tercera\"\n// English locale\n43.ToOrdinalWords(GrammaticalGender.Masculine, WordForm.Abbreviation, new CultureInfo(\"en\")) => \"forty-third\"\n```\n\n\n### DateTime to ordinal words\n\nThis is kind of an extension of Ordinalize\n```C#\n// for English UK locale\nnew DateTime(2015, 1, 1).ToOrdinalWords() => \"1st January 2015\"\nnew DateTime(2015, 2, 12).ToOrdinalWords() => \"12th February 2015\"\nnew DateTime(2015, 3, 22).ToOrdinalWords() => \"22nd March 2015\"\n// for English US locale\nnew DateTime(2015, 1, 1).ToOrdinalWords() => \"January 1st, 2015\"\nnew DateTime(2015, 2, 12).ToOrdinalWords() => \"February 12th, 2015\"\nnew DateTime(2015, 3, 22).ToOrdinalWords() => \"March 22nd, 2015\"\n```\n\n`ToOrdinalWords` also supports grammatical case.\nYou can pass a second argument to `ToOrdinalWords` to specify the case of the output.\nThe possible values are `GrammaticalCase.Nominative`, `GrammaticalCase.Genitive`, `GrammaticalCase.Dative`, `GrammaticalCase.Accusative`, `GrammaticalCase.Instrumental` and `GrammaticalGender.Prepositional`:\n\n```C#\n```\n\nObviously this only applies to some cultures. For others passing case in doesn't make any difference in the result.\n\n\n### TimeOnly to Clock Notation\n\nExtends TimeOnly to allow humanizing it to a clock notation\n```C#\n// for English US locale\nnew TimeOnly(3, 0).ToClockNotation() => \"three o'clock\"\nnew TimeOnly(12, 0).ToClockNotation() => \"noon\"\nnew TimeOnly(14, 30).ToClockNotation() => \"half past two\"\n\n// for Brazilian Portuguese locale\nnew TimeOnly(3, 0).ToClockNotation() => \"três em ponto\"\nnew TimeOnly(12, 0).ToClockNotation() => \"meio-dia\"\nnew TimeOnly(14, 30).ToClockNotation() => \"duas e meia\"\n```\n\n\n### Roman numerals\n\nHumanizer can change numbers to Roman numerals using the `ToRoman` extension. The numbers 1 to 10 can be expressed in Roman numerals as follows:\n\n```C#\n1.ToRoman() => \"I\"\n2.ToRoman() => \"II\"\n3.ToRoman() => \"III\"\n4.ToRoman() => \"IV\"\n5.ToRoman() => \"V\"\n6.ToRoman() => \"VI\"\n7.ToRoman() => \"VII\"\n8.ToRoman() => \"VIII\"\n9.ToRoman() => \"IX\"\n10.ToRoman() => \"X\"\n```\n\nAlso the reverse operation using the `FromRoman` extension.\n\n```C#\n\"I\".FromRoman() => 1\n\"II\".FromRoman() => 2\n\"III\".FromRoman() => 3\n\"IV\".FromRoman() => 4\n\"V\".FromRoman() => 5\n```\nNote that only integers smaller than 4000 can be converted to Roman numerals.\n\n\n### Metric numerals\n\nHumanizer can change numbers to Metric numerals using the `ToMetric` extension. The numbers 1, 1230 and 0.1 can be expressed in Metric numerals as follows:\n\n```C#\n1d.ToMetric() => \"1\"\n1230d.ToMetric() => \"1.23k\"\n0.1d.ToMetric() => \"100m\"\n```\n\nAlso the reverse operation using the `FromMetric` extension.\n\n```C#\n\"1\".FromMetric() => 1\n\"1.23k\".FromMetric() => 1230\n\"100m\".FromMetric() => 0.1\n```\n\n\n### ByteSize\n\nHumanizer includes a port of the brilliant [ByteSize](https://github.com/omar/ByteSize) library.\nQuite a few changes and additions are made on `ByteSize` to make the interaction with `ByteSize` easier and more consistent with the Humanizer API.\nHere is a few examples of how you can convert from numbers to byte sizes and between size magnitudes:\n\n```c#\nvar fileSize = (10).Kilobytes();\n\nfileSize.Bits      => 81920\nfileSize.Bytes     => 10240\nfileSize.Kilobytes => 10\nfileSize.Megabytes => 0.009765625\nfileSize.Gigabytes => 9.53674316e-6\nfileSize.Terabytes => 9.31322575e-9\n```\n\nThere are a few extension methods that allow you to turn a number into a ByteSize instance:\n\n```C#\n3.Bits();\n5.Bytes();\n(10.5).Kilobytes();\n(2.5).Megabytes();\n(10.2).Gigabytes();\n(4.7).Terabytes();\n```\n\nYou can also add/subtract the values using +/- operators and Add/Subtract methods:\n\n```C#\nvar total = (10).Gigabytes() + (512).Megabytes() - (2.5).Gigabytes();\ntotal.Subtract((2500).Kilobytes()).Add((25).Megabytes());\n```\n\nA `ByteSize` object contains two properties that represent the largest metric prefix symbol and value:\n\n```C#\nvar maxFileSize = (10).Kilobytes();\n\nmaxFileSize.LargestWholeNumberSymbol;  // \"KB\"\nmaxFileSize.LargestWholeNumberValue;   // 10\n```\n\nIf you want a string representation you can call `ToString` or `Humanize` interchangeably on the `ByteSize` instance:\n\n```C#\n7.Bits().ToString();           // 7 b\n8.Bits().ToString();           // 1 B\n(.5).Kilobytes().Humanize();   // 512 B\n(1000).Kilobytes().ToString(); // 1000 KB\n(1024).Kilobytes().Humanize(); // 1 MB\n(.5).Gigabytes().Humanize();   // 512 MB\n(1024).Gigabytes().ToString(); // 1 TB\n```\n\nYou can also optionally provide a format for the expected string representation.\nThe formatter can contain the symbol of the value to display: `b`, `B`, `KB`, `MB`, `GB`, `TB`.\nThe formatter uses the built in [`double.ToString` method](https://docs.microsoft.com/dotnet/api/system.double.tostring) with `#.##` as the default format which rounds the number to two decimal places:\n\n```C#\nvar b = (10.505).Kilobytes();\n\n// Default number format is #.##\nb.ToString(\"KB\");         // 10.52 KB\nb.Humanize(\"MB\");         // .01 MB\nb.Humanize(\"b\");          // 86057 b\n\n// Default symbol is the largest metric prefix value >= 1\nb.ToString(\"#.#\");        // 10.5 KB\n\n// All valid values of double.ToString(string format) are acceptable\nb.ToString(\"0.0000\");     // 10.5050 KB\nb.Humanize(\"000.00\");     // 010.51 KB\n\n// You can include number format and symbols\nb.ToString(\"#.#### MB\");  // .0103 MB\nb.Humanize(\"0.00 GB\");    // 0 GB\nb.Humanize(\"#.## B\");     // 10757.12 B\n```\n\nIf you want a string representation with full words you can call `ToFullWords` on the `ByteSize` instance:\n\n```C#\n7.Bits().ToFullWords();           // 7 bits\n8.Bits().ToFullWords();           // 1 byte\n(.5).Kilobytes().ToFullWords();   // 512 bytes\n(1000).Kilobytes().ToFullWords(); // 1000 kilobytes\n(1024).Kilobytes().ToFullWords(); // 1 megabyte\n(.5).Gigabytes().ToFullWords();   // 512 megabytes\n(1024).Gigabytes().ToFullWords(); // 1 terabyte\n```\n\nThere isn't a `Dehumanize` method to turn a string representation back into a `ByteSize` instance; but you can use `Parse` and `TryParse` on `ByteSize` to do that.\nLike other `TryParse` methods, `ByteSize.TryParse` returns `boolean` value indicating whether or not the parsing was successful.\nIf the value is parsed it is output to the `out` parameter supplied:\n\n```C#\nByteSize output;\nByteSize.TryParse(\"1.5mb\", out output);\n\n// Invalid\nByteSize.Parse(\"1.5 b\");   // Can't have partial bits\n\n// Valid\nByteSize.Parse(\"5b\");\nByteSize.Parse(\"1.55B\");\nByteSize.Parse(\"1.55KB\");\nByteSize.Parse(\"1.55 kB \"); // Spaces are trimmed\nByteSize.Parse(\"1.55 kb\");\nByteSize.Parse(\"1.55 MB\");\nByteSize.Parse(\"1.55 mB\");\nByteSize.Parse(\"1.55 mb\");\nByteSize.Parse(\"1.55 GB\");\nByteSize.Parse(\"1.55 gB\");\nByteSize.Parse(\"1.55 gb\");\nByteSize.Parse(\"1.55 TB\");\nByteSize.Parse(\"1.55 tB\");\nByteSize.Parse(\"1.55 tb\");\n```\n\nFinally, if you need to calculate the rate at which a quantity of bytes has been transferred, you can use the `Per` method of `ByteSize`. The `Per` method accepts one argument - the measurement interval for the bytes; this is the amount of time it took to transfer the bytes.\n\nThe `Per` method returns a `ByteRate` class which has a `Humanize` method. By default, rates are given in seconds (eg, MB/s). However, if desired, a TimeUnit may be passed to `Humanize` for an alternate interval. Valid intervals are `TimeUnit.Second`, `TimeUnit.Minute`, and `TimeUnit.Hour`. Examples of each interval and example byte rate usage is below.\n\n```C#\nvar size = ByteSize.FromMegabytes(10);\nvar measurementInterval = TimeSpan.FromSeconds(1);\n\nvar text = size.Per(measurementInterval).Humanize();\n// 10 MB/s\n\ntext = size.Per(measurementInterval).Humanize(TimeUnit.Minute);\n// 600 MB/min\n\ntext = size.Per(measurementInterval).Humanize(TimeUnit.Hour);\n// 35.15625 GB/hour\n```\n\nYou can specify a format for the bytes part of the humanized output:\n\n```C#\n19854651984.Bytes().Per(1.Seconds()).Humanize(\"#.##\");\n// 18.49 GB/s\n```\n\n\n### Heading to words\n\nHumanizer includes methods to change a numeric heading to words. The heading can be a `double` whereas the result will be a string. You can choose whether to return a full representation of the heading (e.g. north, east, south or west), a short representation (e.g. N, E, S, W) or a unicode arrow character (e.g. ↑, →, ↓, ←).\n\n```C#\n360.ToHeading();\n// N\n720.ToHeading();\n// N\n```\n\nIn order to retrieve a full version of the heading, use the following call:\n\n```C#\n180.ToHeading(HeadingStyle.Full);\n// south\n360.ToHeading(HeadingStyle.Full);\n// north\n```\n\nPlease note that a textual representation has a maximum deviation of 11.25°.\n\nThe methods above all have an overload with which you can provide a `CultureInfo` object in order to determine the localized result to return.\n\nTo retrieve an arrow representing the heading use the following method:\n\n```C#\n90.ToHeadingArrow();\n// →\n225.ToHeadingArrow();\n// ↙\n```\n\nThe arrow representation of the heading has a maximum deviation of 22.5°.\n\nIn order to retrieve a heading based on the short text representation (e.g. N, E, S, W), the following method can be used:\n\n```C#\n\"S\".FromShortHeading();\n// 180\n\"SW\".FromShortHeading();\n// 225\n```\n\n\n### Tupleize\n\nHumanizer can change whole numbers into their 'tuple'  using `Tupleize`. For example:\n\n```C#\n1.Tupleize();\n// single\n3.Tupleize();\n// triple\n100.Tupleize();\n// centuple\n```\n\nThe numbers 1-10, 100 and 1000 will be converted into a 'named' tuple (i.e. \"single\", \"double\" etc.). Any other number \"n\" will be converted to \"n-tuple\".\n\n\n### Time unit to symbol\n\nHumanizer can translate time units to their symbols:\n\n```C#\nTimeUnit.Day.ToSymbol();\n// d\nTimeUnit.Week.ToSymbol();\n// week\nTimeUnit.Year.ToSymbol();\n// y\n```\n\n\n## Mix this into your framework to simplify your life\n\nThis is just a baseline and you can use this to simplify your day to day job. For example, in Asp.Net MVC we keep chucking `Display` attribute on ViewModel properties so `HtmlHelper` can generate correct labels for us; but, just like enums, in vast majority of cases we just need a space between the words in property name - so why not use `\"string\".Humanize` for that?!\n\nYou may find an Asp.Net MVC sample [in the code](https://github.com/Humanizr/Humanizer/tree/v2.7.9/samples/Humanizer.MvcSample) that does that (although the project is excluded from the solution file to make the nuget package available for .Net 3.5 too).\n\nThis is achieved using a custom `DataAnnotationsModelMetadataProvider` I called [HumanizerMetadataProvider](https://github.com/Humanizr/Humanizer/blob/v2.7.9/samples/Humanizer.MvcSample/HumanizerMetadataProvider.cs). It is small enough to repeat here; so here we go:\n\n```C#\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.ComponentModel.DataAnnotations;\nusing System.Linq;\nusing System.Web.Mvc;\nusing Humanizer;\n\npublic class HumanizerMetadataProvider : DataAnnotationsModelMetadataProvider\n{\n    protected override ModelMetadata CreateMetadata(\n        IEnumerable<Attribute> attributes,\n        Type containerType,\n        Func<object> modelAccessor,\n        Type modelType,\n        string propertyName)\n    {\n        var propertyAttributes = attributes.ToList();\n        var modelMetadata = base.CreateMetadata(propertyAttributes, containerType, modelAccessor, modelType, propertyName);\n\n        if (IsTransformRequired(modelMetadata, propertyAttributes))\n            modelMetadata.DisplayName = modelMetadata.PropertyName.Humanize();\n\n        return modelMetadata;\n    }\n\n    private static bool IsTransformRequired(ModelMetadata modelMetadata, IList<Attribute> propertyAttributes)\n    {\n        if (string.IsNullOrEmpty(modelMetadata.PropertyName))\n            return false;\n\n        if (propertyAttributes.OfType<DisplayNameAttribute>().Any())\n            return false;\n\n        if (propertyAttributes.OfType<DisplayAttribute>().Any())\n            return false;\n\n        return true;\n    }\n}\n```\n\nThis class calls the base class to extract the metadata and then, if required, humanizes the property name.\nIt is checking if the property already has a `DisplayName` or `Display` attribute on it in which case the metadata provider will just honor the attribute and leave the property alone.\nFor other properties it will Humanize the property name. That is all.\n\nNow you need to register this metadata provider with Asp.Net MVC.\nMake sure you use `System.Web.Mvc.ModelMetadataProviders`, and not `System.Web.ModelBinding.ModelMetadataProviders`:\n\n```C#\nModelMetadataProviders.Current = new HumanizerMetadataProvider();\n```\n\n... and now you can replace:\n\n```C#\npublic class RegisterModel\n{\n    [Display(Name = \"User name\")]\n    public string UserName { get; set; }\n\n    [Display(Name = \"Email address\")]\n    public string EmailAddress { get; set; }\n\n    [Display(Name = \"Confirm password\")]\n    public string ConfirmPassword { get; set; }\n}\n```\n\nwith:\n\n```C#\npublic class RegisterModel\n{\n    public string UserName { get; set; }\n    public string EmailAddress { get; set; }\n    public string ConfirmPassword { get; set; }\n}\n```\n\n... and the \"metadata humanizer\" will take care of the rest.\n\nNo need to mention that if you want title casing for your labels you can chain the method with `Transform`:\n\n```C#\nmodelMetadata.DisplayName = modelMetadata.PropertyName.Humanize().Transform(To.TitleCase);\n```\n\n\n## Use in ASP.NET 4.x MVC Views\n\nHumanizer is a Portable Class Library. There is currently [an issue](https://stackoverflow.com/questions/16675171/what-does-the-web-config-compilation-assemblies-element-do) if you try to use PCL's in an MVC view since the MVC views do not share the same build system as the regular project. You must specify all references in the `web.config` file, including ones the project system normally automatically adds.\n\nIf you encounter errors saying that you must add a reference to either `System.Runtime` or `System.Globalization`, this applies to you. The solution is to add the contract references to your `web.config` as listed [here](https://stackoverflow.com/a/19942274/738188). Note that this applies to any PCL you use in an MVC view, not just Humanizer.\n\n\n## Continuous Integration from Azure DevOps\n\nHumanizer project is built & tested continuously by Azure DevOps (more details [here](https://dev.azure.com/dotnet/Humanizer/_build?definitionId=14)). That applies to pull requests too. Shortly after you submit a PR you can check the build and test status notification on your PR.\n\nThe current build status on the CI server is [![Build status](https://dev.azure.com/dotnet/Humanizer/_apis/build/status/Humanizer-CI?branchName=main)](https://dev.azure.com/dotnet/Humanizer/_build?definitionId=14)\n\n\n## Related projects\n\nBelow is a list of related open source projects:\n\n\n### Humanizer ReSharper Annotations\n\nIf using ReSharper, annotations for Humanizer are available in the [Humanizer.Annotations package](https://resharper-plugins.jetbrains.com/packages/Humanizer.Annotations/), which you can obtain via the ReSharper Extension Manager.\nThese annotations do not yet cover the entire library, but [pull requests are always welcome!](https://github.com/enduracode/humanizer-annotations).\n\n\n### PowerShell Humanizer\n\n[PowerShell Humanizer](https://github.com/dfinke/PowerShellHumanizer) is a PowerShell module that wraps Humanizer.\n\n\n### Humanizer JVM\n\n[Humanizer.jvm](https://github.com/MehdiK/Humanizer.jvm) is an adaptation of the Humanizer framework for .Net which is made for the jvm and is written in Kotlin.\nHumanizer.jvm meets all your jvm needs for manipulating and displaying strings, enums, dates, times, timespans, numbers and quantities.\n\n\n### Humanizer.node\n\n[Humanizer.node](https://github.com/fakoua/humanizer.node) is a TypeScript port of the Humanizer framework.\n\n\n## Icon\n\nIcon created by [Tyrone Rieschiek](https://twitter.com/Inkventive)\n"
        },
        {
          "name": "release_notes.md",
          "type": "blob",
          "size": 29.6220703125,
          "content": "# v2.2\n\n - [#634](https://github.com/Humanizr/Humanizer/pull/634) - Added support for Greek language in resources contributed by Christos Matskas ([cmatskas](https://github.com/cmatskas))\n - [#633](https://github.com/Humanizr/Humanizer/pull/633) - #632 Continued: Fuzzy month years logic for time span humanize extensions contributed by Claire Novotny ([onovotny](https://github.com/onovotny)) +enhancement\n - [#632](https://github.com/Humanizr/Humanizer/pull/632) - Fuzzy month years logic for time span humanize extensions contributed by Martin Strecker ([MaStr11](https://github.com/MaStr11))\n - [#631](https://github.com/Humanizr/Humanizer/pull/631) - Latvian localization contributed by Dmitry Bogatykh ([bogatykh](https://github.com/bogatykh))\n - [#630](https://github.com/Humanizr/Humanizer/pull/630) - billions and millions greater than 2 contributed by Rafael Bianchi ([rafaellfontana](https://github.com/rafaellfontana))\n - [#628](https://github.com/Humanizr/Humanizer/pull/628) - IsDefined is prefered contributed by Shimmy ([weitzhandler](https://github.com/weitzhandler))\n - [#623](https://github.com/Humanizr/Humanizer/issues/623) - Wrongful commit to master. What to do?\n - [#620](https://github.com/Humanizr/Humanizer/issues/620) - Double Barrel Name conversion\n - [#619](https://github.com/Humanizr/Humanizer/pull/619) - Update readme.md contributed by Tyler Brinkley ([TylerBrinkley](https://github.com/TylerBrinkley))\n - [#617](https://github.com/Humanizr/Humanizer/pull/617) - issue 611: added the method Kebaberize contributed by ([klaus78](https://github.com/klaus78))\n - [#616](https://github.com/Humanizr/Humanizer/issues/616) - English verb (Past Participle) tense conversion \"x\" => \"xed\" feasibility?\n - [#613](https://github.com/Humanizr/Humanizer/issues/613) - Humanizer.Core not working correctly, show localized strings instead of english\n - [#612](https://github.com/Humanizr/Humanizer/pull/612) - Added Swedish collection formatter contributed by Māris Brenčuks ([brencuks](https://github.com/brencuks))\n - [#610](https://github.com/Humanizr/Humanizer/pull/610) - adding parameter decimals toMetric(). Fixes #609 contributed by ([klaus78](https://github.com/klaus78))\n - [#609](https://github.com/Humanizr/Humanizer/issues/609) - add .ToMetric() rounding +enhancement\n - [#608](https://github.com/Humanizr/Humanizer/pull/608) - 605: Fix enum no display attrib contributed by Thomas Bo Nielsen ([basildk](https://github.com/basildk))\n - [#605](https://github.com/Humanizr/Humanizer/issues/605) - enum with DisplayAttribute but no Description attribute fails +fix\n - [#603](https://github.com/Humanizr/Humanizer/pull/603) - Syntax correction in readme.md contributed by Brian MacKay ([kinetiq](https://github.com/kinetiq))\n - [#602](https://github.com/Humanizr/Humanizer/pull/602) - Register Portuguese translations as `pt` contributed by ([hangy](https://github.com/hangy))\n - [#601](https://github.com/Humanizr/Humanizer/issues/601) - Humanize pt-PT problem\n - [#600](https://github.com/Humanizr/Humanizer/pull/600) - Revert \"Add Esperanto support to NumberToWords. Fixes #558\" contributed by Claire Novotny ([onovotny](https://github.com/onovotny))\n - [#598](https://github.com/Humanizr/Humanizer/pull/598) - Workaround for Croatian TimeSpan localization bug contributed by ([hangy](https://github.com/hangy))\n - [#597](https://github.com/Humanizr/Humanizer/issues/597) - Croatian localization of TimeSpan fails with >1 day\n - [#596](https://github.com/Humanizr/Humanizer/issues/596) - Can not add Humanizer 2.1.0 in Class library (.Net Core)\n - [#595](https://github.com/Humanizr/Humanizer/pull/595) - Add new overload for Ordinalize that accepts a CultureInfo contributed by Thijs Brobbel ([tiesmaster](https://github.com/tiesmaster))\n - [#590](https://github.com/Humanizr/Humanizer/pull/590) - English contributed by ([stevotennis](https://github.com/stevotennis))\n - [#589](https://github.com/Humanizr/Humanizer/pull/589) - Fix CONTRIBUTING.md of broken links. contributed by Sho Sato ([cssho](https://github.com/cssho))\n - [#588](https://github.com/Humanizr/Humanizer/pull/588) - Add resource value validation for DefaultFormatter contributed by Krisztián Bodrogi ([Chrissx](https://github.com/Chrissx))\n - [#586](https://github.com/Humanizr/Humanizer/pull/586) - added translation for DateHumanize_Now contributed by Daniel Katz ([danielkatz](https://github.com/danielkatz))\n - [#583](https://github.com/Humanizr/Humanizer/issues/583) - TimeSpan.Humanize does not behave as expected +enhancement\n - [#582](https://github.com/Humanizr/Humanizer/pull/582) - Pass through the content of the \"Letter, other\" Unicode category. contributed by ([hangy](https://github.com/hangy))\n - [#581](https://github.com/Humanizr/Humanizer/pull/581) - Fix misspelling contributed by Cameron Sjo ([cameron-sjo](https://github.com/cameron-sjo))\n - [#578](https://github.com/Humanizr/Humanizer/issues/578) - .Humanize() on \"Arabic\" letters returns empty string (or any other casing)\n - [#577](https://github.com/Humanizr/Humanizer/issues/577) - .NET Core 1.0 Support?\n - [#576](https://github.com/Humanizr/Humanizer/pull/576) - Fixed incorrect locale in readme contributed by ([fishchisel](https://github.com/fishchisel))\n - [#575](https://github.com/Humanizr/Humanizer/issues/575) - not installable for projects that targets .NET client profile\n - [#574](https://github.com/Humanizr/Humanizer/issues/574) - Difference Dasherize and Hyphenate\n - [#573](https://github.com/Humanizr/Humanizer/issues/573) - Humanizer.Core 2.1.0 breaks compatibility with PCL Profile 259\n - [#569](https://github.com/Humanizr/Humanizer/pull/569) - Add Esperanto support to NumberToWords. Fixes #558 contributed by Alois ([aloisdg](https://github.com/aloisdg))\n - [#558](https://github.com/Humanizr/Humanizer/issues/558) - Add Esperanto support for NumberToWords\n - [#504](https://github.com/Humanizr/Humanizer/pull/504) - Add support for long to ToQuantity contributed by Robert Pethick ([RobPethick](https://github.com/RobPethick)) +enhancement\n - [#503](https://github.com/Humanizr/Humanizer/issues/503) - ToQuantity does not support long quantities +enhancement\n - [#500](https://github.com/Humanizr/Humanizer/pull/500) - Add ToOrdinalWords extension with gender overload contributed by Robert Pethick ([RobPethick](https://github.com/RobPethick))\n - [#328](https://github.com/Humanizr/Humanizer/issues/328) - Ordinal number suffixes\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v2.1...v2.2)\n\n# vNext\n\n### v2.1 - 2016-07-04\n\n[Fixed issues](https://github.com/Humanizr/Humanizer/issues?q=is%3Aclosed+milestone%3Av2.1)\n[Commits](https://github.com/Humanizr/Humanizer/compare/v2.0.1...v2.1)\n\n### v2.0.1 - 2016-02-07\n  - [#520](https://github.com/Humanizr/Humanizer/issues/520) Humanizer.Core package does not install on Xamarin\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v2.0...v2.0.1)\n\n### v2.0.0 - 2016-01-30\n  - [#507](https://github.com/Humanizr/Humanizer/issues/507) Remove obsolete members\n  - [#517](https://github.com/Humanizr/Humanizer/pull/517) Allow formatted byte size when humanizing `ByteRate`\n  - [#497](https://github.com/Humanizr/Humanizer/issues/497) Add option to customize list of time indicators of humanized timespans\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.37.0...v2.0)\n\n### v2.0.0-beta02 - 2015-12-30\n  - [#59](https://github.com/Humanizr/Humanizer/issues/59) Getting only needed resources on nuget install \n  - [#101](https://github.com/Humanizr/Humanizer/issues/101) Add precision to DateTime.Humanize \n  - [#234](https://github.com/Humanizr/Humanizer/issues/234) Remove Plurality enum \n  - [#238](https://github.com/Humanizr/Humanizer/issues/238) Change DefaultDateTimeHumanizeStrategy to turn 60 min to one hour not 45 \n  - [#470](https://github.com/Humanizr/Humanizer/issues/470) & [#492](https://github.com/Humanizr/Humanizer/issues/492): Build warning fixes \n\n [Commits](https://github.com/Humanizr/Humanizer/compare/v2.0.0-beta01...v2.0.0-beta02)\n\n### v2.0.0-beta0001 - 2015-11-01\n - [#451](https://github.com/Humanizr/Humanizer/issues/451): Support `dotnet` TFM. Includes support for CoreCLR\n - [#465](https://github.com/Humanizr/Humanizer/issues/465): Dropped .NET 4 and Silverlight 5 support.\n - [#462](https://github.com/Humanizr/Humanizer/pull/462): Implemented Spanish cardinal feminines\n - [#459](https://github.com/Humanizr/Humanizer/pull/459): Add support of metric numeral expressions\n - Enable source debugging via [GitLink](https://github.com/GitTools/GitLink)\n\n [Commits](https://github.com/Humanizr/Humanizer/compare/v1.37.0...v2.0.0-beta01)\n\n### v1.37.0 - 2015-07-03\n - [#416](https://github.com/Humanizr/Humanizer/pull/416): Change BrazilianPortugueseOrdinalizer to PortugueseOrdinalizer\n - [#419](https://github.com/Humanizr/Humanizer/pull/419): Added Dutch Ordinalizer\n - [#432](https://github.com/Humanizr/Humanizer/pull/432): Added the 'xunit.runner.visualstudio' nuget package to the test project\n - [#431](https://github.com/Humanizr/Humanizer/pull/431): Added build target for .NET 4.0 Client Profile\n - [#435](https://github.com/Humanizr/Humanizer/pull/435): Added Afrikaans localization\n - [#438](https://github.com/Humanizr/Humanizer/pull/438): Fixed the bug with negative TimeSpan Humanize\n - [#421](https://github.com/Humanizr/Humanizer/pull/421) & [#425](https://github.com/Humanizr/Humanizer/pull/425): Fixed StringExentions -> StringExtensions\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.36.0...v1.37.0)\n\n### v1.36.0 - 2015-05-24\n - [#403](https://github.com/Humanizr/Humanizer/pull/403): Added TimeSpan minUnit option\n - [#417](https://github.com/Humanizr/Humanizer/pull/417): Support for Serbian language, ToWords()\n - [#414](https://github.com/Humanizr/Humanizer/pull/414): Add Ukraininan language\n - [#408](https://github.com/Humanizr/Humanizer/pull/408): Added support for adding/removing rules from singular/pluralization by adding `Vocabulary` class and `Vocabularies.Default`\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.35.0...v1.36.0)\n\n### v1.35.0 - 2015-03-29\n - [#399](https://github.com/Humanizr/Humanizer/pull/399): Added support for humanizing DateTimeOffset\n - [#395](https://github.com/Humanizr/Humanizer/pull/395): Added support for Xamarin platforms to PCL\n - [#397](https://github.com/Humanizr/Humanizer/pull/397): Added is/are to inflector rules\n - [#392](https://github.com/Humanizr/Humanizer/pull/394): Default implementation for collection formatter using regular style instead of an exception. Default separator is ampercent.\n - [#377](https://github.com/Humanizr/Humanizer/pull/377): Added culture specific decimal separator\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.34.0...v1.35.0)\n\n### v1.34.0 - 2015-03-04\n - [#381](https://github.com/Humanizr/Humanizer/pull/381): Fixes trailing question mark reported in #378.\n - [#382](https://github.com/Humanizr/Humanizer/pull/382): Fix 90000th and -thousandth in RussianNumberToWordsConverter.\n - [#386](https://github.com/Humanizr/Humanizer/pull/386): Collection formatter support for German, Danish, Dutch, Portuguese and Norwegian\n - [#384](https://github.com/Humanizr/Humanizer/pull/384): Added maximum TimeUnit to TimeSpanHumanizeExtensions.Humanize to enable prevention of rolling up the next largest unit of time.\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.33.7...v1.34.0)\n\n### v1.33.7 - 2015-02-03\n - [#376](https://github.com/Humanizr/Humanizer/pull/376): Fixes the IConvertible warning thrown on Windows Phone reported on #317\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.33.0...v1.33.7)\n\n### v1.33.0 - 2015-01-26\n - [#374](https://github.com/Humanizr/Humanizer/pull/374): **BREAKING CHANGE**: Fixed Chinese locale code: CHS to Hans & CHT to Hant\n - [#366](https://github.com/Humanizr/Humanizer/pull/366): Removed UnitPreposition to avoid warnings in Win 8.1 apps\n - [#365](https://github.com/Humanizr/Humanizer/pull/365): Added ByteSizeExtensions method for long inputs\n - [#364](https://github.com/Humanizr/Humanizer/pull/364): Added \"campuses\" as plural of \"campus\"\n - [#363](https://github.com/Humanizr/Humanizer/pull/363): Use RegexOptions.Compiled if available\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.32.0...v1.33.0)\n\n### v1.32.0 - 2014-12-18\n - [#354](https://github.com/Humanizr/Humanizer/pull/354): Removed unnecessary Regex constructors\n - [#356](https://github.com/Humanizr/Humanizer/pull/356): Added missing values for ro and changed the RomanianFormatter implementation so as to avoid duplicate resources\n - [#357](https://github.com/Humanizr/Humanizer/pull/357): Added Chinese localisation\n - [#350](https://github.com/Humanizr/Humanizer/pull/350): Added missing values for nl\n - [#359](https://github.com/Humanizr/Humanizer/pull/359): Added special case resources to neutral language\n - [#362](https://github.com/Humanizr/Humanizer/pull/362): Fixed arithmatic operations in ByteSize\n - [#361](https://github.com/Humanizr/Humanizer/pull/361): Added 'criteria' as the irregular plural of 'criterion'\n - [#355](https://github.com/Humanizr/Humanizer/pull/355): Added 'waves' as plural of 'wave'\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.31.0...v1.32.0)\n\n###v1.31.0 - 2014-11-08\n  - [#340](https://github.com/Humanizr/Humanizer/pull/340): Fixed TimeSpan humanization precision skips units after the largest one when they're zero until it finds a non-zero unit\n  - [#347](https://github.com/Humanizr/Humanizer/pull/347): Changed één to 1 for dutch language.\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.30.0...v1.31.0)\n\n### v1.30.0 - 2014-11-01\n  - [#341](https://github.com/Humanizr/Humanizer/pull/341): Added logic to properly treat underscores, dashes and spaces.\n  - [#342](https://github.com/Humanizr/Humanizer/pull/342): Added complete Uzbek localisation\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.29.0...v1.30.0)\n\n### v1.29.0 - 2014-09-12\n  - [#320](https://github.com/Humanizr/Humanizer/pull/320): Fixed Dehumanize actually humanizing an already dehumanized string\n  - [#322](https://github.com/Humanizr/Humanizer/pull/322): DefaultFormatter.TimeSpanHumanize throws a more meaningful exception when called with TimeUnits larger than TimeUnit.Week\n  - [#314](https://github.com/Humanizr/Humanizer/pull/314): Added ByteRate class and supporting members to facilitate calculation of byte transfer rates\n  - [#333](https://github.com/Humanizr/Humanizer/pull/333): Added support to humanize enums from resource strings\n  - [#332](https://github.com/Humanizr/Humanizer/pull/332): Added Italian localisation and tests: date and time Resources, CollectionFormatter, NumberToWordsConverter (cardinal and ordinal), Ordinalizer\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.28.0...v1.29.0)\n\n### v1.28.0 - 2014-07-06\n  - [#309](https://github.com/Humanizr/Humanizer/pull/309): Fixed the bug with DateTime.Humanize returning tomorrow when it's not actually tomorrow\n  - [#306](https://github.com/Humanizr/Humanizer/pull/306): Added Singularize/Pluralize overload without using obsolete plurality enum\n  - [#303](https://github.com/Humanizr/Humanizer/pull/303): Added support for all integer types in ByteSize extensions\n  - [#307](https://github.com/Humanizr/Humanizer/pull/307): Added support to string.FormatWith for the explicit culture parameter\n  - [#312](https://github.com/Humanizr/Humanizer/pull/312): Added Turkish ToWord, ToOrdinalWord and Ordinalize implementation\n  - [#173](https://github.com/Humanizr/Humanizer/pull/173): Added support for Window Phone 8.1\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.27.0...v1.28.0)\n\n### v1.27.0 - 2014-06-21\n  - [#301](https://github.com/Humanizr/Humanizer/pull/301): Added Bangla (Bangladesh) localisation\n  - [#300](https://github.com/Humanizr/Humanizer/pull/300): Added optional Culture parameter to NumberToWords\n  - [#297](https://github.com/Humanizr/Humanizer/pull/297): Added support for all integer types in Fluent Date\n  - [#294](https://github.com/Humanizr/Humanizer/pull/294): Added support for untyped comparison of ByteSize\n  - [#277](https://github.com/Humanizr/Humanizer/pull/277): Added support for custom enum description attribute property names\n  - [#276](https://github.com/Humanizr/Humanizer/pull/276): Added Farsi ToOrdinalWords\n  - [#281](https://github.com/Humanizr/Humanizer/pull/281): Changed the logic for handling hyphenation and large numbers ending in twelve for English ordinal words; e.g. before \"twenty first\" now \"twenty-first\"\n  - [#278](https://github.com/Humanizr/Humanizer/pull/278): Changed DefaultDateTimeHumanizeStrategy to turn 60 min to one hour not 45\n  - [#283](https://github.com/Humanizr/Humanizer/pull/283): Added Neutral nb support for DateTime and TimeSpan Humanize\n  - [#286](https://github.com/Humanizr/Humanizer/pull/286): Added optional Culture parameter to DateTime.Humanize & TimeSpan.Humanize\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.26.1...v1.27.0)\n\n### v1.26.1 - 2014-05-20\n  - [#257](https://github.com/Humanizr/Humanizer/pull/257): Added German localisation for ToOrdinalWords and Ordinalize\n  - [#261](https://github.com/Humanizr/Humanizer/pull/261): Added future dates to Portuguese - Brazil\n  - [#269](https://github.com/Humanizr/Humanizer/pull/269): Added Vietnamese localisation\n  - [#268](https://github.com/Humanizr/Humanizer/pull/268): Added humanization of collections\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.25.4...v1.26.1)\n\n### v1.25.4 - 2014-04-27\n  - [#236](https://github.com/Humanizr/Humanizer/pull/236): Added Turkish localisation\n  - [#239](https://github.com/Humanizr/Humanizer/pull/239): Added Serbian localisation\n  - [#241](https://github.com/Humanizr/Humanizer/pull/241): Added German ToWords localisation\n  - [#244](https://github.com/Humanizr/Humanizer/pull/244): Added Slovenian localisation\n  - [#247](https://github.com/Humanizr/Humanizer/pull/247): Added Slovenian number to words localisation\n  - [#227](https://github.com/Humanizr/Humanizer/pull/227) & [#243](https://github.com/Humanizr/Humanizer/pull/243): Moved localiser registry to their own classes, allowed public access via Configurator, and made the default registrations lazy loaded\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.24.1...v1.25.4)\n\n### v1.24.1 - 2014-04-21\n  - [#232](https://github.com/Humanizr/Humanizer/pull/232): Adding code & tests to handle Arabic numbers to ordinal\n  - [#235](https://github.com/Humanizr/Humanizer/pull/235): Fixed the conversion for \"1 millon\" in SpanishNumberToWordsConverter\n  - [#233](https://github.com/Humanizr/Humanizer/pull/233): Added build.cmd and Verify build configuration for strict project build and analysis\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.23.1...v1.24.1)\n\n### v1.23.1 - 2014-04-19\n  - [#217](https://github.com/Humanizr/Humanizer/pull/217): Added pt-BR and Spanish Ordinalize localisation.\n  - [#220](https://github.com/Humanizr/Humanizer/pull/220): Added string formatting options to ToQuantity\n  - [#219](https://github.com/Humanizr/Humanizer/pull/219): Added Japanese translation for date and timespan\n  - [#221](https://github.com/Humanizr/Humanizer/pull/221): Added Russian ordinalizer\n  - [#228](https://github.com/Humanizr/Humanizer/pull/228): Fixed the \"twenties\" in SpanishNumberToWordsConverter\n  - [#231](https://github.com/Humanizr/Humanizer/pull/231): Added more settings for FromNow, Dual and Plural (Arabic)\n  - [#222](https://github.com/Humanizr/Humanizer/pull/222): Updated Ordinalize and ToOrdinalWords to account for special exceptions with 1 and 3.\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.22.1...v1.23.1)\n\n### v1.22.1 - 2014-04-14\n  - [#188](https://github.com/Humanizr/Humanizer/pull/188): Added Spanish ToOrdinalWords translations\n  - [#166](https://github.com/Humanizr/Humanizer/pull/166): Added Dutch (NL) Number to words and ordinals\n  - [#199](https://github.com/Humanizr/Humanizer/pull/199): Added Hebrew Number to words (both genders)\n  - [#202](https://github.com/Humanizr/Humanizer/pull/202): Fixed typo sekunttia -> sekuntia (Finnish translation)\n  - [#203](https://github.com/Humanizr/Humanizer/pull/203): Added feminine gender for french ordinal words\n  - [#208](https://github.com/Humanizr/Humanizer/pull/208): Added Hebrew implementation of future DateTime\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.21.1...v1.22.1)\n\n### v1.21.1 - 2014-04-12\n  - [#196](https://github.com/Humanizr/Humanizer/pull/196): Added Gender for ToOrdinalWords (needed for Brazilian Portuguese). Added pt-br OrdinalToWords localisation\n  - [#194](https://github.com/Humanizr/Humanizer/pull/194): Added pt-BR NumberToWords localisation\n  - [#147](https://github.com/Humanizr/Humanizer/pull/147): Added Russian translation for ToWords\n  - [#190](https://github.com/Humanizr/Humanizer/pull/190): Added French translation for ToWords and ToOrdinalWords\n  - [#179](https://github.com/Humanizr/Humanizer/pull/179): Added Hungarian localisation\n  - [#181](https://github.com/Humanizr/Humanizer/pull/181): Added Bulgarian localization, date and timespan tests\n  - [#141](https://github.com/Humanizr/Humanizer/pull/141): Added Indonesian localization\n  - [#148](https://github.com/Humanizr/Humanizer/pull/148): Added Hebrew localization for date and timespan\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.20.15...v1.21.1)\n\n### v1.20.15 - 2014-04-12\n  - [#186](https://github.com/Humanizr/Humanizer/pull/186): Refactored `ToOrdinalWords` to use existing `NumberToWordsExtension` to prepare for Ordinal localization\n  - [#193](https://github.com/Humanizr/Humanizer/pull/193): Fixed the NullException error on DateTime.Humanize\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.20.2...v1.20.15)\n\n### v1.20.2 - 2014-04-11\n  - [#171](https://github.com/Humanizr/Humanizer/pull/171): T4-Template fix: Using EnglishNumberToWordsConverter instead of 'ToWords()' while dogfooding the template with the library.\n  - [#165](https://github.com/Humanizr/Humanizer/pull/165): Added precision based `DateTime.Humanize` strategy\n  - [#155](https://github.com/Humanizr/Humanizer/pull/155): French and Belgian French localisation\n  - [#151](https://github.com/Humanizr/Humanizer/pull/151): Added Spanish ToWords Translations\n  - [#172](https://github.com/Humanizr/Humanizer/pull/172): Added Polish translation for ToWords\n  - [#184](https://github.com/Humanizr/Humanizer/pull/184): Fixed spelling error with forth/fourth in EnglishNumberToWordsConverter\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.19.1...v1.20.2)\n\n### v1.19.1 - 2014-04-10\n  - [#149](https://github.com/Humanizr/Humanizer/pull/149): Improved & refactored number to words localisation\n  - [#143](https://github.com/Humanizr/Humanizer/pull/143): Added Russian translation for future DateTime, TimeSpan and Now\n  - [#144](https://github.com/Humanizr/Humanizer/pull/144): Added Danish localization (strings, tests)\n  - [#146](https://github.com/Humanizr/Humanizer/pull/146): Added Spanish translation for future DateTime, TimeSpan and Now\n\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.18.1...v1.19.1)\n\n### v1.18.1 - 2014-04-09\n  - [#137](https://github.com/Humanizr/Humanizer/pull/137): Fixed grammar error in `nb-NO` resource file & added missing Norwegian resource strings (mainly `DateHumanize_*FromNow`)\n  - [#135](https://github.com/Humanizr/Humanizer/pull/135): Added Swedish localization (strings, tests)\n  - [#140](https://github.com/Humanizr/Humanizer/pull/140): Added Polish localization (strings, formatter, tests)\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.17.1...v1.18.1)\n\n### v1.17.1 - 2014-04-06\n  - [#124](https://github.com/Humanizr/Humanizer/pull/124): Added Slovak localization (strings, formatter, tests)\n  - [#130](https://github.com/Humanizr/Humanizer/pull/130): Added Czech localization (strings, formatter, tests)\n  - [#131](https://github.com/Humanizr/Humanizer/pull/131): Clean date humanize tests and renamed `TimeUnitTense` to `Tense`\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.16.4...v1.17.1)\n\n### v1.16.4 - 2014-04-04\n  - [#129](https://github.com/Humanizr/Humanizer/pull/129): Removed all but PCL references\n  - [#121](https://github.com/Humanizr/Humanizer/pull/121): Added Farsi translation for DateTime, TimeSpan and NumberToWords\n  - [#120](https://github.com/Humanizr/Humanizer/pull/120): Added German translation for DateTime and TimeSpan\n  - [#117](https://github.com/Humanizr/Humanizer/pull/117): Added `FormatWith` string extension\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.15.1...v1.16.4)\n\n### v1.15.1 - 2014-03-28\n  - [#113](https://github.com/Humanizr/Humanizer/pull/113): Added `Truncate` feature\n  - [#109](https://github.com/Humanizr/Humanizer/pull/109): Made Dutch (NL) localization a neutral culture, not just for Belgium\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.14.1...v1.15.1)\n\n### v1.14.1 - 2014-03-26\n  - [#108](https://github.com/Humanizr/Humanizer/pull/108): Added support for custom description attributes\n  - [#106](https://github.com/Humanizr/Humanizer/pull/106):\n    - Refactored IFormatter and DefaultFormatter\n\t- Refactored `DateTime.Humanize` and `TimeSpan.Humanize`\n\t- Changed `ResourceKeys` to use a dynamic key generation\n\t- Fixed the intermittent failing tests on `DateTime.Humanize`\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.13.2...v1.14.1)\n\n### v1.13.2 - 2014-03-17\n  - [#99](https://github.com/Humanizr/Humanizer/pull/99): Added `ByteSize` feature\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.12.4...v1.13.2)\n\n### v1.12.4 - 2014-02-25\n  - [#95](https://github.com/Humanizr/Humanizer/pull/95): Added NoMatch optional parameter to DehumanizeTo & renamed `CannotMapToTargetException` to `NoMatchFoundException`\n\n#### Breaking Changes\nIf you were catching `CannotMapToTargetException` on a `DehumanizeTo` call, that's been renamed to `NoMatchFoundException` to make it more generic.\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.11.3...v1.12.4)\n\n### v1.11.3 - 2014-02-18\n  - [#93](https://github.com/Humanizr/Humanizer/pull/93): added non-generic DehumanizeTo for Enums unknown at compile time\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.10.1...v1.11.3)\n\n### v1.10.1 - 2014-02-15\n  - [#89](https://github.com/Humanizr/Humanizer/pull/89): added `ToRoman` and `FromRoman` extensions\n  - [#82](https://github.com/Humanizr/Humanizer/pull/82): fixed Greek locale code\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.9.1...v1.10.1)\n\n### v1.9.1 - 2014-02-12\n  - [#78](https://github.com/Humanizr/Humanizer/pull/78): added support for billions to `ToWords`\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.8.1...v1.9.1)\n\n### v1.8.16 - 2014-02-12\n  - [#81](https://github.com/Humanizr/Humanizer/pull/81): fixed issue with localised methods returning null in Windows Store apps\n  - Created [Humanizr.net](http://humanizr.net) website as GitHub pages\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.8.1...v1.8.16)\n\n### v1.8.1 - 2014-02-04\n  - [#73](https://github.com/Humanizr/Humanizer/pull/73): added `ToWords` implementation for Arabic\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.7.1...v1.8.1)\n\n### v1.7.1 - 2014-02-31\n  - [#68](https://github.com/Humanizr/Humanizer/pull/68): `DateTime.Humanize()` now supports future dates\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.6.1...v1.7.1)\n\n### v1.6.1 - 2014-01-27\n  - [#69](https://github.com/Humanizr/Humanizer/pull/69): changed the return type of `DehumanizeTo<TTargetEnum>` to `TTargetEnum`\n\n#### Potential breaking change\nThe return type of `DehumanizeTo<TTargetEnum>` was changed from `Enum` to `TTargetEnum` to make the API a lot easier to work with.\nThat also potentially means that your calls to the old method may be broken.\nDepending on how you were using the method you might have to either drop the now redundant cast to `TTargetEnum` in your code, or\nfix it based on your requirements.\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.5.1...v1.6.1)\n\n### v1.5.1 - 2014-01-23\n  - [#65](https://github.com/Humanizr/Humanizer/pull/65): added precision to `TimeSpan.Humanize`\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.4.1...v1.5.1)\n\n### v1.4.1 - 2014-01-20\n  - [#62](https://github.com/Humanizr/Humanizer/pull/62): added `ShowQuantityAs` parameter to `ToQuantity`\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.3.1...v1.4.1)\n\n### v1.3.1 - 2014-14-01\n  - [#51](https://github.com/Humanizr/Humanizer/pull/51): added Spanish translation for `DateTime.Humanize`\n  - [#52](https://github.com/Humanizr/Humanizer/pull/52): added Arabic translation for `DateTime.Humanize`\n  - [#53](https://github.com/Humanizr/Humanizer/pull/53): added `Hyphenate` as an overload for `Dasherize`\n  - [#54](https://github.com/Humanizr/Humanizer/pull/54): added Portuguese translation for `DateTime.Humanize`\n  - [#55](https://github.com/Humanizr/Humanizer/pull/55): added Arabic translation for `TimeSpan.Humanize`\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.1.0...v1.3.1)\n\n### v1.1.0 - 2014-01-01\n  - [#37](https://github.com/Humanizr/Humanizer/pull/37): added `ToQuantity` method\n  - [#43](https://github.com/Humanizr/Humanizer/pull/43):\n    - added `Plurality` enum\n    - can call `Singularize` on singular and `Pluralize` on plural words\n    - `ToQuantity` can be called on words with unknown plurality\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.0.29...v1.1.0)\n\n### v1.0.29 - 2013-12-25\n  - [#26](https://github.com/Humanizr/Humanizer/pull/26): added Norwegian (nb-NO) localization for `DateTime.Humanize()`\n  - [#33](https://github.com/Humanizr/Humanizer/pull/33):\n    - changed to Portable Class Library with support for .Net 4+, SilverLight 5, Windows Phone 8 and Win Store applications\n    - symbols nuget package is published so you can step through Humanizer code while debugging your code\n\n[Commits](https://github.com/Humanizr/Humanizer/compare/v1.0.0...v1.0.29)\n\n### v1.0.0 - 2013-11-10\nNo release history before this point: check out http://www.mehdi-khalili.com/humanizer-v1 for the feature-set at V1\n\nCommits: ...\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "version.json",
          "type": "blob",
          "size": 0.25,
          "content": "{\n  \"version\": \"3.0.0-beta.{height}\",\n  \"publicReleaseRefSpec\": [\n    \"^refs/heads/main$\", // we release out of main\n    \"^refs/heads/rel/v\\\\d+\\\\.\\\\d+\" // we also release branches starting with rel/vN.N\n  ],\n  \"nugetPackageVersion\":{\n    \"semVer\": 2\n  }\n}\n"
        }
      ]
    }
  ]
}