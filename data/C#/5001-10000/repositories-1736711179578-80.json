{
  "metadata": {
    "timestamp": 1736711179578,
    "page": 80,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "dotnet/reactive",
      "stars": 6782,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 12.4365234375,
          "content": "# EditorConfig is awesome:http://EditorConfig.org\n# From https://raw.githubusercontent.com/dotnet/roslyn/master/.editorconfig\n\n# top-most EditorConfig file\nroot = true\n\n# Don't use tabs for indentation.\n[*]\nindent_style = space\ntrim_trailing_whitespace = true\n# (Please don't specify an indent_size here; that has too many unintended consequences.)\n\n# Code files\n[*.{cs,csx,vb,vbx}]\nindent_size = 4\ninsert_final_newline = true\ncharset = utf-8-bom\n\n# Xml project files\n[*.{csproj,vbproj,vcxproj,vcxproj.filters,proj,projitems,shproj}]\nindent_size = 2\n\n# Xml config files\n[*.{props,targets,ruleset,config,nuspec,resx,vsixmanifest,vsct}]\nindent_size = 2\n\n# Yml/Yaml files\n[*.{yaml,yml}]\nindent_size = 2\n\n# Powershell files\n[*.ps1]\nindent_size = 2\n\n# JSON files\n[*.json]\nindent_size = 2\n\n# Shell scripts\n[*.sh]\nend_of_line = lf\n\n[*.{cmd,bat}]\nend_of_line = crlf\n\n# Dotnet code style settings:\n[*.{cs,vb}]\n# Sort using and Import directives with System.* appearing first\ndotnet_sort_system_directives_first = true\n# Put a blank line between System.* and Microsoft.*\ndotnet_separate_import_directive_groups = true\n\n# Avoid \"this.\" and \"Me.\" if not necessary\ndotnet_style_qualification_for_field = false:suggestion\ndotnet_style_qualification_for_property = false:suggestion\ndotnet_style_qualification_for_method = false:suggestion\ndotnet_style_qualification_for_event = false:suggestion\n\n# Use language keywords instead of framework type names for type references\ndotnet_style_predefined_type_for_locals_parameters_members = true:suggestion\ndotnet_style_predefined_type_for_member_access = true:suggestion\n\n# Prefer read-only on fields\ndotnet_style_readonly_field = true:warning\n\n# Suggest more modern language features when available\ndotnet_style_object_initializer = true:silent\ndotnet_style_collection_initializer = true:suggestion\ndotnet_style_coalesce_expression = true:suggestion\ndotnet_style_null_propagation = true:suggestion\ndotnet_style_explicit_tuple_names = true:suggestion\ndotnet_style_prefer_inferred_tuple_names = true:suggestion\ndotnet_style_prefer_inferred_anonymous_type_member_names = true:suggestion\ndotnet_style_prefer_is_null_check_over_reference_equality_method = true:suggestion\ndotnet_style_prefer_conditional_expression_over_return = false\ndotnet_style_prefer_conditional_expression_over_assignment = false\ndotnet_style_prefer_auto_properties = true:silent\n\n# Parentheses\ndotnet_style_parentheses_in_arithmetic_binary_operators = always_for_clarity:silent\ndotnet_style_parentheses_in_other_binary_operators = always_for_clarity:silent\ndotnet_style_parentheses_in_other_operators = never_if_unnecessary:silent\ndotnet_style_parentheses_in_relational_binary_operators = always_for_clarity:silent\n\n# Accessibility modifiers\ndotnet_style_require_accessibility_modifiers = always:suggestion\n\n\n# Naming Rules\n\n# Interfaces start with an I and are PascalCased\ndotnet_naming_rule.interfaces_must_be_pascal_cased_and_prefixed_with_I.symbols                        = interface_symbols\ndotnet_naming_rule.interfaces_must_be_pascal_cased_and_prefixed_with_I.style                          = pascal_case_and_prefix_with_I_style\ndotnet_naming_rule.interfaces_must_be_pascal_cased_and_prefixed_with_I.severity                       = warning\n\n# External members are PascalCased\ndotnet_naming_rule.externally_visible_members_must_be_pascal_cased.symbols                            = externally_visible_symbols\ndotnet_naming_rule.externally_visible_members_must_be_pascal_cased.style                              = pascal_case_style\ndotnet_naming_rule.externally_visible_members_must_be_pascal_cased.severity                           = warning\n\n# Parameters are camelCased\ndotnet_naming_rule.parameters_must_be_camel_cased.symbols                                             = parameter_symbols\ndotnet_naming_rule.parameters_must_be_camel_cased.style                                               = camel_case_style\ndotnet_naming_rule.parameters_must_be_camel_cased.severity                                            = warning\n\n# Constants are PascalCased\ndotnet_naming_rule.constants_must_be_pascal_cased.symbols                                             = constant_symbols\ndotnet_naming_rule.constants_must_be_pascal_cased.style                                               = pascal_case_style\ndotnet_naming_rule.constants_must_be_pascal_cased.severity                                            = warning\n\n# Uncomment this group and comment out the next group if you prefer s_ prefixes for static fields\n\n# Private static fields are prefixed with s_ and are camelCased like s_myStatic\n#dotnet_naming_rule.private_static_fields_must_be_camel_cased_and_prefixed_with_s_underscore.symbols   = private_static_field_symbols\n#dotnet_naming_rule.private_static_fields_must_be_camel_cased_and_prefixed_with_s_underscore.style     = camel_case_and_prefix_with_s_underscore_style\n#dotnet_naming_rule.private_static_fields_must_be_camel_cased_and_prefixed_with_s_underscore.severity  = warning\n\n# Static readonly fields are PascalCased\ndotnet_naming_rule.static_readonly_fields_should_be_pascal_case.symbols                               = private_static_readonly_field_symbols\ndotnet_naming_rule.static_readonly_fields_should_be_pascal_case.style                                 = pascal_case_style\ndotnet_naming_rule.static_readonly_fields_should_be_pascal_case.severity                              = warning\n\n# Comment this group and uncomment out the next group if you don't want _ prefixed fields.\n\n# Private instance fields are camelCased with an _ like _myField\ndotnet_naming_rule.private_instance_fields_must_be_camel_cased_and_prefixed_with_underscore.symbols   = private_field_symbols\ndotnet_naming_rule.private_instance_fields_must_be_camel_cased_and_prefixed_with_underscore.style     = camel_case_and_prefix_with_underscore_style\ndotnet_naming_rule.private_instance_fields_must_be_camel_cased_and_prefixed_with_underscore.severity  = warning\n\n# Private instance fields are camelCased\n#dotnet_naming_rule.private_instance_fields_must_be_camel_cased.symbols                                = private_field_symbols\n#dotnet_naming_rule.private_instance_fields_must_be_camel_cased.style                                  = camel_case_style\n#dotnet_naming_rule.private_instance_fields_must_be_camel_cased.severity                               = warning\n\n# Symbols\ndotnet_naming_symbols.externally_visible_symbols.applicable_kinds                                     = class,struct,interface,enum,property,method,field,event,delegate\ndotnet_naming_symbols.externally_visible_symbols.applicable_accessibilities                           = public,internal,friend,protected,protected_internal,protected_friend,private_protected\n\ndotnet_naming_symbols.interface_symbols.applicable_kinds                                              = interface\ndotnet_naming_symbols.interface_symbols.applicable_accessibilities                                    = *\n\ndotnet_naming_symbols.parameter_symbols.applicable_kinds                                              = parameter\ndotnet_naming_symbols.parameter_symbols.applicable_accessibilities                                    = *\n\ndotnet_naming_symbols.constant_symbols.applicable_kinds                                               = field\ndotnet_naming_symbols.constant_symbols.required_modifiers                                             = const\ndotnet_naming_symbols.constant_symbols.applicable_accessibilities                                     = *\n\ndotnet_naming_symbols.private_static_field_symbols.applicable_kinds                                   = field\ndotnet_naming_symbols.private_static_field_symbols.required_modifiers                                 = static,shared\ndotnet_naming_symbols.private_static_field_symbols.applicable_accessibilities                         = private\n\ndotnet_naming_symbols.private_static_readonly_field_symbols.applicable_kinds                          = field\ndotnet_naming_symbols.private_static_readonly_field_symbols.required_modifiers                        = static,shared,readonly\ndotnet_naming_symbols.private_static_readonly_field_symbols.applicable_accessibilities                = private\n\ndotnet_naming_symbols.private_field_symbols.applicable_kinds                                          = field\ndotnet_naming_symbols.private_field_symbols.applicable_accessibilities                                = private\n\n# Styles\ndotnet_naming_style.camel_case_style.capitalization                                                   = camel_case\n\ndotnet_naming_style.pascal_case_style.capitalization                                                  = pascal_case\n\ndotnet_naming_style.camel_case_and_prefix_with_s_underscore_style.required_prefix                     = s_\ndotnet_naming_style.camel_case_and_prefix_with_s_underscore_style.capitalization                      = camel_case\n\ndotnet_naming_style.camel_case_and_prefix_with_underscore_style.required_prefix                       = _\ndotnet_naming_style.camel_case_and_prefix_with_underscore_style.capitalization                        = camel_case\n\ndotnet_naming_style.pascal_case_and_prefix_with_I_style.required_prefix                               = I\ndotnet_naming_style.pascal_case_and_prefix_with_I_style.capitalization                                = pascal_case\n\n\n# CSharp code style settings:\n[*.cs]\n# Modifier order\ncsharp_preferred_modifier_order = public,private,protected,internal,static,extern,new,virtual,abstract,sealed,override,readonly,unsafe,volatile,async:suggestion\n\n# Code block\ncsharp_prefer_braces = false:none\n\n# Indentation preferences\ncsharp_indent_block_contents = true\ncsharp_indent_braces = false\ncsharp_indent_case_contents = true\ncsharp_indent_switch_labels = true\ncsharp_indent_labels = flush_left\n\n# Prefer \"var\" everywhere\ncsharp_style_var_for_built_in_types = true:suggestion\ncsharp_style_var_when_type_is_apparent = true:suggestion\ncsharp_style_var_elsewhere = true:suggestion\n\n# Code style defaults\ncsharp_preserve_single_line_blocks = true\ncsharp_preserve_single_line_statements = true\n\n# Prefer method-like constructs to have a block body\ncsharp_style_expression_bodied_methods = false:none\ncsharp_style_expression_bodied_constructors = false:none\ncsharp_style_expression_bodied_operators = false:none\n\n# Prefer property-like constructs to have an expression-body\ncsharp_style_expression_bodied_properties = true:none\ncsharp_style_expression_bodied_indexers = true:none\ncsharp_style_expression_bodied_accessors = true:none\n\n# Expression \ncsharp_prefer_simple_default_expression = true:suggestion\ncsharp_style_deconstructed_variable_declaration = true:suggestion\ncsharp_style_pattern_local_over_anonymous_function = true:suggestion\n\n# Pattern matching\ncsharp_style_pattern_matching_over_is_with_cast_check = true:suggestion\ncsharp_style_pattern_matching_over_as_with_null_check = true:suggestion\ncsharp_style_inlined_variable_declaration = true:suggestion\n\n# Null checking preferences\ncsharp_style_throw_expression = true:suggestion\ncsharp_style_conditional_delegate_call = true:suggestion\n\n# Newline settings\ncsharp_new_line_before_open_brace = all\ncsharp_new_line_before_else = true\ncsharp_new_line_before_catch = true\ncsharp_new_line_before_finally = true\ncsharp_new_line_before_members_in_object_initializers = true\ncsharp_new_line_before_members_in_anonymous_types = true\ncsharp_new_line_between_query_expression_clauses = true\n\n# Space preferences\ncsharp_space_after_cast = false\ncsharp_space_after_colon_in_inheritance_clause = true\ncsharp_space_after_comma = true\ncsharp_space_after_dot = false\ncsharp_space_after_keywords_in_control_flow_statements = true\ncsharp_space_after_semicolon_in_for_statement = true\ncsharp_space_around_binary_operators = before_and_after\ncsharp_space_around_declaration_statements = do_not_ignore\ncsharp_space_before_colon_in_inheritance_clause = true\ncsharp_space_before_comma = false\ncsharp_space_before_dot = false\ncsharp_space_before_open_square_brackets = false\ncsharp_space_before_semicolon_in_for_statement = false\ncsharp_space_between_empty_square_brackets = false\ncsharp_space_between_method_call_empty_parameter_list_parentheses = false\ncsharp_space_between_method_call_name_and_opening_parenthesis = false\ncsharp_space_between_method_call_parameter_list_parentheses = false\ncsharp_space_between_method_declaration_empty_parameter_list_parentheses = false\ncsharp_space_between_method_declaration_name_and_open_parenthesis = false\ncsharp_space_between_method_declaration_parameter_list_parentheses = false\ncsharp_space_between_parentheses = false\ncsharp_space_between_square_brackets = false\n\n# Primary constructors\n# We find these something of a mixed bag.\ndotnet_diagnostic.IDE0290.severity = none"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.4716796875,
          "content": "# Auto detect text files and perform LF normalization\n* text=auto\n\n# Custom for Visual Studio\n*.cs     diff=csharp\n*.sln    merge=union\n*.csproj merge=union\n*.vbproj merge=union\n*.fsproj merge=union\n*.dbproj merge=union\n\n# Standard to msysgit\n*.doc\t diff=astextplain\n*.DOC\t diff=astextplain\n*.docx diff=astextplain\n*.DOCX diff=astextplain\n*.dot  diff=astextplain\n*.DOT  diff=astextplain\n*.pdf  diff=astextplain\n*.PDF\t diff=astextplain\n*.rtf\t diff=astextplain\n*.RTF\t diff=astextplain\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 2.5849609375,
          "content": "Ix.NET/Layout\nIx.NET/Layout\nRx.NET/Layout\n\n\n*.pydevproject\n.project\n.metadata\nbin/\ntmp/\n*.tmp\n*.bak\n*.swp\n*~.nib\nlocal.properties\n.classpath\n.settings/\n.loadpath\n*.exe\n.store/\n\n*.binlog\n\n# External tool builders\n.externalToolBuilders/\n\n# Locally stored \"Eclipse launch configurations\"\n*.launch\n\n# CDT-specific\n.cproject\n\n# PDT-specific\n.buildpath\n\n_NCrunch*\n\n#################\n## Visual Studio\n#################\n\n## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n\n# User-specific files\n*.suo\n*.user\n*.sln.docstates\n\n# Build results\n[Dd]ebug/\n[Rr]elease/\n*_i.c\n*_p.c\n*.ilk\n*.meta\n*.obj\n*.pch\n*.pdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.vspscc\n.builds\n*.dotCover\n\n## TODO: If you have NuGet Package Restore enabled, uncomment this\npackages/\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opensdf\n*.sdf\n\n# Visual Studio profiler\n*.psess\n*.vsp\n\n# ReSharper is a .NET coding add-in\n_ReSharper*\n\n# Installshield output folder\n[Ee]xpress\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish\n\n# Others\n[Bb]in\n[Oo]bj\nsql\nTestResults\n*.Cache\nClientBin\nstylecop.*\n~$*\n*.dbmdl\n.vs/\n*.lock.json\nartifacts/\nGenerated_Code #added for RIA/Silverlight projects\nApiApprovalTests.*.received.txt\ncoverlet/\n\n# Backup & report files from converting an old project file to a newer\n# Visual Studio version. Backup files are not needed, because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\nUpgradeLog*.htm\n\n\n############\n## Windows\n############\n\n# Windows image file caches\nThumbs.db\n\n# Folder config file\nDesktop.ini\n\n\n#############\n## Python\n#############\n\n*.py[co]\n\n# Packages\n*.egg\n*.egg-info\ndist\nbuild\neggs\nparts\nbin\nvar\nsdist\ndevelop-eggs\n.installed.cfg\n\n# Installer logs\npip-log.txt\n\n# Unit test / coverage reports\n.coverage\n.tox\n\n#Translations\n*.mo\n\n#Mr Developer\n.mr.developer.cfg\n\n# Mac crap\n.DS_Store\nRx.NET/Source/Rx.sln.ide/\nIx.NET/Source/Interactive Extensions.sln.ide/\nRx.NET/tools/HomoIcon/HomoIcon.sln.ide/\nRx.NET/Test/Rx/packages/\nRx.NET/Samples/Portable/Portable.sln.ide/\nRx.NET/Samples/Portable/packages/\n\n*.nupkg\n*.nuget.props\n*.nuget.targets\nnuget.exe\n\n# dotnet local cache\n.dotnet\n\n# JetBrains Rider adds these\n.idea/\n\n# Local NCrunch settings\n*.v3.ncrunchproject\n*.v3.ncrunchsolution\n/Rx.NET/Source/.NCrunch_*/StoredText\n\n# Windows Store app package directories and files\nAppPackages/\nBundleArtifacts/\nPackage.StoreAssociation.xml\n_pkginfo.txt\n*.appx\n"
        },
        {
          "name": "AUTHORS.txt",
          "type": "blob",
          "size": 0.59375,
          "content": "List of contributors to the Rx libraries\n\nRx and Ix.NET:\nWes Dyer\nJeffrey van Gogh\t\nMatthew Podwysocki \nBart De Smet\t\t\nDanny van Velzen\nErik Meijer\nBrian Beckman\nAaron Lahman\nGeorgi Chkodrov\nArthur Watson\nGert Drapers\nMark Shields\nEric Rozell\nClaire Novotny\nGeoffrey Huntley\nDavid Karnok\nDaniel C. Weber\n\n\nRx.js and Ix.js:\nMatthew Podwysocki\nJeffrey van Gogh\nBart De Smet\nBrian Beckman\nWes Dyer\nErik Meijer\n\nTx:\nGeorgi Chkodrov\nBart De Smet\t\t\nAaron Lahman\nErik Meijer\nBrian Grunkemeyer\nBeysim Sezgin\nTiho Tarnavski\nCollin Meek\nSajay Anthony\nKaren Albrecht\nJohn Allen\nZach Kramer\n\nRx++ and Ix++:\nAaron Lahman\n"
        },
        {
          "name": "AsyncRx.NET",
          "type": "tree",
          "content": null
        },
        {
          "name": "CODE-OF-CONDUCT.md",
          "type": "blob",
          "size": 0.2529296875,
          "content": "# Code of Conduct\n\nThis project has adopted the code of conduct defined by the Contributor Covenant\nto clarify expected behavior in our community.\n\nFor more information, see the [.NET Foundation Code of Conduct](https://dotnetfoundation.org/code-of-conduct).\n"
        },
        {
          "name": "Ix.NET",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.08984375,
          "content": "The MIT License (MIT)\n\nCopyright (c) .NET Foundation and Contributors\n\nAll rights reserved.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 18.564453125,
          "content": "﻿Reactive Extensions\n======================\n\nThis repository contains four libraries which are conceptually related in that they are all concerned with LINQ over sequences of things:\n\n* [Reactive Extensions for .NET](Rx.NET/) aka Rx.NET or Rx ([System.Reactive](https://www.nuget.org/packages/System.Reactive/)): a library for event-driven programming with a composable, declarative model\n* [AsyncRx.NET](AsyncRx.NET/) (experimental preview) ([System.Reactive.Async](https://www.nuget.org/packages/System.Reactive.Async)): experimental implementation of Rx for `IAsyncObservable<T>` offering deeper `async`/`await` support\n* [Interactive Extensions for .NET](Ix.NET/), aka Ix ([System.Interactive](https://www.nuget.org/packages/System.Interactive/)): extended LINQ operators for `IAsyncEnumerable` and `IEnumerable`\n* [LINQ for `IAsyncEnumerable`](./Ix.NET/Source/System.Linq.Async/) ([System.Linq.Async](https://www.nuget.org/packages/System.Linq.Async/)): implements standard LINQ operators for `IAsyncEnumerable`\n\nEach will be described later in this README.\n\n## FREE Introduction to Rx.NET 2nd Edition eBook\n\n<a href=\"https://introtorx.com/\"><img align=\"left\" alt=\"Introduction to Rx.NET 2nd Edition book cover.\" src=\"Rx.NET/Resources/Artwork/title_page_sm.png\"/></a>\n\nReactive programming provides clarity when our code needs to respond to events. The Rx.NET libraries were designed to enable cloud-native applications to process live data in reliable, predictable ways.\n\nWe've written a FREE book which explains the vital abstractions that underpin Rx, and shows how to exploit the powerful and extensive functionality built into the Rx.NET libraries. \n\nBased on Lee Campbell's 2010 book (kindly donated to the project), it has been re-written to bring it up to date with Rx.NET v6.0, .NET 8.0, and modern cloud native use cases such as IoT and real-time stream data processing.\n\nIntroduction to Rx.NET is available [Online](https://introtorx.com/), [on GitHub](Rx.NET/Documentation/IntroToRx/), as [PDF](https://endjincdn.blob.core.windows.net/assets/ebooks/introduction-to-rx-dotnet/introduction-to-rx-dotnet-2nd-edition.pdf), and [EPUB](https://endjincdn.blob.core.windows.net/assets/ebooks/introduction-to-rx-dotnet/introduction-to-rx-dotnet-2nd-edition.epub).\n\n<br clear=\"left\"/>\n\n## Getting the bits\n\nChannel  | Rx | AsyncRx | Ix | System.Linq.Async\n--- | --- | --- | --- |--- |\nNuGet.org | [![#](https://img.shields.io/nuget/v/System.Reactive.svg)](https://www.nuget.org/packages/System.Reactive/)| [![#](https://img.shields.io/nuget/v/System.Reactive.Async.svg)](https://www.nuget.org/packages/System.Reactive.Async/) | [![#](https://img.shields.io/nuget/v/System.Interactive.svg)](https://www.nuget.org/packages/System.Interactive/) | [![#](https://img.shields.io/nuget/v/System.Linq.Async.svg)](https://www.nuget.org/packages/System.Linq.Async/)\nNuGet.org preview (if newer than release) | [![#](https://img.shields.io/nuget/vpre/System.Reactive.svg)](https://www.nuget.org/packages/System.Reactive/) | [![#](https://img.shields.io/nuget/vpre/System.Reactive.Async.svg)](https://www.nuget.org/packages/System.Reactive.Async/) | [![#](https://img.shields.io/nuget/vpre/System.Interactive.svg)](https://www.nuget.org/packages/System.Interactive/) | [![#](https://img.shields.io/nuget/vpre/System.Linq.Async.svg)](https://www.nuget.org/packages/System.Linq.Async/)\nBuild | [![Build Status](https://dev.azure.com/dotnet/Rx.NET/_apis/build/status/Rx.NET-CI?branchName=main)](https://dev.azure.com/dotnet/Rx.NET/_build/latest?definitionId=9) | [![Build Status](https://dev.azure.com/dotnet/Rx.NET/_apis/build/status/AsyncRx.NET-CI?branchName=main)](https://dev.azure.com/dotnet/Rx.NET/_build/latest?definitionId=191) | [![Build Status](https://dev.azure.com/dotnet/Rx.NET/_apis/build/status/Ix.NET-CI?branchName=main)](https://dev.azure.com/dotnet/Rx.NET/_build/latest?definitionId=28) | Built as part of Ix\n[Azure<br>Artifacts](https://dev.azure.com/dotnet/Rx.NET/_packaging?_a=feed&feed=RxNet) | [![System.Reactive package in RxNet feed in Azure Artifacts](https://azpkgsshield.azurevoodoo.net/dotnet/Rx.NET/RxNet/System.Reactive)](https://dev.azure.com/dotnet/Rx.NET/_packaging?_a=package&feed=5afc77bd-23b4-46f8-b725-40ebedab630c&package=3c02dce4-f7e9-43ec-a014-28ea9fc46f82&preferRelease=true) | [![System.Reactive.Async package in RxNet feed in Azure Artifacts](https://azpkgsshield.azurevoodoo.net/dotnet/Rx.NET/RxNet/System.Reactive.Async)](https://dev.azure.com/dotnet/Rx.NET/_artifacts/feed/RxNet/NuGet/System.Reactive.Async/&preferRelease=true) | [![System.Interactive package in RxNet feed in Azure Artifacts](https://azpkgsshield.azurevoodoo.net/dotnet/Rx.NET/RxNet/System.Interactive)](https://dev.azure.com/dotnet/Rx.NET/_packaging?_a=package&feed=5afc77bd-23b4-46f8-b725-40ebedab630c&package=a3311bc0-c6ea-4460-bea8-b65d633e2583&preferRelease=true) | [![System.Linq.Async package in RxNet feed in Azure Artifacts](https://azpkgsshield.azurevoodoo.net/dotnet/Rx.NET/RxNet/System.Linq.Async)](https://dev.azure.com/dotnet/Rx.NET/_artifacts/feed/RxNet/NuGet/System.Linq.Async/&preferRelease=true)\nRelease history | [ReleaseHistory](Rx.NET/Documentation/ReleaseHistory/) | [ReleaseHistory](Ix.NET/Documentation/ReleaseHistory/)| [ReleaseHistory](Ix.NET/Documentation/ReleaseHistory/)\n\nFor nightly builds, configure NuGet to use this feed: `https://pkgs.dev.azure.com/dotnet/Rx.NET/_packaging/RxNet/nuget/v3/index.json`\n\n### Join the conversation\n\nCatch us in the #rxnet channel over at https://reactivex.slack.com/\n\n## A Brief Introduction to Rx\n\nIn this digital age, live data streams are ubiquitous. Financial applications depend on a swift response to timely information. Computer networks have always been able to provide extensive information about their health and operation. Utility companies such as water providers have vast numbers of devices monitoring their operations. User interface and game building frameworks report user interactions in great detail. Delivery vans continuously report their progress. Aircraft provide performance telemetry to detect potential maintenance issues before they become serious problems, and cars are now starting to do the same. Many of us wear or carry devices that track our physical activity and even [vital signs](https://www.youtube.com/watch?v=6yjl_h7-WYA&t=2443s). And the improvements in machine learning have enriched the insights that can be derived from the ever-increasing volume and variety of live data.\n\nBut despite being so widespread, live information streams have always been something of a second class citizen. Almost all programming languages have some innate way to work with lists of data (e.g., arrays), but these mechanisms tend to presume that the relevant data is already sitting in memory, ready for us to work with it. What's missing is the liveness—the fact that an information source might produce new data at any moment, on its own schedule.\n\nRx elevates the support for live streams of information to the same level as we expect for things like arrays. Here's an example:\n\n```cs\nvar bigTrades =\n    from trade in trades\n    where trade.Volume > 1_000_000\n    select trade;\n```\n\nThis uses C#'s LINQ feature to filter `trades` down to those entities with a volume greater than one million. This query expression syntax is just a shorthand for method calls, so we could also write it this way:\n\n```cs\nvar bigTrades = trades.Where(trade => trade.Volume > 1_000_000);\n```\n\nThe exact behaviour of these two (equivalent) code snippets depends on what type `trades` has. If it were a `IEnumerable<Trade>`, then this query would just iterate through the list, and `bigTrades` would be an enumerable sequence containing just the matching objects. If `trades` were an object representing a database table (e.g., an [Entity Framework](https://learn.microsoft.com/en-us/ef/core/) [DbSet](https://learn.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbset-1), this would be translated into a database query. But if we're using Rx, `trades` would be an `IObservable<Trade>`, an object reporting live events as they happen. And `bigTrades` would also be an `IObservable<Trade>`, reporting only those trades with a volume over a million. We can provide Rx with a callback to be invoked each time an observable source has something for us:\n\n```cs\nbigTrades.Subscribe(t => Console.WriteLine($\"{t.Symbol}: trade with volume {t.Volume}\"));\n```\n\nThe two key features of Rx are:\n\n* a clearly defined way to represent and handle live sequences of data ([`IObservable<T>`](https://learn.microsoft.com/en-us/dotnet/api/system.iobservable-1))\n* a set of operators (such as the `Where` operator just shown) enabling event processing logic to be expressed declaratively\n\nRx has been particularly successfully applied in user interfaces. (This is also true outside of .NET—[RxJS](https://rxjs.dev/) is a JavaScript spin-off of Rx, and it is very popular in user interface code.) The https://github.com/reactiveui/reactiveui makes deep use of Rx to support .NET UI development.\n\nIan Griffiths presented a concise 60 minute overview of [Reactive Extensions for .NET](https://endjin.com/what-we-think/talks/reactive-extensions-for-dotnet) at the dotnetsheff meetup in 2020. More videos are available on the [Rx playlist](https://www.youtube.com/playlist?list=PLJt9xcgQpM60Fz20FIXBvj6ku4a7WOLGb).\n\n## AsyncRx.Net\n\nAlthough Rx is a natural way to model asynchronous processes, its original design presumed that code acting on notifications would run synchronously. This is because Rx's design predates C#'s `async`/`await` language features. So although Rx offer adapters that can convert between [`IObservable<T>`](https://learn.microsoft.com/en-us/dotnet/api/system.iobservable-1) and [`Task<T>`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task-1), there were certain cases where `async` was not an option.\n\nAsyncRx.Net lifts this restriction by defining `IAsyncObservable<T>`. This enables observers to use asynchronous code. For example, if `bigTrades` were an `IAsyncObservable<Trade>` we could write this:\n\n```cs\nbigTrades.Subscribe(async t => await bigTradeStore.LogTradeAsync(t));\n```\n\nAsyncRx.Net is currently in preview.\n\n## Interactive Extensions\n\nRx defines all the standard LINQ operators available for other providers, but it also adds numerous additional operators. For example, it defines `Scan`, which performs the same basic processing as the standard [`Aggregate`](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.aggregate) operator, but instead of producing a single result after processing every element, it produces a sequence containing the aggregated value after every single step. (For example, if the operation being aggregated is addition, `Aggregate` would return the sum total as a single output, whereas `Scan` would produce a running total for each input. Given a sequence `[1,2,3]`, `Aggregate((a, x) => a + x)` produces just `6`, whereas `Scan` would produce `[1,3,6]`.)\n\nSome of the additional operators Rx defines are useful only when you're working with events. But some are applicable to sequences of any kind. So the Interactive Extensions (Ix for short) define implementations for `IEnumerable<T>`. Ix is effectively an extension of LINQ to Objects, adding numerous additional operators. (Its usefulness is borne out by the fact that the .NET runtime libraries have, over time, added some of the operators that used to be available only in Ix. For example, .NET 6 added [`MinBy`](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.minby) and [`MaxBy`](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.maxby), operators previously only defined by Ix.)\n\nThis library is called the \"Interactive Extensions\" because \"Interactive\" is in a sense the opposite of \"Reactive\". (The name does not refer to user interactions.)\n\n## LINQ for `IAsyncEnumerable` (`System.Linq.Async`)\n\nOne of the features pioneered by Ix was an asynchronous version of `IEnumerable<T>`. This is another example of a feature so useful that it was eventually added to the .NET runtime libraries: .NET Core 3.0 introduced [`IAsyncEnumerable<T>`](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.iasyncenumerable-1), and the associated version C# (8.0) added intrinsic support for this interface with its `await foreach` construct.\n\nAlthough .NET Core 3.0 defined `IAsyncEnumerable<T>`, it did not add any corresponding LINQ implementation. Whereas [`IEnumerable<T>` supports all the standard operators](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable) such as `Where`, `GroupBy`, and `SelectMany`, .NET does not have built-in implementations of any of these for `IAsyncEnumerable<T>`. However, Ix had provided LINQ operators for its prototype version of `IAsyncEnumerable<T>` from the start, so when .NET Core 3.0 shipped, it was a relatively straightforward task to update all those existing LINQ operators to work with the new, official [`IAsyncEnumerable<T>`](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.iasyncenumerable-1).\n\nThus, the [System.Linq.Async](https://www.nuget.org/packages/System.Linq.Async/) NuGet package was created, providing a LINQ to Objects implementation for `IAsyncEnumerable<T>` to match the one already built into .NET for `IEnumerable<T>`.\n\nSince all of the relevant code was already part of the Ix project (with `IAsyncEnumerable<T>` also originally having been defined by this project), the [System.Linq.Async](https://www.nuget.org/packages/System.Linq.Async/) NuGet package is built as part of the [Ix project](Ix.NET/).\n\n\n\n## Contributing\n\nSome of the best ways to contribute are to try things out, file bugs, and join in design conversations.\n\n* Clone the sources: `git clone https://github.com/dotnet/reactive`\n* [Building, testing and debugging the sources](https://github.com/dotnet/reactive/wiki/Building%20Testing%20and%20Debugging)\n* [How to Contribute](https://github.com/dotnet/reactive/wiki/Contributing-Code)\n* [Pull requests](https://github.com/dotnet/reactive/pulls): [Open](https://github.com/dotnet/reactive/pulls?q=is%3Aopen+is%3Apr)/[Closed](https://github.com/dotnet/reactive/pulls?q=is%3Apr+is%3Aclosed)\n\nLooking for something to work on? The list of [up for grabs issues](https://github.com/dotnet/reactive/issues?q=is%3Aopen+is%3Aissue+label%3A%22Up+for+Grabs%22) is a great place to start.\n\nThis project has adopted a code of conduct adapted from the [Contributor Covenant](http://contributor-covenant.org/) to clarify expected behavior in our community. This code of conduct has been [adopted by many other projects](http://contributor-covenant.org/adopters/). For more information see the [Code of conduct](http://www.dotnetfoundation.org/code-of-conduct).\n\n## .NET Foundation\n\nThis project is part of the [.NET Foundation](http://www.dotnetfoundation.org/projects) along with other\nprojects like [the .NET Runtime](https://github.com/dotnet/runtime/). The .NET Foundation provides this project with DevOps infrastructure to compile, test, sign and package this complex solution which has over 100 million downloads. It also provides conservatorship enabling the project to pass from maintainer to maintainer, enabling continuity for the community.\n\n## Current Core Team\n\nThe people currently maintaining Rx are:\n\n<table>\n  <tbody>\n    <tr>\n      <td align=\"center\" valign=\"top\">\n        <img width=\"150\" height=\"150\" src=\"https://github.com/idg10.png?s=150\">\n        <br>\n        <a href=\"https://github.com/idg10\">Ian Griffiths</a>\n        <p>Hove, UK</p>\n        <p><a href=\"https://endjin.com/who-we-are/our-people/ian-griffiths/\">Ian's blog on endjin.com</a>\n      </td>\n      <td align=\"center\" valign=\"top\">\n        <img width=\"150\" height=\"150\" src=\"https://github.com/HowardvanRooijen.png?s=150\">\n        <br>\n        <a href=\"https://github.com/HowardvanRooijen\">Howard van Rooijen</a>\n        <p>Winchester, UK</p>\n        <p><a href=\"https://endjin.com/who-we-are/our-people/howard-van-rooijen/\">Howard's blog on endjin.com</a>\n      </td>\n  </tbody>\n</table>\n\nRx has been around for roughly a decade and a half, so we owe a great deal to its creators, and the many people who have worked on it since. See the [AUTHORS.txt](AUTHORS.txt) for a full list.\n\n## Roadmap\n\nAs part of .NET Conf 2023, Ian Griffiths provided an update on the efforts to [modernize Rx.NET for v6.0 and the plans to for v7.0](https://endjin.com/what-we-think/talks/modernizing-reactive-extensions-for-dotnet). \n\nFor more information, see the following discussions:\n\n- [Future Rx.NET Packaging](https://github.com/dotnet/reactive/discussions/2038)\n- [Rx.NET v6.0 & v7.0 high-level plan](https://github.com/dotnet/reactive/discussions/1868)\n\nWe have set out a [roadmap](Rx.NET/Documentation/Rx-Roadmap-2023.md) explaining our medium term plans for ongoing development of Rx. This diagram illustrates our view of the platforms on which Rx is used, and the planned support lifecycles for these various targets:\n\n![The support lifecycle for various .NET platforms, represented as a set of timelines, showing the published plans for widely used versions that are current as of 2023, with a particular focus on which versions will be current as of November 2023. The top section of the diagram shows .NET releases starting with .NET 6.0 being released in November 2021, and shows for each subsequent release occurring in November of each subsequent year, up as far as .NET 13.0 in November 2028. It also shows that even-numbered releases are Long Term Support (LTS for short) releases, supported for 3 years, while odd-numbered releases are supported only for 18 months. The section beneath this shows that .NET Framework versions 4.7.2, 4.8.0, and 4.8.1 will all be in support as of November 2023, and will continue to be in support beyond the timescale covered by this diagram, i.e., beyond November 2028. The section beneath this shows the release plan for MAUI, starting with version 8.0 on November 2023, and subsequent releases at the same time each subsequent year, up to version 13.0 in November 2028. The diagram shows that each of these versions is supported for only 18 months. Beneath this is are two lines showing Xamarin iOS 16.0, and Xamarin Android 13.0 support being active on November 2023, and running for 18 months. Beneath this is a line showing UWP version 10.0.16299 support being active on November 2023, and running beyond the timescale covered by the diagram. Beneath this is a section showing that Unity 2021 was released in 2021, and will go out of support near the end of 2023, and it shows a Unity 2022 release labelled as \"Release soon,\" with a release date somewhere in the middle of 2023. The bottom of the diagram shows the endjin logo, and endjin's corporate motto: \"we help small teams achieve big things.\"](Rx.NET/Documentation/RX-Platform-Support-Roadmap.png \".NET Platform Support Roadmap\")\n"
        },
        {
          "name": "Rx.NET",
          "type": "tree",
          "content": null
        },
        {
          "name": "azure-pipelines.asyncrx.yml",
          "type": "blob",
          "size": 3.5693359375,
          "content": "trigger:\n  branches:\n    include:\n      - main\n      - rel/*\n  paths:\n    include:\n      - AsyncRx.NET/*\n      - .editorconfig\n      - azure-pipelines.asyncrx.yml\n\npr:\n  branches:\n    include:\n    - main\n    - rel/*\n  paths:\n    include:\n      - AsyncRx.NET/*\n      - .editorconfig\n      - azure-pipelines.asyncrx.yml\n\nstages:\n- stage: Build\n  jobs:\n  - job: Build\n    pool:\n      vmImage: windows-latest\n\n    variables:\n      BuildConfiguration: Release\n      BuildPlatform: Any CPU\n      DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true\n\n    steps:\n    - task: UseDotNet@2\n      displayName: Use .NET Core 7.0.x SDK\n      inputs:\n        version: 7.0.x\n        performMultiLevelLookup: true\n\n    - task: DotNetCoreCLI@2\n      inputs:\n        command: custom\n        custom: tool\n        arguments: install --tool-path . nbgv\n      displayName: Install NBGV tool\n\n    - script: nbgv cloud -a -p AsyncRx.NET\n      displayName: Set Version\n\n    - task: MSBuild@1\n      displayName: Build AsyncRx.NET.sln\n      inputs:\n        solution: AsyncRx.NET/AsyncRx.NET.sln\n        msbuildArguments: /restore /t:build /p:CreatePackage=true /p:NoPackageAnalysis=true /p:PackageOutputPath=$(Build.ArtifactStagingDirectory)\\artifacts\n        configuration: $(BuildConfiguration)\n        maximumCpuCount: false\n\n    - task: DotNetCoreCLI@2\n      inputs:\n        command: custom\n        custom: tool\n        arguments: install --tool-path . dotnet-reportgenerator-globaltool\n      displayName: Install ReportGenerator tool\n\n    # Normally we'd run tests here, but AsyncRx.NET doesn't have any yet!\n    # Once we're ready to stablize, we'd also add API surface area tests too\n  \n    - publish:  AsyncRx.NET/build\n      artifact: config\n      displayName: Publish signing config\n\n    - publish: $(Build.ArtifactStagingDirectory)\\artifacts\n      displayName: Publish artifacts\n      artifact: BuildPackages\n\n# Rx.NET has an IntegrationTests stage. Consider this once we have tests\n\n- stage: CodeSign\n  # In Rx, the condition includes:\n  #   succeeded('IntegrationTests')\n  condition: not(eq(variables['build.reason'], 'PullRequest'))\n  jobs:\n  - deployment: CodeSign\n    displayName: Code Signing\n    pool:\n      vmImage: windows-latest\n    environment: Code Sign\n    variables:\n    - group: SignClient Credentials\n    strategy:\n      runOnce:\n        deploy:\n          steps:\n\n          - task: UseDotNet@2\n            displayName: Use .NET 8.0.x SDK\n            inputs:\n              version: 8.0.x\n              performMultiLevelLookup: true\n\n          - task: DotNetCoreCLI@2\n            displayName: Install SignTool tool\n            inputs:\n              command: custom\n              custom: tool\n              arguments: install --tool-path . sign --version 0.9.1-beta.24406.1\n\n          - task: AzureCLI@2\n            inputs:\n              azureSubscription: 'Rx.NET Sign Service Connection'\n              scriptType: pscore\n              scriptLocation: inlineScript\n              inlineScript: |\n                .\\sign code azure-key-vault `\n                \"**/*.nupkg\" `\n                --base-directory \"$(Pipeline.Workspace)\\BuildPackages\" `\n                --publisher-name \"Reactive Extensions for .NET (.NET Foundation)\" `\n                --description \"AsyncRx.NET\" `\n                --description-url \"https://github.com/dotnet/reactive\" `\n                --azure-key-vault-url \"$(SignKeyVaultUrl)\" `\n                --azure-key-vault-certificate \"$(SignKeyVaultCertificateName)\"\n            displayName: Sign packages\n\n          - publish: $(Pipeline.Workspace)/BuildPackages\n            displayName: Publish Signed Packages\n            artifact: SignedPackages\n"
        },
        {
          "name": "azure-pipelines.ix.yml",
          "type": "blob",
          "size": 4.837890625,
          "content": "trigger:\n  branches:\n    include:\n      - main\n      - rel/*\n  paths:\n    include:\n      - Ix.NET/Source/*\n      - .editorconfig\n      - azure-pipelines.ix.yml\n\npr:\n  branches:\n    include:\n      - main\n      - rel/*\n  paths:\n    include:\n      - Ix.NET/Source/*\n      - .editorconfig\n      - azure-pipelines.ix.yml\n\nvariables:\n  BuildConfiguration: Release\n  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true\n\nstages:\n- stage: Build\n  jobs:\n  - job: Build\n    pool:\n      vmImage: ubuntu-latest\n    steps:\n    - task: UseDotNet@2\n      displayName: Use .NET Core 8.x SDK\n      inputs:\n        version: 8.x\n\n    - task: UseDotNet@2\n      displayName: .NET 6.0 runtime\n      inputs:\n        version: '6.x'\n        packageType: runtime\n\n    - task: UseDotNet@2\n      displayName: .NET Core 3.1 runtime\n      inputs:\n        version: '3.1.x'\n        packageType: runtime\n\n    - task: DotNetCoreCLI@2\n      inputs:\n        command: custom\n        custom: tool\n        arguments: install --tool-path . nbgv\n      displayName: Install NBGV tool\n\n    - script: ./nbgv cloud -p Ix.NET/Source\n      displayName: Set Version\n\n    - task: DotNetCoreCLI@2\n      inputs:\n        command: restore\n        projects: Ix.NET/Source/**/*.csproj\n      displayName: Restore\n\n    # Since we can no longer use MSBuild.Extras.SDK, the reference assembly projects don't get built automatically\n    # when the corresponding main project run, so we need this extra build step to ensure that the files exist by\n    # the time pack runs\n    - task: DotNetCoreCLI@2\n      inputs:\n        command: build\n        arguments: -c $(BuildConfiguration)\n        projects: Ix.NET/Source/refs/**/*.csproj\n      displayName: Build reference assemblies\n\n    - task: DotNetCoreCLI@2\n      inputs:\n        command: pack\n        packagesToPack: Ix.NET/Source/**/System.Interactive*.csproj;Ix.NET/Source/**/System.Linq.*.csproj;!Ix.NET/Source/**/*.Tests*.csproj;!Ix.NET/Source/refs/**\n        configuration: $(BuildConfiguration)\n        packDirectory: $(Build.ArtifactStagingDirectory)/artifacts\n        verbosityPack: Minimal\n      displayName: Pack\n\n    - task: DotNetCoreCLI@2\n      inputs:\n        command: custom\n        custom: tool\n        arguments: install --tool-path . dotnet-reportgenerator-globaltool\n      displayName: Install ReportGenerator tool\n\n    - task: DotNetCoreCLI@2\n      inputs:\n        command: test\n        projects: Ix.NET/Source/**/*.Tests.csproj\n        arguments: -c $(BuildConfiguration) --settings Ix.NET/Source/CodeCoverage.runsettings --collect:\"XPlat Code Coverage\" -- RunConfiguration.DisableAppDomain=true\n      displayName: Run Tests\n\n    - script: ./reportgenerator -reports:$(Agent.TempDirectory)/**/coverage.cobertura.xml -targetdir:$(Build.SourcesDirectory)/Ix.NET/Source/coverlet/reports -reporttypes:\"Cobertura\"\n      displayName: Create reports\n\n    - task: PublishCodeCoverageResults@1\n      displayName: 'Publish code coverage'\n      inputs:\n        codeCoverageTool: Cobertura\n        summaryFileLocation: $(Build.SourcesDirectory)/Ix.NET/Source/coverlet/reports/Cobertura.xml\n\n    - publish:  Ix.NET/Source/build\n      artifact: config\n      displayName: Publish signing config\n\n    - publish: $(Build.ArtifactStagingDirectory)/artifacts\n      displayName: Publish artifacts\n      artifact: BuildPackages\n\n- stage: CodeSign\n  condition: and(succeeded('Build'), not(eq(variables['build.reason'], 'PullRequest')))\n  jobs:\n  - deployment: CodeSign\n    displayName: Code Signing\n    pool:\n      vmImage: windows-latest\n    environment: Code Sign\n    variables:\n    - group: SignClient Credentials\n    strategy:\n      runOnce:\n        deploy:\n          steps:\n\n          - task: UseDotNet@2\n            displayName: Use .NET 8.0.x SDK\n            inputs:\n              version: 8.0.x\n              performMultiLevelLookup: true\n\n          - task: DotNetCoreCLI@2\n            displayName: Install SignTool tool\n            inputs:\n              command: custom\n              custom: tool\n              arguments: install --tool-path . sign --version 0.9.1-beta.24406.1\n\n          - task: AzureCLI@2\n            inputs:\n              azureSubscription: 'Rx.NET Sign Service Connection'\n              scriptType: pscore\n              scriptLocation: inlineScript\n              inlineScript: |\n                .\\sign code azure-key-vault `\n                \"**/*.nupkg\" `\n                --base-directory \"$(Pipeline.Workspace)\\BuildPackages\" `\n                --publisher-name \"Reactive Extensions for .NET (.NET Foundation)\" `\n                --description \"Ix.NET\" `\n                --description-url \"https://github.com/dotnet/reactive\" `\n                --azure-key-vault-url \"$(SignKeyVaultUrl)\" `\n                --azure-key-vault-certificate \"$(SignKeyVaultCertificateName)\"\n            displayName: Sign packages\n\n          - publish: $(Pipeline.Workspace)/BuildPackages\n            displayName: Publish Signed Packages\n            artifact: SignedPackages\n"
        },
        {
          "name": "azure-pipelines.rx.yml",
          "type": "blob",
          "size": 9.181640625,
          "content": "trigger:\n  branches:\n    include:\n      - main\n      - rel/*\n  paths:\n    include:\n      - Rx.NET/Source/*\n      - .editorconfig\n      - azure-pipelines.rx.yml\n\npr:\n  branches:\n    include:\n    - main\n    - rel/*\n  paths:\n    include:\n      - Rx.NET/Source/*\n      - .editorconfig\n      - azure-pipelines.rx.yml\n\nstages:\n- stage: Build\n  jobs:\n  - job: Build\n    pool:\n      vmImage: windows-latest\n\n    variables:\n      BuildConfiguration: Release\n      BuildPlatform: Any CPU\n      DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true\n\n    steps:\n    - task: UseDotNet@2\n      displayName: Use .NET 8.0.x SDK\n      inputs:\n        version: 8.0.x\n        performMultiLevelLookup: true\n\n    # We need .NET 7.0 and 6.0 to be able to run all tests.\n    # For .NET 7.0, the runtime package is sufficient because we don't need to build anything.\n    # That doesn't work for 6.0, because we need the desktop framework, and the only way to\n    # get that into a build agent seems to be to install the SDK.\n    - task: UseDotNet@2\n      displayName: Use .NET 7.0 runtime\n      inputs:\n        version: '7.0.x'\n        packageType: runtime\n\n    - task: UseDotNet@2\n      displayName: Use .NET 6.0 SDK\n      inputs:\n        version: '6.0.x'\n\n    - task: DotNetCoreCLI@2\n      inputs:\n        command: custom\n        custom: tool\n        arguments: install --tool-path . nbgv\n      displayName: Install NBGV tool\n\n    - script: nbgv cloud -a -p Rx.NET/Source\n      displayName: Set Version\n\n    - task: MSBuild@1\n      displayName: Build System.Reactive.sln\n      inputs:\n        solution: Rx.NET/Source/System.Reactive.sln\n        msbuildArguments: /restore /t:build /p:CreatePackage=true /p:NoPackageAnalysis=true /p:PackageOutputPath=$(Build.ArtifactStagingDirectory)\\artifacts\n        configuration: $(BuildConfiguration)\n        maximumCpuCount: false\n\n    - task: NuGetCommand@2\n      displayName: Pack compatibility package\n      inputs:\n        command: custom\n        arguments: pack Rx.NET/Source/facades/System.Reactive.Compatibility.nuspec -Version $(NBGV_NuGetPackageVersion) -MinClientVersion 2.12 -NoPackageAnalysis -outputdirectory $(Build.ArtifactStagingDirectory)\\artifacts\n\n    - task: DotNetCoreCLI@2\n      inputs:\n        command: custom\n        custom: tool\n        arguments: install --tool-path . dotnet-reportgenerator-globaltool\n      displayName: Install ReportGenerator tool\n\n    - task: DotNetCoreCLI@2\n      inputs:\n        command: test\n        projects: Rx.NET/Source/tests/Tests.System.Reactive/*.csproj\n        arguments: -c $(BuildConfiguration) --filter \"TestCategory!=SkipCI\" --settings Rx.NET/Source/CodeCoverage.runsettings --collect:\"XPlat Code Coverage\" -- RunConfiguration.DisableAppDomain=true\n      displayName: Run Unit Tests\n\n    - task: DotNetCoreCLI@2\n      inputs:\n        command: test\n        projects: Rx.NET/Source/tests/Tests.System.Reactive.ApiApprovals/Tests.System.Reactive.ApiApprovals.csproj\n        arguments: -c $(BuildConfiguration)\n      displayName: Run Api Approvals Tests\n\n    - script: reportgenerator -reports:$(Agent.TempDirectory)/**/coverage.cobertura.xml -targetdir:$(Build.SourcesDirectory)/Rx.NET/Source/coverlet/reports -reporttypes:\"Cobertura\"\n      displayName: Create reports\n\n    - task: PublishCodeCoverageResults@1\n      displayName: 'Publish code coverage'\n      inputs:\n        codeCoverageTool: Cobertura\n        summaryFileLocation: $(Build.SourcesDirectory)/Rx.NET/Source/coverlet/reports/Cobertura.xml\n\n    - publish:  Rx.NET/Source/build\n      artifact: config\n      displayName: Publish signing config\n\n    - publish: $(Build.ArtifactStagingDirectory)\\artifacts\n      displayName: Publish artifacts\n      artifact: BuildPackages\n    \n    - publish: Rx.NET/Source/tests/Tests.System.Reactive.ApiApprovals/Api\n      displayName: Publish test artifiacts\n      artifact: ApprovalsTests\n      condition: always()\n\n- stage: IntegrationTests\n  jobs:\n  - job: Linux\n    pool:\n      vmImage: ubuntu-latest\n\n    variables:\n      BuildConfiguration: Release\n      BuildPlatform: Any CPU\n      DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true\n\n    steps:\n    - task: UseDotNet@2\n      inputs:\n        version: 8.0.x\n\n    - task: UseDotNet@2\n      displayName: Use .NET 7.0 SDK\n      inputs:\n        version: '7.0.x'\n        packageType: runtime\n\n    - task: UseDotNet@2\n      displayName: Use .NET 6.0 SDK\n      inputs:\n        version: '6.0.x'\n        packageType: runtime\n\n    - task: DotNetCoreCLI@2\n      inputs:\n        command: custom\n        custom: tool\n        arguments: install --tool-path . nbgv\n      displayName: Install NBGV tool\n\n    - script: ./nbgv cloud -a -p Rx.NET/Source\n      displayName: Set Version\n\n    - task: DownloadPipelineArtifact@2\n      displayName: Download Build Artifacts\n      inputs:\n        artifactName: BuildPackages\n        targetPath: $(System.DefaultWorkingDirectory)/Rx.NET/Integration/LocalPackages\n\n    - task: DotNetCoreCLI@2\n      displayName: Update Rx\n      inputs:\n        command: custom\n        projects: $(System.DefaultWorkingDirectory)/Rx.NET/Integration/LinuxTests/LinuxTests.csproj\n        custom: restore\n        arguments: --configfile $(System.DefaultWorkingDirectory)/Rx.NET/Integration/NuGet.Config\n\n    - task: DotNetCoreCLI@2\n      inputs:\n        command: test\n        projects: $(System.DefaultWorkingDirectory)/Rx.NET/Integration/LinuxTests/LinuxTests.csproj\n        arguments: -c $(BuildConfiguration) -f net8.0 --filter \"TestCategory!=SkipCI\"\n      displayName: Run 8.0 Tests on Linux\n\n    - task: DotNetCoreCLI@2\n      inputs:\n        command: test\n        projects: $(System.DefaultWorkingDirectory)/Rx.NET/Integration/LinuxTests/LinuxTests.csproj\n        arguments: -c $(BuildConfiguration) -f net7.0 --filter \"TestCategory!=SkipCI\"\n      displayName: Run 7.0 Tests on Linux\n\n    - task: DotNetCoreCLI@2\n      inputs:\n        command: test\n        projects: $(System.DefaultWorkingDirectory)/Rx.NET/Integration/LinuxTests/LinuxTests.csproj\n        arguments: -c $(BuildConfiguration) -f net6.0 --filter \"TestCategory!=SkipCI\"\n      displayName: Run 6.0 Tests on Linux\n\n  - job: WindowsDesktop    \n    pool:\n      vmImage: windows-latest\n\n    variables:\n      BuildConfiguration: Release\n      BuildPlatform: Any CPU\n      DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true\n\n    steps:\n    - task: UseDotNet@2\n      inputs:\n        version: 8.0.x\n        performMultiLevelLookup: true\n\n    - task: UseDotNet@2\n      displayName: Use .NET 7.0 SDK\n      inputs:\n        version: '7.0.x'\n\n    - task: UseDotNet@2\n      displayName: Use .NET 6.0 SDK\n      inputs:\n        version: '6.0.x'\n\n    - task: DotNetCoreCLI@2\n      inputs:\n        command: custom\n        custom: tool\n        arguments: install --tool-path . nbgv\n      displayName: Install NBGV tool\n\n    - script: nbgv cloud -a -p Rx.NET/Source\n      displayName: Set Version\n\n    - task: DownloadPipelineArtifact@2\n      displayName: Download Build Artifacts\n      inputs:\n        artifactName: BuildPackages\n        targetPath: $(System.DefaultWorkingDirectory)/Rx.NET/Integration/LocalPackages\n\n    - task: DotNetCoreCLI@2\n      displayName: Update Rx\n      inputs:\n        command: custom\n        projects: $(System.DefaultWorkingDirectory)/Rx.NET/Integration/WindowsDesktopTests/WindowsDesktopTests.csproj\n        custom: restore\n        arguments: --configfile $(System.DefaultWorkingDirectory)/Rx.NET/Integration/NuGet.Config\n\n    - task: DotNetCoreCLI@2\n      inputs:\n        command: test\n        projects: $(System.DefaultWorkingDirectory)/Rx.NET/Integration/WindowsDesktopTests/WindowsDesktopTests.csproj\n        arguments: -c $(BuildConfiguration) --filter \"TestCategory!=SkipCI\"\n      displayName: Run Tests on Window Desktop\n\n- stage: CodeSign\n  condition: and(succeeded('IntegrationTests'), not(eq(variables['build.reason'], 'PullRequest')))\n  jobs:\n  - deployment: CodeSign\n    displayName: Code Signing\n    pool:\n      vmImage: windows-latest\n    environment: Code Sign\n    variables:\n    - group: SignClient Credentials\n    strategy:\n      runOnce:\n        deploy:\n          steps:\n\n          - task: UseDotNet@2\n            displayName: Use .NET 8.0.x SDK\n            inputs:\n              version: 8.0.x\n              performMultiLevelLookup: true\n\n          - task: DotNetCoreCLI@2\n            displayName: Install SignTool tool\n            inputs:\n              command: custom\n              custom: tool\n              arguments: install --tool-path . sign --version 0.9.1-beta.24406.1\n\n          # Run the signing command\n\n          - task: AzureCLI@2\n            inputs:\n              azureSubscription: 'Rx.NET Sign Service Connection'\n              scriptType: pscore\n              scriptLocation: inlineScript\n              inlineScript: |\n                .\\sign code azure-key-vault `\n                \"**/*.nupkg\" `\n                --base-directory \"$(Pipeline.Workspace)\\BuildPackages\" `\n                --publisher-name \"Reactive Extensions for .NET (.NET Foundation)\" `\n                --description \"Rx.NET\" `\n                --description-url \"https://github.com/dotnet/reactive\" `\n                --azure-key-vault-url \"$(SignKeyVaultUrl)\" `\n                --azure-key-vault-certificate \"$(SignKeyVaultCertificateName)\"\n            displayName: Sign packages\n\n          - publish: $(Pipeline.Workspace)/BuildPackages\n            displayName: Publish Signed Packages\n            artifact: SignedPackages\n"
        }
      ]
    }
  ]
}