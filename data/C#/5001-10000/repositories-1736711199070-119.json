{
  "metadata": {
    "timestamp": 1736711199070,
    "page": 119,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "dotnet-state-machine/stateless",
      "stars": 5687,
      "defaultBranch": "dev",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0654296875,
          "content": "# Auto detect text files and perform LF normalization\n\n* text=auto\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.134765625,
          "content": "bin\nobj\nStateless.userprefs\n*.user\n\n# Visual Studio 2015 cache/options directory\n.vs/\n\nproject.lock.json\nartifacts/\nTestResult.xml\n*.orig\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 13.4052734375,
          "content": "# Changelog\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](http://keepachangelog.com/en/1.0.0/)\nand this project adheres to [Semantic Versioning](http://semver.org/spec/v2.0.0.html).\n\n## 5.17.0 - 2024.12.30\n### Changed\n - Use `PackageLicenseExpression` in csproj file [#583], [#584]\n### Added\n - Added mermaid graph support [#585]\n - Allow PermitDynamic destination state to be calculated with an async function (Task) [#595]\n - Updated readme to clarify re-entry behaviour of dynamic transitions [#604]\n - Added .NET 9.0 to build targets [#610]\n### Fixed\n - Unexpected graph labels for internal transitions [#587]\n - Labels not escaped in `UmlDotGraphStyle` [#597]\n\n## 5.16.0 - 2024.05.24\n### Changed\n - Permit state reentry from dynamic transitions [#565]\n   - This is a change in behavior from v5.15.0 (see [#544]); this version restores the previous behavior for `PermitDynamic` that allows reentry;\n     if reentry is not the desired behavior, consider using a guard condition with `PermitDynamicIf`.\n - Remove getDestination, and use Destination property instead (internal refactor) [#575]\n### Added\n - Add overloads to `FireAsync` to support parameterized trigger arguments [#570]\n - Add overloads to `CanFire` to support parameterized trigger arguments [#574]\n### Fixed\n - Prevent `NullReferenceException` in the `InvocationInfo` class [#566]\n\n## 5.15.0 - 2023.12.29\n### Changed\n - Updated net6.0 build target to net8.0 [#551]\n - New abstract method, `GetInitialTransition`, added to `GraphStyleBase` to remove DOT graph implementation from `StateGraph` [#557]\n   - Classes that are derived from `GraphStyleBase` and are being migrated from an earlier release of Stateless will need to implement this method.\n### Added\n - Added license information and README file to NuGet package [#539], [#553]\n\n## 5.14.0 - 2023.11.14\n### Added\n - Enable Source Link & Deterministic Builds [#501]\n - Added optional `RetainSynchronizationContext` property [#519]\n - Update example apps to `net6.0` [#520]\n - Bump solution Visual Studio version to 2022 [#526]\n - Remove obsolete TargetFrameworks [#524]\n - Added `FireAsync(TriggerWithParameters, params object[])` overload [#536]\n### Fixed\n - `StateMachineInfo.InitialState.Transitions` throws if `AddRelationships` not called [#514]\n - Trigger information is missing for `OnEntryFromAsync` [#511]\n - Fixed typos & redundant parentheses [#512], [#521], [#522]\n - Change mechanism for losing the synchronization context [#528]\n - `InvalidOperationException` thrown from call to `FireAsync` [#532]\n - Added missing guard function parameter support from `InternalTransitionAsyncIf` [#530]\n - Using `PermitIf` on a state with substates leads to reentry [#544]\n\n## 5.13.0 - 2022.12.29\n### Added\n - Add method to get permitted triggers with parameter information [#494]\n### Fixed\n - Fix incorrect initial state in dotgraph after trigger fired [#495]\n\n## 5.12.0 - 2022.10.17\n### Added\n - Add explicit .NET 6.0 framework support [#479]\n - Stateless.Tests -> .NET 6 [#484]\n - Update Readme regarding state machine events [#488]\n### Fixed\n - Typo in summary comment of class UmlDotGraph [#471]\n - Github workflows/dotnet pack: Fix project path casing and directory separators [#478]\n - Hardcode the AssemblyName attribute in the .csproj to \"Stateless\" [#480]\n### Security\n - Bump Newtonsoft.Json from 10.0.3 to 13.0.1 in /example/JsonExample [#487]\n\n## 5.11.0 - 2021.04.28\n### Added\n - Added CanFire overload to return unmet guard descriptions [#443]\n### Fixed\n - Inconsistency in sync/async statemachine execution [#444]\n - Added support for spaces in state/trigger names in Graphviz node graphs by wrapping them in escaped quotes [#447]\n\n## 5.10.1\nRe-releasing 5.2.0 as v5.10.1.\nThe version number was accidentally set to 5.10 when creating the 5.2 release.\nVersion 5.10.0 is now listed as the newest, since it has the highest version number.\n5.2.0 and 5.10.0 are identical.\n\n## 5.2.0\n### Added\n - Added support for net50\n### Changed\n - Only run tests under net50\n - Non-code change: Switch to using Github Actions\n### Fixed\n - Fixed the bug \"IgnoreIf Guard description is raised when PermitReentryIf Guard Fails\". [#422]\n\n## 5.1.8\n### Fixed\n- Fixed bug \"When adding .PermitDynamicIf, call .PermitTriggers throw NullReferenceException\" [#416]\n\n## 5.1.7 - 2021.01.10\n### Fixed\n - Fixed nullReferenceException when getting permitted triggers on a dynamic transition. [#413]\n\n## 5.1.7 - 2021.01.10\n### Fixed\n - Fixed OnTransitionCompletedEvent, it now has the correct Destination state when there is an initial transition. [#413]\n\n## 5.1.6 - 2020.11.21\n### Fixed\n - Added support for new OnTransitionCompletedEvent, which is run after all OnExit / OnEntry methods have run [#394]\n\n## 5.1.5 - 2020.11.16\n### Changed\n - Fixed spelling errors\n - Fixed analyser warnings (mostly null checks)\n### Fixed\n - Added CLSCompliant attribute, which went missing in November 2019 [#401]\n\n## 5.1.4 - 2020.11.07\n### Fixed\n - Fixed Unmet guard collection not set by OnUnhandledTrigger if transition guard of substate fails [#398] (Thanks to the awesome DeepakParamkusam)\n \n## 5.1.3 - 2020.08.12\n### Fixed\n - Fixed ambiguos guard function call when trigger is a state [#380]\n \n## 5.1.2 - 2020.04.27\n### Fixed\n - Fixed wrong onTransitionEvent ordering in Async firing [#372]\n\n## [5.1.1] - 2020.04.03\n### Changed\n- Inverted if (_firingMode.Equals(FiringMode.Immediate) into if (FiringMode.Immediate.Equals(_firingMode) to avoid VerificationException  when including assembly AllowPartiallyTrustedCallers [#365].\n\n## [5.1.0] - 2020.03.24\n### Added\n- Added missing possible destination states to all PermitDynamic and PermitDynamicIf, see issue [#305].\n\n### Fixed\n- Fixed trigger execution order issue if there are uncaught exceptions. Ref issue [#267]\n- Fixed issue #272 and #275. Triggers with no parameters threw exceptions when checking if they could be fired, or retrieved with GetPermittedTriggers.\n\n## [5.0.1] - 2020.03.13\n### Fixed\n- Added missing initial transition, see PR #286.\n\n## [5.0.0] - 2020.02.28\n### Changed\n- Activate and deactivate actions only runs on manual call to Activate / Deactivate. This breaks the v4.4 implementation, where activate/deactivate actions are run on every state transition.\n\n## [4.4.0] - 2020.02.07\n### Changed\n- PR #348 Added trigger parameters to OnTransitioned event\n### Fixed\n- #342 StateMutator is called multiple times with the same state \n- #345 Wrong behavior with FiringMode.Immediate in version 4.3.0\n- #339 OnEntry behavour different: Unit test broken when updated to 4.3.0 from 4.2.1\n- #292 Nested InitialTransitions calls superstate onEntry twice\n\n## [4.3.0] - 2019.11.11\n### Changed\n- Netstandard2.0 support\n\n## [4.2.0] - 2018.06.01\n### Added\n - PR #254 Add initial transitions\n### Changed\n- Simplified examples a bit and added comments \n### Fixed\n- #261 Reentrant trigger in substate causes exit action to be executed twice\n- #263 NullReferenceException bug introduced in commit c13e181b\n\n## [4.1.0] - 2018-05-18\n### Added\n - #246 Queuing should not be the default behavior\n### Fixed\n - #191 Shouldn't Reentry fire OnEntry from substate?\n - #228 guard function called twice?\n - #214 Transition object holds parent state as source state instead of child\n - #249 Latest prerelease v4.0.1-dev-00294 bug (Internal transition handler not executing)\n\n## [4.0.0] - 2017-09-30\n### Added\n - #169 HTML format DOT graph output\n - #132 Conditional InternalTransition\n - #130 Support InternalTransition for all TriggerWithParams  \n### Changed\n - #178 Replace calls to Enforce.ArgumentNotNull with in-place null checks, and other changes suggested by CodeCracker\n - #168 Modified the output of OnUnmute to display the correct message\n - #164 Reducing confusion, and fixing invalid cast in Reflection.  \n - #158 Create new ActionInfo class, start insinuating it\n - #156 TriggerInfo.Value -> UnderlyingTrigger  \n - #149 Moved StateType and TriggerType into StateMachineInfo, removed TriggerInfo\n - #147 Extracting common abstract base class for transition info\n - #142 Further reflection API refinement\n - #141 Update to RTM dotnet tooling/VS2017\n - #137 Replace magic string usages with nameof()\n - #125 Adding check for cyclic configuration\n - #123 Update for the current .NET Core version  \n \n\n### Deprecated\n### Removed\n### Fixed\n - #175 Fix Multiple internal transition actions executed if defined in state hierarchy, and Renamed DynamicTransitionInfo.Destination to DestinationDescription  \n - #144 Fix unbounded recursion/fully initialize sub/super-states\n - #140 Adding recursive trigger processing to InternalFireAsync  \n\n## [3.1.0] - 2016-12-15\n### Added\n### Changed\n### Deprecated\n### Removed\n### Fixed\n\n## [3.0.1] - 2016-11-23\n### Added\n### Changed\n### Deprecated\n### Removed\n### Fixed\n\n## [3.0.0] - 2016-11-03\n### Added\n### Changed\n### Deprecated\n### Removed\n### Fixed\n\n## Release template - version and date goes here\n### Added\n### Changed\n### Deprecated\n### Removed\n### Fixed\n\n[#610]: https://github.com/dotnet-state-machine/stateless/pull/610\n[#604]: https://github.com/dotnet-state-machine/stateless/issues/604\n[#597]: https://github.com/dotnet-state-machine/stateless/pull/597\n[#595]: https://github.com/dotnet-state-machine/stateless/pull/595\n[#587]: https://github.com/dotnet-state-machine/stateless/pull/589\n[#585]: https://github.com/dotnet-state-machine/stateless/issues/585\n[#584]: https://github.com/dotnet-state-machine/stateless/pull/584\n[#583]: https://github.com/dotnet-state-machine/stateless/pull/583\n[#575]: https://github.com/dotnet-state-machine/stateless/pull/575\n[#574]: https://github.com/dotnet-state-machine/stateless/pull/574\n[#570]: https://github.com/dotnet-state-machine/stateless/pull/570\n[#566]: https://github.com/dotnet-state-machine/stateless/pull/566\n[#565]: https://github.com/dotnet-state-machine/stateless/issues/565\n[#551]: https://github.com/dotnet-state-machine/stateless/pull/551\n[#557]: https://github.com/dotnet-state-machine/stateless/issues/557\n[#553]: https://github.com/dotnet-state-machine/stateless/issues/553\n[#539]: https://github.com/dotnet-state-machine/stateless/issues/539\n[#501]: https://github.com/dotnet-state-machine/stateless/pull/501\n[#519]: https://github.com/dotnet-state-machine/stateless/pull/519\n[#520]: https://github.com/dotnet-state-machine/stateless/pull/520\n[#526]: https://github.com/dotnet-state-machine/stateless/pull/526\n[#524]: https://github.com/dotnet-state-machine/stateless/pull/524\n[#536]: https://github.com/dotnet-state-machine/stateless/pull/536\n[#514]: https://github.com/dotnet-state-machine/stateless/pull/514\n[#511]: https://github.com/dotnet-state-machine/stateless/pull/511\n[#522]: https://github.com/dotnet-state-machine/stateless/pull/522\n[#521]: https://github.com/dotnet-state-machine/stateless/pull/521\n[#512]: https://github.com/dotnet-state-machine/stateless/pull/512\n[#528]: https://github.com/dotnet-state-machine/stateless/pull/528\n[#532]: https://github.com/dotnet-state-machine/stateless/pull/532\n[#530]: https://github.com/dotnet-state-machine/stateless/pull/530\n[#544]: https://github.com/dotnet-state-machine/stateless/pull/544\n[#494]: https://github.com/dotnet-state-machine/stateless/pull/494\n[#495]: https://github.com/dotnet-state-machine/stateless/pull/495\n[#479]: https://github.com/dotnet-state-machine/stateless/pull/479\n[#484]: https://github.com/dotnet-state-machine/stateless/pull/484\n[#488]: https://github.com/dotnet-state-machine/stateless/pull/488\n[#471]: https://github.com/dotnet-state-machine/stateless/pull/471\n[#478]: https://github.com/dotnet-state-machine/stateless/pull/478\n[#480]: https://github.com/dotnet-state-machine/stateless/pull/480\n[#487]: https://github.com/dotnet-state-machine/stateless/pull/487\n[#443]: https://github.com/dotnet-state-machine/stateless/pull/443\n[#444]: https://github.com/dotnet-state-machine/stateless/issues/444\n[#447]: https://github.com/dotnet-state-machine/stateless/pull/447\n[#422]: https://github.com/dotnet-state-machine/stateless/issues/422\n[#416]: https://github.com/dotnet-state-machine/stateless/issues/416\n[#413]: https://github.com/dotnet-state-machine/stateless/issues/413\n[#394]: https://github.com/dotnet-state-machine/stateless/issues/394\n[#401]: https://github.com/dotnet-state-machine/stateless/issues/401\n[#398]: https://github.com/dotnet-state-machine/stateless/issues/398\n[#380]: https://github.com/dotnet-state-machine/stateless/issues/380\n[#373]: https://github.com/dotnet-state-machine/stateless/issues/372\n[#365]: https://github.com/dotnet-state-machine/stateless/pull/365\n[#272]: https://github.com/dotnet-state-machine/stateless/issues/272\n[#275]: https://github.com/dotnet-state-machine/stateless/issues/275\n[#267]: https://github.com/dotnet-state-machine/stateless/issues/267\n[#305]: https://github.com/dotnet-state-machine/stateless/issues/305\n[4.2.0]: https://github.com/dotnet-state-machine/stateless/commit/8933fe58a3d2ab63bdf47f523df0b9639cd65c97\n[4.1.0]: https://github.com/dotnet-state-machine/stateless/compare/bb742e8d40ceaacb219695875dfe38670ac77e28...daef9cb2897e18f25e85dd27fb80e549369bdfac\n[4.0.0]: https://github.com/dotnet-state-machine/stateless/compare/23624d88e684d9984e5b5fdbc3d4aba601bdd1a4...bb742e8d40ceaacb219695875dfe38670ac77e28\n[3.1.0]: https://github.com/dotnet-state-machine/stateless/compare/6aa544c6a5e22b93fbe206513d79e15a3e2ef172...23624d88e684d9984e5b5fdbc3d4aba601bdd1a4\n[3.0.1]: https://github.com/dotnet-state-machine/stateless/compare/6c44d2ae69f67606b5d979b2f0e353adccb1913c...6aa544c6a5e22b93fbe206513d79e15a3e2ef172\n[3.0.0]: https://github.com/dotnet-state-machine/stateless/compare/4d4cc84bad583eaf8f983edc351179cef40bd093...6c44d2ae69f67606b5d979b2f0e353adccb1913c\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.9912109375,
          "content": "# Contributing to Stateless\n\nIf you're reading this page, thank you for considering making a contribution to Stateless! This project depends on the work of the community. As maintainers, we'll try our best to make bug fixes, review PRs, and respond to issues and feature requests.\n\n## Getting Started\n\nIf you've found a bug, need a new feature or want to suggest a change, be sure to take a look through the [issues](https://github.com/dotnet-state-machine/stateless/issues?q=is%3Aissue) and [pull requests](https://github.com/dotnet-state-machine/stateless/pulls) in case it's been discussed before or is already in progress.\n\nIf you've found a security vulnerability, please report it using the [Security Advisories](https://github.com/dotnet-state-machine/stateless/security/advisories) page.\n\nFor anyone new to contributing to open source, there are some great guides to help you get started, such as [this one by freeCodeCamp.org](https://github.com/freeCodeCamp/how-to-contribute-to-open-source) and [this one from Open Source Guides](https://opensource.guide/how-to-contribute/).\n\n## General Guidance\n\nIt's best to start by discussing a proposed change in an [issue](https://github.com/dotnet-state-machine/stateless/issues), be it a new issue you've created or an existing issue you're willing to help with. Let others know you're working on it.\n\nCheck that your [fork is synced with the upsream repo](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/syncing-a-fork) before you start working on a change, then create a branch from it and commit your changes to that branch. When you're ready for the change to be reviewed, create a pull request to merge your change back to the upstream `dotnet-state-machine:dev` branch.\n\nPlease make sure your change meets the following criteria before raising a pull request:\n\n* Keep the change relevant to the specific issue being addressed; making changes that haven't been discussed could have unintended side effects.\n* Add unit test coverage for your work; this not only helps to validate that your change works as described, it also acts as documentation and helps to defend against future regressions.\n* Update the documentation! Help others benefit from your work by including guidance in the README.\n* Be open and encouraging to constructive feedback; reviewers may ask for further changes or may want to discuss alternative approaches; the project will benefit from your patience and your willingness to engage with reviewers.\n\n## Other Ways to Contribute\n\n* Participate in open discussions, for instance by helping to answer questions or offering guidance to others.\n* Improve the documentation, even something as small as fixing a typo or including a code snippet in the README; it all helps.\n* Review a pull request; take a look through the [open pull requests](https://github.com/dotnet-state-machine/stateless/pulls) and offer constructive feedback.\n* Boost the project; star the repository, mention it on social media, or link to it in your project's README.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.5458984375,
          "content": "Copyright 2025 Nicholas Blumhardt\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.70703125,
          "content": "# Stateless [![Build status](https://github.com/dotnet-state-machine/stateless/actions/workflows/BuildAndTestOnPullRequests.yml/badge.svg)](https://github.com/dotnet-state-machine/stateless/actions/workflows/BuildAndTestOnPullRequests.yml) [![NuGet Pre Release](https://img.shields.io/nuget/vpre/Stateless.svg)](https://www.nuget.org/packages/stateless) [![Join the chat at https://gitter.im/dotnet-state-machine/stateless](https://badges.gitter.im/dotnet-state-machine/stateless.svg)](https://gitter.im/dotnet-state-machine/stateless?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge) [![Stack Overflow](https://img.shields.io/badge/stackoverflow-tag-orange.svg)](http://stackoverflow.com/questions/tagged/stateless-state-machine)\n\n**Create *state machines* and lightweight *state machine-based workflows* directly in .NET code:**\n\n```csharp\nvar phoneCall = new StateMachine<State, Trigger>(State.OffHook);\n\nphoneCall.Configure(State.OffHook)\n    .Permit(Trigger.CallDialled, State.Ringing);\n\nphoneCall.Configure(State.Connected)\n    .OnEntry(t => StartCallTimer())\n    .OnExit(t => StopCallTimer())\n    .InternalTransition(Trigger.MuteMicrophone, t => OnMute())\n    .InternalTransition(Trigger.UnmuteMicrophone, t => OnUnmute())\n    .InternalTransition<int>(_setVolumeTrigger, (volume, t) => OnSetVolume(volume))\n    .Permit(Trigger.LeftMessage, State.OffHook)\n    .Permit(Trigger.PlacedOnHold, State.OnHold);\n\n// ...\n\nphoneCall.Fire(Trigger.CallDialled);\nAssert.AreEqual(State.Ringing, phoneCall.State);\n```\n\nThis project, as well as the example above, was inspired by [Simple State Machine (Archived)](https://web.archive.org/web/20170814020207/http://simplestatemachine.codeplex.com/).\n\n## Features\n\nMost standard state machine constructs are supported:\n\n * Generic support for states and triggers of any .NET type (numbers, strings, enums, etc.)\n * Hierarchical states\n * Entry/exit actions for states\n * Guard clauses to support conditional transitions\n * Introspection\n\nSome useful extensions are also provided:\n\n * Ability to store state externally (for example, in a property tracked by an ORM)\n * Parameterised triggers\n * Reentrant states\n * Export to DOT graph\n * Export to mermaid graph\n\n### Hierarchical States\n\n\nIn the example below, the `OnHold` state is a substate of the `Connected` state. This means that an `OnHold` call is still connected.\n\n```csharp\nphoneCall.Configure(State.OnHold)\n    .SubstateOf(State.Connected)\n    .Permit(Trigger.TakenOffHold, State.Connected)\n    .Permit(Trigger.PhoneHurledAgainstWall, State.PhoneDestroyed);\n```\n\nIn addition to the `StateMachine.State` property, which will report the precise current state, an `IsInState(State)` method is provided. `IsInState(State)` will take substates into account, so that if the example above was in the `OnHold` state, `IsInState(State.Connected)` would also evaluate to `true`.\n\n### Entry/Exit actions\n\nIn the example, the `StartCallTimer()` method will be executed when a call is connected. The `StopCallTimer()` will be executed when call completes (by either hanging up or hurling the phone against the wall.)\n\nThe call can move between the `Connected` and `OnHold` states without the `StartCallTimer()` and `StopCallTimer()` methods being called repeatedly because the `OnHold` state is a substate of the `Connected` state.\n\nEntry/Exit action handlers can be supplied with a parameter of type `Transition` that describes the trigger, source and destination states.\n\n### Internal transitions\n\nSometimes a trigger needs to be handled, but the state shouldn't change. This is an internal transition. Use `InternalTransition` for this.\n\n### Initial state transitions\n\nA substate can be marked as initial state. When the state machine enters the super state it will also automatically enter the substate. This can be configured like this:\n\n```csharp\n    sm.Configure(State.B)\n        .InitialTransition(State.C);\n\n    sm.Configure(State.C)\n        .SubstateOf(State.B);\n```\n\nDue to Stateless' internal structure, it does not know when it is \"started\". This makes it impossible to handle an initial transition in the traditional way. It is possible to work around this limitation by adding a dummy initial state, and then use Activate() to \"start\" the state machine.\n\n```csharp\n    sm.Configure(InitialState)\n        .OnActivate(() => sm.Fire(LetsGo))\n        .Permit(LetsGo, StateA)\n```\n\n\n### External State Storage\n\nStateless is designed to be embedded in various application models. For example, some ORMs place requirements upon where mapped data may be stored, and UI frameworks often require state to be stored in special \"bindable\" properties. To this end, the `StateMachine` constructor can accept function arguments that will be used to read and write the state values:\n\n```csharp\nvar stateMachine = new StateMachine<State, Trigger>(\n    () => myState.Value,\n    s => myState.Value = s);\n```\n\nIn this example the state machine will use the `myState` object for state storage.\n\nAnother example can be found in the JsonExample solution, located in the example folder. \n\n\n### Activation / Deactivation\n\nIt might be necessary to perform some code before storing the object state, and likewise when restoring the object state. Use `Deactivate` and `Activate` for this. Activation should only be called once before normal operation starts, and once before state storage. \n\n### Introspection\n\nThe state machine can provide a list of the triggers that can be successfully fired within the current state via the `StateMachine.PermittedTriggers` property. Use `StateMachine.GetInfo()` to retrieve information about the state configuration.\n\n### Guard Clauses\n\nThe state machine will choose between multiple transitions based on guard clauses, e.g.:\n\n```csharp\nphoneCall.Configure(State.OffHook)\n    .PermitIf(Trigger.CallDialled, State.Ringing, () => IsValidNumber)\n    .PermitIf(Trigger.CallDialled, State.Beeping, () => !IsValidNumber);\n```\n\nGuard clauses within a state must be mutually exclusive (multiple guard clauses cannot be valid at the same time.) Substates can override transitions by respecifying them, however substates cannot disallow transitions that are allowed by the superstate.\n\nThe guard clauses will be evaluated whenever a trigger is fired. Guards should therefore be made side effect free.\n\n### Parameterised Triggers\n\nStrongly-typed parameters can be assigned to triggers:\n\n```csharp\nvar assignTrigger = stateMachine.SetTriggerParameters<string>(Trigger.Assign);\n\nstateMachine.Configure(State.Assigned)\n    .OnEntryFrom(assignTrigger, email => OnAssigned(email));\n\nstateMachine.Fire(assignTrigger, \"joe@example.com\");\n```\n\nTrigger parameters can be used to dynamically select the destination state using the `PermitDynamic()` configuration method.\n\n### Ignored Transitions and Reentrant States\n\nIn Stateless, firing a trigger that does not have an allowed transition associated with it will cause an exception to be thrown. This ensures that all transitions are explicitly defined, preventing unintended state changes.\n\nTo ignore triggers within certain states, use the `Ignore(TTrigger)` directive:\n\n```csharp\nphoneCall.Configure(State.Connected)\n    .Ignore(Trigger.CallDialled);\n```\n\nAlternatively, a state can be marked reentrant. A reentrant state is one that can transition back into itself. In such cases, the state's exit and entry actions will be executed, providing a way to handle events that require the state to reset or reinitialize.\n\n```csharp\nstateMachine.Configure(State.Assigned)\n    .PermitReentry(Trigger.Assigned)\n    .OnEntry(() => SendEmailToAssignee());\n```\n\nBy default, triggers must be ignored explicitly. To override Stateless's default behaviour of throwing an exception when an unhandled trigger is fired, configure the state machine using the `OnUnhandledTrigger` method:\n\n```csharp\nstateMachine.OnUnhandledTrigger((state, trigger) => { });\n```\n\n### Dynamic State Transitions and State Re-entry\n\nDynamic state transitions allow the destination state to be determined at runtime based on trigger parameters or other logic.\n\n```csharp\nstateMachine.Configure(State.Start)\n    .PermitDynamic(Trigger.CheckScore, () => score < 10 ? State.LowScore : State.HighScore);\n```\n\nWhen a dynamic transition results in the same state as the current state, it effectively becomes a reentrant transition, causing the state's exit and entry actions to execute. This can be useful for scenarios where the state needs to refresh or reset based on certain triggers.\n\n```csharp\nstateMachine.Configure(State.Waiting)\n    .OnEntry(() => Console.WriteLine($\"Elapsed time: {elapsed} seconds...\"))\n    .PermitDynamic(Trigger.CheckStatus, () => ready ? State.Done : State.Waiting);\n```\n\n### State change notifications (events)\n\nStateless supports 2 types of state machine events:\n * State transition\n * State machine transition completed\n\n#### State transition\n```csharp\nstateMachine.OnTransitioned((transition) => { });\n```\nThis event will be invoked every time the state machine changes state.\n\n#### State machine transition completed\n```csharp\nstateMachine.OnTransitionCompleted((transition) => { });\n```\nThis event will be invoked at the very end of the trigger handling, after the last entry action has been executed.\n\n### Export to DOT graph\n\nIt can be useful to visualize state machines on runtime. With this approach the code is the authoritative source and state diagrams are by-products which are always up to date.\n \n```csharp\nphoneCall.Configure(State.OffHook)\n    .PermitIf(Trigger.CallDialled, State.Ringing, IsValidNumber);\n    \nstring graph = UmlDotGraph.Format(phoneCall.GetInfo());\n```\n\nThe `UmlDotGraph.Format()` method returns a string representation of the state machine in the [DOT graph language](https://en.wikipedia.org/wiki/DOT_(graph_description_language)), e.g.:\n\n```dot\ndigraph {\n  OffHook -> Ringing [label=\"CallDialled [IsValidNumber]\"];\n}\n```\n\nThis can then be rendered by tools that support the DOT graph language, such as the [dot command line tool](http://www.graphviz.org/doc/info/command.html) from [graphviz.org](http://www.graphviz.org) or [viz.js](https://github.com/mdaines/viz.js). See http://www.webgraphviz.com for instant gratification.\nCommand line example: `dot -T pdf -o phoneCall.pdf phoneCall.dot` to generate a PDF file.\n\n### Export to Mermaid graph\n\nMermaid graphs can also be generated from state machines.\n \n```csharp\nphoneCall.Configure(State.OffHook)\n    .PermitIf(Trigger.CallDialled, State.Ringing);\n    \nstring graph = MermaidGraph.Format(phoneCall.GetInfo());\n```\n\nThe `MermaidGraph.Format()` method returns a string representation of the state machine in the [Mermaid](https://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting/creating-diagrams#creating-mermaid-diagrams), e.g.:\n\n```\nstateDiagram-v2\n     [*] --> OffHook\n    OffHook --> Ringing : CallDialled\n```\n\nThis can be rendered by GitHub markdown or an engine such as [Obsidian](https://github.com/obsidianmd).\n\n``` mermaid\nstateDiagram-v2\n     [*] --> OffHook\n    OffHook --> Ringing : CallDialled\n```\n\n### Async triggers\n\nOn platforms that provide `Task<T>`, the `StateMachine` supports `async` entry/exit actions and so on:\n\n```csharp\nstateMachine.Configure(State.Assigned)\n    .OnEntryAsync(async () => await SendEmailToAssignee());\n```\n\nAsynchronous handlers must be registered using the `*Async()` methods in these cases.\n\nTo fire a trigger that invokes asynchronous actions, the `FireAsync()` method must be used:\n\n```csharp\nawait stateMachine.FireAsync(Trigger.Assigned);\n```\n\n**Note:** while `StateMachine` may be used _asynchronously_, it remains single-threaded and may not be used _concurrently_ by multiple threads.\n\n## Advanced Features ##\n\n### Retaining the SynchronizationContext ###\nIn specific situations where all handler methods must be invoked with the consumer's `SynchronizationContext`, set the `RetainSynchronizationContext` property on creation:\n\n```csharp\nvar stateMachine = new StateMachine<State, Trigger>(initialState)\n{\n    RetainSynchronizationContext = true\n};\n```\n\nSetting this is vital within a Microsoft Orleans Grain for example, which requires the `SynchronizationContext` in order to make calls to other Grains.\n\n## Building\n\nStateless runs on .NET runtime version 4+ and practically all modern .NET platforms by targeting .NET Framework 4.6.2, .NET Standard 2.0 and .NET 8.0. Visual Studio 2017 or later is required to build the solution.\n\n\n## Contributing\n\nWe welcome contributions to this project. Check [CONTRIBUTING.md](CONTRIBUTING.md) for more info.\n\n\n## Project Goals\n\nThis page is an almost-complete description of Stateless, and its explicit aim is to remain minimal.\n\nPlease use the issue tracker or the Discussions page if you'd like to report problems or discuss features.\n\n(_Why the name? Stateless implements the set of rules regarding state transitions, but, at least when the delegate version of the constructor is used, doesn't maintain any internal state itself._)\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.3505859375,
          "content": "# Security Policy\n\n## Reporting a Vulnerability\n\nIf you discover a security vulnerability in Stateles, please report it via the [Security Advisories](https://github.com/dotnet-state-machine/stateless/security/advisories) page. Creating a security advistory will notify the project owners and allow them to assess it and take appropriate action to resolve it.\n"
        },
        {
          "name": "Stateless.sln",
          "type": "blob",
          "size": 5.6064453125,
          "content": "Microsoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio Version 17\nVisualStudioVersion = 17.4.33213.308\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"global\", \"global\", \"{8DE7A8AE-D87D-46A0-9757-88BA4AF7EDA5}\"\n\tProjectSection(SolutionItems) = preProject\n\t\t.gitattributes = .gitattributes\n\t\t.gitignore = .gitignore\n\t\tCHANGELOG.md = CHANGELOG.md\n\t\tLICENSE = LICENSE\n\t\tREADME.md = README.md\n\tEndProjectSection\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"src\", \"src\", \"{73DF639A-6E93-4F1C-9BF1-C9A0E7A37FFF}\"\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"asset\", \"asset\", \"{E443FF16-5964-44FE-9993-0E0BCE7D9DD3}\"\n\tProjectSection(SolutionItems) = preProject\n\t\tasset\\Stateless.png = asset\\Stateless.png\n\t\tasset\\Stateless.snk = asset\\Stateless.snk\n\t\tasset\\Stateless.svg = asset\\Stateless.svg\n\tEndProjectSection\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"test\", \"test\", \"{7806676C-8860-473E-950E-6C7E8D3490A0}\"\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"example\", \"example\", \"{45C09CCA-6C76-4E10-B386-5D95A7610FE0}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Stateless\", \"src\\Stateless\\Stateless.csproj\", \"{56053FAC-1555-457F-9F95-66A06B4F30C6}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Stateless.Tests\", \"test\\Stateless.Tests\\Stateless.Tests.csproj\", \"{6694F685-0229-4671-9B2D-667662C29F42}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"BugTrackerExample\", \"example\\BugTrackerExample\\BugTrackerExample.csproj\", \"{1E7BDA62-0BEF-49C4-BADF-F271755D3990}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"OnOffExample\", \"example\\OnOffExample\\OnOffExample.csproj\", \"{19ABDDFE-C040-404E-897B-37BE6C248ED7}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"TelephoneCallExample\", \"example\\TelephoneCallExample\\TelephoneCallExample.csproj\", \"{5182CA95-8E6F-4D16-9790-8F7D1C5A9C87}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"JsonExample\", \"example\\JsonExample\\JsonExample.csproj\", \"{809A7873-DD78-4D5D-A432-9718C929BECA}\"\nEndProject\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"AlarmExample\", \"example\\AlarmExample\\AlarmExample.csproj\", \"{4E44B325-F791-4C24-872B-D1454DBBA30D}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|Any CPU = Debug|Any CPU\n\t\tRelease|Any CPU = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{56053FAC-1555-457F-9F95-66A06B4F30C6}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{56053FAC-1555-457F-9F95-66A06B4F30C6}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{56053FAC-1555-457F-9F95-66A06B4F30C6}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{56053FAC-1555-457F-9F95-66A06B4F30C6}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{6694F685-0229-4671-9B2D-667662C29F42}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{6694F685-0229-4671-9B2D-667662C29F42}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{6694F685-0229-4671-9B2D-667662C29F42}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{6694F685-0229-4671-9B2D-667662C29F42}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{1E7BDA62-0BEF-49C4-BADF-F271755D3990}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{1E7BDA62-0BEF-49C4-BADF-F271755D3990}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{1E7BDA62-0BEF-49C4-BADF-F271755D3990}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{1E7BDA62-0BEF-49C4-BADF-F271755D3990}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{19ABDDFE-C040-404E-897B-37BE6C248ED7}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{19ABDDFE-C040-404E-897B-37BE6C248ED7}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{19ABDDFE-C040-404E-897B-37BE6C248ED7}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{19ABDDFE-C040-404E-897B-37BE6C248ED7}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{5182CA95-8E6F-4D16-9790-8F7D1C5A9C87}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{5182CA95-8E6F-4D16-9790-8F7D1C5A9C87}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{5182CA95-8E6F-4D16-9790-8F7D1C5A9C87}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{5182CA95-8E6F-4D16-9790-8F7D1C5A9C87}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{809A7873-DD78-4D5D-A432-9718C929BECA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{809A7873-DD78-4D5D-A432-9718C929BECA}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{809A7873-DD78-4D5D-A432-9718C929BECA}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{809A7873-DD78-4D5D-A432-9718C929BECA}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{4E44B325-F791-4C24-872B-D1454DBBA30D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{4E44B325-F791-4C24-872B-D1454DBBA30D}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{4E44B325-F791-4C24-872B-D1454DBBA30D}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{4E44B325-F791-4C24-872B-D1454DBBA30D}.Release|Any CPU.Build.0 = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(NestedProjects) = preSolution\n\t\t{56053FAC-1555-457F-9F95-66A06B4F30C6} = {73DF639A-6E93-4F1C-9BF1-C9A0E7A37FFF}\n\t\t{6694F685-0229-4671-9B2D-667662C29F42} = {7806676C-8860-473E-950E-6C7E8D3490A0}\n\t\t{1E7BDA62-0BEF-49C4-BADF-F271755D3990} = {45C09CCA-6C76-4E10-B386-5D95A7610FE0}\n\t\t{19ABDDFE-C040-404E-897B-37BE6C248ED7} = {45C09CCA-6C76-4E10-B386-5D95A7610FE0}\n\t\t{5182CA95-8E6F-4D16-9790-8F7D1C5A9C87} = {45C09CCA-6C76-4E10-B386-5D95A7610FE0}\n\t\t{809A7873-DD78-4D5D-A432-9718C929BECA} = {45C09CCA-6C76-4E10-B386-5D95A7610FE0}\n\t\t{4E44B325-F791-4C24-872B-D1454DBBA30D} = {45C09CCA-6C76-4E10-B386-5D95A7610FE0}\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {7A73ADDC-8150-4AFC-AAF0-BA8B4D7A94D7}\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "asset",
          "type": "tree",
          "content": null
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}