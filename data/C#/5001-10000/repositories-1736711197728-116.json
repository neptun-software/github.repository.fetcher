{
  "metadata": {
    "timestamp": 1736711197728,
    "page": 116,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "sta/websocket-sharp",
      "stars": 5780,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.138671875,
          "content": "## Ignore build results and temporary files.\n\nBackup*\n_UpgradeReport_Files\nbin\nobj\n\n*.mdb\n*.pdb\n*.pidb\n*.suo\n*.user\n*.userprefs\nUpgradeLog*.*\n"
        },
        {
          "name": "Example",
          "type": "tree",
          "content": null
        },
        {
          "name": "Example2",
          "type": "tree",
          "content": null
        },
        {
          "name": "Example3",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.0595703125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2010-2025 sta.blockhead\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 21.1474609375,
          "content": "![Logo](websocket-sharp_logo.png)\n\n## Welcome to websocket-sharp! ##\n\nwebsocket-sharp supports:\n\n- [RFC 6455](#supported-websocket-specifications)\n- [WebSocket Client](#websocket-client) and [Server](#websocket-server)\n- [Per-message Compression](#per-message-compression) extension\n- [Secure Connection](#secure-connection)\n- [HTTP Authentication](#http-authentication)\n- [Query string, Origin header, and Cookies](#query-string-origin-header-and-cookies)\n- [Connecting through the HTTP proxy server](#connecting-through-the-http-proxy-server)\n- .NET Framework **3.5** or later versions of .NET Framework (includes compatible environment such as [Mono])\n\n## Branches ##\n\n- [master] for production releases.\n- [hybi-00] for older [draft-ietf-hybi-thewebsocketprotocol-00]. No longer maintained.\n- [draft75] for even more old [draft-hixie-thewebsocketprotocol-75]. No longer maintained.\n\n## Build ##\n\nwebsocket-sharp is built as a single assembly, **websocket-sharp.dll**.\n\nwebsocket-sharp is developed with [MonoDevelop]. So a simple way to build is to open **websocket-sharp.sln** and run build for **websocket-sharp project** with any of the build configurations (e.g. `Debug`) in MonoDevelop.\n\n## Install ##\n\n### Self Build ###\n\nYou should add your websocket-sharp.dll (e.g. `/path/to/websocket-sharp/bin/Debug/websocket-sharp.dll`) to the library references of your project.\n\nIf you would like to use that dll in your [Unity] project, you should add it to any folder of your project (e.g. `Assets/Plugins`) in the **Unity Editor**.\n\n### NuGet Gallery ###\n\nwebsocket-sharp is available on the [NuGet Gallery], as still a **prerelease** version.\n\n- [NuGet Gallery: websocket-sharp]\n\nYou can add websocket-sharp to your project with the NuGet Package Manager, by using the following command in the Package Manager Console.\n\n    PM> Install-Package WebSocketSharp -Pre\n\n## Usage ##\n\n### WebSocket Client ###\n\n```csharp\nusing System;\nusing WebSocketSharp;\n\nnamespace Example\n{\n  public class Program\n  {\n    public static void Main (string[] args)\n    {\n      using (var ws = new WebSocket (\"ws://dragonsnest.far/Laputa\")) {\n        ws.OnMessage += (sender, e) =>\n                          Console.WriteLine (\"Laputa says: \" + e.Data);\n\n        ws.Connect ();\n        ws.Send (\"BALUS\");\n        Console.ReadKey (true);\n      }\n    }\n  }\n}\n```\n\n#### Step 1 ####\n\nRequired namespace.\n\n```csharp\nusing WebSocketSharp;\n```\n\nThe `WebSocket` class exists in the `WebSocketSharp` namespace.\n\n#### Step 2 ####\n\nCreating a new instance of the `WebSocket` class with the WebSocket URL to connect.\n\n```csharp\nvar ws = new WebSocket (\"ws://example.com\");\n```\n\nThe `WebSocket` class inherits the `System.IDisposable` interface, so you can create it with the `using` statement.\n\n```csharp\nusing (var ws = new WebSocket (\"ws://example.com\")) {\n  ...\n}\n```\n\nThis will **close** the WebSocket connection with status code `1001` (going away) when the control leaves the `using` block.\n\n#### Step 3 ####\n\nSetting the `WebSocket` events.\n\n##### WebSocket.OnOpen Event #####\n\nThis event occurs when the WebSocket connection has been established.\n\n```csharp\nws.OnOpen += (sender, e) => {\n               ...\n             };\n```\n\n`System.EventArgs.Empty` is passed as `e`, so you do not need to use it.\n\n##### WebSocket.OnMessage Event #####\n\nThis event occurs when the `WebSocket` instance receives a message.\n\n```csharp\nws.OnMessage += (sender, e) => {\n                  ...\n                };\n```\n\nA `WebSocketSharp.MessageEventArgs` instance is passed as `e`.\n\nIf you would like to get the message data, you should access `e.Data` or `e.RawData` property.\n\n`e.Data` property returns a `string`, so it is mainly used to get the **text** message data.\n\n`e.RawData` property returns a `byte[]`, so it is mainly used to get the **binary** message data.\n\n```csharp\nif (e.IsText) {\n  // Do something with e.Data.\n  ...\n\n  return;\n}\n\nif (e.IsBinary) {\n  // Do something with e.RawData.\n  ...\n\n  return;\n}\n```\n\nAnd if you would like to notify that a **ping** has been received, via this event, you should set the `WebSocket.EmitOnPing` property to `true`.\n\n```csharp\nws.EmitOnPing = true;\nws.OnMessage += (sender, e) => {\n                  if (e.IsPing) {\n                    // Do something to notify that a ping has been received.\n                    ...\n\n                    return;\n                  }\n                };\n```\n\n##### WebSocket.OnError Event #####\n\nThis event occurs when the `WebSocket` instance gets an error.\n\n```csharp\nws.OnError += (sender, e) => {\n                ...\n              };\n```\n\nA `WebSocketSharp.ErrorEventArgs` instance is passed as `e`.\n\nIf you would like to get the error message, you should access `e.Message` property.\n\n`e.Message` property returns a `string` that represents the error message.\n\nAnd `e.Exception` property returns a `System.Exception` instance that represents the cause of the error if it is due to an exception.\n\n##### WebSocket.OnClose Event #####\n\nThis event occurs when the WebSocket connection has been closed.\n\n```csharp\nws.OnClose += (sender, e) => {\n                ...\n              };\n```\n\nA `WebSocketSharp.CloseEventArgs` instance is passed as `e`.\n\nIf you would like to get the reason for the close, you should access `e.Code` or `e.Reason` property.\n\n`e.Code` property returns a `ushort` that represents the status code for the close.\n\n`e.Reason` property returns a `string` that represents the reason for the close.\n\n#### Step 4 ####\n\nConnecting to the WebSocket server.\n\n```csharp\nws.Connect ();\n```\n\nIf you would like to connect to the server asynchronously, you should use the `WebSocket.ConnectAsync ()` method.\n\n#### Step 5 ####\n\nSending data to the WebSocket server.\n\n```csharp\nws.Send (data);\n```\n\nThe `WebSocket.Send` method is overloaded.\n\nYou can use the `WebSocket.Send (string)`, `WebSocket.Send (byte[])`, `WebSocket.Send (System.IO.FileInfo)`, or `WebSocket.Send (System.IO.Stream, int)` method to send the data.\n\nIf you would like to send the data asynchronously, you should use the `WebSocket.SendAsync` method.\n\n```csharp\nws.SendAsync (data, completed);\n```\n\nAnd also if you would like to do something when the send is complete, you should set `completed` to any `Action<bool>` delegate.\n\n#### Step 6 ####\n\nClosing the WebSocket connection.\n\n```csharp\nws.Close (code, reason);\n```\n\nIf you would like to close the connection explicitly, you should use the `WebSocket.Close` method.\n\nThe `WebSocket.Close` method is overloaded.\n\nYou can use the `WebSocket.Close ()`, `WebSocket.Close (ushort)`, `WebSocket.Close (WebSocketSharp.CloseStatusCode)`, `WebSocket.Close (ushort, string)`, or `WebSocket.Close (WebSocketSharp.CloseStatusCode, string)` method to close the connection.\n\nIf you would like to close the connection asynchronously, you should use the `WebSocket.CloseAsync` method.\n\n### WebSocket Server ###\n\n```csharp\nusing System;\nusing WebSocketSharp;\nusing WebSocketSharp.Server;\n\nnamespace Example\n{\n  public class Laputa : WebSocketBehavior\n  {\n    protected override void OnMessage (MessageEventArgs e)\n    {\n      var msg = e.Data == \"BALUS\"\n                ? \"Are you kidding?\"\n                : \"I'm not available now.\";\n\n      Send (msg);\n    }\n  }\n\n  public class Program\n  {\n    public static void Main (string[] args)\n    {\n      var wssv = new WebSocketServer (\"ws://dragonsnest.far\");\n\n      wssv.AddWebSocketService<Laputa> (\"/Laputa\");\n      wssv.Start ();\n      Console.ReadKey (true);\n      wssv.Stop ();\n    }\n  }\n}\n```\n\n#### Step 1 ####\n\nRequired namespace.\n\n```csharp\nusing WebSocketSharp.Server;\n```\n\nThe `WebSocketBehavior` and `WebSocketServer` classes exist in the `WebSocketSharp.Server` namespace.\n\n#### Step 2 ####\n\nCreating the class that inherits the `WebSocketBehavior` class.\n\nFor example, if you would like to provide an echo service,\n\n```csharp\nusing System;\nusing WebSocketSharp;\nusing WebSocketSharp.Server;\n\npublic class Echo : WebSocketBehavior\n{\n  protected override void OnMessage (MessageEventArgs e)\n  {\n    Send (e.Data);\n  }\n}\n```\n\nAnd if you would like to provide a chat service,\n\n```csharp\nusing System;\nusing WebSocketSharp;\nusing WebSocketSharp.Server;\n\npublic class Chat : WebSocketBehavior\n{\n  private string _suffix;\n\n  public Chat ()\n  {\n    _suffix = String.Empty;\n  }\n\n  public string Suffix {\n    get {\n      return _suffix;\n    }\n\n    set {\n      _suffix = value ?? String.Empty;\n    }\n  }\n\n  protected override void OnMessage (MessageEventArgs e)\n  {\n    Sessions.Broadcast (e.Data + _suffix);\n  }\n}\n```\n\nYou can define the behavior of any WebSocket service by creating the class that inherits the `WebSocketBehavior` class.\n\nIf you override the `WebSocketBehavior.OnMessage (MessageEventArgs)` method, it will be called when the `WebSocket` used in a session in the service receives a message.\n\nAnd if you override the `WebSocketBehavior.OnOpen ()`, `WebSocketBehavior.OnError (ErrorEventArgs)`, and `WebSocketBehavior.OnClose (CloseEventArgs)` methods, each of them will be called when each of the `WebSocket` events (`OnOpen`, `OnError`, and `OnClose`) occurs.\n\nThe `WebSocketBehavior.Send` method can send data to the client on a session in the service.\n\nIf you would like to get the sessions in the service, you should access the `WebSocketBehavior.Sessions` property (returns a `WebSocketSharp.Server.WebSocketSessionManager`).\n\nThe `WebSocketBehavior.Sessions.Broadcast` method can send data to every client in the service.\n\n#### Step 3 ####\n\nCreating a new instance of the `WebSocketServer` class.\n\n```csharp\nvar wssv = new WebSocketServer (4649);\n\nwssv.AddWebSocketService<Echo> (\"/Echo\");\nwssv.AddWebSocketService<Chat> (\"/Chat\");\nwssv.AddWebSocketService<Chat> (\"/ChatWithNyan\", s => s.Suffix = \" Nyan!\");\n```\n\nYou can add any WebSocket service to your `WebSocketServer` with the specified behavior and absolute path to the service, by using the `WebSocketServer.AddWebSocketService<TBehavior> (string)` or `WebSocketServer.AddWebSocketService<TBehavior> (string, Action<TBehavior>)` method.\n\nThe type of `TBehavior` must inherit the `WebSocketBehavior` class, and must have a public parameterless constructor.\n\nSo you can use a class in the above Step 2 to add the service.\n\nIf you create a new instance of the `WebSocketServer` class without a port number, it sets the port number to **80**. So it is necessary to run with root permission.\n\n    $ sudo mono example2.exe\n\n#### Step 4 ####\n\nStarting the WebSocket server.\n\n```csharp\nwssv.Start ();\n```\n\n#### Step 5 ####\n\nStopping the WebSocket server.\n\n```csharp\nwssv.Stop ();\n```\n\n### HTTP Server with the WebSocket ###\n\nI have modified the `System.Net.HttpListener`, `System.Net.HttpListenerContext`, and some other classes from **[Mono]** to create an HTTP server that allows to accept the WebSocket handshake requests.\n\nSo websocket-sharp provides the `WebSocketSharp.Server.HttpServer` class.\n\nYou can add any WebSocket service to your `HttpServer` with the specified behavior and path to the service, by using the `HttpServer.AddWebSocketService<TBehavior> (string)` or `HttpServer.AddWebSocketService<TBehavior> (string, Action<TBehavior>)` method.\n\n```csharp\nvar httpsv = new HttpServer (4649);\n\nhttpsv.AddWebSocketService<Echo> (\"/Echo\");\nhttpsv.AddWebSocketService<Chat> (\"/Chat\");\nhttpsv.AddWebSocketService<Chat> (\"/ChatWithNyan\", s => s.Suffix = \" Nyan!\");\n```\n\nFor more information, would you see **[Example3]**?\n\n### WebSocket Extensions ###\n\n#### Per-message Compression ####\n\nwebsocket-sharp supports the [Per-message Compression][rfc7692] extension (but does not support it with the [context take over]).\n\nAs a WebSocket client, if you would like to enable this extension, you should set the `WebSocket.Compression` property to a compression method before calling the connect method.\n\n```csharp\nws.Compression = CompressionMethod.Deflate;\n```\n\nAnd then the client will send the following header in the handshake request to the server.\n\n    Sec-WebSocket-Extensions: permessage-deflate; server_no_context_takeover; client_no_context_takeover\n\nIf the server supports this extension, it will return the same header which has the corresponding value.\n\nSo eventually this extension will be available when the client receives the header in the handshake response.\n\n#### Ignoring the extensions ####\n\nAs a WebSocket server, if you would like to ignore the extensions requested from a client, you should set the `WebSocketBehavior.IgnoreExtensions` property to `true` in your `WebSocketBehavior` constructor or initializing it, such as the following.\n\n```csharp\nwssv.AddWebSocketService<Chat> (\n  \"/Chat\",\n  s => s.IgnoreExtensions = true // To ignore the extensions requested from a client.\n);\n```\n\nIf it is set to `true`, the service will not return the Sec-WebSocket-Extensions header in its handshake response.\n\nI think this is useful when you get something error in connecting the server and exclude the extensions as a cause of the error.\n\n### Secure Connection ###\n\nwebsocket-sharp supports the secure connection with **SSL/TLS**.\n\nAs a WebSocket client, you should create a new instance of the `WebSocket` class with a **wss** scheme WebSocket URL.\n\n```csharp\nvar ws = new WebSocket (\"wss://example.com\");\n```\n\nIf you would like to set a custom validation for the server certificate, you should set the `WebSocket.SslConfiguration.ServerCertificateValidationCallback` property to a callback for it.\n\n```csharp\nws.SslConfiguration.ServerCertificateValidationCallback =\n  (sender, certificate, chain, sslPolicyErrors) => {\n    // Do something to validate the server certificate.\n    ...\n\n    return true; // If the server certificate is valid.\n  };\n```\n\nThe default callback always returns `true`.\n\nAs a WebSocket server, you should create a new instance of the `WebSocketServer` or `HttpServer` class with some settings for the secure connection, such as the following.\n\n```csharp\nvar wssv = new WebSocketServer (5963, true);\nwssv.SslConfiguration.ServerCertificate = new X509Certificate2 (\n                                            \"/path/to/cert.pfx\", \"password for cert.pfx\"\n                                          );\n```\n\n### HTTP Authentication ###\n\nwebsocket-sharp supports the [HTTP Authentication (Basic/Digest)][rfc2617].\n\nAs a WebSocket client, you should set a pair of user name and password for the HTTP authentication, by using the `WebSocket.SetCredentials (string, string, bool)` method before calling the connect method.\n\n```csharp\nws.SetCredentials (\"nobita\", \"password\", preAuth);\n```\n\nIf `preAuth` is `true`, the client will send the credentials for the Basic authentication in the first handshake request to the server.\n\nOtherwise, it will send the credentials for either the Basic or Digest (determined by the unauthorized response to the first handshake request) authentication in the second handshake request to the server.\n\nAs a WebSocket server, you should set an HTTP authentication scheme, a realm, and any function to find the user credentials before calling the start method, such as the following.\n\n```csharp\nwssv.AuthenticationSchemes = AuthenticationSchemes.Basic;\nwssv.Realm = \"WebSocket Test\";\nwssv.UserCredentialsFinder = id => {\n    var name = id.Name;\n\n    // Return user name, password, and roles.\n    return name == \"nobita\"\n           ? new NetworkCredential (name, \"password\", \"gunfighter\")\n           : null; // If the user credentials are not found.\n  };\n```\n\nIf you would like to provide the Digest authentication, you should set such as the following.\n\n```csharp\nwssv.AuthenticationSchemes = AuthenticationSchemes.Digest;\n```\n\n### Query string, Origin header, and Cookies ###\n\nAs a WebSocket client, if you would like to send the query string in the handshake request, you should create a new instance of the `WebSocket` class with a WebSocket URL that includes the [Query] string parameters.\n\n```csharp\nvar ws = new WebSocket (\"ws://example.com/?name=nobita\");\n```\n\nAnd if you would like to send the Origin header in the handshake request, you should set the `WebSocket.Origin` property to an allowable value as the [Origin] header before calling the connect method.\n\n```csharp\nws.Origin = \"http://example.com\";\n```\n\nAnd also if you would like to send the cookies in the handshake request, you should set any cookie by using the `WebSocket.SetCookie (WebSocketSharp.Net.Cookie)` method before calling the connect method.\n\n```csharp\nws.SetCookie (new Cookie (\"name\", \"nobita\"));\n```\n\nAs a WebSocket server, if you would like to get the query string included in a handshake request, you should access the `WebSocketBehavior.QueryString` property, such as the following.\n\n```csharp\npublic class Chat : WebSocketBehavior\n{\n  private string _name;\n  ...\n\n  protected override void OnOpen ()\n  {\n    _name = QueryString[\"name\"];\n  }\n\n  ...\n}\n```\n\nAnd if you would like to validate the Origin header, cookies, or both, you should set each validation for it with your `WebSocketBehavior`, for example, by using the `WebSocketServer.AddWebSocketService<TBehavior> (string, Action<TBehavior>)` method with initializing, such as the following.\n\n```csharp\nwssv.AddWebSocketService<Chat> (\n  \"/Chat\",\n  s => {\n    s.OriginValidator =\n      val => {\n        // Check the value of the Origin header, and return true if valid.\n\n        Uri origin;\n\n        return !val.IsNullOrEmpty ()\n               && Uri.TryCreate (val, UriKind.Absolute, out origin)\n               && origin.Host == \"example.com\";\n      };\n\n    s.CookiesValidator =\n      (req, res) => {\n        // Check the cookies in \"req\", and set the cookies to send to\n        // the client with \"res\" if necessary.\n\n        foreach (var cookie in req) {\n          cookie.Expired = true;\n\n          res.Add (cookie);\n        }\n\n        return true; // If valid.\n      };\n  }\n);\n```\n\n### Connecting through the HTTP proxy server ###\n\nwebsocket-sharp supports to connect through the HTTP proxy server.\n\nIf you would like to connect to a WebSocket server through the HTTP proxy server, you should set the proxy server URL, and if necessary, a pair of user name and password for the proxy server authentication (Basic/Digest), by using the `WebSocket.SetProxy (string, string, string)` method before calling the connect method.\n\n```csharp\nvar ws = new WebSocket (\"ws://example.com\");\nws.SetProxy (\"http://localhost:3128\", \"nobita\", \"password\");\n```\n\nI have tested this with **[Squid]**. It is necessary to disable the following option in **squid.conf** (e.g. `/etc/squid/squid.conf`).\n\n```\n# Deny CONNECT to other than SSL ports\n#http_access deny CONNECT !SSL_ports\n```\n\n### Logging ###\n\nThe `WebSocket` class has the own logging function.\n\nYou can use it with the `WebSocket.Log` property (returns a `WebSocketSharp.Logger`).\n\nSo if you would like to change the current logging level (`WebSocketSharp.LogLevel.Error` as the default), you should set the `WebSocket.Log.Level` property to any of the `LogLevel` enum values.\n\n```csharp\nws.Log.Level = LogLevel.Debug;\n```\n\nThe above means a log with lower than `LogLevel.Debug` cannot be outputted.\n\nAnd if you would like to output a log, you should use any of the output methods. The following outputs a log with `LogLevel.Debug`.\n\n```csharp\nws.Log.Debug (\"This is a debug message.\");\n```\n\nThe `WebSocketServer` and `HttpServer` classes have the same logging function.\n\n## Examples ##\n\nExamples using websocket-sharp.\n\n### Example ###\n\n[Example] connects to the server executed by [Example2] or [Example3].\n\n### Example2 ###\n\n[Example2] starts a WebSocket server.\n\n### Example3 ###\n\n[Example3] starts an HTTP server that allows to accept the WebSocket handshake requests.\n\nWould you access to [http://localhost:4649](http://localhost:4649) to do **WebSocket Echo Test** with your web browser while Example3 is running?\n\n## Supported WebSocket Specifications ##\n\nwebsocket-sharp supports **RFC 6455**, and it is based on the following references:\n\n- [The WebSocket Protocol][rfc6455]\n- [The WebSocket API][api]\n- [Compression Extensions for WebSocket][rfc7692]\n\nThanks for translating to japanese.\n\n- [The WebSocket Protocol 日本語訳][rfc6455_ja]\n- [The WebSocket API 日本語訳][api_ja]\n\n## License ##\n\nwebsocket-sharp is provided under [The MIT License].\n\n\n[Example]: https://github.com/sta/websocket-sharp/tree/master/Example\n[Example2]: https://github.com/sta/websocket-sharp/tree/master/Example2\n[Example3]: https://github.com/sta/websocket-sharp/tree/master/Example3\n[Mono]: http://www.mono-project.com\n[MonoDevelop]: http://monodevelop.com\n[NuGet Gallery]: http://www.nuget.org\n[NuGet Gallery: websocket-sharp]: http://www.nuget.org/packages/WebSocketSharp\n[Origin]: http://tools.ietf.org/html/rfc6454#section-7\n[Query]: http://tools.ietf.org/html/rfc3986#section-3.4\n[Squid]: http://www.squid-cache.org\n[The MIT License]: https://raw.github.com/sta/websocket-sharp/master/LICENSE.txt\n[Unity]: http://unity3d.com\n[api]: http://www.w3.org/TR/websockets\n[api_ja]: http://www.hcn.zaq.ne.jp/___/WEB/WebSocket-ja.html\n[context take over]: https://datatracker.ietf.org/doc/html/rfc7692#section-7.1.1\n[draft-hixie-thewebsocketprotocol-75]: http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-75\n[draft-ietf-hybi-thewebsocketprotocol-00]: http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-00\n[draft75]: https://github.com/sta/websocket-sharp/tree/draft75\n[hybi-00]: https://github.com/sta/websocket-sharp/tree/hybi-00\n[master]: https://github.com/sta/websocket-sharp/tree/master\n[rfc2617]: http://tools.ietf.org/html/rfc2617\n[rfc6455]: http://tools.ietf.org/html/rfc6455\n[rfc6455_ja]: http://www.hcn.zaq.ne.jp/___/WEB/RFC6455-ja.html\n[rfc7692]: https://datatracker.ietf.org/doc/html/rfc7692\n"
        },
        {
          "name": "websocket-sharp.sln",
          "type": "blob",
          "size": 4.1669921875,
          "content": "﻿\r\nMicrosoft Visual Studio Solution File, Format Version 10.00\r\n# Visual Studio 2008\r\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"websocket-sharp\", \"websocket-sharp\\websocket-sharp.csproj\", \"{B357BAC7-529E-4D81-A0D2-71041B19C8DE}\"\r\nEndProject\r\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"Example\", \"Example\\Example.csproj\", \"{52805AEC-EFB1-4F42-BB8E-3ED4E692C568}\"\r\nEndProject\r\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"Example2\", \"Example2\\Example2.csproj\", \"{B81A24C8-25BB-42B2-AF99-1E1EACCE74C7}\"\r\nEndProject\r\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"Example3\", \"Example3\\Example3.csproj\", \"{C648BA25-77E5-4A40-A97F-D0AA37B9FB26}\"\r\nEndProject\r\nGlobal\r\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\r\n\t\tDebug|Any CPU = Debug|Any CPU\r\n\t\tRelease|Any CPU = Release|Any CPU\r\n\t\tDebug_Ubuntu|Any CPU = Debug_Ubuntu|Any CPU\r\n\t\tRelease_Ubuntu|Any CPU = Release_Ubuntu|Any CPU\r\n\tEndGlobalSection\r\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\r\n\t\t{52805AEC-EFB1-4F42-BB8E-3ED4E692C568}.Debug_Ubuntu|Any CPU.ActiveCfg = Debug_Ubuntu|Any CPU\r\n\t\t{52805AEC-EFB1-4F42-BB8E-3ED4E692C568}.Debug_Ubuntu|Any CPU.Build.0 = Debug_Ubuntu|Any CPU\r\n\t\t{52805AEC-EFB1-4F42-BB8E-3ED4E692C568}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{52805AEC-EFB1-4F42-BB8E-3ED4E692C568}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{52805AEC-EFB1-4F42-BB8E-3ED4E692C568}.Release_Ubuntu|Any CPU.ActiveCfg = Release_Ubuntu|Any CPU\r\n\t\t{52805AEC-EFB1-4F42-BB8E-3ED4E692C568}.Release_Ubuntu|Any CPU.Build.0 = Release_Ubuntu|Any CPU\r\n\t\t{52805AEC-EFB1-4F42-BB8E-3ED4E692C568}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{52805AEC-EFB1-4F42-BB8E-3ED4E692C568}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{B357BAC7-529E-4D81-A0D2-71041B19C8DE}.Debug_Ubuntu|Any CPU.ActiveCfg = Debug_Ubuntu|Any CPU\r\n\t\t{B357BAC7-529E-4D81-A0D2-71041B19C8DE}.Debug_Ubuntu|Any CPU.Build.0 = Debug_Ubuntu|Any CPU\r\n\t\t{B357BAC7-529E-4D81-A0D2-71041B19C8DE}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{B357BAC7-529E-4D81-A0D2-71041B19C8DE}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{B357BAC7-529E-4D81-A0D2-71041B19C8DE}.Release_Ubuntu|Any CPU.ActiveCfg = Release_Ubuntu|Any CPU\r\n\t\t{B357BAC7-529E-4D81-A0D2-71041B19C8DE}.Release_Ubuntu|Any CPU.Build.0 = Release_Ubuntu|Any CPU\r\n\t\t{B357BAC7-529E-4D81-A0D2-71041B19C8DE}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{B357BAC7-529E-4D81-A0D2-71041B19C8DE}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{B81A24C8-25BB-42B2-AF99-1E1EACCE74C7}.Debug_Ubuntu|Any CPU.ActiveCfg = Debug_Ubuntu|Any CPU\r\n\t\t{B81A24C8-25BB-42B2-AF99-1E1EACCE74C7}.Debug_Ubuntu|Any CPU.Build.0 = Debug_Ubuntu|Any CPU\r\n\t\t{B81A24C8-25BB-42B2-AF99-1E1EACCE74C7}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{B81A24C8-25BB-42B2-AF99-1E1EACCE74C7}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{B81A24C8-25BB-42B2-AF99-1E1EACCE74C7}.Release_Ubuntu|Any CPU.ActiveCfg = Release_Ubuntu|Any CPU\r\n\t\t{B81A24C8-25BB-42B2-AF99-1E1EACCE74C7}.Release_Ubuntu|Any CPU.Build.0 = Release_Ubuntu|Any CPU\r\n\t\t{B81A24C8-25BB-42B2-AF99-1E1EACCE74C7}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{B81A24C8-25BB-42B2-AF99-1E1EACCE74C7}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{C648BA25-77E5-4A40-A97F-D0AA37B9FB26}.Debug_Ubuntu|Any CPU.ActiveCfg = Debug_Ubuntu|Any CPU\r\n\t\t{C648BA25-77E5-4A40-A97F-D0AA37B9FB26}.Debug_Ubuntu|Any CPU.Build.0 = Debug_Ubuntu|Any CPU\r\n\t\t{C648BA25-77E5-4A40-A97F-D0AA37B9FB26}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{C648BA25-77E5-4A40-A97F-D0AA37B9FB26}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{C648BA25-77E5-4A40-A97F-D0AA37B9FB26}.Release_Ubuntu|Any CPU.ActiveCfg = Release_Ubuntu|Any CPU\r\n\t\t{C648BA25-77E5-4A40-A97F-D0AA37B9FB26}.Release_Ubuntu|Any CPU.Build.0 = Release_Ubuntu|Any CPU\r\n\t\t{C648BA25-77E5-4A40-A97F-D0AA37B9FB26}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{C648BA25-77E5-4A40-A97F-D0AA37B9FB26}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\tEndGlobalSection\r\n\tGlobalSection(MonoDevelopProperties) = preSolution\r\n\t\tStartupItem = websocket-sharp\\websocket-sharp.csproj\r\n\t\tPolicies = $0\r\n\t\t$0.TextStylePolicy = $1\r\n\t\t$1.inheritsSet = null\r\n\t\t$1.scope = text/x-csharp\r\n\t\t$0.CSharpFormattingPolicy = $2\r\n\t\t$2.inheritsSet = Mono\r\n\t\t$2.inheritsScope = text/x-csharp\r\n\t\t$2.scope = text/x-csharp\r\n\tEndGlobalSection\r\nEndGlobal\r\n"
        },
        {
          "name": "websocket-sharp",
          "type": "tree",
          "content": null
        },
        {
          "name": "websocket-sharp_icon.png",
          "type": "blob",
          "size": 0.8896484375,
          "content": null
        },
        {
          "name": "websocket-sharp_logo.png",
          "type": "blob",
          "size": 0.818359375,
          "content": null
        }
      ]
    }
  ]
}