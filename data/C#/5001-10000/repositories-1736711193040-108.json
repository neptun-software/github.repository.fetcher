{
  "metadata": {
    "timestamp": 1736711193040,
    "page": 108,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjExMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "MessagePack-CSharp/MessagePack-CSharp",
      "stars": 5926,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".config",
          "type": "tree",
          "content": null
        },
        {
          "name": ".devcontainer",
          "type": "tree",
          "content": null
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 9.4091796875,
          "content": "# EditorConfig is awesome:http://EditorConfig.org\n\n# top-most EditorConfig file\nroot = true\n\n# Don't use tabs for indentation.\n[*]\nindent_style = space\n\n# (Please don't specify an indent_size here; that has too many unintended consequences.)\n\n[*.yml]\nindent_size = 2\nindent_style = space\n\n# Code files\n[*.{cs,csx,vb,vbx,h,cpp,idl}]\nindent_size = 4\ninsert_final_newline = true\ntrim_trailing_whitespace = true\n\n# MSBuild project files\n[*.{csproj,vbproj,vcxproj,vcxproj.filters,proj,projitems,shproj,msbuildproj,props,targets}]\nindent_size = 2\n\n# Xml config files\n[*.{ruleset,config,nuspec,resx,vsixmanifest,vsct,runsettings}]\nindent_size = 2\nindent_style = space\n\n# JSON files\n[*.json]\nindent_size = 2\nindent_style = space\n\n[*.ps1]\nindent_style = space\nindent_size = 4\n\n# Dotnet code style settings:\n[*.{cs,vb}]\n\n# Use tuple syntax\ndotnet_diagnostic.SA1141.severity = silent\n# Tuple types in signatures should have element names\ndotnet_diagnostic.SA1414.severity = silent\n# Braces should not be omitted from multi-line child statement\ndotnet_diagnostic.SA1519.severity = silent\n\n# Sort using and Import directives with System.* appearing first\ndotnet_sort_system_directives_first = true\ndotnet_separate_import_directive_groups = false\ndotnet_style_qualification_for_field = false:silent\ndotnet_style_qualification_for_property = false:silent\ndotnet_style_qualification_for_method = false:silent\ndotnet_style_qualification_for_event = false:silent\n\n# Use language keywords instead of framework type names for type references\ndotnet_style_predefined_type_for_locals_parameters_members = true:suggestion\ndotnet_style_predefined_type_for_member_access = true:suggestion\n\n# Suggest more modern language features when available\ndotnet_style_object_initializer = true:suggestion\ndotnet_style_collection_initializer = true:suggestion\ndotnet_style_coalesce_expression = true:suggestion\ndotnet_style_null_propagation = true:suggestion\ndotnet_style_explicit_tuple_names = true:suggestion\n\n# Non-private static fields are PascalCase\ndotnet_naming_rule.non_private_static_fields_should_be_pascal_case.severity = suggestion\ndotnet_naming_rule.non_private_static_fields_should_be_pascal_case.symbols = non_private_static_fields\ndotnet_naming_rule.non_private_static_fields_should_be_pascal_case.style = non_private_static_field_style\n\ndotnet_naming_symbols.non_private_static_fields.applicable_kinds = field\ndotnet_naming_symbols.non_private_static_fields.applicable_accessibilities = public, protected, internal, protected internal, private protected\ndotnet_naming_symbols.non_private_static_fields.required_modifiers = static\n\ndotnet_naming_style.non_private_static_field_style.capitalization = pascal_case\n\n# Constants are PascalCase\ndotnet_naming_rule.constants_should_be_pascal_case.severity = suggestion\ndotnet_naming_rule.constants_should_be_pascal_case.symbols = constants\ndotnet_naming_rule.constants_should_be_pascal_case.style = constant_style\n\ndotnet_naming_symbols.constants.applicable_kinds = field, local\ndotnet_naming_symbols.constants.required_modifiers = const\n\ndotnet_naming_style.constant_style.capitalization = pascal_case\n\n# Static fields are camelCase\ndotnet_naming_rule.static_fields_should_be_camel_case.severity = suggestion\ndotnet_naming_rule.static_fields_should_be_camel_case.symbols = static_fields\ndotnet_naming_rule.static_fields_should_be_camel_case.style = static_field_style\n\ndotnet_naming_symbols.static_fields.applicable_kinds = field\ndotnet_naming_symbols.static_fields.required_modifiers = static\n\ndotnet_naming_style.static_field_style.capitalization = camel_case\n\n# Instance fields are camelCase\ndotnet_naming_rule.instance_fields_should_be_camel_case.severity = suggestion\ndotnet_naming_rule.instance_fields_should_be_camel_case.symbols = instance_fields\ndotnet_naming_rule.instance_fields_should_be_camel_case.style = instance_field_style\n\ndotnet_naming_symbols.instance_fields.applicable_kinds = field\n\ndotnet_naming_style.instance_field_style.capitalization = camel_case\n\n# Locals and parameters are camelCase\ndotnet_naming_rule.locals_should_be_camel_case.severity = suggestion\ndotnet_naming_rule.locals_should_be_camel_case.symbols = locals_and_parameters\ndotnet_naming_rule.locals_should_be_camel_case.style = camel_case_style\n\ndotnet_naming_symbols.locals_and_parameters.applicable_kinds = parameter, local\n\ndotnet_naming_style.camel_case_style.capitalization = camel_case\n\n# Local functions are PascalCase\ndotnet_naming_rule.local_functions_should_be_pascal_case.severity = suggestion\ndotnet_naming_rule.local_functions_should_be_pascal_case.symbols = local_functions\ndotnet_naming_rule.local_functions_should_be_pascal_case.style = local_function_style\n\ndotnet_naming_symbols.local_functions.applicable_kinds = local_function\n\ndotnet_naming_style.local_function_style.capitalization = pascal_case\n\n# By default, name items with PascalCase\ndotnet_naming_rule.members_should_be_pascal_case.severity = suggestion\ndotnet_naming_rule.members_should_be_pascal_case.symbols = all_members\ndotnet_naming_rule.members_should_be_pascal_case.style = pascal_case_style\n\ndotnet_naming_symbols.all_members.applicable_kinds = *\n\ndotnet_naming_style.pascal_case_style.capitalization = pascal_case\n\n# CSharp code style settings:\n[*.cs]\n# Indentation preferences\ncsharp_indent_block_contents = true\ncsharp_indent_braces = false\ncsharp_indent_case_contents = true\ncsharp_indent_switch_labels = true\ncsharp_indent_labels = flush_left\n\n# Prefer \"var\" everywhere\ncsharp_style_var_for_built_in_types = true:suggestion\ncsharp_style_var_when_type_is_apparent = true:suggestion\ncsharp_style_var_elsewhere = true:suggestion\n\n# Prefer method-like constructs to have a block body\ncsharp_style_expression_bodied_methods = false:none\ncsharp_style_expression_bodied_constructors = false:none\ncsharp_style_expression_bodied_operators = false:none\n\n# Prefer property-like constructs to have an expression-body\ncsharp_style_expression_bodied_properties = true:none\ncsharp_style_expression_bodied_indexers = true:none\ncsharp_style_expression_bodied_accessors = true:none\n\n# Suggest more modern language features when available\ncsharp_style_pattern_matching_over_is_with_cast_check = true:suggestion\ncsharp_style_pattern_matching_over_as_with_null_check = true:suggestion\ncsharp_style_inlined_variable_declaration = true:suggestion\ncsharp_style_throw_expression = true:suggestion\ncsharp_style_conditional_delegate_call = true:suggestion\n\n# Newline settings\ncsharp_new_line_before_open_brace = all\ncsharp_new_line_before_else = true\ncsharp_new_line_before_catch = true\ncsharp_new_line_before_finally = true\ncsharp_new_line_before_members_in_object_initializers = true\ncsharp_new_line_before_members_in_anonymous_types = true\n\n# Blocks are allowed\ncsharp_prefer_braces = true:silent\n\ndotnet_diagnostic.RS0041.severity = suggestion\n\n# SA1130: Use lambda syntax\ndotnet_diagnostic.SA1130.severity = silent\n\n# IDE1006: Naming Styles - StyleCop handles these for us\ndotnet_diagnostic.IDE1006.severity = none\n\ndotnet_diagnostic.DOC100.severity = silent\ndotnet_diagnostic.DOC104.severity = warning\ndotnet_diagnostic.DOC105.severity = warning\ndotnet_diagnostic.DOC106.severity = warning\ndotnet_diagnostic.DOC107.severity = warning\ndotnet_diagnostic.DOC108.severity = warning\ndotnet_diagnostic.DOC200.severity = warning\ndotnet_diagnostic.DOC202.severity = warning\n\n# CA1062: Validate arguments of public methods\ndotnet_diagnostic.CA1062.severity = suggestion\n\n# CS1591: Missing XML comment for publicly visible type or member\ndotnet_diagnostic.CS1591.severity = suggestion\n\n# SA1101: Prefix local calls with this\ndotnet_diagnostic.SA1101.severity = suggestion\n\n# SA120x: Element ordering\ndotnet_diagnostic.SA1201.severity = silent\ndotnet_diagnostic.SA1202.severity = silent\ndotnet_diagnostic.SA1204.severity = silent\ndotnet_diagnostic.SA1214.severity = silent\n\n# SA1121: Use built-in type alias\ndotnet_diagnostic.SA1121.severity = suggestion\n\n# SA1124: Do not use regions\ndotnet_diagnostic.SA1124.severity = suggestion\n\n# SA1133: Each attribute should be placed in its own set of square brackets\ndotnet_diagnostic.SA1133.severity = silent\n\n# SA1134: Each attribute should be placed on its own line of code\ndotnet_diagnostic.SA1134.severity = silent\n\n# SA1139: Use literal syntax instead of casting\ndotnet_diagnostic.SA1139.severity = suggestion\n\n# SA1600: Elements should be documented\ndotnet_diagnostic.SA1600.severity = silent\n\n# SA1601: Partial elements should be documented\ndotnet_diagnostic.SA1601.severity = silent\n\n# SA1602: Enumeration items should be documented\ndotnet_diagnostic.SA1602.severity = silent\n\n# SA1601: Element documentation should have summary\ndotnet_diagnostic.SA1604.severity = suggestion\n\n# SA1615: The documentation for parameter is missing\ndotnet_diagnostic.SA1611.severity = suggestion\n\n# SA1615: Element return value should be documented\ndotnet_diagnostic.SA1615.severity = suggestion\n\n# SA1618: Document type parameters\ndotnet_diagnostic.SA1618.severity = suggestion\n\n# CA2016: Forward the CancellationToken parameter\ndotnet_diagnostic.CA2016.severity = warning\n\n# SA1005: Single line comments should begin with single space\ndotnet_diagnostic.SA1005.severity = none\n\n# SA1507: Code should not contain multiple blank lines in a row\ndotnet_diagnostic.SA1507.severity = none\n\n# SA1508: Closing braces should not be preceded by blank line\ndotnet_diagnostic.SA1508.severity = none\n\n# SA1512: Single-line comments should not be followed by blank line\ndotnet_diagnostic.SA1512.severity = none\n\n# SA1515: Single-line comment should be preceded by blank line\ndotnet_diagnostic.SA1515.severity = none\n\n[*.sln]\nindent_style = tab\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 2.63671875,
          "content": "###############################################################################\n# Set default behavior to automatically normalize line endings.\n###############################################################################\n* text=auto\n\n# Ensure shell scripts use LF line endings (linux only accepts LF)\n*.sh eol=lf\n*.ps1 eol=lf\n\n# The macOS codesign tool is extremely picky, and requires LF line endings.\n*.plist eol=lf\n\n###############################################################################\n# Set default behavior for command prompt diff.\n#\n# This is need for earlier builds of msysgit that does not have it on by\n# default for csharp files.\n# Note: This is only used by command line\n###############################################################################\n#*.cs     diff=csharp\n\n###############################################################################\n# Set the merge driver for project and solution files\n#\n# Merging from the command prompt will add diff markers to the files if there\n# are conflicts (Merging from VS is not affected by the settings below, in VS\n# the diff markers are never inserted). Diff markers may cause the following\n# file extensions to fail to load in VS. An alternative would be to treat\n# these files as binary and thus will always conflict and require user\n# intervention with every merge. To do so, just uncomment the entries below\n###############################################################################\n#*.sln       merge=binary\n#*.csproj    merge=binary\n#*.vbproj    merge=binary\n#*.vcxproj   merge=binary\n#*.vcproj    merge=binary\n#*.dbproj    merge=binary\n#*.fsproj    merge=binary\n#*.lsproj    merge=binary\n#*.wixproj   merge=binary\n#*.modelproj merge=binary\n#*.sqlproj   merge=binary\n#*.wwaproj   merge=binary\n\n###############################################################################\n# behavior for image files\n#\n# image files are treated as binary by default.\n###############################################################################\n#*.jpg   binary\n#*.png   binary\n#*.gif   binary\n\n###############################################################################\n# diff behavior for common document formats\n#\n# Convert binary document formats to text before diffing them. This feature\n# is only available from the command line. Turn it on by uncommenting the\n# entries below.\n###############################################################################\n#*.doc   diff=astextplain\n#*.DOC   diff=astextplain\n#*.docx  diff=astextplain\n#*.DOCX  diff=astextplain\n#*.dot   diff=astextplain\n#*.DOT   diff=astextplain\n#*.pdf   diff=astextplain\n#*.PDF   diff=astextplain\n#*.rtf   diff=astextplain\n#*.RTF   diff=astextplain\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 6.3388671875,
          "content": "## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n##\n## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore\n\n# User-specific files\n*.rsuser\n*.suo\n*.user\n*.userosscache\n*.sln.docstates\n*.lutconfig\nlaunchSettings.json\n\n# User-specific files (MonoDevelop/Xamarin Studio)\n*.userprefs\n\n# Mono auto generated files\nmono_crash.*\n\n# Build results\n[Dd]ebug/\n[Dd]ebugPublic/\n[Rr]elease/\n[Rr]eleases/\nx64/\nx86/\n[Aa][Rr][Mm]/\n[Aa][Rr][Mm]64/\nbld/\n[Bb]in/\n[Oo]bj/\n[Ll]og/\n\n# Visual Studio 2015/2017 cache/options directory\n.vs/\n# Uncomment if you have tasks that create the project's static files in wwwroot\n#wwwroot/\n\n# Jetbrains Rider cache directory\n.idea/\n\n# Visual Studio 2017 auto generated files\nGenerated\\ Files/\n\n# MSTest test Results\n[Tt]est[Rr]esult*/\n[Bb]uild[Ll]og.*\n\n# NUnit\n*.VisualState.xml\nTestResult.xml\nnunit-*.xml\n\n# Build Results of an ATL Project\n[Dd]ebugPS/\n[Rr]eleasePS/\ndlldata.c\n\n# Benchmark Results\nBenchmarkDotNet.Artifacts/\n\n# StyleCop\nStyleCopReport.xml\n\n# Files built by Visual Studio\n*_i.c\n*_p.c\n*_h.h\n*.ilk\n*.obj\n*.iobj\n*.pch\n*.pdb\n*.ipdb\n*.pgc\n*.pgd\n*.rsp\n!Directory.Build.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.tmp_proj\n*_wpftmp.csproj\n*.log\n*.vspscc\n*.vssscc\n.builds\n*.pidb\n*.svclog\n*.scc\n\n# Chutzpah Test files\n_Chutzpah*\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opendb\n*.opensdf\n*.sdf\n*.cachefile\n*.VC.db\n*.VC.VC.opendb\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n*.sap\n\n# Visual Studio Trace Files\n*.e2e\n\n# TFS 2012 Local Workspace\n$tf/\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*/\n*.[Rr]e[Ss]harper\n*.DotSettings.user\n\n# JustCode is a .NET coding add-in\n.JustCode\n\n# TeamCity is a build add-in\n_TeamCity*\n\n# DotCover is a Code Coverage Tool\n*.dotCover\n\n# AxoCover is a Code Coverage Tool\n.axoCover/*\n!.axoCover/settings.json\n\n# Visual Studio code coverage results\n*.coverage\n*.coveragexml\n/coveragereport/\n\n# NCrunch\n_NCrunch_*\n.*crunch*.local.xml\nnCrunchTemp_*\n\n# MightyMoose\n*.mm.*\nAutoTest.Net/\n\n# Web workbench (sass)\n.sass-cache/\n\n# Installshield output folder\n[Ee]xpress/\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish/\n\n# Publish Web Output\n*.[Pp]ublish.xml\n*.azurePubxml\n# Note: Comment the next line if you want to checkin your web deploy settings,\n# but database connection strings (with potential passwords) will be unencrypted\n*.pubxml\n*.publishproj\n\n# Microsoft Azure Web App publish settings. Comment the next line if you want to\n# checkin your Azure Web App publish settings, but sensitive information contained\n# in these scripts will be unencrypted\nPublishScripts/\n\n# NuGet Packages\n*.nupkg\n# NuGet Symbol Packages\n*.snupkg\n# The packages folder can be ignored because of Package Restore\n**/[Pp]ackages/*\n# except build/, which is used as an MSBuild target.\n!**/[Pp]ackages/build/\n# Uncomment if necessary however generally it will be regenerated when needed\n#!**/[Pp]ackages/repositories.config\n# NuGet v3's project.json files produces more ignorable files\n*.nuget.props\n*.nuget.targets\n\n# Microsoft Azure Build Output\ncsx/\n*.build.csdef\n\n# Microsoft Azure Emulator\necf/\nrcf/\n\n# Windows Store app package directories and files\nAppPackages/\nBundleArtifacts/\nPackage.StoreAssociation.xml\n_pkginfo.txt\n*.appx\n*.appxbundle\n*.appxupload\n\n# Visual Studio cache files\n# files ending in .cache can be ignored\n*.[Cc]ache\n# but keep track of directories ending in .cache\n!?*.[Cc]ache/\n\n# Others\nClientBin/\n~$*\n*~\n*.dbmdl\n*.dbproj.schemaview\n*.jfm\n*.pfx\n*.publishsettings\norleans.codegen.cs\n\n# Including strong name files can present a security risk\n# (https://github.com/github/gitignore/pull/2483#issue-259490424)\n#*.snk\n\n# Since there are multiple workflows, uncomment next line to ignore bower_components\n# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)\n#bower_components/\n\n# RIA/Silverlight projects\nGenerated_Code/\n\n# Backup & report files from converting an old project file\n# to a newer Visual Studio version. Backup files are not needed,\n# because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\nUpgradeLog*.htm\nServiceFabricBackup/\n*.rptproj.bak\n\n# SQL Server files\n*.mdf\n*.ldf\n*.ndf\n\n# Business Intelligence projects\n*.rdl.data\n*.bim.layout\n*.bim_*.settings\n*.rptproj.rsuser\n*- [Bb]ackup.rdl\n*- [Bb]ackup ([0-9]).rdl\n*- [Bb]ackup ([0-9][0-9]).rdl\n\n# Microsoft Fakes\nFakesAssemblies/\n\n# GhostDoc plugin setting file\n*.GhostDoc.xml\n\n# Node.js Tools for Visual Studio\n.ntvs_analysis.dat\nnode_modules/\n\n# Visual Studio 6 build log\n*.plg\n\n# Visual Studio 6 workspace options file\n*.opt\n\n# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)\n*.vbw\n\n# Visual Studio LightSwitch build output\n**/*.HTMLClient/GeneratedArtifacts\n**/*.DesktopClient/GeneratedArtifacts\n**/*.DesktopClient/ModelManifest.xml\n**/*.Server/GeneratedArtifacts\n**/*.Server/ModelManifest.xml\n_Pvt_Extensions\n\n# Paket dependency manager\n.paket/paket.exe\npaket-files/\n\n# FAKE - F# Make\n.fake/\n\n# CodeRush personal settings\n.cr/personal\n\n# Python Tools for Visual Studio (PTVS)\n__pycache__/\n*.pyc\n\n# Cake - Uncomment if you are using it\n# tools/**\n# !tools/packages.config\n\n# Tabs Studio\n*.tss\n\n# Telerik's JustMock configuration file\n*.jmconfig\n\n# BizTalk build output\n*.btp.cs\n*.btm.cs\n*.odx.cs\n*.xsd.cs\n\n# OpenCover UI analysis results\nOpenCover/\n\n# Azure Stream Analytics local run output\nASALocalRun/\n\n# MSBuild Binary and Structured Log\n*.binlog\n\n# NVidia Nsight GPU debugger configuration file\n*.nvuser\n\n# MFractors (Xamarin productivity tool) working folder\n.mfractor/\n\n# Local History for Visual Studio\n.localhistory/\n\n# BeatPulse healthcheck temp database\nhealthchecksdb\n\n# Backup folder for Package Reference Convert tool in Visual Studio 2017\nMigrationBackup/\n\n# dotnet tool local install directory\n.store/\n\n# mac-created file to track user view preferences for a directory\n.DS_Store\n\n# Analysis results\n*.sarif\n\n# Unity\n\nsrc/MessagePack.UnityClient/bin/*\nsrc/MessagePack.UnityClient/Library/*\nsrc/MessagePack.UnityClient/obj/*\nsrc/MessagePack.UnityClient/Temp/*\nsrc/MessagePack.UnityClient/UserSettings/*\nsrc/MessagePack.UnityClient/Assets/Packages/\n\n# BenchmarkDotNet results\nBenchmarkDotNet.Artifacts/\n\nsrc/MessagePack.UnityClient/.vsconfig\n"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.3134765625,
          "content": "# Contributing\n\n## Dependencies\n\n* [Visual Studio 2022](https://visualstudio.microsoft.com/)\n* [Unity Editor](https://unity3d.com/unity/editor) (optional)\n* .NET Core SDK and runtimes (run `init` to install)\n\nThis repo uses the .NET Core SDK and runtimes to build and test the projects.\nYou can install the right versions of the SDK and runtimes by running the `init.ps1` script at the root of the repo.\n\nBy default no elevation is required as these toolsets are installed in a per-user directory. Launching `devenv` from the same PowerShell window that you ran the script will lead VS to discover these per-user toolsets.\nTo get VS to find the toolsets when launched from the Start Menu, run `init -InstallLocality machine`, which requires elevation for each SDK or runtime installed.\n\n## How to Build\n\nOpen `MessagePack.sln` on Visual Studio 2022.\n\nAlternatively you may build from the command line using `msbuild.exe` or:\n\n    dotnet build /p:platform=NoVSIX\n\n## Unity\n\nSee the ReadMe for the target directory `src\\MessagePack.UnityClient` for information on building and managing with Unity. Unity's CI is managed in `unity.yml` in GitHub Actions.\n\n## How to Publish Package\n\nPackage publishing is triggered via GitHub Actions using workflow_dispatch. Follow these steps:\n\n1. Select Actions -> \"Run release build and publish to NuGet\"\n2. Enter a version tag (e.g., `v3.0.1`)\n3. Click \"Run workflow\"\n\n![image](https://github.com/user-attachments/assets/74886c88-f6d1-4108-8ce1-02d3d1b31f1f)\n\nThe workflow will:\n- Update the version in [MessagePack.UnityClient/Assets/Scripts/MessagePack/package.json](https://github.com/MessagePack-CSharp/MessagePack-CSharp/blob/master/src/MessagePack.UnityClient/Assets/Scripts/MessagePack/package.json)\n- Commit and push the change\n- Build the .NET library\n- Publish to [NuGet/MessagePack](https://www.nuget.org/packages/MessagePack)\n- Create a draft GitHub release\n\nAfter CI completion, edit the release draft to add relevant release notes and announcements.\n\n### Secret\n\nThe following secrets are managed at the organization level:\n\n* `UNITY_EMAIL`\n* `UNITY_LICENSE`\n* `UNITY_PASSWORD`\n* `NUGET_KEY`\n\nThe `UNITY_*` secrets are personal license keys required for Unity builds.\n\n`NUGET_KEY` is a key required for releasing nupkg files, and since it has a 365-day expiration period, the key needs to be regenerated when it expires."
        },
        {
          "name": "CONTRIBUTORS",
          "type": "blob",
          "size": 0.06640625,
          "content": "Yoshifumi Kawai <ils@neue.cc>\nAndrew Arnott <andrewarnott@live.com>\n"
        },
        {
          "name": "Directory.Build.props",
          "type": "blob",
          "size": 2.3330078125,
          "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project>\n  <PropertyGroup>\n    <Configuration Condition=\" '$(Configuration)' == '' \">Debug</Configuration>\n    <RepoRootPath>$(MSBuildThisFileDirectory)</RepoRootPath>\n    <BaseIntermediateOutputPath>$(RepoRootPath)obj\\$([MSBuild]::MakeRelative($(RepoRootPath), $(MSBuildProjectDirectory)))\\</BaseIntermediateOutputPath>\n    <BaseOutputPath Condition=\" '$(BaseOutputPath)' == '' \">$(RepoRootPath)bin\\$(MSBuildProjectName)\\</BaseOutputPath>\n    <PackageOutputPath>$(RepoRootPath)bin\\Packages\\$(Configuration)\\</PackageOutputPath>\n    <AnalysisLevel>latest</AnalysisLevel>\n    <EnforceCodeStyleInBuild>true</EnforceCodeStyleInBuild>\n    <GenerateDocumentationFile>true</GenerateDocumentationFile>\n    <ProduceReferenceAssembly>true</ProduceReferenceAssembly>\n\n    <!-- https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md#setplatform-negotiation -->\n    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n\n    <!-- Opt in till https://github.com/NuGet/Home/issues/9803 makes this the default. -->\n    <!-- Opt back out until an SDK with the fix for https://github.com/NuGet/Home/issues/12177 is generally available. -->\n    <RestoreUseStaticGraphEvaluation>false</RestoreUseStaticGraphEvaluation>\n\n    <!-- Local builds should embed PDBs so we never lose them when a subsequent build occurs. -->\n    <DebugType Condition=\" '$(CI)' != 'true' and '$(TF_BUILD)' != 'true' \">embedded</DebugType>\n\n    <PackageProjectUrl>https://github.com/MessagePack-CSharp/MessagePack-CSharp</PackageProjectUrl>\n    <Authors>neuecc,aarnott</Authors>\n    <Copyright>© Yoshifumi Kawai and contributors. All rights reserved.</Copyright>\n    <PackageLicenseExpression>MIT</PackageLicenseExpression>\n    <PublishRepositoryUrl>true</PublishRepositoryUrl>\n    <EmbedUntrackedSources>true</EmbedUntrackedSources>\n    <IncludeSymbols Condition=\" '$(DebugType)' != 'embedded' \">true</IncludeSymbols>\n    <SymbolPackageFormat>snupkg</SymbolPackageFormat>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <AdditionalFiles Include=\"$(MSBuildThisFileDirectory)stylecop.json\" Link=\"stylecop.json\" />\n  </ItemGroup>\n\n  <ItemDefinitionGroup>\n    <!-- We always want MSBuild properties generated that point at the restored location of each package. -->\n    <PackageReference GeneratePathProperty=\"true\" />\n  </ItemDefinitionGroup>\n\n</Project>\n"
        },
        {
          "name": "Directory.Build.rsp",
          "type": "blob",
          "size": 0.7578125,
          "content": "#------------------------------------------------------------------------------\n# This file contains command-line options that MSBuild will process as part of\n# every build, unless the \"/noautoresponse\" switch is specified.\n#\n# MSBuild processes the options in this file first, before processing the\n# options on the command line. As a result, options on the command line can\n# override the options in this file. However, depending on the options being\n# set, the overriding can also result in conflicts.\n#\n# NOTE: The \"/noautoresponse\" switch cannot be specified in this file, nor in\n# any response file that is referenced by this file.\n#------------------------------------------------------------------------------\n/nr:false\n/m\n/verbosity:minimal\n/clp:Summary;ForceNoAlign\n"
        },
        {
          "name": "Directory.Build.targets",
          "type": "blob",
          "size": 0.4736328125,
          "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project>\n  <PropertyGroup>\n    <LangVersion Condition=\"'$(Language)'=='C#'\">12</LangVersion>\n    <LangVersion Condition=\"'$(Language)'=='VB'\">16.9</LangVersion>\n  </PropertyGroup>\n  <ItemGroup>\n    <!-- Avoid compile error about missing namespace when combining ImplicitUsings with .NET Framework target frameworks. -->\n    <Using Remove=\"System.Net.Http\" Condition=\"'$(TargetFrameworkIdentifier)'=='.NETFramework'\" />\n  </ItemGroup>\n</Project>\n"
        },
        {
          "name": "Directory.Packages.props",
          "type": "blob",
          "size": 5.4013671875,
          "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project>\n  <!-- https://learn.microsoft.com/nuget/consume-packages/central-package-management -->\n  <PropertyGroup>\n    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>\n    <CentralPackageTransitivePinningEnabled>true</CentralPackageTransitivePinningEnabled>\n    <BenchmarkDotNetVersion>0.14.0</BenchmarkDotNetVersion>\n    <!-- https://learn.microsoft.com/en-us/visualstudio/extensibility/roslyn-version-support?view=vs-2022 -->\n    <MicrosoftCodeAnalysisVersion>4.8.0</MicrosoftCodeAnalysisVersion>\n    <MicrosoftCodeAnalysisVersion Condition=\"'$(IsAnalyzerProject)'=='true'\">4.3.0</MicrosoftCodeAnalysisVersion>\n    <MicrosoftCodeAnalysisTestingVersion>1.1.2</MicrosoftCodeAnalysisTestingVersion>\n  </PropertyGroup>\n  <ItemGroup>\n    <PackageVersion Include=\"BenchmarkDotNet.Diagnostics.Windows\" Version=\"$(BenchmarkDotNetVersion)\" />\n    <PackageVersion Include=\"BenchmarkDotNet\" Version=\"$(BenchmarkDotNetVersion)\" />\n    <PackageVersion Include=\"Ceras\" Version=\"4.1.7\" />\n    <PackageVersion Include=\"ConsoleAppFramework\" Version=\"4.2.4\" />\n    <PackageVersion Include=\"FluentAssertions\" Version=\"6.12.0\" />\n    <PackageVersion Include=\"FsPickler\" Version=\"5.3.2\" />\n    <PackageVersion Include=\"Hyperion\" Version=\"0.12.2\" />\n    <PackageVersion Include=\"IsExternalInit\" Version=\"1.0.3\" />\n    <PackageVersion Include=\"Jil\" version=\"2.17.0\" />\n    <PackageVersion Include=\"Microsoft.AspNetCore.Mvc.Core\" Version=\"2.2.5\" />\n    <PackageVersion Include=\"Microsoft.CodeAnalysis.Analyzers\" version=\"3.3.4\" />\n    <PackageVersion Include=\"Microsoft.CodeAnalysis.Common\" version=\"$(MicrosoftCodeAnalysisVersion)\" />\n    <PackageVersion Include=\"Microsoft.CodeAnalysis.CSharp.CodeFix.Testing.XUnit\" Version=\"$(MicrosoftCodeAnalysisTestingVersion)\" />\n    <PackageVersion Include=\"Microsoft.CodeAnalysis.CSharp\" version=\"$(MicrosoftCodeAnalysisVersion)\" />\n    <PackageVersion Include=\"Microsoft.CodeAnalysis.CSharp.SourceGenerators.Testing.XUnit\" Version=\"$(MicrosoftCodeAnalysisTestingVersion)\" />\n    <PackageVersion Include=\"Microsoft.CodeAnalysis.CSharp.Workspaces\" version=\"$(MicrosoftCodeAnalysisVersion)\" />\n    <PackageVersion Include=\"Microsoft.CodeAnalysis.ResxSourceGenerator\" Version=\"3.11.0-beta1.24415.1\" />\n    <PackageVersion Include=\"Microsoft.CodeAnalysis.VisualBasic.CodeFix.Testing.XUnit\" Version=\"$(MicrosoftCodeAnalysisTestingVersion)\" />\n    <PackageVersion Include=\"Microsoft.CodeAnalysis.VisualBasic.Workspaces\" version=\"$(MicrosoftCodeAnalysisVersion)\" />\n    <PackageVersion Include=\"Microsoft.CodeAnalysis.Workspaces.Common\" Version=\"$(MicrosoftCodeAnalysisVersion)\" />\n    <PackageVersion Include=\"Microsoft.NET.StringTools\" Version=\"17.11.4\" />\n    <PackageVersion Include=\"Microsoft.NET.Test.Sdk\" Version=\"17.11.1\" />\n    <PackageVersion Include=\"Microsoft.NETCore.Portable.Compatibility\" Version=\"1.0.1\" />\n    <PackageVersion Include=\"Moq\" Version=\"4.20.70\" />\n    <PackageVersion Include=\"MsgPack.Cli\" Version=\"1.0.1\" />\n    <PackageVersion Include=\"Nerdbank.Streams\" Version=\"2.11.79\" />\n    <PackageVersion Include=\"Newtonsoft.Json.Bson\" Version=\"1.0.2\" />\n    <PackageVersion Include=\"Newtonsoft.Json\" Version=\"13.0.3\" />\n    <PackageVersion Include=\"NuGet.Protocol\" Version=\"6.8.0\" />\n    <PackageVersion Include=\"nunit\" Version=\"4.2.2\" />\n    <PackageVersion Include=\"NUnit3TestAdapter\" Version=\"4.5.0\" />\n    <PackageVersion Include=\"protobuf-net\" Version=\"3.2.30\" />\n    <PackageVersion Include=\"RandomFixtureKit\" Version=\"1.0.1\" />\n    <PackageVersion Include=\"ReactiveProperty\" Version=\"9.6.0\" />\n    <PackageVersion Include=\"Required\" Version=\"1.0.0\" />\n    <PackageVersion Include=\"Sigil\" version=\"5.0.0\" />\n    <PackageVersion Include=\"SpanJson\" Version=\"4.2.1\" />\n    <PackageVersion Include=\"Utf8Json\" Version=\"1.3.7\" />\n    <PackageVersion Include=\"Xunit.Combinatorial\" Version=\"1.6.24\" />\n    <PackageVersion Include=\"xunit.runner.console\" Version=\"2.9.2\" />\n    <PackageVersion Include=\"xunit.runner.visualstudio\" Version=\"2.8.2\" />\n    <PackageVersion Include=\"Xunit.SkippableFact\" Version=\"1.5.23\" />\n    <PackageVersion Include=\"xunit\" Version=\"2.9.2\" />\n    <PackageVersion Include=\"ZeroFormatter\" Version=\"1.6.4\" />\n  </ItemGroup>\n  <ItemGroup Condition=\" '$(TargetFramework)' == 'netstandard2.1'\">\n    <PackageVersion Include=\"System.Collections.Immutable\" Version=\"8.0.0\" />\n  </ItemGroup>\n  <ItemGroup Condition=\" ('$(TargetFramework)' == 'netstandard2.0' and '$(IsAnalyzerProject)' != 'true') or '$(TargetFramework)' == 'net472'\">\n    <PackageVersion Include=\"Microsoft.Bcl.AsyncInterfaces\" Version=\"8.0.0\" />\n    <PackageVersion Include=\"System.Collections.Immutable\" Version=\"8.0.0\" />\n    <PackageVersion Include=\"System.Memory\" Version=\"4.5.5\" />\n    <PackageVersion Include=\"System.Reflection.Emit.Lightweight\" Version=\"4.7.0\" />\n    <PackageVersion Include=\"System.Reflection.Emit\" Version=\"4.7.0\" />\n    <PackageVersion Include=\"System.Reflection.Metadata\" Version=\"8.0.1\" />\n    <PackageVersion Include=\"System.Runtime.CompilerServices.Unsafe\" Version=\"6.0.0\" />\n    <PackageVersion Include=\"System.Text.Json\" Version=\"8.0.5\" />\n    <PackageVersion Include=\"System.Threading.Tasks.Extensions\" Version=\"4.5.4\" />\n  </ItemGroup>\n  <ItemGroup>\n    <GlobalPackageReference Include=\"CSharpIsNullAnalyzer\" Version=\"0.1.593\" />\n    <GlobalPackageReference Include=\"PolySharp\" Version=\"1.15.0\" />\n    <GlobalPackageReference Include=\"StyleCop.Analyzers.Unstable\" Version=\"1.2.0.556\" />\n  </ItemGroup>\n</Project>\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 2.3955078125,
          "content": "MessagePack for C#\n\nMIT License\n\nCopyright (c) 2017 Yoshifumi Kawai and contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n---\n\nlz4net\n\nBSD 2-Clause \"Simplified\" License\n\nCopyright (c) 2013-2017, Milosz Krajewski\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "MessagePack.sln",
          "type": "blob",
          "size": 19.091796875,
          "content": "﻿\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio Version 17\nVisualStudioVersion = 17.4.33103.184\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"src\", \"src\", \"{86309CF6-0054-4CE3-BFD3-CA0AA7DB17BC}\"\n\tProjectSection(SolutionItems) = preProject\n\t\tsrc\\Directory.Build.props = src\\Directory.Build.props\n\t\tsrc\\Directory.Build.targets = src\\Directory.Build.targets\n\tEndProjectSection\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePack\", \"src\\MessagePack\\MessagePack.csproj\", \"{7ABB33EE-A2F1-492B-8DAF-5DF89F0F0B79}\"\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"tests\", \"tests\", \"{19FE674A-AC94-4E7E-B24C-2285D1D04CDE}\"\n\tProjectSection(SolutionItems) = preProject\n\t\ttests\\SourceGeneratorConsumer.props = tests\\SourceGeneratorConsumer.props\n\t\ttests\\SourceGeneratorConsumer.targets = tests\\SourceGeneratorConsumer.targets\n\tEndProjectSection\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePack.Tests\", \"tests\\MessagePack.Tests\\MessagePack.Tests.csproj\", \"{9E1A55CA-711D-4F58-A332-735960E3434C}\"\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"docs\", \"docs\", \"{344DC89D-8761-4552-A70A-B34DC19F39C4}\"\n\tProjectSection(SolutionItems) = preProject\n\t\t.gitignore = .gitignore\n\t\tLICENSE = LICENSE\n\t\tREADME.md = README.md\n\tEndProjectSection\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"sandbox\", \"sandbox\", \"{BF4C4202-5015-4FBD-80E6-D0F36A06F700}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Sandbox\", \"sandbox\\Sandbox\\Sandbox.csproj\", \"{ED43BDA5-947C-4769-A47A-F07D3C6142AE}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"DynamicCodeDumper\", \"sandbox\\DynamicCodeDumper\\DynamicCodeDumper.csproj\", \"{8E511130-F838-4B47-842B-0FB27AD175B5}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"SharedData\", \"sandbox\\SharedData\\SharedData.csproj\", \"{3ABC5C4C-2CE4-459E-8666-F2B181C3DEF3}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePack.UnityShims\", \"src\\MessagePack.UnityShims\\MessagePack.UnityShims.csproj\", \"{C01E1407-7FEC-4C1D-B0B4-74D95A317AA6}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePack.ReactiveProperty\", \"src\\MessagePack.ReactiveProperty\\MessagePack.ReactiveProperty.csproj\", \"{166A16C0-B89F-41AF-956A-235C6CA62C25}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePack.ImmutableCollection\", \"src\\MessagePack.ImmutableCollection\\MessagePack.ImmutableCollection.csproj\", \"{E066F547-7261-4561-AEFC-E64DBFD874F8}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"PerfNetFramework\", \"sandbox\\PerfNetFramework\\PerfNetFramework.csproj\", \"{014A3DCE-50A6-4774-A4C1-C66EEAB67133}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePack.AspNetCoreMvcFormatter\", \"src\\MessagePack.AspNetCoreMvcFormatter\\MessagePack.AspNetCoreMvcFormatter.csproj\", \"{17831017-C29C-4A48-B159-849BCE5079FB}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"PerfBenchmarkDotNet\", \"sandbox\\PerfBenchmarkDotNet\\PerfBenchmarkDotNet.csproj\", \"{814F94D6-1413-4ACB-B1B5-A3488CAA1E6B}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"TestData2\", \"sandbox\\TestData2\\TestData2.csproj\", \"{2A32A538-BA26-4D89-85D0-E4249AFA0837}\"\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"build\", \"build\", \"{301F812B-8AEE-4DC2-8009-4510F02294AD}\"\n\tProjectSection(SolutionItems) = preProject\n\t\t.editorconfig = .editorconfig\n\t\tDirectory.Build.props = Directory.Build.props\n\t\tDirectory.Packages.props = Directory.Packages.props\n\t\tglobal.json = global.json\n\t\tnuget.config = nuget.config\n\t\tstylecop.json = stylecop.json\n\tEndProjectSection\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePack.AspNetCoreMvcFormatter.Tests\", \"tests\\MessagePack.AspNetCoreMvcFormatter.Tests\\MessagePack.AspNetCoreMvcFormatter.Tests.csproj\", \"{79C2B2CB-872A-4BA9-82DC-60F6DD77F940}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePack.Annotations\", \"src\\MessagePack.Annotations\\MessagePack.Annotations.csproj\", \"{85763F30-7733-44AB-89AB-D1B64F6E0D93}\"\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"Solution Items\", \"Solution Items\", \"{5BAF9120-1293-449E-975C-A373E9DE7F69}\"\n\tProjectSection(SolutionItems) = preProject\n\t\t.gitignore = .gitignore\n\tEndProjectSection\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"benchmark\", \"benchmark\", \"{51A614B0-E583-4DD2-AC7D-6A65634582E0}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"SerializerBenchmark\", \"benchmark\\SerializerBenchmark\\SerializerBenchmark.csproj\", \"{4142EA80-FEF4-44A5-8553-1AE84BEBAFED}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePack.Internal\", \"sandbox\\MessagePack.Internal\\MessagePack.Internal.csproj\", \"{C100FBA6-4164-4D6A-A532-5984D2B8DCB0}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePack.Internal.Tests\", \"tests\\MessagePack.Internal.Tests\\MessagePack.Internal.Tests.csproj\", \"{8D9FD130-7905-47D8-A25C-7FDEE28EA0E8}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePack.SourceGenerator\", \"src\\MessagePack.SourceGenerator\\MessagePack.SourceGenerator.csproj\", \"{32C91908-5CAD-4C95-B240-ACBBACAC9476}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePack.SourceGenerator.Tests\", \"tests\\MessagePack.SourceGenerator.Tests\\MessagePack.SourceGenerator.Tests.csproj\", \"{6AC51E68-4681-463A-B4B6-BD53517244B2}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"ExperimentalBenchmark\", \"benchmark\\ExperimentalBenchmark\\ExperimentalBenchmark.csproj\", \"{4C9BB260-62D8-49CD-9F9C-9AA6A8BFC637}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePack.Experimental\", \"src\\MessagePack.Experimental\\MessagePack.Experimental.csproj\", \"{AC2503A7-736D-4AE6-9355-CF35D9DF6139}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePack.Experimental.Tests\", \"tests\\MessagePack.Experimental.Tests\\MessagePack.Experimental.Tests.csproj\", \"{8AB40D1C-1134-4D77-B39A-19AEDC729450}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePack.GeneratedCode.Tests\", \"tests\\MessagePack.GeneratedCode.Tests\\MessagePack.GeneratedCode.Tests.csproj\", \"{D4CE7347-CEBE-46E5-BD12-1319573B6C5E}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePack.SourceGenerator.ExecutionTests\", \"tests\\MessagePack.SourceGenerator.ExecutionTests\\MessagePack.SourceGenerator.ExecutionTests.csproj\", \"{7908D954-15D4-4D67-B49A-4484809DA2C4}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePack.SourceGenerator.MapModeExecutionTests\", \"tests\\MessagePack.SourceGenerator.MapModeExecutionTests\\MessagePack.SourceGenerator.MapModeExecutionTests.csproj\", \"{EDBA7DDC-69AF-4D5B-A8F6-3B508F8CC0FC}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePack.Analyzers.CodeFixes\", \"src\\MessagePack.Analyzers.CodeFixes\\MessagePack.Analyzers.CodeFixes.csproj\", \"{7A6CB600-2393-468F-9952-84EC624D57BD}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePack.Analyzers\", \"src\\MessagePack.Analyzers\\MessagePack.Analyzers.csproj\", \"{EB77463C-9D06-4AAE-84F0-470988D30DA0}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"CollectionsMarshalBenchmark\", \"benchmark\\CollectionsMarshalBenchmark\\CollectionsMarshalBenchmark.csproj\", \"{9A31C44C-9C51-4D41-B8E5-2864245F877E}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|Any CPU = Debug|Any CPU\n\t\tRelease|Any CPU = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{7ABB33EE-A2F1-492B-8DAF-5DF89F0F0B79}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{7ABB33EE-A2F1-492B-8DAF-5DF89F0F0B79}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{7ABB33EE-A2F1-492B-8DAF-5DF89F0F0B79}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{7ABB33EE-A2F1-492B-8DAF-5DF89F0F0B79}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{9E1A55CA-711D-4F58-A332-735960E3434C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{9E1A55CA-711D-4F58-A332-735960E3434C}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{9E1A55CA-711D-4F58-A332-735960E3434C}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{9E1A55CA-711D-4F58-A332-735960E3434C}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{ED43BDA5-947C-4769-A47A-F07D3C6142AE}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{ED43BDA5-947C-4769-A47A-F07D3C6142AE}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{ED43BDA5-947C-4769-A47A-F07D3C6142AE}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{ED43BDA5-947C-4769-A47A-F07D3C6142AE}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{8E511130-F838-4B47-842B-0FB27AD175B5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{8E511130-F838-4B47-842B-0FB27AD175B5}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{8E511130-F838-4B47-842B-0FB27AD175B5}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{8E511130-F838-4B47-842B-0FB27AD175B5}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{3ABC5C4C-2CE4-459E-8666-F2B181C3DEF3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{3ABC5C4C-2CE4-459E-8666-F2B181C3DEF3}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{3ABC5C4C-2CE4-459E-8666-F2B181C3DEF3}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{3ABC5C4C-2CE4-459E-8666-F2B181C3DEF3}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{C01E1407-7FEC-4C1D-B0B4-74D95A317AA6}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{C01E1407-7FEC-4C1D-B0B4-74D95A317AA6}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{C01E1407-7FEC-4C1D-B0B4-74D95A317AA6}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{C01E1407-7FEC-4C1D-B0B4-74D95A317AA6}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{166A16C0-B89F-41AF-956A-235C6CA62C25}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{166A16C0-B89F-41AF-956A-235C6CA62C25}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{166A16C0-B89F-41AF-956A-235C6CA62C25}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{166A16C0-B89F-41AF-956A-235C6CA62C25}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{E066F547-7261-4561-AEFC-E64DBFD874F8}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{E066F547-7261-4561-AEFC-E64DBFD874F8}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{E066F547-7261-4561-AEFC-E64DBFD874F8}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{E066F547-7261-4561-AEFC-E64DBFD874F8}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{014A3DCE-50A6-4774-A4C1-C66EEAB67133}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{014A3DCE-50A6-4774-A4C1-C66EEAB67133}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{014A3DCE-50A6-4774-A4C1-C66EEAB67133}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{014A3DCE-50A6-4774-A4C1-C66EEAB67133}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{17831017-C29C-4A48-B159-849BCE5079FB}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{17831017-C29C-4A48-B159-849BCE5079FB}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{17831017-C29C-4A48-B159-849BCE5079FB}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{17831017-C29C-4A48-B159-849BCE5079FB}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{814F94D6-1413-4ACB-B1B5-A3488CAA1E6B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{814F94D6-1413-4ACB-B1B5-A3488CAA1E6B}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{814F94D6-1413-4ACB-B1B5-A3488CAA1E6B}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{814F94D6-1413-4ACB-B1B5-A3488CAA1E6B}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{2A32A538-BA26-4D89-85D0-E4249AFA0837}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{2A32A538-BA26-4D89-85D0-E4249AFA0837}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{2A32A538-BA26-4D89-85D0-E4249AFA0837}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{2A32A538-BA26-4D89-85D0-E4249AFA0837}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{79C2B2CB-872A-4BA9-82DC-60F6DD77F940}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{79C2B2CB-872A-4BA9-82DC-60F6DD77F940}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{79C2B2CB-872A-4BA9-82DC-60F6DD77F940}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{79C2B2CB-872A-4BA9-82DC-60F6DD77F940}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{85763F30-7733-44AB-89AB-D1B64F6E0D93}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{85763F30-7733-44AB-89AB-D1B64F6E0D93}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{85763F30-7733-44AB-89AB-D1B64F6E0D93}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{85763F30-7733-44AB-89AB-D1B64F6E0D93}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{4142EA80-FEF4-44A5-8553-1AE84BEBAFED}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{4142EA80-FEF4-44A5-8553-1AE84BEBAFED}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{4142EA80-FEF4-44A5-8553-1AE84BEBAFED}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{4142EA80-FEF4-44A5-8553-1AE84BEBAFED}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{C100FBA6-4164-4D6A-A532-5984D2B8DCB0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{C100FBA6-4164-4D6A-A532-5984D2B8DCB0}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{C100FBA6-4164-4D6A-A532-5984D2B8DCB0}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{C100FBA6-4164-4D6A-A532-5984D2B8DCB0}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{8D9FD130-7905-47D8-A25C-7FDEE28EA0E8}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{8D9FD130-7905-47D8-A25C-7FDEE28EA0E8}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{8D9FD130-7905-47D8-A25C-7FDEE28EA0E8}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{8D9FD130-7905-47D8-A25C-7FDEE28EA0E8}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{32C91908-5CAD-4C95-B240-ACBBACAC9476}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{32C91908-5CAD-4C95-B240-ACBBACAC9476}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{32C91908-5CAD-4C95-B240-ACBBACAC9476}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{32C91908-5CAD-4C95-B240-ACBBACAC9476}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{6AC51E68-4681-463A-B4B6-BD53517244B2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{6AC51E68-4681-463A-B4B6-BD53517244B2}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{6AC51E68-4681-463A-B4B6-BD53517244B2}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{6AC51E68-4681-463A-B4B6-BD53517244B2}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{4C9BB260-62D8-49CD-9F9C-9AA6A8BFC637}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{4C9BB260-62D8-49CD-9F9C-9AA6A8BFC637}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{4C9BB260-62D8-49CD-9F9C-9AA6A8BFC637}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{4C9BB260-62D8-49CD-9F9C-9AA6A8BFC637}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{AC2503A7-736D-4AE6-9355-CF35D9DF6139}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{AC2503A7-736D-4AE6-9355-CF35D9DF6139}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{AC2503A7-736D-4AE6-9355-CF35D9DF6139}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{AC2503A7-736D-4AE6-9355-CF35D9DF6139}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{8AB40D1C-1134-4D77-B39A-19AEDC729450}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{8AB40D1C-1134-4D77-B39A-19AEDC729450}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{8AB40D1C-1134-4D77-B39A-19AEDC729450}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{8AB40D1C-1134-4D77-B39A-19AEDC729450}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{D4CE7347-CEBE-46E5-BD12-1319573B6C5E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{D4CE7347-CEBE-46E5-BD12-1319573B6C5E}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{D4CE7347-CEBE-46E5-BD12-1319573B6C5E}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{D4CE7347-CEBE-46E5-BD12-1319573B6C5E}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{7908D954-15D4-4D67-B49A-4484809DA2C4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{7908D954-15D4-4D67-B49A-4484809DA2C4}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{7908D954-15D4-4D67-B49A-4484809DA2C4}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{7908D954-15D4-4D67-B49A-4484809DA2C4}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{EDBA7DDC-69AF-4D5B-A8F6-3B508F8CC0FC}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{EDBA7DDC-69AF-4D5B-A8F6-3B508F8CC0FC}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{EDBA7DDC-69AF-4D5B-A8F6-3B508F8CC0FC}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{EDBA7DDC-69AF-4D5B-A8F6-3B508F8CC0FC}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{7A6CB600-2393-468F-9952-84EC624D57BD}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{7A6CB600-2393-468F-9952-84EC624D57BD}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{7A6CB600-2393-468F-9952-84EC624D57BD}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{7A6CB600-2393-468F-9952-84EC624D57BD}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{EB77463C-9D06-4AAE-84F0-470988D30DA0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{EB77463C-9D06-4AAE-84F0-470988D30DA0}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{EB77463C-9D06-4AAE-84F0-470988D30DA0}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{EB77463C-9D06-4AAE-84F0-470988D30DA0}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{9A31C44C-9C51-4D41-B8E5-2864245F877E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{9A31C44C-9C51-4D41-B8E5-2864245F877E}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{9A31C44C-9C51-4D41-B8E5-2864245F877E}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{9A31C44C-9C51-4D41-B8E5-2864245F877E}.Release|Any CPU.Build.0 = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(NestedProjects) = preSolution\n\t\t{7ABB33EE-A2F1-492B-8DAF-5DF89F0F0B79} = {86309CF6-0054-4CE3-BFD3-CA0AA7DB17BC}\n\t\t{9E1A55CA-711D-4F58-A332-735960E3434C} = {19FE674A-AC94-4E7E-B24C-2285D1D04CDE}\n\t\t{ED43BDA5-947C-4769-A47A-F07D3C6142AE} = {BF4C4202-5015-4FBD-80E6-D0F36A06F700}\n\t\t{8E511130-F838-4B47-842B-0FB27AD175B5} = {BF4C4202-5015-4FBD-80E6-D0F36A06F700}\n\t\t{3ABC5C4C-2CE4-459E-8666-F2B181C3DEF3} = {BF4C4202-5015-4FBD-80E6-D0F36A06F700}\n\t\t{C01E1407-7FEC-4C1D-B0B4-74D95A317AA6} = {86309CF6-0054-4CE3-BFD3-CA0AA7DB17BC}\n\t\t{166A16C0-B89F-41AF-956A-235C6CA62C25} = {86309CF6-0054-4CE3-BFD3-CA0AA7DB17BC}\n\t\t{E066F547-7261-4561-AEFC-E64DBFD874F8} = {86309CF6-0054-4CE3-BFD3-CA0AA7DB17BC}\n\t\t{014A3DCE-50A6-4774-A4C1-C66EEAB67133} = {BF4C4202-5015-4FBD-80E6-D0F36A06F700}\n\t\t{17831017-C29C-4A48-B159-849BCE5079FB} = {86309CF6-0054-4CE3-BFD3-CA0AA7DB17BC}\n\t\t{814F94D6-1413-4ACB-B1B5-A3488CAA1E6B} = {BF4C4202-5015-4FBD-80E6-D0F36A06F700}\n\t\t{2A32A538-BA26-4D89-85D0-E4249AFA0837} = {BF4C4202-5015-4FBD-80E6-D0F36A06F700}\n\t\t{79C2B2CB-872A-4BA9-82DC-60F6DD77F940} = {19FE674A-AC94-4E7E-B24C-2285D1D04CDE}\n\t\t{85763F30-7733-44AB-89AB-D1B64F6E0D93} = {86309CF6-0054-4CE3-BFD3-CA0AA7DB17BC}\n\t\t{4142EA80-FEF4-44A5-8553-1AE84BEBAFED} = {51A614B0-E583-4DD2-AC7D-6A65634582E0}\n\t\t{C100FBA6-4164-4D6A-A532-5984D2B8DCB0} = {BF4C4202-5015-4FBD-80E6-D0F36A06F700}\n\t\t{8D9FD130-7905-47D8-A25C-7FDEE28EA0E8} = {19FE674A-AC94-4E7E-B24C-2285D1D04CDE}\n\t\t{32C91908-5CAD-4C95-B240-ACBBACAC9476} = {86309CF6-0054-4CE3-BFD3-CA0AA7DB17BC}\n\t\t{6AC51E68-4681-463A-B4B6-BD53517244B2} = {19FE674A-AC94-4E7E-B24C-2285D1D04CDE}\n\t\t{4C9BB260-62D8-49CD-9F9C-9AA6A8BFC637} = {51A614B0-E583-4DD2-AC7D-6A65634582E0}\n\t\t{AC2503A7-736D-4AE6-9355-CF35D9DF6139} = {86309CF6-0054-4CE3-BFD3-CA0AA7DB17BC}\n\t\t{8AB40D1C-1134-4D77-B39A-19AEDC729450} = {19FE674A-AC94-4E7E-B24C-2285D1D04CDE}\n\t\t{D4CE7347-CEBE-46E5-BD12-1319573B6C5E} = {19FE674A-AC94-4E7E-B24C-2285D1D04CDE}\n\t\t{7908D954-15D4-4D67-B49A-4484809DA2C4} = {19FE674A-AC94-4E7E-B24C-2285D1D04CDE}\n\t\t{EDBA7DDC-69AF-4D5B-A8F6-3B508F8CC0FC} = {19FE674A-AC94-4E7E-B24C-2285D1D04CDE}\n\t\t{7A6CB600-2393-468F-9952-84EC624D57BD} = {86309CF6-0054-4CE3-BFD3-CA0AA7DB17BC}\n\t\t{EB77463C-9D06-4AAE-84F0-470988D30DA0} = {86309CF6-0054-4CE3-BFD3-CA0AA7DB17BC}\n\t\t{9A31C44C-9C51-4D41-B8E5-2864245F877E} = {51A614B0-E583-4DD2-AC7D-6A65634582E0}\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {B3911209-2DBF-47F8-98F6-BBC0EDFE63DE}\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 82.0791015625,
          "content": "# MessagePack for C# (.NET Framework, .NET 8, Unity, Xamarin)\n\n[![NuGet](https://img.shields.io/nuget/v/MessagePack.svg)](https://www.nuget.org/packages/messagepack)\n[![NuGet](https://img.shields.io/nuget/vpre/MessagePack.svg)](https://www.nuget.org/packages/messagepack)\n[![Releases](https://img.shields.io/github/release/neuecc/MessagePack-CSharp.svg)](https://github.com/MessagePack-CSharp/MessagePack-CSharp/releases)\n\n[![Join the chat at https://gitter.im/MessagePack-CSharp/Lobby](https://badges.gitter.im/MessagePack-CSharp/Lobby.svg)](https://gitter.im/MessagePack-CSharp/Lobby?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Build Status](https://dev.azure.com/ils0086/MessagePack-CSharp/_apis/build/status/MessagePack-CSharp-CI?branchName=master)](https://dev.azure.com/ils0086/MessagePack-CSharp/_build/latest?definitionId=2&branchName=master)\n\nThe extremely fast [MessagePack](http://msgpack.org/) serializer for C#.\nIt is 10x faster than [MsgPack-Cli](https://github.com/msgpack/msgpack-cli) and outperforms other C# serializers. MessagePack for C# also ships with built-in support for LZ4 compression - an extremely fast compression algorithm. Performance is important, particularly in applications like games, distributed computing, microservices, or data caches.\n\n![Perf comparison graph](https://cloud.githubusercontent.com/assets/46207/23835716/89c8ab08-07af-11e7-9183-9e9415bdc87f.png)\n\nMessagePack has a compact binary size and a full set of general purpose expressive data types. Please have a look at the [comparison with JSON, protobuf, ZeroFormatter section](#comparison) and learn [why MessagePack C# is the fastest](#performance).\n\n## Table of Contents\n\n- [Installation](#installation)\n    - [NuGet packages](#nuget-packages)\n    - [Unity](#unity)\n    - [Migration notes from v1.x](#migration-notes-from-v1x)\n- [Quick Start](#quick-start)\n- [Analyzer](#analyzer)\n- [Built-in supported types](#built-in-supported-types)\n- [Object Serialization](#object-serialization)\n- [DataContract compatibility](#datacontract-compatibility)\n- [Serializing readonly/immutable object members  (SerializationConstructor)](#serializing-readonlyimmutable-object-members--serializationconstructor)\n- [Serialization Callback](#serialization-callback)\n- [Union](#union)\n- [Dynamic (Untyped) Deserialization](#dynamic-untyped-deserialization)\n- [Object Type Serialization](#object-type-serialization)\n- [Typeless](#typeless)\n- [Security](#security)\n- [Performance](#performance)\n    - [Deserialization Performance for different options](#deserialization-performance-for-different-options)\n    - [String interning](#string-interning)\n- [LZ4 Compression](#lz4-compression)\n    - [Attributions](#attributions)\n- [Comparison with protobuf, JSON, ZeroFormatter](#comparison-with-protobuf-json-zeroformatter)\n- [Hints to achieve maximum performance when using MessagePack for C#](#hints-to-achieve-maximum-performance-when-using-messagepack-for-c)\n    - [Use indexed keys instead of string keys (Contractless)](#use-indexed-keys-instead-of-string-keys-contractless)\n    - [Create own custom composite resolver](#create-own-custom-composite-resolver)\n    - [Use native resolvers](#use-native-resolvers)\n    - [Be careful when copying buffers](#be-careful-when-copying-buffers)\n    - [Choosing compression](#choosing-compression)\n- [Extensions](#extensions)\n- [Experimental Features](#experimental-features)\n- [High-Level API (`MessagePackSerializer`)](#high-level-api-messagepackserializer)\n    - [Multiple MessagePack structures on a single `Stream`](#multiple-messagepack-structures-on-a-single-stream)\n- [Low-Level API (`IMessagePackFormatter<T>`)](#low-level-api-imessagepackformattert)\n- [Primitive API (`MessagePackWriter`, `MessagePackReader`)](#primitive-api-messagepackwriter-messagepackreader)\n    - [`MessagePackReader`](#messagepackreader)\n    - [`MessagePackWriter`](#messagepackwriter)\n- [Main Extension Point (`IFormatterResolver`)](#main-extension-point-iformatterresolver)\n- [MessagePackFormatterAttribute](#messagepackformatterattribute)\n- [IgnoreFormatter](#ignoreformatter)\n- [Reserved Extension Types](#reserved-extension-types)\n- [Unity support](#unity-support)\n- [AOT Code Generation (support for Unity/Xamarin)](#aot)\n- [RPC](#rpc)\n    - [MagicOnion](#magiconion)\n    - [StreamJsonRpc](#streamjsonrpc)\n- [How to build](#how-to-build)\n- [Author Info](#author-info)\n- [Code of Conduct & .NET Foundation notice](#coc)\n\n## Installation\n\nThis library is distributed via NuGet. Special [Unity support](#unity) is available, too.\n\nWe target .NET Standard 2.0 with special optimizations for .NET 8+ and .NET Framework.\nThe library code is pure C# (with Just-In-Time IL code generation on some platforms or AOT safe source generators).\n\n### NuGet packages\n\nTo install with NuGet, just install the `MessagePack` package:\n\n```ps1\nInstall-Package MessagePack\n```\n\nThere are also a range of official and third party Extension Packages available (learn more in our [extensions section](#extensions)):\n\n```ps1\nInstall-Package MessagePack.ReactiveProperty\nInstall-Package MessagePack.UnityShims\nInstall-Package MessagePack.AspNetCoreMvcFormatter\n```\n\n### Unity\n\nFor Unity projects, please read the [Unity Support](#unity-support) section to install.\n\n### Migration notes from prior versions\n\nMigrating from a prior major version of MessagePack to the latest?\nCheck out [these instructions](doc/migration.md).\n\n## Quick Start\n\nDefine the struct or class to be serialized and annotate it with a `[MessagePackObject]` attribute.\nAnnotate members whose values should be serialized (fields as well as properties) with `[Key]` attributes.\n\n```csharp\n[MessagePackObject]\npublic class MyClass\n{\n    // Key attributes take a serialization index (or string name)\n    // The values must be unique and versioning has to be considered as well.\n    // Keys are described in later sections in more detail.\n    [Key(0)]\n    public int Age { get; set; }\n\n    [Key(1)]\n    public string FirstName { get; set; }\n\n    [Key(2)]\n    public string LastName { get; set; }\n\n    // All fields or properties that should not be serialized must be annotated with [IgnoreMember].\n    [IgnoreMember]\n    public string FullName { get { return FirstName + LastName; } }\n}\n```\n\nCall `MessagePackSerializer.Serialize<T>/Deserialize<T>` to serialize/deserialize your object instance.\nYou can use the `ConvertToJson` method to get a human readable representation of any MessagePack binary blob.\n\n```csharp\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var mc = new MyClass\n        {\n            Age = 99,\n            FirstName = \"hoge\",\n            LastName = \"huga\",\n        };\n\n        // Call Serialize/Deserialize, that's all.\n        byte[] bytes = MessagePackSerializer.Serialize(mc);\n        MyClass mc2 = MessagePackSerializer.Deserialize<MyClass>(bytes);\n\n        // You can dump MessagePack binary blobs to human readable json.\n        // Using indexed keys (as opposed to string keys) will serialize to MessagePack arrays,\n        // hence property names are not available.\n        // [99,\"hoge\",\"huga\"]\n        var json = MessagePackSerializer.ConvertToJson(bytes);\n        Console.WriteLine(json);\n    }\n}\n```\n\nBy default, a `MessagePackObject` annotation is required. This can be made optional; see the [Object Serialization section](#object-serialization) and the [Formatter Resolver section](#resolvers) for details.\n\n## Analyzer\n\nThe MessagePackAnalyzer package(includes in default) aids with:\n\n1. Produces compiler warnings upon incorrect attribute use, member accessibility, and more.\n1. Automating attributing of your serializable classes and members.\n1. Optionally improving startup time through [AOT formatter generation](#aot).\n\nThe first two of these features is demonstrated below:\n\n![analyzergif](https://cloud.githubusercontent.com/assets/46207/23837445/ce734eae-07cb-11e7-9758-d69f0f095bc1.gif)\n\nTwo assembly-level attributes exist to help with mixing in your own custom formatters with the automatically generated ones:\n- `MessagePackKnownFormatterAttribute` - Identifies classes that implement `IMessagePackFormatter<T>`.\nThe `T` type argument will _not_ produce an analyzer warning when `T` is used elsewhere in a serializable object.\nWhen using a source generated resolver, the resolver will refer to this formatter for the appropriate type(s).\n- `MessagePackAssumedFormattableAttribute` - Identifies types that are assumed to have an `IMessagePackFormatter<T>` *somewhere*, and that will be combined within an `IFormatterResolver` at runtime to ensure the specified type can be serialized.\nThis attribute will suppress the analyzer warning from using that type although the type does not have a `[MessagePackObject]` attribute on it.\n\n\n## Built-in supported types\n\nThese types can serialize by default:\n\n* Primitives (`int`, `string`, etc...), `Enum`s, `Nullable<>`, `Lazy<>`\n* `TimeSpan`,  `DateTime`, `DateTimeOffset`\n* `Guid`, `Uri`, `Version`, `StringBuilder`\n* `BigInteger`, `Complex`, `Half`\n* `Array[]`, `Array[,]`, `Array[,,]`, `Array[,,,]`, `ArraySegment<>`, `BitArray`\n* `KeyValuePair<,>`, `Tuple<,...>`, `ValueTuple<,...>`\n* `ArrayList`, `Hashtable`\n* `List<>`, `LinkedList<>`, `Queue<>`, `Stack<>`, `HashSet<>`, `ReadOnlyCollection<>`, `SortedList<,>`\n* `IList<>`, `ICollection<>`, `IEnumerable<>`, `IReadOnlyCollection<>`, `IReadOnlyList<>`\n* `Dictionary<,>`, `IDictionary<,>`, `SortedDictionary<,>`, `ILookup<,>`, `IGrouping<,>`, `ReadOnlyDictionary<,>`, `IReadOnlyDictionary<,>`\n* `ObservableCollection<>`, `ReadOnlyObservableCollection<>`\n* `ISet<>`,\n* `ConcurrentBag<>`, `ConcurrentQueue<>`, `ConcurrentStack<>`, `ConcurrentDictionary<,>`\n* Immutable collections (`ImmutableList<>`, etc)\n* Custom implementations of `ICollection<>` or `IDictionary<,>` with a parameterless constructor\n* Custom implementations of `IList` or `IDictionary` with a parameterless constructor\n\nYou can add support for custom types, and there are some official/third-party extension packages for:\n\n* ReactiveProperty\n* for Unity (`Vector3`, `Quaternion`, etc...)\n* F# (Record, FsList, Discriminated Unions, etc...)\n\nPlease see the [extensions section](#extensions).\n\n`MessagePack.Nil` is the built-in type representing null/void in MessagePack for C#.\n\n## Object Serialization\n\nMessagePack for C# can serialize your own public `class` or `struct` types. By default, serializable types must be annotated with the `[MessagePackObject]` attribute and members with the `[Key]` attribute. Keys can be either indexes (`int`) or arbitrary strings. If all keys are indexes, arrays are used for serialization, which offers advantages in performance and binary size. Otherwise, MessagePack maps (dictionaries) will be used.\n\nIf you use `[MessagePackObject(keyAsPropertyName: true)]`, then members do not require explicit `Key` attributes, but string keys will be used.\n\n```csharp\n[MessagePackObject]\npublic class Sample1\n{\n    [Key(0)]\n    public int Foo { get; set; }\n    [Key(1)]\n    public int Bar { get; set; }\n}\n\n[MessagePackObject]\npublic class Sample2\n{\n    [Key(\"foo\")]\n    public int Foo { get; set; }\n    [Key(\"bar\")]\n    public int Bar { get; set; }\n}\n\n[MessagePackObject(keyAsPropertyName: true)]\npublic class Sample3\n{\n    // No need for a Key attribute\n    public int Foo { get; set; }\n\n    // If want to ignore a public member, you can use the  IgnoreMember attribute\n    [IgnoreMember]\n    public int Bar { get; set; }\n}\n\n// [10,20]\nConsole.WriteLine(MessagePackSerializer.SerializeToJson(new Sample1 { Foo = 10, Bar = 20 }));\n\n// {\"foo\":10,\"bar\":20}\nConsole.WriteLine(MessagePackSerializer.SerializeToJson(new Sample2 { Foo = 10, Bar = 20 }));\n\n// {\"Foo\":10}\nConsole.WriteLine(MessagePackSerializer.SerializeToJson(new Sample3 { Foo = 10, Bar = 20 }));\n```\n\nAll public instance members (fields as well as properties) will be serialized. If you want to ignore certain public members, annotate the member with a `[IgnoreMember]` attribute.\n\nPlease note that any serializable struct or class must have public accessibility; private and internal structs and classes cannot be serialized!\nThe default of requiring `MessagePackObject` annotations is meant to enforce explicitness and therefore may help write more robust code.\n\nShould you use an indexed (`int`) key or a string key?\nWe recommend using indexed keys for faster serialization and a more compact binary representation than string keys.\nHowever, the additional information in the strings of string keys can be quite useful when debugging.\n\nWhen classes change or are extended, be careful about versioning. `MessagePackSerializer` will initialize members to their `default` value if a key does not exist in the serialized binary blob, meaning members using reference types can be initialized to `null`.\nIf you use indexed (`int`) keys, the keys should start at 0 and should be sequential. If a later version stops using certain members, you should keep the obsolete members (C# provides an `Obsolete` attribute to annotate such members) until all other clients had a chance to update and remove their uses of these members as well. Also, when the values of indexed keys \"jump\" a lot, leaving gaps in the sequence, it will negatively affect the binary size, as `null` placeholders will be inserted into the resulting arrays. However, you shouldn't reuse indexes of removed members to avoid compatibility issues between clients or when trying to deserialize legacy blobs.\n\nExample of index gaps and resulting placeholders:\n\n```csharp\n[MessagePackObject]\npublic class IntKeySample\n{\n    [Key(3)]\n    public int A { get; set; }\n    [Key(10)]\n    public int B { get; set; }\n}\n\n// [null,null,null,0,null,null,null,null,null,null,0]\nConsole.WriteLine(MessagePackSerializer.SerializeToJson(new IntKeySample()));\n```\n\nIf you do not want to explicitly annotate with the `MessagePackObject`/`Key` attributes and instead want to use MessagePack for C# more like e.g. [Json.NET](https://github.com/JamesNK/Newtonsoft.Json), you can make use of the contractless resolver.\n\n```csharp\npublic class ContractlessSample\n{\n    public int MyProperty1 { get; set; }\n    public int MyProperty2 { get; set; }\n}\n\nvar data = new ContractlessSample { MyProperty1 = 99, MyProperty2 = 9999 };\nvar bin = MessagePackSerializer.Serialize(\n  data,\n  MessagePack.Resolvers.ContractlessStandardResolver.Options);\n\n// {\"MyProperty1\":99,\"MyProperty2\":9999}\nConsole.WriteLine(MessagePackSerializer.ConvertToJson(bin));\n\n// You can also set ContractlessStandardResolver as the default.\n// (Global state; Not recommended when writing library code)\nMessagePackSerializer.DefaultOptions = MessagePack.Resolvers.ContractlessStandardResolver.Options;\n\n// Now serializable...\nvar bin2 = MessagePackSerializer.Serialize(data);\n```\n\nIf you want to serialize private members as well, you can use one of the `*AllowPrivate` resolvers.\n\n```csharp\n[MessagePackObject]\npublic class PrivateSample\n{\n    [Key(0)]\n    int x;\n\n    public void SetX(int v)\n    {\n        x = v;\n    }\n\n    public int GetX()\n    {\n        return x;\n    }\n}\n\nvar data = new PrivateSample();\ndata.SetX(9999);\n\n// You can choose either StandardResolverAllowPrivate\n// or ContractlessStandardResolverAllowPrivate\nvar bin = MessagePackSerializer.Serialize(\n  data,\n  MessagePack.Resolvers.DynamicObjectResolverAllowPrivate.Options);\n```\n\nIf you want to use MessagePack for C# more like a BinaryFormatter with a typeless serialization API, use the typeless resolver and helpers. Please consult the [Typeless section](#typeless).\n\nResolvers are the way to add specialized support for custom types to MessagePack for C#. Please refer to the [Extension point section](#resolvers).\n\n## DataContract compatibility\n\nYou can use `[DataContract]` annotations instead of `[MessagePackObject]` ones. If type is annotated with `DataContract`, you can use `[DataMember]` annotations instead of `[Key]` ones and `[IgnoreDataMember]` instead of `[IgnoreMember]`.\n\nThen `[DataMember(Order = int)]` will behave the same as `[Key(int)]`, `[DataMember(Name = string)]` the same as `[Key(string)]`, and `[DataMember]` the same as `[Key(nameof(member name)]`.\n\nUsing `DataContract`, e.g. in shared libraries, makes your classes/structs independent from MessagePack for C# serialization.\nHowever, it is not supported by the analyzers nor source generator.\nAlso, features like `UnionAttribute`, `MessagePackFormatter`, `SerializationConstructor`, etc can not be used.\nDue to this, we recommend that you use the specific MessagePack for C# annotations when possible.\n\n## Serializing readonly/immutable object members  (SerializationConstructor)\n\nMessagePack for C# supports serialization of readonly/immutable objects/members. For example, this struct can be serialized and deserialized.\n\n```csharp\n[MessagePackObject]\npublic struct Point\n{\n    [Key(0)]\n    public readonly int X;\n    [Key(1)]\n    public readonly int Y;\n\n    public Point(int x, int y)\n    {\n        this.X = x;\n        this.Y = y;\n    }\n}\n\nvar data = new Point(99, 9999);\nvar bin = MessagePackSerializer.Serialize(data);\n\n// Okay to deserialize immutable object\nvar point = MessagePackSerializer.Deserialize<Point>(bin);\n```\n\n`MessagePackSerializer` will choose the constructor with the best matched argument list, using argument indexes index for index keys, or parameter names for string keys. If it cannot determine an appropriate constructor, a `MessagePackDynamicObjectResolverException: can't find matched constructor parameter` exception will be thrown.\nYou can specify which constructor to use manually with a `[SerializationConstructor]` annotation.\n\n```csharp\n[MessagePackObject]\npublic struct Point\n{\n    [Key(0)]\n    public readonly int X;\n    [Key(1)]\n    public readonly int Y;\n\n    [SerializationConstructor]\n    public Point(int x)\n    {\n        this.X = x;\n        this.Y = -1;\n    }\n\n    // If not marked attribute, used this(most matched argument)\n    public Point(int x, int y)\n    {\n        this.X = x;\n        this.Y = y;\n    }\n}\n```\n\n### C# 9 `record` types\n\nC# 9.0 record with primary constructor is similar immutable object, also supports serialize/deserialize.\n\n```csharp\n// use key as property name\n[MessagePackObject(true)]public record Point(int X, int Y);\n\n// use property: to set KeyAttribute\n[MessagePackObject] public record Point([property:Key(0)] int X, [property: Key(1)] int Y);\n\n// Or use explicit properties\n[MessagePackObject]\npublic record Person\n{\n    [Key(0)]\n    public string FirstName { get; init; }\n\n    [Key(1)]\n    public string LastName { get; init; }\n}\n```\n\n### C# 9 `init` property setter limitations\n\nWhen using `init` property setters in _generic_ classes, [a CLR bug](https://github.com/neuecc/MessagePack-CSharp/issues/1134) prevents our most efficient code generation from invoking the property setter.\nAs a result, you should avoid using `init` on property setters in generic classes when using the public-only `DynamicObjectResolver`/`StandardResolver`.\n\nWhen using the `DynamicObjectResolverAllowPrivate`/`StandardResolverAllowPrivate` resolver the bug does not apply and you may use `init` without restriction.\n\n## Serialization Callback\n\nObjects implementing the `IMessagePackSerializationCallbackReceiver` interface will received `OnBeforeSerialize` and `OnAfterDeserialize` calls during serialization/deserialization.\n\n```csharp\n[MessagePackObject]\npublic class SampleCallback : IMessagePackSerializationCallbackReceiver\n{\n    [Key(0)]\n    public int Key { get; set; }\n\n    public void OnBeforeSerialize()\n    {\n        Console.WriteLine(\"OnBefore\");\n    }\n\n    public void OnAfterDeserialize()\n    {\n        Console.WriteLine(\"OnAfter\");\n    }\n}\n```\n\n## Union\n\nMessagePack for C# supports serializing interface-typed and abstract class-typed objects. It behaves like `XmlInclude` or `ProtoInclude`. In MessagePack for C# these are called `Union`. Only interfaces and abstracts classes are allowed to be annotated with `Union` attributes. Unique union keys are required.\n\n```csharp\n// Annotate inheritance types\n[MessagePack.Union(0, typeof(FooClass))]\n[MessagePack.Union(1, typeof(BarClass))]\npublic interface IUnionSample\n{\n}\n\n[MessagePackObject]\npublic class FooClass : IUnionSample\n{\n    [Key(0)]\n    public int XYZ { get; set; }\n}\n\n[MessagePackObject]\npublic class BarClass : IUnionSample\n{\n    [Key(0)]\n    public string OPQ { get; set; }\n}\n\n// ---\n\nIUnionSample data = new FooClass() { XYZ = 999 };\n\n// Serialize interface-typed object.\nvar bin = MessagePackSerializer.Serialize(data);\n\n// Deserialize again.\nvar reData = MessagePackSerializer.Deserialize<IUnionSample>(bin);\n\n// Use with e.g. type-switching in C# 7.0\nswitch (reData)\n{\n    case FooClass x:\n        Console.WriteLine(x.XYZ);\n        break;\n    case BarClass x:\n        Console.WriteLine(x.OPQ);\n        break;\n    default:\n        break;\n}\n```\n\nUnions are internally serialized to two-element arrays.\n\n```csharp\nIUnionSample data = new BarClass { OPQ = \"FooBar\" };\n\nvar bin = MessagePackSerializer.Serialize(data);\n\n// Union is serialized to two-length array, [key, object]\n// [1,[\"FooBar\"]]\nConsole.WriteLine(MessagePackSerializer.ConvertToJson(bin));\n```\n\nUsing `Union` with abstract classes works the same way.\n\n```csharp\n[Union(0, typeof(SubUnionType1))]\n[Union(1, typeof(SubUnionType2))]\n[MessagePackObject]\npublic abstract class ParentUnionType\n{\n    [Key(0)]\n    public int MyProperty { get; set; }\n}\n\n[MessagePackObject]\npublic class SubUnionType1 : ParentUnionType\n{\n    [Key(1)]\n    public int MyProperty1 { get; set; }\n}\n\n[MessagePackObject]\npublic class SubUnionType2 : ParentUnionType\n{\n    [Key(1)]\n    public int MyProperty2 { get; set; }\n}\n```\n\nPlease be mindful that you cannot reuse the same keys in derived types that are already present in the parent type, as internally a single flat array or map will be used and thus cannot have duplicate indexes/keys.\n\n## Dynamic (Untyped) Deserialization\n\nWhen calling `MessagePackSerializer.Deserialize<object>` or `MessagePackSerializer.Deserialize<dynamic>`, any values present in the blob will be converted to primitive values, i.e. `bool`, `char`, `sbyte`, `byte`, `short`, `int`, `long`, `ushort`, `uint`, `ulong`, `float`, `double`, `DateTime`, `string`, `byte[]`, `object[]`, `IDictionary<object, object>`.\n\n```csharp\n// Sample blob.\nvar model = new DynamicModel { Name = \"foobar\", Items = new[] { 1, 10, 100, 1000 } };\nvar blob = MessagePackSerializer.Serialize(model, ContractlessStandardResolver.Options);\n\n// Dynamic (\"untyped\")\nvar dynamicModel = MessagePackSerializer.Deserialize<dynamic>(blob, ContractlessStandardResolver.Options);\n\n// You can access the data using array/dictionary indexers, as shown above\nConsole.WriteLine(dynamicModel[\"Name\"]); // foobar\nConsole.WriteLine(dynamicModel[\"Items\"][2]); // 100\n```\n\nExploring object trees using the dictionary indexer syntax is the fastest option for untyped deserialization, but it is tedious to read and write.\nWhere performance is not as important as code readability, consider deserializing with [ExpandoObject](doc/ExpandoObject.md).\n\n## Object Type Serialization\n\n`StandardResolver` and `ContractlessStandardResolver` can serialize `object`/anonymous typed objects.\n\n```csharp\nvar objects = new object[] { 1, \"aaa\", new ObjectFieldType { Anything = 9999 } };\nvar bin = MessagePackSerializer.Serialize(objects);\n\n// [1,\"aaa\",[9999]]\nConsole.WriteLine(MessagePackSerializer.ConvertToJson(bin));\n\n// Support anonymous Type Serialize\nvar anonType = new { Foo = 100, Bar = \"foobar\" };\nvar bin2 = MessagePackSerializer.Serialize(anonType, MessagePack.Resolvers.ContractlessStandardResolver.Options);\n\n// {\"Foo\":100,\"Bar\":\"foobar\"}\nConsole.WriteLine(MessagePackSerializer.ConvertToJson(bin2));\n```\n\n> Unity supports is limited.\n\nWhen deserializing, the behavior will be the same as Dynamic (Untyped) Deserialization.\n\n## Typeless\n\nThe typeless API is similar to `BinaryFormatter`, as it will embed type information into the blobs, so no types need to be specified explicitly when calling the API.\n\n```csharp\nobject mc = new Sandbox.MyClass()\n{\n    Age = 10,\n    FirstName = \"hoge\",\n    LastName = \"huga\"\n};\n\n// Serialize with the typeless API\nvar blob = MessagePackSerializer.Typeless.Serialize(mc);\n\n// Blob has embedded type-assembly information.\n// [\"Sandbox.MyClass, Sandbox\",10,\"hoge\",\"huga\"]\nConsole.WriteLine(MessagePackSerializer.ConvertToJson(bin));\n\n// You can deserialize to MyClass again with the typeless API\n// Note that no type has to be specified explicitly in the Deserialize call\n// as type information is embedded in the binary blob\nvar objModel = MessagePackSerializer.Typeless.Deserialize(bin) as MyClass;\n```\n\nType information is represented by the MessagePack `ext` format, type code `100`.\n\n`MessagePackSerializer.Typeless` is a shortcut of `Serialize/Deserialize<object>(TypelessContractlessStandardResolver.Instance)`.\nIf you want to configure it as the default resolver, you can use `MessagePackSerializer.Typeless.RegisterDefaultResolver`.\n\n`TypelessFormatter` can used standalone or combined with other resolvers.\n\n```csharp\n// Replaced `object` uses the typeless resolver\nvar resolver = MessagePack.Resolvers.CompositeResolver.Create(\n    new[] { MessagePack.Formatters.TypelessFormatter.Instance },\n    new[] { MessagePack.Resolvers.StandardResolver.Instance });\n\npublic class Foo\n{\n    // use Typeless(this field only)\n    [MessagePackFormatter(typeof(TypelessFormatter))]\n    public object Bar;\n}\n```\n\nIf a type's name is changed later, you can no longer deserialize old blobs. But you can specify a fallback name in such cases, providing a `TypelessFormatter.BindToType` function of your own.\n\n```csharp\nMessagePack.Formatters.TypelessFormatter.BindToType = typeName =>\n{\n    if (typeName.StartsWith(\"SomeNamespace\"))\n    {\n        typeName = typeName.Replace(\"SomeNamespace\", \"AnotherNamespace\");\n    }\n\n    return Type.GetType(typeName, false);\n};\n```\n\n## <a name=\"security\"></a>Security\n\nDeserializing data from an untrusted source can introduce security vulnerabilities in your application.\nDepending on the settings used during deserialization, **untrusted data may be able to execute arbitrary code** or cause a denial of service attack.\nUntrusted data might come from over the network from an untrusted source (e.g. any and every networked client) or can be tampered with by an intermediary when transmitted over an unauthenticated connection, or from a local storage that might have been tampered with, or many other sources. MessagePack for C# does not provide any means to authenticate data or make it tamper-resistant. Please use an appropriate method of authenticating data before deserialization - such as a [`MAC`](https://en.wikipedia.org/wiki/Message_authentication_code) .\n\nPlease be very mindful of these attack scenarios; many projects and companies, and serialization library users in general, have been bitten by untrusted user data deserialization in the past.\n\nWhen deserializing untrusted data, put MessagePack into a more secure mode by configuring your `MessagePackSerializerOptions.Security` property:\n\n```cs\nvar options = MessagePackSerializerOptions.Standard\n    .WithSecurity(MessagePackSecurity.UntrustedData);\n\n// Pass the options explicitly for the greatest control.\nT object = MessagePackSerializer.Deserialize<T>(data, options);\n\n// Or set the security level as the default.\nMessagePackSerializer.DefaultOptions = options;\n```\n\nYou should also avoid the Typeless serializer/formatters/resolvers for untrusted data as that opens the door for the untrusted data to potentially deserialize unanticipated types that can compromise security.\n\nThe `UntrustedData` mode merely hardens against some common attacks, but is no fully secure solution in itself.\n\n## Performance\n\nBenchmarks comparing MessagePack For C# to other serializers were run on `Windows 10 Pro x64 Intel Core i7-6700K 4.00GHz, 32GB RAM`. Benchmark code is [available here](https://github.com/neuecc/ZeroFormatter/tree/master/sandbox/PerformanceComparison) - and their [version info](https://github.com/neuecc/ZeroFormatter/blob/bc63cb925d/sandbox/PerformanceComparison/packages.config).\n[ZeroFormatter](https://github.com/neuecc/ZeroFormatter/) and [FlatBuffers](https://google.github.io/flatbuffers/) have infinitely fast deserializers, so ignore their deserialization performance.\n\n![image](https://cloud.githubusercontent.com/assets/46207/23835765/55fe494e-07b0-11e7-98be-5e7a9411da40.png)\n\n MessagePack for C# uses many techniques to improve performance.\n\n* The serializer uses `IBufferWriter<byte>` rather than `System.IO.Stream` to reduce memory overhead.\n* Buffers are rented from pools to reduce allocations, keeping throughput high through reduced GC pressure.\n* Don't create intermediate utility instances (`*Writer/*Reader`, `*Context`, etc...)\n* Utilize dynamic code generation and JIT to avoid boxing value types. Use AOT generation on platforms that prohibit JITs.\n* Cached generated formatters on static generic fields (don't use dictionary-cache because dictionary lookup is overhead). See [Resolvers](https://github.com/neuecc/MessagePack-CSharp/tree/209f301e2e595ed366408624011ba2e856d23429/src/MessagePack/Resolvers)\n* Heavily tuned dynamic IL code generation and JIT to avoid boxing value types. See [DynamicObjectTypeBuilder](https://github.com/neuecc/MessagePack-CSharp/blob/209f301e2e595ed366408624011ba2e856d23429/src/MessagePack/Resolvers/DynamicObjectResolver.cs#L142-L754). Use AOT generation on platforms that prohibit JIT.\n* Call the Primitive API directly when IL code generation determines target types to be  primitive.\n* Reduce branching of variable length formats when IL code generation knows the target type (integer/string) ranges\n* Don't use the `IEnumerable<T>` abstraction to iterate over collections when possible, [see: CollectionFormatterBase](https://github.com/neuecc/MessagePack-CSharp/blob/209f301e2e595ed366408624011ba2e856d23429/src/MessagePack/Formatters/CollectionFormatter.cs#L192-L355) and derived collection formatters\n* Use pre-generated lookup tables to reduce checks of mgpack type constraints, [see: MessagePackBinary](https://github.com/neuecc/MessagePack-CSharp/blob/209f301e2e595ed366408624011ba2e856d23429/src/MessagePack/MessagePackBinary.cs#L15-L212)\n* Uses optimized type key dictionary for non-generic methods, [see: ThreadsafeTypeKeyHashTable](https://github.com/neuecc/MessagePack-CSharp/blob/91312921cb7fe987f48336768c898a76ac7dbb40/src/MessagePack/Internal/ThreadsafeTypeKeyHashTable.cs)\n* Avoid string key decoding for lookup maps (string key and use automata based name lookup with inlined IL code generation, see: [AutomataDictionary](https://github.com/neuecc/MessagePack-CSharp/blob/bcedbce3fd98cb294210d6b4a22bdc4c75ccd916/src/MessagePack/Internal/AutomataDictionary.cs)\n* To encode string keys, use pre-generated member name bytes and fixed sized byte array copies in IL, see: [UnsafeMemory.cs](https://github.com/neuecc/MessagePack-CSharp/blob/f17ddc5d107d3a2f66f60398b214ef87919ff892/src/MessagePack/Internal/UnsafeMemory.cs)\n\nBefore creating this library, I implemented a fast serializer with [ZeroFormatter#Performance](https://github.com/neuecc/ZeroFormatter#performance). This is a further evolved implementation. MessagePack for C# is always fast and optimized for all types (primitive, small struct, large object, any collections).\n\n### <a name=\"deserialize-performance\"></a>Deserialization Performance for different options\n\nPerformance varies depending on the options used. This is a micro benchmark with [BenchmarkDotNet](https://github.com/dotnet/BenchmarkDotNet). The target object has 9 members (`MyProperty1` ~ `MyProperty9`), values are zero.\n\n |              Method |        Mean | Error | Scaled |  Gen 0 | Allocated |\n |-------------------- |------------:|------:|-------:|-------:|----------:|\n |            M IntKey |    72.67 ns |    NA |   1.00 | 0.0132 |      56 B |\n |         M StringKey |   217.95 ns |    NA |   3.00 | 0.0131 |      56 B |\n |   M Typeless_IntKey |   176.71 ns |    NA |   2.43 | 0.0131 |      56 B |\n |M Typeless_StringKey |   378.64 ns |    NA |   5.21 | 0.0129 |      56 B |\n |       MsgPackCliMap | 1,355.26 ns |    NA |  18.65 | 0.1431 |     608 B |\n |     MsgPackCliArray |   455.28 ns |    NA |   6.26 | 0.0415 |     176 B |\n |         ProtobufNet |   265.85 ns |    NA |   3.66 | 0.0319 |     136 B |\n |            Hyperion |   366.47 ns |    NA |   5.04 | 0.0949 |     400 B |\n |       JsonNetString | 2,783.39 ns |    NA |  38.30 | 0.6790 |    2864 B |\n | JsonNetStreamReader | 3,297.90 ns |    NA |  45.38 | 1.4267 |    6000 B |\n |           JilString |   553.65 ns |    NA |   7.62 | 0.0362 |     152 B |\n |     JilStreamReader | 1,408.46 ns |    NA |  19.38 | 0.8450 |    3552 B |\n\n`IntKey`, `StringKey`, `Typeless_IntKey`, `Typeless_StringKey` are MessagePack for C# options. All MessagePack for C# options achieve zero memory allocations in the deserialization process. `JsonNetString`/`JilString` is deserialized from strings. `JsonNetStreamReader`/`JilStreamReader` is deserialized from UTF-8 byte arrays using `StreamReader`. Deserialization is normally read from Stream. Thus, it will be restored from byte arrays (or Stream) instead of strings.\n\nMessagePack for C# `IntKey` is the fastest. `StringKey` is slower than `IntKey` because matching the character string of property names is required. `IntKey` works by reading the array length, then `for (array length) { binary decode }`. `StringKey` works by reading map length, `for (map length) { decode key, lookup key, binary decode }`, so it requires an additional two steps (decoding of keys and lookups of keys).\n\nString key is often a useful, contractless, simple replacement of JSON, interoperability with other languages, and more robust versioning. MessagePack for C# is also optimized for string keys as much a possible. First of all, it does not decode UTF-8 byte arrays to full string for matching with the member name; instead it will look up the byte arrays as it is (to avoid decoding costs and extra memory allocations).\n\nAnd It will try to match each `long type` (per 8 character, if it is not enough, pad with 0) using [automata](https://en.wikipedia.org/wiki/Automata_theory) and inline it when generating IL code.\n\n![image](https://user-images.githubusercontent.com/46207/29754771-216b40e2-8bc7-11e7-8310-1c3602e80a08.png)\n\nThis also avoids calculating the hash code of byte arrays, and the comparison can be made several times faster using the long type.\n\nThis is the sample of decompiled generated deserializer code, decompiled using [ILSpy](http://ilspy.net/).\n\n![image](https://user-images.githubusercontent.com/46207/29754804-b5ba0f44-8bc7-11e7-9f6b-0c8f3c041237.png)\n\nIf the number of nodes is large, searches will use an embedded binary search.\n\nExtra note, this is serialization benchmark result.\n\n |              Method |        Mean | Error | Scaled |  Gen 0 | Allocated |\n |-------------------- |------------:|------:|-------:|-------:|----------:|\n |              IntKey |    84.11 ns |    NA |   1.00 | 0.0094 |      40 B |\n |           StringKey |   126.75 ns |    NA |   1.51 | 0.0341 |     144 B |\n |     Typeless_IntKey |   183.31 ns |    NA |   2.18 | 0.0265 |     112 B |\n |  Typeless_StringKey |   193.95 ns |    NA |   2.31 | 0.0513 |     216 B |\n |       MsgPackCliMap |   967.68 ns |    NA |  11.51 | 0.1297 |     552 B |\n |     MsgPackCliArray |   284.20 ns |    NA |   3.38 | 0.1006 |     424 B |\n |         ProtobufNet |   176.43 ns |    NA |   2.10 | 0.0665 |     280 B |\n |            Hyperion |   280.14 ns |    NA |   3.33 | 0.1674 |     704 B |\n |       ZeroFormatter |   149.95 ns |    NA |   1.78 | 0.1009 |     424 B |\n |       JsonNetString | 1,432.55 ns |    NA |  17.03 | 0.4616 |    1944 B |\n | JsonNetStreamWriter | 1,775.72 ns |    NA |  21.11 | 1.5526 |    6522 B |\n |           JilString |   547.51 ns |    NA |   6.51 | 0.3481 |    1464 B |\n |     JilStreamWriter |   778.78 ns |    NA |   9.26 | 1.4448 |    6066 B |\n\n Of course, `IntKey` is fastest but `StringKey` also performs reasonably well.\n\n### <a name=\"string-interning\"></a>String interning\n\nThe msgpack format does not provide for reusing strings in the data stream.\nThis naturally leads the deserializer to create a new `string` object for every string encountered,\neven if it is equal to another string previously encountered.\n\nWhen deserializing data that may contain the same strings repeatedly it can be worthwhile\nto have the deserializer take a little extra time to check whether it has seen a given string before\nand reuse it if it has.\n\nTo enable string interning on *all* string values, use a resolver that specifies `StringInterningFormatter`\nbefore any of the standard ones, like this:\n\n```cs\nvar options = MessagePackSerializerOptions.Standard.WithResolver(\n    CompositeResolver.Create(\n        new IMessagePackFormatter[] { new StringInterningFormatter() },\n        new IFormatterResolver[] { StandardResolver.Instance }));\n\nMessagePackSerializer.Deserialize<ClassOfStrings>(data, options);\n```\n\nIf you know which fields of a particular type are likely to contain duplicate strings,\nyou can apply the string interning formatter to just those fields so the deserializer only pays\nfor the interned string check where it matters most.\nNote that this technique requires a `[MessagePackObject]` or `[DataContract]` class.\n\n```cs\n[MessagePackObject]\npublic class ClassOfStrings\n{\n    [Key(0)]\n    [MessagePackFormatter(typeof(StringInterningFormatter))]\n    public string InternedString { get; set; }\n\n    [Key(1)]\n    public string OrdinaryString { get; set; }\n}\n```\n\nIf you are writing your own formatter for some type that contains strings,\nyou can call on the `StringInterningFormatter` directly from your formatter as well for the strings.\n\n## LZ4 Compression\n\nMessagePack is a fast and *compact* format but it is not compression. [LZ4](https://github.com/lz4/lz4) is an extremely fast compression algorithm, and using it MessagePack for C# can achieve extremely fast performance as well as extremely compact binary sizes!\n\nMessagePack for C# has built-in LZ4 support. You can activate it using a modified options object and passing it into an API like this:\n\n```cs\nvar lz4Options = MessagePackSerializerOptions.Standard.WithCompression(MessagePackCompression.Lz4BlockArray);\nMessagePackSerializer.Serialize(obj, lz4Options);\n```\n\n`MessagePackCompression` has two modes, `Lz4Block` and `Lz4BlockArray`. Neither is a simple binary LZ4 compression, but a special compression integrated into the serialization pipeline, using MessagePack `ext` code (`Lz4BlockArray (98)` or `Lz4Block (99)`). Therefore, it is not readily compatible with compression offered in other languages.\n\n`Lz4Block` compresses an entire MessagePack sequence as a single LZ4 block. This is the simple compression that achieves best compression ratio, at the cost of copying the entire sequence when necessary to get contiguous memory.\n\n`Lz4BlockArray` compresses an entire MessagePack sequence as a array of LZ4 blocks. Compressed/decompressed blocks are  chunked and thus do not enter the GC's Large-Object-Heap, but the compression ratio is slightly worse.\n\nWe recommend to use `Lz4BlockArray` as the default when using compression.\nFor compatibility with MessagePack v1.x, use `Lz4Block`.\n\nRegardless of which LZ4 option is set at the deserialization, both methods can be deserialized. For example, when the `Lz4BlockArray` option was used, binary data using either `Lz4Block` and `Lz4BlockArray` can be deserialized. Neither can be decompressed and hence deserialized when the compression option is set to `None`.\n\n### Attributions\n\nLZ4 compression support is using Milosz Krajewski's [lz4net](https://github.com/MiloszKrajewski/lz4net) code with some modifications.\n\n## <a name=\"comparison\"></a>Comparison with protobuf, JSON, ZeroFormatter\n\n[protobuf-net](https://github.com/mgravell/protobuf-net) is major, widely used binary-format library on .NET. I love protobuf-net and respect their great work. But when you use protobuf-net as a general purpose serialization format, you may encounter an annoying issue.\n\n```csharp\n[ProtoContract]\npublic class Parent\n{\n    [ProtoMember(1)]\n    public int Primitive { get; set; }\n    [ProtoMember(2)]\n    public Child Prop { get; set; }\n    [ProtoMember(3)]\n    public int[] Array { get; set; }\n}\n\n[ProtoContract]\npublic class Child\n{\n    [ProtoMember(1)]\n    public int Number { get; set; }\n}\n\nusing (var ms = new MemoryStream())\n{\n    // serialize null.\n    ProtoBuf.Serializer.Serialize<Parent>(ms, null);\n\n    ms.Position = 0;\n    var result = ProtoBuf.Serializer.Deserialize<Parent>(ms);\n\n    Console.WriteLine(result != null); // True, not null. but all property are zero formatted.\n    Console.WriteLine(result.Primitive); // 0\n    Console.WriteLine(result.Prop); // null\n    Console.WriteLine(result.Array); // null\n}\n\nusing (var ms = new MemoryStream())\n{\n    // serialize empty array.\n    ProtoBuf.Serializer.Serialize<Parent>(ms, new Parent { Array = System.Array.Empty<int>() });\n\n    ms.Position = 0;\n    var result = ProtoBuf.Serializer.Deserialize<Parent>(ms);\n\n    Console.WriteLine(result.Array == null); // True, null!\n}\n```\n\nprotobuf(-net) cannot handle null and empty collection correctly, because protobuf has no `null` representation (see [this SO answer from a protobuf-net author](https://stackoverflow.com/questions/21631428/protobuf-net-deserializes-empty-collection-to-null-when-the-collection-is-a-prop/21632160#21632160)).\n\n[MessagePack's type system](https://github.com/msgpack/msgpack/blob/master/spec.md#type-system) can correctly serialize the entire C# type system. This is a strong reason to recommend MessagePack over protobuf.\n\nProtocol Buffers have good IDL and [gRPC](https://www.grpc.io/) support. If you want to use IDL, I recommend [Google.Protobuf](https://github.com/google/protobuf/tree/master/csharp/src/Google.Protobuf) over MessagePack.\n\nJSON is good general-purpose format. It is simple, human-readable and thoroughly-enough specified. [Utf8Json](https://github.com/neuecc/Utf8Json) - which I created as well - adopts same architecture as MessagePack for C# and avoids encoding/decoding costs as much as possible just like this library does. If you want to know more about binary vs text formats, see [Utf8Json/which serializer should be used](https://github.com/neuecc/Utf8Json#which-serializer-should-be-used).\n\n[ZeroFormatter](https://github.com/neuecc/ZeroFormatter/) is similar as [FlatBuffers](https://google.github.io/flatbuffers/) but specialized to C#, and special in that regard. Deserialization is infinitely fast but the produced binary size is larger. And ZeroFormatter's caching algorithm requires additional memory.\n\nFor many common uses, MessagePack for C# would be a better fit.\n\n## Hints to achieve maximum performance when using MessagePack for C#\n\nMessagePack for C# prioritizes maximum performance by default. However, there are also some options that sacrifice performance for convenience.\n\n### Use indexed keys instead of string keys (Contractless)\n\nThe [Deserialization Performance for different options](https://github.com/neuecc/MessagePack-CSharp#deserialize-performance) section shows the results of indexed keys (`IntKey`) vs string keys (`StringKey`) performance. Indexed keys serialize the object graph as a MessagePack array. String keys serializes the object graph as a MessagePack map.\n\nFor example this type is serialized to\n\n```csharp\n[MessagePackObject]\npublic class Person\n{\n    [Key(0)] or [Key(\"name\")]\n    public string Name { get; set;}\n    [Key(1)] or [Key(\"age\")]\n    public int Age { get; set;}\n}\n\nnew Person { Name = \"foobar\", Age = 999 }\n```\n\n* `IntKey`: `[\"foobar\", 999]`\n* `StringKey`: `{\"name:\"foobar\",\"age\":999}`.\n\n `IntKey` is always fast in both serialization and deserialization because it does not have to handle and lookup key names, and always has the smaller binary size.\n\n`StringKey` is often a useful, contractless, simple replacement for JSON, interoperability with other languages with MessagePack support, and less error prone versioning. But to achieve maximum performance, use `IntKey`.\n\n### Create own custom composite resolver\n\n`CompositeResolver.Create` is an easy way to create composite resolvers. But formatter lookups have some overhead. If you create a custom resolver (or use `StaticCompositeResolver.Instance`), you can avoid this overhead.\n\n```csharp\npublic class MyApplicationResolver : IFormatterResolver\n{\n    public static readonly IFormatterResolver Instance = new MyApplicationResolver();\n\n    // configure your custom resolvers.\n    private static readonly IFormatterResolver[] Resolvers = new IFormatterResolver[]\n    {\n    };\n\n    private MyApplicationResolver() { }\n\n    public IMessagePackFormatter<T> GetFormatter<T>()\n    {\n        return Cache<T>.Formatter;\n    }\n\n    private static class Cache<T>\n    {\n        public static IMessagePackFormatter<T> Formatter;\n\n        static Cache()\n        {\n            // configure your custom formatters.\n            if (typeof(T) == typeof(XXX))\n            {\n                Formatter = new ICustomFormatter();\n                return;\n            }\n\n            foreach (var resolver in Resolvers)\n            {\n                var f = resolver.GetFormatter<T>();\n                if (f != null)\n                {\n                    Formatter = f;\n                    return;\n                }\n            }\n        }\n    }\n}\n```\n\n> NOTE: If you are creating a library, recommend using the above custom resolver instead of `CompositeResolver.Create`. Also, libraries must not use `StaticCompositeResolver` - as it is global state - to avoid compatibility issues.\n\n### Use native resolvers\n\nBy default, MessagePack for C# serializes GUID as string. This is much slower than the native .NET format GUID. The same applies to Decimal. If your application makes heavy use of GUID or Decimal and you don't have to worry about interoperability with other languages, you can replace them with the native serializers `NativeGuidResolver` and `NativeDecimalResolver` respectively.\n\nAlso, `DateTime` is serialized using the MessagePack timestamp format. By using the `NativeDateTimeResolver`, it is possible to maintain Kind and perform faster serialization.\n\n### Be careful when copying buffers\n\n`MessagePackSerializer.Serialize` returns `byte[]` in default. The final `byte[]` is copied from an internal buffer pool. That is an extra cost.  You can use `IBufferWriter<T>` or the `Stream` API to write to buffers directly. If you want to use a buffer pool outside of the serializer, you should implement custom `IBufferWriter<byte>` or use an existing one such as [`Sequence<T>`](https://github.com/AArnott/Nerdbank.Streams/blob/master/doc/Sequence.md) from the [Nerdbank.Streams](https://nuget.org/packages/Nerdbank.Streams) package.\n\nDuring deserialization, `MessagePackSerializer.Deserialize(ReadOnlyMemory<byte> buffer)` is better than the `Deserialize(Stream stream)` overload. This is because the Stream API version starts by reading the data, generating a `ReadOnlySequence<byte>`, and only then starts the deserialization.\n\n### Choosing compression\n\nCompression is generally effective when there is duplicate data. In MessagePack, arrays containing objects using string keys (Contractless) can be compressed efficiently because compression can be applied to many duplicate property names. Indexed keys compression is not as effectively compressed as string keys, but indexed keys are smaller in the first place.\n\nThis is some example benchmark performance data;\n\n|         Serializer |      Mean |  DataSize |\n|------------------- |----------:|----------:|\n|             IntKey |  2.941 us |  469.00 B |\n|        IntKey(Lz4) |  3.449 us |  451.00 B |\n|          StringKey |  4.340 us | 1023.00 B |\n|     StringKey(Lz4) |  5.469 us |  868.00 B |\n\n`IntKey(Lz4)` is not as effectively compressed, but performance is still somewhat degraded. On the other hand, `StringKey` can be expected to have a sufficient effect on the binary size. However, this is just an example. Compression can be quite effective depending on the data, too, or have little effect other than slowing down your program. There are also cases in which well-compressible data exists in the values (such as long strings, e.g. containing HTML data with many repeated HTML tags). It is important to verify the actual effects of compression on a case by case basis.\n\n## Extensions\n\nMessagePack for C# has extension points that enable you to provide optimal serialization support for custom types. There are official extension support packages.\n\n```ps1\nInstall-Package MessagePack.ReactiveProperty\nInstall-Package MessagePack.UnityShims\nInstall-Package MessagePack.AspNetCoreMvcFormatter\n```\n\nThe `MessagePack.ReactiveProperty` package adds support for types of the [ReactiveProperty](https://github.com/runceel/ReactiveProperty) library. It adds `ReactiveProperty<>`, `IReactiveProperty<>`, `IReadOnlyReactiveProperty<>`, `ReactiveCollection<>`, `Unit` serialization support. It is useful for save viewmodel state.\n\nThe `MessagePack.UnityShims` package provides shims for [Unity](https://unity3d.com/)'s standard structs (`Vector2`, `Vector3`, `Vector4`, `Quaternion`, `Color`, `Bounds`, `Rect`, `AnimationCurve`, `Keyframe`, `Matrix4x4`, `Gradient`, `Color32`, `RectOffset`, `LayerMask`, `Vector2Int`, `Vector3Int`, `RangeInt`, `RectInt`, `BoundsInt`) and corresponding formatters. It can enable proper communication between servers and Unity clients.\n\nAfter installation, extension packages must be enabled, by creating composite resolvers. Here is an example showing how to enable all extensions.\n\n```csharp\n// Set extensions to default resolver.\nvar resolver = MessagePack.Resolvers.CompositeResolver.Create(\n    // enable extension packages first\n    ReactivePropertyResolver.Instance,\n    MessagePack.Unity.Extension.UnityBlitResolver.Instance,\n    MessagePack.Unity.UnityResolver.Instance,\n\n    // finally use standard (default) resolver\n    StandardResolver.Instance\n);\nvar options = MessagePackSerializerOptions.Standard.WithResolver(resolver);\n\n// Pass options every time or set as default\nMessagePackSerializer.DefaultOptions = options;\n```\n\nFor configuration details, see: [Extension Point section](#resolvers).\n\nThe `MessagePack.AspNetCoreMvcFormatter` is add-on for [ASP.NET Core MVC](https://github.com/aspnet/Mvc)'s serialization to boost up performance. This is configuration sample.\n\n```csharp\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddMvc().AddMvcOptions(option =>\n    {\n        option.OutputFormatters.Clear();\n        option.OutputFormatters.Add(new MessagePackOutputFormatter(ContractlessStandardResolver.Options));\n        option.InputFormatters.Clear();\n        option.InputFormatters.Add(new MessagePackInputFormatter(ContractlessStandardResolver.Options));\n    });\n}\n```\n\nOther authors are creating extension packages, too.\n\n* [MagicOnion](https://github.com/Cysharp/MagicOnion) - gRPC based HTTP/2 RPC Streaming Framework\n* [MasterMemory](https://github.com/Cysharp/MasterMemory) - Embedded Readonly In-Memory Document Database\n\nYou can make your own extension serializers or integrate with frameworks. Let's create and share!\n\n* [MessagePack.FSharpExtensions](https://github.com/pocketberserker/MessagePack.FSharpExtensions) - supports F# list, set, map, unit, option, discriminated union\n* [MessagePack.NodaTime](https://github.com/ARKlab/MessagePack) - Support for NodaTime types to MessagePack C#\n* [WebApiContrib.Core.Formatter.MessagePack](https://github.com/WebApiContrib/WebAPIContrib.Core#formatters) - supports ASP.NET Core MVC ([details in blog post](https://www.strathweb.com/2017/06/using-messagepack-with-asp-net-core-mvc/))\n* [MessagePack.MediaTypeFormatter](https://github.com/sketch7/MessagePack.MediaTypeFormatter) - MessagePack MediaTypeFormatter\n\n## Experimental Features\n\nMessagePack for C# has experimental features which provides you with very performant formatters. There is an official package.\n\n```ps1\nInstall-Package MessagePack.Experimental\n```\n\nFor detailed information, see: [Experimental.md](src/MessagePack.Experimental/Experimental.md)\n\n# API\n\n## High-Level API (`MessagePackSerializer`)\n\nThe `MessagePackSerializer` class is the entry point of MessagePack for C#. Static methods make up the main API of MessagePack for C#.\n\n| API | Description |\n| --- | --- |\n| `Serialize<T>` | Serializes an object graph to a MessagePack binary blob. Async variant for Stream available. Non-generic overloads available. |\n| `Deserialize<T>` | Deserializes a MessagePack binary to an object graph. Async variant for Stream available. Non-generic overloads available. |\n| `SerializeToJson` | Serialize a MessagePack-compatible object graph to JSON instead of MessagePack. Useful for debugging. |\n| `ConvertToJson` | Convert MessagePack binary to JSON. Useful for debugging.  |\n| `ConvertFromJson` | Convert JSON to a MessagePack binary. |\n\nThe `MessagePackSerializer.Typeless` class offers most of the same APIs as above, but removes all type arguments from the API, forcing serialization to include the full type name of the root object. It uses the `TypelessContractlessStandardResolver`. Consider the result to be a .NET-specific MessagePack binary that isn't readily compatible with MessagePack deserializers in other runtimes.\n\nMessagePack for C# fundamentally serializes using `IBufferWriter<byte>` and deserializes using `ReadOnlySequence<byte>` or `Memory<byte>`. Method overloads are provided to conveniently use it with common buffer types and the .NET `Stream` class, but some of these convenience overloads require copying buffers once and therefore have a certain overhead.\n\nThe high-level API uses a memory pool internally to avoid unnecessary memory allocation. If result size is under 64K, it allocates GC memory only for the return bytes.\n\nEach serialize/deserialize method takes an optional `MessagePackSerializerOptions` parameter which can be used to specify a custom `IFormatterResolver` to use or to activate LZ4 compression support.\n\n### Multiple MessagePack structures on a single `Stream`\n\nTo deserialize a `Stream` that contains multiple consecutive MessagePack data structures,\nyou can use the `MessagePackStreamReader` class to efficiently identify the `ReadOnlySequence<byte>`\nfor each data structure and deserialize it. For example:\n\n```cs\nstatic async Task<List<T>> DeserializeListFromStreamAsync<T>(Stream stream, CancellationToken cancellationToken)\n{\n    var dataStructures = new List<T>();\n    using (var streamReader = new MessagePackStreamReader(stream))\n    {\n        while (await streamReader.ReadAsync(cancellationToken) is ReadOnlySequence<byte> msgpack)\n        {\n            dataStructures.Add(MessagePackSerializer.Deserialize<T>(msgpack, cancellationToken: cancellationToken));\n        }\n    }\n\n    return dataStructures;\n}\n```\n\n## Low-Level API (`IMessagePackFormatter<T>`)\n\nThe `IMessagePackFormatter<T>` interface is responsible for serializing a unique type. For example `Int32Formatter : IMessagePackFormatter<Int32>` represents Int32 MessagePack serializer.\n\n```csharp\npublic interface IMessagePackFormatter<T>\n{\n    void Serialize(ref MessagePackWriter writer, T value, MessagePackSerializerOptions options);\n    T Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options);\n}\n```\n\nMany built-in formatters exists under `MessagePack.Formatters`. Your custom types are usually automatically supported with the built-in type resolvers that generate new `IMessagePackFormatter<T>` types on-the-fly using dynamic code generation. See our [AOT code generation](#aot) support for platforms that do not support this.\n\nHowever, some types - especially those provided by third party libraries or the runtime itself - cannot be appropriately annotated, and contractless serialization would produce inefficient or even wrong results.\nTo take more control over the serialization of such custom types, write your own `IMessagePackFormatter<T>` implementation.\nHere is an example of such a custom formatter implementation. Note its use of the primitive API that is described in the next section.\n\n```csharp\n/// <summary>Serializes a <see cref=\"FileInfo\" /> by its full path as a string.</summary>\npublic class FileInfoFormatter : IMessagePackFormatter<FileInfo>\n{\n    public void Serialize(\n      ref MessagePackWriter writer, FileInfo value, MessagePackSerializerOptions options)\n    {\n        if (value == null)\n        {\n            writer.WriteNil();\n            return;\n        }\n\n        writer.WriteString(value.FullName);\n    }\n\n    public FileInfo Deserialize(\n      ref MessagePackReader reader, MessagePackSerializerOptions options)\n    {\n        if (reader.TryReadNil())\n        {\n            return null;\n        }\n\n        options.Security.DepthStep(ref reader);\n\n        var path = reader.ReadString();\n\n        reader.Depth--;\n        return new FileInfo(path);\n    }\n}\n```\n\nThe `DepthStep` and `Depth--` statements provide a level of security while deserializing untrusted data\nthat might otherwise be able to execute a denial of service attack by sending MessagePack data that would\ndeserialize into a very deep object graph leading to a `StackOverflowException` that would crash the process.\nThis pair of statements should surround the bulk of any `IMessagePackFormatter<T>.Deserialize` method.\n\n**Important**: A message pack formatter must *read or write exactly one data structure*.\nIn the above example we just read/write a string. If you have more than one element to write out,\nyou must precede it with a map or array header. You must read the entire map/array when deserializing.\nFor example:\n\n```csharp\npublic class MySpecialObjectFormatter : IMessagePackFormatter<MySpecialObject>\n{\n    public void Serialize(\n      ref MessagePackWriter writer, MySpecialObject value, MessagePackSerializerOptions options)\n    {\n        if (value == null)\n        {\n            writer.WriteNil();\n            return;\n        }\n\n        writer.WriteArrayHeader(2);\n        writer.WriteString(value.FullName);\n        writer.WriteString(value.Age);\n    }\n\n    public MySpecialObject Deserialize(\n      ref MessagePackReader reader, MessagePackSerializerOptions options)\n    {\n        if (reader.TryReadNil())\n        {\n            return null;\n        }\n\n        options.Security.DepthStep(ref reader);\n\n        string fullName = null;\n        int age = 0;\n\n        // Loop over *all* array elements independently of how many we expect,\n        // since if we're serializing an older/newer version of this object it might\n        // vary in number of elements that were serialized, but the contract of the formatter\n        // is that exactly one data structure must be read, regardless.\n        // Alternatively, we could check that the size of the array/map is what we expect\n        // and throw if it is not.\n        int count = reader.ReadArrayHeader();\n        for (int i = 0; i < count; i++)\n        {\n            switch (i)\n            {\n                case 0:\n                    fullName = reader.ReadString();\n                    break;\n                case 1:\n                    age = reader.ReadInt32();\n                    break;\n                default:\n                    reader.Skip();\n                    break;\n            }\n        }\n\n        reader.Depth--;\n        return new MySpecialObject(fullName, age);\n    }\n}\n```\n\nYour custom formatters must be discoverable via some `IFormatterResolver`. Learn more in our [resolvers](#resolvers) section.\n\nYou can see many other samples from [builtin formatters](https://github.com/neuecc/MessagePack-CSharp/tree/master/src/MessagePack/Formatters).\n\n## Primitive API (`MessagePackWriter`, `MessagePackReader`)\n\nThe `MessagePackWriter` and `MessagePackReader` structs make up the lowest-level API. They read and write the primitives types defined in the MessagePack specification.\n\n### `MessagePackReader`\n\nA `MessagePackReader` can efficiently read from `ReadOnlyMemory<byte>` or `ReadOnlySequence<byte>` without any allocations, except to allocate a new `string` as required by the `ReadString()` method. All other methods return either value structs or `ReadOnlySequence<byte>` slices for extensions/arrays.\nReading directly from `ReadOnlySequence<byte>` means the reader can directly consume some modern high performance APIs such as `PipeReader`.\n\n| Method | Description |\n| --- | --- |\n| `Skip` | Advances the reader's position past the current value. If the value is complex (e.g. map, array) the entire structure is skipped. |\n| `Read*` | Read and return a value whose type is named by the method name from the current reader position. Throws if the expected type does not match the actual type. When reading numbers, the type need not match the binary-specified type exactly. The numeric value will be coerced into the desired type or throw if the integer type is too small for a large value. |\n| `TryReadNil` | Advances beyond the current value if the current value is `nil` and returns `true`; otherwise leaves the reader's position unchanged and returns `false`. |\n| `ReadBytes` | Returns a slice of the input sequence representing the contents of a `byte[]`, and advances the reader. |\n| `ReadStringSequence` | Returns a slice of the input sequence representing the contents of a `string` without decoding it, and advances the reader. |\n| `Clone` | Creates a new `MessagePackReader` with the specified input sequence and the same settings as the original reader. |\n| `CreatePeekReader` | Creates a new reader with the same position as this one, allowing the caller to \"read ahead\" without impacting the original reader's position. |\n| `NextCode` | Reads the low-level MessagePack `byte` that describes the type of the next value. Does not advance the reader. See [MessagePack format of first byte](https://github.com/msgpack/msgpack/blob/master/spec.md#overview). Its static class has `ToMessagePackType` and `ToFormatName` utility methods. `MessagePackRange` means Min-Max fix range of MessagePack format. |\n| `NextMessagePackType` | Describes the `NextCode` value as a higher level category. Does not advance the reader. See [MessagePack spec of source types](https://github.com/msgpack/msgpack/blob/master/spec.md#serialization-type-to-format-conversion). |\n| (others) | Other methods and properties as described by the .xml doc comment file and Intellisense. |\n\nThe `MessagePackReader` is capable of automatically interpreting both the old and new MessagePack spec.\n\n### `MessagePackWriter`\n\nA `MessagePackWriter` writes to a given instance of `IBufferWriter<byte>`. Several common implementations of this exist, allowing zero allocations and minimal buffer copies while writing directly to several I/O APIs including `PipeWriter`.\n\nThe `MessagePackWriter` writes the new MessagePack spec by default, but can write MessagePack compatible with the old spec by setting the `OldSpec` property to `true`.\n\n| Method | Description |\n| --- | --- |\n| `Clone` | Creates a new `MessagePackWriter` with the specified underlying `IBufferWriter<byte>` and the same settings as the original writer. |\n| `Flush` | Writes any buffered bytes to the underlying `IBufferWriter<byte>`. |\n| `WriteNil` | Writes the MessagePack equivalent of .NET's `null` value. |\n| `Write` | Writes any MessagePack primitive value in the most compact form possible. Has overloads for every primitive type defined by the MessagePack spec. |\n| `Write*IntType*` | Writes an integer value in exactly the MessagePack type specified, even if a more compact format exists. |\n| `WriteMapHeader` | Introduces a map by specifying the number of key=value pairs it contains. |\n| `WriteArrayHeader` | Introduces an array by specifying the number of elements it contains. |\n| `WriteExtensionFormat` | Writes the full content of an extension value including length, type code and content. |\n| `WriteExtensionFormatHeader` | Writes just the header (length and type code) of an extension value. |\n| `WriteRaw` | Copies the specified bytes directly to the underlying `IBufferWriter<byte>` without any validation. |\n| (others) | Other methods and properties as described by the .xml doc comment file and Intellisense. |\n\n`DateTime` is serialized to [MessagePack Timestamp format](https://github.com/msgpack/msgpack/blob/master/spec.md#formats-timestamp), it serialize/deserialize UTC and loses `Kind` info and requires that `MessagePackWriter.OldSpec == false`.\nIf you use the `NativeDateTimeResolver`, `DateTime` values will be serialized using .NET's native `Int64` representation, which preserves `Kind` info but may not be interoperable with non-.NET platforms.\n\n## <a name=\"resolvers\"></a>Main Extension Point (`IFormatterResolver`)\n\nAn `IFormatterResolver` is storage of typed serializers. The `MessagePackSerializer` API accepts a `MessagePackSerializerOptions` object which specifies the `IFormatterResolver` to use, allowing customization of the serialization of complex types.\n\n| Resolver Name | Description |\n| --- | --- |\n| BuiltinResolver | Builtin primitive and standard classes resolver. It includes primitive(int, bool, string...) and there nullable, array and list. and some extra builtin types(`Guid`, `Uri`, `BigInteger`, etc...). |\n| StandardResolver | Composited resolver. It resolves in the following order `builtin -> attribute -> dynamic enum -> dynamic generic -> dynamic union -> dynamic object -> dynamic object fallback`. This is the default of MessagePackSerializer. |\n| ContractlessStandardResolver | Composited `StandardResolver`(except dynamic object fallback) -> `DynamicContractlessObjectResolver` -> `DynamicObjectTypeFallbackResolver`. It enables contractless serialization. |\n| StandardResolverAllowPrivate | Same as StandardResolver but allow serialize/deserialize private members. |\n| ContractlessStandardResolverAllowPrivate | Same as ContractlessStandardResolver but allow serialize/deserialize private members. |\n| PrimitiveObjectResolver | MessagePack primitive object resolver. It is used fallback in `object` type and supports `bool`, `char`, `sbyte`, `byte`, `short`, `int`, `long`, `ushort`, `uint`, `ulong`, `float`, `double`, `DateTime`, `string`, `byte[]`, `ICollection`, `IDictionary`. |\n| DynamicObjectTypeFallbackResolver | Serialize is used type in from `object` type, deserialize is used PrimitiveObjectResolver. |\n| AttributeFormatterResolver | Get formatter from `[MessagePackFormatter]` attribute. |\n| CompositeResolver | Composes several resolvers and/or formatters together in an ordered list, allowing reuse and overriding of behaviors of existing resolvers and formatters. |\n| NativeDateTimeResolver | Serialize by .NET native DateTime binary format. It keeps `DateTime.Kind` that loses by standard(MessagePack timestamp) format. |\n| NativeGuidResolver | Serialize by .NET native Guid binary representation. It is faster than standard(string) representation. |\n| NativeDecimalResolver | Serialize by .NET native decimal binary representation. It is faster than standard(string) representation. |\n| DynamicEnumResolver | Resolver of enum and there nullable, serialize there underlying type. It uses dynamic code generation to avoid boxing and boostup performance serialize there name. |\n| DynamicEnumAsStringResolver | Resolver of enum and there nullable.  It uses reflection call for resolve nullable at first time. |\n| DynamicGenericResolver | Resolver of generic type(`Tuple<>`, `List<>`, `Dictionary<,>`, `Array`, etc). It uses reflection call for resolve generic argument at first time. |\n| DynamicUnionResolver | Resolver of interface marked by UnionAttribute. It uses dynamic code generation to create dynamic formatter. |\n| DynamicObjectResolver | Resolver of class and struct made by MessagePackObjectAttribute. It uses dynamic code generation to create dynamic formatter. |\n| DynamicContractlessObjectResolver | Resolver of all classes and structs. It does not needs `MessagePackObjectAttribute` and serialized key as string(same as marked `[MessagePackObject(true)]`). |\n| DynamicObjectResolverAllowPrivate | Same as DynamicObjectResolver but allow serialize/deserialize private members. |\n| DynamicContractlessObjectResolverAllowPrivate | Same as DynamicContractlessObjectResolver but allow serialize/deserialize private members. |\n| TypelessObjectResolver | Used for `object`, embed .NET type in binary by `ext(100)` format so no need to pass type in deserialization.  |\n| TypelessContractlessStandardResolver | Composited resolver. It resolves in the following order `nativedatetime -> builtin -> attribute -> dynamic enum -> dynamic generic -> dynamic union -> dynamic object -> dynamiccontractless -> typeless`. This is the default of `MessagePackSerializer.Typeless`  |\n\nEach instance of `MessagePackSerializer` accepts only a single resolver. Most object graphs will need more than one for serialization, so composing a single resolver made up of several is often required, and can be done with the `CompositeResolver` as shown below:\n\n```csharp\n// Do this once and store it for reuse.\nvar resolver = MessagePack.Resolvers.CompositeResolver.Create(\n    // resolver custom types first\n    ReactivePropertyResolver.Instance,\n    MessagePack.Unity.Extension.UnityBlitResolver.Instance,\n    MessagePack.Unity.UnityResolver.Instance,\n\n    // finally use standard resolver\n    StandardResolver.Instance\n);\nvar options = MessagePackSerializerOptions.Standard.WithResolver(resolver);\n\n// Each time you serialize/deserialize, specify the options:\nbyte[] msgpackBytes = MessagePackSerializer.Serialize(myObject, options);\nT myObject2 = MessagePackSerializer.Deserialize<MyObject>(msgpackBytes, options);\n```\n\nA resolver can be set as default with `MessagePackSerializer.DefaultOptions = options`, but **WARNING**:\nWhen developing an application where you control all MessagePack-related code it may be safe to rely on this mutable static to control behavior.\nFor all other libraries or multi-purpose applications that use `MessagePackSerializer` you should explicitly specify the `MessagePackSerializerOptions` to use with each method invocation to guarantee your code behaves as you expect even when sharing an `AppDomain` or process with other MessagePack users that may change this static property.\n\nHere is sample of use `DynamicEnumAsStringResolver` with `DynamicContractlessObjectResolver` (It is Json.NET-like lightweight setting.)\n\n```csharp\n// composite same as StandardResolver\nvar resolver = MessagePack.Resolvers.CompositeResolver.Create(\n    MessagePack.Resolvers.BuiltinResolver.Instance,\n    MessagePack.Resolvers.AttributeFormatterResolver.Instance,\n\n    // replace enum resolver\n    MessagePack.Resolvers.DynamicEnumAsStringResolver.Instance,\n\n    MessagePack.Resolvers.DynamicGenericResolver.Instance,\n    MessagePack.Resolvers.DynamicUnionResolver.Instance,\n    MessagePack.Resolvers.DynamicObjectResolver.Instance,\n\n    MessagePack.Resolvers.PrimitiveObjectResolver.Instance,\n\n    // final fallback(last priority)\n    MessagePack.Resolvers.DynamicContractlessObjectResolver.Instance\n);\n```\n\nIf you want to make an extension package, you should write both a formatter and resolver\nfor easier consumption.\nHere is sample of a resolver:\n\n```csharp\npublic class SampleCustomResolver : IFormatterResolver\n{\n    // Resolver should be singleton.\n    public static readonly IFormatterResolver Instance = new SampleCustomResolver();\n\n    private SampleCustomResolver()\n    {\n    }\n\n    // GetFormatter<T>'s get cost should be minimized so use type cache.\n    public IMessagePackFormatter<T> GetFormatter<T>()\n    {\n        return FormatterCache<T>.Formatter;\n    }\n\n    private static class FormatterCache<T>\n    {\n        public static readonly IMessagePackFormatter<T> Formatter;\n\n        // generic's static constructor should be minimized for reduce type generation size!\n        // use outer helper method.\n        static FormatterCache()\n        {\n            Formatter = (IMessagePackFormatter<T>)SampleCustomResolverGetFormatterHelper.GetFormatter(typeof(T));\n        }\n    }\n}\n\ninternal static class SampleCustomResolverGetFormatterHelper\n{\n    // If type is concrete type, use type-formatter map\n    static readonly Dictionary<Type, object> formatterMap = new Dictionary<Type, object>()\n    {\n        {typeof(FileInfo), new FileInfoFormatter()}\n        // add more your own custom serializers.\n    };\n\n    internal static object GetFormatter(Type t)\n    {\n        object formatter;\n        if (formatterMap.TryGetValue(t, out formatter))\n        {\n            return formatter;\n        }\n\n        // If type can not get, must return null for fallback mechanism.\n        return null;\n    }\n}\n```\n\n## MessagePackFormatterAttribute\n\nMessagePackFormatterAttribute is a lightweight extension point of class, struct, interface, enum and property/field. This is like Json.NET's JsonConverterAttribute. For example, serialize private field, serialize x10 formatter.\n\n```csharp\n[MessagePackFormatter(typeof(CustomObjectFormatter))]\npublic class CustomObject\n{\n    string internalId;\n\n    public CustomObject()\n    {\n        this.internalId = Guid.NewGuid().ToString();\n    }\n\n    // serialize/deserialize internal field.\n    class CustomObjectFormatter : IMessagePackFormatter<CustomObject>\n    {\n        public void Serialize(ref MessagePackWriter writer, CustomObject value, MessagePackSerializerOptions options)\n        {\n            options.Resolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.internalId, options);\n        }\n\n        public CustomObject Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n        {\n            var id = options.Resolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);\n            return new CustomObject { internalId = id };\n        }\n    }\n}\n\n// per field, member\n\npublic class Int_x10Formatter : IMessagePackFormatter<int>\n{\n    public int Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n    {\n        return reader.ReadInt32() * 10;\n    }\n\n    public void Serialize(ref MessagePackWriter writer, int value, MessagePackSerializerOptions options)\n    {\n        writer.WriteInt32(value * 10);\n    }\n}\n\n[MessagePackObject]\npublic class MyClass\n{\n    // You can attach custom formatter per member.\n    [Key(0)]\n    [MessagePackFormatter(typeof(Int_x10Formatter))]\n    public int MyProperty1 { get; set; }\n}\n```\n\nFormatter is retrieved by `AttributeFormatterResolver`, it is included in `StandardResolver`.\n\n## IgnoreFormatter\n\n`IgnoreFormatter<T>` is lightweight extension point of class and struct. If there exists types that can't be serialized, you can register `IgnoreFormatter<T>` that serializes those to nil/null.\n\n```csharp\n// CompositeResolver can set custom formatter.\nvar resolver = MessagePack.Resolvers.CompositeResolver.Create(\n    new IMessagePackFormatter[]\n    {\n        // for example, register reflection infos (can not serialize)\n        new IgnoreFormatter<MethodBase>(),\n        new IgnoreFormatter<MethodInfo>(),\n        new IgnoreFormatter<PropertyInfo>(),\n        new IgnoreFormatter<FieldInfo>()\n    },\n    new IFormatterResolver[]\n    {\n        ContractlessStandardResolver.Instance\n    });\n```\n\n## Reserved Extension Types\n\nMessagePack for C# already used some MessagePack extension type codes, be careful to avoid using the same ext code for other purposes.\n\nRange | Reserved for\n--|--\n\\[-128, -1\\] | Reserved by the msgpack spec for predefined types\n\\[30, 120) | Reserved for this library's use to support common types in .NET\n\nThis leaves the following ranges for your use:\n\n- \\[0, 30)\n- \\[120, 127]\n\nWithin the *reserved* ranges, this library defines or implements extensions that use these type codes:\n\n| Code | Type | Use by |\n| ---- | ---- | --- |\n| -1   | DateTime | MessagePack-spec reserved for timestamp |\n| 30   | Vector2[] | for Unity, UnsafeBlitFormatter |\n| 31   | Vector3[] | for Unity, UnsafeBlitFormatter |\n| 32   | Vector4[] | for Unity, UnsafeBlitFormatter |\n| 33   | Quaternion[] | for Unity, UnsafeBlitFormatter |\n| 34   | Color[] | for Unity, UnsafeBlitFormatter |\n| 35   | Bounds[] | for Unity, UnsafeBlitFormatter |\n| 36   | Rect[] | for Unity, UnsafeBlitFormatter |\n| 37   | Int[] | for Unity, UnsafeBlitFormatter |\n| 38   | Float[] | for Unity, UnsafeBlitFormatter |\n| 39   | Double[] | for Unity, UnsafeBlitFormatter |\n| 98   | All | MessagePackCompression.Lz4BlockArray |\n| 99   | All | MessagePackCompression.Lz4Block |\n| 100  | object | TypelessFormatter |\n\n## Unity support\n\nThe minimum supported Unity version will be `2022.3.12f1`, as it is necessary to support IL2CPP via C# Source Generator.\n\nThere are two installation steps required to use it in Unity. Do both, not just one.\n\n1. Install `MessagePack` from NuGet using [NuGetForUnity](https://github.com/GlitchEnzo/NuGetForUnity)\n   Open Window from NuGet -> Manage NuGet Packages, Search \"MessagePack\" and Press Install.\n\n2. Install `MessagePack.Unity` package by referencing the git URL.\n   Open Package Manager window and press `Add Package from git URL...`, enter following path\n\n   ```\n   https://github.com/MessagePack-CSharp/MessagePack-CSharp.git?path=src/MessagePack.UnityClient/Assets/Scripts/MessagePack\n   ```\n\n   MessagePack uses the ..* release tag, so you can specify a version like #v3.0.0. For example: `https://github.com/MessagePack-CSharp/MessagePack-CSharp.git?path=src/MessagePack.UnityClient/Assets/Scripts/MessagePack#v3.0.0`\n\nIn Unity, MessagePackSerializer can serialize `Vector2`, `Vector3`, `Vector4`, `Quaternion`, `Color`, `Bounds`, `Rect`, `AnimationCurve`, `Keyframe`, `Matrix4x4`, `Gradient`, `Color32`, `RectOffset`, `LayerMask`, `Vector2Int`, `Vector3Int`, `RangeInt`, `RectInt`, `BoundsInt` and their nullable, array and list types with the built-in extension `UnityResolver`.\n\n`MessagePack.Unity` automatically adds `UnityResolver` to the default options Resolver when the application starts with code like this in the unity package to enable this serialization:\n\n```csharp\n[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.SubsystemRegistration)]\nprivate static void Init()\n{\n    MessagePackSerializer.DefaultOptions = MessagePackSerializerOptions.Standard.WithResolver(UnityResolver.InstanceWithStandardResolver);\n}\n```\n\nIf you want to customize the Resolver or change the DefaultOptions, it would be good to keep this in mind.\n\n### Share types with .NET\n\nThe `MessagePack.UnityShims` NuGet package is for .NET server-side serialization support to communicate with Unity. It includes shims for Vector3 etc and the Safe/Unsafe serialization extension.\n\nThere are several ways to share types between .NET and Unity:\n\n* Share using symbolic links\n* Place the actual files on the Unity side and reference them as link files in the .NET csproj\n* Use UPM local references to reference the .NET project from the Unity side\n\nWhile the setup is a bit challenging, the smoothest way to share is using UPM local references. For detailed steps, please refer to the [MagicOnion Sample](https://github.com/Cysharp/MagicOnion/tree/main/samples/ChatApp).\n\n### UnsafeBlitResolver\n\nMessagePack for C# has an additional unsafe extension.  `UnsafeBlitResolver` is special resolver for extremely fast but unsafe serialization/deserialization of struct arrays.\n\n![image](https://cloud.githubusercontent.com/assets/46207/23837633/76589924-07ce-11e7-8b26-e50eab548938.png)\n\nx20 faster Vector3[] serialization than native JsonUtility. If use `UnsafeBlitResolver`, serialization uses a special format (ext:typecode 30~39)  for `Vector2[]`, `Vector3[]`, `Quaternion[]`, `Color[]`, `Bounds[]`, `Rect[]`. If use `UnityBlitWithPrimitiveArrayResolver`, it supports `int[]`, `float[]`, `double[]` too. This special feature is useful for serializing Mesh (many `Vector3[]`) or many transform positions.\n\nIf you want to use unsafe resolver, register `UnityBlitResolver` or `UnityBlitWithPrimitiveArrayResolver`.\n\nHere is sample of configuration.\n\n```csharp\nStaticCompositeResolver.Instance.Register(\n    MessagePack.Unity.UnityResolver.Instance,\n    MessagePack.Unity.Extension.UnityBlitWithPrimitiveArrayResolver.Instance,\n    MessagePack.Resolvers.StandardResolver.Instance\n);\n\nvar options = MessagePackSerializerOptions.Standard.WithResolver(StaticCompositeResolver.Instance);\nMessagePackSerializer.DefaultOptions = options;\n```\n\n## <a name=\"aot\"></a>AOT Code Generation\n\nA source generator is provided in the `MessagePackAnalyzer` package, which is automatically installed when you install `MessagePack` via NuGet.\nThis will source generate the formatters required for all your `[MessagePackObject]`-annotated data types during compilation for the fastest possible startup and runtime.\nAn `IFormatterResolver` is also generated that bundles all source generated and user-written formatters together.\nThe `StandardResolver` includes the `SourceGeneratedFormatterResolver` which discovers and uses your source generated resolver automatically.\n\nTherefore, in the usual scenario, it will work with AOT Safe without any special handling.\nIf you prefer to restrict your resolver to source-generated formatters, you should use the `MessagePack.GeneratedMessagePackResolver`, which is source generated into your project for that purpose.\nThis type's name and namespace can be customized by applying `[GeneratedMessagePackResolver]` to a `partial class` that you define, at which point that class becomes the resolver for you to use.\n\nAt runtime, if a source generated or hand-written formatter cannot be found for a given `[MessagePackObject]` type, MessagePack will generate the formatters on the fly using [Reflection.Emit](https://learn.microsoft.com/dotnet/api/system.reflection.emit.ilgenerator) to create highly-tuned formatters for each type.\nThis code generation has a minor upfront performance cost.\n\n> Note: When using Unity, dynamic code generation only works when targeting .NET Framework 4.x + mono runtime.\nFor all other Unity targets, AOT is required.\n\n### Customizations\n\nYou can customize the generated source through properties on the `GeneratedMessagePackResolverAttribute`.\n\n```cs\n[GeneratedMessagePackResolver]\npartial class MyResolver\n{\n}\n```\n\nWhen exposing the generated resolver publicly, consumers outside the library should aggregate the resolver using its `Instance` property, which contains *only* the generated formatters.\n\nTwo assembly-level attributes exist to help with mixing in your own custom formatters with the automatically generated ones:\n- `MessagePackKnownFormatterAttribute`\n- `MessagePackAssumedFormattableAttribute`\n\nLearn more about using a mix of your own custom formatters and automatically generated ones in [the Analyzer section](#analyzer).\n\n### MagicOnion\n\n[MagicOnion](https://github.com/Cysharp/MagicOnion) is a code-first gRPC framework based on grpc-dotnet and MessagePack. gRPC usually communicates with Protocol Buffers using IDL. But MagicOnion uses MessagePack for C# and does not need IDL. When communicating C# to C#, schemaless (or rather C# classes as schema) is better than using IDL.\n\n### StreamJsonRpc\n\nThe StreamJsonRpc library is based on [JSON-RPC](https://www.jsonrpc.org/) and includes [a pluggable formatter architecture](https://github.com/microsoft/vs-streamjsonrpc/blob/master/doc/extensibility.md#alternative-formatters) and as of v2.3 includes [MessagePack support](https://github.com/microsoft/vs-streamjsonrpc/blob/master/doc/extensibility.md#message-formatterss).\n\n## How to build\nSee our [contributor's guide](CONTRIBUTING.md).\n\n## <a name=\"coc\"></a>Code of Conduct\n\nThis project has adopted the code of conduct defined by the Contributor Covenant to clarify expected behavior in our community.\nFor more information see the [.NET Foundation Code of Conduct](https://dotnetfoundation.org/code-of-conduct).\n\n## .NET Foundation\n\nThis project is supported by the [.NET Foundation](https://dotnetfoundation.org).\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.7861328125,
          "content": "# Security Policy\n\n## Supported Versions\n\n| Version | Supported | End-of-life date |\n| ------- | --------- | ---------------- |\n| 1.x     | ❌ |\n| 2.x     | ✅ | 2025-12-31 |\n| 3.x     | ✅ | not yet determined |\n\nEach supported major version is only serviced for security issues at its tip.\nFor example 2.5 will receive updates but 2.4 will not.\n3.0 will receive updates until 3.1 is stable, at which point 3.0 will no longer received security updates.\n\n## Reporting a Vulnerability\n\nPlease use [the Security tab](https://github.com/MessagePack-CSharp/MessagePack-CSharp/security) to responsibly report security vulnerabilities.\n\nAlternatively, email the project's main contributors with any vulnerability you become aware of.\n\n    Yoshifumi Kawai <ils@neue.cc>; Andrew Arnott <andrewarnott@live.com>\n"
        },
        {
          "name": "benchmark",
          "type": "tree",
          "content": null
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "global.json",
          "type": "blob",
          "size": 0.099609375,
          "content": "{\n  \"sdk\": {\n    \"version\": \"9.0.100\",\n    \"rollForward\": \"patch\",\n    \"allowPrerelease\": false\n  }\n}\n"
        },
        {
          "name": "graph.xlsx",
          "type": "blob",
          "size": 31.27734375,
          "content": null
        },
        {
          "name": "init.cmd",
          "type": "blob",
          "size": 0.630859375,
          "content": "@echo off\nSETLOCAL\nset PS1UnderCmd=1\n\n:: Get the datetime in a format that can go in a filename.\nset _my_datetime=%date%_%time%\nset _my_datetime=%_my_datetime: =_%\nset _my_datetime=%_my_datetime::=%\nset _my_datetime=%_my_datetime:/=_%\nset _my_datetime=%_my_datetime:.=_%\nset CmdEnvScriptPath=%temp%\\envvarscript_%_my_datetime%.cmd\n\npowershell.exe -NoProfile -NoLogo -ExecutionPolicy bypass -Command \"try { & '%~dpn0.ps1' %*; exit $LASTEXITCODE } catch { write-host $_; exit 1 }\"\n\n:: Set environment variables in the parent cmd.exe process.\nIF EXIST \"%CmdEnvScriptPath%\" (\n    ENDLOCAL\n    CALL \"%CmdEnvScriptPath%\"\n    DEL \"%CmdEnvScriptPath%\"\n)\n"
        },
        {
          "name": "init.ps1",
          "type": "blob",
          "size": 4.5498046875,
          "content": "#!/usr/bin/env pwsh\n\n<#\n.SYNOPSIS\n    Installs dependencies required to build and test the projects in this repository.\n.DESCRIPTION\n    This MAY not require elevation, as the SDK and runtimes are installed to a per-user location,\n    unless the `-InstallLocality` switch is specified directing to a per-repo or per-machine location.\n    See detailed help on that switch for more information.\n\n    The CmdEnvScriptPath environment variable may be optionally set to a path to a cmd shell script to be created (or appended to if it already exists) that will set the environment variables in cmd.exe that are set within the PowerShell environment.\n    This is used by init.cmd in order to reapply any new environment variables to the parent cmd.exe process that were set in the powershell child process.\n.PARAMETER InstallLocality\n    A value indicating whether dependencies should be installed locally to the repo or at a per-user location.\n    Per-user allows sharing the installed dependencies across repositories and allows use of a shared expanded package cache.\n    Visual Studio will only notice and use these SDKs/runtimes if VS is launched from the environment that runs this script.\n    Per-repo allows for high isolation, allowing for a more precise recreation of the environment within an Azure Pipelines build.\n    When using 'repo', environment variables are set to cause the locally installed dotnet SDK to be used.\n    Per-repo can lead to file locking issues when dotnet.exe is left running as a build server and can be mitigated by running `dotnet build-server shutdown`.\n    Per-machine requires elevation and will download and install all SDKs and runtimes to machine-wide locations so all applications can find it.\n.PARAMETER NoPrerequisites\n    Skips the installation of prerequisite software (e.g. SDKs, tools).\n.PARAMETER NoNuGetCredProvider\n    Skips the installation of the NuGet credential provider. Useful in pipelines with the `NuGetAuthenticate` task, as a workaround for https://github.com/microsoft/artifacts-credprovider/issues/244.\n    This switch is ignored and installation is skipped when -NoPrerequisites is specified.\n.PARAMETER UpgradePrerequisites\n    Takes time to install prerequisites even if they are already present in case they need to be upgraded.\n    No effect if -NoPrerequisites is specified.\n.PARAMETER NoRestore\n    Skips the package restore step.\n.PARAMETER NoToolRestore\n    Skips the dotnet tool restore step.\n.PARAMETER AccessToken\n    An optional access token for authenticating to Azure Artifacts authenticated feeds.\n.PARAMETER Interactive\n    Runs NuGet restore in interactive mode. This can turn authentication failures into authentication challenges.\n#>\n[CmdletBinding(SupportsShouldProcess = $true)]\nParam (\n    [ValidateSet('repo', 'user', 'machine')]\n    [string]$InstallLocality = 'user',\n    [Parameter()]\n    [switch]$NoPrerequisites,\n    [Parameter()]\n    [switch]$NoNuGetCredProvider,\n    [Parameter()]\n    [switch]$UpgradePrerequisites,\n    [Parameter()]\n    [switch]$NoRestore,\n    [Parameter()]\n    [switch]$NoToolRestore,\n    [Parameter()]\n    [string]$AccessToken,\n    [Parameter()]\n    [switch]$Interactive\n)\n\n$EnvVars = @{}\n$PrependPath = @()\n\nif (!$NoPrerequisites) {\n    if (!$NoNuGetCredProvider) {\n        & \"$PSScriptRoot\\tools\\Install-NuGetCredProvider.ps1\" -AccessToken $AccessToken -Force:$UpgradePrerequisites\n    }\n\n    & \"$PSScriptRoot\\tools\\Install-DotNetSdk.ps1\" -InstallLocality $InstallLocality\n    if ($LASTEXITCODE -eq 3010) {\n        Exit 3010\n    }\n}\n\n# Workaround nuget credential provider bug that causes very unreliable package restores on Azure Pipelines\n$env:NUGET_PLUGIN_HANDSHAKE_TIMEOUT_IN_SECONDS = 20\n$env:NUGET_PLUGIN_REQUEST_TIMEOUT_IN_SECONDS = 20\n\nPush-Location $PSScriptRoot\ntry {\n    $HeaderColor = 'Green'\n\n    $RestoreArguments = @()\n    if ($Interactive) {\n        $RestoreArguments += '--interactive'\n    }\n\n    if (!$NoRestore -and $PSCmdlet.ShouldProcess(\"NuGet packages\", \"Restore\")) {\n        Write-Host \"Restoring NuGet packages\" -ForegroundColor $HeaderColor\n        dotnet restore @RestoreArguments\n        if ($lastexitcode -ne 0) {\n            throw \"Failure while restoring packages.\"\n        }\n    }\n\n    if (!$NoToolRestore -and $PSCmdlet.ShouldProcess(\"dotnet tool\", \"restore\")) {\n        dotnet tool restore @RestoreArguments\n        if ($lastexitcode -ne 0) {\n            throw \"Failure while restoring dotnet CLI tools.\"\n        }\n    }\n\n    & \"$PSScriptRoot/tools/Set-EnvVars.ps1\" -Variables $EnvVars -PrependPath $PrependPath | Out-Null\n}\ncatch {\n    Write-Error $error[0]\n    exit $lastexitcode\n}\nfinally {\n    Pop-Location\n}\n"
        },
        {
          "name": "installcredprovider.ps1",
          "type": "blob",
          "size": 5.767578125,
          "content": "# A PowerShell script that adds the latest version of the Azure Artifacts credential provider\n# plugin for Dotnet and/or NuGet to ~/.nuget/plugins directory\n# To install netcore, run installcredprovider.ps1\n# To install netcore and netfx, run installcredprovider.ps1 -AddNetfx\n# To overwrite existing plugin with the latest version, run installcredprovider.ps1 -Force\n# To use a specific version of a credential provider, run installcredprovider.ps1 -Version \"0.1.17\" or installcredprovider.ps1 -Version \"0.1.17\" -Force\n# More: https://github.com/Microsoft/artifacts-credprovider/blob/master/README.md\n\nparam(\n    # whether or not to install netfx folder for nuget\n    [switch]$AddNetfx,\n    # override existing cred provider with the latest version\n    [switch]$Force,\n    # install the version specified\n    [string]$Version\n)\n\n$script:ErrorActionPreference='Stop'\n\n# Without this, System.Net.WebClient.DownloadFile will fail on a client with TLS 1.0/1.1 disabled\nif ([Net.ServicePointManager]::SecurityProtocol.ToString().Split(',').Trim() -notcontains 'Tls12') {\n    [Net.ServicePointManager]::SecurityProtocol += [Net.SecurityProtocolType]::Tls12\n}\n\n$profilePath = [System.Environment]::GetFolderPath([System.Environment+SpecialFolder]::UserProfile)\n$tempPath = [System.IO.Path]::GetTempPath()\n\n$pluginLocation = [System.IO.Path]::Combine($profilePath, \".nuget\", \"plugins\");\n$tempZipLocation = [System.IO.Path]::Combine($tempPath, \"CredProviderZip\");\n\n$localNetcoreCredProviderPath = [System.IO.Path]::Combine(\"netcore\", \"CredentialProvider.Microsoft\");\n$localNetfxCredProviderPath = [System.IO.Path]::Combine(\"netfx\", \"CredentialProvider.Microsoft\");\n\n$fullNetfxCredProviderPath = [System.IO.Path]::Combine($pluginLocation, $localNetfxCredProviderPath)\n$fullNetcoreCredProviderPath = [System.IO.Path]::Combine($pluginLocation, $localNetcoreCredProviderPath)\n\n$netfxExists = Test-Path -Path ($fullNetfxCredProviderPath)\n$netcoreExists = Test-Path -Path ($fullNetcoreCredProviderPath)\n\n# Check if plugin already exists if -Force swich is not set\nif (!$Force) {\n    if ($AddNetfx -eq $True -and $netfxExists -eq $True -and $netcoreExists -eq $True) {\n        Write-Host \"The netcore and netfx Credential Providers are already in $pluginLocation\"\n        return\n    }\n\n    if ($AddNetfx -eq $False -and $netcoreExists -eq $True) {\n        Write-Host \"The netcore Credential Provider is already in $pluginLocation\"\n        return\n    }\n}\n\n# Get the zip file from the GitHub release\n$releaseUrlBase = \"https://api.github.com/repos/Microsoft/artifacts-credprovider/releases\"\n$versionError = \"Unable to find the release version $Version from $releaseUrlBase\"\n$releaseId = \"latest\"\nif (![string]::IsNullOrEmpty($Version)) {\n    try {\n        $releases = Invoke-WebRequest -UseBasicParsing $releaseUrlBase\n        $releaseJson = $releases | ConvertFrom-Json\n        $correctReleaseVersion = $releaseJson | ? { $_.name -eq $Version }\n        $releaseId = $correctReleaseVersion.id\n    } catch {\n        Write-Error $versionError\n        return\n    }\n}\n\nif (!$releaseId) {\n    Write-Error $versionError\n    return\n}\n\n$releaseUrl = [System.IO.Path]::Combine($releaseUrlBase, $releaseId)\n$releaseUrl = $releaseUrl.Replace(\"\\\",\"/\")\n\n$zipErrorString = \"Unable to resolve the Credential Provider zip file from $releaseUrl\"\ntry {\n    Write-Host \"Fetching release $releaseUrl\"\n    $release = Invoke-WebRequest -UseBasicParsing $releaseUrl\n    $releaseJson = $release.Content | ConvertFrom-Json\n    if ($AddNetfx -eq $True) {\n        Write-Host \"Using Microsoft.NuGet.CredentialProvider.zip\"\n        $zipAsset = $releaseJson.assets | ? { $_.name -eq \"Microsoft.NuGet.CredentialProvider.zip\" }\n    } else {\n        Write-Host \"Using Microsoft.NetCore2.NuGet.CredentialProvider.zip\"\n        $zipAsset = $releaseJson.assets | ? { $_.name -eq \"Microsoft.NetCore2.NuGet.CredentialProvider.zip\" }\n    }\n    \n    $packageSourceUrl = $zipAsset.browser_download_url\n} catch {\n    Write-Error $zipErrorString\n    return\n}\n\nif (!$packageSourceUrl) {\n    Write-Error $zipErrorString\n    return\n}\n\n# Create temporary location for the zip file handling\nWrite-Host \"Creating temp directory for the Credential Provider zip: $tempZipLocation\"\nif (Test-Path -Path $tempZipLocation) {\n    Remove-Item $tempZipLocation -Force -Recurse\n}\nNew-Item -ItemType Directory -Force -Path $tempZipLocation\n\n# Download credential provider zip to the temp location\n$pluginZip = ([System.IO.Path]::Combine($tempZipLocation, \"Microsoft.NuGet.CredentialProvider.zip\"))\nWrite-Host \"Downloading $packageSourceUrl to $pluginZip\"\ntry {\n    $client = New-Object System.Net.WebClient\n    $client.DownloadFile($packageSourceUrl, $pluginZip)\n} catch {\n    Write-Error \"Unable to download $packageSourceUrl to the location $pluginZip\"\n}\n\n# Extract zip to temp directory\nWrite-Host \"Extracting zip to the Credential Provider temp directory\"\nAdd-Type -AssemblyName System.IO.Compression.FileSystem \n[System.IO.Compression.ZipFile]::ExtractToDirectory($pluginZip, $tempZipLocation)\n\n# Remove existing content and copy netcore (and netfx) directories to plugins directory\nWrite-Host \"Copying Credential Provider to $pluginLocation\"\nif ($netcoreExists) {\n    Remove-Item $fullNetcoreCredProviderPath -Force -Recurse\n}\nCopy-Item ([System.IO.Path]::Combine($tempZipLocation, \"plugins\", $localNetcoreCredProviderPath)) -Destination $fullNetcoreCredProviderPath -Force -Recurse\nif ($AddNetfx -eq $True) {\n    if ($netfxExists) {\n        Remove-Item $fullNetfxCredProviderPath -Force -Recurse\n    }\n    Copy-Item ([System.IO.Path]::Combine($tempZipLocation, \"plugins\", $localNetfxCredProviderPath)) -Destination $fullNetfxCredProviderPath -Force -Recurse\n}\n\n# Remove $tempZipLocation directory\nWrite-Host \"Removing the Credential Provider temp directory $tempZipLocation\"\nRemove-Item $tempZipLocation -Force -Recurse\n\nWrite-Host \"Credential Provider installed successfully\"\n"
        },
        {
          "name": "nuget.config",
          "type": "blob",
          "size": 0.9384765625,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<configuration>\n  <config>\n    <add key=\"repositorypath\" value=\"packages\" />\n  </config>\n  <packageSources>\n    <!--To inherit the global NuGet package sources remove the <clear/> line below -->\n    <clear />\n    <add key=\"nuget\" value=\"https://api.nuget.org/v3/index.json\" />\n    <add key=\"dotnet-tools\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json\" />\n  </packageSources>\n  <disabledPackageSources>\n    <!-- Defend against user or machine level disabling of sources that we list in this file. -->\n    <clear />\n  </disabledPackageSources>\n  <packageSourceMapping>\n    <clear />\n    <packageSource key=\"nuget\">\n      <package pattern=\"*\" />\n      <package pattern=\"Microsoft.CodeAnalysis.*\" />\n    </packageSource>\n    <packageSource key=\"dotnet-tools\">\n      <package pattern=\"Microsoft.CodeAnalysis.*\" />\n    </packageSource>\n  </packageSourceMapping>\n</configuration>\n"
        },
        {
          "name": "opensource.snk",
          "type": "blob",
          "size": 0.58203125,
          "content": null
        },
        {
          "name": "sandbox",
          "type": "tree",
          "content": null
        },
        {
          "name": "settings.VisualStudio.json",
          "type": "blob",
          "size": 0.0498046875,
          "content": "{\n  \"textEditor.codeCleanup.profile\": \"profile1\"\n}\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "stylecop.json",
          "type": "blob",
          "size": 0.7451171875,
          "content": "{\n  \"$schema\": \"https://raw.githubusercontent.com/DotNetAnalyzers/StyleCopAnalyzers/master/StyleCop.Analyzers/StyleCop.Analyzers/Settings/stylecop.schema.json\",\n  \"settings\": {\n    \"documentationRules\": {\n      \"copyrightText\": \"Copyright (c) All contributors. All rights reserved.\\nLicensed under the {licenseName} license. See {licenseFile} file in the project root for full license information.\",\n      \"variables\": {\n        \"licenseName\": \"MIT\",\n        \"licenseFile\": \"LICENSE\"\n      },\n      \"fileNamingConvention\": \"metadata\",\n      \"xmlHeader\": false\n    },\n    \"layoutRules\": {\n      \"newlineAtEndOfFile\": \"require\"\n    },\n    \"orderingRules\": {\n      \"systemUsingDirectivesFirst\": true,\n      \"usingDirectivesPlacement\": \"outsideNamespace\"\n    }\n  }\n}\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}