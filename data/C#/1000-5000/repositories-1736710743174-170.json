{
  "metadata": {
    "timestamp": 1736710743174,
    "page": 170,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "AutoFixture/AutoFixture",
      "stars": 3375,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".config",
          "type": "tree",
          "content": null
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.4150390625,
          "content": "root = true\n\n[*.{cs,fs,fsx}]\nindent_size = 4\nindent_style = space\n\n[*.{sln,csproj,fsproj,config,xml,props}]\nindent_size = 2\nindent_style = space\n\n[*.cs]\n# Require \"this.\" keyword qualification in code\ndotnet_style_qualification_for_field = true:suggestion\ndotnet_style_qualification_for_property = true:suggestion\ndotnet_style_qualification_for_method = true:suggestion\ndotnet_style_qualification_for_event = true:suggestion\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.78515625,
          "content": "# Enable automatic line ending conversion for text files on checkout and commit.\n# For all extensions that are not being explicitly defined below git will try to guess\n# whether file contains text and if so, will convert the line endings.\n* text=auto\n\n# Define all the file extensions for which we should always apply line ending covnersion\n*.cs      text diff=csharp\n*.fs      text\n*.fsx     text\n*.config  text\n*.xml     text\n\n*.sln     text\n*.csproj  text\n*.fsproj  text\n*.props   text\n*.ruleset text\n\n*.md      text\n*.txt     text\n*.yml     text\n*.pp      text\n*.nuspec  text\n\n*.bat     text\n*.cmd     text\n*.sh      text\n\n# Define all the binary files that should not be touched\n*.dll     binary\n*.exe     binary\n*.pdb     binary\n*.png     binary\n*.snk     binary\n*.sigdata binary\n*.optdata binary\n\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.5703125,
          "content": "[Dd]ebug/\n[Rr]elease/\n[Bb]in/\n[Oo]bj/\n[Hh]elp/\n\n# User-specific files\n*.suo\n*.user\n\n# DotCover is a Code Coverage Tool\n*.dotCover\n\n# ReSharper is a .NET coding add-in\n_ReSharper*/\n*.[Rr]e[Ss]harper\n*.DotSettings.user\n\n# NCrunch\n_NCrunch_*\n.*crunch*.local.xml\nnCrunchTemp_*\n\n# FAKE - F# Make\n.fake/\n\n# JetBrains Rider\n.idea/\n\n# Visual Studio 2015 cache/options directory\n.vs/\n\n# VS Code cache/options\n.vscode/\n\n# package files can be ignored because of the NuGet restore\n**/packages/*\n\n# Tmp modified files\n*.orig\n\n# Temp build artifacts and tools\n/build/\n.tmp/\n\n# VIM tmp files\n*.swp\n"
        },
        {
          "name": "AutoFixtureLogo200x200.png",
          "type": "blob",
          "size": 13.9833984375,
          "content": null
        },
        {
          "name": "Build.fsx",
          "type": "blob",
          "size": 15.5771484375,
          "content": "ï»¿#r \"paket:\nnuget Fake.BuildServer.AppVeyor\nnuget Fake.Core.Environment\nnuget Fake.Core.Target\nnuget Fake.Core.Xml\nnuget Fake.DotNet\nnuget Fake.DotNet.Cli\nnuget Fake.DotNet.MsBuild\nnuget Fake.DotNet.NuGet\nnuget Fake.DotNet.Testing.NUnit\nnuget Fake.IO.FileSystem\nnuget Fake.IO.Zip\nnuget Fake.Tools.Git\nnuget Fake.Testing.Common\n\"\n\n#load \".fake/build.fsx/intellisense.fsx\"\n\nopen System\nopen System.Text.RegularExpressions\n\nopen Fake.BuildServer;\nopen Fake.Core;\nopen Fake.Core.String.Operators\nopen Fake.Core.TargetOperators\nopen Fake.DotNet;\nopen Fake.IO\nopen Fake.IO.Globbing.Operators\nopen Fake.IO.FileSystemOperators\nopen Fake.Tools;\n\nlet buildDir = Environment.environVarOrDefault \"BUILD_DIR\" \"build\" |> Path.getFullName\nlet buildToolsDir = buildDir </> \"tools\"\nlet testResultsFolder = buildDir </> \"TestResults\" |> Path.getFullName\nlet nuGetOutputFolder = buildDir </> \"NuGetPackages\"\nlet nuGetPackages = !! (nuGetOutputFolder </> \"*.nupkg\")\nlet sourcesDirPath = \"src\"\nlet solutionPath = sourcesDirPath </> \"All.sln\" |> Path.getFullName\nlet buildConfiguration = DotNet.BuildConfiguration.fromEnvironVarOrDefault \"BUILD_CONFIGURATION\" DotNet.BuildConfiguration.Release\nlet buildVerbosity = match Environment.environVarOrDefault \"BUILD_VERBOSITY\" \"\"  |> String.toLower with\n                     | \"quiet\" | \"q\"         -> Quiet\n                     | \"minimal\" | \"m\"       -> Minimal\n                     | \"normal\" | \"n\"        -> Normal\n                     | \"detailed\" | \"d\"      -> Detailed\n                     | \"diagnostic\" | \"diag\" -> Diagnostic\n                     | _ -> Minimal\n\n\ntype BuildVersionCalculationSource = { Major: int; Minor: int; Revision: int; PreSuffix: string; \n                                       CommitsNum: int; Sha: string; BuildNumber: int }\nlet getVersionSourceFromGit buildNumber =\n    // The --fist-parent flag is required to correctly work for vNext branch.\n    // Example of output for a release tag: v3.50.2-288-g64fd5c5b, for a prerelease tag: v3.50.2-alpha1-288-g64fd5c5b.\n    let desc = Git.CommandHelper.runSimpleGitCommand \"\" \"describe --tags --long --abbrev=40 --first-parent --match=v*\"\n\n    // Previously repository contained a few broken tags like \"v.3.21.1\". They were removed, but could still exist\n    // in forks. We handle them as well to not fail on such repositories.\n    let result = Regex.Match(desc,\n                             @\"^v(\\.)?(?<maj>\\d+)\\.(?<min>\\d+)\\.(?<rev>\\d+)(?<pre>-\\w+\\d*)?-(?<num>\\d+)-g(?<sha>[a-z0-9]+)$\",\n                             RegexOptions.IgnoreCase)\n                      .Groups\n\n    let getMatch (name:string) = result.[name].Value\n\n    { Major = getMatch \"maj\" |> int\n      Minor = getMatch \"min\" |> int\n      Revision = getMatch \"rev\" |> int\n      PreSuffix = getMatch \"pre\"\n      CommitsNum = getMatch \"num\" |> int\n      Sha = getMatch \"sha\"\n      BuildNumber = buildNumber\n    }\n\ntype BuildVersionInfo = { AssemblyVersion:string; FileVersion:string; InfoVersion:string; NugetVersion:string; CommitHash: string;\n                          Source: Option<BuildVersionCalculationSource> }\nlet calculateVersion source =\n    let s = source\n    let (major, minor, revision, preReleaseSuffix, commitsNum, sha, buildNumber) =\n        (s.Major, s.Minor, s.Revision, s.PreSuffix, s.CommitsNum, s.Sha, s.BuildNumber)\n\n    let assemblyVersion = sprintf \"%d.%d.0.0\" major minor\n    let fileVersion = sprintf \"%d.%d.%d.%d\" major minor revision buildNumber\n    \n    // If number of commits since last tag is greater than zero, we append another identifier with number of commits.\n    // The produced version is larger than the last tag version.\n    // If we are on a tag, we use version without modification.\n    // Examples of output: 3.50.2.1, 3.50.2.215, 3.50.1-rc1.3, 3.50.1-rc3.35\n    let nugetVersion = match commitsNum with\n                       | 0 -> sprintf \"%d.%d.%d%s\" major minor revision preReleaseSuffix\n                       | _ -> sprintf \"%d.%d.%d%s.%d\" major minor revision preReleaseSuffix commitsNum\n\n    let infoVersion = match commitsNum with\n                      | 0 -> nugetVersion\n                      | _ -> sprintf \"%s-%s\" nugetVersion sha\n\n    { AssemblyVersion=assemblyVersion; FileVersion=fileVersion; InfoVersion=infoVersion; NugetVersion=nugetVersion; CommitHash=s.Sha;\n      Source = Some source }\n\n// Calculate version that should be used for the build. Define globally as data might be required by multiple targets.\n// Please never name the build parameter with version as \"Version\" - it might be consumed by the MSBuild, override \n// the defined properties and break some tasks (e.g. NuGet restore).\nlet mutable buildVersion = match Environment.environVarOrDefault \"BUILD_VERSION\" \"git\" with\n                           | \"git\"       -> Environment.environVarOrDefault \"BUILD_NUMBER\" \"0\"\n                                            |> int\n                                            |> getVersionSourceFromGit\n                                            |> calculateVersion\n\n                           | assemblyVer -> { AssemblyVersion = assemblyVer\n                                              FileVersion = Environment.environVarOrDefault \"BUILD_FILE_VERSION\" assemblyVer\n                                              InfoVersion = Environment.environVarOrDefault \"BUILD_INFO_VERSION\" assemblyVer\n                                              NugetVersion = Environment.environVarOrDefault \"BUILD_NUGET_VERSION\" assemblyVer\n                                              CommitHash = Environment.environVarOrDefault \"BUILD_COMMIT_HASH\" \"\"\n                                              Source = None }\n\nlet setVNextBranchVersion vNextVersion =\n    buildVersion <-\n        match buildVersion.Source with\n        // Don't update version if it was explicitly specified.\n        | None                                -> buildVersion\n        // Don't update version if tag with current major version is already present (e.g. rc is released).\n        | Some s when s.Major >= vNextVersion -> buildVersion\n        | Some source                         -> \n            // The trick is the \"git describe\" command contains the --first-parent flag.\n            // Because of that git matched the last release tag before the fork was created and calculated number\n            // of commits since that release. We are perfectly fine, as this number will constantly increase only.\n            // Set version to X.0.0-alpha.NUM, where X - major version, NUM - commits since last release before fork.\n            { source with Major = vNextVersion\n                          Minor = 0\n                          Revision = 0\n                          PreSuffix = \"-alpha\" }\n            |> calculateVersion\n\nlet configureMsBuildParams (parameters: MSBuild.CliArguments) = \n    let isCiBuild = BuildServer.buildServer <> LocalBuild\n\n    let properties = [ \"AssemblyVersion\", buildVersion.AssemblyVersion\n                       \"FileVersion\", buildVersion.FileVersion\n                       \"InformationalVersion\", buildVersion.InfoVersion\n                       \"PackageVersion\", buildVersion.NugetVersion\n                       \"CommitHash\", buildVersion.CommitHash\n                       \"EnableSourceLink\", isCiBuild.ToString()\n                       \"ContinuousIntegrationBuild\", isCiBuild.ToString() ]\n\n    { parameters with Verbosity = Some buildVerbosity\n                      Properties = properties }\n\nTarget.create \"Verify\" (fun _ ->\n    try\n        DotNet.build (fun p -> { p with Configuration = DotNet.BuildConfiguration.Custom \"Verify\"\n                                        MSBuildParams = configureMsBuildParams p.MSBuildParams })\n                     solutionPath\n    with\n    | MSBuildException (msg, errors) -> \n        let msg = sprintf\n                    \"%s\\r\\nHINT: To simplify the fix process it's recommended to switch to the 'Verify' configuration \\\n                    in the IDE. This way you might get Roslyn quick fixes for the violated rules.\"\n                    msg\n        raise (MSBuildException(msg, errors))\n)\n\nTarget.create \"Build\" (fun _ ->\n    DotNet.build (fun p -> { p with Configuration = buildConfiguration\n                                    MSBuildParams = configureMsBuildParams p.MSBuildParams })\n                 solutionPath\n)\n\nTarget.create \"CleanTestResultsFolder\" (fun _ -> Shell.cleanDir testResultsFolder)\n\nTarget.create \"Test\" (fun _ ->\n    let findProjects pattern = System.IO.Directory.GetDirectories(\"Src\", pattern)\n    let getTestAssemblies framework projDirs =\n        projDirs\n        |> Seq.map (fun proj -> !! (sprintf \"bin/%s/%s/*Test.dll\" (buildConfiguration.ToString()) framework)\n                                |> GlobbingPattern.setBaseDir proj)\n        |> Seq.collect id\n\n\n    // DotNet.test does not support -- parameters for now.\n    let result = DotNet.exec id\n                    \"test\"\n                    (sprintf \n                        \"%s --no-build --configuration %s --logger:trx --results-directory \\\"%s\\\" -- RunConfiguration.NoAutoReporters=true\"\n                        solutionPath\n                        (buildConfiguration.ToString())\n                        testResultsFolder)\n\n    if not result.OK then failwith \"test failed\"\n\n    findProjects \"AutoFixture.NUnit2.*Test\"\n    |> getTestAssemblies \"*\"\n    |> Testing.NUnit.Sequential.run (fun p -> { p with StopOnError = false\n                                                       ShowLabels = false\n                                                       OutputFile  = testResultsFolder </> \"NUnit2TestResult.xml\"\n                                                       ToolPath = buildToolsDir </> \"NUnit.Runners.2.6.2\" </> \"tools\" })\n)\n\nTarget.create \"CleanNuGetPackages\" (fun _ ->\n    Shell.cleanDir nuGetOutputFolder\n)\n\nTarget.create \"NuGetPack\" (fun _ ->\n    DotNet.pack (fun p -> { p with Configuration = buildConfiguration\n                                   OutputPath = Some (Path.getFullName nuGetOutputFolder)\n                                   MSBuildParams = configureMsBuildParams p.MSBuildParams })\n                solutionPath\n\n    let findDependencyNode name (doc:Xml.XmlDocument) =\n            doc.SelectSingleNode(sprintf \"//*[local-name()='dependency' and @id='%s']\" name)\n\n    // Verify that AutoFixture reference is valid.\n    let dependencyVersion = !! \"AutoFixture.AutoNSubstitute*\"\n                            |> GlobbingPattern.setBaseDir nuGetOutputFolder\n                            |> Seq.head\n                            |> Zip.unzipFirstMatchingFileInMemory (fun ze -> ze.Name.EndsWith \".nuspec\")\n                            |> Xml.createDoc\n                            |> findDependencyNode \"AutoFixture\"\n                            |> Xml.getAttribute \"version\"\n\n    if(buildVersion.NugetVersion <> dependencyVersion) \n        then failwithf \"Invalid dependency version in the produced package. Actual: '%s' Expected: '%s'\"\n                       dependencyVersion\n                       buildVersion.NugetVersion \n        else Trace.logfn \"Verified the dependency version. Actual: '%s' Expected: '%s'\"\n                   dependencyVersion\n                   buildVersion.NugetVersion\n)\n\nlet publishPackages packageFeed accessKey =\n    // Protect the secret explicitly, even though FAKE should do it.\n    // See the discussion: https://github.com/fsharp/FAKE/issues/2526#issuecomment-650567241\n    TraceSecrets.register \"<api key>\" accessKey \n\n    nuGetPackages\n    |> Seq.iter (fun pkg -> DotNet.nugetPush (fun p -> { p with PushParams = { p.PushParams with ApiKey = Some accessKey\n                                                                                                 Source = Some packageFeed }})\n                                             pkg\n    )\n\nTarget.create \"PublishNuGet\" (fun _ ->\n    let feed = \"https://www.nuget.org/api/v2/package\"\n    let key = Environment.environVarOrFail \"NUGET_API_KEY\"\n\n    publishPackages feed key\n)\n\nTarget.create \"PublishMyGet\" (fun _ ->\n    let packageFeed = \"https://www.myget.org/F/autofixture/api/v2/package\"\n    let key = Environment.environVarOrFail \"MYGET_API_KEY\"\n\n    publishPackages packageFeed key\n)\n\nTarget.create \"CompleteBuild\"   ignore\n\n\"Verify\" ==> \"Build\"\n\n\n\"CleanTestResultsFolder\" ==> \"Test\"\n\"Build\"                  ==> \"Test\"\n\n\"CleanNuGetPackages\" ==> \"NuGetPack\"\n\"Test\"               ==> \"NuGetPack\"\n\n\"NuGetPack\" ==> \"CompleteBuild\"\n\n\"NuGetPack\" ==> \"PublishNuGet\"\n\n\"NuGetPack\" ==> \"PublishMyGet\"\n\n// ==============================================\n// ================== AppVeyor ==================\n// ==============================================\n\n// Add a helper to identify whether current trigger is PR.\ntype AppVeyor.Environment with\n    static member IsPullRequest = String.isNotNullOrEmpty AppVeyor.Environment.PullRequestNumber\n\ntype AppVeyorTrigger = SemVerTag | CustomTag | PR | VNextBranch | Unknown\nlet anAppVeyorTrigger =\n    let tag = if AppVeyor.Environment.RepoTag then Some AppVeyor.Environment.RepoTagName else None\n    let isPR = AppVeyor.Environment.IsPullRequest\n    let branch = if String.isNotNullOrEmpty AppVeyor.Environment.RepoBranch then Some AppVeyor.Environment.RepoBranch else None\n\n    match tag, isPR, branch with\n    | Some t, _, _ when \"v\\d+.*\" >** t -> SemVerTag\n    | Some _, _, _                     -> CustomTag\n    | _, true, _                       -> PR\n    // Branch name should be checked after the PR flag, because for PR it's set to the upstream branch name.\n    | _, _, Some br when \"v\\d+\" >** br -> VNextBranch\n    | _                                -> Unknown\n\nTarget.create \"AppVeyor_SetVNextVersion\" (fun _ ->\n    // vNext branch has the following name: \"vX\", where X is the next version.\n    AppVeyor.Environment.RepoBranch.Substring(1) \n    |> int\n    |> setVNextBranchVersion\n)\n\nTarget.create \"AppVeyor_UploadTestReports\" (fun _ ->\n    let shuffle xs = xs |> Seq.sortBy (fun _ -> Guid())\n\n    !!\"*.trx\"\n    |> GlobbingPattern.setBaseDir testResultsFolder\n    |> Seq.map (fun file -> (file, ImportData.Mstest))\n    |> Seq.append [(testResultsFolder </> \"NUnit2TestResult.xml\", ImportData.Nunit NunitDataVersion.Nunit)]\n    |> shuffle\n    |> Seq.map (fun (file, format) -> async { Trace.publish format file })\n    |> Async.Parallel\n    |> Async.RunSynchronously\n    |> ignore\n)\n\nTarget.createFinal \"AppVeyor_UpdateVersion\" (fun _ ->\n    // Artifacts might be deployable, so we update build version to find them later by file version.\n    let versionSuffix = if AppVeyor.Environment.IsPullRequest then\n                            let appVeyorVersion = AppVeyor.Environment.BuildVersion;\n                            appVeyorVersion.Substring(appVeyorVersion.IndexOf('-'))\n                        else\n                            \"\"\n    Trace.setBuildNumber (buildVersion.FileVersion + versionSuffix)\n)\n\nTarget.create \"AppVeyor\" ignore\n\n\"AppVeyor_SetVNextVersion\" =?> (\"PatchAssemblyVersions\", anAppVeyorTrigger = VNextBranch)\n\n\"Test\" ==> \"AppVeyor_UploadTestReports\"\n\n// Add logic to resolve action based on current trigger info.\n(==>) <| match anAppVeyorTrigger with\n         | SemVerTag                -> \"PublishNuGet\"\n         | VNextBranch              -> \"PublishMyGet\"\n         | PR | CustomTag | Unknown -> \"CompleteBuild\"\n      <| \"AppVeyor\"\n\n\"AppVeyor_UploadTestReports\" ==> \"AppVeyor\"\n\n// Print state info at the very beginning.\nif BuildServer.buildServer = AppVeyor \n   then Trace.logfn \"[AppVeyor state] Is tag: %b, tag name: '%s', is PR: %b, branch name: '%s', trigger: %A, build version: '%s'\"\n              AppVeyor.Environment.RepoTag \n              AppVeyor.Environment.RepoTagName \n              AppVeyor.Environment.IsPullRequest\n              AppVeyor.Environment.RepoBranch\n              anAppVeyorTrigger\n              AppVeyor.Environment.BuildVersion\n        Target.activateFinal \"AppVeyor_UpdateVersion\"\n\nBuildServer.install [ AppVeyor.Installer ]\n\n// ========= ENTRY POINT =========\nTarget.runOrDefault \"CompleteBuild\"\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 0.232421875,
          "content": "This project has adopted the code of conduct defined by the Contributor Covenant to clarify expected behavior in our community.\nFor more information see the [.NET Foundation Code of Conduct](https://dotnetfoundation.org/code-of-conduct). "
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 5.708984375,
          "content": "# How to contribute to AutoFixture\n\nAutoFixture is currently being developed in C# on .NET 4.5.2 and .NET Standard using Visual Studio 2017 Update 5 or later with [xUnit.net](http://xunit.codeplex.com/) as the unit testing framework. So far, all development has been done with TDD, so there's a pretty high degree of code coverage, and the aim is to keep it that way.\n\n## Build\n\nAutoFixture uses [FAKE](https://github.com/fsprojects/FAKE) as a build engine. If you would like to build the AutoFixture locally, run the `build.cmd` file and wait for the result.\n\nThe repository state (the last tag name and number of commits since the last tag) is used to determine the build version. If you would like to override the auto-generated AutoFixture version, set the `BUILD_VERSION` environment variable before calling the `build.cmd` file. Example for PowerShell:\n\n```cmd\n$env:BUILD_VERSION='3.52.0'; .\\build.cmd\n```\n\nRefer to the [Build.fsx](Build.fsx) file to get information about all the supported build keys.\n\n## Dependencies\n\nAll the external dependencies are restored during the build and don't need to be committed to the repository.\nIf you would like to work with project offline, ensure to trigger a build while you are still online so dependencies are cached. To trigger a build run the `build.cmd` file located in the root directory of the repo.\n\n## Verification\n\nThere are several different targeted solutions to be found under the `\\Src` folder, but be aware that the final verification step before pushing to the repository is to successfully run all the unit tests in the `build.cmd` file.\n\nAs part of the verification build, Code Analysis is executed in a configuration that treats warnings as errors. For unit test projects code most of the rules are suppressed so only missing warnings are expected. No CA warnings should be suppressed unless the documented conditions for suppression are satisfied. Otherwise, a documented agreement between at least two active developers of the project should be reached to allow a suppression of a non-suppressible warning.\n\n## Pull requests\n\nWhen developing for AutoFixture, please respect the coding style already present. Look around in the source code to get a feel for it.\n\nPlease keep line lengths under 120 characters. Line lengths over 120 characters don't fit into the standard GitHub code listing window, so it requires vertical scrolling to review.\n\nAlso, please follow the [Open Source Contribution Etiquette](http://tirania.org/blog/archive/2010/Dec-31.html). AutoFixture is a fairly typical open source project: if you want to contribute, start by [creating a fork](https://help.github.com/articles/fork-a-repo/) and [sending a pull request](https://help.github.com/articles/about-pull-requests/) when you have something you wish to commit. When creating pull requests, please keep the Single Responsibility Principle in mind. A pull request that does a single thing very well is more likely to be accepted. See also the article [The Rules of the Open Road](http://blog.half-ogre.com/posts/software/rules-of-the-open-road) for more good tips on working with OSS and Pull Requests, as well as these [10 tips for better Pull Requests](http://blog.ploeh.dk/2015/01/15/10-tips-for-better-pull-requests).\n\nFor complex pull requests, you are encouraged to first start a discussion on the [issue list](https://github.com/AutoFixture/AutoFixture/issues). This can save you time, because the AutoFixture regulars can help verify your idea, or point you in the right direction.\n\nSome existing issues are marked with [the `good first issue` tag](https://help.github.com/articles/finding-open-source-projects-on-github/#searching-using-labels). These are good candidates to attempt, if you are just getting started with AutoFixture.\n\nWhen you submit a pull request, you can expect a response within a day or two. We (the maintainers of AutoFixture) have day jobs, so we may not be able to immediately review your pull request, but we do make it a priority. Also keep in mind that we may not be in your time zone.\n\nMost likely, when we review pull requests, we will make suggestions for improvement. This is normal, so don't interpret it as though we don't like your pull request. On the contrary, if we agree on the overall goal of the pull request, we want to work *with* you to make it a success.\n\n## Versioning\n\nAutoFixture follows [Semantic Versioning 2.0.0](http://semver.org/spec/v2.0.0.html) for the public releases (published to the [nuget.org](https://www.nuget.org/)).\n\n## Continuous Integration\n\nAutoFixture has been set up for Continuous Integration. The build is hosted on [AppVeyor](https://ci.appveyor.com/project/AutoFixture/autofixture) and runs automatically every time a new commit is pushed to any of the [public branches](https://github.com/AutoFixture/AutoFixture/branches) or a Pull Request is submitted. AutoFixture uses GitHub's [Commit Status API](https://github.com/blog/1227-commit-status-api#pull-requests) to prevent Pull Requests that don't pass the build from being accidentally merged.\n\nThe build process is implemented in the [`Build.fsx`](https://github.com/AutoFixture/AutoFixture/blob/master/Build.fsx) file using [FAKE](http://fsharp.github.io/FAKE/) and consists of four main steps:\n\n1. Compile all projects\n2. Run static analysis on all projects using [FxCop](https://en.wikipedia.org/wiki/FxCop) and [Roslyn Analyzers package](https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers). \n3. Run [all tests](https://ci.appveyor.com/project/AutoFixture/autofixture/build/tests)\n4. Create [NuGet packages](https://ci.appveyor.com/project/AutoFixture/autofixture/build/artifacts)\n\nThe NuGet packages produced by the latest build can be downloaded directly from [AppVeyor](https://ci.appveyor.com/project/AutoFixture/autofixture/build/artifacts).\n"
        },
        {
          "name": "LICENCE.txt",
          "type": "blob",
          "size": 1.0537109375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2013 Mark Seemann\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.9150390625,
          "content": "# AutoFixture\n\n[![License](https://img.shields.io/badge/license-MIT-green)](https://raw.githubusercontent.com/AutoFixture/AutoFixture/master/LICENCE.txt)\n[![Build status](https://ci.appveyor.com/api/projects/status/qlmobf6rt05pmt7e/branch/master?svg=true)](https://ci.appveyor.com/project/AutoFixture/autofixture/branch/master)\n[![release](https://github.com/AutoFixture/AutoFixture/actions/workflows/release.yml/badge.svg)](https://github.com/AutoFixture/AutoFixture/actions/workflows/release.yml)\n[![NuGet version](https://buildstats.info/nuget/autofixture)](https://www.nuget.org/packages/AutoFixture)\n[![NuGet preview version](https://img.shields.io/nuget/vpre/AutoFixture?logo=nuget)](https://www.nuget.org/packages/AutoFixture)\n<a href=\"https://twitter.com/AutoFixture\">\n    <img src=\"https://img.shields.io/twitter/follow/AutoFixture?label=%40AutoFixture\" alt=\"AutoFixture\" align=\"right\" />\n</a>\n\nWrite maintainable unit tests, faster.\n\nAutoFixture makes it easier for developers to do Test-Driven Development by automating non-relevant Test Fixture Setup, allowing the Test Developer to focus on the essentials of each test case.\n\nCheck the [testimonials](https://github.com/AutoFixture/AutoFixture/wiki/Who-uses-AutoFixture) to see what other people have to say about AutoFixture.\n\n## Table of Contents\n\n- [Overview](#overview)\n- [Downloads](#downloads)\n- [Documentation](#documentation)\n- [Feedback & Questions](#feedback--questions)\n- [License](#license)\n\n## Overview\n\n(Jump straight to the [CheatSheet](https://github.com/AutoFixture/AutoFixture/wiki/Cheat-Sheet) if you just want to see some code samples right away.)\n\nAutoFixture is designed to make Test-Driven Development more productive and unit tests more refactoring-safe. It does so by removing the need for hand-coding anonymous variables as part of a test's Fixture Setup phase. Among other features, it offers a generic implementation of the [Test Data Builder](http://www.natpryce.com/articles/000714.html) pattern.\n\nWhen writing unit tests, you typically need to create some objects that represent the initial state of the test. Often, an API will force you to specify much more data than you really care about, so you frequently end up creating objects that has no influence on the test, simply to make the code compile.\n\nAutoFixture can help by creating such [Anonymous Variables](https://docs.microsoft.com/en-us/archive/blogs/ploeh/anonymous-variables) for you. Here's a simple example:\n\n```c#\n[Fact]\npublic void IntroductoryTest()\n{\n    // Arrange\n    Fixture fixture = new Fixture();\n\n    int expectedNumber = fixture.Create<int>();\n    MyClass sut = fixture.Create<MyClass>();\n    // Act\n    int result = sut.Echo(expectedNumber);\n    // Assert\n    Assert.Equal(expectedNumber, result);\n}\n```\n\nThis example illustrates the basic principle of AutoFixture: It can create values of virtually any type without the need for you to explicitly define which values should be used. The number *expectedNumber* is created by a call to `Create<T>` - this will create a 'nice', regular integer value, saving you the effort of explicitly coming up with one.\n\nThe example also illustrates how AutoFixture can be used as a [SUT Factory](http://blog.ploeh.dk/2009/02/13/SUTFactory.aspx) that creates the actual System Under Test (the MyClass instance).\n\nGiven the right combination of unit testing framework and extensions for AutoFixture, we can further reduce the above test to be even more declarative:\n\n### [xUnit](http://blog.ploeh.dk/2010/10/08/AutoDataTheoriesWithAutoFixture.aspx)\n\n```c#\n[Theory, AutoData]\npublic void IntroductoryTest(int expectedNumber, MyClass sut)\n{\n    int result = sut.Echo(expectedNumber);\n    Assert.Equal(expectedNumber, result);\n}\n```\n\n### [NUnit](http://gertjvr.wordpress.com/2013/09/25/howto-autofixture-nunit2)\n\n```c#\n[Test, AutoData]\npublic void IntroductoryTest(int expectedNumber, MyClass sut)\n{\n    int result = sut.Echo(expectedNumber);\n    Assert.Equal(expectedNumber, result);\n}\n```\n\nNotice how we can reduce unit tests to state only the relevant parts of the test. The rest (variables, Fixture object) is relegated to attributes and parameter values that are supplied automatically by AutoFixture. The test is now only two lines of code.\n\nUsing AutoFixture is as easy as referencing the library and creating a new instance of the Fixture class!\n\n## Downloads\n\nAutoFixture packages are distributed via NuGet.<br />\nTo install the packages you can use the integrated package manager of your IDE, the .NET CLI, or reference the package directly in your project file.\n\n```cmd\ndotnet add package AutoFixture --version 4.18.0\n```\n\n```xml\n<PackageReference Include=\"AutoFixture\" Version=\"4.18.0\" />\n```\n\nAutoFixture offers a variety of utility packages and integrations with most of the major mocking libraries and testing frameworks.\n\n### Core packages\n\nThe core packages offer the full set of AutoFixture's features without requring any testing framework or third party integration.\n\n| Product | Package | Stable | Preview | Downloads |\n|---------|---------|--------|---------|-----------|\n| The core package | [AutoFixture](http://www.nuget.org/packages/AutoFixture) | [![NuGet](https://img.shields.io/nuget/v/AutoFixture)](https://www.nuget.org/packages/AutoFixture) | [![NuGet](https://img.shields.io/nuget/vpre/autofixture)](https://www.nuget.org/packages/AutoFixture)| ![NuGet](https://img.shields.io/nuget/dt/autofixture) |\n| Assertion idioms | [AutoFixture.Idioms](http://www.nuget.org/packages/AutoFixture.Idioms) | [![NuGet](https://img.shields.io/nuget/v/AutoFixture.Idioms)](https://www.nuget.org/packages/AutoFixture.Idioms) | [![NuGet](https://img.shields.io/nuget/vpre/AutoFixture.Idioms)](https://www.nuget.org/packages/AutoFixture.Idioms)| ![NuGet](https://img.shields.io/nuget/dt/autofixture.idioms) |\n| Seed extensions  | [AutoFixture.SeedExtensions](http://www.nuget.org/packages/AutoFixture.SeedExtensions) | [![NuGet](https://img.shields.io/nuget/v/AutoFixture.SeedExtensions)](https://www.nuget.org/packages/AutoFixture.SeedExtensions) | [![NuGet](https://img.shields.io/nuget/vpre/AutoFixture.SeedExtensions)](https://www.nuget.org/packages/AutoFixture.SeedExtensions)| ![NuGet](https://img.shields.io/nuget/dt/autofixture.seedextensions) |\n\n### Mocking libraries\n\nAutoFixture offers integations with most major .NET mocking libraries.<br/>\nThese integrations enable such features as configuring mocks, auto-injecting mocks, etc.\n\n| Product | Package | Stable | Preview | Downloads |\n|---------|---------|--------|---------|-----------|\n| Moq | [AutoFixture.AutoMoq](http://www.nuget.org/packages/AutoFixture.AutoMoq) | [![NuGet](https://img.shields.io/nuget/v/AutoFixture.AutoMoq)](https://www.nuget.org/packages/AutoFixture.AutoMoq) | [![NuGet](https://img.shields.io/nuget/vpre/AutoFixture.AutoMoq)](https://www.nuget.org/packages/AutoFixture.AutoMoq)| ![NuGet](https://img.shields.io/nuget/dt/autofixture.automoq) |\n| NSubstitute | [AutoFixture.AutoNSubstitute](http://www.nuget.org/packages/AutoFixture.AutoNSubstitute) | [![NuGet](https://img.shields.io/nuget/v/AutoFixture.AutoNSubstitute)](https://www.nuget.org/packages/AutoFixture.AutoNSubstitute) | [![NuGet](https://img.shields.io/nuget/vpre/AutoFixture.AutoNSubstitute)](https://www.nuget.org/packages/AutoFixture.AutoNSubstitute)| ![NuGet](https://img.shields.io/nuget/dt/autofixture.AutoNSubstitute) |\n| FakeItEasy | [AutoFixture.AutoFakeItEasy](http://www.nuget.org/packages/AutoFixture.AutoFakeItEasy) | [![NuGet](https://img.shields.io/nuget/v/AutoFixture.AutoFakeItEasy)](https://www.nuget.org/packages/AutoFixture.AutoFakeItEasy) | [![NuGet](https://img.shields.io/nuget/vpre/AutoFixture.AutoFakeItEasy)](https://www.nuget.org/packages/AutoFixture.AutoFakeItEasy)| ![NuGet](https://img.shields.io/nuget/dt/autofixture.AutoFakeItEasy) |\n| Rhino Mocks | [AutoFixture.AutoRhinoMocks](http://www.nuget.org/packages/AutoFixture.AutoRhinoMocks) | [![NuGet](https://img.shields.io/nuget/v/AutoFixture.AutoRhinoMocks)](https://www.nuget.org/packages/AutoFixture.AutoRhinoMocks) | [![NuGet](https://img.shields.io/nuget/vpre/AutoFixture.AutoRhinoMocks)](https://www.nuget.org/packages/AutoFixture.AutoRhinoMocks)| ![NuGet](https://img.shields.io/nuget/dt/autofixture.AutoRhinoMocks) |\n\n> **NOTE:** \n> Since AutoFixture tries maintain compatibility with a large number of package versions, the packages bundled with AutoFixture might not contain the latest features of your mocking library.<br />\n> Make sure to install the latest version of the mocking library package, alongside the AutoFixture package.\n\n### Testing frameworks\n\nAutoFixture offers integrations with most major .NET testing frameworks.<br />\nThese integrations enable auto-generation of test cases, combining auto-generated data with inline arguments, etc.\n\n| Product  | Package | Stable | Preview | Downloads |\n|----------|---------|--------|---------|-----------|\n| xUnit v2 | [AutoFixture.Xunit2](http://www.nuget.org/packages/AutoFixture.Xunit2) | [![NuGet](https://img.shields.io/nuget/v/AutoFixture.Xunit2)](https://www.nuget.org/packages/AutoFixture.Xunit2) | [![NuGet](https://img.shields.io/nuget/vpre/AutoFixture.Xunit2)](https://www.nuget.org/packages/AutoFixture.Xunit2) | ![NuGet](https://img.shields.io/nuget/dt/autofixture.xUnit2) |\n| NUnit v3 | [AutoFixture.NUnit3](http://www.nuget.org/packages/AutoFixture.NUnit3) | [![NuGet](https://img.shields.io/nuget/v/AutoFixture.NUnit3)](https://www.nuget.org/packages/AutoFixture.NUnit3) | [![NuGet](https://img.shields.io/nuget/vpre/AutoFixture.NUnit3)](https://www.nuget.org/packages/AutoFixture.NUnit3) | ![NuGet](https://img.shields.io/nuget/dt/autofixture.NUnit3) |\n| xUnit v1 | [AutoFixture.Xunit](http://www.nuget.org/packages/AutoFixture.Xunit) | [![NuGet](https://img.shields.io/nuget/v/AutoFixture.Xunit)](https://www.nuget.org/packages/AutoFixture.Xunit) | [![NuGet](https://img.shields.io/nuget/vpre/AutoFixture.Xunit)](https://www.nuget.org/packages/AutoFixture.Xunit) | ![NuGet](https://img.shields.io/nuget/dt/autofixture.XUnit) |\n| NUnit v2 | [AutoFixture.NUnit2](http://www.nuget.org/packages/AutoFixture.NUnit2) | [![NuGet](https://img.shields.io/nuget/v/AutoFixture.NUnit2)](https://www.nuget.org/packages/AutoFixture.NUnit2) | [![NuGet](https://img.shields.io/nuget/vpre/AutoFixture.NUnit2)](https://www.nuget.org/packages/AutoFixture.NUnit2) | ![NuGet](https://img.shields.io/nuget/dt/autofixture.NUnit2) |\n| Foq      | [AutoFixture.AutoFoq](http://www.nuget.org/packages/AutoFixture.AutoFoq) | [![NuGet](https://img.shields.io/nuget/v/AutoFixture.AutoFoq)](https://www.nuget.org/packages/AutoFixture.AutoFoq) | [![NuGet](https://img.shields.io/nuget/vpre/AutoFixture.AutoFoq)](https://www.nuget.org/packages/AutoFixture.AutoFoq) | ![NuGet](https://img.shields.io/nuget/dt/autofixture.AutoFoq) |\n\nYou can check the compatibility with your target framework version on the [wiki](https://github.com/AutoFixture/AutoFixture/wiki#net-platforms-compatibility-table) or on the [NuGet](https://www.nuget.org/profiles/AutoFixture) website.\n\n### vNext feed\n\nThe artifacts of the next major version are published to [nuget.org](https://www.nuget.org), and are marked with the `preview` suffix (e.g. `5.0.0-preview00007`).</br>\nYou can use these packages to early access and test the next major version of the AutoFixture.</br>\nMake sure to enable the preview packages in your IDE in order to see the latest version.\n\n> __NOTE:__ This preview versions exists for the _preview purpose_ only, so use them with caution:\n>\n>* New versions of packages might contain breaking changes and API could change drastically from package to package. By other words, we don't follow the SemVer policy for the packages in this feed;\n>* Preview packages might be unlisted over time, in order to not clutter the version suggestion dialog in IDEs, but will generally remain available\n\n## Documentation\n\n* [CheatSheet](https://github.com/AutoFixture/AutoFixture/wiki/Cheat-Sheet)\n* [FAQ](https://github.com/AutoFixture/AutoFixture/wiki/FAQ)\n\n### Additional resources\n\n* [Pluralsight course](https://www.pluralsight.com/courses/unit-testing-autofixture-dot-net)\n* [ploeh blog](http://blog.ploeh.dk/tags/#AutoFixture-ref)\n* [Nikos Baxevanis' blog](http://blog.nikosbaxevanis.com)\n* [Enrico Campidoglio's blog](http://megakemp.com/tag/autofixture)\n* [Gert Jansen van Rensburg's blog](http://gertjvr.wordpress.com/category/autofixture)\n* [Questions on Stack Overflow](http://stackoverflow.com/questions/tagged/autofixture)\n\n## Feedback & Questions\n\nIf you have questions, feel free to ask. The best places to ask are:\n\n* [Stack Overflow - use the *autofixture* tag](http://stackoverflow.com/questions/tagged/autofixture)\n* [GitHub Q&A Discussions](https://github.com/AutoFixture/AutoFixture/discussions/categories/q-a)\n\n## License\n\nAutoFixture is Open Source software and is released under the [MIT license](https://raw.githubusercontent.com/AutoFixture/AutoFixture/master/LICENCE.txt).<br />\nThe licenses allows the use of AutoFixture libraries in free and commercial applications and libraries without restrictions.\n\n### .NET Foundation\n\nThis project is supported by the [.NET Foundation](https://dotnetfoundation.org).\n"
        },
        {
          "name": "References",
          "type": "tree",
          "content": null
        },
        {
          "name": "Src",
          "type": "tree",
          "content": null
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 0.5458984375,
          "content": "image: Visual Studio 2019\n\nenvironment:\n  NUGET_API_KEY:\n    secure: jn0ZfEwCAw9ixglHnFE+qqo51cP1/aqYLjNHD64RlyEmAKbUoQrph/tyRSbrWqPo\n  MYGET_API_KEY:\n    secure: hA4Ut1N2lrrdEtAN24Bty/FNiU0d/Ur/dLYSqpr8jKHOvoO7MU4jD+KwzUvATh+E\n\npull_requests:\n  do_not_increment_build_number: true\n\nskip_commits:\n  files:\n    - '**/*.md'\n    - '**/*.txt'\n\nbuild_script:\n- ps: |\n    $env:BUILD_VERSION=\"git\";\n    $env:BUILD_NUMBER=$env:APPVEYOR_BUILD_NUMBER;\n    & .\\build.cmd -t AppVeyor\n\ntest: off\n\nartifacts:\n- path: build\\NuGetPackages\\*.nupkg\n  name: NuGet\n\ndeploy: off\n\n"
        },
        {
          "name": "build.cmd",
          "type": "blob",
          "size": 0.62109375,
          "content": "@echo off\ncls\n\nSET SCRIPT_DIR=%~dp0\nSET BUILD_DIR=%SCRIPT_DIR%\\build\nSET TOOLS_DIR=%BUILD_DIR%\\tools\nSET NUGET_PATH=%TOOLS_DIR%\\nuget.exe\n\nIF NOT EXIST %TOOLS_DIR%\\ (\n  mkdir %TOOLS_DIR%\n)\n\nIF NOT EXIST %NUGET_PATH% (\n  echo Downloading NuGet.exe ...\n  powershell -Command \"Start-BitsTransfer -Source https://dist.nuget.org/win-x86-commandline/v4.3.0/nuget.exe -Destination %NUGET_PATH%\"\n)\n\nIF NOT EXIST \"%TOOLS_DIR%\\NUnit.Runners.2.6.2\\\" (\n  %NUGET_PATH% install \"NUnit.Runners\" -Version 2.6.2 -OutputDirectory %TOOLS_DIR% \n)\n\ndotnet tool restore\n\necho Running FAKE Build...\ndotnet tool run fake --silent run %SCRIPT_DIR%\\build.fsx %*\n"
        },
        {
          "name": "build.fsx.lock",
          "type": "blob",
          "size": 8.2177734375,
          "content": "STORAGE: NONE\nRESTRICTION: == netstandard2.0\nNUGET\n  remote: https://api.nuget.org/v3/index.json\n    BlackFox.VsWhere (1.1)\n      FSharp.Core (>= 4.2.3)\n      Microsoft.Win32.Registry (>= 4.7)\n    Fake.BuildServer.AppVeyor (5.20.4)\n      Fake.Core.Environment (>= 5.20.4)\n      Fake.Core.Process (>= 5.20.4)\n      Fake.Core.String (>= 5.20.4)\n      Fake.Core.Trace (>= 5.20.4)\n      Fake.IO.FileSystem (>= 5.20.4)\n      Fake.Net.Http (>= 5.20.4)\n      FSharp.Core (>= 4.7.2)\n    Fake.Core.CommandLineParsing (5.20.4)\n      FParsec (>= 1.1.1)\n      FSharp.Core (>= 4.7.2)\n    Fake.Core.Context (5.20.4)\n      FSharp.Core (>= 4.7.2)\n    Fake.Core.Environment (5.20.4)\n      FSharp.Core (>= 4.7.2)\n    Fake.Core.FakeVar (5.20.4)\n      Fake.Core.Context (>= 5.20.4)\n      FSharp.Core (>= 4.7.2)\n    Fake.Core.Process (5.20.4)\n      Fake.Core.Environment (>= 5.20.4)\n      Fake.Core.FakeVar (>= 5.20.4)\n      Fake.Core.String (>= 5.20.4)\n      Fake.Core.Trace (>= 5.20.4)\n      Fake.IO.FileSystem (>= 5.20.4)\n      FSharp.Core (>= 4.7.2)\n      System.Collections.Immutable (>= 1.7.1)\n    Fake.Core.SemVer (5.20.4)\n      FSharp.Core (>= 4.7.2)\n    Fake.Core.String (5.20.4)\n      FSharp.Core (>= 4.7.2)\n    Fake.Core.Target (5.20.4)\n      Fake.Core.CommandLineParsing (>= 5.20.4)\n      Fake.Core.Context (>= 5.20.4)\n      Fake.Core.Environment (>= 5.20.4)\n      Fake.Core.FakeVar (>= 5.20.4)\n      Fake.Core.Process (>= 5.20.4)\n      Fake.Core.String (>= 5.20.4)\n      Fake.Core.Trace (>= 5.20.4)\n      FSharp.Control.Reactive (>= 4.4.2)\n      FSharp.Core (>= 4.7.2)\n    Fake.Core.Tasks (5.20.4)\n      Fake.Core.Trace (>= 5.20.4)\n      FSharp.Core (>= 4.7.2)\n    Fake.Core.Trace (5.20.4)\n      Fake.Core.Environment (>= 5.20.4)\n      Fake.Core.FakeVar (>= 5.20.4)\n      FSharp.Core (>= 4.7.2)\n    Fake.Core.Xml (5.20.4)\n      Fake.Core.String (>= 5.20.4)\n      FSharp.Core (>= 4.7.2)\n    FAKE.Dotnet (2.0)\n    Fake.DotNet.Cli (5.20.4)\n      Fake.Core.Environment (>= 5.20.4)\n      Fake.Core.Process (>= 5.20.4)\n      Fake.Core.String (>= 5.20.4)\n      Fake.Core.Trace (>= 5.20.4)\n      Fake.DotNet.MSBuild (>= 5.20.4)\n      Fake.DotNet.NuGet (>= 5.20.4)\n      Fake.IO.FileSystem (>= 5.20.4)\n      FSharp.Core (>= 4.7.2)\n      Mono.Posix.NETStandard (>= 1.0)\n      Newtonsoft.Json (>= 12.0.3)\n    Fake.DotNet.MSBuild (5.20.4)\n      BlackFox.VsWhere (>= 1.1)\n      Fake.Core.Environment (>= 5.20.4)\n      Fake.Core.Process (>= 5.20.4)\n      Fake.Core.String (>= 5.20.4)\n      Fake.Core.Trace (>= 5.20.4)\n      Fake.IO.FileSystem (>= 5.20.4)\n      FSharp.Core (>= 4.7.2)\n      MSBuild.StructuredLogger (>= 2.1.176)\n    Fake.DotNet.NuGet (5.20.4)\n      Fake.Core.Environment (>= 5.20.4)\n      Fake.Core.Process (>= 5.20.4)\n      Fake.Core.SemVer (>= 5.20.4)\n      Fake.Core.String (>= 5.20.4)\n      Fake.Core.Tasks (>= 5.20.4)\n      Fake.Core.Trace (>= 5.20.4)\n      Fake.Core.Xml (>= 5.20.4)\n      Fake.IO.FileSystem (>= 5.20.4)\n      Fake.Net.Http (>= 5.20.4)\n      FSharp.Core (>= 4.7.2)\n      Newtonsoft.Json (>= 12.0.3)\n      NuGet.Protocol (>= 5.6)\n    Fake.DotNet.Testing.NUnit (5.20.4)\n      Fake.Core.Environment (>= 5.20.4)\n      Fake.Core.Process (>= 5.20.4)\n      Fake.Core.String (>= 5.20.4)\n      Fake.Core.Trace (>= 5.20.4)\n      Fake.IO.FileSystem (>= 5.20.4)\n      Fake.Testing.Common (>= 5.20.4)\n      FSharp.Core (>= 4.7.2)\n    Fake.IO.FileSystem (5.20.4)\n      Fake.Core.String (>= 5.20.4)\n      FSharp.Core (>= 4.7.2)\n    Fake.IO.Zip (5.20.4)\n      Fake.Core.String (>= 5.20.4)\n      Fake.IO.FileSystem (>= 5.20.4)\n      FSharp.Core (>= 4.7.2)\n    Fake.Net.Http (5.20.4)\n      Fake.Core.Trace (>= 5.20.4)\n      FSharp.Core (>= 4.7.2)\n    Fake.Testing.Common (5.20.4)\n      Fake.Core.Trace (>= 5.20.4)\n      FSharp.Core (>= 4.7.2)\n    Fake.Tools.Git (5.20.4)\n      Fake.Core.Environment (>= 5.20.4)\n      Fake.Core.Process (>= 5.20.4)\n      Fake.Core.SemVer (>= 5.20.4)\n      Fake.Core.String (>= 5.20.4)\n      Fake.Core.Trace (>= 5.20.4)\n      Fake.IO.FileSystem (>= 5.20.4)\n      FSharp.Core (>= 4.7.2)\n    FParsec (1.1.1)\n      FSharp.Core (>= 4.3.4)\n    FSharp.Control.Reactive (5.0.2)\n      FSharp.Core (>= 4.7.2)\n      System.Reactive (>= 5.0)\n    FSharp.Core (5.0.2)\n    Microsoft.Build (16.11)\n    Microsoft.Build.Framework (16.11)\n      System.Security.Permissions (>= 4.7)\n    Microsoft.Build.Tasks.Core (16.11)\n      Microsoft.Build.Framework (>= 16.11)\n      Microsoft.Build.Utilities.Core (>= 16.11)\n      Microsoft.NET.StringTools (>= 1.0)\n      Microsoft.Win32.Registry (>= 4.3)\n      System.CodeDom (>= 4.4)\n      System.Collections.Immutable (>= 5.0)\n      System.Reflection.Metadata (>= 1.6)\n      System.Resources.Extensions (>= 4.6)\n      System.Security.Cryptography.Pkcs (>= 4.7)\n      System.Security.Cryptography.Xml (>= 4.7)\n      System.Security.Permissions (>= 4.7)\n      System.Threading.Tasks.Dataflow (>= 4.9)\n    Microsoft.Build.Utilities.Core (16.11)\n      Microsoft.Build.Framework (>= 16.11)\n      Microsoft.NET.StringTools (>= 1.0)\n      Microsoft.Win32.Registry (>= 4.3)\n      System.Collections.Immutable (>= 5.0)\n      System.Configuration.ConfigurationManager (>= 4.7)\n      System.Security.Permissions (>= 4.7)\n      System.Text.Encoding.CodePages (>= 4.0.1)\n    Microsoft.NET.StringTools (1.0)\n      System.Memory (>= 4.5.4)\n      System.Runtime.CompilerServices.Unsafe (>= 5.0)\n    Microsoft.NETCore.Platforms (5.0.2)\n    Microsoft.NETCore.Targets (5.0)\n    Microsoft.Win32.Registry (5.0)\n      System.Buffers (>= 4.5.1)\n      System.Memory (>= 4.5.4)\n      System.Security.AccessControl (>= 5.0)\n      System.Security.Principal.Windows (>= 5.0)\n    Mono.Posix.NETStandard (1.0)\n    MSBuild.StructuredLogger (2.1.545)\n      Microsoft.Build (>= 16.10)\n      Microsoft.Build.Framework (>= 16.10)\n      Microsoft.Build.Tasks.Core (>= 16.10)\n      Microsoft.Build.Utilities.Core (>= 16.10)\n    Newtonsoft.Json (13.0.1)\n    NuGet.Common (5.11)\n      NuGet.Frameworks (>= 5.11)\n    NuGet.Configuration (5.11)\n      NuGet.Common (>= 5.11)\n      System.Security.Cryptography.ProtectedData (>= 4.4)\n    NuGet.Frameworks (5.11)\n    NuGet.Packaging (5.11)\n      Newtonsoft.Json (>= 9.0.1)\n      NuGet.Configuration (>= 5.11)\n      NuGet.Versioning (>= 5.11)\n      System.Security.Cryptography.Cng (>= 5.0)\n      System.Security.Cryptography.Pkcs (>= 5.0)\n    NuGet.Protocol (5.11)\n      NuGet.Packaging (>= 5.11)\n    NuGet.Versioning (5.11)\n    System.Buffers (4.5.1)\n    System.CodeDom (5.0)\n    System.Collections.Immutable (5.0)\n      System.Memory (>= 4.5.4)\n    System.Configuration.ConfigurationManager (5.0)\n      System.Security.Cryptography.ProtectedData (>= 5.0)\n      System.Security.Permissions (>= 5.0)\n    System.Formats.Asn1 (5.0)\n      System.Buffers (>= 4.5.1)\n      System.Memory (>= 4.5.4)\n    System.Memory (4.5.4)\n      System.Buffers (>= 4.5.1)\n      System.Numerics.Vectors (>= 4.4)\n      System.Runtime.CompilerServices.Unsafe (>= 4.5.3)\n    System.Numerics.Vectors (4.5)\n    System.Reactive (5.0)\n      System.Runtime.InteropServices.WindowsRuntime (>= 4.3)\n      System.Threading.Tasks.Extensions (>= 4.5.4)\n    System.Reflection.Metadata (5.0)\n      System.Collections.Immutable (>= 5.0)\n    System.Resources.Extensions (5.0)\n      System.Memory (>= 4.5.4)\n    System.Runtime (4.3.1)\n      Microsoft.NETCore.Platforms (>= 1.1.1)\n      Microsoft.NETCore.Targets (>= 1.1.3)\n    System.Runtime.CompilerServices.Unsafe (5.0)\n    System.Runtime.InteropServices.WindowsRuntime (4.3)\n      System.Runtime (>= 4.3)\n    System.Security.AccessControl (5.0)\n      System.Security.Principal.Windows (>= 5.0)\n    System.Security.Cryptography.Cng (5.0)\n    System.Security.Cryptography.Pkcs (5.0.1)\n      System.Buffers (>= 4.5.1)\n      System.Formats.Asn1 (>= 5.0)\n      System.Memory (>= 4.5.4)\n      System.Security.Cryptography.Cng (>= 5.0)\n    System.Security.Cryptography.ProtectedData (5.0)\n      System.Memory (>= 4.5.4)\n    System.Security.Cryptography.Xml (5.0)\n      System.Memory (>= 4.5.4)\n      System.Security.Cryptography.Pkcs (>= 5.0)\n      System.Security.Permissions (>= 5.0)\n    System.Security.Permissions (5.0)\n      System.Security.AccessControl (>= 5.0)\n    System.Security.Principal.Windows (5.0)\n    System.Text.Encoding.CodePages (5.0)\n      System.Runtime.CompilerServices.Unsafe (>= 5.0)\n    System.Threading.Tasks.Dataflow (5.0)\n    System.Threading.Tasks.Extensions (4.5.4)\n      System.Runtime.CompilerServices.Unsafe (>= 4.5.3)\n"
        }
      ]
    }
  ]
}