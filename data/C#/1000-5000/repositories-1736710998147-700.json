{
  "metadata": {
    "timestamp": 1736710998147,
    "page": 700,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "oleg-shilo/cs-script",
      "stars": 1693,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 2.458984375,
          "content": "###############################################################################\n# Set default behavior to automatically normalize line endings.\n###############################################################################\n* text=auto\n\n###############################################################################\n# Set default behavior for command prompt diff.\n#\n# This is need for earlier builds of msysgit that does not have it on by\n# default for csharp files.\n# Note: This is only used by command line\n###############################################################################\n#*.cs     diff=csharp\n\n###############################################################################\n# Set the merge driver for project and solution files\n#\n# Merging from the command prompt will add diff markers to the files if there\n# are conflicts (Merging from VS is not affected by the settings below, in VS\n# the diff markers are never inserted). Diff markers may cause the following \n# file extensions to fail to load in VS. An alternative would be to treat\n# these files as binary and thus will always conflict and require user\n# intervention with every merge. To do so, just uncomment the entries below\n###############################################################################\n#*.sln       merge=binary\n#*.csproj    merge=binary\n#*.vbproj    merge=binary\n#*.vcxproj   merge=binary\n#*.vcproj    merge=binary\n#*.dbproj    merge=binary\n#*.fsproj    merge=binary\n#*.lsproj    merge=binary\n#*.wixproj   merge=binary\n#*.modelproj merge=binary\n#*.sqlproj   merge=binary\n#*.wwaproj   merge=binary\n\n###############################################################################\n# behavior for image files\n#\n# image files are treated as binary by default.\n###############################################################################\n#*.jpg   binary\n#*.png   binary\n#*.gif   binary\n\n###############################################################################\n# diff behavior for common document formats\n# \n# Convert binary document formats to text before diffing them. This feature\n# is only available from the command line. Turn it on by uncommenting the \n# entries below.\n###############################################################################\n#*.doc   diff=astextplain\n#*.DOC   diff=astextplain\n#*.docx  diff=astextplain\n#*.DOCX  diff=astextplain\n#*.dot   diff=astextplain\n#*.DOT   diff=astextplain\n#*.pdf   diff=astextplain\n#*.PDF   diff=astextplain\n#*.rtf   diff=astextplain\n#*.RTF   diff=astextplain\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 4.3349609375,
          "content": "## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n\n# User-specific files\n*.suo\n*.user\n*.userosscache\n*.sln.docstates\n\n# User-specific files (MonoDevelop/Xamarin Studio)\n*.userprefs\n\n# Build results\n[Dd]ebug/\n[Dd]ebugPublic/\n[Rr]elease/\n[Rr]eleases/\nx64/\nx86/\nbld/\n[Bb]in/\n[Oo]bj/\n[Ll]og/\n\n# Visual Studio 2015 cache/options directory\n.vs/\n# Uncomment if you have tasks that create the project's static files in wwwroot\n#wwwroot/\n\n# MSTest test Results\n[Tt]est[Rr]esult*/\n[Bb]uild[Ll]og.*\n\n# NUNIT\n*.VisualState.xml\nTestResult.xml\n\n# Build Results of an ATL Project\n[Dd]ebugPS/\n[Rr]eleasePS/\ndlldata.c\n\n# DNX\nproject.lock.json\nproject.fragment.lock.json\nartifacts/\n\n*_i.c\n*_p.c\n*_i.h\n*.ilk\n*.meta\n*.obj\n*.pch\n*.pdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.tmp_proj\n*.log\n*.vspscc\n*.vssscc\n.builds\n*.pidb\n*.svclog\n*.scc\n\n# Chutzpah Test files\n_Chutzpah*\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opendb\n*.opensdf\n*.sdf\n*.cachefile\n*.VC.db\n*.VC.VC.opendb\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n*.sap\n\n# TFS 2012 Local Workspace\n$tf/\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*/\n*.[Rr]e[Ss]harper\n*.DotSettings.user\n\n# JustCode is a .NET coding add-in\n.JustCode\n\n# TeamCity is a build add-in\n_TeamCity*\n\n# DotCover is a Code Coverage Tool\n*.dotCover\n\n# NCrunch\n_NCrunch_*\n.*crunch*.local.xml\nnCrunchTemp_*\n\n# MightyMoose\n*.mm.*\nAutoTest.Net/\n\n# Web workbench (sass)\n.sass-cache/\n\n# Installshield output folder\n[Ee]xpress/\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish/\n\n# Publish Web Output\n*.[Pp]ublish.xml\n*.azurePubxml\n# TODO: Comment the next line if you want to checkin your web deploy settings\n# but database connection strings (with potential passwords) will be unencrypted\n#*.pubxml\n*.publishproj\n\n# Microsoft Azure Web App publish settings. Comment the next line if you want to\n# checkin your Azure Web App publish settings, but sensitive information contained\n# in these scripts will be unencrypted\nPublishScripts/\n\n# NuGet Packages\n*.nupkg\n# The packages folder can be ignored because of Package Restore\n**/packages/*\n# except build/, which is used as an MSBuild target.\n!**/packages/build/\n# Uncomment if necessary however generally it will be regenerated when needed\n#!**/packages/repositories.config\n# NuGet v3's project.json files produces more ignoreable files\n*.nuget.props\n*.nuget.targets\n\n# Microsoft Azure Build Output\ncsx/\n*.build.csdef\n\n# Microsoft Azure Emulator\necf/\nrcf/\n\n# Windows Store app package directories and files\nAppPackages/\nBundleArtifacts/\nPackage.StoreAssociation.xml\n_pkginfo.txt\n\n# Visual Studio cache files\n# files ending in .cache can be ignored\n*.[Cc]ache\n# but keep track of directories ending in .cache\n!*.[Cc]ache/\n\n# Others\nClientBin/\n~$*\n*~\n*.dbmdl\n*.dbproj.schemaview\n*.jfm\n*.pfx\n*.publishsettings\nnode_modules/\norleans.codegen.cs\n\n# Since there are multiple workflows, uncomment next line to ignore bower_components\n# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)\n#bower_components/\n\n# RIA/Silverlight projects\nGenerated_Code/\n\n# Backup & report files from converting an old project file\n# to a newer Visual Studio version. Backup files are not needed,\n# because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\nUpgradeLog*.htm\n\n# SQL Server files\n*.mdf\n*.ldf\n\n# Business Intelligence projects\n*.rdl.data\n*.bim.layout\n*.bim_*.settings\n\n# Microsoft Fakes\nFakesAssemblies/\n\n# GhostDoc plugin setting file\n*.GhostDoc.xml\n\n# Node.js Tools for Visual Studio\n.ntvs_analysis.dat\n\n# Visual Studio 6 build log\n*.plg\n\n# Visual Studio 6 workspace options file\n*.opt\n\n# Visual Studio LightSwitch build output\n**/*.HTMLClient/GeneratedArtifacts\n**/*.DesktopClient/GeneratedArtifacts\n**/*.DesktopClient/ModelManifest.xml\n**/*.Server/GeneratedArtifacts\n**/*.Server/ModelManifest.xml\n_Pvt_Extensions\n\n# Paket dependency manager\n.paket/paket.exe\npaket-files/\n\n# FAKE - F# Make\n.fake/\n\n# JetBrains Rider\n.idea/\n*.sln.iml\n\n# CodeRush\n.cr/\n\n# Python Tools for Visual Studio (PTVS)\n__pycache__/\n*.pyc\n/Source/.NET Core/spike\n/Source/.NET Core/css/spike\n/Source/.NET Core/prepare_publish_cs-script.core.cmd\nsrc/chocolatey/cs-script.7z\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0517578125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2018 oleg-shilo\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.52734375,
          "content": "[![stand with Ukraine](https://img.shields.io/badge/stand_with-ukraine-ffd700.svg?labelColor=0057b7)](https://stand-with-ukraine.pp.ua)\n\n# CS-Script\n<img align=\"right\" src=\"https://raw.githubusercontent.com/oleg-shilo/cs-script/master/src/logo/css_logo_100x100.png\" alt=\"\" style=\"float:right\">\n\n---\n\nThis page is a one-minute-read info about the brightest features of the system. The complete overview can be found on [Wiki](https://github.com/oleg-shilo/cs-script/wiki/CS-Script-Overview)    \n\n---\n_Please note that this repository is hosting the releases of CS-Script (v4.0.0 and higher). The previous content of this repository and wiki (.NET Framework edition of CS-Script) has been moved to the new repository: https://github.com/oleg-shilo/cs-script.net-framework_\n\n_Note .NET SDK is required to have all features. However, the core features can utilized even with .NET Runtime only. See [details](https://github.com/oleg-shilo/cs-script/wiki/Choosing-Compiler-Engine#compiler-technology-comparison)._\n\n---\n[![CI](https://github.com/oleg-shilo/cs-script/actions/workflows/dotnet-desktop.yml/badge.svg)](https://github.com/oleg-shilo/cs-script/actions/workflows/dotnet-desktop.yml)\n[![Build status](https://ci.appveyor.com/api/projects/status/github/oleg-shilo/cs-script?svg=true)](https://ci.appveyor.com/project/oleg-shilo/cs-script) [![Chocolatey Version](http://img.shields.io/chocolatey/v/cs-script.svg?style=flat-square)](http://chocolatey.org/packages/cs-script) [![Chocolatey Downloads](http://img.shields.io/chocolatey/dt/cs-script.svg?style=flat-square)](http://chocolatey.org/packages/cs-script) [![NuGet version (CS-Script)](https://img.shields.io/nuget/v/CS-Script.svg?style=flat-square)](https://www.nuget.org/packages/CS-Script/)\n\n[![paypal](https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif)](https://oleg-shilo.github.io/cs-script/Donation.html)\n\nCS-Script is a CLR-based scripting system that uses ECMA-compliant C# as a programming language.\n\nCS-Script is one of the most mature C# scripting solutions. It became publicly available in 2004, just two years after the first release of .NET. It was the first comprehensive scripting platform for .NET\n\nCS-Script supports both hosted and standalone (CLI) execution models. This makes it possible to use the script engine as a pure C# alternative for PowerShell. As well as extending .NET applications with C# scripts executed at runtime by the hosted script engine.\n\nCS-Script allows seamlessly switching underlying compiling technology without affecting the code base. Currently supported compilers are _dotnet.exe_ and _csc.exe_. \n\nCS-Script also offers comprehensive integration with the most common development tools:\n\n- Visual Studio (built-in feature via `-vs` CLI argument)\n- [VSCode](https://github.com/oleg-shilo/cs-script.vscode)\n- [Sublime Text 3](https://github.com/oleg-shilo/cs-script-sublime)\n- _Legacy .NET Framework plugins that are yet to be ported to .NET 5:_\n  - [Notepad++](https://github.com/oleg-shilo/cs-script.npp) .\n  - [Visual Studio](https://github.com/oleg-shilo/CS-Script.VSIX)\n\nIt can be run on Win and Linux. Class library for hosting the script engine is compiled for \".NET Standard\" so it can be hosted by any managed application.\n\nOver the long history of CS-Script it has been downloaded through Notepad++ x86 plugin manager alone over ![](https://oleg-shilo.github.io/cs-script/download.stats/css.npp.count.jpeg) times ([stats](https://www.cs-script.net/cs-script/download.stats/daily_downloads.html) till July 2017).\n\n<hr/>\n\n_**Documentation disclaimer**_\nPlease be aware that the online [Documentation Wiki](https://github.com/oleg-shilo/cs-script/wiki) is intended to provide the most detailed information about the product. It is constantly evolving and sometimes may have be a little out of sync concerning the latest product releases. \n\nThough, the most accurate and concise documentation is embedded in the engine executable and can be accessed via CLI \"help\" command:\n```ps\ncss -help\n```\n\nA copy of the help content can be accessed [here](help.txt)\n\n#### _**Howto get CS-Script**_\n\nNote, every [release](https://github.com/oleg-shilo/cs-script/releases) comes with a detailed description of how to deploy/integrate CS-Script on/with your environment or application. This covers various package distribution solutions\n- .NET Tools\n- Chocolatey\n- WinGet\n- Debian package \n- NuGet package\n\n<hr/>\n\nThe following section describes a few use cases just to give you an idea about the product:\n\n_**CLI: Executing script from shell**_\n\nCS-Script follows many elements of the Python user experience model. Thus a script can reference other scripts, .NET assemblies or even NuGet packages. It also uses Python style caching ensuring that script that was executed at least once is never compiled again unless the script code is changes. This ensures ultimate performance. Thus script execution speed of the consecutive runs matches the excution of fully compiled .NET applications.  \n\nCreate a simple console script:\n_You can script any type of application that .NET supports (e.g. WinForm, WPF, WEB API) and in two supported syntaxes: C# and VB._\n\n```ps\ncscs -new script.cs\n```\n\nThis creates a sample script file with a sample code. Of course you can also create the script file by yourself. This is a top-level class script:\n\n```C#\nusing System;\n\nConsole.WriteLine(user());\n\nstring user()\n    => Environment.UserName;\n```\n\nExecute script file directly in cmd-prompt/linux-shell without building an executable assembly:\n```\ncss .\\script.cs\n```\nNote, while the script engine CLI executables is `cscs.exe` (on Win) and `cscs` (on Linux) you can use `css` shim that is available in both win and linux distro.\n\n_**CLI: Executing script from IDE**_\n\nWhile various IDEs can be used VSCode is arguably the simplest one.\nYou can either load the existing script into it with `css -vscode .\\script.cs` or create a new script within the IDE if you install the [CS-Script extension](https://marketplace.visualstudio.com/items?itemName=oleg-shilo.cs-script):\n![](https://user-images.githubusercontent.com/16729806/108838856-53b3e500-7628-11eb-8979-9b464484afec.gif)  \n\n\n_**Hosting script engine**_\n\nYou can host the script engine in any .NET application. The class library is distributed as a NuGet package [CS-Script](https://www.nuget.org/packages/CS-Script/). \n\n```ps\nInstall-Package CS-Script\n```\n\nThe library is built against _.NET Standard 2.0_ so it can be hosted on any edition of runtime. However the script evaluation is done via .NET 5 tool chain so it needs to be installed on the host PC even if the application is implemented with the older framework (e.g. .NET Framework).\n\nThese are just a few samples:\n_The complete content of samples can be found [here](https://github.com/oleg-shilo/cs-script.core/blob/master/src/CSScriptLib/src/CSScriptLib/samples.cs)._\n\n```C#\npublic interface ICalc\n{\n    int Sum(int a, int b);\n}\n...\n// you can but don't have to inherit your script class from ICalc\nICalc calc = CSScript.Evaluator\n                     .LoadCode<ICalc>(@\"using System;\n                                        public class Script\n                                        {\n                                            public int Sum(int a, int b)\n                                            {\n                                                return a+b;\n                                            }\n                                        }\");\nint result = calc.Sum(1, 2);\n```\n\n```C#\ndynamic script = CSScript.Evaluator\n                         .LoadMethod(@\"int Product(int a, int b)\n                                       {\n                                           return a * b;\n                                       }\");\n\nint result = script.Product(3, 2);\n```\n\n```C#\npublic interface ICalc\n{\n    int Sum(int a, int b);\n    int Div(int a, int b);\n}\n...\nICalc script = CSScript.Evaluator\n                       .LoadMethod<ICalc>(@\"public int Sum(int a, int b)\n                                            {\n                                                return a + b;\n                                            }\n                                            public int Div(int a, int b)\n                                            {\n                                                return a/b;\n                                            }\");\nint result = script.Div(15, 3);\n```\n\n```C#\nvar log = CSScript.Evaluator\n                  .CreateDelegate(@\"void Log(string message)\n                                    {\n                                        Console.WriteLine(message);\n                                    }\");\n\nlog(\"Test message\");\n```\n\n```C#\nint sum = CSScript.Evaluator.Eval(\"6 + 3\");\n```\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "help.txt",
          "type": "blob",
          "size": 43.1953125,
          "content": "C# Script execution engine (.NET Core). Version 4.8.26.0.\nCopyright (C) 2004-2023 Oleg Shilo.\n\nUsage: cscs <switch 1> <switch 2> <file> [params] [//x]\n\nfile\tSpecifies name of a script file to be run.\nparams\tSpecifies optional parameters for a script file to be run.\n//x\tLaunch debugger just before starting the script.\n---------\n<switch 1>\n\n--help|-help|-? [<command>|<scope[:md]>|<-out:<file>>]\n    Displays either generic or command specific help info.\n    \n       <command> - one of the supported CLI commands\n       <scope>  \n             cli    - print documentation for all CLI commands\n             syntax - print the complete documentation for scripting syntax\n             md     - print the documentation in GitHub markdown format\n             (e.g. -help cli:md)\n       <file>    - output file for the help content\n    \n    Reversed order of parameters for the command specific help is also acceptable. The all following argument\n    combinations print the same help topic for 'cache' command:\n    \n       -help cache\n       -? cache\n       -cache help\n       -cache ?\n\n-e\n    Compiles script into console application executable.\n    Note this switch will force the use of dotnet compiler as csc is not capable of building executable\n    assemblies. Thus //css_engine and -engine options will always be ignored.\n\n-ew\n    Compiles script into Windows application executable (applicable only on Windows).\n    Note this switch will force the use of dotnet compiler as csc is not capable of building executable\n    assemblies. Thus //css_engine and -engine options will always be ignored.\n\n-rx\n    Run script as an external process. This option is incompatible with VB scripts.\n    This mode allows execution of the scripts that are otherwise incompatible with the runtime of the script engine\n    (e.g. x86 vs x64, .NETCore vs .NETFramework).\n    Note, this execution mode comes with some limitations (depending on the compilation engine):\n     - csc \n       The compiled script is executed with dotnet.exe launcher (e.g. dotnet script.dll).\n     - dotnet \n       The compiled script is executed directly as exe(e.g. script.exe).\n     - roslyn \n       This mode is not supported as Roslyn scripts do not support static main.\n\n-c[:<0|1>]\n    Executes compiled script cache (e.g. <cache dir>/script.cs.dll) if found.\n    This command improves performance by avoiding compiling the script if it was not changed since last execution.\n    \n       -c:1|-c  - enable caching\n       -c:0     - disable caching (which might be enabled globally)\n\n-ca\n    Compiles script file into cache file (e.g. <cache dir>/script.cs.dll).\n\n-cd\n    Compiles script file into assembly (.dll) in the script folder without execution.\n\n-check\n    Checks script for errors without execution.\n\n-proj\n    Shows script 'project info' - script and all its dependencies.\n    An internal-use version of this command '-proj:csproj' can be also useful for troubleshooting.\n\n-vs <script>|-vs:init [index_of_detected_VS_executable]\n    Generates .NET project file and opens it in Visual Studio.\n    The path to the Visual Studio executable (devenv.exe) needs to be defined in the environment variable\n    CSSCRIPT_VSEXE.\n    You can let CS-Script to detect installed Visual Studio executable and interactively select the detected\n    executable for integrating it with CS-Script by using -vs:init option.\n    Alternatively, you can even ask to integrate the first detected executable with: \n          cscs -vs:init 0\n\n-vscode\n    Generates .NET project file and opens it in Visual Studio Code.\n    The path to the Visual Studio Code executable (code.exe) needs to be defined in the environment variable\n    CSSCRIPT_VSCODEEXE.\n\n-cache[:<ls|trim|clear>]\n    Performs script cache operations.\n    \n     ls    - lists all cache items.\n     trim  - removes all abandoned cache items.\n     clear - removes all cache items.\n\n-co:<options>\n    Passes compiler options directly to the language compiler (e.g. csc.exe or dotnet.exe).\n    Note, some compiler options may not be compatible if they are passed to the wrong compiler executable (see\n    compiler documentation). Though the fundamental switches like /platform:* are converted by CS-Script into\n    compatible version between csc.exe and dotnet.exe.\n    (e.g.  -co:/d:TRACE pass /d:TRACE option to C# compiler\n     or    -co:/platform:x86 to produce Win32 executable)\n\n-ng|-engine:<csc|dotnet|roslyn>\n    Forces compilation to be done by one of the supported .NET engines.\n      \n    dotnet - dotnet.exe compiler; this is the most versatile compilation engine though it does have a startup\n               overhead when running the script for the first time. It requires .NET SDK to be installed on the target\n               system.\n      \n    csc   - csc.exe compiler; the fastest compiler available. It is not suitable for WPF scripts as csc.exe cannot\n              compile XAML.\n              The compilation is performed in the separate child process build.exe which is somewhat equivalent to\n              VBCSCompiler.exe (build server) from .NET toolset. It requires .NET SDK to be installed on the target\n              system.\n              CS-Script communicates with build.exe build server via socket (default port 17001). You can control port\n              value via the environment variable 'CSS_BUILDSERVER_CSC_PORT'\n              Value csc-inproc will suppress spinning off an build server process and .NET csc.exe will be called\n              directly instead. This option convenient when socket communication is undesirable for whatever reason.\n              Though in this case all the performance benefits of -ng:csc will be lost and then you are better off\n              using -ng:dotnet instead.\n      \n    roslyn - Microsoft.CodeAnalysis.CSharp.Scripting.dll compiler; this is the most portable compilation engine. It\n               does not require .NET SDK being installed. Though it does have limitations (see documentation).\n               The compilation is performed in the separate child process cscs (another instance of script engine)\n               which is somewhat equivalent of VBCSCompiler.exe (build server) from .NET toolset.\n               CS-Script communicates with cscs build server via socket (default port 17002). You can control port\n               value via the environment variable 'CSS_BUILDSERVER_ROSLYN_PORT'\n               Value roslyn-inproc will suppress spinning off an external process and Roslyn compiler will be hosted\n               in the original process of script engine instead. This option is convenient when socket communication\n               is undesirable for whatever reason. Though in this case performance will be effected on the first run\n               of the script.\n      \n    \n    (e.g. cscs -engine:dotnet sample.cs\n          cscs -ng:csc sample.cs\n          cscs -ng:roslyn-inproc sample.cs\n          cscs -ng:roslyn sample.cs)\n\n-s|-sample[:<C# version>]\n     -s:7    - prints C# 7+ sample. Otherwise, it prints the default canonical 'Hello World' sample.\n    (e.g. cscs -s:7 > sample.cs).\n\n-new[:<type>] [<script name>]\n    Creates a new script.\n    Usage: -new[:<type>] [<otput file>]\n          type - script template based on available types.\n          output - location to place the generated script file(s).\n    \n    Type           Template\n    ---------------------------------------------------\n    console         Console script application (Default)\n    console-vb      Console VB script application\n    winform         Windows Forms (WinForms) script application\n    winform-vb      Windows Forms (WinForms) VB script application\n    wpf             WPF script application\n    wpf-cm          Caliburn.Micro based WPF script application\n    toplevel|top    Top-level class script application with no entry point\n    toplevel-x      Top-level class script application with no entry point; an advanced CS-Script integration samples.\n    cmd             Custom command script. See https://github.com/oleg-shilo/cs-script/wiki/Custom-Commands.\n     \n    Legacy templates:\n    auto            Auto-class (classless) script application; use 'toplevel' instead\n    freestyle       Freestyle (no entry point) script application; use 'toplevel' instead\n     \n    Examples:\n        cscs -new script\n        cscs -new:toplevel script.cs\n        cscs -new:console console.cs\n        cscs -new:winform myapp.cs\n        cscs -new:wpf hello\n        cscs -new:cmd edit\n\n-code[:show] <script code>\n    Executes script code directly without using a script file.\n    Sample:\n     \n    \n    cscs -code \"Console.WriteLine(Environment.UserDomainName);#nConsole.WriteLine(#''%USERNAME%#'');\"\n    cscs -code \"using System.Linq;#nSystem.Diagnostics.Process.GetProcessesByName(''notepad'').ToList().ForEach(x =>\n    x.Kill());\"\n    cscs -code \"SetEnvironmentVariable(ntp,notepad.exe, EnvironmentVariableTarget.Machine)\"\n    \n     \n    The -code argument must be the last argument in the command. The only argument that is allowed after the <script\n    code> is //x\n     \n    Escaping special characters sometimes can be problematic as many shells have their own techniques (e.g. PowerShell\n    collapses two single quote characters) that may conflict with CS-Script escaping approach.This is the reason why\n    CS-Script offers multiple escape techniques.\n    It can be beneficial during the troubleshooting to use -code:show command that outputs the received CLI\n    arguments and the interpreted C# code without the execution.\n     \n    Since command-line interface does not allow some special characters they need to be escaped.\n    \n    Escaped         Interpreted character\n    -------------------------------------\n    #n        ->    <\\n>\n    #r        ->    <\\r>\n    #''       ->    \"   \n    ''        ->    \"   \n    #         ->    \"   \n    n         ->    <\\n>\n    r         ->    <\\r>\n            ->    \"\n\n-wait[:prompt]\n    Waits for user input after the execution before exiting.\n    If specified the execution will proceed with exit only after any std input is received.\n    Applicable for console mode only.\n    prompt - if none specified 'Press any key to continue...' will be used\n\n-ac|-autoclass[:<0|1|2|out>]\n    Legacy command: executes scripts without class definition. Use top-level statements (C# 9) scripts instead.\n    \n     -ac     - enables auto-class decoration (which might be disabled globally).\n     -ac:0   - disables auto-class decoration (which might be enabled globally).\n     -ac:1   - same as '-ac'\n     -ac:2   - same as '-ac:1' and '-ac'\n     -ac:out - prints auto-class decoration for a given script file. The argument must be followed by the path to\n               script file.\n    \n     \n    Automatically generates 'static entry point' class if the script doesn't define any.\n     \n    \n        using System;\n     \n        void Main()\n        {\n            Console.WriteLine(\"Hello World!\");\n        }\n     \n    \n    Using an alternative 'instance entry point' is even more convenient (and reliable).\n    The acceptable 'instance entry point' signatures are:\n     \n        void main()\n        void main(string[] args)\n        int main()\n        int main(string[] args)\n     \n    Note, having any active code above entry point is acceptable though it complicates the troubleshooting if such a\n    code contains errors. (see https://github.com/oleg-shilo/cs-script/wiki/CLI---User-Guide#command-auto-class)\n     \n    By default CS-Script decorates the script by adding a class declaration statement to the start of the script\n    routine and a class closing bracket to the end. This may have an unintended effect as any class declared in the\n    script becomes a 'nested class'. While it is acceptable for practically all use-cases it may be undesired for just\n    a few scenarios. For example, any class containing method extensions must be a top-level static class, which\n    conflicts with the auto-class decoration algorithm.\n     \n    The solution to this problem is to allow some user code to be protected from being included in the decorated code.\n    Users can achieve this by placing '//css_ac_end' statement into the code. Any user code below this statement will\n    be excluded from the decoration and stay unchanged.\n\n---------\n<switch 2>\n\n-dbg|-d\n    Forces compiler to include debug information.\n\n-l[:<0|1>]\n    'local' (makes the script directory a 'current directory'). '1' is a default value.\n\n-v|-ver|--version [output file]\n    Prints CS-Script version information.\n\n-dbgprint[:<0:1>]\n    Controls whether to enable Python-like print methods (e.g. dbg.print(DateTime.Now)).\n    This setting allows controlling dynamic referencing of script engine assembly containing the implementation of\n    Python-like print methods dbg.print and derived extension methods object.print() and object.dup(). While\n    dbg.print is extremely useful it can and lead to some referencing challenges when the script being executed is\n    referencing assemblies compiled with dbg.print already included. The simplest way to solve this problem is to\n    disable the dbg.cs inclusion.\n    \n     -dbgprint:1   enable dbg.cs inclusion; Same as -dbgprint;\n     -dbgprint:0   disable dbg.cs inclusion;\n\n-verbose\n    Prints runtime information during the script execution.\n    '-verbose2' additionally echoes compiling engine (e.g. csc.dll) input and output.\n    (applicable for console clients only)\n\n-profile\n    Prints script loading performance information during the script execution.\n\n-speed\n    Prints script initialization/compilation time information of the .NET compiler. \n    You can use -ng option () \n    It is a convenient way of testing performance of the .NET distribution.\n\n-install/-uninstall\n    Sets/unsets CSSCRIPT_ROOT environment variable to the location of the script engine being executed.\n    This environment variable is required for integration of CS-Script with Notepad++,Sublime Text and some other\n    editors, which require CS-Script installed on the host OS.\n    This command is only supported on Windows\n\n-server[:<start|stop|restart|add|remove|ping>]\n    Prints the information about build server.\n    Note, the server starts automatically on the script execution that is configured to use the 'csc' or 'roslyn'\n    engine.\n    Build server is a background process, which implements top loading of C# compiler csc.exe. Somewhat similar to\n    VBCSCompiler.exe.\n    These options are only relevant if the compiler engine is set to 'csc' or roslyn (see '-engine' command).\n    Note, the build server is deployed on the first execution of the script with csc or roslyn engine.\n    Though on Linux it has to be an execution with root privileges. Or you can just run sudo css -server:add.\n    \n     -server:start   - deploys and starts build server. Useful if you want to start the server on system startup.\n     -server:stop    - stops build server\n     -server:restart - restarts build server\n     -server:reset   - stops, re-deploys and starts build server\n     -server:add     - deploys build server\n     -server:remove  - removes build server files. Useful for troubleshooting.\n     -server:ping    - Pins running instance (if any) of the build server\n    \n    The following options are only relevant if the compiler engine is set to 'roslyn' (see '-engine' command).\n    Roslyn based build server variant is much simpler so it only exposes start and stop interface.\n    \n     -server_r:start - deploys and starts Roslyn build server\n     -server_r:stop  - stops Roslyn build server\n    \n    And this is how you can start and stop both Roslyn and csc build servers with a single command:\n    \n     -servers:start - deploys and starts both Roslyn and csc build server\n     -servers:stop  - stops both Roslyn and csc build server\n     -kill          - a complete equivalent of -servers:stop\n\n-netfx\n    Compile and execute the script on the latest .NET Framework compiler (csc.exe) found on the system.\n    The script will be automatically executed as an external process thus the value of the -rx switchwill be ignored.\n\n-tc\n    Trace compiler input produced by CS-Script code provider CSSRoslynProvider.dll.\n    It's useful when troubleshooting custom compilers (e.g. Roslyn on Linux).\n\n-wpf[:<enable|disable|1|0>]\n    Enables/disables WPF support on Windows by updating the framework name in the *.runtimeconfig.json file\n    \n     -wpf               - prints current enabled status\n     -wpf:<enable|1>    - enables WPF support\n     -wpf:<disable|0>   - disables WPF support\n\n-config[:<option>]\n    Performs various CS-Script config operations\n    \n     -config:none                   - ignores config file (uses default settings)\n     -config:create                 - creates config file with default settings\n     -config:default                - prints default config file\n     -config:<raw|xml>              - prints current config file content\n     -config[:ls]                   - lists/prints current config values\n     -config:<name> ?               - prints help for the configuration value specified by name\n     -config:get:<name>             - prints current config value\n     -config::<name>                - the same as -config:get:name\n     -config:set:<name>=<value>     - sets current config value\n     -config:set:<name>=add:<value> - updates the current config value content by appending the specified value.\n     -config:set:<name>=del:<value> - updates the current config value content by removing all occurrences of the\n                                      specified value.\n     -config:<file>                 - uses custom config file\n    \n     \n    Note: The property name in -config:set and -config:set is case insensitive and can also contain '_' as a token\n    separator that is ignored during property lookup.\n    \n    (e.g. cscs -config:none sample.cs\n          cscs -config:default > css_VB.xml\n          cscs -config:set:DefaultCompilerEngine=dotnet\n          cscs -config:set:DefaultArguments=add:-ac\n          cscs -config:set:default_arguments=del:-ac\n          cscs -config:c:\\cs-script\\css_VB.xml sample.vb)\n\n-out[:<file>]\n    Forces the script to be compiled into a specific location.\n    Used only for very fine hosting tuning.\n    (e.g. cscs -out:%temp%\\%pid%\\sample.dll sample.cs\n\n-r:<assembly 1>,<assembly N>\n    Uses explicitly referenced assembly.\n    It is required only for rare cases when namespace cannot be resolved into assembly.\n    (e.g. cscs /r:myLib.dll myScript.cs).\n\n-dir:<directory 1>,<directory N>\n    Adds path(s) to the assembly probing directory list.\n    You can use the reserved word 'show' as a directory name to print the configured probing directories.\n    (e.g. cscs -dir:C:\\MyLibraries myScript.cs; cscs -dir:show).\n\n-precompiler[:<file 1>,<file N>]\n    Specifies custom precompiler. This can be either script or assembly file.\n    Alias - pc[:<file 1>,<file N>]\n    If no file(s) specified prints the code template for the custom precompiler. The special value 'print' has the\n    same effect (e.g. cscs -pc:print).\n    There is a special reserved word 'nodefault' to be used as a file name. It instructs script engine to prevent\n    loading any built-in precompilers like the one for removing shebang before the execution.\n    (see https://www.cs-script.net/cs-script/help-legacy/precompilers.html)\n\n-pvdr|-provider:<file>\n    Location of the alternative/custom code provider assembly.\n    Alias - pvdr:<file>\n    If set it forces script engine to use an alternative code compiler.\n     \n    C#7 support is implemented via Roslyn based provider: '-pvdr:CSSRoslynProvider.dll'.If the switch is not specified\n    CSSRoslynProvider.dll file will be use as a code provider if it is found in the same folder where the script\n    engine is. Automatic CSSRoslynProvider.dll loading can be disabled with a special 'none' argument: -pvdr:none.\n    (see https://www.cs-script.net/cs-script/help-legacy/help/non_cs_compilers.html)\n\n-nuget[:restore]\n    Installs new or updates existing NuGet packages. It is a very close equivalent of dotnet restore command\n    \n     -nuget         - prints the list of all root packages in the repository\n     -nuget:restore - Downloads and installs all packages specified in the script without executing the script.\n                      Effectively it is an equivalent of -check but with the forced nuget packages restore operation.\n                      Using this option is an alternative to having '//css_nuget -force ...' directive in the script\n                      code as it may be a more convenient way of updating packages manually instead of having them\n                      updated on every script execution/recompilation.\n                      You can set CSS_RESTORE_DONOT_CLEAN environment variable to disable removing temporary folders\n                      created during restore operations. This can be useful for troubleshooting NuGet packages\n                      restoring.\n    ---------------------------------------------\n    Note: A the current NuGet support model is available since v4.7.0. The old options of this -nuget command that\n    are only available with the legacy NuGet support algorithm. This mode can be enabled by setting\n    LegacyNugetSupport option to false: css -config:set:LegacyNugetSupport=true. Read more:\n    https://github.com/oleg-shilo/cs-script/wiki/NuGet-Support\n     \n    Legacy CLI:\n     \n    -nuget[:<package|restore>]\n    This command allows a lightweight management of the NuGet packages. The functionality is limited to installing,\n    restoring and updating the packages.\n    \n     -nuget           - prints the list of all root packages in the repository\n     -nuget:<package> - downloads and installs the latest version of the package(s). \n                        Wild cards can be used to update multiple packages. For example '-nuget:ServiceStack*' will\n                        update all already installed ServiceStack packages.\n                        You can also use the index of the package instead of its full name.\n                        (Not available with new NuGet support)\n     -nuget:restore   - Downloads and installs all packages specified in the script without executing the script.\n\n-syntax\n    Prints documentation for CS-Script specific C# syntax.\n\n-commands|-cmd\n    Prints list of supported commands (arguments) as well as the custom commands defined by user.\n\n-list|-ls [<kill|k> | <kill-all|ka>\n    Prints list of all currently running scripts.\n    If script execution tracking is undesirable you can disable it by setting DisableCSScriptProcessTracking\n    environment variable to a non empty value.\n     kill|k      - Allow user to select and user to select and terminate any running script.\n     *           - Terminate all running scripts when 'kill' option is used.\n                   (e.g. cscs -list kill * ).\n\n---------\n\n\n**************************************\nCS-Script specific syntax\n**************************************\n \nEngine directives:\n- //css_include <file>;\n- //css_import <file>[, preserve_main][, rename_namespace(<oldName>, <newName>)];\n- //css_nuget [-force] package0[,package1]..[,packageN];\n- //css_nuget [-noref] [-force[:delay]] [-ver:<version>] [-rt:<runtime>] [-ng:<nuget arguments>]\npackage0[,package1]..[,packageN];\n- //css_args arg0[,arg1]..[,argN];\n- //css_reference <file>;\n- //css_precompiler <file 1>,<file 2>;\n- //css_searchdir <directory>;\n- //css_winapp\n- //css_webapp\n- //css_autoclass [style]\n- //css_resource <file>[, <out_file>];\n- //css_co <options>;\n- //css_engine <csc|dotnet|roslyn>;\n- //css_ignore_namespace <namespace>;\n- //css_ac_end\n- //css_prescript file([arg0][,arg1]..[,argN])[ignore];\n- //css_postscript file([arg0][,arg1]..[,argN])[ignore];\n------------------------------------\nEngine directives can be controlled (enabled/disabled) with compiler conditional symbols and environment variables via\nthe inline #if syntax:\n \n\n  //css_include #if DEBUG debug_utils.cs\n  //css_dir #if (DEBUG) .\\bin\\Debug\n  //css_reference #if PRODUCTION_PC d:\\temp\\build\\certificates.dll\n\n------------------------------------\nThe script engine also always defines special compiler conditional symbol CS_SCRIPT:\n \n\n  #if CS_SCRIPT\n       Console.WriteLine(\"Running as a script...\");\n  #endif\n\nThe script engine also defines another conditional symbol NETCORE to allow userto distinguish between executions\nunder .NET (full) and .NET Core\n------------------------------------\n//css_include <file>;\n \nAlias - //css_inc\n \nfile - name of a script file to be included at compile-time.\n \nThis directive is available for both CLI and hosted script execution.\n \nThis directive is used to import/include one script into another one. It is a logical equivalent of '#include' in C++.\n \nIf a relative file path is specified with a single-dot prefix it will be automatically converted into the absolute\npath with respect to the location of the script file containing the //css_include directive. Otherwise it will be\nresolved with respect to the process current directory.\n \nIf for whatever reason it is preferred to always resolve path expression with respect to the parent script location\nyou can configure the script engine to do it with the following command:\n \n\n   cscs -config:set:ResolveRelativeFromParentScriptLocation = true\n \n \nNote, if you use a wildcard in the imported script name (e.g. ./*_build.cs) the directive will only import from the\nfirst probing directory where the matching file(s) is found. Be careful with the wide wildcard as '*.cs' as they may\nlead to unpredictable behavior. For example they may match everything from the very first probing directory, which is\ntypically a current directory. Using more specific wildcards is arguably more practical (e.g. 'utils/*.cs',\n'*Helper.cs', './*.cs')\n------------------------------------\n//css_import <file>[, preserve_main][, rename_namespace(<oldName>, <newName>)];\n \nAlias - //css_imp\n \nThis is a more specialized version of the default script importing directive //css_include (//css_inc) with some extra\nrenaming functionality.\nWhile //css_include simply includes a script file in the execution as is, //css_import analyzes the file being\nimported and renames namespaces and static Main(...) to avoid naming collisions. Thus you should use it only if you\nhave naming collision problems.\n \nfile             - name of a script file to be imported at compile-time.\npreserve_main    - do not rename 'static Main'. \n                   .NET allows only one entry point 'static Main' method per application.Thus it is a problem if the\n                   primary and the imported scripts both contain 'static Main'.To avoid this the script engine\n                   searches the imported script for 'static Main' method and renames it in 'i_Main' and then uses a\n                   temporary copy of the processed imported script during the execution. If you need to use the\n                   imported script as is, then you should use 'preserve_main' argument with the '//css_import'\n                   directive.\nrename_namespace - rename namespace clause, it can appear in the directive multiple times\noldName          - name of a namespace to be renamed during importing\nnewName          - new name of a namespace to be renamed during importing\n \n------------------------------------\n \n//css_nuget [-force] package0[,package1]..[,packageN];\n \nDownloads/Installs the NuGet package. It also automatically references the downloaded package assemblies.\nBy default, the package is not downloaded again if it was already downloaded.\nCS-Script uses dotnet.exe to manage NuGet packages. This makes the developer experience fully consistent with\ntraditional SW development of compiled .NET applications.\n\n -force - switch to force individual packages downloading even when they were already downloaded.\n \n Examples: //css_nuget cs-script;\n           //css_nuget -force NLog\n \n--- Legacy NuGet support ---\n \nBefore v4.7.0 CS-SCript was relying on nuget.exe, the only option available in .NET at that time.\nTo allow backwards compatibility this mode is still available and it can be enabled by setting LegacyNugetSupport\nconfiguration value option to false with css -config:set:LegacyNugetSupport=true\nRead more: https://github.com/oleg-shilo/cs-script/wiki/NuGet-Support\n \nNote: Legacy NuGet support is less reliable, predictable or flexible (e.g. does not support package native assets)\nthus it's highly recommend that you use this mode only if you have to.\n \nThe legacy NuGet support CLI is somewhat different:\n//css_nuget [-noref] [-force[:delay]] [-ver:<version>] [-rt:<runtime>] [-ng:<nuget arguments>]\npackage0[,package1]..[,packageN];\n \nIf no version is specified then the highest downloaded version (if any) will be used.\nReferencing the downloaded packages can only handle simple dependency scenarios when all downloaded assemblies are to\nbe referenced.\nYou should use '-noref' switch and reference assemblies manually for all other cases. For example multiple assemblies\nwith the same file name that target different CLRs (e.g. v3.5 vs v4.0) in the same package.\nSwitches:\n \n\n -noref         - switch for individual packages if automatic referencing isn't desired.\n                  You can use 'css_nuget' environment variable for further referencing package content (e.g. //css_dir\n                  %css_nuget%\\WixSharp\\**)\n                  (Not available with new NuGet support)\n -force[:delay] - switch to force individual packages downloading even when they were already downloaded.\n                  You can optionally specify a delay for the next forced downloading by the number of seconds since\n                  last download.\n                  '-force:3600' will delay it for one hour. This option is useful for preventing frequent download\n                  interruptions during active script development.\n                  (Not available with new NuGet support)\n -ver:<version> - switch to download/reference a specific package version.\n -rt:<runtime>  - switch to use specific runtime binaries (e.g. '-rt:netstandard1.3').\n                  (Not available with new NuGet support)\n -ng:<args>     - switch to pass nuget.exe/dotnet restore arguments for every individual package.\n                  (-restore: as an alias of this switch)\n \n \nExample: //css_nuget cs-script;\n         //css_nuget -restore:\"-v minimal\" -ver:4.1.2 NLog\n         //css_nuget -ver:4.1.2 -restore:\"-f --no-cache\" NLog\n         //css_nuget -ver:\"4.1.1-rc1\" -rt:netstandard2.0 -ng:\"-f --no-cache\" NLog\n \nThis directive will install CS-Script NuGet package.\n(see http://www.csscript.net/help/script_nugets.html)\n------------------------------------\n//css_args arg0[,arg1]..[,argN];\n \nEmbedded script arguments. Both script and engine arguments are allowed except \"/noconfig\" engine command switch.\n \nExample: //css_args -dbg, -inmem;\nThis directive will always force the script engine to execute the script in debug mode.\nNote: the arguments must be coma separated.\n------------------------------------\n//css_reference <file>;\n \nAlias - //css_ref\n \nfile - name of the assembly file to be loaded at run-time.\nThis directive is used to reference assemblies required at run time.\nThe assembly must be in GAC, the same folder with the script file or in the 'Script Library' folders (see 'CS-Script\nsettings').\n \nNote if you use wildcard in the referenced assembly name (e.g. socket.*.dll) the directive will only reference from\nthe first probing directory where the matching file(s) is found. Be careful with the wide wildcard as '*.dll' as they\nmay lead to unpredictable behavior. For example they may match everything from the very first probing directory, which\nis typically a current directory. Using more specific wildcards is arguably more practical (e.g. 'utils/*.dll',\n'*Helper.dll', './*.dll')\n \n------------------------------------\n//css_precompiler <file 1>,<file 2>;\n \nAlias - //css_pc\n \nfile - name of the script or assembly file implementing precompiler.\n \nThis directive is used to specify the CS-Script precompilers to be loaded and exercised against script at run time\njust before compiling it. Precompilers are typically used to alter the script coder before the execution. Thus\nCS-Script uses built-in precompiler to decorate classless scripts executed with -autoclass switch.\n(see http://www.csscript.net/help/precompilers.html\n------------------------------------\n//css_searchdir <directory>;\n \nAlias - //css_dir\n \ndirectory - name of the directory to be used for script and assembly probing at run-time.\n \nThis directive is used to extend set of search directories (script and assembly probing).\nThe directory name can be a wildcard based expression.In such a case all directories matching the pattern will be this\ncase all directories will be probed.\nThe special case when the path ends with '**' is reserved to indicate 'sub directories' case. Examples:\n\n    //css_dir packages\\ServiceStack*.1.0.21\\lib\\net40\n    //css_dir packages\\**\n\n------------------------------------\n//css_winapp\n \nAlias - //css_winapp\n \nAdds search directories required for running WinForm and WPF scripts.\nNote: you need to use csws.exe engine to run WPF scripts.\nAlternatively you can set environment variable 'CSS_WINAPP' to non empty value and css.exe shim will redirect the\nexecution to the csws.exe executable.\n------------------------------------\n//css_webapp\n \nAlias - //css_webapp\n \nIndicates that the script app needs to be compiled against Microsoft.AspNetCore.App framework.\nA typical example is a WebAPI script application.\n------------------------------------\n//css_autoclass [style]\n \nAlias - //css_ac\n \nOBSOLETE, use top-class native C# 9 feature instead\nAutomatically generates 'static entry point' class if the script doesn't define any.\n \n    //css_ac\n    using System;\n \n    void Main()\n    {\n        Console.WriteLine(\"Hello World!\");\n    }\n \nUsing an alternative 'instance entry point' is even more convenient (and reliable).\nThe acceptable 'instance entry point' signatures are:\n\n    void main()\n    void main(string[] args)\n    int main()\n    int main(string[] args)\n \nThe convention for the classless (auto-class) code structure is as follows:\n - set of 'using' statements\n - classless 'main' \n - user code \n - optional //css_ac_end directive\n - optional user code that is not a subject of auto-class decoration\n(see https://github.com/oleg-shilo/cs-script/wiki/CLI-Script-Execution#command-auto-class)\n \nA special case of auto-class use case is a free style C# code that has no entry point 'main' at all:\n \n    //css_autoclass freestyle\n    using System;\n \n    Console.WriteLine(Environment.Version);\n \nSince it's problematic to reliable auto-detect free style auto-classes, they must be defined with the special\nparameter 'freestyle' after the '//css_ac' directive\n \nBy default, CS-Script decorates the script by adding a class declaration statement to the start of the script routine\nand a class-closing bracket to the end. This may have an unintended effect as any class declared in the script becomes\na 'nested class'. While it is acceptable for practically all use-cases it may be undesired for just a few scenarios.\nFor example, any class containing method extensions must be a top-level static class, which conflicts with the\nauto-class decoration algorithm.\n \nAn additional '//css_autoclass_end' ('//css_ac_end') directive can be used to solve this problem.\n \nIt's nothing else but a marker indicating the end of the code that needs to be decorated as (wrapped into) an\nauto-class.\nThis directive allows defining top level static classes in the class-less scripts, which is required for implementing\nextension methods.\n \n //css_ac\n using System;\n \n void main()\n {\n     ...\n }\n \n //css_ac_end\n \n static class Extensions\n {\n     static public string Convert(this string text)\n     {\n         ...\n     }\n }\n \n------------------------------------\n//css_resource <file>[, <out_file>];\n \nAlias - //css_res\n \nfile     - name of the compiled resource file (.resources) to be used with the script.\n             Alternatively, it can be the name of the XML resource file (.resx) that will be compiled on-fly.\nout_file  - Optional name of the compiled resource file (.resources) to be generated form the .resx input.If not\n             supplied then the compiled file will have the same name as the input file but the file extension '.resx'\n             changed to '.resources'.\n \nThis directive is used to reference resource file for script.\n Example: //css_res Scripting.Form1.resources;\n          //css_res Resources1.resx;\n          //css_res Form1.resx, Scripting.Form1.resources;\n------------------------------------\n//css_co <options>;\n \noptions - options string.\n \nThis directive is used to pass compiler options string directly to the language-specific CLR compiling engine.\nNote: \n- the options may not be compatible with the compiling engine of your choice (see //css_engine).Thus //css_co\n/define:CS_SCRIPT will work for csc engine but will not for dotnet since it does not support /define.\n- character ; in compiler options interferes with //css_... directives so try to avoid it. Thus use -d:DEBUG\n-d:NET4 instead of -d:DEBUG;NET4\n Example: //css_co /d:TRACE pass /d:TRACE option to C# compiler\n          //css_co /platform:x86 to produce Win32 executable\n          //css_co -nullable:enable -warnaserror:nullable to enable nullable reference types.\n------------------------------------\n//css_engine <csc|dotnet|roslyn>;\n \nAlias - //css_ng\n \nThis directive is used to select compiler services for building a script into an assembly.\n \n dotnet - use dotnet.exe and on-fly .NET projects.\n          This is a default compiler engine that handles well even complicated heterogeneous multi-file scripts like\n          WPF scripts.\n csc    - use csc.exe. \n          This compiler shows much better performance. Though it is not suitable for WPF scripts.\nThis feature is conceptually similar to the VBCSCompiler.exe build server, which is not available in in\n.NET5/.NET-Core. Even though available on .NET-Fx (Roslyn).\n          Using this option can in order of magnitude improve compilation speed. However it's not suitable for\n          compiling WPF scripts because csc.exe cannot compile XAML.\n          While this feature is useful it will be deprecated when .NET5+ starts distributing its own properly working\n          build server VBCSCompiler.exe.\nroslyn - use Microsoft.CodeAnalysis.CSharp.Scripting.dll (Roslyn). \n         This compiler shows good performance and does not require .NET SDK. Though, it is not suitable for WPF\n         scripts. See [this wiki](https://github.com/oleg-shilo/cs-script/wiki/Choosing-Compiler-Engine) for details.\n \n Example: //css_engine csc\n------------------------------------\n//css_ignore_namespace <namespace>;\n \nAlias - //css_ignore_ns\n \nnamespace - name of the namespace. Use '*' to completely disable namespace resolution\n \nThis directive is used to prevent CS-Script from resolving the referenced namespace into the assembly.\n------------------------------------\n//css_ac_end\n \nThis directive is only applicable for class-less scripts executed with '-autoclass' CLI argument. It's nothing else\nbut a marker indicating the end of the code that needs to be decorated as (wrapped into) an auto-class.\nThis directive allows achieving top-level static classes in the class-less scripts, which is required for implementing\nextension methods.\n \n //css_args -autoclass\n using System;\n \n void main()\n {\n     ...\n }\n \n //css_ac_end\n \n static class Extensions\n {\n     static public void Convert(this string text)\n     {\n         ...\n     }\n }\n \n------------------------------------\n//css_prescript file([arg0][,arg1]..[,argN])[ignore];\n \nAlias - //css_pre\n \nfile    - script file (extension is optional)\narg0..N - script string arguments\nignore  - continue execution of the main script in case of error\n \nThese directives are used to execute secondary pre-execution scripts.\nIf $this (or $this.name) is specified as arg0..N it will be replaced at execution time with the main script full name\n(or file name only).\nYou may find that in many cases precompilers (//css_pc and -pc) are a more powerful and flexible alternative to the\npre-execution script.\n------------------------------------\n//css_postscript file([arg0][,arg1]..[,argN])[ignore];\nAlias - //css_post\n \nfile    - script file (extension is optional)\narg0..N - script string arguments\nignore  - continue execution of the main script in case of error\n \nThese directives are used to execute secondary post-execution scripts.\nIf $this (or $this.name) is specified as arg0..N it will be replaced at execution time with the main script full name\n(or file name only).\n \n-------------------------------------\n \nNote the script engine always sets the following environment variables:\n pid                     - host processId (e.g. Environment.GetEnvironmentVariable(\"pid\")\n CSScriptRuntime         - script engine version\n CSScriptRuntimeLocation - script engine location\n cscs_exe_dir            - script engine directory\n EntryScript             - location of the entry script\n EntryScriptAssembly     - location of the compiled script assembly\n location:<asm_hash>     - location of the compiled script assembly.\n \nThis variable is particularly useful as it allows finding the compiled assembly file from the inside of the script\ncode. Even when the script loaded in-memory (InMemoryAssembly setting) but not from the original file. (e.g. var\nlocation = Environment.GetEnvironmentVariable(\"location:\" + Assembly.GetExecutingAssembly().GetHashCode()); \n \nNote that the default setting of 'location:<asm_hash>' is disabled. You can enable it by setting\n'CSS_SCRIPTLOCATIONREFLECTION' environment variable to non empty string.\n \nThe following is the optional set of environment variables that the script engine uses to improve the user experience:\n \n 'CSS_NUGET' \n      location of the NuGet packages, which scripts can load/reference\n \n 'CSSCRIPT_ROOT'\n      script engine location. Used by the engine to locate dependencies (e.g. resgen.exe). Typically this variable is\n      during the CS-Script installation.\n \n 'CSSCRIPT_CONSOLE_ENCODING_OVERWRITE'\n      script engine output encoding if the one from the css_confix.xml needs to be overwritten.\n \n 'CSSCRIPT_INC'\n      a system-wide include directory for the all frequently used user scripts.\n \n 'CSSCRIPT_CSC_CMD_LOG'\n      the location of the log file that will be created during the script execution with the 'csc' compiler engine.the\n      file will contain the command line that is used to start csc.exe to compile the script. This behavior is\n      useful for the advanced debugging scenarios. Of the environment variable is not set or the value is not a valid\n      file path then no log file will be created.\n \n---------\nDuring the script execution CS-Script always injects a little object inspector class 'dbg'. This class contains static\nprinting methods that mimic Python's 'print()'. It is particularly useful for object inspection in the absence of a\nproper debugger.\n \nExamples:\n  dbg.print(\"Now:\", DateTime.Now)        - prints concatenated objects.\n  dbg.print(DateTime.Now)                - prints object and values of its properties.\n  dbg.printf(\"Now: {0}\", DateTime.Now)   - formats and prints object and values of its fields and properties.\n \n---------\nAny directive has to be written as a single line in order to have no impact on compiling by CLI compliant compiler.It\nalso must be placed before any namespace or class declaration.\n \n---------\nExample:\n \n //css_include web_api_host.cs;\n //css_reference media_server.dll;\n //css_nuget Newtonsoft.Json;\n \n using System;\n using static dbg;\n \n class MediaServer\n {\n     static void Main(string[] args)\n     {\n         print(args);\n \n         WebApi.SimpleHost(args)\n               .StartAsConosle(\"http://localhost:8080\");\n   }\n }\n \nOr shorter form:\n \n //css_args -ac\n //css_inc web_api_host.cs\n //css_ref media_server.dll\n //css_nuget Newtonsoft.Json\n \n using System;\n \n void main(string[] args)\n {\n     print(args);\n \n     WebApi.SimpleHost(args)\n           .StartAsConosle(\"http://localhost:8080\");\n }\n \n---------\n Project Website: https://github.com/oleg-shilo/cs-script\n\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}