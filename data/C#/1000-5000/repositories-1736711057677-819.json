{
  "metadata": {
    "timestamp": 1736711057677,
    "page": 819,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "sonicether/SEGI",
      "stars": 1511,
      "defaultBranch": "master",
      "files": [
        {
          "name": "Demo Scene.meta",
          "type": "blob",
          "size": 0.1865234375,
          "content": "fileFormatVersion: 2\nguid: 40179eb5518caa642b27dfbca905e94c\nfolderAsset: yes\ntimeCreated: 1465533948\nlicenseType: Pro\nDefaultImporter:\n  userData: \n  assetBundleName: \n  assetBundleVariant: \n"
        },
        {
          "name": "Demo Scene",
          "type": "tree",
          "content": null
        },
        {
          "name": "Editor.meta",
          "type": "blob",
          "size": 0.1865234375,
          "content": "fileFormatVersion: 2\nguid: b1d5c75d8d4db414999f6a063263bbea\nfolderAsset: yes\ntimeCreated: 1451700781\nlicenseType: Pro\nDefaultImporter:\n  userData: \n  assetBundleName: \n  assetBundleVariant: \n"
        },
        {
          "name": "Editor",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0419921875,
          "content": "MIT License\n\nCopyright (c) 2017 sonicether\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.13671875,
          "content": "<p align=\"center\">\n  <img src=\"https://i.imgur.com/gtkjoxj.png\">\n</p>\n\n# SEGI\nA fully-dynamic voxel-based global illumination system for Unity. More details at http://www.sonicether.com/segi/\n\n<p align=\"center\" style=\"display: inline-block;\">\n  <img height=\"248px\" width=\"440px\" src=\"https://i.imgur.com/xoR4ab6.jpg\">\n  <img height=\"248px\" width=\"440px\" src=\"https://i.imgur.com/m0S2k0C.jpg\">\n</p>\n\n# Installation\nCheck the [Releases](https://github.com/sonicether/SEGI/releases) section above to download a version of SEGI that is a simple .unitypackage file which is ready for you to import into your project. \n\nYou can also click the \"Clone or Download\" button and select \"Download Zip\", then extract the contents to \"Assets/SEGI\" in your project to test out the latest unreleased versions of SEGI.\n\nAll the scripts and files for SEGI must be in \"Assets/SEGI\" for SEGI to fully function properly in your project.\n\nPlease refer to the User Guide.pdf for usage instructions.\n\n# Community\nIf you need some help, feel free to ask any questions in the [official thread](https://forum.unity.com/threads/segi-fully-dynamic-global-illumination.410310) on Unity forums.\n"
        },
        {
          "name": "Resources.meta",
          "type": "blob",
          "size": 0.1865234375,
          "content": "fileFormatVersion: 2\nguid: 38f1ddad6fdb5944184d42eb02f56391\nfolderAsset: yes\ntimeCreated: 1465533034\nlicenseType: Pro\nDefaultImporter:\n  userData: \n  assetBundleName: \n  assetBundleVariant: \n"
        },
        {
          "name": "Resources",
          "type": "tree",
          "content": null
        },
        {
          "name": "SEGI.cs",
          "type": "blob",
          "size": 40.33984375,
          "content": "using UnityEngine;\nusing UnityEngine.Rendering;\nusing System.Collections;\nusing System;\nusing System.IO;\nusing System.Runtime.Serialization;\nusing System.Runtime.Serialization.Formatters.Binary;\n\n\n[ExecuteInEditMode]\n#if UNITY_5_4_OR_NEWER\n[ImageEffectAllowedInSceneView]\n#endif\n[RequireComponent(typeof(Camera))]\n[AddComponentMenu(\"Image Effects/Sonic Ether/SEGI\")]\npublic class SEGI : MonoBehaviour\n{\n\n#region Parameters\n\t[Serializable]\n\tpublic enum VoxelResolution\n\t{\n\t\tlow = 128,\n\t\thigh = 256\n\t}\n\n\tpublic bool updateGI = true;\n\tpublic LayerMask giCullingMask = 2147483647;\n\tpublic float shadowSpaceSize = 50.0f;\n\tpublic Light sun;\n\n\tpublic Color skyColor;\n\n\tpublic float voxelSpaceSize = 25.0f;\n\n\tpublic bool useBilateralFiltering = false;\n\n\t[Range(0, 2)]\n\tpublic int innerOcclusionLayers = 1;\n\n\n\t[Range(0.01f, 1.0f)]\n\tpublic float temporalBlendWeight = 0.1f;\n\n\n\tpublic VoxelResolution voxelResolution = VoxelResolution.high;\n\n\tpublic bool visualizeSunDepthTexture = false;\n\tpublic bool visualizeGI = false;\n\tpublic bool visualizeVoxels = false;\n\n\tpublic bool halfResolution = true;\n\tpublic bool stochasticSampling = true;\n\tpublic bool infiniteBounces = false;\n\tpublic Transform followTransform;\n\t[Range(1, 128)]\n\tpublic int cones = 6;\n\t[Range(1, 32)]\n\tpublic int coneTraceSteps = 14;\n\t[Range(0.1f, 2.0f)]\n\tpublic float coneLength = 1.0f;\n\t[Range(0.5f, 6.0f)]\n\tpublic float coneWidth = 5.5f;\n\t[Range(0.0f, 4.0f)]\n\tpublic float occlusionStrength = 1.0f;\n\t[Range(0.0f, 4.0f)]\n\tpublic float nearOcclusionStrength = 0.5f;\n\t[Range(0.001f, 4.0f)]\n\tpublic float occlusionPower = 1.5f;\n\t[Range(0.0f, 4.0f)]\n\tpublic float coneTraceBias = 1.0f;\n\t[Range(0.0f, 4.0f)]\n\tpublic float nearLightGain = 1.0f;\n\t[Range(0.0f, 4.0f)]\n\tpublic float giGain = 1.0f;\n\t[Range(0.0f, 4.0f)]\n\tpublic float secondaryBounceGain = 1.0f;\n\t[Range(0.0f, 16.0f)]\n\tpublic float softSunlight = 0.0f;\n\n\t[Range(0.0f, 8.0f)]\n\tpublic float skyIntensity = 1.0f;\n\n\tpublic bool doReflections = true;\n\t[Range(12, 128)]\n\tpublic int reflectionSteps = 64;\n\t[Range(0.001f, 4.0f)]\n\tpublic float reflectionOcclusionPower = 1.0f;\n\t[Range(0.0f, 1.0f)]\n\tpublic float skyReflectionIntensity = 1.0f;\n\n\tpublic bool voxelAA = false;\n\n\tpublic bool gaussianMipFilter = false;\n\n\n\t[Range(0.1f, 4.0f)]\n\tpublic float farOcclusionStrength = 1.0f;\n\t[Range(0.1f, 4.0f)]\n\tpublic float farthestOcclusionStrength = 1.0f;\n\n\t[Range(3, 16)]\n\tpublic int secondaryCones = 6;\n\t[Range(0.1f, 4.0f)]\n\tpublic float secondaryOcclusionStrength = 1.0f;\n\n\tpublic bool sphericalSkylight = false;\n\n#endregion\n\n\n\n\n\n\n#region InternalVariables\n\tobject initChecker;\n\tMaterial material;\n\tCamera attachedCamera;\n\tTransform shadowCamTransform;\n\tCamera shadowCam;\n\tGameObject shadowCamGameObject;\n    Texture2D[] blueNoise;\n\t\n\tint sunShadowResolution = 256;\n\tint prevSunShadowResolution;\n\n\tShader sunDepthShader;\n\n\tfloat shadowSpaceDepthRatio = 10.0f;\n\n\tint frameCounter = 0;\n\n\n\tRenderTexture sunDepthTexture;\n\tRenderTexture previousGIResult;\n\tRenderTexture previousCameraDepth;\n\n\t///<summary>This is a volume texture that is immediately written to in the voxelization shader. The RInt format enables atomic writes to avoid issues where multiple fragments are trying to write to the same voxel in the volume.</summary>\n\tRenderTexture integerVolume;\n\n\t///<summary>An array of volume textures where each element is a mip/LOD level. Each volume is half the resolution of the previous volume. Separate textures for each mip level are required for manual mip-mapping of the main GI volume texture.</summary>\n\tRenderTexture[] volumeTextures;\n\n\t///<summary>The secondary volume texture that holds irradiance calculated during the in-volume GI tracing that occurs when Infinite Bounces is enabled. </summary>\n\tRenderTexture secondaryIrradianceVolume;\n\n\t///<summary>The alternate mip level 0 main volume texture needed to avoid simultaneous read/write errors while performing temporal stabilization on the main voxel volume.</summary>\n\tRenderTexture volumeTextureB;\n\n\t///<summary>The current active volume texture that holds GI information to be read during GI tracing.</summary>\n\tRenderTexture activeVolume;\n\n\t///<summary>The volume texture that holds GI information to be read during GI tracing that was used in the previous frame.</summary>\n\tRenderTexture previousActiveVolume;\n\n\t///<summary>A 2D texture with the size of [voxel resolution, voxel resolution] that must be used as the active render texture when rendering the scene for voxelization. This texture scales depending on whether Voxel AA is enabled to ensure correct voxelization.</summary>\n\tRenderTexture dummyVoxelTextureAAScaled;\n\n\t///<summary>A 2D texture with the size of [voxel resolution, voxel resolution] that must be used as the active render texture when rendering the scene for voxelization. This texture is always the same size whether Voxel AA is enabled or not.</summary>\n\tRenderTexture dummyVoxelTextureFixed;\n\n\tbool notReadyToRender = false;\n\n\tShader voxelizationShader;\n\tShader voxelTracingShader;\n\n\tComputeShader clearCompute;\n\tComputeShader transferIntsCompute;\n\tComputeShader mipFilterCompute;\n\n\tconst int numMipLevels = 6;\n\n\tCamera voxelCamera;\n\tGameObject voxelCameraGO;\n\tGameObject leftViewPoint;\n\tGameObject topViewPoint;\n\n\tfloat voxelScaleFactor\n\t{\n\t\tget\n\t\t{\n\t\t\treturn (float)voxelResolution / 256.0f;\n\t\t}\n\t}\n\n\tVector3 voxelSpaceOrigin;\n\tVector3 previousVoxelSpaceOrigin;\n\tVector3 voxelSpaceOriginDelta;\n\n\n\tQuaternion rotationFront = new Quaternion(0.0f, 0.0f, 0.0f, 1.0f);\n\tQuaternion rotationLeft = new Quaternion(0.0f, 0.7f, 0.0f, 0.7f);\n\tQuaternion rotationTop = new Quaternion(0.7f, 0.0f, 0.0f, 0.7f);\n\n\tint voxelFlipFlop = 0;\n\n\t\n\tenum RenderState\n\t{\n\t\tVoxelize,\n\t\tBounce\n\t}\n\n\tRenderState renderState = RenderState.Voxelize;\n#endregion\n\n\n\n\n\n#region SupportingObjectsAndProperties\n\tstruct Pass\n\t{\n\t\tpublic static int DiffuseTrace = 0;\n\t\tpublic static int BilateralBlur = 1;\n\t\tpublic static int BlendWithScene = 2;\n\t\tpublic static int TemporalBlend = 3;\n\t\tpublic static int SpecularTrace = 4;\n\t\tpublic static int GetCameraDepthTexture = 5;\n\t\tpublic static int GetWorldNormals = 6;\n\t\tpublic static int VisualizeGI = 7;\n\t\tpublic static int WriteBlack = 8;\n\t\tpublic static int VisualizeVoxels = 10;\n\t\tpublic static int BilateralUpsample = 11;\n\t}\n\n\tpublic struct SystemSupported\n\t{\n\t\tpublic bool hdrTextures;\n\t\tpublic bool rIntTextures;\n\t\tpublic bool dx11;\n\t\tpublic bool volumeTextures;\n\t\tpublic bool postShader;\n\t\tpublic bool sunDepthShader;\n\t\tpublic bool voxelizationShader;\n\t\tpublic bool tracingShader;\n\n\t\tpublic bool fullFunctionality\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\treturn hdrTextures && rIntTextures && dx11 && volumeTextures && postShader && sunDepthShader && voxelizationShader && tracingShader;\n\t\t\t}\n\t\t}\n\t}\n\n\t/// <summary>\n\t/// Contains info on system compatibility of required hardware functionality\n\t/// </summary>\n\tpublic SystemSupported systemSupported;\n\n\t/// <summary>\n\t/// Estimates the VRAM usage of all the render textures used to render GI.\n\t/// </summary>\n\tpublic float vramUsage\n\t{\n\t\tget\n\t\t{\n\t\t\tlong v = 0;\n\n\t\t\tif (sunDepthTexture != null)\n\t\t\t\tv += sunDepthTexture.width * sunDepthTexture.height * 16;\n\n\t\t\tif (previousGIResult != null)\n\t\t\t\tv += previousGIResult.width * previousGIResult.height * 16 * 4;\n\n\t\t\tif (previousCameraDepth != null)\n\t\t\t\tv += previousCameraDepth.width * previousCameraDepth.height * 32;\n\n\t\t\tif (integerVolume != null)\n\t\t\t\tv += integerVolume.width * integerVolume.height * integerVolume.volumeDepth * 32;\n\n\t\t\tif (volumeTextures != null)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < volumeTextures.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (volumeTextures[i] != null)\n\t\t\t\t\t\tv += volumeTextures[i].width * volumeTextures[i].height * volumeTextures[i].volumeDepth * 16 * 4;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (secondaryIrradianceVolume != null)\n\t\t\t\tv += secondaryIrradianceVolume.width * secondaryIrradianceVolume.height * secondaryIrradianceVolume.volumeDepth * 16 * 4;\n\n\t\t\tif (volumeTextureB != null)\n\t\t\t\tv += volumeTextureB.width * volumeTextureB.height * volumeTextureB.volumeDepth * 16 * 4;\n\n\t\t\tif (dummyVoxelTextureAAScaled != null)\n\t\t\t\tv += dummyVoxelTextureAAScaled.width * dummyVoxelTextureAAScaled.height * 8;\n\n\t\t\tif (dummyVoxelTextureFixed != null)\n\t\t\t\tv += dummyVoxelTextureFixed.width * dummyVoxelTextureFixed.height * 8;\n\n\t\t\tfloat vram = (v / 8388608.0f);\n\n\t\t\treturn vram;\n\t\t}\n\t}\n\n\tint mipFilterKernel\n\t{\n\t\tget\n\t\t{\n\t\t\treturn gaussianMipFilter ? 1 : 0;\n\t\t}\n\t}\n\n\tint dummyVoxelResolution\n\t{\n\t\tget\n\t\t{\n\t\t\treturn (int)voxelResolution * (voxelAA ? 2 : 1);\n\t\t}\n\t}\n\n\tint giRenderRes\n\t{\n\t\tget\n\t\t{\n\t\t\treturn halfResolution ? 2 : 1;\n\t\t}\n\t}\n\n#endregion\n\n\n\t///<summary>Applies an SEGIPreset to this instance of SEGI.</summary>\n\tpublic void ApplyPreset(SEGIPreset preset)\n\t{\n\t\tvoxelResolution = preset.voxelResolution;\n\t\tvoxelAA = preset.voxelAA;\n\t\tinnerOcclusionLayers = preset.innerOcclusionLayers;\n\t\tinfiniteBounces = preset.infiniteBounces;\n\n\t\ttemporalBlendWeight = preset.temporalBlendWeight;\n\t\tuseBilateralFiltering = preset.useBilateralFiltering;\n\t\thalfResolution = preset.halfResolution;\n\t\tstochasticSampling = preset.stochasticSampling;\n\t\tdoReflections = preset.doReflections;\n\n\t\tcones = preset.cones;\n\t\tconeTraceSteps = preset.coneTraceSteps;\n\t\tconeLength = preset.coneLength;\n\t\tconeWidth = preset.coneWidth;\n\t\tconeTraceBias = preset.coneTraceBias;\n\t\tocclusionStrength = preset.occlusionStrength;\n\t\tnearOcclusionStrength = preset.nearOcclusionStrength;\n\t\tocclusionPower = preset.occlusionPower;\n\t\tnearLightGain = preset.nearLightGain;\n\t\tgiGain = preset.giGain;\n\t\tsecondaryBounceGain = preset.secondaryBounceGain;\n\n\t\treflectionSteps = preset.reflectionSteps;\n\t\treflectionOcclusionPower = preset.reflectionOcclusionPower;\n\t\tskyReflectionIntensity = preset.skyReflectionIntensity;\n\t\tgaussianMipFilter = preset.gaussianMipFilter;\n\n\t\tfarOcclusionStrength = preset.farOcclusionStrength;\n\t\tfarthestOcclusionStrength = preset.farthestOcclusionStrength;\n\t\tsecondaryCones = preset.secondaryCones;\n\t\tsecondaryOcclusionStrength = preset.secondaryOcclusionStrength;\n\t}\n\n\tvoid Start()\n\t{\n\t\tInitCheck();\n\t}\n\n\tvoid InitCheck()\n\t{\n\t\tif (initChecker == null)\n\t\t{\n\t\t\tInit();\n\t\t}\n\t}\n\n\tvoid CreateVolumeTextures()\n\t{\n\t\tif (volumeTextures != null)\n\t\t{\n\t\t\tfor (int i = 0; i < numMipLevels; i++)\n\t\t\t{\n\t\t\t\tif (volumeTextures[i] != null) {\n\t\t\t\t\tvolumeTextures[i].DiscardContents();\n\t\t\t\t\tvolumeTextures[i].Release();\n\t\t\t\t\tDestroyImmediate(volumeTextures[i]);\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\tvolumeTextures = new RenderTexture[numMipLevels];\n\n\t\tfor (int i = 0; i < numMipLevels; i++)\n\t\t{\n\t\t\tint resolution = (int)voxelResolution / Mathf.RoundToInt(Mathf.Pow((float)2, (float)i));\n\t\t\tvolumeTextures[i] = new RenderTexture(resolution, resolution, 0, RenderTextureFormat.ARGBHalf, RenderTextureReadWrite.Linear);\n\t\t\t#if UNITY_5_4_OR_NEWER\n\t\t\tvolumeTextures[i].dimension = TextureDimension.Tex3D;\n\t\t\t#else\n\t\t\tvolumeTextures[i].isVolume = true;\n\t\t\t#endif\n\t\t\tvolumeTextures[i].volumeDepth = resolution;\n\t\t\tvolumeTextures[i].enableRandomWrite = true;\n\t\t\tvolumeTextures[i].filterMode = FilterMode.Bilinear;\n\t\t\t#if UNITY_5_4_OR_NEWER\n\t\t\tvolumeTextures[i].autoGenerateMips = false;\n\t\t\t#else\n\t\t\tvolumeTextures[i].generateMips = false;\n\t\t\t#endif\n\t\t\tvolumeTextures[i].useMipMap = false;\n\t\t\tvolumeTextures[i].Create();\n\t\t\tvolumeTextures[i].hideFlags = HideFlags.HideAndDontSave;\n\t\t}\n\n\t\tif (volumeTextureB)\n\t\t{\n\t\t\tvolumeTextureB.DiscardContents();\n\t\t\tvolumeTextureB.Release();\n\t\t\tDestroyImmediate(volumeTextureB);\n\t\t}\n\t\tvolumeTextureB = new RenderTexture((int)voxelResolution, (int)voxelResolution, 0, RenderTextureFormat.ARGBHalf, RenderTextureReadWrite.Linear);\n\t\t#if UNITY_5_4_OR_NEWER\n\t\tvolumeTextureB.dimension = TextureDimension.Tex3D;\n\t\t#else\n\t\tvolumeTextureB.isVolume = true;\n\t\t#endif\n\t\tvolumeTextureB.volumeDepth = (int)voxelResolution;\n\t\tvolumeTextureB.enableRandomWrite = true;\n\t\tvolumeTextureB.filterMode = FilterMode.Bilinear;\n\t\t#if UNITY_5_4_OR_NEWER\n\t\tvolumeTextureB.autoGenerateMips = false;\n\t\t#else\n\t\tvolumeTextureB.generateMips = false;\n\t\t#endif\n\t\tvolumeTextureB.useMipMap = false;\n\t\tvolumeTextureB.Create();\n\t\tvolumeTextureB.hideFlags = HideFlags.HideAndDontSave;\n\n\t\tif (secondaryIrradianceVolume)\n\t\t{\n\t\t\tsecondaryIrradianceVolume.DiscardContents();\n\t\t\tsecondaryIrradianceVolume.Release();\n\t\t\tDestroyImmediate(secondaryIrradianceVolume);\n\t\t}\n\t\tsecondaryIrradianceVolume = new RenderTexture((int)voxelResolution, (int)voxelResolution, 0, RenderTextureFormat.ARGBHalf, RenderTextureReadWrite.Linear);\n\t\t#if UNITY_5_4_OR_NEWER\n\t\tsecondaryIrradianceVolume.dimension = TextureDimension.Tex3D;\n\t\t#else\n\t\tsecondaryIrradianceVolume.isVolume = true;\n\t\t#endif\n\t\tsecondaryIrradianceVolume.volumeDepth = (int)voxelResolution;\n\t\tsecondaryIrradianceVolume.enableRandomWrite = true;\n\t\tsecondaryIrradianceVolume.filterMode = FilterMode.Point;\n\t\t#if UNITY_5_4_OR_NEWER\n\t\tsecondaryIrradianceVolume.autoGenerateMips = false;\n\t\t#else\n\t\tsecondaryIrradianceVolume.generateMips = false;\n\t\t#endif\n\t\tsecondaryIrradianceVolume.useMipMap = false;\n\t\tsecondaryIrradianceVolume.antiAliasing = 1;\n\t\tsecondaryIrradianceVolume.Create();\n\t\tsecondaryIrradianceVolume.hideFlags = HideFlags.HideAndDontSave;\n\n\n\n\t\tif (integerVolume)\n\t\t{\n\t\t\tintegerVolume.DiscardContents();\n\t\t\tintegerVolume.Release();\n\t\t\tDestroyImmediate(integerVolume);\n\t\t}\n\t\tintegerVolume = new RenderTexture((int)voxelResolution, (int)voxelResolution, 0, RenderTextureFormat.RInt, RenderTextureReadWrite.Linear);\n\t\t#if UNITY_5_4_OR_NEWER\n\t\tintegerVolume.dimension = TextureDimension.Tex3D;\n\t\t#else\n\t\tintegerVolume.isVolume = true;\n\t\t#endif\n\t\tintegerVolume.volumeDepth = (int)voxelResolution;\n\t\tintegerVolume.enableRandomWrite = true;\n\t\tintegerVolume.filterMode = FilterMode.Point;\n\t\tintegerVolume.Create();\n\t\tintegerVolume.hideFlags = HideFlags.HideAndDontSave;\n\n\t\tResizeDummyTexture();\n\n\t}\n\n\tvoid ResizeDummyTexture()\n\t{\n\t\tif (dummyVoxelTextureAAScaled)\n\t\t{\n\t\t\tdummyVoxelTextureAAScaled.DiscardContents();\n\t\t\tdummyVoxelTextureAAScaled.Release();\n\t\t\tDestroyImmediate(dummyVoxelTextureAAScaled);\n\t\t}\n\t\tdummyVoxelTextureAAScaled = new RenderTexture(dummyVoxelResolution, dummyVoxelResolution, 0, RenderTextureFormat.R8);\n\t\tdummyVoxelTextureAAScaled.Create();\n\t\tdummyVoxelTextureAAScaled.hideFlags = HideFlags.HideAndDontSave;\n\n\t\tif (dummyVoxelTextureFixed)\n\t\t{\n\t\t\tdummyVoxelTextureFixed.DiscardContents();\n\t\t\tdummyVoxelTextureFixed.Release();\n\t\t\tDestroyImmediate(dummyVoxelTextureFixed);\n\t\t}\n\t\tdummyVoxelTextureFixed = new RenderTexture((int)voxelResolution, (int)voxelResolution, 0, RenderTextureFormat.R8);\n\t\tdummyVoxelTextureFixed.Create();\n\t\tdummyVoxelTextureFixed.hideFlags = HideFlags.HideAndDontSave;\n\t}\n\n\tvoid Init()\n\t{\n\t\t//Setup shaders and materials\n\t\tsunDepthShader = Shader.Find(\"Hidden/SEGIRenderSunDepth\");\n\n\t\tclearCompute = Resources.Load(\"SEGIClear\") as ComputeShader;\n\t\ttransferIntsCompute = Resources.Load(\"SEGITransferInts\") as ComputeShader;\n\t\tmipFilterCompute = Resources.Load(\"SEGIMipFilter\") as ComputeShader;\n\n\t\tvoxelizationShader = Shader.Find(\"Hidden/SEGIVoxelizeScene\");\n\t\tvoxelTracingShader = Shader.Find(\"Hidden/SEGITraceScene\");\n\t\t\n\t\tif (!material) {\n\t\t\tmaterial = new Material(Shader.Find(\"Hidden/SEGI\"));\n\t\t\tmaterial.hideFlags = HideFlags.HideAndDontSave;\n\t\t}\n\t\t\n\t\t//Get the camera attached to this game object\n\t\tattachedCamera = this.GetComponent<Camera>();\n\t\tattachedCamera.depthTextureMode |= DepthTextureMode.Depth;\n\t\t#if UNITY_5_4_OR_NEWER\n\t\tattachedCamera.depthTextureMode |= DepthTextureMode.MotionVectors;\n\t\t#endif\n\n\n\t\t//Find the proxy shadow rendering camera if it exists\n\t\tGameObject scgo = GameObject.Find(\"SEGI_SHADOWCAM\");\n\n\t\t//If not, create it\n\t\tif (!scgo)\n\t\t{\n\t\t\tshadowCamGameObject = new GameObject(\"SEGI_SHADOWCAM\");\n\t\t\tshadowCam = shadowCamGameObject.AddComponent<Camera>();\n\t\t\tshadowCamGameObject.hideFlags = HideFlags.HideAndDontSave;\n\n\n\t\t\tshadowCam.enabled = false;\n\t\t\tshadowCam.depth = attachedCamera.depth - 1;\n\t\t\tshadowCam.orthographic = true;\n\t\t\tshadowCam.orthographicSize = shadowSpaceSize;\n\t\t\tshadowCam.clearFlags = CameraClearFlags.SolidColor;\n\t\t\tshadowCam.backgroundColor = new Color(0.0f, 0.0f, 0.0f, 1.0f);\n\t\t\tshadowCam.farClipPlane = shadowSpaceSize * 2.0f * shadowSpaceDepthRatio;\n\t\t\tshadowCam.cullingMask = giCullingMask;\n\t\t\tshadowCam.useOcclusionCulling = false;\n\n\t\t\tshadowCamTransform = shadowCamGameObject.transform;\n\t\t}\n\t\telse\t//Otherwise, it already exists, just get it\n\t\t{\n\t\t\tshadowCamGameObject = scgo;\n\t\t\tshadowCam = scgo.GetComponent<Camera>();\n\t\t\tshadowCamTransform = shadowCamGameObject.transform;\n\t\t}\n\n\n\t\t\n\t\t//Create the proxy camera objects responsible for rendering the scene to voxelize the scene. If they already exist, destroy them\n\t\tGameObject vcgo = GameObject.Find(\"SEGI_VOXEL_CAMERA\");\n\t\t\n\t\tif (!vcgo) {\n\t\t\tvoxelCameraGO = new GameObject(\"SEGI_VOXEL_CAMERA\");\n\t\t\tvoxelCameraGO.hideFlags = HideFlags.HideAndDontSave;\n\n\t\t\tvoxelCamera = voxelCameraGO.AddComponent<Camera>();\n\t\t\tvoxelCamera.enabled = false;\n\t\t\tvoxelCamera.orthographic = true;\n\t\t\tvoxelCamera.orthographicSize = voxelSpaceSize * 0.5f;\n\t\t\tvoxelCamera.nearClipPlane = 0.0f;\n\t\t\tvoxelCamera.farClipPlane = voxelSpaceSize;\n\t\t\tvoxelCamera.depth = -2;\n\t\t\tvoxelCamera.renderingPath = RenderingPath.Forward;\n\t\t\tvoxelCamera.clearFlags = CameraClearFlags.Color;\n\t\t\tvoxelCamera.backgroundColor = Color.black;\n\t\t\tvoxelCamera.useOcclusionCulling = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvoxelCameraGO = vcgo;\n\t\t\tvoxelCamera = vcgo.GetComponent<Camera>();\n\t\t}\n\n\t\tGameObject lvp = GameObject.Find(\"SEGI_LEFT_VOXEL_VIEW\");\n\t\t\n\t\tif (!lvp) {\n\t\t\tleftViewPoint = new GameObject(\"SEGI_LEFT_VOXEL_VIEW\");\n\t\t\tleftViewPoint.hideFlags = HideFlags.HideAndDontSave;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tleftViewPoint = lvp;\n\t\t}\n\n\t\tGameObject tvp = GameObject.Find(\"SEGI_TOP_VOXEL_VIEW\");\n\t\t\n\t\tif (!tvp) {\n\t\t\ttopViewPoint = new GameObject(\"SEGI_TOP_VOXEL_VIEW\");\n\t\t\ttopViewPoint.hideFlags = HideFlags.HideAndDontSave;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttopViewPoint = tvp;\n\t\t}\n\n\t\t//Get blue noise textures\n\t\tblueNoise = null;\n\t\tblueNoise = new Texture2D[64];\n\t\tfor (int i = 0; i < 64; i++)\n\t\t{\n\t\t    string fileName = \"LDR_RGBA_\" + i.ToString();\n\t\t    Texture2D blueNoiseTexture = Resources.Load(\"Noise Textures/\" + fileName) as Texture2D;\n\n\t\t    if (blueNoiseTexture == null)\n\t\t    {\n\t\t\tDebug.LogWarning(\"Unable to find noise texture \\\"Assets/SEGI/Resources/Noise Textures/\" + fileName + \"\\\" for SEGI!\");\n\t\t    } \n\n\t\t    blueNoise[i] = blueNoiseTexture;\n\n\t\t}\n\n\t\t//Setup sun depth texture\n\t\tif (sunDepthTexture)\n\t\t{\n\t\t\tsunDepthTexture.DiscardContents();\n\t\t\tsunDepthTexture.Release();\n\t\t\tDestroyImmediate(sunDepthTexture);\n\t\t}\n\t\tsunDepthTexture = new RenderTexture(sunShadowResolution, sunShadowResolution, 16, RenderTextureFormat.RHalf, RenderTextureReadWrite.Linear);\n\t\tsunDepthTexture.wrapMode = TextureWrapMode.Clamp;\n\t\tsunDepthTexture.filterMode = FilterMode.Point;\n\t\tsunDepthTexture.Create();\n\t\tsunDepthTexture.hideFlags = HideFlags.HideAndDontSave;\n\n\n\t\t//Create the volume textures\n\t\tCreateVolumeTextures();\n\n\n\t\tinitChecker = new object();\n\t}\n\n\tvoid CheckSupport()\n\t{\n\t\tsystemSupported.hdrTextures = SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf);\n\t\tsystemSupported.rIntTextures = SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RInt);\n\t\tsystemSupported.dx11 = SystemInfo.graphicsShaderLevel >= 50 && SystemInfo.supportsComputeShaders;\n\t\tsystemSupported.volumeTextures = SystemInfo.supports3DTextures;\n\n\t\tsystemSupported.postShader = material.shader.isSupported;\n\t\tsystemSupported.sunDepthShader = sunDepthShader.isSupported;\n\t\tsystemSupported.voxelizationShader = voxelizationShader.isSupported;\n\t\tsystemSupported.tracingShader = voxelTracingShader.isSupported;\n\n\t\tif (!systemSupported.fullFunctionality)\n\t\t{\n\t\t\tDebug.LogWarning(\"SEGI is not supported on the current platform. Check for shader compile errors in SEGI/Resources\");\n\t\t\tenabled = false;\n\t\t}\n\t}\n\n\tvoid OnDrawGizmosSelected()\n\t{\n\t\tif (!enabled)\n\t\t\treturn;\n\t\t\t\n\t\tColor prevColor = Gizmos.color;\n\t\tGizmos.color = new Color(1.0f, 0.25f, 0.0f, 0.5f);\n\n\t\tGizmos.DrawCube(voxelSpaceOrigin, new Vector3(voxelSpaceSize, voxelSpaceSize, voxelSpaceSize));\n\n\t\tGizmos.color = new Color(1.0f, 0.0f, 0.0f, 0.1f);\n\n\t\tGizmos.color = prevColor;\n\t}\n\n\tvoid CleanupTexture(ref RenderTexture texture)\n\t{\n\t\tif (texture)\n\t\t{\n\t\t\ttexture.DiscardContents();\n\t\t\ttexture.Release();\n\t\t\tDestroyImmediate(texture);\n\t\t}\n\t}\n\n\tvoid CleanupTextures()\n\t{\n\t\tCleanupTexture(ref sunDepthTexture);\n\t\tCleanupTexture(ref previousGIResult);\n\t\tCleanupTexture(ref previousCameraDepth);\n\t\tCleanupTexture(ref integerVolume);\n\t\tfor (int i = 0; i < volumeTextures.Length; i++)\n\t\t{\n\t\t\tCleanupTexture(ref volumeTextures[i]);\n\t\t}\n\t\tCleanupTexture(ref secondaryIrradianceVolume);\n\t\tCleanupTexture(ref volumeTextureB);\n\t\tCleanupTexture(ref dummyVoxelTextureAAScaled);\n\t\tCleanupTexture(ref dummyVoxelTextureFixed);\n\t}\n\n\tvoid Cleanup()\n\t{\n\t\tDestroyImmediate(material);\n\t\tDestroyImmediate(voxelCameraGO);\n\t\tDestroyImmediate(leftViewPoint);\n\t\tDestroyImmediate(topViewPoint);\n\t\tDestroyImmediate(shadowCamGameObject);\n\t\tinitChecker = null;\n\n\t\tCleanupTextures();\n\t}\n\n\tvoid OnEnable()\n\t{\n\t\tInitCheck();\n\t\tResizeRenderTextures();\n\n\t\tCheckSupport();\n\t}\n\n\tvoid OnDisable()\n\t{\n\t\tCleanup();\n\t}\n\n\tvoid ResizeRenderTextures()\n\t{\n\t\tif (previousGIResult)\n\t\t{\n\t\t\tpreviousGIResult.DiscardContents();\n\t\t\tpreviousGIResult.Release();\n\t\t\tDestroyImmediate(previousGIResult);\n\t\t}\n\n\t\tint width = attachedCamera.pixelWidth == 0 ? 2 : attachedCamera.pixelWidth;\n\t\tint height = attachedCamera.pixelHeight == 0 ? 2 : attachedCamera.pixelHeight;\n\n\t\tpreviousGIResult = new RenderTexture(width, height, 0, RenderTextureFormat.ARGBHalf);\n\t\tpreviousGIResult.wrapMode = TextureWrapMode.Clamp;\n\t\tpreviousGIResult.filterMode = FilterMode.Bilinear;\n\t\tpreviousGIResult.useMipMap = true;\n\t\t#if UNITY_5_4_OR_NEWER\n\t\tpreviousGIResult.autoGenerateMips = false;\n\t\t#else\n\t\tpreviousResult.generateMips = false;\n\t\t#endif\n\t\tpreviousGIResult.Create();\n\t\tpreviousGIResult.hideFlags = HideFlags.HideAndDontSave;\n\n\t\tif (previousCameraDepth)\n\t\t{\n\t\t\tpreviousCameraDepth.DiscardContents();\n\t\t\tpreviousCameraDepth.Release();\n\t\t\tDestroyImmediate(previousCameraDepth);\n\t\t}\n\t\tpreviousCameraDepth = new RenderTexture(width, height, 0, RenderTextureFormat.RFloat, RenderTextureReadWrite.Linear);\n\t\tpreviousCameraDepth.wrapMode = TextureWrapMode.Clamp;\n\t\tpreviousCameraDepth.filterMode = FilterMode.Bilinear;\n\t\tpreviousCameraDepth.Create();\n\t\tpreviousCameraDepth.hideFlags = HideFlags.HideAndDontSave;\n\t}\n\n\tvoid ResizeSunShadowBuffer()\n\t{\n\n\t\tif (sunDepthTexture)\n\t\t{\n\t\t\tsunDepthTexture.DiscardContents();\n\t\t\tsunDepthTexture.Release();\n\t\t\tDestroyImmediate(sunDepthTexture);\n\t\t}\n\t\tsunDepthTexture = new RenderTexture(sunShadowResolution, sunShadowResolution, 16, RenderTextureFormat.RHalf, RenderTextureReadWrite.Linear);\n\t\tsunDepthTexture.wrapMode = TextureWrapMode.Clamp;\n\t\tsunDepthTexture.filterMode = FilterMode.Point;\n\t\tsunDepthTexture.Create();\n\t\tsunDepthTexture.hideFlags = HideFlags.HideAndDontSave;\n\t}\n\n\tvoid Update()\n\t{\n\t\tif (notReadyToRender)\n\t\t\treturn;\n\n\t\tif (previousGIResult == null)\n\t\t{\n\t\t\tResizeRenderTextures();\n\t\t}\n\n\t\tif (previousGIResult.width != attachedCamera.pixelWidth || previousGIResult.height != attachedCamera.pixelHeight)\n\t\t{\n\t\t\tResizeRenderTextures();\n\t\t}\n\n\t\tif ((int)sunShadowResolution != prevSunShadowResolution)\n\t\t{\n\t\t\tResizeSunShadowBuffer();\n\t\t}\n\n\t\tprevSunShadowResolution = (int)sunShadowResolution;\n\n\t\tif (volumeTextures[0].width != (int)voxelResolution)\n\t\t{\n\t\t\tCreateVolumeTextures();\n\t\t}\n\n\t\tif (dummyVoxelTextureAAScaled.width != dummyVoxelResolution)\n\t\t{\n\t\t\tResizeDummyTexture();\n\t\t}\n\t}\n\n    Matrix4x4 TransformViewMatrix(Matrix4x4 mat)\n    {\n\t\t//Since the third column of the view matrix needs to be reversed if using reversed z-buffer, do so here\n#if UNITY_5_5_OR_NEWER\n        if (SystemInfo.usesReversedZBuffer)\n        {\n            mat[2, 0] = -mat[2, 0];\n            mat[2, 1] = -mat[2, 1];\n            mat[2, 2] = -mat[2, 2];\n            mat[2, 3] = -mat[2, 3];\n        }\n#endif\n        return mat;\n    }\n\n\tvoid OnPreRender()\n\t{\n\t\t//Force reinitialization to make sure that everything is working properly if one of the cameras was unexpectedly destroyed\n\t\tif (!voxelCamera || !shadowCam)\n\t\t\tinitChecker = null;\n\t\t\t\n\t\tInitCheck();\n\n\t\tif (notReadyToRender)\n\t\t\treturn;\n\n\t\tif (!updateGI)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t//Cache the previous active render texture to avoid issues with other Unity rendering going on\n\t\tRenderTexture previousActive = RenderTexture.active;\n\n\t\tShader.SetGlobalInt(\"SEGIVoxelAA\", voxelAA ? 1 : 0);\n\n\n\n\t\t//Main voxelization work\n\t\tif (renderState == RenderState.Voxelize)\n\t\t{\n\t\t\tactiveVolume = voxelFlipFlop == 0 ? volumeTextures[0] : volumeTextureB;\t\t\t\t//Flip-flopping volume textures to avoid simultaneous read and write errors in shaders\n\t\t\tpreviousActiveVolume = voxelFlipFlop == 0 ? volumeTextureB : volumeTextures[0];\n\n\t\t\t//float voxelTexel = (1.0f * voxelSpaceSize) / (int)voxelResolution * 0.5f;\t\t\t//Calculate the size of a voxel texel in world-space units\n\n\n\n\t\t\t//Setup the voxel volume origin position\n\t\t\tfloat interval = voxelSpaceSize / 8.0f;\t\t\t\t\t\t\t\t\t\t\t\t//The interval at which the voxel volume will be \"locked\" in world-space\n\t\t\tVector3 origin;\n\t\t\tif (followTransform)\n\t\t\t{\n\t\t\t\torigin = followTransform.position;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//GI is still flickering a bit when the scene view and the game view are opened at the same time\n\t\t\t\torigin = transform.position + transform.forward * voxelSpaceSize / 4.0f;\n\t\t\t}\n\t\t\t//Lock the voxel volume origin based on the interval\n\t\t\tvoxelSpaceOrigin = new Vector3(Mathf.Round(origin.x / interval) * interval, Mathf.Round(origin.y / interval) * interval, Mathf.Round(origin.z / interval) * interval);\n\n\t\t\t//Calculate how much the voxel origin has moved since last voxelization pass. Used for scrolling voxel data in shaders to avoid ghosting when the voxel volume moves in the world\n\t\t\tvoxelSpaceOriginDelta = voxelSpaceOrigin - previousVoxelSpaceOrigin;\n\t\t\tShader.SetGlobalVector(\"SEGIVoxelSpaceOriginDelta\", voxelSpaceOriginDelta / voxelSpaceSize);\n\n\t\t\tpreviousVoxelSpaceOrigin = voxelSpaceOrigin;\n\n\n\n\t\t\t//Set the voxel camera (proxy camera used to render the scene for voxelization) parameters\n\t\t\tvoxelCamera.enabled = false;\n\t\t\tvoxelCamera.orthographic = true;\n\t\t\tvoxelCamera.orthographicSize = voxelSpaceSize * 0.5f;\n\t\t\tvoxelCamera.nearClipPlane = 0.0f;\n\t\t\tvoxelCamera.farClipPlane = voxelSpaceSize;\n\t\t\tvoxelCamera.depth = -2;\n\t\t\tvoxelCamera.renderingPath = RenderingPath.Forward;\n\t\t\tvoxelCamera.clearFlags = CameraClearFlags.Color;\n\t\t\tvoxelCamera.backgroundColor = Color.black;\n\t\t\tvoxelCamera.cullingMask = giCullingMask;\n\n\n\t\t\t//Move the voxel camera game object and other related objects to the above calculated voxel space origin\n\t\t\tvoxelCameraGO.transform.position = voxelSpaceOrigin - Vector3.forward * voxelSpaceSize * 0.5f;\n\t\t\tvoxelCameraGO.transform.rotation = rotationFront;\n\n\t\t\tleftViewPoint.transform.position = voxelSpaceOrigin + Vector3.left * voxelSpaceSize * 0.5f;\n\t\t\tleftViewPoint.transform.rotation = rotationLeft;\n\t\t\ttopViewPoint.transform.position = voxelSpaceOrigin + Vector3.up * voxelSpaceSize * 0.5f;\n\t\t\ttopViewPoint.transform.rotation = rotationTop;\n\n\n\n\t\t\t//Set matrices needed for voxelization\n\t\t\tShader.SetGlobalMatrix(\"WorldToCamera\", attachedCamera.worldToCameraMatrix);\n\t\t\tShader.SetGlobalMatrix(\"SEGIVoxelViewFront\", TransformViewMatrix(voxelCamera.transform.worldToLocalMatrix));\n\t\t\tShader.SetGlobalMatrix(\"SEGIVoxelViewLeft\", TransformViewMatrix(leftViewPoint.transform.worldToLocalMatrix));\n\t\t\tShader.SetGlobalMatrix(\"SEGIVoxelViewTop\", TransformViewMatrix(topViewPoint.transform.worldToLocalMatrix));\n\t\t\tShader.SetGlobalMatrix(\"SEGIWorldToVoxel\", voxelCamera.worldToCameraMatrix);\n\t\t\tShader.SetGlobalMatrix(\"SEGIVoxelProjection\", voxelCamera.projectionMatrix);\n\t\t\tShader.SetGlobalMatrix(\"SEGIVoxelProjectionInverse\", voxelCamera.projectionMatrix.inverse);\n\n\t\t\tShader.SetGlobalInt(\"SEGIVoxelResolution\", (int)voxelResolution);\n\n\t\t\tMatrix4x4 voxelToGIProjection = (shadowCam.projectionMatrix) * (shadowCam.worldToCameraMatrix) * (voxelCamera.cameraToWorldMatrix);\n\t\t\tShader.SetGlobalMatrix(\"SEGIVoxelToGIProjection\", voxelToGIProjection);\n\t\t\tShader.SetGlobalVector(\"SEGISunlightVector\", sun ? Vector3.Normalize(sun.transform.forward) : Vector3.up);\n\n\t\t\t//Set paramteters\n\t\t\tShader.SetGlobalColor(\"GISunColor\", sun == null ? Color.black : new Color(Mathf.Pow(sun.color.r, 2.2f), Mathf.Pow(sun.color.g, 2.2f), Mathf.Pow(sun.color.b, 2.2f), Mathf.Pow(sun.intensity, 2.2f)));\n\t\t\tShader.SetGlobalColor(\"SEGISkyColor\", new Color(Mathf.Pow(skyColor.r * skyIntensity * 0.5f, 2.2f), Mathf.Pow(skyColor.g * skyIntensity * 0.5f, 2.2f), Mathf.Pow(skyColor.b * skyIntensity * 0.5f, 2.2f), Mathf.Pow(skyColor.a, 2.2f)));\n\t\t\tShader.SetGlobalFloat(\"GIGain\", giGain);\n\t\t\tShader.SetGlobalFloat(\"SEGISecondaryBounceGain\", infiniteBounces ? secondaryBounceGain : 0.0f);\n\t\t\tShader.SetGlobalFloat(\"SEGISoftSunlight\", softSunlight);\n\t\t\tShader.SetGlobalInt(\"SEGISphericalSkylight\", sphericalSkylight ? 1 : 0);\n\t\t\tShader.SetGlobalInt(\"SEGIInnerOcclusionLayers\", innerOcclusionLayers);\n\n\n\t\t\t//Render the depth texture from the sun's perspective in order to inject sunlight with shadows during voxelization\n\t\t\tif (sun != null)\n\t\t\t{\n\t\t\t\tshadowCam.cullingMask = giCullingMask;\n\n\t\t\t\tVector3 shadowCamPosition = voxelSpaceOrigin + Vector3.Normalize(-sun.transform.forward) * shadowSpaceSize * 0.5f * shadowSpaceDepthRatio;\n\n\t\t\t\tshadowCamTransform.position = shadowCamPosition;\n\t\t\t\tshadowCamTransform.LookAt(voxelSpaceOrigin, Vector3.up);\n\n\t\t\t\tshadowCam.renderingPath = RenderingPath.Forward;\n\t\t\t\tshadowCam.depthTextureMode |= DepthTextureMode.None;\n\n\t\t\t\tshadowCam.orthographicSize = shadowSpaceSize;\n\t\t\t\tshadowCam.farClipPlane = shadowSpaceSize * 2.0f * shadowSpaceDepthRatio;\n\n\n\t\t\t\tGraphics.SetRenderTarget(sunDepthTexture);\n\t\t\t\tshadowCam.SetTargetBuffers(sunDepthTexture.colorBuffer, sunDepthTexture.depthBuffer);\n\n\t\t\t\tshadowCam.RenderWithShader(sunDepthShader, \"\");\n\n\t\t\t\tShader.SetGlobalTexture(\"SEGISunDepth\", sunDepthTexture);\n\t\t\t}\n\n\n\n\n\t\t\t\n\n\n\n\n\t\t\t//Clear the volume texture that is immediately written to in the voxelization scene shader\n\t\t\tclearCompute.SetTexture(0, \"RG0\", integerVolume);\n\t\t\tclearCompute.SetInt(\"Res\", (int)voxelResolution);\n\t\t\tclearCompute.Dispatch(0, (int)voxelResolution / 16, (int)voxelResolution / 16, 1);\n\n\n\n\n\n\n\n\n\t\t\t//Render the scene with the voxel proxy camera object with the voxelization shader to voxelize the scene to the volume integer texture\n\t\t\tGraphics.SetRandomWriteTarget(1, integerVolume);\n\t\t\tvoxelCamera.targetTexture = dummyVoxelTextureAAScaled;\n\t\t\tvoxelCamera.RenderWithShader(voxelizationShader, \"\");\n\t\t\tGraphics.ClearRandomWriteTargets();\n\n\n\t\t\t//Transfer the data from the volume integer texture to the main volume texture used for GI tracing. \n\t\t\ttransferIntsCompute.SetTexture(0, \"Result\", activeVolume);\n\t\t\ttransferIntsCompute.SetTexture(0, \"PrevResult\", previousActiveVolume);\n\t\t\ttransferIntsCompute.SetTexture(0, \"RG0\", integerVolume);\n\t\t\ttransferIntsCompute.SetInt(\"VoxelAA\", voxelAA ? 1 : 0);\n\t\t\ttransferIntsCompute.SetInt(\"Resolution\", (int)voxelResolution);\n\t\t\ttransferIntsCompute.SetVector(\"VoxelOriginDelta\", (voxelSpaceOriginDelta / voxelSpaceSize) * (int)voxelResolution);\n\t\t\ttransferIntsCompute.Dispatch(0, (int)voxelResolution / 16, (int)voxelResolution / 16, 1);\n\n\t\t\tShader.SetGlobalTexture(\"SEGIVolumeLevel0\", activeVolume);\n\n\t\t\t//Manually filter/render mip maps\n\t\t\tfor (int i = 0; i < numMipLevels - 1; i++)\n\t\t\t{\n\t\t\t\tRenderTexture source = volumeTextures[i];\n\n\t\t\t\tif (i == 0)\n\t\t\t\t{\n\t\t\t\t\tsource = activeVolume;\n\t\t\t\t}\n\n\t\t\t\tint destinationRes = (int)voxelResolution / Mathf.RoundToInt(Mathf.Pow((float)2, (float)i + 1.0f));\n\t\t\t\tmipFilterCompute.SetInt(\"destinationRes\", destinationRes);\n\t\t\t\tmipFilterCompute.SetTexture(mipFilterKernel, \"Source\", source);\n\t\t\t\tmipFilterCompute.SetTexture(mipFilterKernel, \"Destination\", volumeTextures[i + 1]);\n\t\t\t\tmipFilterCompute.Dispatch(mipFilterKernel, destinationRes / 8, destinationRes / 8, 1);\n\t\t\t\tShader.SetGlobalTexture(\"SEGIVolumeLevel\" + (i + 1).ToString(), volumeTextures[i + 1]);\n\t\t\t}\n\n\t\t\t//Advance the voxel flip flop counter\n\t\t\tvoxelFlipFlop += 1;\n\t\t\tvoxelFlipFlop = voxelFlipFlop % 2;\n\n\t\t\tif (infiniteBounces)\n\t\t\t{\n\t\t\t\trenderState = RenderState.Bounce;\n\t\t\t}\n\t\t}\n\t\telse if (renderState == RenderState.Bounce)\n\t\t{\n\n\t\t\t//Clear the volume texture that is immediately written to in the voxelization scene shader\n\t\t\tclearCompute.SetTexture(0, \"RG0\", integerVolume);\n\t\t\tclearCompute.Dispatch(0, (int)voxelResolution / 16, (int)voxelResolution / 16, 1);\n\n\t\t\t//Set secondary tracing parameters\n\t\t\tShader.SetGlobalInt(\"SEGISecondaryCones\", secondaryCones);\n\t\t\tShader.SetGlobalFloat(\"SEGISecondaryOcclusionStrength\", secondaryOcclusionStrength);\n\n\t\t\t//Render the scene from the voxel camera object with the voxel tracing shader to render a bounce of GI into the irradiance volume\n\t\t\tGraphics.SetRandomWriteTarget(1, integerVolume);\n\t\t\tvoxelCamera.targetTexture = dummyVoxelTextureFixed;\n\t\t\tvoxelCamera.RenderWithShader(voxelTracingShader, \"\");\n\t\t\tGraphics.ClearRandomWriteTargets();\n\n\n\t\t\t//Transfer the data from the volume integer texture to the irradiance volume texture. This result is added to the next main voxelization pass to create a feedback loop for infinite bounces\n\t\t\ttransferIntsCompute.SetTexture(1, \"Result\", secondaryIrradianceVolume);\n\t\t\ttransferIntsCompute.SetTexture(1, \"RG0\", integerVolume);\n\t\t\ttransferIntsCompute.SetInt(\"Resolution\", (int)voxelResolution);\n\t\t\ttransferIntsCompute.Dispatch(1, (int)voxelResolution / 16, (int)voxelResolution / 16, 1);\n\n\t\t\tShader.SetGlobalTexture(\"SEGIVolumeTexture1\", secondaryIrradianceVolume);\n\n\t\t\trenderState = RenderState.Voxelize;\n\t\t}\n\n\n\n\t\tRenderTexture.active = previousActive;\n\t}\n\n\t[ImageEffectOpaque]\n\tvoid OnRenderImage(RenderTexture source, RenderTexture destination)\n\t{\n\t\tif (notReadyToRender)\n\t\t{\n\t\t\tGraphics.Blit(source, destination);\n\t\t\treturn;\n\t\t}\n\n\t\t//Set parameters\n\t\tShader.SetGlobalFloat(\"SEGIVoxelScaleFactor\", voxelScaleFactor);\n\n\t\tmaterial.SetMatrix(\"CameraToWorld\", attachedCamera.cameraToWorldMatrix);\n\t\tmaterial.SetMatrix(\"WorldToCamera\", attachedCamera.worldToCameraMatrix);\n\t\tmaterial.SetMatrix(\"ProjectionMatrixInverse\", attachedCamera.projectionMatrix.inverse);\n\t\tmaterial.SetMatrix(\"ProjectionMatrix\", attachedCamera.projectionMatrix);\n\t\tmaterial.SetInt(\"FrameSwitch\", frameCounter);\n\t\tShader.SetGlobalInt(\"SEGIFrameSwitch\", frameCounter);\n\t\tmaterial.SetVector(\"CameraPosition\", transform.position);\n\t\tmaterial.SetFloat(\"DeltaTime\", Time.deltaTime);\n\n\t\tmaterial.SetInt(\"StochasticSampling\", stochasticSampling ? 1 : 0);\n\t\tmaterial.SetInt(\"TraceDirections\", cones);\n\t\tmaterial.SetInt(\"TraceSteps\", coneTraceSteps);\n\t\tmaterial.SetFloat(\"TraceLength\", coneLength);\n\t\tmaterial.SetFloat(\"ConeSize\", coneWidth);\n\t\tmaterial.SetFloat(\"OcclusionStrength\", occlusionStrength);\n\t\tmaterial.SetFloat(\"OcclusionPower\", occlusionPower);\n\t\tmaterial.SetFloat(\"ConeTraceBias\", coneTraceBias);\n\t\tmaterial.SetFloat(\"GIGain\", giGain);\n\t\tmaterial.SetFloat(\"NearLightGain\", nearLightGain);\n\t\tmaterial.SetFloat(\"NearOcclusionStrength\", nearOcclusionStrength);\n\t\tmaterial.SetInt(\"DoReflections\", doReflections ? 1 : 0);\n\t\tmaterial.SetInt(\"HalfResolution\", halfResolution ? 1 : 0);\n\t\tmaterial.SetInt(\"ReflectionSteps\", reflectionSteps);\n\t\tmaterial.SetFloat(\"ReflectionOcclusionPower\", reflectionOcclusionPower);\n\t\tmaterial.SetFloat(\"SkyReflectionIntensity\", skyReflectionIntensity);\n\t\tmaterial.SetFloat(\"FarOcclusionStrength\", farOcclusionStrength);\n\t\tmaterial.SetFloat(\"FarthestOcclusionStrength\", farthestOcclusionStrength);\n        material.SetTexture(\"NoiseTexture\", blueNoise[frameCounter % 64]);\n\t\tmaterial.SetFloat(\"BlendWeight\", temporalBlendWeight);\n\n\t\t//If Visualize Voxels is enabled, just render the voxel visualization shader pass and return\n\t\tif (visualizeVoxels)\n\t\t{\n\t\t\tGraphics.Blit(source, destination, material, Pass.VisualizeVoxels);\n\t\t\treturn;\n\t\t}\n\n\t\t//Setup temporary textures\n\t\tRenderTexture gi1 = RenderTexture.GetTemporary(source.width / giRenderRes, source.height / giRenderRes, 0, RenderTextureFormat.ARGBHalf);\n\t\tRenderTexture gi2 = RenderTexture.GetTemporary(source.width / giRenderRes, source.height / giRenderRes, 0, RenderTextureFormat.ARGBHalf);\n\t\tRenderTexture reflections = null;\n\n\t\t//If reflections are enabled, create a temporary render buffer to hold them\n\t\tif (doReflections)\n\t\t{\n\t\t\treflections = RenderTexture.GetTemporary(source.width, source.height, 0, RenderTextureFormat.ARGBHalf);\n\t\t}\n\n\t\t//Setup textures to hold the current camera depth and normal\n\t\tRenderTexture currentDepth = RenderTexture.GetTemporary(source.width / giRenderRes, source.height / giRenderRes, 0, RenderTextureFormat.RFloat, RenderTextureReadWrite.Linear);\n\t\tcurrentDepth.filterMode = FilterMode.Point;\n\n\t\tRenderTexture currentNormal = RenderTexture.GetTemporary(source.width / giRenderRes, source.height / giRenderRes, 0, RenderTextureFormat.ARGBHalf, RenderTextureReadWrite.Linear);\n\t\tcurrentNormal.filterMode = FilterMode.Point;\n\n\t\t//Get the camera depth and normals\n\t\tGraphics.Blit(source, currentDepth, material, Pass.GetCameraDepthTexture);\n\t\tmaterial.SetTexture(\"CurrentDepth\", currentDepth);\n\t\tGraphics.Blit(source, currentNormal, material, Pass.GetWorldNormals);\n\t\tmaterial.SetTexture(\"CurrentNormal\", currentNormal);\n\n\t\t//Set the previous GI result and camera depth textures to access them in the shader\n\t\tmaterial.SetTexture(\"PreviousGITexture\", previousGIResult);\n\t\tShader.SetGlobalTexture(\"PreviousGITexture\", previousGIResult);\n\t\tmaterial.SetTexture(\"PreviousDepth\", previousCameraDepth);\n\n\t\t//Render diffuse GI tracing result\n\t\tGraphics.Blit(source, gi2, material, Pass.DiffuseTrace);\n\t\tif (doReflections)\n\t\t{\n\t\t\t//Render GI reflections result\n\t\t\tGraphics.Blit(source, reflections, material, Pass.SpecularTrace);\n\t\t\tmaterial.SetTexture(\"Reflections\", reflections);\n\t\t}\n\n\n\t\t//Perform bilateral filtering\n\t\tif (useBilateralFiltering)\n\t\t{\n\t\t\tmaterial.SetVector(\"Kernel\", new Vector2(0.0f, 1.0f));\n\t\t\tGraphics.Blit(gi2, gi1, material, Pass.BilateralBlur);\n\n\t\t\tmaterial.SetVector(\"Kernel\", new Vector2(1.0f, 0.0f));\n\t\t\tGraphics.Blit(gi1, gi2, material, Pass.BilateralBlur);\n\n\t\t\tmaterial.SetVector(\"Kernel\", new Vector2(0.0f, 1.0f));\n\t\t\tGraphics.Blit(gi2, gi1, material, Pass.BilateralBlur);\n\n\t\t\tmaterial.SetVector(\"Kernel\", new Vector2(1.0f, 0.0f));\n\t\t\tGraphics.Blit(gi1, gi2, material, Pass.BilateralBlur);\n\t\t}\n\n\t\t//If Half Resolution tracing is enabled\n\t\tif (giRenderRes == 2)\n\t\t{\n\t\t\tRenderTexture.ReleaseTemporary(gi1);\n\n\t\t\t//Setup temporary textures\n\t\t\tRenderTexture gi3 = RenderTexture.GetTemporary(source.width, source.height, 0, RenderTextureFormat.ARGBHalf);\n\t\t\tRenderTexture gi4 = RenderTexture.GetTemporary(source.width, source.height, 0, RenderTextureFormat.ARGBHalf);\n\n\n\t\t\t//Prepare the half-resolution diffuse GI result to be bilaterally upsampled\n\t\t\tgi2.filterMode = FilterMode.Point;\n\t\t\tGraphics.Blit(gi2, gi4);\n\n\t\t\tRenderTexture.ReleaseTemporary(gi2);\n\n\t\t\tgi4.filterMode = FilterMode.Point;\n\t\t\tgi3.filterMode = FilterMode.Point;\n\n\n\t\t\t//Perform bilateral upsampling on half-resolution diffuse GI result\n\t\t\tmaterial.SetVector(\"Kernel\", new Vector2(1.0f, 0.0f));\n\t\t\tGraphics.Blit(gi4, gi3, material, Pass.BilateralUpsample);\n\t\t\tmaterial.SetVector(\"Kernel\", new Vector2(0.0f, 1.0f));\n\n\t\t\t//Perform temporal reprojection and blending\n\t\t\tif (temporalBlendWeight < 1.0f)\n\t\t\t{\n\t\t\t\tGraphics.Blit(gi3, gi4);\n\t\t\t\tGraphics.Blit(gi4, gi3, material, Pass.TemporalBlend);\n\t\t\t\tGraphics.Blit(gi3, previousGIResult);\n\t\t\t\tGraphics.Blit(source, previousCameraDepth, material, Pass.GetCameraDepthTexture);\n\t\t\t}\n\n\t\t\t//Set the result to be accessed in the shader\n\t\t\tmaterial.SetTexture(\"GITexture\", gi3);\n\n\t\t\t//Actually apply the GI to the scene using gbuffer data\n\t\t\tGraphics.Blit(source, destination, material, visualizeGI ? Pass.VisualizeGI : Pass.BlendWithScene);\n\n\t\t\t//Release temporary textures\n\t\t\tRenderTexture.ReleaseTemporary(gi3);\n\t\t\tRenderTexture.ReleaseTemporary(gi4);\n\t\t}\n\t\telse \t//If Half Resolution tracing is disabled\n\t\t{\t\n\t\t\t//Perform temporal reprojection and blending\n\t\t\tif (temporalBlendWeight < 1.0f)\n\t\t\t{\n\t\t\t\tGraphics.Blit(gi2, gi1, material, Pass.TemporalBlend);\n\t\t\t\tGraphics.Blit(gi1, previousGIResult);\n\t\t\t\tGraphics.Blit(source, previousCameraDepth, material, Pass.GetCameraDepthTexture);\n\t\t\t}\n\t\t\t\n\t\t\t//Actually apply the GI to the scene using gbuffer data\n\t\t\tmaterial.SetTexture(\"GITexture\", temporalBlendWeight < 1.0f ? gi1 : gi2);\n\t\t\tGraphics.Blit(source, destination, material, visualizeGI ? Pass.VisualizeGI : Pass.BlendWithScene);\n\n\t\t\t//Release temporary textures\n\t\t\tRenderTexture.ReleaseTemporary(gi1);\n\t\t\tRenderTexture.ReleaseTemporary(gi2);\n\t\t}\n\n\t\t//Release temporary textures\n\t\tRenderTexture.ReleaseTemporary(currentDepth);\n\t\tRenderTexture.ReleaseTemporary(currentNormal);\n\n\t\t//Visualize the sun depth texture\n\t\tif (visualizeSunDepthTexture)\n\t\t\tGraphics.Blit(sunDepthTexture, destination);\n\n\n\t\t//Release the temporary reflections result texture\n\t\tif (doReflections)\n\t\t{\n\t\t\tRenderTexture.ReleaseTemporary(reflections);\n\t\t}\n\n\t\t//Set matrices/vectors for use during temporal reprojection\n\t\tmaterial.SetMatrix(\"ProjectionPrev\", attachedCamera.projectionMatrix);\n\t\tmaterial.SetMatrix(\"ProjectionPrevInverse\", attachedCamera.projectionMatrix.inverse);\n\t\tmaterial.SetMatrix(\"WorldToCameraPrev\", attachedCamera.worldToCameraMatrix);\n\t\tmaterial.SetMatrix(\"CameraToWorldPrev\", attachedCamera.cameraToWorldMatrix);\n\t\tmaterial.SetVector(\"CameraPositionPrev\", transform.position);\n\n\t\t//Advance the frame counter\n\t\tframeCounter = (frameCounter + 1) % (64);\n\t}\n}\n\n"
        },
        {
          "name": "SEGI.cs.meta",
          "type": "blob",
          "size": 0.3056640625,
          "content": "fileFormatVersion: 2\nguid: 855c24b21068ca6449a4680af0c5645e\ntimeCreated: 1502923549\nlicenseType: Pro\nMonoImporter:\n  serializedVersion: 2\n  defaultReferences: []\n  executionOrder: 0\n  icon: {fileID: 2800000, guid: dbb032076c5c83c41bba0c204a2a970a, type: 3}\n  userData: \n  assetBundleName: \n  assetBundleVariant: \n"
        },
        {
          "name": "SEGICascaded.cs",
          "type": "blob",
          "size": 47.794921875,
          "content": "using UnityEngine;\nusing UnityEngine.Rendering;\nusing System.Collections;\nusing System;\nusing System.IO;\nusing System.Runtime.Serialization;\nusing System.Runtime.Serialization.Formatters.Binary;\n\n[ExecuteInEditMode]\n#if UNITY_5_4_OR_NEWER\n[ImageEffectAllowedInSceneView]\n#endif\n[RequireComponent(typeof(Camera))]\n[AddComponentMenu(\"Image Effects/Sonic Ether/SEGI (Cascaded)\")]\npublic class SEGICascaded : MonoBehaviour\n{\n\n\n\n#region Parameters\n\t[Serializable]\n\tpublic enum VoxelResolution\n\t{\n\t\tlow = 64,\n\t\thigh = 128\n\t}\n\n\tpublic VoxelResolution voxelResolution = VoxelResolution.high;\n\n\tpublic bool visualizeSunDepthTexture = false;\n\tpublic bool visualizeGI = false;\n\n\tpublic Light sun;\n\tpublic LayerMask giCullingMask = 2147483647;\n\n\tpublic float shadowSpaceSize = 50.0f;\n\n\t[Range(0.01f, 1.0f)]\n\tpublic float temporalBlendWeight = 0.1f;\n\n\tpublic bool visualizeVoxels = false;\n\n\tpublic bool updateGI = true;\n\n\n\tpublic Color skyColor;\n\n\tpublic float voxelSpaceSize = 25.0f;\n\n\tpublic bool useBilateralFiltering = false;\n\n\t[Range(0, 2)]\n\tpublic int innerOcclusionLayers = 1;\n\n\tpublic bool halfResolution = false;\n\tpublic bool stochasticSampling = true;\n\tpublic bool infiniteBounces = false;\n\tpublic Transform followTransform;\n\t[Range(1, 128)]\n\tpublic int cones = 4;\n\t[Range(1, 32)]\n\tpublic int coneTraceSteps = 10;\n\t[Range(0.1f, 2.0f)]\n\tpublic float coneLength = 1.0f;\n\t[Range(0.5f, 6.0f)]\n\tpublic float coneWidth = 3.9f;\n\t[Range(0.0f, 2.0f)]\n\tpublic float occlusionStrength = 0.15f;\n\t[Range(0.0f, 4.0f)]\n\tpublic float nearOcclusionStrength = 0.5f;\n\t[Range(0.001f, 4.0f)]\n\tpublic float occlusionPower = 0.65f;\n\t[Range(0.0f, 4.0f)]\n\tpublic float coneTraceBias = 2.8f;\n\t[Range(0.0f, 4.0f)]\n\tpublic float nearLightGain = 0.36f;\n\t[Range(0.0f, 4.0f)]\n\tpublic float giGain = 1.0f;\n\t[Range(0.0f, 4.0f)]\n\tpublic float secondaryBounceGain = 0.9f;\n\t[Range(0.0f, 16.0f)]\n\tpublic float softSunlight = 0.0f;\n\n\t[Range(0.0f, 8.0f)]\n\tpublic float skyIntensity = 1.0f;\n\n\t[HideInInspector]\n\tpublic bool doReflections\n\t{\n\t\tget\n\t\t{\n\t\t\treturn false;\t//Locked to keep reflections disabled since they're in a broken state with cascades at the moment\n\t\t}\n\t\tset\n\t\t{\n\t\t\tvalue = false;\n\t\t}\n\t}\n\n\t[Range(12, 128)]\n\tpublic int reflectionSteps = 64;\n\t[Range(0.001f, 4.0f)]\n\tpublic float reflectionOcclusionPower = 1.0f;\n\t[Range(0.0f, 1.0f)]\n\tpublic float skyReflectionIntensity = 1.0f;\n\n\n\n\t[Range(0.1f, 4.0f)]\n\tpublic float farOcclusionStrength = 1.0f;\n\t[Range(0.1f, 4.0f)]\n\tpublic float farthestOcclusionStrength = 1.0f;\n\n\t[Range(3, 16)]\n\tpublic int secondaryCones = 6;\n\t[Range(0.1f, 2.0f)]\n\tpublic float secondaryOcclusionStrength = 0.27f;\n\n\tpublic bool sphericalSkylight = false;\n#endregion\n\n\n\n\n#region InternalVariables\n\tobject initChecker;\n\tMaterial material;\n\tCamera attachedCamera;\n\tTransform shadowCamTransform;\n\tCamera shadowCam;\n\tGameObject shadowCamGameObject;\n\tTexture2D[] blueNoise;\n\n\tint sunShadowResolution = 128;\n\tint prevSunShadowResolution;\n\n\tShader sunDepthShader;\n\n\tfloat shadowSpaceDepthRatio = 10.0f;\n\n\tint frameCounter = 0;\n\n\n\n\tRenderTexture sunDepthTexture;\n\tRenderTexture previousGIResult;\n\tRenderTexture previousDepth;\n\n\t///<summary>This is a volume texture that is immediately written to in the voxelization shader. The RInt format enables atomic writes to avoid issues where multiple fragments are trying to write to the same voxel in the volume.</summary>\n\tRenderTexture integerVolume;\n\n\t///<summary>A 2D texture with the size of [voxel resolution, voxel resolution] that must be used as the active render texture when rendering the scene for voxelization. This texture scales depending on whether Voxel AA is enabled to ensure correct voxelization.</summary>\n\tRenderTexture dummyVoxelTextureAAScaled;\n\n\t///<summary>A 2D texture with the size of [voxel resolution, voxel resolution] that must be used as the active render texture when rendering the scene for voxelization. This texture is always the same size whether Voxel AA is enabled or not.</summary>\n\tRenderTexture dummyVoxelTextureFixed;\n\n\t///<summary>The main GI data clipmaps that hold GI data referenced during GI tracing</summary>\n\tClipmap[] clipmaps;\n\n\t///<summary>The secondary clipmaps that hold irradiance data for infinite bounces</summary>\n\tClipmap[] irradianceClipmaps;\n\n\n\n\tbool notReadyToRender = false;\n\n\tShader voxelizationShader;\n\tShader voxelTracingShader;\n\n\tComputeShader clearCompute;\n\tComputeShader transferIntsCompute;\n\tComputeShader mipFilterCompute;\n\n\tconst int numClipmaps = 6;\n\tint clipmapCounter = 0;\n\tint currentClipmapIndex = 0;\n\n\tCamera voxelCamera;\n\tGameObject voxelCameraGO;\n\tGameObject leftViewPoint;\n\tGameObject topViewPoint;\n\n\tfloat voxelScaleFactor\n\t{\n\t\tget\n\t\t{\n\t\t\treturn (float)voxelResolution / 256.0f;\n\t\t}\n\t}\n\n\tQuaternion rotationFront = new Quaternion(0.0f, 0.0f, 0.0f, 1.0f);\n\tQuaternion rotationLeft = new Quaternion(0.0f, 0.7f, 0.0f, 0.7f);\n\tQuaternion rotationTop = new Quaternion(0.7f, 0.0f, 0.0f, 0.7f);\n\n\tint giRenderRes\n\t{\n\t\tget\n\t\t{\n\t\t\treturn halfResolution ? 2 : 1;\n\t\t}\n\t}\n\n\tenum RenderState\n\t{\n\t\tVoxelize,\n\t\tBounce\n\t}\n\n\tRenderState renderState = RenderState.Voxelize;\n#endregion\n\n\n\n#region SupportingObjectsAndProperties\n\tstruct Pass\n\t{\n\t\tpublic static int DiffuseTrace = 0;\n\t\tpublic static int BilateralBlur = 1;\n\t\tpublic static int BlendWithScene = 2;\n\t\tpublic static int TemporalBlend = 3;\n\t\tpublic static int SpecularTrace = 4;\n\t\tpublic static int GetCameraDepthTexture = 5;\n\t\tpublic static int GetWorldNormals = 6;\n\t\tpublic static int VisualizeGI = 7;\n\t\tpublic static int WriteBlack = 8;\n\t\tpublic static int VisualizeVoxels = 10;\n\t\tpublic static int BilateralUpsample = 11;\n\t}\n\n\tpublic struct SystemSupported\n\t{\n\t\tpublic bool hdrTextures;\n\t\tpublic bool rIntTextures;\n\t\tpublic bool dx11;\n\t\tpublic bool volumeTextures;\n\t\tpublic bool postShader;\n\t\tpublic bool sunDepthShader;\n\t\tpublic bool voxelizationShader;\n\t\tpublic bool tracingShader;\n\n\t\tpublic bool fullFunctionality\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\treturn hdrTextures && rIntTextures && dx11 && volumeTextures && postShader && sunDepthShader && voxelizationShader && tracingShader;\n\t\t\t}\n\t\t}\n\t}\n\n\t/// <summary>\n\t/// Contains info on system compatibility of required hardware functionality\n\t/// </summary>\n\tpublic SystemSupported systemSupported;\n\n\t/// <summary>\n\t/// Estimates the VRAM usage of all the render textures used to render GI.\n\t/// </summary>\n\tpublic float vramUsage\t//TODO: Update vram usage calculation\n\t{\n\t\tget\n\t\t{\n\t\t\tif (!enabled)\n\t\t\t{\n\t\t\t\treturn 0.0f;\n\t\t\t}\n\t\t\tlong v = 0;\n\n\t\t\tif (sunDepthTexture != null)\n\t\t\t\tv += sunDepthTexture.width * sunDepthTexture.height * 16;\n\n\t\t\tif (previousGIResult != null)\n\t\t\t\tv += previousGIResult.width * previousGIResult.height * 16 * 4;\n\n\t\t\tif (previousDepth != null)\n\t\t\t\tv += previousDepth.width * previousDepth.height * 32;\n\n\t\t\tif (integerVolume != null)\n\t\t\t\tv += integerVolume.width * integerVolume.height * integerVolume.volumeDepth * 32;\n\n\t\t\tif (dummyVoxelTextureAAScaled != null)\n\t\t\t\tv += dummyVoxelTextureAAScaled.width * dummyVoxelTextureAAScaled.height * 8;\n\n\t\t\tif (dummyVoxelTextureFixed != null)\n\t\t\t\tv += dummyVoxelTextureFixed.width * dummyVoxelTextureFixed.height * 8;\n\n\t\t\tif (clipmaps != null)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < numClipmaps; i++)\n\t\t\t\t{\n\t\t\t\t\tif (clipmaps[i] != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tv += clipmaps[i].volumeTexture0.width * clipmaps[i].volumeTexture0.height * clipmaps[i].volumeTexture0.volumeDepth * 16 * 4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (irradianceClipmaps != null)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < numClipmaps; i++)\n\t\t\t\t{\n\t\t\t\t\tif (irradianceClipmaps[i] != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tv += irradianceClipmaps[i].volumeTexture0.width * irradianceClipmaps[i].volumeTexture0.height * irradianceClipmaps[i].volumeTexture0.volumeDepth * 16 * 4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\tfloat vram = (v / 8388608.0f);\n\n\t\t\treturn vram;\n\t\t}\n\t}\n\n\tclass Clipmap\n\t{\n\t\tpublic Vector3 origin;\n\t\tpublic Vector3 originDelta;\n\t\tpublic Vector3 previousOrigin;\n\t\tpublic float localScale;\n\n\t\tpublic int resolution;\n\n\t\tpublic RenderTexture volumeTexture0;\n\n\t\tpublic FilterMode filterMode = FilterMode.Bilinear;\n\t\tpublic RenderTextureFormat renderTextureFormat = RenderTextureFormat.ARGBHalf;\n\n\t\tpublic void UpdateTextures()\n\t\t{\n\t\t\tif (volumeTexture0)\n\t\t\t{\n\t\t\t\tvolumeTexture0.DiscardContents();\n\t\t\t\tvolumeTexture0.Release();\n\t\t\t\tDestroyImmediate(volumeTexture0);\n\t\t\t}\n\t\t\tvolumeTexture0 = new RenderTexture(resolution, resolution, 0, renderTextureFormat, RenderTextureReadWrite.Linear);\n\t\t\tvolumeTexture0.wrapMode = TextureWrapMode.Clamp;\n\t\t\t#if UNITY_5_4_OR_NEWER\n\t\t\tvolumeTexture0.dimension = TextureDimension.Tex3D;\n\t\t\t#else\n\t\t\tvolumeTexture0.isVolume = true;\n\t\t\t#endif\n\t\t\tvolumeTexture0.volumeDepth = resolution;\n\t\t\tvolumeTexture0.enableRandomWrite = true;\n\t\t\tvolumeTexture0.filterMode = filterMode;\n\t\t\t#if UNITY_5_4_OR_NEWER\n\t\t\tvolumeTexture0.autoGenerateMips = false;\n\t\t\t#else\n\t\t\tvolumeTexture0.generateMips = false;\n\t\t\t#endif\n\t\t\tvolumeTexture0.useMipMap = false;\n\t\t\tvolumeTexture0.Create();\n\t\t\tvolumeTexture0.hideFlags = HideFlags.HideAndDontSave;\n\t\t}\n\n\t\tpublic void CleanupTextures()\n\t\t{\n\t\t\tif (volumeTexture0)\n\t\t\t{\n\t\t\t\tvolumeTexture0.DiscardContents();\n\t\t\t\tvolumeTexture0.Release();\n\t\t\t\tDestroyImmediate(volumeTexture0);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic bool gaussianMipFilter\n\t{\n\t\tget\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tset\n\t\t{\n\t\t\tvalue = false;\n\t\t}\n\t}\n\n\tint mipFilterKernel\n\t{\n\t\tget\n\t\t{\n\t\t\treturn gaussianMipFilter ? 1 : 0;\n\t\t}\n\t}\n\n\tpublic bool voxelAA = false;\n\n\tint dummyVoxelResolution\n\t{\n\t\tget\n\t\t{\n\t\t\treturn (int)voxelResolution * (voxelAA ? 4 : 1);\n\t\t}\n\t}\n\n#endregion\n\n\n\n\tpublic void ApplyPreset(SEGICascadedPreset preset)\n\t{\n\t\tvoxelResolution = preset.voxelResolution;\n\t\tvoxelAA = preset.voxelAA;\n\t\tinnerOcclusionLayers = preset.innerOcclusionLayers;\n\t\tinfiniteBounces = preset.infiniteBounces;\n\n\t\ttemporalBlendWeight = preset.temporalBlendWeight;\n\t\tuseBilateralFiltering = preset.useBilateralFiltering;\n\t\thalfResolution = preset.halfResolution;\n\t\tstochasticSampling = preset.stochasticSampling;\n\t\tdoReflections = preset.doReflections;\n\n\t\tcones = preset.cones;\n\t\tconeTraceSteps = preset.coneTraceSteps;\n\t\tconeLength = preset.coneLength;\n\t\tconeWidth = preset.coneWidth;\n\t\tconeTraceBias = preset.coneTraceBias;\n\t\tocclusionStrength = preset.occlusionStrength;\n\t\tnearOcclusionStrength = preset.nearOcclusionStrength;\n\t\tocclusionPower = preset.occlusionPower;\n\t\tnearLightGain = preset.nearLightGain;\n\t\tgiGain = preset.giGain;\n\t\tsecondaryBounceGain = preset.secondaryBounceGain;\n\n\t\treflectionSteps = preset.reflectionSteps;\n\t\treflectionOcclusionPower = preset.reflectionOcclusionPower;\n\t\tskyReflectionIntensity = preset.skyReflectionIntensity;\n\t\tgaussianMipFilter = preset.gaussianMipFilter;\n\n\t\tfarOcclusionStrength = preset.farOcclusionStrength;\n\t\tfarthestOcclusionStrength = preset.farthestOcclusionStrength;\n\t\tsecondaryCones = preset.secondaryCones;\n\t\tsecondaryOcclusionStrength = preset.secondaryOcclusionStrength;\n\t}\n\n\tvoid Start()\n\t{\n\t\tInitCheck();\n\t}\n\n\tvoid InitCheck()\n\t{\n\t\tif (initChecker == null)\n\t\t{\n\t\t\tInit();\n\t\t}\n\t}\n\n\tvoid CreateVolumeTextures()\n\t{\n\t\tif (integerVolume)\n\t\t{\n\t\t\tintegerVolume.DiscardContents();\n\t\t\tintegerVolume.Release();\n\t\t\tDestroyImmediate(integerVolume);\n\t\t}\n\t\tintegerVolume = new RenderTexture((int)voxelResolution, (int)voxelResolution, 0, RenderTextureFormat.RInt, RenderTextureReadWrite.Linear);\n\t\t#if UNITY_5_4_OR_NEWER\n\t\tintegerVolume.dimension = TextureDimension.Tex3D;\n\t\t#else\n\t\tintegerVolume.isVolume = true;\n\t\t#endif\n\t\tintegerVolume.volumeDepth = (int)voxelResolution;\n\t\tintegerVolume.enableRandomWrite = true;\n\t\tintegerVolume.filterMode = FilterMode.Point;\n\t\tintegerVolume.Create();\n\t\tintegerVolume.hideFlags = HideFlags.HideAndDontSave;\n\n\t\tResizeDummyTexture();\n\t}\n\n\tvoid BuildClipmaps()\n\t{\n\t\tif (clipmaps != null)\n\t\t{\n\t\t\tfor (int i = 0; i < numClipmaps; i++)\n\t\t\t{\n\t\t\t\tif (clipmaps[i] != null)\n\t\t\t\t{\n\t\t\t\t\tclipmaps[i].CleanupTextures();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tclipmaps = new Clipmap[numClipmaps];\n\n\t\tfor (int i = 0; i < numClipmaps; i++)\n\t\t{\n\t\t\tclipmaps[i] = new Clipmap();\n\t\t\tclipmaps[i].localScale = Mathf.Pow(2.0f, (float)i);\n\t\t\tclipmaps[i].resolution = (int)voxelResolution;\n\t\t\tclipmaps[i].filterMode = FilterMode.Bilinear;\n\t\t\tclipmaps[i].renderTextureFormat = RenderTextureFormat.ARGBHalf;\n\t\t\tclipmaps[i].UpdateTextures();\n\t\t}\n\n\t\tif (irradianceClipmaps != null)\n\t\t{\n\t\t\tfor (int i = 0; i < numClipmaps; i++)\n\t\t\t{\n\t\t\t\tif (irradianceClipmaps[i] != null)\n\t\t\t\t{\n\t\t\t\t\tirradianceClipmaps[i].CleanupTextures();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tirradianceClipmaps = new Clipmap[numClipmaps];\n\n\t\tfor (int i = 0; i < numClipmaps; i++)\n\t\t{\n\t\t\tirradianceClipmaps[i] = new Clipmap();\n\t\t\tirradianceClipmaps[i].localScale = Mathf.Pow(2.0f, i);\n\t\t\tirradianceClipmaps[i].resolution = (int)voxelResolution;\n\t\t\tirradianceClipmaps[i].filterMode = FilterMode.Point;\n\t\t\tirradianceClipmaps[i].renderTextureFormat = RenderTextureFormat.ARGBHalf;\n\t\t\tirradianceClipmaps[i].UpdateTextures();\n\t\t}\n\t}\n\n\tvoid ResizeDummyTexture()\n\t{\n\t\tif (dummyVoxelTextureAAScaled)\n\t\t{\n\t\t\tdummyVoxelTextureAAScaled.DiscardContents();\n\t\t\tdummyVoxelTextureAAScaled.Release();\n\t\t\tDestroyImmediate(dummyVoxelTextureAAScaled);\n\t\t}\n\t\tdummyVoxelTextureAAScaled = new RenderTexture(dummyVoxelResolution, dummyVoxelResolution, 0, RenderTextureFormat.R8);\n\t\tdummyVoxelTextureAAScaled.Create();\n\t\tdummyVoxelTextureAAScaled.hideFlags = HideFlags.HideAndDontSave;\n\n\t\tif (dummyVoxelTextureFixed)\n\t\t{\n\t\t\tdummyVoxelTextureFixed.DiscardContents();\n\t\t\tdummyVoxelTextureFixed.Release();\n\t\t\tDestroyImmediate(dummyVoxelTextureFixed);\n\t\t}\n\t\tdummyVoxelTextureFixed = new RenderTexture((int)voxelResolution, (int)voxelResolution, 0, RenderTextureFormat.R8);\n\t\tdummyVoxelTextureFixed.Create();\n\t\tdummyVoxelTextureFixed.hideFlags = HideFlags.HideAndDontSave;\n\t}\n\n\tvoid GetBlueNoiseTextures()\n\t{\n\t\tblueNoise = null;\n\t\tblueNoise = new Texture2D[64];\n\t\tfor (int i = 0; i < 64; i++)\n\t\t{\n\t\t\tstring filename = \"LDR_RGBA_\" + i.ToString();\n\t\t\tTexture2D blueNoiseTexture = Resources.Load(\"Noise Textures/\" + filename) as Texture2D;\n\n\t\t\tif (blueNoiseTexture == null)\n\t\t\t{\n\t\t\t\tDebug.LogWarning(\"Unable to find noise texture \\\"Assets/SEGI/Resources/Noise Textures/\" + filename + \"\\\" for SEGI!\");\n\t\t\t}\n\n\t\t\tblueNoise[i] = blueNoiseTexture;\n\t\t}\n\t}\n\n\tvoid Init()\n\t{\n\t\t//Setup shaders and materials\n\t\tsunDepthShader = Shader.Find(\"Hidden/SEGIRenderSunDepth_C\");\n\t\tclearCompute = Resources.Load(\"SEGIClear_C\") as ComputeShader;\n\t\ttransferIntsCompute = Resources.Load(\"SEGITransferInts_C\") as ComputeShader;\n\t\tmipFilterCompute = Resources.Load(\"SEGIMipFilter_C\") as ComputeShader;\n\t\tvoxelizationShader = Shader.Find(\"Hidden/SEGIVoxelizeScene_C\");\n\t\tvoxelTracingShader = Shader.Find(\"Hidden/SEGITraceScene_C\");\n\n\t\tif (!material) {\n\t\t\tmaterial = new Material(Shader.Find(\"Hidden/SEGI_C\"));\n\t\t\tmaterial.hideFlags = HideFlags.HideAndDontSave;\n\t\t}\n\n\t\t//Get the camera attached to this game object\n\t\tattachedCamera = this.GetComponent<Camera>();\n\t\tattachedCamera.depthTextureMode |= DepthTextureMode.Depth;\n\t\tattachedCamera.depthTextureMode |= DepthTextureMode.DepthNormals;\n\t\t#if UNITY_5_4_OR_NEWER\n\t\tattachedCamera.depthTextureMode |= DepthTextureMode.MotionVectors;\n\t\t#endif\n\n\n\t\t//Find the proxy shadow rendering camera if it exists\n\t\tGameObject scgo = GameObject.Find(\"SEGI_SHADOWCAM\");\n\n\t\t//If not, create it\n\t\tif (!scgo)\n\t\t{\n\t\t\tshadowCamGameObject = new GameObject(\"SEGI_SHADOWCAM\");\n\t\t\tshadowCam = shadowCamGameObject.AddComponent<Camera>();\n\t\t\tshadowCamGameObject.hideFlags = HideFlags.HideAndDontSave;\n\n\n\t\t\tshadowCam.enabled = false;\n\t\t\tshadowCam.depth = attachedCamera.depth - 1;\n\t\t\tshadowCam.orthographic = true;\n\t\t\tshadowCam.orthographicSize = shadowSpaceSize;\n\t\t\tshadowCam.clearFlags = CameraClearFlags.SolidColor;\n\t\t\tshadowCam.backgroundColor = new Color(0.0f, 0.0f, 0.0f, 1.0f);\n\t\t\tshadowCam.farClipPlane = shadowSpaceSize * 2.0f * shadowSpaceDepthRatio;\n\t\t\tshadowCam.cullingMask = giCullingMask;\n\t\t\tshadowCam.useOcclusionCulling = false;\n\n\t\t\tshadowCamTransform = shadowCamGameObject.transform;\n\t\t}\n\t\telse\t//Otherwise, it already exists, just get it\n\t\t{\n\t\t\tshadowCamGameObject = scgo;\n\t\t\tshadowCam = scgo.GetComponent<Camera>();\n\t\t\tshadowCamTransform = shadowCamGameObject.transform;\n\t\t}\n\n\n\n\n\t\t//Create the proxy camera objects responsible for rendering the scene to voxelize the scene. If they already exist, destroy them\n\t\tGameObject vcgo = GameObject.Find(\"SEGI_VOXEL_CAMERA\");\n\t\t\n\t\tif (!vcgo) {\n\t\t\tvoxelCameraGO = new GameObject(\"SEGI_VOXEL_CAMERA\");\n\t\t\tvoxelCameraGO.hideFlags = HideFlags.HideAndDontSave;\n\n\t\t\tvoxelCamera = voxelCameraGO.AddComponent<Camera>();\n\t\t\tvoxelCamera.enabled = false;\n\t\t\tvoxelCamera.orthographic = true;\n\t\t\tvoxelCamera.orthographicSize = voxelSpaceSize * 0.5f;\n\t\t\tvoxelCamera.nearClipPlane = 0.0f;\n\t\t\tvoxelCamera.farClipPlane = voxelSpaceSize;\n\t\t\tvoxelCamera.depth = -2;\n\t\t\tvoxelCamera.renderingPath = RenderingPath.Forward;\n\t\t\tvoxelCamera.clearFlags = CameraClearFlags.Color;\n\t\t\tvoxelCamera.backgroundColor = Color.black;\n\t\t\tvoxelCamera.useOcclusionCulling = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvoxelCameraGO = vcgo;\n\t\t\tvoxelCamera = vcgo.GetComponent<Camera>();\n\t\t}\n\n\t\tGameObject lvp = GameObject.Find(\"SEGI_LEFT_VOXEL_VIEW\");\n\t\t\n\t\tif (!lvp) {\n\t\t\tleftViewPoint = new GameObject(\"SEGI_LEFT_VOXEL_VIEW\");\n\t\t\tleftViewPoint.hideFlags = HideFlags.HideAndDontSave;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tleftViewPoint = lvp;\n\t\t}\n\n\t\tGameObject tvp = GameObject.Find(\"SEGI_TOP_VOXEL_VIEW\");\n\t\t\n\t\tif (!tvp) {\n\t\t\ttopViewPoint = new GameObject(\"SEGI_TOP_VOXEL_VIEW\");\n\t\t\ttopViewPoint.hideFlags = HideFlags.HideAndDontSave;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttopViewPoint = tvp;\n\t\t}\n\t\t\n\t\t//Setup sun depth texture\n\t\tif (sunDepthTexture)\n\t\t{\n\t\t\tsunDepthTexture.DiscardContents();\n\t\t\tsunDepthTexture.Release();\n\t\t\tDestroyImmediate(sunDepthTexture);\n\t\t}\n\t\tsunDepthTexture = new RenderTexture(sunShadowResolution, sunShadowResolution, 16, RenderTextureFormat.RHalf, RenderTextureReadWrite.Linear);\n\t\tsunDepthTexture.wrapMode = TextureWrapMode.Clamp;\n\t\tsunDepthTexture.filterMode = FilterMode.Point;\n\t\tsunDepthTexture.Create();\n\t\tsunDepthTexture.hideFlags = HideFlags.HideAndDontSave;\n\n\n\n\t\tCreateVolumeTextures();\n\t\tBuildClipmaps();\n\t\tGetBlueNoiseTextures();\n\n\n\n\t\tinitChecker = new object();\n\t}\n\n\tvoid CheckSupport()\n\t{\n\t\tsystemSupported.hdrTextures = SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf);\n\t\tsystemSupported.rIntTextures = SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RInt);\n\t\tsystemSupported.dx11 = SystemInfo.graphicsShaderLevel >= 50 && SystemInfo.supportsComputeShaders;\n\t\tsystemSupported.volumeTextures = SystemInfo.supports3DTextures;\n\n\t\tsystemSupported.postShader = material.shader.isSupported;\n\t\tsystemSupported.sunDepthShader = sunDepthShader.isSupported;\n\t\tsystemSupported.voxelizationShader = voxelizationShader.isSupported;\n\t\tsystemSupported.tracingShader = voxelTracingShader.isSupported;\n\n\t\tif (!systemSupported.fullFunctionality)\n\t\t{\n\t\t\tDebug.LogWarning(\"SEGI is not supported on the current platform. Check for shader compile errors in SEGI/Resources\");\n\t\t\tenabled = false;\n\t\t}\n\t}\n\n\tvoid OnDrawGizmosSelected()\n\t{\n\t\tif (!enabled)\n\t\t\treturn;\n\t\tColor prevColor = Gizmos.color;\n\t\tGizmos.color = new Color(1.0f, 0.25f, 0.0f, 0.5f);\n\n\t\tfloat scale = clipmaps[numClipmaps - 1].localScale;\n\t\tGizmos.DrawCube(clipmaps[0].origin, new Vector3(voxelSpaceSize * scale, voxelSpaceSize * scale, voxelSpaceSize * scale));\n\n\t\tGizmos.color = new Color(1.0f, 0.0f, 0.0f, 0.1f);\n\n\t\tGizmos.color = prevColor;\n\t}\n\n\tvoid CleanupTexture(ref RenderTexture texture)\n\t{\n\t\tif (texture)\n\t\t{\n\t\t\ttexture.DiscardContents();\n\t\t\ttexture.Release();\n\t\t\tDestroyImmediate(texture);\n\t\t}\n\t}\n\n\tvoid CleanupTextures()\n\t{\n\t\tCleanupTexture(ref sunDepthTexture);\n\t\tCleanupTexture(ref previousGIResult);\n\t\tCleanupTexture(ref previousDepth);\n\t\tCleanupTexture(ref integerVolume);\n\t\tCleanupTexture(ref dummyVoxelTextureAAScaled);\n\t\tCleanupTexture(ref dummyVoxelTextureFixed);\n\n\t\tif (clipmaps != null)\n\t\t{\n\t\t\tfor (int i = 0; i < numClipmaps; i++)\n\t\t\t{\n\t\t\t\tif (clipmaps[i] != null)\n\t\t\t\t{\n\t\t\t\t\tclipmaps[i].CleanupTextures();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tif (irradianceClipmaps != null)\n\t\t{\n\t\t\tfor (int i = 0; i < numClipmaps; i++)\n\t\t\t{\n\t\t\t\tif (irradianceClipmaps[i] != null)\n\t\t\t\t{\n\t\t\t\t\tirradianceClipmaps[i].CleanupTextures();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid Cleanup()\n\t{\n\t\tDestroyImmediate(material);\n\t\tDestroyImmediate(voxelCameraGO);\n\t\tDestroyImmediate(leftViewPoint);\n\t\tDestroyImmediate(topViewPoint);\n\t\tDestroyImmediate(shadowCamGameObject);\n\t\tinitChecker = null;\n\t\tCleanupTextures();\n\t}\n\n\tvoid OnEnable()\n\t{\n\t\tInitCheck();\n\t\tResizeRenderTextures();\n\n\t\tCheckSupport();\n\t}\n\n\tvoid OnDisable()\n\t{\n\t\tCleanup();\n\t}\n\n\tvoid ResizeRenderTextures()\n\t{\n\t\tif (previousGIResult)\n\t\t{\n\t\t\tpreviousGIResult.DiscardContents();\n\t\t\tpreviousGIResult.Release();\n\t\t\tDestroyImmediate(previousGIResult);\n\t\t}\n\n\t\tint width = attachedCamera.pixelWidth == 0 ? 2 : attachedCamera.pixelWidth;\n\t\tint height = attachedCamera.pixelHeight == 0 ? 2 : attachedCamera.pixelHeight;\n\n\t\tpreviousGIResult = new RenderTexture(width, height, 0, RenderTextureFormat.ARGBHalf);\n\t\tpreviousGIResult.wrapMode = TextureWrapMode.Clamp;\n\t\tpreviousGIResult.filterMode = FilterMode.Bilinear;\n\t\tpreviousGIResult.Create();\n\t\tpreviousGIResult.hideFlags = HideFlags.HideAndDontSave;\n\n\t\tif (previousDepth)\n\t\t{\n\t\t\tpreviousDepth.DiscardContents();\n\t\t\tpreviousDepth.Release();\n\t\t\tDestroyImmediate(previousDepth);\n\t\t}\n\t\tpreviousDepth = new RenderTexture(width, height, 0, RenderTextureFormat.RFloat, RenderTextureReadWrite.Linear);\n\t\tpreviousDepth.wrapMode = TextureWrapMode.Clamp;\n\t\tpreviousDepth.filterMode = FilterMode.Bilinear;\n\t\tpreviousDepth.Create();\n\t\tpreviousDepth.hideFlags = HideFlags.HideAndDontSave;\n\t}\n\n\tvoid ResizeSunShadowBuffer()\n\t{\n\n\t\tif (sunDepthTexture)\n\t\t{\n\t\t\tsunDepthTexture.DiscardContents();\n\t\t\tsunDepthTexture.Release();\n\t\t\tDestroyImmediate(sunDepthTexture);\n\t\t}\n\t\tsunDepthTexture = new RenderTexture(sunShadowResolution, sunShadowResolution, 16, RenderTextureFormat.RHalf, RenderTextureReadWrite.Linear);\n\t\tsunDepthTexture.wrapMode = TextureWrapMode.Clamp;\n\t\tsunDepthTexture.filterMode = FilterMode.Point;\n\t\tsunDepthTexture.Create();\n\t\tsunDepthTexture.hideFlags = HideFlags.HideAndDontSave;\n\t}\n\n\tvoid Update()\n\t{\n\t\tif (notReadyToRender)\n\t\t\treturn;\n\n\t\tif (previousGIResult == null)\n\t\t{\n\t\t\tResizeRenderTextures();\n\t\t}\n\n\t\tif (previousGIResult.width != attachedCamera.pixelWidth || previousGIResult.height != attachedCamera.pixelHeight)\n\t\t{\n\t\t\tResizeRenderTextures();\n\t\t}\n\n\t\tif ((int)sunShadowResolution != prevSunShadowResolution)\n\t\t{\n\t\t\tResizeSunShadowBuffer();\n\t\t}\n\n\t\tprevSunShadowResolution = (int)sunShadowResolution;\n\n\t\tif (clipmaps[0].resolution != (int)voxelResolution)\n\t\t{\n\t\t\tclipmaps[0].resolution = (int)voxelResolution;\n\t\t\tclipmaps[0].UpdateTextures();\n\t\t}\n\n\t\tif (dummyVoxelTextureAAScaled.width != dummyVoxelResolution)\n\t\t{\n\t\t\tResizeDummyTexture();\n\t\t}\n\t}\n\n\tMatrix4x4 TransformViewMatrix(Matrix4x4 mat)\n\t{\n#if UNITY_5_5_OR_NEWER\n\t\tif (SystemInfo.usesReversedZBuffer)\n\t\t{\n\t\t\tmat[2, 0] = -mat[2, 0];\n\t\t\tmat[2, 1] = -mat[2, 1];\n\t\t\tmat[2, 2] = -mat[2, 2];\n\t\t\tmat[2, 3] = -mat[2, 3];\n\t\t\t// mat[3, 2] += 0.0f;\n\t\t}\n#endif\n\t\treturn mat;\n\t}\n\n\tint SelectCascadeBinary(int c)\n\t{\n\t\tfloat counter = c + 0.01f;\n\n\t\tint result = 0;\n\t\tfor (int i = 1; i < numClipmaps; i++)\n\t\t{\n\t\t\tfloat level = Mathf.Pow(2.0f, i);\n\t\t\tresult += Mathf.CeilToInt(\t((counter / level) % 1.0f) - ((level - 1.0f) / level)\t);\t\t\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tvoid OnPreRender()\n\t{\n\t\t//Force reinitialization to make sure that everything is working properly if one of the cameras was unexpectedly destroyed\n\t\tif (!voxelCamera || !shadowCam)\n\t\t\tinitChecker = null;\n\t\n\t\tInitCheck();\n\n\t\tif (notReadyToRender)\n\t\t\treturn;\n\n\t\tif (!updateGI)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t//Cache the previous active render texture to avoid issues with other Unity rendering going on\n\t\tRenderTexture previousActive = RenderTexture.active;\n\n\t\tShader.SetGlobalInt(\"SEGIVoxelAA\", voxelAA ? 3 : 0);\n\n\t\t//Temporarily disable rendering of shadows on the directional light during voxelization pass. Cache the result to set it back to what it was after voxelization is done\n        LightShadows prevSunShadowSetting = LightShadows.None;\n\t\tif (sun != null)\n\t\t{\n\t\t\tprevSunShadowSetting = sun.shadows;\n        \tsun.shadows = LightShadows.None;\n\t\t}\n\n\t\t//Main voxelization work\n\t\tif (renderState == RenderState.Voxelize)\n\t\t{\n\t\t\tcurrentClipmapIndex = SelectCascadeBinary(clipmapCounter);\t\t//Determine which clipmap to update during this frame\n\n\t\t\tClipmap activeClipmap = clipmaps[currentClipmapIndex];\t\t\t//Set the active clipmap based on which one is determined to render this frame\n\n\t\t\t//If we're not updating the base level 0 clipmap, get the previous clipmap\n\t\t\tClipmap prevClipmap = null;\n\t\t\tif (currentClipmapIndex != 0)\n\t\t\t{\n\t\t\t\tprevClipmap = clipmaps[currentClipmapIndex - 1];\n            }\n\n            float clipmapShadowSize = shadowSpaceSize * activeClipmap.localScale;\n            float clipmapSize = voxelSpaceSize * activeClipmap.localScale;\t//Determine the current clipmap's size in world units based on its scale\n\t\t\t//float voxelTexel = (1.0f * clipmapSize) / activeClipmap.resolution * 0.5f;\t//Calculate the size of a voxel texel in world-space units\n\n\n\n\n\n\t\t\t//Setup the voxel volume origin position\n\t\t\tfloat interval = (clipmapSize) / 8.0f;\t\t\t\t\t\t\t//The interval at which the voxel volume will be \"locked\" in world-space\n\t\t\tVector3 origin;\n\t\t\tif (followTransform)\n\t\t\t{\n\t\t\t\torigin = followTransform.position;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//GI is still flickering a bit when the scene view and the game view are opened at the same time\n\t\t\t\torigin = transform.position + transform.forward * clipmapSize / 4.0f;\n\t\t\t}\n\t\t\t//Lock the voxel volume origin based on the interval\n\t\t\tactiveClipmap.previousOrigin = activeClipmap.origin;\n\t\t\tactiveClipmap.origin = new Vector3(Mathf.Round(origin.x / interval) * interval, Mathf.Round(origin.y / interval) * interval, Mathf.Round(origin.z / interval) * interval);\n\n\n\t\t\t//Clipmap delta movement for scrolling secondary bounce irradiance volume when this clipmap has changed origin\n\t\t\tactiveClipmap.originDelta = activeClipmap.origin - activeClipmap.previousOrigin;\n\t\t\tShader.SetGlobalVector(\"SEGIVoxelSpaceOriginDelta\", activeClipmap.originDelta / (voxelSpaceSize * activeClipmap.localScale));\n\n\n\n\n\n\n\t\t\t//Calculate the relative origin and overlap/size of the previous cascade as compared to the active cascade. This is used to avoid voxelizing areas that have already been voxelized by previous (smaller) cascades\n\t\t\tVector3 prevClipmapRelativeOrigin = Vector3.zero;\n\t\t\tfloat prevClipmapOccupance = 0.0f;\n\t\t\tif (currentClipmapIndex != 0)\n\t\t\t{\n\t\t\t\tprevClipmapRelativeOrigin = (prevClipmap.origin - activeClipmap.origin) / clipmapSize;\n\t\t\t\tprevClipmapOccupance = prevClipmap.localScale / activeClipmap.localScale;\n\t\t\t}\n\t\t\tShader.SetGlobalVector(\"SEGIClipmapOverlap\", new Vector4(prevClipmapRelativeOrigin.x, prevClipmapRelativeOrigin.y, prevClipmapRelativeOrigin.z, prevClipmapOccupance));\n\n\t\t\t//Calculate the relative origin and scale of this cascade as compared to the first (level 0) cascade. This is used during GI tracing/data lookup to ensure tracing is done in the correct space\n\t\t\tfor (int i = 1; i < numClipmaps; i++)\n\t\t\t{\n\t\t\t\tVector3 clipPosFromMaster = Vector3.zero;\n\t\t\t\tfloat clipScaleFromMaster = 1.0f;\n\n\t\t\t\tclipPosFromMaster = (clipmaps[i].origin - clipmaps[0].origin) / (voxelSpaceSize * clipmaps[i].localScale);\n\t\t\t\tclipScaleFromMaster = clipmaps[0].localScale / clipmaps[i].localScale;\n\n\t\t\t\tShader.SetGlobalVector(\"SEGIClipTransform\" + i.ToString(), new Vector4(clipPosFromMaster.x, clipPosFromMaster.y, clipPosFromMaster.z, clipScaleFromMaster));\n\t\t\t}\n\n\t\t\t//Set the voxel camera (proxy camera used to render the scene for voxelization) parameters\n\t\t\tvoxelCamera.enabled = false;\n\t\t\tvoxelCamera.orthographic = true;\n\t\t\tvoxelCamera.orthographicSize = clipmapSize * 0.5f;\n\t\t\tvoxelCamera.nearClipPlane = 0.0f;\n\t\t\tvoxelCamera.farClipPlane = clipmapSize;\n\t\t\tvoxelCamera.depth = -2;\n\t\t\tvoxelCamera.renderingPath = RenderingPath.Forward;\n\t\t\tvoxelCamera.clearFlags = CameraClearFlags.Color;\n\t\t\tvoxelCamera.backgroundColor = Color.black;\n\t\t\tvoxelCamera.cullingMask = giCullingMask;\n\n\t\t\t//Move the voxel camera game object and other related objects to the above calculated voxel space origin\n\t\t\tvoxelCameraGO.transform.position = activeClipmap.origin - Vector3.forward * clipmapSize * 0.5f;\n\t\t\tvoxelCameraGO.transform.rotation = rotationFront;\n\n\t\t\tleftViewPoint.transform.position = activeClipmap.origin + Vector3.left * clipmapSize * 0.5f;\n\t\t\tleftViewPoint.transform.rotation = rotationLeft;\n\t\t\ttopViewPoint.transform.position = activeClipmap.origin + Vector3.up * clipmapSize * 0.5f;\n\t\t\ttopViewPoint.transform.rotation = rotationTop;\n\n\n\n\n\t\t\t//Set matrices needed for voxelization\n\t\t\t//Shader.SetGlobalMatrix(\"WorldToGI\", shadowCam.worldToCameraMatrix);\n\t\t\t//Shader.SetGlobalMatrix(\"GIToWorld\", shadowCam.cameraToWorldMatrix);\n\t\t\t//Shader.SetGlobalMatrix(\"GIProjection\", shadowCam.projectionMatrix);\n\t\t\t//Shader.SetGlobalMatrix(\"GIProjectionInverse\", shadowCam.projectionMatrix.inverse);\n\t\t\tShader.SetGlobalMatrix(\"WorldToCamera\", attachedCamera.worldToCameraMatrix);\n\t\t\tShader.SetGlobalFloat(\"GIDepthRatio\", shadowSpaceDepthRatio);\n\t\t\t\n\t\t\tMatrix4x4 frontViewMatrix = TransformViewMatrix(voxelCamera.transform.worldToLocalMatrix);\n\t\t\tMatrix4x4 leftViewMatrix = TransformViewMatrix(leftViewPoint.transform.worldToLocalMatrix);\n\t\t\tMatrix4x4 topViewMatrix = TransformViewMatrix(topViewPoint.transform.worldToLocalMatrix);\n\n\t\t\tShader.SetGlobalMatrix(\"SEGIVoxelViewFront\", frontViewMatrix);\n\t\t\tShader.SetGlobalMatrix(\"SEGIVoxelViewLeft\", leftViewMatrix);\n\t\t\tShader.SetGlobalMatrix(\"SEGIVoxelViewTop\", topViewMatrix);\n\t\t\tShader.SetGlobalMatrix(\"SEGIWorldToVoxel\", voxelCamera.worldToCameraMatrix);\n\t\t\tShader.SetGlobalMatrix(\"SEGIVoxelProjection\", voxelCamera.projectionMatrix);\n\t\t\tShader.SetGlobalMatrix(\"SEGIVoxelProjectionInverse\", voxelCamera.projectionMatrix.inverse);\n\n\t\t\tShader.SetGlobalMatrix(\"SEGIVoxelVPFront\", GL.GetGPUProjectionMatrix(voxelCamera.projectionMatrix, true) * frontViewMatrix);\n\t\t\tShader.SetGlobalMatrix(\"SEGIVoxelVPLeft\", GL.GetGPUProjectionMatrix(voxelCamera.projectionMatrix, true) * leftViewMatrix);\n\t\t\tShader.SetGlobalMatrix(\"SEGIVoxelVPTop\", GL.GetGPUProjectionMatrix(voxelCamera.projectionMatrix, true) * topViewMatrix);\n\n\t\t\tShader.SetGlobalMatrix(\"SEGIWorldToVoxel\" + currentClipmapIndex.ToString(), voxelCamera.worldToCameraMatrix);\n\t\t\tShader.SetGlobalMatrix(\"SEGIVoxelProjection\" + currentClipmapIndex.ToString(), voxelCamera.projectionMatrix);\n\n\t\t\tMatrix4x4 voxelToGIProjection = shadowCam.projectionMatrix * shadowCam.worldToCameraMatrix * voxelCamera.cameraToWorldMatrix;\n\t\t\tShader.SetGlobalMatrix(\"SEGIVoxelToGIProjection\", voxelToGIProjection);\n\t\t\tShader.SetGlobalVector(\"SEGISunlightVector\", sun ? Vector3.Normalize(sun.transform.forward) : Vector3.up);\n\n\n\t\t\t//Set paramteters\n\t\t\tShader.SetGlobalInt(\"SEGIVoxelResolution\", (int)voxelResolution);\n\t\t\t\n\t\t\tShader.SetGlobalColor(\"GISunColor\", sun == null ? Color.black : new Color(Mathf.Pow(sun.color.r, 2.2f), Mathf.Pow(sun.color.g, 2.2f), Mathf.Pow(sun.color.b, 2.2f), Mathf.Pow(sun.intensity, 2.2f)));\n\t\t\tShader.SetGlobalColor(\"SEGISkyColor\", new Color(Mathf.Pow(skyColor.r * skyIntensity * 0.5f, 2.2f), Mathf.Pow(skyColor.g * skyIntensity * 0.5f, 2.2f), Mathf.Pow(skyColor.b * skyIntensity * 0.5f, 2.2f), Mathf.Pow(skyColor.a, 2.2f)));\n\t\t\tShader.SetGlobalFloat(\"GIGain\", giGain);\n\t\t\tShader.SetGlobalFloat(\"SEGISecondaryBounceGain\", infiniteBounces ? secondaryBounceGain : 0.0f);\n\t\t\tShader.SetGlobalFloat(\"SEGISoftSunlight\", softSunlight);\n\t\t\tShader.SetGlobalInt(\"SEGISphericalSkylight\", sphericalSkylight ? 1 : 0);\n\t\t\tShader.SetGlobalInt(\"SEGIInnerOcclusionLayers\", innerOcclusionLayers);\n\n\n\n\n\t\t\t//Render the depth texture from the sun's perspective in order to inject sunlight with shadows during voxelization\n\t\t\tif (sun != null)\n\t\t\t{\n\t\t\t\tshadowCam.cullingMask = giCullingMask;\n\n\t\t\t\tVector3 shadowCamPosition = activeClipmap.origin + Vector3.Normalize(-sun.transform.forward) * clipmapShadowSize * 0.5f * shadowSpaceDepthRatio;\n\n\t\t\t\tshadowCamTransform.position = shadowCamPosition;\n\t\t\t\tshadowCamTransform.LookAt(activeClipmap.origin, Vector3.up);\n\n\t\t\t\tshadowCam.renderingPath = RenderingPath.Forward;\n\t\t\t\tshadowCam.depthTextureMode |= DepthTextureMode.None;\n\n\t\t\t\tshadowCam.orthographicSize = clipmapShadowSize;\n\t\t\t\tshadowCam.farClipPlane = clipmapShadowSize * 2.0f * shadowSpaceDepthRatio;\n\n                //Shader.SetGlobalMatrix(\"WorldToGI\", shadowCam.worldToCameraMatrix);\n                //Shader.SetGlobalMatrix(\"GIToWorld\", shadowCam.cameraToWorldMatrix);\n                //Shader.SetGlobalMatrix(\"GIProjection\", shadowCam.projectionMatrix);\n                //Shader.SetGlobalMatrix(\"GIProjectionInverse\", shadowCam.projectionMatrix.inverse);\n                voxelToGIProjection = shadowCam.projectionMatrix * shadowCam.worldToCameraMatrix * voxelCamera.cameraToWorldMatrix;\n                Shader.SetGlobalMatrix(\"SEGIVoxelToGIProjection\", voxelToGIProjection);\n\n\n\t\t\t\tGraphics.SetRenderTarget(sunDepthTexture);\n\t\t\t\tshadowCam.SetTargetBuffers(sunDepthTexture.colorBuffer, sunDepthTexture.depthBuffer);\n\n\t\t\t\tshadowCam.RenderWithShader(sunDepthShader, \"\");\n\n\t\t\t\tShader.SetGlobalTexture(\"SEGISunDepth\", sunDepthTexture);\n\t\t\t}\n\n\n\n\n\n\n\n\t\t\t//Clear the volume texture that is immediately written to in the voxelization scene shader\n\t\t\tclearCompute.SetTexture(0, \"RG0\", integerVolume);\n\t\t\tclearCompute.SetInt(\"Res\", activeClipmap.resolution);\n\t\t\tclearCompute.Dispatch(0, activeClipmap.resolution / 16, activeClipmap.resolution / 16, 1);\n\n\n\n\n\t\t\t//Set irradiance \"secondary bounce\" texture\n\t\t\tShader.SetGlobalTexture(\"SEGICurrentIrradianceVolume\", irradianceClipmaps[currentClipmapIndex].volumeTexture0);\n\n\t\t\t\n\t\t\tGraphics.SetRandomWriteTarget(1, integerVolume);\n\t\t\tvoxelCamera.targetTexture = dummyVoxelTextureAAScaled;\n\t\t\tvoxelCamera.RenderWithShader(voxelizationShader, \"\");\n\t\t\tGraphics.ClearRandomWriteTargets();\n\n\n\t\t\t//Transfer the data from the volume integer texture to the main volume texture used for GI tracing. \n\t\t\ttransferIntsCompute.SetTexture(0, \"Result\", activeClipmap.volumeTexture0);\n\t\t\ttransferIntsCompute.SetTexture(0, \"RG0\", integerVolume);\n\t\t\ttransferIntsCompute.SetInt(\"VoxelAA\", voxelAA ? 3 : 0);\n\t\t\ttransferIntsCompute.SetInt(\"Resolution\", activeClipmap.resolution);\n\t\t\ttransferIntsCompute.Dispatch(0, activeClipmap.resolution / 16, activeClipmap.resolution / 16, 1);\n\n\n\n\t\t\t//Push current voxelization result to higher levels\n\t\t\tfor (int i = 0 + 1; i < numClipmaps; i++)\n\t\t\t{\n\t\t\t\tClipmap sourceClipmap = clipmaps[i - 1];\n\t\t\t\tClipmap targetClipmap = clipmaps[i];\n\n\n\t\t\t\tVector3 sourceRelativeOrigin = Vector3.zero;\n\t\t\t\tfloat sourceOccupance = 0.0f;\n\n\t\t\t\tsourceRelativeOrigin = (sourceClipmap.origin - targetClipmap.origin) / (targetClipmap.localScale * voxelSpaceSize);\n\t\t\t\tsourceOccupance = sourceClipmap.localScale / targetClipmap.localScale;\n\n\t\t\t\tmipFilterCompute.SetTexture(0, \"Source\", sourceClipmap.volumeTexture0);\n\t\t\t\tmipFilterCompute.SetTexture(0, \"Destination\", targetClipmap.volumeTexture0);\n\t\t\t\tmipFilterCompute.SetVector(\"ClipmapOverlap\", new Vector4(sourceRelativeOrigin.x, sourceRelativeOrigin.y, sourceRelativeOrigin.z, sourceOccupance));\n\t\t\t\tmipFilterCompute.SetInt(\"destinationRes\", targetClipmap.resolution);\n\t\t\t\tmipFilterCompute.Dispatch(0, targetClipmap.resolution / 16, targetClipmap.resolution / 16, 1);\n\t\t\t}\n\n\n\n\t\t\tfor (int i = 0; i < numClipmaps; i++)\n\t\t\t{\n\t\t\t\tShader.SetGlobalTexture(\"SEGIVolumeLevel\" + i.ToString(), clipmaps[i].volumeTexture0);\n\t\t\t}\n\n\n\t\t\tif (infiniteBounces)\n\t\t\t{\n\t\t\t\trenderState = RenderState.Bounce;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//Increment clipmap counter\n\t\t\t\tclipmapCounter++;\n\t\t\t\tif (clipmapCounter >= (int)Mathf.Pow(2.0f, numClipmaps))\n\t\t\t\t{\n\t\t\t\t\tclipmapCounter = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (renderState == RenderState.Bounce)\n\t\t{\n\t\t\t//Calculate the relative position and scale of the current clipmap as compared to the first (level 0) clipmap. Used to ensure tracing is performed in the correct space\n\t\t\tVector3 translateToZero = Vector3.zero;\n\t\t\ttranslateToZero = (clipmaps[currentClipmapIndex].origin - clipmaps[0].origin) / (voxelSpaceSize * clipmaps[currentClipmapIndex].localScale);\n\t\t\tfloat scaleToZero = 1.0f / clipmaps[currentClipmapIndex].localScale;\n\t\t\tShader.SetGlobalVector(\"SEGICurrentClipTransform\", new Vector4(translateToZero.x, translateToZero.y, translateToZero.z, scaleToZero));\n\n\t\t\t//Clear the volume texture that is immediately written to in the voxelization scene shader\n\t\t\tclearCompute.SetTexture(0, \"RG0\", integerVolume);\n\t\t\tclearCompute.SetInt(\"Res\", clipmaps[currentClipmapIndex].resolution);\n\t\t\tclearCompute.Dispatch(0, (int)voxelResolution / 16, (int)voxelResolution / 16, 1);\n\n\t\t\t//Only render infinite bounces for clipmaps 0, 1, and 2\n\t\t\tif (currentClipmapIndex <= 2)\n\t\t\t{\n\t\t\t\tShader.SetGlobalInt(\"SEGISecondaryCones\", secondaryCones);\n\t\t\t\tShader.SetGlobalFloat(\"SEGISecondaryOcclusionStrength\", secondaryOcclusionStrength);\n\n\t\t\t\tGraphics.SetRandomWriteTarget(1, integerVolume);\n\t\t\t\tvoxelCamera.targetTexture = dummyVoxelTextureFixed;\n\t\t\t\tvoxelCamera.RenderWithShader(voxelTracingShader, \"\");\n\t\t\t\tGraphics.ClearRandomWriteTargets();\n\n\t\t\t\ttransferIntsCompute.SetTexture(1, \"Result\", irradianceClipmaps[currentClipmapIndex].volumeTexture0);\n\t\t\t\ttransferIntsCompute.SetTexture(1, \"RG0\", integerVolume);\n\t\t\t\ttransferIntsCompute.SetInt(\"Resolution\", (int)voxelResolution);\n\t\t\t\ttransferIntsCompute.Dispatch(1, (int)voxelResolution / 16, (int)voxelResolution / 16, 1);\n\t\t\t}\n\n\t\t\t//Increment clipmap counter\n\t\t\tclipmapCounter++;\n\t\t\tif (clipmapCounter >= (int)Mathf.Pow(2.0f, numClipmaps))\n\t\t\t{\n\t\t\t\tclipmapCounter = 0;\n\t\t\t}\n\n\t\t\trenderState = RenderState.Voxelize;\n\n\t\t}\n\t\tMatrix4x4 giToVoxelProjection = voxelCamera.projectionMatrix * voxelCamera.worldToCameraMatrix * shadowCam.cameraToWorldMatrix;\n\t\tShader.SetGlobalMatrix(\"GIToVoxelProjection\", giToVoxelProjection);\n\n\n\n\t\tRenderTexture.active = previousActive;\n\n\t\t//Set the sun's shadow setting back to what it was before voxelization\n\t\tif (sun != null)\n\t\t{\n\t\t\tsun.shadows = prevSunShadowSetting;\n\t\t}\n    }\n\n    [ImageEffectOpaque]\n\tvoid OnRenderImage(RenderTexture source, RenderTexture destination)\n\t{\n\t\tif (notReadyToRender)\n\t\t{\n\t\t\tGraphics.Blit(source, destination);\n\t\t\treturn;\n\t\t}\n\n\t\t//Set parameters\n\t\tShader.SetGlobalFloat(\"SEGIVoxelScaleFactor\", voxelScaleFactor);\n\n\t\tmaterial.SetMatrix(\"CameraToWorld\", attachedCamera.cameraToWorldMatrix);\n\t\tmaterial.SetMatrix(\"WorldToCamera\", attachedCamera.worldToCameraMatrix);\n\t\tmaterial.SetMatrix(\"ProjectionMatrixInverse\", attachedCamera.projectionMatrix.inverse);\n\t\tmaterial.SetMatrix(\"ProjectionMatrix\", attachedCamera.projectionMatrix);\n\t\tmaterial.SetInt(\"FrameSwitch\", frameCounter);\n\t\tShader.SetGlobalInt(\"SEGIFrameSwitch\", frameCounter);\n\t\tmaterial.SetVector(\"CameraPosition\", transform.position);\n\t\tmaterial.SetFloat(\"DeltaTime\", Time.deltaTime);\n\n\t\tmaterial.SetInt(\"StochasticSampling\", stochasticSampling ? 1 : 0);\n\t\tmaterial.SetInt(\"TraceDirections\", cones);\n\t\tmaterial.SetInt(\"TraceSteps\", coneTraceSteps);\n\t\tmaterial.SetFloat(\"TraceLength\", coneLength);\n\t\tmaterial.SetFloat(\"ConeSize\", coneWidth);\n\t\tmaterial.SetFloat(\"OcclusionStrength\", occlusionStrength);\n\t\tmaterial.SetFloat(\"OcclusionPower\", occlusionPower);\n\t\tmaterial.SetFloat(\"ConeTraceBias\", coneTraceBias);\n\t\tmaterial.SetFloat(\"GIGain\", giGain);\n\t\tmaterial.SetFloat(\"NearLightGain\", nearLightGain);\n\t\tmaterial.SetFloat(\"NearOcclusionStrength\", nearOcclusionStrength);\n\t\tmaterial.SetInt(\"DoReflections\", doReflections ? 1 : 0);\n\t\tmaterial.SetInt(\"HalfResolution\", halfResolution ? 1 : 0);\n\t\tmaterial.SetInt(\"ReflectionSteps\", reflectionSteps);\n\t\tmaterial.SetFloat(\"ReflectionOcclusionPower\", reflectionOcclusionPower);\n\t\tmaterial.SetFloat(\"SkyReflectionIntensity\", skyReflectionIntensity);\n\t\tmaterial.SetFloat(\"FarOcclusionStrength\", farOcclusionStrength);\n\t\tmaterial.SetFloat(\"FarthestOcclusionStrength\", farthestOcclusionStrength);\n\t\tmaterial.SetTexture(\"NoiseTexture\", blueNoise[frameCounter]);\n\t\tmaterial.SetFloat(\"BlendWeight\", temporalBlendWeight);\n\n\t\t//If Visualize Voxels is enabled, just render the voxel visualization shader pass and return\n\t\tif (visualizeVoxels)\n\t\t{\n\t\t\tGraphics.Blit(source, destination, material, Pass.VisualizeVoxels);\n\t\t\treturn;\n\t\t}\n\n\t\t//Setup temporary textures\n\t\tRenderTexture gi1 = RenderTexture.GetTemporary(source.width / giRenderRes, source.height / giRenderRes, 0, RenderTextureFormat.ARGBHalf);\n\t\tRenderTexture gi2 = RenderTexture.GetTemporary(source.width / giRenderRes, source.height / giRenderRes, 0, RenderTextureFormat.ARGBHalf);\n\t\tRenderTexture reflections = null;\n\n\t\t//If reflections are enabled, create a temporary render buffer to hold them\n\t\tif (doReflections)\n\t\t{\n\t\t\treflections = RenderTexture.GetTemporary(source.width, source.height, 0, RenderTextureFormat.ARGBHalf);\n\t\t}\n\n\t\t//Get the camera depth and normals\n\t\tRenderTexture currentDepth = RenderTexture.GetTemporary(source.width / giRenderRes, source.height / giRenderRes, 0, RenderTextureFormat.RFloat, RenderTextureReadWrite.Linear);\n\t\tcurrentDepth.filterMode = FilterMode.Point;\n\t\tRenderTexture currentNormal = RenderTexture.GetTemporary(source.width / giRenderRes, source.height / giRenderRes, 0, RenderTextureFormat.ARGBHalf, RenderTextureReadWrite.Linear);\n\t\tcurrentNormal.filterMode = FilterMode.Point;\n\n\t\t//Get the camera depth and normals\n\t\tGraphics.Blit(source, currentDepth, material, Pass.GetCameraDepthTexture);\n\t\tmaterial.SetTexture(\"CurrentDepth\", currentDepth);\n\t\tGraphics.Blit(source, currentNormal, material, Pass.GetWorldNormals);\n\t\tmaterial.SetTexture(\"CurrentNormal\", currentNormal);\n\n\t\t//Set the previous GI result and camera depth textures to access them in the shader\n\t\tmaterial.SetTexture(\"PreviousGITexture\", previousGIResult);\n\t\tShader.SetGlobalTexture(\"PreviousGITexture\", previousGIResult);\n\t\tmaterial.SetTexture(\"PreviousDepth\", previousDepth);\n\n\t\t//Render diffuse GI tracing result\n\t\tGraphics.Blit(source, gi2, material, Pass.DiffuseTrace);\n\t\tif (doReflections)\n\t\t{\t\t\t\n\t\t\t//Render GI reflections result\n\t\t\tGraphics.Blit(source, reflections, material, Pass.SpecularTrace);\n\t\t\tmaterial.SetTexture(\"Reflections\", reflections);\n\t\t}\n\n\n\t\t//Perform bilateral filtering\n\t\tif (useBilateralFiltering && temporalBlendWeight >= 0.99999f)\n\t\t{\n\t\t\tmaterial.SetVector(\"Kernel\", new Vector2(0.0f, 1.0f));\n\t\t\tGraphics.Blit(gi2, gi1, material, Pass.BilateralBlur);\n\n\t\t\tmaterial.SetVector(\"Kernel\", new Vector2(1.0f, 0.0f));\n\t\t\tGraphics.Blit(gi1, gi2, material, Pass.BilateralBlur);\n\n\t\t\tmaterial.SetVector(\"Kernel\", new Vector2(0.0f, 1.0f));\n\t\t\tGraphics.Blit(gi2, gi1, material, Pass.BilateralBlur);\n\n\t\t\tmaterial.SetVector(\"Kernel\", new Vector2(1.0f, 0.0f));\n\t\t\tGraphics.Blit(gi1, gi2, material, Pass.BilateralBlur);\n\t\t}\n\n\t\t//If Half Resolution tracing is enabled\n\t\tif (giRenderRes == 2)\n\t\t{\n\t\t\tRenderTexture.ReleaseTemporary(gi1);\n\n\t\t\t//Setup temporary textures\n\t\t\tRenderTexture gi3 = RenderTexture.GetTemporary(source.width, source.height, 0, RenderTextureFormat.ARGBHalf);\n\t\t\tRenderTexture gi4 = RenderTexture.GetTemporary(source.width, source.height, 0, RenderTextureFormat.ARGBHalf);\n\n\t\t\t//Prepare the half-resolution diffuse GI result to be bilaterally upsampled\n\t\t\tgi2.filterMode = FilterMode.Point;\n\t\t\tGraphics.Blit(gi2, gi4);\n\n\t\t\tRenderTexture.ReleaseTemporary(gi2);\n\n\t\t\tgi4.filterMode = FilterMode.Point;\n\t\t\tgi3.filterMode = FilterMode.Point;\n\n\n\t\t\t//Perform bilateral upsampling on half-resolution diffuse GI result\n\t\t\tmaterial.SetVector(\"Kernel\", new Vector2(1.0f, 0.0f));\n\t\t\tGraphics.Blit(gi4, gi3, material, Pass.BilateralUpsample);\n\t\t\tmaterial.SetVector(\"Kernel\", new Vector2(0.0f, 1.0f));\n\n\n\n\t\t\t//Perform a bilateral blur to be applied in newly revealed areas that are still noisy due to not having previous data blended with it\n\t\t\tRenderTexture blur0 = RenderTexture.GetTemporary(source.width, source.height, 0, RenderTextureFormat.ARGBHalf);\n\t\t\tRenderTexture blur1 = RenderTexture.GetTemporary(source.width, source.height, 0, RenderTextureFormat.ARGBHalf);\n\t\t\tmaterial.SetVector(\"Kernel\", new Vector2(0.0f, 1.0f));\n\t\t\tGraphics.Blit(gi3, blur1, material, Pass.BilateralBlur);\n\n\t\t\tmaterial.SetVector(\"Kernel\", new Vector2(1.0f, 0.0f));\n\t\t\tGraphics.Blit(blur1, blur0, material, Pass.BilateralBlur);\n\n\t\t\tmaterial.SetVector(\"Kernel\", new Vector2(0.0f, 2.0f));\n\t\t\tGraphics.Blit(blur0, blur1, material, Pass.BilateralBlur);\n\n\t\t\tmaterial.SetVector(\"Kernel\", new Vector2(2.0f, 0.0f));\n\t\t\tGraphics.Blit(blur1, blur0, material, Pass.BilateralBlur);\n\n\t\t\tmaterial.SetTexture(\"BlurredGI\", blur0);\n\n\n\t\t\t//Perform temporal reprojection and blending\n\t\t\tif (temporalBlendWeight < 1.0f)\n\t\t\t{\n\t\t\t\tGraphics.Blit(gi3, gi4);\n\t\t\t\tGraphics.Blit(gi4, gi3, material, Pass.TemporalBlend);\n\t\t\t\tGraphics.Blit(gi3, previousGIResult);\n\t\t\t\tGraphics.Blit(source, previousDepth, material, Pass.GetCameraDepthTexture);\n\n\t\t\t\t\t\t\t\n\t\t\t\t//Perform bilateral filtering on temporally blended result\n\t\t\t\tif (useBilateralFiltering)\n\t\t\t\t{\n\t\t\t\t\tmaterial.SetVector(\"Kernel\", new Vector2(0.0f, 1.0f));\n\t\t\t\t\tGraphics.Blit(gi3, gi4, material, Pass.BilateralBlur);\n\n\t\t\t\t\tmaterial.SetVector(\"Kernel\", new Vector2(1.0f, 0.0f));\n\t\t\t\t\tGraphics.Blit(gi4, gi3, material, Pass.BilateralBlur);\n\n\t\t\t\t\tmaterial.SetVector(\"Kernel\", new Vector2(0.0f, 1.0f));\n\t\t\t\t\tGraphics.Blit(gi3, gi4, material, Pass.BilateralBlur);\n\n\t\t\t\t\tmaterial.SetVector(\"Kernel\", new Vector2(1.0f, 0.0f));\n\t\t\t\t\tGraphics.Blit(gi4, gi3, material, Pass.BilateralBlur);\n\t\t\t\t}\n\t\t\t}\n\n\n\n\n\n\t\t\t//Set the result to be accessed in the shader\n\t\t\tmaterial.SetTexture(\"GITexture\", gi3);\n\n\t\t\t//Actually apply the GI to the scene using gbuffer data\n\t\t\tGraphics.Blit(source, destination, material, visualizeGI ? Pass.VisualizeGI : Pass.BlendWithScene);\n\n\t\t\t//Release temporary textures\n\t\t\tRenderTexture.ReleaseTemporary(blur0);\n            RenderTexture.ReleaseTemporary(blur1);\n\t\t\tRenderTexture.ReleaseTemporary(gi3);\n\t\t\tRenderTexture.ReleaseTemporary(gi4);\n\t\t}\n\t\telse\t//If Half Resolution tracing is disabled\n\t\t{\n\t\t\tif (temporalBlendWeight < 1.0f)\n\t\t\t{\n\t\t\t\t//Perform a bilateral blur to be applied in newly revealed areas that are still noisy due to not having previous data blended with it\n                RenderTexture blur0 = RenderTexture.GetTemporary(source.width, source.height, 0, RenderTextureFormat.ARGBHalf);\n                RenderTexture blur1 = RenderTexture.GetTemporary(source.width, source.height, 0, RenderTextureFormat.ARGBHalf);\n                material.SetVector(\"Kernel\", new Vector2(0.0f, 1.0f));\n                Graphics.Blit(gi2, blur1, material, Pass.BilateralBlur);\n\n                material.SetVector(\"Kernel\", new Vector2(1.0f, 0.0f));\n                Graphics.Blit(blur1, blur0, material, Pass.BilateralBlur);\n\n                material.SetVector(\"Kernel\", new Vector2(0.0f, 2.0f));\n                Graphics.Blit(blur0, blur1, material, Pass.BilateralBlur);\n\n                material.SetVector(\"Kernel\", new Vector2(2.0f, 0.0f));\n                Graphics.Blit(blur1, blur0, material, Pass.BilateralBlur);\n\n                material.SetTexture(\"BlurredGI\", blur0);\n\n\n\n\n\t\t\t\t//Perform temporal reprojection and blending\n                Graphics.Blit(gi2, gi1, material, Pass.TemporalBlend);\n\t\t\t\tGraphics.Blit(gi1, previousGIResult);\n\t\t\t\tGraphics.Blit(source, previousDepth, material, Pass.GetCameraDepthTexture);\n\n\n\n\t\t\t\t//Perform bilateral filtering on temporally blended result\n\t\t\t\tif (useBilateralFiltering)\n\t\t\t\t{\n\t\t\t\t\tmaterial.SetVector(\"Kernel\", new Vector2(0.0f, 1.0f));\n\t\t\t\t\tGraphics.Blit(gi1, gi2, material, Pass.BilateralBlur);\n\n\t\t\t\t\tmaterial.SetVector(\"Kernel\", new Vector2(1.0f, 0.0f));\n\t\t\t\t\tGraphics.Blit(gi2, gi1, material, Pass.BilateralBlur);\n\n\t\t\t\t\tmaterial.SetVector(\"Kernel\", new Vector2(0.0f, 1.0f));\n\t\t\t\t\tGraphics.Blit(gi1, gi2, material, Pass.BilateralBlur);\n\n\t\t\t\t\tmaterial.SetVector(\"Kernel\", new Vector2(1.0f, 0.0f));\n\t\t\t\t\tGraphics.Blit(gi2, gi1, material, Pass.BilateralBlur);\n\t\t\t\t}\n\n\n\n                RenderTexture.ReleaseTemporary(blur0);\n                RenderTexture.ReleaseTemporary(blur1);\n            }\n\n\t\t\t//Actually apply the GI to the scene using gbuffer data\n\t\t\tmaterial.SetTexture(\"GITexture\", temporalBlendWeight < 1.0f ? gi1 : gi2);\n\t\t\tGraphics.Blit(source, destination, material, visualizeGI ? Pass.VisualizeGI : Pass.BlendWithScene);\n\n\t\t\t//Release temporary textures\n\t\t\tRenderTexture.ReleaseTemporary(gi1);\n\t\t\tRenderTexture.ReleaseTemporary(gi2);\n\t\t}\n\n\t\t//Release temporary textures\n\t\tRenderTexture.ReleaseTemporary(currentDepth);\n\t\tRenderTexture.ReleaseTemporary(currentNormal);\n\n\t\tif (visualizeSunDepthTexture)\n\t\t\tGraphics.Blit(sunDepthTexture, destination);\n\n\t\t//Release the temporary reflections result texture\n\t\tif (doReflections)\n\t\t{\n\t\t\tRenderTexture.ReleaseTemporary(reflections);\n\t\t}\n\n\t\t//Set matrices/vectors for use during temporal reprojection\n\t\tmaterial.SetMatrix(\"ProjectionPrev\", attachedCamera.projectionMatrix);\n\t\tmaterial.SetMatrix(\"ProjectionPrevInverse\", attachedCamera.projectionMatrix.inverse);\n\t\tmaterial.SetMatrix(\"WorldToCameraPrev\", attachedCamera.worldToCameraMatrix);\n\t\tmaterial.SetMatrix(\"CameraToWorldPrev\", attachedCamera.cameraToWorldMatrix);\n\t\tmaterial.SetVector(\"CameraPositionPrev\", transform.position);\n\n\t\t//Advance the frame counter\n\t\tframeCounter = (frameCounter + 1) % (64);\n\t}\n}\n"
        },
        {
          "name": "SEGICascaded.cs.meta",
          "type": "blob",
          "size": 0.3056640625,
          "content": "fileFormatVersion: 2\nguid: 3f6545096e58f2445a95f9ff831d18fd\ntimeCreated: 1502923567\nlicenseType: Pro\nMonoImporter:\n  serializedVersion: 2\n  defaultReferences: []\n  executionOrder: 0\n  icon: {fileID: 2800000, guid: dbb032076c5c83c41bba0c204a2a970a, type: 3}\n  userData: \n  assetBundleName: \n  assetBundleVariant: \n"
        },
        {
          "name": "SEGICascadedPreset.cs",
          "type": "blob",
          "size": 1.587890625,
          "content": "﻿using UnityEngine;\nusing System.Collections;\n\npublic class SEGICascadedPreset : ScriptableObject\n{\n\tpublic SEGICascaded.VoxelResolution voxelResolution = SEGICascaded.VoxelResolution.high;\n\tpublic bool voxelAA = false;\n\t[Range(0, 2)]\n\tpublic int innerOcclusionLayers = 1;\n\tpublic bool infiniteBounces = true;\n\n\t[Range(0.01f, 1.0f)]\n\tpublic float temporalBlendWeight = 0.15f;\n\tpublic bool useBilateralFiltering = true;\n\tpublic bool halfResolution = true;\n\tpublic bool stochasticSampling = true;\n\tpublic bool doReflections = true;\n\n\t[Range(1, 128)]\n\tpublic int cones = 13;\n\t[Range(1, 32)]\n\tpublic int coneTraceSteps = 8;\n\t[Range(0.1f, 2.0f)]\n\tpublic float coneLength = 1.0f;\n\t[Range(0.5f, 6.0f)]\n\tpublic float coneWidth = 6.0f;\n\t[Range(0.0f, 4.0f)]\n\tpublic float coneTraceBias = 0.63f;\n\t[Range(0.0f, 4.0f)]\n\tpublic float occlusionStrength = 1.0f;\n\t[Range(0.0f, 4.0f)]\n\tpublic float nearOcclusionStrength = 0.0f;\n\t[Range(0.001f, 4.0f)]\n\tpublic float occlusionPower = 1.0f;\n\t[Range(0.0f, 4.0f)]\n\tpublic float nearLightGain = 1.0f;\n\t[Range(0.0f, 4.0f)]\n\tpublic float giGain = 1.0f;\n\t[Range(0.0f, 2.0f)]\n\tpublic float secondaryBounceGain = 1.0f;\n\t[Range(12, 128)]\n\tpublic int reflectionSteps = 64;\n\t[Range(0.001f, 4.0f)]\n\tpublic float reflectionOcclusionPower = 1.0f;\n\t[Range(0.0f, 1.0f)]\n\tpublic float skyReflectionIntensity = 1.0f;\n\tpublic bool gaussianMipFilter = false;\n\n\t[Range(0.1f, 4.0f)]\n\tpublic float farOcclusionStrength = 1.0f;\n\t[Range(0.1f, 4.0f)]\n\tpublic float farthestOcclusionStrength = 1.0f;\n\n\t[Range(3, 16)]\n\tpublic int secondaryCones = 6;\n\t[Range(0.1f, 4.0f)]\n\tpublic float secondaryOcclusionStrength = 1.0f;\n}\n"
        },
        {
          "name": "SEGICascadedPreset.cs.meta",
          "type": "blob",
          "size": 0.255859375,
          "content": "fileFormatVersion: 2\nguid: 195d4ee8e5f057f4590c043b132f9c86\ntimeCreated: 1501556281\nlicenseType: Pro\nMonoImporter:\n  serializedVersion: 2\n  defaultReferences: []\n  executionOrder: 0\n  icon: {instanceID: 0}\n  userData: \n  assetBundleName: \n  assetBundleVariant: \n"
        },
        {
          "name": "SEGIPreset.cs",
          "type": "blob",
          "size": 1.564453125,
          "content": "﻿using UnityEngine;\nusing System.Collections;\n\npublic class SEGIPreset : ScriptableObject\n{\n\tpublic SEGI.VoxelResolution voxelResolution = SEGI.VoxelResolution.high;\n\tpublic bool voxelAA = false;\n\t[Range(0, 2)]\n\tpublic int innerOcclusionLayers = 1;\n\tpublic bool infiniteBounces = true;\n\n\t[Range(0.01f, 1.0f)]\n\tpublic float temporalBlendWeight = 0.15f;\n\tpublic bool useBilateralFiltering = true;\n\tpublic bool halfResolution = true;\n\tpublic bool stochasticSampling = true;\n\tpublic bool doReflections = true;\n\n\t[Range(1, 128)]\n\tpublic int cones = 13;\n\t[Range(1, 32)]\n\tpublic int coneTraceSteps = 8;\n\t[Range(0.1f, 2.0f)]\n\tpublic float coneLength = 1.0f;\n\t[Range(0.5f, 6.0f)]\n\tpublic float coneWidth = 6.0f;\n\t[Range(0.0f, 4.0f)]\n\tpublic float coneTraceBias = 0.63f;\n\t[Range(0.0f, 4.0f)]\n\tpublic float occlusionStrength = 1.0f;\n\t[Range(0.0f, 4.0f)]\n\tpublic float nearOcclusionStrength = 0.0f;\n\t[Range(0.001f, 4.0f)]\n\tpublic float occlusionPower = 1.0f;\n\t[Range(0.0f, 4.0f)]\n\tpublic float nearLightGain = 1.0f;\n\t[Range(0.0f, 4.0f)]\n\tpublic float giGain = 1.0f;\n\t[Range(0.0f, 2.0f)]\n\tpublic float secondaryBounceGain = 1.0f;\n\t[Range(12, 128)]\n\tpublic int reflectionSteps = 64;\n\t[Range(0.001f, 4.0f)]\n\tpublic float reflectionOcclusionPower = 1.0f;\n\t[Range(0.0f, 1.0f)]\n\tpublic float skyReflectionIntensity = 1.0f;\n\tpublic bool gaussianMipFilter = false;\n\n\t[Range(0.1f, 4.0f)]\n\tpublic float farOcclusionStrength = 1.0f;\n\t[Range(0.1f, 4.0f)]\n\tpublic float farthestOcclusionStrength = 1.0f;\n\n\t[Range(3, 16)]\n\tpublic int secondaryCones = 6;\n\t[Range(0.1f, 4.0f)]\n\tpublic float secondaryOcclusionStrength = 1.0f;\n}\n"
        },
        {
          "name": "SEGIPreset.cs.meta",
          "type": "blob",
          "size": 0.255859375,
          "content": "fileFormatVersion: 2\nguid: c7780f824b3fbed498c366c0f53ccef9\ntimeCreated: 1502920421\nlicenseType: Pro\nMonoImporter:\n  serializedVersion: 2\n  defaultReferences: []\n  executionOrder: 0\n  icon: {instanceID: 0}\n  userData: \n  assetBundleName: \n  assetBundleVariant: \n"
        },
        {
          "name": "User Guide.pdf",
          "type": "blob",
          "size": 537.0966796875,
          "content": null
        },
        {
          "name": "User Guide.pdf.meta",
          "type": "blob",
          "size": 0.169921875,
          "content": "fileFormatVersion: 2\nguid: d0dd481c6f681dd4b93c76ecea4252ba\ntimeCreated: 1465554248\nlicenseType: Pro\nDefaultImporter:\n  userData: \n  assetBundleName: \n  assetBundleVariant: \n"
        }
      ]
    }
  ]
}