{
  "metadata": {
    "timestamp": 1736710892909,
    "page": 474,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "0xd4d/dnlib",
      "stars": 2197,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 4.2509765625,
          "content": "root = true\n\n[*]\ncharset = utf-8\n#end_of_line =\nindent_size = 4\nindent_style = tab\ntab_width = 4\n\n[*.json]\n\n[app.config]\n\n[*.yml]\nindent_size = 2\nindent_style = space\n\n[*.{proj,csproj,vbproj,props,targets,resx,vsixmanifest}]\nindent_size = 2\nindent_style = space\n\n[app.manifest]\nindent_size = 2\nindent_style = space\n\n[*.xml]\n\n[*.xaml]\nindent_style = space\n\n[*.{cs,vb}]\ninsert_final_newline = true\n\ndotnet_separate_import_directive_groups = false\ndotnet_sort_system_directives_first = true\ndotnet_style_coalesce_expression = true:suggestion\ndotnet_style_collection_initializer = true:suggestion\ndotnet_style_explicit_tuple_names = true:suggestion\ndotnet_style_null_propagation = true:suggestion\ndotnet_style_object_initializer = true:suggestion\ndotnet_style_predefined_type_for_locals_parameters_members = true:none\ndotnet_style_predefined_type_for_member_access = true:none\ndotnet_style_prefer_auto_properties = true:suggestion\ndotnet_style_prefer_inferred_anonymous_type_member_names = true:suggestion\ndotnet_style_prefer_inferred_tuple_names = true:suggestion\ndotnet_style_prefer_is_null_check_over_reference_equality_method = false:suggestion\ndotnet_style_qualification_for_event = false:suggestion\ndotnet_style_qualification_for_field = false:suggestion\ndotnet_style_qualification_for_method = false:suggestion\ndotnet_style_qualification_for_property = false:suggestion\ndotnet_style_require_accessibility_modifiers = never:info\n\n[*.cs]\ncsharp_indent_block_contents = true\ncsharp_indent_braces = false\ncsharp_indent_case_contents = true\ncsharp_indent_case_contents_when_block = false\ncsharp_indent_labels = flush_left\ncsharp_indent_switch_labels = false\ncsharp_new_line_before_catch = true\ncsharp_new_line_before_else = true\ncsharp_new_line_before_finally = true\ncsharp_new_line_before_members_in_anonymous_types = true\ncsharp_new_line_before_members_in_object_initializers = true\ncsharp_new_line_before_open_brace = none\ncsharp_new_line_between_query_expression_clauses = true\ncsharp_prefer_braces = false\ncsharp_prefer_simple_default_expression = true:suggestion\n#csharp_preferred_modifier_order =\ncsharp_preserve_single_line_blocks = true\ncsharp_preserve_single_line_statements = true\ncsharp_space_after_cast = false\ncsharp_space_after_colon_in_inheritance_clause = true\ncsharp_space_after_comma = true\ncsharp_space_after_dot = false\ncsharp_space_after_keywords_in_control_flow_statements = true\ncsharp_space_after_semicolon_in_for_statement = true\ncsharp_space_around_binary_operators = before_and_after\ncsharp_space_around_declaration_statements = false\ncsharp_space_before_colon_in_inheritance_clause = true\ncsharp_space_before_comma = false\ncsharp_space_before_dot = false\ncsharp_space_before_open_square_brackets = false\ncsharp_space_before_semicolon_in_for_statement = false\ncsharp_space_between_empty_square_brackets = false\ncsharp_space_between_method_call_empty_parameter_list_parentheses = false\ncsharp_space_between_method_call_name_and_opening_parenthesis = false\ncsharp_space_between_method_call_parameter_list_parentheses = false\ncsharp_space_between_method_declaration_empty_parameter_list_parentheses = false\ncsharp_space_between_method_declaration_name_and_open_parenthesis = false\ncsharp_space_between_method_declaration_parameter_list_parentheses = false\ncsharp_space_between_parentheses =\ncsharp_space_between_square_brackets = false\ncsharp_style_conditional_delegate_call = true:suggestion\ncsharp_style_deconstructed_variable_declaration = false:none\ncsharp_style_expression_bodied_accessors = true:suggestion\ncsharp_style_expression_bodied_constructors = true:suggestion\ncsharp_style_expression_bodied_indexers = true:suggestion\ncsharp_style_expression_bodied_methods = true:suggestion\ncsharp_style_expression_bodied_operators = true:suggestion\ncsharp_style_expression_bodied_properties = true:suggestion\ncsharp_style_inlined_variable_declaration = true:suggestion\ncsharp_style_pattern_local_over_anonymous_function = true:suggestion\ncsharp_style_pattern_matching_over_as_with_null_check = true:suggestion\ncsharp_style_pattern_matching_over_is_with_cast_check = true:suggestion\ncsharp_style_throw_expression = true:suggestion\ncsharp_style_var_elsewhere = true:suggestion\ncsharp_style_var_for_built_in_types = false:none\ncsharp_style_var_when_type_is_apparent = true:suggestion\n\n[*.vb]\n#visual_basic_preferred_modifier_order =\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0234375,
          "content": ".vs/\n.vscode/\nbin/\nobj/\n"
        },
        {
          "name": "Examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.0400390625,
          "content": "Copyright (C) 2012-2019 de4dot@gmail.com\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 21.4404296875,
          "content": "# dnlib [![NuGet](https://img.shields.io/nuget/v/dnlib.svg)](https://www.nuget.org/packages/dnlib/) [![](https://github.com/0xd4d/dnlib/workflows/GitHub%20CI/badge.svg)](https://github.com/0xd4d/dnlib/actions)\n\n.NET module/assembly reader/writer library\n\nOpening a .NET assembly/module\n------------------------------\n\nFirst of all, the important namespaces are `dnlib.DotNet` and `dnlib.DotNet.Emit`. `dnlib.DotNet.Emit` is only needed if you intend to read/write method bodies. All the examples below assume you have the appropriate using statements at the top of each source file:\n\n```C#\n    using dnlib.DotNet;\n    using dnlib.DotNet.Emit;\n```\n\nModuleDefMD is the class that is created when you open a .NET module. It has several `Load()` methods that will create a ModuleDefMD instance. If it's not a .NET module/assembly, a `BadImageFormatException` will be thrown.\n\nRead a .NET module from a file:\n\n```C#\n    // Create a default assembly resolver and type resolver and pass it to Load().\n    // If it's a .NET Core assembly, you'll need to disable GAC loading and add\n    // .NET Core reference assembly search paths.\n    ModuleContext modCtx = ModuleDef.CreateModuleContext();\n    ModuleDefMD module = ModuleDefMD.Load(@\"C:\\path\\to\\file.exe\", modCtx);\n```\n\nRead a .NET module from a byte array:\n\n```C#\n    byte[] data = System.IO.File.ReadAllBytes(@\"C:\\path\\of\\file.dll\");\n    // See comment above about the assembly resolver\n    ModuleContext modCtx = ModuleDef.CreateModuleContext();\n    ModuleDefMD module = ModuleDefMD.Load(data, modCtx);\n```\n\nYou can also pass in a Stream instance, an address in memory (HINSTANCE) or even a System.Reflection.Module instance:\n\n```C#\n    System.Reflection.Module reflectionModule = typeof(void).Module;\t// Get mscorlib.dll's module\n    // See comment above about the assembly resolver\n    ModuleContext modCtx = ModuleDef.CreateModuleContext();\n    ModuleDefMD module = ModuleDefMD.Load(reflectionModule, modCtx);\n```\n\nTo get the assembly, use its Assembly property:\n\n```C#\n    AssemblyDef asm = module.Assembly;\n    Console.WriteLine(\"Assembly: {0}\", asm);\n```\n\nIf it's an obfuscated Unity/Mono assembly, you need to create a `ModuleCreationOptions` instance and write `CLRRuntimeReaderKind.Mono` to `ModuleCreationOptions.Runtime` and pass in this `ModuleCreationOptions` instance to one of the `ModuleDefMD.Load(...)` methods.\n\nSaving a .NET assembly/module\n-----------------------------\n\nUse `module.Write()`. It can save the assembly to a file or a Stream.\n\n```C#\n    module.Write(@\"C:\\saved-assembly.dll\");\n```\n\nIf it's a C++/CLI assembly, you should use `NativeWrite()`\n\n```C#\n    module.NativeWrite(@\"C:\\saved-assembly.dll\");\n```\n\nTo detect it at runtime, use this code:\n\n```C#\n    if (module.IsILOnly) {\n    \t// This assembly has only IL code, and no native code (eg. it's a C# or VB assembly)\n    \tmodule.Write(@\"C:\\saved-assembly.dll\");\n    }\n    else {\n    \t// This assembly has native code (eg. C++/CLI)\n    \tmodule.NativeWrite(@\"C:\\saved-assembly.dll\");\n    }\n```\n\nPDB files\n---------\n\nPDB files are read from disk by default. You can change this behaviour by creating a `ModuleCreationOptions` and passing it in to the code that creates a module.\n\nTo save a PDB file, create a `ModuleWriterOptions` / `NativeModuleWriterOptions` and set its `WritePdb` property to `true`. By default, it will create a PDB file with the same name as the output assembly but with a `.pdb` extension. You can override this by writing the PDB file name to `PdbFileName` or writing your own stream to `PdbStream`. If `PdbStream` is initialized, `PdbFileName` should also be initialized because the name of the PDB file will be written to the PE file.\n\n```C#\n    // Create a default assembly resolver and type resolver\n    ModuleContext modCtx = ModuleDef.CreateModuleContext();\n    var mod = ModuleDefMD.Load(@\"C:\\myfile.dll\", modCtx);\n    // ...\n    var wopts = new dnlib.DotNet.Writer.ModuleWriterOptions(mod);\n    wopts.WritePdb = true;\n    // wopts.PdbFileName = @\"C:\\out2.pdb\";\t// Set other file name\n    mod.Write(@\"C:\\out.dll\", wopts);\n```\n\ndnlib supports Windows PDBs, portable PDBs and embedded portable PDBs.\n\nWindows PDBs\n------------\n\nIt's only possible to write Windows PDBs on Windows (portable PDBs can be written on any OS). dnlib has a managed Windows PDB reader that supports all OSes.\n\nThere are two *native* Windows PDB reader and writer implementations, the old `diasymreader.dll` that ships with .NET Framework and `Microsoft.DiaSymReader.Native` which has been updated with more features and bug fixes.\n\ndnlib will use `Microsoft.DiaSymReader.Native` if it exists and fall back to `diasymreader.dll` if needed. `PdbReaderOptions` and `PdbWriterOptions` can be used to disable one of them.\n\n`Microsoft.DiaSymReader.Native` is a NuGet package with 32-bit and 64-bit native DLLs. You have to add a reference to this NuGet package if you want dnlib to use it. dnlib doesn't add a reference to it.\n\nStrong name signing an assembly\n-------------------------------\n\nUse the following code to strong name sign the assembly when saving it:\n\n```C#\n    using dnlib.DotNet.Writer;\n    ...\n    // Open or create an assembly\n    ModuleDef mod = ModuleDefMD.Load(.....);\n    \n    // Create writer options\n    var opts = new ModuleWriterOptions(mod);\n    \n    // Open or create the strong name key\n    var signatureKey = new StrongNameKey(@\"c:\\my\\file.snk\");\n    \n    // This method will initialize the required properties\n    opts.InitializeStrongNameSigning(mod, signatureKey);\n    \n    // Write and strong name sign the assembly\n    mod.Write(@\"C:\\out\\file.dll\", opts);\n```\n\nEnhanced strong name signing an assembly\n----------------------------------------\n\nSee this [MSDN article](http://msdn.microsoft.com/en-us/library/hh415055.aspx) for info on enhanced strong naming.\n\nEnhanced strong name signing without key migration:\n\n```C#\n    using dnlib.DotNet.Writer;\n    ...\n    // Open or create an assembly\n    ModuleDef mod = ModuleDefMD.Load(....);\n    \n    // Open or create the signature keys\n    var signatureKey = new StrongNameKey(....);\n    var signaturePubKey = new StrongNamePublicKey(....);\n    \n    // Create module writer options\n    var opts = new ModuleWriterOptions(mod);\n    \n    // This method will initialize the required properties\n    opts.InitializeEnhancedStrongNameSigning(mod, signatureKey, signaturePubKey);\n    \n    // Write and strong name sign the assembly\n    mod.Write(@\"C:\\out\\file.dll\", opts);\n```\n\nEnhanced strong name signing with key migration:\n\n```C#\n    using dnlib.DotNet.Writer;\n    ...\n    // Open or create an assembly\n    ModuleDef mod = ModuleDefMD.Load(....);\n    \n    // Open or create the identity and signature keys\n    var signatureKey = new StrongNameKey(....);\n    var signaturePubKey = new StrongNamePublicKey(....);\n    var identityKey = new StrongNameKey(....);\n    var identityPubKey = new StrongNamePublicKey(....);\n    \n    // Create module writer options\n    var opts = new ModuleWriterOptions(mod);\n    \n    // This method will initialize the required properties and add\n    // the required attribute to the assembly.\n    opts.InitializeEnhancedStrongNameSigning(mod, signatureKey, signaturePubKey, identityKey, identityPubKey);\n    \n    // Write and strong name sign the assembly\n    mod.Write(@\"C:\\out\\file.dll\", opts);\n```\n\nExporting managed methods (DllExport)\n-------------------------------------\n\ndnlib supports exporting managed methods so the managed DLL file can be loaded by native code and then executed. .NET Framework supports this feature, but there's no guarantee that other CLRs (eg. .NET Core or Mono/Unity) support this feature.\nIn case of .NET Core please be aware that `ijwhost.dll` has to be loaded prior to calling your exported method and that ijwhost currently (as of .NET Core 3.0) does not work if the calling app is self-contained.\n\nThe `MethodDef` class has an `ExportInfo` property. If it gets initialized, the method gets exported when saving the module. At most 65536 (2^16) methods can be exported. This is a PE file limitation, not a dnlib limitation.\n\nExported methods should not be generic.\n\nThe method's calling convention should be changed to eg. stdcall, or cdecl, by adding an optional modifier to `MethodDef.MethodSig.RetType`. It must be a `System.Runtime.CompilerServices.CallConvCdecl`, `System.Runtime.CompilerServices.CallConvStdcall`, `System.Runtime.CompilerServices.CallConvThiscall`, or a `System.Runtime.CompilerServices.CallConvFastcall`, eg.:\n\n```C#\nvar type = method.MethodSig.RetType;\ntype = new CModOptSig(module.CorLibTypes.GetTypeRef(\"System.Runtime.CompilerServices\", \"CallConvCdecl\"), type);\nmethod.MethodSig.RetType = type;\n```\n\nRequirements:\n\n- The assembly platform must be x86, x64, IA-64 or ARM (ARM64 isn't supported at the moment). AnyCPU assemblies are not supported. This is as simple as changing (if needed) `ModuleWriterOptions.PEHeadersOptions.Machine` when saving the file. x86 files should set `32-bit required` flag and clear `32-bit preferred` flag in the COR20 header.\n- `ModuleWriterOptions.Cor20HeaderOptions.Flags`: The `IL Only` bit must be cleared.\n- It must be a DLL file (see `ModuleWriterOptions.PEHeadersOptions.Characteristics`). The file will fail to load at runtime if it's an EXE file.\n\nNOTE: VS' debugger crashes if there's a `DebuggableAttribute` attribute and if the first ctor arg is 0x107. The workaround is to clear the `EnableEditAndContinue` bit:\n\n```C#\nvar ca = module.Assembly.CustomAttributes.Find(\"System.Diagnostics.DebuggableAttribute\");\nif (ca is not null && ca.ConstructorArguments.Count == 1) {\n    var arg = ca.ConstructorArguments[0];\n    // VS' debugger crashes if value == 0x107, so clear EnC bit\n    if (arg.Type.FullName == \"System.Diagnostics.DebuggableAttribute/DebuggingModes\" && arg.Value is int value && value == 0x107) {\n        arg.Value = value & ~(int)DebuggableAttribute.DebuggingModes.EnableEditAndContinue;\n        ca.ConstructorArguments[0] = arg;\n    }\n}\n```\n\nSee the following issues: [#271](https://github.com/0xd4d/dnlib/issues/271), [#172](https://github.com/0xd4d/dnlib/issues/172)\n\nType classes\n------------\n\nThe metadata has three type tables: `TypeRef`, `TypeDef`, and `TypeSpec`. The classes dnlib use are called the same. These three classes all implement `ITypeDefOrRef`.\n\nThere's also type signature classes. The base class is `TypeSig`. You'll find `TypeSig`s in method signatures (return type and parameter types) and locals. The `TypeSpec` class also has a `TypeSig` property.\n\nAll of these types implement `IType`.\n\n`TypeRef` is a reference to a type in (usually) another assembly.\n\n`TypeDef` is a type definition and it's a type defined in some module. This class does *not* derive from `TypeRef`. :)\n\n`TypeSpec` can be a generic type, an array type, etc.\n\n`TypeSig` is the base class of all type signatures (found in method sigs and locals). It has a `Next` property that points to the next `TypeSig`. Eg. a Byte[] would first contain a `SZArraySig`, and its `Next` property would point to Byte signature.\n\n`CorLibTypeSig` is a simple corlib type. You don't create these directly. Use eg. `module.CorLibTypes.Int32` to get a System.Int32 type signature.\n\n`ValueTypeSig` is used when the next class is a value type.\n\n`ClassSig` is used when the next class is a reference type.\n\n`GenericInstSig` is a generic instance type. It has a reference to the generic type (a `TypeDef` or a `TypeRef`) and the generic arguments.\n\n`PtrSig` is a pointer sig.\n\n`ByRefSig` is a by reference type.\n\n`ArraySig` is a multi-dimensional array type. Most likely when you create an array, you should use `SZArraySig`, and *not* `ArraySig`.\n\n`SZArraySig` is a single dimension, zero lower bound array. In C#, a `byte[]` is a `SZArraySig`, and *not* an `ArraySig`.\n\n`GenericVar` is a generic type variable.\n\n`GenericMVar` is a generic method variable.\n\nSome examples if you're not used to the way type signatures are represented in metadata:\n\n```C#\n    ModuleDef mod = ....;\n    \n    // Create a byte[]\n    SZArraySig array1 = new SZArraySig(mod.CorLibTypes.Byte);\n    \n    // Create an int[][]\n    SZArraySig array2 = new SZArraySig(new SZArraySig(mod.CorLibTypes.Int32));\n    \n    // Create an int[,]\n    ArraySig array3 = new ArraySig(mod.CorLibTypes.Int32, 2);\n    \n    // Create an int[*] (one-dimensional array)\n    ArraySig array4 = new ArraySig(mod.CorLibTypes.Int32, 1);\n    \n    // Create a Stream[]. Stream is a reference class so it must be enclosed in a ClassSig.\n    // If it were a value type, you would use ValueTypeSig instead.\n    TypeRef stream = new TypeRefUser(mod, \"System.IO\", \"Stream\", mod.CorLibTypes.AssemblyRef);\n    SZArraySig array5 = new SZArraySig(new ClassSig(stream));\n```\n\nSometimes you must convert an `ITypeDefOrRef` (`TypeRef`, `TypeDef`, or `TypeSpec`) to/from a `TypeSig`. There's extension methods you can use:\n\n```C#\n    // array5 is defined above\n    ITypeDefOrRef type1 = array5.ToTypeDefOrRef();\n    TypeSig type2 = type1.ToTypeSig();\n```\n\nNaming conventions of metadata table classes\n--------------------------------------------\n\nFor most tables in the metadata, there's a corresponding dnlib class with the exact same or a similar name. Eg. the metadata has a `TypeDef` table, and dnlib has a `TypeDef` class. Some tables don't have a class because they're referenced by other classes, and that information is part of some other class. Eg. the `TypeDef` class contains all its properties and events, even though the `TypeDef` table has no property or event column.\n\nFor each of these table classes, there's an abstract base class, and two sub classes. These sub classes are named the same as the base class but ends in either `MD` (for classes created from the metadata) or `User` (for classes created by the user). Eg. `TypeDef` is the base class, and it has two sub classes `TypeDefMD` which is auto-created from metadata, and `TypeRefUser` which is created by the user when adding user types. Most of the XyzMD classes are internal and can't be referenced directly by the user. They're created by `ModuleDefMD` (which is the only public `MD` class). All XyzUser classes are public.\n\nMetadata table classes\n----------------------\n\nHere's a list of the most common metadata table classes\n\n`AssemblyDef` is the assembly class.\n\n`AssemblyRef` is an assembly reference.\n\n`EventDef` is an event definition. Owned by a `TypeDef`.\n\n`FieldDef` is a field definition. Owned by a `TypeDef`.\n\n`GenericParam` is a generic parameter (owned by a `MethodDef` or a `TypeDef`)\n\n`MemberRef` is what you create if you need a field reference or a method reference.\n\n`MethodDef` is a method definition. It usually has a `CilBody` with CIL instructions. Owned by a `TypeDef`.\n\n`MethodSpec` is a instantiated generic method.\n\n`ModuleDef` is the base module class. When you read an existing module, a `ModuleDefMD` is created.\n\n`ModuleRef` is a module reference.\n\n`PropertyDef` is a property definition. Owned by a `TypeDef`.\n\n`TypeDef` is a type definition. It contains a lot of interesting stuff, including methods, fields, properties, etc.\n\n`TypeRef` is a type reference. Usually to a type in another assembly.\n\n`TypeSpec` is a type specification, eg. an array, generic type, etc.\n\nMethod classes\n--------------\n\nThe following are the method classes: `MethodDef`, `MemberRef` (method ref) and `MethodSpec`. They all implement `IMethod`.\n\nField classes\n-------------\n\nThe following are the field classes: `FieldDef` and `MemberRef` (field ref). They both implement `IField`.\n\nComparing types, methods, fields, etc\n-------------------------------------\n\ndnlib has a `SigComparer` class that can compare any type with any other type. Any method with any other method, etc. It also has several pre-created `IEqualityComparer<T>` classes (eg. `TypeEqualityComparer`, `FieldEqualityComparer`, etc) which you can use if you intend to eg. use a type as a key in a `Dictionary<TKey, TValue>`.\n\nThe `SigComparer` class can also compare types with `System.Type`, methods with `System.Reflection.MethodBase`, etc.\n\nIt has many options you can set, see `SigComparerOptions`. The default options is usually good enough, though.\n\n```C#\n    // Compare two types\n    TypeRef type1 = ...;\n    TypeDef type2 = ...;\n    if (new SigComparer().Equals(type1, type2))\n    \tConsole.WriteLine(\"They're equal\");\n\n    // Use the type equality comparer\n    Dictionary<IType, int> dict = new Dictionary<IType, int>(TypeEqualityComparer.Instance);\n    TypeDef type1 = ...;\n    dict.Add(type1, 10);\n\n    // Compare a `TypeRef` with a `System.Type`\n    TypeRef type1 = ...;\n    if (new SigComparer().Equals(type1, typeof(int)))\n    \tConsole.WriteLine(\"They're equal\");\n```\n\nIt has many `Equals()` and `GetHashCode()` overloads.\n\n.NET Resources\n--------------\n\nThere's three types of .NET resource, and they all derive from the common base class `Resource`. `ModuleDef.Resources` is a list of all resources the module owns.\n\n`EmbeddedResource` is a resource that has data embedded in the owner module. This is the most common type of resource and it's probably what you want.\n\n`AssemblyLinkedResource` is a reference to a resource in another assembly.\n\n`LinkedResource` is a reference to a resource on disk.\n\nWin32 resources\n---------------\n\n`ModuleDef.Win32Resources` can be null or a `Win32Resources` instance. You can add/remove any Win32 resource blob. dnlib doesn't try to parse these blobs.\n\nParsing method bodies\n---------------------\n\nThis is usually only needed if you have decrypted a method body. If it's a standard method body, you can use `MethodBodyReader.Create()`. If it's similar to a standard method body, you can derive a class from `MethodBodyReaderBase` and override the necessary methods.\n\nResolving references\n--------------------\n\n`TypeRef.Resolve()` and `MemberRef.Resolve()` both use `module.Context.Resolver` to resolve the type, field or method. The custom attribute parser code may also resolve type references.\n\nIf you call `Resolve()` or read custom attributes, you should initialize module.Context to a `ModuleContext`. It should normally be shared between all modules you open.\n\n```C#\n    // You should pass this context to ModuleDefMD.Load(), but you can also write\n    // it to `module.Context`\n    ModuleContext modCtx = ModuleDef.CreateModuleContext();\n    // It creates the default assembly resolver\n    AssemblyResolver asmResolver = (AssemblyResolver)modCtx.AssemblyResolver;\n\n    // Enable the TypeDef cache for all assemblies that are loaded\n    // by the assembly resolver. Only enable it if all auto-loaded\n    // assemblies are read-only.\n    asmResolver.EnableTypeDefCache = true;\n```\n\nAll assemblies that you yourself open should be added to the assembly resolver cache.\n\n```C#\n    ModuleDefMD mod = ModuleDefMD.Load(...);\n    mod.Context = modCtx;\t// Use the previously created (and shared) context\n    // This code assumes you're using the default assembly resolver\n    ((AssemblyResolver)mod.Context.AssemblyResolver).AddToCache(mod);\n```\n\nResolving types, methods, etc from metadata tokens\n--------------------------------------------------\n\n`ModuleDefMD` has several `ResolveXXX()` methods, eg. `ResolveTypeDef()`, `ResolveMethod()`, etc.\n\nCreating mscorlib type references\n---------------------------------\n\nEvery module has a `CorLibTypes` property. It has references to a few of the simplest types such as all integer types, floating point types, Object, String, etc. If you need a type that's not there, you must create it yourself, eg.:\n\n```C#\n    TypeRef consoleRef = new TypeRefUser(mod, \"System\", \"Console\", mod.CorLibTypes.AssemblyRef);\n```\n\nImporting runtime types, methods, fields\n----------------------------------------\n\nTo import a `System.Type`, `System.Reflection.MethodInfo`, `System.Reflection.FieldInfo`, etc into a module, use the `Importer` class.\n\n```C#\n    Importer importer = new Importer(mod);\n    ITypeDefOrRef consoleRef = importer.Import(typeof(System.Console));\n    IMethod writeLine = importer.Import(typeof(System.Console).GetMethod(\"WriteLine\"));\n```\n\nYou can also use it to import types, methods etc from another `ModuleDef`.\n\nAll imported types, methods etc will be references to the original assembly. I.e., it won't add the imported `TypeDef` to the target module. It will just create a `TypeRef` to it.\n\nUsing decrypted methods\n-----------------------\n\nIf `ModuleDefMD.MethodDecrypter` is initialized, `ModuleDefMD` will call it and check whether the method has been decrypted. If it has, it calls `IMethodDecrypter.GetMethodBody()` which you should implement. Return the new `MethodBody`. `GetMethodBody()` should usually call `MethodBodyReader.Create()` which does the actual parsing of the CIL code.\n\nIt's also possible to override `ModuleDefMD.ReadUserString()`. This method is called by the CIL parser when it finds a `Ldstr` instruction. If `ModuleDefMD.StringDecrypter` is not null, its `ReadUserString()` method is called with the string token. Return the decrypted string or null if it should be read from the `#US` heap.\n\nLow level access to the metadata\n--------------------------------\n\nThe low level classes are in the `dnlib.DotNet.MD` namespace.\n\nOpen an existing .NET module/assembly and you get a ModuleDefMD. It has several properties, eg. `StringsStream` is the #Strings stream.\n\nThe `Metadata` property gives you full access to the metadata.\n\nTo get a list of all valid TypeDef rids (row IDs), use this code:\n\n```C#\n    using dnlib.DotNet.MD;\n    // ...\n    ModuleDefMD mod = ModuleDefMD.Load(...);\n    RidList typeDefRids = mod.Metadata.GetTypeDefRidList();\n    for (int i = 0; i < typeDefRids.Count; i++)\n    \tConsole.WriteLine(\"rid: {0}\", typeDefRids[i]);\n```\n\nYou don't need to create a `ModuleDefMD`, though. See `MetadataFactory`.\n\nCredits\n-------\n\nBig thanks to [Ki](https://github.com/yck1509) for writing the managed Windows PDB reader!\n\n[List of all contributors](https://github.com/0xd4d/dnlib/graphs/contributors)\n"
        },
        {
          "name": "build.ps1",
          "type": "blob",
          "size": 0.84375,
          "content": "param([switch]$NoMsbuild)\n\n$ErrorActionPreference = 'Stop'\n\n$configuration = 'Release'\n\n#\n# dotnet build isn't used because it can't build net35 tfms\n#\n\n$env:NoTargetFrameworkNet35 = ''\n\n$useMsbuild = $IsWindows -or $IsWindows -eq $null\nif ($NoMsbuild) {\n\t$useMsbuild = $false\n}\n\nif (!$useMsbuild) {\n\t# There are currently no net35 reference assemblies on nuget\n\t$env:NoTargetFrameworkNet35 = 'true'\n}\n\nif ($useMsbuild) {\n\tmsbuild -v:m -restore -t:Build -p:Configuration=$configuration\n\tif ($LASTEXITCODE) { exit $LASTEXITCODE }\n\tmsbuild -v:m -t:Pack -p:Configuration=$configuration src/dnlib.csproj\n\tif ($LASTEXITCODE) { exit $LASTEXITCODE }\n}\nelse {\n\tdotnet build -v:m -c $configuration\n\tif ($LASTEXITCODE) { exit $LASTEXITCODE }\n\tdotnet pack -v:m -c $configuration src/dnlib.csproj\n\tif ($LASTEXITCODE) { exit $LASTEXITCODE }\n}\n\n$env:NoTargetFrameworkNet35 = ''\n"
        },
        {
          "name": "dnlib.sln",
          "type": "blob",
          "size": 1.53125,
          "content": "﻿\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio Version 16\nVisualStudioVersion = 16.0.29318.209\nMinimumVisualStudioVersion = 16.0.29318.209\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"dnlib\", \"src\\dnlib.csproj\", \"{FDFC1237-143F-4919-8318-4926901F4639}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Examples\", \"Examples\\Examples.csproj\", \"{F27E72B5-C4BD-40BF-AD19-4C8A99B55872}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|Any CPU = Debug|Any CPU\n\t\tRelease|Any CPU = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{FDFC1237-143F-4919-8318-4926901F4639}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{FDFC1237-143F-4919-8318-4926901F4639}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{FDFC1237-143F-4919-8318-4926901F4639}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{FDFC1237-143F-4919-8318-4926901F4639}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{F27E72B5-C4BD-40BF-AD19-4C8A99B55872}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{F27E72B5-C4BD-40BF-AD19-4C8A99B55872}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{F27E72B5-C4BD-40BF-AD19-4C8A99B55872}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{F27E72B5-C4BD-40BF-AD19-4C8A99B55872}.Release|Any CPU.Build.0 = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {49902A67-E85B-44E8-9C4F-26F8854AA894}\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "dnlib.snk",
          "type": "blob",
          "size": 0.58203125,
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}