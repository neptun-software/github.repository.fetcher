{
  "metadata": {
    "timestamp": 1736710746202,
    "page": 177,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ullmark/hashids.net",
      "stars": 3327,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.8115234375,
          "content": "# top-most EditorConfig file\r\nroot = true\r\n\r\n[*.cs]\r\nend_of_line = lf\r\nindent_style = space\r\nindent_size = 4\r\n\r\n# IDE0049: Use framework type\r\ndotnet_style_predefined_type_for_locals_parameters_members = true\r\ndotnet_style_predefined_type_for_member_access = true\r\n\r\n# IDE0008: Use explicit type\r\ncsharp_style_var_when_type_is_apparent = true\r\ncsharp_style_var_for_built_in_types = true\r\ncsharp_style_var_elsewhere = true\r\n\r\n# IDE0009: Member access should be qualified.\r\ndotnet_style_qualification_for_method = false\r\ndotnet_style_qualification_for_event = false\r\ndotnet_style_qualification_for_field = false\r\ndotnet_style_qualification_for_property = false\r\n\r\n# IDE0058: Expression value is never used\r\ncsharp_style_unused_value_expression_statement_preference = discard_variable:none\r\ndotnet_diagnostic.IDE0058.severity = none\r\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.375,
          "content": "\n\n# User-specific files\n*.rsuser\n*.suo\n*.user\n*.userosscache\n*.sln.docstates\n*.cache\n*.orig\n.idea/\n.vs\n\n# Build results\n[Dd]ebug/\n[Dd]ebugPublic/\n[Rr]elease/\n[Rr]eleases/\nx64/\nx86/\n[Aa][Rr][Mm]/\n[Aa][Rr][Mm]64/\nbld/\n[Bb]in/\n[Oo]bj/\n[Ll]og/\n[Ll]ogs/\n\n# .NET Core\nproject.lock.json\nproject.fragment.lock.json\nartifacts/\npackages/\n\n# BenchmarkDotNet.Artifacts\nBenchmarkDotNet.Artifacts/\n"
        },
        {
          "name": "Hashids.net.sln",
          "type": "blob",
          "size": 2.408203125,
          "content": "﻿\r\nMicrosoft Visual Studio Solution File, Format Version 12.00\r\n# Visual Studio Version 16\r\nVisualStudioVersion = 16.0.29324.140\r\nMinimumVisualStudioVersion = 10.0.40219.1\r\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"Solution Items\", \"Solution Items\", \"{A6015393-39EA-44E3-BF0A-37D2BC5CC874}\"\r\n\tProjectSection(SolutionItems) = preProject\r\n\t\t.editorconfig = .editorconfig\r\n\t\tLICENSE.txt = LICENSE.txt\r\n\t\tREADME.md = README.md\r\n\tEndProjectSection\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Hashids.net\", \"src\\Hashids.net\\Hashids.net.csproj\", \"{4802CAD5-1B10-4C3F-9333-B80664A9A4FC}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Hashids.net.test\", \"test\\Hashids.net.test\\Hashids.net.test.csproj\", \"{3BB2139F-2788-4B8C-9A2E-9F35BFCD3EBB}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Hashids.net.benchmark\", \"test\\Hashids.net.benchmark\\Hashids.net.benchmark.csproj\", \"{5A9F0EB0-FFE0-41BF-8A8D-11CD23B283B7}\"\r\nEndProject\r\nGlobal\r\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\r\n\t\tDebug|Any CPU = Debug|Any CPU\r\n\t\tRelease|Any CPU = Release|Any CPU\r\n\tEndGlobalSection\r\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\r\n\t\t{4802CAD5-1B10-4C3F-9333-B80664A9A4FC}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{4802CAD5-1B10-4C3F-9333-B80664A9A4FC}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{4802CAD5-1B10-4C3F-9333-B80664A9A4FC}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{4802CAD5-1B10-4C3F-9333-B80664A9A4FC}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{3BB2139F-2788-4B8C-9A2E-9F35BFCD3EBB}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{3BB2139F-2788-4B8C-9A2E-9F35BFCD3EBB}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{3BB2139F-2788-4B8C-9A2E-9F35BFCD3EBB}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{3BB2139F-2788-4B8C-9A2E-9F35BFCD3EBB}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{5A9F0EB0-FFE0-41BF-8A8D-11CD23B283B7}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{5A9F0EB0-FFE0-41BF-8A8D-11CD23B283B7}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{5A9F0EB0-FFE0-41BF-8A8D-11CD23B283B7}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{5A9F0EB0-FFE0-41BF-8A8D-11CD23B283B7}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\tEndGlobalSection\r\n\tGlobalSection(SolutionProperties) = preSolution\r\n\t\tHideSolutionNode = FALSE\r\n\tEndGlobalSection\r\n\tGlobalSection(ExtensibilityGlobals) = postSolution\r\n\t\tSolutionGuid = {DC10B2B5-0872-4BEA-92F8-35570DFAC84F}\r\n\tEndGlobalSection\r\nEndGlobal\r\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.0458984375,
          "content": "Copyright (c) 2012 Markus Ullmark\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.5205078125,
          "content": "# Hashids\n\nA small .NET package to generate YouTube-like IDs from numbers.\n\nIt converts numbers like `347` into strings like `yr8`, or array of numbers like `[27, 986]` into `3kTMd`. You can also decode those IDs back. This is useful in bundling several parameters into one, hiding actual IDs, or simply using them as short string IDs.\n\n[http://www.hashids.org/net/](http://www.hashids.org/net/)\n\n## NOTE: You might want to use sqids-dotnet instead.\nThe original author of the Hashids algoritm has rebranded and created a new algoritm called \"sqids\", [you can read more about why here.](https://github.com/hashids). A .NET version of sqids has already been created and [can be found here](https://sqids.org/dotnet). \n\nThis library have more or less been considered feature complete since its creation 2012 and will remain available and accept pull requests for \nbug fixes etc. but no new features will be added.\n\n## Features\n\n-   Creates short unique IDs from integers. _(only positive numbers & zero)_\n-   Generates non-sequential IDs for incremental input to stay unguessable.\n-   Supports a single number or array of numbers. _(supports `int` and `long`)_\n-   Supports custom alphabet and salt — so IDs are unique to your application. _(salt must be smaller than alphabet)_\n-   Supports minimum hash length.\n-   Tries to avoid basic English curse words.\n\n### Notes\n\n-   This is **NOT** a true cryptographic hash, since it is reversible.\n-   Only zero and positive integers are supported. Negative numbers will not be encoded.\n-   Only a minimum hash length can be specified. There is no way to fit arbitrary numbers within a maximum hash length.\n-   The alphabet must contain at least 16 unique characters and is case-sensitive.\n-   Separators are characters used to encode multiple numbers in a hash and must also be in the alphabet.\n-   The salt must be smaller than the available alphabet and is limited to the length of the `alphabet - separators - 1`.\n\n## Installation\n\nInstall the package with [NuGet][]\n\n    Install-Package hashids.net\n\n## Usage\n\n### Import namespace\n\n```C#\nusing HashidsNet;\n```\n\n### Encoding one number\n\nYou can pass a unique salt value so your hashes differ from everyone else's. I use \"**this is my salt**\" as an example.\n\n```C#\nvar hashids = new Hashids(\"this is my salt\");\nvar hash = hashids.Encode(12345);\n```\n\n`hash` is now going to be:\n\n    NkK9\n\nIf your id is stored as a `Int64` you need to use \"EncodeLong\".\n\n```C#\nvar hashids = new Hashids(\"this is my salt\");\nvar hash = hashids.EncodeLong(666555444333222L);\n```\n\n`hash` is now going to be:\n\n    KVO9yy1oO5j\n\n### Decoding\n\nNotice during decoding, same salt value is used:\n\n```C#\nvar hashids = new Hashids(\"this is my salt\");\nnumbers = hashids.Decode(\"NkK9\");\n```\n\n`numbers` is now going to be:\n\n    [ 12345 ]\n\n```C#\nvar hashids = new Hashids(\"this is my salt\");\nnumbers = hashids.DecodeLong(\"KVO9yy1oO5j\");\n```\n\n`numbers` is now going to be:\n\n    [ 666555444333222L ]\n\n### Decoding a single id\n\nBy default, Decode and DecodeLong will return an array. If you need to decode just one id you can use\nthe following helper functions:\n\n```C#\nvar hashids = new Hashids(\"this is my pepper\");\nnumber = hashids.DecodeSingle(\"NkK9\");\n```\n\n`number` is now going to be:\n\n    12345\n\n```C#\nvar hashids = new Hashids(\"this is my pepper\");\n\nif (hashids.TryDecodeSingle(\"NkK9\", out int number)) { // Decoding hash successfull. }\n```\n\n`number` is now going to be:\n\n    12345\n\nYou can handle the exception to see what went wrong with the decoding:\n\n```C#\nvar hashids = new Hashids(\"this is my pepper\");\ntry\n{\n    number = hashids.DecodeSingle(\"NkK9\");\n}\ncatch (NoResultException) { // Decoding the provided hash has not yielded any result. }\n```\n\n`number` is now going to be:\n\n    12345\n\n```C#\nvar hashids = new Hashids(\"this is my pepper\");\nnumber = hashids.DecodeSingleLong(\"KVO9yy1oO5j\");\n```\n\n`number` is now going to be:\n\n    666555444333222L\n\n```C#\nvar hashids = new Hashids(\"this is my pepper\");\n\nif (hashids.TryDecodeSingleLong(\"NkK9\", out long number)) { // Decoding hash successfull. }\n```\n\n`number` is now going to be:\n\n    666555444333222L\n\n```C#\nvar hashids = new Hashids(\"this is my pepper\");\ntry\n{\n    number = hashids.DecodeSingleLong(\"KVO9yy1oO5j\");\n}\ncatch (NoResultException) { // Decoding the provided hash has not yielded any result. }\n```\n\n`number` is now going to be:\n\n    666555444333222L\n\n### Decoding with different salt\n\nDecoding will not work if salt is changed:\n\n```C#\nvar hashids = new Hashids(\"this is my pepper\");\nnumbers = hashids.Decode(\"NkK9\");\n```\n\n`numbers` is now going to be:\n\n    []\n\n### Encoding several numbers\n\n```C#\nvar hashids = new Hashids(\"this is my salt\");\nvar hash = hashids.Encode(683, 94108, 123, 5);\n```\n\n`hash` is now going to be:\n\n    aBMswoO2UB3Sj\n\n### Decoding is done the same way\n\n```C#\nvar hashids = new Hashids(\"this is my salt\");\nvar numbers = hashids.Decode(\"aBMswoO2UB3Sj\")\n```\n\n`numbers` is now going to be:\n\n    [ 683, 94108, 123, 5 ]\n\n### Encoding and specifying minimum hash length\n\nHere we encode integer 1, and set the minimum hash length to **8** (by default it's **0** -- meaning hashes will be the shortest possible length).\n\n```C#\nvar hashids = new Hashids(\"this is my salt\", 8);\nvar hash = hashids.Encode(1);\n```\n\n`hash` is now going to be:\n\n    gB0NV05e\n\n### Decoding\n\n```C#\nvar hashids = new Hashids(\"this is my salt\", 8);\nvar numbers = hashids.Decode(\"gB0NV05e\");\n```\n\n`numbers` is now going to be:\n\n    [ 1 ]\n\n### Specifying custom hash alphabet\n\nHere we set the alphabet to consist of: \"abcdefghijkABCDEFGHIJK12345\"\n\n```C#\nvar hashids = new Hashids(\"this is my salt\", 0, \"abcdefghijkABCDEFGHIJK12345\")\nvar hash = hashids.Encode(1, 2, 3, 4, 5)\n```\n\n`hash` is now going to be:\n\n    Ec4iEHeF3\n\n## Randomness\n\nThe primary purpose of hashids is to obfuscate ids. It's not meant or tested to be used for security purposes or compression.\nHaving said that, this algorithm does try to make these hashes unguessable and unpredictable:\n\n### Repeating numbers\n\n```C#\nvar hashids = new Hashids(\"this is my salt\");\nvar hash = hashids.Encode(5, 5, 5, 5);\n```\n\nYou don't see any repeating patterns that might show there's 4 identical numbers in the hash:\n\n    1Wc8cwcE\n\nSame with incremented numbers:\n\n```C#\nvar hashids = new Hashids(\"this is my salt\");\nvar hash = hashids.Encode(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n```\n\n`hash` will be :\n\n    kRHnurhptKcjIDTWC3sx\n\n### Incrementing number hashes:\n\n```C#\nvar hashids = new Hashids(\"this is my salt\");\n\nhashids.Encode(1); // => NV\nhashids.Encode(2); // => 6m\nhashids.Encode(3); // => yD\nhashids.Encode(4); // => 2l\nhashids.Encode(5); // => rD\n```\n\n### Encoding using a HEX string\n\n```C#\nvar hashids = new Hashids(\"this is my salt\");\nvar hash = hashids.EncodeHex(\"DEADBEEF\");\n```\n\n`hash` is now going to be:\n\n    kRNrpKlJ\n\n### Decoding to a HEX string\n\n```C#\nvar hashids = new Hashids(\"this is my salt\");\nvar hex = hashids.DecodeHex(\"kRNrpKlJ\");\n```\n\n`hex` is now going to be:\n\n    DEADBEEF\n\n## Changelog\n\n**v.1.7.0**\n\n-   PR [#86](https://github.com/ullmark/hashids.net/pull/86) - Fix for decoding hash smaller than min length setting.\n-   Project build targets now set to `netstandard2.0`, `net6.0`, `net7.0`.\n\n**v.1.6.1**\n\n-   PR [#76](https://github.com/ullmark/hashids.net/pull/76) - Fix min buffer sizes.\n\n**v.1.6.0**\n\n-   PR [#66](https://github.com/ullmark/hashids.net/pull/66) - Fixed invalid constant bug.\n-   PR [#67](https://github.com/ullmark/hashids.net/pull/67) and PR [#73](https://github.com/ullmark/hashids.net/pull/73) - Update and cleanup tests and constants.\n-   PR [#65](https://github.com/ullmark/hashids.net/pull/65) - Improved performance and reduced allocations for single number decode.\n\n**v1.5.0**\n\n-   PR [#59](https://github.com/ullmark/hashids.net/pull/59) and PR [#61](https://github.com/ullmark/hashids.net/pull/61) - Project clean up and removal of `net461` target.\n-   PR [#50](https://github.com/ullmark/hashids.net/pull/50) - Added support for .NET 6.\n-   PR [#49](https://github.com/ullmark/hashids.net/pull/49) - Optimized methods for single number encoding.\n-   PR [#57](https://github.com/ullmark/hashids.net/pull/57) - Optimized methods for single number decoding.\n-   PR [#54](https://github.com/ullmark/hashids.net/pull/54) and [#58](https://github.com/ullmark/hashids.net/pull/58) - Fixed Github Actions build and test.\n-   PR [#55](https://github.com/ullmark/hashids.net/pull/55) - Removed System.Buffers dependency for .NET 5 and higher.\n-   PR [#47](https://github.com/ullmark/hashids.net/pull/47) - Improved performance with `readonly` and `Span<T>` usage.\n-   PR [#60](https://github.com/ullmark/hashids.net/pull/60) - Reference `System.Memory` to replace internal `ReadOnlySpan<T>` class.\n-   PR [#63](https://github.com/ullmark/hashids.net/pull/63) - Array and Span usage optimizations.\n-   PR [#62](https://github.com/ullmark/hashids.net/pull/62) - Documentation improvements.\n\n**1.4.1**\n\n-   PR [#45](https://github.com/ullmark/hashids.net/pull/45) - Cleanup unused nuget references and replace `Microsoft.Extensions.ObjectPool` with internal implementation.\n\n**1.4.0**\n\n-   Modernized project with updated build targets now set to `net461`, `net5.0`, `netstandard2.0`\n-   PR [#30](https://github.com/ullmark/hashids.net/pull/30) - Fix floating-point math to handle large ratio of alphabet to separators.\n-   PR [#37](https://github.com/ullmark/hashids.net/pull/37) - Performance and memory optimizations.\n-   PR [#42](https://github.com/ullmark/hashids.net/pull/42) - Performance updates and added BenchmarkDotnet for profiling.\n-   PR [#43](https://github.com/ullmark/hashids.net/pull/43) - Improved performance and reduced allocations.\n-   Issues [#23](https://github.com/ullmark/hashids.net/issues/23), [#32](https://github.com/ullmark/hashids.net/issues/32), [#35](https://github.com/ullmark/hashids.net/issues/35) - Fix floating-point math, now replaced by Horner's method.\n-   Issue [#27](https://github.com/ullmark/hashids.net/issues/27) - Allow dashes in alphabet (dashes caused issues with Regex which is not used anymore).\n-   Issue [#21](https://github.com/ullmark/hashids.net/issues/21) - Fix encoding exception when decoding a character used as guard.\n-   Issue [#29](https://github.com/ullmark/hashids.net/issues/29) - Added tests to confirm thread-safety.\n\n**1.3.0**\n\n-   PR [#26](https://github.com/ullmark/hashids.net/pull/26) - Support .netstandard2.0.\n\n**1.2.2**\n\n-   PR [#19](https://github.com/ullmark/hashids.net/pull/19) - Only instantiate the HEX-connected Regexes if we use any of the HEX functions. This will speed up creation of \"Hashids\"-instances. It\n    is likely that most users doesn't use the HEX-functions.\n\n**1.2.1**\n\n-   PR [#11](https://github.com/ullmark/hashids.net/pull/11) - Speed up consistent shuffle with less string manipulation.\n-   Issue [#15](https://github.com/ullmark/hashids.net/issues/15) - Decoding strings that contain characters not in the alphabet will now return empty array. (To conform to behaviour in the js-library).\n-   Issue [#18](https://github.com/ullmark/hashids.net/issues/18) - Encoding with a negative number will now return empty string. (To conform to behaviour in the js-library).\n\n**1.2.0**Added\n\n-   Added .NET Core support.\n\n**1.1.2**\n\n-   Fixed issue [#14](https://github.com/ullmark/hashids.net/issues/14) that caused HEX values to be encoded/decoded incorrectly.\n\n**1.1.1**\n\n-   Accepted PR [#12](https://github.com/ullmark/hashids.net/pull/12) that fixed an issue when encoding very many longs at the same time\n\n**1.1.0**\n\n-   Added support for `long` via _new_ functions to not introduce breaking changes.\n    -   `EncodeLong` for encodes.\n    -   `DecodeLong` for decodes.\n-   Added interface `IHashids` for people who want an interface to work with.\n\n**1.0.1**\n\n-   The .NET 4.0 version of the package used .NET 4.5 as build target. This was fixed and a new version was pushed to nuget.\n\n**1.0.0**\n\n-   Several public functions marked obsolete and renamed versions added, to be more appropriate:\n\n    -   Function `Encrypt()` changed to `Encode()`\n    -   Function `Decrypt()` changed to `Decode()`\n    -   Function `EncryptHex()` changed to `EncodeHex()`\n    -   Function `DecryptHex()` changed to `DecodeHex()`\n\n    Hashids was designed to encode integers, primary ids at most. We've had several requests to encrypt sensitive data with Hashids and this is the wrong algorithm for that. So to encourage more appropriate use, `encrypt/decrypt` is being \"downgraded\" to `encode/decode`.\n\n**0.3.4**\n\n-   The public functions are now virtual and therefor can be mocked with a mocking library.\n\n**0.3.3**\n\n-   Rewrote the code to support the new hashing algorithm.\n-   Support for `EncryptHex` and `DecryptHex`\n\n**0.1.4**\n\n-   Initial version of the port.\n\n[nuget]: https://www.nuget.org/packages/Hashids.net\n"
        },
        {
          "name": "benchmark.sh",
          "type": "blob",
          "size": 0.107421875,
          "content": "dotnet run --framework net6.0 --project .\\test\\Hashids.net.benchmark\\Hashids.net.benchmark.csproj -c Release \n"
        },
        {
          "name": "build.sh",
          "type": "blob",
          "size": 0.060546875,
          "content": "dotnet build\ndotnet clean\ndotnet test\ndotnet build -c Release\n"
        },
        {
          "name": "hashids.png",
          "type": "blob",
          "size": 13.1923828125,
          "content": null
        },
        {
          "name": "pack.sh",
          "type": "blob",
          "size": 0.0830078125,
          "content": "dotnet build\ndotnet test\ndotnet clean\ndotnet build -c Release\ndotnet pack -c Release\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}