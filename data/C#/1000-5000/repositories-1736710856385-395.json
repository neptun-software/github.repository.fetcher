{
  "metadata": {
    "timestamp": 1736710856385,
    "page": 395,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "netwrix/pingcastle",
      "stars": 2398,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 4.6494140625,
          "content": "PingCastle.xlsx\nResxManager-*\nADWS/wsdl\n\n## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n##\n## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore\n\n# User-specific files\n*.suo\n*.user\n*.userosscache\n*.sln.docstates\n\n# User-specific files (MonoDevelop/Xamarin Studio)\n*.userprefs\n\n# Build results\n[Dd]ebug/\n[Dd]ebugPublic/\n[Rr]elease/\n[Rr]eleases/\nx64/\nx86/\nbld/\n[Bb]in/\n[Oo]bj/\n[Ll]og/\n\n# Visual Studio 2015 cache/options directory\n.vs/\n# Uncomment if you have tasks that create the project's static files in wwwroot\n#wwwroot/\n\n# MSTest test Results\n[Tt]est[Rr]esult*/\n[Bb]uild[Ll]og.*\n\n# NUNIT\n*.VisualState.xml\nTestResult.xml\n\n# Build Results of an ATL Project\n[Dd]ebugPS/\n[Rr]eleasePS/\ndlldata.c\n\n# .NET Core\nproject.lock.json\nproject.fragment.lock.json\nartifacts/\n**/Properties/launchSettings.json\n\n*_i.c\n*_p.c\n*_i.h\n*.ilk\n*.meta\n*.obj\n*.pch\n*.pdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.tmp_proj\n*.log\n*.vspscc\n*.vssscc\n.builds\n*.pidb\n*.svclog\n*.scc\n\n# Chutzpah Test files\n_Chutzpah*\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opendb\n*.opensdf\n*.sdf\n*.cachefile\n*.VC.db\n*.VC.VC.opendb\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n*.sap\n\n# TFS 2012 Local Workspace\n$tf/\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*/\n*.[Rr]e[Ss]harper\n*.DotSettings.user\n\n# JustCode is a .NET coding add-in\n.JustCode\n\n# TeamCity is a build add-in\n_TeamCity*\n\n# DotCover is a Code Coverage Tool\n*.dotCover\n\n# Visual Studio code coverage results\n*.coverage\n*.coveragexml\n\n# NCrunch\n_NCrunch_*\n.*crunch*.local.xml\nnCrunchTemp_*\n\n# MightyMoose\n*.mm.*\nAutoTest.Net/\n\n# Web workbench (sass)\n.sass-cache/\n\n# Installshield output folder\n[Ee]xpress/\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish/\n\n# Publish Web Output\n*.[Pp]ublish.xml\n*.azurePubxml\n# TODO: Comment the next line if you want to checkin your web deploy settings\n# but database connection strings (with potential passwords) will be unencrypted\n*.pubxml\n*.publishproj\n\n# Microsoft Azure Web App publish settings. Comment the next line if you want to\n# checkin your Azure Web App publish settings, but sensitive information contained\n# in these scripts will be unencrypted\nPublishScripts/\n\n# NuGet Packages\n*.nupkg\n# The packages folder can be ignored because of Package Restore\n**/packages/*\n# except build/, which is used as an MSBuild target.\n!**/packages/build/\n# Uncomment if necessary however generally it will be regenerated when needed\n#!**/packages/repositories.config\n# NuGet v3's project.json files produces more ignorable files\n*.nuget.props\n*.nuget.targets\n\n# Microsoft Azure Build Output\ncsx/\n*.build.csdef\n\n# Microsoft Azure Emulator\necf/\nrcf/\n\n# Windows Store app package directories and files\nAppPackages/\nBundleArtifacts/\nPackage.StoreAssociation.xml\n_pkginfo.txt\n\n# Visual Studio cache files\n# files ending in .cache can be ignored\n*.[Cc]ache\n# but keep track of directories ending in .cache\n!*.[Cc]ache/\n\n# Others\nClientBin/\n~$*\n*~\n*.dbmdl\n*.dbproj.schemaview\n*.jfm\n*.pfx\n*.publishsettings\norleans.codegen.cs\n\n# Since there are multiple workflows, uncomment next line to ignore bower_components\n# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)\n#bower_components/\n\n# RIA/Silverlight projects\nGenerated_Code/\n\n# Backup & report files from converting an old project file\n# to a newer Visual Studio version. Backup files are not needed,\n# because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\nUpgradeLog*.htm\n\n# SQL Server files\n*.mdf\n*.ldf\n\n# Business Intelligence projects\n*.rdl.data\n*.bim.layout\n*.bim_*.settings\n\n# Microsoft Fakes\nFakesAssemblies/\n\n# GhostDoc plugin setting file\n*.GhostDoc.xml\n\n# Node.js Tools for Visual Studio\n.ntvs_analysis.dat\nnode_modules/\n\n# Typescript v1 declaration files\ntypings/\n\n# Visual Studio 6 build log\n*.plg\n\n# Visual Studio 6 workspace options file\n*.opt\n\n# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)\n*.vbw\n\n# Visual Studio LightSwitch build output\n**/*.HTMLClient/GeneratedArtifacts\n**/*.DesktopClient/GeneratedArtifacts\n**/*.DesktopClient/ModelManifest.xml\n**/*.Server/GeneratedArtifacts\n**/*.Server/ModelManifest.xml\n_Pvt_Extensions\n\n# Paket dependency manager\n.paket/paket.exe\npaket-files/\n\n# FAKE - F# Make\n.fake/\n\n# JetBrains Rider\n.idea/\n*.sln.iml\n\n# CodeRush\n.cr/\n\n# Python Tools for Visual Studio (PTVS)\n__pycache__/\n*.pyc\n\n# Cake - Uncomment if you are using it\n# tools/**\n# !tools/packages.config\n*.dll\n"
        },
        {
          "name": "ADWS",
          "type": "tree",
          "content": null
        },
        {
          "name": "Bot",
          "type": "tree",
          "content": null
        },
        {
          "name": "Cloud",
          "type": "tree",
          "content": null
        },
        {
          "name": "Compatibility.cs",
          "type": "blob",
          "size": 1.365234375,
          "content": "﻿//\n// Copyright (c) Ping Castle. All rights reserved.\n// https://www.pingcastle.com\n//\n// Licensed under the Non-Profit OSL. See LICENSE file in the project root for full license information.\n//\n\nnamespace System.Runtime.Serialization\n{\n    [AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Module, Inherited = false, AllowMultiple = true)]\n    internal sealed class ContractNamespaceAttribute : Attribute\n    {\n        private string clrNamespace;\n\n        private string contractNamespace;\n\n        public string ClrNamespace\n        {\n            get\n            {\n                return this.clrNamespace;\n            }\n            set\n            {\n                this.clrNamespace = value;\n            }\n        }\n\n        public string ContractNamespace\n        {\n            get\n            {\n                return this.contractNamespace;\n            }\n        }\n\n        public ContractNamespaceAttribute(string contractNamespace)\n        {\n            this.contractNamespace = contractNamespace;\n        }\n    }\n\n    // available in dotnet 3 but not on dotnet 2 which is needed for Windows 2000\n    [System.AttributeUsage(System.AttributeTargets.Field | System.AttributeTargets.Property, AllowMultiple = false, Inherited = false)]\n    internal sealed class IgnoreDataMemberAttribute : Attribute\n    {\n        public IgnoreDataMemberAttribute()\n        {\n        }\n    }\n}\n"
        },
        {
          "name": "ConsoleMenu.cs",
          "type": "blob",
          "size": 15.8330078125,
          "content": "﻿using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Reflection;\nusing System.Runtime.InteropServices;\n\nnamespace PingCastle\n{\n\n    public class ConsoleMenuItem\n    {\n        public string Choice { get; set; }\n        public string ShortDescription { get; set; }\n        public string LongDescription { get; set; }\n\n        public ConsoleMenuItem(string choice, string shortDescription)\n            : this(choice, shortDescription, null)\n        {\n        }\n\n        public ConsoleMenuItem(string choice, string shortDescription, string longDescription)\n        {\n            Choice = choice;\n            ShortDescription = shortDescription;\n            LongDescription = longDescription;\n        }\n    }\n\n    public class ConsoleMenu\n    {\n\n        public static string Header { get; set; }\n        public static string Title { get; set; }\n        public static string Notice { get; set; }\n        public static string Information { get; set; }\n\n        static void printSelectMenuStyle0(List<ConsoleMenuItem> items, int currentIndex, int top, int left)\n        {\n            bool hasDescription = false;\n            string description = null;\n            int largerChoice = 0;\n            int maxDescription = 0;\n            for (int i = 0; i < items.Count; i++)\n            {\n                if (!String.IsNullOrEmpty(items[i].ShortDescription))\n                    hasDescription = true;\n                int l = items[i].Choice.Length;\n                if (l > largerChoice)\n                    largerChoice = l;\n            }\n            Console.SetCursorPosition(left, top);\n            for (int i = 0; i < items.Count; i++)\n            {\n                if (i == currentIndex - 1)\n                {\n                    Console.BackgroundColor = ConsoleColor.Gray;\n                    Console.ForegroundColor = ConsoleColor.Black;\n                    description = items[i].LongDescription;\n                }\n                if (!String.IsNullOrEmpty(items[i].LongDescription) && maxDescription < items[i].LongDescription.Length)\n                    maxDescription = items[i].LongDescription.Length;\n                Console.Write(\"  \" + (char)(i < 9 ? i + '1' : i - 9 + 'a') + \"-\" + items[i].Choice);\n                if (hasDescription)\n                {\n                    int diff = largerChoice - items[i].Choice.Length;\n                    if (diff > 0)\n                        Console.Write(new String(' ', diff));\n                    if (!String.IsNullOrEmpty(items[i].ShortDescription))\n                        Console.Write(\"-\" + items[i].ShortDescription);\n                }\n                Console.WriteLine();\n                Console.ResetColor();\n            }\n            if (0 == currentIndex)\n            {\n                Console.BackgroundColor = ConsoleColor.Gray;\n                Console.ForegroundColor = ConsoleColor.Black;\n            }\n            Console.WriteLine(\"  0-Exit\");\n            Console.ResetColor();\n            if (!String.IsNullOrEmpty(description))\n            {\n                Console.ForegroundColor = ConsoleColor.Yellow;\n                Console.WriteLine(\"==============================\");\n                Console.ResetColor();\n                int currentLineCursor = Console.CursorTop;\n                Console.WriteLine(new string(' ', maxDescription));\n                Console.SetCursorPosition(0, currentLineCursor);\n                Console.WriteLine(description);\n            }\n            else\n            {\n                Console.WriteLine(new string(' ', Console.WindowWidth - 1));\n                Console.WriteLine(new string(' ', maxDescription));\n            }\n        }\n\n        static void printSelectMenuStyle1(List<ConsoleMenuItem> items, int currentIndex, int top, int left)\n        {\n            string description = null;\n            Console.SetCursorPosition(left, top);\n            string item;\n            int maxDescription = 0;\n            for (int i = 0; i < items.Count; i++)\n            {\n                if (i == currentIndex - 1)\n                {\n                    Console.BackgroundColor = ConsoleColor.Gray;\n                    Console.ForegroundColor = ConsoleColor.Black;\n                    description = items[i].ShortDescription;\n                }\n                if (!String.IsNullOrEmpty(items[i].ShortDescription) && maxDescription < items[i].ShortDescription.Length)\n                    maxDescription = items[i].ShortDescription.Length;\n\n                item = \"  \" + (char)(i < 9 ? i + '1' : i - 9 + 'a') + \"-\" + items[i].Choice;\n                Console.SetCursorPosition(left + (i < (items.Count + 1) / 2 ? 0 : Console.WindowWidth / 2), top + i + (i < (items.Count + 1) / 2 ? 0 : -(items.Count + 1) / 2));\n                Console.Write(item + new string(' ', Console.WindowWidth / 2 - item.Length - 1));\n                Console.ResetColor();\n            }\n            if (0 == currentIndex)\n            {\n                Console.BackgroundColor = ConsoleColor.Gray;\n                Console.ForegroundColor = ConsoleColor.Black;\n            }\n            Console.SetCursorPosition(left, top + (items.Count + 1) / 2);\n            item = \"  0-Exit\";\n            Console.WriteLine(item + new string(' ', Console.WindowWidth / 2 - item.Length - 1));\n            Console.ResetColor();\n            if (!String.IsNullOrEmpty(description))\n            {\n                Console.ForegroundColor = ConsoleColor.Yellow;\n                Console.WriteLine(\"==============================\");\n                Console.ResetColor();\n                int currentLineCursor = Console.CursorTop;\n                Console.WriteLine(new string(' ', maxDescription));\n                Console.SetCursorPosition(0, currentLineCursor);\n                Console.WriteLine(description);\n            }\n\n        }\n\n        protected static void DisplayHeader()\n        {\n            Console.Clear();\n            if (!String.IsNullOrEmpty(Header))\n            {\n                Console.WriteLine(Header);\n            }\n            if (!String.IsNullOrEmpty(Title))\n            {\n                Console.ForegroundColor = ConsoleColor.Yellow;\n                Console.WriteLine(Title);\n                Console.WriteLine(new string('=', Title.Length));\n                Console.ResetColor();\n            }\n            if (!String.IsNullOrEmpty(Information))\n            {\n                Console.WriteLine(Information);\n            }\n            if (!String.IsNullOrEmpty(Notice))\n            {\n                Console.ForegroundColor = ConsoleColor.Red;\n                Console.WriteLine(Notice);\n                Console.ResetColor();\n            }\n        }\n\n        private static void ClearTopic()\n        {\n            Information = null;\n            Notice = null;\n            Title = null;\n        }\n\n        public static string AskForString()\n        {\n            DisplayHeader();\n            ClearTopic();\n            return Console.ReadLine();\n        }\n\n        public static List<string> AskForListString()\n        {\n            DisplayHeader();\n            ClearTopic();\n            var list = new List<string>();\n            var line = Console.ReadLine();\n            while (!String.IsNullOrEmpty(line))\n            {\n                list.Add(line);\n                line = Console.ReadLine();\n            }\n            return list;\n        }\n\n        public static int SelectMenu(List<ConsoleMenuItem> items, int defaultIndex = 1)\n        {\n            DisplayHeader();\n            ClearTopic();\n            return SelectMenu(items, defaultIndex, 0);\n        }\n\n        public static int SelectMenuCompact(List<ConsoleMenuItem> items, int defaultIndex = 1)\n        {\n            DisplayHeader();\n            ClearTopic();\n            return SelectMenu(items, defaultIndex, 1);\n        }\n\n        protected static int SelectMenu(List<ConsoleMenuItem> items, int defaultIndex = 1, int style = 0)\n        {\n            int top = Console.CursorTop;\n            int left = Console.CursorLeft;\n            int index = defaultIndex;\n            Console.CursorVisible = false;\n            while (true)\n            {\n                switch (style)\n                {\n                    case 1:\n                        printSelectMenuStyle1(items, index, top, left);\n                        break;\n                    case 0:\n                    default:\n                        printSelectMenuStyle0(items, index, top, left);\n                        break;\n                }\n                ConsoleKeyInfo ckey = Console.ReadKey(true);\n\n                if (ckey.Key == ConsoleKey.Escape)\n                {\n                    Console.CursorVisible = true;\n                    Console.ResetColor();\n                    return 0;\n                }\n                if (ckey.Key == ConsoleKey.DownArrow)\n                {\n                    if (index == items.Count)\n                    {\n                        index = 0; // exit key\n                    }\n                    else if (style == 1 && index == (items.Count + 1) / 2)\n                    {\n                        index = 0; // exit key\n                    }\n                    else if (index == 0)\n                    {\n                    }\n                    else { index++; }\n                }\n                else if (ckey.Key == ConsoleKey.UpArrow)\n                {\n                    if (index == 1)\n                    {\n                    }\n                    else if (index == 0)\n                    {\n                        if (style == 1)\n                        {\n                            index = (items.Count + 1) / 2;\n                        }\n                        else\n                        {\n                            index = items.Count;\n                        }\n                    }\n                    else { index--; }\n                }\n                else if (ckey.Key == ConsoleKey.LeftArrow && style == 1)\n                {\n                    if (index >= (items.Count + 1) / 2)\n                    {\n                        index -= (items.Count + 1) / 2;\n                    }\n                }\n                else if (ckey.Key == ConsoleKey.RightArrow && style == 1)\n                {\n                    if (index <= (items.Count) / 2)\n                    {\n                        index += (items.Count + 1) / 2;\n                    }\n                }\n                else if (ckey.Key == ConsoleKey.Enter)\n                {\n                    Console.CursorVisible = true;\n                    Console.ResetColor();\n                    return index;\n                }\n                else\n                {\n                    int number;\n                    char key = ckey.KeyChar;\n                    if (Int32.TryParse(key.ToString(), out number) && number >= 0 && number <= 9 && (number <= items.Count))\n                    {\n                        Console.CursorVisible = true;\n                        Console.ResetColor();\n                        return number;\n                    }\n                    if (key >= 'a' && key <= 'z' && ((key - 'a' + 10) <= items.Count))\n                    {\n                        Console.CursorVisible = true;\n                        Console.ResetColor();\n                        return (key - 'a' + 10);\n                    }\n                    if (key >= 'A' && key <= 'Z' && ((key - 'A' + 10) <= items.Count))\n                    {\n                        Console.CursorVisible = true;\n                        Console.ResetColor();\n                        return (key - 'A' + 10);\n                    }\n                }\n            }\n        }\n\n        // http://msdn.microsoft.com/en-us/library/ms680313\n\n#pragma warning disable 0649\n        struct _IMAGE_FILE_HEADER\n        {\n            public ushort Machine;\n            public ushort NumberOfSections;\n            public uint TimeDateStamp;\n            public uint PointerToSymbolTable;\n            public uint NumberOfSymbols;\n            public ushort SizeOfOptionalHeader;\n            public ushort Characteristics;\n        };\n#pragma warning restore 0649\n\n        public static DateTime GetBuildDateTime(Assembly assembly)\n        {\n            var path = assembly.Location;\n            if (File.Exists(path))\n            {\n                var buffer = new byte[Marshal.SizeOf(typeof(_IMAGE_FILE_HEADER))];\n                using (var fileStream = new FileStream(path, FileMode.Open, FileAccess.Read))\n                {\n                    fileStream.Position = 0x3C;\n                    fileStream.Read(buffer, 0, 4);\n                    fileStream.Position = BitConverter.ToUInt32(buffer, 0); // COFF header offset\n                    fileStream.Read(buffer, 0, 4); // \"PE\\0\\0\"\n                    fileStream.Read(buffer, 0, buffer.Length);\n                }\n                var pinnedBuffer = GCHandle.Alloc(buffer, GCHandleType.Pinned);\n                try\n                {\n                    var coffHeader = (_IMAGE_FILE_HEADER)Marshal.PtrToStructure(pinnedBuffer.AddrOfPinnedObject(), typeof(_IMAGE_FILE_HEADER));\n\n                    return TimeZone.CurrentTimeZone.ToLocalTime(new DateTime(1970, 1, 1) + new TimeSpan(coffHeader.TimeDateStamp * TimeSpan.TicksPerSecond));\n                }\n                finally\n                {\n                    pinnedBuffer.Free();\n                }\n            }\n            return new DateTime();\n        }\n\n        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n        public class WinTrustFileInfo\n        {\n            public UInt32 StructSize = (UInt32)Marshal.SizeOf(typeof(WinTrustFileInfo));\n            public IntPtr pszFilePath;\n            public IntPtr hFile = IntPtr.Zero;\n            public IntPtr pgKnownSubject = IntPtr.Zero;\n        }\n\n        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n        public class WinTrustData\n        {\n            public UInt32 StructSize = (UInt32)Marshal.SizeOf(typeof(WinTrustData));\n            public IntPtr PolicyCallbackData = IntPtr.Zero;\n            public IntPtr SIPClientData = IntPtr.Zero;\n            public UInt32 UIChoice = 2;\n            public UInt32 RevocationChecks = 0;\n            public UInt32 UnionChoice = 1;\n            public IntPtr FileInfoPtr;\n            public UInt32 StateAction = 0;\n            public IntPtr StateData = IntPtr.Zero;\n            public String URLReference = null;\n            public UInt32 ProvFlags = 0x00000010;\n            public UInt32 UIContext = 0;\n        }\n\n        public class WinTrust\n        {\n            [DllImport(\"wintrust.dll\", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]\n            public static extern uint WinVerifyTrust(IntPtr hwnd, [MarshalAs(UnmanagedType.LPStruct)] Guid pgActionID, [MarshalAs(UnmanagedType.LPStruct)] WinTrustData pWVTData);\n\n            public static Guid WINTRUST_ACTION_GENERIC_VERIFY_V2 = new Guid(\"00AAC56B-CD44-11d0-8CC2-00C04FC295EE\");\n        }\n\n        public static uint CheckWinTrustFlags(Assembly assembly)\n        {\n            var path = assembly.Location;\n            if (string.IsNullOrEmpty(path))\n            {\n                System.Diagnostics.Trace.WriteLine(\"In memory location detected\");\n                return 0x80070002;\n            }\n            else if (File.Exists(path))\n            {\n                return CheckWinTrustFlags(path);\n            }\n            return 0;\n        }\n\n        public static uint CheckWinTrustFlags(string filePath)\n        {\n            WinTrustFileInfo fileInfo = new WinTrustFileInfo\n            {\n                pszFilePath = Marshal.StringToCoTaskMemAuto(filePath)\n            };\n\n            WinTrustData trustData = new WinTrustData\n            {\n                FileInfoPtr = Marshal.AllocCoTaskMem(Marshal.SizeOf(typeof(WinTrustFileInfo))),\n                RevocationChecks = 0,\n            };\n            Marshal.StructureToPtr(fileInfo, trustData.FileInfoPtr, false);\n\n            uint result = WinTrust.WinVerifyTrust(IntPtr.Subtract(IntPtr.Zero, 1), WinTrust.WINTRUST_ACTION_GENERIC_VERIFY_V2, trustData);\n\n            Marshal.FreeCoTaskMem(fileInfo.pszFilePath);\n            Marshal.FreeCoTaskMem(trustData.FileInfoPtr);\n\n            return result;\n        }\n    }\n}\n"
        },
        {
          "name": "Data",
          "type": "tree",
          "content": null
        },
        {
          "name": "Exports",
          "type": "tree",
          "content": null
        },
        {
          "name": "FodyWeavers.xml",
          "type": "blob",
          "size": 0.2177734375,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Weavers xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"FodyWeavers.xsd\">\n    <Costura>\n        <ExcludeAssemblies />\n    </Costura>\n</Weavers>"
        },
        {
          "name": "FodyWeavers.xsd",
          "type": "blob",
          "size": 8.46484375,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">\n  <!-- This file was generated by Fody. Manual changes to this file will be lost when your project is rebuilt. -->\n  <xs:element name=\"Weavers\">\n    <xs:complexType>\n      <xs:all>\n        <xs:element name=\"Costura\" minOccurs=\"0\" maxOccurs=\"1\">\n          <xs:complexType>\n            <xs:all>\n              <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"ExcludeAssemblies\" type=\"xs:string\">\n                <xs:annotation>\n                  <xs:documentation>A list of assembly names to exclude from the default action of \"embed all Copy Local references\", delimited with line breaks</xs:documentation>\n                </xs:annotation>\n              </xs:element>\n              <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"IncludeAssemblies\" type=\"xs:string\">\n                <xs:annotation>\n                  <xs:documentation>A list of assembly names to include from the default action of \"embed all Copy Local references\", delimited with line breaks.</xs:documentation>\n                </xs:annotation>\n              </xs:element>\n              <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"ExcludeRuntimeAssemblies\" type=\"xs:string\">\n                <xs:annotation>\n                  <xs:documentation>A list of runtime assembly names to exclude from the default action of \"embed all Copy Local references\", delimited with line breaks</xs:documentation>\n                </xs:annotation>\n              </xs:element>\n              <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"IncludeRuntimeAssemblies\" type=\"xs:string\">\n                <xs:annotation>\n                  <xs:documentation>A list of runtime assembly names to include from the default action of \"embed all Copy Local references\", delimited with line breaks.</xs:documentation>\n                </xs:annotation>\n              </xs:element>\n              <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"Unmanaged32Assemblies\" type=\"xs:string\">\n                <xs:annotation>\n                  <xs:documentation>A list of unmanaged 32 bit assembly names to include, delimited with line breaks.</xs:documentation>\n                </xs:annotation>\n              </xs:element>\n              <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"Unmanaged64Assemblies\" type=\"xs:string\">\n                <xs:annotation>\n                  <xs:documentation>A list of unmanaged 64 bit assembly names to include, delimited with line breaks.</xs:documentation>\n                </xs:annotation>\n              </xs:element>\n              <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"PreloadOrder\" type=\"xs:string\">\n                <xs:annotation>\n                  <xs:documentation>The order of preloaded assemblies, delimited with line breaks.</xs:documentation>\n                </xs:annotation>\n              </xs:element>\n            </xs:all>\n            <xs:attribute name=\"CreateTemporaryAssemblies\" type=\"xs:boolean\">\n              <xs:annotation>\n                <xs:documentation>This will copy embedded files to disk before loading them into memory. This is helpful for some scenarios that expected an assembly to be loaded from a physical file.</xs:documentation>\n              </xs:annotation>\n            </xs:attribute>\n            <xs:attribute name=\"IncludeDebugSymbols\" type=\"xs:boolean\">\n              <xs:annotation>\n                <xs:documentation>Controls if .pdbs for reference assemblies are also embedded.</xs:documentation>\n              </xs:annotation>\n            </xs:attribute>\n            <xs:attribute name=\"IncludeRuntimeReferences\" type=\"xs:boolean\">\n              <xs:annotation>\n                <xs:documentation>Controls if runtime assemblies are also embedded.</xs:documentation>\n              </xs:annotation>\n            </xs:attribute>\n            <xs:attribute name=\"UseRuntimeReferencePaths\" type=\"xs:boolean\">\n              <xs:annotation>\n                <xs:documentation>Controls whether the runtime assemblies are embedded with their full path or only with their assembly name.</xs:documentation>\n              </xs:annotation>\n            </xs:attribute>\n            <xs:attribute name=\"DisableCompression\" type=\"xs:boolean\">\n              <xs:annotation>\n                <xs:documentation>Embedded assemblies are compressed by default, and uncompressed when they are loaded. You can turn compression off with this option.</xs:documentation>\n              </xs:annotation>\n            </xs:attribute>\n            <xs:attribute name=\"DisableCleanup\" type=\"xs:boolean\">\n              <xs:annotation>\n                <xs:documentation>As part of Costura, embedded assemblies are no longer included as part of the build. This cleanup can be turned off.</xs:documentation>\n              </xs:annotation>\n            </xs:attribute>\n            <xs:attribute name=\"LoadAtModuleInit\" type=\"xs:boolean\">\n              <xs:annotation>\n                <xs:documentation>Costura by default will load as part of the module initialization. This flag disables that behavior. Make sure you call CosturaUtility.Initialize() somewhere in your code.</xs:documentation>\n              </xs:annotation>\n            </xs:attribute>\n            <xs:attribute name=\"IgnoreSatelliteAssemblies\" type=\"xs:boolean\">\n              <xs:annotation>\n                <xs:documentation>Costura will by default use assemblies with a name like 'resources.dll' as a satellite resource and prepend the output path. This flag disables that behavior.</xs:documentation>\n              </xs:annotation>\n            </xs:attribute>\n            <xs:attribute name=\"ExcludeAssemblies\" type=\"xs:string\">\n              <xs:annotation>\n                <xs:documentation>A list of assembly names to exclude from the default action of \"embed all Copy Local references\", delimited with |</xs:documentation>\n              </xs:annotation>\n            </xs:attribute>\n            <xs:attribute name=\"IncludeAssemblies\" type=\"xs:string\">\n              <xs:annotation>\n                <xs:documentation>A list of assembly names to include from the default action of \"embed all Copy Local references\", delimited with |.</xs:documentation>\n              </xs:annotation>\n            </xs:attribute>\n            <xs:attribute name=\"ExcludeRuntimeAssemblies\" type=\"xs:string\">\n              <xs:annotation>\n                <xs:documentation>A list of runtime assembly names to exclude from the default action of \"embed all Copy Local references\", delimited with |</xs:documentation>\n              </xs:annotation>\n            </xs:attribute>\n            <xs:attribute name=\"IncludeRuntimeAssemblies\" type=\"xs:string\">\n              <xs:annotation>\n                <xs:documentation>A list of runtime assembly names to include from the default action of \"embed all Copy Local references\", delimited with |.</xs:documentation>\n              </xs:annotation>\n            </xs:attribute>\n            <xs:attribute name=\"Unmanaged32Assemblies\" type=\"xs:string\">\n              <xs:annotation>\n                <xs:documentation>A list of unmanaged 32 bit assembly names to include, delimited with |.</xs:documentation>\n              </xs:annotation>\n            </xs:attribute>\n            <xs:attribute name=\"Unmanaged64Assemblies\" type=\"xs:string\">\n              <xs:annotation>\n                <xs:documentation>A list of unmanaged 64 bit assembly names to include, delimited with |.</xs:documentation>\n              </xs:annotation>\n            </xs:attribute>\n            <xs:attribute name=\"PreloadOrder\" type=\"xs:string\">\n              <xs:annotation>\n                <xs:documentation>The order of preloaded assemblies, delimited with |.</xs:documentation>\n              </xs:annotation>\n            </xs:attribute>\n          </xs:complexType>\n        </xs:element>\n      </xs:all>\n      <xs:attribute name=\"VerifyAssembly\" type=\"xs:boolean\">\n        <xs:annotation>\n          <xs:documentation>'true' to run assembly verification (PEVerify) on the target assembly after all weavers have been executed.</xs:documentation>\n        </xs:annotation>\n      </xs:attribute>\n      <xs:attribute name=\"VerifyIgnoreCodes\" type=\"xs:string\">\n        <xs:annotation>\n          <xs:documentation>A comma-separated list of error codes that can be safely ignored in assembly verification.</xs:documentation>\n        </xs:annotation>\n      </xs:attribute>\n      <xs:attribute name=\"GenerateXsd\" type=\"xs:boolean\">\n        <xs:annotation>\n          <xs:documentation>'false' to turn off automatic generation of the XML Schema file.</xs:documentation>\n        </xs:annotation>\n      </xs:attribute>\n    </xs:complexType>\n  </xs:element>\n</xs:schema>"
        },
        {
          "name": "Graph",
          "type": "tree",
          "content": null
        },
        {
          "name": "Healthcheck",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 11.505859375,
          "content": "Full License Text\n\nNon-Profit Open Software License (\"Non-Profit OSL\") 3.0\n\nThis Non-Profit Open Software License (\"Non-Profit OSL\") version 3.0 (the \"License\") applies to any original work of authorship (the \"Original Work\") whose owner (the \"Licensor\") has placed the following licensing notice adjacent to the copyright notice for the Original Work:\n\nLicensed under the Non-Profit Open Software License version 3.0\n\n1) Grant of Copyright License. Licensor grants You a worldwide, royalty-free, non-exclusive, sublicensable license, for the duration of the copyright, to do the following:\n\na) to reproduce the Original Work in copies, either alone or as part of a collective work;\n\nb) to translate, adapt, alter, transform, modify, or arrange the Original Work, thereby creating derivative works (\"Derivative Works\") based upon the Original Work;\n\nc) to distribute or communicate copies of the Original Work and Derivative Works to the public, with the proviso that copies of Original Work or Derivative Works that You distribute or communicate shall be licensed under this Non-Profit Open Software License or as provided in section 17(d);\n\nd) to perform the Original Work publicly; and\n\ne) to display the Original Work publicly.\n\n2) Grant of Patent License. Licensor grants You a worldwide, royalty-free, non-exclusive, sublicensable license, under patent claims owned or controlled by the Licensor that are embodied in the Original Work as furnished by the Licensor, for the duration of the patents, to make, use, sell, offer for sale, have made, and import the Original Work and Derivative Works.\n\n3) Grant of Source Code License. The term \"Source Code\" means the preferred form of the Original Work for making modifications to it and all available documentation describing how to modify the Original Work. Licensor agrees to provide a machine-readable copy of the Source Code of the Original Work along with each copy of the Original Work that Licensor distributes. Licensor reserves the right to satisfy this obligation by placing a machine-readable copy of the Source Code in an information repository reasonably calculated to permit inexpensive and convenient access by You for as long as Licensor continues to distribute the Original Work.\n\n4) Exclusions From License Grant. Neither the names of Licensor, nor the names of any contributors to the Original Work, nor any of their trademarks or service marks, may be used to endorse or promote products derived from this Original Work without express prior permission of the Licensor. Except as expressly stated herein, nothing in this License grants any license to Licensor's trademarks, copyrights, patents, trade secrets or any other intellectual property. No patent license is granted to make, use, sell, offer for sale, have made, or import embodiments of any patent claims other than the licensed claims defined in Section 2. No license is granted to the trademarks of Licensor even if such marks are included in the Original Work. Nothing in this License shall be interpreted to prohibit Licensor from licensing under terms different from this License any Original Work that Licensor otherwise would have a right to license.\n\n5) External Deployment. The term \"External Deployment\" means the use, distribution, or communication of the Original Work or Derivative Works in any way such that the Original Work or Derivative Works may be used by anyone other than You, whether those works are distributed or communicated to those persons or made available as an application intended for use over a network. As an express condition for the grants of license hereunder, You must treat any External Deployment by You of the Original Work or a Derivative Work as a distribution under section 1(c).\n\n6) Attribution Rights. You must retain, in the Source Code of any Derivative Works that You create, all copyright, patent, or trademark notices from the Source Code of the Original Work, as well as any notices of licensing and any descriptive text identified therein as an \"Attribution Notice.\" You must cause the Source Code for any Derivative Works that You create to carry a prominent Attribution Notice reasonably calculated to inform recipients that You have modified the Original Work.\n\n7) Warranty of Provenance and Disclaimer of Warranty. The Original Work is provided under this License on an \"AS IS\" BASIS and WITHOUT WARRANTY, either express or implied, including, without limitation, the warranties of non-infringement, merchantability or fitness for a particular purpose. THE ENTIRE RISK AS TO THE QUALITY OF THE ORIGINAL WORK IS WITH YOU. This DISCLAIMER OF WARRANTY constitutes an essential part of this License. No license to the Original Work is granted by this License except under this disclaimer.\n\n8) Limitation of Liability. Under no circumstances and under no legal theory, whether in tort (including negligence), contract, or otherwise, shall the Licensor be liable to anyone for any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or the use of the Original Work including, without limitation, damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses. This limitation of liability shall not apply to the extent applicable law prohibits such limitation.\n\n9) Acceptance and Termination. If, at any time, You expressly assented to this License, that assent indicates your clear and irrevocable acceptance of this License and all of its terms and conditions. If You distribute or communicate copies of the Original Work or a Derivative Work, You must make a reasonable effort under the circumstances to obtain the express assent of recipients to the terms of this License. This License conditions your rights to undertake the activities listed in Section 1, including your right to create Derivative Works based upon the Original Work, and doing so without honoring these terms and conditions is prohibited by copyright law and international treaty. Nothing in this License is intended to affect copyright exceptions and limitations (including \"fair use\" or \"fair dealing\"). This License shall terminate immediately and You may no longer exercise any of the rights granted to You by this License upon your failure to honor the conditions in Section 1(c).\n\n10) Termination for Patent Action. This License shall terminate automatically and You may no longer exercise any of the rights granted to You by this License as of the date You commence an action, including a cross-claim or counterclaim, against Licensor or any licensee alleging that the Original Work infringes a patent. This termination provision shall not apply for an action alleging patent infringement by combinations of the Original Work with other software or hardware.\n\n11) Jurisdiction, Venue and Governing Law. Any action or suit relating to this License may be brought only in the courts of a jurisdiction wherein the Licensor resides or in which Licensor conducts its primary business, and under the laws of that jurisdiction excluding its conflict-of-law provisions. The application of the United Nations Convention on Contracts for the International Sale of Goods is expressly excluded. Any use of the Original Work outside the scope of this License or after its termination shall be subject to the requirements and penalties of copyright or patent law in the appropriate jurisdiction. This section shall survive the termination of this License.\n\n12) Attorneys' Fees. In any action to enforce the terms of this License or seeking damages relating thereto, the prevailing party shall be entitled to recover its costs and expenses, including, without limitation, reasonable attorneys' fees and costs incurred in connection with such action, including any appeal of such action. This section shall survive the termination of this License.\n\n13) Miscellaneous. If any provision of this License is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable.\n\n14) Definition of \"You\" in This License. \"You\" throughout this License, whether in upper or lower case, means an individual or a legal entity exercising rights under, and complying with all of the terms of, this License. For legal entities, \"You\" includes any entity that controls, is controlled by, or is under common control with you. For purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.\n\n15) Right to Use. You may use the Original Work in all ways not otherwise restricted or conditioned by this License or by law, and Licensor promises not to interfere with or be responsible for such uses by You.\n\n16) Modification of This License. This License is Copyright © 2005 Lawrence Rosen. Permission is granted to copy, distribute, or communicate this License without modification. Nothing in this License permits You to modify this License as applied to the Original Work or to Derivative Works. However, You may modify the text of this License and copy, distribute or communicate your modified version (the \"Modified License\") and apply it to other original works of authorship subject to the following conditions: (i) You may not indicate in any way that your Modified License is the \"Open Software License\" or \"OSL\" and you may not use those names in the name of your Modified License; (ii) You must replace the notice specified in the first paragraph above with the notice \"Licensed under <insert your license name here>\" or with a notice of your own that is not confusingly similar to the notice in this License; and (iii) You may not claim that your original works are open source software unless your Modified License has been approved by Open Source Initiative (OSI) and You comply with its license review and certification process.\n\n17) Non-Profit Amendment. The name of this amended version of the Open Software License (\"OSL 3.0\") is \"Non-Profit Open Software License 3.0\". The original OSL 3.0 license has been amended as follows:\n\n(a) Licensor represents and declares that it is a not-for-profit organization that derives no revenue whatsoever from the distribution of the Original Work or Derivative Works thereof, or from support or services relating thereto.\n\n(b) The first sentence of Section 7 [\"Warranty of Provenance\"] of OSL 3.0 has been stricken. For Original Works licensed under this Non-Profit OSL 3.0, LICENSOR OFFERS NO WARRANTIES WHATSOEVER.\n\n(c) In the first sentence of Section 8 [\"Limitation of Liability\"] of this Non-Profit OSL 3.0, the list of damages for which LIABILITY IS LIMITED now includes \"direct\" damages.\n\n(d) The proviso in Section 1(c) of this License now refers to this \"Non-Profit Open Software License\" rather than the \"Open Software License\". You may distribute or communicate the Original Work or Derivative Works thereof under this Non-Profit OSL 3.0 license only if You make the representation and declaration in paragraph (a) of this Section 17. Otherwise, You shall distribute or communicate the Original Work or Derivative Works thereof only under the OSL 3.0 license and You shall publish clear licensing notices so stating. Also by way of clarification, this License does not authorize You to distribute or communicate works under this Non-Profit OSL 3.0 if You received them under the original OSL 3.0 license.\n\n(e) Original Works licensed under this license shall reference \"Non-Profit OSL 3.0\" in licensing notices to distinguish them from works licensed under the original OSL 3.0 license.\n"
        },
        {
          "name": "License.cs",
          "type": "blob",
          "size": 11.0185546875,
          "content": "﻿//\n// Copyright (c) Ping Castle. All rights reserved.\n// https://www.pingcastle.com\n//\n// Licensed under the Non-Profit OSL. See LICENSE file in the project root for full license information.\n//\nusing System;\nusing System.ComponentModel;\nusing System.Configuration;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Security.Cryptography;\nusing System.Text;\n\nnamespace ADSecurityHealthCheck\n{\n    internal class ADHealthCheckingLicenseSettings : PingCastle.ADHealthCheckingLicenseSettings\n    {\n    }\n}\n\nnamespace PingCastle\n{\n\n    public interface IPingCastleLicenseInfo\n    {\n        string GetSerialNumber();\n    }\n\n    public class ADHealthCheckingLicenseProvider : LicenseProvider\n    {\n\n        #region Public Methods\n\n        /// <summary>\n        /// Gets a license for an instance or type of component.\n        /// </summary>\n        /// <param name=\"context\">A <see cref=\"LicenseContext\"/> that specifies where you can use the licensed object.</param>\n        /// <param name=\"type\">A <see cref=\"System.Type\"/> that represents the component requesting the license.</param>\n        /// <param name=\"instance\">An object that is requesting the license.</param>\n        /// <param name=\"allowExceptions\">true if a <see cref=\"LicenseException\"/> should be thrown when the component cannot be granted a license; otherwise, false.</param>\n        /// <returns>A valid <see cref=\"License\"/>.</returns>\n        public override License GetLicense(LicenseContext context, Type type, object instance, bool allowExceptions)\n        {\n            IPingCastleLicenseInfo licenseInfo = (IPingCastleLicenseInfo)instance;\n            return new ADHealthCheckingLicense(licenseInfo.GetSerialNumber());\n        }\n        #endregion\n\n    }\n\n    internal class ADHealthCheckingLicenseSettings : ConfigurationSection\n    {\n        private static ADHealthCheckingLicenseSettings settings;\n\n        public static ADHealthCheckingLicenseSettings Settings\n        {\n            get\n            {\n                if (settings == null)\n                    settings = ConfigurationManager.GetSection(\"LicenseSettings\") as ADHealthCheckingLicenseSettings;\n                return settings;\n            }\n        }\n\n        [ConfigurationProperty(\"license\", IsRequired = false)]\n        public string License\n        {\n            get { return (string)this[\"license\"]; }\n            set { this[\"license\"] = value; }\n        }\n    }\n\n    public class ADHealthCheckingLicense : License, IDisposable\n    {\n        private bool _disposed = false;\n        private string _licKey = null;\n\n        public ADHealthCheckingLicense(string license)\n            : this(license, true)\n        {\n\n        }\n\n        public ADHealthCheckingLicense(string license, bool DoAKeyCheck)\n        {\n            if (String.IsNullOrEmpty(license))\n                throw new PingCastleException(\"No PingCastle license has been provided\");\n            _licKey = license;\n            Trace.WriteLine(\"License: \" + _licKey);\n            if (!VerifyKey())\n            {\n                throw new PingCastleException(\"The PingCastle license is not valid\");\n            }\n        }\n\n        #region Properties\n\n        public DateTime EndTime { get; set; }\n        public string DomainLimitation { get; set; }\n        public string CustomerNotice { get; set; }\n        public string Edition { get; set; }\n        public int? DomainNumberLimit { get; set; }\n\n        /// <summary>\n        /// Gets the license key granted to this component.\n        /// </summary>\n        public override string LicenseKey\n        {\n            get { return _licKey; }\n        }\n\n        #endregion\n\n        private bool VerifyKey()\n        {\n#if DEBUG\n            if (_licKey.Equals(\"debug\", StringComparison.InvariantCultureIgnoreCase))\n            {\n                EndTime = DateTime.MaxValue;\n                DomainLimitation = null;\n                CustomerNotice = \"debug version\";\n                return true;\n            }\n#endif\n            try\n            {\n                Trace.WriteLine(\"starting the license analysis\");\n\n                Trace.WriteLine(\"License info uncompressed\");\n                if (_licKey != null && _licKey.StartsWith(\"PC2\"))\n                {\n                    VerifyLicenseV2();\n                }\n                else\n                {\n                    VerifyLicenseV1();\n                }\n                return true;\n            }\n            catch (Exception ex)\n            {\n                Trace.Write(\"License: exception \" + ex.Message);\n                return false;\n            }\n        }\n\n        private void VerifyLicenseV2()\n        {\n            byte[] b = Convert.FromBase64String(_licKey.Substring(3));\n            using (MemoryStream ms = new MemoryStream(b))\n            {\n                using (GZipStream gs = new GZipStream(ms, CompressionMode.Decompress))\n                {\n                    using (var ms2 = new MemoryStream())\n                    {\n                        while (true)\n                        {\n                            int infoType = readint(gs);\n                            int infoLength = readint(gs);\n                            byte[] data = new byte[infoLength];\n                            gs.Read(data, 0, data.Length);\n                            Trace.WriteLine(\"data Type = \" + infoType);\n                            switch (infoType)\n                            {\n                                case 0:\n                                    Trace.WriteLine(\"Signature\");\n                                    VerifySignature(data, ms2.ToArray());\n                                    if (Edition == \"Pro\" && DomainNumberLimit == null)\n                                        DomainNumberLimit = 1;\n                                    return;\n                                case 1:\n                                    Trace.WriteLine(\"EndTime\");\n                                    EndTime = DateTime.FromFileTimeUtc(BitConverter.ToInt64(data, 0));\n                                    break;\n                                case 2:\n                                    Trace.WriteLine(\"DomainLimitation\");\n                                    DomainLimitation = Encoding.Unicode.GetString(data);\n                                    break;\n                                case 3:\n                                    Trace.WriteLine(\"CustomerNotice\");\n                                    CustomerNotice = Encoding.Unicode.GetString(data);\n                                    break;\n                                case 4:\n                                    Trace.WriteLine(\"Edition\");\n                                    Edition = Encoding.Unicode.GetString(data);\n                                    break;\n                                case 5:\n                                    DomainNumberLimit = BitConverter.ToInt32(data, 0);\n                                    break;\n                            }\n                            ms2.Write(BitConverter.GetBytes(infoType), 0, 4);\n                            ms2.Write(BitConverter.GetBytes(data.Length), 0, 4);\n                            ms2.Write(data, 0, data.Length);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        private void VerifyLicenseV1()\n        {\n            byte[] b = Convert.FromBase64String(_licKey);\n\n            MemoryStream ms = new MemoryStream();\n            ms.Write(b, 0, b.Length);\n            ms.Position = 0;\n            byte[] date = new byte[readint(ms)];\n            byte[] limitation = new byte[readint(ms)];\n            byte[] notice = new byte[readint(ms)];\n            byte[] signature = new byte[readint(ms)];\n            Trace.WriteLine(\"reading date\");\n            ms.Read(date, 0, date.Length);\n            Trace.WriteLine(\"reading limitation\");\n            ms.Read(limitation, 0, limitation.Length);\n            Trace.WriteLine(\"reading notice\");\n            ms.Read(notice, 0, notice.Length);\n            Trace.WriteLine(\"reading signature\");\n            ms.Read(signature, 0, signature.Length);\n            Trace.WriteLine(\"reading done\");\n            byte[] bytes = new byte[date.Length + limitation.Length + notice.Length];\n\n            Array.Copy(date, 0, bytes, 0, date.Length);\n            Array.Copy(limitation, 0, bytes, date.Length, limitation.Length);\n            Array.Copy(notice, 0, bytes, limitation.Length + date.Length, notice.Length);\n\n            VerifySignature(signature, bytes);\n\n            EndTime = DateTime.FromFileTimeUtc(BitConverter.ToInt64(date, 0));\n            Trace.WriteLine(\"Endtime=\" + EndTime);\n            DomainLimitation = Encoding.Unicode.GetString(limitation);\n            Trace.WriteLine(\"DomainLimitation=\" + DomainLimitation);\n            CustomerNotice = Encoding.Unicode.GetString(notice);\n            Trace.WriteLine(\"CustomerNotice=\" + CustomerNotice);\n            Trace.WriteLine(\"license verified\");\n        }\n\n        private void VerifySignature(byte[] signature, byte[] dataToVerify)\n        {\n            Trace.WriteLine(\"hashing license info\");\n            using (SHA1 hashstring = SHA1.Create())\n            {\n                byte[] hash = hashstring.ComputeHash(dataToVerify);\n                Trace.WriteLine(\"hashing done\");\n                Trace.WriteLine(\"loading rsa key\");\n                using (RSACryptoServiceProvider RSA = LoadRSAKey())\n                {\n                    Trace.WriteLine(\"loading rsa key\");\n                    Trace.WriteLine(\"verifying the signature\");\n                    if (!RSA.VerifyHash(hash, \"1.3.14.3.2.26\", signature))\n                    {\n                        throw new Exception(\"Invalid signature\");\n                    }\n                    Trace.WriteLine(\"signature ok\");\n                }\n            }\n        }\n\n        private RSACryptoServiceProvider LoadRSAKey()\n        {\n            RSACryptoServiceProvider RSA = new RSACryptoServiceProvider();\n            RSAParameters parameters = new RSAParameters();\n            parameters.Modulus = Convert.FromBase64String(\"wNtlwFv+zo0lrShHnSi5VLT6Sbfx3ZXhtefSJfYs3YjWyPHv3ihLjXlBjMlGI5ziXrjcriNNZ5zn2P2qvv3VdX02zsIuGuAYZi0c4WBhiqtKgTo7USxsAaGxpqiWTkW3NQylw27p3jqICO7cbLXsr3aEZJJUgqkNay/l4S3pYIs=\");\n            parameters.Exponent = Convert.FromBase64String(\"AQAB\");\n            RSA.ImportParameters(parameters);\n            return RSA;\n        }\n\n        int readint(Stream stream)\n        {\n            byte[] temp = new byte[4];\n            stream.Read(temp, 0, 4);\n            int size = BitConverter.ToInt32(temp, 0);\n            return size;\n        }\n\n        /// <summary>\n        /// Disposes this object.\n        /// </summary>\n        public sealed override void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n\n        /// <summary>\n        /// Disposes this object.\n        /// </summary>\n        /// <param name=\"disposing\">true if the object is disposing.</param>\n        protected virtual void Dispose(bool disposing)\n        {\n            if (disposing)\n            {\n                if (!_disposed)\n                {\n                    //Custom disposing here.\n                }\n                _disposed = true;\n            }\n        }\n\n    }\n}\n"
        },
        {
          "name": "NativeMethods.cs",
          "type": "blob",
          "size": 19.5615234375,
          "content": "﻿//\n// Copyright (c) Ping Castle. All rights reserved.\n// https://www.pingcastle.com\n//\n// Licensed under the Non-Profit OSL. See LICENSE file in the project root for full license information.\n//\nusing System;\nusing System.ComponentModel;\nusing System.Diagnostics;\nusing System.Net;\nusing System.Runtime.InteropServices;\nusing System.Security.Permissions;\nusing System.Security.Principal;\nusing System.Text;\n\nnamespace PingCastle\n{\n    public class NativeMethods\n    {\n        #region PInvoke Signatures\n\n        [DllImport(\"advapi32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\n        static extern bool LookupAccountSid(\n            string lpSystemName,\n            [MarshalAs(UnmanagedType.LPArray)] byte[] Sid,\n            System.Text.StringBuilder lpName,\n            ref uint cchName,\n            System.Text.StringBuilder ReferencedDomainName,\n            ref uint cchReferencedDomainName,\n            out SID_NAME_USE peUse);\n\n        const int NO_ERROR = 0;\n        const int ERROR_INSUFFICIENT_BUFFER = 122;\n        const int ERROR_INVALID_FLAGS = 1004;\n\n        public enum SID_NAME_USE\n        {\n            SidTypeUser = 1,\n            SidTypeGroup,\n            SidTypeDomain,\n            SidTypeAlias,\n            SidTypeWellKnownGroup,\n            SidTypeDeletedAccount,\n            SidTypeInvalid,\n            SidTypeUnknown,\n            SidTypeComputer\n        }\n\n        [EnvironmentPermissionAttribute(SecurityAction.Demand, Unrestricted = true)]\n        public static string ConvertSIDToNameWithWindowsAPI(string sidstring, string server, out string referencedDomain)\n        {\n            StringBuilder name = new StringBuilder();\n            uint cchName = (uint)name.Capacity;\n            StringBuilder referencedDomainName = new StringBuilder();\n            uint cchReferencedDomainName = (uint)referencedDomainName.Capacity;\n            SID_NAME_USE sidUse;\n\n            SecurityIdentifier securityidentifier = null;\n            referencedDomain = null;\n            try\n            {\n                securityidentifier = new SecurityIdentifier(sidstring);\n            }\n            catch (Exception ex)\n            {\n                Trace.WriteLine(\"Got \" + ex.Message + \" when trying to convert \" + sidstring + \" as sid\");\n                Trace.WriteLine(ex.StackTrace);\n                return sidstring;\n            }\n\n            // try to resolve the account using the server\n            byte[] Sid = new byte[securityidentifier.BinaryLength];\n            securityidentifier.GetBinaryForm(Sid, 0);\n\n            int err = NO_ERROR;\n            if (!LookupAccountSid(server, Sid, name, ref cchName, referencedDomainName, ref cchReferencedDomainName, out sidUse))\n            {\n                err = System.Runtime.InteropServices.Marshal.GetLastWin32Error();\n                if (err == ERROR_INSUFFICIENT_BUFFER)\n                {\n                    name.EnsureCapacity((int)cchName);\n                    referencedDomainName.EnsureCapacity((int)cchReferencedDomainName);\n                    err = NO_ERROR;\n                    if (!LookupAccountSid(server, Sid, name, ref cchName, referencedDomainName, ref cchReferencedDomainName, out sidUse))\n                        err = System.Runtime.InteropServices.Marshal.GetLastWin32Error();\n                }\n            }\n            if (err == 0)\n            {\n                referencedDomain = referencedDomainName.ToString();\n                if (String.IsNullOrEmpty(referencedDomain))\n                    return name.ToString();\n                else\n                    return referencedDomainName + \"\\\\\" + name;\n            }\n            Trace.WriteLine(@\"Error \" + err + \" when translating \" + sidstring + \" on \" + server);\n            return sidstring;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct UNICODE_STRING : IDisposable\n        {\n            public ushort Length;\n            public ushort MaximumLength;\n            private IntPtr buffer;\n\n            [SecurityPermission(SecurityAction.LinkDemand)]\n            public void Initialize(string s)\n            {\n                Length = (ushort)(s.Length * 2);\n                MaximumLength = (ushort)(Length + 2);\n                buffer = Marshal.StringToHGlobalUni(s);\n            }\n\n            [SecurityPermission(SecurityAction.LinkDemand)]\n            public void Dispose()\n            {\n                Marshal.FreeHGlobal(buffer);\n                buffer = IntPtr.Zero;\n            }\n            [SecurityPermission(SecurityAction.LinkDemand)]\n            public override string ToString()\n            {\n                if (Length == 0)\n                    return String.Empty;\n                return Marshal.PtrToStringUni(buffer, Length / 2);\n            }\n        }\n\n        // used for local admins scanner\n        [DllImport(\"samlib.dll\"), System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Portability\", \"CA1901:PInvokeDeclarationsShouldBePortable\", MessageId = \"3\")]\n        internal static extern int SamConnect(ref UNICODE_STRING serverName, out IntPtr hServerHandle, int desiredAccess, int trusted);\n        [DllImport(\"samlib.dll\")]\n        internal static extern int SamOpenDomain(IntPtr SamHandle, int DesiredAccess, byte[] DomainId, out IntPtr DomainHandle);\n        [DllImport(\"samlib.dll\")]\n        internal static extern int SamOpenAlias(IntPtr DomainHandle, int DesiredAccess, int AliasId, out IntPtr AliasHandle);\n        [DllImport(\"samlib.dll\")]\n        internal static extern int SamGetMembersInAlias(IntPtr AliasHandle, out IntPtr Members, out int CountReturned);\n        [DllImport(\"samlib.dll\")]\n        internal static extern int SamFreeMemory(IntPtr memory);\n        [DllImport(\"samlib.dll\")]\n        internal static extern int SamCloseHandle(IntPtr SamHandle);\n        [DllImport(\"advapi32.dll\", SetLastError = false)]\n        internal static extern int LsaNtStatusToWinError(int status);\n\n        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n        internal struct SHARE_INFO_1\n        {\n            public string shi1_netname;\n            public uint shi1_type;\n            public string shi1_remark;\n            public SHARE_INFO_1(string sharename, uint sharetype, string remark)\n            {\n                this.shi1_netname = sharename;\n                this.shi1_type = sharetype;\n                this.shi1_remark = remark;\n            }\n            public override string ToString()\n            {\n                return shi1_netname;\n            }\n        }\n\n        // used in share scanner\n        [DllImport(\"Netapi32.dll\", CharSet = CharSet.Unicode)]\n        internal static extern int NetShareEnum(\n             string ServerName,\n             int level,\n             ref IntPtr bufPtr,\n             uint prefmaxlen,\n             ref int entriesread,\n             ref int totalentries,\n             ref int resume_handle\n             );\n\n        internal struct LSA_OBJECT_ATTRIBUTES\n        {\n            public UInt32 Length;\n            public IntPtr RootDirectory;\n            public UNICODE_STRING ObjectName;\n            public UInt32 Attributes;\n            public IntPtr SecurityDescriptor;\n            public IntPtr SecurityQualityOfService;\n        }\n\n        [DllImport(\"advapi32.dll\")]\n        internal static extern uint LsaOpenPolicy(\n           ref UNICODE_STRING SystemName,\n           ref LSA_OBJECT_ATTRIBUTES ObjectAttributes,\n           uint DesiredAccess,\n           out IntPtr PolicyHandle\n        );\n\n        [DllImport(\"advapi32.dll\")]\n        internal static extern uint LsaClose(IntPtr ObjectHandle);\n\n        [StructLayout(LayoutKind.Sequential)]\n        internal struct LSA_TRUST_INFORMATION\n        {\n            internal UNICODE_STRING Name;\n            internal IntPtr Sid;\n        }\n\n        #endregion\n\n\n        [DllImport(\"advapi32.dll\")]\n        internal static extern int LsaFreeMemory(IntPtr pBuffer);\n\n        [DllImport(\"advapi32.dll\", SetLastError = true)]\n        internal static extern uint LsaLookupSids(\n            IntPtr PolicyHandle,\n            int Count,\n            IntPtr ptrEnumBuf,\n            out IntPtr ptrDomainList,\n            out IntPtr ptrNameList\n         );\n\n        [DllImport(\"advapi32\")]\n        internal static extern uint LsaLookupNames(\n            IntPtr PolicyHandle,\n            int Count,\n            UNICODE_STRING[] Names,\n            out IntPtr ReferencedDomains,\n            out IntPtr Sids\n        );\n\n        [StructLayout(LayoutKind.Sequential)]\n        internal struct LSA_REFERENCED_DOMAIN_LIST\n        {\n            public int Entries;\n            public IntPtr Domains;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct LSA_TRANSLATED_NAME\n        {\n            public SID_NAME_USE Use;\n            public UNICODE_STRING Name;\n            public int DomainIndex;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct LSA_TRANSLATED_SID\n        {\n            public SID_NAME_USE Use;\n            public uint RelativeId;\n            public int DomainIndex;\n        }\n\n        [SecurityPermission(SecurityAction.Demand, Flags = SecurityPermissionFlag.UnmanagedCode)]\n        public static SecurityIdentifier GetSidFromDomainNameWithWindowsAPI(string server, string domainToResolve)\n        {\n            NativeMethods.UNICODE_STRING us = new NativeMethods.UNICODE_STRING();\n            NativeMethods.LSA_OBJECT_ATTRIBUTES loa = new NativeMethods.LSA_OBJECT_ATTRIBUTES();\n            us.Initialize(server);\n            IntPtr PolicyHandle = IntPtr.Zero;\n            uint ret = NativeMethods.LsaOpenPolicy(ref us, ref loa, 0x00000800, out PolicyHandle);\n            if (ret != 0)\n            {\n                Trace.WriteLine(\"LsaOpenPolicy 0x\" + ret.ToString(\"x\"));\n                return null;\n            }\n            try\n            {\n                UNICODE_STRING usdomain = new UNICODE_STRING();\n                usdomain.Initialize(domainToResolve);\n                IntPtr ReferencedDomains, Sids;\n                ret = LsaLookupNames(PolicyHandle, 1, new UNICODE_STRING[] { usdomain }, out ReferencedDomains, out Sids);\n                if (ret != 0)\n                {\n                    Trace.WriteLine(\"LsaLookupNames 0x\" + ret.ToString(\"x\"));\n                    return null;\n                }\n                try\n                {\n                    LSA_REFERENCED_DOMAIN_LIST domainList = (LSA_REFERENCED_DOMAIN_LIST)Marshal.PtrToStructure(ReferencedDomains, typeof(LSA_REFERENCED_DOMAIN_LIST));\n                    if (domainList.Entries > 0)\n                    {\n                        LSA_TRUST_INFORMATION trustInfo = (LSA_TRUST_INFORMATION)Marshal.PtrToStructure(domainList.Domains, typeof(LSA_TRUST_INFORMATION));\n                        return new SecurityIdentifier(trustInfo.Sid);\n                    }\n                }\n                finally\n                {\n                    LsaFreeMemory(ReferencedDomains);\n                    LsaFreeMemory(Sids);\n                }\n            }\n            finally\n            {\n                NativeMethods.LsaClose(PolicyHandle);\n            }\n            return null;\n        }\n\n\n        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n        public struct STAT_WORKSTATION_0\n        {\n            public long StatisticsStartTime;\n            public long BytesReceived;\n            public long SmbsReceived;\n            public long PagingReadBytesRequested;\n            public long NonPagingReadBytesRequested;\n            public long CacheReadBytesRequested;\n            public long NetworkReadBytesRequested;\n            public long BytesTransmitted;\n            public long SmbsTransmitted;\n            public long PagingWriteBytesRequested;\n            public long NonPagingWriteBytesRequested;\n            public long CacheWriteBytesRequested;\n            public long NetworkWriteBytesRequested;\n            public uint InitiallyFailedOperations;\n            public uint FailedCompletionOperations;\n            public uint ReadOperations;\n            public uint RandomReadOperations;\n            public uint ReadSmbs;\n            public uint LargeReadSmbs;\n            public uint SmallReadSmbs;\n            public uint WriteOperations;\n            public uint RandomWriteOperations;\n            public uint WriteSmbs;\n            public uint LargeWriteSmbs;\n            public uint SmallWriteSmbs;\n            public uint RawReadsDenied;\n            public uint RawWritesDenied;\n            public uint NetworkErrors;\n            public uint Sessions;\n            public uint FailedSessions;\n            public uint Reconnects;\n            public uint CoreConnects;\n            public uint Lanman20Connects;\n            public uint Lanman21Connects;\n            public uint LanmanNtConnects;\n            public uint ServerDisconnects;\n            public uint HungSessions;\n            public uint UseCount;\n            public uint FailedUseCount;\n            public uint CurrentCommands;\n        }\n\n        [DllImport(\"Netapi32.dll\", CharSet = CharSet.Unicode)]\n        internal static extern uint NetStatisticsGet(\n            [In, MarshalAs(UnmanagedType.LPWStr)] string server,\n            [In, MarshalAs(UnmanagedType.LPWStr)] string service,\n            int level,\n            int options,\n            out IntPtr bufptr);\n\n        [SecurityPermission(SecurityAction.Demand, Flags = SecurityPermissionFlag.UnmanagedCode)]\n        public static DateTime GetStartupTime(string server)\n        {\n            IntPtr buffer = IntPtr.Zero;\n            uint ret = NetStatisticsGet(server, \"LanmanWorkstation\", 0, 0, out buffer);\n            if (ret != 0)\n            {\n                Trace.WriteLine(\"GetStartupTime \" + server + \" returned \" + ret);\n                return DateTime.MinValue;\n            }\n            try\n            {\n                STAT_WORKSTATION_0 data = (STAT_WORKSTATION_0)Marshal.PtrToStructure(buffer, typeof(STAT_WORKSTATION_0));\n                return DateTime.FromFileTime(data.StatisticsStartTime);\n            }\n            finally\n            {\n                NetApiBufferFree(buffer);\n            }\n        }\n\n        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n        public struct WKSTA_INFO_100\n        {\n            public int platform_id;\n            public string computer_name;\n            public string lan_group;\n            public int ver_major;\n            public int ver_minor;\n        }\n\n        [DllImport(\"netapi32.dll\", CharSet = CharSet.Unicode)]\n        internal static extern uint NetWkstaGetInfo(\n                string servername,\n                int level,\n                out IntPtr bufptr);\n\n        [SecurityPermission(SecurityAction.Demand, Flags = SecurityPermissionFlag.UnmanagedCode)]\n        public static string GetComputerVersion(string server)\n        {\n            IntPtr buffer = IntPtr.Zero;\n            uint ret = NetWkstaGetInfo(server, 100, out buffer);\n            if (ret != 0)\n            {\n                Trace.WriteLine(\"GetComputerVersion \" + server + \" returned \" + ret);\n                return \"not found\";\n            }\n            try\n            {\n                WKSTA_INFO_100 data = (WKSTA_INFO_100)Marshal.PtrToStructure(buffer, typeof(WKSTA_INFO_100));\n                string version = data.ver_major.ToString() + \".\" + data.ver_minor.ToString();\n                return version;\n            }\n            finally\n            {\n                NetApiBufferFree(buffer);\n            }\n        }\n\n        [DllImport(\"Netapi32\", CharSet = CharSet.Auto)]\n        internal static extern int NetApiBufferFree(IntPtr Buffer);\n\n\n        [DllImport(\"Dnsapi.dll\", CharSet = CharSet.Unicode, EntryPoint = \"DnsQuery_W\")]\n        internal static extern int DnsQuery([In] string recordName, [In] short recordType, [In] int options, [In] IntPtr servers, out IntPtr dnsResultList, [Out] IntPtr reserved);\n\n        [DllImport(\"Dnsapi.dll\", CharSet = CharSet.Unicode)]\n        internal static extern void DnsRecordListFree([In] IntPtr dnsResultList, [In] bool dnsFreeType);\n\n        [DllImport(\"Dnsapi.dll\", SetLastError = true, EntryPoint = \"DnsWriteQuestionToBuffer_W\", CharSet = CharSet.Unicode)]\n        internal static extern bool DnsWriteQuestionToBuffer(\n            byte[] buffer,\n            ref int bufferSize,\n            string name,\n            ushort wType,\n            ushort Xid,\n            bool fRecursionDesired);\n\n        [DllImport(\"Dnsapi.dll\", SetLastError = true, EntryPoint = \"DnsExtractRecordsFromMessage_W\", CharSet = CharSet.Unicode)]\n        internal static extern bool DnsExtractRecordsFromMessage(\n            byte[] message,\n            int messageLength,\n            out IntPtr ppRecords);\n\n        [DllImport(\"Crypt32.dll\", CharSet = CharSet.Auto, SetLastError = true)]\n        public static extern bool CryptDecodeObject([In] uint dwCertEncodingType, [In] [MarshalAs(UnmanagedType.LPStr)] string lpszStructType, [In] byte[] pbEncoded, [In] uint cbEncoded, [In] uint dwFlags, [Out] IntPtr pvStructInfo, [In] [Out] ref uint pcbStructInfo);\n\n        public struct CERT_TEMPLATE_EXT\n        {\n            [MarshalAs(UnmanagedType.LPStr)]\n            public string pszObjId;\n\n            public uint dwMajorVersion;\n\n            public bool fMinorVersion;\n\n            public uint dwMinorVersion;\n        }\n\n        #region convert command line to argc\n        [DllImport(\"shell32.dll\", SetLastError = true, CharSet = CharSet.Unicode)]\n        static extern IntPtr CommandLineToArgvW([MarshalAs(UnmanagedType.LPWStr)] string lpCmdLine, out int pNumArgs);\n\n        [DllImport(\"kernel32.dll\")]\n        static extern IntPtr LocalFree(IntPtr hMem);\n\n        private static string[] SplitArgsWindows(string unsplitArgumentLine)\n        {\n            int numberOfArgs;\n            IntPtr ptrToSplitArgs;\n            string[] splitArgs;\n\n            ptrToSplitArgs = CommandLineToArgvW(unsplitArgumentLine, out numberOfArgs);\n\n            // CommandLineToArgvW returns NULL upon failure.\n            if (ptrToSplitArgs == IntPtr.Zero)\n                throw new ArgumentException(\"Unable to split argument.\", new Win32Exception());\n\n            // Make sure the memory ptrToSplitArgs to is freed, even upon failure.\n            try\n            {\n                splitArgs = new string[numberOfArgs];\n\n                // ptrToSplitArgs is an array of pointers to null terminated Unicode strings.\n                // Copy each of these strings into our split argument array.\n                for (int i = 0; i < numberOfArgs; i++)\n                    splitArgs[i] = Marshal.PtrToStringUni(\n                        Marshal.ReadIntPtr(ptrToSplitArgs, i * IntPtr.Size));\n\n                return splitArgs;\n            }\n            finally\n            {\n                // Free memory obtained by CommandLineToArgW.\n                LocalFree(ptrToSplitArgs);\n            }\n        }\n\n        public static string[] SplitArguments(string commandLine)\n        {\n            if (Environment.OSVersion.Platform == PlatformID.Win32NT)\n            {\n                return SplitArgsWindows(commandLine);\n            }\n            var parmChars = commandLine.ToCharArray();\n            var inSingleQuote = false;\n            var inDoubleQuote = false;\n            for (var index = 0; index < parmChars.Length; index++)\n            {\n                if (parmChars[index] == '\"' && !inSingleQuote)\n                {\n                    inDoubleQuote = !inDoubleQuote;\n                    parmChars[index] = '\\n';\n                }\n                if (parmChars[index] == '\\'' && !inDoubleQuote)\n                {\n                    inSingleQuote = !inSingleQuote;\n                    parmChars[index] = '\\n';\n                }\n                if (!inSingleQuote && !inDoubleQuote && parmChars[index] == ' ')\n                    parmChars[index] = '\\n';\n            }\n            return (new string(parmChars)).Split(new[] { '\\n' }, StringSplitOptions.RemoveEmptyEntries);\n        }\n        #endregion convert command line to argc\n    }\n}\n"
        },
        {
          "name": "PingCastle.csproj",
          "type": "blob",
          "size": 39.4560546875,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project ToolsVersion=\"4.0\" DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <Import Project=\"packages\\Costura.Fody.5.7.0\\build\\Costura.Fody.props\" Condition=\"Exists('packages\\Costura.Fody.5.7.0\\build\\Costura.Fody.props')\" />\n  <Import Project=\"$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.Common.props\" Condition=\"Exists('$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.Common.props')\" />\n  <PropertyGroup>\n    <Configuration Condition=\" '$(Configuration)' == '' \">Debug</Configuration>\n    <Platform Condition=\" '$(Platform)' == '' \">AnyCPU</Platform>\n    <ProjectGuid>{52BBA3C2-A74E-4096-B65F-B88C38F92120}</ProjectGuid>\n    <OutputType>Exe</OutputType>\n    <AppDesignerFolder>Properties</AppDesignerFolder>\n    <RootNamespace>PingCastle</RootNamespace>\n    <AssemblyName>PingCastle</AssemblyName>\n    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>\n    <FileAlignment>512</FileAlignment>\n    <TargetFrameworkProfile />\n    <IsWebBootstrapper>false</IsWebBootstrapper>\n    <PublishUrl>publier\\</PublishUrl>\n    <Install>true</Install>\n    <InstallFrom>Disk</InstallFrom>\n    <UpdateEnabled>false</UpdateEnabled>\n    <UpdateMode>Foreground</UpdateMode>\n    <UpdateInterval>7</UpdateInterval>\n    <UpdateIntervalUnits>Days</UpdateIntervalUnits>\n    <UpdatePeriodically>false</UpdatePeriodically>\n    <UpdateRequired>false</UpdateRequired>\n    <MapFileExtensions>true</MapFileExtensions>\n    <ApplicationRevision>0</ApplicationRevision>\n    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>\n    <UseApplicationTrust>false</UseApplicationTrust>\n    <BootstrapperEnabled>true</BootstrapperEnabled>\n  </PropertyGroup>\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' \">\n    <PlatformTarget>AnyCPU</PlatformTarget>\n    <DebugSymbols>true</DebugSymbols>\n    <DebugType>full</DebugType>\n    <Optimize>false</Optimize>\n    <OutputPath>bin\\Debug\\</OutputPath>\n    <DefineConstants>DEBUG;TRACE</DefineConstants>\n    <ErrorReport>prompt</ErrorReport>\n    <WarningLevel>4</WarningLevel>\n    <NoWarn>0436</NoWarn>\n    <Prefer32Bit>false</Prefer32Bit>\n  </PropertyGroup>\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' \">\n    <PlatformTarget>AnyCPU</PlatformTarget>\n    <DebugType>pdbonly</DebugType>\n    <Optimize>true</Optimize>\n    <OutputPath>bin\\Release\\</OutputPath>\n    <DefineConstants>TRACE</DefineConstants>\n    <ErrorReport>prompt</ErrorReport>\n    <WarningLevel>4</WarningLevel>\n    <NoWarn>0436</NoWarn>\n    <Prefer32Bit>false</Prefer32Bit>\n  </PropertyGroup>\n  <PropertyGroup>\n    <SignAssembly>false</SignAssembly>\n  </PropertyGroup>\n  <PropertyGroup>\n    <AssemblyOriginatorKeyFile>\n    </AssemblyOriginatorKeyFile>\n  </PropertyGroup>\n  <PropertyGroup>\n    <ApplicationIcon>pingcastle.ico</ApplicationIcon>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'Debug|x86'\">\n    <DebugSymbols>true</DebugSymbols>\n    <OutputPath>bin\\x86\\Debug\\</OutputPath>\n    <DefineConstants>DEBUG;TRACE</DefineConstants>\n    <DebugType>full</DebugType>\n    <PlatformTarget>x86</PlatformTarget>\n    <ErrorReport>prompt</ErrorReport>\n    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>\n    <Prefer32Bit>false</Prefer32Bit>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'Release|x86'\">\n    <OutputPath>bin\\x86\\Release\\</OutputPath>\n    <DefineConstants>TRACE</DefineConstants>\n    <Optimize>true</Optimize>\n    <DebugType>pdbonly</DebugType>\n    <PlatformTarget>x86</PlatformTarget>\n    <ErrorReport>prompt</ErrorReport>\n    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>\n    <Prefer32Bit>false</Prefer32Bit>\n  </PropertyGroup>\n  <ItemGroup>\n    <Reference Include=\"Costura, Version=5.7.0.0, Culture=neutral, processorArchitecture=MSIL\">\n      <HintPath>packages\\Costura.Fody.5.7.0\\lib\\netstandard1.0\\Costura.dll</HintPath>\n    </Reference>\n    <Reference Include=\"Newtonsoft.Json, Version=13.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>.\\Newtonsoft.Json.dll</HintPath>\n    </Reference>\n    <Reference Include=\"System\" />\n    <Reference Include=\"System.ComponentModel.Composition\" />\n    <Reference Include=\"System.configuration\" />\n    <Reference Include=\"System.Core\" />\n    <Reference Include=\"System.Data\" />\n    <Reference Include=\"System.DirectoryServices\" />\n    <Reference Include=\"System.DirectoryServices.Protocols\" />\n    <Reference Include=\"System.Drawing\" />\n    <Reference Include=\"System.IO.Compression\" />\n    <Reference Include=\"System.Net.Http, Version=4.1.1.3, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL\">\n      <HintPath>packages\\System.Net.Http.4.3.4\\lib\\net46\\System.Net.Http.dll</HintPath>\n    </Reference>\n    <Reference Include=\"System.Numerics\" />\n    <Reference Include=\"System.Runtime.InteropServices.RuntimeInformation, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL\">\n      <HintPath>packages\\System.Runtime.InteropServices.RuntimeInformation.4.3.0\\lib\\net45\\System.Runtime.InteropServices.RuntimeInformation.dll</HintPath>\n    </Reference>\n    <Reference Include=\"System.Runtime.Serialization\" />\n    <Reference Include=\"System.Security\" />\n    <Reference Include=\"System.Security.Cryptography.Algorithms, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL\">\n      <HintPath>packages\\System.Security.Cryptography.Algorithms.4.3.0\\lib\\net463\\System.Security.Cryptography.Algorithms.dll</HintPath>\n    </Reference>\n    <Reference Include=\"System.Security.Cryptography.Encoding, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL\">\n      <HintPath>packages\\System.Security.Cryptography.Encoding.4.3.0\\lib\\net46\\System.Security.Cryptography.Encoding.dll</HintPath>\n    </Reference>\n    <Reference Include=\"System.Security.Cryptography.Primitives, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL\">\n      <HintPath>packages\\System.Security.Cryptography.Primitives.4.3.0\\lib\\net46\\System.Security.Cryptography.Primitives.dll</HintPath>\n    </Reference>\n    <Reference Include=\"System.Security.Cryptography.X509Certificates, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL\">\n      <HintPath>packages\\System.Security.Cryptography.X509Certificates.4.3.0\\lib\\net461\\System.Security.Cryptography.X509Certificates.dll</HintPath>\n    </Reference>\n    <Reference Include=\"System.ServiceModel\" />\n    <Reference Include=\"System.Text.RegularExpressions, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL\">\n      <HintPath>packages\\System.Text.RegularExpressions.4.3.1\\lib\\net463\\System.Text.RegularExpressions.dll</HintPath>\n    </Reference>\n    <Reference Include=\"System.Web\" />\n    <Reference Include=\"System.Windows.Forms\" />\n    <Reference Include=\"System.Xml\" />\n    <Reference Include=\"System.Xml.Linq\" />\n    <Reference Include=\"WindowsBase\" />\n  </ItemGroup>\n  <ItemGroup>\n    <Compile Include=\"ADWS\\IADConnection.cs\" />\n    <Compile Include=\"ADWS\\LinuxConnection.cs\" />\n    <Compile Include=\"ADWS\\LinuxFileConnection.cs\" />\n    <Compile Include=\"ADWS\\WindowsFileConnection.cs\" />\n    <Compile Include=\"Bot\\Bot.cs\" />\n    <Compile Include=\"Bot\\BotData.cs\" />\n    <Compile Include=\"Bot\\BotStream.cs\" />\n    <Compile Include=\"Cloud\\Analyzer\\Analyzer.cs\" />\n    <Compile Include=\"Cloud\\Common\\HttpClientHelper.cs\" />\n    <Compile Include=\"Cloud\\Common\\JsonSerialization.cs\" />\n    <Compile Include=\"Cloud\\Constants.cs\" />\n    <Compile Include=\"Cloud\\Credentials\\CertificateBuilder.cs\" />\n    <Compile Include=\"Cloud\\Credentials\\CertificateCredential.cs\" />\n    <Compile Include=\"Cloud\\Credentials\\CredentialBase.cs\" />\n    <Compile Include=\"Cloud\\Credentials\\IAzureCredential.cs\" />\n    <Compile Include=\"Cloud\\Credentials\\PRTCredential.cs\" />\n    <Compile Include=\"Cloud\\Credentials\\UserCredential.cs\" />\n    <Compile Include=\"Cloud\\Data\\AzureADKey.cs\" />\n    <Compile Include=\"Cloud\\Data\\HealthCheckCloudData.cs\" />\n    <Compile Include=\"Cloud\\Export\\ExportAsGuest.cs\" />\n    <Compile Include=\"Cloud\\Logs\\LoggingHandler.cs\" />\n    <Compile Include=\"Cloud\\Logs\\SazGenerator.cs\" />\n    <Compile Include=\"Cloud\\PingCastleCloudException.cs\" />\n    <Compile Include=\"Cloud\\PublicServices\\OpenIDConfiguration.cs\" />\n    <Compile Include=\"Cloud\\PublicServices\\PublicService.cs\" />\n    <Compile Include=\"Cloud\\PublicServices\\TenantBrandingInfo.cs\" />\n    <Compile Include=\"Cloud\\PublicServices\\UserRealmCT.cs\" />\n    <Compile Include=\"Cloud\\PublicServices\\UserRealmCTRequest.cs\" />\n    <Compile Include=\"Cloud\\PublicServices\\UserRealmSRF.cs\" />\n    <Compile Include=\"Cloud\\PublicServices\\UserRealmV1.cs\" />\n    <Compile Include=\"Cloud\\PublicServices\\UserRealmV2.cs\" />\n    <Compile Include=\"Healthcheck\\LAPSAnalyzer.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledTerminalServiceGPO.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledScriptToInternet.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledDefenderASR.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledFolderOptions.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyRootDseAnonBinding.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledAesNotEnabled.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedRODCKrbtgtOrphan.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalySmartCardExpirePassword.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyDCCoerce.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledObsolete2012.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledObsoleteDC2012.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedUnprotectedOU.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedEmailOn.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledDefaultOUChanged.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyDCLdapsSSLAdvanced.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledOldNtlm.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledPwdLastSetCluster.cs\" />\n    <Compile Include=\"Report\\ReportCloudCompared.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledObsoleteFunctionalLevel4.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledObsoleteFunctionalLevel3.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledObsoleteFunctionalLevel1.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedDisplaySpecifier.cs\" />\n    <Compile Include=\"RPC\\rpcfirewallchecker.cs\" />\n    <Compile Include=\"RuntimeSettings.cs\" />\n    <Compile Include=\"Report\\ReportCloud.cs\" />\n    <Compile Include=\"Cloud\\RESTServices\\AzureServiceAttribute.cs\" />\n    <Compile Include=\"Cloud\\RESTServices\\Azure\\AzureADConnectApi.cs\" />\n    <Compile Include=\"Cloud\\RESTServices\\Azure\\GraphAPI.cs\" />\n    <Compile Include=\"Cloud\\RESTServices\\Azure\\ManagementApi.cs\" />\n    <Compile Include=\"Cloud\\RESTServices\\Azure\\MicrosoftGraph.cs\" />\n    <Compile Include=\"Cloud\\RESTServices\\Azure\\ProvisioningApi.cs\" />\n    <Compile Include=\"Cloud\\RESTServices\\ClientIDs.cs\" />\n    <Compile Include=\"Cloud\\RESTServices\\EndPointAttribute.cs\" />\n    <Compile Include=\"Cloud\\RESTServices\\IAzureService.cs\" />\n    <Compile Include=\"Cloud\\RESTServices\\O365\\O365Api.cs\" />\n    <Compile Include=\"Cloud\\RESTServices\\RESTClientBase.cs\" />\n    <Compile Include=\"Cloud\\Rules\\ADConnectVersion.cs\" />\n    <Compile Include=\"Cloud\\Rules\\ADConnectVersion1.cs\" />\n    <Compile Include=\"Cloud\\Rules\\GuestUserAccessRestriction1.cs\" />\n    <Compile Include=\"Cloud\\Rules\\GuestUserAccessRestriction2.cs\" />\n    <Compile Include=\"Cloud\\Rules\\UserConsentCompanyData.cs\" />\n    <Compile Include=\"Cloud\\Rules\\UserRegisterApplications.cs\" />\n    <Compile Include=\"Cloud\\Tokens\\ChallengeResponse.cs\" />\n    <Compile Include=\"Cloud\\Tokens\\CookieManager.cs\" />\n    <Compile Include=\"Cloud\\Tokens\\JwtHeader.cs\" />\n    <Compile Include=\"Cloud\\Tokens\\JwtPayload.cs\" />\n    <Compile Include=\"Cloud\\Tokens\\JwtToken.cs\" />\n    <Compile Include=\"Cloud\\Tokens\\Token.cs\" />\n    <Compile Include=\"Cloud\\Tokens\\TokenCache.cs\" />\n    <Compile Include=\"Cloud\\Tokens\\TokenFactory.cs\" />\n    <Compile Include=\"Cloud\\UI\\AuthenticationDialog.cs\">\n      <SubType>Form</SubType>\n    </Compile>\n    <Compile Include=\"Cloud\\UI\\AuthenticationDialog.Designer.cs\">\n      <DependentUpon>AuthenticationDialog.cs</DependentUpon>\n    </Compile>\n    <Compile Include=\"ConsoleMenu.cs\" />\n    <Compile Include=\"Data\\IPingCastleReport.cs\" />\n    <Compile Include=\"Data\\IPingCastleReportGenerator.cs\" />\n    <Compile Include=\"Data\\PingCastleReportHelper.cs\" />\n    <Compile Include=\"Data\\PingCastleReportDataExportLevel.cs\" />\n    <Compile Include=\"Data\\SafeXmlWriter.cs\" />\n    <Compile Include=\"Exports\\ExportComputers.cs\" />\n    <Compile Include=\"Exports\\ExportBase.cs\" />\n    <Compile Include=\"Exports\\ExportChanges.cs\" />\n    <Compile Include=\"Exports\\ExportUsers.cs\" />\n    <Compile Include=\"Exports\\IExport.cs\" />\n    <Compile Include=\"Graph\\Database\\LiveDataStorage.cs\" />\n    <Compile Include=\"Graph\\Database\\MappingType.cs\" />\n    <Compile Include=\"Graph\\Database\\RelationType.cs\" />\n    <Compile Include=\"Graph\\Export\\ExportDataFromActiveDirectoryLive.cs\" />\n    <Compile Include=\"ADWS\\ADWSConnection.cs\" />\n    <Compile Include=\"ADWS\\ADConnection.cs\" />\n    <Compile Include=\"ADWS\\LDAPConnection.cs\" />\n    <Compile Include=\"Compatibility.cs\" />\n    <Compile Include=\"Graph\\Reporting\\GraphObjectReference.cs\" />\n    <Compile Include=\"Healthcheck\\ADModel.cs\" />\n    <Compile Include=\"Data\\DomainKey.cs\" />\n    <Compile Include=\"ADWS\\DomainLocator.cs\" />\n    <Compile Include=\"Data\\PingCastleReportCollection.cs\" />\n    <Compile Include=\"Data\\DataHelper.cs\" />\n    <Compile Include=\"Data\\PingCastleReportHistoryCollection.cs\" />\n    <Compile Include=\"Healthcheck\\InfrastructureSettings.cs\" />\n    <Compile Include=\"Healthcheck\\FakeHealthCheckDataGenerator.cs\" />\n    <Compile Include=\"Healthcheck\\HealthCheckEncryption.cs\" />\n    <Compile Include=\"Data\\HealthCheckBUEntityData.cs\" />\n    <Compile Include=\"Data\\CompromiseGraphData.cs\" />\n    <Compile Include=\"Healthcheck\\HoneyPotSettings.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledKerberosArmoring.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledKerberosArmoringDC.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyDCWebClient.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyCertTempNoSecurity.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleTrustAES.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyCertEnrollCB.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyCertEnrollHttp.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyDCLdapSign.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyDCLdapsCB.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyDnsZoneAUCreateChild.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyGuest.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledObsoleteW10.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledObsoleteWin8.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyDsHeuristicsLDAPSecurity.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyDsHeuristicsDoNotVerifyUniqueness.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyWSUSSSL.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyHardenedPaths.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaleADRegistrationViaSchema.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledWSUSNoPinning.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledWSUSUserProxy.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledWSUShttp.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyPreWin2000AuthenticatedUsers.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyCertTempAnyone.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyCertTempAgent.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyCertTempAnyPurpose.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyCertTempCustomSubject.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyLAPSJoinedComputers.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyDnsZoneTransfert.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledObsoleteWin7.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledJavaSchema.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleTrustAzureADSSO.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyUnixPassword.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyNoNetSessionHardening.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedRODCSYSVOLWrite.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedRODCAdminRevealed.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedRODCRevealOnDemand.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedRODCNeverReveal.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedDNSAdmin.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledNoPreAuthAdmin.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedAdminPwdTooOld.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledPwdLastSet90.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledPwdLastSet45.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedProtectedUsers.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyPreWin2000Other.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedDelegationDCsourcedeleg.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedDelegationDCt2a4d.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedDelegationDCa2d2.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaleDCRegistration.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledPwdLastSetDC.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledInactiveDC.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyDnsZoneUnsecureUpdate2.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyDnsZoneUnsecureUpdate1.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyNTFRSOnSYSVOL.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedRODCDeniedGroup.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedRODCAllowedGroup.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyDsHeuristicsAnonNSPI.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyCertWeakRSA2.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyCertWeakRSAComponent.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyCertWeakDSA.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyCertROCA.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledObsolete2008.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledObsoleteDC2008.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledObsoleteVista.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyAuditPowershell.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyDCLdapsSSL.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyAuditDC.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedControlPathIndirectMany.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedControlPathIndirectEveryone.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedLogonDenied.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedTrustedCredManAccessPrivilege.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedDNSDelegation.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedKerberoasting.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledPwdNeverExpires.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleTrustSIDHistoryDangerous.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleTrustTGTDelegation.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyNoGPOLLMNR.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleTrustFileDeployedOutOfDomain.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedDelegationFileDeployed.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyDCRefuseComputerPwdChange.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyLDAPSigningDisabled.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedRecoveryModeUnprotected.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedDsHeuristicsDoListObject.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedDsHeuristicsAdminSDExMaskModified.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedRecycleBin.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedLoginDCEveryone.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedExchangePrivEsc.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedPrivilegeEveryone.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedDelegationGPOData.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedOperatorsEmpty.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyNotEnoughDC.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyDCSpooler.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedDelegationKeyAdmin.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedExchangeAdminSDHolder.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedUnconstrainedDelegation.cs\" />\n    <Compile Include=\"misc\\NamedPipeTester.cs\" />\n    <Compile Include=\"misc\\ConnectionTester.cs\" />\n    <Compile Include=\"misc\\DnsQuery.cs\" />\n    <Compile Include=\"misc\\ConnectionTesterHttp.cs\" />\n    <Compile Include=\"misc\\ConnectionTesterLdap.cs\" />\n    <Compile Include=\"misc\\JSONParser.cs\" />\n    <Compile Include=\"misc\\RestrictedToken.cs\" />\n    <Compile Include=\"misc\\ROCAVulnerabilityTester.cs\" />\n    <Compile Include=\"misc\\Subnet.cs\" />\n    <Compile Include=\"PingCastleException.cs\" />\n    <Compile Include=\"PingCastleFactory.cs\" />\n    <Compile Include=\"Report\\IActionPlan.cs\" />\n    <Compile Include=\"Report\\IPingCastleReportUser.cs\" />\n    <Compile Include=\"Report\\ReportBase.cs\" />\n    <Compile Include=\"Report\\ReportBenchmark.cs\" />\n    <Compile Include=\"Report\\ReportHealthCheckConsolidation.cs\" />\n    <Compile Include=\"Report\\ReportHealthCheckRules.cs\" />\n    <Compile Include=\"Report\\ReportHealthCheckSingle.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedDelegationLoginScript.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalySMB2SignatureNotEnabled.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalySMB2SignatureNotRequired.cs\" />\n    <Compile Include=\"Report\\ReportHealthCheckSingleCompared.cs\" />\n    <Compile Include=\"Report\\ReportHelper.cs\" />\n    <Compile Include=\"Report\\ReportNetworkMap.cs\" />\n    <Compile Include=\"Report\\ReportRiskControls.cs\" />\n    <Compile Include=\"RPC\\dcom.cs\" />\n    <Compile Include=\"RPC\\SSPI.cs\" />\n    <Compile Include=\"Rules\\CustomRulesSettings.cs\" />\n    <Compile Include=\"Rules\\IRiskEvaluation.cs\" />\n    <Compile Include=\"Rules\\IRuleScore.cs\" />\n    <Compile Include=\"Rules\\RiskModelCategory.cs\" />\n    <Compile Include=\"Rules\\RiskRuleCategory.cs\" />\n    <Compile Include=\"Rules\\RuleAttribute.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledDCSubnetMissing.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyBackupMetadata.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalySchemaProtectedUsers.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyLAPS.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledMS17_010.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledNoPreAuth.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledSMBv1.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledMS14_068.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyMembershipEveryone.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedDCOwner.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleTrustSIDHistoryUnknownDomain.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleTrustSIDHistorySameDomain.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaleADRegistrationEnabled.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyCertSHA1Root.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyCertSHA0Root.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyCertMD5Root.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyCertMD4Root.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyCertMD2Root.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyCertWeakRSA.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyCertSHA0Intermediate.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyCertMD2Intermediate.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyCertMD4Intermediate.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleTrustSIDHistoryAuditingGroup.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleTrustLoginScriptOutOfDomain.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyNullSession.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyPreWin2000Anonymous.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyCertSHA1Intermediate.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyCertMD5Intermediate.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyServicePolicy.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyRemoteBlankPasswordUse.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyAnonymousAuthorizedGPO.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyLMHash.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyMinPasswordLen.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyReversiblePassword.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalySmartCardRequired.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyPasswordInGPO.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyAdminSDHolder.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyKrbtgt.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedDangerousDelegation.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedDelegationEveryone.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedUnknownDelegation.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedSchemaAdmins.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedServiceDomainAdmin.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedDelegated.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedAdminInactive.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedAdminNumber.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRulePrivilegedAdminLogin.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleAnomalyDsHeuristicsAnonymous.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleTrustInactive.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleTrustDownlevel.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledObsoleteDC2003.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledObsoleteDC2000.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledObsolete2003.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledObsolete2000.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledObsoleteXP.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledObsoleteNT4.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledDCNotUpdated.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleTrustSIDFiltering.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledDuplicateObjects.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledReversibleEncryptionComputer.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledReversibleEncryption.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledPwdNotRequired.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledDesEnabled.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledPrimaryGroupComputer.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledPrimaryGroup.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledInactiveComputer.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledInactive.cs\" />\n    <Compile Include=\"Rules\\RuleBase.cs\" />\n    <Compile Include=\"Healthcheck\\Rules\\HeatlcheckRuleStaledSIDHistory.cs\" />\n    <Compile Include=\"Healthcheck\\TrustAnalyzer.cs\" />\n    <Compile Include=\"License.cs\" />\n    <Compile Include=\"RPC\\spool.cs\" />\n    <Compile Include=\"Rules\\RuleSet.cs\" />\n    <Compile Include=\"ADWS\\LinuxSidResolver.cs\" />\n    <Compile Include=\"Scanners\\AntivirusScanner.cs\" />\n    <Compile Include=\"Scanners\\bluekeepscanner.cs\" />\n    <Compile Include=\"Scanners\\ComputerVersion.cs\" />\n    <Compile Include=\"Scanners\\ZeroLogonScanner.cs\" />\n    <Compile Include=\"Scanners\\RemoteScanner.cs\" />\n    <Compile Include=\"Scanners\\Smb3QueryNetworkScanner.cs\" />\n    <Compile Include=\"Scanners\\OxidBindingScanner.cs\" />\n    <Compile Include=\"Scanners\\LAPSBitLocker.cs\" />\n    <Compile Include=\"Scanners\\ConsistencyScanner.cs\" />\n    <Compile Include=\"Scanners\\ACLScanner.cs\" />\n    <Compile Include=\"Scanners\\Smb1Protocol.cs\" />\n    <Compile Include=\"Scanners\\Smb2Protocol.cs\" />\n    <Compile Include=\"Scanners\\SpoolerScanner.cs\" />\n    <Compile Include=\"Scanners\\ForeignUsersScanner.cs\" />\n    <Compile Include=\"Scanners\\nullsessionTrustScanner.cs\" />\n    <Compile Include=\"Scanners\\NullSessionScanner.cs\" />\n    <Compile Include=\"Scanners\\IScanner.cs\" />\n    <Compile Include=\"Scanners\\ms17_010scanner.cs\" />\n    <Compile Include=\"Scanners\\ReplicationScanner.cs\" />\n    <Compile Include=\"Scanners\\ScannerBase.cs\" />\n    <Compile Include=\"Scanners\\SmbScanner.cs\" />\n    <Compile Include=\"Scanners\\startupScanner.cs\" />\n    <Compile Include=\"Scanners\\localAdminsEnumerator.cs\" />\n    <Compile Include=\"Scanners\\localAdminsScanner.cs\" />\n    <Compile Include=\"misc\\BlockingQueue.cs\" />\n    <Compile Include=\"Healthcheck\\HealthcheckAnalyzer.cs\" />\n    <Compile Include=\"Data\\HealthcheckData.cs\" />\n    <Compile Include=\"Report\\ReportMapBuilder.cs\" />\n    <Compile Include=\"ADWS\\ADItem.cs\" />\n    <Compile Include=\"ADWS\\ADDomainInfo.cs\" />\n    <Compile Include=\"Graph\\Export\\RelationFactory.cs\" />\n    <Compile Include=\"ADWS\\ADWebService.cs\" />\n    <Compile Include=\"Graph\\Database\\Relation.cs\" />\n    <Compile Include=\"Graph\\Database\\Node.cs\" />\n    <Compile Include=\"Graph\\Reporting\\ReportGenerator.cs\" />\n    <Compile Include=\"ADWS\\soapheader.cs\" />\n    <Compile Include=\"ADWS\\wse.cs\" />\n    <Compile Include=\"misc\\RegistryPolReader.cs\" />\n    <Compile Include=\"NativeMethods.cs\" />\n    <Compile Include=\"RPC\\lsa.cs\" />\n    <Compile Include=\"RPC\\nativemethods.cs\" />\n    <Compile Include=\"RPC\\nrpc.cs\" />\n    <Compile Include=\"RPC\\nullsession.cs\" />\n    <Compile Include=\"RPC\\rpcapi.cs\" />\n    <Compile Include=\"RPC\\samr.cs\" />\n    <Compile Include=\"Program.cs\" />\n    <Compile Include=\"Properties\\AssemblyInfo.cs\" />\n    <Compile Include=\"shares\\ShareEnumerator.cs\" />\n    <Compile Include=\"shares\\ShareScanner.cs\" />\n    <Compile Include=\"Tasks.cs\" />\n    <Compile Include=\"template\\TemplateManager.cs\" />\n  </ItemGroup>\n  <ItemGroup>\n    <None Include=\"app.config\">\n      <SubType>Designer</SubType>\n    </None>\n    <None Include=\"ADWS\\wsdl\\ActiveDirectory.wsdl\" />\n    <None Include=\"ADWS\\wsdl\\ActiveDirectory1.xsd\">\n      <SubType>Designer</SubType>\n    </None>\n    <None Include=\"ADWS\\wsdl\\activedirectorydata.xsd\">\n      <SubType>Designer</SubType>\n    </None>\n    <None Include=\"ADWS\\wsdl\\addressing.xsd\">\n      <SubType>Designer</SubType>\n    </None>\n    <None Include=\"ADWS\\wsdl\\Arrays.xsd\">\n      <SubType>Designer</SubType>\n    </None>\n    <None Include=\"ADWS\\wsdl\\DirectoryAccess.xsd\">\n      <SubType>Designer</SubType>\n    </None>\n    <None Include=\"ADWS\\wsdl\\enumeration.wsdl\" />\n    <None Include=\"ADWS\\wsdl\\enumeration.xsd\">\n      <SubType>Designer</SubType>\n    </None>\n    <None Include=\"ADWS\\wsdl\\ldapquery.xsd\">\n      <SubType>Designer</SubType>\n    </None>\n    <None Include=\"ADWS\\wsdl\\Message.xsd\">\n      <SubType>Designer</SubType>\n    </None>\n    <None Include=\"ADWS\\wsdl\\regeneratewsdl.bat\" />\n    <None Include=\"ADWS\\wsdl\\service.xsd\">\n      <SubType>Designer</SubType>\n    </None>\n    <None Include=\"ADWS\\wsdl\\transfer.wsdl\" />\n    <None Include=\"ADWS\\wsdl\\transfer.xsd\">\n      <SubType>Designer</SubType>\n    </None>\n    <None Include=\"ADWS\\wsdl\\wsman.xsd\">\n      <SubType>Designer</SubType>\n    </None>\n    <EmbeddedResource Include=\"Cloud\\Rules\\RuleDescription.resx\">\n      <SubType>Designer</SubType>\n    </EmbeddedResource>\n    <EmbeddedResource Include=\"Cloud\\UI\\AuthenticationDialog.resx\">\n      <DependentUpon>AuthenticationDialog.cs</DependentUpon>\n    </EmbeddedResource>\n    <EmbeddedResource Include=\"Healthcheck\\Rules\\RuleDescription.resx\">\n      <SubType>Designer</SubType>\n    </EmbeddedResource>\n    <EmbeddedResource Include=\"template\\responsivetemplate.html.gz\" />\n    <EmbeddedResource Include=\"template\\vis.min.css.gz\" />\n    <EmbeddedResource Include=\"template\\vis.min.js.gz\" />\n    <EmbeddedResource Include=\"template\\bootstrap.min.css.gz\" />\n    <EmbeddedResource Include=\"template\\bootstrap.min.js.gz\" />\n    <EmbeddedResource Include=\"template\\jquery.min.js.gz\" />\n    <EmbeddedResource Include=\"template\\popper.min.js.gz\" />\n    <Content Include=\"FodyWeavers.xml\" />\n    <Content Include=\"FodyWeavers.xsd\" />\n    <Content Include=\"template\\ProcessTemplate.ps1\" />\n    <EmbeddedResource Include=\"template\\ReportBase.css.gz\" />\n    <EmbeddedResource Include=\"template\\ReportCompromiseGraph.css.gz\" />\n    <EmbeddedResource Include=\"template\\ReportHealthCheckConsolidation.css.gz\" />\n    <EmbeddedResource Include=\"template\\ReportHealthCheckRules.css.gz\" />\n    <EmbeddedResource Include=\"template\\ReportMapBuilder.css.gz\" />\n    <EmbeddedResource Include=\"template\\ReportNetworkMap.css.gz\" />\n    <EmbeddedResource Include=\"template\\ReportRiskControls.css.gz\" />\n    <EmbeddedResource Include=\"template\\ReportCompromiseGraph.js.gz\" />\n    <EmbeddedResource Include=\"template\\ReportMapBuilder.js.gz\" />\n    <EmbeddedResource Include=\"template\\ReportNetworkMap.js.gz\" />\n    <EmbeddedResource Include=\"template\\bootstrap-table.min.css.gz\" />\n    <EmbeddedResource Include=\"template\\bootstrap-table.min.js.gz\" />\n    <EmbeddedResource Include=\"template\\ReportBase.js.gz\" />\n    <EmbeddedResource Include=\"template\\bootstrap-table-export.min.js.gz\" />\n    <EmbeddedResource Include=\"template\\tableExport.min.js.gz\" />\n    <EmbeddedResource Include=\"template\\ReportCloudMain.js.gz\" />\n    <None Include=\"packages.config\" />\n  </ItemGroup>\n  <ItemGroup>\n    <Content Include=\"changelog.txt\" />\n    <Content Include=\"pingcastle.ico\" />\n    <Content Include=\"template\\ReportBase.css\" />\n    <Content Include=\"template\\ReportBase.js\" />\n    <Content Include=\"template\\ReportCloudMain.js\" />\n    <Content Include=\"template\\ReportCompromiseGraph.css\" />\n    <Content Include=\"template\\ReportCompromiseGraph.js\" />\n    <Content Include=\"template\\ReportHealthCheckConsolidation.css\" />\n    <Content Include=\"template\\ReportHealthCheckRules.css\" />\n    <Content Include=\"template\\ReportMapBuilder.css\" />\n    <Content Include=\"template\\ReportMapBuilder.js\" />\n    <Content Include=\"template\\ReportNetworkMap.css\" />\n    <Content Include=\"template\\ReportNetworkMap.js\" />\n    <Content Include=\"template\\ReportRiskControls.css\" />\n    <Content Include=\"template\\responsivetemplate.html\" />\n  </ItemGroup>\n  <ItemGroup>\n    <BootstrapperPackage Include=\"Microsoft.Net.Client.3.5\">\n      <Visible>False</Visible>\n      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>\n      <Install>false</Install>\n    </BootstrapperPackage>\n    <BootstrapperPackage Include=\"Microsoft.Net.Framework.3.5.SP1\">\n      <Visible>False</Visible>\n      <ProductName>.NET Framework 3.5 SP1</ProductName>\n      <Install>true</Install>\n    </BootstrapperPackage>\n  </ItemGroup>\n  <ItemGroup>\n    <ProjectReference Include=\"PingCastleCommon\\PingCastleCommon.csproj\">\n      <Project>{5a81e70c-7e84-48c2-a777-4f8060f02c43}</Project>\n      <Name>PingCastleCommon</Name>\n    </ProjectReference>\n  </ItemGroup>\n  <Import Project=\"$(MSBuildToolsPath)\\Microsoft.CSharp.targets\" />\n  <PropertyGroup>\n    <PostBuildEvent>SET PATH=%25PATH%25;\"C:\\Program Files (x86)\\Windows Kits\\8.0\\bin\\x86\"\nSET SIGN_SHA256=signtool.exe sign  /d \"PingCastle\" /td sha256 /fd sha256 /n \"Ping Castle SAS\" \nIF /I \"$(COMPUTERNAME)\" == \"DESKTOP-QCK4J75\" goto sign\nIF /I \"$(COMPUTERNAME)\" == \"DESKTOP-90K6SJ2\" goto sign\n\ngoto end\n\n:sign\n@echo ================\n@echo signature\n@echo ================\nIF /I \"$(ConfigurationName)\" == \"Release\" (\necho timestamp\n%25SIGN_SHA256%25  /tr http://timestamp.digicert.com \"$(TargetPath)\"\n)\nIF /I \"$(ConfigurationName)\" == \"Debug\" (\n%25SIGN_SHA256%25 \"$(TargetPath)\"\n)\n:end</PostBuildEvent>\n  </PropertyGroup>\n  <PropertyGroup>\n    <PreBuildEvent>cd $(ProjectDir)\\template\npowershell.exe -ExecutionPolicy Bypass -NoProfile -NonInteractive -File \"ProcessTemplate.ps1\"</PreBuildEvent>\n  </PropertyGroup>\n  <Import Project=\"packages\\Fody.6.8.1\\build\\Fody.targets\" Condition=\"Exists('packages\\Fody.6.8.1\\build\\Fody.targets')\" />\n  <Target Name=\"EnsureNuGetPackageBuildImports\" BeforeTargets=\"PrepareForBuild\">\n    <PropertyGroup>\n      <ErrorText>This project references NuGet package(s) that are missing on this computer. Enable NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105.The missing file is {0}.</ErrorText>\n    </PropertyGroup>\n    <Error Condition=\"!Exists('packages\\Fody.6.8.1\\build\\Fody.targets')\" Text=\"$([System.String]::Format('$(ErrorText)', 'packages\\Fody.6.8.1\\build\\Fody.targets'))\" />\n    <Error Condition=\"!Exists('packages\\Costura.Fody.5.7.0\\build\\Costura.Fody.props')\" Text=\"$([System.String]::Format('$(ErrorText)', 'packages\\Costura.Fody.5.7.0\\build\\Costura.Fody.props'))\" />\n    <Error Condition=\"!Exists('packages\\Costura.Fody.5.7.0\\build\\Costura.Fody.targets')\" Text=\"$([System.String]::Format('$(ErrorText)', 'packages\\Costura.Fody.5.7.0\\build\\Costura.Fody.targets'))\" />\n  </Target>\n  <Import Project=\"packages\\Costura.Fody.5.7.0\\build\\Costura.Fody.targets\" Condition=\"Exists('packages\\Costura.Fody.5.7.0\\build\\Costura.Fody.targets')\" />\n  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. \n       Other similar extension points exist, see Microsoft.Common.targets.\n  <Target Name=\"BeforeBuild\">\n  </Target>\n  <Target Name=\"AfterBuild\">\n  </Target>\n  -->\n</Project>"
        },
        {
          "name": "PingCastle.sln",
          "type": "blob",
          "size": 4.0498046875,
          "content": "﻿\r\nMicrosoft Visual Studio Solution File, Format Version 12.00\r\n# Visual Studio Version 17\r\nVisualStudioVersion = 17.9.34723.18\r\nMinimumVisualStudioVersion = 10.0.40219.1\r\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"PingCastle\", \"PingCastle.csproj\", \"{52BBA3C2-A74E-4096-B65F-B88C38F92120}\"\r\nEndProject\r\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"PingCastleAutoUpdater\", \"PingCastleAutoUpdater\\PingCastleAutoUpdater.csproj\", \"{0E5D043A-CAA1-40C7-A616-773F347FA43F}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"PingCastleCommon\", \"PingCastleCommon\\PingCastleCommon.csproj\", \"{803FFFA3-DB44-4B28-B0CB-139DCBE898AF}\"\r\nEndProject\r\nGlobal\r\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\r\n\t\tDebug|Any CPU = Debug|Any CPU\r\n\t\tDebug|x64 = Debug|x64\r\n\t\tDebug|x86 = Debug|x86\r\n\t\tRelease|Any CPU = Release|Any CPU\r\n\t\tRelease|x64 = Release|x64\r\n\t\tRelease|x86 = Release|x86\r\n\tEndGlobalSection\r\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\r\n\t\t{52BBA3C2-A74E-4096-B65F-B88C38F92120}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{52BBA3C2-A74E-4096-B65F-B88C38F92120}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{52BBA3C2-A74E-4096-B65F-B88C38F92120}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{52BBA3C2-A74E-4096-B65F-B88C38F92120}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{52BBA3C2-A74E-4096-B65F-B88C38F92120}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{52BBA3C2-A74E-4096-B65F-B88C38F92120}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{52BBA3C2-A74E-4096-B65F-B88C38F92120}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{52BBA3C2-A74E-4096-B65F-B88C38F92120}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{52BBA3C2-A74E-4096-B65F-B88C38F92120}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{52BBA3C2-A74E-4096-B65F-B88C38F92120}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{52BBA3C2-A74E-4096-B65F-B88C38F92120}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{52BBA3C2-A74E-4096-B65F-B88C38F92120}.Release|x86.Build.0 = Release|Any CPU\r\n\t\t{0E5D043A-CAA1-40C7-A616-773F347FA43F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{0E5D043A-CAA1-40C7-A616-773F347FA43F}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{0E5D043A-CAA1-40C7-A616-773F347FA43F}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{0E5D043A-CAA1-40C7-A616-773F347FA43F}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{0E5D043A-CAA1-40C7-A616-773F347FA43F}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{0E5D043A-CAA1-40C7-A616-773F347FA43F}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{0E5D043A-CAA1-40C7-A616-773F347FA43F}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{0E5D043A-CAA1-40C7-A616-773F347FA43F}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{0E5D043A-CAA1-40C7-A616-773F347FA43F}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{0E5D043A-CAA1-40C7-A616-773F347FA43F}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{0E5D043A-CAA1-40C7-A616-773F347FA43F}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{0E5D043A-CAA1-40C7-A616-773F347FA43F}.Release|x86.Build.0 = Release|Any CPU\r\n\t\t{803FFFA3-DB44-4B28-B0CB-139DCBE898AF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{803FFFA3-DB44-4B28-B0CB-139DCBE898AF}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{803FFFA3-DB44-4B28-B0CB-139DCBE898AF}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{803FFFA3-DB44-4B28-B0CB-139DCBE898AF}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{803FFFA3-DB44-4B28-B0CB-139DCBE898AF}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{803FFFA3-DB44-4B28-B0CB-139DCBE898AF}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{803FFFA3-DB44-4B28-B0CB-139DCBE898AF}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{803FFFA3-DB44-4B28-B0CB-139DCBE898AF}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{803FFFA3-DB44-4B28-B0CB-139DCBE898AF}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{803FFFA3-DB44-4B28-B0CB-139DCBE898AF}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{803FFFA3-DB44-4B28-B0CB-139DCBE898AF}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{803FFFA3-DB44-4B28-B0CB-139DCBE898AF}.Release|x86.Build.0 = Release|Any CPU\r\n\tEndGlobalSection\r\n\tGlobalSection(SolutionProperties) = preSolution\r\n\t\tHideSolutionNode = FALSE\r\n\tEndGlobalSection\r\n\tGlobalSection(ExtensibilityGlobals) = postSolution\r\n\t\tSolutionGuid = {EC2B7D83-FCCE-4EF6-B7D1-7B63907C25D7}\r\n\tEndGlobalSection\r\nEndGlobal\r\n"
        },
        {
          "name": "PingCastleAutoUpdater",
          "type": "tree",
          "content": null
        },
        {
          "name": "PingCastleCommon",
          "type": "tree",
          "content": null
        },
        {
          "name": "PingCastleException.cs",
          "type": "blob",
          "size": 0.5869140625,
          "content": "﻿using System;\nusing System.Runtime.Serialization;\n\nnamespace PingCastle\n{\n    [Serializable]\n    public class PingCastleException : Exception\n    {\n        public PingCastleException()\n        {\n        }\n\n        public PingCastleException(string message)\n            : base(message)\n        {\n        }\n\n        public PingCastleException(string message, Exception innerException)\n            : base(message, innerException)\n        {\n        }\n\n        protected PingCastleException(SerializationInfo info, StreamingContext context)\n            : base(info, context)\n        {\n        }\n    }\n}\n"
        },
        {
          "name": "PingCastleFactory.cs",
          "type": "blob",
          "size": 3.078125,
          "content": "﻿using PingCastle.Data;\nusing PingCastle.Exports;\nusing PingCastle.Healthcheck;\nusing PingCastle.Report;\nusing PingCastle.Scanners;\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Reflection;\n\nnamespace PingCastle\n{\n    public class PingCastleFactory\n    {\n        public static Dictionary<string, Type> GetAllScanners()\n        {\n            var output = new Dictionary<string, Type>();\n            foreach (Type type in Assembly.GetAssembly(typeof(PingCastleFactory)).GetExportedTypes())\n            {\n                if (!type.IsAbstract && typeof(IScanner).IsAssignableFrom(type))\n                {\n                    PropertyInfo pi = type.GetProperty(\"Name\");\n                    try\n                    {\n                        IScanner scanner = (IScanner)Activator.CreateInstance(type);\n                        output.Add(scanner.Name, type);\n                    }\n                    catch (Exception ex)\n                    {\n                        Console.WriteLine(\"Unable to load the class \" + type + \" (\" + ex.Message + \")\");\n                    }\n                }\n            }\n            return output;\n        }\n\n        public static IScanner LoadScanner(Type scannerType)\n        {\n            return (IScanner)Activator.CreateInstance(scannerType);\n        }\n\n        public static Dictionary<string, Type> GetAllExport()\n        {\n            var output = new Dictionary<string, Type>();\n            foreach (Type type in Assembly.GetAssembly(typeof(PingCastleFactory)).GetExportedTypes())\n            {\n                if (!type.IsAbstract && typeof(IExport).IsAssignableFrom(type))\n                {\n                    PropertyInfo pi = type.GetProperty(\"Name\");\n                    IExport export = (IExport)Activator.CreateInstance(type);\n                    output.Add(export.Name, type);\n                }\n            }\n            return output;\n        }\n\n        public static IExport LoadExport(Type scannerType)\n        {\n            return (IExport)Activator.CreateInstance(scannerType);\n        }\n\n        public static string GetFilePatternForLoad<T>() where T : IPingCastleReport\n        {\n            if (typeof(T) == typeof(HealthcheckData))\n            {\n                return \"*ad_hc_*.xml\";\n            }\n            throw new NotImplementedException(\"No file pattern known for type \" + typeof(T));\n        }\n       \n        static T GetImplementation<T>()\n        {\n            foreach (Type type in Assembly.GetAssembly(typeof(PingCastleFactory)).GetExportedTypes())\n            {\n                if (typeof(T).IsAssignableFrom(type) && !type.IsAbstract)\n                {\n                    try\n                    {\n                        return (T)Activator.CreateInstance(type);\n                    }\n                    catch (Exception)\n                    {\n                        Trace.WriteLine(\"Unable to instanciate the type \" + type);\n                        throw;\n                    }\n                }\n            }\n            throw new NotImplementedException(\"No implementation found for type \" + typeof(T).ToString());\n        }\n    }\n}\n"
        },
        {
          "name": "Program.cs",
          "type": "blob",
          "size": 65.9658203125,
          "content": "﻿//\n// Copyright (c) Ping Castle. All rights reserved.\n// https://www.pingcastle.com\n//\n// Licensed under the Non-Profit OSL. See LICENSE file in the project root for full license information.\n//\nusing PingCastle.ADWS;\nusing PingCastle.Data;\nusing PingCastle.Exports;\nusing PingCastle.Graph.Reporting;\nusing PingCastle.Healthcheck;\nusing PingCastle.Report;\nusing PingCastle.Scanners;\nusing PingCastle.Cloud.Common;\nusing PingCastle.Cloud.RESTServices.Azure;\nusing PingCastle.Cloud.Tokens;\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Net;\nusing System.Net.NetworkInformation;\nusing System.Reflection;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing PingCastleCommon;\n\nnamespace PingCastle\n{\n    enum PossibleTasks\n    {\n        GenerateKey,\n        Scanner,\n        Export,\n        Carto,\n        Bot,\n        ADHealthCheck,\n        ADConso,\n        HCRules,\n        Regen,\n        Reload,\n        DemoReport,\n        UploadAllRports,\n        FakeReport,\n        CloudHealthCheck,\n        ExportRulesXml,\n    }\n\n    [LicenseProvider(typeof(PingCastle.ADHealthCheckingLicenseProvider))]\n    public class Program : IPingCastleLicenseInfo\n    {\n        \n        Dictionary<PossibleTasks, Func<bool>> actions;\n        Dictionary<PossibleTasks, string[]> requiredSettings;\n        List<PossibleTasks> requestedActions = new List<PossibleTasks>();\n\n        RuntimeSettings settings;\n        Tasks tasks;\n\n        public Program()\n        {\n            settings = new RuntimeSettings();\n            tasks = new Tasks(settings);\n        }\n\n        public static void Main(string[] args)\n        {\n            try\n            {\n                // enable the use of TLS1.0\n                //AppContext.SetSwitch(\"Switch.System.Net.DontEnableSchUseStrongCrypto\", true);\n                // enable the use of TLS1.2 if enabled on the system\n                //AppContext.SetSwitch(\"Switch.System.Net.DontEnableSystemDefaultTlsVersions\", false);\n\n                AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);\n                AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(CurrentDomain_AssemblyResolve);\n                Trace.WriteLine(\"Running on dotnet:\" + Environment.Version);\n                Program program = new Program();\n                program.Run(args);\n                // dispose the http logger\n                HttpClientHelper.EnableLoging(null);\n                if (program.settings.InteractiveMode)\n                {\n                    Console.WriteLine(\"=============================================================================\");\n                    Console.WriteLine(\"Program launched in interactive mode - press any key to terminate the program\");\n                    Console.WriteLine(\"=============================================================================\");\n                    Console.ReadKey();\n                }\n            }\n            catch (Exception ex)\n            {\n                // dispose the http logger\n                HttpClientHelper.EnableLoging(null);\n                Tasks.DisplayException(\"main program\", ex);\n            }\n        }\n\n        static void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)\n        {\n            Tasks.DisplayException(\"application domain\", e.ExceptionObject as Exception);\n        }\n\n        static Assembly CurrentDomain_AssemblyResolve(object sender, ResolveEventArgs args)\n        {\n            // hook required for \"System.Runtime.Serialization.ContractNamespaceAttribute\"\n            var name = new AssemblyName(args.Name);\n            Trace.WriteLine(\"Needing assembly \" + name + \" unknown (\" + args.Name + \")\");\n            return null;\n        }\n\n        private void Run(string[] args)\n        {\n            ADHealthCheckingLicense license = null;\n            Version version = Assembly.GetExecutingAssembly().GetName().Version;\n            Trace.WriteLine(\"PingCastle version \" + version.ToString(4));\n            for (int i = 0; i < args.Length; i++)\n            {\n                if (args[i].Equals(\"--debug-license\", StringComparison.InvariantCultureIgnoreCase))\n                {\n                    EnableLogConsole();\n                }\n                else if (args[i].Equals(\"--license\", StringComparison.InvariantCultureIgnoreCase) && i + 1 < args.Length)\n                {\n                    _serialNumber = args[++i];\n                }\n                else if (args[i].Equals(\"--out\", StringComparison.InvariantCultureIgnoreCase) && i + 1 < args.Length)\n                {\n                    string filename = args[++i];\n                    FilesValidator.CheckPathTraversal(filename);\n    \n                    var fi = new FileInfo(filename);\n                    if (!Directory.Exists(fi.DirectoryName))\n                    {\n                        Directory.CreateDirectory(fi.DirectoryName);\n                    }\n                    Stream stream = File.Open(filename, FileMode.Create, FileAccess.Write, FileShare.Read);\n                    StreamWriter writer = new StreamWriter(stream);\n                    writer.AutoFlush = true;\n                    Console.SetOut(writer);\n                }\n            }\n            Trace.WriteLine(\"Starting the license checking\");\n            try\n            {\n                license = LicenseManager.Validate(typeof(Program), this) as ADHealthCheckingLicense;\n            }\n            catch (Exception ex)\n            {\n                Trace.WriteLine(\"the license check failed - please check that the .config file is in the same directory\");\n                WriteInRed(ex.Message);\n                if (args.Length == 0)\n                {\n                    Console.WriteLine(\"=============================================================================\");\n                    Console.WriteLine(\"Program launched in interactive mode - press any key to terminate the program\");\n                    Console.WriteLine(\"=============================================================================\");\n                    Console.ReadKey();\n                }\n                return;\n            }\n            Trace.WriteLine(\"License checked\");\n            Trace.WriteLine(\"CustomerNotice: \" + license.CustomerNotice);\n            Trace.WriteLine(\"DomainLimitation: \" + license.DomainLimitation);\n            Trace.WriteLine(\"DomainNumberLimit: \" + license.DomainNumberLimit);\n            Trace.WriteLine(\"Edition: \" + license.Edition);\n            Trace.WriteLine(\"EndTime: \" + license.EndTime);\n            if (license.EndTime < DateTime.Now)\n            {\n                WriteInRed(\"The program is unsupported since: \" + license.EndTime.ToString(\"u\") + \")\");\n                if (args.Length == 0)\n                {\n                    Console.WriteLine(\"=============================================================================\");\n                    Console.WriteLine(\"Program launched in interactive mode - press any key to terminate the program\");\n                    Console.WriteLine(\"=============================================================================\");\n                    Console.ReadKey();\n                }\n                return;\n            }\n            if (license.EndTime < DateTime.MaxValue)\n            {\n                Console.WriteLine();\n            }\n            tasks.License = license;\n\n            actions = new Dictionary<PossibleTasks, Func<bool>>\n            {\n                {PossibleTasks.GenerateKey,              tasks.GenerateKeyTask},\n                {PossibleTasks.Scanner,                  tasks.ScannerTask},\n                {PossibleTasks.Export,                   tasks.ExportTask},\n                {PossibleTasks.Carto,                    tasks.CartoTask},\n                //{PossibleTasks.Bot,                      tasks.BotTask},\n                {PossibleTasks.ADHealthCheck,            tasks.AnalysisTask<HealthcheckData>},\n                {PossibleTasks.ADConso,                  tasks.ConsolidationTask<HealthcheckData>},\n                {PossibleTasks.HCRules,                  tasks.HealthCheckRulesTask},\n                {PossibleTasks.Regen,                    tasks.RegenerateHtmlTask},\n                {PossibleTasks.Reload,                   tasks.ReloadXmlReport},\n                {PossibleTasks.DemoReport,               tasks.GenerateDemoReportTask},\n                {PossibleTasks.UploadAllRports,          tasks.UploadAllReportInCurrentDirectory},\n                {PossibleTasks.FakeReport,               tasks.GenerateFakeReport},\n                {PossibleTasks.CloudHealthCheck,         tasks.AnalyzeTask},\n                {PossibleTasks.ExportRulesXml,           tasks.GenerateRuleList},\n            };\n\n            requiredSettings = new Dictionary<PossibleTasks, string[]>\n            {\n                {PossibleTasks.ADHealthCheck,                  new string[] {\"Server\"}},\n                {PossibleTasks.ADConso,                  new string[] {\"Directory\"}},\n                //{PossibleTasks.Scanner,                  new string[] {\"Server\"}},\n                //{PossibleTasks.Export,                  new string[] {\"Server\"}},\n                {PossibleTasks.Carto,                  new string[] {\"Server\"}},\n                {PossibleTasks.Regen,                  new string[] {\"File\"}},\n                {PossibleTasks.Reload,                  new string[] {\"File\"}},\n                {PossibleTasks.UploadAllRports,                  new string[] {\"Directory\"}},\n                {PossibleTasks.FakeReport,                  new string[] {\"Directory\"}},\n                {PossibleTasks.CloudHealthCheck,        new string[] {\"AzureADCredential\"}},\n            };\n\n            LoadCustomRules(tasks);\n            ConsoleMenu.Header = @\"  \\==--O___      PingCastle (Version \" + version.ToString(4) + @\"     \" + ConsoleMenu.GetBuildDateTime(Assembly.GetExecutingAssembly()) + @\")\n   \\  / \\  ¨¨>   Get Active Directory Security at 80% in 20% of the time\n    \\/   \\ ,’    \" + (license.EndTime < DateTime.MaxValue ? \"End of support: \" + license.EndTime.ToString(\"yyyy-MM-dd\") : \"\") + @\"\n     O¨---O      To find out more about PingCastle, visit https://www.pingcastle.com\n      \\ ,'       For online documentation, visit https://helpcenter.netwrix.com/category/pingcastle\n       v         For support and questions:\n                 -\tOpen-source community, visit https://github.com/netwrix/pingcastle/issues\n                 -\tCustomers, visit https://www.netwrix.com/support.html  \";\n\n            if (!ParseCommandLine(args))\n                return;\n            // Trace to file or console may be enabled here\n            Trace.WriteLine(\"[New run]\" + DateTime.Now.ToString(\"u\"));\n            Trace.WriteLine(\"PingCastle version \" + version.ToString(4));\n            Trace.WriteLine(\"Running on dotnet:\" + Environment.Version);\n            if (!String.IsNullOrEmpty(license.DomainLimitation) && !Tasks.compareStringWithWildcard(license.DomainLimitation, settings.Server))\n            {\n                WriteInRed(\"Limitations applies to the --server argument (\" + license.DomainLimitation + \")\");\n                return;\n            }\n            if (!String.IsNullOrEmpty(license.CustomerNotice))\n            {\n                Console.WriteLine(license.CustomerNotice);\n            }\n\n\n            if (!settings.CheckArgs())\n                return;\n\n            foreach (var a in requestedActions)\n            {\n                var r = actions[a].Invoke();\n                if (!r) return;\n            }\n            tasks.CompleteTasks();\n        }\n\n\n        private void LoadCustomRules(Tasks tasks)\n        {\n            if (string.IsNullOrEmpty(tasks.License.Edition))\n                return;\n            if (string.Equals(tasks.License.Edition, \"Auditor\", StringComparison.OrdinalIgnoreCase))\n                return;\n            if (string.Equals(tasks.License.Edition, \"Basic\", StringComparison.OrdinalIgnoreCase))\n                return;\n            PingCastle.Rules.RuleSet<HealthcheckData>.LoadCustomRules();\n        }\n\n        const string basicEditionLicense = \"PC2H4sIAAAAAAAEAGNkYGDgAGKGhqddLpPuMDIDmSVA7MZQxJAKhAoMrgwpDJlAsUyGfIY8ID+fIQ1IBgD5eQzpDM4MiQzFQNkcsFpjBj0wNgCydYHYD6i6BEinAekiIJ0MpHOBMBXISwaakAjUp8BQCjQBpBvsDCBO0/5r9LZOXyzWeNPMG1smHuJw0Ov0zrFRb6kzr5szxTHoqMPxhd+ymjT93k4wtr0ee4H117lTjDwZx+aevZNQsbFQzPWVseOMtvBF/63Zbu0L0ktZd1DF1/NC7NUzX7mTDsjZLLyRLVq4nX+iPhOLqPCuknQr0fiPpgtiVrhNcthX/6yjfDMAJAREbhQBAAA=\";\n        string _serialNumber;\n        public string GetSerialNumber()\n        {\n            if (String.IsNullOrEmpty(_serialNumber))\n            {\n                // try to load it from the configuration file\n                try\n                {\n                    _serialNumber = ADHealthCheckingLicenseSettings.Settings.License;\n                }\n                catch (Exception ex)\n                {\n                    Trace.WriteLine(\"Exception when getting the license string\");\n                    Trace.WriteLine(ex.Message);\n                    Trace.WriteLine(ex.StackTrace);\n                    if (ex.InnerException != null)\n                    {\n                        Trace.WriteLine(ex.InnerException.Message);\n                        Trace.WriteLine(ex.InnerException.StackTrace);\n                    }\n\n                }\n                if (!String.IsNullOrEmpty(_serialNumber))\n                {\n                    Trace.WriteLine(\"Using the license defined in the config file\");\n                    try\n                    {\n                        var license = new ADHealthCheckingLicense(_serialNumber);\n                        return _serialNumber;\n                    }\n                    catch (Exception ex)\n                    {\n                        _serialNumber = null;\n                        Trace.WriteLine(\"Exception when verifying the external license\");\n                        Trace.WriteLine(ex.Message);\n                        Trace.WriteLine(ex.StackTrace);\n                        if (ex.InnerException != null)\n                        {\n                            Trace.WriteLine(ex.InnerException.Message);\n                            Trace.WriteLine(ex.InnerException.StackTrace);\n                        }\n                    }\n\n                }\n            }\n            // fault back to the default license:\n            Trace.WriteLine(\"Using the license inside the product\");\n            _serialNumber = basicEditionLicense;\n            try\n            {\n                var license = new ADHealthCheckingLicense(_serialNumber);\n            }\n            catch (Exception)\n            {\n                throw new PingCastleException(\"Unable to load the license from the .config file and the license embedded in PingCastle is not valid. Check that all files have been copied in the same directory and that you have a valid license\");\n            }\n            return _serialNumber;\n        }\n\n        private void WriteInRed(string data)\n        {\n            Console.ForegroundColor = ConsoleColor.Red;\n            Console.WriteLine(data);\n            Trace.WriteLine(\"[Red]\" + data);\n            Console.ResetColor();\n        }\n\n        // parse command line arguments\n        private bool ParseCommandLine(string[] args)\n        {\n            bool delayedInteractiveMode = false;\n            if (args.Length == 0)\n            {\n                if (!RunInteractiveMode())\n                    return false;\n            }\n            else\n            {\n                Trace.WriteLine(\"Before parsing arguments\");\n                for (int i = 0; i < args.Length; i++)\n                {\n                    switch (args[i])\n                    {\n                        case \"--api-endpoint\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --api-endpoint is mandatory\");\n                                return false;\n                            }\n                            settings.apiEndpoint = args[++i];\n                            {\n                                Uri res;\n                                if (!Uri.TryCreate(settings.apiEndpoint, UriKind.Absolute, out res))\n                                {\n                                    WriteInRed(\"unable to convert api-endpoint into an URI\");\n                                    return false;\n                                }\n                            }\n                            break;\n                        case \"--api-key\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --api-key is mandatory\");\n                                return false;\n                            }\n                            settings.apiKey = args[++i];\n                            break;\n                        case \"--azuread\":\n                            requestedActions.Add(PossibleTasks.CloudHealthCheck);\n                            break;\n                        case \"--bot\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --bot is mandatory\");\n                                return false;\n                            }\n                            settings.botPipe = args[++i];\n                            requestedActions.Add(PossibleTasks.Bot);\n                            break;\n                        case \"--carto\":\n                            requestedActions.Add(PossibleTasks.Carto);\n                            break;\n                        case \"--clientid\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --clientid is mandatory\");\n                                return false;\n                            }\n                            settings.clientid = args[++i];\n                            break;\n                        case \"--center-on\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --center-on is mandatory\");\n                                return false;\n                            }\n                            settings.CenterDomainForSimpliedGraph = args[++i];\n                            break;\n                        case \"--datefile\":\n                            HealthcheckData.UseDateInFileName();\n                            break;\n                        case \"--debug-license\":\n                            break;\n                        case \"--demo-reports\":\n                            requestedActions.Add(PossibleTasks.DemoReport);\n                            break;\n                        case \"--doNotTestSMBv1\":\n                            SmbScanner.DoNotTestSMBv1 = true;\n                            break;\n                        case \"--encrypt\":\n                            settings.EncryptReport = true;\n                            break;\n                        case \"--export-rules\":\n                            requestedActions.Add(PossibleTasks.ExportRulesXml);\n                            break;\n                        case \"--foreigndomain\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --foreigndomain is mandatory\");\n                                return false;\n                            }\n                            ForeignUsersScanner.EnumInboundSid = args[++i];\n                            break;\n                        case \"--explore-trust\":\n                            settings.ExploreTerminalDomains = true;\n                            break;\n                        case \"--explore-forest-trust\":\n                            settings.ExploreForestTrust = true;\n                            break;\n                        case \"--explore-exception\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --explore-exception is mandatory\");\n                                return false;\n                            }\n                            settings.DomainToNotExplore = new List<string>(args[++i].Split(','));\n                            break;\n                        case \"--export\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --export is mandatory\");\n                                return false;\n                            }\n                            {\n                                var exports = PingCastleFactory.GetAllExport();\n                                string exportname = args[++i];\n                                if (!exports.ContainsKey(exportname))\n                                {\n                                    string list = null;\n                                    var allexports = new List<string>(exports.Keys);\n                                    allexports.Sort();\n                                    foreach (string name in allexports)\n                                    {\n                                        if (list != null)\n                                            list += \",\";\n                                        list += name;\n                                    }\n                                    WriteInRed(\"Unsupported exportname - available scanners are:\" + list);\n\n                                }\n                                settings.Export = exports[exportname];\n                                requestedActions.Add(PossibleTasks.Export);\n                            }\n                            break;\n                        case \"--filter-date\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --filter-date is mandatory\");\n                                return false;\n                            }\n                            DateTime date;\n                            if (!DateTime.TryParse(args[++i], out date))\n                            {\n                                WriteInRed(\"Unable to parse the date \\\"\" + args[i] + \"\\\" - try entering 2016-01-01\");\n                                return false;\n                            }\n                            settings.FilterReportDate = date;\n                            break;\n                        case \"--regen-report\":\n                            requestedActions.Add(PossibleTasks.Regen);\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --regen-report is mandatory\");\n                                return false;\n                            }\n                            settings.InputFile = args[++i];\n                            break;\n                        case \"--generate-fake-reports\":\n                            requestedActions.Add(PossibleTasks.FakeReport);\n                            break;\n                        case \"--generate-key\":\n                            requestedActions.Add(PossibleTasks.GenerateKey);\n                            break;\n                        case \"--healthcheck\":\n                            requestedActions.Add(PossibleTasks.ADHealthCheck);\n                            break;\n                        case \"--hc-conso\":\n                            requestedActions.Add(PossibleTasks.ADConso);\n                            break;\n                        case \"--help\":\n                            DisplayHelp();\n                            return false;\n                        case \"--I-swear-I-paid-win7-support\":\n                            //Healthcheck.Rules.HeatlcheckRuleStaledObsoleteWin7.IPaidSupport = true;\n                            Console.WriteLine(\"Sorry Extended support for Win7 is not available anymmore.\\n--I-swear-I-paid-win7-support is ignored\");\n                            break;\n                        case \"--I-swear-I-paid-win8-support\":\n                            Healthcheck.Rules.HeatlcheckRuleStaledObsoleteWin8.IPaidSupportWin8 = true;\n                            break;\n                        case \"--I-swear-I-paid-win2012-support\":\n                            Healthcheck.Rules.HeatlcheckRuleStaledObsolete2012.IPaidSupportWin2012 = true;\n                            break;\n                        case \"--interactive\":\n                            delayedInteractiveMode = true;\n                            break;\n                        case \"--level\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --level is mandatory\");\n                                return false;\n                            }\n                            try\n                            {\n                                tasks.ExportLevel = (PingCastleReportDataExportLevel)Enum.Parse(typeof(PingCastleReportDataExportLevel), args[++i]);\n                            }\n                            catch (Exception)\n                            {\n                                WriteInRed(\"Unable to parse the level [\" + args[i] + \"] to one of the predefined value (\" + String.Join(\",\", Enum.GetNames(typeof(PingCastleReportDataExportLevel))) + \")\");\n                                return false;\n                            }\n                            break;\n                        case \"--license\":\n                            i++;\n                            break;\n                        case \"--log\":\n                            Tasks.EnableLogFile();\n                            break;\n                        case \"--log-console\":\n                            EnableLogConsole();\n                            break;\n                        case \"--log-samba\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for -log-samba is mandatory\");\n                                return false;\n                            }\n                            LinuxSidResolver.LogLevel = args[++i];\n                            break;\n                        case \"--max-nodes\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --max-nodes is mandatory\");\n                                return false;\n                            }\n                            {\n                                int maxNodes;\n                                if (!int.TryParse(args[++i], out maxNodes))\n                                {\n                                    WriteInRed(\"argument for --max-nodes is not a valid value (typically: 1000)\");\n                                    return false;\n                                }\n                                ReportGenerator.MaxNodes = maxNodes;\n                            }\n                            break;\n                        case \"--max-depth\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --max-depth is mandatory\");\n                                return false;\n                            }\n                            {\n                                int maxDepth;\n                                if (!int.TryParse(args[++i], out maxDepth))\n                                {\n                                    WriteInRed(\"argument for --max-depth is not a valid value (typically: 30)\");\n                                    return false;\n                                }\n                                ReportGenerator.MaxDepth = maxDepth;\n                            }\n                            break;\n                        case \"--no-enum-limit\":\n                            ReportHealthCheckSingle.MaxNumberUsersInHtmlReport = int.MaxValue;\n                            break;\n                        case \"--no-csp-header\":\n                            ReportBase.NoCspHeader = true;\n                            break;\n                        case \"--node\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --node is mandatory\");\n                                return false;\n                            }\n                            tasks.NodesToInvestigate = new List<string>(Regex.Split(args[++i], @\"(?<!(?<!\\\\)*\\\\)\\,\"));\n                            break;\n                        case \"--nodes\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --nodes is mandatory\");\n                                return false;\n                            }\n                            tasks.NodesToInvestigate = new List<string>(File.ReadAllLines(args[++i]));\n                            break;\n                        case \"--notifyMail\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --notifyMail is mandatory\");\n                                return false;\n                            }\n                            settings.mailNotification = args[++i];\n                            break;\n                        case \"--nslimit\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --nslimit is mandatory\");\n                                return false;\n                            }\n                            if (!int.TryParse(args[++i], out NullSessionScanner.NullSessionEnumerationLimit))\n                            {\n                                WriteInRed(\"argument for --nslimit is not a valid value (typically: 5)\");\n                                return false;\n                            }\n                            break;\n                        case \"--out\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --out is mandatory\");\n                                return false;\n                            }\n                            i++;\n                            // argument processed at the beginning of the program\n                            break;\n                        case \"--pagesize\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --pagesize is mandatory\");\n                                return false;\n                            }\n                            if (!int.TryParse(args[++i], out LDAPConnection.PageSize))\n                            {\n                                WriteInRed(\"argument for --pagesize is not a valid value (typically: 500)\");\n                                return false;\n                            }\n                            break;\n                        case \"--p12-file\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --p12-file is mandatory\");\n                                return false;\n                            }\n                            settings.p12file = args[++i];\n                            break;\n                        case \"--p12-pass\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --p12-pass is mandatory\");\n                                return false;\n                            }\n                            settings.p12passSet = true;\n                            settings.p12pass = args[++i];\n                            break;\n                        case \"--password\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --password is mandatory\");\n                                return false;\n                            }\n                            var p = args[++i];\n                            settings.Password = new System.Security.SecureString();\n                            foreach (var c in p.ToCharArray())\n                                settings.Password.AppendChar(c);\n                            break;\n                        case \"--port\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --port is mandatory\");\n                                return false;\n                            }\n                            int port;\n                            if (!int.TryParse(args[++i], out port))\n                            {\n                                WriteInRed(\"argument for --port is not a valid value (typically: 9389)\");\n                                return false;\n                            }\n                            settings.Port = port;\n                            break;\n                        case \"--private-key\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --private-key is mandatory\");\n                                return false;\n                            }\n                            settings.privateKey = args[++i];\n                            break;\n                        case \"--protocol\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --protocol is mandatory\");\n                                return false;\n                            }\n                            try\n                            {\n                                ADWebService.ConnectionType = (ADConnectionType)Enum.Parse(typeof(ADConnectionType), args[++i]);\n                            }\n                            catch (Exception ex)\n                            {\n                                Trace.WriteLine(ex.Message);\n                                WriteInRed(\"Unable to parse the protocol [\" + args[i] + \"] to one of the predefined value (\" + String.Join(\",\", Enum.GetNames(typeof(ADConnectionType))) + \")\");\n                                return false;\n                            }\n                            break;\n                        case \"--quota\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --quota is mandatory\");\n                                return false;\n                            }\n                            {\n                                int quota;\n                                if (!int.TryParse(args[++i], out quota))\n                                {\n                                    WriteInRed(\"argument for --quota is not a valid value (typically: 500)\");\n                                    return false;\n                                }\n                                ADConnection.RecordPerSeconds = quota;\n                            }\n                            break;\n                        case \"--reachable\":\n                            settings.AnalyzeReachableDomains = true;\n                            break;\n                        case \"--rules\":\n                            requestedActions.Add(PossibleTasks.HCRules);\n                            break;\n                        case \"--scanner\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --scanner is mandatory\");\n                                return false;\n                            }\n                            {\n                                var scanners = PingCastleFactory.GetAllScanners();\n                                string scannername = args[++i];\n                                if (!scanners.ContainsKey(scannername))\n                                {\n                                    string list = null;\n                                    var allscanners = new List<string>(scanners.Keys);\n                                    allscanners.Sort();\n                                    foreach (string name in allscanners)\n                                    {\n                                        if (list != null)\n                                            list += \",\";\n                                        list += name;\n                                    }\n                                    WriteInRed(\"Unsupported scannername - available scanners are:\" + list);\n                                    return false;\n                                }\n                                settings.Scanner = scanners[scannername];\n                                requestedActions.Add(PossibleTasks.Scanner);\n                            }\n                            break;\n                        case \"--scmode-all\":\n                            ScannerBase.ScanningMode = 1;\n                            break;\n                        case \"--scmode-single\":\n                            ScannerBase.ScanningMode = 2;\n                            break;\n                        case \"--scmode-workstation\":\n                            ScannerBase.ScanningMode = 3;\n                            break;\n                        case \"--scmode-server\":\n                            ScannerBase.ScanningMode = 4;\n                            break;\n                        case \"--scmode-dc\":\n                            ScannerBase.ScanningMode = 5;\n                            break;\n                        case \"--scmode-file\":\n                            ScannerBase.ScanningMode = 6;\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --scmode-file is mandatory\");\n                                return false;\n                            }\n                            settings.InputFile = args[++i];\n                            break;\n                        case \"--sendxmlTo\":\n                        case \"--sendXmlTo\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --sendXmlTo is mandatory\");\n                                return false;\n                            }\n                            settings.sendXmlTo = args[++i];\n                            break;\n                        case \"--sendhtmlto\":\n                        case \"--sendHtmlTo\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --sendHtmlTo is mandatory\");\n                                return false;\n                            }\n                            settings.sendHtmlTo = args[++i];\n                            break;\n                        case \"--sendallto\":\n                        case \"--sendAllTo\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --sendAllTo is mandatory\");\n                                return false;\n                            }\n                            settings.sendAllTo = args[++i];\n                            break;\n                        case \"--server\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --server is mandatory\");\n                                return false;\n                            }\n                            settings.Server = args[++i];\n                            break;\n                        case \"--skip-null-session\":\n                            HealthcheckAnalyzer.SkipNullSession = true;\n                            break;\n                        case \"--skip-dc-rpc\":\n                            HealthcheckAnalyzer.SkipRPC = true;\n                            break;\n                        case \"--reload-report\":\n                        case \"--slim-report\":\n                            requestedActions.Add(PossibleTasks.Reload);\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --slim-report is mandatory\");\n                                return false;\n                            }\n                            settings.InputFile = args[++i];\n                            break;\n                        case \"--smtplogin\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --smtplogin is mandatory\");\n                                return false;\n                            }\n                            settings.smtpLogin = args[++i];\n                            break;\n                        case \"--smtppass\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --smtppass is mandatory\");\n                                return false;\n                            }\n                            settings.smtpPassword = args[++i];\n                            break;\n                        case \"--smtptls\":\n                            settings.smtpTls = true;\n                            break;\n                        case \"--tenantid\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --tenantid is mandatory\");\n                                return false;\n                            }\n                            settings.tenantid = args[++i];\n                            break;\n                        case \"--thumbprint\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --thumbprint is mandatory\");\n                                return false;\n                            }\n                            settings.thumbprint = args[++i];\n                            break;\n                        case \"--upload-all-reports\":\n                            requestedActions.Add(PossibleTasks.UploadAllRports);\n                            break;\n                        case \"--user\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --user is mandatory\");\n                                return false;\n                            }\n                            i++;\n                            if (args[i].Contains(\"\\\\\"))\n                            {\n                                int pos = args[i].IndexOf('\\\\');\n                                settings.Userdomain = args[i].Substring(0, pos);\n                                settings.User = args[i].Substring(pos + 1);\n                            }\n                            else\n                            {\n                                settings.User = args[i];\n                                if (!settings.User.Contains(\"@\"))\n                                {\n                                    Console.ForegroundColor = ConsoleColor.Yellow;\n                                    Console.WriteLine(\"Beware: the user is not on the form domain\\\\user or user@domain.com. Most likely the GPO part will trigger an access denied error.\");\n                                    Console.ResetColor();\n                                }\n                            }\n                            break;\n                        case \"--use-prt\":\n                            settings.usePrt = true;\n                            break;\n                        case \"--webdirectory\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --webdirectory is mandatory\");\n                                return false;\n                            }\n                            settings.sharepointdirectory = args[++i];\n                            break;\n                        case \"--webuser\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --webuser is mandatory\");\n                                return false;\n                            }\n                            settings.sharepointuser = args[++i];\n                            break;\n                        case \"--webpassword\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --webpassword is mandatory\");\n                                return false;\n                            }\n                            settings.sharepointpassword = args[++i];\n                            break;\n                        case \"--xmls\":\n                            if (i + 1 >= args.Length)\n                            {\n                                WriteInRed(\"argument for --xmls is mandatory\");\n                                return false;\n                            }\n                            settings.InputDirectory = args[++i];\n                            break;\n                        default:\n                            WriteInRed(\"unknow argument: \" + args[i]);\n                            DisplayHelp();\n                            return false;\n                    }\n                }\n                Trace.WriteLine(\"After parsing arguments\");\n            }\n            if (requestedActions.Count == 0 && !delayedInteractiveMode)\n            {\n                WriteInRed(\"You must choose at least one value among --healthcheck --azuread --hc-conso --advanced-export --advanced-report --nullsession --carto\");\n                DisplayHelp();\n                return false;\n            }\n            Trace.WriteLine(\"Things to do OK\");\n            if (delayedInteractiveMode)\n            {\n                RunInteractiveMode();\n            }\n            foreach (var action in requestedActions)\n            {\n                if (requiredSettings.ContainsKey(action))\n                {\n                    var r = requiredSettings[action];\n                    if (r.Length > 0)\n                    {\n                        var state = settings.EnsureDataCompleted(r);\n                        if (state != DisplayState.Run)\n                        {\n                            DisplayHelp();\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n\n        private void EnableLogConsole()\n        {\n            Trace.AutoFlush = true;\n            TextWriterTraceListener listener = new TextWriterTraceListener(Console.Out);\n            Trace.Listeners.Add(listener);\n        }\n\n        // interactive interface\n        private bool RunInteractiveMode()\n        {\n            settings.InteractiveMode = true;\n            Stack<DisplayState> states = new Stack<DisplayState>();\n            var state = DisplayState.MainMenu;\n\n            states.Push(state);\n            while (states.Count > 0 && states.Peek() != DisplayState.Run)\n            {\n                switch (state)\n                {\n                    case DisplayState.MainMenu:\n                        state = DisplayMainMenu();\n                        break;\n                    case DisplayState.ScannerMenu:\n                        state = settings.DisplayScannerMenu();\n                        break;\n                    case DisplayState.AvancedMenu:\n                        state = DisplayAdvancedMenu();\n                        break;\n                    case DisplayState.ProtocolMenu:\n                        state = DisplayProtocolMenu();\n                        break;\n                    case DisplayState.ExportMenu:\n                        state = settings.DisplayExportMenu();\n                        break;\n                    default:\n                        // defensive programming\n                        if (state != DisplayState.Exit)\n                        {\n                            Console.WriteLine(\"No implementation of state \" + state);\n                            state = DisplayState.Exit;\n                        }\n                        break;\n                }\n                if (state == DisplayState.Exit)\n                {\n                    states.Pop();\n                    if (states.Count > 0)\n                        state = states.Peek();\n                }\n                else\n                {\n                    states.Push(state);\n                }\n            }\n            return (states.Count > 0);\n        }\n\n        DisplayState DisplayMainMenu()\n        {\n            requestedActions.Clear();\n\n            List<ConsoleMenuItem> choices = new List<ConsoleMenuItem>() {\n                new ConsoleMenuItem(\"healthcheck\",\"Score the risk of a domain\", \"This is the main functionnality of PingCastle. In a matter of minutes, it produces a report which will give you an overview of your Active Directory security. This report can be generated on other domains by using the existing trust links.\"),\n                new ConsoleMenuItem(\"azuread\",\"Score the risk of AzureAD\", \"This is the main functionnality of PingCastle. In a matter of minutes, it produces a report which will give you an overview of your AzureAD security.\"),\n                new ConsoleMenuItem(\"conso\",\"Aggregate multiple reports into a single one\", \"With many healthcheck reports, you can get a single report for a whole scope. Maps will be generated.\"),\n                new ConsoleMenuItem(\"carto\",\"Build a map of all interconnected domains\", \"It combines the healthcheck reports that would be run on all trusted domains and then the conso option. But lighter and then faster.\"),\n                new ConsoleMenuItem(\"scanner\",\"Perform specific security checks on workstations\", \"You can know your local admins, if Bitlocker is properly configured, discover unprotect shares, ... A menu will be shown to select the right scanner.\"),\n                new ConsoleMenuItem(\"export\",\"Export users or computers\", \"Don't involve your admin and get the list of users or computers you want to get. A menu will be shown to select the export.\"),\n                new ConsoleMenuItem(\"advanced\",\"Open the advanced menu\", \"This is the place you want to configure PingCastle without playing with command line switches.\"),\n            };\n\n            ConsoleMenu.Title = \"What do you want to do?\";\n            ConsoleMenu.Information = \"Using interactive mode.\\r\\nDo not forget that there are other command line switches like --help that you can use\";\n            int choice = ConsoleMenu.SelectMenu(choices);\n            if (choice == 0)\n                return DisplayState.Exit;\n\n            string whattodo = choices[choice - 1].Choice;\n            switch (whattodo)\n            {\n                default:\n                case \"healthcheck\":\n                    requestedActions.Add(PossibleTasks.ADHealthCheck);\n                    return DisplayState.Run;\n                case \"azuread\":\n                    requestedActions.Add(PossibleTasks.CloudHealthCheck);\n                    return DisplayState.Run;\n                case \"carto\":\n                    requestedActions.Add(PossibleTasks.Carto);\n                    return DisplayState.Run;\n                case \"conso\":\n                    requestedActions.Add(PossibleTasks.ADConso);\n                    return DisplayState.Run;\n                case \"scanner\":\n                    requestedActions.Add(PossibleTasks.Scanner);\n                    return DisplayState.ScannerMenu;\n                case \"export\":\n                    requestedActions.Add(PossibleTasks.Export);\n                    return DisplayState.ExportMenu;\n                case \"advanced\":\n                    return DisplayState.AvancedMenu;\n            }\n        }\n\n        DisplayState DisplayAdvancedMenu()\n        {\n            List<ConsoleMenuItem> choices = new List<ConsoleMenuItem>() {\n                new ConsoleMenuItem(\"protocol\",\"Change the protocol used to query the AD (LDAP, ADWS, ...)\"),\n                new ConsoleMenuItem(\"hcrules\",\"Generate a report containing all rules applied by PingCastle\"),\n                new ConsoleMenuItem(\"generatekey\",\"Generate RSA keys used to encrypt and decrypt reports\"),\n                new ConsoleMenuItem(\"noenumlimit\",\"Remove the 100 items limitation in healthcheck reports\"),\n                new ConsoleMenuItem(\"decrypt\",\"Decrypt a xml report\"),\n                new ConsoleMenuItem(\"regenerate\",\"Regenerate the html report based on the xml report\"),\n                new ConsoleMenuItem(\"log\",\"Enable logging (log is \" + (Trace.Listeners.Count > 1 ? \"enabled\":\"disabled\") + \")\"),\n            };\n\n            ConsoleMenu.Title = \"What do you want to do?\";\n            int choice = ConsoleMenu.SelectMenu(choices);\n            if (choice == 0)\n                return DisplayState.Exit;\n\n            string whattodo = choices[choice - 1].Choice;\n            switch (whattodo)\n            {\n                default:\n                case \"protocol\":\n                    return DisplayState.ProtocolMenu;\n                case \"hcrules\":\n                    requestedActions.Add(PossibleTasks.HCRules);\n                    return DisplayState.Run;\n                case \"generatekey\":\n                    requestedActions.Add(PossibleTasks.GenerateKey);\n                    return DisplayState.Run;\n                case \"decrypt\":\n                    requestedActions.Add(PossibleTasks.Reload);\n                    return DisplayState.Run;\n                case \"regenerate\":\n                    requestedActions.Add(PossibleTasks.Regen);\n                    return DisplayState.Run;\n                case \"log\":\n                    if (Trace.Listeners.Count <= 1)\n                        Tasks.EnableLogFile();\n                    return DisplayState.Exit;\n                case \"noenumlimit\":\n                    ReportHealthCheckSingle.MaxNumberUsersInHtmlReport = int.MaxValue;\n                    ConsoleMenu.Notice = \"Limitation removed\";\n                    return DisplayState.Exit;\n            }\n        }\n\n        DisplayState DisplayProtocolMenu()\n        {\n            List<ConsoleMenuItem> choices = new List<ConsoleMenuItem>() {\n                new ConsoleMenuItem(\"ADWSThenLDAP\",\"default: ADWS then if failed, LDAP\"),\n                new ConsoleMenuItem(\"ADWSOnly\",\"use only ADWS\"),\n                new ConsoleMenuItem(\"LDAPOnly\",\"use only LDAP\"),\n                new ConsoleMenuItem(\"LDAPThenADWS\",\"LDAP then if failed, ADWS\"),\n            };\n\n            ConsoleMenu.Title = \"What protocol do you want to use?\";\n            ConsoleMenu.Information = \"ADWS (Active Directory Web Service - tcp/9389) is the fastest protocol but is limited 5 sessions in parallele and a 30 minutes windows. LDAP is more stable but slower.\\r\\nCurrent protocol: [\" + ADWebService.ConnectionType + \"]\";\n            int defaultChoice = 1;\n            for (int i = 0; i < choices.Count; i++)\n            {\n                if (choices[i].Choice == ADWebService.ConnectionType.ToString())\n                    defaultChoice = 1 + i;\n            }\n            int choice = ConsoleMenu.SelectMenu(choices, defaultChoice);\n            if (choice == 0)\n                return DisplayState.Exit;\n\n            string whattodo = choices[choice - 1].Choice;\n            ADWebService.ConnectionType = (ADConnectionType)Enum.Parse(typeof(ADConnectionType), whattodo);\n            return DisplayState.Exit;\n        }\n\n\n        private static void DisplayHelp()\n        {\n            Console.WriteLine(\"switch:\");\n            Console.WriteLine(\"  --help              : display this message\");\n            Console.WriteLine(\"  --interactive       : force the interactive mode\");\n            Console.WriteLine(\"  --log               : generate a log file\");\n            Console.WriteLine(\"  --log-console       : add log to the console\");\n            Console.WriteLine(\"  --log-samba <option>: enable samba login (example: 10)\");\n            Console.WriteLine(\"  --api-endpoint <>   : to upload report via api call eg: http://server\");\n            Console.WriteLine(\"  --api-key  <key>    : and using the api key as registered\");\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"Common options when connecting to the AD\");\n            Console.WriteLine(\"  --server <server>   : use this server (default: current domain controller)\");\n            Console.WriteLine(\"                        the special value * or *.forest do the healthcheck for all domains\");\n            Console.WriteLine(\"  --port <port>       : the port to use for ADWS or LDAP (default: 9389 or 389)\");\n            Console.WriteLine(\"  --user <user>       : use this user (default: integrated authentication)\");\n            Console.WriteLine(\"  --password <pass>   : use this password (default: asked on a secure prompt)\");\n            Console.WriteLine(\"  --protocol <proto>  : selection the protocol to use among LDAP or ADWS (fastest)\");\n            Console.WriteLine(\"                      : ADWSThenLDAP (default), ADWSOnly, LDAPOnly, LDAPThenADWS\");\n            Console.WriteLine(\"  --pagesize <size>   : change the default LDAP page size - default is 500\");\n            Console.WriteLine(\"  --quota <num>       : Number of LDAP items per second that will be processed - default unlimited\");\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"  --carto             : perform a quick cartography with domains surrounding\");\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"  --healthcheck       : perform the healthcheck (step1)\");\n            Console.WriteLine(\"    --explore-trust   : on domains of a forest, after the healthcheck, do the hc on all trusted domains except domains of the forest and forest trusts\");\n            Console.WriteLine(\"    --explore-forest-trust : on root domain of a forest, after the healthcheck, do the hc on all forest trusts discovered\");\n            Console.WriteLine(\"    --explore-trust and --explore-forest-trust can be run together\");\n            Console.WriteLine(\"    --explore-exception <domains> : comma separated values of domains that will not be explored automatically\");\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"    --datefile        : insert the date into the report filename\");\n            Console.WriteLine(\"    --encrypt         : use an RSA key stored in the .config file to crypt the content of the xml report\");\n            Console.WriteLine(\"    --level <level>   : specify the amount of data found in the xml file\");\n            Console.WriteLine(\"                      : level: Full, Normal, Light\");\n            Console.WriteLine(\"    --no-enum-limit   : remove the max 100 users limitation in html report\");\n            Console.WriteLine(\"    --reachable       : add reachable domains to the list of discovered domains\");\n            Console.WriteLine(\"    --sendXmlTo <emails>: send xml reports to a mailbox (comma separated email)\");\n            Console.WriteLine(\"    --sendHtmlTo <emails>: send html reports to a mailbox\");\n            Console.WriteLine(\"    --sendAllTo <emails>: send html reports to a mailbox\");\n            Console.WriteLine(\"    --notifyMail <emails>: add email notification when the mail is received\");\n            Console.WriteLine(\"    --smtplogin <user>: allow smtp credentials ...\");\n            Console.WriteLine(\"    --smtppass <pass> : ... to be entered on the command line\");\n            Console.WriteLine(\"    --smtptls         : enable TLS/SSL in SMTP if used on other port than 465 and 587\");\n            Console.WriteLine(\"    --skip-null-session: do not test for null session\");\n            Console.WriteLine(\"    --skip-dc-rpc     : do not test for rpc on DC\");\n            Console.WriteLine(\"    --webdirectory <dir>: upload the xml report to a webdav server\");\n            Console.WriteLine(\"    --webuser <user>  : optional user and password\");\n            Console.WriteLine(\"    --webpassword <password>\");\n            Console.WriteLine(\"    --max-depth       : maximum number of relation to explore (default:30)\");\n            Console.WriteLine(\"    --max-nodes       : maximum number of node to include (default:1000)\");\n            Console.WriteLine(\"    --node <node>     : create a report based on a object\");\n            Console.WriteLine(\"                      : example: \\\"cn=name\\\" or \\\"name\\\"\");\n            Console.WriteLine(\"    --nodes <file>    : create x report based on the nodes listed on a file\");\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"    --I-swear-I-paid-win7-support : meaningless\");\n            Console.WriteLine(\"    --I-swear-I-paid-win8-support : meaningless\");\n            Console.WriteLine(\"    --I-swear-I-paid-win2012-support : meaningless\");\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"--rules               : Generate an html containing all the rules used by PingCastle\");\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"  --generate-key      : generate and display a new RSA key for encryption\");\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"  --no-csp-header     : disable the Content Security Policy header. More risks but enables styles & js when stored on a webserver\");\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"  --hc-conso          : consolidate multiple healthcheck xml reports (step2)\");\n            Console.WriteLine(\"    --center-on <domain> : center the simplified graph on this domain\");\n            Console.WriteLine(\"                         default is the domain with the most links\");\n            Console.WriteLine(\"    --xmls <path>     : specify the path containing xml (default: current directory)\");\n            Console.WriteLine(\"    --filter-date <date>: filter report generated after the date.\");\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"  --regen-report <xml> : regenerate a html report based on a xml report\");\n            Console.WriteLine(\"  --reload-report <xml> : regenerate a xml report based on a xml report\");\n            Console.WriteLine(\"                          any healthcheck switches (send email, ..) can be reused\");\n            Console.WriteLine(\"    --level <level>   : specify the amount of data found in the xml file\");\n            Console.WriteLine(\"                      : level: Full, Normal, Light (default: Normal)\");\n            Console.WriteLine(\"    --encrypt         : use an RSA key stored in the .config file to crypt the content of the xml report\");\n            Console.WriteLine(\"                        the absence of this switch on an encrypted report will produce a decrypted report\");\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"  --scanner <type>    : perform a scan on one of all computers of the domain (using --server)\");\n            Console.WriteLine(\"\");\n            \n            var scanner = PingCastleFactory.GetAllScanners();\n            var scannerNames = new List<string>(scanner.Keys);\n            scannerNames.Sort();\n            foreach (var scannerName in scannerNames)\n            {\n                Type scannerType = scanner[scannerName];\n                IScanner iscanner = PingCastleFactory.LoadScanner(scannerType);\n                Console.ForegroundColor = ConsoleColor.Yellow;\n                Console.WriteLine(iscanner.Name);\n                Console.ResetColor();\n                Console.WriteLine(iscanner.Description);\n            }\n            Console.WriteLine(\"  options for scanners:\");\n            Console.WriteLine(\"    --scmode-all      : scan all computers (default)\");\n            Console.WriteLine(\"    --scmode-single   : force scanner to check one single computer\");\n            Console.WriteLine(\"    --scmode-workstation : force scanner to check workstations\");\n            Console.WriteLine(\"    --scmode-server   : force scanner to check servers\");\n            Console.WriteLine(\"    --scmode-dc       : force scanner to check dc\");\n            Console.WriteLine(\"    --scmode-file <file> : force scanner to use the computer from file\");\n            Console.WriteLine(\"    --nslimit <number>: Limit the number of users to enumerate (default: unlimited)\");\n            Console.WriteLine(\"    --foreigndomain <sid> : foreign domain targeted using its FQDN or sids\");\n            Console.WriteLine(\"                        Example of SID: S-1-5-21-4005144719-3948538632-2546531719\");\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"  --export <type>    : perform an export of objects of the domain (using --server)\");\n            var exports = PingCastleFactory.GetAllExport();\n            var exportNames = new List<string>(exports.Keys);\n            exportNames.Sort();\n            foreach (var exportName in exportNames)\n            {\n                Type exportType = exports[exportName];\n                IExport iexport = PingCastleFactory.LoadExport(exportType);\n                Console.ForegroundColor = ConsoleColor.Yellow;\n                Console.WriteLine(iexport.Name);\n                Console.ResetColor();\n                Console.WriteLine(iexport.Description);\n            }\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"Common options when connecting to AzureAD\");\n            Console.WriteLine(\"     --tenantid xx: specify the tenant id to use. Requiered for cert auth\");\n            Console.WriteLine(\"Authentication\");\n            Console.WriteLine(\"  --use-prt          : use prt to log on\");\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"Certificate authentication\");\n            Console.WriteLine(\"   --clientid xxx : specify the client id to which the certificate is associated\");\n            Console.WriteLine(\"   With private key\");\n            Console.WriteLine(\"     --thumbprint xxx : specify the thumprint of the certificate configured\");\n            Console.WriteLine(\"     --private-key xxx : specify the key file to use (PKCS8)\");\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"   With P12\");\n            Console.WriteLine(\"     --p12-file xxx : specify the P12 file to use\");\n            Console.WriteLine(\"     --p12-pass xxx : specify the password to use\");\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"  --upload-all-reports: use the API to upload all reports in the current directory\");\n            Console.WriteLine(\"    --api-endpoint <> : upload report via api call eg: http://server\");\n            Console.WriteLine(\"    --api-key  <key>  : and using the api key as registered\");\n            Console.WriteLine(\"                        Note: do not forget to set --level Full to send all the information available\");\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"  --export-rules : export all rule in a single xml file\");\n\n\n        }\n    }\n\n\n}\n\n\n"
        },
        {
          "name": "Properties",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.49609375,
          "content": "# PingCastle by Netwrix\n\n## Acquisition Announcement\n\nWe are excited to announce that PingCastle has been acquired by [Netwrix](http://www.netwrix.com/)!\n\nNetwrix understands that commercial acquisitions of open source solutions can create concerns within the community. We are committed to actively stewarding the project and maintaining the availability of the open source edition.\n\nPingCastle has a long history of offering both open source and commercial editions. Netwrix is not only committed to preserving the open source project but also increasing development resources to enhance both the open source and commercial versions with new features and capabilities.\n\nNetwrix, an industry leader in Active Directory security solutions and other cybersecurity solutions, ensures a brighter digital future for more than 13,500 customers worldwide. Netwrix empowers security professionals to face digital threats with confidence by enabling them to identify and protect sensitive data as well as to detect, respond to, and recover from attacks.\n\n## Introduction\n\nThe risk level regarding Active Directory security has changed.\nSeveral vulnerabilities have been made popular with tools like [mimikatz](https://github.com/gentilkiwi/mimikatz) or sites likes [adsecurity.org](http://adsecurity.org/).\n\nPingCastle is a tool designed to assess quickly the Active Directory security level with a methodology based on risk assessment and a maturity framework.\nIt does not aim at a perfect evaluation but rather as an efficiency compromise.\n\n```plain\n  \\==--O___      PingCastle (Version 3.3.0.0     9/13/2024 7:25:24 PM)\n   \\  / \\  \"\">   Get Active Directory Security at 80% in 20% of the time\n    \\/   \\ ,'    End of support: 1/31/2026\n     O\"---O      To find out more about PingCastle, visit https://www.pingcastle.com         \n      \\ ,'       For online documentation, visit https://helpcenter.netwrix.com/category/pingcastle\n       v         For support and questions:\n                 -\tOpen-source community, visit https://github.com/netwrix/pingcastle/issues\n                 -\tCustomers, visit https://www.netwrix.com/support.html  \t   \nWhat do you want to do?\n=======================\nUsing interactive mode.\nDo not forget that there are other command line switches like --help that you can use\n  1-healthcheck-Score the risk of a domain\n  2-azuread    -Score the risk of AzureAD\n  3-conso      -Aggregate multiple reports into a single one\n  4-carto      -Build a map of all interconnected domains\n  5-scanner    -Perform specific security checks on workstations\n  6-export     -Export users or computers\n  7-advanced   -Open the advanced menu\n  0-Exit\n==============================\nThis is the main functionnality of PingCastle. In a matter of minutes, it produces a report which will give you an overview of your Active Directory security. This report can be generated on other domains by using the existing trust links.\n```\n\nCheck <https://www.pingcastle.com> for the documentation and methodology\n\n## Build\n\nPingCastle is a c# project which can be build from Visual Studio 2012 to Visual Studio 2022\n\n## Features & Bugs\n\nFor reporting bugs or requesting features in the open source edition of PingCastle, please create a Github issue.\n\nCustomers of a commercially available edition should contact [Netwrix technical support](https://www.netwrix.com/support.html).\n\n## License\n\nPingCastle source code is licensed under a proprietary license and the Non-Profit Open Software License (\"Non-Profit OSL\") 3.0.\n\nExcept if a license is purchased, you are not allowed to make any profit from this source code.\nTo be more specific:\n\n* It is allowed to run PingCastle without purchasing any license on for profit companies if the company itself (or its ITSM provider) run it.\n* To build services based on PingCastle AND earning money from that, you MUST purchase a license.\n\nPing Castle uses the following Open source components:\n\n* [Bootstrap](https://getbootstrap.com/) licensed under the [MIT license](https://tldrlegal.com/license/mit-license)\n* [JQuery](https://jquery.org) licensed under the [MIT license](https://tldrlegal.com/license/mit-license)\n* [vis.js](http://visjs.org/) licensed under the [MIT license](https://tldrlegal.com/license/mit-license)\n* [popper.js](https://popper.js.org/) licensed under the [MIT license](https://tldrlegal.com/license/mit-license)\n* [Bootstrap Table](https://bootstrap-table.com/) licensed under the [MIT license](https://tldrlegal.com/license/mit-license)\n\n## Author\n\n*\tGeneral Contact: [PingCastle.Contact@netwrix.com](mailto:PingCastle.Contact@netwrix.com)\n"
        },
        {
          "name": "RPC",
          "type": "tree",
          "content": null
        },
        {
          "name": "Report",
          "type": "tree",
          "content": null
        },
        {
          "name": "Rules",
          "type": "tree",
          "content": null
        },
        {
          "name": "RuntimeSettings.cs",
          "type": "blob",
          "size": 17.1982421875,
          "content": "﻿using PingCastle.ADWS;\nusing PingCastle.Exports;\nusing PingCastle.Report;\nusing PingCastle.Scanners;\nusing PingCastle.Cloud.Common;\nusing PingCastle.Cloud.Credentials;\nusing PingCastle.Cloud.RESTServices.Azure;\nusing PingCastle.Cloud.Tokens;\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.NetworkInformation;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Security;\nusing PingCastleCommon;\n\nnamespace PingCastle\n{\n    public enum DisplayState\n    {\n        Exit,\n        MainMenu,\n        ScannerMenu,\n        Run,\n        AvancedMenu,\n        AskForScannerParameter,\n        ProtocolMenu,\n        ExportMenu,\n    }\n\n    public class RuntimeSettings\n    {\n        public bool InteractiveMode { get; set; }\n\n        public string Server { get; set; }\n        public int Port { get; set; }\n        public NetworkCredential Credential { get; set; }\n\n        // must exists\n        public string InputFile { get; set; }\n        // must exists\n        public string InputDirectory { get; set; }\n\n        public Type Scanner { get; set; }\n        public Type Export { get; set; }\n        public IAzureCredential AzureCredential { get; set; }\n\n        public string User { get; set; }\n        public string Userdomain { get; set; }\n        public SecureString Password { get; set; }\n\n        public string InitForExportAsGuest { get; set; }\n\n        public string sendXmlTo;\n        public string sendHtmlTo;\n        public string sendAllTo;\n        public string sharepointdirectory;\n        public string sharepointuser;\n        public string sharepointpassword;\n        public string CenterDomainForSimpliedGraph = null;\n        public bool ExploreTerminalDomains;\n        public bool ExploreForestTrust;\n        public List<string> DomainToNotExplore;\n        public bool EncryptReport = false;\n        public string mailNotification;\n        public string smtpLogin;\n        public string smtpPassword;\n        public DateTime FilterReportDate = DateTime.MaxValue;\n        public bool smtpTls;\n\n        public string apiEndpoint;\n        public string apiKey;\n        public bool AnalyzeReachableDomains;\n        public string botPipe;\n\n        internal string privateKey = null;\n        internal string tenantid = null;\n        internal string clientid = null;\n        internal string thumbprint = null;\n        internal string p12file = null;\n        internal string p12pass = null;\n        internal bool p12passSet = false;\n        internal bool usePrt = false;\n\n        private bool CheckCertificate()\n        {\n            if (!string.IsNullOrEmpty(thumbprint) || !string.IsNullOrEmpty(privateKey))\n            {\n                if (string.IsNullOrEmpty(thumbprint))\n                {\n                    WriteInRed(\"--thumbprint must be completed when --private-key is set\");\n                    return false;\n                }\n                if (string.IsNullOrEmpty(privateKey))\n                {\n                    WriteInRed(\"--private-key must be completed when --thumbprint is set\");\n                    return false;\n                }\n                if (string.IsNullOrEmpty(clientid))\n                {\n                    WriteInRed(\"--clientid must be set when certificate authentication is configured\");\n                    return false;\n                }\n                if (string.IsNullOrEmpty(tenantid))\n                {\n                    WriteInRed(\"--tenantid must be set when certificate authentication is configured\");\n                    return false;\n                }\n                if (!string.IsNullOrEmpty(p12file))\n                {\n                    WriteInRed(\"--p12-file cannot be combined with --private-key\");\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public bool CheckArgs()\n        {\n            return true;\n            //return CheckCertificate();\n        }\n\n        #region display menu\n        public DisplayState EnsureDataCompleted(params string[] requirements)\n        {\n            if (requirements.Contains(\"Scanner\"))\n            {\n                if (Scanner == null)\n                {\n                    var state = DisplayScannerMenu();\n                    if (state != DisplayState.Run)\n                        return state;\n                }\n            }\n            if (requirements.Contains(\"Export\"))\n            {\n                if (Export == null)\n                {\n                    var state = DisplayExportMenu();\n                    if (state != DisplayState.Run)\n                        return state;\n                }\n            }\n            if (requirements.Contains(\"Server\"))\n            {\n                if (InteractiveMode)\n                {\n                    var state = DisplayAskServer();\n                    if (state != DisplayState.Run)\n                        return state;\n                }\n                if (string.IsNullOrEmpty(Server))\n                {\n                    Server = IPGlobalProperties.GetIPGlobalProperties().DomainName;\n                }\n                if (string.IsNullOrEmpty(Server))\n                {\n                    WriteInRed(\"This computer is not connected to a domain. The program couldn't guess the domain or server to connect.\");\n                    WriteInRed(\"Please run again this program with the flag --server <my.domain.com> or --server <mydomaincontroller.my.domain.com>\");\n                    return DisplayState.Exit;\n                }\n                if (!string.IsNullOrEmpty(User))\n                {\n                    if (Password == null)\n                    {\n                        if (!AskCredential())\n                            return DisplayState.Exit;\n                    }\n                    if (!string.IsNullOrEmpty(Userdomain))\n                    {\n                        Credential = new NetworkCredential(User, Password, Userdomain);\n                    }\n                    else\n                    {\n                        Credential = new NetworkCredential(User, Password);\n                    }\n                }\n            }\n            if (requirements.Contains(\"AzureADCredential\") || requirements.Contains(\"AzureADTenant\"))\n            {\n                if (AzureCredential == null)\n                {\n                    if (!string.IsNullOrEmpty(privateKey))\n                    {\n                        var key = File.ReadAllText(privateKey);\n                        AzureCredential = CertificateCredential.LoadFromKeyFile(clientid, tenantid, key, thumbprint);\n                    }\n                    if (!string.IsNullOrEmpty(p12file))\n                    {\n                        AzureCredential = CertificateCredential.LoadFromP12(clientid, tenantid, p12file, p12pass);\n                    }\n                    if (usePrt)\n                    {\n                        AzureCredential = new PRTCredential(tenantid);\n                    }\n                }\n                if (AzureCredential == null)\n                {\n                    var state = DisplayAskAzureADCredential();\n                    if (state != DisplayState.Run)\n                        return state;\n                }\n            }\n            if (requirements.Contains(\"AzureADTenant\"))\n            {\n                var state = DisplayAskAzureADTenant();\n                if (state != DisplayState.Run)\n                    return state;\n            }\n            if (requirements.Contains(\"File\"))\n            {\n                var state = DisplayAskForFile();\n                if (state != DisplayState.Run)\n                    return state;\n            }\n            if (requirements.Contains(\"Directory\"))\n            {\n                if (string.IsNullOrEmpty(InputDirectory))\n                {\n                    InputDirectory = Directory.GetCurrentDirectory();\n                }\n                if (!Directory.Exists(InputDirectory))\n                {\n                    WriteInRed(\"No input directory has been provided\");\n                    return DisplayState.Exit;\n                }\n            }\n            if (requirements.Contains(\"AzureADSeed\"))\n            {\n                var state = DisplayAskForSeed();\n                if (state != DisplayState.Run)\n                    return state;\n            }\n\n            return DisplayState.Run;\n        }\n\n        public DisplayState DisplayScannerMenu()\n        {\n            var scanners = PingCastleFactory.GetAllScanners();\n\n            var choices = new List<ConsoleMenuItem>();\n            foreach (var scanner in scanners)\n            {\n                Type scannerType = scanner.Value;\n                IScanner iscanner = PingCastleFactory.LoadScanner(scannerType);\n                string description = iscanner.Description;\n                choices.Add(new ConsoleMenuItem(scanner.Key, description));\n            }\n            choices.Sort((ConsoleMenuItem a, ConsoleMenuItem b)\n                =>\n            {\n                return String.Compare(a.Choice, b.Choice);\n            }\n            );\n            ConsoleMenu.Notice = \"WARNING: Checking a lot of workstations may raise security alerts.\";\n            ConsoleMenu.Title = \"Select a scanner\";\n            ConsoleMenu.Information = \"What scanner whould you like to run ?\";\n            int choice = ConsoleMenu.SelectMenuCompact(choices, 1);\n            if (choice == 0)\n            {\n                return DisplayState.Exit;\n            }\n            Scanner = scanners[choices[choice - 1].Choice];\n            return DisplayState.Run;\n        }\n\n        public DisplayState DisplayExportMenu()\n        {\n            var exports = PingCastleFactory.GetAllExport();\n\n            var choices = new List<ConsoleMenuItem>();\n            foreach (var export in exports)\n            {\n                Type exportType = export.Value;\n                IExport iexport = PingCastleFactory.LoadExport(exportType);\n                string description = iexport.Description;\n                choices.Add(new ConsoleMenuItem(export.Key, description));\n            }\n            choices.Sort((ConsoleMenuItem a, ConsoleMenuItem b)\n                =>\n            {\n                return String.Compare(a.Choice, b.Choice);\n            }\n            );\n            ConsoleMenu.Title = \"Select an export\";\n            ConsoleMenu.Information = \"What export whould you like to run ?\";\n            int choice = ConsoleMenu.SelectMenu(choices, 1);\n            if (choice == 0)\n            {\n                return DisplayState.Exit;\n            }\n            Export = exports[choices[choice - 1].Choice];\n            return DisplayState.Run;\n        }\n\n        DisplayState DisplayAskServer()\n        {\n            var defaultServer = IPGlobalProperties.GetIPGlobalProperties().DomainName;\n            while (true)\n            {\n                if (!String.IsNullOrEmpty(defaultServer) || string.Equals(defaultServer, \"(None)\", StringComparison.OrdinalIgnoreCase))\n                {\n                    ConsoleMenu.Information = \"Please specify the domain or server to investigate (default:\" + defaultServer + \")\";\n                }\n                else\n                {\n                    ConsoleMenu.Information = \"Please specify the domain or server to investigate:\";\n                }\n                ConsoleMenu.Title = \"Select a domain or server\";\n                Server = ConsoleMenu.AskForString();\n                if (!String.IsNullOrEmpty(Server))\n                {\n                    break;\n                }\n                if (!string.IsNullOrEmpty(defaultServer))\n                {\n                    Server = defaultServer;\n                    break;\n                }\n            }\n            return DisplayState.Run;\n        }\n\n\n        private DisplayState DisplayAskAzureADCredential()\n        {\n            List<ConsoleMenuItem> choices = new List<ConsoleMenuItem>() {\n                new ConsoleMenuItem(\"askcredential\",\"Ask credentials\", \"The identity may be asked multiple times during the healthcheck.\"),\n            };\n\n            var tokens = TokenFactory.GetRegisteredPRTIdentities();\n            if (tokens.Count > 0)\n            {\n                choices.Insert(0, new ConsoleMenuItem(\"useprt\", \"Use SSO with the PRT stored on this computer\", \"Use the Primary Refresh Token available on this computer to connect automatically without credential prompting.\"));\n            }\n\n            ConsoleMenu.Title = \"Which identity do you want to use?\";\n            ConsoleMenu.Information = \"The program will use the choosen identity to perform the operation on the Azure Tenant.\";\n            int choice = ConsoleMenu.SelectMenu(choices);\n            if (choice == 0)\n                return DisplayState.Exit;\n\n            AzureCredential = null;\n\n            string whattodo = choices[choice - 1].Choice;\n            switch (whattodo)\n            {\n                default:\n                    break;\n                case \"askcredential\":\n                    AzureCredential = new UserCredential();\n                    break;\n                case \"useprt\":\n                    AzureCredential = new PRTCredential();\n                    break;\n\n            }\n\n            return DisplayState.Run;\n        }\n\n        private DisplayState DisplayAskAzureADTenant()\n        {\n            HttpClientHelper.LogComment = \"DisplayAskTenant\";\n            ManagementApi.TenantListResponse p;\n            try\n            {\n                var graph = new ManagementApi(AzureCredential);\n                p = graph.ListTenants();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n                return DisplayState.Exit;\n            }\n            HttpClientHelper.LogComment = null;\n\n\n            List<ConsoleMenuItem> choices = new List<ConsoleMenuItem>();\n            foreach (var t in p.responses)\n            {\n                foreach (var t2 in t.content.value)\n                {\n                    choices.Add(new ConsoleMenuItem(t2.tenantId, t2.displayName + \" (\" + t2.countryCode + \")\"));\n                }\n            }\n\n            ConsoleMenu.Title = \"Which tenant do you want to use?\";\n            ConsoleMenu.Information = \"The program will use the choosen tenant to perform the operation on the Azure Tenant.\";\n            int choice = ConsoleMenu.SelectMenu(choices);\n            if (choice == 0)\n                return DisplayState.Exit;\n\n            string whattodo = choices[choice - 1].Choice;\n            AzureCredential.TenantidToQuery = whattodo;\n\n            return DisplayState.Run;\n        }\n\n        DisplayState DisplayAskForFile()\n        {\n            while (String.IsNullOrEmpty(InputFile) || !File.Exists(InputFile))\n            {\n                ConsoleMenu.Title = \"Select an existing file\";\n                ConsoleMenu.Information = \"Please specify the file to open.\";\n                InputFile = ConsoleMenu.AskForString();\n                ConsoleMenu.Notice = \"The file \" + InputFile + \" was not found\";\n            }\n            return DisplayState.Run;\n        }\n\n        DisplayState DisplayAskForDirectory()\n        {\n            while (String.IsNullOrEmpty(InputDirectory) || !Directory.Exists(InputDirectory))\n            {\n                ConsoleMenu.Title = \"Select an existing directory\";\n                ConsoleMenu.Information = \"Please specify the directory to open.\";\n                InputFile = ConsoleMenu.AskForString();\n                ConsoleMenu.Notice = \"The directory \" + InputFile + \" was not found\";\n            }\n            return DisplayState.Run;\n        }\n\n        DisplayState DisplayAskForSeed()\n        {\n            while (String.IsNullOrEmpty(InitForExportAsGuest))\n            {\n                ConsoleMenu.Title = \"Select the seed\";\n                ConsoleMenu.Information = @\"To start the export, the program need to have a first user. It can be its objectId or its UPN (firstname.lastname@domain.com). The program accept many values if there are separted by a comma.\";\n                InitForExportAsGuest = ConsoleMenu.AskForString();\n\n                // error message in case the query is not complete\n                ConsoleMenu.Notice = \"The seed cannot be empty\";\n            }\n            return DisplayState.Run;\n        }\n\n        private bool AskCredential()\n        {\n            Password = new SecureString();\n            Console.WriteLine(\"Enter password: \");\n            ConsoleKeyInfo nextKey = Console.ReadKey(true);\n\n            while (nextKey.Key != ConsoleKey.Enter)\n            {\n                if (nextKey.Key == ConsoleKey.Backspace)\n                {\n                    if (Password.Length > 0)\n                    {\n                        Password.RemoveAt(Password.Length - 1);\n                        // erase the last * as well\n                        Console.Write(nextKey.KeyChar);\n                        Console.Write(\" \");\n                        Console.Write(nextKey.KeyChar);\n                    }\n                }\n                else\n                {\n                    Password.AppendChar(nextKey.KeyChar);\n                    Console.Write(\"*\");\n                }\n                nextKey = Console.ReadKey(true);\n            }\n            Console.WriteLine();\n            return true;\n        }\n\n\n\n\n        #endregion\n        private void WriteInRed(string data)\n        {\n            Console.ForegroundColor = ConsoleColor.Red;\n            Console.WriteLine(data);\n            Trace.WriteLine(\"[Red]\" + data);\n            Console.ResetColor();\n        }\n    }\n}\n"
        },
        {
          "name": "Scanners",
          "type": "tree",
          "content": null
        },
        {
          "name": "Tasks.cs",
          "type": "blob",
          "size": 71.9560546875,
          "content": "﻿//\n// Copyright (c) Ping Castle. All rights reserved.\n// https://www.pingcastle.com\n//\n// Licensed under the Non-Profit OSL. See LICENSE file in the project root for full license information.\n//\nusing PingCastle.Data;\nusing PingCastle.Exports;\nusing PingCastle.Healthcheck;\nusing PingCastle.misc;\nusing PingCastle.Report;\nusing PingCastle.Rules;\nusing PingCastle.Scanners;\nusing PingCastle.Cloud.Credentials;\nusing PingCastle.Cloud.Data;\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Net;\nusing System.Net.Mail;\nusing System.Reflection;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing TinyJson;\nusing System.Xml.Serialization;\nusing System.Xml;\nusing System.Net.Http;\n\nnamespace PingCastle\n{\n    public class Tasks\n    {\n        public ADHealthCheckingLicense License { get; set; }\n\n        public NetworkCredential Credential = null;\n        public List<string> NodesToInvestigate = new List<string>();\n\n        public PingCastleReportDataExportLevel ExportLevel = PingCastleReportDataExportLevel.Normal;\n\n\n        Dictionary<string, string> xmlreports = new Dictionary<string, string>();\n        Dictionary<string, string> htmlreports = new Dictionary<string, string>();\n        Dictionary<string, DateTime> dateReports = new Dictionary<string, DateTime>();\n        Dictionary<string, string> aadjsonreport = new Dictionary<string, string>();\n        Dictionary<string, string> aadhtmlreport = new Dictionary<string, string>();\n\n        private RuntimeSettings Settings;\n\n        public Tasks(RuntimeSettings settings)\n        {\n            Settings = settings;\n        }\n\n        internal static void EnableLogFile()\n        {\n            Trace.AutoFlush = true;\n            TextWriterTraceListener listener = new TextWriterTraceListener(\"trace.log\");\n            Trace.Listeners.Add(listener);\n            PingCastle.Cloud.Common.HttpClientHelper.EnableLoging(new PingCastle.Cloud.Logs.SazGenerator());\n        }\n\n        public bool GenerateKeyTask()\n        {\n            return StartTask(\"Generate Key\",\n                    () =>\n                    {\n                        HealthCheckEncryption.GenerateRSAKey();\n                    });\n        }\n\n        public bool GenerateAzureADKeyTask()\n        {\n            return StartTask(\"Generate AzureAD Key\",\n                    () =>\n                    {\n                        Console.WriteLine(\"Go to portal.azure.com\");\n                        Console.WriteLine(\"Open Azure Active Directory\");\n                        Console.WriteLine(\"Go to App registrations\");\n                        Console.WriteLine(\"Select new registration and create an app.\");\n                        Console.WriteLine(\"Go to Certificates & secrets and select certificates\");\n                        Console.WriteLine(\"upload the .cer file generated\");\n                        Console.WriteLine(\"\");\n                        Console.WriteLine(\"Go to Roles adn administrators\");\n                        Console.WriteLine(\"Select the role Global Reader\");\n                        Console.WriteLine(\"Click on Add assignments and add the previously created account\");\n                        Console.WriteLine(\"Make sure the App registration is listed on Assignments before leaving\");\n                        var tenant = \"pingcastle.com\";\n                        PingCastle.Cloud.Credentials.CertificateBuilder.GenerateAzureADCertificate(tenant, \"vletoux\", DateTime.Now.AddYears(2));\n                        return;\n\n                        //CertificateBuilder.GenerateAzureADCertificate(\"pingcatle.c\n                    });\n        }\n\n        public bool ScannerTask()\n        {\n            return StartTask(\"Scanner\",\n                    () =>\n                    {\n                        PropertyInfo pi = Settings.Scanner.GetProperty(\"Name\");\n                        IScanner scanner = PingCastleFactory.LoadScanner(Settings.Scanner);\n                        string name = pi.GetValue(scanner, null) as string;\n                        DisplayAdvancement(\"Running scanner \" + name);\n                        scanner.Initialize(Settings);\n                        if (scanner.QueryForAdditionalParameterInInteractiveMode() != DisplayState.Run)\n                            return;\n                        string file = \"ad_scanner_\" + name + \"_\" + Settings.Server + \".txt\";\n                        scanner.Export(file);\n                        DisplayAdvancement(\"Results saved to \" + new FileInfo(file).FullName);\n                    }\n                );\n        }\n\n        public bool CartoTask()\n        {\n            return CartoTask(false);\n        }\n\n        public bool CartoTask(bool PerformHealthCheckGenerateDemoReports = false)\n        {\n            List<HealthcheckAnalyzer.ReachableDomainInfo> domains = null;\n            StartTask(\"Exploration\",\n                () =>\n                {\n                    HealthcheckAnalyzer hcroot = new HealthcheckAnalyzer();\n                    hcroot.limitHoneyPot = string.IsNullOrEmpty(License.Edition);\n                    domains = hcroot.GetAllReachableDomains(Settings.Port, Settings.Credential);\n                    Console.ForegroundColor = ConsoleColor.Yellow;\n                    Console.WriteLine(\"List of domains that will be queried\");\n                    Console.ResetColor();\n                    foreach (var domain in domains)\n                    {\n                        Console.WriteLine(domain.domain);\n                    }\n                });\n            var consolidation = new PingCastleReportCollection<HealthcheckData>();\n            StartTask(\"Examining all domains in parallele (this can take a few minutes)\",\n            () =>\n            {\n                BlockingQueue<string> queue = new BlockingQueue<string>(30);\n                int numberOfThread = 100;\n                Thread[] threads = new Thread[numberOfThread];\n                try\n                {\n                    ThreadStart threadFunction = () =>\n                    {\n                        for (; ; )\n                        {\n                            string domain = null;\n                            if (!queue.Dequeue(out domain)) break;\n                            try\n                            {\n                                Console.WriteLine(\"[\" + DateTime.Now.ToLongTimeString() + \"] \" + \"Starting the analysis of \" + domain);\n                                HealthcheckAnalyzer hc = new HealthcheckAnalyzer();\n                                hc.limitHoneyPot = string.IsNullOrEmpty(License.Edition);\n\n                                var data = hc.GenerateCartoReport(domain, Settings.Port, Settings.Credential, Settings.AnalyzeReachableDomains);\n                                consolidation.Add(data);\n                                Console.WriteLine(\"[\" + DateTime.Now.ToLongTimeString() + \"] \" + \"Analysis of \" + domain + \" completed with success\");\n                            }\n                            catch (Exception ex)\n                            {\n                                Console.WriteLine(\"[\" + DateTime.Now.ToLongTimeString() + \"] \" + \"Analysis of \" + domain + \" failed\");\n                                Trace.WriteLine(\"Exception while analysing domain \" + domain + \" : \" + ex.Message);\n                                Trace.WriteLine(ex.StackTrace);\n                            }\n                        }\n                    };\n                    // Consumers\n                    for (int i = 0; i < numberOfThread; i++)\n                    {\n                        threads[i] = new Thread(threadFunction);\n                        threads[i].Start();\n                    }\n                    foreach (var domain in domains)\n                    {\n                        queue.Enqueue(domain.domain);\n                    }\n                    queue.Quit();\n                    Trace.WriteLine(\"examining domains file completed. Waiting for worker thread to complete\");\n                    for (int i = 0; i < numberOfThread; i++)\n                    {\n                        threads[i].Join();\n                    }\n                    Trace.WriteLine(\"Done examining domains\");\n                }\n                catch (Exception ex)\n                {\n                    Trace.WriteLine(\"Exception while analysing domain in carto: \" + ex.Message);\n                    Trace.WriteLine(ex.StackTrace);\n                }\n                finally\n                {\n                    queue.Quit();\n                    for (int i = 0; i < numberOfThread; i++)\n                    {\n                        if (threads[i] != null)\n                            if (threads[i].ThreadState == System.Threading.ThreadState.Running)\n                                threads[i].Abort();\n                    }\n                }\n            });\n            if (PerformHealthCheckGenerateDemoReports)\n            {\n                Console.WriteLine(\"Performing demo report transformation\");\n                Trace.WriteLine(\"Performing demo report transformation\");\n                consolidation = PingCastleReportHelper<HealthcheckData>.TransformReportsToDemo(consolidation);\n            }\n            if (!StartTask(\"Healthcheck consolidation\",\n                () =>\n                {\n                    consolidation.EnrichInformation();\n                    ReportHealthCheckMapBuilder nodeAnalyzer = new ReportHealthCheckMapBuilder(consolidation, License);\n                    nodeAnalyzer.Log = Console.WriteLine;\n                    nodeAnalyzer.CenterDomainForSimpliedGraph = Settings.CenterDomainForSimpliedGraph;\n                    nodeAnalyzer.GenerateReportFile(\"ad_carto_full_node_map.html\");\n                    nodeAnalyzer.FullNodeMap = false;\n                    nodeAnalyzer.CenterDomainForSimpliedGraph = Settings.CenterDomainForSimpliedGraph;\n                    nodeAnalyzer.GenerateReportFile(\"ad_carto_simple_node_map.html\");\n                }\n            )) return false;\n            return true;\n        }\n\n        public bool AnalysisTask<T>() where T : IPingCastleReport\n        {\n            if (!string.IsNullOrEmpty(Settings.apiEndpoint) && !string.IsNullOrEmpty(Settings.apiKey))\n            {\n                var ret = RetrieveSettingsViaAPI();\n                if (!ret)\n                    return false;\n            }\n            string[] servers = Settings.Server.Split(',');\n            foreach (string server in servers)\n            {\n                AnalysisTask<T>(server);\n            }\n            return true;\n        }\n\n        public bool CompleteTasks()\n        {\n            if (!string.IsNullOrEmpty(Settings.sendXmlTo))\n                SendEmail(Settings.sendXmlTo, true, false);\n            if (!string.IsNullOrEmpty(Settings.sendHtmlTo))\n                SendEmail(Settings.sendHtmlTo, false, true);\n            if (!string.IsNullOrEmpty(Settings.sendAllTo))\n                SendEmail(Settings.sendAllTo, true, true);\n            if (!string.IsNullOrEmpty(Settings.sharepointdirectory))\n            {\n                // TODO: remove this functionality (unused ?) or add AAD support\n                foreach (string domain in xmlreports.Keys)\n                {\n                    UploadToWebsite(HealthcheckData.GetMachineReadableFileName(domain, dateReports.ContainsKey(domain) ? dateReports[domain] : DateTime.Now), xmlreports[domain]);\n                }\n            }\n            if (!String.IsNullOrEmpty(Settings.apiKey) && !String.IsNullOrEmpty(Settings.apiEndpoint))\n                SendViaAPI(xmlreports, aadjsonreport);\n            return true;\n        }\n\n        public bool GenerateFakeReport()\n        {\n            return StartTask(\"Generate fake reports\",\n                    () =>\n                    {\n                        var fakegenerator = new FakeHealthCheckDataGenerator();\n                        var hcconso = fakegenerator.GenerateData();\n\n                        foreach (var pingCastleReport in hcconso)\n                        {\n                            var enduserReportGenerator = new ReportHealthCheckSingle();\n                            enduserReportGenerator.GenerateReportFile(pingCastleReport, License, pingCastleReport.GetHumanReadableFileName());\n                            DisplayAdvancement(\"Export level is \" + ExportLevel);\n                            if (ExportLevel != PingCastleReportDataExportLevel.Full)\n                            {\n                                DisplayAdvancement(\"Personal data will NOT be included in the .xml file (add --level Full to add it. Ex: PingCastle.exe --interactive --level Full)\");\n                            }\n                            pingCastleReport.SetExportLevel(ExportLevel);\n                            DataHelper<HealthcheckData>.SaveAsXml(pingCastleReport, pingCastleReport.GetMachineReadableFileName(), Settings.EncryptReport);\n\n                        }\n\n                        var reportConso = new ReportHealthCheckConsolidation();\n                        reportConso.GenerateReportFile(hcconso, License, \"ad_hc_summary.html\");\n                        ReportHealthCheckMapBuilder nodeAnalyzer = new ReportHealthCheckMapBuilder(hcconso, License);\n                        nodeAnalyzer.Log = Console.WriteLine;\n                        nodeAnalyzer.GenerateReportFile(\"ad_hc_summary_full_node_map.html\");\n                        nodeAnalyzer.FullNodeMap = false;\n                        nodeAnalyzer.CenterDomainForSimpliedGraph = Settings.CenterDomainForSimpliedGraph;\n                        nodeAnalyzer.GenerateReportFile(\"ad_hc_summary_simple_node_map.html\");\n                        var mapReport = new ReportNetworkMap();\n                        mapReport.GenerateReportFile(hcconso, License, \"ad_hc_hilbert_map.html\");\n                    }\n                );\n        }\n\n        public class ExportedRule\n        {\n            public string Type { get; set; }\n            public RiskRuleCategory Category { get; set; }\n\n            public string Description { get; set; }\n\n            public string Documentation { get; set; }\n\n            public int MaturityLevel { get; set; }\n\n            public RiskModelCategory Model { get; set; }\n\n            public string Rationale { get; set; }\n\n            public string ReportLocation { get; set; }\n\n            public string RiskId { get; set; }\n\n            //public List<RuleComputationAttribute> RuleComputation { get; set; }\n\n            public string Solution { get; set; }\n\n            public string TechnicalExplanation { get; set; }\n\n            public string Title { get; set; }\n        }\n\n        public bool GenerateRuleList()\n        {\n            return StartTask(\"Export rules\",\n                    () =>\n                    {\n                        var rules = new List<ExportedRule>();\n                        foreach (var r in PingCastle.Rules.RuleSet<HealthcheckData>.Rules)\n                        {\n                            rules.Add(new ExportedRule()\n                            {\n                                Type = \"Active Directory\",\n                                Category = r.Category,\n                                Description = r.Description,\n                                Documentation = r.Documentation,\n                                MaturityLevel = r.MaturityLevel,\n                                Model = r.Model,\n                                Rationale = r.Rationale,\n                                ReportLocation = r.ReportLocation,\n                                RiskId = r.RiskId,\n                                //RuleComputation = r.RuleComputation,\n                                Solution = r.Solution,\n                                TechnicalExplanation = r.TechnicalExplanation,\n                                Title = r.Title,\n                            });\n                        }\n\n                        foreach (var r in PingCastle.Rules.RuleSet<HealthCheckCloudData>.Rules)\n                        {\n                            rules.Add(new ExportedRule()\n                            {\n                                Type = \"Azure AD\",\n                                Category = r.Category,\n                                Description = r.Description,\n                                Documentation = r.Documentation,\n                                MaturityLevel = r.MaturityLevel,\n                                Model = r.Model,\n                                Rationale = r.Rationale,\n                                ReportLocation = r.ReportLocation,\n                                RiskId = r.RiskId,\n                                //RuleComputation = r.RuleComputation,\n                                Solution = r.Solution,\n                                TechnicalExplanation = r.TechnicalExplanation,\n                                Title = r.Title,\n                            });\n                        }\n\n                        var xs = new XmlSerializer(typeof(List<ExportedRule>));\n                        var xmlDoc = new XmlDocument();\n                        xmlDoc.PreserveWhitespace = true;\n                        var nav = xmlDoc.CreateNavigator();\n                        using (XmlWriter wr = nav.AppendChild())\n                        using (var wr2 = new SafeXmlWriter(wr))\n                        {\n                            xs.Serialize(wr2, rules);\n                        }\n                        xmlDoc.Save(\"PingCastleRules.xml\");\n\n                    }\n            );\n        }\n\n        public bool AnalysisCheckTask<T>(string server)\n        {\n            return true;\n        }\n\n        public bool AnalysisTask<T>(string server) where T : IPingCastleReport\n        {\n            Trace.WriteLine(\"Working on \" + server);\n            if (server == \"*\" && Settings.InteractiveMode)\n            {\n                Trace.WriteLine(\"Setting reachable domains to on because interactive + server = *\");\n                Settings.AnalyzeReachableDomains = true;\n            }\n            if (server.Contains(\"*\"))\n            {\n                List<string> domains = GetListOfDomainToExploreFromGenericName(server);\n                int i = 1;\n\n                foreach (var domain in domains)\n                {\n                    Console.ForegroundColor = ConsoleColor.Yellow;\n                    Console.WriteLine(\"\");\n                    string display = \"Starting the report for \" + domain + \" (\" + i++ + \"/\" + domains.Count + \")\";\n                    Console.WriteLine(display);\n                    Console.WriteLine(new String('=', display.Length));\n                    Console.ResetColor();\n                    PerformTheAnalysis(domain);\n                }\n\n            }\n            else\n            {\n                var data = PerformTheAnalysis(server);\n                var hcData = data as HealthcheckData;\n                // do additional exploration based on trust results ?\n                Trace.WriteLine(\"do additional exploration based on trust results ?\");\n                if (hcData != null && (Settings.ExploreTerminalDomains || Settings.ExploreForestTrust))\n                {\n                    Trace.WriteLine(\"ExploreTerminalDomains is \" + Settings.ExploreTerminalDomains);\n                    Trace.WriteLine(\"ExploreForestTrust is \" + Settings.ExploreForestTrust);\n                    if (hcData.Trusts != null)\n                    {\n                        List<string> domainToExamine = new List<string>();\n                        foreach (var trust in hcData.Trusts)\n                        {\n                            Trace.WriteLine(\"Examining \" + trust.TrustPartner + \" for additional exploration\");\n                            string attributes = TrustAnalyzer.GetTrustAttribute(trust.TrustAttributes);\n                            string direction = TrustAnalyzer.GetTrustDirection(trust.TrustDirection);\n                            if (direction.Contains(\"Inbound\") || direction.Contains(\"Disabled\"))\n                                continue;\n                            if (attributes.Contains(\"Intra-Forest\"))\n                                continue;\n                            // explore forest trust only if explore forest trust is set\n                            if (attributes.Contains(\"Forest Trust\"))\n                            {\n                                if (Settings.ExploreForestTrust)\n                                {\n                                    if (!ShouldTheDomainBeNotExplored(trust.TrustPartner))\n                                        domainToExamine.Add(trust.TrustPartner);\n                                    else\n                                        Trace.WriteLine(\"Domain \" + trust.TrustPartner + \" not to explore (direct domain)\");\n                                    if (trust.KnownDomains != null)\n                                    {\n                                        foreach (var di in trust.KnownDomains)\n                                        {\n                                            if (!ShouldTheDomainBeNotExplored(di.DnsName))\n                                                domainToExamine.Add(di.DnsName);\n                                            Trace.WriteLine(\"Domain \" + di.DnsName + \" not to explore (known domain)\");\n                                        }\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                if (Settings.ExploreTerminalDomains)\n                                {\n                                    if (!ShouldTheDomainBeNotExplored(trust.TrustPartner))\n                                        domainToExamine.Add(trust.TrustPartner);\n                                    else\n                                        Trace.WriteLine(\"Domain \" + trust.TrustPartner + \"not to explore (terminal domain)\");\n                                }\n                            }\n                        }\n                        Console.ForegroundColor = ConsoleColor.Yellow;\n                        Console.WriteLine(\"List of domains that will be queried\");\n                        Trace.WriteLine(\"List of domains that will be queried\");\n                        Console.ResetColor();\n                        foreach (var domain in domainToExamine)\n                        {\n                            Console.WriteLine(domain);\n                            Trace.WriteLine(domain);\n                        }\n                        Trace.WriteLine(\"End selection\");\n                        foreach (string domain in domainToExamine)\n                        {\n                            PerformTheAnalysis(domain);\n                        }\n                    }\n                }\n                Trace.WriteLine(\"done additional exploration\");\n                return hcData != null;\n            }\n            return true;\n        }\n\n        private List<string> GetListOfDomainToExploreFromGenericName(string server)\n        {\n            List<string> domains = new List<string>();\n            StartTask(\"Exploration\",\n                () =>\n                {\n                    HealthcheckAnalyzer hcroot = new HealthcheckAnalyzer();\n                    hcroot.limitHoneyPot = string.IsNullOrEmpty(License.Edition);\n                    var reachableDomains = hcroot.GetAllReachableDomains(Settings.Port, Settings.Credential);\n                    List<HealthcheckAnalyzer.ReachableDomainInfo> domainsfiltered = new List<HealthcheckAnalyzer.ReachableDomainInfo>();\n                    Console.ForegroundColor = ConsoleColor.Yellow;\n                    Console.WriteLine(\"List of domains that will be queried\");\n                    Console.ResetColor();\n                    foreach (var reachableDomain in reachableDomains)\n                    {\n                        if (compareStringWithWildcard(server, reachableDomain.domain) && !ShouldTheDomainBeNotExplored(reachableDomain.domain))\n                        {\n                            domains.Add(reachableDomain.domain);\n                            Console.WriteLine(reachableDomain.domain);\n                        }\n                    }\n                });\n            return domains;\n        }\n\n        public static bool compareStringWithWildcard(string stringWithWildcard, string toCompare)\n        {\n            string regex = \"^\" + Regex.Escape(stringWithWildcard)\n                              .Replace(@\"\\*\", \".*\")\n                              .Replace(@\"\\?\", \".\")\n                       + \"$\";\n            return Regex.Match(toCompare, regex, RegexOptions.IgnoreCase).Success;\n        }\n\n        bool ShouldTheDomainBeNotExplored(string domainToCheck)\n        {\n            if (Settings.DomainToNotExplore == null)\n                return false;\n            foreach (string domain in Settings.DomainToNotExplore)\n            {\n                if (domainToCheck.Equals(domain, StringComparison.InvariantCultureIgnoreCase))\n                {\n                    Trace.WriteLine(\"Domain \" + domainToCheck + \" is filtered\");\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        HealthcheckData PerformTheAnalysis(string server)\n        {\n            HealthcheckData pingCastleReport = null;\n            bool status = StartTask(\"Perform analysis for \" + server,\n                () =>\n                {\n                    var analyzer = new HealthcheckAnalyzer();\n                    analyzer.limitHoneyPot = string.IsNullOrEmpty(License.Edition);\n                    pingCastleReport = analyzer.PerformAnalyze(new PingCastleAnalyzerParameters()\n                    {\n                        Server = server,\n                        Port = Settings.Port,\n                        Credential = Settings.Credential,\n                        PerformExtendedTrustDiscovery = Settings.AnalyzeReachableDomains,\n                        AdditionalNamesForDelegationAnalysis = NodesToInvestigate,\n                    });\n                    string domain = pingCastleReport.Domain.DomainName;\n                    DisplayAdvancement(\"Generating html report\");\n                    var enduserReportGenerator = new ReportHealthCheckSingle();\n                    htmlreports[domain] = enduserReportGenerator.GenerateReportFile(pingCastleReport, License, pingCastleReport.GetHumanReadableFileName());\n                    DisplayAdvancement(\"Generating xml file for consolidation report\" + (Settings.EncryptReport ? \" (encrypted)\" : \"\"));\n                    DisplayAdvancement(\"Export level is \" + ExportLevel);\n                    if (ExportLevel != PingCastleReportDataExportLevel.Full)\n                    {\n                        DisplayAdvancement(\"Personal data will NOT be included in the .xml file (add --level Full to add it. Ex: PingCastle.exe --interactive --level Full)\");\n                    }\n                    pingCastleReport.SetExportLevel(ExportLevel);\n                    xmlreports[domain] = DataHelper<HealthcheckData>.SaveAsXml(pingCastleReport, pingCastleReport.GetMachineReadableFileName(), Settings.EncryptReport);\n                    dateReports[domain] = pingCastleReport.GenerationDate;\n                    DisplayAdvancement(\"Done\");\n                });\n            return pingCastleReport;\n        }\n\n        public bool ConsolidationTask<T>() where T : IPingCastleReport\n        {\n            return StartTask(\"PingCastle report consolidation (\" + typeof(T).Name + \")\",\n                    () =>\n                    {\n                        var consolidation = PingCastleReportHelper<T>.LoadXmls(Settings.InputDirectory, Settings.FilterReportDate);\n                        if (consolidation.Count == 0)\n                        {\n                            WriteInRed(\"No report has been found. Please generate one with PingCastle and try again. The task will stop.\");\n                            return;\n                        }\n                        if (typeof(T) == typeof(HealthcheckData))\n                        {\n                            var hcconso = consolidation as PingCastleReportCollection<HealthcheckData>;\n                            var report = new ReportHealthCheckConsolidation();\n                            report.GenerateReportFile(hcconso, License, \"ad_hc_summary.html\");\n                            ReportHealthCheckMapBuilder nodeAnalyzer = new ReportHealthCheckMapBuilder(hcconso, License);\n                            nodeAnalyzer.Log = Console.WriteLine;\n                            nodeAnalyzer.GenerateReportFile(\"ad_hc_summary_full_node_map.html\");\n                            nodeAnalyzer.FullNodeMap = false;\n                            nodeAnalyzer.CenterDomainForSimpliedGraph = Settings.CenterDomainForSimpliedGraph;\n                            nodeAnalyzer.GenerateReportFile(\"ad_hc_summary_simple_node_map.html\");\n                            var mapReport = new ReportNetworkMap();\n                            mapReport.GenerateReportFile(hcconso, License, \"ad_hc_hilbert_map.html\");\n                        }\n                    }\n                );\n        }\n\n        public bool HealthCheckRulesTask()\n        {\n            return StartTask(\"PingCastle Health Check rules\",\n                    () =>\n                    {\n                        var rulesBuilder = new ReportHealthCheckRules();\n                        rulesBuilder.GenerateReportFile(\"ad_hc_rules_list.html\");\n                    }\n                );\n        }\n\n\n        public bool RegenerateHtmlTask()\n        {\n            return StartTask(\"Regenerate html report\",\n                    () =>\n                    {\n                        var fi = new FileInfo(Settings.InputFile);\n                        if (fi.Name.EndsWith(\".json.gz\", StringComparison.CurrentCultureIgnoreCase))\n                        {\n                            HealthCheckCloudData report;\n                            using (var sr = File.OpenRead(Settings.InputFile))\n                            {\n                                if (fi.Name.EndsWith(\".gz\", StringComparison.OrdinalIgnoreCase))\n                                {\n                                    using (var gz = new GZipStream(sr, CompressionMode.Decompress))\n                                    {\n                                        report = HealthCheckCloudData.LoadFromStream(gz);\n                                    }\n                                }\n                                else\n                                {\n                                    report = HealthCheckCloudData.LoadFromStream(sr);\n                                }\n                                report.CheckIntegrity();\n                                var reportGenerator = new ReportCloud();\n                                reportGenerator.GenerateReportFile(report, License, \"pingcastlecloud_\" + report.TenantName + \".html\");\n\n                            }\n                        }\n                        else if (fi.Name.EndsWith(\".xml\", StringComparison.CurrentCultureIgnoreCase))\n                        {\n                            var healthcheckData = DataHelper<HealthcheckData>.LoadXml(Settings.InputFile);\n                            if (healthcheckData.Level != PingCastleReportDataExportLevel.Full)\n                            {\n                                DisplayAdvancement(\"The xml report does not contain personal data. Current reporting level is: \" + healthcheckData.Level);\n                            }\n                            var endUserReportGenerator = new ReportHealthCheckSingle();\n                            endUserReportGenerator.GenerateReportFile(healthcheckData, License, healthcheckData.GetHumanReadableFileName());\n                        }\n                    }\n                );\n        }\n\n        public bool ReloadXmlReport()\n        {\n            return StartTask(\"Reload report\",\n                    () =>\n                    {\n                        string newfile = Settings.InputFile.Replace(\".xml\", \"_reloaded.xml\");\n                        string xml = null;\n                        string domainFQDN = null;\n                        var fi = new FileInfo(Settings.InputFile);\n                        if (fi.Name.StartsWith(\"ad_hc_\"))\n                        {\n                            HealthcheckData healthcheckData = DataHelper<HealthcheckData>.LoadXml(Settings.InputFile);\n                            if (healthcheckData.Level != PingCastleReportDataExportLevel.Full)\n                            {\n                                DisplayAdvancement(\"The xml report does not contain personal data. Current reporting level is: \" + healthcheckData.Level);\n                            }\n\n                            domainFQDN = healthcheckData.DomainFQDN;\n                            DisplayAdvancement(\"Regenerating xml \" + (Settings.EncryptReport ? \" (encrypted)\" : \"\"));\n                            healthcheckData.Level = ExportLevel;\n                            xml = DataHelper<HealthcheckData>.SaveAsXml(healthcheckData, newfile, Settings.EncryptReport);\n                            // email sending will be handled by completedtasks\n                            xmlreports[domainFQDN] = xml;\n                            dateReports[domainFQDN] = healthcheckData.GenerationDate;\n                        }\n                        else\n                        {\n                            DisplayAdvancement(\"file ignored because it does not start with ad_hc_\");\n                        }\n                    }\n                );\n        }\n\n        public bool AnalyzeTask()\n        {\n            return StartTask(\"Analyze\",\n                () =>\n                {\n                    var analyze = new PingCastle.Cloud.Analyzer.Analyzer(Settings.AzureCredential);\n                    var report = analyze.Analyze().GetAwaiter().GetResult();\n                    report.SetIntegrity();\n                    using (var sr = File.OpenWrite(\"pingcastlecloud_\" + report.TenantName + \".json.gz\"))\n                    using (var gz = new GZipStream(sr, CompressionMode.Compress))\n                    using (var sw = new StreamWriter(gz))\n                    {\n                        sw.Write(report.ToJsonString());\n                    }\n                    aadjsonreport[report.TenantName] = \"pingcastlecloud_\" + report.TenantName + \".json.gz\";\n\n                    var reportGenerator = new ReportCloud();\n                    reportGenerator.GenerateReportFile(report, License, \"pingcastlecloud_\" + report.TenantName + \".html\");\n                    aadhtmlreport[report.TenantName] = \"pingcastlecloud_\" + report.TenantName + \".html\";\n                });\n        }\n\n        public bool UploadAllReportInCurrentDirectory()\n        {\n            return StartTask(\"Upload report\",\n                () =>\n                {\n                    if (String.IsNullOrEmpty(Settings.apiKey) || String.IsNullOrEmpty(Settings.apiEndpoint))\n                        throw new PingCastleException(\"API end point not available\");\n                    var files = new List<string>(Directory.GetFiles(Directory.GetCurrentDirectory(), \"*ad_*.xml\", SearchOption.AllDirectories));\n                    files.AddRange(Directory.GetFiles(Directory.GetCurrentDirectory(), \"pingcastlecloud_*.json.gz\", SearchOption.AllDirectories));\n                    files.Sort();\n                    DisplayAdvancement(files.Count + \" files to import (only ad_*.xml files and pingcastlecloud_*.json.gz files are uploaded)\");\n                    var reports = new List<KeyValuePair<string, string>>();\n                    var aadreports = new List<KeyValuePair<string, string>>();\n                    int i = 1;\n                    foreach (string file in files)\n                    {\n                        if (i % 50 == 0)\n                        {\n                            DisplayAdvancement(\"Uploading file up to #\" + i);\n                            SendViaAPI(reports, aadreports);\n                            reports.Clear();\n                        }\n                        if (!file.EndsWith(\".json.gz\", StringComparison.OrdinalIgnoreCase))\n                        {\n                            string filename = Path.GetFileNameWithoutExtension(file);\n                            reports.Add(new KeyValuePair<string, string>(filename, File.ReadAllText(file)));\n                        }\n                        else\n                        {\n                            aadreports.Add(new KeyValuePair<string, string>(file, file));\n                        }\n                        i++;\n                    }\n                    if (reports.Count > 0 || aadreports.Count > 0)\n                        SendViaAPI(reports, aadreports);\n                }\n            );\n        }\n\n        public bool GenerateDemoReportTask()\n        {\n            return StartTask(\"Generating demo reports\",\n                    () =>\n                    {\n                        string path = Path.Combine(Settings.InputDirectory, \"demo\");\n                        if (!Directory.Exists(path))\n                        {\n                            Directory.CreateDirectory(path);\n                        }\n                        var consolidation = PingCastleReportHelper<HealthcheckData>.LoadXmls(Settings.InputDirectory, Settings.FilterReportDate);\n                        if (consolidation.Count == 0)\n                        {\n                            WriteInRed(\"No report has been found. Please generate one with PingCastle and the Health Check mode. The program will stop.\");\n                            return;\n                        }\n                        consolidation = PingCastleReportHelper<HealthcheckData>.TransformReportsToDemo(consolidation);\n                        foreach (HealthcheckData data in consolidation)\n                        {\n                            string domain = data.DomainFQDN;\n                            var endUserReportGenerator = new ReportHealthCheckSingle();\n                            string html = endUserReportGenerator.GenerateReportFile(data, License, Path.Combine(path, data.GetHumanReadableFileName()));\n                            data.SetExportLevel(ExportLevel);\n                            string xml = DataHelper<HealthcheckData>.SaveAsXml(data, Path.Combine(path, data.GetMachineReadableFileName()), Settings.EncryptReport);\n                        }\n\n                    }\n                );\n        }\n\n        // return JWT token\n        void SendViaAPIGetJwtToken(WebClient client)\n        {\n            ServicePointManager.Expect100Continue = false;\n            client.UseDefaultCredentials = true;\n            client.Proxy = WebRequest.DefaultWebProxy;\n            if (client.Proxy == null)\n            {\n                Trace.WriteLine(\"No proxy\");\n            }\n            else\n            {\n                Trace.WriteLine(\"with proxy\");\n                Trace.WriteLine(\"Using proxy:\" + client.Proxy.GetProxy(new Uri(Settings.apiEndpoint)));\n                Trace.WriteLine(\"Is bypassed:\" + client.Proxy.IsBypassed(new Uri(Settings.apiEndpoint)));\n            }\n            Version version = Assembly.GetExecutingAssembly().GetName().Version;\n            client.Headers.Add(HttpRequestHeader.ContentType, \"application/json\");\n            client.Headers.Add(HttpRequestHeader.UserAgent, \"PingCastle \" + version.ToString(4));\n            //client.Headers.Add(\"Authorization\", token);\n            string token;\n            byte[] answer = null;\n            try\n            {\n                //https://docs.microsoft.com/en-us/dotnet/api/system.net.securityprotocoltype?view=netcore-3.1\n                // try enable TLS1.1\n                try\n                {\n                    System.Net.ServicePointManager.SecurityProtocol = (System.Net.SecurityProtocolType)(768 | (int)System.Net.ServicePointManager.SecurityProtocol);\n                }\n                catch\n                {\n                }\n                // try enable TLS1.2\n                try\n                {\n                    System.Net.ServicePointManager.SecurityProtocol = (System.Net.SecurityProtocolType)(3072 | (int)System.Net.ServicePointManager.SecurityProtocol);\n                }\n                catch\n                {\n                }\n                // try enable TLS1.3\n                try\n                {\n                    System.Net.ServicePointManager.SecurityProtocol = (System.Net.SecurityProtocolType)(12288 | (int)System.Net.ServicePointManager.SecurityProtocol);\n                }\n                catch\n                {\n                }\n                string location = Dns.GetHostEntry(Environment.MachineName).HostName;\n                Trace.WriteLine(\"location: \" + location);\n                Trace.WriteLine(\"apikey: \" + Settings.apiKey);\n                byte[] data = Encoding.Default.GetBytes(\"{\\\"apikey\\\": \\\"\" + ReportHelper.EscapeJsonString(Settings.apiKey) + \"\\\",\\\"location\\\": \\\"\" + ReportHelper.EscapeJsonString(location) + \"\\\"}\");\n                answer = client.UploadData(Settings.apiEndpoint + \"api/Agent/Login\", \"POST\", data);\n                token = Encoding.Default.GetString(answer);\n                Trace.WriteLine(\"token: \" + token);\n                client.Headers.Add(HttpRequestHeader.Authorization, token);\n            }\n            catch (WebException ex)\n            {\n                if (ex.Status == WebExceptionStatus.SecureChannelFailure)\n                {\n                    WriteInRed(\"If you require TLS 1.2 or 1.3 for API, be sure you have installed the Windows patch to support TLS 1.2 or 1.3\");\n                    WriteInRed(\"See kb3140245 and KB4019276 for TLS 1.2\");\n                    WriteInRed(\"Be sure also that .NET has been patched to handle the TLS version\");\n                }\n                if (ex.Response != null)\n                {\n                    var responseStream = ex.Response.GetResponseStream();\n                    if (responseStream != null)\n                    {\n                        using (var reader = new StreamReader(responseStream))\n                        {\n                            string responseText = reader.ReadToEnd();\n                            throw new UnauthorizedAccessException(responseText);\n                        }\n                    }\n                }\n                throw new UnauthorizedAccessException(ex.Message);\n            }\n        }\n\n        string SendViaAPIUploadOneReport(WebClient client, string filename, string xml)\n        {\n            byte[] answer = null;\n            Version version = Assembly.GetExecutingAssembly().GetName().Version;\n            client.Headers.Add(HttpRequestHeader.ContentType, \"application/json\");\n            client.Headers.Add(HttpRequestHeader.UserAgent, \"PingCastle \" + version.ToString(4));\n            try\n            {\n                Trace.WriteLine(\"using filename:\" + filename);\n                var request = \"{\\\"xmlReport\\\": \\\"\" + ReportHelper.EscapeJsonString(xml) + \"\\\",\\\"filename\\\":\\\"\" + ReportHelper.EscapeJsonString(filename) + \"\\\"}\";\n                byte[] data = Encoding.ASCII.GetBytes(request);\n                answer = client.UploadData(Settings.apiEndpoint + \"api/Agent/SendReport\", \"POST\", data);\n                var o = Encoding.Default.GetString(answer);\n                Trace.WriteLine(\"answer:\" + o);\n                return o;\n            }\n            catch (WebException ex)\n            {\n                Trace.WriteLine(\"Status: \" + ex.Status);\n                Trace.WriteLine(\"Message: \" + ex.Message);\n                if (ex.Response != null)\n                {\n                    var responseStream = ex.Response.GetResponseStream();\n                    if (responseStream != null)\n                    {\n                        using (var reader = new StreamReader(responseStream))\n                        {\n                            string responseText = reader.ReadToEnd();\n                            if (string.IsNullOrEmpty(responseText))\n                                responseText = ex.Message;\n                            throw new PingCastleException(responseText);\n                        }\n                    }\n                }\n                else\n                {\n                    Trace.WriteLine(\"WebException response null\");\n                }\n                throw;\n            }\n        }\n\n        string SendViaAPIUploadOneAADReport(WebClient client, string filename, Stream filecontent)\n        {\n            byte[] answer = null;\n            Version version = Assembly.GetExecutingAssembly().GetName().Version;\n            client.Headers.Add(HttpRequestHeader.UserAgent, \"PingCastle \" + version.ToString(4));\n            //client.Headers.Add(HttpRequestHeader.ContentType,  \"multipart/form-data;\n            try\n            {\n                Trace.WriteLine(\"using filename:\" + filename);\n                /*byte[] data;\n                using (var multipartcontent = new MultipartFormDataContent())\n                {\n                    multipartcontent.Headers.ContentType.MediaType = \"multipart/form-data\";\n                    multipartcontent.Add(new StreamContent(filecontent), \"file\", filename);\n                    data = multipartcontent.ReadAsByteArrayAsync().GetAwaiter().GetResult();\n                }\n                answer = client.UploadData(Settings.apiEndpoint + \"api/Agent/SendAADReport\", \"POST\", data);*/\n                answer = client.UploadFile(Settings.apiEndpoint + \"api/Agent/SendAADReport\", filename);\n\n                var o = Encoding.Default.GetString(answer);\n                Trace.WriteLine(\"answer:\" + o);\n                return o;\n            }\n            catch (WebException ex)\n            {\n                Trace.WriteLine(\"Status: \" + ex.Status);\n                Trace.WriteLine(\"Message: \" + ex.Message);\n                if (ex.Response != null)\n                {\n                    var responseStream = ex.Response.GetResponseStream();\n                    if (responseStream != null)\n                    {\n                        using (var reader = new StreamReader(responseStream))\n                        {\n                            string responseText = reader.ReadToEnd();\n                            if (string.IsNullOrEmpty(responseText))\n                                responseText = ex.Message;\n                            throw new PingCastleException(responseText);\n                        }\n                    }\n                }\n                else\n                {\n                    Trace.WriteLine(\"WebException response null\");\n                }\n                throw;\n            }\n        }\n\n        public class CustomComputationRule\n        {\n            public string ComputationType { get; set; }\n            public int Score { get; set; }\n            public int Threshold { get; set; }\n            public int Order { get; set; }\n        }\n        public class CustomRule\n        {\n            public string RiskID { get; set; }\n            public int? MaturityLevel { get; set; }\n            public List<CustomComputationRule> Computation { get; set; }\n        }\n\n        public class AgentSettings\n        {\n            public string License { get; set; }\n            public string ExportLevel { get; set; }\n            public List<CustomRule> CustomRules { get; set; }\n        }\n\n        private void ProcessSettings(WebClient client)\n        {\n            Version version = Assembly.GetExecutingAssembly().GetName().Version;\n            client.Headers.Add(HttpRequestHeader.ContentType, \"application/json\");\n            client.Headers.Add(HttpRequestHeader.UserAgent, \"PingCastle \" + version.ToString(4));\n            try\n            {\n                string answer = client.DownloadString(Settings.apiEndpoint + \"api/Agent/GetSettings\");\n                Trace.WriteLine(\"answer:\" + answer);\n                DisplayAdvancement(\"OK\");\n\n                // TinyJson is extracted from https://github.com/zanders3/json\n                // MIT License\n                var deserializedResult = JSONParser.FromJson<AgentSettings>(answer);\n\n                // could also use this serializer, but starting .Net 4 only (not .net 3)\n                //var serializer = new System.Web.Script.Serialization.JavaScriptSerializer();\n                //var deserializedResult = serializer.Deserialize<AgentSettings>(answer);\n\n                if (deserializedResult.License != null)\n                {\n                    try\n                    {\n                        var license = new ADHealthCheckingLicense(deserializedResult.License);\n\n                        Trace.WriteLine(\"License checked\");\n                        Trace.WriteLine(\"CustomerNotice: \" + license.CustomerNotice);\n                        Trace.WriteLine(\"DomainLimitation: \" + license.DomainLimitation);\n                        Trace.WriteLine(\"DomainNumberLimit: \" + license.DomainNumberLimit);\n                        Trace.WriteLine(\"Edition: \" + license.Edition);\n                        Trace.WriteLine(\"EndTime: \" + license.EndTime);\n\n                        if (license.EndTime > DateTime.Now)\n                        {\n                            License = license;\n                            DisplayAdvancement(\"A new license has been retrieved from the API. Using it.\");\n                            if (!string.IsNullOrEmpty(license.CustomerNotice))\n                            {\n                                DisplayAdvancement(license.CustomerNotice);\n                            }\n                        }\n                        else\n                        {\n                            DisplayAdvancement(\"A new license has been retrieved from the API. But the license is out-dated.\");\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        Trace.WriteLine(ex.Message);\n                    }\n                }\n                if (!string.IsNullOrEmpty(deserializedResult.ExportLevel))\n                {\n                    try\n                    {\n                        // enum parsed as string to avoid a problem is a newer version of the enum is sent over the wire\n                        ExportLevel = (PingCastleReportDataExportLevel)Enum.Parse(typeof(PingCastleReportDataExportLevel), deserializedResult.ExportLevel);\n                    }\n                    catch (Exception)\n                    {\n                        Trace.WriteLine(\"Unable to parse the level [\" + deserializedResult.ExportLevel + \"] to one of the predefined value (\" + String.Join(\",\", Enum.GetNames(typeof(PingCastleReportDataExportLevel))) + \")\");\n                    }\n                }\n                if (deserializedResult.CustomRules != null && deserializedResult.CustomRules.Count != 0)\n                {\n                    if (string.IsNullOrEmpty(License.Edition) || License.Edition == \"Auditor\")\n                    {\n                        Trace.WriteLine(\"Custom rules not allowed\");\n                    }\n                    else\n                    {\n                        foreach (var rule in deserializedResult.CustomRules)\n                        {\n                            var hcrule = RuleSet<HealthcheckData>.GetRuleFromID(rule.RiskID);\n                            if (hcrule == null)\n                            {\n                                Trace.WriteLine(\"Rule \" + rule.RiskID + \" ignored because not found\");\n                                continue;\n                            }\n                            if (rule.MaturityLevel != null)\n                            {\n                                hcrule.MaturityLevel = (int)rule.MaturityLevel;\n                            }\n                            if (rule.Computation != null && rule.Computation.Count > 0)\n                            {\n                                var computations = new List<RuleComputationAttribute>();\n                                foreach (var c in rule.Computation)\n                                {\n                                    RuleComputationType type;\n                                    try\n                                    {\n                                        // enum parsed as string to avoid a problem is a newer version of the enum is sent over the wire\n                                        type = (RuleComputationType)Enum.Parse(typeof(RuleComputationType), c.ComputationType);\n                                    }\n                                    catch (Exception)\n                                    {\n                                        Trace.WriteLine(\"Unable to parse the RuleComputationType [\" + c.ComputationType + \"] to one of the predefined value (\" + String.Join(\",\", Enum.GetNames(typeof(RuleComputationType))) + \")\");\n                                        computations.Clear();\n                                        break;\n                                    }\n                                    computations.Add(new RuleComputationAttribute(type, c.Score, c.Threshold, c.Order));\n                                }\n                                if (computations.Count > 0)\n                                {\n                                    hcrule.RuleComputation.Clear();\n                                    hcrule.RuleComputation.AddRange(computations);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            catch (WebException ex)\n            {\n                if (ex.Status == WebExceptionStatus.ProtocolError && ex.Response != null)\n                {\n                    var resp = (HttpWebResponse)ex.Response;\n                    if (resp.StatusCode == HttpStatusCode.NotFound) // HTTP 404\n                    {\n                        Trace.WriteLine(\"GetSettings page not found\");\n                        DisplayAdvancement(\"Not found\");\n                        return;\n                    }\n                }\n                Trace.WriteLine(\"Status: \" + ex.Status);\n                Trace.WriteLine(\"Message: \" + ex.Message);\n                if (ex.Response != null)\n                {\n                    var responseStream = ex.Response.GetResponseStream();\n                    if (responseStream != null)\n                    {\n                        using (var reader = new StreamReader(responseStream))\n                        {\n                            string responseText = reader.ReadToEnd();\n                            if (string.IsNullOrEmpty(responseText))\n                                responseText = ex.Message;\n                            throw new PingCastleException(responseText);\n                        }\n                    }\n                }\n                else\n                {\n                    Trace.WriteLine(\"WebException response null\");\n                }\n                throw;\n            }\n        }\n\n        void SendViaAPI(IEnumerable<KeyValuePair<string, string>> xmlreports, IEnumerable<KeyValuePair<string, string>> jsonreports)\n        {\n            StartTask(\"Send via API\",\n                    () =>\n                    {\n                        if (!Settings.apiEndpoint.EndsWith(\"/\"))\n                            Settings.apiEndpoint += \"/\";\n                        Trace.WriteLine(\"apiendpoint: \" + Settings.apiEndpoint);\n                        using (WebClient client = new WebClient())\n                        {\n                            try\n                            {\n                                SendViaAPIGetJwtToken(client);\n                                DisplayAdvancement(\"API Login OK\");\n                            }\n                            catch (UnauthorizedAccessException ex)\n                            {\n                                WriteInRed(\"Login failed (\" + ex.Message + \")\");\n                                return;\n                            }\n                            foreach (KeyValuePair<string, string> report in xmlreports)\n                            {\n                                try\n                                {\n                                    string answer = SendViaAPIUploadOneReport(client, report.Key, report.Value);\n                                    DisplayAdvancement(report.Key + \"-\" + (String.IsNullOrEmpty(answer) ? \"OK\" : answer));\n                                }\n                                catch (Exception ex)\n                                {\n                                    Trace.WriteLine(\"Exception:\");\n                                    Trace.WriteLine(ex.GetType());\n                                    Trace.WriteLine(ex.Message);\n                                    Trace.WriteLine(ex.StackTrace);\n                                    WriteInRed(report.Key);\n                                    DisplayException(null, ex);\n                                }\n                            }\n                            foreach (KeyValuePair<string, string> report in jsonreports)\n                            {\n                                try\n                                {\n                                    using (var stream = File.OpenRead(report.Value))\n                                    {\n                                        string answer = SendViaAPIUploadOneAADReport(client, report.Key, stream);\n                                        DisplayAdvancement(report.Key + \"-\" + (String.IsNullOrEmpty(answer) ? \"OK\" : answer));\n                                    }\n                                }\n                                catch (Exception ex)\n                                {\n                                    Trace.WriteLine(\"Exception:\");\n                                    Trace.WriteLine(ex.GetType());\n                                    Trace.WriteLine(ex.Message);\n                                    Trace.WriteLine(ex.StackTrace);\n                                    WriteInRed(report.Key);\n                                    DisplayException(null, ex);\n                                }\n                            }\n                        }\n                    });\n        }\n\n        bool RetrieveSettingsViaAPI()\n        {\n            bool ret = true;\n            StartTask(\"Retrieve Settings via API\",\n                    () =>\n                    {\n                        if (!Settings.apiEndpoint.EndsWith(\"/\"))\n                            Settings.apiEndpoint += \"/\";\n                        Trace.WriteLine(\"apiendpoint: \" + Settings.apiEndpoint);\n                        using (WebClient client = new WebClient())\n                        {\n                            try\n                            {\n                                SendViaAPIGetJwtToken(client);\n                                DisplayAdvancement(\"API Login OK\");\n                            }\n                            catch (UnauthorizedAccessException ex)\n                            {\n                                WriteInRed(\"Login failed (\" + ex.Message + \")\");\n                                ret = false;\n                                return;\n                            }\n                            try\n                            {\n                                ProcessSettings(client);\n                            }\n                            catch (Exception ex)\n                            {\n                                Trace.WriteLine(\"Exception:\");\n                                Trace.WriteLine(ex.GetType());\n                                Trace.WriteLine(ex.Message);\n                                Trace.WriteLine(ex.StackTrace);\n                                DisplayException(null, ex);\n                            }\n                        }\n                    });\n            return ret;\n        }\n\n        void SendEmail(string email, List<string> domains, List<Attachment> Files)\n        {\n            Version version = Assembly.GetExecutingAssembly().GetName().Version;\n            var versionString = version.ToString(4);\n#if DEBUG\n            versionString += \" Beta\";\n#endif\n            string body = @\"Hello,\n\nThis is the PingCastle program sending reports for:\n- \" + String.Join(\"\\r\\n- \", domains.ToArray());\n            SendEmail(email, \"[PingCastle][\" + versionString + \"] Reports for \" + String.Join(\",\", domains.ToArray()), body, Files);\n        }\n\n        void SendEmail(string email, bool xml, bool html)\n        {\n            List<Attachment> Files = new List<Attachment>();\n            List<string> domains = new List<string>();\n            if (xml)\n            {\n                foreach (string domain in xmlreports.Keys)\n                {\n                    if (!domains.Contains(domain))\n                        domains.Add(domain);\n                    Files.Add(Attachment.CreateAttachmentFromString(xmlreports[domain], HealthcheckData.GetMachineReadableFileName(domain, dateReports.ContainsKey(domain) ? dateReports[domain] : DateTime.Now)));\n                }\n                foreach (string tenant in aadjsonreport.Keys)\n                {\n                    if (!domains.Contains(tenant))\n                        domains.Add(tenant);\n                    Files.Add(new Attachment(aadjsonreport[tenant]));\n                }\n            }\n            if (html)\n            {\n                foreach (string domain in htmlreports.Keys)\n                {\n                    if (!domains.Contains(domain))\n                        domains.Add(domain);\n                    Files.Add(Attachment.CreateAttachmentFromString(htmlreports[domain], HealthcheckData.GetHumanReadableFileName(domain, dateReports.ContainsKey(domain) ? dateReports[domain] : DateTime.Now)));\n                }\n                foreach (string tenant in aadhtmlreport.Keys)\n                {\n                    if (!domains.Contains(tenant))\n                        domains.Add(tenant);\n                    Files.Add(new Attachment(aadhtmlreport[tenant]));\n                }\n            }\n            if (Files.Count == 0)\n                return;\n            SendEmail(email, domains, Files);\n        }\n\n        void SendEmail(string recipient, string subject, string body, List<Attachment> attachments)\n        {\n            StartTask(\"Send email\",\n                    () =>\n                    {\n                        MailMessage message = new MailMessage();\n                        foreach (Attachment attachment in attachments)\n                        {\n                            message.Attachments.Add(attachment);\n                        }\n                        message.Subject = subject;\n                        message.Body = body;\n                        message.To.Add(recipient);\n                        if (!String.IsNullOrEmpty(Settings.mailNotification))\n                        {\n                            message.Headers.Add(\"Disposition-Notification-To\", Settings.mailNotification);\n                            message.Headers.Add(\"Return-Receipt-To\", Settings.mailNotification);\n                        }\n                        SmtpClient client = new SmtpClient();\n                        if (Settings.smtpTls)\n                            client.EnableSsl = true;\n                        else\n                            client.EnableSsl = (client.Port == 587 || client.Port == 465);\n                        if (!String.IsNullOrEmpty(Settings.smtpLogin) || !String.IsNullOrEmpty(Settings.smtpPassword))\n                            client.Credentials = new NetworkCredential(Settings.smtpLogin, Settings.smtpPassword);\n                        client.Send(message);\n                    }\n                    );\n        }\n\n        void UploadToWebsite(string filename, string filecontent)\n        {\n            StartTask(\"Upload to website\",\n                    () =>\n                    {\n                        WebClient client = new WebClient();\n                        if (!String.IsNullOrEmpty(Settings.sharepointuser))\n                            client.Credentials = new NetworkCredential(Settings.sharepointuser, Settings.sharepointpassword);\n                        else\n                            client.UseDefaultCredentials = true;\n                        string url = Settings.sharepointdirectory + (Settings.sharepointdirectory.EndsWith(\"/\") ? null : \"/\") + filename;\n                        Trace.WriteLine(\"url: \" + url);\n                        client.UploadData(url, \"PUT\", Encoding.UTF8.GetBytes(filecontent));\n                    }\n            );\n        }\n\n        public bool BotTask()\n        {\n            return StartTask(\"Running Bot\",\n                    () =>\n                    {\n                        var bot = new PingCastle.Bot.Bot();\n                        bot.Run(Settings.botPipe);\n                    }\n            );\n        }\n\n        public bool ExportTask()\n        {\n            return StartTask(\"Running Export\",\n                    () =>\n                    {\n\n                        PropertyInfo pi = Settings.Export.GetProperty(\"Name\");\n                        IExport export = PingCastleFactory.LoadExport(Settings.Export);\n                        string name = pi.GetValue(export, null) as string;\n                        DisplayAdvancement(\"Running export \" + name);\n                        export.Initialize(Settings);\n                        if (export.QueryForAdditionalParameterInInteractiveMode() != DisplayState.Run)\n                            return;\n                        string file = \"ad_export_\" + name + \"_\" + Settings.Server + \".txt\";\n                        export.Export(file);\n                        DisplayAdvancement(\"Results saved to \" + new FileInfo(file).FullName);\n                    }\n            );\n        }\n\n        // function used to encapsulate a task and to fail gracefully with an error message\n        // return true is success; false in cas of failure\n        delegate void TaskDelegate();\n        private bool StartTask(string taskname, TaskDelegate taskdelegate)\n        {\n            Console.ForegroundColor = ConsoleColor.Yellow;\n            Console.WriteLine(\"Starting the task: \" + taskname);\n            Console.ResetColor();\n            Trace.WriteLine(\"Starting \" + taskname + \" at:\" + DateTime.Now);\n            Stopwatch watch = new Stopwatch();\n            watch.Start();\n            try\n            {\n                taskdelegate();\n            }\n            catch (PingCastleException ex)\n            {\n                WriteInRed(\"[\" + DateTime.Now.ToLongTimeString() + \"] An exception occured when doing the task: \" + taskname);\n                WriteInRed(ex.Message);\n                if (ex.InnerException != null)\n                {\n                    Trace.WriteLine(ex.InnerException.Message);\n                }\n            }\n            // better exception message\n            catch (PingCastleDataException ex)\n            {\n                WriteInRed(\"[\" + DateTime.Now.ToLongTimeString() + \"] An exception occured when doing the task: \" + taskname);\n                WriteInRed(ex.ReportName + \"-\" + ex.Message);\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                WriteInRed(\"[\" + DateTime.Now.ToLongTimeString() + \"] An exception occured when doing the task: \" + taskname);\n                WriteInRed(\"Exception: \" + ex.Message);\n                Trace.WriteLine(ex.StackTrace);\n            }\n            catch (SmtpException ex)\n            {\n                WriteInRed(\"[\" + DateTime.Now.ToLongTimeString() + \"] An exception occured when doing the task: \" + taskname);\n                WriteInRed(\"Exception: \" + ex.Message);\n                WriteInRed(\"Error code: \" + ex.StatusCode);\n                Trace.WriteLine(\"Type:\" + ex.GetType().ToString());\n                if (ex.InnerException != null)\n                {\n                    WriteInRed(ex.InnerException.Message);\n                }\n                WriteInRed(\"Check the email configuration in the .config file or the network connectivity to solve the problem\");\n            }\n            catch (ReflectionTypeLoadException ex)\n            {\n                WriteInRed(\"[\" + DateTime.Now.ToLongTimeString() + \"] An exception occured when doing the task: \" + taskname);\n                WriteInRed(\"Exception: \" + ex.Message);\n                foreach (Type type in new List<Type>(ex.Types))\n                {\n                    WriteInRed(\"Was trying to load type: \" + type.FullName);\n                }\n                DisplayException(taskname, ex);\n                return false;\n            }\n            // default exception message\n            catch (Exception ex)\n            {\n                WriteInRed(\"[\" + DateTime.Now.ToLongTimeString() + \"] An exception occured when doing the task: \" + taskname);\n                // type EndpointNotFoundException is located in Service Model using dotnet 3.0. What if run on dotnet 2.0 ?\n                if (ex.GetType().FullName == \"System.ServiceModel.EndpointNotFoundException\")\n                {\n                    WriteInRed(\"Exception: \" + ex.Message);\n                }\n                else if (ex.GetType().FullName == \"System.Runtime.InteropServices.COMException\")\n                {\n                    WriteInRed(\"Exception: \" + ex.Message);\n                    WriteInRed(\"HRESULT: \" + ex.HResult);\n                }\n                // type DirectoryServicesCOMException not found in dotnet core\n                else if (ex.GetType().FullName == \"System.DirectoryServices.DirectoryServicesCOMException\")\n                {\n                    WriteInRed(\"An exception occured while querying the Active Directory\");\n                    string ExtendedErrorMessage = (string)ex.GetType().GetProperty(\"ExtendedErrorMessage\").GetValue(ex, null);\n                    int ExtendedError = (int)ex.GetType().GetProperty(\"ExtendedError\").GetValue(ex, null);\n                    WriteInRed(\"Exception: \" + ex.Message + \"(\" + ExtendedErrorMessage + \")\");\n                    if (ExtendedError == 234)\n                    {\n                        WriteInRed(\"This error occurs when the Active Directory server is under load\");\n                        WriteInRed(\"Suggestion: try again and if the error persists, check for AD corruption\");\n                        WriteInRed(\"Try our corruption scanner to identify the object or check for AD integrity using ntdsutil.exe\");\n                    }\n                }\n                else if (ex.GetType().FullName == \"System.DirectoryServices.ActiveDirectory.ActiveDirectoryServerDownException\")\n                {\n                    WriteInRed(\"Active Directory not Found: \" + ex.Message);\n                }\n                else if (ex.GetType().FullName == \"System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException\")\n                {\n                    WriteInRed(\"Active Directory Not Found: \" + ex.Message);\n                }\n                else\n                {\n                    DisplayException(taskname, ex);\n                    return false;\n                }\n            }\n            watch.Stop();\n            Trace.WriteLine(\"Stoping \" + taskname + \" at: \" + DateTime.Now);\n            Trace.WriteLine(\"The task \" + taskname + \" took \" + watch.Elapsed);\n            Console.ForegroundColor = ConsoleColor.Yellow;\n            Console.WriteLine(\"Task \" + taskname + \" completed\");\n            Console.ResetColor();\n            return true;\n        }\n\n        public static void DisplayException(string taskname, Exception ex)\n        {\n            if (!String.IsNullOrEmpty(taskname))\n            {\n                WriteInRed(\"[\" + DateTime.Now.ToLongTimeString() + \"] An exception occured when doing the task: \" + taskname);\n                WriteInRed(\"Note: you can run the program with the switch --log to get more detail\");\n                Trace.WriteLine(\"An exception occured when doing the task: \" + taskname);\n            }\n            WriteInRed(\"Exception: \" + ex.Message);\n            Trace.WriteLine(\"Type:\" + ex.GetType().ToString());\n            var fnfe = ex as FileNotFoundException;\n            if (fnfe != null)\n            {\n                WriteInRed(\"file:\" + fnfe.FileName);\n            }\n            if (ex.GetType().ToString() == \"Novell.Directory.Ldap.LdapException\")\n            {\n                string novelMessage = null;\n                int novelResultCode;\n                novelResultCode = (int)ex.GetType().GetProperty(\"ResultCode\").GetValue(ex, null);\n                novelMessage = ex.GetType().GetProperty(\"LdapErrorMessage\").GetValue(ex, null) as string;\n                WriteInRed(\"message: \" + novelMessage);\n                WriteInRed(\"ResultCode: \" + novelResultCode);\n            }\n            WriteInDarkRed(ex.StackTrace);\n            if (ex.InnerException != null)\n            {\n                Trace.WriteLine(\"innerexception: \");\n                DisplayException(null, ex.InnerException);\n            }\n        }\n\n\n        private static void WriteInRed(string data)\n        {\n            Console.ForegroundColor = ConsoleColor.Red;\n            Console.WriteLine(data);\n            Trace.WriteLine(\"[Red]\" + data);\n            Console.ResetColor();\n        }\n\n        private static void WriteInDarkRed(string data)\n        {\n            Console.ForegroundColor = ConsoleColor.DarkRed;\n            Console.WriteLine(data);\n            Trace.WriteLine(\"[DarkRed]\" + data);\n            Console.ResetColor();\n        }\n\n        private void DisplayAdvancement(string data)\n        {\n            string value = \"[\" + DateTime.Now.ToLongTimeString() + \"] \" + data;\n            Console.WriteLine(value);\n            Trace.WriteLine(value);\n        }\n    }\n}\n"
        },
        {
          "name": "app.config",
          "type": "blob",
          "size": 5.4189453125,
          "content": "<?xml version=\"1.0\"?>\n<configuration>\n  <configSections>  \n    <section name=\"LicenseSettings\" type=\"PingCastle.ADHealthCheckingLicenseSettings, PingCastle\" />\n    <section name=\"encryptionSettings\" type=\"PingCastle.Healthcheck.EncryptionSettings, PingCastle\" />\n    <section name=\"honeyPotSettings\" type=\"PingCastle.Healthcheck.HoneyPotSettings, PingCastle\" />\n    <section name=\"infrastructureSettings\" type=\"PingCastle.Healthcheck.InfrastructureSettings, PingCastle\" />\n    <section name=\"customRulesSettings\" type=\"PingCastle.Rules.CustomRulesSettings, PingCastle\" />\n  </configSections>\n  <!-- Compatibility with all .Net version starting from 3.0 (for WCF) -->\n  <startup useLegacyV2RuntimeActivationPolicy=\"true\">\n    <supportedRuntime version=\"v4.0\"/>\n    <supportedRuntime version=\"v2.0.50727\"/>\n  </startup>\n  <!--\n  For brand customization for customers having a license\n  <appSettings>\n    <add key=\"BrandLogo\" value=\"base64 encoded icon\"/>\n    <add key=\"BrandCss\" value=\".pingcastle-css {color: red;}\"/>\n    <add key=\"BrandJs\" value=\"alert('test')\"/>\n  </appSettings>\n  -->\n  <!-- Windows XP or .Net 3.0 supports only the class RijndaelManaged which is not fips compliant -->\n  <runtime>\n    <enforceFIPSPolicy enabled=\"false\"/>\n    <!--\n    If you enable this, you will be able to use Tlsv1.2 to push report\n    But you won't test SSLv3 or TLS 1.0 on your DC\n    \n    Note: this settings require to have the KB3154518 installed.\n    See https://docs.microsoft.com/en-us/dotnet/framework/network-programming/tls for more info\n    \n    If you are admin we recommend to set :\n    - for dotnet 2, 3, 3.5\n    the SystemDefaultTlsVersions registry key\n    see:\n    https://support.microsoft.com/en-us/help/3154520/support-for-tls-system-default-versions-included-in-the-net-framework\n    - for dotnet 4\n    the SchUseStrongCrypto registry key\n    https://docs.microsoft.com/en-us/officeonlineserver/enable-tls-1-1-and-tls-1-2-support-in-office-online-server#enable-strong-cryptography-in-net-framework-45-or-higher\n    \n    So you can use both TLS 1.2 and next to upload your reports and test for old protocols too.\n    -->\n    <AppContextSwitchOverrides value=\"Switch.System.Net.DontEnableSystemDefaultTlsVersions=false\"/>\n  </runtime>\n  <LicenseSettings\n    license=\"\" />\n  <!-- Encryption seeting to protect the report for a loss of confidentiality -->\n  <!-- Change the encryption key ! -->\n  <!-- Use the switch -generate-key to generate keys -->\n  <encryptionSettings encryptionKey=\"default\">\n    <RSAKeys>\n      <KeySettings name=\"default\" publicKey=\"&lt;RSAKeyValue&gt;&lt;Modulus&gt;rXQQDs1PVbp1L7o4DwM51HJIDyXpDIBCg1PEkRy6jNJxCYxwbm9vK9ma92IQiT642gYsbb7N/6VW21xgukULMizAFVCfyofkQzK7mI8CH4HsQB+XjKVGK8ONDO9zVYwyGZBcz0pRjnm9eDj6vPpYOZqeAgr1n7aqBNgZPZolYoc=&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt;\"\n                   privateKey=\"&lt;RSAKeyValue&gt;&lt;Modulus&gt;rXQQDs1PVbp1L7o4DwM51HJIDyXpDIBCg1PEkRy6jNJxCYxwbm9vK9ma92IQiT642gYsbb7N/6VW21xgukULMizAFVCfyofkQzK7mI8CH4HsQB+XjKVGK8ONDO9zVYwyGZBcz0pRjnm9eDj6vPpYOZqeAgr1n7aqBNgZPZolYoc=&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;P&gt;xEXa3R3dmyxV2rLlhKHOuuhJi+LvSgkO/Ddlia7BqrTnPZ72SQUFqbd/6kcYo87KKR9rL/60lb1AH3Ms5o/whw==&lt;/P&gt;&lt;Q&gt;4jyDCyiXmWgtY+bzZKE5v1estW/s2vwcZ3xcGoGnAkIhOLiEZnK6atQSgb32l8h06P2KCZWc01IgRk0ihvV+AQ==&lt;/Q&gt;&lt;DP&gt;vyhd6l+NFvWORKtZ+Nxy8P0NrG2AqvW5n5IAlaEbxDvev9hTfHiktFAhCDboW5oqsPSFu7/xd6lTi43sXD4yfw==&lt;/DP&gt;&lt;DQ&gt;4i5fURufHOcTYiq2saeipVLRP4ALzA97kla5emKfBtn4fs2yyP3ws/ccHYw+6hamE33PsK9cX8VesQpS95yeAQ==&lt;/DQ&gt;&lt;InverseQ&gt;rQiTcmkCvJHI4e8qDEQS1Efs/1j9xB9fbn3J0vNngWbPjdrY8YCOWu8SoAVzCeZ+WBR7FwOut0yL8/pAERlA0A==&lt;/InverseQ&gt;&lt;D&gt;DmYqqRfpJJxAezBR1Ak4BUdhbQSAJr4FB4LuN/+zCtqzcI/8i2Zry6+aWjwFVGdlEBBgItIqprTSk45FJ2Fw7tvOBso+VEOAxNYe8Rpw1RgZeN5fRGm5O685SjNawHA9potK8v2R5DzpWgLcSEqkGYg4clh1Y/s0Qb+OW2NP+gE=&lt;/D&gt;&lt;/RSAKeyValue&gt;\"/>\n    </RSAKeys>\n  </encryptionSettings>\n  <!-- honeypot settings -->\n  <honeyPotSettings>\n    <HoneyPots>\n      <HoneyPot samAccountName=\"HoneyPot\" />\n      <HoneyPot distinguishedName=\"CN=ADIANT-VIRTUAL-,CN=Computers,DC=test,DC=mysmartlogon,DC=com\"/>\n      <HoneyPot samAccountName=\"HoneyPotInexistant\"/>\n    </HoneyPots>\n  </honeyPotSettings>\n  <!-- reserved for paid customers to describe their infrastructure and alter the rule computation to avoid false positives -->\n  <infrastructureSettings>\n    <!-- You can use this section to declare that you are using Riverbed devices.\n    Please look at the Microsoft documentation about the side effects that this kind of device generates:\n    https://docs.microsoft.com/en-us/troubleshoot/windows-server/identity/info-devices-configured-rodcs\n    -->\n    <Riverbeds>\n      <!-- There is no need to add a final $ in the samAccountName of the Riverbed-->\n      <Riverbed samAccountName=\"Riverbed\"/>\n    </Riverbeds>\n  </infrastructureSettings>\n\n  <!-- reserved for paid customers (starting with Pro license to customize rules -->\n  <!-- <customRulesSettings>\n    <CustomRules>\n      <CustomRule RiskId=\"A-Krbtgt\">\n        <Computations>\n          <Computation Type=\"TriggerOnThreshold\" Score=\"50\" Threshold=\"1464\" Order=\"1\"/>\n        </Computations>\n      </CustomRule>\n    </CustomRules>\n  </customRulesSettings>-->\n  <!-- Email settings -->\n  <system.net>\n    <mailSettings>\n      <smtp from=\"from@address.com\" deliveryMethod=\"Network\">\n        <network host=\"stmp.server.com\" port=\"25\" userName=\"username\" password=\"password\"/>\n      </smtp>\n    </mailSettings>\n  </system.net>\n</configuration>\n"
        },
        {
          "name": "changelog.txt",
          "type": "blob",
          "size": 36.4052734375,
          "content": "3.3.0.1\n* fix an issue where rule is not displayed when impacted users/computers count is less than 100.\n\n3.3.0.0\n* adjusted the rules S-DesEnabled, S-PwdNotRequired, S-PwdNeverExpires, P-Delegated, A-PreWin2000Other, S-PrimaryGroup, P-ServiceDomainAdmin, \n  A-AdminSDHolder to display directly the list of impacted users in the rule if the number is limited (hardcoded to 100) so Pro / Enterprise users can set accounts in exceptions\n* handle the case where the property ms-DS-MachineAccountQuota has been removed (you can add as many computers as you want)\n* ignore RPC coerce test if the computer used to run PingCastle is the DC (false positive)\n* added the rule S-FirewallScript which recommends firewall rules against script engines (suggestion of Steen Poulsen)\n* added the rule S-TerminalServicesGPO which recommends session timeout for RDP (suggestion of Steen Poulsen)\n* Upgraded .NET Framework version to 4.7.2\n* Release will contain version for 4.5.2 and 4.7.2\n* Upgraded nuget packages\n* Security improvements\n\n3.2.1.0\n* adjust P-DisplaySpecifier to be more relaxed when foreign path are used\n* P-DNSAdmin is not triggered anymore (following our previous notification)\n* added troubleshooting tests in case PingCastle is asked to connect to LDAPS and if the remote certificate is untrusted\n* adjust powershell requests in S-OS-* rules descriptions\n* fix a problem when with S-PwdLastSet-45 / S-PwdLastSet-90 when the DC has an incorrect date and set lastlogondate in the future\n* add support for ms-LAPS-EncryptedPassword\n* fix a problem in AzureAD when PRT was used even if manual credential was provided\n* disabled the rule UserConsentCompanyData because the AAD changed drastically\n* remove computer inherited class (managed service account) from AES missing control\n* added the rule A-SmartCardPwdRotation checking for msDS-ExpirePasswordsOnSmartCardOnlyAccounts\n* added the rule P-RODCKrbtgtOrphan checking for krbtgt_* account associated to RODC that are orphans\n* added the rule S-AesNotEnabled checking for AES not enabled on service accounts\n* added the rule S-PwdLastSet-Cluster checking for password change on clusters (at least every 3 years)\n* added the rule A-RootDseAnonBinding to check for anonymous binding on rootDse for DC with Windows 2019+\n* added the rule S-FolderOptions to recommend to open .js .jse files using notepad instead of the default script engine\n* added the rule S-DefenderASR to implement Defender ASR rules. Even if another AV is installed, it will cover computers in a default state\n* Pro: added a workaround to fix issues when ClientSecret is not defined for AAD authentication\n\n3.2.0.1\n* fix a regression in S-ADRegistration if multiple SeMachineAccountPrivilege have been defined, including Everyone like group and if MachineAccountQuota is not zero\n\n3.2.0.0\n* added a RPC scanner for DC (python coercer like script but without exploiting) and --skip-dc-rpc to disable this scan\n* added the rule A-DC-Coerce matching the RPC scanner output\n* changed S-OldNtlm and S-ADRegistration to take in account GPO overwriting settings\n\n3.1.5.0\n* exclude cluster objects (which looks like computers) from healthcheck analysis. In export computers, new column is added to reflect the cluster status\n* fix an issue with restricted group membership\n* excluded gmsa from P-ProtectedUsers and P-Delegated\n* added a message in the console if the custom rule failed to load (instead of just being logged)\n* adjusted the implementation logic of P-AdminLogin for better adjustment of customization\n* rewrote the collection logic for admin last login to avoid S4USelf side effect (aka collect it on all DC instead of relying on lastlogontimestamp)\n* added whenChanged to the user export function\n* fix a bug when the replication metadata of some objects is denied\n* fix an issue relative to parallele work for msi analysis\n* clarify the rationale of S-OS-W10 by adding the number of active computers\n* display the list of accounts in S-PwdNeverExpires if the count is less than 100 (hardcoded) so I can be added in exception for licensed version\n* change the logic to handle AzureADKerberos accounts for S-DC-NotUpdated and S-DC-Inactive\n* added a remark in the report about the impossibility to reach 100% LAPS deployment given the collected stats\n* add Windows OS details (such as SP or release) on the consolidation report\n\n3.1.0.1\n* fix local membership if many settings are defined\n* fix LAPS collection (signed / unsigned bug)\n\n3.1.0.0\n* fix a bug for machineaccountquote when GPO has been rewritten to remove all users\n* fix a regression introduced in previous version in P-TrustedCredManAccessPrivilege\n* added a password distribution chart in consolidation report (reserved for licensee)\n* added LAPS last change date for \"export computers\"\n* using new LAPS attribute ms-LAPS-Password\n* wording change for A-SmartCardRequired\n* added the rule A-DCLdapsProtocolAdvanced for Tls 1.0 and Tls 1.1 detection (informational)\n* added the rule S-DefaultOUChanged for informational use of redircmp - thanks to Andy Wendel\n* changed the rule A-MembershipEveryone to check for \"Local Users and group\" assignation\n* added the rule P-AdminEmailOn to check if privileged accounts have an email (informative & maturity level 3)\n* added the rule P-UnprotectedOU to check for unprotected OU (informative & maturity level 4)\n* added the rule S-OS-2012 and S-DC-2012 that will trigger after Oct 10 2023 (unless --I-swear-... is set)\n\n3.0.0.4\n* fix channel binding issue (if server was configured with only TLS1.2 and client was not configured for TLS1.2 in the default algorithm it was not tested)\n* fix integrity bug for paid subscriptions\n\n3.0.0.3\n* fix T-AlgsAES to not be enforced for unidirectional trust (trusdirection=2)\n* removed rule P-DNSDelegation as it has no meaning anymore\n* added LAPS usage analysis & statictics (for paid customers)\n* change the timeout of TlsCheck from 10ms to 1s\n* fix setintegrity missing\n* fix kerberos armoring detection bug - thanks to Andy Wendel\n* change timeout for Tls check (was only 10ms) to 1s\n\n3.0.0.0\n* migrate from .net 3 to .net 4.5\n* integrated PingCastleCloud project\n* fix rule A-CertEnrollChannelBinding which was triggering even if CB is enabled\n* fix test ldap signature on ldap and not ldaps\n* fix a logic issue when testing for integrity in LDAP\n* fix sorting and filtering issue\n* collect exchange info and display it and sccm in the report\n* migration from .net 3 to .net 4.5\n* added the rule S-KerberosArmoring and S-KerberosArmoringDC\n* fix visibility on DNS zone replicated on DC only (not the DomainDns zone)\n* fix HTTP ConnectionTester for NTLM only websites (refusing Negotiate)\n* changed A-WeakRSARootCert2 to be triggered in 2031 instead of 2030\n* added the rule P-DisplaySpecifier to check for DisplaySpecifier abuse\n* align S-ADRegistrationSchema with ANSSI rule\n* added the rule S-FunctionalLevel1/3/4 to check the functional level of the domain / forest\n* parallelize PKI checks for environments with several ADCS entries\n* fix a bug in T-SIDHistoryDangerous which made it ineffective\n* added the hidden option --doNotTestSMBv1 to not trigger SOC when testing for SMB v1\n* adapt the rule S-ADRegistration in case there is no GPO settings SeMachineAccountPrivilege\n* adjust the label of the rule A-WeakRSARootCert2 to clarify that certificate with 2048 bits module should expires before 2030\n* fix a regression with server containing * pattern\n* disabled --I-swear-I-paid-win7-support because extended support is not available anymore\n* fixed P-AdminPwdTooOld and P-ProtectedUsers which were checking also disabled accounts\n* fixed A-WSUS-SslProtocol incorrect LDAP reference in rule description\n* license can be pushed using API but only the banner for the embedded license was shown leading to customer confusing. Added a message to avoid that\n* added the rule S-OldNtlm to hunt DC accepting NTLMv1 and used in coerced authenthication attacks\n\n2.11.0.0\n* fix: the rule S-OS-W10 was triggering even if there is no enabled Windows 10\n* added the rules A-DCLdapSign and A-DCLdapsChannelBinding\n* added the rules A-CertEnrollHttp and A-CertEnrollChannelBinding\n* if an api key is provided, test it at the beginning of the processing (instead of doing at the end)\n* enable custom rules processing for Pro / Enterprise versions\n* added the rule T-AlgsAES to check for trust algorithms\n* fix a problem when Users container has been removed\n* fix P-AdminLogin when administrator login date is in the future (can happen when reloading backups)\n* fix perform PKI tests only if the PKI is installed\n* reworked the rule set to be more performant\n* fix a problem when a OU used for PKI has been manually removed\n* fix S-PwdNeverExpires - HealthMailbox* accounts with a password change within 40 days are excluded\n* fix S-Inactive - change 6*31 days to 6 months. If a password change occured within 6 months (no login) the password is now considered as active\n* added for auditor licenses, a feature to have a dashboard for RC4 to AES migration in Kerberos\n* change the powershell command to check for S-DesEnabled\n* added SCCM listing\n* added the possibility to specify honeypot accounts by a DN (the setting is \"distinguishedName\")\n* migrate to bootstrap 5, popperjs 2 and bootstrap-table (instead of datatables)\n* added table export for licensed users\n* fix rules checking for external path location (server.domain.fqdn) when uri is based on IP instead of FQDN\n* fix the computation of constrained delegation with protocol transition (this impacts rule P-DelegationDCt2a4d)\n* added a note for P-AdminLogin about S4u2Self\n* added the rule A-CertTempNoSecurity\n* changed A-CertTempAnyone and other rules so the program considers that the group Domain Computers is like Everyone if ms-DS-MachineAccountQuota is non zero\n* added the rule A-DC-WebClient to hunt for WebClient service enabled on domain controllers\n* modifed P-Delegated to add HoneyPot account checks\n* fix change the evaluation order for Embedded systems (vs Winows 7) when reducing OS name into a short description\n* modify delegations gathering: filter entreprise domain controllers and check base of configuration partition\n\n2.10.1.1\n* for guest enablement, check if useraccountcontrol is not zero (can be the case when checked on a DC)\n* change maturity level for rule P-DNSAdmin, the score and the description\n\n2.10.1.0\n* fix more readable error message if the xml file is corrupted\n* fix a bug in P-DNSDelegation to avoid false positive when the computer is in another language than english\n* fix LTSC vs LTSB for older version of Windows 10\n* reimplemented RPC calls to avoid AV false positive\n* fix a bug in the ui if the export menu is cancelled\n* added the rule A-HardenedPaths related to STIG V-63577 (MS15-011 and MS15-014)\n* modify the report to hightlight in particular for delegations DCSync / AADConnect rights\n* added \"Add access check for current user in the share scanner\"\n* fix problem if there is a conflict replication when defining FSMO roles\n* fix: Do not fail if the .config file has being modified with bugged honeypot data\n* adding option --quota to limit the LDAP query speed\n* add a warning if there is a misconfiguration in the schema\n* added benchmark button\n* fix a modelisation issue when a child domain cannot reach its forest root\n* added the rule S-JavaSchema to check the presence of the RFC 2713 schema extension (java objects representation in LDAP)\n* modified the rule S-PwdLastSet-45 and S-PwdLastSet-90 to be applicable only on server data (lot of false positive for user computers connected once in a while)\n* added a section in the report to display certificate template delegations (excluded admins for clarity as other delegations)\n* added the rules S-WSUS-NoPinning, S-WSUS-UserProxy, S-WSUS-HTTP, A-WSUS-SslProtocol for WSUS configuration\n* modified the wording of the explanation of the rule P-ServiceDomainAdmin\n* added a function in export to save in a file (and on screen) all changes that occurs in real time (modulo the replication time)\n* fixed a typo in UnixPassword check which was clearing the data\n* added azure ad configuration & AzureADConnect info in the report if found\n* fixed S-DC-Inactive to not display an error about the AzureAD Kerberos account\n* fixed a bug when reloading very old PingCastle reports\n* added the rule A-DsHeuristicsDoNotVerifyUniqueness if the mitigation for CVE-2021-42282 has been disabled\n* added the rule A-DsHeuristicsLDAPSecurity if the mitigation for CVE-2021-42291 has been disabled\n* updated S-OS-W10 with new end of support dates\n* added the rule S-OS-Win8 for Windows 8 / 8.1 which is out of regular support\n* added the rule A-Guest to be sure the guest account is disabled\n* added the rule A-DnsZoneAUCreateChild for level 4 hardening about dnszone\n\n2.10.0.0\n* change pre-win 2000 compabitility group to handle group rename\n* added a setting to change the LDAP page size (to test when the AD corruption message is showing)\n* update to bootstrap 4.6.0\n* add the ability to see the rules for each level in the maturity report\n* be more scoped when looking for sites GPO\n* fix: replace \"admins\" string in code, because they were some strings unmatched (especially in P-Kerberoasting & P-ServiceDomainAdmin)\n* fix S-PwdLastSet-45 S-PwdLastSet-90: the check was made against inactive computers instead of active ones\n* added the rule A-DnsZoneTransfert which checks for DNS Zone Transfers\n* added the rule A-LAPS-Joined-Computers which checks for manually joined computers - the owner of the computer objects see the LAPS password - thanks to Andy Wendel\n* fix P-AdminNum for a better wording if it matches\n* fix unixpassword LDAP search query for optimization (looks only on active user account)\n* added the MS FAQ for Krbtgt reset in the A-Krbtgt rule links\n* fix a non timeout issue when SSL connection are \"suspensed\" by a network device\n* fix when using a custom identity, forward the impersonation token to all threads launched by the application\n* added the rule A-CertTempAgent, A-CertTempAnyPurpose, A-CertTempAnyone, A-CertTempCustomSubject for certificate template abuse\n* added Mitre Att&ck mapping & reports\n* added the rule A-PreWin2000AuthenticatedUsers for information for the printnightmare problem\n* added a detail by OS (Windows 10 edition / Windows 2008 R2)\n* added the rule S-OS-W10 for Windows 10 non supported versions\n* added details for DC certificate\n* added DC certificates to A-CertROCA and A-WeakRSARootCert\n* change the algorithm which finds the DnsAdmin group to be more flexible for translation and moves\n* fix password authentication that was not working in some cases\n* for honeypot accounts, change P-Kerberoasting to take it into account\n* fix NetCease check to be case insensitive (thanks to @ralish)\n* added an option for scanners to use a file as input instead of querying the AD\n* added an export section to export users or computers (a scanner was already present and moved to this section)\n* added the rule S-ADRegistrationSchema for schema class check à la CVE-2021-34470\n* fixed P-AdminLogin that wasn't effective (this check was active only during the first 35 days of the domain)\n* defer DataTable initialization (css for table) to avoid any problem in table stop javascript\n* fix a bug when msDS-GroupManagedServiceAccount and msDS-ManagedServiceAccount were not counted as group member\n* fix a problem in P-ServiceDomainAdmin to look individually at each password change and to set them as exception if needed\n* change the rule detail rendering to avoid issues with strange items\n* added the option --datefile\n\n2.9.2.0\n* modify P-UnkownDelegation to not be triggered with SID having their RID < 1000 (RID is the last number)\n* modify A-AuditDC to not request simple audit policies anymore and removing the need for Other Account Logon Events reserved for future use\n* modify S-PwdNeverExpires description to take in account linux servers which do not change their machine password\n* modify P-ProtectedUsers to change the limit from 1 to 2\n* added exception for AzureADKerberos in S-DCRegistration and AzureADKerberos\n* Fix user scanner which where filtering only admincount users\n* Fix authentication by user/password when the user was submitted as UPN\n* Fix the program was resilient for control characters when serializing to xml, but not to non existing character\n* Fix a problem when duplicated SID (\\0CNF:) were used in permissions\n* Add gpo applied order property (aka gpo precedence)\n* rewrote the way subnets are collect to avoid the 1500 items limit (MS-ADTS 3.1.1.3.4.6 aka MaxValRange)\n* Add in the report lDAPIPDenyList (IP denied for LDAP communication) if any found\n* Fix: the GPO full info was not displayed in the report in the section Obfuscated Passwords\n* Add linked GPO to site when browsing GPO info\n* Added the new service for the remote scanner based on github PR\n* Be more resilient if the security of DC objects cannot be examined\n* Fix documentation links\n* Add scanner computer version\n* Added a comment in PingCastle.exe.config about uploading reports using the API with TLS 1.2 and next vs testing old protocols\n* Fix some gallery.technet.microsoft.com link (other need to be fixed)\n\n2.9.1.0\n* added options for the scanner to select only dc, servers, workstations\n* added the privilege SeManageVolumePrivilege to the list of dangerous privileges\n* when a rule crashes, continue the execution but with a message asking the user to call the support\n* fix a problem when RODC Denied Users are from a domain PingCastle can't access\n* group SID History data was not analyzed regarding its creation date\n* added a zerologon scanner (not in healthcheck because it will trigger IDS & AV in the future\n* fix a bug when a SID being duplicated is used as member of a group\n* Do not raise an alert when the account sensitive checkbox is not checked but the user is in protected users. Thanks Fanaw.\n* Do not raise an alert if there is only one user not in protected users as this is a regular admin practice. Thanks Oliver-André\n* Add the possibility to have DC in the honeyPot account. Typically used for riverbed devices for example\n* specify in the rule A-NTFRSOnSysvol that NTFRS is supported up to Windows 2022 at this time - also match only if there is a DC < win 2019\n* add new definition of the ESET AV for AV scanner module\n\n2.9.0.0\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\nInformation: the 3.0 version of PingCastle will run by default on .net 4 instead of .net 2 (this may break the compatibiliy with Windows 2000)\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n* when building the map, the program was taking the first part of the FQDN as a shortname. Now it uses the Netbios name if it is available\n* change tooltip description for the trust section of the healthcheck report\n* added the rule S-DC-2008 and S-OS-2008 to check for obsolete 2008 servers which are no longer supported\n* Fix: A-AuditDC - GPO at the root level was ignored and OU specific too. Now the GPO is checked per DC.\n* Fix: A-AuditDC - Reword the rule A-AuditDC for better understanding\n* change A-Krbtgt to be triggered only after 1 year (previously 40 days)\n* Fix: In some scanners, the comma was used instead of a tab\n* Fix: Avoid a crash if the security descriptor of the msi files cannot be retrieved\n* Fix: better switch in case of failure of ADWS to LDAP\n* Added the rule A-CertROCA to check for recoverable public key (ROCA vulnerability) [ANSSI: vuln1_certificates_vuln]\n* Added the rule A-CertWeakDSA to check for DSA key use in certificate used for digital signature [ANSSI: vuln1_certificates_vuln]\n* Added the rule A-CertWeakRsaComponent to check for low RSA exponent\n* Added the rule A-WeakRSARootCert2 to check for rsa module length between 1024 & 2048 (friend of A-WeakRSARootCert)\n* Added the rule A-DsHeuristicsAllowAnonNSPI to check if the heuristics fAllowAnonNSPI is enabled\n* Added the rule P-RODCAllowedGroup to check for the Allowed RODC Password Replication Group group\n* Added the rule P-RODCDeniedGroup to check for the Denied RODC Password Replication Group group\n* Added the rule A-NTFRSOnSysvol to check the usage of the old protocol NTFRS on SYSVOL replication\n* Added the rules A-DnsZoneUpdate1 and A-DnsZoneUpdate2 about DNS unsecure updates\n* Added the rule S-DC-Inactive to check for inactive DC\n* Added the rule S-PwdLastSet-DC to check for regular password change on DC\n* Added the rule T-SIDHistoryDangerous to check for SID lower than 1000 or well known in SIDHistory\n* Added the rule S-PwdNeverExpires to check for accounts with never expiring passwords\n* Added the rule S-DCRegistration to check if DC are well registered (aka detect fake DC)\n* Added the rule P-DelegationDCt2a4d P-DelegationDCa2d2 and P-DelegationDCsourcedeleg for DC delegation analysis\n* Added the rule A-PreWin2000Other to be the companion of A-PreWin2000Anonymous\n* Added the rule P-ProtectedUsers to check if all privileged accounts are member of the protected users group\n* Added the rule S-PwdLastSet-45 and S-PwdLastSet-90 for workstations without the automatic password change disabled\n* Added the rule P-AdminPwdTooOld to check for admin passwords older than 3 years\n* Added the rule S-NoPreAuthAdmin, which is a split of the rule S-NoPreAuth, to match admins\n* Added the rule P-DNSAdmin to check for members of the DNS Admins group\n* Added the rule P-RODCRevealOnDemand P-RODCNeverReveal and P-RODCAdminRevealed for RODC checks\n* Added the rule P-RODCSYSVOLWrite to check for RODC write access to the SYSVOL volume\n* Added the rule A-NoNetSessionHardening to check if the NetCease mitigation has been applied\n* Added the rule A-UnixPwd to check for attributes known to contains password\n* Added the rule T-AzureADSSO to check for password rotation with AzureAD SSO (AZUREADSSOACC)\n* Added the rule S-OS-Win7 to check for Windows 7. PingCastle is looking for support purchased from MS.\n* Change the rule reports to include ANSSI rules\n* Change the threshold of S-Inactive from 15 to 25% to match user_accounts_dormant rule\n* Change the category of P-ControlPathIndirectMany and P-ControlPathIndirectEveryone to the new Control Path category\n* Change the rule P-AdminNum to add a new limit of 50 admins\n* Change the cagory of the rule P-DelegationEveryone, P-PrivilegeEveryone, P-TrustedCredManAccessPrivilege, P-UnconstrainedDelegation, P-UnkownDelegation\n* Change the rule A-MinPwdLen to check only GPO applied to something\n* Change the way GPO are evaluated in rules: if the GPO is disabled or not applied, no anomaly is found\n* Change the rule A-MembershipEveryone to not trigger an alert when Authenticated users is a member of BUILTIN\\Users\n* Adding features exclusive for our customers, such as maturity evaluation, and charts\n* Added the scanner export_user for a quick user analysis\n* Added pagination and search in healthcheck report\n* For AdminSDHolder users check, added the date in the report (written as 'Event') when the attribute admincount has been set (via replication metadata)\n* Auditor & Enterprise licensee can now brand the report by using Appsettings/BrandLogo for base64 logo and Appsettings/BrandCss & BrandJs for raw Css & Js to inject\n* make visible the rule ID in the healthcheck report in the rule description\n* Removed BSI reference as the document is not online anymore\n* Added ms-mcs-admpwd read check in delegations\n* Fix members of admin groups outside the AD were not visible in the report\n* Add some VPAT / RGAA V4 compability\n* update the rule P-DNSDelegation to informative as it was assigned the identifier CVE-2021-40469 and fixed by a patch in October 2021\n\n2.8.0.0\n* reworked the way third party components are included in reports for better html auditing (aka Content Security Policy)\n* added the rule P-DNSDelegation to check delegation on the MS DNS server which can be used to take control of the domain\n* show healthcheck rule detail in a table if possible\n* remove the \"network configuration operators\" group from privileged groups as it has no impact on the domain by itself\n* split the allow login / deny login settings from privileges and from DC to another dedicated section\n* added the rule P-TrustedCredManAccessPrivilege to match STIG rule V-63843\n* added Auto logon info if found in the GPO passwords section\n* added the rule P-LogonDenied to check for tiers isolation. Only in application if more than 200 users & 200 computers\n* be resilient if a new rule category is added in the future so future reports can be read by this PingCastle version\n* fix a problem when control character is found in data (loginscript for example) and cannot be serialized in xml\n* added an experimental bluekeep scanner. To avoid AV detection, the code is commented. Decomment and recompile to use it.\n* added SeSecurityPrivilege (access to the security event log) in the list of privileges to monitor.\n* merged the permission report and the healthcheck report\n* added the rule P-ControlPathIndirectEveryone and P-ControlPathIndirectMany for control path analysis\n* added the rule A-AuditDC for audit policy\n* update to bootstrap 4.4.1\n* change the algorithm to locate the server. Faster and compatible with kerberos only domains.\n* added the rule A-DCLdapsProtocol looking for SSLv2 and SSLv3 active on DC\n* added the rule A-AuditPowershell to check for powershell auditing (informative)\n* added the rule S-OS-Vista to check for Vista presence (which is not supported anymore). Windows 7 & 2008 added after extended support stops.\n* added honey pot setting to avoid honey pot accounts to be in error\n* added a new view for the DC certificates\n\n2.7.1.0\n* update the TGT delegation algorithm after the July update (new flag CROSS_ORGANIZATION_ENABLE_TGT_DELEGATION)\n\n2.7.0.0\n* added a network map inspired from hilbert curves\n* fix a bug when doing a map with very complicated data\n* adjust the krbtgt last password change when a replication set it to \"not set\"\n* added the rule P-ExchangePrivEsc to check for Exchange misconfiguration at install\n* added the rule P-LoginDCEveryone to check if everybody can logon to a DC\n* added the rule P-RecycleBin to check for the Recycle Bin feature (at forest level)\n* added the rule P-DsHeuristicsAdminSDExMask to check if AdminSDHolder has been disabled for some critical groups\n* added the rule P-DsHeuristicsDoListObject to check if the feature DoListObject has been enabled (informative only)\n* added the rule P-RecoveryModeUnprotected to check if any user can go into recovery mode without being admin\n* added the rule A-LDAPSigningDisabled to check if the LDAP signing mode has been set to None\n* added the rule A-DCRefuseComputerPwdChange to check that Domain Controllers don't deny the change of computers account password\n* added the rule P-DelegationFileDeployed to check for deployed file via GPO (msi, file copied, ...)\n* added the rule T-FileDeployedOutOfDomain to check for deployed file via GPO (msi, file copied, ...) from outside this domain\n* added the rule A-NoGPOLLMNR which checks if LLMNR can be used to steal credentials\n* added the rule T-TGTDelegation to check for TGT delegation on forest trusts\n* added the rule P-Kerberoasting to check for keberoasting (SPN for admin account). A mitigation via a regular password change is allowed.\n* update the score produced by the rule S-SMB-v1 from 1 to 10\n* fix the scanner command line when targeting multiple computer (single and multiple were inverted)\n* added the scanner antivirus\n* added the scanner laps_bitlocker\n* fix a bug in the graph report when multiple files were examinated in parallele\n* add a transition msDS-AllowedToActOnBehalfOfOtherIdentity to the graph report\n* fix a bug when computing msDS-Lockout* in PSO (time were divided by 5)\n* fix rule A-LMHashAuthorized which were not triggering due to a bug and improved its documentation\n* improve the healtcheck report and added a comment to locate the NTLMstore (certificate section)\n* fix GPP Password for scheduled task - only 1 out of 4 kind of scheduled tasks were checked\n* fix support for missing well known sid S-1-5-32-545 for rules\n* fix a tedious bug when using LDAP and when requesting the property Objectclass - it is not available in the result using the native API\n* fix a tedious bug when reading SMB2 data (input was inverted with output) which gave inaccurate results regarding signature\n* PingCastle does now have a default license and can be run without the .config file\n  In this case, the compatibility shims are removed and forced under .Net 2 engine. To run under .Net 4, a recompile is needed.\n\n2.6.0.0\n* fix a problem for early version of LDAP undetected : in ms-*-AdmPwd, MCS was replaced by company name\n* integrate many hidden functions into the \"scanner mode\" to be more easy to use\n* removing the ms17-010 scanner from the source because antivirus are so stupid that they cannot make the difference between a vulnerability scanner & an exploitation kit\n* added many scanners (aclscanner, ...)\n* breaking change: admin accounts where checks for lock, smart card, ... even if the account is disabled. This is not the case anymore.\n* tuned S-DC-SubnetMissing to avoid dealing with local ipv6 loopback address (::1)\n* added the rule A-DC-Spooler and the spooler scanner to check for print spooler accessible remotely (used to collect computer credentials via unconstrained delegation)\n* added the rule A-NotEnoughDC to check domains have at least 2 DC\n* added the rule P-UnconstrainedDelegation to check for unconstrained delegation in kerberos (the data was already reported)\n* in relation with P-UnconstrainedDelegation, change the way accounts \"trusted for delegation\" are selected. Change useraccountcontrol flag from 0x01000000 to 0x80000\n* fix in healthcheck report: the reversible password detail section was only displayed if there was unconstrained delegation in the domain\n* added the rule P-ExchangeAdminSDHolder to check for the Exchange modification of the AdminSDHolder object\n* added the rule P-DelegationKeyAdmin to check for boggus Windows 2016 installation\n* added the (informative) rule P-OperatorsEmpty to check the recommendation to have the account and server operators empty\n* added the rule P-DelegationGPOData to check for too large permissions granted to GPO items\n* added the rule P-PrivilegeEveryone to check for too large GPO assigned privileges\n* adjust the Domain Controller selection for tests (aka: number of DC in a domain & checks performed on them)\n* remove the --split-OU technique which was not used and add an automatic protocol fallback in case of failure (ADWS then LDAP for example)\n* allow the use of LDAPS via the --port 636 command switch\n* fix a couple of problem in PingCastleReporting (incorrect numbers, wrong label, inability to load some configuration)\n* Migrate from Bootstrap 3 to Bootstrap 4\n* fix some mono incompatibility\n* fix crash when analysing gpo where scheduled task password is being stored\n* fix A-NoServicePolicy which was triggered when i shouldn't and vice versa\n* add support for Windows 2019\n* fix DnsAdminGroup not found when moved in another OU\n* fix rootDse listing when using credential & required bind\n* extended the rule S-DesEnabled to check also computers account\n* add to the report a link in rules to sections of the report to get more insight\n\n2.5.2.0\n* fix a problem when a dc has been removed but not its computer account but its dns record\n* fix a problem when for the rule A-SmartCardRequired which was triggered each time a \"smart card required\" account was found\n* fix: the decryption process was broken as successful descryption always triggered a failure\n* fix S-DC-SubnetMissing when subnet are duplicated (contains CNF and generated from replication problem)\n* fix NT4 mismatch if the year was not present and include the word \"dataceNTer\"\n* add a check for \"smart card required\" for administrator accounts\n* reworked the menu to be more interactive\n\n2.5.0.0\n* rewrote all rules description / rationale / etc\n* added start and end date for exception\n* breaking: change the date at which the exception / migration is evaluated from current date to report generation date\n* new rules: A-SMB2SignatureNotEnabled A-SMB2SignatureNotRequired S-DC-SubnetMissing P-DelegationLoginScript\n* added an experimental scanner for replication usn check\n* allows DNS Admin group to be moved to another OU than CN=Users (as a reminder, the group is selected based on its description)\n* fix logon logoff script label inverted\n* allow users to be in the guest group for their primary group (was Domain Users only before)\n* record more details about the operating systems (and adapt the reload of previous reports)\n* the rule A-LAPS-Not-Installed, previously informative, now scores 15 points. If the local admin password is set at install, the rule should be put in exception.\n* many adaptation to be used with Ping Castle Enterprise\n\n2.4.3.1\n* add schemainfo checks\n* rework the way replication metadata is collected\n\n2.4.3.0\n* fix compatibility problem with windows 2000\n* fix bugs relative to --no-enum-limit, adminsdholder check, sidhistory without whencreated, reloading without threat model\n* add check related to replication metadata (dsasignature, KrbtgtLastVersion)\n* minor changes in the powerpoint reporting (more detail on the reporting frequency)\n* new rule for mandatory AD backup (microsoft procedure)\n* minor change in reporting (alphabetically order for risk model, ...)\n\n2.4.2.0\n* risk model in the healthcheck report\n* checking for LAPS install\n* scanner for ms17-010 (not in healthcheck)\n* small report improvements\n* small bug fixing (ex: if AdminSDHolder denied to authentiated users)\n\n2.4.1.1\n* better Samba compatibility (linux DC)\n* added smb check functionalities & scanner for workstation\n* added support for PSO\n* rewrote \"scanner\" functionalities to be more user friendly\n* adding dnsadmins as privileged group following https://medium.com/@esnesenon/feature-not-bug-dnsadmin-to-dc-compromise-in-one-line-a0f779b8dc83\n\n2.4.1.0\n* modified the healthcheck report and consolidation to be responsive\n* added in PingCastleReporting the risk map (link between BU & entities)\n* added in PingCastleReporting the Rules report (matched and explanation) and removed --export-hc-rule in PingCastle\n* reworked the report to add a DC view (last startup - for patches, creation date, if presence of null session)\n* add an alert for MS14-068 via startuptime\n* changed P-AdminNum to be less strict (especially for forest root) and A-Krbtgt to be less agressive\n* improve the explanation of some rules\n* various bug fixes in PingCastleReporting\n\n2.4.0.1\n* modified some KPI in PingCastleReporting overview\n* added the flag --smtptls\n* modified the score computation algorithm to take part of migration information in the past (showing evolution of score)\n* modify the bad primary group count by excluding members of guests group\n\n2.4.0.0\n* program rebranded to PingCastle\n* added PingCastleReporting for management reports (powerpoint, history, ...)\n* reworked the advanced module\n  - added the live mode for advanced report\n* handle many domains with the same FQDN (but different sid)\n* rewrote the \"Unknown domain\" algorithm in xls which is reusing the graph made at consolidation\n* add option to set an exception for all domains (set domain as \"*\" in the xls file)\n* add all --explore options\n* rules A-LoginScript, P-Disabled and S-PwdNeverExpires disabled\n* added the rule P-DCOwner to check for DC ownership\n* lowering the points to 0 for P-ServiceDomainAdmin if the passwords are changed regulary\n* add netbios / sid information for forest of domains found indirectly (for matching existing domains)\n* modify the simple node graph to add intermediate score and BU/Entity information when available\n* added mail notification option if mail is read & smtp credential on command line\n* added \"details\" for rules which are difficult to understand without specifics\n* added the domain root for the delegation check\n* disabled the check on dangerous permissions for migration sid history and unexpire password (too much false positives)\n* added sidhistory information for groups to the sidhistory user information (to not forget to remove sidhistory for groups)\n\n2.3.0.1 (cert-ist forum version)\n* add the reachable mode (disabled by default, enabled by default if domain=* and used in interactive mode)\n  This mode scans for domains outside trusts. Discover new domains when run on trusted domains.\n* Reworked the domain maps for visualization and inclusing of the reachable mode data.\n* Add Netbios information in the trust information to be able to match some reachable mode data.\n* Remove the requirement for ADWS. LDAP is used if ADWS is not available (LDAP is far more slower than ADWS)\n\n2.2.1.5\nfix a problem when a distinguished name of an admin contain LDAP request char\n\n2.2.1.4\nfix a problem in the consolidation\nfix a problem if a login script is invalid and cannot be parsed as a url\n\n2.2.1.3\nbug fixing (null session enabled on forest side, PreWin2000 group empty)\nSimplify full graph with bidirectional nodes & red color for unprotected trusts\nadd a simplified graph\n"
        },
        {
          "name": "license.rtf",
          "type": "blob",
          "size": 12.1015625,
          "content": "{\\rtf1\\ansi\\ansicpg1252\\deff0\\nouicompat\\deflang1036\\deflangfe1036{\\fonttbl{\\f0\\fmodern\\fprq1\\fcharset0 Courier New;}}\r\n{\\colortbl ;\\red250\\green156\\blue26;}\r\n{\\*\\generator Riched20 10.0.17134}\\viewkind4\\uc1 \r\n\\pard\\nowidctlpar\\cf1\\b\\f0\\fs22\\lang1033 PingCastle\\cf0\\b0\\par\r\nCopyright (C) 2016-2018 Ping Castle SAS\\par\r\n\\par\r\n\\par\r\nNon-Profit Open Software License (\"Non-Profit OSL\") 3.0\\par\r\n\\par\r\nThis Non-Profit Open Software License (\"Non-Profit OSL\") version 3.0 (the \"License\") applies to any original work of authorship (the \"Original Work\") whose owner (the \"Licensor\") has placed the following licensing notice adjacent to the copyright notice for the Original Work:\\par\r\n\\par\r\nLicensed under the Non-Profit Open Software License version 3.0\\par\r\n\\par\r\n1) Grant of Copyright License. Licensor grants You a worldwide, royalty-free, non-exclusive, sublicensable license, for the duration of the copyright, to do the following:\\par\r\n\\par\r\na) to reproduce the Original Work in copies, either alone or as part of a collective work;\\par\r\n\\par\r\nb) to translate, adapt, alter, transform, modify, or arrange the Original Work, thereby creating derivative works (\"Derivative Works\") based upon the Original Work;\\par\r\n\\par\r\nc) to distribute or communicate copies of the Original Work and Derivative Works to the public, with the proviso that copies of Original Work or Derivative Works that You distribute or communicate shall be licensed under this Non-Profit Open Software License or as provided in section 17(d);\\par\r\n\\par\r\nd) to perform the Original Work publicly; and\\par\r\n\\par\r\ne) to display the Original Work publicly.\\par\r\n\\par\r\n2) Grant of Patent License. Licensor grants You a worldwide, royalty-free, non-exclusive, sublicensable license, under patent claims owned or controlled by the Licensor that are embodied in the Original Work as furnished by the Licensor, for the duration of the patents, to make, use, sell, offer for sale, have made, and import the Original Work and Derivative Works.\\par\r\n\\par\r\n3) Grant of Source Code License. The term \"Source Code\" means the preferred form of the Original Work for making modifications to it and all available documentation describing how to modify the Original Work. Licensor agrees to provide a machine-readable copy of the Source Code of the Original Work along with each copy of the Original Work that Licensor distributes. Licensor reserves the right to satisfy this obligation by placing a machine-readable copy of the Source Code in an information repository reasonably calculated to permit inexpensive and convenient access by You for as long as Licensor continues to distribute the Original Work.\\par\r\n\\par\r\n4) Exclusions From License Grant. Neither the names of Licensor, nor the names of any contributors to the Original Work, nor any of their trademarks or service marks, may be used to endorse or promote products derived from this Original Work without express prior permission of the Licensor. Except as expressly stated herein, nothing in this License grants any license to Licensor's trademarks, copyrights, patents, trade secrets or any other intellectual property. No patent license is granted to make, use, sell, offer for sale, have made, or import embodiments of any patent claims other than the licensed claims defined in Section 2. No license is granted to the trademarks of Licensor even if such marks are included in the Original Work. Nothing in this License shall be interpreted to prohibit Licensor from licensing under terms different from this License any Original Work that Licensor otherwise would have a right to license.\\par\r\n\\par\r\n5) External Deployment. The term \"External Deployment\" means the use, distribution, or communication of the Original Work or Derivative Works in any way such that the Original Work or Derivative Works may be used by anyone other than You, whether those works are distributed or communicated to those persons or made available as an application intended for use over a network. As an express condition for the grants of license hereunder, You must treat any External Deployment by You of the Original Work or a Derivative Work as a distribution under section 1(c).\\par\r\n\\par\r\n6) Attribution Rights. You must retain, in the Source Code of any Derivative Works that You create, all copyright, patent, or trademark notices from the Source Code of the Original Work, as well as any notices of licensing and any descriptive text identified therein as an \"Attribution Notice.\" You must cause the Source Code for any Derivative Works that You create to carry a prominent Attribution Notice reasonably calculated to inform recipients that You have modified the Original Work.\\par\r\n\\par\r\n7) Warranty of Provenance and Disclaimer of Warranty. The Original Work is provided under this License on an \"AS IS\" BASIS and WITHOUT WARRANTY, either express or implied, including, without limitation, the warranties of non-infringement, merchantability or fitness for a particular purpose. THE ENTIRE RISK AS TO THE QUALITY OF THE ORIGINAL WORK IS WITH YOU. This DISCLAIMER OF WARRANTY constitutes an essential part of this License. No license to the Original Work is granted by this License except under this disclaimer.\\par\r\n\\par\r\n8) Limitation of Liability. Under no circumstances and under no legal theory, whether in tort (including negligence), contract, or otherwise, shall the Licensor be liable to anyone for any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or the use of the Original Work including, without limitation, damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses. This limitation of liability shall not apply to the extent applicable law prohibits such limitation.\\par\r\n\\par\r\n9) Acceptance and Termination. If, at any time, You expressly assented to this License, that assent indicates your clear and irrevocable acceptance of this License and all of its terms and conditions. If You distribute or communicate copies of the Original Work or a Derivative Work, You must make a reasonable effort under the circumstances to obtain the express assent of recipients to the terms of this License. This License conditions your rights to undertake the activities listed in Section 1, including your right to create Derivative Works based upon the Original Work, and doing so without honoring these terms and conditions is prohibited by copyright law and international treaty. Nothing in this License is intended to affect copyright exceptions and limitations (including \"fair use\" or \"fair dealing\"). This License shall terminate immediately and You may no longer exercise any of the rights granted to You by this License upon your failure to honor the conditions in Section 1(c).\\par\r\n\\par\r\n10) Termination for Patent Action. This License shall terminate automatically and You may no longer exercise any of the rights granted to You by this License as of the date You commence an action, including a cross-claim or counterclaim, against Licensor or any licensee alleging that the Original Work infringes a patent. This termination provision shall not apply for an action alleging patent infringement by combinations of the Original Work with other software or hardware.\\par\r\n\\par\r\n11) Jurisdiction, Venue and Governing Law. Any action or suit relating to this License may be brought only in the courts of a jurisdiction wherein the Licensor resides or in which Licensor conducts its primary business, and under the laws of that jurisdiction excluding its conflict-of-law provisions. The application of the United Nations Convention on Contracts for the International Sale of Goods is expressly excluded. Any use of the Original Work outside the scope of this License or after its termination shall be subject to the requirements and penalties of copyright or patent law in the appropriate jurisdiction. This section shall survive the termination of this License.\\par\r\n\\par\r\n12) Attorneys' Fees. In any action to enforce the terms of this License or seeking damages relating thereto, the prevailing party shall be entitled to recover its costs and expenses, including, without limitation, reasonable attorneys' fees and costs incurred in connection with such action, including any appeal of such action. This section shall survive the termination of this License.\\par\r\n\\par\r\n13) Miscellaneous. If any provision of this License is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable.\\par\r\n\\par\r\n14) Definition of \"You\" in This License. \"You\" throughout this License, whether in upper or lower case, means an individual or a legal entity exercising rights under, and complying with all of the terms of, this License. For legal entities, \"You\" includes any entity that controls, is controlled by, or is under common control with you. For purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.\\par\r\n\\par\r\n15) Right to Use. You may use the Original Work in all ways not otherwise restricted or conditioned by this License or by law, and Licensor promises not to interfere with or be responsible for such uses by You.\\par\r\n\\par\r\n16) Modification of This License. This License is Copyright  2005 Lawrence Rosen. Permission is granted to copy, distribute, or communicate this License without modification. Nothing in this License permits You to modify this License as applied to the Original Work or to Derivative Works. However, You may modify the text of this License and copy, distribute or communicate your modified version (the \"Modified License\") and apply it to other original works of authorship subject to the following conditions: (i) You may not indicate in any way that your Modified License is the \"Open Software License\" or \"OSL\" and you may not use those names in the name of your Modified License; (ii) You must replace the notice specified in the first paragraph above with the notice \"Licensed under <insert your license name here>\" or with a notice of your own that is not confusingly similar to the notice in this License; and (iii) You may not claim that your original works are open source software unless your Modified License has been approved by Open Source Initiative (OSI) and You comply with its license review and certification process.\\par\r\n\\par\r\n17) Non-Profit Amendment. The name of this amended version of the Open Software License (\"OSL 3.0\") is \"Non-Profit Open Software License 3.0\". The original OSL 3.0 license has been amended as follows:\\par\r\n\\par\r\n(a) Licensor represents and declares that it is a not-for-profit organization that derives no revenue whatsoever from the distribution of the Original Work or Derivative Works thereof, or from support or services relating thereto.\\par\r\n\\par\r\n(b) The first sentence of Section 7 [\"Warranty of Provenance\"] of OSL 3.0 has been stricken. For Original Works licensed under this Non-Profit OSL 3.0, LICENSOR OFFERS NO WARRANTIES WHATSOEVER.\\par\r\n\\par\r\n(c) In the first sentence of Section 8 [\"Limitation of Liability\"] of this Non-Profit OSL 3.0, the list of damages for which LIABILITY IS LIMITED now includes \"direct\" damages.\\par\r\n\\par\r\n(d) The proviso in Section 1(c) of this License now refers to this \"Non-Profit Open Software License\" rather than the \"Open Software License\". You may distribute or communicate the Original Work or Derivative Works thereof under this Non-Profit OSL 3.0 license only if You make the representation and declaration in paragraph (a) of this Section 17. Otherwise, You shall distribute or communicate the Original Work or Derivative Works thereof only under the OSL 3.0 license and You shall publish clear licensing notices so stating. Also by way of clarification, this License does not authorize You to distribute or communicate works under this Non-Profit OSL 3.0 if You received them under the original OSL 3.0 license.\\par\r\n\\par\r\n(e) Original Works licensed under this license shall reference \"Non-Profit OSL 3.0\" in licensing notices to distinguish them from works licensed under the original OSL 3.0 license.\\par\r\n}\r\n\u0000"
        },
        {
          "name": "misc",
          "type": "tree",
          "content": null
        },
        {
          "name": "packages.config",
          "type": "blob",
          "size": 3.2724609375,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<packages>\n  <package id=\"Costura.Fody\" version=\"5.7.0\" targetFramework=\"net452\" developmentDependency=\"true\" />\n  <package id=\"Fody\" version=\"6.8.1\" targetFramework=\"net452\" developmentDependency=\"true\" />\n  <package id=\"Microsoft.NETCore.Platforms\" version=\"1.1.0\" targetFramework=\"net452\" />\n  <package id=\"NETStandard.Library\" version=\"1.6.1\" targetFramework=\"net452\" />\n  <package id=\"System.Collections\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.Collections.Concurrent\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.Diagnostics.Debug\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.Diagnostics.Tools\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.Diagnostics.Tracing\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.Globalization\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.IO\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.IO.Compression\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.Linq\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.Linq.Expressions\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.Net.Http\" version=\"4.3.4\" targetFramework=\"net472\" />\n  <package id=\"System.Net.Primitives\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.ObjectModel\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.Reflection\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.Reflection.Extensions\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.Reflection.Primitives\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.Resources.ResourceManager\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.Runtime\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.Runtime.Extensions\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.Runtime.InteropServices\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.Runtime.InteropServices.RuntimeInformation\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.Runtime.Numerics\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.Security.Cryptography.Algorithms\" version=\"4.3.0\" targetFramework=\"net472\" />\n  <package id=\"System.Security.Cryptography.Encoding\" version=\"4.3.0\" targetFramework=\"net472\" />\n  <package id=\"System.Security.Cryptography.Primitives\" version=\"4.3.0\" targetFramework=\"net472\" />\n  <package id=\"System.Security.Cryptography.X509Certificates\" version=\"4.3.0\" targetFramework=\"net472\" />\n  <package id=\"System.Text.Encoding\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.Text.Encoding.Extensions\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.Text.RegularExpressions\" version=\"4.3.1\" targetFramework=\"net472\" />\n  <package id=\"System.Threading\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.Threading.Tasks\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.Threading.Timer\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.Xml.ReaderWriter\" version=\"4.3.0\" targetFramework=\"net452\" />\n  <package id=\"System.Xml.XDocument\" version=\"4.3.0\" targetFramework=\"net452\" />\n</packages>"
        },
        {
          "name": "pingcastle.ico",
          "type": "blob",
          "size": 33.2646484375,
          "content": null
        },
        {
          "name": "shares",
          "type": "tree",
          "content": null
        },
        {
          "name": "template",
          "type": "tree",
          "content": null
        },
        {
          "name": "testLDAPqueries.ps1",
          "type": "blob",
          "size": 0.677734375,
          "content": "Clear-Host\n$RootDSE = [System.DirectoryServices.DirectoryEntry]([ADSI]\"LDAP://RootDSE\")\n$NC = $RootDSE.Get(\"defaultNamingContext\")\n\n$dn = New-Object System.DirectoryServices.DirectoryEntry (\"LDAP://CN=Users,\" + $NC)\n\n$Rech = new-object System.DirectoryServices.DirectorySearcher($dn)\n$Rech.filter = \"(description=DNS Administrators Group)\"\n$Rech.SearchScope = \"onelevel\"\n#$a=$Rech.PropertiesToLoad.Add(\"distinguishedName\");\n#$a=$Rech.PropertiesToLoad.Add(\"name\");\n#$a=$Rech.PropertiesToLoad.Add(\"nTSecurityDescriptor\");\n$Rech.PageSize = 500;\n\n$colResults = $Rech.FindAll()\n\nforeach ($objResult in $colResults)\n{\n    $objItem = $objResult.Properties;\n    Write-host $objItem.distinguishedname;\n}"
        }
      ]
    }
  ]
}