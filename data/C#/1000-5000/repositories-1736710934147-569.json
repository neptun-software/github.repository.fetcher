{
  "metadata": {
    "timestamp": 1736710934147,
    "page": 569,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "DavidArayan/ezy-slice",
      "stars": 1940,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.01953125,
          "content": "\n*.meta\n\n\\.DS_Store\n"
        },
        {
          "name": "EzySlice",
          "type": "tree",
          "content": null
        },
        {
          "name": "Graphics",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0537109375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 David Arayan\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.716796875,
          "content": "<h3 align=\"center\">\n  <img src=\"Graphics/icon.png?raw=true\" alt=\"EzySlice Logo\" width=\"600\">\n</h3>\n\n[![Twitter: @DavidArayan](https://img.shields.io/badge/contact-DavidArayan-blue.svg?style=flat)](https://twitter.com/DavidArayan)\n[![Join the chat at https://gitter.im/ezyframeworks/ezyslice](https://img.shields.io/badge/chat-gitter/ezyslice-green.svg?style=flat)](https://gitter.im/ezyframeworks/ezyslice)\n[![License](https://img.shields.io/badge/license-MIT-orange.svg?style=flat)](LICENSE)\n[![Codacy Badge](https://api.codacy.com/project/badge/Grade/76175609cae14f4b93feef579c630324)](https://app.codacy.com/app/DavidArayan/ezy-slice?utm_source=github.com&utm_medium=referral&utm_content=DavidArayan/ezy-slice&utm_campaign=Badge_Grade_Dashboard)\n\n* * *\n\n#### Open Source Slicer Framework for the Unity3D Game Engine\n\n-   Ability to slice any convex Mesh using a Plane\n-   UV/Normal/Tangent Space Interpolation for seamless cuts\n-   Flexible and Documented API\n-   No external plugin dependencies, fully written in C#\n-   Updated for Unity3D 2018\n-   MIT Open Source [License](LICENSE)\n\n#### Algorithms in use\n\n-   General purpose Monotone Chain for cross section triangulation for Convex slices\n-   Barycentric Coordinates for UV/Normal/Tangent space Interpolation \n-   Purpose built Triangle to Plane intersection to cover all general cases for slicing\n-   Designed with performance in mind\n\n#### Contributions and Bug Reports\n\n-   Contributions are always welcome and highly appreciated! please use pull request.\n-   Bugs, Comments, General Enquiries and Feature Requests please use the Issue Tracker\n\n#### Example Projects\n\n-   Visit <https://github.com/DavidArayan/EzySlice-Example-Scenes> for example/debug scenes using the Slicer Framework. Example Repository is kept up to date with the latest changes on the main framework.\n-   More Example Projects coming soon!\n\n* * *\n\n#### Usage Examples\n\nGetting started with EzySlice is easy. Below you will find sample usage functions. EzySlice uses extension methods to hide most of the internal complexity.\n\n-   The examples below will slice a GameObject and return SlicedHull object. SlicedHull has functionality for generating the final GameObjects for rendering. An additional API exists to generate the GameObjects automatically without any additional work required.\n-   All functions will return null if slicing fails.\n\n##### SlicedHull Example\n\n```C#\npublic GameObject objectToSlice; // non-null\n\n/**\n * Example on how to slice a GameObject in world coordinates.\n */\npublic SlicedHull Slice(Vector3 planeWorldPosition, Vector3 planeWorldDirection) {\n\treturn objectToSlice.Slice(planeWorldPosition, planeWorldDirection);\n}\n```\n\n##### Direct Instantiated Example\n\n```C#\npublic GameObject objectToSlice; // non-null\n\n/**\n * Example on how to slice a GameObject in world coordinates.\n */\npublic GameObject[] Slice(Vector3 planeWorldPosition, Vector3 planeWorldDirection) {\n\treturn objectToSlice.SliceInstantiate(planeWorldPosition, planeWorldDirection);\n}\n```\n\n-   A custom TextureRegion can be defined to map the final UV coordinates of the cross-section. TextureRegion is essentially a reference to a specific part of a texture in UV coordinate space. This can be useful if single materials are used repeatedly as atlasses.\n\n##### SlicedHull Example\n\n```C#\npublic GameObject objectToSlice; // non-null\n\n/**\n * Example on how to slice a GameObject in world coordinates.\n * Uses a custom TextureRegion to offset the UV coordinates of the cross-section\n */\npublic SlicedHull Slice(Vector3 planeWorldPosition, Vector3 planeWorldDirection, TextureRegion region) {\n\treturn objectToSlice.Slice(planeWorldPosition, planeWorldDirection, region);\n}\n```\n\n##### Direct Instantiated Example\n\n```C#\npublic GameObject objectToSlice; // non-null\n\n/**\n * Example on how to slice a GameObject in world coordinates.\n * Uses a custom TextureRegion to offset the UV coordinates of the cross-section\n */\npublic GameObject[] Slice(Vector3 planeWorldPosition, Vector3 planeWorldDirection, TextureRegion region) {\n\treturn objectToSlice.SliceInstantiate(planeWorldPosition, planeWorldDirection, region);\n}\n```\n\n-   There are cases where supplying the material directly can have performance benefits. In the previous examples, the Slicer will simply create the cross section as a submesh which will allow adding the Material externally when the GameObject is created. By supplying the Material directly, this will allow the Slicer to potentially batch the final results instead of creating repeated submeshes.\n\n##### SlicedHull Example\n\n```C#\npublic GameObject objectToSlice; // non-null\npublic Material crossSectionMaterial; // non-null\n\n/**\n * Example on how to slice a GameObject in world coordinates.\n * Uses a custom TextureRegion to offset the UV coordinates of the cross-section\n * Uses a custom Material\n */\npublic SlicedHull Slice(Vector3 planeWorldPosition, Vector3 planeWorldDirection, TextureRegion region) {\n\treturn objectToSlice.Slice(planeWorldPosition, planeWorldDirection, region, crossSectionMaterial);\n}\n```\n\n##### Direct Instantiated Example\n\n```C#\npublic GameObject objectToSlice; // non-null\npublic Material crossSectionMaterial; // non-null\n\n/**\n * Example on how to slice a GameObject in world coordinates.\n * Uses a custom TextureRegion to offset the UV coordinates of the cross-section\n * Uses a custom Material\n */\npublic GameObject[] Slice(Vector3 planeWorldPosition, Vector3 planeWorldDirection, TextureRegion region) {\n\treturn objectToSlice.SliceInstantiate(planeWorldPosition, planeWorldDirection, region, crossSectionMaterial);\n}\n```\n\n-   Below is a sample on how to generate a TextureRegion. TextureRegion is stored in UV Coordinate space and is a reference to a specific region of a texture.\n\n##### Using a Texture\n\n```C#\n/**\n * Example on how to calculate a custom TextureRegion to reference a different part of a texture\n * \n * px -> The start X Position in Pixel Coordinates\n * py -> The start Y Position in Pixel Coordinates\n * width -> The width of the texture in Pixel Coordinates\n * height -> The height of the texture in Pixel Coordinates\n */\npublic TextureRegion CalculateCustomRegion(Texture myTexture, int px, int py, int width, int height) {\n\treturn myTexture.GetTextureRegion(px, py, width, height);\n}\n```\n\n##### Using a Material\n\n```C#\n/**\n * Example on how to calculate a custom TextureRegion to reference a different part of a texture\n * This example will use the mainTexture component of a Material\n * \n * px -> The start X Position in Pixel Coordinates\n * py -> The start Y Position in Pixel Coordinates\n * width -> The width of the texture in Pixel Coordinates\n * height -> The height of the texture in Pixel Coordinates\n */\npublic TextureRegion CalculateCustomRegion(Material myMaterial, int px, int py, int width, int height) {\n\treturn myMaterial.GetTextureRegion(px, py, width, height);\n}\n```\n"
        }
      ]
    }
  ]
}