{
  "metadata": {
    "timestamp": 1736710677177,
    "page": 27,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "liangxiegame/QFramework",
      "stars": 4559,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.7392578125,
          "content": ".idea\nQFramework.ToolKits/Assets/.qframework\nQFramework.ToolKits/Assets/Plugins/Editor/JetBrains\nJetBrains.meta\nEditor.meta\nQFramework.ToolKits/Builds\nQFramework.ToolKits/Library\nQFramework.ToolKits/Logs\nQFramework.ToolKits/obj\nQFramework.ToolKits/Temp\n*.csproj\nQFramework.ToolKits/AssetBundles\nQFramework.ToolKits/Assets/StreamingAssets/AssetBundles\nQFramework.ToolKits/Build/\nQFramework.Unity2018+/Temp/\nQFramework.Unity2018+/Logs/\nQFramework.Unity2018+/Library/\nQFramework.Unity2018+/Assets/.qframework/\nQFramework.Unity2018+/obj/\nQFramework.Unity2018+/Assets/Plugins/Editor/JetBrains/\nQFramework.Unity2018+/AssetBundles/\nQFramework.Unity2018+/Assets/StreamingAssets/AssetBundles/\nQFramework.Unity2018+/Assets/StreamingAssets/AssetBundles.meta\n.DS_Store\n"
        },
        {
          "name": "Doc.md",
          "type": "blob",
          "size": 269.2109375,
          "content": "# 1. 介绍\r\n# 01. 简介\r\n\r\n大家好，我是 QFramework 的作者 凉鞋，QFramework 从第一次代码提交到现在快 7 年了（2015 年 12 月 \\~ 2022 年 10 月）了，而经过了 7 年时间的打磨，我们终于迎来了 v1.0 版本。\r\n\r\n此教程，将收录于 QFramework 的官方文档，发布于 qframework.cn，同时也会包含在 QFramework.Toolkits 的编辑器内置文档中。\r\n\r\n## QFramework 简介\r\n\r\nQFramework 是一套渐进式、快速开发框架，适用于任何类型的游戏及应用项目。\r\n\r\nQFramework 包含一套 开发架构 和 大量的工具集。\r\n\r\nQFramework 特性速览：\r\n\r\n*   开发架构（QFramework.cs）\r\n  *   简单、易上手、强大\r\n  *   MVC\r\n  *   IOC、分层支持\r\n  *   CQRS 支持\r\n  *   符合 SOLID原则\r\n  *   可以使用 DDD 的方式设计项目\r\n  *   不到 1000 行代码\r\n*   工具集（QFramework.Toolkits）\r\n  *   UIKit 界面\\&View快速开发&管理解决方案\r\n    *   UI、GameObject 的代码生成&自动赋值\r\n    *   界面管理\r\n    *   层级管理\r\n    *   界面堆栈\r\n    *   默认使用 ResKit 方式管理界面资源\r\n    *   可自定义界面的加载、卸载方式\r\n    *   Manager Of Manager 架构集成（不推荐使用）\r\n  *   ResKit 资源快速开发&管理解决方案\r\n    *   AssetBundle 提供模拟模式，开发阶段无需打包即可加载资源\r\n    *   资源名称代码生成支持\r\n    *   同一个 API 可加载 AssetBundle、Resources、网络 和 自定义来源的资源\r\n    *   提供一套引用计数的资源管理模型\r\n  *   AudioKit 音频管理解决方案\r\n    *   提供背景音乐、人声、音效 三种音频播放 API\r\n    *   音量控制\r\n    *   默认使用 ResKit 方式管理音频资源\r\n    *   可自定义音频的加载、卸载方式\r\n  *   CoreKit 提供大量的代码工具\r\n    *   ActionKit：动作序列执行系统\r\n    *   CodeGenKit：代码生成 & 自动序列化赋值工具\r\n    *   EventKit：提供基于类、字符串、枚举以及信号类型的事件工具集\r\n    *   FluentAPI：对大量的 Unity 和 C# 常用的 API 提供了静态扩展的封装（链式 API）\r\n    *   IOCKit：提供依赖注入容器\r\n    *   LocaleKit：本地化&多语言工具集\r\n    *   LogKit：日志工具集\r\n    *   PackageKit：包管理工具，由此可更新框架和对应的插件模块。\r\n    *   PoolKit：对象池工具集，提供对象池的基础上，也提供 ListPool 和 Dictionary Pool 等工具。\r\n    *   SingletonKit：单例工具集\r\n    *   TableKit：提供表格类数据结构的工具集\r\n\r\nQFramework 的设计哲学是从每个细节上提升开发效率。\r\n\r\n同时 QFramework 还包含丰富的生态。\r\n\r\n*QFrameowrk.Toolkits 内置编辑器*\r\n\r\n![image.png](https://file.liangxiegame.com/d15a75ba-8d6d-4d77-b096-a93c559d29b9.png)\r\n\r\n*资源*\r\n\r\n| **版本**                          |                                                                                                   |                                                                                                                                                                                                                            |\r\n| ------------------------------- | ------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| QFramework.cs                   | QFramework 本体架构的实现                                                                                |                                                                                                                                                                                                                            |\r\n| QFramework.cs  示例               | QFramework.cs 与官方示例： CounterApp、《点点点》、FlappyBird、CubeMaster、ShootingEditor2D、贪吃蛇等                 | [github](https://github.com/liangxiegame/QFramework/blob/master/QFramework.cs.Examples.unitypackage)\\|[gitee](https://gitee.com/liangxiegame/QFramework/blob/master/QFramework.cs.Examples.unitypackage)                   |\r\n| QFramework.Toolkits             | QFramework  集成 CoreKit/UIKit/ActionKit/ResKit/PackageKit/AudioKit 等全部官方工具（已包含 QFramework.cs 和 示例) | [github](https://github.com/liangxiegame/QFramework/blob/master/QFramework.Toolkits.unitypackage)\\|[gitee](https://gitee.com/liangxiegame/QFramework/blob/master/QFramework.Toolkits.unitypackage)                         |\r\n| QFramework.Toolkits.Demo.WuZiQi | 使用 QFramework.Toolkits 开发的五子棋 Demo（需要安装好  QFramework.Toolkits）                                    | [github](https://github.com/liangxiegame/QFramework/blob/master/QFramework.Toolkits.Demo.WuZiQi.unitypackage)\\|[gitee](https://gitee.com/liangxiegame/QFramework/blob/master/QFramework.Toolkits.Demo.WuZiQi.unitypackage) |\r\n| QFramework.Toolkits.Demo.Saolei | 使用 QFramework.Toolkits 开发的扫雷 Demo（需要安装好  QFramework.Toolkits）                                     | [github](https://github.com/liangxiegame/QFramework/blob/master/QFramework.Toolkits.Demo.SaoLei.unitypackage)\\|[gitee](https://gitee.com/liangxiegame/QFramework/blob/master/QFramework.Toolkits.Demo.SaoLei.unitypackage) |\r\n| QFramework.ToolKitsPro          | 在 ToolKits 基础上集成更多好用的工具的版本（已包含 QFramework.Toolkits）                                               | [AssetStore](http://u3d.as/SJ9)                                                                                                                                                                                            |\r\n| **群友案例**                        |                                                                                                   |                                                                                                                                                                                                                            |\r\n| 赛车游戏《Crazy Car》                 | 群友 [TastSong](https://github.com/TastSong) 使用 QF 进行重构的开源赛车游戏                                      | [游戏主页(Github](https://github.com/TastSong/CrazyCar))                                                                                                                                                                       |\r\n| **社区**                          |                                                                                                   |                                                                                                                                                                                                                            |\r\n| QQ 群:623597263                  | 交流群                                                                                               | [点击加群](http://shang.qq.com/wpa/qunwpa?idkey=706b8eef0fff3fe4be9ce27c8702ad7d8cc1bceabe3b7c0430ec9559b3a9ce66)                                                                                                              |\r\n| github issue                    | github 社区                                                                                         | [地址](https://github.com/liangxiegame/QFramework/issues/new)                                                                                                                                                                |\r\n| gitee issue                     | gitee 社区（国内访问快）                                                                                   | [地址](https://gitee.com/liangxiegame/QFramework/issues)                                                                                                                                                                     |\r\n| **教程**                          |                                                                                                   |                                                                                                                                                                                                                            |\r\n| 《框架搭建 决定版》                      | 教程 QFramework  的核心架构是怎么演化过来的？                                                                     | [课程主页](https://learn.u3d.cn/tutorial/framework_design)\\|[学生课堂笔记1](https://github.com/Haogehaojiu/FrameworkDesign)\\|[学生课堂笔记2](https://github.com/Haogehaojiu/ShootingEditor2D)                                              |\r\n| **产品案例**                        |                                                                                                   |                                                                                                                                                                                                                            |\r\n| 独立游戏《鬼山之下》                      | 使用 QF 制作的独立游戏                                                                                     | [游戏主页(Steam)](https://store.steampowered.com/app/1517160/_/)                                                                                                                                                               |\r\n| 手机游戏《谐音梗挑战》                     | 使用 QF 制作的手机游戏                                                                                     | [游戏主页(TapTap)](https://www.taptap.com/app/201075)                                                                                                                                                                          |\r\n| 独立游戏《推灭泡泡姆》                     | ‍QF 群友，大学生团队制作的独立游戏，终于等到上架啦，亲自游玩过，很好玩，大家多多支~（P.S 使用 QF.cs 作为架构开发的哦~）                              | [游戏主页(TapTap)](https://www.taptap.com/app/233228)                                                                                                                                                                          |\r\n| **官方工具**（独立版本，不互相依赖)            |                                                                                                   |                                                                                                                                                                                                                            |\r\n| SingletonKit                    | 易上手功能强大的单例工具，由 QF 官方维护                                                                            | [github](https://github.com/liangxiegame/SingletonKit)\\|[gitee](https://gitee.com/liangxiegame/SingletonKit)                                                                                                               |\r\n| ExtensionKit                    | 易上手功能强大的 C#/UnityAPI 的静态扩展 ，由 QF 官方维护                                                             | [github](https://github.com/liangxiegame/ExtensionKit)\\|[gitee](https://gitee.com/liangxiegame/ExtensionKit)                                                                                                               |\r\n| IOCKit                          | 易上手功能强大的 IOC 容器 ，由 QF 官方维护                                                                        | [github](https://github.com/liangxiegame/IOCKit)\\|[gitee](https://gitee.com/liangxiegame/IOCKit)                                                                                                                           |\r\n| TableKit                        | 一套类似表格的数据结构（List\\<List\\<T>>)，兼顾查询效率和联合强大的查询功能，由 QF 官方维护                                           | [github](https://github.com/liangxiegame/TableKit)\\|[gitee](https://gitee.com/liangxiegame/TableKit)                                                                                                                       |\r\n| PoolKit                         | 对象池工具，由 QF 官方维护                                                                                   | [github](https://github.com/liangxiegame/PoolKit)\\|[gitee](https://gitee.com/liangxiegame/PoolKit)                                                                                                                         |\r\n| LogKit                          | 日志工具，由 QF 官方维护                                                                                    | [github](https://github.com/liangxiegame/LogKit)\\|[gitee](https://gitee.com/liangxiegame/LogKit)                                                                                                                           |\r\n| ActionKit                       | 动作序列工具，由 QF 官方维护                                                                                  | [github](https://github.com/liangxiegame/ActionKit)\\|[gitee](https://gitee.com/liangxiegame/ActionKit)                                                                                                                     |\r\n| ResKit                          | 资源管理工具，由 QF 官方维护                                                                                  | [github](https://github.com/liangxiegame/ResKit)\\|[gitee](https://gitee.com/liangxiegame/ResKit)                                                                                                                           |\r\n| UIKit                           | UIKit 是一套 UI/View 开发解决方案，由 QF 官方维护                                                                | [github](https://github.com/liangxiegame/UIKit)\\|[gitee](https://gitee.com/liangxiegame/UIKit)                                                                                                                             |\r\n| AudioKit                        | 一套音频管理工具，由 QF 官方维护                                                                                | [github](https://github.com/liangxiegame/AudioKit)\\|[gitee](https://gitee.com/liangxiegame/AudioKit)                                                                                                                       |\r\n| PackageKit                      | 一套包管理工具，可以通过 PackageKit 安装旧版本的 QFramework，以及大量的解决方案。                                              | [github](https://github.com/liangxiegame/PackageKit)\\|[gitee](https://gitee.com/liangxiegame/PackageKit)                                                                                                                   |\r\n| **其他相关教程**                      |                                                                                                   |                                                                                                                                                                                                                            |\r\n| 《独立游戏体验计划》（猫叔）                  | 独立游戏制作体验教程，有用到 QFramework.cs                                                                      | [b 站](https://space.bilibili.com/656352)                                                                                                                                                                                   |\r\n| 《原创独立游戏制作》（凉鞋）                  | 原创独立游戏制作教程，有用到 QFramework.cs                                                                      | [b 站](https://space.bilibili.com/60450548/channel/collectiondetail?sid=125221)                                                                                                                                             |\r\n\r\n**典型的 QFramework.cs 架构代码**\r\n\r\n```csharp\r\nnamespace QFramework.Exmaple\r\n{\r\n    public class CounterAppController : MonoBehaviour , IController\r\n    {\r\n        // View\r\n        private Button mBtnAdd;\r\n        private Button mBtnSub;\r\n        private Text mCountText;\r\n        \r\n        // Model\r\n        private ICounterAppModel mModel;\r\n\r\n        void Start()\r\n        {\r\n            // 获取模型\r\n            mModel = this.GetModel<ICounterAppModel>();\r\n            \r\n            // View 组件获取\r\n            mBtnAdd = transform.Find(\"BtnAdd\").GetComponent<Button>();\r\n            mBtnSub = transform.Find(\"BtnSub\").GetComponent<Button>();\r\n            mCountText = transform.Find(\"CountText\").GetComponent<Text>();\r\n            \r\n            \r\n            // 监听输入\r\n            mBtnAdd.onClick.AddListener(() =>\r\n            {\r\n                // 交互逻辑\r\n                this.SendCommand<IncreaseCountCommand>();\r\n            });\r\n            \r\n            mBtnSub.onClick.AddListener(() =>\r\n            {\r\n                // 交互逻辑\r\n                this.SendCommand(new DecreaseCountCommand(/* 这里可以传参（如果有） */));\r\n            });\r\n\r\n            // 表现逻辑\r\n            mModel.Count.RegisterWithInitValue(newCount => // -+\r\n            {\r\n                UpdateView();\r\n\r\n            }).UnRegisterWhenGameObjectDestroyed(gameObject);\r\n        }\r\n        \r\n        void UpdateView()\r\n        {\r\n            mCountText.text = mModel.Count.ToString();\r\n        }\r\n\r\n        public IArchitecture GetArchitecture()\r\n        {\r\n            return CounterApp.Interface;\r\n        }\r\n\r\n        private void OnDestroy()\r\n        {\r\n          \r\n            mModel = null;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n**典型的 QFramework.Toolkits 代码**\r\n\r\n```csharp\r\nusing QFramework;\r\nusing UnityEngine;\r\nusing UnityEngine.UI;\r\n\r\nnamespace liangxiegame\r\n{\r\n    public partial class UIGamePanel : UIPanel\r\n    {\r\n        private ResLoader mResLoader;\r\n        \r\n        protected override void OnInit(IUIData uiData = null)\r\n        {\r\n            mResLoader = ResLoader.Allocate();\r\n            \r\n            mResLoader.LoadSync<GameObject>(\"GameplayRoot\")\r\n                .Instantiate()\r\n                .Identity()\r\n                .GetComponent<GameplayRoot>()\r\n                .InitGameplayRoot();\r\n            \r\n            \r\n            BtnPause.onClick.AddListener(() =>\r\n            {\r\n                AudioKit.PlaySound(\"btn_click\");\r\n                \r\n                ActionKit.Sequence()\r\n                    .Callback(() => BtnPause.interactable = false)\r\n                    .Callback(() => BtnPause.PlayBtnFadeAnimation())\r\n                    .Delay(0.3f)\r\n                    .Callback(() => UIKit.OpenPanel<UIPausePanel>())\r\n                    .Start(this);\r\n            });\r\n        }\r\n\r\n        protected override void OnClose()\r\n        {\r\n            mResLoader.Recycle2Cache();\r\n            mResLoader = null;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 大量的示例\r\n\r\n### 小游戏《点点点》\r\n\r\n![b5966b31-f004-4b5f-a38d-25753fb2eb8f.gif](https://file.liangxiegame.com/5a10aa95-4c93-4dae-acec-667a113c30ca.gif)\r\n\r\n### 小游戏《FlappyBird》\r\n\r\n![430b7f31-508d-4569-aa51-b75d5553b8c4.gif](https://file.liangxiegame.com/9845122b-93d9-4106-a027-2d7c129a096a.gif)\r\n\r\n作者：王二 soso <https://github.com/so-sos-so>\r\n\r\n### 小游戏《Cube Master》\r\n\r\n![b1334ef2-f6d4-4a9c-a5c4-b6cd6508595c.gif](https://file.liangxiegame.com/f51abab0-9dc9-478b-b1f1-67f2cd588477.gif) 作者：王二 soso <https://github.com/so-sos-so>\r\n\r\n### 简易关卡编辑器2D\r\n\r\n![c57c20cf-5ee6-4346-8be8-8ad1ea2d63b9.gif](https://file.liangxiegame.com/6492498b-6c22-478d-8785-9f43453c34db.gif)\r\n\r\n![ea2cb545-4b5b-4d02-b494-dde4afa4e190.gif](https://file.liangxiegame.com/34b775c6-6a49-4141-9b9a-1377a6c15673.gif)\r\n\r\n### 小游戏《贪吃蛇》\r\n\r\n![fb907355-c06c-4bde-8ca3-5638ba9b3ef7.gif](https://file.liangxiegame.com/ac70d14e-ea89-445d-899e-06f18f11f8d1.gif)\r\n\r\n作者：一只皮皮虾 <https://gitee.com/PantyNeko/>\r\n\r\n以上的示例都是由 QFramework.cs 制作而成的官方示例。\r\n\r\n另外还有群友制作的开源游戏\r\n\r\n### CrazyCar\r\n\r\nUnity制作的联机赛车游戏，后台为SpringBoot + Mybatis；游戏采用QFramework框架，支持KCP和WebSocket网络(商用级)\r\n\r\n![Login.jpg](https://file.liangxiegame.com/0ab6cb1d-2374-4aa2-b27d-f04eb72792cd.png)\r\n\r\n![Setting.png](https://file.liangxiegame.com/a113dcba-9ba8-4a40-b000-be3b61719ecc.png)\r\n\r\n![Homepage.png](https://file.liangxiegame.com/9075c10d-6d21-411c-b1a4-7f92a08f9bfa.png)\r\n\r\n![Avatar.png](https://file.liangxiegame.com/32b48b5b-cdcc-433e-b1b2-4b1333211a70.png) ![Profile.png](https://file.liangxiegame.com/bda476e4-0ede-4fd9-a5bb-e993bce8a786.png)\r\n\r\n![Equip.png](https://file.liangxiegame.com/158b0ce0-6e67-47c5-81b5-cee6388dd99c.png)\r\n\r\n![Rank.png](https://file.liangxiegame.com/2bd0ef1f-d639-48e8-8c48-320995d20de4.png)\r\n\r\n![TimeTrial.png](https://file.liangxiegame.com/aa337718-b868-41d2-bc6b-2ef51c157481.png) ![Match.png](https://file.liangxiegame.com/06157781-3271-438c-bf3f-613e6ec00fb0.png)\r\n\r\n作者: TastSone  <https://github.com/TastSong>\r\n\r\n项目地址: <https://github.com/TastSong/CrazyCar>\r\n\r\n## 案例《五子棋》\r\n\r\n![2f4dacbd-e59b-43af-b7be-44220fac664e.png](https://file.liangxiegame.com/a76bc24a-1828-46f2-94c5-8bd24884f932.png)\r\n\r\n源码地址:\r\n\r\n*   github <https://github.com/liangxiegame/QFramework>\r\n*   gitee <https://gitee.com/liangxiegame/QFramework>\r\n\r\n![image.png](https://file.liangxiegame.com/3abceb70-2d17-4457-aff1-ef8a6ef4bd66.png)\r\n\r\n## 案例《扫雷》\r\n\r\n作者：Joker\r\n\r\n![扫雷](https://file.liangxiegame.com/4c42d227-11b9-4485-8884-a2f04a62460c.png)\r\n\r\n源码地址:\r\n\r\n*   github <https://github.com/liangxiegame/QFramework>\r\n*   gitee <https://gitee.com/liangxiegame/QFramework>\r\n\r\n![image.png](https://file.liangxiegame.com/6482d4eb-5af9-4932-a2f8-2164cb22e931.png)\r\n\r\n## 本教程简介\r\n\r\n在上一版官方教程《QFramework 使用指南 2020》写完之后，经过两年（2022 年），QFramework 改进了很多工具的使用体验，同时又新增了一套非常简单且强大的开发架构，这样就迎来了 QFramework 第一个正式版本 QFramework v1，这样就导致导致 QFramework 的推荐使用的 API 发生了一些变化，虽然旧版本的 API 还能用，但是按照《QFramework 使用指南 2020》写的很多代码会报很多警告，这会让很多初学者感到疑惑，所以笔者打算在《QFramework 使用指南 2020》的基础上，重制一套新的 QFramework 使用教程，名字叫做《QFramework v1.0 使用指南》。\r\n\r\n教程分为架构篇和工具集篇，架构篇着重介绍 QFramework.cs 这套架构入门以及使用规范，工具篇着重介绍 QFramework 中的大量的工具集的使用。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>ix 独立游戏学院 & Unity 进阶小班地址：[https://www.gamepixedu.com/](https://www.gamepixedu.com/)\r\n# 02.Roadmap-路线图\r\n\r\n**将来也许**\r\n* sLua、toLua、xLua、ILRuntime 支持\r\n* Pro 版本推进\r\n  * Architecture Designer 使用可视化设计架构，一键生成架构代码\r\n* ResKit 支持自定义目录方案\r\n* UIKit 支持多个 Canvas Root 和 摄像机方案\r\n* CodeGenKit 同步\r\n* 插件平台的插件整理\r\n* ResKit 重构（支持热更）\r\n* UIKit 重构\r\n* AudioKit 重构\r\n\r\n**v1.0.x**（当前）\r\n* QFramework.Toolkits 收录四个示例\r\n* 编辑器使用体验改进\r\n* QFramework Pro v0.5 Architecture Designer 发布\r\n\r\n**v0.16.x**（已完成）\r\n*《QFramework v1.0 使用指南》 完成\r\n* 编辑器文档 支持 gif 动画 和 简单的 C# 代码高亮\r\n* 示例完善\r\n\r\n**v0.15.x**（已完成）\r\n* 文档整理 & 在编辑器内部内置\r\n\r\n**v0.14.x（已完成）**\r\n* Asset Store 兼容 & 减少第三方依赖\r\n\r\n**v0.11.x（已完成）**\r\n* 打 dll 优化旧设备的编译速度\r\n\r\n**v0.10.x（已完成）**\r\n* ILRuntime 支持（只完成一部分，后续再支持）\r\n\r\n**v0.9.x（已完成）**\r\n* 单元测试覆盖\r\n* PackageKit、Framework、Extensions 的示例全部覆盖\r\n* 3 ~ 5 个 Demo 发布\r\n\r\n**v0.2.x ~ v0.8.x（已完成）**\r\n* PackageManager 独立成 PackageKit\r\n* 剥离掉第三方插件，最为扩展插件支持\r\n* 插件平台发布：https://liangxiegame.com/qf/package\r\n* 命名空间从 QF 改回 QFramework\r\n* 大量 Bug 修复、大量示例编写\r\n* 五子棋 Demo 发布：Demo：五子棋\r\n* QFramework 使用指南 2020 完结：QFramework 使用指南 2020\r\n\r\n**v0.1.x（已完成)**\r\n* UniRx、Zenject、uFrame、JsonDotnet、CatLib 集成和增强\r\n* IOC 增加 IOC 部分\r\n* 框架自动更新机制 => PackageManager\r\n* 命名空间从 QFramework 改成 QF\r\n\r\n**v0.0.x（已完成**\r\n* 框架搭建 2017 的工具集收录\r\n* 框架搭建 2018 的 ResKit 和 UI Kit 模块实现\r\n* ActionKit 模块实现\r\n* Manager Of Managers 支持\r\n* 框架自动更新机制\r\n\r\n* Pro 版本（开源收费版本）\r\n  * CoreKitPro（未开始）\r\n  * LuaKit-轻量级 Lua 脚本方案，由 MoonSharp 魔改而来(未开始)\r\n  * CodeGenKitPro 代码生成库\r\n  * ActionKitPro(未开始)\r\n  * ResKitPro(未开始)\r\n  * UIKitPro\r\n  * LuaKitPro（基于 xLua)(未开始)\r\n  * ILRuntimeKitPro（基于 ILRuntime 的热更框架）(未开始)\r\n  * DocKit-可视化编程写文档，一键生成类图功能（进行中）\r\n  * DialogueKit-对话编辑器（未开始）\r\n  * InventoryKit-背包系统（未开始）\r\n  * ArchitectureKit-架构设计器（未开始）\r\n  * QuestKit-任务编辑器（未开始）\r\n  * 存档-未开始）\r\n\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n# 2. 架构篇：QFramework.cs\r\n# 01. QFramework 架构简介\r\n\r\nQFramework 架构是一套简单、强大、易上手的系统设计架构。\r\n\r\n这套架构的特性如下：\r\n* 基于 MVC\r\n* 分层\r\n* (可选)CQRS 支持\r\n* (可选)事件驱动\r\n* (可选)数据驱动\r\n* (可选)IOC 模块化\r\n* (可选)领域驱动设计（DDD）支持\r\n* 符合 SOLID 原则\r\n* 源码不到 1000 行\r\n\r\n## 提供的架构图\r\n![image.png](https://file.liangxiegame.com/5e9f1682-1907-47a2-a23a-2d5a4ba2e7a4.png)\r\n## 举个例子（一图胜千言😂）\r\n![](https://file.liangxiegame.com/6bf42306-0b2a-4417-bbcf-354af0132596.png)\r\n\r\n这两张图现在大家可能还看不太懂，没关系，我们过一遍快速入门就懂了。\r\n\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n# 02. QFramework 的 MVC\r\nQFramework 基于 MVC 的开发模式\r\n\r\n所以我们先从最熟知的 MVC 架构开始着手 QFramework 的学习。\r\n\r\n我们先做一个非常简单的计数器应用。\r\n\r\n\r\n首先我们使用 UGUI 创建一个最简单的界面，如下图所示：\r\n\r\n![image.png](https://file.liangxiegame.com/902ef543-64b1-45ad-ae45-ea180ebec133.png)\r\n\r\n场景结构如下所示：\r\n\r\n![image.png](https://file.liangxiegame.com/1db2c50c-cb8b-4b1c-92f6-432ff4083105.png)\r\n\r\n复制完之后，我们创建一个脚本叫做 CounterAppController，代码如下：\r\n\r\n```csharp\r\nusing UnityEngine;\r\nusing UnityEngine.UI;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    // Controller\r\n    public class CounterAppController : MonoBehaviour\r\n    {\r\n        // View\r\n        private Button mBtnAdd;\r\n        private Button mBtnSub;\r\n        private Text mCountText;\r\n        \r\n        // Model\r\n        private int mCount = 0;\r\n\r\n        void Start()\r\n        {\r\n            // View 组件获取\r\n            mBtnAdd = transform.Find(\"BtnAdd\").GetComponent<Button>();\r\n            mBtnSub = transform.Find(\"BtnSub\").GetComponent<Button>();\r\n            mCountText = transform.Find(\"CountText\").GetComponent<Text>();\r\n            \r\n            \r\n            // 监听输入\r\n            mBtnAdd.onClick.AddListener(() =>\r\n            {\r\n                // 交互逻辑\r\n                mCount++;\r\n                // 表现逻辑\r\n                UpdateView();        \r\n            });\r\n            \r\n            mBtnSub.onClick.AddListener(() =>\r\n            {\r\n                // 交互逻辑\r\n                mCount--;\r\n                // 表现逻辑\r\n                UpdateView();\r\n            });\r\n            \r\n            UpdateView();\r\n        }\r\n        \r\n        void UpdateView()\r\n        {\r\n            mCountText.text = mCount.ToString();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n代码很简单，这是一个非常简易的 MVC 的实现。\r\n\r\n我们将此脚本挂在 Canvas 节点上，运行 Unity 结果如下：\r\n\r\n\r\n![282fcc3c-96fa-46e1-b4c6-7f4528b04271.gif](https://file.liangxiegame.com/1b934e4f-8f72-44c2-800a-a97f1e707950.gif)\r\n\r\n非常简单。\r\n\r\n此时我们还没有导入我们的 QFramework，不着急，我们先看看代码中所介绍的概念。\r\n\r\n首先是 Model、View、Controller\r\n\r\nModel 的代码如下:\r\n```csharp\r\n// Model\r\nprivate int mCount = 0;\r\n```\r\n\r\n非常简单，只有一个成员变量，但是在这里它其实并不算是一个 Model，他只是要在 View 中显示的一个数据而已，具体为什么不是 Model 我们在后边再说。\r\n\r\nView 的代码如下:\r\n```csharp\r\n// View\r\nprivate Button mBtnAdd;\r\nprivate Button mBtnSub;\r\nprivate Text mCountText;\r\n```\r\n\r\nView 的代码也很简单，View 在 QFramework 的 MVC 定义里就是提供关键组件的引用，比如这三个组件是要在 Controller 代码里要用到的。而其他的例如 Canvas Scaler 等这些组件目前 Controller 不需要，所以就不用声明。\r\n\r\nController 的代码，如下：\r\n\r\n```csharp\r\nvoid Start()\r\n{\r\n    ...\r\n      \r\n    // 监听输入\r\n    mBtnAdd.onClick.AddListener(() =>\r\n    {\r\n        // 交互逻辑\r\n        mCount++;\r\n        // 表现逻辑\r\n        UpdateView();        \r\n    });\r\n            \r\n    mBtnSub.onClick.AddListener(() =>\r\n    {\r\n        // 交互逻辑\r\n        mCount--;\r\n        // 表现逻辑\r\n        UpdateView();\r\n    });\r\n            \r\n    UpdateView();\r\n}\r\n        \r\nvoid UpdateView()\r\n{\r\n    mCountText.text = mCount.ToString();\r\n}\r\n```\r\n\r\n以上就是 Controller 的代码。\r\n\r\n好了，我们回头再看下完整代码。\r\n\r\n\r\n```csharp\r\nusing UnityEngine;\r\nusing UnityEngine.UI;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    // Controller\r\n    public class CounterAppController : MonoBehaviour\r\n    {\r\n        // View\r\n        private Button mBtnAdd;\r\n        private Button mBtnSub;\r\n        private Text mCountText;\r\n        \r\n        // Model\r\n        private int mCount = 0;\r\n\r\n        void Start()\r\n        {\r\n            // View 组件获取\r\n            mBtnAdd = transform.Find(\"BtnAdd\").GetComponent<Button>();\r\n            mBtnSub = transform.Find(\"BtnSub\").GetComponent<Button>();\r\n            mCountText = transform.Find(\"CountText\").GetComponent<Text>();\r\n            \r\n            \r\n            // 监听输入\r\n            mBtnAdd.onClick.AddListener(() =>\r\n            {\r\n                // 交互逻辑\r\n                mCount++;\r\n                // 表现逻辑\r\n                UpdateView();        \r\n            });\r\n            \r\n            mBtnSub.onClick.AddListener(() =>\r\n            {\r\n                // 交互逻辑\r\n                mCount--;\r\n                // 表现逻辑\r\n                UpdateView();\r\n            });\r\n            \r\n            UpdateView();\r\n        }\r\n        \r\n        void UpdateView()\r\n        {\r\n            mCountText.text = mCount.ToString();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n目前像计数器这样的逻辑，以上的代码完全没有问题。\r\n\r\n但是我们要用发展的眼光看待问题。\r\n\r\n假如这是一个初创项目，那么接下来很有可能需要添加大量的业务逻辑。\r\n\r\n其中很有可能让 mCount 在多个 Controller 中使用，甚至需要针对 mCount 这个数据写一些其他逻辑，比如增加 mCount 则增加 5 个分数，或者 mCount 需要存储等，总之 mCount 在未来可能会发展成一个需要共享的数据，而 mCount 目前只属于 CounterAppController，显然在未来这是不够用的。\r\n\r\n我们就需要让 mCount 成员变量变成一个共享的数据，最快的做法是吧 mCount 变量变成静态变量或者单例，但是这样虽然写起来很快，但是在后期维护额度时候会产生很多的问题。\r\n\r\n而 QFramework 架构提供了 Model 的概念。\r\n\r\n我们来使用一下。\r\n\r\n我们先导入 QFramework 架构。\r\n\r\n导入 QFramework 的方式非常简单，只需要复制 QFramework.cs 的代码到 Unity 工程中即可。\r\n\r\nQFramework.cs 地址：\r\n* Gitee: https://gitee.com/liangxiegame/QFramework/blob/master/QFramework.cs\r\n* Github: https://github.com/liangxiegame/QFramework/blob/master/QFramework.cs\r\n\r\n导入之后，我们将 CounterAppController 的代码改成如下：\r\n\r\n```csharp\r\nusing UnityEngine;\r\nusing UnityEngine.UI;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    \r\n    // 1. 定义一个 Model 对象\r\n    public class CounterAppModel : AbstractModel\r\n    {\r\n        public int Count;\r\n        \r\n        protected override void OnInit()\r\n        {\r\n            Count = 0;\r\n        }\r\n    }\r\n\r\n\r\n    // 2.定义一个架构（提供 MVC、分层、模块管理等）\r\n    public class CounterApp : Architecture<CounterApp>\r\n    {\r\n        protected override void Init()\r\n        {\r\n            // 注册 Model\r\n            this.RegisterModel(new CounterAppModel());\r\n        }\r\n    }\r\n\r\n    // Controller\r\n    public class CounterAppController : MonoBehaviour , IController /* 3.实现 IController 接口 */\r\n    {\r\n        // View\r\n        private Button mBtnAdd;\r\n        private Button mBtnSub;\r\n        private Text mCountText;\r\n        \r\n        // 4. Model\r\n        private CounterAppModel mModel;\r\n\r\n        void Start()\r\n        {\r\n            // 5. 获取模型\r\n            mModel = this.GetModel<CounterAppModel>();\r\n            \r\n            // View 组件获取\r\n            mBtnAdd = transform.Find(\"BtnAdd\").GetComponent<Button>();\r\n            mBtnSub = transform.Find(\"BtnSub\").GetComponent<Button>();\r\n            mCountText = transform.Find(\"CountText\").GetComponent<Text>();\r\n            \r\n            \r\n            // 监听输入\r\n            mBtnAdd.onClick.AddListener(() =>\r\n            {\r\n                // 6. 交互逻辑\r\n                mModel.Count++;\r\n                // 表现逻辑\r\n                UpdateView();        \r\n            });\r\n            \r\n            mBtnSub.onClick.AddListener(() =>\r\n            {\r\n                // 7. 交互逻辑\r\n                mModel.Count--;\r\n                // 表现逻辑\r\n                UpdateView();\r\n            });\r\n            \r\n            UpdateView();\r\n        }\r\n        \r\n        void UpdateView()\r\n        {\r\n            mCountText.text = mModel.Count.ToString();\r\n        }\r\n\r\n        // 3.指定架构\r\n        public IArchitecture GetArchitecture()\r\n        {\r\n            return CounterApp.Interface;\r\n        }\r\n\r\n        private void OnDestroy()\r\n        {\r\n            // 8. 将 Model 设置为空\r\n            mModel = null;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n好了，代码引入了两个新的概念，一个是 Architecture，另一个是 Model。\r\n\r\nArchitecture 用于管理模块，或者说 Architecture 提供一整套架构的解决方案，而模块管理和提供 MVC 只是其功能的一小部分。\r\n\r\n我们运行一下 Unity 结果如下：\r\n\r\n![282fcc3c-96fa-46e1-b4c6-7f4528b04271.gif](https://file.liangxiegame.com/aa28ef15-11e9-49f2-9536-9db18b025a8f.gif)\r\n\r\n运行正确。\r\n\r\n好了，我们上手了 QFramework 提供的 MVC 架构。\r\n\r\n这里要注意一点，Model 的引入是为了解决数据共享的问题，而不是说单只是为了让数据和表现分离，这一点是非常重要的一点。\r\n\r\n数据共享分两种：空间上的共享和时间上的共享。\r\n\r\n空间的共享很简单，就是多个点的代码需要访问 Model 里的数据。\r\n\r\n时间上的共享就是存储功能，将上一次关闭 App 之前的数据存储到一个文件里，这次打开时获得上次关闭 App 之前的数据。\r\n\r\n虽然我们上手了 MVC，但是这样的 MVC 还有很多问题，我们下一篇继续解决。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n\r\n\r\n\r\n\r\n# 03. 引入 Command\r\n\r\n我们回顾一下目前的代码，如下；\r\n```csharp\r\nusing UnityEngine;\r\nusing UnityEngine.UI;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    \r\n    // 1. 定义一个 Model 对象\r\n    public class CounterAppModel : AbstractModel\r\n    {\r\n        public int Count;\r\n        \r\n        protected override void OnInit()\r\n        {\r\n            Count = 0;\r\n        }\r\n    }\r\n\r\n\r\n    // 2.定义一个架构（提供 MVC、分层、模块管理等）\r\n    public class CounterApp : Architecture<CounterApp>\r\n    {\r\n        protected override void Init()\r\n        {\r\n            // 注册 Model\r\n            this.RegisterModel(new CounterAppModel());\r\n        }\r\n    }\r\n\r\n    // Controller\r\n    public class CounterAppController : MonoBehaviour , IController /* 3.实现 IController 接口 */\r\n    {\r\n        // View\r\n        private Button mBtnAdd;\r\n        private Button mBtnSub;\r\n        private Text mCountText;\r\n        \r\n        // 4. Model\r\n        private CounterAppModel mModel;\r\n\r\n        void Start()\r\n        {\r\n            // 5. 获取模型\r\n            mModel = this.GetModel<CounterAppModel>();\r\n            \r\n            // View 组件获取\r\n            mBtnAdd = transform.Find(\"BtnAdd\").GetComponent<Button>();\r\n            mBtnSub = transform.Find(\"BtnSub\").GetComponent<Button>();\r\n            mCountText = transform.Find(\"CountText\").GetComponent<Text>();\r\n            \r\n            \r\n            // 监听输入\r\n            mBtnAdd.onClick.AddListener(() =>\r\n            {\r\n                // 6. 交互逻辑\r\n                mModel.Count++;\r\n                // 表现逻辑\r\n                UpdateView();        \r\n            });\r\n            \r\n            mBtnSub.onClick.AddListener(() =>\r\n            {\r\n                // 7. 交互逻辑\r\n                mModel.Count--;\r\n                // 表现逻辑\r\n                UpdateView();\r\n            });\r\n            \r\n            UpdateView();\r\n        }\r\n        \r\n        void UpdateView()\r\n        {\r\n            mCountText.text = mModel.Count.ToString();\r\n        }\r\n\r\n        // 3.\r\n        public IArchitecture GetArchitecture()\r\n        {\r\n            return CounterApp.Interface;\r\n        }\r\n\r\n        private void OnDestroy()\r\n        {\r\n            // 8. 将 Model 设置为空\r\n            mModel = null;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n现在，数据共享的问题通过 引入 Model 解决了。\r\n\r\n这里再次强调一下，需要共享的数据放 Model 里，不需要共享的，能不放就不放。\r\n\r\n虽然引入了 Model，但是这套代码随着项目规模的发展还是有很多的问题。\r\n\r\n其中最严重也最常见的就是 Controller 会越来越臃肿。\r\n\r\n我们简单分析一下为什么 Controller 会越来越臃肿，我们先看下监听用户输入部分的代码，如下：\r\n\r\n```csharp\r\n// 监听输入\r\nmBtnAdd.onClick.AddListener(() =>\r\n{\r\n    // 交互逻辑\r\n    mModel.Count++;\r\n    // 表现逻辑\r\n    UpdateView();        \r\n});\r\n            \r\nmBtnSub.onClick.AddListener(() =>\r\n{\r\n    // 交互逻辑\r\n    mModel.Count--;\r\n    // 表现逻辑\r\n    UpdateView();\r\n});\r\n```\r\n\r\n在处理用户输入的代码中，笔者写了注释，交互逻辑 和 表现逻辑。\r\n\r\n什么是交互逻辑 和 表现逻辑？\r\n\r\n非常简单。\r\n\r\n交互逻辑，就是从用户输入开始到数据变更的逻辑\r\n\r\n顺序是 View->Controller->Model\r\n\r\n表现逻辑，就是数据变更到在界面显示的逻辑\r\n\r\n顺序是 Model->Controller->View\r\n\r\n如下图所示：\r\n\r\n![image.png](https://file.liangxiegame.com/0b4e1255-ee5d-4223-97a6-2e49cf68715c.png)\r\n\r\n虽然交互逻辑和表现逻辑理解起来简单，但是它们非常重要，因为 QFramework 接下来的概念都是围绕这两个概念展开的。\r\n\r\nView、Model 以及 Controller 的交互逻辑和表现逻辑形成了一个闭环。构成了完整的 MVC 闭环。\r\n\r\n\r\n而 Controller 本身之所以臃肿，是因为，它负责了两种职责，即改变 Model 数据 的交互逻辑，以及 Model 数据变更之后更新到界面的表现逻辑。\r\n\r\n而在一个有一定规模的项目中，表现逻辑和交互逻辑非常多。而一个 Controller 很容易就做到上千行代码。\r\n\r\n而大部分的 MVC 方案，解决 Controller 臃肿用的是引入 Command 的方式，即引入命令模式，通过命令来分担 Controller 的交互逻辑的职责。\r\n\r\nQFramework 也是使用了同样的方式解决 Controller 臃肿的问题。\r\n\r\n\r\n我们将代码改成如下：\r\n\r\n```csharp\r\nusing UnityEngine;\r\nusing UnityEngine.UI;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    \r\n    // 1. 定义一个 Model 对象\r\n    public class CounterAppModel : AbstractModel\r\n    {\r\n        public int Count;\r\n        \r\n        protected override void OnInit()\r\n        {\r\n            Count = 0;\r\n        }\r\n    }\r\n\r\n\r\n    // 2.定义一个架构（提供 MVC、分层、模块管理等）\r\n    public class CounterApp : Architecture<CounterApp>\r\n    {\r\n        protected override void Init()\r\n        {\r\n            // 注册 Model\r\n            this.RegisterModel(new CounterAppModel());\r\n        }\r\n    }\r\n    \r\n    // 引入 Command\r\n    public class IncreaseCountCommand : AbstractCommand // ++\r\n    {\r\n        protected override void OnExecute()\r\n        {\r\n            this.GetModel<CounterAppModel>().Count++;\r\n        }\r\n    }\r\n    \r\n    public class DecreaseCountCommand : AbstractCommand // ++\r\n    {\r\n        protected override void OnExecute()\r\n        {\r\n            this.GetModel<CounterAppModel>().Count--;\r\n        }\r\n    }\r\n\r\n    // Controller\r\n    public class CounterAppController : MonoBehaviour , IController /* 3.实现 IController 接口 */\r\n    {\r\n        // View\r\n        private Button mBtnAdd;\r\n        private Button mBtnSub;\r\n        private Text mCountText;\r\n        \r\n        // 4. Model\r\n        private CounterAppModel mModel;\r\n\r\n        void Start()\r\n        {\r\n            // 5. 获取模型\r\n            mModel = this.GetModel<CounterAppModel>();\r\n            \r\n            // View 组件获取\r\n            mBtnAdd = transform.Find(\"BtnAdd\").GetComponent<Button>();\r\n            mBtnSub = transform.Find(\"BtnSub\").GetComponent<Button>();\r\n            mCountText = transform.Find(\"CountText\").GetComponent<Text>();\r\n            \r\n            \r\n            // 监听输入\r\n            mBtnAdd.onClick.AddListener(() =>\r\n            {\r\n                // 交互逻辑\r\n                this.SendCommand<IncreaseCountCommand>();\r\n                // 表现逻辑\r\n                UpdateView();        \r\n            });\r\n            \r\n            mBtnSub.onClick.AddListener(() =>\r\n            {\r\n                // 交互逻辑\r\n                this.SendCommand<DecreaseCountCommand>();\r\n                // 表现逻辑\r\n                UpdateView();\r\n            });\r\n            \r\n            UpdateView();\r\n        }\r\n        \r\n        void UpdateView()\r\n        {\r\n            mCountText.text = mModel.Count.ToString();\r\n        }\r\n\r\n        // 3.\r\n        public IArchitecture GetArchitecture()\r\n        {\r\n            return CounterApp.Interface;\r\n        }\r\n\r\n        private void OnDestroy()\r\n        {\r\n            // 8. 将 Model 设置为空\r\n            mModel = null;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n代码很简单，我们用流程图表示如下：\r\n\r\n![image.png](https://file.liangxiegame.com/6544f785-0389-46bc-813d-b9c77abdd336.png)\r\n\r\n运行 Unity，结果如下：\r\n\r\n![282fcc3c-96fa-46e1-b4c6-7f4528b04271.gif](https://file.liangxiegame.com/1b934e4f-8f72-44c2-800a-a97f1e707950.gif)\r\n\r\n\r\n没有变化，运行正确。\r\n\r\n大家可能会问，一个简单的数据加减操作，至于创建一个 Command 对象来承担么？看不出来好处呀，反而代码更多了。\r\n\r\n如果整个项目只有一个简单的数据加减操作，那使用 Command 有点多此一举，但是一般的项目的交互逻辑，是非常复杂的，代码量也非常多，整个时候使用 Command 词汇发挥作用。\r\n\r\n具体发挥什么作用，使用 Command 可以带来很多便利，比如：\r\n* Command 可以复用，Command 也可以调用 Command\r\n* Command 可以比较方便实现撤销功能，如果 App 或者 游戏需要的话\r\n* 如果遵循一定规范，可以实现使用 Command 跑自动化测试。\r\n* Command 可以定制 Command 队列，也可以让 Command 按照特定的方式执行\r\n* 一个 Command 也可以封装成一个 Http 或者 TCP 里的一次数据请求\r\n* Command 可以实现 Command 中间件模式\r\n* 等等\r\n\r\nOK，通过引入 Command，帮助分担了 Controller 的交互逻辑。使得 Controller 成为一个薄薄的一层，在需要修改 Model 的时候，Controller 只要调用一句简单的 Command 即可。\r\n\r\nCommand 最明显的好处就是：\r\n* 就算代码再乱，也只是在一个 Command 对象里乱，而不会影响其他的对象。\r\n* 讲方法封装成命令对象，可以实现对命令对象的组织、排序、延时等操作。\r\n\r\n更多好处会随着大家的实践慢慢体会到。\r\n\r\n当前的 MVC 流程如下：\r\n\r\n![](https://file.liangxiegame.com/5ddfe754-110f-4417-8e29-d890e36d4a7a.png)\r\n\r\n这篇内容就这些。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n\r\n\r\n# 04. 引入 Event\r\n\r\n我们看下当前的代码:\r\n\r\n```csharp\r\nusing UnityEngine;\r\nusing UnityEngine.UI;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    \r\n    // 1. 定义一个 Model 对象\r\n    public class CounterAppModel : AbstractModel\r\n    {\r\n        public int Count;\r\n        \r\n        protected override void OnInit()\r\n        {\r\n            Count = 0;\r\n        }\r\n    }\r\n\r\n\r\n    // 2.定义一个架构（提供 MVC、分层、模块管理等）\r\n    public class CounterApp : Architecture<CounterApp>\r\n    {\r\n        protected override void Init()\r\n        {\r\n            // 注册 Model\r\n            this.RegisterModel(new CounterAppModel());\r\n        }\r\n    }\r\n    \r\n    // 引入 Command\r\n    public class IncreaseCountCommand : AbstractCommand\r\n    {\r\n        protected override void OnExecute()\r\n        {\r\n            this.GetModel<CounterAppModel>().Count++;\r\n        }\r\n    }\r\n    \r\n    public class DecreaseCountCommand : AbstractCommand\r\n    {\r\n        protected override void OnExecute()\r\n        {\r\n            this.GetModel<CounterAppModel>().Count--;\r\n        }\r\n    }\r\n\r\n    // Controller\r\n    public class CounterAppController : MonoBehaviour , IController /* 3.实现 IController 接口 */\r\n    {\r\n        // View\r\n        private Button mBtnAdd;\r\n        private Button mBtnSub;\r\n        private Text mCountText;\r\n        \r\n        // 4. Model\r\n        private CounterAppModel mModel;\r\n\r\n        void Start()\r\n        {\r\n            // 5. 获取模型\r\n            mModel = this.GetModel<CounterAppModel>();\r\n            \r\n            // View 组件获取\r\n            mBtnAdd = transform.Find(\"BtnAdd\").GetComponent<Button>();\r\n            mBtnSub = transform.Find(\"BtnSub\").GetComponent<Button>();\r\n            mCountText = transform.Find(\"CountText\").GetComponent<Text>();\r\n            \r\n            \r\n            // 监听输入\r\n            mBtnAdd.onClick.AddListener(() =>\r\n            {\r\n                // 交互逻辑\r\n                this.SendCommand<IncreaseCountCommand>();\r\n                // 表现逻辑\r\n                UpdateView();        \r\n            });\r\n            \r\n            mBtnSub.onClick.AddListener(() =>\r\n            {\r\n                // 交互逻辑\r\n                this.SendCommand<DecreaseCountCommand>();\r\n                // 表现逻辑\r\n                UpdateView();\r\n            });\r\n            \r\n            UpdateView();\r\n        }\r\n        \r\n        void UpdateView()\r\n        {\r\n            mCountText.text = mModel.Count.ToString();\r\n        }\r\n\r\n        // 3.\r\n        public IArchitecture GetArchitecture()\r\n        {\r\n            return CounterApp.Interface;\r\n        }\r\n\r\n        private void OnDestroy()\r\n        {\r\n            // 8. 将 Model 设置为空\r\n            mModel = null;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n我们通过引入了 Command 来帮助 Controller 分担了一部分的交互逻辑。\r\n\r\n但是表现逻辑的代码目前看起来并不是很智能。\r\n\r\n表现逻辑的代码如下：\r\n\r\n```csharp\r\n// 监听输入\r\nmBtnAdd.onClick.AddListener(() =>\r\n{\r\n    // 交互逻辑\r\n    this.SendCommand<IncreaseCountCommand>();\r\n    // 表现逻辑\r\n    UpdateView();        \r\n});\r\n            \r\nmBtnSub.onClick.AddListener(() =>\r\n{\r\n    // 交互逻辑\r\n    this.SendCommand<DecreaseCountCommand>();\r\n    // 表现逻辑\r\n    UpdateView();\r\n});\r\n```\r\n\r\n每次调用逻辑之后，表现逻辑部分都需要手动调用一次（UpdateView 方法）。\r\n\r\n在一个项目中，表现逻辑的调用次数，至少会和交互逻辑的调用次数一样多。因为只要修改了数据，对应地就要把数据的biang在界面上表现出来。\r\n\r\n而这部分嗲用表现逻辑的代码也会很多，所以我们引入一个事件机制来解决这个问题。\r\n\r\n这个事件机制的使用其实是和 Command 一起使用的，这里有一个简单的小模式，如下图所示：\r\n\r\n![](https://file.liangxiegame.com/60ccd370-7c2c-4792-8435-ff5427dc5a1b.png)\r\n\r\n即通过 Command 修改数据，当数据发生修改后发送对应的数据变更事件。\r\n\r\n这个是简化版本的 CQRS 原则，即 Command Query Responsibility Separiation，读写分离原则。\r\n\r\n引入这项原则会很容易实现 事件驱动、数据驱动 架构。\r\n\r\n在 QFramework 中，用法非常简单，代码如下:\r\n\r\n```csharp\r\nusing UnityEngine;\r\nusing UnityEngine.UI;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    \r\n    // 1. 定义一个 Model 对象\r\n    public class CounterAppModel : AbstractModel\r\n    {\r\n        public int Count;\r\n        \r\n        protected override void OnInit()\r\n        {\r\n            Count = 0;\r\n        }\r\n    }\r\n\r\n\r\n    // 2.定义一个架构（提供 MVC、分层、模块管理等）\r\n    public class CounterApp : Architecture<CounterApp>\r\n    {\r\n        protected override void Init()\r\n        {\r\n            // 注册 Model\r\n            this.RegisterModel(new CounterAppModel());\r\n        }\r\n    }\r\n    \r\n    // 定义数据变更事件\r\n    public struct CountChangeEvent // ++\r\n    {\r\n        \r\n    }\r\n    \r\n    // 引入 Command\r\n    public class IncreaseCountCommand : AbstractCommand \r\n    {\r\n        protected override void OnExecute()\r\n        {\r\n            this.GetModel<CounterAppModel>().Count++;\r\n            this.SendEvent<CountChangeEvent>(); // ++\r\n        }\r\n    }\r\n    \r\n    public class DecreaseCountCommand : AbstractCommand\r\n    {\r\n        protected override void OnExecute()\r\n        {\r\n            this.GetModel<CounterAppModel>().Count--;\r\n            this.SendEvent<CountChangeEvent>(); // ++\r\n        }\r\n    }\r\n\r\n    // Controller\r\n    public class CounterAppController : MonoBehaviour , IController /* 3.实现 IController 接口 */\r\n    {\r\n        // View\r\n        private Button mBtnAdd;\r\n        private Button mBtnSub;\r\n        private Text mCountText;\r\n        \r\n        // 4. Model\r\n        private CounterAppModel mModel;\r\n\r\n        void Start()\r\n        {\r\n            // 5. 获取模型\r\n            mModel = this.GetModel<CounterAppModel>();\r\n            \r\n            // View 组件获取\r\n            mBtnAdd = transform.Find(\"BtnAdd\").GetComponent<Button>();\r\n            mBtnSub = transform.Find(\"BtnSub\").GetComponent<Button>();\r\n            mCountText = transform.Find(\"CountText\").GetComponent<Text>();\r\n            \r\n            \r\n            // 监听输入\r\n            mBtnAdd.onClick.AddListener(() =>\r\n            {\r\n                // 交互逻辑\r\n                this.SendCommand<IncreaseCountCommand>();\r\n            });\r\n            \r\n            mBtnSub.onClick.AddListener(() =>\r\n            {\r\n                // 交互逻辑\r\n                this.SendCommand(new DecreaseCountCommand(/* 这里可以传参（如果有） */));\r\n            });\r\n            \r\n            UpdateView();\r\n            \r\n            // 表现逻辑\r\n            this.RegisterEvent<CountChangeEvent>(e =>\r\n            {\r\n                UpdateView();\r\n\r\n            }).UnRegisterWhenGameObjectDestroyed(gameObject);\r\n        }\r\n        \r\n        void UpdateView()\r\n        {\r\n            mCountText.text = mModel.Count.ToString();\r\n        }\r\n\r\n        // 3.\r\n        public IArchitecture GetArchitecture()\r\n        {\r\n            return CounterApp.Interface;\r\n        }\r\n\r\n        private void OnDestroy()\r\n        {\r\n            // 8. 将 Model 设置为空\r\n            mModel = null;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n代码很简单。\r\n\r\n流程图如下：\r\n\r\n![image.png](https://file.liangxiegame.com/43474a6f-6a18-4d97-bdb9-9319a77481b9.png)\r\n\r\n运行结果如下:\r\n\r\n![282fcc3c-96fa-46e1-b4c6-7f4528b04271.gif](https://file.liangxiegame.com/1b934e4f-8f72-44c2-800a-a97f1e707950.gif)\r\n\r\n引入事件机制 和 CQRS 原则之后，我们的表现逻辑的代码变少了很多。\r\n\r\n由原来的两次主动调用\r\n\r\n``` csharp\r\n// 监听输入\r\nmBtnAdd.onClick.AddListener(() =>\r\n{\r\n    // 交互逻辑\r\n    this.SendCommand<IncreaseCountCommand>(); // 没有参数构造的命令支持泛型\r\n    // 表现逻辑\r\n    UpdateView();\r\n});\r\n            \r\nmBtnSub.onClick.AddListener(() =>\r\n{\r\n    // 交互逻辑\r\n    this.SendCommand(new DecreaseCountCommand()); // 也支持直接传入对象（方便通过构造传参)\r\n    // 表现逻辑\r\n    UpdateView();\r\n});\r\n```\r\n\r\n变成了一处监听事件，接收事件进行调用。\r\n\r\n``` csharp\r\n// 监听输入\r\nmBtnAdd.onClick.AddListener(() =>\r\n{\r\n    // 交互逻辑\r\n    this.SendCommand<IncreaseCountCommand>(); // 没有参数构造的命令支持泛型\r\n});\r\n            \r\nmBtnSub.onClick.AddListener(() =>\r\n{\r\n    // 交互逻辑\r\n    this.SendCommand(new DecreaseCountCommand()); // 也支持直接传入对象（方便通过构造传参)\r\n});\r\n            \r\nUpdateView();\r\n            \r\n// 表现逻辑\r\nthis.RegisterEvent<CountChangeEvent>(e =>\r\n{\r\n    UpdateView();\r\n}).UnRegisterWhenGameObjectDestroyed(gameObject);\r\n```\r\n\r\n这样减缓了很多交互逻辑。\r\n\r\nOK，到此，我们算是用上了还算合格的 MVC 的实现，而 QFramework 所提供的概念中，最重要的概念已经接触到了，即 CQRS，通过 Command 去修改数据，数据发生修改后发送数据变更事件。\r\n\r\n当前的示意图如下：\r\n\r\n![](https://file.liangxiegame.com/d25c65e0-25ba-43ca-9060-69bd51efaf46.png)\r\n\r\n\r\n学到这里，对于 QFramework 架构的使用算是真正的入门了。\r\n\r\n不过接下来还有一些概念，我们下一篇继续。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n# 05. 引入 Utility\r\n\r\n在这一篇，我们来支持 CounterApp 的存储功能。\r\n\r\n其代码也非常简单，只需要修改一部分 Model 的代码即可，如下：\r\n\r\n```csharp\r\n    // 定义一个 Model 对象\r\n    public class CounterAppModel : AbstractModel\r\n    {\r\n        private int mCount;\r\n\r\n        public int Count\r\n        {\r\n            get => mCount;\r\n            set\r\n            {\r\n                if (mCount != value)\r\n                {\r\n                    mCount = value;\r\n                    PlayerPrefs.SetInt(nameof(Count),mCount);\r\n                }\r\n            }\r\n        }\r\n\r\n        protected override void OnInit()\r\n        {\r\n            Count = PlayerPrefs.GetInt(nameof(Count), mCount);\r\n        }\r\n    }\r\n```\r\n\r\n这样就支持了非常基本的数据存储功能。\r\n\r\n当然还是有一些问题，如果时候未来我们需要存储的数据非常多的时候，Model 层就会充斥大量存储、加载相关的代码。\r\n\r\n还有就是，我们以后如果不想使用 PlayperPrefs 了，想使用 EasySave 或者 SQLite 的时候，就会造成大量的修改工作量。\r\n\r\n于是 QFramework 提供了一个 Utility 层，专门用来解决上述两个问题的，使用方法非常简单，如下：\r\n\r\n```csharp\r\nusing UnityEngine;\r\nusing UnityEngine.UI;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    \r\n    // 1. 定义一个 Model 对象\r\n    public class CounterAppModel : AbstractModel\r\n    {\r\n        private int mCount;\r\n\r\n        public int Count\r\n        {\r\n            get => mCount;\r\n            set\r\n            {\r\n                if (mCount != value)\r\n                {\r\n                    mCount = value;\r\n                    PlayerPrefs.SetInt(nameof(Count),mCount);\r\n                }\r\n            }\r\n        }\r\n\r\n        protected override void OnInit()\r\n        {\r\n            var storage = this.GetUtility<Storage>();\r\n\r\n            Count = storage.LoadInt(nameof(Count));\r\n\r\n            // 可以通过 CounterApp.Interface 监听数据变更事件\r\n            CounterApp.Interface.RegisterEvent<CountChangeEvent>(e =>\r\n            {\r\n                this.GetUtility<Storage>().SaveInt(nameof(Count), Count);\r\n            });\r\n        }\r\n    }\r\n\r\n    // 定义 utility 层\r\n    public class Storage : IUtility\r\n    {\r\n        public void SaveInt(string key, int value)\r\n        {\r\n            PlayerPrefs.SetInt(key,value);\r\n        }\r\n\r\n        public int LoadInt(string key, int defaultValue = 0)\r\n        {\r\n            return PlayerPrefs.GetInt(key, defaultValue);\r\n        }\r\n    }\r\n\r\n\r\n    // 2.定义一个架构（提供 MVC、分层、模块管理等）\r\n    public class CounterApp : Architecture<CounterApp>\r\n    {\r\n        protected override void Init()\r\n        {\r\n            // 注册 Model\r\n            this.RegisterModel(new CounterAppModel());\r\n            \r\n            // 注册存储工具的对象\r\n            this.RegisterUtility(new Storage());\r\n        }\r\n    }\r\n    \r\n    // 定义数据变更事件\r\n    public struct CountChangeEvent // ++\r\n    {\r\n        \r\n    }\r\n    \r\n    // 引入 Command\r\n    public class IncreaseCountCommand : AbstractCommand \r\n    {\r\n        protected override void OnExecute()\r\n        {\r\n            this.GetModel<CounterAppModel>().Count++;\r\n            this.SendEvent<CountChangeEvent>(); // ++\r\n        }\r\n    }\r\n    \r\n    public class DecreaseCountCommand : AbstractCommand\r\n    {\r\n        protected override void OnExecute()\r\n        {\r\n            this.GetModel<CounterAppModel>().Count--;\r\n            this.SendEvent<CountChangeEvent>(); // ++\r\n        }\r\n    }\r\n\r\n    // Controller\r\n    public class CounterAppController : MonoBehaviour , IController /* 3.实现 IController 接口 */\r\n    {\r\n        // View\r\n        private Button mBtnAdd;\r\n        private Button mBtnSub;\r\n        private Text mCountText;\r\n        \r\n        // 4. Model\r\n        private CounterAppModel mModel;\r\n\r\n        void Start()\r\n        {\r\n            // 5. 获取模型\r\n            mModel = this.GetModel<CounterAppModel>();\r\n            \r\n            // View 组件获取\r\n            mBtnAdd = transform.Find(\"BtnAdd\").GetComponent<Button>();\r\n            mBtnSub = transform.Find(\"BtnSub\").GetComponent<Button>();\r\n            mCountText = transform.Find(\"CountText\").GetComponent<Text>();\r\n            \r\n            \r\n            // 监听输入\r\n            mBtnAdd.onClick.AddListener(() =>\r\n            {\r\n                // 交互逻辑\r\n                this.SendCommand<IncreaseCountCommand>();\r\n            });\r\n            \r\n            mBtnSub.onClick.AddListener(() =>\r\n            {\r\n                // 交互逻辑\r\n                this.SendCommand(new DecreaseCountCommand(/* 这里可以传参（如果有） */));\r\n            });\r\n            \r\n            UpdateView();\r\n            \r\n            // 表现逻辑\r\n            this.RegisterEvent<CountChangeEvent>(e =>\r\n            {\r\n                UpdateView();\r\n\r\n            }).UnRegisterWhenGameObjectDestroyed(gameObject);\r\n        }\r\n        \r\n        void UpdateView()\r\n        {\r\n            mCountText.text = mModel.Count.ToString();\r\n        }\r\n\r\n        // 3.\r\n        public IArchitecture GetArchitecture()\r\n        {\r\n            return CounterApp.Interface;\r\n        }\r\n\r\n        private void OnDestroy()\r\n        {\r\n            // 8. 将 Model 设置为空\r\n            mModel = null;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n代码非常简单，我们运行下 Unity 看下结果：\r\n\r\n![f55b6c09-f5a0-402f-bffa-5ceb0bc3d8fb.gif](https://file.liangxiegame.com/1c622976-b32a-4b62-92a3-d34b2c628e27.gif)\r\n\r\n运行正确。\r\n\r\n这样当我们，想要将 PlayerPrefs 方案替换成 EasySave 的时候，只需要对 Storage 里的代码进行修改即可。\r\n\r\n最后给出流程图，如下：\r\n\r\n![image.png](https://file.liangxiegame.com/f2329b2f-700a-4693-b22e-b1afc50c7364.png)\r\n\r\n好了，这篇就介绍到这里。\r\n\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n# 06. 引入 System\r\n在这一篇，我们来引入最后一个基本概念 System。\r\n\r\n首先我们来看下代码，如下:\r\n\r\n```csharp\r\nusing UnityEngine;\r\nusing UnityEngine.UI;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    \r\n    // 1. 定义一个 Model 对象\r\n    public class CounterAppModel : AbstractModel\r\n    {\r\n        private int mCount;\r\n\r\n        public int Count\r\n        {\r\n            get => mCount;\r\n            set\r\n            {\r\n                if (mCount != value)\r\n                {\r\n                    mCount = value;\r\n                    PlayerPrefs.SetInt(nameof(Count),mCount);\r\n                }\r\n            }\r\n        }\r\n\r\n        protected override void OnInit()\r\n        {\r\n            var storage = this.GetUtility<Storage>();\r\n\r\n            Count = storage.LoadInt(nameof(Count));\r\n\r\n            // 可以通过 CounterApp.Interface 监听数据变更事件\r\n            CounterApp.Interface.RegisterEvent<CountChangeEvent>(e =>\r\n            {\r\n                this.GetUtility<Storage>().SaveInt(nameof(Count), Count);\r\n            });\r\n        }\r\n    }\r\n\r\n    // 定义 utility 层\r\n    public class Storage : IUtility\r\n    {\r\n        public void SaveInt(string key, int value)\r\n        {\r\n            PlayerPrefs.SetInt(key,value);\r\n        }\r\n\r\n        public int LoadInt(string key, int defaultValue = 0)\r\n        {\r\n            return PlayerPrefs.GetInt(key, defaultValue);\r\n        }\r\n    }\r\n\r\n\r\n    // 2.定义一个架构（提供 MVC、分层、模块管理等）\r\n    public class CounterApp : Architecture<CounterApp>\r\n    {\r\n        protected override void Init()\r\n        {\r\n            // 注册 Model\r\n            this.RegisterModel(new CounterAppModel());\r\n            \r\n            // 注册存储工具的对象\r\n            this.RegisterUtility(new Storage());\r\n        }\r\n    }\r\n    \r\n    // 定义数据变更事件\r\n    public struct CountChangeEvent // ++\r\n    {\r\n        \r\n    }\r\n    \r\n    // 引入 Command\r\n    public class IncreaseCountCommand : AbstractCommand \r\n    {\r\n        protected override void OnExecute()\r\n        {\r\n            this.GetModel<CounterAppModel>().Count++;\r\n            this.SendEvent<CountChangeEvent>(); // ++\r\n        }\r\n    }\r\n    \r\n    public class DecreaseCountCommand : AbstractCommand\r\n    {\r\n        protected override void OnExecute()\r\n        {\r\n            this.GetModel<CounterAppModel>().Count--;\r\n            this.SendEvent<CountChangeEvent>(); // ++\r\n        }\r\n    }\r\n\r\n    // Controller\r\n    public class CounterAppController : MonoBehaviour , IController /* 3.实现 IController 接口 */\r\n    {\r\n        // View\r\n        private Button mBtnAdd;\r\n        private Button mBtnSub;\r\n        private Text mCountText;\r\n        \r\n        // 4. Model\r\n        private CounterAppModel mModel;\r\n\r\n        void Start()\r\n        {\r\n            // 5. 获取模型\r\n            mModel = this.GetModel<CounterAppModel>();\r\n            \r\n            // View 组件获取\r\n            mBtnAdd = transform.Find(\"BtnAdd\").GetComponent<Button>();\r\n            mBtnSub = transform.Find(\"BtnSub\").GetComponent<Button>();\r\n            mCountText = transform.Find(\"CountText\").GetComponent<Text>();\r\n            \r\n            \r\n            // 监听输入\r\n            mBtnAdd.onClick.AddListener(() =>\r\n            {\r\n                // 交互逻辑\r\n                this.SendCommand<IncreaseCountCommand>();\r\n            });\r\n            \r\n            mBtnSub.onClick.AddListener(() =>\r\n            {\r\n                // 交互逻辑\r\n                this.SendCommand(new DecreaseCountCommand(/* 这里可以传参（如果有） */));\r\n            });\r\n            \r\n            UpdateView();\r\n            \r\n            // 表现逻辑\r\n            this.RegisterEvent<CountChangeEvent>(e =>\r\n            {\r\n                UpdateView();\r\n\r\n            }).UnRegisterWhenGameObjectDestroyed(gameObject);\r\n        }\r\n        \r\n        void UpdateView()\r\n        {\r\n            mCountText.text = mModel.Count.ToString();\r\n        }\r\n\r\n        // 3.\r\n        public IArchitecture GetArchitecture()\r\n        {\r\n            return CounterApp.Interface;\r\n        }\r\n\r\n        private void OnDestroy()\r\n        {\r\n            // 8. 将 Model 设置为空\r\n            mModel = null;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n这里我们假设一个功能，即策划提出了一个成就达成的功能，即 Count 到 10 的时候，触发一个点击达人成就，点击二十次 则触发一个 点击专家成就。\r\n\r\n逻辑听起来很简单，我们直接在 IncreaseCountCommand 里编写即可，如下：\r\n\r\n```csharp\r\n    public class IncreaseCountCommand : AbstractCommand \r\n    {\r\n        protected override void OnExecute()\r\n        {\r\n            var model = this.GetModel<CounterAppModel>();\r\n                \r\n            model.Count++;\r\n            this.SendEvent<CountChangeEvent>(); // ++\r\n\r\n            if (model.Count == 10)\r\n            {\r\n                Debug.Log(\"触发 点击达人 成就\");\r\n            }\r\n            else if (model.Count == 20)\r\n            {\r\n                Debug.Log(\"触发 点击专家 成就\");\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n代码很简单，我们运行测试一下。\r\n\r\n运行之后，笔者点击了 20 次 + 号，结果如下：\r\n\r\n![image.png](https://file.liangxiegame.com/826d5513-059e-41ba-8f5a-4fbea78dbde7.png)\r\n\r\n这个功能很快就完成了。\r\n\r\n但是这个时候策划说，希望再增加一个当点击 - 号到 -10 时，触发一个 点击菜鸟成就，然后策划还说，点击达人 和 点击专家 成就太容易达成了，需要分别改成 1000 次 和 2000 次。\r\n\r\n而这次策划提出的需求，需要我们修改两处的代码，即 IncreaseCountCommand 里需要修改数值为 1000 和 2000，然后再 DecreaseCountCommand 增加一个判断逻辑。\r\n\r\n一次提出的需求，结果造成了多处修改，这说明代码有问题。\r\n\r\n首先像这种规则类的逻辑，比如分数统计或者成就统计等代码，不适合分散写在 Command 里，而适合统一写在一个对象里，而这种对象，在 QFramework 里有提供，就是 System 对象。\r\n\r\n使用代码如下:\r\n\r\n```csharp\r\nusing UnityEngine;\r\nusing UnityEngine.UI;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    \r\n    // 1. 定义一个 Model 对象\r\n    public class CounterAppModel : AbstractModel\r\n    {\r\n        private int mCount;\r\n\r\n        public int Count\r\n        {\r\n            get => mCount;\r\n            set\r\n            {\r\n                if (mCount != value)\r\n                {\r\n                    mCount = value;\r\n                    PlayerPrefs.SetInt(nameof(Count),mCount);\r\n                }\r\n            }\r\n        }\r\n\r\n        protected override void OnInit()\r\n        {\r\n            var storage = this.GetUtility<Storage>();\r\n\r\n            Count = storage.LoadInt(nameof(Count));\r\n\r\n            // 可以通过 CounterApp.Interface 监听数据变更事件\r\n            CounterApp.Interface.RegisterEvent<CountChangeEvent>(e =>\r\n            {\r\n                this.GetUtility<Storage>().SaveInt(nameof(Count), Count);\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n    public class AchievementSystem : AbstractSystem // +\r\n    {\r\n        protected override void OnInit()\r\n        {\r\n            var model = this.GetModel<CounterAppModel>();\r\n\r\n            this.RegisterEvent<CountChangeEvent>(e =>\r\n            {\r\n                if (model.Count == 10)\r\n                {\r\n                    Debug.Log(\"触发 点击达人 成就\");\r\n                }\r\n                else if (model.Count == 20)\r\n                {\r\n                    Debug.Log(\"触发 点击专家 成就\");\r\n                } else if (model.Count == -10)\r\n                {\r\n                    Debug.Log(\"触发 点击菜鸟 成就\");\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    // 定义 utility 层\r\n    public class Storage : IUtility\r\n    {\r\n        public void SaveInt(string key, int value)\r\n        {\r\n            PlayerPrefs.SetInt(key,value);\r\n        }\r\n\r\n        public int LoadInt(string key, int defaultValue = 0)\r\n        {\r\n            return PlayerPrefs.GetInt(key, defaultValue);\r\n        }\r\n    }\r\n\r\n\r\n    // 2.定义一个架构（提供 MVC、分层、模块管理等）\r\n    public class CounterApp : Architecture<CounterApp>\r\n    {\r\n        protected override void Init()\r\n        {\r\n            // 注册 System \r\n            this.RegisterSystem(new AchievementSystem()); // +\r\n             \r\n            // 注册 Model\r\n            this.RegisterModel(new CounterAppModel());\r\n            \r\n            // 注册存储工具的对象\r\n            this.RegisterUtility(new Storage());\r\n        }\r\n    }\r\n    \r\n    // 定义数据变更事件\r\n    public struct CountChangeEvent // ++\r\n    {\r\n        \r\n    }\r\n    \r\n    // 引入 Command\r\n    public class IncreaseCountCommand : AbstractCommand \r\n    {\r\n        protected override void OnExecute()\r\n        {\r\n            var model = this.GetModel<CounterAppModel>();\r\n                \r\n            model.Count++;\r\n            this.SendEvent<CountChangeEvent>(); // ++\r\n        }\r\n    }\r\n    \r\n    public class DecreaseCountCommand : AbstractCommand\r\n    {\r\n        protected override void OnExecute()\r\n        {\r\n            this.GetModel<CounterAppModel>().Count--;\r\n            this.SendEvent<CountChangeEvent>(); // ++\r\n        }\r\n    }\r\n\r\n    // Controller\r\n    public class CounterAppController : MonoBehaviour , IController /* 3.实现 IController 接口 */\r\n    {\r\n        // View\r\n        private Button mBtnAdd;\r\n        private Button mBtnSub;\r\n        private Text mCountText;\r\n        \r\n        // 4. Model\r\n        private CounterAppModel mModel;\r\n\r\n        void Start()\r\n        {\r\n            // 5. 获取模型\r\n            mModel = this.GetModel<CounterAppModel>();\r\n            \r\n            // View 组件获取\r\n            mBtnAdd = transform.Find(\"BtnAdd\").GetComponent<Button>();\r\n            mBtnSub = transform.Find(\"BtnSub\").GetComponent<Button>();\r\n            mCountText = transform.Find(\"CountText\").GetComponent<Text>();\r\n            \r\n            \r\n            // 监听输入\r\n            mBtnAdd.onClick.AddListener(() =>\r\n            {\r\n                // 交互逻辑\r\n                this.SendCommand<IncreaseCountCommand>();\r\n            });\r\n            \r\n            mBtnSub.onClick.AddListener(() =>\r\n            {\r\n                // 交互逻辑\r\n                this.SendCommand(new DecreaseCountCommand(/* 这里可以传参（如果有） */));\r\n            });\r\n            \r\n            UpdateView();\r\n            \r\n            // 表现逻辑\r\n            this.RegisterEvent<CountChangeEvent>(e =>\r\n            {\r\n                UpdateView();\r\n\r\n            }).UnRegisterWhenGameObjectDestroyed(gameObject);\r\n        }\r\n        \r\n        void UpdateView()\r\n        {\r\n            mCountText.text = mModel.Count.ToString();\r\n        }\r\n\r\n        // 3.\r\n        public IArchitecture GetArchitecture()\r\n        {\r\n            return CounterApp.Interface;\r\n        }\r\n\r\n        private void OnDestroy()\r\n        {\r\n            // 8. 将 Model 设置为空\r\n            mModel = null;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n代码越来越多，但是不难。\r\n\r\n运行游戏，笔者点击的结果如下：\r\n\r\n![](https://file.liangxiegame.com/a1adc1e8-6bb9-49c1-ae74-e0e55673e865.png)\r\n\r\n结果没问题。\r\n\r\n好了，笔者写的成就系统非常简陋，实际上额度成就系统可以写得非常完善，比如可以再成就系统里进行存储加载等操作，而此文的成就系统仅仅是展示目的。\r\n\r\n到此，我们就接触到了 QFramework 架构所提供的核心概念。\r\n\r\n我们回顾一下第一篇的两张图，如下:\r\n\r\n![](https://file.liangxiegame.com/39bdcf54-0240-46e0-8f68-9eb708505695.png)\r\n\r\n\r\n\r\n![](https://file.liangxiegame.com/6bf42306-0b2a-4417-bbcf-354af0132596.png)\r\n\r\n到此，大家应该能看懂这两张图了。\r\n\r\nQFramework 总共分四个层级，即\r\n* 表现层：IController\r\n* 系统层：ISystem\r\n* 数据层：IModel\r\n* 工具层：IUtility\r\n\r\n除了四个层级，还接触了为 Controller 的交互逻辑减负的 Command 和 为表现逻辑减负的 Event。\r\n\r\n还有一个非常重要的 CQRS 原则的简易版本，Command->Model->State Changed Event。\r\n\r\n到目前为止 QFramework 的基本用法我们过了一遍了。\r\n\r\n从下一篇开始，我们开始介绍 QFramework 架构提供的剩余功能，这些功能是可选的。\r\n\r\n这篇就到这里。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n\r\n\r\n\r\n\r\n\r\n# 07. 使用 BindableProperty 优化事件\r\n\r\n在这篇我们介绍一个新的概念 BindableProperty。\r\n\r\nBindableProperty 是包含 数据 + 数据变更事件 的一个对象。\r\n\r\n## BindableProperty 基本使用\r\n简单的用法如下:\r\n\r\n```csharp\r\nvar age = new BindableProperty<int>(10);\r\n\r\nage.Register(newAge=>{\r\n  \r\n  Debug.Log(newAge)\r\n}).UnRegisterWhenGameObjectDestoryed(gameObject);\r\n\r\n\r\nage++;\r\nage--;\r\n\r\n\r\n// 输出结果\r\n// 11\r\n// 10\r\n```\r\n\r\n非常简单，就是当调用 age++ 和 age-- 的时候，就会触发数据变更事件。\r\n\r\nBindableProperty 除了提供 Register 这个 API 之外，还提供了 RegisterWithInitValue API,意思是 注册时 先把当前值返回过来。\r\n\r\n具体用法如下:\r\n\r\n```csharp\r\nvar age = new BindableProperty<int>(5);\r\n\r\nage.RegisterWithInitValue(newAge => {\r\n  \r\n  Debug.Log(newAge);\r\n  \r\n});\r\n\r\n// 输出结果\r\n// 5\r\n```\r\n\r\n这个 API 就是，没有任何变化的情况下，age 先返回一个当前的值，比较方便用于显示初始界面。\r\n\r\nBindableProperty 是一个独立的工具，可以脱离 QFramework 架构使用，也就是说不用非要用 QFramework 的 MVC 才能用 BindableProperty，而是可以再自己项目中随意使用。\r\n\r\n## 使用 BindableProperty 优化  CounterApp 的代码\r\n\r\n我们直接优化即可，优化后代码如下:\r\n\r\n```csharp\r\nusing UnityEngine;\r\nusing UnityEngine.UI;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    \r\n    // 1. 定义一个 Model 对象\r\n    public class CounterAppModel : AbstractModel\r\n    {\r\n        public BindableProperty<int> Count { get; } = new BindableProperty<int>();\r\n\r\n        protected override void OnInit()\r\n        {\r\n            var storage = this.GetUtility<Storage>();\r\n            \r\n            // 设置初始值（不触发事件）\r\n            Count.SetValueWithoutEvent(storage.LoadInt(nameof(Count)));\r\n\r\n            // 当数据变更时 存储数据\r\n            Count.Register(newCount =>\r\n            {\r\n                storage.SaveInt(nameof(Count),newCount);\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n    public class AchievementSystem : AbstractSystem \r\n    {\r\n        protected override void OnInit()\r\n        {\r\n            this.GetModel<CounterAppModel>() // -+\r\n                .Count\r\n                .Register(newCount =>\r\n                {\r\n                    if (newCount == 10)\r\n                    {\r\n                        Debug.Log(\"触发 点击达人 成就\");\r\n                    }\r\n                    else if (newCount == 20)\r\n                    {\r\n                        Debug.Log(\"触发 点击专家 成就\");\r\n                    }\r\n                    else if (newCount == -10)\r\n                    {\r\n                        Debug.Log(\"触发 点击菜鸟 成就\");\r\n                    }\r\n                });\r\n        }\r\n    }\r\n\r\n    // 定义 utility 层\r\n    public class Storage : IUtility\r\n    {\r\n        public void SaveInt(string key, int value)\r\n        {\r\n            PlayerPrefs.SetInt(key,value);\r\n        }\r\n\r\n        public int LoadInt(string key, int defaultValue = 0)\r\n        {\r\n            return PlayerPrefs.GetInt(key, defaultValue);\r\n        }\r\n    }\r\n\r\n\r\n    // 2.定义一个架构（提供 MVC、分层、模块管理等）\r\n    public class CounterApp : Architecture<CounterApp>\r\n    {\r\n        protected override void Init()\r\n        {\r\n            // 注册 System \r\n            this.RegisterSystem(new AchievementSystem()); // +\r\n             \r\n            // 注册 Model\r\n            this.RegisterModel(new CounterAppModel());\r\n            \r\n            // 注册存储工具的对象\r\n            this.RegisterUtility(new Storage());\r\n        }\r\n    }\r\n\r\n    // 引入 Command\r\n    public class IncreaseCountCommand : AbstractCommand \r\n    {\r\n        protected override void OnExecute()\r\n        {\r\n            var model = this.GetModel<CounterAppModel>();\r\n                \r\n            model.Count.Value++; // -+\r\n        }\r\n    }\r\n    \r\n    public class DecreaseCountCommand : AbstractCommand\r\n    {\r\n        protected override void OnExecute()\r\n        {\r\n            this.GetModel<CounterAppModel>().Count.Value--; // -+\r\n        }\r\n    }\r\n\r\n    // Controller\r\n    public class CounterAppController : MonoBehaviour , IController /* 3.实现 IController 接口 */\r\n    {\r\n        // View\r\n        private Button mBtnAdd;\r\n        private Button mBtnSub;\r\n        private Text mCountText;\r\n        \r\n        // 4. Model\r\n        private CounterAppModel mModel;\r\n\r\n        void Start()\r\n        {\r\n            // 5. 获取模型\r\n            mModel = this.GetModel<CounterAppModel>();\r\n            \r\n            // View 组件获取\r\n            mBtnAdd = transform.Find(\"BtnAdd\").GetComponent<Button>();\r\n            mBtnSub = transform.Find(\"BtnSub\").GetComponent<Button>();\r\n            mCountText = transform.Find(\"CountText\").GetComponent<Text>();\r\n            \r\n            \r\n            // 监听输入\r\n            mBtnAdd.onClick.AddListener(() =>\r\n            {\r\n                // 交互逻辑\r\n                this.SendCommand<IncreaseCountCommand>();\r\n            });\r\n            \r\n            mBtnSub.onClick.AddListener(() =>\r\n            {\r\n                // 交互逻辑\r\n                this.SendCommand(new DecreaseCountCommand(/* 这里可以传参（如果有） */));\r\n            });\r\n\r\n            // 表现逻辑\r\n            mModel.Count.RegisterWithInitValue(newCount => // -+\r\n            {\r\n                UpdateView();\r\n\r\n            }).UnRegisterWhenGameObjectDestroyed(gameObject);\r\n        }\r\n        \r\n        void UpdateView()\r\n        {\r\n            mCountText.text = mModel.Count.ToString();\r\n        }\r\n\r\n        // 3.\r\n        public IArchitecture GetArchitecture()\r\n        {\r\n            return CounterApp.Interface;\r\n        }\r\n\r\n        private void OnDestroy()\r\n        {\r\n            // 8. 将 Model 设置为空\r\n            mModel = null;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n代码改动很多，重要的改动为：\r\n* Model 中的 Count 和 mCount 改成了一个叫做 Count 的 BindableProperty\r\n* 删掉了 CountChangeEvent 改用监听 BindableProperty\r\n* Controller 在初始化中去掉一次 UpdateView 的主动调用\r\n\r\n可以说代码量一下子少了很多。\r\n\r\n我们看下运行结果：\r\n\r\n![282fcc3c-96fa-46e1-b4c6-7f4528b04271.gif](https://file.liangxiegame.com/1b934e4f-8f72-44c2-800a-a97f1e707950.gif)\r\n\r\n\r\n运行没问题。\r\n\r\n由于我们的 Count 数据，是单个数据 + 事件变更的形式，所以用 BindableProperty 非常合适，可以少写很多代码。\r\n\r\n一般情况下，像主角的金币、分数等数据非常适合用 BindableProperty 的方式实现。\r\n\r\n好了 BindableProperty 我们就介绍到这里。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n# 08. 用接口设计模块（依赖倒置原则）\r\n\r\nQFramework 本身支持依赖倒置原则，就是所有的模块访问和交互都可以通过接口来完成，代码如下:\r\n\r\n```csharp\r\nusing UnityEngine;\r\nusing UnityEngine.UI;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    \r\n    // 1. 定义一个 Model 对象\r\n    public interface ICounterAppModel : IModel\r\n    {\r\n        BindableProperty<int> Count { get; }\r\n    }\r\n    public class CounterAppModel : AbstractModel,ICounterAppModel\r\n    {\r\n        public BindableProperty<int> Count { get; } = new BindableProperty<int>();\r\n\r\n        protected override void OnInit()\r\n        {\r\n            var storage = this.GetUtility<IStorage>();\r\n            \r\n            // 设置初始值（不触发事件）\r\n            Count.SetValueWithoutEvent(storage.LoadInt(nameof(Count)));\r\n\r\n            // 当数据变更时 存储数据\r\n            Count.Register(newCount =>\r\n            {\r\n                storage.SaveInt(nameof(Count),newCount);\r\n            });\r\n        }\r\n    }\r\n\r\n    public interface IAchievementSystem : ISystem\r\n    {\r\n        \r\n    }\r\n\r\n    public class AchievementSystem : AbstractSystem ,IAchievementSystem\r\n    {\r\n        protected override void OnInit()\r\n        {\r\n            this.GetModel<ICounterAppModel>() // -+\r\n                .Count\r\n                .Register(newCount =>\r\n                {\r\n                    if (newCount == 10)\r\n                    {\r\n                        Debug.Log(\"触发 点击达人 成就\");\r\n                    }\r\n                    else if (newCount == 20)\r\n                    {\r\n                        Debug.Log(\"触发 点击专家 成就\");\r\n                    }\r\n                    else if (newCount == -10)\r\n                    {\r\n                        Debug.Log(\"触发 点击菜鸟 成就\");\r\n                    }\r\n                });\r\n        }\r\n    }\r\n\r\n    public interface IStorage : IUtility\r\n    {\r\n        void SaveInt(string key, int value);\r\n        int LoadInt(string key, int defaultValue = 0);\r\n    }\r\n    \r\n    public class Storage : IStorage\r\n    {\r\n        public void SaveInt(string key, int value)\r\n        {\r\n            PlayerPrefs.SetInt(key,value);\r\n        }\r\n\r\n        public int LoadInt(string key, int defaultValue = 0)\r\n        {\r\n            return PlayerPrefs.GetInt(key, defaultValue);\r\n        }\r\n    }\r\n\r\n\r\n    // 2.定义一个架构（提供 MVC、分层、模块管理等）\r\n    public class CounterApp : Architecture<CounterApp>\r\n    {\r\n        protected override void Init()\r\n        {\r\n            // 注册 System \r\n            this.RegisterSystem<IAchievementSystem>(new AchievementSystem()); \r\n             \r\n            // 注册 Model\r\n            this.RegisterModel<ICounterAppModel>(new CounterAppModel());\r\n            \r\n            // 注册存储工具的对象\r\n            this.RegisterUtility<IStorage>(new Storage());\r\n        }\r\n    }\r\n\r\n    // 引入 Command\r\n    public class IncreaseCountCommand : AbstractCommand \r\n    {\r\n        protected override void OnExecute()\r\n        {\r\n            var model = this.GetModel<ICounterAppModel>();\r\n                \r\n            model.Count.Value++; // -+\r\n        }\r\n    }\r\n    \r\n    public class DecreaseCountCommand : AbstractCommand\r\n    {\r\n        protected override void OnExecute()\r\n        {\r\n            this.GetModel<ICounterAppModel>().Count.Value--; // -+\r\n        }\r\n    }\r\n\r\n    // Controller\r\n    public class CounterAppController : MonoBehaviour , IController /* 3.实现 IController 接口 */\r\n    {\r\n        // View\r\n        private Button mBtnAdd;\r\n        private Button mBtnSub;\r\n        private Text mCountText;\r\n        \r\n        // 4. Model\r\n        private ICounterAppModel mModel;\r\n\r\n        void Start()\r\n        {\r\n            // 5. 获取模型\r\n            mModel = this.GetModel<ICounterAppModel>();\r\n            \r\n            // View 组件获取\r\n            mBtnAdd = transform.Find(\"BtnAdd\").GetComponent<Button>();\r\n            mBtnSub = transform.Find(\"BtnSub\").GetComponent<Button>();\r\n            mCountText = transform.Find(\"CountText\").GetComponent<Text>();\r\n            \r\n            \r\n            // 监听输入\r\n            mBtnAdd.onClick.AddListener(() =>\r\n            {\r\n                // 交互逻辑\r\n                this.SendCommand<IncreaseCountCommand>();\r\n            });\r\n            \r\n            mBtnSub.onClick.AddListener(() =>\r\n            {\r\n                // 交互逻辑\r\n                this.SendCommand(new DecreaseCountCommand(/* 这里可以传参（如果有） */));\r\n            });\r\n\r\n            // 表现逻辑\r\n            mModel.Count.RegisterWithInitValue(newCount => // -+\r\n            {\r\n                UpdateView();\r\n\r\n            }).UnRegisterWhenGameObjectDestroyed(gameObject);\r\n        }\r\n        \r\n        void UpdateView()\r\n        {\r\n            mCountText.text = mModel.Count.ToString();\r\n        }\r\n\r\n        // 3.\r\n        public IArchitecture GetArchitecture()\r\n        {\r\n            return CounterApp.Interface;\r\n        }\r\n\r\n        private void OnDestroy()\r\n        {\r\n            // 8. 将 Model 设置为空\r\n            mModel = null;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n代码不难。\r\n\r\n所有的模块注册，模块获取 等代码都是通过接口完成，这一点符合 SOLID 原则中的 依赖倒置原则。\r\n\r\n通过接口设计模块可以让我们更容易思考模块之间的交互和职责本身，而不是具体实现，在设计的时候可以减少很多的干扰。\r\n\r\n当然面向接口的方式去做开发也有很多其他的好处，这当然是大家随着使用时长会慢慢体会的。\r\n\r\n其中有一个重要的大一点，就是我们之前说的 Storage，如果想把存储的 API 从 PlayerPrefs 切换成 EasySave，那么我们就不需要去修改 Storage 对象，而是扩展一个 IStorage 接口即可，伪代码如下:\r\n```csharp\r\n    public class EasySaveStorage : IStorage\r\n    {\r\n        public void SaveInt(string key, int value)\r\n        {\r\n            // todo\r\n        }\r\n\r\n        public int LoadInt(string key, int defaultValue = 0)\r\n        {\r\n            // todo\r\n            throw new System.NotImplementedException();\r\n        }\r\n    }\r\n```\r\n\r\n注册模块的伪代码如下:\r\n\r\n```csharp\r\n    // 定义一个架构（用于管理模块）\r\n    public class CounterApp : Architecture<CounterApp>\r\n    {\r\n        protected override void Init()\r\n        {\r\n            // 注册成就系统\r\n            this.RegisterSystem<IAchievementSystem>(new AchievementSystem());\r\n            \r\n            this.RegisterModel<ICounterAppModel>(new CounterAppModel());\r\n            \r\n            // 注册存储工具对象\r\n            // this.RegisterUtility<IStorage>(new Storage());\r\n            this.RegisterUtility<IStorage>(new EasySaveStorage());\r\n        }\r\n    }\r\n```\r\n\r\n这样，底层所有存储的代码都切换成了 EasySave 的存储，替换一套方案非常简单。\r\n\r\n好了，用接口设计模块的功能就介绍完了。\r\n\r\n这篇内容就这些。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n# 09. Query 介绍\r\n\r\nQuery 是 CQRS 中的 Q，也就是 Command Query Responsibility Saperation 中的 Query。\r\n\r\n关于 Command 我们已经介绍了。\r\n\r\n而 Query 是和 Command 对应的查询对象。\r\n\r\n首先 Controller 中的表现逻辑更多是接收到数据变更事件之后，对 Model 或者 System 进行查询，而查询的时候，有的时候需要组合查询，比如多个 Model 一起查询，查询的数据可能还需要转换一下，这种查询的代码量比较多。尤其是像模拟警用或者非常重数据的项目，所以 QFramework 支持通过 Query 这样的一个概念，来解决这部分问题。\r\n\r\n使用的方式也很简单，和 Command 用法一致，这里我们写一个小的 App， 叫做 QueryExampleApp 代码如下:\r\n\r\n```csharp\r\nusing System.Collections.Generic;\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class QueryExampleController : MonoBehaviour,IController\r\n    {\r\n        public class StudentModel : AbstractModel\r\n        {\r\n\r\n            public List<string> StudentNames = new List<string>()\r\n            {\r\n                \"张三\",\r\n                \"李四\"\r\n            };\r\n            \r\n            protected override void OnInit()\r\n            {\r\n                \r\n            }\r\n        }\r\n        \r\n        public class TeacherModel : AbstractModel\r\n        {\r\n            public List<string> TeacherNames = new List<string>()\r\n            {\r\n                \"王五\",\r\n                \"赵六\"\r\n            };\r\n                \r\n            protected override void OnInit()\r\n            {\r\n                \r\n            }\r\n        }\r\n\r\n        // Architecture\r\n        public class QueryExampleApp : Architecture<QueryExampleApp>\r\n        {\r\n            protected override void Init()\r\n            {\r\n                this.RegisterModel(new StudentModel());\r\n                this.RegisterModel(new TeacherModel());\r\n            }\r\n        }\r\n        \r\n        \r\n        /// <summary>\r\n        /// 获取学校的全部人数\r\n        /// </summary>\r\n        public class SchoolAllPersonCountQuery : AbstractQuery<int>\r\n        {\r\n            protected override int OnDo()\r\n            {\r\n                return this.GetModel<StudentModel>().StudentNames.Count +\r\n                       this.GetModel<TeacherModel>().TeacherNames.Count;\r\n            }\r\n        }\r\n\r\n        private int mAllPersonCount = 0;\r\n\r\n        private void OnGUI()\r\n        {\r\n            GUILayout.Label(mAllPersonCount.ToString());\r\n\r\n            if (GUILayout.Button(\"查询学校总人数\"))\r\n            {\r\n                mAllPersonCount = this.SendQuery(new SchoolAllPersonCountQuery());\r\n            }\r\n        }\r\n\r\n        public IArchitecture GetArchitecture()\r\n        {\r\n            return QueryExampleApp.Interface;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n代码不难。\r\n\r\n运行之后，当按下查询按钮时结果如下：\r\n\r\n\r\n![image.png](https://file.liangxiegame.com/1736bf69-b795-408a-8c09-6e413f57b0b1.png)\r\n\r\n\r\n好了，这样 Query 的示例就写完了。\r\n\r\nQuery 是一个可选的概念，如果游戏中数据的查询逻辑并不是很重的话，直接在 Controller 的表现逻辑里写就可以了，但是查询数据比较重，或者项目规模非常大的话，最好是用 Query 来承担查询的逻辑。\r\n\r\n\r\nCommand 一般负责数据的 增 删 改，而 Query 负责数据的 查。\r\n\r\n\r\n如果游戏需要从服务器同步数据，一般拉取服务器数据的请求可以写在 Query 中，而增删改服务器输的请求可以写在 Command 中。\r\n\r\n好了，关于 Query 就介绍到这里。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n# 10. 架构规范 与 推荐用法\r\n\r\nQFramework 架构提供了四个层级：\r\n* 表现层：IController\r\n* 系统层：ISystem\r\n* 数据层：IModel\r\n* 工具层：IUtility\r\n\r\n\r\n除了四个层级，还提供了 Command、Query、Event、BindableProperty 等概念和工具。\r\n\r\n这里有一套层级的规则，如下：\r\n\r\n* 表现层：ViewController 层。IController接口，负责接收输入和状态变化时的表现，一般情况下，MonoBehaviour 均为表现层\r\n  * 可以获取 System、Model\r\n  * 可以发送 Command、Query\r\n  * 可以监听 Event\r\n\r\nController 的接口定义如下：\r\n\r\n```csharp\r\n#region Controller\r\n\r\npublic interface IController : IBelongToArchitecture, ICanSendCommand, ICanGetSystem, ICanGetModel,ICanRegisterEvent, ICanSendQuery\r\n{\r\n}\r\n\r\n#endregion\r\n```\r\n\r\n* 系统层：System层。ISystem接口，帮助IController承担一部分逻辑，在多个表现层共享的逻辑，比如计时系统、商城系统、成就系统等\r\n  * 可以获取 System、Model\r\n  * 可以监听Event\r\n  *  可以发送Event\r\n\r\nSystem 的接口定义如下：\r\n\r\n```csharp\r\n#region System\r\n\r\npublic interface ISystem : IBelongToArchitecture, ICanSetArchitecture, ICanGetModel, ICanGetUtility,ICanRegisterEvent, ICanSendEvent, ICanGetSystem\r\n{\r\n    void Init();\r\n}\r\n```\r\n\r\n\r\n* 数据层：Model层。IModel接口，负责数据的定义、数据的增删查改方法的提供\r\n  * 可以获取 Utility\r\n  * 可以发送 Event\r\n\r\n\r\nModel 的接口定义如下：\r\n```csharp\r\npublic interface IModel : IBelongToArchitecture, ICanSetArchitecture, ICanGetUtility, ICanSendEvent\r\n{\r\n    void Init();\r\n}\r\n```\r\n\r\n\r\n* 工具层：Utility层。IUtility接口，负责提供基础设施，比如存储方法、序列化方法、网络连接方法、蓝牙方法、SDK、框架继承等。啥都干不了，可以集成第三方库，或者封装API\r\n\r\nUtility 的接口定义如下:\r\n```csharp\r\n#region Utility\r\n\r\npublic interface IUtility\r\n{\r\n}\r\n\r\n#endregion\r\n```\r\n\r\n\r\n* Command：命令，负责数据的增删改。\r\n  * 可以获取 System、Model\r\n  * 可以发送 Event、Command\r\n\r\nCommand 的接口定义如下：\r\n\r\n```csharp\r\npublic interface ICommand : IBelongToArchitecture, ICanSetArchitecture, ICanGetSystem, ICanGetModel, ICanGetUtility,ICanSendEvent, ICanSendCommand, ICanSendQuery\r\n{\r\n    void Execute();\r\n}\r\n```\r\n\r\n* Query：查询、负责数据的查询\r\n  * 可以获取 System、Model\r\n  * 可以发送 Query\r\n\r\n```csharp\r\npublic interface IQuery<TResult> : IBelongToArchitecture, ICanSetArchitecture, ICanGetModel, ICanGetSystem,ICanSendQuery\r\n{\r\n    TResult Do();\r\n}\r\n```\r\n\r\n\r\n* 通用规则：\r\n  - IController 更改 ISystem、IModel 的状态必须用Command\r\n  - ISystem、IModel 状态发生变更后通知 IController 必须用事件或BindableProperty\r\n  - IController可以获取ISystem、IModel对象来进行数据查询\r\n  - ICommand、IQuery 不能有状态,\r\n  - 上层可以直接获取下层，下层不能获取上层对象\r\n  - 下层向上层通信用事件\r\n  - 上层向下层通信用方法调用（只是做查询，状态变更用 Command），IController 的交互逻辑为特别情况，只能用 Command\r\n\r\n通用规则是理想状态下的一套规则，但是落实的实际项目，很有可能需要对以上规则做一些修改。\r\n\r\n修改的方式非常简单，比如我希望 IController 可以发送事件，那么我们只需要在 IController 接口上增加一个 ICanSendEvent 接口即可，代码如下:\r\n\r\n```csharp\r\n    #region Controller\r\n\r\n    public interface IController : IBelongToArchitecture, ICanSendCommand, ICanGetSystem, ICanGetModel,\r\n        ICanRegisterEvent, ICanSendQuery,\r\n        ICanSendEvent // +\r\n    {\r\n    }\r\n\r\n    #endregion\r\n```\r\n\r\n这样，就可以在 Controller 对象里，通过 this.SendEvent 来发送事件了。\r\n\r\n如果是打算先了解或学习 QFramework 架构，那么我推荐就先按照 QFramework 默认的架构规范来做练习项目。\r\n\r\n如果是打算马上用 QFramework 做项目，那么可以再保持原有开发习惯的基础上，一点点引入 QFramework 的概念，比如一开始用 BindableProperty 和 Architecture 来解决 Model 和数据更新的问题。\r\n\r\n再慢慢开始用 Command 来解决交互逻辑臃肿的问题，以此类推，直到能完全掌握全部概念，最终能修改和定制 QFramework.cs 源码。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n# 11. 光速实现 EditorCounterApp 和 给主程看的开发模式\r\n\r\n首先，我们来实现一个好玩的事情，就是在前边已经实现好的 CounterApp 的基础上，光速实现一个编辑器版本的 CounterApp。\r\n\r\n代码非常简单，如下:\r\n\r\n```csharp\r\n#if UNITY_EDITOR\r\nusing System;\r\nusing UnityEditor;\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class EditorCounterAppWindow : EditorWindow,IController\r\n    {\r\n\r\n        [MenuItem(\"QFramework/Example/EditorCounterAppWindow\")]\r\n        static void Open()\r\n        {\r\n            GetWindow<EditorCounterAppWindow>().Show();\r\n        }\r\n        \r\n        private ICounterAppModel mCounterAppModel;\r\n\r\n        private void OnEnable()\r\n        {\r\n            mCounterAppModel = this.GetModel<ICounterAppModel>();\r\n        }\r\n\r\n        private void OnDisable()\r\n        {\r\n            mCounterAppModel = null;\r\n        }\r\n\r\n        private void OnGUI()\r\n        {\r\n            if (GUILayout.Button(\"+\"))\r\n            {\r\n                this.SendCommand<IncreaseCountCommand>();\r\n            }\r\n            \r\n            GUILayout.Label(mCounterAppModel.Count.Value.ToString());\r\n\r\n\r\n            if (GUILayout.Button(\"-\"))\r\n            {\r\n                this.SendCommand<DecreaseCountCommand>();\r\n            }\r\n        }\r\n\r\n        public IArchitecture GetArchitecture()\r\n        {\r\n            return CounterApp.Interface;\r\n        }\r\n    }\r\n}\r\n\r\n#endif\r\n```\r\n\r\n代码量不多，运行结果如下：\r\n\r\n![image.png](https://file.liangxiegame.com/3b685522-d4ef-4648-ba3d-5726aaee7b62.png)\r\n\r\n\r\n这样就非常快速地实现了 CounterApp 的 编辑器版本。\r\n\r\n因为 QFramework 写的 App ，底层三层是可以复用的。\r\n\r\n如图所示：\r\n\r\n![image.png](https://file.liangxiegame.com/fc803d9e-2868-4b5b-af29-d39dd9e37891.png)\r\n\r\n底层的三层 与 表现层 的通信方式有 Command、回调/事件、方法/Query。\r\n\r\n\r\n我们可以把表现层类比成网页前端，而底层三层类比成服务器。\r\n\r\n那么 Command、回调/事件、方法/Query 其实就是类似于 HTTP 或者 TCP 的接口或协议。\r\n\r\n而接口或者协议只要做好约定，那么前端就不需要关心服务端的具体实现了，而服务端也不需要关心前端的具体实现。\r\n\r\n这就做到了在分工时，将表现层和底层三层的工作分别给不同的人来负责。\r\n\r\n而笔者曾经做过一个这样的项目。\r\n\r\n在项目中笔者负责将 底层三层实现好，然后和服务器把数据和接口调好，数据的显示部分笔者用的一个快速写界面的方案，比如 xmllayout 或者 delight，这种方案写界面非常快，可以用来实现系统原型。\r\n\r\n然后等数据和接口调好，系统原型实现好后，把界面、做场景流程、做表现的工作都分配给了初学者的同事们，同事们只要看实现的系统原型，就知道调用哪些 Command/Query、监听哪些事件、或调用哪些方法，这样就可以做好分工协作了。\r\n\r\n用一张图表示如下：\r\n\r\n![image.png](https://file.liangxiegame.com/430968f9-68a8-470a-8450-b70316a31419.png)\r\n\r\n\r\n当然这只是其中一种的项目开发模式。\r\n\r\n随着时间，初学者同事们用熟了这套架构之后，渐渐地也能自己写底层三层了，于是笔者就慢慢把底层的工作量也分出去了，自己就没啥事干了。\r\n\r\n好了，这就是一次笔者曾经使用的一种开发模式的分享，而具体自己的开发模式，需要根据实际情况来制定，最简单的方式就是先按照原有的习惯的开发模式，然后逐渐掌握这套架构，掌握了之后慢慢改进之前的开发模式。\r\n\r\n这篇就介绍到这里。\r\n\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n\r\n\r\n# 12. 纸上设计\r\n由于 QFramework 支持 MVC、分层 和 CQRS，再加上提供了使用规范，那么 QFramework 就可以达到高度的标准化，达到高度的标准化那么就有了做一件事情的条件，就是纸上设计。\r\n\r\n假如我们想实现一个主角吃金币，金币数量增加的功能，则可以按照如下顺序设计图。\r\n\r\n\r\n首先需要确定数据结构。\r\n\r\n我们可以用类图来确定，也可以用更简单的方式绘制。\r\n\r\n![image.png](https://file.liangxiegame.com/fb76cf87-9758-4289-8b6b-29621beba7c4.png)\r\n\r\n\r\n\r\n然后，我们需要确定表现层如何显示金币。\r\n\r\n![image.png](https://file.liangxiegame.com/6f4dcfce-75a6-4e5d-bfc0-edc5f2e20f16.png)\r\n\r\n接着，我们要开始设计 Command。\r\n\r\n![image.png](https://file.liangxiegame.com/ed1b486b-4ea7-45e1-8af2-6c238952c83e.png)\r\n\r\n然后，可以把如何触发，和如何更新的图都画好。\r\n\r\n![image.png](https://file.liangxiegame.com/504fc46e-351a-4b56-874e-bbb9d2879642.png)\r\n\r\n这样一个吃金币的功能思路就设计好了。\r\n\r\n当然吃金币这个例子很简单。\r\n\r\n不过笔者建议，如果 QFramework 架构用得不是很熟悉的时候，就用这种小功能来做一些纸上设计比较合适。\r\n\r\n而当 QFramework 架构用得很熟的时候，可以在纸上设计一些更复杂的功能。\r\n\r\n比如技能系统、强化道具系统、背包系统、任务系统等等。\r\n\r\n\r\n我们看一下第一篇中的一张图。\r\n\r\n![](https://file.liangxiegame.com/6bf42306-0b2a-4417-bbcf-354af0132596.png)\r\n\r\n这张图，其实就是一张纸上设计图，即 当主角打死敌人后 触发分数变更、触发成就达成 的功能。\r\n\r\n这种图加上吃金币图，是 QFramework 纸上设计中的 功能图。\r\n\r\n\r\n除了功能图 ，还有 QFrameowrk 纸上设计的 架构图。\r\n\r\n架构图的示例如下所示：\r\n\r\n![image.png](https://file.liangxiegame.com/c1584a3b-f8be-49a1-897a-9f1b684864bf.png)\r\n\r\n\r\n架构图只是罗列了每个模块都在哪个层级，并没有展示具体如何交互。\r\n\r\n而功能则是展示了一个功能具体的逻辑控制流向。\r\n\r\n在一般情况下，架构图 和 功能图 都不是必须的。\r\n\r\n功能图在早期更多是帮助 QFramework 不熟悉的人梳理思路用的。\r\n\r\n但是也有开发人员不在电脑旁的时候，而此时项目也比较紧，这个时候 纸上设计 就会排上用场了。\r\n\r\n开发人员完全可以纸上把整个项目的功能思路都实现出来。\r\n\r\n还有一种用法就是，开发人员拿到需求之后，集合全部开发人员开一次会议，在会议中边研读策划文档边和大家一起用纸上设计把整个项目的功能思路都实现出来，然后再把编码和具体实现的工作量分配给每个人，这也是一种用法。\r\n\r\n总之 纸上设计 是非常有用的一个方法。\r\n\r\n可能有人会问，纸上设计需要遵循什么格式吗？\r\n\r\n答案是没有的。\r\n\r\n如果习惯用 UML 类图，那就用 UML 类图绘制，如果习惯用方块、圆圈、棱角那就用方块、圆圈、棱角，如果习惯用纸笔，那就用纸笔。\r\n\r\n总之怎么快怎么方便就怎么用。\r\n\r\n\r\n纸上设计 除了方便功能实现，也方便在团队内沟通，比如一位开发人员如果对实现一个功能没有思路，那么就可以问主程或者 QFramework 高手，让高手用一张纸来梳理思路，这样开发人员拿到这张纸就可以去实现了。还可以每次让开发人员先在纸上设计好，然后把这张纸拿给主程或者 QFramework 高手，主程或 QFramework 高手验证完才可以进行编码实现，这样用也是可以的。\r\n\r\n好了关于纸上设计的入门和一些拓展用法就介绍到这里。\r\n\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 13. Architecture 的好处\r\n\r\n\r\n不管是 System、Model 还是 Utility，都会注册到 Architecture 中。\r\n\r\n伪代码如下:\r\n```csharp\r\nnamespace QFramework.PointGame\r\n{\r\n    public class PointGame : Architecture<PointGame>\r\n    {\r\n        protected override void Init()\r\n        {\r\n            RegisterSystem<IScoreSystem>(new ScoreSystem());\r\n            RegisterSystem<ICountDownSystem>(new CountDownSystem());\r\n            RegisterSystem<IAchievementSystem>(new AchievementSystem());\r\n\r\n            RegisterModel<IGameModel>(new GameModel());\r\n\r\n            RegisterUtility<IStorage>(new PlayerPrefsStorage());\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n大家可能会问，如果一个项目有非常多的 System、Model、Utility 全部注册到 Architecture，这样 Architecture 的代码量就变多了，会不会让项目变得难以管理？\r\n\r\n答案是不会，Architecture 注册的模块越多，这套架构发挥的作用就越大。\r\n\r\n因为 Architecture 本身就能很好地展示项目的结构，可以把 Architecture 本身当做一个架构图。\r\n\r\n比如以上伪代码对应的架构图如下：\r\n\r\n![image.png](https://file.liangxiegame.com/cc294f03-4171-4cb3-b774-b487688e51fb.png)\r\n非常清晰。\r\n\r\n而伪代码中只有 5 个注册模块，是非常少见的，一般情况下，项目都会注册十几个甚至几十个模块，也有上百个模块的时候。\r\n\r\n而如果这些模块没有用 QFramework 而全部使用单例实现的话，项目就会变得很混乱。\r\n\r\n而使用了 QFramework，我们就可以在 Architecture 中统一集中管理这些模块，是方便项目管理的。\r\n\r\n这就是使用 Architecture 的优势。\r\n\r\n这里，再贴出一下笔者曾经写的项目的 Architecture，代码如下:\r\n\r\n```csharp\r\nusing IndieGame.Models;\r\nusing IndieGame.Utility;\r\nusing QFramework;\r\nusing UnityEngine;\r\nusing UTGM;\r\n\r\nnamespace IndieGame\r\n{\r\n    public class LiangxiesGame : Architecture<LiangxiesGame>\r\n    {\r\n        public static bool IsTestMode = true;\r\n\r\n        public static void SetTestMode(bool testMode)\r\n        {\r\n            IsTestMode = testMode;\r\n        }\r\n\r\n        protected override void Init()\r\n        {\r\n            RegisterSystem<ISaveSystem>(new SaveSystem());\r\n            RegisterSystem<IInputSystem>(new InputSystem());\r\n            RegisterSystem<ILevelSystem>(new LevelSystem());\r\n            RegisterSystem<IBookSystem>(new BookSystem());\r\n            RegisterSystem<IMapSystem>(new MapSystem());\r\n            RegisterSystem<IGameTimeSystem>(new GameTimeSystem());\r\n            RegisterSystem<IRankSystem>(new RankSystem());\r\n            RegisterSystem<IGameSystem>(new GameSystem());\r\n            RegisterSystem<ILuaSystem>(new LuaSystem());\r\n            RegisterSystem<IAchievementSystem>(new AchievementSystem());\r\n            RegisterSystem<IEnemyRecycleSystem>(new EnemyRecycleSystem());\r\n            RegisterSystem<IUISystem>(new UISystem());\r\n            RegisterSystem<IHurtSystem>(new HurtSystem());\r\n            RegisterSystem<ILevelUpSystem>(new LevelUpSystem());\r\n            RegisterSystem<ILevelConfigSystem>(new LevelConfigSystem());\r\n        \r\n            RegisterModel<ICoinModel>(new CoinModel());\r\n            RegisterModel<ISettingModel>(new SettingModel());\r\n            RegisterModel<IBookModel>(new BookModel());\r\n            RegisterModel<IMechanismModel>(new MechanismModel());\r\n            RegisterModel<IPlayerModel>(new PlayerModel());\r\n            \r\n            RegisterUtility<IStorage>(new EasySaveStorage());\r\n\r\n            Application.persistentDataPath.CreateDirIfNotExists();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nSystem 层有什么、Model 层有什么、Utility 层有什么，一目了然。\r\n\r\n好了，这篇就到这里。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n# 14. Command 拦截\r\n\r\nQFramework 提供了拦截 Command 的 API。\r\n\r\n我们尝试在 CounterApp 中实现一个 Command 日志。\r\n\r\n代码很简单，如下:\r\n\r\n```csharp\r\npublic class CounterApp : Architecture<CounterApp>\r\n{\r\n    protected override void Init()\r\n    {\r\n        // 注册 System \r\n        this.RegisterSystem<IAchievementSystem>(new AchievementSystem()); \r\n             \r\n        // 注册 Model\r\n        this.RegisterModel<ICounterAppModel>(new CounterAppModel());\r\n            \r\n        // 注册存储工具的对象\r\n        this.RegisterUtility<IStorage>(new Storage());\r\n    }\r\n\r\n    protected override void ExecuteCommand(ICommand command)\r\n    {\r\n        Debug.Log(\"Before \" + command.GetType().Name + \"Execute\");\r\n        base.ExecuteCommand(command);\r\n        Debug.Log(\"After \" + command.GetType().Name + \"Execute\");\r\n    }\r\n}\r\n```\r\n\r\n只需要在 Architecture 中覆写 ExecuteCommand 即可。\r\n\r\n运行之后，笔者随意点击了几次按钮，结果如下:\r\n\r\n![image.png](https://file.liangxiegame.com/96bdc2f4-222d-4e91-a10e-dc2128e50fb4.png)\r\n\r\n这样就实现了一个非常简单的 Command 日志功能。\r\n\r\n\r\n## 有了 Command 拦截有什么用？\r\n\r\n有了 Command 拦截功能，我们可以做非常多的事情，比如：\r\n* Command 日志可以用来方便调试\r\n* 可以实现 Command 中间件模式 可以写各种各样额度 Command 中间件，比如 Command 日志中间件\r\n* 可以方便你先撤销功能\r\n* 可以用 Command 做自动化测试\r\n* 等等\r\n\r\n好了这篇就介绍到这里。\r\n\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n# 15. 内置工具：TypeEventSystem\r\n\r\nQFramework 除了提供了一套架构之外，QFramework 还提供三个可以脱离架构使用的工具 TypeEventSystem、EasyEvent、BindableProperty、IOCContainer。\r\n\r\n这些工具并不是有意提供，而是 QFramework 的架构在设计之初是通过这三个工具组合使用而成的。\r\n\r\n在这一篇，我们来学习 TypeEventSystem 的使用。\r\n\r\n## 基本使用\r\n\r\n```csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class TypeEventSystemBasicExample : MonoBehaviour\r\n    {\r\n        public struct TestEventA\r\n        {\r\n            public int Age;\r\n        }\r\n\r\n        private void Start()\r\n        {\r\n            TypeEventSystem.Global.Register<TestEventA>(e =>\r\n            {\r\n                Debug.Log(e.Age);\r\n            }).UnRegisterWhenGameObjectDestroyed(gameObject);\r\n        }\r\n        \r\n        private void Update()\r\n        {\r\n            // 鼠标左键点击\r\n            if (Input.GetMouseButtonDown(0))\r\n            {\r\n                TypeEventSystem.Global.Send(new TestEventA()\r\n                {\r\n                    Age = 18\r\n                });\r\n            }\r\n\r\n            // 鼠标右键点击\r\n            if (Input.GetMouseButtonDown(1))\r\n            {\r\n                TypeEventSystem.Global.Send<TestEventA>();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// 输出结果\r\n// 点击鼠标左键，则输出:\r\n// 18\r\n// 点击鼠标右键，则输出:\r\n// 0\r\n```\r\n\r\n这就是 TypeEventSystem 的最基本用法。\r\n\r\n## 事件继承支持\r\n除了基本用法，TypeEventSystem 的事件还支持继承关系。\r\n\r\n示例代码如下:\r\n```csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class TypeEventSystemInheritEventExample : MonoBehaviour\r\n    {\r\n        public interface IEventA\r\n        {\r\n            \r\n        }\r\n        \r\n        public struct EventB : IEventA\r\n        {\r\n            \r\n        }\r\n\r\n        private void Start()\r\n        {\r\n            TypeEventSystem.Global.Register<IEventA>(e =>\r\n            {\r\n                Debug.Log(e.GetType().Name);\r\n            }).UnRegisterWhenGameObjectDestroyed(gameObject);\r\n        }\r\n\r\n        private void Update()\r\n        {\r\n            if (Input.GetMouseButtonDown(0))\r\n            {\r\n                TypeEventSystem.Global.Send<IEventA>(new EventB());\r\n                \r\n                // 无效\r\n                TypeEventSystem.Global.Send<EventB>();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// 输出结果:\r\n// 当按下鼠标左键时，输出:\r\n// EventB\r\n```\r\n\r\n代码不难。\r\n\r\n## TypeEventSystem 手动注销\r\n\r\n如果想控制 TypeEventSystem 的注销，而不是自动注销也很简单，代码如下:\r\n\r\n```csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class TypeEventSystemUnRegisterExample : MonoBehaviour\r\n    {\r\n\r\n        public struct EventA\r\n        {\r\n            \r\n        }\r\n        \r\n        private void Start()\r\n        {\r\n            TypeEventSystem.Global.Register<EventA>(OnEventA);\r\n        }\r\n\r\n        void OnEventA(EventA e)\r\n        {\r\n            \r\n        }\r\n\r\n        private void OnDestroy()\r\n        {\r\n            TypeEventSystem.Global.UnRegister<EventA>(OnEventA);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n代码也很简单。\r\n\r\n## 接口事件\r\n\r\nTypeEventSystem 还支持接口事件模式，示例代码如下:\r\n\r\n```csharp\r\nusing System;\r\nusing System.Collections;\r\nusing System.Collections.Generic;\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public struct InterfaceEventA\r\n    {\r\n            \r\n    }\r\n\r\n    public struct InterfaceEventB\r\n    {\r\n        \r\n    }\r\n\r\n    public class InterfaceEventModeExample : MonoBehaviour\r\n        , IOnEvent<InterfaceEventA>\r\n        , IOnEvent<InterfaceEventB>\r\n    {\r\n        public void OnEvent(InterfaceEventA e)\r\n        {\r\n            Debug.Log(e.GetType().Name);\r\n        }\r\n        \r\n        public void OnEvent(InterfaceEventB e)\r\n        {\r\n            Debug.Log(e.GetType().Name);\r\n        }\r\n\r\n        private void Start()\r\n        {\r\n            this.RegisterEvent<InterfaceEventA>()\r\n                .UnRegisterWhenGameObjectDestroyed(gameObject);\r\n\r\n            this.RegisterEvent<InterfaceEventB>();\r\n        }\r\n\r\n        private void OnDestroy()\r\n        {\r\n            this.UnRegisterEvent<InterfaceEventB>();\r\n        }\r\n\r\n        private void Update()\r\n        {\r\n            if (Input.GetMouseButtonDown(0))\r\n            {\r\n                TypeEventSystem.Global.Send<InterfaceEventA>();\r\n                TypeEventSystem.Global.Send<InterfaceEventB>();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// 输出结果\r\n// 当按下鼠标左键时，输出:\r\n// InterfaceEventA\r\n// InterfaceEventB\r\n```\r\n\r\n代码很简单。\r\n\r\n同样接口事件也支持事件之间的继承。\r\n\r\n接口事件拥有更好的约束，只要完成实现接口，就可以通过 IDE 的代码生成少写很多代码，其灵感受 CorgiEngine、TopDownEngine 启发。\r\n\r\n## 非 MonoBehavior 脚本如何自动销毁\r\n\r\n```csharp\r\npublic class NoneMonoScript : IUnRegisterList\r\n{\r\n    public List<IUnRegister> UnregisterList { get; } = new List<IUnRegister>();\r\n\r\n\r\n    void Start()\r\n    {\r\n        TypeEventSystem.Global.Register<EasyEventExample.EventA>(a =>\r\n        {\r\n                    \r\n        }).AddToUnregisterList(this);\r\n    }\r\n\r\n    void OnDestroy()\r\n    {\r\n        this.UnRegisterAll();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n## 小结\r\n如果想手动注销，必须要创建一个用于接收事件的方法。\r\n\r\n而用自动注销则直接用委托即可。\r\n\r\n这两个各有优劣，按需使用。\r\n\r\n另外，事件的定义最好使用 struct，因为 struct 的 gc 更少，可以获得更好的性能。\r\n\r\n接口事件拥有更好的约束，也可以通过 IDE 的代码生成来提高开发效率。\r\n\r\n总之 TypeEventSystem 是一个非常强大的事件工具。\r\n\r\n另外再补充一下，如果想要进行自动销毁，还有一个更简单的方法，就是使用 UnRegisterWhenCurrentSceneUnloaded 方式注销，示例代码如下:\r\n```csharp\r\nTypeEventSystem.Global.Register<EasyEventExample.EventA>(a =>\r\n{\r\n                    \r\n}).UnRegisterWhenCurrentSceneUnloaded();\r\n```\r\n\r\n这种可以不用传任何的 GameObject，只不过加载新的场景时自动注销。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n# 16. 内置工具：EasyEvent\r\n\r\nTypeEventSystem 是基于 EasyEvent 实现的。\r\n\r\nEasyEvent 也是一个可以脱离架构使用的工具。\r\n\r\n这里我们来学习一下基本用法。\r\n\r\n## 基本使用\r\n代码如下:\r\n\r\n```csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class EasyEventExample : MonoBehaviour\r\n    {\r\n        private EasyEvent mOnMouseLeftClickEvent = new EasyEvent();\r\n        \r\n        private EasyEvent<int> mOnValueChanged = new EasyEvent<int>();\r\n        \r\n        public class EventA : EasyEvent<int,int> { }\r\n\r\n        private EventA mEventA = new EventA();\r\n\r\n        private void Start()\r\n        {\r\n            mOnMouseLeftClickEvent.Register(() =>\r\n            {\r\n                Debug.Log(\"鼠标左键点击\");\r\n            }).UnRegisterWhenGameObjectDestroyed(gameObject);\r\n\r\n            mOnValueChanged.Register(value =>\r\n            {\r\n\r\n                Debug.Log($\"值变更:{value}\");\r\n            }).UnRegisterWhenGameObjectDestroyed(gameObject);\r\n\r\n\r\n            mEventA.Register((a, b) =>\r\n            {\r\n                Debug.Log($\"自定义事件:{a} {b}\");\r\n            }).UnRegisterWhenGameObjectDestroyed(gameObject);\r\n        }\r\n\r\n        private void Update()\r\n        {\r\n            if (Input.GetMouseButtonDown(0))\r\n            {\r\n                mOnMouseLeftClickEvent.Trigger();\r\n            }\r\n            \r\n            if (Input.GetMouseButtonDown(1))\r\n            {\r\n                mOnValueChanged.Trigger(10);\r\n            }\r\n\r\n            // 鼠标中键\r\n            if (Input.GetMouseButtonDown(2))\r\n            {\r\n                mEventA.Trigger(1,2);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// 输出结果：\r\n// 按鼠标左键时，输出:\r\n// 鼠标左键点击\r\n// 按鼠标右键时，输出:\r\n// 值变更:10\r\n// 按鼠标中键时，输出:\r\n// 自定义事件:1 2\r\n```\r\n\r\n基本使用非常简单。\r\n\r\nEasyEvent 最多支持三个泛型。\r\n\r\n## EasyEvent 的优势\r\nEasyEvent 是 C# 委托和事件的替代。\r\n\r\nEasyEvent 相比 C# 委托和事件，优势是可以自动注销。\r\n\r\n相比 TypeEventSystem，优势是更轻量，大多数情况下不用声明事件类，而且性能更好（接近 C# 委托）。\r\n\r\n缺点则是其携带的参数没有名字，需要自己定义名字。\r\n\r\n在设计一些通用系统的时候，EasyEvent 会派上用场，比如背包系统、对话系统，TypeEventSystem 是一个非常好的例子。\r\n\r\n在一个项目早期做原型验证时，EasyEvent 也会起非常大的作用，QFramework 架构中的事件，其实写起来有点繁琐，而在项目早期快速迭代原型是重点，此时用 EasyEvent 可以获得更快的开发效率，而使用 QFramework 架构中的事件在项目规模更大的时候会发挥很大的作用，它更方便协作更容易维护，也更容易标准化。\r\n\r\n好了，关于 EasyEvent 的介绍就到这里。\r\n\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n# 17. 内置工具：BindableProperty\r\n\r\n在此篇介绍 BindableProperty。\r\n\r\nBindableProperty 提供 数据 + 数据变更事件 的一个对象。\r\n\r\n## 基本使用\r\n\r\n```csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class BindablePropertyExample : MonoBehaviour\r\n    {\r\n        private BindableProperty<int> mSomeValue = new BindableProperty<int>(0);\r\n\r\n        private BindableProperty<string> mName = new BindableProperty<string>(\"QFramework\");\r\n        \r\n        void Start()\r\n        {\r\n            mSomeValue.Register(newValue =>\r\n            {\r\n                Debug.Log(newValue);\r\n            }).UnRegisterWhenGameObjectDestroyed(gameObject);\r\n\r\n            mName.RegisterWithInitValue(newName =>\r\n            {\r\n                Debug.Log(mName);\r\n            }).UnRegisterWhenGameObjectDestroyed(gameObject);\r\n        }\r\n        \r\n        void Update()\r\n        {\r\n\r\n            if (Input.GetMouseButtonDown(0))\r\n            {\r\n                mSomeValue.Value++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// 输出结果\r\n// QFramework\r\n// 按下鼠标左键,输出:\r\n// 1\r\n// 按下鼠标左键,输出:\r\n// 2\r\n```\r\n\r\n非常简单。\r\n\r\n\r\n关于 BindableProperty，在之前写 CounterApp 的时候有介绍过，所以这篇就介绍到这里。\r\n\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n# 18. 内置工具：IOCContainer\r\n\r\nQFramework 架构的模块注册与获取是通过 IOCContainer 实现的。\r\n\r\nIOC 的意思是控制反转，即控制反转容器。\r\n\r\n其技术的本质很简单，本质就是一个字典，Key 是 Type，Value 是 Object，即：Dictionary<Type,object>。\r\n\r\nQFramework 架构中的 IOCContainer 是一个非常简易版本的控制翻转容器，仅支持了注册对象为单例的模式。\r\n\r\n一般情况下，其他的控制反转容器会有各种各样的对象注册模式，有的甚至会内置对象池和对象工厂，比如 Zenject。\r\n\r\n不过，我们先不用理会那些，如果先上手使用了最简易的版本，其他版本会更容易上手。\r\n\r\n我们看下 IOCContainer 的基本使用。\r\n\r\n代码如下:\r\n\r\n```csharp\r\nusing System;\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class IOCContainerExample : MonoBehaviour\r\n    {\r\n        \r\n        public class SomeService\r\n        {\r\n            public void Say()\r\n            {\r\n                Debug.Log(\"SomeService Say Hi\");\r\n            }\r\n        }\r\n        \r\n        \r\n        public interface INetworkService\r\n        {\r\n            void Connect();\r\n        }\r\n        \r\n        public class NetworkService : INetworkService\r\n        {\r\n            public void Connect()\r\n            {\r\n                Debug.Log(\"NetworkService Connect Succeed\");\r\n            }\r\n        }\r\n\r\n        private void Start()\r\n        {\r\n            var container = new IOCContainer();\r\n            \r\n            container.Register(new SomeService());\r\n            \r\n            container.Register<INetworkService>(new NetworkService());\r\n            \r\n            \r\n            container.Get<SomeService>().Say();\r\n            container.Get<INetworkService>().Connect();\r\n        }\r\n    }\r\n}\r\n\r\n// 输出结果:\r\n// SomeService Say Hi\r\n// NetworkService Connect Succeed\r\n```\r\n\r\n非常简单。\r\n\r\n但是对于很多初学者，IOCContainer 感觉不知道怎么用，也无法理解。\r\n\r\n这里给一个简单的说法，使用 IOCContainer 更容易设计出符合依赖倒置原则的模块。\r\n\r\n而 QFramework 架构的用接口设计模块的支持就是通过 IOCContainer 支持的，同样使用 IOCContainer 也更容易设计出分层的架构。\r\n\r\n好了，关于 IOCContainer 就介绍到这里。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n# 19. 心中有架构\r\n\r\nQFramework.cs 提供了 MVC、分层、CQRS、事件驱动、数据驱动等工具，除了这些工具，QFramework.cs 还提供了架构使用规范。\r\n\r\n而当使用 QFramework 熟练到一定的程度之后，就可以达到心中有架构的境界。\r\n\r\n如果达到这个境界，你就早已不是当年的你了（开玩笑）。\r\n\r\n心中有架构的境界，具体是指可以不依赖 QFramework.cs 就可以再项目中实践 QFramework.cs 架构。\r\n\r\n具体的示例如下:\r\n\r\n```csharp\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class ArchitectureInHeartExample : MonoBehaviour\r\n    {\r\n\r\n        #region Framework\r\n\r\n        public interface ICommand\r\n        {\r\n            void Execute();\r\n        }\r\n\r\n        public class BindableProperty<T>\r\n        {\r\n            private T mValue = default;\r\n\r\n            public T Value\r\n            {\r\n                get => mValue;\r\n                set\r\n                {\r\n                    if (mValue != null && mValue.Equals(value)) return;\r\n                    mValue = value;\r\n                    OnValueChanged?.Invoke(mValue);\r\n                }\r\n            }\r\n\r\n            public event Action<T> OnValueChanged = _ => { };\r\n        }\r\n\r\n        #endregion\r\n\r\n\r\n        #region 定义 Model\r\n\r\n        public static class CounterModel\r\n        {\r\n            public static BindableProperty<int> Counter = new BindableProperty<int>()\r\n            {\r\n                Value = 0\r\n            };\r\n        }\r\n        \r\n        #endregion\r\n\r\n        #region 定义 Command\r\n        public struct IncreaseCountCommand : ICommand\r\n        {\r\n            public void Execute()\r\n            {\r\n                CounterModel.Counter.Value++;\r\n            }\r\n        }\r\n        \r\n        public struct DecreaseCountCommand : ICommand\r\n        {\r\n            public void Execute()\r\n            {\r\n                CounterModel.Counter.Value--;\r\n            }\r\n        }\r\n        #endregion\r\n\r\n\r\n        private void OnGUI()\r\n        {\r\n            if (GUILayout.Button(\"+\"))\r\n            {\r\n                new IncreaseCountCommand().Execute();\r\n            }\r\n\r\n            GUILayout.Label(CounterModel.Counter.Value.ToString());\r\n\r\n            if (GUILayout.Button(\"-\"))\r\n            {\r\n                new DecreaseCountCommand().Execute();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n上图是一个计数器应用的实现。\r\n\r\n在这个实现里，没有使用 QFramework.cs 里的任何内容，但是也写出来了符合 QFramework.cs 架构规范的计数器应用实现。\r\n\r\n当大家使用 QFramework.cs 到一定程度之后，在未来不使用 QFramework.cs ，也可以按照 QFramework.cs 架构规范来写项目，而到此时，对于大家来说有没有  QFramework.cs 就无所谓了，因为 QFramework.cs 的架构规范已经刻在大家的骨子里了。\r\n\r\n\r\n\r\n当大家熟练使用 QFramework.cs 之后，有一天如果大家去研究 网页前端、服务器、App 开发，会发现它们的很多框架与 QFramework.cs 架构有共通之处，甚至说，通过 QFramework.cs 中积累的开发经验可以直接照搬到其他领域的开发中。\r\n\r\n这是因为 QFramework.cs 最初的设计目的，就是为了糅合和简化大量其他领域的架构概念，比如 React 中的 Redux（Flux）、.Net Core 开发中的领域驱动设计、CQRS、仓储模式等、App 开发中的 MVC、MVP、MVVM 等。\r\n\r\n我们简单看一下这些图，大家就清楚了。\r\n\r\n首先是前端 React 中的 Redux 的工作流程，如下：\r\n![bg2016091802.jpg](https://file.liangxiegame.com/8b854e1e-4772-4a79-b595-c0ded004a569.png)\r\n\r\n\r\n\r\n\r\n其中 React Components 对应的是 QFramework.cs  中的 Controller。\r\n\r\nAction + Reducers 对应的是 QFramework.cs 中的 Command\r\n\r\nStore 对应的是 QFramework.cs 中的 Model。\r\n\r\n\r\n接着是领域驱动设计：\r\n\r\n![image.png](https://file.liangxiegame.com/f966558b-c616-46cd-9eee-4ba56de64b2c.png)\r\n\r\n\r\n其中 Interface 对应的是 IController。\r\n\r\nApplication 对应的是 ISystem。\r\n\r\nDomain 对应的是 Model。\r\n\r\nInfrustracture 对应的是 Utility + 一部分 Model。\r\n\r\n\r\n接着看下 CQRS，CQRS 一般是领域驱动设计包含的模式，如下图所示:\r\n\r\n![v2-da8a89f95e09bb518ad8c770b1413e5e_720w.jpg](https://file.liangxiegame.com/5f45fb20-537e-4574-80ac-c8d6a2d7921e.png)\r\n\r\n\r\n\r\n其中 User Interface 对应的是 IController。\r\n\r\nCommand 和 Query 对应的是 Command 和 Query。\r\n\r\nDomain Model 和 Data 对应的是 Model\r\n\r\nEvent 对应的是 Event。\r\n\r\n非常接近。\r\n\r\n接着看下仓储模式:\r\n\r\n![20150922190750314.png](https://file.liangxiegame.com/5bf7ddeb-702d-4e05-aa4a-b3751a7547eb.png)\r\n\r\n\r\n仓储模式没有具体的图，而此图是从网上随便找的，很清晰地表达出了仓储模式的结构。\r\n\r\n其中 IRepository 对应的是 IModel。\r\n\r\nRepository 对应的是 AbstractModel。\r\n\r\nIBookRepository 对应的是 ICounterModel。\r\n\r\nBookRespository 对应的是 CounterModel。\r\n\r\n使用 ICounterModel 和 CounterModel 举例不是很合适，因为 CounterModel 只有一个 Counter 数据。\r\n\r\n更适合的举例是 IStudentModel，StudentModel ，因为 StudentModel 会维护一个 Student 的 List。\r\n\r\n仓储模式的优势在于，可以让上层（System、Controller）专注于数据的增删改查功能，而不是具体的增删改查实现，因为在服务器端，数据都是存储在数据库中的，数据库有很多类型，比如 MySQL、MongoDB 等，而在服务器端开发时，很有可能在开发阶段用 SQLite 或者 MongoDB，而在生产环境用的是 MySQL、PostgreSQL，所以在静态类型语言中，仓储模式会和 ORM 一起配合，让开发者专注在数据的增删改查和数据之间的关联上，而不是具体的查询语句，这样能提高开发效率。\r\n\r\n\r\n最后，MVC、MVP、MVVM 这里就不介绍了，其中 MVP 和 MVVM 的实现会用 BindableProperty，有的会用反射的形式实现。\r\n\r\n而 QFramework.cs 中的 BindableProperty 和 MVC 分层，则是来自这些架构中。\r\n\r\n好了，此篇的内容就说完了。\r\n\r\n大家可能会问，为什么 QFramework.cs 要糅合这些架构概念？\r\n\r\n因为在 2019 年左右，笔者刚好在业余时间研究了一年 React 开发，用 React 前端开发做了一些 SideProject，服务器则是用的 .Net Core，再加上之前笔者也有做 iOS、Android 等开发经验。而在当时，笔者突然发现这些领域的架构概念很多都是相通的，可能在这个领域叫这个，在另一个领域只是换了一个名字而已，于是就产生了可不可以把这些架构概念都糅合在一起，然后去掉繁琐的保留有用的部分，于是就开始了 QFramework.cs 的设计。\r\n\r\n杂糅和简化这些概念的  QFramework.cs 有什么好处呢？\r\n\r\n首先 QFramework.cs 是非常容易上手的架构，因为其中的 MVC 三层概念让大家会觉得非常亲切，所以上手成本并不是很高。\r\n\r\n其次 QFramework.cs 是一个能提高大家技术水平的架构，在架构方面，天花板是领域驱动设计的实现，是架构师必研究的内容，如果 QFramework.cs 用熟悉了，再去研究领域驱动设计会容易得多，而领域驱动设计不管在项目中有没有使用，只要去研究就会对架构水平有很大的提升，而 QFramework.cs 算是简化版本的领域驱动设计的实现。\r\n\r\n然后 QFramework.cs 可以用来做系统设计、可以做游戏、做项目、做插件都是很适合的，因为笔者自己的很多项目、插件、服务器都是用 QFramework.cs 架构来做的。\r\n\r\n最后 QFramework.cs 本身是很强大的，易上手、简单、代码精简、可维护性强、开发效率高、可定制性强、扩展性强，因为 QFramework.cs 吸取了大量其他领域架构的优点，同时也经历过大量项目的打磨而成，总体的代码精简到了 900 行左右。\r\n\r\n\r\n如果大家想在更进一步强化这些概念，最好的方式就是尝试去学习其他领域的架构，比如:\r\n* React 与  RedU型\r\n* Java/.Net Core 与 DDD 实现，CQRS、仓储模式\r\n* App 开发中的 MVC、MVP、MVVM\r\n\r\n好了，这篇内容就说到这里。\r\n\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 20. QFramework.cs 的更多内容\r\n\r\n终于把想介绍的内容都讲完了。\r\n\r\n如果想进一步了解和学习 QFramework.cs 可以看如下内容。\r\n\r\n## 使用 QFramework.cs 的案例与项目\r\n\r\n更多的案例可以到 QFramework github 主页查看。\r\n\r\n地址:\r\n* github: https://github.com/liangxiegame/QFramework\r\n* gitee: https://gitee.com/liangxiegame/QFramework\r\n\r\n国内童鞋建议打开 gitee 版本仓库。\r\n\r\n在 Readme 中可以看到如下内容:\r\n\r\n![image.png](https://file.liangxiegame.com/26d4141d-b622-4fed-8dd3-f87979ae5c25.png)\r\n\r\n在这里可以安装 QFramework.cs 与官方示例。\r\n\r\n点击之后，再点击下图中的下载按钮。\r\n\r\n![image.png](https://file.liangxiegame.com/78c1b225-4cfb-4f0c-ab98-33049e2068f2.png)\r\n就可以下载 QFramework.cs 官方示例了。\r\n\r\n\r\n示例中，除了本教程包含的 CounterApp，还有很多其他示例，如下:\r\n\r\n### 小游戏《点点点》\r\n\r\n![b5966b31-f004-4b5f-a38d-25753fb2eb8f.gif](https://file.liangxiegame.com/5a10aa95-4c93-4dae-acec-667a113c30ca.gif)\r\n\r\n### 小游戏《FlappyBird》\r\n\r\n![430b7f31-508d-4569-aa51-b75d5553b8c4.gif](https://file.liangxiegame.com/9845122b-93d9-4106-a027-2d7c129a096a.gif)\r\n\r\n作者：王二 soso https://github.com/so-sos-so\r\n\r\n### 小游戏《Cube Master》\r\n\r\n![b1334ef2-f6d4-4a9c-a5c4-b6cd6508595c.gif](https://file.liangxiegame.com/f51abab0-9dc9-478b-b1f1-67f2cd588477.gif)\r\n作者：王二 soso https://github.com/so-sos-so\r\n\r\n### 简易关卡编辑器2D\r\n![c57c20cf-5ee6-4346-8be8-8ad1ea2d63b9.gif](https://file.liangxiegame.com/6492498b-6c22-478d-8785-9f43453c34db.gif)\r\n\r\n![ea2cb545-4b5b-4d02-b494-dde4afa4e190.gif](https://file.liangxiegame.com/34b775c6-6a49-4141-9b9a-1377a6c15673.gif)\r\n\r\n\r\n### 小游戏《贪吃蛇》\r\n\r\n![fb907355-c06c-4bde-8ca3-5638ba9b3ef7.gif](https://file.liangxiegame.com/ac70d14e-ea89-445d-899e-06f18f11f8d1.gif)\r\n\r\n作者：一只皮皮虾 https://gitee.com/PantyNeko/\r\n\r\n以上的示例都是由 QFramework.cs 制作而成的官方示例。\r\n\r\n\r\n另外还有群友制作的开源游戏\r\n\r\n### CrazyCar\r\n\r\nUnity制作的联机赛车游戏，后台为SpringBoot + Mybatis；游戏采用QFramework框架，支持KCP和WebSocket网络(商用级)\r\n\r\n\r\n![Login.jpg](https://file.liangxiegame.com/0ab6cb1d-2374-4aa2-b27d-f04eb72792cd.png)\r\n\r\n![Setting.png](https://file.liangxiegame.com/a113dcba-9ba8-4a40-b000-be3b61719ecc.png)\r\n\r\n![Homepage.png](https://file.liangxiegame.com/9075c10d-6d21-411c-b1a4-7f92a08f9bfa.png)\r\n\r\n![Avatar.png](https://file.liangxiegame.com/32b48b5b-cdcc-433e-b1b2-4b1333211a70.png) ![Profile.png](https://file.liangxiegame.com/bda476e4-0ede-4fd9-a5bb-e993bce8a786.png)\r\n\r\n\r\n![Equip.png](https://file.liangxiegame.com/158b0ce0-6e67-47c5-81b5-cee6388dd99c.png)\r\n\r\n![Rank.png](https://file.liangxiegame.com/2bd0ef1f-d639-48e8-8c48-320995d20de4.png)\r\n\r\n![TimeTrial.png](https://file.liangxiegame.com/aa337718-b868-41d2-bc6b-2ef51c157481.png)\r\n![Match.png](https://file.liangxiegame.com/06157781-3271-438c-bf3f-613e6ec00fb0.png)\r\n\r\n作者: TastSone  https://github.com/TastSong\r\n\r\n项目地址: https://github.com/TastSong/CrazyCar\r\n\r\n\r\n## QFramework.cs 的架构如何演化出来的?\r\n\r\nQFramework.cs 的架构当前的版本，是从 《框架搭建 决定版》中设计出来的，如果学习这门课程，可以对 QFramework.cs 的原理和理念理解得更深刻，更容易对 QFramework.cs 做修改和定制。\r\n\r\n* 《框架搭建 决定版》B 站试听：https://www.bilibili.com/video/BV1wh411U7X6\r\n* 《框架搭建 决定版》完整版\r\n  *  Unity 官方中文课堂：https://learn.u3d.cn/tutorial/framework_design\r\n  *  siki 学院：https://www.sikiedu.com/my/course/871\r\n  *  GamePix 独立游戏学院：https://www.gamepixedu.com/my/course/2\r\n\r\n\r\n另外 QFramework.Toolkits 和 QFramework.ToolkitsPro 里包含的工具很多都是由 QFramework.cs 设计的， 工具的源码本身也是不错的学习资料。\r\n\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n# 3. 工具篇：QFramework.Toolkits\r\n# 01. QFramework.Toolkits 简介\r\n\r\nQFramework.Toolkits 是包含 QFramework.cs 和 大量工具集的解决方案。\r\n\r\n在 QFramework v1.0 之前，QFramework.Toolkits 就是 QFramework 本身，而在 QFramework v1.0 开始，QFramework 拥有了自己的开发架构—QFramework.cs，于是原来的 QFramework 就变成了 QFramework.Toolkits。\r\n\r\nQFramework.Toolkits 称为 QFramework 工具集，是一套**开箱即用的、渐进式**的**快速开发**框架。\r\n\r\n目标是作为无框架经验的公司、独立开发者、以及 Unity3D 初学者们的**第一套框架**。框架内部积累了多个项目在各个技术方向的解决方案。学习成本低，接入成本低（侵入性低），重构成本低，二次开发成本低。文档内容丰富。\r\n\r\nQFramework 工具集的设计哲学是追求极致的开发效率和开发体验。\r\n\r\n**QFramework.Toolkits 特性一览**\r\n\r\n* 工具集（QFramework.Toolkits v0.16）\r\n    * UIKit 界面&View快速开发&管理解决方案\r\n        * UI、GameObject 的代码生成&自动赋值\r\n        * 界面管理\r\n        * 层级管理\r\n        * 界面堆栈\r\n        * 默认使用 ResKit 方式管理界面资源\r\n        * 可自定义界面的加载、卸载方式\r\n        * Manager Of Manager 架构集成（不推荐使用）\r\n    * ResKit 资源快速开发&管理解决方案\r\n        * AssetBundle 提供模拟模式，开发阶段无需打包即可加载资源\r\n        * 资源名称代码生成支持\r\n        * 同一个 API 可加载 AssetBundle、Resources、网络 和 自定义来源的资源\r\n        * 提供一套引用计数的资源管理模型\r\n    * AudioKit 音频管理解决方案\r\n        * 提供背景音乐、人声、音效 三种音频播放 API\r\n        * 音量控制\r\n        * 默认使用 ResKit 方式管理音频资源\r\n        * 可自定义音频的加载、卸载方式\r\n    * CoreKit 提供大量的代码工具\r\n        * ActionKit：动作序列执行系统\r\n        * CodeGenKit：代码生成 & 自动序列化赋值工具\r\n        * EventKit：提供基于类、字符串、枚举以及信号类型的事件工具集\r\n        * FluentAPI：对大量的 Unity 和 C# 常用的 API 提供了静态扩展的封装（链式 API）\r\n        * IOCKit：提供依赖注入容器\r\n        * LocaleKit：本地化&多语言工具集\r\n        * LogKit：日志工具集\r\n        * PackageKit：包管理工具，由此可更新框架和对应的插件模块。\r\n        * PoolKit：对象池工具集，提供对象池的基础上，也提供 ListPool 和 Dictionary Pool 等工具。\r\n        * SingletonKit：单例工具集\r\n        * TableKit：提供表格类数据结构的工具集\r\n\r\n\r\n**典型的 QFrameowrk.Toolkits 代码**\r\n\r\n```csharp\r\nusing QFramework;\r\nusing UnityEngine;\r\nusing UnityEngine.UI;\r\n\r\nnamespace liangxiegame\r\n{\r\n    public partial class UIGamePanel : UIPanel\r\n    {\r\n        private ResLoader mResLoader;\r\n        \r\n        protected override void OnInit(IUIData uiData = null)\r\n        {\r\n            mResLoader = ResLoader.Allocate();\r\n            \r\n            mResLoader.LoadSync<GameObject>(\"GameplayRoot\")\r\n                .Instantiate()\r\n                .Identity()\r\n                .GetComponent<GameplayRoot>()\r\n                .InitGameplayRoot();\r\n            \r\n            \r\n            BtnPause.onClick.AddListener(() =>\r\n            {\r\n                AudioKit.PlaySound(\"btn_click\");\r\n                \r\n                ActionKit.Sequence()\r\n                    .Callback(() => BtnPause.interactable = false)\r\n                    .Callback(() => BtnPause.PlayBtnFadeAnimation())\r\n                    .Delay(0.3f)\r\n                    .Callback(() => UIKit.OpenPanel<UIPausePanel>())\r\n                    .Start(this);\r\n            });\r\n        }\r\n\r\n        protected override void OnClose()\r\n        {\r\n            mResLoader.Recycle2Cache();\r\n            mResLoader = null;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n# 02. 下载与安装\r\n\r\n\r\n## 如何下载&安装\r\nQFramework.Toolkits 的最新 unitypackage 存放在  git 仓库里，如下图所示:\r\n\r\n![image.png](https://file.liangxiegame.com/e5ff0b03-e593-4720-b077-1b0af817cdf0.png)\r\n\r\ngit 仓库地址:\r\n* github： https://github.com/liangxiegame/QFramework\r\n* gitee（国内镜像）： https://gitee.com/liangxiegame/QFramework\r\n\r\n点击包文件后，再点击下载按钮。\r\n\r\n![image.png](https://file.liangxiegame.com/4cfddfa3-a27a-4454-9cd9-8ebeef6ae8cc.png)\r\n\r\n下载完成后导入到 Unity 工程即可。\r\n\r\n## 如何更新\r\n\r\n当有新版本时，在 QFramework 的编辑器面板内就可以升级，打开方式 ctrl + e 或 ctrl + shift + e，打开后如下图所示：\r\n\r\n![image.png](https://file.liangxiegame.com/af6ae4cb-312b-413b-a92e-a57c27820a60.png)\r\n\r\n当有新版本时，图中的按钮会显示为\"更新\"，点击就可以一键更新。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n\r\n## UI Kit 小结\r\n\r\n在这一章，UI Kit 的核心功能，我们都接触过了，如下：\r\n\r\n* UIPanel/UIElement 代码生成\r\n* UIKit 常用 API\r\n  * UIKit.OpenPanel（Async）\r\n  * UIKit.ClosePanel\r\n  * UIKit.CloseSelf\r\n  * UIKit.SetResolution\r\n  * UIKit.Stack.Push、UIPanel.Back(Pop)\r\n* UIPanel 生命周期\r\n* UIPanel 测试场景生成工具\r\n* 自定义加载界面\r\n\r\n只要掌握了以上这些，基本上开发一些界面就没啥问题了。\r\n\r\n关于 UIKit 就介绍到这里。\r\n\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  \r\n# 01. FluentAPI 链式 API\r\n\r\n## FluentAPI 简介\r\nFluentAPI 是 笔者积累的 Unity API 的一些链式封装。\r\n\r\n基本使用非常简单，如下：\r\n```csharp\r\n// traditional style\r\nvar playerPrefab = Resources.Load<GameObject>(\"no prefab don't run\");\r\nvar playerObj = Instantiate(playerPrefab);\r\n\r\nplayerObj.transform.SetParent(null);\r\nplayerObj.transform.localRotation = Quaternion.identity;\r\nplayerObj.transform.localPosition = Vector3.left;\r\nplayerObj.transform.localScale = Vector3.one;\r\nplayerObj.layer = 1;\r\nplayerObj.layer = LayerMask.GetMask(\"Default\");\r\n\r\nDebug.Log(\"playerPrefab instantiated\");\r\n\r\n// Extension's Style,same as above \r\nResources.Load<GameObject>(\"playerPrefab\")\r\n    .Instantiate()\r\n    .transform\r\n    .Parent(null)\r\n    .LocalRotationIdentity()\r\n    .LocalPosition(Vector3.left)\r\n    .LocalScaleIdentity()\r\n    .Layer(1)\r\n    .Layer(\"Default\")\r\n    .ApplySelfTo(_ => { Debug.Log(\"playerPrefab instantiated\"); });\r\n```\r\n\r\n代码很简单。\r\n\r\nFluentAPI 包含 100 多个常用 API 的链式封装，具体可以参考编辑器内文档。\r\n\r\n![image.png](https://file.liangxiegame.com/67604baa-a9ca-4f03-8f7a-c1f88be322b7.png)\r\n\r\n另外 链式 API 可以与 QFramework 的其他模块配合使用事半功倍，比如 ResKit 与 FluentAPI 结合，参考代码如下:\r\n\r\n```csharp\r\nmResLoader.LoadSync<GameObject>(\"mygameobj\")\r\n  .InstantiateWithParent(parent)\r\n  .transform\r\n  .LocalIdentity()\r\n  .Name(\"MyGameObj\")\r\n  .Show();\r\n```\r\n\r\n\r\n链式 API 就介绍到这里。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n# 01. FSMKit 状态机\r\n\r\nQFramework 内置了一个简易的状态机，基本使用如下:\r\n\r\n## 链式\r\n\r\n```csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class IStateBasicUsageExample : MonoBehaviour\r\n    {\r\n        public enum States\r\n        {\r\n            A,\r\n            B\r\n        }\r\n\r\n        public FSM<States> FSM = new FSM<States>();\r\n\r\n        void Start()\r\n        {\r\n            FSM.State(States.A)\r\n                .OnCondition(()=>FSM.CurrentStateId == States.B)\r\n                .OnEnter(() =>\r\n                {\r\n                    Debug.Log(\"Enter A\");\r\n                })\r\n                .OnUpdate(() =>\r\n                {\r\n                    \r\n                })\r\n                .OnFixedUpdate(() =>\r\n                {\r\n                    \r\n                })\r\n                .OnGUI(() =>\r\n                {\r\n                    GUILayout.Label(\"State A\");\r\n                    if (GUILayout.Button(\"To State B\"))\r\n                    {\r\n                        FSM.ChangeState(States.B);\r\n                    }\r\n                })\r\n                .OnExit(() =>\r\n                {\r\n                    Debug.Log(\"Enter B\");\r\n\r\n                });\r\n\r\n            FSM.State(States.B)\r\n                .OnCondition(() => FSM.CurrentStateId == States.A)\r\n                .OnGUI(() =>\r\n                {\r\n                    GUILayout.Label(\"State B\");\r\n                    if (GUILayout.Button(\"To State A\"))\r\n                    {\r\n                        FSM.ChangeState(States.A);\r\n                    }\r\n                });\r\n            \r\n            FSM.StartState(States.A);\r\n        }\r\n\r\n        private void Update()\r\n        {\r\n            FSM.Update();\r\n        }\r\n\r\n        private void FixedUpdate()\r\n        {\r\n            FSM.FixedUpdate();\r\n        }\r\n\r\n        private void OnGUI()\r\n        {\r\n            FSM.OnGUI();\r\n        }\r\n\r\n        private void OnDestroy()\r\n        {\r\n            FSM.Clear();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n运行之后，结果如下:\r\n\r\n![1](https://file.liangxiegame.com/c263fec3-02eb-4af6-bb84-a3310440cfa9.gif)\r\n\r\n没啥问题。\r\n\r\n\r\n\r\n## 类模式\r\n\r\n链式适合在快速开发阶段，或者在状态非常少的阶段使用。\r\n\r\n\r\n\r\n而如果状态较多，或者相应代码量较多的阶段，可以使用类模式，代码如下:\r\n\r\n\r\n\r\n```csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class IStateClassExample : MonoBehaviour\r\n    {\r\n\r\n        public enum States\r\n        {\r\n            A,\r\n            B,\r\n            C\r\n        }\r\n\r\n        public FSM<States> FSM = new FSM<States>();\r\n\r\n        public class StateA : AbstractState<States,IStateClassExample>\r\n        {\r\n            public StateA(FSM<States> fsm, IStateClassExample target) : base(fsm, target)\r\n            {\r\n            }\r\n\r\n            protected override bool OnCondition()\r\n            {\r\n                return mFSM.CurrentStateId == States.B;\r\n            }\r\n\r\n            public override void OnGUI()\r\n            {\r\n                GUILayout.Label(\"State A\");\r\n\r\n                if (GUILayout.Button(\"To State B\"))\r\n                {\r\n                    mFSM.ChangeState(States.B);\r\n                }\r\n            }\r\n        }\r\n        \r\n        \r\n        public class StateB: AbstractState<States,IStateClassExample>\r\n        {\r\n            public StateB(FSM<States> fsm, IStateClassExample target) : base(fsm, target)\r\n            {\r\n            }\r\n\r\n            protected override bool OnCondition()\r\n            {\r\n                return mFSM.CurrentStateId == States.A;\r\n            }\r\n\r\n            public override void OnGUI()\r\n            {\r\n                GUILayout.Label(\"State B\");\r\n\r\n                if (GUILayout.Button(\"To State A\"))\r\n                {\r\n                    mFSM.ChangeState(States.A);\r\n                }\r\n            }\r\n        }\r\n\r\n        private void Start()\r\n        {\r\n            FSM.AddState(States.A, new StateA(FSM, this));\r\n            FSM.AddState(States.B, new StateB(FSM, this));\r\n\r\n            // 支持和链式模式混用\r\n            // FSM.State(States.C)\r\n            //     .OnEnter(() =>\r\n            //     {\r\n            //\r\n            //     });\r\n            \r\n            FSM.StartState(States.A);\r\n        }\r\n\r\n        private void OnGUI()\r\n        {\r\n            FSM.OnGUI();\r\n        }\r\n\r\n        private void OnDestroy()\r\n        {\r\n            FSM.Clear();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n运行之后结果如下。\r\n\r\n\r\n\r\n![1](https://file.liangxiegame.com/c263fec3-02eb-4af6-bb84-a3310440cfa9.gif)\r\n\r\n关于状态机的介绍就到这里。\r\n\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n\r\n# 01. PoolKit 对象池套件\r\n\r\n\r\n## SimpleObjectPool 简易对象池\r\n\r\n```csharp\r\nclass Fish\r\n{\r\n             \r\n}\r\n\r\nvar pool = new SimpleObjectPool<Fish>(() => new Fish(),initCount:50);\r\n \r\nDebug.Log(pool.CurCount);\r\n// 50 \r\nvar fish = pool.Allocate();\r\n \r\nDebug.Log(pool.CurCount);\r\n// 49\r\npool.Recycle(fish);\r\n\r\nDebug.Log(pool.CurCount);\r\n// 50\r\n\r\n\r\n// ---- GameObject ----\r\nvar gameObjPool = new SimpleObjectPool<GameObject>(() =>\r\n{\r\n    var gameObj = new GameObject(\"\"AGameObject\"\");\r\n    // init gameObj code \r\n\r\n    // gameObjPrefab = Resources.Load<GameObject>(\"\"somePath/someGameObj\"\");\r\n                \r\n    return gameObj;\r\n}, (gameObj) =>\r\n{\r\n    // reset code here\r\n});\r\n```\r\n\r\n## SafeObjectPool 安全对象池\r\n\r\n```csharp\r\nclass Bullet :IPoolable,IPoolType\r\n{\r\n    public void OnRecycled()\r\n    {\r\n        Debug.Log(\"\"回收了\"\");\r\n    }\r\n \r\n    public  bool IsRecycled { get; set; }\r\n \r\n    public static Bullet Allocate()\r\n    {\r\n        return SafeObjectPool<Bullet>.Instance.Allocate();\r\n    }\r\n             \r\n    public void Recycle2Cache()\r\n    {\r\n        SafeObjectPool<Bullet>.Instance.Recycle(this);\r\n    }\r\n}\r\n \r\nSafeObjectPool<Bullet>.Instance.Init(50,25);\r\n             \r\nvar bullet = Bullet.Allocate();\r\n \r\nDebug.Log(SafeObjectPool<Bullet>.Instance.CurCount);\r\n             \r\nbullet.Recycle2Cache();\r\n \r\nDebug.Log(SafeObjectPool<Bullet>.Instance.CurCount);\r\n \r\n// can config object factory\r\n// 可以配置对象工厂\r\nSafeObjectPool<Bullet>.Instance.SetFactoryMethod(() =>\r\n{\r\n    // bullet can be mono behaviour\r\n    return new Bullet();\r\n});\r\n             \r\nSafeObjectPool<Bullet>.Instance.SetObjectFactory(new DefaultObjectFactory<Bullet>());\r\n \r\n// can set\r\n// 可以设置\r\n// NonPublicObjectFactory: 可以通过调用私有构造来创建对象,can call private constructor to create object\r\n// CustomObjectFactory: 自定义创建对象的方式,can create object by Func<T>\r\n// DefaultObjectFactory: 通过 new 创建对象, can create object by new \r\n```\r\n\r\n## 基本的数据结构封装 List、Dictionary\r\n\r\n```csharp\r\nvar names = ListPool<string>.Get()\r\nnames.Add(\"\"Hello\"\");\r\n\r\nnames.Release2Pool();\r\n// or ListPool<string>.Release(names);\r\n```\r\n\r\n\r\n```csharp\r\nvar infos = DictionaryPool<string,string>.Get()\r\ninfos.Add(\"\"name\"\",\"\"liangxie\"\");\r\n\r\ninfos.Release2Pool();\r\n// or DictionaryPool<string,string>.Release(names);\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n# 01. TableKit 表数据结构\r\n\r\n在设计 UIKit、ResKit 等系统时，如果只使用默认的 List 和 Dictionary 来管理数据和对象需要做很多的封装。\r\n\r\n因为本身 List 和 Dictionary 支持的查询方式比较单一，如果想做一些比较复杂的查询，比如联合查询，那么 List 和 Dictionary 的性能会比较差。\r\n\r\n所以为此，笔者简单封装了一个 Table 数据结构。\r\n\r\n使用示例如下:\r\n\r\n```csharp\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing UnityEngine;\r\n\r\nnamespace QFramework\r\n{\r\n    public class TableKitExample : MonoBehaviour\r\n    {\r\n        public class Student\r\n        {\r\n            public string Name { get; set; }\r\n            public int Age { get; set; }\r\n            public int Level { get; set; }\r\n        }\r\n        public class School : Table<Student>\r\n        {\r\n            public TableIndex<int, Student> AgeIndex = new TableIndex<int, Student>((student) => student.Age);\r\n            public TableIndex<int, Student> LevelIndex = new TableIndex<int, Student>((student) => student.Level);\r\n            \r\n            protected override void OnAdd(Student item)\r\n            {\r\n                AgeIndex.Add(item);\r\n                LevelIndex.Add(item);\r\n            }\r\n\r\n            protected override void OnRemove(Student item)\r\n            {\r\n                AgeIndex.Remove(item);\r\n                LevelIndex.Remove(item);\r\n            }\r\n\r\n            protected override void OnClear()\r\n            {\r\n                AgeIndex.Clear();\r\n                LevelIndex.Clear();\r\n            }\r\n\r\n            public override IEnumerator<Student> GetEnumerator()\r\n            {\r\n                return AgeIndex.Dictionary.Values.SelectMany(s=>s).GetEnumerator();\r\n            }\r\n\r\n            protected override void OnDispose()\r\n            {\r\n                AgeIndex.Dispose();\r\n                LevelIndex.Dispose();\r\n            }\r\n        }\r\n\r\n\r\n        private void Start()\r\n        {\r\n            var school = new School();\r\n            school.Add(new Student(){Age = 1,Level = 2,Name = \"liangxie\"});\r\n            school.Add(new Student(){Age = 2,Level = 2,Name = \"ava\"});\r\n            school.Add(new Student(){Age = 3,Level = 2,Name = \"abc\"});\r\n            school.Add(new Student(){Age = 3,Level = 3,Name = \"efg\"});\r\n            \r\n            foreach (var student in school.LevelIndex.Get(2).Where(s=>s.Age < 3))\r\n            {\r\n                Debug.Log(student.Age + \":\" + student.Level + \":\" + student.Name);\r\n            }\r\n        }\r\n    }\r\n}\r\n// 1:2:liangxie\r\n// 2:2:ava\r\n```\r\n\r\n\r\nTableKit 兼顾查询功能支持和性能，在功能和性能之间取得了一个平衡。\r\n\r\nResKit、UIKit 的数据管理全部由 TableKit 支持。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n\r\n\r\n# 01. 其他事件工具\r\n\r\nQFramework 除了支持了  TypeEventSystem、EasyEvent 还支持了 EnumEventSystem、StringEventSystem。\r\n\r\n\r\n## EnumEventSystem\r\n\r\nEnumEventSystem 前身是 老版本 QFramework 的 QEventSystem\r\n\r\n``` csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework\r\n{\r\n\tpublic class EnumEventExample : MonoBehaviour\r\n\t{\r\n\t\t#region 事件定义\r\n\r\n\t\tpublic enum TestEvent\r\n\t\t{\r\n\t\t\tStart,\r\n\t\t\tTestOne,\r\n\t\t\tEnd,\r\n\t\t}\r\n\r\n\t\tpublic enum TestEventB\r\n\t\t{\r\n\t\t\tStart = TestEvent.End, // 为了保证每个消息 Id 唯一，需要头尾相接\r\n\t\t\tTestB,\r\n\t\t\tEnd,\r\n\t\t}\r\n\r\n\t\t#endregion 事件定义\r\n\t\t\r\n\t\tvoid Start()\r\n\t\t{\r\n\t\t\tEnumEventSystem.Global.Register(TestEvent.TestOne, OnEvent);\r\n\t\t}\r\n\r\n\t\tvoid OnEvent(int key, params object[] obj)\r\n\t\t{\r\n\t\t\tswitch (key)\r\n\t\t\t{\r\n\t\t\t\tcase (int) TestEvent.TestOne:\r\n\t\t\t\t\tDebug.Log(obj[0]);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tprivate void Update()\r\n\t\t{\r\n\t\t\tif (Input.GetMouseButtonDown(0))\r\n\t\t\t{\r\n\t\t\t\tEnumEventSystem.Global.Send(TestEvent.TestOne, \"Hello World!\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tprivate void OnDestroy()\r\n\t\t{\r\n\t\t\tEnumEventSystem.Global.UnRegister(TestEvent.TestOne, OnEvent);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n\r\n## StringEventSystem\r\n\r\nStringEventSystem 的前身是，老版本的 MsgDispatcher\r\n\r\n``` csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework\r\n{\r\n\tpublic class EnumEventExample : MonoBehaviour\r\n\t{\r\n\t\t#region 事件定义\r\n\r\n\t\tpublic enum TestEvent\r\n\t\t{\r\n\t\t\tStart,\r\n\t\t\tTestOne,\r\n\t\t\tEnd,\r\n\t\t}\r\n\r\n\t\tpublic enum TestEventB\r\n\t\t{\r\n\t\t\tStart = TestEvent.End, // 为了保证每个消息 Id 唯一，需要头尾相接\r\n\t\t\tTestB,\r\n\t\t\tEnd,\r\n\t\t}\r\n\r\n\t\t#endregion 事件定义\r\n\t\t\r\n\t\tvoid Start()\r\n\t\t{\r\n\t\t\tEnumEventSystem.Global.Register(TestEvent.TestOne, OnEvent);\r\n\t\t}\r\n\r\n\t\tvoid OnEvent(int key, params object[] obj)\r\n\t\t{\r\n\t\t\tswitch (key)\r\n\t\t\t{\r\n\t\t\t\tcase (int) TestEvent.TestOne:\r\n\t\t\t\t\tDebug.Log(obj[0]);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tprivate void Update()\r\n\t\t{\r\n\t\t\tif (Input.GetMouseButtonDown(0))\r\n\t\t\t{\r\n\t\t\t\tEnumEventSystem.Global.Send(TestEvent.TestOne, \"Hello World!\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tprivate void OnDestroy()\r\n\t\t{\r\n\t\t\tEnumEventSystem.Global.UnRegister(TestEvent.TestOne, OnEvent);\r\n\t\t}\r\n\t}\r\n}\r\n// 输出结果\r\n// 点击鼠标左键\r\n// Hello World\r\n```\r\n\r\n\r\n## StringEventSystem\r\n\r\n``` csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class StringEventSystemExample : MonoBehaviour\r\n    {\r\n        void Start()\r\n        {\r\n            StringEventSystem.Global.Register(\"TEST_ONE\", () =>\r\n            {\r\n                Debug.Log(\"TEST_ONE\");\r\n            }).UnRegisterWhenGameObjectDestroyed(gameObject);\r\n            \r\n            // 事件 + 参数\r\n            StringEventSystem.Global.Register<int>(\"TEST_TWO\", (count) =>\r\n            {\r\n                Debug.Log(\"TEST_TWO:\" + count);\r\n\r\n            }).UnRegisterWhenGameObjectDestroyed(gameObject);\r\n        }\r\n\r\n        private void Update()\r\n        {\r\n            if (Input.GetMouseButtonDown(0))\r\n            {\r\n                StringEventSystem.Global.Send(\"TEST_ONE\");\r\n                StringEventSystem.Global.Send(\"TEST_TWO\",10);\r\n                \r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// 输出结果\r\n// 点击鼠标左键\r\n// TEST_ONE\r\n// TEST_TWO:10\r\n\r\n```\r\n\r\n\r\n\r\n\r\n## 对比\r\n\r\n* TypeEventSystem：\r\n  * 事件体定义简洁\r\n  * 比较适合用于设计框架\r\n  * 支持 struct 获得较好内存性能\r\n  * 使用反射，CPU 性能相对比较差\r\n\r\n* EasyEvent\r\n  * 方便、易用、开发效率高\r\n  * CPU 性能、内存性能较好，接近委托\r\n  * 功能有限\r\n  * 比较适合设计通用解决工具，比如通用背包、全局生命周期触发等\r\n  * StringEventSystem、TypeEventSystem 的底层由 EasyEvent 实现\r\n\r\n* EnumEventSystem\r\n  * 使用枚举作为事件 id，比较适合和服务端的 protobuf 或带有消息 id 的长链接通信\r\n  * 性能较好\r\n  * 枚举用于定义消息体有维护成本\r\n\r\n* StringEventSystem\r\n  * 使用字符串作为事件 id，比较适合和其他脚本层通信，比如 Lua、ILRuntime、PlayMaker 等。\r\n  * 性能一般\r\n\r\n\r\n目前官方推荐使用 TypeEventSystem 和 EasyEvent 这两个工具。\r\n\r\n如果要和网络通信则选择用 EnumEventSystem。\r\n\r\n如果要和其他脚本层通信选择用 StringEventSystem。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n    \r\n    \r\n    \r\n        \r\n# 01. 更多内容\r\n\r\n\r\n## 案例《五子棋》\r\n\r\n![2f4dacbd-e59b-43af-b7be-44220fac664e.png](https://file.liangxiegame.com/a76bc24a-1828-46f2-94c5-8bd24884f932.png)\r\n\r\n\r\n源码地址:\r\n* github https://github.com/liangxiegame/QFramework\r\n* gitee https://gitee.com/liangxiegame/QFramework\r\n\r\n![image.png](https://file.liangxiegame.com/3abceb70-2d17-4457-aff1-ef8a6ef4bd66.png)\r\n\r\n## 案例《扫雷》\r\n\r\n作者：Joker\r\n\r\n![扫雷](https://file.liangxiegame.com/4c42d227-11b9-4485-8884-a2f04a62460c.png)\r\n源码地址:\r\n* github https://github.com/liangxiegame/QFramework\r\n* gitee https://gitee.com/liangxiegame/QFramework\r\n\r\n![image.png](https://file.liangxiegame.com/6482d4eb-5af9-4932-a2f8-2164cb22e931.png)\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n# 01. GridKit 二维格子数据结构\r\n\r\n在做游戏的过程中，我们经常需要处理二维格子类的数据，比如消除类游戏、俄罗斯方块、各种棋类游戏，还有我们最常用的 Tilemap 的地块数据，这些都需要二维格子数据结构。\r\n\r\n而在 GameMaker Studio 引擎中，这样的数据结构直接在引擎层面提供，名字叫做 ds_grid。\r\n\r\n受到 GameMaker Stdio 的 ds_grid 启发，QFramework 也实现了一个类似的数据结构，名字叫做 EasyGrid，示例代码如下:\r\n``` csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class GridKitExample : MonoBehaviour\r\n    {\r\n        // Start is called before the first frame update\r\n        void Start()\r\n        {\r\n            var grid = new EasyGrid<string>(4, 4);\r\n\r\n            grid.Fill(\"Empty\");\r\n            \r\n            grid[2, 3] = \"Hello\";\r\n\r\n            grid.ForEach((x, y, content) => Debug.Log($\"({x},{y}):{content})\");\r\n\r\n            grid.Clear();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n运行后，代码如下:\r\n``` \r\n(0,0):Empty\r\n(0,1):Empty\r\n(0,2):Empty\r\n(0,3):Empty\r\n(1,0):Empty\r\n(1,1):Empty\r\n(1,2):Empty\r\n(1,3):Empty\r\n(2,0):Empty\r\n(2,1):Empty\r\n(2,2):Empty\r\n(2,3):Hello\r\n(3,0):Empty\r\n(3,1):Empty\r\n(3,2):Empty\r\n(3,3):Empty\r\n```\r\n\r\n好了这个就是关于 GridKit 的简单介绍。\r\n\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n# 01. LiveCodingKit 热重载\r\n\r\n我们在用 Unity 开发的时候，每次编写或修改一点代码就需要进行 停止运行->编写代码->等待编译->运行游戏。\r\n\r\n而在很多情况下这个过程是一个比较耗神的过程，因为开发者需要等待，还需要动手操作。\r\n\r\n在笔者体验过 GameMakerStudio 的 GMLive 插件后，发现不停止运行就可以直接查看代码编写的结果的体验非常丝滑。\r\n\r\n于是笔者就在 QFramework 中写了一个类似的方案 LiveCodingKit。\r\n\r\n使用方式很简单，首先在 QFramework 编辑器中可以看到 LiveCodingKit 面板，如下:\r\n\r\n![image-20230112105034532](https://file.liangxiegame.com/4e7b25f6-cb59-4283-8e74-9d2c951c39e5.png)\r\n\r\n确保开启是勾选状态。\r\n\r\n然后根据自己需要选择当编译完成时，对应的操作，一般情况下重新加载当前场景就够用了。\r\n\r\n当然如果是场景和场景间有依赖关系，那么可以选择重启游戏。\r\n\r\n然后随意运行一个带有脚本的场景，笔者选择的是 QFramework 自带的示例，如下:\r\n\r\n![image-20230112105245671](https://file.liangxiegame.com/907db129-95aa-4674-a63a-3c47f82d4dc9.png)\r\n\r\n然后新增代码如下:\r\n\r\n```csharp\r\npublic partial class UIBasicPanel : UIPanel\r\n{\r\n   protected override void OnInit(IUIData uiData = null)\r\n   {\r\n      mData = uiData as UIBasicPanelData ?? new UIBasicPanelData();\r\n      \r\n      BtnStart.onClick.AddListener(() =>\r\n      {\r\n         Debug.Log(\"开始游戏\");\r\n      });\r\n\r\n      BtnStart.Rotation(Quaternion.Euler(0, 0, 90)); // 新增代码\r\n   }\r\n   \r\n```\r\n\r\n之后回到 Unity 直接等待编译（不用停止运行）。\r\n\r\n\r\n\r\n编译完成后结果如下:\r\n\r\n![image-20230112105456694](https://file.liangxiegame.com/5185ab09-938c-4bd7-9259-6ff08ebaf779.png)\r\n\r\n\r\n\r\nOK，结果没问题。\r\n\r\n这就是 LiveCodingKit 的介绍，当你需要在代码中调整一些数值，写 OnGUI 代码，会非常方便，当然也有一些不适用的情况，这个就需要大家自行体验了。\r\n\r\n\r\n\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n# 01. 动态二维格子数据结构 DynaGrid（GridKit）\r\n\r\n之前介绍的 EasyGrid 只支持固定宽度和高度，但是在很多情况下我们需要一个动态宽高的二维格子数据结构。\r\n\r\n于是 QFramework 增加了 DynaGrid。\r\n\r\n示例代码如下:\r\n``` csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class DynaGridExample : MonoBehaviour\r\n    {\r\n        public class MyData\r\n        {\r\n            public string Key;\r\n        }\r\n\r\n        void Start()\r\n        {\r\n            var dynaGrid = new DynaGrid<MyData>();\r\n            dynaGrid[1, 1] = new MyData() { Key = \"\"Hero\"\" };\r\n            dynaGrid[-1, -10] = new MyData() { Key = \"\"Enemy\"\" };\r\n\r\n            dynaGrid.ForEach((x, y, data) => { Debug.Log($\"\"{x} {y} {data.Key}\"\"); });\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n运行后，代码如下:\r\n``` \r\n// 1 1 Hero\r\n// -1 -10 Enemy\r\n```\r\n\r\n好了这个就是关于 DynaGrid 的简单介绍。\r\n\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263 \r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n\r\n# 03. CodeGenKit 脚本生成\r\n在这一篇，我们学习几乎每个项目都要用到并且从中受益的功能：自动生成脚本并绑定，简称脚本生成。\r\n\r\n## 基本使用\r\n\r\n我们先在场景中，随便创建一些有父子结构的 GameObject，如下所示：\r\n\r\n![image.png](https://file.liangxiegame.com/ed37997b-614b-4fb1-baa8-c23d7748c67d.png)\r\n\r\n接着给 Player 挂上 ViewController，快捷键 （Alt + V），如下图所示：\r\n\r\n![image.png](https://file.liangxiegame.com/cfb5f767-120f-4e0f-a69b-bdef1b6e9c98.png)\r\n\r\n\r\n然后填写 刚刚添加的组件信息:\r\n\r\n![image.png](https://file.liangxiegame.com/a2bc2a07-02bf-46e3-ad65-36309c290bce.png)\r\n\r\n\r\n在这里，可以填写命名空间，要生成的脚本名，以及脚本生成的目录，当然这里也可以直接将要生成的目录拖到大方块中。\r\n\r\n如果拖拽了目录，就会自动填写脚本生成目录，如下图所示：\r\n\r\n![image.png](https://file.liangxiegame.com/41f2abac-2fcf-4c03-8ba0-ab45f71859f3.png)\r\n\r\n之后，我们可以给 Player GameObject 一个子节点挂上 Bind 组件（快捷键，alt + b)，如下所示\r\n\r\n![image.png](https://file.liangxiegame.com/e818f0e5-6bfc-436b-8f61-20fb90da4bd6.png)\r\n\r\n\r\n\r\nWeapon 挂上的组件如下所示:\r\n![image.png](https://file.liangxiegame.com/04e7c9a4-0bc6-4257-9793-41531c3faa64.png)\r\n\r\n\r\n接下来我们可以点击图中的 生成代码按钮 或者是 Player 上 ViewController 的 生成代码按钮，两者点击哪个都可以。\r\n\r\n点击之后，就会生成代码，等待编译，结果如下:\r\n\r\n脚本目录:\r\n![image.png](https://file.liangxiegame.com/d3fc5522-6655-4318-8bec-7f4721753110.png)\r\n\r\n我们在看下场景中的 Player 的 Inspector 如下图所示：\r\n\r\n![image.png](https://file.liangxiegame.com/07c51906-6c1d-49be-bb9b-faef8ce999ae.png)\r\n\r\n\r\n我们看到，Player 自动获得了 Weapon 的引用。\r\n\r\n而且，在 Player.cs 中可以直接访问到 Weapon，如下图所示:\r\n\r\n![image.png](https://file.liangxiegame.com/3a9f0ac1-c05c-4cdf-b442-c33fadb6897a.png)\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n\r\n## 增量生成\r\n我们再看下目录：\r\n\r\n![image.png](https://file.liangxiegame.com/47398560-791c-4e41-8586-6b76347f2758.png)\r\n\r\n这里有两个文件 Player 和 Player.Designer。\r\n\r\n其中 Player 是用来给大家写逻辑用的，所以 Player 只会生成一次。\r\n\r\n而 Player.Designer 每次点击生成代码都会重新生成。\r\n\r\n我们看下 Player.Designer 的代码，如下:\r\n\r\n```csharp\r\n// Generate Id:471bf5e6-b60b-42b8-b5c8-b070a963ab4a\r\nusing UnityEngine;\r\n\r\n// 1.请在菜单 编辑器扩展/Namespace Settings 里设置命名空间\r\n// 2.命名空间更改后，生成代码之后，需要把逻辑代码文件（非 Designer）的命名空间手动更改\r\nnamespace QFramework.Example\r\n{\r\n\tpublic partial class Player\r\n\t{\r\n\r\n\t\tpublic Transform Weapon;\r\n\r\n\t}\r\n}\r\n```\r\n\r\n代码中只有一个 Weapon 。\r\n\r\n接着，我们再给 Player 的另一个子 GameObject 挂上 Bind 脚本，如下:\r\n\r\n![image.png](https://file.liangxiegame.com/acde8a1e-2e6f-4bee-8aa9-02cec82f2808.png)\r\n\r\n然后点击生成代码，操作如下:\r\n\r\n![image.png](https://file.liangxiegame.com/991db32f-8212-4d7a-8176-0065cebad93f.png)\r\n\r\n\r\n生成之后，结果如下:\r\n\r\nPlayer 多了一个 Ground Check\r\n![image.png](https://file.liangxiegame.com/d769f7e4-1e70-4dfc-9962-27d6b99998a4.png)\r\n\r\n再看下  Player.Designer 的代码，如下:\r\n\r\n```csharp\r\n// Generate Id:f512c2ed-6243-4a89-897e-bdaaabe50d63\r\nusing UnityEngine;\r\n\r\n// 1.请在菜单 编辑器扩展/Namespace Settings 里设置命名空间\r\n// 2.命名空间更改后，生成代码之后，需要把逻辑代码文件（非 Designer）的命名空间手动更改\r\nnamespace QFramework.Example\r\n{\r\n\tpublic partial class Player\r\n\t{\r\n\r\n\t\tpublic Transform Weapon;\r\n\r\n\t\tpublic Transform GroundCheck;\r\n\r\n\t}\r\n}\r\n```\r\n\r\n这次多了一个 GroundCheck。\r\n\r\n而 Player 代码则未发生任何变化。\r\n\r\n所以每次生成代码，Player.cs 只会生成一次，Player.Designer.cs 每次都重新生成，所以大家放心在 Player.cs 里写代码。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 类型选择\r\n之前我们用 Bind 绑定的 GameObject 都是 Transform 类型的，这次我们尝试绑定一下其他类型。\r\n\r\n我们给 Weapon GameObject 挂上一个 Sprite Renderer 如下所示:\r\n\r\n![image.png](https://file.liangxiegame.com/913a4dcb-7e35-433c-a50a-454614ddf89d.png)\r\n\r\n\r\n然后，我们点击 Bind 的类型，显示如下：\r\n\r\n![image.png](https://file.liangxiegame.com/9ff5d52d-61bb-43b7-b4f0-5e9c118329e1.png)\r\n\r\n也就是说 Bind 可以选择挂在此 GameObject 上的组件。\r\n\r\n我们选择 Sprite Render 类型，如下:\r\n\r\n![image.png](https://file.liangxiegame.com/720ec620-1ca4-42b7-afa8-ec94ee846d06.png)\r\n\r\n然后点击生成代码，结果如下:\r\n\r\n![image.png](https://file.liangxiegame.com/dd6a1012-6721-4c71-9291-de008a5b8614.png)\r\n\r\n\r\nPlayer 引用的  Weapon 变成了 Sprite Renderer 类型。\r\n\r\nPlayer.Designer.cs 的代码变成了如下:\r\n\r\n```csharp\r\n// Generate Id:de59e915-d1b6-40aa-a8e5-6fc4a8bf8e3e\r\nusing UnityEngine;\r\n\r\n// 1.请在菜单 编辑器扩展/Namespace Settings 里设置命名空间\r\n// 2.命名空间更改后，生成代码之后，需要把逻辑代码文件（非 Designer）的命名空间手动更改\r\nnamespace QFramework.Example\r\n{\r\n\tpublic partial class Player\r\n\t{\r\n\r\n\t\tpublic UnityEngine.SpriteRenderer Weapon;\r\n\r\n\t\tpublic Transform GroundCheck;\r\n\r\n\t}\r\n}\r\n```\r\n\r\nWeapon 从原来的 Transform 类型变成了 SpriteRenderer 类型。\r\n\r\n这样我们在 Player.cs 就可以拿到 SpriteRenderer 类型的 Weapon 了，如下图所示：\r\n\r\n![image.png](https://file.liangxiegame.com/534d8275-5d63-4307-89a8-378722f0bffc.png)\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## ViewController 与 ViewController 嵌套\r\nViewController 与 ViewController 之间可以嵌套\r\n\r\n我们在 Player 的 Weapon GameObject 再创建一个 WeaponEffect GameObject 如下:\r\n\r\n![image.png](https://file.liangxiegame.com/e9ef6d43-7e8c-42ff-9593-76dced914c7a.png)\r\n\r\n然后将 WeaponEffect 挂上 Bind 脚本，如下:\r\n\r\n![image.png](https://file.liangxiegame.com/0eed4e49-2a89-4d36-af02-4e42647cfe3a.png)\r\n\r\n接着给 Weapon 挂一个 ViewController 脚本，如下:\r\n\r\n![image.png](https://file.liangxiegame.com/e0b90b3b-cf9a-4688-ab6d-c73c8feb9f72.png)\r\n\r\n我们将脚本生成目录修改一下，修改成与 Player.cs 同一个目录，如下:\r\n\r\n![image.png](https://file.liangxiegame.com/f7c52c1e-0437-48a3-b3e1-7c9d77a080bf.png)\r\n\r\n\r\n点击生成代码，如下所示:\r\n\r\n![image.png](https://file.liangxiegame.com/29e139ca-9fc4-4422-9d4c-7831ad6d75c6.png)\r\n\r\n生成完了之后，我们再将 Weapon 上的 Bind 类型改成 Weapon，如下:\r\n\r\n![image.png](https://file.liangxiegame.com/54a25732-61ea-4dd9-84dd-7bb80d66fd2d.png)\r\n\r\n然后点击 Bind 上的生成代码，结果如下:\r\n\r\n![image.png](https://file.liangxiegame.com/83beb081-fb7a-48df-85f5-5caf01cac1fb.png)\r\n\r\n这样 ViewController 与 ViewController 嵌套绑定就实现了。\r\n\r\n在 Player.cs 中可以按照如下的方式调用 Weapon 的子 GameObject 如下:\r\n\r\n![image.png](https://file.liangxiegame.com/c29ba2f9-39b0-436a-8084-781edaf959fe.png)\r\n\r\n当然可以再 Weapon.cs 中写 Weapon 自己的逻辑。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 如何设置默认的 命名空间 和 脚本生成目录\r\n很简单，打开 QFramework 编辑器面板，（快捷键 ctrl + e 或 ctrl + shift + e)\r\n\r\n![image.png](https://file.liangxiegame.com/4322e7cc-8f5e-4e45-abbe-d63110d2e605.png)\r\n\r\n在 CodeGenKit 设置里就可以更改默认的命名空间和默认的脚本生成位置。\r\n\r\n当然在这里生成了，也还是可以在 ViewController Inspector 上进行设置。\r\n\r\n我们先改下命名空间和脚本生成路径，如下:\r\n\r\n![image.png](https://file.liangxiegame.com/72f7df2a-40cb-443c-a1f3-f4c5d5656a4b.png)\r\n\r\n然后我们创建一个 GameObject 挂上 ViewController 组件，结果如下:\r\n\r\n![image.png](https://file.liangxiegame.com/f461ade5-8cf6-4bfd-a94d-c86f523cf8e8.png)\r\n\r\n这样默认的命名空间就生效了。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 生成 Prefab\r\n在 ViewController 或 生成脚本的 Inspector 上，有一个生成 prefab 的选项\r\n\r\n![image.png](https://file.liangxiegame.com/f88d06e7-2b95-47fe-ac91-c446fc550447.png)\r\n\r\n勾选后，如下所示：\r\n\r\n![image.png](https://file.liangxiegame.com/0b9de93d-12c9-498f-b38c-c2682aa98287.png)\r\n\r\n这里可以修改要生成的目录，笔者选择和脚本生成的目录一致，如下:\r\n\r\n![image.png](https://file.liangxiegame.com/7628fcb6-c9de-4fe5-9f80-8967d745b3aa.png)\r\n\r\n然后点击，生成代码，结果如下:\r\n\r\n场景中的 Player 变成了 prefab\r\n![image.png](https://file.liangxiegame.com/9e71ac1b-874e-47dd-b9ab-8d64e605f8a1.png)\r\n\r\n生成目录中也有了 prefab\r\n\r\n![image.png](https://file.liangxiegame.com/18caef79-77b1-41a6-a102-9d53683be04d.png)\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n\r\n## Why？\r\n为什么要搞一个  CodeGenKit？\r\n\r\n因为创建脚本目录、创建脚本文件、声明成员变量或者通过 transform.Find 获取子节点的引用、然后挂脚本、拖拽赋值，这些工作量非常多，而且很繁重，如果能够把这部分工作量通过代码生成并自动赋值的方式给优化掉，那么项目的开发效率就会得到及大地提升。\r\n\r\nCodeGenKit 中的  ViewController 除了可以用于普通的 GameObject，还可以支持 NGUI 和 UGUI 等 UI 组件。\r\n\r\n好了，关于脚本生成的功能介绍到这里。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 如何设置 ViewController 的父类\r\n\r\n当我们给 GameObject 挂上 ViewController 之后，我们就会看到如下图:\r\n\r\n![image-20240508162552269](https://file.liangxiegame.com/59a62ce9-a4a9-4de0-b1b8-9d31e3a5ec72.png)\r\n\r\n图中我们默认继承了 ViewController。\r\n\r\n在很多情况下，我们是有需要设置公共父类的需求的，要想设置公共父类非常简单。\r\n\r\n只需要继承 ViewController 的同时，加上 ViewControllerChildAttribute 即可，代码如下:\r\n```csharp\r\nnamespace QFramework.Gungeon\r\n{\r\n    [ViewControllerChild]\r\n    public abstract class PowerUp : ViewController\r\n    {\r\n        \r\n    }\r\n}\r\n```\r\n\r\n等待编译后，就可以选择了，结果如下:\r\n![img.png](https://file.liangxiegame.com/5fa3e200-832b-45a1-abf2-0c54e25fcc65.png)\r\n\r\n\r\n\r\n\r\n# 04. ActionKit 时序动作执行系统\r\nAciontKit 是一个时序动作执行系统。\r\n\r\n游戏中，动画的播放、延时、资源的异步加载、Tween 的执行、网络请求等，这些全部都是时序任务，而 ActionKit，可以把这些任务全部整合在一起，使用统一的 API，来对他们的执行进行**计划**。\r\n\r\nOK，我们先看下 ActionKit的基本用法。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 延时回调\r\n\r\n示例代码如下:\r\n\r\n```csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class DelayExample : MonoBehaviour\r\n    {\r\n        void Start()\r\n        {\r\n            Debug.Log(\"Start Time:\" + Time.time);\r\n            \r\n            ActionKit.Delay(1.0f, () =>\r\n            {\r\n                Debug.Log(\"End Time:\" + Time.time);\r\n                \r\n            }).Start(this);\r\n        }\r\n    }\r\n}\r\n\r\n// 输出结果\r\n// Start Time: 0\r\n// End Time: 1.00781\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 序列和完成回调\r\n```csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class SequenceAndCallback : MonoBehaviour\r\n    {\r\n        void Start()\r\n        {\r\n            Debug.Log(\"Sequence Start:\" + Time.time);\r\n\r\n            ActionKit.Sequence()\r\n                .Callback(() => Debug.Log(\"Delay Start:\" + Time.time))\r\n                .Delay(1.0f)\r\n                .Callback(() => Debug.Log(\"Delay Finish:\" + Time.time))\r\n                .Start(this, _ => { Debug.Log(\"Sequence Finish:\" + Time.time); });\r\n        }\r\n    }\r\n}\r\n// 输出结果\r\n// Sequence Start:0\r\n// Delay Start:0\r\n// Delay Finish:1.00537\r\n// Sequence Finish:1.00537\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 帧延时\r\n\r\n```csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class DelayFrameExample : MonoBehaviour\r\n    {\r\n        void Start()\r\n        {\r\n            Debug.Log(\"Delay Frame Start FrameCount:\" + Time.frameCount);\r\n            \r\n            ActionKit.DelayFrame(1, () => { Debug.Log(\"Delay Frame Finish FrameCount:\" + Time.frameCount); })\r\n                .Start(this);\r\n\r\n\r\n            ActionKit.Sequence()\r\n                .DelayFrame(10)\r\n                .Callback(() => Debug.Log(\"Sequence Delay FrameCount:\" + Time.frameCount))\r\n                .Start(this);\r\n\r\n            // ActionKit.Sequence()\r\n            //      .NextFrame()\r\n            //      .Start(this);\r\n\r\n            ActionKit.NextFrame(() => { }).Start(this);\r\n        }\r\n    }\r\n}\r\n\r\n// 输出结果\r\n// Delay Frame Start FrameCount:1\r\n// Delay Frame Finish FrameCount:2\r\n// Sequence Delay FrameCount:11\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n\r\n## 条件执行\r\n\r\n```csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class ConditionExample : MonoBehaviour\r\n    {\r\n        private void Start()\r\n        {\r\n            ActionKit.Sequence()\r\n                .Callback(() => Debug.Log(\"Before Condition\"))\r\n                .Condition(() => Input.GetMouseButtonDown(0))\r\n                .Callback(() => Debug.Log(\"Mouse Clicked\"))\r\n                .Start(this);\r\n        }\r\n    }\r\n}\r\n\r\n// 输出结果\r\n// Before Condition\r\n// 鼠标左键按下后\r\n// Mouse Clicked\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 重复执行\r\n\r\n```csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class RepeatExample : MonoBehaviour\r\n    {\r\n        private void Start()\r\n        {\r\n            ActionKit.Repeat()\r\n                .Condition(() => Input.GetMouseButtonDown(0))\r\n                .Callback(() => Debug.Log(\"Mouse Clicked\"))\r\n                .Start(this);\r\n\r\n\r\n            ActionKit.Repeat(5)\r\n                .Condition(() => Input.GetMouseButtonDown(1))\r\n                .Callback(() => Debug.Log(\"Mouse right clicked\"))\r\n                .Start(this, () =>\r\n                {\r\n                    Debug.Log(\"Right click finished\");\r\n                });\r\n        }\r\n    }\r\n}\r\n\r\n// 输出结果\r\n// 每次点击鼠标左键都会输出：Mouse Clicked \r\n// 点击鼠标右键，只会输出五次：Mouse right clicked，第五次输出  Right click finished\r\n// \r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 并行执行\r\n```csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class ParallelExample : MonoBehaviour\r\n    {\r\n        void Start()\r\n        {\r\n            Debug.Log(\"Parallel Start:\" + Time.time);\r\n\r\n            ActionKit.Parallel()\r\n                .Delay(1.0f, () => { Debug.Log(Time.time); })\r\n                .Delay(2.0f, () => { Debug.Log(Time.time); })\r\n                .Delay(3.0f, () => { Debug.Log(Time.time); })\r\n                .Start(this, () =>\r\n                {\r\n                    Debug.Log(\"Parallel Finish:\" + Time.time);\r\n                });\r\n        }\r\n    }\r\n}\r\n\r\n// 输出结果\r\n// Parallel Start:0\r\n// 1.030884\r\n// 2.025135\r\n// 3.018883\r\n// Parallel Finish:3.018883\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 更复杂的示例\r\n\r\n```csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class ComplexExample : MonoBehaviour\r\n    {\r\n        private void Start()\r\n        {\r\n            ActionKit.Sequence()\r\n                .Callback(() => Debug.Log(\"Sequence Start\"))\r\n                .Callback(() => Debug.Log(\"Parallel Start\"))\r\n                .Parallel(p =>\r\n                {\r\n                    p.Delay(1.0f, () => Debug.Log(\"Delay 1s Finished\"))\r\n                        .Delay(2.0f, () => Debug.Log(\"Delay 2s Finished\"));\r\n                })\r\n                .Callback(() => Debug.Log(\"Parallel Finished\"))\r\n                .Callback(() => Debug.Log(\"Check Mouse Clicked\"))\r\n                .Sequence(s =>\r\n                {\r\n                    s.Condition(() => Input.GetMouseButton(0))\r\n                        .Callback(() => Debug.Log(\"Mouse Clicked\"));\r\n                })\r\n                .Start(this, () =>\r\n                {\r\n                    Debug.Log(\"Finish\");\r\n                    \r\n                });\r\n        }\r\n    }\r\n}\r\n\r\n// Sequence Start\r\n// Parallel Start\r\n// Delay 1s Finished\r\n// Delay 2s Finished\r\n// Parallel Finished\r\n// Check Mouse Clicked\r\n// 此时按下鼠标左键\r\n// Mouse Clicked\r\n// Finish\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n\r\n## 自定义动作\r\n\r\n```csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class CustomExample : MonoBehaviour\r\n    {\r\n        class SomeData\r\n        {\r\n            public int ExecuteCount = 0;\r\n        }\r\n\r\n        private void Start()\r\n        {\r\n            ActionKit.Custom(a =>\r\n            {\r\n                a\r\n                    .OnStart(() => { Debug.Log(\"OnStart\"); })\r\n                    .OnExecute(dt =>\r\n                    {\r\n                        Debug.Log(\"OnExecute\");\r\n\r\n                        a.Finish();\r\n                    })\r\n                    .OnFinish(() => { Debug.Log(\"OnFinish\"); });\r\n            }).Start(this);\r\n            \r\n            // OnStart\r\n            // OnExecute\r\n            // OnFinish\r\n\r\n            ActionKit.Custom<SomeData>(a =>\r\n                {\r\n                    a\r\n                        .OnStart(() =>\r\n                        {\r\n                            a.Data = new SomeData()\r\n                            {\r\n                                ExecuteCount = 0\r\n                            };\r\n                        })\r\n                        .OnExecute(dt =>\r\n                        {\r\n                            Debug.Log(a.Data.ExecuteCount);\r\n                            a.Data.ExecuteCount++;\r\n\r\n                            if (a.Data.ExecuteCount >= 5)\r\n                            {\r\n                                a.Finish();\r\n                            }\r\n                        }).OnFinish(() => { Debug.Log(\"Finished\"); });\r\n                })\r\n                .Start(this);\r\n            \r\n            // 0\r\n            // 1\r\n            // 2\r\n            // 3\r\n            // 4\r\n            // Finished\r\n\r\n            // 还支持 Sequence、Repeat、Spawn 等\r\n            // Also support sequence repeat spawn\r\n            // ActionKit.Sequence()\r\n            //     .Custom(c =>\r\n            //     {\r\n            //         c.OnStart(() => c.Finish());\r\n            //     }).Start(this);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 协程支持\r\n\r\n```csharp\r\nusing System.Collections;\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class CoroutineExample : MonoBehaviour\r\n    {\r\n        private void Start()\r\n        {\r\n            ActionKit.Coroutine(SomeCoroutine).Start(this);\r\n            \r\n            SomeCoroutine().ToAction().Start(this);\r\n\r\n            ActionKit.Sequence()\r\n                .Coroutine(SomeCoroutine)\r\n                .Start(this);\r\n        }\r\n\r\n        IEnumerator SomeCoroutine()\r\n        {\r\n            yield return new WaitForSeconds(1.0f);\r\n            Debug.Log(\"Hello:\" + Time.time);\r\n        }\r\n    }\r\n}\r\n\r\n// 输出结果\r\n// Hello:1.002077\r\n// Hello:1.002077\r\n// Hello:1.002077\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 全局 Mono 生命周期\r\n```csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class GlobalMonoEventsExample : MonoBehaviour\r\n    {\r\n        void Start()\r\n        {\r\n            ActionKit.OnUpdate.Register(() =>\r\n            {\r\n                if (Time.frameCount % 30 == 0)\r\n                {\r\n                    Debug.Log(\"Update\");\r\n                }\r\n            }).UnRegisterWhenGameObjectDestroyed(gameObject);\r\n\r\n            ActionKit.OnFixedUpdate.Register(() =>\r\n            {\r\n                // fixed update code here\r\n                // 这里写 fixed update 相关代码\r\n            }).UnRegisterWhenGameObjectDestroyed(gameObject);\r\n            \r\n            ActionKit.OnLateUpdate.Register(() =>\r\n            {\r\n                // late update code here\r\n                // 这里写 late update 相关代码\r\n            }).UnRegisterWhenGameObjectDestroyed(gameObject);\r\n\r\n            ActionKit.OnGUI.Register(() =>\r\n            {\r\n                GUILayout.Label(\"See Example Code\");\r\n                GUILayout.Label(\"请查看示例代码\");\r\n            }).UnRegisterWhenGameObjectDestroyed(gameObject);\r\n\r\n            ActionKit.OnApplicationFocus.Register(focus =>\r\n            {\r\n                Debug.Log(\"focus:\" + focus);\r\n            }).UnRegisterWhenGameObjectDestroyed(gameObject);\r\n\r\n            ActionKit.OnApplicationPause.Register(pause =>\r\n            {\r\n                Debug.Log(\"pause:\" + pause);\r\n            }).UnRegisterWhenGameObjectDestroyed(gameObject);\r\n\r\n            ActionKit.OnApplicationQuit.Register(() =>\r\n            {\r\n                Debug.Log(\"quit\");\r\n            }).UnRegisterWhenGameObjectDestroyed(gameObject);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## DOTween 集成\r\n\r\n需要先提前装好 DOTween。\r\n\r\n然后导入 Example 中的如下包。\r\n\r\n![image.png](https://file.liangxiegame.com/63e3eba5-0dfc-4d53-af56-242d6a308124.png)\r\n\r\n导入之后，就可以用 让 ActionKit 跑 DOTween 了，代码如下:\r\n\r\n```csharp\r\nusing DG.Tweening;\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class DOTweenExample : MonoBehaviour\r\n    {\r\n        private void Start()\r\n        {\r\n            // 使用 Custom 就可以方便接入\r\n            // Just Use Custom \r\n            ActionKit.Custom(c =>\r\n            {\r\n                c.OnStart(() => { transform.DOLocalMove(Vector3.one, 0.5f).OnComplete(c.Finish); });\r\n            }).Start(this);\r\n            \r\n            // 也可以自定义 IAction\r\n            // Also implement with IAction\r\n            DOTweenAction.Allocate(() => transform.DOLocalRotate(Vector3.one, 0.5f))\r\n                .Start(this);\r\n            \r\n            // 使用 ToAction\r\n            // Use ToAction\r\n            DOVirtual.DelayedCall(2.0f, () => LogKit.I(\"2.0f\")).ToAction().Start(this);\r\n\r\n            // 链式 API 支持\r\n            // fluent api support\r\n            ActionKit.Sequence()\r\n                .DOTween(() => transform.DOScale(Vector3.one, 0.5f))\r\n                .Start(this);\r\n        }\r\n    }\r\n    \r\n  \r\n}\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## UniRx 集成\r\n需要先提前装好 UniRx。\r\n\r\n然后导入 Example 中的如下包。\r\n\r\n![image.png](https://file.liangxiegame.com/9b687ee1-83ec-49f5-b315-5795cc72b3ce.png)\r\n\r\n\r\n导入成功后，使用示例如下:\r\n\r\n```csharp\r\nusing System;\r\nusing UniRx;\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class UniRxExample : MonoBehaviour\r\n    {\r\n        void Start()\r\n        {\r\n            // 可以直接使用 Custom\r\n            // directly use custom\r\n            ActionKit.Custom(c =>\r\n            {\r\n                c.OnStart(() => { Observable.Timer(TimeSpan.FromSeconds(1.0f)).Subscribe(_ => c.Finish()); });\r\n            }).Start(this, () => LogKit.I(\"1.0f\"));\r\n\r\n            // 使用 UniRxAction 不方便...\r\n            // Use UniRxAction \r\n            UniRxAction<long>.Allocate(() => Observable.Timer(TimeSpan.FromSeconds(2.0f))).Start(this,()=>LogKit.I(\"2.0f\"));\r\n\r\n\r\n            // 使用 ToAction 方便易用\r\n            // Use ToAction\r\n            Observable.Timer(TimeSpan.FromSeconds(3.0f)).ToAction().Start(this, () => LogKit.I(\"3.0f\"));\r\n\r\n            ActionKit.Sequence()\r\n                .UniRx(() => Observable.Timer(TimeSpan.FromSeconds(4.0f)))\r\n                .Start(this, () => LogKit.I(\"4.0f\"));\r\n        }\r\n    }\r\n \r\n}\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 通过场景时停止\r\n\r\n除了 Start(Component/GameObject) StartGlobal，ActionKit 还提供了 StartCurrentScene 的启动方式。\r\n\r\nStartCurrentScene 会在当前场景切换时会自动停止和回收 Action。\r\n\r\n示例代码如下:\r\n```csharp\r\nusing UnityEngine;\r\nusing UnityEngine.SceneManagement;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class StartCurrentSceneExample : MonoBehaviour\r\n    {\r\n        void Start()\r\n        {\r\n            ActionKit.Sequence()\r\n                .Delay(1.0f)\r\n                .Callback(() =>\r\n                {\r\n                    Debug.Log(\"printed\");\r\n                    SceneManager.LoadScene(SceneManager.GetActiveScene().name);\r\n                })\r\n                .Delay(1.0f)\r\n                .Callback(() =>\r\n                {\r\n                    Debug.Log(\"Not print\");\r\n                })\r\n                .StartCurrentScene();\r\n        }\r\n    }\r\n}\r\n```\r\n运行结果如下:\r\n```csharp\r\n// printed\r\n// 间隔 1 秒\r\n// printed\r\n// 间隔 1 秒\r\n// printed\r\n// 间隔 1 秒\r\n// printed\r\n// 间隔 1 秒\r\n// printed\r\n// ...\r\n```\r\n\r\n永远不会输出代码中的 Not print，因为当场景变更时，会自动停止动作序列的执行。\r\n\r\n好了，这就是 StartCurrentScene 的介绍了。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 不受 TimeScale 限制执行动作\r\n\r\n某天群友提了个功能建议，需要支持不受 TimeScale 的方式执行动作。\r\n\r\n于是笔者给 ActionKit 新增了一个 API：IgnoreTimeScale。\r\n\r\n命名方式和 DOTween 的一样。\r\n\r\n看下示例：\r\n\r\n```csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class IgnoreTimeScaleExample : MonoBehaviour\r\n    {\r\n        private void Start()\r\n        {\r\n            Time.timeScale = 0.25f;\r\n            ActionKit.Sequence()\r\n                .Delay(3.0f)\r\n                .Callback(() =>\r\n                {\r\n                    Debug.Log(\"Scaled Time:\" + Time.time);\r\n                    Debug.Log(\"Unscaled Time:\" + Time.unscaledTime);\r\n                })\r\n                .Start(this)\r\n                .IgnoreTimeScale();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n运行的结果为:\r\n```csharp\r\n// Scaled Time: 0.7585141\r\n// Unscaled Time: 3.02394;\r\n```\r\n\r\n第一个值是理论值，因为 UnscaledTime 会把引擎启动的时间计算进去，笔者实际的第一个值是 0.3 左右。\r\n\r\n不过，在实际游戏里启动的话，这个值会比较精准。\r\n\r\n这就是 IgnoreTimeScale 的用法介绍啦。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n\r\n\r\n\r\n\r\n# 05. SingletonKit 单例套件\r\nSingletonKit 是 QFramework 的第一个收集的工具，经过了 8 年的迭代，现在已经非常成熟了。\r\n\r\n好久不见 ！之前想着让各位直接用 QFramework，但是后来想想，如果正在进行的项目直接使用QFramework，这样风险太高了，要改的代码太多，所以打算陆续独立出来一些工具和模块,允许各位一个模块一个模块的进行更换，减少更换带来的风险。\r\n\r\n## SingletonKit:\r\n\r\n之前有几篇文章介绍过单例模板在 Unity 中的几种实现。之后又参考了其他的单例库的实现，借鉴(chao)了它们的优点,借鉴了哪里有声明原作者。\r\n\r\n## 快速开始:\r\n\r\n实现一个继承 MonoBehaviour 的单例类\r\n\r\n```csharp\r\nnamespace QFramework.Example\r\n{\r\n\t[MonoSingletonPath(\"[Audio]/AudioManager\")]\r\n\tpublic class AudioManager : ManagerBase,ISingleton\r\n\t{\r\n\t\tpublic static AudioManager Instance\r\n\t\t{\r\n\t\t\tget { return QMonoSingletonProperty<AudioManager>.Instance; }\r\n\t\t}\r\n\t\t\r\n\t\tpublic void OnSingletonInit()\r\n\t\t{\r\n\t\t\t\r\n\t\t}\r\n\r\n\t\tpublic void Dispose()\r\n\t\t{\r\n\t\t\tQMonoSingletonProperty<AudioManager>.Dispose();\r\n\t\t}\r\n\r\n\r\n\t\tpublic void PlaySound(string soundName)\r\n\t\t{\r\n\t\t\t\r\n\t\t}\r\n\r\n\t\tpublic void StopSound(string soundName)\r\n\t\t{\r\n\t\t\t\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n结果如下:\r\n![DraggedImage.png](https://upload-images.jianshu.io/upload_images/2296785-a0d55653522f9037.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n这样从头到尾都很！优！雅！\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## C# 单例类\r\n\r\n*   Singleton.cs\r\n\r\n```csharp\r\npublic class GameDataManager : Singleton<GameDataManager>\r\n{\r\n    private static int mIndex = 0;\r\n\r\n    private Class2Singleton() {}\r\n\r\n    public override void OnSingletonInit()\r\n    {\r\n        mIndex++;\r\n    }\r\n\r\n    public void Log(string content)\r\n    {\r\n        Debug.Log(\"\"GameDataManager\"\" + mIndex + \"\":\"\" + content);\r\n    }\r\n}\r\n\r\nGameDataManager.Instance.Log(\"\"Hello\"\");\r\n// GameDataManager1:OnSingletonInit:Hello\r\nGameDataManager.Instance.Log(\"\"Hello\"\");\r\n// GameDataManager1:OnSingletonInit:Hello\r\nGameDataManager.Instance.Dispose();\r\n```\r\n\r\n只需简单继承QSingleton，并声明非public构造方法即可。如果有需要获取单例初始化的时机，则可以选择重载OnSingletonInit方法。\r\n\r\n## 结果:\r\n``` \r\nHello World!\r\nHello World!\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## Mono 单例\r\n\r\n* MonoSingleton.cs\r\n```csharp\r\npublic class GameManager : MonoSingleton<GameManager>\r\n{\r\n    public override void OnSingletonInit()\r\n    {\r\n        Debug.Log(name + \"\":\"\" + \"\"OnSingletonInit\"\");\r\n    }\r\n\r\n    private void Awake()\r\n    {\r\n        Debug.Log(name + \"\":\"\" + \"\"Awake\"\");\r\n    }\r\n\r\n    private void Start()\r\n    {\r\n        Debug.Log(name + \"\":\"\" + \"\"Start\"\");\r\n    }\r\n\r\n    protected override void OnDestroy()\r\n    {\r\n        base.OnDestroy();\r\n\t\t\t\r\n        Debug.Log(name + \"\":\"\" + \"\"OnDestroy\"\");\r\n    }\r\n}\r\n\r\nvar gameManager = GameManager.Instance;\r\n// GameManager:OnSingletonInit\r\n// GameManager:Awake\r\n// GameManager:Start\r\n// ---------------------\r\n// GameManager:OnDestroy\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## Mono 属性单例\r\n代码如下:\r\n\r\n* MonoSingletonProperty.cs\r\n```csharp\r\npublic class GameManager : MonoBehaviour,ISingleton\r\n{\r\n    public static GameManager Instance\r\n    {\r\n        get { return MonoSingletonProperty<GameManager>.Instance; }\r\n    }\r\n\t\t\r\n    public void Dispose()\r\n    {\r\n    \tMonoSingletonProperty<GameManager>.Dispose();\r\n    }\r\n\t\t\r\n    public void OnSingletonInit()\r\n    {\r\n    \tDebug.Log(name + \"\":\"\" + \"\"OnSingletonInit\"\");\r\n    }\r\n    \r\n    private void Awake()\r\n    {\r\n        Debug.Log(name + \"\":\"\" + \"\"Awake\"\");\r\n    }\r\n    \r\n    private void Start()\r\n    {\r\n        Debug.Log(name + \"\":\"\" + \"\"Start\"\");\r\n    }\r\n    \r\n    protected void OnDestroy()\r\n    {\r\n        Debug.Log(name + \"\":\"\" + \"\"OnDestroy\"\");\r\n    }\r\n}\r\nvar gameManager = GameManager.Instance;\r\n// GameManager:OnSingletonInit\r\n// GameManager:Awake\r\n// GameManager:Start\r\n// ---------------------\r\n// GameManager:OnDestroy\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## C# 属性单例\r\n\r\n代码如下：\r\n\r\n* SingletonProperty.cs\r\n```csharp\r\npublic class GameDataManager : ISingleton\r\n{\r\n    public static GameDataManager Instance\r\n    {\r\n        get { return SingletonProperty<GameDataManager>.Instance; }\r\n    }\r\n\r\n    private GameDataManager() {}\r\n\t\t\r\n    private static int mIndex = 0;\r\n\r\n    public void OnSingletonInit()\r\n    {\r\n        mIndex++;\r\n    }\r\n\r\n    public void Dispose()\r\n    {\r\n        SingletonProperty<GameDataManager>.Dispose();\r\n    }\r\n\t\t\r\n    public void Log(string content)\r\n    {\r\n        Debug.Log(\"\"GameDataManager\"\" + mIndex + \"\":\"\" + content);\r\n    }\r\n}\r\n \r\nGameDataManager.Instance.Log(\"\"Hello\"\");\r\n// GameDataManager1:OnSingletonInit:Hello\r\n \r\nGameDataManager.Instance.Log(\"\"Hello\"\");\r\n// GameDataManager1:OnSingletonInit:Hello\r\n \r\nGameDataManager.Instance.Dispose();\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n\r\n## MonoSingletPath 重命名\r\n\r\n\r\n代码如下：\r\nMonoSingletonPath.cs：\r\n\r\n```csharp\r\nnamespace QFramework.Example\r\n{\r\n\tusing UnityEngine;\r\n\r\n\t[MonoSingletonPath(\"[Example]/MonoSingeltonPath\")]\r\n\tclass ClassUseMonoSingletonPath : QMonoSingleton<ClassUseMonoSingletonPath>\r\n\t{\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic class MonoSingletonPath : MonoBehaviour\r\n\t{\r\n\t\tprivate void Start()\r\n\t\t{\r\n\t\t\tvar intance = ClassUseMonoSingletonPath.Instance;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## 结果:\r\n![DraggedImage.png](https://upload-images.jianshu.io/upload_images/2296785-8bf380c8327ffbce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n\r\n## PersistentMonoSingleton\r\n\r\n当场景里包含两个 PersistentMonoSingleton，保留先创建的\r\n\r\n```csharp\r\npublic class GameManager : PersistentMonoSingleton<GameManager>\r\n{\r\n \r\n}\r\n \r\nIEnumerator Start()\r\n{\r\n    var gameManager = GameManager.Instance;\r\n \r\n    var newGameManager = new GameObject().AddComponent<GameManager>();\r\n \r\n    yield return new WaitForEndOfFrame();\r\n \r\n    Debug.Log(FindObjectOfTypes<GameManager>().Length);\r\n    // 1\r\n    Debug.Log(gameManager == null);\r\n    // false\r\n    Debug.Log(newGameManager == null);\r\n    // true\r\n}\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## ReplaceableMonoSingleton\r\n\r\n当场景里包含两个 ReplaceableMonoSingleton，保留最后创建的\r\n\r\n```csharp\r\npublic class GameManager : ReplaceableMonoSingleton<GameManager>\r\n{\r\n \r\n}\r\n\r\nIEnumerator Start()\r\n{\r\n    var gameManager = GameManager.Instance;\r\n \r\n    var newGameManager = new GameObject().AddComponent<GameManager>();\r\n \r\n    yield return new WaitForEndOfFrame();\r\n \r\n    Debug.Log(FindObjectOfTypes<GameManager>().Length);\r\n    // 1\r\n    Debug.Log(gameManager == null);\r\n    // true\r\n    Debug.Log(newGameManager == null);\r\n    // false\r\n}\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n# 4. 解决方案篇\r\n# 01. ResKit：资源管理&开发解决方案\r\n## Res Kit 简介\r\nRes Kit，是资源管理&快速开发解决方案\r\n\r\n**特性如下:**\r\n* 可以使用一个 API 从  dataPath、Resources、StreammingAssetPath、PersistentDataPath、网络等地方加载资源。\r\n* 基于引用计数，简化资源加载和卸载。\r\n* 拥抱游戏开发流程中的不同阶段\r\n    * 开发阶段不用打 AB 直接从 dataPath 加载。\r\n    * 测试阶段支持只需打一次 AB 即可。\r\n* 可选择生成资源名常量代码，减少拼写错误。\r\n* 异步加载队列支持\r\n* 对于 AssetBundle 资源，可以只通过资源名而不是 AssetBundle 名 + 资源名 加载资源，简化 API 使用。\r\n\r\n\r\n## Res Kit 快速入门\r\n我们知道，在一般情况下，有两种方式可以让我们实现动态加载资源：\r\n* Resources\r\n* AssetBundle\r\n\r\n在 Res Kit 中，推荐使用 AssetBundle 的方式进行加载，因为 Res Kit 所封装的 AssetBundle 方式，比 Resources 的方式更好用。\r\n\r\n除了 Res Kit 中的 AsseBundle 方式更易用外，AssetBundle 本身相比 Resources 有更多的优点，比如更小的包体，支持热更等。\r\n\r\n废话不多说，我们看下 Res Kit 的基本使用。\r\n\r\nRes Kit 在开发阶段，分为两步。\r\n* 标记资源\r\n* 写代码\r\n\r\n在开始之前，我们要确保，当前的 Res Kit 环境为模拟模式。\r\n\r\n按下快捷键 ctrl + e 或者 ctrl + shift + r ，我们可以看到如下面板:\r\n\r\n![image.png](https://file.liangxiegame.com/d6d1ac25-4c60-4b42-81ec-51b1628b640a.png)\r\n\r\n确保模拟模式勾选之后，我们就可以进入使用流程了。\r\n\r\n### 1. 资源标记\r\n\r\n在 Asset 目录下，只需对需要标记的文件或文件夹右键->@ResKit- AssetBundle Mark，如下所示：\r\n\r\n![image.png](https://file.liangxiegame.com/2d793421-94cb-457f-80da-ee976f700f02.png)\r\n\r\n标记完了，\r\n\r\n标记成功后，我们可以看到如下结果：\r\n\r\n1. 该资源标记的选项为勾选状态\r\n\r\n![image.png](https://file.liangxiegame.com/1ced7efd-a328-4c5e-a76a-4a85020acdd2.png)\r\n\r\n2. 该资源的 AssetLabel 中的名字如下\r\n   ![image.png](https://file.liangxiegame.com/a7e20396-e553-4ead-8291-e4395fe53b30.png)\r\n\r\n这样就标记成功了。\r\n\r\n这里注意，一次标记就是一个 AssetBundle，如果想要让 AssetBundle 包含多个资源，可以将多个资源放到一个文件夹中，然后标记文件夹。\r\n\r\n\r\n### 2.资源加载\r\n接下来我们直接写资源加载的代码即可，代码如下，具体的代码含义，看注释即可。。\r\n\r\n```csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class ResKitExample : MonoBehaviour\r\n    {\r\n        // 每个脚本都需要\r\n        private ResLoader mResLoader = ResLoader.Allocate();\r\n\r\n        private void Start()\r\n        {\r\n            // 项目启动只调用一次即可\r\n            ResKit.Init();\r\n            \r\n            // 通过资源名 + 类型搜索并加载资源（更方便）\r\n            var prefab = mResLoader.LoadSync<GameObject>(\"AssetObj\");\r\n            var gameObj = Instantiate(prefab);\r\n            gameObj.name = \"这是使用通过 AssetName 加载的对象\";\r\n\r\n            // 通过 AssetBundleName 和 资源名搜索并加载资源（更精确）\r\n            prefab = mResLoader.LoadSync<GameObject>(\"assetobj_prefab\", \"AssetObj\");\r\n            gameObj = Instantiate(prefab);\r\n            gameObj.name = \"这是使用通过 AssetName  和 AssetBundle 加载的对象\";\r\n        }\r\n\r\n        private void OnDestroy()\r\n        {\r\n            // 释放所有本脚本加载过的资源\r\n            // 释放只是释放资源的引用\r\n            // 当资源的引用数量为 0 时，会进行真正的资源卸载操作\r\n            mResLoader.Recycle2Cache();\r\n            mResLoader = null;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n将此脚本挂到任意 GameObject 上，运行后，结果如下:\r\n\r\n\r\n![image.png](https://file.liangxiegame.com/04cd1727-b7ad-436d-988c-80b70c0fc106.png)\r\n\r\n资源加载成功。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 模拟模式与非模拟模式\r\n\r\n### AssetBundle 的不便之处\r\n在使用 Res Kit 之前，相信大家多多少少接触过 AssetBundle。 有的童鞋可能是在项目中用过 AssetBundle，有的童鞋可能只是简单学习过 AssetBundle。总之，AssetBundle 在不通过 Res Kit 使用之前，总结下来就两个字：麻烦。\r\n\r\nAssetBundle 麻烦在哪里呢？\r\n\r\n首先 AssetBundle，需要打包才能在运行时加载资源。而打包需要我们写编辑器扩展脚本，在编辑器扩展脚本中还要处理平台和路径相关的逻辑。\r\n\r\n在运行时，还需要根据平台和路径去加载对应的 AssetBundle。\r\n\r\n这些操作想想就比较头痛。\r\n\r\n既然 AssetBundle 这么麻烦，我们为什么还要用 AssetBundle 呢？\r\n\r\n因为 AssetBundle 可以给项目带来更好的性能，而且 AssetBundle 支持热更新。\r\n\r\n有了这两个优势，AssetBundle 就成了很多项目的必然选择。\r\n\r\n而 Res Kit 中，为了解决频繁打包的问题，引入了一个概念：模拟模式（Simulation Mode）。\r\n\r\n#### 模拟模式（Simulation Mode）\r\n\r\n**什么是模拟模式？**\r\n\r\n顾名思义，就是模拟加载 AssetBundle 的模式，这里只是模拟，并没有真正去加载 AssetBundle，而是去加载 Application.dataPath 目录下的资源，也就是 Assets 目录下的资源。\r\n\r\n**这样做有什么好处呢？**\r\n\r\n好处就是每当有资源修改的时候，就不用再打 AB 包了，就可以在运行时加载到修改后的资源。\r\n\r\n如果是非模拟模式下，每当有资源修改时，就需要再打一次 AB 包，才能加载到修改后的资源。\r\n\r\n所以一个模拟模式，解决了频繁打 AB 包的问题，从而在开发阶段提高我们的开发效率。\r\n\r\n那么在使用 Res Kit 的时候，模拟模式对应的阶段是开发阶段，那么非模拟模式对应的是什么阶段呢？\r\n\r\n答案就是真机阶段。\r\n\r\n### 开发阶段、真机阶段\r\n开发阶段、真机阶段并不是 Unity 提供的概念，而是笔者在迭代 Res Kit 中提出的两个概念。\r\n\r\n这两个概念很容易理解：\r\n* 开发阶段：开发逻辑的阶段，需要编写大量的逻辑，大部分情况下都在 Unity Editor 环境下开发。\r\n* 真机阶段：需要在真机上运行的阶段，这个阶段主要是做大量的测试或者真正发布了。\r\n\r\n相信有点规模的项目都会分阶段出来的，比如开发阶段、测试阶段、生产阶段等等，大家理解起来应该不难。\r\n\r\n接下来简单分析一下开发阶段、真机阶段的特点。\r\n\r\n**开发阶段**\r\n在开发阶段，开发者需要写大量的逻辑，而且资源的目录还没有稳定，一般在开发过程中会有很大的变化。\r\n如果每次资源的修改都需要打 AB 包的话，会非常影响开发进度。\r\n\r\n**真机阶段**\r\n真机阶段，一般就是一个版本的逻辑都写完了，只需要做一些测试和 debug 工作。在这个阶段，资源目录都稳定了，不需要做很大的调整。\r\n\r\n在真机阶段，每次打 App 包之前，只需要 Build 一次 AB 即可。\r\n\r\n当然，在 Unity Editor 环境中，可以取消勾选模拟模式，这样在 Unity Editor 环境下可以加载真正的 AssetBundle 包。\r\n\r\n在上一篇文章所说的，拥抱各个开发阶段指的就是为开发阶段、和真机阶段做了考虑。\r\n\r\n此篇的内容就这些。\r\n\r\n### 小结\r\n* 开发阶段：\r\n    *  模拟模式\r\n* 真机阶段：\r\n    * 每次打 App 包之前，打一次 AB 包。\r\n    * 可以在 Unity Editor 环境下，取消勾选模拟模式，这时在运行时加载的资源则是真正的 AssetBundle 资源\r\n\r\n\r\n## 如何打 AssetBundle（真机模式）\r\n\r\n\r\n![image.png](https://file.liangxiegame.com/bcc21643-8c4a-4f6f-b3a9-db1ec3071119.png)\r\n\r\n取消勾选模拟模式情况下，点击打 AB 包 即可。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 异步加载\r\n异步加载代码如下:\r\n``` csharp\r\n// 添加到加载队列\r\nmResLoader.Add2Load(\"TestObj\",(succeed,res)=>{\r\n    if (succeed) \r\n    {\r\n        res.Asset.As<GameObject>()\r\n\t\t\t\t\t\t.Instantiate();\r\n    }\r\n});\r\n\r\n// 执行异步加载\r\nmResLoader.LoadAsync();\r\n```\r\n与 LoadSync 不同的是，异步加载是分两步的，第一步是添加到加载队列，第二步是执行异步加载。\r\n\r\n这样做是为了支持同时异步加载多个资源的。\r\n\r\n## 异步加载\r\n代码如下:\r\n```csharp\r\nusing System.Collections;\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class AsyncLoadExample : MonoBehaviour\r\n    {\r\n        IEnumerator Start()\r\n        {\r\n            yield return ResKit.InitAsync();\r\n\r\n            var resLoader = ResLoader.Allocate();\r\n            \r\n            resLoader.Add2Load<GameObject>(\"AssetObj 1\",(b, res) =>\r\n            {\r\n                if (b)\r\n                {\r\n                    res.Asset.As<GameObject>().Instantiate();\r\n                }\r\n            });\r\n\r\n            // AssetBundleName + AssetName\r\n            resLoader.Add2Load<GameObject>(\"assetobj 2_prefab\",\"AssetObj 2\",(b, res) =>\r\n            {\r\n                if (b)\r\n                {\r\n                    res.Asset.As<GameObject>().Instantiate();\r\n                }\r\n            });\r\n            \r\n            resLoader.Add2Load<GameObject>(\"AssetObj 3\",(b, res) =>\r\n            {\r\n                if (b)\r\n                {\r\n                    res.Asset.As<GameObject>().Instantiate();\r\n                }\r\n            });\r\n\r\n            resLoader.LoadAsync(() =>\r\n            {\r\n                // 加载成功 5 秒后回收\r\n                ActionKit.Delay(5.0f, () =>\r\n                {\r\n                    resLoader.Recycle2Cache();\r\n\r\n                }).Start(this);\r\n            });\r\n        }\r\n\r\n    }\r\n}\r\n```\r\n\r\n结果如下:\r\n\r\n![image.png](https://file.liangxiegame.com/8ad406e4-f59c-43d2-bd4a-e7de57560958.png)\r\n\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 加载场景\r\n\r\n注意：标记场景时要确保，一个场景是一个 AssetBundle。\r\n\r\n```csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n\tpublic class LoadSceneExample : MonoBehaviour\r\n\t{\r\n\t\tprivate ResLoader mResLoader = null;\r\n\r\n\t\tvoid Start()\r\n\t\t{\r\n\t\t\tResKit.Init();\r\n\r\n\t\t\tmResLoader = ResLoader.Allocate();\r\n\r\n\t\t\t// 同步加载\r\n\t\t\tmResLoader.LoadSceneSync(\"SceneRes\");\r\n\r\n\t\t\t// 异步加载\r\n\t\t\tmResLoader.LoadSceneAsync(\"SceneRes\");\r\n\r\n\t\t\t// 异步加载\r\n\t\t\tmResLoader.LoadSceneAsync(\"SceneRes\", onStartLoading: operation =>\r\n\t\t\t{\r\n\t\t\t\t// 做一些加载操作\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tprivate void OnDestroy()\r\n\t\t{\r\n\t\t\tmResLoader.Recycle2Cache();\r\n\t\t\tmResLoader = null;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 加载 Resources 中的资源\r\n\r\n```csharp\r\nusing UnityEngine;\r\nusing UnityEngine.UI;\r\n\r\nnamespace QFramework.Example\r\n{\r\n\tpublic class LoadResourcesResExample : MonoBehaviour\r\n\t{\r\n\t\tpublic RawImage RawImage;\r\n\t\t\r\n\t\tprivate ResLoader mResLoader = ResLoader.Allocate();\r\n\t\t\r\n\t\tprivate void Start()\r\n\t\t{\r\n\t\t\t//  加载 Resources 目录里的资源不用调用 ResKit.Init\r\n\t\t\t\r\n\t\t\tRawImage.texture = mResLoader.LoadSync<Texture2D>(\"resources://TestTexture\");\r\n\t\t}\r\n\r\n\t\tprivate void OnDestroy()\r\n\t\t{\r\n\t\t\tDebug.Log(\"On Destroy \");\r\n\t\t\tmResLoader.Recycle2Cache();\r\n\t\t\tmResLoader = null;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 关联对象管理\r\n\r\n```csharp\r\nusing System.Collections;\r\nusing UnityEngine;\r\nusing UnityEngine.UI;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class ResLoaderRelateUnloadAssetExample : MonoBehaviour\r\n    {\r\n        // Use this for initialization\r\n        IEnumerator Start()\r\n        {\r\n            var image = transform.Find(\"Image\").GetComponent<Image>();\r\n\r\n            ResKit.Init();\r\n\r\n            var resLoader = ResLoader.Allocate();\r\n            \r\n            var texture2D = resLoader.LoadSync<Texture2D>(\"TextureExample1\");\r\n\r\n            // create Sprite 扩展\r\n            var sprite = Sprite.Create(texture2D, new Rect(0, 0, texture2D.width, texture2D.height), Vector2.one * 0.5f);\r\n\r\n            image.sprite = sprite;\r\n\r\n            // 添加关联的 Sprite\r\n            resLoader.AddObjectForDestroyWhenRecycle2Cache(sprite);\r\n\r\n            yield return new WaitForSeconds(5.0f);\r\n            \r\n            // 当释放时 sprite 也会销毁\r\n            resLoader.Recycle2Cache();\r\n            resLoader = null;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## SpriteAtlas 加载\r\n\r\n```csharp\r\nusing System.Collections;\r\nusing UnityEngine;\r\nusing UnityEngine.U2D;\r\nusing UnityEngine.UI;\r\n\r\nnamespace QFramework\r\n{\r\n\t/// <inheritdoc />\r\n\t/// <summary>\r\n\t/// 参考:http://www.cnblogs.com/TheChenLin/p/9763710.html\r\n\t/// </summary>\r\n\tpublic class TestSpriteAtlas : MonoBehaviour\r\n\t{\r\n\t\t[SerializeField] private Image mImage;\r\n\r\n\t\t// Use this for initialization\r\n\t\tprivate IEnumerator Start()\r\n\t\t{\r\n\t\t\tvar loader = ResLoader.Allocate();\r\n\r\n\t\t\tResKit.Init();\r\n\r\n\t\t\tvar spriteAtlas = loader.LoadSync<SpriteAtlas>(\"spriteatlas\");\r\n\t\t\tvar square = spriteAtlas.GetSprite(\"shop\");\r\n\t\t\t\r\n\t\t\tloader.AddObjectForDestroyWhenRecycle2Cache(square);\r\n\r\n\t\t\tmImage.sprite = square;\r\n\r\n\t\t\tyield return new WaitForSeconds(5.0f);\r\n\r\n\t\t\tloader.Recycle2Cache();\r\n\t\t\tloader = null;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 加载网络图片\r\n\r\n```csharp\r\nusing UnityEngine;\r\nusing UnityEngine.UI;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class NetImageExample : MonoBehaviour\r\n    {\r\n        ResLoader mResLoader = ResLoader.Allocate();\r\n\r\n        // Use this for initialization\r\n        void Start()\r\n        {\r\n            var image = transform.Find(\"Image\").GetComponent<Image>();\r\n            \r\n            mResLoader.Add2Load<Texture2D>(\r\n                \"http://pic.616pic.com/ys_b_img/00/44/76/IUJ3YQSjx1.jpg\".ToNetImageResName(),\r\n                (b, res) =>\r\n                {\r\n                    if (b)\r\n                    {\r\n                        var texture = res.Asset as Texture2D;\r\n\r\n                        var sprite = Sprite.Create(texture, new Rect(0, 0, texture.width, texture.height),\r\n                            Vector2.one * 0.5f);\r\n                        image.sprite = sprite;\r\n                        mResLoader.AddObjectForDestroyWhenRecycle2Cache(sprite);\r\n                    }\r\n                });\r\n            \r\n            mResLoader.LoadAsync();\r\n        }\r\n        \r\n        private void OnDestroy()\r\n        {\r\n            mResLoader.Recycle2Cache();\r\n            mResLoader = null;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 从 PersistentDataPath 加载图片\r\n```csharp\r\nnamespace QFramework.Example\r\n{\r\n\tusing System.Collections;\r\n\tusing UnityEngine.UI;\r\n\tusing UnityEngine;\r\n\t\r\n\tpublic class ImageLoaderExample : MonoBehaviour\r\n\t{\r\n\t\tprivate ResLoader mResLoader = null;\r\n\r\n\t\tprivate IEnumerator Start()\r\n\t\t{\r\n\t\t\tResMgr.Init();\r\n\t\t\t\r\n\t\t\tmResLoader = ResLoader.Allocate();\r\n\r\n\t\t\t// local image\r\n\t\t\tvar localImageUrl = \"file://\" + Application.persistentDataPath + \"/Workspaces/lM1wmsLQtfzRQc6fsdEU.jpg\";\r\n\r\n\t\t\tmResLoader.Add2Load(localImageUrl.ToLocalImageResName(),\r\n\t\t\t\tdelegate(bool b, IRes res)\r\n\t\t\t\t{\r\n\t\t\t\t\tDebug.LogError(b);\r\n\t\t\t\t\tif (b)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvar texture2D = res.Asset as Texture2D;\r\n\t\t\t\t\t\ttransform.Find(\"Image\").GetComponent<Image>().sprite = Sprite.Create(texture2D,\r\n\t\t\t\t\t\t\tnew Rect(0, 0, texture2D.width, texture2D.height), Vector2.one * 0.5f);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\r\n\t\t\tmResLoader.LoadAsync();\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tyield return new WaitForSeconds(5.0f);\r\n\t\t\tmResLoader.Recycle2Cache();\r\n\t\t\tmResLoader = null;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 自定义 Res\r\n\r\nResKit 提供了 自定义 Res ，通过自定义 Res 可以非常方便地自定义 Res 的加载来源，比如 PersistentDataPath、StreamingAssetPath、AssetBundle 等，甚至是内存中的 GameObject 等资产，还可以集成 Addressables 或者其他的资源管理方案，ResKit 内置支持的 AssetBundle、Resources、网络图片加载、PersistentDataPath 图片加载都是通过自定义 Res 的方式扩展而来。\r\n\r\n我们看下自定义 Res 的用法，如下:\r\n```csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework\r\n{\r\n    public class CustomResExample : MonoBehaviour\r\n    {\r\n        // 自定义的 Res\r\n        public class MyRes : Res\r\n        {\r\n            public MyRes(string name)\r\n            {\r\n                mAssetName = name;\r\n            }\r\n\r\n            // 同步加载（自己实现）\r\n            public override bool LoadSync()\r\n            {\r\n                // Asset = 加载的结果给 Asset 赋值 \r\n                State = ResState.Ready;\r\n                return true;\r\n            }\r\n\r\n            // 异步加载(自己实现)\r\n            public override void LoadAsync()\r\n            {\r\n                // Asset = 加载的结果给 Asset 赋值 \r\n                State = ResState.Ready;\r\n            }\r\n            \r\n\r\n            // 释放资源（自己实现)\r\n            protected override void OnReleaseRes()\r\n            {\r\n                // 卸载操作\r\n                // Asset = null\r\n                State = ResState.Waiting;\r\n            }\r\n        }\r\n\r\n        // 自定义的 Res 创建器（包含识别功能）\r\n        public class MyResCreator : IResCreator\r\n        {\r\n            // 识别\r\n            public bool Match(ResSearchKeys resSearchKeys)\r\n            {\r\n                return resSearchKeys.AssetName.StartsWith(\"myres://\");\r\n            }\r\n\r\n            // 创建\r\n            public IRes Create(ResSearchKeys resSearchKeys)\r\n            {\r\n                return new MyRes(resSearchKeys.AssetName);\r\n            }\r\n        }\r\n\r\n        void Start()\r\n        {\r\n            // 添加创建器\r\n            ResFactory.AddResCreator<MyResCreator>();\r\n\r\n            var resLoader = ResLoader.Allocate();\r\n\r\n            var resSearchKeys = ResSearchKeys.Allocate(\"myres://hello_world\");\r\n            \r\n            var myRes =  resLoader.LoadResSync(resSearchKeys);\r\n            \r\n            resSearchKeys.Recycle2Cache();\r\n            \r\n            Debug.Log(myRes.AssetName);\r\n            Debug.Log(myRes.State);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n非常简单。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 代码生成\r\n\r\nRes Kit 支持代码生成，生成按钮的位置如下所示:\r\n![image.png](https://file.liangxiegame.com/e482f08e-2e8e-4b43-84bf-f32722cc5f5c.png)\r\n点击生成代码即可，生成后结果如下。\r\n![image.png](https://file.liangxiegame.com/0ea13581-4960-4bc8-bbf1-b49a03455271.png)\r\n\r\n生成了 QAssets 代码文件，代码内容如下:\r\n\r\n```csharp\r\nnamespace QAssetBundle\r\n{\r\n  \r\n    public class Testobj_prefab\r\n    {\r\n        public const string BundleName = \"testobj_prefab\";\r\n        public const string TESTOBJ = \"testobj\";\r\n    }\r\n    public class Testsprite_png\r\n    {\r\n        public const string BundleName = \"testsprite_png\";\r\n        public const string TESTSPRITE = \"testsprite\";\r\n    }\r\n}\r\n\r\n```\r\n\r\n生成了代码，那么在写资源加载的代码的时候就会爽的飞起，如下图示:\r\n![image.png](https://file.liangxiegame.com/7b8ae854-aafe-49d8-9318-5f7d1190c8cc.png)\r\n\r\n图中，给出了资源名字的提示。\r\n\r\n这样就不容易出现字符串的拼写错误了。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## ResLoader 推荐用法\r\n\r\nResLoader 的推荐用法，是一个需要加载的单元申请一个 ResLoader。\r\n\r\n代码如下:\r\n\r\n```csharp\r\nusing QF.Res;\r\nusing QF.Extensions;\r\nusing UnityEngine;\r\n\r\nnamespace QF.Example \r\n{\r\n\tpublic class TestResKit : MonoBehaviour \r\n\t{\r\n\t\t/// <summary>\r\n\t\t/// 每一个需要加载资源的单元（脚本、界面）申请一个 ResLoader\r\n\t\t/// ResLoader 本身会记录该脚本加载过的资源\r\n\t\t/// </summary>\r\n\t\t/// <returns></returns>\r\n\t\tResLoader mResLoader = ResLoader.Allocate ();\r\n  \r\n    ...\r\n  \r\n        void Destroy()\r\n\t\t{\r\n\t\t\t// 释放所有本脚本加载过的资源\r\n\t\t\t// 释放只是释放资源的引用\r\n\t\t\t// 当资源的引用数量为 0 时，会进行真正的资源卸载操作\r\n\t\t\tmResLoader.Recycle2Cache();\r\n\t\t\tmResLoader = null;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n在以上代码中，TestResKit 是一个需要加载资源的单元。\r\n\r\n**这个单元是什么意思呢？**\r\n\r\n其实很简单，单元可以是 UIPanel （界面），或者任何需要加载资源服务的 MonoBehaviour。\r\n\r\n## ResLoader 的职责\r\n\r\nResLoader 的职责字如其意，就是负责加载资源的，即资源加载器。\r\n\r\n一个 ResLoader 会记录所有它加载过的资源。\r\n\r\n这样它在释放资源的时候只需要根据加载记录，进行释放即可。\r\n\r\nResLoader 与 单元（Test 脚本）的示意图如下:\r\n![image.png](https://file.liangxiegame.com/296b0166-bdea-47d5-ac87-4b55c91df16f.png)\r\n\r\n这里我们要注意，ResLoader 不是进行真正的资源加载操作，而是进行资源的引用获取。\r\n\r\n真正的资源加载是在 ResMgr 中完成，这个过程用户是无法感知的到的。\r\n\r\nResLoader 获取资源引用的过程如下:\r\n\r\n1. 从 ResLoader 的引用记录中查询是否已经获取了引用，如果之前已经在 ResLoader 记录过资源引用则返回资源。否则执行 2.\r\n2. 从 ResMgr 中查询是否已经有资源对象，如果有资源对象，返回资源，并在 ResLoader 中记录引用，同时对资源对象进行引用计数 +1 操作，否则执行 3.\r\n3. 让 ResMgr 进行资源加载，同时创建资源对象，剩下的步骤同 2。\r\n\r\n大致的访问资源的过程就是如此，不理解的童鞋不要紧，因为对使用上来说不重要。\r\n\r\n我们只需要知道，建议每个需要加载的脚本申请一个 ResLoader，是为了更方便地让大家进行资源管理。\r\n\r\n不管这个脚本加载过多少个东西，也不管别的脚本加载过多少，只需要各自脚本释放自己的 ResLoader 即可。\r\n\r\n因为每个资源对象对集成了引用计数的。\r\n\r\n## 申请 ResLoader 的消耗\r\n\r\n几乎没有消耗，因为 ResLoader 是从对象池中申请的。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## WebGL 注意事项补充\r\n\r\n在 WebGL 平台 ResKit 加载 AssetBundle 资源只支持异步加载。\r\n\r\n\r\n异步初始化\r\n```csharp\r\nStartCoroutine(ResKit.InitAsync());\r\n// 或者\r\nResKit.InitAsync().ToAction().StartGlobal();\r\n```\r\n\r\n异步加载资源\r\n* 先 Add2Load\r\n* 再调用 LoadAsync()\r\n\r\n\r\n好了，ResKit 的功能就全部介绍完了。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n\r\n\r\n\r\n\r\n\r\n# 02. UIKit：界面管理&快速开发解决方案\r\n## UI Kit 简介\r\n\r\nUI Kit 是一套界面管理&快速开发解决方案\r\n\r\nUI Kit 的特性如下：\r\n\r\n* 界面管理\r\n* 层级管理\r\n* 代码生成及组件自动绑定（底层用的 ViewController)\r\n\r\n\r\n## UI Kit 基本使用\r\n\r\nUI Kit 本身有一套推荐使用的工作流程，而此工作流程的设计是为了使每个界面只负责展示数据和监听用户输入，界面与界面之间互相独立，并且可独立测试。\r\n\r\n下面我们将介绍如何制作一个游戏主页（UIBasicPanel）。\r\n\r\n首先我们先创建一个场景：TestUIBasicPanel，如下图所示:\r\n\r\n![image-20220725171613899](https://file.liangxiegame.com/1b23e2de-9af1-4ce7-b5fd-7f1af8f1688b.png)\r\n\r\n在这里大家要注意一下，UI Kit 推荐每个界面创建一个对应的测试场景，要保证每个界面是可以独立测试的。\r\n\r\n\r\n\r\n接着打开 TestUIBasicPanel 如下所示：\r\n\r\n![image-20220725171641152](https://file.liangxiegame.com/0f2accd3-1836-4d38-9858-3cc7828dc72f.png)\r\n\r\n我们拖出来一个 UIRoot prefab，如下所示:\r\n\r\n![image-20220725171556290](https://file.liangxiegame.com/3804bb25-0112-4798-bee8-d1b9bf13f134.png)\r\n\r\n这里非常清晰地可以看到 UI Kit 所支持的所有层级。\r\n\r\n接着我们在 Design 层级下创建一个 Panel（右击 Design->UI->Panel) ，并命名为 UIBasicPanel，如下所示:\r\n\r\n![image-20220725171752004](https://file.liangxiegame.com/6b626de9-223f-4d32-9031-285c1d537c75.png)\r\n\r\n这里要说一点，Design 层级，顾名思义就是用来做设计的层级，什么是设计？就是拼界面，这个层级就是专门用来拼界面的，Design 层级会在运行的时候会自动隐藏掉自己以及所有的子节点。\r\n\r\nOK，接下来，我们将 UIBasic 制作成 prefab，将其放到 Assets/Art/UIPrefabs 目录下，如果没有这个目录就自己手动创建一下。\r\n\r\n放入后如下图所示:\r\n\r\n![image-20220725172338703](https://file.liangxiegame.com/584225aa-eb8a-4a7d-a44e-32ecd6732aa2.png)\r\n\r\nAssets/Art/UIPrefab 这个目录是怎么来的呢？它是 QFramework 约定的专门放置 UI 界面 prefab 的位置。而 Assets/Art 是框架推荐存放资源的位置，当然关于资源的存放位置只是推荐，而不是强制的。\r\n\r\n但是 UI 界面的 prefab 必须放在 Assets/Art/UIPrefab 目录下，因为这个部分在代码生成的时候需要。\r\n\r\n那么有的童鞋可能会问，Assets/Art/UIPrefab 这个路径可以不可以更改？\r\n\r\n当然可以，更改的方式也很简单，就是打开包管理面板(QFramework/Preference ctrl + e)，打开后可以看到如下面板:\r\n\r\n![image-20220725172030417](https://file.liangxiegame.com/146ffecf-e9b8-46fc-8e6e-1b95832256fd.png)\r\n\r\n详细的设置方式在上边介绍了，这里就不多介绍了。\r\n\r\n接下来需要将 UIHomePanel prefab 标记为 AssetBundle，如下图所示:\r\n\r\n![image-20220725172438374](https://file.liangxiegame.com/f999ac89-5b91-453f-a865-1dea7045a1d3.png)\r\n\r\n标记成功后。\r\n\r\n会看到如下结果:\r\n\r\n![image-20220725172140857](https://file.liangxiegame.com/3c313f23-2350-4e88-a7b3-88958e9e6219.png)\r\n\r\n接着，我们在这里要确保一件事情，就是 Res Kit 需要保证当前环境是模拟环境（Simulation Mode），具体看面板中的如下选项是否是勾上即可。\r\n\r\n![image-20220725172213241](https://file.liangxiegame.com/98e4043d-bd1b-4a29-9363-890f9f545b12.png)\r\n\r\n确保勾上之后，我们就开始生成代码，具体操作如下所示（右键->@UI-Kit Create UI Code):\r\n\r\n![image-20220725172505171](https://file.liangxiegame.com/de51f6ad-fef7-46dd-adee-c286b77511fe.png)\r\n\r\n点击之后等待编译，编译结束后，我们看到如下结果:\r\n\r\n**脚本生成成功**\r\n\r\n![image-20220725172532517](https://file.liangxiegame.com/7f3959f1-66fc-44de-a8b1-97e31383dcdd.png)\r\n\r\n\r\n\r\n**脚本自动挂载了 UIBasicPanel Prefab 上**\r\n\r\n![image-20220725172550535](https://file.liangxiegame.com/b386fd53-1f84-4ede-a79c-a20533361fa1.png)\r\n\r\n到此，代码生成部分就介绍完了。\r\n\r\n接着，我们想办法让这个场景独立运行。\r\n\r\n现在，我们直接运行场景，是不会加载任何界面的，如下所示:\r\n\r\n![image-20220725172721472](https://file.liangxiegame.com/4ecc5084-4f8b-4ac3-a62b-d4b7a4c9967e.png)\r\n\r\n如何让这个场景加载 UIBasicPanel 呢？\r\n\r\n很简单，使用 UIPanelTester 如下所示:\r\n\r\n![image-20220725172923702](https://file.liangxiegame.com/dd934412-abfd-4d92-9906-3e084a2b761d.png)\r\n\r\n按照图中样子设置就好，然后运行场景。\r\n结果如下:\r\n\r\n![image-20220725173003435](https://file.liangxiegame.com/71acdc41-14a2-42c3-a9c7-6fef2af9757b.png)\r\n\r\n图中成功加载了改界面。\r\n\r\n这样，最基本的 UIBasicPanel 测试场景就算搭建完了，同时我们是完全按照 QFramework 推荐的工作流程完成的。\r\n\r\n虽然步骤会稍微繁琐一点，但是用一段时间大家就会觉得这是值得的。\r\n\r\nOK，接下来我们来介绍控件的自动绑定功能。\r\n\r\n## 控件的自动绑定功能\r\n\r\n我们在 UIBasicPanel 上添加一些按钮，并在每个按钮上挂上 Bind 脚本，如下所示:\r\n\r\n![image-20220725173212119](https://file.liangxiegame.com/9f099faf-d488-491c-bb74-444816c48d6f.png)\r\n\r\n接着 Apply UIBasicPanel，如下所示:\r\n\r\n![image-20220725173259294](https://file.liangxiegame.com/5782a40b-f683-41a2-9db7-7481853aa6a8.png)\r\n\r\n这里要注意，一定要选定 UIBasicPanel 再进行 Apply，千万别选成 UIRoot 了。\r\n\r\nApply 之后，再次生成一次代码，操作如下所示:\r\n\r\n![image-20220725172505171](https://file.liangxiegame.com/de51f6ad-fef7-46dd-adee-c286b77511fe.png)\r\n\r\n生成之后，结果如下:\r\n\r\n![image-20220725191039907](https://file.liangxiegame.com/3f332d24-b7cc-403e-a8d0-e628bf186f9e.png)\r\n\r\n接着，我们打开 UIHomePanel.cs 脚本，试着写一些代码:\r\n\r\n```csharp\r\nusing UnityEngine;\r\nusing UnityEngine.UI;\r\nusing QFramework;\r\n\r\nnamespace QFramework.Example\r\n{\r\n\tpublic class UIBasicPanelData : UIPanelData\r\n\t{\r\n\t}\r\n\tpublic partial class UIBasicPanel : UIPanel\r\n\t{\r\n\t\tprotected override void OnInit(IUIData uiData = null)\r\n\t\t{\r\n\t\t\tmData = uiData as UIBasicPanelData ?? new UIBasicPanelData();\r\n\t\t\t\r\n\t\t\tBtnStart.onClick.AddListener(() =>\r\n\t\t\t{\r\n\t\t\t\tDebug.Log(\"开始游戏\");\r\n\t\t\t});\r\n\t\t}\r\n\t\t\r\n\t\tprotected override void OnOpen(IUIData uiData = null)\r\n\t\t{\r\n\t\t}\r\n\t\t\r\n\t\tprotected override void OnShow()\r\n\t\t{\r\n\t\t}\r\n\t\t\r\n\t\tprotected override void OnHide()\r\n\t\t{\r\n\t\t}\r\n\t\t\r\n\t\tprotected override void OnClose()\r\n\t\t{\r\n\t\t}\r\n\t}\r\n}\r\n\r\n```\r\n\r\n代码很简单，主要是在 OnInit 的时候注册了 BtnStart 按钮。\r\n\r\n接着我们运行场景，接着点击 BtnStart 按钮，得到结果如下:\r\n![image.png](http://file.liangxiegame.com/70f2fbb8-1267-407a-960f-bb019f114a83.png)\r\n\r\n这样控件自动绑定功能就介绍完了。\r\n\r\n\r\n\r\n自动绑定的功能与 View Controller + Bind 是使用的是同一套机制。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 打开、关闭界面\r\n\r\n我们运行 UIBasicPanel 是通过 UIPanelTester 实现的。\r\n\r\nUIPanelTester 是一个 UI 界面的测试器，它只能在编辑器环境下运行。\r\n\r\n真正打开一个 UI 界面，是通过 UIKit.OpenPanel 这个 API 完成的。\r\n\r\n只需要写如下代码即可:\r\n\r\n```csharp\r\nUIKit.OpenPanel<UIBasicPanel>();\r\n```\r\n\r\n代码非常简单。\r\n\r\n而我们要关闭掉一个 UI 界面也比较容易，代码如下:\r\n\r\n```csharp\r\nUIKit.ClosePanel<UIBasicPanel>();\r\n```\r\n\r\n如果是在一个界面内部关掉自己的话，代码如下:\r\n\r\n```csharp\r\nthis.CloseSelf(); // this 继承自 UIPanel \r\n```\r\n\r\nOK，到此我们接触了 3 个 API：\r\n\r\n* UIKit.OpenPanel\\<T\\>();\r\n* UIKit.ClosePanel\\<T\\>();\r\n* UIPanel.CloseSelf();\r\n\r\n后边的两个没什么好讲的，很简单，但是第一个 API 比较重要，因为它有一些参数我们可以填。\r\n\r\n## UIKit.OpenPanel\r\n\r\nUIKit.OpenPanel 的参数定义及重载如下：\r\n\r\n```csharp\r\npublic static T OpenPanel<T>(UILevel canvasLevel = UILevel.Common, IUIData uiData = null,\r\n            string assetBundleName = null,\r\n            string prefabName = null) where T : UIPanel\r\n{\r\n\t...\r\n}\r\n\r\npublic static T OpenPanel<T>(IUIData uiData, PanelOpenType panelOpenType = PanelOpenType.Single,\r\n            string assetBundleName = null,\r\n            string prefabName = null) where T : UIPanel\r\n{\r\n\t...\r\n}\r\n\r\npublic static UIPanel OpenPanel(string panelName, UILevel level = UILevel.Common, string assetBundleName = null)\r\n{\r\n\t...\r\n}\r\n```\r\n\r\n\r\n\r\n所有参数如下：\r\n\r\n* canvasLevel：界面在哪个层级打开\r\n  * 默认值：Common\r\n* uiData：打开时可以给界面传的初始数据\r\n  * 默认值：null\r\n* assetBundleName：界面资源所在的 assetBundle 名\r\n  * 默认值：null\r\n* prefabName：如果界面名字和 prefab 名字不同，则以这个参数为准去加载界面资源\r\n  * 默认值：null\r\n\r\n都有默认值，所以这四个参数都可以不用传。\r\n\r\n不过这四个 API 在某种情况下非常实用。\r\n\r\n下边举一些例子。\r\n\r\n```csharp\r\n// 在 Forward 层级打开\r\nUIKit.OpenPanel<UIBasicPanel>(UILevel.Forward);\r\n\r\n// 传递初始数据给 UIHomePanel\r\nUIKit.OpenPanel<UIBasicPanel>(new UIHomePanelData()\r\n{\r\n    Coin = 10\r\n});\r\n            \r\n// 从 UIHomePanelTest.prefab 加载界面 \r\nUIKit.OpenPanel<UIBasicPanel>(prefabName: \"UIBasicPanel\");\r\n```\r\n\r\n都比较容易理解。\r\n\r\n有的童鞋可能会问，我们给 UIHomePanel 传递的  UIHomePanelData，在哪里使用呢？\r\n\r\n答案是在，OnInit 和 OnOpen 中，如下所示:\r\n\r\n```csharp\r\nnamespace QFramework.Example\r\n{\r\n    using System;\r\n    using System.Collections;\r\n    using System.Collections.Generic;\r\n    using System.Linq;\r\n    using UnityEngine;\r\n    using UnityEngine.UI;\r\n    \r\n    \r\n    public class UIBasicPanelData : QFramework.UIPanelData\r\n    {\r\n        public int Coin;\r\n    }\r\n    \r\n    public partial class UIBasicPanel : QFramework.UIPanel\r\n    {\r\n        protected override void OnInit(QFramework.IUIData uiData)\r\n        {\r\n            mData = uiData as UIBasicPanelData ?? new UIBasicPanelData();\r\n            // please add init code here\r\n            \r\n            // 外边传进来的，第一次初始化的时候使用\r\n            Debug.Log(mData.Coin);\r\n        }\r\n        \r\n        protected override void OnOpen(QFramework.IUIData uiData)\r\n        {\r\n            // 每次 OpenPanel 的时候使用\r\n            Debug.Log((uiData as UIBasicPanelData).Coin);\r\n        }\r\n        \r\n        protected override void OnShow()\r\n        {\r\n\r\n        }\r\n        \r\n        protected override void OnHide()\r\n        {\r\n        }\r\n        \r\n        protected override void OnClose()\r\n        {\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n为什么要这样做呢？\r\n\r\n笔者认为，界面有两种显示数据的用法，一种是有的界面是需要从外边填充的，比如警告、弹框、或者道具信息页面等。另一种界面是需要自己获取数据并展示的，比如游戏中的主角金币、等级、经验值等。\r\n\r\n\r\n\r\n如果界面的数据都从外边填充，那么这个界面会拥有更好的可复用性。\r\n\r\n\r\n\r\n当然需要一个可复用性的界面还是需要一个普通界面就看大家的需求了，并不是说有可复用性的界面就是好的。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n\r\n## 异步加载界面\r\n\r\n```csharp\r\nStartCoroutine(UIKit.OpenPanelAsync<UIHomePanel>());\r\n// 或者\r\nUIKit.OpenPanelAsync<UIHomePanel>().ToAction().Start(this);\r\n```\r\n\r\n在 WebGL 平台上, AssetBundle 加载资源只支持异步加载，所以为此提供了 UIKit 的异步加载支持。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n\r\n\r\n\r\n\r\n\r\n## UIPanel 生命周期\r\n\r\n我们先看下  UIBasicPanel 的代码，如下:\r\n\r\n```csharp\r\nnamespace QFramework.Example\r\n{\r\n    using System;\r\n    using System.Collections;\r\n    using System.Collections.Generic;\r\n    using System.Linq;\r\n    using UnityEngine;\r\n    using UnityEngine.UI;\r\n    \r\n    \r\n    public class UIBasicPanelData : QFramework.UIPanelData\r\n    {\r\n    }\r\n    \r\n    public partial class UIBasicPanel : QFramework.UIPanel\r\n    {        \r\n        protected override void OnInit(QFramework.IUIData uiData)\r\n        {\r\n            mData = uiData as UIHomePanelData ?? new UIHomePanelData();\r\n            // please add init code here\r\n            \r\n            \r\n        }\r\n        \r\n        protected override void OnOpen(QFramework.IUIData uiData)\r\n        {\r\n        }\r\n        \r\n        protected override void OnShow()\r\n        {\r\n\r\n        }\r\n        \r\n        protected override void OnHide()\r\n        {\r\n        }\r\n        \r\n        protected override void OnClose()\r\n        {\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n默认的生命周期函数如下:\r\n\r\n* OnInit\r\n* OnOpen\r\n* OnShow\r\n* OnHide\r\n* OnClose\r\n\r\nOnInit 则是在 UIPanel 所在的 prefab 初始化的时候进行调用的，在调用 UIKit.OpenPanel 时，只要在 UIKit 中没有对应的缓存界面时，就会调用一次 OnInit 这个周期。\r\n\r\nOnOpen 就是每次 UIKit.OpenPanel 调用时，就会调用。\r\n\r\nOnShow  实际上调用时机与 UIKit.OpenPanel 是一样的，只不过 OnShow 是最初版本遗留下拉的 API，所以就保留了。当然还有 UIMgr.ShowPanel 调用时，OnShow 会被调用\r\n\r\nOnHide 则是在 UIKit.HidePanel 调用时，OnHide 会被调用。\r\n\r\n最后 OnClose 就是在 UIKit.ClosePanel 调用时，就会触发，实际上 OnClose 相当于 OnDestory 这个周期。\r\n\r\n大概就这些，其中 UIKit.OpenPanel 会触发资源的加载和初始化操作，而 UIKit.ClosePanel 则会触发卸载和销毁操作，只要记得这两点就好。\r\n\r\n笔者基本上就只会用到 OnInit 和 OnClose 这些周期，偶尔会用一用 OnOpen。\r\n\r\n\r\n\r\nOK，此篇的内容就这些。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n\r\n\r\n\r\n\r\n\r\n\r\n## UIKit 剩下的常用 API\r\n\r\n### UIKit.Root.SetResolution\r\n\r\n参数定义如下：\r\n\r\n![image.png](http://file.liangxiegame.com/bac63766-0f9a-4d9c-92fd-cb6b90324262.png)\r\n\r\n对应 UIRoot 上的 Canvas Scaler 如下:\r\n\r\n![image.png](http://file.liangxiegame.com/bc2c2122-c559-48bf-8b2f-ea4609826493.png)\r\n\r\n大部分项目，用这个 API 做屏幕适配足够了。\r\n\r\n### UIKit.Root.Camera\r\n\r\n获取 UIRoot 的摄像机。\r\n\r\n```csharp\r\nvar uiCamera = UIKit.Root.Camera;\r\n```\r\n\r\n### UIKit.Stack.Push、UIPanel.Back（Pop）\r\n\r\n有的时候，UI 需要实现一个 UI 界面的堆栈，以便于支持返回上一页这样的操作。\r\n\r\n这个时候就可以用 Push 和 UIPanel.Back 实现。\r\n\r\n示例代码:\r\n\r\n```csharp\r\nUIKit.Stack.Push(this); // this 是 Panel\r\n// UIHomePanel 需要确保是打开的状态，如果不打开会报错。\r\nUIKit.Stack.Push<UIHomePanel>();\r\n            \r\nthis.Back(); // 弹出 UIHomePanel\r\nthis.Back(); // 弹出 this\r\n```\r\n\r\n非常简单。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## UIPanel 自动生成工具\r\n\r\n在此篇的最开始，笔者手动创建了一套围绕 UIBasicPanel 的测试、开发场景，其过程比较繁琐。\r\n\r\n为了解决这个问题，笔者写了一个简单的 UIPanel 自动生成工具。\r\n\r\n接下来看下它的基本使用流程。\r\n\r\n### 基本使用\r\n\r\n首先，快捷键 ctrl + e 打开 PackageKit 面板，如下:\r\n\r\n![image-20220725213353833](https://file.liangxiegame.com/12dcb73a-c255-45f4-869e-a00700d3b3c1.png)\r\n\r\n在上图中界面名字的输入框中输入 Game/UIGamePanel，然后点击创建 UI Panel，如下所示:\r\n\r\n![image-20220725213736831](https://file.liangxiegame.com/19dfe911-4cdd-4432-a99c-00423b38d781.png)\r\n\r\n\r\n\r\n输入之后可以看到即将生成文件的预览。\r\n\r\n在这个面板中，我们还可以设置 分辨率与适配对齐，还有模块的目录，如果不想在更目录创建按照规范生成文件，也可以在其他子目录中创建。\r\n\r\n我们点击 \"创建 UI Panel\" 这个按钮。\r\n\r\n\r\n\r\n点击之后结果如下:\r\n\r\n\r\n\r\n![image-20220725214053092](https://file.liangxiegame.com/daf92af1-1e66-4b86-bf4b-e331c272570b.png)\r\n\r\n\r\n\r\n相关的 prefab，场景、脚本都生成好了，就连 AssetBundle 也都标记好了，如下:\r\n\r\n\r\n\r\n![image-20220725214155564](https://file.liangxiegame.com/a0a6c3e3-c4b6-4602-8b92-a47506714a98.png)\r\n\r\n这就是这个工具的一个用处，非常方便，解决了笔者大量的开发工作量。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## UI Element 简介\r\n\r\n在前篇，我们了解到，一个 UIPanel 是可以自动绑定几个 子控件的（Bind）。但是当一个界面结构比较复杂的时候，不可能一个 UIPanel 管理数十个 Bind，这时候就需要对 Bind 进行一些打组操作。我们的 UIElement 就可以登场了。\r\n\r\n## UIElement 基本使用\r\n\r\n使用方式非常简单，就是将 Bind 中的 标记类型 改成 Element即可,如下所示。\r\n\r\n![image.png](https://file.liangxiegame.com/47b78081-62cd-41e2-b96b-47383dc80e04.png)\r\n\r\n![image.png](https://file.liangxiegame.com/b9533003-b30b-406e-b14c-4f8f777b1e95.png)\r\n\r\n并且要给 生成类名 填写一个名字，这个名字决定生成的类的名字。这里填写了 UIAboutSubPanel。\r\n\r\n\r\n之后进行 Apply 操作。\r\n\r\n![image-20220728141929443](https://file.liangxiegame.com/46876a38-e980-49a8-bbc8-59e74f968f3d.png)\r\n\r\n\r\n\r\n注意这里 Apply 的是 UIBasicPanel。\r\n\r\n接着生成代码， 如下:\r\n\r\n![image-20220728142010223](https://file.liangxiegame.com/800b53e4-0d6a-43f4-9aa1-ce3815d5fc87.png)\r\n\r\n\r\n等待编译后，如下所示：\r\n\r\n\r\n\r\n![image-20220728142048854](https://file.liangxiegame.com/3c05a2b9-f815-421b-b0b4-379a0477e401.png)\r\n\r\n\r\n\r\n\r\n\r\nBtnClose 由 UIAboutSubPanel 管理了\r\n\r\n![image-20220728142125763](https://file.liangxiegame.com/956e3e01-32a3-4582-a691-59e2d9e647de.png)\r\n\r\n我们看下脚本目录:\r\n\r\n![image-20220728142202239](https://file.liangxiegame.com/76847346-79ad-4003-84f7-6111152e457a.png)\r\n\r\n目录生成了一个新的文件夹，是以父 Panel （UIBasicPanel）为名的。\r\n\r\n打开 UIAboutSubPanel 脚本，代码如下所示:\r\n\r\n```csharp\r\n/****************************************************************************\r\n * 2022.7 LIANGXIEWIN\r\n ****************************************************************************/\r\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing UnityEngine;\r\nusing UnityEngine.UI;\r\nusing QFramework;\r\n\r\nnamespace QFramework.Example\r\n{\r\n\tpublic partial class SubPanel1 : UIElement\r\n\t{\r\n\t\tprivate void Awake()\r\n\t\t{\r\n\t\t}\r\n\r\n\t\tprotected override void OnBeforeDestroy()\r\n\t\t{\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n再看下 UILoginView.Designer.cs 脚本，如下所示:\r\n\r\n```csharp\r\n/****************************************************************************\r\n * 2022.7 LIANGXIEWIN\r\n ****************************************************************************/\r\n\r\nusing UnityEngine;\r\nusing UnityEngine.UI;\r\nusing QFramework;\r\n\r\nnamespace QFramework.Example\r\n{\r\n\tpublic partial class SubPanel1\r\n\t{\r\n\t\t[SerializeField] public UnityEngine.UI.Button BtnStart2;\r\n\t\t[SerializeField] public UnityEngine.UI.Button BtnStart3;\r\n\r\n\t\tpublic void Clear()\r\n\t\t{\r\n\t\t\tBtnStart2 = null;\r\n\t\t\tBtnStart3 = null;\r\n\t\t}\r\n\r\n\t\tpublic override string ComponentName\r\n\t\t{\r\n\t\t\tget { return \"SubPanel1\";}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n结构与之前的 UIBasicPanel 非常相似。\r\n\r\n接下来，就可以写一些与子模块相关的逻辑了，关于 UIElement 的基本使用就介绍到这里。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n\r\n\r\n\r\n\r\n## 同一个类型的界面打开多个\r\n\r\n```csharp\r\nUIKit.OpenPanel<UIMultiPanel>(new UIMultiPanelData(), PanelOpenType.Multiple);\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 如何自定义界面加载方式?\r\n\r\n\r\n\r\n继承 AbstractPanelLoaderPool 类，再实现一个 IPanelLoader 的类，参考代码如下:\r\n\r\n\r\n\r\n```csharp\r\nusing System;\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class CustomPanelLoaderExample : MonoBehaviour\r\n    {\r\n        public class ResourcesPanelLoaderPool : AbstractPanelLoaderPool\r\n        {\r\n            /// <summary>\r\n            /// Load Panel from Resources\r\n            /// </summary>\r\n            public class ResourcesPanelLoader : IPanelLoader\r\n            {\r\n                private GameObject mPanelPrefab;\r\n\r\n                public GameObject LoadPanelPrefab(PanelSearchKeys panelSearchKeys)\r\n                {\r\n                    mPanelPrefab = Resources.Load<GameObject>(panelSearchKeys.GameObjName);\r\n                    return mPanelPrefab;\r\n                }\r\n\r\n                public void LoadPanelPrefabAsync(PanelSearchKeys panelSearchKeys, Action<GameObject> onPanelLoad)\r\n                {\r\n                    var request = Resources.LoadAsync<GameObject>(panelSearchKeys.GameObjName);\r\n\r\n                    request.completed += operation => { onPanelLoad(request.asset as GameObject); };\r\n                }\r\n\r\n                public void Unload()\r\n                {\r\n                    mPanelPrefab = null;\r\n                }\r\n            }\r\n\r\n            protected override IPanelLoader CreatePanelLoader()\r\n            {\r\n                return new ResourcesPanelLoader();\r\n            }\r\n        }\r\n\r\n        void Start()\r\n        {\r\n            // 游戏启动时，设置一次\r\n            UIKit.Config.PanelLoaderPool = new ResourcesPanelLoaderPool();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n如果想要支持 其他方式加载界面则可以通过此方式定制。\r\n\r\n\r\n\r\n另外，QFramework 中的 UIKit 默认使用 ResKit 的方式加载界面。\r\n\r\n\r\n\r\n可以在 QFramework 源码中看到如下代码:\r\n\r\n\r\n\r\n```csharp\r\nusing System;\r\nusing UnityEngine;\r\n\r\nnamespace QFramework\r\n{\r\n    public class UIKitWithResKitInit\r\n    {\r\n        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]\r\n        public static void Init()\r\n        {\r\n            UIKit.Config.PanelLoaderPool = new ResKitPanelLoaderPool();\r\n        }\r\n    }\r\n    \r\n    ...\r\n}\r\n```\r\n\r\n\r\n\r\n如果想要使用自定义的方式加载界面，需要将以上代码注释掉。\r\n\r\n\r\n\r\n好了，关于 UIKit 自定义加载界面就简单介绍到这里。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n# 03. AudioKit 音频管理解决方案\r\n## 基本使用\r\n\r\nAudioKit 音频播放相关的功能如下:\r\n* 播放背景音乐，同一时间只能播放一个音乐，播放别的音乐会直接卸载掉正在播放的音乐。\r\n* 播放音效，同一时间可以播放多个音效，当多人说话时，也可以用来播放人声。\r\n* 播放人声，与播放背景音乐一致，同一时间只能播放一个人声，用于播放一些旁白之类的声音非常适合。\r\n\r\n对应的 API 调用方式如下:\r\n\r\n```csharp\r\nbtnPlayGame.onClick.AddListener(() => { AudioKit.PlayMusic(\"resources://game_bg\"); });\r\n\r\nbtnPlaySound.onClick.AddListener(() => { AudioKit.PlaySound(\"resources://game_bg\"); });\r\n\r\nbtnPlayVoiceA.onClick.AddListener(() => { AudioKit.PlayVoice(\"resources://game_bg\"); });\r\n```\r\n\r\n\r\nAudioKit 设置相关的功能如下:\r\n* 背景音乐开关\r\n* 音效开关\r\n* 人声开关\r\n\r\n调用示例如下：\r\n\r\n```csharp\r\nbtnSoundOn.onClick.AddListener(() => { AudioKit.Settings.IsSoundOn.Value = true; });\r\n\r\nbtnSoundOff.onClick.AddListener(() => { AudioKit.Settings.IsSoundOn.Value = false; });\r\n\r\nbtnMusicOn.onClick.AddListener(() => { AudioKit.Settings.IsMusicOn.Value = true; });\r\n\r\nbtnMusicOff.onClick.AddListener(() => { AudioKit.Settings.IsMusicOn.Value = false; });\r\n\r\nbtnVoiceOn.onClick.AddListener(() => { AudioKit.Settings.IsVoiceOn.Value = true; });\r\n\r\nbtnVoiceOff.onClick.AddListener(() => { AudioKit.Settings.IsVoiceOn.Value = false; });\r\n```\r\n这是打开声音这个功能的使用方式。\r\n\r\n\r\n调整音量大小的代码如下:\r\n\r\n```csharp\r\nAudioKit.Settings.MusicVolume.RegisterWithInitValue(v => musicVolumeSlider.value = v);\r\nAudioKit.Settings.VoiceVolume.RegisterWithInitValue(v => voiceVolumeSlider.value = v);\r\nAudioKit.Settings.SoundVolume.RegisterWithInitValue(v => soundVolumeSlider.value = v);\r\n            \r\nmusicVolumeSlider.onValueChanged.AddListener(v => { AudioKit.Settings.MusicVolume.Value = v; });\r\nvoiceVolumeSlider.onValueChanged.AddListener(v => { AudioKit.Settings.VoiceVolume.Value = v; });\r\nsoundVolumeSlider.onValueChanged.AddListener(v => { AudioKit.Settings.SoundVolume.Value = v; });\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n## 如何自定义音频加载\r\n\r\n与 UIKit 一样, AudioKit 也支持了自定义音频加载的方式。\r\n\r\n参考代码如下:\r\n\r\n```csharp\r\nusing System;\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class CustomAudioLoaderExample : MonoBehaviour\r\n    {\r\n        /// <summary>\r\n        /// 定义从 Resources 加载音频\r\n        /// </summary>\r\n        class ResourcesAudioLoaderPool : AbstractAudioLoaderPool\r\n        {\r\n            protected override IAudioLoader CreateLoader()\r\n            {\r\n                return new ResourcesAudioLoader();\r\n            }\r\n        }\r\n\r\n        class ResourcesAudioLoader : IAudioLoader\r\n        {\r\n            private AudioClip mClip;\r\n        \r\n            public AudioClip Clip => mClip;\r\n\r\n            public AudioClip LoadClip(AudioSearchKeys panelSearchKeys)\r\n            {\r\n                mClip = Resources.Load<AudioClip>(panelSearchKeys.AssetName);\r\n                return mClip;\r\n            }\r\n\r\n            public void LoadClipAsync(AudioSearchKeys audioSearchKeys, Action<bool,AudioClip> onLoad)\r\n            {\r\n                var resourceRequest = Resources.LoadAsync<AudioClip>(audioSearchKeys.AssetName);\r\n                resourceRequest.completed += operation =>\r\n                {\r\n                    var clip = resourceRequest.asset as AudioClip;\r\n                    onLoad(clip, clip);\r\n                };\r\n            }\r\n\r\n            public void Unload()\r\n            {\r\n                Resources.UnloadAsset(mClip);\r\n            }\r\n        }\r\n        \r\n        \r\n        void Start()\r\n        {\r\n            // 启动时需要调用一次\r\n            AudioKit.Config.AudioLoaderPool = new ResourcesAudioLoaderPool();\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n由于 QFramework 中的 AudioKit 默认是通过 ResKit 加载，所以使用自定义加载方式时，请将项目中如下代码注释掉:\r\n\r\n```csharp\r\n    public class AudioKitWithResKitInit \r\n    {\r\n        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]\r\n        public static void Init()\r\n        {\r\n            AudioKit.Config.AudioLoaderPool = new ResKitAudioLoaderPool();\r\n        }\r\n    }\r\n```\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n在笔者自己做游戏的时候遇到很多情况下需要等待音效播放完，之后做一些时序性的事情，所以笔者实现了让 AudioKit 的 ActionKit\r\n支持的功能。\r\n\r\n## 基本使用\r\n\r\n```csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class AudioKitActionExample : MonoBehaviour\r\n    {\r\n        private void Start()\r\n        {\r\n            PlaySoundAction\r\n                .Allocate(\"resources://button_clicked\", () =>\r\n                {\r\n                    Debug.Log(\"button_clicked finish\");\r\n                })\r\n                .Start(this);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n这样就实现了一个简单的当音效播放完之后做 XXX 的功能。\r\n\r\n## 与 Sequence、Repeat、Parallel 配合\r\n\r\n这三个本质都是 Sequence，所以这里只展示 PlaySound 在 Sequence 的用法，如下:\r\n\r\n```csharp\r\nusing UnityEngine;\r\n\r\nnamespace QFramework.Example\r\n{\r\n    public class AudioKitActionExample : MonoBehaviour\r\n    {\r\n        private void Start()\r\n        {\r\n            var heroClip = Resources.Load<AudioClip>(\"hero_hurt\");\r\n\r\n            ActionKit.Sequence()\r\n                .Delay(1.0f)\r\n                .PlaySound(\"resources://button_clicked\")\r\n                .Delay(1.0f)\r\n                .PlaySound(heroClip)\r\n                .Start(this);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n与 ActionKit 的 Sequence 配合，可以做一些复杂的效果，比如延时几秒后播放某个音效等。\r\n\r\nPlaySound 就介绍到这里。\r\n\r\n本文由 QFramework 教程年会员赞助，地址：[https://www.gamepixedu.com/goods/show/55](https://www.gamepixedu.com/goods/show/55)\r\n\r\n* QFramework 主页：[qframework.cn](https://qframework.cn)\r\n* QFramework 交流群: 623597263\r\n* QFramework Github 地址: <https://github.com/liangxiegame/qframework>\r\n* QFramework Gitee 地址：<https://gitee.com/liangxiegame/QFramework>\r\n"
        },
        {
          "name": "Example.png",
          "type": "blob",
          "size": 575.7138671875,
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.05859375,
          "content": "MIT License\r\n\r\nCopyright (c) 2023 凉鞋\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n"
        },
        {
          "name": "LOGO.png",
          "type": "blob",
          "size": 3.7998046875,
          "content": null
        },
        {
          "name": "QFramework API.md",
          "type": "blob",
          "size": 20.544921875,
          "content": "- - QFramework API 文档\r\n\r\n    \r\n\r\n    ## 1. 架构（Architecture）\r\n\r\n    \r\n\r\n    ### 1.1 IArchitecture 接口\r\n\r\n    \r\n\r\n    - **描述：** 定义了架构的基本功能，包括注册、获取和发送命令、查询、事件以及反初始化。\r\n    - **方法：**\r\n      - `void RegisterSystem<T>(T system) where T : ISystem`：注册一个系统。\r\n      - `void RegisterModel<T>(T model) where T : IModel`：注册一个模型。\r\n      - `void RegisterUtility<T>(T utility) where T : IUtility`：注册一个工具类。\r\n      - `T GetSystem<T>() where T : class, ISystem`：获取一个系统。\r\n      - `T GetModel<T>() where T : class, IModel`：获取一个模型。\r\n      - `T GetUtility<T>() where T : class, IUtility`：获取一个工具类。\r\n      - `void SendCommand<T>(T command) where T : ICommand`：发送一个无返回值的命令。\r\n      - `TResult SendCommand<TResult>(ICommand<TResult> command)`：发送一个有返回值的命令。\r\n      - `TResult SendQuery<TResult>(IQuery<TResult> query)`：发送一个查询。\r\n      - `void SendEvent<T>() where T : new()`：发送一个无参构造函数的事件。\r\n      - `void SendEvent<T>(T e)`：发送一个事件。\r\n      - `IUnRegister RegisterEvent<T>(Action<T> onEvent)`：注册一个事件监听器。\r\n      - `void UnRegisterEvent<T>(Action<T> onEvent)`：移除一个事件监听器。\r\n      - `void Deinit()`：反初始化架构。\r\n\r\n    \r\n\r\n    ### 1.2 Architecture<T> 抽象类\r\n\r\n    \r\n\r\n    - **描述：** 架构的抽象基类，实现了 IArchitecture 接口。\r\n    - **类型参数：**\r\n      - `T`：具体的架构类型，必须继承自 Architecture<T>。\r\n    - **字段：**\r\n      - `public static Action<T> OnRegisterPatch`：注册补丁时的回调函数。\r\n      - `protected static T mArchitecture`：架构的单例实例。\r\n      - `public static IArchitecture Interface`：获取架构的接口。\r\n    - **方法：**\r\n      - `protected abstract void Init()`：初始化架构，子类必须实现。\r\n      - `public void Deinit()`：反初始化架构。\r\n      - `protected virtual void OnDeinit()`：反初始化时的回调函数，子类可重写。\r\n    - **受保护的成员：**\r\n      - `private IOCContainer mContainer`：用于管理依赖注入的容器。\r\n      - `protected virtual TResult ExecuteCommand<TResult>(ICommand<TResult> command)`：执行有返回值的命令。\r\n      - `protected virtual void ExecuteCommand(ICommand command)`：执行无返回值的命令。\r\n      - `protected virtual TResult DoQuery<TResult>(IQuery<TResult> query)`：执行查询。\r\n      - `private TypeEventSystem mTypeEventSystem`：类型事件系统，用于管理事件的发送和接收。\r\n\r\n    \r\n\r\n    ### 1.3 IOnEvent<T> 接口\r\n\r\n    \r\n\r\n    - **描述：** 定义了事件处理方法的接口。\r\n    - **类型参数：**\r\n      - `T`：事件类型。\r\n    - **方法：**\r\n      - `void OnEvent(T e)`：事件处理方法。\r\n\r\n    \r\n\r\n    ### 1.4 OnGlobalEventExtension 静态类\r\n\r\n    \r\n\r\n    - **描述：** 提供了 IOnEvent<T> 接口的扩展方法，用于注册和移除全局事件监听器。\r\n    - **方法：**\r\n      - `public static IUnRegister RegisterEvent<T>(this IOnEvent<T> self) where T : struct`：注册一个全局事件监听器。\r\n      - `public static void UnRegisterEvent<T>(this IOnEvent<T> self) where T : struct`：移除一个全局事件监听器。\r\n\r\n    \r\n\r\n    ## 2. 控制器（Controller）\r\n\r\n    \r\n\r\n    ### 2.1 IController 接口\r\n\r\n    \r\n\r\n    - **描述：** 定义了控制器的基本功能，继承自多个接口，包括 IBelongToArchitecture、ICanSendCommand、ICanGetSystem、ICanGetModel、ICanRegisterEvent、ICanSendQuery 和 ICanGetUtility。\r\n\r\n    \r\n\r\n    ## 3. 系统（System）\r\n\r\n    \r\n\r\n    ### 3.1 ISystem 接口\r\n\r\n    \r\n\r\n    - **描述：** 定义了系统的基本功能，继承自多个接口，包括 IBelongToArchitecture、ICanSetArchitecture、ICanGetModel、ICanGetUtility、ICanRegisterEvent、ICanSendEvent、ICanGetSystem 和 ICanInit。\r\n\r\n    \r\n\r\n    ### 3.2 AbstractSystem 抽象类\r\n\r\n    \r\n\r\n    - **描述：** 系统的抽象基类，实现了 ISystem 接口。\r\n    - **字段：**\r\n      - `public bool Initialized { get; set; }`：指示系统是否已初始化。\r\n    - **方法：**\r\n      - `protected abstract void OnInit()`：初始化系统，子类必须实现。\r\n      - `public void Deinit()`：反初始化系统。\r\n      - `protected virtual void OnDeinit()`：反初始化时的回调函数，子类可重写。\r\n\r\n    \r\n\r\n    ## 4. 模型（Model）\r\n\r\n    \r\n\r\n    ### 4.1 IModel 接口\r\n\r\n    \r\n\r\n    - **描述：** 定义了模型的基本功能，继承自多个接口，包括 IBelongToArchitecture、ICanSetArchitecture、ICanGetUtility、ICanSendEvent 和 ICanInit。\r\n\r\n    \r\n\r\n    ### 4.2 AbstractModel 抽象类\r\n\r\n    \r\n\r\n    - **描述：** 模型的抽象基类，实现了 IModel 接口。\r\n    - **字段：**\r\n      - `public bool Initialized { get; set; }`：指示模型是否已初始化。\r\n    - **方法：**\r\n      - `protected abstract void OnInit()`：初始化模型，子类必须实现。\r\n      - `public void Deinit()`：反初始化模型。\r\n      - `protected virtual void OnDeinit()`：反初始化时的回调函数，子类可重写。\r\n\r\n    \r\n\r\n    ## 5. 工具类（Utility）\r\n\r\n    \r\n\r\n    ### 5.1 IUtility 接口\r\n\r\n    \r\n\r\n    - **描述：** 定义了工具类的基本功能，没有任何方法。\r\n\r\n    \r\n\r\n    ## 6. 命令（Command）\r\n\r\n    \r\n\r\n    ### 6.1 ICommand 接口\r\n\r\n    \r\n\r\n    - **描述：** 定义了无返回值命令的基本功能，继承自多个接口，包括 IBelongToArchitecture、ICanSetArchitecture、ICanGetSystem、ICanGetModel、ICanGetUtility、ICanSendEvent、ICanSendCommand 和 ICanSendQuery。\r\n    - **方法：**\r\n      - `void Execute()`：执行命令。\r\n\r\n    \r\n\r\n    ### 6.2 ICommand<TResult> 接口\r\n\r\n    \r\n\r\n    - **描述：** 定义了有返回值命令的基本功能，继承自多个接口，包括 IBelongToArchitecture、ICanSetArchitecture、ICanGetSystem、ICanGetModel、ICanGetUtility、ICanSendEvent、ICanSendCommand 和 ICanSendQuery。\r\n    - **类型参数：**\r\n      - `TResult`：命令执行结果的类型。\r\n    - **方法：**\r\n      - `TResult Execute()`：执行命令并返回结果。\r\n\r\n    \r\n\r\n    ### 6.3 AbstractCommand 抽象类\r\n\r\n    \r\n\r\n    - **描述：** 无返回值命令的抽象基类，实现了 ICommand 接口。\r\n    - **方法：**\r\n      - `protected abstract void OnExecute()`：执行命令的具体逻辑，子类必须实现。\r\n\r\n    \r\n\r\n    ### 6.4 AbstractCommand<TResult> 抽象类\r\n\r\n    \r\n\r\n    - **描述：** 有返回值命令的抽象基类，实现了 ICommand<TResult> 接口。\r\n    - **类型参数：**\r\n      - `TResult`：命令执行结果的类型。\r\n    - **方法：**\r\n      - `protected abstract TResult OnExecute()`：执行命令的具体逻辑并返回结果，子类必须实现。\r\n\r\n    \r\n\r\n    ## 7. 查询（Query）\r\n\r\n    \r\n\r\n    ### 7.1 IQuery<TResult> 接口\r\n\r\n    \r\n\r\n    - **描述：** 定义了查询的基本功能，继承自多个接口，包括 IBelongToArchitecture、ICanSetArchitecture、ICanGetModel、ICanGetSystem 和 ICanSendQuery。\r\n    - **类型参数：**\r\n      - `TResult`：查询结果的类型。\r\n    - **方法：**\r\n      - `TResult Do()`：执行查询并返回结果。\r\n\r\n    \r\n\r\n    ### 7.2 AbstractQuery<T> 抽象类\r\n\r\n    \r\n\r\n    - **描述：** 查询的抽象基类，实现了 IQuery<T> 接口。\r\n    - **类型参数：**\r\n      - `T`：查询结果的类型。\r\n    - **方法：**\r\n      - `protected abstract T OnDo()`：执行查询的具体逻辑并返回结果，子类必须实现。\r\n\r\n    \r\n\r\n    ## 8. 规则（Rule）\r\n\r\n    \r\n\r\n    ### 8.1 IBelongToArchitecture 接口\r\n\r\n    \r\n\r\n    - **描述：** 定义了属于架构的类型的基本功能。\r\n    - **方法：**\r\n      - `IArchitecture GetArchitecture()`：获取所属的架构。\r\n\r\n    \r\n\r\n    ### 8.2 ICanSetArchitecture 接口\r\n\r\n    \r\n\r\n    - **描述：** 定义了可以设置架构的类型的基本功能。\r\n    - **方法：**\r\n      - `void SetArchitecture(IArchitecture architecture)`：设置所属的架构。\r\n\r\n    \r\n\r\n    ### 8.3 ICanGetModel 接口\r\n\r\n    \r\n\r\n    - **描述：** 定义了可以获取模型的类型的基本功能，继承自 IBelongToArchitecture 接口。\r\n\r\n    \r\n\r\n    ### 8.4 CanGetModelExtension 静态类\r\n\r\n    \r\n\r\n    - **描述：** 提供了 ICanGetModel 接口的扩展方法，用于获取模型。\r\n    - **方法：**\r\n      - `public static T GetModel<T>(this ICanGetModel self) where T : class, IModel`：获取指定类型的模型。\r\n\r\n    \r\n\r\n    ### 8.5 ICanGetSystem 接口\r\n\r\n    \r\n\r\n    - **描述：** 定义了可以获取系统的类型的基本功能，继承自 IBelongToArchitecture 接口。\r\n\r\n    \r\n\r\n    ### 8.6 CanGetSystemExtension 静态类\r\n\r\n    \r\n\r\n    - **描述：** 提供了 ICanGetSystem 接口的扩展方法，用于获取系统。\r\n    - **方法：**\r\n      - `public static T GetSystem<T>(this ICanGetSystem self) where T : class, ISystem`：获取指定类型的系统。\r\n\r\n    \r\n\r\n    ### 8.7 ICanGetUtility 接口\r\n\r\n    \r\n\r\n    - **描述：** 定义了可以获取工具类的类型的基本功能，继承自 IBelongToArchitecture 接口。\r\n\r\n    \r\n\r\n    ### 8.8 CanGetUtilityExtension 静态类\r\n\r\n    \r\n\r\n    - **描述：** 提供了 ICanGetUtility 接口的扩展方法，用于获取工具类。\r\n    - **方法：**\r\n      - `public static T GetUtility<T>(this ICanGetUtility self) where T : class, IUtility`：获取指定类型的工具类。\r\n\r\n    \r\n\r\n    ### 8.9 ICanRegisterEvent 接口\r\n\r\n    \r\n\r\n    - **描述：** 定义了可以注册事件监听器的类型的基本功能，继承自 IBelongToArchitecture 接口。\r\n\r\n    \r\n\r\n    ### 8.10 CanRegisterEventExtension 静态类\r\n\r\n    \r\n\r\n    - **描述：** 提供了 ICanRegisterEvent 接口的扩展方法，用于注册和移除事件监听器。\r\n    - **方法：**\r\n      - `public static IUnRegister RegisterEvent<T>(this ICanRegisterEvent self, Action<T> onEvent)`：注册一个事件监听器。\r\n      - `public static void UnRegisterEvent<T>(this ICanRegisterEvent self, Action<T> onEvent)`：移除一个事件监听器。\r\n\r\n    \r\n\r\n    ### 8.11 ICanSendCommand 接口\r\n\r\n    \r\n\r\n    - **描述：** 定义了可以发送命令的类型的基本功能，继承自 IBelongToArchitecture 接口。\r\n\r\n    \r\n\r\n    ### 8.12 CanSendCommandExtension 静态类\r\n\r\n    \r\n\r\n    - **描述：** 提供了 ICanSendCommand 接口的扩展方法，用于发送命令。\r\n    - **方法：**\r\n      - `public static void SendCommand<T>(this ICanSendCommand self) where T : ICommand, new()`：发送一个无参构造函数的命令。\r\n      - `public static void SendCommand<T>(this ICanSendCommand self, T command) where T : ICommand`：发送一个命令。\r\n      - `public static TResult SendCommand<TResult>(this ICanSendCommand self, ICommand<TResult> command)`：发送一个有返回值的命令。\r\n\r\n    \r\n\r\n    ### 8.13 ICanSendEvent 接口\r\n\r\n    \r\n\r\n    - **描述：** 定义了可以发送事件的类型的基本功能，继承自 IBelongToArchitecture 接口。\r\n\r\n    \r\n\r\n    ### 8.14 CanSendEventExtension 静态类\r\n\r\n    \r\n\r\n    - **描述：** 提供了 ICanSendEvent 接口的扩展方法，用于发送事件。\r\n    - **方法：**\r\n      - `public static void SendEvent<T>(this ICanSendEvent self) where T : new()`：发送一个无参构造函数的事件。\r\n      - `public static void SendEvent<T>(this ICanSendEvent self, T e)`：发送一个事件。\r\n\r\n    \r\n\r\n    ### 8.15 ICanSendQuery 接口\r\n\r\n    \r\n\r\n    - **描述：** 定义了可以发送查询的类型的基本功能，继承自 IBelongToArchitecture 接口。\r\n\r\n    \r\n\r\n    ### 8.16 CanSendQueryExtension 静态类\r\n\r\n    \r\n\r\n    - **描述：** 提供了 ICanSendQuery 接口的扩展方法，用于发送查询。\r\n    - **方法：**\r\n      - `public static TResult SendQuery<TResult>(this ICanSendQuery self, IQuery<TResult> query)`：发送一个查询。\r\n\r\n    \r\n\r\n    ### 8.17 ICanInit 接口\r\n\r\n    \r\n\r\n    - **描述：** 定义了可以初始化的类型的基本功能。\r\n    - **字段：**\r\n      - `bool Initialized { get; set; }`：指示是否已初始化。\r\n    - **方法：**\r\n      - `void Init()`：初始化。\r\n      - `void Deinit()`：反初始化。\r\n\r\n    \r\n\r\n    ## 9. 类型事件系统（TypeEventSystem）\r\n\r\n    \r\n\r\n    ### 9.1 IUnRegister 接口\r\n\r\n    \r\n\r\n    - **描述：** 定义了取消注册操作的基本功能。\r\n    - **方法：**\r\n      - `void UnRegister()`：取消注册。\r\n\r\n    \r\n\r\n    ### 9.2 IUnRegisterList 接口\r\n\r\n    \r\n\r\n    - **描述：** 定义了取消注册列表的基本功能。\r\n    - **属性：**\r\n      - `List<IUnRegister> UnregisterList { get; }`：取消注册列表。\r\n\r\n    \r\n\r\n    ### 9.3 IUnRegisterListExtension 静态类\r\n\r\n    \r\n\r\n    - **描述：** 提供了 IUnRegisterList 接口的扩展方法，用于管理取消注册列表。\r\n    - **方法：**\r\n      - `public static void AddToUnregisterList(this IUnRegister self, IUnRegisterList unRegisterList)`：将一个取消注册操作添加到列表中。\r\n      - `public static void UnRegisterAll(this IUnRegisterList self)`：取消注册列表中的所有操作。\r\n\r\n    \r\n\r\n    ### 9.4 CustomUnRegister 结构体\r\n\r\n    \r\n\r\n    - **描述：** 自定义的取消注册操作，实现了 IUnRegister 接口。\r\n    - **构造函数：**\r\n      - `public CustomUnRegister(Action onUnRegister)`：创建一个新的 CustomUnRegister 实例。\r\n\r\n    \r\n\r\n    ### 9.5 UnRegisterTrigger 抽象类\r\n\r\n    \r\n\r\n    - **描述：** 取消注册触发器的基类，继承自 UnityEngine.MonoBehaviour。\r\n    - **方法：**\r\n      - `public IUnRegister AddUnRegister(IUnRegister unRegister)`：添加一个取消注册操作。\r\n      - `public void RemoveUnRegister(IUnRegister unRegister)`：移除一个取消注册操作。\r\n      - `public void UnRegister()`：取消注册所有操作。\r\n\r\n    \r\n\r\n    ### 9.6 UnRegisterOnDestroyTrigger 类\r\n\r\n    \r\n\r\n    - **描述：** 在游戏对象销毁时取消注册的触发器，继承自 UnRegisterTrigger。\r\n\r\n    \r\n\r\n    ### 9.7 UnRegisterOnDisableTrigger 类\r\n\r\n    \r\n\r\n    - **描述：** 在游戏对象禁用时取消注册的触发器，继承自 UnRegisterTrigger。\r\n\r\n    \r\n\r\n    ### 9.8 UnRegisterCurrentSceneUnloadedTrigger 类\r\n\r\n    \r\n\r\n    - **描述：** 在当前场景卸载时取消注册的触发器，继承自 UnRegisterTrigger。\r\n    - **属性：**\r\n      - `public static UnRegisterCurrentSceneUnloadedTrigger Get`：获取 UnRegisterCurrentSceneUnloadedTrigger 的实例。\r\n\r\n    \r\n\r\n    ### 9.9 UnRegisterExtension 静态类\r\n\r\n    \r\n\r\n    - **描述：** 提供了 IUnRegister 接口的扩展方法，用于在特定情况下取消注册。\r\n\r\n    \r\n\r\n    ### 9.10 TypeEventSystem 类\r\n\r\n    \r\n\r\n    - **描述：** 类型事件系统，用于发送和接收事件。\r\n    - **字段：**\r\n      - `public static readonly TypeEventSystem Global`：全局的 TypeEventSystem 实例。\r\n    - **方法：**\r\n      - `public void Send<T>() where T : new()`：发送一个无参构造函数的事件。\r\n      - `public void Send<T>(T e)`：发送一个事件。\r\n      - `public IUnRegister Register<T>(Action<T> onEvent)`：注册一个事件监听器。\r\n      - `public void UnRegister<T>(Action<T> onEvent)`：移除一个事件监听器。\r\n\r\n    \r\n\r\n    ## 10. 依赖注入容器（IOC）\r\n\r\n    \r\n\r\n    ### 10.1 IOCContainer 类\r\n\r\n    \r\n\r\n    - **描述：** 依赖注入容器，用于管理依赖关系。\r\n    - **方法：**\r\n      - `public void Register<T>(T instance)`：注册一个实例。\r\n      - `public T Get<T>() where T : class`：获取一个实例。\r\n      - `public IEnumerable<T> GetInstancesByType<T>()`：获取指定类型的所有实例。\r\n      - `public void Clear()`：清空容器。\r\n\r\n    \r\n\r\n    ## 11. 可绑定属性（BindableProperty）\r\n\r\n    \r\n\r\n    ### 11.1 IBindableProperty<T> 接口\r\n\r\n    \r\n\r\n    - **描述：** 定义了可绑定属性的基本功能，继承自 IReadonlyBindableProperty<T> 接口。\r\n    - **类型参数：**\r\n      - `T`：属性值的类型。\r\n    - **属性：**\r\n      - `new T Value { get; set; }`：属性值。\r\n    - **方法：**\r\n      - `void SetValueWithoutEvent(T newValue)`：设置属性值，但不触发事件。\r\n\r\n    \r\n\r\n    ### 11.2 IReadonlyBindableProperty<T> 接口\r\n\r\n    \r\n\r\n    - **描述：** 定义了只读可绑定属性的基本功能，继承自 IEasyEvent 接口。\r\n    - **类型参数：**\r\n      - `T`：属性值的类型。\r\n    - **属性：**\r\n      - `T Value { get; }`：属性值。\r\n    - **方法：**\r\n      - `IUnRegister RegisterWithInitValue(Action<T> action)`：注册一个事件监听器，并在注册时触发一次事件。\r\n      - `void UnRegister(Action<T> onValueChanged)`：移除一个事件监听器。\r\n      - `IUnRegister Register(Action<T> onValueChanged)`：注册一个事件监听器。\r\n\r\n    \r\n\r\n    ### 11.3 BindableProperty<T> 类\r\n\r\n    \r\n\r\n    - **描述：** 可绑定属性的实现类，实现了 IBindableProperty<T> 接口。\r\n    - **类型参数：**\r\n      - `T`：属性值的类型。\r\n    - **字段：**\r\n      - `public static Func<T, T, bool> Comparer { get; set; }`：用于比较两个属性值是否相等的比较器。\r\n    - **构造函数：**\r\n      - `public BindableProperty(T defaultValue = default)`：创建一个新的 BindableProperty 实例。\r\n      - `public BindableProperty<T> WithComparer(Func<T, T, bool> comparer)`：创建一个新的 BindableProperty 实例，并指定比较器。\r\n\r\n    \r\n\r\n    ### 11.4 ComparerAutoRegister 类\r\n\r\n    \r\n\r\n    - **描述：** 用于自动注册常用类型的比较器的类。\r\n\r\n    \r\n\r\n    ## 12. 简单事件（EasyEvent）\r\n\r\n    \r\n\r\n    ### 12.1 IEasyEvent 接口\r\n\r\n    \r\n\r\n    - **描述：** 定义了简单事件的基本功能。\r\n    - **方法：**\r\n      - `IUnRegister Register(Action onEvent)`：注册一个事件监听器。\r\n\r\n    \r\n\r\n    ### 12.2 EasyEvent 类\r\n\r\n    \r\n\r\n    - **描述：** 无参数简单事件的实现类，实现了 IEasyEvent 接口。\r\n    - **方法：**\r\n      - `public IUnRegister Register(Action onEvent)`：注册一个事件监听器。\r\n      - `public void UnRegister(Action onEvent)`：移除一个事件监听器。\r\n      - `public void Trigger()`：触发事件。\r\n\r\n    \r\n\r\n    ### 12.3 EasyEvent<T> 类\r\n\r\n    \r\n\r\n    - **描述：** 单参数简单事件的实现类，实现了 IEasyEvent 接口。\r\n    - **类型参数：**\r\n      - `T`：事件参数的类型。\r\n    - **方法：**\r\n      - `public IUnRegister Register(Action<T> onEvent)`：注册一个事件监听器。\r\n      - `public void UnRegister(Action<T> onEvent)`：移除一个事件监听器。\r\n      - `public void Trigger(T t)`：触发事件。\r\n\r\n    \r\n\r\n    ### 12.4 EasyEvent<T, K> 类\r\n\r\n    \r\n\r\n    - **描述：** 双参数简单事件的实现类，实现了 IEasyEvent 接口。\r\n    - **类型参数：**\r\n      - `T`：第一个事件参数的类型。\r\n      - `K`：第二个事件参数的类型。\r\n    - **方法：**\r\n      - `public IUnRegister Register(Action<T, K> onEvent)`：注册一个事件监听器。\r\n      - `public void UnRegister(Action<T, K> onEvent)`：移除一个事件监听器。\r\n      - `public void Trigger(T t, K k)`：触发事件。\r\n\r\n    \r\n\r\n    ### 12.5 EasyEvent<T, K, S> 类\r\n\r\n    \r\n\r\n    - **描述：** 三参数简单事件的实现类，实现了 IEasyEvent 接口。\r\n    - **类型参数：**\r\n      - `T`：第一个事件参数的类型。\r\n      - `K`：第二个事件参数的类型。\r\n      - `S`：第三个事件参数的类型。\r\n    - **方法：**\r\n      - `public IUnRegister Register(Action<T, K, S> onEvent)`：注册一个事件监听器。\r\n      - `public void UnRegister(Action<T, K, S> onEvent)`：移除一个事件监听器。\r\n      - `public void Trigger(T t, K k, S s)`：触发事件。\r\n\r\n    \r\n\r\n    ### 12.6 EasyEvents 类\r\n\r\n    \r\n\r\n    - **描述：** 用于管理多个简单事件的类。\r\n    - **字段：**\r\n      - `public static readonly EasyEvents mGlobalEvents`：全局的 EasyEvents 实例。\r\n    - **方法：**\r\n      - `public static T Get<T>() where T : IEasyEvent`：获取一个简单事件。\r\n      - `public static void Register<T>() where T : IEasyEvent, new()`：注册一个简单事件。\r\n      - `public void AddEvent<T>() where T : IEasyEvent, new()`：添加一个简单事件。\r\n      - `public T GetEvent<T>() where T : IEasyEvent`：获取一个简单事件。\r\n      - `public T GetOrAddEvent<T>() where T : IEasyEvent, new()`：获取或添加一个简单事件。\r\n\r\n    \r\n\r\n    ## 13. 事件扩展（Event Extension）\r\n\r\n    \r\n\r\n    ### 13.1 OrEvent 类\r\n\r\n    \r\n\r\n    - **描述：** 用于组合多个事件"
        },
        {
          "name": "QFramework.Godot4+",
          "type": "tree",
          "content": null
        },
        {
          "name": "QFramework.NetworkExtension",
          "type": "tree",
          "content": null
        },
        {
          "name": "QFramework.Toolkits.Demo.SaoLei.unitypackage",
          "type": "blob",
          "size": 26.677734375,
          "content": null
        },
        {
          "name": "QFramework.Toolkits.Demo.WuZiQi.unitypackage",
          "type": "blob",
          "size": 134.9365234375,
          "content": null
        },
        {
          "name": "QFramework.Toolkits.unitypackage",
          "type": "blob",
          "size": 5452.4912109375,
          "content": ""
        },
        {
          "name": "QFramework.Unity2018+",
          "type": "tree",
          "content": null
        },
        {
          "name": "QFramework.cs",
          "type": "blob",
          "size": 27.1416015625,
          "content": "﻿/****************************************************************************\n * Copyright (c) 2015 ~ 2024 liangxiegame MIT License\n *\n * QFramework v1.0\n *\n * https://qframework.cn\n * https://github.com/liangxiegame/QFramework\n * https://gitee.com/liangxiegame/QFramework\n *\n * Author:\n *  liangxie        https://github.com/liangxie\n *  soso            https://github.com/so-sos-so\n *\n * Contributor\n *  TastSong        https://github.com/TastSong\n *  京产肠饭         https://gitee.com/JingChanChangFan/hk_-unity-tools\n *  猫叔(一只皮皮虾) https://space.bilibili.com/656352/\n *  misakiMeiii     https://github.com/misakiMeiii\n *  New一天\n *  幽飞冷凝雪～冷\n *\n * Community\n *  QQ Group: 623597263\n * \n * Latest Update: 2024.5.12 20:17 add UnRegisterWhenCurrentSceneUnloaded(Suggested by misakiMeiii) \n ****************************************************************************/\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing UnityEngine;\nusing UnityEngine.SceneManagement;\n\nnamespace QFramework\n{\n    #region Architecture\n\n    public interface IArchitecture\n    {\n        void RegisterSystem<T>(T system) where T : ISystem;\n\n        void RegisterModel<T>(T model) where T : IModel;\n\n        void RegisterUtility<T>(T utility) where T : IUtility;\n\n        T GetSystem<T>() where T : class, ISystem;\n\n        T GetModel<T>() where T : class, IModel;\n\n        T GetUtility<T>() where T : class, IUtility;\n\n        void SendCommand<T>(T command) where T : ICommand;\n\n        TResult SendCommand<TResult>(ICommand<TResult> command);\n\n        TResult SendQuery<TResult>(IQuery<TResult> query);\n\n        void SendEvent<T>() where T : new();\n        void SendEvent<T>(T e);\n\n        IUnRegister RegisterEvent<T>(Action<T> onEvent);\n        void UnRegisterEvent<T>(Action<T> onEvent);\n\n        void Deinit();\n    }\n\n    public abstract class Architecture<T> : IArchitecture where T : Architecture<T>, new()\n    {\n        private bool mInited = false;\n\n\n        public static Action<T> OnRegisterPatch = architecture => { };\n\n        protected static T mArchitecture;\n\n        public static IArchitecture Interface\n        {\n            get\n            {\n                if (mArchitecture == null) MakeSureArchitecture();\n                return mArchitecture;\n            }\n        }\n\n\n        static void MakeSureArchitecture()\n        {\n            if (mArchitecture == null)\n            {\n                mArchitecture = new T();\n                mArchitecture.Init();\n\n                OnRegisterPatch?.Invoke(mArchitecture);\n\n                foreach (var model in mArchitecture.mContainer.GetInstancesByType<IModel>().Where(m => !m.Initialized))\n                {\n                    model.Init();\n                    model.Initialized = true;\n                }\n\n                foreach (var system in mArchitecture.mContainer.GetInstancesByType<ISystem>()\n                             .Where(m => !m.Initialized))\n                {\n                    system.Init();\n                    system.Initialized = true;\n                }\n\n                mArchitecture.mInited = true;\n            }\n        }\n\n        protected abstract void Init();\n\n        public void Deinit()\n        {\n            OnDeinit();\n            foreach (var system in mContainer.GetInstancesByType<ISystem>().Where(s => s.Initialized)) system.Deinit();\n            foreach (var model in mContainer.GetInstancesByType<IModel>().Where(m => m.Initialized)) model.Deinit();\n            mContainer.Clear();\n            mArchitecture = null;\n        }\n\n        protected virtual void OnDeinit()\n        {\n        }\n\n        private IOCContainer mContainer = new IOCContainer();\n\n        public void RegisterSystem<TSystem>(TSystem system) where TSystem : ISystem\n        {\n            system.SetArchitecture(this);\n            mContainer.Register<TSystem>(system);\n\n            if (mInited)\n            {\n                system.Init();\n                system.Initialized = true;\n            }\n        }\n\n        public void RegisterModel<TModel>(TModel model) where TModel : IModel\n        {\n            model.SetArchitecture(this);\n            mContainer.Register<TModel>(model);\n\n            if (mInited)\n            {\n                model.Init();\n                model.Initialized = true;\n            }\n        }\n\n        public void RegisterUtility<TUtility>(TUtility utility) where TUtility : IUtility =>\n            mContainer.Register<TUtility>(utility);\n\n        public TSystem GetSystem<TSystem>() where TSystem : class, ISystem => mContainer.Get<TSystem>();\n\n        public TModel GetModel<TModel>() where TModel : class, IModel => mContainer.Get<TModel>();\n\n        public TUtility GetUtility<TUtility>() where TUtility : class, IUtility => mContainer.Get<TUtility>();\n\n        public TResult SendCommand<TResult>(ICommand<TResult> command) => ExecuteCommand(command);\n\n        public void SendCommand<TCommand>(TCommand command) where TCommand : ICommand => ExecuteCommand(command);\n\n        protected virtual TResult ExecuteCommand<TResult>(ICommand<TResult> command)\n        {\n            command.SetArchitecture(this);\n            return command.Execute();\n        }\n\n        protected virtual void ExecuteCommand(ICommand command)\n        {\n            command.SetArchitecture(this);\n            command.Execute();\n        }\n\n        public TResult SendQuery<TResult>(IQuery<TResult> query) => DoQuery<TResult>(query);\n\n        protected virtual TResult DoQuery<TResult>(IQuery<TResult> query)\n        {\n            query.SetArchitecture(this);\n            return query.Do();\n        }\n\n        private TypeEventSystem mTypeEventSystem = new TypeEventSystem();\n\n        public void SendEvent<TEvent>() where TEvent : new() => mTypeEventSystem.Send<TEvent>();\n\n        public void SendEvent<TEvent>(TEvent e) => mTypeEventSystem.Send<TEvent>(e);\n\n        public IUnRegister RegisterEvent<TEvent>(Action<TEvent> onEvent) => mTypeEventSystem.Register<TEvent>(onEvent);\n\n        public void UnRegisterEvent<TEvent>(Action<TEvent> onEvent) => mTypeEventSystem.UnRegister<TEvent>(onEvent);\n    }\n\n    public interface IOnEvent<T>\n    {\n        void OnEvent(T e);\n    }\n\n    public static class OnGlobalEventExtension\n    {\n        public static IUnRegister RegisterEvent<T>(this IOnEvent<T> self) where T : struct =>\n            TypeEventSystem.Global.Register<T>(self.OnEvent);\n\n        public static void UnRegisterEvent<T>(this IOnEvent<T> self) where T : struct =>\n            TypeEventSystem.Global.UnRegister<T>(self.OnEvent);\n    }\n\n    #endregion\n\n    #region Controller\n\n    public interface IController : IBelongToArchitecture, ICanSendCommand, ICanGetSystem, ICanGetModel,\n        ICanRegisterEvent, ICanSendQuery, ICanGetUtility\n    {\n    }\n\n    #endregion\n\n    #region System\n\n    public interface ISystem : IBelongToArchitecture, ICanSetArchitecture, ICanGetModel, ICanGetUtility,\n        ICanRegisterEvent, ICanSendEvent, ICanGetSystem, ICanInit\n    {\n    }\n\n    public abstract class AbstractSystem : ISystem\n    {\n        private IArchitecture mArchitecture;\n\n        IArchitecture IBelongToArchitecture.GetArchitecture() => mArchitecture;\n\n        void ICanSetArchitecture.SetArchitecture(IArchitecture architecture) => mArchitecture = architecture;\n\n        public bool Initialized { get; set; }\n        void ICanInit.Init() => OnInit();\n\n        public void Deinit() => OnDeinit();\n\n        protected virtual void OnDeinit()\n        {\n        }\n\n        protected abstract void OnInit();\n    }\n\n    #endregion\n\n    #region Model\n\n    public interface IModel : IBelongToArchitecture, ICanSetArchitecture, ICanGetUtility, ICanSendEvent, ICanInit\n    {\n    }\n\n    public abstract class AbstractModel : IModel\n    {\n        private IArchitecture mArchitecturel;\n\n        IArchitecture IBelongToArchitecture.GetArchitecture() => mArchitecturel;\n\n        void ICanSetArchitecture.SetArchitecture(IArchitecture architecture) => mArchitecturel = architecture;\n\n        public bool Initialized { get; set; }\n        void ICanInit.Init() => OnInit();\n        public void Deinit() => OnDeinit();\n\n        protected virtual void OnDeinit()\n        {\n        }\n\n        protected abstract void OnInit();\n    }\n\n    #endregion\n\n    #region Utility\n\n    public interface IUtility\n    {\n    }\n\n    #endregion\n\n    #region Command\n\n    public interface ICommand : IBelongToArchitecture, ICanSetArchitecture, ICanGetSystem, ICanGetModel, ICanGetUtility,\n        ICanSendEvent, ICanSendCommand, ICanSendQuery\n    {\n        void Execute();\n    }\n\n    public interface ICommand<TResult> : IBelongToArchitecture, ICanSetArchitecture, ICanGetSystem, ICanGetModel,\n        ICanGetUtility,\n        ICanSendEvent, ICanSendCommand, ICanSendQuery\n    {\n        TResult Execute();\n    }\n\n    public abstract class AbstractCommand : ICommand\n    {\n        private IArchitecture mArchitecture;\n\n        IArchitecture IBelongToArchitecture.GetArchitecture() => mArchitecture;\n\n        void ICanSetArchitecture.SetArchitecture(IArchitecture architecture) => mArchitecture = architecture;\n\n        void ICommand.Execute() => OnExecute();\n\n        protected abstract void OnExecute();\n    }\n\n    public abstract class AbstractCommand<TResult> : ICommand<TResult>\n    {\n        private IArchitecture mArchitecture;\n\n        IArchitecture IBelongToArchitecture.GetArchitecture() => mArchitecture;\n\n        void ICanSetArchitecture.SetArchitecture(IArchitecture architecture) => mArchitecture = architecture;\n\n        TResult ICommand<TResult>.Execute() => OnExecute();\n\n        protected abstract TResult OnExecute();\n    }\n\n    #endregion\n\n    #region Query\n\n    public interface IQuery<TResult> : IBelongToArchitecture, ICanSetArchitecture, ICanGetModel, ICanGetSystem,\n        ICanSendQuery\n    {\n        TResult Do();\n    }\n\n    public abstract class AbstractQuery<T> : IQuery<T>\n    {\n        public T Do() => OnDo();\n\n        protected abstract T OnDo();\n\n\n        private IArchitecture mArchitecture;\n\n        public IArchitecture GetArchitecture() => mArchitecture;\n\n        public void SetArchitecture(IArchitecture architecture) => mArchitecture = architecture;\n    }\n\n    #endregion\n\n    #region Rule\n\n    public interface IBelongToArchitecture\n    {\n        IArchitecture GetArchitecture();\n    }\n\n    public interface ICanSetArchitecture\n    {\n        void SetArchitecture(IArchitecture architecture);\n    }\n\n    public interface ICanGetModel : IBelongToArchitecture\n    {\n    }\n\n    public static class CanGetModelExtension\n    {\n        public static T GetModel<T>(this ICanGetModel self) where T : class, IModel =>\n            self.GetArchitecture().GetModel<T>();\n    }\n\n    public interface ICanGetSystem : IBelongToArchitecture\n    {\n    }\n\n    public static class CanGetSystemExtension\n    {\n        public static T GetSystem<T>(this ICanGetSystem self) where T : class, ISystem =>\n            self.GetArchitecture().GetSystem<T>();\n    }\n\n    public interface ICanGetUtility : IBelongToArchitecture\n    {\n    }\n\n    public static class CanGetUtilityExtension\n    {\n        public static T GetUtility<T>(this ICanGetUtility self) where T : class, IUtility =>\n            self.GetArchitecture().GetUtility<T>();\n    }\n\n    public interface ICanRegisterEvent : IBelongToArchitecture\n    {\n    }\n\n    public static class CanRegisterEventExtension\n    {\n        public static IUnRegister RegisterEvent<T>(this ICanRegisterEvent self, Action<T> onEvent) =>\n            self.GetArchitecture().RegisterEvent<T>(onEvent);\n\n        public static void UnRegisterEvent<T>(this ICanRegisterEvent self, Action<T> onEvent) =>\n            self.GetArchitecture().UnRegisterEvent<T>(onEvent);\n    }\n\n    public interface ICanSendCommand : IBelongToArchitecture\n    {\n    }\n\n    public static class CanSendCommandExtension\n    {\n        public static void SendCommand<T>(this ICanSendCommand self) where T : ICommand, new() =>\n            self.GetArchitecture().SendCommand<T>(new T());\n\n        public static void SendCommand<T>(this ICanSendCommand self, T command) where T : ICommand =>\n            self.GetArchitecture().SendCommand<T>(command);\n\n        public static TResult SendCommand<TResult>(this ICanSendCommand self, ICommand<TResult> command) =>\n            self.GetArchitecture().SendCommand(command);\n    }\n\n    public interface ICanSendEvent : IBelongToArchitecture\n    {\n    }\n\n    public static class CanSendEventExtension\n    {\n        public static void SendEvent<T>(this ICanSendEvent self) where T : new() =>\n            self.GetArchitecture().SendEvent<T>();\n\n        public static void SendEvent<T>(this ICanSendEvent self, T e) => self.GetArchitecture().SendEvent<T>(e);\n    }\n\n    public interface ICanSendQuery : IBelongToArchitecture\n    {\n    }\n\n    public static class CanSendQueryExtension\n    {\n        public static TResult SendQuery<TResult>(this ICanSendQuery self, IQuery<TResult> query) =>\n            self.GetArchitecture().SendQuery(query);\n    }\n\n    public interface ICanInit\n    {\n        bool Initialized { get; set; }\n        void Init();\n        void Deinit();\n    }\n\n    #endregion\n\n    #region TypeEventSystem\n\n    public interface IUnRegister\n    {\n        void UnRegister();\n    }\n\n    public interface IUnRegisterList\n    {\n        List<IUnRegister> UnregisterList { get; }\n    }\n\n    public static class IUnRegisterListExtension\n    {\n        public static void AddToUnregisterList(this IUnRegister self, IUnRegisterList unRegisterList) =>\n            unRegisterList.UnregisterList.Add(self);\n\n        public static void UnRegisterAll(this IUnRegisterList self)\n        {\n            foreach (var unRegister in self.UnregisterList)\n            {\n                unRegister.UnRegister();\n            }\n\n            self.UnregisterList.Clear();\n        }\n    }\n\n    public struct CustomUnRegister : IUnRegister\n    {\n        private Action mOnUnRegister { get; set; }\n        public CustomUnRegister(Action onUnRegister) => mOnUnRegister = onUnRegister;\n\n        public void UnRegister()\n        {\n            mOnUnRegister.Invoke();\n            mOnUnRegister = null;\n        }\n    }\n\n#if UNITY_5_6_OR_NEWER\n    public abstract class UnRegisterTrigger : UnityEngine.MonoBehaviour\n    {\n        private readonly HashSet<IUnRegister> mUnRegisters = new HashSet<IUnRegister>();\n\n        public IUnRegister AddUnRegister(IUnRegister unRegister)\n        {\n            mUnRegisters.Add(unRegister);\n            return unRegister;\n        }\n\n        public void RemoveUnRegister(IUnRegister unRegister) => mUnRegisters.Remove(unRegister);\n\n        public void UnRegister()\n        {\n            foreach (var unRegister in mUnRegisters)\n            {\n                unRegister.UnRegister();\n            }\n\n            mUnRegisters.Clear();\n        }\n    }\n\n    public class UnRegisterOnDestroyTrigger : UnRegisterTrigger\n    {\n        private void OnDestroy()\n        {\n            UnRegister();\n        }\n    }\n\n    public class UnRegisterOnDisableTrigger : UnRegisterTrigger\n    {\n        private void OnDisable()\n        {\n            UnRegister();\n        }\n    }\n\n    public class UnRegisterCurrentSceneUnloadedTrigger : UnRegisterTrigger\n    {\n        private static UnRegisterCurrentSceneUnloadedTrigger mDefault;\n\n        public static UnRegisterCurrentSceneUnloadedTrigger Get\n        {\n            get\n            {\n                if (!mDefault)\n                {\n                    mDefault = new GameObject(\"UnRegisterCurrentSceneUnloadedTrigger\")\n                        .AddComponent<UnRegisterCurrentSceneUnloadedTrigger>();\n                }\n\n                return mDefault;\n            }\n        }\n\n        private void Awake()\n        {\n            DontDestroyOnLoad(this);\n            hideFlags = HideFlags.HideInHierarchy;\n            SceneManager.sceneUnloaded += OnSceneUnloaded;\n        }\n\n        private void OnDestroy() => SceneManager.sceneUnloaded -= OnSceneUnloaded;\n        void OnSceneUnloaded(Scene scene) => UnRegister();\n    }\n#endif\n\n    public static class UnRegisterExtension\n    {\n#if UNITY_5_6_OR_NEWER\n\n        static T GetOrAddComponent<T>(GameObject gameObject) where T : Component\n        {\n            var trigger = gameObject.GetComponent<T>();\n\n            if (!trigger)\n            {\n                trigger = gameObject.AddComponent<T>();\n            }\n\n            return trigger;\n        }\n\n        public static IUnRegister UnRegisterWhenGameObjectDestroyed(this IUnRegister unRegister,\n            UnityEngine.GameObject gameObject) =>\n            GetOrAddComponent<UnRegisterOnDestroyTrigger>(gameObject)\n                .AddUnRegister(unRegister);\n\n        public static IUnRegister UnRegisterWhenGameObjectDestroyed<T>(this IUnRegister self, T component)\n            where T : UnityEngine.Component =>\n            self.UnRegisterWhenGameObjectDestroyed(component.gameObject);\n\n        public static IUnRegister UnRegisterWhenDisabled<T>(this IUnRegister self, T component)\n            where T : UnityEngine.Component =>\n            self.UnRegisterWhenDisabled(component.gameObject);\n\n        public static IUnRegister UnRegisterWhenDisabled(this IUnRegister unRegister,\n            UnityEngine.GameObject gameObject) =>\n            GetOrAddComponent<UnRegisterOnDisableTrigger>(gameObject)\n                .AddUnRegister(unRegister);\n        \n        public static IUnRegister UnRegisterWhenCurrentSceneUnloaded(this IUnRegister self) =>\n            UnRegisterCurrentSceneUnloadedTrigger.Get.AddUnRegister(self);\n#endif\n\n\n#if GODOT\n\t\tpublic static IUnRegister UnRegisterWhenNodeExitTree(this IUnRegister unRegister, Godot.Node node)\n\t\t{\n\t\t\tnode.TreeExiting += unRegister.UnRegister;\n\t\t\treturn unRegister;\n\t\t}\n#endif\n    }\n\n    public class TypeEventSystem\n    {\n        private readonly EasyEvents mEvents = new EasyEvents();\n\n        public static readonly TypeEventSystem Global = new TypeEventSystem();\n\n        public void Send<T>() where T : new() => mEvents.GetEvent<EasyEvent<T>>()?.Trigger(new T());\n\n        public void Send<T>(T e) => mEvents.GetEvent<EasyEvent<T>>()?.Trigger(e);\n\n        public IUnRegister Register<T>(Action<T> onEvent) => mEvents.GetOrAddEvent<EasyEvent<T>>().Register(onEvent);\n\n        public void UnRegister<T>(Action<T> onEvent)\n        {\n            var e = mEvents.GetEvent<EasyEvent<T>>();\n            e?.UnRegister(onEvent);\n        }\n    }\n\n    #endregion\n\n    #region IOC\n\n    public class IOCContainer\n    {\n        private Dictionary<Type, object> mInstances = new Dictionary<Type, object>();\n\n        public void Register<T>(T instance)\n        {\n            var key = typeof(T);\n\n            if (mInstances.ContainsKey(key))\n            {\n                mInstances[key] = instance;\n            }\n            else\n            {\n                mInstances.Add(key, instance);\n            }\n        }\n\n        public T Get<T>() where T : class\n        {\n            var key = typeof(T);\n\n            if (mInstances.TryGetValue(key, out var retInstance))\n            {\n                return retInstance as T;\n            }\n\n            return null;\n        }\n\n        public IEnumerable<T> GetInstancesByType<T>()\n        {\n            var type = typeof(T);\n            return mInstances.Values.Where(instance => type.IsInstanceOfType(instance)).Cast<T>();\n        }\n\n        public void Clear() => mInstances.Clear();\n    }\n\n    #endregion\n\n    #region BindableProperty\n\n    public interface IBindableProperty<T> : IReadonlyBindableProperty<T>\n    {\n        new T Value { get; set; }\n        void SetValueWithoutEvent(T newValue);\n    }\n\n    public interface IReadonlyBindableProperty<T> : IEasyEvent\n    {\n        T Value { get; }\n\n        IUnRegister RegisterWithInitValue(Action<T> action);\n        void UnRegister(Action<T> onValueChanged);\n        IUnRegister Register(Action<T> onValueChanged);\n    }\n\n    public class BindableProperty<T> : IBindableProperty<T>\n    {\n        public BindableProperty(T defaultValue = default) => mValue = defaultValue;\n\n        protected T mValue;\n\n        public static Func<T, T, bool> Comparer { get; set; } = (a, b) => a.Equals(b);\n\n        public BindableProperty<T> WithComparer(Func<T, T, bool> comparer)\n        {\n            Comparer = comparer;\n            return this;\n        }\n\n        public T Value\n        {\n            get => GetValue();\n            set\n            {\n                if (value == null && mValue == null) return;\n                if (value != null && Comparer(value, mValue)) return;\n\n                SetValue(value);\n                mOnValueChanged.Trigger(value);\n            }\n        }\n\n        protected virtual void SetValue(T newValue) => mValue = newValue;\n\n        protected virtual T GetValue() => mValue;\n\n        public void SetValueWithoutEvent(T newValue) => mValue = newValue;\n\n        private EasyEvent<T> mOnValueChanged = new EasyEvent<T>();\n\n        public IUnRegister Register(Action<T> onValueChanged)\n        {\n            return mOnValueChanged.Register(onValueChanged);\n        }\n\n        public IUnRegister RegisterWithInitValue(Action<T> onValueChanged)\n        {\n            onValueChanged(mValue);\n            return Register(onValueChanged);\n        }\n\n        public void UnRegister(Action<T> onValueChanged) => mOnValueChanged.UnRegister(onValueChanged);\n\n        IUnRegister IEasyEvent.Register(Action onEvent)\n        {\n            return Register(Action);\n            void Action(T _) => onEvent();\n        }\n\n        public override string ToString() => Value.ToString();\n    }\n\n    internal class ComparerAutoRegister\n    {\n#if UNITY_5_6_OR_NEWER\n        [UnityEngine.RuntimeInitializeOnLoadMethod(UnityEngine.RuntimeInitializeLoadType.BeforeSceneLoad)]\n        public static void AutoRegister()\n        {\n            BindableProperty<int>.Comparer = (a, b) => a == b;\n            BindableProperty<float>.Comparer = (a, b) => a == b;\n            BindableProperty<double>.Comparer = (a, b) => a == b;\n            BindableProperty<string>.Comparer = (a, b) => a == b;\n            BindableProperty<long>.Comparer = (a, b) => a == b;\n            BindableProperty<UnityEngine.Vector2>.Comparer = (a, b) => a == b;\n            BindableProperty<UnityEngine.Vector3>.Comparer = (a, b) => a == b;\n            BindableProperty<UnityEngine.Vector4>.Comparer = (a, b) => a == b;\n            BindableProperty<UnityEngine.Color>.Comparer = (a, b) => a == b;\n            BindableProperty<UnityEngine.Color32>.Comparer =\n                (a, b) => a.r == b.r && a.g == b.g && a.b == b.b && a.a == b.a;\n            BindableProperty<UnityEngine.Bounds>.Comparer = (a, b) => a == b;\n            BindableProperty<UnityEngine.Rect>.Comparer = (a, b) => a == b;\n            BindableProperty<UnityEngine.Quaternion>.Comparer = (a, b) => a == b;\n            BindableProperty<UnityEngine.Vector2Int>.Comparer = (a, b) => a == b;\n            BindableProperty<UnityEngine.Vector3Int>.Comparer = (a, b) => a == b;\n            BindableProperty<UnityEngine.BoundsInt>.Comparer = (a, b) => a == b;\n            BindableProperty<UnityEngine.RangeInt>.Comparer = (a, b) => a.start == b.start && a.length == b.length;\n            BindableProperty<UnityEngine.RectInt>.Comparer = (a, b) => a.Equals(b);\n        }\n#endif\n    }\n\n    #endregion\n\n    #region EasyEvent\n\n    public interface IEasyEvent\n    {\n        IUnRegister Register(Action onEvent);\n    }\n\n    public class EasyEvent : IEasyEvent\n    {\n        private Action mOnEvent = () => { };\n\n        public IUnRegister Register(Action onEvent)\n        {\n            mOnEvent += onEvent;\n            return new CustomUnRegister(() => { UnRegister(onEvent); });\n        }\n\n        public void UnRegister(Action onEvent) => mOnEvent -= onEvent;\n\n        public void Trigger() => mOnEvent?.Invoke();\n    }\n\n    public class EasyEvent<T> : IEasyEvent\n    {\n        private Action<T> mOnEvent = e => { };\n\n        public IUnRegister Register(Action<T> onEvent)\n        {\n            mOnEvent += onEvent;\n            return new CustomUnRegister(() => { UnRegister(onEvent); });\n        }\n\n        public void UnRegister(Action<T> onEvent) => mOnEvent -= onEvent;\n\n        public void Trigger(T t) => mOnEvent?.Invoke(t);\n\n        IUnRegister IEasyEvent.Register(Action onEvent)\n        {\n            return Register(Action);\n            void Action(T _) => onEvent();\n        }\n    }\n\n    public class EasyEvent<T, K> : IEasyEvent\n    {\n        private Action<T, K> mOnEvent = (t, k) => { };\n\n        public IUnRegister Register(Action<T, K> onEvent)\n        {\n            mOnEvent += onEvent;\n            return new CustomUnRegister(() => { UnRegister(onEvent); });\n        }\n\n        public void UnRegister(Action<T, K> onEvent) => mOnEvent -= onEvent;\n\n        public void Trigger(T t, K k) => mOnEvent?.Invoke(t, k);\n\n        IUnRegister IEasyEvent.Register(Action onEvent)\n        {\n            return Register(Action);\n            void Action(T _, K __) => onEvent();\n        }\n    }\n\n    public class EasyEvent<T, K, S> : IEasyEvent\n    {\n        private Action<T, K, S> mOnEvent = (t, k, s) => { };\n\n        public IUnRegister Register(Action<T, K, S> onEvent)\n        {\n            mOnEvent += onEvent;\n            return new CustomUnRegister(() => { UnRegister(onEvent); });\n        }\n\n        public void UnRegister(Action<T, K, S> onEvent) => mOnEvent -= onEvent;\n\n        public void Trigger(T t, K k, S s) => mOnEvent?.Invoke(t, k, s);\n\n        IUnRegister IEasyEvent.Register(Action onEvent)\n        {\n            return Register(Action);\n            void Action(T _, K __, S ___) => onEvent();\n        }\n    }\n\n    public class EasyEvents\n    {\n        private static readonly EasyEvents mGlobalEvents = new EasyEvents();\n\n        public static T Get<T>() where T : IEasyEvent => mGlobalEvents.GetEvent<T>();\n\n        public static void Register<T>() where T : IEasyEvent, new() => mGlobalEvents.AddEvent<T>();\n\n        private readonly Dictionary<Type, IEasyEvent> mTypeEvents = new Dictionary<Type, IEasyEvent>();\n\n        public void AddEvent<T>() where T : IEasyEvent, new() => mTypeEvents.Add(typeof(T), new T());\n\n        public T GetEvent<T>() where T : IEasyEvent\n        {\n            return mTypeEvents.TryGetValue(typeof(T), out var e) ? (T)e : default;\n        }\n\n        public T GetOrAddEvent<T>() where T : IEasyEvent, new()\n        {\n            var eType = typeof(T);\n            if (mTypeEvents.TryGetValue(eType, out var e))\n            {\n                return (T)e;\n            }\n\n            var t = new T();\n            mTypeEvents.Add(eType, t);\n            return t;\n        }\n    }\n\n    #endregion\n\n\n    #region Event Extension\n\n    public class OrEvent : IUnRegisterList\n    {\n        public OrEvent Or(IEasyEvent easyEvent)\n        {\n            easyEvent.Register(Trigger).AddToUnregisterList(this);\n            return this;\n        }\n\n        private Action mOnEvent = () => { };\n\n        public IUnRegister Register(Action onEvent)\n        {\n            mOnEvent += onEvent;\n            return new CustomUnRegister(() => { UnRegister(onEvent); });\n        }\n\n        public void UnRegister(Action onEvent)\n        {\n            mOnEvent -= onEvent;\n            this.UnRegisterAll();\n        }\n\n        private void Trigger() => mOnEvent?.Invoke();\n\n        public List<IUnRegister> UnregisterList { get; } = new List<IUnRegister>();\n    }\n\n    public static class OrEventExtensions\n    {\n        public static OrEvent Or(this IEasyEvent self, IEasyEvent e) => new OrEvent().Or(self).Or(e);\n    }\n\n    #endregion\n\n#if UNITY_EDITOR\n    internal class EditorMenus\n    {\n        [UnityEditor.MenuItem(\"QFramework/Install QFrameworkWithToolKits\")]\n        public static void InstallPackageKit() => UnityEngine.Application.OpenURL(\"https://qframework.cn/qf\");\n    }\n#endif\n}"
        },
        {
          "name": "QFramework.cs.Examples.unitypackage",
          "type": "blob",
          "size": 1998.306640625,
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.7197265625,
          "content": "\n\n\n\n\n\n\n\n![LOGO](LOGO.png)\n\n\n\n[![](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/liangxiegame/QFramework/blob/master/LICENSE)\n\n# QFramework 简介 Intro\n\n[中文]()|[English](README_EN.md)\n\n[QFramework](https://github.com/liangxiegame/QFramework) 是提供一套简单、强大、易上手、符合 SOLID 原则、支持领域驱动设计（DDD）、事件驱动、数据驱动、分层、MVC 、CQRS、模块化、易扩展的架构，她的源码只有不到 1000 行，你可以完全把她放在你的笔记应用里保存。\n\n## 提供的架构图\n\n![](http://processon.com/chart_image/5c270aa6e4b007ba5d5029dc.png)\n\n## 举个例子（一图胜千言😂）\n\n![](https://file.liangxiegame.com/6bf42306-0b2a-4417-bbcf-354af0132596.png)\n\n## 各种情况的示意图\n\n![](http://processon.com/chart_image/5cbb1edce4b0bab90960a4f6.png)\n\n## 架构使用规范\n\n**QFramework系统设计架构分为四层及其规则：**\n\n* 表现层：ViewController层。IController接口，负责接收输入和状态变化时的表现，一般情况下，MonoBehaviour 均为表现层\n    * 可以获取System\n    * 可以获取Model\n    * 可以发送Command\n    * 可以监听Event\n* 系统层：System层。ISystem接口，帮助IController承担一部分逻辑，在多个表现层共享的逻辑，比如计时系统、商城系统、成就系统等\n    * 可以获取System\n    * 可以获取Model\n    * 可以监听Event\n    * 可以发送Event\n* 数据层：Model层。IModel接口，负责数据的定义、数据的增删查改方法的提供\n    * 可以获取Utility\n    * 可以发送Event\n* 工具层：Utility层。IUtility接口，负责提供基础设施，比如存储方法、序列化方法、网络连接方法、蓝牙方法、SDK、框架继承等。啥都干不了，可以集成第三方库，或者封装API\n* 除了四个层级，还有一个核心概念——Command\n    * 可以获取System\n    * 可以获取Model\n    * 可以发送Event\n    * 可以发送Command\n* 层级规则：\n    * IController 更改 ISystem、IModel 的状态必须用Command\n    * ISystem、IModel状态发生变更后通知IController必须用事件或BindableProperty\n    * IController可以获取ISystem、IModel对象来进行数据查询\n    * ICommand不能有状态\n    * 上层可以直接获取下层，下层不能获取上层对象\n    * 下层向上层通信用事件\n    * 上层向下层通信用方法调用（只是做查询，状态变更用Command），IController的交互逻辑为特别情况，只能用Command\n\n（照抄自：[学生课堂笔记1](https://github.com/Haogehaojiu/FrameworkDesign)）\n\n### 运行环境\n\n* Unity 2018.4.x ~ Unity 6.x\n\n## 安装\n\n* QFramework.cs \n    * 直接复制[此代码](QFramework.cs)到自己项目中的任意脚本中\n* QFramework.cs 与 官方示例\n    * [点此下载 unitypackage](./QFramework.cs.Examples.unitypackage)\n\n* QFramework.ToolKits\n    * [点此下载 unitypackage](./QFramework.Toolkits.unitypackage)\n* QFramework.ToolKitsPro\n    * 从 [AssetStore](http://u3d.as/SJ9) 安装\n\n\n\n## 资源\n\n| **版本** |                                      |                                                          |\n| ----------------------  | ---------------------------------------- | ------------------------------------------------------------ |\n| QFramework.cs | QFramework 本体架构的实现 | [文件](QFramework.cs) |\n| QFramework.cs  示例 | QFramework.cs 与官方示例： CounterApp、《点点点》、FlappyBird、CubeMaster、ShootingEditor2D、贪吃蛇等 | [点此下载 unitypackage](./QFramework.cs.Examples.unitypackage) |\n| QFramework.Toolkits | QFramework  集成 CoreKit/UIKit/ActionKit/ResKit/PackageKit/AudioKit 等全部官方工具（已包含 QFramework.cs 和 示例) | [点此下载 unitypackage](./QFramework.Toolkits.unitypackage) |\n| QFramework.Toolkits.Demo.WuZiQi | 使用 QFramework.Toolkits 开发的五子棋 Demo（需要安装好  QFramework.Toolkits） | [点此下载 unitypackage](./QFramework.Toolkits.Demo.WuZiQi.unitypackage) |\n| QFramework.Toolkits.Demo.Saolei | 使用 QFramework.Toolkits 开发的扫雷 Demo（需要安装好  QFramework.Toolkits） | [点此下载 unitypackage](./QFramework.Toolkits.Demo.SaoLei.unitypackage) |\n| QFramework.ToolKitsPro | 在 ToolKits 基础上集成更多好用的工具的版本（已包含 QFramework.Toolkits） | [AssetStore](http://u3d.as/SJ9) |\n| **群友案例** |  |  |\n| 赛车游戏《Crazy Car》 | 群友 [TastSong](https://github.com/TastSong) 使用 QF 进行重构的开源赛车游戏 | [游戏主页(Github](https://github.com/TastSong/CrazyCar)) |\n| **社区** |  |  |\n| QQ 群1（已满）：623597263 | 交流群 | [点击加群](https://qm.qq.com/cgi-bin/qm/qr?k=G4DZ_6qMbN8miP8RcRD9NdhNcVyrD88F&jump_from=webapi&authKey=P8WO3esK/KbDxWPHI5F3EC04IPT6jDSkk/tl73/EHIcRkMTvnLhwpTK1PtHr6V+p) |\n| QQ 群2：541745166 | 交流群 | [点击加群](https://qm.qq.com/q/VI5Od3rri4) |\n| QQ 频道 :qframework        | 交流群&社区 | [点击加入频道](https://pd.qq.com/s/52bw86mlv) |\n| **教程** |  |  |\n| 《框架搭建 决定版》    | 教程 QFramework  的核心架构是怎么演化过来的？ | [课程主页](https://learn.u3d.cn/tutorial/framework_design)\\|[学生课堂笔记1](https://github.com/Haogehaojiu/FrameworkDesign)\\|[学生课堂笔记2](https://github.com/Haogehaojiu/ShootingEditor2D) |\n| **产品案例** | 如果用了 qf 并且想要在如下列表中登记，可以在 github/gitee 的 issue 里发帖子,也可以加 qq 群，也可以用邮箱联系凉鞋 liangxiegame@163.com，当然如果看到使用 qf 的项目，我也会先去尝试征得同意再放到如下列表。 |  |\n| ![](./README/boxbread.jpeg) | 独立游戏《盒子面包坊》 | [TapTap](https://www.taptap.cn/app/384085) \\| [Steam](https://store.steampowered.com/app/2942950/_/) |\n| ![](./README/X-teroids.png) | 独立游戏《X-teriods》 | [Steam](https://store.steampowered.com/app/3342540/Xteroids/) |\n| ![](./README/hanchen.jpg) | 独立游戏《汉尘：腐草为萤》 | [Steam](https://store.steampowered.com/app/2078910/_/)\\|[摩点](https://m.modian.com/project/135490.html) |\n| ![](./README/thebirthofsprites.jpg) | 独立游戏《你好茄子：精灵的诞生》 | [Steam](https://store.steampowered.com/app/2375290/_/) |\n| ![](./README/huoche.jpg) | 独立游戏《当火车鸣笛三秒》 | [Steam](https://store.steampowered.com/app/1563700/_/)\\|[TapTap](https://www.taptap.cn/app/208258) |\n| ![](./README/qiezi1.jpg) | 独立游戏《你好茄子》 | [Steam](https://store.steampowered.com/app/2091640/Hi_Eggplant/) |\n| ![](./README/1stmountain.jpg) | 独立游戏《第一座山》 | [Steam](https://store.steampowered.com/app/2149980/The_First_Mountain/) |\n| ![](./README/tuimiepaopaomu.webp) | 独立游戏《推灭泡泡姆》 | [TapTap](https://www.taptap.com/app/233228) |\n| ![](./README/utgm.jpg) | 独立游戏《鬼山之下》 | [Steam](https://store.steampowered.com/app/1517160/_/) |\n| ![](./README/xieyingeng.png) | 手机游戏《谐音梗挑战》 | [TapTap](https://www.taptap.com/app/201075)        |\n| **其他相关教程** |  |  |\n| 《独立游戏体验计划》（猫叔） | 独立游戏制作体验教程，有用到 QFramework.cs | [b 站](https://space.bilibili.com/656352) |\n| 《原创独立游戏制作：平台射击 Roguelike》（凉鞋） | 原创独立游戏制作教程，有用到 QFramework.cs | [b 站](https://space.bilibili.com/60450548/channel/collectiondetail?sid=125221) |\n| 《原创独立游戏制作：类星露谷》（凉鞋） | 原创独立游戏制作教程，有用到 PlayMaker、QFramework.Tookits | [b 站](https://space.bilibili.com/60450548/channel/collectiondetail?sid=919279) |\n| 《QFramework 游戏开发：类幸存者》 | 面向 QFramework 的游戏开发教程，完成一款类吸血鬼幸存者游戏。 | [b 站](https://www.bilibili.com/video/BV1Uu4y1i7WH/) |\n| 《QFramework 教程年会员》 | QFramework 相关的课程案例 | [GamePix](https://www.gamepixedu.com/goods/show/55) |\n\n\n\n## Star 趋势（如果项目有帮到您欢迎点赞）\n\n[![Stargazers over time](https://starchart.cc/liangxiegame/QFramework.svg)](https://starchart.cc/liangxiegame/QFramework)\n\n\n\n### 作者\n\n* [凉鞋 liangxiegame](https://github.com/liangxiegame)\n\n### 贡献者\n\n* [京产肠饭]( https://gitee.com/JingChanChangFan/hk_-unity-tools)\n\n* [猫叔(一只皮皮虾)]( https://space.bilibili.com/656352/)\n\n* [TastSong]( https://github.com/TastSong)\n\n* [misakiMeiii](https://github.com/misakiMeiii)\n\n* [soso](https://github.com/so-sos-so)\n\n* [蓝色孤舟 gdtdftdqtd](https://github.com/gdtdftdqtd)\n\n* [h3166179](https://github.com/h3166179)\n\n* [葫芦 WangEdgar](https://github.com/WangEdgar)\n\n* New一天\n\n* 幽飞冷凝雪～冷\n\n\n### 优秀的 Unity 库、框架\n\n- [ET](https://github.com/egametang/ET)：ET Unity3D Client And C# Server Framework\n- [IFramework（OnClick）](https://github.com/OnClick9927/IFramework) Simple Unity Tools\n- [JEngine](https://github.com/JasonXuDeveloper/JEngine)  使Unity开发的游戏支持热更新的解决方案。\n- [TinaX Framework](https://tinax.corala.space/) “开箱即用”的Unity独立游戏开发工具\n\n### 代码规范完全遵循:\n\n[QCSharpStyleGuide](https://github.com/liangxiegame/QCSharpStyleGuide)\n\n\n### 赞助 Donate:\n\n* 如果觉得不错可以在 [这里 Asset Store](http://u3d.as/SJ9) 给个 5 星哦~ give 5 star\n* 或者给此仓库一个小小的 Star~ star this repository\n* 以上这些都会转化成我们的动力,提供更好的技术服务! \n\n\n\n### 鸣谢\n\n感谢 JetBrains 公司提供的使用许可证！\n\n<p><a href=\"https://www.jetbrains.com/?from=QFramework \">\n<img src=\"https://file.liangxiegame.com/2bf40802-c296-4bdc-bc8a-718000503771.png\" alt=\"JetBrains的Logo\" width=\"20%\" height=\"20%\"></a></p>\n\n本开源项目由 [QFramework 教程年会员](https://www.gamepixedu.com/goods/show/55) 提供资助\n"
        },
        {
          "name": "README",
          "type": "tree",
          "content": null
        },
        {
          "name": "README_EN.md",
          "type": "blob",
          "size": 8.7822265625,
          "content": "![LOGO](https://file.liangxiegame.com/67ca2c27-d711-40b2-96f3-d2f6071e3f3c.png)\n\n[![](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/liangxiegame/QFramework/blob/master/LICENSE)\n[![Build Status](https://travis-ci.org/liangxiegame/QFramework.svg?branch=master)](https://travis-ci.org/liangxiegame/QFramework)\n\n\n# QFramework Intro\n\n[中文](README)|[English](README_EN.md)\n\n[QFramework](https://github.com/liangxiegame/QFramework)  is a framework. she support solid pricinple、domain design driven、event-driven、data-driven、layered、mvc、cqrs、modulization、extendable、scalable architecture. Simple but powerful! she only has 800 lines of code.can save to a note-taking app. \n\n## Architecture diagram\n\n![](http://processon.com/chart_image/5c270aa6e4b007ba5d5029dc.png)\n\n## For Example（😂）\n\n![](https://file.liangxiegame.com/5fcdf6d1-0605-4ae6-b4bf-12e661eb2f1e.png)\n\n## Schematic diagram of various situations\n\n![](http://processon.com/chart_image/5cbb1edce4b0bab90960a4f6.png)\n\n## Architecture Rule\n\n**QFramework System Design Architecture has 4 layers：**\n\n* Presentation Layer：ViewController Layer. Using IController interface，recive input from user and state changed event from model. In unity MonoBehaviour is on presentation layer\n    * Can get System\n    * Can get Model\n    * Can send Command\n    * Can listen Event\n* System Layer：Using ISystem interface. share IController's part of responsibility. Sharing logic shared across multiple presentation layers，suchas time system、shop system、archivement system.\n    * Can get System\n    * Can get Model\n    * Can listen Event\n    * Can send Event\n* Model Layer：Using IModel interface.Responsible for data definition, data addition, deletion, query and modification methods.\n    * Can get Utility\n    * Can send Event\n* Utility Layer：Using IUtility interface.Responsible for providing infrastructure, such as storage method, serialization method, network connection method, Bluetooth method, SDK, framework inheritance, etc. Nothing can be done. You can integrate third-party libraries or encapsulate APIs\n* In addition to the four layers, there is a core concept - command\n    * Can get System\n    * Can get Model\n    * Can send Event\n    * Can send Command\n* Layer Rule：\n    * IController change ISystem、IModel's state by Command\n    * Notify icontroller after the change of ISystem and IModel must use event or bindableproperty\n    * IController can get ISystem、IModel for data query\n    * ICommand cannot have state\n    * The upper layer can directly obtain the lower layer, and the lower layer cannot obtain the upper object\n    * Events for lower layer to upper layer communication\n    * The communication between the upper layer and the lower layer is called by method (only for query and command for state change). The interaction logic of IController is special, and command can only be used\n\n（照抄自：[学生课堂笔记1](https://github.com/Haogehaojiu/FrameworkDesign)）\n\n### Environment\n\n* Unity 2018.4.x ~ 2021.x\n\n## Install\n\n* QFramework.cs\n    * copy [this code](QFramework.cs) to your project\n\n* QFramework.cs With Examples\n    * [downlowd unitypackage](./QFramework.cs.Examples.unitypackage)\n* QFramework.ToolKits\n    * [downlowd unitypackage](./QFramework.Toolkits.unitypackage)\n* QFramework.ToolkitsPro\n    * install by [Asset Store](http://u3d.as/SJ9) \n\n\n\n\n## Resources\n\n| **Version**                                 |                                                              |                                                              |\n| ------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| QFramework.cs                               | Implementation of qframework ontology architecture           | [code file](./QFramework.cs)                                 |\n| QFramework.cs With Examples                 | QFramework.cs and  Examples：CounterApp、Point Point Point、CubeMaster、FlappyBird、ShootingEditor2D、SnakeGame  etc (QFramework.cs included) | [downlowd unitypackage](./QFramework.cs.Examples.unitypackage) |\n| QFramework.ToolKits                         | QFramework.cs  with UIKit/ActionKit/ResKit/PackageKit/AudioKit (QFramework.cs and examples included) | [downlowd unity package](./QFramework.Toolkits.unitypackage) |\n| QFramework.Toolkits.Demo.WuZiQi             | Gobang Demo by QFramework.Toolkits（Need Install QFramework.Toolkits） | [download unitypackage](./QFramework.Toolkits.Demo.WuZiQi.unitypackage) |\n| QFramework.Toolkits.Demo.Saolei             | Mine clearance Demo by QFramework.Toolkits（Need Install QFramework.Toolkits） | [download unitypackage](./QFramework.Toolkits.Demo.SaoLei.unitypackage) |\n| QFramework.ToolKitsPro                      | More Powerful Tools version based on QFramework.ToolKits (QFramework.Toolkits included) | [AssetStore](http://u3d.as/SJ9)                              |\n| **Community**                               |                                                              |                                                              |\n| github issue                                | github community                                             | [address](https://github.com/liangxiegame/QFramework/issues/new) |\n| gitee issue                                 | gitee community                                              | [address](https://gitee.com/liangxiegame/QFramework/issues)  |\n| **ShowCase**                                | email me or publish on github's issue. My email: liangxiegame@163.com |                                                              |\n| 《Box Bakery》                              |                                                              | [Steam](https://store.steampowered.com/app/2942950/Box_Bakery/) |\n| 《X-teroids》                               |                                                              | [Steam](https://store.steampowered.com/app/3342540/Xteroids/) |\n| 《The last day of Han dynasty》             |                                                              | [Steam](https://store.steampowered.com/app/2078910/_/)       |\n| 《Hi Eggplant：The Birth Of Sprites》       |                                                              | [Steam](https://store.steampowered.com/app/2375290/_/)       |\n| 《When The Train Buzzes For Three Seconds》 |                                                              | [Steam](https://store.steampowered.com/app/1563700/_/)\\|[TapTap](https://www.taptap.cn/app/208258) |\n| 《Hi Eggplant》                             |                                                              | [Steam](https://store.steampowered.com/app/2091640/Hi_Eggplant/) |\n| 《The First Mountain》                      |                                                              | [Steam](https://store.steampowered.com/app/2149980/The_First_Mountain/) |\n| 《Hi Eggplant》                             |                                                              | [Steam](https://store.steampowered.com/app/2091640/Hi_Eggplant/) |\n| 《Under The Ghost Mountain》                |                                                              | [Steam](https://store.steampowered.com/app/1517160/_/)       |\n\n\n\n## Star Trends\n\n[![Stargazers over time](https://starchart.cc/liangxiegame/QFramework.svg)](https://starchart.cc/liangxiegame/QFramework)\n\n\n### Author\n\n* [凉鞋 liangxiegame](https://github.com/liangxiegame)\n\n### Contributors\n\n* [京产肠饭]( https://gitee.com/JingChanChangFan/hk_-unity-tools)\n\n* [猫叔(一只皮皮虾)]( https://space.bilibili.com/656352/)\n\n* [TastSong]( https://github.com/TastSong)\n\n* [misakiMeiii](https://github.com/misakiMeiii)\n\n* [soso](https://github.com/so-sos-so)\n\n* [蓝色孤舟 gdtdftdqtd](https://github.com/gdtdftdqtd)\n\n* [h3166179](https://github.com/h3166179)\n\n* [葫芦 WangEdgar](https://github.com/WangEdgar)\n\n* New一天\n\n* 幽飞冷凝雪～冷\n\n\n### Other Awesome Framework\n\n- [ET](https://github.com/egametang/ET)：ET Unity3D Client And C# Server Framework\n- [JEngine](https://github.com/JasonXuDeveloper/JEngine)  The solution that allows unity games update in runtime.\n- [TinaX Framework](https://tinax.corala.space/) “开箱即用”的Unity独立游戏开发工具\n\n### Code Style:\n\n[QCSharpStyleGuide](https://github.com/liangxiegame/QCSharpStyleGuide)\n\n\n### Donate:\n\n* 如果觉得不错可以在 [Asset Store](http://u3d.as/SJ9) 给个 5 星哦~ give 5 star\n* 或者给此仓库一个小小的  Star~ star this repository\n* 以上这些都会转化成我们的动力,提供更好的技术服务! \n\n### Credits:\n\nThanks for Licenses Supporting by JetBrains Company\n\n<p><a href=\"https://www.jetbrains.com/?from=QFramework \">\n<img src=\"https://file.liangxiegame.com/2bf40802-c296-4bdc-bc8a-718000503771.png\" alt=\"JetBrains的Logo\" width=\"20%\" height=\"20%\"></a></p>"
        }
      ]
    }
  ]
}