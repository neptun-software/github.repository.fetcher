{
  "metadata": {
    "timestamp": 1736710895903,
    "page": 480,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "2Retr0/GodotOceanWaves",
      "stars": 2178,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.078125,
          "content": "# Normalize EOL for all files that Git considers text files.\n* text=auto eol=lf\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.24609375,
          "content": "# Godot 4+ specific ignores\n.godot/\n\n# Godot-specific ignores\n.import/\nexport.cfg\nexport_presets.cfg\n*.tmp\n\n# Imported translations (automatically generated from CSV files)\n*.translation\n\n# Mono-specific ignores\n.mono/\ndata_*/\nmono_crash.*.json\n\nbuild/"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0439453125,
          "content": "MIT License\n\nCopyright (c) 2024 Ethan Truong\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.32421875,
          "content": "# GodotOceanWaves\nAn open ocean rendering experiment in the Godot Engine utilizing the inverse Fourier transform of directional ocean-wave spectra for wave generation. A concise set of parameters is exposed, allowing for scriptable, real-time modification of wave properties to emulate a wide-variety of ocean-wave environments.\n\n[ocean_demo.mp4](https://github.com/user-attachments/assets/a8083878-a297-4536-a481-9123cea7e7df)\n\n## Introduction\n### Why Fourier Transforms?\nA common approach for animating water in video games is by displacing vertices using *Gerstner waves*. While Gerstner waves work well for modeling the lower-frequency details in calmer waters, they fall short in accurately representing the choppy surfaces in an open ocean. To simulate the latter, a more complex approach simulates waves using the *inverse Fourier transform* of ocean-wave spectra modeled from empirical data gathered by oceanographers.\n\nA benefit of working in frequency space using ocean-wave spectra is the ease of modifying ocean properties (e.g., surface choppiness). When using Gerstner waves, it is unclear how waves (and their parameters) need to be changed to emulate a certain ocean state. In contrast, ocean-wave spectra expose parameters that change waves' properties directly.\n\nTo compute the Fourier transform, a *fast Fourier transform* algorithm (FFT) is used specifically. On top of having a lower computational complexity than the classical discrete Fourier transform algorithm ($O(N \\log N)$ versus $`O(N^2)`$), the FFT is *scalable as a parallel system*. This means that it is perfect for running on the GPU. Using Gerstner waves requires each thread to perform $N$ computations, one for each wave. In contrast, FFT-based waves only require each thread to perform $\\log(N)$ equivalent computations. At scale, more waves can be added to the system (at the same performance cost), permitting more accurate surface simulation.\n\n## Results\n### Wave Shading\n#### Lighting Model\nThe ocean lighting model largely follows the BSDF described in the 'Atlas' GDC talk. One deviation, however, is the use of the GGX distribution (rather than Beckmann distribution) for the microfacet distribution. This was due to the GGX distribution's 'flatter' and softer highlights providing a more uniform appearance in many of the ocean-wave environments tested.\n\nThe normal/foam map is sampled with a mix between bicubic and bilinear filtering depending on the world-space pixel density (a value dependent on the normal map texture resolution and texture UV tiling size). This effectively reduces texture aliasing artifacts at lower surface resolutions while maintaining the detail at higher surface resolutions.\n\n#### Sea Foam\nTessendorf notes a method for determining when to generate sea foam by checking where the waves' peaks curl into themselves (i.e., when the Jacobian of the displacement is negative). Foam accumulates linearly and dissipates exponentially on a texture over multiple wave updates, and are controlled by \"foam grow rate\" and \"foam decay rate\" parameters respectively.\n\n#### Sea Spray\nSea spray is modeled using particles via Godot's GPUParticles3D node and makes heavy use of a custom particle shader. Particles are distributed evenly across the plane within the GPUParticles3D node's bounding box. Then, they are culled based on the foam amount present at their position. Un-culled particles begin their lifecycle at a random offset.\n\nEach sea spray particle uses a billboarded sprite with a single static texture. Over the course of their lifecycle, particles' scales and displacements are modified to emulate a splash's appearance. A dissolve effect in particles' mesh shader fades the sprite in a way that simulates how sea spray atomizes once in the air.\n\nOne *major* drawback of this method is that a large increase in particle amount only results in a small increase in sea spray density. This is due to the equal distribution of particles along the bounding box, which results in a majority of the added particles being culled.\n\n![shading_demo](https://github.com/user-attachments/assets/c69766e7-711c-4909-a1fa-290bac0d577a)\n\n### Wave Simulation\nThe method for generating surface waves closely follows Tessendorf. A directional ocean-wave spectrum function is multiplied with Gaussian-distributed random numbers to generate an initial spectral sea state. The initial state is then propagated in time through a \"dispersion relation\" (relating the frequency of waves and their propagation speed). An inverse Fourier transform can then be applied to the propagated state to generate displacement and normal maps.\n\nThe methodology Tessendorf describes was implemented through a compute shader pipeline using Godot's RenderingDevice abstraction. The following sections detail more on major aspects of the wave generation system.\n\n#### Ocean-Wave Spectra\nThe directional ocean-wave spectrum function, $S(\\omega, \\theta)$, returns the energy of a wave given its frequency ($\\omega$) and direction ($\\theta$). It is comprised of a **non-directional spectrum function**, $S(\\omega)$, and a **directional spread function**, $D(\\omega, \\theta)$; the choice of either is entirely independent.\n\n * For the **non-directional spectrum function**, the *Texel-Marsen-Arsloe* (TMA) spectrum described in Horvath was chosen. Given the wind speed ($U$), depth ($D$), and fetch length (i.e., distance from shoreline) ($F$), the TMA spectrum combines its preceding *JONSWAP* spectrum with a depth attenuation function and is defined as $S_{\\text{TMA}}(\\omega) = S_{\\text{JONSWAP}}(\\omega)\\Phi(\\omega)$ where:\n```math\n\\begin{align*}\nS_{\\text{JONSWAP}}(\\omega) &= \\Big[0.076\\Big(\\tfrac{U^2}{F \\cdot 9.81}\\Big)^{0.22}\\Big]\\Big[\\tfrac{9.81^2}{\\omega^5}\\exp\\Big({-\\tfrac 5 4}\\big(\\tfrac{\\omega_p}{\\omega}\\big)^4\\Big)\\Big] \\Big[3.3^{\\exp\\Big(-\\tfrac{(\\omega - \\omega_p)^2}{2(0.07 + 0.02\\cdot\\mathrm{step}(\\omega - \\omega_p))^2\\omega_p^2}\\Big)}\\Big]\\\\\n\\Phi(\\omega) &\\approx \\tfrac 1 2 \\omega_h^2 + ({-\\omega}_h^2+2\\omega_h-1)\\cdot\\mathrm{step}(\\omega_h - 1)\\\\\n\\omega_p &= 22\\Big(\\tfrac{9.81^2}{U F}\\Big)\\\\\n\\omega_h &= \\omega \\sqrt{\\tfrac D {9.81}}\n\\end{align*}\n```\n * For the **directional spread function**, a combination of the *flat* and *Hasselmann* directional spreadings described in Horvath—mixed by a 'spread' parameter ($\\mu$)—was chosen. Horvath also proposes the addition of a 'swell' parameter ($\\xi$) to model ocean-wave elongation—this was also incorporated into the spread model. The mixed spread function is defined as ${D_{\\text{mixed}}(\\omega, \\theta) = \\mathrm{lerp}((2\\pi){^{-1}},\\ Q(s+s_\\xi)\\text{|}\\cos(\\theta \\text{/}2)\\text{|}^{2(s+s_\\xi)},\\ \\mu)}$ where:\n```math\n\\begin{align*}\n<!-- https://www.wolframalpha.com/input?i2d=true&i=taylor+series+Divide%5BPower%5B2%2C%5C%2840%292x-1%5C%2841%29%5D%2C%CF%80%5D*Divide%5BPower%5B%5C%2840%29x%21%5C%2841%29%2C2%5D%2C%5C%2840%292x%5C%2841%29%21%5D+at+x+%3D+0 -->\nQ(\\sigma) &\\approx \\begin{cases}\n 0.09\\sigma^3 + \\big(\\tfrac{\\ln^2 2}{\\pi} - \\tfrac{\\pi}{12}\\big)\\sigma^2+\\big(\\tfrac{\\ln 2}{\\pi}\\big)\\sigma+\\tfrac{1}{2\\pi} & \\text{if } \\sigma \\leq 0.4\\\\\n \\frac{\\sqrt \\sigma}{2\\sqrt \\pi} + \\frac{1}{16\\sqrt{\\pi \\sigma}} & \\text{otherwise.}\n\\end{cases}\\\\\ns &= \\begin{cases}\n 6.97\\big(\\tfrac \\omega {\\omega_p}\\big){^{4.06}} & \\text{if } \\omega \\leq \\omega_p\\\\\n 9.77\\big(\\tfrac \\omega {\\omega_p}\\big){^{-2.33 -1.45(\\omega_p U\\text{/}9.81-1.17)}} & \\text{otherwise.}\n\\end{cases}\\\\\ns_\\xi &= 16 \\tanh\\big(\\tfrac{\\omega_p}{\\omega}\\big)\\xi^2\n\\end{align*}\n```\n$Q(\\sigma)$ is a normalization factor used to satisfy the condition: $\\int_{-\\pi}^\\pi D(\\omega, \\theta)d \\theta = 1$. The Hasselmann directional spread was chosen due to its approximate analytical solution for $Q(\\sigma)$ (as opposed to e.g., the Donelan-Banner directional spread also described in Horvath).\n\nFollowing a suggestion in Tessendorf, the resultant spectrum function was also multiplied by a small-wave suppression term, $`\\exp({-k}^2(1-\\delta)^2)`$ (given the magnitude of the wave vector ($k$) and a 'detail' parameter ($\\delta$)). Combining the above, our *final* directional ocean-wave spectrum function used can be denoted as:\n```math\nS(\\omega, \\theta) = S_{\\text{TMA}}(\\omega)D_{\\text{mixed}}(\\omega, \\theta)\\exp({-k}^2(1-\\delta)^2)\n```\n\n#### Fast Fourier Transform\nA custom FFT implementation was written for the GPU using compute shaders. The *Stockham* FFT algorithm was used over the Cooley-Tukey algorithm to avoid the initial bit-reversal permutation. Following Flügge, a 'butterfly' texture is computed, once per spectrum texture resolution change, encoding the dataflow of the FFT.\n\nFirst, the FFT kernel is applied row-wise to perform the 2D FFT on the spectrum texture. The texture is then transposed using a compute shader, allowing the same row-wise FFT kernel to then be reused for—what is effectively—a column-wise FFT. This transposition also improves memory access patterns along with enabling pipeline reuse.\n\n#### Wave Cascades\nAt large-enough distances—especially with sea foam present—tiling artifacts become very apparent. The wave generation system allows multiple wave cascades to be layered simultaneously to address this. Each cascade has its own tiling size and set of parameters. Cascades can be added/removed from the generation system dynamically in real-time. However, as all cascades use the same compute pipelines, they must have the same spectra texture resolution. Alternatively, blending wave displacements/normals with noise could also reduce tiling artifacts—at a lesser performance cost.\n\nEach wave cascades’ parameters and size must be carefully chosen to avoid wave interference when layered. Similarly, the cascades' wave phases should be offset to avoid interference with other cascades. The generation system automatically attempts this by offsetting each cascades’ start times differently (honestly, not sure if it works lol).\n\n#### Load Balancing\nDue to the erratic nature of wave motion, their movement can appear perceptually smooth even without updating their displacements every frame. Thus, an \"update rate\" parameter was introduced to control how often wave cascades are updated per second. While this reduces the amount of GPU-time spent working on FFT, frames during which the wave generation pipeline runs still stutter.\n\nAn experiment to asynchronously compute cascade updates using Godot's local RenderingDevices, caused significant performance overhead due to transferring textures between the CPU and GPU. Instead, the wave generation system *attempts to load-balance cascades*. Whenever the frame time is shorter than the update rate, only one cascade is updated per frame. This reduces stuttering while still benefiting from the lower GPU workload of frame skipping.\n\nThe displacement, normal, and foam maps generated after running FFT on our directional ocean-wave spectrum function (along with its associated parameters) yield realistic surface motion across a broad range of ocean-wave environments.\n\n[environment_demo.mp4](https://github.com/user-attachments/assets/7589758f-1233-4be8-accc-2902a1dd01ec)\n\n## References\n**Flügge, Fynn-Jorin**. **[Realtime GPGPU FFT Ocean Water Simulation](https://tore.tuhh.de/entities/publication/1cd390d3-732b-41c1-aa2b-07b71a64edd2)**. Hamburg University of Technology. (2017).\\\n**Gunnell, Garrett**. **[I Tried Simulating The Entire Ocean](https://www.youtube.com/watch?v=yPfagLeUa7k)**. (2023).\\\n**Horvath, Christopher J**. **[Empirical Directional Wave Spectra for Computer Graphics](https://dl.acm.org/doi/10.1145/2791261.2791267)**. DigiPro. (2015).\\\n**Tessendorf, Jerry**. **[Simulating Ocean Water](https://people.computing.clemson.edu/~jtessen/reports/papers_files/coursenotes2004.pdf)**. SIGGRAPH. (2004).\\\n**Matusiak, Robert**. **[Implementing Fast Fourier Transform Algorithms of Real-Valued Sequences](https://www.ti.com/lit/an/spra291/spra291.pdf)**. Texas Instruments. (2001).\\\n**Mihelich, Mark**. **[Wakes, Explosions and Lighting: Interactive Water Simulation in 'Atlas'](https://www.youtube.com/watch?v=Dqld965-Vv0)**. GDC. (2019).\\\n**Pensionerov, Ivan**. **[FFT-Ocean](https://github.com/gasgiant/FFT-Ocean)**. GitHub. (2020).\n\n## Attribution\n**[Evening Road 01 (Pure Sky)](https://polyhaven.com/a/evening_road_01_puresky)** by **Jarod Guest** is used under the [CC0 1.0](https://creativecommons.org/publicdomain/zero/1.0/) license.\\\n**[OTFFT DIT Stockham Algorithm](http://wwwa.pikara.ne.jp/okojisan/otfft-en/stockham3.html)** by **Takuya Okahisa** is used and modified under the [MIT](http://wwwa.pikara.ne.jp/okojisan/otfft-en/download.html) license.\n"
        },
        {
          "name": "addons",
          "type": "tree",
          "content": null
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "icon.svg",
          "type": "blob",
          "size": 0.927734375,
          "content": "<svg height=\"128\" width=\"128\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"2\" y=\"2\" width=\"124\" height=\"124\" rx=\"14\" fill=\"#363d52\" stroke=\"#212532\" stroke-width=\"4\"/><g transform=\"scale(.101) translate(122 122)\"><g fill=\"#fff\"><path d=\"M105 673v33q407 354 814 0v-33z\"/><path fill=\"#478cbf\" d=\"m105 673 152 14q12 1 15 14l4 67 132 10 8-61q2-11 15-15h162q13 4 15 15l8 61 132-10 4-67q3-13 15-14l152-14V427q30-39 56-81-35-59-83-108-43 20-82 47-40-37-88-64 7-51 8-102-59-28-123-42-26 43-46 89-49-7-98 0-20-46-46-89-64 14-123 42 1 51 8 102-48 27-88 64-39-27-82-47-48 49-83 108 26 42 56 81zm0 33v39c0 276 813 276 813 0v-39l-134 12-5 69q-2 10-14 13l-162 11q-12 0-16-11l-10-65H447l-10 65q-4 11-16 11l-162-11q-12-3-14-13l-5-69z\"/><path d=\"M483 600c3 34 55 34 58 0v-86c-3-34-55-34-58 0z\"/><circle cx=\"725\" cy=\"526\" r=\"90\"/><circle cx=\"299\" cy=\"526\" r=\"90\"/></g><g fill=\"#414042\"><circle cx=\"307\" cy=\"532\" r=\"60\"/><circle cx=\"717\" cy=\"532\" r=\"60\"/></g></g></svg>\n"
        },
        {
          "name": "icon.svg.import",
          "type": "blob",
          "size": 0.8232421875,
          "content": "[remap]\n\nimporter=\"texture\"\ntype=\"CompressedTexture2D\"\nuid=\"uid://d4lmcsuyxx6mo\"\npath=\"res://.godot/imported/icon.svg-218a8f2b3041327d8a5756f3a245f83b.ctex\"\nmetadata={\n\"vram_texture\": false\n}\n\n[deps]\n\nsource_file=\"res://icon.svg\"\ndest_files=[\"res://.godot/imported/icon.svg-218a8f2b3041327d8a5756f3a245f83b.ctex\"]\n\n[params]\n\ncompress/mode=0\ncompress/high_quality=false\ncompress/lossy_quality=0.7\ncompress/hdr_compression=1\ncompress/normal_map=0\ncompress/channel_pack=0\nmipmaps/generate=false\nmipmaps/limit=-1\nroughness/mode=0\nroughness/src_normal=\"\"\nprocess/fix_alpha_border=true\nprocess/premult_alpha=false\nprocess/normal_map_invert_y=false\nprocess/hdr_as_srgb=false\nprocess/hdr_clamp_exposure=false\nprocess/size_limit=0\ndetect_3d/compress_to=1\nsvg/scale=1.0\neditor/scale_with_editor_scale=false\neditor/convert_colors_with_editor_theme=false\n"
        },
        {
          "name": "main.gd",
          "type": "blob",
          "size": 8.8515625,
          "content": "@tool\nextends Node3D\n\nvar clipmap_tile_size := 1.0 # Not the smallest tile size, but one that reduces the amount of vertex jitter.\nvar previous_tile := Vector3i.MAX\nvar should_render_imgui := not Engine.is_editor_hint()\n\n@onready var viewport : Variant = Engine.get_singleton(&'EditorInterface').get_editor_viewport_3d(0) if Engine.is_editor_hint() else get_viewport()\n@onready var camera : Variant = viewport.get_camera_3d()\n@onready var water := $Water\n\n# References to various parameters (for imgui)\n@onready var _camera_fov := [camera.fov]\n@onready var _updates_per_second := [water.updates_per_second]\n@onready var _water_color := [water.water_color.r, water.water_color.g, water.water_color.b]\n@onready var _foam_color := [water.foam_color.r, water.foam_color.g, water.foam_color.b]\n@onready var _is_sea_spray_visible := [true]\n\nfunc _init() -> void:\n\tif Engine.is_editor_hint(): return\n\tif DisplayServer.window_get_vsync_mode() == DisplayServer.VSYNC_ENABLED:\n\t\tDisplayServer.window_set_vsync_mode(DisplayServer.VSYNC_DISABLED)\n\tDisplayServer.window_set_size(DisplayServer.screen_get_size() * 0.75)\n\tDisplayServer.window_set_position(DisplayServer.screen_get_size() * 0.25 / 2.0)\n\nfunc _process(delta : float) -> void:\n\tif not Engine.is_editor_hint():\n\t\tif should_render_imgui:\n\t\t\t_render_imgui()\n\t\tcamera.enable_camera_movement = not (ImGui.IsWindowHovered(ImGui.HoveredFlags_AnyWindow) or ImGui.IsAnyItemActive())\n\nfunc _physics_process(delta: float) -> void:\n\t# Shift water mesh whenever player moves into a new tile.\n\tvar tile := (Vector3(camera.global_position.x, 0.0, camera.global_position.z) / clipmap_tile_size).ceil()\n\tif not tile.is_equal_approx(previous_tile):\n\t\twater.global_position = tile * clipmap_tile_size\n\t\tprevious_tile = tile\n\n\t# Vary audio samples based on total wind speed across all cascades.\n\tvar total_wind_speed := 0.0\n\tfor params in water.parameters:\n\t\ttotal_wind_speed += params.wind_speed\n\t$OceanAudioPlayer.volume_db = lerpf(-30.0, 15.0, minf(total_wind_speed/15.0, 1.0))\n\t$WindAudioPlayer.volume_db = lerpf(5.0, -30.0, minf(total_wind_speed/15.0, 1.0))\n\nfunc _input(event: InputEvent) -> void:\n\tif event.is_action_pressed(&'toggle_imgui'):\n\t\tshould_render_imgui = not should_render_imgui\n\telif event.is_action_pressed(&'toggle_fullscreen'):\n\t\tDisplayServer.window_set_mode(DisplayServer.WINDOW_MODE_FULLSCREEN if DisplayServer.window_get_mode() == DisplayServer.WINDOW_MODE_WINDOWED else DisplayServer.WINDOW_MODE_WINDOWED)\n\telif event.is_action_pressed(&'ui_cancel'):\n\t\tDisplayServer.window_set_mode(DisplayServer.WINDOW_MODE_WINDOWED)\n\nfunc imgui_text_tooltip(title : String, tooltip : String) -> void:\n\tImGui.Text(title); if ImGui.IsItemHovered() and not tooltip.is_empty(): ImGui.SetTooltip(tooltip)\n\nfunc _render_imgui() -> void:\n\tvar fps := Engine.get_frames_per_second()\n\tvar mesh_quality_keys : Array = water.MeshQuality.keys()\n\n\tImGui.Begin(' ', [], ImGui.WindowFlags_AlwaysAutoResize | ImGui.WindowFlags_NoMove)\n\tImGui.SetWindowPos(Vector2(20, 20))\n\tImGui.SeparatorText('OceanWaves')\n\tImGui.Text('FPS:                %d (%s)' % [fps, '%.2fms' % (1.0 / fps*1e3)])\n\tImGui.Text('Enable Sea Spray:  '); ImGui.SameLine(); if ImGui.Checkbox('##sea_spray_checkbox', _is_sea_spray_visible): $Water/WaterSprayEmitter.visible = _is_sea_spray_visible[0]\n\timgui_text_tooltip('Wave Resolution:   ', 'The resolution of the displacement/normal maps used for each wave cascade.\\nThis is also the FFT input size.'); ImGui.SameLine()\n\tif ImGui.BeginCombo('##resolution', '%dx%d' % [water.map_size, water.map_size]):\n\t\tfor resolution in [128, 256, 512, 1024]:\n\t\t\tif ImGui.Selectable('%dx%d' % [resolution, resolution]):\n\t\t\t\twater.map_size = resolution\n\t\tImGui.EndCombo()\n\tImGui.Text('Wave Mesh Quality: '); ImGui.SameLine();\n\tif ImGui.BeginCombo('##mesh_quality', '%s' % mesh_quality_keys[water.mesh_quality].capitalize()):\n\t\tfor mesh_quality in len(water.MeshQuality):\n\t\t\tif ImGui.Selectable('%s' % mesh_quality_keys[mesh_quality].capitalize()):\n\t\t\t\twater.mesh_quality = mesh_quality\n\t\t\t\tclipmap_tile_size = 1.0 if mesh_quality == water.MeshQuality.HIGH else 4.0\n\t\tImGui.EndCombo()\n\timgui_text_tooltip('Updates per Second:', 'Denotes how many times wave spectrums will be updated per second.\\n(0 is uncapped)'); ImGui.SameLine(); if ImGui.SliderFloat('##update_rate', _updates_per_second, 0, 60): water.updates_per_second = _updates_per_second[0]\n\tImGui.Text('Water Color:       '); ImGui.SameLine(); if ImGui.ColorButtonEx('##water_color_button', water.water_color, ImGui.ColorEditFlags_Float, Vector2(ImGui.GetColumnWidth(), ImGui.GetFrameHeight())): ImGui.OpenPopup('water_color_picker')\n\tif ImGui.BeginPopup('water_color_picker'):\n\t\tif ImGui.ColorPicker3('##water_color_picker', _water_color, ImGui.ColorEditFlags_Float | ImGui.ColorEditFlags_NoSidePreview | ImGui.ColorEditFlags_DisplayRGB | ImGui.ColorEditFlags_DisplayHex):\n\t\t\twater.water_color = Color(_water_color[0], _water_color[1], _water_color[2])\n\t\tImGui.EndPopup()\n\tImGui.Text('Foam Color:        '); ImGui.SameLine(); if ImGui.ColorButtonEx('##foam_color_button', water.foam_color, ImGui.ColorEditFlags_Float, Vector2(ImGui.GetColumnWidth(), ImGui.GetFrameHeight())): ImGui.OpenPopup('foam_color_picker')\n\tif ImGui.BeginPopup('foam_color_picker'):\n\t\tif ImGui.ColorPicker3('##foam_color_picker', _foam_color, ImGui.ColorEditFlags_Float | ImGui.ColorEditFlags_NoSidePreview | ImGui.ColorEditFlags_DisplayRGB | ImGui.ColorEditFlags_DisplayHex):\n\t\t\twater.foam_color = Color(_foam_color[0], _foam_color[1], _foam_color[2])\n\t\tImGui.EndPopup()\n\n\tImGui.SeparatorText('Wave Parameters')\n\tif ImGui.BeginTabBar('##cascades'):\n\t\tfor i in len(water.parameters):\n\t\t\tvar params : WaveCascadeParameters = water.parameters[i]\n\t\t\tif ImGui.BeginTabItem('Cascade %d' % (i + 1)):\n\t\t\t\timgui_text_tooltip('Tile Length:       ', 'Denotes the distance the cascade\\'s tile should cover (in meters).'); ImGui.SameLine(); if ImGui.InputFloat2('##tile_length', params._tile_length): params.tile_length = Vector2(params._tile_length[0], params._tile_length[1])\n\t\t\t\timgui_text_tooltip('Displacement Scale:', ''); ImGui.SameLine(); if ImGui.SliderFloat('##displacement_scale', params._displacement_scale, 0, 2): params.displacement_scale = params._displacement_scale[0]\n\t\t\t\timgui_text_tooltip('Normal Scale:      ', ''); ImGui.SameLine(); if ImGui.SliderFloat('##normal_scale', params._normal_scale, 0, 2): params.normal_scale = params._normal_scale[0]\n\t\t\t\tImGui.Dummy(Vector2(0,0)); ImGui.Separator(); ImGui.Dummy(Vector2(0,0))\n\t\t\t\timgui_text_tooltip('Wind Speed:        ', 'Denotes the average wind speed above the water (in meters per second).\\nIncreasing makes waves steeper and more \\'chaotic\\'.'); ImGui.SameLine(); if ImGui.DragFloat('##wind_speed', params._wind_speed): params.wind_speed = params._wind_speed[0]\n\t\t\t\timgui_text_tooltip('Wind Direction:    ', ''); ImGui.SameLine(); if ImGui.SliderAngle('##wind_direction', params._wind_direction): params.wind_direction = rad_to_deg(params._wind_direction[0])\n\t\t\t\timgui_text_tooltip('Fetch Length:      ', 'Denotes the distance from shoreline (in kilometers).\\nIncreasing makes waves steeper, but reduces their \\'choppiness\\'.'); ImGui.SameLine(); if ImGui.DragFloat('##fetch_length', params._fetch_length): params.fetch_length = params._fetch_length[0]\n\t\t\t\timgui_text_tooltip('Swell:             ', 'Modifies waves to clump in a more elongated, parallel manner.'); ImGui.SameLine(); if ImGui.SliderFloat('##swell', params._swell, 0, 2): params.swell = params._swell[0]\n\t\t\t\timgui_text_tooltip('Spread:            ', 'Modifies how much wind and swell affect the direction of the waves.'); ImGui.SameLine(); if ImGui.SliderFloat('##spread', params._spread, 0, 1): params.spread = params._spread[0]\n\t\t\t\timgui_text_tooltip('Detail:            ', 'Modifies the attenuation of high frequency waves.'); ImGui.SameLine(); if ImGui.SliderFloat('##detail', params._detail, 0, 1): params.detail = params._detail[0]\n\t\t\t\tImGui.Dummy(Vector2(0,0)); ImGui.Separator(); ImGui.Dummy(Vector2(0,0))\n\t\t\t\timgui_text_tooltip('Whitecap:          ', 'Modifies how steep a wave needs to be before foam can accumulate.'); ImGui.SameLine(); if ImGui.SliderFloat('##white_cap', params._whitecap, 0, 2): params.whitecap = params._whitecap[0]\n\t\t\t\timgui_text_tooltip('Foam Amount:       ', ''); ImGui.SameLine(); if ImGui.SliderFloat('##foam_amount', params._foam_amount, 0, 10): params.foam_amount = params._foam_amount[0]\n\t\t\t\tImGui.EndTabItem()\n\t\tImGui.EndTabBar()\n\n\tImGui.SeparatorText('Camera')\n\tImGui.Text('Camera Position:    %+.2v' % camera.global_position)\n\tImGui.Text('Camera FOV:        '); ImGui.SameLine(); if ImGui.SliderFloat('##fov_float', _camera_fov, 20, 170): camera.fov = _camera_fov[0]\n\n\tImGui.Dummy(Vector2(0,0)); ImGui.Separator(); ImGui.Dummy(Vector2(0,0))\n\tImGui.PushStyleColor(ImGui.Col_Text, Color.WEB_GRAY);\n\tImGui.Text('Press %s-H to toggle GUI visibility!' % ['Cmd' if OS.get_name() == 'macOS' else 'Ctrl']);\n\tImGui.Text('Press %s-F to toggle fullscreen!' % ['Cmd' if OS.get_name() == 'macOS' else 'Ctrl']);\n\tImGui.PopStyleColor()\n\tImGui.End()\n"
        },
        {
          "name": "main.tscn",
          "type": "blob",
          "size": 5.19140625,
          "content": "[gd_scene load_steps=24 format=3 uid=\"uid://dx4r13gqfh13\"]\n\n[ext_resource type=\"Script\" path=\"res://main.gd\" id=\"1_skarq\"]\n[ext_resource type=\"Script\" path=\"res://assets/water/wave_cascade_parameters.gd\" id=\"2_pw5n6\"]\n[ext_resource type=\"Texture2D\" uid=\"uid://cnft723bala47\" path=\"res://assets/skybox.png\" id=\"3_0ksgj\"]\n[ext_resource type=\"Script\" path=\"res://assets/player/camera.gd\" id=\"4_v2yip\"]\n[ext_resource type=\"Material\" uid=\"uid://byumtcccq4ew3\" path=\"res://assets/water/mat_water.tres\" id=\"5_lt75t\"]\n[ext_resource type=\"ArrayMesh\" uid=\"uid://ix4vp1y05f1s\" path=\"res://assets/water/clipmap_high.obj\" id=\"5_n61pp\"]\n[ext_resource type=\"AudioStream\" uid=\"uid://cvvn0vke5comw\" path=\"res://assets/ocean_loop.wav\" id=\"6_jpklm\"]\n[ext_resource type=\"Script\" path=\"res://assets/water/water.gd\" id=\"7_s0x5e\"]\n[ext_resource type=\"AudioStream\" uid=\"uid://ck6vmandgjhy0\" path=\"res://assets/wind_loop.wav\" id=\"8_6r5si\"]\n[ext_resource type=\"Shader\" path=\"res://assets/shaders/spatial/sea_spray.gdshader\" id=\"8_eu8jb\"]\n[ext_resource type=\"Material\" uid=\"uid://5xqyddws6rt5\" path=\"res://assets/water/mat_spray.tres\" id=\"9_skbf4\"]\n[ext_resource type=\"Texture2D\" uid=\"uid://dtm5tyuh2slqt\" path=\"res://assets/water/sea_spray.png\" id=\"10_spqpo\"]\n\n[sub_resource type=\"PanoramaSkyMaterial\" id=\"PanoramaSkyMaterial_t7jwl\"]\npanorama = ExtResource(\"3_0ksgj\")\n\n[sub_resource type=\"Sky\" id=\"Sky_vroi3\"]\nsky_material = SubResource(\"PanoramaSkyMaterial_t7jwl\")\n\n[sub_resource type=\"Environment\" id=\"Environment_icybu\"]\nbackground_mode = 2\nsky = SubResource(\"Sky_vroi3\")\ntonemap_mode = 2\nfog_mode = 1\nfog_light_color = Color(0.272954, 0.419272, 0.484632, 1)\nfog_sun_scatter = 0.05\nfog_density = 1.0\nfog_aerial_perspective = 0.626\nfog_sky_affect = 0.0\nfog_depth_curve = 0.25\nfog_depth_begin = 200.0\nfog_depth_end = 350.0\nvolumetric_fog_enabled = true\nvolumetric_fog_density = 0.0\nvolumetric_fog_length = 256.0\nadjustment_enabled = true\nadjustment_brightness = 0.85\nadjustment_contrast = 1.07\nadjustment_saturation = 1.5\n\n[sub_resource type=\"Resource\" id=\"Resource_adqv5\"]\nscript = ExtResource(\"2_pw5n6\")\ntile_length = Vector2(88, 88)\ndisplacement_scale = 1.0\nnormal_scale = 1.0\nwind_speed = 10.0\nwind_direction = 20.0\nfetch_length = 150.0\nswell = 0.8\nspread = 0.2\ndetail = 1.0\nwhitecap = 0.5\nfoam_amount = 8.0\n\n[sub_resource type=\"Resource\" id=\"Resource_luhq0\"]\nscript = ExtResource(\"2_pw5n6\")\ntile_length = Vector2(57, 57)\ndisplacement_scale = 0.75\nnormal_scale = 1.0\nwind_speed = 5.0\nwind_direction = 15.0\nfetch_length = 150.0\nswell = 0.8\nspread = 0.4\ndetail = 1.0\nwhitecap = 0.5\nfoam_amount = 0.0\n\n[sub_resource type=\"Resource\" id=\"Resource_83u3u\"]\nscript = ExtResource(\"2_pw5n6\")\ntile_length = Vector2(16, 16)\ndisplacement_scale = 0.0\nnormal_scale = 0.25\nwind_speed = 20.0\nwind_direction = 20.0\nfetch_length = 550.0\nswell = 0.8\nspread = 0.4\ndetail = 1.0\nwhitecap = 0.25\nfoam_amount = 3.0\n\n[sub_resource type=\"FastNoiseLite\" id=\"FastNoiseLite_k6xhe\"]\n\n[sub_resource type=\"NoiseTexture2D\" id=\"NoiseTexture2D_tsx6q\"]\nseamless = true\nnoise = SubResource(\"FastNoiseLite_k6xhe\")\n\n[sub_resource type=\"ShaderMaterial\" id=\"ShaderMaterial_ds3o1\"]\nrender_priority = 0\nshader = ExtResource(\"8_eu8jb\")\nshader_parameter/max_alpha = 0.666\nshader_parameter/albedo_texture = ExtResource(\"10_spqpo\")\nshader_parameter/dissolve_texture = SubResource(\"NoiseTexture2D_tsx6q\")\n\n[sub_resource type=\"QuadMesh\" id=\"QuadMesh_06d3e\"]\n\n[sub_resource type=\"FogMaterial\" id=\"FogMaterial_riff4\"]\ndensity = 8.0\nalbedo = Color(0.988718, 0.989631, 0.989629, 1)\nheight_falloff = 0.176\nedge_fade = 1.75\n\n[node name=\"Main\" type=\"Node3D\"]\nscript = ExtResource(\"1_skarq\")\n\n[node name=\"Environment\" type=\"WorldEnvironment\" parent=\".\"]\nenvironment = SubResource(\"Environment_icybu\")\n\n[node name=\"Sun\" type=\"DirectionalLight3D\" parent=\".\"]\ntransform = Transform3D(0.945601, -0.0516921, 0.321197, -0.00840572, 0.983084, 0.18296, -0.325221, -0.175707, 0.929171, 0, 10, 0)\nshadow_bias = 0.0\nshadow_normal_bias = 6.464\nshadow_opacity = 0.8\nshadow_blur = 5.0\n\n[node name=\"Camera\" type=\"Camera3D\" parent=\".\"]\ntransform = Transform3D(-0.996195, -0.0151344, 0.0858316, 0, 0.984807, 0.173648, -0.0871557, 0.172987, -0.981061, 0, 10, -25)\nscript = ExtResource(\"4_v2yip\")\n\n[node name=\"Water\" type=\"MeshInstance3D\" parent=\".\"]\ntransform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -1, 0, -25)\nsorting_offset = 999.0\nmaterial_override = ExtResource(\"5_lt75t\")\ncast_shadow = 0\nmesh = ExtResource(\"5_n61pp\")\nskeleton = NodePath(\"\")\nscript = ExtResource(\"7_s0x5e\")\nparameters = Array[ExtResource(\"2_pw5n6\")]([SubResource(\"Resource_adqv5\"), SubResource(\"Resource_luhq0\"), SubResource(\"Resource_83u3u\")])\n\n[node name=\"WaterSprayEmitter\" type=\"GPUParticles3D\" parent=\"Water\"]\ntransform = Transform3D(15, 0, 0, 0, 15, 0, 0, 0, 15, 0, 0, 0)\nmaterial_override = SubResource(\"ShaderMaterial_ds3o1\")\ncast_shadow = 0\namount = 32768\nlifetime = 6.0\nprocess_material = ExtResource(\"9_skbf4\")\ndraw_pass_1 = SubResource(\"QuadMesh_06d3e\")\n\n[node name=\"FogVolume\" type=\"FogVolume\" parent=\".\"]\nshape = 4\nmaterial = SubResource(\"FogMaterial_riff4\")\n\n[node name=\"OceanAudioPlayer\" type=\"AudioStreamPlayer\" parent=\".\"]\nstream = ExtResource(\"6_jpklm\")\nvolume_db = 15.0\nautoplay = true\n\n[node name=\"WindAudioPlayer\" type=\"AudioStreamPlayer\" parent=\".\"]\nstream = ExtResource(\"8_6r5si\")\nvolume_db = -30.0\nautoplay = true\n"
        },
        {
          "name": "project.godot",
          "type": "blob",
          "size": 1.9501953125,
          "content": "; Engine configuration file.\n; It's best edited using the editor UI and not directly,\n; since the parameters that go here are not all obvious.\n;\n; Format:\n;   [section] ; section goes between []\n;   param=value ; assign values to parameters\n\nconfig_version=5\n\n[application]\n\nconfig/name=\"OceanWaves\"\nrun/main_scene=\"res://main.tscn\"\nconfig/features=PackedStringArray(\"4.3\", \"Forward Plus\")\nboot_splash/show_image=false\nconfig/icon=\"res://icon.svg\"\n\n[autoload]\n\nImGuiRoot=\"*res://addons/imgui-godot/data/ImGuiRoot.tscn\"\n\n[debug]\n\ngdscript/warnings/unused_parameter=0\ngdscript/warnings/shadowed_variable=0\ngdscript/warnings/incompatible_ternary=0\ngdscript/warnings/integer_division=0\n\n[display]\n\nwindow/stretch/mode=\"canvas_items\"\nwindow/stretch/aspect=\"ignore\"\nwindow/vsync/vsync_mode=3\nwindow/quality/msaa_2d=0\nwindow/quality/msaa_3d=1\nwindow/show_image=false\n\n[editor_plugins]\n\nenabled=PackedStringArray(\"res://addons/imgui-godot/plugin.cfg\")\n\n[input]\n\ntoggle_imgui={\n\"deadzone\": 0.5,\n\"events\": [Object(InputEventKey,\"resource_local_to_scene\":false,\"resource_name\":\"\",\"device\":-1,\"window_id\":0,\"command_or_control_autoremap\":true,\"alt_pressed\":false,\"shift_pressed\":false,\"pressed\":false,\"keycode\":0,\"physical_keycode\":72,\"key_label\":0,\"unicode\":0,\"location\":0,\"echo\":false,\"script\":null)\n]\n}\ntoggle_fullscreen={\n\"deadzone\": 0.5,\n\"events\": [Object(InputEventKey,\"resource_local_to_scene\":false,\"resource_name\":\"\",\"device\":-1,\"window_id\":0,\"command_or_control_autoremap\":true,\"alt_pressed\":false,\"shift_pressed\":false,\"pressed\":false,\"keycode\":0,\"physical_keycode\":70,\"key_label\":0,\"unicode\":0,\"location\":0,\"echo\":false,\"script\":null)\n]\n}\n\n[rendering]\n\nanti_aliasing/quality/msaa_3d=1\n\n[shader_globals]\n\ndisplacements={\n\"type\": \"sampler2DArray\",\n\"value\": \"\"\n}\nnormals={\n\"type\": \"sampler2DArray\",\n\"value\": \"\"\n}\nwater_color={\n\"type\": \"color\",\n\"value\": Color(0.0100228, 0.0196066, 0.0272118, 1)\n}\nfoam_color={\n\"type\": \"color\",\n\"value\": Color(0, 0, 0, 1)\n}\nnum_cascades={\n\"type\": \"uint\",\n\"value\": 0\n}\n"
        }
      ]
    }
  ]
}