{
  "metadata": {
    "timestamp": 1736711003564,
    "page": 711,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "amantinband/error-or",
      "stars": 1674,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 2.203125,
          "content": "root = true\r\n\r\n[*]\r\nindent_style = space\r\nindent_size = 4\r\nend_of_line = crlf\r\ncharset = utf-8\r\ntrim_trailing_whitespace = true\r\ninsert_final_newline = true\r\n\r\n# SA1615: Element return value should be documented.\r\ndotnet_diagnostic.SA1615.severity = none\r\n\r\n# SA1611: Element parameters must be documented.\r\ndotnet_diagnostic.SA1611.severity = none\r\n\r\n# SA1633: File must have header.\r\ndotnet_diagnostic.SA1633.severity = none\r\n\r\n# SA1633: Generic type parameters must be documented.\r\ndotnet_diagnostic.SA1618.severity = none\r\n\r\n# SA1133: Each attribute should be placed in its own set of square brackets.\r\ndotnet_diagnostic.SA1133.severity = none\r\n\r\n# SA1600: Elements must be documented.\r\ndotnet_diagnostic.SA1600.severity = none\r\n\r\n# SA1601: Partial elementes should be documented.\r\ndotnet_diagnostic.SA1601.severity = none\r\n\r\n# SA1313: Parameter names must begin with lower case letter.\r\ndotnet_diagnostic.SA1313.severity = none\r\n\r\n# SA1009: Closing parenthesis should be followed by a space.\r\ndotnet_diagnostic.SA1009.severity = none\r\n\r\n# SA1000: The keyword 'new' should be followed by a space.\r\ndotnet_diagnostic.SA1000.severity = none\r\n\r\n# SA1101: Prefix local calls with this.\r\ndotnet_diagnostic.SA1101.severity = none\r\n\r\n# SA1309: Field should not begin with an underscore.\r\ndotnet_diagnostic.SA1309.severity = none\r\n\r\n# SA1602: Enumeration items should be documented.\r\ndotnet_diagnostic.SA1602.severity = none\r\n\r\n# CS1591: Missing XML comment for publicly visible type or member.\r\ndotnet_diagnostic.CS1591.severity = none\r\n\r\n# SA1200: Using directive should appear within a namespace declaration.\r\ndotnet_diagnostic.SA1200.severity = none\r\n\r\n# IDE0008: Use explicit type\r\ncsharp_style_var_when_type_is_apparent = true\r\n\r\n# IDE0130: Namespace does not match folder structure\r\ndotnet_style_namespace_match_folder = false\r\n\r\n# IDE0023: Use block body for operators\r\ncsharp_style_expression_bodied_operators = when_on_single_line\r\n\r\n# IDE0130: Namespace does not match folder structure\r\ndotnet_diagnostic.IDE0130.severity = none\r\n\r\n# SA1642: Constructor summary documentation should begin with standard text\r\ndotnet_diagnostic.SA1642.severity = none\r\n\r\n# SA1516: Elements should be separated by blank line\r\ndotnet_diagnostic.SA1516.severity = none\r\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.6484375,
          "content": "**/.ionide\n**/.vscode\n**/.vs\n**/.idea\n**/obj\n**/bin\n**/artifacts\n**/TestResults\n\n.fake\n.ionide\n\n# Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio, WebStorm and Rider\n# Reference: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839\n\n# User-specific stuff\n.idea/**/workspace.xml\n.idea/**/tasks.xml\n.idea/**/usage.statistics.xml\n.idea/**/dictionaries\n.idea/**/shelf\n\n# AWS User-specific\n.idea/**/aws.xml\n\n# Generated files\n.idea/**/contentModel.xml\n\n# Sensitive or high-churn files\n.idea/**/dataSources/\n.idea/**/dataSources.ids\n.idea/**/dataSources.local.xml\n.idea/**/sqlDataSources.xml\n.idea/**/dynamic.xml\n.idea/**/uiDesigner.xml\n.idea/**/dbnavigator.xml\n\n# Gradle\n.idea/**/gradle.xml\n.idea/**/libraries\n\n# Gradle and Maven with auto-import\n# When using Gradle or Maven with auto-import, you should exclude module files,\n# since they will be recreated, and may cause churn.  Uncomment if using\n# auto-import.\n# .idea/artifacts\n# .idea/compiler.xml\n# .idea/jarRepositories.xml\n# .idea/modules.xml\n# .idea/*.iml\n# .idea/modules\n# *.iml\n# *.ipr\n\n# CMake\ncmake-build-*/\n\n# Mongo Explorer plugin\n.idea/**/mongoSettings.xml\n\n# File-based project format\n*.iws\n\n# IntelliJ\nout/\n\n# mpeltonen/sbt-idea plugin\n.idea_modules/\n\n# JIRA plugin\natlassian-ide-plugin.xml\n\n# Cursive Clojure plugin\n.idea/replstate.xml\n\n# SonarLint plugin\n.idea/sonarlint/\n\n# Crashlytics plugin (for Android Studio and IntelliJ)\ncom_crashlytics_export_strings.xml\ncrashlytics.properties\ncrashlytics-build.properties\nfabric.properties\n\n# Editor-based Rest Client\n.idea/httpRequests\n\n# Android studio 3.1+ serialized cache file\n.idea/caches/build_file_checksums.ser\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 1.39453125,
          "content": "# Changelog\r\n\r\nAll notable changes to this project are documented in this file.\r\n\r\n## [1.10.0] - 2024-02-14\r\n\r\n### Added\r\n\r\n- `ErrorType.Forbidden`\r\n- README to NuGet package\r\n\r\n## [1.9.0] - 2024-01-06\r\n\r\n### Added\r\n\r\n- `ToErrorOr`\r\n\r\n## [2.0.0] - 2024-03-26\r\n\r\n### Added\r\n\r\n- `FailIf`\r\n\r\n```csharp\r\npublic ErrorOr<TValue> FailIf(Func<TValue, bool> onValue, Error error)\r\n```\r\n\r\n```csharp\r\nErrorOr<int> errorOr = 1;\r\nerrorOr.FailIf(x => x > 0, Error.Failure());\r\n```\r\n\r\n### Breaking Changes\r\n\r\n- `Then` that receives an action is now called `ThenDo`\r\n\r\n```diff\r\n-public ErrorOr<TValue> Then(Action<TValue> action)\r\n+public ErrorOr<TValue> ThenDo(Action<TValue> action)\r\n```\r\n\r\n```diff\r\n-public static async Task<ErrorOr<TValue>> Then<TValue>(this Task<ErrorOr<TValue>> errorOr, Action<TValue> action)\r\n+public static async Task<ErrorOr<TValue>> ThenDo<TValue>(this Task<ErrorOr<TValue>> errorOr, Action<TValue> action)\r\n```\r\n\r\n- `ThenAsync` that receives an action is now called `ThenDoAsync`\r\n\r\n```diff\r\n-public async Task<ErrorOr<TValue>> ThenAsync(Func<TValue, Task> action)\r\n+public async Task<ErrorOr<TValue>> ThenDoAsync(Func<TValue, Task> action)\r\n```\r\n\r\n```diff\r\n-public static async Task<ErrorOr<TValue>> ThenAsync<TValue>(this Task<ErrorOr<TValue>> errorOr, Func<TValue, Task> action)\r\n+public static async Task<ErrorOr<TValue>> ThenDoAsync<TValue>(this Task<ErrorOr<TValue>> errorOr, Func<TValue, Task> action)\r\n```\r\n"
        },
        {
          "name": "Directory.Build.props",
          "type": "blob",
          "size": 0.654296875,
          "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n\r\n<Project>\r\n\r\n  <PropertyGroup>\r\n    <LangVersion>12.0</LangVersion>\r\n    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>\r\n    <ImplicitUsings>enable</ImplicitUsings>\r\n    <Nullable>enable</Nullable>\r\n    <TreatWarningsAsErrors>True</TreatWarningsAsErrors>\r\n    <GenerateDocumentationFile>true</GenerateDocumentationFile>\r\n  </PropertyGroup>\r\n\r\n  <ItemGroup>\r\n    <PackageReference Include=\"StyleCop.Analyzers\" Version=\"1.2.0-beta.556\">\r\n        <PrivateAssets>all</PrivateAssets>\r\n        <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>\r\n    </PackageReference>\r\n  </ItemGroup>\r\n\r\n</Project>\r\n"
        },
        {
          "name": "ErrorOr.sln",
          "type": "blob",
          "size": 1.4013671875,
          "content": "ï»¿\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio Version 16\nVisualStudioVersion = 16.0.30114.105\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"ErrorOr\", \"src\\ErrorOr.csproj\", \"{19633D81-11FE-4C55-AA8D-452D20EEEF98}\"\nEndProject\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"tests\", \"tests\\Tests.csproj\", \"{0E84EC69-4E4C-4195-907D-06C96D0140A6}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|Any CPU = Debug|Any CPU\n\t\tRelease|Any CPU = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{19633D81-11FE-4C55-AA8D-452D20EEEF98}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{19633D81-11FE-4C55-AA8D-452D20EEEF98}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{19633D81-11FE-4C55-AA8D-452D20EEEF98}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{19633D81-11FE-4C55-AA8D-452D20EEEF98}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{0E84EC69-4E4C-4195-907D-06C96D0140A6}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{0E84EC69-4E4C-4195-907D-06C96D0140A6}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{0E84EC69-4E4C-4195-907D-06C96D0140A6}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{0E84EC69-4E4C-4195-907D-06C96D0140A6}.Release|Any CPU.Build.0 = Release|Any CPU\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.0498046875,
          "content": "MIT License\n\nCopyright (c) 2022 Amichai Mantinband\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 21.4599609375,
          "content": "<div align=\"center\">\r\n\r\n<img src=\"assets/icon.png\" alt=\"drawing\" width=\"700px\"/></br>\r\n\r\n[![NuGet](https://img.shields.io/nuget/v/erroror.svg)](https://www.nuget.org/packages/erroror)\r\n\r\n[![Build](https://github.com/amantinband/error-or/actions/workflows/build.yml/badge.svg)](https://github.com/amantinband/error-or/actions/workflows/build.yml) [![publish ErrorOr to nuget](https://github.com/amantinband/error-or/actions/workflows/publish.yml/badge.svg)](https://github.com/amantinband/error-or/actions/workflows/publish.yml)\r\n\r\n[![GitHub contributors](https://img.shields.io/github/contributors/amantinband/error-or)](https://GitHub.com/amantinband/error-or/graphs/contributors/) [![GitHub Stars](https://img.shields.io/github/stars/amantinband/error-or.svg)](https://github.com/amantinband/error-or/stargazers) [![GitHub license](https://img.shields.io/github/license/amantinband/error-or)](https://github.com/amantinband/error-or/blob/main/LICENSE)\r\n[![codecov](https://codecov.io/gh/amantinband/error-or/branch/main/graph/badge.svg?token=DR2EBIWK7B)](https://codecov.io/gh/amantinband/error-or)\r\n---\r\n\r\n### A simple, fluent discriminated union of an error or a result.\r\n\r\n`dotnet add package ErrorOr`\r\n\r\n</div>\r\n\r\n- [Give it a star â­!](#give-it-a-star-)\r\n- [Getting Started ð](#getting-started-)\r\n  - [Replace throwing exceptions with `ErrorOr<T>`](#replace-throwing-exceptions-with-errorort)\r\n  - [Support For Multiple Errors](#support-for-multiple-errors)\r\n  - [Various Functional Methods and Extension Methods](#various-functional-methods-and-extension-methods)\r\n    - [Real world example](#real-world-example)\r\n    - [Simple Example with intermediate steps](#simple-example-with-intermediate-steps)\r\n      - [No Failure](#no-failure)\r\n      - [Failure](#failure)\r\n- [Creating an `ErrorOr` instance](#creating-an-erroror-instance)\r\n  - [Using implicit conversion](#using-implicit-conversion)\r\n  - [Using The `ErrorOrFactory`](#using-the-errororfactory)\r\n  - [Using The `ToErrorOr` Extension Method](#using-the-toerroror-extension-method)\r\n- [Properties](#properties)\r\n  - [`IsError`](#iserror)\r\n  - [`Value`](#value)\r\n  - [`Errors`](#errors)\r\n  - [`FirstError`](#firsterror)\r\n  - [`ErrorsOrEmptyList`](#errorsoremptylist)\r\n- [Methods](#methods)\r\n  - [`Match`](#match)\r\n    - [`Match`](#match-1)\r\n    - [`MatchAsync`](#matchasync)\r\n    - [`MatchFirst`](#matchfirst)\r\n    - [`MatchFirstAsync`](#matchfirstasync)\r\n  - [`Switch`](#switch)\r\n    - [`Switch`](#switch-1)\r\n    - [`SwitchAsync`](#switchasync)\r\n    - [`SwitchFirst`](#switchfirst)\r\n    - [`SwitchFirstAsync`](#switchfirstasync)\r\n  - [`Then`](#then)\r\n    - [`Then`](#then-1)\r\n    - [`ThenAsync`](#thenasync)\r\n    - [`ThenDo` and `ThenDoAsync`](#thendo-and-thendoasync)\r\n    - [Mixing `Then`, `ThenDo`, `ThenAsync`, `ThenDoAsync`](#mixing-then-thendo-thenasync-thendoasync)\r\n  - [`FailIf`](#failif)\r\n  - [`Else`](#else)\r\n    - [`Else`](#else-1)\r\n    - [`ElseAsync`](#elseasync)\r\n- [Mixing Features (`Then`, `FailIf`, `Else`, `Switch`, `Match`)](#mixing-features-then-failif-else-switch-match)\r\n- [Error Types](#error-types)\r\n  - [Built in error types](#built-in-error-types)\r\n  - [Custom error types](#custom-error-types)\r\n- [Built in result types (`Result.Success`, ..)](#built-in-result-types-resultsuccess-)\r\n- [Organizing Errors](#organizing-errors)\r\n- [Mediator + FluentValidation + `ErrorOr` ð¤](#mediator--fluentvalidation--erroror-)\r\n- [Contribution ð¤²](#contribution-)\r\n- [Credits ð](#credits-)\r\n- [License ðªª](#license-)\r\n\r\n# Give it a star â­!\r\n\r\nLoving it? Show your support by giving this project a star!\r\n\r\n# Getting Started ð\r\n\r\n## Replace throwing exceptions with `ErrorOr<T>`\r\n\r\nThis ð\r\n\r\n```cs\r\npublic float Divide(int a, int b)\r\n{\r\n    if (b == 0)\r\n    {\r\n        throw new Exception(\"Cannot divide by zero\");\r\n    }\r\n\r\n    return a / b;\r\n}\r\n\r\ntry\r\n{\r\n    var result = Divide(4, 2);\r\n    Console.WriteLine(result * 2); // 4\r\n}\r\ncatch (Exception e)\r\n{\r\n    Console.WriteLine(e.Message);\r\n    return;\r\n}\r\n```\r\n\r\nTurns into this ð\r\n\r\n```cs\r\npublic ErrorOr<float> Divide(int a, int b)\r\n{\r\n    if (b == 0)\r\n    {\r\n        return Error.Unexpected(description: \"Cannot divide by zero\");\r\n    }\r\n\r\n    return a / b;\r\n}\r\n\r\nvar result = Divide(4, 2);\r\n\r\nif (result.IsError)\r\n{\r\n    Console.WriteLine(result.FirstError.Description);\r\n    return;\r\n}\r\n\r\nConsole.WriteLine(result.Value * 2); // 4\r\n```\r\n\r\nOr, using [Then](#then--thenasync)/[Else](#else--elseasync) and [Switch](#switch--switchasync)/[Match](#match--matchasync), you can do this ð\r\n\r\n```cs\r\n\r\nDivide(4, 2)\r\n    .Then(val => val * 2)\r\n    .SwitchFirst(\r\n        onValue: Console.WriteLine, // 4\r\n        onFirstError: error => Console.WriteLine(error.Description));\r\n```\r\n\r\n## Support For Multiple Errors\r\n\r\nInternally, the `ErrorOr` object has a list of `Error`s, so if you have multiple errors, you don't need to compromise and have only the first one.\r\n\r\n```cs\r\npublic class User(string _name)\r\n{\r\n    public static ErrorOr<User> Create(string name)\r\n    {\r\n        List<Error> errors = [];\r\n\r\n        if (name.Length < 2)\r\n        {\r\n            errors.Add(Error.Validation(description: \"Name is too short\"));\r\n        }\r\n\r\n        if (name.Length > 100)\r\n        {\r\n            errors.Add(Error.Validation(description: \"Name is too long\"));\r\n        }\r\n\r\n        if (string.IsNullOrWhiteSpace(name))\r\n        {\r\n            errors.Add(Error.Validation(description: \"Name cannot be empty or whitespace only\"));\r\n        }\r\n\r\n        if (errors.Count > 0)\r\n        {\r\n            return errors;\r\n        }\r\n\r\n        return new User(name);\r\n    }\r\n}\r\n```\r\n\r\n## Various Functional Methods and Extension Methods\r\n\r\nThe `ErrorOr` object has a variety of methods that allow you to work with it in a functional way.\r\n\r\nThis allows you to chain methods together, and handle the result in a clean and concise way.\r\n\r\n### Real world example\r\n\r\n```cs\r\nreturn await _userRepository.GetByIdAsync(id)\r\n    .Then(user => user.IncrementAge()\r\n        .Then(success => user)\r\n        .Else(errors => Error.Unexpected(\"Not expected to fail\")))\r\n    .FailIf(user => !user.IsOverAge(18), UserErrors.UnderAge)\r\n    .ThenDo(user => _logger.LogInformation($\"User {user.Id} incremented age to {user.Age}\"))\r\n    .ThenAsync(user => _userRepository.UpdateAsync(user))\r\n    .Match(\r\n        _ => NoContent(),\r\n        errors => errors.ToActionResult());\r\n```\r\n\r\n### Simple Example with intermediate steps\r\n\r\n#### No Failure\r\n\r\n```cs\r\nErrorOr<string> foo = await \"2\".ToErrorOr()\r\n    .Then(int.Parse) // 2\r\n    .FailIf(val => val > 2, Error.Validation(description: $\"{val} is too big\") // 2\r\n    .ThenDoAsync(Task.Delay) // Sleep for 2 milliseconds\r\n    .ThenDo(val => Console.WriteLine($\"Finished waiting {val} milliseconds.\")) // Finished waiting 2 milliseconds.\r\n    .ThenAsync(val => Task.FromResult(val * 2)) // 4\r\n    .Then(val => $\"The result is {val}\") // \"The result is 4\"\r\n    .Else(errors => Error.Unexpected(description: \"Yikes\")) // \"The result is 4\"\r\n    .MatchFirst(\r\n        value => value, // \"The result is 4\"\r\n        firstError => $\"An error occurred: {firstError.Description}\");\r\n```\r\n\r\n#### Failure\r\n\r\n```cs\r\nErrorOr<string> foo = await \"5\".ToErrorOr()\r\n    .Then(int.Parse) // 5\r\n    .FailIf(val => val > 2, Error.Validation(description: $\"{val} is too big\") // Error.Validation()\r\n    .ThenDoAsync(Task.Delay) // Error.Validation()\r\n    .ThenDo(val => Console.WriteLine($\"Finished waiting {val} milliseconds.\")) // Error.Validation()\r\n    .ThenAsync(val => Task.FromResult(val * 2)) // Error.Validation()\r\n    .Then(val => $\"The result is {val}\") // Error.Validation()\r\n    .Else(errors => Error.Unexpected(description: \"Yikes\")) // Error.Unexpected()\r\n    .MatchFirst(\r\n        value => value,\r\n        firstError => $\"An error occurred: {firstError.Description}\"); // An error occurred: Yikes\r\n```\r\n\r\n\r\n# Creating an `ErrorOr` instance\r\n\r\n## Using implicit conversion\r\n\r\nThere are implicit converters from `TResult`, `Error`, `List<Error>` to `ErrorOr<TResult>`\r\n\r\n```cs\r\nErrorOr<int> result = 5;\r\nErrorOr<int> result = Error.Unexpected();\r\nErrorOr<int> result = [Error.Validation(), Error.Validation()];\r\n```\r\n\r\n```cs\r\npublic ErrorOr<int> IntToErrorOr()\r\n{\r\n    return 5;\r\n}\r\n```\r\n\r\n```cs\r\npublic ErrorOr<int> SingleErrorToErrorOr()\r\n{\r\n    return Error.Unexpected();\r\n}\r\n```\r\n\r\n```cs\r\npublic ErrorOr<int> MultipleErrorsToErrorOr()\r\n{\r\n    return [\r\n        Error.Validation(description: \"Invalid Name\"),\r\n        Error.Validation(description: \"Invalid Last Name\")\r\n    ];\r\n}\r\n```\r\n\r\n## Using The `ErrorOrFactory`\r\n\r\n```cs\r\nErrorOr<int> result = ErrorOrFactory.From(5);\r\nErrorOr<int> result = ErrorOrFactory.From<int>(Error.Unexpected());\r\nErrorOr<int> result = ErrorOrFactory.From<int>([Error.Validation(), Error.Validation()]);\r\n```\r\n\r\n```cs\r\npublic ErrorOr<int> GetValue()\r\n{\r\n    return ErrorOrFactory.From(5);\r\n}\r\n```\r\n\r\n```cs\r\npublic ErrorOr<int> SingleErrorToErrorOr()\r\n{\r\n    return ErrorOrFactory.From<int>(Error.Unexpected());\r\n}\r\n```\r\n\r\n```cs\r\npublic ErrorOr<int> MultipleErrorsToErrorOr()\r\n{\r\n    return ErrorOrFactory.From([\r\n        Error.Validation(description: \"Invalid Name\"),\r\n        Error.Validation(description: \"Invalid Last Name\")\r\n    ]);\r\n}\r\n```\r\n\r\n## Using The `ToErrorOr` Extension Method\r\n\r\n```cs\r\nErrorOr<int> result = 5.ToErrorOr();\r\nErrorOr<int> result = Error.Unexpected().ToErrorOr<int>();\r\nErrorOr<int> result = new[] { Error.Validation(), Error.Validation() }.ToErrorOr<int>();\r\n```\r\n\r\n# Properties\r\n\r\n## `IsError`\r\n\r\n```cs\r\nErrorOr<int> result = User.Create();\r\n\r\nif (result.IsError)\r\n{\r\n    // the result contains one or more errors\r\n}\r\n```\r\n\r\n## `Value`\r\n\r\n```cs\r\nErrorOr<int> result = User.Create();\r\n\r\nif (!result.IsError) // the result contains a value\r\n{\r\n    Console.WriteLine(result.Value);\r\n}\r\n```\r\n\r\n## `Errors`\r\n\r\n```cs\r\nErrorOr<int> result = User.Create();\r\n\r\nif (result.IsError)\r\n{\r\n    result.Errors // contains the list of errors that occurred\r\n        .ForEach(error => Console.WriteLine(error.Description));\r\n}\r\n```\r\n\r\n## `FirstError`\r\n\r\n```cs\r\nErrorOr<int> result = User.Create();\r\n\r\nif (result.IsError)\r\n{\r\n    var firstError = result.FirstError; // only the first error that occurred\r\n    Console.WriteLine(firstError == result.Errors[0]); // true\r\n}\r\n```\r\n\r\n## `ErrorsOrEmptyList`\r\n\r\n```cs\r\nErrorOr<int> result = User.Create();\r\n\r\nif (result.IsError)\r\n{\r\n    result.ErrorsOrEmptyList // List<Error> { /* one or more errors */  }\r\n    return;\r\n}\r\n\r\nresult.ErrorsOrEmptyList // List<Error> { }\r\n```\r\n\r\n# Methods\r\n\r\n## `Match`\r\n\r\nThe `Match` method receives two functions, `onValue` and `onError`, `onValue` will be invoked if the result is success, and `onError` is invoked if the result is an error.\r\n\r\n### `Match`\r\n\r\n```cs\r\nstring foo = result.Match(\r\n    value => value,\r\n    errors => $\"{errors.Count} errors occurred.\");\r\n```\r\n\r\n### `MatchAsync`\r\n\r\n```cs\r\nstring foo = await result.MatchAsync(\r\n    value => Task.FromResult(value),\r\n    errors => Task.FromResult($\"{errors.Count} errors occurred.\"));\r\n```\r\n\r\n### `MatchFirst`\r\n\r\nThe `MatchFirst` method receives two functions, `onValue` and `onError`, `onValue` will be invoked if the result is success, and `onError` is invoked if the result is an error.\r\n\r\nUnlike `Match`, if the state is error, `MatchFirst`'s `onError` function receives only the first error that occurred, not the entire list of errors.\r\n\r\n\r\n```cs\r\nstring foo = result.MatchFirst(\r\n    value => value,\r\n    firstError => firstError.Description);\r\n```\r\n\r\n### `MatchFirstAsync`\r\n\r\n```cs\r\nstring foo = await result.MatchFirstAsync(\r\n    value => Task.FromResult(value),\r\n    firstError => Task.FromResult(firstError.Description));\r\n```\r\n\r\n## `Switch`\r\n\r\nThe `Switch` method receives two actions, `onValue` and `onError`, `onValue` will be invoked if the result is success, and `onError` is invoked if the result is an error.\r\n\r\n### `Switch`\r\n\r\n```cs\r\nresult.Switch(\r\n    value => Console.WriteLine(value),\r\n    errors => Console.WriteLine($\"{errors.Count} errors occurred.\"));\r\n```\r\n\r\n### `SwitchAsync`\r\n\r\n```cs\r\nawait result.SwitchAsync(\r\n    value => { Console.WriteLine(value); return Task.CompletedTask; },\r\n    errors => { Console.WriteLine($\"{errors.Count} errors occurred.\"); return Task.CompletedTask; });\r\n```\r\n\r\n### `SwitchFirst`\r\n\r\nThe `SwitchFirst` method receives two actions, `onValue` and `onError`, `onValue` will be invoked if the result is success, and `onError` is invoked if the result is an error.\r\n\r\nUnlike `Switch`, if the state is error, `SwitchFirst`'s `onError` function receives only the first error that occurred, not the entire list of errors.\r\n\r\n```cs\r\nresult.SwitchFirst(\r\n    value => Console.WriteLine(value),\r\n    firstError => Console.WriteLine(firstError.Description));\r\n```\r\n\r\n###  `SwitchFirstAsync`\r\n\r\n```cs\r\nawait result.SwitchFirstAsync(\r\n    value => { Console.WriteLine(value); return Task.CompletedTask; },\r\n    firstError => { Console.WriteLine(firstError.Description); return Task.CompletedTask; });\r\n```\r\n\r\n## `Then`\r\n\r\n### `Then`\r\n\r\n`Then` receives a function, and invokes it only if the result is not an error.\r\n\r\n```cs\r\nErrorOr<int> foo = result\r\n    .Then(val => val * 2);\r\n```\r\n\r\nMultiple `Then` methods can be chained together.\r\n\r\n```cs\r\nErrorOr<string> foo = result\r\n    .Then(val => val * 2)\r\n    .Then(val => $\"The result is {val}\");\r\n```\r\n\r\nIf any of the methods return an error, the chain will break and the errors will be returned.\r\n\r\n```cs\r\nErrorOr<int> Foo() => Error.Unexpected();\r\n\r\nErrorOr<string> foo = result\r\n    .Then(val => val * 2)\r\n    .Then(_ => GetAnError())\r\n    .Then(val => $\"The result is {val}\") // this function will not be invoked\r\n    .Then(val => $\"The result is {val}\"); // this function will not be invoked\r\n```\r\n\r\n### `ThenAsync`\r\n\r\n`ThenAsync` receives an asynchronous function, and invokes it only if the result is not an error.\r\n\r\n```cs\r\nErrorOr<string> foo = await result\r\n    .ThenAsync(val => DoSomethingAsync(val))\r\n    .ThenAsync(val => DoSomethingElseAsync($\"The result is {val}\"));\r\n```\r\n\r\n### `ThenDo` and `ThenDoAsync`\r\n\r\n`ThenDo` and `ThenDoAsync` are similar to `Then` and `ThenAsync`, but instead of invoking a function that returns a value, they invoke an action.\r\n\r\n```cs\r\nErrorOr<string> foo = result\r\n    .ThenDo(val => Console.WriteLine(val))\r\n    .ThenDo(val => Console.WriteLine($\"The result is {val}\"));\r\n```\r\n\r\n```cs\r\nErrorOr<string> foo = await result\r\n    .ThenDoAsync(val => Task.Delay(val))\r\n    .ThenDo(val => Console.WriteLine($\"Finsihed waiting {val} seconds.\"))\r\n    .ThenDoAsync(val => Task.FromResult(val * 2))\r\n    .ThenDo(val => $\"The result is {val}\");\r\n```\r\n\r\n### Mixing `Then`, `ThenDo`, `ThenAsync`, `ThenDoAsync`\r\n\r\nYou can mix and match `Then`, `ThenDo`, `ThenAsync`, `ThenDoAsync` methods.\r\n\r\n```cs\r\nErrorOr<string> foo = await result\r\n    .ThenDoAsync(val => Task.Delay(val))\r\n    .Then(val => val * 2)\r\n    .ThenAsync(val => DoSomethingAsync(val))\r\n    .ThenDo(val => Console.WriteLine($\"Finsihed waiting {val} seconds.\"))\r\n    .ThenAsync(val => Task.FromResult(val * 2))\r\n    .Then(val => $\"The result is {val}\");\r\n```\r\n\r\n## `FailIf`\r\n\r\n`FailIf` receives a predicate and an error. If the predicate is true, `FailIf` will return the error. Otherwise, it will return the value of the result.\r\n\r\n```cs\r\nErrorOr<int> foo = result\r\n    .FailIf(val => val > 2, Error.Validation(description: $\"{val} is too big\"));\r\n```\r\n\r\nOnce an error is returned, the chain will break and the error will be returned.\r\n\r\n```cs\r\nvar result = \"2\".ToErrorOr()\r\n    .Then(int.Parse) // 2\r\n    .FailIf(val => val > 1, Error.Validation(description: $\"{val} is too big\") // validation error\r\n    .Then(num => num * 2) // this function will not be invoked\r\n    .Then(num => num * 2) // this function will not be invoked\r\n```\r\n\r\n## `Else`\r\n\r\n`Else` receives a value or a function. If the result is an error, `Else` will return the value or invoke the function. Otherwise, it will return the value of the result.\r\n\r\n### `Else`\r\n\r\n```cs\r\nErrorOr<string> foo = result\r\n    .Else(\"fallback value\");\r\n```\r\n\r\n```cs\r\nErrorOr<string> foo = result\r\n    .Else(errors => $\"{errors.Count} errors occurred.\");\r\n```\r\n\r\n### `ElseAsync`\r\n\r\n```cs\r\nErrorOr<string> foo = await result\r\n    .ElseAsync(Task.FromResult(\"fallback value\"));\r\n```\r\n\r\n```cs\r\nErrorOr<string> foo = await result\r\n    .ElseAsync(errors => Task.FromResult($\"{errors.Count} errors occurred.\"));\r\n```\r\n\r\n# Mixing Features (`Then`, `FailIf`, `Else`, `Switch`, `Match`)\r\n\r\nYou can mix `Then`, `FailIf`, `Else`, `Switch` and `Match` methods together.\r\n\r\n```cs\r\nErrorOr<string> foo = await result\r\n    .ThenDoAsync(val => Task.Delay(val))\r\n    .FailIf(val => val > 2, Error.Validation(description: $\"{val} is too big\"))\r\n    .ThenDo(val => Console.WriteLine($\"Finished waiting {val} seconds.\"))\r\n    .ThenAsync(val => Task.FromResult(val * 2))\r\n    .Then(val => $\"The result is {val}\")\r\n    .Else(errors => Error.Unexpected())\r\n    .MatchFirst(\r\n        value => value,\r\n        firstError => $\"An error occurred: {firstError.Description}\");\r\n```\r\n\r\n# Error Types\r\n\r\nEach `Error` instance has a `Type` property, which is an enum value that represents the type of the error.\r\n\r\n## Built in error types\r\n\r\nThe following error types are built in:\r\n\r\n```cs\r\npublic enum ErrorType\r\n{\r\n    Failure,\r\n    Unexpected,\r\n    Validation,\r\n    Conflict,\r\n    NotFound,\r\n    Unauthorized,\r\n    Forbidden,\r\n}\r\n```\r\n\r\nEach error type has a static method that creates an error of that type. For example:\r\n\r\n```cs\r\nvar error = Error.NotFound();\r\n```\r\n\r\noptionally, you can pass a code, description and metadata to the error:\r\n\r\n```cs\r\nvar error = Error.Unexpected(\r\n    code: \"User.ShouldNeverHappen\",\r\n    description: \"A user error that should never happen\",\r\n    metadata: new Dictionary<string, object>\r\n    {\r\n        { \"user\", user },\r\n    });\r\n```\r\nThe `ErrorType` enum is a good way to categorize errors.\r\n\r\n## Custom error types\r\n\r\nYou can create your own error types if you would like to categorize your errors differently.\r\n\r\nA custom error type can be created with the `Custom` static method\r\n\r\n```cs\r\npublic static class MyErrorTypes\r\n{\r\n    const int ShouldNeverHappen = 12;\r\n}\r\n\r\nvar error = Error.Custom(\r\n    type: MyErrorTypes.ShouldNeverHappen,\r\n    code: \"User.ShouldNeverHappen\",\r\n    description: \"A user error that should never happen\");\r\n```\r\n\r\nYou can use the `Error.NumericType` method to retrieve the numeric type of the error.\r\n\r\n```cs\r\nvar errorMessage = Error.NumericType switch\r\n{\r\n    MyErrorType.ShouldNeverHappen => \"Consider replacing dev team\",\r\n    _ => \"An unknown error occurred.\",\r\n};\r\n```\r\n\r\n# Built in result types (`Result.Success`, ..)\r\n\r\nThere are a few built in result types:\r\n\r\n```cs\r\nErrorOr<Success> result = Result.Success;\r\nErrorOr<Created> result = Result.Created;\r\nErrorOr<Updated> result = Result.Updated;\r\nErrorOr<Deleted> result = Result.Deleted;\r\n```\r\n\r\nWhich can be used as following\r\n\r\n```cs\r\nErrorOr<Deleted> DeleteUser(Guid id)\r\n{\r\n    var user = await _userRepository.GetByIdAsync(id);\r\n    if (user is null)\r\n    {\r\n        return Error.NotFound(description: \"User not found.\");\r\n    }\r\n\r\n    await _userRepository.DeleteAsync(user);\r\n    return Result.Deleted;\r\n}\r\n```\r\n\r\n# Organizing Errors\r\n\r\nA nice approach, is creating a static class with the expected errors. For example:\r\n\r\n```cs\r\npublic static partial class DivisionErrors\r\n{\r\n    public static Error CannotDivideByZero = Error.Unexpected(\r\n        code: \"Division.CannotDivideByZero\",\r\n        description: \"Cannot divide by zero.\");\r\n}\r\n```\r\n\r\nWhich can later be used as following ð\r\n\r\n```cs\r\npublic ErrorOr<float> Divide(int a, int b)\r\n{\r\n    if (b == 0)\r\n    {\r\n        return DivisionErrors.CannotDivideByZero;\r\n    }\r\n\r\n    return a / b;\r\n}\r\n```\r\n\r\n# [Mediator](https://github.com/jbogard/MediatR) + [FluentValidation](https://github.com/FluentValidation/FluentValidation) + `ErrorOr` ð¤\r\n\r\nA common approach when using `MediatR` is to use `FluentValidation` to validate the request before it reaches the handler.\r\n\r\nUsually, the validation is done using a `Behavior` that throws an exception if the request is invalid.\r\n\r\nUsing `ErrorOr`, we can create a `Behavior` that returns an error instead of throwing an exception.\r\n\r\nThis plays nicely when the project uses `ErrorOr`, as the layer invoking the `Mediator`, similar to other components in the project, simply receives an `ErrorOr` and can handle it accordingly.\r\n\r\nHere is an example of a `Behavior` that validates the request and returns an error if it's invalid ð\r\n\r\n```cs\r\npublic class ValidationBehavior<TRequest, TResponse>(IValidator<TRequest>? validator = null)\r\n    : IPipelineBehavior<TRequest, TResponse>\r\n        where TRequest : IRequest<TResponse>\r\n        where TResponse : IErrorOr\r\n{\r\n    private readonly IValidator<TRequest>? _validator = validator;\r\n\r\n    public async Task<TResponse> Handle(\r\n        TRequest request,\r\n        RequestHandlerDelegate<TResponse> next,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        if (_validator is null)\r\n        {\r\n            return await next();\r\n        }\r\n\r\n        var validationResult = await _validator.ValidateAsync(request, cancellationToken);\r\n\r\n        if (validationResult.IsValid)\r\n        {\r\n            return await next();\r\n        }\r\n\r\n        var errors = validationResult.Errors\r\n            .ConvertAll(error => Error.Validation(\r\n                code: error.PropertyName,\r\n                description: error.ErrorMessage));\r\n\r\n        return (dynamic)errors;\r\n    }\r\n}\r\n```\r\n\r\n# Contribution ð¤²\r\n\r\nIf you have any questions, comments, or suggestions, please open an issue or create a pull request ð\r\n\r\n# Credits ð\r\n\r\n- [OneOf](https://github.com/mcintyre321/OneOf/tree/master/OneOf) - An awesome library which provides F# style discriminated unions behavior for C#\r\n\r\n# License ðªª\r\n\r\nThis project is licensed under the terms of the [MIT](https://github.com/mantinband/error-or/blob/main/LICENSE) license.\r\n"
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}