{
  "metadata": {
    "timestamp": 1736710916033,
    "page": 528,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "dynamicexpresso/DynamicExpresso",
      "stars": 2040,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 13.2685546875,
          "content": "# EditorConfig is awesome: https://EditorConfig.org\n#\n# More info about editorconfig for C# and .NET in Visual Studio see:\n# https://docs.microsoft.com/en-us/visualstudio/ide/create-portable-custom-editor-options?view=vs-2019\n#\n# Most of the .NET and C# rules below were taken from the\n# Microsoft Roslyn team's editorconfig at:\n# https://github.com/dotnet/roslyn/blob/master/.editorconfig\n\n# Top-most EditorConfig file.\nroot = true\n\n# All files\n[*]\ncharset = utf-8\n# indent_size intentionally not specified in this section.\nindent_style = space # Use soft tabs (spaces) for indentation.\ninsert_final_newline = true\ntrim_trailing_whitespace = true\n\n# JSON files\n[*.json]\nindent_size = 2\n\n# Markdown files\n[*.md]\nindent_size = 2\ntrim_trailing_whitespace = false\n\n# PowerShell scripts\n[*.ps1]\nindent_size = 4\n\n# Visual Studio XML project files\n[*.{csproj,vcxproj,vcxproj.filters,proj,projitems,shproj}]\nindent_size = 2\n\n# Visual Studio and .NET related XML config files\n[*.{props,targets,ruleset,config,nuspec,resx,vsixmanifest,vsct}]\nindent_size = 2\n\n# YAML files\n[*.{yml,yaml}]\nindent_size = 2\nindent_style = space\n\n#==================================================================\n# C# files\n#\n# Most of the .NET and C# rules below were taken from the\n# Microsoft Roslyn team's editorconfig at:\n# https://github.com/dotnet/roslyn/blob/master/.editorconfig\n#\n# More info about editorconfig for C# and .NET in Visual Studio see:\n# https://docs.microsoft.com/en-us/visualstudio/ide/create-portable-custom-editor-options?view=vs-2019\n#\n# Code style rules options:\n# https://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/code-style-rule-options?view=vs-2019\n#\n# Enforce Code Style in Builds\n# For builds, outside of Visual Studio, you can enable code style analysis for .NET projects by\n# setting the EnforceCodeStyleInBuild property to true in the VS .csproj file.\n# Example:\n#   <PropertyGroup>\n#       <EnforceCodeStyleInBuild>true</EnforceCodeStyleInBuild>\n#   </PropertyGroup>\n# See https://docs.microsoft.com/en-us/dotnet/core/project-sdk/msbuild-props#enforcecodestyleinbuild\n# Note: This feature is currently experimental and may change between the .NET 5 and .NET 6 releases.\n#\n[*.cs]\nindent_size = 4\nindent_style = tab # Use soft tabs (spaces) for indentation.\n\n# IDE0055: Fix formatting\ndotnet_diagnostic.IDE0055.severity = warning\n\n# Sort using and Import directives with System.* appearing first\ndotnet_sort_system_directives_first = true\ndotnet_separate_import_directive_groups = false\n# Avoid \"this.\" and \"Me.\" if not necessary\ndotnet_style_qualification_for_field = false:refactoring\ndotnet_style_qualification_for_property = false:refactoring\ndotnet_style_qualification_for_method = false:refactoring\ndotnet_style_qualification_for_event = false:refactoring\n\n# Use language keywords instead of framework type names for type references\ndotnet_style_predefined_type_for_locals_parameters_members = true:suggestion\ndotnet_style_predefined_type_for_member_access = true:suggestion\n\n# Suggest more modern language features when available\ndotnet_style_object_initializer = true:suggestion\ndotnet_style_collection_initializer = true:suggestion\ndotnet_style_coalesce_expression = true:suggestion\ndotnet_style_null_propagation = true:suggestion\ndotnet_style_explicit_tuple_names = true:suggestion\n\n# Non-private static fields are PascalCase\ndotnet_naming_rule.non_private_static_fields_should_be_pascal_case.severity = suggestion\ndotnet_naming_rule.non_private_static_fields_should_be_pascal_case.symbols = non_private_static_fields\ndotnet_naming_rule.non_private_static_fields_should_be_pascal_case.style = non_private_static_field_style\n\ndotnet_naming_symbols.non_private_static_fields.applicable_kinds = field\ndotnet_naming_symbols.non_private_static_fields.applicable_accessibilities = public, protected, internal, protected_internal, private_protected\ndotnet_naming_symbols.non_private_static_fields.required_modifiers = static\n\ndotnet_naming_style.non_private_static_field_style.capitalization = pascal_case\n\n# Non-private readonly fields are PascalCase\ndotnet_naming_rule.non_private_readonly_fields_should_be_pascal_case.severity = suggestion\ndotnet_naming_rule.non_private_readonly_fields_should_be_pascal_case.symbols = non_private_readonly_fields\ndotnet_naming_rule.non_private_readonly_fields_should_be_pascal_case.style = non_private_readonly_field_style\n\ndotnet_naming_symbols.non_private_readonly_fields.applicable_kinds = field\ndotnet_naming_symbols.non_private_readonly_fields.applicable_accessibilities = public, protected, internal, protected_internal, private_protected\ndotnet_naming_symbols.non_private_readonly_fields.required_modifiers = readonly\n\ndotnet_naming_style.non_private_readonly_field_style.capitalization = pascal_case\n\n# Constants are PascalCase\ndotnet_naming_rule.constants_should_be_pascal_case.severity = suggestion\ndotnet_naming_rule.constants_should_be_pascal_case.symbols = constants\ndotnet_naming_rule.constants_should_be_pascal_case.style = constant_style\n\ndotnet_naming_symbols.constants.applicable_kinds = field, local\ndotnet_naming_symbols.constants.required_modifiers = const\n\ndotnet_naming_style.constant_style.capitalization = pascal_case\n\n# Static fields are camelCase and start with s_\ndotnet_naming_rule.static_fields_should_be_camel_case.severity = suggestion\ndotnet_naming_rule.static_fields_should_be_camel_case.symbols = static_fields\ndotnet_naming_rule.static_fields_should_be_camel_case.style = static_field_style\n\ndotnet_naming_symbols.static_fields.applicable_kinds = field\ndotnet_naming_symbols.static_fields.required_modifiers = static\n\ndotnet_naming_style.static_field_style.capitalization = camel_case\ndotnet_naming_style.static_field_style.required_prefix = s_\n\n# Instance fields are camelCase and start with _\ndotnet_naming_rule.instance_fields_should_be_camel_case.severity = suggestion\ndotnet_naming_rule.instance_fields_should_be_camel_case.symbols = instance_fields\ndotnet_naming_rule.instance_fields_should_be_camel_case.style = instance_field_style\n\ndotnet_naming_symbols.instance_fields.applicable_kinds = field\n\ndotnet_naming_style.instance_field_style.capitalization = camel_case\ndotnet_naming_style.instance_field_style.required_prefix = _\n\n# Locals and parameters are camelCase\ndotnet_naming_rule.locals_should_be_camel_case.severity = suggestion\ndotnet_naming_rule.locals_should_be_camel_case.symbols = locals_and_parameters\ndotnet_naming_rule.locals_should_be_camel_case.style = camel_case_style\n\ndotnet_naming_symbols.locals_and_parameters.applicable_kinds = parameter, local\n\ndotnet_naming_style.camel_case_style.capitalization = camel_case\n\n# Local functions are PascalCase\ndotnet_naming_rule.local_functions_should_be_pascal_case.severity = suggestion\ndotnet_naming_rule.local_functions_should_be_pascal_case.symbols = local_functions\ndotnet_naming_rule.local_functions_should_be_pascal_case.style = local_function_style\n\ndotnet_naming_symbols.local_functions.applicable_kinds = local_function\n\ndotnet_naming_style.local_function_style.capitalization = pascal_case\n\n# By default, name items with PascalCase\ndotnet_naming_rule.members_should_be_pascal_case.severity = suggestion\ndotnet_naming_rule.members_should_be_pascal_case.symbols = all_members\ndotnet_naming_rule.members_should_be_pascal_case.style = pascal_case_style\n\ndotnet_naming_symbols.all_members.applicable_kinds = *\n\ndotnet_naming_style.pascal_case_style.capitalization = pascal_case\n\n# error RS2008: Enable analyzer release tracking for the analyzer project containing rule '{0}'\ndotnet_diagnostic.RS2008.severity = none\n\n# IDE0073: File header comment\n# Don't require source files to include header comment that matches\n# the text specified in the file_header_template option.\ndotnet_diagnostic.IDE0073.severity = none\n\n# Newly created .cs files will begin with a comment line that includes\n# the text specified in the file_header_template option.\n# Omitt, or comment out, the file_header_template option if you don't\n# use file header comments.\n# file_header_template = Sample header comment text.\n\n# IDE0035: Remove unreachable code\ndotnet_diagnostic.IDE0035.severity = warning\n\n# IDE0036: Order modifiers\ndotnet_diagnostic.IDE0036.severity = warning\n\n# IDE0043: Format string contains invalid placeholder\ndotnet_diagnostic.IDE0043.severity = warning\n\n# IDE0044: Make field readonly\ndotnet_diagnostic.IDE0044.severity = warning\n\n# RS0016: Only enable if API files are present\ndotnet_public_api_analyzer.require_api_files = true\n\n# CSharp code style settings:\n[*.cs]\n# Newline settings\ncsharp_new_line_before_open_brace = all\ncsharp_new_line_before_else = true\ncsharp_new_line_before_catch = true\ncsharp_new_line_before_finally = true\ncsharp_new_line_before_members_in_object_initializers = true\ncsharp_new_line_before_members_in_anonymous_types = true\ncsharp_new_line_between_query_expression_clauses = true\n\n# Indentation preferences\ncsharp_indent_block_contents = true\ncsharp_indent_braces = false\ncsharp_indent_case_contents = true\ncsharp_indent_case_contents_when_block = true\ncsharp_indent_switch_labels = true\ncsharp_indent_labels = flush_left\n\n# Prefer \"var\" everywhere\ncsharp_style_var_for_built_in_types = true:suggestion\ncsharp_style_var_when_type_is_apparent = true:suggestion\ncsharp_style_var_elsewhere = true:suggestion\n\n# Prefer method-like constructs to have a block body\ncsharp_style_expression_bodied_methods = false:none\ncsharp_style_expression_bodied_constructors = false:none\ncsharp_style_expression_bodied_operators = false:none\n\n# Prefer property-like constructs to have an expression-body\ncsharp_style_expression_bodied_properties = true:none\ncsharp_style_expression_bodied_indexers = true:none\ncsharp_style_expression_bodied_accessors = true:none\n\n# Suggest more modern language features when available\ncsharp_style_pattern_matching_over_is_with_cast_check = true:suggestion\ncsharp_style_pattern_matching_over_as_with_null_check = true:suggestion\ncsharp_style_inlined_variable_declaration = true:suggestion\ncsharp_style_throw_expression = true:suggestion\ncsharp_style_conditional_delegate_call = true:suggestion\n\n# Space preferences\ncsharp_space_after_cast = false\ncsharp_space_after_colon_in_inheritance_clause = true\ncsharp_space_after_comma = true\ncsharp_space_after_dot = false\ncsharp_space_after_keywords_in_control_flow_statements = true\ncsharp_space_after_semicolon_in_for_statement = true\ncsharp_space_around_binary_operators = before_and_after\ncsharp_space_around_declaration_statements = do_not_ignore\ncsharp_space_before_colon_in_inheritance_clause = true\ncsharp_space_before_comma = false\ncsharp_space_before_dot = false\ncsharp_space_before_open_square_brackets = false\ncsharp_space_before_semicolon_in_for_statement = false\ncsharp_space_between_empty_square_brackets = false\ncsharp_space_between_method_call_empty_parameter_list_parentheses = false\ncsharp_space_between_method_call_name_and_opening_parenthesis = false\ncsharp_space_between_method_call_parameter_list_parentheses = false\ncsharp_space_between_method_declaration_empty_parameter_list_parentheses = false\ncsharp_space_between_method_declaration_name_and_open_parenthesis = false\ncsharp_space_between_method_declaration_parameter_list_parentheses = false\ncsharp_space_between_parentheses = false\ncsharp_space_between_square_brackets = false\n\n# Blocks are allowed\ncsharp_prefer_braces = true:silent\ncsharp_preserve_single_line_blocks = true\ncsharp_preserve_single_line_statements = true\n\n[src/CodeStyle/**.cs]\n# warning RS0005: Do not use generic CodeAction.Create to create CodeAction\ndotnet_diagnostic.RS0005.severity = none\n\n[src/{Analyzers,CodeStyle,Features,Workspaces,EditorFeatures, VisualStudio}/**/*.cs]\n\n# IDE0005: Remove unnecessary import (Remove unnecessary using)\n# https://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/style-rules/ide0005\n# NOTE: To enable this rule on build, you need to enable XML documentation comments for the project.\n# See GitHub issue 41640 for more details:\n# https://github.com/dotnet/roslyn/issues/41640\n\ndotnet_diagnostic.IDE0005.severity = warning\n\n# IDE0011: Add braces\ncsharp_prefer_braces = when_multiline:warning\n# NOTE: We need the below severity entry for Add Braces due to https://github.com/dotnet/roslyn/issues/44201\ndotnet_diagnostic.IDE0011.severity = warning\n\n# IDE0040: Add accessibility modifiers\ndotnet_diagnostic.IDE0040.severity = warning\n\n# CONSIDER: Are IDE0051 and IDE0052 too noisy to be warnings for IDE editing scenarios?\n# Should they be made build-only warnings?\n# IDE0051: Remove unused private member\ndotnet_diagnostic.IDE0051.severity = warning\n\n# IDE0052: Remove unread private member\ndotnet_diagnostic.IDE0052.severity = warning\n\n# IDE0059: Unnecessary assignment to a value\ndotnet_diagnostic.IDE0059.severity = warning\n\n# IDE0060: Remove unused parameter\ndotnet_diagnostic.IDE0060.severity = warning\n\n# CA1822: Make member static\ndotnet_diagnostic.CA1822.severity = warning\n\n# Prefer \"var\" everywhere\ndotnet_diagnostic.IDE0007.severity = warning\ncsharp_style_var_for_built_in_types = true:warning\ncsharp_style_var_when_type_is_apparent = true:warning\ncsharp_style_var_elsewhere = true:warning\n\n[src/{VisualStudio}/**/*.cs]\n# CA1822: Make member static\n# Not enforced as a build 'warning' for 'VisualStudio' layer due to large number\n# of false positives from https://github.com/dotnet/roslyn-analyzers/issues/3857\n# and https://github.com/dotnet/roslyn-analyzers/issues/3858\n# Additionally, there is a risk of accidentally breaking an internal API that\n# partners rely on though IVT.\ndotnet_diagnostic.CA1822.severity = suggestion\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.4716796875,
          "content": "# Auto detect text files and perform LF normalization\n* text=auto\n\n# Custom for Visual Studio\n*.cs     diff=csharp\n*.sln    merge=union\n*.csproj merge=union\n*.vbproj merge=union\n*.fsproj merge=union\n*.dbproj merge=union\n\n# Standard to msysgit\n*.doc\t diff=astextplain\n*.DOC\t diff=astextplain\n*.docx diff=astextplain\n*.DOCX diff=astextplain\n*.dot  diff=astextplain\n*.DOT  diff=astextplain\n*.pdf  diff=astextplain\n*.PDF\t diff=astextplain\n*.rtf\t diff=astextplain\n*.RTF\t diff=astextplain\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.978515625,
          "content": "\n#################\n## Eclipse\n#################\n\n*.pydevproject\n.project\n.metadata\nbin/\ntmp/\n*.tmp\n*.bak\n*.swp\n*~.nib\nlocal.properties\n.classpath\n.settings/\n.loadpath\n\n# External tool builders\n.externalToolBuilders/\n\n# Locally stored \"Eclipse launch configurations\"\n*.launch\n\n# CDT-specific\n.cproject\n\n# PDT-specific\n.buildpath\n\n\n#################\n## Visual Studio\n#################\n\n## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n\n# User-specific files\n*.suo\n*.user\n*.sln.docstates\n\n# Build results\n[Dd]ebug/\n[Rr]elease/\n*_i.c\n*_p.c\n*.ilk\n*.meta\n*.obj\n*.pch\n*.pdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.vspscc\n.builds\n*.dotCover\n\n.vs\n\npackages/\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opensdf\n*.sdf\n\n# Visual Studio profiler\n*.psess\n*.vsp\n\n# ReSharper is a .NET coding add-in\n_ReSharper*\n\n# Installshield output folder\n[Ee]xpress\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish\n\n# Others\n[Bb]in\n[Oo]bj\nsql\nTestResults\n*.Cache\nClientBin\nstylecop.*\n~$*\n*.dbmdl\nGenerated_Code #added for RIA/Silverlight projects\n\n# Backup & report files from converting an old project file to a newer\n# Visual Studio version. Backup files are not needed, because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\n\n\n\n############\n## Windows\n############\n\n# Windows image file caches\nThumbs.db\n\n# Folder config file\nDesktop.ini\n\n\n#############\n## Python\n#############\n\n*.py[co]\n\n# Packages\n*.egg\n*.egg-info\ndist\nbuild\neggs\nparts\nbin\nvar\nsdist\ndevelop-eggs\n.installed.cfg\n\n# Installer logs\npip-log.txt\n\n# Unit test / coverage reports\n.coverage\n.tox\n\n#Translations\n*.mo\n\n#Mr Developer\n.mr.developer.cfg\n\n# Mac crap\n.DS_Store\n\n#Resharper\n_ReSharper*\n\n#Stylecop\nStyleCop.Cache\n\n#Other\n*.vsmdi\n*.InstallLog\n\n# NUnit console output\nTestResult.xml\n"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "CODEOWNERS",
          "type": "blob",
          "size": 0.0244140625,
          "content": "* @davideicardi @metoule\n"
        },
        {
          "name": "DynamicExpresso.sln",
          "type": "blob",
          "size": 1.970703125,
          "content": "﻿\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio 15\nVisualStudioVersion = 15.0.27130.2010\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"DynamicExpresso.UnitTest\", \"test\\DynamicExpresso.UnitTest\\DynamicExpresso.UnitTest.csproj\", \"{33157A92-C6B2-4A51-8262-1FEBFD6558BE}\"\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"docs\", \"docs\", \"{4088369E-AB00-4333-A56A-27E05D3767B1}\"\n\tProjectSection(SolutionItems) = preProject\n\t\tREADME.md = README.md\n\tEndProjectSection\nEndProject\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"DynamicExpresso.Core\", \"src\\DynamicExpresso.Core\\DynamicExpresso.Core.csproj\", \"{C6B7C0D2-B84A-4307-9C61-D95613DB564D}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|Any CPU = Debug|Any CPU\n\t\tRelease|Any CPU = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{33157A92-C6B2-4A51-8262-1FEBFD6558BE}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{33157A92-C6B2-4A51-8262-1FEBFD6558BE}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{33157A92-C6B2-4A51-8262-1FEBFD6558BE}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{33157A92-C6B2-4A51-8262-1FEBFD6558BE}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{C6B7C0D2-B84A-4307-9C61-D95613DB564D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{C6B7C0D2-B84A-4307-9C61-D95613DB564D}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{C6B7C0D2-B84A-4307-9C61-D95613DB564D}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{C6B7C0D2-B84A-4307-9C61-D95613DB564D}.Release|Any CPU.Build.0 = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {A36C3463-448E-4051-AE87-A2994E36C1EC}\n\tEndGlobalSection\n\tGlobalSection(MonoDevelopProperties) = preSolution\n\t\tStartupItem = test\\DynamicExpresso.UnitTest\\DynamicExpresso.UnitTest.csproj\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "DynamicExpressoWebShell.sln",
          "type": "blob",
          "size": 1.623046875,
          "content": "﻿\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio 15\nVisualStudioVersion = 15.0.27004.2005\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"DynamicExpressoWebShell\", \"sample\\DynamicExpressoWebShell\\DynamicExpressoWebShell.csproj\", \"{970A9B0D-4DDF-4E8F-A184-89CC202DB542}\"\nEndProject\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"DynamicExpresso.Core\", \"src\\DynamicExpresso.Core\\DynamicExpresso.Core.csproj\", \"{B496A172-45A2-413A-9060-CDBE4142A8F2}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|Any CPU = Debug|Any CPU\n\t\tRelease|Any CPU = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{970A9B0D-4DDF-4E8F-A184-89CC202DB542}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{970A9B0D-4DDF-4E8F-A184-89CC202DB542}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{970A9B0D-4DDF-4E8F-A184-89CC202DB542}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{970A9B0D-4DDF-4E8F-A184-89CC202DB542}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{B496A172-45A2-413A-9060-CDBE4142A8F2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{B496A172-45A2-413A-9060-CDBE4142A8F2}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{B496A172-45A2-413A-9060-CDBE4142A8F2}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{B496A172-45A2-413A-9060-CDBE4142A8F2}.Release|Any CPU.Build.0 = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {A4275949-B3D5-4432-9D94-27F4EE8E5B90}\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.044921875,
          "content": "MIT License\n\nCopyright (c) 2018 Davide Icardi\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 21.380859375,
          "content": "# Dynamic Expresso\n\n[![NuGet version](https://badge.fury.io/nu/DynamicExpresso.Core.svg)](http://badge.fury.io/nu/DynamicExpresso.Core)\n[![.NET CI](https://github.com/dynamicexpresso/DynamicExpresso/actions/workflows/ci.yml/badge.svg)](https://github.com/dynamicexpresso/DynamicExpresso/actions/workflows/ci.yml)\n\nSupported platforms: .NET Core 3.1, .NET Core 5.0 and above, .NET 4.6.2\n\nDynamic Expresso is an interpreter for simple C# statements written in .NET Standard 2.0.\nDynamic Expresso embeds its own parsing logic, really interprets C# statements by converting it to .NET lambda expressions or delegates.\n\nUsing Dynamic Expresso developers can create scriptable applications, execute .NET code without compilation or create dynamic linq statements. \n\nStatements are written using a subset of C# language specifications. Global variables or parameters can be injected and used inside expressions. It doesn't generate assembly but it creates an expression tree on the fly. \n\n![dynamic expresso workflow](https://raw.github.com/dynamicexpresso/DynamicExpresso/master/docs/workflow.png \"dynamic expresso workflow\")\n\nFor example you can evaluate math expressions:\n```csharp\nvar interpreter = new Interpreter();\nvar result = interpreter.Eval(\"8 / 2 + 2\");\n```\nor parse an expression with variables or parameters and invoke it multiple times:\n```csharp\nvar interpreter = new Interpreter().SetVariable(\"service\", new ServiceExample());\nstring expression = \"x > 4 ? service.OneMethod() : service.AnotherMethod()\";\nLambda parsedExpression = interpreter.Parse(expression, new Parameter(\"x\", typeof(int)));\nvar result = parsedExpression.Invoke(5);\n```\nor generate delegates and lambda expressions for LINQ queries:\n```csharp\nvar prices = new [] { 5, 8, 6, 2 };\nvar whereFunction = new Interpreter().ParseAsDelegate<Func<int, bool>>(\"arg > 5\");\nvar count = prices.Where(whereFunction).Count();\n```\n## Live demo\nDynamic Expresso live demo: [http://dynamic-expresso.azurewebsites.net/](http://dynamic-expresso.azurewebsites.net/)\n\n## Quick start\nDynamic Expresso is available on [NuGet]. You can install the package using:\n\n\tPM> Install-Package DynamicExpresso.Core\n\nSource code and symbols (.pdb files) for debugging are available on [Symbol Source].\n\n## Features\n- Expressions can be written using a subset of C# syntax (see Syntax section for more information)\n- Support for variables and parameters\n- Can generate delegates or lambda expression\n- Full suite of unit tests\n- Good performance compared to other similar projects\n- Partial support of generic, params array and extension methods (only with implicit generic arguments detection)\n- Partial support of `dynamic` (`ExpandoObject` for get properties, method invocation and indexes(#142), see #72. `DynamicObject` for get properties and indexes, see #142)\n- Partial support of lambda expressions (disabled by default, because it has a slight performance penalty)\n- Case insensitive expressions (default is case sensitive)\n- Ability to discover identifiers (variables, types, parameters) of a given expression\n- Small footprint, generated expressions are managed classes, can be unloaded and can be executed in a single appdomain\n- Easy to use and deploy, it is all contained in a single assembly without other external dependencies\n- Written in .NET Standard 2.0\n\t- Build available for .NET 4.6.1 and .NET Core 2.0\n- Open source (MIT license)\n\n### Return value\nYou can parse and execute void expression (without a return value) or you can return any valid .NET type. \nWhen parsing an expression you can specify the expected expression return type. For example you can write:\n```csharp\nvar target = new Interpreter();\ndouble result = target.Eval<double>(\"Math.Pow(x, y) + 5\",\n\t\t\t\t    new Parameter(\"x\", typeof(double), 10),\n\t\t\t\t    new Parameter(\"y\", typeof(double), 2));\n```\nThe built-in parser can also understand the return type of any given expression so you can check if the expression returns what you expect.\n\n### Variables\nVariables can be used inside expressions with `Interpreter.SetVariable` method:\n```csharp\nvar target = new Interpreter().SetVariable(\"myVar\", 23);\n\nAssert.AreEqual(23, target.Eval(\"myVar\"));\n```\nVariables can be primitive types or custom complex types (classes, structures, delegates, arrays, collections, ...).\n\nCustom functions can be passed with delegate variables using `Interpreter.SetFunction` method:\n```csharp\nFunc<double, double, double> pow = (x, y) => Math.Pow(x, y);\nvar target = new Interpreter().SetFunction(\"pow\", pow);\n\nAssert.AreEqual(9.0, target.Eval(\"pow(3, 2)\"));\n```\nCustom [Expression](http://msdn.microsoft.com/en-us/library/system.linq.expressions.expression.aspx) can be passed by using `Interpreter.SetExpression` method.\n\n\n### Parameters\nParsed expressions can accept one or more parameters:\n```csharp\nvar interpreter = new Interpreter();\n\nvar parameters = new[] {\n\tnew Parameter(\"x\", 23),\n\tnew Parameter(\"y\", 7)\n};\n\nAssert.AreEqual(30, interpreter.Eval(\"x + y\", parameters));\n```\nParameters can be primitive types or custom types. You can parse an expression once and invoke it multiple times with different parameter values:\n```csharp\nvar target = new Interpreter();\n\nvar parameters = new[] {\n\tnew Parameter(\"x\", typeof(int)),\n\tnew Parameter(\"y\", typeof(int))\n};\n\nvar myFunc = target.Parse(\"x + y\", parameters);\n\nAssert.AreEqual(30, myFunc.Invoke(23, 7));\nAssert.AreEqual(30, myFunc.Invoke(32, -2));\n```\n\n### Special identifiers\n\nEither a variable or a parameter with name `this` can be referenced implicitly.\n\n```csharp\nclass Customer { public string Name { get; set; } }\n\nvar target = new Interpreter();\n\n// 'this' is treated as a special identifier and can be accessed implicitly \ntarget.SetVariable(\"this\", new Customer { Name = \"John\" });\n\n// explicit context reference via 'this' variable\nAssert.AreEqual(\"John\", target.Eval(\"this.Name\"));\n\n// 'this' variable is referenced implicitly\nAssert.AreEqual(\"John\", target.Eval(\"Name\"));\n```\n\n### Built-in types and custom types\nCurrently predefined types available are:\n\n\tObject object \n\tBoolean bool \n\tChar char\n\tString string\n\tSByte Byte byte\n\tInt16 UInt16 Int32 int UInt32 Int64 long UInt64 \n\tSingle Double double Decimal decimal \n\tDateTime TimeSpan\n\tGuid\n\tMath Convert\n\nYou can reference any other custom .NET type by using `Interpreter.Reference` method:\n```csharp\nvar target = new Interpreter().Reference(typeof(Uri));\n\nAssert.AreEqual(typeof(Uri), target.Eval(\"typeof(Uri)\"));\nAssert.AreEqual(Uri.UriSchemeHttp, target.Eval(\"Uri.UriSchemeHttp\"));\n```\n\n### Generate dynamic delegates\nYou can use the `Interpreter.ParseAsDelegate<TDelegate>` method to directly parse an expression into a .NET delegate type that can be normally invoked. \nIn the example below I generate a `Func<Customer, bool>` delegate that can be used in a LINQ where expression.\n```csharp\nclass Customer\n{\n\tpublic string Name { get; set; }\n\tpublic int Age { get; set; }\n\tpublic char Gender { get; set; }\n}\n\n[Test]\npublic void Linq_Where()\n{\n\tvar customers = new List<Customer> {\n\t\tnew Customer() { Name = \"David\", Age = 31, Gender = 'M' },\n\t\tnew Customer() { Name = \"Mary\", Age = 29, Gender = 'F' },\n\t\tnew Customer() { Name = \"Jack\", Age = 2, Gender = 'M' },\n\t\tnew Customer() { Name = \"Marta\", Age = 1, Gender = 'F' },\n\t\tnew Customer() { Name = \"Moses\", Age = 120, Gender = 'M' },\n\t};\n\n\tstring whereExpression = \"customer.Age > 18 && customer.Gender == 'F'\";\n\n\tvar interpreter = new Interpreter();\n\tFunc<Customer, bool> dynamicWhere = interpreter.ParseAsDelegate<Func<Customer, bool>>(whereExpression, \"customer\");\n\n\tAssert.AreEqual(1, customers.Where(dynamicWhere).Count());\n}\n```\nThis is the preferred way to parse an expression that you known at compile time what parameters can accept and what value must return.\n\n### Generate lambda expressions\nYou can use the `Interpreter.ParseAsExpression<TDelegate>` method to directly parse an expression into a .NET lambda expression (`Expression<TDelegate>`). \n\nIn the example below I generate a `Expression<Func<Customer, bool>>` expression that can be used in a Queryable LINQ where expression or in any other place where an expression is required. Like Entity Framework or other similar libraries.\n```csharp\nclass Customer\n{\n\tpublic string Name { get; set; }\n\tpublic int Age { get; set; }\n\tpublic char Gender { get; set; }\n}\n\n[Test]\npublic void Linq_Queryable_Expression_Where()\n{\n\tIQueryable<Customer> customers = (new List<Customer> {\n\t\tnew Customer() { Name = \"David\", Age = 31, Gender = 'M' },\n\t\tnew Customer() { Name = \"Mary\", Age = 29, Gender = 'F' },\n\t\tnew Customer() { Name = \"Jack\", Age = 2, Gender = 'M' },\n\t\tnew Customer() { Name = \"Marta\", Age = 1, Gender = 'F' },\n\t\tnew Customer() { Name = \"Moses\", Age = 120, Gender = 'M' },\n\t}).AsQueryable();\n\n\tstring whereExpression = \"customer.Age > 18 && customer.Gender == 'F'\";\n\n\tvar interpreter = new Interpreter();\n\tExpression<Func<Customer, bool>> expression = interpreter.ParseAsExpression<Func<Customer, bool>>(whereExpression, \"customer\");\n\n\tAssert.AreEqual(1, customers.Where(expression).Count());\n}\n```\n\n## Syntax and operators\nStatements can be written using a subset of the C# syntax. Here you can find a list of the supported expressions: \n\n### Operators\n\nSupported operators:\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>Category</th><th>Operators</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>Primary</td><td><code>x.y  f(x)  a[x]  new  typeof</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Unary</td><td><code>+  -  !  (T)x</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Multiplicative</td><td><code>*  /  %</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Additive</td><td><code>+  -</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Relational and type testing</td><td><code>&lt;  &gt;  &lt;=  &gt;=  is  as</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Equality</td><td><code>==  !=</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Logical AND</td><td><code>&</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Logical OR</td><td><code>|</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Logical XOR</td><td><code>^</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Conditional AND</td><td><code>&&</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Conditional OR</td><td><code>||</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Conditional</td><td><code>?:</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Assignment</td><td><code>=</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Null coalescing</td><td><code>??</code></td>\n\t\t</tr>\n\t</tbody>\n</table>\n\nOperators precedence is respected following [C# rules (Operator precedence and associativity)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/).\n\nSome operators, like the assignment operator, can be disabled for security reason.\n\n### Literals\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>Category</th><th>Operators</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>Constants</td><td><code>true  false  null</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Real literal suffixes</td><td><code>d  f  m</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Integer literal suffixes</td><td><code>u l ul lu</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>String/char</td><td><code>\"\"  ''</code></td>\n\t\t</tr>\n\t</tbody>\n</table>\n\nThe following character escape sequences are supported inside string or char literals:\n\n- `\\'` - single quote, needed for character literals\n- `\\\"` - double quote, needed for string literals\n- `\\\\` - backslash\n- `\\0` - Unicode character 0\n- `\\a` - Alert (character 7)\n- `\\b` - Backspace (character 8)\n- `\\f` - Form feed (character 12)\n- `\\n` - New line (character 10)\n- `\\r` - Carriage return (character 13)\n- `\\t` - Horizontal tab (character 9)\n- `\\v` - Vertical quote (character 11)\n\n### Type's members invocation\n\nAny standard .NET method, field, property or constructor can be invoked.\n```csharp\nvar service = new MyTestService();\nvar context = new MyTestContext();\n\nvar target = new Interpreter()\n  .SetVariable(\"x\", service)\n  .SetVariable(\"this\", context);\n\nAssert.AreEqual(service.HelloWorld(), target.Eval(\"x.HelloWorld()\"));\nAssert.AreEqual(service.AProperty, target.Eval(\"x.AProperty\"));\nAssert.AreEqual(service.AField, target.Eval(\"x.AField\"));\n\n// implicit context reference\nAssert.AreEqual(context.GetContextId(), target.Eval(\"GetContextId()\"));\nAssert.AreEqual(context.ContextName, target.Eval(\"ContextName\"));\nAssert.AreEqual(context.ContextField, target.Eval(\"ContextField\"));\n```\n```csharp\nvar target = new Interpreter();\nAssert.AreEqual(new DateTime(2015, 1, 24), target.Eval(\"new DateTime(2015, 1, 24)\"));\n```\nDynamic Expresso also supports:\n\n- Extension methods\n```csharp\nvar x = new int[] { 10, 30, 4 };\nvar target = new Interpreter()\n\t.Reference(typeof(System.Linq.Enumerable))\n\t.SetVariable(\"x\", x);\nAssert.AreEqual(x.Count(), target.Eval(\"x.Count()\"));\n```\n- Indexer methods (like `array[0]`)\n- Generics, only partially supported (only implicit, you cannot invoke an explicit generic method)\n- Params array (see C# `params` keyword)\n\n### Lambda expressions\nDynamic Expresso has partial supports of lambda expressions. For example, you can use any Linq method:\n\n```csharp\nvar x = new string[] { \"this\", \"is\", \"awesome\" };\nvar options = InterpreterOptions.Default | InterpreterOptions.LambdaExpressions; // enable lambda expressions\nvar target = new Interpreter(options)\n\t.SetVariable(\"x\", x);\n\nvar results = target.Eval<IEnumerable<string>>(\"x.Where(str => str.Length > 5).Select(str => str.ToUpper())\");\nAssert.AreEqual(new[] { \"AWESOME\" }, results);\n```\n\nNote that parsing lambda expressions is disabled by default, because it has a slight performance cost.\nTo enable them, you must set the `InterpreterOptions.LambdaExpressions` flag.\n\nIt's also possible to create a delegate directly from a lambda expression:\n\n```csharp\nvar options = InterpreterOptions.Default | InterpreterOptions.LambdaExpressions; // enable lambda expressions\nvar target = new Interpreter(options)\n\t.SetVariable(\"increment\", 3); // access a variable from the lambda expression\n\nvar myFunc = target.Eval<Func<int, string, string>>(\"(i, str) => str.ToUpper() + (i + increment)\");\nAssert.AreEqual(\"TEST8\", lambda.Invoke(5, \"test\"));\n```\n\n### Case sensitive/insensitive\nBy default all expressions are considered case sensitive (`VARX` is different than `varx`, as in C#).\nThere is an option to use a case insensitive parser. For example:\n```csharp\nvar target = new Interpreter(InterpreterOptions.DefaultCaseInsensitive);\n\ndouble x = 2;\nvar parameters = new[] {\n\tnew Parameter(\"x\", x.GetType(), x)\n};\n\nAssert.AreEqual(x, target.Eval(\"x\", parameters));\nAssert.AreEqual(x, target.Eval(\"X\", parameters));\n```\n\n\n\n## Identifiers detection\nSometimes you need to check which identifiers (variables, types, parameters) are used in expression before parsing it.\nMaybe because you want to validate it or you want to ask the user to enter parameters value of a given expression.\nBecause if you parse an expression without the right parameter an exception is throwed.\n\nIn these cases you can use `Interpreter.DetectIdentifiers` method to obtain a list of used identifiers, both known and unknown.\n```csharp\nvar target = new Interpreter();\n\nvar detectedIdentifiers = target.DetectIdentifiers(\"x + y\");\n\nCollectionAssert.AreEqual(new[] { \"x\", \"y\" }, \n\t\t\t  detectedIdentifiers.UnknownIdentifiers.ToArray());\n```\n\n## Default number type\nIn C #, numbers are usually interpreted as integers or doubles if they have decimal places.\n\nIn some cases it may be useful to be able to configure the default type of numbers if no particular suffix is ​​specified: for example in financial calculations, where usually numbers are interpreted as decimal type.\n\nIn these cases you can set the default number type using `Interpreter.SetDefaultNumberType`  method.\n\n```csharp\nvar target = new Interpreter();\n\ntarget.SetDefaultNumberType(DefaultNumberType.Decimal);\n\nAssert.IsInstanceOf(typeof(System.Decimal), target.Eval(\"45\"));\nAssert.AreEqual(10M/3M, target.Eval(\"10/3\")); // 3.33333333333 instead of 3\n```\n\n## Limitations\nNot every C# syntaxes are supported. Here some examples of NOT supported features:\n\n- Multiline expressions\n- for/foreach/while/do operators\n- Array/list/dictionary initialization\n- Explicit generic invocation (like `method<type>(arg)`) \n- Lambda/delegate declaration (delegate and lamda are only supported as variables or parameters or as a return type of the expression)\n- Array/list/dictionary element assignment (set indexer operator)\n- Other operations on `dynamic` objects (only property, method invocation and index now are supported)\n\n## Exceptions\nIf there is an error during the parsing always an exception of type `ParseException` is throwed. \n`ParseException` has several specialization classes based on the type of error (UnknownIdentifierException, NoApplicableMethodException. ...).\n\n## Performance and multithreading\nThe `Interpreter` class can be used by multiple threads but without modify it.\nIn essence only get properties, `Parse` and `Eval` methods are thread safe. Other methods (`SetVariable`, `Reference`, ...) must be called in an initialization phase.\n`Lambda` and `Parameter` classes are completely thread safe.\n\nIf you need to run the same expression multiple times with different parameters I suggest to parse it one time and then invoke the parsed expression multiple times.\n\n## Security\nIf you allow an end user to write expression you must consider some security implications.\n\nParsed expressions can access only the .NET types that you have referenced using the `Interpreter.Reference` method or types that you pass as a variable or parameter. \nYou must pay attention of what types you expose.\nIn any case generated delegates are executed as any other delegate and standard security .NET rules can be applied (for more info see [Security in the .NET Framework](http://msdn.microsoft.com/en-us/library/fkytk30f.aspx)). \n\nIf expressions test can be written directly by users you must ensure that only certain features are available. Here some guidelines:\n\nFor example you can disable assignment operators, to ensure that the user cannot change some values that you don't expect. \nBy default assignment operators are enables, by you can disable it using:\n```csharp\nvar target = new Interpreter().EnableAssignment(AssignmentOperators.None);\n```\nFrom version 1.3 to prevent malicious users to call unexpected types or assemblies within an expression, \nsome reflection methods are blocked. For example you cannot write:\n```csharp\nvar target = new Interpreter();\ntarget.Eval(\"typeof(double).GetMethods()\");\n// or\ntarget.Eval(\"typeof(double).Assembly\");\n```\nThe only exception to this rule is the `Type.Name` property that is permitted for debugging reasons.\n To enable standard reflection features you can use `Interpreter.EnableReflection` method, like:\n```csharp\nvar target = new Interpreter().EnableReflection();\n```\n\n## Usage scenarios\nHere are some possible usage scenarios of Dynamic Expresso:\n\n- Programmable applications\n- Allow the user to inject customizable rules and logic without recompiling\n- Evaluate dynamic functions or commands\n- LINQ dynamic query\n\n## Future roadmap\n\nSee [github open issues and milestones](https://github.com/dynamicexpresso/DynamicExpresso/issues).\n\n## Help and support\n\nIf you need help you can try one of the following:\n\n- [FAQ](https://github.com/dynamicexpresso/DynamicExpresso/wiki/FAQ) wiki page\n- github [official repository](https://github.com/dynamicexpresso/DynamicExpresso)\n\n## Maintainers\n\nCurrently Dynamic Expresso is maintained by @davideicardi and @metoule.\n\n## Credits\n\nThis project is based on two old works:\n- \"Converting String expressions to Funcs with FunctionFactory by Matthew Abbott\" (link not more available) \n- DynamicQuery - Dynamic LINQ - Visual Studio 2008 sample: http://msdn.microsoft.com/en-us/vstudio/bb894665.aspx \n\nThanks to all [contributors](https://github.com/dynamicexpresso/DynamicExpresso/graphs/contributors)!\n\n## Other resources or similar projects\nBelow you can find a list of some similar projects that I have evaluated or that can be interesting to study. \nFor one reason or another none of these projects exactly fit my needs so I decided to write my own interpreter.\n\n- Roslyn Project - Scripting API - https://github.com/dotnet/roslyn/wiki/Scripting-API-Samples\n\t- This is the new Microsoft Official Compiler as a service library. I suggest to consider using Roslyin instead of DynamicExpresso for complex scenarios.\n- Mono.CSharp - C# Compiler Service and Runtime Evaulator - http://docs.go-mono.com/index.aspx?link=N%3AMono.CSharp\n- NCalc - Mathematical Expressions Evaluator for .NET - http://ncalc.codeplex.com/\n- David Wynne CSharpEval https://github.com/DavidWynne/CSharpEval\n- CSharp Eval http://csharp-eval.com/\n- C# Expression Evaluator http://csharpeval.codeplex.com/\n- Jint - Javascript interpreter for .NET - http://jint.codeplex.com/\n- Jurassic - Javascript compiler for .NET - http://jurassic.codeplex.com/\n- Javascrpt.net - javascript V8 engine - http://javascriptdotnet.codeplex.com/\n- CS-Script - http://www.csscript.net/\n- IronJS, IronRuby, IronPython\n- paxScript.NET http://eco148-88394.innterhost.net/paxscriptnet/\n\n## Continuous Integration\n\nA continuous integration pipeline is configured using Github Actions, see `.github/workflows` folder.\n\nWhenever a new [Release](https://github.com/dynamicexpresso/DynamicExpresso/releases) is created, Nuget packages are published. For snapshot releases packages are published only to Github.\nFor official releases packages are published to both GitHub and Nuget.\n\n## Compiling and run tests\n\nTo compile the solution you can run:\n\n\tdotnet build DynamicExpresso.sln -c Release\n\nTo create nuget packages:\n\n\tdotnet pack DynamicExpresso.sln -c Release\n\nTo run unit tests:\n\n\tdotnet test DynamicExpresso.sln -c Release\n\nor run unit tests for a specific project with a specific framework:\n\n\tdotnet test DynamicExpresso.sln --no-restore -c Release --verbosity normal -f netcoreapp3.1\n\nAdd `--logger:trx` to generate test results for VSTS.\n\n## Release notes\n\nSee [releases page](https://github.com/dynamicexpresso/DynamicExpresso/releases).\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "sample",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}