{
  "metadata": {
    "timestamp": 1736711123424,
    "page": 961,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Cysharp/ZLogger",
      "stars": 1326,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 2.0615234375,
          "content": "# Build Folders (you can keep bin if you'd like, to store dlls and pdbs)\n[Bb]in/\n[Oo]bj/\n\n# mstest test results\nTestResults\n\n## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n\n# User-specific files\n*.suo\n*.user\n*.sln.docstates\n\n# Build results\n[Dd]ebug/\n[Rr]elease/\nx64/\n*_i.c\n*_p.c\n*.ilk\n*.obj\n*.pch\n*.pdb\n*.pgc\n*.pgd\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.log\n*.vspscc\n*.vssscc\n.builds\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opensdf\n*.sdf\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*\n\n# NCrunch\n*.ncrunch*\n.*crunch*.local.xml\n\n# Installshield output folder \n[Ee]xpress\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish\n\n# Publish Web Output\n*.Publish.xml\n\n# NuGet Packages Directory\npackages\n\n# Windows Azure Build Output\ncsx\n*.build.csdef\n\n# Windows Store app package directory\nAppPackages/\n\n# Others\n[Bb]in\n[Oo]bj\nsql\nTestResults\n[Tt]est[Rr]esult*\n*.Cache\nClientBin\n[Ss]tyle[Cc]op.*\n~$*\n*.dbmdl\nGenerated_Code #added for RIA/Silverlight projects\n\n# Backup & report files from converting an old project file to a newer\n# Visual Studio version. Backup files are not needed, because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\n.vs/config/applicationhost.config\n.vs/restore.dg\n\n# Unity\nsrc/MasterMemory.UnityClient/bin/*\nsrc/MasterMemory.UnityClient/Library/*\nsrc/MasterMemory.UnityClient/obj/*\nsrc/MasterMemory.UnityClient/Temp/*\n\n# OTHER\nnuget/tools/*\n*.nupkg\n.vs\n.idea\n\n# Unity\nLibrary/\nTemp/\ntools/CommandTools/Properties/launchSettings.json\n\nsrc/ZLogger.Unity/Assembly-CSharp-Editor.csproj\n\nsrc/ZLogger.Unity/Assembly-CSharp.csproj\n\nsrc/ZLogger.Unity/RuntimeUnitTestToolkit.csproj\n\nsrc/ZLogger.Unity/ZLogger.csproj\n\nsrc/ZLogger.Unity/ZLogger.Unity.sln\n\nsrc/ZLogger.Unity/ZString.csproj\n\nsrc/ZLogger.Unity/*.csproj\n\n.DS_Store\n"
        },
        {
          "name": "Directory.Build.props",
          "type": "blob",
          "size": 0.875,
          "content": "<Project>\n\n    <PropertyGroup>\n        <!-- NuGet Packaging -->\n        <PackageVersion>$(Version)</PackageVersion>\n        <Company>Cysharp</Company>\n        <Authors>Cysharp</Authors>\n        <Copyright>© Cysharp, Inc.</Copyright>\n        <PackageProjectUrl>https://github.com/Cysharp/ZLogger</PackageProjectUrl>\n        <RepositoryUrl>$(PackageProjectUrl)</RepositoryUrl>\n        <RepositoryType>git</RepositoryType>\n        <PackageLicenseExpression>MIT</PackageLicenseExpression>\n        <PackageIcon>Icon.png</PackageIcon>\n        <SignAssembly>true</SignAssembly>\n        <AssemblyOriginatorKeyFile>../../opensource.snk</AssemblyOriginatorKeyFile>\n        <!-- For BenchmarkDotNet generated project-->\n        <AssemblyOriginatorKeyFile Condition=\"EXISTS('./../../../../../../opensource.snk')\">../../../../../../opensource.snk</AssemblyOriginatorKeyFile>\n    </PropertyGroup>\n\n</Project>\n"
        },
        {
          "name": "Icon.png",
          "type": "blob",
          "size": 3.1103515625,
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.044921875,
          "content": "MIT License\n\nCopyright (c) 2020 Cysharp, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 41.7666015625,
          "content": "ZLogger\n===\n[![GitHub Actions](https://github.com/Cysharp/ZLogger/workflows/Build-Debug/badge.svg)](https://github.com/Cysharp/ZLogger/actions) [![Releases](https://img.shields.io/github/release/Cysharp/ZLogger.svg)](https://github.com/Cysharp/ZLogger/releases)\n\n**Z**ero Allocation Text/Structured **Logger** for .NET and Unity, with StringInterpolation and Source Generator, built on top of a `Microsoft.Extensions.Logging`.\n\nThe usual destinations for log output are `Console(Stream)`, `File(Stream)`, `Network(Stream)`, all in UTF8 format. However, since typical logging architectures are based on Strings (UTF16), this requires additional encoding costs. In ZLogger, we utilize the [String Interpolation Improvement of C# 10](https://devblogs.microsoft.com/dotnet/string-interpolation-in-c-10-and-net-6/) and by leveraging .NET 8's [IUtf8SpanFormattable](https://learn.microsoft.com/en-us/dotnet/api/system.iutf8spanformattable?view=net-8.0), we have managed to avoid the boxing of values and maintain high performance by consistently outputting directly in UTF8 from input to output.\n\nZLogger is built directly on top of `Microsoft.Extensions.Logging`. `Microsoft.Extensions.Logging` is an official log abstraction used in many frameworks, such as ASP.NET Core and Generic Host. However, since regular loggers have their own systems, a bridge is required to connect these systems, and this is where a lot of overhead can be observed. ZLogger eliminates the need for this bridge, thereby completely avoiding overhead.\n\n![Alt text](docs/image.png)\n\nThis benchmark is for writing to a file, but the default settings of typical loggers are very slow. This is because they flush after every write. In the benchmark, to ensure fairness, careful attention was paid to set the options in each logger for maximum speed. ZLogger is designed to be the fastest by default, so there is no need to worry about any settings.\n\nThe slowness of this default setting is due to I/O, so it can be mitigated by using a faster drive. When taking benchmarks, please note that the results can vary greatly not only on your local (which is probably fast!) but also on drives attached to the cloud and in environments like Docker. One of the good points about the async-buffered setting is that it can reduce the impact of such I/O issues.\n\nZLogger focuses on the new syntax of C#, and fully adopts Interpolated Strings.\n\n![Alt text](docs/image-1.png)\n\nThis allows for providing parameters to logs in the most convenient form. Also, by closely integrating with System.Text.Json's Utf8JsonWriter, it not only enables high-performance output of text logs but also makes it possible to efficiently output structured logs.\n\nZLogger also emphasizes console output, which is crucial in cloud-native applications. By default, it outputs with performance that can withstand destinations in cloud log management. Of course, it supports both text logs and structured logs.\n\nZLogger delivers its best performance with .NET 8 and above, but it is designed to maintain consistent performance with .NET Standard 2.0 and .NET 6 through a fallback to its own IUtf8SpanFormattable.\n\nAs for standard logger features, it supports loading LogLevel from json, filtering by category, and scopes, as found in Microsoft.Extensions.Logging. In terms of output destinations, it is equipped with sufficient capabilities for `Console`, `File`, `RollingFile`, `InMemory`, `Stream`, and an `AsyncBatchingProcessor` for sending logs over HTTP and similar protocols.\n\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n## Table of Contents\n\n- [Getting Started](#getting-started)\n- [Logging Providers](#logging-providers)\n  - [Console](#console)\n  - [File](#file)\n  - [RollingFile](#rollingfile)\n  - [Stream](#stream)\n  - [In-Memory](#in-memory)\n  - [LogProcessor](#logprocessor)\n- [Formatter Configurations](#formatter-configurations)\n  - [PlainText](#plaintext)\n  - [JSON](#json)\n    - [KeyNameMutator](#keynamemutator)\n  - [MessagePack](#messagepack)\n  - [Custom Formatter](#custom-formatter)\n- [LogInfo](#loginfo)\n- [ZLoggerOptions](#zloggeroptions)\n- [ZLoggerMessage Source Generator](#zloggermessage-source-generator)\n- [Microsoft.CodeAnalysis.BannedApiAnalyzers](#microsoftcodeanalysisbannedapianalyzers)\n- [Global LoggerFactory](#global-loggerfactory)\n- [Unity](#unity)\n  - [Installation](#installation)\n  - [Basic usage](#basic-usage)\n- [License](#license)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\nGetting Started\n---\nThis library is distributed via NuGet, supporting `.NET Standard 2.0`, `.NET Standard 2.1`, `.NET 6(.NET 7)` and `.NET 8` or above. \nFor Unity, the requirements and installation process are completely different. See the [Unity](#unity) section for details.\n\n> dotnet add package [ZLogger](https://www.nuget.org/packages/ZLogger)\n\nHere is the most simple sample on ASP.NET Core.\n\n```csharp\nusing ZLogger;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Logging.ClearProviders();\nbuilder.Logging.AddZLoggerConsole();\n```\n\nYou can get logger from dependency injection.\n\n```csharp\n@page\n@using ZLogger;\n@inject ILogger<Index> logger\n@{\n    logger.ZLogInformation($\"Requested path: {this.HttpContext.Request.Path}\");\n}\n```\n\nThis simple logger setup is possible because it is integrated with `Microsoft.Extensions.Logging` by default. For reference, here's how you would set it up using [LoggerFactory](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging):\n\n```csharp\nusing Microsoft.Extensions.Logging;\nusing ZLogger;\n\nusing var factory = LoggerFactory.Create(logging =>\n{\n    logging.SetMinimumLevel(LogLevel.Trace);\n\n    // Add ZLogger provider to ILoggingBuilder\n    logging.AddZLoggerConsole();\n    \n    // Output Structured Logging, setup options\n    // logging.AddZLoggerConsole(options => options.UseJsonFormatter());\n});\n\nvar logger = factory.CreateLogger(\"Program\");\n\nvar name = \"John\";\nvar age = 33;\n\n// Use **Z**Log method and string interpolation to log message\nlogger.ZLogInformation($\"Hello my name is {name}, {age} years old.\");\n```\n\nNormally, you don't create LoggerFactory yourself. Instead, you set up a Generic Host and receive ILogger through dependency injection (DI). You can setup logger by [.NET Generic Host](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-8.0)(for ASP.NET Core) and if you want to use this in ConsoleApplication, we provides [ConsoleAppFramework](https://github.com/Cysharp/ConsoleAppFramework) to use hosting abstraction.\n\nHere is the showcase of providers.\n\n```csharp\nusing ZLogger;\n\nvar builder = Host.CreateApplicationBuilder();\n\nbuilder.Logging\n    // optional(MS.E.Logging):clear default providers(recommend to remove all)\n    .ClearProviders()\n\n    // optional(MS.E.Logging):setup minimum log level\n    .SetMinimumLevel(LogLevel.Trace)\n    \n    // Add to output to console\n    .AddZLoggerConsole();\n\n    // Add to output to the file\n    .AddZLoggerFile(\"/path/to/file.log\")\n    \n    // Add to output the file that rotates at constant intervals.\n    .AddZLoggerRollingFile(options =>\n    {\n        // File name determined by parameters to be rotated\n        options.FilePathSelector = (timestamp, sequenceNumber) => $\"logs/{timestamp.ToLocalTime():yyyy-MM-dd}_{sequenceNumber:000}.log\";\n        \n        // The period of time for which you want to rotate files at time intervals.\n        options.RollingInterval = RollingInterval.Day;\n        \n        // Limit of size if you want to rotate by file size. (KB)\n        options.RollingSizeKB = 1024;        \n    })    \n    \n    // Add to output of simple rendered strings into memory. You can subscribe to this and use it.\n    .AddZLoggerInMemory(processor =>\n    {\n        processor.MessageReceived += renderedLogString => \n        {\n            System.Console.WriteLine(renderedLogString);    \n        };\n    })\n    \n    // Add output to any steram (`System.IO.Stream`)\n    .AddZLoggerStream(stream);\n\n    // Add custom output\n    .AddZLoggerLogProcessor(new YourCustomLogExporter());\n    \n    // Format as json\n    .AddZLoggerConsole(options =>\n    {\n        options.UseJsonFormatter();\n    })\n    \n    // Format as json and configure output\n    .AddZLoggerConsole(options =>\n    {\n        options.UseJsonFormatter(formatter =>\n        {\n            formatter.IncludeProperties = IncludeProperties.ParameterKeyValues;\n        });\n    })\n\n    // Further common settings\n    .AddZLoggerConsole(options =>\n    {\n        // Enable LoggerExtensions.BeginScope\n        options.IncludeScopes = true;\n        \n        // Set TimeProvider\n        options.TimeProvider = yourTimeProvider\n    });\n```\n\nLook at the use of loggers and the syntax of ZLog.\n\n```cs\nusing Microsoft.Extensions.Logging;\nusing ZLogger;\n\n// get ILogger<T> from DI.\npublic class MyClass(ILogger<MyClass> logger)\n{\n    // name = \"Bill\", city = \"Kumamoto\", age = 21\n    public void Foo(string name, string city, int age)\n    {\n        // plain-text:\n        // Hello, Bill lives in Kumamoto 21 years old.\n        // json:\n        // {\"Timestamp\":\"2023-11-30T17:28:35.869211+09:00\",\"LogLevel\":\"Information\",\"Category\":\"MyClass\",\"Message\":\"Hello, Bill lives in Kumamoto 21 years old.\",\"name\":\"Bill\",\"city\":\"Kumamoto\",\"age\":21}\n        // json(IncludeProperties.ParameterKeyValues):\n        // {\"name\":\"Bill\",\"city\":\"Kumamoto\",\"age\":21}\n        logger.ZLogInformation($\"Hello, {name} lives in {city} {age} years old.\");\n    \n        // Explicit property name, you can use custom format string start with '@'\n        logger.ZLogInformation($\"Hello, {name:@user-name} id:{100:@id} {age} years old.\");\n    \n        // Dump variables as JSON, you can use custom format string `json`\n        var user = new User(1, \"Alice\");\n\n        // user: {\"Id\":1,\"Name\":\"Bob\"}\n        logger.ZLogInformation($\"user: {user:json}\");\n    }\n}\n```\n\nAll standard `.Log` methods are processed as strings by ZLogger's Provider. However, by using our unique `.ZLog*` methods, you can process them at high performance while remaining in UTF8. Additionally, these methods support both text logs and structured logs using String Interpolation syntax.\n\nAll logging methods are completely similar as [Microsoft.Extensions.Logging.LoggerExtensions](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerextensions), but it has **Z** prefix overload.\n\nThe ZLog* method uses [InterpolatedStringHandler](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/interpolated-string-handler) in .NET and prepare the template at compile time.\n\nSome special custom formats are also supported. The `:@` can be used when you want to explicitly give the structured log a name other than the name of the variable to capture. `:json` can be used to log the result of JsonSerializing an object.\n\nThe `@` parameter name specification and format string can be used together.\n\n```csharp\n// Today is 2023-12-19.\n// {\"date\":\"2023-12-19T11:25:34.3642389+09:00\"}\nlogger.ZLogDebug($\"Today is {DateTime.Now:@date:yyyy-MM-dd}.\");\n```\n\nLogging Providers\n---\nBy adding Providers, you can configure where the logs are output. ZLogger has the following providers.\n\n| Type                                   | Alias               | Builder Extension      |\n|----------------------------------------|---------------------|------------------------|\n| ZLoggerConsoleLoggerProvider           | ZLoggerConsole      | AddZLoggerConsole      |\n| ZLoggerFileLoggerProvider              | ZLoggerFile         | AddZLoggerFile         |\n| ZLoggerRollingFileLoggerProvider       | ZLoggerRollingFile  | AddZLoggerRollingFile  |\n| ZLoggerStreamLoggerProvider            | ZLoggerStream       | AddZLoggerStream       |\n| ZLoggerInMemoryProcessorLoggerProvider | ZLoggerInMemory     | AddZLoggerInMemory     |\n| ZLoggerLogProcessorLoggerProvider      | ZLoggerLogProcessor | AddZLoggerLogProcessor |\n\nAll Providers can take an Action that sets `ZLoggerOptions` as the last argument. As follows.\n\n```cs\nbuilder.Logging\n    .ClearProviders()\n\n    // Configure options\n    .AddZLoggerConsole(options => \n    {\n        options.LogToStandardErrorThreshold = LogLevel.Error;\n    });\n    \n    // Configure options with service provider\n    .AddZLoggerConsole((options, services) => \n    {\n        options.TimeProvider = services.GetService<YourCustomTimeProvider>();\n    });\n```\n\nIf you are using `Microsoft.Extensions.Configuration`, you can set the log level through configuration. In this case, alias of Provider can be used.  for example:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\"\n    },\n    \"ZLoggerConsoleLoggerProvider\": {\n      \"LogLevel\": {\n        \"Default\": \"Debug\"\n      }\n    }\n  }\n}\n```\n\nEach Provider's behavior can be modified using the common `ZLoggerOptions`. For details, please refer to the [ZLoggerOptions](#zloggeroptions) section. Additionally, you can customize structured logging (JSON Logging) using the `UseFormatter` method within these options. For more information on this, check the [Formatter Configurations](#formatter-configurations) section.\n\n### Console\n\nConsole writes to the standard output. Console output is not only for development purposes, but also serves as a standard log input port in containerized and cloud environments, making performance critically important. ZLogger has been optimized to maximize console output performance.\n\n```csharp\nlogging.AddZLoggerConsole();\n```\n\nIf you are using `ZLoggerConsoleLoggerProvider`, the following additional options are available:\n\n| Name                                    | Description                                                                                                                               |\n|:----------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------|\n| `bool OutputEncodingToUtf8`             | Set `Console.OutputEncoding = new UTF8Encoding(false)` when the provider is created.  (default: true)                                     |\n| `bool ConfigureEnableAnsiEscapeCode`    | If set true, then configure console option on execution and enable virtual terminal processing(enable ANSI escape code). (default: false) |\n| `LogLevel LogToStandardErrorThreshold`  | If set, logs at a higher level than the value will be output to standard error. (default: LogLevel.None)                                  |\n\n### File\n\nFile outputs text logs to a file. This is a Provider that writes to a single file in append mode at high speed.\n\n```csharp\nlogging.AddZLoggerFile(\"log.txt\");\n```\n\nIf you are using `ZLoggerFileLoggerProvider`, the following additional options are available:\n\n| Name                                                                              | Description                                                                                                        |\n|:----------------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------|\n| `bool fileShared`                                                                  | If set true, enables exclusive control of writing to the same file from multiple processes.(default: false) |\n\n### RollingFile\n\nRollingFile is a Provider that dynamically changes the output file based on certain conditions.\n\n```csharp\n// output to  yyyy-MM-dd_*.log, roll by 1MB or changed date\nlogging.AddZLoggerRollingFile((dt, index) => $\"{dt:yyyy-MM-dd}_{index}.log\", 1024 * 1024);\n```\n\nIf you are using `ZLoggerRollingFileLoggerProvider`, the following additional options are available:\n\n| Name                                                                              | Description                                                                                                        |\n|:----------------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------|\n| `Func<DateTimeOffset, int, string> fileNameSelector`                              | The Func to consturct the file path. `DateTimeOffset` is date of file open time(UTC), `int` is number sequence.        |\n| `RollingInterval rollInterval`                                                    | Interval to automatically rotate files.                                                                            |\n| `int rollSizeKB`                                                                  | Limit size of single file.  If the file size is exceeded, a new file is created with the sequence number moved up. |\n| `bool fileShared`                                                                  | If set true, enables exclusive control of writing to the same file from multiple processes.(default: false) |\n\n\n### Stream\n\nStream can output logs to any arbitrary Stream. For example, if you output to a MemoryStream, you can retrieve the rendered results in memory. If you pass a NetworkStream such as TCP, it will write logs over the network.\n\n```csharp\nvar ms = new MemoryStream();\nlogging.AddZLoggerStream(ms);\n```\n\n### In-Memory\n\nInMemory allows you to retrieve rendered strings as they are generated. It can be conveniently used for purposes such as accumulating logs in a `List<string>` or `Queue<string>` for display on screen.\n\n```csharp\nlogging.AddZLoggerInMemory(processor =>\n{\n    processor.MessageReceived += msg =>\n    {\n        Console.WriteLine($\"Received:{msg}\");\n    };\n});\n```\n\nIf you are using `ZLoggerInMemoryLoggerProvider`, the following additional options are available:\n\n| Name                                                                                                            | Description |\n|:----------------------------------------------------------------------------------------------------------------|:------------|\n| `string processorKey`                                                                                           |  If specified, `InMemoryObservableLogProcessor` is registered in the DI container as a keyed service and can be retrieved by name.           |\n| `Action<InMemoryObservableLogProcessor> configureProcessor`                                                     |  Custom actions can be added that use processors instead of DI containers.           |\n\n### LogProcessor\n\nLogProcessor is the most primitive Provider that allows you to customize output on a per-log basis (`IZLoggerEntry`) by implementing a custom `IAsyncLogProcessor`.\n\n```csharp\npublic interface IAsyncLogProcessor : IAsyncDisposable\n{\n    void Post(IZLoggerEntry log);\n}\n```\n\nFor example, a LogProcessor that propagates logs as string events can be written as follows:\n\n```csharp\npublic class SimpleInMemoryLogProcessor : IAsyncLogProcessor\n{\n    public event Action<string>? OnMessageReceived;\n\n    public void Post(IZLoggerEntry log)\n    {\n        var msg = log.ToString();\n        log.Return();\n        \n        OnMessageReceived?.Invoke(msg);\n    }\n\n    public ValueTask DisposeAsync()\n    {\n        return default;\n    }\n}\n```\n\n```csharp\nvar processor = new SimpleInMemoryLogProcessor();\nprocessor.OnMessageReceived += msg => Console.WriteLine(msg);\n\nlogging.AddZLoggerLogProcessor(processor);\n```\n\nNote that `IZLoggerEntry` is pooled, so you must always call `Return()`.\n\nHere's a more complex example. `BatchingAsyncLogProcessor` can batch logs together, which is useful for scenarios like sending multiple log lines via HTTP in a single request.\n\n```csharp\npublic class BatchingHttpLogProcessor : BatchingAsyncLogProcessor\n{\n    HttpClient httpClient;\n    ArrayBufferWriter<byte> bufferWriter;\n    IZLoggerFormatter formatter;\n\n    public BatchingHttpLogProcessor(int batchSize, ZLoggerOptions options)\n        : base(batchSize, options)\n    {\n        httpClient = new HttpClient();\n        bufferWriter = new ArrayBufferWriter<byte>();\n        formatter = options.CreateFormatter();\n    }\n\n    protected override async ValueTask ProcessAsync(IReadOnlyList<INonReturnableZLoggerEntry> list)\n    {\n        foreach (var item in list)\n        {\n            item.FormatUtf8(bufferWriter, formatter);\n        }\n        \n        var byteArrayContent = new ByteArrayContent(bufferWriter.WrittenSpan.ToArray());\n        await httpClient.PostAsync(\"http://foo\", byteArrayContent).ConfigureAwait(false);\n\n        bufferWriter.Clear();\n    }\n\n    protected override ValueTask DisposeAsyncCore()\n    {\n        httpClient.Dispose();\n        return default;\n    }\n}\n```\n\nIn this case, the LogEntry is NonReturnable, so there's no need to call Return().\n\nFormatter Configurations\n----\n\nBoth PlainText and JSON can be customized in addition to the standard log formats.\n\n### PlainText\n\n```cs\nlogging.AddZLoggerConsole(options =>\n{\n    // Text format\n    // e.g) \"2023-12-01 16:41:55.775|Information|This is log message. (MyNamespace.MyApp)\n    options.UsePlainTextFormatter(formatter =>\n    {\n        formatter.SetPrefixFormatter($\"{0}|{1}|\", (in MessageTemplate template, in LogInfo info) => template.Format(info.Timestamp, info.LogLevel));\n        formatter.SetSuffixFormatter($\" ({0})\", (in MessageTemplate template, in LogInfo info) => template.Format(info.Category));\n        formatter.SetExceptionFormatter((writer, ex) => Utf8StringInterpolation.Utf8String.Format(writer, $\"{ex.Message}\"));\n    });\n});\n```\n\nYou can set Prefix and Suffix individually for text output. For performance reasons, the first argument is a special String Interpolation Template, which is formatted by the lambda expression in the second argument. For properties that can actually be retrieved with `LogInfo`, refer to [LogInfo](#loginfo). It is also possible to retrieve the log file path and line number from LogInfo.\n\nOnly LogLevel supports a special format specification. By passing `:short`, you can get a 3-character log level notation such as `TRC`, `DBG`, `INF`, `WRN`, `ERR`, `CRI`, `NON` (the length of the beginning matches, making it easier to read when opened in an editor). For Timestamp, there are `local | local-longdate | longdate`(local, local-longdate, longdate are same, there are alias), `utc | utc-longdate`, `datetime | local-datetime`, `utc-datetime`, `dateonly | local-dateonly`, `utc-dateonly`, `timeonly | local-timeonly`, `utc-timeonly`. Default is `local`.\n\n```csharp\nlogging.AddZLoggerConsole(options =>\n{\n    options.UsePlainTextFormatter(formatter =>\n    {\n        // 2023-12-19 02:46:14.289 [DBG]......\n        formatter.SetPrefixFormatter($\"{0:utc-longdate} [{1:short}]\", (template, info) => template.Format(info.Timestamp, info.LogLevel));\n    });\n});\n```\n\nSetExceptionFormatter allows you to customize the display when outputting exceptions. This can be easily converted to a string using `Utf8String.Format`.\n\n### JSON\n\nYou can flexibly change the JSON output format by modifying the JsonFormatter options. For example, if you set `IncludeProperties` to only `ParameterKeyValues`, you will get only the payload JSON. By default, the payload part is output directly without nesting, but if you set `PropertyKeyValuesObjectName`, you can output the payload JSON to a nested location. It is also possible to add values for arbitrary JSON Objects using `AdditionalFormatter`.\n\nThe following is an example of customization to conform to the [Google Cloud Logging format](https://cloud.google.com/logging/docs/structured-logging?hl=en). We have also changed standard key names such as Timestamp.\n\n```csharp\nusing System.Text.Json;\nusing ZLogger;\nusing ZLogger.Formatters;\n\nnamespace ConsoleApp;\n\nusing static IncludeProperties;\nusing static JsonEncodedText; // JsonEncodedText.Encode\n\npublic static class CloudLoggingExtensions\n{\n    // Cloud Logging Json Field\n    // https://cloud.google.com/logging/docs/structured-logging?hl=en\n    public static ZLoggerOptions UseCloudLoggingJsonFormat(this ZLoggerOptions options)\n    {\n        return options.UseJsonFormatter(formatter =>\n        {\n            // Category and ScopeValues is manually write in AdditionalFormatter at labels so remove from include properties.\n            formatter.IncludeProperties = Timestamp | LogLevel | Message | ParameterKeyValues;\n\n            formatter.JsonPropertyNames = JsonPropertyNames.Default with\n            {\n                LogLevel = Encode(\"severity\"),\n                LogLevelNone = Encode(\"DEFAULT\"),\n                LogLevelTrace = Encode(\"DEBUG\"),\n                LogLevelDebug = Encode(\"DEBUG\"),\n                LogLevelInformation = Encode(\"INFO\"),\n                LogLevelWarning = Encode(\"WARNING\"),\n                LogLevelError = Encode(\"ERROR\"),\n                LogLevelCritical = Encode(\"CRITICAL\"),\n\n                Message = Encode(\"message\"),\n                Timestamp = Encode(\"timestamp\"),\n            };\n\n            formatter.PropertyKeyValuesObjectName = Encode(\"jsonPayload\");\n\n            // cache JsonEncodedText outside of AdditionalFormatter\n            var labels = Encode(\"logging.googleapis.com/labels\");\n            var category = Encode(\"category\");\n            var eventId = Encode(\"eventId\");\n            var userId = Encode(\"userId\");\n\n            formatter.AdditionalFormatter = (Utf8JsonWriter writer, in LogInfo) =>\n            {\n                writer.WriteStartObject(labels);\n                writer.WriteString(category, logInfo.Category.JsonEncoded);\n                writer.WriteString(eventId, logInfo.EventId.Name);\n\n                if (logInfo.ScopeState != null && !logInfo.ScopeState.IsEmpty)\n                {\n                    foreach (var item in logInfo.ScopeState.Properties)\n                    {\n                        if (item.Key == \"userId\")\n                        {\n                            writer.WriteString(userId, item.Value!.ToString());\n                            break;\n                        }\n                    }\n                }\n                writer.WriteEndObject();\n            };\n        });\n    }\n}\n```\n\nThe list of properties is as follows.\n\n| Name                                                                | Description                                                                       |\n|:--------------------------------------------------------------------|:----------------------------------------------------------------------------------|\n| `JsonPropertyNames JsonPropertyNames`                               | Specify the name of each key in the output JSON                                   |\n| `IncludeProperties IncludeProperties`                               | Flags that can specify properties to be output. (default: `Timestamp, LogLevel, CategoryName, Message, Exception, ScopeKeyValues, ParameterKeyValues`) |\n| `JsonSerializerOptions JsonSerializerOptions`                       | The options of `System.Text.Json`                                                 |\n| `JsonLogInfoFormatter? AdditionalFormatter`                         | Action when rendering additional properties based on `LogInfo`.                   |\n| `JsonEncodedText? PropertyKeyValuesObjectName`                      | If set, the key/value properties is nested under the specified key name.          |\n| `IKeyNameMutator? KeyNameMutator`                                   | You can set the naming convention if you want to automatically convert key names. |\n| `bool UseUtcTimestamp`                                              | If true, timestamp is output in utc. (default: false)                             |\n\n#### KeyNameMutator\n\nBy default, JSON key names are output as is, so in the following character output, \"user.Name\" becomes the JSON key name.\n\n```csharp\nvar user = new User(1, \"Alice\");\nlogger.ZLogInformation($\"Name: {user.Name}\");\n```\n\nIf you set this to `formatter.KeyNameMutator = KeyNameMutator.LastMemberName`, it becomes `Name`. If you set this to `LastMemberNameLowerFirstCharacter`, the first character is replaced with lower-case, resulting in `name`.\n\nThe following is a list of KeyNameMutators provided as standard:\n\n| Name                                  | Description                                                                                               |\n|:--------------------------------------|:----------------------------------------------------------------------------------------------------------|\n| `LastMemberName`                      | Returns the last member name of the source.                                                               |\n| `LowerFirstCharacter`                 | The first character converted to lowercase.                                                               |\n| `UpperFirstCharacter`                 | The first character converted to uppercase.                                                               |\n| `LastMemberNameLowerFirstCharacter`   | Returns the last member name of the source with the first character converted to lowercase.               |\n| `LastMemberNameUpperFirstCharacter`   | Returns the last member name of the source with the first character converted to uppercase.               |       \n\n\n### MessagePack\n\nWe also support structured logging output in binary format using MessagePack instead of JSON. `UseMessagePackFormatter()` requires a reference to the additional package `ZLogger.MessagePack`.\n\n> PM> Install-Package [ZLogger.MessagePack](https://www.nuget.org/packages/ZLogger.MessagePack)\n\n```csharp\nlogging.AddZLoggerFile(\"log.bin\", options =>\n{\n    options.UseMessagePackFormatter();\n});\n```\n\nMessagePack extension uses [MessagePack-CSharp](https://github.com/MessagePack-CSharp/MessagePack-CSharp) as writer.\n\nThe list of properties is as follows.\n\n| Name                                                               | Description                                                        |\n|:-------------------------------------------------------------------|:-------------------------------------------------------------------|\n| `MessagePackSerializerOptions MessagePackSerializerOptions`        | The options of `MessagePack-CSharp`.                               |\n| `IncludeProperties IncludeProperties`                              | Flags that can specify properties to be output. (default: `Timestamp| LogLevel | CategoryName | Message | Exception | ScopeKeyValues | ParameterKeyValues`) |\n| `IKeyNameMutator? KeyNameMutator`                                   | You can set the naming convention if you want to automatically convert key names. |\n\n### Custom Formatter \n\nIf you want to create a formatter other than the default PlainText, Json, and MessagePack, you can implement `IZloggerFormatter` to create any custom output.\n\n```csharp\npublic interface IZLoggerFormatter\n{\n    bool WithLineBreak { get; }\n    void FormatLogEntry<TEntry>(IBufferWriter<byte> writer, TEntry entry)\n        where TEntry : IZLoggerEntry;\n}\n```\n\n```csharp\noptions.UseFormatter(() => new MyFormatter());\n```\n\nLogInfo\n---\nAdditional information about when each log was written can be obtained from this LogInfo struct.\n\n| Name                        | Description                                                                                              |\n|:----------------------------|:---------------------------------------------------------------------------------------------------------|\n| `LogCategory Category`      | The category name set for each logger. And holds JsonEncodedText and utf8 byte sequence representations. |\n| `Timestamp Timestamp`       | Timestamp                                                                                                |\n| `LogLevel LogLevel`         | LogLevel  of `Microsoft.Extensions.Logging`                                                              |\n| `EventId EventId`           | EventId of `Microsoft.Extensions.Logging`                                                                |\n| `Exception? Exception`      | Exception given as argument when logging.                                                                |\n| `LogScopeState? ScopeState` | Additional properties set by `ILogger.BeginScope(...)` (if ZLoggerOptions.IncludeScopes = true)          |\n| `ThreadInfo ThreadInfo`     | Additional properties set by ZLoggerOptions.CaptureThreadInfo = true)                                    |\n| `object? Context`    | Additional context | \n| `string? MemberName` | Caller MemberName         |\n| `string? FilePath` | Caller FilePath         |\n| `int LineNumber` | Caller LineNumber         |\n\nZLoggerOptions\n---\nThe following are common option items for all providers.\n\n| Name                                                                         | Description                                                                                                                                                                                                                    |\n|:-----------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `bool IncludeScopes { get; set; }`                                           | Enable `ILogger.BeginScope`, default is `false`.                                                                                                                                                                               |\n| `bool IsFormatLogImmediatelyInStandardLog { get; set; }`                     | Fallback of standard logger.Log, message stringify immediately or not. Default is `true`.                                                                                                                                      |\n| `bool CaptureThreadInfo { get; set; }`                                       | Capture information about the thread that generated a log entry. Default is `false`.                                                                                                                                           |\n| `TimeProvider? TimeProvider { get; set; }`                                   | Gets or sets the time provider for the logger. The Timestamp of LogInfo is generated by TimeProvider's GetUtcNow() and LocalTimeZone when TimeProvider is set. The default value is null, which means use the system standard. |\n| `Action<Exception>? InternalErrorLogger { get; set; }`                       | `InternalErrorLogger` is a delegate that is called when an exception occurs in the log writing process (such as a serialization error). The default value is `null`, which means errors are ignored.                           |\n| `CreateFormatter()`                                                          | Create an formatter to use in ZLoggerProvider.                                                                                                                                                                                 |\n| `UseFormatter(Func<IZLoggerFormatter> formatterFactory)`                     | Set the formatter that defines the output format of the log.                                                                                                                                                                   |\n| `UsePlainTextFormatter(Action<PlainTextZLoggerFormatter>? configure = null)` | Use the built-in plain text formatter.                                                                                                                                                                                         |\n| `UseJsonFormatter(Action<SystemTextJsonZLoggerFormatter>? configure = null)` | Use the built-in json formatter. (implementation of `System.Text.Json`)                                                                                                                                                        |\n\nBy default, `UsePlainTextFormatter` is set. Also, only one formatter can be set for one provider. If you want to use multiple formatters, you need to add multiple providers.\n\n```csharp\n// Show plain text log for console, json log for file\nlogging.AddZLoggerConsole(options => options.UsePlainTextFormatter());\nlogging.AddZLoggerFile(\"json.log\", options => options.UseJsonFormatter());\n```\n\nZLoggerMessage Source Generator\n---\nA log method generator similar to .NET 6's [Compile-time logging source generation](https://learn.microsoft.com/en-us/dotnet/core/extensions/logger-message-generator) is bundled as standard.\n\n```csharp\npublic static partial class MyLogger\n{\n    [ZLoggerMessage(LogLevel.Information, \"Bar: {x} {y}\")]\n    public static partial void Bar(this ILogger<Foo> logger, int x, int y);\n}\n```\n\nThis can achieve the highest performance. It's also possible to use special format specifiers like `:json`.\n\nMicrosoft.CodeAnalysis.BannedApiAnalyzers\n---\n[Microsoft.CodeAnalysis.BannedApiAnalyzers](https://github.com/dotnet/roslyn-analyzers/blob/master/src/Microsoft.CodeAnalysis.BannedApiAnalyzers/BannedApiAnalyzers.Help.md) is an interesting analyzer, you can prohibit the normal Log method and induce the user to call ZLogger's ZLog method.\n\n![image](https://user-images.githubusercontent.com/46207/78545188-56ea8a80-7836-11ea-81f2-6cbf7119f027.png)\n\nAll you have to do is prepare the following configuration.\n\n```\nT:Microsoft.Extensions.Logging.LoggerExtensions;Don't use this, use ZLog*** instead.\nT:System.Console;Don't use this, use logger instead.\n```\n\nGlobal LoggerFactory\n---\nLike the traditional log manager, how to get and store logger per type without DI(such as `static readonly ILogger logger = LogManager.GetLogger()`). You can get `ILoggerFactory` from `IHost` before Run and set to the global static loggerfactory store.\n\n```csharp\nusing var host = Host.CreateDefaultBuilder()\n    .ConfigureLogging(logging =>\n    {\n        logging.ClearProviders();\n        logging.AddZLoggerConsole();\n    })\n    .Build(); // use Build instead of Run directly\n\n// get configured loggerfactory.\nvar loggerFactory = host.Services.GetRequiredService<ILoggerFactory>();\n\nLogManager.SetLoggerFactory(loggerFactory, \"Global\");\n\n// Run after set global logger.\nawait host.RunAsync();\n\n// -----\n\n// Own static logger manager\npublic static class LogManager\n{\n    static ILogger globalLogger = default!;\n    static ILoggerFactory loggerFactory = default!;\n\n    public static void SetLoggerFactory(ILoggerFactory loggerFactory, string categoryName)\n    {\n        LogManager.loggerFactory = loggerFactory;\n        LogManager.globalLogger = loggerFactory.CreateLogger(categoryName);\n    }\n\n    public static ILogger Logger => globalLogger;\n\n    // standard LoggerFactory caches logger per category so no need to cache in this manager\n    public static ILogger<T> GetLogger<T>() where T : class => loggerFactory.CreateLogger<T>();\n    public static ILogger GetLogger(string categoryName) => loggerFactory.CreateLogger(categoryName);\n}\n```\n\nYou can use this logger manager like following.\n\n```csharp\npublic class Foo\n{\n    static readonly ILogger<Foo> logger = LogManager.GetLogger<Foo>();\n\n    public void Foo(int x)\n    {\n        logger.ZLogDebug($\"do do do: {x}\");\n    }\n}\n```\n\nUnity\n---\n\n### Installation\n\nZLogger uses some of the compile time features of C# 10, and ZLogger.Generator uses some of the features of C# 11.\n\nTo use them in Unity, needs to check the Unity version and set up the compiler.\n\n- Unity 2022.2 or newer\n  - Standard ZLogger features are available.\n  - Unity internally embeds the .NET SDK 6. So C# 10 is available via compiler arguments.\n- Unity 2022.3.12f1 or newer\n  - ZLogger source generator available.\n  - Unity internaly update .NET SDK 6. So C# 11 features are in preview.\n\nPrerequirements:\n- Install [NuGetForUnity](https://github.com/GlitchEnzo/NuGetForUnity)\n  - Required to install the dlls of ZLogger and its dependencies.\n- Install [CsprojModifier](https://github.com/Cysharp/CsprojModifier) \n  - Required to develop in the IDE with a new language version.\n- Install `ZLogger.Unity` package via git url.\n  - Add `https://github.com/Cysharp/ZLogger.git?path=src/ZLogger.Unity/Assets/ZLogger.Unity` to Package Manager\n  \nInstallation steps:\n\n1. Setup the C# compiler for unity. \n    - Add a text file named `csc.rsp` with the following contents under your Assets/.\n        - ```\n          -langVersion:10 -nullable\n          ```\n    - Note:\n        - If you are using assembly definition, put it in the same folder as the asmdef that references ZLogger.\n        - If you are using Unity 2022.3.12f1 or newer, you can use `langVersion:preview` allows parts of C# 11 features.\n\n2. Setup the C# compiler for your IDE. \n    - Add a text file named LangVersion.props with the following contents\n        - ```xml\n          <Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n            <PropertyGroup>\n              <LangVersion>10.0</LangVersion>\n              <Nullable>enable</Nullable>\n            </PropertyGroup>\n          </Project>\n          ``` \n    - Open Project Settings and [C# Project Modifier] section under the [Editor].\n    - Add the .props file you just created, to the list of [Additional project imports].\n    - Note:\n        - If you are using assembly definition, add your additional csproj in the list of [The project to be addef for import].\n        - If you want to use `ZLoggerMessage` Source Generator, require Unity 2022.3.12f1 and change to `<LangVersion>11</LangVersion>`\n3. Install ZLogger nuget package. \n    - Open [Nuget] -> [Manage Nuget Packages] in the menu bar.\n    - Search `ZLogger`, and press [Install].\n\n\n\n### Basic usage\n\nThe basic functions of ZLogger are also available in Unity as follows. Use LoggerFactory directly to create loggers.\n\n```cs\nvar loggerFactory = LoggerFactory.Create(logging =>\n{\n    logging.SetMinimumLevel(LogLevel.Trace);\n    logging.AddZLoggerUnityDebug(); // log to UnityDebug\n});\n\nvar logger = loggerFactory.CreateLogger<YourClass>();\n\nvar name = \"foo\";\nlogger.ZLogInformation($\"Hello, {name}!\");\n```\n\nAlso supports StructuredLogging(JSON), and FileProvider.\n\n```cs\nvar loggerFactory = LoggerFactory.Create(logging =>\n{\n    logging.AddZLoggerFile(\"/path/to/logfile\", options =>\n    {\n        options.UseJsonFormatter();\n    });\n});\n```\n\nUnity 2022.3.12f1 and enables `-langVersion:preview` supports Source Generator.\n\n```csharp\npublic static partial class LogExtensions\n{\n    [ZLoggerMessage(LogLevel.Debug, \"Hello, {name}\")]\n    public static partial void Hello(this ILogger<NewBehaviourScript> logger, string name);\n}\n```\n\nLicense\n---\nThis library is licensed under the MIT License.\n"
        },
        {
          "name": "ZLogger.sln",
          "type": "blob",
          "size": 6.8330078125,
          "content": "﻿\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio Version 17\nVisualStudioVersion = 17.6.33815.320\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"src\", \"src\", \"{108EBE73-8E8B-4BC8-ACBB-FB97D2B64B2E}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"ZLogger\", \"src\\ZLogger\\ZLogger.csproj\", \"{72C3035E-A0F8-4B05-B6AB-3C177CF3F79D}\"\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"sandbox\", \"sandbox\", \"{87C57843-6AA8-462F-B383-0E756D1E389C}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"ConsoleApp\", \"sandbox\\ConsoleApp\\ConsoleApp.csproj\", \"{54C5F84D-31C0-4337-AA68-F4D00255407C}\"\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"tests\", \"tests\", \"{BA8EAC7A-0D94-4EE2-A8F5-3998D73E3325}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"ZLogger.Tests\", \"tests\\ZLogger.Tests\\ZLogger.Tests.csproj\", \"{F4ADB9AC-E3FF-40D2-9538-D3DE600EECB6}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Benchmark\", \"sandbox\\Benchmark\\Benchmark.csproj\", \"{D817C5DF-B922-4697-A84A-A16241D076EC}\"\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"tools\", \"tools\", \"{231AACB5-020B-48E4-875A-7F223D511E21}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"CommandTools\", \"tools\\CommandTools\\CommandTools.csproj\", \"{DCF2A056-C3E9-4302-92CC-F4D88AF4CBF0}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"ZLogger.MessagePack\", \"src\\ZLogger.MessagePack\\ZLogger.MessagePack.csproj\", \"{A2243ECE-9B2C-4D15-865D-471A5FC9E0DE}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"ZLogger.MessagePack.Tests\", \"tests\\ZLogger.MessagePack.Tests\\ZLogger.MessagePack.Tests.csproj\", \"{35FFEF10-C4B9-4E6C-B00F-BC32AB0F81C4}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"ZLogger.Generator\", \"src\\ZLogger.Generator\\ZLogger.Generator.csproj\", \"{2F75085C-9DFE-495F-8D11-F6AFFED22FA5}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"GeneratorSandbox\", \"sandbox\\GeneratorSandbox\\GeneratorSandbox.csproj\", \"{18D196D4-6582-4903-BF82-BEF3014C0B3F}\"\nEndProject\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"ZLogger.Generator.Tests\", \"tests\\ZLogger.Generator.Tests\\ZLogger.Generator.Tests.csproj\", \"{837A506E-4119-4E7C-B708-5056889A6D5F}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|Any CPU = Debug|Any CPU\n\t\tRelease|Any CPU = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{72C3035E-A0F8-4B05-B6AB-3C177CF3F79D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{72C3035E-A0F8-4B05-B6AB-3C177CF3F79D}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{72C3035E-A0F8-4B05-B6AB-3C177CF3F79D}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{72C3035E-A0F8-4B05-B6AB-3C177CF3F79D}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{54C5F84D-31C0-4337-AA68-F4D00255407C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{54C5F84D-31C0-4337-AA68-F4D00255407C}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{54C5F84D-31C0-4337-AA68-F4D00255407C}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{54C5F84D-31C0-4337-AA68-F4D00255407C}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{F4ADB9AC-E3FF-40D2-9538-D3DE600EECB6}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{F4ADB9AC-E3FF-40D2-9538-D3DE600EECB6}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{F4ADB9AC-E3FF-40D2-9538-D3DE600EECB6}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{F4ADB9AC-E3FF-40D2-9538-D3DE600EECB6}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{D817C5DF-B922-4697-A84A-A16241D076EC}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{D817C5DF-B922-4697-A84A-A16241D076EC}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{D817C5DF-B922-4697-A84A-A16241D076EC}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{D817C5DF-B922-4697-A84A-A16241D076EC}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{DCF2A056-C3E9-4302-92CC-F4D88AF4CBF0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{DCF2A056-C3E9-4302-92CC-F4D88AF4CBF0}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{DCF2A056-C3E9-4302-92CC-F4D88AF4CBF0}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{DCF2A056-C3E9-4302-92CC-F4D88AF4CBF0}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{A2243ECE-9B2C-4D15-865D-471A5FC9E0DE}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{A2243ECE-9B2C-4D15-865D-471A5FC9E0DE}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{A2243ECE-9B2C-4D15-865D-471A5FC9E0DE}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{A2243ECE-9B2C-4D15-865D-471A5FC9E0DE}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{35FFEF10-C4B9-4E6C-B00F-BC32AB0F81C4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{35FFEF10-C4B9-4E6C-B00F-BC32AB0F81C4}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{35FFEF10-C4B9-4E6C-B00F-BC32AB0F81C4}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{35FFEF10-C4B9-4E6C-B00F-BC32AB0F81C4}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{2F75085C-9DFE-495F-8D11-F6AFFED22FA5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{2F75085C-9DFE-495F-8D11-F6AFFED22FA5}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{2F75085C-9DFE-495F-8D11-F6AFFED22FA5}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{2F75085C-9DFE-495F-8D11-F6AFFED22FA5}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{18D196D4-6582-4903-BF82-BEF3014C0B3F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{18D196D4-6582-4903-BF82-BEF3014C0B3F}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{18D196D4-6582-4903-BF82-BEF3014C0B3F}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{18D196D4-6582-4903-BF82-BEF3014C0B3F}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{837A506E-4119-4E7C-B708-5056889A6D5F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{837A506E-4119-4E7C-B708-5056889A6D5F}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{837A506E-4119-4E7C-B708-5056889A6D5F}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{837A506E-4119-4E7C-B708-5056889A6D5F}.Release|Any CPU.Build.0 = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(NestedProjects) = preSolution\n\t\t{72C3035E-A0F8-4B05-B6AB-3C177CF3F79D} = {108EBE73-8E8B-4BC8-ACBB-FB97D2B64B2E}\n\t\t{54C5F84D-31C0-4337-AA68-F4D00255407C} = {87C57843-6AA8-462F-B383-0E756D1E389C}\n\t\t{F4ADB9AC-E3FF-40D2-9538-D3DE600EECB6} = {BA8EAC7A-0D94-4EE2-A8F5-3998D73E3325}\n\t\t{D817C5DF-B922-4697-A84A-A16241D076EC} = {87C57843-6AA8-462F-B383-0E756D1E389C}\n\t\t{DCF2A056-C3E9-4302-92CC-F4D88AF4CBF0} = {231AACB5-020B-48E4-875A-7F223D511E21}\n\t\t{A2243ECE-9B2C-4D15-865D-471A5FC9E0DE} = {108EBE73-8E8B-4BC8-ACBB-FB97D2B64B2E}\n\t\t{35FFEF10-C4B9-4E6C-B00F-BC32AB0F81C4} = {BA8EAC7A-0D94-4EE2-A8F5-3998D73E3325}\n\t\t{2F75085C-9DFE-495F-8D11-F6AFFED22FA5} = {108EBE73-8E8B-4BC8-ACBB-FB97D2B64B2E}\n\t\t{18D196D4-6582-4903-BF82-BEF3014C0B3F} = {87C57843-6AA8-462F-B383-0E756D1E389C}\n\t\t{837A506E-4119-4E7C-B708-5056889A6D5F} = {BA8EAC7A-0D94-4EE2-A8F5-3998D73E3325}\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {D6093B62-9CF6-4344-8924-80BF89EEB4BA}\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "opensource.snk",
          "type": "blob",
          "size": 0.58203125,
          "content": null
        },
        {
          "name": "sandbox",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}