{
  "metadata": {
    "timestamp": 1736711100846,
    "page": 916,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "bezzad/Downloader",
      "stars": 1379,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 5.861328125,
          "content": "## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n##\n## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore\n\n# User-specific files\n*.rsuser\n*.suo\n*.user\n*.userosscache\n*.sln.docstates\n\n# User-specific files (MonoDevelop/Xamarin Studio)\n*.userprefs\n\n# Mono auto generated files\nmono_crash.*\n\n# Build results\n[Dd]ebug/\n[Dd]ebugPublic/\n[Rr]elease/\n[Rr]eleases/\nx64/\nx86/\n[Aa][Rr][Mm]/\n[Aa][Rr][Mm]64/\nbld/\n[Bb]in/\n[Oo]bj/\n[Ll]og/\n[Ll]ogs/\n\n# Visual Studio 2015/2017 cache/options directory\n.vs/\n# Uncomment if you have tasks that create the project's static files in wwwroot\n#wwwroot/\n\n# Visual Studio 2017 auto generated files\nGenerated\\ Files/\n\n# MSTest test Results\n[Tt]est[Rr]esult*/\n[Bb]uild[Ll]og.*\n\n# NUnit\n*.VisualState.xml\nTestResult.xml\nnunit-*.xml\n\n# Build Results of an ATL Project\n[Dd]ebugPS/\n[Rr]eleasePS/\ndlldata.c\n\n# Benchmark Results\nBenchmarkDotNet.Artifacts/\n\n# .NET Core\nproject.lock.json\nproject.fragment.lock.json\nartifacts/\n\n# StyleCop\nStyleCopReport.xml\n\n# Files built by Visual Studio\n*_i.c\n*_p.c\n*_h.h\n*.ilk\n*.meta\n*.obj\n*.iobj\n*.pch\n*.pdb\n*.ipdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.tmp_proj\n*_wpftmp.csproj\n*.log\n*.vspscc\n*.vssscc\n.builds\n*.pidb\n*.svclog\n*.scc\n\n# Chutzpah Test files\n_Chutzpah*\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opendb\n*.opensdf\n*.sdf\n*.cachefile\n*.VC.db\n*.VC.VC.opendb\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n*.sap\n\n# Visual Studio Trace Files\n*.e2e\n\n# TFS 2012 Local Workspace\n$tf/\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*/\n*.[Rr]e[Ss]harper\n*.DotSettings.user\n\n# TeamCity is a build add-in\n_TeamCity*\n\n# DotCover is a Code Coverage Tool\n*.dotCover\n\n# AxoCover is a Code Coverage Tool\n.axoCover/*\n!.axoCover/settings.json\n\n# Visual Studio code coverage results\n*.coverage\n*.coveragexml\n\n# NCrunch\n_NCrunch_*\n.*crunch*.local.xml\nnCrunchTemp_*\n\n# MightyMoose\n*.mm.*\nAutoTest.Net/\n\n# Web workbench (sass)\n.sass-cache/\n\n# Installshield output folder\n[Ee]xpress/\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish/\n\n# Publish Web Output\n*.[Pp]ublish.xml\n*.azurePubxml\n# Note: Comment the next line if you want to checkin your web deploy settings,\n# but database connection strings (with potential passwords) will be unencrypted\n*.pubxml\n*.publishproj\n\n# Microsoft Azure Web App publish settings. Comment the next line if you want to\n# checkin your Azure Web App publish settings, but sensitive information contained\n# in these scripts will be unencrypted\nPublishScripts/\n\n# NuGet Packages\n*.nupkg\n# NuGet Symbol Packages\n*.snupkg\n# The packages folder can be ignored because of Package Restore\n**/[Pp]ackages/*\n# except build/, which is used as an MSBuild target.\n!**/[Pp]ackages/build/\n# Uncomment if necessary however generally it will be regenerated when needed\n#!**/[Pp]ackages/repositories.config\n# NuGet v3's project.json files produces more ignorable files\n*.nuget.props\n*.nuget.targets\n\n# Microsoft Azure Build Output\ncsx/\n*.build.csdef\n\n# Microsoft Azure Emulator\necf/\nrcf/\n\n# Windows Store app package directories and files\nAppPackages/\nBundleArtifacts/\nPackage.StoreAssociation.xml\n_pkginfo.txt\n*.appx\n*.appxbundle\n*.appxupload\n\n# Visual Studio cache files\n# files ending in .cache can be ignored\n*.[Cc]ache\n# but keep track of directories ending in .cache\n!?*.[Cc]ache/\n\n# Others\nClientBin/\n~$*\n*~\n*.dbmdl\n*.dbproj.schemaview\n*.jfm\n*.pfx\n*.publishsettings\norleans.codegen.cs\n\n# Including strong name files can present a security risk\n# (https://github.com/github/gitignore/pull/2483#issue-259490424)\n#*.snk\n\n# Since there are multiple workflows, uncomment next line to ignore bower_components\n# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)\n#bower_components/\n\n# RIA/Silverlight projects\nGenerated_Code/\n\n# Backup & report files from converting an old project file\n# to a newer Visual Studio version. Backup files are not needed,\n# because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\nUpgradeLog*.htm\nServiceFabricBackup/\n*.rptproj.bak\n\n# SQL Server files\n*.mdf\n*.ldf\n*.ndf\n\n# Business Intelligence projects\n*.rdl.data\n*.bim.layout\n*.bim_*.settings\n*.rptproj.rsuser\n*- [Bb]ackup.rdl\n*- [Bb]ackup ([0-9]).rdl\n*- [Bb]ackup ([0-9][0-9]).rdl\n\n# Microsoft Fakes\nFakesAssemblies/\n\n# GhostDoc plugin setting file\n*.GhostDoc.xml\n\n# Node.js Tools for Visual Studio\n.ntvs_analysis.dat\nnode_modules/\n\n# Visual Studio 6 build log\n*.plg\n\n# Visual Studio 6 workspace options file\n*.opt\n\n# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)\n*.vbw\n\n# Visual Studio LightSwitch build output\n**/*.HTMLClient/GeneratedArtifacts\n**/*.DesktopClient/GeneratedArtifacts\n**/*.DesktopClient/ModelManifest.xml\n**/*.Server/GeneratedArtifacts\n**/*.Server/ModelManifest.xml\n_Pvt_Extensions\n\n# Paket dependency manager\n.paket/paket.exe\npaket-files/\n\n# FAKE - F# Make\n.fake/\n\n# CodeRush personal settings\n.cr/personal\n\n# Python Tools for Visual Studio (PTVS)\n__pycache__/\n*.pyc\n\n# Cake - Uncomment if you are using it\n# tools/**\n# !tools/packages.config\n\n# Tabs Studio\n*.tss\n\n# Telerik's JustMock configuration file\n*.jmconfig\n\n# BizTalk build output\n*.btp.cs\n*.btm.cs\n*.odx.cs\n*.xsd.cs\n\n# OpenCover UI analysis results\nOpenCover/\n\n# Azure Stream Analytics local run output\nASALocalRun/\n\n# MSBuild Binary and Structured Log\n*.binlog\n\n# NVidia Nsight GPU debugger configuration file\n*.nvuser\n\n# MFractors (Xamarin productivity tool) working folder\n.mfractor/\n\n# Local History for Visual Studio\n.localhistory/\n\n# BeatPulse healthcheck temp database\nhealthchecksdb\n\n# Backup folder for Package Reference Convert tool in Visual Studio 2017\nMigrationBackup/\n\n# Ionide (cross platform F# VS Code tools) working folder\n.ionide/\n"
        },
        {
          "name": ".licrc",
          "type": "blob",
          "size": 1.1083984375,
          "content": "# IMPORTANT!: ALL SECTIONS ARE MANDATORY\n[licenses]\n# This indicates which are the only licenses that Licensebat will accept.\n# The rest will be flagged as not allowed.\naccepted = [\"MIT\", \"MSC\", \"BSD\"]\n# This will indicate which licenses are not accepted.\n# The rest will be accepted, except for the unknown licenses or dependencies without licenses.\n# unaccepted = [\"LGPL\"]\n# Note that only one of the previous options can be enabled at once. \n# If both of them are informed, only accepted will be considered.\n\n[dependencies]\n# This will allow users to flag some dependencies so that Licensebat will not check for their license.\nignored=[\"ignored_dep1\", \"ignored_dep2\"]\n# If set to true, Licensebat will ignore the dev dependencies.\nignore_dev_dependencies = true\n# If set to true, Licensebat will ignore the optional dependencies.\nignore_optional_dependencies = true\n\n[behavior]\n# False by default, if true, it will only run the checks when one of the dependency files or the .licrc file has been modified.\nrun_only_on_dependency_modification = true\n# False by default, if true, it will never block the build.\ndo_not_block_pr = false"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.05078125,
          "content": "MIT License\n\nCopyright (c) 2021 Behzad Khosravifar\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 17.927734375,
          "content": "[![Windows x64](https://github.com/bezzad/Downloader/workflows/Windows%20x64/badge.svg)](https://github.com/bezzad/Downloader/actions/workflows/dotnet-windows.yml)\n[![Ubuntu x64](https://github.com/bezzad/Downloader/workflows/Ubuntu%20x64/badge.svg)](https://github.com/bezzad/Downloader/actions/workflows/dotnet-ubuntu.yml)\n[![MacOS](https://github.com/bezzad/Downloader/workflows/MacOS/badge.svg)](https://github.com/bezzad/Downloader/actions/workflows/dotnet-macos.yml)\n[![Build Status](https://ci.appveyor.com/api/projects/status/dsghbc9nj1in2l6f?svg=true)](https://ci.appveyor.com/project/bezzad/downloader)\n[![codecov](https://codecov.io/github/bezzad/Downloader/graph/badge.svg?token=CnLljCB3zO)](https://codecov.io/github/bezzad/Downloader)\n[![NuGet](https://img.shields.io/nuget/dt/downloader.svg)](https://www.nuget.org/packages/downloader)\n[![NuGet](https://img.shields.io/nuget/vpre/downloader.svg)](https://www.nuget.org/packages/downloader)\n[![CodeFactor](https://www.codefactor.io/repository/github/bezzad/downloader/badge/master)](https://www.codefactor.io/repository/github/bezzad/downloader/overview/master)\n[![Codacy Badge](https://app.codacy.com/project/badge/Grade/f7cd6e24f75c45c28e5e6fab2ef8d219)](https://www.codacy.com/gh/bezzad/Downloader/dashboard?utm_source=github.com&utm_medium=referral&utm_content=bezzad/Downloader&utm_campaign=Badge_Grade)\n[![License](https://img.shields.io/github/license/bezzad/downloader.svg)](https://github.com/bezzad/downloader/blob/master/LICENSE)\n[![Generic badge](https://img.shields.io/badge/support-.Net_Framework-blue.svg)](https://github.com/bezzad/Downloader)\n[![Generic badge](https://img.shields.io/badge/support-.Net_8.0-purple.svg)](https://github.com/bezzad/Downloader)\n[![Generic badge](https://img.shields.io/badge/support-.Net_Standard_2.1-blue.svg)](https://github.com/bezzad/Downloader)\n\n# Downloader\n\n:rocket: Fast, cross-platform, and reliable multipart downloader in `.Net` :rocket:\n\n**Downloader** is a modern, fluent, asynchronous, and portable library for .NET, built with testability in mind. It supports multipart downloads with real-time asynchronous progress events. The library is compatible with projects targeting `.NET Standard 2.1`, `.NET 8`, and later versions.\n\nDownloader works on Windows, Linux, and macOS.\n> **Note**: Support for older versions of .NET was removed in Downloader `v3.2.0`. From this version onwards, only `.Net 8.0` and higher versions are supported.  \n> If you need compatibility with older .NET versions (e.g., `.NET Framework 4.6.1`), use Downloader `v3.1.*`.\n\n> For a complete example, see the [Downloader.Sample](https://github.com/bezzad/Downloader/blob/master/src/Samples/Downloader.Sample/Program.cs) project in this repository.\n\n## Sample Console Application\n\n![sample-project](https://github.com/bezzad/Downloader/raw/master/sample.gif)\n\n---\n\n## Key Features\n\n- Simple interface for download requests.\n- Asynchronous, non-blocking file downloads.\n- Supports all file types (e.g., images, videos, PDFs, APKs).\n- Cross-platform support for files of any size.\n- Real-time progress updates for each download chunk.\n- Downloads files in multiple parts (parallel download).\n- Resilient to client-side and server-side errors.\n- Configurable `ChunkCount` to control download segmentation.\n- Supports both in-memory and on-disk multipart downloads.\n- Parallel saving of chunks directly into the final file (no temporary files).\n- Pre-allocates file size before download begins.\n- Ability to resume downloads with a saved package object.\n- Provides real-time speed and progress data.\n- Asynchronous pause and resume functionality.\n- Download files with dynamic speed limits.\n- Supports downloading to memory streams (without saving to disk).\n- Supports large file downloads and live-streaming (e.g., music playback during download).\n- Download a specific byte range from a large file.\n- Lightweight, fast codebase with no external dependencies.\n- Manage RAM usage during downloads.\n\n---\n\n## Installation via [NuGet](https://www.nuget.org/packages/downloader)\n\n    PM> Install-Package Downloader\n\n## Installation via the .NET CLI\n\n    dotnet add package Downloader\n\n---\n\n## Usage\n\n### **Step 1**: Create a Custom Configuration\n\n#### Simple Configuration\n\n```csharp\nvar downloadOpt = new DownloadConfiguration()\n{\n    ChunkCount = 8, // Number of file parts, default is 1\n    ParallelDownload = true // Download parts in parallel (default is false)\n};\n```\n\n### Complex Configuration\n\n\n> **Note**: Only include the options you need in your application.\n\n```csharp\nvar downloadOpt = new DownloadConfiguration()\n{\n    // usually, hosts support max to 8000 bytes, default value is 8000\n    BufferBlockSize = 10240,\n    // file parts to download, the default value is 1\n    ChunkCount = 8,             \n    // download speed limited to 2MB/s, default values is zero or unlimited\n    MaximumBytesPerSecond = 1024*1024*2, \n    // the maximum number of times to fail\n    MaxTryAgainOnFailover = 5,    \n    // release memory buffer after each 50 MB\n    MaximumMemoryBufferBytes = 1024 * 1024 * 50, \n    // download parts of the file as parallel or not. The default value is false\n    ParallelDownload = true,\n    // number of parallel downloads. The default value is the same as the chunk count\n    ParallelCount = 4,    \n    // timeout (millisecond) per stream block reader, default values is 1000\n    Timeout = 1000,      \n    // set true if you want to download just a specific range of bytes of a large file\n    RangeDownload = false,\n    // floor offset of download range of a large file\n    RangeLow = 0,\n    // ceiling offset of download range of a large file\n    RangeHigh = 0, \n    // clear package chunks data when download completed with failure, default value is false\n    ClearPackageOnCompletionWithFailure = true, \n    // minimum size of chunking to download a file in multiple parts, the default value is 512\n    MinimumSizeOfChunking = 1024, \n    // Before starting the download, reserve the storage space of the file as file size, the default value is false\n    ReserveStorageSpaceBeforeStartingDownload = true,\n    // Get on demand downloaded data with ReceivedBytes on downloadProgressChanged event \n    EnableLiveStreaming = false, \n    // config and customize request headers\n    RequestConfiguration = \n    {        \n        Accept = \"*/*\",\n        CookieContainer = cookies,\n        Headers = [\"Accept-Encoding: gzip, deflate, br\"], // { your custom headers }\n        KeepAlive = true, // default value is false\n        ProtocolVersion = HttpVersion.Version11, // default value is HTTP 1.1\n        // your custom user agent or your_app_name/app_version.\n        UserAgent = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64)\",\n        Proxy = new WebProxy() {\n           Address = new Uri(\"http://YourProxyServer/proxy.pac\"),\n           UseDefaultCredentials = false,\n           Credentials = System.Net.CredentialCache.DefaultNetworkCredentials,\n           BypassProxyOnLocal = true\n        }\n    }\n};\n```\n\n### **Step 2**: Create the Download Service\n\n```csharp\nvar downloader = new DownloadService(downloadOpt);\n```\n\n### **Step 3**: Handle Download Events\n\n```csharp\n// Provide `FileName` and `TotalBytesToReceive` at the start of each download\ndownloader.DownloadStarted += OnDownloadStarted;\n\n// Provide any information about chunker downloads, \n// like progress percentage per chunk, speed, \n// total received bytes and received bytes array to live streaming.\ndownloader.ChunkDownloadProgressChanged += OnChunkDownloadProgressChanged;\n\n// Provide any information about download progress, \n// like progress percentage of sum of chunks, total speed, \n// average speed, total received bytes and received bytes array \n// to live streaming.\ndownloader.DownloadProgressChanged += OnDownloadProgressChanged;\n\n// Download completed event that can include errors or \n// canceled or download completed successfully.\ndownloader.DownloadFileCompleted += OnDownloadFileCompleted;\n```\n\n### **Step 4**: Start the Download\n\n```csharp\nstring file = @\"Your_Path\\fileName.zip\";\nstring url = @\"https://file-examples.com/fileName.zip\";\nawait downloader.DownloadFileTaskAsync(url, file);\n```\n\n### **Step 4b**: Start the download without file name\n\n```csharp\nDirectoryInfo path = new DirectoryInfo(\"Your_Path\");\nstring url = @\"https://file-examples.com/fileName.zip\";\n// download into \"Your_Path\\fileName.zip\"\nawait downloader.DownloadFileTaskAsync(url, path); \n```\n\n### **Step 4c**: Download in MemoryStream\n\n```csharp\n// After download completion, it gets a MemoryStream\nStream destinationStream = await downloader.DownloadFileTaskAsync(url); \n```\n\n---\n### How to **pause** and **resume** downloads quickly\n\nWhen you want to resume a download quickly after pausing a few seconds. You can call the `Pause` function of the downloader service. This way, streams stay alive and are only suspended by a locker to be released and resumed whenever you want.\n\n```csharp\n// Pause the download\nDownloadService.Pause();\n\n// Resume the download\nDownloadService.Resume();\n```\n\n---\n### How to **stop** and **resume** downloads other time\n\nThe `DownloadService` class has a property called `Package` that stores each step of the download. To stop the download you must call the `CancelAsync` method. Now, if you want to continue again, you must call the same `DownloadFileTaskAsync` function with the `Package` parameter to resume your download. For example:\n\n```csharp\n// At first, keep and store the Package file to resume \n// your download from the last download position:\nDownloadPackage pack = downloader.Package;\n```\n\n**Stop or cancel download:**\n\n```csharp\n// This function breaks your stream and cancels progress.\ndownloader.CancelAsync();\n```\n\n**Resuming download after cancellation:**\n\n```csharp\nawait downloader.DownloadFileTaskAsync(pack);\n```\n\nSo that you can even save your large downloads with a very small amount in the Package and after restarting the program, restore it and start continuing your download. \nThe packages are your snapshot of the download instance. Only the downloaded file addresses will be included in the package, and you can resume it whenever you want. \nFor more detail see [StopResumeDownloadTest](https://github.com/bezzad/Downloader/blob/master/src/Downloader.Test/IntegrationTests/DownloadIntegrationTest.cs#L210) method\n\n> Note: Sometimes a server does not support downloading in a specific range. That time, we can't resume downloads after canceling. So, the downloader starts from the beginning.\n\n---\n\n## Fluent download builder usage\n\nFor easy and fluent use of the downloader, you can use the `DownloadBuilder` class. Consider the following examples:\n\nSimple usage:\n\n```csharp\nawait DownloadBuilder.New()\n    .WithUrl(@\"https://host.com/test-file.zip\")\n    .WithDirectory(@\"C:\\temp\")\n    .Build()\n    .StartAsync();\n```\n\nComplex usage:\n\n```csharp\nIDownload download = DownloadBuilder.New()\n    .WithUrl(@\"https://host.com/test-file.zip\")\n    .WithDirectory(@\"C:\\temp\")\n    .WithFileName(\"test-file.zip\")\n    .WithConfiguration(new DownloadConfiguration())\n    .Build();\n\ndownload.DownloadProgressChanged += DownloadProgressChanged;\ndownload.DownloadFileCompleted += DownloadFileCompleted;\ndownload.DownloadStarted += DownloadStarted;\ndownload.ChunkDownloadProgressChanged += ChunkDownloadProgressChanged;\n\nawait download.StartAsync();\n\ndownload.Stop(); // cancel current download\n```\n\nResume the existing download package:\n\n```csharp\nawait DownloadBuilder.Build(package).StartAsync();\n```\n\nResume the existing download package with a new configuration:\n\n```csharp\nawait DownloadBuilder.Build(package, config).StartAsync();\n```\n\n[Pause and Resume quickly](https://github.com/bezzad/Downloader/blob/master/src/Downloader.Test/UnitTests/DownloadBuilderTest.cs#L110):\n\n```csharp\nvar download = DownloadBuilder.New()\n     .Build()\n     .WithUrl(url)\n     .WithFileLocation(path);\nawait download.StartAsync();\n\ndownload.Pause(); // pause current download quickly\n\ndownload.Resume(); // continue current download quickly\n```\n\n---\n\n## When does the Downloader fail to download in multiple chunks?\n\n### Content-Length:\nIf your URL server does not provide the file size in the response header (`Content-Length`). \nThe Downloader cannot split the file into multiple parts and continues its work with one chunk.\n\n### Accept-Ranges:\nIf the server returns `Accept-Ranges: none` in the responses header then that means the server does not support download in range and \nthe Downloader cannot use multiple chunking and continues its work with one chunk.\n\n### Content-Range:\nAt first, the Downloader sends a GET request to the server to fetch the file's size in the range. \nIf the server does not provide `Content-Range` in the header then that means the server does not support download in range. \nTherefore, the Downloader has to continue its work with one chunk.\n\n---\n\n## How to serialize and deserialize the downloader package\n\n### **What is Serialization?**\n\nSerialization is the process of converting an object's state into information that can be stored for later retrieval or that can be sent to another system. For example, you may have an object that represents a document that you wish to save. This object could be serialized to a stream of binary information and stored as a file on disk. Later the binary data can be retrieved from the file and deserialized into objects that are exact copies of the original information. As a second example, you may have an object containing the details of a transaction that you wish to send to another type of system. This information could be serialized to XML before being transmitted. The receiving system would convert the XML into a format that it could understand.\n\nIn this section, we want to show how to serialize download packages to `JSON` text or `Binary`, after stopping the download to keep downloading data and resuming that every time you want.\nYou can serialize packages even using memory storage for caching download data which is used `MemoryStream`.\n\n### **JSON Serialization**\n\nSerializing the package to [`JSON`](https://www.newtonsoft.com) is very simple like this:\n\n```csharp\nvar packageJson = JsonConvert.SerializeObject(package);\n```\n\nDeserializing into the new package:\n\n```csharp\nvar newPack = JsonConvert.DeserializeObject<DownloadPackage>(packageJson);\n```\n\nFor more detail see [PackageSerializationTest](https://github.com/bezzad/Downloader/blob/46167082b8de99d8e6ad21329c3a32a6e26cfd3e/src/Downloader.Test/DownloadPackageTest.cs#L34) method\n\n### **Binary Serialization**\n\n\nTo serialize or deserialize the package into a binary file, first, you need to serialize it to JSON and next save it with [BinaryWriter](https://learn.microsoft.com/en-us/dotnet/api/system.io.binarywriter).\n\n> **NOTE**: \nThe [BinaryFormatter](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) type is dangerous and is not recommended for data processing. \nApplications should stop using [BinaryFormatter](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) as soon as possible, even if they believe the data they're processing to be trustworthy. \n[BinaryFormatter](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is insecure and can't be made secure. \nSo, [BinaryFormatter](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is deprecated and we can no longer support it. \n[Reference](https://learn.microsoft.com/en-us/dotnet/standard/serialization/binaryformatter-security-guide)\n\n# Instructions for Contributing\n\nWelcome to contribute, feel free to change and open a [**PullRequest**](http://help.github.com/pull-requests/) to develop the branch.\nYou can use either the latest version of Visual Studio or Visual Studio Code and .NET CLI for Windows, Mac and Linux.\n\nFor GitHub workflow, check out our Git workflow below this paragraph. We are following the excellent GitHub Flow process, and would like to make sure you have all the information needed to be a world-class contributor!\n\n## Git Workflow\n\nThe general process for working with Downloader is:\n\n1. [Fork](http://help.github.com/forking/) on GitHub\n2. Make sure your line endings are correctly configured and fix your line endings!\n3. Clone your fork locally\n4. Configure the upstream repo (`git remote add upstream git://github.com/bezzad/downloader`)\n5. Switch to the latest development branch (e.g. vX.Y.Z, using `git checkout vX.Y.Z`)\n6. Create a local branch from that (`git checkout -b myBranch`).\n7. Work on your feature\n8. Rebase if required\n9. Push the branch up to GitHub (`git push origin myBranch`)\n10. Send a Pull Request on GitHub - the PR should target (have as a base branch) the latest development branch (eg `vX.Y.Z`) rather than `master`.\n\nWe accept pull requests from the community. But, you should **never** work on a clone of the master, and you should **never** send a pull request from the master - always from a branch. Please be sure to branch from the head of the latest vX.Y.Z `develop` branch (rather than `master`) when developing contributions.\n\n## You can run tests with the Docker Compose file with the following command:\n> `docker-compose -p downloader up`\n\n## Or with docker file:\n> `docker build -f ./dockerfile -t downloader-linux .`\n> `docker run --name downloader-linux-container -d downloader-linux --env=ASPNETCORE_ENVIRONMENT=Development .`\n\n## Or run the following command to call docker directly:\n> `docker run --rm -v ${pwd}:/app --env=ASPNETCORE_ENVIRONMENT=Development -w /app/tests mcr.microsoft.com/dotnet/sdk:6.0 dotnet test ../ --logger:trx`\n\n# License\nLicensed under the terms of the [MIT License](https://raw.githubusercontent.com/bezzad/Downloader/master/LICENSE)\n\n[![FOSSA Status](https://app.fossa.com/api/projects/git%2Bgithub.com%2Fbezzad%2FDownloader.svg?type=large)](https://app.fossa.com/projects/git%2Bgithub.com%2Fbezzad%2FDownloader?ref=badge_large)\n\n# Contributors\nThanks go to these wonderful people (List made with [contrib. rocks](https://contrib.rocks)):\n\n<a href=\"https://github.com/bezzad/downloader/graphs/contributors\">\n  <img alt=\"downloader contributors\" src=\"https://contrib.rocks/image?repo=bezzad/downloader\" />\n</a>\n"
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 0.369140625,
          "content": "version: '{branch}-{build}'\nimage: Visual Studio 2022\n\npull_requests:\n  do_not_increment_build_number: true\n\nnuget:\n  disable_publish_on_pr: true\n\nbefore_build:\n  - choco install dotnet-sdk\n  - dotnet restore .\\src\\Downloader.sln\n\nbuild_script:\n  - dotnet build .\\src\\Downloader.sln --verbosity minimal\n\ntest_script:\n  - dotnet test .\\src\\Downloader.Test\\Downloader.Test.csproj\n"
        },
        {
          "name": "codecov.yml",
          "type": "blob",
          "size": 0.6962890625,
          "content": "codecov:\n  notify:\n    after_n_builds: 3\n    wait_for_ci: true\n  status:\n    project:\n      default: # default is the status check's name, not default settings\n        target: auto\n        threshold: 5\n        base: auto\n        flags:\n          - unit\n        paths:\n          - \"src\"\n        # advanced settings\n        branches:\n          - master\n          - develop\n        if_ci_failed: error #success, failure, error, ignore\n        informational: false\n        only_pulls: false\n\nignore:\n  - (?s:src/Downloader\\.Sample/.*/[^\\/]*)\\Z\n  - (?s:src/Downloader\\.Sample\\.NetFramework/.*/[^\\/]*)\\Z\n  - (?s:src/Downloader\\.DummyHttpServer/.*/[^\\/]*)\\Z\n  - ^src/Downloader.Test/Properties/Resources.Designer.cs.*\n \n"
        },
        {
          "name": "sample.gif",
          "type": "blob",
          "size": 380.998046875,
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}