{
  "metadata": {
    "timestamp": 1736710918948,
    "page": 535,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "microsoft/Microsoft.IO.RecyclableMemoryStream",
      "stars": 2020,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".devcontainer",
          "type": "tree",
          "content": null
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 1.3876953125,
          "content": "# EditorConfig is awesome: http://EditorConfig.org\n\n# Create portable, custom editor settings with EditorConfig\n# https://docs.microsoft.com/en-us/visualstudio/ide/create-portable-custom-editor-options\n\n# .NET coding convention settings for EditorConfig\n# https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference\n\n# Language conventions\n# https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-language-conventions\n\n# Formatting conventions\n# https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-formatting-conventions\n\n# .NET naming conventions for EditorConfig\n# https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-naming-conventions\n\n# Top-most EditorConfig file\nroot = true\n\n# Editor default newlines with a newline ending every file\n[*]\ninsert_final_newline = true\ncharset = utf-8\nindent_style = space\nindent_size = 2\ntrim_trailing_whitespace = true\n\n[*.cs]\nindent_size = 4\n\n# Code files\n[*.{cs,vb}]\n\ncsharp_prefer_simple_using_statement = true:warning\ncsharp_style_prefer_switch_expression = true:warning\n\ndotnet_style_qualification_for_field = true:warning\ndotnet_style_qualification_for_property = true:warning\ndotnet_style_qualification_for_method = true:warning\ndotnet_style_qualification_for_event = true:warning\ncsharp_style_namespace_declarations = block_scoped:warning\n\ncsharp_style_expression_bodied_properties = when_on_single_line:warning\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 2.458984375,
          "content": "###############################################################################\n# Set default behavior to automatically normalize line endings.\n###############################################################################\n* text=auto\n\n###############################################################################\n# Set default behavior for command prompt diff.\n#\n# This is need for earlier builds of msysgit that does not have it on by\n# default for csharp files.\n# Note: This is only used by command line\n###############################################################################\n#*.cs     diff=csharp\n\n###############################################################################\n# Set the merge driver for project and solution files\n#\n# Merging from the command prompt will add diff markers to the files if there\n# are conflicts (Merging from VS is not affected by the settings below, in VS\n# the diff markers are never inserted). Diff markers may cause the following \n# file extensions to fail to load in VS. An alternative would be to treat\n# these files as binary and thus will always conflict and require user\n# intervention with every merge. To do so, just uncomment the entries below\n###############################################################################\n#*.sln       merge=binary\n#*.csproj    merge=binary\n#*.vbproj    merge=binary\n#*.vcxproj   merge=binary\n#*.vcproj    merge=binary\n#*.dbproj    merge=binary\n#*.fsproj    merge=binary\n#*.lsproj    merge=binary\n#*.wixproj   merge=binary\n#*.modelproj merge=binary\n#*.sqlproj   merge=binary\n#*.wwaproj   merge=binary\n\n###############################################################################\n# behavior for image files\n#\n# image files are treated as binary by default.\n###############################################################################\n#*.jpg   binary\n#*.png   binary\n#*.gif   binary\n\n###############################################################################\n# diff behavior for common document formats\n# \n# Convert binary document formats to text before diffing them. This feature\n# is only available from the command line. Turn it on by uncommenting the \n# entries below.\n###############################################################################\n#*.doc   diff=astextplain\n#*.DOC   diff=astextplain\n#*.docx  diff=astextplain\n#*.DOCX  diff=astextplain\n#*.dot   diff=astextplain\n#*.DOT   diff=astextplain\n#*.pdf   diff=astextplain\n#*.PDF   diff=astextplain\n#*.rtf   diff=astextplain\n#*.RTF   diff=astextplain\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 2.1845703125,
          "content": "## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n\n# User-specific files\n*.suo\n*.user\n*.sln.docstates\n\n# Build results\n\n[Dd]ebug/\n[Rr]elease/\nx64/\nbuild/\n[Bb]in/\n[Oo]bj/\n\n# Enable \"build/\" folder in the NuGet Packages folder since NuGet packages use it for MSBuild targets\n!packages/*/build/\n\n# MSTest test Results\n[Tt]est[Rr]esult*/\n[Bb]uild[Ll]og.*\n\n*_i.c\n*_p.c\n*.ilk\n*.meta\n*.obj\n*.pch\n*.pdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.tmp_proj\n*.log\n*.vspscc\n*.vssscc\n.builds\n*.pidb\n*.log\n*.scc\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opensdf\n*.sdf\n*.cachefile\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*/\n*.[Rr]e[Ss]harper\n\n# TeamCity is a build add-in\n_TeamCity*\n\n# DotCover is a Code Coverage Tool\n*.dotCover\n\n# NCrunch\n*.ncrunch*\n.*crunch*.local.xml\n\n# Installshield output folder\n[Ee]xpress/\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish/\n\n# Publish Web Output\n*.Publish.xml\n\n# NuGet Packages Directory\n## TODO: If you have NuGet Package Restore enabled, uncomment the next line\npackages/\n\n# Windows Azure Build Output\ncsx\n*.build.csdef\n\n# Windows Store app package directory\nAppPackages/\n\n# Others\nsql/\n*.Cache\nClientBin/\n[Ss]tyle[Cc]op.*\n~$*\n*~\n*.dbmdl\n*.[Pp]ublish.xml\n*.pfx\n*.publishsettings\n.vs/\n\n# RIA/Silverlight projects\nGenerated_Code/\n\n# Backup & report files from converting an old project file to a newer\n# Visual Studio version. Backup files are not needed, because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\nUpgradeLog*.htm\n\n# SQL Server files\nApp_Data/*.mdf\nApp_Data/*.ldf\n\n\n#LightSwitch generated files\nGeneratedArtifacts/\n_Pvt_Extensions/\nModelManifest.xml\n\n# =========================\n# Windows detritus\n# =========================\n\n# Windows image file caches\nThumbs.db\nehthumbs.db\n\n# Folder config file\nDesktop.ini\n\n# Recycle Bin used on file shares\n$RECYCLE.BIN/\n\n# Mac desktop service store files\n.DS_Store\n"
        },
        {
          "name": "BenchmarkTests",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGES.md",
          "type": "blob",
          "size": 9.111328125,
          "content": "# Version 3.0.1\n\n**Bug Fix**\n\n* Fix infinite loop bug when calling (Try)GetBuffer on a stream longer than 1 GB when using the `UseExponentialLargeBuffer` option. (Issue #344)\n\n# Version 3.0.0\n\n**Breaking Changes**\n\n* Removed `int`-based constructor and `GetStream` overloads where `long`-based methods exist.\n* Removed all methods marked with `[Obsolete]`: \n    * `StreamDisposedEventArgs.ctor(Guid, string, string, string)`\n    * `RecyclableMemoryStreamManager.GetStream(Guid, string, Memory<byte>)`\n    * `RecyclableMemoryStreamManager.GetStream(Memory<byte>)`\n    * `RecyclableMemoryStreamManager.GetStream(string, Memory<byte>)`\n* Enable nullable annotations and warnings. i.e., added `<Nullable>enabled</Nullable>` to the project file.\n* All overloads of `RecyclableMemoryStreamManager.GetStream` now return type `RecyclableMemoryStream` instead of `MemoryStream`.\n* Removed explicit targets for net462, netcoreapp2.1, and net5.0. Supported targets are netstandard2.0, netstandard2.1, and net6.0 (there are a few net6.0-specific optimizations).\n* Moved all the configuration settings for `RecyclableMemoryStreamManager` to the new `RecyclableMemoryStreamManager.Options` class. Removed many of the constructors as a result. This class will facilitate easier dependency injection through use of the [Options pattern](https://learn.microsoft.com/en-us/dotnet/core/extensions/options), for those who need it.\n* Renamed some settings' names to be more consistent (e.g., `MaximumLargePoolFreeBytes`)\n\n**New Feature**\n\n* Added a new option for `RecyclableMemoryStreamManager`: `ZeroOutBuffer`, which will cause all buffers to be cleared on allocation and when returning to the pool. Off by default.\n\n**Other Changes**\n\n* Upgrade NUnit test library to version 4.\n* Fix some spelling issues in comments and variable names.\n* Update code to the latest recommended C# syntax.\n\n# Version 2.3.2\n\n**Optimizations**\n\n* Calculating blocks and offsets was made more efficient by using `Math.DivRem`.\n* Reading and writing to the stream was made more efficient with fewer array accesses.\n* `CopyTo` was overridden to avoid using the slower default implementation.\n\n# Version 2.3.1\n\n**New Feature**\n* Stream lifetime (creation through dispose) is now tracked and reported through the `MemoryStreamDispose` `EventSource` event, as well as through the `StreamDisposed` .NET event.\n\n**Changes**\n\n* The pool statistics used to be reported only when blocks/buffers were returned to the pool. This could lead to lopsided reporting patterns in some cases. Now, pool statistics are reported on stream creation and disposal.\n* Added pool stats information to the `MemoryStreamDiscardBuffer` event. \n* Changed events relating to buffer creation to be at the warning level instead of verbose. These are signals that the pool might not be large enough to handle the load.\n\n**Bug Fixes**\n\n* Fixed allocation/finalization bug that could cause a `NullReferenceException` in some low-memory scenarios.\n\n**Internal**\n\n* .NET 7 SDK used to build\n* Changed coding style to match some newer patterns (and added .editorconfig file to enforce in the future)\n* Fixed punctuation and spelling in API documentation.\n\n# Version 2.2.1\n\n**API change**\n\n* There are now overloads that take a type `long` parameter for requestedSize.\n\n**Bug Fix**\n\n* `ToString` will no longer throw an exception if the stream is disposed.\n\n\n# Version 2.2.0\n\n**API changes**\n\n* Add an override for `GetStream` that takes a `ReadOnlySpan<byte>`. This supersedes the versions of `GetStream` that take `Memory<byte>`, which were marked as `[Obsolete]`.\n\n**Bug Fixes**\n\n* Fixed: `GetReadOnlySequence()` throws `ArgumentOutOfRangeException`\n\n**Performance Improvements**\n\n* Removed enumerator allocation when returning blocks to the pool.\n* Changed default size of stream's block list to 0 because `EnsureCapacity` will always run, potentially resizing the list anyway.\n* Removed unneeded closure allocation when copying buffers.\n* Use `GC.AllocateUninitializedArray` in an additional spot, for better performance in .NET 5+.\n\n**Documentation**\n\n* Improved documentation, standardized punctuation, fixed code formatting.\n\n# Version 2.1.3\n\n** Bug Fixes**\n\n* Fixed another integer overflow error when returning buffers to the pool.\n\n# Version 2.1.2\n\n**Bug Fixes**\n\n* Added `[SecurityRules(SecurityRuyleSet.Level1)]` to assembly to allow more relaxed inheritance security rules.\n* Fixed an integer overflow when calculating large buffer sizes.\n\n# Version 2.1.0\n\n* Added `RecyclableMemoryStreamManager` constructor overloads that take parameters for specifying the maximum free pool sizes. Updated IntelliSense documentation to make clear that these values need to be explicitly set to avoid unbounded pool growth.\n* Buffers are now allocated using `GC.AllocateUninitializedArray` in .NET 5.\n* net462 and netstandard2.0 targets can now support the `Span`-related APIs via a dependency on System.Memory.\n* Updated documentation to fix typos and clarify language in some parts.\n* Support for Source Link\n\n# Version 2.0\n\n**Breaking Changes**\n\n* Removed 2 GB stream limit. Extremely large streams can be created by chaining together blocks. Attempts to convert a stream into a contiguous buffer longer than the runtime's limits will result in an exception.\n* Removed build targets for net40, net45, net46, and netstandard1.4. Added net462.\n* Changed some ETW events to provide more information.\n* Refactored .NET events to match the information payloads of the ETW events.\n* `GetBuffer` now throws `OutOfMemoryException` instead of `InvalidOperationException` if the needed size is too large for a contiguous array.\n\n**Other Changes**\n\n* Removed use of `Interlocked` methods when checking whether the stream is disposed. This should improve performance. (Concurrent use of streams has never been supported.)\n* `RecyclableMemoryStream` now implements `IBufferWriter<byte>`\n* New method overloads of `WriteTo` that allow you write the contents of the stream directly to another `byte[]` buffer.\n* Reformatted all code documentation to be more readable.\n\n**Development-only Changes**\n\n* Significantly improved unit test speed\n\n# Version 1.4.0\n\n* Added netstandard2.0 target. There was an issue calling `GetBuffer` from a netstandard2.0 project, which would resolve to the netstandard1.4 target of RMS. netstandard1.4 doesn't support overriding `GetBuffer`, so you could hit `UnauthorizedAccessException`.\n* A bug fix for `CopyToAsync`. It was copying the entire stream, but the expected behavior based on `System.IO.MemoryStream` is to copy from the current position.\n* Some performance improvements to `CopyToAsync`. \n\n# Version 1.3.6\n\n**Minor updates**\n\n* Override `CopyToAsync` to save some allocations.\n* Apply `AllowPartiallyTrustedCallers` attribute to assembly\n\n# Version 1.3.5\n\n**Performance Improvements**\n\n* `WriteByte` has been significantly optimized to be faster.\n* `CheckDisposed`, which is called in many code paths, has similarly been optimized.\n\n# Version 1.3.4\n\n**New API**\n\n* `void WriteTo(Stream stream, int offset, int count)` -- Allows you to write a portion of the current stream to a destination stream without first having to call `GetBuffer`.\n\n# Version 1.3.3\n\n**Functionality**\n\n- Added `RecyclableMemoryStreamManager.ThrowExceptionOnToArray`. Causes a `NotSupportedException` to be thrown if `RecyclableMemoryStream.ToArray` is called. Default is `false`.\n- Added overloads of `RecyclableMemoryStreamManager.GetStream` that accept `Memory<byte>` arguments.\n\n**Meta**\n\n- Added changes.md to solution\n- Regenerated API documentation for new XML comments and new APIs.\n\n# Version 1.3.2\n**Bug Fixes**\n\n- Removed a buggy and unnecessary boundary check in Write methods.\n\n**Performance**\n\n- Removed LINQ iteration in some properties.\n- Overloads of `Read`, `SafeRead`, and `Write` that accept `Span` arguments (.NET Core and .NET Standard targets only)\n\n**Functionality**\n\n- New buffer allocation strategy: exponential. Instead of linearly increasing large buffer sizes by a fixed multiple (say, 1MB), you can choose to have it increase exponentially in size, starting with smaller large buffers. This will allow you more efficient use of space, especially in smaller heap scenarios where you don't have gobs of memory to keep in a pool. We use this in Bing in some data centers that are more resource constrained than others.\n- New targets for .NET Framework 4.6, .NET Standard 2.1\n- Overload for `TryGetBuffer`, introduced in .NET Framework 4.6.\n- Allow the Stream's GUID to be set explicitly\n\n**Meta**\n\n- Removed CBT build support files. Using dotnet.exe to build now.\n- Added public key for delayed signing during build\n- Consolidate and updated all NuGet package settings in the .csproj file.\n- Added setting for generating a NuGet package for symbols (.snupkg)\n\n# Version 1.2.0\n- Bugs fixed when allocating very large streams.\n- Concurrent methods for reading from a single stream added.\n- Support for .NET 4.0 (without ETW instrumentation).\n- It is now safe to call Dispose from multiple threads on the same object.\n\n# Version 1.1.0\n- Binaries on nuget.org are now signed through Microsoft.\n- Some documentation enhancements and typo-cleanup.\n- Some minor performance improvements.\n- Fix behavior of `Dispose()` to be safe on double-dispose.\n\n# Version 1.0.0\n- Initial release.\n"
        },
        {
          "name": "Diagrams.vsdx",
          "type": "blob",
          "size": 25.76953125,
          "content": null
        },
        {
          "name": "Directory.Build.props",
          "type": "blob",
          "size": 0.169921875,
          "content": "<Project>\n\n  <PropertyGroup>\n    <LangVersion>latest</LangVersion>\n    <Nullable>enable</Nullable>\n    <ImplicitUsings>enable</ImplicitUsings>\n  </PropertyGroup>\n\n</Project>\n"
        },
        {
          "name": "Examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0673828125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015-2016 Microsoft\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n"
        },
        {
          "name": "MSFT.snk",
          "type": "blob",
          "size": 0.15625,
          "content": null
        },
        {
          "name": "Microsoft.IO.RecyclableMemoryStream.sln",
          "type": "blob",
          "size": 3.7490234375,
          "content": "﻿\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio Version 17\nVisualStudioVersion = 17.4.33213.308\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Microsoft.IO.RecyclableMemoryStream\", \"src\\Microsoft.IO.RecyclableMemoryStream.csproj\", \"{4B52F0CE-5F4C-43E7-A054-50CA0A502CF3}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"UnitTests\", \"UnitTests\\UnitTests.csproj\", \"{419C9F3D-71CC-4F95-8324-E15CD0D1E754}\"\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"Solution Items\", \"Solution Items\", \"{DF4A161A-7C52-46A2-A0ED-427C1C6F29AA}\"\n\tProjectSection(SolutionItems) = preProject\n\t\t.editorconfig = .editorconfig\n\t\tCHANGES.md = CHANGES.md\n\t\tDirectory.Build.props = Directory.Build.props\n\t\tglobal.json = global.json\n\t\tLICENSE = LICENSE\n\t\tREADME.md = README.md\n\tEndProjectSection\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \".github\", \".github\", \"{937E12C6-9E9E-438A-86C2-102E1D0C6826}\"\n\tProjectSection(SolutionItems) = preProject\n\t\t.github\\dependabot.yml = .github\\dependabot.yml\n\tEndProjectSection\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"workflows\", \"workflows\", \"{0ED3EBE5-1575-4649-A1F9-3D24BFFC4A9B}\"\n\tProjectSection(SolutionItems) = preProject\n\t\t.github\\workflows\\benchmark.yml = .github\\workflows\\benchmark.yml\n\t\t.github\\workflows\\ci-cd.yml = .github\\workflows\\ci-cd.yml\n\t\t.github\\workflows\\codeql-analysis.yml = .github\\workflows\\codeql-analysis.yml\n\tEndProjectSection\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"BenchmarkTests\", \"BenchmarkTests\\BenchmarkTests.csproj\", \"{731CCC6D-2583-4CB0-A439-8173E9722E4D}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Examples\", \"Examples\\Examples.csproj\", \"{9CFCED9A-7439-491A-8F24-827241280DA6}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|Any CPU = Debug|Any CPU\n\t\tRelease|Any CPU = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{4B52F0CE-5F4C-43E7-A054-50CA0A502CF3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{4B52F0CE-5F4C-43E7-A054-50CA0A502CF3}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{4B52F0CE-5F4C-43E7-A054-50CA0A502CF3}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{4B52F0CE-5F4C-43E7-A054-50CA0A502CF3}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{419C9F3D-71CC-4F95-8324-E15CD0D1E754}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{419C9F3D-71CC-4F95-8324-E15CD0D1E754}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{419C9F3D-71CC-4F95-8324-E15CD0D1E754}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{419C9F3D-71CC-4F95-8324-E15CD0D1E754}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{731CCC6D-2583-4CB0-A439-8173E9722E4D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{731CCC6D-2583-4CB0-A439-8173E9722E4D}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{731CCC6D-2583-4CB0-A439-8173E9722E4D}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{731CCC6D-2583-4CB0-A439-8173E9722E4D}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{9CFCED9A-7439-491A-8F24-827241280DA6}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{9CFCED9A-7439-491A-8F24-827241280DA6}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{9CFCED9A-7439-491A-8F24-827241280DA6}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{9CFCED9A-7439-491A-8F24-827241280DA6}.Release|Any CPU.Build.0 = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(NestedProjects) = preSolution\n\t\t{937E12C6-9E9E-438A-86C2-102E1D0C6826} = {DF4A161A-7C52-46A2-A0ED-427C1C6F29AA}\n\t\t{0ED3EBE5-1575-4649-A1F9-3D24BFFC4A9B} = {937E12C6-9E9E-438A-86C2-102E1D0C6826}\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {D5E147AF-721B-469D-AD77-A00A290340AC}\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "Microsoft.IO.RecyclableMemoryStream.sln.DotSettings",
          "type": "blob",
          "size": 11.1845703125,
          "content": "﻿<wpf:ResourceDictionary xml:space=\"preserve\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:s=\"clr-namespace:System;assembly=mscorlib\" xmlns:ss=\"urn:shemas-jetbrains-com:settings-storage-xaml\" xmlns:wpf=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\">\n\t<s:Boolean x:Key=\"/Default/CodeEditing/Intellisense/CodeCompletion/AutoCompleteBasicCompletion/@EntryValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/CodeEditing/Intellisense/CodeCompletion/IntelliSenseCompletingCharacters/CSharpCompletingCharacters/UpgradedFromVSSettings/@EntryValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/CodeEditing/Localization/CSharpLocalizationOptions/DontAnalyseVerbatimStrings/@EntryValue\">False</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/CodeInspection/ExcludedFiles/FileMasksToSkip/=_002A_002Emin_002Ejs/@EntryIndexedValue\">True</s:Boolean>\n\t<s:String x:Key=\"/Default/CodeStyle/CodeCleanup/Profiles/=Default/@EntryIndexedValue\">&lt;?xml version=\"1.0\" encoding=\"utf-16\"?&gt;&lt;Profile name=\"Default\"&gt;&lt;CSArrangeThisQualifier&gt;True&lt;/CSArrangeThisQualifier&gt;&lt;RemoveCodeRedundancies&gt;True&lt;/RemoveCodeRedundancies&gt;&lt;CSUseAutoProperty&gt;True&lt;/CSUseAutoProperty&gt;&lt;CSMakeFieldReadonly&gt;True&lt;/CSMakeFieldReadonly&gt;&lt;CSUseVar&gt;&lt;BehavourStyle&gt;CAN_CHANGE_BOTH&lt;/BehavourStyle&gt;&lt;LocalVariableStyle&gt;ALWAYS_IMPLICIT&lt;/LocalVariableStyle&gt;&lt;ForeachVariableStyle&gt;ALWAYS_IMPLICIT&lt;/ForeachVariableStyle&gt;&lt;/CSUseVar&gt;&lt;CSUpdateFileHeader&gt;True&lt;/CSUpdateFileHeader&gt;&lt;CSOptimizeUsings&gt;&lt;OptimizeUsings&gt;True&lt;/OptimizeUsings&gt;&lt;EmbraceInRegion&gt;False&lt;/EmbraceInRegion&gt;&lt;RegionName&gt;&lt;/RegionName&gt;&lt;/CSOptimizeUsings&gt;&lt;CSShortenReferences&gt;True&lt;/CSShortenReferences&gt;&lt;CSReformatCode&gt;True&lt;/CSReformatCode&gt;&lt;CSReorderTypeMembers&gt;True&lt;/CSReorderTypeMembers&gt;&lt;/Profile&gt;</s:String>\n\t<s:String x:Key=\"/Default/CodeStyle/CodeCleanup/RecentlyUsedProfile/@EntryValue\">Default</s:String>\n\t<s:String x:Key=\"/Default/CodeStyle/CodeCleanup/SilentCleanupProfile/@EntryValue\">Default: Reformat Code</s:String>\n\t<s:String x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpCodeStyle/ThisQualifier/INSTANCE_MEMBERS_QUALIFY_MEMBERS/@EntryValue\">All</s:String>\n\t<s:Boolean x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/ALIGN_FIRST_ARG_BY_PAREN/@EntryValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/ALIGN_LINQ_QUERY/@EntryValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/ALIGN_MULTILINE_ARGUMENT/@EntryValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/ALIGN_MULTILINE_ARRAY_AND_OBJECT_INITIALIZER/@EntryValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/ALIGN_MULTILINE_CALLS_CHAIN/@EntryValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/ALIGN_MULTILINE_EXPRESSION/@EntryValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/ALIGN_MULTILINE_EXTENDS_LIST/@EntryValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/ALIGN_MULTILINE_FOR_STMT/@EntryValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/ALIGN_MULTILINE_PARAMETER/@EntryValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/ALIGN_MULTIPLE_DECLARATION/@EntryValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/ALIGN_MULTLINE_TYPE_PARAMETER_CONSTRAINS/@EntryValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/ALIGN_MULTLINE_TYPE_PARAMETER_LIST/@EntryValue\">True</s:Boolean>\n\t<s:Int64 x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/BLANK_LINES_BETWEEN_USING_GROUPS/@EntryValue\">1</s:Int64>\n\t<s:Int64 x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/BLANK_LINES_INSIDE_REGION/@EntryValue\">0</s:Int64>\n\t<s:String x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/EMPTY_BLOCK_STYLE/@EntryValue\">TOGETHER_SAME_LINE</s:String>\n\t<s:String x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/FORCE_ATTRIBUTE_STYLE/@EntryValue\">JOIN</s:String>\n\t<s:String x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/FORCE_FIXED_BRACES_STYLE/@EntryValue\">ALWAYS_ADD</s:String>\n\t<s:String x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/FORCE_FOR_BRACES_STYLE/@EntryValue\">ALWAYS_ADD</s:String>\n\t<s:String x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/FORCE_FOREACH_BRACES_STYLE/@EntryValue\">ALWAYS_ADD</s:String>\n\t<s:String x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/FORCE_IFELSE_BRACES_STYLE/@EntryValue\">ALWAYS_ADD</s:String>\n\t<s:String x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/FORCE_USING_BRACES_STYLE/@EntryValue\">ALWAYS_ADD</s:String>\n\t<s:String x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/FORCE_WHILE_BRACES_STYLE/@EntryValue\">ALWAYS_ADD</s:String>\n\t<s:Boolean x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/INDENT_ANONYMOUS_METHOD_BLOCK/@EntryValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/INDENT_CASE_FROM_SWITCH/@EntryValue\">False</s:Boolean>\n\t<s:Int64 x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/KEEP_BLANK_LINES_IN_CODE/@EntryValue\">1</s:Int64>\n\t<s:Int64 x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/KEEP_BLANK_LINES_IN_DECLARATIONS/@EntryValue\">1</s:Int64>\n\t<s:Boolean x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/PLACE_FIELD_ATTRIBUTE_ON_SAME_LINE/@EntryValue\">False</s:Boolean>\n\t<s:String x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/REDUNDANT_THIS_QUALIFIER_STYLE/@EntryValue\">ALWAYS_USE</s:String>\n\t<s:Boolean x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/SPACE_AFTER_TYPECAST_PARENTHESES/@EntryValue\">False</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/SPACE_AROUND_MULTIPLICATIVE_OP/@EntryValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/SPACE_BEFORE_SIZEOF_PARENTHESES/@EntryValue\">False</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/SPACE_BEFORE_TYPEOF_PARENTHESES/@EntryValue\">False</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/CodeStyle/CodeFormatting/CSharpFormat/SPACE_WITHING_EMPTY_BRACES/@EntryValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/CodeStyle/CodeFormatting/JavaScriptCodeFormatting/ALIGN_MULTIPLE_DECLARATION/@EntryValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/CodeStyle/CodeFormatting/JavaScriptCodeFormatting/JavaScriptFormatOther/ALIGN_MULTIPLE_DECLARATION/@EntryValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/CodeStyle/CSharpUsing/AddImportsToDeepestScope/@EntryValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/CodeStyle/CSharpUsing/QualifiedUsingAtNestedScope/@EntryValue\">True</s:Boolean>\n\t<s:String x:Key=\"/Default/CodeStyle/FileHeader/FileHeaderText/@EntryValue\">The MIT License (MIT)&#xD;\n&#xD;\nCopyright (c) 2015-2016 Microsoft&#xD;\n&#xD;\nPermission is hereby granted, free of charge, to any person obtaining a copy&#xD;\nof this software and associated documentation files (the \"Software\"), to deal&#xD;\nin the Software without restriction, including without limitation the rights&#xD;\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell&#xD;\ncopies of the Software, and to permit persons to whom the Software is&#xD;\nfurnished to do so, subject to the following conditions:&#xD;\n&#xD;\nThe above copyright notice and this permission notice shall be included in all&#xD;\ncopies or substantial portions of the Software.&#xD;\n&#xD;\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#xD;\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#xD;\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE&#xD;\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#xD;\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&#xD;\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE&#xD;\nSOFTWARE.&#xD;\n</s:String>\n\t<s:String x:Key=\"/Default/CodeStyle/Naming/CSharpNaming/Abbreviations/=ETW/@EntryIndexedValue\">ETW</s:String>\n\t<s:String x:Key=\"/Default/CodeStyle/Naming/CSharpNaming/Abbreviations/=ID/@EntryIndexedValue\">ID</s:String>\n\t<s:String x:Key=\"/Default/CodeStyle/Naming/CSharpNaming/Abbreviations/=MB/@EntryIndexedValue\">MB</s:String>\n\t<s:String x:Key=\"/Default/CodeStyle/Naming/CSharpNaming/EventHandlerPatternLong/@EntryValue\">$object$_On$event$</s:String>\n\t<s:String x:Key=\"/Default/CodeStyle/Naming/CSharpNaming/PredefinedNamingRules/=PrivateInstanceFields/@EntryIndexedValue\">&lt;Policy Inspect=\"True\" Prefix=\"\" Suffix=\"\" Style=\"aaBb\" /&gt;</s:String>\n\t<s:String x:Key=\"/Default/CodeStyle/Naming/CSharpNaming/PredefinedNamingRules/=PrivateStaticFields/@EntryIndexedValue\">&lt;Policy Inspect=\"True\" Prefix=\"\" Suffix=\"\" Style=\"aaBb\" /&gt;</s:String>\n\t<s:String x:Key=\"/Default/CodeStyle/Naming/VBNaming/EventHandlerPatternLong/@EntryValue\">$object$_On$event$</s:String>\n\t<s:Boolean x:Key=\"/Default/Environment/SettingsMigration/IsMigratorApplied/=JetBrains_002EReSharper_002EPsi_002ECSharp_002ECodeStyle_002ESettingsUpgrade_002EAddAccessorOwnerDeclarationBracesMigration/@EntryIndexedValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/Environment/SettingsMigration/IsMigratorApplied/=JetBrains_002EReSharper_002EPsi_002ECSharp_002ECodeStyle_002ESettingsUpgrade_002EMigrateBlankLinesAroundFieldToBlankLinesAroundProperty/@EntryIndexedValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/Environment/SettingsMigration/IsMigratorApplied/=JetBrains_002EReSharper_002EPsi_002ECSharp_002ECodeStyle_002ESettingsUpgrade_002EMigrateThisQualifierSettings/@EntryIndexedValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/Environment/SettingsMigration/IsMigratorApplied/=JetBrains_002EReSharper_002EPsi_002EJavaScript_002ECodeStyle_002ESettingsUpgrade_002EJsCodeFormatterSettingsUpgrader/@EntryIndexedValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/Environment/SettingsMigration/IsMigratorApplied/=JetBrains_002EReSharper_002EPsi_002EJavaScript_002ECodeStyle_002ESettingsUpgrade_002EJsParsFormattingSettingsUpgrader/@EntryIndexedValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/Environment/SettingsMigration/IsMigratorApplied/=JetBrains_002EReSharper_002EPsi_002EJavaScript_002ECodeStyle_002ESettingsUpgrade_002EJsWrapperSettingsUpgrader/@EntryIndexedValue\">True</s:Boolean>\n\t<s:Boolean x:Key=\"/Default/PatternsAndTemplates/Todo/TodoPatterns/=06BB8EC17B74D2428417461A462291F5/@KeyIndexDefined\">True</s:Boolean>\n\t<s:String x:Key=\"/Default/PatternsAndTemplates/Todo/TodoPatterns/=06BB8EC17B74D2428417461A462291F5/Color/@EntryValue\">Blue</s:String>\n\t<s:Boolean x:Key=\"/Default/PatternsAndTemplates/Todo/TodoPatterns/=06BB8EC17B74D2428417461A462291F5/MatchComments/@EntryValue\">True</s:Boolean>\n\t<s:String x:Key=\"/Default/PatternsAndTemplates/Todo/TodoPatterns/=06BB8EC17B74D2428417461A462291F5/Name/@EntryValue\">FixMe</s:String>\n\t<s:String x:Key=\"/Default/PatternsAndTemplates/Todo/TodoPatterns/=06BB8EC17B74D2428417461A462291F5/Pattern/@EntryValue\">(?&lt;=\\W|^)(?&lt;TAG&gt;FIXME)(\\W|$)(.*)</s:String>\n\t<s:String x:Key=\"/Default/PatternsAndTemplates/Todo/TodoPatterns/=06BB8EC17B74D2428417461A462291F5/TodoIconStyle/@EntryValue\">Normal</s:String></wpf:ResourceDictionary>\n"
        },
        {
          "name": "NuGet.config",
          "type": "blob",
          "size": 0.4970703125,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<configuration>\n  <config>\n    <add key=\"repositoryPath\" value=\".\\src\\packages\" />\n  </config>\n  <packageRestore>\n    <add key=\"enabled\" value=\"True\" />\n    <add key=\"automatic\" value=\"True\" />\n  </packageRestore>\n  <activePackageSource>\n    <add key=\"All\" value=\"(Aggregate source)\" />\n  </activePackageSource>\n  <packageSources>\n    <clear />\n    <add\n      key=\"OSS_All\"\n      value=\"https://api.nuget.org/v3/index.json\"\n    />\n  </packageSources>\n</configuration>"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 21.244140625,
          "content": "# Microsoft.IO.RecyclableMemoryStream [![NuGet Version](https://img.shields.io/nuget/v/Microsoft.IO.RecyclableMemoryStream.svg?style=flat)](https://www.nuget.org/packages/Microsoft.IO.RecyclableMemoryStream/) \n\nA library to provide pooling for .NET `MemoryStream` objects to improve application performance, especially in the area of garbage collection.\n\n## Get Started\n\nInstall the latest version from [NuGet](https://www.nuget.org/packages/Microsoft.IO.RecyclableMemoryStream/)\n\n```\nInstall-Package Microsoft.IO.RecyclableMemoryStream\n```\n\n## Purpose\n\n`Microsoft.IO.RecyclableMemoryStream` is a `MemoryStream` replacement that offers superior behavior for performance-critical systems. In particular it is optimized to do the following:\n\n* Eliminate Large Object Heap allocations by using pooled buffers\n* Incur far fewer gen 2 GCs, and spend far less time paused due to GC\n* Avoid memory leaks by having a bounded pool size\n* Avoid memory fragmentation\n* Allow for multiple ways to read and write data that will avoid extraneous allocations\n* Provide excellent debuggability and logging\n* Provide metrics for performance tracking\n\n## Features\n\n- The semantics are close to the original `System.IO.MemoryStream` implementation, and is intended to be a drop-in replacement as much as possible.\n- Rather than pooling the streams themselves, the underlying buffers are pooled. This allows you to use the simple `Dispose` pattern to release the buffers back to the pool, as well as detect invalid usage patterns (such as reusing a stream after it’s been disposed).\n- `RecyclableMemoryStreamManager` is thread-safe (streams themselves are inherently NOT thread safe).\n- Implementation of `IBufferWrite<byte>`.\n- Support for enormous streams through abstracted buffer chaining.\n- Extensive support for newer memory-related types like `Span<byte>`, `ReadOnlySpan<byte>`, `ReadOnlySequence<byte>`, and `Memory<byte>`.\n- Each stream can be tagged with an identifying string that is used in logging - helpful when finding bugs and memory leaks relating to incorrect pool use.\n- Debug features like recording the call stack of the stream allocation to track down pool leaks\n- Maximum free pool size to handle spikes in usage without using too much memory.\n- Flexible and adjustable limits to the pooling algorithm.\n- Metrics tracking and events so that you can see the impact on the system.\n\n## Build Targets\n\nAt least MSBuild 16.8 is required to build the code. You get this with Visual Studio 2019.\n\nSupported build targets in v2.0 are: net462, netstandard2.0, netstandard2.1, and netcoreapp2.1 (net40, net45, net46 and netstandard1.4 were deprecated). Starting with v2.1, net5.0 target has been added.\n\n## Testing\n\nA minimum of .NET 5.0 is required for executing the unit tests. Requirements:\n- NUnit test adapter (VS Extension)\n- Be sure to set the default processor architecture for tests to x64 (or the giant allocation test will fail)\n\n## Benchmark tests\n\nThe results are available [here](https://microsoft.github.io/Microsoft.IO.RecyclableMemoryStream/dev/bench/)\n\n## Change Log\n\nRead the change log [here](https://github.com/microsoft/Microsoft.IO.RecyclableMemoryStream/blob/master/CHANGES.md).\n\n## How It Works\n\n`RecyclableMemoryStream` improves GC performance by ensuring that the larger buffers used for the streams are put into the gen 2 heap and stay there forever. This should cause full collections to happen less frequently. If you pick buffer sizes above 85,000 bytes, then you will ensure these are placed on the large object heap, which is touched even less frequently by the garbage collector.\n\nThe `RecyclableMemoryStreamManager` class maintains two separate pools of objects:\n\n1. **Small Pool** - Holds small buffers (of configurable size). Used by default for all normal read/write operations. Multiple small buffers are chained together in the `RecyclableMemoryStream` class and abstracted into a single stream.\n2. **Large Pool** - Holds large buffers, which are only used when you must have a single, contiguous buffer, such as when you plan to call `GetBuffer()`. It is possible to create streams larger than is possible to be represented by a single buffer because of .NET's array size limits.\n\nA `RecyclableMemoryStream` starts out by using a small buffer, chaining additional ones as the stream capacity grows. Should you ever call `GetBuffer()` and the length is greater than a single small buffer's capacity, then the small buffers are converted to a single large buffer. You can also request a stream with an initial capacity; if that capacity is larger than the small pool block size, multiple blocks will be chained unless you call an overload with `asContiguousBuffer` set to true, in which case a single large buffer will be assigned from the start. If you request a capacity larger than the maximum poolable size, you will still get a stream back, but the buffers will not be pooled. (Note: This is not referring to the maximum array size. You can limit the poolable buffer sizes in `RecyclableMemoryStreamManager`)\n\nThere are two versions of the large pool:\n\n* **Linear** (default) - You specify a multiple and a maximum size, and an array of buffers, from size (1 * multiple), (2 * multiple), (3 * multiple), ... maximum is created. For example, if you specify a multiple of 1 MB and maximum size of 8 MB, then you will have an array of length 8. The first slot will contain 1 MB buffers, the second slot 2 MB buffers, and so on.\n* **Exponential** - Instead of linearly growing, the buffers double in size for each slot. For example, if you specify a multiple of 256KB, and a maximum size of 8 MB, you will have an array of length 6, the slots containing buffers of size 256KB, 512KB, 1MB, 2MB, 4MB, and 8MB.\n\n![Pool Image Comparison](https://raw.githubusercontent.com/microsoft/Microsoft.IO.RecyclableMemoryStream/88e0deeabc11d7da4038329de5093c5a8d4c73be/poolcomparison.png)\n\nWhich one should you use? That depends on your usage pattern. If you have an unpredictable large buffer size, perhaps the linear one will be more suitable. If you know that a longer stream length is unlikely, but you may have a lot of streams in the smaller size, picking the exponential version could lead to less overall memory usage (which was the reason this form was added).\n\nBuffers are created, on demand, the first time they are requested and nothing suitable already exists in the pool. After use, these buffers will be returned to the pool through the `RecyclableMemoryStream`'s `Dispose` method. When that return happens, the `RecyclableMemoryStreamManager` will use the properties `MaximumFreeSmallPoolBytes` and `MaximumFreeLargePoolBytes` to determine whether to put those buffers back in the pool, or let them go (and thus be garbage collected). It is through these properties that you determine how large your pool can grow. If you set these to 0, you can have unbounded pool growth, which is essentially indistinguishable from a memory leak. For every application, you must determine through analysis and experimentation the appropriate balance between pool size and garbage collection.\n\nIf you forget to call a stream's `Dispose` method, this could cause a memory leak. To help you prevent this, each stream has a finalizer that will be called by the CLR once there are no more references to the stream. This finalizer will raise an event or log a message about the leaked stream.\n\nNote that for performance reasons, the buffers are not ever pre-initialized or zeroed-out. It is your responsibility to ensure their contents are valid and safe to use buffer recycling.\nIf you want to avoid accidental data leakage, you can set `ZeroOutBuffer` to true. This will zero out the buffers on allocation and before returning them to the pool. Be aware of the performance implications.\n\n## Usage\n\nYou can jump right in with no fuss by just doing a simple replacement of `MemoryStream` with something like this:\n\n```csharp\nclass Program\n{\n    private static readonly RecyclableMemoryStreamManager manager = new RecyclableMemoryStreamManager();\n\n    static void Main(string[] args)\n    {\n        var sourceBuffer = new byte[] { 0, 1, 2, 3, 4, 5, 6, 7 };\n        \n        using (var stream = manager.GetStream())\n        {\n            stream.Write(sourceBuffer, 0, sourceBuffer.Length);\n        }\n    }\n}\n```\n| **_IMPORTANT_** | Note that `RecyclableMemoryStreamManager` should be declared once and it will live for the entire process lifetime. It is perfectly fine to use multiple pools if you desire, especially if you want to configure them differently.|\n|-|:-|\n\nTo facilitate easier debugging, you can optionally provide a string `tag`, which serves as a human-readable identifier for the stream. This can be something like “ClassName.MethodName”, but it can be whatever you want. Each stream also has a GUID to provide absolute identity if needed, but the `tag` is usually sufficient.\n\n```csharp\nusing (var stream = manager.GetStream(\"Program.Main\"))\n{\n    stream.Write(sourceBuffer, 0, sourceBuffer.Length);\n}\n```\n\nYou can also provide an existing buffer. It’s important to note that the data from this buffer will be *copied* into a buffer owned by the pool:\n\n```csharp\nvar stream = manager.GetStream(\"Program.Main\", sourceBuffer, \n                                    0, sourceBuffer.Length);\n```\n\nYou can also change the parameters of the pool itself:\n\n```csharp\nvar options = new RecyclableMemoryStreamManager.Options()\n{\n    BlockSize = 1024,\n    LargeBufferMultiple = 1024 * 1024,\n    MaximumBufferSize = 16 * 1024 * 1024,\n    GenerateCallStacks = true,\n    AggressiveBufferReturn = true,\n    MaximumLargePoolFreeBytes = 16 * 1024 * 1024 * 4,\n    MaximumSmallPoolFreeBytes = 100 * 1024,\n};\n\nvar manager = new RecyclableMemoryStreamManager(options);\n```\n\nYou should usually set at least `BlockSize`, `LargeBufferMultiple`, `MaximumBufferSize`, `MaximumLargePoolFreeBytes`, and `MaximumSmallPoolFreeBytes` because their appropriate values are highly dependent on the application.\n\n### Usage Guidelines\n\nWhile this library strives to be very general and not impose too many restraints on how you use it, its purpose is to reduce the cost of garbage collections incurred by frequent large allocations. Thus, there are some general guidelines for usage that may be useful to you:\n\n1. Set the `BlockSize`, `LargeBufferMultiple`, `MaximumBufferSize`, `MaximumLargePoolFreeBytes` and `MaximumSmallPoolFreeBytes` properties to reasonable values for your application and resource requirements. **Important!**: If you do not set `MaximumFreeLargePoolBytes` and `MaximumFreeSmallPoolBytes` there is the possibility for unbounded memory growth!\n2. Always dispose of each stream exactly once.\n3. Most applications should not call `ToArray` and should avoid calling `GetBuffer` if possible. Instead, use `GetReadOnlySequence` for reading and the `IBufferWriter` methods `GetSpan`\\\\`GetMemory` with `Advance` for writing. There are also miscellaneous `CopyTo` and `WriteTo` methods that may be convenient. The point is to avoid creating unnecessary GC pressure where possible.\n4. Experiment to find the appropriate settings for your scenario.\n\nA working knowledge of the garbage collector is a very good idea before you try to optimize your scenario with this library. An article such as [Garbage Collection](https://docs.microsoft.com/dotnet/standard/garbage-collection/), or a book like *Writing High-Performance .NET Code* will help you understand the design principles of this library.\n\nWhen configuring the options, consider questions such as these:\n\n* What is the distribution of stream lengths that I expect?\n* How many streams will be in use at one time?\n* Is `GetBuffer` called a lot? How much use of large pool buffers will I need?\n* How resilient to spikes in activity do I need to be? i.e., How many free bytes should I keep around in case?\n* What are my physical memory limitations on the machines where this will be used?\n\n### IBufferWriter\\<byte\\>: GetMemory, GetSpan, and Advance ###\n\n`RecyclableMemoryStream` implements [IBufferWriter<byte>](https://docs.microsoft.com/en-us/dotnet/api/system.buffers.ibufferwriter-1?view=netstandard-2.1) so it can be used for zero-copy encoding and formatting. You can also directly modify the stream contents using `GetSpan`\\\\`GetMemory` with `Advance`. For instance, writing a `BigInteger` to a stream:\n\n```csharp\nvar bigInt = BigInteger.Parse(\"123456789013374299100987654321\");\n\nusing (var stream = manager.GetStream())\n{\n    Span<byte> buffer = stream.GetSpan(bigInt.GetByteCount());\n    bigInt.TryWriteBytes(buffer, out int bytesWritten);\n    stream.Advance(bytesWritten);\n}\n```\n\n### GetReadOnlySequence ###\n\n`GetReadOnlySequence` returns a [ReadOnlySequence<byte>](https://docs.microsoft.com/en-us/dotnet/api/system.buffers.readonlysequence-1?view=netstandard-2.1) that can be used for zero-copy stream processing. For example, hashing the contents of a stream: \n\n```csharp\nusing (var stream = manager.GetStream())\nusing (var sha256Hasher = IncrementalHash.CreateHash(HashAlgorithmName.SHA256))\n{\n    foreach (var memory in stream.GetReadOnlySequence())\n    {\n        sha256Hasher.AppendData(memory.Span);\n    }\n    \n    sha256Hasher.GetHashAndReset();\n}\n```\n\n### GetBuffer and ToArray ###\n\n`RecyclableMemoryStream` is designed to operate primarily on chained small pool blocks. To access these blocks use `GetReadOnlySequence` for reading and `GetSpan`\\\\`GetMemory` with `Advance` for writing. However, if you still want a contiguous buffer for the whole stream there are two APIs which `RecyclableMemoryStream` overrides from its parent `MemoryStream` class:\n\n* `GetBuffer` - If possible, a reference to the single block will be returned to the caller. If multiple blocks are in use, they will be converted into a single large pool buffer and the data copied into it. In all cases, the caller must use the `Length` property to determine how much usable data is actually in the returned buffer. If the stream length is longer than the maximum allowable stream size, a single buffer will still be returned, but it will not be pooled. If no possible contiguous buffer can be returned due to .NET array-size limitations, then an `OutOfMemoryException` will be thrown.\n* `ToArray` - It looks similar to `GetBuffer` on the surface, but is actually significantly different. In `ToArray` the data is *always* copied into a new array that is exactly the right length for the full contents of the stream. This new buffer is never pooled. Users of this library should consider any call to `ToArray` to be a bug, as it wipes out many of the benefits of `RecyclableMemoryStream` completely. However, the method is included for completeness, especially if you are calling other APIs that only take a `byte` array with no length parameter. An event is logged on all `ToArray` calls.\n\nYou can optionally configure the `RecyclableStreamManager.ThrowExceptionOnToArray` property to disallow calls to `RecyclableMemoryStream.ToArray`. If this value is set to true, then any calls to `ToArray` will result in a `NotSupportedException`.\n\n## Metrics and Hooks\n\n### ETW Events ###\n\n`RecyclableMemoryStream` has an `EventSource` provider that produces a number of events for tracking behavior and performance. You can use events to debug leaks or subtle problems with pooled stream usage.\n\n| Name | Level | Description |\n| -----|-------|-------------|\n| MemoryStreamCreated | Verbose | Logged every time a stream object is allocated. Fields: `guid`, `tag`, `requestedSize`, `actualSize`. |\n| MemoryStreamDisposed | Verbose | Logged every time a stream object is disposed. Fields: `guid`, `tag`, `allocationStack`, `disposeStack`. |\n| MemoryStreamDoubleDispose | Critical | Logged if a stream is disposed more than once. This indicates a logic error by the user of the stream. Dispose should happen exactly once per stream to avoid resource usage bugs. Fields: `guid`, `tag`, `allocationStack`, `disposeStack1`, `disposeStack2`. |\n| MemoryStreamFinalized | Error | Logged if a stream has gone out of scope without being disposed. This indicates a resource leak. Fields: `guid`, `tag`, `allocationStack`.|\n| MemoryStreamToArray | Verbose | Logged whenever `ToArray` is called. This indicates a potential problem, as calling `ToArray` goes against the concepts of good memory practice which `RecyclableMemoryStream` is trying to solve. Fields: `guid`, `tag`, `stack`, `size`.|\n| MemoryStreamManagerInitialized| Informational | Logged when the `RecyclableMemoryStreamManager` is initialized. Fields: `blockSize`, `largeBufferMultiple`, `maximumBufferSize`.|\n| MemoryStreamNewBlockCreated | Verbose | Logged whenever a block for the small pool is created. Fields: `smallPoolInUseBytes`.|\n| MemoryStreamNewLargeBufferCreated | Verbose | Logged whenever a large buffer is allocated. Fields: `requiredSize`, `largePoolInUseBytes`.|\n| MemoryStreamNonPooledLargeBufferCreated | Verbose | Logged whenever a buffer is requested that is larger than the maximum pooled size. The buffer is still created and returned to the user, but it can not be re-pooled. Fields: `guid`, `tag`, `requiredSize`, `allocationStack`. |\n| MemoryStreamDiscardBuffer | Warning | Logged whenever a buffer is discarded rather than put back in the pool. Fields: `guid`, `tag`, `bufferType` (`Small`, `Large`), `reason` (`TooLarge`, `EnoughFree`). |\n| MemoryStreamOverCapacity | Error | Logged whenever an attempt is made to set the capacity of the stream beyond the limits of `RecyclableMemoryStreamManager.MaximumStreamCapacity`, if such a limit is set. Fields: `guid`, `tag`, `requestedCapacity`, `maxCapacity`, `allocationStack`.|\n\n### Event Hooks ###\n\nIn addition to the logged ETW events, there are a number of .NET event hooks on `RecyclableMemoryStreamManager` that you can use as triggers for your own custom actions:\n\n| Name | Description |\n|---------|------------|\n| `BlockCreated` | A new small pool block has been allocated. |\n| `BufferDiscarded` | A buffer has been refused re-entry to the pool and given over to the garbage collector. |\n| `LargeBufferCreated` | A large buffer has been allocated. |\n| `StreamCreated` | A new stream has been created. |\n| `StreamDisposed` | A stream has been disposed. |\n| `StreamDoubleDisposed` | A stream has been disposed twice, indicating an error. |\n| `StreamFinalized` | A stream has been finalized, which means it was never disposed before it went out of scope. |\n| `StreamLength` | Reports the stream's length upon disposal. Can allow you to track stream metrics. |\n| `StreamConvertedToArray` | Someone called `ToArray` on a stream. |\n| `StreamOverCapacity` | An attempt was made to expand beyond the maximum capacity allowed by the pool manager. |\n| `UsageReport` | Provides stats on pool usage for metrics tracking. |\n\n## Debugging Problems\n\nOnce you start introducing re-usable resources like the pooled buffers in `RecyclableMemoryStream`, you are taking some of the duties of the CLR away from it and reserving them for yourself. This can be error-prone. See the Usage section above for some guidelines on making your usage of this library successful.\n\nThere are a number of features that will help you debug usage of these streams.\n\n### Stream Identification ###\n\nEach stream is assigned a unique GUID and, optionally, a `tag`.\n\nThe GUID is unique for each stream object and serves to identify that stream throughout its lifetime.\n\nA `tag` is an optional, arbitrary string assigned by the caller when a stream is requested. This can be a class name, function name, or some other meaningful string that can help you identify the source of the stream's usage. Note that multiple streams will contain the same tag. They identify where in your code the stream originated; they are not unique stream identifiers.\n\n### Callstack Recording ###\n\nIf you set the `GenerateCallStacks` property on `RecyclableMemoryStreamManager` to true, then major operations on the stream, such as allocation and disposal, will record the call stack of those method calls. These will be reported in ETW events in the event of detected programming errors such as double-dispose or finalization. \n\nTurning this feature on causes a very significant negative performance impact, so should only be done when actively investigating a problem.\n\n### Double-Dispose Protection ###\n\nIf `Dispose` is called twice on the same stream, an event is logged with the relevant stream's information. If `GenerateCallStacks` is turned on, this will include the call stacks for allocation and both disposals.\n\n### Non-Dispose Detection ###\n\nIf `Dispose` is never called for a stream, the finalizer will eventually be called by the CLR, and an event will be logged with relevant stream information, including the allocation stack, if enabled. Buffers for finalized streams are lost to the pool, and this should be considered a bug.\n\n### Concurrency\n\nConcurrent use of `RecyclableMemoryStream` objects is not supported under any circumstances. However, `RecyclableMemoryStreamManager` is thread-safe and can be used to retrieve streams in a multi-threading scenario.\n\n### ETW Events ###\n\nUse an ETW event monitor such as [PerfView](https://www.microsoft.com/download/details.aspx?id=28567) to collect and analyze ETW events.\n\nMany of these events contain helpful clues about the stream in question, including its tag, guid, and stacks (if enabled).\n\n## Reference\n\nRead the API documentation [here](https://github.com/microsoft/Microsoft.IO.RecyclableMemoryStream/blob/master/docs/Microsoft.IO.RecyclableMemoryStream.md).\n\n## License\n\nThis library is released under the [MIT license](https://github.com/microsoft/Microsoft.IO.RecyclableMemoryStream/blob/master/LICENSE).\n\n## Support\n\nCheck the support policy [here](SUPPORT.md)\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 2.6923828125,
          "content": "<!-- BEGIN MICROSOFT SECURITY.MD V0.0.7 BLOCK -->\n\n## Security\n\nMicrosoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include [Microsoft](https://github.com/Microsoft), [Azure](https://github.com/Azure), [DotNet](https://github.com/dotnet), [AspNet](https://github.com/aspnet), [Xamarin](https://github.com/xamarin), and [our GitHub organizations](https://opensource.microsoft.com/).\n\nIf you believe you have found a security vulnerability in any Microsoft-owned repository that meets [Microsoft's definition of a security vulnerability](https://aka.ms/opensource/security/definition), please report it to us as described below.\n\n## Reporting Security Issues\n\n**Please do not report security vulnerabilities through public GitHub issues.**\n\nInstead, please report them to the Microsoft Security Response Center (MSRC) at [https://msrc.microsoft.com/create-report](https://aka.ms/opensource/security/create-report).\n\nIf you prefer to submit without logging in, send email to [secure@microsoft.com](mailto:secure@microsoft.com).  If possible, encrypt your message with our PGP key; please download it from the [Microsoft Security Response Center PGP Key page](https://aka.ms/opensource/security/pgpkey).\n\nYou should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at [microsoft.com/msrc](https://aka.ms/opensource/security/msrc). \n\nPlease include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue:\n\n  * Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.)\n  * Full paths of source file(s) related to the manifestation of the issue\n  * The location of the affected source code (tag/branch/commit or direct URL)\n  * Any special configuration required to reproduce the issue\n  * Step-by-step instructions to reproduce the issue\n  * Proof-of-concept or exploit code (if possible)\n  * Impact of the issue, including how an attacker might exploit the issue\n\nThis information will help us triage your report more quickly.\n\nIf you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our [Microsoft Bug Bounty Program](https://aka.ms/opensource/security/bounty) page for more details about our active programs.\n\n## Preferred Languages\n\nWe prefer all communications to be in English.\n\n## Policy\n\nMicrosoft follows the principle of [Coordinated Vulnerability Disclosure](https://aka.ms/opensource/security/cvd).\n\n<!-- END MICROSOFT SECURITY.MD BLOCK -->\n"
        },
        {
          "name": "SUPPORT.md",
          "type": "blob",
          "size": 0.4287109375,
          "content": "# Support\n\n## How to file issues and get help  \n\nThis project uses GitHub Issues to track bugs and feature requests. Please search the existing\nissues before filing new issues to avoid duplicates.  For new issues, file your bug or\nfeature request as a new Issue.\n\nFor help and questions about using this project, please submit a new Issue.\n\n## Microsoft Support Policy  \n\nSupport for this project is limited to the resources listed above.\n"
        },
        {
          "name": "UnitTests",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "generatedocs.cmd",
          "type": "blob",
          "size": 0.3359375,
          "content": "@ECHO OFF\nECHO ===========================================================\nECHO Using xmldocmd from https://github.com/ejball/XmlDocMarkdown\nECHO ===========================================================\n\ndel /q /s docs\\*\n\nxmldocmd .\\src\\bin\\Release\\netstandard2.1\\Microsoft.IO.RecyclableMemoryStream.dll .\\docs --obsolete --clean\n\nECHO Done."
        },
        {
          "name": "global.json",
          "type": "blob",
          "size": 0.076171875,
          "content": "{\n  \"sdk\": {\n    \"version\": \"8.0.100\",\n    \"rollForward\": \"latestMinor\"\n  }\n}\n"
        },
        {
          "name": "poolcomparison.png",
          "type": "blob",
          "size": 28.78515625,
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}