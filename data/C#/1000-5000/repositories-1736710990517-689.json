{
  "metadata": {
    "timestamp": 1736710990517,
    "page": 689,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jadepeng/XMusicDownloader",
      "stars": 1716,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 5.419921875,
          "content": "## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n##\n## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore\n\n# User-specific files\n*.suo\n*.user\n*.userosscache\n*.sln.docstates\n*.zip\n\n# User-specific files (MonoDevelop/Xamarin Studio)\n*.userprefs\n\n# Build results\n[Dd]ebug/\n[Dd]ebugPublic/\nbld/\n[Oo]bj/\n\n# Visual Studio 2015/2017 cache/options directory\n.vs/\n# Uncomment if you have tasks that create the project's static files in wwwroot\n#wwwroot/\n\n# Visual Studio 2017 auto generated files\nGenerated\\ Files/\n\n# MSTest test Results\n[Tt]est[Rr]esult*/\n[Bb]uild[Ll]og.*\n\n# NUNIT\n*.VisualState.xml\nTestResult.xml\n\n# Build Results of an ATL Project\n[Dd]ebugPS/\n[Rr]eleasePS/\ndlldata.c\n\n# Benchmark Results\nBenchmarkDotNet.Artifacts/\n\n# .NET Core\nproject.lock.json\nproject.fragment.lock.json\nartifacts/\n\n# StyleCop\nStyleCopReport.xml\n\n# Files built by Visual Studio\n*_i.c\n*_p.c\n*_h.h\n*.ilk\n*.meta\n*.obj\n*.iobj\n*.pch\n*.pdb\n*.ipdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.tmp_proj\n*.log\n*.vspscc\n*.vssscc\n.builds\n*.pidb\n*.svclog\n*.scc\n\n# Chutzpah Test files\n_Chutzpah*\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opendb\n*.opensdf\n*.sdf\n*.cachefile\n*.VC.db\n*.VC.VC.opendb\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n*.sap\n\n# Visual Studio Trace Files\n*.e2e\n\n# TFS 2012 Local Workspace\n$tf/\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*/\n*.[Rr]e[Ss]harper\n*.DotSettings.user\n\n# JustCode is a .NET coding add-in\n.JustCode\n\n# TeamCity is a build add-in\n_TeamCity*\n\n# DotCover is a Code Coverage Tool\n*.dotCover\n\n# AxoCover is a Code Coverage Tool\n.axoCover/*\n!.axoCover/settings.json\n\n# Visual Studio code coverage results\n*.coverage\n*.coveragexml\n\n# NCrunch\n_NCrunch_*\n.*crunch*.local.xml\nnCrunchTemp_*\n\n# MightyMoose\n*.mm.*\nAutoTest.Net/\n\n# Web workbench (sass)\n.sass-cache/\n\n# Installshield output folder\n[Ee]xpress/\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish/\n\n# Publish Web Output\n*.[Pp]ublish.xml\n*.azurePubxml\n# Note: Comment the next line if you want to checkin your web deploy settings,\n# but database connection strings (with potential passwords) will be unencrypted\n*.pubxml\n*.publishproj\n\n# Microsoft Azure Web App publish settings. Comment the next line if you want to\n# checkin your Azure Web App publish settings, but sensitive information contained\n# in these scripts will be unencrypted\nPublishScripts/\n\n# NuGet Packages\n*.nupkg\n# The packages folder can be ignored because of Package Restore\n**/[Pp]ackages/*\n# except build/, which is used as an MSBuild target.\n!**/[Pp]ackages/build/\n# Uncomment if necessary however generally it will be regenerated when needed\n#!**/[Pp]ackages/repositories.config\n# NuGet v3's project.json files produces more ignorable files\n*.nuget.props\n*.nuget.targets\n\n# Microsoft Azure Build Output\ncsx/\n*.build.csdef\n\n# Microsoft Azure Emulator\necf/\nrcf/\n\n# Windows Store app package directories and files\nAppPackages/\nBundleArtifacts/\nPackage.StoreAssociation.xml\n_pkginfo.txt\n*.appx\n\n# Visual Studio cache files\n# files ending in .cache can be ignored\n*.[Cc]ache\n# but keep track of directories ending in .cache\n!*.[Cc]ache/\n\n# Others\nClientBin/\n~$*\n*~\n*.dbmdl\n*.dbproj.schemaview\n*.jfm\n*.pfx\n*.publishsettings\norleans.codegen.cs\n\n# Including strong name files can present a security risk\n# (https://github.com/github/gitignore/pull/2483#issue-259490424)\n#*.snk\n\n# Since there are multiple workflows, uncomment next line to ignore bower_components\n# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)\n#bower_components/\n\n# RIA/Silverlight projects\nGenerated_Code/\n\n# Backup & report files from converting an old project file\n# to a newer Visual Studio version. Backup files are not needed,\n# because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\nUpgradeLog*.htm\nServiceFabricBackup/\n*.rptproj.bak\n\n# SQL Server files\n*.mdf\n*.ldf\n*.ndf\n\n# Business Intelligence projects\n*.rdl.data\n*.bim.layout\n*.bim_*.settings\n*.rptproj.rsuser\n\n# Microsoft Fakes\nFakesAssemblies/\n\n# GhostDoc plugin setting file\n*.GhostDoc.xml\n\n# Node.js Tools for Visual Studio\n.ntvs_analysis.dat\nnode_modules/\n\n# Visual Studio 6 build log\n*.plg\n\n# Visual Studio 6 workspace options file\n*.opt\n\n# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)\n*.vbw\n\n# Visual Studio LightSwitch build output\n**/*.HTMLClient/GeneratedArtifacts\n**/*.DesktopClient/GeneratedArtifacts\n**/*.DesktopClient/ModelManifest.xml\n**/*.Server/GeneratedArtifacts\n**/*.Server/ModelManifest.xml\n_Pvt_Extensions\n\n# Paket dependency manager\n.paket/paket.exe\npaket-files/\n\n# FAKE - F# Make\n.fake/\n\n# JetBrains Rider\n.idea/\n*.sln.iml\n\n# CodeRush\n.cr/\n\n# Python Tools for Visual Studio (PTVS)\n__pycache__/\n*.pyc\n\n# Cake - Uncomment if you are using it\n# tools/**\n# !tools/packages.config\n\n# Tabs Studio\n*.tss\n\n# Telerik's JustMock configuration file\n*.jmconfig\n\n# BizTalk build output\n*.btp.cs\n*.btm.cs\n*.odx.cs\n*.xsd.cs\n\n# OpenCover UI analysis results\nOpenCover/\n\n# Azure Stream Analytics local run output\nASALocalRun/\n\n# MSBuild Binary and Structured Log\n*.binlog\n\n# NVidia Nsight GPU debugger configuration file\n*.nvuser\n\n# MFractors (Xamarin productivity tool) working folder\n.mfractor/\n\n# Local History for Visual Studio\n.localhistory/\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 15.119140625,
          "content": "# XMusicDownloader\n\nXMusicDownloader，一款 支持从百度、网易、qq和酷狗、咪咕音乐等音乐网站搜索并下载歌曲的程序。\n\n开源音乐下载神器XMusicDownloader更新啦，新增网易、腾讯音乐歌单歌曲、歌手歌曲、专辑歌曲一键下载，同时支持下载flac无损音乐。\n\n## 功能\n\nV1.0 功能[开源工具软件XMusicDownloader——音乐下载神器](https://www.cnblogs.com/xiaoqi/p/xmusicdownloader.html)\n* 聚合搜索多家音乐网站\n* 支持音乐批量下载\n* 搜索结果综合排序\n* 可以编写Provider程序，支持其他音乐网站\n\nV1.1 新增功能支持歌单、专辑、歌手歌曲下载，支持无损下载\n+ 支持歌单、专辑、歌手歌曲下载（腾讯、网易）\n+ 支持flac无损、320,128 码率下载\n\n![V1.1截图](https://github.com/jadepeng/XMusicDownloader/raw/master/v1.1.png)\n\n## 关联软件\n\n### 网易云音乐歌单收费歌曲补全工具\n\n![界面](https://gitee.com/jadepeng/pic/raw/master/pic/2020/8/25/1598352954630.png)\n\n原理以及使用方法见： https://www.cnblogs.com/xiaoqi/p/music163tool.html\n\n\n## 扩展功能说明\n\n主要是调用了一个[第三方接口](https://www.bzqll.com/2019/04/318.html)实现歌单、歌手和专辑歌曲读取，以及获取真实下载地址。\n\n### 扩展provider接口，增加获取歌曲列表接口\n\n增加Support接口判断url地址是否是歌单地址，增加GetSongList用于获取歌单的歌曲列表，增加getDownloadUrl(string id, string rate)获取歌曲下载地址。\n\n```\npublic interface IMusicProvider\n    {\n        string Name { get; }\n\n        string getDownloadUrl(Song song);\n        List<Song> SearchSongs(string keyword, int page, int pageSize);\n\n        // 歌单\n        bool Support(string url);\n        List<Song> GetSongList(string url);\n        /// <summary>\n        /// 获取下载地址\n        /// </summary>\n        /// <param name=\"id\">歌曲id</param>\n        /// <param name=\"rate\">码率，音质 如果最大音质获取出错则自动转其他音质\t</param>\n        /// <returns>歌曲下载地址</returns>\n        string getDownloadUrl(string id, string rate);\n    }\n```\n\n### 实现provider\n\n以QQ为例：\n\n先判断是否是支持的url，主要是判断是否符合歌单、专辑、歌手的url格式。\n\n```\n        // 歌单： https://y.qq.com/n/yqq/playsquare/6924336223.html#stat=y_new.playlist.dissname\n        // 专辑 https://y.qq.com/n/yqq/album/00153q8l2vldMz.html\n        // 歌手 https://y.qq.com/n/yqq/singer/000CK5xN3yZDJt.html\n\n        Regex regex = new Regex(\"\\\\/(\\\\w+).html\");\n        public bool Support(string url)\n        {\n            if (url == null)\n            {\n                return false;\n            }\n\n            if (!regex.IsMatch(url))\n            {\n                return false;\n            }\n\n            return url.StartsWith(\"https://y.qq.com/n/yqq/playsquare\") || url.StartsWith(\"https://y.qq.com/n/yqq/album\") || url.StartsWith(\"https://y.qq.com/n/yqq/singer\");\n        } \n\n```\n\n然后调用itooi.cn的api获取歌曲\n\n- 歌单接口 `https://v1.itooi.cn/tencent/songList?id=`\n- 歌手歌曲接口 `https://v1.itooi.cn/tencent/song/artist?id=`\n- 专辑歌曲接口 `https://v1.itooi.cn/tencent/album?id=`\n\n```\n public List<Song> GetSongList(string url)\n        {\n            var isSongList = url.StartsWith(\"https://y.qq.com/n/yqq/playsquare\");\n\n            var id = regex.Match(url).Groups[1].Value;\n\n            var result = new List<Song>();\n\n            if (isSongList)\n            {\n                GetSongListDetail(id, result);\n            }\n            else if (url.StartsWith(\"https://y.qq.com/n/yqq/albu\"))\n            {\n                GetAlbum(id, result);\n            }\n            else\n            {\n                GetSingerSong(id, result);\n            }\n\n\n            return result;\n\n        }\n\n        private void GetSongListDetail(string id, List<Song> result)\n        {\n            var requestUrl = \"https://v1.itooi.cn/tencent/songList?id=\" + id;\n            var searchResult = HttpHelper.GET(requestUrl, DEFAULT_CONFIG);\n\n            var songList = JObject.Parse(searchResult)[\"data\"][0][\"songlist\"];\n            var index = 1;\n\n            foreach (var songItem in songList)\n            {\n                var song = new Song\n                {\n                    id = (string)songItem[\"songmid\"],\n                    name = (string)songItem[\"title\"],\n                    album = (string)songItem[\"album\"][\"name\"],\n                    rate = 320,\n                    index = index++,\n                    size = (double)songItem[\"file\"][\"size_320mp3\"],\n                    source = Name,\n                    //singer = (string)songItem[\"author\"],\n                    duration = (double)songItem[\"interval\"]\n                };\n                if (song.size == 0d)\n                {\n                    song.size = (double)songItem[\"file\"][\"size_128mp3\"];\n                    song.rate = 128;\n                }\n                song.singer = \"\";\n                foreach (var ar in songItem[\"singer\"])\n                {\n                    song.singer += ar[\"name\"] + \" \";\n                }\n                result.Add(song);\n\n            }\n        }\n```\n\n最后获取下载地址，接口地址是`https://v1.itooi.cn/tencent/url?id=${id}&quality=[128,320,flac]`\n\n```\n public string getDownloadUrl(string id, string rate)\n        {\n            return HttpHelper.DetectLocationUrl(\"https://v1.itooi.cn/tencent/url?id=\" + id + \"&quality=\" + rate, DEFAULT_CONFIG);\n        }\n```\n\n这里要检测下真实url，递归检测302跳转：\n\n```\n public static string DetectLocationUrl(string url, HttpConfig config)\n        {\n            if (config == null) config = new HttpConfig();\n            using (HttpWebResponse response = GetResponse(url, \"GET\", null, config))\n            {\n                string detectUrl =  response.GetResponseHeader(\"Location\");\n                if(detectUrl.Length == 0)\n                {\n                    return url;\n                }\n                // 递归获取\n                return DetectLocationUrl(detectUrl, config);\n            }\n        }\n```\n\n\n\n缘起：\n\n一直用网易音乐听歌，但是诸如李健、周杰伦的不少歌曲，网易都没有版权，要从QQ等音乐去下载，因此一直想写一个小程序，可以从其他音乐网站下载相关歌曲，趁放假，花了几小时做了这样一个程序。\n\nBTW: 之前写过一个[从酷狗和网易音乐提取缓存文件的程序](https://github.com/jadepeng/musicDecryptor)，感兴趣的可以查看。\n\n## 功能\n\n* 聚合搜索多家音乐网站\n* 支持音乐批量下载\n* 搜索结果综合排序\n* 可以编写Provider程序，支持其他音乐网站\n\n实现IMusicProvider即可，主要是搜索和获取下载链接的方法。\n\n\n``` csharp?linenums\n    public interface IMusicProvider\n    {\n        string Name { get; }\n\n        string getDownloadUrl(Song song);\n        List<Song> SearchSongs(string keyword, int page, int pageSize);\n    }\n```\n\n\n## 界面截图\n\n![预览](https://www.github.com/jadepeng/blogpic/raw/master/images/2019/1-25/1548431781568.png)\n\n## 下载程序\n\nhttps://github.com/jadepeng/XMusicDownloader/releases\n\n## 实现方案介绍\n\n### 定义song实体\n\n``` javascript\npublic class Song\n    {\n        public string id { get; set; }\n        public string name { get; set; }\n        public string singer { get; set; }\n        public string album { get; set; }\n        public string source { get; set; }\n        public double duration { get; set; }\n        public double size { get; set; }\n        public string url { get; set; }\n        public int rate { get; set; }\n        public int index { get; set; }\n\n        public string getFileName()\n        {\n            return singer + \"-\" + name + \".mp3\";\n        }\n\n        public string getMergedKey()\n        {\n            return singer.Replace(\" \", \"\") + name.Replace(\" \", \"\");\n        }\n    }\n```\n\n### 封装各个音乐网站\n\n抽象为MusicProvider，音乐提供方:)，定义Name为名称，SearchSongs搜索歌曲，getDownloadUrl获取音乐下载地址。\n\n``` c#\n\n    public interface IMusicProvider\n    {\n        string Name { get; }\n\n        string getDownloadUrl(Song song);\n        List<Song> SearchSongs(string keyword, int page, int pageSize);\n    }\n```\n\n然后就是依次实现百度、网易等音乐网站，以QQ为例。\n\n\n``` csharp\n public class QQProvider : IMusicProvider\n    {\n        static HttpConfig DEFAULT_CONFIG = new HttpConfig\n        {\n            Referer = \"http://m.y.qq.com\",\n\n        };\n\n        public string Name { get; } = \"QQ\";\n\n        static string[] prefixes = new string[] { \"M800\", \"M500\", \"C400\" };\n\n        public List<Song> SearchSongs(string keyword,int page,int pageSize)\n        {\n            var searchResult = HttpHelper.GET(string.Format(\"http://c.y.qq.com/soso/fcgi-bin/search_for_qq_cp?w={0}&format=json&p={1}&n={2}\", keyword, page,pageSize), DEFAULT_CONFIG);\n            var searchResultJson = JsonParser.Deserialize(searchResult).data.song;\n            var result = new List<Song>();\n\n            var index = 1;\n            foreach(var songItem in searchResultJson.list)\n            {\n                var song = new Song\n                {\n                    id = songItem[\"songmid\"],\n                    name = songItem[\"songname\"],\n                    album = songItem[\"albumname\"],\n                    rate = 128,\n                    size = songItem[\"size128\"],\n                    source = Name,\n                    index = index++,\n                    duration = songItem[\"interval\"]\n                };\n                song.singer = \"\";\n                foreach (var ar in songItem[\"singer\"])\n                {\n                    song.singer += ar[\"name\"] + \" \";\n                }\n                result.Add(song);\n            }\n\n            return result;\n\n        }\n\n        public string getDownloadUrl(Song song)\n        {\n            var guid = new Random().Next(1000000000, 2000000000);\n\n            var key = JsonParser.Deserialize(HttpHelper.GET(string.Format(\"http://base.music.qq.com/fcgi-bin/fcg_musicexpress.fcg?guid={0}&format=json&json=3\",guid), DEFAULT_CONFIG)).key;\n            foreach(var prefix in prefixes)\n            {\n               \n                var musicUrl = string.Format(\"http://dl.stream.qqmusic.qq.com/{0}{1}.mp3?vkey={2}&guid={3}&fromtag=1\", prefix, song.id, key, guid);\n                if (HttpHelper.GetUrlContentLength(musicUrl) > 0)\n                {\n                    return musicUrl;\n                }\n            }\n\n            return null;\n\n        }\n    \n    }\n```\n\n- 搜索调用`http://c.y.qq.com/soso/fcgi-bin/search_for_qq_cp?w={0}&format=json&p={1}&n={2}`接口，获取下载地址调用`http://base.music.qq.com/fcgi-bin/fcg_musicexpress.fcg?guid={0}&format=json&json=3`,然后再组合。\n\n### 聚合搜索\n\n设计一个MusicProviders，加载所有的IMusicProvider，提供一个SearchSongs方法，并发调用各个网站的搜索，然后merge到一起。\n\n``` csharp\n\n  public List<MergedSong> SearchSongs(string keyword, int page, int pageSize)\n        {\n            var songs = new List<Song>();\n            Providers.AsParallel().ForAll(provider =>\n            {\n                var currentSongs = provider.SearchSongs(keyword, page, pageSize);\n                songs.AddRange(currentSongs);\n            });\n\n            // merge\n\n            return songs.GroupBy(s => s.getMergedKey()).Select(g => new MergedSong(g.ToList())).OrderByDescending(s => s.score).ToList();\n        }\n```\n\n关于merge，核心就是将相同的歌曲合并到一起，我们暂且认为歌手+歌曲名相同的为同一首歌曲：\n\n``` csharp?linenums\n   public string getMergedKey()\n        {\n            return singer.Replace(\" \", \"\") + name.Replace(\" \", \"\");\n        }\n\t\t\n```\n\n因此按megekey分组，就能实现聚合。我们设计一个`MergedSong`来包裹。\n\n\n``` csharp\npublic class MergedSong\n    {\n        public List<Song> items\n        {\n            get; set;\n        }\n\n        public MergedSong(List<Song> items)\n        {\n            this.items = items;\n        }\n\n        public string name\n        {\n            get\n            {\n                return this.items[0].name;\n            }\n        }\n        public string singer\n        {\n            get\n            {\n                return this.items[0].singer;\n            }\n        }\n        public string album\n        {\n            get\n            {\n                return this.items[0].album;\n            }\n        }\n\n        public string source\n        {\n            get\n            {\n                return string.Join(\",\", this.items.Select(i => i.source).ToArray());\n            }\n        }\n\n\n        public double duration\n        {\n            get\n            {\n                return this.items[0].duration;\n            }\n        }\n\n        public double size\n        {\n            get\n            {\n                return this.items[0].size;\n            }\n        }\n\n        public double rate\n        {\n            get\n            {\n                return this.items[0].rate;\n            }\n        }\n\n\n        public double score\n        {\n            get\n            {\n                // 投票+排序加权  (各50%）\n                return this.items.Count / (MusicProviders.Instance.Providers.Count - 1) + (20 - this.items.Average(i => i.index)) / 20;\n            }\n        }\n\n    }\n```\n\nMergedSong的核心是定义了一个score，我们通过投票+搜索结果排序，用来决定合并结果的排序。\n\n### 下载\n\n下载主要是通过provider获取真实url，然后下载即可。\n\n``` csharp?linenums\npublic class SongItemDownloader\n    {\n        MusicProviders musicProviders;\n        string target;\n        MergedSong song;\n\n        public event DownloadFinishEvent DownloadFinish;\n\n        public SongItemDownloader(MusicProviders musicProviders, string target, MergedSong song)\n        {\n            this.musicProviders = musicProviders;\n            this.target = target;\n            this.song = song;\n        }\n\n        public long totalBytes;\n\n        public long bytesReceived;\n\n        public double ReceiveProgress;\n\n\n        public double receiveSpeed;\n\n        DateTime lastTime = DateTime.Now;\n\n        public void Download()\n        {\n            WebClient client = new WebClient();\n            client.DownloadProgressChanged += Client_DownloadProgressChanged;\n            new Thread(() =>\n            {\n                // 多来源，防止单个来源出错\n                foreach (var item in song.items)\n                {\n                    try\n                    {\n                        client.DownloadFile(musicProviders.getDownloadUrl(item), target + \"\\\\\" + item.getFileName());\n                        DownloadFinish?.Invoke(this, this);\n                        break;\n\n                    }\n                    catch\n                    {\n                    }\n                }\n\n            }).Start();\n        }\n\n        private void Client_DownloadProgressChanged(object sender, DownloadEventArgs e)\n        {\n            this.bytesReceived = e.bytesReceived;\n            this.totalBytes = e.totalBytes;\n            this.receiveSpeed = e.receiveSpeed;\n            this.ReceiveProgress = e.ReceiveProgress;\n        }\n    }\n```\n\n\n## 参考\n\n- 程序界面，使用了 https://github.com/Gsangu/KugouDownloader 代码\n- 搜索和下载方案参考 https://github.com/0xHJK/music-dl\n"
        },
        {
          "name": "XMuiscDownloader.sln",
          "type": "blob",
          "size": 1.1025390625,
          "content": "﻿\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio Version 16\nVisualStudioVersion = 16.0.31424.327\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"XMusicDownloader\", \"XMusicDownloader\\XMusicDownloader.csproj\", \"{DD9FED3C-F339-4317-92A1-6E6BA9CE21DA}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|Any CPU = Debug|Any CPU\n\t\tRelease|Any CPU = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{DD9FED3C-F339-4317-92A1-6E6BA9CE21DA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{DD9FED3C-F339-4317-92A1-6E6BA9CE21DA}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{DD9FED3C-F339-4317-92A1-6E6BA9CE21DA}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{DD9FED3C-F339-4317-92A1-6E6BA9CE21DA}.Release|Any CPU.Build.0 = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {5629C6D7-651E-4B25-AC06-83EBB408A7A8}\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "XMusicDownloader",
          "type": "tree",
          "content": null
        },
        {
          "name": "v1.1.png",
          "type": "blob",
          "size": 85.0810546875,
          "content": null
        }
      ]
    }
  ]
}