{
  "metadata": {
    "timestamp": 1736710898831,
    "page": 487,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "kevin-montrose/Jil",
      "stars": 2147,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0810546875,
          "content": "bin/\nobj/\n*.suo\n*.sln.ide/\n*.user\n.vs/\n*.lock.json\n.nupkgs/*\nBackup/\nUpgradeLog.htm"
        },
        {
          "name": "Benchmark",
          "type": "tree",
          "content": null
        },
        {
          "name": "CREDITS.md",
          "type": "blob",
          "size": 0.5595703125,
          "content": "This is a, possibly incomplete, list of Jil contributors.\nNames (N) are in alphabetic order, emails (E) and websites (W) are optional.\nWhen you submit a pull request, you may also modify this file\nif you so desire.\n\nCode need not be directly merged to merit inclusion in this file.\nReference implementations, significant and clear bug reports, etc. \nare also sufficient.\n\nThis file is modeled on the [Linux CREDITS file](https://github.com/torvalds/linux/blob/master/CREDITS).\n\n====\n\nN: Kevin Montrose  \nE: kevin.montrose@stackoverflow.com  \nW: http://kevinmontrose.com/  \n"
        },
        {
          "name": "Experiments",
          "type": "tree",
          "content": null
        },
        {
          "name": "Jil.StrongName",
          "type": "tree",
          "content": null
        },
        {
          "name": "Jil.sln",
          "type": "blob",
          "size": 4.2646484375,
          "content": "ï»¿\r\nMicrosoft Visual Studio Solution File, Format Version 12.00\r\n# Visual Studio 15\r\nVisualStudioVersion = 15.0.26403.7\r\nMinimumVisualStudioVersion = 10.0.40219.1\r\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"Solution Items\", \"Solution Items\", \"{C918E754-B4AA-43CC-81DE-CC0D0B806A59}\"\r\n\tProjectSection(SolutionItems) = preProject\r\n\t\tLICENSE = LICENSE\r\n\t\tREADME.md = README.md\r\n\tEndProjectSection\r\nEndProject\r\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"Jil\", \"Jil\\Jil.csproj\", \"{73D243E7-DD9B-4546-9B71-4EE8BF5ED6C3}\"\r\nEndProject\r\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"JilTests\", \"JilTests\\JilTests.csproj\", \"{9D12CD30-3BCE-4CC4-BC8A-94C951802804}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Experiments\", \"Experiments\\Experiments.csproj\", \"{E26CA103-9746-4038-876F-19218F47C29C}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Benchmark\", \"Benchmark\\Benchmark.csproj\", \"{F4EB088A-3962-4444-8935-7D5B1C197019}\"\r\nEndProject\r\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"Jil.StrongName\", \"Jil.StrongName\\Jil.StrongName.csproj\", \"{0EDD50BE-0CCD-48E1-A613-4A623F543492}\"\r\nEndProject\r\nGlobal\r\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\r\n\t\tDebug|Any CPU = Debug|Any CPU\r\n\t\tRelease_ExhaustiveTest|Any CPU = Release_ExhaustiveTest|Any CPU\r\n\t\tRelease|Any CPU = Release|Any CPU\r\n\tEndGlobalSection\r\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\r\n\t\t{73D243E7-DD9B-4546-9B71-4EE8BF5ED6C3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{73D243E7-DD9B-4546-9B71-4EE8BF5ED6C3}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{73D243E7-DD9B-4546-9B71-4EE8BF5ED6C3}.Release_ExhaustiveTest|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{73D243E7-DD9B-4546-9B71-4EE8BF5ED6C3}.Release_ExhaustiveTest|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{73D243E7-DD9B-4546-9B71-4EE8BF5ED6C3}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{73D243E7-DD9B-4546-9B71-4EE8BF5ED6C3}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{9D12CD30-3BCE-4CC4-BC8A-94C951802804}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{9D12CD30-3BCE-4CC4-BC8A-94C951802804}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{9D12CD30-3BCE-4CC4-BC8A-94C951802804}.Release_ExhaustiveTest|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{9D12CD30-3BCE-4CC4-BC8A-94C951802804}.Release_ExhaustiveTest|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{9D12CD30-3BCE-4CC4-BC8A-94C951802804}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{9D12CD30-3BCE-4CC4-BC8A-94C951802804}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{E26CA103-9746-4038-876F-19218F47C29C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{E26CA103-9746-4038-876F-19218F47C29C}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{E26CA103-9746-4038-876F-19218F47C29C}.Release_ExhaustiveTest|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{E26CA103-9746-4038-876F-19218F47C29C}.Release_ExhaustiveTest|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{E26CA103-9746-4038-876F-19218F47C29C}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{E26CA103-9746-4038-876F-19218F47C29C}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{F4EB088A-3962-4444-8935-7D5B1C197019}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{F4EB088A-3962-4444-8935-7D5B1C197019}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{F4EB088A-3962-4444-8935-7D5B1C197019}.Release_ExhaustiveTest|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{F4EB088A-3962-4444-8935-7D5B1C197019}.Release_ExhaustiveTest|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{F4EB088A-3962-4444-8935-7D5B1C197019}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{F4EB088A-3962-4444-8935-7D5B1C197019}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{0EDD50BE-0CCD-48E1-A613-4A623F543492}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{0EDD50BE-0CCD-48E1-A613-4A623F543492}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{0EDD50BE-0CCD-48E1-A613-4A623F543492}.Release_ExhaustiveTest|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{0EDD50BE-0CCD-48E1-A613-4A623F543492}.Release_ExhaustiveTest|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{0EDD50BE-0CCD-48E1-A613-4A623F543492}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{0EDD50BE-0CCD-48E1-A613-4A623F543492}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\tEndGlobalSection\r\n\tGlobalSection(SolutionProperties) = preSolution\r\n\t\tHideSolutionNode = FALSE\r\n\tEndGlobalSection\r\n\tGlobalSection(ExtensibilityGlobals) = postSolution\r\n\t\tSolutionGuid = {A199582F-E573-4803-8C0F-69358330693D}\r\n\tEndGlobalSection\r\nEndGlobal\r\n"
        },
        {
          "name": "Jil",
          "type": "tree",
          "content": null
        },
        {
          "name": "JilTests",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0595703125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2013-2015 Kevin Montrose\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
        },
        {
          "name": "Nuget",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 19.6787109375,
          "content": "### Jil\n\nA fast JSON (de)serializer, built on [Sigil](https://github.com/kevin-montrose/Sigil) with a number of somewhat crazy optimization tricks.\n\n[Releases are available on Nuget](https://www.nuget.org/packages/Jil/) in addition to this repository.\n\n## Usage\n\n### Serializing\n\n```C#\nusing(var output = new StringWriter())\n{\n    JSON.Serialize(\n        new\n        {\n            MyInt = 1,\n            MyString = \"hello world\",\n            // etc.\n        },\n        output\n    );\n}\n```\n\nThere is also a `Serialize` method that returns a string.\n\nThe first time Jil is used to serialize a given configuration and type pair, it will spend extra time building the serializer.\nSubsequent invocations will be much faster, so if a consistently fast runtime is necessary in your code you may want to \"prime the pump\"\nwith an earlier \"throw away\" serialization.\n\n### Dynamic Serialization\n\nIf you need to serialize compile-time unknown types (including subclasses, and virtual properties) you should use `JSON.SerializeDynamic` instead.\n`JSON.SerializeDynamic` does not require a generic type parameter, and can cope with subclasses, `object`/`dynamic` members, and [DLR](http://msdn.microsoft.com/en-us/library/dd233052(v=vs.110).aspx) participating \ntypes such as [ExpandoObject](http://msdn.microsoft.com/en-us/library/system.dynamic.expandoobject(v=vs.110).aspx) and [DynamicObject](http://msdn.microsoft.com/en-us/library/system.dynamic.dynamicobject(v=vs.110).aspx).\n\n### Deserializing\n\n```C#\nusing(var input = new StringReader(myString))\n{\n    var result = JSON.Deserialize<MyType>(input);\n}\n```\n\nThere is also a `Deserialize` method that takes a string as input.\n\nThe first time Jil is used to deserialize a given configuration and type pair, it will spend extra time building the deserializer.\nSubsequent invocations will be much faster, so if a consistently fast runtime is necessary in your code you may want to \"prime the pump\"\nwith an earlier \"throw away\" deserialization.\n\nJil is case sensitive as a rule, so when deserializing make sure your member names match what is in your JSON.\n\n### Dynamic Deserialization\n\n```C#\nusing(var input = new StringReader(myString))\n{\n    var result = JSON.DeserializeDynamic(input);\n}\n```\n\nThere is also a `DeserializeDynamic` method that works directly on strings.\n\nThese methods return `dynamic`, and support the following operations:\n\n  - Casts\n    * ie. `(int)JSON.DeserializeDynamic(\"123\")`\n  - Member access\n    * ie. `JSON.DeserializeDynamic(@\"{\"\"A\"\":123}\").A`\n  - Indexers\n    * ie. `JSON.DeserializeDynamic(@\"{\"\"A\"\":123}\")[\"A\"]`\n    * or `JSON.DeserializeDynamic(\"[0, 1, 2]\")[0]`\n  - Foreach loops\n    * ie. `foreach(var keyValue in JSON.DeserializeDynamic(@\"{\"\"A\"\":123}\")) { ... }`\n      - in this example, `keyValue` is a dynamic with `Key` and `Value` properties\n    * or `foreach(var item in JSON.DeserializeDynamic(\"[0, 1, 2]\")) { ... }`\n      - in this example, `item` is a `dynamic` and will have values 0, 1, and 2\n  - Common unary operators (+, -, and !)\n  - Common binary operators (&&, ||, +, -, *, /, ==, !=, <, <=, >, and >=)\n  - `.Length` & `.Count` on arrays\n  - `.ContainsKey(string)` on objects\n\n## Supported Types\n\nJil will only (de)serialize types that can be reasonably represented as [JSON](http://json.org).\n\nThe following types (and any user defined types composed of them) are supported:\n\n  - Strings (including char)\n  - Booleans\n  - Integer numbers (int, long, byte, etc.)\n  - Floating point numbers (float, double, and decimal)\n  - DateTimes & DateTimeOffsets\n    * Note that DateTimes are converted to UTC time to allow for round-tripping, use DateTimeOffsets if you need to preserve timezone information\n    * See Configuration for further details\n  - TimeSpans\n    * See Configuration for further details\n  - Nullable types\n  - Enumerations\n    * Including \\[Flags\\]\n  - Guids\n    * Only the [\"D\" format](http://msdn.microsoft.com/en-us/library/97af8hh4.aspx)\n  - IList&lt;T&gt;, ICollection&lt;T&gt;, and IReadOnlyList&lt;T&gt; implementations\n  - IDictionary&lt;TKey, TValue&gt; implementations where TKey is a string or enumeration\n  - ISet&lt;T&gt; \n\nJil deserializes public fields and properties; the order in which they are serialized is not defined (it is unlikely to be in\ndeclaration order).  The [`DataMemberAttribute.Name` property](http://msdn.microsoft.com/en-us/library/ms584759(v=vs.110).aspx) and [`IgnoreDataMemberAttribute`](http://msdn.microsoft.com/en-us/library/system.runtime.serialization.ignoredatamemberattribute.aspx) are respected by Jil, as is the [ShouldSerializeXXX() pattern](http://msdn.microsoft.com/en-us/library/53b8022e(v=vs.110).aspx).  For situations where `DataMemberAttribute` and `IgnoreDataMemberAttribute` cannot be used, Jil provides the [`JilDirectiveAttribute`](https://github.com/kevin-montrose/Jil/blob/master/Jil/JilDirectiveAttribute.cs) which provides equivalent functionality.\n\nStrong typing of primitives types (int, long, etc.) can be done by annotating a wrapper type with `[JilPrimitiveWrapper]`.  Such a type should have one declared field or property, and default or single parameter constructor.\n\n## Unions\n\nJil has limited support for \"unions\" (fields on JSON objects that may contain one of several types), provided that they can be distiguished by their first character.\n\nIn other words:\n```csharp\nclass LegalUnion\n{\n\t[JilDirective(Name = \"Foo\", IsUnion = true)]\n\tpublic string FooString { get; set; }\n\t[JilDirective(Name = \"Foo\", IsUnion = true)]\n\tpublic int FooInt { get; set; }\n}\n```\nIs allowed because the first character of a JSON string is always `\"`, while the first character of a JSON number is a digit or `-`.\n\nThe following would not be legal, however.\n```csharp\nclass IllegalUnion\n{\n\t[JilDirective(Name = \"Foo\", IsUnion = true)]\n\tpublic uint FooUInt { get; set; }\n\t[JilDirective(Name = \"Foo\", IsUnion = true)]\n\tpublic double FooDouble { get; set; }\n}\n```\nSince both properties could start with a digit.\n\nYou can also use a `Type` member to determine which field was (de)serialized.\n```csharp\nclass WithUnionType\n{\n\t[JilDirective(Name = \"Foo\", IsUnion = true, IsUnionType = true)]\n\tpublic Type FooType { get; set; }\n\n\t[JilDirective(Name = \"Foo\", IsUnion = true)]\n\tpublic uint FooUInt { get; set; }\n\t[JilDirective(Name = \"Foo\", IsUnion = true)]\n\tpublic List<int> FooList { get; set; }\n\n}\n```\nWhen serializing this field _must_ be set.\n\n## Configuration\n\nJil's `JSON.Serialize` and `JSON.Deserialize` methods take an optional `Options` parameter which controls:\n\n  - The format of DateTimes, DateTimeOffsets, and TimeSpans; one of\n    * MicrosoftStyleMillisecondsSinceUnixEpoch, a string\n\t  - \"\\/Date(##...##)\\/\" for DateTimes & DateTimeOffsets\n\t  - \"1.23:45:56.78\" for TimeSpans\n\t* MillisecondsSinceUnixEpoch, a number\n\t  - for DateTimes & DateTimeOffsets it can be passed directly to [JavaScript's Date() constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date)\n\t  - for TimeSpans it's simply [TimeSpan.TotalMilliseconds](http://msdn.microsoft.com/en-us/library/system.timespan.totalmilliseconds%28v=vs.110%29.aspx)\n\t* SecondsSinceUnixEpoch, a number\n\t  - for DateTimes & DateTimeOffsets this is commonly refered to as [unix time](http://en.wikipedia.org/wiki/Unix_time)\n\t  - for TimeSpans it's simply [TimeSpan.TotalSeconds](http://msdn.microsoft.com/en-us/library/system.timespan.totalseconds%28v=vs.110%29.aspx)\n\t* ISO8601, a string\n\t  - for DateTimes & DateTimeOffsets, ie. \"2011-07-14T19:43:37Z\"\n\t    * DateTimes are always serialized in UTC (timezone offset = 00:00), because Local DateTimes cannot reliably roundtrip\n\t\t* DateTimeOffsets include their timezone offset when serialized\n\t  - for TimeSpans, ie. \"P40DT11H10M9.4S\" \n    * RFC1123, a string\n\t  - for DateTimes and DateTimeOffsets, ie. \"Thu, 10 Apr 2008 13:30:00 GMT\"\n\t  - \"1.23:45:56.78\" for TimeSpans\n  - What to treat DateTimes with an [Unspecified DateTimeKind](https://msdn.microsoft.com/en-us/library/shx7s921%28v=vs.110%29.aspx) as; one of\n    * IsLocal, will treat an unspecified DateTime as if it were in local time\n\t* IsUtc, will treat an unspecified DateTime as if it were in UTC\n  - Whether or not to exclude null values when serializing dictionaries, and object members\n  - Whether or not to \"pretty print\" while serializing, which adds extra linebreaks and whitespace for presentation's sake\n  - Whether or not the serialized JSON will be used as JSONP (which requires slightly more work be done w.r.t. escaping)\n  - Whether or not to include inherited members when serializing\n  - The way to format member names; one of\n    * Verbatim\n\t  - As it appears in source, unless modified by a `[MemberName]` or `[JilDirective]`\n\t* CamelCase\n\t  - lowercasing the first letter of members, ie. `\"CamelCase\"` would become `\"camelCase\"`\n\n## Benchmarks\n\nJil aims to be the fastest general purpose JSON (de)serializer for .NET.  Flexibility and \"nice to have\" features are explicitly discounted\nin the pursuit of speed.\n\nThese benchmarks were run on a machine with the following specs:\n\n<ul>\n <li>Operating System: Windows 8.1 Enterprise 64-bit (6.3, Build 9600) (9600.winblue_r3.140827-1500)</li>\n <li>System Manufacturer: Apple Inc.</li>\n <li>System Model: MacBookPro11,3</li>\n <li>Processor: Intel(R) Core(TM) i7-4960HQ CPU @ 2.60GHz (8 CPUs), ~2.6GHz</li>\n <li>Memory: 16384MB RAM</li>\n <ul>\n  <li>DDR3</li>\n  <li>Dual Channel</li>\n  <li>798.1 MHZ</li>\n </ul>\n</ul>\n\nAs with all benchmarks, take these with a grain of salt.\n\n### Serialization\n\nFor comparison, here's how Jil stacks up against other popular .NET serializers in a [synthetic benchmark](https://github.com/kevin-montrose/Jil/tree/7915b2e8897024e82628c514d63af596fcfd5013/Benchmark):\n\n - [Json.NET](http://james.newtonking.com/json) - JSON library included with ASP.NET MVC, version 6.0.7\n - [ServiceStack.Text](https://github.com/ServiceStack/ServiceStack.Text) - JSON, CSV, and JSV library; a part of the [ServiceStack framework](https://github.com/ServiceStack/ServiceStack), version 3.9.71\n - [protobuf-net](https://code.google.com/p/protobuf-net/) - binary serializer for Google's [Protocol Buffers](https://code.google.com/p/protobuf/), version 2.0.0.688\n   * __does not__ serialize JSON, included as a baseline\n\nAll three libraries are in use at [Stack Exchange](https://stackexchange.com/) in various production roles.\n\n<img src=\"https://i.imgur.com/kagJdod.png\" />\n\n<img src=\"https://i.imgur.com/ggFu8Kw.png\" />\n\n<img src=\"https://i.imgur.com/moSS1Mv.png\" />\n\nNote that the bars in each group of each graph are scaled so that the fastest library is 100.\n\nNumbers, include millisecond timings, can found in [this Google Document](https://docs.google.com/spreadsheets/d/1Jx7DAGopJo3BC0St_L5qHJJrWpZe9x9BCHgdeY9-b-w/edit).\n\nThe Question, Answer, and User types are taken from the [Stack Exchange API](http://api.stackexchange.com/).\n\nData for each type is randomly generated from a fixed seed.  Random text is biased towards ASCII<sup>*</sup>, but includes all unicode.\n\n<sub>*This is meant to simulate typical content from the Stack Exchange API.</sub>\n\n### Deserialization\n\nThe same libraries and same types were used to test deserialization.\n\n<img src=\"https://i.imgur.com/Qvdvo44.png\" />\n\n<img src=\"https://i.imgur.com/QPtJzZV.png\" />\n\n<img src=\"https://i.imgur.com/fESbbgm.png\" />\n\nNote that the bars in each group of each graph are scaled so that the fastest library is 100.\n\nNumbers, include millisecond timings, can be found in [the same Google Document](https://docs.google.com/spreadsheets/d/1Jx7DAGopJo3BC0St_L5qHJJrWpZe9x9BCHgdeY9-b-w/edit).\n\n## Tricks\n\nJil has a lot of tricks to make it fast.  These may be interesting, even if Jil itself is too limited for your use.\n\n### Sigil\n\nJil does a lot of IL generation to produce tight, focused code.  While possible with [ILGenerator](http://msdn.microsoft.com/en-us/library/system.reflection.emit.ilgenerator.aspx), Jil instead uses the [Sigil library](https://github.com/kevin-montrose/Sigil).\nSigil automatically does a lot of the busy work you'd normally have to do manually to produce ideal IL.\nUsing Sigil also makes hacking on Jil much more productive, as debuging IL generation without it is pretty slow going.\n\n### Trade Memory For Speed\n\nJil's internal serializers and deserializers are (in the absense of recursive types) monolithic, and per-type; avoiding extra runtime lookups, and giving\n.NET's JIT more context when generating machine code.\n\nThe methods Jil create also do no Options checking at serialization time; Options are baked in at first use.  This means\nthat Jil may create up to 32 different serializers and 8 different deserializers for a single type (though in practice, many fewer).\n\n### Optimizing Member Access Order\n\nPerhaps the [most arcane code in Jil](https://github.com/kevin-montrose/Jil/blob/519a0c552e9fb93a4df94eed0b2f9804271f2fef/Jil/Serialize/Utils.cs#L52) determines the preferred order to access members, so the CPU doesn't stall waiting for values from memory.\n\nMembers are divided up into 4 groups:\n<ul>\n  <li>Simple\n    <ul>\n      <li>primitive ValueTypes such as int, double, etc.</li>\n    </ul>\n  </li>\n  <li>Nullable Types</li>\n  <li>Recursive Types</li>\n  <li>Everything Else</li>\n</ul>\n\nMembers within each group are ordered by the offset of the fields backing them (properties are decompiled to determine fields they use).\n\nThis is a fairly naive implementation of this idea, there's almost certainly more that could be squeezed out especially with regards to consistency of gains.\n\n### Don't Allocate If You Can Avoid It\n\n.NET's GC is excellent, but no-GC is still faster than any-GC.\n\nJil tries to avoid allocating any reference types, with some exceptions:\n\n - [a 36-length char\\[\\]](https://github.com/kevin-montrose/Jil/blob/519a0c552e9fb93a4df94eed0b2f9804271f2fef/Jil/Serialize/InlineSerializer.cs#L2785) if any integer numbers, DateTimes, or GUIDs are being serialized\n - [a 32-length char\\[\\]](https://github.com/kevin-montrose/Jil/blob/44aef95ecb762b34827ec22967ea263056b96434/Jil/Deserialize/InlineDeserializer.cs#L64) if any strings, user defined objects, or ISO8601 DateTimes are being deserialized\n\nDepending on the data being deserialized a `StringBuilder` may also be allocated.  If a `TextWriter` does not have an invariant culture, strings may also be allocated when serializing floating point numbers.\n\n### Escaping Tricks\n\nJSON has escaping rules for `\\`, `\"`, and control characters.  These can be kind of time consuming to deal with. Jil avoids it as much as possible in two ways.\n\nFirst, all known key names are determined once and baked into the generated delegates [like so](https://github.com/kevin-montrose/Jil/blob/519a0c552e9fb93a4df94eed0b2f9804271f2fef/Jil/Serialize/InlineSerializer.cs#L980).\nKnown keys are member names and enumeration values.\n\nSecond, rather than lookup encoded characters in a dictionary or a long series of branches Jil does explicit checks for `\"` and `\\` and turns the rest into\na subtraction and jump table lookup.  This comes out to ~three branches (with mostly consistently taken paths, good for branch prediction in theory) per character.\n\nThis works because control characters in .NET strings (bascally UTF-16, but might as well be ASCII for this trick) are sequential, being [0,31].\n\nJSONP also requires escaping of line separator (\\u2028) and paragraph separator (\\u2029) characters.  When configured to serialize JSONP,\nJil escapes them in the same manner as `\\` and `\"`.\n\n### Custom Number Formatting\n\nWhile number formatting in .NET is pretty fast, it has a lot of baggage to handle custom number formatting.\n\nSince JSON has a strict definition of a number, a Write() implementation without configuration is noticeably faster.\nTo go the extra mile, Jil contains [separate implementations for `int`, `uint`, `ulong`, and `long`](https://github.com/kevin-montrose/Jil/blob/519a0c552e9fb93a4df94eed0b2f9804271f2fef/Jil/Serialize/Methods.cs#L803).\n\nJil __does not__ include custom `decimal`, `double`, or `single` Write() implementations, as despite my best efforts I haven't been able to beat the ones built into .NET.\nIf you think you're up to the challenge, I'd be really interested in seeing code that *is* faster than the included implementations.\n\n### Custom Date Formatting\n\nSimilarly to numbers, each of Jil's date formats has a custom Write() implementation.\n\n - [ISO8601](https://github.com/kevin-montrose/Jil/blob/519a0c552e9fb93a4df94eed0b2f9804271f2fef/Jil/Serialize/Methods.cs#L142) can be unrolled into a smaller number of `/` and `%` instructions\n - [RFC1123](https://github.com/kevin-montrose/Jil/blob/fa66ef27b606f2d39512ed54073377730d065896/Jil/Serialize/Methods.cs#L1574) can be similarly decomposed\n - [Microsoft-style](https://github.com/kevin-montrose/Jil/blob/fa66ef27b606f2d39512ed54073377730d065896/Jil/Serialize/InlineSerializer.cs#L613) is a subtraction and division, then fed into the custom `long` writing code\n - [Milliseconds since the unix epoch](https://github.com/kevin-montrose/Jil/blob/519a0c552e9fb93a4df94eed0b2f9804271f2fef/Jil/Serialize/InlineSerializer.cs#L528) is essentially the same\n - [Seconds since the unix epoch](https://github.com/kevin-montrose/Jil/blob/519a0c552e9fb93a4df94eed0b2f9804271f2fef/Jil/Serialize/InlineSerializer.cs#L577) just has a different divisor\n \n### Custom Guid Formatting\n\nNoticing a pattern?\n\nJil has a [custom Guid writer](https://github.com/kevin-montrose/Jil/blob/201a611f1589c07b6a65d4fb07bf1d95616bf1e4/Jil/Serialize/Methods.cs#L100) (which is one of the reasons Jil only supports the D format).\n\nFun fact about this method, I tested a more branch heavy version (which removed the byte lookup) which turned out to be considerably slower than the built-in method due to [branch prediction failures](http://stackoverflow.com/a/11227902/80572).\nType 4 Guids being random makes for something quite close to the worst case for branch prediciton.\n\n### Different Code For Arrays\n\nAlthough arrays implement `IList<T>` the JIT generates much better code if you give it array-ish IL to chew on, so Jil does so.\n\n### Special Casing Enumerations With Sequential Values\n\nMany enums end up having sequential values, Jil will exploit this if possible and generate a subtraction and jump table lookup.\nNon-sequential enumerations are handled with a long series of branches.\n\n### Custom Number Readers\n\nJust like Jil maintains many different methods for writing integer types, it also maintains [different methods for reading them](https://github.com/kevin-montrose/Jil/blob/44aef95ecb762b34827ec22967ea263056b96434/Jil/Deserialize/Methods.ReadNumbers.cs).  These methods omit unnecessary sign checks, overflow checks, and culture-specific formatting support.\n\n### Automata Based Member Name Lookups\n\nRather than read a member name into a string or buffer when deserializing, Jil will try to match it one character at a time using an [automata](http://en.wikipedia.org/wiki/Automata_theory).\n\n### Avoid Abstractions If Able\n\nIf you're serializing to `string` (as indicated by using a particular [`Serialize<T>`](https://github.com/kevin-montrose/Jil/blob/7915b2e8897024e82628c514d63af596fcfd5013/Jil/JSON.cs#L140) method) Jil will avoid the overhead of virtually dispatching calls against `TextWriter`, and instead statically call against its own specialized [`StringBuilder`-esque class](https://github.com/kevin-montrose/Jil/blob/7915b2e8897024e82628c514d63af596fcfd5013/Jil/Serialize/ThunkWriter.cs#L133).  In the general case Jil prefers to write against a `TextWriter` so as to keep memory pressure low (a real concern in many real world deployments), but when Jil is going to allocate a `string` anyway avoiding virtual dispatch results in a noticeable speed up. \n\nSimiarly, deserializing from `string` (as indicated by this [`Deserialize<T>`](https://github.com/kevin-montrose/Jil/blob/fa66ef27b606f2d39512ed54073377730d065896/Jil/JSON.cs#L2012) method) Jil avoid using `TextReader`, and instead issue static calls against a [lightweight wrapper of its own](https://github.com/kevin-montrose/Jil/blob/fa66ef27b606f2d39512ed54073377730d065896/Jil/Deserialize/ThunkReader.cs).\n"
        },
        {
          "name": "build.cmd",
          "type": "blob",
          "size": 0.2412109375,
          "content": "@ECHO OFF\nPowerShell -NoProfile -NoLogo -ExecutionPolicy unrestricted -Command \"[System.Threading.Thread]::CurrentThread.CurrentCulture = ''; [System.Threading.Thread]::CurrentThread.CurrentUICulture = '';& '%~dp0build.ps1' %*; exit $LASTEXITCODE\""
        },
        {
          "name": "build.ps1",
          "type": "blob",
          "size": 1.8818359375,
          "content": "[CmdletBinding(PositionalBinding=$false)]\nparam(\n    [bool] $CreatePackages = $true,\n    [bool] $RunTests = $true,\n    [string] $PullRequestNumber\n)\n\nWrite-Host \"Run Parameters:\" -ForegroundColor Cyan\nWrite-Host \"  CreatePackages: $CreatePackages\"\nWrite-Host \"  RunTests: $RunTests\"\nWrite-Host \"  dotnet --version:\" (dotnet --version)\n\n$packageOutputFolder = \"$PSScriptRoot\\.nupkgs\"\n$projectsToBuild =\n    'Jil',\n    'Jil.StrongName'\n\n$testsToRun =\n    'JilTests'\n\nif ($PullRequestNumber) {\n    Write-Host \"Building for a pull request (#$PullRequestNumber), skipping packaging.\" -ForegroundColor Yellow\n    $CreatePackages = $false\n}\n\nWrite-Host \"Building solution...\" -ForegroundColor \"Magenta\"\ndotnet restore \".\\Jil.sln\" /p:CI=true\ndotnet build \".\\Jil.sln\" -c Release /p:CI=true\nWrite-Host \"Done building.\" -ForegroundColor \"Green\"\n\nif ($RunTests) {\n    foreach ($project in $testsToRun) {\n        Write-Host \"Running tests: $project (all frameworks)\" -ForegroundColor \"Magenta\"\n        Push-Location \".\\$project\"\n\n        dotnet xunit\n        if ($LastExitCode -ne 0) {\n            Write-Host \"Error with tests, aborting build.\" -Foreground \"Red\"\n            Pop-Location\n            Exit 1\n        }\n\n        Write-Host \"Tests passed!\" -ForegroundColor \"Green\"\n\t    Pop-Location\n    }\n}\n\nif ($CreatePackages) {\n    mkdir -Force $packageOutputFolder | Out-Null\n    Write-Host \"Clearing existing $packageOutputFolder...\" -NoNewline\n    Get-ChildItem $packageOutputFolder | Remove-Item\n    Write-Host \"done.\" -ForegroundColor \"Green\"\n\n    Write-Host \"Building all packages\" -ForegroundColor \"Green\"\n\n    foreach ($project in $projectsToBuild) {\n        Write-Host \"Packing $project (dotnet pack)...\" -ForegroundColor \"Magenta\"\n        dotnet pack \".\\$project\\$project.csproj\" --no-build -c Release /p:PackageOutputPath=$packageOutputFolder /p:NoPackageAnalysis=true /p:CI=true\n        Write-Host \"\"\n    }\n}\n\nWrite-Host \"Done.\""
        }
      ]
    }
  ]
}