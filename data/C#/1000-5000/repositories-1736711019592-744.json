{
  "metadata": {
    "timestamp": 1736711019592,
    "page": 744,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "thefuntastic/Unity3d-Finite-State-Machine",
      "stars": 1618,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.337890625,
          "content": "*.mat merge=unityyamlmerge eol=lf\n*.anim merge=unityyamlmerge eol=lf\n*.unity merge=unityyamlmerge eol=lf\n*.prefab merge=unityyamlmerge eol=lf\n*.physicsMaterial2D merge=unityyamlmerge eol=lf\n*.physicMaterial merge=unityyamlmerge eol=lf\n*.asset merge=unityyamlmerge eol=lf\n*.meta merge=unityyamlmerge eol=lf\n*.controller merge=unityyamlmerge eol=lf"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.220703125,
          "content": "*/Library\n*/Assets/UnityVS\n*/Temp\n*/obj\n*/Assets/UnityVS.meta\n*/.vs\n*/_Resharper.*\n*/.idea\n*/Logs\n\n*/Assets/Plugins/Editor/Jetbrains/**\n*/Assets/Plugins/Editor/Jetbrains.meta\n\n*.DotSettings\n*.DotSettings.user\n*.unityproj\n*.suo"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.0732421875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 Made With Monster Love (pty) ltd\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.8515625,
          "content": "# Simple Finite State Machine for Unity (C#)\n\nState machines are a very effective way to manage game state, either on your main game play object (Game Over, Restart, Continue etc) or UI (buttonHover, buttonPress etc) or on individual actors and NPCs (AI behaviours, Animations, etc). The following is a simple state machine that should work well within any Unity context. \n\n## Designed for simplicity\n\nThe textbook state machine implementation, and by extension other C# state machine libraries, have a tendency towards complicated configuration or excessive boilerplate. StateMachines are incredibly useful though - administrative overhead should never prevent us from improving readability, fixing bugs, and otherwise writing good code.\n\n* **Create states at the speed of thought:** Just add Enum fields!\n* **Effectively reason about your code:** Everything is in one place directly inside your MonoBehaviour.\n* **Use what you know about Unity:** Doing things the \"Unity\" way avoids unexpected weirdness and side effects.\n* **Only write the methods you're going to use:** Clever under-the-hood reflection saves you from writing tedious boilerplate.\n\nHowever, working programmers still need to ship production code. Correctness and performance should not be sacrificed in the name of convenience.  \n\n* Extensive unit test coverage\n* Garbage allocation free after initialization\n* Battle hardened and shipped in production code \n* Suports iOS/Android/IL2CPP\n\n\n## Usage\n\nThe included example project (for Unity 2019.4) shows the State Machine in action. However, the following is everything you need to get going immediately:\n\n```C#\nusing MonsterLove.StateMachine; //1. Remember the using statement\n\npublic class MyGameplayScript : MonoBehaviour\n{\n    public enum States\n    {\n        Init, \n        Play, \n        Win, \n        Lose\n    }\n    \n    StateMachine<States> fsm;\n    \n    void Awake(){\n        fsm = new StateMachine<States>(this); //2. The main bit of \"magic\". \n\n        fsm.ChangeState(States.Init); //3. Easily trigger state transitions\n    }\n\n    void Init_Enter()\n    {\n        Debug.Log(\"Ready\");\n    }\n\n    void Play_Enter()\n    {      \n        Debug.Log(\"Spawning Player\");    \n    }\n\n    void Play_FixedUpdate()\n    {\n        Debug.Log(\"Doing Physics stuff\");\n    }\n\n    void Play_Update()\n    {\n        if(player.health <= 0)\n        {\n            fsm.ChangeState(States.Lose); //3. Easily trigger state transitions\n        }\n    }\n\n    void Play_Exit()\n    {\n        Debug.Log(\"Despawning Player\");    \n    }\n\n    void Win_Enter()\n    {\n        Debug.Log(\"Game Over - you won!\");\n    }\n\n    void Lose_Enter()\n    {\n        Debug.Log(\"Game Over - you lost!\");\n    }\n\n}\n```\n\n### State Methods are defined by underscore convention ( `StateName_Method` )\n\nLike MonoBehavior methods (`Awake`, `Updates`, etc), state methods are defined by convention. Declare a method in the format `StateName_Method`, and this will be associated with any matching names in the provided enum.\n\n```C#\nvoid enum States\n{\n    Play, \n}\n\n\n//Coroutines are supported, simply return IEnumerator\nIEnumerator Play_Enter()\n{\n    yield return new WaitForSeconds(1);\n    \n    Debug.Log(\"Start\");    \n}\n\n\nIEnumerator Play_Exit()\n{\n    yield return new WaitForSeconds(1);\n}\n\nvoid Play_Finally()\n{\n    Debug.Log(\"GameOver\");\n}\n```\nThese built-in methods are always available, triggered automatically by `ChangeState(States newState)` calls: \n- `Enter`\n- `Exit`\n- `Finally`\n\nBoth `Enter` and `Exit` support co-routines, simply return `IEnumerator`. However, return `void`, and they will be called immediately with no overhead. `Finally` is always called after `Exit` and provides an opportunity to perform clean-up and hygiene in special cases where the `Exit` routine might be interrupted before completing (see the Transitions heading).\n\n## Data-Driven State Events\n\nTo define additional events, we need to specify a `Driver`.\n\n```C#\npublic class Driver\n{\n    StateEvent Update;\n    StateEvent<Collision> OnCollisionEnter; \n    StateEvent<int> OnHealthPickup;\n}\n```\n\nThis is a very simple class. It doesn't have to be called `Driver`; the only constraint is that it must contain `StateEvent` fields. When we pass this to our state machine definition, it will take care of everything needed to set up new State event hooks.\n\n```C#\nStateMachine<States, Driver> fsm;\n    \nvoid Awake(){\n    fsm = new StateMachine<States, Driver>(this); \n}\n\nvoid Play_Enter()\n{\n    Debug.Log(\"Started\");\n}\n\nvoid Play_Update()\n{\n    Debug.Log(\"Ticked\");\n}\n\nvoid Play_OnHealthPickup(int health)\n{\n    //Add to player health\n}\n\n```\n\nAs these are custom events, the final step is to tell the state machine when these should be fired.\n\n```C#\nvoid Update()\n{\n    fsm.Driver.Update.Invoke();\n}\n\nvoid OnCollisionEnter(Collision collision)\n{\n    fsm.Driver.OnCollisionEnter.Invoke(collision);\n}\n\nvoid OnHealthPickup(int health)\n{\n    fsm.Driver.OnHealthPickup.Invoke();\n}\n```\n\n##### Driver Deep-Dive\n\nCompared to the rest of the StateMachine, the `Driver` might elicit a reaction of: *\"Hey! You said there wasn't going to be any funny business here!\"*\n\nIndeed, there aren't many analogues in either C# or Unity. Before `v4.0`, the state machine would dynamically assign a `StateMachineRunner` component that would call `FixedUpdate`,`Update` & `LateUpate` hooks. (For backwards compatibility this is still the default behaviour when omitting a `Driver`). This worked, but additional hooks meant forking the `StateMachineRunner` class. Also, as a separate MonoBehaviour, it has it's own script execution order which could sometimes lead to oddities.\n\nBut with the user responsible for invoking events - eg `fsm.Drive.Update.Invoke()`, it becomes much easier to reason about the lifecycle of the fsm. No more having to guess whether the StateMachine will update before or after the rest of the class, because the trigger is right there. It can be moved to right spot in the main `Update()` call. \n\n```C#\nvoid Update()\n{\n    //Do Stuff\n\n    fsm.Driver.Update.Invoke();\n\n    //Do Other Stuff\n}\n\nvoid Play_Update()\n{\n    //No guessing when this happens\n}\n```\n\nThe real power shines when we consider another anti-pattern. Calling a state change from outside the state machine can lead to unintended side-effects. Imagine the following scenario where a global call causes a state transition. However without \n\n```C#\npublic void EndGame()\n{\n    fsm.ChangeState(States.GameOver);\n}\n\nvoid Idle_Update()\n{\n    //Changing to GameOver would cause unintended things to happen\n}\n\nvoid Play_Update()\n{\n    //GameOver is legal\n}\n```\n\nSome libraries deal with this by defining transitons tables. However, it's possible to achieve a similar outcome using state events:  \n```C#\npublic class Driver()\n{\n    public StateEvent OnEndGame;\n}\n\npublic void EndGame()\n{\n    fsm.Driver.OnEndGame.Invoke();\n}\n\nvoid Idle_Update()\n{\n    //Changing to GameOver would cause unintended things to happen\n}\n\nvoid Play_Update()\n{\n    //GameOver is legal\n}\n\nvoid Play_OnEndGame()\n{\n    fsm.ChangeState(State.GameOver);\n}\n```\nNow the `Play` state is only state that can respond to EndGame calls. This creates an implicit transition table as sort of \"free\" side-effect.\n\n\n## Async Transitions\n\nThere is simple support for managing asynchronous state changes with long enter or exit coroutines.\n\n```C#\nfsm.ChangeState(States.MyNextState, StateTransition.Safe);\n```\n\nThe default is `StateTransition.Safe`. This will always allows the current state to finish both its enter and exit functions before transitioning to any new states.\n\n```C#\nfsm.ChangeState(States.MyNextState, StateTransition.Overwrite);\n```\n\n`StateMahcine.Overwrite` will cancel any current transitions, and call the next state immediately. This means any code which has yet to run in enter and exit routines will be skipped. If you need to ensure you end with a particular configuration, the finally function will always be called:\n\n```C#\nvoid MyCurrentState_Finally()\n{\n    //Reset object to desired configuration\n}\n```\n\n## Upgrading from v3 and above - April 2020\n\nVersion `4.0` brings substantial innovation, however the API strives for backwards compatibility which means all the code you've already written does not need to change. However, the layout of the files inside the package has changed. To avoid errors it is recommended you delete the existing `MonsterLove` folder containing `StateMachine.cs` and related files, then reimport the new package.  \n\n## Performance & Limitations\n\n##### Design Philosophy\n\nThe state machine is designed to maximise simplicity for the end-user. To achieve this, under the hood lies some intricate reflection \"magic\". Reflection is a controversial choice because it is slow - and that's no exception here. However, we seek to balance the trade-off by limiting all the reflection to a single call when the state machine is initialised. This does degrade instantiation performance, however, instantiation is already slow. It's expected that strategies such as object pooling (recycling objects spawned on startup instead of at runtime) are already in effect, which moves this cost to a time when the user is unlikely to notice it.\n\nOnce the initialisation cost has been swallowed, the State Machine aims to be a good citizen at runtime, avoiding allocations that cause garbage pressure and aiming for respectable performance. Ensuring correctness does mean that calling StateEvents' `Invoke()` is slower than naked method calls. Over tens of thousands of instances this can add up to a significant overhead. In these use cases (multiple 1000's of objects) it is recommended to replace the state machine with something hand-tuned. \n\nHowever, for most general use cases, eg manager classes, or other items with low instance counts (10's or 100's) - the difference in performance should absolutely not be something you need to think about. \n\n##### Memory Allocation Free?\nThis is designed to target mobile, as such should be memory allocation free. However the same rules apply as with the rest of Unity in regards to using `IEnumerator` and Coroutines.  \n\n##### Windows Store Platforms\nDue to differences in the Windows Store flavour of .Net and WinRT, this platform is currently incompatible. More details available in this [issue](https://github.com/thefuntastic/Unity3d-Finite-State-Machine/issues/4).\n\n## License\nMIT License\n\n## Notes\n\nThis is state machine is used extensively on the [Made With Monster Love](http://www.madewithmonsterlove.com) title [Cadence](http://store.steampowered.com/app/362800/Cadence/), a puzzle game about making music.  \n\nThis library owes its origins to the state machine from the now defunct Unity Gems (available via [The Internet Archive](http://web.archive.org/web/20140902150909/http://unitygems.com/fsm1/) as of Nov 2014). The original project, however, had many short comings that made usage difficult. Adhering to the principle that a library should do one thing really well, what we have now is perhaps the easiest and most straight forward State Machine in existence for Unity.\n\n##### Feedback and suggestions:\n- http://www.twitter.com/thefuntastic\n"
        },
        {
          "name": "StateMachine",
          "type": "tree",
          "content": null
        },
        {
          "name": "changelog.txt",
          "type": "blob",
          "size": 3.56640625,
          "content": "v4.0 April 2021\n\t*StateMachine now accepts a Driver class, a powerful convention for data driven state events that provides explicit control of the State Machine lifecycle. \n\t*Added `LastState` property\n\t*Added `NextState` property\n\t*Added `reenter` flag to allow transitions back into the same state\n\t*Fixed AOT imcompatibility preventing release of v4.0\n\t*Added new example showing Driver implementation\n\t*Modernised unit tests for Unity Test Runner\n\t*Components deriving from a super class will now also search super classes for state methods\n\t*Upgraded project to Unity 2019.4.19\n\n\t### Upgrade Notes:\n\tThe layout of the library has changed. To avoid issues delete the existing `MonsterLove` folder containing `StateMachine.cs` and related files, before reimporting the Unity package. The API however remains backwards compatible with prior versions. This means your client code does not need to be upgraded.\n\nv4.0-rc1 August 2019\n\t*Created StateMachine Driver concept\n\t*Added `LastState` property to StateMachine class\n\t*Modernised unit tests for Unity Test Runner\n\t*Compenents deriving from a super class will now also search super classes for state methods\n\t*Upgraded project to Unity 2018.3.7\n\nv3.1 March 2016\n\t*Fixing edge cases where non coroutine Exit fucntions wouldn't be called if StateTrasition.Overwrite used\n\nv3.0 March 2016\n\t*Multiple state machines per game object now supported\n\t*Can now reference stateMachine.State without having to cast the result to an enum\n\t*Enter and Exit methods that aren't corouintes are now executed on the same frame they are called - solves many timing issues\n\t*StateMachine is assigned to an instance variable rather than inheritance. Means your MonoBehaviour can inherit from other classes and allows multiple state machines per object\n\t*Classes are now StateMachine and StateMachineRunner. Is more semantic and provides a gentle upgrade path that won't clash with the previous implementation\n\t*StateManchine<States>.Initialize(component) syntax sugar to make initialization more friendly\n\t*Enhanced test coverage\n\t*Removed Method Name warnings as this was just an un-ending source of grief \n\t*Upgraded example project to Unity 5.3.2\n\nv2.4 June 2015\n\t*Bugfix: StateTransition.Overwrite is now consistent with expected behviour\n\t*Added \"Finally\" state function that is always called, even if overwrite cancels the exit routine\n\nv2.3 April 2015\n\t*Breaking change: Refactored StateMachineBehaviour and StateMachineEngine to StateBehaviour and StateEngine to avoid Unity5 conflicts\n\t*Added the concept of StateTransition. Two options: Safe and Overwrite. The default is safe which allows the current coroutine to finish before changing to the next state. \n\t*Better test coverage using UnityTestTools integration tests\n\nv2.2 January 2015\n\t*State Update & Late Update functions no longer run during transitions (i.e. Enter & Exit functions)\n\t*Bug fix: Changing state from a states Update function no longer cause states to enter twice. Note: changing from functions outside of a state can still cause this behaviour\n\nv2.1 December 2014\n\t*Change initialization method and added convenience methods on StateMachineBehaviour. NotePrevious projects will need change Initialization calls.\n\nv2.0 November 2014\n\tComplete rewrite of State Machine for Unity. Now has the following features\n\n\t* Simple use of Enums as state definition. \n\t* Minimal initialization - one line of code. \n\t* Incredibly easy to add/remove states\n\t* Uses reflection to avoid boiler plate code - only write the methods you actually need. \n\t* Compatible with Coroutines.\n\t* Tested on iOS and Android\n\nv1.0 April 2012\n\tA state machine for Unity"
        }
      ]
    }
  ]
}