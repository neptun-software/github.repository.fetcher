{
  "metadata": {
    "timestamp": 1736710850196,
    "page": 383,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Cysharp/R3",
      "stars": 2426,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 12.47265625,
          "content": "# top-most EditorConfig file\nroot = true\n\n# Default settings:\n# A newline ending every file\n# Use 4 spaces as indentation\n[*]\ninsert_final_newline = true\nindent_style = space\nindent_size = 4\ntrim_trailing_whitespace = true\n\n[{appsettings.json,appsettings.*.json}]\ncharset = utf-8-bom\nindent_style = space\nindent_size = 4\n\n# Generated code\n[*{_AssemblyInfo.cs,.notsupported.cs}]\ngenerated_code = true\ndotnet_style_operator_placement_when_wrapping = beginning_of_line\ntab_width = 4\nend_of_line = crlf\ndotnet_style_coalesce_expression = true:suggestion\ndotnet_style_null_propagation = true:suggestion\ndotnet_style_prefer_is_null_check_over_reference_equality_method = true:suggestion\ndotnet_style_prefer_auto_properties = true:suggestion\ndotnet_style_object_initializer = true:suggestion\ndotnet_style_prefer_collection_expression = true:suggestion\ndotnet_style_collection_initializer = true:suggestion\ndotnet_style_prefer_simplified_boolean_expressions = true:suggestion\ndotnet_style_prefer_conditional_expression_over_assignment = true:silent\ndotnet_style_prefer_conditional_expression_over_return = true:silent\ndotnet_style_explicit_tuple_names = true:suggestion\ndotnet_style_prefer_inferred_tuple_names = true:suggestion\ndotnet_style_prefer_inferred_anonymous_type_member_names = true:suggestion\ndotnet_style_prefer_compound_assignment = true:suggestion\ndotnet_style_prefer_simplified_interpolation = true:suggestion\ndotnet_style_namespace_match_folder = true:suggestion\ndotnet_style_readonly_field = true:suggestion\ndotnet_style_predefined_type_for_member_access = true:suggestion\ndotnet_style_predefined_type_for_locals_parameters_members = true:suggestion\ndotnet_style_require_accessibility_modifiers = for_non_interface_members:silent\ndotnet_style_allow_statement_immediately_after_block_experimental = true:silent\ndotnet_style_allow_multiple_blank_lines_experimental = true:silent\ndotnet_code_quality_unused_parameters = non_public:suggestion\ndotnet_style_parentheses_in_relational_binary_operators = always_for_clarity:silent\ndotnet_style_parentheses_in_other_binary_operators = always_for_clarity:silent\ndotnet_style_parentheses_in_arithmetic_binary_operators = always_for_clarity:silent\ndotnet_style_parentheses_in_other_operators = never_if_unnecessary:silent\ndotnet_style_qualification_for_method = false:none\ndotnet_style_qualification_for_property = false:none\ndotnet_style_qualification_for_field = false:none\ndotnet_style_qualification_for_event = false:none\n\n# Razor files\n[*.razor]\ncharset = utf-8-bom\n\n# C# files\n[*.cs]\ncharset = utf-8-bom\n\n# New line preferences\ncsharp_new_line_before_open_brace = all\ncsharp_new_line_before_else = true\ncsharp_new_line_before_catch = true\ncsharp_new_line_before_finally = true\ncsharp_new_line_before_members_in_object_initializers = true\ncsharp_new_line_before_members_in_anonymous_types = true\ncsharp_new_line_between_query_expression_clauses = true\n\n# Indentation preferences\ncsharp_indent_block_contents = true\ncsharp_indent_braces = false\ncsharp_indent_case_contents = true\ncsharp_indent_case_contents_when_block = true\ncsharp_indent_switch_labels = true\ncsharp_indent_labels = one_less_than_current\n\n# Modifier preferences\ncsharp_preferred_modifier_order = public,private,protected,internal,static,extern,new,virtual,abstract,sealed,override,readonly,unsafe,volatile,async:suggestion\n\n# avoid this. unless absolutely necessary\ndotnet_style_qualification_for_field = false:none\ndotnet_style_qualification_for_property = false:none\ndotnet_style_qualification_for_method = false:none\ndotnet_style_qualification_for_event = false:none\n\n# Types: use keywords instead of BCL types, and permit var only when the type is clear\ncsharp_style_var_for_built_in_types = false:none\ncsharp_style_var_when_type_is_apparent = false:none\ncsharp_style_var_elsewhere = false:none\ndotnet_style_predefined_type_for_locals_parameters_members = true:suggestion\ndotnet_style_predefined_type_for_member_access = true:suggestion\n\n# name all constant fields using PascalCase\ndotnet_naming_rule.constant_fields_should_be_pascal_case.severity = suggestion\ndotnet_naming_rule.constant_fields_should_be_pascal_case.symbols  = constant_fields\ndotnet_naming_rule.constant_fields_should_be_pascal_case.style = pascal_case_style\ndotnet_naming_symbols.constant_fields.applicable_kinds   = field\ndotnet_naming_symbols.constant_fields.required_modifiers = const\ndotnet_naming_style.pascal_case_style.capitalization = pascal_case\n\n# static fields\ndotnet_naming_rule.static_fields_should_have_prefix.severity = none\ndotnet_naming_rule.static_fields_should_have_prefix.symbols  = static_fields\ndotnet_naming_rule.static_fields_should_have_prefix.style = static_prefix_style\ndotnet_naming_symbols.static_fields.applicable_kinds   = field\ndotnet_naming_symbols.static_fields.required_modifiers = static\ndotnet_naming_symbols.static_fields.applicable_accessibilities = private, internal, private_protected\ndotnet_naming_style.static_prefix_style.required_prefix = s_\ndotnet_naming_style.static_prefix_style.capitalization = camel_case\n\n# internal and private fields\ndotnet_naming_rule.camel_case_for_private_internal_fields.severity = none\ndotnet_naming_rule.camel_case_for_private_internal_fields.symbols  = private_internal_fields\ndotnet_naming_rule.camel_case_for_private_internal_fields.style = camel_case_underscore_style\ndotnet_naming_symbols.private_internal_fields.applicable_kinds = field\ndotnet_naming_symbols.private_internal_fields.applicable_accessibilities = private, internal\ndotnet_naming_style.camel_case_underscore_style.required_prefix = _\ndotnet_naming_style.camel_case_underscore_style.capitalization = camel_case\n\n# Code style defaults\ncsharp_using_directive_placement = outside_namespace:suggestion\ncsharp_prefer_braces = true:silent\ncsharp_preserve_single_line_blocks = true:none\ncsharp_preserve_single_line_statements = false:none\ncsharp_prefer_static_local_function = true:suggestion\ncsharp_prefer_simple_using_statement = false:none\ncsharp_style_prefer_switch_expression = true:suggestion\n\n# Code quality\ndotnet_style_readonly_field = true:suggestion\ndotnet_code_quality_unused_parameters = non_public:suggestion\n\n# Expression-level preferences\ndotnet_style_object_initializer = true:suggestion\ndotnet_style_collection_initializer = true:suggestion\ndotnet_style_explicit_tuple_names = true:suggestion\ndotnet_style_coalesce_expression = true:suggestion\ndotnet_style_null_propagation = true:suggestion\ndotnet_style_prefer_is_null_check_over_reference_equality_method = true:suggestion\ndotnet_style_prefer_inferred_tuple_names = true:suggestion\ndotnet_style_prefer_inferred_anonymous_type_member_names = true:suggestion\ndotnet_style_prefer_auto_properties = true:suggestion\ndotnet_style_prefer_conditional_expression_over_assignment = true:silent\ndotnet_style_prefer_conditional_expression_over_return = true:silent\ncsharp_prefer_simple_default_expression = true:suggestion\n\n# Expression-bodied members\ncsharp_style_expression_bodied_methods = true:silent\ncsharp_style_expression_bodied_constructors = true:silent\ncsharp_style_expression_bodied_operators = true:silent\ncsharp_style_expression_bodied_properties = true:silent\ncsharp_style_expression_bodied_indexers = true:silent\ncsharp_style_expression_bodied_accessors = true:silent\ncsharp_style_expression_bodied_lambdas = true:silent\ncsharp_style_expression_bodied_local_functions = true:silent\n\n# Pattern matching\ncsharp_style_pattern_matching_over_is_with_cast_check = true:suggestion\ncsharp_style_pattern_matching_over_as_with_null_check = true:suggestion\ncsharp_style_inlined_variable_declaration = true:suggestion\n\n# Null checking preferences\ncsharp_style_throw_expression = true:suggestion\ncsharp_style_conditional_delegate_call = true:suggestion\n\n# Other features\ncsharp_style_prefer_index_operator = false:none\ncsharp_style_prefer_range_operator = false:none\ncsharp_style_pattern_local_over_anonymous_function = false:none\n\n# Space preferences\ncsharp_space_after_cast = false\ncsharp_space_after_colon_in_inheritance_clause = true\ncsharp_space_after_comma = true\ncsharp_space_after_dot = false\ncsharp_space_after_keywords_in_control_flow_statements = true\ncsharp_space_after_semicolon_in_for_statement = true\ncsharp_space_around_binary_operators = before_and_after\ncsharp_space_around_declaration_statements = do_not_ignore\ncsharp_space_before_colon_in_inheritance_clause = true\ncsharp_space_before_comma = false\ncsharp_space_before_dot = false\ncsharp_space_before_open_square_brackets = false\ncsharp_space_before_semicolon_in_for_statement = false\ncsharp_space_between_empty_square_brackets = false\ncsharp_space_between_method_call_empty_parameter_list_parentheses = false\ncsharp_space_between_method_call_name_and_opening_parenthesis = false\ncsharp_space_between_method_call_parameter_list_parentheses = false\ncsharp_space_between_method_declaration_empty_parameter_list_parentheses = false\ncsharp_space_between_method_declaration_name_and_open_parenthesis = false\ncsharp_space_between_method_declaration_parameter_list_parentheses = false\ncsharp_space_between_parentheses = false\ncsharp_space_between_square_brackets = false\n\n# Analyzers\ndotnet_code_quality.CA1052.api_surface = private, internal\ndotnet_code_quality.CA1802.api_surface = private, internal\ndotnet_code_quality.CA1822.api_surface = private, internal\ndotnet_code_quality.CA2208.api_surface = public\n\n# IDE0008: Use explicit type\ndotnet_diagnostic.IDE0008.severity = none\n\n# IDE0090: Use 'new(...)'\ndotnet_diagnostic.IDE0090.severity = none\n\n# IDE0040: Add accessibility modifiers\ndotnet_diagnostic.IDE0040.severity = none\n\n# Nullability in reference types of interface implemented by the base type doesn't match\ndotnet_diagnostic.CS8644.severity = none\n\ndotnet_diagnostic.CA1816.severity = none\n\ndotnet_diagnostic.IDE1006.severity = none\n\n#Remove unnecessary suppression\ndotnet_diagnostic.IDE0079.severity = none\n\ndotnet_diagnostic.IDE0130.severity = none\n\ndotnet_diagnostic.CA1822.severity = none\n\ncsharp_style_prefer_switch_expression = false:suggestion\n\ncsharp_style_pattern_matching_over_as_with_null_check = false:suggestion\n\ndotnet_naming_symbols.functional_symbols.applicable_kinds           = property,method,event,delegate\ndotnet_naming_style.pascal_case_style.capitalization = pascal_case\ndotnet_naming_rule.functional_symbols_must_be_capitalized.symbols   = functional_symbols\ndotnet_naming_rule.functional_symbols_must_be_capitalized.style = pascal_case_style\ndotnet_naming_rule.functional_symbols_must_be_capitalized.severity = warning\n\ndotnet_naming_symbols.public_symbols.applicable_kinds           = property,method,field,event,delegate\ndotnet_naming_symbols.public_symbols.applicable_accessibilities = public\ndotnet_naming_symbols.public_symbols.required_modifiers         = readonly\ndotnet_naming_style.first_word_upper_case_style.capitalization = first_word_upper\ndotnet_naming_rule.public_members_must_be_capitalized.symbols   = public_symbols\ndotnet_naming_rule.public_members_must_be_capitalized.style = first_word_upper_case_style\ndotnet_naming_rule.public_members_must_be_capitalized.severity = warning\n\ncsharp_style_expression_bodied_methods = false:silent\ncsharp_style_expression_bodied_constructors = false:silent\ncsharp_style_expression_bodied_operators = false:silent\ncsharp_style_namespace_declarations = file_scoped:suggestion\ncsharp_style_prefer_method_group_conversion = true:silent\ncsharp_style_prefer_top_level_statements = true:silent\ncsharp_style_prefer_primary_constructors = true:suggestion\ncsharp_style_prefer_null_check_over_type_check = true:suggestion\ncsharp_style_prefer_local_over_anonymous_function = true:suggestion\ncsharp_style_implicit_object_creation_when_type_is_apparent = true:suggestion\ncsharp_style_prefer_tuple_swap = true:suggestion\ncsharp_style_prefer_utf8_string_literals = true:suggestion\ncsharp_style_deconstructed_variable_declaration = true:suggestion\ncsharp_style_unused_value_assignment_preference = discard_variable:suggestion\ncsharp_style_unused_value_expression_statement_preference = discard_variable:silent\ncsharp_style_prefer_readonly_struct_member = true:suggestion\ncsharp_style_prefer_readonly_struct = true:suggestion\ncsharp_style_allow_embedded_statements_on_same_line_experimental = true:silent\ncsharp_style_allow_blank_line_after_token_in_arrow_expression_clause_experimental = true:silent\ncsharp_style_allow_blank_line_after_token_in_conditional_expression_experimental = true:silent\ncsharp_style_allow_blank_line_after_colon_in_constructor_initializer_experimental = true:silent\ncsharp_style_allow_blank_lines_between_consecutive_braces_experimental = true:silent\ncsharp_style_prefer_pattern_matching = true:silent\ncsharp_style_prefer_extended_property_pattern = true:suggestion\ncsharp_style_prefer_not_pattern = true:suggestion\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.7734375,
          "content": "# Build Folders (you can keep bin if you'd like, to store dlls and pdbs)\n[Bb]in/\n[Oo]bj/\n\n# mstest test results\nTestResults\n\n## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n\n# User-specific files\n*.suo\n*.user\n*.sln.docstates\n\n# Build results\n[Dd]ebug/\n[Rr]elease/\nx64/\n*_i.c\n*_p.c\n*.ilk\n*.obj\n*.pch\n*.pdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.log\n*.vspscc\n*.vssscc\n.builds\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opensdf\n*.sdf\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*\n\n# NCrunch\n*.ncrunch*\n.*crunch*.local.xml\n\n# Installshield output folder\n[Ee]xpress\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish\n\n# Publish Web Output\n*.Publish.xml\n\n# NuGet Packages Directory\npackages\n\n# Windows Azure Build Output\ncsx\n*.build.csdef\n\n# Windows Store app package directory\nAppPackages/\n\n# Others\n[Bb]in\n[Oo]bj\nsql\nTestResults\n[Tt]est[Rr]esult*\n*.Cache\nClientBin\n[Ss]tyle[Cc]op.*\n~$*\n*.dbmdl\nGenerated_Code #added for RIA/Silverlight projects\n\n# Backup & report files from converting an old project file to a newer\n# Visual Studio version. Backup files are not needed, because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\n.vs/config/applicationhost.config\n.vs/restore.dg\n\n# OTHER\nnuget/tools/*\n*.nupkg\n\n.vs\n**/.DS_Store\n.idea\n\n# publish directory\nout/\n*.tsbuildinfo\n\n# Unity\nsrc/R3.Unity/bin/*\nsrc/R3.Unity/Library/*\nsrc/R3.Unity/obj/*\nsrc/R3.Unity/Temp/*\nsrc/R3.Unity/UserSettings/*\nsrc/R3.Unity/*.sln\nsrc/R3.Unity/*.csproj"
        },
        {
          "name": "Directory.Build.props",
          "type": "blob",
          "size": 0.8701171875,
          "content": "<Project>\n\n    <PropertyGroup>\n        <!-- NuGet Packaging -->\n        <PackageVersion>$(Version)</PackageVersion>\n        <Company>Cysharp</Company>\n        <Authors>Cysharp</Authors>\n        <Copyright>© Cysharp, Inc.</Copyright>\n        <PackageProjectUrl>https://github.com/Cysharp/R3</PackageProjectUrl>\n        <RepositoryUrl>$(PackageProjectUrl)</RepositoryUrl>\n        <RepositoryType>git</RepositoryType>\n        <PackageLicenseExpression>MIT</PackageLicenseExpression>\n        <PackageIcon>Icon.png</PackageIcon>\n        <SignAssembly>true</SignAssembly>\n        <AssemblyOriginatorKeyFile>../../opensource.snk</AssemblyOriginatorKeyFile>\n        <!-- For BenchmarkDotNet generated project-->\n        <AssemblyOriginatorKeyFile Condition=\"EXISTS('./../../../../../../opensource.snk')\">../../../../../../opensource.snk</AssemblyOriginatorKeyFile>\n    </PropertyGroup>\n\n</Project>\n"
        },
        {
          "name": "Icon.png",
          "type": "blob",
          "size": 3.1103515625,
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.044921875,
          "content": "MIT License\n\nCopyright (c) 2024 Cysharp, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "R3.sln",
          "type": "blob",
          "size": 38.0517578125,
          "content": "﻿\r\nMicrosoft Visual Studio Solution File, Format Version 12.00\r\n# Visual Studio Version 17\r\nVisualStudioVersion = 17.8.34309.116\r\nMinimumVisualStudioVersion = 10.0.40219.1\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"R3\", \"src\\R3\\R3.csproj\", \"{17F32115-0300-4842-8328-395AB56F6BD7}\"\r\nEndProject\r\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"src\", \"src\", \"{9FA6D327-728B-4436-AE3A-9E46D8FEF591}\"\r\nEndProject\r\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"sandbox\", \"sandbox\", \"{FAB2137C-1DBA-4F2F-8E22-DF3521C9B365}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"ConsoleApp1\", \"sandbox\\ConsoleApp1\\ConsoleApp1.csproj\", \"{72DE3CB9-195E-4740-9416-5960D75ED795}\"\r\nEndProject\r\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"tests\", \"tests\", \"{0544806B-3BB4-43CF-8277-BC612F32208D}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"R3.Tests\", \"tests\\R3.Tests\\R3.Tests.csproj\", \"{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}\"\r\nEndProject\r\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"docs\", \"docs\", \"{C7327A31-448F-4A7D-9AC6-C06F5AA03D02}\"\r\n\tProjectSection(SolutionItems) = preProject\r\n\t\t.gitignore = .gitignore\r\n\t\tDirectory.Build.props = Directory.Build.props\r\n\t\tREADME.md = README.md\r\n\tEndProjectSection\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"R3.WPF\", \"src\\R3.WPF\\R3.WPF.csproj\", \"{57AC0130-0D5F-489A-A565-B41EF9928085}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"WpfApp1\", \"sandbox\\WpfApp1\\WpfApp1.csproj\", \"{BA40E541-3BCD-438A-B966-2FC7BE80AB80}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"R3.Avalonia\", \"src\\R3.Avalonia\\R3.Avalonia.csproj\", \"{C492C048-732F-4F0D-AC09-03F3187ABB17}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"AvaloniaApplication1\", \"sandbox\\AvaloniaApplication1\\AvaloniaApplication1.csproj\", \"{978BECEF-5217-4531-B0B7-45BC8D820A28}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"R3.Godot\", \"src\\R3.Godot\\R3.Godot.csproj\", \"{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Benchmark\", \"sandbox\\Benchmark\\Benchmark.csproj\", \"{EBC13ACA-717D-4635-920A-5E0E211B0CF4}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"WinFormsApp1\", \"sandbox\\WinFormsApp1\\WinFormsApp1.csproj\", \"{E6418D3D-01AA-4176-A7CA-6878FA6E4238}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"R3.WinForms\", \"src\\R3.WinForms\\R3.WinForms.csproj\", \"{6598690F-B65B-4C49-824B-7474E735AE92}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"ReferenceBuilder\", \"sandbox\\ReferenceBuilder\\ReferenceBuilder.csproj\", \"{4298FE47-5434-4A0B-9793-6B771E6FC4CA}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"R3.Stride\", \"src\\R3.Stride\\R3.Stride.csproj\", \"{A6554704-FE57-4473-BB46-8586F22472AA}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"R3.LogicLooper\", \"src\\R3.LogicLooper\\R3.LogicLooper.csproj\", \"{B95D732A-7538-4795-AC42-6F595ECB8DB8}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MauiApp1\", \"sandbox\\MauiApp1\\MauiApp1.csproj\", \"{2CD257D7-DF21-4D60-AC05-747D83236E5A}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"R3.Maui\", \"src\\R3.Maui\\R3.Maui.csproj\", \"{F1D6609C-AA33-4099-8932-BADBCB935FBD}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MonoGameApplication1\", \"sandbox\\MonoGameApplication1\\MonoGameApplication1.csproj\", \"{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"R3.MonoGame\", \"src\\R3.MonoGame\\R3.MonoGame.csproj\", \"{D754069D-C912-4D71-97CB-9B2DDD2380B4}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"R3.WinUI3\", \"src\\R3.WinUI3\\R3.WinUI3.csproj\", \"{87F12DBB-E32B-49B8-B5F1-5B53B711989B}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"WinUI3App1\", \"sandbox\\WinUI3App1\\WinUI3App1.csproj\", \"{CDC17599-81AD-44B9-B4E5-38241147CDA2}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"BlazorApp1\", \"sandbox\\BlazorApp1\\BlazorApp1.csproj\", \"{F55F3891-FD11-4C69-9DB6-0CC24B591F59}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"R3.Blazor\", \"src\\R3.Blazor\\R3.Blazor.csproj\", \"{EC0E35F9-9362-41CB-8F8F-797547803892}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"R3.BlazorWebAssembly\", \"src\\R3.BlazorWebAssembly\\R3.BlazorWebAssembly.csproj\", \"{3C77C89F-AA56-4C0A-9635-C0795F41C65C}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"BlazorWebAssemblyApp1\", \"sandbox\\BlazorWebAssemblyApp1\\BlazorWebAssemblyApp1.csproj\", \"{C55C88AE-1C1E-469A-A34A-AE508885D616}\"\r\nEndProject\r\nGlobal\r\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\r\n\t\tDebug|Any CPU = Debug|Any CPU\r\n\t\tDebug|ARM64 = Debug|ARM64\r\n\t\tDebug|x64 = Debug|x64\r\n\t\tDebug|x86 = Debug|x86\r\n\t\tRelease|Any CPU = Release|Any CPU\r\n\t\tRelease|ARM64 = Release|ARM64\r\n\t\tRelease|x64 = Release|x64\r\n\t\tRelease|x86 = Release|x86\r\n\tEndGlobalSection\r\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\r\n\t\t{17F32115-0300-4842-8328-395AB56F6BD7}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{17F32115-0300-4842-8328-395AB56F6BD7}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{17F32115-0300-4842-8328-395AB56F6BD7}.Debug|ARM64.ActiveCfg = Debug|Any CPU\r\n\t\t{17F32115-0300-4842-8328-395AB56F6BD7}.Debug|ARM64.Build.0 = Debug|Any CPU\r\n\t\t{17F32115-0300-4842-8328-395AB56F6BD7}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{17F32115-0300-4842-8328-395AB56F6BD7}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{17F32115-0300-4842-8328-395AB56F6BD7}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{17F32115-0300-4842-8328-395AB56F6BD7}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{17F32115-0300-4842-8328-395AB56F6BD7}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{17F32115-0300-4842-8328-395AB56F6BD7}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{17F32115-0300-4842-8328-395AB56F6BD7}.Release|ARM64.ActiveCfg = Release|Any CPU\r\n\t\t{17F32115-0300-4842-8328-395AB56F6BD7}.Release|ARM64.Build.0 = Release|Any CPU\r\n\t\t{17F32115-0300-4842-8328-395AB56F6BD7}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{17F32115-0300-4842-8328-395AB56F6BD7}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{17F32115-0300-4842-8328-395AB56F6BD7}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{17F32115-0300-4842-8328-395AB56F6BD7}.Release|x86.Build.0 = Release|Any CPU\r\n\t\t{72DE3CB9-195E-4740-9416-5960D75ED795}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{72DE3CB9-195E-4740-9416-5960D75ED795}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{72DE3CB9-195E-4740-9416-5960D75ED795}.Debug|ARM64.ActiveCfg = Debug|Any CPU\r\n\t\t{72DE3CB9-195E-4740-9416-5960D75ED795}.Debug|ARM64.Build.0 = Debug|Any CPU\r\n\t\t{72DE3CB9-195E-4740-9416-5960D75ED795}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{72DE3CB9-195E-4740-9416-5960D75ED795}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{72DE3CB9-195E-4740-9416-5960D75ED795}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{72DE3CB9-195E-4740-9416-5960D75ED795}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{72DE3CB9-195E-4740-9416-5960D75ED795}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{72DE3CB9-195E-4740-9416-5960D75ED795}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{72DE3CB9-195E-4740-9416-5960D75ED795}.Release|ARM64.ActiveCfg = Release|Any CPU\r\n\t\t{72DE3CB9-195E-4740-9416-5960D75ED795}.Release|ARM64.Build.0 = Release|Any CPU\r\n\t\t{72DE3CB9-195E-4740-9416-5960D75ED795}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{72DE3CB9-195E-4740-9416-5960D75ED795}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{72DE3CB9-195E-4740-9416-5960D75ED795}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{72DE3CB9-195E-4740-9416-5960D75ED795}.Release|x86.Build.0 = Release|Any CPU\r\n\t\t{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Debug|ARM64.ActiveCfg = Debug|Any CPU\r\n\t\t{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Debug|ARM64.Build.0 = Debug|Any CPU\r\n\t\t{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Release|ARM64.ActiveCfg = Release|Any CPU\r\n\t\t{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Release|ARM64.Build.0 = Release|Any CPU\r\n\t\t{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Release|x86.Build.0 = Release|Any CPU\r\n\t\t{57AC0130-0D5F-489A-A565-B41EF9928085}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{57AC0130-0D5F-489A-A565-B41EF9928085}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{57AC0130-0D5F-489A-A565-B41EF9928085}.Debug|ARM64.ActiveCfg = Debug|Any CPU\r\n\t\t{57AC0130-0D5F-489A-A565-B41EF9928085}.Debug|ARM64.Build.0 = Debug|Any CPU\r\n\t\t{57AC0130-0D5F-489A-A565-B41EF9928085}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{57AC0130-0D5F-489A-A565-B41EF9928085}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{57AC0130-0D5F-489A-A565-B41EF9928085}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{57AC0130-0D5F-489A-A565-B41EF9928085}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{57AC0130-0D5F-489A-A565-B41EF9928085}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{57AC0130-0D5F-489A-A565-B41EF9928085}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{57AC0130-0D5F-489A-A565-B41EF9928085}.Release|ARM64.ActiveCfg = Release|Any CPU\r\n\t\t{57AC0130-0D5F-489A-A565-B41EF9928085}.Release|ARM64.Build.0 = Release|Any CPU\r\n\t\t{57AC0130-0D5F-489A-A565-B41EF9928085}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{57AC0130-0D5F-489A-A565-B41EF9928085}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{57AC0130-0D5F-489A-A565-B41EF9928085}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{57AC0130-0D5F-489A-A565-B41EF9928085}.Release|x86.Build.0 = Release|Any CPU\r\n\t\t{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Debug|ARM64.ActiveCfg = Debug|Any CPU\r\n\t\t{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Debug|ARM64.Build.0 = Debug|Any CPU\r\n\t\t{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Release|ARM64.ActiveCfg = Release|Any CPU\r\n\t\t{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Release|ARM64.Build.0 = Release|Any CPU\r\n\t\t{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Release|x86.Build.0 = Release|Any CPU\r\n\t\t{C492C048-732F-4F0D-AC09-03F3187ABB17}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{C492C048-732F-4F0D-AC09-03F3187ABB17}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{C492C048-732F-4F0D-AC09-03F3187ABB17}.Debug|ARM64.ActiveCfg = Debug|Any CPU\r\n\t\t{C492C048-732F-4F0D-AC09-03F3187ABB17}.Debug|ARM64.Build.0 = Debug|Any CPU\r\n\t\t{C492C048-732F-4F0D-AC09-03F3187ABB17}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{C492C048-732F-4F0D-AC09-03F3187ABB17}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{C492C048-732F-4F0D-AC09-03F3187ABB17}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{C492C048-732F-4F0D-AC09-03F3187ABB17}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{C492C048-732F-4F0D-AC09-03F3187ABB17}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{C492C048-732F-4F0D-AC09-03F3187ABB17}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{C492C048-732F-4F0D-AC09-03F3187ABB17}.Release|ARM64.ActiveCfg = Release|Any CPU\r\n\t\t{C492C048-732F-4F0D-AC09-03F3187ABB17}.Release|ARM64.Build.0 = Release|Any CPU\r\n\t\t{C492C048-732F-4F0D-AC09-03F3187ABB17}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{C492C048-732F-4F0D-AC09-03F3187ABB17}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{C492C048-732F-4F0D-AC09-03F3187ABB17}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{C492C048-732F-4F0D-AC09-03F3187ABB17}.Release|x86.Build.0 = Release|Any CPU\r\n\t\t{978BECEF-5217-4531-B0B7-45BC8D820A28}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{978BECEF-5217-4531-B0B7-45BC8D820A28}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{978BECEF-5217-4531-B0B7-45BC8D820A28}.Debug|ARM64.ActiveCfg = Debug|Any CPU\r\n\t\t{978BECEF-5217-4531-B0B7-45BC8D820A28}.Debug|ARM64.Build.0 = Debug|Any CPU\r\n\t\t{978BECEF-5217-4531-B0B7-45BC8D820A28}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{978BECEF-5217-4531-B0B7-45BC8D820A28}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{978BECEF-5217-4531-B0B7-45BC8D820A28}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{978BECEF-5217-4531-B0B7-45BC8D820A28}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{978BECEF-5217-4531-B0B7-45BC8D820A28}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{978BECEF-5217-4531-B0B7-45BC8D820A28}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{978BECEF-5217-4531-B0B7-45BC8D820A28}.Release|ARM64.ActiveCfg = Release|Any CPU\r\n\t\t{978BECEF-5217-4531-B0B7-45BC8D820A28}.Release|ARM64.Build.0 = Release|Any CPU\r\n\t\t{978BECEF-5217-4531-B0B7-45BC8D820A28}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{978BECEF-5217-4531-B0B7-45BC8D820A28}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{978BECEF-5217-4531-B0B7-45BC8D820A28}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{978BECEF-5217-4531-B0B7-45BC8D820A28}.Release|x86.Build.0 = Release|Any CPU\r\n\t\t{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Debug|ARM64.ActiveCfg = Debug|Any CPU\r\n\t\t{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Debug|ARM64.Build.0 = Debug|Any CPU\r\n\t\t{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Release|ARM64.ActiveCfg = Release|Any CPU\r\n\t\t{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Release|ARM64.Build.0 = Release|Any CPU\r\n\t\t{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Release|x86.Build.0 = Release|Any CPU\r\n\t\t{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Debug|ARM64.ActiveCfg = Debug|Any CPU\r\n\t\t{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Debug|ARM64.Build.0 = Debug|Any CPU\r\n\t\t{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Release|ARM64.ActiveCfg = Release|Any CPU\r\n\t\t{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Release|ARM64.Build.0 = Release|Any CPU\r\n\t\t{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Release|x86.Build.0 = Release|Any CPU\r\n\t\t{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Debug|ARM64.ActiveCfg = Debug|Any CPU\r\n\t\t{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Debug|ARM64.Build.0 = Debug|Any CPU\r\n\t\t{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Release|ARM64.ActiveCfg = Release|Any CPU\r\n\t\t{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Release|ARM64.Build.0 = Release|Any CPU\r\n\t\t{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Release|x86.Build.0 = Release|Any CPU\r\n\t\t{6598690F-B65B-4C49-824B-7474E735AE92}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{6598690F-B65B-4C49-824B-7474E735AE92}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{6598690F-B65B-4C49-824B-7474E735AE92}.Debug|ARM64.ActiveCfg = Debug|Any CPU\r\n\t\t{6598690F-B65B-4C49-824B-7474E735AE92}.Debug|ARM64.Build.0 = Debug|Any CPU\r\n\t\t{6598690F-B65B-4C49-824B-7474E735AE92}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{6598690F-B65B-4C49-824B-7474E735AE92}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{6598690F-B65B-4C49-824B-7474E735AE92}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{6598690F-B65B-4C49-824B-7474E735AE92}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{6598690F-B65B-4C49-824B-7474E735AE92}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{6598690F-B65B-4C49-824B-7474E735AE92}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{6598690F-B65B-4C49-824B-7474E735AE92}.Release|ARM64.ActiveCfg = Release|Any CPU\r\n\t\t{6598690F-B65B-4C49-824B-7474E735AE92}.Release|ARM64.Build.0 = Release|Any CPU\r\n\t\t{6598690F-B65B-4C49-824B-7474E735AE92}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{6598690F-B65B-4C49-824B-7474E735AE92}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{6598690F-B65B-4C49-824B-7474E735AE92}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{6598690F-B65B-4C49-824B-7474E735AE92}.Release|x86.Build.0 = Release|Any CPU\r\n\t\t{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Debug|ARM64.ActiveCfg = Debug|Any CPU\r\n\t\t{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Debug|ARM64.Build.0 = Debug|Any CPU\r\n\t\t{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Release|ARM64.ActiveCfg = Release|Any CPU\r\n\t\t{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Release|ARM64.Build.0 = Release|Any CPU\r\n\t\t{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Release|x86.Build.0 = Release|Any CPU\r\n\t\t{A6554704-FE57-4473-BB46-8586F22472AA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{A6554704-FE57-4473-BB46-8586F22472AA}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{A6554704-FE57-4473-BB46-8586F22472AA}.Debug|ARM64.ActiveCfg = Debug|Any CPU\r\n\t\t{A6554704-FE57-4473-BB46-8586F22472AA}.Debug|ARM64.Build.0 = Debug|Any CPU\r\n\t\t{A6554704-FE57-4473-BB46-8586F22472AA}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{A6554704-FE57-4473-BB46-8586F22472AA}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{A6554704-FE57-4473-BB46-8586F22472AA}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{A6554704-FE57-4473-BB46-8586F22472AA}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{A6554704-FE57-4473-BB46-8586F22472AA}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{A6554704-FE57-4473-BB46-8586F22472AA}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{A6554704-FE57-4473-BB46-8586F22472AA}.Release|ARM64.ActiveCfg = Release|Any CPU\r\n\t\t{A6554704-FE57-4473-BB46-8586F22472AA}.Release|ARM64.Build.0 = Release|Any CPU\r\n\t\t{A6554704-FE57-4473-BB46-8586F22472AA}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{A6554704-FE57-4473-BB46-8586F22472AA}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{A6554704-FE57-4473-BB46-8586F22472AA}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{A6554704-FE57-4473-BB46-8586F22472AA}.Release|x86.Build.0 = Release|Any CPU\r\n\t\t{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Debug|ARM64.ActiveCfg = Debug|Any CPU\r\n\t\t{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Debug|ARM64.Build.0 = Debug|Any CPU\r\n\t\t{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Release|ARM64.ActiveCfg = Release|Any CPU\r\n\t\t{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Release|ARM64.Build.0 = Release|Any CPU\r\n\t\t{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Release|x86.Build.0 = Release|Any CPU\r\n\t\t{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Debug|ARM64.ActiveCfg = Debug|Any CPU\r\n\t\t{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Debug|ARM64.Build.0 = Debug|Any CPU\r\n\t\t{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Debug|ARM64.Deploy.0 = Debug|Any CPU\r\n\t\t{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Debug|x64.Deploy.0 = Debug|Any CPU\r\n\t\t{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Debug|x86.Deploy.0 = Debug|Any CPU\r\n\t\t{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Release|ARM64.ActiveCfg = Release|Any CPU\r\n\t\t{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Release|ARM64.Build.0 = Release|Any CPU\r\n\t\t{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Release|ARM64.Deploy.0 = Release|Any CPU\r\n\t\t{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Release|x64.Deploy.0 = Release|Any CPU\r\n\t\t{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Release|x86.Build.0 = Release|Any CPU\r\n\t\t{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Release|x86.Deploy.0 = Release|Any CPU\r\n\t\t{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Debug|ARM64.ActiveCfg = Debug|Any CPU\r\n\t\t{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Debug|ARM64.Build.0 = Debug|Any CPU\r\n\t\t{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Release|ARM64.ActiveCfg = Release|Any CPU\r\n\t\t{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Release|ARM64.Build.0 = Release|Any CPU\r\n\t\t{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Release|x86.Build.0 = Release|Any CPU\r\n\t\t{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Debug|ARM64.ActiveCfg = Debug|Any CPU\r\n\t\t{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Debug|ARM64.Build.0 = Debug|Any CPU\r\n\t\t{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Release|ARM64.ActiveCfg = Release|Any CPU\r\n\t\t{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Release|ARM64.Build.0 = Release|Any CPU\r\n\t\t{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Release|x86.Build.0 = Release|Any CPU\r\n\t\t{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Debug|ARM64.ActiveCfg = Debug|Any CPU\r\n\t\t{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Debug|ARM64.Build.0 = Debug|Any CPU\r\n\t\t{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Release|ARM64.ActiveCfg = Release|Any CPU\r\n\t\t{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Release|ARM64.Build.0 = Release|Any CPU\r\n\t\t{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Release|x86.Build.0 = Release|Any CPU\r\n\t\t{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Debug|ARM64.ActiveCfg = Debug|Any CPU\r\n\t\t{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Debug|ARM64.Build.0 = Debug|Any CPU\r\n\t\t{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Release|ARM64.ActiveCfg = Release|Any CPU\r\n\t\t{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Release|ARM64.Build.0 = Release|Any CPU\r\n\t\t{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Release|x86.Build.0 = Release|Any CPU\r\n\t\t{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Debug|Any CPU.ActiveCfg = Debug|x64\r\n\t\t{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Debug|Any CPU.Deploy.0 = Debug|x64\r\n\t\t{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Debug|ARM64.ActiveCfg = Debug|ARM64\r\n\t\t{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Debug|ARM64.Build.0 = Debug|ARM64\r\n\t\t{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Debug|ARM64.Deploy.0 = Debug|ARM64\r\n\t\t{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Debug|x64.ActiveCfg = Debug|x64\r\n\t\t{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Debug|x64.Build.0 = Debug|x64\r\n\t\t{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Debug|x64.Deploy.0 = Debug|x64\r\n\t\t{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Debug|x86.ActiveCfg = Debug|x86\r\n\t\t{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Debug|x86.Build.0 = Debug|x86\r\n\t\t{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Debug|x86.Deploy.0 = Debug|x86\r\n\t\t{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Release|Any CPU.ActiveCfg = Release|x64\r\n\t\t{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Release|ARM64.ActiveCfg = Release|ARM64\r\n\t\t{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Release|ARM64.Build.0 = Release|ARM64\r\n\t\t{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Release|ARM64.Deploy.0 = Release|ARM64\r\n\t\t{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Release|x64.ActiveCfg = Release|x64\r\n\t\t{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Release|x64.Build.0 = Release|x64\r\n\t\t{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Release|x64.Deploy.0 = Release|x64\r\n\t\t{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Release|x86.ActiveCfg = Release|x86\r\n\t\t{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Release|x86.Build.0 = Release|x86\r\n\t\t{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Release|x86.Deploy.0 = Release|x86\r\n\t\t{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Debug|ARM64.ActiveCfg = Debug|Any CPU\r\n\t\t{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Debug|ARM64.Build.0 = Debug|Any CPU\r\n\t\t{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Release|ARM64.ActiveCfg = Release|Any CPU\r\n\t\t{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Release|ARM64.Build.0 = Release|Any CPU\r\n\t\t{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Release|x86.Build.0 = Release|Any CPU\r\n\t\t{EC0E35F9-9362-41CB-8F8F-797547803892}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{EC0E35F9-9362-41CB-8F8F-797547803892}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{EC0E35F9-9362-41CB-8F8F-797547803892}.Debug|ARM64.ActiveCfg = Debug|Any CPU\r\n\t\t{EC0E35F9-9362-41CB-8F8F-797547803892}.Debug|ARM64.Build.0 = Debug|Any CPU\r\n\t\t{EC0E35F9-9362-41CB-8F8F-797547803892}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{EC0E35F9-9362-41CB-8F8F-797547803892}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{EC0E35F9-9362-41CB-8F8F-797547803892}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{EC0E35F9-9362-41CB-8F8F-797547803892}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{EC0E35F9-9362-41CB-8F8F-797547803892}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{EC0E35F9-9362-41CB-8F8F-797547803892}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{EC0E35F9-9362-41CB-8F8F-797547803892}.Release|ARM64.ActiveCfg = Release|Any CPU\r\n\t\t{EC0E35F9-9362-41CB-8F8F-797547803892}.Release|ARM64.Build.0 = Release|Any CPU\r\n\t\t{EC0E35F9-9362-41CB-8F8F-797547803892}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{EC0E35F9-9362-41CB-8F8F-797547803892}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{EC0E35F9-9362-41CB-8F8F-797547803892}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{EC0E35F9-9362-41CB-8F8F-797547803892}.Release|x86.Build.0 = Release|Any CPU\r\n\t\t{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Debug|ARM64.ActiveCfg = Debug|Any CPU\r\n\t\t{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Debug|ARM64.Build.0 = Debug|Any CPU\r\n\t\t{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Release|ARM64.ActiveCfg = Release|Any CPU\r\n\t\t{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Release|ARM64.Build.0 = Release|Any CPU\r\n\t\t{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Release|x86.Build.0 = Release|Any CPU\r\n\t\t{C55C88AE-1C1E-469A-A34A-AE508885D616}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{C55C88AE-1C1E-469A-A34A-AE508885D616}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{C55C88AE-1C1E-469A-A34A-AE508885D616}.Debug|ARM64.ActiveCfg = Debug|Any CPU\r\n\t\t{C55C88AE-1C1E-469A-A34A-AE508885D616}.Debug|ARM64.Build.0 = Debug|Any CPU\r\n\t\t{C55C88AE-1C1E-469A-A34A-AE508885D616}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{C55C88AE-1C1E-469A-A34A-AE508885D616}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{C55C88AE-1C1E-469A-A34A-AE508885D616}.Debug|x86.ActiveCfg = Debug|Any CPU\r\n\t\t{C55C88AE-1C1E-469A-A34A-AE508885D616}.Debug|x86.Build.0 = Debug|Any CPU\r\n\t\t{C55C88AE-1C1E-469A-A34A-AE508885D616}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{C55C88AE-1C1E-469A-A34A-AE508885D616}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{C55C88AE-1C1E-469A-A34A-AE508885D616}.Release|ARM64.ActiveCfg = Release|Any CPU\r\n\t\t{C55C88AE-1C1E-469A-A34A-AE508885D616}.Release|ARM64.Build.0 = Release|Any CPU\r\n\t\t{C55C88AE-1C1E-469A-A34A-AE508885D616}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{C55C88AE-1C1E-469A-A34A-AE508885D616}.Release|x64.Build.0 = Release|Any CPU\r\n\t\t{C55C88AE-1C1E-469A-A34A-AE508885D616}.Release|x86.ActiveCfg = Release|Any CPU\r\n\t\t{C55C88AE-1C1E-469A-A34A-AE508885D616}.Release|x86.Build.0 = Release|Any CPU\r\n\tEndGlobalSection\r\n\tGlobalSection(SolutionProperties) = preSolution\r\n\t\tHideSolutionNode = FALSE\r\n\tEndGlobalSection\r\n\tGlobalSection(NestedProjects) = preSolution\r\n\t\t{17F32115-0300-4842-8328-395AB56F6BD7} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}\r\n\t\t{72DE3CB9-195E-4740-9416-5960D75ED795} = {FAB2137C-1DBA-4F2F-8E22-DF3521C9B365}\r\n\t\t{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B} = {0544806B-3BB4-43CF-8277-BC612F32208D}\r\n\t\t{57AC0130-0D5F-489A-A565-B41EF9928085} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}\r\n\t\t{BA40E541-3BCD-438A-B966-2FC7BE80AB80} = {FAB2137C-1DBA-4F2F-8E22-DF3521C9B365}\r\n\t\t{C492C048-732F-4F0D-AC09-03F3187ABB17} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}\r\n\t\t{978BECEF-5217-4531-B0B7-45BC8D820A28} = {FAB2137C-1DBA-4F2F-8E22-DF3521C9B365}\r\n\t\t{B7A5DDB0-5F43-49D0-A047-D0D26626BE30} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}\r\n\t\t{EBC13ACA-717D-4635-920A-5E0E211B0CF4} = {FAB2137C-1DBA-4F2F-8E22-DF3521C9B365}\r\n\t\t{E6418D3D-01AA-4176-A7CA-6878FA6E4238} = {FAB2137C-1DBA-4F2F-8E22-DF3521C9B365}\r\n\t\t{6598690F-B65B-4C49-824B-7474E735AE92} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}\r\n\t\t{4298FE47-5434-4A0B-9793-6B771E6FC4CA} = {FAB2137C-1DBA-4F2F-8E22-DF3521C9B365}\r\n\t\t{A6554704-FE57-4473-BB46-8586F22472AA} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}\r\n\t\t{B95D732A-7538-4795-AC42-6F595ECB8DB8} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}\r\n\t\t{2CD257D7-DF21-4D60-AC05-747D83236E5A} = {FAB2137C-1DBA-4F2F-8E22-DF3521C9B365}\r\n\t\t{F1D6609C-AA33-4099-8932-BADBCB935FBD} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}\r\n\t\t{BEF76A77-E2F9-4113-8DC2-DB825964D6EF} = {FAB2137C-1DBA-4F2F-8E22-DF3521C9B365}\r\n\t\t{D754069D-C912-4D71-97CB-9B2DDD2380B4} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}\r\n\t\t{87F12DBB-E32B-49B8-B5F1-5B53B711989B} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}\r\n\t\t{CDC17599-81AD-44B9-B4E5-38241147CDA2} = {FAB2137C-1DBA-4F2F-8E22-DF3521C9B365}\r\n\t\t{F55F3891-FD11-4C69-9DB6-0CC24B591F59} = {FAB2137C-1DBA-4F2F-8E22-DF3521C9B365}\r\n\t\t{EC0E35F9-9362-41CB-8F8F-797547803892} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}\r\n\t\t{3C77C89F-AA56-4C0A-9635-C0795F41C65C} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}\r\n\t\t{C55C88AE-1C1E-469A-A34A-AE508885D616} = {FAB2137C-1DBA-4F2F-8E22-DF3521C9B365}\r\n\tEndGlobalSection\r\n\tGlobalSection(ExtensibilityGlobals) = postSolution\r\n\t\tSolutionGuid = {84B77761-6B9E-46BA-B132-6C77B0B6E4FA}\r\n\tEndGlobalSection\r\nEndGlobal\r\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 139.865234375,
          "content": "# R3\n\nThe new future of [dotnet/reactive](https://github.com/dotnet/reactive/) and [UniRx](https://github.com/neuecc/UniRx), which support many platforms including [Unity](#unity), [Godot](#godot), [Avalonia](#avalonia), [WPF](#wpf), [WinForms](#winforms), [WinUI3](#winui3), [Stride](#stride), [LogicLooper](#logiclooper), [MAUI](#maui), [MonoGame](#monogame), [Blazor](#blazor).\n\nI have over 10 years of experience with Rx, experience in implementing a custom Rx runtime ([UniRx](https://github.com/neuecc/UniRx)) for game engine, and experience in implementing an asynchronous runtime ([UniTask](https://github.com/Cysharp/UniTask/)) for game engine. Based on those experiences, I came to believe that there is a need to implement a new Reactive Extensions for .NET, one that reflects modern C# and returns to the core values of Rx.\n\n* Stopping the pipeline at OnError is a mistake.\n* IScheduler is the root of poor performance.\n* Frame-based operations, a missing feature in Rx, are especially important in game engines.\n* Single asynchronous operations should be entirely left to async/await.\n* Synchronous APIs should not be implemented.\n* Query syntax is a bad notation except for SQL.\n* The Necessity of a subscription list to prevent subscription leaks (similar to a Parallel Debugger)\n* Backpressure should be left to [IAsyncEnumerable](https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/generate-consume-asynchronous-stream) and [Channels](https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/).\n* For distributed processing and queries, there are [GraphQL](https://graphql.org/), [Kubernetes](https://kubernetes.io/), [Orleans](https://learn.microsoft.com/en-us/dotnet/orleans/), [Akka.NET](https://getakka.net/), [gRPC](https://grpc.io/), [MagicOnion](https://github.com/Cysharp/MagicOnion).\n\nIn other words, LINQ is not for EveryThing, and we believe that the essence of Rx lies in the processing of in-memory messaging (LINQ to Events), which will be our focus. We are not concerned with communication processes like [Reactive Streams](https://www.reactive-streams.org/).\n\nTo address the shortcomings of dotnet/reactive, we have made changes to the core interfaces. In recent years, Rx-like frameworks optimized for language features, such as [Kotlin Flow](https://kotlinlang.org/docs/flow.html) and [Swift Combine](https://developer.apple.com/documentation/combine), have been standardized. C# has also evolved significantly, now at C# 12, and we believe there is a need for an Rx that aligns with the latest C#.\n\nImproving performance was also a theme in the reimplementation. For example, this is the result of the terrible performance of IScheduler and the performance difference caused by its removal.\n\n![image](https://github.com/Cysharp/ZLogger/assets/46207/68a12664-a840-4725-a87c-8fdbb03b4a02)\n`Observable.Range(1, 10000).Subscribe()`\n\nYou can also see interesting results in allocations with the addition and deletion to Subject.\n\n![image](https://github.com/Cysharp/ZLogger/assets/46207/2194c086-37a3-44d6-8642-5fd0fa91b168)\n`x10000 subject.Subscribe() -> x10000 subscription.Dispose()`\n\nThis is because dotnet/reactive has adopted ImmutableArray (or its equivalent) for Subject, which results in the allocation of a new array every time one is added or removed. Depending on the design of the application, a large number of subscriptions can occur (we have seen this especially in the complexity of games), which can be a critical issue. In R3, we have devised a way to achieve high performance while avoiding ImmutableArray.\n\nFor those interested in learning more about the implementation philosophy and comparisons, please refer to my blog article [R3 — A New Modern Reimplementation of Reactive Extensions for C#](https://neuecc.medium.com/r3-a-new-modern-reimplementation-of-reactive-extensions-for-c-cf29abcc5826).\n\nCore Interface\n---\nThis library is distributed via NuGet, supporting .NET Standard 2.0, .NET Standard 2.1, .NET 6(.NET 7) and .NET 8 or above.\n\n> PM> Install-Package [R3](https://www.nuget.org/packages/R3)\n\nSome platforms(WPF, Avalonia, Unity, Godot) requires additional step to install. Please see [Platform Supports](#platform-supports) section in below.\n\nR3 code is mostly the same as standard Rx. Make the Observable via factory methods(Timer, Interval, FromEvent, Subject, etc...) and chain operator via LINQ methods. Therefore, your knowledge about Rx and documentation on Rx can be almost directly applied. If you are new to Rx, the [ReactiveX](https://reactivex.io/intro.html) website and [Introduction to Rx.NET](https://introtorx.com/) would be useful resources for reference.\n\n```csharp\nusing R3;\n\nvar subscription = Observable.Interval(TimeSpan.FromSeconds(1))\n    .Select((_, i) => i)\n    .Where(x => x % 2 == 0)\n    .Subscribe(x => Console.WriteLine($\"Interval:{x}\"));\n\nvar cts = new CancellationTokenSource();\n_ = Task.Run(() => { Console.ReadLine(); cts.Cancel(); });\n\nawait Observable.Timer(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(3))\n    .TakeUntil(cts.Token)\n    .ForEachAsync(x => Console.WriteLine($\"Timer\"));\n\nsubscription.Dispose();\n```\n\nThe surface API remains the same as normal Rx, but the interfaces used internally are different and are not `IObservable<T>/IObserver<T>`.\n\n`IObservable<T>` being the dual of `IEnumerable<T>` is a beautiful definition, but it was not very practical in use.\n\n```csharp\npublic abstract class Observable<T>\n{\n    public IDisposable Subscribe(Observer<T> observer);\n}\n\npublic abstract class Observer<T> : IDisposable\n{\n    public void OnNext(T value);\n    public void OnErrorResume(Exception error);\n    public void OnCompleted(Result result); // Result is (Success | Failure)\n}\n```\n\nThe biggest difference is that in normal Rx, when an exception occurs in the pipeline, it flows to `OnError` and the subscription is unsubscribed, but in R3, it flows to `OnErrorResume` and the subscription is not unsubscribed.\n\nI consider the automatic unsubscription by OnError to be a bad design for event handling. It's very difficult and risky to resolve it within an operator like Retry, and it also led to poor performance (there are many questions and complex answers about stopping and resubscribing all over the world). Also, converting OnErrorResume to OnError(OnCompleted(Result.Failure)) is easy and does not degrade performance, but the reverse is impossible. Therefore, the design was changed to not stop by default and give users the choice to stop.\n\nSince the original Rx contract was `OnError | OnCompleted`, it was changed to `OnCompleted(Result result)` to consolidate into one method. Result is a readonly struct with two states: `Success() | Failure(Exception)`.\n\nThe reason for changing to an abstract class instead of an interface is that Rx has implicit complex contracts that interfaces do not guarantee. By making it an abstract class, we fully controlled the behavior of Subscribe, OnNext, and Dispose. This made it possible to manage the list of all subscriptions and prevent subscription leaks.\n\n![image](https://github.com/Cysharp/ZLogger/assets/46207/149abca5-6d84-44ea-8373-b0e8cd2dc46a)\n\nSubscription leaks are a common problem in applications with long lifecycles, such as GUIs or games. Tracking all subscriptions makes it easy to prevent leaks.\n\nInternally, when subscribing, an Observer is always linked to the target Observable and doubles as a Subscription. This ensures that Observers are reliably connected from top to bottom, making tracking certain and clear that they are released on OnCompleted/Dispose. In terms of performance, because the Observer itself always becomes a Subscription, there is no need for unnecessary IDisposable allocations.\n\nTimeProvider instead of IScheduler\n---\nIn traditional Rx, `IScheduler` was used as an abstraction for time-based processing, but in R3, we have discontinued its use and instead opted for the [TimeProvider](https://learn.microsoft.com/en-us/dotnet/api/system.timeprovider?view=net-8.0) introduced in .NET 8. For example, the operators are defined as follows:\n\n```csharp\npublic static Observable<Unit> Interval(TimeSpan period, TimeProvider timeProvider);\npublic static Observable<T> Delay<T>(this Observable<T> source, TimeSpan dueTime, TimeProvider timeProvider)\npublic static Observable<T> Debounce<T>(this Observable<T> source, TimeSpan timeSpan, TimeProvider timeProvider) // same as Throttle in dotnet/reactive\n```\n\nOriginally, `IScheduler` had performance issues, and the internal implementation of dotnet/reactive was peppered with code that circumvented these issues using `PeriodicTimer` and `IStopwatch`, leading to unnecessary complexity. These can be better expressed with TimeProvider (`TimeProvider.CreateTimer()`, `TimeProvider.GetTimestamp()`).\n\nWhile TimeProvider is an abstraction for asynchronous operations, excluding the Fake for testing purposes, `IScheduler` included synchronous schedulers like `ImmediateScheduler` and `CurrentThreadScheduler`. However, these were also meaningless as applying them to time-based operators would cause blocking, and `CurrentThreadScheduler` had poor performance.\n\n![image](https://github.com/Cysharp/ZLogger/assets/46207/68a12664-a840-4725-a87c-8fdbb03b4a02)\n`Observable.Range(1, 10000).Subscribe()`\n\nIn R3, anything that requires synchronous execution (like Range) is treated as Immediate, and everything else is considered asynchronous and handled through TimeProvider.\n\nAs for the implementation of TimeProvider, the standard TimeProvider.System using the ThreadPool is the default. For unit testing, FakeTimeProvider (Microsoft.Extensions.TimeProvider.Testing) is available. Additionally, many TimeProvider implementations are provided for different platforms, such as DispatcherTimerProvider for WPF and UpdateTimerProvider for Unity, enhancing ease of use tailored to each platform.\n\nFrame based operations\n---\nIn GUI applications, there's the message loop, and in game engines, there's the game loop. Platforms that operate based on loops are not uncommon. The idea of executing something after a few seconds or frames fits very well with Rx. Just as time has been abstracted through TimeProvider, we introduced a layer of abstraction for frames called FrameProvider, and added frame-based operators corresponding to all methods that accept TimeProvider.\n\n```csharp\npublic static Observable<Unit> IntervalFrame(int periodFrame, FrameProvider frameProvider);\npublic static Observable<T> DelayFrame<T>(this Observable<T> source, int frameCount, FrameProvider frameProvider)\npublic static Observable<T> DebounceFrame<T>(this Observable<T> source, int frameCount, FrameProvider frameProvider)\n```\n\nThe effectiveness of frame-based processing has been proven in Unity's Rx implementation, [neuecc/UniRx](https://github.com/neuecc/UniRx), which is one of the reasons why UniRx has gained strong support.\n\nThere are also several operators unique to frame-based processing.\n\n```csharp\n// push OnNext every frame.\nObservable.EveryUpdate().Subscribe(x => Console.WriteLine(x));\n\n// take value until next frame\neventSoure.TakeUntil(Observable.NextFrame()).Subscribe();\n\n// polling value changed\nObservable.EveryValueChanged(this, x => x.Width).Subscribe(x => WidthText.Text = x.ToString());\nObservable.EveryValueChanged(this, x => x.Height).Subscribe(x => HeightText.Text = x.ToString());\n```\n\n`EveryValueChanged` could be interesting, as it converts properties without Push-based notifications like `INotifyPropertyChanged`.\n\n![](https://cloud.githubusercontent.com/assets/46207/15827886/1573ff16-2c48-11e6-9876-4e4455d7eced.gif)`\n\nSubjects(ReactiveProperty)\n---\nIn R3, there are five types of Subjects: `Subject`, `BehaviorSubject`, `ReactiveProperty`, `ReplaySubject`, and `ReplayFrameSubject`.\n\n`Subject` is an event in Rx. Just as an event can register multiple Actions and distribute values using Invoke, a `Subject` can register multiple `Observer`s and distribute values using OnNext, OnErrorResume, and OnCompleted. There are variations of Subject, such as `BehaviorSubject` and `ReactiveProperty`, which holds a single value internally, `ReplaySubject`, which holds multiple values based on count or time, and `ReplayFrameSubject`, which holds multiple values based on frame time. The internally recorded values are distributed when Subscribe is called.\n\n `ReactiveProperty` corresponds to what would be a `BehaviorSubject`, but with the added functionality of eliminating duplicate values. In addition, since the value can be set with `.Value`, it can be utilized for binding on XAML platforms, etc.\n\nHere's an example of creating an observable model using `ReactiveProperty`:\n\n```csharp\n// Reactive Notification Model\npublic class Enemy\n{\n    public ReactiveProperty<long> CurrentHp { get; private set; }\n\n    public ReactiveProperty<bool> IsDead { get; private set; }\n\n    public Enemy(int initialHp)\n    {\n        // Declarative Property\n        CurrentHp = new ReactiveProperty<long>(initialHp);\n        IsDead = CurrentHp.Select(x => x <= 0).ToReactiveProperty();\n    }\n}\n\n// ---\n\n// Click button, HP decrement\nMyButton.OnClickAsObservable().Subscribe(_ => enemy.CurrentHp.Value -= 99);\n\n// subscribe from notification model.\nenemy.CurrentHp.Subscribe(x => Console.WriteLine(\"HP:\" + x));\nenemy.IsDead.Where(isDead => isDead == true)\n    .Subscribe(_ =>\n    {\n        // when dead, disable button\n        MyButton.SetDisable();\n    });\n```\n\nIn `ReactiveProperty`, the value is updated by `.Value` and if it is identical to the current value, no notification is issued. If you want to force notification of a value even if it is the same, call `.OnNext(value)`.\n\n`ReactiveProperty` has equivalents in other frameworks as well, such as [Android LiveData](https://developer.android.com/topic/libraries/architecture/livedata) and [Kotlin StateFlow](https://developer.android.com/kotlin/flow/stateflow-and-sharedflow), particularly effective for data binding in UI contexts. In .NET, there is a library called [runceel/ReactiveProperty](https://github.com/runceel/ReactiveProperty), which I originally created.\n\nUnlike dotnet/reactive's Subject, all Subjects in R3 (Subject, BehaviorSubject, ReactiveProperty, ReplaySubject, ReplayFrameSubject) are designed to call OnCompleted upon disposal. This is because R3 is designed with a focus on subscription management and unsubscription. By calling OnCompleted, it ensures that all subscriptions are unsubscribed from the Subject, the upstream source of events, by default. If you wish to avoid calling OnCompleted, you can do so by calling `Dispose(false)`.\n\n`ReactiveProperty` is mutable, but it can be converted to a read-only `ReadOnlyReactiveProperty`. Following the [guidance for the Android UI Layer](https://developer.android.com/topic/architecture/ui-layer), the Kotlin code below is\n\n```kotlin\nclass NewsViewModel(...) : ViewModel() {\n\n    private val _uiState = MutableStateFlow(NewsUiState())\n    val uiState: StateFlow<NewsUiState> = _uiState.asStateFlow()\n    ...\n}\n```\n\ncan be adapted to the following R3 code.\n\n```csharp\nclass NewsViewModel\n{\n    ReactiveProperty<NewsUiState> _uiState = new(new NewsUiState());\n    public ReadOnlyReactiveProperty<NewsUiState> UiState => _uiState;\n}\n```\n\nIn R3, we use a combination of a mutable private field and a readonly public property.\n\nBy inheriting `ReactiveProperty` and overriding `OnValueChanging` and `OnValueChanged`, you can customize behavior, such as adding validation.\n\n```csharp\n// Since the primary constructor sets values to fields before calling base, it is safe to call OnValueChanging in the base constructor.\npublic sealed class ClampedReactiveProperty<T>(T initialValue, T min, T max)\n    : ReactiveProperty<T>(initialValue) where T : IComparable<T>\n{\n    private static IComparer<T> Comparer { get; } = Comparer<T>.Default;\n\n    protected override void OnValueChanging(ref T value)\n    {\n        if (Comparer.Compare(value, min) < 0)\n        {\n            value = min;\n        }\n        else if (Comparer.Compare(value, max) > 0)\n        {\n            value = max;\n        }\n    }\n}\n\n// For regular constructors, please set `callOnValueChangeInBaseConstructor` to false and manually call it once to correct the value.\npublic sealed class ClampedReactiveProperty2<T>\n    : ReactiveProperty<T> where T : IComparable<T>\n{\n    private static IComparer<T> Comparer { get; } = Comparer<T>.Default;\n\n    readonly T min, max;\n\n    // callOnValueChangeInBaseConstructor to avoid OnValueChanging call before min, max set.\n    public ClampedReactiveProperty2(T initialValue, T min, T max)\n        : base(initialValue, EqualityComparer<T>.Default, callOnValueChangeInBaseConstructor: false)\n    {\n        this.min = min;\n        this.max = max;\n\n        // modify currentValue manually\n        OnValueChanging(ref GetValueRef());\n    }\n\n    protected override void OnValueChanging(ref T value)\n    {\n        if (Comparer.Compare(value, min) < 0)\n        {\n            value = min;\n        }\n        else if (Comparer.Compare(value, max) > 0)\n        {\n            value = max;\n        }\n    }\n}\n```\n\nAdditionally, `ReactiveProperty` supports serialization with `System.Text.JsonSerializer` in .NET 6 and above. For earlier versions, you need to implement `ReactivePropertyJsonConverterFactory` under the existing implementation and add it to the Converter.\n\nAs an internal implementation, `Subject` and `ReactiveProperty` has a lightweight implementation that consumes less memory. However, in exchange, its behavior differs slightly, especially in multi-threaded environments. For precautions related to multi-threading, please refer to the [Concurrency Policy](#concurrency-policy) section.\n\nDisposable\n---\nTo bundle multiple IDisposables (Subscriptions), it's good to use Disposable's methods. In R3, depending on the performance,\n\n```csharp\nDisposable.Combine(IDisposable d1, ..., IDisposable d8);\nDisposable.Combine(params IDisposable[]);\nDisposable.CreateBuilder();\nCompositeDisposable\nDisposableBag\n```\n\nfive types are available for use. In terms of performance advantages, the order is `Combine(d1,...,d8) (>= CreateBuilder) > Combine(IDisposable[]) >= CreateBuilder > DisposableBag > CompositeDisposable`.\n\nWhen the number of subscriptions is statically determined, Combine offers the best performance. Internally, for less than 8 arguments, it uses fields, and for 9 or more arguments, it uses an array, making Combine especially efficient for 8 arguments or less.\n\n```csharp\npublic partial class MainWindow : Window\n{\n    IDisposable disposable;\n\n    public MainWindow()\n    {\n        var d1 = Observable.IntervalFrame(1).Subscribe();\n        var d2 = Observable.IntervalFrame(1).Subscribe();\n        var d3 = Observable.IntervalFrame(1).Subscribe();\n\n        disposable = Disposable.Combine(d1, d2, d3);\n    }\n\n    protected override void OnClosed(EventArgs e)\n    {\n        disposable.Dispose();\n    }\n}\n```\n\nIf there are many subscriptions and it's cumbersome to hold each one in a variable, `CreateBuilder` can be used instead. At build time, it combines according to the number of items added to it. Since the Builder itself is a struct, there are no allocations.\n\n```csharp\npublic partial class MainWindow : Window\n{\n    IDisposable disposable;\n\n    public MainWindow()\n    {\n        var d = Disposable.CreateBuilder();\n        Observable.IntervalFrame(1).Subscribe().AddTo(ref d);\n        Observable.IntervalFrame(1).Subscribe().AddTo(ref d);\n        Observable.IntervalFrame(1).Subscribe().AddTo(ref d);\n\n        disposable = d.Build();\n    }\n\n    protected override void OnClosed(EventArgs e)\n    {\n        disposable.Dispose();\n    }\n}\n```\n\nFor dynamically added items, using `DisposableBag` is advisable. This is an add-only struct with only `Add/Clear/Dispose` methods. It can be used relatively quickly and with low allocation by holding it in a class field and passing it around by reference. However, it is not thread-safe.\n\n```csharp\npublic partial class MainWindow : Window\n{\n    DisposableBag disposable; // DisposableBag is struct, no need new and don't copy\n\n    public MainWindow()\n    {\n        Observable.IntervalFrame(1).Subscribe().AddTo(ref disposable);\n        Observable.IntervalFrame(1).Subscribe().AddTo(ref disposable);\n        Observable.IntervalFrame(1).Subscribe().AddTo(ref disposable);\n    }\n\n    void OnClick()\n    {\n        Observable.IntervalFrame(1).Subscribe().AddTo(ref disposable);\n    }\n\n    protected override void OnClosed(EventArgs e)\n    {\n        disposable.Dispose();\n    }\n}\n```\n\n`CompositeDisposable` is a class that also supports `Remove` and is thread-safe. It is the most feature-rich, but comparatively, it has the lowest performance.\n\n```csharp\npublic partial class MainWindow : Window\n{\n    CompositeDisposable disposable = new CompositeDisposable();\n\n    public MainWindow()\n    {\n        Observable.IntervalFrame(1).Subscribe().AddTo(disposable);\n        Observable.IntervalFrame(1).Subscribe().AddTo(disposable);\n        Observable.IntervalFrame(1).Subscribe().AddTo(disposable);\n    }\n\n    void OnClick()\n    {\n        Observable.IntervalFrame(1).Subscribe().AddTo(disposable);\n    }\n\n    protected override void OnClosed(EventArgs e)\n    {\n        disposable.Dispose();\n    }\n}\n```\n\nAdditionally, there are other utilities for Disposables as follows.\n\n```csharp\nDisposable.Create(Action);\nDisposable.Dispose(...);\nSingleAssignmentDisposable\nSingleAssignmentDisposableCore // struct\nSerialDisposable\nSerialDisposableCore // struct\n```\n\nSubscription Management\n---\nManaging subscriptions is one of the most crucial aspects of Rx, and inadequate management can lead to memory leaks. There are two patterns for unsubscribing in Rx. One is by disposing of the IDisposable (Subscription) returned by Subscribe. The other is by receiving OnCompleted.\n\nIn R3, to enhance subscription cancellation on both fronts, it's now possible to bundle subscriptions using a variety of Disposable classes for Subscriptions, and for OnCompleted, the upstream side of events (such as Subject or Factory) has been made capable of emitting OnCompleted. Especially, Factories that receive a TimeProvider or FrameProvider can now take a CancellationToken.\n\n```csharp\npublic static Observable<Unit> Interval(TimeSpan period, TimeProvider timeProvider, CancellationToken cancellationToken)\npublic static Observable<Unit> EveryUpdate(FrameProvider frameProvider, CancellationToken cancellationToken)\n```\n\nWhen cancelled, OnCompleted is sent, and all subscriptions are unsubscribed.\n\n### ObservableTracker\n\nR3 incorporates a system called ObservableTracker. When activated, it allows you to view all subscription statuses.\n\n```csharp\nObservableTracker.EnableTracking = true; // default is false\nObservableTracker.EnableStackTrace = true;\n\nusing var d = Observable.Interval(TimeSpan.FromSeconds(1))\n    .Where(x => true)\n    .Take(10000)\n    .Subscribe();\n\n// check subscription\nObservableTracker.ForEachActiveTask(x =>\n{\n    Console.WriteLine(x);\n});\n```\n\n```csharp\nTrackingState { TrackingId = 1, FormattedType = Timer._Timer, AddTime = 2024/01/09 4:11:39, StackTrace =... }\nTrackingState { TrackingId = 2, FormattedType = Where`1._Where<Unit>, AddTime = 2024/01/09 4:11:39, StackTrace =... }\nTrackingState { TrackingId = 3, FormattedType = Take`1._Take<Unit>, AddTime = 2024/01/09 4:11:39, StackTrace =... }\n```\n\nBesides directly calling `ForEachActiveTask`, making it more accessible through a GUI can make it easier to check for subscription leaks. Currently, there is an integrated GUI for Unity, and there are plans to provide a screen using Blazor for other platforms.\n\nObservableSystem, UnhandledExceptionHandler\n---\nFor time-based operators that do not specify a TimeProvider or FrameProvider, the default Provider of ObservableSystem is used. This is settable, so if there is a platform-specific Provider (for example, DispatcherTimeProvider in WPF), you can swap it out to create a more user-friendly environment.\n\n```csharp\npublic static class ObservableSystem\n{\n    public static TimeProvider DefaultTimeProvider { get; set; } = TimeProvider.System;\n    public static FrameProvider DefaultFrameProvider { get; set; } = new NotSupportedFrameProvider();\n\n    static Action<Exception> unhandledException = DefaultUnhandledExceptionHandler;\n\n    // Prevent +=, use Set and Get method.\n    public static void RegisterUnhandledExceptionHandler(Action<Exception> unhandledExceptionHandler)\n    {\n        unhandledException = unhandledExceptionHandler;\n    }\n\n    public static Action<Exception> GetUnhandledExceptionHandler()\n    {\n        return unhandledException;\n    }\n\n    static void DefaultUnhandledExceptionHandler(Exception exception)\n    {\n        Console.WriteLine(\"R3 UnhandledException: \" + exception.ToString());\n    }\n}\n```\n\nIn CUI environments, by default, the FrameProvider will throw an exception. If you want to use FrameProvider in a CUI environment, you can set either `NewThreadSleepFrameProvider`, which sleeps in a new thread for a specified number of seconds, or `TimerFrameProvider`, which executes every specified number of seconds.\n\n### UnhandledExceptionHandler\n\nWhen an exception passes through OnErrorResume and is not ultimately handled by Subscribe, the UnhandledExceptionHandler of ObservableSystem is called. This can be set with `RegisterUnhandledExceptionHandler`. By default, it writes to `Console.WriteLine`, but it may need to be changed to use `ILogger` or something else as required.\n\nResult Handling\n---\nThe `Result` received by OnCompleted has a field `Exception?`, where it's null in case of success and contains the Exception in case of failure.\n\n```csharp\n// Typical processing code example\nvoid OnCompleted(Result result)\n{\n    if (result.IsFailure)\n    {\n        // do failure\n        _ = result.Exception;\n    }\n    else // result.IsSuccess\n    {\n        // do success\n    }\n}\n```\n\nTo generate a `Result`, in addition to using `Result.Success` and `Result.Failure(exception)`, Observer has OnCompleted() and OnCompleted(exception) as shortcuts for Success and Failure, respectively.\n\n```csharp\nobserver.OnCompleted(Result.Success);\nobserver.OnCompleted(Result.Failure(exception));\n\nobserver.OnCompleted(); // same as Result.Success\nobserver.OnCompleted(exception); // same as Result.Failure(exception)\n```\n\nUnit Testing\n---\nFor unit testing, you can use [FakeTimeProvider](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.time.testing.faketimeprovider) of Microsoft.Extensions.TimeProvider.Testing.\n\nAdditionally, in R3, there is a collection called LiveList, which allows you to obtain subscription statuses as a list. Combining these two features can be very useful for unit testing.\n\n```csharp\nvar fakeTime = new FakeTimeProvider();\n\nvar list = Observable.Timer(TimeSpan.FromSeconds(5), fakeTime).ToLiveList();\n\nfakeTime.Advance(TimeSpan.FromSeconds(4));\nlist.AssertIsNotCompleted();\n\nfakeTime.Advance(TimeSpan.FromSeconds(1));\nlist.AssertIsCompleted();\nlist.AssertEqual([Unit.Default]);\n```\n\nFor FrameProvider, a `FakeFrameProvider` is provided as standard, and it can be used in the same way as `FakeTimeProvider`.\n\n```csharp\nvar cts = new CancellationTokenSource();\nvar frameProvider = new FakeFrameProvider();\n\nvar list = Observable.EveryUpdate(frameProvider, cts.Token)\n    .Select(_ => frameProvider.GetFrameCount())\n    .ToLiveList();\n\nlist.AssertEqual([]); // list.Should().Equal(expected);\n\nframeProvider.Advance();\nlist.AssertEqual([0]);\n\nframeProvider.Advance(3);\nlist.AssertEqual([0, 1, 2, 3]);\n\ncts.Cancel();\nlist.AssertIsCompleted(); // list.IsCompleted.Should().BeTrue();\n\nframeProvider.Advance();\nlist.AssertEqual([0, 1, 2, 3]);\nlist.AssertIsCompleted();\n```\n\n`AssertEqual` is a test helper. You can create your own helper to use with the test library.\n\n```csharp\npublic static class LiveListExtensions\n{\n    // Should() is xUnit + FluentAssertions\n    public static void AssertEqual<T>(this LiveList<T> list, params T[] expected)\n    {\n        list.Should().Equal(expected);\n    }\n\n    public static void AssertEqual<T>(this LiveList<T[]> list, params T[][] expected)\n    {\n        list.Count.Should().Be(expected.Length);\n\n        for (int i = 0; i < expected.Length; i++)\n        {\n            list[i].Should().Equal(expected[i]);\n        }\n    }\n\n    public static void AssertEmpty<T>(this LiveList<T> list)\n    {\n        list.Count.Should().Be(0);\n    }\n\n    public static void AssertIsCompleted<T>(this LiveList<T> list)\n    {\n        list.IsCompleted.Should().BeTrue();\n    }\n\n    public static void AssertIsNotCompleted<T>(this LiveList<T> list)\n    {\n        list.IsCompleted.Should().BeFalse();\n    }\n\n    public static void Advance(this FakeTimeProvider timeProvider, int seconds)\n    {\n        timeProvider.Advance(TimeSpan.FromSeconds(seconds));\n    }\n}\n```\n\nInteroperability with `IObservable<T>`\n---\n`Observable<T>` is not `IObservable<T>`. You can convert both by these methods.\n\n* `public static Observable<T> ToObservable<T>(this IObservable<T> source)`\n* `public static IObservable<T> AsSystemObservable<T>(this Observable<T> source)`\n\nInteroperability with `async/await`\n---\nR3 has special integration with `async/await`. First, all methods that return a single asynchronous operation have now become ***Async methods, returning `Task<T>`.\n\nFurthermore, you can specify special behaviors when asynchronous methods are provided to Where/Select/Subscribe.\n\n| Name | ReturnType |\n| --- | --- |\n| **SelectAwait**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask<TResult>>` selector, `AwaitOperation` awaitOperation = AwaitOperation.Sequential, `bool` configureAwait = true, `bool` cancelOnCompleted = true, `int` maxConcurrent = -1) | `Observable<TResult>` |\n| **WhereAwait**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask<Boolean>>` predicate, `AwaitOperation` awaitOperation = AwaitOperation.Sequential, `bool` configureAwait = true, `bool` cancelOnCompleted = true, `int` maxConcurrent = -1) | `Observable<T>` |\n| **SubscribeAwait**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` onNextAsync, `AwaitOperation` awaitOperation = AwaitOperation.Sequential, `bool` configureAwait = true, `bool` cancelOnCompleted = true, `int` maxConcurrent = -1) | `IDisposable` |\n| **SubscribeAwait**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` onNextAsync, `Action<Result>` onCompleted, `AwaitOperation` awaitOperation = AwaitOperation.Sequential, `bool` configureAwait = true, `bool` cancelOnCompleted = true, `int` maxConcurrent = -1) | `IDisposable` |\n| **SubscribeAwait**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` onNextAsync, `Action<Exception>` onErrorResume, `Action<Result>` onCompleted, `AwaitOperation` awaitOperation = AwaitOperation.Sequential, `bool` configureAwait = true, `bool` cancelOnCompleted = true, `int` maxConcurrent = -1) | `IDisposable` |\n\n```csharp\npublic enum AwaitOperation\n{\n    /// <summary>All values are queued, and the next value waits for the completion of the asynchronous method.</summary>\n    Sequential,\n    /// <summary>Drop new value when async operation is running.</summary>\n    Drop,\n    /// <summary>If the previous asynchronous method is running, it is cancelled and the next asynchronous method is executed.</summary>\n    Switch,\n    /// <summary>All values are sent immediately to the asynchronous method.</summary>\n    Parallel,\n    /// <summary>All values are sent immediately to the asynchronous method, but the results are queued and passed to the next operator in order.</summary>\n    SequentialParallel,\n    /// <summary>Send the first value and the last value while the asynchronous method is running.</summary>\n    ThrottleFirstLast\n}\n```\n\n```csharp\n// for example...\n// Drop enables prevention of execution by multiple clicks\nbutton.OnClickAsObservable()\n    .SelectAwait(async (_, ct) =>\n    {\n        var req = await UnityWebRequest.Get(\"https://google.com/\").SendWebRequest().WithCancellation(ct);\n        return req.downloadHandler.text;\n    }, AwaitOperation.Drop)\n    .SubscribeToText(text);\n```\n\n`maxConcurrent` is only effective for `Parallel` and `SequentialParallel`, allowing control over the number of parallel operations. By default, it allows unlimited parallelization.\n\n`cancelOnCompleted` lets you choose whether to cancel the ongoing asynchronous method (by setting CancellationToken to Cancel) when the `OnCompleted` event is received. The default is true, meaning it will be cancelled. If set to false, it waits for the completion of the asynchronous method before calling the subsequent `OnCompleted` (potentially after issuing OnNext, depending on the case).\n\nAdditionally, the following time-related filtering/aggregating methods can also accept asynchronous methods.\n\n| Name | ReturnType |\n| --- | --- |\n| **Debounce**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` throttleDurationSelector, `Boolean` configureAwait = true) | `Observable<T>` |\n| **ThrottleFirst**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` sampler, `Boolean` configureAwait = true) | `Observable<T>` |\n| **ThrottleLast**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` sampler, `Boolean` configureAwait = true) | `Observable<T>` |\n| **ThrottleFirstLast**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` sampler, `Boolean` configureAwait = true) | `Observable<T>` |\n| **SkipUntil**(this `Observable<T>` source, `CancellationToken` cancellationToken) | `Observable<T>` | \n| **SkipUntil**(this `Observable<T>` source, `Task` task) | `Observable<T>` | \n| **SkipUntil**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` asyncFunc, `Boolean` configureAwait = true) | `Observable<T>` | \n| **TakeUntil**(this `Observable<T>` source, `CancellationToken` cancellationToken) | `Observable<T>` | \n| **TakeUntil**(this `Observable<T>` source, `Task` task) | `Observable<T>` | \n| **TakeUntil**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` asyncFunc, `Boolean` configureAwait = true) | `Observable<T>` | \n| **Chunk**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` asyncWindow, `Boolean` configureAwait = true) | `Observable<T[]>` | \n\nFor example, by using the asynchronous function version of Chunk, you can naturally and easily write complex processes such as generating chunks at random times instead of fixed times.\n\n```csharp\nObservable.Interval(TimeSpan.FromSeconds(1))\n    .Index()\n    .Chunk(async (_, ct) =>\n    {\n        await Task.Delay(TimeSpan.FromSeconds(Random.Shared.Next(0, 5)), ct);\n    })\n    .Subscribe(xs =>\n    {\n        Console.WriteLine(string.Join(\", \", xs));\n    });\n```\nThese asynchronous methods are immediately canceled when `OnCompleted` is issued, and the subsequent `OnCompleted` is executed.\n\nBy utilizing async/await for Retry-related operations, you can achieve better handling. For instance, whereas the previous version of Rx could only retry the entire pipeline, with R3, which accepts async/await, it is possible to retry on a per asynchronous method execution basis.\n\n```csharp\nbutton.OnClickAsObservable()\n    .SelectAwait(async (_, ct) =>\n    {\n        var retry = 0;\n    AGAIN:\n        try\n        {\n            var req = await UnityWebRequest.Get(\"https://google.com/\").SendWebRequest().WithCancellation(ct);\n            return req.downloadHandler.text;\n        }\n        catch\n        {\n            if (retry++ < 3) goto AGAIN;\n            throw;\n        }\n    }, AwaitOperation.Drop)\n```\n\nRepeat can also be implemented in combination with async/await. In this case, handling complex conditions for Repeat might be easier than completing it with Rx alone.\n\n```csharp\nwhile (!ct.IsCancellationRequested)\n{\n    await button.OnClickAsObservable()\n        .Take(1)\n        .ForEachAsync(_ =>\n        {\n            // do something\n        });\n}\n```\n\nConcurrency Policy\n---\nThe composition of operators is thread-safe, and it is expected that the values flowing through OnNext are on a single thread. In other words, if OnNext is issued on multiple threads, the operators may behave unexpectedly. This is the same as with dotnet/reactive.\n\nFor example, while Subject itself is thread-safe, the operators are not thread-safe.\n\n```csharp\n// dotnet/reactive\nvar subject = new System.Reactive.Subjects.Subject<int>();\n\n// single execution shows 100 but actually 9* multiple times(broken)\nsubject.Take(100).Count().Subscribe(x => Console.WriteLine(x));\n\nParallel.For(0, 1000, new ParallelOptions { MaxDegreeOfParallelism = 10 }, x => subject.OnNext(x));\n```\n\nThis means that the issuance of OnNext must always be done on a single thread. For converting external inputs into Observables, such as with `FromEvent`, and when the source of input issues in a multi-threaded manner, it is necessary to synchronize using `Synchronize` to construct the correct operator chain.\n\n```csharp\nsubject.Synchronize(gate).Take(100).Count().Subscribe();\n```\n\nUnlike dotnet/reactive, R3.Subject.OnNext is not ThreadSafe. If you are calling OnNext from multiple threads, please use a lock.\n\nIn R3, ReplaySubject and BehaviorSubject do not require Synchronize and are thread-safe, including OnNext.\n\nReactiveProperty is not thread-safe and OnNext, set Value and Subscribe cannot be called simultaneously. If you need to use it in such a situation, use `SynchronizedReactiveProperty` instead.\n\n```csharp\nclass MyClass\n{\n    public SynchronizedReactiveProperty<int> Prop { get; } = new();\n}\n```\n\nSampling Timing\n---\nThe `Sample(TimeSpan)` in dotnet/reactive starts a timer in the background when subscribed to, and uses that interval for filtering. Additionally, the timer continues to run in the background indefinitely.\n\n`ThrottleFirst/Last/FirstLast(TimeSpan)` in R3 behaves differently; the timer is stopped upon subscription and only starts when a value arrives. If the timer is stopped at that time, it starts, and then stops the timer after the specified duration.\n\nAlso, overloads that accept an asynchronous function `Func<T, CancellationToken, ValueTask>`, such as `ThrottleFirst/Last/FirstLast`, `Chunk`, `SkipUntil`, `TakeUntil`), behave in such a way that if the asynchronous function is not running when a value arrives, the execution of the asynchronous function begins.\n\nThis change is expected to result in consistent behavior across all operators.\n\nObservableCollections\n---\nAs a special collection for monitoring changes in collections and handling them in R3, the [ObservableCollections](https://github.com/Cysharp/ObservableCollections)'s `ObservableCollections.R3` package is available.\n\nIt has `ObservableList<T>`, `ObservableDictionary<TKey, TValue>`, `ObservableHashSet<T>`, `ObservableQueue<T>`, `ObservableStack<T>`, `ObservableRingBuffer<T>`, `ObservableFixedSizeRingBuffer<T>` and these observe methods.\n\n```csharp\nObservable<CollectionAddEvent<T>> IObservableCollection<T>.ObserveAdd()\nObservable<CollectionRemoveEvent<T>> IObservableCollection<T>.ObserveRemove()\nObservable<CollectionReplaceEvent<T>> IObservableCollection<T>.ObserveReplace()\nObservable<CollectionMoveEvent<T>> IObservableCollection<T>.ObserveMove()\nObservable<CollectionResetEvent<T>> IObservableCollection<T>.ObserveReset()\n```\n\nXAML Platforms(`BindableReactiveProperty<T>`)\n---\nFor XAML based application platforms, R3 provides `BindableReactiveProperty<T>` that can bind observable property to view like [Android LiveData](https://developer.android.com/topic/libraries/architecture/livedata) and [Kotlin StateFlow](https://developer.android.com/kotlin/flow/.stateflow-and-sharedflow). It implements [INotifyPropertyChanged](https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.inotifypropertychanged) and [INotifyDataErrorInfo](https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.inotifydataerrorinfo).\n\nSimple usage, expose `BindableReactiveProperty<T>` via `new` or `ToBindableReactiveProperty`.\n\nHere is the simple In and Out BindableReactiveProperty ViewModel, Xaml and code-behind. In xaml, `.Value` to bind property.\n\n```csharp\npublic class BasicUsagesViewModel : IDisposable\n{\n    public BindableReactiveProperty<string> Input { get; }\n    public BindableReactiveProperty<string> Output { get; }\n\n    public BasicUsagesViewModel()\n    {\n        Input = new BindableReactiveProperty<string>(\"\");\n        Output = Input.Select(x => x.ToUpper()).ToBindableReactiveProperty(\"\");\n    }\n\n    public void Dispose()\n    {\n        Disposable.Dispose(Input, Output);\n    }\n}\n```\n\n```xml\n<Window x:Class=\"WpfApp1.MainWindow\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n        xmlns:local=\"clr-namespace:WpfApp1\"\n        mc:Ignorable=\"d\"\n        Title=\"MainWindow\" Height=\"450\" Width=\"800\">\n    <Window.DataContext>\n        <local:BasicUsagesViewModel />\n    </Window.DataContext>\n    <StackPanel>\n        <TextBlock Text=\"Basic usages\" FontSize=\"24\" />\n\n        <Label Content=\"Input\" />\n        <TextBox Text=\"{Binding Input.Value, UpdateSourceTrigger=PropertyChanged}\" />\n\n        <Label Content=\"Output\" />\n        <TextBlock Text=\"{Binding Output.Value}\" />\n    </StackPanel>\n</Window>\n```\n\n```csharp\nnamespace WpfApp1;\n\npublic partial class MainWindow : Window\n{\n    public MainWindow()\n    {\n        InitializeComponent();\n    }\n\n    protected override void OnClosed(EventArgs e)\n    {\n        (this.DataContext as IDisposable)?.Dispose();\n    }\n}\n```\n\n![image](https://github.com/Cysharp/R3/assets/46207/01c3738f-e941-412e-b517-8e7867d6f709)\n\nBindableReactiveProperty also supports validation via DataAnnotation or custom logic. If you want to use DataAnnotation attribute, require to call `EnableValidation<T>()` in field initializer or `EnableValidation(Expression selfSelector)` in constructor.\n\n```csharp\npublic class ValidationViewModel : IDisposable\n{\n    // Pattern 1. use EnableValidation<T> to enable DataAnnotation validation in field initializer\n    [Range(0.0, 300.0)]\n    public BindableReactiveProperty<double> Height { get; } = new BindableReactiveProperty<double>().EnableValidation<ValidationViewModel>();\n\n    [Range(0.0, 300.0)]\n    public BindableReactiveProperty<double> Weight { get; }\n\n    IDisposable customValidation1Subscription;\n    public BindableReactiveProperty<double> CustomValidation1 { get; set; }\n\n    public BindableReactiveProperty<double> CustomValidation2 { get; set; }\n\n    public ValidationViewModel()\n    {\n        // Pattern 2. use EnableValidation(Expression) to enable DataAnnotation validation\n        Weight = new BindableReactiveProperty<double>().EnableValidation(() => Weight);\n\n        // Pattern 3. EnableValidation() and call OnErrorResume to set custom error message\n        CustomValidation1 = new BindableReactiveProperty<double>().EnableValidation();\n        customValidation1Subscription = CustomValidation1.Subscribe(x =>\n        {\n            if (0.0 <= x && x <= 300.0) return;\n\n            CustomValidation1.OnErrorResume(new Exception(\"value is not in range.\"));\n        });\n\n        // Pattern 4. simplified version of Pattern3, EnableValidation(Func<T, Exception?>)\n        CustomValidation2 = new BindableReactiveProperty<double>().EnableValidation(x =>\n        {\n            if (0.0 <= x && x <= 300.0) return null; // null is no validate result\n            return new Exception(\"value is not in range.\");\n        });\n    }\n\n    public void Dispose()\n    {\n        Disposable.Dispose(Height, Weight, CustomValidation1, customValidation1Subscription, CustomValidation2);\n    }\n}\n```\n\n```xml\n<Window x:Class=\"WpfApp1.MainWindow\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n        xmlns:local=\"clr-namespace:WpfApp1\"\n        mc:Ignorable=\"d\"\n        Title=\"MainWindow\" Height=\"450\" Width=\"800\">\n    <Window.DataContext>\n        <local:ValidationViewModel />\n    </Window.DataContext>\n\n    <StackPanel Margin=\"10\">\n        <Label Content=\"Validation\" />\n        <TextBox Text=\"{Binding Height.Value, UpdateSourceTrigger=PropertyChanged}\"  />\n        <TextBox  Text=\"{Binding Weight.Value, UpdateSourceTrigger=PropertyChanged}\" />\n        <TextBox  Text=\"{Binding CustomValidation1.Value, UpdateSourceTrigger=PropertyChanged}\" />\n        <TextBox  Text=\"{Binding CustomValidation2.Value, UpdateSourceTrigger=PropertyChanged}\" />\n    </StackPanel>\n</Window>\n```\n\n![image](https://github.com/Cysharp/R3/assets/46207/f80149e6-1573-46b5-9a77-b78776dd3527)\n\nThere is also `IReadOnlyBindableReactiveProperty<T>`, which is preferable when ReadOnly is required in binding, can create from `IObservable<T>.ToReadOnlyBindableReactiveProperty<T>`.\n\n### ReactiveCommand\n\n`ReactiveCommand<T>` and `ReactiveCommand` are observable [ICommand](https://learn.microsoft.com/en-us/dotnet/api/system.windows.input.icommand) implementation. It can create from `Observable<bool> canExecuteSource`.\n\n```csharp\npublic class CommandViewModel : IDisposable\n{\n    public BindableReactiveProperty<bool> OnCheck { get; } // bind to CheckBox\n    public ReactiveCommand ShowMessageBox { get; }   // bind to Button, non generics ReactiveCommand is ReactiveCommand<Unit>\n\n    public CommandViewModel()\n    {\n        OnCheck = new BindableReactiveProperty<bool>();\n        ShowMessageBox = OnCheck.ToReactiveCommand(_ =>\n        {\n            MessageBox.Show(\"clicked\");\n        });\n    }\n\n    public void Dispose()\n    {\n        Disposable.Dispose(OnCheck, ShowMessageBox);\n    }\n}\n```\n\n```xml\n<Window x:Class=\"WpfApp1.MainWindow\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n        xmlns:local=\"clr-namespace:WpfApp1\"\n        mc:Ignorable=\"d\"\n        Title=\"MainWindow\" Height=\"450\" Width=\"800\">\n    <Window.DataContext>\n        <local:CommandViewModel />\n    </Window.DataContext>\n    <StackPanel Margin=\"10\">\n        <Label Content=\"Command\" />\n        <CheckBox IsChecked=\"{Binding OnCheck.Value}\" />\n        <Button Content=\"Btn\" Command=\"{Binding ShowMessageBox}\" />\n    </StackPanel>\n</Window>\n```\n\n![rpcommand](https://github.com/Cysharp/R3/assets/46207/c456829e-1493-446d-831b-425f05be5d05)\n\n### INotifyPropertyChanged to Observable\n\nTo convert properties of `INotifyPropertyChanged` and `INotifyPropertyChanging` into Observables, you can use `ObservePropertyChanged` and `ObservePropertyChanging`.\n\n```csharp\nvar person = new Person { Name = \"foo\" };\n\nperson.ObservePropertyChanged(x => x.Name)\n      .Subscribe(x => Console.WriteLine($\"Changed:{x}\"));\n\np.Name = \"bar\";\np.Name = \"baz\";\n```\n\n`Func<T, TProperty> propertySelector` only supports simple property name lambda. This is because, in R3, `CallerArgumentExpression` is used to extract, for example from `x => x.Name` to \"Name\".\n\n### FromEvent\n\nTo convert existing events into Observables, use FromEvent. Because it requires the conversion of delegates and has a unique way of calling, please refer to the following sample.\n\n```csharp\nObservable.FromEvent<RoutedEventHandler, RoutedEventArgs>(\n    h => (sender, e) => h(e),\n    e => button.Click += e,\n    e => button.Click -= e);\n```\n\nPlatform Supports\n---\nEven without adding specific platform support, it is possible to use only the core library. However, Rx becomes more user-friendly by replacing the standard `TimeProvider` and `FrameProvider` with those optimized for each platform. For example, while the standard `TimeProvider` is thread-based, using a UI thread-based `TimeProvider` for each platform can eliminate the need for dispatch through `ObserveOn`, enhancing usability. Additionally, since message loops differ across platforms, the use of individual `FrameProvider` is essential.\n\nAlthough standard support is provided for the following platforms, by implementing `TimeProvider` and `FrameProvider`, it is possible to support any environment, including in-house game engine or other frameworks.\n\n* [WPF](#wpf)\n* [Avalonia](#avalonia)\n* [MAUI](#mau)\n* [WinForms](#winforms)\n* [WinUI3](#winui3)\n* [Unity](#unity)\n* [Godot](#godot)\n* [Stride](#stride)\n* [MonoGame](#monogame)\n* [LogicLooper](#logiclooper)\n* [Blazor](#blazor)\n\n### WPF\n\n> PM> Install-Package [R3Extensions.WPF](https://www.nuget.org/packages/R3Extensions.WPF)\n\nR3Extensions.WPF package has two providers.\n\n* WpfDispatcherTimerProvider\n* WpfRenderingFrameProvider\n\nCalling `WpfProviderInitializer.SetDefaultObservableSystem()` at startup will replace `ObservableSystem.DefaultTimeProvider` and `ObservableSystem.DefaultFrameProvider` with the aforementioned providers.\n\n```csharp\npublic partial class App : Application\n{\n    protected override void OnStartup(StartupEventArgs e)\n    {\n        // You need to set UnhandledExceptionHandler\n        WpfProviderInitializer.SetDefaultObservableSystem(ex => Trace.WriteLine($\"R3 UnhandledException:{ex}\"));\n    }\n}\n```\n\nAs a result, time based operations are replaced with `DispatcherTimer`, allowing you to reflect time based operations on the UI without having to use `ObserveOn`.\n\n`WpfRenderingFrameProvider` is a frame-based loop system synchronized with the `CompositionTarget.Rendering` event. This allows for writing code that, for example, reads and reflects changes in values that do not implement `INotifyPropertyChanged`.\n\n```csharp\npublic partial class MainWindow : Window\n{\n    IDisposable disposable;\n\n    public MainWindow()\n    {\n        InitializeComponent();\n\n        var d1 = Observable.EveryValueChanged(this, x => x.Width).Subscribe(x => WidthText.Text = x.ToString());\n        var d2 = Observable.EveryValueChanged(this, x => x.Height).Subscribe(x => HeightText.Text = x.ToString());\n\n        disposable = Disposable.Combine(d1, d2);\n    }\n\n    protected override void OnClosed(EventArgs e)\n    {\n        disposable.Dispose();\n    }\n}\n```\n\n![](https://cloud.githubusercontent.com/assets/46207/15827886/1573ff16-2c48-11e6-9876-4e4455d7eced.gif)\n\nIn addition to the above, the following `ObserveOn`/`SubscribeOn` methods have been added.\n\n* ObserveOnDispatcher\n* ObserveOnCurrentDispatcher\n* SubscribeOnDispatcher\n* SubscribeOnCurrentDispatcher\n\nViewModel binding support, see [`BindableReactiveProperty<T>`](#xaml-platformsbindablereactivepropertyt) section.\n\n### Avalonia\n\n> PM> Install-Package [R3Extensions.Avalonia](https://www.nuget.org/packages/R3Extensions.Avalonia)\n\nR3Extensions.Avalonia package has these providers.\n\n* AvaloniaDispatcherTimerProvider\n* AvaloniaDispatcherFrameProvider\n* AvaloniaRenderingFrameProvider\n\nCalling `AvaloniaProviderInitializer.SetDefaultObservableSystem()` at startup will replace `ObservableSystem.DefaultTimeProvider` and `ObservableSystem.DefaultFrameProvider` with `AvaloniaDispatcherTimerProvider` and `AvaloniaDispatcherFrameProvider`.\n\nAdditionally, calling `UseR3()` in `ApplicationBuilder` sets the default providers, making it a recommended approach.\n\n```csharp\npublic static AppBuilder BuildAvaloniaApp()\n    => AppBuilder.Configure<App>()\n        .UsePlatformDetect()\n        .WithInterFont()\n        .LogToTrace()\n        .UseR3(); // add this line\n```\n\nAs a result, time based operations are replaced with `DispatcherTimer`, allowing you to reflect time based operations on the UI without having to use `ObserveOn`.\n\nIn the case of methods without arguments, integrate the following method into `ObservableSystem.RegisterUnhandledExceptionHandler`. Please customize this as necessary.\n\n```csharp\nex => Logger.Sink?.Log(LogEventLevel.Error, \"R3\", null, \"R3 Unhandled Exception {0}\", ex);\n```\n\n`AvaloniaDispatcherFrameProvider` calculates a frame by polling with `DispatcherTimer`. By default, it updates at 60fps.\n\nUsing `AvaloniaRenderingFrameProvider` is more performant however it needs `TopLevel`.\n\n```csharp\npublic partial class MainWindow : Window\n{\n    AvaloniaRenderingFrameProvider frameProvider;\n\n    public MainWindow()\n    {\n        InitializeComponent();\n\n        // initialize RenderingFrameProvider\n        var topLevel = TopLevel.GetTopLevel(this);\n        this.frameProvider = new AvaloniaRenderingFrameProvider(topLevel!);\n    }\n\n    protected override void OnLoaded(RoutedEventArgs e)\n    {\n        // pass frameProvider\n        Observable.EveryValueChanged(this, x => x.Width, frameProvider)\n            .Subscribe(x => textBlock.Text = x.ToString());\n    }\n\n    protected override void OnClosed(EventArgs e)\n    {\n        frameProvider.Dispose();\n    }\n}\n```\n\nIn addition to the above, the following `ObserveOn`/`SubscribeOn` methods have been added.\n\n* ObserveOnDispatcher\n* ObserveOnUIThreadDispatcher\n* SubscribeOnDispatcher\n* SubscribeOnUIThreadDispatcher\n\n### MAUI\n\n> PM> Install-Package [R3Extensions.Maui](https://www.nuget.org/packages/R3Extensions.Maui)\n\nR3Extensions.Maui package has these providers.\n\n* MauiDispatcherTimerProvider\n* MauiTickerFrameProvider\n\nAnd ViewModel binding is supported, see [`BindableReactiveProperty<T>`](#xaml-platformsbindablereactivepropertyt) section.\n\nCalling `UseR3()` in `MauiAppBuilder` sets the default providers.\n\n```csharp\npublic static MauiApp CreateMauiApp()\n{\n    var builder = MauiApp.CreateBuilder();\n    builder\n        .UseMauiApp<App>()\n        .ConfigureFonts(fonts =>\n        {\n            fonts.AddFont(\"OpenSans-Regular.ttf\", \"OpenSansRegular\");\n            fonts.AddFont(\"OpenSans-Semibold.ttf\", \"OpenSansSemibold\");\n        })\n        .UseR3(); // add this line\n\n    return builder.Build();\n}\n```\n\n`UseR3()` configures the following.\n\n- Time based operations are replaced with `IDispatcher`, allowing you to reflect time based operations on the UI without having to use `ObserveOn`.\n- Frame based operations are replaced with `Ticker`.\n- `ObservableSystem.RegisterUnhandledExceptionHandler` is set to `R3MauiDefaultExceptionHandler`:\n    - ```csharp\n      public class R3MauiDefaultExceptionHandler(IServiceProvider serviceProvider) : IR3MauiExceptionHandler\n      {\n          public void HandleException(Exception ex)\n          {\n              System.Diagnostics.Trace.TraceError(\"R3 Unhandled Exception {0}\", ex);\n\n              var logger = serviceProvider.GetService<ILogger<R3MauiDefaultExceptionHandler>>();\n              logger?.LogError(ex, \"R3 Unhandled Exception\");\n          }\n      }\n      ```\nIf you want to customize the ExceptionHandler, there are two ways.\n\nOne is to pass a callback to `UseR3e\n\n```csharp\nbuilder.UseR3(ex => Console.WriteLine($\"R3 UnhandledException:{ex}\"));\n```\n\nThe second is to create an implementation of the `IR3MAuiExceptionHandler` interface and DI it.\nSince MAUI is a DI-based framework, this method will make it easier to access the various functions in the DI container.\n\n```csharp\nbuilder.Services.AddSingleton<IR3MauiExceptionHandler, YourCustomExceptionHandler>();\n```\n\n### WinForms\n\n> PM> Install-Package [R3Extensions.WinForms](https://www.nuget.org/packages/R3Extensions.WinForms)\n\nR3Extensions.WinForms package has these providers.\n\n* WinFormsFrameProvider\n* WinFormsTimerProvider\n\nCalling `WinFormsProviderInitializer.SetDefaultObservableSystem()` at startup(Program.Main) will replace `ObservableSystem.DefaultTimeProvider` and `ObservableSystem.DefaultFrameProvider` with `WinFormsFrameProvider` and `WinFormsTimerProvider`.\n\n\n```csharp\nusing R3.WinForms;\n\ninternal static class Program\n{\n    [STAThread]\n    static void Main()\n    {\n        ApplicationConfiguration.Initialize();\n\n        var form = new Form1();\n\n        // add this line\n        WinFormsProviderInitializer.SetDefaultObservableSystem(ex => Trace.WriteLine($\"R3 UnhandledException:{ex}\"), form);\n\n        Application.Run(form);\n    }\n}\n```\n\n`SetDefaultObservableSystem` takes ISynchronizeInvoke (such as Form or Control). This makes the Timer operate on the thread to which it belongs.\n\nFrameProvider is executed as one frame using the hook of MessageFilter.\n\n### WinUI3\n\n> PM> Install-Package [R3Extensions.WinUI3](https://www.nuget.org/packages/R3Extensions.WinUI3)\n\nR3Extensions.WinUI3 package has these providers.\n\n* WinUI3DispatcherTimerProvider\n* WinUI3RenderingFrameProvider\n\nCalling `WinUI3ProviderInitializer.SetDefaultObservableSystem()` at startup will replace `ObservableSystem.DefaultTimeProvider` and `ObservableSystem.DefaultFrameProvider` with the aforementioned providers.\n\n```csharp\npublic partial class App : Application\n{\n    public App()\n    {\n        this.InitializeComponent();\n\n        // Add this line.\n        // You need to set UnhandledExceptionHandler\n        WinUI3ProviderInitializer.SetDefaultObservableSystem(ex => Trace.WriteLine(ex.ToString()));\n    }\n\n    // OnLaunched...\n}\n```\n\n### Unity\n\nThe minimum Unity support for R3 is **Unity 2021.3**.\n\nThere are two installation steps required to use it in Unity.\n\n1. Install `R3` from NuGet using [NuGetForUnity](https://github.com/GlitchEnzo/NuGetForUnity)\n\n* Open Window from NuGet -> Manage NuGet Packages, Search \"R3\" and Press Install.\n![](https://github.com/Cysharp/ZLogger/assets/46207/dbad9bf7-28e3-4856-b0a8-0ff8a2a01d67)\n\n* If you encounter version conflict errors, please disable version validation in Player Settings(Edit -> Project Settings -> Player -> Scroll down and expand \"Other Settings\" than uncheck \"Assembly Version Validation\" under the \"Configuration\" section).\n\n2. Install the `R3.Unity` package by referencing the git URL\n\n```\nhttps://github.com/Cysharp/R3.git?path=src/R3.Unity/Assets/R3.Unity\n```\n\n![image](https://github.com/Cysharp/ZLogger/assets/46207/7325d266-05b4-47c9-b06a-a67a40368dd2)\n![image](https://github.com/Cysharp/ZLogger/assets/46207/29bf5636-4d6a-4e75-a3d8-3f8408bd8c51)\n\nR3 uses the *.*.* release tag, so you can specify a version like #1.0.0. For example: `https://github.com/Cysharp/R3.git?path=src/R3.Unity/Assets/R3.Unity#1.0.0`\n\nUnity's TimeProvider and FrameProvider is PlayerLoop based. Additionally, there are variations of TimeProvider that correspond to the TimeScale.\n\n```\nUnityTimeProvider.Initialization\nUnityTimeProvider.EarlyUpdate\nUnityTimeProvider.FixedUpdate\nUnityTimeProvider.PreUpdate\nUnityTimeProvider.Update\nUnityTimeProvider.PreLateUpdate\nUnityTimeProvider.PostLateUpdate\nUnityTimeProvider.TimeUpdate\n\nUnityTimeProvider.InitializationIgnoreTimeScale\nUnityTimeProvider.EarlyUpdateIgnoreTimeScale\nUnityTimeProvider.FixedUpdateIgnoreTimeScale\nUnityTimeProvider.PreUpdateIgnoreTimeScale\nUnityTimeProvider.UpdateIgnoreTimeScale\nUnityTimeProvider.PreLateUpdateIgnoreTimeScale\nUnityTimeProvider.PostLateUpdateIgnoreTimeScale\nUnityTimeProvider.TimeUpdateIgnoreTimeScale\n\nUnityTimeProvider.InitializationRealtime\nUnityTimeProvider.EarlyUpdateRealtime\nUnityTimeProvider.FixedUpdateRealtime\nUnityTimeProvider.PreUpdateRealtime\nUnityTimeProvider.UpdateRealtime\nUnityTimeProvider.PreLateUpdateRealtime\nUnityTimeProvider.PostLateUpdateRealtime\nUnityTimeProvider.TimeUpdateRealtime\n```\n\n```\nUnityFrameProvider.Initialization\nUnityFrameProvider.EarlyUpdate\nUnityFrameProvider.FixedUpdate\nUnityFrameProvider.PreUpdate\nUnityFrameProvider.Update\nUnityFrameProvider.PreLateUpdate\nUnityFrameProvider.PostLateUpdate\nUnityFrameProvider.TimeUpdate\n```\n\nYou can write it like this using these:\n\n```csharp\n// ignore-timescale based interval\nObservable.Interval(TimeSpan.FromSeconds(5), UnityTimeProvider.UpdateIgnoreTimeScale);\n\n// fixed-update loop\nObservable.EveryUpdate(UnityFrameProvider.FixedUpdate);\n\n// observe PostLateUpdate\nObservable.Return(42).ObserveOn(UnityFrameProvider.PostLateUpdate);\n```\n\nIn the case of Unity, `UnityTimeProvider.Update` and `UnityFrameProvider.Update` are automatically set at startup by default.\n\n```csharp\npublic static class UnityProviderInitializer\n{\n    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]\n    public static void SetDefaultObservableSystem()\n    {\n        SetDefaultObservableSystem(static ex => UnityEngine.Debug.LogException(ex));\n    }\n\n    public static void SetDefaultObservableSystem(Action<Exception> unhandledExceptionHandler)\n    {\n        ObservableSystem.RegisterUnhandledExceptionHandler(unhandledExceptionHandler);\n        ObservableSystem.DefaultTimeProvider = UnityTimeProvider.Update;\n        ObservableSystem.DefaultFrameProvider = UnityFrameProvider.Update;\n    }\n}\n```\n\nA method has been added to convert from UnityEvent to AsObservable. If a CancellationToken is passed, it allows the event source to call for event unsubscription by issuing OnCompleted when Cancel is invoked. For example, if you pass `MonoBehaviour.destroyCancellationToken`, it will be reliably unsubscribed in conjunction with the GameObject's lifecycle.\n\n```csharp\npublic static Observable<Unit> AsObservable(this UnityEngine.Events.UnityEvent unityEvent, CancellationToken cancellationToken = default)\npublic static Observable<T> AsObservable<T>(this UnityEngine.Events.UnityEvent<T> unityEvent, CancellationToken cancellationToken = default)\npublic static Observable<(T0 Arg0, T1 Arg1)> AsObservable<T0, T1>(this UnityEngine.Events.UnityEvent<T0, T1> unityEvent, CancellationToken cancellationToken = default)\npublic static Observable<(T0 Arg0, T1 Arg1, T2 Arg2)> AsObservable<T0, T1, T2>(this UnityEngine.Events.UnityEvent<T0, T1, T2> unityEvent, CancellationToken cancellationToken = default)\npublic static Observable<(T0 Arg0, T1 Arg1, T2 Arg2, T3 Arg3)> AsObservable<T0, T1, T2, T3>(this UnityEngine.Events.UnityEvent<T0, T1, T2, T3> unityEvent, CancellationToken cancellationToken = default)\n```\n\nAdditionally, with extension methods for uGUI, uGUI events can be easily converted to Observables. OnValueChangedAsObservable starts the subscription by first emitting the latest value at the time of subscription. Also when the associated component is destroyed, it emits an OnCompleted event to ensure the subscription is reliably cancelled.\n\n```csharp\npublic static IDisposable SubscribeToText(this Observable<string> source, Text text)\npublic static IDisposable SubscribeToText<T>(this Observable<T> source, Text text)\npublic static IDisposable SubscribeToText<T>(this Observable<T> source, Text text, Func<T, string> selector)\npublic static IDisposable SubscribeToInteractable(this Observable<bool> source, Selectable selectable)\npublic static Observable<Unit> OnClickAsObservable(this Button button)\npublic static Observable<bool> OnValueChangedAsObservable(this Toggle toggle)\npublic static Observable<float> OnValueChangedAsObservable(this Scrollbar scrollbar)\npublic static Observable<Vector2> OnValueChangedAsObservable(this ScrollRect scrollRect)\npublic static Observable<float> OnValueChangedAsObservable(this Slider slider)\npublic static Observable<string> OnEndEditAsObservable(this InputField inputField)\npublic static Observable<string> OnValueChangedAsObservable(this InputField inputField)\npublic static Observable<int> OnValueChangedAsObservable(this Dropdown dropdown)\n```\n\nIn addition to the above, the following `ObserveOn`/`SubscribeOn` methods have been added.\n\n* ObserveOnMainThread\n* SubscribeOnMainThread\n\nWhen using `AddTo(Component / GameObject)` in Unity, it attaches a special component called ObservableDestroyTrigger if gameObject is not active yet, which monitors for destruction. Unity has a characteristic where components that have never been activated do not fire OnDestroy, and the destroyCancellationToken does not get canceled. ObservableDestroyTrigger is designed to monitor for destruction and reliably issue OnDestroy regardless of the active state. It would be wise to use destroyCancellationToken effectively if needed.\n\n```csharp\n// simple pattern\nObservable.EveryUpdate().Subscribe().AddTo(this);\nObservable.EveryUpdate().Subscribe().AddTo(this);\nObservable.EveryUpdate().Subscribe().AddTo(this);\n\n// better performance\nvar d = Disposable.CreateBuilder();\nObservable.EveryUpdate().Subscribe().AddTo(ref d);\nObservable.EveryUpdate().Subscribe().AddTo(ref d);\nObservable.EveryUpdate().Subscribe().AddTo(ref d);\nd.RegisterTo(this.destroyCancellationToken); // Build and Register\n```\n\nYou open tracker window in `Window -> Observable Tracker`. It enables watch `ObservableTracker` list in editor window.\n\n![image](https://github.com/Cysharp/ZLogger/assets/46207/149abca5-6d84-44ea-8373-b0e8cd2dc46a)\n\n* Enable AutoReload(Toggle) - Reload automatically.\n* Reload - Reload view.\n* GC.Collect - Invoke GC.Collect.\n* Enable Tracking(Toggle) - Start to track subscription. Performance impact: low.\n* Enable StackTrace(Toggle) - Capture StackTrace when observable is subscribed. Performance impact: high.\n\nObservable Tracker is intended for debugging use only as enabling tracking and capturing stacktraces is useful but has a heavy performance impact. Recommended usage is to enable both tracking and stacktraces to find subscription leaks and to disable them both when done.\n\n#### `SerializableReactiveProperty<T>`\n\n`ReactiveProperty<T>` can not use on `[SerializeField]`. However you can use `SerializableReactiveProperty<T>` instead.\n\n```csharp\npublic class NewBehaviourScript : MonoBehaviour\n{\n    public SerializableReactiveProperty<int> rpInt;\n    public SerializableReactiveProperty<long> rpLong;\n    public SerializableReactiveProperty<byte> rpByte;\n    public SerializableReactiveProperty<float> rpFloat;\n    public SerializableReactiveProperty<double> rpDouble;\n    public SerializableReactiveProperty<string> rpString;\n    public SerializableReactiveProperty<bool> rpBool;\n    public SerializableReactiveProperty<Vector2> rpVector2;\n    public SerializableReactiveProperty<Vector2Int> rpVector2Int;\n    public SerializableReactiveProperty<Vector3> rpVector3;\n    public SerializableReactiveProperty<Vector3Int> rpVector3Int;\n    public SerializableReactiveProperty<Vector4> rpVector4;\n    public SerializableReactiveProperty<Color> rpColor;\n    public SerializableReactiveProperty<Rect> rpRect;\n    public SerializableReactiveProperty<Bounds> rpBounds;\n    public SerializableReactiveProperty<BoundsInt> rpBoundsInt;\n    public SerializableReactiveProperty<Quaternion> rpQuaternion;\n    public SerializableReactiveProperty<Matrix4x4> rpMatrix4x4;\n    public SerializableReactiveProperty<FruitEnum> rpEnum;\n    public SerializableReactiveProperty<FruitFlagsEnum> rpFlagsEnum;\n}\n```\n\n![image](https://github.com/Cysharp/R3/assets/46207/31be9378-846e-4635-8cc6-0b6e3954e918)\n\n#### Triggers\n\nR3 can handle [MonoBehaviour messages](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html) with R3.Triggers:\n\nThese can also be handled more easily by directly subscribing to observables returned by extension methods on Component/GameObject. These methods inject ObservableTrigger automatically.\n\n```csharp\nusing R3;\nusing R3.Triggers;\n\n// when using R3.Triggers, Component or GameObject has [MonoBehaviour Messages]AsObservable extension methods.\nthis.OnCollisionEnterAsObservable()\n    .Subscribe(x =>\n    {\n        Debug.Log(\"collision enter\");\n    });\n```\n\n### Godot\n\nGodot support is for Godot 4.x.\n\nThere are some installation steps required to use it in Godot.\n\n1. Install `R3` from NuGet.\n2. Download(or clone git submodule) the repository and move the `src/R3.Godot/addons/R3.Godot` directory to your project.\n3. Enable the `R3.Godot` plugin from the plugins menu.\n\n![image](https://github.com/Cysharp/R3/assets/46207/56bfbb3b-8e7c-4af3-b762-35e4de8a2e83)\n\nGodot support has these TimeProvider and FrameProvider.\n\n```\nGodotTimeProvider.Process\nGodotTimeProvider.PhysicsProcess\n```\n\n```\nGodotFrameProvider.Process\nGodotFrameProvider.PhysicsProcess\n```\n\nautoloaded `FrameProviderDispatcher` set `GodotTimeProvider.Process` and `GodotFrameProvider.Process` as default providers. Additionally, UnhandledException is written to `GD.PrintErr`.\n\nThis is the minimal sample to use R3.Godot.\n\n```csharp\nusing Godot;\nusing R3;\nusing System;\n\npublic partial class Node2D : Godot.Node2D\n{\n    IDisposable subscription;\n\n    public override void _Ready()\n    {\n        subscription = Observable.EveryUpdate()\n            .ThrottleLastFrame(10)\n            .Subscribe(x =>\n            {\n                GD.Print($\"Observable.EveryUpdate: {GodotFrameProvider.Process.GetFrameCount()}\");\n            });\n    }\n\n    public override void _ExitTree()\n    {\n        subscription?.Dispose();\n    }\n}\n```\n\nFor the UI event observe/subscribe extension are also available.\n\n```csharp\npublic static IDisposable SubscribeToLabel(this Observable<string> source, Label label)\npublic static IDisposable SubscribeToLabel<T>(this Observable<T> source, Label label)\npublic static IDisposable SubscribeToLabel<T>(this Observable<T> source, Label label, Func<T, string> selector)\npublic static Observable<Unit> OnPressedAsObservable(this BaseButton button, CancellationToken cancellationToken = default)\npublic static Observable<bool> OnToggledAsObservable(this BaseButton button, CancellationToken cancellationToken = default)\npublic static Observable<double> OnValueChangedAsObservable(this Godot.Range range, CancellationToken cancellationToken = default)\npublic static Observable<string> OnTextSubmittedAsObservable(this LineEdit lineEdit, CancellationToken cancellationToken = default)\npublic static Observable<string> OnTextChangedAsObservable(this LineEdit lineEdit, CancellationToken cancellationToken = default)\npublic static Observable<Unit> OnTextChangedAsObservable(this TextEdit textEdit, CancellationToken cancellationToken = default)\npublic static Observable<long> OnItemSelectedAsObservable(this OptionButton optionButton, CancellationToken cancellationToken = default)\n```\n\nYou can watch subscription status in `Debugger -> ObservableTracker` view.\n\n![image](https://github.com/Cysharp/R3/assets/46207/8b5258a5-8124-4123-a837-79c31427c1d3)\n\n### Stride\n\nR3 extensions for [Stride](https://stride3d.net) game engine.\n\n> PM> Install-Package [R3Extensions.Stride](https://www.nuget.org/packages/R3Extensions.Stride)\n\n#### Usage\n\n1. Reference R3.Stride\n2. add empty Entity by Stride editor\n3. add \"R3/StrideFrameProviderComponent\"\n4. set Stride Frame Provider Component's priority to lower than other scripts which use R3 API\n\nR3Extensions.Stride provides these providers.\n\n* StrideTimeProvider\n* StrideFrameProvider\n\nFor the UI event observe/subscribe extension are also available.\n\n```csharp\npublic static Observable<(object? sender, PropertyChangedArgs<MouseOverState> arg)> MouseOverStateChangedAsObservable(this UIElement element, CancellationToken token = default)\npublic static Observable<(object? sender, TouchEventArgs)> PreviewTouchDownAsObservable(this UIElement element, CancellationToken token = default)\npublic static Observable<(object? sender, TouchEventArgs)> PreviewTouchMoveAsObservable(this UIElement element, CancellationToken token = default)\npublic static Observable<(object? sender, TouchEventArgs)> PreviewTouchUpAsObservable(this UIElement element, CancellationToken token = default)\npublic static Observable<(object? sender, TouchEventArgs)> TouchDownAsObservable(this UIElement element, CancellationToken token = default)\npublic static Observable<(object? sender, TouchEventArgs)> TouchMoveAsObservable(this UIElement element, CancellationToken token = default)\npublic static Observable<(object? sender, TouchEventArgs)> TouchUpAsObservable(this UIElement element, CancellationToken token = default)\npublic static Observable<(object? sender, TouchEventArgs)> TouchEnterAsObservable(this UIElement element, CancellationToken token = default)\npublic static Observable<(object? sender, TouchEventArgs)> TouchLeaveAsObservable(this UIElement element, CancellationToken token = default)\npublic static Observable<(object? sender, RoutedEventArgs arg)> ClickAsObservable(this ButtonBase btn, CancellationToken token = default)\npublic static Observable<(object? sender, RoutedEventArgs arg)> ValueChangedAsObservable(this Slider slider, CancellationToken token = default)\npublic static Observable<(object? sender, RoutedEventArgs arg)> TextChangedAsObservable(this EditText editText, CancellationToken token = default)\npublic static Observable<(object? sender, RoutedEventArgs arg)> CheckedAsObservable(this ToggleButton toggleButton, CancellationToken token = default)\npublic static Observable<(object? sender, RoutedEventArgs arg)> IndeterminateAsObservable(this ToggleButton button, CancellationToken token = default)\npublic static Observable<(object? sender, RoutedEventArgs arg)> UncheckedAsObservable(this ToggleButton toggleButton, CancellationToken token = default)\npublic static Observable<(object? sender, RoutedEventArgs arg)> OutsideClickAsObservable(this ModalElement modalElement, CancellationToken token = default)\n```\n\nAnd event extensions.\n\n```csharp\npublic static Observable<(object? sender, TrackingCollectionChangedEventArgs arg)> CollectionChangedAsObservable(this ITrackingCollectionChanged hashset, CancellationToken token = default)\npublic static Observable<(object? sender, FastTrackingCollectionChangedEventArgs arg)> CollectionChangedAsObservable<T>(this FastTrackingCollection<T> collection, CancellationToken token = default)\npublic static Observable<T> AsObservable<T>(this EventKey<T> eventKey, CancellationToken token = default)\npublic static Observable<Unit> AsObservable(this EventKey eventKey, CancellationToken token = default)\n```\n\n### MonoGame\n\nR3 extensions for [MonoGame](https://monogame.net) game engine.\n\n> PM> Install-Package [R3Extensions.MonoGame](https://www.nuget.org/packages/R3Extensions.MonoGame)\n\nSet up as follows:\n\n1. Reference R3.MonoGame\n2. Add an instance of `ObservableSystemComponent` to your Game class.\n\n```csharp\npublic class Game1 : Game\n{\n    public Game1()\n    {\n        var observableSystemComponent = new ObservableSystemComponent(this);\n        Components.Add(observableSystemComponent);\n    }\n}\n```\n\nObservableSystemComponent configure the following:\n- Setup TimeProvider and FrameProvider.\n  - Time based operations are replaced with `Game.Update(GameTime)`.\n  - Frame based operations are replaced with `Game.Update(GameTime)`.\n- Set UnhandledExceptionHandler. By default, the unhandled exception handler simply flows to System.Diagnostics.Trace.\n  - If you want to change this, do the following:\n    - ```csharp\n      new ObservableSystemComponent(this, ex => Console.WriteLine($\"R3 UnhandledException: {ex}\");\n      ```\n\nR3Extensions.MonoGame provides these providers.\n\n* MonoGameTimeProvider\n* MonoGameFrameProvider\n\nAnd provides these custom operators.\n\n```csharp\n// Observe the current GameTime value.\npublic static Observable<GameTime> GameTime(this Observable<Unit> source)\n\n// observe the current GameTime and the value of the source observable.\npublic static Observable<(GameTime GameTime, T Item)> GameTime<T>(this Observable<T> source)\n```\n\n### LogicLooper\n\nR3 extensions for [LogicLooper](https://github.com/Cysharp/LogicLooper/)\n\n> PM> Install-Package [R3Extensions.LogicLooper](https://www.nuget.org/packages/R3Extensions.LogicLooper)\n\nThat supports two special providers.\n\n* LogicLooperFrameProvider\n* LogicLooperTimerProvider\n\n### Blazor\n\nR3 extensions for Blazor.\n\n> PM> Install-Package [R3Extensions.Blazor](https://www.nuget.org/packages/R3Extensions.Blazor)\n\nIf project target is WebAssembly Blazor, import `R3Extensions.BlazorWebAssembly` instead.\n\n> PM> Install-Package [R3Extensions.BlazorWebAssembly](https://www.nuget.org/packages/R3Extensions.BlazorWebAssembly)\n\n```csharp\n// Add this line before Build()\n// for WebAssembly use AddBlazorWebAssemblyR3() instead.\nbuilder.Services.AddBlazorR3();\n\nvar app = builder.Build();\n```\n\nWhen you call `AddBlazorR3/AddBlazorWebAssemblyR3` on IServiceCollection, a TimeProvider corresponding to the request scope is implicitly used and automatically marshaled to the current request. This eliminates the need for InvokeAsync when calling time-related methods within Blazor.\n\n```csharp\npublic partial class Counter : IDisposable\n{\n    int currentCount = 0;\n    IDisposable? subscription;\n\n    protected override void OnInitialized()\n    {\n        subscription = Observable.Interval(TimeSpan.FromSeconds(1))\n            .Subscribe(_ =>\n            {\n                // no needs InvokeAsync\n                currentCount++;\n                StateHasChanged();\n            });\n    }\n\n    public void Dispose()\n    {\n        subscription?.Dispose();\n    }\n}\n```\n\nIn this case, since all default TimeProviders are tied to the request, you must explicitly pass `TimeProvider.System` for executions that are not related to a request.\n\nThere is also a way to utilize R3 in Blazor without using `AddBlazorR3/AddBlazorWebAssemblyR3`. One method is to use `ObserveOnCurrentSynchronizationContext`.\n\n```csharp\nsubscription = Observable.Interval(TimeSpan.FromSeconds(1)) // default TimeProvider is TimeProvider.System\n    .ObserveOnCurrentSynchronizationContext() // uses Blazor RendererSynchronizationContext\n    .Subscribe(_ =>\n    {\n        currentCount++;\n        StateHasChanged();\n    });\n```\n\nAnother method is to inject the TimeProvider. By manually setting up a `SynchronizationContextTimeProvider` tied to the request scope, you can use a custom TimeProvider without changing the default TimeProvider. Also, in this case, it is easy to substitute a `FakeTimeProvider` for unit testing.\n\n```csharp\n// use AddScoped instead of AddBlazorR3\nbuilder.Services.AddScoped<TimeProvider, SynchronizationContextTimeProvider>();\n\nvar app = builder.Build();\n```\n\n```csharp\npublic partial class Counter : IDisposable\n{\n    int currentCount = 0;\n    IDisposable? subscription;\n\n    // Inject scoped TimeProvider manually(in bUnit testing, inject FakeTimeProvider)\n    [Inject]\n    public required TimeProvider TimeProvider { get; init; }\n\n    protected override void OnInitialized()\n    {\n        subscription = Observable.Interval(TimeSpan.FromSeconds(1), TimeProvider)\n            .Subscribe(_ =>\n            {\n                currentCount++;\n                StateHasChanged();\n            });\n    }\n\n    public void Dispose()\n    {\n        subscription?.Dispose();\n    }\n}\n```\n\nOperator Reference\n---\nThe standard operators in ReactiveX follow the behavior described in the [Reactive X Operator documentation](https://reactivex.io/documentation/operators.html).\n\nMethods that accept a Scheduler will take a `TimeProvider`. Additionally, methods that receive a `TimeProvider` have an added method called `***Frame` that accepts a `FrameProvider`.\n\nFor default time based operations that do not take a provider, `ObservableSystem.DefaultTimeProvider` is used, and for frame based operations without provider, `ObservableSystem.DefaultFrameProvider` is used.\n\n### Factory\n\nFactory methods are defined as static methods in the static class `Observable`.\n\n| Name(Parameter) | ReturnType | \n| --- | --- | \n| **Amb**(params `Observable<T>[]` sources) | `Observable<T>` | \n| **Amb**(`IEnumerable<Observable<T>>` sources) | `Observable<T>` | \n| **CombineLatest**(params `Observable<T>[]` sources) | `Observable<T[]>` | \n| **CombineLatest**(`IEnumerable<Observable<T>>` sources) | `Observable<T[]>` | \n| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Func<T1, T2, TResult>` resultSelector) | `Observable<TResult>` | \n| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Func<T1, T2, T3, TResult>` resultSelector) | `Observable<TResult>` | \n| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Func<T1, T2, T3, T4, TResult>` resultSelector) | `Observable<TResult>` | \n| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Func<T1, T2, T3, T4, T5, TResult>` resultSelector) | `Observable<TResult>` | \n| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Func<T1, T2, T3, T4, T5, T6, TResult>` resultSelector) | `Observable<TResult>` | \n| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Func<T1, T2, T3, T4, T5, T6, T7, TResult>` resultSelector) | `Observable<TResult>` | \n| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>` resultSelector) | `Observable<TResult>` | \n| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>` resultSelector) | `Observable<TResult>` | \n| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>` resultSelector) | `Observable<TResult>` | \n| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>` resultSelector) | `Observable<TResult>` | \n| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Observable<T12>` source12, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>` resultSelector) | `Observable<TResult>` | \n| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Observable<T12>` source12, `Observable<T13>` source13, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>` resultSelector) | `Observable<TResult>` | \n| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Observable<T12>` source12, `Observable<T13>` source13, `Observable<T14>` source14, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>` resultSelector) | `Observable<TResult>` | \n| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Observable<T12>` source12, `Observable<T13>` source13, `Observable<T14>` source14, `Observable<T15>` source15, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>` resultSelector) | `Observable<TResult>` | \n| **Concat**(params `Observable<T>[]` sources) | `Observable<T>` | \n| **Concat**(`IEnumerable<Observable<T>>` sources) | `Observable<T>` | \n| **Concat**(this `Observable<Observable<T>>` sources) | `Observable<T>` | \n| **Create**(`Func<Observer<T>, IDisposable>` subscribe, `Boolean` rawObserver = false) | `Observable<T>` | \n| **Create**(`TState` state, `Func<Observer<T>, TState, IDisposable>` subscribe, `Boolean` rawObserver = false) | `Observable<T>` | \n| **Create**(`Func<Observer<T>, CancellationToken, ValueTask>` subscribe, `Boolean` rawObserver = false) | `Observable<T>` | \n| **Create**(`TState` state, `Func<Observer<T>, TState, CancellationToken, ValueTask>` subscribe, `Boolean` rawObserver = false) | `Observable<T>` | \n| **CreateFrom**(`Func<CancellationToken, IAsyncEnumerable<T>>` factory) | `Observable<T>` | \n| **CreateFrom**(`TState` state, `Func<CancellationToken, TState, IAsyncEnumerable<T>>` factory) | `Observable<T>` | \n| **Defer**(`Func<Observable<T>>` observableFactory, `Boolean` rawObserver = false) | `Observable<T>` | \n| **Empty**() | `Observable<T>` | \n| **Empty**(`TimeProvider` timeProvider) | `Observable<T>` | \n| **Empty**(`TimeSpan` dueTime, `TimeProvider` timeProvider) | `Observable<T>` | \n| **EveryUpdate**() | `Observable<Unit>` | \n| **EveryUpdate**(`CancellationToken` cancellationToken) | `Observable<Unit>` | \n| **EveryUpdate**(`FrameProvider` frameProvider) | `Observable<Unit>` | \n| **EveryUpdate**(`FrameProvider` frameProvider, `CancellationToken` cancellationToken) | `Observable<Unit>` | \n| **EveryValueChanged**(`TSource` source, `Func<TSource, TProperty>` propertySelector, `CancellationToken` cancellationToken = default) | `Observable<TProperty>` | \n| **EveryValueChanged**(`TSource` source, `Func<TSource, TProperty>` propertySelector, `FrameProvider` frameProvider, `CancellationToken` cancellationToken = default) | `Observable<TProperty>` | \n| **EveryValueChanged**(`TSource` source, `Func<TSource, TProperty>` propertySelector, `EqualityComparer<TProperty>` equalityComparer, `CancellationToken` cancellationToken = default) | `Observable<TProperty>` | \n| **EveryValueChanged**(`TSource` source, `Func<TSource, TProperty>` propertySelector, `FrameProvider` frameProvider, `EqualityComparer<TProperty>` equalityComparer, `CancellationToken` cancellationToken = default) | `Observable<TProperty>` | \n| **FromAsync**(`Func<CancellationToken, ValueTask>` asyncFactory, `Boolean` configureAwait = true) | `Observable<Unit>` | \n| **FromAsync**(`Func<CancellationToken, ValueTask<T>>` asyncFactory, `Boolean` configureAwait = true) | `Observable<T>` | \n| **FromEvent**(`Action<Action>` addHandler, `Action<Action>` removeHandler, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | \n| **FromEvent**(`Action<Action<T>>` addHandler, `Action<Action<T>>` removeHandler, `CancellationToken` cancellationToken = default) | `Observable<T>` | \n| **FromEvent**(`Func<Action, TDelegate>` conversion, `Action<TDelegate>` addHandler, `Action<TDelegate>` removeHandler, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | \n| **FromEvent**(`Func<Action<T>, TDelegate>` conversion, `Action<TDelegate>` addHandler, `Action<TDelegate>` removeHandler, `CancellationToken` cancellationToken = default) | `Observable<T>` | \n| **FromEventHandler**(`Action<EventHandler>` addHandler, `Action<EventHandler>` removeHandler, `CancellationToken` cancellationToken = default) | `Observable<ValueTuple<Object, EventArgs>>` | \n| **FromEventHandler**(`Action<EventHandler<TEventArgs>>` addHandler, `Action<EventHandler<TEventArgs>>` removeHandler, `CancellationToken` cancellationToken = default) | `Observable<ValueTuple<Object, TEventArgs>>` | \n| **Interval**(`TimeSpan` period, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | \n| **Interval**(`TimeSpan` period, `TimeProvider` timeProvider, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | \n| **IntervalFrame**(`Int32` periodFrame, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | \n| **IntervalFrame**(`Int32` periodFrame, `FrameProvider` frameProvider, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | \n| **Merge**(params `Observable<T>[]` sources) | `Observable<T>` | \n| **Merge**(this `IEnumerable<Observable<T>>` sources) | `Observable<T>` | \n| **Merge**(this `Observable<Observable<T>>` sources) | `Observable<T>` | \n| **Never**() | `Observable<T>` | \n| **NextFrame**(`CancellationToken` cancellationToken = default) | `Observable<Unit>` | \n| **NextFrame**(`FrameProvider` frameProvider, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | \n| **ObservePropertyChanged**(this `T` value, `Func<T, TProperty>` propertySelector, `Boolean` pushCurrentValueOnSubscribe = true, `CancellationToken` cancellationToken = default, `String` expr = default) | `Observable<TProperty>` | \n| **ObservePropertyChanged**(this `T` value, `Func<T, TProperty1>` propertySelector1, `Func<TProperty1, TProperty2>` propertySelector2, `Boolean` pushCurrentValueOnSubscribe = true, `CancellationToken` cancellationToken = default, `String` propertySelector1Expr = default, `String` propertySelector2Expr = default) | `Observable<TProperty2>` | \n| **ObservePropertyChanged**(this `T` value, `Func<T, TProperty1>` propertySelector1, `Func<TProperty1, TProperty2>` propertySelector2, `Func<TProperty2, TProperty3>` propertySelector3, `Boolean` pushCurrentValueOnSubscribe = true, `CancellationToken` cancellationToken = default, `String` propertySelector1Expr = default, `String` propertySelector2Expr = default, `String` propertySelector3Expr = default) | `Observable<TProperty3>` | \n| **ObservePropertyChanging**(this `T` value, `Func<T, TProperty>` propertySelector, `Boolean` pushCurrentValueOnSubscribe = true, `CancellationToken` cancellationToken = default, `String` expr = default) | `Observable<TProperty>` | \n| **ObservePropertyChanging**(this `T` value, `Func<T, TProperty1>` propertySelector1, `Func<TProperty1, TProperty2>` propertySelector2, `Boolean` pushCurrentValueOnSubscribe = true, `CancellationToken` cancellationToken = default, `String` propertySelector1Expr = default, `String` propertySelector2Expr = default) | `Observable<TProperty2>` | \n| **ObservePropertyChanging**(this `T` value, `Func<T, TProperty1>` propertySelector1, `Func<TProperty1, TProperty2>` propertySelector2, `Func<TProperty2, TProperty3>` propertySelector3, `Boolean` pushCurrentValueOnSubscribe = true, `CancellationToken` cancellationToken = default, `String` propertySelector1Expr = default, `String` propertySelector2Expr = default, `String` propertySelector3Expr = default) | `Observable<TProperty3>` | \n| **Range**(`Int32` start, `Int32` count) | `Observable<Int32>` | \n| **Range**(`Int32` start, `Int32` count, `CancellationToken` cancellationToken) | `Observable<Int32>` | \n| **Repeat**(`T` value, `Int32` count) | `Observable<T>` | \n| **Repeat**(`T` value, `Int32` count, `CancellationToken` cancellationToken) | `Observable<T>` | \n| **Return**(`T` value) | `Observable<T>` | \n| **Return**(`T` value, `TimeProvider` timeProvider, `CancellationToken` cancellationToken = default) | `Observable<T>` | \n| **Return**(`T` value, `TimeSpan` dueTime, `TimeProvider` timeProvider, `CancellationToken` cancellationToken = default) | `Observable<T>` | \n| **Return**(`Unit` value) | `Observable<Unit>` | \n| **Return**(`Boolean` value) | `Observable<Boolean>` | \n| **Return**(`Int32` value) | `Observable<Int32>` | \n| **ReturnFrame**(`T` value, `CancellationToken` cancellationToken = default) | `Observable<T>` | \n| **ReturnFrame**(`T` value, `FrameProvider` frameProvider, `CancellationToken` cancellationToken = default) | `Observable<T>` | \n| **ReturnFrame**(`T` value, `Int32` dueTimeFrame, `CancellationToken` cancellationToken = default) | `Observable<T>` | \n| **ReturnFrame**(`T` value, `Int32` dueTimeFrame, `FrameProvider` frameProvider, `CancellationToken` cancellationToken = default) | `Observable<T>` | \n| **ReturnOnCompleted**(`Result` result) | `Observable<T>` | \n| **ReturnOnCompleted**(`Result` result, `TimeProvider` timeProvider) | `Observable<T>` | \n| **ReturnOnCompleted**(`Result` result, `TimeSpan` dueTime, `TimeProvider` timeProvider) | `Observable<T>` | \n| **ReturnUnit**() | `Observable<Unit>` | \n| **Throw**(`Exception` exception) | `Observable<T>` | \n| **Throw**(`Exception` exception, `TimeProvider` timeProvider) | `Observable<T>` | \n| **Throw**(`Exception` exception, `TimeSpan` dueTime, `TimeProvider` timeProvider) | `Observable<T>` | \n| **Timer**(`TimeSpan` dueTime, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | \n| **Timer**(`DateTimeOffset` dueTime, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | \n| **Timer**(`TimeSpan` dueTime, `TimeSpan` period, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | \n| **Timer**(`DateTimeOffset` dueTime, `TimeSpan` period, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | \n| **Timer**(`TimeSpan` dueTime, `TimeProvider` timeProvider, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | \n| **Timer**(`DateTimeOffset` dueTime, `TimeProvider` timeProvider, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | \n| **Timer**(`TimeSpan` dueTime, `TimeSpan` period, `TimeProvider` timeProvider, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | \n| **Timer**(`DateTimeOffset` dueTime, `TimeSpan` period, `TimeProvider` timeProvider, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | \n| **TimerFrame**(`Int32` dueTimeFrame, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | \n| **TimerFrame**(`Int32` dueTimeFrame, `Int32` periodFrame, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | \n| **TimerFrame**(`Int32` dueTimeFrame, `FrameProvider` frameProvider, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | \n| **TimerFrame**(`Int32` dueTimeFrame, `Int32` periodFrame, `FrameProvider` frameProvider, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | \n| **ToObservable**(this `Task` task, `Boolean` configureAwait = true) | `Observable<Unit>` | \n| **ToObservable**(this `Task<T>` task, `Boolean` configureAwait = true) | `Observable<T>` | \n| **ToObservable**(this `ValueTask` task, `Boolean` configureAwait = true) | `Observable<Unit>` | \n| **ToObservable**(this `ValueTask<T>` task, `Boolean` configureAwait = true) | `Observable<T>` | \n| **ToObservable**(this `IEnumerable<T>` source, `CancellationToken` cancellationToken = default) | `Observable<T>` | \n| **ToObservable**(this `IAsyncEnumerable<T>` source) | `Observable<T>` | \n| **ToObservable**(this `IObservable<T>` source) | `Observable<T>` | \n| **Yield**(`CancellationToken` cancellationToken = default) | `Observable<Unit>` | \n| **Yield**(`TimeProvider` timeProvider, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | \n| **YieldFrame**(`CancellationToken` cancellationToken = default) | `Observable<Unit>` | \n| **YieldFrame**(`FrameProvider` frameProvider, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | \n| **Zip**(params `Observable<T>[]` sources) | `Observable<T[]>` | \n| **Zip**(`IEnumerable<Observable<T>>` sources) | `Observable<T[]>` | \n| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Func<T1, T2, TResult>` resultSelector) | `Observable<TResult>` | \n| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Func<T1, T2, T3, TResult>` resultSelector) | `Observable<TResult>` | \n| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Func<T1, T2, T3, T4, TResult>` resultSelector) | `Observable<TResult>` | \n| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Func<T1, T2, T3, T4, T5, TResult>` resultSelector) | `Observable<TResult>` | \n| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Func<T1, T2, T3, T4, T5, T6, TResult>` resultSelector) | `Observable<TResult>` | \n| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Func<T1, T2, T3, T4, T5, T6, T7, TResult>` resultSelector) | `Observable<TResult>` | \n| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>` resultSelector) | `Observable<TResult>` | \n| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>` resultSelector) | `Observable<TResult>` | \n| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>` resultSelector) | `Observable<TResult>` | \n| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>` resultSelector) | `Observable<TResult>` | \n| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Observable<T12>` source12, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>` resultSelector) | `Observable<TResult>` | \n| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Observable<T12>` source12, `Observable<T13>` source13, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>` resultSelector) | `Observable<TResult>` | \n| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Observable<T12>` source12, `Observable<T13>` source13, `Observable<T14>` source14, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>` resultSelector) | `Observable<TResult>` | \n| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Observable<T12>` source12, `Observable<T13>` source13, `Observable<T14>` source14, `Observable<T15>` source15, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>` resultSelector) | `Observable<TResult>` | \n| **ZipLatest**(params `Observable<T>[]` sources) | `Observable<T[]>` | \n| **ZipLatest**(`IEnumerable<Observable<T>>` sources) | `Observable<T[]>` | \n| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Func<T1, T2, TResult>` resultSelector) | `Observable<TResult>` | \n| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Func<T1, T2, T3, TResult>` resultSelector) | `Observable<TResult>` | \n| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Func<T1, T2, T3, T4, TResult>` resultSelector) | `Observable<TResult>` | \n| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Func<T1, T2, T3, T4, T5, TResult>` resultSelector) | `Observable<TResult>` | \n| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Func<T1, T2, T3, T4, T5, T6, TResult>` resultSelector) | `Observable<TResult>` | \n| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Func<T1, T2, T3, T4, T5, T6, T7, TResult>` resultSelector) | `Observable<TResult>` | \n| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>` resultSelector) | `Observable<TResult>` | \n| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>` resultSelector) | `Observable<TResult>` | \n| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>` resultSelector) | `Observable<TResult>` | \n| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>` resultSelector) | `Observable<TResult>` | \n| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Observable<T12>` source12, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>` resultSelector) | `Observable<TResult>` | \n| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Observable<T12>` source12, `Observable<T13>` source13, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>` resultSelector) | `Observable<TResult>` | \n| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Observable<T12>` source12, `Observable<T13>` source13, `Observable<T14>` source14, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>` resultSelector) | `Observable<TResult>` | \n| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Observable<T12>` source12, `Observable<T13>` source13, `Observable<T14>` source14, `Observable<T15>` source15, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>` resultSelector) | `Observable<TResult>` | \n\nMethods that accept a `CancellationToken` will emit `OnCompleted` when a Cancel is issued. This allows you to unsubscribe all subscriptions from the event source.\n\n`Range`, `Repeat`, `Return/Empty/Throw` (which do not take a `TimeProvider`) issue values immediately. This means that even if disposed of midway, the emission of values cannot be stopped. For example,\n\n```csharp\nObservable.Range(0, int.MaxValue)\n    .Do(onNext: x => Console.WriteLine($\"Do:{x}\"))\n    .Take(10)\n    .Subscribe(x => Console.WriteLine($\"Subscribe:{x}\"));\n```\n\nIn this case, since the disposal of `Take(10)` is conveyed after the emission of `Range`, the stream does not stop. In dotnet/reactive, this could be avoided by specifying `CurrentThreadScheduler`, but it was not adopted in R3 due to a significant performance decrease.\n\nIf you want to avoid such cases, you can stop the Range by conveying a cancellation command through a `CancellationToken`.\n\n```csharp\nvar cts = new CancellationTokenSource();\n\nObservable.Range(0, int.MaxValue, cts.Token)\n    .Do(onNext: x => Console.WriteLine($\"Do:{x}\"))\n    .Take(10)\n    .DoCancelOnCompleted(cts)\n    .Subscribe(x => Console.WriteLine($\"Subscribe:{x}\"));\n```\n\nAmong our custom frame-based methods, `EveryUpdate` emits values every frame. `Yield` and `NextFrame` are similar, but `Yield` emits on the first frame loop after subscribing, while `NextFrame` delays emission to the next frame if it's in the same frame as the `FrameProvider.GetFrameCount()` value obtained at the time of subscription. `EveryValueChanged` compares values every frame and notifies when there is a change.\n\n### Operator\n\nOperator methods are defined as extension methods to `Observable<T>` in the static class `ObservableExtensions`.\n\n| Name(Parameter) | ReturnType | \n| --- | --- | \n| **AggregateAsync**(this `Observable<T>` source, `Func<T, T, T>` func, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **AggregateAsync**(this `Observable<T>` source, `TResult` seed, `Func<TResult, T, TResult>` func, `CancellationToken` cancellationToken = default) | `Task<TResult>` | \n| **AggregateAsync**(this `Observable<T>` source, `TAccumulate` seed, `Func<TAccumulate, T, TAccumulate>` func, `Func<TAccumulate, TResult>` resultSelector, `CancellationToken` cancellationToken = default) | `Task<TResult>` | \n| **AggregateByAsync**(this `Observable<TSource>` source, `Func<TSource, TKey>` keySelector, `TAccumulate` seed, `Func<TAccumulate, TSource, TAccumulate>` func, `IEqualityComparer<TKey>` keyComparer = default, `CancellationToken` cancellationToken = default) | `Task<IEnumerable<KeyValuePair<TKey, TAccumulate>>>` | \n| **AggregateByAsync**(this `Observable<TSource>` source, `Func<TSource, TKey>` keySelector, `Func<TKey, TAccumulate>` seedSelector, `Func<TAccumulate, TSource, TAccumulate>` func, `IEqualityComparer<TKey>` keyComparer = default, `CancellationToken` cancellationToken = default) | `Task<IEnumerable<KeyValuePair<TKey, TAccumulate>>>` | \n| **AllAsync**(this `Observable<T>` source, `Func<T, Boolean>` predicate, `CancellationToken` cancellationToken = default) | `Task<Boolean>` | \n| **Amb**(this `Observable<T>` source, `Observable<T>` second) | `Observable<T>` | \n| **AnyAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<Boolean>` | \n| **AnyAsync**(this `Observable<T>` source, `Func<T, Boolean>` predicate, `CancellationToken` cancellationToken = default) | `Task<Boolean>` | \n| **Append**(this `Observable<T>` source, `T` value) | `Observable<T>` | \n| **Append**(this `Observable<T>` source, `IEnumerable<T>` values) | `Observable<T>` | \n| **Append**(this `Observable<T>` source, `Func<T>` valueFactory) | `Observable<T>` | \n| **Append**(this `Observable<T>` source, `TState` state, `Func<TState, T>` valueFactory) | `Observable<T>` | \n| **AsObservable**(this `Observable<T>` source) | `Observable<T>` | \n| **AsSystemObservable**(this `Observable<T>` source) | `IObservable<T>` | \n| **AsUnitObservable**(this `Observable<T>` source) | `Observable<Unit>` | \n| **AverageAsync**(this `Observable<Int32>` source, `CancellationToken` cancellationToken = default) | `Task<Double>` | \n| **AverageAsync**(this `Observable<T>` source, `Func<T, Int32>` selector, `CancellationToken` cancellationToken = default) | `Task<Double>` | \n| **AverageAsync**(this `Observable<Int64>` source, `CancellationToken` cancellationToken = default) | `Task<Double>` | \n| **AverageAsync**(this `Observable<T>` source, `Func<T, Int64>` selector, `CancellationToken` cancellationToken = default) | `Task<Double>` | \n| **AverageAsync**(this `Observable<Single>` source, `CancellationToken` cancellationToken = default) | `Task<Double>` | \n| **AverageAsync**(this `Observable<T>` source, `Func<T, Single>` selector, `CancellationToken` cancellationToken = default) | `Task<Double>` | \n| **AverageAsync**(this `Observable<Double>` source, `CancellationToken` cancellationToken = default) | `Task<Double>` | \n| **AverageAsync**(this `Observable<T>` source, `Func<T, Double>` selector, `CancellationToken` cancellationToken = default) | `Task<Double>` | \n| **AverageAsync**(this `Observable<Decimal>` source, `CancellationToken` cancellationToken = default) | `Task<Double>` | \n| **AverageAsync**(this `Observable<T>` source, `Func<T, Decimal>` selector, `CancellationToken` cancellationToken = default) | `Task<Double>` | \n| **AverageAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<Double>` | \n| **AverageAsync**(this `Observable<TSource>` source, `Func<TSource, TResult>` selector, `CancellationToken` cancellationToken = default) | `Task<Double>` | \n| **Cast**(this `Observable<T>` source) | `Observable<TResult>` | \n| **Catch**(this `Observable<T>` source, `Observable<T>` second) | `Observable<T>` | \n| **Catch**(this `Observable<T>` source, `Func<TException, Observable<T>>` errorHandler) | `Observable<T>` | \n| **Chunk**(this `Observable<T>` source, `Int32` count) | `Observable<T[]>` | \n| **Chunk**(this `Observable<T>` source, `Int32` count, `Int32` skip) | `Observable<T[]>` | \n| **Chunk**(this `Observable<T>` source, `TimeSpan` timeSpan) | `Observable<T[]>` | \n| **Chunk**(this `Observable<T>` source, `TimeSpan` timeSpan, `TimeProvider` timeProvider) | `Observable<T[]>` | \n| **Chunk**(this `Observable<T>` source, `TimeSpan` timeSpan, `Int32` count) | `Observable<T[]>` | \n| **Chunk**(this `Observable<T>` source, `TimeSpan` timeSpan, `Int32` count, `TimeProvider` timeProvider) | `Observable<T[]>` | \n| **Chunk**(this `Observable<TSource>` source, `Observable<TWindowBoundary>` windowBoundaries) | `Observable<TSource[]>` | \n| **Chunk**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` asyncWindow, `Boolean` configureAwait = true) | `Observable<T[]>` | \n| **ChunkFrame**(this `Observable<T>` source) | `Observable<T[]>` | \n| **ChunkFrame**(this `Observable<T>` source, `Int32` frameCount) | `Observable<T[]>` | \n| **ChunkFrame**(this `Observable<T>` source, `Int32` frameCount, `FrameProvider` frameProvider) | `Observable<T[]>` | \n| **ChunkFrame**(this `Observable<T>` source, `Int32` frameCount, `Int32` count) | `Observable<T[]>` | \n| **ChunkFrame**(this `Observable<T>` source, `Int32` frameCount, `Int32` count, `FrameProvider` frameProvider) | `Observable<T[]>` | \n| **Concat**(this `Observable<T>` source, `Observable<T>` second) | `Observable<T>` | \n| **ContainsAsync**(this `Observable<T>` source, `T` value, `CancellationToken` cancellationToken = default) | `Task<Boolean>` | \n| **ContainsAsync**(this `Observable<T>` source, `T` value, `IEqualityComparer<T>` equalityComparer, `CancellationToken` cancellationToken = default) | `Task<Boolean>` | \n| **CountAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<Int32>` | \n| **CountAsync**(this `Observable<T>` source, `Func<T, Boolean>` predicate, `CancellationToken` cancellationToken = default) | `Task<Int32>` | \n| **Debounce**(this `Observable<T>` source, `TimeSpan` timeSpan) | `Observable<T>` | \n| **Debounce**(this `Observable<T>` source, `TimeSpan` timeSpan, `TimeProvider` timeProvider) | `Observable<T>` | \n| **Debounce**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` throttleDurationSelector, `Boolean` configureAwait = true) | `Observable<T>` | \n| **DebounceFrame**(this `Observable<T>` source, `Int32` frameCount) | `Observable<T>` | \n| **DebounceFrame**(this `Observable<T>` source, `Int32` frameCount, `FrameProvider` frameProvider) | `Observable<T>` | \n| **DefaultIfEmpty**(this `Observable<T>` source) | `Observable<T>` | \n| **DefaultIfEmpty**(this `Observable<T>` source, `T` defaultValue) | `Observable<T>` | \n| **Delay**(this `Observable<T>` source, `TimeSpan` dueTime) | `Observable<T>` | \n| **Delay**(this `Observable<T>` source, `TimeSpan` dueTime, `TimeProvider` timeProvider) | `Observable<T>` | \n| **DelayFrame**(this `Observable<T>` source, `Int32` frameCount) | `Observable<T>` | \n| **DelayFrame**(this `Observable<T>` source, `Int32` frameCount, `FrameProvider` frameProvider) | `Observable<T>` | \n| **DelaySubscription**(this `Observable<T>` source, `TimeSpan` dueTime) | `Observable<T>` | \n| **DelaySubscription**(this `Observable<T>` source, `TimeSpan` dueTime, `TimeProvider` timeProvider) | `Observable<T>` | \n| **DelaySubscriptionFrame**(this `Observable<T>` source, `Int32` frameCount) | `Observable<T>` | \n| **DelaySubscriptionFrame**(this `Observable<T>` source, `Int32` frameCount, `FrameProvider` frameProvider) | `Observable<T>` | \n| **Dematerialize**(this `Observable<Notification<T>>` source) | `Observable<T>` | \n| **Distinct**(this `Observable<T>` source) | `Observable<T>` | \n| **Distinct**(this `Observable<T>` source, `IEqualityComparer<T>` comparer) | `Observable<T>` | \n| **DistinctBy**(this `Observable<TSource>` source, `Func<TSource, TKey>` keySelector) | `Observable<TSource>` | \n| **DistinctBy**(this `Observable<TSource>` source, `Func<TSource, TKey>` keySelector, `IEqualityComparer<TKey>` comparer) | `Observable<TSource>` | \n| **DistinctUntilChanged**(this `Observable<T>` source) | `Observable<T>` | \n| **DistinctUntilChanged**(this `Observable<T>` source, `IEqualityComparer<T>` comparer) | `Observable<T>` | \n| **DistinctUntilChangedBy**(this `Observable<T>` source, `Func<T, TKey>` keySelector) | `Observable<T>` | \n| **DistinctUntilChangedBy**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `IEqualityComparer<TKey>` comparer) | `Observable<T>` | \n| **Do**(this `Observable<T>` source, `Action<T>` onNext = default, `Action<Exception>` onErrorResume = default, `Action<Result>` onCompleted = default, `Action` onDispose = default, `Action` onSubscribe = default) | `Observable<T>` | \n| **Do**(this `Observable<T>` source, `TState` state, `Action<T, TState>` onNext = default, `Action<Exception, TState>` onErrorResume = default, `Action<Result, TState>` onCompleted = default, `Action<TState>` onDispose = default, `Action<TState>` onSubscribe = default) | `Observable<T>` | \n| **DoCancelOnCompleted**(this `Observable<T>` source, `CancellationTokenSource` cancellationTokenSource) | `Observable<T>` | \n| **ElementAtAsync**(this `Observable<T>` source, `Int32` index, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **ElementAtAsync**(this `Observable<T>` source, `Index` index, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **ElementAtOrDefaultAsync**(this `Observable<T>` source, `Int32` index, `T` defaultValue = default, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **ElementAtOrDefaultAsync**(this `Observable<T>` source, `Index` index, `T` defaultValue = default, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **FirstAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **FirstAsync**(this `Observable<T>` source, `Func<T, Boolean>` predicate, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **FirstOrDefaultAsync**(this `Observable<T>` source, `T` defaultValue = default, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **FirstOrDefaultAsync**(this `Observable<T>` source, `Func<T, Boolean>` predicate, `T` defaultValue = default, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **ForEachAsync**(this `Observable<T>` source, `Action<T>` action, `CancellationToken` cancellationToken = default) | `Task` | \n| **ForEachAsync**(this `Observable<T>` source, `Action<T, Int32>` action, `CancellationToken` cancellationToken = default) | `Task` | \n| **FrameCount**(this `Observable<T>` source) | `Observable<ValueTuple<Int64, T>>` | \n| **FrameCount**(this `Observable<T>` source, `FrameProvider` frameProvider) | `Observable<ValueTuple<Int64, T>>` | \n| **FrameInterval**(this `Observable<T>` source) | `Observable<ValueTuple<Int64, T>>` | \n| **FrameInterval**(this `Observable<T>` source, `FrameProvider` frameProvider) | `Observable<ValueTuple<Int64, T>>` | \n| **IgnoreElements**(this `Observable<T>` source) | `Observable<T>` | \n| **IgnoreElements**(this `Observable<T>` source, `Action<T>` doOnNext) | `Observable<T>` | \n| **IgnoreOnErrorResume**(this `Observable<T>` source) | `Observable<T>` | \n| **IgnoreOnErrorResume**(this `Observable<T>` source, `Action<Exception>` doOnErrorResume) | `Observable<T>` | \n| **Index**(this `Observable<Unit>` source) | `Observable<Int32>` | \n| **Index**(this `Observable<T>` source) | `Observable<ValueTuple<Int32, T>>` | \n| **IsEmptyAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<Boolean>` | \n| **LastAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **LastAsync**(this `Observable<T>` source, `Func<T, Boolean>` predicate, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **LastOrDefaultAsync**(this `Observable<T>` source, `T` defaultValue = default, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **LastOrDefaultAsync**(this `Observable<T>` source, `Func<T, Boolean>` predicate, `T` defaultValue = default, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **LongCountAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<Int64>` | \n| **LongCountAsync**(this `Observable<T>` source, `Func<T, Boolean>` predicate, `CancellationToken` cancellationToken = default) | `Task<Int64>` | \n| **Materialize**(this `Observable<T>` source) | `Observable<Notification<T>>` | \n| **MaxAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **MaxAsync**(this `Observable<T>` source, `IComparer<T>` comparer, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **MaxAsync**(this `Observable<TSource>` source, `Func<TSource, TResult>` selector, `CancellationToken` cancellationToken = default) | `Task<TResult>` | \n| **MaxAsync**(this `Observable<TSource>` source, `Func<TSource, TResult>` selector, `IComparer<TResult>` comparer, `CancellationToken` cancellationToken = default) | `Task<TResult>` | \n| **MaxByAsync**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **MaxByAsync**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `IComparer<TKey>` comparer, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **Merge**(this `Observable<T>` source, `Observable<T>` second) | `Observable<T>` | \n| **MinAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **MinAsync**(this `Observable<T>` source, `IComparer<T>` comparer, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **MinAsync**(this `Observable<TSource>` source, `Func<TSource, TResult>` selector, `CancellationToken` cancellationToken = default) | `Task<TResult>` | \n| **MinAsync**(this `Observable<TSource>` source, `Func<TSource, TResult>` selector, `IComparer<TResult>` comparer, `CancellationToken` cancellationToken = default) | `Task<TResult>` | \n| **MinByAsync**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **MinByAsync**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `IComparer<TKey>` comparer, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **MinMaxAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<ValueTuple<T, T>>` | \n| **MinMaxAsync**(this `Observable<T>` source, `IComparer<T>` comparer, `CancellationToken` cancellationToken = default) | `Task<ValueTuple<T, T>>` | \n| **MinMaxAsync**(this `Observable<TSource>` source, `Func<TSource, TResult>` selector, `CancellationToken` cancellationToken = default) | `Task<ValueTuple<TResult, TResult>>` | \n| **MinMaxAsync**(this `Observable<TSource>` source, `Func<TSource, TResult>` selector, `IComparer<TResult>` comparer, `CancellationToken` cancellationToken = default) | `Task<ValueTuple<TResult, TResult>>` | \n| **Multicast**(this `Observable<T>` source, `ISubject<T>` subject) | `ConnectableObservable<T>` | \n| **ObserveOn**(this `Observable<T>` source, `SynchronizationContext` synchronizationContext) | `Observable<T>` | \n| **ObserveOn**(this `Observable<T>` source, `TimeProvider` timeProvider) | `Observable<T>` | \n| **ObserveOn**(this `Observable<T>` source, `FrameProvider` frameProvider) | `Observable<T>` | \n| **ObserveOnCurrentSynchronizationContext**(this `Observable<T>` source) | `Observable<T>` | \n| **ObserveOnThreadPool**(this `Observable<T>` source) | `Observable<T>` | \n| **OfType**(this `Observable<T>` source) | `Observable<TResult>` | \n| **OnErrorResumeAsFailure**(this `Observable<T>` source) | `Observable<T>` | \n| **Pairwise**(this `Observable<T>` source) | `Observable<ValueTuple<T, T>>` | \n| **Prepend**(this `Observable<T>` source, `T` value) | `Observable<T>` | \n| **Prepend**(this `Observable<T>` source, `IEnumerable<T>` values) | `Observable<T>` | \n| **Prepend**(this `Observable<T>` source, `Func<T>` valueFactory) | `Observable<T>` | \n| **Prepend**(this `Observable<T>` source, `TState` state, `Func<TState, T>` valueFactory) | `Observable<T>` | \n| **Publish**(this `Observable<T>` source) | `ConnectableObservable<T>` | \n| **Publish**(this `Observable<T>` source, `T` initialValue) | `ConnectableObservable<T>` | \n| **RefCount**(this `ConnectableObservable<T>` source) | `Observable<T>` | \n| **Replay**(this `Observable<T>` source) | `ConnectableObservable<T>` | \n| **Replay**(this `Observable<T>` source, `Int32` bufferSize) | `ConnectableObservable<T>` | \n| **Replay**(this `Observable<T>` source, `TimeSpan` window) | `ConnectableObservable<T>` | \n| **Replay**(this `Observable<T>` source, `TimeSpan` window, `TimeProvider` timeProvider) | `ConnectableObservable<T>` | \n| **Replay**(this `Observable<T>` source, `Int32` bufferSize, `TimeSpan` window) | `ConnectableObservable<T>` | \n| **Replay**(this `Observable<T>` source, `Int32` bufferSize, `TimeSpan` window, `TimeProvider` timeProvider) | `ConnectableObservable<T>` | \n| **ReplayFrame**(this `Observable<T>` source, `Int32` window) | `ConnectableObservable<T>` | \n| **ReplayFrame**(this `Observable<T>` source, `Int32` window, `FrameProvider` frameProvider) | `ConnectableObservable<T>` | \n| **ReplayFrame**(this `Observable<T>` source, `Int32` bufferSize, `Int32` window) | `ConnectableObservable<T>` | \n| **ReplayFrame**(this `Observable<T>` source, `Int32` bufferSize, `Int32` window, `FrameProvider` frameProvider) | `ConnectableObservable<T>` | \n| **Scan**(this `Observable<TSource>` source, `Func<TSource, TSource, TSource>` accumulator) | `Observable<TSource>` | \n| **Scan**(this `Observable<TSource>` source, `TAccumulate` seed, `Func<TAccumulate, TSource, TAccumulate>` accumulator) | `Observable<TAccumulate>` | \n| **Select**(this `Observable<T>` source, `Func<T, TResult>` selector) | `Observable<TResult>` | \n| **Select**(this `Observable<T>` source, `Func<T, Int32, TResult>` selector) | `Observable<TResult>` | \n| **Select**(this `Observable<T>` source, `TState` state, `Func<T, TState, TResult>` selector) | `Observable<TResult>` | \n| **Select**(this `Observable<T>` source, `TState` state, `Func<T, Int32, TState, TResult>` selector) | `Observable<TResult>` | \n| **SelectAwait**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask<TResult>>` selector, `AwaitOperation` awaitOperation = AwaitOperation.Sequential, `Boolean` configureAwait = true, `Boolean` cancelOnCompleted = false, `Int32` maxConcurrent = -1) | `Observable<TResult>` | \n| **SelectMany**(this `Observable<TSource>` source, `Func<TSource, Observable<TResult>>` selector) | `Observable<TResult>` | \n| **SelectMany**(this `Observable<TSource>` source, `Func<TSource, Observable<TCollection>>` collectionSelector, `Func<TSource, TCollection, TResult>` resultSelector) | `Observable<TResult>` | \n| **SelectMany**(this `Observable<TSource>` source, `Func<TSource, Int32, Observable<TResult>>` selector) | `Observable<TResult>` | \n| **SelectMany**(this `Observable<TSource>` source, `Func<TSource, Int32, Observable<TCollection>>` collectionSelector, `Func<TSource, Int32, TCollection, Int32, TResult>` resultSelector) | `Observable<TResult>` | \n| **SequenceEqualAsync**(this `Observable<T>` source, `Observable<T>` second, `CancellationToken` cancellationToken = default) | `Task<Boolean>` | \n| **SequenceEqualAsync**(this `Observable<T>` source, `Observable<T>` second, `IEqualityComparer<T>` equalityComparer, `CancellationToken` cancellationToken = default) | `Task<Boolean>` | \n| **Share**(this `Observable<T>` source) | `Observable<T>` | \n| **SingleAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **SingleAsync**(this `Observable<T>` source, `Func<T, Boolean>` predicate, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **SingleOrDefaultAsync**(this `Observable<T>` source, `T` defaultValue = default, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **SingleOrDefaultAsync**(this `Observable<T>` source, `Func<T, Boolean>` predicate, `T` defaultValue = default, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **Skip**(this `Observable<T>` source, `Int32` count) | `Observable<T>` | \n| **Skip**(this `Observable<T>` source, `TimeSpan` duration) | `Observable<T>` | \n| **Skip**(this `Observable<T>` source, `TimeSpan` duration, `TimeProvider` timeProvider) | `Observable<T>` | \n| **SkipFrame**(this `Observable<T>` source, `Int32` frameCount) | `Observable<T>` | \n| **SkipFrame**(this `Observable<T>` source, `Int32` frameCount, `FrameProvider` frameProvider) | `Observable<T>` | \n| **SkipLast**(this `Observable<T>` source, `Int32` count) | `Observable<T>` | \n| **SkipLast**(this `Observable<T>` source, `TimeSpan` duration) | `Observable<T>` | \n| **SkipLast**(this `Observable<T>` source, `TimeSpan` duration, `TimeProvider` timeProvider) | `Observable<T>` | \n| **SkipLastFrame**(this `Observable<T>` source, `Int32` frameCount) | `Observable<T>` | \n| **SkipLastFrame**(this `Observable<T>` source, `Int32` frameCount, `FrameProvider` frameProvider) | `Observable<T>` | \n| **SkipUntil**(this `Observable<T>` source, `Observable<TOther>` other) | `Observable<T>` | \n| **SkipUntil**(this `Observable<T>` source, `CancellationToken` cancellationToken) | `Observable<T>` | \n| **SkipUntil**(this `Observable<T>` source, `Task` task, `Boolean` configureAwait = true) | `Observable<T>` | \n| **SkipUntil**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` asyncFunc, `Boolean` configureAwait = true) | `Observable<T>` | \n| **SkipWhile**(this `Observable<T>` source, `Func<T, Boolean>` predicate) | `Observable<T>` | \n| **SkipWhile**(this `Observable<T>` source, `Func<T, Int32, Boolean>` predicate) | `Observable<T>` | \n| **SubscribeAwait**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` onNextAsync, `AwaitOperation` awaitOperation = AwaitOperation.Sequential, `Boolean` configureAwait = true, `Boolean` cancelOnCompleted = false, `Int32` maxConcurrent = -1) | `IDisposable` | \n| **SubscribeAwait**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` onNextAsync, `Action<Result>` onCompleted, `AwaitOperation` awaitOperation = AwaitOperation.Sequential, `Boolean` configureAwait = true, `Boolean` cancelOnCompleted = false, `Int32` maxConcurrent = -1) | `IDisposable` | \n| **SubscribeAwait**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` onNextAsync, `Action<Exception>` onErrorResume, `Action<Result>` onCompleted, `AwaitOperation` awaitOperation = AwaitOperation.Sequential, `Boolean` configureAwait = true, `Boolean` cancelOnCompleted = false, `Int32` maxConcurrent = -1) | `IDisposable` | \n| **SubscribeOn**(this `Observable<T>` source, `SynchronizationContext` synchronizationContext) | `Observable<T>` | \n| **SubscribeOn**(this `Observable<T>` source, `TimeProvider` timeProvider) | `Observable<T>` | \n| **SubscribeOn**(this `Observable<T>` source, `FrameProvider` frameProvider) | `Observable<T>` | \n| **SubscribeOnCurrentSynchronizationContext**(this `Observable<T>` source) | `Observable<T>` | \n| **SubscribeOnSynchronize**(this `Observable<T>` source, `Object` gate, `Boolean` rawObserver = false) | `Observable<T>` | \n| **SubscribeOnThreadPool**(this `Observable<T>` source) | `Observable<T>` | \n| **SumAsync**(this `Observable<Int32>` source, `CancellationToken` cancellationToken = default) | `Task<Int32>` | \n| **SumAsync**(this `Observable<TSource>` source, `Func<TSource, Int32>` selector, `CancellationToken` cancellationToken = default) | `Task<Int32>` | \n| **SumAsync**(this `Observable<Int64>` source, `CancellationToken` cancellationToken = default) | `Task<Int64>` | \n| **SumAsync**(this `Observable<TSource>` source, `Func<TSource, Int64>` selector, `CancellationToken` cancellationToken = default) | `Task<Int64>` | \n| **SumAsync**(this `Observable<Single>` source, `CancellationToken` cancellationToken = default) | `Task<Single>` | \n| **SumAsync**(this `Observable<TSource>` source, `Func<TSource, Single>` selector, `CancellationToken` cancellationToken = default) | `Task<Single>` | \n| **SumAsync**(this `Observable<Double>` source, `CancellationToken` cancellationToken = default) | `Task<Double>` | \n| **SumAsync**(this `Observable<TSource>` source, `Func<TSource, Double>` selector, `CancellationToken` cancellationToken = default) | `Task<Double>` | \n| **SumAsync**(this `Observable<Decimal>` source, `CancellationToken` cancellationToken = default) | `Task<Decimal>` | \n| **SumAsync**(this `Observable<TSource>` source, `Func<TSource, Decimal>` selector, `CancellationToken` cancellationToken = default) | `Task<Decimal>` | \n| **SumAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<T>` | \n| **SumAsync**(this `Observable<TSource>` source, `Func<TSource, TResult>` selector, `CancellationToken` cancellationToken = default) | `Task<TResult>` | \n| **Switch**(this `Observable<Observable<T>>` sources) | `Observable<T>` | \n| **Synchronize**(this `Observable<T>` source) | `Observable<T>` | \n| **Synchronize**(this `Observable<T>` source, `Object` gate) | `Observable<T>` | \n| **Take**(this `Observable<T>` source, `Int32` count) | `Observable<T>` | \n| **Take**(this `Observable<T>` source, `TimeSpan` duration) | `Observable<T>` | \n| **Take**(this `Observable<T>` source, `TimeSpan` duration, `TimeProvider` timeProvider) | `Observable<T>` | \n| **TakeFrame**(this `Observable<T>` source, `Int32` frameCount) | `Observable<T>` | \n| **TakeFrame**(this `Observable<T>` source, `Int32` frameCount, `FrameProvider` frameProvider) | `Observable<T>` | \n| **TakeLast**(this `Observable<T>` source, `Int32` count) | `Observable<T>` | \n| **TakeLast**(this `Observable<T>` source, `TimeSpan` duration) | `Observable<T>` | \n| **TakeLast**(this `Observable<T>` source, `TimeSpan` duration, `TimeProvider` timeProvider) | `Observable<T>` | \n| **TakeLastFrame**(this `Observable<T>` source, `Int32` frameCount) | `Observable<T>` | \n| **TakeLastFrame**(this `Observable<T>` source, `Int32` frameCount, `FrameProvider` frameProvider) | `Observable<T>` | \n| **TakeUntil**(this `Observable<T>` source, `Observable<TOther>` other) | `Observable<T>` | \n| **TakeUntil**(this `Observable<T>` source, `CancellationToken` cancellationToken) | `Observable<T>` | \n| **TakeUntil**(this `Observable<T>` source, `Task` task, `Boolean` configureAwait = true) | `Observable<T>` | \n| **TakeUntil**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` asyncFunc, `Boolean` configureAwait = true) | `Observable<T>` | \n| **TakeUntil**(this `Observable<T>` source, `Func<T, Boolean>` predicate) | `Observable<T>` | \n| **TakeUntil**(this `Observable<T>` source, `Func<T, Int32, Boolean>` predicate) | `Observable<T>` | \n| **TakeWhile**(this `Observable<T>` source, `Func<T, Boolean>` predicate) | `Observable<T>` | \n| **TakeWhile**(this `Observable<T>` source, `Func<T, Int32, Boolean>` predicate) | `Observable<T>` | \n| **ThrottleFirst**(this `Observable<T>` source, `TimeSpan` timeSpan) | `Observable<T>` | \n| **ThrottleFirst**(this `Observable<T>` source, `TimeSpan` timeSpan, `TimeProvider` timeProvider) | `Observable<T>` | \n| **ThrottleFirst**(this `Observable<T>` source, `Observable<TSample>` sampler) | `Observable<T>` | \n| **ThrottleFirst**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` sampler, `Boolean` configureAwait = true) | `Observable<T>` | \n| **ThrottleFirstFrame**(this `Observable<T>` source, `Int32` frameCount) | `Observable<T>` | \n| **ThrottleFirstFrame**(this `Observable<T>` source, `Int32` frameCount, `FrameProvider` frameProvider) | `Observable<T>` | \n| **ThrottleFirstLast**(this `Observable<T>` source, `TimeSpan` timeSpan) | `Observable<T>` | \n| **ThrottleFirstLast**(this `Observable<T>` source, `TimeSpan` timeSpan, `TimeProvider` timeProvider) | `Observable<T>` | \n| **ThrottleFirstLast**(this `Observable<T>` source, `Observable<TSample>` sampler) | `Observable<T>` | \n| **ThrottleFirstLast**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` sampler, `Boolean` configureAwait = true) | `Observable<T>` | \n| **ThrottleFirstLastFrame**(this `Observable<T>` source, `Int32` frameCount) | `Observable<T>` | \n| **ThrottleFirstLastFrame**(this `Observable<T>` source, `Int32` frameCount, `FrameProvider` frameProvider) | `Observable<T>` | \n| **ThrottleLast**(this `Observable<T>` source, `TimeSpan` timeSpan) | `Observable<T>` | \n| **ThrottleLast**(this `Observable<T>` source, `TimeSpan` timeSpan, `TimeProvider` timeProvider) | `Observable<T>` | \n| **ThrottleLast**(this `Observable<T>` source, `Observable<TSample>` sampler) | `Observable<T>` | \n| **ThrottleLast**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` sampler, `Boolean` configureAwait = true) | `Observable<T>` | \n| **ThrottleLastFrame**(this `Observable<T>` source, `Int32` frameCount) | `Observable<T>` | \n| **ThrottleLastFrame**(this `Observable<T>` source, `Int32` frameCount, `FrameProvider` frameProvider) | `Observable<T>` | \n| **TimeInterval**(this `Observable<T>` source) | `Observable<ValueTuple<TimeSpan, T>>` | \n| **TimeInterval**(this `Observable<T>` source, `TimeProvider` timeProvider) | `Observable<ValueTuple<TimeSpan, T>>` | \n| **Timeout**(this `Observable<T>` source, `TimeSpan` dueTime) | `Observable<T>` | \n| **Timeout**(this `Observable<T>` source, `TimeSpan` dueTime, `TimeProvider` timeProvider) | `Observable<T>` | \n| **TimeoutFrame**(this `Observable<T>` source, `Int32` frameCount) | `Observable<T>` | \n| **TimeoutFrame**(this `Observable<T>` source, `Int32` frameCount, `FrameProvider` frameProvider) | `Observable<T>` | \n| **Timestamp**(this `Observable<T>` source) | `Observable<ValueTuple<Int64, T>>` | \n| **Timestamp**(this `Observable<T>` source, `TimeProvider` timeProvider) | `Observable<ValueTuple<Int64, T>>` | \n| **ToArrayAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<T[]>` | \n| **ToAsyncEnumerable**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `IAsyncEnumerable<T>` | \n| **ToDictionaryAsync**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `CancellationToken` cancellationToken = default) | `Task<Dictionary<TKey, T>>` | \n| **ToDictionaryAsync**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `IEqualityComparer<TKey>` keyComparer, `CancellationToken` cancellationToken = default) | `Task<Dictionary<TKey, T>>` | \n| **ToDictionaryAsync**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `Func<T, TElement>` elementSelector, `CancellationToken` cancellationToken = default) | `Task<Dictionary<TKey, TElement>>` | \n| **ToDictionaryAsync**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `Func<T, TElement>` elementSelector, `IEqualityComparer<TKey>` keyComparer, `CancellationToken` cancellationToken = default) | `Task<Dictionary<TKey, TElement>>` | \n| **ToHashSetAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<HashSet<T>>` | \n| **ToHashSetAsync**(this `Observable<T>` source, `IEqualityComparer<T>` comparer, `CancellationToken` cancellationToken = default) | `Task<HashSet<T>>` | \n| **ToListAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<List<T>>` | \n| **ToLiveList**(this `Observable<T>` source) | `LiveList<T>` | \n| **ToLiveList**(this `Observable<T>` source, `Int32` bufferSize) | `LiveList<T>` | \n| **ToLookupAsync**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `CancellationToken` cancellationToken = default) | `Task<ILookup<TKey, T>>` | \n| **ToLookupAsync**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `IEqualityComparer<TKey>` keyComparer, `CancellationToken` cancellationToken = default) | `Task<ILookup<TKey, T>>` | \n| **ToLookupAsync**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `Func<T, TElement>` elementSelector, `CancellationToken` cancellationToken = default) | `Task<ILookup<TKey, TElement>>` | \n| **ToLookupAsync**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `Func<T, TElement>` elementSelector, `IEqualityComparer<TKey>` keyComparer, `CancellationToken` cancellationToken = default) | `Task<ILookup<TKey, TElement>>` | \n| **Trampoline**(this `Observable<T>` source) | `Observable<T>` | \n| **WaitAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task` | \n| **Where**(this `Observable<T>` source, `Func<T, Boolean>` predicate) | `Observable<T>` | \n| **Where**(this `Observable<T>` source, `Func<T, Int32, Boolean>` predicate) | `Observable<T>` | \n| **Where**(this `Observable<T>` source, `TState` state, `Func<T, TState, Boolean>` predicate) | `Observable<T>` | \n| **Where**(this `Observable<T>` source, `TState` state, `Func<T, Int32, TState, Boolean>` predicate) | `Observable<T>` | \n| **WhereAwait**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask<Boolean>>` predicate, `AwaitOperation` awaitOperation = AwaitOperation.Sequential, `Boolean` configureAwait = true, `Boolean` cancelOnCompleted = false, `Int32` maxConcurrent = -1) | `Observable<T>` | \n| **WhereNotNull**(this `Observable<TResult>` source) | `Observable<TResult>` | \n| **WithLatestFrom**(this `Observable<TFirst>` first, `Observable<TSecond>` second, `Func<TFirst, TSecond, TResult>` resultSelector) | `Observable<TResult>` | \n\nIn dotnet/reactive, methods that return a single `IObservable<T>` (such as `First`) are all provided only as `***Async`, returning `Task<T>`. Additionally, to align with the naming of Enumerable, `Buffer` has been changed to `Chunk`.\n\n`Throttle` has been changed to `Debounce`, and `Sample` has been changed to `ThrottleLast`. Originally in dotnet/reactive, there were only `Throttle` and `Sample`. But `Sample` needs both first and last, and many Rx libraries defined it as `ThrottleFirst`, the behavior of `ThrottleFirst` is similar to `Sample` (which is `ThrottleLast`), whereas `Throttle` has a completely different behavior. Therefore, `Throttle` was changed to the more commonly used `Debounce`, and `Sample` was changed to `ThrottleLast` for symmetry with `ThrottleFirst`. Additionally, I am opposed to keeping `Sample` as an alias for `ThrottleLast`. As a result of such methods being maintained, other libraries often receive questions like \"What is the difference between `ThrottleLast` and `Sample`?\"\n\nClass/Method name changes from dotnet/reactive and neuecc/UniRx\n---\n* `Buffer` -> `Chunk`\n* `BatchFrame` -> `ChunkFrame`\n* `Throttle` -> `Debounce`\n* `ThrottleFrame` -> `DebounceFrame`\n* `Sample` -> `ThrottleLast`\n* `SampleFrame` -> `ThrottleLastFrame`\n* `StartWith` -> `Prepend`\n* `ObserveEveryValueChanged(this T value)` -> `Observable.EveryValueChanged(T value)`\n* `Distinct(selector)` -> `DistinctBy`\n* `DistinctUntilChanged(selector)` -> `DistinctUntilChangedBy`\n* `Finally` -> `Do(onDisposed:)`\n* `Do***` -> `Do(on***:)`\n* `AsyncSubject<T>` -> `TaskCompletionSource<T>`\n* `StableCompositeDisposable` -> `Disposable.Combine`\n* `IScheduler` -> `TimeProvider`\n* Return single value methods -> `***Async` (or `Take(1)`, `TakeLast(1)`)\n* `ToTask()`, `ToUniTask()` -> `LastAsync()` or `FirstAsync()`\n* `IReadOnlyReactiveProperty.Value` -> `ReadOnlyReactiveProperty.CurrentValue`\n* `ReactiveProperty.SkipLatestValueOnSubscribe()` → `.Skip(1)`\n* `MainThreadDispatcher.OnApplicationQuitAsObservable` → `Application.exitCancellationToken`\n* `ReactiveCollection` / `ReactiveDictionary` -> [ObservableCollections.R3](https://github.com/Cysharp/ObservableCollections)\n* `ObjectPool` in UniRx -> use [UniTask](https://github.com/Cysharp/UniTask) and make yourself\n* MessageBroker in UniRx -> [MessagePipe](https://github.com/Cysharp/MessagePipe)\n* Logger in UniRx -> [ZLogger](https://github.com/Cysharp/ZLogger/)\n\nSimilar to `IObservable<T>`, if you want to stop the stream when an `OnErrorResume` occurs, you connect `OnErrorResumeAsFailure` in the method chain.\n\nLicense\n---\nThis library is under the MIT License."
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "opensource.snk",
          "type": "blob",
          "size": 0.58203125,
          "content": null
        },
        {
          "name": "sandbox",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}