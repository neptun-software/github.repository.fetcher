{
  "metadata": {
    "timestamp": 1736710757224,
    "page": 201,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "nxrighthere/UnrealCLR",
      "stars": 3172,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.025390625,
          "content": "*.h linguist-language=C++\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.26171875,
          "content": ".DS_Store\nInstall/bin\nInstall/obj\nSource/Managed/Framework/bin\nSource/Managed/Framework/obj\nSource/Managed/Runtime/bin\nSource/Managed/Runtime/obj\nSource/Managed/Tests/bin\nSource/Managed/Tests/obj\nSource/Native/Binaries\nSource/Native/Intermediate\nSource/Native/Managed\n"
        },
        {
          "name": "API",
          "type": "tree",
          "content": null
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.2744140625,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to making participation in our project and\nour community a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, sex characteristics, gender identity and expression,\nlevel of experience, education, socio-economic status, nationality, personal\nappearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or\n advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic\n address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces\nwhen an individual is representing the project or its community. Examples of\nrepresenting a project or community include using an official project e-mail\naddress, posting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event. Representation of a project may be\nfurther defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by contacting the project team at nxrighthere@gmail.com. All\ncomplaints will be reviewed and investigated and will result in a response that\nis deemed necessary and appropriate to the circumstances. The project team is\nobligated to maintain confidentiality with regard to the reporter of an incident.\nFurther details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,\navailable at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see\nhttps://www.contributor-covenant.org/faq\n"
        },
        {
          "name": "Content",
          "type": "tree",
          "content": null
        },
        {
          "name": "Install",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0712890625,
          "content": "MIT License\n\nCopyright (c) 2021 Stanislav Denisov (nxrighthere@gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "MANUAL.md",
          "type": "blob",
          "size": 13.39453125,
          "content": "- [Getting started](#getting-started)\r\n  * [Development](#development)\r\n  * [Project](#project)\r\n    + [Entry point](#entry-point)\r\n    + [Blueprint functions](#blueprint-functions)\r\n  * [Packaging](#packaging)\r\n- [Engine](#engine)\r\n  * [World events](#world-events)\r\n  * [Code structure](#code-structure)\r\n  * [Blueprints](#blueprints)\r\n  * [Data passing](#data-passing)\r\n- [Tools](#tools)\r\n\r\nGetting started\r\n--------\r\n### Development\r\nUnrealCLR doesn't depend on how the development environment is organized. Any IDE such as [Visual Studio](https://visualstudio.microsoft.com), [Visual Code](https://code.visualstudio.com), or [Rider](https://www.jetbrains.com/rider/), can be used to manage a project. The programmer has full freedom to set up the building pipeline in any desirable way just as for a regular .NET library.\r\n\r\n### Project\r\nAfter [building and installing](https://github.com/nxrighthere/UnrealCLR#building) the plugin, use IDE or [CLI tool](https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-new) to create a [.NET class library](https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-new#classlib) project which targets `net6.0` in any preferable location. Don't store source code in `%Project%/Managed` folder of the engine's project, it's used exclusively for loading and packaging user assemblies by the plugin.\r\n\r\nAdd a reference to `UnrealEngine.Framework.dll` assembly located in `Source/Managed/Framework/bin/Release` folder.\r\n\r\nAssuming you put your code in `%Project%/MyDotNetCode`, your project file should look similar to this:\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n  <PropertyGroup>\r\n    <TargetFramework>net6.0</TargetFramework>\r\n    <AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>\r\n    <OutputPath>../Managed/Build</OutputPath>\r\n  </PropertyGroup>\r\n\r\n  <ItemGroup>\r\n    <Reference Include=\"UnrealEngine.Framework\">\r\n      <HintPath>%UnrealCLR%/Source/Managed/Framework/bin/Release/UnrealEngine.Framework.dll</HintPath>\r\n    </Reference>\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nCreate a new or open a source code file in the .NET project and replace its content with the following code:\r\n\r\n#### Entry point\r\n\r\n<details>\r\n<summary>C#</summary>\r\n\r\n```csharp\r\nusing System;\r\nusing System.Drawing;\r\nusing UnrealEngine.Framework;\r\n\r\nnamespace Game {\r\n\tpublic class Main { // Indicates the main entry point for automatic loading by the plugin\r\n\t\tpublic static void OnWorldBegin() => Debug.AddOnScreenMessage(-1, 10.0f, Color.DeepPink, \"Hello, Unreal Engine!\");\r\n\r\n\t\tpublic static void OnWorldPostBegin() => Debug.AddOnScreenMessage(-1, 10.0f, Color.DeepPink, \"How's it going?\");\r\n\r\n\t\tpublic static void OnWorldEnd() => Debug.AddOnScreenMessage(-1, 10.0f, Color.DeepPink, \"See you soon, Unreal Engine!\");\r\n\r\n\t\tpublic static void OnWorldPrePhysicsTick(float deltaTime) => Debug.AddOnScreenMessage(1, 10.0f, Color.DeepPink, \"On pre physics tick invoked!\");\r\n\r\n\t\tpublic static void OnWorldDuringPhysicsTick(float deltaTime) => Debug.AddOnScreenMessage(2, 10.0f, Color.DeepPink, \"On during physics tick invoked!\");\r\n\r\n\t\tpublic static void OnWorldPostPhysicsTick(float deltaTime) => Debug.AddOnScreenMessage(3, 10.0f, Color.DeepPink, \"On post physics tick invoked!\");\r\n\r\n\t\tpublic static void OnWorldPostUpdateTick(float deltaTime) => Debug.AddOnScreenMessage(4, 10.0f, Color.DeepPink, \"On post update tick invoked!\");\r\n\t}\r\n}\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>F#</summary>\r\n\r\n```fsharp\r\nnamespace Game\r\n\r\nopen System\r\nopen System.Drawing\r\nopen UnrealEngine.Framework\r\n\r\nmodule Main = // Indicates the main entry point for automatic loading by the plugin\r\n    let OnWorldBegin() = Debug.AddOnScreenMessage(-1, 10.0f, Color.DeepPink, \"Hello, Unreal Engine!\")\r\n\r\n    let OnWorldPostBegin() = Debug.AddOnScreenMessage(-1, 10.0f, Color.DeepPink, \"How's it going?\")\r\n\r\n    let OnWorldEnd() = Debug.AddOnScreenMessage(-1, 10.0f, Color.DeepPink, \"See you soon, Unreal Engine!\")\r\n\r\n    let OnWorldPrePhysicsTick(deltaTime:float32) = Debug.AddOnScreenMessage(1, 10.0f, Color.DeepPink, \"On pre physics tick invoked!\")\r\n\r\n    let OnWorldDuringPhysicsTick(deltaTime:float32) = Debug.AddOnScreenMessage(2, 10.0f, Color.DeepPink, \"On during physics tick invoked!\")\r\n\r\n    let OnWorldPostPhysicsTick(deltaTime:float32) = Debug.AddOnScreenMessage(3, 10.0f, Color.DeepPink, \"On post physics tick invoked!\")\r\n\r\n    let OnWorldPostUpdateTick(deltaTime:float32) = Debug.AddOnScreenMessage(4, 10.0f, Color.DeepPink, \"On post update tick invoked!\")\r\n```\r\n</details>\r\n\r\nAll functions of the main entry point are optional, and it's not necessary to implement them for every [tick group](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Actors/Ticking/index.html).\r\n\r\n[Publish](https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-publish) a .NET assembly to `%Project%/Managed` folder of the engine's project, and make sure that no other assemblies of other .NET projects are stored there.\r\n\r\nAssemblies that no longer referenced and unused in the project will persist in `%Project%/Managed` folder. Consider maintaining this folder through IDE or automation scripts.\r\n\r\nEnter the [play mode](https://docs.unrealengine.com/en-US/Basics/HowTo/PIE/index.html) to execute managed code. Stop the play mode to unload assemblies from memory for further recompilation.\r\n\r\n#### Blueprint functions\r\n\r\n<details>\r\n<summary>C#</summary>\r\n\r\n```csharp\r\nusing System;\r\nusing System.Drawing;\r\nusing UnrealEngine.Framework;\r\n\r\nnamespace Game {\r\n\tpublic class System { // Custom class for loading functions from blueprints\r\n\t\tpublic static void Function() => Debug.AddOnScreenMessage(-1, 10.0f, Color.DeepPink, \"Blueprint function invoked!\");\r\n\t}\r\n}\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>F#</summary>\r\n\r\n```fsharp\r\nnamespace Game\r\n\r\nopen System\r\nopen System.Drawing\r\nopen UnrealEngine.Framework\r\n\r\nmodule System = // Custom module for loading functions from blueprints\r\n    let Function() = Debug.AddOnScreenMessage(-1, 10.0f, Color.DeepPink, \"Blueprint function invoked!\")\r\n```\r\n</details>\r\n\r\nTo run a blueprint function, create a new or open an existing [level](https://docs.unrealengine.com/en-US/Engine/QuickStart/index.html#3.createanewlevel) of the engine. Open level blueprint by navigating to `Blueprints -> Open Level Blueprint` and create a basic execution flow by right-clicking on the graph and selecting nodes from the .NET category:\r\n\r\n<p align=\"left\">\r\n\t<img src=\"https://github.com/Rageware/Images/raw/master/UnrealCLR/level-graph.png\" alt=\"graph\">\r\n</p>\r\n\r\nCompile the blueprint and enter the play mode.\r\n\r\n### Packaging\r\nThe plugin is transparently integrated into the [packaging](https://docs.unrealengine.com/en-US/Engine/Basics/Projects/Packaging/index.html) pipeline of the engine and ready for standalone distribution.\r\n\r\nEngine\r\n--------\r\n### World events\r\nThe framework provides world events that are executed by the engine in a predetermined order to drive logic and simulation. Event functions are automatically loaded by the plugin from `Main` class for further execution.\r\n\r\n`OnWorldBegin()` Called after the world is initialized before the level script.\r\n\r\n`OnWorldPostBegin()` Called after the level script when default actors are spawned.\r\n\r\n`OnWorldEnd()` Called before deinitialization of the world after the level script.\r\n\r\n`OnWorldPrePhysicsTick(float deltaTime)` Called at the beginning of the frame.\r\n\r\n`OnWorldDuringPhysicsTick(float deltaTime)` Called when physics simulation has begun.\r\n\r\n`OnWorldPostPhysicsTick(float deltaTime)` Called when physics simulation is complete.\r\n\r\n`OnWorldPostUpdateTick(float deltaTime)` Called after cameras are updated.\r\n\r\n### Code structure\r\nThe plugin allows organizing the code structure of the project in any preferable way. Any paradigms or patterns can be used to drive logic and simulation without any intermediate management between user code and the engine.\r\n\r\n**Object-Oriented Design**\r\n\r\n```csharp\r\nusing System;\r\nusing System.Drawing;\r\nusing UnrealEngine.Framework;\r\n\r\nnamespace Game {\r\n\tpublic class Main {\r\n\t\tprivate static Entity[] entities = new Entity[32];\r\n\r\n\t\tpublic static void OnWorldBegin() {\r\n\t\t\tfor (int i = 0; i < entities.Length; i++) {\r\n\t\t\t\tentities[i] = new Entity(nameof(Entity) + i);\r\n\t\t\t\tentities[i].OnBegin();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpublic static void OnWorldPrePhysicsTick(float deltaTime) {\r\n\t\t\tfor (int i = 0; i < entities.Length; i++) {\r\n\t\t\t\tif (entities[i].CanTick)\r\n\t\t\t\t\tentities[i].OnPrePhysicsTick(deltaTime);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic class Entity : Actor {\r\n\t\tpublic Entity(string name = null, bool canTick = true) : base(name) {\r\n\t\t\tCanTick = canTick;\r\n\t\t}\r\n\r\n\t\tpublic bool CanTick { get; set; }\r\n\r\n\t\tpublic void OnBegin() => Debug.AddOnScreenMessage(-1, 1.0f, Color.LightSeaGreen, Name + \" begin!\");\r\n\r\n\t\tpublic void OnPrePhysicsTick(float deltaTime) => Debug.AddOnScreenMessage(-1, 1.0f, Color.LightSteelBlue, Name + \" tick!\");\r\n\t}\r\n}\r\n```\r\n\r\n**Data-Oriented Design**\r\n\r\n```csharp\r\nusing System;\r\nusing System.Drawing;\r\nusing UnrealEngine.Framework;\r\n\r\nnamespace Game {\r\n\tpublic class Main {\r\n\t\tprivate static Actor[] entities = new Actor[32];\r\n\t\tprivate static bool[] canTick = new bool[entities.Length];\r\n\r\n\t\tpublic static void OnWorldBegin() {\r\n\t\t\tfor (int i = 0; i < entities.Length; i++) {\r\n\t\t\t\tentities[i] = new Actor(\"Entity\" + i);\r\n\t\t\t\tcanTick[i] = true;\r\n\r\n\t\t\t\tOnEntityBegin(i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpublic static void OnWorldPrePhysicsTick(float deltaTime) {\r\n\t\t\tfor (int i = 0; i < entities.Length; i++) {\r\n\t\t\t\tif (canTick[i])\r\n\t\t\t\t\tOnEntityPrePhysicsTick(i, deltaTime);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tprivate static void OnEntityBegin(int id) => Debug.AddOnScreenMessage(-1, 1.0f, Color.LightSeaGreen, entities[id].Name + \" begin!\");\r\n\r\n\t\tprivate static void OnEntityPrePhysicsTick(int id, float deltaTime) => Debug.AddOnScreenMessage(-1, 1.0f, Color.LightSteelBlue, entities[id].Name + \" tick!\");\r\n\t}\r\n}\r\n```\r\n\r\nSee [tests project](https://github.com/nxrighthere/UnrealCLR/tree/master/Source/Managed/Tests) for a basic implementation of various systems.\r\n\r\n### Blueprints\r\nThe plugin provides two blueprints to manage the execution. They can be used in any combinations with other nodes, data types, and C++ code to weave managed functionality with events. It's highly recommended to use creative approaches that extract information from blueprint classes instead of using plain strings for managed functions.\r\n\r\n**Find Managed Function**\r\n\r\nAttempts to find a managed function from loaded assemblies. This node performs a fast operation to retrieve function pointer from the cached dictionary once assemblies loaded after entering the play mode. Logs an error if the managed function was not found and sets `Result` parameter to `false`. `Optional` checkbox indicates if the managed function is optional and the error should not be logged.\r\n\r\n**Execute Managed Function**\r\n\r\nAttempts to execute a managed function. This node performs a fast execution of a function pointer. Optionally allows passing an [object reference](https://github.com/nxrighthere/UnrealCLR/blob/master/API/ObjectReference.md) of the engine to managed code with further conversion to an appropriate type.\r\n\r\n### Data passing\r\nSeveral options are available to pass data between the managed runtime and the engine.\r\n\r\n**Commands, functions, and events**\r\n\r\nThe engine's reflection system allows to dynamically invoke commands, functions, and events of engine classes from managed code to pass data on-demand through custom arguments.\r\n\r\nBlueprint event dispatcher:\r\n\r\n<p align=\"left\">\r\n\t<img src=\"https://github.com/Rageware/Images/raw/master/UnrealCLR/event-dispatcher.png\" alt=\"event-dispatcher\">\r\n</p>\r\n\r\n```csharp\r\nblueprint.Invoke($\"TestEvent \\\"{ message }\\\" { value }\");\r\n```\r\n\r\nSee [Actor.Invoke()](https://github.com/nxrighthere/UnrealCLR/blob/master/API/Actor-Invoke(string).md), [ActorComponent.Invoke()](https://github.com/nxrighthere/UnrealCLR/blob/master/API/ActorComponent-Invoke(string).md), and [AnimationInstance.Invoke()](https://github.com/nxrighthere/UnrealCLR/blob/master/API/AnimationInstance-Invoke(string).md) methods.\r\n\r\n**Blueprint variables**\r\n\r\nThe engine provides a convenient way to [manage variables/properties](https://docs.unrealengine.com/en-US/Engine/Blueprints/UserGuide/Variables/index.html) per actor/component basis that are accessible from the world outliner.\r\n\r\nInstance-editable blueprint variables:\r\n\r\n<p align=\"left\">\r\n\t<img src=\"https://github.com/Rageware/Images/raw/master/UnrealCLR/blueprint-variables.png\" alt=\"blueprint-variables\">\r\n</p>\r\n\r\nExposed as properties and accessible from the world outliner:\r\n\r\n<p align=\"left\">\r\n\t<img src=\"https://github.com/Rageware/Images/raw/master/UnrealCLR/editor-properties.png\" alt=\"editor-properties\">\r\n</p>\r\n\r\nSee [Actor](https://github.com/nxrighthere/UnrealCLR/blob/master/API/Actor.md), [ActorComponent](https://github.com/nxrighthere/UnrealCLR/blob/master/API/ActorComponent.md), and [AnimationInstance](https://github.com/nxrighthere/UnrealCLR/blob/master/API/AnimationInstance.md) classes for appropriate methods to get and set data.\r\n\r\n**Console variables**\r\n\r\nData that should be globally accessible can be stored in console variables and modified from the editor's console.\r\n\r\n<p align=\"left\">\r\n\t<img src=\"https://github.com/Rageware/Images/raw/master/UnrealCLR/console-variable.png\" alt=\"console-variable\">\r\n</p>\r\n\r\nSee [ConsoleVariable](https://github.com/nxrighthere/UnrealCLR/blob/master/API/ConsoleVariable.md) class for appropriate methods to get and set data.\r\n\r\nTools\r\n--------\r\nThe plugin is compatible with [.NET tools](https://github.com/natemcmaster/dotnet-tools) and makes the engine's application instance visible as a regular .NET application for IDEs and external programs.\r\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.078125,
          "content": "<p align=\"center\">\n\t<img src=\"https://i.imgur.com/c6Zn7SE.png\" alt=\"alt logo\">\n</p>\n\nUnrealCLR is a plugin which natively integrates .NET host into the Unreal Engine with the Common Language Runtime for direct execution of managed code to build a game/application logic using the full power of C# 10.0, F# 6.0, and .NET facilities with engine API. The project is aimed at stability, performance, and maintainability.\n\n[API reference](https://github.com/nxrighthere/UnrealCLR/blob/master/API/UnrealEngine-Framework.md) | [Manual](https://github.com/nxrighthere/UnrealCLR/blob/master/MANUAL.md) | [Code of Conduct](https://github.com/nxrighthere/UnrealCLR/blob/master/CODE_OF_CONDUCT.md) | [Community](https://github.com/nxrighthere/UnrealCLR/discussions) | [Roadmap](https://github.com/users/nxrighthere/projects/5?fullscreen=true) | [Contact](mailto:nxrighthere@gmail.com)\n\nFeatures:\n\n- Host loading, integration, and management during the lifetime of the engine\n- Dynamic loading, unloading, isolation, and dependency resolving of user assemblies at runtime\n- On-the-fly access and execution of managed functionality through blueprints\n- Runtime exceptions handling and tracing\n- Continuously evolving framework for access to the engine API from managed code written in idiomatic C#\n- High-performance interoperability through optimized code and utilization of blittable data types\n- Support of .NET facilities including hardware-accelerated math with transparent re-mapping to vector types of the engine\n- Support of .NET tools for debugging and profiling such as [JetBrains](https://www.jetbrains.com/products.html#lang=csharp) product line, [dnSpy](https://github.com/0xd4d/dnSpy) debugger, and [others](https://www.nuget.org/packages?packagetype=dotnettool)\n- Full independence from the compilation pipeline of assemblies with support of [NuGet](https://www.nuget.org) packages, analyzers, and generators\n- Automatic project packaging for standalone distribution\n- Carefully handcrafted source code for best maintainability and performance\n- Extensive unit testing to ensure the robustness and consistency\n- Distributed as a plugin and doesn't require rebuilding the engine\n- Documented source code\n\nThe plugin is available for Windows, Linux, and macOS (x64).\n\n<p align=\"center\"> \n  <img src=\"https://github.com/Rageware/Images/blob/master/epic-megagrants.png\" alt=\"megagrant\">\n</p>\n\nBuilding\n--------\n### Prerequisites\n- Unreal Engine 4.25.4 or higher\n- A native [compilation toolchain](https://docs.unrealengine.com/en-US/Programming/Development/VisualStudioSetup/index.html#runtheunrealenginepre-requisiteinstaller) with platform-specific dependencies\n- [.NET 6 SDK 6.0.101](https://dotnet.microsoft.com/download/dotnet/6.0)\n\n### Auto\n\n#### Compilation\nCreate a new or use an existing Unreal Engine C++ or blueprints project. Clone the repository or download a desirable version from the [releases](https://github.com/nxrighthere/UnrealCLR/releases) section. Navigate to `Install` folder, and run `dotnet run` command. Follow the installation instructions. Open the project after the installation process is complete.\n\n#### Upgrading\nMake sure that the Unreal Engine is not running. Re-run the installation process. Recompile custom code with an updated framework.\n\n#### Command-line options\n`--project-path <path>` Sets a path to an Unreal Engine project\n\n`--compile-tests <true/false>` Indicates whether tests should be compiled\n\n`--overwrite-files` Indicates whether all previous files of the plugin and content of tests should be overwritten\n\n### Manual\n\n#### Compilation\n\n##### Plugin\nCreate a new or use an existing Unreal Engine C++ or blueprints project. Clone the repository or download a desirable version from the [releases](https://github.com/nxrighthere/UnrealCLR/releases) section. Copy the content of the `Source/Native` folder to `%Project%/Plugins/UnrealCLR` directory. Compile the managed runtime from `Source/Managed/Runtime` folder by running the following command: `dotnet publish --configuration Release --framework net6.0 --output \"%Project%/Plugins/UnrealCLR/Managed\"`. Restart Unreal Engine, open the project, and build the plugin.\n\n##### Tests\nTo quickly start testing, open a project with the plugin in Unreal Engine, copy all folders from the `Content` of the repository to `%Project%/Content` directory, and wait until they loaded in the Content Browser. Compile the managed assemblies from `Source/Managed/Tests` folder by running the following commands:\n```\ndotnet publish \"../Framework\" --configuration Release --framework net6.0\ndotnet publish --configuration Release --framework net6.0 --output \"%Project%/Managed/Tests\"\n```\n\n#### Upgrading\nMake sure that the Unreal Engine is not running. Delete the plugin folder from a project, and repeat all steps from the compilation section. Recompile custom code with an updated framework.\n\nRunning\n--------\n### Plugin\nThe plugin is automatically loaded at startup. To make sure that it's initialized open the console window from `Window -> Developer Tools -> Output Log`, find `UnrealCLR` logs using the search input.\n\n### Tests\nOpen the scene with tests in the editor and enter the play mode. To switch a test, navigate to `Blueprints -> Open Level Blueprint`, select the `Test Systems` enumeration on the left panel, and change default value on the right panel.\n\nOverview\n--------\n### Design and architecture\nUnrealCLR is designed to be flexible and extensible. The plugin is transparently managing core functionality of the runtime, binding and caching the engine API for managed environment. The programmer has full control over execution flow through code and blueprints that allow to dynamically weave native events of the engine and its objects with managed logic. There's no hidden states or obscured order of execution behind the lifecycle of scripts.\n\n### Assemblies management\nAt runtime, UnrealCLR loading managed assemblies into a cached isolated context. It allows dynamically replace assemblies after unloading them from memory, therefore the programmer can work with code without restarting the editor for continuous development. The compilation pipeline is entirely up to a developer, it can be organized in any desirable way without any limitations and with full support of [NuGet](https://www.nuget.org) packages.\n\n### Engine application program interface\nThe plugin and framework are evolving all the time to utilize as much power of the Unreal Engine as possible. It's crucial to have a feature-rich API. The system is created with high-performance in mind but without trading safety. The vast majority of code is written and verified by hand to prevent any unexpected behaviors at runtime and to ensure stability.\n\n### Powerful tooling\nUse your favorite IDE and [.NET tools](https://github.com/natemcmaster/dotnet-tools) that can be attached to the process of the engine just as to a regular .NET application for profiling and debugging. It's very convenient and works out of the box without any external effort. Analyze performance, monitor CPU usage and memory consumption, debug execution, take full control over the code. Explore new possibilities and extend your toolset in no time.\n\nEssentials\n--------\n### Exceptions\nThe runtime redirects all unhandled exceptions to log files, the console window, and on-screen messages of the engine, however, it's highly recommended to use [try-catch](https://docs.microsoft.com/en-us/dotnet/standard/exceptions/how-to-use-the-try-catch-block-to-catch-exceptions) blocks in C# to override redirections with custom handlers. It's necessary to have an attached debugger to properly trace exceptions in the editor or standalone. Use [option types](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/options) in F# to avoid exceptions altogether.\n\n### Memory management\nUnreal Engine, as well as .NET runtime, utilizes a garbage collector for memory management. The framework is designed with consistency in mind to prevent crashes and validate memory transparently for a programmer, no matter how objects were created and freed: with C++, C#, F#, or blueprints.\n\n### Hot reload\nThe plugin is independent of the compilation routine of user assemblies. It's loading assemblies from `%Project%/Managed` folder and resolving dependencies at runtime after entering/leaving the play mode. The framework of the plugin with the engine API is automatically recognized and loaded as a dependency.\n\n### Ecosystem compatibility\nThe framework replicates the class hierarchy of the engine with full interoperability support. Any external C++ code, blueprints, and plugins are compatible and extensible with UnrealCLR by design through the engine API. The plugin integrated into the engine's building pipeline and ready for distribution of self-contained applications.\n\nAcknowledgments\n--------\nThanks to [@natemcmaster](https://github.com/natemcmaster) for a great .NET library that simplifies dynamic loading of assemblies.\n\nSpecial thanks to [@Doraku](https://github.com/Doraku) for an amazing documentation generator and rapid improvement of it.\n\nSupporters\n--------\nThese wonderful people make open-source better:\n<p align=\"left\"> \n  <img src=\"https://github.com/Rageware/Supporters/blob/master/unrealclr-supporters.png\" alt=\"supporters\">\n</p>\n"
        },
        {
          "name": "Source",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}