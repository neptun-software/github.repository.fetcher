{
  "metadata": {
    "timestamp": 1736711117235,
    "page": 945,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Azure/azure-functions-core-tools",
      "stars": 1339,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.8505859375,
          "content": "*.doc  diff=astextplain\n*.DOC\tdiff=astextplain\n*.docx\tdiff=astextplain\n*.DOCX\tdiff=astextplain\n*.dot\tdiff=astextplain\n*.DOT\tdiff=astextplain\n*.pdf\tdiff=astextplain\n*.PDF\tdiff=astextplain\n*.rtf\tdiff=astextplain\n*.RTF\tdiff=astextplain\n\n*.jpg  \tbinary\n*.png \tbinary\n*.gif \tbinary\n\n*.cs text=auto diff=csharp \n*.vb text=auto\n*.c text=auto\n*.cpp text=auto\n*.cxx text=auto\n*.h text=auto\n*.hxx text=auto\n*.py text=auto\n*.rb text=auto\n*.java text=auto\n*.html text=auto\n*.htm text=auto\n*.css text=auto\n*.scss text=auto\n*.sass text=auto\n*.less text=auto\n*.js text eol=lf\n*.json text eol=lf\n*.sh text eol=lf\n*.lisp text=auto\n*.clj text=auto\n*.sql text=auto\n*.php text=auto\n*.lua text=auto\n*.m text=auto\n*.asm text=auto\n*.erl text=auto\n*.fs text=auto\n*.fsx text=auto\n*.hs text=auto\n\n*.csproj text=auto\n*.vbproj text=auto\n*.fsproj text=auto\n*.dbproj text=auto\n*.sln text=auto eol=crlf"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.302734375,
          "content": "bin\nobj\ncsx\n.vs\nedge\nPublish\n\n*.user\n*.suo\n*.cscfg\n*.Cache\n\n/packages\n/TestResults\n\n/tools/NuGet.exe\nnode_modules/\n\n__pycache__\n\n*.ncrunchproject\n*.ncrunchsolution\nnCrunchTemp*\n\n.fake/\nartifacts/\n/src/Azure.Functions.Cli/Properties/launchSettings.json\nlaunchSettings.json\npublish-env\n\n# MacOS related\n.DS_Store"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "Azure.Functions.Cli.sln",
          "type": "blob",
          "size": 2.083984375,
          "content": "﻿\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio Version 16\nVisualStudioVersion = 16.0.29519.87\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"src\", \"src\", \"{5F51C958-39C0-4E0C-9165-71D0BCE647BC}\"\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"test\", \"test\", \"{6EE1D011-2334-44F2-9D41-608B969DAE6D}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Azure.Functions.Cli\", \"src\\Azure.Functions.Cli\\Azure.Functions.Cli.csproj\", \"{6608738C-3BDB-47F5-BC62-66A8BDF9D884}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Azure.Functions.Cli.Tests\", \"test\\Azure.Functions.Cli.Tests\\Azure.Functions.Cli.Tests.csproj\", \"{EAEA6EDB-A301-4A50-86D8-91859DABE30E}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|Any CPU = Debug|Any CPU\n\t\tRelease|Any CPU = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{6608738C-3BDB-47F5-BC62-66A8BDF9D884}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{6608738C-3BDB-47F5-BC62-66A8BDF9D884}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{6608738C-3BDB-47F5-BC62-66A8BDF9D884}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{6608738C-3BDB-47F5-BC62-66A8BDF9D884}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{EAEA6EDB-A301-4A50-86D8-91859DABE30E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{EAEA6EDB-A301-4A50-86D8-91859DABE30E}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{EAEA6EDB-A301-4A50-86D8-91859DABE30E}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{EAEA6EDB-A301-4A50-86D8-91859DABE30E}.Release|Any CPU.Build.0 = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(NestedProjects) = preSolution\n\t\t{6608738C-3BDB-47F5-BC62-66A8BDF9D884} = {5F51C958-39C0-4E0C-9165-71D0BCE647BC}\n\t\t{EAEA6EDB-A301-4A50-86D8-91859DABE30E} = {6EE1D011-2334-44F2-9D41-608B969DAE6D}\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {FA1E01D6-A57B-4061-A333-EDC511D283C0}\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "CODEOWNERS",
          "type": "blob",
          "size": 0.6435546875,
          "content": "# =======================================================\n# See https://help.github.com/articles/about-codeowners/\n# for more info about CODEOWNERS file\n#\n# It uses the same pattern rule for gitignore file\n# https://git-scm.com/docs/gitignore#_pattern_format\n#\n# Order is important; the last matching pattern takes the\n# most precedence.\n# =======================================================\n\n* @azure/azure-functions-core\n\n# Adding codeowner for Language specific files such that GitHub automatically adds language owners as a reviewers.\nsrc/Azure.Functions.Cli/Azure.Functions.Cli.csproj @azure/azure-functions-worker-owners @azure/azure-functions-core\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 4.68359375,
          "content": "﻿## Running the latest runtime version\n\n## Dependencies\n\nThere is a dependency on the .NET Core tools for the cross platform support. You can [install these here](https://www.microsoft.com/net/core).\n\nTo install the required dotnet packages navigate into the repository root and run `dotnet restore`\n\n## Compiling the CLI Tools\n\nTo build the project run `cd src/Azure.Functions.Cli; dotnet build` (note navigating into the src directory is required due to the test suite currently failing to compile on non-windows environments - see below)\n\n### Running against a function app\n\nTo test this project against a local function app you can run from that function app's directory\n\n`dotnet run --project PATH_TO_FUNCTIONS_CLI/src/Azure.Functions.Cli start`\n\nwhere PATH_TO_FUNCTIONS_CLI is the absolute or relative path to the root of this repository.\n\n### Running the Test Suite\n\n- Build the solution `dotnet build Azure.Functions.Cli.sln`\n  - As part of this build, the cli is copied into the test project's output directory (`test/Azure.Functions.Cli.Tests/bin/Debug/net8.0`) - this is what will be used by the tests\n  - If you wish to override this, you can set the `FUNC_PATH` environment variable to the path of the `func`/`func.exe` you wish to test against\n- Run the test suite in Visual Studio Test Explorer or by running `dotnet test` from the `test` project root.\n  - i.e. `cd test/Azure.Functions.Cli.Tests; dotnet test`\n\n#### Storage Emulator\n\nSome tests, namely E2E, require an Azure storage emulator to be running. You can download the storage emulator [here](https://learn.microsoft.com/en-us/azure/storage/common/storage-use-azurite?tabs=visual-studio%2Cblob-storage).\n\nRun the emulator before your run the tests.\n\n> There is a script you can use for this as well, see `tools/start-emulators.ps1`\n\n#### Templates missing\n\nIf you see an error saying the templates folder is missing, you can follow either of the following steps:\n\n##### (a)\n\n- Find your offical func instation directory\n  - i.e. `/opt/homebrew/Cellar/azure-functions-core-tools@4/4.0.6610`\n  - or `%LOCALAPPDATA%\\AzureFunctionsTools\\Releases\\4.69.0\\cli_x64\\`\n- Copy the templates folder to the test project's output directory (`test/Azure.Functions.Cli.Tests/bin/Debug/net8.0`)\n\n##### or (b)\n\n- Update `build/Program.cs` to just add the template nugets and json:\n\n    ```csharp\n    Orchestrator\n        .CreateForTarget(args)\n        .Then(AddTemplatesNupkgs)\n        .Then(AddTemplatesJson)\n        .Run();\n    ```\n- Set environment variables required to run the build script\n  - Windows: `$env:IsReleaseBuild = \"false\"`\n  - MacOS: `export IsReleaseBuild=false`\n    - If using M1/M2, you may need to set the dotnet root as well `export DOTNET_ROOT=/usr/local/share/dotnet/x64`\n- Run the build script `build.ps1`\n- In the `artifacts` folder, you should find a `templates` folder within any the subfolders here\n- Copy the `templates` folder to the test project's output directory (`test/Azure.Functions.Cli.Tests/bin/Debug/net8.0`)\n\n## Contributing to this Repository\n\n### Filing Issues\n\nFiling issues is a great way to contribute to the SDK. Here are some guidelines:\n\n* Include as much detail as you can be about the problem\n* Point to a test repository (e.g. hosted on GitHub) that can help reproduce the issue. This works better then trying to describe step by step how to create a repro scenario.\n* Github supports markdown, so when filing bugs make sure you check the formatting before clicking submit.\n\n### Submitting Pull Requests\n\nIf you don't know what a pull request is read this https://help.github.com/articles/using-pull-requests.\n\nBefore we can accept your pull-request you'll need to sign a [Contribution License Agreement (CLA)](http://en.wikipedia.org/wiki/Contributor_License_Agreement). You can sign ours [here](https://cla2.dotnetfoundation.org). However, you don't have to do this up-front. You can simply clone, fork, and submit your pull-request as usual.\n\nWhen your pull-request is created, we classify it. If the change is trivial, i.e. you just fixed a typo, then the PR is labelled with `cla-not-required`. Otherwise it's classified as `cla-required`. In that case, the system will also also tell you how you can sign the CLA. Once you signed a CLA, the current and all future pull-requests will be labelled as `cla-signed`. Signing the CLA might sound scary but it's actually super simple and can be done in less than a minute.\n\nBefore submitting a feature or substantial code contribution please discuss it with the team and ensure it follows the product roadmap. Note that all code submissions will be rigorously reviewed and tested by the Azure Functions Core Tools team, and only those that meet the bar for both quality and design/roadmap appropriateness will be merged into the source."
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0810546875,
          "content": "﻿The MIT License (MIT)\n\nCopyright (c) .NET Foundation.  All rights reserved.  \n \nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n \nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n \nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE."
        },
        {
          "name": "NuGet.Config",
          "type": "blob",
          "size": 1.1025390625,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<configuration>\n  <clear />\n  <packageSources>\n    <clear />\n    <add key=\"nuget.org\" value=\"https://api.nuget.org/v3/index.json\" />\n    <add key=\"Microsoft.Azure.Functions.PowerShellWorker\" value=\"https://azfunc.pkgs.visualstudio.com/e6a70c92-4128-439f-8012-382fe78d6396/_packaging/Microsoft.Azure.Functions.PowerShellWorker/nuget/v3/index.json\" />\n    <add key=\"AzureFunctions\" value=\"https://azfunc.pkgs.visualstudio.com/e6a70c92-4128-439f-8012-382fe78d6396/_packaging/AzureFunctions/nuget/v3/index.json\" />\n    <add key=\"AzureFunctionsRelease\" value=\"https://azfunc.pkgs.visualstudio.com/e6a70c92-4128-439f-8012-382fe78d6396/_packaging/AzureFunctionsRelease/nuget/v3/index.json\" />\n    <add key=\"AzureFunctionsPreRelease\" value=\"https://azfunc.pkgs.visualstudio.com/e6a70c92-4128-439f-8012-382fe78d6396/_packaging/AzureFunctionsPreRelease/nuget/v3/index.json\" />\n    <add key=\"AzureFunctionsTempStaging\" value=\"https://azfunc.pkgs.visualstudio.com/e6a70c92-4128-439f-8012-382fe78d6396/_packaging/AzureFunctionsTempStaging/nuget/v3/index.json\" />\n  </packageSources>\n</configuration>\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 14.10546875,
          "content": "﻿![Azure Functions Logo](https://raw.githubusercontent.com/Azure/azure-functions-cli/master/src/Azure.Functions.Cli/npm/assets/azure-functions-logo-color-raster.png)\n\n|Branch|Status|\n|---|---|\n|main|[![Build status](https://azfunc.visualstudio.com/Azure%20Functions/_apis/build/status/azure-functions-core-tools?branchName=main)](https://azfunc.visualstudio.com/Azure%20Functions/_build/latest?definitionId=11&branchName=main)|\n|in-proc|[![Build status](https://azfunc.visualstudio.com/Azure%20Functions/_apis/build/status/azure-functions-core-tools?branchName=in-proc)](https://azfunc.visualstudio.com/Azure%20Functions/_build/latest?definitionId=11&branchName=in-proc)|\n|v1.x|[![Build status](https://azfunc.visualstudio.com/Azure%20Functions/_apis/build/status/azure-functions-core-tools?branchName=v1.x)](https://azfunc.visualstudio.com/Azure%20Functions/_build/latest?definitionId=11&branchName=v1.x)|\n\n# Azure Functions Core Tools\n\nThe Azure Functions Core Tools provide a local development experience for creating, developing, testing, running, and debugging Azure Functions.\n\n## Versions\n\n**v1** (v1.x branch): Requires .NET 4.7.1 Windows Only\n\n**v4**: (main branch): Self-contained cross-platform package **(recommended)**\n\n## Installing\n\n### Windows\n\n#### To download and install with MSI:\n\n##### v4\n\n- [Windows 64-bit](https://go.microsoft.com/fwlink/?linkid=2174087) (VS Code debugging requires 64-bit)\n- [Windows 32-bit](https://go.microsoft.com/fwlink/?linkid=2174159)\n\n##### v3\n\n- [Windows 64-bit](https://go.microsoft.com/fwlink/?linkid=2135274) (VS Code debugging requires 64-bit)\n- [Windows 32-bit](https://go.microsoft.com/fwlink/?linkid=2135275)\n\n#### To install with npm:\n\n##### v4\n```bash\nnpm i -g azure-functions-core-tools@4 --unsafe-perm true\n```\n\n##### v3\n```bash\nnpm i -g azure-functions-core-tools@3 --unsafe-perm true\n```\n\n##### v2\n```bash\nnpm i -g azure-functions-core-tools@2 --unsafe-perm true\n```\n\n#### To install with chocolatey:\n\n##### v4\n```bash\nchoco install azure-functions-core-tools\n```\n\n##### v3\n```bash\nchoco install azure-functions-core-tools-3\n```\n\n*Notice: To debug functions under vscode, the 64-bit version is required*\n```bash\nchoco install azure-functions-core-tools-3 --params \"'/x64'\"\n```\n\n##### v2\n```bash\nchoco install azure-functions-core-tools-2\n```\n\n#### To install with winget:\n\n##### v4\n\n```bash\nwinget install Microsoft.Azure.FunctionsCoreTools\n```\n\n##### v3\n\n```bash\nwinget install Microsoft.Azure.FunctionsCoreTools -v 3.0.3904\n```\n\n### Mac\n\n#### Homebrew:\n\n##### v4\n    \n```bash\nbrew tap azure/functions\nbrew install azure-functions-core-tools@4\n```\n\n##### v3\n```bash\nbrew tap azure/functions\nbrew install azure-functions-core-tools@3\n```\n\n##### v2\n```bash\nbrew tap azure/functions\nbrew install azure-functions-core-tools@2\n```\n\nHomebrew allows side by side installation of v2 and v3, you can switch between the versions using\n```bash\nbrew link --overwrite azure-functions-core-tools@3\n```\n\n\n### Linux\n\n#### 1. Set up package feed\n\n##### Ubuntu 22.04\n\n```bash\nwget -q https://packages.microsoft.com/config/ubuntu/22.04/packages-microsoft-prod.deb\nsudo dpkg -i packages-microsoft-prod.deb\n```\n\n##### Ubuntu 20.04\n\n```bash\nwget -q https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb\nsudo dpkg -i packages-microsoft-prod.deb\n```\n\n##### Ubuntu 19.04\n\n```bash\nwget -q https://packages.microsoft.com/config/ubuntu/19.04/packages-microsoft-prod.deb\nsudo dpkg -i packages-microsoft-prod.deb\n```\n\n##### Ubuntu 18.10\n\n```bash\nwget -q https://packages.microsoft.com/config/ubuntu/18.10/packages-microsoft-prod.deb\nsudo dpkg -i packages-microsoft-prod.deb\n```\n\n##### Ubuntu 18.04\n\n```bash\nwget -q https://packages.microsoft.com/config/ubuntu/18.04/packages-microsoft-prod.deb\nsudo dpkg -i packages-microsoft-prod.deb\n```\n\n##### Ubuntu 16.04 / Linux Mint 18\n\n```bash\nwget -q https://packages.microsoft.com/config/ubuntu/16.04/packages-microsoft-prod.deb\nsudo dpkg -i packages-microsoft-prod.deb\n```\n\n##### Debian 12\n\n```bash\nexport DEBIAN_VERSION=12\n\napt-get update && apt-get install gpg wget  -y\nwget -qO- https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor | tee /usr/share/keyrings/microsoft-prod.gpg\nwget -q https://packages.microsoft.com/config/debian/$DEBIAN_VERSION/prod.list\nmv prod.list /etc/apt/sources.list.d/microsoft-prod.list\nchown root:root /usr/share/keyrings/microsoft-prod.gpg\nchown root:root /etc/apt/sources.list.d/microsoft-prod.list\napt-get update && apt-get install azure-functions-core-tools-4  -y\napt-get update && apt-get install libicu-dev  -y\n```\n\n#### 2. Install\n\n##### v4\n```bash\nsudo apt-get update\nsudo apt-get install azure-functions-core-tools-4\n```\n\n##### v3\n```bash\nsudo apt-get update\nsudo apt-get install azure-functions-core-tools-3\n```\n\n##### v2\n```bash\nsudo apt-get update\nsudo apt-get install azure-functions-core-tools-2\n```\n\n#### Other Linux Distributions\n\n1. Download latest release\n\n    Download the latest release for your platform from [here](https://github.com/Azure/azure-functions-core-tools/releases).\n\n2. Unzip release zip\n\n    Using your preferred tool, unzip the downloaded release. To unzip into an `azure-functions-cli` directory using the `unzip` tool, run this command from the directory containing the downloaded release zip:\n\n    ```bash\n    unzip -d azure-functions-cli Azure.Functions.Cli.linux-x64.*.zip\n    ```\n\n3. Make the `func` command executable\n\n    Zip files do not maintain the executable bit on binaries. So, you'll need to make the `func` binary, as well as `gozip` (used by func during packaging) executables. Assuming you used the instructions above to unzip:\n\n    ```bash\n    cd azure-functions-cli\n    chmod +x func\n    chmod +x gozip\n    ./func\n    ```\n\n4. Optionally add `func` to your `$PATH`\n\n    To execute the `func` command without specifying the full path to the binary, add its directory to your `$PATH` environment variable. Assuming you're still following along from above:\n\n    ```bash\n    export PATH=`pwd`:$PATH\n    func\n    ```\n\n[Code and test Azure Functions locally](https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local)\n\n**NOTE**: npm can be used on all platforms. On unix platforms, you may need to specify `--unsafe-perm` if you are running npm with sudo. That's due to npm behavior of post install script.\n\n## Getting Started on Kubernetes\n\nUsing the Core Tools, you can easily configure a Kubernetes cluster and run Azure Functions on it.\n\n### Prerequisites\n\n* [Docker](https://docs.docker.com/install/)\n* [Kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/)\n\n### Installing Kubernetes scalers\n\nThis deploys [KEDA](https://github.com/kedacore/keda) to your cluster which allows you to deploy your functions in a scale-to-zero by default for non-http scenarios only.\n\n```bash\nfunc kubernetes install --namespace {namespace}\n```\n\n**KEDA:** Handles monitoring polling event sources currently QueueTrigger and ServiceBusTrigger.\n\n### Deploy to Kubernetes\n\n**First make sure you have Dockerfile for your project.** You can generate one using\n```bash\nfunc init --docker # or --docker-only (for existing projects)\n```\nThen to deploy to kubernetes\n\n```bash\nfunc kubernetes deploy \\\n    --name myfunction \\\n    --namespace functions-ns \\\n    --registry <docker-hub-id or registry-server>\n```\n\nThis will build the current `Dockerfile` and push the image to the registry specified, then deploys a `Secret`, `Deployment`, and `ScaledObject`. If your functions have httpTrigger, you'll get an additional `Deployment` and `Service`.\n\n### Deploy using a private registry\n\n```bash\nfunc kubernetes deploy --name myfunction --registry <docker-hub-id or registry-server> --pull-secret <registry auth secret>\n\n```\n\n### Deploy a function to Knative\n\n#### Prerequisites\n\n* [Knative](https://github.com/knative/docs/tree/master/docs/install)\n\nDeploying Azure Functions to knative is supported with the ```--platform knative``` flag.\nThe Core Tools CLI identifies non HTTP trigger functions and annotates the knative manifest with the the ```minScale``` annotation to opt out of scale-to-zero.\n\n```bash\nfunc deploy --platform knative --name myfunction --registry <docker-hub-id or registry-server>\n```\n\n### Deploying a function to AKS using ACR\nUsing the configuration options an Azure Function app can also be deployed to a [AKS](https://azure.microsoft.com/en-us/services/kubernetes-service/) (Azure Kubernetes Service) Kubernetes cluster and use [ACR](https://azure.microsoft.com/en-us/services/container-registry/) as the registry server. Do all of the following *before* you run the deployment command.\n\n#### Create a AKS cluster\nYou can create an AKS cluster using the [Azure Portal](https://docs.microsoft.com/en-us/azure/aks/kubernetes-walkthrough-portal) or using [Azure CLI](https://docs.microsoft.com/en-us/azure/aks/kubernetes-walkthrough).\n\nOnce your AKS cluster is created make sure that you can access it using kubectl. To make kubectl run in the context of your cluster, configure a connection using the command below.\n```azurecli\naz aks get-credentials \\\n    --name FunctionsCluster \\\n    --resource-group <resource-group-name>\n```\n\nTo verify the connection to your cluster run the following command\n```bash\n> kubectl get nodes\n\nNAME                       STATUS    ROLES     AGE       VERSION\naks-agentpool-20257154-0   Ready     agent     1d        v1.11.5\naks-agentpool-20257154-1   Ready     agent     1d        v1.11.5\naks-agentpool-20257154-2   Ready     agent     1d        v1.11.5\n```\n#### Create a ACR Registry\nAn ACR instance can be created using the Azure Portal or the [Azure CLI](https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-azure-cli#create-a-container-registry)\n\n#### Login to the ACR Registry\nBefore pushing and pulling container images, you must log in to the ACR instance.\n\n```azurecli\naz acr login --name <acrName>\n```\n\n#### Give the AKS cluster access to the ACR Registry\nThe AKS cluster needs access to the ACR Registry to pull the container. Azure creates a service principal to support cluster operability with other Azure resources. This can be used for authentication with an ACR registry. See here for how to grant the right access here: [Authenticate with Azure Container Registry from Azure Kubernetes Service](https://docs.microsoft.com/en-us/azure/container-registry/container-registry-auth-aks)\n\n#### Run the deployment\nThe deployment will build the docker container and upload the container image to your referenced ACR instance (Note: Specify the ACR Login Server in the --registry parameter this is usually of the form <container_registry_name>.azurecr.io) and then your AKS cluster will use that as a source to obtain the container and deploy it.\n\n```bash\nfunc kubernetes deploy --name myfunction --registry <acr-registry-loginserver>\n```\n\nIf the deployment is successful, you should see this:\n\nFunction deployed successfully!\nFunction IP: 40.121.21.192\n\n#### Verifying your deployment\nYou can verify your deployment by using the Kubernetes web dashboard. To start the Kubernetes dashboard, use the [az aks browse](https://docs.microsoft.com/en-us/cli/azure/aks?view=azure-cli-latest#az-aks-browse) command.\n\n```azurecli\naz aks browse --resource-group myResourceGroup --name myAKSCluster\n```\nIn the Kubernetes dashboard look for the namespace \"azure-functions\" and make sure that a pod has been deployed sucessfully with your container.\n\n### Deploying Azure Functions with Virtual-Kubelet\n\nAzure Functions running on Kubernetes can take advantage of true serverless containers model by getting deployed to different providers of [Virtual Kubelet](https://github.com/virtual-kubelet/virtual-kubelet), such as Azure Container Instances.<br>\n\nFunctions deployed to Kubernetes already contain all the tolerations needed to be schedulable to Virtual Kubelet nodes.\nAll you need to do is to set up VKubelet on your Kubernetes cluster:\n\n* [Install VKubelet with ACI](https://github.com/virtual-kubelet/azure-aci)\n\n* [Install VKubelet with ACI on AKS](https://docs.microsoft.com/en-us/cli/azure/aks?view=azure-cli-latest#az-aks-install-connector)\n\n*Important note:*\nVirtual Kubelet does not currently allow for Kubernetes Services to route external traffic to pods.\nThis means that HTTP triggered functions will not receive traffic running on a VKubelet provider (including ACI).\n\nA good usage scenario for using functions with VKubelet would be with event triggered / time triggered functions that do not rely on external HTTP traffic.\n\n## Known Issues:\n\n`func extensions` command require the `dotnet` cli to be installed and on your path. This requirement is tracked [here](https://github.com/Azure/azure-functions-core-tools/issues/367). You can install .NET Core for your platform from https://www.microsoft.com/net/download/\n\n## Default Directories\n\n* `CurrentDirectory`: is the default directory the functions runtime looks for functions in.\n* `%TMP%\\LogFiles\\Application\\Functions`: is the default directory for logs. It mirrors the logs directory on Azure as well.\n\n## Telemetry\n\nThe Azure Functions Core tools collect usage data in order to help us improve your experience.\nThe data is anonymous and doesn't include any user specific or personal information. The data is collected by Microsoft.\n\nYou can opt-out of telemetry by setting the `FUNCTIONS_CORE_TOOLS_TELEMETRY_OPTOUT` environment variable to '1' or 'true' using your favorite shell.\n\n[Microsoft privacy statement](https://privacy.microsoft.com/en-US/privacystatement)\n\n## License\n\nThis project is under the benevolent umbrella of the [.NET Foundation](http://www.dotnetfoundation.org/) and is licensed under [the MIT License](LICENSE)\n\nThis project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/). For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.\n\n## Contact Us\n\nFor questions on Azure Functions or the tools, you can ask questions here:\n\n- [Azure Functions Q&A Forum](https://docs.microsoft.com/en-us/answers/topics/azure-functions.html)\n- [Azure-Functions tag on StackOverflow](http://stackoverflow.com/questions/tagged/azure-functions)\n\nFile bugs at [Azure Functions Core Tools repo on GitHub](https://github.com/Azure/azure-functions-core-tools/issues).\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 2.6923828125,
          "content": "<!-- BEGIN MICROSOFT SECURITY.MD V0.0.7 BLOCK -->\n\n## Security\n\nMicrosoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include [Microsoft](https://github.com/Microsoft), [Azure](https://github.com/Azure), [DotNet](https://github.com/dotnet), [AspNet](https://github.com/aspnet), [Xamarin](https://github.com/xamarin), and [our GitHub organizations](https://opensource.microsoft.com/).\n\nIf you believe you have found a security vulnerability in any Microsoft-owned repository that meets [Microsoft's definition of a security vulnerability](https://aka.ms/opensource/security/definition), please report it to us as described below.\n\n## Reporting Security Issues\n\n**Please do not report security vulnerabilities through public GitHub issues.**\n\nInstead, please report them to the Microsoft Security Response Center (MSRC) at [https://msrc.microsoft.com/create-report](https://aka.ms/opensource/security/create-report).\n\nIf you prefer to submit without logging in, send email to [secure@microsoft.com](mailto:secure@microsoft.com).  If possible, encrypt your message with our PGP key; please download it from the [Microsoft Security Response Center PGP Key page](https://aka.ms/opensource/security/pgpkey).\n\nYou should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at [microsoft.com/msrc](https://aka.ms/opensource/security/msrc). \n\nPlease include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue:\n\n  * Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.)\n  * Full paths of source file(s) related to the manifestation of the issue\n  * The location of the affected source code (tag/branch/commit or direct URL)\n  * Any special configuration required to reproduce the issue\n  * Step-by-step instructions to reproduce the issue\n  * Proof-of-concept or exploit code (if possible)\n  * Impact of the issue, including how an attacker might exploit the issue\n\nThis information will help us triage your report more quickly.\n\nIf you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our [Microsoft Bug Bounty Program](https://aka.ms/opensource/security/bounty) page for more details about our active programs.\n\n## Preferred Languages\n\nWe prefer all communications to be in English.\n\n## Policy\n\nMicrosoft follows the principle of [Coordinated Vulnerability Disclosure](https://aka.ms/opensource/security/cvd).\n\n<!-- END MICROSOFT SECURITY.MD BLOCK -->\n"
        },
        {
          "name": "build.ps1",
          "type": "blob",
          "size": 0.95703125,
          "content": "$buildFolderPath = Join-Path $PSScriptRoot \"build\"\nif (-not (Test-Path $buildFolderPath))\n{\n    throw \"Build folder '$buildFolderPath' does not exist.\"\n}\n\nSet-Location $buildFolderPath\n\n$buildCommand = $null\n\n$isReleaseBuild = $null\nif (-not([bool]::TryParse($env:IsReleaseBuild, [ref] $isReleaseBuild)))\n{\n    throw \"IsReleaseBuild can only be set to true or false.\"\n}\n\nif ($env:IntegrationBuildNumber)\n{\n    if (-not ($env:IntegrationBuildNumber -like \"PreRelease*-*\"))\n    {\n        $integrationBuildNumberExample = \"PreRelease\" + (Get-Date -Format \"yyMMdd-HHmm\")\n        $errorMessage = \"IntegrationBuildNumber '$env:IntegrationBuildNumber' format is invalid. It should be of the form '$integrationBuildNumberExample'.\"\n        throw $errorMessage\n    }\n\n    $buildCommand = { dotnet run --integrationTests }\n}\nelse\n{\n    $buildCommand = { dotnet run --ci }\n}\n\nWrite-Host \"Running $buildCommand\"\n& $buildCommand\nif ($LastExitCode -ne 0) { $host.SetShouldExit($LastExitCode)  }"
        },
        {
          "name": "build.sh",
          "type": "blob",
          "size": 0.2568359375,
          "content": "#!/usr/bin/env bash\ndotnet build Azure.Functions.Cli.sln\ndotnet publish src/Azure.Functions.Cli/Azure.Functions.Cli.csproj --runtime linux-x64 --output /tmp/cli\n# FUNC_PATH=/tmp/cli/func dotnet test test/Azure.Functions.Cli.Tests/Azure.Functions.Cli.Tests.csproj\n"
        },
        {
          "name": "build",
          "type": "tree",
          "content": null
        },
        {
          "name": "check-vulnerabilities.ps1",
          "type": "blob",
          "size": 2.0615234375,
          "content": "$projectPath = \".\\src\\Azure.Functions.Cli\"\n$projectFileName = \".\\Azure.Functions.Cli.csproj\"\n$logFilePath = \"..\\..\\build.log\"\n$skipCveFilePath = \"..\\..\\skipPackagesCve.json\"\nif (-not (Test-Path $projectPath))\n{\n    throw \"Project path '$projectPath' does not exist.\"\n}\n\ncd $projectPath\n\n$cmd = \"restore\"\nWrite-Host \"dotnet $cmd\"\ndotnet $cmd | Tee-Object $logFilePath\n\n$cmd = \"list\", \"package\", \"--include-transitive\", \"--vulnerable\", \"--format\", \"json\"\nWrite-Host \"dotnet $cmd\"\ndotnet $cmd | Tee-Object $logFilePath\n\n# Parse JSON output\n$logContent = Get-Content $logFilePath -Raw | ConvertFrom-Json\n$topLevelPackages = $logContent.projects.frameworks.topLevelPackages\n\n# Load skip-cve.json\n$skipCveContent = Get-Content $skipCveFilePath -Raw | ConvertFrom-Json\n$skipPackages = $skipCveContent.packages\n\n# Validate files in skipPackagesCve.json are still valid security vulnerabilities\n$topLevelPackageIds = $topLevelPackages.id\n$invalidSkips = $skipPackages | Where-Object { $_ -notin $topLevelPackageIds }\n\nif ($invalidSkips.Count -gt 0) {\n    Write-Host \"The following packages in 'skipPackagesCve.json' do not exist in the vulnerable packages list: $($invalidSkips -join ', '). Please remove these packages from the JSON file.\"\n    Exit 1\n}\n\n# Filter vulnerabilities\n$vulnerablePackages = @()\nforeach ($package in $topLevelPackages) {\n    if ($skipPackages -notcontains $package.id) {\n        $vulnerablePackages += $package\n    }\n}\n\n# Check for remaining vulnerabilities\nif ($vulnerablePackages.Count -gt 0) {\n    Write-Host \"Security vulnerabilities found (excluding skipped packages):\"\n    $vulnerablePackages | ForEach-Object {\n        Write-Host \"Package: $($_.id)\"\n        Write-Host \"Version: $($_.resolvedVersion)\"\n        $_.vulnerabilities | ForEach-Object {\n            Write-Host \"Severity: $($_.severity)\"\n            Write-Host \"Advisory: $($_.advisoryurl)\"\n        }\n    }\n    Exit 1\n} else {\n    Write-Host \"No security vulnerabilities found (excluding skipped packages).\"\n}\n\n$logFileExists = Test-Path $logFilePath -PathType Leaf\nif ($logFileExists)\n{\n  Remove-Item $logFilePath\n}\n\ncd ../.."
        },
        {
          "name": "code-mirror.yml",
          "type": "blob",
          "size": 0.5302734375,
          "content": "trigger:\n  branches:\n    include:\n    # Below branches are examples for Azure/azure-functions-host. Replace with appropriate branches for your repository.\n    # Keep this set limited as appropriate (don't mirror individual user branches).\n    - v3.x\n    - release_4.0\n    - release_3.0\n    - release_4.0_hotfix\n    - main\n    - in-proc\n\nresources:\n  repositories:\n  - repository: eng\n    type: git\n    name: engineering\n    ref: refs/tags/release\n\nvariables:\n  - template: ci/variables/cfs.yml@eng\n\nextends:\n  template: ci/code-mirror.yml@eng\n"
        },
        {
          "name": "dotnet-install.sh",
          "type": "blob",
          "size": 29.4638671875,
          "content": "#!/usr/bin/env bash\n# Copyright (c) .NET Foundation and contributors. All rights reserved.\n# Licensed under the MIT license. See LICENSE file in the project root for full license information.\n#\n# Original file from https://github.com/dotnet/cli/blob/80d542b8f4eff847a0f72dc8f2c2a29851272778/scripts/obtain/dotnet-install.sh\n\n# Stop script on NZEC\nset -e\n# Stop script if unbound variable found (use ${var:-} if intentional)\nset -u\n# By default cmd1 | cmd2 returns exit code of cmd2 regardless of cmd1 success\n# This is causing it to fail\nset -o pipefail\n\n# Use in the the functions: eval $invocation\ninvocation='say_verbose \"Calling: ${yellow:-}${FUNCNAME[0]} ${green:-}$*${normal:-}\"'\n\n# standard output may be used as a return value in the functions\n# we need a way to write text on the screen in the functions so that\n# it won't interfere with the return value.\n# Exposing stream 3 as a pipe to standard output of the script itself\nexec 3>&1\n\n# Setup some colors to use. These need to work in fairly limited shells, like the Ubuntu Docker container where there are only 8 colors.\n# See if stdout is a terminal\nif [ -t 1 ] && command -v tput > /dev/null; then\n    # see if it supports colors\n    ncolors=$(tput colors)\n    if [ -n \"$ncolors\" ] && [ $ncolors -ge 8 ]; then\n        bold=\"$(tput bold       || echo)\"\n        normal=\"$(tput sgr0     || echo)\"\n        black=\"$(tput setaf 0   || echo)\"\n        red=\"$(tput setaf 1     || echo)\"\n        green=\"$(tput setaf 2   || echo)\"\n        yellow=\"$(tput setaf 3  || echo)\"\n        blue=\"$(tput setaf 4    || echo)\"\n        magenta=\"$(tput setaf 5 || echo)\"\n        cyan=\"$(tput setaf 6    || echo)\"\n        white=\"$(tput setaf 7   || echo)\"\n    fi\nfi\n\nsay_warning() {\n    printf \"%b\\n\" \"${yellow:-}dotnet_install: Warning: $1${normal:-}\"\n}\n\nsay_err() {\n    printf \"%b\\n\" \"${red:-}dotnet_install: Error: $1${normal:-}\" >&2\n}\n\nsay() {\n    # using stream 3 (defined in the beginning) to not interfere with stdout of functions\n    # which may be used as return value\n    printf \"%b\\n\" \"${cyan:-}dotnet-install:${normal:-} $1\" >&3\n}\n\nsay_verbose() {\n    if [ \"$verbose\" = true ]; then\n        say \"$1\"\n    fi\n}\n\n# This platform list is finite - if the SDK/Runtime has supported Linux distribution-specific assets,\n#   then and only then should the Linux distribution appear in this list.\n# Adding a Linux distribution to this list does not imply distribution-specific support.\nget_legacy_os_name_from_platform() {\n    eval $invocation\n\n    platform=\"$1\"\n    case \"$platform\" in\n        \"centos.7\")\n            echo \"centos\"\n            return 0\n            ;;\n        \"debian.8\")\n            echo \"debian\"\n            return 0\n            ;;\n        \"fedora.23\")\n            echo \"fedora.23\"\n            return 0\n            ;;\n        \"fedora.27\")\n            echo \"fedora.27\"\n            return 0\n            ;;\n        \"fedora.24\")\n            echo \"fedora.24\"\n            return 0\n            ;;\n        \"opensuse.13.2\")\n            echo \"opensuse.13.2\"\n            return 0\n            ;;\n        \"opensuse.42.1\")\n            echo \"opensuse.42.1\"\n            return 0\n            ;;\n        \"opensuse.42.3\")\n            echo \"opensuse.42.3\"\n            return 0\n            ;;\n        \"rhel.7\"*)\n            echo \"rhel\"\n            return 0\n            ;;\n        \"ubuntu.14.04\")\n            echo \"ubuntu\"\n            return 0\n            ;;\n        \"ubuntu.16.04\")\n            echo \"ubuntu.16.04\"\n            return 0\n            ;;\n        \"ubuntu.16.10\")\n            echo \"ubuntu.16.10\"\n            return 0\n            ;;\n        \"ubuntu.18.04\")\n            echo \"ubuntu.18.04\"\n            return 0\n            ;;\n        \"alpine.3.4.3\")\n            echo \"alpine\"\n            return 0\n            ;;\n    esac\n    return 1\n}\n\nget_linux_platform_name() {\n    eval $invocation\n\n    if [ -n \"$runtime_id\" ]; then\n        echo \"${runtime_id%-*}\"\n        return 0\n    else\n        if [ -e /etc/os-release ]; then\n            . /etc/os-release\n            echo \"$ID.$VERSION_ID\"\n            return 0\n        elif [ -e /etc/redhat-release ]; then\n            local redhatRelease=$(</etc/redhat-release)\n            if [[ $redhatRelease == \"CentOS release 6.\"* || $redhatRelease == \"Red Hat Enterprise Linux Server release 6.\"* ]]; then\n                echo \"rhel.6\"\n                return 0\n            fi\n        fi\n    fi\n\n    say_verbose \"Linux specific platform name and version could not be detected: UName = $uname\"\n    return 1\n}\n\nget_current_os_name() {\n    eval $invocation\n\n    local uname=$(uname)\n    if [ \"$uname\" = \"Darwin\" ]; then\n        echo \"osx\"\n        return 0\n    elif [ \"$uname\" = \"Linux\" ]; then\n        local linux_platform_name\n        linux_platform_name=\"$(get_linux_platform_name)\" || { echo \"linux\" && return 0 ; }\n\n        if [[ $linux_platform_name == \"rhel.6\" ]]; then\n            echo $linux_platform_name\n            return 0\n        elif [[ $linux_platform_name == alpine* ]]; then\n            echo \"linux-musl\"\n            return 0\n        else\n            echo \"linux\"\n            return 0\n        fi\n    fi\n\n    say_err \"OS name could not be detected: UName = $uname\"\n    return 1\n}\n\nget_legacy_os_name() {\n    eval $invocation\n\n    local uname=$(uname)\n    if [ \"$uname\" = \"Darwin\" ]; then\n        echo \"osx\"\n        return 0\n    elif [ -n \"$runtime_id\" ]; then\n        echo $(get_legacy_os_name_from_platform \"${runtime_id%-*}\" || echo \"${runtime_id%-*}\")\n        return 0\n    else\n        if [ -e /etc/os-release ]; then\n            . /etc/os-release\n            os=$(get_legacy_os_name_from_platform \"$ID.$VERSION_ID\" || echo \"\")\n            if [ -n \"$os\" ]; then\n                echo \"$os\"\n                return 0\n            fi\n        fi\n    fi\n\n    say_verbose \"Distribution specific OS name and version could not be detected: UName = $uname\"\n    return 1\n}\n\nmachine_has() {\n    eval $invocation\n\n    hash \"$1\" > /dev/null 2>&1\n    return $?\n}\n\n\ncheck_min_reqs() {\n    local hasMinimum=false\n    if machine_has \"curl\"; then\n        hasMinimum=true\n    elif machine_has \"wget\"; then\n        hasMinimum=true\n    fi\n\n    if [ \"$hasMinimum\" = \"false\" ]; then\n        say_err \"curl (recommended) or wget are required to download dotnet. Install missing prerequisite to proceed.\"\n        return 1\n    fi\n    return 0\n}\n\ncheck_pre_reqs() {\n    eval $invocation\n\n    if [ \"${DOTNET_INSTALL_SKIP_PREREQS:-}\" = \"1\" ]; then\n        return 0\n    fi\n\n    if [ \"$(uname)\" = \"Linux\" ]; then\n        if [ ! -x \"$(command -v ldconfig)\" ]; then\n            echo \"ldconfig is not in PATH, trying /sbin/ldconfig.\"\n            LDCONFIG_COMMAND=\"/sbin/ldconfig\"\n        else\n            LDCONFIG_COMMAND=\"ldconfig\"\n        fi\n\n        local librarypath=${LD_LIBRARY_PATH:-}\n        LDCONFIG_COMMAND=\"$LDCONFIG_COMMAND -NXv ${librarypath//:/ }\"\n\n        [ -z \"$($LDCONFIG_COMMAND 2>/dev/null | grep libunwind)\" ] && say_warning \"Unable to locate libunwind. Probable prerequisite missing; please install libunwind.\"\n        [ -z \"$($LDCONFIG_COMMAND 2>/dev/null | grep libssl)\" ] && say_warning \"Unable to locate libssl. Probable prerequisite missing; please install libssl.\"\n        [ -z \"$($LDCONFIG_COMMAND 2>/dev/null | grep libicu)\" ] && say_warning \"Unable to locate libicu. Probable prerequisite missing; please install libicu.\"\n        [ -z \"$($LDCONFIG_COMMAND 2>/dev/null | grep -F libcurl.so)\" ] && say_warning \"Unable to locate libcurl. Probable prerequisite missing; please install libcurl.\"\n    fi\n\n    return 0\n}\n\n# args:\n# input - $1\nto_lowercase() {\n    #eval $invocation\n\n    echo \"$1\" | tr '[:upper:]' '[:lower:]'\n    return 0\n}\n\n# args:\n# input - $1\nremove_trailing_slash() {\n    #eval $invocation\n\n    local input=\"${1:-}\"\n    echo \"${input%/}\"\n    return 0\n}\n\n# args:\n# input - $1\nremove_beginning_slash() {\n    #eval $invocation\n\n    local input=\"${1:-}\"\n    echo \"${input#/}\"\n    return 0\n}\n\n# args:\n# root_path - $1\n# child_path - $2 - this parameter can be empty\ncombine_paths() {\n    eval $invocation\n\n    # TODO: Consider making it work with any number of paths. For now:\n    if [ ! -z \"${3:-}\" ]; then\n        say_err \"combine_paths: Function takes two parameters.\"\n        return 1\n    fi\n\n    local root_path=\"$(remove_trailing_slash \"$1\")\"\n    local child_path=\"$(remove_beginning_slash \"${2:-}\")\"\n    say_verbose \"combine_paths: root_path=$root_path\"\n    say_verbose \"combine_paths: child_path=$child_path\"\n    echo \"$root_path/$child_path\"\n    return 0\n}\n\nget_machine_architecture() {\n    eval $invocation\n\n    if command -v uname > /dev/null; then\n        CPUName=$(uname -m)\n        case $CPUName in\n        armv7l)\n            echo \"arm\"\n            return 0\n            ;;\n        aarch64)\n            echo \"arm64\"\n            return 0\n            ;;\n        esac\n    fi\n\n    # Always default to 'x64'\n    echo \"x64\"\n    return 0\n}\n\n# args:\n# architecture - $1\nget_normalized_architecture_from_architecture() {\n    eval $invocation\n\n    local architecture=\"$(to_lowercase \"$1\")\"\n    case \"$architecture\" in\n        \\<auto\\>)\n            echo \"$(get_normalized_architecture_from_architecture \"$(get_machine_architecture)\")\"\n            return 0\n            ;;\n        amd64|x64)\n            echo \"x64\"\n            return 0\n            ;;\n        arm)\n            echo \"arm\"\n            return 0\n            ;;\n        arm64)\n            echo \"arm64\"\n            return 0\n            ;;\n    esac\n\n    say_err \"Architecture \\`$architecture\\` not supported. If you think this is a bug, please report it at https://github.com/dotnet/cli/issues\"\n    return 1\n}\n\n# version_info is a conceptual two line string representing commit hash and 4-part version\n# format:\n# Line 1: # commit_hash\n# Line 2: # 4-part version\n\n# args:\n# version_text - stdin\nget_version_from_version_info() {\n    eval $invocation\n\n    cat | tail -n 1 | sed 's/\\r$//'\n    return 0\n}\n\n# args:\n# version_text - stdin\nget_commit_hash_from_version_info() {\n    eval $invocation\n\n    cat | head -n 1 | sed 's/\\r$//'\n    return 0\n}\n\n# args:\n# install_root - $1\n# relative_path_to_package - $2\n# specific_version - $3\nis_dotnet_package_installed() {\n    eval $invocation\n\n    local install_root=\"$1\"\n    local relative_path_to_package=\"$2\"\n    local specific_version=\"${3//[$'\\t\\r\\n']}\"\n\n    local dotnet_package_path=\"$(combine_paths \"$(combine_paths \"$install_root\" \"$relative_path_to_package\")\" \"$specific_version\")\"\n    say_verbose \"is_dotnet_package_installed: dotnet_package_path=$dotnet_package_path\"\n\n    if [ -d \"$dotnet_package_path\" ]; then\n        return 0\n    else\n        return 1\n    fi\n}\n\n# args:\n# azure_feed - $1\n# channel - $2\n# normalized_architecture - $3\n# coherent - $4\nget_latest_version_info() {\n    eval $invocation\n\n    local azure_feed=\"$1\"\n    local channel=\"$2\"\n    local normalized_architecture=\"$3\"\n    local coherent=\"$4\"\n\n    local version_file_url=null\n    if [[ \"$runtime\" == \"dotnet\" ]]; then\n        version_file_url=\"$uncached_feed/Runtime/$channel/latest.version\"\n    elif [[ \"$runtime\" == \"aspnetcore\" ]]; then\n        version_file_url=\"$uncached_feed/aspnetcore/Runtime/$channel/latest.version\"\n    elif [ -z \"$runtime\" ]; then\n        if [ \"$coherent\" = true ]; then\n            version_file_url=\"$uncached_feed/Sdk/$channel/latest.coherent.version\"\n        else\n            version_file_url=\"$uncached_feed/Sdk/$channel/latest.version\"\n        fi\n    else\n        say_err \"Invalid value for \\$runtime\"\n        return 1\n    fi\n    say_verbose \"get_latest_version_info: latest url: $version_file_url\"\n\n    download \"$version_file_url\"\n    return $?\n}\n\n# args:\n# azure_feed - $1\n# channel - $2\n# normalized_architecture - $3\n# version - $4\nget_specific_version_from_version() {\n    eval $invocation\n\n    local azure_feed=\"$1\"\n    local channel=\"$2\"\n    local normalized_architecture=\"$3\"\n    local version=\"$(to_lowercase \"$4\")\"\n\n    case \"$version\" in\n        latest)\n            local version_info\n            version_info=\"$(get_latest_version_info \"$azure_feed\" \"$channel\" \"$normalized_architecture\" false)\" || return 1\n            say_verbose \"get_specific_version_from_version: version_info=$version_info\"\n            echo \"$version_info\" | get_version_from_version_info\n            return 0\n            ;;\n        coherent)\n            local version_info\n            version_info=\"$(get_latest_version_info \"$azure_feed\" \"$channel\" \"$normalized_architecture\" true)\" || return 1\n            say_verbose \"get_specific_version_from_version: version_info=$version_info\"\n            echo \"$version_info\" | get_version_from_version_info\n            return 0\n            ;;\n        *)\n            echo \"$version\"\n            return 0\n            ;;\n    esac\n}\n\n# args:\n# azure_feed - $1\n# channel - $2\n# normalized_architecture - $3\n# specific_version - $4\nconstruct_download_link() {\n    eval $invocation\n\n    local azure_feed=\"$1\"\n    local channel=\"$2\"\n    local normalized_architecture=\"$3\"\n    local specific_version=\"${4//[$'\\t\\r\\n']}\"\n\n    local osname\n    osname=\"$(get_current_os_name)\" || return 1\n\n    local download_link=null\n    if [[ \"$runtime\" == \"dotnet\" ]]; then\n        download_link=\"$azure_feed/Runtime/$specific_version/dotnet-runtime-$specific_version-$osname-$normalized_architecture.tar.gz\"\n    elif [[ \"$runtime\" == \"aspnetcore\" ]]; then\n        download_link=\"$azure_feed/aspnetcore/Runtime/$specific_version/aspnetcore-runtime-$specific_version-$osname-$normalized_architecture.tar.gz\"\n    elif [ -z \"$runtime\" ]; then\n        download_link=\"$azure_feed/Sdk/$specific_version/dotnet-sdk-$specific_version-$osname-$normalized_architecture.tar.gz\"\n    else\n        return 1\n    fi\n\n    echo \"$download_link\"\n    return 0\n}\n\n# args:\n# azure_feed - $1\n# channel - $2\n# normalized_architecture - $3\n# specific_version - $4\nconstruct_legacy_download_link() {\n    eval $invocation\n\n    local azure_feed=\"$1\"\n    local channel=\"$2\"\n    local normalized_architecture=\"$3\"\n    local specific_version=\"${4//[$'\\t\\r\\n']}\"\n\n    local distro_specific_osname\n    distro_specific_osname=\"$(get_legacy_os_name)\" || return 1\n\n    local legacy_download_link=null\n    if [[ \"$runtime\" == \"dotnet\" ]]; then\n        legacy_download_link=\"$azure_feed/Runtime/$specific_version/dotnet-$distro_specific_osname-$normalized_architecture.$specific_version.tar.gz\"\n    elif [ -z \"$runtime\" ]; then\n        legacy_download_link=\"$azure_feed/Sdk/$specific_version/dotnet-dev-$distro_specific_osname-$normalized_architecture.$specific_version.tar.gz\"\n    else\n        return 1\n    fi\n\n    echo \"$legacy_download_link\"\n    return 0\n}\n\nget_user_install_path() {\n    eval $invocation\n\n    if [ ! -z \"${DOTNET_INSTALL_DIR:-}\" ]; then\n        echo \"$DOTNET_INSTALL_DIR\"\n    else\n        echo \"$HOME/.dotnet\"\n    fi\n    return 0\n}\n\n# args:\n# install_dir - $1\nresolve_installation_path() {\n    eval $invocation\n\n    local install_dir=$1\n    if [ \"$install_dir\" = \"<auto>\" ]; then\n        local user_install_path=\"$(get_user_install_path)\"\n        say_verbose \"resolve_installation_path: user_install_path=$user_install_path\"\n        echo \"$user_install_path\"\n        return 0\n    fi\n\n    echo \"$install_dir\"\n    return 0\n}\n\n# args:\n# install_root - $1\nget_installed_version_info() {\n    eval $invocation\n\n    local install_root=\"$1\"\n    local version_file=\"$(combine_paths \"$install_root\" \"$local_version_file_relative_path\")\"\n    say_verbose \"Local version file: $version_file\"\n    if [ ! -z \"$version_file\" ] | [ -r \"$version_file\" ]; then\n        local version_info=\"$(cat \"$version_file\")\"\n        echo \"$version_info\"\n        return 0\n    fi\n\n    say_verbose \"Local version file not found.\"\n    return 0\n}\n\n# args:\n# relative_or_absolute_path - $1\nget_absolute_path() {\n    eval $invocation\n\n    local relative_or_absolute_path=$1\n    echo \"$(cd \"$(dirname \"$1\")\" && pwd -P)/$(basename \"$1\")\"\n    return 0\n}\n\n# args:\n# input_files - stdin\n# root_path - $1\n# out_path - $2\n# override - $3\ncopy_files_or_dirs_from_list() {\n    eval $invocation\n\n    local root_path=\"$(remove_trailing_slash \"$1\")\"\n    local out_path=\"$(remove_trailing_slash \"$2\")\"\n    local override=\"$3\"\n    local osname=\"$(get_current_os_name)\"\n    local override_switch=$(\n        if [ \"$override\" = false ]; then\n            if [[ \"$osname\" == \"linux-musl\" ]]; then\n                printf -- \"-u\";\n            else\n                printf -- \"-n\";\n            fi\n        fi)\n\n    cat | uniq | while read -r file_path; do\n        local path=\"$(remove_beginning_slash \"${file_path#$root_path}\")\"\n        local target=\"$out_path/$path\"\n        if [ \"$override\" = true ] || (! ([ -d \"$target\" ] || [ -e \"$target\" ])); then\n            mkdir -p \"$out_path/$(dirname \"$path\")\"\n            cp -R $override_switch \"$root_path/$path\" \"$target\"\n        fi\n    done\n}\n\n# args:\n# zip_path - $1\n# out_path - $2\nextract_dotnet_package() {\n    eval $invocation\n\n    local zip_path=\"$1\"\n    local out_path=\"$2\"\n\n    local temp_out_path=\"$(mktemp -d \"$temporary_file_template\")\"\n\n    local failed=false\n    tar -xzf \"$zip_path\" -C \"$temp_out_path\" > /dev/null || failed=true\n\n    local folders_with_version_regex='^.*/[0-9]+\\.[0-9]+[^/]+/'\n    find \"$temp_out_path\" -type f | grep -Eo \"$folders_with_version_regex\" | sort | copy_files_or_dirs_from_list \"$temp_out_path\" \"$out_path\" false\n    find \"$temp_out_path\" -type f | grep -Ev \"$folders_with_version_regex\" | copy_files_or_dirs_from_list \"$temp_out_path\" \"$out_path\" \"$override_non_versioned_files\"\n\n    rm -rf \"$temp_out_path\"\n\n    if [ \"$failed\" = true ]; then\n        say_err \"Extraction failed\"\n        return 1\n    fi\n}\n\n# args:\n# remote_path - $1\n# [out_path] - $2 - stdout if not provided\ndownload() {\n    eval $invocation\n\n    local remote_path=\"$1\"\n    local out_path=\"${2:-}\"\n\n    local failed=false\n    if machine_has \"curl\"; then\n        downloadcurl \"$remote_path\" \"$out_path\" || failed=true\n    elif machine_has \"wget\"; then\n        downloadwget \"$remote_path\" \"$out_path\" || failed=true\n    else\n        failed=true\n    fi\n    if [ \"$failed\" = true ]; then\n        say_verbose \"Download failed: $remote_path\"\n        return 1\n    fi\n    return 0\n}\n\ndownloadcurl() {\n    eval $invocation\n    local remote_path=\"$1\"\n    local out_path=\"${2:-}\"\n\n    # Append feed_credential as late as possible before calling curl to avoid logging feed_credential\n    remote_path=\"${remote_path}${feed_credential}\"\n\n    local failed=false\n    if [ -z \"$out_path\" ]; then\n        curl --retry 10 -sSL -f --create-dirs \"$remote_path\" || failed=true\n    else\n        curl --retry 10 -sSL -f --create-dirs -o \"$out_path\" \"$remote_path\" || failed=true\n    fi\n    if [ \"$failed\" = true ]; then\n        say_verbose \"Curl download failed\"\n        return 1\n    fi\n    return 0\n}\n\ndownloadwget() {\n    eval $invocation\n    local remote_path=\"$1\"\n    local out_path=\"${2:-}\"\n\n    # Append feed_credential as late as possible before calling wget to avoid logging feed_credential\n    remote_path=\"${remote_path}${feed_credential}\"\n\n    local failed=false\n    if [ -z \"$out_path\" ]; then\n        wget -q --tries 10 -O - \"$remote_path\" || failed=true\n    else\n        wget --tries 10 -O \"$out_path\" \"$remote_path\" || failed=true\n    fi\n    if [ \"$failed\" = true ]; then\n        say_verbose \"Wget download failed\"\n        return 1\n    fi\n    return 0\n}\n\ncalculate_vars() {\n    eval $invocation\n    valid_legacy_download_link=true\n\n    normalized_architecture=\"$(get_normalized_architecture_from_architecture \"$architecture\")\"\n    say_verbose \"normalized_architecture=$normalized_architecture\"\n\n    specific_version=\"$(get_specific_version_from_version \"$azure_feed\" \"$channel\" \"$normalized_architecture\" \"$version\")\"\n    say_verbose \"specific_version=$specific_version\"\n    if [ -z \"$specific_version\" ]; then\n        say_err \"Could not get version information.\"\n        return 1\n    fi\n\n    download_link=\"$(construct_download_link \"$azure_feed\" \"$channel\" \"$normalized_architecture\" \"$specific_version\")\"\n    say_verbose \"download_link=$download_link\"\n\n    legacy_download_link=\"$(construct_legacy_download_link \"$azure_feed\" \"$channel\" \"$normalized_architecture\" \"$specific_version\")\" || valid_legacy_download_link=false\n\n    if [ \"$valid_legacy_download_link\" = true ]; then\n        say_verbose \"legacy_download_link=$legacy_download_link\"\n    else\n        say_verbose \"Cound not construct a legacy_download_link; omitting...\"\n    fi\n\n    install_root=\"$(resolve_installation_path \"$install_dir\")\"\n    say_verbose \"install_root=$install_root\"\n}\n\ninstall_dotnet() {\n    eval $invocation\n    local download_failed=false\n    local asset_name=''\n    local asset_relative_path=''\n\n    if [[ \"$runtime\" == \"dotnet\" ]]; then\n        asset_relative_path=\"shared/Microsoft.NETCore.App\"\n        asset_name=\".NET Core Runtime\"\n    elif [[ \"$runtime\" == \"aspnetcore\" ]]; then\n        asset_relative_path=\"shared/Microsoft.AspNetCore.App\"\n        asset_name=\"ASP.NET Core Runtime\"\n    elif [ -z \"$runtime\" ]; then\n        asset_relative_path=\"sdk\"\n        asset_name=\".NET Core SDK\"\n    else\n        say_err \"Invalid value for \\$runtime\"\n        return 1\n    fi\n\n    #  Check if the SDK version is already installed.\n    if is_dotnet_package_installed \"$install_root\" \"$asset_relative_path\" \"$specific_version\"; then\n        say \"$asset_name version $specific_version is already installed.\"\n        return 0\n    fi\n\n    mkdir -p \"$install_root\"\n    zip_path=\"$(mktemp \"$temporary_file_template\")\"\n    say_verbose \"Zip path: $zip_path\"\n\n    say \"Downloading link: $download_link\"\n\n    # Failures are normal in the non-legacy case for ultimately legacy downloads.\n    # Do not output to stderr, since output to stderr is considered an error.\n    download \"$download_link\" \"$zip_path\" 2>&1 || download_failed=true\n\n    #  if the download fails, download the legacy_download_link\n    if [ \"$download_failed\" = true ]; then\n        say \"Cannot download: $download_link\"\n\n        if [ \"$valid_legacy_download_link\" = true ]; then\n            download_failed=false\n            download_link=\"$legacy_download_link\"\n            zip_path=\"$(mktemp \"$temporary_file_template\")\"\n            say_verbose \"Legacy zip path: $zip_path\"\n            say \"Downloading legacy link: $download_link\"\n            download \"$download_link\" \"$zip_path\" 2>&1 || download_failed=true\n        fi\n    fi\n\n    if [ \"$download_failed\" = true ]; then\n        say_err \"Could not download $asset_name version $specific_version\"\n        return 1\n    fi\n\n    say \"Extracting zip from $download_link\"\n    extract_dotnet_package \"$zip_path\" \"$install_root\"\n\n    #  Check if the SDK version is now installed; if not, fail the installation.\n    if ! is_dotnet_package_installed \"$install_root\" \"$asset_relative_path\" \"$specific_version\"; then\n        say_err \"$asset_name version $specific_version failed to install with an unknown error.\"\n        return 1\n    fi\n\n    return 0\n}\n\nlocal_version_file_relative_path=\"/.version\"\nbin_folder_relative_path=\"\"\ntemporary_file_template=\"${TMPDIR:-/tmp}/dotnet.XXXXXXXXX\"\n\nchannel=\"LTS\"\nversion=\"Latest\"\ninstall_dir=\"<auto>\"\narchitecture=\"<auto>\"\ndry_run=false\nno_path=false\nazure_feed=\"https://dotnetcli.azureedge.net/dotnet\"\nuncached_feed=\"https://dotnetcli.blob.core.windows.net/dotnet\"\nfeed_credential=\"\"\nverbose=false\nruntime=\"\"\nruntime_id=\"\"\noverride_non_versioned_files=true\n\nwhile [ $# -ne 0 ]\ndo\n    name=\"$1\"\n    case \"$name\" in\n        -c|--channel|-[Cc]hannel)\n            shift\n            channel=\"$1\"\n            ;;\n        -v|--version|-[Vv]ersion)\n            shift\n            version=\"$1\"\n            ;;\n        -i|--install-dir|-[Ii]nstall[Dd]ir)\n            shift\n            install_dir=\"$1\"\n            ;;\n        --arch|--architecture|-[Aa]rch|-[Aa]rchitecture)\n            shift\n            architecture=\"$1\"\n            ;;\n        --shared-runtime|-[Ss]hared[Rr]untime)\n            say_warning \"The --shared-runtime flag is obsolete and may be removed in a future version of this script. The recommended usage is to specify '--runtime dotnet'.\"\n            if [ -z \"$runtime\" ]; then\n                runtime=\"dotnet\"\n            fi\n            ;;\n        --runtime|-[Rr]untime)\n            shift\n            runtime=\"$1\"\n            if [[ \"$runtime\" != \"dotnet\" ]] && [[ \"$runtime\" != \"aspnetcore\" ]]; then\n                say_err \"Unsupported value for --runtime: '$1'. Valid values are 'dotnet' and 'aspnetcore'.\"\n                exit 1\n            fi\n            ;;\n        --dry-run|-[Dd]ry[Rr]un)\n            dry_run=true\n            ;;\n        --no-path|-[Nn]o[Pp]ath)\n            no_path=true\n            ;;\n        --verbose|-[Vv]erbose)\n            verbose=true\n            ;;\n        --azure-feed|-[Aa]zure[Ff]eed)\n            shift\n            azure_feed=\"$1\"\n            ;;\n        --uncached-feed|-[Uu]ncached[Ff]eed)\n            shift\n            uncached_feed=\"$1\"\n            ;;\n        --feed-credential|-[Ff]eed[Cc]redential)\n            shift\n            feed_credential=\"$1\"\n            ;;\n        --runtime-id|-[Rr]untime[Ii]d)\n            shift\n            runtime_id=\"$1\"\n            ;;\n        --skip-non-versioned-files|-[Ss]kip[Nn]on[Vv]ersioned[Ff]iles)\n            override_non_versioned_files=false\n            ;;\n        -?|--?|-h|--help|-[Hh]elp)\n            script_name=\"$(basename \"$0\")\"\n            echo \".NET Tools Installer\"\n            echo \"Usage: $script_name [-c|--channel <CHANNEL>] [-v|--version <VERSION>] [-p|--prefix <DESTINATION>]\"\n            echo \"       $script_name -h|-?|--help\"\n            echo \"\"\n            echo \"$script_name is a simple command line interface for obtaining dotnet cli.\"\n            echo \"\"\n            echo \"Options:\"\n            echo \"  -c,--channel <CHANNEL>         Download from the channel specified, Defaults to \\`$channel\\`.\"\n            echo \"      -Channel\"\n            echo \"          Possible values:\"\n            echo \"          - Current - most current release\"\n            echo \"          - LTS - most current supported release\"\n            echo \"          - 2-part version in a format A.B - represents a specific release\"\n            echo \"              examples: 2.0; 1.0\"\n            echo \"          - Branch name\"\n            echo \"              examples: release/2.0.0; Master\"\n            echo \"  -v,--version <VERSION>         Use specific VERSION, Defaults to \\`$version\\`.\"\n            echo \"      -Version\"\n            echo \"          Possible values:\"\n            echo \"          - latest - most latest build on specific channel\"\n            echo \"          - coherent - most latest coherent build on specific channel\"\n            echo \"              coherent applies only to SDK downloads\"\n            echo \"          - 3-part version in a format A.B.C - represents specific version of build\"\n            echo \"              examples: 2.0.0-preview2-006120; 1.1.0\"\n            echo \"  -i,--install-dir <DIR>             Install under specified location (see Install Location below)\"\n            echo \"      -InstallDir\"\n            echo \"  --architecture <ARCHITECTURE>      Architecture of dotnet binaries to be installed, Defaults to \\`$architecture\\`.\"\n            echo \"      --arch,-Architecture,-Arch\"\n            echo \"          Possible values: x64, arm, and arm64\"\n            echo \"  --runtime <RUNTIME>                Installs a shared runtime only, without the SDK.\"\n            echo \"      -Runtime\"\n            echo \"          Possible values:\"\n            echo \"          - dotnet     - the Microsoft.NETCore.App shared runtime\"\n            echo \"          - aspnetcore - the Microsoft.AspNetCore.App shared runtime\"\n            echo \"  --skip-non-versioned-files         Skips non-versioned files if they already exist, such as the dotnet executable.\"\n            echo \"      -SkipNonVersionedFiles\"\n            echo \"  --dry-run,-DryRun                  Do not perform installation. Display download link.\"\n            echo \"  --no-path, -NoPath                 Do not set PATH for the current process.\"\n            echo \"  --verbose,-Verbose                 Display diagnostics information.\"\n            echo \"  --azure-feed,-AzureFeed            Azure feed location. Defaults to $azure_feed, This parameter typically is not changed by the user.\"\n            echo \"  --uncached-feed,-UncachedFeed      Uncached feed location. This parameter typically is not changed by the user.\"\n            echo \"  --feed-credential,-FeedCredential  Azure feed shared access token. This parameter typically is not specified.\"\n            echo \"  --runtime-id                       Installs the .NET Tools for the given platform (use linux-x64 for portable linux).\"\n            echo \"      -RuntimeId\"\n            echo \"  -?,--?,-h,--help,-Help             Shows this help message\"\n            echo \"\"\n            echo \"Obsolete parameters:\"\n            echo \"  --shared-runtime                   The recommended alternative is '--runtime dotnet'.\"\n            echo \"      -SharedRuntime                 Installs just the shared runtime bits, not the entire SDK.\"\n            echo \"\"\n            echo \"Install Location:\"\n            echo \"  Location is chosen in following order:\"\n            echo \"    - --install-dir option\"\n            echo \"    - Environmental variable DOTNET_INSTALL_DIR\"\n            echo \"    - $HOME/.dotnet\"\n            exit 0\n            ;;\n        *)\n            say_err \"Unknown argument \\`$name\\`\"\n            exit 1\n            ;;\n    esac\n\n    shift\ndone\n\ncheck_min_reqs\ncalculate_vars\n\nif [ \"$dry_run\" = true ]; then\n    say \"Payload URL: $download_link\"\n    if [ \"$valid_legacy_download_link\" = true ]; then\n        say \"Legacy payload URL: $legacy_download_link\"\n    fi\n    say \"Repeatable invocation: ./$(basename \"$0\") --version $specific_version --channel $channel --install-dir $install_dir\"\n    exit 0\nfi\n\ncheck_pre_reqs\ninstall_dotnet\n\nbin_path=\"$(get_absolute_path \"$(combine_paths \"$install_root\" \"$bin_folder_relative_path\")\")\"\nif [ \"$no_path\" = false ]; then\n    say \"Adding to current process PATH: \\`$bin_path\\`. Note: This change will be visible only when sourcing script.\"\n    export PATH=\"$bin_path\":\"$PATH\"\nelse\n    say \"Binaries of dotnet can be found in $bin_path\"\nfi\n\nsay \"Installation finished successfully.\""
        },
        {
          "name": "eng",
          "type": "tree",
          "content": null
        },
        {
          "name": "generateMsiFiles.ps1",
          "type": "blob",
          "size": 2.134765625,
          "content": "$baseDir = Get-Location\r\n\r\nWrite-Host \"Generating MSI files\"\r\n\r\n# Add WiX to PATH\r\nif (-not (@($env:Path -split \";\") -contains $env:WIX))\r\n{\r\n    # Check if the Wix path points to the bin folder\r\n    if ((Split-Path $env:WIX -Leaf) -ne \"bin\")\r\n    {\r\n        $env:Path += \";$env:WIX\\bin\"\r\n    }\r\n    else\r\n    {\r\n        $env:Path += \";$env:WIX\"\r\n    }\r\n}\r\n\r\n# Get runtime version\r\n$artifactsPath = \"$baseDir\\artifacts\"\r\n$buildDir = \"$baseDir\\build\"\r\n$cli = Get-ChildItem -Path $artifactsPath -Include func.dll -Recurse | Select-Object -First 1\r\n$cliVersion = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($cli).FileVersion\r\n\r\n# Generate MSI installers for Windows\r\n# TODO: add 'arm64' to the below array once a production-ready version of the WiX toolset supporting\r\n# it is released. See https://github.com/Azure/azure-functions-core-tools/issues/3122\r\n@('x64', 'x86') | ForEach-Object { \r\n    $platform = $_\r\n    $targetDir = \"$artifactsPath\\win-$platform\"\r\n\r\n    Copy-Item \"$buildDir\\icon.ico\" -Destination $targetDir\r\n    Copy-Item \"$buildDir\\license.rtf\" -Destination $targetDir\r\n    Copy-Item \"$buildDir\\installbanner.bmp\" -Destination $targetDir\r\n    Copy-Item \"$buildDir\\installdialog.bmp\" -Destination $targetDir\r\n    Set-Location $targetDir\r\n\r\n    $masterWxsName = \"funcinstall\"\r\n    $fragmentName = \"$platform-frag\"\r\n    $msiName = \"func-cli-$cliVersion-$platform\"\r\n\r\n    $masterWxsPath = \"$buildDir\\$masterWxsName.wxs\"\r\n    $fragmentPath = \"$buildDir\\$fragmentName.wxs\"\r\n    $msiPath = \"$artifactsPath\\$msiName.msi\"\r\n\r\n    & { heat dir '.' -cg FuncHost -dr INSTALLDIR -gg -ke -out $fragmentPath -srd -sreg -template fragment -var var.Source }\r\n    & { candle -arch $platform -dPlatform=\"$platform\" -dSource='.' -dProductVersion=\"$cliVersion\" $masterWxsPath $fragmentPath }\r\n    & { light -ext \"WixUIExtension\" -out $msiPath -sice:\"ICE61\" \"$masterWxsName.wixobj\" \"$fragmentName.wixobj\" }\r\n    \r\n    # Check that the .msi files are actually present\r\n    if (-not(Test-Path -Path $msiPath))\r\n    {\r\n        throw \"$msiPath not found.\"\r\n    }\r\n\r\n    Set-Location $baseDir\r\n    Get-ChildItem -Path $targetDir -Recurse | Remove-Item -Force -Recurse -ea SilentlyContinue\r\n}"
        },
        {
          "name": "generateSha.ps1",
          "type": "blob",
          "size": 0.603515625,
          "content": "function GenerateSha([string]$filePath,[string]$artifactsPath, [string]$shaFileName)\r\n{\r\n$sha = (Get-FileHash $filePath).Hash.ToLower()\r\n$shaPath = Join-Path $artifactsPath \"$shaFileName.sha2\"\r\nOut-File -InputObject $sha -Encoding ascii -FilePath $shaPath -NoNewline\r\n}\r\n\r\nSet-Location \".\\build\"\r\n\r\n$artifactsPath = Resolve-Path \"..\\artifacts\\\"\r\n$zipFilesSearchPath = Join-Path $artifactsPath \"*.zip\"\r\n$zipFiles  = Get-ChildItem -File $zipFilesSearchPath\r\n\r\nforeach($zipFile in $zipFiles)\r\n{\r\n    $zipFullPath = $zipFile.FullName\r\n    $fileName = $zipFile.Name\r\n    GenerateSha $zipFullPath $artifactsPath $fileName\r\n}"
        },
        {
          "name": "host",
          "type": "tree",
          "content": null
        },
        {
          "name": "pipelineUtilities.psm1",
          "type": "blob",
          "size": 5.5458984375,
          "content": "#\n# Copyright (c) Microsoft. All rights reserved.\n# Licensed under the MIT license. See LICENSE file in the project root for full license information.\n#\n\n#Requires -Version 6.0\n\nusing namespace System.Runtime.InteropServices\n\n$DLL_NAME = \"Microsoft.ManifestTool.dll\"\n$MANIFESTOOLNAME = \"ManifestTool\"\n$MANIFESTOOL_DIRECTORY = Join-Path $PSScriptRoot $MANIFESTOOLNAME\n$MANIFEST_TOOL_PATH = \"$MANIFESTOOL_DIRECTORY/$DLL_NAME\"\n\nfunction Get-ManifestToolPath\n{\n    if (Test-Path $MANIFEST_TOOL_PATH)\n    {\n        return $MANIFEST_TOOL_PATH\n    }\n    throw \"The SBOM Manifest Tool is not installed. Please run Install-SBOMUtil -SBOMUtilSASUrl <SASUrl>\"\n}\n\nfunction Install-SBOMUtil\n{\n    param(\n        [string]\n        $SBOMUtilSASUrl\n    )\n    \n    if ([string]::IsNullOrEmpty($SBOMUtilSASUrl))\n    {\n        throw \"The `$SBOMUtilSASUrl parameter cannot be null or empty when specifying `$(addSBOM)\"\n    }\n\n    Write-Host \"Installing $MANIFESTOOLNAME...\"\n    Remove-Item -Recurse -Force $MANIFESTOOL_DIRECTORY -ErrorAction Ignore\n\n    Invoke-RestMethod -Uri $SBOMUtilSASUrl -OutFile \"$MANIFESTOOL_DIRECTORY.zip\"\n    Expand-Archive \"$MANIFESTOOL_DIRECTORY.zip\" -DestinationPath $MANIFESTOOL_DIRECTORY\n    \n    if (-not (Test-Path $MANIFEST_TOOL_PATH))\n    {\n        throw \"$MANIFESTOOL_DIRECTORY does not contain '$DLL_NAME'\"\n    }\n\n    Write-Host 'Done.'\n\n    return $MANIFEST_TOOL_PATH\n}\n\n$DotnetSDKVersionRequirements = @{\n\n    # .NET SDK 3.1 is required by the Microsoft.ManifestTool.dll tool\n    '2.1' = @{\n        MinimalPatch = '818'\n        DefaultPatch = '818'\n    }\n\n    # .NET SDK 3.1 is required by the Microsoft.ManifestTool.dll tool\n    '3.1' = @{\n        MinimalPatch = '415'\n        DefaultPatch = '415'\n    }\n\n    '6.0' = @{\n        MinimalPatch = '417'\n        DefaultPatch = '417'\n    }\n\n    '8.0' = @{\n        MinimalPatch = '204'\n        DefaultPatch = '204'\n    }\n    # Update .NET 9 patch once .NET 9 has been released out of preview\n    '9.0' = @{\n        MinimalPatch = '100-rc.1.24452.12'\n        DefaultPatch = '100-rc.1.24452.12'\n\n    }\n}\n\nfunction AddLocalDotnetDirPath {\n    $LocalDotnetDirPath = if ($IsWindows) { \"$env:ProgramFiles/dotnet\" } else { \"/usr/share/dotnet\" }\n    if (($env:PATH -split [IO.Path]::PathSeparator) -notcontains $LocalDotnetDirPath) {\n        $env:PATH = $LocalDotnetDirPath + [IO.Path]::PathSeparator + $env:PATH\n    }\n}\n\nfunction Find-DotnetVersionsToInstall\n{\n    AddLocalDotnetDirPath\n    $listSdksOutput = dotnet --list-sdks\n    $installedDotnetSdks = $listSdksOutput | ForEach-Object { $_.Split(\" \")[0] }\n    Write-Host \"Detected dotnet SDKs: $($installedDotnetSdks -join ', ')\"\n    $missingVersions = [System.Collections.Generic.List[string]]::new()\n    foreach ($majorMinorVersion in $DotnetSDKVersionRequirements.Keys) {\n        $minimalVersion = \"$majorMinorVersion.$($DotnetSDKVersionRequirements[$majorMinorVersion].MinimalPatch)\"\n        $firstAcceptable = $installedDotnetSdks |\n                                Where-Object { $_.StartsWith(\"$majorMinorVersion.\") } |\n                                Where-Object { [System.Management.Automation.SemanticVersion]::new($_) -ge [System.Management.Automation.SemanticVersion]::new($minimalVersion) } |\n                                Select-Object -First 1\n        if ($firstAcceptable) {\n            Write-Host \"Found dotnet SDK $firstAcceptable for .NET Core $majorMinorVersion.\"\n        }                               \n        else {\n            Write-Host \"Cannot find the dotnet SDK for .NET Core $majorMinorVersion. Version $minimalVersion or higher is required.\"\n            $missingVersions.Add(\"$majorMinorVersion.$($DotnetSDKVersionRequirements[$majorMinorVersion].DefaultPatch)\")\n        }\n    }\n    return $missingVersions\n}\n\n$installScript = if ($IsWindows) { \"dotnet-install.ps1\" } else { \"dotnet-install.sh\" }\n$obtainUrl = \"https://raw.githubusercontent.com/dotnet/cli/master/scripts/obtain\"\n\nfunction Install-DotnetVersion($Version,$Channel) {\n    if ((Test-Path  $installScript) -ne $True) {\n        Write-Host \"Downloading dotnet-install script\"\n        Invoke-WebRequest -Uri $obtainUrl/$installScript -OutFile $installScript\n    }\n\n    Write-Host \"Installing dotnet SDK version $Version\"\n    if ($IsWindows) {\n        & .\\$installScript -InstallDir \"$env:ProgramFiles/dotnet\" -Channel $Channel -Version $Version\n        # Installing .NET into x86 directory since the E2E App runs the tests on x86 and looks for the specified framework there\n        & .\\$installScript -InstallDir \"$env:ProgramFiles (x86)/dotnet\" -Channel $Channel -Version $Version -Architecture x86\n    } else {\n        bash ./$installScript --install-dir /usr/share/dotnet -c $Channel -v $Version\n    }\n}\n\nfunction Install-Dotnet {\n    [CmdletBinding()]\n    param(\n        [string]$Channel = 'release'\n    )\n    try {\n        $versionsToInstall = Find-DotnetVersionsToInstall\n        if ($versionsToInstall.Count -eq 0) {\n            return\n        }\n        foreach ($version in $versionsToInstall) {\n            Install-DotnetVersion -Version $version -Channel $Channel\n        }\n        $listSdksOutput = dotnet --list-sdks\n        $installedDotnetSdks = $listSdksOutput | ForEach-Object { $_.Split(\" \")[0] }\n        Write-Host \"Detected dotnet SDKs: $($installedDotnetSdks -join ', ')\"\n\n        $listRuntimesOutput = dotnet --list-runtimes\n        $installedDotnetRuntimes = $listRuntimesOutput | ForEach-Object { $_.Split(\" \")[1] }\n        Write-Host \"Detected dotnet Runtimes: $($installedDotnetRuntimes -join ', ')\"\n    }\n    finally {\n        if (Test-Path  $installScript) {\n            Remove-Item $installScript -Force -ErrorAction SilentlyContinue\n        }\n    }\n}"
        },
        {
          "name": "publish-scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "repackageBinaries.ps1",
          "type": "blob",
          "size": 4.5390625,
          "content": "Set-Location \".\\build\"\r\nAdd-Type -AssemblyName System.IO.Compression.FileSystem\r\n\r\nfunction Unzip([string]$zipfilePath, [string]$outputpath) {\r\n    try {\r\n        [System.IO.Compression.ZipFile]::ExtractToDirectory($zipfilePath, $outputpath)\r\n        LogSuccess \"Unzipped:$zipfilePath at $outputpath\"\r\n    }\r\n    catch {\r\n        LogErrorAndExit \"Unzip failed for:$zipfilePath\" $_.Exception\r\n    }\r\n}\r\n\r\n\r\nfunction Zip([string]$directoryPath, [string]$zipPath) {\r\n    try {\r\n        LogSuccess \"start zip:$directoryPath to $zipPath\"\r\n\r\n        [System.IO.Compression.ZipFile]::CreateFromDirectory($directoryPath, $zipPath, [System.IO.Compression.CompressionLevel]::Optimal, $false);\r\n        LogSuccess \"Zipped:$directoryPath to $zipPath\"\r\n    }\r\n    catch {\r\n        LogErrorAndExit \"Zip operation failed for:$directoryPath\" $_.Exception\r\n    }\r\n}\r\n\r\n\r\nfunction LogErrorAndExit($errorMessage, $exception) {\r\n    Write-Output $errorMessage\r\n    if ($exception -ne $null) {\r\n        Write-Output $exception|format-list -force\r\n    }    \r\n    Exit 1\r\n}\r\n\r\nfunction LogSuccess($message) {\r\n    Write-Output `n\r\n    Write-Output $message\r\n}\r\n\r\ntry \r\n{\r\n    $artifactsPath = Resolve-Path \"..\\artifacts\\\"\r\n    $tempDirectoryPath = \"..\\artifacts\\temp\\\"\r\n\r\n    if (Test-Path $tempDirectoryPath)\r\n    {\r\n        Remove-Item $tempDirectoryPath -Force -Recurse\r\n    }\r\n\r\n    # Runtimes with signed binaries\r\n    $runtimesIdentifiers = @(\"min.win-arm64\", \"min.win-x86\",\"min.win-x64\", \"osx-arm64\", \"osx-x64\")\r\n    $tempDirectory = New-Item $tempDirectoryPath -ItemType Directory\r\n    LogSuccess \"$tempDirectoryPath created\"\r\n\r\n    # Unzip the coretools artifact to add signed binaries\r\n    foreach($rid in $runtimesIdentifiers)\r\n    {\r\n        $files= Get-ChildItem -Path \"..\\artifacts\\*.zip\"\r\n        foreach($file in $files)\r\n        {\r\n            if ($file.Name.Contains($rid))\r\n            {\r\n                $fileName = [io.path]::GetFileNameWithoutExtension($file.Name)\r\n\r\n                $targetDirectory = Join-Path $tempDirectoryPath $fileName\r\n                $dir = New-Item $targetDirectory -ItemType Directory\r\n                $targetDirectory = Resolve-Path $targetDirectory \r\n                $filePath = Resolve-Path $file.FullName\r\n                Unzip $filePath $targetDirectory       \r\n                   \r\n                # Removing file after extraction\r\n                Remove-Item $filePath\r\n                LogSuccess \"Removed $filePath\"\r\n            }\r\n        }\r\n    }\r\n\r\n    # Store file count before replacing the binaries\r\n    $fileCountBefore = (Get-ChildItem $tempDirectoryPath -Recurse | Measure-Object).Count\r\n\r\n    # copy authenticode signed binaries into extracted directories\r\n    $authenticodeDirectory = \"..\\artifacts\\ToSign\\Authenticode\\\"\r\n    $authenticodeDirectories = Get-ChildItem $authenticodeDirectory -Directory\r\n\r\n    foreach($directory in $authenticodeDirectories)\r\n    {\r\n        $sourcePath = $directory.FullName\r\n        Copy-Item -Path $sourcePath -Destination $tempDirectoryPath -Recurse -Force\r\n    }\r\n\r\n    # copy thirdparty signed directory into extracted directories\r\n    $thirdPathDirectory  = \"..\\artifacts\\ToSign\\ThirdParty\\\"\r\n    $thirdPathDirectories  = Get-ChildItem $thirdPathDirectory -Directory\r\n\r\n    foreach($directory in $thirdPathDirectories)\r\n    {\r\n        $sourcePath = $directory.FullName\r\n        Copy-Item -Path $sourcePath -Destination $tempDirectoryPath -Recurse -Force\r\n    }\r\n\r\n    # mac signing requires the files to be in a zip to sign, so we have to extract the zip before copying over the signed files\r\n    $macZipFiles  = Get-ChildItem \"..\\artifacts\\ToSign\\Mac\\*.zip\"\r\n    foreach($macZipFile in $macZipFiles)\r\n    {\r\n        $macUnzippedDir = Join-Path $macZipFile.DirectoryName $macZipFile.BaseName\r\n        Unzip $macZipFile.FullName $macUnzippedDir\r\n        Copy-Item -Path $macUnzippedDir -Destination $tempDirectoryPath -Recurse -Force\r\n    }\r\n\r\n    $fileCountAfter = (Get-ChildItem $tempDirectoryPath -Recurse | Measure-Object).Count\r\n\r\n    if ($fileCountBefore -ne $fileCountAfter)\r\n    {\r\n        LogErrorAndExit \"File count does not match. File count before copy: $fileCountBefore != file count after copy:$fileCountAfter\" $_.Exception\r\n    }\r\n\r\n    $tempDirectories  = Get-ChildItem $tempDirectoryPath -Directory\r\n    foreach($directory in $tempDirectories)\r\n    {\r\n       $directoryName = $directory.Name\r\n       $zipPath = Join-Path $artifactsPath $directoryName\r\n       $zipPath = $zipPath + \".zip\"\r\n       $directoryPath = $directory.FullName\r\n       Zip $directoryPath $zipPath \r\n    }\r\n    \r\n}\r\ncatch {\r\n    LogErrorAndExit \"Execution Failed\" $_.Exception\r\n}"
        },
        {
          "name": "skipPackagesCve.json",
          "type": "blob",
          "size": 0.0380859375,
          "content": "{\n  \"packages\": [\n    \"DotNetZip\"\n  ]\n}"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "uploadContentToStorageAccount.ps1",
          "type": "blob",
          "size": 5.1064453125,
          "content": "param (\n    [Parameter(Mandatory=$true)]\n    [ValidateNotNullOrEmpty()]\n    [System.String]\n    $StorageAccountName,\n\n    [Parameter(Mandatory=$true)]\n    [ValidateNotNullOrEmpty()]\n    [System.String]\n    $StorageAccountKey,\n\n    [Parameter(Mandatory=$true)]\n    [ValidateNotNullOrEmpty()]\n    [System.String]\n    $SourcePath\n)\n\nfunction WriteLog\n{\n    param (\n        [Parameter(Mandatory=$true)]\n        [ValidateNotNullOrEmpty()]\n        [System.String]\n        $Message,\n\n        [Switch]\n        $Throw\n    )\n\n    $Message = (Get-Date -Format G)  + \" -- $Message\"\n\n    if ($Throw)\n    {\n        throw $Message\n    }\n\n    Write-Host $Message\n}\n\nfunction GetContentType\n{\n    param\n    (\n        [Parameter(Mandatory=$true)]\n        [ValidateNotNullOrEmpty()]\n        [System.String]\n        $FilePath\n    )\n\n    $fileExtension =  [System.IO.Path]::GetExtension($FilePath)\n\n    switch ($fileExtension)\n    {\n        \".txt\" { \"text/plain\" }\n        \".json\" { \"application/json\" }\n        default { \"application/octet-stream\"}\n    }\n}\n\nWriteLog -Message \"Script started.\"\n\n$CONTAINER_NAME = \"builds\"\n$FUNC_RUNTIME_VERSION = '4'\n\nif (-not (Test-Path $SourcePath))\n{\n    throw \"SourcePath '$SourcePath' does not exist.\"\n}\n\nWriteLog \"Validating source path '$SourcePath'.\"\n$filesToUpload = @(Get-ChildItem -Path \"$SourcePath/*.zip\" | ForEach-Object {$_.FullName})\nif ($filesToUpload.Count -eq 0)\n{\n    WriteLog -Message \"'$SourcePath' does not contain any zip files to upload.\" -Throw\n}\n\nif (-not (Get-command New-AzStorageContext -ea SilentlyContinue))\n{\n    WriteLog \"Installing Az.Storage.\"\n    Install-Module Az.Storage -Force -Verbose -AllowClobber -Scope CurrentUser\n}\n\n$context = $null\ntry\n{\n    WriteLog \"Connecting to storage account...\"\n    $context = New-AzStorageContext -StorageAccountName $StorageAccountName -StorageAccountKey $StorageAccountKey -ErrorAction Stop\n}\ncatch\n{\n    $message = \"Failed to authenticate with Azure. Please verify the StorageAccountName and StorageAccountKey. Exception information: $_\"\n    WriteLog -Message $message -Throw\n}\n\n# Validate and read manifest file\n$manifestFileName = \"integrationTestsBuildManifest.json\"\n$manifestFilePath = Join-Path $SourcePath $manifestFileName\n\nif (-not (Test-Path $manifestFilePath))\n{\n    WriteLog -Message \"File '$manifestFilePath' does not exist.\" -Throw\n}\n\n$manifest = $null\ntry\n{\n    WriteLog -Message \"Reading $manifestFileName.\"\n    $manifest = Get-Content $manifestFilePath -Raw | ConvertFrom-Json -ErrorAction Stop\n    $filesToUpload += $manifestFilePath\n}\ncatch\n{\n    WriteLog -Message \"Failed to parse '$manifestFilePath'. Please make sure the file content is a valid JSON.\" -Throw\n}\n\n# Create a version.txt file from the integrationTestBuildManifest.json and add it to the list of files to upload\nWriteLog -Message \"Creating version.txt file...\"\n$version = $manifest.CoreToolsVersion\n$versionFilePath = Join-Path $SourcePath \"version.txt\"\n$version | Set-Content -Path $versionFilePath\n$filesToUpload += $versionFilePath\n\n# These are the destination paths in the storage account\n# \"https://<storageAccountName>.blob.core.windows.net/builds/$FUNC_RUNTIME_VERSION/latest/Azure.Functions.Cli.$os-$arch.zip\"\n# \"https://<storageAccountName>.blob.core.windows.net/builds/$FUNC_RUNTIME_VERSION/$version/Azure.Functions.Cli.$os-$arch.zip\"\n$latestDestinationPath = \"$FUNC_RUNTIME_VERSION/latest\"\n$versionDestinationPath = \"$FUNC_RUNTIME_VERSION/$($version)\"\n\n# Delete the files in the latest folder if it is not empty\n$filesToDelete = @(Get-AzStorageBlob -Container $CONTAINER_NAME -Context $context -ErrorAction SilentlyContinue | Where-Object {$_.Name -like \"*$latestDestinationPath*\" })\nif ($filesToDelete.Count -gt 0)\n{\n    WriteLog -Message \"Deleting files in the latest folder....\"\n    $filesToDelete | ForEach-Object {\n        Remove-AzStorageBlob -Container $CONTAINER_NAME  -Context $context -Blob $_.Name -Force -ErrorAction SilentlyContinue | Out-Null\n    }\n}\n\nforeach ($path in @($latestDestinationPath, $versionDestinationPath))\n{\n    foreach ($file in $filesToUpload)\n    {\n        $fileName = Split-Path $file -Leaf\n        $destinationPath = Join-Path $path $fileName\n\n        $contentType = GetContentType -FilePath $file\n\n        if ($destinationPath -like \"*latest*\")\n        {\n            # Remove the Core Tools version from the path for latest\n            $destinationPath = $destinationPath.Replace(\".\" + $version, \"\")\n        }\n\n        try\n        {\n            WriteLog -Message \"Uploading '$fileName' to '$destinationPath'.\"\n\n            Set-AzStorageBlobContent -File $file `\n                                     -Container $CONTAINER_NAME `\n                                     -Blob $destinationPath `\n                                     -Context $context `\n                                     -StandardBlobTier Hot `\n                                     -ErrorAction Stop `\n                                     -Properties  @{\"ContentType\" = $contentType} `\n                                     -Force | Out-Null\n        }\n        catch\n        {\n            WriteLog -Message \"Failed to upload file '$file' to storage account. Exception information: $_\" -Throw\n        }\n    }\n}\n\nWriteLog -Message \"Script completed.\"\n"
        },
        {
          "name": "validateWorkerVersions.ps1",
          "type": "blob",
          "size": 3.5654296875,
          "content": "<#\r\n    .SYNOPSIS\r\n        Used to validate and/or update worker package versions\r\n    .EXAMPLE\r\n        ./validateWorkerVersions.ps1\r\n\r\n        Validates the workers match the existing host version and throws an error if they don't\r\n    .EXAMPLE\r\n        ./validateWorkerVersions.ps1 -Update -HostVersion 4.0.0\r\n\r\n        Updates the host reference to 4.0.0 and the workers to their matching versions\r\n#>\r\nparam (\r\n    [Switch]$Update,\r\n    \r\n    # An explicit host version, otherwise the host version from Azure.Functions.Cli.csproj will be used\r\n    [string]$hostVersion\r\n)\r\n\r\n# the xml will fail to parse if the data is encoded with a bom character\r\nfunction removeBomIfExists([string]$data)\r\n{\r\n    if ($data.StartsWith(0xFEFF)) {\r\n        $data = $data.substring(1)\r\n    }\r\n    return $data\r\n}\r\n\r\n$cliCsprojPath = \"$PSScriptRoot/src/Azure.Functions.Cli/Azure.Functions.Cli.csproj\"\r\n$cliCsprojContent = removeBomIfExists(Get-Content $cliCsprojPath)\r\n$cliCsprojXml = [xml]$cliCsprojContent\r\n\r\nfunction getPackageVersion([string]$packageName, [string]$csprojContent)\r\n{\r\n    $version = (Select-Xml -Content $csprojContent -XPath \"/Project//PackageReference[@Include='$packageName']/@Version\").ToString()\r\n    if (-Not $version) {\r\n        throw \"Failed to find version for package $packageName\"\r\n    }\r\n    return $version\r\n}\r\n\r\nfunction setCliPackageVersion([string]$packageName, [string]$newVersion)\r\n{\r\n    $node = $cliCsprojXml.SelectSingleNode(\"/Project//PackageReference[@Include='$packageName']\")\r\n    if (-Not $node) {\r\n        throw \"Failed to find reference for package $packageName\"\r\n    }\r\n    $oldVersion = $node.Version\r\n    $node.Version = $newVersion\r\n    Write-Output \"Updated $packageName from $oldVersion to $newVersion\"\r\n}\r\n\r\n$hostPackageName = \"Microsoft.Azure.WebJobs.Script.WebHost\"\r\nif (-Not $hostVersion) {\r\n    $hostVersion = getPackageVersion $hostPackageName $cliCsprojContent\r\n} elseif ($Update) {\r\n    setCliPackageVersion $hostPackageName $hostVersion\r\n}\r\n\r\nfunction getHostFileContent([string]$filePath) {\r\n    $uri = \"https://raw.githubusercontent.com/Azure/azure-functions-host/v$hostVersion/$filePath\"\r\n    return removeBomIfExists((Invoke-WebRequest -Uri $uri -MaximumRetryCount 5 -RetryIntervalSec 2).Content)\r\n}\r\n$hostCsprojContent = getHostFileContent \"src/WebJobs.Script/WebJobs.Script.csproj\"\r\n$pythonPropsContent = getHostFileContent \"build/python.props\"\r\n\r\n$workers = \"JavaWorker\", \"NodeJsWorker\", \"PowerShellWorker.PS7.0\", \"PowerShellWorker.PS7.2\", \"PowerShellWorker.PS7.4\", \"PythonWorker\"\r\n\r\n$failedValidation = $false\r\nforeach($worker in $workers) {\r\n    $packageName = \"Microsoft.Azure.Functions.$worker\"\r\n    if ($worker -eq \"PythonWorker\") {\r\n        $hostWorkerVersion = getPackageVersion $packageName $pythonPropsContent\r\n    } else {\r\n        $hostWorkerVersion = getPackageVersion $packageName $hostCsprojContent\r\n    }\r\n    $cliWorkerVersion = getPackageVersion $packageName $cliCsprojContent\r\n\r\n    if ($Update) {\r\n        setCliPackageVersion $packageName $hostWorkerVersion\r\n    } elseif ($hostWorkerVersion -ne $cliWorkerVersion) {\r\n        Write-Output \"Reference to $worker in the host ($hostWorkerVersion) does not match version in the cli ($cliWorkerVersion)\"\r\n        $failedValidation = $true\r\n    }\r\n}\r\n\r\nif ($Update) {\r\n    $cliCsprojXml.Save($cliCsprojPath)\r\n    Write-Output \"Updated worker versions! 🚀\"\r\n} elseif ($failedValidation) {\r\n    Write-Output \"You can run './validateWorkerVersions.ps1 -Update' locally to fix worker versions.\"\r\n    throw \"Not all worker versions matched. 😢 See output for more info\"\r\n} else {\r\n    Write-Output \"Worker versions match! 🥳\"\r\n}\r\n"
        }
      ]
    }
  ]
}