{
  "metadata": {
    "timestamp": 1736710952634,
    "page": 610,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jstedfast/MimeKit",
      "stars": 1859,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".config",
          "type": "tree",
          "content": null
        },
        {
          "name": ".devcontainer",
          "type": "tree",
          "content": null
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 8.2451171875,
          "content": "# Remove the line below if you want to inherit .editorconfig settings from higher directories\nroot = true\n\n# C# files\n[*.cs]\n\n#### Core EditorConfig Options ####\n\n# Indentation and spacing\nindent_size = 4\nindent_style = tab\ntab_width = 4\n\n# New line preferences\nend_of_line = crlf\ninsert_final_newline = true\n\n#### .NET Coding Conventions ####\n\n# Organize usings\ndotnet_separate_import_directive_groups = true\ndotnet_sort_system_directives_first = true\nfile_header_template = unset\n\n# this. and Me. preferences\ndotnet_style_qualification_for_event = false:silent\ndotnet_style_qualification_for_field = false:silent\ndotnet_style_qualification_for_method = false:silent\ndotnet_style_qualification_for_property = false:silent\n\n# Language keywords vs BCL types preferences\ndotnet_style_predefined_type_for_locals_parameters_members = true:silent\ndotnet_style_predefined_type_for_member_access = true:silent\n\n# Parentheses preferences\ndotnet_style_parentheses_in_arithmetic_binary_operators = always_for_clarity:silent\ndotnet_style_parentheses_in_other_binary_operators = always_for_clarity:silent\ndotnet_style_parentheses_in_other_operators = never_if_unnecessary:silent\ndotnet_style_parentheses_in_relational_binary_operators = always_for_clarity:silent\n\n# Modifier preferences\ndotnet_style_require_accessibility_modifiers = for_non_interface_members:silent\n\n# Expression-level preferences\ndotnet_style_coalesce_expression = true:suggestion\ndotnet_style_collection_initializer = true:suggestion\ndotnet_style_explicit_tuple_names = true:suggestion\ndotnet_style_null_propagation = true:suggestion\ndotnet_style_object_initializer = true:suggestion\ndotnet_style_operator_placement_when_wrapping = beginning_of_line\ndotnet_style_prefer_auto_properties = true:silent\ndotnet_style_prefer_compound_assignment = true:suggestion\ndotnet_style_prefer_conditional_expression_over_assignment = true:silent\ndotnet_style_prefer_conditional_expression_over_return = true:silent\ndotnet_style_prefer_inferred_anonymous_type_member_names = true:suggestion\ndotnet_style_prefer_inferred_tuple_names = true:suggestion\ndotnet_style_prefer_is_null_check_over_reference_equality_method = true:suggestion\ndotnet_style_prefer_simplified_boolean_expressions = true:suggestion\ndotnet_style_prefer_simplified_interpolation = true:suggestion\n\n# Field preferences\ndotnet_style_readonly_field = true:suggestion\n\n# Parameter preferences\ndotnet_code_quality_unused_parameters = all:suggestion\n\n#### C# Coding Conventions ####\n\n# var preferences\ncsharp_style_var_elsewhere = false:silent\ncsharp_style_var_for_built_in_types = false:silent\ncsharp_style_var_when_type_is_apparent = false:silent\n\n# Expression-bodied members\ncsharp_style_expression_bodied_accessors = true:silent\ncsharp_style_expression_bodied_constructors = false:silent\ncsharp_style_expression_bodied_indexers = true:silent\ncsharp_style_expression_bodied_lambdas = true:silent\ncsharp_style_expression_bodied_local_functions = false:silent\ncsharp_style_expression_bodied_methods = false:silent\ncsharp_style_expression_bodied_operators = false:silent\ncsharp_style_expression_bodied_properties = true:silent\n\n# Pattern matching preferences\ncsharp_style_pattern_matching_over_as_with_null_check = true:suggestion\ncsharp_style_pattern_matching_over_is_with_cast_check = true:suggestion\ncsharp_style_prefer_switch_expression = true:suggestion\n\n# Null-checking preferences\ncsharp_style_conditional_delegate_call = true:suggestion\n\n# Modifier preferences\ncsharp_prefer_static_local_function = true:suggestion\ncsharp_preferred_modifier_order = public,private,protected,internal,static,extern,new,virtual,abstract,sealed,override,readonly,unsafe,volatile,async:silent\n\n# Code-block preferences\ncsharp_prefer_braces = true:silent\ncsharp_prefer_simple_using_statement = true:suggestion\n\n# Expression-level preferences\ncsharp_prefer_simple_default_expression = false:suggestion\ncsharp_style_deconstructed_variable_declaration = true:suggestion\ncsharp_style_inlined_variable_declaration = true:suggestion\ncsharp_style_pattern_local_over_anonymous_function = true:suggestion\ncsharp_style_prefer_index_operator = true:suggestion\ncsharp_style_prefer_range_operator = true:suggestion\ncsharp_style_throw_expression = true:suggestion\ncsharp_style_unused_value_assignment_preference = discard_variable:suggestion\ncsharp_style_unused_value_expression_statement_preference = discard_variable:silent\n\n# 'using' directive preferences\ncsharp_using_directive_placement = outside_namespace:silent\n\n#### C# Formatting Rules ####\n\n# New line preferences\ncsharp_new_line_before_catch = false\ncsharp_new_line_before_else = false\ncsharp_new_line_before_finally = false\ncsharp_new_line_before_members_in_anonymous_types = true\ncsharp_new_line_before_members_in_object_initializers = true\ncsharp_new_line_before_open_brace = methods,types\ncsharp_new_line_between_query_expression_clauses = true\n\n# Indentation preferences\ncsharp_indent_block_contents = true\ncsharp_indent_braces = false\ncsharp_indent_case_contents = true\ncsharp_indent_case_contents_when_block = true\ncsharp_indent_labels = one_less_than_current\ncsharp_indent_switch_labels = false\n\n# Space preferences\ncsharp_space_after_cast = true\ncsharp_space_after_colon_in_inheritance_clause = true\ncsharp_space_after_comma = true\ncsharp_space_after_dot = false\ncsharp_space_after_keywords_in_control_flow_statements = true\ncsharp_space_after_semicolon_in_for_statement = true\ncsharp_space_around_binary_operators = before_and_after\ncsharp_space_around_declaration_statements = false\ncsharp_space_before_colon_in_inheritance_clause = true\ncsharp_space_before_comma = false\ncsharp_space_before_dot = false\ncsharp_space_before_open_square_brackets = false\ncsharp_space_before_semicolon_in_for_statement = false\ncsharp_space_between_empty_square_brackets = false\ncsharp_space_between_method_call_empty_parameter_list_parentheses = false\ncsharp_space_between_method_call_name_and_opening_parenthesis = true\ncsharp_space_between_method_call_parameter_list_parentheses = false\ncsharp_space_between_method_declaration_empty_parameter_list_parentheses = false\ncsharp_space_between_method_declaration_name_and_open_parenthesis = true\ncsharp_space_between_method_declaration_parameter_list_parentheses = false\ncsharp_space_between_parentheses = false\ncsharp_space_between_square_brackets = false\n\n# Wrapping preferences\ncsharp_preserve_single_line_blocks = true\ncsharp_preserve_single_line_statements = true\n\n#### Naming styles ####\n\n# Naming rules\n\ndotnet_naming_rule.interface_should_be_begins_with_i.severity = suggestion\ndotnet_naming_rule.interface_should_be_begins_with_i.symbols = interface\ndotnet_naming_rule.interface_should_be_begins_with_i.style = begins_with_i\n\ndotnet_naming_rule.types_should_be_pascal_case.severity = suggestion\ndotnet_naming_rule.types_should_be_pascal_case.symbols = types\ndotnet_naming_rule.types_should_be_pascal_case.style = pascal_case\n\ndotnet_naming_rule.non_field_members_should_be_pascal_case.severity = suggestion\ndotnet_naming_rule.non_field_members_should_be_pascal_case.symbols = non_field_members\ndotnet_naming_rule.non_field_members_should_be_pascal_case.style = pascal_case\n\n# Symbol specifications\n\ndotnet_naming_symbols.interface.applicable_kinds = interface\ndotnet_naming_symbols.interface.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected\ndotnet_naming_symbols.interface.required_modifiers = \n\ndotnet_naming_symbols.types.applicable_kinds = class, struct, interface, enum\ndotnet_naming_symbols.types.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected\ndotnet_naming_symbols.types.required_modifiers = \n\ndotnet_naming_symbols.non_field_members.applicable_kinds = property, event, method\ndotnet_naming_symbols.non_field_members.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected\ndotnet_naming_symbols.non_field_members.required_modifiers = \n\n# Naming styles\n\ndotnet_naming_style.pascal_case.required_prefix = \ndotnet_naming_style.pascal_case.required_suffix = \ndotnet_naming_style.pascal_case.word_separator = \ndotnet_naming_style.pascal_case.capitalization = pascal_case\n\ndotnet_naming_style.begins_with_i.required_prefix = I\ndotnet_naming_style.begins_with_i.required_suffix = \ndotnet_naming_style.begins_with_i.word_separator = \ndotnet_naming_style.begins_with_i.capitalization = pascal_case\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.111328125,
          "content": "*.csproj text\n*.nuspec text\n*.sln eol=crlf\n*.xhtml binary\n*.html binary\n*.txt text\n*.yml text\n*.cs text\n*.md text\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.392578125,
          "content": "MimeKit/Resources/Resource.designer.cs\nMono.Data.Sqlite/Documentation\nproject.nuget.cache\n*project.lock.json\n*.csproj.nuget.cache\n*.csproj.nuget.dgspec.json\n*.nupkg\n*.patch\n*.userprefs\n*.user\n*.suo\n*~\ntest-results\npackages\nobj\nbin\n.vs\n\n# files generated by running the unit tests\n# in the root folder\nexported.p12\nexported.crt\ngpg.conf\npkcs7.db\npubring.gpg\nsecring.gpg\nsmime.db\nsmimev0-tmp.db\nsqlite.db"
        },
        {
          "name": "AotCompatibility",
          "type": "tree",
          "content": null
        },
        {
          "name": "Benchmarks",
          "type": "tree",
          "content": null
        },
        {
          "name": "FAQ.md",
          "type": "blob",
          "size": 46.998046875,
          "content": "# Frequently Asked Questions\n\n## Question Index\n\n### General\n\n* [Are MimeKit and MailKit completely free? Can I use them in my proprietary product(s)?](#completely-free)\n* [Why do I get `NotSupportedException: No data is available for encoding ######. For information on defining a custom encoding, see the documentation for the Encoding.RegisterProvider method.`?](#register-provider)\n* [Why do I get a `TypeLoadException` when I try to create a new MimeMessage?](#type-load-exception)\n\n### Messages\n\n* [How do I create a message with attachments?](#create-attachments)\n* [How do I get the main body of a message?](#message-body)\n* [How do I tell if a message has attachments?](#has-attachments)\n* [Why doesn't the `MimeMessage` class implement `ISerializable` so that I can serialize a message to disk and read it back later?](#serialize-message)\n* [How do I parse messages?](#load-messages)\n* [How do I save messages?](#save-messages)\n* [How do I save attachments?](#save-attachments)\n* [How do I get the email addresses in the From, To, and Cc headers?](#address-headers)\n* [Why do attachments with unicode or long filenames appear as \"ATT0####.dat\" in Outlook?](#untitled-attachments)\n* [How do I decrypt PGP messages that are embedded in the main message text?](#decrypt-inline-pgp)\n* [How do I reply to a message using MimeKit?](#reply-message)\n* [How do I forward a message?](#forward-message)\n* [Why does text show up garbled in my ASP.NET Core / .NET Core / .NET 5 app?](#garbled-text)\n\n### Specialty\n\n* [How would I parse multipart/form-data from an HTTP web request?](#parse-web-request-form-data)\n\n## General\n\n### <a name=\"completely-free\">Q: Are MimeKit and MailKit completely free? Can I use them in my proprietary product(s)?</a>\n\nYes. MimeKit and MailKit are both completely free and open source. They are both covered under the\n[MIT](https://opensource.org/licenses/MIT) license.\n\n### <a name=\"register-provider\">Q: Why do I get `NotSupportedException: No data is available for encoding ######. For information on defining a custom encoding, see the documentation for the Encoding.RegisterProvider method.`?</a>\n\nIn .NET Core, Microsoft decided to split out the non-Unicode text encodings into a separate NuGet package called\n[System.Text.Encoding.CodePages](https://www.nuget.org/packages/System.Text.Encoding.CodePages).\n\nMimeKit already pulls in a reference to this NuGet package, so you shsouldn't need to add a reference to it in\nyour project. That said, you will still need to register the encoding provider. It is recommended that you add\nthe following line of code to your program initialization (e.g. the beginning of your program's Main() method):\n\n```csharp\nSystem.Text.Encoding.RegisterProvider (System.Text.CodePagesEncodingProvider.Instance);\n```\n\n### <a name=\"type-load-exception\">Q: Why do I get a `TypeLoadException` when I try to create a new MimeMessage?</a>\n\nThis only seems to happen in cases where the application is built for .NET Framework (v4.x) and seems to be most\ncommon for ASP.NET web applications that were built using Visual Studio 2019 (it is unclear whether this happens\nwith Visual Studio 2022 as well).\n\nThe issue is that some (older?) versions of MSBuild do not correctly generate `\\*.dll.config`, `app.config`\nand/or `web.config` files with proper assembly version binding redirects.\n\nIf this problem is happening to you, make sure to use MimeKit and MailKit >= v4.0 which include `MimeKit.dll.config`\nand `MailKit.dll.config`.\n\nThe next step is to manually edit your application's `app.config` (or `web.config`) to add a binding redirect\nfor `System.Runtime.CompilerServices.Unsafe`:\n\n```xml\n<configuration>\n  <runtime>\n    <assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\">\n      <dependentAssembly>\n        <assemblyIdentity name=\"System.Runtime.CompilerServices.Unsafe\" publicKeyToken=\"b03f5f7f11d50a3a\" culture=\"neutral\" />\n        <bindingRedirect oldVersion=\"0.0.0.0-6.0.0.0\" newVersion=\"6.0.0.0\" />\n      </dependentAssembly>\n    </assemblyBinding>\n  </runtime>\n</configuration>\n```\n\n## Messages\n\n### <a name=\"create-attachments\">Q: How do I create a message with attachments?</a>\n\nTo construct a message with attachments, the first thing you'll need to do is create a `multipart/mixed`\ncontainer which you'll then want to add the message body to first. Once you've added the body, you can\nthen add MIME parts to it that contain the content of the files you'd like to attach, being sure to set\nthe `Content-Disposition` header value to attachment. You'll probably also want to set the `filename`\nparameter on the `Content-Disposition` header as well as the `name` parameter on the `Content-Type`\nheader. The most convenient way to do this is to use the\n[MimePart.FileName](https://www.mimekit.net/docs/html/P_MimeKit_MimePart_FileName.htm) property which\nwill set both parameters for you as well as setting the `Content-Disposition` header value to `attachment`\nif it has not already been set to something else.\n\n```csharp\nvar message = new MimeMessage ();\nmessage.From.Add (new MailboxAddress (\"Joey\", \"joey@friends.com\"));\nmessage.To.Add (new MailboxAddress (\"Alice\", \"alice@wonderland.com\"));\nmessage.Subject = \"How you doin?\";\n\n// create our message text, just like before (except don't set it as the message.Body)\nvar body = new TextPart (\"plain\") {\n    Text = @\"Hey Alice,\n\nWhat are you up to this weekend? Monica is throwing one of her parties on\nSaturday and I was hoping you could make it.\n\nWill you be my +1?\n\n-- Joey\n\"\n};\n\n// create an image attachment for the file located at path\nvar attachment = new MimePart (\"image\", \"gif\") {\n    Content = new MimeContent (File.OpenRead (path), ContentEncoding.Default),\n    ContentDisposition = new ContentDisposition (ContentDisposition.Attachment),\n    ContentTransferEncoding = ContentEncoding.Base64,\n    FileName = Path.GetFileName (path)\n};\n\n// now create the multipart/mixed container to hold the message text and the\n// image attachment\nvar multipart = new Multipart (\"mixed\");\nmultipart.Add (body);\nmultipart.Add (attachment);\n\n// now set the multipart/mixed as the message body\nmessage.Body = multipart;\n```\n\nA simpler way to construct messages with attachments is to take advantage of the\n[BodyBuilder](https://www.mimekit.net/docs/html/T_MimeKit_BodyBuilder.htm) class.\n\n```csharp\nvar message = new MimeMessage ();\nmessage.From.Add (new MailboxAddress (\"Joey\", \"joey@friends.com\"));\nmessage.To.Add (new MailboxAddress (\"Alice\", \"alice@wonderland.com\"));\nmessage.Subject = \"How you doin?\";\n\nvar builder = new BodyBuilder ();\n\n// Set the plain-text version of the message text\nbuilder.TextBody = @\"Hey Alice,\n\nWhat are you up to this weekend? Monica is throwing one of her parties on\nSaturday and I was hoping you could make it.\n\nWill you be my +1?\n\n-- Joey\n\";\n\n// We may also want to attach a calendar event for Monica's party...\nbuilder.Attachments.Add (@\"C:\\Users\\Joey\\Documents\\party.ics\");\n\n// Now we just need to set the message body and we're done\nmessage.Body = builder.ToMessageBody ();\n```\n\nFor more information, see [Creating Messages](https://www.mimekit.net/docs/html/Creating-Messages.htm).\n\n### <a name=\"message-body\">Q: How do I get the main body of a message?</a>\n\n(Note: for the TL;DR version, skip to [the end](#message-body-tldr))\n\nMIME is a tree structure of parts. There are multiparts which contain other parts (even other multiparts).\nThere are message parts which contain messages. And finally, there are leaf-node parts which contain content.\n\nThere are a few common message structures:\n\n1. The message contains only a `text/plain` or `text/html` part (easy, just use that).\n\n2. The message contains a `multipart/alternative` which will typically look a bit like this:\n\n    ```\n    multipart/alternative\n       text/plain\n       text/html\n    ```\n\n3. Same as above, but the html part is inside a `multipart/related` so that it can embed images:\n\n    ```\n    multipart/alternative\n       text/plain\n       multipart/related\n          text/html\n          image/jpeg\n          image/png\n    ```\n\n4. The message contains a textual body part as well as some attachments:\n\n    ```\n    multipart/mixed\n       text/plain or text/html\n       application/octet-stream\n       application/zip\n    ```\n\n5. the same as above, but with the first part replaced with either #2 or #3. To illustrate:\n\n    ```\n    multipart/mixed\n       multipart/alternative\n          text/plain\n          text/html\n       application/octet-stream\n       application/zip\n    ```\n\n    or...\n\n    ```\n    multipart/mixed\n       multipart/alternative\n          text/plain\n          multipart/related\n             text/html\n             image/jpeg\n             image/png\n       application/octet-stream\n       application/zip\n    ```\n\n<a name=\"message-body-tldr\"></a>Now, if you don't care about any of that and just want to get the text of\nthe first `text/plain` or `text/html` part you can find, that's easy.\n\n[MimeMessage](https://www.mimekit.net/docs/html/T_MimeKit_MimeMessage.htm) has two convenience properties\nfor this: [TextBody](https://www.mimekit.net/docs/html/P_MimeKit_MimeMessage_TextBody.htm) and\n[HtmlBody](https://www.mimekit.net/docs/html/P_MimeKit_MimeMessage_HtmlBody.htm).\n\n`MimeMessage.HtmlBody`, as the name implies, will traverse the MIME structure for you and find the most\nappropriate body part with a `Content-Type` of `text/html` that can be interpreted as the message body.\nLikewise, the `TextBody` property can be used to get the `text/plain` version of the message body.\n\nFor more information, see [Working with Messages](https://www.mimekit.net/docs/html/Working-With-Messages.htm).\n\n### <a name=\"has-attachments\">Q: How do I tell if a message has attachments?</a>\n\nIn most cases, a message with a body that has a MIME-type of `multipart/mixed` containing more than a\nsingle part probably has attachments. As illustrated above, the first part of a `multipart/mixed` is\ntypically the textual body of the message, but it is not always quite that simple.\n\nIn general, MIME attachments will have a `Content-Disposition` header with a value of `attachment`.\nTo get the list of body parts matching this criteria, you can use the\n[MimeMessage.Attachments](https://www.mimekit.net/docs/html/P_MimeKit_MimeMessage_Attachments.htm) property.\n\nUnfortunately, not all mail clients follow this convention and so you may need to write your own custom logic.\nFor example, you may wish to treat all body parts having a `name` or `filename` parameter set on them:\n\n```csharp\nvar attachments = message.BodyParts.OfType<MimePart> ().Where (part => !string.IsNullOrEmpty (part.FileName));\n```\n\nA more sophisticated approach is to treat body parts not referenced by the main textual body part of the\nmessage as attachments. In other words, treat any body part not used for rendering the message as an\nattachment. For an example on how to do this, consider the following code snippets:\n\n```csharp\n/// <summary>\n/// Visits a MimeMessage and generates HTML suitable to be rendered by a browser control.\n/// </summary>\nclass HtmlPreviewVisitor : MimeVisitor\n{\n    List<MultipartRelated> stack = new List<MultipartRelated> ();\n    List<MimeEntity> attachments = new List<MimeEntity> ();\n    List<MimeEntity> calenderAttachments = new List<MimeEntity> ();\n\n    readonly string tempDir;\n    string body;\n\n    /// <summary>\n    /// Creates a new HtmlPreviewVisitor.\n    /// </summary>\n    /// <param name=\"tempDirectory\">A temporary directory used for storing image files.</param>\n    public HtmlPreviewVisitor (string tempDirectory)\n    {\n        tempDir = tempDirectory;\n    }\n\n    /// <summary>\n    /// The list of attachments that were in the MimeMessage.\n    /// </summary>\n    public IList<MimeEntity> Attachments {\n        get { return attachments; }\n    }\n\n    /// <summary>\n    /// The list of text/calender entries that were in the MimeMessage.\n    /// </summary>\n    public IList<MimeEntity> CalenderAttachments {\n        get { return calenderAttachments; }\n    }\n\n    /// <summary>\n    /// The HTML string that can be set on the BrowserControl.\n    /// </summary>\n    public string HtmlBody {\n        get { return body ?? string.Empty; }\n    }\n\n    protected override void VisitMultipartAlternative (MultipartAlternative alternative)\n    {\n        // walk the multipart/alternative children backwards from greatest level of faithfulness to the least faithful\n        for (int i = alternative.Count - 1; i >= 0 && body == null; i--)\n            alternative[i].Accept (this);\n    }\n\n    protected override void VisitMultipartRelated (MultipartRelated related)\n    {\n        var root = related.Root;\n\n        // push this multipart/related onto our stack\n        stack.Add (related);\n\n        // visit the root document\n        root.Accept (this);\n\n        // pop this multipart/related off our stack\n        stack.RemoveAt (stack.Count - 1);\n    }\n\n    // look up the image based on the img src url within our multipart/related stack\n    bool TryGetImage (string url, out MimePart image)\n    {\n        UriKind kind;\n        int index;\n        Uri uri;\n\n        if (Uri.IsWellFormedUriString (url, UriKind.Absolute))\n            kind = UriKind.Absolute;\n        else if (Uri.IsWellFormedUriString (url, UriKind.Relative))\n            kind = UriKind.Relative;\n        else\n            kind = UriKind.RelativeOrAbsolute;\n\n        try {\n            uri = new Uri (url, kind);\n        } catch {\n            image = null;\n            return false;\n        }\n\n        for (int i = stack.Count - 1; i >= 0; i--) {\n            if ((index = stack[i].IndexOf (uri)) == -1)\n                continue;\n\n            image = stack[i][index] as MimePart;\n            return image != null;\n        }\n\n        image = null;\n\n        return false;\n    }\n\n    /// <summary>\n    /// Get a file:// URI for the image attachment.\n    /// </summary>\n    /// <remarks>\n    /// Saves the image attachment to a temp file and returns a file:// URI for the\n    /// temp file.\n    /// </remarks>\n    /// <returns>The file:// URI.</returns>\n    /// <param name=\"image\">The image attachment.</param>\n    /// <param name=\"url\">The original HTML image URL.</param>\n    string GetFileUri (MimePart image, string url)\n    {\n        string fileName = url.Replace (':', '_').Replace ('\\\\', '_').Replace ('/', '_');\n\n        string path = Path.Combine (tempDir, fileName);\n\n        if (!File.Exists (path)) {\n            using (var output = File.Create (path))\n                image.Content.DecodeTo (output);\n        }\n\n        return \"file://\" + path.Replace ('\\\\', '/');\n    }\n\n    /// <summary>\n    /// Get a data: URI for the image attachment.\n    /// </summary>\n    /// <remarks>\n    /// Encodes the image attachment into a string suitable for setting as a src= attribute value in\n    /// an img tag.\n    /// </remarks>\n    /// <returns>The data: URI.</returns>\n    /// <param name=\"image\">The image attachment.</param>\n    string GetDataUri (MimePart image)\n    {\n        using (var memory = new MemoryStream ()) {\n            image.Content.DecodeTo (memory);\n            var buffer = memory.GetBuffer ();\n            var length = (int) memory.Length;\n            var base64 = Convert.ToBase64String (buffer, 0, length);\n\n            return string.Format (\"data:{0};base64,{1}\", image.ContentType.MimeType, base64);\n        }\n    }\n\n    // Replaces <img src=...> urls that refer to images embedded within the message with\n    // \"file://\" urls that the browser control will actually be able to load.\n    void HtmlTagCallback (HtmlTagContext ctx, HtmlWriter htmlWriter)\n    {\n        if (ctx.TagId == HtmlTagId.Meta && !ctx.IsEndTag) {\n            bool isContentType = false;\n\n            ctx.WriteTag (htmlWriter, false);\n\n            // replace charsets with \"utf-8\" since our output will be in utf-8 (and not whatever the original charset was)\n            foreach (var attribute in ctx.Attributes) {\n                if (attribute.Id == HtmlAttributeId.Charset) {\n                    htmlWriter.WriteAttributeName (attribute.Name);\n                    htmlWriter.WriteAttributeValue (\"utf-8\");\n                } else if (isContentType && attribute.Id == HtmlAttributeId.Content) {\n                    htmlWriter.WriteAttributeName (attribute.Name);\n                    htmlWriter.WriteAttributeValue (\"text/html; charset=utf-8\");\n                } else {\n                    if (attribute.Id == HtmlAttributeId.HttpEquiv && attribute.Value != null\n                        && attribute.Value.Equals (\"Content-Type\", StringComparison.OrdinalIgnoreCase))\n                        isContentType = true;\n\n                    htmlWriter.WriteAttribute (attribute);\n                }\n            }\n        } else if (ctx.TagId == HtmlTagId.Image && !ctx.IsEndTag && stack.Count > 0) {\n            ctx.WriteTag (htmlWriter, false);\n\n            // replace the src attribute with a file:// URL\n            foreach (var attribute in ctx.Attributes) {\n                if (attribute.Id == HtmlAttributeId.Src) {\n                    if (!TryGetImage (attribute.Value, out var image)) {\n                        htmlWriter.WriteAttribute (attribute);\n                        continue;\n                    }\n\n                    // Note: you can either use a \"file://\" URI or you can use a\n                    // \"data:\" URI, the choice is yours.\n                    var uri = GetFileUri (image, attribute.Value);\n                    //var uri = GetDataUri (image);\n\n                    htmlWriter.WriteAttributeName (attribute.Name);\n                    htmlWriter.WriteAttributeValue (uri);\n                } else {\n                    htmlWriter.WriteAttribute (attribute);\n                }\n            }\n        } else if (ctx.TagId == HtmlTagId.Body && !ctx.IsEndTag) {\n            ctx.WriteTag (htmlWriter, false);\n\n            // add and/or replace oncontextmenu=\"return false;\"\n            foreach (var attribute in ctx.Attributes) {\n                if (attribute.Name.Equals (\"oncontextmenu\", StringComparison.OrdinalIgnoreCase))\n                   continue;\n\n                htmlWriter.WriteAttribute (attribute);\n            }\n\n            htmlWriter.WriteAttribute (\"oncontextmenu\", \"return false;\");\n        } else {\n            // pass the tag through to the output\n            ctx.WriteTag (htmlWriter, true);\n        }\n    }\n\n    protected override void VisitTextPart (TextPart entity)\n    {\n        TextConverter converter;\n\n        // treat text/calendar parts as attachments rather than message bodies\n        if (entity.ContentType.IsMimeType (\"text\", \"calendar\")) {\n            calendarAattachments.Add (entity);\n            return;\n        }\n\n        if (body != null) {\n            // since we've already found the body, treat this as an attachment\n            attachments.Add (entity);\n            return;\n        }\n\n        if (entity.IsHtml) {\n            converter = new HtmlToHtml {\n                HtmlTagCallback = HtmlTagCallback\n            };\n        } else if (entity.IsFlowed) {\n            var flowed = new FlowedToHtml ();\n            string delsp;\n\n            if (entity.ContentType.Parameters.TryGetValue (\"delsp\", out delsp))\n                flowed.DeleteSpace = delsp.Equals (\"yes\", StringComparison.OrdinalIgnoreCase);\n            converter = flowed;\n        } else {\n            converter = new TextToHtml ();\n        }\n\n        body = converter.Convert (entity.Text);\n    }\n\n    protected override void VisitTnefPart (TnefPart entity)\n    {\n        // extract any attachments in the MS-TNEF part\n        attachments.AddRange (entity.ExtractAttachments ());\n    }\n\n    protected override void VisitMessagePart (MessagePart entity)\n    {\n        // treat message/rfc822 parts as attachments\n        attachments.Add (entity);\n    }\n\n    protected override void VisitMimePart (MimePart entity)\n    {\n        // realistically, if we've gotten this far, then we can treat this as an attachment\n        // even if the IsAttachment property is false.\n        attachments.Add (entity);\n    }\n}\n```\n\nAnd the way you'd use this visitor might look something like this:\n\n```csharp\nvoid Render (MimeMessage message)\n{\n    var tmpDir = Path.Combine (Path.GetTempPath (), message.MessageId);\n    var visitor = new HtmlPreviewVisitor (tmpDir);\n\n    Directory.CreateDirectory (tmpDir);\n\n    message.Accept (visitor);\n\n    DisplayHtml (visitor.HtmlBody);\n    DisplayAttachments (visitor.Attachments);\n}\n```\n\nOnce you've rendered the message using the above technique, you'll have a list of attachments that\nwere not used, even if they did not match the simplistic criteria used by the `MimeMessage.Attachments`\nproperty.\n\n### <a name=\"serialize-message\">Q: Why doesn't the `MimeMessage` class implement `ISerializable` so that I can serialize a message to disk and read it back later?</a>\n\nThe MimeKit API was designed to use the existing MIME format for serialization. In light of this, the ability\nto use the .NET serialization API and format did not make much sense to support.\n\nYou can easily serialize a [MimeMessage](https://www.mimekit.net/docs/html/T_MimeKit_MimeMessage.htm) to a stream using the\n[WriteTo](https://www.mimekit.net/docs/html/Overload_MimeKit_MimeMessage_WriteTo.htm) methods.\n\nFor more information on this topic, see the following other two topics:\n\n* [How do I parse messages?](#load-messages)\n* [How do I save messages?](#save-messages)\n\n### <a name=\"load-messages\">Q: How do I parse messages?</a>\n\nOne of the more common operations that MimeKit is meant for is parsing email messages from arbitrary streams.\nThere are two ways of accomplishing this task.\n\nThe first way is to use one of the [Load](https://www.mimekit.net/docs/html/Overload_MimeKit_MimeMessage_Load.htm) methods\non `MimeMessage`:\n\n```csharp\n// Load a MimeMessage from a stream\nvar message = MimeMessage.Load (stream);\n```\n\nOr you can load a message from a file path:\n\n```csharp\n// Load a MimeMessage from a file path\nvar message = MimeMessage.Load (\"message.eml\");\n```\n\nThe second way is to use the [MimeParser](https://www.mimekit.net/docs/html/T_MimeKit_MimeParser.htm) class. For the most\npart, using the `MimeParser` directly is not necessary unless you wish to parse a Unix mbox file stream. However, this is\nhow you would do it:\n\n```csharp\n// Load a MimeMessage from a stream\nvar parser = new MimeParser (stream, MimeFormat.Entity);\nvar message = parser.ParseMessage ();\n```\n\nFor Unix mbox file streams, you would use the parser like this:\n\n```csharp\n// Load every message from a Unix mbox\nvar parser = new MimeParser (stream, MimeFormat.Mbox);\nwhile (!parser.IsEndOfStream) {\n    var message = parser.ParseMessage ();\n\n    // do something with the message\n}\n```\n\n### <a name=\"save-messages\">Q: How do I save messages?</a>\n\nOne you've got a [MimeMessage](https://www.mimekit.net/docs/html/T_MimeKit_MimeMessage.htm), you can save\nit to a file using the [WriteTo](https://mimekit.net/docs/html/Overload_MimeKit_MimeMessage_WriteTo.htm) method:\n\n```csharp\nmessage.WriteTo (\"message.eml\");\n```\n\nThe `WriteTo` method also has overloads that allow you to write the message to a `Stream` instead.\n\nBy default, the `WriteTo` method will save the message using DOS line-endings on Windows and Unix\nline-endings on Unix-based systems such as macOS and Linux. You can override this behavior by\npassing a [FormatOptions](https://mimekit.net/docs/html/T_MimeKit_FormatOptions.htm) argument to\nthe method:\n\n```csharp\n// clone the default formatting options\nvar format = FormatOptions.Default.Clone ();\n\n// override the line-endings to be DOS no matter what platform we are on\nformat.NewLineFormat = NewLineFormat.Dos;\n\nmessage.WriteTo (format, \"message.eml\");\n```\n\nNote: While it may seem like you can safely use the `ToString` method to serialize a message,\n***DON'T DO IT!*** This is ***not*** safe! MIME messages cannot be accurately represented as\nstrings due to the fact that each MIME part of the message *may* be encoded in a different\ncharacter set, thus making it impossible to convert the message into a unicode string using a\nsingle charset to do the conversion (which is *exactly* what `ToString` does).\n\n### <a name=\"save-attachments\">Q: How do I save attachments?</a>\n\nIf you've already got a [MimePart](https://www.mimekit.net/docs/html/T_MimeKit_MimePart.htm) that represents\nthe attachment that you'd like to save, here's how you might save it:\n\n```csharp\nusing (var stream = File.Create (fileName))\n    attachment.Content.DecodeTo (stream);\n```\n\nPretty simple, right?\n\nBut what if your attachment is actually a [MessagePart](https://www.mimekit.net/docs/html/T_MimeKit_MessagePart.htm)?\n\nTo save the content of a `message/rfc822` part, you'd use the following code snippet:\n\n```csharp\nusing (var stream = File.Create (fileName))\n    attachment.Message.WriteTo (stream);\n```\n\nIf you are iterating over all of the attachments in a message, you might do something like this:\n\n```csharp\nforeach (var attachment in message.Attachments) {\n    var fileName = attachment.ContentDisposition?.FileName ?? attachment.ContentType.Name;\n    \n    using (var stream = File.Create (fileName)) {\n        if (attachment is MessagePart) {\n            var rfc822 = (MessagePart) attachment;\n            \n            rfc822.Message.WriteTo (stream);\n        } else {\n            var part = (MimePart) attachment;\n            \n            part.Content.DecodeTo (stream);\n        }\n    }\n}\n```\n\n### <a name=\"address-headers\">Q: How do I get the email addresses in the From, To, and Cc headers?</a>\n\nThe [From](https://www.mimekit.net/docs/html/P_MimeKit_MimeMessage_From.htm),\n[To](https://www.mimekit.net/docs/html/P_MimeKit_MimeMessage_To.htm), and\n[Cc](https://www.mimekit.net/docs/html/P_MimeKit_MimeMessage_Cc.htm) properties of a\n[MimeMessage](https://www.mimekit.net/docs/html/T_MimeKit_MimeMessage.htm) are all of type\n[InternetAddressList](https://www.mimekit.net/docs/html/T_MimeKit_InternetAddressList.htm). An\n`InternetAddressList` is a list of\n[InternetAddress](https://www.mimekit.net/docs/html/T_MimeKit_InternetAddress.htm) items. This is\nwhere most people start to get lost because an `InternetAddress` is an abstract class that only\nreally has a [Name](https://www.mimekit.net/docs/html/P_MimeKit_InternetAddress_Name.htm) property.\n\nAs you've probably already discovered, the `Name` property contains the name of the person\n(if available), but what you want is his or her email address, not their name.\n\nTo get the email address, you'll need to figure out what subclass of address each `InternetAddress`\nreally is. There are 2 subclasses of `InternetAddress`:\n[GroupAddress](https://www.mimekit.net/docs/html/T_MimeKit_GroupAddress.htm) and\n[MailboxAddress](https://www.mimekit.net/docs/html/T_MimeKit_MailboxAddress.htm).\n\nA `GroupAddress` is a named group of more `InternetAddress` items that are contained within the\n[Members](https://www.mimekit.net/docs/html/P_MimeKit_GroupAddress_Members.htm) property. To get\nan idea of what a group address represents, consider the following examples:\n\n```\nTo: My Friends: Joey <joey@friends.com>, Monica <monica@friends.com>, \"Mrs. Chanandler Bong\"\n    <chandler@friends.com>, Ross <ross@friends.com>, Rachel <rachel@friends.com>;\n```\n\nIn the above example, the `To` header's `InternetAddressList` will contain only 1 item which will be a\n`GroupAddress` with a `Name` value of `My Friends`. The `Members` property of the `GroupAddress` will\ncontain 5 more `InternetAddress` items (which will all be instances of `MailboxAddress`).\n\nThe above example, however, is not very likely to ever be seen in messages you deal with. A far more\ncommon example would be the one below:\n\n```\nTo: undisclosed-recipients:;\n```\n\nMost of the time, the `From`, `To`, and `Cc` headers will only contain mailbox addresses. As you will\nnotice, a `MailboxAddress` has an\n[Address](https://www.mimekit.net/docs/html/P_MimeKit_MailboxAddress_Address.htm) property which will\ncontain the email address of the mailbox. In the following example, the `Address` property will\ncontain the value `john@smith.com`:\n\n```\nTo: John Smith <john@smith.com>\n```\n\nIf you only care about getting a flattened list of the mailbox addresses in a `From`, `To`, or `Cc`\nheader, you can do something like this:\n\n```csharp\nforeach (var mailbox in message.To.Mailboxes)\n    Console.WriteLine (\"{0}'s email address is {1}\", mailbox.Name, mailbox.Address);\n```\n\n### <a name=\"untitled-attachments\">Q: Why do attachments with unicode or long filenames appear as \"ATT0####.dat\" in Outlook?</a>\n\nAn attachment filename is stored as a MIME parameter on the `Content-Disposition` header. Unfortunately,\nthe original MIME specifications did not specify a method for encoding non-ASCII filenames. In 1997,\n[rfc2184](https://tools.ietf.org/html/rfc2184) (later updated by [rfc2231](https://tools.ietf.org/html/rfc2231))\nwas published which specified an encoding mechanism to use for encoding them. Since there was a window in\ntime where the MIME specifications did not define a way to encode them, some mail client developers decided\nto use the mechanism described by [rfc2047](https://tools.ietf.org/html/rfc2047) which was meant for\nencoding non-ASCII text in headers. While this may at first seem logical, the problem with this approach\nwas that rfc2047 `encoded-word` tokens are not allowed to be in quotes (as well as some other issues) and\nso another, more appropriate, encoding mechanism was needed.\n\nOutlook is one of those mail clients which decided to encode filenames using the mechanism described in\nrfc2047 and until Outlook 2007, did not support filenames encoded using the mechanism defined in rfc2231.\n\nAs of MimeKit v1.2.18, it is possible to configure MimeKit to use the rfc2047 encoding mechanism for\nfilenames in the following two ways:\n\nThe first way is to set the encoding method on each individual\n[Parameter](https://www.mimekit.net/docs/html/T_MimeKit_Parameter.htm):\n\n```csharp\nParameter param;\n\nif (attachment.ContentDisposition.Parameters.TryGetValue (\"filename\", out param))\n    param.EncodingMethod = ParameterEncodingMethod.Rfc2047;\n```\n\nOr\n\n```csharp\nforeach (var param in attachment.ContentDisposition.Parameters) {\n    param.EncodingMethod = ParameterEncodingMethod.Rfc2047;\n}\n```\n\n### <a name=\"decrypt-inline-pgp\">Q: How do I decrypt PGP messages that are embedded in the main message text?</a>\n\nSome PGP-enabled mail clients, such as Thunderbird, embed encrypted PGP blurbs within the `text/plain` body\nof the message rather than using the PGP/MIME format that MimeKit prefers.\n\nThese messages often look something like this:\n\n```text\nReturn-Path: <pgp-enthusiast@example.com>\nReceived: from [127.0.0.1] (hostname.example.com. [201.95.8.17])\n    by mx.google.com with ESMTPSA id l67sm26628445yha.8.2014.04.27.13.49.44\n    for <pgp-enthusiast@example.com>\n    (version=TLSv1 cipher=ECDHE-RSA-RC4-SHA bits=128/128);\n    Sun, 27 Apr 2014 13:49:44 -0700 (PDT)\nMessage-ID: <535D6D67.8020803@example.com>\nDate: Sun, 27 Apr 2014 17:49:43 -0300\nFrom: Die-Hard PGP Fan <pgp-enthusiast@example.com>\nUser-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; rv:24.0) Gecko/20100101 Thunderbird/24.4.0\nMIME-Version: 1.0\nTo: undisclosed-recipients:;\nSubject: Test of inline encrypted PGP blocks\nX-Enigmail-Version: 1.6\nContent-Type: text/plain; charset=ISO-8859-1\nContent-Transfer-Encoding: 8bit\nX-Antivirus: avast! (VPS 140427-1, 27/04/2014), Outbound message\nX-Antivirus-Status: Clean\n\n-----BEGIN PGP MESSAGE-----\nCharset: ISO-8859-1\nVersion: GnuPG v2.0.22 (MingW32)\nComment: Using GnuPG with Thunderbird - http://www.enigmail.net/\n\nSGFoISBJIGZvb2xlZCB5b3UsIHRoaXMgdGV4dCBpc24ndCBhY3R1YWxseSBlbmNy\neXB0ZWQgd2l0aCBQR1AsCml0J3MgYWN0dWFsbHkgb25seSBiYXNlNjQgZW5jb2Rl\nZCEKCkknbSBqdXN0IHVzaW5nIHRoaXMgYXMgYW4gZXhhbXBsZSwgdGhvdWdoLCBz\nbyBpdCBkb2Vzbid0IHJlYWxseSBtYXR0ZXIuCgpGb3IgdGhlIHNha2Ugb2YgYXJn\ndW1lbnQsIHdlJ2xsIHByZXRlbmQgdGhhdCB0aGlzIGlzIGFjdHVhbGx5IGFuIGVu\nY3J5cHRlZApibHVyYi4gTW1ta2F5PyBUaGFua3MuCg==\n-----END PGP MESSAGE-----\n```\n\nTo deal with these kinds of messages, I've added a method to OpenPgpContext called `GetDecryptedStream` which\ncan be used to get the raw decrypted stream.\n\nThere are actually 2 variants of this method:\n\n```csharp\npublic Stream GetDecryptedStream (Stream encryptedData, out DigitalSignatureCollection signatures)\n```\n\nand\n\n```csharp\npublic Stream GetDecryptedStream (Stream encryptedData)\n```\n\nThe first variant is useful in cases where the encrypted PGP blurb is also digitally signed, allowing you to get\nyour hands on the list of digitial signatures in order for you to verify each of them.\n\nTo decrypt the content of the message, you'll want to locate the `TextPart` (in this case, it'll just be\n`message.Body`)\nand then do this:\n\n```csharp\nstatic Stream DecryptEmbeddedPgp (TextPart text)\n{\n    using (var memory = new MemoryStream ()) {\n        text.Content.DecodeTo (memory);\n        memory.Position = 0;\n\n        using (var ctx = new MyGnuPGContext ()) {\n            return ctx.GetDecryptedStream (memory);\n        }\n    }\n}\n```\n\nWhat you do with that decrypted stream is up to you. It's up to you to figure out what the decrypted content is\n(is it text? a jpeg image? a video?) and how to display it to the user.\n\n### <a name=\"reply-message\">Q: How do I reply to a message?</a>\n\nReplying to a message is fairly simple. For the most part, you'd just create the reply message\nthe same way you'd create any other message. There are only a few slight differences:\n\n1. In the reply message, you'll want to prefix the `Subject` header with `\"Re: \"` if the prefix\n   doesn't already exist in the message you are replying to (in other words, if you are replying\n   to a message with a `Subject` of `\"Re: party tomorrow night!\"`, you would not prefix it with\n   another `\"Re: \"`).\n2. You will want to set the reply message's `In-Reply-To` header to the value of the\n   `Message-Id` header in the original message.\n3. You will want to copy the original message's `References` header into the reply message's\n   `References` header and then append the original message's `Message-Id` header.\n4. You will probably want to \"quote\" the original message's text in the reply.\n\nIf this logic were to be expressed in code, it might look something like this:\n\n```csharp\npublic static MimeMessage Reply (MimeMessage message, MailboxAddress from, bool replyToAll)\n{\n    var reply = new MimeMessage ();\n\n    reply.From.Add (from);\n\n    // reply to the sender of the message\n    if (message.ReplyTo.Count > 0) {\n        reply.To.AddRange (message.ReplyTo);\n    } else if (message.From.Count > 0) {\n        reply.To.AddRange (message.From);\n    } else if (message.Sender != null) {\n        reply.To.Add (message.Sender);\n    }\n\n    if (replyToAll) {\n        // include all of the other original recipients - TODO: remove ourselves from these lists\n        reply.To.AddRange (message.To);\n        reply.Cc.AddRange (message.Cc);\n    }\n\n    // set the reply subject\n    if (!message.Subject?.StartsWith (\"Re:\", StringComparison.OrdinalIgnoreCase))\n        reply.Subject = \"Re: \" + (message.Subject ?? string.Empty);\n    else\n        reply.Subject = message.Subject;\n\n    // construct the In-Reply-To and References headers\n    if (!string.IsNullOrEmpty (message.MessageId)) {\n        reply.InReplyTo = message.MessageId;\n        foreach (var id in message.References)\n            reply.References.Add (id);\n        reply.References.Add (message.MessageId);\n    }\n\n    // quote the original message text\n    using (var quoted = new StringWriter ()) {\n        var sender = message.Sender ?? message.From.Mailboxes.FirstOrDefault ();\n\n        quoted.WriteLine (\"On {0}, {1} wrote:\", message.Date.ToString (\"f\"), !string.IsNullOrEmpty (sender.Name) ? sender.Name : sender.Address);\n        using (var reader = new StringReader (message.TextBody)) {\n            string line;\n\n            while ((line = reader.ReadLine ()) != null) {\n                quoted.Write (\"> \");\n                quoted.WriteLine (line);\n            }\n        }\n\n        reply.Body = new TextPart (\"plain\") {\n            Text = quoted.ToString ()\n        };\n    }\n\n    return reply;\n}\n```\n\nBut what if you wanted to reply to a message and quote the HTML formatting of the original message\nbody (assuming it has an HTML body) while still including the embedded images?\n\nThis gets a bit more complicated, but it's still doable...\n\nThe first thing we'd need to do is implement our own\n[MimeVisitor](https://www.mimekit.net/docs/html/T_MimeKit_MimeVisitor.htm) to handle this:\n\n```csharp\npublic class ReplyVisitor : MimeVisitor\n{\n    readonly Stack<Multipart> stack = new Stack<Multipart> ();\n    MimeMessage original, reply;\n    MailboxAddress from;\n    bool replyToAll;\n\n    /// <summary>\n    /// Creates a new ReplyVisitor.\n    /// </summary>\n    public ReplyVisitor (MailboxAddress from, bool replyToAll)\n    {\n        this.replyToAll = replyToAll;\n        this.from = from;\n    }\n\n    /// <summary>\n    /// Gets the reply.\n    /// </summary>\n    /// <value>The reply.</value>\n    public MimeMessage Reply {\n        get { return reply; }\n    }\n\n    void Push (MimeEntity entity)\n    {\n        var multipart = entity as Multipart;\n\n        if (reply.Body == null) {\n            reply.Body = entity;\n        } else {\n            var parent = stack.Peek ();\n            parent.Add (entity);\n        }\n\n        if (multipart != null)\n            stack.Push (multipart);\n    }\n\n    void Pop ()\n    {\n        stack.Pop ();\n    }\n\n    static string GetOnDateSenderWrote (MimeMessage message)\n    {\n        var sender = message.Sender != null ? message.Sender : message.From.Mailboxes.FirstOrDefault ();\n        var name = sender != null ? (!string.IsNullOrEmpty (sender.Name) ? sender.Name : sender.Address) : \"an unknown sender\";\n\n        return string.Format (\"On {0}, {1} wrote:\", message.Date.ToString (\"f\"), name);\n    }\n\n    /// <summary>\n    /// Visit the specified message.\n    /// </summary>\n    /// <param name=\"message\">The message.</param>\n    public override void Visit (MimeMessage message)\n    {\n        reply = new MimeMessage ();\n        original = message;\n\n        stack.Clear ();\n\n        reply.From.Add (from.Clone ());\n\n        // reply to the sender of the message\n        if (message.ReplyTo.Count > 0) {\n            reply.To.AddRange (message.ReplyTo);\n        } else if (message.From.Count > 0) {\n            reply.To.AddRange (message.From);\n        } else if (message.Sender != null) {\n            reply.To.Add (message.Sender);\n        }\n\n        if (replyToAll) {\n            // include all of the other original recipients - TODO: remove ourselves from these lists\n            reply.To.AddRange (message.To);\n            reply.Cc.AddRange (message.Cc);\n        }\n\n        // set the reply subject\n        if (!message.Subject?.StartsWith (\"Re:\", StringComparison.OrdinalIgnoreCase))\n            reply.Subject = \"Re: \" + (message.Subject ?? string.Empty);\n        else\n            reply.Subject = message.Subject;\n\n        // construct the In-Reply-To and References headers\n        if (!string.IsNullOrEmpty (message.MessageId)) {\n            reply.InReplyTo = message.MessageId;\n            foreach (var id in message.References)\n                reply.References.Add (id);\n            reply.References.Add (message.MessageId);\n        }\n\n        base.Visit (message);\n    }\n\n    /// <summary>\n    /// Visit the specified entity.\n    /// </summary>\n    /// <param name=\"entity\">The MIME entity.</param>\n    /// <exception cref=\"System.NotSupportedException\">\n    /// Only Visit(MimeMessage) is supported.\n    /// </exception>\n    public override void Visit (MimeEntity entity)\n    {\n        throw new NotSupportedException ();\n    }\n\n    protected override void VisitMultipartAlternative (MultipartAlternative alternative)\n    {\n        var multipart = new MultipartAlternative ();\n\n        Push (multipart);\n\n        for (int i = 0; i < alternative.Count; i++)\n            alternative[i].Accept (this);\n\n        Pop ();\n    }\n\n    protected override void VisitMultipartRelated (MultipartRelated related)\n    {\n        var multipart = new MultipartRelated ();\n        var root = related.Root;\n\n        Push (multipart);\n\n        root.Accept (this);\n\n        for (int i = 0; i < related.Count; i++) {\n            if (related[i] != root)\n                related[i].Accept (this);\n        }\n\n        Pop ();\n    }\n\n    protected override void VisitMultipart (Multipart multipart)\n    {\n        foreach (var part in multipart) {\n            if (part is MultipartAlternative)\n                part.Accept (this);\n            else if (part is MultipartRelated)\n                part.Accept (this);\n            else if (part is TextPart)\n                part.Accept (this);\n        }\n    }\n\n    void HtmlTagCallback (HtmlTagContext ctx, HtmlWriter htmlWriter)\n    {\n        if (ctx.TagId == HtmlTagId.Body && !ctx.IsEmptyElementTag) {\n            if (ctx.IsEndTag) {\n                // end our opening <blockquote>\n                htmlWriter.WriteEndTag (HtmlTagId.BlockQuote);\n\n                // pass the </body> tag through to the output\n                ctx.WriteTag (htmlWriter, true);\n            } else {\n                // pass the <body> tag through to the output\n                ctx.WriteTag (htmlWriter, true);\n\n                // prepend the HTML reply with \"On {DATE}, {SENDER} wrote:\"\n                htmlWriter.WriteStartTag (HtmlTagId.P);\n                htmlWriter.WriteText (GetOnDateSenderWrote (original));\n                htmlWriter.WriteEndTag (HtmlTagId.P);\n\n                // Wrap the original content in a <blockquote>\n                htmlWriter.WriteStartTag (HtmlTagId.BlockQuote);\n                htmlWriter.WriteAttribute (HtmlAttributeId.Style, \"border-left: 1px #ccc solid; margin: 0 0 0 .8ex; padding-left: 1ex;\");\n\n                ctx.InvokeCallbackForEndTag = true;\n            }\n        } else {\n            // pass the tag through to the output\n            ctx.WriteTag (htmlWriter, true);\n        }\n    }\n\n    string QuoteText (string text)\n    {\n        using (var quoted = new StringWriter ()) {\n            quoted.WriteLine (GetOnDateSenderWrote (original));\n\n            using (var reader = new StringReader (text)) {\n                string line;\n\n                while ((line = reader.ReadLine ()) != null) {\n                    quoted.Write (\"> \");\n                    quoted.WriteLine (line);\n                }\n            }\n\n            return quoted.ToString ();\n        }\n    }\n\n    protected override void VisitTextPart (TextPart entity)\n    {\n        string text;\n\n        if (entity.IsHtml) {\n            var converter = new HtmlToHtml {\n                HtmlTagCallback = HtmlTagCallback\n            };\n\n            text = converter.Convert (entity.Text);\n        } else if (entity.IsFlowed) {\n            var converter = new FlowedToText ();\n\n            text = converter.Convert (entity.Text);\n            text = QuoteText (text);\n        } else {\n            // quote the original message text\n            text = QuoteText (entity.Text);\n        }\n\n        var part = new TextPart (entity.ContentType.MediaSubtype.ToLowerInvariant ()) {\n            Text = text\n        };\n\n        Push (part);\n    }\n\n    protected override void VisitMessagePart (MessagePart entity)\n    {\n        // don't descend into message/rfc822 parts\n    }\n}\n```\n\n```csharp\npublic static MimeMessage Reply (MimeMessage message, MailboxAddress from, bool replyToAll)\n{\n    var visitor = new ReplyVisitor (from, replyToAll);\n\n    visitor.Visit (message);\n\n    return visitor.Reply;\n}\n```\n\n### <a name=\"forward-message\">Q: How do I forward a message?</a>\n\nThere are 2 common ways of forwarding a message: attaching the original message as an attachment and inlining\nthe message body much like replying typically does. Which method you choose is up to you.\n\nTo forward a message by attaching it as an attachment, you would do do something like this:\n\n```csharp\npublic static MimeMessage Forward (MimeMessage original, MailboxAddress from, IEnumerable<InternetAddress> to)\n{\n    var message = new MimeMessage ();\n    message.From.Add (from);\n    message.To.AddRange (to);\n\n    // set the forwarded subject\n    if (!original.Subject?.StartsWith (\"FW:\", StringComparison.OrdinalIgnoreCase))\n        message.Subject = \"FW: \" + (original.Subject ?? string.Empty);\n    else\n        message.Subject = original.Subject;\n\n    // create the main textual body of the message\n    var text = new TextPart (\"plain\") { Text = \"Here's the forwarded message:\" };\n\n    // create the message/rfc822 attachment for the original message\n    var rfc822 = new MessagePart { Message = original };\n    \n    // create a multipart/mixed container for the text body and the forwarded message\n    var multipart = new Multipart (\"mixed\");\n    multipart.Add (text);\n    multipart.Add (rfc822);\n\n    // set the multipart as the body of the message\n    message.Body = multipart;\n\n    return message;\n}\n```\n\nTo forward a message by inlining the original message's text content, you can do something like this:\n\n```csharp\npublic static MimeMessage Forward (MimeMessage original, MailboxAddress from, IEnumerable<InternetAddress> to)\n{\n    var message = new MimeMessage ();\n    message.From.Add (from);\n    message.To.AddRange (to);\n\n    // set the forwarded subject\n    if (!original.Subject?.StartsWith (\"FW:\", StringComparison.OrdinalIgnoreCase))\n        message.Subject = \"FW: \" + (original.Subject ?? string.Empty);\n    else\n        message.Subject = original.Subject;\n\n    // quote the original message text\n    using (var text = new StringWriter ()) {\n        text.WriteLine ();\n        text.WriteLine (\"-------- Original Message --------\");\n        text.WriteLine (\"Subject: {0}\", original.Subject ?? string.Empty);\n        text.WriteLine (\"Date: {0}\", DateUtils.FormatDate (original.Date));\n        text.WriteLine (\"From: {0}\", original.From);\n        text.WriteLine (\"To: {0}\", original.To);\n        text.WriteLine ();\n\n        text.Write (original.TextBody);\n\n        message.Body = new TextPart (\"plain\") {\n            Text = text.ToString ()\n        };\n    }\n\n    return message;\n}\n```\n\nKeep in mind that not all messages will have a `TextBody` available, so you'll have to find a way to handle those cases.\n\n### <a name=\"garbled-text\">Q: Why does text show up garbled in my ASP.NET Core / .NET Core / .NET 5 app?</a>\n\n.NET Core (and ASP.NET Core by extension) and .NET >= 5 only provide the Unicode encodings, ASCII and ISO-8859-1 by default.\nOther text encodings are not available to your application unless your application\n[registers](https://docs.microsoft.com/en-us/dotnet/api/system.text.encoding.registerprovider?view=net-5.0) the encoding\nprovider that provides all of the additional encodings.\n\nFirst, add a package reference for the [System.Text.Encoding.CodePages](https://www.nuget.org/packages/System.Text.Encoding.CodePages)\nnuget package to your project and then register the additional text encodings using the following code snippet:\n\n```csharp\nSystem.Text.Encoding.RegisterProvider (System.Text.CodePagesEncodingProvider.Instance);\n```\n\nNote: The above code snippet should be safe to call in .NET Framework versions >= 4.6 as well.\n\n## Specialty\n\n### <a name=\"parse-web-request-form-data\">Q: How would I parse multipart/form-data from an HTTP web request?</a>\n\nSince classes like `HttpWebResponse` take care of parsing the HTTP headers (which includes the `Content-Type`\nheader) and only offer a content stream to consume, MimeKit provides a way to deal with this using the following\ntwo static methods on `MimeEntity`:\n\n```csharp\npublic static MimeEntity Load (ParserOptions options, ContentType contentType, Stream content, CancellationToken cancellationToken = default (CancellationToken));\n\npublic static MimeEntity Load (ContentType contentType, Stream content, CancellationToken cancellationToken = default (CancellationToken));\n```\n\nHere's how you might use these methods:\n\n```csharp\nMimeEntity ParseMultipartFormData (HttpWebResponse response)\n{\n    var contentType = ContentType.Parse (response.ContentType);\n\n    return MimeEntity.Load (contentType, response.GetResponseStream ());\n}\n```\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.068359375,
          "content": "MIT License\n\nCopyright (C) 2012-2024 .NET Foundation and Contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "MimeKit.Coverity.sln",
          "type": "blob",
          "size": 3.26953125,
          "content": "\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio Version 16\nVisualStudioVersion = 16.0.30711.63\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MimeKit\", \"MimeKit\\MimeKit.csproj\", \"{29F68E0E-0119-45CC-B6B4-A0C70FADA4AD}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|Any CPU = Debug|Any CPU\n\t\tRelease|Any CPU = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{29F68E0E-0119-45CC-B6B4-A0C70FADA4AD}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{29F68E0E-0119-45CC-B6B4-A0C70FADA4AD}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{29F68E0E-0119-45CC-B6B4-A0C70FADA4AD}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{29F68E0E-0119-45CC-B6B4-A0C70FADA4AD}.Release|Any CPU.Build.0 = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {FE861017-7B1A-4D73-AAEC-0DEBA21F6C52}\n\tEndGlobalSection\n\tGlobalSection(MonoDevelopProperties) = preSolution\n\t\tPolicies = $0\n\t\t$0.StandardHeader = $1\n\t\t$1.Text = @\\n${FileName}\\n \\nAuthor: ${AuthorName} <${AuthorEmail}>\\n\\nCopyright (c) ${Year} ${CopyrightHolder}\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \"Software\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in\\nall copies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\nTHE SOFTWARE.\\n\n\t\t$1.IncludeInNewFiles = True\n\t\t$0.TextStylePolicy = $4\n\t\t$2.inheritsSet = VisualStudio\n\t\t$2.scope = text/plain\n\t\t$2.FileWidth = 120\n\t\t$2.TabsToSpaces = False\n\t\t$2.EolMarker = Unix\n\t\t$2.inheritsScope = text/plain\n\t\t$0.CSharpFormattingPolicy = $3\n\t\t$3.NamespaceBraceStyle = EndOfLine\n\t\t$3.StructBraceStyle = EndOfLine\n\t\t$3.EnumBraceStyle = EndOfLine\n\t\t$3.AfterDelegateDeclarationParameterComma = True\n\t\t$3.BeforeSizeOfParentheses = True\n\t\t$3.BeforeTypeOfParentheses = True\n\t\t$3.SpacesBeforeBrackets = False\n\t\t$3.SpacesAfterTypecast = True\n\t\t$3.AlignToFirstIndexerArgument = True\n\t\t$3.inheritsSet = Mono\n\t\t$3.inheritsScope = text/x-csharp\n\t\t$3.scope = text/x-csharp\n\t\t$3.NewLineForMembersInObjectInit = True\n\t\t$3.NewLineForMembersInAnonymousTypes = True\n\t\t$3.SpaceAfterCast = True\n\t\t$3.SpaceBeforeOpenSquareBracket = False\n\t\t$4.FileWidth = 120\n\t\t$4.TabsToSpaces = False\n\t\t$4.EolMarker = Unix\n\t\t$4.inheritsSet = VisualStudio\n\t\t$4.inheritsScope = text/plain\n\t\t$4.scope = text/plain\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "MimeKit.sln",
          "type": "blob",
          "size": 4.435546875,
          "content": "\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio Version 17\nVisualStudioVersion = 17.3.32825.248\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"Solution Items\", \"Solution Items\", \"{4B4EB921-F77E-4A51-897F-BBA7FA3E3468}\"\n\tProjectSection(SolutionItems) = preProject\n\t\t.editorconfig = .editorconfig\n\tEndProjectSection\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MimeKit\", \"MimeKit\\MimeKit.csproj\", \"{E8667DCE-A5BB-4D30-9815-FC8959E447F5}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"UnitTests\", \"UnitTests\\UnitTests.csproj\", \"{88EC8D73-8099-4DD6-B78B-C21FCED97EA1}\"\n\tProjectSection(ProjectDependencies) = postProject\n\t\t{E8667DCE-A5BB-4D30-9815-FC8959E447F5} = {E8667DCE-A5BB-4D30-9815-FC8959E447F5}\n\tEndProjectSection\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Benchmarks\", \"Benchmarks\\Benchmarks.csproj\", \"{AA778CE1-53AF-4E28-8282-56EAB3A444FC}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|Any CPU = Debug|Any CPU\n\t\tRelease|Any CPU = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{E8667DCE-A5BB-4D30-9815-FC8959E447F5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{E8667DCE-A5BB-4D30-9815-FC8959E447F5}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{E8667DCE-A5BB-4D30-9815-FC8959E447F5}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{E8667DCE-A5BB-4D30-9815-FC8959E447F5}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{88EC8D73-8099-4DD6-B78B-C21FCED97EA1}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{88EC8D73-8099-4DD6-B78B-C21FCED97EA1}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{88EC8D73-8099-4DD6-B78B-C21FCED97EA1}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{88EC8D73-8099-4DD6-B78B-C21FCED97EA1}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{AA778CE1-53AF-4E28-8282-56EAB3A444FC}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{AA778CE1-53AF-4E28-8282-56EAB3A444FC}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{AA778CE1-53AF-4E28-8282-56EAB3A444FC}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{AA778CE1-53AF-4E28-8282-56EAB3A444FC}.Release|Any CPU.Build.0 = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {835CB316-68E1-4B7A-9392-920A18AD35CC}\n\tEndGlobalSection\n\tGlobalSection(MonoDevelopProperties) = preSolution\n\t\tPolicies = $0\n\t\t$0.StandardHeader = $1\n\t\t$1.Text = @\\n${FileName}\\n \\nAuthor: ${AuthorName} <${AuthorEmail}>\\n\\nCopyright (c) ${Year} ${CopyrightHolder}\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \"Software\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in\\nall copies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\nTHE SOFTWARE.\\n\n\t\t$0.TextStylePolicy = $3\n\t\t$3.FileWidth = 120\n\t\t$3.TabsToSpaces = False\n\t\t$3.inheritsSet = null\n\t\t$3.inheritsScope = text/plain\n\t\t$3.scope = text/x-csharp\n\t\t$0.CSharpFormattingPolicy = $4\n\t\t$4.SpaceAfterCast = True\n\t\t$4.scope = text/x-csharp\n\t\t$4.IndentSwitchSection = False\n\t\t$4.NewLinesForBracesInProperties = False\n\t\t$4.NewLinesForBracesInAccessors = False\n\t\t$4.NewLinesForBracesInAnonymousMethods = False\n\t\t$4.NewLinesForBracesInControlBlocks = False\n\t\t$4.NewLinesForBracesInAnonymousTypes = False\n\t\t$4.NewLinesForBracesInObjectCollectionArrayInitializers = False\n\t\t$4.NewLinesForBracesInLambdaExpressionBody = False\n\t\t$4.NewLineForElse = False\n\t\t$4.NewLineForCatch = False\n\t\t$4.NewLineForFinally = False\n\t\t$4.NewLineForClausesInQuery = False\n\t\t$4.SpacingAfterMethodDeclarationName = True\n\t\t$4.SpaceAfterMethodCallName = True\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "MimeKit",
          "type": "tree",
          "content": null
        },
        {
          "name": "MimeKitLite.sln",
          "type": "blob",
          "size": 1.3134765625,
          "content": "\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio Version 16\nVisualStudioVersion = 16.0.30114.105\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"Solution Items\", \"Solution Items\", \"{A56B6ECE-F1EE-41A2-A92B-18D2BDAFB6A2}\"\n\tProjectSection(SolutionItems) = preProject\n\t\t.editorconfig = .editorconfig\n\tEndProjectSection\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MimeKitLite\", \"MimeKit\\MimeKitLite.csproj\", \"{23F999AF-CF50-42FF-A011-D56D68E60FB9}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|Any CPU = Debug|Any CPU\n\t\tRelease|Any CPU = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{23F999AF-CF50-42FF-A011-D56D68E60FB9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{23F999AF-CF50-42FF-A011-D56D68E60FB9}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{23F999AF-CF50-42FF-A011-D56D68E60FB9}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{23F999AF-CF50-42FF-A011-D56D68E60FB9}.Release|Any CPU.Build.0 = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {3E07F961-6E08-4E6A-AF55-EC1428E15EAD}\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 51.419921875,
          "content": "# MimeKit\n\n|  Package  |Latest Release|Latest Build|\n|:----------|:------------:|:----------:|\n|**MimeKit**|[![MimeKit NuGet](https://img.shields.io/nuget/v/MimeKit.svg?logo=nuget&style=flat-square)](https://www.nuget.org/packages/MimeKit)![MimeKit NuGet Downloads](https://img.shields.io/nuget/dt/MimeKit.svg?style=flat-square)|[![MimeKit MyGet](https://img.shields.io/myget/mimekit/v/MimeKit.svg?logo=nuget&style=flat-square&label=myget)](https://www.myget.org/feed/mimekit/package/nuget/MimeKit)|\n|**MimeKitLite**|[![MimeKitLite NuGet](https://img.shields.io/nuget/v/MimeKitLite.svg?logo=nuget&style=flat-square)](https://www.nuget.org/packages/MimeKitLite)![MimeKitLite NuGet Downloads](https://img.shields.io/nuget/dt/MimeKitLite.svg?style=flat-square)||\n|**MailKit**|[![MailKit NuGet](https://img.shields.io/nuget/v/MailKit.svg?logo=nuget&style=flat-square)](https://www.nuget.org/packages/MailKit)![MailKit NuGet Downloads](https://img.shields.io/nuget/dt/MailKit.svg?style=flat-square)|[![MailKit MyGet](https://img.shields.io/myget/mimekit/v/MailKit.svg?logo=nuget&style=flat-square&label=myget)](https://www.myget.org/feed/mimekit/package/nuget/MailKit)|\n|**MailKitLite**|[![MailKitLite NuGet](https://img.shields.io/nuget/v/MailKitLite.svg?logo=nuget&style=flat-square)](https://www.nuget.org/packages/MailKitLite)![MailKitLite NuGet Downloads](https://img.shields.io/nuget/dt/MailKitLite.svg?style=flat-square)||\n\n\n|   Platform   |Build Status|Code Coverage|Static Analysis|\n|:-------------|:----------:|:-----------:|:-------------:|\n|**Linux/Mac**|[![Build Status](https://github.com/jstedfast/MimeKit/actions/workflows/main.yml/badge.svg?event=push)](https://github.com/jstedfast/MimeKit/actions/workflows/main.yml)|[![Code Coverage](https://coveralls.io/repos/jstedfast/MimeKit/badge.svg?branch=master)](https://coveralls.io/r/jstedfast/MimeKit?branch=master)|[![Static Analysis](https://scan.coverity.com/projects/3201/badge.svg)](https://scan.coverity.com/projects/3201)|\n|**Windows**  |[![Build Status](https://github.com/jstedfast/MimeKit/actions/workflows/main.yml/badge.svg?event=push)](https://github.com/jstedfast/MimeKit/actions/workflows/main.yml)|[![Code Coverage](https://coveralls.io/repos/jstedfast/MimeKit/badge.svg?branch=master)](https://coveralls.io/r/jstedfast/MimeKit?branch=master)|[![Static Analysis](https://scan.coverity.com/projects/3201/badge.svg)](https://scan.coverity.com/projects/3201)|\n\n## What is MimeKit?\n\nMimeKit is a C# library which may be used for the creation and parsing of messages using the Multipurpose\nInternet Mail Extension (MIME), as defined by [numerous IETF specifications](https://github.com/jstedfast/MimeKit/blob/master/RFCs.md).\n\n## Donate\n\nMimeKit is a personal open source project that I have put thousands of hours into perfecting with the\ngoal of making it the very best MIME parser framework for .NET. I need your help to achieve this.\n\nDonating helps pay for things such as web hosting, domain registration and licenses for developer tools\nsuch as a performance profiler, memory profiler, a static code analysis tool, and more. It also helps\nmotivate me to continue working on the project.\n\n<a href=\"https://github.com/sponsors/jstedfast\" _target=\"blank\"><img alt=\"Click here to lend your support to MimeKit by making a donation!\" src=\"https://www.paypal.com/en_US/i/btn/x-click-but21.gif\"></a>\n\n## History\n\nAs a developer and user of email clients, I had come to realize that the vast majority of email client\n(and server) software had less-than-satisfactory MIME implementations. More often than not these email clients\ncreated broken MIME messages and/or would incorrectly try to parse a MIME message thus subtracting from the full\nbenefits that MIME was meant to provide. MimeKit is meant to address this issue by following the MIME specification\nas closely as possible while also providing programmers with an extremely easy to use high-level API.\n\nThis led me, at first, to implement another MIME parser library called [GMime](https://github.com/jstedfast/gmime)\nwhich is implemented in C and later added a C# binding called GMime-Sharp.\n\nNow that I typically find myself working in C# rather than lower level languages like C, I decided to\nbegin writing a new parser in C# which would not depend on GMime. This would also allow me to have more\nflexibility in that I'd be able to use Generics and create a more .NET-compliant API.\n\n## Performance\n\nWhile mainstream beliefs may suggest that C# can never be as fast as C, it turns out that with a bit of creative\nparser design and a few clever optimizations \n<sup>[[1](http://jeffreystedfast.blogspot.com/2013/09/optimization-tips-tricks-used-by.html)]\n[[2](http://jeffreystedfast.blogspot.com/2013/10/optimization-tips-tricks-used-by.html)]</sup>, MimeKit's\nperformance is actually [on par with GMime](http://jeffreystedfast.blogspot.com/2014/03/gmime-gets-speed-boost.html).\n\nSince GMime is pretty well-known as a high-performance native MIME parser and MimeKit more-or-less matches GMime's\nperformance, it stands to reason that MimeKit is likely unsurpassed in performance in the .NET MIME parser space.\n\nFor a comparison, as I [blogged here](http://jeffreystedfast.blogspot.com/2013/10/optimization-tips-tricks-used-by.html)\n(I have since optimized MimeKit by at least another 30%), MimeKit is more than 25x faster than OpenPOP.NET, 75x\nfaster than SharpMimeTools, and 65x faster than regex-based parsers. Even the commercial MIME parser offerings such\nas LimiLabs' Mail.dll and NewtonIdeas' Mime4Net cannot even come close to matching MimeKit's performance (they are\nboth orders of magnitude slower than MimeKit).\n\nFor comparison purposes, I've published a [MIME parser benchmark](https://github.com/jstedfast/MimeParserBenchmark)\nto make it easier for anyone else to compare the performance of MimeKit to their favourite MIME parser.\n\nHere are the results:\n\n```\nParsing startrek.msg (1000 iterations):\nMimeKit:        0.6989221 seconds\nOpenPop:        25.3056064 seconds\nAE.Net.Mail:    17.5971438 seconds\nMailSystem.NET: 26.3891218 seconds\nMIMER:          76.4538978 seconds\n\nParsing xamarin3.msg (1000 iterations):\nMimeKit:        3.4215505 seconds\nOpenPop:        159.3308053 seconds\nAE.Net.Mail:    132.3044291 seconds\nMailSystem.NET: 133.5832078 seconds\nMIMER:          784.433441 seconds\n```\n\nHow does your MIME parser compare?\n\n\n## License Information\n\n```\nMIT License\n\nCopyright (C) 2012-2024 .NET Foundation and Contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n```\n\n## Installing via NuGet\n\nThe easiest way to install MimeKit is via [NuGet](https://www.nuget.org/packages/MimeKit/).\n\nIn Visual Studio's [Package Manager Console](https://docs.nuget.org/docs/start-here/using-the-package-manager-console),\nenter the following command:\n\n```powershell\nInstall-Package MimeKit\n```\n\n## Getting the Source Code\n\nFirst, you'll need to clone MimeKit from my GitHub repository. To do this using the command-line version of Git,\nyou'll need to issue the following command in your terminal:\n\n```bash\ngit clone --recursive https://github.com/jstedfast/MimeKit.git\n```\n\nIf you are using [TortoiseGit](https://tortoisegit.org) on Windows, you'll need to right-click in the directory\nwhere you'd like to clone MimeKit and select **Git Clone...** in the menu. Once you do that, you'll get the\nfollowing dialog:\n\n![Download the source code using TortoiseGit](https://github.com/jstedfast/MimeKit/blob/master/images/clone.png)\n\nFill in the areas outlined in red and then click **OK**. This will recursively clone MimeKit onto your local machine.\n\n## Updating the Source Code\n\nOccasionally you might want to update your local copy of the source code if I have made changes to MimeKit since you\ndownloaded the source code in the step above. To do this using the command-line version fo Git, you'll need to issue\nthe following commands in your terminal within the MimeKit directory:\n\n```bash\ngit pull\ngit submodule update\n```\n\nIf you are using [TortoiseGit](https://tortoisegit.org) on Windows, you'll need to right-click on the MimeKit\ndirectory and select **Git Sync...** in the menu. Once you do that, you'll need to click the **Pull** and\n**Submodule Update** buttons in the following dialog:\n\n![Update the source code using TortoiseGit](https://github.com/jstedfast/MimeKit/blob/master/images/update.png)\n\n## Building\n\nIn the top-level MimeKit directory, there are a number of solution files; they are:\n\n* **MimeKit.sln** - includes projects for .NET Framework 4.6.2/4.7/4.8, .NETStandard 2.0/2.1, .NET 6.0 as well as the unit tests.\n* **MimeKitLite.sln** - includes projects for the stripped-down versions of MimeKit that drop support for crypto.\n\nOnce you've opened the appropriate MimeKit solution file in [Visual Studio](https://www.visualstudio.com/downloads/),\nyou can choose the **Debug** or **Release** build configuration and then build.\n\nBoth Visual Studio 2022 and Visual Studio 2019 should be able to build MimeKit without any issues, but older versions such as\nVisual Studio 2015 and 2017 will require modifications to the projects in order to build correctly. It has been reported that adding\nNuGet package references to [Microsoft.Net.Compilers](https://www.nuget.org/packages/Microsoft.Net.Compilers/) >= 3.6.0\nand [System.ValueTuple](https://www.nuget.org/packages/System.ValueTuple/) >= 4.5.0 will allow MimeKit to build successfully.\n\nNote: The **Release** build will generate the xml API documentation, but the **Debug** build will not.\n\n## Using MimeKit\n\n### Parsing Messages\n\nOne of the more common operations that MimeKit is meant for is parsing email messages from arbitrary streams.\nThere are two ways of accomplishing this task.\n\nThe first way is to use one of the [Load](https://www.mimekit.net/docs/html/Overload_MimeKit_MimeMessage_Load.htm) methods\non `MimeMessage`:\n\n```csharp\n// Load a MimeMessage from a stream\nvar message = MimeMessage.Load (stream);\n```\n\nOr you can load a message from a file path:\n\n```csharp\n// Load a MimeMessage from a file path\nvar message = MimeMessage.Load (\"message.eml\");\n```\n\nThe second way is to use the [MimeParser](https://www.mimekit.net/docs/html/T_MimeKit_MimeParser.htm) class. For the most\npart, using the `MimeParser` directly is not necessary unless you wish to parse a Unix mbox file stream. However, this is\nhow you would do it:\n\n```csharp\n// Load a MimeMessage from a stream\nvar parser = new MimeParser (stream, MimeFormat.Entity);\nvar message = parser.ParseMessage ();\n```\n\nFor Unix mbox file streams, you would use the parser like this:\n\n```csharp\n// Load every message from a Unix mbox\nvar parser = new MimeParser (stream, MimeFormat.Mbox);\nwhile (!parser.IsEndOfStream) {\n    var message = parser.ParseMessage ();\n\n    // do something with the message\n}\n```\n\n### Getting the Body of a Message\n\nA common misunderstanding about email is that there is a well-defined message body and then a list\nof attachments. This is not really the case. The reality is that MIME is a tree structure of content,\nmuch like a file system.\n\nLuckily, MIME does define a set of general rules for how mail clients should interpret this tree\nstructure of MIME parts. The `Content-Disposition` header is meant to provide hints to the receiving\nclient as to which parts are meant to be displayed as part of the message body and which are meant\nto be interpreted as attachments.\n\nThe `Content-Disposition` header will generally have one of two values: `inline` or `attachment`.\n\nThe meaning of these values should be fairly obvious. If the value is `attachment`, then the content\nof said MIME part is meant to be presented as a file attachment separate from the core message.\nHowever, if the value is `inline`, then the content of that MIME part is meant to be displayed inline\nwithin the mail client's rendering of the core message body. If the `Content-Disposition` header does\nnot exist, then it should be treated as if the value were `inline`.\n\nTechnically, every part that lacks a `Content-Disposition` header or that is marked as `inline`, then,\nis part of the core message body.\n\nThere's a bit more to it than that, though.\n\nModern MIME messages will often contain a `multipart/alternative` MIME container which will generally contain\na `text/plain` and `text/html` version of the text that the sender wrote. The `text/html` version is typically\nformatted much closer to what the sender saw in his or her WYSIWYG editor than the `text/plain` version.\n\nThe reason for sending the message text in both formats is that not all mail clients are capable of displaying\nHTML.\n\nThe receiving client should only display one of the alternative views contained within the `multipart/alternative`\ncontainer. Since alternative views are listed in order of least faithful to most faithful with what the sender\nsaw in his or her WYSIWYG editor, the receiving client *should* walk over the list of alternative views starting\nat the end and working backwards until it finds a part that it is capable of displaying.\n\nExample:\n\n```text\nmultipart/alternative\n  text/plain\n  text/html\n```\n\nAs seen in the example above, the `text/html` part is listed last because it is the most faithful to\nwhat the sender saw in his or her WYSIWYG editor when writing the message.\n\nTo make matters even more complicated, sometimes modern mail clients will use a `multipart/related`\nMIME container instead of a simple `text/html` part in order to embed images and other content\nwithin the HTML.\n\nExample:\n\n```text\nmultipart/alternative\n  text/plain\n  multipart/related\n    text/html\n    image/jpeg\n    video/mp4\n    image/png\n```\n\nIn the example above, one of the alternative views is a `multipart/related` container which contains\nan HTML version of the message body that references the sibling video and images.\n\nNow that you have a rough idea of how a message is structured and how to interpret various MIME entities,\nthe next step is learning how to traverse the MIME tree using MimeKit.\n\nNote: For your convenience, MimeKit's `MimeMessage` class has two properties that can help you get the\n`text/plain` or `text/html` version of the message body. These are `TextBody` and `HtmlBody`,\nrespectively.\n\nKeep in mind, however, that at least with the `HtmlBody` property, it may be that the HTML part is\na child of a `multipart/related`, allowing it to refer to images and other types of media that\nare also contained within that `multipart/related` entity. This property is really only a convenience\nproperty and is not a really good substitute for traversing the MIME structure yourself so that you\nmay properly interpret related content.\n\n### Traversing a MimeMessage\n\nThe `MimeMessage.Body` is the top-level MIME entity of the message. Generally, it will either be a\n`TextPart` or a `Multipart`.\n\nAs an example, if you wanted to rip out all of the attachments of a message, your code might look\nsomething like this:\n\n```csharp\nvar attachments = new List<MimePart> ();\nvar multiparts = new List<Multipart> ();\nvar iter = new MimeIterator (message);\n\n// collect our list of attachments and their parent multiparts\nwhile (iter.MoveNext ()) {\n    var multipart = iter.Parent as Multipart;\n    var part = iter.Current as MimePart;\n\n    if (multipart != null && part != null && part.IsAttachment) {\n        // keep track of each attachment's parent multipart\n        multiparts.Add (multipart);\n        attachments.Add (part);\n    }\n}\n\n// now remove each attachment from its parent multipart...\nfor (int i = 0; i < attachments.Count; i++)\n    multiparts[i].Remove (attachments[i]);\n```\n\n### Quick and Dirty Enumeration of Message Body Parts\n\nIf you would rather skip the proper way of traversing a MIME tree, another option that MimeKit provides\nis a simple enumerator over the message's body parts in a flat (depth-first) list.\n\nYou can access this flat list via the `BodyParts` property, like so:\n\n```csharp\nforeach (var part in message.BodyParts) {\n   // do something\n}\n```\n\nAnother helper property on the MimeMessage class is the `Attachments` property which works\nmuch the same way as the `BodyParts` property except that it will only contain MIME parts\nwhich have a `Content-Disposition` header value that is set to `attachment`.\n\n### Getting the Decoded Content of a MIME Part\n\nAt some point, you're going to want to extract the decoded content of a `MimePart` (such as an image) and\nsave it to disk or feed it to a UI control to display it.\n\nOnce you've found the `MimePart` object that you'd like to extract the content of, here's how you can\nsave the decoded content to a file:\n\n```csharp\n// This will get the name of the file as specified by the sending mail client.\n// Note: this value *may* be null, so you'll want to handle that case in your code.\nvar fileName = part.FileName;\n\nusing (var stream = File.Create (fileName)) {\n    part.Content.DecodeTo (stream);\n}\n```\n\nYou can also get access to the original raw content by \"opening\" the `Content`. This might be useful\nif you want to pass the content off to a UI control that can do its own loading from a stream.\n\n```csharp\nusing (var stream = part.Content.Open ()) {\n    // At this point, you can now read from the stream as if it were the original,\n    // raw content. Assuming you have an image UI control that could load from a\n    // stream, you could do something like this:\n    imageControl.Load (stream);\n}\n```\n\nThere are a number of useful filters that can be applied to a `FilteredStream`, so if you find this type of\ninterface appealing, I suggest taking a look at the available filters in the `MimeKit.IO.Filters` namespace\nor even write your own! The possibilities are limited only by your imagination.\n\n### Creating a Simple Message\n\nCreating MIME messages using MimeKit is really trivial.\n\n```csharp\nvar message = new MimeMessage ();\nmessage.From.Add (new MailboxAddress (\"Joey\", \"joey@friends.com\"));\nmessage.To.Add (new MailboxAddress (\"Alice\", \"alice@wonderland.com\"));\nmessage.Subject = \"How you doin?\";\n\nmessage.Body = new TextPart (\"plain\") {\n    Text = @\"Hey Alice,\n\nWhat are you up to this weekend? Monica is throwing one of her parties on\nSaturday and I was hoping you could make it.\n\nWill you be my +1?\n\n-- Joey\n\"\n};\n```\n\nA `TextPart` is a leaf-node MIME part with a text media-type. The first argument to the `TextPart` constructor\nspecifies the media-subtype, in this case, \"plain\". Another media subtype you are probably familiar with\nis the \"html\" subtype. Some other examples include \"enriched\", \"rtf\", and \"csv\".\n\nThe `Text` property is the easiest way to both get and set the string content of the MIME part.\n\n### Creating a Message with Attachments\n\nAttachments are just like any other `MimePart`, the only difference is that they typically have\na `Content-Disposition` header with a value of \"attachment\" instead of \"inline\" or no\n`Content-Disposition` header at all.\n\nTypically, when a mail client adds attachments to a message, it will create a `multipart/mixed`\npart and add the text body part and all of the file attachments to the `multipart/mixed.`\n\nHere's how you can do that with MimeKit:\n\n```csharp\nvar message = new MimeMessage ();\nmessage.From.Add (new MailboxAddress (\"Joey\", \"joey@friends.com\"));\nmessage.To.Add (new MailboxAddress (\"Alice\", \"alice@wonderland.com\"));\nmessage.Subject = \"How you doin?\";\n\n// create our message text, just like before (except don't set it as the message.Body)\nvar body = new TextPart (\"plain\") {\n    Text = @\"Hey Alice,\n\nWhat are you up to this weekend? Monica is throwing one of her parties on\nSaturday and I was hoping you could make it.\n\nWill you be my +1?\n\n-- Joey\n\"\n};\n\n// create an image attachment for the file located at path\nvar attachment = new MimePart (\"image\", \"gif\") {\n    Content = new MimeContent (File.OpenRead (path), ContentEncoding.Default),\n    ContentDisposition = new ContentDisposition (ContentDisposition.Attachment),\n    ContentTransferEncoding = ContentEncoding.Base64,\n    FileName = Path.GetFileName (path)\n};\n\n// now create the multipart/mixed container to hold the message text and the\n// image attachment\nvar multipart = new Multipart (\"mixed\");\nmultipart.Add (body);\nmultipart.Add (attachment);\n\n// now set the multipart/mixed as the message body\nmessage.Body = multipart;\n```\n\nOf course, that is just a simple example. A lot of modern mail clients such as Outlook or Thunderbird will \nsend out both a `text/html` and a `text/plain` version of the message text. To do this, you'd create a\n`TextPart` for the `text/plain` part and another `TextPart` for the `text/html` part and then add them to a\n`multipart/alternative` like so:\n\n```csharp\nvar attachment = CreateAttachment ();\nvar plain = CreateTextPlainPart ();\nvar html = CreateTextHtmlPart ();\n\n// Note: it is important that the text/html part is added second, because it is the\n// most expressive version and (probably) the most faithful to the sender's WYSIWYG \n// editor.\nvar alternative = new Multipart (\"alternative\");\nalternative.Add (plain);\nalternative.Add (html);\n\n// now create the multipart/mixed container to hold the multipart/alternative\n// and the image attachment\nvar multipart = new Multipart (\"mixed\");\nmultipart.Add (alternative);\nmultipart.Add (attachment);\n\n// now set the multipart/mixed as the message body\nmessage.Body = multipart;\n```\n\n### Creating a Message Using a BodyBuilder (not Arnold Schwarzenegger)\n\nIf you are used to System.Net.Mail's API for creating messages, you will probably find using a `BodyBuilder`\nmuch more friendly than manually creating the tree of MIME parts. Here's how you could create a message body\nusing a `BodyBuilder`:\n\n```csharp\nvar message = new MimeMessage ();\nmessage.From.Add (new MailboxAddress (\"Joey\", \"joey@friends.com\"));\nmessage.To.Add (new MailboxAddress (\"Alice\", \"alice@wonderland.com\"));\nmessage.Subject = \"How you doin?\";\n\nvar builder = new BodyBuilder ();\n\n// Set the plain-text version of the message text\nbuilder.TextBody = @\"Hey Alice,\n\nWhat are you up to this weekend? Monica is throwing one of her parties on\nSaturday and I was hoping you could make it.\n\nWill you be my +1?\n\n-- Joey\n\";\n\n// generate a Content-Id for the image we'll be referencing\nvar contentId = MimeUtils.GenerateMessageId ();\n\n// Set the html version of the message text\nbuilder.HtmlBody = string.Format (@\"<p>Hey Alice,<br>\n<p>What are you up to this weekend? Monica is throwing one of her parties on\nSaturday and I was hoping you could make it.<br>\n<p>Will you be my +1?<br>\n<p>-- Joey<br>\n<center><img src=\"\"cid:{0}\"\" alt=\"\"selfie.jpg\"\"></center>\", contentId);\n\n// Since selfie.jpg is referenced from the html text, we'll need to add it\n// to builder.LinkedResources and then set the Content-Id header value\nbuilder.LinkedResources.Add (@\"C:\\Users\\Joey\\Documents\\Selfies\\selfie.jpg\");\nbuilder.LinkedResources[0].ContentId = contentId;\n\n// We may also want to attach a calendar event for Monica's party...\nbuilder.Attachments.Add (@\"C:\\Users\\Joey\\Documents\\party.ics\");\n\n// Now we just need to set the message body and we're done\nmessage.Body = builder.ToMessageBody ();\n```\n\n### Preparing to use MimeKit's S/MIME support\n\nBefore you can begin using MimeKit's S/MIME support, you will need to decide which\ndatabase to use for certificate storage.\n\nIf you are targetting any of the Xamarin platforms (or Linux), you won't need to do\nanything (although you certainly can if you want to) because, by default, I've\nconfigured MimeKit to use the Mono.Data.Sqlite binding to SQLite.\n\nIf you are on any of the Windows platforms, however, you'll need to decide on whether\nto use one of the conveniently available backends such as the `WindowsSecureMimeContext`\nbackend or the `TemporarySecureMimeContext` backend or else you'll need to pick a\nSystem.Data provider such as\n[System.Data.SQLite](https://www.nuget.org/packages/System.Data.SQLite) to use with\nthe `DefaultSecureMimeContext` base class.\n\nIf you opt for using the `DefaultSecureMimeContext` backend, you'll need to implement\nyour own `DefaultSecureMimeContext` subclass. Luckily, it's very simple to do.\nAssuming you've chosen System.Data.SQLite, here's how you'd implement your own\n`DefaultSecureMimeContext` class:\n\n```csharp\nusing System.Data.SQLite;\nusing MimeKit.Cryptography;\n\nusing MyAppNamespace {\n    class MySecureMimeContext : DefaultSecureMimeContext\n    {\n        public MySecureMimeContext () : base (OpenDatabase (\"C:\\\\wherever\\\\certdb.sqlite\"))\n        {\n        }\n\n        static IX509CertificateDatabase OpenDatabase (string fileName)\n        {\n            var builder = new SQLiteConnectionStringBuilder ();\n            builder.DateTimeFormat = SQLiteDateFormats.Ticks;\n            builder.DataSource = fileName;\n\n            if (!File.Exists (fileName))\n                SQLiteConnection.CreateFile (fileName);\n\n            var sqlite = new SQLiteConnection (builder.ConnectionString);\n            sqlite.Open ();\n\n            return new SqliteCertificateDatabase (sqlite, \"password\");\n        }\n    }\n}\n```\n\nNow that you've implemented your own `SecureMimeContext`, you'll want to register it with MimeKit:\n\n```csharp\nCryptographyContext.Register (typeof (MySecureMimeContext));\n```\n\nNow you are ready to encrypt, decrypt, sign and verify S/MIME messages!\n\nNote: If you choose to use the `WindowsSecureMimeContext` or `TemporarySecureMimeContext` backend,\nyou should register that class instead.\n\n### Preparing to use MimeKit's PGP/MIME support\n\nLike with S/MIME support, you also need to register your own `OpenPgpContext`. Unlike S/MIME, however,\nyou don't need to choose a database if you subclass `GnuPGContext` because it uses GnuPG's PGP keyrings\nto load and store public and private keys. If you choose to subclass `GnuPGContext`, the only thing you\nyou need to do is implement a password callback method:\n\n```csharp\nusing MimeKit.Cryptography;\n\nnamespace MyAppNamespace {\n    class MyGnuPGContext : GnuPGContext\n    {\n        public MyGnuPgContext () : base ()\n        {\n        }\n\n        protected override string GetPasswordForKey (PgpSecretKey key)\n        {\n            // prompt the user (or a secure password cache) for the password for the specified secret key.\n            return \"password\";\n        }\n    }\n}\n```\n\nOnce again, to register your `OpenPgpContext`, you can use the following code snippet:\n\n```csharp\nCryptographyContext.Register (typeof (MyGnuPGContext));\n```\n\nNow you are ready to encrypt, decrypt, sign and verify PGP/MIME messages!\n\n### Encrypting Messages with S/MIME\n\nS/MIME uses an `application/pkcs7-mime` MIME part to encapsulate encrypted content (as well as other things).\n\n```csharp\nvar joey = new MailboxAddress (\"Joey\", \"joey@friends.com\");\nvar alice = new MailboxAddress (\"Alice\", \"alice@wonderland.com\");\n\nvar message = new MimeMessage ();\nmessage.From.Add (joey);\nmessage.To.Add (alice);\nmessage.Subject = \"How you doin?\";\n\n// create our message body (perhaps a multipart/mixed with the message text and some\n// image attachments, for example)\nvar body = CreateMessageBody ();\n\n// now to encrypt our message body using our custom S/MIME cryptography context\nusing (var ctx = new MySecureMimeContext ()) {\n    // Note: this assumes that \"Alice\" has an S/MIME certificate with an X.509\n    // Subject Email identifier that matches her email address. If she doesn't,\n    // try using a SecureMailboxAddress which allows you to specify the\n    // fingerprint of her certificate to use for lookups.\n    message.Body = ApplicationPkcs7Mime.Encrypt (ctx, message.To.Mailboxes, body);\n}\n```\n\n### Decrypting S/MIME Messages\n\nAs mentioned earlier, S/MIME uses an `application/pkcs7-mime` part with an \"smime-type\" parameter with a value of\n\"enveloped-data\" to encapsulate the encrypted content.\n\nThe first thing you must do is find the `ApplicationPkcs7Mime` part (see the section on traversing MIME parts).\n\n```csharp\nif (entity is ApplicationPkcs7Mime) {\n    var pkcs7 = (ApplicationPkcs7Mime) entity;\n\n    if (pkcs7.SecureMimeType == SecureMimeType.EnvelopedData)\n        return pkcs7.Decrypt ();\n}\n```\n\n### Encrypting Messages with PGP/MIME\n\nUnlike S/MIME, PGP/MIME uses `multipart/encrypted` to encapsulate its encrypted data.\n\n```csharp\nvar joey = new MailboxAddress (\"Joey\", \"joey@friends.com\");\nvar alice = new MailboxAddress (\"Alice\", \"alice@wonderland.com\");\n\nvar message = new MimeMessage ();\nmessage.From.Add (joey);\nmessage.To.Add (alice);\nmessage.Subject = \"How you doin?\";\n\n// create our message body (perhaps a multipart/mixed with the message text and some\n// image attachments, for example)\nvar body = CreateMessageBody ();\n\n// now to encrypt our message body using our custom PGP/MIME cryptography context\nusing (var ctx = new MyGnuPGContext ()) {\n    // Note: this assumes that \"Alice\" has a public PGP key that matches her email\n    // address. If she doesn't, try using a SecureMailboxAddress which allows you\n    // to specify the fingerprint of her public PGP key to use for lookups.\n    message.Body = MultipartEncrypted.Encrypt (ctx, message.To.Mailboxes, body);\n}\n```\n\n### Decrypting PGP/MIME Messages\n\nAs mentioned earlier, PGP/MIME uses a `multipart/encrypted` part to encapsulate the encrypted content.\n\nA `multipart/encrypted` contains exactly 2 parts: the first `MimeEntity` is the version information while the\nsecond `MimeEntity` is the actual encrypted content and will typically be an `application/octet-stream`.\n\nThe first thing you must do is find the `MultipartEncrypted` part (see the section on traversing MIME parts).\n\n```csharp\nif (entity is MultipartEncrypted) {\n    var encrypted = (MultipartEncrypted) entity;\n\n    return encrypted.Decrypt ();\n}\n```\n\n### Digitally Signing Messages with S/MIME or PGP/MIME\n\nBoth S/MIME and PGP/MIME use a `multipart/signed` to contain the signed content and the detached signature data.\n\nHere's how you might digitally sign a message using S/MIME:\n\n```csharp\nvar joey = new MailboxAddress (\"Joey\", \"joey@friends.com\");\nvar alice = new MailboxAddress (\"Alice\", \"alice@wonderland.com\");\n\nvar message = new MimeMessage ();\nmessage.From.Add (joey);\nmessage.To.Add (alice);\nmessage.Subject = \"How you doin?\";\n\n// create our message body (perhaps a multipart/mixed with the message text and some\n// image attachments, for example)\nvar body = CreateMessageBody ();\n\n// now to digitally sign our message body using our custom S/MIME cryptography context\nusing (var ctx = new MySecureMimeContext ()) {\n    // Note: this assumes that \"Joey\" has an S/MIME signing certificate and private key\n    // with an X.509 Subject Email identifier that matches Joey's email address.\n    message.Body = MultipartSigned.Create (ctx, joey, DigestAlgorithm.Sha1, body);\n}\n```\n\nFor S/MIME, if you have a way for the user to configure which S/MIME certificate to use\nas their signing certificate, you could also do something more like this:\n\n```csharp\n// now to digitally sign our message body using our custom S/MIME cryptography context\nusing (var ctx = new MySecureMimeContext ()) {\n    var certificate = GetJoeysX509Certificate ();\n    var signer = new CmsSigner (certificate);\n    signer.DigestAlgorithm = DigestAlgorithm.Sha1;\n\n    message.Body = MultipartSigned.Create (ctx, signer, body);\n}\n```\n\nIf you'd prefer to use PGP instead of S/MIME, things work almost exactly the same except that you\nwould use an OpenPGP cryptography context. For example, you might use a subclass of the\n`GnuPGContext` that comes with MimeKit if you want to re-use the user's GnuPG keyrings (you can't\nuse `GnuPGContext` directly because it has no way of prompting the user for their passphrase).\n\nFor the sake of this example, let's pretend that you've written a minimal subclass of\n`MimeKit.Cryptography.GnuPGContext` that only overrides the `GetPassword()` method and\nthat this subclass is called `MyGnuPGContext`.\n\n```csharp\n// now to digitally sign our message body using our custom OpenPGP cryptography context\nusing (var ctx = new MyGnuPGContext ()) {\n    // Note: this assumes that \"Joey\" has a PGP key that matches his email address.\n    message.Body = MultipartSigned.Create (ctx, joey, DigestAlgorithm.Sha1, body);\n}\n```\n\nJust like S/MIME, however, you can also do your own PGP key lookups instead of\nrelying on email addresses to match up with the user's private key.\n\n```csharp\n// now to digitally sign our message body using our custom OpenPGP cryptography context\nusing (var ctx = new MyGnuPGContext ()) {\n    var key = GetJoeysPrivatePgpKey ();\n    message.Body = MultipartSigned.Create (ctx, key, DigestAlgorithm.Sha1, body);\n}\n```\n\n### Verifying S/MIME and PGP/MIME Digital Signatures\n\nAs mentioned earlier, both S/MIME and PGP/MIME typically use a `multipart/signed` part to contain the\nsigned content and the detached signature data.\n\nA `multipart/signed` contains exactly 2 parts: the first `MimeEntity` is the signed content while the second\n`MimeEntity` is the detached signature and, by default, will either be an `ApplicationPgpSignature` part or\nan `ApplicationPkcs7Signature` part (depending on whether the sending client signed using OpenPGP or S/MIME).\n\nBecause the `multipart/signed` part may have been signed by multiple signers, it is important to\nverify each of the digital signatures (one for each signer) that are returned by the\n`MultipartSigned.Verify()` method:\n\n```csharp\nif (entity is MultipartSigned) {\n    var signed = (MultipartSigned) entity;\n\n    foreach (var signature in signed.Verify ()) {\n        try {\n            bool valid = signature.Verify ();\n\n            // If valid is true, then it signifies that the signed content has not been\n            // modified since this particular signer signed the content.\n            //\n            // However, if it is false, then it indicates that the signed content has\n            // been modified.\n        } catch (DigitalSignatureVerifyException) {\n            // There was an error verifying the signature.\n        }\n    }\n}\n```\n\nIt should be noted, however, that while most S/MIME clients will use the preferred `multipart/signed`\napproach, it is possible that you may encounter an `application/pkcs7-mime` part with an \"smime-type\"\nparameter set to \"signed-data\". Luckily, MimeKit can handle this format as well:\n\n```csharp\nif (entity is ApplicationPkcs7Mime) {\n    var pkcs7 = (ApplicationPkcs7Mime) entity;\n\n    if (pkcs7.SecureMimeType == SecureMimeType.SignedData) {\n        // extract the original content and get a list of signatures\n        MimeEntity extracted;\n\n        // Note: if you are rendering the message, you'll want to render the\n        // extracted mime part rather than the application/pkcs7-mime part.\n        foreach (var signature in pkcs7.Verify (out extracted)) {\n            try {\n                bool valid = signature.Verify ();\n\n                // If valid is true, then it signifies that the signed content has not\n                // been modified since this particular signer signed the content.\n                //\n                // However, if it is false, then it indicates that the signed content\n                // has been modified.\n            } catch (DigitalSignatureVerifyException) {\n                // There was an error verifying the signature.\n            }\n        }\n    }\n}\n```\n\n### Signing Messages with DKIM\n\nIn addition to OpenPGP and S/MIME, MimeKit also supports DKIM signatures. To sign a message using DKIM,\nyou'll first need a private key. In the following example, assume that the private key is saved in a\nfile called **privatekey.pem**:\n\n```csharp\nvar headers = new HeaderId[] { HeaderId.From, HeaderId.Subject, HeaderId.Date };\nvar signer = new DkimSigner (\"privatekey.pem\", \"example.com\", \"brisbane\", DkimSignatureAlgorithm.RsaSha256) {\n    HeaderCanonicalizationAlgorithm = DkimCanonicalizationAlgorithm.Simple,\n    BodyCanonicalizationAlgorithm = DkimCanonicalizationAlgorithm.Simple,\n    AgentOrUserIdentifier = \"@eng.example.com\",\n    QueryMethod = \"dns/txt\",\n};\n\n// Prepare the message body to be sent over a 7bit transport (such as older versions of SMTP).\n// Note: If the SMTP server you will be sending the message over supports the 8BITMIME extension,\n// then you can use `EncodingConstraint.EightBit` instead.\nmessage.Prepare (EncodingConstraint.SevenBit);\n\nsigner.Sign (message, headers);\n```\n\nAs you can see, it's fairly straight forward.\n\n### Verifying DKIM Signatures\n\nVerifying DKIM signatures is slightly more involved than creating them because you'll need to write a custom\nimplementation of the `IDkimPublicKeyLocator` interface. Typically, this custom class will need to download\nthe DKIM public keys via your chosen DNS library as they are requested by MimeKit during verification of\nDKIM signature headers.\n\nOnce you've implemented a custom `IDkimPublicKeyLocator`, verifying signatures is fairly trivial. Most of the work\nneeded will be in the `IDkimPublicKeyLocator` implementation. As an example of how to implement this interface,\nhere is one possible implementation using the [Heijden.DNS](https://www.nuget.org/packages/Heijden.Dns/) library:\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\n\nusing Heijden.DNS;\n\nusing Org.BouncyCastle.Crypto;\n\nusing MimeKit;\nusing MimeKit.Cryptography;\n\nnamespace DkimVerifierExample\n{\n    // Note: By using the DkimPublicKeyLocatorBase, we avoid having to parse the DNS TXT records\n    // in order to get the public key ourselves.\n    class DkimPublicKeyLocator : DkimPublicKeyLocatorBase\n    {\n        readonly Dictionary<string, AsymmetricKeyParameter> cache;\n        readonly Resolver resolver;\n\n        public DkimPublicKeyLocator ()\n        {\n            cache = new Dictionary<string, AsymmetricKeyParameter> ();\n\n            resolver = new Resolver (\"8.8.8.8\") {\n                TransportType = TransportType.Udp,\n                UseCache = true,\n                Retries = 3\n            };\n        }\n\n        AsymmetricKeyParameter DnsLookup (string domain, string selector, CancellationToken cancellationToken)\n        {\n            var query = selector + \"._domainkey.\" + domain;\n            AsymmetricKeyParameter pubkey;\n\n            // checked if we've already fetched this key\n            if (cache.TryGetValue (query, out pubkey))\n                return pubkey;\n\n            // make a DNS query\n            var response = resolver.Query (query, QType.TXT);\n            var builder = new StringBuilder ();\n\n            // combine the TXT records into 1 string buffer\n            foreach (var record in response.RecordsTXT) {\n                foreach (var text in record.TXT)\n                    builder.Append (text);\n            }\n\n            var txt = builder.ToString ();\n\n            // DkimPublicKeyLocatorBase provides us with this helpful method.\n            pubkey = GetPublicKey (txt);\n\n            cache.Add (query, pubkey);\n\n            return pubkey;\n        }\n\n        public AsymmetricKeyParameter LocatePublicKey (string methods, string domain, string selector, CancellationToken cancellationToken = default (CancellationToken))\n        {\n            var methodList = methods.Split (new char[] { ':' }, StringSplitOptions.RemoveEmptyEntries);\n            for (int i = 0; i < methodList.Length; i++) {\n                if (methodList[i] == \"dns/txt\")\n                    return DnsLookup (domain, selector, cancellationToken);\n            }\n\n            throw new NotSupportedException (string.Format (\"{0} does not include any suported lookup methods.\", methods));\n        }\n\n        public Task<AsymmetricKeyParameter> LocatePublicKeyAsync (string methods, string domain, string selector, CancellationToken cancellationToken = default (CancellationToken))\n        {\n            return Task.Run (() => {\n                return LocatePublicKey (methods, domain, selector, cancellationToken);\n            }, cancellationToken);\n        }\n    }\n\n    class Program\n    {\n        public static void Main (string[] args)\n        {\n            if (args.Length == 0) {\n                Help ();\n                return;\n            }\n\n            for (int i = 0; i < args.Length; i++) {\n                if (args[i] == \"--help\") {\n                    Help ();\n                    return;\n                }\n            }\n\n            var locator = new DkimPublicKeyLocator ();\n            var verifier = new DkimVerifier (locator);\n\n            for (int i = 0; i < args.Length; i++) {\n                if (!File.Exists (args[i])) {\n                    Console.Error.WriteLine (\"{0}: No such file.\", args[i]);\n                    continue;\n                }\n\n                Console.Write (\"{0} -> \", args[i]);\n\n                var message = MimeMessage.Load (args[i]);\n                var index = message.Headers.IndexOf (HeaderId.DkimSignature);\n\n                if (index == -1) {\n                    Console.WriteLine (\"NO SIGNATURE\");\n                    continue;\n                }\n\n                var dkim = message.Headers[index];\n\n                if (verifier.Verify (message, dkim)) {\n                    // the DKIM-Signature header is valid!\n                    Console.ForegroundColor = ConsoleColor.Green;\n                    Console.WriteLine (\"VALID\");\n                    Console.ResetColor ();\n                } else {\n                    // the DKIM-Signature is invalid!\n                    Console.ForegroundColor = ConsoleColor.Red;\n                    Console.WriteLine (\"INVALID\");\n                    Console.ResetColor ();\n                }\n            }\n        }\n\n        static void Help ()\n        {\n            Console.WriteLine (\"Usage is: DkimVerifier [options] [messages]\");\n            Console.WriteLine ();\n            Console.WriteLine (\"Options:\");\n            Console.WriteLine (\"  --help               This help menu.\");\n        }\n    }\n}\n```\n\n### Signing Messages with ARC\n\nSigning with ARC is similar to DKIM but quite a bit more involved. In order to sign with\nARC, you must first validate that the existing message is authentictic and produce\nan ARC-Authentication-Results header containing the methods that you used to\nauthenticate the message as well as their results.\n\nThe abstract [ArcSigner](https://www.mimekit.net/docs/html/T_MimeKit_Cryptography_ArcSigner.htm)\nclass provided by MimeKit will need to be subclassed before it can be used. An example subclass\nthat provides 2 different implementations for generating the ARC-Authentication-Results header\ncan be seen below:\n\n```csharp\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\n\nusing MimeKit;\nusing MimeKit.Cryptography;\n\nnamespace ArcSignerExample\n{\n    class MyArcSigner : ArcSigner\n    {\n        public MyArcSigner (string fileName, string domain, string selector, DkimSigningAlgorithm algorithm = DkimSignatureAlgorithm.RsaSha256)\n               : base (fileName, domain, selector, algorithm)\n        {\n        }\n\n        /// <summary>\n        /// Generate the ARC-Authentication-Results header.\n        /// </summary>\n        /// <remarks>\n        /// The ARC-Authentication-Results header contains information detailing the results of\n        /// authenticating/verifying the message via ARC, DKIM, SPF, etc.\n        ///\n        /// In the following implementation, we assume that all of these authentication results\n        /// have already been determined by other mail software that has added some Authentication-Results\n        /// headers containing this information.\n        ///\n        /// Note: This method is used when ArcSigner.Sign() is called instead of ArcSigner.SignAsync().\n        /// </remarks>\n        protected override AuthenticationResults GenerateArcAuthenticationResults (FormatOptions options, MimeMessage message, CancellationToken cancellationToken)\n        {\n            const string AuthenticationServiceIdentifier = \"lists.example.com\";\n\n            var results = new AuthenticationResults (AuthenticationServiceIdentifier);\n\n            for (int i = 0; i < message.Headers.Count; i++) {\n                var header = message.Headers[i];\n\n                if (header.Id != HeaderId.AuthenticationResults)\n                    continue;\n\n                if (!AuthenticationResults.TryParse (header.RawValue, out AuthenticationResults authres))\n                    continue;\n\n                if (authres.AuthenticationServiceIdentifier != AuthenticationServiceIdentifier)\n                    continue;\n\n                // Merge any authentication results that aren't already known.\n                foreach (var result in authres.Results) {\n                    if (!results.Results.Any (r => r.Method == result.Method))\n                        results.Results.Add (result);\n                }\n            }\n\n            return results;\n        }\n\n        /// <summary>\n        /// Generate the ARC-Authentication-Results asynchronously.\n        /// </summary>\n        /// <remarks>\n        /// The ARC-Authentication-Results header contains information detailing the results of\n        /// authenticating/verifying the message via ARC, DKIM, SPF, etc.\n        ///\n        /// In the following implementation, we assume that we have to verify all of the various\n        /// authentication methods ourselves.\n        ///\n        /// Note: This method is used when ArcSigner.SignAsync() is called instead of ArcSigner.Sign().\n        /// </remarks>\n        protected override async Task<AuthenticationResults> GenerateArcAuthenticationResultsAsync (FormatOptions options, MimeMessage message, CancellationToken cancellationToken)\n        {\n            const string AuthenticationServiceIdentifier = \"lists.example.com\";\n\n            var results = new AuthenticationResults (AuthenticationServiceIdentifier);\n            var locator = new DkimPublicKeyLocator (); // from the DKIM example above\n            var dkimVerifier = new DkimVerifier (locator);\n            var arcVerifier = new ArcVerifier (locator);\n            AuthenticationMethodResult method;\n\n            // Add the ARC authentication results\n            try {\n                var arc = await arcVerifier.VerifyAsync (message, cancellationToken);\n                var result = arc.Chain.ToString ().ToLowerInvariant ();\n\n                method = new AuthenticationMethodResult (\"arc\", result);\n                results.Results.Add (method);\n            } catch {\n                // Likely a DNS error\n                method = new AuthenticationMethodResult (\"arc\", \"fail\");\n                method.Reason = \"DNS error\";\n                results.Results.Add (method);\n            }\n\n            // Add authentication results for each DKIM signature\n            foreach (var dkimHeader in message.Headers.Where (h => h.Id == HeaderId.DkimSignature)) {\n                string result;\n\n                try {\n                    if (await dkimVerifier.VerifyAsync (message, cancellationToken)) {\n                        result = \"pass\";\n                    } else {\n                        result = \"fail\";\n                    }\n                } catch {\n                    result = \"fail\";\n                }\n\n                method = new AuthenticationMethodResult (\"dkim\", result);\n\n                // Parse the DKIM-Signature header so that we can add some\n                // properties to our method result.\n                var params = dkimHeader.Value.Replace (\" \", \"\").Split (new char[] { ';' });\n                var i = params.FirstOrDefault (p => p.StartsWith (\"i=\", StringComparison.Ordinal));\n                var b = params.FirstOrDefault (p => p.StartsWith (\"b=\", StringComparison.Ordinal));\n\n                if (i != null)\n                    method.Parameters.Add (\"header.i\", i.Substring (2));\n\n                if (b != null)\n                    method.Parameters.Add (\"header.b\", b.Substring (2, 8));\n\n                results.Results.Add (method);\n            }\n\n            return results;\n        }\n    }\n}\n```\n\nOnce you have a custom `ArcSigner` class, the actual logic for signing is almost identical to DKIM.\n\nNote: As with the DKIM signing example above, assume that the private key is saved in a\nfile called **privatekey.pem**:\n\n```csharp\nvar headers = new HeaderId[] { HeaderId.From, HeaderId.Subject, HeaderId.Date };\nvar signer = new MyArcSigner (\"privatekey.pem\", \"example.com\", \"brisbane\", DkimSignatureAlgorithm.RsaSha256) {\n    HeaderCanonicalizationAlgorithm = DkimCanonicalizationAlgorithm.Relaxed,\n    BodyCanonicalizationAlgorithm = DkimCanonicalizationAlgorithm.Relaxed,\n    AgentOrUserIdentifier = \"@eng.example.com\"\n};\n\n// Prepare the message body to be sent over a 7bit transport (such as older versions of SMTP).\n// Note: If the SMTP server you will be sending the message over supports the 8BITMIME extension,\n// then you can use `EncodingConstraint.EightBit` instead.\nmessage.Prepare (EncodingConstraint.SevenBit);\n\nsigner.Sign (message, headers); // or SignAsync\n```\n\n### Verifying ARC Signatures\n\nJust like with verifying DKIM signatures, you will need to implement the `IDkimPublicKeyLocator`\ninterface. To see an example of how to implement this interface, see the DKIM signature verification\nexample above.\n\nThe `ArcVerifier` works exactly the same as the `DkimVerifier` except that it is not necessary\nto provide a `Header` argument to the `Verify` or `VerifyAsync` method.\n\n```csharp\nvar verifier = new ArcVerifier (new DkimPublicKeyLocator ());\nvar results = await verifier.VerifyAsync (message);\n\n// The Chain results are the only real important results.\nConsole.WriteLine (\"ARC results: {0}\", results.Chain);\n```\n\n## Contributing\n\nThe first thing you'll need to do is fork MimeKit to your own GitHub repository. For instructions on how to\ndo that, see the section titled **Getting the Source Code**.\n\nIf you use [Visual Studio for Mac](https://visualstudio.microsoft.com/vs/mac/) or [MonoDevelop](https://monodevelop.com),\nall of the solution files are configured with the coding style used by MimeKit. If you use Visual Studio on Windows or\nsome other editor, please try to maintain the existing coding style as best as you can.\n\nOnce you've got some changes that you'd like to submit upstream to the official MimeKit repository,\nsend me a **Pull Request** and I will try to review your changes in a timely manner.\n\nIf you'd like to contribute but don't have any particular features in mind to work on, check out the issue\ntracker and look for something that might pique your interest!\n\n## Reporting Bugs\n\nHave a bug or a feature request? Please open a new\n[bug report](https://github.com/jstedfast/MimeKit/issues/new?template=bug_report.md)\nor\n[feature request](https://github.com/jstedfast/MimeKit/issues/new?template=feature_request.md).\n\nBefore opening a new issue, please search through any [existing issues](https://github.com/jstedfast/MimeKit/issues)\nto avoid submitting duplicates. It may also be worth checking the\n[FAQ](https://github.com/jstedfast/MimeKit/blob/master/FAQ.md) for common questions that other developers\nhave had.\n\nIf you are getting an exception from somewhere within MimeKit, don't just provide the `Exception.Message`\nstring. Please include the `Exception.StackTrace` as well. The `Message`, by itself, is often useless.\n\n## Documentation\n\nAPI documentation can be found at [https://www.mimekit.net/docs](https://www.mimekit.net/docs).\n\nA copy of the XML-formatted API reference documentation is also included in the NuGet package.\n\n## .NET Foundation\n\nMimeKit is a [.NET Foundation](https://www.dotnetfoundation.org/projects) project.\n\nThis project has adopted the code of conduct defined by the [Contributor Covenant](https://contributor-covenant.org/) to clarify expected behavior in our community. For more information, see the [.NET Foundation Code of Conduct](https://www.dotnetfoundation.org/code-of-conduct).\n"
        },
        {
          "name": "RFCs.md",
          "type": "blob",
          "size": 7.916015625,
          "content": "### Specifications\n\nMimeKit implements the following IETF specifications defining Internet Mail and MIME:\n\n* [0822](https://tools.ietf.org/html/rfc0822): Standard for the Format of Arpa Internet Text Messages\n* [1341](https://tools.ietf.org/html/rfc1341): MIME (Multipurpose Internet Mail Extensions): Mechanisms for Specifying and Describing the Format of Internet Message Bodies\n* [1342](https://tools.ietf.org/html/rfc1342): Representation of Non-ASCII Text in Internet Message Headers\n* [1521](https://tools.ietf.org/html/rfc1521): MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies (Obsoletes rfc1341)\n* [1522](https://tools.ietf.org/html/rfc1522): MIME (Multipurpose Internet Mail Extensions) Part Two: Message Header Extensions for Non-ASCII Text (Obsoletes rfc1342)\n* [1544](https://tools.ietf.org/html/rfc1544): The Content-MD5 Header Field\n* [1847](https://tools.ietf.org/html/rfc1847): Security Multiparts for MIME: Multipart/Signed and Multipart/Encrypted\n* [1864](https://tools.ietf.org/html/rfc1864): The Content-MD5 Header Field (Obsoletes rfc1544)\n* [1872](https://tools.ietf.org/html/rfc1872): The MIME Multipart/Related Content-type\n* [1892](https://tools.ietf.org/html/rfc1892): The Multipart/Report Content Type for the Reporting of  Mail System Administrative Messages\n* [2015](https://tools.ietf.org/html/rfc2015): MIME Security with Pretty Good Privacy (PGP)\n* [2045](https://tools.ietf.org/html/rfc2045): Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies\n* [2046](https://tools.ietf.org/html/rfc2046): Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types\n* [2047](https://tools.ietf.org/html/rfc2047): Multipurpose Internet Mail Extensions (MIME) Part Three: Message Header Extensions for Non-ASCII Text\n* [2048](https://tools.ietf.org/html/rfc2048): Multipurpose Internet Mail Extensions (MIME) Part Four: Registration Procedures\n* [2049](https://tools.ietf.org/html/rfc2049): Multipurpose Internet Mail Extensions (MIME) Part Five: Conformance Criteria and Examples\n* [2110](https://tools.ietf.org/html/rfc2110): MIME E-mail Encapsulation of Aggregate Documents, such as HTML (MHTML)\n* [2111](https://tools.ietf.org/html/rfc2111): Content-ID and Message-ID Uniform Resource Locators\n* [2112](https://tools.ietf.org/html/rfc2112): The MIME Multipart/Related Content-type (Obsoletes rfc1872)\n* [2183](https://tools.ietf.org/html/rfc2183): Communicating Presentation Information in Internet Messages: The Content-Disposition Header Field\n* [2184](https://tools.ietf.org/html/rfc2184): MIME Parameter Value and Encoded Word Extensions: Character Sets, Languages, and Continuations\n* [2231](https://tools.ietf.org/html/rfc2231): MIME Parameter Value and Encoded Word Extensions: Character Sets, Languages, and Continuations (Obsoletes rfc2184)\n* [2298](https://tools.ietf.org/html/rfc2298): An Extensible Message Format for Message Disposition Notifications\n* [2311](https://tools.ietf.org/html/rfc2311): S/MIME Version 2 Message Specification\n* [2312](https://tools.ietf.org/html/rfc2312): S/MIME Version 2 Certificate Handling\n* [2315](https://tools.ietf.org/html/rfc2315): PKCS #7: Cryptographic Message Syntax\n* [2387](https://tools.ietf.org/html/rfc2387): The MIME Multipart/Related Content-type (Obsoletes rfc2112)\n* [2424](https://tools.ietf.org/html/rfc2424): Content Duration MIME Header Definition\n* [2557](https://tools.ietf.org/html/rfc2557): MIME Encapsulation of Aggregate Documents, such as HTML (MHTML) (Obsoletes rfc2110)\n* [2630](https://tools.ietf.org/html/rfc2630): Cryptographic Message Syntax\n* [2632](https://tools.ietf.org/html/rfc2632): S/MIME Version 3 Certificate Handling\n* [2633](https://tools.ietf.org/html/rfc2633): S/MIME Version 3 Message Specification\n* [2634](https://tools.ietf.org/html/rfc2634): Enhanced Security Services for S/MIME\n* [2822](https://tools.ietf.org/html/rfc2822): Internet Message Format (Obsoletes rfc0822)\n* [3156](https://tools.ietf.org/html/rfc3156): MIME Security with OpenPGP (Updates rfc2015)\n* [3462](https://tools.ietf.org/html/rfc3462): The Multipart/Report Media Type for the Reporting of Mail System Administrative Messages (Obsoletes rfc1892)\n* [3464](https://tools.ietf.org/html/rfc3464): An Extensible Message Format for Delivery Status Notifications\n* [3798](https://tools.ietf.org/html/rfc3798): Message Disposition Notification (Obsoletes rfc2298)\n* [3850](https://tools.ietf.org/html/rfc3850): S/MIME Version 3.1 Certificate Handling (Obsoletes rfc2632)\n* [3851](https://tools.ietf.org/html/rfc3851): S/MIME Version 3.1 Message Specification (Obsoletes rfc2633)\n* [4262](https://tools.ietf.org/html/rfc4262): X.509 Certificate Extension for S/MIME Capabilities\n* [4871](https://tools.ietf.org/html/rfc4871): DomainKeys Identified Mail (DKIM) Signatures\n* [5322](https://tools.ietf.org/html/rfc5322): Internet Message Format (Obsoletes rfc2822)\n* [5451](https://tools.ietf.org/html/rfc5451): Message Header Field for Indicating Message Authentication Status\n* [5672](https://tools.ietf.org/html/rfc5672): RFC 4871 DomainKeys Identified Mail (DKIM) Signatures -- Update\n* [5750](https://tools.ietf.org/html/rfc5750): S/MIME Version 3.2 Certificate Handling (Obsoletes rfc3850)\n* [5751](https://tools.ietf.org/html/rfc5751): S/MIME Version 3.2 Message Specification (Obsoletes rfc3851)\n* [6376](https://tools.ietf.org/html/rfc6376): DomainKeys Identified Mail (DKIM) Signatures (Obsoletes rfc4871)\n* [6522](https://tools.ietf.org/html/rfc6522): The Multipart/Report Media Type for the Reporting of Mail System Administrative Messages (Obsoletes rfc3462)\n* [6532](https://tools.ietf.org/html/rfc6532): Internationalized Email Headers\n* [6533](https://tools.ietf.org/html/rfc6533): Internationalized Delivery Status and Disposition Notifications\n* [7001](https://tools.ietf.org/html/rfc7001): Message Header Field for Indicating Message Authentication Status (Obsoletes rfc5451)\n* [7601](https://tools.ietf.org/html/rfc7601): Message Header Field for Indicating Message Authentication Status (Obsoletes rfc7001)\n* [8098](https://tools.ietf.org/html/rfc8098): Message Disposition Notification (Obsoletes rfc3798)\n* [8301](https://tools.ietf.org/html/rfc8301): Cryptographic Algorithm and Key Usage Update to DomainKeys Identified Mail (DKIM)\n* [8463](https://tools.ietf.org/html/rfc8463): A New Cryptographic Signature Method for DomainKeys Identified Mail (DKIM)\n* [8617](https://tools.ietf.org/html/rfc8617): The Authenticated Received Chain (ARC) Protocol\n\n#### Other RFCs of interest:\n\n* [1523](https://tools.ietf.org/html/rfc1523): The text/enriched MIME Content-type\n* [1927](https://tools.ietf.org/html/rfc1927): Suggested Additional MIME Types for Associating Documents\n* [2369](https://tools.ietf.org/html/rfc2369): The Use of URLs as Meta-Syntax for Core Mail List Commands and their Transport through Message Header Fields\n* [2388](https://tools.ietf.org/html/rfc2388): Returning Values from Forms: multipart/form-data\n* [4134](https://tools.ietf.org/html/rfc4134): Examples of S/MIME Messages\n* [6577](https://tools.ietf.org/html/rfc6577): Authentication-Results Registration Update for Sender Policy Framework (SPF) Results\n* [7103](https://tools.ietf.org/html/rfc7103): Advice for Safe Handling of Malformed Messages\n* [7107](https://tools.ietf.org/html/rfc7107): Object Identifier Registry for the S/MIME Mail Security Working Group\n* [7114](https://tools.ietf.org/html/rfc7114): Creation of a Registry for smime-type Parameter Values\n* [7281](https://tools.ietf.org/html/rfc7281): Authentication-Results Registration for S/MIME Signature Verification\n* [7410](https://tools.ietf.org/html/rfc7410): A Property Types Registry for the Authentication-Results Header Field\n* [8550](https://tools.ietf.org/html/rfc8550): S/MIME Version 4.0 Certificate Handling (Obsoletes rfc5750)\n* [8551](https://tools.ietf.org/html/rfc8551): S/MIME Version 4.0 Message Specification (Obsoletes rfc5751)\n* [9216](https://tools.ietf.org/html/rfc9216): S/MIME Example Keys and Certificates"
        },
        {
          "name": "ReleaseNotes.md",
          "type": "blob",
          "size": 78.6943359375,
          "content": "# Release Notes\n\n## MimeKit 4.9.0 (2024-12-09)\n\n* Started adding some DynamicallyAccessedMembers attributes for AOT compatibility.\n* Refactored some code for AOT Compatibility (MimeKitLite is now 100% AOT Compatible but MimeKit still has\n  issues related to SQLite database loading for the S/MIME certificate database).\n  (MailKit issue [#10844](https://github.com/jstedfast/MailKit/issues/1844))\n* Fixed TextPreviewer to use an encoding with an empty string fallback to prevent '?' characters from\n  being appended to the generated preview string if the byte sequence was truncated.\n* Improved performance of InternetAddressList.Parse()/TryParse().\n* Improved InternetAddressList parser performance for malformed addresses that only contain\n  display-name strings separated by commas.\n  (issue [#1106](https://github.com/jstedfast/MimeKit/issues/1106))\n* Exposed BouncyCastleCertificateExtensions.IsSelfSigned(), GetKeyUsageFlags() and IsDelta() as new public APIs.\n* Exposed X509KeyUsageBits enum as public.\n* Added support for domain-bound S/MIME certificates. (issue [#1113](https://github.com/jstedfast/MimeKit/issues/1113))\n* Dropped support for net6.0 in the nuget packages (Microsoft support ended Nov 12, 2024).\n* Removed explicit dependency on System.Runtime.CompilerServices.Unsafe.\n* Bumped System.Security.Cryptography.Pkcs dependency to v8.0.1.\n* Bumped BouncyCastle.Cryptography dependency to v2.5.0.\n* Bumped System.Buffers dependency to v4.6.0.\n* Bumped System.Memory dependency to v4.6.0.\n\n## MimeKit 4.8.0 (2024-09-29)\n\n* Added TypeConverters for InternetAddress and InternetAddressList.\n\n## MimeKit 4.7.1 (2024-07-11)\n\n* Bumped System.Formats.Asn1 to v8.0.1 to fix a denial of service security issue.\n\n## MimeKit 4.7.0 (2024-06-29)\n\n* Bumped BouncyCastle.Cryptography from 2.3.1 to 2.4.0\n* Don't override the parameter encoding with UTF-8 if format.International is true.\n  (issue [#1041](https://github.com/jstedfast/MimeKit/issues/1041))\n* Fixed BouncyCastle S/MIME backend to properly encrypt/decrypt for SubjectKeyIdentifier.\n  (BouncyCastle issue [#532](https://github.com/bcgit/bc-csharp/issues/532))\n* Added support for addresses like \"webmaster\\@custom-host.com@mail-host.com\".\n  (issue [#1043](https://github.com/jstedfast/MimeKit/issues/1043))\n* Improved Content-Type and Content-Disposition parameter serialization in a few cases.\n* Added tests for HeaderList.set_Item[int index] and fixed a bug that was exposed.\n* Fixed ContentDisposition.Size parsing to use InvariantCulture.\n* Fixed parser logic for determining if a message/rfc822 part is encoded.\n  (issue [#1049](https://github.com/jstedfast/MimeKit/issues/1049))\n\n## MimeKit 4.6.0 (2024-05-17)\n\n* Fixed hex format specifier for PGP keyserver lookup. (issue [#1028](https://github.com/jstedfast/MimeKit/issues/1028))\n* Bumped the BouncyCastle.Cryptography dependency to v2.3.1 to fix some security issues.\n* Fixed a bug in conversion logic between BouncyCastle DSA key parameters and System.Security.Cryptography's DSA implementation.\n\n## MimeKit 4.5.0 (2024-04-13)\n\n* Fixed MailboxAddress to not use punycode to encode or decode the local-part of an addr-spec.\n  (issue [#1012](https://github.com/jstedfast/MimeKit/issues/1012))\n* Removed explicit refs to CompilerServices.Unsafe and Encoding.CodePages from net6.0/8.0.\n  (issue [#1013](https://github.com/jstedfast/MimeKit/issues/1013))\n\n## MimeKit 4.4.0 (2024-03-02)\n\n* Added net8.0 target.\n* Improved folding logic for Disposition-Notification-Options header values.\n  (issue [#979](https://github.com/jstedfast/MimeKit/issues/979))\n* Added interfaces for MimeMessage, MimeEntity, MimePart, Multipart, etc.\n  (issue [#980](https://github.com/jstedfast/MimeKit/issues/980))\n* Fixed the FormatOptions.NewLineFormat setter logic.\n* Modified AttachmentCollection.Add() for message/rfc822 attachments to better\n  handle MimeParser exceptions.\n  (issue [#1001](https://github.com/jstedfast/MimeKit/issues/1001))\n* Bump BouncyCastle dependency to v2.3.0.\n* Added support for ECC S/MIME certificates.\n  (issue [#998](https://github.com/jstedfast/MimeKit/issues/998))\n* Improved Unix2Dos and Dos2Unix filters by fixing some corner cases exposed by new unit tests.\n* Fixed MaxMimeDepth logic to still use MimePart subclasses when reached.\n  (issue [#1006](https://github.com/jstedfast/MimeKit/issues/1006))\n\n## MimeKit 4.3.0 (2023-11-11)\n\n* Added work-around for broken Message-ID header values of the form &lt;id@@domain&gt;.\n  (issue [#962](https://github.com/jstedfast/MimeKit/issues/962))\n* Added virtual Multipart.TryGetValue(TextFormat, out TextPart) method that recursively\n  iterates over child parts to find the TextPart with the desired format.\n* Fixed MimeMessage.TextBody/HtmlBody to locate the text body in a multipart/mixed that is\n  inside of a multipart/alternative. This resolves an issue locating the text body within\n  some broken iOS Apple Mail messages. (issue [#963](https://github.com/jstedfast/MimeKit/issues/963))\n\n## MimeKit 4.2.0 (2023-09-02)\n\n* Follow the spec more closely for allowable header field characters.\n  (issue [#936](https://github.com/jstedfast/MimeKit/issues/936))\n* Avoid throwing NRE when an RC2 algorithm was used for S/MIME w/o parameters.\n  (issue [#941](https://github.com/jstedfast/MimeKit/issues/941))\n* Added a few more (undocumented) TnefPropertyIds.\n* Optimized AttachmentCollection.Add(byte[], ...) by not copying the data to a new stream.\n* Improved performance of HtmlTokenizer.\n* Added new HtmlTokenizer constructors that take a Stream instead of a TextReader. This\n  allows for a slight performance improvement over using a TextReader as well.\n* Lazy-allocate Base64/QuotedPrintable decoders when decoding rfc2047-encoded headers.\n  This is a very small reduction in GC pressure.\n* Reduced memory allocations in Rfc2047.DecodePhrase() and DecodeText().\n* Avoid allocating empty `List<string>`s in DomainList.ctor(), lazily allocate the\n  list only when a domain is added. Another minor reduction in GC pressure.\n* Updated the Date parser to allocate an internal list of tokens with a optimal\n  initial capacity to avoid the need for reallocating.\n\n## MimeKit 4.1.0 (2023-06-17)\n\n* Readded the System.Net.Mail-to-MimeKit conversion APIs for the netstandard2.x frameworks.\n  (issue [#913](https://github.com/jstedfast/MimeKit/issues/913))\n* Fixed the MimeEntity.LoadAsync() overloads that take a ContentType parameter to to properly wait\n  to dispose of the stream until after the entity has been parsed.\n  (issue [#916](https://github.com/jstedfast/MimeKit/issues/916))\n* Optimized conversion between HeaderId and string.\n* Added a new IMimeParser interface that both MimeParser and ExperimentalMimePraser implement.\n* Added \"unicode\" to the list of charset aliases for UTF-8.\n  (issue [#923](https://github.com/jstedfast/MimeKit/issues/923))\n* Added support for the Edwards Curve DSA PGP public key algorithm.\n  (issue [#932](https://github.com/jstedfast/MimeKit/issues/932))\n* Bumped System.Security.Cryptography.Pkcs dependency to 7.0.2.\n* Bumped BouncyCastle dependency to 2.2.1.\n\n## MimeKit 4.0.0 (2023-04-15)\n\n* Ported to BouncyCastle v2.1.1. (issue [#865](https://github.com/jstedfast/MimeKit/issues/865))\n* Fixed System.Net.Mail.MailMessage -> MimeMessage converter to reset MailMessage attachment/alternateview streams back\n  to 0 after copying them. (issue [#907](https://github.com/jstedfast/MimeKit/issues/907))\n* Added support for the signature expiration field in DKIM signatures which can be specified\n  using the new DkimSigner.SignatureExpiresAfter property.\n* Added equality operators for TnefNameId and TnefPropertyTag.\n* Fixed MimeMessage's MessageId, ResentMessageId and InReplyTo property setters to be more lax.\n  (issue [#912](https://github.com/jstedfast/MimeKit/issues/912))\n* MimeKit and MimeKitLite nuget packages now include MimeKit.dll.config that contain assembly redirects\n  which *may* resolve some issues some developers were having with loading assemblies such as\n  System.Runtime.CompilerServices.Unsafe.dll.\n\n## MimeKit 3.6.1 (2023-03-19)\n\n* Improved the UrlScanner to allow numeric key/value pairs (seems to match behavior in other url detection algorithms).\n* Fixed a mis-use of ArrayPool in the OpenPgpContext.Encrypt/EncryptAsync that could cause memory corruption.\n* Use BitConverter to decode floats/doubles from the input buffer instead of custom code.\n* Bumped the System.Security.Cryptography.Pkcs dependency to v6.0.2.\n\n## MimeKit 3.6.0 (2023-03-04)\n\n* Added the .msg &lt;-&gt; application/vnd.ms-outlook mime-type mapping.\n  (issue [#880](https://github.com/jstedfast/MimeKit/issues/880))\n* Improved encoding/formatting of List-Archive, List-Help, List-Post, List-Subscribe and List-Unsubscribe headers.\n  (issue [#885](https://github.com/jstedfast/MimeKit/issues/885))\n* Reduced memory allocations when encoding the mailbox/group names.\n* Added more Rfc2047.EncodePhrase()/EncodeText() overloads that take `startIndex` and `count` arguments.\n* Fixed parsing of Message-Id's containing a quoted string dot-atom (among regular dot-atoms).\n  (issue [#889](https://github.com/jstedfast/MimeKit/issues/889))\n* Fixed a bug in the parsing of HTML &lt;script&gt; content that sometimes caused a character to be duplicated.\n* Use MailMessage.HeadersEncoding when coverting a MailMessage to a MimeMessage.\n* Improved the UrlScanner to accept urls like `https://example.com?query`\n  (issue [#897](https://github.com/jstedfast/MimeKit/issues/897))\n\n## MimeKit 3.5.0 (2023-01-28)\n\n* Fixed potential NRE's in the GnuPG config parser\n* Modified AsBouncyCastleCertificate() extension method to throw on fail\n* Added Clone() methods to ContentType, ContentDisposition and Parameter.\n\n## MimeKit 3.4.3 (2022-11-25)\n\n* Fixed a variety of memory leaks revealed by (issue [#852](https://github.com/jstedfast/MimeKit/issues/852))\n* Fixed the message/delivery-status parser to handle extra blank lines between status groups.\n  (issue [#855](https://github.com/jstedfast/MimeKit/issues/855))\n* Updated packages to explicitly depend on System.Runtime.CompilerServices.Unsafe v6.0.0.\n* Updated net6.0 dependencies to explicitly include System.Text.Encoding.CodePages v6.0.0.\n\n## MimeKit 3.4.2 (2022-10-24)\n\n* Fixed MessageDeliveryStatus.ParseStatusGroups() to catch FormatException instead of ParseException.\n  (issue [#837](https://github.com/jstedfast/MimeKit/issues/837))\n* Fixed DefaultSecureMimeContext to use the correct AppData path on Windows.\n* Fixed MimeMessage .ctor(params object[] args) to respect a Date header argument.\n  (issue [#840](https://github.com/jstedfast/MimeKit/issues/840))\n* Updated MIME-Type to file extension mappings to add a few missing types/extensions.\n  (issue [#844](https://github.com/jstedfast/MimeKit/issues/844))\n* Fixed address parser to no longer throw ArgumentOutOfRangeException when parsing some mailbox names.\n  (issue [#846](https://github.com/jstedfast/MimeKit/issues/846) and [#847](https://github.com/jstedfast/MimeKit/issues/847))\n* Map codepage 932 to shift_jis instead of iso-2022-jp.\n  (issue [#848](https://github.com/jstedfast/MimeKit/issues/848))\n\n## MimeKit 3.4.1 (2022-09-12)\n\n* Improved logic for reformatting headers when MimeMessage.WriteTo() is called with FormatOptions.International\n  set to true.\n* Fixed logic for quoting and/or encoding the MailboxAddress.Name in cases where the Name string contains\n  quotes or parenthesis (especially when unicode characters are within the quotes or parenthesis).\n* Improved logic in the address parser when it comes to unquoting mailbox names (i.o.w. unquote *before* decoding\n  rather than after).\n* Modified the Message-ID/Content-ID parser to be more lenient.\n  (issue [#835](https://github.com/jstedfast/MimeKit/issues/835))\n\n## MimeKit 3.4.0 (2022-08-17)\n\n* Introduced a new IPunycode interface and Punycode class allowing developers to override the default\n  implementation that uses .NET's IdnMapping class.\n  (issue [#801](https://github.com/jstedfast/MimeKit/issues/801))\n* Added HtmlAttributeCollection Contains, IndexOf and TryGetValue methods.\n* Dropped .NET5.0 support.\n* Changed HtmlToHtml converter to avoid decoding character references.\n  (issue [#808](https://github.com/jstedfast/MimeKit/issues/808))\n* Fixed BoundStream to only seek in the base stream if seeking is supported.\n* Added a new TextPart.TryDetectEncoding() API.\n  (issue [#804](https://github.com/jstedfast/MimeKit/issues/804))\n* Added support for message/feedback-report via a new MessageFeedbackReport class.\n* Fixed a potential memory leak.\n* When unquoting parameter values, don't convert tabs to spaces.\n  (issue [#809](https://github.com/jstedfast/MimeKit/issues/809))\n* Don't call Encoding.RegisterProvider() anymore. Rely on developers doing this themselves in their application\n  startup logic.\n* Remove System.Text.Encoding.CodePages dependency for net4x.\n* Expose the LineNumber property on MimeMessageBeginEventArgs and MimeEntityBeginEventArgs.\n  (issue [#819](https://github.com/jstedfast/MimeKit/issues/819))\n\n## MimeKit 3.3.0 (2022-06-11)\n\n* Added Import() methods for X509Certificate2 for all S/MIME contexts.\n  (issue [#784](https://github.com/jstedfast/MimeKit/issues/784))\n* Handle S/MIME sha# as well as sha-# micalg names for improved interop.\n  (issue [#790](https://github.com/jstedfast/MimeKit/issues/790))\n* Fixed the MemoryBlockStream.Read() method to handle cases where the length of the stream is longer than\n  int.MaxValue.\n* Fixed TnefPart.ConvertToMessage() to promote lone multipart/mixed subparts to become the message body\n  much like it used to work pre-v3.2.0. (issue [#789](https://github.com/jstedfast/MimeKit/issues/789))\n* Reduced memory usage when using SecureMimeContext.Compress() and CompressAsync().\n* Dropped support for net452 and net461 now that their life cycles have ended and are no longer supported\n  by Microsoft. (issue [#768](https://github.com/jstedfast/MimeKit/issues/768))\n* Added support for net462.\n\nSpecial thanks to Fedir Klymenko for his improvements to MemoryBlockStream and SecureMimeContext.Compress!\n\n## MimeKit 3.2.0 (2022-03-26)\n\n* Rewrote QuotedPrintableEncoder to more strictly fold at the specified line length.\n  (issue [#781](https://github.com/jstedfast/MimeKit/issues/781))\n* Change the default maxLineLength for quoted-printable/base64 encoders to 76 to match the recommendation\n  in the specification (was previously 72).\n* Use cached Task instances (e.g. Task.CompletedTask) when possible to improve performance.\n* Make use of ReadOnlySpan&lt;T&gt; instead of String.Substring() wherever possible to improve performance.\n* Reduced string allocations in other ways.\n* Provide MailboxAddress accessors for LocalPart and Domain.\n  (issue [#766](https://github.com/jstedfast/MimeKit/issues/766))\n* Replaced support for .NET Framework v4.6 with 4.6.1 and added a System.Text.Encoding.CodePages dependency\n  to solve various cases where MimeKit would fail to initialize properly on ASP.NET systems using net461\n  when system character encodings were not available.\n* Fixed MessagePartial to use invariant culture when setting number/total param values.\n* Make sure all int.TryParse() calls use the correct NumberStyles.\n* Make use of a ValueStringBuilder to construct strings without needing to allocate a StringBuilder.\n* Fixed InternetAddressList.TryParse() to fail on invalid input.\n  (issue [#762](https://github.com/jstedfast/MimeKit/issues/762))\n* Added dispose handling to MimeMessage.CreateFromMailMessage().\n* Improved MIME structure returned by TnefPart.ConvertToMessage().\n* Rewrote header folding logic to avoid string allocations.\n* Implemented IEquatable&lt;T&gt; on TnefNameId.\n* If iso-8859-1 isn't available, fall back to ASCII instead of Windows-1252.\n  (issue [#751](https://github.com/jstedfast/MimeKit/issues/751))\n\nSpecial Thanks to Jason Nelson for taking the lead on many of the listed (and unlisted) performance\nimprovements and helping me make MimeKit even more awesome!\n\n## MimeKit 3.1.1 (2022-01-30)\n\n* When initializing character encodings for netstandard and net50/net60, wrap the Reflection logic\n  to invoke System.Text.Encoding.RegisterProvider() in a try/catch to prevents exceptions when\n  using the netstandard version of MimeKit in a .NET Framework app.\n  (issue [#751](https://github.com/jstedfast/MimeKit/issues/751))\n* Added a work-around for Office365 `message/delivery-status` parts where all status groups after\n  the first are base64 encoded. This seems to be a bug in Office365 where it treats the first\n  status group as MIME entity and the following status groups as the content.\n  (issue [#250](https://github.com/jstedfast/MimeKit/issues/250))\n* Fixed the MimeMessage .ctor that takes object parameters to first check that a Message-Id\n  header was not supplied before generating one for the message.\n  (issue [#747](https://github.com/jstedfast/MimeKit/issues/747))\n* Fixed the BestEncodingFilter logic such that if any line in binary content is > 998 and it contains\n  nul bytes, it should recommend base64 (not quoted-printable).\n\n## MimeKit 3.1.0 (2022-01-14)\n\n* Always use a lowercase domain name in the Message-Id to work around bugs in eM Client.\n  (issue [#734](https://github.com/jstedfast/MimeKit/issues/734))\n* Improved handling of parsing Content-Types like \"multipart/multipart/mixed; boundary=...\".\n  (issue [#737](https://github.com/jstedfast/MimeKit/issues/737))\n* Added a maxLineLength argument to the QuotedPrintableEncoder .ctor.\n* Added maxLineLength arguments to EncoderFilter.Create() methods.\n* Fixed MimePart.Prepare() to remember the maxLineLength argument value for later use in the\n  WriteTo() implementation. This maxLineLength value can then be passed to the Base64 or\n  QuotedPrintable encoder so that it can properly limit lines to that length (up to a max of\n  76 characters as per the specs). (issue [#743](https://github.com/jstedfast/MimeKit/issues/743))\n* Added net6.0 to the list of TargetFrameworks.\n\n## MimeKit 3.0.0 (2021-12-11)\n\n* Removed APIs marked as \\[Obsolete\\] in 2.x.\n* Refactored X509CertificateDatabase protected methods to include a DbConnection parameter.\n* Removed OpenPgpContextBase by folding the logic into OpenPgpContext.\n* Added Async APIs for OpenPGP and S/MIME.\n* Lazy-load headers on MimeMessage and MimeEntity (and subclasses) to improve performance.\n* Added a new MimeReader class that acts as a lower-level MimeParser alternative, allowing developers\n  to parse MIME content without having to instantiate a MIME tree of objects or wait until the parser\n  has completed (and returned a MimeMessage or MimeEntity object) before processing MIME data. This is\n  conceptually similar to a SAX XML parser approach.\n* Added a new ExperimentalMimeParser that duplicates MimeParser functionality, but is built on top of\n  MimeReader. This implementation will eventually replace MimeParser once I get some feedback on it.\n  Should be ~5% faster than MimeParser.\n* Improved MimeParser performance slightly based on some of the experimentation done to make the\n  ExperimentalMimeParser fast.\n* Added CancellationToken arguments for some AttachmentCollection.Add() overloads.\n* Use 'net5.0' as the .NET 5.0 target framework moniker instead of 'net50'.\n  (issue [#720](https://github.com/jstedfast/MimeKit/issues/720))\n* Drop support for .NET 4.5 and replace it with .NET 4.5.2\n* Bumped Portable.BouncyCastle to 1.9.0\n* Added new MimeMessage.GetRecipients() method.\n* Make it possible to bypass MimeEntity preparation for signing by adding a PrepareBeforeSigning property to\n  CryptographyContext. (issue [#721](https://github.com/jstedfast/MimeKit/issues/721))\n* MimeMessage and MimeEntity now implement IDisposable.\n  (issue [#732](https://github.com/jstedfast/MimeKit/issues/732))\n\n## MimeKit 2.15.1 (2021-09-13)\n\n* Improved MimeParser to be a little more efficient based on work being done for the upcoming v3.0 release.\n* Fixed a bug in the MimeParser exposed by added unit tests regarding Content-Length handling.\n* Improved address parser error messages.\n* Fixed MailboxAddress.Address to be forgiving if there is trailing whitespace after the addr-spec token when\n  setting MailboxAddress.Address. (issue [#705](https://github.com/jstedfast/MimeKit/issues/705))\n* Fixed MimeMessage and MimeEntity.ToString() to not write a newline before the message/entity\n  (regression introduced in 2.14.0).\n\n## MimeKit 2.15.0 (2021-08-18)\n\n* Use DebugType=full for .NET Framework v4.x. (MailKit issue [#1239](https://github.com/jstedfast/MailKit/issues/1239))\n* Fixed bug in MultipartSigned.VerifyAsync() that would dispose of the crypto context before the async task was\n  complete, resulting in an OperationCanceledException.\n* Default to using the Environment.SpecialFolder.UserProfile directory instead of Personal when GNUPGHOME isn't defined\n  in the environment. The Personal directory maps to the MyDocuments directory, so this wasn't correct. The .gnupg\n  directory should be in the user's HOME directory.\n* Added ContentType.ToString(bool encode) and ContentDisposition.ToString(bool encode) convenience methods.\n* Changed the public Header.Parse/TryParse APIs to canonicalize header values to end with a newline even if the input\n  string does not. (issue [#695](https://github.com/jstedfast/MimeKit/issues/695))\n\n## MimeKit 2.14.0 (2021-07-28)\n\n* Allow ..'s and trailing .'s in the local-part of an addr-spec by introducing a new RfcComplianceMode.Looser\n  enum value that can be set on the ParserOptions.AddressParserComplianceMode property.\n  (issue [#682](https://github.com/jstedfast/MimeKit/issues/682))\n* Use Reflection to call Encoding.RegisterProvider() so that referencing the netstandard MimeKit assemblies\n  from .NET 4.8 won't crash. (issue [#683](https://github.com/jstedfast/MimeKit/issues/683))\n* Don't write the X-MimeKit warning header in ToString() anymore. This is a lost cause.\n* Updated the OpenPgpContext to default to keys.openpgp.org since keys.gnupg.net does not resolve via DNS anymore.\n\n## MimeKit 2.13.0 (2021-06-11)\n\n* Added a way to force MimeKit to always quote parameter values.\n  (issue [#674](https://github.com/jstedfast/MimeKit/issues/674))\n* Fixed PGP/MIME signatures to use the proper BEGIN/END PGP SIGNATURE markers instead of\n  BEGIN/END PGP MESSAGE markers by avoiding compressing the PGP signature packet.\n  (issue [#681](https://github.com/jstedfast/MimeKit/issues/681))\n\n## MimeKit 2.12.0 (2021-05-12)\n\n* Fixed S/MIME support using WindowsSecureMimeContext with MimeKit's CmsSigner classes which was\n  causing a PlatformNotSupportedException.\n  (issue [#664](https://github.com/jstedfast/MimeKit/issues/664))\n* When extracting HTML from TNEF, try to use the charset delcared in the HTML's meta tags.\n  (issue [#667](https://github.com/jstedfast/MimeKit/issues/667))\n* Added AttachmentCollection.AddAsync() methods.\n  (issue [#670](https://github.com/jstedfast/MimeKit/issues/670))\n* Enable SqliteCertificateDatabase initialization logic for .NET v5.0.\n  (issue [#673](https://github.com/jstedfast/MimeKit/issues/673))\n\n## MimeKit 2.11.0 (2021-03-12)\n\n* Fixed DSA key conversion logic to work more reliably.\n* Catch exceptions from IPGlobalProperties.GetIPGlobalProperties() and fall back to localhost.\n  (issue [#630](https://github.com/jstedfast/MimeKit/issues/630))\n* Fixed base64 encoder to only flush with a newline if it is midline.\n  (issue [#646](https://github.com/jstedfast/MimeKit/issues/646))\n* Added .NET 5 build targets and include in the nuget packages.\n* Added a new GnuPGContext .ctor that allows specifying a custom path.\n* Bumped Portable.BouncyCastle dependency to 1.8.10.\n* Improved HtmlWriter ArgumentException messages.\n\n## MimeKit 2.10.1 (2020-12-05)\n\n* Treat message/disposition-notification and message/delivery-status the same as text/*\n  when preparing for signing. (issue [#626](https://github.com/jstedfast/MimeKit/issues/626))\n* Always set Content-Disposition: inline for BodyBuilder.LinkedResources. This fixes a\n  regression introduced in 2.10.0.\n  (issue [#627](https://github.com/jstedfast/MimeKit/issues/627))\n* Fixed NuGet package references to System.Data.DataSetExtensions for netstandard2.1 and\n  net4x.\n\n## MimeKit 2.10.0 (2020-11-20)\n\n* Added SQL Server support. (issue [#619](https://github.com/jstedfast/MimeKit/issues/619))\n* Fixed a leak in SqlCertificateDatabase when creating the certificates database.\n* Bumped BouncyCastle dependency to v1.8.8. (issue [#610](https://github.com/jstedfast/MimeKit/issues/610))\n* Exposed some ArcVerifier and DkimVerifier internal methods.\n  (issue [#601](https://github.com/jstedfast/MimeKit/issues/601))\n* Improved MimeParser performance.\n* Fixed potential leaks in MimeParser when loading MimePart content in exception cases.\n* Made use of ArrayPools for various buffers which may help performance.\n  (issue [#616](https://github.com/jstedfast/MimeKit/issues/616))\n* Fixed MimeUtils.GenerateMessageId() to encode international domain names.\n* Fixed MimeUtils.GenerateMessageId() to cache the local hostname.\n  (issue [#612](https://github.com/jstedfast/MimeKit/issues/612))\n* Modified AttachmentCollection to use a custom implementation of Path.GetFileName()\n  that allows illegal path characters.\n* Only generate a ContentId for the MultipartRelated Root if it is not the first part.\n\n## MimeKit 2.9.2 (2020-09-12)\n\n* Include WindowsSecureMimeContext in the .NET Standard 2.x build.\n  (issue [#600](https://github.com/jstedfast/MimeKit/issues/600))\n* Fixed message.Prepare() to never choose the quoted-printable encoding\n  for non-text based MimeParts.\n  (issue [#598](https://github.com/jstedfast/MimeKit/issues/598))\n* Added work-around for mailers that don't use a ';' between Content-Type\n  and Content-Disposition parameters.\n  (issue [#595](https://github.com/jstedfast/MimeKit/issues/595))\n* Added improved error reporting for ArcVerifier.\n  (issue [#591](https://github.com/jstedfast/MimeKit/issues/591))\n* Added another work-around for parsing Authentication-Results headers.\n  (issue [#590](https://github.com/jstedfast/MimeKit/issues/590))\n* MimeMessage.ToString() now adds an X-MimeKit-Warning header to the\n  beginning of the output string to make it clear to developers doing this\n  that they are Doing it Wrong(tm).\n* Added a TLS-Required HeaderId enum value.\n\n## MimeKit 2.9.1 (2020-07-11)\n\n* Refactored OpenPgpContext to separate out key storage implementation.\n  (issue [#576](https://github.com/jstedfast/MimeKit/issues/576))\n* Fixed the TextToFlowed converter.\n  (issue [#580](https://github.com/jstedfast/MimeKit/issues/580))\n* Protect against ABRs in AuthenticationResults.TryParse().\n  (issue [#581](https://github.com/jstedfast/MimeKit/issues/581))\n* The net45 version of MimeKit now depends on Portable.BouncyCastle instead of official\n  BouncyCastle.\n* Added MimeParser events to report stream offsets for MimeMessages and MimeEntities.\n  (issue [#582](https://github.com/jstedfast/MimeKit/issues/582))\n* Fixed DkimPublicKeyLocatorBase to treat unspecified 'k' values in DKIM DNS records as\n  \"k=rsa\".\n  (issue [#583](https://github.com/jstedfast/MimeKit/issues/583))\n* Fixed date format serializer to use CultureInfo.InvariantCulture.\n* Fixed AuthenticationResults parser to allow '_' characters in method results.\n  (issue [#584](https://github.com/jstedfast/MimeKit/issues/584))\n* Improved RSACng and DSACng support.\n\n## MimeKit 2.8.0 (2020-05-30)\n\n* Improved logic for verifying signatures for MimeParts containing mixed line endings.\n  (issue [#569](https://github.com/jstedfast/MimeKit/issues/569))\n* Fixed MailboxAddress parser to decode IDN-encoded local-parts of email addresses.\n  (MailKit issue [#1026](https://github.com/jstedfast/MailKit/issues/1026))\n* Added new MailboxAddress.GetAddress(bool idnEncode) method.\n* Improved subclassability of OpenPgpContext by making a number of methods virtual.\n  (issue [#571](https://github.com/jstedfast/MimeKit/issues/571))\n* Added support for RSACng and DSACng.\n  (issue [#567](https://github.com/jstedfast/MimeKit/issues/567))\n* Dropped Xamarin platforms since they are compatible with netstandard2.0.\n\n## MimeKit 2.7.0 (2020-05-19)\n\n* Fixed InternetAddressList.Insert() to allow inserting at the end of the list.\n  (issue [#559](https://github.com/jstedfast/MimeKit/issues/559))\n* Added ParserOptions.MaxMimeDepth to allow developers to set the max nesting depth\n  allowed by the parser.\n* Added logic to handle multipart children without any headers or content.\n* Added a new Verify(bool verifySignatureOnly) method to IDigitalSignature for\n  developers who just want to be able to verify the signature without worrying\n  about the certificate chain.\n* Fixed MimePart.WriteTo() to avoid canonicalizing line endings for MimeParts that\n  do not define a Content-Transfer-Encoding.\n  (issue [#569](https://github.com/jstedfast/MimeKit/issues/569))\n* NuGet packages now include the portable pdb's.\n\n## MimeKit 2.6.0 (2020-04-03)\n\n* Fixed the MimeEntity.ContentId setter to use ParseUtils.TryParseMsgId() instead of\n  MailboxAddress.TryParse() so that it is more lenient in what it accepts.\n  (issue [#542](https://github.com/jstedfast/MimeKit/issues/542))\n* Added an HtmlTokenizer.IgnoreTruncatedTags property which is useful when working with\n  truncated HTML.\n* Optimized the heck out of HtmlEntityDecoder.\n* Added a TextPart.Format property for a quick way to determine the type of text it\n  contains.\n* Added text/plain and text/html preview/snippet generators (PlainTextPreviewer and\n  HtmlTextPreviewer, respectively). This is part of a larger improvement to MailKit's\n  text preview feature for IMAP.\n  (MailKit issue [#1001](https://github.com/jstedfast/MailKit/issues/1001))\n* Fixed SqlCertificateDatabase to accept null SubjectKeyIdentifiers.\n* Changed Header.FormatRawValue() to be protected virtual and added Header.SetRawValue()\n  to allow developers to override the default formatting behavior by either subclassing\n  Header or by calling header.SetRawValue().\n  (issue [#546](https://github.com/jstedfast/MimeKit/issues/546))\n* Switched MimeKit for Android and iOS over to using Portable.BouncyCastle.\n* Added MimeTypes.Register() to allow developers to register their own mime-type mappings\n  to file extensions.\n\n## MimeKit 2.5.2 (2020-03-14)\n\n* Updated net46, net47, and net48 builds to reference Portable.BouncyCastle instead of\n  the standard BouncyCastle package, just like the netstandard builds.\n  (issue [#540](https://github.com/jstedfast/MimeKit/issues/540))\n* Fixed extraction of TNEF EmbeddedMessage attachment data to skip the leading GUID.\n  (issue [#538](https://github.com/jstedfast/MimeKit/issues/538))\n* Added a few more TNEF property tags.\n* Fixed the HtmlEntityDecoder to require some named attributes to end with a `;`.\n\n## MimeKit 2.5.1 (2020-02-15)\n\n* Fixed parsing of email addresses containing unicode or other types of 8-bit text.\n  (issue [#536](https://github.com/jstedfast/MimeKit/issues/536))\n* Added a MimeTypes.TryGetExtension() method to try and get a file name extension\n  based on a mime-type.\n  (issue [#534](https://github.com/jstedfast/MimeKit/issues/534))\n* Updated mime-type mappings.\n\n## MimeKit 2.5.0 (2020-01-18)\n\n* Fixed message reserialization after prepending headers.\n  (issue [#524](https://github.com/jstedfast/MimeKit/issues/524))\n* Added a ContentType.CharsetEncoding property.\n  (issue [#526](https://github.com/jstedfast/MimeKit/issues/526))\n* Allow empty prop-spec token values in Authentication-Results headers.\n  (issue [#527](https://github.com/jstedfast/MimeKit/issues/527))\n* Added logic to quote Authentication-Results pvalue tokens if needed.\n* Added support for converting RSACng keys into BouncyCastle keys for\n  net4x versions that support it.\n* Added support for RSAES-OAEP for the BouncyCastle backend.\n  (issue [#528](https://github.com/jstedfast/MimeKit/issues/528))\n* Updated and changed the API for RSASSA-PSS. CmsSigner now has a\n  RsaSignaturePadding property which obsoletes the previous\n  RsaSignaturePaddingScheme property.\n* Added more columns to the default SQLite database CERTIFICATES table\n  that allow more optimal SQL searches for certificates given various\n  matching criteria.\n* Fixed WindowsSecureMimeContext.Decrypt() to make sure it doesn't stop\n  at the first failed recipient.\n  (issue [#530](https://github.com/jstedfast/MimeKit/issues/530))\n* Fixed splitting and reassembly of message/partial messages.\n* Improved handling of Office365 Authentication-Results headers by adding\n  a Office365AuthenticationServiceIdentifier property to the\n  AuthenticationMethodResult class.\n* Fixed mailbox address parser to be more lenient about `\"[\"` and `\"]\"`\n  characters in the display-name.\n  (issue [#532](https://github.com/jstedfast/MimeKit/issues/532))\n\n## MimeKit 2.4.1 (2019-11-10)\n\n* Don't use PublicSign on non-Windows NT machines when building.\n  (issue [#516](https://github.com/jstedfast/MimeKit/issues/516))\n* Improved BouncyCastleSecureMimeContext logic for building certificate chains so that\n  certificate chains are included in the S/MIME signature.\n  (issue [#515](https://github.com/jstedfast/MimeKit/issues/515))\n* Improved SqlCertificateDatabase.Find() by using more IX509Selector properties.\n* Relaxed the Authentication-Results header parser a bit to allow '/' in pvalue tokens.\n  (issue [#518](https://github.com/jstedfast/MimeKit/issues/518))\n\n## MimeKit 2.4.0 (2019-11-02)\n\n* Added the `text/csv` mime-type to the `MimeTypes` mapping table for files with a .csv extension.\n* Expanded the .NETStandard API to match the .NET 4.5 API, so .NETStandard is now complete.\n* Dropped support for .NETPortable and WindowsPhone/Universal v8.1.\n* Added a net48 assembly to the NuGet package.\n* Improved HTML tokenizer performance.\n* Fixed X509Crl.IsDelta for CRLs without extensions.\n  (issue [#513](https://github.com/jstedfast/MimeKit/issues/513))\n* Added support for `message/global-delivery-status`, `message/global-disposition-notification`,\n  and `message/global-headers` to `MimeParser`.\n  (issue [#514](https://github.com/jstedfast/MimeKit/issues/514))\n* Fixed S/MIME signatures generated by a TemporarySecureMimeContext to include the certificate chain.\n  (issue [#515](https://github.com/jstedfast/MimeKit/issues/515))\n\n## MimeKit 2.3.2 (2019-10-12)\n\n* Fixed reserialization of message/rfc822 parts to not add an extra new-line sequence\n  to the end of the message. (issue [#510](https://github.com/jstedfast/MimeKit/issues/510))\n* Fixed DefaultSecureMimeContext to build the cert chain outside of the private key query.\n  (issue [#508](https://github.com/jstedfast/MimeKit/issues/508))\n* Modified the Message-Id parser to gobble ctrl chars in the local-part.\n* Fixed some buglets in the TextToFlowed converter involving space-stuffing lines.\n* Fixed BodyBuilder logic for constructing a body with an HtmlBody set to string.Empty.\n  (issue [#506](https://github.com/jstedfast/MimeKit/issues/506))\n* Fixed potential memory leaks in WindowsSecureMimeContext and BouncyCastleSecureMimeContext\n  in the Export() methods in cases where an exception is throw while adding certificates.\n* Removed MimeKit.Cryptography.NpgsqlCertificateDatabase. It is unlikely anyone actually\n  uses this.\n\n## MimeKit 2.3.1 (2019-09-08)\n\n* Updated CmsSigner's default DigestAlgorithm to Sha256 instead of Sha1 to match\n  System.Security.Cryptography.Pkcs.CmsSigner's default.\n* Updated WindowsSecureMimeContext to default to IssuerAndSerialNumber for\n  System.Security.Cryptography.Pkcs.CmsSigner.\n* Added support for the RSASSA-PSS signature padding algorithm when using the\n  BouncyCastle backend.\n* Improved robustness of TNEF processing of email address fields.\n* Modified FilteredStream.Flush*() to not flush the source stream.\n  (MailKit issue [#904](https://github.com/jstedfast/MailKit/issues/904))\n* Added net46 and net47 assemblies to the NuGet package.\n\n## MimeKit 2.3.0 (2019-08-24)\n\n* Fixed MultipartRelated to fall back to the multipart/related type parameter when\n  locating the Root. (issue [#489](https://github.com/jstedfast/MimeKit/issues/489))\n* Improved Authentication-Results parser to handle non-standard syntax.\n  (issue [#490](https://github.com/jstedfast/MimeKit/issues/490))\n* When FormatOptions.AllowMixedHeaderCharsets is disabled, always use the user-specified\n  charset. Previously this could/would still use us-ascii and/or iso-8859-1 if the entire\n  header could fit within one of those charsets.\n  (issue [#493](https://github.com/jstedfast/MimeKit/issues/493))\n* Fixed the line length calculations in the BestEncodingFilter.\n  (issue [#497](https://github.com/jstedfast/MimeKit/issues/497))\n* Fixed Multipart to properly ensure the epilogue ends w/ a new-line when\n  FormatOptions.EnsureNewLine is true.\n  (issue [#499](https://github.com/jstedfast/MimeKit/issues/499))\n* Modified Multipart.WriteTo[Async] to not ensure that a Content-Type boundary parameter\n  has been set. This code-path was only hit if the multipart was parsed by the parser and\n  did not have a boundary parameter in the first place. In the interest of preserving\n  byte-for-byte compatibility with the original input, this sanity check has been removed.\n  (issue [#499](https://github.com/jstedfast/MimeKit/issues/499))\n\n## MimeKit 2.2.0 (2019-06-11)\n\n* Added support for [ARC](https://arc-spec.org).\n* Added AuthenticationResults class for parsing and constructing Authentication-Results and\n  ARC-Authentication-Results headers.\n* Added support for the Ed25519-SHA256 DKIM signature algorithm.\n* Obsoleted MimeMessage DKIM API's in favor of the newer DKIM API's:\n  * MimeMessage.Sign (DkimSigner, ...) has been replaced by DkimSigner.Sign (MimeMessage, ...).\n  * MimeMessage.Verify (Header, ...) has been replaced by DkimVerifier.Verify (MimeMessage, Header, ...).\n* Added DkimPublicKeyLocatorBase to help simplify implementing IDkimPublicKeyLocator.\n\n## MimeKit 2.1.5 (2019-05-13)\n\n* Updated the BouncyCastle assemblies to version 1.8.5 for iOS and Android.\n* Fixed a possible NullReferenceException when decoding S/MIME digital signatures.\n* Fixed the netstandard2.0 dependencies to no longer explicitly include System.Net.Http.\n  (issue [#482](https://github.com/jstedfast/MimeKit/issues/482))\n* Override Equals(object) and GetHashCode() for InternetAddress and InternetAddressList.\n  (issue [#481](https://github.com/jstedfast/MimeKit/issues/481))\n* Fixed TnefReader.Dispose() to avoid a potential NullReferenceException if double disposed.\n* Fixed the Message-Id, Content-Id, References and In-Reply-To parsers to be more liberal\n  in what they accept in terms of the `msg-id` token.\n* Changed the Header encoding logic for the In-Reply-To header to not rfc2047 encode the value\n  even if it is longer than the suggested line-length.\n  (issue [#479](https://github.com/jstedfast/MimeKit/issues/479))\n* Reduced netstandard dependencies. (issue [#475](https://github.com/jstedfast/MimeKit/issues/475))\n\n## MimeKit 2.1.4 (2019-04-13)\n\n* Added a setter for FormatOptions.MaxLineLength, allowing developers to override this value.\n* Improved TNEF handling of Content-Disposition and Content-Id properties.\n  (issue [#470](https://github.com/jstedfast/MimeKit/pull/470) and\n  issue [#471](https://github.com/jstedfast/MimeKit/pull/471))\n* Improved Content-Id parser to be more forgiving with improperly formatted IDs.\n  (issue [#472](https://github.com/jstedfast/MimeKit/issue/472))\n* Added support for the text/rfc822-headers MIME-type via the new TextRfc822Headers class.\n  (issue [#474](https://github.com/jstedfast/MimeKit/issue/474))\n* Added fallback logic for international email addresses that are not properly encoded in UTF-8.\n  (issue [#477](https://github.com/jstedfast/MimeKit/issue/477))\n\n## MimeKit 2.1.3 (2019-02-24)\n\n* Fixed an NRE in X509CertificateDatabase.Dispose().\n* Fixed TextPart.Text and GetText() to properly canonicalize EOLN for multi-byte charsets\n  such as UTF-16. (issue [#442](https://github.com/jstedfast/MimeKit/issues/442))\n* Fixed System.Net.Mail.MailMessage cast to MimeMessage when the ContentStream of\n  the attachments has not been rewound to the beginning of the stream.\n  (issue [#467](https://github.com/jstedfast/MimeKit/issues/467))\n* Changed ParserOptions.AllowAddressesWithoutDomain to work as users expected and\n  moved the old logic into ParserOptions.AllowUnquotedCommasInAddresses.\n  (issue [#465](https://github.com/jstedfast/MimeKit/issues/465))\n\n## MimeKit 2.1.2 (2018-12-30)\n\n* Fixed WindowsSecureMimeDigitalCertificate logic for ECDsa.\n* Added X509Certificate.GetPublicKeyAlgorithm() extension method.\n* Modified ApplicationPkcs7Mime to be less strict about the smime-type.\n\n## MimeKit 2.1.1 (2018-12-16)\n\n* Mapped the TNEF Sensitivity property to the Sensitivity message header when calling\n  TnefPart.ConvertToMessage().\n* Fixed the TNEF Importance and Priority mappings when calling TnefPart.ConvertToMessage().\n* Added more TnefPropertyId's that have been identified.\n* Map PidTagTnefCorrelationKey to the Message-Id message header.\n* When the TNEF data does not have a SentDate property, set the MimeMessage.Date property\n  to DateTimeOffset.MinValue instead of DateTimeOffset.Now.\n* Fixed TnefPart.ConvertToMessage() to check the TNEF SubjectPrefix and NormalizedSubject\n  properties and use them if a TNEF Subject property is not available.\n* Fixed TNEF logic for extracting attachment content to not truncate some bytes from the beginning\n  of the content.\n* Added more fallbacks for attempting to extract the sender information out of the TNEF data.\n* Bumped Android and iOS versions of BouncyCastle to v1.8.4.\n\n## MimeKit 2.1.0 (2018-12-01)\n\n* Optimized SecureMimeCryptographyContext.Supports() and OpenPgpCryptographyContext.Supports()\n  implementations.\n* Optimized the OptimizedOrdinalIgnoreCaseComparer even more.\n* Fixed OpenPgpDigitalCertificate.ExpirationDate for PGP keys that never expire.\n* Reduced string allocations in MultipartSigned.Verify() and MultipartEncrypted.Decrypt().\n* Fixed OpenPgpContext.Decrypt() to make sure to always clean up MemoryBlockStreams.\n* Added a bunch more HeaderId enum values.\n* Improved header folding logic for headers with long words.\n  (issue [#451](https://github.com/jstedfast/MimeKit/issues/451))\n\n## MimeKit 2.0.7 (2018-10-28)\n\n* Fixed a bug in the UUEncoder.\n* Fixed a bug in MimeIterator.MoveTo().\n* Modified BodyBuilder.ToMessageBody() to avoid returning a multipart/mixed with only a single\n  child. (issue [#441](https://github.com/jstedfast/MimeKit/issues/441))\n* Modified TnefPart to no longer set the name parameter on the Content-Type header of\n  extracted message bodies. (issue [#435](https://github.com/jstedfast/MimeKit/issues/435))\n* Fixed various locations that loaded content from files to use FileShare.Read so as to avoid file\n  sharing violations if the application already has that file opened elsewhere. (issue [#426](https://github.com/jstedfast/MimeKit/issues/426))\n* Improved address parser to handle \"local-part (User Name)\" style addresses.\n* Updated the iOS and Android BouncyCastle dependency to 1.8.3.\n* Modified TextPart.Text and GetText() to canonicalize the newlines. (issue [#442](https://github.com/jstedfast/MimeKit/issues/442))\n* Fixed WindowsSecureMimeContext.EncapsulatedSign (CmsSigner, ...) and Sign (CmsSigner, ...).\n* Added SecureMimeContext.Import(string, string) to import passworded pk12 files.\n* Improved MimeParser's support of Content-Length.\n* Fixed MimeParser.ParseEntity() and MimeEntity.Load() to throw a FormatException if the\n  stream does not have properly formatted headers. (issue [#443](https://github.com/jstedfast/MimeKit/issues/443))\n* Added support for message/global.\n\n## MimeKit 2.0.6 (2018-08-04)\n\n* Added more bounds checking for parsing mailbox addresses to fix IndexOutOfRangeExceptions\n  given an incomplete address like \"Name <\". (issue [#421](https://github.com/jstedfast/MimeKit/issues/421))\n* Fixed support for parsing mbox files using Content-Length.\n* Modified the TextPart.Text getter property to check for a UTF-16 BOM and use an appropriate\n  UTF-16 System.Text.Encoding if found instead of simply assuming UTF-8 and falling back to\n  iso-8859-1. (issue [#417](https://github.com/jstedfast/MimeKit/issues/417))\n* Minor optimizations.\n\n## MimeKit 2.0.5 (2018-07-07)\n\n* Make sure messages created from System.Net.Mail.MailMessages have a Date header. (MailKit issue [#710](https://github.com/jstedfast/MailKit/issues/710))\n* Allow developers to pass in their own SecureRandom when generating PGP key pairs. (issue [#404](https://github.com/jstedfast/MimeKit/issues/404))\n* Modified MemoryBlockStream to use a shared buffer pool to relieve pressure on the GC. (MailKit issue [#725](https://github.com/jstedfast/MailKit/issues/725))\n\n## MimeKit 2.0.4 (2018-05-21)\n\n* The default value of the `CheckCertificateRevocation` property located on the `BouncyCastleSecureMimeContext` has been changed\n  to `false` due to privacy concerns noted in the [Efail](https://efail.de) document published in May of 2018. Clients that wish\n  to continue automatic downloads of S/MIME CRLs can manually set the property to `true`.\n* Properly wrap long mailbox names with quoted phrases.\n* Fixed parsing of header blocks that span across read boundaries. (issue [#395](https://github.com/jstedfast/MimeKit/issues/395))\n* Added FormatOptions.EnsureNewLine property (MailKit issue [#251](https://github.com/jstedfast/MailKit/issues/251))\n* Enable System.Net.Mail support for .NET Core 2.0. (issue [#393](https://github.com/jstedfast/MimeKit/issues/393))\n\n## MimeKit 2.0.3 (2018-04-15)\n\n* Allow empty TextBody and HtmlBody properties for BodyBuilder. (issue [#391](https://github.com/jstedfast/MimeKit/issues/391))\n* Fixed BodyBuilder.Attachments.Add() to properly handle message/rfc822 attachments.\n* Fixed HTML entity encoder logic when a surrogate pair is at the end of the input. (issue [#385](https://github.com/jstedfast/MimeKit/issues/385))\n\n## MimeKit 2.0.2 (2018-03-18)\n\n* IDN encode/decode the local part of mailbox addresses as well. (MailKit issue [#649](https://github.com/jstedfast/MailKit/issues/649))\n* Added a record for .epub to the MimeTypes database. (issue [#376](https://github.com/jstedfast/MimeKit/issues/376))\n* Explicitly pass 'false' as the silent argument to SignedCms.ComputeSignature(). (issue [#374](https://github.com/jstedfast/MimeKit/issues/374))\n* Make sure the MimeParser does not hang if the last header line is truncated before CRLF.\n* Don't use Encoder/DecoderExceptionFallbacks in the TNEF reader. (issue [#370](https://github.com/jstedfast/MimeKit/issues/370))\n* Provide a better error message when the cert within a pkcs12 cannot digital sign. (issue [#367](https://github.com/jstedfast/MimeKit/issues/367))\n* Fixed TemporarySecureMimeContext to key off the certificate's fingerprint.\n\n## MimeKit 2.0.1 (2018-01-06)\n\n* Improved the HTML parser logic to better handle a number of edge cases.\n* MimeKit will now automatically download CRLs based on the CRL Distribution Point\n  certificate extension if any HTTP URLs are defined (LDAP and FTP are not yet supported)\n  when verifying S/MIME digital signatures using a derivative of the\n  BouncyCastleSecureMimeContext backend (the WindowsSecureMimeContext gets this for free\n  from System.Security's CMS implementation).\n* Fixed OpenPgpContext.RetrievePublicKeyRingAsync() to use the filtered stream.\n* Added support for using the Blowfish encryption algorithm with S/MIME (only supported\n  in the BouncyCastle backends).\n* Added support for using the SEED encryption algorithm with S/MIME (also only supported\n  in the BouncyCastle backends).\n* Added an optional 'algorithm' argument to OpenPgpContext.GenerateKeyPair() to allow\n  specifying the symmetric key algorithm to use in generating the key pair. This defaults\n  to AES-256, which is the same value used in older versions of MimeKit.\n\n## MimeKit 2.0.0 (2017-12-22)\n\n* Added IDkimPublicKeyLocator.LookupPublicKeyAsync() and MimeMessage.VerifyAsync() to support\n  asynchronous DNS lookups of DKIM public keys.\n* Fixed tokenization of unquoted HTML attributes containing entities.\n* Vastly improved the WindowsSecureMimeContext to do everything using System.Security\n  instead of a mix of System.Security and Bouncy Castle.\n* Refactored SecureMimeContext into a base SecureMimeContext and a\n  BouncyCastleSecureMimeContext that contained all of the Bouncy Castle-specific logic.\n* Added useful extension methods to facilitate conversion between System.Security and\n  Bouncy Castle crypto types (such as X509Certificates and AsymmetricAlgorithms).\n* Renamed the IContentObject interface to IMimeContent.\n* Renamed the ContentObject class to MimeContent.\n* Renamed the MimePart.ContentObject property to MimePart.Content.\n* Dropped support for .NET 3.5 and .NET 4.0.\n\n## MimeKit 1.22.0 (2017-11-24)\n\n* Fixed a buffering bug in MimeParser's header parser. (issue [#358](https://github.com/jstedfast/MimeKit/issues/358))\n* Set the TnefReader charset on extracted text/plain and text/html bodies. (issue [#357](https://github.com/jstedfast/MimeKit/issues/357))\n* Added safeguard to protect against malformed nested group addresses which could cause\n  a stack overflow in the parser. ParserOptions now has a way of limiting the recursive\n  depth of rfc822 group addresses using the MaxAddressGroupDepth property. (issue [#355](https://github.com/jstedfast/MimeKit/issues/355))\n* Fixed the S/MIME certificate database for .NETStandard by using GetFieldValue() instead\n  of GetBytes() which is not supported on .NETStandard. (issue [#351](https://github.com/jstedfast/MimeKit/issues/351))\n\n## MimeKit 1.20.0 (2017-10-28)\n\n* Added async support for writing MimeMessage, MimeEntity, HeaderList and ContentObject.\n* Added async support for parsing MimeMessage, MimeEntity, and HeaderList.\n* Added async support to MimeKit.IO streams.\n* Removed methods marked [Obsolete] (which have been marked obsolete for several years now).\n* Improved performance of writing messages by a small amount.\n* Fixed SecureMimeDigitalSignature to capture the signature digest algorithm used by the sending\n  client. (issue [#341](https://github.com/jstedfast/MimeKit/issues/341))\n* Fixed the S/MIME decoder to correctly determine the RC2 algorithm used by the sending client.\n  (issue [#337](https://github.com/jstedfast/MimeKit/issues/337))\n* Fixed a bug in BoundStream.Seek().\n\n## MimeKit 1.18.1 (2017-09-03)\n\n* Added CanSign() and CanEncrypt() methods to CryptographyContext for checking\n  whether or not a mailbox can be used for signing or be encrypted to. (issue [#325](https://github.com/jstedfast/MimeKit/issues/325))\n* Automatically register the CodePagesEncodingProvider when running on .NETStandard. (issue [#330](https://github.com/jstedfast/MimeKit/issues/330))\n* Fixed MimeMessage.TextBody to return null when the top-level MIME part is a TextPart\n  marked as an attachment.\n* Fixed the HtmlToHtml converter to suppress comments if the HtmlTagContext's SuppressInnerContent\n  property is active (even if FilterComments is false).\n* Documented OpenPgpContext.GenerateKeyPair() which was added in 1.18.0.\n* Added OpenPgpContext.Delete() methods to delete public and secret keyrings.\n* Added OpenPgpContext.SignKey().\n* Remove \"Version:\" header from armored OpenPGP output. (issue [#319](https://github.com/jstedfast/MimeKit/issues/319))\n\n## MimeKit 1.18.0 (2017-08-07)\n\n* Allow importing of known PGP keys (needed when re-importing keys after signing them). (issue [#315](https://github.com/jstedfast/MimeKit/issues/315))\n* Added APIs to enumerate public and secret PGP keys.\n* Added an OpenPgpDetectionFilter to detect OpenPGP blocks and their stream offsets.\n* Added a MimeMessage.WriteTo() overload that takes a bool headersOnly argument.\n* Pushed SecureMimeContext's EncryptionAlgorithm preferences down into CryptographyContext.\n* Updated GnuPGContext to load algorithm preferences from gpg.conf.\n* Fixed TemporarySecureMimeContext to use the fingerprint in the certificate lookup methods\n  when the MailboxAddress argument is a SecureMailboxAddress. (issue [#322](https://github.com/jstedfast/MimeKit/issues/322))\n* Fall back to using the Subject Alternative Rfc822 Name if the SubjectEmailAddress fails. (issue [#323](https://github.com/jstedfast/MimeKit/issues/323))\n\n## MimeKit 1.16.2 (2017-07-01)\n\n* Fixed a bug in the MailMessage to MimeMessage conversion which corrupted the Subject string. (issue [#306](https://github.com/jstedfast/MimeKit/issues/306))\n* If no KeyUsage extension exists for an X509 certificate, assume no restrictions on key usage.\n* Throw an exception if there is a problem building an X509 certificate chain when verifying\n  S/MIME signatures.\n\n## MimeKit 1.16.1 (2017-05-05)\n\n* Fixed TextToHtml and FlowedToHtml's OutputHtmlFragment property to work.\n* Fixed EncodeAddrspec and DecodeAddrspec to handle string.Empty. (issue [#302](https://github.com/jstedfast/MimeKit/issues/302))\n* Allow string.Empty as a valid addrspec for MailboxAddress. (issue [#302](https://github.com/jstedfast/MimeKit/issues/302))\n* Catch exceptions trying to import CRLs and Certs when verifying S/MIME signatures. (issue [#304](https://github.com/jstedfast/MimeKit/issues/304))\n\n## MimeKit 1.16.0 (2017-04-21)\n\n* Added new ParserOptions option to allow local-only mailbox addresses (e.g. no @domain).\n* Improved address parser to interpret unquoted names containing commas in email addresses\n  as all part of the same name/email address instead of as a separate email address.\n* Greatly improved the WindowsSecureMimeContext backend.\n* A number of fixes to bugs exposed by an ever-increasing set of unit tests (up to 87% coverage).\n\n## MimeKit 1.14.0 (2017-04-09)\n\n* Added International Domain Name support for email addresses.\n* Added a work-around for mailers that didn't provide a disposition value in a\n  Content-Disposition header.\n* Added a work-around for mailers that quote the disposition value in a Content-Disposition\n  header.\n* Added automatic key retrieval functionality for the GnuPG crypto context.\n* Added a virtual DigestSigner property to DkimSigner so that consumers can hook into services\n  such as Azure. (issue [#296](https://github.com/jstedfast/MimeKit/issues/296))\n* Fixed a bug in the MimeFilterBase.SaveRemainingInput() logic.\n* Preserve munged From-lines at the start of message/rfc822 parts.\n* Map code page 50220 to iso-2022-jp.\n* Format Reply-To and Sender headers as address headers when using Header.SetValue().\n* Fixed MimeMessage.CreateFromMailMessage() to set MimeVersion. (issue [#290](https://github.com/jstedfast/MimeKit/issues/290))\n\n## MimeKit 1.12.0 (2017-03-12)\n\n* Added new DKIM MimeMessage.Sign() methods that take an IList&lt;string&gt; of header field names\n  to sign.\n* Improved the address parser to allow the lack of a terminating ';' character at the end of\n  group addresses.\n* Improved the address parser to unquoted ',' and '.' characters in the name component of\n  mailbox and group addresses.\n* Added support for CryptographyContext factories by adding new Register() methods that\n  take function callbacks that return a SecureMimeContext or OpenPgpContext. Thanks to\n  Christoph Enzmann for this feature. (issue [#283](https://github.com/jstedfast/MimeKit/issues/283))\n* Fixed DefaultSecureMimeContext..cctor() to not call Directory.CreateDirectory() on\n  the default database directory. Instead, let the .ctor() create it instead if and when\n  an instance of the DefaultSecureMimeContext is created. (issue [#285](https://github.com/jstedfast/MimeKit/issues/285))\n* Store DBNull in S/MIME SQL backends for null values (SQLite handles `null` but\n  databases such as Postgres do not). (issue [#286](https://github.com/jstedfast/MimeKit/issues/286))\n\n## MimeKit 1.10.1 (2017-01-28)\n\n* Fixed the Content-Type and Content-Disposition parameter parser to remove trailing lwsp from\n  unquoted parameter values. (issue [#278](https://github.com/jstedfast/MimeKit/issues/278))\n* Fixed MimePart.WriteTo() to not necessarily force the content to end with a new-line.\n\n## MimeKit 1.10.0 (2016-10-31)\n\n* Fixed OpenPgpContext.Verify() to throw FormatException if no data packets found.\n* Added new MailboxAddress constructors that do not take a 'name' argument. (issue [#267](https://github.com/jstedfast/MimeKit/issues/267))\n* Added an HtmlToHtml.FilterComments property to remove comments. (issue [#271](https://github.com/jstedfast/MimeKit/issues/271))\n* Modified address parser to handle invalid addresses like \"user@example.com <user@example.com>\".\n\n## MimeKit 1.8.0 (2016-09-25)\n\n* Improved parsing of malformed mailbox addresses.\n* Added DecompressTo() and DecryptTo() methods to SecureMimeContext.\n* Fixed MessagePartial.Split().\n\n## MimeKit 1.6.0 (2016-09-11)\n\n* Use RandomNumberGenerator.Create() for .NET Core instead of System.Random when generating\n  multipart boundaries.\n\n## MimeKit 1.4.2 (2016-08-14)\n\n* Strong-name the .NET Core assemblies.\n* Fixed logic for selecting certificates from the Windows X.509 Store. (issue [#262](https://github.com/jstedfast/MimeKit/issues/262))\n\n## MimeKit 1.4.1 (2016-07-17)\n\n* Fixed QuotedPrintableDecoder to handle soft breaks that fall on a buffer boundary.\n* Fixed MimeMessage.WriteTo() to properly respect the FormatOptions when writing the\n  message headers.\n* Updated TextFormat to contain a Plain value (Text is now an alias) to hopefully make\n  its mapping to text/plain more obvious.\n* Added new TextPart .ctor that takes a TextFormat argument so that developers that\n  don't understand mime-types can more easily intuit what that argument should be.\n\n## MimeKit 1.4.0 (2016-07-01)\n\n* Added support for .NET Core 1.0\n* Changed the default value of FormatOptions.AllowMixedHeaderCharsets to false.\n* Added a new DkimSigner .ctor that takes a stream of key data. (issue [#255](https://github.com/jstedfast/MimeKit/issues/255))\n\n## MimeKit 1.2.25 (2016-06-16)\n\n* Fixed parsing bugs in MessageDeliveryStatus.StatusGroups. (issue [#253](https://github.com/jstedfast/MimeKit/issues/253))\n* Fixed MimeParser.ParseHeaders() to handle header blocks that do not end with a blank line. (issue [#250](https://github.com/jstedfast/MimeKit/issues/250))\n* Fixed the MailboxAddress parser to handle whitespace between '<' and the addr-spec.\n* Fixed TemporarySecureMimeContext to handle certificates with null email addresses. (issue [#252](https://github.com/jstedfast/MimeKit/issues/252))\n\n## MimeKit 1.2.24 (2016-05-22)\n\n* Modified MimeMessage .ctor to not add an empty To: header by default. (issue [#241](https://github.com/jstedfast/MimeKit/issues/241))\n* Modified MimeMessage to remove address headers when all addresses in that field are removed.\n* Properly apply SecurityCriticalAttribute to GetObjectData() on custom Exceptions.\n* Fixed TnefPropertyReader to convert APPTIME values into DateTimes from the OLE Automation\n  Date format. (issue [#245](https://github.com/jstedfast/MimeKit/issues/245))\n\n## MimeKit 1.2.23 (2016-05-07)\n\n* Modified ParamaterList.TryParse() to handle quoted rfc2231-encoded param values. (issue [#239](https://github.com/jstedfast/MimeKit/issues/239))\n* Updated to reference BouncyCastle via NuGet packages rather than bundling the assemblies.\n* Fixed MimeParser to set a multipart's raw epilogue to null instead of an empty byte array.\n  Fixes some issues with digital signature verification (as well as DKIM verification).\n* Added an HtmlWriter.WriteText() override with Console.WriteLine() style params.\n* Added convenience MimeMessage property for the X-Priority header.\n* Fixed MimeMessage.ConvertFromMailMessage() to use appropriate MimeEntity subclasses. (issue [#232](https://github.com/jstedfast/MimeKit/issues/232))\n\n## MimeKit 1.2.22 (2016-02-28)\n\n* Added a new SecureMimeContext.Verify() overload that returns the extracted content stream.\n* Exposed the SecureMimeContext.GetDigitalSignatures() method as protected, allowing custom\n  subclasses to implement their own Verify() methods.\n* Fixed X509CertificateDatabase to store the X509Certificate NotBefore and NotAfter DateTimes\n  in UTC rather than LocalTime.\n* Added a work-around for GoDaddy's ASP.NET web host which does not support the iso-8859-1\n  System.Text.Encoding (used as a fallback encoding within MimeKit) by falling back to\n  Windows-1252 instead.\n* Added new convenience .ctors for CmsSigner and CmsRecipient for loading certificates from a\n  file or stream.\n* Fixed UrlScanner to properly deal with IPv6 literals in email addresses.\n\n## MimeKit 1.2.21 (2016-02-13)\n\n* Added a MultipartReport class for multipart/report.\n* Fixed serialization for embedded message/* parts. (issue [#228](https://github.com/jstedfast/MimeKit/issues/228))\n* Fixed MimeMessage.WriteTo() to only make sure that the stream ends with a newline if it\n  wasn't parsed. (issue [#227](https://github.com/jstedfast/MimeKit/issues/227))\n* Fixed MimeMessage to only set a MIME-Version if the message was not produced by the parser.\n* Ignore timezones outside the range of -1200 to +1400.\n* Added InternetAddress.Clone() to allow addresses to be cloned.\n* Properly serialize message/rfc822 parts that contain an mbox marker.\n* Fixed MimeMessage.DkimSign() to not enforce 7bit encoding of the body. (issue [#224](https://github.com/jstedfast/MimeKit/issues/224))\n* Fixed ParameterList.IndexOf(string) to be case insensitive.\n\n## MimeKit 1.2.20 (2016-01-24)\n\n* Fixed serialization of mime parts with empty content. (issue [#221](https://github.com/jstedfast/MimeKit/issues/221))\n* Fixed a bug in the TnefPropertyReader that would break when not all properties were read\n  by the consumer of the API.\n* Fixed the InternetAddress parser to throw a more informative error when parsing broken\n  routes in mailboxes.\n* Added HeaderList.Add(*, Encoding, string) and .Insert(*, Encoding, string) methods.\n* Added more OpenPgpContext.Encrypt() overloads (and equivalent MultipartEncrypted overloads).\n* Added OpenPgpContext.Import(PgpSecretKeyRing) and OpenPgpContext.Import(PgpSecretKeyRingBundle).\n* Fixed HtmlUtils.HtmlAttributeEncode() to properly encode non-ascii characters as entities.\n* Fixed HtmlUtils.HtmlEncode() to properly encode non-ascii characters as entities.\n* Fixed MimeParser to track whether or not each multipart had an end boundary so that\n  when they get reserialized, they match the original. (issue [#218](https://github.com/jstedfast/MimeKit/issues/218))\n* Implemented an optimized OrdinalIgnoreCase string comparer which improves the performance\n  of the MimeParser slightly.\n* Fixed QuotedPrintableDecoder to properly handle \"==\" sequences.\n* Added a ContentDisposition.TryParse(ParserOptions,string) method.\n* Added a ContentType.TryParse(ParserOptions,string) method.\n* Fixed MimeParser to trim the CR from the mbox From marker.\n* Fixed SqlCertificateDatabase to properly chain Dispose.\n\n## MimeKit 1.2.19 (2016-01-01)\n\n* Handle illegal Content-Id headers that do not enclose their values in <>'s. (issue [#215](https://github.com/jstedfast/MimeKit/issues/215))\n* Fixed reserialization of MimeParts with empty content. (issue [#213](https://github.com/jstedfast/MimeKit/issues/213))\n* Improved parsing logic for malformed Content-Type headers.\n* Fixed HtmlTokenizer to work properly when some closing tags were not lowercase.\n* Bumped Bouncy Castle to v1.8.1.\n\n## MimeKit 1.2.18 (2015-12-16)\n\n* Removed unimplemented TNEF APIs.\n* Use DateTime.UtcNow for S/MIME certificate validity checks.\n* Added ToString() methods on ContentType/Disposition that take FormatOptions.\n* Added a new ToString() method to InternetAddress that takes a FormatOptions. (issue [#208](https://github.com/jstedfast/MimeKit/issues/208))\n* Added a MimeEntity.WriteTo() method that takes a bool contentOnly parameter. (issue [#207](https://github.com/jstedfast/MimeKit/issues/207))\n* Added support for encoding parameter values using rfc2047 encoded-words instead of\n  the standard rfc2231 encoding.\n* Fixed SecureMailboxAddress's Fingerprint property to work with both the PGP key ID\n  *and* the fingerprint. Previously only worked with the PGP key id. (issue [#203](https://github.com/jstedfast/MimeKit/issues/203))\n* Added GroupAddress.Parse() and MailboxAddress.Parse() methods. (issue [#197](https://github.com/jstedfast/MimeKit/issues/197))\n* Set a default filename when generating application/pgp-signature parts. (issue [#195](https://github.com/jstedfast/MimeKit/issues/195))\n\n## MimeKit 1.2.17 (2015-12-05)\n\n* Fixed DkimRelaxedBodyFilter to properly handle CRLF split across buffers.\n* Added ContentType.IsMimeType method to replace CongtentType.Matches.\n* Added S/MIME, PGP and DKIM support to the PCL and WindowsUniversal versions of MimeKit.\n* Fixed PGP key expiration calculation when encrypting. (issue [#194](https://github.com/jstedfast/MimeKit/issues/194))\n\n## MimeKit 1.2.16 (2015-11-29)\n\n* Fixed relaxed body canonicalization logic for DKIM signatures. (issue [#190](https://github.com/jstedfast/MimeKit/issues/190))\n\n## MimeKit 1.2.15 (2015-11-22)\n\n* Fixed the Date parser to catch exceptions thrown by the DateTimeOffset .ctor if any of the\n  fields are out of range.\n* Fixed logic for trimming trailing blank lines for the DKIM relaxed body algorithm. (issue [#187](https://github.com/jstedfast/MimeKit/issues/187))\n* Fixed DKIM body filters to reserve extra space in the output buffer. (issue [#188](https://github.com/jstedfast/MimeKit/issues/188))\n* Allow specifying a charset encoding for each Content-Type/Disposition parameter.\n\n## MimeKit 1.2.14 (2015-10-18)\n\n* Fixed DKIM-Signature signing logic to use a UTC-based timestamp value rather than a\n  timestamp based on the local-time. (issue [#180](https://github.com/jstedfast/MimeKit/issues/180))\n* Fixed Multipart epilogue parsing and serialization logic to make sure that serializing\n  a multipart is properly byte-for-byte identical to the original text. This fixes a\n  corner-case that affected all types of digital signatures (DKIM, PGP, and S/MIME)\n  spanning across nested multiparts. (issue [#181](https://github.com/jstedfast/MimeKit/issues/181))\n* Fixed MimeMessage.WriteTo() to ensure that the output stream always ends with a new-line.\n\n## MimeKit 1.2.13 (2015-10-11)\n\n* Modified Base64Encoder's .ctor to allow specifying a maxLineLength.\n* Fixed DKIM signing logic for multipart/alternative messages. (issue [#178](https://github.com/jstedfast/MimeKit/issues/178))\n\n## MimeKit 1.2.12 (2015-09-20)\n\n* Prevent infinite loop when flushing CharsetFilter when there is no input data left.\n\n## MimeKit 1.2.11 (2015-09-06)\n\n* Fixed an IndexOutOfRangeException bug in the TextToHTML converter logic. (issue [#165](https://github.com/jstedfast/MimeKit/issues/165))\n* Fixed the DKIM-Signature verification logic to be more lenient in parsing DKIM-Signature\n  headers. (issue [#166](https://github.com/jstedfast/MimeKit/issues/166))\n* Fixed the DKIM-Signature verification logic to error-out if the h= parameter does not\n  include the From header. (issue [#167](https://github.com/jstedfast/MimeKit/issues/167))\n* Fixed the DKIM-Signature verification logic to make sure that the domain-name in the i=\n  param matches (or is a subdomain of) the d= value. (issue [#169](https://github.com/jstedfast/MimeKit/issues/169))\n* Fixed the CharsetFilter to avoid calling Convert() on empty input.\n* Fixed logic for canonicalizing header values using the relaxed DKIM algorithm.\n  (issue [#171](https://github.com/jstedfast/MimeKit/issues/171))\n* Fixed AttachmentCollection to mark embedded parts as inline instead of attachment.\n* Fixed the DKIM-Signature logic (both signing and verifying) to properly canonicalize the\n  body content. (issue [#172](https://github.com/jstedfast/MimeKit/issues/172))\n\n## MimeKit 1.2.10 (2015-08-16)\n\n* Added public Stream property to IContentObject.\n* Implemented a better fix for illegal unquoted multi-line Content-Type and\n  Content-Disposition parameter values. (issue [#159](https://github.com/jstedfast/MimeKit/issues/159))\n* Fixed the UrlScanner to properly handle \"ftp.\" at the very end of the message text.\n  (issue [#161](https://github.com/jstedfast/MimeKit/issues/161))\n* Fixed charset handling logic to not override charset aliases already in the cache.\n\n## MimeKit 1.2.9 (2015-08-08)\n\n* Fixed WriteTo(string fileName) methods to overwrite the existing file. (issue [#154](https://github.com/jstedfast/MimeKit/issues/154))\n* Updated InternetAddressList to implement IComparable.\n* Fixed DKIM-Signature generation and verification.\n* Added support for Message-Id headers that do not properly use encapsulate the value\n  with angle brackets.\n\n## MimeKit 1.2.8 (2015-07-19)\n\n* Added a new MessageDeliveryStatus MimePart subclass to make message/delivery-status\n  MIME parts easier to deal with.\n* Improved HtmlTokenizer's support for the script tag - it is should now be completely\n  bug free.\n* Fixed to filter out duplicate recipients when encrypting for S/MIME or PGP.\n* Fixed MimeParser to handle a message stream of just \"\\r\\n\".\n* Add a leading space in the Sender and Resent-Sender header values.\n\n## MimeKit 1.2.7 (2015-07-05)\n\n* Fixed encoding GroupAddress with multiple mailbox addresses.\n* Fixed MessageIdList to be less strict in what it will accept.\n* Fixed logic for DKIM-Signature header folding.\n\n## MimeKit 1.2.6 (2015-06-25)\n\n* Fixed a bug in the HTML tokenizer to handle some weird HTML created by Outlook 15.0.\n* Added CmsRecipient .ctor overloads that accept X509Certificate2. (issue [#149](https://github.com/jstedfast/MimeKit/issues/149))\n\n## MimeKit 1.2.5 (2015-06-22)\n\n* Changed BodyParts and Attachments to be IEnumerable&lt;MimeEntity&gt; -\n  WARNING! This is an API change! (issue [#148](https://github.com/jstedfast/MimeKit/issues/148))\n* Moved the IsAttachment property from MimePart down into MimeEntity.\n* Added MimeMessage.Importance and MimeMessage.Priority properties.\n* Vastly improved the HtmlToHtml text converter with a w3 compliant\n  HTML tokenizer.\n\n## MimeKit 1.2.4 (2015-06-14)\n\n* Added support for generating and verifying DKIM-Signature headers.\n* Improved error handling for Encoding.GetEncoding() in CharsetFilter constructors.\n* Fixed buffering in the HTML parser.\n* Fixed Windows and Temporary S/MIME contexts to use case-insensitive address\n  comparisons like the other backends do. (issue [#146](https://github.com/jstedfast/MimeKit/issues/146)).\n* Added HeaderList.LastIndexOf() convenience methods.\n* Added a new Prepare() method to prepare a message or entity for transport\n  and/or signing (used by MultipartSigned and MailKit.SmtpClient) to reduce\n  duplicated code.\n* Fixed FilteredStream.Flush() to flush filters even when no data has been\n  written.\n* Fixed the ChainedStream.Read() logic. (issue [#143](https://github.com/jstedfast/MimeKit/issues/143))\n* Added EncoderFilter and DecoderFilter.Create() overloads that take an encoding\n  name (string).\n* HeaderList.WriteTo() now adds a blank line to the end of the output instead\n  of leaving this up to the MimeEntity.WriteTo() method. This was needed for\n  the DKIM-Signatures feature.\n\n## MimeKit 1.2.3 (2015-06-01)\n\n* Fixed TextToFlowed logic that stripped trailing spaces.\n* Switched to PCL Profile78 to support Xamarin.Forms.\n\n## MimeKit 1.2.2 (2015-05-31)\n\n* Added a MultipartAlternative class which adds some useful convenience methods\n  and properties for use with the multipart/alternative mime-type.\n* Fixed MimeKitLite's MimeParser to use TnefPart for the ms-tnef mime-types.\n* Fixed MimeMessage.TextBody to convert format=flowed into plain text.\n* Made BoundStream.LeaveOpen protected instead of private.\n* Fixed ChainedStream to dispose child streams when it is disposed.\n* Obsoleted MultipartEncrypted.Create() methods in favor of equivalent\n  Encrypt() and SignAndEncrypt() methods to make them a bit more intuitive.\n* Added a MimeVisitor class that implements the visitor pattern for visiting\n  MIME nodes.\n\n## MimeKit 1.2.1 (2015-05-25)\n\n* Added a Format property to ContentType.\n* Added a TryGetValue() method to ParameterList.\n* Added IsFlowed and IsRichText convenience properties to TextPart.\n* Fixed the HtmlToHtml converter to properly handle HTML text that begins\n  with leading text data.\n* Fixed MimeParser.ParseHeaders() to handle input that does not end with a\n  blank line. (issue [#142](https://github.com/jstedfast/MimeKit/issues/142))\n* Renamed MimeEntityConstructorInfo to MimeEntityConstructorArgs.\n* Modified the MimeParser to use TextPart to represent application/rtf.\n\n## MimeKit 1.2.0 (2015-05-24)\n\n* Force the use of the rfc2047 \"B\" encoding for ISO-2022-JP. (issue [#139](https://github.com/jstedfast/MimeKit/issues/139))\n* Added some text converters to convert between various text formats\n  including format=flowed and HTML.\n\n## MimeKit 1.0.15 (2015-05-12)\n\n* Fixed MimeMessage.WriteTo() to be thread-safe. (issue [#138](https://github.com/jstedfast/MimeKit/issues/138))\n\n## MimeKit 1.0.14 (2015-05-09)\n\n* Added support for .NET 3.5.\n* Added a convenience CmsSigner .ctor that takes an X509Certificate2 argument.\n* Fixed BodyBuilder to never return a TextPart w/ a null ContentObject.\n* Fixed TextPart.GetText() to protect against NullReferenceExceptions if the\n  ContentObject is null.\n* Fixed MimeFilterBase.EnsureOutputSize() to initialize OutputBuffer if it is\n  null. Prevents NullReferenceExceptions in obscure corner cases. (issue [#135](https://github.com/jstedfast/MimeKit/issues/135))\n* Added a TnefAttachFlags enum which is used to determine if image attachments\n  in MS-TNEF data are meant to have a Content-Disposition of \"inline\" when\n  extracted as MIME attachments. (issue [#129](https://github.com/jstedfast/MimeKit/issues/129))\n* Fixed TnefPart.ConvertToMessage() and ExtractAttachments() to use the\n  PR_ATTACH_MIME_TAG property to determine the intended mime-type for extracted\n  attachments.\n* Catch DecoderFallbackExceptions in MimeMessage.ToString() and fall back to\n  Latin1. (issue [#137](https://github.com/jstedfast/MimeKit/issues/137))\n\n## MimeKit 1.0.13 (2015-04-11)\n\n* Added a work-around for a bug in Thunderbird's multipart/related implementation.\n  (issue [#124](https://github.com/jstedfast/MimeKit/issues/124))\n* Improved MimeMessage.CreateFromMailMessage() a bit more to avoid creating empty\n  From, Reply-To, To, Cc and/or Bcc headers.\n* Modified the HeaderIdExtensions to only be available for the HeaderId enum values.\n\n## MimeKit 1.0.12 (2015-03-29)\n\n* Modified InternetAddressList.Equals() to return true if the lists contain the same\n  addresses even if they are in different orders. (issue [#118](https://github.com/jstedfast/MimeKit/issues/118))\n* Allow S/MIME certificates with the NonRepudiation key usage to be used for signing.\n  (issue [#119](https://github.com/jstedfast/MimeKit/issues/119))\n* Don't change the Content-Transfer-Encoding of MIME parts being encrypted as part of\n  a multipart/encrypted. (issue [#122](https://github.com/jstedfast/MimeKit/issues/122))\n* Fixed logic to decide if a PGP secret key is expired. (issue [#120](https://github.com/jstedfast/MimeKit/issues/120))\n* Added support for SecureMailboxAddresses to OpenPgpContext to allow key lookups by\n  fingerprints instead of email addresses.\n\n## MimeKit 1.0.11 (2015-03-21)\n\n* Added the ContentDisposition.FormData string constant.\n* Allow the ContentDisposition.Disposition property to be set to values other than\n  \"attachment\" and \"inline\". (issue [#112](https://github.com/jstedfast/MimeKit/issues/112))\n* Shortened the length of the local-part of auto-generated Message-Ids.\n* Fixed MimeMessage.CreateFromMailMessage() to not duplicate From/To/Cc/etc addresses\n  if the System.Net.Mail.MailMessage has been sent via System.Net.Mail.SmtpClient\n  prior to calling MimeMessage.CreateFromMailMessage(). (issue [#115](https://github.com/jstedfast/MimeKit/issues/115))\n* When parsing S/MIME digital signatures, don't import the full certificate chain.\n  (issue [#110](https://github.com/jstedfast/MimeKit/issues/110))\n* Added immutability-friendly .ctor to MimeMessage for use with languages such as F#.\n  (issue [#116](https://github.com/jstedfast/MimeKit/issues/116))\n\n## MimeKit 1.0.10 (2015-03-14)\n\n* Ignore semi-colons in Content-Transfer-Encoding headers to work around broken mailers.\n* Added ParserOptions.ParameterComplianceMode (defaults to RfcComoplianceMode.Loose)\n  which works around unquoted parameter values in Content-Type and Content-Disposition\n  headers. (issue [#106](https://github.com/jstedfast/MimeKit/issues/106))\n* Modified the MimeParser to handle whitespace between header field names and the ':'.\n* Probe to make sure that various System.Text.Encodings are available before adding\n  aliases for them (some may not be available depending on the platform).\n* Added a MimePart.GetBestEncoding() overload that takes a maxLineLength argument.\n* Modified MultipartSigned to use 78 characters as the max line length rather than 998\n  characters. (issue [#107](https://github.com/jstedfast/MimeKit/issues/107))\n\n## MimeKit 1.0.9 (2015-03-08)\n\n* Added a new MessageDispositionNotification MimePart subclass to represent\n  message/disposition-notification parts.\n* Fixed the TNEF parser to gracefully deal with duplicate attachment properties.\n\n## MimeKit 1.0.8 (2015-03-02)\n\n* Modified the parser to accept Message-Id values without a domain (i.e. \"<local-part@>\").\n* Fixed a NullReferenceException in MimeMessage.BodyParts in cases where a MessagePart\n  has a null Message.\n* Renamed DateUtils.TryParseDateTime() to DateUtils.TryParse() (the old API still exists\n  but has been marked [Obsolete]).\n* Renamed MimeUtils.TryParseVersion() to MimeUtils.TryParse() (the old API still exists\n  but has been marked [Obsolete]).\n* Fixed S/MIME support to gracefully deal with badly formatted signature timestamps\n  which incrorectly use leap seconds. (issue [#103](https://github.com/jstedfast/MimeKit/issues/103))\n\n## MimeKit 1.0.7 (2015-02-17)\n\n* Fixed TnefPropertyReader.GetEmbeddedMessageReader() to skip the Guid.\n* When decrypting PGP data, iterate over all encrypted packets to find one that\n  can be decrypted (i.e. the private key exists in the user's keychain).\n* Updated WindowsSecureMimeContext to respect SecureMailboxAddresses like the\n  other backends. (issue [#100](https://github.com/jstedfast/MimeKit/issues/100))\n* Added a Pkcs9SigningTime attribute to the CmsSigner for WindowsSecureMimeContext.\n  (issue [#101](https://github.com/jstedfast/MimeKit/issues/101))\n\n## MimeKit 1.0.6 (2015-01-18)\n\n* Vastly improved MS-TNEF support. In addition to being fixed to properly extract\n  the AttachData property of an Attachment attribute, more metadata is captured\n  and translated to the MIME equivalents (such as attachment creation and\n  modification times, the size of the attachment, and the display name).\n* Migrated the iOS assemblies to Xamarin.iOS Unified API for 64-bit support.\n\nNote: If you are not yet ready to port your iOS application to the Unified API,\n      you will need to stick with the 1.0.5 release. The Classic MonoTouch API\n      is no longer supported.\n\n## MimeKit 1.0.5 (2015-01-10)\n\n* Fixed out-of-memory error when encoding some long non-ASCII parameter values in\n  Content-Type and Content-Disposition headers.\n\n## MimeKit 1.0.4 (2015-01-08)\n\n* Added workaround for msg-id tokens with multiple domains\n  (e.g. id@domain1@domain2).\n* Added convenience methods to Header to allow the use of charset strings.\n* Added more HeaderList.Replace() method overloads for convenience.\n* Added a FormatOptions property to disallow the use of mixed charsets when\n  encoding headers (issue [#139](https://github.com/jstedfast/MimeKit/issues/139)).\n\n## MimeKit 1.0.3 (2014-12-13)\n\n* Improved MimeMessage.TextBody and MimeMessage.HtmlBody logic. (issue [#87](https://github.com/jstedfast/MimeKit/issues/87))\n* Added new overrides of TextPart.GetText() and SetText() methods that take a\n  charset string argument instead of a System.Text.Encoding.\n* Fixed charset fallback logic to work properly (it incorrectly assumed that\n  by default, Encoding.UTF8.GetString() would throw an exception when it\n  encountered illegal byte sequences). (issue [#88](https://github.com/jstedfast/MimeKit/issues/88))\n* Fixed S/MIME logic for finding X.509 certificates to use for encipherment.\n  (issue [#89](https://github.com/jstedfast/MimeKit/issues/89))\n\n## MimeKit 1.0.2 (2014-12-05)\n\n* Fixed MimeMessage.HtmlBody and MimeMessage.TextBody to properly\n  handle nested multipart/alternatives (only generated by automated\n  mailers).\n\n## MimeKit 1.0.1 (2014-11-23)\n\n* Added MimeMessage.HtmlBody and MimeMessage.TextBody convenience properties.\n* Added TextPart.IsPlain and TextPart.IsHtml convenience properties.\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 1.55078125,
          "content": "# Security Policy\n\nThe MimeKit team takes the security of our software products and services seriously.\n\nIf you believe you have found a security vulnerability in the MimeKit repository, please report it to us as described below.\n\n## Supported Versions\n\nDue to the fact that the MimeKit team is small (currently only myself), I can\nonly support security fixes for the latest version.\n\n| Version | Supported          |\n| ------- | ------------------ |\n| 4.x     | :white_check_mark: |\n| < 4.0   | :x:                |\n\n## Reporting a Vulnerability\n\n**Please do not report security vulnerabilities through public GitHub issues.**\n\nInstead, please report them via a [Private Security Advisory](https://github.com/jstedfast/MimeKit/security/advisories/new) submission.\n\nFor more information about the fields available and guidance on filling in the form, see\n\"[Creating a repository security advisory](https://docs.github.com/en/code-security/security-advisories/working-with-repository-security-advisories/creating-a-repository-security-advisory)\"\nand \"[Best practices for writing repository security advisories.](https://docs.github.com/en/code-security/security-advisories/guidance-on-reporting-and-writing-information-about-vulnerabilities/best-practices-for-writing-repository-security-advisories)\"\n\nYou should receive a response within 24 hours. If for some reason you do not, please follow up via [email](mailto:jestedfa@microsoft.com?subject=MimeKit%20Security%20Advisory) to ensure we received your original message.\n\n## Preferred Languages\n\nAll communications should be in English.\n"
        },
        {
          "name": "UnitTests",
          "type": "tree",
          "content": null
        },
        {
          "name": "cov-build.bat",
          "type": "blob",
          "size": 0.1669921875,
          "content": "..\\cov-analysis\\bin\\cov-build.exe --dir cov-int \"C:\\Program Files\\Microsoft Visual Studio\\2022\\Enterprise\\MSBuild\\Current\\Bin\\MSBuild.exe\" /t:Rebuild MimeKit.Coverity.sln\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "nuget",
          "type": "tree",
          "content": null
        },
        {
          "name": "rfc",
          "type": "tree",
          "content": null
        },
        {
          "name": "samples",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}