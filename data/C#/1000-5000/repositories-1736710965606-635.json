{
  "metadata": {
    "timestamp": 1736710965606,
    "page": 635,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Cinchoo/ChoEazyCopy",
      "stars": 1810,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 2.458984375,
          "content": "###############################################################################\n# Set default behavior to automatically normalize line endings.\n###############################################################################\n* text=auto\n\n###############################################################################\n# Set default behavior for command prompt diff.\n#\n# This is need for earlier builds of msysgit that does not have it on by\n# default for csharp files.\n# Note: This is only used by command line\n###############################################################################\n#*.cs     diff=csharp\n\n###############################################################################\n# Set the merge driver for project and solution files\n#\n# Merging from the command prompt will add diff markers to the files if there\n# are conflicts (Merging from VS is not affected by the settings below, in VS\n# the diff markers are never inserted). Diff markers may cause the following \n# file extensions to fail to load in VS. An alternative would be to treat\n# these files as binary and thus will always conflict and require user\n# intervention with every merge. To do so, just uncomment the entries below\n###############################################################################\n#*.sln       merge=binary\n#*.csproj    merge=binary\n#*.vbproj    merge=binary\n#*.vcxproj   merge=binary\n#*.vcproj    merge=binary\n#*.dbproj    merge=binary\n#*.fsproj    merge=binary\n#*.lsproj    merge=binary\n#*.wixproj   merge=binary\n#*.modelproj merge=binary\n#*.sqlproj   merge=binary\n#*.wwaproj   merge=binary\n\n###############################################################################\n# behavior for image files\n#\n# image files are treated as binary by default.\n###############################################################################\n#*.jpg   binary\n#*.png   binary\n#*.gif   binary\n\n###############################################################################\n# diff behavior for common document formats\n# \n# Convert binary document formats to text before diffing them. This feature\n# is only available from the command line. Turn it on by uncommenting the \n# entries below.\n###############################################################################\n#*.doc   diff=astextplain\n#*.DOC   diff=astextplain\n#*.docx  diff=astextplain\n#*.DOCX  diff=astextplain\n#*.dot   diff=astextplain\n#*.DOT   diff=astextplain\n#*.pdf   diff=astextplain\n#*.PDF   diff=astextplain\n#*.rtf   diff=astextplain\n#*.RTF   diff=astextplain\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.134765625,
          "content": "# git ignore file\nbin/*\nobj/*\nLib/Cinchoo.Core.pdb\n*.suo\n*.user\npackages/*\npublish/*\n/.vs/ChoEazyCopy/v15/Server/sqlite3\n/.vs/ChoEazyCopy\n"
        },
        {
          "name": "App.config",
          "type": "blob",
          "size": 4.0859375,
          "content": "<?xml version=\"1.0\"?>\n<configuration>\n\t<configSections>\n\t\t<section name=\"appFrxSettings\" type=\"Cinchoo.Core.ChoAppFrxSettings, Cinchoo.Core\"/>\n\t\t<sectionGroup name=\"userSettings\" type=\"System.Configuration.UserSettingsGroup, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\">\n\t\t\t<section name=\"ChoEazyCopy.Properties.Settings\" type=\"System.Configuration.ClientSettingsSection, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\" allowExeDefinition=\"MachineToLocalUser\" requirePermission=\"false\"/>\n\t\t</sectionGroup>\n\t</configSections>\n\t<appFrxSettings appEnvironment=\"\" appFrxFilePath=\"\" applicationHostType=\"\" disableAppConfig=\"true\" disableFrxConfig=\"true\" disableMetaDataConfig=\"true\"/>\n\t<system.diagnostics>\n\t\t<switches>\n\t\t\t<add name=\"ChoSwitch\" value=\"0\"/>\n\t\t</switches>\n\t</system.diagnostics>\n\t<startup>\n\t\t<supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.7.2\"/>\n\t</startup>\n\t<userSettings>\n\t\t<ChoEazyCopy.Properties.Settings>\n\t\t\t<setting name=\"WindowTop\" serializeAs=\"String\">\n\t\t\t\t<value>100</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"WindowLeft\" serializeAs=\"String\">\n\t\t\t\t<value>100</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"WindowHeight\" serializeAs=\"String\">\n\t\t\t\t<value>500</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"WindowWidth\" serializeAs=\"String\">\n\t\t\t\t<value>800</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"WindowState\" serializeAs=\"String\">\n\t\t\t\t<value>Normal</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"RememberWindowSizeAndPosition\" serializeAs=\"String\">\n\t\t\t\t<value>False</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"ScrollOutput\" serializeAs=\"String\">\n\t\t\t\t<value>False</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"BackupTaskDirectory\" serializeAs=\"String\">\n\t\t\t\t<value />\n\t\t\t</setting>\n\t\t\t<setting name=\"DateCreatedVisibility\" serializeAs=\"String\">\n\t\t\t\t<value>True</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"DateModifiedVisibility\" serializeAs=\"String\">\n\t\t\t\t<value>True</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"SizeColumnToFit\" serializeAs=\"String\">\n\t\t\t\t<value>True</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"KeepDateCreated\" serializeAs=\"String\">\n\t\t\t\t<value>True</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"KeepDateModified\" serializeAs=\"String\">\n\t\t\t\t<value>True</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"TaskNameColumnWidth\" serializeAs=\"String\">\n\t\t\t\t<value>NaN</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"DateCreatedColumnWidth\" serializeAs=\"String\">\n\t\t\t\t<value>NaN</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"DateModifiedColumnWidth\" serializeAs=\"String\">\n\t\t\t\t<value>NaN</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"SizeAllColumnsToFit\" serializeAs=\"String\">\n\t\t\t\t<value>False</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"ConfirmOnDelete\" serializeAs=\"String\">\n\t\t\t\t<value>True</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"BackupTaskTabActiveAtOpen\" serializeAs=\"String\">\n\t\t\t\t<value>False</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"ControlPanelMinimized\" serializeAs=\"String\">\n\t\t\t\t<value>False</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"ControlPanelWidth\" serializeAs=\"String\">\n\t\t\t\t<value>300</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"WatchForChanges\" serializeAs=\"String\">\n\t\t\t\t<value>True</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"TaskQNameColumnWidth\" serializeAs=\"String\">\n\t\t\t\t<value>NaN</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"TaskQStartTimeColumnWidth\" serializeAs=\"String\">\n\t\t\t\t<value>NaN</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"TaskQQueueTimeColumnWidth\" serializeAs=\"String\">\n\t\t\t\t<value>NaN</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"TaskQueueTabActiveAtOpen\" serializeAs=\"String\">\n\t\t\t\t<value>False</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"TaskQTaskItems\" serializeAs=\"String\">\n\t\t\t\t<value />\n\t\t\t</setting>\n\t\t\t<setting name=\"TaskQEndTimeColumnWidth\" serializeAs=\"String\">\n\t\t\t\t<value>NaN</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"TaskQStatusColumnWidth\" serializeAs=\"String\">\n\t\t\t\t<value>NaN</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"TaskQErrorMsgColumnWidth\" serializeAs=\"String\">\n\t\t\t\t<value>NaN</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"TaskQIdColumnWidth\" serializeAs=\"String\">\n\t\t\t\t<value>NaN</value>\n\t\t\t</setting>\n\t\t\t<setting name=\"UpdateSettings\" serializeAs=\"String\">\n\t\t\t\t<value>True</value>\n\t\t\t</setting>\n\t\t</ChoEazyCopy.Properties.Settings>\n\t</userSettings>\n</configuration>\n"
        },
        {
          "name": "App.ico",
          "type": "blob",
          "size": 97.341796875,
          "content": null
        },
        {
          "name": "App.xaml",
          "type": "blob",
          "size": 1.8740234375,
          "content": "﻿<Application x:Class=\"ChoEazyCopy.App\"\n             xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n            xmlns:mah=\"clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro\"\n            xmlns:local=\"clr-namespace:ChoEazyCopy\"\n             >\n    <Application.Resources>\n\n        <ResourceDictionary>\n            <ResourceDictionary.MergedDictionaries>\n                <ResourceDictionary Source=\"pack://application:,,,/MahApps.Metro;component/Styles/Controls.xaml\" />\n                <ResourceDictionary Source=\"pack://application:,,,/MahApps.Metro;component/Styles/Fonts.xaml\" />\n                <ResourceDictionary Source=\"pack://application:,,,/MahApps.Metro;component/Styles/Colors.xaml\" />\n                <ResourceDictionary Source=\"pack://application:,,,/MahApps.Metro;component/Styles/Accents/Blue.xaml\" />\n                <ResourceDictionary Source=\"pack://application:,,,/MahApps.Metro;component/Styles/Accents/BaseDark.xaml\" />\n                <ResourceDictionary Source=\"pack://application:,,,/MahApps.Metro;component/Styles/Accents/Steel.xaml\" />\n                <ResourceDictionary Source=\"pack://application:,,,/MahApps.Metro;component/Styles/Accents/BaseLight.xaml\" />\n            </ResourceDictionary.MergedDictionaries>\n            <Color x:Key=\"AccentColor\">#FF2C8742</Color>\n\n            <DataTemplate x:Key=\"NumericDropDownListEditor\">\n                <mah:NumericUpDown Minimum=\"0\" Interval=\"1\" Value=\"{Binding TextValue, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\" />\n            </DataTemplate>\n            <DataTemplate x:Key=\"TimePickerEditor\">\n                <local:ChoMaskedTextBox Text=\"{Binding TextValue, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\" InputMask=\"00:00:00\" />\n            </DataTemplate>\n        </ResourceDictionary>\n    </Application.Resources>\n</Application>\n"
        },
        {
          "name": "App.xaml.cs",
          "type": "blob",
          "size": 9.353515625,
          "content": "﻿using Cinchoo.Core;\nusing Cinchoo.Core.Diagnostics;\nusing Cinchoo.Core.Shell;\nusing Cinchoo.Core.Windows.Forms;\nusing System;\nusing System.Collections.Generic;\nusing System.Configuration;\nusing System.Data;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Windows;\nusing System.IO;\nusing System.Diagnostics;\nusing ChoEazyCopy.Properties;\nusing System.Reflection;\nusing System.Security.Principal;\nusing MahApps.Metro;\n\nnamespace ChoEazyCopy\n{\n    [ChoApplicationHost]\n    public class AppHost : ChoApplicationHost\n    {\n        public const string AppFileExt = \".ezy\";\n        private string _defaultBalloonTipText = null;\n\n        [STAThread]\n        public static void Main(string[] args)\n        {\n            // Copy user settings from previous application version if necessary\n            if (Settings.Default.UpdateSettings)\n            {\n                Settings.Default.Upgrade();\n                Settings.Default.Reload();\n                Settings.Default.UpdateSettings = false;\n                Settings.Default.Save();\n            }\n            ChoApplication.Run(args);\n        }\n        public override void OnTrayAppExitMenuClicked(object sender, EventArgs e)\n        {\n            ChoApplication.NotifyIcon.Dispose();\n            base.OnTrayAppExitMenuClicked(sender, e);\n        }\n\n        protected override void ApplyGlobalApplicationSettingsOverrides(ChoGlobalApplicationSettings obj)\n        {\n            obj.TrayApplicationBehaviourSettings.TurnOn = true;\n            obj.TrayApplicationBehaviourSettings.TurnOnMode = ChoTrayAppTurnOnMode.OnMinimize;\n            obj.TrayApplicationBehaviourSettings.HideTrayIconWhenMainWindowShown = false;\n            obj.TrayApplicationBehaviourSettings.ContextMenuSettings.DisplayHelpMenuItem = false;\n            obj.TrayApplicationBehaviourSettings.ContextMenuSettings.DisplayAboutMenuItem = false;\n            obj.TrayApplicationBehaviourSettings.ContextMenuSettings.DisplayShowMainWndMenuItem = true;\n            obj.TrayApplicationBehaviourSettings.ContextMenuSettings.DisplayShowInTaskbarMenuItem = false;\n\n            obj.ApplicationBehaviourSettings.SingleInstanceApp = false;\n            obj.ApplicationBehaviourSettings.ActivateFirstInstance = true;\n        }\n\n        protected override void OnWindowMinimize(ChoNotifyIcon notifyIcon)\n        {\n            ChoApplication.NotifyIcon.ShowBalloonTip(_defaultBalloonTipText, 500);\n        }\n\n        protected override void OnStart(string[] args)\n        {\n            _defaultBalloonTipText = \"{0} is running...\".FormatString(ChoGlobalApplicationSettings.Me.ApplicationName);\n\n            UnregisterShellExtensions();\n\n            if (ChoApplication.ApplicationMode == ChoApplicationMode.Console)\n            {\n                ChoAppCmdLineArgs cmdLineArgs = new ChoAppCmdLineArgs();\n                cmdLineArgs.StartFileCopy();\n            }\n            \n            base.OnStart(args);\n        }\n\n        public static void RegisterShellExtensions()\n        {\n            try\n            {\n                ChoShellExtension.Register();\n                ChoTrace.WriteLine(\"Shell Extensions registered successfully.\");\n            }\n            catch (Exception ex)\n            {\n                ChoTrace.WriteLine(\"Failed to register Shell Extensions. {0}\".FormatString(ex.Message));\n            }\n            try\n            {\n                ChoShellFileAssociation.Register();\n                ChoTrace.WriteLine(\"File Associations registered successfully.\");\n            }\n            catch (Exception ex)\n            {\n                ChoTrace.WriteLine(\"Failed to register File Associations. {0}\".FormatString(ex.Message));\n            }\n        }\n\n        public static void UnregisterShellExtensions()\n        {\n            try\n            {\n                ChoShellExtension.Unregister();\n                ChoTrace.WriteLine(\"Shell Extensions unregistered successfully.\");\n            }\n            catch (Exception ex)\n            {\n                ChoTrace.WriteLine(\"Failed to unregister Shell Extensions. {0}\".FormatString(ex.Message));\n            }\n            try\n            {\n                ChoShellFileAssociation.Unregister();\n                ChoTrace.WriteLine(\"File Associations unregistered successfully.\");\n            }\n            catch (Exception ex)\n            {\n                ChoTrace.WriteLine(\"Failed to unregister File Associations. {0}\".FormatString(ex.Message));\n            }\n        }\n\n        public static void RunAsAdmin()\n        {\n            if (!IsRunAsAdmin())\n            {\n                ProcessStartInfo proc = new ProcessStartInfo();\n                proc.UseShellExecute = true;\n                proc.WorkingDirectory = Environment.CurrentDirectory;\n                proc.FileName = Assembly.GetEntryAssembly().CodeBase;\n\n                foreach (string arg in Environment.GetCommandLineArgs())\n                {\n                    proc.Arguments += String.Format(\"\\\"{0}\\\" \", arg);\n                }\n\n                proc.Verb = \"runas\";\n\n                try\n                {\n                    Process.Start(proc);\n                    Environment.Exit(0);\n                }\n                catch (Exception ex)\n                {\n                    ChoTrace.WriteLine(\"This application requires elevated credentials in order to operate correctly! {0}\".FormatString(ex.Message));\n                }\n            }\n        }\n\n        internal static bool IsRunAsAdmin()\n        {\n            WindowsIdentity id = WindowsIdentity.GetCurrent();\n            WindowsPrincipal principal = new WindowsPrincipal(id);\n\n            return principal.IsInRole(WindowsBuiltInRole.Administrator);\n        }\n\n        public override object MainWindowObject\n        {\n            get\n            {\n                ChoFileAssociationCmdLineArgs cmd = new ChoFileAssociationCmdLineArgs();\n                if (cmd.IsAppFile)\n                    return new MainWindow(cmd.SettingsFilePath);\n                else\n                    return new MainWindow();\n            }\n        }\n\n        public override object ApplicationObject\n        {\n            get\n            {\n                if (Application.Current == null)\n                    new App();\n                //ThemeManager.ChangeAppStyle(Application.Current,\n                //                            ThemeManager.GetAccent(\"Blue\"),\n                //                            ThemeManager.GetAppTheme(\"BaseDark\"));\n                //ThemeManager.ChangeAppStyle(Application.Current,\n                //                            ThemeManager.GetAccent(\"Steel\"),\n                //                            ThemeManager.GetAppTheme(\"BaseLight\"));\n\n                Application.Current.Exit += (o, e) => ChoApplication.NotifyIcon.Dispose();\n                return Application.Current;\n            }\n        }\n\n        protected override void AfterNotifyIconConstructed(ChoNotifyIcon ni)\n        {\n            ni.Text = \"ChoEazyCopy - Cinchoo\";\n\n            ni.ContextMenuStrip.Items.Insert(1, new System.Windows.Forms.ToolStripMenuItem(\"Launch New Instance\",\n                System.Drawing.Image.FromStream(this.GetType().Assembly.GetManifestResourceStream(\"ChoEazyCopy.Resources.OpenNewWindow.png\")),\n                ((o, e) =>\n                {\n                    var info = new System.Diagnostics.ProcessStartInfo(ChoApplication.EntryAssemblyLocation);\n                    System.Diagnostics.Process.Start(info);\n                })));\n            if (!IsRunAsAdmin())\n            {\n                ni.ContextMenuStrip.Items.Insert(2, new System.Windows.Forms.ToolStripMenuItem(\"Run as Administrator\",\n                  System.Drawing.Image.FromStream(this.GetType().Assembly.GetManifestResourceStream(\"ChoEazyCopy.Resources.Security.png\")),\n                    ((o, e) =>\n                    {\n                        AppHost.RunAsAdmin();\n                    })));\n            }\n            else\n            {\n                ni.ContextMenuStrip.Items.Insert(2, new System.Windows.Forms.ToolStripMenuItem(\"Register Shell Extensions\",\n                  System.Drawing.Image.FromStream(this.GetType().Assembly.GetManifestResourceStream(\"ChoEazyCopy.Resources.Registry.png\")),\n                  ((o, e) =>\n                  {\n                      AppHost.RegisterShellExtensions();\n                  })));\n                ni.ContextMenuStrip.Items.Insert(3, new System.Windows.Forms.ToolStripMenuItem(\"Unregister Shell Extensions\",\n                  System.Drawing.Image.FromStream(this.GetType().Assembly.GetManifestResourceStream(\"ChoEazyCopy.Resources.RemoveRegistry.png\")),\n                   ((o, e) =>\n                   {\n                       AppHost.UnregisterShellExtensions();\n                   })));\n\n            }\n        }\n\n        public void ShowMainWindow()\n        {\n            var a = ApplicationObject;\n            var wnd = MainWindowObject;\n            if (wnd is Window)\n            {\n                ChoWindowsManager.HideConsoleWindow();\n                ((Window)wnd).ShowDialog();\n            }\n        }\n    }\n\n    [ChoShellExtension]\n    public class ShellExt\n    {\n        [ChoShellExtensionContextMenu(\"Folder\", MenuText = \"Open with ChoEazyCopy...\", DefaultArgPrefix = \"/d:\")]\n        public static void EazyCopyFiles(string[] args)\n        {\n            new AppHost().ShowMainWindow();\n        }\n    }\n\n    /// <summary>\n    /// Interaction logic for App.xaml\n    /// </summary>\n    public partial class App : Application\n    {\n        public App()\n        {\n            InitializeComponent();\n        }\n    }\n}\n"
        },
        {
          "name": "ChoAppCmdLineArgs.cs",
          "type": "blob",
          "size": 3.7275390625,
          "content": "﻿using Cinchoo.Core;\nusing Cinchoo.Core.Diagnostics;\nusing Cinchoo.Core.IO;\nusing Cinchoo.Core.Shell;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\n\nnamespace ChoEazyCopy\n{\n    [ChoCommandLineArgObject(DisplayDefaultValue = true, UsageSwitch = \"_\")]\n    public class ChoShellExtCmdLineArgs : ChoCommandLineArgObject\n    {\n        [ChoCommandLineArg(\"d\", Description = \"Source directory.\", Order = -2)]\n        public string Directory\n        {\n            get;\n            set;\n        }\n    }\n\n    [ChoCommandLineArgObject(DisplayDefaultValue = true, UsageSwitch = \"_\")]\n    public class ChoFileAssociationCmdLineArgs : ChoCommandLineArgObject\n    {\n        [ChoPositionalCommandLineArg(1, \"SettingsFilePath\", Description = \"Settings file path.\")]\n        public string SettingsFilePath\n        {\n            get;\n            set;\n        }\n\n        public bool IsAppFile;\n\n        protected override void OnAfterCommandLineArgObjectLoaded(string[] commandLineArgs)\n        {\n            if (!SettingsFilePath.IsNullOrWhiteSpace())\n            {\n                IsAppFile = Path.GetExtension(SettingsFilePath) == AppHost.AppFileExt;\n            }\n        }\n    }\n\n    [ChoCommandLineArgObject(DisplayDefaultValue=true)]\n    public class ChoAppCmdLineArgs : ChoCommandLineArgObject\n    {\n        [ChoPositionalCommandLineArg(1, \"SettingsFilePath\", Description = \"Settings file path.\", IsRequired = true)]\n        public string SettingsFilePath\n        {\n            get;\n            set;\n        }\n\n        [ChoCommandLineArg(\"s\", Description = \"Source directory.\", Order = 2, NoOfTabsSwitchDescFormatSeparator=3)]\n        public string SourceDirectory\n        {\n            get;\n            set;\n        }\n\n        [ChoCommandLineArg(\"d\", Description = \"Destination directory.\", Order = 3, NoOfTabsSwitchDescFormatSeparator = 3)]\n        public string DestDirectory\n        {\n            get;\n            set;\n        }\n\n        protected override void OnAfterCommandLineArgObjectLoaded(string[] commandLineArgs)\n        {\n            if (!SettingsFilePath.IsNullOrWhiteSpace())\n            {\n                SettingsFilePath = ChoPath.GetFullPath(SettingsFilePath);\n            }\n        }\n\n        public void StartFileCopy(string sourceDirectory = null, string destDirectory = null)\n        {\n            try\n            {\n                ChoAppSettings appSettings = new ChoAppSettings();\n                if (!SettingsFilePath.IsNullOrWhiteSpace())\n                {\n                    if (!File.Exists(SettingsFilePath))\n                        throw new ArgumentException(\"Can't find '{0}' settings file.\".FormatString(SettingsFilePath));\n\n                    appSettings.LoadXml(File.ReadAllText(SettingsFilePath));\n                }\n\n                ChoConsole.WriteLine();\n\n                ChoRoboCopyManager _roboCopyManager = new ChoRoboCopyManager(SettingsFilePath);\n                _roboCopyManager.Status += (sender, e) =>\n                {\n                    ChoTrace.Write(e.Message);\n                    ChoConsole.Write(e.Message, ConsoleColor.Yellow);\n                };\n                _roboCopyManager.AppStatus += (sender, e) =>\n                {\n                    ChoTrace.Write(e.Message);\n                    ChoConsole.Write(e.Message, ConsoleColor.Yellow);\n                };\n\n                _roboCopyManager.Process(appSettings, true);\n            }\n            catch (ThreadAbortException)\n            {\n                Console.WriteLine(\"RoboCopy operation cancelled by user.\");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(\"RoboCopy operation failed.\" + Environment.NewLine + ChoApplicationException.ToString(ex));\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "ChoAppSettings.cs",
          "type": "blob",
          "size": 82.4677734375,
          "content": "﻿namespace ChoEazyCopy\n{\n    #region NameSpaces\n\n    using System;\n    using System.Text;\n    using System.Collections.Generic;\n    using Cinchoo.Core.Configuration;\n    using System.ComponentModel;\n    using System.Runtime.Remoting.Contexts;\n    using System.Dynamic;\n    using Cinchoo.Core.Text.RegularExpressions;\n    using System.Text.RegularExpressions;\n    using Cinchoo.Core.Diagnostics;\n    using Cinchoo.Core;\n    using System.Diagnostics;\n    using Cinchoo.Core.Xml.Serialization;\n    using Cinchoo.Core.IO;\n    using System.IO;\n    using System.Xml.Serialization;\n    using System.Windows;\n    using Cinchoo.Core.WPF;\n    using System.Windows.Data;\n    using System.Linq;\n    using System.Collections.ObjectModel;\n    using System.Windows.Controls;\n    using System.Windows.Threading;\n    using System.Runtime.CompilerServices;\n    using System.Reflection;\n    using SoftFluent.Windows;\n\n    #endregion NameSpaces\n\n    [Flags]\n    public enum ChoCopyFileFlags\n    {\n        [Description(\"\")]\n        None = 0,\n        [Description(\"D\")]\n        Data = 1,\n        [Description(\"A\")]\n        Attributes = 2,\n        [Description(\"T\")]\n        Timestamps = 4,\n        [Description(\"S\")]\n        SecurityNTFSACLs = 8,\n        [Description(\"O\")]\n        OwnerInfo = 16,\n        [Description(\"U\")]\n        AuditingInfo = 32\n    }\n\n    [Flags]\n    public enum ChoCopyDirFlags\n    {\n        [Description(\"\")]\n        None = 0,\n        [Description(\"D\")]\n        Data = 1,\n        [Description(\"A\")]\n        Attributes = 2,\n        [Description(\"T\")]\n        Timestamps = 4,\n        [Description(\"E\")]\n        ExtendedAttributes = 8,\n        [Description(\"X\")]\n        SkipAlternativeDataStreams = 16,\n    }\n\n    [Flags]\n    public enum ChoFileAttributes\n    {\n        [Description(\"\")]\n        None = 0,\n        [Description(\"R\")]\n        ReadOnly = 1,\n        [Description(\"H\")]\n        Hidden = 2,\n        [Description(\"A\")]\n        Archive = 4,\n        [Description(\"S\")]\n        System = 8,\n        [Description(\"C\")]\n        Compressed = 16,\n        [Description(\"N\")]\n        NotContentIndexed = 32,\n        [Description(\"E\")]\n        Encrypted = 64,\n        [Description(\"T\")]\n        Temporary = 128\n    }\n\n    [Flags]\n    public enum ChoFileSelectionAttributes\n    {\n        None = 0,\n        [Description(\"R\")]\n        ReadOnly = 1,\n        [Description(\"A\")]\n        Archive = 2,\n        [Description(\"S\")]\n        System = 4,\n        [Description(\"H\")]\n        Hidden = 8,\n        [Description(\"C\")]\n        Compressed = 16,\n        [Description(\"N\")]\n        NotContentIndexed = 32,\n        [Description(\"E\")]\n        Encrypted = 64,\n        [Description(\"T\")]\n        Temporary = 128,\n        [Description(\"O\")]\n        Offline = 256\n    }\n\n    public enum ChoFileMoveAttributes\n    {\n        None,\n        MoveFilesOnly,\n        MoveDirectoriesAndFiles,\n    }\n    public abstract class ChoViewModelBase : INotifyPropertyChanged\n    {\n        public event PropertyChangedEventHandler PropertyChanged;\n\n        protected virtual void NotifyPropertyChanged([CallerMemberName] string name = null)\n        {\n            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));\n        }\n    }\n\n    [ChoNameValueConfigurationSection(\"applicationSettings\" /*, BindingMode = ChoConfigurationBindingMode.OneWayToSource */, Silent = false)]\n    public class ChoAppSettings : ChoViewModelBase, ICloneable<ChoAppSettings> //: ChoConfigurableObject\n    {\n        private readonly static XmlSerializer _xmlSerializer = new XmlSerializer(typeof(ChoAppSettings));\n        private readonly static Dictionary<string, PropertyInfo> _propInfos = new Dictionary<string, PropertyInfo>();\n        private readonly static Dictionary<PropertyInfo, object> _defaultValues = new Dictionary<PropertyInfo, object>();\n        private readonly static ChoAppSettings DefaultInstance = new ChoAppSettings();\n\n        #region Constructors\n\n        static ChoAppSettings()\n        {\n            ChoPropertyInfoAttribute attr = null;\n            foreach (var pi in ChoType.GetProperties(typeof(ChoAppSettings)))\n            {\n                attr = pi.GetCustomAttributes(false).OfType<ChoPropertyInfoAttribute>().FirstOrDefault();\n                if (attr != null)\n                {\n                    _propInfos.Add(pi.Name, pi);\n                    _defaultValues.Add(pi, attr.DefaultValue);\n                }\n            }\n\n            ChoObject.ResetObject(DefaultInstance);\n        }\n\n        public ChoAppSettings()\n        {\n        }\n\n        #endregion Constructors\n\n        #region Instance Data Members (Others)\n\n        private bool _showRoboCopyProgress;\n        [Browsable(false)]\n        [ChoPropertyInfo(\"ShowRoboCopyProgress\")]\n        //[XmlIgnore]\n        public bool ShowRoboCopyProgress\n        {\n            get { return _showRoboCopyProgress; }\n            set\n            {\n                if (value)\n                {\n                    //CopySubDirectories = false;\n                    //CopyFlags = String.Empty;\n\n                    //MirrorDirTree = true; //MIR = Mirror mode\n                    NoProgress = true; //NP  = Don't show progress percentage in log\n                    NoDirListLog = true; // NDL - No directory list log\n                    NoFileClassLog = true; //NC  = Don't log file classes (existing, new file, etc.)\n                    PrintByteSizes = true; //BYTES = Show file sizes in bytes\n                    NoJobHeader = true; //NJH = Do not display robocopy job header (JH)\n                    NoJobSummary = true; //NJS = Do not display robocopy job summary (JS)\n                }\n\n                _showRoboCopyProgress = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        private bool _showOutputLineNumbers;\n        [Browsable(false)]\n        [ChoPropertyInfo(\"showOutputLineNumbers\")]\n        public bool ShowOutputLineNumbers\n        {\n            get { return _showOutputLineNumbers; }\n            set\n            {\n                _showOutputLineNumbers = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        private int _maxStatusMsgSize;\n        [Browsable(false)]\n        [ChoPropertyInfo(\"maxStatusMsgSize\", DefaultValue = \"1000\")]\n        public int MaxStatusMsgSize\n        {\n            get { return _maxStatusMsgSize; }\n            set\n            {\n                if (value > 0)\n                {\n                    _maxStatusMsgSize = value;\n                    NotifyPropertyChanged();\n                }\n            }\n        }\n\n        string _sourceDirectory;\n        [Browsable(false)]\n        [ChoPropertyInfo(\"sourceDirectory\")]\n        public string SourceDirectory\n        {\n            get { return _sourceDirectory; }\n            set\n            {\n                _sourceDirectory = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        string _destDirectory;\n        [Browsable(false)]\n        [ChoPropertyInfo(\"destDirectory\")]\n        public string DestDirectory\n        {\n            get { return _destDirectory; }\n            set\n            {\n                _destDirectory = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        #endregion Instance Data Members (Others)\n\n        #region Instance Data Members (Common Options)\n\n        string _roboCopyFilePath;\n        [Category(\"1. Common Options\")]\n        [Description(\"RoboCopy file path.\")]\n        [DisplayName(\"RoboCopyFilePath\")]\n        [ChoPropertyInfo(\"roboCopyFilePath\", DefaultValue = \"RoboCopy.exe\")]\n        public string RoboCopyFilePath\n        {\n            get { return _roboCopyFilePath; }\n            set\n            {\n                _roboCopyFilePath = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        string _files;\n        [Category(\"1. Common Options\")]\n        [Description(\"File(s) to copy (names/wildcards: default is \\\"*.*\\\").\")]\n        [DisplayName(\"Files\")]\n        [ChoPropertyInfo(\"files\", DefaultValue = \"*.*\")]\n        public string Files\n        {\n            get { return _files; }\n            set\n            {\n                _files = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        string _additionalParams;\n        [Category(\"1. Common Options\")]\n        [Description(\"Additional command line parameters (Optional).\")]\n        [DisplayName(\"AdditionalParams\")]\n        [ChoPropertyInfo(\"additionalParams\", DefaultValue = \"\")]\n        [PropertyGridOptions(EditorDataTemplateResourceKey = \"BigTextEditor\")]\n        public string AdditionalParams\n        {\n            get { return _additionalParams; }\n            set\n            {\n                _additionalParams = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        string _precommands;\n        [Category(\"1. Common Options\")]\n        [Description(\"Specify MS-DOS commands to run before robocopy operations, separated by ; (Optional).\")]\n        [DisplayName(\"PreCommands\")]\n        [ChoPropertyInfo(\"precommands\", DefaultValue = \"\")]\n        //[Editor(typeof(ChoMultilineTextBoxEditor), typeof(ChoMultilineTextBoxEditor))]\n        [PropertyGridOptions(EditorDataTemplateResourceKey = \"BigTextEditor\")]\n        public string Precommands\n        {\n            get { return _precommands; }\n            set\n            {\n                _precommands = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        string _postcommands;\n        [Category(\"1. Common Options\")]\n        [Description(\"Specify MS-DOS commands to run after robocopy operations, separated by ; (Optional).\")]\n        [DisplayName(\"Postcommands\")]\n        [ChoPropertyInfo(\"postcommands\", DefaultValue = \"\")]\n        //[Editor(typeof(ChoMultilineTextBoxEditor), typeof(ChoMultilineTextBoxEditor))]\n        [PropertyGridOptions(EditorDataTemplateResourceKey = \"BigTextEditor\")]\n        public string Postcommands\n        {\n            get { return _postcommands; }\n            set\n            {\n                _postcommands = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        string _comments;\n        [Category(\"1. Common Options\")]\n        [Description(\"Short description of backup task.\")]\n        [DisplayName(\"Comments\")]\n        [ChoPropertyInfo(\"comments\", DefaultValue = \"\")]\n        [PropertyGridOptions(EditorDataTemplateResourceKey = \"BigTextEditor\")]\n        public string Comments\n        {\n            get { return _comments; }\n            set\n            {\n                _comments = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        #endregion Instance Data Members (Common Options)\n\n        #region Instance Data Members (Source Options)\n\n        bool _copyNoEmptySubDirectories;\n        [Category(\"2. Source Options\")]\n        [Description(\"Copy subdirectories, but not empty ones. (/S).\")]\n        [DisplayName(\"CopyNoEmptySubDirectories\")]\n        [ChoPropertyInfo(\"copyNoEmptySubDirectories\")]\n        public bool CopyNoEmptySubDirectories\n        {\n            get { return _copyNoEmptySubDirectories; }\n            set\n            {\n                _copyNoEmptySubDirectories = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _copySubDirectories;\n        [Category(\"2. Source Options\")]\n        [Description(\"Copy subdirectories, including Empty ones. (/E).\")]\n        [DisplayName(\"CopySubDirectories\")]\n        [ChoPropertyInfo(\"copySubDirectories\", DefaultValue = \"true\")]\n        public bool CopySubDirectories\n        {\n            get { return _copySubDirectories; }\n            set\n            {\n                _copySubDirectories = value;\n                if (!value) ShowRoboCopyProgress = false;\n                NotifyPropertyChanged();\n            }\n        }\n\n        ChoCopyFileFlags _copyFileFlags;\n        [Category(\"2. Source Options\")]\n        [Description(\"What to copy for files (default is /COPY:DAT). (copyflags : D=Data, A=Attributes, T=Timestamps, S=Security=NTFS ACLs, O=Owner info, U=aUditing info). (/COPY:flags).\")]\n        [DisplayName(\"CopyFlags\")]\n        [ChoPropertyInfo(\"copyFlags\", DefaultValue = \"Data,Attributes,Timestamps\")]\n        //[Editor(typeof(CopyFlagsEditor), typeof(CopyFlagsEditor))]\n        [XmlIgnore]\n        public ChoCopyFileFlags CopyFileFlags\n        {\n            get { return _copyFileFlags; }\n            set\n            {\n                _copyFileFlags = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        [Browsable(false)]\n        [XmlElement(\"CopyFileFlags\")]\n        public string CopyFileFlagsElement\n        {\n            get { return CopyFileFlags.ToString(); }\n            set\n            {\n                if (value != null)\n                {\n                    if (!value.Contains(\",\"))\n                    value = value.Replace(\" \", \",\").Trim();\n                }\n\n                ChoCopyFileFlags copyFlags;\n                if (Enum.TryParse<ChoCopyFileFlags>(value, out copyFlags))\n                    _copyFileFlags = copyFlags;\n            }\n        }\n\n        bool _copyFilesWithSecurity;\n        [Category(\"2. Source Options\")]\n        [Description(\"Copy files with security (equivalent to /COPY:DATS). (/SEC).\")]\n        [DisplayName(\"CopyFilesWithSecurity\")]\n        [ChoPropertyInfo(\"copyFilesWithSecurity\")]\n        public bool CopyFilesWithSecurity\n        {\n            get { return _copyFilesWithSecurity; }\n            set\n            {\n                _copyFilesWithSecurity = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        //bool _copyDirTimestamp;\n        //[Category(\"2. Source Options\")]\n        //[Description(\"Copy Directory Timestamps. (/DCOPY:T).\")]\n        //[DisplayName(\"CopyDirTimestamp\")]\n        //[ChoPropertyInfo(\"copyDirTimestamp\")]\n        //public bool CopyDirTimestamp\n        //{\n        //    get { return _copyDirTimestamp; }\n        //    set\n        //    {\n        //        _copyDirTimestamp = value;\n        //        NotifyPropertyChanged();\n        //    }\n        //}\n\n\n        ChoCopyDirFlags _copyDirFlags;\n        [Category(\"2. Source Options\")]\n        [Description(\"What to copy in directories (default is /DCOPY:DA). (copyflags : D=Data, A=Attributes, T=Timestamps, X=Skip alt data streams). (/DCOPY:flags).\")]\n        [DisplayName(\"CopyDirFlags\")]\n        [ChoPropertyInfo(\"copyDirFlags\", DefaultValue = \"Data,Attributes\")]\n        //[Editor(typeof(CopyFlagsEditor), typeof(CopyFlagsEditor))]\n        [XmlIgnore]\n        public ChoCopyDirFlags CopyDirFlags\n        {\n            get { return _copyDirFlags; }\n            set\n            {\n                _copyDirFlags = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        [Browsable(false)]\n        [XmlElement(\"CopyDirFlags\")]\n        public string CopyDirFlagsElement\n        {\n            get { return CopyDirFlags.ToString(); }\n            set\n            {\n                if (value != null)\n                {\n                    if (!value.Contains(\",\"))\n                        value = value.Replace(\" \", \",\").Trim();\n                }\n\n                ChoCopyDirFlags copyDirFlags;\n                if (Enum.TryParse<ChoCopyDirFlags>(value, out copyDirFlags))\n                    _copyDirFlags = copyDirFlags;\n            }\n        }\n\n\n        bool _copyFilesWithFileInfo;\n        [Category(\"2. Source Options\")]\n        [Description(\"Copy all file info (equivalent to /COPY:DATSOU). (/COPYALL).\")]\n        [DisplayName(\"CopyFilesWithFileInfo\")]\n        [ChoPropertyInfo(\"copyFilesWithFileInfo\")]\n        public bool CopyFilesWithFileInfo\n        {\n            get { return _copyFilesWithFileInfo; }\n            set\n            {\n                _copyFilesWithFileInfo = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _copyFilesWithNoFileInfo;\n        [Category(\"2. Source Options\")]\n        [Description(\"Copy no file info (useful with /PURGE). (/NOCOPY).\")]\n        [DisplayName(\"CopyFilesWithNoFileInfo\")]\n        [ChoPropertyInfo(\"copyFilesWithNoFileInfo\")]\n        public bool CopyFilesWithNoFileInfo\n        {\n            get { return _copyFilesWithNoFileInfo; }\n            set\n            {\n                _copyFilesWithNoFileInfo = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _copyOnlyFilesWithArchiveAttributes;\n        [Category(\"2. Source Options\")]\n        [Description(\"Copy only files with the Archive attribute set. (/A).\")]\n        [DisplayName(\"CopyOnlyFilesWithArchiveAttributes\")]\n        [ChoPropertyInfo(\"copyOnlyFilesWithArchiveAttributes\")]\n        public bool CopyOnlyFilesWithArchiveAttributes\n        {\n            get { return _copyOnlyFilesWithArchiveAttributes; }\n            set\n            {\n                _copyOnlyFilesWithArchiveAttributes = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _copyOnlyFilesWithArchiveAttributesAndReset;\n        [Category(\"2. Source Options\")]\n        [Description(\"Copy only files with the Archive attribute and reset it. (/M).\")]\n        [DisplayName(\"CopyOnlyFilesWithArchiveAttributesAndReset\")]\n        [ChoPropertyInfo(\"copyOnlyFilesWithArchiveAttributesAndReset\")]\n        public bool CopyOnlyFilesWithArchiveAttributesAndReset\n        {\n            get { return _copyOnlyFilesWithArchiveAttributesAndReset; }\n            set\n            {\n                _copyOnlyFilesWithArchiveAttributesAndReset = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        uint _onlyCopyNLevels;\n        [Category(\"2. Source Options\")]\n        [Description(\"Only copy the top n levels of the source directory tree. 0 - all levels. (/LEV:n).\")]\n        [DisplayName(\"OnlyCopyNLevels\")]\n        [ChoPropertyInfo(\"onlyCopyNLevels\")]\n        [PropertyGridOptions(EditorDataTemplateResourceKey = \"NumericDropDownListEditor\")]\n        public uint OnlyCopyNLevels\n        {\n            get { return _onlyCopyNLevels; }\n            set\n            {\n                _onlyCopyNLevels = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        uint _excludeFilesOlderThanNDays;\n        [Category(\"2. Source Options\")]\n        [Description(\"MAXimum file AGE - exclude files older than n days/date. (/MAXAGE:n).\")]\n        [DisplayName(\"ExcludeFilesOlderThanNDays\")]\n        [ChoPropertyInfo(\"excludeFilesOlderThanNDays\")]\n        [PropertyGridOptions(EditorDataTemplateResourceKey = \"NumericDropDownListEditor\")]\n        public uint ExcludeFilesOlderThanNDays\n        {\n            get { return _excludeFilesOlderThanNDays; }\n            set\n            {\n                _excludeFilesOlderThanNDays = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        uint _excludeFilesNewerThanNDays;\n        [Category(\"2. Source Options\")]\n        [Description(\"MINimum file AGE - exclude files newer than n days/date. (/MINAGE:n).\")]\n        [DisplayName(\"ExcludeFilesNewerThanNDays\")]\n        [ChoPropertyInfo(\"excludeFilesNewerThanNDays\")]\n        [PropertyGridOptions(EditorDataTemplateResourceKey = \"NumericDropDownListEditor\")]\n        public uint ExcludeFilesNewerThanNDays\n        {\n            get { return _excludeFilesNewerThanNDays; }\n            set\n            {\n                _excludeFilesNewerThanNDays = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _assumeFATFileTimes;\n        [Category(\"2. Source Options\")]\n        [Description(\"assume FAT File Times (2-second granularity). (/FFT).\")]\n        [DisplayName(\"AssumeFATFileTimes\")]\n        [ChoPropertyInfo(\"assumeFATFileTimes\")]\n        public bool AssumeFATFileTimes\n        {\n            get { return _assumeFATFileTimes; }\n            set\n            {\n                _assumeFATFileTimes = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _turnOffLongPath;\n        [Category(\"2. Source Options\")]\n        [Description(\"Turn off very long path (> 256 characters) support. (/256).\")]\n        [DisplayName(\"TurnOffLongPath\")]\n        [ChoPropertyInfo(\"turnOffLongPath\")]\n        public bool TurnOffLongPath\n        {\n            get { return _turnOffLongPath; }\n            set\n            {\n                _turnOffLongPath = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        #endregion Instance Data Members (Source Options)\n\n        #region Instance Data Members (Destination Options)\n\n        ChoFileAttributes _addFileAttributes;\n        [Category(\"3. Destination Options\")]\n        [Description(\"Add the given attributes to copied files. (/A+:[RASHCNET]).\")]\n        [DisplayName(\"AddFileAttributes\")]\n        [ChoPropertyInfo(\"addFileAttributes\", DefaultValue = \"\")]\n        //[Editor(typeof(FileAttributesEditor), typeof(FileAttributesEditor))]\n        [XmlIgnore]\n        public ChoFileAttributes AddFileAttributes\n        {\n            get { return _addFileAttributes; }\n            set\n            {\n                _addFileAttributes = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n\n        [Browsable(false)]\n        [XmlElement(\"AddFileAttributes\")]\n        public string AddFileAttributesElement\n        {\n            get { return AddFileAttributes.ToString(); }\n            set\n            {\n                if (value != null)\n                {\n                    if (!value.Contains(\",\"))\n                        value = value.Replace(\" \", \",\").Trim();\n                }\n\n                ChoFileAttributes addFileAttributes;\n                if (Enum.TryParse<ChoFileAttributes>(value, out addFileAttributes))\n                    _addFileAttributes = addFileAttributes;\n            }\n        }\n\n        ChoFileAttributes _removeFileAttributes;\n        [Category(\"3. Destination Options\")]\n        [Description(\"Remove the given Attributes from copied files. (/A-:[RASHCNET]).\")]\n        [DisplayName(\"RemoveFileAttributes\")]\n        [ChoPropertyInfo(\"removeFileAttributes\", DefaultValue = \"\")]\n        //[Editor(typeof(FileAttributesEditor), typeof(FileAttributesEditor))]\n        [XmlIgnore]\n        public ChoFileAttributes RemoveFileAttributes\n        {\n            get { return _removeFileAttributes; }\n            set\n            {\n                _removeFileAttributes = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        [Browsable(false)]\n        [XmlElement(\"RemoveFileAttributes\")]\n        public string RemoveFileAttributesElement\n        {\n            get { return RemoveFileAttributes.ToString(); }\n            set\n            {\n                if (value != null)\n                {\n                    if (!value.Contains(\",\"))\n                        value = value.Replace(\" \", \",\").Trim();\n                }\n\n                ChoFileAttributes removeFileAttributes;\n                if (Enum.TryParse<ChoFileAttributes>(value, out removeFileAttributes))\n                    _removeFileAttributes = removeFileAttributes;\n            }\n        }\n\n        bool _createFATFileNames;\n        [Category(\"3. Destination Options\")]\n        [Description(\"Create destination files using 8.3 FAT file names only. (/FAT).\")]\n        [DisplayName(\"CreateFATFileNames\")]\n        [ChoPropertyInfo(\"createFATFileNames\")]\n        public bool CreateFATFileNames\n        {\n            get { return _createFATFileNames; }\n            set\n            {\n                _createFATFileNames = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _createDirTree;\n        [Category(\"3. Destination Options\")]\n        [Description(\"Create directory tree and zero-length files only. (/CREATE).\")]\n        [DisplayName(\"CreateDirTree\")]\n        [ChoPropertyInfo(\"createDirTree\")]\n        public bool CreateDirTree\n        {\n            get { return _createDirTree; }\n            set\n            {\n                _createDirTree = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _compensateOneHourDSTTimeDiff;\n        [Category(\"3. Destination Options\")]\n        [Description(\"Compensate for one-hour DST time differences. (/DST).\")]\n        [DisplayName(\"CompensateOneHourDSTTimeDiff\")]\n        [ChoPropertyInfo(\"compensateOneHourDSTTimeDiff\")]\n        public bool CompensateOneHourDSTTimeDiff\n        {\n            get { return _compensateOneHourDSTTimeDiff; }\n            set\n            {\n                _compensateOneHourDSTTimeDiff = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        #endregion Instance Data Members (Destination Options)\n\n        #region Instance Data Members (Copy Options)\n\n        bool _listOnly;\n        [Category(\"4. Copy Options\")]\n        [Description(\"List only - don't copy, timestamp or delete any files. (/L).\")]\n        [DisplayName(\"ListOnly\")]\n        [ChoPropertyInfo(\"listOnly\")]\n        public bool ListOnly\n        {\n            get { return _listOnly; }\n            set\n            {\n                _listOnly = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        ChoFileMoveAttributes _moveFilesAndDirectories;\n        [Category(\"4. Copy Options\")]\n        [Description(\"Move files and dirs (delete from source after copying). (/MOV or /MOVE).\")]\n        [DisplayName(\"MoveFilesAndDirectories\")]\n        [ChoPropertyInfo(\"moveFilesAndDirectories\", DefaultValue = \"None\")]\n        //[Editor(typeof(FileMoveSelectionAttributesEditor), typeof(FileMoveSelectionAttributesEditor))]\n        public ChoFileMoveAttributes MoveFilesAndDirectories\n        {\n            get { return _moveFilesAndDirectories; }\n            set\n            {\n                _moveFilesAndDirectories = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        internal void SetMoveFilesAndDirectories(ChoFileMoveAttributes value)\n        {\n            _moveFilesAndDirectories = value;\n            NotifyPropertyChanged(nameof(Comments));\n        }\n\n\n        bool _copySymbolicLinks;\n        [Category(\"4. Copy Options\")]\n        [Description(\"Copy symbolic links versus the target. (/SL).\")]\n        [DisplayName(\"CopySymbolicLinks\")]\n        [ChoPropertyInfo(\"copySymbolicLinks\")]\n        public bool CopySymbolicLinks\n        {\n            get { return _copySymbolicLinks; }\n            set\n            {\n                _copySymbolicLinks = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _copyFilesRestartableMode;\n        [Category(\"4. Copy Options\")]\n        [Description(\"Copy files in restartable mode. (/Z).\")]\n        [DisplayName(\"CopyFilesRestartableMode\")]\n        [ChoPropertyInfo(\"copyFilesRestartableMode\")]\n        public bool CopyFilesRestartableMode\n        {\n            get { return _copyFilesRestartableMode; }\n            set\n            {\n                _copyFilesRestartableMode = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _copyFilesBackupMode;\n        [Category(\"4. Copy Options\")]\n        [Description(\"Copy files in Backup mode. (/B).\")]\n        [DisplayName(\"CopyFilesBackupMode\")]\n        [ChoPropertyInfo(\"copyFilesBackupMode\")]\n        public bool CopyFilesBackupMode\n        {\n            get { return _copyFilesBackupMode; }\n            set\n            {\n                _copyFilesBackupMode = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _unbufferredIOCopy;\n        [Category(\"4. Copy Options\")]\n        [Description(\"Copy using unbuffered I/O (recommended for large files). (/J)\")]\n        [DisplayName(\"UnbufferredIOCopy\")]\n        [ChoPropertyInfo(\"unbufferredIOCopy\")]\n        public bool UnbufferredIOCopy\n        {\n            get { return _unbufferredIOCopy; }\n            set\n            {\n                _unbufferredIOCopy = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _copyWithoutWindowsCopyOffload;\n        [Category(\"4. Copy Options\")]\n        [Description(\"Copy files without using the Windows Copy Offload mechanism. (/NOOFFLOAD).\")]\n        [DisplayName(\"CopyWithoutWindowsCopyOffload\")]\n        [ChoPropertyInfo(\"copyWithoutWindowsCopyOffload\")]\n        public bool CopyWithoutWindowsCopyOffload\n        {\n            get { return _copyWithoutWindowsCopyOffload; }\n            set\n            {\n                _copyWithoutWindowsCopyOffload = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _encrptFileEFSRawMode;\n        [Category(\"4. Copy Options\")]\n        [Description(\"Copy all encrypted files in EFS RAW mode. (/EFSRAW).\")]\n        [DisplayName(\"EncrptFileEFSRawMode\")]\n        [ChoPropertyInfo(\"encrptFileEFSRawMode\")]\n        public bool EncrptFileEFSRawMode\n        {\n            get { return _encrptFileEFSRawMode; }\n            set\n            {\n                _encrptFileEFSRawMode = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _fixFileTimeOnFiles;\n        [Category(\"4. Copy Options\")]\n        [Description(\"Fix file times on all files, even skipped files. (/TIMFIX).\")]\n        [DisplayName(\"FixFileTimeOnFiles\")]\n        [ChoPropertyInfo(\"fixFileTimeOnFiles\")]\n        public bool FixFileTimeOnFiles\n        {\n            get { return _fixFileTimeOnFiles; }\n            set\n            {\n                _fixFileTimeOnFiles = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _excludeOlderFiles;\n        [Category(\"4. Copy Options\")]\n        [Description(\"eXclude Older files. (/XO).\")]\n        [DisplayName(\"ExcludeOlderFiles\")]\n        [ChoPropertyInfo(\"excludeOlderFiles\")]\n        public bool ExcludeOlderFiles\n        {\n            get { return _excludeOlderFiles; }\n            set\n            {\n                _excludeOlderFiles = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _excludeChangedFiles;\n        [Category(\"4. Copy Options\")]\n        [Description(\"eXclude Changed files. (/XC).\")]\n        [DisplayName(\"ExcludeChangedFiles\")]\n        [ChoPropertyInfo(\"excludeChangedFiles\")]\n        public bool ExcludeChangedFiles\n        {\n            get { return _excludeChangedFiles; }\n            set\n            {\n                _excludeChangedFiles = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _excludeNewerFiles;\n        [Category(\"4. Copy Options\")]\n        [Description(\"eXclude Newer files. (/XN).\")]\n        [DisplayName(\"ExcludeNewerFiles\")]\n        [ChoPropertyInfo(\"excludeNewerFiles\")]\n        public bool ExcludeNewerFiles\n        {\n            get { return _excludeNewerFiles; }\n            set\n            {\n                _excludeNewerFiles = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _excludeExtraFilesAndDirs;\n        [Category(\"4. Copy Options\")]\n        [Description(\"eXclude eXtra files and directories. (/XX).\")]\n        [DisplayName(\"ExcludeExtraFilesAndDirs\")]\n        [ChoPropertyInfo(\"excludeExtraFilesAndDirs\")]\n        public bool ExcludeExtraFilesAndDirs\n        {\n            get { return _excludeExtraFilesAndDirs; }\n            set\n            {\n                _excludeExtraFilesAndDirs = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        string _excludeFilesWithGivenNames;\n        [Category(\"4. Copy Options\")]\n        [Description(\"eXclude Files matching given names/paths/wildcards. Separate names with ;. (/XF).\")]\n        [DisplayName(\"ExcludeFilesWithGivenNames\")]\n        [ChoPropertyInfo(\"excludeFilesWithGivenNames\", DefaultValue = \"\")]\n        //[Editor(typeof(ChoPropertyGridFilePicker), typeof(ChoPropertyGridFilePicker))]\n        [PropertyGridOptions(EditorDataTemplateResourceKey = \"BigTextEditor\")]\n        public string ExcludeFilesWithGivenNames\n        {\n            get { return _excludeFilesWithGivenNames; }\n            set\n            {\n                _excludeFilesWithGivenNames = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        string _excludeDirsWithGivenNames;\n        [Category(\"4. Copy Options\")]\n        [Description(\"eXclude Directories matching given names/paths. Separate names with ;. (/XD).\")]\n        [DisplayName(\"ExcludeDirsWithGivenNames\")]\n        [ChoPropertyInfo(\"excludeDirsWithGivenNames\", DefaultValue = \"\")]\n        //[Editor(typeof(ChoPropertyGridFolderPicker), typeof(ChoPropertyGridFolderPicker))]\n        [PropertyGridOptions(EditorDataTemplateResourceKey = \"BigTextEditor\")]\n        public string ExcludeDirsWithGivenNames\n        {\n            get { return _excludeDirsWithGivenNames; }\n            set\n            {\n                _excludeDirsWithGivenNames = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        ChoFileSelectionAttributes _includeFilesWithGivenAttributes;\n        [Category(\"4. Copy Options\")]\n        [Description(\"Include only files with any of the given Attributes set. (/IA:[RASHCNETO]).\")]\n        [DisplayName(\"IncludeFilesWithGivenAttributes\")]\n        [ChoPropertyInfo(\"includeFilesWithGivenAttributes\", DefaultValue = \"\")]\n        //[Editor(typeof(FileSelectionAttributesEditor), typeof(FileSelectionAttributesEditor))]\n        [XmlIgnore]\n        public ChoFileSelectionAttributes IncludeFilesWithGivenAttributes\n        {\n            get { return _includeFilesWithGivenAttributes; }\n            set\n            {\n                _includeFilesWithGivenAttributes = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        [Browsable(false)]\n        [XmlElement(\"IncludeFilesWithGivenAttributes\")]\n        public string IncludeFilesWithGivenAttributesElement\n        {\n            get { return IncludeFilesWithGivenAttributes.ToString(); }\n            set\n            {\n                if (value != null)\n                {\n                    if (!value.Contains(\",\"))\n                        value = value.Replace(\" \", \",\").Trim();\n                }\n\n                ChoFileSelectionAttributes includeFilesWithGivenAttributes;\n                if (Enum.TryParse<ChoFileSelectionAttributes>(value, out includeFilesWithGivenAttributes))\n                    _includeFilesWithGivenAttributes = includeFilesWithGivenAttributes;\n            }\n        }\n\n        ChoFileSelectionAttributes _excludeFilesWithGivenAttributes;\n        [Category(\"4. Copy Options\")]\n        [Description(\"eXclude files with any of the given Attributes set. (/XA:[RASHCNETO]).\")]\n        [DisplayName(\"ExcludeFilesWithGivenAttributes\")]\n        [ChoPropertyInfo(\"excludeFilesWithGivenAttributes\", DefaultValue = \"\")]\n        //[Editor(typeof(FileSelectionAttributesEditor), typeof(FileSelectionAttributesEditor))]\n        [XmlIgnore]\n        public ChoFileSelectionAttributes ExcludeFilesWithGivenAttributes\n        {\n            get { return _excludeFilesWithGivenAttributes; }\n            set\n            {\n                _excludeFilesWithGivenAttributes = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        [Browsable(false)]\n        [XmlElement(\"ExcludeFilesWithGivenAttributes\")]\n        public string ExcludeFilesWithGivenAttributesElement\n        {\n            get { return ExcludeFilesWithGivenAttributes.ToString(); }\n            set\n            {\n                if (value != null)\n                {\n                    if (!value.Contains(\",\"))\n                        value = value.Replace(\" \", \",\").Trim();\n                }\n\n                ChoFileSelectionAttributes excludeFilesWithGivenAttributes;\n                if (Enum.TryParse<ChoFileSelectionAttributes>(value, out excludeFilesWithGivenAttributes))\n                    _excludeFilesWithGivenAttributes = excludeFilesWithGivenAttributes;\n            }\n        }\n\n        bool _overrideModifiedFiles;\n        [Category(\"4. Copy Options\")]\n        [Description(\"Include Modified files (differing change times). Otherwise the same. These files are not copied by default;. (/IM).\")]\n        [DisplayName(\"OverrideModifiedFiles\")]\n        [ChoPropertyInfo(\"overrideModifiedFiles\")]\n        public bool OverrideModifiedFiles\n        {\n            get { return _overrideModifiedFiles; }\n            set\n            {\n                _overrideModifiedFiles = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _includeSameFiles;\n        [Category(\"4. Copy Options\")]\n        [Description(\"Include Same files. Overwrite files even if they are already the same. (/IS).\")]\n        [DisplayName(\"IncludeSameFiles\")]\n        [ChoPropertyInfo(\"includeSameFiles\")]\n        public bool IncludeSameFiles\n        {\n            get { return _includeSameFiles; }\n            set\n            {\n                _includeSameFiles = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _includeTweakedFiles;\n        [Category(\"4. Copy Options\")]\n        [Description(\"Include Tweaked files. (/IT).\")]\n        [DisplayName(\"IncludeTweakedFiles\")]\n        [ChoPropertyInfo(\"includeTweakedFiles\")]\n        public bool IncludeTweakedFiles\n        {\n            get { return _includeTweakedFiles; }\n            set\n            {\n                _includeTweakedFiles = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _excludeJunctionPoints;\n        [Category(\"4. Copy Options\")]\n        [Description(\"eXclude Junction points and symbolic links. (normally included by default). (/XJ).\")]\n        [DisplayName(\"ExcludeJunctionPoints\")]\n        [ChoPropertyInfo(\"excludeJunctionPoints\")]\n        public bool ExcludeJunctionPoints\n        {\n            get { return _excludeJunctionPoints; }\n            set\n            {\n                _excludeJunctionPoints = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _excludeJunctionPointsForDirs;\n        [Category(\"4. Copy Options\")]\n        [Description(\"eXclude Junction points and symbolic links for source directories. (/XJD).\")]\n        [DisplayName(\"ExcludeJunctionPointsForDirs\")]\n        [ChoPropertyInfo(\"excludeJunctionPointsForDirs\")]\n        public bool ExcludeJunctionPointsForDirs\n        {\n            get { return _excludeJunctionPointsForDirs; }\n            set\n            {\n                _excludeJunctionPointsForDirs = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _excludeJunctionPointsForFiles;\n        [Category(\"4. Copy Options\")]\n        [Description(\"eXclude symbolic links for source files. (/XJF).\")]\n        [DisplayName(\"ExcludeJunctionPointsForFiles\")]\n        [ChoPropertyInfo(\"excludeJunctionPointsForFiles\")]\n        public bool ExcludeJunctionPointsForFiles\n        {\n            get { return _excludeJunctionPointsForFiles; }\n            set\n            {\n                _excludeJunctionPointsForFiles = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        uint _excludeFilesBiggerThanNBytes;\n        [Category(\"4. Copy Options\")]\n        [Description(\"MAXimum file size - exclude files bigger than n bytes. (/MAX:n).\")]\n        [DisplayName(\"ExcludeFilesBiggerThanNBytes\")]\n        [ChoPropertyInfo(\"excludeFilesBiggerThanNBytes\")]\n        [PropertyGridOptions(EditorDataTemplateResourceKey = \"NumericDropDownListEditor\")]\n        public uint ExcludeFilesBiggerThanNBytes\n        {\n            get { return _excludeFilesBiggerThanNBytes; }\n            set\n            {\n                _excludeFilesBiggerThanNBytes = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        uint _excludeFilesSmallerThanNBytes;\n        [Category(\"4. Copy Options\")]\n        [Description(\"MINimum file size - exclude files smaller than n bytes. (/MIN:n).\")]\n        [DisplayName(\"ExcludeFilesSmallerThanNBytes\")]\n        [ChoPropertyInfo(\"excludeFilesSmallerThanNBytes\")]\n        [PropertyGridOptions(EditorDataTemplateResourceKey = \"NumericDropDownListEditor\")]\n        public uint ExcludeFilesSmallerThanNBytes\n        {\n            get { return _excludeFilesSmallerThanNBytes; }\n            set\n            {\n                _excludeFilesSmallerThanNBytes = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        uint _excludeFilesUnusedSinceNDays;\n        [Category(\"4. Copy Options\")]\n        [Description(\"MAXimum Last Access Date - exclude files unused since n. (/MAXLAD:n).\")]\n        [DisplayName(\"ExcludeFilesUnusedSinceNDays\")]\n        [ChoPropertyInfo(\"excludeFilesUnusedSinceNDays\")]\n        [PropertyGridOptions(EditorDataTemplateResourceKey = \"NumericDropDownListEditor\")]\n        public uint ExcludeFilesUnusedSinceNDays\n        {\n            get { return _excludeFilesUnusedSinceNDays; }\n            set\n            {\n                _excludeFilesUnusedSinceNDays = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        uint _excludeFilesUsedSinceNDays;\n        [Category(\"4. Copy Options\")]\n        [Description(\"MINimum Last Access Date - exclude files used since n. (If n < 1900 then n = n days, else n = YYYYMMDD date). (/MINLAD:n).\")]\n        [DisplayName(\"ExcludeFilesUsedSinceNDays\")]\n        [ChoPropertyInfo(\"excludeFilesUsedSinceNDays\")]\n        [PropertyGridOptions(EditorDataTemplateResourceKey = \"NumericDropDownListEditor\")]\n        public uint ExcludeFilesUsedSinceNDays\n        {\n            get { return _excludeFilesUsedSinceNDays; }\n            set\n            {\n                _excludeFilesUsedSinceNDays = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _mirrorDirTree;\n        [Category(\"4. Copy Options\")]\n        [Description(\"Mirror a directory tree (equivalent to /E plus /PURGE). (/MIR).\")]\n        [DisplayName(\"MirrorDirTree\")]\n        [ChoPropertyInfo(\"mirrorDirTree\")]\n        public bool MirrorDirTree\n        {\n            get { return _mirrorDirTree; }\n            set\n            {\n                _mirrorDirTree = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _delDestFileDirIfNotExistsInSource;\n        [Category(\"4. Copy Options\")]\n        [Description(\"Delete dest files/dirs that no longer exist in source. (/PURGE).\")]\n        [DisplayName(\"DelDestFileDirIfNotExistsInSource\")]\n        [ChoPropertyInfo(\"delDestFileDirIfNotExistsInSource\")]\n        public bool DelDestFileDirIfNotExistsInSource\n        {\n            get { return _delDestFileDirIfNotExistsInSource; }\n            set\n            {\n                _delDestFileDirIfNotExistsInSource = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _excludeLonelyFilesAndDirs;\n        [Category(\"4. Copy Options\")]\n        [Description(\"eXclude Lonely files and directories. (/XL).\")]\n        [DisplayName(\"ExcludeLonelyFilesAndDirs\")]\n        [ChoPropertyInfo(\"excludeLonelyFilesAndDirs\")]\n        public bool ExcludeLonelyFilesAndDirs\n        {\n            get { return _excludeLonelyFilesAndDirs; }\n            set\n            {\n                _excludeLonelyFilesAndDirs = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _fixFileSecurityOnFiles;\n        [Category(\"4. Copy Options\")]\n        [Description(\"Fix file security on all files, even skipped files. (/SECFIX).\")]\n        [DisplayName(\"FixFileSecurityOnFiles\")]\n        [ChoPropertyInfo(\"fixFileSecurityOnFiles\")]\n        public bool FixFileSecurityOnFiles\n        {\n            get { return _fixFileSecurityOnFiles; }\n            set\n            {\n                _fixFileSecurityOnFiles = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _fallbackCopyFilesMode;\n        [Category(\"4. Copy Options\")]\n        [Description(\"Use restartable mode; if access denied use Backup mode. (/ZB).\")]\n        [DisplayName(\"FallbackCopyFilesMode\")]\n        [ChoPropertyInfo(\"fallbackCopyFilesMode\")]\n        public bool FallbackCopyFilesMode\n        {\n            get { return _fallbackCopyFilesMode; }\n            set\n            {\n                _fallbackCopyFilesMode = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        uint _interPacketGapInMS;\n        [Category(\"4. Copy Options\")]\n        [Description(\"Inter-Packet Gap (ms), to free bandwidth on slow lines. (/IPG:n).\")]\n        [DisplayName(\"InterPacketGapInMS\")]\n        [ChoPropertyInfo(\"interPacketGapInMS\")]\n        public uint InterPacketGapInMS\n        {\n            get { return _interPacketGapInMS; }\n            set\n            {\n                _interPacketGapInMS = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        private uint _multithreadCopy;\n        [Category(\"4. Copy Options\")]\n        [Description(\"Do multi-threaded copies with n threads (default 8). n must be at least 1 and not greater than 128. This option is incompatible with the /IPG and /EFSRAW options. Redirect output using /LOG option for better performance. (/MT[:n]).\")]\n        [DisplayName(\"MultithreadCopy\")]\n        [ChoPropertyInfo(\"multithreadCopy\", DefaultValue = \"0\")]\n        [PropertyGridOptions(EditorDataTemplateResourceKey = \"NumericDropDownListEditor\")]\n        public uint MultithreadCopy\n        {\n            get { return _multithreadCopy; }\n            set\n            {\n                if (value < 1 || value > 128)\n                    _multithreadCopy = 0;\n                else\n                    _multithreadCopy = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _copyNODirInfo;\n        [Category(\"4. Copy Options\")]\n        [Description(\"COPY NO directory info (by default /DCOPY:DA is done). (/NODCOPY).\")]\n        [DisplayName(\"CopyNODirInfo\")]\n        [ChoPropertyInfo(\"copyNODirInfo\")]\n        public bool CopyNODirInfo\n        {\n            get { return _copyNODirInfo; }\n            set\n            {\n                _copyNODirInfo = value;\n                NotifyPropertyChanged();\n            }\n        }\n        #endregion Instance Data Members (Copy Options)\n\n        #region Instance Data Members (Monitoring Options)\n\n        const string DefaultNoOfRetries = \"1000000\";\n\n        uint _noOfRetries;\n        [Category(\"5. Monitoring Options\")]\n        [Description(\"Number of Retries on failed copies: default 1 million. (/R:n).\")]\n        [DisplayName(\"NoOfRetries\")]\n        [ChoPropertyInfo(\"noOfRetries\", DefaultValue = DefaultNoOfRetries)]\n        [PropertyGridOptions(EditorDataTemplateResourceKey = \"NumericDropDownListEditor\")]\n        public uint NoOfRetries\n        {\n            get { return _noOfRetries; }\n            set\n            {\n                _noOfRetries = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        const string DefaultWaitTimeBetweenRetries = \"30\";\n\n        uint _waitTimeBetweenRetries;\n        [Category(\"5. Monitoring Options\")]\n        [Description(\"Wait time between retries: default is 30 seconds. (/W:n).\")]\n        [DisplayName(\"WaitTimeBetweenRetries\")]\n        [ChoPropertyInfo(\"waitTimeBetweenRetries\", DefaultValue = DefaultWaitTimeBetweenRetries)]\n        [PropertyGridOptions(EditorDataTemplateResourceKey = \"NumericDropDownListEditor\")]\n        public uint WaitTimeBetweenRetries\n        {\n            get { return _waitTimeBetweenRetries; }\n            set\n            {\n                _waitTimeBetweenRetries = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _saveRetrySettingsToRegistry;\n        [Category(\"5. Monitoring Options\")]\n        [Description(\"Save /R:n and /W:n in the Registry as default settings. (/REG).\")]\n        [DisplayName(\"SaveRetrySettingsToRegistry\")]\n        [ChoPropertyInfo(\"saveRetrySettingsToRegistry\")]\n        public bool SaveRetrySettingsToRegistry\n        {\n            get { return _saveRetrySettingsToRegistry; }\n            set\n            {\n                _saveRetrySettingsToRegistry = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _waitForSharenames;\n        [Category(\"5. Monitoring Options\")]\n        [Description(\"Wait for sharenames to be defined (retry error 67). (/TBD).\")]\n        [DisplayName(\"WaitForSharenames\")]\n        [ChoPropertyInfo(\"waitForSharenames\")]\n        public bool WaitForSharenames\n        {\n            get { return _waitForSharenames; }\n            set\n            {\n                _waitForSharenames = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        uint _runAgainWithNoChangesSeen;\n        [Category(\"5. Monitoring Options\")]\n        [Description(\"Monitor source; run again when more than n changes seen. (/MON:n).\")]\n        [DisplayName(\"RunAgainWithNoChangesSeen\")]\n        [ChoPropertyInfo(\"runAgainWithNoChangesSeen\")]\n        [PropertyGridOptions(EditorDataTemplateResourceKey = \"NumericDropDownListEditor\")]\n        public uint RunAgainWithNoChangesSeen\n        {\n            get { return _runAgainWithNoChangesSeen; }\n            set\n            {\n                _runAgainWithNoChangesSeen = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        uint _runAgainWithChangesSeenInMin;\n        [Category(\"5. Monitoring Options\")]\n        [Description(\"Monitor source; run again in m minutes time, if changed. (/MOT:m).\")]\n        [DisplayName(\"RunAgainWithChangesSeenInMin\")]\n        [ChoPropertyInfo(\"runAgainWithChangesSeenInMin\")]\n        [PropertyGridOptions(EditorDataTemplateResourceKey = \"NumericDropDownListEditor\")]\n        public uint RunAgainWithChangesSeenInMin\n        {\n            get { return _runAgainWithChangesSeenInMin; }\n            set\n            {\n                _runAgainWithChangesSeenInMin = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        bool _checkRunHourPerFileBasis;\n        [Category(\"5. Monitoring Options\")]\n        [Description(\"Check run hours on a Per File (not per pass) basis. (/PF).\")]\n        [DisplayName(\"CheckRunHourPerFileBasis\")]\n        [ChoPropertyInfo(\"checkRunHourPerFileBasis\")]\n        public bool CheckRunHourPerFileBasis\n        {\n            get { return _checkRunHourPerFileBasis; }\n            set\n            {\n                _checkRunHourPerFileBasis = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        #endregion Instance Data Members (Monitoring Options)\n\n        #region Instance Data Members (Scheduling Options)\n\n        private TimeSpan _runHourStartTime;\n        [Category(\"6. Scheduling Options\")]\n        [Description(\"Run Hours StartTime, when new copies may be started after then. (/RH:hhmm-hhmm).\")]\n        [DisplayName(\"RunHourStartTime\")]\n        [ChoPropertyInfo(\"runHourStartTime\")]\n        [XmlIgnore]\n        [PropertyGridOptions(EditorDataTemplateResourceKey = \"TimePickerEditor\")]\n        [IgnoreValue(\"__:__:__\")]\n        public TimeSpan RunHourStartTime\n        {\n            get { return _runHourStartTime; }\n            set { _runHourStartTime = value; NotifyPropertyChanged(); }\n        }\n\n        [Browsable(false)]\n        public long RunHourStartTimeTicks\n        {\n            get { return _runHourStartTime.Ticks; }\n            set { _runHourStartTime = new TimeSpan(value); }\n        }\n\n        private TimeSpan _runHourEndTime;\n        [Category(\"6. Scheduling Options\")]\n        [Description(\"Run Hours EndTime, when new copies may be Ended before then. (/RH:hhmm-hhmm).\")]\n        [DisplayName(\"RunHourEndTime\")]\n        [ChoPropertyInfo(\"runHourEndTime\")]\n        [XmlIgnore]\n        [PropertyGridOptions(EditorDataTemplateResourceKey = \"TimePickerEditor\")]\n        [IgnoreValue(\"__:__:__\")]\n        public TimeSpan RunHourEndTime\n        {\n            get { return _runHourEndTime; }\n            set { _runHourEndTime = value; NotifyPropertyChanged(); }\n        }\n\n        [Browsable(false)]\n        public long RunHourEndTimeTicks\n        {\n            get { return _runHourEndTime.Ticks; }\n            set { _runHourEndTime = new TimeSpan(value); }\n        }\n\n\n        #endregion Instance Data Members (Scheduling Options)\n\n        #region Instance Data Members (Logging Options)\n\n        private bool _noProgress;\n        [Category(\"7. Logging Options\")]\n        [Description(\"No Progress - don't display percentage copied. Suppresses the display of progress information. This can be useful when output is redirected to a file. (/NP).\")]\n        [DisplayName(\"NoProgress\")]\n        [ChoPropertyInfo(\"noProgress\")]\n        public bool NoProgress\n        {\n            get { return _noProgress; }\n            set \n            { \n                _noProgress = value;\n                if (!value) ShowRoboCopyProgress = false;\n                NotifyPropertyChanged(); \n            }\n        }\n\n        private bool _unicode;\n        [Category(\"7. Logging Options\")]\n        [Description(\"Display the status output as unicode text. (/unicode).\")]\n        [DisplayName(\"Unicode\")]\n        [ChoPropertyInfo(\"unicode\")]\n        public bool Unicode\n        {\n            get { return _unicode; }\n            set { _unicode = value; NotifyPropertyChanged(); }\n        }\n\n        private string _outputLogFilePath;\n        [Category(\"7. Logging Options\")]\n        [Description(\"Output status to LOG file (overwrite existing log). (/LOG:file).\")]\n        [DisplayName(\"OutputLogFilePath\")]\n        [ChoPropertyInfo(\"outputLogFilePath\", DefaultValue = \"\")]\n        public string OutputLogFilePath\n        {\n            get { return _outputLogFilePath; }\n            set { _outputLogFilePath = value; NotifyPropertyChanged(); }\n        }\n\n        private string _unicodeOutputLogFilePath;\n        [Category(\"7. Logging Options\")]\n        [Description(\"Output status to LOG file as UNICODE (overwrite existing log). (/UNILOG:file).\")]\n        [DisplayName(\"UnicodeOutputLogFilePath\")]\n        [ChoPropertyInfo(\"unicodeOutputLogFilePath\", DefaultValue = \"\")]\n        public string UnicodeOutputLogFilePath\n        {\n            get { return _unicodeOutputLogFilePath; }\n            set { _unicodeOutputLogFilePath = value; NotifyPropertyChanged(); }\n        }\n\n        private string _appendOutputLogFilePath;\n        [Category(\"7. Logging Options\")]\n        [Description(\"Output status to LOG file (append to existing log). (/LOG+:file).\")]\n        [DisplayName(\"AppendOutputLogFilePath\")]\n        [ChoPropertyInfo(\"appendOutputLogFilePath\", DefaultValue = \"\")]\n        public string AppendOutputLogFilePath\n        {\n            get { return _appendOutputLogFilePath; }\n            set { _appendOutputLogFilePath = value; NotifyPropertyChanged(); }\n        }\n\n        private string _appendUnicodeOutputLogFilePath;\n        [Category(\"7. Logging Options\")]\n        [Description(\"Output status to LOG file as UNICODE (append to existing log). (/UNILOG+:file).\")]\n        [DisplayName(\"AppendUnicodeOutputLogFilePath\")]\n        [ChoPropertyInfo(\"appendUnicodeOutputLogFilePath\", DefaultValue = \"\")]\n        public string AppendUnicodeOutputLogFilePath\n        {\n            get { return _appendUnicodeOutputLogFilePath; }\n            set { _appendUnicodeOutputLogFilePath = value; NotifyPropertyChanged(); }\n        }\n\n        private bool _includeSourceFileTimestamp;\n        [Category(\"7. Logging Options\")]\n        [Description(\"Include source file timestamps in the output. (/TS).\")]\n        [DisplayName(\"IncludeSourceFileTimestamp\")]\n        [ChoPropertyInfo(\"includeSourceFileTimestamp\")]\n        public bool IncludeSourceFileTimestamp\n        {\n            get { return _includeSourceFileTimestamp; }\n            set { _includeSourceFileTimestamp = value; NotifyPropertyChanged(); }\n        }\n\n        private bool _includeFullPathName;\n        [Category(\"7. Logging Options\")]\n        [Description(\"Include Full Pathname of files in the output. (/FP).\")]\n        [DisplayName(\"IncludeFullPathName\")]\n        [ChoPropertyInfo(\"includeFullPathName\")]\n        public bool IncludeFullPathName\n        {\n            get { return _includeFullPathName; }\n            set { _includeFullPathName = value; NotifyPropertyChanged(); }\n        }\n\n        private bool _noFileSizeLog;\n        [Category(\"7. Logging Options\")]\n        [Description(\"No Size - don't log file sizes. (/NS).\")]\n        [DisplayName(\"NoFileSizeLog\")]\n        [ChoPropertyInfo(\"noFileSizeLog\")]\n        public bool NoFileSizeLog\n        {\n            get { return _noFileSizeLog; }\n            set { _noFileSizeLog = value; NotifyPropertyChanged(); }\n        }\n\n        private bool _noFileClassLog;\n        [Category(\"7. Logging Options\")]\n        [Description(\"No Class - don't log file classes. (/NC).\")]\n        [DisplayName(\"NoFileClassLog\")]\n        [ChoPropertyInfo(\"noFileClassLog\")]\n        public bool NoFileClassLog\n        {\n            get { return _noFileClassLog; }\n            set \n            { \n                _noFileClassLog = value;\n                if (!value) ShowRoboCopyProgress = false;\n                NotifyPropertyChanged(); \n            }\n        }\n\n        private bool _noFileNameLog;\n        [Category(\"7. Logging Options\")]\n        [Description(\"No File List - don't log file names. Hides file names. Failures are still logged though. Any files files deleted or would be deleted if /L was omitted are always logged. (/NFL).\")]\n        [DisplayName(\"NoFileNameLog\")]\n        [ChoPropertyInfo(\"noFileNameLog\")]\n        public bool NoFileNameLog\n        {\n            get { return _noFileNameLog; }\n            set { _noFileNameLog = value; NotifyPropertyChanged(); }\n        }\n\n        private bool _noDirListLog;\n        [Category(\"7. Logging Options\")]\n        [Description(\"No Directory List - don't log directory names. Hides output of the directory listing. Full file pathnames are output to more easily track down problematic files. (/NDL).\")]\n        [DisplayName(\"NoDirListLog\")]\n        [ChoPropertyInfo(\"noDirListLog\")]\n        public bool NoDirListLog\n        {\n            get { return _noDirListLog; }\n            set \n            { \n                _noDirListLog = value;\n                if (!value) ShowRoboCopyProgress = false;\n                NotifyPropertyChanged(); \n            }\n        }\n\n        //[Category(\"Logging Options\")]\n        //[Description(\"Output to console window, as well as the log file. (/TEE).\")]\n        //[DisplayName(\"NoDirListLog\")]\n        //[ChoPropertyInfo(\"noDirListLog\")]\n        //public bool NoDirListLog\n        //{\n        //    get;\n        //    set;\n        //}\n\n        private bool _noJobHeader;\n        [Category(\"7. Logging Options\")]\n        [Description(\"No Job Header. (/NJH).\")]\n        [DisplayName(\"NoJobHeader\")]\n        [ChoPropertyInfo(\"noJobHeader\")]\n        public bool NoJobHeader\n        {\n            get { return _noJobHeader; }\n            set \n            { \n                _noJobHeader = value;\n                if (!value) ShowRoboCopyProgress = false;\n                NotifyPropertyChanged(); \n            }\n        }\n\n        private bool _noJobSummary;\n        [Category(\"7. Logging Options\")]\n        [Description(\"No Job Summary. (/NJS).\")]\n        [DisplayName(\"NoJobSummary\")]\n        [ChoPropertyInfo(\"noJobSummary\")]\n        public bool NoJobSummary\n        {\n            get { return _noJobSummary; }\n            set \n            { \n                _noJobSummary = value;\n                if (!value) ShowRoboCopyProgress = false;\n                NotifyPropertyChanged(); \n            }\n        }\n\n        private bool _printByteSizes;\n        [Category(\"7. Logging Options\")]\n        [Description(\"Print sizes as bytes. (/BYTES).\")]\n        [DisplayName(\"PrintByteSizes\")]\n        [ChoPropertyInfo(\"printByteSizes\")]\n        public bool PrintByteSizes\n        {\n            get { return _printByteSizes; }\n            set \n            { \n                _printByteSizes = value;\n                if (!value) ShowRoboCopyProgress = false;\n                NotifyPropertyChanged(); \n            }\n        }\n\n        private bool _reportExtraFiles;\n        [Category(\"7. Logging Options\")]\n        [Description(\"Report all eXtra files, not just those selected. (/X).\")]\n        [DisplayName(\"ReportExtraFiles\")]\n        [ChoPropertyInfo(\"reportExtraFiles\")]\n        public bool ReportExtraFiles\n        {\n            get { return _reportExtraFiles; }\n            set { _reportExtraFiles = value; NotifyPropertyChanged(); }\n        }\n\n        private bool _verboseOutput;\n        [Category(\"7. Logging Options\")]\n        [Description(\"Produce Verbose output, showing skipped files. (/V).\")]\n        [DisplayName(\"VerboseOutput\")]\n        [ChoPropertyInfo(\"verboseOutput\")]\n        public bool VerboseOutput\n        {\n            get { return _verboseOutput; }\n            set { _verboseOutput = value; NotifyPropertyChanged(); }\n        }\n\n        private bool _showEstTimeOfArrival;\n        [Category(\"7. Logging Options\")]\n        [Description(\"Show Estimated Time of Arrival of copied files. (/ETA).\")]\n        [DisplayName(\"ShowEstTimeOfArrival\")]\n        [ChoPropertyInfo(\"showEstTimeOfArrival\")]\n        public bool ShowEstTimeOfArrival\n        {\n            get { return _showEstTimeOfArrival; }\n            set { _showEstTimeOfArrival = value; NotifyPropertyChanged(); }\n        }\n\n        private bool _showDebugVolumeInfo;\n        [Category(\"7. Logging Options\")]\n        [Description(\"Show debug volume information. (/DEBUG).\")]\n        [DisplayName(\"ShowDebugVolumeInfo\")]\n        [ChoPropertyInfo(\"showDebugVolumeInfo\")]\n        public bool ShowDebugVolumeInfo\n        {\n            get { return _showDebugVolumeInfo; }\n            set { _showDebugVolumeInfo = value; NotifyPropertyChanged(); }\n        }\n\n        #endregion Instance Data Members (Logging Options)\n\n        #region Commented\n\n        //[Category(\"Copy Options\")]\n        //[Description(\"Move files (delete from source after copying). (/MOV).\")]\n        //[DisplayName(\"MoveFiles\")]\n        //[ChoPropertyInfo(\"moveFiles\")]\n        //public bool MoveFiles\n        //{\n        //    get;\n        //    set;\n        //}\n\n        //[Category(\"Copy Options\")]\n        //[Description(\"Move files and dirs (delete from source after copying). (/MOVE).\")]\n        //[DisplayName(\"MoveFilesNDirs\")]\n        //[ChoPropertyInfo(\"moveFilesNDirs\")]\n        //public bool MoveFilesNDirs\n        //{\n        //    get;\n        //    set;\n        //}\n\n        #endregion Commented\n\n        public void Reset()\n        {\n            Copy(DefaultInstance, this);\n            //ChoObject.ResetObject(this);\n            //Persist();\n            SourceDirectory = null;\n            DestDirectory = null;\n            MultithreadCopy = 0;\n            Precommands = null;\n            Postcommands = null;\n            Comments = null;\n        }\n        \n        public string GetCmdLineText()\n        {\n            return \"{0} {1}\".FormatString(RoboCopyFilePath, GetCmdLineParams());\n        }\n\n        public string GetCmdLineTextEx()\n        {\n            return \"{0} {1} {2} {3}\".FormatString(RoboCopyFilePath, GetCmdLineParams(), GetExCmdLineParams(), Comments);\n        }\n\n        string DirSafeguard(string path)\n        {\n            // Escape the last '\\' from the path if it is not escaped yet.\n            if (path.Length > 1 && path.Last() == '\\\\' && (path[path.Length - 2] != '\\\\'))\n                path += '\\\\';\n            return path;\n        }\n\n        internal string GetExCmdLineParams()\n        {\n            StringBuilder cmdText = new StringBuilder();\n\n            if (!Postcommands.IsNullOrWhiteSpace())\n                cmdText.Append(Postcommands);\n            if (!Precommands.IsNullOrWhiteSpace())\n                cmdText.Append(Precommands);\n            cmdText.Append($\"/ShowOutputLineNumbers:{ShowOutputLineNumbers}\");\n            cmdText.Append($\"/ShowRoboCopyProgress:{ShowRoboCopyProgress}\");\n\n            return cmdText.ToString();\n        }\n        internal string GetCmdLineParams(string sourceDirectory = null, string destDirectory = null)\n        {\n            StringBuilder cmdText = new StringBuilder();\n            \n            if (!sourceDirectory.IsNullOrWhiteSpace())\n                cmdText.AppendFormat(\" \\\"{0}\\\"\", DirSafeguard(sourceDirectory));\n            else if (!SourceDirectory.IsNullOrWhiteSpace())\n                cmdText.AppendFormat(\" \\\"{0}\\\"\", DirSafeguard(SourceDirectory));\n\n            if (!destDirectory.IsNullOrWhiteSpace())\n                cmdText.AppendFormat(\" \\\"{0}\\\"\", DirSafeguard(destDirectory));\n            else if (!DestDirectory.IsNullOrWhiteSpace())\n                cmdText.AppendFormat(\" \\\"{0}\\\"\", DirSafeguard(DestDirectory));\n\n            if (!Files.IsNullOrWhiteSpace())\n                cmdText.AppendFormat(\" {0}\", Files);\n            else\n                cmdText.Append(\"*.*\");\n\n            //Copy Options\n            if (CopyNoEmptySubDirectories)\n                cmdText.Append(\" /S\");\n            if (CopySubDirectories)\n                cmdText.Append(\" /E\");\n            if (OnlyCopyNLevels > 0)\n                cmdText.AppendFormat(\" /LEV:{0}\", OnlyCopyNLevels);\n            if (CopyFilesRestartableMode)\n                cmdText.Append(\" /Z\");\n            if (CopyFilesBackupMode)\n                cmdText.Append(\" /B\");\n            if (FallbackCopyFilesMode)\n                cmdText.Append(\" /ZB\");\n            if (UnbufferredIOCopy)\n                cmdText.Append(\" /J\");\n\n            if (EncrptFileEFSRawMode)\n                cmdText.Append(\" /EFSRAW\");\n\n            StringBuilder copyFileFlags = new StringBuilder();\n            if ((CopyFileFlags & ChoCopyFileFlags.Data) == ChoCopyFileFlags.Data)\n                copyFileFlags.Append($\"D\");\n            if ((CopyFileFlags & ChoCopyFileFlags.Attributes) == ChoCopyFileFlags.Attributes)\n                copyFileFlags.Append($\"A\");\n            if ((CopyFileFlags & ChoCopyFileFlags.Timestamps) == ChoCopyFileFlags.Timestamps)\n                copyFileFlags.Append($\"T\");\n            if ((CopyFileFlags & ChoCopyFileFlags.SecurityNTFSACLs) == ChoCopyFileFlags.SecurityNTFSACLs)\n                copyFileFlags.Append($\"S\");\n            if ((CopyFileFlags & ChoCopyFileFlags.OwnerInfo) == ChoCopyFileFlags.OwnerInfo)\n                copyFileFlags.Append($\"O\");\n            if ((CopyFileFlags & ChoCopyFileFlags.AuditingInfo) == ChoCopyFileFlags.AuditingInfo)\n                copyFileFlags.Append($\"U\");\n            if (copyFileFlags.Length > 0)\n                cmdText.AppendFormat(\" /COPY:{0}\", copyFileFlags.ToString());\n\n            StringBuilder copyDirFlags = new StringBuilder();\n            if ((CopyDirFlags & ChoCopyDirFlags.Data) == ChoCopyDirFlags.Data)\n                copyDirFlags.Append($\"D\");\n            if ((CopyDirFlags & ChoCopyDirFlags.Attributes) == ChoCopyDirFlags.Attributes)\n                copyDirFlags.Append($\"A\");\n            if ((CopyDirFlags & ChoCopyDirFlags.Timestamps) == ChoCopyDirFlags.Timestamps)\n                copyDirFlags.Append($\"T\");\n            if ((CopyDirFlags & ChoCopyDirFlags.ExtendedAttributes) == ChoCopyDirFlags.ExtendedAttributes)\n                copyDirFlags.Append($\"E\");\n            if ((CopyDirFlags & ChoCopyDirFlags.SkipAlternativeDataStreams) == ChoCopyDirFlags.SkipAlternativeDataStreams)\n                copyDirFlags.Append($\"X\");\n            if (copyDirFlags.Length > 0)\n                cmdText.AppendFormat(\" /DCOPY:{0}\", copyDirFlags.ToString());\n\n            if (CopyFilesWithSecurity)\n                cmdText.Append(\" /SEC\");\n\n            if (CopyFilesWithFileInfo)\n                cmdText.Append(\" /COPYALL\");\n            if (CopyFilesWithNoFileInfo)\n                cmdText.Append(\" /NOCOPY\");\n            if (FixFileSecurityOnFiles)\n                cmdText.Append(\" /SECFIX\");\n            if (FixFileTimeOnFiles)\n                cmdText.Append(\" /TIMFIX\");\n\n            if (DelDestFileDirIfNotExistsInSource)\n                cmdText.Append(\" /PURGE\");\n            if (MirrorDirTree)\n                cmdText.Append(\" /MIR\");\n            //if (MoveFiles)\n            //    cmdText.Append(\" /MOV\");\n            //if (MoveFilesNDirs)\n            //    cmdText.Append(\" /MOVE\");\n            switch (MoveFilesAndDirectories)\n            {\n                case ChoFileMoveAttributes.MoveFilesOnly:\n                    cmdText.Append(\" /MOV\");\n                    break;\n                case ChoFileMoveAttributes.MoveDirectoriesAndFiles:\n                    cmdText.Append(\" /MOVE\");\n                    break;\n                default:\n                    break;\n            }\n\n            StringBuilder addFileAttributes = new StringBuilder();\n            if ((AddFileAttributes & ChoFileAttributes.ReadOnly) == ChoFileAttributes.ReadOnly)\n                addFileAttributes.Append($\"R\");\n            if ((AddFileAttributes & ChoFileAttributes.Hidden) == ChoFileAttributes.Hidden)\n                addFileAttributes.Append($\"H\");\n            if ((AddFileAttributes & ChoFileAttributes.Archive) == ChoFileAttributes.Archive)\n                addFileAttributes.Append($\"A\");\n            if ((AddFileAttributes & ChoFileAttributes.System) == ChoFileAttributes.System)\n                addFileAttributes.Append($\"S\");\n            if ((AddFileAttributes & ChoFileAttributes.Compressed) == ChoFileAttributes.Compressed)\n                addFileAttributes.Append($\"C\");\n            if ((AddFileAttributes & ChoFileAttributes.NotContentIndexed) == ChoFileAttributes.NotContentIndexed)\n                addFileAttributes.Append($\"N\");\n            if ((AddFileAttributes & ChoFileAttributes.Encrypted) == ChoFileAttributes.Encrypted)\n                addFileAttributes.Append($\"E\");\n            if ((AddFileAttributes & ChoFileAttributes.Temporary) == ChoFileAttributes.Temporary)\n                addFileAttributes.Append($\"T\");\n            if (addFileAttributes.Length > 0)\n                cmdText.AppendFormat(\" /A+:{0}\", addFileAttributes.ToString());\n\n            StringBuilder removeFileAttributes = new StringBuilder();\n            if ((RemoveFileAttributes & ChoFileAttributes.ReadOnly) == ChoFileAttributes.ReadOnly)\n                removeFileAttributes.Append($\"R\");\n            if ((RemoveFileAttributes & ChoFileAttributes.Hidden) == ChoFileAttributes.Hidden)\n                removeFileAttributes.Append($\"H\");\n            if ((RemoveFileAttributes & ChoFileAttributes.Archive) == ChoFileAttributes.Archive)\n                removeFileAttributes.Append($\"A\");\n            if ((RemoveFileAttributes & ChoFileAttributes.System) == ChoFileAttributes.System)\n                removeFileAttributes.Append($\"S\");\n            if ((RemoveFileAttributes & ChoFileAttributes.Compressed) == ChoFileAttributes.Compressed)\n                removeFileAttributes.Append($\"C\");\n            if ((RemoveFileAttributes & ChoFileAttributes.NotContentIndexed) == ChoFileAttributes.NotContentIndexed)\n                removeFileAttributes.Append($\"N\");\n            if ((RemoveFileAttributes & ChoFileAttributes.Encrypted) == ChoFileAttributes.Encrypted)\n                removeFileAttributes.Append($\"E\");\n            if ((RemoveFileAttributes & ChoFileAttributes.Temporary) == ChoFileAttributes.Temporary)\n                removeFileAttributes.Append($\"T\");\n            if (removeFileAttributes.Length > 0)\n                cmdText.AppendFormat(\" /A-:{0}\", removeFileAttributes.ToString());\n\n            if (CreateDirTree)\n                cmdText.Append(\" /CREATE\");\n            if (CreateFATFileNames)\n                cmdText.Append(\" /FAT\");\n            if (TurnOffLongPath)\n                cmdText.Append(\" /256\");\n\n            if (RunAgainWithNoChangesSeen > 0)\n                cmdText.AppendFormat(\" /MON:{0}\", RunAgainWithNoChangesSeen);\n            if (RunAgainWithChangesSeenInMin > 0)\n                cmdText.AppendFormat(\" /MOT:{0}\", RunAgainWithChangesSeenInMin);\n            if (RunHourStartTime != TimeSpan.Zero\n                && RunHourEndTime != TimeSpan.Zero\n                && RunHourStartTime < RunHourEndTime)\n                cmdText.AppendFormat(\" /RH:{0}-{1}\", RunHourStartTime.ToString(\"hhmm\"), RunHourEndTime.ToString(\"hhmm\"));\n            if (CheckRunHourPerFileBasis)\n                cmdText.Append(\" /PF\");\n            if (InterPacketGapInMS > 0)\n                cmdText.AppendFormat(\" /IPG:{0}\", InterPacketGapInMS);\n            if (CopySymbolicLinks)\n                cmdText.Append(\" /SL\");\n            if (MultithreadCopy > 0)\n                cmdText.AppendFormat(\" /MT:{0}\", MultithreadCopy);\n            if (CopyNODirInfo)\n                cmdText.Append(\" /NODCOPY\");\n            if (CopyWithoutWindowsCopyOffload)\n                cmdText.Append(\" /NOOFFLOAD\");\n            if (OverrideModifiedFiles)\n                cmdText.Append(\" /IM\");\n            //File Selection Options\n            if (CopyOnlyFilesWithArchiveAttributes)\n                cmdText.Append(\" /A\");\n            if (CopyOnlyFilesWithArchiveAttributesAndReset)\n                cmdText.Append(\" /M\");\n\n            StringBuilder includeFilesWithGivenAttributes = new StringBuilder();\n            if ((IncludeFilesWithGivenAttributes & ChoFileSelectionAttributes.ReadOnly) == ChoFileSelectionAttributes.ReadOnly)\n                removeFileAttributes.Append($\"R\");\n            if ((IncludeFilesWithGivenAttributes & ChoFileSelectionAttributes.Archive) == ChoFileSelectionAttributes.Archive)\n                removeFileAttributes.Append($\"A\");\n            if ((IncludeFilesWithGivenAttributes & ChoFileSelectionAttributes.System) == ChoFileSelectionAttributes.System)\n                removeFileAttributes.Append($\"S\");\n            if ((IncludeFilesWithGivenAttributes & ChoFileSelectionAttributes.Hidden) == ChoFileSelectionAttributes.Hidden)\n                removeFileAttributes.Append($\"H\");\n            if ((IncludeFilesWithGivenAttributes & ChoFileSelectionAttributes.Compressed) == ChoFileSelectionAttributes.Compressed)\n                removeFileAttributes.Append($\"C\");\n            if ((IncludeFilesWithGivenAttributes & ChoFileSelectionAttributes.NotContentIndexed) == ChoFileSelectionAttributes.NotContentIndexed)\n                removeFileAttributes.Append($\"N\");\n            if ((IncludeFilesWithGivenAttributes & ChoFileSelectionAttributes.Encrypted) == ChoFileSelectionAttributes.Encrypted)\n                removeFileAttributes.Append($\"E\");\n            if ((IncludeFilesWithGivenAttributes & ChoFileSelectionAttributes.Temporary) == ChoFileSelectionAttributes.Temporary)\n                removeFileAttributes.Append($\"T\");\n            if ((IncludeFilesWithGivenAttributes & ChoFileSelectionAttributes.Offline) == ChoFileSelectionAttributes.Offline)\n                removeFileAttributes.Append($\"O\");\n            if (includeFilesWithGivenAttributes.Length > 0)\n                cmdText.AppendFormat(\" /IA:{0}\", includeFilesWithGivenAttributes.ToString());\n\n\n            StringBuilder excludeFilesWithGivenAttributes = new StringBuilder();\n            if ((ExcludeFilesWithGivenAttributes & ChoFileSelectionAttributes.ReadOnly) == ChoFileSelectionAttributes.ReadOnly)\n                removeFileAttributes.Append($\"R\");\n            if ((ExcludeFilesWithGivenAttributes & ChoFileSelectionAttributes.Archive) == ChoFileSelectionAttributes.Archive)\n                removeFileAttributes.Append($\"A\");\n            if ((ExcludeFilesWithGivenAttributes & ChoFileSelectionAttributes.System) == ChoFileSelectionAttributes.System)\n                removeFileAttributes.Append($\"S\");\n            if ((ExcludeFilesWithGivenAttributes & ChoFileSelectionAttributes.Hidden) == ChoFileSelectionAttributes.Hidden)\n                removeFileAttributes.Append($\"H\");\n            if ((ExcludeFilesWithGivenAttributes & ChoFileSelectionAttributes.Compressed) == ChoFileSelectionAttributes.Compressed)\n                removeFileAttributes.Append($\"C\");\n            if ((ExcludeFilesWithGivenAttributes & ChoFileSelectionAttributes.NotContentIndexed) == ChoFileSelectionAttributes.NotContentIndexed)\n                removeFileAttributes.Append($\"N\");\n            if ((ExcludeFilesWithGivenAttributes & ChoFileSelectionAttributes.Encrypted) == ChoFileSelectionAttributes.Encrypted)\n                removeFileAttributes.Append($\"E\");\n            if ((ExcludeFilesWithGivenAttributes & ChoFileSelectionAttributes.Temporary) == ChoFileSelectionAttributes.Temporary)\n                removeFileAttributes.Append($\"T\");\n            if ((ExcludeFilesWithGivenAttributes & ChoFileSelectionAttributes.Offline) == ChoFileSelectionAttributes.Offline)\n                removeFileAttributes.Append($\"O\");\n            if (excludeFilesWithGivenAttributes.Length > 0)\n                cmdText.AppendFormat(\" /XA:{0}\", excludeFilesWithGivenAttributes.ToString());\n            \n            if (!ExcludeFilesWithGivenNames.IsNullOrWhiteSpace())\n                cmdText.AppendFormat(@\" /XF {0}\", String.Join(\" \", ExcludeFilesWithGivenNames.Split(\";\").Select(f => f).Select(f => f.Contains(\" \") ? String.Format(@\"\"\"{0}\"\"\", f) : f)));\n            if (!ExcludeDirsWithGivenNames.IsNullOrWhiteSpace())\n                cmdText.AppendFormat(@\" /XD {0}\", String.Join(\" \", ExcludeDirsWithGivenNames.Split(\";\").Select(f => f).Select(f => f.Contains(\" \") ? String.Format(@\"\"\"{0}\"\"\", f) : f)));\n            if (ExcludeChangedFiles)\n                cmdText.Append(\" /XC\");\n            if (ExcludeNewerFiles)\n                cmdText.Append(\" /XN\");\n            if (ExcludeOlderFiles)\n                cmdText.Append(\" /XO\");\n            if (ExcludeExtraFilesAndDirs)\n                cmdText.Append(\" /XX\");\n            if (ExcludeLonelyFilesAndDirs)\n                cmdText.Append(\" /XL\");\n            if (IncludeSameFiles)\n                cmdText.Append(\" /IS\");\n            if (IncludeTweakedFiles)\n                cmdText.Append(\" /IT\");\n\n            if (ExcludeFilesBiggerThanNBytes > 0)\n                cmdText.AppendFormat(\" /MAX:{0}\", ExcludeFilesBiggerThanNBytes);\n            if (ExcludeFilesSmallerThanNBytes > 0)\n                cmdText.AppendFormat(\" /MIN:{0}\", ExcludeFilesSmallerThanNBytes);\n\n            if (ExcludeFilesOlderThanNDays > 0)\n                cmdText.AppendFormat(\" /MAXAGE:{0}\", ExcludeFilesOlderThanNDays);\n            if (ExcludeFilesNewerThanNDays > 0)\n                cmdText.AppendFormat(\" /MINAGE:{0}\", ExcludeFilesNewerThanNDays);\n            if (ExcludeFilesUnusedSinceNDays > 0)\n                cmdText.AppendFormat(\" /MAXLAD:{0}\", ExcludeFilesUnusedSinceNDays);\n            if (ExcludeFilesUsedSinceNDays > 0)\n                cmdText.AppendFormat(\" /MINLAD:{0}\", ExcludeFilesUsedSinceNDays);\n\n            if (ExcludeJunctionPoints)\n                cmdText.Append(\" /XJ\");\n            if (AssumeFATFileTimes)\n                cmdText.Append(\" /FFT\");\n            if (CompensateOneHourDSTTimeDiff)\n                cmdText.Append(\" /DST\");\n            if (ExcludeJunctionPointsForDirs)\n                cmdText.Append(\" /XJD\");\n            if (ExcludeJunctionPointsForFiles)\n                cmdText.Append(\" /XJF\");\n\n            //Retry Options\n            if (NoOfRetries.ToString() != DefaultNoOfRetries && NoOfRetries >= 0)\n                cmdText.AppendFormat(\" /R:{0}\", NoOfRetries);\n            if (WaitTimeBetweenRetries.ToString() != DefaultWaitTimeBetweenRetries && WaitTimeBetweenRetries >= 0)\n                cmdText.AppendFormat(\" /W:{0}\", WaitTimeBetweenRetries);\n            if (SaveRetrySettingsToRegistry)\n                cmdText.Append(\" /REG\");\n            if (WaitForSharenames)\n                cmdText.Append(\" /TBD\");\n\n            //Logging Options\n            if (ListOnly)\n                cmdText.Append(\" /L\");\n            if (ReportExtraFiles)\n                cmdText.Append(\" /X\");\n            if (VerboseOutput)\n                cmdText.Append(\" /V\");\n            if (IncludeSourceFileTimestamp)\n                cmdText.Append(\" /TS\");\n            if (IncludeFullPathName)\n                cmdText.Append(\" /FP\");\n            if (PrintByteSizes)\n                cmdText.Append(\" /BYTES\");\n            if (NoFileSizeLog)\n                cmdText.Append(\" /NS\");\n            if (NoFileClassLog)\n                cmdText.Append(\" /NC\");\n            if (NoFileNameLog)\n                cmdText.Append(\" /NFL\");\n            if (NoDirListLog)\n                cmdText.Append(\" /NDL\");\n            if (NoProgress)\n                cmdText.Append(\" /NP\");\n            if (Unicode)\n                cmdText.Append(\" /unicode\");\n            if (ShowEstTimeOfArrival)\n                cmdText.Append(\" /ETA\");\n            if (ShowDebugVolumeInfo)\n                cmdText.Append(\" /DEBUG\");\n            if (!OutputLogFilePath.IsNullOrWhiteSpace())\n                cmdText.AppendFormat(\" /LOG:\\\"{0}\\\"\", OutputLogFilePath);\n            if (!AppendOutputLogFilePath.IsNullOrWhiteSpace())\n                cmdText.AppendFormat(\" /LOG+:\\\"{0}\\\"\", AppendOutputLogFilePath);\n            if (!UnicodeOutputLogFilePath.IsNullOrWhiteSpace())\n                cmdText.AppendFormat(\" /UNILOG:\\\"{0}\\\"\", UnicodeOutputLogFilePath);\n            if (!AppendUnicodeOutputLogFilePath.IsNullOrWhiteSpace())\n                cmdText.AppendFormat(\" /UNILOG+:\\\"{0}\\\"\", AppendUnicodeOutputLogFilePath);\n            if (NoJobHeader)\n                cmdText.Append(\" /NJH\");\n            if (NoJobSummary)\n                cmdText.Append(\" /NJS\");\n\n            if (!AdditionalParams.IsNullOrWhiteSpace())\n                cmdText.AppendFormat(\" {0}\", AdditionalParams);\n\n            return cmdText.ToString();\n        }\n\n        //TODO\n        //protected override void OnAfterConfigurationObjectLoaded()\n        //{\n        //    if (RoboCopyFilePath.IsNullOrWhiteSpace())\n        //        RoboCopyFilePath = \"RoboCopy.exe\";\n        //}\n\n        public void Persist()\n        {\n\n        }\n\n        //public string GetXml()\n        //{\n        //    StringBuilder xml = new StringBuilder();\n        //    using (StringWriter w = new StringWriter(xml))\n        //    {\n        //        _xmlSerializer.Serialize(w, this);\n        //        return xml.ToString();\n        //    }\n        //}\n\n        public void LoadXml(string xml)\n        {\n            using (StringReader reader = new StringReader(xml))\n            {\n                var appSettings = _xmlSerializer.Deserialize(reader) as ChoAppSettings;\n                Copy(appSettings, this);\n            }\n        }\n\n        public static void Copy(ChoAppSettings src, ChoAppSettings dest)\n        {\n            if (src == null || dest == null)\n                return;\n\n            foreach (var pi in _propInfos.Values)\n            {\n                SetPropertyValue(dest, pi, ChoType.GetPropertyValue(src, pi));\n            }\n        }\n        private static readonly Dictionary<IntPtr, Action<object, object>> _setterCache = new Dictionary<IntPtr, Action<object, object>>();\n        private static readonly object _padLock = new object();\n        public static void SetPropertyValue(object target, PropertyInfo propertyInfo, object val)\n        {\n            ChoGuard.ArgumentNotNull(target, \"Target\");\n            ChoGuard.ArgumentNotNull(propertyInfo, \"PropertyInfo\");\n\n            if ((val == null || (val is string && ((string)val).IsEmpty())) && propertyInfo.PropertyType.IsValueType)\n            {\n                if (propertyInfo.PropertyType.IsNullableType())\n                    val = null;\n                else\n                    val = propertyInfo.PropertyType.Default();\n            }\n\n            try\n            {\n                Action<object, object> setter;\n                var mi = propertyInfo.GetSetMethod();\n                if (mi != null)\n                {\n                    var key = mi.MethodHandle.Value;\n                    if (!_setterCache.TryGetValue(key, out setter))\n                    {\n                        lock (_padLock)\n                        {\n                            if (!_setterCache.TryGetValue(key, out setter))\n                                _setterCache.Add(key, setter = propertyInfo.CreateSetMethod());\n                        }\n                    }\n\n                    setter(target, val);\n                }\n            }\n            catch (TargetInvocationException ex)\n            {\n                throw new TargetInvocationException(String.Format(\"[Object: {0}, Member: {1}]:\", target.GetType().FullName, propertyInfo.Name), ex.InnerException);\n            }\n        }\n\n        public ChoAppSettings Clone()\n        {\n            var obj = new ChoAppSettings();\n            Copy(this, obj);\n            return obj;\n        }\n\n        object ICloneable.Clone()\n        {\n            return Clone();\n        }\n    }\n}\n"
        },
        {
          "name": "ChoAppTheme.cs",
          "type": "blob",
          "size": 4.6064453125,
          "content": "﻿using MahApps.Metro;\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Linq;\nusing System.Runtime.CompilerServices;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows;\nusing System.Windows.Media;\n\nnamespace ChoEazyCopy\n{\n    public class ChoAppTheme : INotifyPropertyChanged\n    {\n        public static readonly ChoAppTheme Instance = new ChoAppTheme();\n\n        private Accent _accent = ThemeManager.GetAccent(\"Blue\");\n        private AppTheme _appTheme = ThemeManager.GetAppTheme(\"BaseDark\");\n        private bool _isDarkMode = false;\n\n        public event PropertyChangedEventHandler PropertyChanged;\n\n        public void Refresh(Accent accent, AppTheme appTheme, bool isDarkMode)\n        {\n            _accent = accent;\n            _appTheme = appTheme;\n            _isDarkMode = isDarkMode;\n\n            RaisePropertyChanged(nameof(ControlBackgroundBrush));\n            RaisePropertyChanged(nameof(ControlForegroundBrush));\n        }\n\n        private void RaisePropertyChanged([CallerMemberName] string propertyName = null)\n        {\n            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));\n        }\n\n        public Brush TextBoxFocusBorderBrush\n        {\n            get\n            {\n                return (Brush)_appTheme.Resources[\"TextBoxFocusBorderBrush\"];\n            }\n        }\n\n        public Brush ControlMouseOverBackgroundBrush\n        {\n            get\n            {\n                return (Brush)_appTheme.Resources[\"GrayHoverBrush\"];\n            }\n        }\n\n        public Brush ControlBackgroundBrush\n        {\n            get\n            {\n                if (_isDarkMode)\n                    return (Brush)_appTheme.Resources[\"BlackBrush\"];\n                else\n                    return (Brush)_appTheme.Resources[\"WhiteBrush\"];\n            }\n        }\n\n        public Brush ControlForegroundBrush\n        {\n            get\n            {\n                if (_isDarkMode)\n                    return new SolidColorBrush(Colors.White);\n                else\n                    return new SolidColorBrush(Colors.Black);\n                if (!_isDarkMode)\n                    return (Brush)_appTheme.Resources[\"BlackBrush\"];\n                else\n                    return (Brush)_appTheme.Resources[\"WhiteBrush\"];\n            }\n        }\n\n        public Brush PGControlBackgroundBrush\n        {\n            get\n            {\n                //if (_isDarkMode)\n                //    return (Brush)_appTheme.Resources[\"WhiteBrush\"];\n                //else\n                return System.Windows.SystemColors.ControlLightBrush;\n            }\n        }\n\n        public Brush PGControlForegroundBrush\n        {\n            get\n            {\n                if (_isDarkMode)\n                    return (Brush)_appTheme.Resources[\"WhiteBrush\"];\n                else\n                    return (Brush)_appTheme.Resources[\"BlackBrush\"];\n            }\n        }\n\n        public Brush PGControlBorderBrush\n        {\n            get\n            {\n                return (Brush)_appTheme.Resources[\"ControlBorderBrush\"];\n            }\n        }\n\n        public Brush ControlBorderBrush\n        {\n            get\n            {\n                return (Brush)_appTheme.Resources[\"ControlBorderBrush\"];\n            }\n        }\n\n        public Brush WindowTitleColorBrush\n        {\n            get\n            {\n                return (Brush)_appTheme.Resources[\"WindowTitleColorBrush\"];\n            }\n        }\n\n        public Brush ThemeForegroundBrush\n        {\n            get\n            {\n                return (Brush)_appTheme.Resources[\"BlackBrush\"];\n            }\n        }\n\n        public Brush ThemeBackgroundBrush\n        {\n            get\n            {\n                return (Brush)_accent.Resources[\"AccentColorBrush\"];\n            }\n        }\n\n        public Brush WindowTitleBrush\n        {\n            get\n            {\n                return (Brush)_appTheme.Resources[\"WindowTitleColorBrush\"];\n            }\n        }\n        public Brush MouseOverBrush\n        {\n            get\n            {\n                return (Brush)_appTheme.Resources[\"ButtonMouseOverBorderBrush\"];\n            }\n        }\n\n        public Brush TabControlBackgroundBrush\n        {\n            get\n            {\n                return (Brush)_accent.Resources[\"AccentColorBrush\"];\n            }\n        }\n\n        public Brush TabControlForegroundBrush\n        {\n            get\n            {\n                //if (!_isDarkMode)\n                //    return (Brush)_appTheme.Resources[\"BlackBrush\"];\n                //else\n                    return (Brush)_appTheme.Resources[\"WhiteBrush\"];\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "ChoApplicationThemeManager.cs",
          "type": "blob",
          "size": 1.162109375,
          "content": "﻿using MahApps.Metro;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows;\n\nnamespace ChoEazyCopy\n{\n    public static class ChoApplicationThemeManager\n    {\n        static ChoApplicationThemeManager()\n        {\n            _theme = \"BaseLight\";\n            _accent = \"Steel\";\n        }\n        private static string _theme;\n        public static string Theme\n        {\n            get { return _theme; }\n            set\n            {\n                _theme = value;\n                ApplyTheme();\n            }\n        }\n        private static string _accent;\n        public static string Accent\n        {\n            get { return _accent; }\n            set\n            {\n                _accent = value;\n                ApplyTheme();\n            }\n        }\n\n        public static void ApplyTheme()\n        {\n            MainWindow wnd = Application.Current.MainWindow as MainWindow;\n\n            ThemeManager.ChangeAppStyle(wnd,\n                            ThemeManager.GetAccent(Accent),\n                            ThemeManager.GetAppTheme(Theme));\n            wnd.RefreshWindow();\n        }\n    }\n}\n"
        },
        {
          "name": "ChoAssemblyBetaVersionAttribute.cs",
          "type": "blob",
          "size": 0.4501953125,
          "content": "﻿using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ChoEazyCopy\n{\n    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = false, Inherited = true)]\n    public class ChoAssemblyBetaVersionAttribute : Attribute\n    {\n        public string Version { get; set; }\n        public ChoAssemblyBetaVersionAttribute(string text)\n        {\n            Version = text;\n        }\n    }\n\n}\n"
        },
        {
          "name": "ChoBackupTaskInfo.cs",
          "type": "blob",
          "size": 0.7841796875,
          "content": "﻿using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ChoEazyCopy\n{\n    public class ChoBackupTaskInfo\n    {\n        public string TaskName { get; set; }\n        public string FileName { get; set; }\n        public string FilePath { get; set; }\n        public DateTime CreatedDate { get; set; }\n        public DateTime ModifiedDate { get; set; }\n\n        public ChoBackupTaskInfo(string filePath)\n        {\n            var fi = new FileInfo(filePath);\n\n            TaskName = Path.GetFileNameWithoutExtension(filePath);\n            FilePath = filePath;\n            FileName = Path.GetFileName(filePath);\n            CreatedDate = fi.CreationTime;\n            ModifiedDate = fi.LastWriteTime;\n        }\n    }\n\n}\n"
        },
        {
          "name": "ChoEazyCopy.csproj",
          "type": "blob",
          "size": 14.5439453125,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project ToolsVersion=\"12.0\" DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <Import Project=\"$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.Common.props\" Condition=\"Exists('$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.Common.props')\" />\n  <PropertyGroup>\n    <Configuration Condition=\" '$(Configuration)' == '' \">Debug</Configuration>\n    <Platform Condition=\" '$(Platform)' == '' \">AnyCPU</Platform>\n    <ProjectGuid>{1C308884-EEE4-4156-812A-A83EA79C50C8}</ProjectGuid>\n    <OutputType>Exe</OutputType>\n    <AppDesignerFolder>Properties</AppDesignerFolder>\n    <RootNamespace>ChoEazyCopy</RootNamespace>\n    <AssemblyName>ChoEazyCopy</AssemblyName>\n    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>\n    <FileAlignment>512</FileAlignment>\n    <ProjectTypeGuids>{60dc8134-eba5-43b8-bcc9-bb4bc16c2548};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>\n    <WarningLevel>4</WarningLevel>\n    <TargetFrameworkProfile />\n    <IsWebBootstrapper>false</IsWebBootstrapper>\n    <NuGetPackageImportStamp>\n    </NuGetPackageImportStamp>\n    <PublishUrl>publish\\</PublishUrl>\n    <Install>true</Install>\n    <InstallFrom>Disk</InstallFrom>\n    <UpdateEnabled>true</UpdateEnabled>\n    <UpdateMode>Foreground</UpdateMode>\n    <UpdateInterval>7</UpdateInterval>\n    <UpdateIntervalUnits>Days</UpdateIntervalUnits>\n    <UpdatePeriodically>false</UpdatePeriodically>\n    <UpdateRequired>false</UpdateRequired>\n    <MapFileExtensions>true</MapFileExtensions>\n    <UpdateUrl>https://choeazycopy.codeplex.com/releases/clickonce/</UpdateUrl>\n    <SupportUrl>http://www.cinchoo.com</SupportUrl>\n    <ErrorReportUrl>http://www.cinchoo.com</ErrorReportUrl>\n    <ProductName>ChoEasyCopy</ProductName>\n    <PublisherName>Cinchoo Inc</PublisherName>\n    <SuiteName>ChoEazyCopy</SuiteName>\n    <ApplicationRevision>17</ApplicationRevision>\n    <ApplicationVersion>1.0.0.17</ApplicationVersion>\n    <UseApplicationTrust>false</UseApplicationTrust>\n    <PublishWizardCompleted>true</PublishWizardCompleted>\n    <BootstrapperEnabled>true</BootstrapperEnabled>\n  </PropertyGroup>\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' \">\n    <PlatformTarget>AnyCPU</PlatformTarget>\n    <DebugSymbols>true</DebugSymbols>\n    <DebugType>full</DebugType>\n    <Optimize>false</Optimize>\n    <OutputPath>bin\\Debug\\</OutputPath>\n    <DefineConstants>TRACE;DEBUG;_DELAY_RUN_1, _TEST_MODE</DefineConstants>\n    <ErrorReport>prompt</ErrorReport>\n    <WarningLevel>4</WarningLevel>\n    <UseVSHostingProcess>false</UseVSHostingProcess>\n    <Prefer32Bit>false</Prefer32Bit>\n  </PropertyGroup>\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' \">\n    <PlatformTarget>AnyCPU</PlatformTarget>\n    <DebugType>none</DebugType>\n    <Optimize>true</Optimize>\n    <OutputPath>bin\\Release\\</OutputPath>\n    <DefineConstants>TRACE</DefineConstants>\n    <ErrorReport>prompt</ErrorReport>\n    <WarningLevel>4</WarningLevel>\n    <UseVSHostingProcess>false</UseVSHostingProcess>\n    <Prefer32Bit>false</Prefer32Bit>\n  </PropertyGroup>\n  <PropertyGroup>\n    <ApplicationIcon>App.ico</ApplicationIcon>\n  </PropertyGroup>\n  <PropertyGroup>\n    <StartupObject />\n  </PropertyGroup>\n  <PropertyGroup>\n    <ManifestCertificateThumbprint>657F697FB207CCAA0A24AB7FA09D8323949DA568</ManifestCertificateThumbprint>\n  </PropertyGroup>\n  <PropertyGroup>\n    <ManifestKeyFile>ChoEazyCopy_TemporaryKey.pfx</ManifestKeyFile>\n  </PropertyGroup>\n  <PropertyGroup>\n    <GenerateManifests>false</GenerateManifests>\n  </PropertyGroup>\n  <PropertyGroup>\n    <SignManifests>true</SignManifests>\n  </PropertyGroup>\n  <PropertyGroup>\n    <TargetZone>LocalIntranet</TargetZone>\n  </PropertyGroup>\n  <PropertyGroup />\n  <ItemGroup>\n    <Reference Include=\"Cinchoo.Core, Version=1.0.9.5, Culture=neutral, PublicKeyToken=b7dacd80ff3e33de, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>Lib\\Cinchoo.Core.dll</HintPath>\n    </Reference>\n    <Reference Include=\"ICSharpCode.AvalonEdit\">\n      <HintPath>Lib\\ICSharpCode.AvalonEdit.dll</HintPath>\n      <Private>False</Private>\n    </Reference>\n    <Reference Include=\"MahApps.Metro, Version=1.1.2.0, Culture=neutral, PublicKeyToken=f4fb5a3c4d1e5b4f, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>Lib\\MahApps.Metro.dll</HintPath>\n      <Private>False</Private>\n    </Reference>\n    <Reference Include=\"MahApps.Metro.IconPacks.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>Lib\\MahApps.Metro.IconPacks.Core.dll</HintPath>\n      <Private>False</Private>\n    </Reference>\n    <Reference Include=\"MahApps.Metro.IconPacks.FontAwesome, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>Lib\\MahApps.Metro.IconPacks.FontAwesome.dll</HintPath>\n      <Private>False</Private>\n    </Reference>\n    <Reference Include=\"Microsoft.WindowsAPICodePack\">\n      <HintPath>Lib\\Microsoft.WindowsAPICodePack.dll</HintPath>\n      <Private>False</Private>\n    </Reference>\n    <Reference Include=\"Microsoft.WindowsAPICodePack.Shell\">\n      <HintPath>Lib\\Microsoft.WindowsAPICodePack.Shell.dll</HintPath>\n      <Private>False</Private>\n    </Reference>\n    <Reference Include=\"SoftFluent.Windows, Version=1.0.0.0, Culture=neutral, PublicKeyToken=02a67131d2a99c25, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>Lib\\SoftFluent.Windows.dll</HintPath>\n      <Private>False</Private>\n    </Reference>\n    <Reference Include=\"System\" />\n    <Reference Include=\"System.Activities.Presentation\" />\n    <Reference Include=\"System.Configuration\" />\n    <Reference Include=\"System.Configuration.Install\" />\n    <Reference Include=\"System.Data\" />\n    <Reference Include=\"System.Drawing\" />\n    <Reference Include=\"System.Management\" />\n    <Reference Include=\"System.ServiceProcess\" />\n    <Reference Include=\"System.Windows.Controls.Ribbon\" />\n    <Reference Include=\"System.Windows.Forms\" />\n    <Reference Include=\"System.Windows.Interactivity, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>Lib\\System.Windows.Interactivity.dll</HintPath>\n      <Private>False</Private>\n    </Reference>\n    <Reference Include=\"System.Xml\" />\n    <Reference Include=\"Microsoft.CSharp\" />\n    <Reference Include=\"System.Core\" />\n    <Reference Include=\"System.Xml.Linq\" />\n    <Reference Include=\"System.Data.DataSetExtensions\" />\n    <Reference Include=\"System.Xaml\">\n      <RequiredTargetFramework>4.0</RequiredTargetFramework>\n    </Reference>\n    <Reference Include=\"WindowsBase\" />\n    <Reference Include=\"PresentationCore\" />\n    <Reference Include=\"PresentationFramework\" />\n  </ItemGroup>\n  <ItemGroup>\n    <Page Include=\"App.xaml\">\n      <Generator>MSBuild:Compile</Generator>\n      <SubType>Designer</SubType>\n    </Page>\n    <Page Include=\"ChoSystemColorsWindow.xaml\">\n      <SubType>Designer</SubType>\n      <Generator>MSBuild:Compile</Generator>\n    </Page>\n    <Page Include=\"MainWindow.xaml\">\n      <Generator>MSBuild:Compile</Generator>\n      <SubType>Designer</SubType>\n    </Page>\n    <Compile Include=\"App.xaml.cs\">\n      <DependentUpon>App.xaml</DependentUpon>\n      <SubType>Code</SubType>\n    </Compile>\n    <Compile Include=\"ChoAppCmdLineArgs.cs\" />\n    <Compile Include=\"ChoAppSettings.cs\" />\n    <Compile Include=\"ChoAppTheme.cs\" />\n    <Compile Include=\"ChoRoboCopyManager.cs\" />\n    <Compile Include=\"ChoSystemColorsWindow.xaml.cs\">\n      <DependentUpon>ChoSystemColorsWindow.xaml</DependentUpon>\n    </Compile>\n    <Compile Include=\"ChoTaskQueueItem.cs\" />\n    <Compile Include=\"ChoUserPreferences.cs\" />\n    <Compile Include=\"ChoGridViewColumnVisibilityManager.cs\" />\n    <Compile Include=\"ChoGridViewSort.cs\" />\n    <Compile Include=\"ChoSortAdorner.cs\" />\n    <Compile Include=\"ChoTaskQManager.cs\" />\n    <Compile Include=\"ChoUtility.cs\" />\n    <Compile Include=\"ChoObservableCollection.cs\" />\n    <Compile Include=\"ChoTaskQueueItemLogInfo.cs\" />\n    <Compile Include=\"ChoAssemblyBetaVersionAttribute.cs\" />\n    <Compile Include=\"ChoFileSizeFormatter.cs\" />\n    <Compile Include=\"ChoApplicationThemeManager.cs\" />\n    <Compile Include=\"ChoValueConverters.cs\" />\n    <Compile Include=\"ChoBackupTaskInfo.cs\" />\n    <Compile Include=\"Controls\\ChoPropertyGrid.cs\" />\n    <Compile Include=\"Controls\\ChoMaskedTextBox.cs\" />\n    <Compile Include=\"Controls\\WpfPropertyGrid.cs\" />\n    <Compile Include=\"MainWindow.xaml.cs\">\n      <DependentUpon>MainWindow.xaml</DependentUpon>\n      <SubType>Code</SubType>\n    </Compile>\n  </ItemGroup>\n  <ItemGroup>\n    <Compile Include=\"ChoMruComboBox.cs\" />\n    <Compile Include=\"ChoObservableMruList.cs\" />\n    <Compile Include=\"Properties\\AssemblyInfo.cs\">\n      <SubType>Code</SubType>\n    </Compile>\n    <Compile Include=\"Properties\\Resources.Designer.cs\">\n      <AutoGen>True</AutoGen>\n      <DesignTime>True</DesignTime>\n      <DependentUpon>Resources.resx</DependentUpon>\n    </Compile>\n    <Compile Include=\"Properties\\Settings.Designer.cs\">\n      <AutoGen>True</AutoGen>\n      <DependentUpon>Settings.settings</DependentUpon>\n      <DesignTimeSharedInput>True</DesignTimeSharedInput>\n    </Compile>\n    <EmbeddedResource Include=\"Properties\\Resources.resx\">\n      <Generator>ResXFileCodeGenerator</Generator>\n      <LastGenOutput>Resources.Designer.cs</LastGenOutput>\n    </EmbeddedResource>\n    <EmbeddedResource Include=\"Resources\\Registry.png\" />\n    <None Include=\"ChoEazyCopy_TemporaryKey.pfx\" />\n    <None Include=\"Properties\\Settings.settings\">\n      <Generator>SettingsSingleFileGenerator</Generator>\n      <LastGenOutput>Settings.Designer.cs</LastGenOutput>\n    </None>\n    <AppDesigner Include=\"Properties\\\" />\n  </ItemGroup>\n  <ItemGroup>\n    <None Include=\"App.config\" />\n  </ItemGroup>\n  <ItemGroup>\n    <Resource Include=\"App.ico\" />\n  </ItemGroup>\n  <ItemGroup>\n    <Resource Include=\"Resources\\AddFile.png\" />\n    <Resource Include=\"Resources\\Erase.png\" />\n    <Resource Include=\"Resources\\NewFile.png\" />\n    <Resource Include=\"Resources\\OpenFile.png\" />\n    <Resource Include=\"Resources\\OpenFolder.png\" />\n    <EmbeddedResource Include=\"Resources\\OpenNewWindow.png\" />\n    <Resource Include=\"Resources\\SaveAsFile.png\" />\n    <Resource Include=\"Resources\\SaveFile.png\" />\n    <Resource Include=\"Resources\\Stop.png\" />\n  </ItemGroup>\n  <ItemGroup>\n    <Resource Include=\"Resources\\Copy.png\" />\n    <Resource Include=\"Resources\\Cut.png\" />\n    <Resource Include=\"Resources\\Paste.png\" />\n  </ItemGroup>\n  <ItemGroup>\n    <EmbeddedResource Include=\"Lib\\Cinchoo.Core.dll\" />\n    <Resource Include=\"Resources\\OpenFolder1.png\" />\n    <Resource Include=\"Resources\\Refresh.png\" />\n    <Resource Include=\"Resources\\help.png\" />\n    <EmbeddedResource Include=\"Lib\\ICSharpCode.AvalonEdit.dll\" />\n    <Resource Include=\"Resources\\Run.png\" />\n    <Resource Include=\"Resources\\Donate.png\" />\n    <EmbeddedResource Include=\"Resources\\RemoveRegistry.png\" />\n    <EmbeddedResource Include=\"Resources\\Security.png\" />\n    <Resource Include=\"Resources\\Scroll.png\" />\n    <EmbeddedResource Include=\"Lib\\System.Windows.Interactivity.dll\" />\n    <EmbeddedResource Include=\"Lib\\MahApps.Metro.dll\" />\n  </ItemGroup>\n  <ItemGroup>\n    <BootstrapperPackage Include=\".NETFramework,Version=v4.0\">\n      <Visible>False</Visible>\n      <ProductName>Microsoft .NET Framework 4 %28x86 and x64%29</ProductName>\n      <Install>true</Install>\n    </BootstrapperPackage>\n    <BootstrapperPackage Include=\"Microsoft.Net.Client.3.5\">\n      <Visible>False</Visible>\n      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>\n      <Install>false</Install>\n    </BootstrapperPackage>\n    <BootstrapperPackage Include=\"Microsoft.Net.Framework.3.5.SP1\">\n      <Visible>False</Visible>\n      <ProductName>.NET Framework 3.5 SP1</ProductName>\n      <Install>false</Install>\n    </BootstrapperPackage>\n    <BootstrapperPackage Include=\"Microsoft.Windows.Installer.4.5\">\n      <Visible>False</Visible>\n      <ProductName>Windows Installer 4.5</ProductName>\n      <Install>true</Install>\n    </BootstrapperPackage>\n  </ItemGroup>\n  <ItemGroup>\n    <PublishFile Include=\"Lib\\Cinchoo.Core.dll\">\n      <Visible>False</Visible>\n      <Group>\n      </Group>\n      <TargetPath>\n      </TargetPath>\n      <PublishState>Exclude</PublishState>\n      <IncludeHash>True</IncludeHash>\n      <FileType>File</FileType>\n    </PublishFile>\n    <PublishFile Include=\"MahApps.Metro\">\n      <Visible>False</Visible>\n      <Group>\n      </Group>\n      <TargetPath>\n      </TargetPath>\n      <PublishState>Include</PublishState>\n      <IncludeHash>True</IncludeHash>\n      <FileType>Assembly</FileType>\n    </PublishFile>\n    <PublishFile Include=\"System.Windows.Interactivity\">\n      <Visible>False</Visible>\n      <Group>\n      </Group>\n      <TargetPath>\n      </TargetPath>\n      <PublishState>Include</PublishState>\n      <IncludeHash>True</IncludeHash>\n      <FileType>Assembly</FileType>\n    </PublishFile>\n    <PublishFile Include=\"Xceed.Wpf.Toolkit\">\n      <Visible>False</Visible>\n      <Group>\n      </Group>\n      <TargetPath>\n      </TargetPath>\n      <PublishState>Include</PublishState>\n      <IncludeHash>True</IncludeHash>\n      <FileType>Assembly</FileType>\n    </PublishFile>\n  </ItemGroup>\n  <ItemGroup>\n    <EmbeddedResource Include=\"Lib\\MahApps.Metro.IconPacks.Core.dll\" />\n    <EmbeddedResource Include=\"Lib\\MahApps.Metro.IconPacks.FontAwesome.dll\" />\n  </ItemGroup>\n  <ItemGroup>\n    <Resource Include=\"Resources\\SyncJob.png\" />\n  </ItemGroup>\n  <ItemGroup>\n    <Resource Include=\"Resources\\CopyJob.png\" />\n  </ItemGroup>\n  <ItemGroup>\n    <Resource Include=\"Resources\\MoveJob.png\" />\n  </ItemGroup>\n  <ItemGroup>\n    <WCFMetadata Include=\"Connected Services\\\" />\n  </ItemGroup>\n  <ItemGroup>\n    <EmbeddedResource Include=\"Lib\\MahApps.Metro.IconPacks.BootstrapIcons.dll\" />\n  </ItemGroup>\n  <ItemGroup>\n    <Resource Include=\"Resources\\Search.png\" />\n  </ItemGroup>\n  <ItemGroup>\n    <EmbeddedResource Include=\"Lib\\SoftFluent.Windows.dll\" />\n  </ItemGroup>\n  <ItemGroup>\n    <EmbeddedResource Include=\"Lib\\Microsoft.WindowsAPICodePack.dll\" />\n    <EmbeddedResource Include=\"Lib\\Microsoft.WindowsAPICodePack.Shell.dll\" />\n  </ItemGroup>\n  <Import Project=\"$(MSBuildToolsPath)\\Microsoft.CSharp.targets\" />\n  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. \n       Other similar extension points exist, see Microsoft.Common.targets.\n  <Target Name=\"BeforeBuild\">\n  </Target>\n  <Target Name=\"AfterBuild\">\n  </Target>\n  -->\n</Project>"
        },
        {
          "name": "ChoEazyCopy.sln",
          "type": "blob",
          "size": 1.076171875,
          "content": "﻿\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio Version 16\nVisualStudioVersion = 16.0.31911.196\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"ChoEazyCopy\", \"ChoEazyCopy.csproj\", \"{1C308884-EEE4-4156-812A-A83EA79C50C8}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|Any CPU = Debug|Any CPU\n\t\tRelease|Any CPU = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{1C308884-EEE4-4156-812A-A83EA79C50C8}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{1C308884-EEE4-4156-812A-A83EA79C50C8}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{1C308884-EEE4-4156-812A-A83EA79C50C8}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{1C308884-EEE4-4156-812A-A83EA79C50C8}.Release|Any CPU.Build.0 = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {BCB980A2-9C9E-486E-A17B-97EA0B28F8DE}\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "ChoEazyCopy_TemporaryKey.pfx",
          "type": "blob",
          "size": 1.62890625,
          "content": null
        },
        {
          "name": "ChoFileSizeFormatter.cs",
          "type": "blob",
          "size": 0.6416015625,
          "content": "﻿using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ChoEazyCopy\n{\n    public static class ChoFileSizeFormatter\n    {\n        static readonly string[] suffixes = { \"Bytes\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\" };\n        public static string FormatSize(Int64 bytes)\n        {\n            int counter = 0;\n            decimal number = (decimal)bytes;\n            while (Math.Round(number / 1024) >= 1)\n            {\n                number = number / 1024;\n                counter++;\n            }\n            return string.Format(\"{0:n1}{1}\", number, suffixes[counter]);\n        }\n    }\n}\n"
        },
        {
          "name": "ChoGridViewColumnVisibilityManager.cs",
          "type": "blob",
          "size": 6.0595703125,
          "content": "﻿using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows;\nusing System.Windows.Controls;\n\nnamespace ChoEazyCopy\n{\n    public class ChoGridViewColumnVisibilityManager\n    {\n        private static Dictionary<GridView, Dictionary<GridViewColumn, double>> _columns = null;\n\n        public static void ResizeAllColumnsToFit(DependencyObject obj)\n        {\n            ListView lv = obj as ListView;\n            if (lv == null) return;\n\n            GridView gridview = lv.View as GridView;\n            if (gridview == null || gridview.Columns == null) return;\n\n            var columns = _columns;\n            if (columns == null || !_columns.ContainsKey(gridview))\n                return;\n            if (_columns[gridview] == null)\n                return;\n\n            foreach (GridViewColumn gc in _columns[gridview].Keys.ToArray())\n            {\n                gc.Width = 0;\n                gc.Width = Double.NaN;\n                columns[gridview][gc] = gc.Width;\n            }\n\n        }\n        public static bool Contains(GridViewColumn col)\n        {\n            Dictionary<GridViewColumn, double> dict = null;\n            return Contains(col, out dict);\n        }\n\n        public static bool Contains(GridViewColumn col, out Dictionary<GridViewColumn, double> dict)\n        {\n            dict = null;\n            if (col == null)\n                return false;\n            if (_columns == null)\n                return false;\n\n            foreach (var gv in _columns.Keys.ToArray())\n            {\n                if (_columns[gv].ContainsKey(col))\n                {\n                    dict = _columns[gv];\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        public static void SetGridColumnWidth(GridViewColumnHeader colHeader)\n        {\n            SetGridColumnWidth(colHeader.Column);\n        }\n\n        public static void SetGridColumnWidth(GridViewColumn col)\n        {\n            Dictionary<GridViewColumn, double> dict = null;\n            if (Contains(col, out dict) && (col.Width > 0 || col.Width == double.NaN))\n                dict[col] = col.Width;\n        }\n\n        static void UpdateListView(ListView lv)\n        {\n            GridView gridview = lv.View as GridView;\n            if (gridview == null || gridview.Columns == null) return;\n\n            if (_columns == null)\n                _columns = new Dictionary<GridView, Dictionary<GridViewColumn, double>>();\n\n            if (!_columns.ContainsKey(gridview))\n            {\n                _columns.Add(gridview, new Dictionary<GridViewColumn, double>());\n                foreach (GridViewColumn gc in gridview.Columns)\n                    _columns[gridview].Add(gc, gc.Width);\n            }\n\n            List<GridViewColumn> toRemove = new List<GridViewColumn>();\n            foreach (GridViewColumn gc in gridview.Columns)\n            {\n                if (!GetIsVisible(gc))\n                {\n                    gc.Width = 0;\n                    ((GridViewColumnHeader)gc.Header).IsHitTestVisible = false;\n                }\n                else\n                {\n                    Dictionary<GridViewColumn, double> dict = null;\n                    if (Contains(gc, out dict))\n                    {\n                        gc.Width = dict[gc];\n                        ((GridViewColumnHeader)gc.Header).IsHitTestVisible = true;\n                    }\n                }\n            }\n        }\n\n        public static bool GetIsVisible(DependencyObject obj)\n        {\n            return (bool)obj.GetValue(IsVisibleProperty);\n        }\n\n        public static void SetIsVisible(DependencyObject obj, bool value)\n        {\n            obj.SetValue(IsVisibleProperty, value);\n        }\n\n        public static readonly DependencyProperty IsVisibleProperty =\n            DependencyProperty.RegisterAttached(\"IsVisible\", typeof(bool), typeof(ChoGridViewColumnVisibilityManager), new UIPropertyMetadata(true, OnIsVisibleChanged));\n\n\n        public static bool GetEnabled(DependencyObject obj)\n        {\n            return (bool)obj.GetValue(EnabledProperty);\n        }\n\n        public static void SetEnabled(DependencyObject obj, bool value)\n        {\n            obj.SetValue(EnabledProperty, value);\n        }\n\n        public static readonly DependencyProperty EnabledProperty =\n            DependencyProperty.RegisterAttached(\"Enabled\", typeof(bool), typeof(ChoGridViewColumnVisibilityManager), new UIPropertyMetadata(false,\n                new PropertyChangedCallback(OnEnabledChanged)));\n\n        private static void OnIsVisibleChanged(DependencyObject obj, DependencyPropertyChangedEventArgs e)\n        {\n            GridViewColumn gc = obj as GridViewColumn;\n            if (gc != null)\n            {\n                if (!GetIsVisible(gc))\n                {\n                    gc.Width = 0;\n                    ((GridViewColumnHeader)gc.Header).IsHitTestVisible = false;\n                }\n                else\n                {\n                    Dictionary<GridViewColumn, double> dict = null;\n                    if (Contains(gc, out dict))\n                    {\n                        gc.Width = dict[gc];\n                        ((GridViewColumnHeader)gc.Header).IsHitTestVisible = true;\n                    }\n                }\n            }\n        }\n        private static void OnEnabledChanged(DependencyObject obj, DependencyPropertyChangedEventArgs e)\n        {\n            ListView view = obj as ListView;\n            if (view != null)\n            {\n                bool enabled = (bool)e.NewValue;\n                if (enabled)\n                {\n                    view.Loaded += (sender, e2) =>\n                    {\n                        UpdateListView((ListView)sender);\n                    };\n                    view.TargetUpdated += (sender, e2) =>\n                    {\n                        UpdateListView((ListView)sender);\n                    };\n                    view.DataContextChanged += (sender, e2) =>\n                    {\n                        UpdateListView((ListView)sender);\n                    };\n                }\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "ChoGridViewSort.cs",
          "type": "blob",
          "size": 7.0205078125,
          "content": "﻿using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Input;\nusing System.Windows.Media;\n\nnamespace ChoEazyCopy\n{\n    public class ChoGridViewSort\n    {\n        #region Attached properties\n\n        public static ICommand GetCommand(DependencyObject obj)\n        {\n            return (ICommand)obj.GetValue(CommandProperty);\n        }\n\n        public static void SetCommand(DependencyObject obj, ICommand value)\n        {\n            obj.SetValue(CommandProperty, value);\n        }\n\n        // Using a DependencyProperty as the backing store for Command.  This enables animation, styling, binding, etc...\n        public static readonly DependencyProperty CommandProperty =\n            DependencyProperty.RegisterAttached(\n                \"Command\",\n                typeof(ICommand),\n                typeof(ChoGridViewSort),\n                new UIPropertyMetadata(\n                    null,\n                    (o, e) =>\n                    {\n                        ItemsControl listView = o as ItemsControl;\n                        if (listView != null)\n                        {\n                            if (!GetAutoSort(listView)) // Don't change click handler if AutoSort enabled\n                            {\n                                if (e.OldValue != null && e.NewValue == null)\n                                {\n                                    listView.RemoveHandler(GridViewColumnHeader.ClickEvent, new RoutedEventHandler(ColumnHeader_Click));\n                                }\n                                if (e.OldValue == null && e.NewValue != null)\n                                {\n                                    listView.AddHandler(GridViewColumnHeader.ClickEvent, new RoutedEventHandler(ColumnHeader_Click));\n                                }\n                            }\n                        }\n                    }\n                )\n            );\n\n        public static bool GetAutoSort(DependencyObject obj)\n        {\n            return (bool)obj.GetValue(AutoSortProperty);\n        }\n\n        public static void SetAutoSort(DependencyObject obj, bool value)\n        {\n            obj.SetValue(AutoSortProperty, value);\n        }\n\n        // Using a DependencyProperty as the backing store for AutoSort.  This enables animation, styling, binding, etc...\n        public static readonly DependencyProperty AutoSortProperty =\n            DependencyProperty.RegisterAttached(\n                \"AutoSort\",\n                typeof(bool),\n                typeof(ChoGridViewSort),\n                new UIPropertyMetadata(\n                    false,\n                    (o, e) =>\n                    {\n                        ListView listView = o as ListView;\n                        if (listView != null)\n                        {\n                            if (GetCommand(listView) == null) // Don't change click handler if a command is set\n                            {\n                                bool oldValue = (bool)e.OldValue;\n                                bool newValue = (bool)e.NewValue;\n                                if (oldValue && !newValue)\n                                {\n                                    listView.RemoveHandler(GridViewColumnHeader.ClickEvent, new RoutedEventHandler(ColumnHeader_Click));\n                                }\n                                if (!oldValue && newValue)\n                                {\n                                    listView.AddHandler(GridViewColumnHeader.ClickEvent, new RoutedEventHandler(ColumnHeader_Click));\n                                }\n                            }\n                        }\n                    }\n                )\n            );\n\n        public static string GetPropertyName(DependencyObject obj)\n        {\n            return obj != null ? (string)obj.GetValue(PropertyNameProperty) : null;\n        }\n\n        public static void SetPropertyName(DependencyObject obj, string value)\n        {\n            if (obj != null)\n                obj.SetValue(PropertyNameProperty, value);\n        }\n\n        // Using a DependencyProperty as the backing store for PropertyName.  This enables animation, styling, binding, etc...\n        public static readonly DependencyProperty PropertyNameProperty =\n            DependencyProperty.RegisterAttached(\n                \"PropertyName\",\n                typeof(string),\n                typeof(ChoGridViewSort),\n                new UIPropertyMetadata(null)\n            );\n\n        #endregion\n\n        #region Column header click event handler\n\n        private static void ColumnHeader_Click(object sender, RoutedEventArgs e)\n        {\n            GridViewColumnHeader headerClicked = e.OriginalSource as GridViewColumnHeader;\n            if (headerClicked != null)\n            {\n                string propertyName = GetPropertyName(headerClicked.Column);\n                if (!string.IsNullOrEmpty(propertyName))\n                {\n                    ListView listView = GetAncestor<ListView>(headerClicked);\n                    if (listView != null)\n                    {\n                        ICommand command = GetCommand(listView);\n                        if (command != null)\n                        {\n                            if (command.CanExecute(propertyName))\n                            {\n                                command.Execute(propertyName);\n                            }\n                        }\n                        else if (GetAutoSort(listView))\n                        {\n                            ApplySort(listView.Items, propertyName);\n                        }\n                    }\n                }\n            }\n        }\n\n        #endregion\n\n        #region Helper methods\n\n        public static T GetAncestor<T>(DependencyObject reference) where T : DependencyObject\n        {\n            DependencyObject parent = VisualTreeHelper.GetParent(reference);\n            while (!(parent is T))\n            {\n                parent = VisualTreeHelper.GetParent(parent);\n            }\n            if (parent != null)\n                return (T)parent;\n            else\n                return null;\n        }\n\n        public static void ApplySort(ICollectionView view, string propertyName)\n        {\n            ListSortDirection direction = ListSortDirection.Ascending;\n            if (view.SortDescriptions.Count > 0)\n            {\n                SortDescription currentSort = view.SortDescriptions[0];\n                if (currentSort.PropertyName == propertyName)\n                {\n                    if (currentSort.Direction == ListSortDirection.Ascending)\n                        direction = ListSortDirection.Descending;\n                    else\n                        direction = ListSortDirection.Ascending;\n                }\n                view.SortDescriptions.Clear();\n            }\n            if (!string.IsNullOrEmpty(propertyName))\n            {\n                view.SortDescriptions.Add(new SortDescription(propertyName, direction));\n            }\n        }\n\n        #endregion\n    }\n}\n"
        },
        {
          "name": "ChoMruComboBox.cs",
          "type": "blob",
          "size": 3.2431640625,
          "content": "﻿using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Data;\nusing System.Windows.Documents;\nusing System.Windows.Input;\nusing System.Windows.Media;\nusing System.Windows.Media.Imaging;\nusing System.Windows.Navigation;\nusing System.Windows.Shapes;\nusing System.Windows.Threading;\n\nnamespace ChoEazyCopy\n{\n    public class ChoMruComboBox : Control\n    {\n        \n        #region Dependency Properties\n\n        public static readonly DependencyProperty MruSourceProperty =\n            DependencyProperty.Register(\"MruSource\", typeof(ChoObservableMruList<string>), typeof(ChoMruComboBox));\n\n        public static readonly DependencyProperty TextProperty =\n            DependencyProperty.Register(\"Text\", typeof(string), typeof(ChoMruComboBox), new PropertyMetadata(OnTextChanged));\n\n        #endregion\n\n        #region Constructors\n\n        static ChoMruComboBox()\n        {\n            DefaultStyleKeyProperty.OverrideMetadata(typeof(ChoMruComboBox), new FrameworkPropertyMetadata(typeof(ChoMruComboBox)));\n        }\n\n        public ChoMruComboBox()\n        {\n\n            this.Focusable = false;\n            this.IsTabStop = false;\n            \n        }\n\n        #endregion\n\n        #region Properties\n\n        public ChoObservableMruList<string> MruSource\n        {\n            get { return (ChoObservableMruList<string>)GetValue(MruSourceProperty); }\n            set { SetValue(MruSourceProperty, value); }\n        }\n\n        public string Text\n        {\n            get { return (string)GetValue(TextProperty); }\n            set { SetValue(TextProperty, value); }\n        }\n\n        #endregion\n\n        #region Event Handlers\n\n        private static void OnTextChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)\n        {\n                        \n            ChoMruComboBox srcControl = d as ChoMruComboBox;\n            if (srcControl != null)\n            {\n                if (srcControl.MruSource != null)\n                {\n                    var dir = e.NewValue.ToString();\n\n                    if (!dir.IsNullOrWhiteSpace() && Directory.Exists(dir))\n                        srcControl.MruSource.Add(dir);\n                }\n            }\n\n        }\n        private static void OnTextChanged1(DependencyObject d, DependencyPropertyChangedEventArgs e)\n        {\n            ChoMruComboBox srcControl = d as ChoMruComboBox;\n            if (srcControl != null)\n            {\n                if (srcControl.MruSource != null)\n                {\n                    System.Threading.ThreadPool.RegisterWaitForSingleObject(new AutoResetEvent(false),\n                    (state, bTimeout) => srcControl.HandleMruUpdate(e.NewValue.ToString()), \"\", TimeSpan.FromSeconds(1), true);\n                }\n            }\n        }\n        private void HandleMruUpdate(string listVal)\n        {\n            if (this.Dispatcher.CheckAccess()) \n            {\n                if (Directory.Exists(listVal))\n                    this.MruSource.Add(listVal); \n            }\n            else\n            {\n                this.Dispatcher.BeginInvoke(DispatcherPriority.Normal, new Action<string>(HandleMruUpdate), listVal);\n            }\n        }\n        #endregion\n\n    }\n\n}\n"
        },
        {
          "name": "ChoObservableCollection.cs",
          "type": "blob",
          "size": 1.6083984375,
          "content": "﻿using System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\nusing System.Collections.Specialized;\nusing System.ComponentModel;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ChoEazyCopy\n{\n    public class ChoObservableCollection<T> : ObservableCollection<T> where T : INotifyPropertyChanged\n    {\n        public ChoObservableCollection(IEnumerable<T> initialData) : base(initialData)\n        {\n            Init();\n        }\n\n        public ChoObservableCollection()\n        {\n            Init();\n        }\n\n        private void Init()\n        {\n            foreach (T item in Items)\n                item.PropertyChanged += ItemOnPropertyChanged;\n\n            CollectionChanged += FullObservableCollectionCollectionChanged;\n        }\n\n        private void FullObservableCollectionCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)\n        {\n            if (e.NewItems != null)\n            {\n                foreach (T item in e.NewItems)\n                {\n                    if (item != null)\n                        item.PropertyChanged += ItemOnPropertyChanged;\n                }\n            }\n\n            if (e.OldItems != null)\n            {\n                foreach (T item in e.OldItems)\n                {\n                    if (item != null)\n                        item.PropertyChanged -= ItemOnPropertyChanged;\n                }\n            }\n        }\n\n        private void ItemOnPropertyChanged(object sender, PropertyChangedEventArgs e)\n            => ItemChanged?.Invoke(sender, e);\n\n        public event PropertyChangedEventHandler ItemChanged;\n    }\n}\n"
        },
        {
          "name": "ChoObservableMruList.cs",
          "type": "blob",
          "size": 3.2392578125,
          "content": "﻿using System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\nusing System.Linq;\nusing System.Text;\n\n\nnamespace ChoEazyCopy\n{\n    \n    public class ChoObservableMruList<T> : ObservableCollection<T>\n    {\n\n        #region Fields\n\n        private readonly int _maxSize = -1;\n        private readonly IEqualityComparer<T> _itemComparer = null;\n\n        #endregion\n\n        #region Constructors\n\n        public ChoObservableMruList() : base()\n        {\n\n        }\n\n        public ChoObservableMruList(IEnumerable<T> collection) : base(collection)\n        {\n\n        }\n\n        public ChoObservableMruList(List<T> list) : base(list)\n        {\n            \n        }\n\n        public ChoObservableMruList(int maxSize, IEqualityComparer<T> itemComparer) : base()\n        {\n            _maxSize = maxSize;\n            _itemComparer = itemComparer;\n        }\n\n        public ChoObservableMruList(IEnumerable<T> collection, int maxSize, IEqualityComparer<T> itemComparer)\n            : base(collection)\n        {\n            _maxSize = maxSize;\n            _itemComparer = itemComparer;\n            RemoveOverflow();\n        }\n\n        public ChoObservableMruList(List<T> list, int maxSize, IEqualityComparer<T> itemComparer)\n            : base(list)\n        {\n            _maxSize = maxSize;\n            _itemComparer = itemComparer;\n            RemoveOverflow();\n        }\n\n        #endregion\n        \n        #region Properties\n\n        public int MaxSize\n        {\n            get { return _maxSize; }\n        }\n        \n        #endregion\n\n        #region Public Methods\n\n        public new void Add(T item)\n        {\n\n            int indexOfMatch = this.IndexOf(item);\n            if (indexOfMatch < 0)\n            {\n                base.Insert(0, item);\n            }\n            else\n            {\n                base.Move(indexOfMatch, 0);\n            }\n\n            RemoveOverflow();\n            \n        }\n\n        public new bool Contains(T item)\n        {               \n            return this.Contains(item, _itemComparer);\n        }\n\n        public new int IndexOf(T item)\n        {\n\n            int indexOfMatch = -1;\n\n            if (_itemComparer != null)\n            {\n                for (int idx = 0; idx < this.Count; idx++)\n                {\n                    if (_itemComparer.Equals(item, this[idx]))\n                    {\n                        indexOfMatch = idx;\n                        break;\n                    }\n                }\n            }\n            else\n            {\n                indexOfMatch = base.IndexOf(item);\n            }\n\n            return indexOfMatch;\n\n        }\n\n        public new bool Remove(T item)\n        {\n\n            bool opResult = false;\n\n            int targetIndex = this.IndexOf(item);\n            if (targetIndex > -1)\n            {\n                this.RemoveAt(targetIndex);\n                opResult = true;\n            }\n\n            return opResult;\n\n        }\n        \n        #endregion\n\n        #region Helper Methods\n\n        private void RemoveOverflow()\n        {\n            \n            if (this.MaxSize > 0)\n            {\n                while (this.Count > this.MaxSize)\n                {\n                    this.RemoveAt(this.Count - 1);\n                }\n            }\n\n        }\n\n        #endregion\n\n    }\n\n}\n"
        },
        {
          "name": "ChoPropertyGridCustomEditors.cs",
          "type": "blob",
          "size": 6.9921875,
          "content": "﻿using Cinchoo.Core.WPF;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Data;\nusing System.Windows.Threading;\n\nnamespace ChoEazyCopy\n{\n    /*\n    //Custom editors that are used as attributes MUST implement the ITypeEditor interface.\n    public class CopyFlagsEditor : Xceed.Wpf.Toolkit.PropertyGrid.Editors.ITypeEditor\n    {\n        public FrameworkElement ResolveEditor(Xceed.Wpf.Toolkit.PropertyGrid.PropertyItem propertyItem)\n        {\n            ChoMultiSelectComboBox cmb = new ChoMultiSelectComboBox();\n            cmb.HorizontalAlignment = HorizontalAlignment.Stretch;\n\n            //create the binding from the bound property item to the editor\n            var _binding = new Binding(\"Value\"); //bind to the Value property of the PropertyItem\n            _binding.Source = propertyItem;\n            _binding.ValidatesOnExceptions = true;\n            _binding.ValidatesOnDataErrors = true;\n            _binding.Mode = propertyItem.IsReadOnly ? BindingMode.OneWay : BindingMode.TwoWay;\n            BindingOperations.SetBinding(cmb, ChoMultiSelectComboBox.TextProperty, _binding);\n\n            cmb.ItemsSource = ChoEnum.AsNodeList<ChoCopyFlags>(propertyItem.Value.ToNString());\n\n            return cmb;\n        }\n    }\n\n    //Custom editors that are used as attributes MUST implement the ITypeEditor interface.\n    public class FileAttributesEditor : Xceed.Wpf.Toolkit.PropertyGrid.Editors.ITypeEditor\n    {\n        public FrameworkElement ResolveEditor(Xceed.Wpf.Toolkit.PropertyGrid.PropertyItem propertyItem)\n        {\n            ChoMultiSelectComboBox cmb = new ChoMultiSelectComboBox();\n            cmb.HorizontalAlignment = HorizontalAlignment.Stretch;\n\n            //create the binding from the bound property item to the editor\n            var _binding = new Binding(\"Value\"); //bind to the Value property of the PropertyItem\n            _binding.Source = propertyItem;\n            _binding.ValidatesOnExceptions = true;\n            _binding.ValidatesOnDataErrors = true;\n            _binding.Mode = propertyItem.IsReadOnly ? BindingMode.OneWay : BindingMode.TwoWay;\n            BindingOperations.SetBinding(cmb, ChoMultiSelectComboBox.TextProperty, _binding);\n\n            cmb.ItemsSource = ChoEnum.AsNodeList<ChoFileAttributes>(propertyItem.Value.ToNString());\n\n            return cmb;\n        }\n    }\n\n    //Custom editors that are used as attributes MUST implement the ITypeEditor interface.\n    public class FileSelectionAttributesEditor : Xceed.Wpf.Toolkit.PropertyGrid.Editors.ITypeEditor\n    {\n        public FrameworkElement ResolveEditor(Xceed.Wpf.Toolkit.PropertyGrid.PropertyItem propertyItem)\n        {\n            ChoMultiSelectComboBox cmb = new ChoMultiSelectComboBox();\n            cmb.HorizontalAlignment = HorizontalAlignment.Stretch;\n\n            //create the binding from the bound property item to the editor\n            var _binding = new Binding(\"Value\"); //bind to the Value property of the PropertyItem\n            _binding.Source = propertyItem;\n            _binding.ValidatesOnExceptions = true;\n            _binding.ValidatesOnDataErrors = true;\n            _binding.Mode = propertyItem.IsReadOnly ? BindingMode.OneWay : BindingMode.TwoWay;\n            BindingOperations.SetBinding(cmb, ChoMultiSelectComboBox.TextProperty, _binding);\n\n            cmb.ItemsSource = ChoEnum.AsNodeList<ChoFileSelectionAttributes>(propertyItem.Value.ToNString());\n\n            return cmb;\n        }\n    }\n\n    public class FileMoveSelectionAttributesEditor : Xceed.Wpf.Toolkit.PropertyGrid.Editors.ITypeEditor\n    {\n        public FrameworkElement ResolveEditor(Xceed.Wpf.Toolkit.PropertyGrid.PropertyItem propertyItem)\n        {\n            ChoFileMoveComboBox cmb = new ChoFileMoveComboBox();\n            cmb.HorizontalAlignment = HorizontalAlignment.Stretch;\n\n            //create the binding from the bound property item to the editor\n            var _binding = new Binding(\"Value\"); //bind to the Value property of the PropertyItem\n            _binding.Source = propertyItem;\n            _binding.ValidatesOnExceptions = true;\n            _binding.ValidatesOnDataErrors = true;\n            _binding.Mode = propertyItem.IsReadOnly ? BindingMode.OneWay : BindingMode.TwoWay;\n            BindingOperations.SetBinding(cmb, ChoFileMoveComboBox.TextProperty, _binding);\n\n            cmb.ItemsSource = ChoEnum.AsNodeList<ChoFileMoveAttributes>(propertyItem.Value.ToNString()).Select(c => c.Title);\n            Dispatcher.CurrentDispatcher.BeginInvoke(new Action(() => cmb.SelectedItem = propertyItem.Value.ToNString()));\n            return cmb;\n        }\n    }\n\n    public class ChoFileMoveComboBox : ComboBox\n    {\n        protected override void OnSelectionChanged(SelectionChangedEventArgs e)\n        {\n            if (e.RemovedItems.Count > 0)\n            {\n                if (e.AddedItems != null && e.AddedItems.Count > 0)\n                {\n                    var value = (ChoFileMoveAttributes)Enum.Parse(typeof(ChoFileMoveAttributes), e.AddedItems.OfType<string>().FirstOrDefault());\n                    if (value == ChoFileMoveAttributes.MoveFilesOnly)\n                    {\n                        if (MessageBox.Show(\"Would like to delete the original file(s) after transferring the copies to the new location?\", MainWindow.Caption, MessageBoxButton.YesNo, MessageBoxImage.Stop) == MessageBoxResult.No)\n                        {\n                            e.Handled = true;\n                            return;\n                        }\n                    }\n                    else if (value == ChoFileMoveAttributes.MoveDirectoriesAndFiles)\n                    {\n                        if (MessageBox.Show(\"Would like to delete the original file(s) / folder(s) after transferring the copies to the new location?\", MainWindow.Caption, MessageBoxButton.YesNo, MessageBoxImage.Stop) == MessageBoxResult.No)\n                        {\n                            e.Handled = true;\n                            return;\n                        }\n                    }\n                }\n            }\n            base.OnSelectionChanged(e);\n        }\n    }\n    public class ChoMultilineTextBoxEditor : Xceed.Wpf.Toolkit.PropertyGrid.Editors.ITypeEditor\n    {\n        public FrameworkElement ResolveEditor(Xceed.Wpf.Toolkit.PropertyGrid.PropertyItem propertyItem)\n        {\n            System.Windows.Controls.TextBox textBox = new System.Windows.Controls.TextBox();\n            textBox.AcceptsReturn = true;\n            //create the binding from the bound property item to the editor\n            var _binding = new Binding(\"Value\"); //bind to the Value property of the PropertyItem\n            _binding.Source = propertyItem;\n            _binding.ValidatesOnExceptions = true;\n            _binding.ValidatesOnDataErrors = true;\n            _binding.Mode = propertyItem.IsReadOnly ? BindingMode.OneWay : BindingMode.TwoWay;\n            BindingOperations.SetBinding(textBox, System.Windows.Controls.TextBox.TextProperty, _binding);\n            return textBox;\n        }\n    }\n    */\n}\n"
        },
        {
          "name": "ChoPropertyGridFilePicker.xaml",
          "type": "blob",
          "size": 0.7646484375,
          "content": "﻿<UserControl x:Class=\"ChoEazyCopy.ChoPropertyGridFilePicker\"\n             xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n             xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" \n             xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" \n             xmlns:local=\"clr-namespace:ChoEazyCopy\"\n             mc:Ignorable=\"d\" \n             d:DesignHeight=\"450\" d:DesignWidth=\"800\"\n             x:Name=\"TheControl\">\n    <DockPanel>\n        <Button x:Name=\"PickFileButton\" Content=\"…\" Click=\"PickFileButton_Click\" DockPanel.Dock=\"Right\" Width=\"15\" />\n        <TextBox Text=\"{Binding ElementName=TheControl, Path=Value}\" />\n    </DockPanel>\n</UserControl>\n"
        },
        {
          "name": "ChoPropertyGridFilePicker.xaml.cs",
          "type": "blob",
          "size": 2.013671875,
          "content": "﻿using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Data;\nusing System.Windows.Documents;\nusing System.Windows.Input;\nusing System.Windows.Media;\nusing System.Windows.Media.Imaging;\nusing System.Windows.Navigation;\nusing System.Windows.Shapes;\nusing Microsoft.Win32;\nusing Xceed.Wpf.Toolkit.PropertyGrid;\nusing Xceed.Wpf.Toolkit.PropertyGrid.Editors;\n\nnamespace ChoEazyCopy\n{\n    /// <summary>\n    /// Interaction logic for ChoPropertyGridFilePicker.xaml\n    /// </summary>\n    public partial class ChoPropertyGridFilePicker : UserControl, ITypeEditor\n    {\n        public ChoPropertyGridFilePicker()\n        {\n            InitializeComponent();\n        }\n\n        public string Value\n        {\n            get { return (string)GetValue(ValueProperty); }\n            set { SetValue(ValueProperty, value); }\n        }\n\n        // Using a DependencyProperty as the backing store for Value.  This enables animation, styling, binding, etc...\n        public static readonly DependencyProperty ValueProperty =\n            DependencyProperty.Register(\"Value\", typeof(string), typeof(ChoPropertyGridFilePicker), new PropertyMetadata(null));\n\n        public FrameworkElement ResolveEditor(PropertyItem propertyItem)\n        {\n            Binding binding = new Binding(\"Value\");\n            binding.Source = propertyItem;\n            binding.Mode = propertyItem.IsReadOnly ? BindingMode.OneWay : BindingMode.TwoWay;\n            BindingOperations.SetBinding(this, ValueProperty, binding);\n            return this;\n        }\n\n        private void PickFileButton_Click(object sender, RoutedEventArgs e)\n        {\n            OpenFileDialog fd = new OpenFileDialog();\n            fd.Multiselect = true;\n            fd.CheckFileExists = false;\n            if (fd.ShowDialog() == true)\n            {\n                Value = String.Join(\";\", fd.FileNames.Select(f => f).Select(f => f.Contains(\" \") ? String.Format(@\"\"\"{0}\"\"\", f) : f));\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "ChoPropertyGridFolderPicker.xaml",
          "type": "blob",
          "size": 0.7705078125,
          "content": "﻿<UserControl x:Class=\"ChoEazyCopy.ChoPropertyGridFolderPicker\"\n             xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n             xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" \n             xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" \n             xmlns:local=\"clr-namespace:ChoEazyCopy\"\n             mc:Ignorable=\"d\" \n             d:DesignHeight=\"450\" d:DesignWidth=\"800\"\n             x:Name=\"TheControl\">\n    <DockPanel>\n        <Button x:Name=\"PickFolderButton\" Content=\"…\" Click=\"PickFolderButton_Click\" DockPanel.Dock=\"Right\" Width=\"15\" />\n        <TextBox Text=\"{Binding ElementName=TheControl, Path=Value}\" />\n    </DockPanel>\n</UserControl>\n"
        },
        {
          "name": "ChoPropertyGridFolderPicker.xaml.cs",
          "type": "blob",
          "size": 1.96484375,
          "content": "﻿using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Data;\nusing System.Windows.Documents;\nusing System.Windows.Input;\nusing System.Windows.Media;\nusing System.Windows.Media.Imaging;\nusing System.Windows.Navigation;\nusing System.Windows.Shapes;\nusing Microsoft.Win32;\nusing Xceed.Wpf.Toolkit.PropertyGrid;\nusing Xceed.Wpf.Toolkit.PropertyGrid.Editors;\n\nnamespace ChoEazyCopy\n{\n    /// <summary>\n    /// Interaction logic for ChoPropertyGridFolderPicker.xaml\n    /// </summary>\n    public partial class ChoPropertyGridFolderPicker : UserControl, ITypeEditor\n    {\n        public ChoPropertyGridFolderPicker()\n        {\n            InitializeComponent();\n        }\n\n        public string Value\n        {\n            get { return (string)GetValue(ValueProperty); }\n            set { SetValue(ValueProperty, value); }\n        }\n\n        // Using a DependencyProperty as the backing store for Value.  This enables animation, styling, binding, etc...\n        public static readonly DependencyProperty ValueProperty =\n            DependencyProperty.Register(\"Value\", typeof(string), typeof(ChoPropertyGridFolderPicker), new PropertyMetadata(null));\n\n        public FrameworkElement ResolveEditor(PropertyItem propertyItem)\n        {\n            Binding binding = new Binding(\"Value\");\n            binding.Source = propertyItem;\n            binding.Mode = propertyItem.IsReadOnly ? BindingMode.OneWay : BindingMode.TwoWay;\n            BindingOperations.SetBinding(this, ValueProperty, binding);\n            return this;\n        }\n\n        private void PickFolderButton_Click(object sender, RoutedEventArgs e)\n        {\n            using (var dialog = new System.Windows.Forms.FolderBrowserDialog())\n            {\n               if (dialog.ShowDialog() == System.Windows.Forms.DialogResult.OK)\n                {\n                    Value = dialog.SelectedPath;\n                }\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "ChoRoboCopyManager.cs",
          "type": "blob",
          "size": 23.0078125,
          "content": "﻿namespace ChoEazyCopy\n{\n    #region NameSpaces\n\n    using System;\n    using System.Linq;\n    using System.Collections.Generic;\n    using System.Text;\n    using System.IO;\n    using System.Text.RegularExpressions;\n    using System.Windows;\n    using Cinchoo.Core.IO;\n    using Cinchoo.Core;\n    using System.Threading;\n    using System.Diagnostics;\n    using System.Threading.Tasks;\n    using System.Management;\n\n    #endregion NameSpaces\n\n    public class ChoFileProcessEventArgs : EventArgs\n    {\n        #region Instance Data Members (Public)\n\n        public string Message\n        {\n            get;\n            private set;\n        }\n\n        public object Tag\n        {\n            get;\n            private set;\n        }\n\n        #endregion Instance Data Members (Public)\n\n        #region Constructors\n\n        public ChoFileProcessEventArgs(string message, object tag = null)\n        {\n            Message = message;\n            Tag = tag;\n        }\n\n        #endregion Constructors\n    }\n    public class ChoRoboCopyProgressEventArgs : EventArgs\n    {\n        #region Instance Data Members (Public)\n\n        public long _runningBytes\n        {\n            get;\n            private set;\n        }\n\n        public long _runningFileCount\n        {\n            get;\n            private set;\n        }\n\n        public long _totalBytes\n        {\n            get;\n            private set;\n        }\n\n        public long _totalFileCount\n        {\n            get;\n            private set;\n        }\n\n        #endregion Instance Data Members (Public)\n\n        #region Constructors\n\n        public ChoRoboCopyProgressEventArgs(long runningBytes, long runningFileCount, long totalBytes, long totalFileCount)\n        {\n            _runningBytes = runningBytes;\n            _runningFileCount = runningFileCount;\n            _totalBytes = totalBytes;\n            _totalFileCount = totalFileCount;\n        }\n\n        #endregion Constructors\n    }\n\n    public class ChoRoboCopyManager : IDisposable\n    {\n        #region Shared Data Members (Private)\n\n        private static readonly ChoAppSettings _appSettings = new ChoAppSettings();\n\n        #endregion Shared Data Members (Private)\n\n        #region EventHandlers\n\n        public event EventHandler<ChoFileProcessEventArgs> Status;\n        public event EventHandler<ChoFileProcessEventArgs> AppStatus;\n        public event EventHandler<ChoRoboCopyProgressEventArgs> Progress;\n\n        #endregion EventHandlers\n\n        #region Instance Data Members (Private)\n\n        private Process _process = null;\n        private Process _robocopyProcess = null;\n        private Process _analyzeRobocopyProcess = null;\n\n        private long _totalFileCount = 0;\n        private long _totalBytes = 0;\n        private long _runningFileCount = 0;\n        private long _runningBytes = 0;\n        private bool _cancel = false;\n        private bool _hasError = false;\n\n        AutoResetEvent _waitForRobocopyProcessToExit = new AutoResetEvent(false);\n        private Regex _regexBytes = new Regex(@\"(?<=\\s+)\\d+(?=\\s+)\", RegexOptions.Compiled);\n\n        #endregion Instance Data Members (Private)\n\n        #region Constructors\n\n        public ChoRoboCopyManager(string settingsFilePath = null)\n        {\n            if (settingsFilePath.IsNullOrWhiteSpace())\n            {\n                if (File.Exists(settingsFilePath))\n                {\n                    string settingsText = File.ReadAllText(settingsFilePath);\n                    _appSettings.LoadXml(settingsText);\n                }\n            }\n        }\n\n        #endregion Constructors\n\n        #region Instance Members (Public)\n\n        public void Process(ChoAppSettings appSettings, bool console = false)\n        {\n            string fileName = appSettings.RoboCopyFilePath;\n            string arguments = appSettings.GetCmdLineParams();\n\n            AppStatus.Raise(this, new ChoFileProcessEventArgs(\"Starting RoboCopy operation...\"));\n            Status.Raise(this, new ChoFileProcessEventArgs(Environment.NewLine));\n\n            string preCommands = appSettings.Precommands;\n            string postCommands = appSettings.Postcommands;\n            bool testRun = appSettings.ListOnly;\n            _cancel = false;\n            \n            try\n            {\n                // Setup the process start info\n                var processStartInfo = new ProcessStartInfo(\"cmd.exe\", \" /E:OFF /F:OFF /V:OFF /K\") // new ProcessStartInfo(fileName, arguments) //_appSettings.RoboCopyFilePath, _appSettings.GetCmdLineParams(sourceDirectory, destDirectory))\n                {\n                    UseShellExecute = false,\n                    RedirectStandardInput = true,\n                    RedirectStandardOutput = true,\n                    RedirectStandardError = true,\n                    CreateNoWindow = true\n                };\n\n                // Setup the process\n                Process process = new Process { StartInfo = processStartInfo, EnableRaisingEvents = true };\n\n                // Register event\n                _process = process;\n\n                string echoCmd = testRun ? \"@ECHO \" : \"\";\n                //Run precommands\n                    \n                Status.Raise(this, new ChoFileProcessEventArgs($\"**************************************\" + Environment.NewLine));\n                Status.Raise(this, new ChoFileProcessEventArgs($\"Starting RoboCopy operations...\" + Environment.NewLine));\n\n                if (!preCommands.IsNullOrWhiteSpace())\n                {\n                    _hasError = false;\n\n                    // Start process\n                    process.Start();\n\n                    //Task.Factory.StartNew(new Action<object>(ReadFromStreamReader), process.StandardOutput);\n                    Task.Factory.StartNew(new Action<object>(ReadFromStreamReader), process.StandardError);\n\n                    //Replace tokens\n                    preCommands = preCommands.Replace(\"{SRC_DIR}\", appSettings.SourceDirectory);\n                    preCommands = preCommands.Replace(\"{DEST_DIR}\", appSettings.DestDirectory);\n\n                    if (!testRun)\n                        Status.Raise(this, new ChoFileProcessEventArgs($\"Executing pre-process commands...\" + Environment.NewLine));\n                    else\n                        Status.Raise(this, new ChoFileProcessEventArgs($\"SKIP: Executing pre-process commands...\" + Environment.NewLine));\n\n                    Status.Raise(this, new ChoFileProcessEventArgs($\"{FormatCmd(preCommands, appSettings)}\" + Environment.NewLine));\n                    if (!testRun)\n                        process.StandardInput.WriteLine(preCommands);\n\n                    //foreach (var cmd in preCommands.SplitNTrim().Select(c => c.NTrim()).Select(c => MarshalCmd(c, appSettings)).Where(c => !c.IsNullOrWhiteSpace()))\n                    //{\n                    //    Status.Raise(this, new ChoFileProcessEventArgs($\">{echoCmd}{cmd}\" + Environment.NewLine));\n                    //    process.StandardInput.WriteLine($\"{echoCmd}{cmd}\");\n                    //}\n\n                    process.StandardInput.WriteLine(\"exit\");\n                    process.WaitForExit();\n\n                    if (_hasError)\n                    {\n                        Status.Raise(this, new ChoFileProcessEventArgs($\"RoboCopy operations failed.\" + Environment.NewLine));\n                        AppStatus.Raise(this, new ChoFileProcessEventArgs(\"RoboCopy operations failed.\", \"RoboCopy operations failed.\"));\n                        return;\n                    }\n                }\n\n                //Run robocopy\n                //process.StandardInput.WriteLine($\"{fileName} {arguments}\");\n\n                if (appSettings.ShowRoboCopyProgress)\n                {\n                    if (!Analyze(appSettings))\n                        return;\n                }\n                if (!RunRoboCopyOperation(appSettings))\n                    return;\n\n                //Run postcommands\n                if (!postCommands.IsNullOrWhiteSpace())\n                {\n                    _hasError = false;\n\n                    // Start process\n                    process.Start();\n\n                    //Task.Factory.StartNew(new Action<object>(ReadFromStreamReader), process.StandardOutput);\n                    Task.Factory.StartNew(new Action<object>(ReadFromStreamReader), process.StandardError);\n\n                    //Replace tokens\n                    postCommands = postCommands.Replace(\"{SRC_DIR}\", appSettings.SourceDirectory);\n                    postCommands = postCommands.Replace(\"{DEST_DIR}\", appSettings.DestDirectory);\n\n                    if (!testRun)\n                        Status.Raise(this, new ChoFileProcessEventArgs($\"Executing post-process commands...\" + Environment.NewLine));\n                    else\n                        Status.Raise(this, new ChoFileProcessEventArgs($\"SKIP: Executing post-process commands...\" + Environment.NewLine));\n\n                    Status.Raise(this, new ChoFileProcessEventArgs($\"{FormatCmd(postCommands, appSettings)}\" + Environment.NewLine));\n                    if (!testRun)\n                        process.StandardInput.WriteLine(postCommands);\n\n                    //foreach (var cmd in postCommands.SplitNTrim().Select(c => c.NTrim()).Select(c => MarshalCmd(c, appSettings)).Where(c => !c.IsNullOrWhiteSpace()))\n                    //{\n                    //    Status.Raise(this, new ChoFileProcessEventArgs($\">{echoCmd}{cmd}\" + Environment.NewLine));\n                    //    process.StandardInput.WriteLine($\"{echoCmd}{cmd}\");\n                    //}\n                    process.StandardInput.WriteLine(\"exit\");\n                    process.WaitForExit();\n\n                    if (_hasError)\n                    {\n                        Status.Raise(this, new ChoFileProcessEventArgs($\"RoboCopy operations failed.\" + Environment.NewLine));\n                        AppStatus.Raise(this, new ChoFileProcessEventArgs(\"RoboCopy operations failed.\", \"RoboCopy operations failed.\"));\n                        return;\n                    }\n                }\n\n                _process = null;\n\n                if (!_cancel)\n                {\n                    Status.Raise(this, new ChoFileProcessEventArgs($\"RoboCopy operations completed successfully.\" + Environment.NewLine));\n                    AppStatus.Raise(this, new ChoFileProcessEventArgs(\"RoboCopy operation completed successfully.\", \"RoboCopy operation completed successfully.\"));\n                }\n                else\n                {\n                    Status.Raise(this, new ChoFileProcessEventArgs($\"RoboCopy operations cancelled by user.\" + Environment.NewLine));\n                    AppStatus.Raise(this, new ChoFileProcessEventArgs(\"RoboCopy operations cancelled by user.\", \"RoboCopy operations cancelled by user.\"));\n                }\n            }\n            catch (ThreadAbortException)\n            {\n                Status.Raise(this, new ChoFileProcessEventArgs(Environment.NewLine + \"RoboCopy operation canceled by user.\" + Environment.NewLine, \"RoboCopy operation canceled by user.\"));\n                AppStatus.Raise(this, new ChoFileProcessEventArgs(\"RoboCopy operation canceled by user.\", \"RoboCopy operation canceled by user.\"));\n            }\n            catch (Exception ex)\n            {\n                Status.Raise(this, new ChoFileProcessEventArgs(Environment.NewLine + ex.ToString() + Environment.NewLine));\n                AppStatus.Raise(this, new ChoFileProcessEventArgs(\"RoboCopy operation failed.\", \"RoboCopy operation failed.\"));\n            }\n        }\n\n        private string FormatCmd(string cmd, ChoAppSettings appSettings)\n        {\n            return cmd.Split(\"\\n\").Select(line => $\">{line.Trim()}\").Join(Environment.NewLine);\n        }\n\n        public bool RunRoboCopyOperation(ChoAppSettings appSettings)\n        {\n            string fileName = appSettings.RoboCopyFilePath;\n            string arguments = appSettings.GetCmdLineParams();\n\n            AppStatus.Raise(this, new ChoFileProcessEventArgs(\"Performing RoboCopy operation...\"));\n            Status.Raise(this, new ChoFileProcessEventArgs(\"Performing RoboCopy operation...\"));\n\n            string preCommands = appSettings.Precommands;\n            string postCommands = appSettings.Postcommands;\n            bool testRun = appSettings.ListOnly;\n\n            try\n            {\n                _waitForRobocopyProcessToExit.Reset();\n\n                // Setup the process start info\n                var processStartInfo = new ProcessStartInfo(fileName, arguments) // new ProcessStartInfo(fileName, arguments) //_appSettings.RoboCopyFilePath, _appSettings.GetCmdLineParams(sourceDirectory, destDirectory))\n                {\n                    UseShellExecute = false,\n                    //RedirectStandardInput = true,\n                    RedirectStandardOutput = true,\n                    RedirectStandardError = true,\n                    CreateNoWindow = true\n                };\n                Status.Raise(this, new ChoFileProcessEventArgs(Environment.NewLine));\n\n                // Setup the process\n                Process process = new Process { StartInfo = processStartInfo, EnableRaisingEvents = true };\n                Status.Raise(this, new ChoFileProcessEventArgs($\">{fileName} {arguments}\"));\n\n                // Register event\n                _robocopyProcess = process;\n\n                // Start process\n                process.Start();\n\n                //process.BeginOutputReadLine();\n                Task.Factory.StartNew(new Action<object>(ParseRobocopyOutput), new Tuple<StreamReader, bool>(process.StandardOutput, false));\n                Task.Factory.StartNew(new Action<object>(ReadFromStreamReader), process.StandardError);\n\n                //Run robocopy\n                //process.StandardInput.WriteLine($\"{fileName} {arguments} /L\");\n\n                //process.StandardInput.WriteLine(\"exit\");\n\n                process.WaitForExit();\n                _waitForRobocopyProcessToExit.WaitOne();\n                Status.Raise(this, new ChoFileProcessEventArgs(Environment.NewLine));\n\n                _robocopyProcess = null;\n            }\n            catch (ThreadAbortException)\n            {\n                return false;\n            }\n            catch (Exception)\n            {\n                return false;\n            }\n\n            return true;\n        }\n\n        public bool Analyze(ChoAppSettings appSettings)\n        {\n            string fileName = appSettings.RoboCopyFilePath;\n            string arguments = appSettings.GetCmdLineParams() + \" /L\";\n\n            AppStatus.Raise(this, new ChoFileProcessEventArgs(\"Analyzing RoboCopy operation...\"));\n            Status.Raise(this, new ChoFileProcessEventArgs(\"Analyzing RoboCopy operation...\"));\n\n            string preCommands = appSettings.Precommands;\n            string postCommands = appSettings.Postcommands;\n            bool testRun = appSettings.ListOnly;\n\n            try\n            {\n                _waitForRobocopyProcessToExit.Reset();\n\n                // Setup the process start info\n                var processStartInfo = new ProcessStartInfo(fileName, arguments) // new ProcessStartInfo(fileName, arguments) //_appSettings.RoboCopyFilePath, _appSettings.GetCmdLineParams(sourceDirectory, destDirectory))\n                {\n                    UseShellExecute = false,\n                    //RedirectStandardInput = true,\n                    RedirectStandardOutput = true,\n                    RedirectStandardError = true,\n                    CreateNoWindow = true\n                };\n\n                // Setup the process\n                Process process = new Process { StartInfo = processStartInfo, EnableRaisingEvents = true };\n\n                // Register event\n                _analyzeRobocopyProcess = process;\n\n                // Start process\n                process.Start();\n\n                //process.BeginOutputReadLine();\n                Task.Factory.StartNew(new Action<object>(ParseRobocopyOutput), new Tuple<StreamReader, bool>(process.StandardOutput, true));\n                Task.Factory.StartNew(new Action<object>(ReadFromStreamReader), process.StandardError);\n\n                //Run robocopy\n                //process.StandardInput.WriteLine($\"{fileName} {arguments} /L\");\n\n                //process.StandardInput.WriteLine(\"exit\");\n\n                process.WaitForExit();\n                _waitForRobocopyProcessToExit.WaitOne();\n\n                _analyzeRobocopyProcess = null;\n            }\n            catch (ThreadAbortException)\n            {\n                return false;\n            }\n            catch (Exception)\n            {\n                return false;\n            }\n\n            return true;\n        }\n\n        bool cleanup = false;\n        private string CleanUp(string txt)\n        {\n            //if (!cleanup)\n            //{\n            //    if (txt.Contains(Environment.NewLine))\n            //        txt = txt.Substring(txt.IndexOf(Environment.NewLine));\n            //    else\n            //        txt = null;\n\n            //    cleanup = true;\n            //}\n\n            return txt;\n        }\n\n        private void ParseRobocopyOutput(object state)\n        {\n            cleanup = false;\n            \n            StreamReader reader = ((Tuple<StreamReader, bool>)state).Item1;\n            bool isAnalyze = ((Tuple<StreamReader, bool>)state).Item2;\n\n            char[] buffer = new char[32768];\n            int chars;\n            StringBuilder txt = new StringBuilder();\n            while ((chars = reader.Read(buffer, 0, buffer.Length)) > 0)\n            {\n                string data = new string(buffer, 0, chars);\n                txt.Append(data);\n\n                if (txt.Length > 0)\n                {\n                    var msg = CleanUp(txt.ToString());\n                    int pos = msg.LastIndexOf(Environment.NewLine);\n\n                    if (pos >= 0)\n                    {\n                        ParseRobocopyOutputData(msg.Substring(0, pos), isAnalyze); \n                        txt.Clear();\n                        txt.Append(msg.Substring(pos + 1));\n                    }\n                }\n            }\n            if (txt.Length > 0)\n            {\n                ParseRobocopyOutputData(CleanUp(txt.ToString()), isAnalyze);\n                txt.Clear();\n            }\n            _waitForRobocopyProcessToExit.Set();\n            // You arrive here when process is terminated.\n        }\n\n        private void ParseRobocopyOutputData(string msg, bool isAnalyze)\n        {\n            if (!isAnalyze && msg.Length > 0)\n                Status.Raise(this, new ChoFileProcessEventArgs(msg));\n\n            var lines = msg.Split(Environment.NewLine).Where(m => !m.IsNullOrWhiteSpace()).ToArray();\n\n            long fileSize = 0;\n            foreach (var line in lines)\n            {\n                fileSize = 0;\n                var match = _regexBytes.Match(line);\n                if (match.Success)\n                {\n                    fileSize += match.Value.CastTo<long>();\n                }\n\n                if (isAnalyze)\n                {\n                    _totalBytes += fileSize;\n                    _totalFileCount++;\n                }\n                else\n                {\n                    _runningBytes += fileSize;\n                    _runningFileCount++;\n#if TEST_MODE\n                    Thread.Sleep(1000);\n#endif\n                    var progress = Progress;\n                    if (progress != null && _totalBytes > 0)\n                    {\n                        progress.Raise(null, new ChoRoboCopyProgressEventArgs(_runningBytes, _runningFileCount, _totalBytes, _totalFileCount));\n                    }\n                }\n            }\n        }\n\n        private void ReadFromStreamReader(object state)\n        {\n            cleanup = false;\n            StreamReader reader = state as StreamReader;\n            char[] buffer = new char[32768];\n            int chars;\n            StringBuilder txt = new StringBuilder();\n            while ((chars = reader.Read(buffer, 0, buffer.Length)) > 0)\n            {\n                string data = new string(buffer, 0, chars);\n                txt.Append(data);\n\n                if (txt.Length > 0)\n                {\n                    _hasError = true;\n                    Status.Raise(this, new ChoFileProcessEventArgs(CleanUp(txt.ToString())));\n                    txt.Clear();\n                }\n            }\n            if (txt.Length > 0)\n            {\n                _hasError = true;\n                Status.Raise(this, new ChoFileProcessEventArgs(CleanUp(txt.ToString())));\n                txt.Clear();\n            }\n\n            // You arrive here when process is terminated.\n        }\n\n        internal void Cancel()\n        {\n            _cancel = true;\n            _waitForRobocopyProcessToExit.Set();\n\n            Process process = _analyzeRobocopyProcess;\n            if (process != null)\n            {\n                try\n                {\n                    try\n                    {\n                        KillProcessAndChildrens(_process.Id);\n                    }\n                    catch { }\n\n                    process.Kill();\n                    //AppStatus.Raise(this, new ChoFileProcessEventArgs(\"RoboCopy operation canceled.\"));\n                    _analyzeRobocopyProcess = null;\n                }\n                catch { }\n            }\n            process = _robocopyProcess;\n            if (process != null)\n            {\n                try\n                {\n                    try\n                    {\n                        KillProcessAndChildrens(_process.Id);\n                    }\n                    catch { }\n\n                    process.Kill();\n                    //AppStatus.Raise(this, new ChoFileProcessEventArgs(\"RoboCopy operation canceled.\"));\n                    _robocopyProcess = null;\n                }\n                catch { }\n            }\n\n            process = _process;\n            if (process != null)\n            {\n                try\n                {\n                    try\n                    {\n                        KillProcessAndChildrens(_process.Id);\n                    }\n                    catch { }\n\n                    process.Kill();\n                    AppStatus.Raise(this, new ChoFileProcessEventArgs(\"RoboCopy operation canceled.\"));\n                    _process = null;\n                }\n                catch { }\n            }\n        }\n\n        private void KillProcessAndChildrens(int pid)\n        {\n            ManagementObjectSearcher processSearcher = new ManagementObjectSearcher\n              (\"Select * From Win32_Process Where ParentProcessID=\" + pid);\n            ManagementObjectCollection processCollection = processSearcher.Get();\n\n            // We must kill child processes first!\n            if (processCollection != null)\n            {\n                foreach (ManagementObject mo in processCollection)\n                {\n                    KillProcessAndChildrens(Convert.ToInt32(mo[\"ProcessID\"])); //kill child processes(also kills childrens of childrens etc.)\n                }\n            }\n\n            // Then kill parents.\n            try\n            {\n                Process proc = System.Diagnostics.Process.GetProcessById(pid);\n                if (!proc.HasExited) proc.Kill();\n            }\n            catch (ArgumentException)\n            {\n                // Process already exited.\n            }\n        }\n        #endregion Instance Members (Public)\n\n        #region IDisposable Members\n\n        public void Dispose()\n        {\n        }\n\n        #endregion\n    }\n}\n"
        },
        {
          "name": "ChoSortAdorner.cs",
          "type": "blob",
          "size": 1.4775390625,
          "content": "﻿using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows;\nusing System.Windows.Documents;\nusing System.Windows.Media;\n\nnamespace ChoEazyCopy\n{\n    public class ChoSortAdorner : Adorner\n    {\n        private static Geometry ascGeometry =\n            Geometry.Parse(\"M 0 4 L 3.5 0 L 7 4 Z\");\n\n        private static Geometry descGeometry =\n            Geometry.Parse(\"M 0 0 L 3.5 4 L 7 0 Z\");\n\n        public ListSortDirection Direction { get; private set; }\n\n        public ChoSortAdorner(UIElement element, ListSortDirection dir)\n            : base(element)\n        {\n            this.Direction = dir;\n        }\n\n        protected override void OnRender(DrawingContext drawingContext)\n        {\n            base.OnRender(drawingContext);\n\n            if (AdornedElement.RenderSize.Width < 20)\n                return;\n\n            TranslateTransform transform = new TranslateTransform\n                (\n                    AdornedElement.RenderSize.Width - 15,\n                    (AdornedElement.RenderSize.Height - 5) / 2\n                );\n            drawingContext.PushTransform(transform);\n\n            Geometry geometry = ascGeometry;\n            if (this.Direction == ListSortDirection.Descending)\n                geometry = descGeometry;\n            drawingContext.DrawGeometry(ChoAppTheme.Instance.ControlForegroundBrush, null, geometry);\n\n            drawingContext.Pop();\n        }\n    }\n}\n"
        },
        {
          "name": "ChoSystemColorsWindow.xaml",
          "type": "blob",
          "size": 1.7216796875,
          "content": "﻿<Window x:Class=\"ChoEazyCopy.ChoSystemColorsWindow\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n        xmlns:local=\"clr-namespace:ChoEazyCopy\"\n        mc:Ignorable=\"d\"\n        Title=\"ChoSystemColorsWindow\" Height=\"450\" Width=\"800\">\n    <Window.Resources>\n        <DataTemplate x:Key=\"CellColor\">\n            <DockPanel>\n                <TextBlock>\n                    <TextBlock.Background>\n                        <SolidColorBrush Color=\"{Binding Path=Color}\" />\n                    </TextBlock.Background>\n                    <TextBlock.Text>\n                        &#160;&#160;&#160;&#160;&#160;\n                        &#160;&#160;&#160;&#160;&#160;\n                        &#160;&#160;&#160;&#160;&#160;\n                    </TextBlock.Text>\n                </TextBlock>\n            </DockPanel>\n        </DataTemplate>\n    </Window.Resources>\n    <Grid>\n        <ListView Grid.Row=\"1\"\n                  Name=\"SystemColorsList\"\n                  ItemsSource=\"{Binding}\">\n            <ListView.View>\n                <GridView AllowsColumnReorder=\"True\">\n                    <GridViewColumn CellTemplate=\"{StaticResource CellColor}\"\n                                    Header=\"Color\"\n                                    Width=\"Auto\"/>\n                    <GridViewColumn DisplayMemberBinding=\"{Binding Path=Name}\"\n                                    Header=\"Name\"\n                                    Width=\"Auto\"/>\n                </GridView>\n            </ListView.View>\n        </ListView>\n    </Grid>\n</Window>\n"
        },
        {
          "name": "ChoSystemColorsWindow.xaml.cs",
          "type": "blob",
          "size": 1.3173828125,
          "content": "﻿using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Data;\nusing System.Windows.Documents;\nusing System.Windows.Input;\nusing System.Windows.Media;\nusing System.Windows.Media.Imaging;\nusing System.Windows.Shapes;\n\nnamespace ChoEazyCopy\n{\n    /// <summary>\n    /// Interaction logic for ChoSystemColorsWindow.xaml\n    /// </summary>\n    public partial class ChoSystemColorsWindow : Window\n    {\n        public ChoSystemColorsWindow()\n        {\n            InitializeComponent();\n            List<ColorAndName> l = new List<ColorAndName>();\n\n            foreach (PropertyInfo i in typeof(System.Windows.SystemColors).GetProperties())\n            {\n                if (i.PropertyType == typeof(Color))\n                {\n                    ColorAndName cn = new ColorAndName();\n                    cn.Color = (Color)i.GetValue(new Color(), BindingFlags.GetProperty, null, null, null);\n                    cn.Name = i.Name;\n                    l.Add(cn);\n                }\n            }\n\n            SystemColorsList.DataContext = l;\n        }\n        class ColorAndName\n        {\n            public Color Color { get; set; }\n            public string Name { get; set; }\n        }\n    }\n}\n"
        },
        {
          "name": "ChoTaskQManager.cs",
          "type": "blob",
          "size": 4.81640625,
          "content": "﻿using Cinchoo.Core;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace ChoEazyCopy\n{\n    internal class ChoTaskQManager\n    {\n        private readonly ICollection<ChoTaskQueueItem> _taskQItems;\n        private readonly object _padLock;\n        private Thread _roboCopyThread;\n\n        public ChoTaskQManager(ICollection<ChoTaskQueueItem> taskQItems, object padLock)\n        {\n            _taskQItems = taskQItems;\n            _padLock = padLock;\n        }\n\n        public void Start()\n        {\n#if TEST_MODE\n            return;\n#endif\n            if (_roboCopyThread != null)\n                return;\n            \n            ChoTaskQueueItem firstTaskQueueItem = null;\n\n            _roboCopyThread = new Thread(() =>\n            {\n                int count = 0;\n                while (true)\n                {\n                    lock (_padLock)\n                    {\n                        count = _taskQItems.Count;\n                        if (count > 0)\n                        {\n                            firstTaskQueueItem = GetFirstTaskQueueItem();\n                            if (firstTaskQueueItem != null)\n                            {\n                                RunRoboCopyOperation(firstTaskQueueItem);\n                            }\n                        }\n                    }\n\n                    if (firstTaskQueueItem == null)\n                        Thread.Sleep(10 * 1000);\n                }\n            });\n            _roboCopyThread.Start();\n        }\n\n        private void RunRoboCopyOperation(ChoTaskQueueItem taskQueueItem)\n        {\n            try\n            {\n                taskQueueItem.StartTime = DateTime.Now;\n                taskQueueItem.ErrorMessage = null;\n\n                if (taskQueueItem.TaskFilePath.IsNullOrWhiteSpace())\n                    throw new ApplicationException(\"Missing task file path.\");\n                if (taskQueueItem.TaskFilePath.IsNullOrWhiteSpace())\n                    throw new ApplicationException($\"'{taskQueueItem.TaskFilePath}' task file path does not exists.\");\n\n                ChoAppSettings appSettings = new ChoAppSettings();\n                appSettings.LoadXml(File.ReadAllText(taskQueueItem.TaskFilePath));\n\n                using (var log = new StreamWriter(taskQueueItem.LogFilePath))\n                {\n                    ChoRoboCopyManager _roboCopyManager = new ChoRoboCopyManager();\n                    _roboCopyManager.Status += (sender, e) => log.Write(e.Message);\n                    //_roboCopyManager.AppStatus += (sender, e) => UpdateStatus(e.Message, e.Tag.ToNString());\n\n                    _roboCopyManager.Process(appSettings);\n                }\n\n                taskQueueItem.Status = TaskStatus.Completed;\n            }\n            catch (ThreadAbortException)\n            {\n                taskQueueItem.Status = TaskStatus.Stopped;\n                Thread.ResetAbort();\n            }\n            catch (Exception ex)\n            {\n                taskQueueItem.Status = TaskStatus.Stopped;\n                taskQueueItem.ErrorMessage = ex.Message;\n            }\n            finally\n            {\n                taskQueueItem.EndTime = DateTime.Now;\n            }\n        }\n\n        private ChoTaskQueueItem GetFirstTaskQueueItem()\n        {\n            return _taskQItems.FirstOrDefault(t => t.Status == TaskStatus.Queued);\n        }\n\n        public void Stop()\n        {\n            var thread = _roboCopyThread;\n            if (thread != null)\n                thread.AbortThread();\n        }\n\n        public void Add(string taskName, DateTime? startTime = null, DateTime? endTime = null, string taskFilePath = null, \n            TaskStatus? status = TaskStatus.Queued, string errorMsg = null, Action<ChoTaskQueueItem> onSuccess = null, \n            Action<string, string> onFailure = null)\n        {\n            lock (_padLock)\n            {\n                try\n                {\n                    long index = _taskQItems.Count == 0 ? 0 : _taskQItems.Max(i => i.Id);\n                    var task = new ChoTaskQueueItem(index + 1, taskName)\n                    {\n                        StartTime = startTime == null ? DateTime.Now : startTime.Value,\n                        EndTime = endTime == null ? DateTime.Now.AddDays(1) : endTime.Value,\n                        TaskFilePath = taskFilePath,\n                        Status = status == null ? TaskStatus.Queued : status.Value,\n                        ErrorMessage = errorMsg,\n                    };\n\n                    _taskQItems.Add(task);\n                    if (onSuccess != null)\n                        onSuccess(task);\n                }\n                catch (Exception ex)\n                {\n                    if (onFailure != null)\n                        onFailure(taskName, ex.Message);\n                }\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "ChoTaskQueueItem.cs",
          "type": "blob",
          "size": 2.90625,
          "content": "﻿using Cinchoo.Core;\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ChoEazyCopy\n{\n    public enum TaskStatus { Queued = 0, Running = 1, Stopped = 2, Completed = 3}\n\n    public class ChoTaskQueueItem : ChoViewModelBase\n    {\n        private Guid _UID;\n        public Guid UID\n        {\n            get { return _UID; }\n            set\n            {\n                _UID = value;\n                NotifyPropertyChanged();\n            }\n        }\n        private long _id;\n        public long Id \n        { \n            get { return _id; }\n            set\n            {\n                _id = value;\n                NotifyPropertyChanged();\n            }\n        }\n        private string _taskName;\n        public string TaskName\n        {\n            get { return _taskName; }\n            set\n            {\n                _taskName = value;\n                NotifyPropertyChanged();\n            }\n        }\n        private DateTime _queueTime;\n        public DateTime QueueTime\n        {\n            get { return _queueTime; }\n            set\n            {\n                _queueTime = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n\n        private DateTime _startTime;\n        public DateTime StartTime\n        {\n            get { return _startTime; }\n            set\n            {\n                _startTime = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        private DateTime _endTime;\n        public DateTime EndTime\n        {\n            get { return _endTime; }\n            set\n            {\n                _endTime = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        private TaskStatus _status;\n        public TaskStatus Status\n        {\n            get { return _status; }\n            set\n            {\n                _status = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        private string _errorMessage;\n        public string ErrorMessage\n        {\n            get { return _errorMessage; }\n            set\n            {\n                _errorMessage = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n\n        private string _taskFilePath;\n        public string TaskFilePath\n        {\n            get { return _taskFilePath; }\n            set\n            {\n                _taskFilePath = value;\n                NotifyPropertyChanged();\n            }\n        }\n\n        public string LogFilePath \n        {\n            get { return Path.Combine(ChoTaskQueueItemLogInfo.AppLogFolder, $\"{TaskName}_{UID}.log\");  } \n        }\n\n        public ChoTaskQueueItem()\n        {\n\n        }\n\n        public ChoTaskQueueItem(long id, string taskName)\n        {\n            UID = Guid.NewGuid();\n            Id = id;\n            TaskName = taskName;\n            QueueTime = DateTime.Now;\n        }\n    }\n\n}\n"
        },
        {
          "name": "ChoTaskQueueItemLogInfo.cs",
          "type": "blob",
          "size": 0.677734375,
          "content": "﻿using Cinchoo.Core;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ChoEazyCopy\n{\n    public static class ChoTaskQueueItemLogInfo\n    {\n        public static string AppLogFolder\n        {\n            get;\n            private set;\n        }\n\n        static ChoTaskQueueItemLogInfo()\n        {\n            AppLogFolder = Path.Combine(Path.Combine(System.Environment.GetFolderPath(System.Environment.SpecialFolder.LocalApplicationData),\n                ChoGlobalApplicationSettings.Me.ApplicationNameWithoutExtension), \"Log\");\n            Directory.CreateDirectory(AppLogFolder);\n        }\n    }\n}\n"
        },
        {
          "name": "ChoUserPreferences.cs",
          "type": "blob",
          "size": 4.990234375,
          "content": "﻿using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.ComponentModel;\nusing System.Windows;\n\nnamespace ChoEazyCopy\n{\n    public class ChoUserPreferences\n    {\n        #region Public Properties\n\n        public double WindowTop { get; set; }\n\n        public double WindowLeft { get; set; }\n\n        public double WindowHeight { get; set; }\n\n        public double WindowWidth { get; set; }\n\n        public System.Windows.WindowState WindowState { get; set; }\n\n        public bool RememberWindowSizeAndPosition { get; set; }\n\n        public bool ScrollOutput { get; set; }\n\n        public string BackupTaskDirectory { get; set; }\n        #endregion\n\n        #region Constructor\n\n        public ChoUserPreferences()\n        {\n            //Load the settings\n            Load();\n\n            //Size it to fit the current screen\n            SizeToFit();\n\n            //Move the window at least partially into view\n            MoveIntoView();\n        }\n\n        #endregion //Constructor\n\n        #region Functions\n\n        /// <summary>\n        /// If the saved window dimensions are larger than the current screen shrink the\n        /// window to fit.\n        /// </summary>\n        public void SizeToFit()\n        {\n            if (WindowHeight > System.Windows.SystemParameters.VirtualScreenHeight)\n                WindowHeight = System.Windows.SystemParameters.VirtualScreenHeight;\n\n            if (WindowWidth > System.Windows.SystemParameters.VirtualScreenWidth)\n                WindowWidth = System.Windows.SystemParameters.VirtualScreenWidth;\n        }\n\n        /// <summary>\n        /// If the window is more than half off of the screen move it up and to the left \n        /// so half the height and half the width are visible.\n        /// </summary>\n        public void MoveIntoView()\n        {\n            //if (WindowTop + WindowHeight / 2 > System.Windows.SystemParameters.VirtualScreenHeight)\n            //    WindowTop = System.Windows.SystemParameters.VirtualScreenHeight - WindowHeight;\n\n            //if (WindowLeft + WindowWidth / 2 > System.Windows.SystemParameters.VirtualScreenWidth)\n            //    WindowLeft = System.Windows.SystemParameters.VirtualScreenWidth - WindowWidth;\n\n            //if (WindowTop < 0)\n            //    WindowTop = 0;\n\n            //if (WindowLeft < 0)\n            //    WindowLeft = 0;\n\n            // make sure it's in the current view space\n            if (WindowTop + (WindowHeight / 2)\n                > (SystemParameters.VirtualScreenHeight + SystemParameters.VirtualScreenTop))\n            {\n                WindowTop = SystemParameters.VirtualScreenHeight + SystemParameters.VirtualScreenTop - WindowHeight;\n            }\n\n            if (WindowLeft + (WindowWidth / 2)\n                > (SystemParameters.VirtualScreenWidth + SystemParameters.VirtualScreenLeft))\n            {\n                WindowLeft = SystemParameters.VirtualScreenWidth + SystemParameters.VirtualScreenLeft - WindowWidth;\n            }\n\n            if (WindowTop < SystemParameters.VirtualScreenTop)\n            {\n                WindowTop = SystemParameters.VirtualScreenTop;\n            }\n\n            if (WindowLeft < SystemParameters.VirtualScreenLeft)\n            {\n                WindowLeft = SystemParameters.VirtualScreenLeft;\n            }\n        }\n\n        private void Load()\n        {\n            Properties.Settings.Default.Reload();\n            WindowTop = Properties.Settings.Default.WindowTop;\n            WindowLeft = Properties.Settings.Default.WindowLeft;\n            WindowHeight = Properties.Settings.Default.WindowHeight;\n            WindowWidth = Properties.Settings.Default.WindowWidth;\n            WindowState = Properties.Settings.Default.WindowState;\n            RememberWindowSizeAndPosition = Properties.Settings.Default.RememberWindowSizeAndPosition;\n            ScrollOutput = Properties.Settings.Default.ScrollOutput;\n            BackupTaskDirectory = Properties.Settings.Default.BackupTaskDirectory;\n        }\n\n        public void Save()\n        {\n            Properties.Settings.Default.Reload();\n            if (WindowState != System.Windows.WindowState.Minimized)\n            {\n                Properties.Settings.Default.WindowTop = WindowTop;\n                Properties.Settings.Default.WindowLeft = WindowLeft;\n                Properties.Settings.Default.WindowHeight = WindowHeight;\n                Properties.Settings.Default.WindowWidth = WindowWidth;\n                Properties.Settings.Default.WindowState = WindowState;\n                Properties.Settings.Default.RememberWindowSizeAndPosition = RememberWindowSizeAndPosition;\n                Properties.Settings.Default.ScrollOutput = ScrollOutput;\n\n                Properties.Settings.Default.BackupTaskDirectory = BackupTaskDirectory;\n                Properties.Settings.Default.Save();\n            }\n            else\n            {\n                Properties.Settings.Default.BackupTaskDirectory = BackupTaskDirectory;\n                Properties.Settings.Default.Save();\n            }\n        }\n\n        #endregion //Functions\n\n    }\n}\n"
        },
        {
          "name": "ChoUtility.cs",
          "type": "blob",
          "size": 1.0185546875,
          "content": "﻿using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ChoEazyCopy\n{\n    public static class ChoUtility\n    {\n        public static void Move<T>(this List<T> list, int oldIndex, int newIndex)\n        {\n            var item = list[oldIndex];\n\n            list.RemoveAt(oldIndex);\n\n            if (newIndex > oldIndex) newIndex--;\n            // the actual index could have shifted due to the removal\n\n            list.Insert(newIndex, item);\n        }\n\n        public static void Move<T>(this List<T> list, T item, int newIndex)\n        {\n            if (item != null)\n            {\n                var oldIndex = list.IndexOf(item);\n                if (oldIndex > -1)\n                {\n                    list.RemoveAt(oldIndex);\n\n                    if (newIndex > oldIndex) newIndex--;\n                    // the actual index could have shifted due to the removal\n\n                    list.Insert(newIndex, item);\n                }\n            }\n\n        }\n    }\n}\n"
        },
        {
          "name": "ChoValueConverters.cs",
          "type": "blob",
          "size": 10.4208984375,
          "content": "﻿using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows;\nusing System.Windows.Data;\nusing System.Windows.Markup;\nusing System.Windows.Media;\n\nnamespace ChoEazyCopy\n{\n    public class BoolInverterConverter : IValueConverter\n    {\n        #region IValueConverter Members\n\n        public object Convert(object value, Type targetType, object parameter,\n            System.Globalization.CultureInfo culture)\n        {\n            if (value is bool)\n            {\n                return !(bool)value;\n            }\n            return value;\n        }\n\n        public object ConvertBack(object value, Type targetType, object parameter,\n            System.Globalization.CultureInfo culture)\n        {\n            if (value is bool)\n            {\n                return !(bool)value;\n            }\n            return value;\n        }\n\n        #endregion\n    }\n    public class SourceDirBorderColorConverter : MarkupExtension, IValueConverter\n    {\n        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)\n        {\n            var val = (bool)value;\n            if (val)\n                return System.Windows.SystemColors.ActiveBorderBrush;\n            else\n                return Brushes.Red;\n        }\n\n        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)\n        {\n            throw new NotImplementedException();\n        }\n\n        public override object ProvideValue(IServiceProvider serviceProvider)\n        {\n            return this;\n        }\n    }\n\n    public class BoolToBackgroundColorConverter : IValueConverter\n    {\n        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)\n        {\n            var val = (bool)value;\n            if (val)\n                return ChoAppTheme.Instance.ControlBackgroundBrush;\n            else\n                return Brushes.Red;\n        }\n\n        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)\n        {\n            throw new NotImplementedException();\n        }\n    }\n    public class BoolToForegroundColorConverter : IValueConverter\n    {\n        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)\n        {\n            var val = (bool)value;\n            if (val)\n                return ChoAppTheme.Instance.ControlForegroundBrush;\n            else\n                return Brushes.White;\n        }\n\n        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)\n        {\n            throw new NotImplementedException();\n        }\n    }\n    public class MathConverter : IValueConverter\n    {\n        private static readonly char[] _allOperators = new[] { '+', '-', '*', '/', '%', '(', ')' };\n\n        private static readonly List<string> _grouping = new List<string> { \"(\", \")\" };\n        private static readonly List<string> _operators = new List<string> { \"+\", \"-\", \"*\", \"/\", \"%\" };\n\n        #region IValueConverter Members\n\n        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)\n        {\n            // Parse value into equation and remove spaces\n            var mathEquation = parameter as string;\n            mathEquation = mathEquation.Replace(\" \", \"\");\n            mathEquation = mathEquation.Replace(\"@VALUE\", value.ToString());\n\n            // Validate values and get list of numbers in equation\n            var numbers = new List<double>();\n            double tmp;\n\n            foreach (string s in mathEquation.Split(_allOperators))\n            {\n                if (s != string.Empty)\n                {\n                    if (double.TryParse(s, out tmp))\n                    {\n                        numbers.Add(tmp);\n                    }\n                    else\n                    {\n                        // Handle Error - Some non-numeric, operator, or grouping character found in string\n                        throw new InvalidCastException();\n                    }\n                }\n            }\n\n            // Begin parsing method\n            EvaluateMathString(ref mathEquation, ref numbers, 0);\n\n            // After parsing the numbers list should only have one value - the total\n            return numbers[0];\n        }\n\n        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)\n        {\n            throw new NotImplementedException();\n        }\n\n        #endregion\n\n        // Evaluates a mathematical string and keeps track of the results in a List<double> of numbers\n        private void EvaluateMathString(ref string mathEquation, ref List<double> numbers, int index)\n        {\n            // Loop through each mathemtaical token in the equation\n            string token = GetNextToken(mathEquation);\n\n            while (token != string.Empty)\n            {\n                // Remove token from mathEquation\n                mathEquation = mathEquation.Remove(0, token.Length);\n\n                // If token is a grouping character, it affects program flow\n                if (_grouping.Contains(token))\n                {\n                    switch (token)\n                    {\n                        case \"(\":\n                            EvaluateMathString(ref mathEquation, ref numbers, index);\n                            break;\n\n                        case \")\":\n                            return;\n                    }\n                }\n\n                // If token is an operator, do requested operation\n                if (_operators.Contains(token))\n                {\n                    // If next token after operator is a parenthesis, call method recursively\n                    string nextToken = GetNextToken(mathEquation);\n                    if (nextToken == \"(\")\n                    {\n                        EvaluateMathString(ref mathEquation, ref numbers, index + 1);\n                    }\n\n                    // Verify that enough numbers exist in the List<double> to complete the operation\n                    // and that the next token is either the number expected, or it was a ( meaning\n                    // that this was called recursively and that the number changed\n                    if (numbers.Count > (index + 1) &&\n                        (double.Parse(nextToken) == numbers[index + 1] || nextToken == \"(\"))\n                    {\n                        switch (token)\n                        {\n                            case \"+\":\n                                numbers[index] = numbers[index] + numbers[index + 1];\n                                break;\n                            case \"-\":\n                                numbers[index] = numbers[index] - numbers[index + 1];\n                                break;\n                            case \"*\":\n                                numbers[index] = numbers[index] * numbers[index + 1];\n                                break;\n                            case \"/\":\n                                numbers[index] = numbers[index] / numbers[index + 1];\n                                break;\n                            case \"%\":\n                                numbers[index] = numbers[index] % numbers[index + 1];\n                                break;\n                        }\n                        numbers.RemoveAt(index + 1);\n                    }\n                    else\n                    {\n                        // Handle Error - Next token is not the expected number\n                        throw new FormatException(\"Next token is not the expected number\");\n                    }\n                }\n\n                token = GetNextToken(mathEquation);\n            }\n        }\n\n        // Gets the next mathematical token in the equation\n        private string GetNextToken(string mathEquation)\n        {\n            // If we're at the end of the equation, return string.empty\n            if (mathEquation == string.Empty)\n            {\n                return string.Empty;\n            }\n\n            // Get next operator or numeric value in equation and return it\n            string tmp = \"\";\n            foreach (char c in mathEquation)\n            {\n                if (_allOperators.Contains(c))\n                {\n                    return (tmp == \"\" ? c.ToString() : tmp);\n                }\n                else\n                {\n                    tmp += c;\n                }\n            }\n\n            return tmp;\n        }\n    }\n    public class BooleanToVisibilityConverter : IValueConverter\n    {\n        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)\n        {\n            if (value is Boolean && (bool)value)\n            {\n                return Visibility.Visible;\n            }\n            return Visibility.Collapsed;\n        }\n\n        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)\n        {\n            if (value is Visibility && (Visibility)value == Visibility.Visible)\n            {\n                return true;\n            }\n            return false;\n        }\n    }\n    public class BooleanToVisibilityInverterConverter : IValueConverter\n    {\n        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)\n        {\n            if (value is Boolean && (bool)value)\n            {\n                return Visibility.Collapsed;\n            }\n            return Visibility.Visible;\n        }\n\n        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)\n        {\n            if (value is Visibility && (Visibility)value == Visibility.Visible)\n            {\n                return false;\n            }\n            return true;\n        }\n    }\n    public class BooleanToVisibilityInverterConverterEx : IValueConverter\n    {\n        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)\n        {\n            if (value is Boolean && (bool)value)\n            {\n                return Visibility.Hidden;\n            }\n            return Visibility.Visible;\n        }\n\n        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)\n        {\n            if (value is Visibility && (Visibility)value == Visibility.Visible)\n            {\n                return false;\n            }\n            return true;\n        }\n    }\n}\n"
        },
        {
          "name": "Controls",
          "type": "tree",
          "content": null
        },
        {
          "name": "FodyWeavers.xml",
          "type": "blob",
          "size": 0.1435546875,
          "content": "﻿<Weavers xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"FodyWeavers.xsd\">\n  <PropertyChanged />\n</Weavers>"
        },
        {
          "name": "FodyWeavers.xsd",
          "type": "blob",
          "size": 3.9453125,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">\n  <!-- This file was generated by Fody. Manual changes to this file will be lost when your project is rebuilt. -->\n  <xs:element name=\"Weavers\">\n    <xs:complexType>\n      <xs:all>\n        <xs:element name=\"PropertyChanged\" minOccurs=\"0\" maxOccurs=\"1\">\n          <xs:complexType>\n            <xs:attribute name=\"InjectOnPropertyNameChanged\" type=\"xs:boolean\">\n              <xs:annotation>\n                <xs:documentation>Used to control if the On_PropertyName_Changed feature is enabled.</xs:documentation>\n              </xs:annotation>\n            </xs:attribute>\n            <xs:attribute name=\"TriggerDependentProperties\" type=\"xs:boolean\">\n              <xs:annotation>\n                <xs:documentation>Used to control if the Dependent properties feature is enabled.</xs:documentation>\n              </xs:annotation>\n            </xs:attribute>\n            <xs:attribute name=\"EnableIsChangedProperty\" type=\"xs:boolean\">\n              <xs:annotation>\n                <xs:documentation>Used to control if the IsChanged property feature is enabled.</xs:documentation>\n              </xs:annotation>\n            </xs:attribute>\n            <xs:attribute name=\"EventInvokerNames\" type=\"xs:string\">\n              <xs:annotation>\n                <xs:documentation>Used to change the name of the method that fires the notify event. This is a string that accepts multiple values in a comma separated form.</xs:documentation>\n              </xs:annotation>\n            </xs:attribute>\n            <xs:attribute name=\"CheckForEquality\" type=\"xs:boolean\">\n              <xs:annotation>\n                <xs:documentation>Used to control if equality checks should be inserted. If false, equality checking will be disabled for the project.</xs:documentation>\n              </xs:annotation>\n            </xs:attribute>\n            <xs:attribute name=\"CheckForEqualityUsingBaseEquals\" type=\"xs:boolean\">\n              <xs:annotation>\n                <xs:documentation>Used to control if equality checks should use the Equals method resolved from the base class.</xs:documentation>\n              </xs:annotation>\n            </xs:attribute>\n            <xs:attribute name=\"UseStaticEqualsFromBase\" type=\"xs:boolean\">\n              <xs:annotation>\n                <xs:documentation>Used to control if equality checks should use the static Equals method resolved from the base class.</xs:documentation>\n              </xs:annotation>\n            </xs:attribute>\n            <xs:attribute name=\"SuppressWarnings\" type=\"xs:boolean\">\n              <xs:annotation>\n                <xs:documentation>Used to turn off build warnings from this weaver.</xs:documentation>\n              </xs:annotation>\n            </xs:attribute>\n            <xs:attribute name=\"SuppressOnPropertyNameChangedWarning\" type=\"xs:boolean\">\n              <xs:annotation>\n                <xs:documentation>Used to turn off build warnings about mismatched On_PropertyName_Changed methods.</xs:documentation>\n              </xs:annotation>\n            </xs:attribute>\n          </xs:complexType>\n        </xs:element>\n      </xs:all>\n      <xs:attribute name=\"VerifyAssembly\" type=\"xs:boolean\">\n        <xs:annotation>\n          <xs:documentation>'true' to run assembly verification (PEVerify) on the target assembly after all weavers have been executed.</xs:documentation>\n        </xs:annotation>\n      </xs:attribute>\n      <xs:attribute name=\"VerifyIgnoreCodes\" type=\"xs:string\">\n        <xs:annotation>\n          <xs:documentation>A comma-separated list of error codes that can be safely ignored in assembly verification.</xs:documentation>\n        </xs:annotation>\n      </xs:attribute>\n      <xs:attribute name=\"GenerateXsd\" type=\"xs:boolean\">\n        <xs:annotation>\n          <xs:documentation>'false' to turn off automatic generation of the XML Schema file.</xs:documentation>\n        </xs:annotation>\n      </xs:attribute>\n    </xs:complexType>\n  </xs:element>\n</xs:schema>"
        },
        {
          "name": "Images",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.048828125,
          "content": "MIT License\n\nCopyright (c) 2017-2022 Cinchoo Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "MainWindow.xaml",
          "type": "blob",
          "size": 98.1484375,
          "content": "﻿<Controls:MetroWindow\n    x:Class=\"ChoEazyCopy.MainWindow\"\n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n    xmlns:Controls=\"clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro\"\n    xmlns:Properties=\"clr-namespace:ChoEazyCopy.Properties\"\n    xmlns:iconPacks=\"http://metro.mahapps.com/winfx/xaml/iconpacks\"\n    xmlns:local=\"clr-namespace:ChoEazyCopy\"\n    xmlns:sfw=\"clr-namespace:SoftFluent.Windows;assembly=SoftFluent.Windows\"\n    xmlns:sys=\"clr-namespace:System;assembly=mscorlib\"\n    xmlns:wpg=\"clr-namespace:System.Windows.Controls\"\n    x:Name=\"ChoEazyCopyWindow\"\n    Title=\"ChoEazyCopy - Cinchoo Inc.\"\n    Width=\"950\"\n    Height=\"600\"\n    MinWidth=\"500\"\n    MinHeight=\"400\"\n    AllowDrop=\"True\"\n    BorderBrush=\"{DynamicResource AccentColorBrush}\"\n    BorderThickness=\"1\"\n    Closed=\"Window_Closed\"\n    Closing=\"Window_Closing\"\n    Icon=\"App.ico\"\n    Loaded=\"Window_Loaded\"\n    ResizeMode=\"CanResizeWithGrip\"\n    TitleCaps=\"False\">\n    <Controls:MetroWindow.RightWindowCommands>\n        <Controls:WindowCommands>\n            <Controls:ToggleSwitch\n                Margin=\"10,0,0,0\"\n                FontSize=\"16\"\n                Foreground=\"LightYellow\"\n                IsChecked=\"{Binding RememberWindowSizeAndPosition}\"\n                ToolTip=\"Remember windows position/size.\" />\n        </Controls:WindowCommands>\n    </Controls:MetroWindow.RightWindowCommands>\n    <Controls:MetroWindow.LeftWindowCommands>\n        <Controls:WindowCommands>\n            <Button\n                x:Name=\"btnApplicationCmds\"\n                Click=\"btnApplicationCmds_Click\"\n                ToolTip=\"Application Commands\">\n                <Image Source=\"{iconPacks:FontAwesomeImage Kind=CogSolid}\" />\n                <Button.ContextMenu>\n                    <ContextMenu>\n                        <MenuItem\n                            x:Name=\"mnuLaunchNewInstance\"\n                            Click=\"mnuLaunchNewInstance_Click\"\n                            Header=\"Launch New Instance\">\n                            <MenuItem.Icon>\n                                <Image Source=\"Resources/OpenNewWindow.png\" />\n                            </MenuItem.Icon>\n                        </MenuItem>\n                        <MenuItem\n                            x:Name=\"mnuRunasAdministrator\"\n                            Click=\"mnuRunasAdministrator_Click\"\n                            Header=\"Run as Administrator\">\n                            <MenuItem.Icon>\n                                <Image Source=\"Resources/Security.png\" />\n                            </MenuItem.Icon>\n                        </MenuItem>\n                        <MenuItem\n                            x:Name=\"mnuRegisterShellExtensions\"\n                            Click=\"mnuRegisterShellExtensions_Click\"\n                            Header=\"Register Shell Extensions\">\n                            <MenuItem.Icon>\n                                <Image Source=\"Resources/Registry.png\" />\n                            </MenuItem.Icon>\n                        </MenuItem>\n                        <MenuItem\n                            x:Name=\"mnuUnregisterShellExtensions\"\n                            Click=\"mnuUnregisterShellExtensions_Click\"\n                            Header=\"Unregister Shell Extensions\">\n                            <MenuItem.Icon>\n                                <Image Source=\"Resources/RemoveRegistry.png\" />\n                            </MenuItem.Icon>\n                        </MenuItem>\n                        <Separator />\n                        <MenuItem\n                            x:Name=\"mnuAlwaysOnTop\"\n                            Click=\"mnuAlwaysOnTop_Click\"\n                            Header=\"Always on Top\"\n                            IsCheckable=\"True\"\n                            IsChecked=\"False\">\n                            <!--<MenuItem.Icon>\n                                <iconPacks:FontAwesome Kind=\"HandshakeRegular\"></iconPacks:FontAwesome>\n                            </MenuItem.Icon>-->\n                        </MenuItem>\n                        <MenuItem\n                            x:Name=\"mnuRunatSystemsStartup\"\n                            Click=\"mnuRunatSystemsStartup_Click\"\n                            Header=\"Run at Systems Startup\"\n                            IsCheckable=\"True\">\n                            <!--<MenuItem.Icon>\n                                <iconPacks:FontAwesome Kind=\"ShieldAltSolid\"></iconPacks:FontAwesome>\n                            </MenuItem.Icon>-->\n                        </MenuItem>\n                        <MenuItem\n                            x:Name=\"mnuDarkTheme\"\n                            Click=\"mnuDarkTheme_Click\"\n                            Header=\"Enable Dark Theme\"\n                            IsCheckable=\"True\"\n                            IsChecked=\"False\">\n                            <!--<MenuItem.Icon>\n                                <iconPacks:FontAwesome Kind=\"HandshakeRegular\"></iconPacks:FontAwesome>\n                            </MenuItem.Icon>-->\n                        </MenuItem>\n\n                    </ContextMenu>\n                </Button.ContextMenu>\n            </Button>\n        </Controls:WindowCommands>\n    </Controls:MetroWindow.LeftWindowCommands>\n    <Window.Resources>\n        <ContextMenu x:Key=\"expControlPanelContextMenu\">\n            <MenuItem\n                x:Name=\"mnuResetExpander\"\n                Click=\"mnuResetExpander_Click\"\n                Header=\"Reset\" />\n        </ContextMenu>\n\n        <ContextMenu x:Key=\"TextBoxContextMenu\" Background=\"White\">\n            <MenuItem Command=\"ApplicationCommands.Copy\">\n                <MenuItem.Icon>\n                    <Image Source=\"Resources/Copy.png\" />\n                </MenuItem.Icon>\n            </MenuItem>\n            <MenuItem Command=\"ApplicationCommands.Cut\">\n                <MenuItem.Icon>\n                    <Image Source=\"Resources/Cut.png\" />\n                </MenuItem.Icon>\n            </MenuItem>\n            <MenuItem Command=\"ApplicationCommands.Paste\">\n                <MenuItem.Icon>\n                    <Image Source=\"Resources/Paste.png\" />\n                </MenuItem.Icon>\n            </MenuItem>\n        </ContextMenu>\n        <Style TargetType=\"ToolTip\">\n            <Style.Triggers>\n                <Trigger Property=\"Content\" Value=\"{x:Static sys:String.Empty}\">\n                    <Setter Property=\"Visibility\" Value=\"Collapsed\" />\n                </Trigger>\n                <Trigger Property=\"Content\" Value=\"{x:Null}\">\n                    <Setter Property=\"Visibility\" Value=\"Collapsed\" />\n                </Trigger>\n            </Style.Triggers>\n            <Style.Resources>\n                <Style TargetType=\"ContentPresenter\">\n                    <Style.Resources>\n                        <Style TargetType=\"TextBlock\">\n                            <Setter Property=\"TextWrapping\" Value=\"Wrap\" />\n                        </Style>\n                    </Style.Resources>\n                </Style>\n            </Style.Resources>\n            <Setter Property=\"MaxWidth\" Value=\"500\" />\n        </Style>\n        <Style TargetType=\"{x:Type TextBox}\">\n            <Setter Property=\"ContextMenu\" Value=\"{StaticResource TextBoxContextMenu}\" />\n        </Style>\n        <Style TargetType=\"{x:Type Button}\">\n            <Style.Resources>\n                <Style TargetType=\"{x:Type Image}\">\n                    <Style.Triggers>\n                        <Trigger Property=\"IsEnabled\" Value=\"False\">\n                            <Setter Property=\"Opacity\" Value=\"0.5\" />\n                        </Trigger>\n                    </Style.Triggers>\n                </Style>\n            </Style.Resources>\n        </Style>\n        <Style x:Key=\"GridViewColumnHeaderStyle1\" TargetType=\"{x:Type GridViewColumnHeader}\">\n            <Setter Property=\"HorizontalContentAlignment\" Value=\"Left\" />\n            <Setter Property=\"Background\" Value=\"{Binding WindowTitleBrush}\" />\n            <Setter Property=\"Foreground\" Value=\"{Binding TitleForeground}\" />\n            <Style.Triggers>\n                <Trigger Property=\"IsMouseOver\" Value=\"true\">\n                    <Setter Property=\"Background\" Value=\"Transparent\" />\n                </Trigger>\n            </Style.Triggers>\n        </Style>\n        <Style\n            x:Key=\"WaterMarkTextBoxStyle\"\n            BasedOn=\"{StaticResource {x:Type TextBox}}\"\n            TargetType=\"{x:Type TextBox}\">\n            <Setter Property=\"Template\">\n                <Setter.Value>\n                    <ControlTemplate TargetType=\"{x:Type TextBox}\">\n                        <Grid>\n                            <Border\n                                x:Name=\"Bd\"\n                                Background=\"{TemplateBinding Background}\"\n                                BorderBrush=\"{TemplateBinding BorderBrush}\"\n                                BorderThickness=\"{TemplateBinding BorderThickness}\"\n                                SnapsToDevicePixels=\"True\">\n                                <Grid>\n                                    <ScrollViewer x:Name=\"PART_ContentHost\" SnapsToDevicePixels=\"{TemplateBinding SnapsToDevicePixels}\" />\n                                    <TextBlock\n                                        x:Name=\"textBlock\"\n                                        Padding=\"2,0,0,0\"\n                                        Opacity=\"0.5\"\n                                        Text=\"{TemplateBinding Tag}\"\n                                        TextWrapping=\"Wrap\"\n                                        Visibility=\"Hidden\" />\n                                </Grid>\n                            </Border>\n                        </Grid>\n                        <ControlTemplate.Triggers>\n                            <Trigger Property=\"IsMouseOver\" Value=\"True\">\n                                <Setter Property=\"BorderBrush\" Value=\"{Binding TextBoxFocusBorderBrush}\" />\n                                <Setter Property=\"Background\" Value=\"Transparent\" />\n                            </Trigger>\n                            <MultiTrigger>\n                                <MultiTrigger.Conditions>\n                                    <Condition Property=\"Text\" Value=\"\" />\n                                </MultiTrigger.Conditions>\n                                <Setter TargetName=\"textBlock\" Property=\"Visibility\" Value=\"Visible\" />\n                            </MultiTrigger>\n                        </ControlTemplate.Triggers>\n                    </ControlTemplate>\n                </Setter.Value>\n            </Setter>\n        </Style>\n        <Style x:Key=\"StatusBarTextBlock\" TargetType=\"{x:Type TextBlock}\">\n            <Setter Property=\"TextWrapping\" Value=\"NoWrap\" />\n            <Setter Property=\"TextTrimming\" Value=\"CharacterEllipsis\" />\n            <Setter Property=\"Padding\" Value=\"2,0\" />\n        </Style>\n        <local:BoolInverterConverter x:Key=\"BoolInverterConverter1\" />\n        <local:BoolInverterConverter x:Key=\"BoolInverterConverter2\" />\n        <local:BoolToBackgroundColorConverter x:Key=\"BoolToBackgroundColorConverter1\" />\n        <local:BoolToForegroundColorConverter x:Key=\"BoolToForegroundColorConverter1\" />\n        <local:BooleanToVisibilityConverter x:Key=\"BooleanToVisibilityConverter1\" />\n        <local:BooleanToVisibilityInverterConverter x:Key=\"BooleanToVisibilityInverterConverter1\" />\n        <local:BooleanToVisibilityInverterConverterEx x:Key=\"BooleanToVisibilityInverterConverterEx1\" />\n        <local:MathConverter x:Key=\"MathConverter\" />\n\n        <Style TargetType=\"{x:Type local:ChoMruComboBox}\">\n            <Setter Property=\"Template\">\n                <Setter.Value>\n                    <ControlTemplate TargetType=\"{x:Type local:ChoMruComboBox}\">\n                        <ComboBox\n                            IsEditable=\"True\"\n                            IsTextSearchCaseSensitive=\"False\"\n                            IsTextSearchEnabled=\"True\"\n                            ItemsSource=\"{Binding MruSource, RelativeSource={RelativeSource TemplatedParent}}\"\n                            Text=\"{Binding Text, RelativeSource={RelativeSource TemplatedParent}, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\" />\n                    </ControlTemplate>\n                </Setter.Value>\n            </Setter>\n        </Style>\n\n    </Window.Resources>\n    <DockPanel>\n        <StatusBar\n            Width=\"Auto\"\n            Margin=\"5,0,5,5\"\n            DockPanel.Dock=\"Bottom\">\n            <StatusBarItem\n                Padding=\"0\"\n                VerticalContentAlignment=\"Top\"\n                Focusable=\"False\">\n                <TextBlock x:Name=\"sbAppStatus\" Style=\"{StaticResource StatusBarTextBlock}\"><Run Text=\"{Binding AppStatusText}\" /></TextBlock>\n            </StatusBarItem>\n        </StatusBar>\n        <Grid>\n            <Grid.ColumnDefinitions>\n                <ColumnDefinition Width=\"*\" />\n                <ColumnDefinition Width=\"5\" />\n                <ColumnDefinition Width=\"{Binding ControlPanelWidth, Mode=TwoWay}\">\n                    <ColumnDefinition.Style>\n                        <Style TargetType=\"{x:Type ColumnDefinition}\">\n                            <Setter Property=\"MinWidth\" Value=\"350\" />\n                            <!--  Default MinHeight  -->\n                            <Style.Triggers>\n                                <DataTrigger Binding=\"{Binding ElementName=expControlPanel, Path=IsExpanded}\" Value=\"False\">\n                                    <Setter Property=\"MinWidth\" Value=\"24\" />\n                                    <!--  MinHeight when Collapsed  -->\n                                    <Setter Property=\"MaxWidth\" Value=\"40\" />\n                                </DataTrigger>\n                                <DataTrigger Binding=\"{Binding ElementName=expControlPanel, Path=IsExpanded}\" Value=\"True\">\n                                    <Setter Property=\"MaxWidth\" Value=\"{Binding ElementName=ChoEazyCopyWindow, Path=Width, Converter={StaticResource MathConverter}, ConverterParameter=@VALUE/2}\" />\n                                </DataTrigger>\n                            </Style.Triggers>\n                        </Style>\n                    </ColumnDefinition.Style>\n                </ColumnDefinition>\n            </Grid.ColumnDefinitions>\n            <DockPanel Grid.Column=\"0\" LastChildFill=\"true\">\n                <Ribbon\n                    x:Name=\"RibbonWin\"\n                    MinWidth=\"500\"\n                    Margin=\"0,0,5,0\"\n                    Background=\"{Binding ThemeBackgroundBrush}\"\n                    ContextMenu=\"{x:Null}\"\n                    DockPanel.Dock=\"Top\"\n                    Foreground=\"Black\"\n                    Loaded=\"RibbonWin_Loaded\"\n                    SelectedIndex=\"0\">\n                    <Ribbon.ApplicationMenu>\n                        <RibbonApplicationMenu Visibility=\"Collapsed\" />\n                    </Ribbon.ApplicationMenu>\n                    <RibbonTab\n                        ContextMenu=\"{x:Null}\"\n                        Header=\"Home\"\n                        KeyTip=\"H\">\n                        <RibbonGroup\n                            x:Name=\"HomeGroup\"\n                            ContextMenu=\"{x:Null}\"\n                            Header=\"Action\">\n                            <RibbonButton\n                                x:Name=\"btnRun\"\n                                Click=\"btnRun_Click\"\n                                ContextMenu=\"{x:Null}\"\n                                KeyTip=\"R\"\n                                Label=\"Run\"\n                                LargeImageSource=\"Resources\\Run.png\" />\n                            <RibbonButton\n                                x:Name=\"btnStop\"\n                                Click=\"btnStop_Click\"\n                                ContextMenu=\"{x:Null}\"\n                                KeyTip=\"T\"\n                                Label=\"Stop\"\n                                SmallImageSource=\"Resources\\Stop.png\" />\n                            <RibbonButton\n                                x:Name=\"btnClear\"\n                                Click=\"btnClear_Click\"\n                                ContextMenu=\"{x:Null}\"\n                                KeyTip=\"E\"\n                                Label=\"Clear Output\"\n                                SmallImageSource=\"Resources\\Erase.png\" />\n                            <RibbonCheckBox\n                                x:Name=\"btnScrollOutput\"\n                                ContextMenu=\"{x:Null}\"\n                                IsChecked=\"{Binding ScrollOutput}\"\n                                KeyTip=\"L\"\n                                Label=\"Scroll Output\"\n                                SmallImageSource=\"Resources\\Scroll.png\" />\n                        </RibbonGroup>\n                        <RibbonGroup\n                            x:Name=\"FileGroup\"\n                            ContextMenu=\"{x:Null}\"\n                            Header=\"File\">\n                            <!--<RibbonButton x:Name=\"btnNewFile\" LargeImageSource=\"Resources\\NewFile.png\" Label=\"New\" KeyTip=\"N\" Click=\"btnNewFile_Click\"  ContextMenu=\"{x:Null}\"/>-->\n                            <RibbonMenuButton\n                                x:Name=\"btnNewFile\"\n                                KeyTip=\"N\"\n                                Label=\"New\"\n                                LargeImageSource=\"Resources\\NewFile.png\"\n                                SmallImageSource=\"Resources\\NewFile.png\">\n                                <RibbonMenuItem\n                                    Click=\"btnNewFile_Click\"\n                                    ContextMenu=\"{x:Null}\"\n                                    Header=\"Empty Job\"\n                                    ImageSource=\"Resources\\NewFile.png\" />\n                                <RibbonMenuItem\n                                    Click=\"btnNewSyncFile_Click\"\n                                    ContextMenu=\"{x:Null}\"\n                                    Header=\"Synchronization Job\"\n                                    ImageSource=\"Resources\\SyncJob.png\"\n                                    ToolTip=\"With the Synchronization job all new and modified files of source folder are mirrored to destination folder. Files and folders which don't exist anymore in the source folder when the job runs will be deleted in the destination folder.\" />\n                                <RibbonMenuItem\n                                    Click=\"btnNewCopyFile_Click\"\n                                    ContextMenu=\"{x:Null}\"\n                                    Header=\"Copy Job\"\n                                    ImageSource=\"Resources\\CopyJob.png\"\n                                    ToolTip=\"With the Copy job all new and modified files of source folder are also copied to destination folder. However files and folders which previously has been copied to the destination folder but doesn't exist anymore when the job runs, will be kept in the destination folder.\" />\n                                <RibbonMenuItem\n                                    Click=\"btnNewMoveFile_Click\"\n                                    ContextMenu=\"{x:Null}\"\n                                    Header=\"Move Job\"\n                                    ImageSource=\"Resources\\MoveJob.png\"\n                                    ToolTip=\"With the Move job, move all files/folders from source location to destination location. All successfull moved files/folders are removed from the source.\" />\n                            </RibbonMenuButton>\n                            <RibbonButton\n                                x:Name=\"btnOpenFile\"\n                                Click=\"btnOpenFile_Click\"\n                                ContextMenu=\"{x:Null}\"\n                                KeyTip=\"O\"\n                                Label=\"Open\"\n                                SmallImageSource=\"Resources\\OpenFile.png\" />\n                            <RibbonButton\n                                x:Name=\"btnSaveFile\"\n                                Click=\"btnSaveFile_Click\"\n                                ContextMenu=\"{x:Null}\"\n                                KeyTip=\"S\"\n                                Label=\"Save\"\n                                SmallImageSource=\"Resources\\SaveFile.png\" />\n                            <RibbonButton\n                                x:Name=\"btnSaveAsFile\"\n                                Click=\"btnSaveAsFile_Click\"\n                                ContextMenu=\"{x:Null}\"\n                                KeyTip=\"A\"\n                                Label=\"Save As\"\n                                SmallImageSource=\"Resources\\SaveAsFile.png\" />\n                        </RibbonGroup>\n                        <RibbonGroup x:Name=\"DonateGroup\" ContextMenu=\"{x:Null}\">\n                            <RibbonButton\n                                x:Name=\"btnDonate\"\n                                Click=\"BtnDonate_Click\"\n                                ContextMenu=\"{x:Null}\"\n                                KeyTip=\"D\"\n                                Label=\"Donate\"\n                                LargeImageSource=\"Resources\\Donate.png\"\n                                ToolTip=\"Your support is much appreciated.\" />\n                        </RibbonGroup>\n                        <!--<RibbonGroup VerticalAlignment=\"Center\" ContextMenu=\"{x:Null}\">\n                            <DockPanel LastChildFill=\"True\">\n                                <TextBlock DockPanel.Dock=\"Bottom\">Settings File</TextBlock>\n                                <TextBlock x:Name=\"tbSettingsName\" FontSize=\"24\" FontWeight=\"Bold\" Foreground=\"DarkBlue\"\n                                            Width=\"Auto\" VerticalAlignment=\"Stretch\" FontFamily=\"Verdana\"\n                                           Text=\"{Binding SettingsFileName}\" ToolTip=\"{Binding SettingsFilePath}\"\n                                           />\n                            </DockPanel>\n                        </RibbonGroup>-->\n                        <RibbonGroup x:Name=\"HelpGroup\" ContextMenu=\"{x:Null}\">\n                            <RibbonButton\n                                x:Name=\"btnHelp\"\n                                Click=\"btnHelp_Click\"\n                                ContextMenu=\"{x:Null}\"\n                                KeyTip=\"D\"\n                                Label=\"Help\"\n                                LargeImageSource=\"Resources\\Help.png\"\n                                ToolTip=\"RoboCopy offical help\" />\n                        </RibbonGroup>\n                    </RibbonTab>\n                </Ribbon>\n\n                <DockPanel\n                    x:Name=\"dockPanel1\"\n                    HorizontalAlignment=\"Stretch\"\n                    VerticalAlignment=\"Stretch\"\n                    FocusManager.FocusedElement=\"{Binding ElementName=txtFolder}\"\n                    LastChildFill=\"True\">\n                    <Grid Width=\"Auto\" DockPanel.Dock=\"Top\">\n                        <Grid.RowDefinitions>\n                            <RowDefinition />\n                            <RowDefinition />\n                        </Grid.RowDefinitions>\n                        <Grid.ColumnDefinitions>\n                            <ColumnDefinition />\n                        </Grid.ColumnDefinitions>\n                        <Border\n                            Grid.Row=\"0\"\n                            Margin=\"5,5,5,0\"\n                            Background=\"{Binding WindowTitleBrush}\"\n                            BorderBrush=\"{Binding WindowTitleBrush}\"\n                            BorderThickness=\"1\">\n                            <DockPanel LastChildFill=\"true\">\n                                <Label FontWeight=\"Bold\" Foreground=\"{Binding TitleForeground}\">TASK FILE:</Label>\n                                <TextBlock\n                                    VerticalAlignment=\"Center\"\n                                    Foreground=\"{Binding TitleForeground}\"\n                                    Text=\"{Binding SettingsFileName}\"\n                                    ToolTip=\"{Binding SettingsFilePath}\" />\n\n                            </DockPanel>\n                        </Border>\n\n                        <GroupBox\n                            x:Name=\"grpFolders\"\n                            Grid.Row=\"1\"\n                            Grid.Column=\"0\"\n                            Height=\"Auto\"\n                            Margin=\"5\">\n                            <GroupBox.Header>\n                                <DockPanel LastChildFill=\"True\">\n                                    <Button\n                                        xmlns:Controls=\"clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro\"\n                                        xmlns:Converters=\"clr-namespace:MahApps.Metro.Converters;assembly=MahApps.Metro\"\n                                        x:Name=\"btnSwapDir\"\n                                        Click=\"btnSwapDir_Click\"\n                                        Content=\"Swap Directories\"\n                                        DockPanel.Dock=\"Right\"\n                                        Style=\"{DynamicResource MetroButton}\" />\n                                    <TextBlock\n                                        xmlns:Controls=\"clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro\"\n                                        xmlns:Converters=\"clr-namespace:MahApps.Metro.Converters;assembly=MahApps.Metro\"\n                                        VerticalAlignment=\"Center\"\n                                        Text=\"CHOOSE FOLDERS\">\n                                        <TextBlock.Foreground>\n                                            <MultiBinding Converter=\"{x:Static Converters:BackgroundToForegroundConverter.Instance}\">\n                                                <Binding\n                                                    Mode=\"OneWay\"\n                                                    Path=\"Background\"\n                                                    RelativeSource=\"{RelativeSource AncestorType=GroupBox}\" />\n                                                <Binding\n                                                    Mode=\"OneWay\"\n                                                    Path=\"(Controls:GroupBoxHelper.HeaderForeground)\"\n                                                    RelativeSource=\"{RelativeSource AncestorType=GroupBox}\" />\n                                            </MultiBinding>\n                                        </TextBlock.Foreground>\n                                    </TextBlock>\n                                </DockPanel>\n                            </GroupBox.Header>\n\n                            <Grid Width=\"Auto\" Height=\"Auto\">\n                                <Grid.ColumnDefinitions>\n                                    <ColumnDefinition Width=\"35*\" />\n                                    <ColumnDefinition Width=\"145*\" />\n                                    <ColumnDefinition Width=\"368*\" />\n                                    <ColumnDefinition Width=\"20\" />\n                                </Grid.ColumnDefinitions>\n                                <Grid.RowDefinitions>\n                                    <RowDefinition />\n                                    <RowDefinition />\n                                    <RowDefinition />\n                                    <RowDefinition />\n                                </Grid.RowDefinitions>\n                                <Label\n                                    Grid.Row=\"0\"\n                                    Grid.ColumnSpan=\"2\"\n                                    FontWeight=\"Bold\">\n                                    Source Directory\n                                </Label>\n                                <TextBox\n                                    x:Name=\"txtSourceDirectory\"\n                                    Grid.Row=\"1\"\n                                    Grid.Column=\"0\"\n                                    Grid.ColumnSpan=\"3\"\n                                    Margin=\"1\"\n                                    VerticalAlignment=\"Stretch\"\n                                    BorderBrush=\"{Binding SourceDirStatus, Converter={local:SourceDirBorderColorConverter}}\"\n                                    TabIndex=\"0\"\n                                    Text=\"{Binding Path=AppSettings.SourceDirectory, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n                                    ToolTip=\"{Binding Path=SourceDirTooltip}\" />\n                                <Button\n                                    x:Name=\"btnSourceDirBrowse\"\n                                    Grid.Row=\"1\"\n                                    Grid.Column=\"3\"\n                                    Margin=\"1,0,1,2\"\n                                    VerticalAlignment=\"Bottom\"\n                                    Click=\"btnSourceDirBrowse_Click\"\n                                    Style=\"{StaticResource {x:Static ToolBar.ButtonStyleKey}}\"\n                                    TabIndex=\"1\"\n                                    ToolTip=\"Choose source directory...\">\n                                    <Image Source=\"Resources/OpenFolder.png\">\n                                        <Image.Style>\n                                            <Style TargetType=\"{x:Type Image}\">\n                                                <Style.Triggers>\n                                                    <Trigger Property=\"IsEnabled\" Value=\"False\">\n                                                        <Setter Property=\"Opacity\" Value=\"0.5\" />\n                                                    </Trigger>\n                                                </Style.Triggers>\n                                            </Style>\n                                        </Image.Style>\n                                    </Image>\n                                </Button>\n                                <Label\n                                    Grid.Row=\"2\"\n                                    Grid.ColumnSpan=\"2\"\n                                    FontWeight=\"Bold\">\n                                    Destination Directory\n                                </Label>\n                                <TextBox\n                                    x:Name=\"txtDestDirectory\"\n                                    Grid.Row=\"3\"\n                                    Grid.Column=\"0\"\n                                    Grid.ColumnSpan=\"3\"\n                                    Margin=\"1\"\n                                    TabIndex=\"2\"\n                                    Text=\"{Binding Path=AppSettings.DestDirectory, UpdateSourceTrigger=PropertyChanged}\"\n                                    ToolTip=\"Destination directory.\" />\n                                <Button\n                                    x:Name=\"btnDestDirBrowse\"\n                                    Grid.Row=\"3\"\n                                    Grid.Column=\"3\"\n                                    Margin=\"1,2,1,1\"\n                                    Click=\"btnDestDirBrowse_Click\"\n                                    Style=\"{StaticResource {x:Static ToolBar.ButtonStyleKey}}\"\n                                    TabIndex=\"3\"\n                                    ToolTip=\"Choose destination directory...\">\n                                    <Image Source=\"Resources/OpenFolder.png\">\n                                        <Image.Style>\n                                            <Style TargetType=\"{x:Type Image}\">\n                                                <Style.Triggers>\n                                                    <Trigger Property=\"IsEnabled\" Value=\"False\">\n                                                        <Setter Property=\"Opacity\" Value=\"0.5\" />\n                                                    </Trigger>\n                                                </Style.Triggers>\n                                            </Style>\n                                        </Image.Style>\n                                    </Image>\n                                </Button>\n                            </Grid>\n                        </GroupBox>\n                    </Grid>\n                    <GroupBox\n                        DockPanel.Dock=\"Bottom\"\n                        IsEnabled=\"{Binding IsNotRunning}\"\n                        Visibility=\"{Binding Path=AppSettings.ListOnly, Converter={StaticResource BooleanToVisibilityInverterConverter1}}\">\n                        <GroupBox.Header>\n                            <DockPanel LastChildFill=\"True\">\n                                <CheckBox\n                                    xmlns:Controls=\"clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro\"\n                                    xmlns:Converters=\"clr-namespace:MahApps.Metro.Converters;assembly=MahApps.Metro\"\n                                    Content=\"SHOW PROGRESS\"\n                                    DockPanel.Dock=\"Right\"\n                                    IsChecked=\"{Binding Path=AppSettings.ShowRoboCopyProgress}\"\n                                    Style=\"{DynamicResource MetroCheckBox}\">\n                                    <CheckBox.Foreground>\n                                        <MultiBinding Converter=\"{x:Static Converters:BackgroundToForegroundConverter.Instance}\">\n                                            <Binding\n                                                Mode=\"OneWay\"\n                                                Path=\"Background\"\n                                                RelativeSource=\"{RelativeSource AncestorType=GroupBox}\" />\n                                            <Binding\n                                                Mode=\"OneWay\"\n                                                Path=\"(Controls:GroupBoxHelper.HeaderForeground)\"\n                                                RelativeSource=\"{RelativeSource AncestorType=GroupBox}\" />\n                                        </MultiBinding>\n                                    </CheckBox.Foreground>\n                                </CheckBox>\n                                <TextBlock\n                                    xmlns:Controls=\"clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro\"\n                                    xmlns:Converters=\"clr-namespace:MahApps.Metro.Converters;assembly=MahApps.Metro\"\n                                    VerticalAlignment=\"Center\"\n                                    Text=\"ROBOCOPY PROGRESS\">\n                                    <TextBlock.Foreground>\n                                        <MultiBinding Converter=\"{x:Static Converters:BackgroundToForegroundConverter.Instance}\">\n                                            <Binding\n                                                Mode=\"OneWay\"\n                                                Path=\"Background\"\n                                                RelativeSource=\"{RelativeSource AncestorType=GroupBox}\" />\n                                            <Binding\n                                                Mode=\"OneWay\"\n                                                Path=\"(Controls:GroupBoxHelper.HeaderForeground)\"\n                                                RelativeSource=\"{RelativeSource AncestorType=GroupBox}\" />\n                                        </MultiBinding>\n                                    </TextBlock.Foreground>\n                                </TextBlock>\n                            </DockPanel>\n                        </GroupBox.Header>\n\n                        <DockPanel x:Name=\"dpRoboCopyProgress\" LastChildFill=\"true\">\n                            <TextBlock\n                                DockPanel.Dock=\"Top\"\n                                Text=\"Robocopy progress disabled.\"\n                                Visibility=\"{Binding Path=AppSettings.ShowRoboCopyProgress, Converter={StaticResource BooleanToVisibilityInverterConverter1}}\" />\n                            <TextBlock\n                                DockPanel.Dock=\"Top\"\n                                Text=\"{Binding RobocopyProgresssText}\"\n                                Visibility=\"{Binding Path=AppSettings.ShowRoboCopyProgress, Converter={StaticResource BooleanToVisibilityConverter1}}\" />\n                            <Grid Visibility=\"{Binding Path=AppSettings.ShowRoboCopyProgress, Converter={StaticResource BooleanToVisibilityConverter1}}\">\n                                <ProgressBar\n                                    x:Name=\"pbar\"\n                                    Height=\"15\"\n                                    Margin=\"0,5,0,5\"\n                                    HorizontalAlignment=\"Stretch\"\n                                    Maximum=\"100\"\n                                    Minimum=\"0\"\n                                    Value=\"{Binding RobocopyProgresssBarValue}\" />\n                                <TextBlock\n                                    HorizontalAlignment=\"Center\"\n                                    VerticalAlignment=\"Center\"\n                                    Foreground=\"White\"\n                                    Text=\"{Binding ElementName=pbar, Path=Value, StringFormat={}{0:0}%}\" />\n                            </Grid>\n                        </DockPanel>\n                    </GroupBox>\n                    <Grid Width=\"Auto\">\n                        <Grid.ColumnDefinitions>\n                            <ColumnDefinition />\n                        </Grid.ColumnDefinitions>\n                        <Grid.RowDefinitions>\n                            <RowDefinition Height=\"100\" MinHeight=\"100\" />\n                            <RowDefinition Height=\"Auto\" />\n                            <RowDefinition Height=\"*\" />\n                        </Grid.RowDefinitions>\n                        <GroupBox\n                            Grid.Row=\"0\"\n                            Margin=\"5,0,5,0\"\n                            HorizontalAlignment=\"Stretch\"\n                            VerticalAlignment=\"Stretch\">\n                            <GroupBox.Header>\n                                <DockPanel LastChildFill=\"True\">\n                                    <CheckBox\n                                        xmlns:Controls=\"clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro\"\n                                        xmlns:Converters=\"clr-namespace:MahApps.Metro.Converters;assembly=MahApps.Metro\"\n                                        Content=\"TEST RUN\"\n                                        DockPanel.Dock=\"Right\"\n                                        IsChecked=\"{Binding Path=AppSettings.ListOnly}\"\n                                        Style=\"{DynamicResource MetroCheckBox}\">\n                                        <CheckBox.Foreground>\n                                            <MultiBinding Converter=\"{x:Static Converters:BackgroundToForegroundConverter.Instance}\">\n                                                <Binding\n                                                    Mode=\"OneWay\"\n                                                    Path=\"Background\"\n                                                    RelativeSource=\"{RelativeSource AncestorType=GroupBox}\" />\n                                                <Binding\n                                                    Mode=\"OneWay\"\n                                                    Path=\"(Controls:GroupBoxHelper.HeaderForeground)\"\n                                                    RelativeSource=\"{RelativeSource AncestorType=GroupBox}\" />\n                                            </MultiBinding>\n                                        </CheckBox.Foreground>\n                                    </CheckBox>\n                                    <TextBlock\n                                        xmlns:Controls=\"clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro\"\n                                        xmlns:Converters=\"clr-namespace:MahApps.Metro.Converters;assembly=MahApps.Metro\"\n                                        VerticalAlignment=\"Center\"\n                                        Text=\"ROBOCOPY COMMAND\">\n                                        <TextBlock.Foreground>\n                                            <MultiBinding Converter=\"{x:Static Converters:BackgroundToForegroundConverter.Instance}\">\n                                                <Binding\n                                                    Mode=\"OneWay\"\n                                                    Path=\"Background\"\n                                                    RelativeSource=\"{RelativeSource AncestorType=GroupBox}\" />\n                                                <Binding\n                                                    Mode=\"OneWay\"\n                                                    Path=\"(Controls:GroupBoxHelper.HeaderForeground)\"\n                                                    RelativeSource=\"{RelativeSource AncestorType=GroupBox}\" />\n                                            </MultiBinding>\n                                        </TextBlock.Foreground>\n                                    </TextBlock>\n                                </DockPanel>\n                            </GroupBox.Header>\n\n                            <DockPanel LastChildFill=\"True\">\n                                <TextBox\n                                    Name=\"txtRoboCopyCmdEx\"\n                                    Margin=\"0,3,0,2\"\n                                    HorizontalAlignment=\"Stretch\"\n                                    VerticalAlignment=\"Stretch\"\n                                    IsReadOnly=\"True\"\n                                    TabIndex=\"24\"\n                                    TextWrapping=\"Wrap\"\n                                    VerticalScrollBarVisibility=\"Auto\"\n                                    Visibility=\"Collapsed\" />\n                                <TextBox\n                                    Name=\"txtRoboCopyCmd\"\n                                    Margin=\"0,3,0,2\"\n                                    HorizontalAlignment=\"Stretch\"\n                                    VerticalAlignment=\"Stretch\"\n                                    IsReadOnly=\"True\"\n                                    TabIndex=\"24\"\n                                    TextWrapping=\"Wrap\"\n                                    VerticalScrollBarVisibility=\"Auto\" />\n                            </DockPanel>\n                        </GroupBox>\n                        <GridSplitter\n                            Grid.Row=\"1\"\n                            Height=\"1\"\n                            Margin=\"5,5,5,0\"\n                            HorizontalAlignment=\"Stretch\"\n                            IsTabStop=\"False\"\n                            ResizeDirection=\"Rows\" />\n                        <GroupBox\n                            Grid.Row=\"2\"\n                            Margin=\"5,0,5,5\"\n                            VerticalAlignment=\"Stretch\">\n                            <GroupBox.Header>\n                                <DockPanel LastChildFill=\"True\">\n                                    <CheckBox\n                                        xmlns:Controls=\"clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro\"\n                                        xmlns:Converters=\"clr-namespace:MahApps.Metro.Converters;assembly=MahApps.Metro\"\n                                        Content=\"SHOW LINE NUMBERS\"\n                                        DockPanel.Dock=\"Right\"\n                                        IsChecked=\"{Binding Path=AppSettings.ShowOutputLineNumbers}\"\n                                        Style=\"{DynamicResource MetroCheckBox}\">\n                                        <CheckBox.Foreground>\n                                            <MultiBinding Converter=\"{x:Static Converters:BackgroundToForegroundConverter.Instance}\">\n                                                <Binding\n                                                    Mode=\"OneWay\"\n                                                    Path=\"Background\"\n                                                    RelativeSource=\"{RelativeSource AncestorType=GroupBox}\" />\n                                                <Binding\n                                                    Mode=\"OneWay\"\n                                                    Path=\"(Controls:GroupBoxHelper.HeaderForeground)\"\n                                                    RelativeSource=\"{RelativeSource AncestorType=GroupBox}\" />\n                                            </MultiBinding>\n                                        </CheckBox.Foreground>\n                                    </CheckBox>\n                                    <TextBlock\n                                        xmlns:Controls=\"clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro\"\n                                        xmlns:Converters=\"clr-namespace:MahApps.Metro.Converters;assembly=MahApps.Metro\"\n                                        VerticalAlignment=\"Center\"\n                                        Text=\"OUTPUT\">\n                                        <TextBlock.Foreground>\n                                            <MultiBinding Converter=\"{x:Static Converters:BackgroundToForegroundConverter.Instance}\">\n                                                <Binding\n                                                    Mode=\"OneWay\"\n                                                    Path=\"Background\"\n                                                    RelativeSource=\"{RelativeSource AncestorType=GroupBox}\" />\n                                                <Binding\n                                                    Mode=\"OneWay\"\n                                                    Path=\"(Controls:GroupBoxHelper.HeaderForeground)\"\n                                                    RelativeSource=\"{RelativeSource AncestorType=GroupBox}\" />\n                                            </MultiBinding>\n                                        </TextBlock.Foreground>\n                                    </TextBlock>\n                                </DockPanel>\n                            </GroupBox.Header>\n                            <avalonEdit:TextEditor\n                                xmlns:avalonEdit=\"http://icsharpcode.net/sharpdevelop/avalonedit\"\n                                Name=\"txtStatus\"\n                                FontFamily=\"Courier New\"\n                                FontSize=\"10pt\"\n                                Foreground=\"{Binding ControlForegroundBrush}\"\n                                HorizontalScrollBarVisibility=\"Auto\"\n                                KeyDown=\"txtStatus_KeyDown\"\n                                ShowLineNumbers=\"{Binding Path=AppSettings.ShowOutputLineNumbers}\"\n                                SyntaxHighlighting=\"DOS\"\n                                TabIndex=\"25\"\n                                VerticalScrollBarVisibility=\"Auto\" />\n                            <!--\n                                TextBox\n                                Margin=\"0,3,0,2\"\n                                VerticalAlignment=\"Stretch\"\n                                x:Name=\"txtStatus\"\n                                IsReadOnly=\"True\"\n                                TabIndex=\"25\" FontFamily=\"Courier New\" VerticalScrollBarVisibility=\"Auto\" HorizontalScrollBarVisibility=\"Auto\" /\n                            -->\n                        </GroupBox>\n                    </Grid>\n                </DockPanel>\n\n            </DockPanel>\n            <Expander\n                x:Name=\"expControlPanel\"\n                Grid.Column=\"2\"\n                ContextMenu=\"{StaticResource expControlPanelContextMenu}\"\n                ExpandDirection=\"Left\"\n                IsExpanded=\"True\">\n                <Expander.Header>\n                    <TextBlock\n                        FontWeight=\"Bold\"\n                        Foreground=\"White\"\n                        Text=\"Control Panel\">\n                        <TextBlock.LayoutTransform>\n                            <RotateTransform Angle=\"90\" />\n                        </TextBlock.LayoutTransform>\n                    </TextBlock>\n                </Expander.Header>\n\n                <TabControl\n                    x:Name=\"tabControlPanel\"\n                    Grid.Column=\"2\"\n                    TabStripPlacement=\"Bottom\">\n                    <TabControl.Resources>\n                        <SolidColorBrush x:Key=\"RedBrush\" Color=\"Red\" />\n                        <SolidColorBrush x:Key=\"GreenBrush\" Color=\"Green\" />\n                        <SolidColorBrush x:Key=\"SolidBorderBrush\" Color=\"#888\" />\n                        <SolidColorBrush x:Key=\"DisabledBackgroundBrush\" Color=\"#EEE\" />\n                        <SolidColorBrush x:Key=\"DisabledBorderBrush\" Color=\"#AAA\" />\n                        <SolidColorBrush x:Key=\"DisabledForegroundBrush\" Color=\"#888\" />\n                        <Style TargetType=\"{x:Type TabItem}\">\n                            <Setter Property=\"Template\">\n                                <Setter.Value>\n                                    <ControlTemplate TargetType=\"{x:Type TabItem}\">\n                                        <Grid>\n                                            <Border\n                                                Name=\"Border\"\n                                                Margin=\"0,0,-4,0\"\n                                                Background=\"{Binding TabControlBackgroundBrush}\"\n                                                BorderBrush=\"{StaticResource SolidBorderBrush}\"\n                                                BorderThickness=\"1,1,1,1\"\n                                                CornerRadius=\"0,0,2,12\">\n                                                <ContentPresenter\n                                                    x:Name=\"ContentSite\"\n                                                    Margin=\"12,2,12,2\"\n                                                    HorizontalAlignment=\"Center\"\n                                                    VerticalAlignment=\"Center\"\n                                                    ContentSource=\"Header\"\n                                                    RecognizesAccessKey=\"True\" />\n                                            </Border>\n                                        </Grid>\n                                        <ControlTemplate.Triggers>\n                                            <Trigger Property=\"IsSelected\" Value=\"True\">\n                                                <Setter Property=\"Panel.ZIndex\" Value=\"100\" />\n                                                <Setter TargetName=\"Border\" Property=\"Background\" Value=\"{Binding TabControlForegroundBrush}\" />\n                                                <Setter TargetName=\"Border\" Property=\"BorderThickness\" Value=\"1,1,1,0\" />\n                                                <Setter Property=\"Foreground\" Value=\"{Binding TabControlBackgroundBrush}\" />\n                                            </Trigger>\n                                            <Trigger Property=\"IsSelected\" Value=\"False\">\n                                                <Setter TargetName=\"Border\" Property=\"Background\" Value=\"{Binding TabControlBackgroundBrush}\" />\n                                                <Setter Property=\"Foreground\" Value=\"{Binding TabControlForegroundBrush}\" />\n                                            </Trigger>\n                                            <Trigger Property=\"IsEnabled\" Value=\"False\">\n                                                <Setter TargetName=\"Border\" Property=\"Background\" Value=\"{StaticResource DisabledBackgroundBrush}\" />\n                                                <Setter TargetName=\"Border\" Property=\"BorderBrush\" Value=\"{StaticResource DisabledBorderBrush}\" />\n                                                <Setter Property=\"Foreground\" Value=\"{StaticResource DisabledForegroundBrush}\" />\n                                            </Trigger>\n                                        </ControlTemplate.Triggers>\n                                    </ControlTemplate>\n                                </Setter.Value>\n                            </Setter>\n                            <Setter Property=\"HeaderTemplate\">\n                                <Setter.Value>\n                                    <DataTemplate>\n                                        <ContentPresenter Content=\"{TemplateBinding Content}\" TextBlock.FontWeight=\"Bold\">\n                                            <ContentPresenter.LayoutTransform>\n                                                <RotateTransform Angle=\"0\" />\n                                            </ContentPresenter.LayoutTransform>\n                                        </ContentPresenter>\n                                    </DataTemplate>\n                                </Setter.Value>\n                            </Setter>\n                        </Style>\n                    </TabControl.Resources>\n                    <TabItem\n                        x:Name=\"tabRoboCopyOptionsItem\"\n                        Header=\"RoboCopy Options\"\n                        ToolTip=\"\">\n                        <DockPanel LastChildFill=\"True\">\n                            <TextBlock\n                                x:Name=\"txtPropertyGridWaterMark\"\n                                DockPanel.Dock=\"Top\"\n                                FontSize=\"20\"\n                                FontWeight=\"Bold\"\n                                Foreground=\"Red\"\n                                Text=\"{Binding PropertyGridTooltip}\"\n                                TextWrapping=\"WrapWithOverflow\"\n                                ToolTip=\"{Binding PropertyGridTooltip}\"\n                                Visibility=\"Collapsed\" />\n                            <sfw:PropertyGrid\n                                xmlns:sfw=\"clr-namespace:SoftFluent.Windows;assembly=SoftFluent.Windows\"\n                                Name=\"pgAppSettings\"\n                                Margin=\"-3\"\n                                Background=\"{Binding PGControlBackgroundBrush}\"\n                                BorderBrush=\"{Binding PGControlBorderBrush}\"\n                                DecamelizePropertiesDisplayNames=\"false\"\n                                Foreground=\"{Binding PGControlForegroundBrush}\"\n                                GroupByCategory=\"True\"\n                                HelpVisible=\"True\"\n                                SelectedObject=\"{Binding AppSettings}\" />\n                            <!--<local:ChoPropertyGrid  Margin=\"-3\" VerticalAlignment=\"Stretch\" x:Name=\"pgAppSettings\"\n                                                    SelectedObject=\"{Binding AppSettings}\"\n                                                         ToolTip=\"{Binding PropertyGridTooltip}\" Style=\"{x:Null}\"/>-->\n                            <!--<local:ExtendedPropertyGrid  Margin=\"-3\" VerticalAlignment=\"Stretch\" x:Name=\"pgAppSettings\"\n                                                    SelectedObject=\"{Binding AppSettings}\" SelectedObjectName=\"\" ShowTitle=\"False\"\n                                           ShowDescriptionByTooltip=\"True\" FilterWatermark=\"{Binding PropertyGridTooltip}\"\n                                                         ToolTip=\"{Binding PropertyGridTooltip}\" Style=\"{x:Null}\"/>-->\n                        </DockPanel>\n                    </TabItem>\n                    <TabItem\n                        x:Name=\"tabBackupTasks\"\n                        Header=\"Backup Tasks\"\n                        ToolTip=\"\">\n                        <GroupBox\n                            x:Name=\"grpBackupTasks\"\n                            Margin=\"-3\"\n                            Header=\"Backup Tasks\">\n                            <DockPanel LastChildFill=\"True\">\n                                <DockPanel HorizontalAlignment=\"Stretch\" DockPanel.Dock=\"Top\">\n                                    <TextBlock DockPanel.Dock=\"Top\" FontWeight=\"Bold\">Directory</TextBlock>\n                                    <DockPanel\n                                        HorizontalAlignment=\"Stretch\"\n                                        DockPanel.Dock=\"Bottom\"\n                                        LastChildFill=\"True\">\n                                        <Button\n                                            x:Name=\"btnFindBackupTaskDirectoryInFileExplorer\"\n                                            Width=\"20\"\n                                            Height=\"20\"\n                                            VerticalAlignment=\"Center\"\n                                            Click=\"btnFindBackupTaskDirectoryInFileExplorer_Click\"\n                                            DockPanel.Dock=\"Right\"\n                                            IsEnabled=\"{Binding BackupTaskDirStatus}\"\n                                            Style=\"{StaticResource {x:Static ToolBar.ButtonStyleKey}}\"\n                                            ToolTip=\"Find backup task directory in file explorer\">\n                                            <Border>\n                                                <Image Source=\"Resources/Search.png\">\n                                                    <Image.Style>\n                                                        <Style TargetType=\"{x:Type Image}\">\n                                                            <Style.Triggers>\n                                                                <Trigger Property=\"IsEnabled\" Value=\"False\">\n                                                                    <Setter Property=\"Opacity\" Value=\"0.5\" />\n                                                                </Trigger>\n                                                            </Style.Triggers>\n                                                        </Style>\n                                                    </Image.Style>\n                                                </Image>\n                                            </Border>\n                                        </Button>\n                                        <Button\n                                            x:Name=\"btnRefreshBackupTasks\"\n                                            Width=\"20\"\n                                            Margin=\"1,0,1,2\"\n                                            VerticalAlignment=\"Bottom\"\n                                            Click=\"btnRefreshBackupTasks_Click\"\n                                            DockPanel.Dock=\"Right\"\n                                            IsEnabled=\"{Binding BackupTaskDirStatus}\"\n                                            Style=\"{StaticResource {x:Static ToolBar.ButtonStyleKey}}\"\n                                            ToolTip=\"Reload backup tasks...\">\n                                            <Image Source=\"Resources/Refresh.png\">\n                                                <Image.Style>\n                                                    <Style TargetType=\"{x:Type Image}\">\n                                                        <Style.Triggers>\n                                                            <Trigger Property=\"IsEnabled\" Value=\"False\">\n                                                                <Setter Property=\"Opacity\" Value=\"0.5\" />\n                                                            </Trigger>\n                                                        </Style.Triggers>\n                                                    </Style>\n                                                </Image.Style>\n                                            </Image>\n                                        </Button>\n                                        <Button\n                                            x:Name=\"btnBackupTaskDirectory\"\n                                            Width=\"20\"\n                                            Margin=\"1,0,1,2\"\n                                            VerticalAlignment=\"Bottom\"\n                                            Click=\"btnBackupTaskDirectory_Click\"\n                                            DockPanel.Dock=\"Right\"\n                                            Style=\"{StaticResource {x:Static ToolBar.ButtonStyleKey}}\"\n                                            ToolTip=\"Choose backup tasks directory...\">\n                                            <Image Source=\"Resources/OpenFolder.png\">\n                                                <Image.Style>\n                                                    <Style TargetType=\"{x:Type Image}\">\n                                                        <Style.Triggers>\n                                                            <Trigger Property=\"IsEnabled\" Value=\"False\">\n                                                                <Setter Property=\"Opacity\" Value=\"0.5\" />\n                                                            </Trigger>\n                                                        </Style.Triggers>\n                                                    </Style>\n                                                </Image.Style>\n                                            </Image>\n                                        </Button>\n                                        <local:ChoMruComboBox\n                                            HorizontalAlignment=\"Stretch\"\n                                            Background=\"{Binding BackupTaskDirStatus, Converter={StaticResource BoolToBackgroundColorConverter1}}\"\n                                            Foreground=\"{Binding BackupTaskDirStatus, Converter={StaticResource BoolToForegroundColorConverter1}}\"\n                                            MruSource=\"{Binding RecentNumbersList}\"\n                                            Text=\"{Binding Path=BackupTaskDirectory, UpdateSourceTrigger=PropertyChanged, Mode=TwoWay}\" />\n\n                                        <!--TextBox HorizontalAlignment=\"Stretch\"\n                                            x:Name=\"txtBackupTasksDirectory\"\n                                            Margin=\"1\"\n                                            TabIndex=\"0\"\n                                            Style=\"{StaticResource WaterMarkTextBoxStyle}\"\n                                            ToolTip=\"{Binding BackupTaskDirTooltip}\"\n                                                Text=\"{Binding Path=BackupTaskDirectory, UpdateSourceTrigger=PropertyChanged}\"\n                                                        Background=\"{Binding BackupTaskDirStatus, Converter={StaticResource BoolToBackgroundColorConverter1}}\"\n                                                        Foreground=\"{Binding BackupTaskDirStatus, Converter={StaticResource BoolToForegroundColorConverter1}}\"\n                                            >\n                                        </TextBox-->\n                                    </DockPanel>\n                                </DockPanel>\n\n                                <DockPanel LastChildFill=\"True\">\n                                    <DockPanel DockPanel.Dock=\"Bottom\" LastChildFill=\"True\">\n                                        <StackPanel\n                                            Margin=\"0,5,0,0\"\n                                            VerticalAlignment=\"Bottom\"\n                                            DockPanel.Dock=\"Right\"\n                                            Orientation=\"Vertical\">\n                                            <Button\n                                                x:Name=\"btnCloneTask\"\n                                                Margin=\"5,0,0,0\"\n                                                Click=\"btnCloneTask_Click\"\n                                                Content=\"CLONE\"\n                                                DockPanel.Dock=\"Right\"\n                                                IsEnabled=\"{Binding CloneTaskEnabled}\"\n                                                Style=\"{DynamicResource MetroButton}\"\n                                                ToolTip=\"Clone task\" />\n                                            <Button\n                                                x:Name=\"btnDeleteTask\"\n                                                Margin=\"5,5,0,0\"\n                                                Click=\"btnDeleteTask_Click\"\n                                                Content=\"DELETE\"\n                                                DockPanel.Dock=\"Right\"\n                                                IsEnabled=\"{Binding DeleteTaskEnabled}\"\n                                                Style=\"{DynamicResource MetroButton}\"\n                                                ToolTip=\"Delete task\" />\n                                            <Button\n                                                x:Name=\"btnQueueTask\"\n                                                Margin=\"5,5,0,0\"\n                                                Click=\"btnQueueTask_Click\"\n                                                Content=\"QUEUE\"\n                                                DockPanel.Dock=\"Right\"\n                                                IsEnabled=\"{Binding QueueTaskEnabled}\"\n                                                Style=\"{DynamicResource MetroButton}\"\n                                                ToolTip=\"Queue task\" />\n                                        </StackPanel>\n                                        <DockPanel LastChildFill=\"True\">\n                                            <TextBlock DockPanel.Dock=\"Top\" FontWeight=\"Bold\">Backup Task Comments</TextBlock>\n                                            <TextBox\n                                                x:Name=\"txtTaskComments\"\n                                                Height=\"70\"\n                                                Margin=\"0,5,0,0\"\n                                                Text=\"{Binding Path=AppSettings.Comments, UpdateSourceTrigger=PropertyChanged}\"\n                                                TextWrapping=\"WrapWithOverflow\"\n                                                ToolTip=\"Backup Task Comments\"\n                                                VerticalScrollBarVisibility=\"Auto\" />\n                                        </DockPanel>\n                                    </DockPanel>\n                                    <ListView\n                                        x:Name=\"lstBackupTasks\"\n                                        Margin=\"0,5,0,0\"\n                                        VerticalAlignment=\"Stretch\"\n                                        local:ChoGridViewColumnVisibilityManager.Enabled=\"True\"\n                                        local:ChoGridViewSort.AutoSort=\"True\"\n                                        BorderThickness=\"1\"\n                                        DisplayMemberPath=\"FileName\"\n                                        FontFamily=\"Courier New\"\n                                        FontSize=\"12\"\n                                        ItemsSource=\"{Binding BackupTaskInfos}\"\n                                        PreviewKeyUp=\"lstBackupTasks_PreviewKeyUp\"\n                                        SelectedItem=\"{Binding SelectedBackupTaskItem}\"\n                                        SelectedValue=\"{Binding SelectedBackupTaskFilePath}\"\n                                        SelectedValuePath=\"FilePath\"\n                                        ToolTip=\"\">\n                                        <ListView.Resources>\n                                            <ContextMenu x:Key=\"grdHeaderContextMenu\">\n                                                <MenuItem\n                                                    x:Name=\"mnuDateCreated\"\n                                                    Header=\"Date Created\"\n                                                    IsCheckable=\"true\"\n                                                    IsChecked=\"{Binding DateCreated}\" />\n                                                <MenuItem\n                                                    x:Name=\"mnuDateModified\"\n                                                    Header=\"Date Modified\"\n                                                    IsCheckable=\"true\"\n                                                    IsChecked=\"{Binding DateModified}\" />\n                                                <Separator />\n                                                <MenuItem Header=\"Clone Options\">\n                                                    <MenuItem\n                                                        Header=\"Keep Date Created\"\n                                                        IsCheckable=\"true\"\n                                                        IsChecked=\"{Binding KeepDateCreated}\" />\n                                                    <MenuItem\n                                                        Header=\"Keep Date Modified\"\n                                                        IsCheckable=\"true\"\n                                                        IsChecked=\"{Binding KeepDateModified}\" />\n                                                </MenuItem>\n                                                <Separator />\n                                                <MenuItem\n                                                    x:Name=\"mnuColumnToFit\"\n                                                    Click=\"mnuColumnToFit_Click\"\n                                                    Header=\"Size Column to Fit\" />\n                                                <MenuItem\n                                                    x:Name=\"mnuAllColumnsToFit\"\n                                                    Click=\"mnuAllColumnsToFit_Click\"\n                                                    Header=\"Size All Columns to Fit\" />\n                                                <Separator />\n                                                <MenuItem\n                                                    Header=\"Confirm on Delete Task\"\n                                                    IsCheckable=\"True\"\n                                                    IsChecked=\"{Binding ConfirmOnDelete}\" />\n                                                <MenuItem\n                                                    Header=\"Watch for Changes\"\n                                                    IsCheckable=\"True\"\n                                                    IsChecked=\"{Binding WatchForChanges}\" />\n                                            </ContextMenu>\n                                            <ContextMenu x:Key=\"grdItemContextMenu\">\n                                                <MenuItem\n                                                    x:Name=\"mnuCloneTask\"\n                                                    Click=\"mnuCloneTask_Click\"\n                                                    Header=\"Clone Task\"\n                                                    InputGestureText=\"Ctrl+V\" />\n                                                <MenuItem\n                                                    x:Name=\"mnuDeleteTask\"\n                                                    Click=\"mnuDeleteTask_Click\"\n                                                    Header=\"Delete Task\"\n                                                    InputGestureText=\"Del\" />\n                                                <MenuItem\n                                                    x:Name=\"mnuQueueTask\"\n                                                    Click=\"mnuQueueTask_Click\"\n                                                    Header=\"Queue Task\"\n                                                    InputGestureText=\"Ctrl+Q\" />\n                                                <Separator />\n                                                <MenuItem Header=\"Clone Options\">\n                                                    <MenuItem\n                                                        Header=\"Keep Date Created\"\n                                                        IsCheckable=\"true\"\n                                                        IsChecked=\"{Binding KeepDateCreated, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type Window}}}\" />\n                                                    <MenuItem\n                                                        Header=\"Keep Date Modified\"\n                                                        IsCheckable=\"true\"\n                                                        IsChecked=\"{Binding KeepDateModified, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type Window}}}\" />\n                                                </MenuItem>\n                                                <Separator />\n                                                <MenuItem\n                                                    Header=\"Confirm on Delete Task\"\n                                                    IsCheckable=\"True\"\n                                                    IsChecked=\"{Binding ConfirmOnDelete, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type Window}}}\" />\n                                                <MenuItem\n                                                    Header=\"Watch for Changes\"\n                                                    IsCheckable=\"True\"\n                                                    IsChecked=\"{Binding WatchForChanges, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type Window}}}\" />\n                                            </ContextMenu>\n                                        </ListView.Resources>\n                                        <ListView.ItemContainerStyle>\n                                            <Style TargetType=\"{x:Type ListViewItem}\">\n                                                <!--<EventSetter Event=\"PreviewMouseLeftButtonDown\" Handler=\"OnListViewItem_PreviewMouseLeftButtonDown\" />-->\n                                                <Setter Property=\"ContextMenu\" Value=\"{StaticResource grdItemContextMenu}\" />\n                                                <Style.Triggers>\n                                                    <Trigger Property=\"IsMouseOver\" Value=\"True\">\n                                                        <Setter Property=\"Background\" Value=\"Transparent\" />\n                                                    </Trigger>\n                                                    <Trigger Property=\"IsSelected\" Value=\"True\">\n                                                        <Setter Property=\"Background\" Value=\"Gray\" />\n                                                        <Setter Property=\"Foreground\" Value=\"White\" />\n                                                    </Trigger>\n                                                </Style.Triggers>\n                                            </Style>\n                                        </ListView.ItemContainerStyle>\n                                        <ListView.View>\n                                            <GridView AllowsColumnReorder=\"true\" ColumnHeaderContainerStyle=\"{StaticResource GridViewColumnHeaderStyle1}\">\n                                                <GridViewColumn\n                                                    x:Name=\"grdTaskNameColumn\"\n                                                    Width=\"{Binding TaskNameColumnWidth}\"\n                                                    local:ChoGridViewSort.PropertyName=\"TaskName\"\n                                                    DisplayMemberBinding=\"{Binding Path=TaskName}\">\n                                                    <GridViewColumnHeader\n                                                        x:Name=\"grdTaskNameColumnHeader\"\n                                                        Click=\"grdBackupTaskColumnHeader_Click\"\n                                                        Content=\"TASK NAME\"\n                                                        ContextMenu=\"{StaticResource grdHeaderContextMenu}\"\n                                                        MouseDown=\"GridViewColumnHeader_MouseDown\"\n                                                        SizeChanged=\"TaskNameGridViewColumnHeader_SizeChanged\"\n                                                        Tag=\"TaskName\" />\n                                                </GridViewColumn>\n                                                <GridViewColumn\n                                                    x:Name=\"grdDateCreatedColumn\"\n                                                    Width=\"{Binding DateCreatedColumnWidth}\"\n                                                    local:ChoGridViewColumnVisibilityManager.IsVisible=\"{Binding DateCreatedVisibility}\"\n                                                    local:ChoGridViewSort.PropertyName=\"CreatedDate\"\n                                                    DisplayMemberBinding=\"{Binding Path=CreatedDate, StringFormat='dd-MMM-yyyy hh:mm:ss tt'}\">\n                                                    <GridViewColumnHeader\n                                                        x:Name=\"grdDateCreatedColumnHeader\"\n                                                        Click=\"grdBackupTaskColumnHeader_Click\"\n                                                        Content=\"DATE CREATED\"\n                                                        ContextMenu=\"{StaticResource grdHeaderContextMenu}\"\n                                                        MouseDown=\"GridViewColumnHeader_MouseDown\"\n                                                        SizeChanged=\"DateCreatedGridViewColumnHeader_SizeChanged\"\n                                                        Tag=\"CreatedDate\" />\n                                                </GridViewColumn>\n                                                <GridViewColumn\n                                                    x:Name=\"grdDateModifiedColumn\"\n                                                    Width=\"{Binding DateModifiedColumnWidth}\"\n                                                    local:ChoGridViewColumnVisibilityManager.IsVisible=\"{Binding DateModifiedVisibility}\"\n                                                    local:ChoGridViewSort.PropertyName=\"ModifiedDate\"\n                                                    DisplayMemberBinding=\"{Binding Path=ModifiedDate, StringFormat='dd-MMM-yyyy hh:mm:ss tt'}\">\n                                                    <GridViewColumnHeader\n                                                        x:Name=\"grdDateModifiedColumnHeader\"\n                                                        Click=\"grdBackupTaskColumnHeader_Click\"\n                                                        Content=\"DATE MODIFIED\"\n                                                        ContextMenu=\"{StaticResource grdHeaderContextMenu}\"\n                                                        MouseDown=\"GridViewColumnHeader_MouseDown\"\n                                                        SizeChanged=\"DateModifiedGridViewColumnHeader_SizeChanged\"\n                                                        Tag=\"ModifiedDate\" />\n                                                </GridViewColumn>\n                                            </GridView>\n                                        </ListView.View>\n                                    </ListView>\n\n                                    <!--<ListBox x:Name=\"lstBackupTasks\" Margin=\"0,5,0,0\" BorderThickness=\"1\" BorderBrush=\"LightGray\" VerticalAlignment=\"Stretch\"\n                                             ItemsSource=\"{Binding BackupTaskInfos}\" SelectedValuePath=\"FilePath\" DisplayMemberPath=\"FileName\"\n                                             SelectedValue=\"{Binding SelectedBackupTaskFilePath}\" >-->\n                                </DockPanel>\n                            </DockPanel>\n                        </GroupBox>\n                    </TabItem>\n                    <TabItem\n                        x:Name=\"tabTaskQueue\"\n                        Header=\"Task Queue\"\n                        ToolTip=\"\">\n                        <GroupBox\n                            x:Name=\"grpTaskQueue\"\n                            Margin=\"-3\"\n                            Header=\"Task Queue\">\n                            <DockPanel LastChildFill=\"True\">\n                                <StackPanel\n                                    Margin=\"0,5,0,0\"\n                                    DockPanel.Dock=\"Bottom\"\n                                    Orientation=\"Horizontal\">\n                                    <Button\n                                        x:Name=\"btnTaskQStopTask\"\n                                        Margin=\"0,0,0,0\"\n                                        Click=\"btnTaskQStopTask_Click\"\n                                        Content=\"STOP\"\n                                        IsEnabled=\"{Binding TaskQStopTaskEnabled}\"\n                                        Style=\"{DynamicResource MetroButton}\"\n                                        ToolTip=\"Stop task\" />\n                                    <!--<Button Margin=\"5,0,0,0\" x:Name=\"btnTaskQMoveUpTask\" Content=\"MOVE UP\" IsEnabled=\"{Binding TaskQMoveUpTaskEnabled }\"\n                                            Style=\"{DynamicResource MetroButton}\" Click=\"btnTaskQMoveUpTask_Click\"  ToolTip=\"Move Up task\"/>\n                                    <Button Margin=\"5,0,0,0\" x:Name=\"btnTaskQMoveDownTask\" Content=\"MOVE DOWN\" IsEnabled=\"{Binding TaskQMoveDownTaskEnabled }\"\n                                            Style=\"{DynamicResource MetroButton}\" Click=\"btnTaskQMoveDownTask_Click\"  ToolTip=\"Move Down task\"/>-->\n                                    <Button\n                                        x:Name=\"btnTaskQRemoveTask\"\n                                        Margin=\"5,0,0,0\"\n                                        Click=\"btnTaskQRemoveTask_Click\"\n                                        Content=\"REMOVE\"\n                                        IsEnabled=\"{Binding TaskQRemoveTaskEnabled}\"\n                                        Style=\"{DynamicResource MetroButton}\"\n                                        ToolTip=\"Remove task\" />\n                                    <Button\n                                        x:Name=\"btnOpenTaskLogFile\"\n                                        Margin=\"5,0,0,0\"\n                                        Click=\"btnOpenTaskLogFile_Click\"\n                                        Content=\"OPEN LOG FILE\"\n                                        DockPanel.Dock=\"Right\"\n                                        IsEnabled=\"{Binding OpenTaskLogFileEnabled}\"\n                                        Style=\"{DynamicResource MetroButton}\"\n                                        ToolTip=\"Open task log file\" />\n                                    <Button\n                                        x:Name=\"btnOpenTaskLogFolder\"\n                                        Margin=\"5,0,0,0\"\n                                        Click=\"btnOpenTaskLogFolder_Click\"\n                                        Content=\"OPEN LOG FOLDER\"\n                                        DockPanel.Dock=\"Right\"\n                                        IsEnabled=\"{Binding OpenTaskLogFolderEnabled}\"\n                                        Style=\"{DynamicResource MetroButton}\"\n                                        ToolTip=\"Open task log folder\" />\n                                </StackPanel>\n                                <ListView\n                                    x:Name=\"lstTaskQueue\"\n                                    Margin=\"0,0,0,0\"\n                                    VerticalAlignment=\"Stretch\"\n                                    local:ChoGridViewColumnVisibilityManager.Enabled=\"True\"\n                                    local:ChoGridViewSort.AutoSort=\"True\"\n                                    BorderBrush=\"LightGray\"\n                                    BorderThickness=\"1\"\n                                    FontFamily=\"Courier New\"\n                                    FontSize=\"12\"\n                                    ItemsSource=\"{Binding TaskQueueItems}\"\n                                    PreviewKeyUp=\"lstTaskQueue_PreviewKeyUp\"\n                                    SelectedItem=\"{Binding SelectedTaskQueueItem}\"\n                                    SelectedValue=\"{Binding SelectedTaskQueueItemId}\"\n                                    SelectedValuePath=\"Id\"\n                                    ToolTip=\"\">\n                                    <ListView.Resources>\n                                        <ContextMenu x:Key=\"grdTaskQueueHeaderContextMenu\">\n                                            <MenuItem\n                                                x:Name=\"mnuTaskQColumnToFit\"\n                                                Click=\"mnuTaskQColumnToFit_Click\"\n                                                Header=\"Size Column to Fit\" />\n                                            <MenuItem\n                                                x:Name=\"mnuTaskQAllColumnsToFit\"\n                                                Click=\"mnuTaskQAllColumnsToFit_Click\"\n                                                Header=\"Size All Columns to Fit\" />\n                                            <Separator />\n                                            <MenuItem\n                                                Header=\"Confirm on Delete Task\"\n                                                IsCheckable=\"True\"\n                                                IsChecked=\"{Binding ConfirmOnDelete}\" />\n                                        </ContextMenu>\n                                        <ContextMenu x:Key=\"grdTaskQueueItemContextMenu\">\n                                            <MenuItem\n                                                x:Name=\"mnuTaskQStopTask\"\n                                                Click=\"mnuCloneTask_Click\"\n                                                Header=\"Stop Task\"\n                                                InputGestureText=\"Ctrl+S\"\n                                                IsEnabled=\"{Binding TaskQStopTaskEnabled}\" />\n                                            <!--<MenuItem x:Name=\"mnuTaskQMoveUpTask\" Header=\"Move Up Task\" Click=\"mnuDeleteTask_Click\" InputGestureText=\"Ctrl+Up\" IsEnabled=\"{Binding TaskQMoveUpTaskEnabled }\"/>\n                                            <MenuItem x:Name=\"mnuTaskQMoveDownTask\" Header=\"Move Down Task\" Click=\"mnuDeleteTask_Click\" InputGestureText=\"Ctrl+Down\" IsEnabled=\"{Binding TaskQMoveDownTaskEnabled }\"/>-->\n                                            <MenuItem\n                                                x:Name=\"mnuTaskQRemoveTask\"\n                                                Click=\"mnuDeleteTask_Click\"\n                                                Header=\"Remove Task\"\n                                                InputGestureText=\"Del\"\n                                                IsEnabled=\"{Binding TaskQRemoveTaskEnabled}\" />\n                                            <MenuItem\n                                                x:Name=\"mnuTaskQOpenLogFile\"\n                                                Click=\"mnuTaskQOpenLogFile_Click\"\n                                                Header=\"Open log file\"\n                                                InputGestureText=\"Ctrl+O\"\n                                                IsEnabled=\"{Binding OpenTaskLogFileEnabled}\" />\n                                            <Separator />\n                                            <MenuItem\n                                                Header=\"Confirm on Delete Task\"\n                                                IsCheckable=\"True\"\n                                                IsChecked=\"{Binding ConfirmOnDelete, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type Window}}}\" />\n                                        </ContextMenu>\n                                    </ListView.Resources>\n                                    <ListView.ItemContainerStyle>\n                                        <Style TargetType=\"{x:Type ListBoxItem}\">\n                                            <!--<EventSetter Event=\"PreviewMouseLeftButtonDown\" Handler=\"OnListViewItem_PreviewMouseLeftButtonDown\" />-->\n                                            <Setter Property=\"ContextMenu\" Value=\"{StaticResource grdTaskQueueItemContextMenu}\" />\n                                            <Setter Property=\"Padding\" Value=\"0,0,0,0\" />\n                                            <Setter Property=\"Margin\" Value=\"0,0,0,0\" />\n                                            <Style.Triggers>\n                                                <DataTrigger Binding=\"{Binding Status}\" Value=\"3\">\n                                                    <Setter Property=\"Background\" Value=\"DarkGreen\" />\n                                                    <Setter Property=\"Foreground\" Value=\"White\" />\n                                                </DataTrigger>\n                                                <DataTrigger Binding=\"{Binding Status}\" Value=\"2\">\n                                                    <Setter Property=\"Background\" Value=\"Red\" />\n                                                    <Setter Property=\"Foreground\" Value=\"White\" />\n                                                </DataTrigger>\n                                                <DataTrigger Binding=\"{Binding Status}\" Value=\"1\">\n                                                    <Setter Property=\"Background\" Value=\"Yellow\" />\n                                                    <Setter Property=\"Foreground\" Value=\"Black\" />\n                                                </DataTrigger>\n                                            </Style.Triggers>\n                                        </Style>\n                                    </ListView.ItemContainerStyle>\n                                    <ListView.View>\n                                        <GridView AllowsColumnReorder=\"true\" ColumnHeaderContainerStyle=\"{StaticResource GridViewColumnHeaderStyle1}\">\n                                            <GridViewColumn\n                                                x:Name=\"grdTaskQIdColumn\"\n                                                Width=\"{Binding TaskQIdColumnWidth}\"\n                                                local:ChoGridViewSort.PropertyName=\"Id\"\n                                                DisplayMemberBinding=\"{Binding Path=Id}\">\n                                                <GridViewColumnHeader\n                                                    x:Name=\"grdTaskQTaskIdColumnHeader\"\n                                                    Click=\"grdTaskQColumnHeader_Click\"\n                                                    Content=\"ID\"\n                                                    ContextMenu=\"{StaticResource grdTaskQueueHeaderContextMenu}\"\n                                                    MouseDown=\"GridViewTaskQColumnHeader_MouseDown\"\n                                                    SizeChanged=\"grdTaskQIdColumnHeader_SizeChanged\"\n                                                    Tag=\"TaskName\" />\n                                            </GridViewColumn>\n                                            <GridViewColumn\n                                                x:Name=\"grdTaskQNameColumn\"\n                                                Width=\"{Binding TaskQNameColumnWidth}\"\n                                                local:ChoGridViewSort.PropertyName=\"TaskName\"\n                                                DisplayMemberBinding=\"{Binding Path=TaskName}\">\n                                                <GridViewColumnHeader\n                                                    x:Name=\"grdTaskQTaskNameColumnHeader\"\n                                                    Click=\"grdTaskQColumnHeader_Click\"\n                                                    Content=\"TASK NAME\"\n                                                    ContextMenu=\"{StaticResource grdTaskQueueHeaderContextMenu}\"\n                                                    MouseDown=\"GridViewTaskQColumnHeader_MouseDown\"\n                                                    SizeChanged=\"grdTaskQNameColumnHeader_SizeChanged\"\n                                                    Tag=\"TaskName\" />\n                                            </GridViewColumn>\n                                            <GridViewColumn\n                                                x:Name=\"grdTaskQQueueTimeColumn\"\n                                                Width=\"{Binding TaskQQueueTimeColumnWidth}\"\n                                                local:ChoGridViewColumnVisibilityManager.IsVisible=\"{Binding QueueTime}\"\n                                                local:ChoGridViewSort.PropertyName=\"QueueTime\"\n                                                DisplayMemberBinding=\"{Binding Path=QueueTime, StringFormat='dd-MMM-yyyy hh:mm:ss tt'}\">\n                                                <GridViewColumnHeader\n                                                    x:Name=\"grdTaskQQueueTimeColumnHeader\"\n                                                    Click=\"grdTaskQColumnHeader_Click\"\n                                                    Content=\"QUEUE TIME\"\n                                                    ContextMenu=\"{StaticResource grdTaskQueueHeaderContextMenu}\"\n                                                    MouseDown=\"GridViewTaskQColumnHeader_MouseDown\"\n                                                    SizeChanged=\"grdTaskQQueueTimeColumnHeader_SizeChanged\"\n                                                    Tag=\"QueueTime\" />\n                                            </GridViewColumn>\n                                            <GridViewColumn\n                                                x:Name=\"grdTaskQStartTimeColumn\"\n                                                Width=\"{Binding TaskQStartTimeColumnWidth}\"\n                                                local:ChoGridViewColumnVisibilityManager.IsVisible=\"{Binding StartTime}\"\n                                                local:ChoGridViewSort.PropertyName=\"StartTime\"\n                                                DisplayMemberBinding=\"{Binding Path=StartTime, StringFormat='dd-MMM-yyyy hh:mm:ss tt'}\">\n                                                <GridViewColumnHeader\n                                                    x:Name=\"grdTaskQStartTimeColumnHeader\"\n                                                    Click=\"grdTaskQColumnHeader_Click\"\n                                                    Content=\"START TIME\"\n                                                    ContextMenu=\"{StaticResource grdTaskQueueHeaderContextMenu}\"\n                                                    MouseDown=\"GridViewTaskQColumnHeader_MouseDown\"\n                                                    SizeChanged=\"grdTaskQStartTimeColumnHeader_SizeChanged\"\n                                                    Tag=\"StartTime\" />\n                                            </GridViewColumn>\n                                            <GridViewColumn\n                                                x:Name=\"grdTaskQEndTimeColumn\"\n                                                Width=\"{Binding DateModifiedColumnWidth}\"\n                                                local:ChoGridViewColumnVisibilityManager.IsVisible=\"{Binding EndTime}\"\n                                                local:ChoGridViewSort.PropertyName=\"EndTime\"\n                                                DisplayMemberBinding=\"{Binding Path=EndTime, StringFormat='dd-MMM-yyyy hh:mm:ss tt'}\">\n                                                <GridViewColumnHeader\n                                                    x:Name=\"grdTaskQEndTimeColumnHeader\"\n                                                    Click=\"grdTaskQColumnHeader_Click\"\n                                                    Content=\"END TIME\"\n                                                    ContextMenu=\"{StaticResource grdTaskQueueHeaderContextMenu}\"\n                                                    MouseDown=\"GridViewTaskQColumnHeader_MouseDown\"\n                                                    SizeChanged=\"grdTaskQEndTimeColumnHeader_SizeChanged\"\n                                                    Tag=\"EndTime\" />\n                                            </GridViewColumn>\n                                            <GridViewColumn\n                                                x:Name=\"grdTaskQStatusColumn\"\n                                                Width=\"{Binding DateModifiedColumnWidth}\"\n                                                local:ChoGridViewColumnVisibilityManager.IsVisible=\"{Binding Status}\"\n                                                local:ChoGridViewSort.PropertyName=\"Status\"\n                                                DisplayMemberBinding=\"{Binding Path=Status}\">\n                                                <GridViewColumnHeader\n                                                    x:Name=\"grdTaskQStatusColumnHeader\"\n                                                    Click=\"grdTaskQColumnHeader_Click\"\n                                                    Content=\"STATUS\"\n                                                    ContextMenu=\"{StaticResource grdTaskQueueHeaderContextMenu}\"\n                                                    MouseDown=\"GridViewTaskQColumnHeader_MouseDown\"\n                                                    SizeChanged=\"grdTaskQStatusColumnHeader_SizeChanged\"\n                                                    Tag=\"Status\" />\n                                            </GridViewColumn>\n                                            <GridViewColumn\n                                                x:Name=\"grdTaskQErrorMsgColumn\"\n                                                Width=\"{Binding DateModifiedColumnWidth}\"\n                                                local:ChoGridViewColumnVisibilityManager.IsVisible=\"{Binding ErrorMessage}\"\n                                                local:ChoGridViewSort.PropertyName=\"Status\"\n                                                DisplayMemberBinding=\"{Binding Path=ErrorMessage}\">\n                                                <GridViewColumnHeader\n                                                    x:Name=\"grdTaskQErrorMsgColumnHeader\"\n                                                    Click=\"grdTaskQColumnHeader_Click\"\n                                                    Content=\"ERROR MSG\"\n                                                    ContextMenu=\"{StaticResource grdTaskQueueHeaderContextMenu}\"\n                                                    MouseDown=\"GridViewTaskQColumnHeader_MouseDown\"\n                                                    SizeChanged=\"grdTaskQErrorMsgColumnHeader_SizeChanged\"\n                                                    Tag=\"ErrorMessage\" />\n                                            </GridViewColumn>\n                                        </GridView>\n                                    </ListView.View>\n                                </ListView>\n\n                                <!--<ListBox x:Name=\"lstBackupTasks\" Margin=\"0,5,0,0\" BorderThickness=\"1\" BorderBrush=\"LightGray\" VerticalAlignment=\"Stretch\"\n                                             ItemsSource=\"{Binding BackupTaskInfos}\" SelectedValuePath=\"FilePath\" DisplayMemberPath=\"FileName\"\n                                             SelectedValue=\"{Binding SelectedBackupTaskFilePath}\" >-->\n                            </DockPanel>\n                        </GroupBox>\n                    </TabItem>\n                </TabControl>\n            </Expander>\n\n            <GridSplitter\n                Grid.Column=\"1\"\n                Width=\"1\"\n                HorizontalAlignment=\"Right\"\n                VerticalAlignment=\"Stretch\"\n                Background=\"{Binding WindowTitleBrush}\"\n                IsTabStop=\"False\"\n                ResizeBehavior=\"PreviousAndNext\"\n                ResizeDirection=\"Columns\" />\n        </Grid>\n    </DockPanel>\n</Controls:MetroWindow>\n"
        },
        {
          "name": "MainWindow.xaml.cs",
          "type": "blob",
          "size": 100.22265625,
          "content": "﻿using Cinchoo.Core;\nusing Cinchoo.Core.Configuration;\nusing Cinchoo.Core.Diagnostics;\nusing Cinchoo.Core.Reflection;\nusing Cinchoo.Core.Win32.Dialogs;\nusing Cinchoo.Core.WPF;\nusing ICSharpCode.AvalonEdit.Rendering;\nusing MahApps.Metro;\nusing MahApps.Metro.Controls;\nusing Microsoft.Win32;\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\nusing System.Collections.Specialized;\nusing System.ComponentModel;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Runtime.CompilerServices;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Data;\nusing System.Windows.Documents;\nusing System.Windows.Input;\nusing System.Windows.Media;\nusing System.Windows.Media.Imaging;\nusing System.Windows.Navigation;\nusing System.Windows.Threading;\nusing System.Xml;\nusing System.Xml.Serialization;\n//using Xceed.Wpf.Toolkit.PropertyGrid;\nusing Microsoft.WindowsAPICodePack.Dialogs;\n\nnamespace ChoEazyCopy\n{\n    /// <summary>\n    /// Interaction logic for MainWindow.xaml\n    /// </summary>\n    public partial class MainWindow : MetroWindow, INotifyPropertyChanged\n    {\n        const string NEW_SETTING_FILE_NAME = \"<NEW>\";\n\n        #region Instance Members (Private)\n\n        private static string _caption;\n        internal static string Caption\n        {\n            get { return _caption; }\n            set\n            {\n                _caption = value;\n            }\n        }\n        private ChoObservableMruList<string> _recentNumbersList;\n        private ChoRoboCopyManager _roboCopyManager = null;\n        private DispatcherTimer _dispatcherTimer;\n        private Thread _mainUIThread;\n        private Thread _processFilesThread;\n        private ChoAppSettings _appSettings;\n        private GridViewColumnHeader listViewSortCol = null;\n        private ChoSortAdorner listViewSortAdorner = null;\n        private bool IsStopping = false;\n        private bool _isRunning = false;\n\n        private string _defaultAppStatusText = \"Ready\";\n        private string _appStatusText;\n        public string AppStatusText\n        {\n            get { return _appStatusText; }\n            set\n            {\n                _appStatusText = value;\n                RaisePropertyChanged(nameof(AppStatusText));\n            }\n        }\n\n        public ChoObservableMruList<string> RecentNumbersList\n        {\n            get\n            {\n                if (null == _recentNumbersList)\n                {\n                    _recentNumbersList = new ChoObservableMruList<string>(9, StringComparer.OrdinalIgnoreCase);\n                }\n                return _recentNumbersList;\n            }\n        }\n        public bool IsRunning\n        {\n            get { return _isRunning; }\n            set\n            {\n                _isRunning = value;\n                RaisePropertyChanged(nameof(IsRunning));\n                RaisePropertyChanged(nameof(IsNotRunning));\n            }\n        }\n        public bool IsNotRunning\n        {\n            get { return !_isRunning; }\n            set\n            {\n                _isRunning = !value;\n                RaisePropertyChanged(nameof(IsRunning));\n                RaisePropertyChanged(nameof(IsNotRunning));\n            }\n        }\n\n        public bool IsAdminMode\n        {\n            get;\n            set;\n        }\n        private Brush _controlMouseOverBackgroundBrush;\n        public Brush ControlMouseOverBackgroundBrush\n        {\n            get { return _controlMouseOverBackgroundBrush; }\n            set \n            { \n                _controlMouseOverBackgroundBrush = value; \n                RaisePropertyChanged(nameof(ControlMouseOverBackgroundBrush));\n            }\n        }\n\n        private Brush _controlBackgroundBrush;\n        public Brush ControlBackgroundBrush\n        {\n            get { return _controlBackgroundBrush; }\n            set\n            {\n                _controlBackgroundBrush = value;\n                RaisePropertyChanged(nameof(ControlBackgroundBrush));\n            }\n        }\n\n        private Brush _controlForegroundBrush;\n        public Brush ControlForegroundBrush\n        {\n            get { return _controlForegroundBrush; }\n            set\n            {\n                _controlForegroundBrush = value;\n                RaisePropertyChanged(nameof(ControlForegroundBrush));\n            }\n        }\n\n        private Brush _tabControlBackgroundBrush;\n        public Brush TabControlBackgroundBrush\n        {\n            get { return _tabControlBackgroundBrush; }\n            set\n            {\n                _tabControlBackgroundBrush = value;\n                RaisePropertyChanged(nameof(TabControlBackgroundBrush));\n            }\n        }\n\n        private Brush _tabControlForegroundBrush;\n        public Brush TabControlForegroundBrush\n        {\n            get { return _tabControlForegroundBrush; }\n            set\n            {\n                _tabControlForegroundBrush = value;\n                RaisePropertyChanged(nameof(TabControlForegroundBrush));\n            }\n        }\n\n        private Brush _PGControlBackgroundBrush;\n        public Brush PGControlBackgroundBrush\n        {\n            get { return _PGControlBackgroundBrush; }\n            set\n            {\n                _PGControlBackgroundBrush = value;\n                RaisePropertyChanged(nameof(PGControlBackgroundBrush));\n            }\n        }\n\n        private Brush _PGControlForegroundBrush;\n        public Brush PGControlForegroundBrush\n        {\n            get { return _PGControlForegroundBrush; }\n            set\n            {\n                _PGControlForegroundBrush = value;\n                RaisePropertyChanged(nameof(PGControlForegroundBrush));\n            }\n        }\n\n        private Brush _PGControlBorderBrush;\n        public Brush PGControlBorderBrush\n        {\n            get { return _PGControlBorderBrush; }\n            set\n            {\n                _PGControlBorderBrush = value;\n                RaisePropertyChanged(nameof(PGControlBorderBrush));\n            }\n        }\n\n        private Brush _textBoxFocusBorderBrush;\n        public Brush TextBoxFocusBorderBrush\n        {\n            get { return _textBoxFocusBorderBrush; }\n            set\n            {\n                _textBoxFocusBorderBrush = value;\n                RaisePropertyChanged(nameof(TextBoxFocusBorderBrush));\n            }\n        }\n\n        private Brush _themeForegroundBrush;\n        public Brush ThemeForegroundBrush\n        {\n            get { return _themeForegroundBrush; }\n            set\n            {\n                _themeForegroundBrush = value;\n                RaisePropertyChanged(nameof(ThemeForegroundBrush));\n            }\n        }\n\n        private Brush _themeBackgroundBrush;\n        public Brush ThemeBackgroundBrush\n        {\n            get { return _themeBackgroundBrush; }\n            set\n            {\n                _themeBackgroundBrush = value;\n                RaisePropertyChanged(nameof(ThemeBackgroundBrush));\n            }\n        }\n        private Brush _mouseOverBrush;\n        public Brush MouseOverBrush\n        {\n            get { return _mouseOverBrush; }\n            set\n            {\n                _mouseOverBrush = value;\n                RaisePropertyChanged(nameof(MouseOverBrush));\n            }\n        }\n        private bool _isDirty = false;\n        private bool IsDirty\n        {\n            get { return _isDirty; }\n            set { _isDirty = value; }\n        }\n        private string _settingsFilePath = null;\n        public string SettingsFilePath\n        {\n            get { return _settingsFilePath; }\n            private set\n            {\n                _settingsFilePath = value;\n                IsDirty = false;\n                RaisePropertyChanged(nameof(SettingsFilePath));\n                if (_settingsFilePath.IsNullOrWhiteSpace())\n                    SettingsFileName = null;\n                else\n                    SettingsFileName = Path.GetFileNameWithoutExtension(_settingsFilePath);\n                SetTitle();\n            }\n        }\n        private string _settingsFileName = null;\n        public string SettingsFileName\n        {\n            get { return _settingsFileName.IsNullOrWhiteSpace() ? NEW_SETTING_FILE_NAME : _settingsFileName; }\n            private set\n            {\n                _settingsFileName = value;\n                RaisePropertyChanged(nameof(SettingsFileName));\n            }\n        }\n\n        public bool DateCreatedVisibility\n        {\n            get { return Properties.Settings.Default.DateCreatedVisibility; }\n            set\n            {\n                Properties.Settings.Default.DateCreatedVisibility = value;\n                Properties.Settings.Default.Save();\n                RaisePropertyChanged(nameof(DateCreatedVisibility));\n            }\n        }\n\n        public bool DateModifiedVisibility\n        {\n            get { return Properties.Settings.Default.DateModifiedVisibility; }\n            set\n            {\n                Properties.Settings.Default.DateModifiedVisibility = value;\n                Properties.Settings.Default.Save();\n                RaisePropertyChanged(nameof(DateModifiedVisibility));\n            }\n        }\n\n        public bool KeepDateCreated\n        {\n            get { return Properties.Settings.Default.KeepDateCreated; }\n            set\n            {\n                Properties.Settings.Default.KeepDateCreated = value;\n                Properties.Settings.Default.Save();\n                RaisePropertyChanged(nameof(KeepDateCreated));\n            }\n        }\n\n        public bool KeepDateModified\n        {\n            get { return Properties.Settings.Default.KeepDateModified; }\n            set\n            {\n                Properties.Settings.Default.KeepDateModified = value;\n                Properties.Settings.Default.Save();\n                RaisePropertyChanged(nameof(KeepDateModified));\n            }\n        }\n\n        public bool SizeColumnToFit\n        {\n            get { return Properties.Settings.Default.SizeColumnToFit; }\n            set\n            {\n                Properties.Settings.Default.SizeColumnToFit = value;\n                Properties.Settings.Default.Save();\n                RaisePropertyChanged(nameof(SizeColumnToFit));\n            }\n        }\n\n        public bool SizeAllColumnsToFit\n        {\n            get { return Properties.Settings.Default.SizeAllColumnsToFit; }\n            set\n            {\n                Properties.Settings.Default.SizeAllColumnsToFit = value;\n                Properties.Settings.Default.Save();\n                RaisePropertyChanged(nameof(SizeAllColumnsToFit));\n            }\n        }\n\n        public bool ConfirmOnDelete\n        {\n            get { return Properties.Settings.Default.ConfirmOnDelete; }\n            set\n            {\n                Properties.Settings.Default.ConfirmOnDelete = value;\n                Properties.Settings.Default.Save();\n                RaisePropertyChanged(nameof(ConfirmOnDelete));\n            }\n        }\n\n        public bool WatchForChanges\n        {\n            get { return Properties.Settings.Default.WatchForChanges; }\n            set\n            {\n                Properties.Settings.Default.WatchForChanges = value;\n                Properties.Settings.Default.Save();\n                WatchBackupTasksDirectory();\n                RaisePropertyChanged(nameof(WatchForChanges));\n            }\n        }\n\n        public double TaskNameColumnWidth\n        {\n            get { return Properties.Settings.Default.TaskNameColumnWidth; }\n            set\n            {\n                Properties.Settings.Default.TaskNameColumnWidth = value;\n                Properties.Settings.Default.Save();\n                RaisePropertyChanged(nameof(TaskNameColumnWidth));\n            }\n        }\n\n        public double DateCreatedColumnWidth\n        {\n            get { return Properties.Settings.Default.DateCreatedColumnWidth; }\n            set\n            {\n                Properties.Settings.Default.DateCreatedColumnWidth = value;\n                Properties.Settings.Default.Save();\n                RaisePropertyChanged(nameof(DateCreatedColumnWidth));\n            }\n        }\n\n        public double DateModifiedColumnWidth\n        {\n            get { return Properties.Settings.Default.DateModifiedColumnWidth; }\n            set\n            {\n                Properties.Settings.Default.DateModifiedColumnWidth = value;\n                Properties.Settings.Default.Save();\n                RaisePropertyChanged(nameof(DateModifiedColumnWidth));\n            }\n        }\n        public double TaskQIdColumnWidth\n        {\n            get { return Properties.Settings.Default.TaskQIdColumnWidth; }\n            set\n            {\n                Properties.Settings.Default.TaskQIdColumnWidth = value;\n                Properties.Settings.Default.Save();\n                RaisePropertyChanged(nameof(TaskQIdColumnWidth));\n            }\n        }\n\n        public double TaskQNameColumnWidth\n        {\n            get { return Properties.Settings.Default.TaskQNameColumnWidth; }\n            set\n            {\n                Properties.Settings.Default.TaskQNameColumnWidth = value;\n                Properties.Settings.Default.Save();\n                RaisePropertyChanged(nameof(TaskQNameColumnWidth));\n            }\n        }\n\n        public double TaskQQueueTimeColumnWidth\n        {\n            get { return Properties.Settings.Default.TaskQQueueTimeColumnWidth; }\n            set\n            {\n                Properties.Settings.Default.TaskQQueueTimeColumnWidth = value;\n                Properties.Settings.Default.Save();\n                RaisePropertyChanged(nameof(TaskQQueueTimeColumnWidth));\n            }\n        }\n\n        public double TaskQStartTimeColumnWidth\n        {\n            get { return Properties.Settings.Default.TaskQStartTimeColumnWidth; }\n            set\n            {\n                Properties.Settings.Default.TaskQStartTimeColumnWidth = value;\n                Properties.Settings.Default.Save();\n                RaisePropertyChanged(nameof(TaskQStartTimeColumnWidth));\n            }\n        }\n\n        public double TaskQEndTimeColumnWidth\n        {\n            get { return Properties.Settings.Default.TaskQEndTimeColumnWidth; }\n            set\n            {\n                Properties.Settings.Default.TaskQEndTimeColumnWidth = value;\n                Properties.Settings.Default.Save();\n                RaisePropertyChanged(nameof(TaskQEndTimeColumnWidth));\n            }\n        }\n\n        public double TaskQStatusColumnWidth\n        {\n            get { return Properties.Settings.Default.TaskQStatusColumnWidth; }\n            set\n            {\n                Properties.Settings.Default.TaskQStatusColumnWidth = value;\n                Properties.Settings.Default.Save();\n                RaisePropertyChanged(nameof(TaskQStatusColumnWidth));\n            }\n        }\n        public double TaskQErrorMsgColumnWidth\n        {\n            get { return Properties.Settings.Default.TaskQErrorMsgColumnWidth; }\n            set\n            {\n                Properties.Settings.Default.TaskQErrorMsgColumnWidth = value;\n                Properties.Settings.Default.Save();\n                RaisePropertyChanged(nameof(TaskQErrorMsgColumnWidth));\n            }\n        }\n        public bool BackupTaskTabActiveAtOpen\n        {\n            get { return Properties.Settings.Default.BackupTaskTabActiveAtOpen; }\n            set\n            {\n                Properties.Settings.Default.BackupTaskTabActiveAtOpen = value;\n                Properties.Settings.Default.Save();\n                RaisePropertyChanged(nameof(BackupTaskTabActiveAtOpen));\n            }\n        }\n\n        public bool TaskQueueTabActiveAtOpen\n        {\n            get { return Properties.Settings.Default.TaskQueueTabActiveAtOpen; }\n            set\n            {\n                Properties.Settings.Default.TaskQueueTabActiveAtOpen = value;\n                Properties.Settings.Default.Save();\n                RaisePropertyChanged(nameof(TaskQueueTabActiveAtOpen));\n            }\n        }\n\n        public bool ControlPanelMinimized\n        {\n            get { return Properties.Settings.Default.ControlPanelMinimized; }\n            set\n            {\n                Properties.Settings.Default.ControlPanelMinimized = value;\n                Properties.Settings.Default.Save();\n                RaisePropertyChanged(nameof(ControlPanelMinimized));\n            }\n        }\n\n        public GridLength ControlPanelWidth\n        {\n            get { return Properties.Settings.Default.ControlPanelWidth; }\n            set\n            {\n                Properties.Settings.Default.ControlPanelWidth = value;\n                Properties.Settings.Default.Save();\n                RaisePropertyChanged(nameof(ControlPanelWidth));\n            }\n        }\n\n        private string _propertyGridTooltip;\n        public string PropertyGridTooltip\n        {\n            get { return _propertyGridTooltip; }\n            set\n            {\n                _propertyGridTooltip = value;\n                RaisePropertyChanged(nameof(PropertyGridTooltip));\n            }\n        }\n        private bool _taskQStopTaskEnabled;\n        public bool TaskQStopTaskEnabled\n        {\n            get { return _taskQStopTaskEnabled; }\n            set\n            {\n                _taskQStopTaskEnabled = value;\n                RaisePropertyChanged(nameof(TaskQStopTaskEnabled));\n            }\n        }\n        private bool _taskQMoveUpTaskEnabled;\n        public bool TaskQMoveUpTaskEnabled\n        {\n            get { return _taskQMoveUpTaskEnabled; }\n            set\n            {\n                _taskQMoveUpTaskEnabled = value;\n                RaisePropertyChanged(nameof(TaskQMoveUpTaskEnabled));\n            }\n        }\n        private bool _taskQMoveDownTaskEnabled;\n        public bool TaskQMoveDownTaskEnabled\n        {\n            get { return _taskQMoveDownTaskEnabled; }\n            set\n            {\n                _taskQMoveDownTaskEnabled = value;\n                RaisePropertyChanged(nameof(TaskQMoveDownTaskEnabled));\n            }\n        }\n        private bool _taskQRemoveTaskEnabled;\n        public bool TaskQRemoveTaskEnabled\n        {\n            get { return _taskQRemoveTaskEnabled; }\n            set\n            {\n                _taskQRemoveTaskEnabled = value;\n                RaisePropertyChanged(nameof(TaskQRemoveTaskEnabled));\n            }\n        }\n\n        private bool _cloneTaskEnabled;\n        public bool CloneTaskEnabled\n        {\n            get { return _cloneTaskEnabled; }\n            set\n            {\n                _cloneTaskEnabled = value;\n                RaisePropertyChanged(nameof(CloneTaskEnabled));\n            }\n        }\n        private bool _deleteTaskEnabled;\n        public bool DeleteTaskEnabled\n        {\n            get { return _deleteTaskEnabled; }\n            set\n            {\n                _deleteTaskEnabled = value;\n                RaisePropertyChanged(nameof(DeleteTaskEnabled));\n            }\n        }\n        private bool _queueTaskEnabled;\n        public bool QueueTaskEnabled\n        {\n            get { return _queueTaskEnabled; }\n            set\n            {\n                _queueTaskEnabled = value;\n                RaisePropertyChanged(nameof(QueueTaskEnabled));\n            }\n        }\n        private bool _openTaskLogFileEnabled;\n        public bool OpenTaskLogFileEnabled\n        {\n            get { return _openTaskLogFileEnabled; }\n            set\n            {\n                _openTaskLogFileEnabled = value;\n                RaisePropertyChanged(nameof(OpenTaskLogFileEnabled));\n            }\n        }\n        private bool _openTaskLogFolderEnabled = true;\n        public bool OpenTaskLogFolderEnabled\n        {\n            get { return _openTaskLogFolderEnabled; }\n            set\n            {\n                _openTaskLogFolderEnabled = value;\n                RaisePropertyChanged(nameof(OpenTaskLogFolderEnabled));\n            }\n        }\n\n        public event PropertyChangedEventHandler PropertyChanged;\n        private void RaisePropertyChanged([CallerMemberName] string propName = null)\n        {\n            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propName));\n        }\n\n        #endregion Instance Members (Private)\n\n        private ChoBackupTaskInfo _selectedBackupTaskItem;\n        public ChoBackupTaskInfo SelectedBackupTaskItem\n        {\n            get { return _selectedBackupTaskItem; }\n            set\n            {\n                _selectedBackupTaskItem = value;\n                RaisePropertyChanged(nameof(SelectedBackupTaskItem));\n            }\n        }\n        private string _selectedBackupTaskFilePath;\n        public string SelectedBackupTaskFilePath\n        {\n            get { return _selectedBackupTaskFilePath; }\n            set\n            {\n                var origValue = _selectedBackupTaskFilePath;\n                if (value == _selectedBackupTaskFilePath)\n                    return;\n\n                try\n                {\n                    _selectedBackupTaskFilePath = value;\n                    if (!SaveSettings())\n                    {\n                        if (File.Exists(_selectedBackupTaskFilePath))\n                        {\n                            OpenSettingsFile(_selectedBackupTaskFilePath);\n                            RaisePropertyChanged(nameof(SelectedBackupTaskFilePath));\n                        }\n                        else if (!_selectedBackupTaskFilePath.IsNullOrWhiteSpace())\n                        {\n                            MessageBox.Show($\"File `{_selectedBackupTaskFilePath}` does not exists.\", Caption, MessageBoxButton.OK, MessageBoxImage.Warning);\n                            NewSettingsFile(false);\n                            ReloadBackupTasks();\n                        }\n                    }\n                    else\n                    {\n                        Application.Current.Dispatcher.BeginInvoke(\n                            new Action(() =>\n                            {\n                                _selectedBackupTaskFilePath = origValue;\n                                RaisePropertyChanged(nameof(SelectedBackupTaskFilePath));\n                            }),\n                            DispatcherPriority.ContextIdle,\n                            null\n                        );\n                    }\n                }\n                finally\n                {\n                }\n            }\n        }\n        private Guid _selectedTaskQueueItemId;\n        public Guid SelectedTaskQueueItemId\n        {\n            get { return _selectedTaskQueueItemId; }\n            set\n            {\n                _selectedTaskQueueItemId = value;\n                RaisePropertyChanged(nameof(SelectedTaskQueueItemId));\n            }\n        }\n        private ChoTaskQueueItem _selectedTaskQueueItem;\n        public ChoTaskQueueItem SelectedTaskQueueItem\n        {\n            get { return _selectedTaskQueueItem; }\n            set\n            {\n                _selectedTaskQueueItem = value;\n                RaisePropertyChanged(nameof(SelectedTaskQueueItem));\n            }\n        }\n        private readonly ChoTaskQManager _taskQManager = null;\n        private readonly object _taskQueueItemsLock = new object();\n        private ChoObservableCollection<ChoTaskQueueItem> _taskQueueItems = new ChoObservableCollection<ChoTaskQueueItem>();\n        public ChoObservableCollection<ChoTaskQueueItem> TaskQueueItems\n        {\n            get { return _taskQueueItems; }\n            set\n            {\n                _taskQueueItems = value;\n                RaisePropertyChanged(nameof(TaskQueueItems));\n            }\n        }\n\n        private ObservableCollection<ChoBackupTaskInfo> _backupTaskInfos = new ObservableCollection<ChoBackupTaskInfo>();\n        public ObservableCollection<ChoBackupTaskInfo> BackupTaskInfos\n        {\n            get { return _backupTaskInfos; }\n            set\n            {\n                _backupTaskInfos = value;\n                RaisePropertyChanged(nameof(BackupTaskInfos));\n            }\n        }\n\n        private string _backupTaskDirectory;\n        public string BackupTaskDirectory\n        {\n            get { return _backupTaskDirectory; }\n            set\n            {\n                _backupTaskDirectory = value;\n                RaisePropertyChanged(nameof(BackupTaskDirectory));\n                ReloadBackupTasks(_backupTaskDirectory);\n            }\n        }\n\n        private bool _backupTaskDirStatus = true;\n        public bool BackupTaskDirStatus\n        {\n            get { return _backupTaskDirStatus; }\n            set\n            {\n                _backupTaskDirStatus = value;\n                RaisePropertyChanged(nameof(BackupTaskDirStatus));\n            }\n        }\n\n        private bool _scrollOutput = true;\n        public bool ScrollOutput\n        {\n            get { return _scrollOutput; }\n            set\n            {\n                _scrollOutput = value;\n                RaisePropertyChanged(nameof(ScrollOutput));\n            }\n        }\n\n        private bool _rememberWindowSizeAndPosition = true;\n        public bool RememberWindowSizeAndPosition\n        {\n            get { return _rememberWindowSizeAndPosition; }\n            set\n            {\n                _rememberWindowSizeAndPosition = value;\n                RaisePropertyChanged(nameof(RememberWindowSizeAndPosition));\n            }\n        }\n\n        private ChoAppSettings _bakAppSettings;\n        public ChoAppSettings BakAppSettings\n        {\n            get { return _bakAppSettings; }\n            set\n            {\n                _bakAppSettings = value;\n                RaisePropertyChanged(nameof(BakAppSettings));\n            }\n        }\n\n        public ChoAppSettings AppSettings\n        {\n            get { return _appSettings; }\n            set\n            {\n                _appSettings = value;\n                BakAppSettings = value;\n                RaisePropertyChanged(nameof(AppSettings));\n            }\n        }\n\n        private string _sourceDirTooltip = \"Source directory.\";\n        public string SourceDirTooltip\n        {\n            get { return _sourceDirTooltip; }\n            set\n            {\n                _sourceDirTooltip = value;\n                RaisePropertyChanged(nameof(SourceDirTooltip));\n            }\n        }\n\n        private string _backupTaskDirTooltip = \"Backup Tasks directory.\";\n        public string BackupTaskDirTooltip\n        {\n            get { return _backupTaskDirTooltip; }\n            set\n            {\n                _backupTaskDirTooltip = value;\n                RaisePropertyChanged(nameof(BackupTaskDirTooltip));\n            }\n        }\n\n        private bool _sourceDirStatus = true;\n        public bool SourceDirStatus\n        {\n            get { return _sourceDirStatus; }\n            set\n            {\n                _sourceDirStatus = value;\n                RaisePropertyChanged(nameof(SourceDirStatus));\n            }\n        }\n        public bool DestDirStatus\n        {\n            get;\n            set;\n        } = true;\n        private string _cmdLineText = null;\n        public string CmdLineText\n        {\n            get { return _cmdLineText; }\n            set\n            {\n                _cmdLineText = value;\n                RaisePropertyChanged(nameof(CmdLineText));\n            }\n        }\n        private string _cmdLineTextEx = null;\n        public string CmdLineTextEx\n        {\n            get { return _cmdLineTextEx; }\n            set\n            {\n                _cmdLineTextEx = value;\n                RaisePropertyChanged(nameof(CmdLineTextEx));\n            }\n        }\n\n        private bool _showRoboCopyProgress = false;\n        public bool ShowRoboCopyProgress\n        {\n            get { return _showRoboCopyProgress; }\n            set\n            {\n                _showRoboCopyProgress = value;\n                RaisePropertyChanged(nameof(ShowRoboCopyProgress));\n            }\n        }\n\n        private string _robocopyProgresssText = String.Empty;\n        public string RobocopyProgresssText\n        {\n            get { return _robocopyProgresssText; }\n            set\n            {\n                _robocopyProgresssText = value;\n                RaisePropertyChanged(nameof(RobocopyProgresssText));\n            }\n        }\n\n        private int _robocopyProgresssBarValue = 0;\n        public int RobocopyProgresssBarValue\n        {\n            get { return _robocopyProgresssBarValue; }\n            set\n            {\n                _robocopyProgresssBarValue = value;\n                RaisePropertyChanged(nameof(RobocopyProgresssBarValue));\n            }\n        }\n\n        public MainWindow() :\n            this(null)\n        {\n        }\n\n        public MainWindow(string settingsFilePath)\n        {\n            _taskQManager = new ChoTaskQManager(_taskQueueItems, _taskQueueItemsLock);\n            _taskQManager.Start();\n\n            SettingsFilePath = settingsFilePath;\n            InitializeComponent();\n\n            var up = new ChoUserPreferences();\n            RememberWindowSizeAndPosition = up.RememberWindowSizeAndPosition;\n\n            if (up.RememberWindowSizeAndPosition)\n            {\n                this.Height = up.WindowHeight;\n                this.Width = up.WindowWidth;\n                this.Top = up.WindowTop;\n                this.Left = up.WindowLeft;\n                this.WindowState = up.WindowState;\n            }\n\n            ContentRendered += (o, e) =>\n            {\n                Application.Current.Dispatcher.BeginInvoke(\n                    new Action(() =>\n                    {\n                        using (var cursor = new ChoWPFWaitCursor())\n                        {\n                            Caption = Title;\n                            //Title = \"{0} (v{1})\".FormatString(Title, Assembly.GetEntryAssembly().GetName().Version);\n                            SetTitle();\n                            LoadWindow();\n                        }\n                    }),\n                    DispatcherPriority.ContextIdle,\n                    null\n                );\n            };\n        }\n\n        private void LoadWindow()\n        {\n            AppStatusText = _defaultAppStatusText;\n\n            _appSettings = new ChoAppSettings();\n            if (!SettingsFilePath.IsNullOrWhiteSpace() && File.Exists(SettingsFilePath))\n                _appSettings.LoadXml(File.ReadAllText(SettingsFilePath));\n            else\n            {\n                _appSettings.Reset();\n                NewSettingsFile();\n            }\n\n            DataContext = this;\n            _mainUIThread = Thread.CurrentThread;\n\n\n            _dispatcherTimer = new System.Windows.Threading.DispatcherTimer();\n            _dispatcherTimer.Tick += new EventHandler(dispatcherTimer_Tick);\n            _dispatcherTimer.Interval = new TimeSpan(0, 0, 0, 0, 30);\n            _dispatcherTimer.Start();\n\n            string _ = _appSettings.SourceDirectory;\n            ChoShellExtCmdLineArgs cmdLineArgs = new ChoShellExtCmdLineArgs();\n            if (!cmdLineArgs.Directory.IsNullOrWhiteSpace())\n                _appSettings.SourceDirectory = cmdLineArgs.Directory;\n\n            var up = new ChoUserPreferences();\n            RememberWindowSizeAndPosition = up.RememberWindowSizeAndPosition;\n            ScrollOutput = up.ScrollOutput;\n\n            //if (up.RememberWindowSizeAndPosition)\n            //{\n            //    this.Height = up.WindowHeight;\n            //    this.Width = up.WindowWidth;\n            //    this.Top = up.WindowTop;\n            //    this.Left = up.WindowLeft;\n            //    this.WindowState = up.WindowState;\n            //}\n            RestoreRecentNumbersList();\n            LoadTaskQTaskItems();\n            LoadTestTaskQueueItems();\n\n            _backupTaskDirectory = up.BackupTaskDirectory;\n            ReloadBackupTasks(SettingsFilePath);\n            RaisePropertyChanged(nameof(BackupTaskDirectory));\n\n            grdTaskNameColumn.Width = TaskNameColumnWidth;\n            ChoGridViewColumnVisibilityManager.SetGridColumnWidth(grdTaskNameColumn);\n\n            grdDateCreatedColumn.Width = DateCreatedColumnWidth;\n            ChoGridViewColumnVisibilityManager.SetGridColumnWidth(grdDateCreatedColumn);\n\n            grdDateModifiedColumn.Width = DateModifiedColumnWidth;\n            ChoGridViewColumnVisibilityManager.SetGridColumnWidth(grdDateModifiedColumn);\n\n            grdTaskQTaskNameColumnHeader.Width = TaskQNameColumnWidth;\n            ChoGridViewColumnVisibilityManager.SetGridColumnWidth(grdTaskQTaskNameColumnHeader);\n\n            grdTaskQQueueTimeColumnHeader.Width = TaskQQueueTimeColumnWidth;\n            ChoGridViewColumnVisibilityManager.SetGridColumnWidth(grdTaskQQueueTimeColumnHeader);\n\n            grdTaskQStartTimeColumnHeader.Width = TaskQStartTimeColumnWidth;\n            ChoGridViewColumnVisibilityManager.SetGridColumnWidth(grdTaskQStartTimeColumnHeader);\n\n            grdDateModifiedColumn.Width = DateModifiedColumnWidth;\n            ChoGridViewColumnVisibilityManager.SetGridColumnWidth(grdDateModifiedColumn);\n\n            grdTaskQEndTimeColumnHeader.Width = TaskQEndTimeColumnWidth;\n            ChoGridViewColumnVisibilityManager.SetGridColumnWidth(grdTaskQEndTimeColumnHeader);\n\n            grdTaskQStatusColumnHeader.Width = TaskQStatusColumnWidth;\n            ChoGridViewColumnVisibilityManager.SetGridColumnWidth(grdTaskQStatusColumnHeader);\n\n            grdTaskQErrorMsgColumnHeader.Width = TaskQErrorMsgColumnWidth;\n            ChoGridViewColumnVisibilityManager.SetGridColumnWidth(grdTaskQErrorMsgColumnHeader);\n\n            tabBackupTasks.IsSelected = BackupTaskTabActiveAtOpen;\n            tabTaskQueue.IsSelected = TaskQueueTabActiveAtOpen;\n            expControlPanel.IsExpanded = ControlPanelMinimized;\n\n            IsDirty = false;\n\n            if (WatchForChanges)\n                WatchBackupTasksDirectory();\n            txtRoboCopyCmd.Text = _appSettings.GetCmdLineText();\n            txtRoboCopyCmdEx.Text = _appSettings.GetCmdLineTextEx();\n\n            txtRoboCopyCmd.TextChanged += (o, e) => IsDirty = true;\n            txtRoboCopyCmdEx.TextChanged += (o, e) => IsDirty = true;\n            _appSettings.PropertyChanged += (o, e) =>\n            {\n                txtRoboCopyCmd.Text = _appSettings.GetCmdLineText();\n                txtRoboCopyCmdEx.Text = _appSettings.GetCmdLineTextEx();\n            };\n            IsAdminMode = AppHost.IsRunAsAdmin();\n            if (IsAdminMode)\n            {\n                mnuRunasAdministrator.Visibility = Visibility.Collapsed;\n                mnuRegisterShellExtensions.Visibility = Visibility.Visible;\n                mnuUnregisterShellExtensions.Visibility = Visibility.Visible;\n                mnuRunatSystemsStartup.Visibility = Visibility.Visible;\n                mnuRunatSystemsStartup.IsChecked = GetRunAtSystemsStartupRegistryValue();\n            }\n            else\n            {\n                mnuRunasAdministrator.Visibility = Visibility.Visible;\n                mnuRegisterShellExtensions.Visibility = Visibility.Collapsed;\n                mnuUnregisterShellExtensions.Visibility = Visibility.Collapsed;\n                mnuRunatSystemsStartup.Visibility = Visibility.Collapsed;\n            }\n        }\n\n        private void LoadTestTaskQueueItems()\n        {\n#if TEST_MODE\n            _taskQManager.Add(\"Test1\", status: TaskStatus.Completed);\n            _taskQManager.Add(\"Test2\", status: TaskStatus.Stopped);\n            _taskQManager.Add(\"Test3\", status: TaskStatus.Running);\n            _taskQManager.Add(\"Test4\", status: TaskStatus.Queued);\n            _taskQManager.Add(\"Test5\", status: TaskStatus.Queued);\n#endif\n        }\n\n        private void SetTitle()\n        {\n            var settingsFileName = String.Empty; // SettingsFileName.IsNullOrWhiteSpace() ? String.Empty : $\" - {SettingsFileName}\";\n\n            var attr = typeof(MainWindow).Assembly.GetCustomAttribute<ChoAssemblyBetaVersionAttribute>();\n            if (attr == null || attr.Version.IsNullOrWhiteSpace())\n                Title = $\"{Caption} (v{Assembly.GetEntryAssembly().GetName().Version}){settingsFileName}\";\n            else\n                Title = $\"{Caption} (v{Assembly.GetEntryAssembly().GetName().Version} - {attr.Version}){settingsFileName}\";\n        }\n\n        private void Window_Loaded(object sender1, RoutedEventArgs e1)\n        {\n            ChangeTheme();\n        }\n\n        public void RefreshWindow()\n        {\n            RaisePropertyChanged(nameof(ControlMouseOverBackgroundBrush));\n            RaisePropertyChanged(nameof(ControlBackgroundBrush));\n            RaisePropertyChanged(nameof(ControlForegroundBrush));\n            RaisePropertyChanged(nameof(TextBoxFocusBorderBrush));\n            RaisePropertyChanged(nameof(SourceDirStatus));\n            RaisePropertyChanged(nameof(DestDirStatus));\n            RaisePropertyChanged(nameof(BackupTaskDirStatus));\n        }\n\n        int _appStatusResetTimer = 0;\n\n        private void dispatcherTimer_Tick(object sender, EventArgs e)\n        {\n            if (!AppStatusText.IsNullOrWhiteSpace() && AppStatusText != _defaultAppStatusText && !IsRunning)\n            {\n                _appStatusResetTimer += 30;\n                if (_appStatusResetTimer % (30 * 100) == 0)\n                {\n                    _appStatusResetTimer = 0;\n                    UpdateStatus(_defaultAppStatusText, null);\n                }\n            }\n\n            if (_msgBuffer.Length > 0)\n            {\n                lock (_msgBufferLock)\n                {\n                    if (_msgBuffer.Length > 0)\n                    {\n                        txtStatus.AppendText(_msgBuffer.ToString());\n                        if (ScrollOutput)\n                            txtStatus.ScrollToEnd();\n                        _msgBuffer.Clear();\n                    }\n                }\n            }\n            if (IsStopping)\n                return;\n\n            grpFolders.IsEnabled = !IsRunning;\n\n            if (IsRunning)\n                btnRun.IsEnabled = false;\n            else\n            {\n                if (!txtSourceDirectory.Text.IsNullOrWhiteSpace()\n                    && Directory.Exists(txtSourceDirectory.Text)\n                    && !txtDestDirectory.Text.IsNullOrWhiteSpace()\n                    )\n                    btnRun.IsEnabled = true;\n                else\n                {\n                    btnRun.IsEnabled = false;\n                }\n            }\n            if (txtSourceDirectory.Text.IsNullOrWhiteSpace()\n                    || Directory.Exists(txtSourceDirectory.Text)\n                )\n            {\n                SourceDirTooltip = \"Source directory.\";\n                SourceDirStatus = true;\n            }\n            else\n            {\n                SourceDirTooltip = $\"Direcory not exists.\";\n                SourceDirStatus = false;\n            }\n            if (BackupTaskDirectory.IsNullOrWhiteSpace()\n                    || Directory.Exists(BackupTaskDirectory)\n            )\n            {\n                BackupTaskDirTooltip = \"Backup Tasks directory.\";\n            }\n            else\n            {\n                BackupTaskDirTooltip = $\"Direcory not exists.\";\n            }\n\n            if (BackupTaskDirectory.IsNullOrWhiteSpace()\n                    || Directory.Exists(BackupTaskDirectory)\n                )\n            {\n                BackupTaskDirStatus = true;\n            }\n            else\n            {\n                BackupTaskDirStatus = false;\n            }\n\n            var index = -1;\n            var size = 0;\n            var selectedTaskQueueItem = SelectedTaskQueueItem;\n            lock (_taskQueueItemsLock)\n            {\n                size = TaskQueueItems.Count;\n                index = selectedTaskQueueItem != null ? TaskQueueItems.IndexOf(SelectedTaskQueueItem) : -1;\n            }\n\n            QueueTaskEnabled = DeleteTaskEnabled = CloneTaskEnabled = !SelectedBackupTaskFilePath.IsNullOrWhiteSpace();\n            TaskQStopTaskEnabled = selectedTaskQueueItem != null && selectedTaskQueueItem.Status == TaskStatus.Running;\n            TaskQMoveUpTaskEnabled = selectedTaskQueueItem != null && selectedTaskQueueItem.Status == TaskStatus.Queued && index > 0;\n            TaskQMoveDownTaskEnabled = selectedTaskQueueItem != null && selectedTaskQueueItem.Status == TaskStatus.Queued && index < size - 1;\n            TaskQRemoveTaskEnabled = selectedTaskQueueItem != null && selectedTaskQueueItem.Status != TaskStatus.Running;\n            OpenTaskLogFileEnabled = selectedTaskQueueItem != null && File.Exists(selectedTaskQueueItem.LogFilePath) ? true : false;\n\n            //tabControlPanel.IsEnabled = !IsRunning;\n            dpRoboCopyProgress.IsEnabled = !IsRunning;\n            grpBackupTasks.IsEnabled = !IsRunning;\n            pgAppSettings.Visibility = IsRunning ? Visibility.Collapsed : Visibility.Visible;\n            txtPropertyGridWaterMark.Visibility = !IsRunning ? Visibility.Collapsed : Visibility.Visible;\n            if (IsRunning)\n            {\n                //BakAppSettings = null;\n                PropertyGridTooltip = \"Grid will be hidden while task running.\";\n            }\n            else\n            {\n                //BakAppSettings = AppSettings;\n                PropertyGridTooltip = String.Empty;\n            }\n\n            //DO NOT UNCOMMENT - pgAppSettings (ExtendedPropertyGrid) - setting to disabled causes abnormal application termination\n            //pgAppSettings.IsEnabled = !IsRunning;\n\n            btnStop.IsEnabled = IsRunning;\n            btnNewFile.IsEnabled = !IsRunning;\n            btnOpenFile.IsEnabled = !IsRunning;\n            btnSaveFile.IsEnabled = !IsRunning && IsDirty;\n            btnSaveAsFile.IsEnabled = !IsRunning;\n            btnClear.IsEnabled = !IsRunning && txtStatus.Text.Length > 0;\n\n            if (_processFilesThread != null && _processFilesThread.IsAlive)\n            {\n            }\n            else\n            {\n            }\n            // Forcing the CommandManager to raise the RequerySuggested event\n            CommandManager.InvalidateRequerySuggested();\n        }\n\n        private void btnSourceDirBrowse_Click(object sender, RoutedEventArgs e)\n        {\n            if (CommonFileDialog.IsPlatformSupported)\n            {\n                var dialog = new CommonOpenFileDialog();\n                dialog.Title = \"Choose source folder...\";\n                dialog.IsFolderPicker = true;\n                dialog.InitialDirectory = (System.IO.Directory.Exists(txtSourceDirectory.Text)) ? txtSourceDirectory.Text : \"\";\n\n                CommonFileDialogResult result1 = dialog.ShowDialog();\n                if (result1 == CommonFileDialogResult.Ok)\n                {\n                    if (Directory.Exists(dialog.FileName))\n                        txtSourceDirectory.Text = dialog.FileName;\n                    else\n                        txtSourceDirectory.Text = System.IO.Path.GetDirectoryName(dialog.FileName);\n                }\n\n                return;\n            }\n\n            ChoFolderBrowserDialog dlg1 = new ChoFolderBrowserDialog\n            {\n                Description = \"Choose source folder...\",\n                ShowNewFolderButton = true,\n                ShowEditBox = true,\n                ShowBothFilesAndFolders = true,\n                NewStyle = true,\n                SelectedPath = (System.IO.Directory.Exists(txtSourceDirectory.Text)) ? txtSourceDirectory.Text : \"\",\n                ShowFullPathInEditBox = false,\n            };\n            dlg1.RootFolder = System.Environment.SpecialFolder.MyComputer;\n\n            var result = dlg1.ShowDialog();\n\n            if (result == System.Windows.Forms.DialogResult.OK)\n            {\n                if (Directory.Exists(dlg1.SelectedPath))\n                    txtSourceDirectory.Text = dlg1.SelectedPath;\n                else\n                    txtSourceDirectory.Text = System.IO.Path.GetDirectoryName(dlg1.SelectedPath);\n            }\n        }\n\n        private void btnDestDirBrowse_Click(object sender, RoutedEventArgs e)\n        {\n            if (CommonFileDialog.IsPlatformSupported)\n            {\n                var dialog = new CommonOpenFileDialog();\n                dialog.Title = \"Choose copy/move folder to...\";\n                dialog.IsFolderPicker = true;\n                dialog.InitialDirectory = (System.IO.Directory.Exists(txtDestDirectory.Text)) ? txtDestDirectory.Text : \"\";\n\n                CommonFileDialogResult result1 = dialog.ShowDialog();\n                if (result1 == CommonFileDialogResult.Ok)\n                {\n                    if (Directory.Exists(dialog.FileName))\n                        txtDestDirectory.Text = dialog.FileName;\n                    else\n                        txtDestDirectory.Text = System.IO.Path.GetDirectoryName(dialog.FileName);\n                }\n\n                return;\n            }\n\n            ChoFolderBrowserDialog dlg1 = new ChoFolderBrowserDialog\n            {\n                Description = \"Choose copy/move folder to...\",\n                ShowNewFolderButton = true,\n                ShowEditBox = true,\n                ShowBothFilesAndFolders = false,\n                NewStyle = true,\n                SelectedPath = (System.IO.Directory.Exists(txtDestDirectory.Text)) ? txtDestDirectory.Text : \"\",\n                ShowFullPathInEditBox = false,\n            };\n            dlg1.RootFolder = System.Environment.SpecialFolder.MyComputer;\n\n            var result = dlg1.ShowDialog();\n\n            if (result == System.Windows.Forms.DialogResult.OK)\n            {\n                if (Directory.Exists(dlg1.SelectedPath))\n                    txtDestDirectory.Text = dlg1.SelectedPath;\n                else\n                    txtDestDirectory.Text = System.IO.Path.GetDirectoryName(dlg1.SelectedPath);\n            }\n        }\n\n        private void Window_Closed(object sender, EventArgs e)\n        {\n            ChoFramework.Shutdown();\n        }\n\n        private void ProcessFiles(object cmd)\n        {\n            ChoAppSettings appSettings = cmd as ChoAppSettings; // cmd.ToString();\n            if (appSettings == null)\n                return;\n\n            try\n            {\n                RobocopyProgresssBarValue = 0;\n                RobocopyProgresssText = \"Analyzing RoboCopy operation...\";\n\n                IsRunning = true;\n#if _DELAY_RUN_\n                Thread.Sleep(10 * 1000);\n#endif\n                _roboCopyManager = new ChoRoboCopyManager();\n                _roboCopyManager.Status += (sender, e) => SetStatusMsg(e.Message);\n                _roboCopyManager.AppStatus += (sender, e) => UpdateStatus(e.Message, e.Tag.ToNString());\n                _roboCopyManager.Progress += (sender, e) =>\n                {\n                    RobocopyProgresssBarValue = (int)(((double)e._runningBytes / e._totalBytes) * 100);\n                    RobocopyProgresssText = $\"Copied {e._runningFileCount:N0} of {e._totalFileCount:N0} files; Copied {ChoFileSizeFormatter.FormatSize(e._runningBytes)} of {ChoFileSizeFormatter.FormatSize(e._totalBytes)}\";\n                };\n\n                _roboCopyManager.Process(appSettings);\n            }\n            catch (ThreadAbortException)\n            {\n                Thread.ResetAbort();\n            }\n            catch (Exception ex)\n            {\n                SetStatusMsg(ex.ToString());\n            }\n            finally\n            {\n                IsRunning = false;\n                _roboCopyManager = null;\n                if (RobocopyProgresssText == \"Analyzing roboopy operation...\")\n                    RobocopyProgresssText = String.Empty;\n            }\n        }\n\n        private readonly StringBuilder _msgBuffer = new StringBuilder();\n        private readonly object _msgBufferLock = new object();\n\n        private void SetStatusMsg(string msg)\n        {\n            if (msg != Environment.NewLine && msg.IsNullOrWhiteSpace()) return;\n\n            lock (_msgBufferLock)\n            {\n                _msgBuffer.Append(msg);\n            }\n\n            /*\n            if (Thread.CurrentThread != _mainUIThread)\n            {\n                this.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority.Normal, new Action(() => SetStatusMsg(msg)));\n            }\n            else\n            {\n                Debug.WriteLine(msg);\n\n                //while (txtStatus.Items.Count > _appSettings.MaxStatusMsgSize)\n                //{\n                //    txtStatus.Items.RemoveAt(0);\n                //}\n\n                txtStatus.AppendText(msg);\n                if (ScrollOutput)\n                    txtStatus.ScrollToEnd();\n            }\n            */\n        }\n\n        private void UpdateStatus(string text, string toolTipText)\n        {\n            sbAppStatus.Dispatcher.BeginInvoke(DispatcherPriority.Background, new Action(() =>\n            {\n                AppStatusText = text;\n                if (!toolTipText.IsNullOrWhiteSpace())\n                    ShowBalloonTipText(toolTipText);\n            }));\n        }\n\n        private void ShowBalloonTipText(string msg)\n        {\n            if (ChoApplication.NotifyIcon != null)\n            {\n                ChoApplication.NotifyIcon.BalloonTipText = msg;\n                ChoApplication.NotifyIcon.ShowBalloonTip(500);\n            }\n        }\n\n        private void tbrMain_Loaded(object sender, RoutedEventArgs e)\n        {\n            ToolBar toolBar = sender as ToolBar;\n            var overflowGrid = toolBar.Template.FindName(\"OverflowGrid\", toolBar) as FrameworkElement;\n            if (overflowGrid != null)\n            {\n                overflowGrid.Visibility = Visibility.Collapsed;\n            }\n            var mainPanelBorder = toolBar.Template.FindName(\"MainPanelBorder\", toolBar) as FrameworkElement;\n            if (mainPanelBorder != null)\n            {\n                mainPanelBorder.Margin = new Thickness();\n            }\n        }\n\n        private void btnRun_Click(object sender, RoutedEventArgs e)\n        {\n            ChoFileMoveAttributes value = ChoFileMoveAttributes.None;\n            if (Enum.TryParse<ChoFileMoveAttributes>(_appSettings.MoveFilesAndDirectories.ToNString(), out value))\n            {\n                switch (value)\n                {\n                    case ChoFileMoveAttributes.MoveFilesOnly:\n                        if (MessageBox.Show(\"Are you sure you wish to remove original file{s}? This CANNOT be undone!\", Caption, MessageBoxButton.YesNo, MessageBoxImage.Stop) == MessageBoxResult.No)\n                            return;\n                        break;\n                    case ChoFileMoveAttributes.MoveDirectoriesAndFiles:\n                        if (MessageBox.Show(\"Are you sure you wish to remove original file{s} / folder(s)? This CANNOT be undone!\", Caption, MessageBoxButton.YesNo, MessageBoxImage.Stop) == MessageBoxResult.No)\n                            return;\n                        break;\n                    default:\n                        break;\n                }\n            }\n\n            _processFilesThread = new Thread(new ParameterizedThreadStart(ProcessFiles));\n            _processFilesThread.IsBackground = true;\n            _processFilesThread.Start(_appSettings);\n        }\n\n        private void btnStop_Click(object sender, RoutedEventArgs e)\n        {\n            if (MessageBox.Show(@\"Are you sure you want to stop the operation?\", Caption, MessageBoxButton.YesNo, MessageBoxImage.Stop, MessageBoxResult.No)\n                == MessageBoxResult.No)\n                return;\n\n            IsStopping = true;\n            btnStop.IsEnabled = false;\n            Task.Run(() =>\n            {\n                ChoRoboCopyManager roboCopyManager = _roboCopyManager;\n                if (roboCopyManager != null)\n                {\n                    roboCopyManager.Cancel();\n                }\n\n                Thread processFilesThread = _processFilesThread;\n                if (processFilesThread != null)\n                {\n                    try\n                    {\n                        processFilesThread.Abort();\n                    }\n                    catch (ThreadAbortException)\n                    {\n                        Thread.ResetAbort();\n                    }\n                    _processFilesThread = null;\n                }\n                IsStopping = false;\n            });\n        }\n\n        private void btnSaveAsFile_Click(object sender, RoutedEventArgs e)\n        {\n            SaveSettings(true);\n        }\n\n        private void btnSaveFile_Click(object sender, RoutedEventArgs e)\n        {\n            SaveSettings(false);\n        }\n\n        private bool SaveSettings()\n        {\n            if (IsDirty)\n            {\n                string msg;\n                if (SettingsFilePath.IsNullOrWhiteSpace())\n                    msg = \"Do you want to save settings changes to untitled?\";\n                else\n                    msg = \"Do you want to save settings changes to '{0}'?\".FormatString(Path.GetFileName(SettingsFilePath));\n                MessageBoxResult r = MessageBox.Show(msg, Caption, MessageBoxButton.YesNoCancel, MessageBoxImage.Question);\n                if (r == MessageBoxResult.Cancel)\n                    return true;\n                else if (r == MessageBoxResult.No)\n                {\n                    IsDirty = false;\n                    return false;\n                }\n                else\n                    return !SaveSettings(false);\n            }\n            return false;\n        }\n\n        private bool SaveSettings(bool newFile)\n        {\n            DisposeBackupTasksDirectoryWatcher();\n\n            if (newFile || SettingsFilePath.IsNullOrWhiteSpace())\n            {\n                SaveFileDialog dlg = new SaveFileDialog();\n                dlg.DefaultExt = AppHost.AppFileExt;\n                dlg.Filter = \"EazyCopy files|*{0}\".FormatString(AppHost.AppFileExt);\n\n                var result = dlg.ShowDialog();\n\n                if (result == true)\n                    SettingsFilePath = dlg.FileName;\n                else\n                    return false;\n            }\n\n            try\n            {\n                if (SettingsFilePath.IsNullOrWhiteSpace()) return true;\n                var xml = _appSettings.ToXml();\n                File.WriteAllText(SettingsFilePath, xml);\n                IsDirty = false;\n                return true;\n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(\"Failed saving settings to file. {0}\".FormatString(ex.Message), Caption, MessageBoxButton.OK, MessageBoxImage.Error);\n                return false;\n            }\n            finally\n            {\n                WatchBackupTasksDirectory();\n            }\n        }\n\n        private void btnOpenFile_Click(object sender, RoutedEventArgs e)\n        {\n            if (SaveSettings())\n                return;\n\n            OpenFileDialog dlg = new OpenFileDialog();\n            dlg.DefaultExt = AppHost.AppFileExt;\n            dlg.Filter = \"EazyCopy files|*{0}\".FormatString(AppHost.AppFileExt);\n\n            var result = dlg.ShowDialog();\n\n            if (result == true)\n            {\n                OpenSettingsFile(dlg.FileName);\n            }\n        }\n\n        private void OpenSettingsFile(string settingsFileName)\n        {\n            try\n            {\n                using (var x = new ChoWPFWaitCursor())\n                {\n                    SettingsFilePath = settingsFileName;\n                    //_appSettings.Reset();\n                    if (File.Exists(SettingsFilePath))\n                        _appSettings.LoadXml(File.ReadAllText(SettingsFilePath));\n                    //else\n                    //    btnNewFile_Click(null, null);\n                    txtStatus.Text = String.Empty;\n                    IsDirty = false;\n                }\n            } \n            catch (Exception ex)\n            {\n                string errMsg = ex.InnerException != null ? ex.InnerException.Message : ex.Message;\n                MessageBox.Show($\"Failed to load `{Path.GetFileName(settingsFileName)}` task. {errMsg}\",\n                    Caption, MessageBoxButton.OK, MessageBoxImage.Error);\n\n                NewSettingsFile();\n            }\n        }\n\n        private void btnNewFile_Click(object sender, RoutedEventArgs e)\n        {\n            if (SaveSettings())\n                return;\n\n            NewSettingsFile();\n        }\n\n        private void btnNewSyncFile_Click(object sender, RoutedEventArgs e)\n        {\n            if (SaveSettings())\n                return;\n\n            using (var x = new ChoWPFWaitCursor())\n            {\n                SettingsFilePath = null;\n                txtSourceDirectory.Text = String.Empty;\n                txtDestDirectory.Text = String.Empty;\n                txtStatus.Text = String.Empty;\n                _appSettings.Reset();\n                _appSettings.CopyFileFlags = ChoCopyFileFlags.None;\n                _appSettings.CopyDirFlags = ChoCopyDirFlags.None;\n                _appSettings.CopySubDirectories = false;\n\n                _appSettings.MirrorDirTree = true;\n                _appSettings.CopyFilesWithFileInfo = true;\n\n                _appSettings.FallbackCopyFilesMode = true;\n                _appSettings.WaitTimeBetweenRetries = 1;\n                _appSettings.NoOfRetries = 2;\n                IsDirty = false;\n                SelectedBackupTaskItem = null;\n            }\n        }\n\n        private void btnNewCopyFile_Click(object sender, RoutedEventArgs e)\n        {\n            if (SaveSettings())\n                return;\n\n            using (var x = new ChoWPFWaitCursor())\n            {\n                SettingsFilePath = null;\n                txtSourceDirectory.Text = String.Empty;\n                txtDestDirectory.Text = String.Empty;\n                txtStatus.Text = String.Empty;\n                _appSettings.Reset();\n\n                _appSettings.CopyFileFlags = ChoCopyFileFlags.None;\n                _appSettings.CopyDirFlags = ChoCopyDirFlags.None;\n                _appSettings.CopySubDirectories = false;\n\n                _appSettings.MirrorDirTree = true;\n                _appSettings.CopyFilesWithFileInfo = true;\n\n                _appSettings.ExcludeExtraFilesAndDirs = true;\n                _appSettings.FallbackCopyFilesMode = true;\n                _appSettings.WaitTimeBetweenRetries = 1;\n                _appSettings.NoOfRetries = 2;\n\n                IsDirty = false;\n                SelectedBackupTaskItem = null;\n            }\n        }\n\n        private void btnNewMoveFile_Click(object sender, RoutedEventArgs e)\n        {\n            if (SaveSettings())\n                return;\n\n            using (var x = new ChoWPFWaitCursor())\n            {\n                SettingsFilePath = null;\n                txtSourceDirectory.Text = String.Empty;\n                txtDestDirectory.Text = String.Empty;\n                txtStatus.Text = String.Empty;\n                _appSettings.Reset();\n\n                _appSettings.CopyFileFlags = ChoCopyFileFlags.None;\n                _appSettings.CopyDirFlags = ChoCopyDirFlags.None;\n                _appSettings.CopySubDirectories = false;\n\n                _appSettings.SetMoveFilesAndDirectories(ChoFileMoveAttributes.MoveDirectoriesAndFiles);\n\n                _appSettings.FallbackCopyFilesMode = true;\n                _appSettings.WaitTimeBetweenRetries = 1;\n                _appSettings.NoOfRetries = 2;\n\n                IsDirty = false;\n                SelectedBackupTaskItem = null;\n            }\n        }\n\n        private void NewSettingsFile(bool reset = true)\n        {\n            using (var x = new ChoWPFWaitCursor())\n            {\n                SettingsFilePath = null;\n                txtSourceDirectory.Text = String.Empty;\n                txtDestDirectory.Text = String.Empty;\n                txtStatus.Text = String.Empty;\n                _appSettings.Reset();\n                IsDirty = false;\n                //if (reset)\n                //{\n                //    this.DataContext = null;\n                //    this.DataContext = this;\n                //}\n                SelectedBackupTaskItem = null;\n            }\n        }\n\n        private void btnClear_Click(object sender, RoutedEventArgs e)\n        {\n            txtStatus.Text = String.Empty;\n        }\n\n        private void Window_Closing(object sender, System.ComponentModel.CancelEventArgs e)\n        {\n            //_wndClosing = true;\n            if (IsRunning)\n            {\n                if (MessageBox.Show(\"File operation is in progress. Are you sure want to close the application?\", Caption, MessageBoxButton.YesNo,\n                    MessageBoxImage.Stop) == MessageBoxResult.No)\n                {\n                    e.Cancel = true;\n                    return;\n                }\n            }\n            else\n            {\n                if (MessageBox.Show(\"Are you sure want to close the application?\", Caption, MessageBoxButton.YesNo, MessageBoxImage.Stop) == MessageBoxResult.No)\n                {\n                    e.Cancel = true;\n                    return;\n                }\n            }\n\n            e.Cancel = SaveSettings();\n\n            if (!e.Cancel)\n            {\n                try\n                {\n                    //BackupTaskTabActiveAtOpen = tabBackupTasks.IsSelected;\n                    //TaskQueueTabActiveAtOpen = tabTaskQueue.IsSelected;\n                    ControlPanelMinimized = expControlPanel.IsExpanded;\n\n                    var up = new ChoUserPreferences();\n                    if (RememberWindowSizeAndPosition)\n                    {\n                        up.WindowHeight = this.Height;\n                        up.WindowWidth = this.Width;\n                        up.WindowTop = this.Top;\n                        up.WindowLeft = this.Left;\n                        up.WindowState = this.WindowState;\n                    }\n                    up.RememberWindowSizeAndPosition = RememberWindowSizeAndPosition;\n                    up.ScrollOutput = ScrollOutput;\n                    up.BackupTaskDirectory = BackupTaskDirectory;\n                    up.Save();\n\n                    SaveRecentNumbersList();\n                    SaveTaskQTaskItems();\n                }\n                catch { }\n\n                ChoApplication.NotifyIcon.Dispose();\n            }\n        }\n\n        private void RibbonWin_Loaded(object sender, RoutedEventArgs e)\n        {\n            Grid child = VisualTreeHelper.GetChild((DependencyObject)sender, 0) as Grid;\n            if (child != null)\n            {\n                child.RowDefinitions[0].Height = new GridLength(0);\n                child.RowDefinitions[1].Height = new GridLength(0);\n            }\n        }\n\n        private void BtnDonate_Click(object sender, RoutedEventArgs e)\n        {\n            string url = \"https://buy.stripe.com/8wMdSt5KogJGf969AE\"; // \"https://www.paypal.com/donate/?hosted_button_id=HB6J7QG73HMK8\";\n                                                                      //        string url = \"https://www.paypal.com/cgi-bin/webscr\" +\n                                                                      //\"?cmd=\" + \"_donations\" +\n                                                                      //\"&business=\" + \"cinchoofrx@gmail.com\" +\n                                                                      //\"&lc=\" + \"US\" +\n                                                                      //\"&item_name=\" + \"ChoEazyCopy Donation\" +\n                                                                      //\"&currency_code=\" + \"USD\" +\n                                                                      //\"&bn=\" + \"PP%2dDonationsBF\";\n\n            System.Diagnostics.Process.Start(url);\n        }\n\n        private void btnHelp_Click(object sender, RoutedEventArgs e)\n        {\n//#if DEBUG\n//            ChoSystemColorsWindow wnd = new ChoSystemColorsWindow();\n//            wnd.Show();\n//            return;\n//#endif\n            try\n            {\n                System.Diagnostics.Process.Start(\"https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/robocopy\");\n            }\n            catch { }\n        }\n\n        private void btnSwapDir_Click(object sender, RoutedEventArgs e)\n        {\n            var appSettings = AppSettings;\n            if (appSettings == null)\n                return;\n\n            var dir = appSettings.SourceDirectory;\n\n            appSettings.SourceDirectory = appSettings.DestDirectory;\n            appSettings.DestDirectory = dir;\n        }\n\n        private void btnRefreshBackupTasks_Click(object sender, RoutedEventArgs e)\n        {\n            ReloadBackupTasks(BackupTaskDirectory);\n        }\n\n        private void btnBackupTaskDirectory_Click(object sender, RoutedEventArgs e)\n        {\n            if (!SaveSettings())\n            {\n                if (CommonFileDialog.IsPlatformSupported)\n                {\n                    var dialog = new CommonOpenFileDialog();\n                    dialog.Title = \"Choose Backup Tasks folder...\";\n                    dialog.IsFolderPicker = true;\n                    dialog.InitialDirectory = (System.IO.Directory.Exists(BackupTaskDirectory)) ? BackupTaskDirectory : \"\";\n\n                    CommonFileDialogResult result1 = dialog.ShowDialog();\n                    if (result1 == CommonFileDialogResult.Ok)\n                    {\n                        if (Directory.Exists(dialog.FileName))\n                            BackupTaskDirectory = dialog.FileName;\n                        else\n                            BackupTaskDirectory = System.IO.Path.GetDirectoryName(dialog.FileName);\n\n                        var up = new ChoUserPreferences();\n                        up.BackupTaskDirectory = BackupTaskDirectory;\n                        up.Save();\n\n                    }\n\n                    return;\n                }\n\n                ChoFolderBrowserDialog dlg1 = new ChoFolderBrowserDialog\n                {\n                    Description = \"Choose Backup Tasks folder...\",\n                    ShowNewFolderButton = true,\n                    ShowEditBox = true,\n                    ShowBothFilesAndFolders = false,\n                    NewStyle = true,\n                    SelectedPath = (System.IO.Directory.Exists(BackupTaskDirectory)) ? BackupTaskDirectory : \"\",\n                    ShowFullPathInEditBox = false,\n                };\n                dlg1.RootFolder = System.Environment.SpecialFolder.MyComputer;\n\n                var result = dlg1.ShowDialog();\n\n                if (result == System.Windows.Forms.DialogResult.OK)\n                {\n                    if (Directory.Exists(dlg1.SelectedPath))\n                        BackupTaskDirectory = dlg1.SelectedPath;\n                    else\n                        BackupTaskDirectory = System.IO.Path.GetDirectoryName(dlg1.SelectedPath);\n\n                    var up = new ChoUserPreferences();\n                    up.BackupTaskDirectory = BackupTaskDirectory;\n                    up.Save();\n\n                    //ReloadBackupTasks(BackupTaskDirectory);\n                }\n            }\n        }\n\n        private FileSystemWatcher _watcher;\n\n        private void DisposeBackupTasksDirectoryWatcher()\n        {\n            if (_watcher != null)\n                _watcher.Dispose();\n\n            _watcher = null;\n        }\n\n        private void WatchBackupTasksDirectory()\n        {\n            if (_watcher != null)\n                _watcher.Dispose();\n\n            if (WatchForChanges)\n            {\n                if (Directory.Exists(BackupTaskDirectory))\n                {\n                    _watcher = new FileSystemWatcher();\n                    _watcher.Path = BackupTaskDirectory;\n                    _watcher.NotifyFilter = NotifyFilters.Attributes |\n                        NotifyFilters.CreationTime |\n                        NotifyFilters.FileName |\n                        NotifyFilters.LastAccess |\n                        NotifyFilters.LastWrite |\n                        NotifyFilters.Size |\n                        NotifyFilters.Security;\n\n                    _watcher.Filter = \"*.*\";\n                    _watcher.Deleted += (o, e) => ReloadBackupTasks();\n                    _watcher.Created += (o, e) => ReloadBackupTasks();\n                    _watcher.Changed += (o, e) => ReloadBackupTasks();\n                    _watcher.Renamed += (o, e) => ReloadBackupTasks();\n                    _watcher.EnableRaisingEvents = true;\n                }\n            }\n        }\n\n        private void ReloadBackupTasks(string settingsFilePath = null)\n        {\n            ReloadBackupTasks(BackupTaskDirectory, settingsFilePath);\n        }\n\n        private bool _isBackupTasksLoading = false;\n        private object _padLock = new object();\n        private void ReloadBackupTasks(string backupTasksDir, string settingsFilePath = null)\n        {\n            if (Application.Current == null)\n                return;\n\n            if (!SaveSettings())\n            {\n                if (_isBackupTasksLoading)\n                    return;\n\n                lock (_padLock)\n                {\n                    if (_isBackupTasksLoading)\n                        return;\n                    Application.Current.Dispatcher.BeginInvoke(\n                    new Action(() =>\n                    {\n                        try\n                        {\n                            var selectedBackupTaskInfo = SelectedBackupTaskFilePath;\n\n                            _isBackupTasksLoading = true;\n                            BackupTaskInfos.Clear();\n                            if (backupTasksDir.IsNullOrWhiteSpace() || !Directory.Exists(backupTasksDir))\n                            {\n                                NewSettingsFile();\n                                return;\n                            }\n\n                            foreach (var fi in Directory.GetFiles(backupTasksDir, $\"*{AppHost.AppFileExt}\").Take(1000)\n                                .Select(f => new ChoBackupTaskInfo(f)))\n                            {\n                                BackupTaskInfos.Add(fi);\n                            }\n                            //if (selectedBackupTaskInfo.IsNullOrWhiteSpace()\n                            //    || !BackupTaskInfos.Select(f => f.FilePath == selectedBackupTaskInfo).Any())\n                            //{\n                            //    var fi = BackupTaskInfos.FirstOrDefault();\n                            //    selectedBackupTaskInfo = fi != null ? fi.FilePath : null;\n                            //}\n                            if (!settingsFilePath.IsNullOrWhiteSpace() &&\n                                    BackupTaskInfos.Where(f => f.FilePath == settingsFilePath).Any())\n                            {\n                                SelectedBackupTaskFilePath = BackupTaskInfos.Where(f => f.FilePath == settingsFilePath).First().FilePath;\n                            }\n                            //WatchBackupTasksDirectory();\n                        }\n                        finally\n                        {\n                            _isBackupTasksLoading = false;\n                        }\n                    }),\n                    DispatcherPriority.ContextIdle,\n                    null\n                );\n                }\n            }\n        }\n\n        private void mnuCloneTask_Click(object sender, RoutedEventArgs e)\n        {\n            if (SelectedBackupTaskItem != null)\n                CloneTask();\n        }\n\n        private void mnuDeleteTask_Click(object sender, RoutedEventArgs e)\n        {\n            if (SelectedBackupTaskItem != null)\n                DeleteTask();\n        }\n\n        private void mnuQueueTask_Click(object sender, RoutedEventArgs e)\n        {\n            QueueTask();\n        }\n\n        private void QueueTask()\n        {\n            if (SelectedBackupTaskItem == null)\n                return;\n\n            _taskQManager.Add(SelectedBackupTaskItem.TaskName, taskFilePath: SelectedBackupTaskFilePath,\n                onSuccess: t => UpdateStatus($\"`{t.TaskName}` task queued successfully.\", null),\n                onFailure: (t, e) => UpdateStatus($\"`{t}` task failed to queue.\", null)\n                );\n        }\n\n        private void lstBackupTasks_PreviewKeyUp(object sender, KeyEventArgs e)\n        {\n            if (e.Key == Key.Delete)\n            {\n                if (SelectedBackupTaskItem != null)\n                    DeleteTask();\n            }\n            else if (e.Key == Key.V && (Keyboard.Modifiers & ModifierKeys.Control) == ModifierKeys.Control)\n            {\n                if (SelectedBackupTaskItem != null)\n                    CloneTask();\n            }\n            else if (e.Key == Key.Q && (Keyboard.Modifiers & ModifierKeys.Control) == ModifierKeys.Control)\n            {\n                if (SelectedBackupTaskItem != null)\n                    QueueTask();\n            }\n        }\n\n        private void btnDeleteTask_Click(object sender, RoutedEventArgs e)\n        {\n            DeleteTask();\n        }\n\n        private void DeleteTask()\n        {\n            if (!SaveSettings())\n            {\n                if (SelectedBackupTaskFilePath.IsNullOrWhiteSpace())\n                    return;\n\n                MessageBoxResult result = MessageBoxResult.Yes;\n                if (ConfirmOnDelete)\n                {\n                    result = MessageBox.Show($\"Are you sure you want to delete `{Path.GetFileName(SelectedBackupTaskFilePath)}` task?\",\n                        Caption, MessageBoxButton.YesNo, MessageBoxImage.Warning);\n                }\n\n                if (result == MessageBoxResult.Yes)\n                {\n                    try\n                    {\n                        File.Delete(SelectedBackupTaskFilePath);\n                        //ReloadBackupTasks();\n                        var index = BackupTaskInfos.ToList().FindIndex(f => f.FilePath == SelectedBackupTaskFilePath);\n                        BackupTaskInfos.RemoveAt(index);\n                        if (index - 1 >= 0)\n                        {\n                            SelectedBackupTaskFilePath = BackupTaskInfos[index - 1].FilePath;\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        MessageBox.Show($\"Failed to delete `{Path.GetFileName(SelectedBackupTaskFilePath)}` task. {ex.Message}\",\n                            Caption, MessageBoxButton.OK, MessageBoxImage.Error);\n                    }\n                }\n            }\n        }\n\n        private void btnQueueTask_Click(object sender, RoutedEventArgs e)\n        {\n            QueueTask();\n        }\n\n        private string GetNextCloneTaskFileName(string taskFilePath)\n        {\n            string fileName = Path.GetFileNameWithoutExtension(taskFilePath);\n            string dirName = Path.GetDirectoryName(taskFilePath);\n\n            int index = 0;\n            while (true)\n            {\n                var newFilePath = Path.Combine(dirName, $\"{fileName}_{index}{AppHost.AppFileExt}\");\n                if (!File.Exists(newFilePath))\n                    return newFilePath;\n\n                index++;\n            }\n        }\n\n        private void btnCloneTask_Click(object sender, RoutedEventArgs e)\n        {\n            CloneTask();\n        }\n\n        private void CloneTask()\n        {\n            if (!SaveSettings())\n            {\n                if (SelectedBackupTaskFilePath.IsNullOrWhiteSpace())\n                    return;\n\n                var clonedTaskFilePath = GetNextCloneTaskFileName(SelectedBackupTaskFilePath);\n                try\n                {\n                    var bfi = new ChoBackupTaskInfo(SelectedBackupTaskFilePath);\n                    File.Copy(SelectedBackupTaskFilePath, clonedTaskFilePath, true);\n                    if (KeepDateCreated)\n                        File.SetCreationTime(clonedTaskFilePath, bfi.CreatedDate);\n                    if (KeepDateModified)\n                        File.SetLastWriteTime(clonedTaskFilePath, bfi.ModifiedDate);\n\n                    //ReloadBackupTasks();\n                    BackupTaskInfos.Add(new ChoBackupTaskInfo(clonedTaskFilePath));\n                    SelectedBackupTaskFilePath = clonedTaskFilePath;\n                }\n                catch (Exception ex)\n                {\n                    MessageBox.Show($\"Failed to clone `{Path.GetFileName(SelectedBackupTaskFilePath)}` task. {ex.Message}\",\n                        Caption, MessageBoxButton.OK, MessageBoxImage.Error);\n                }\n            }\n        }\n        private void TaskNameGridViewColumnHeader_SizeChanged(object sender, SizeChangedEventArgs e)\n        {\n            if (e.NewSize.Width <= 60)\n            {\n                e.Handled = true;\n                ((GridViewColumnHeader)sender).Column.Width = 60;\n            }\n            ChoGridViewColumnVisibilityManager.SetGridColumnWidth((GridViewColumnHeader)sender);\n            TaskNameColumnWidth = ((GridViewColumnHeader)sender).Column.Width;\n        }\n        private void DateCreatedGridViewColumnHeader_SizeChanged(object sender, SizeChangedEventArgs e)\n        {\n            if (!ChoGridViewColumnVisibilityManager.GetIsVisible(((GridViewColumnHeader)sender).Column))\n                return;\n\n            if (e.NewSize.Width <= 60)\n            {\n                e.Handled = true;\n                ((GridViewColumnHeader)sender).Column.Width = 0;\n                ((GridViewColumnHeader)sender).Column.Width = 60;\n            }\n            ChoGridViewColumnVisibilityManager.SetGridColumnWidth((GridViewColumnHeader)sender);\n            DateCreatedColumnWidth = ((GridViewColumnHeader)sender).Column.Width;\n        }\n        private void DateModifiedGridViewColumnHeader_SizeChanged(object sender, SizeChangedEventArgs e)\n        {\n            if (!ChoGridViewColumnVisibilityManager.GetIsVisible(((GridViewColumnHeader)sender).Column))\n                return;\n\n            if (e.NewSize.Width <= 60)\n            {\n                e.Handled = true;\n                ((GridViewColumnHeader)sender).Column.Width = 0;\n                ((GridViewColumnHeader)sender).Column.Width = 60;\n            }\n            ChoGridViewColumnVisibilityManager.SetGridColumnWidth((GridViewColumnHeader)sender);\n            DateModifiedColumnWidth = ((GridViewColumnHeader)sender).Column.Width;\n        }\n\n        private void mnuTaskQColumnToFit_Click(object sender, RoutedEventArgs e)\n        {\n            var header = _selectedTaskQGridViewColumnHeader;\n            if (header == null)\n                return;\n\n            header.Column.Width = 0;\n            header.Column.Width = Double.NaN;\n            ChoGridViewColumnVisibilityManager.SetGridColumnWidth(header);\n        }\n\n        private void mnuColumnToFit_Click(object sender, RoutedEventArgs e)\n        {\n            var header = _selectedGridViewColumnHeader;\n            if (header == null)\n                return;\n\n            header.Column.Width = 0;\n            header.Column.Width = Double.NaN;\n            ChoGridViewColumnVisibilityManager.SetGridColumnWidth(header);\n        }\n\n        private void mnuAllColumnsToFit_Click(object sender, RoutedEventArgs e)\n        {\n            ChoGridViewColumnVisibilityManager.ResizeAllColumnsToFit(lstBackupTasks);\n        }\n\n        private void mnuTaskQAllColumnsToFit_Click(object sender, RoutedEventArgs e)\n        {\n            ChoGridViewColumnVisibilityManager.ResizeAllColumnsToFit(lstTaskQueue);\n        }\n\n        private GridViewColumnHeader _selectedGridViewColumnHeader;\n        private void GridViewColumnHeader_MouseDown(object sender, MouseButtonEventArgs e)\n        {\n            if (e.RightButton == MouseButtonState.Pressed)\n            {\n                _selectedGridViewColumnHeader = sender as GridViewColumnHeader;\n            }\n            else\n            {\n                _selectedGridViewColumnHeader = null;\n            }\n        }\n\n        private GridViewColumnHeader _selectedTaskQGridViewColumnHeader;\n        private void GridViewTaskQColumnHeader_MouseDown(object sender, MouseButtonEventArgs e)\n        {\n            if (e.RightButton == MouseButtonState.Pressed)\n            {\n                _selectedTaskQGridViewColumnHeader = sender as GridViewColumnHeader;\n            }\n            else\n            {\n                _selectedTaskQGridViewColumnHeader = null;\n            }\n        }\n\n        private void grdTaskQColumnHeader_Click(object sender, RoutedEventArgs e)\n        {\n            GridViewColumnHeader column = (sender as GridViewColumnHeader);\n            SortTaskQColumn(column);\n        }\n        private void grdBackupTaskColumnHeader_Click(object sender, RoutedEventArgs e)\n        {\n            GridViewColumnHeader column = (sender as GridViewColumnHeader);\n            SortColumn(column);\n        }\n\n        private void SortColumn(GridViewColumnHeader column)\n        {\n            string sortBy = column.Tag.ToString();\n            if (listViewSortCol != null)\n            {\n                AdornerLayer.GetAdornerLayer(listViewSortCol).Remove(listViewSortAdorner);\n                lstBackupTasks.Items.SortDescriptions.Clear();\n            }\n\n            ListSortDirection newDir = ListSortDirection.Ascending;\n            if (listViewSortCol == column && listViewSortAdorner.Direction == newDir)\n                newDir = ListSortDirection.Descending;\n\n            listViewSortCol = column;\n            listViewSortAdorner = new ChoSortAdorner(listViewSortCol, newDir);\n            AdornerLayer.GetAdornerLayer(listViewSortCol).Add(listViewSortAdorner);\n            lstBackupTasks.Items.SortDescriptions.Add(new SortDescription(sortBy, newDir));\n        }\n\n        private void SortTaskQColumn(GridViewColumnHeader column)\n        {\n            string sortBy = column.Tag.ToString();\n            if (listViewSortCol != null)\n            {\n                AdornerLayer.GetAdornerLayer(listViewSortCol).Remove(listViewSortAdorner);\n                lstTaskQueue.Items.SortDescriptions.Clear();\n            }\n\n            ListSortDirection newDir = ListSortDirection.Ascending;\n            if (listViewSortCol == column && listViewSortAdorner.Direction == newDir)\n                newDir = ListSortDirection.Descending;\n\n            listViewSortCol = column;\n            listViewSortAdorner = new ChoSortAdorner(listViewSortCol, newDir);\n            AdornerLayer.GetAdornerLayer(listViewSortCol).Add(listViewSortAdorner);\n            lstTaskQueue.Items.SortDescriptions.Add(new SortDescription(sortBy, newDir));\n        }\n\n        private void mnuResetExpander_Click(object sender, RoutedEventArgs e)\n        {\n            ControlPanelWidth = new GridLength(300);\n        }\n\n        private void btnApplicationCmds_Click(object sender, RoutedEventArgs e)\n        {\n            var addButton = sender as FrameworkElement;\n            if (addButton != null)\n            {\n                addButton.ContextMenu.IsOpen = true;\n            }\n        }\n\n        private void mnuLaunchNewInstance_Click(object sender, RoutedEventArgs e)\n        {\n            var info = new System.Diagnostics.ProcessStartInfo(ChoApplication.EntryAssemblyLocation);\n            System.Diagnostics.Process.Start(info);\n        }\n\n        private void mnuRunasAdministrator_Click(object sender, RoutedEventArgs e)\n        {\n            AppHost.RunAsAdmin();\n        }\n\n        private void mnuRegisterShellExtensions_Click(object sender, RoutedEventArgs e)\n        {\n            AppHost.RegisterShellExtensions();\n        }\n\n        private void mnuUnregisterShellExtensions_Click(object sender, RoutedEventArgs e)\n        {\n            AppHost.UnregisterShellExtensions();\n        }\n\n        private void mnuLightTheme_Click(object sender, RoutedEventArgs e)\n        {\n            ThemeManager.ChangeAppStyle(Application.Current,\n                            ThemeManager.GetAccent(\"Steel\"),\n                            ThemeManager.GetAppTheme(\"BaseLight\"));\n\n        }\n\n        private void mnuDarkTheme_Click(object sender, RoutedEventArgs e)\n        {\n            bool darkMode = mnuDarkTheme.IsChecked;\n\n            ChangeTheme(darkMode);\n            ChangeTheme(!darkMode);\n            ChangeTheme(darkMode);\n        }\n\n        private void ChangeTheme(bool darkMode = false)\n        {\n            MainWindow wnd = Application.Current.MainWindow as MainWindow;\n            Accent accent = null;\n            AppTheme appTheme = null;\n\n            if (!darkMode)\n            {\n                accent = ThemeManager.GetAccent(\"Steel\");\n                appTheme = ThemeManager.GetAppTheme(\"BaseLight\");\n            }\n            else\n            {\n                accent = ThemeManager.GetAccent(\"Steel\");\n                appTheme = ThemeManager.GetAppTheme(\"BaseDark\");\n            }\n            ChoAppTheme.Instance.Refresh(accent, appTheme, darkMode);\n            ThemeManager.ChangeAppStyle(wnd, accent, appTheme);\n\n            ControlMouseOverBackgroundBrush =  ChoAppTheme.Instance.ControlMouseOverBackgroundBrush;\n            ControlBackgroundBrush = ChoAppTheme.Instance.ControlBackgroundBrush;\n            ControlForegroundBrush = ChoAppTheme.Instance.ControlForegroundBrush;\n            PGControlBackgroundBrush = ChoAppTheme.Instance.PGControlBackgroundBrush;\n            PGControlForegroundBrush = ChoAppTheme.Instance.PGControlForegroundBrush;\n            PGControlBorderBrush = ChoAppTheme.Instance.PGControlBorderBrush;\n            TextBoxFocusBorderBrush = ChoAppTheme.Instance.TextBoxFocusBorderBrush;\n            ThemeForegroundBrush = ChoAppTheme.Instance.ThemeForegroundBrush;\n            ThemeBackgroundBrush = ChoAppTheme.Instance.ThemeBackgroundBrush;\n            MouseOverBrush = ChoAppTheme.Instance.MouseOverBrush;\n            TabControlBackgroundBrush = ChoAppTheme.Instance.TabControlBackgroundBrush;\n            TabControlForegroundBrush = ChoAppTheme.Instance.TabControlForegroundBrush;\n\n            //txtStatus.TextArea.TextView.Redraw();\n            txtStatus.TextArea.TextView.LineTransformers.Add(new LineColorizer(ControlForegroundBrush, null));\n        }\n\n        private void btnFindBackupTaskDirectoryInFileExplorer_Click(object sender, RoutedEventArgs e)\n        {\n            try\n            {\n                Process.Start(new System.Diagnostics.ProcessStartInfo()\n                {\n                    FileName = BackupTaskDirectory + \"\\\\\",\n                    UseShellExecute = true,\n                    Verb = \"open\"\n                });\n            }\n            catch { }\n        }\n\n        private void mnuAlwaysOnTop_Click(object sender, RoutedEventArgs e)\n        {\n            ChoWindowsManager.AlwaysOnTop(mnuAlwaysOnTop.IsChecked);\n        }\n\n        private void mnuRunatSystemsStartup_Click(object sender, RoutedEventArgs e)\n        {\n            try\n            {\n                ChoApplication.RunAtSystemStartup(\"{0}_I\".FormatString(ChoGlobalApplicationSettings.Me.ApplicationNameWithoutExtension),\n                    ChoAssembly.GetEntryAssembly().Location, !mnuRunatSystemsStartup.IsChecked);\n\n                //var rkAppRun = Registry.CurrentUser.OpenSubKey(\"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\", true);\n                //if (rkAppRun != null)\n                //    SetValueToRegistry(rkAppRun, \n                //        \"{0}_I\".FormatString(ChoGlobalApplicationSettings.Me.ApplicationNameWithoutExtension), \n                //        @\"\"\"{0}\"\"\".FormatString(ChoAssembly.GetEntryAssembly().Location), !mnuRunatSystemsStartup.IsChecked);\n            }\n            catch { }\n        }\n        private static bool GetRunAtSystemsStartupRegistryValue()\n        {\n            var rkAppRun = Registry.CurrentUser.OpenSubKey(\"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\", true);\n            if (rkAppRun == null)\n                return false;\n\n            string appName = \"{0}_I\".FormatString(ChoGlobalApplicationSettings.Me.ApplicationNameWithoutExtension);\n            string appLocation = ChoAssembly.GetEntryAssembly().Location;\n\n            if (String.IsNullOrEmpty(appName))\n                return false;\n\n            if (rkAppRun == null)\n                return false;\n            var value = rkAppRun.GetValue(appName) as string;\n            if (value != null)\n                value = value.Replace(\"\\\"\", String.Empty);\n            return value == appLocation;\n        }\n        private void RestoreRecentNumbersList()\n        {\n            if (null == Properties.Settings.Default.RecentNumbersList)\n            {\n                Properties.Settings.Default.RecentNumbersList = new StringCollection();\n            }\n\n            StringCollection userNumbers = Properties.Settings.Default.RecentNumbersList;\n            foreach (string recentNumber in userNumbers)\n            {\n                if (!recentNumber.IsNullOrWhiteSpace() && Directory.Exists(recentNumber))\n                    RecentNumbersList.Add(recentNumber);\n            }\n        }\n        private void SaveRecentNumbersList()\n        {\n            if (null == Properties.Settings.Default.RecentNumbersList)\n            {\n                Properties.Settings.Default.RecentNumbersList = new StringCollection();\n            }\n\n            Properties.Settings.Default.RecentNumbersList.Clear();\n            Properties.Settings.Default.RecentNumbersList.AddRange(RecentNumbersList.ToArray<string>());\n\n            Properties.Settings.Default.Save();\n        }\n        private void LoadTaskQTaskItems()\n        {\n#if !TEST_MODE\n            lock (_taskQueueItemsLock)\n            {\n                try\n                {\n                    var xmlSerializer = new XmlSerializer(typeof(ChoTaskQueueItem[]));\n                    var xml = Properties.Settings.Default.TaskQTaskItems;\n\n                    var objs = (ChoTaskQueueItem[])xmlSerializer.Deserialize(new StringReader(xml));\n                    _taskQueueItems.Clear();\n                    foreach (var obj in objs)\n                    {\n                        if (obj.Status == TaskStatus.Running)\n                        {\n                            obj.Status = TaskStatus.Stopped;\n                            obj.EndTime = DateTime.Now;\n                            obj.ErrorMessage = \"Operation terminated by application shutdown.\";\n                        }\n\n                        _taskQueueItems.Add(obj);\n                    }\n                }\n                catch { }\n            }\n#endif\n        }\n        private void SaveTaskQTaskItems()\n        {\n            lock (_taskQueueItemsLock)\n            {\n                try\n                {\n                    XmlSerializer xsSubmit = new XmlSerializer(typeof(ChoTaskQueueItem[]));\n                    var xml = \"\";\n\n                    using (var sww = new StringWriter())\n                    {\n                        using (XmlWriter writer = XmlWriter.Create(sww))\n                        {\n                            xsSubmit.Serialize(writer, _taskQueueItems.ToArray());\n                            xml = sww.ToString();\n                        }\n                    }\n                    Properties.Settings.Default.TaskQTaskItems = xml;\n\n                    Properties.Settings.Default.Save();\n                }\n                catch { }\n            }\n        }\n\n        private void lstTaskQueue_PreviewKeyUp(object sender, KeyEventArgs e)\n        {\n            if (e.Key == Key.Delete)\n            {\n                TaskQRemoveTask();\n            }\n            else if (e.Key == Key.Up && (Keyboard.Modifiers & ModifierKeys.Control) == ModifierKeys.Control)\n            {\n                TaskQMoveUpTask();\n            }\n            else if (e.Key == Key.Down && (Keyboard.Modifiers & ModifierKeys.Control) == ModifierKeys.Control)\n            {\n                TaskQMoveDownTask();\n            }\n            else if (e.Key == Key.S && (Keyboard.Modifiers & ModifierKeys.Control) == ModifierKeys.Control)\n            {\n                TaskQStopTask();\n            }\n            else if (e.Key == Key.O && (Keyboard.Modifiers & ModifierKeys.Control) == ModifierKeys.Control)\n            {\n                OpenTaskLogFile();\n            }\n        }\n\n        private void btnTaskQStopTask_Click(object sender, RoutedEventArgs e)\n        {\n            TaskQStopTask();\n        }\n        private void TaskQStopTask()\n        {\n            if (_selectedTaskQueueItem == null)\n                return;\n\n        }\n        private void btnTaskQMoveUpTask_Click(object sender, RoutedEventArgs e)\n        {\n            TaskQMoveUpTask();\n        }\n        private void TaskQMoveUpTask()\n        {\n            return;\n            if (_selectedTaskQueueItem == null)\n                return;\n\n            lock (_taskQueueItemsLock)\n            {\n                if (_selectedTaskQueueItem == null)\n                    return;\n\n                var index = TaskQueueItems.IndexOf(_selectedTaskQueueItem);\n                TaskQueueItems.Move(index + 1, index);\n            }\n        }\n\n        private void btnTaskQMoveDownTask_Click(object sender, RoutedEventArgs e)\n        {\n            TaskQMoveDownTask();\n        }\n        private void TaskQMoveDownTask()\n        {\n            return;\n            if (_selectedTaskQueueItem == null)\n                return;\n\n            lock (_taskQueueItemsLock)\n            {\n                if (_selectedTaskQueueItem == null)\n                    return;\n\n                var index = TaskQueueItems.IndexOf(_selectedTaskQueueItem);\n                TaskQueueItems.Move(index - 1, index);\n            }\n        }\n\n        private void btnTaskQRemoveTask_Click(object sender, RoutedEventArgs e)\n        {\n            TaskQRemoveTask();\n        }\n\n        private void TaskQRemoveTask()\n        {\n            lock (_taskQueueItemsLock)\n            {\n                if (_selectedTaskQueueItem != null)\n                {\n                    MessageBoxResult result = MessageBoxResult.Yes;\n                    if (ConfirmOnDelete)\n                    {\n                        result = MessageBox.Show($\"Are you sure you want to remove `{Path.GetFileName(_selectedTaskQueueItem.TaskName)}` task?\",\n                            Caption, MessageBoxButton.YesNo, MessageBoxImage.Warning);\n                    }\n\n                    if (result == MessageBoxResult.Yes)\n                    {\n                        try\n                        {\n                            _taskQueueItems.Remove(_selectedTaskQueueItem);\n                        }\n                        catch (Exception ex)\n                        {\n                            MessageBox.Show($\"Failed to remove `{Path.GetFileName(_selectedTaskQueueItem.TaskName)}` task. {ex.Message}\",\n                                Caption, MessageBoxButton.OK, MessageBoxImage.Error);\n                        }\n                    }\n                }\n            }\n        }\n\n        private void grdTaskQIdColumnHeader_SizeChanged(object sender, SizeChangedEventArgs e)\n        {\n            if (e.NewSize.Width <= 60)\n            {\n                e.Handled = true;\n                ((GridViewColumnHeader)sender).Column.Width = 60;\n            }\n            ChoGridViewColumnVisibilityManager.SetGridColumnWidth((GridViewColumnHeader)sender);\n            TaskQIdColumnWidth = ((GridViewColumnHeader)sender).Column.Width;\n        }\n\n        private void grdTaskQNameColumnHeader_SizeChanged(object sender, SizeChangedEventArgs e)\n        {\n            if (e.NewSize.Width <= 60)\n            {\n                e.Handled = true;\n                ((GridViewColumnHeader)sender).Column.Width = 60;\n            }\n            ChoGridViewColumnVisibilityManager.SetGridColumnWidth((GridViewColumnHeader)sender);\n            TaskQNameColumnWidth = ((GridViewColumnHeader)sender).Column.Width;\n        }\n\n        private void grdTaskQQueueTimeColumnHeader_SizeChanged(object sender, SizeChangedEventArgs e)\n        {\n            if (!ChoGridViewColumnVisibilityManager.GetIsVisible(((GridViewColumnHeader)sender).Column))\n                return;\n\n            if (e.NewSize.Width <= 60)\n            {\n                e.Handled = true;\n                ((GridViewColumnHeader)sender).Column.Width = 0;\n                ((GridViewColumnHeader)sender).Column.Width = 60;\n            }\n            ChoGridViewColumnVisibilityManager.SetGridColumnWidth((GridViewColumnHeader)sender);\n            TaskQQueueTimeColumnWidth = ((GridViewColumnHeader)sender).Column.Width;\n        }\n\n        private void grdTaskQStartTimeColumnHeader_SizeChanged(object sender, SizeChangedEventArgs e)\n        {\n            if (!ChoGridViewColumnVisibilityManager.GetIsVisible(((GridViewColumnHeader)sender).Column))\n                return;\n\n            if (e.NewSize.Width <= 60)\n            {\n                e.Handled = true;\n                ((GridViewColumnHeader)sender).Column.Width = 0;\n                ((GridViewColumnHeader)sender).Column.Width = 60;\n            }\n            ChoGridViewColumnVisibilityManager.SetGridColumnWidth((GridViewColumnHeader)sender);\n            TaskQStartTimeColumnWidth = ((GridViewColumnHeader)sender).Column.Width;\n        }\n\n        private void grdTaskQEndTimeColumnHeader_SizeChanged(object sender, SizeChangedEventArgs e)\n        {\n            if (!ChoGridViewColumnVisibilityManager.GetIsVisible(((GridViewColumnHeader)sender).Column))\n                return;\n\n            if (e.NewSize.Width <= 60)\n            {\n                e.Handled = true;\n                ((GridViewColumnHeader)sender).Column.Width = 0;\n                ((GridViewColumnHeader)sender).Column.Width = 60;\n            }\n            ChoGridViewColumnVisibilityManager.SetGridColumnWidth((GridViewColumnHeader)sender);\n            TaskQEndTimeColumnWidth = ((GridViewColumnHeader)sender).Column.Width;\n        }\n\n        private void grdTaskQStatusColumnHeader_SizeChanged(object sender, SizeChangedEventArgs e)\n        {\n            if (!ChoGridViewColumnVisibilityManager.GetIsVisible(((GridViewColumnHeader)sender).Column))\n                return;\n\n            if (e.NewSize.Width <= 60)\n            {\n                e.Handled = true;\n                ((GridViewColumnHeader)sender).Column.Width = 0;\n                ((GridViewColumnHeader)sender).Column.Width = 60;\n            }\n            ChoGridViewColumnVisibilityManager.SetGridColumnWidth((GridViewColumnHeader)sender);\n            TaskQStatusColumnWidth = ((GridViewColumnHeader)sender).Column.Width;\n        }\n\n        private void grdTaskQErrorMsgColumnHeader_SizeChanged(object sender, SizeChangedEventArgs e)\n        {\n            if (!ChoGridViewColumnVisibilityManager.GetIsVisible(((GridViewColumnHeader)sender).Column))\n                return;\n\n            if (e.NewSize.Width <= 60)\n            {\n                e.Handled = true;\n                ((GridViewColumnHeader)sender).Column.Width = 0;\n                ((GridViewColumnHeader)sender).Column.Width = 60;\n            }\n            ChoGridViewColumnVisibilityManager.SetGridColumnWidth((GridViewColumnHeader)sender);\n            TaskQErrorMsgColumnWidth = ((GridViewColumnHeader)sender).Column.Width;\n        }\n\n        private void btnOpenTaskLogFile_Click(object sender, RoutedEventArgs e)\n        {\n            OpenTaskLogFile();\n        }\n\n        private void mnuTaskQOpenLogFile_Click(object sender, RoutedEventArgs e)\n        {\n            OpenTaskLogFile();\n        }\n\n        private void OpenTaskLogFile()\n        {\n            if (_selectedTaskQueueItem != null && File.Exists(_selectedTaskQueueItem.LogFilePath))\n            {\n                try\n                {\n                    Process.Start(\"notepad.exe\", _selectedTaskQueueItem.LogFilePath);\n                }\n                catch { }\n            }\n        }\n\n        private void btnOpenTaskLogFolder_Click(object sender, RoutedEventArgs e)\n        {\n            OpenTaskLogFolder();\n        }\n\n        private void OpenTaskLogFolder()\n        {\n            try\n            {\n                Process.Start(\"explorer.exe\", ChoTaskQueueItemLogInfo.AppLogFolder);\n            }\n            catch { }\n\n        }\n\n        private void txtStatus_KeyDown(object sender, KeyEventArgs e)\n        {\n            e.Handled = true;\n            base.OnKeyDown(e);\n        }\n    }\n\n    //public class ExtendedPropertyGrid : PropertyGrid\n    //{\n    //    protected override void OnFilterChanged(string oldValue, string newValue)\n    //    {\n    //        newValue = newValue.ToLower();\n    //        CollectionViewSource.GetDefaultView((object)this.Properties).Filter\n    //            = (item => (item as PropertyItem).DisplayName.IndexOf(newValue, StringComparison.InvariantCultureIgnoreCase) >= 0\n    //            || (item as PropertyItem).Description.IndexOf(newValue, StringComparison.InvariantCultureIgnoreCase) >= 0);\n    //    }\n    //}\n\n    public class ThemeMenuItem : MenuItem\n    {\n        protected override void OnClick()\n        {\n            var ic = Parent as ItemsControl;\n            if (null != ic)\n            {\n                var rmi = ic.Items.OfType<ThemeMenuItem>().FirstOrDefault(i => i.IsChecked);\n                if (null != rmi) rmi.IsChecked = false;\n\n                IsChecked = true;\n                ChoApplicationThemeManager.Theme = this.Tag as string;\n            }\n            base.OnClick();\n        }\n    }\n    public class AccentMenuItem : MenuItem\n    {\n        protected override void OnClick()\n        {\n            var ic = Parent as ItemsControl;\n            if (null != ic)\n            {\n                var rmi = ic.Items.OfType<AccentMenuItem>().FirstOrDefault(i => i.IsChecked);\n                if (null != rmi) rmi.IsChecked = false;\n\n                IsChecked = true;\n                ChoApplicationThemeManager.Accent = this.Header as string;\n            }\n            base.OnClick();\n        }\n    }\n\n    public class LineColorizer : DocumentColorizingTransformer\n    {\n        private Brush _foregroundBrush;\n        private Brush _backgroundBrush;\n\n        public LineColorizer(Brush foregroundBrush, Brush backgroundBrush)\n        {\n            _foregroundBrush = foregroundBrush;\n            _backgroundBrush = backgroundBrush;\n        }\n\n        protected override void ColorizeLine(ICSharpCode.AvalonEdit.Document.DocumentLine line)\n        {\n            ChangeLinePart(line.Offset, line.EndOffset, ApplyChanges);\n        }\n\n        void ApplyChanges(VisualLineElement element)\n        {\n            // This is where you do anything with the line\n            if (_foregroundBrush != null)\n                element.TextRunProperties.SetForegroundBrush(_foregroundBrush);\n            if (_backgroundBrush != null)\n                element.TextRunProperties.SetBackgroundBrush(_backgroundBrush);\n        }\n    }\n}\n"
        },
        {
          "name": "Properties",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.3271484375,
          "content": "[![github](https://img.shields.io/github/stars/Cinchoo/ChoEazyCopy.svg)]()\n\n# ChoEazyCopy, a RoboCopy GUI\nSimple and powerful GUI to the Microsoft RoboCopy tool\nRoboCopy is a powerful tool included in Microsoft Windows Server that is used to perform more advanced file replication tasks. The biggest benefit you'll find is the ability to create full mirror duplicates of two file structures (including all subdirectories and files, if you choose). RoboCopy also allows you to preserve all of the associated file information, including date and time stamps, security access control lists (ACLs) and more, which is missing from normal file copy operations.\n\nFor people who like to work with the command line, RoboCopy.exe, as it is, is great enough for them. However for those who are comfortable to work with a GUI, here is EazyCopy, a simple and intuitive GUI tool for the RoboCopy command.\n\nThis tool is developed using Cinchoo - An application framework for .NET. It is another working example of using some of the key features of the Cinchoo framework.\n\nFeatures:\n\n* Simple and intuitive GUI.\n* Compose and Save the options as a profile for reuse.\n* Run multiple instances.\n* Run and launch from Windows System Tray\n* Provides a text box with RoboCopy commands associated with the changes to the properties.\n* Display immediate hints for an option highlighted in the property grid or in the text editor.\n* The ability to run the RoboCopy within the GUI.\n\n![alt text](Images/EazyCopyMain.PNG)\n![alt text](Images/EazyCopyMain1.PNG)\n \n#### To read more about this tool, please refer to the CodeProject article below\n\n[Cinchoo - EazyCopy, yet another RoboCopy GUI](http://www.codeproject.com/Articles/988605/Cinchoo-EazyCopy-yet-another-RoboCopy-GU)\n\n## Binaries can be downloaded from \n\n[Download Binaries](https://github.com/Cinchoo/ChoEazyCopy/releases)\n\n### This software requires .NET Framework 4 / .NET Framework 4.5.2\n\n[.NET Framework 4](https://www.microsoft.com/en-us/download/confirmation.aspx?id=17718)\n\n[.NET Framework 4.5.2](https://www.microsoft.com/en-us/download/details.aspx?id=42642)\n\n\nIf this project helps you be more productive, you can give me a cup of coffee :)\n\n[$10](https://buy.stripe.com/8wM7u54Gk2SQ4us001)/[$25](https://buy.stripe.com/8wMdSt5KogJGf969AE)/[$50](https://buy.stripe.com/28o5lX4Gk652e527su)/[$100](https://buy.stripe.com/eVa3dP2ycbpm0ec6or)\n\n"
        },
        {
          "name": "Resources",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}