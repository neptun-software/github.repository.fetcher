{
  "metadata": {
    "timestamp": 1736710924817,
    "page": 549,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "prometheus-net/prometheus-net",
      "stars": 1986,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 2.5234375,
          "content": "###############################################################################\n# Set default behavior to automatically normalize line endings.\n###############################################################################\n* text=auto\n\n# Linux scripts should have Linux file endings.\n*.sh text eol=lf\n\n###############################################################################\n# Set default behavior for command prompt diff.\n#\n# This is need for earlier builds of msysgit that does not have it on by\n# default for csharp files.\n# Note: This is only used by command line\n###############################################################################\n#*.cs     diff=csharp\n\n###############################################################################\n# Set the merge driver for project and solution files\n#\n# Merging from the command prompt will add diff markers to the files if there\n# are conflicts (Merging from VS is not affected by the settings below, in VS\n# the diff markers are never inserted). Diff markers may cause the following \n# file extensions to fail to load in VS. An alternative would be to treat\n# these files as binary and thus will always conflict and require user\n# intervention with every merge. To do so, just uncomment the entries below\n###############################################################################\n#*.sln       merge=binary\n#*.csproj    merge=binary\n#*.vbproj    merge=binary\n#*.vcxproj   merge=binary\n#*.vcproj    merge=binary\n#*.dbproj    merge=binary\n#*.fsproj    merge=binary\n#*.lsproj    merge=binary\n#*.wixproj   merge=binary\n#*.modelproj merge=binary\n#*.sqlproj   merge=binary\n#*.wwaproj   merge=binary\n\n###############################################################################\n# behavior for image files\n#\n# image files are treated as binary by default.\n###############################################################################\n#*.jpg   binary\n#*.png   binary\n#*.gif   binary\n\n###############################################################################\n# diff behavior for common document formats\n# \n# Convert binary document formats to text before diffing them. This feature\n# is only available from the command line. Turn it on by uncommenting the \n# entries below.\n###############################################################################\n#*.doc   diff=astextplain\n#*.DOC   diff=astextplain\n#*.docx  diff=astextplain\n#*.DOCX  diff=astextplain\n#*.dot   diff=astextplain\n#*.DOT   diff=astextplain\n#*.pdf   diff=astextplain\n#*.PDF   diff=astextplain\n#*.rtf   diff=astextplain\n#*.RTF   diff=astextplain\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 5.669921875,
          "content": "## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n##\n## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore\n\n# User-specific files\n*.rsuser\n*.suo\n*.user\n*.userosscache\n*.sln.docstates\n.vs/\n.idea/\n\n# User-specific files (MonoDevelop/Xamarin Studio)\n*.userprefs\n\n# Build results\n[Dd]ebug/\n[Dd]ebugPublic/\n[Rr]elease/\n[Rr]eleases/\nx64/\nx86/\n[Aa][Rr][Mm]/\n[Aa][Rr][Mm]64/\nbld/\n[Bb]in/\n[Oo]bj/\n[Ll]og/\n\n# Visual Studio 2015/2017 cache/options directory\n.vs/\n# Uncomment if you have tasks that create the project's static files in wwwroot\n#wwwroot/\n\n# Visual Studio 2017 auto generated files\nGenerated\\ Files/\n\n# MSTest test Results\n[Tt]est[Rr]esult*/\n[Bb]uild[Ll]og.*\n\n# NUNIT\n*.VisualState.xml\nTestResult.xml\n\n# Build Results of an ATL Project\n[Dd]ebugPS/\n[Rr]eleasePS/\ndlldata.c\n\n# Benchmark Results\nBenchmarkDotNet.Artifacts/\n\n# .NET Core\nproject.lock.json\nproject.fragment.lock.json\nartifacts/\n\n# StyleCop\nStyleCopReport.xml\n\n# Files built by Visual Studio\n*_i.c\n*_p.c\n*_h.h\n*.ilk\n*.meta\n*.obj\n*.iobj\n*.pch\n*.pdb\n*.ipdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.tmp_proj\n*_wpftmp.csproj\n*.log\n*.vspscc\n*.vssscc\n.builds\n*.pidb\n*.svclog\n*.scc\n\n# Chutzpah Test files\n_Chutzpah*\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opendb\n*.opensdf\n*.sdf\n*.cachefile\n*.VC.db\n*.VC.VC.opendb\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n*.sap\n\n# Visual Studio Trace Files\n*.e2e\n\n# TFS 2012 Local Workspace\n$tf/\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*/\n*.[Rr]e[Ss]harper\n*.DotSettings.user\n\n# JustCode is a .NET coding add-in\n.JustCode\n\n# TeamCity is a build add-in\n_TeamCity*\n\n# DotCover is a Code Coverage Tool\n*.dotCover\n\n# AxoCover is a Code Coverage Tool\n.axoCover/*\n!.axoCover/settings.json\n\n# Visual Studio code coverage results\n*.coverage\n*.coveragexml\n\n# NCrunch\n_NCrunch_*\n.*crunch*.local.xml\nnCrunchTemp_*\n\n# MightyMoose\n*.mm.*\nAutoTest.Net/\n\n# Web workbench (sass)\n.sass-cache/\n\n# Installshield output folder\n[Ee]xpress/\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish/\n\n# Publish Web Output\n*.[Pp]ublish.xml\n*.azurePubxml\n# Note: Comment the next line if you want to checkin your web deploy settings,\n# but database connection strings (with potential passwords) will be unencrypted\n*.pubxml\n*.publishproj\n\n# Microsoft Azure Web App publish settings. Comment the next line if you want to\n# checkin your Azure Web App publish settings, but sensitive information contained\n# in these scripts will be unencrypted\nPublishScripts/\n\n# NuGet Packages\n*.nupkg\n# The packages folder can be ignored because of Package Restore\n**/[Pp]ackages/*\n# except build/, which is used as an MSBuild target.\n!**/[Pp]ackages/build/\n# Uncomment if necessary however generally it will be regenerated when needed\n#!**/[Pp]ackages/repositories.config\n# NuGet v3's project.json files produces more ignorable files\n*.nuget.props\n*.nuget.targets\n\n# Microsoft Azure Build Output\ncsx/\n*.build.csdef\n\n# Microsoft Azure Emulator\necf/\nrcf/\n\n# Windows Store app package directories and files\nAppPackages/\nBundleArtifacts/\nPackage.StoreAssociation.xml\n_pkginfo.txt\n*.appx\n\n# Visual Studio cache files\n# files ending in .cache can be ignored\n*.[Cc]ache\n# but keep track of directories ending in .cache\n!*.[Cc]ache/\n\n# Others\nClientBin/\n~$*\n*~\n*.dbmdl\n*.dbproj.schemaview\n*.jfm\n*.pfx\n*.publishsettings\norleans.codegen.cs\n\n# Including strong name files can present a security risk\n# (https://github.com/github/gitignore/pull/2483#issue-259490424)\n#*.snk\n\n# Since there are multiple workflows, uncomment next line to ignore bower_components\n# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)\n#bower_components/\n# ASP.NET Core default setup: bower directory is configured as wwwroot/lib/ and bower restore is true\n**/wwwroot/lib/\n\n# RIA/Silverlight projects\nGenerated_Code/\n\n# Backup & report files from converting an old project file\n# to a newer Visual Studio version. Backup files are not needed,\n# because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\nUpgradeLog*.htm\nServiceFabricBackup/\n*.rptproj.bak\n\n# SQL Server files\n*.mdf\n*.ldf\n*.ndf\n\n# Business Intelligence projects\n*.rdl.data\n*.bim.layout\n*.bim_*.settings\n*.rptproj.rsuser\n\n# Microsoft Fakes\nFakesAssemblies/\n\n# GhostDoc plugin setting file\n*.GhostDoc.xml\n\n# Node.js Tools for Visual Studio\n.ntvs_analysis.dat\nnode_modules/\n\n# Visual Studio 6 build log\n*.plg\n\n# Visual Studio 6 workspace options file\n*.opt\n\n# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)\n*.vbw\n\n# Visual Studio LightSwitch build output\n**/*.HTMLClient/GeneratedArtifacts\n**/*.DesktopClient/GeneratedArtifacts\n**/*.DesktopClient/ModelManifest.xml\n**/*.Server/GeneratedArtifacts\n**/*.Server/ModelManifest.xml\n_Pvt_Extensions\n\n# Paket dependency manager\n.paket/paket.exe\npaket-files/\n\n# FAKE - F# Make\n.fake/\n\n# JetBrains Rider\n.idea/\n*.sln.iml\n\n# CodeRush personal settings\n.cr/personal\n\n# Python Tools for Visual Studio (PTVS)\n__pycache__/\n*.pyc\n\n# Cake - Uncomment if you are using it\n# tools/**\n# !tools/packages.config\n\n# Tabs Studio\n*.tss\n\n# Telerik's JustMock configuration file\n*.jmconfig\n\n# BizTalk build output\n*.btp.cs\n*.btm.cs\n*.odx.cs\n*.xsd.cs\n\n# OpenCover UI analysis results\nOpenCover/\n\n# Azure Stream Analytics local run output\nASALocalRun/\n\n# MSBuild Binary and Structured Log\n*.binlog\n\n# NVidia Nsight GPU debugger configuration file\n*.nvuser\n\n# MFractors (Xamarin productivity tool) working folder\n.mfractor/\n\n# Local History for Visual Studio\n.localhistory/\n"
        },
        {
          "name": "Benchmark.NetCore",
          "type": "tree",
          "content": null
        },
        {
          "name": "Docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "Exemplars.png",
          "type": "blob",
          "size": 33.33984375,
          "content": null
        },
        {
          "name": "History",
          "type": "blob",
          "size": 16.720703125,
          "content": "* 8.2.1\n- Fix occasional \"Collection was modified\" exception when serializing metrics. #464\n* 8.2.0\n- .WithLabels() & similar now accept ReadOnlyMemory<string> as alternative to string[]. Same behavior, just easier to use if you already have a ReadOnlyMemory<string>.\n- .WithLabels() & similar now accept ReadOnlySpan<string> as alternative to string[]. This enables allocation-free metric instance creation if a metric instance with these labels is already known.\n- Incorporated various optimizations to reduce the required CPU time and allocated memory, including #410, #443 and other contributions.\n- Observation of large histograms is now 10-30% faster on machines that support AVX2 instructions.\n- health checks exposed via ForwardToPrometheus() no longer create a default metric if a custom metric is provided #444\n* 8.1.1\n- Fix bug in .NET Meters API adapter for UpDownCounter, which was incorrectly transformed to Prometheus metrics. #452 and #453\n* 8.1.0\n- Add support for capturing HttpClient metrics from all registered HttpClients (`services.UseHttpClientMetrics()`).\n* 8.0.1\n- Allow ObservableCounter<T> to be reset. Previously, the MeterAdapter output got stuck on its previous maximum if the underlying Meter reset its value to a lower value. Now we transform the value 1:1.\n* 8.0.0\n- Added OpenMetrics exposition format support (#388).\n- Added exemplar support for Counter and Histogram (#388).\n- The ':' character is no longer allowed in metric or label names. For metric names, Prometheus standard practice is to use colon only in recording rules.\n- Publish symbol packages and add Source Link support for easier debugging experience.\n- Fix defect where metrics with different labels could overwrite each other in specific circumstances with multiple metric factories in use (#389).\n- Ensure even harder that MetricPusher flushes the final state before stopping (#383 and #384)\n- Simplify DotNetStats built-in collector code for ease of readability and more best practices (#365, #364)\n- Slightly improve Counter performance under concurrent load.\n- Reduce memory allocations performed during ASP.NET Core HTTP request tracking.\n- By default, EventCounterAdapter will only listen to a small predefined set of general-purpose useful event sources, to minimize resource consumption in the default configuration. A custom event source filter must now be provided to enable listening for additional event sources.\n- EventCounterAdapter will only refresh data every 10 seconds by default, to reduce amount of garbage generated in memory (.NET event counters are very noisy and create many temporary objects).\n- Added `IManagedLifetimeMetricFactory.WithLabels()` to enable simpler label enrichment in scenarios where lifetime-managed metric instances are used.\n* 7.1.0\n- Added back .NET Standard 2.0 support as some customers had a hard dependency on .NET Standard 2.0 (despite not being a documented feature even earlier).\n- Added (Observable)UpDownCounter support to MeterAdapter (.NET 7 specific feature).\n* 7.0.0\n- .NET Core specific functionality now targeting .NET 6.0 or greater (all previous versions will be end of life by December 2022).\n- Relaxed the API restriction that forbade you to create multiple metrics with the same name but different label names. While this is a Prometheus anti-pattern, it is a standard pattern in other metrics technologies and we will allow it in the name of interoperability.\n- Added IMetricFactory.WithLabels() to define static labels per-factory and reduce the effort needed by users when defining static labels in specific scopes.\n- Added automatic metric expiration feature, to remove timeseries when they are no longer used after a while. This improves interoperability with other metrics technologies such as .NET Meters.\n- (Breaking change) Rewrite of the MeterAdapter functionality to bridge .NET 6 metrics to Prometheus. API remains equivalent, though options class changed. Output format (what metrics are published) is completely different. Now it translates metric names (instead of putting them in labels) and preserves tags (labels) provided via the .NET Meters API. Added sample project to demonstrate functionality. Ref #359\n- (Breaking change) Dropped support for .NET Standard 2.0 - now will target specifically .NET 6.0 and .NET Framework 4.6.2. This was already documented before but there was \"unofficial\" support also for .NET Standard remaining. This is now removed.\n- (Breaking change) EventCounterAdapter output format changed to translate counters to Prometheus metrics and to improve usability by publishing both counters and gauges from ambiguous event counters.\n- EventCounterAdapter and MeterAdapter are now enabled on startup by default.\n- Added some debug metrics to indicate the number of metric families, instances and timeseries being exported by prometheus-net.\n- Added typical benchmark results to readme for easy reference, and to show relative speed of the simple versus complex instruments.\n- Removed MetricConfiguration.StaticLabels because it had negative performance impact on many code paths that did not use it. The same functionality can be manually implemented in user code. Static labels remain available on registry and factory level.\n- When a before-collection metrics update callback throws an exception, it is now logged and ignored instead of breaking all metrics collection.\n- EventCounterAdapter now defaults to Informational events only, for reduced performance overhead. Can be configured via callback.\n* 6.0.0\n- Dropped library support for unsupported .NET runtime versions (.NET 2.1).\n- If Razor Pages is enabled, the \"page\" label is now automatically added to the default HTTP server metrics, unless there is a user-defined label already present with this name.\n- The \"endpoint\" label is now automatically added to the default HTTP server metrics, containing this endpoint routing route pattern of the request, unless there is a user-defined label already present with this name.\n- Added integration with .NET EventCounters, which can now be easily exposed as Promtheus metrics (see EventCounterAdapter class).\n- Added integration with .NET Meters, which can now be easily exposed as Promtheus metrics (see MeterAdapter class).\n- Added ReplaceOnPush option to MetricPusher #305 #322.\n- Minimum .NET Framework version is now 4.6.2.\n* 5.1.0\n- Add support for adding custom label value providers to HTTP server metrics. #347\n* 5.0.2\n- Bugfix: HttpClientMetrics under concurrent load with long-running requests were leading to broken response streams. #336\n* 5.0.1\n- Bugfix: PowersOfTenDividedBuckets did not work with >= 10 buckets due to overlap. Now skips overlapping region of generated series.\n* 5.0.0\n- Added HTTP client metric that measures the response duration (time until response content reading is finished).\n- Added \"client\" label containing the name of HTTP client to HTTP client metrics.\n- Added \"code\" label with HTTP response code to HTTP client metrics. #299\n- HTTP client metrics now count responses when they are completed, not when started, to match with HTTP server metrics. Also renamed metric to httpclient_requests_sent_total since it said \"received\" previously (due to copy-paste error from HTTP server metrics).\n- HTTP client metrics are now published via the netstandard package, without requiring ASP.NET Core. #314\n- Added Counter.IncTo[Current]TimeUtc().\n* 4.2.0\n- Added Histogram.PowersOfTenDividedBuckets()\n- Improved accuracy of histogram bucket calculations to reduce the likelyhood of seeing 0.00000000000000000001 offsets from expected value due to floating point math.\n- Added ConfigureAwait(false) to MetricHandler to help avoid deadlocks in some rare scenarios. #308\n- Fix defect where MetricPusher terminated when HttpClient signaled timeout. #302, #293\n- No longer need to manually reference ASP.NET Core SDK in csproj file when installing prometheus-net.AspNetCore library. It gets automatically referenced now. #267\n* 4.1.1\n- Bugfix: HTTP request metrics in 4.1.0 got broken due to typo in middleware helper.\n* 4.1.0\n- Fixed HttpClient metrics duration that was incorrectly measured. #265\n- prometheus-net.NetFramework.AspNet is now strong named, just like all the other assemblies. #273\n- NetFx target is now conditional for Windows builds only, to allow easier development work on nonwindows platforms. #264\n- MetricPusher now supports a callback for logging push errors. #186\n- Added support for defining static labels on registry or metric level. #256\n- Added ICollectorRegistry and IMetricFactory for mocking in test code. #268\n- Ignore /metrics URL by default in HTTP request metrics.\n- Fix overflow in Summary after observing more than uint.MaxValue events. #277\n- Reduce allocations in hot paths. #276, #275\n- Added request filtering (authorization) support to standalone MetricServer. #261\n* 4.0.0\n- Allow arbitrary ASP.NET Core route parameters to be exposed as HTTP metric labels. #225\n- Breaking change: some HTTP metrics implementation classes were changed from public to internal. They were never supposed to be public and hopefully nobody ever used them directly. Public documented API did not change.\n- Add HttpClient metrics with IHttpClientFactory integration.\n* 3.6.0\n- Added ASP.NET Core health check publisher for publishing metrics on health check status. #203 #209\n- Fixed hang in ASP.NET Web API exporter. #215\n- Fixed ASP.NET Web API exporter exporting metrics from the wrong registry. #217\n- Reduced memory use in MetricPusher implementation. Inspired by #208\n- Added basic gRPC service metrics support. #212\n- Reduce pointless log spam on cancelled scrapes - will silently ignore cancelled scrapes in the ASP.NET Core exporter. #220\n* 3.5.0\n- Exposed metric.Unpublish() method since there was already a matching Publish() there.\n- When the scrape is aborted, stop collecting/serializing metrics. #189\n- Added simple metric export handler for legacy ASP.NET Web API, to avoid having to deal with HttpListener complexity.\n* 3.4.0\n- Separate packaging for ASP.NET Core 3 to reduce package reference management complexity for users. #164\n- Lazy-initialize the default sample metrics to reduce initialization cost for those who do not need them. #170\n- ASP.NET Core middlware no longer disposes of output stream. #171\n- Fix DotNetStats occasional data tearing under parallel collections. #173\n- Improved wording of some error messages. #169\n- Added Counter.IncTo(), Gauge.IncTo(), Gauge.DecTo(). #181\n- Added Gauge.Set(DateTimeOffset) and Gauge.IncTo(DateTimeOffset). #181\n- Improve .NET Framework 4.6.1 packaging to include the ValueTuple reference automatically. #179\n- ASP.NET Core HTTP metrics now capture route data before it is overwritten by an exception handler. #177\n- ASP.NET Core HTTP \"in progress\" metrics now include controller/action labels (ASP.NET Core 3 only).\n- Fixed concurrently defect in HTTP metrics that may have caused label values from wrong request to apply. #182\n- The HttpListener based MetricServer can now handle more than one concurrent request.\n- Added asynchronous \"before collect\" callbacks, giving user code more flexibility in metric updates.\n- Added .Remove() to labeled metric instances for more convenient removal API (previously had to call method on parent instance).\n- Added .Unpublish() to labeled metric instances to support temporary unpublishing of a metric, without discarding collected data (e.g. histogram buckets), during periods of data unavailability.\n* 3.3.0\n- Add ability to filter requests by port number when exporting metrics. #160\n* 3.2.1\n- Fix NuGet packaging defect that caused reference failures after installing .2.0 on .NET Core 2.1 or newer. #158\n* 3.2.0\n- Enable custom HTTP client to be used in MetricPusher, allowing for Basic auth and more flexibility. #125\n- Add DiagnosticSourceAdapter (.NET Core only). #153\n- Improved compatibility with older .NET Framework versions. #155\n* 3.1.4\n- Fix timezone mismatch in Summary that led to unintended delays in buffer flushing. #149\n* 3.1.3\n- Fix regression introduced in 3.1.0 where MetricPusher does not always flush metrics before stopping.\n* 3.1.2\n- Fix defect where Histogram batch observations only incremented sum by one value, instead of entire batch. #147\n* 3.1.1\n- Added missing UTF-8 charset to Content-Type header, so non-ASCII characters are interpreted correctly by browsers.\n* 3.1.0\n- Added ICounter.NewTimer() (adds the value to the counter)\n- Eliminated some needless allocations when trying to register a metric that is already registered. #134\n- Added IHistogram.Count and IHistogram.Sum to expose aspects of collected data for inspection.\n- Added Collector.GetAllLabelValues() to expose the list of child metrics by all their known label values.\n- Metric export is now asynchronous internally to be compatible with ASP.NET Core 3.0 default configuration.\n- Added CollectorRegistry.CollectAndExportAsTextAsync() to support metric data export via arbitrary custom endpoints.\n* 3.0.3\n- Now backward compatible with ASP.NET Core 2.1 (was 2.2+)\n* 3.0.2\n- Fix defect where histogram sum failed to increment.\n* 3.0.1\n- Fix ObjectDisposedException in MetricPusher.\n* 3.0.0\n- Added HTTP request metrics for ASP.NET Core.\n- Somewhat more realistic examples in readme.\n- Metrics exporter is now significantly more CPU and memory-efficient.\n- Added Observe(value, count) to histogram metric, enabling multiple observations with the same value to be counted.\n- Added CountExceptions() and MeasureInProgress() helper extensions.\n- Adjusted API to better conform to Prometheus client library guidelines in terms of default values.\n- Breaking change: assemblies are now strong-named.\n- Breaking change: removed \"windows\" from built-in metric names as they are not Windows-specific.\n- Breaking change: removed support for protobuf export format (it is no longer used by Prometheus).\n- Breaking change: API surface cleaned up, removed some legacy methods, made many internal types actually internal.\n- Breaking change: \"on demand collectors\" concept replaced with simpler \"before collect callbacks\". Works the same, just less code needed to use it and fewer possible error conditions.\n- Breaking change: removed support for \"custom collectors\", as this was a very special use case that did not benefit at all from the main functionality of the library. Just generate a Prometheus exporter output document yourself if you need to export arbitrary data.\n* 2.1.3\n- Fixed wrong case used for metric type in the export data format. Should always be lowercase. #96\n* 2.1.2\n- Fixed potential conflict when using pushgateway and also other exporter libraries (see #89)\n* 2.1.1\n- Various minor fixes (see issues on GitHub for details).\n* 2.1.0\n- Add MetricOptions and subclasses for more extensible API (old API surface remains available)\n- Add SuppressInitialValue to metric configuration (ref https://www.robustperception.io/existential-issues-with-metrics/)\n- Add .WithLabels() as alternative to .Labels() for fewer annoying Intellisense conflicts.\n* 2.0.0\n- Targeting .NET Standard 2.0 as minimum version (.NET Framework 4.6.1, .NET Core 2.0 and Mono 5.4)\n- Added ASP.NET Core middlware\n- Added possibility to signal a failed scrape from on-demand collectors\n- Removed dependency on Reactive Extensions\n- Minor breaking changes to API\n- Performance improvements for hot-path code\n- Removed mostly obsolete PerfCounterCollector class\n- Fixed NuGet package contents to remove assemblies from dependencies\n- Various minor fixes (see issues on GitHub for details)\n* 1.3.4\n- Added support for .NET 4.5 using System.Reactive 3.1.1.\n- .NET 4.0 support continues to target Rx 2.5\n* 1.2.4:\n- Fixed MetricPusher not flushing metrics when stopped\n* 1.2.3:\n- Fixed label values escaping for ASCII formatter\n* 1.2.2:\n- PushGateway support\n- Various internal improvements (replaced locks with Interlocked operations)\n* 1.1.4:\n- Fixed some metrics not updating, added process ID metric\n- Replaced lock statements in Counter and Gauge with CAS\n* 1.1.3:\n- optionally use https in MetricServer\n* 1.1.2:\n- using UTF-8 in text formatter\n- catching exceptions in MetricServer http loop\n* 1.1.1:\n- disposing of MetricServer loop on Stop()\n* 1.1.0:\n- Renamed some metric names to be in-line with prometheus guidelines (breaking change as far as the exported metrics are concerned)\n* 1.0.0:\n- Add CPU, num handles, start time, num threads metrics to dot net stats collector\n- Made DotNetStatsCollector default (previously it was PerfCounterCollector)\n* 0.0.11:\n- Summary metric ported from go\n* 0.0.10:\n- Fix header writing order\n* 0.0.9:\n- Generalise scraping so it can be called externally without using the embedded http handler\n* 0.0.8:\n- Introduced interfaces for all the metrics to make unlabelled collectors and their children polymorph\n* 0.0.7:\n- Added the notion of OnDemandCollectors + a DotNetStatsCollector to avoid having to use .net perf counters\n* 0.0.6:\n- Do not create unlabelled metric if label names are specified\n* 0.0.5:\n- Allow specifying hostname in URL\n- Fix null ref exception if 'Accept' header is not specified\n* 0.0.3 - initial version"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0498046875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 andrasm\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "LocalMetricsCollector",
          "type": "tree",
          "content": null
        },
        {
          "name": "Prometheus.AspNetCore.Grpc",
          "type": "tree",
          "content": null
        },
        {
          "name": "Prometheus.AspNetCore.HealthChecks",
          "type": "tree",
          "content": null
        },
        {
          "name": "Prometheus.AspNetCore",
          "type": "tree",
          "content": null
        },
        {
          "name": "Prometheus.NetFramework.AspNet",
          "type": "tree",
          "content": null
        },
        {
          "name": "Prometheus",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 39.8642578125,
          "content": "# prometheus-net\n\nThis is a .NET library for instrumenting your applications and exporting metrics to [Prometheus](http://prometheus.io/).\n\n[![Build status](https://dev.azure.com/prometheus-net/prometheus-net/_apis/build/status/prometheus-net)](https://dev.azure.com/prometheus-net/prometheus-net/_build/latest?definitionId=1) [![Nuget](https://img.shields.io/nuget/v/prometheus-net.svg)](https://www.nuget.org/packages/prometheus-net/) ![Nuget](https://img.shields.io/nuget/dt/prometheus-net.svg)\n\n![](Screenshot.png)\n\nThe library targets the following runtimes (and newer):\n\n* .NET Framework 4.6.2\n* .NET 6.0\n\n# Table of contents\n\n* [Best practices and usage](#best-practices-and-usage)\n* [Quick start](#quick-start)\n* [Installation](#installation)\n* [Counters](#counters)\n* [Gauges](#gauges)\n* [Histogram](#histogram)\n* [Summary](#summary)\n* [Measuring operation duration](#measuring-operation-duration)\n* [Tracking in-progress operations](#tracking-in-progress-operations)\n* [Counting exceptions](#counting-exceptions)\n* [Labels](#labels)\n* [Static labels](#static-labels)\n* [Exemplars](#exemplars)\n* [Limiting exemplar volume](#limiting-exemplar-volume)\n* [When are metrics published?](#when-are-metrics-published)\n* [Deleting metrics](#deleting-metrics)\n* [ASP.NET Core exporter middleware](#aspnet-core-exporter-middleware)\n* [ASP.NET Core HTTP request metrics](#aspnet-core-http-request-metrics)\n* [ASP.NET Core gRPC request metrics](#aspnet-core-grpc-request-metrics)\n* [IHttpClientFactory metrics](#ihttpclientfactory-metrics)\n* [ASP.NET Core health check status metrics](#aspnet-core-health-check-status-metrics)\n* [Protecting the metrics endpoint from unauthorized access](#protecting-the-metrics-endpoint-from-unauthorized-access)\n* [ASP.NET Web API exporter](#aspnet-web-api-exporter)\n* [Kestrel stand-alone server](#kestrel-stand-alone-server)\n* [Publishing to Pushgateway](#publishing-to-pushgateway)\n* [Publishing to Pushgateway with basic authentication](#publishing-to-pushgateway-with-basic-authentication)\n* [Publishing via standalone HTTP handler](#publishing-via-standalone-http-handler)\n* [Publishing raw metrics document](#publishing-raw-metrics-document)\n* [Just-in-time updates](#just-in-time-updates)\n* [Suppressing default metrics](#suppressing-default-metrics)\n* [DiagnosticSource integration](#diagnosticsource-integration)\n* [EventCounter integration](#eventcounter-integration)\n* [.NET Meters integration](#net-meters-integration)\n* [Benchmarks](#benchmarks)\n* [Community projects](#community-projects)\n\n# Best practices and usage\n\nThis library allows you to instrument your code with custom metrics and provides some built-in metric collection integrations for ASP.NET Core.\n\nThe documentation here is only a minimal quick start. For detailed guidance on using Prometheus in your solutions, refer to the [prometheus-users discussion group](https://groups.google.com/forum/#!forum/prometheus-users). You are also expected to be familiar with the [Prometheus user guide](https://prometheus.io/docs/introduction/overview/). [/r/PrometheusMonitoring](https://www.reddit.com/r/PrometheusMonitoring/) on Reddit may also prove a helpful resource.\n\nFour types of metrics are available: Counter, Gauge, Summary and Histogram. See the documentation on [metric types](http://prometheus.io/docs/concepts/metric_types/) and [instrumentation best practices](http://prometheus.io/docs/practices/instrumentation/#counter-vs.-gauge-vs.-summary) to learn what each is good for.\n\n**The `Metrics` class is the main entry point to the API of this library.** The most common practice in C# code is to have a `static readonly` field for each metric that you wish to export from a given class.\n\nMore complex patterns may also be used (e.g. combining with dependency injection). The library is quite tolerant of different usage models - if the API allows it, it will generally work fine and provide satisfactory performance. The library is thread-safe.\n\n# Quick start\n\nAfter installing the library, you should:\n\n1. Collect some metrics, either by using built-in integrations or publishing your own custom metrics.\n1. Export the collected metrics over an HTTP endpoint (typically `/metrics`).\n1. Configure a Prometheus server to poll this endpoint for metrics on a regular interval.\n\nMinimal sample app (based on .NET 6 Console app template):\n\n```csharp\nusing var server = new Prometheus.KestrelMetricServer(port: 1234);\nserver.Start();\n\nConsole.WriteLine(\"Open http://localhost:1234/metrics in a web browser.\");\nConsole.WriteLine(\"Press enter to exit.\");\nConsole.ReadLine();\n```\n\nRefer to the sample projects for quick start instructions:\n\n| Name                                                                  | Description                                                                                                           |\n|-----------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|\n| [Sample.Web](Sample.Web/Program.cs)                                   | ASP.NET Core application that produces custom metrics and uses multiple integrations to publish built-in metrics      |\n| [Sample.Console](Sample.Console/Program.cs)                           | .NET console application that exports custom metrics                                                                  |\n| [Sample.Console.DotNetMeters](Sample.Console.DotNetMeters/Program.cs) | Demonstrates how to [publish custom metrics via the .NET Meters API](#net-meters-integration)                         |\n| [Sample.Console.Exemplars](Sample.Console.Exemplars/Program.cs)       | .NET console application that attaches exemplars to some metrics                                                      |\n| [Sample.Console.NetFramework](Sample.Console.NetFramework/Program.cs) | Same as above but targeting .NET Framework                                                                            |\n| [Sample.Console.NoAspNetCore](Sample.Console.NoAspNetCore/Program.cs) | .NET console application that exports custom metrics without requiring the ASP.NET Core runtime to be installed       |\n| [Sample.Grpc](Sample.Grpc/Program.cs)                                 | ASP.NET Core application that publishes a gRPC service                                                                |\n| [Sample.Grpc.Client](Sample.Grpc.Client/Program.cs)                   | Client app for the above                                                                                              |\n| [Sample.NetStandard](Sample.NetStandard/ImportantProcess.cs)          | Demonstrates how to reference prometheus-net in a .NET Standard class library                                         |\n| [Sample.Web.DifferentPort](Sample.Web.DifferentPort/Program.cs)       | Demonstrates how to set up the metric exporter on a different port from the main web API (e.g. for security purposes) |\n| [Sample.Web.MetricExpiration](Sample.Web.MetricExpiration/Program.cs) | Demonstrates how to use [automatic metric deletion](#deleting-metrics)                                                |\n| [Sample.Web.NetFramework](Sample.Web.NetFramework/Global.asax.cs)     | .NET Framework web app that publishes custom metrics                                                                  |\n\nThe rest of this document describes how to use individual features of the library.\n\n# Installation\n\nNuget package for general use and metrics export via HttpListener or to Pushgateway: [prometheus-net](https://www.nuget.org/packages/prometheus-net)\n\n>Install-Package prometheus-net\n\nNuget package for ASP.NET Core middleware and stand-alone Kestrel metrics server: [prometheus-net.AspNetCore](https://www.nuget.org/packages/prometheus-net.AspNetCore)\n\n>Install-Package prometheus-net.AspNetCore\n\nNuget package for ASP.NET Core Health Check integration: [prometheus-net.AspNetCore.HealthChecks](https://www.nuget.org/packages/prometheus-net.AspNetCore.HealthChecks)\n\n>Install-Package prometheus-net.AspNetCore.HealthChecks\n\nNuget package for ASP.NET Core gRPC integration: [prometheus-net.AspNetCore.Grpc](https://www.nuget.org/packages/prometheus-net.AspNetCore.Grpc)\n\n>Install-Package prometheus-net.AspNetCore.Grpc\n\nNuget package for ASP.NET Web API middleware on .NET Framework: [prometheus-net.NetFramework.AspNet](https://www.nuget.org/packages/prometheus-net.NetFramework.AspNet)\n\n>Install-Package prometheus-net.NetFramework.AspNet\n\n# Counters\n\nCounters only increase in value and reset to zero when the process restarts.\n\n```csharp\nprivate static readonly Counter ProcessedJobCount = Metrics\n    .CreateCounter(\"myapp_jobs_processed_total\", \"Number of processed jobs.\");\n\n...\n\nProcessJob();\nProcessedJobCount.Inc();\n```\n\n# Gauges\n\nGauges can have any numeric value and change arbitrarily.\n\n```csharp\nprivate static readonly Gauge JobsInQueue = Metrics\n    .CreateGauge(\"myapp_jobs_queued\", \"Number of jobs waiting for processing in the queue.\");\n\n...\n\njobQueue.Enqueue(job);\nJobsInQueue.Inc();\n\n...\n\nvar job = jobQueue.Dequeue();\nJobsInQueue.Dec();\n```\n\n# Histogram\n\nHistograms track the size and number of events in buckets. This allows for aggregatable calculation of quantiles.\n\n```csharp\nprivate static readonly Histogram OrderValueHistogram = Metrics\n    .CreateHistogram(\"myapp_order_value_usd\", \"Histogram of received order values (in USD).\",\n        new HistogramConfiguration\n        {\n            // We divide measurements in 10 buckets of $100 each, up to $1000.\n            Buckets = Histogram.LinearBuckets(start: 100, width: 100, count: 10)\n        });\n\n...\n\nOrderValueHistogram.Observe(order.TotalValueUsd);\n```\n\n# Summary\n\nSummaries track the trends in events over time (10 minutes by default).\n\n```csharp\nprivate static readonly Summary RequestSizeSummary = Metrics\n    .CreateSummary(\"myapp_request_size_bytes\", \"Summary of request sizes (in bytes) over last 10 minutes.\");\n\n...\n\nRequestSizeSummary.Observe(request.Length);\n```\n\nBy default, only the sum and total count are reported. You may also specify quantiles to measure:\n\n```csharp\nprivate static readonly Summary RequestSizeSummary = Metrics\n    .CreateSummary(\"myapp_request_size_bytes\", \"Summary of request sizes (in bytes) over last 10 minutes.\",\n        new SummaryConfiguration\n        {\n            Objectives = new[]\n            {\n                new QuantileEpsilonPair(0.5, 0.05),\n                new QuantileEpsilonPair(0.9, 0.05),\n                new QuantileEpsilonPair(0.95, 0.01),\n                new QuantileEpsilonPair(0.99, 0.005),\n            }\n        });\n```\n\nThe epsilon indicates the absolute error allowed in measurements. For more information, refer to the [Prometheus documentation on summaries and histograms](https://prometheus.io/docs/practices/histograms/).\n\n# Measuring operation duration\n\nTimers can be used to report the duration of an operation (in seconds) to a Summary, Histogram, Gauge or Counter. Wrap the operation you want to measure in a using block.\n\n```csharp\nprivate static readonly Histogram LoginDuration = Metrics\n    .CreateHistogram(\"myapp_login_duration_seconds\", \"Histogram of login call processing durations.\");\n\n...\n\nusing (LoginDuration.NewTimer())\n{\n    IdentityManager.AuthenticateUser(Request.Credentials);\n}\n```\n\n# Tracking in-progress operations\n\nYou can use `Gauge.TrackInProgress()` to track how many concurrent operations are taking place. Wrap the operation you want to track in a using block.\n\n```csharp\nprivate static readonly Gauge DocumentImportsInProgress = Metrics\n    .CreateGauge(\"myapp_document_imports_in_progress\", \"Number of import operations ongoing.\");\n\n...\n\nusing (DocumentImportsInProgress.TrackInProgress())\n{\n    DocumentRepository.ImportDocument(path);\n}\n```\n\n# Counting exceptions\n\nYou can use `Counter.CountExceptions()` to count the number of exceptions that occur while executing some code.\n\n\n```csharp\nprivate static readonly Counter FailedDocumentImports = Metrics\n    .CreateCounter(\"myapp_document_imports_failed_total\", \"Number of import operations that failed.\");\n\n...\n\nFailedDocumentImports.CountExceptions(() => DocumentRepository.ImportDocument(path));\n```\n\nYou can also filter the exception types to observe:\n\n```csharp\nFailedDocumentImports.CountExceptions(() => DocumentRepository.ImportDocument(path), IsImportRelatedException);\n\nbool IsImportRelatedException(Exception ex)\n{\n    // Do not count \"access denied\" exceptions - those are user error for pointing us to a forbidden file.\n    if (ex is UnauthorizedAccessException)\n        return false;\n\n    return true;\n}\n```\n\n# Labels\n\nAll metrics can have labels, allowing grouping of related time series.\n\nSee the best practices on [naming](http://prometheus.io/docs/practices/naming/)\nand [labels](http://prometheus.io/docs/practices/instrumentation/#use-labels).\n\nTaking a counter as an example:\n\n```csharp\nprivate static readonly Counter RequestCountByMethod = Metrics\n    .CreateCounter(\"myapp_requests_total\", \"Number of requests received, by HTTP method.\", labelNames: new[] { \"method\" });\n\n...\n\n// You can specify the values for the labels later, once you know the right values (e.g in your request handler code).\nRequestCountByMethod.WithLabels(\"GET\").Inc();\n```\n\nNB! Best practices of metric design is to **minimize the number of different label values**. For example:\n\n* HTTP request method is a good choice for labeling - there are not many values.\n* URL is a bad choice for labeling - it has many possible values and would lead to significant data processing inefficiency.\n\n# Static labels\n\nYou can add static labels that always have fixed values. This is possible on two levels:\n\n* on the metrics registry (e.g. `Metrics.DefaultRegistry`)\n* on a metric factory (e.g. `Metrics.WithLabels()`)\n\nAll levels of labeling can be combined and instance-specific metric labels can also be applied on top, as usual.\n\nExample with static labels on two levels and one instance-specific label:\n\n```csharp\nMetrics.DefaultRegistry.SetStaticLabels(new Dictionary<string, string>\n{\n  // Labels applied to all metrics in the registry.\n  { \"environment\", \"testing\" }\n});\n\nvar backgroundServicesMetricFactory = Metrics.WithLabels(new Dictionary<string, string>\n{\n  // Labels applied to all metrics created via this factory.\n  { \"category\", \"background-services\" }\n});\n\nvar requestsHandled = backgroundServicesMetricFactory\n  .CreateCounter(\"myapp_requests_handled_total\", \"Count of requests handled, labelled by response code.\", labelNames: new[] { \"response_code\" });\n\n// Labels applied to individual instances of the metric.\nrequestsHandled.WithLabels(\"404\").Inc();\nrequestsHandled.WithLabels(\"200\").Inc();\n```\n\n# Exemplars\n\nExemplars facilitate [distributed tracing](https://learn.microsoft.com/en-us/dotnet/core/diagnostics/distributed-tracing-concepts), by attaching related trace IDs to metrics. This enables a metrics visualization app to cross-reference [traces](https://opentelemetry.io/docs/concepts/signals/traces/) that explain how the metric got the value it has.\n\n![](Exemplars.png)\n\nSee also, [Grafana fundamentals - introduction to exemplars](https://grafana.com/docs/grafana/latest/fundamentals/exemplars/).\n\nBy default, prometheus-net will create an exemplar with the `trace_id` and `span_id` labels based on the current distributed tracing context (`Activity.Current`). If using OpenTelemetry tracing with ASP.NET Core, the `traceparent` HTTP request header will be used to automatically assign `Activity.Current`.\n\n```csharp\nprivate static readonly Counter TotalSleepTime = Metrics\n    .CreateCounter(\"sample_sleep_seconds_total\", \"Total amount of time spent sleeping.\");\n...\n\n// You only need to create the Activity if one is not automatically assigned (e.g. by ASP.NET Core).\nusing (var activity = new Activity(\"Pausing before record processing\").Start())\n{\n    var sleepStopwatch = Stopwatch.StartNew();\n    await Task.Delay(TimeSpan.FromSeconds(1));\n\n    // The trace_id and span_id from the current Activity are exposed as the exemplar.\n    TotalSleepTime.Inc(sleepStopwatch.Elapsed.TotalSeconds);\n}\n```\n\nThis will be published as the following metric point:\n\n```\nsample_sleep_seconds_total 251.03833569999986 # {trace_id=\"08ad1c8cec52bf5284538abae7e6d26a\",span_id=\"4761a4918922879b\"} 1.0010688 1672634812.125\n```\n\nYou can override any default exemplar logic by providing your own exemplar when updating the value of the metric:\n\n```csharp\nprivate static readonly Counter RecordsProcessed = Metrics\n    .CreateCounter(\"sample_records_processed_total\", \"Total number of records processed.\");\n\n// The key from an exemplar key-value pair should be created once and reused to minimize memory allocations.\nprivate static readonly Exemplar.LabelKey RecordIdKey = Exemplar.Key(\"record_id\");\n...\n\nforeach (var record in recordsToProcess)\n{\n    var exemplar = Exemplar.From(RecordIdKey.WithValue(record.Id.ToString()));\n    RecordsProcessed.Inc(exemplar);\n}\n```\n\n> **Warning**\n> Exemplars are limited to 128 ASCII characters (counting both keys and values) - they are meant to contain IDs for cross-referencing with trace databases, not as a replacement for trace databases.\n\nExemplars are only published if the metrics are being scraped by an OpenMetrics-capable client. For development purposes, you can force the library to use the OpenMetrics exposition format by adding `?accept=application/openmetrics-text` to the `/metrics` URL.\n\n> **Note**\n> The Prometheus database automatically negotiates OpenMetrics support when scraping metrics - you do not need to apply any special scraping configuration in production scenarios. You may need to [enable exemplar storage](https://prometheus.io/docs/prometheus/latest/feature_flags/#exemplars-storage), though.\n\nSee also, [Sample.Console.Exemplars](Sample.Console.Exemplars/Program.cs).\n\n# Limiting exemplar volume\n\nExemplars can be expensive to store in the metrics database. For this reason, it can be useful to only record exemplars for \"interesting\" metric values.\n\nYou can use `ExemplarBehavior.NewExemplarMinInterval` to define a minimum interval between exemplars - a new exemplar will only be recorded if this much time has passed. This can be useful to limit the rate of publishing unique exemplars.\n\nYou can customize the default exemplar provider via `IMetricFactory.ExemplarBehavior` or `CounterConfiguration.ExemplarBehavior` and `HistogramConfiguration.ExemplarBehavior`, which allows you to provide your own method to generate exemplars and to filter which values/metrics exemplars are recorded for:\n\nExample of a custom exemplar provider used together with exemplar rate limiting:\n\n```csharp\n// For the next histogram we only want to record exemplars for values larger than 0.1 (i.e. when record processing goes slowly).\nstatic Exemplar RecordExemplarForSlowRecordProcessingDuration(Collector metric, double value)\n{\n    if (value < 0.1)\n        return Exemplar.None;\n\n    return Exemplar.FromTraceContext();\n}\n\nvar recordProcessingDuration = Metrics\n    .CreateHistogram(\"sample_record_processing_duration_seconds\", \"How long it took to process a record, in seconds.\",\n    new HistogramConfiguration\n    {\n        Buckets = Histogram.PowersOfTenDividedBuckets(-4, 1, 5),\n        ExemplarBehavior = new()\n        {\n            DefaultExemplarProvider = RecordExemplarForSlowRecordProcessingDuration,\n            // Even if we have interesting data more often, do not record it to conserve exemplar storage.\n            NewExemplarMinInterval = TimeSpan.FromMinutes(5)\n        }\n    });\n```\n\nFor the ASP.NET Core HTTP server metrics, you can further fine-tune exemplar recording by inspecting the HTTP request and response:\n\n```csharp\napp.UseHttpMetrics(options =>\n{\n    options.ConfigureMeasurements(measurementOptions =>\n    {\n        // Only measure exemplar if the HTTP response status code is not \"OK\".\n        measurementOptions.ExemplarPredicate = context => context.Response.StatusCode != HttpStatusCode.Ok;\n    });\n});\n```\n\n# When are metrics published?\n\nMetrics without labels are published immediately after the `Metrics.CreateX()` call. Metrics that use labels are published when you provide the label values for the first time.\n\nSometimes you want to delay publishing a metric until you have loaded some data and have a meaningful value to supply for it. The API allows you to suppress publishing of the initial value until you decide the time is right.\n\n```csharp\nprivate static readonly Gauge UsersLoggedIn = Metrics\n    .CreateGauge(\"myapp_users_logged_in\", \"Number of active user sessions\",\n        new GaugeConfiguration\n        {\n            SuppressInitialValue = true\n        });\n\n...\n\n// After setting the value for the first time, the metric becomes published.\nUsersLoggedIn.Set(LoadSessions().Count);\n```\n\nYou can also use `.Publish()` on a metric to mark it as ready to be published without modifying the initial value (e.g. to publish a zero). Conversely, you can use `.Unpublish()` to hide a metric temporarily. Note that the metric remains in memory and retains its value.\n\n# Deleting metrics\n\nYou can use `.Dispose()` or `.RemoveLabelled()` methods on the metric classes to manually delete metrics at any time.\n\nIn some situations, it can be hard to determine when a metric with a specific set of labels becomes irrelevant and needs to be removed. The library provides some assistance here by enabling automatic expiration of metrics when they are no longer used.\n\nTo enable automatic expiration, create the metrics via the metric factory returned by `Metrics.WithManagedLifetime()`. All such metrics will have a fixed expiration time, with the expiration restarting based on certain conditions that indicate the metric is in use.\n\nOption 1: metric lifetime can be controlled by leases - the metric expiration timer starts when the last lease is released (and will be reset when a new lease is taken again).\n\n```csharp\nvar factory = Metrics.WithManagedLifetime(expiresAfter: TimeSpan.FromMinutes(5));\n\n// With expiring metrics, we get back handles to the metric, not the metric directly.\nvar inProgressHandle = expiringMetricFactory\n  .CreateGauge(\"documents_in_progress\", \"Number of documents currently being processed.\",\n    // Automatic metric deletion only makes sense if we have a high/unknown cardinality label set,\n    // so here is a sample label for each \"document provider\", whoever that may be.\n    labelNames: new[] { \"document_provider\" });\n\n...\n\npublic void ProcessDocument(string documentProvider)\n{\n  // Automatic metric deletion will not occur while this lease is held.\n  // This will also reset any existing expiration timer for this document provider.\n  inProgressHandle.WithLease(metric =>\n  {\n    using (metric.TrackInProgress())\n      DoDocumentProcessingWork();\n  }, documentProvider);\n  // Lease is released here.\n  // If this was the last lease for this document provider, the expiration timer will now start.\n}\n```\n\nScenario 2: sometimes managing the leases is not required because you simply want the metric lifetime to be extended whenever the value is updated.\n\n```csharp\nvar factory = Metrics.WithManagedLifetime(expiresAfter: TimeSpan.FromMinutes(5));\n\n// With expiring metrics, we get back handles to the metric, not the metric directly.\nvar processingStartedHandle = expiringMetricFactory\n  .CreateGauge(\"documents_started_processing_total\", \"Number of documents for which processing has started.\",\n    // Automatic metric deletion only makes sense if we have a high/unknown cardinality label set,\n    // so here is a sample label for each \"document provider\", whoever that may be.\n    labelNames: new[] { \"document_provider\" });\n\n// This returns a metric instance that will reset the expiration timer whenever the metric value is updated.\nvar processingStarted = processingStartedHandle.WithExtendLifetimeOnUse();\n\n...\n\npublic void ProcessDocument(string documentProvider)\n{\n  // This will reset the expiration timer for this document provider.\n  processingStarted.WithLabels(documentProvider).Inc();\n\n  DoDocumentProcessingWork();\n}\n```\n\nThe expiration logic is scoped to the factory. Multiple handles for the same metric from the same factory will share their expiration logic. However, handles for the same metric from different factories will have independent expiration logic.\n\nSee also, [Sample.Web.MetricExpiration](Sample.Web.MetricExpiration/Program.cs).\n\n# ASP.NET Core exporter middleware\n\nFor projects built with ASP.NET Core, a middleware plugin is provided.\n\nIf you use the default Visual Studio project templates, modify the `UseEndpoints` call as follows:\n\n* Add `endpoints.MapMetrics()` anywhere in the delegate body.\n\n```csharp\npublic void Configure(IApplicationBuilder app, ...)\n{\n    // ...\n\n    app.UseEndpoints(endpoints =>\n    {\n        // ...\n\n        endpoints.MapMetrics();\n    });\n}\n```\n\nThe default configuration will publish metrics on the `/metrics` URL.\n\nThe ASP.NET Core functionality is delivered in the `prometheus-net.AspNetCore` NuGet package.\n\nSee also, [Sample.Web](Sample.Web/Program.cs).\n\n# ASP.NET Core HTTP request metrics\n\nThe library exposes some metrics from ASP.NET Core applications:\n\n* Number of HTTP requests in progress.\n* Total number of received HTTP requests.\n* Duration of HTTP requests.\n\nThe ASP.NET Core functionality is delivered in the `prometheus-net.AspNetCore` NuGet package.\n\nYou can expose HTTP metrics by modifying your `Startup.Configure()` method:\n\n* After `app.UseRouting()` add `app.UseHttpMetrics()`.\n\nExample `Startup.cs`:\n\n```csharp\npublic void Configure(IApplicationBuilder app, ...)\n{\n    // ...\n\n    app.UseRouting();\n    app.UseHttpMetrics();\n\n    // ...\n}\n```\n\nBy default, metrics are collected separately for each response status code (200, 201, 202, 203, ...). You can considerably reduce the size of the data set by only preserving information about the first digit of the status code:\n\n```csharp\napp.UseHttpMetrics(options =>\n{\n    // This will preserve only the first digit of the status code.\n    // For example: 200, 201, 203 -> 2xx\n    options.ReduceStatusCodeCardinality();\n});\n```\n\nNB! Exception handler middleware that changes HTTP response codes must be registered **after** `UseHttpMetrics()` in order to ensure that prometheus-net reports the correct HTTP response status code.\n\nThe `action`, `controller` and `endpoint` route parameters are always captured by default. If Razor Pages is in use, the `page` label will be captured to show the path to the page.\n\nYou can include additional route parameters as follows:\n\n```csharp\napp.UseHttpMetrics(options =>\n{\n    // Assume there exists a custom route parameter with this name.\n    options.AddRouteParameter(\"api-version\");\n});\n```\n\nYou can also extract arbitrary data from the HttpContext into label values as follows:\n\n```csharp\napp.UseHttpMetrics(options =>\n{\n    options.AddCustomLabel(\"host\", context => context.Request.Host.Host);\n});\n```\n\nSee also, [Sample.Web](Sample.Web/Program.cs).\n\n# ASP.NET Core gRPC request metrics\n\nThe library allows you to expose some metrics from ASP.NET Core gRPC services. These metrics include labels for service and method name.\n\nYou can expose gRPC metrics by modifying your `Startup.Configure()` method:\n* After `app.UseRouting()` add `app.UseGrpcMetrics()`.\n\nExample `Startup.cs`:\n\n```csharp\npublic void Configure(IApplicationBuilder app, ...)\n{\n    // ...\n\n    app.UseRouting();\n    app.UseGrpcMetrics();\n\n    // ...\n}\n```\n\nThe gRPC functionality is delivered in the `prometheus-net.AspNetCore.Grpc` NuGet package.\n\nSee also, [Sample.Grpc](Sample.Grpc/Program.cs).\n\n# IHttpClientFactory metrics\n\nThis library allows you to expose metrics about HttpClient instances created using [IHttpClientFactory](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-requests).\n\nThe exposed metrics include:\n\n* Number of HTTP requests in progress.\n* Total number of started HTTP requests.\n* Duration of HTTP client requests (from start of request to end of reading response headers).\n* Duration of HTTP client responses (from start of request to end of reading response body).\n\nExample `Startup.cs` modification to enable these metrics for all HttpClients registered in the service collection:\n\n```csharp\npublic void ConfigureServices(IServiceCollection services)\n{\n    // ...\n\n    services.UseHttpClientMetrics();\n\n    // ...\n}\n```\n\n> **Note**\n> You can also register HTTP client metrics only for a specific HttpClient by calling `services.AddHttpClient(...).UseHttpClientMetrics()`.\n\nSee also, [Sample.Web](Sample.Web/Program.cs).\n\n# ASP.NET Core health check status metrics\n\nYou can expose the current status of [ASP.NET Core health checks](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks) as Prometheus metrics by extending your `IHealthChecksBuilder` in the `Startup.ConfigureServices()` method:\n\n```csharp\npublic void ConfigureServices(IServiceCollection services, ...)\n{\n    // ...\n\n    services.AddHealthChecks()\n        // ...\n        <Your Health Checks>\n        // ...\n        .ForwardToPrometheus();\n\n    // ...\n}\n```\n\nThe status of each health check will be published in the `aspnetcore_healthcheck_status` metric.\n\nThe ASP.NET Core health check integration is delivered in the `prometheus-net.AspNetCore.HealthChecks` NuGet package.\n\nSee also, [Sample.Web](Sample.Web/Program.cs).\n\n# Protecting the metrics endpoint from unauthorized access\n\nYou may wish to restrict access to the metrics export URL. Documentation on how to apply ASP.NET Core security mechanisms is beyond the scope of this readme file but a good starting point may be to [require an authorization policy to be satisfied for accessing the endpoint](https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies?view=aspnetcore-6.0#apply-policies-to-endpoints)\n\n```csharp\napp.UseEndpoints(endpoints =>\n{\n    // ...\n\n    // Assumes that you have previously configured the \"ReadMetrics\" policy (not shown).\n    endpoints.MapMetrics().RequireAuthorization(\"ReadMetrics\");\n});\n```\n\nAnother commonly used option is to expose a separate web server endpoint (e.g. a new `KestrelMetricServer` instance) on a different port, with firewall rules limiting access to only certain IP addresses. Refer to the sample project [Sample.Web.DifferentPort](Sample.Web.DifferentPort/Program.cs).\n\n# ASP.NET Web API exporter\n\nThe easiest way to export metrics from an ASP.NET Web API app on the full .NET Framework is to use `AspNetMetricServer` in your `Global.asax.cs` file. Insert the following line to the top of the `Application_Start` method:\n\n```csharp\nprotected void Application_Start(object sender, EventArgs e)\n{\n    AspNetMetricServer.RegisterRoutes(GlobalConfiguration.Configuration);\n\n    // Other code follows.\n}\n```\n\nThe above snippet exposes metrics on the `/metrics` URL.\n\nThe `AspNetMetricServer` class is provided by the `prometheus-net.NetFramework.AspNet` NuGet package.\n\n# Kestrel stand-alone server\n\nIn some situation, you may wish to start a stand-alone metric server using Kestrel (e.g. if your app has no other HTTP-accessible functionality).\n\n```csharp\nvar metricServer = new KestrelMetricServer(port: 1234);\nmetricServer.Start();\n```\n\nThe default configuration will publish metrics on the `/metrics` URL.\n\nIf your app is an ASP.NET Core web app, you can use a pipeline-integrated mechanism:\n\n```csharp\nservices.AddMetricServer(options =>\n{\n    options.Port = 1234;\n});\n```\n\n# Publishing to Pushgateway\n\nMetrics can be posted to a [Pushgateway](https://prometheus.io/docs/practices/pushing/) server.\n\n```csharp\nvar pusher = new MetricPusher(new MetricPusherOptions\n{\n    Endpoint = \"https://pushgateway.example.org:9091/metrics\",\n    Job = \"some_job\"\n});\n\npusher.Start();\n```\n\nNote that the default behavior of the metric pusher is to append metrics. You can use `MetricPusherOptions.ReplaceOnPush` to make it replace existing metrics in the same group, removing any that are no longer pushed.\n\n# Publishing to Pushgateway with basic authentication\n\nYou can use a custom HttpClient to supply credentials for the Pushgateway.\n\n```csharp\n// Placeholder username and password here - replace with your own data.\nvar headerValue = Convert.ToBase64String(Encoding.UTF8.GetBytes(\"username:password\"));\nvar httpClient = new HttpClient();\nhttpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Basic\", headerValue);\n\nvar pusher = new MetricPusher(new MetricPusherOptions\n{\n    Endpoint =  \"https://pushgateway.example.org:9091/metrics\",\n    Job = \"some_job\",\n    HttpClientProvider = () => httpClient\n});\n\npusher.Start();\n```\n\n# Publishing via standalone HTTP handler\n\nAs a fallback option for scenarios where Kestrel or ASP.NET Core hosting is unsuitable, an `HttpListener` based metrics server implementation is also available.\n\n```csharp\nvar metricServer = new MetricServer(port: 1234);\nmetricServer.Start();\n```\n\nThe default configuration will publish metrics on the `/metrics` URL.\n\n`MetricServer.Start()` may throw an access denied exception on Windows if your user does not have the right to open a web server on the specified port. You can use the *netsh* command to grant yourself the required permissions:\n\n> netsh http add urlacl url=http://+:1234/metrics user=DOMAIN\\user\n\n# Publishing raw metrics document\n\nIn scenarios where you handle publishing via a custom endpoint, you can export the entire metrics data set as a Prometheus text document.\n\n```csharp\nawait Metrics.DefaultRegistry.CollectAndExportAsTextAsync(outputStream);\n```\n\n# Just-in-time updates\n\nIn some scenarios you may want to only collect data when it is requested by Prometheus. To easily implement this scenario prometheus-net enables you to register a callback before every collection occurs. Register your callback using `Metrics.DefaultRegistry.AddBeforeCollectCallback()`.\n\nEvery callback will be executed before each collection, which will not finish until every callback has finished executing. Prometheus will expect each scrape to complete within a certain amount of seconds. To avoid timeouts, ensure that any registered callbacks execute quickly.\n\n* A synchronous callback (of type `Action`) should not take more than a few milliseconds. Do not read data from remote systems in these callbacks.\n* An asynchronous callback (of type `Func<CancellationToken, Task>`) is more suitable for long-running data collection work (lasting a few seconds). You can use asynchronous callbacks for reading data from remote systems.\n\n```csharp\nMetrics.DefaultRegistry.AddBeforeCollectCallback(async (cancel) =>\n{\n    // Probe a remote system.\n    var response = await httpClient.GetAsync(\"https://google.com\", cancel);\n\n    // Increase a counter by however many bytes we loaded.\n    googlePageBytes.Inc(response.Content.Headers.ContentLength ?? 0);\n});\n```\n\n# Suppressing default metrics\n\nThe library enables various default metrics and integrations by default. If these default metrics are not desirable you may remove them by calling `Metrics.SuppressDefaultMetrics()` before registering any of your own metrics.\n\n# DiagnosticSource integration\n\n[.NET Core provides the DiagnosticSource mechanism for reporting diagnostic events](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md), used widely by .NET and ASP.NET Core classes. To expose basic data on these events via Prometheus, you can use the `DiagnosticSourceAdapter` class:\n\n```csharp\n// An optional \"options\" parameter is available to customize adapter behavior.\nvar registration = DiagnosticSourceAdapter.StartListening();\n\n...\n\n// Stops listening for DiagnosticSource events.\nregistration.Dispose();\n```\n\nAny events that occur are exported as Prometheus metrics, indicating the name of the event source and the name of the event:\n\n```\ndiagnostic_events_total{source=\"Microsoft.AspNetCore\",event=\"Microsoft.AspNetCore.Mvc.AfterAction\"} 4\ndiagnostic_events_total{source=\"HttpHandlerDiagnosticListener\",event=\"System.Net.Http.Request\"} 8\n```\n\nThe level of detail obtained from this is rather low - only the total count for each event is exported. For more fine-grained analytics, you need to listen to DiagnosticSource events on your own and create custom metrics that can understand the meaning of each particular type of event that is of interest to you.\n\n# EventCounter integration\n\n> **Note**\n> The output produced by this integration has changed significantly between prometheus-net 6.0 and prometheus-net 7.0. The old output format is no longer supported.\n\n[.NET Core provides the EventCounter mechanism for reporting diagnostic events](https://docs.microsoft.com/en-us/dotnet/core/diagnostics/event-counters), used used widely by .NET and ASP.NET Core classes. This library publishes all .NET EventCounter data by default. To suppress this, see [Suppressing default metrics](#suppressing-default-metrics).\n\nYou can configure the integration using `Metrics.ConfigureEventCounterAdapter()`.\n\nBy default, prometheus-net will only publish [the well-known .NET EventCounters](https://learn.microsoft.com/en-us/dotnet/core/diagnostics/available-counters) to minimize resource consumption in the default configuration. A custom event source filter must be provided in the configuration to enable publishing of additional event counters.\n\nSee also, [Sample.Console](Sample.Console/Program.cs).\n\n# .NET Meters integration\n\n> **Note**\n> The output produced by this integration has changed significantly between prometheus-net 6.0 and prometheus-net 7.0. The old output format is no longer supported.\n\n[.NET provides the Meters mechanism for reporting diagnostic metrics](https://docs.microsoft.com/en-us/dotnet/core/diagnostics/metrics). This library publishes all .NET Meters API data by default. To suppress this, see [Suppressing default metrics](#suppressing-default-metrics).\n\nYou can configure the integration using `Metrics.ConfigureMeterAdapter()`.\n\nSee also, [Sample.Console.DotNetMeters](Sample.Console.DotNetMeters/Program.cs).\n\n# Benchmarks\n\nA suite of benchmarks is included if you wish to explore the performance characteristics of the library. Simply build and run the `Benchmarks.NetCore` project in Release mode.\n\nAs an example of the performance of measuring data using prometheus-net, we have the results of the MeasurementBenchmarks here, converted into measurements per second:\n\n| Metric type             | Measurements per second |\n|-------------------------|------------------------:|\n| Counter                 |             261 million |\n| Gauge                   |             591 million |\n| Histogram (16 buckets)  |             105 million |\n| Histogram (128 buckets) |              65 million |\n\nAnother popular .NET SDK with Prometheus support is the OpenTelemetry SDK. To help you choose, we have [SdkComparisonBenchmarks.cs](Benchmark.NetCore/SdkComparisonBenchmarks.cs) to compare the two SDKs and give some idea of how they differer in the performance tradeoffs made. Both SDKs are evaluated in single-threaded mode under a comparable workload and enabled feature set. A representative result is here:\n\n| SDK            | Benchmark scenario                    | CPU time | Memory |\n|----------------|---------------------------------------|---------:|-------:|\n| prometheus-net | Counter (existing timeseries) x100K   |   230 µs |   None |\n| OpenTelemetry  | Counter (existing timeseries) x100K   | 10998 µs |   None |\n| prometheus-net | Histogram (existing timeseries) x100K |   957 µs |   None |\n| OpenTelemetry  | Histogram (existing timeseries) x100K | 12110 µs |   None |\n| prometheus-net | Histogram (new timeseries) x1K        |   716 µs | 664 KB |\n| OpenTelemetry  | Histogram (new timeseries) x1K        |   350 µs |  96 KB |\n\n# Community projects\n\nSome useful related projects are:\n\n* [prometheus-net.DotNetRuntime](https://github.com/djluck/prometheus-net.DotNetRuntime) instruments .NET Core apps to export metrics on .NET Core performance.\n* [prometheus-net.AspNet](https://github.com/rocklan/prometheus-net.AspNet) instruments ASP.NET full framework apps to export metrics on performance.\n* [prometheus-net.SystemMetrics](https://github.com/Daniel15/prometheus-net.SystemMetrics) exports various system metrics such as CPU usage, disk usage, etc.\n* [prometheus-net Grafana dashboards](https://github.com/prometheus-net/grafana-dashboards) provides example dashboards for visualizing prometheus-net metrics in [Grafana](https://grafana.com/).\n* [PromQL.Parser](https://github.com/djluck/PromQL.Parser) enables you to parse and create Prometheus queries in C#.\n\nNote: to avoid confusion between \"official\" prometheus-net and community maintained packages, the `prometheus-net` namespace is protected on nuget.org. However, the `prometheus-net.Contrib.*` namespace allows package publishing by all authors.\n"
        },
        {
          "name": "Resources",
          "type": "tree",
          "content": null
        },
        {
          "name": "Sample.Console.DotNetMeters",
          "type": "tree",
          "content": null
        },
        {
          "name": "Sample.Console.Exemplars",
          "type": "tree",
          "content": null
        },
        {
          "name": "Sample.Console.NetFramework",
          "type": "tree",
          "content": null
        },
        {
          "name": "Sample.Console.NoAspNetCore",
          "type": "tree",
          "content": null
        },
        {
          "name": "Sample.Console",
          "type": "tree",
          "content": null
        },
        {
          "name": "Sample.Grpc.Client",
          "type": "tree",
          "content": null
        },
        {
          "name": "Sample.Grpc",
          "type": "tree",
          "content": null
        },
        {
          "name": "Sample.NetStandard",
          "type": "tree",
          "content": null
        },
        {
          "name": "Sample.Web.DifferentPort",
          "type": "tree",
          "content": null
        },
        {
          "name": "Sample.Web.MetricExpiration",
          "type": "tree",
          "content": null
        },
        {
          "name": "Sample.Web.NetFramework",
          "type": "tree",
          "content": null
        },
        {
          "name": "Sample.Web",
          "type": "tree",
          "content": null
        },
        {
          "name": "Screenshot.png",
          "type": "blob",
          "size": 179.1328125,
          "content": null
        },
        {
          "name": "Start-LocalMetricsCollector.ps1",
          "type": "blob",
          "size": 1.0439453125,
          "content": "$ErrorActionPreference = \"Stop\"\n\n# This starts the local metrics collector used at development-time to upload metrics via remote write.\n\nfunction VerifySuccess {\n    if ($LASTEXITCODE -ne 0) {\n        Write-Error \"Last command failed. See log for details.\"\n    }\n}\n\n$adapter = Get-NetIPAddress | ? InterfaceAlias -like \"*(WSL)*\" | ? AddressFamily -eq IPv4\n\nif (!$adapter) {\n    Write-Error \"Unable to find WSL network adapter.\"\n}\n\n[string]$host_ip = $adapter.IPAddress\n\n& docker build --tag prometheus-net-collector --file .\\LocalMetricsCollector\\Dockerfile (Join-Path $PSScriptRoot LocalMetricsCollector)\nVerifySuccess\n\n$apiKeyCredential = Get-Credential -Title \"Enter Grafana Cloud API credentials\"\n$apiKey = ConvertFrom-SecureString -SecureString $apiKeyCredential.Password -AsPlainText\n\n& docker run -it --rm --env PROMETHEUS_PORT=9090 --env GRAFANA_USER=$($apiKeyCredential.UserName) --env GRAFANA_API_KEY=$apiKey --env COMPUTERNAME=$env:COMPUTERNAME --env HOST_IP=$host_ip --publish 9090:9090 --name prometheus-net-collector prometheus-net-collector\nVerifySuccess"
        },
        {
          "name": "Tester.AspNetCore.HealthChecks",
          "type": "tree",
          "content": null
        },
        {
          "name": "Tester.NetCore",
          "type": "tree",
          "content": null
        },
        {
          "name": "Tester.NetFramework.AspNet",
          "type": "tree",
          "content": null
        },
        {
          "name": "Tester.NetFramework",
          "type": "tree",
          "content": null
        },
        {
          "name": "Tests.NetCore",
          "type": "tree",
          "content": null
        },
        {
          "name": "Tests.NetFramework",
          "type": "tree",
          "content": null
        },
        {
          "name": "prometheus-net.sln",
          "type": "blob",
          "size": 13.0048828125,
          "content": "Microsoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio Version 17\nVisualStudioVersion = 17.4.32912.340\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Resources\", \"Resources\\Resources.csproj\", \"{608F1849-C417-4077-B60F-1BBF26762670}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Tests.NetCore\", \"Tests.NetCore\\Tests.NetCore.csproj\", \"{09EED3ED-25BF-4942-8428-383B51DA0D86}\"\nEndProject\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"Tests.NetFramework\", \"Tests.NetFramework\\Tests.NetFramework.csproj\", \"{A45A8238-966E-482D-BF1A-95A25BB3169B}\"\nEndProject\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"Tester.NetFramework\", \"Tester.NetFramework\\Tester.NetFramework.csproj\", \"{377A530B-43FA-4980-97DF-C21BB32B4F77}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Tester.NetCore\", \"Tester.NetCore\\Tester.NetCore.csproj\", \"{5CB67E67-72BD-4514-97D1-336F72F82BBF}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Prometheus.AspNetCore\", \"Prometheus.AspNetCore\\Prometheus.AspNetCore.csproj\", \"{7D0A36BB-5606-4D8F-B048-621C76B22881}\"\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"Documentation\", \"Documentation\", \"{0C02F049-E0A1-4F63-977C-CCC9C7531CF2}\"\n\tProjectSection(SolutionItems) = preProject\n\t\tHistory = History\n\t\tLICENSE = LICENSE\n\t\tREADME.md = README.md\n\tEndProjectSection\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Benchmark.NetCore\", \"Benchmark.NetCore\\Benchmark.NetCore.csproj\", \"{074E91E7-37BE-459E-B42F-96F315586418}\"\nEndProject\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"Prometheus.NetFramework.AspNet\", \"Prometheus.NetFramework.AspNet\\Prometheus.NetFramework.AspNet.csproj\", \"{25C05E15-A8F8-4F36-A35C-4004C0948305}\"\nEndProject\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"Tester.NetFramework.AspNet\", \"Tester.NetFramework.AspNet\\Tester.NetFramework.AspNet.csproj\", \"{1C13A89A-563E-4C4C-83F9-0DCCCFFDFA86}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Prometheus.AspNetCore.HealthChecks\", \"Prometheus.AspNetCore.HealthChecks\\Prometheus.AspNetCore.HealthChecks.csproj\", \"{4B630AF4-71AD-4CF1-AD4E-D0608B426109}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Tester.AspNetCore.HealthChecks\", \"Tester.AspNetCore.HealthChecks\\Tester.AspNetCore.HealthChecks.csproj\", \"{7A0E037C-501E-4FF5-BEEC-0132C809AF67}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Prometheus.AspNetCore.Grpc\", \"Prometheus.AspNetCore.Grpc\\Prometheus.AspNetCore.Grpc.csproj\", \"{86943076-6025-49F3-AC6D-6D63142364F7}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Sample.Console\", \"Sample.Console\\Sample.Console.csproj\", \"{28CA7A01-3D00-4988-8A9A-46F26ED476A0}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Sample.Web\", \"Sample.Web\\Sample.Web.csproj\", \"{60562020-7CC1-494A-837E-30550EE4E811}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Sample.Grpc\", \"Sample.Grpc\\Sample.Grpc.csproj\", \"{0A53812C-89AD-40E7-9A8C-52C82DD433AC}\"\nEndProject\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"Sample.Console.NetFramework\", \"Sample.Console.NetFramework\\Sample.Console.NetFramework.csproj\", \"{E4D772AF-BFA0-4EA9-AE3C-C7326A42F1E5}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Sample.Web.DifferentPort\", \"Sample.Web.DifferentPort\\Sample.Web.DifferentPort.csproj\", \"{1E0B26AD-3CA0-495A-9F47-C8497D641F7D}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Sample.Grpc.Client\", \"Sample.Grpc.Client\\Sample.Grpc.Client.csproj\", \"{74B81DD3-FC37-4760-ABC9-667265B28237}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Sample.Web.MetricExpiration\", \"Sample.Web.MetricExpiration\\Sample.Web.MetricExpiration.csproj\", \"{AE70A38C-C136-4507-98CA-4851F2958A56}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Sample.Console.DotNetMeters\", \"Sample.Console.DotNetMeters\\Sample.Console.DotNetMeters.csproj\", \"{1287EBE0-0EF2-4283-9AF9-747AD4D77F6B}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Prometheus\", \"Prometheus\\Prometheus.csproj\", \"{E585417C-F7DD-4D8C-A0C5-D4B79594634A}\"\nEndProject\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"Sample.Web.NetFramework\", \"Sample.Web.NetFramework\\Sample.Web.NetFramework.csproj\", \"{35C90741-497A-465C-A018-633FAD414D0D}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Sample.Console.NoAspNetCore\", \"Sample.Console.NoAspNetCore\\Sample.Console.NoAspNetCore.csproj\", \"{673B5DEC-8530-4226-B923-9D97A6AC29DB}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Sample.NetStandard\", \"Sample.NetStandard\\Sample.NetStandard.csproj\", \"{4F91DAA7-9DD3-418F-A276-84ABFED388A5}\"\nEndProject\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"Sample.Console.Exemplars\", \"Sample.Console.Exemplars\\Sample.Console.Exemplars.csproj\", \"{7F4947F1-C9DD-42F9-867D-5AC931478205}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|Any CPU = Debug|Any CPU\n\t\tRelease|Any CPU = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{608F1849-C417-4077-B60F-1BBF26762670}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{608F1849-C417-4077-B60F-1BBF26762670}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{09EED3ED-25BF-4942-8428-383B51DA0D86}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{09EED3ED-25BF-4942-8428-383B51DA0D86}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{09EED3ED-25BF-4942-8428-383B51DA0D86}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{09EED3ED-25BF-4942-8428-383B51DA0D86}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{A45A8238-966E-482D-BF1A-95A25BB3169B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{A45A8238-966E-482D-BF1A-95A25BB3169B}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{A45A8238-966E-482D-BF1A-95A25BB3169B}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{A45A8238-966E-482D-BF1A-95A25BB3169B}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{377A530B-43FA-4980-97DF-C21BB32B4F77}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{377A530B-43FA-4980-97DF-C21BB32B4F77}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{377A530B-43FA-4980-97DF-C21BB32B4F77}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{377A530B-43FA-4980-97DF-C21BB32B4F77}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{5CB67E67-72BD-4514-97D1-336F72F82BBF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{5CB67E67-72BD-4514-97D1-336F72F82BBF}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{5CB67E67-72BD-4514-97D1-336F72F82BBF}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{5CB67E67-72BD-4514-97D1-336F72F82BBF}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{7D0A36BB-5606-4D8F-B048-621C76B22881}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{7D0A36BB-5606-4D8F-B048-621C76B22881}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{7D0A36BB-5606-4D8F-B048-621C76B22881}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{7D0A36BB-5606-4D8F-B048-621C76B22881}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{074E91E7-37BE-459E-B42F-96F315586418}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{074E91E7-37BE-459E-B42F-96F315586418}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{074E91E7-37BE-459E-B42F-96F315586418}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{074E91E7-37BE-459E-B42F-96F315586418}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{25C05E15-A8F8-4F36-A35C-4004C0948305}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{25C05E15-A8F8-4F36-A35C-4004C0948305}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{25C05E15-A8F8-4F36-A35C-4004C0948305}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{25C05E15-A8F8-4F36-A35C-4004C0948305}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{1C13A89A-563E-4C4C-83F9-0DCCCFFDFA86}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{1C13A89A-563E-4C4C-83F9-0DCCCFFDFA86}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{1C13A89A-563E-4C4C-83F9-0DCCCFFDFA86}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{4B630AF4-71AD-4CF1-AD4E-D0608B426109}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{4B630AF4-71AD-4CF1-AD4E-D0608B426109}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{4B630AF4-71AD-4CF1-AD4E-D0608B426109}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{4B630AF4-71AD-4CF1-AD4E-D0608B426109}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{7A0E037C-501E-4FF5-BEEC-0132C809AF67}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{7A0E037C-501E-4FF5-BEEC-0132C809AF67}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{7A0E037C-501E-4FF5-BEEC-0132C809AF67}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{7A0E037C-501E-4FF5-BEEC-0132C809AF67}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{86943076-6025-49F3-AC6D-6D63142364F7}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{86943076-6025-49F3-AC6D-6D63142364F7}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{86943076-6025-49F3-AC6D-6D63142364F7}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{86943076-6025-49F3-AC6D-6D63142364F7}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{28CA7A01-3D00-4988-8A9A-46F26ED476A0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{28CA7A01-3D00-4988-8A9A-46F26ED476A0}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{28CA7A01-3D00-4988-8A9A-46F26ED476A0}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{28CA7A01-3D00-4988-8A9A-46F26ED476A0}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{60562020-7CC1-494A-837E-30550EE4E811}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{60562020-7CC1-494A-837E-30550EE4E811}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{60562020-7CC1-494A-837E-30550EE4E811}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{60562020-7CC1-494A-837E-30550EE4E811}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{0A53812C-89AD-40E7-9A8C-52C82DD433AC}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{0A53812C-89AD-40E7-9A8C-52C82DD433AC}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{0A53812C-89AD-40E7-9A8C-52C82DD433AC}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{0A53812C-89AD-40E7-9A8C-52C82DD433AC}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{E4D772AF-BFA0-4EA9-AE3C-C7326A42F1E5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{E4D772AF-BFA0-4EA9-AE3C-C7326A42F1E5}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{E4D772AF-BFA0-4EA9-AE3C-C7326A42F1E5}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{E4D772AF-BFA0-4EA9-AE3C-C7326A42F1E5}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{1E0B26AD-3CA0-495A-9F47-C8497D641F7D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{1E0B26AD-3CA0-495A-9F47-C8497D641F7D}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{1E0B26AD-3CA0-495A-9F47-C8497D641F7D}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{1E0B26AD-3CA0-495A-9F47-C8497D641F7D}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{74B81DD3-FC37-4760-ABC9-667265B28237}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{74B81DD3-FC37-4760-ABC9-667265B28237}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{74B81DD3-FC37-4760-ABC9-667265B28237}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{74B81DD3-FC37-4760-ABC9-667265B28237}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{AE70A38C-C136-4507-98CA-4851F2958A56}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{AE70A38C-C136-4507-98CA-4851F2958A56}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{AE70A38C-C136-4507-98CA-4851F2958A56}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{AE70A38C-C136-4507-98CA-4851F2958A56}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{1287EBE0-0EF2-4283-9AF9-747AD4D77F6B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{1287EBE0-0EF2-4283-9AF9-747AD4D77F6B}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{1287EBE0-0EF2-4283-9AF9-747AD4D77F6B}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{1287EBE0-0EF2-4283-9AF9-747AD4D77F6B}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{E585417C-F7DD-4D8C-A0C5-D4B79594634A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{E585417C-F7DD-4D8C-A0C5-D4B79594634A}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{E585417C-F7DD-4D8C-A0C5-D4B79594634A}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{E585417C-F7DD-4D8C-A0C5-D4B79594634A}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{35C90741-497A-465C-A018-633FAD414D0D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{35C90741-497A-465C-A018-633FAD414D0D}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{35C90741-497A-465C-A018-633FAD414D0D}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{673B5DEC-8530-4226-B923-9D97A6AC29DB}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{673B5DEC-8530-4226-B923-9D97A6AC29DB}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{673B5DEC-8530-4226-B923-9D97A6AC29DB}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{673B5DEC-8530-4226-B923-9D97A6AC29DB}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{4F91DAA7-9DD3-418F-A276-84ABFED388A5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{4F91DAA7-9DD3-418F-A276-84ABFED388A5}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{4F91DAA7-9DD3-418F-A276-84ABFED388A5}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{4F91DAA7-9DD3-418F-A276-84ABFED388A5}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{7F4947F1-C9DD-42F9-867D-5AC931478205}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{7F4947F1-C9DD-42F9-867D-5AC931478205}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{7F4947F1-C9DD-42F9-867D-5AC931478205}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{7F4947F1-C9DD-42F9-867D-5AC931478205}.Release|Any CPU.Build.0 = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {A3F5DDAA-093D-49E7-AA0C-183521D01BA7}\n\tEndGlobalSection\nEndGlobal\n"
        }
      ]
    }
  ]
}