{
  "metadata": {
    "timestamp": 1736710897525,
    "page": 483,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "altmann/FluentResults",
      "stars": 2158,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 2.458984375,
          "content": "###############################################################################\n# Set default behavior to automatically normalize line endings.\n###############################################################################\n* text=auto\n\n###############################################################################\n# Set default behavior for command prompt diff.\n#\n# This is need for earlier builds of msysgit that does not have it on by\n# default for csharp files.\n# Note: This is only used by command line\n###############################################################################\n#*.cs     diff=csharp\n\n###############################################################################\n# Set the merge driver for project and solution files\n#\n# Merging from the command prompt will add diff markers to the files if there\n# are conflicts (Merging from VS is not affected by the settings below, in VS\n# the diff markers are never inserted). Diff markers may cause the following \n# file extensions to fail to load in VS. An alternative would be to treat\n# these files as binary and thus will always conflict and require user\n# intervention with every merge. To do so, just uncomment the entries below\n###############################################################################\n#*.sln       merge=binary\n#*.csproj    merge=binary\n#*.vbproj    merge=binary\n#*.vcxproj   merge=binary\n#*.vcproj    merge=binary\n#*.dbproj    merge=binary\n#*.fsproj    merge=binary\n#*.lsproj    merge=binary\n#*.wixproj   merge=binary\n#*.modelproj merge=binary\n#*.sqlproj   merge=binary\n#*.wwaproj   merge=binary\n\n###############################################################################\n# behavior for image files\n#\n# image files are treated as binary by default.\n###############################################################################\n#*.jpg   binary\n#*.png   binary\n#*.gif   binary\n\n###############################################################################\n# diff behavior for common document formats\n# \n# Convert binary document formats to text before diffing them. This feature\n# is only available from the command line. Turn it on by uncommenting the \n# entries below.\n###############################################################################\n#*.doc   diff=astextplain\n#*.DOC   diff=astextplain\n#*.docx  diff=astextplain\n#*.DOCX  diff=astextplain\n#*.dot   diff=astextplain\n#*.DOT   diff=astextplain\n#*.pdf   diff=astextplain\n#*.PDF   diff=astextplain\n#*.rtf   diff=astextplain\n#*.RTF   diff=astextplain\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 4.0966796875,
          "content": "## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n\n# User-specific files\n*.suo\n*.user\n*.userosscache\n*.sln.docstates\n\n# User-specific files (MonoDevelop/Xamarin Studio)\n*.userprefs\n\n# Build results\n[Dd]ebug/\n[Dd]ebugPublic/\n[Rr]elease/\n[Rr]eleases/\nx64/\nx86/\nbld/\n[Bb]in/\n[Oo]bj/\n[Ll]og/\n\n# Visual Studio 2015 cache/options directory\n.vs/\n# Uncomment if you have tasks that create the project's static files in wwwroot\n#wwwroot/\n\n# MSTest test Results\n[Tt]est[Rr]esult*/\n[Bb]uild[Ll]og.*\n\n# NUNIT\n*.VisualState.xml\nTestResult.xml\n\n# Build Results of an ATL Project\n[Dd]ebugPS/\n[Rr]eleasePS/\ndlldata.c\n\n# DNX\nproject.lock.json\nartifacts/\n\n*_i.c\n*_p.c\n*_i.h\n*.ilk\n*.meta\n*.obj\n*.pch\n*.pdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.tmp_proj\n*.log\n*.vspscc\n*.vssscc\n.builds\n*.pidb\n*.svclog\n*.scc\n\n# Chutzpah Test files\n_Chutzpah*\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opendb\n*.opensdf\n*.sdf\n*.cachefile\n*.VC.db\n*.VC.VC.opendb\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n*.sap\n\n# TFS 2012 Local Workspace\n$tf/\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*/\n*.[Rr]e[Ss]harper\n*.DotSettings.user\n\n# JustCode is a .NET coding add-in\n.JustCode\n\n# TeamCity is a build add-in\n_TeamCity*\n\n# DotCover is a Code Coverage Tool\n*.dotCover\n\n# NCrunch\n_NCrunch_*\n.*crunch*.local.xml\nnCrunchTemp_*\n\n# MightyMoose\n*.mm.*\nAutoTest.Net/\n\n# Web workbench (sass)\n.sass-cache/\n\n# Installshield output folder\n[Ee]xpress/\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish/\n\n# Publish Web Output\n*.[Pp]ublish.xml\n*.azurePubxml\n# TODO: Comment the next line if you want to checkin your web deploy settings\n# but database connection strings (with potential passwords) will be unencrypted\n*.pubxml\n*.publishproj\n\n# Microsoft Azure Web App publish settings. Comment the next line if you want to\n# checkin your Azure Web App publish settings, but sensitive information contained\n# in these scripts will be unencrypted\nPublishScripts/\n\n# NuGet Packages\n*.nupkg\n# The packages folder can be ignored because of Package Restore\n**/packages/*\n# except build/, which is used as an MSBuild target.\n!**/packages/build/\n# Uncomment if necessary however generally it will be regenerated when needed\n#!**/packages/repositories.config\n# NuGet v3's project.json files produces more ignoreable files\n*.nuget.props\n*.nuget.targets\n\n# Microsoft Azure Build Output\ncsx/\n*.build.csdef\n\n# Microsoft Azure Emulator\necf/\nrcf/\n\n# Windows Store app package directories and files\nAppPackages/\nBundleArtifacts/\nPackage.StoreAssociation.xml\n_pkginfo.txt\n\n# Visual Studio cache files\n# files ending in .cache can be ignored\n*.[Cc]ache\n# but keep track of directories ending in .cache\n!*.[Cc]ache/\n\n# Others\nClientBin/\n~$*\n*~\n*.dbmdl\n*.dbproj.schemaview\n*.pfx\n*.publishsettings\nnode_modules/\norleans.codegen.cs\n\n# Since there are multiple workflows, uncomment next line to ignore bower_components\n# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)\n#bower_components/\n\n# RIA/Silverlight projects\nGenerated_Code/\n\n# Backup & report files from converting an old project file\n# to a newer Visual Studio version. Backup files are not needed,\n# because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\nUpgradeLog*.htm\n\n# SQL Server files\n*.mdf\n*.ldf\n\n# Business Intelligence projects\n*.rdl.data\n*.bim.layout\n*.bim_*.settings\n\n# Microsoft Fakes\nFakesAssemblies/\n\n# GhostDoc plugin setting file\n*.GhostDoc.xml\n\n# Node.js Tools for Visual Studio\n.ntvs_analysis.dat\n\n# Visual Studio 6 build log\n*.plg\n\n# Visual Studio 6 workspace options file\n*.opt\n\n# Visual Studio LightSwitch build output\n**/*.HTMLClient/GeneratedArtifacts\n**/*.DesktopClient/GeneratedArtifacts\n**/*.DesktopClient/ModelManifest.xml\n**/*.Server/GeneratedArtifacts\n**/*.Server/ModelManifest.xml\n_Pvt_Extensions\n\n# Paket dependency manager\n.paket/paket.exe\npaket-files/\n\n# FAKE - F# Make\n.fake/\n\n# JetBrains Rider\n.idea/\n*.sln.iml\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.046875,
          "content": "MIT License\n\nCopyright (c) 2021 Michael Altmann\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 25.005859375,
          "content": "<img src=\"https://raw.githubusercontent.com/altmann/FluentResults/master/resources/icons/FluentResults-Icon-64.png\" alt=\"FluentResults\"/>\n# FluentResults\n\n[![Nuget downloads](https://img.shields.io/nuget/v/fluentresults.svg)](https://www.nuget.org/packages/FluentResults/)\n[![Nuget](https://img.shields.io/nuget/dt/fluentresults)](https://www.nuget.org/packages/FluentResults/)\n[![Build status](https://dev.azure.com/altmann/FluentResults/_apis/build/status/FluentResults-CI)](https://dev.azure.com/altmann/FluentResults/_build/latest?definitionId=11)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://github.com/altmann/FluentResults/blob/master/LICENSE)\n\n**FluentResults is a lightweight .NET library developed to solve a common problem. It returns an object indicating success or failure of an operation instead of throwing/using exceptions.**\n\nYou can install [FluentResults with NuGet](https://www.nuget.org/packages/FluentResults/):\n\n```\nInstall-Package FluentResults\n```\n\n> :heart: The most needed community feature is pushed to nuget: **[FluentResults.Extensions.AspNetCore](https://www.nuget.org/packages/FluentResults.Extensions.AspNetCore/)** Read [documentation](https://github.com/altmann/FluentResults/wiki/Returning-Result-Objects-from-ASP.NET-Core-Controller). Try it, test it, [give feedback](https://github.com/altmann/FluentResults/issues/149).\n\n## Key Features\n\n- **Generalised container** which works in all contexts (ASP.NET MVC/WebApi, WPF, DDD Domain Model, etc)\n- Store **multiple errors** in one Result object\n- Store **powerful and elaborative Error and Success objects** instead of only error messages in string format\n- Designing Errors/Success in an object-oriented way\n- Store the **root cause with chain of errors in a hierarchical way**\n- Provide \n  - .NET Standard, .NET Core, .NET 5+ and .NET Full Framework support (details see [.NET Targeting](https://github.com/altmann/FluentResults#net-targeting))\n  - SourceLink support\n  - powerful [code samples](https://github.com/altmann/FluentResults#samplesbest-practices) which show the integration with famous or common frameworks/libraries\n- **NEW** Enhanced [FluentAssertions Extension](https://github.com/altmann/FluentResults/wiki/Asserting-Result-Objects) to assert FluentResult objects in an elegant way\n- **IN PREVIEW** [Returning Result Objects from ASP.NET Controller](https://github.com/altmann/FluentResults/wiki/Returning-Result-Objects-from-ASP.NET-Core-Controller)\n\n## Why Results instead of exceptions\n\nTo be honest, the pattern - returning a Result object indicating success or failure - is not at all a new idea. This pattern comes from functional programming languages. With FluentResults this pattern can also be applied in .NET/C#. \n\nThe article [Exceptions for Flow Control by Vladimir Khorikov](https://enterprisecraftsmanship.com/posts/exceptions-for-flow-control/) describes very good in which scenarios the Result pattern makes sense and in which not. See the [list of Best Practices](https://github.com/altmann/FluentResults#samplesbest-practices) and the [list of resources](https://github.com/altmann/FluentResults#interesting-resources-about-result-pattern) to learn more about the Result Pattern.\n\n## Creating a Result\n\nA Result can store multiple Error and Success messages.\n\n```csharp\n// create a result which indicates success\nResult successResult1 = Result.Ok();\n\n// create a result which indicates failure\nResult errorResult1 = Result.Fail(\"My error message\");\nResult errorResult2 = Result.Fail(new Error(\"My error message\"));\nResult errorResult3 = Result.Fail(new StartDateIsAfterEndDateError(startDate, endDate));\nResult errorResult4 = Result.Fail(new List<string> { \"Error 1\", \"Error 2\" });\nResult errorResult5 = Result.Fail(new List<IError> { new Error(\"Error 1\"), new Error(\"Error 2\") });\n```\n    \nThe class `Result` is typically used by void methods which have no return value.\n\n```csharp\npublic Result DoTask()\n{\n    if (this.State == TaskState.Done)\n        return Result.Fail(\"Task is in the wrong state.\");\n\n    // rest of the logic\n\n    return Result.Ok();\n}\n```\n\nAdditionally a value from a specific type can also be stored if necessary.\n\n```csharp\n// create a result which indicates success\nResult<int> successResult1 = Result.Ok(42);\nResult<MyCustomObject> successResult2 = Result.Ok(new MyCustomObject());\n\n// create a result which indicates failure\nResult<int> errorResult = Result.Fail<int>(\"My error message\");\n```\n\nThe class `Result<T>` is typically used by methods with a return type. \n\n```csharp\npublic Result<Task> GetTask()\n{\n    if (this.State == TaskState.Deleted)\n        return Result.Fail<Task>(\"Deleted Tasks can not be displayed.\");\n\n    // rest of the logic\n\n    return Result.Ok(task);\n}\n```\n\n## Processing a Result\n\nAfter you get a Result object from a method you have to process it. This means, you have to check if the operation was completed successfully or not. The properties `IsSuccess` and `IsFailed` in the Result object indicate success or failure. The value of a `Result<T>` can be accessed via the properties `Value` and `ValueOrDefault`.\n\n```csharp\nResult<int> result = DoSomething();\n     \n// get all reasons why result object indicates success or failure. \n// contains Error and Success messages\nIEnumerable<IReason> reasons = result.Reasons;\n\n// get all Error messages\nIEnumerable<IError> errors = result.Errors;\n\n// get all Success messages\nIEnumerable<ISuccess> successes = result.Successes;\n\nif (result.IsFailed)\n{\n    // handle error case\n    var value1 = result.Value; // throws exception because result is in failed state\n    var value2 = result.ValueOrDefault; // return default value (=0) because result is in failed state\n    return;\n}\n\n// handle success case\nvar value3 = result.Value; // return value and doesn't throw exception because result is in success state\nvar value4 = result.ValueOrDefault; // return value because result is in success state\n```\n\n## Designing errors and success messages\n\nThere are many Result Libraries which store only simple string messages. FluentResults instead stores powerful object-oriented Error and Success objects. The advantage is all the relevant information of an error or success is encapsulated within one class. \n\nThe entire public api of this library uses the interfaces `IReason`, `IError` and `ISuccess` for representing a reason, error or success. `IError` and `ISuccess` inherit from `IReason`. If at least one `IError` object exists in the `Reasons` property then the result indicates a failure and the property `IsSuccess` is false. \n\nYou can create your own `Success` or `Error` classes when you inherit from `ISuccess` or `IError` or if you inherit from `Success` or `Error`. \n\n```csharp\npublic class StartDateIsAfterEndDateError : Error\n{\n    public StartDateIsAfterEndDateError(DateTime startDate, DateTime endDate)\n        : base($\"The start date {startDate} is after the end date {endDate}\")\n    { \n        Metadata.Add(\"ErrorCode\", \"12\");\n    }\n}\n```\n\nWith this mechanism you can also create a class `Warning`. You can choose if a Warning in your system indicates a success or a failure by inheriting from `Success` or `Error` classes.  \n\n## Further features\n\n### Chaining error and success messages\n\nIn some cases it is necessary to chain multiple error and success messages in one result object. \n\n```csharp\nvar result = Result.Fail(\"error message 1\")\n                   .WithError(\"error message 2\")\n                   .WithError(\"error message 3\")\n                   .WithSuccess(\"success message 1\");\n```\n\n### Create a result depending on success/failure condition\n\nVery often you have to create a fail or success result depending on a condition. Usually you can write it in this way:\n\n```csharp\nvar result = string.IsNullOrEmpty(firstName) ? Result.Fail(\"First Name is empty\") : Result.Ok();\n```\n\nWith the methods ```FailIf()``` and ```OkIf()``` you can also write in a more readable way:\n\n```csharp\nvar result = Result.FailIf(string.IsNullOrEmpty(firstName), \"First Name is empty\");\n```\n\nIf an error instance should be lazily initialized, overloads accepting ```Func<string>``` or ```Func<IError>``` can be used to that effect:\n\n```csharp\nvar list = Enumerable.Range(1, 9).ToList();\n\nvar result = Result.FailIf(\n    list.Any(IsDivisibleByTen),\n    () => new Error($\"Item {list.First(IsDivisibleByTen)} should not be on the list\"));\n\nbool IsDivisibleByTen(int i) => i % 10 == 0;\n\n// rest of the code\n```\n\n### Try\n\nIn some scenarios you want to execute an action. If this action throws an exception then the exception should be caught and transformed to a result object. \n\n```csharp\nvar result = Result.Try(() => DoSomethingCritical());\n```\n\nYou can also return your own `Result` object\n\n```csharp\nvar result = Result.Try(() => {\n    if(IsInvalid()) \n    {\n        return Result.Fail(\"Some error\");\n    }\n\n    int id = DoSomethingCritical();\n\n    return Result.Ok(id);\n});\n```\n\nIn the above example the default catchHandler is used. The behavior of the default catchHandler can be overwritten via the global Result settings (see next example). You can control how the Error object looks.\n\n```csharp\nResult.Setup(cfg =>\n{\n    cfg.DefaultTryCatchHandler = exception =>\n    {\n        if (exception is SqlTypeException sqlException)\n            return new ExceptionalError(\"Sql Fehler\", sqlException);\n\n        if (exception is DomainException domainException)\n            return new Error(\"Domain Fehler\")\n                .CausedBy(new ExceptionError(domainException.Message, domainException));\n\n        return new Error(exception.Message);\n    };\n});\n\nvar result = Result.Try(() => DoSomethingCritical());\n```\n\nIt is also possible to pass a custom catchHandler via the ```Try(..)``` method. \n\n```csharp\nvar result = Result.Try(() => DoSomethingCritical(), ex => new MyCustomExceptionError(ex));\n```\n\n### Root cause of the error\n\nYou can also store the root cause of the error in the error object. With the method `CausedBy(...)` the root cause can be passed as Error, list of Errors, string, list of strings or as exception. The root cause is stored in the `Reasons` property of the error object. \n\nExample 1 - root cause is an exception\n```csharp\ntry\n{\n    //export csv file\n}\ncatch(CsvExportException ex)\n{\n    return Result.Fail(new Error(\"CSV Export not executed successfully\").CausedBy(ex));\n}\n```\n\nExample 2 - root cause is an error\n```csharp\nError rootCauseError = new Error(\"This is the root cause of the error\");\nResult result = Result.Fail(new Error(\"Do something failed\", rootCauseError));\n```\n\nExample 3 - reading root cause from errors\n```csharp\nResult result = ....;\nif (result.IsSuccess)\n   return;\n\nforeach(IError error in result.Errors)\n{\n    foreach(ExceptionalError causedByExceptionalError in error.Reasons.OfType<ExceptionalError>())\n    {\n        Console.WriteLine(causedByExceptionalError.Exception);\n    }\n}\n```\n\n### Metadata\n\nIt is possible to add metadata to Error or Success objects. \n\nOne way of doing that is to call the method `WithMetadata(...)` directly where result object is being created. \n\n```csharp\nvar result1 = Result.Fail(new Error(\"Error 1\").WithMetadata(\"metadata name\", \"metadata value\"));\n\nvar result2 = Result.Ok()\n                    .WithSuccess(new Success(\"Success 1\")\n                                 .WithMetadata(\"metadata name\", \"metadata value\"));\n```\n\nAnother way is to call `WithMetadata(...)` in constructor of the `Error` or `Success` class. \n\n```csharp\npublic class DomainError : Error\n{\n    public DomainError(string message)\n        : base(message)\n    { \n        WithMetadata(\"ErrorCode\", \"12\");\n    }\n}\n```\n\n### Merging\n\nMultiple results can be merged with the static method `Merge()`.\n\n```csharp\nvar result1 = Result.Ok();\nvar result2 = Result.Fail(\"first error\");\nvar result3 = Result.Ok<int>();\n\nvar mergedResult = Result.Merge(result1, result2, result3);\n```\n\nA list of results can be merged to one result with the extension method `Merge()`. \n\n```csharp\nvar result1 = Result.Ok();\nvar result2 = Result.Fail(\"first error\");\nvar result3 = Result.Ok<int>();\n\nvar results = new List<Result> { result1, result2, result3 };\n\nvar mergedResult = results.Merge();\n```\n\n### Converting and Transformation\n\nA result object can be converted to another result object with methods `ToResult()` and `ToResult<TValue>()`.\n\n```csharp\n// converting a result to a result from type Result<int> with default value of int\nResult.Ok().ToResult<int>();\n\n// converting a result to a result from type Result<int> with a custom value\nResult.Ok().ToResult<int>(5);\n\n// converting a failed result to a result from type Result<int> without passing a custom value\n// because result is in failed state and therefore no value is needed\nResult.Fail(\"Failed\").ToResult<int>();\n\n// converting a result to a result from type Result<float>\nResult.Ok<int>(5).ToResult<float>(v => v);\n\n// converting a result from type Result<int> to result from type Result<float> without passing the converting\n// logic because result is in failed state and therefore no converting logic needed\nResult.Fail<int>(\"Failed\").ToResult<float>();\n\n// converting a result to a result from type Result\nResult.Ok<int>().ToResult();\n```\n\nA value of a result object to another value can be transformed via method ``Map(..)`\n\n```csharp\n// converting a result to a result from type Result<float>\nResult.Ok<int>(5).Map(v => new Dto(5));\n```\n\n### Implicit conversion from T to success result ```Result<T>```\n\n```csharp\nstring myString = \"hello world\";\nResult<T> result = myString;\n```\n\n### Implicit conversion from Error to fail result ```Result``` or ```Result<T>```\n\nfrom a single error\n\n```csharp\nerror myError = new Error(\"error msg\");\nResult result = myError;\n```\nor from a list of errors\n\n```csharp\nList<Error> myErrors = new List<Error>() \n    { \n        new Error(\"error 1\"), \n        new Error(\"error 2\") \n    };\n    \nResult result = myErrors;\n```\n\n### Bind the result to another result\n\nBinding is a transformation that returns a `Result` | `Result<T>`.\nIt only evaluates the transformation if the original result is successful.\nThe reasons of both `Result` will be merged into a new flattened `Result`.\n\n```csharp\n// converting a result to a result which may fail\nResult<string> r = Result.Ok(8)\n    .Bind(v => v == 5 ? \"five\" : Result.Fail<string>(\"It is not five\"));\n\n// converting a failed result to a result, which can also fail, \n// returns a result with the errors of the first result only,\n// the transformation is not evaluated because the value of the first result is not available\nResult<string> r = Result.Fail<int>(\"Not available\")\n    .Bind(v => v == 5 ? \"five\" : Result.Fail<string>(\"It is not five\"));\n\n// converting a result with value to a Result via a transformation which may fail\nResult.Ok(5).Bind(x => Result.OkIf(x == 6, \"Number is not 6\"));\n\n// converting a result without value into a Result \nResult.Ok().Bind(() => Result.Ok(5));\n\n// just running an action if the original result is sucessful. \nResult r = Result.Ok().Bind(() => Result.Ok());\n```\n\nThe `Bind` has asynchronous overloads.\n\n```csharp\nvar result = await Result.Ok(5)\n    .Bind(int n => Task.FromResult(Result.Ok(n + 1).WithSuccess(\"Added one\")))\n    .Bind(int n => /* next continuation */);\n```\n\n### Set global factories for ISuccess/IError/IExceptionalError\n\nWithin the FluentResults library in some scenarios an ISuccess, IError or IExceptionalError object is created. For example if the method ```Result.Fail(\"My Error\")``` is called then internally an IError object is created. If you need to overwrite this behavior and create in this scenario a custom error class then you can set the error factory via the settings. The same extension points are also available for ISuccess and IExceptionalError. \n\n```csharp\nResult.Setup(cfg =>\n{\n    cfg.SuccessFactory = successMessage => new Success(successMessage).WithMetadata(\"Timestamp\", DateTime.Now);\n    \n    cfg.ErrorFactory = errorMessage => new Error(errorMessage).WithMetadata(\"Timestamp\", DateTime.Now);\n    \n    cfg.ExceptionalErrorFactory = (errorMessage, exception) => new ExceptionalError(errorMessage ?? exception.Message, exception)\n    .WithMetadata(\"Timestamp\", DateTime.Now);\n});\n```\n\n### Mapping errors and successes\n\nIf you want to add some information to all successes in a result you can use `MapSuccesses(...)` on a result object. \n\n```csharp\nvar result = Result.Ok().WithSuccess(\"Success 1\");\nvar result2 = result.MapSuccesses(e => new Success(\"Prefix: \" + e.Message));\n```\n\nIf you want to add some information to all errors in a result you can use `MapErrors(...)` on a result object. This method only iterate through the first level of errors, the root cause errors (in error.Reasons) are not changed. \n\n```csharp\nvar result = Result.Fail(\"Error 1\");\nvar result2 = result.MapErrors(e => new Error(\"Prefix: \" + e.Message));\n```\n\n### Handling/catching errors\n\nSimilar to the catch block for exceptions, the checking and handling of errors within Result object is also supported using some methods: \n\n```csharp\n// check if the Result object contains an error from a specific type\nresult.HasError<MyCustomError>();\n\n// check if the Result object contains an error from a specific type and with a specific condition\nresult.HasError<MyCustomError>(myCustomError => myCustomError.MyField == 2);\n\n// check if the Result object contains an error with a specific metadata key\nresult.HasError(error => error.HasMetadataKey(\"MyKey\"));\n\n// check if the Result object contains an error with a specific metadata\nresult.HasError(error => error.HasMetadata(\"MyKey\", metadataValue => (string)metadataValue == \"MyValue\")); \n```\n\nAll ```HasError()``` methods have an optional out parameter result to access the found errorors. \n\n### Handling successes\n\nChecking if a result object contains a specific success object can be done with the method `HasSuccess()`\n\n```csharp\n// check if the Result object contains a success from a specific type\nresult.HasSuccess<MyCustomSuccess>();\n\n// check if the Result object contains a success from a specific type and with a specific condition\nresult.HasSuccess<MyCustomSuccess>(success => success.MyField == 3);\n```\n\nAll ```HasSuccess()``` methods have an optional out parameter result to access the found successes. \n\n### Handling/catching exceptions\n\nChecking if a result object contains an error with an specific exception type can be done with the method `HasException()`\n\n```csharp\n// check if the Result object contains an exception from a specific type\nresult.HasException<MyCustomException>();\n\n// check if the Result object contains an exception from a specific type and with a specific condition\nresult.HasException<MyCustomException>(MyCustomException => MyCustomException.MyField == 1);\n```\n\nAll ```HasException()``` methods have an optional out parameter result to access the found error. \n\n### Pattern Matching\n\n```csharp\nvar result = Result.Fail<int>(\"Error 1\");\n\nvar outcome = result switch\n{\n     { IsFailed: true } => $\"Errored because {result.Errors}\",\n     { IsSuccess: true } => $\"Value is {result.Value}\",\n     _ => null\n};\n```\n\n### Deconstruct Operators\n\n```csharp\nvar (isSuccess, isFailed, value, errors) = Result.Fail<bool>(\"Failure 1\");\n\nvar (isSuccess, isFailed, errors) = Result.Fail(\"Failure 1\");\n```\n\n### Logging\n\nSometimes it is necessary to log results. First create a logger:\n\n```csharp\npublic class MyConsoleLogger : IResultLogger\n{\n    public void Log(string context, string content, ResultBase result, LogLevel logLevel)\n    {\n        Console.WriteLine(\"Result: {0} {1} <{2}>\", result.Reasons.Select(reason => reason.Message), content, context);\n    }\n\n    public void Log<TContext>(string content, ResultBase result, LogLevel logLevel)\n    {\n        Console.WriteLine(\"Result: {0} {1} <{2}>\", result.Reasons.Select(reason => reason.Message), content, typeof(TContext).FullName);\n    }\n}\n```\n\nThen you must register your logger in the Result settings:\n\n```csharp\nvar myLogger = new MyConsoleLogger();\nResult.Setup(cfg => {\n    cfg.Logger = myLogger;\n});\n```\n\nFinally the logger can be used on any result:\n\n```csharp\nvar result = Result.Fail(\"Operation failed\")\n    .Log();\n```\n\nAdditionally, a context can be passed in form of a string or of a generic type parameter. A custom message that provide more information can also be passed as content.\n\n```csharp\nvar result = Result.Fail(\"Operation failed\")\n    .Log(\"logger context\", \"More info about the result\");\n\nvar result2 = Result.Fail(\"Operation failed\")\n    .Log<MyLoggerContext>(\"More info about the result\");\n```\n\nIt's also possible to specify the desired log level:\n```csharp\nvar result = Result.Ok().Log(LogLevel.Debug);\nvar result = Result.Fail().Log<MyContext>(\"Additional context\", LogLevel.Error);\n```\n\nYou can also log results only on successes or failures:\n\n```csharp\nResult<int> result = DoSomething();\n\n// log with default log level 'Information'\nresult.LogIfSuccess();\n\n// log with default log level 'Error'\nresult.LogIfFailed();\n```\n\n\n### Asserting FluentResult objects\n\nTry it with the power of FluentAssertions and [FluentResults.Extensions.FluentAssertions](https://github.com/altmann/FluentResults/wiki#fluentresultsextensionsfluentassertions). Since v2.0 the assertion package is out of the experimental phase and its really a great enhancement to assert result objects in a fluent way. \n\n### .NET Targeting\n\nFluentResults 3.x and above supports .NET Standard 2.0 and .NET Standard 2.1. \nIf you need support for .NET Standard 1.1, .NET 4.6.1 or .NET 4.5 use [FluentResults 2.x](https://www.nuget.org/packages/FluentResults/2.6.0).\n\n## Samples/Best Practices\n\nHere are some samples and best practices to be followed while using FluentResult or the Result pattern in general with some famous or commonly used frameworks and libraries.\n\n### Powerful domain model inspired by Domain Driven Design\n\n- [Domain model with a command handler](https://github.com/altmann/FluentResults/tree/master/src/FluentResults.Samples/DomainDrivenDesign)\n- Protecting domain invariants by using for example factory methods returning a Result object\n- Make each error unique by making your own custom Error classes inheriting from IError interface or Error class\n- If the method doesn't have a failure scenario then don't use the Result class as return type\n- Be aware that you can merge multiple failed results or return the first failed result asap\n\n### Serializing Result objects (ASP.NET WebApi, [Hangfire](https://www.hangfire.io/))\n\n- [Asp.net WebController](https://github.com/altmann/FluentResults/tree/master/src/FluentResults.Samples/WebController)\n- [Hangfire Job](https://github.com/altmann/FluentResults/tree/master/src/FluentResults.Samples/HangfireJobs)\n- Don't serialize FluentResult result objects. \n- Make your own custom ResultDto class for your public api in your system boundaries\n  - So you can control which data is submitted and which data is serialized\n  - Your public api is independent of third party libraries like FluentResults\n  - You can keep your public api stable\n\n### [MediatR](https://github.com/jbogard/MediatR) request handlers returning Result objects\n\n- [Full functional .NET Core sample code with commands/queries and a ValidationPipelineBehavior](https://github.com/altmann/FluentResults/tree/master/src/FluentResults.Samples.MediatR)\n- Returns business validation errors via a Result object from a MediatR request handler back to the consumer\n- Don't throw exceptions based on business validation errors\n- Inject command and query validation via MediatR PipelineBehavior and return a Result object instead of throwing an exception\n\n## Interesting Resources about Result Pattern\n\n- [Error Handling — Returning Results by Michael Altmann](https://medium.com/@michael_altmann/error-handling-returning-results-2b88b5ea11e9)\n- [Operation Result Pattern by Carl-Hugo Marcotte](https://www.forevolve.com/en/articles/2018/03/19/operation-result/)\n- [Exceptions for flow control in C# by Vladimir Khorikov](https://enterprisecraftsmanship.com/posts/exceptions-for-flow-control/)\n- [Error handling: Exception or Result? by Vladimir Khorikov](https://enterprisecraftsmanship.com/posts/error-handling-exception-or-result/)\n- [What is an exceptional situation in code? by Vladimir Khorikov](https://enterprisecraftsmanship.com/posts/what-is-exceptional-situation/)\n- [Advanced error handling techniques by Vladimir Khorikov](https://enterprisecraftsmanship.com/posts/advanced-error-handling-techniques/)\n- [A Simple Guide by Isaac Cummings](https://medium.com/@cummingsi1993/the-operation-result-pattern-a-simple-guide-fe10ff959080)\n- [Flexible Error Handling w/ the Result Class by Khalil Stemmler](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/handling-errors-result-class/)\n- [Combining ASP.NET Core validation attributes with Value Objects by Vladimir Khorikov](https://enterprisecraftsmanship.com/posts/combining-asp-net-core-attributes-with-value-objects/)\n\n## Donate\n\nI love this project but implementing features, answering issues or maintaining ci/release pipelines takes time - this is my freetime. If you like FluentResult and you find it useful, consider making a donation. Click on the sponsor button on the top right side. \n\n## Contributors\n\nThanks to all the contributers and to all the people who gave feedback!\n\n<a href=\"https://github.com/altmann/fluentresults/graphs/contributors\">\n  <img src=\"https://contrib.rocks/image?repo=altmann/fluentresults\" />\n</a>\n\n## Copyright\n\nCopyright (c) Michael Altmann. See [LICENSE](https://raw.githubusercontent.com/altmann/FluentResults/master/LICENSE) for details.\n"
        },
        {
          "name": "resources",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}