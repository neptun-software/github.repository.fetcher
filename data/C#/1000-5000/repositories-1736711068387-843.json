{
  "metadata": {
    "timestamp": 1736711068387,
    "page": 843,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Cysharp/MessagePipe",
      "stars": 1473,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.30859375,
          "content": "**/.classpath\n**/.dockerignore\n**/.env\n**/.git\n**/.gitignore\n**/.project\n**/.settings\n**/.toolstarget\n**/.vs\n**/.vscode\n**/*.*proj.user\n**/*.dbmdl\n**/*.jfm\n**/azds.yaml\n**/bin\n**/charts\n**/docker-compose*\n**/Dockerfile*\n**/node_modules\n**/npm-debug.log\n**/obj\n**/secrets.dev.yaml\n**/values.dev.yaml\nLICENSE\nREADME.md"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.9130859375,
          "content": "# Build Folders (you can keep bin if you'd like, to store dlls and pdbs)\n[Bb]in/\n[Oo]bj/\n\n# mstest test results\nTestResults\n\n## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n\n# User-specific files\n*.suo\n*.user\n*.sln.docstates\n\n# Build results\n[Dd]ebug/\n[Rr]elease/\n*_i.c\n*_p.c\n*.ilk\n*.obj\n*.pch\n*.pdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.log\n*.vspscc\n*.vssscc\n.builds\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opensdf\n*.sdf\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*\n\n# NCrunch\n*.ncrunch*\n.*crunch*.local.xml\n\n# Installshield output folder\n[Ee]xpress\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish\n\n# Publish Web Output\n*.Publish.xml\n\n# NuGet Packages Directory\npackages\n\n# Windows Azure Build Output\ncsx\n*.build.csdef\n\n# Windows Store app package directory\nAppPackages/\n\n# Others\n[Bb]in\n[Oo]bj\nsql\nTestResults\n[Tt]est[Rr]esult*\n*.Cache\nClientBin\n[Ss]tyle[Cc]op.*\n~$*\n*.dbmdl\nGenerated_Code #added for RIA/Silverlight projects\n\n# Backup & report files from converting an old project file to a newer\n# Visual Studio version. Backup files are not needed, because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\n.vs/config/applicationhost.config\n.vs/restore.dg\n\nnuget/tools/*\nnuget/*.nupkg\nnuget/*.unitypackage\n.vs/\n\n# Jetbrains Rider\n.idea/\n\n# Benchamrk\nBenchmarkDotNet.Artifacts/\n\n# Unity\n.vsconfig\nsrc/MessagePipe.Unity/Library/*\nsrc/MessagePipe.Unity/Temp/*\nsrc/MessagePipe.Unity/Logs/*\nsrc/MessagePipe.Unity/[Uu]ser[Ss]ettings/\nsrc/MessagePipe.Unity/*.sln\nsrc/MessagePipe.Unity/*.csproj\nsrc/MessagePipe.Unity/*.unitypackage\n!src/MessagePipe.Unity/Packages/\n"
        },
        {
          "name": "Directory.Build.props",
          "type": "blob",
          "size": 0.7822265625,
          "content": "<Project>\n  <PropertyGroup>\n    <LangVersion>latest</LangVersion>\n    <Nullable>enable</Nullable>\n    <GenerateDocumentationFile>true</GenerateDocumentationFile>\n    <NoWarn>$(NoWarn);CS1591</NoWarn>\n\n    <!-- NuGet Packaging -->\n    <PackageVersion>$(Version)</PackageVersion>\n    <Company>Cysharp</Company>\n    <Authors>Cysharp</Authors>\n    <Copyright>© Cysharp, Inc.</Copyright>\n    <PackageProjectUrl>https://github.com/Cysharp/MessagePipe</PackageProjectUrl>\n    <RepositoryUrl>$(PackageProjectUrl)</RepositoryUrl>\n    <RepositoryType>git</RepositoryType>\n    <PackageLicenseExpression>MIT</PackageLicenseExpression>\n    <PackageIcon>Icon.png</PackageIcon>\n    <AssemblyOriginatorKeyFile>$(MSBuildThisFileDirectory)opensource.snk</AssemblyOriginatorKeyFile>\n    \n\n  </PropertyGroup>\n</Project>\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.044921875,
          "content": "MIT License\n\nCopyright (c) 2021 Cysharp, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "MessagePipe.sln",
          "type": "blob",
          "size": 14.04296875,
          "content": "﻿\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio Version 17\nVisualStudioVersion = 17.0.32002.185\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePipe\", \"src\\MessagePipe\\MessagePipe.csproj\", \"{D94EF9D4-3CC2-4420-8D0B-25957E7C5309}\"\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"src\", \"src\", \"{381F6F79-110B-4CE4-9A49-583046D8C164}\"\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"sandbox\", \"sandbox\", \"{9813BFC3-7860-4697-A3AF-118BDF710BD0}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePipe.Sandbox.ConsoleApp\", \"sandbox\\MessagePipe.Sandbox.ConsoleApp\\MessagePipe.Sandbox.ConsoleApp.csproj\", \"{BEFA1E77-266B-4F35-8892-935729D4A07F}\"\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"tests\", \"tests\", \"{36546FD6-866F-4809-AFCE-87F7F4201361}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePipe.Tests\", \"tests\\MessagePipe.Tests\\MessagePipe.Tests.csproj\", \"{BC6D3323-B70E-49A1-9360-0E09D8C2851B}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePipe.Redis\", \"src\\MessagePipe.Redis\\MessagePipe.Redis.csproj\", \"{F8F7655B-50D0-4487-93BD-66F3BD7FB736}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePipe.Benchmark\", \"tests\\MessagePipe.Benchmark\\MessagePipe.Benchmark.csproj\", \"{1DD3A001-BB03-4192-892C-92B298E79E68}\"\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"tools\", \"tools\", \"{7946AB0F-638C-4D40-BB01-1EC790B0E921}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"PostBuildUtility\", \"tools\\PostBuildUtility\\PostBuildUtility.csproj\", \"{7C720CA5-C5F6-4B23-B4DD-4E98FF22111F}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePipe.Redis.Tests\", \"tests\\MessagePipe.Redis.Tests\\MessagePipe.Redis.Tests.csproj\", \"{0C4DDD4B-8DCE-48EB-B309-39132313C3AB}\"\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"_items\", \"_items\", \"{33ADB827-BA73-4B6A-AA57-13C74AB9183D}\"\n\tProjectSection(SolutionItems) = preProject\n\t\t.dockerignore = .dockerignore\n\t\t.gitignore = .gitignore\n\t\tdocker-compose.yml = docker-compose.yml\n\t\tREADME.md = README.md\n\tEndProjectSection\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \".github\", \".github\", \"{71072B57-914A-4CA8-915A-64E832DA6E1F}\"\n\tProjectSection(SolutionItems) = preProject\n\t\t.github\\workflows\\build-debug.yml = .github\\workflows\\build-debug.yml\n\tEndProjectSection\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePipe.Analyzer\", \"src\\MessagePipe.Analyzer\\MessagePipe.Analyzer.csproj\", \"{CB2E0099-5D84-4E14-9699-3AF5B9237DF4}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePipe.AnalyzerTestApp\", \"sandbox\\MessagePipe.AnalyzerTestApp\\MessagePipe.AnalyzerTestApp.csproj\", \"{3F0CF7FC-D764-40C0-BA3A-0302DB2F205F}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePipe.Analyzer.Tests\", \"tests\\MessagePipe.Analyzer.Tests\\MessagePipe.Analyzer.Tests.csproj\", \"{64A0C890-301B-49D9-95C8-8CAFB53DCFDC}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePipe.Interprocess\", \"src\\MessagePipe.Interprocess\\MessagePipe.Interprocess.csproj\", \"{10E626FF-DE92-4784-A9EB-F5A6BE26D1D3}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePipe.Interprocess.Tests\", \"tests\\MessagePipe.Interprocess.Tests\\MessagePipe.Interprocess.Tests.csproj\", \"{3B2C3908-E9EB-43F3-9340-3CF5EFBA2F09}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"InterprocessServer\", \"sandbox\\InterprocessServer\\InterprocessServer.csproj\", \"{0E645BF9-3464-4856-A624-FEFCF0050220}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePipe.Interprocess.Benchmark\", \"tests\\MessagePipe.Interprocess.Benchmark\\MessagePipe.Interprocess.Benchmark.csproj\", \"{AF421C72-0DDA-4568-BD7E-B3CE90B3B31C}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"MessagePipe.Nats\", \"src\\MessagePipe.Nats\\MessagePipe.Nats.csproj\", \"{80D9A03B-CDF0-4D52-BF07-2C198707E65C}\"\nEndProject\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"MessagePipe.Nats.Tests\", \"tests\\MessagePipe.Nats.Tests\\MessagePipe.Nats.Tests.csproj\", \"{8BE1C4C7-9584-4F87-9773-6E7A3B3C71E2}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|Any CPU = Debug|Any CPU\n\t\tRelease|Any CPU = Release|Any CPU\n\t\tWinBenchmark|Any CPU = WinBenchmark|Any CPU\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{D94EF9D4-3CC2-4420-8D0B-25957E7C5309}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{D94EF9D4-3CC2-4420-8D0B-25957E7C5309}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{D94EF9D4-3CC2-4420-8D0B-25957E7C5309}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{D94EF9D4-3CC2-4420-8D0B-25957E7C5309}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{D94EF9D4-3CC2-4420-8D0B-25957E7C5309}.WinBenchmark|Any CPU.ActiveCfg = WinBenchmark|Any CPU\n\t\t{D94EF9D4-3CC2-4420-8D0B-25957E7C5309}.WinBenchmark|Any CPU.Build.0 = WinBenchmark|Any CPU\n\t\t{BEFA1E77-266B-4F35-8892-935729D4A07F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{BEFA1E77-266B-4F35-8892-935729D4A07F}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{BEFA1E77-266B-4F35-8892-935729D4A07F}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{BEFA1E77-266B-4F35-8892-935729D4A07F}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{BEFA1E77-266B-4F35-8892-935729D4A07F}.WinBenchmark|Any CPU.ActiveCfg = WinBenchmark|Any CPU\n\t\t{BEFA1E77-266B-4F35-8892-935729D4A07F}.WinBenchmark|Any CPU.Build.0 = WinBenchmark|Any CPU\n\t\t{BC6D3323-B70E-49A1-9360-0E09D8C2851B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{BC6D3323-B70E-49A1-9360-0E09D8C2851B}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{BC6D3323-B70E-49A1-9360-0E09D8C2851B}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{BC6D3323-B70E-49A1-9360-0E09D8C2851B}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{BC6D3323-B70E-49A1-9360-0E09D8C2851B}.WinBenchmark|Any CPU.ActiveCfg = WinBenchmark|Any CPU\n\t\t{BC6D3323-B70E-49A1-9360-0E09D8C2851B}.WinBenchmark|Any CPU.Build.0 = WinBenchmark|Any CPU\n\t\t{F8F7655B-50D0-4487-93BD-66F3BD7FB736}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{F8F7655B-50D0-4487-93BD-66F3BD7FB736}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{F8F7655B-50D0-4487-93BD-66F3BD7FB736}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{F8F7655B-50D0-4487-93BD-66F3BD7FB736}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{F8F7655B-50D0-4487-93BD-66F3BD7FB736}.WinBenchmark|Any CPU.ActiveCfg = WinBenchmark|Any CPU\n\t\t{F8F7655B-50D0-4487-93BD-66F3BD7FB736}.WinBenchmark|Any CPU.Build.0 = WinBenchmark|Any CPU\n\t\t{1DD3A001-BB03-4192-892C-92B298E79E68}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{1DD3A001-BB03-4192-892C-92B298E79E68}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{1DD3A001-BB03-4192-892C-92B298E79E68}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{1DD3A001-BB03-4192-892C-92B298E79E68}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{1DD3A001-BB03-4192-892C-92B298E79E68}.WinBenchmark|Any CPU.ActiveCfg = WinBenchmark|Any CPU\n\t\t{1DD3A001-BB03-4192-892C-92B298E79E68}.WinBenchmark|Any CPU.Build.0 = WinBenchmark|Any CPU\n\t\t{7C720CA5-C5F6-4B23-B4DD-4E98FF22111F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{7C720CA5-C5F6-4B23-B4DD-4E98FF22111F}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{7C720CA5-C5F6-4B23-B4DD-4E98FF22111F}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{7C720CA5-C5F6-4B23-B4DD-4E98FF22111F}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{7C720CA5-C5F6-4B23-B4DD-4E98FF22111F}.WinBenchmark|Any CPU.ActiveCfg = WinBenchmark|Any CPU\n\t\t{7C720CA5-C5F6-4B23-B4DD-4E98FF22111F}.WinBenchmark|Any CPU.Build.0 = WinBenchmark|Any CPU\n\t\t{0C4DDD4B-8DCE-48EB-B309-39132313C3AB}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{0C4DDD4B-8DCE-48EB-B309-39132313C3AB}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{0C4DDD4B-8DCE-48EB-B309-39132313C3AB}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{0C4DDD4B-8DCE-48EB-B309-39132313C3AB}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{0C4DDD4B-8DCE-48EB-B309-39132313C3AB}.WinBenchmark|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{0C4DDD4B-8DCE-48EB-B309-39132313C3AB}.WinBenchmark|Any CPU.Build.0 = Debug|Any CPU\n\t\t{CB2E0099-5D84-4E14-9699-3AF5B9237DF4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{CB2E0099-5D84-4E14-9699-3AF5B9237DF4}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{CB2E0099-5D84-4E14-9699-3AF5B9237DF4}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{CB2E0099-5D84-4E14-9699-3AF5B9237DF4}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{CB2E0099-5D84-4E14-9699-3AF5B9237DF4}.WinBenchmark|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{CB2E0099-5D84-4E14-9699-3AF5B9237DF4}.WinBenchmark|Any CPU.Build.0 = Debug|Any CPU\n\t\t{3F0CF7FC-D764-40C0-BA3A-0302DB2F205F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{3F0CF7FC-D764-40C0-BA3A-0302DB2F205F}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{3F0CF7FC-D764-40C0-BA3A-0302DB2F205F}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{3F0CF7FC-D764-40C0-BA3A-0302DB2F205F}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{3F0CF7FC-D764-40C0-BA3A-0302DB2F205F}.WinBenchmark|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{3F0CF7FC-D764-40C0-BA3A-0302DB2F205F}.WinBenchmark|Any CPU.Build.0 = Debug|Any CPU\n\t\t{64A0C890-301B-49D9-95C8-8CAFB53DCFDC}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{64A0C890-301B-49D9-95C8-8CAFB53DCFDC}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{64A0C890-301B-49D9-95C8-8CAFB53DCFDC}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{64A0C890-301B-49D9-95C8-8CAFB53DCFDC}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{64A0C890-301B-49D9-95C8-8CAFB53DCFDC}.WinBenchmark|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{64A0C890-301B-49D9-95C8-8CAFB53DCFDC}.WinBenchmark|Any CPU.Build.0 = Debug|Any CPU\n\t\t{10E626FF-DE92-4784-A9EB-F5A6BE26D1D3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{10E626FF-DE92-4784-A9EB-F5A6BE26D1D3}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{10E626FF-DE92-4784-A9EB-F5A6BE26D1D3}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{10E626FF-DE92-4784-A9EB-F5A6BE26D1D3}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{10E626FF-DE92-4784-A9EB-F5A6BE26D1D3}.WinBenchmark|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{10E626FF-DE92-4784-A9EB-F5A6BE26D1D3}.WinBenchmark|Any CPU.Build.0 = Debug|Any CPU\n\t\t{3B2C3908-E9EB-43F3-9340-3CF5EFBA2F09}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{3B2C3908-E9EB-43F3-9340-3CF5EFBA2F09}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{3B2C3908-E9EB-43F3-9340-3CF5EFBA2F09}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{3B2C3908-E9EB-43F3-9340-3CF5EFBA2F09}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{3B2C3908-E9EB-43F3-9340-3CF5EFBA2F09}.WinBenchmark|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{3B2C3908-E9EB-43F3-9340-3CF5EFBA2F09}.WinBenchmark|Any CPU.Build.0 = Debug|Any CPU\n\t\t{0E645BF9-3464-4856-A624-FEFCF0050220}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{0E645BF9-3464-4856-A624-FEFCF0050220}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{0E645BF9-3464-4856-A624-FEFCF0050220}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{0E645BF9-3464-4856-A624-FEFCF0050220}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{0E645BF9-3464-4856-A624-FEFCF0050220}.WinBenchmark|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{0E645BF9-3464-4856-A624-FEFCF0050220}.WinBenchmark|Any CPU.Build.0 = Debug|Any CPU\n\t\t{AF421C72-0DDA-4568-BD7E-B3CE90B3B31C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{AF421C72-0DDA-4568-BD7E-B3CE90B3B31C}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{AF421C72-0DDA-4568-BD7E-B3CE90B3B31C}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{AF421C72-0DDA-4568-BD7E-B3CE90B3B31C}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{AF421C72-0DDA-4568-BD7E-B3CE90B3B31C}.WinBenchmark|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{AF421C72-0DDA-4568-BD7E-B3CE90B3B31C}.WinBenchmark|Any CPU.Build.0 = Debug|Any CPU\n\t\t{80D9A03B-CDF0-4D52-BF07-2C198707E65C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{80D9A03B-CDF0-4D52-BF07-2C198707E65C}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{80D9A03B-CDF0-4D52-BF07-2C198707E65C}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{80D9A03B-CDF0-4D52-BF07-2C198707E65C}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{80D9A03B-CDF0-4D52-BF07-2C198707E65C}.WinBenchmark|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{80D9A03B-CDF0-4D52-BF07-2C198707E65C}.WinBenchmark|Any CPU.Build.0 = Debug|Any CPU\n\t\t{8BE1C4C7-9584-4F87-9773-6E7A3B3C71E2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{8BE1C4C7-9584-4F87-9773-6E7A3B3C71E2}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{8BE1C4C7-9584-4F87-9773-6E7A3B3C71E2}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{8BE1C4C7-9584-4F87-9773-6E7A3B3C71E2}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{8BE1C4C7-9584-4F87-9773-6E7A3B3C71E2}.WinBenchmark|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{8BE1C4C7-9584-4F87-9773-6E7A3B3C71E2}.WinBenchmark|Any CPU.Build.0 = Debug|Any CPU\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(NestedProjects) = preSolution\n\t\t{D94EF9D4-3CC2-4420-8D0B-25957E7C5309} = {381F6F79-110B-4CE4-9A49-583046D8C164}\n\t\t{BEFA1E77-266B-4F35-8892-935729D4A07F} = {9813BFC3-7860-4697-A3AF-118BDF710BD0}\n\t\t{BC6D3323-B70E-49A1-9360-0E09D8C2851B} = {36546FD6-866F-4809-AFCE-87F7F4201361}\n\t\t{F8F7655B-50D0-4487-93BD-66F3BD7FB736} = {381F6F79-110B-4CE4-9A49-583046D8C164}\n\t\t{1DD3A001-BB03-4192-892C-92B298E79E68} = {36546FD6-866F-4809-AFCE-87F7F4201361}\n\t\t{7C720CA5-C5F6-4B23-B4DD-4E98FF22111F} = {7946AB0F-638C-4D40-BB01-1EC790B0E921}\n\t\t{0C4DDD4B-8DCE-48EB-B309-39132313C3AB} = {36546FD6-866F-4809-AFCE-87F7F4201361}\n\t\t{71072B57-914A-4CA8-915A-64E832DA6E1F} = {33ADB827-BA73-4B6A-AA57-13C74AB9183D}\n\t\t{CB2E0099-5D84-4E14-9699-3AF5B9237DF4} = {381F6F79-110B-4CE4-9A49-583046D8C164}\n\t\t{3F0CF7FC-D764-40C0-BA3A-0302DB2F205F} = {9813BFC3-7860-4697-A3AF-118BDF710BD0}\n\t\t{64A0C890-301B-49D9-95C8-8CAFB53DCFDC} = {36546FD6-866F-4809-AFCE-87F7F4201361}\n\t\t{10E626FF-DE92-4784-A9EB-F5A6BE26D1D3} = {381F6F79-110B-4CE4-9A49-583046D8C164}\n\t\t{3B2C3908-E9EB-43F3-9340-3CF5EFBA2F09} = {36546FD6-866F-4809-AFCE-87F7F4201361}\n\t\t{0E645BF9-3464-4856-A624-FEFCF0050220} = {9813BFC3-7860-4697-A3AF-118BDF710BD0}\n\t\t{AF421C72-0DDA-4568-BD7E-B3CE90B3B31C} = {36546FD6-866F-4809-AFCE-87F7F4201361}\n\t\t{80D9A03B-CDF0-4D52-BF07-2C198707E65C} = {381F6F79-110B-4CE4-9A49-583046D8C164}\n\t\t{8BE1C4C7-9584-4F87-9773-6E7A3B3C71E2} = {36546FD6-866F-4809-AFCE-87F7F4201361}\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {138B7AA8-E4C0-46A3-A48B-0D373CAC365D}\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "MessagePipe.sln.startup.json",
          "type": "blob",
          "size": 1.9267578125,
          "content": "/*\n    This is a configuration file for the SwitchStartupProject Visual Studio Extension\n    See https://heptapod.host/thirteen/switchstartupproject/blob/branch/current/Configuration.md\n*/\n{\n    /*  Configuration File Version  */\n    \"Version\": 3,\n\n    /*  Create an item in the dropdown list for each project in the solution?  */\n    \"ListAllProjects\": true\n\n    /*\n        Dictionary of named configurations with one or multiple startup projects\n        and optional parameters like command line arguments and working directory.\n        Example:\n\n        \"MultiProjectConfigurations\": {\n          \"A + B (Ext)\": {\n            \"Projects\": {\n              \"MyProjectA\": {},\n              \"MyProjectB\": {\n                \"CommandLineArguments\": \"1234\",\n                \"WorkingDirectory\": \"%USERPROFILE%\\\\test\",\n                \"StartExternalProgram\": \"c:\\\\myprogram.exe\"\n              }\n            }\n          },\n          \"A + B\": {\n            \"Projects\": {\n              \"MyProjectA\": {},\n              \"MyProjectB\": {\n                \"CommandLineArguments\": \"\",\n                \"WorkingDirectory\": \"\",\n                \"StartProject\": true\n              }\n            }\n          },\n          \"D (Debug x86)\": {\n            \"Projects\": {\n              \"MyProjectD\": {}\n            },\n            \"SolutionConfiguration\": \"Debug\",\n            \"SolutionPlatform\": \"x86\",\n          },\n          \"D (Release x64)\": {\n            \"Projects\": {\n              \"MyProjectD\": {}\n            },\n            \"SolutionConfiguration\": \"Release\",\n            \"SolutionPlatform\": \"x64\",\n          }\n        }\n    */\n    //\"MultiProjectConfigurations\": {\n    //    \"Interprocess\": {\n    //        \"Projects\": {\n    //            [\"InterprocessServer\": {\n    //                \"CommandLineArguments\": \"SERVER\"\n    //            },\n    //            \"InterprocessServer\": {\n    //                \"CommandLineArguments\": \"CLIENT\"\n    //            }\n    //        }\n    //    }\n    //}\n}\n"
        },
        {
          "name": "NuGet.config",
          "type": "blob",
          "size": 0.3837890625,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<configuration>\n  <packageSources>\n    <clear />\n    <add key=\"nuget.org\" value=\"https://api.nuget.org/v3/index.json\" />\n    <add key=\"dotnet-tools\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json\" />\n  </packageSources>\n  <disabledPackageSources>\n    <clear />\n  </disabledPackageSources>\n</configuration>\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 48.5810546875,
          "content": "# MessagePipe\n[![GitHub Actions](https://github.com/Cysharp/MessagePipe/workflows/Build-Debug/badge.svg)](https://github.com/Cysharp/MessagePipe/actions) [![Releases](https://img.shields.io/github/release/Cysharp/MessagePipe.svg)](https://github.com/Cysharp/MessagePipe/releases)\n\nMessagePipe is a high-performance in-memory/distributed messaging pipeline for .NET and Unity. It supports all cases of Pub/Sub usage, mediator pattern for CQRS, EventAggregator of Prism(V-VM decoupling), IPC(Interprocess Communication)-RPC, etc.\n\n* Dependency-injection first\n* Filter pipeline\n* better event\n* sync/async\n* keyed/keyless\n* buffered/bufferless\n* singleton/scoped\n* broadcast/response(+many)\n* in-memory/interprocess/distributed\n\nMessagePipe is faster than standard C# event and 78 times faster than Prism's EventAggregator.\n\n![](https://user-images.githubusercontent.com/46207/115984507-5d36da80-a5e2-11eb-9942-66602906f499.png)\n\nOf course, memory allocation per publish operation is less(zero).\n\n![](https://user-images.githubusercontent.com/46207/115814615-62542800-a430-11eb-9041-1f31c1ac8464.png)\n\nAlso providing roslyn-analyzer to prevent subscription leak.\n\n![](https://user-images.githubusercontent.com/46207/117535259-da753d00-b02f-11eb-9818-0ab5ef3049b1.png)\n\nGetting Started\n---\nFor .NET, use NuGet. For Unity, please read [Unity](#unity) section.\n\n> PM> Install-Package [MessagePipe](https://www.nuget.org/packages/MessagePipe)\n\nMessagePipe is built on top of a `Microsoft.Extensions.DependencyInjection`(for Unity, `VContainer` or `Zenject` or `Builtin Tiny DI`) so set up via `ConfigureServices` in [.NET Generic Host](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host). Generic Host is widely used in .NET such as ASP.NET Core, [MagicOnion](https://github.com/Cysharp/MagicOnion/), [ConsoleAppFramework](https://github.com/Cysharp/ConsoleAppFramework/), MAUI, WPF(with external support), etc so easy to setup.\n\n```csharp\nusing MessagePipe;\nusing Microsoft.Extensions.DependencyInjection;\n\nHost.CreateDefaultBuilder()\n    .ConfigureServices((ctx, services) =>\n    {\n        services.AddMessagePipe(); // AddMessagePipe(options => { }) for configure options\n    })\n```\n\nGet the `IPublisher<T>` for publisher, Get the `ISubscribe<T>` for subscriber, like a `Logger<T>`. `T` can be any type, primitive(int, string, etc...), struct, class, enum, etc.\n\n```csharp\nusing MessagePipe;\n\npublic struct MyEvent { }\n\npublic class SceneA\n{\n    readonly IPublisher<MyEvent> publisher;\n    \n    public SceneA(IPublisher<MyEvent> publisher)\n    {\n        this.publisher = publisher;\n    }\n\n    void Send()\n    {\n        this.publisher.Publish(new MyEvent());\n    }\n}\n\npublic class SceneB\n{\n    readonly ISubscriber<MyEvent> subscriber;\n    readonly IDisposable disposable;\n\n    public SceneB(ISubscriber<MyEvent> subscriber)\n    {\n        var bag = DisposableBag.CreateBuilder(); // composite disposable for manage subscription\n        \n        subscriber.Subscribe(x => Console.WriteLine(\"here\")).AddTo(bag);\n\n        disposable = bag.Build();\n    }\n\n    void Close()\n    {\n        disposable.Dispose(); // unsubscribe event, all subscription **must** Dispose when completed\n    }\n}\n```\n\nIt is similar to event, but decoupled by type as key. The return value of Subscribe is `IDisposable`, which makes it easier to unsubscribe than event. You can release many subscriptions at once by `DisposableBag`(`CompositeDisposable`). See the [Managing Subscription and Diagnostics](#managing-subscription-and-diagnostics) section for more details.\n\nThe publisher/subscriber(internally we called MessageBroker) is managed by DI, it is possible to have different broker for each scope. Also, all subscriptions are unsubscribed when the scope is disposed, which prevents subscription leaks.\n\n> Default is singleton, you can configure `MessagePipeOptions.InstanceLifetime` to `Singleton` or `Scoped`.\n\n`IPublisher<T>/ISubscriber<T>` is keyless(type only) however MessagePipe has similar interface `IPublisher<TKey, TMessage>/ISubscriber<TKey, TMessage>` that is keyed(topic) interface.\n\nFor example, our real usecase, There is an application that connects Unity and [MagicOnion](https://github.com/Cysharp/MagicOnion/) (a real-time communication framework like SignalR) and delivers it via a browser by Blazor. At that time, we needed something to connect Blazor's page (Browser lifecycle) and MagicOnion's Hub (Connection lifecycle) to transmit data. We also need to distribute the connections by their IDs.\n\n`Browser <-> Blazor <- [MessagePipe] -> MagicOnion <-> Unity`\n\nWe solved this with the following code.\n\n```csharp\n// MagicOnion(similar as SignalR, realtime event framework for .NET and Unity)\npublic class UnityConnectionHub : StreamingHubBase<IUnityConnectionHub, IUnityConnectionHubReceiver>, IUnityConnectionHub\n{\n    readonly IPublisher<Guid, UnitEventData> eventPublisher;\n    readonly IPublisher<Guid, ConnectionClose> closePublisher;\n    Guid id;\n\n    public UnityConnectionHub(IPublisher<Guid, UnitEventData> eventPublisher, IPublisher<Guid, ConnectionClose> closePublisher)\n    {\n        this.eventPublisher = eventPublisher;\n        this.closePublisher = closePublisher;\n    }\n\n    override async ValueTask OnConnected()\n    {\n        this.id = Guid.Parse(Context.Headers[\"id\"]);\n    }\n\n    override async ValueTask OnDisconnected()\n    {\n        this.closePublisher.Publish(id, new ConnectionClose()); // publish to browser(Blazor)\n    }\n\n    // called from Client(Unity)\n    public Task<UnityEventData> SendEventAsync(UnityEventData data)\n    {\n        this.eventPublisher.Publish(id, data); // publish to browser(Blazor)\n    }\n}\n\n// Blazor\npublic partial class BlazorPage : ComponentBase, IDisposable\n{\n    [Parameter]\n    public Guid ID { get; set; }\n\n    [Inject]\n    ISubscriber<Guid, UnitEventData> UnityEventSubscriber { get; set; }\n\n    [Inject]\n    ISubscriber<Guid, ConnectionClose> ConnectionCloseSubscriber { get; set; }\n\n    IDisposable subscription;\n\n    protected override void OnInitialized()\n    {\n        // receive event from MagicOnion(that is from Unity)\n        var d1 = UnityEventSubscriber.Subscribe(ID, x =>\n        {\n            // do anything...\n        });\n\n        var d2 = ConnectionCloseSubscriber.Subscribe(ID, _ =>\n        {\n            // show disconnected thing to view...\n            subscription?.Dispose(); // and unsubscribe events.\n        });\n\n        subscription = DisposableBag.Create(d1, d2); // combine disposable.\n    }\n    \n    public void Dispose()\n    {\n        // unsubscribe event when browser is closed.\n        subscription?.Dispose();\n    }\n}\n```\n\n> The main difference of Reactive Extensions' Subject is has no `OnCompleted`. OnCompleted may or may not be used, making it very difficult to determine the intent to the observer(subscriber). Also, we usually subscribe to multiple events from the same (different event type)publisher, and it is difficult to handle duplicate OnCompleted in that case. For this reason, MessagePipe only provides a simple Publish(OnNext). If you want to convey completion, please receive a separate event and perform dedicated processing there.\n\n> In other words, this is the equivalent of [Relay in RxSwift](https://github.com/ReactiveX/RxSwift/blob/main/Documentation/Subjects.md).\n\nIn addition to standard Pub/Sub, MessagePipe supports async handlers, mediator patterns with handlers that accept return values, and filters for pre-and-post execution customization.\n\nThis image is a visualization of the connection between all those interfaces.\n\n![image](https://user-images.githubusercontent.com/46207/122254092-bf87c980-cf07-11eb-8bdd-039c87309db6.png)\n\nYou may be confused by the number of interfaces, but many functions can be written with a similar, unified API.\n\nPublish/Subscribe\n---\nPublish/Subscribe interface has keyed(topic) and keyless, sync and async interface.\n\n```csharp\n// keyless-sync\npublic interface IPublisher<TMessage>\n{\n    void Publish(TMessage message);\n}\n\npublic interface ISubscriber<TMessage>\n{\n    IDisposable Subscribe(IMessageHandler<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters);\n}\n\n// keyless-async\npublic interface IAsyncPublisher<TMessage>\n{\n    // async interface's publish is fire-and-forget\n    void Publish(TMessage message, CancellationToken cancellationToken = default(CancellationToken));\n    ValueTask PublishAsync(TMessage message, CancellationToken cancellationToken = default(CancellationToken));\n    ValueTask PublishAsync(TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken = default(CancellationToken));\n}\n\npublic interface IAsyncSubscriber<TMessage>\n{\n    IDisposable Subscribe(IAsyncMessageHandler<TMessage> asyncHandler, params AsyncMessageHandlerFilter<TMessage>[] filters);\n}\n\n// keyed-sync\npublic interface IPublisher<TKey, TMessage>\n    where TKey : notnull\n{\n    void Publish(TKey key, TMessage message);\n}\n\npublic interface ISubscriber<TKey, TMessage>\n    where TKey : notnull\n{\n    IDisposable Subscribe(TKey key, IMessageHandler<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters);\n}\n\n// keyed-async\npublic interface IAsyncPublisher<TKey, TMessage>\n    where TKey : notnull\n{\n    void Publish(TKey key, TMessage message, CancellationToken cancellationToken = default(CancellationToken));\n    ValueTask PublishAsync(TKey key, TMessage message, CancellationToken cancellationToken = default(CancellationToken));\n    ValueTask PublishAsync(TKey key, TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken = default(CancellationToken));\n}\n\npublic interface IAsyncSubscriber<TKey, TMessage>\n    where TKey : notnull\n{\n    IDisposable Subscribe(TKey key, IAsyncMessageHandler<TMessage> asyncHandler, params AsyncMessageHandlerFilter<TMessage>[] filters);\n}\n```\n\nAll are available in the form of `IPublisher/Subscribe<T>` in the DI. async handler can await all subscribers completed by `await PublishAsync`. Asynchronous methods can work sequentially or in parallel, depending on `AsyncPublishStrategy` (defaults is `Parallel`, can be changed by `MessagePipeOptions` or by specifying at publish time). If you don't need to wait, you can call `void Publish` to act as fire-and-forget.\n\nThe before and after of execution can be changed by passing a custom filter. See the [Filter](#filter) section for details.\n\nIf an error occurs, it will be propagated to the caller and subsequent subscribers will be stopped. This behavior can be changed by writing a filter to ignore errors.\n\nISingleton***, IScoped***\n---\nI(Async)Publisher(Subscriber)'s lifetime belongs to `MessagePipeOptions.InstanceLifetime`. However if declare with `ISingletonPublisher<TMessage>`/`ISingletonSubscriber<TKey, TMessage>`, `ISingletonAsyncPublisher<TMessage>`/`ISingletonAsyncSubscriber<TKey, TMessage>` then used singleton lifetime. Also `IScopedPublisher<TMessage>`/`IScopedSubscriber<TKey, TMessage>`, `IScopedAsyncPublisher<TMessage>`/`IScopedAsyncSubscriber<TKey, TMessage>` uses scoped lifetime.\n\nBuffered\n---\n`IBufferedPublisher<TMessage>/IBufferedSubscriber<TMessage>` pair is similar as `BehaviorSubject` or Reactive Extensions(More equal is RxSwift's `BehaviorRelay`). It returns latest value on `Subscribe`.\n\n```csharp\nvar p = provider.GetRequiredService<IBufferedPublisher<int>>();\nvar s = provider.GetRequiredService<IBufferedSubscriber<int>>();\n\np.Publish(999);\n\nvar d1 = s.Subscribe(x => Console.WriteLine(x)); // 999\np.Publish(1000); // 1000\n\nvar d2 = s.Subscribe(x => Console.WriteLine(x)); // 1000\np.Publish(9999); // 9999, 9999\n\nDisposableBag.Create(d1, d2).Dispose();\n```\n\n> If `TMessage` is class and does not have latest value(null), does not send value on Subscribe.\n\n> Keyed buffered publisher/subscriber does not exist because difficult to avoid memory leak of (unused)key and keep latest value.\n\nEventFactory\n---\nUsing `EventFactory`, you can create generic `IPublisher/ISubscriber`, `IAsyncPublisher/IAsyncSubscriber`, `IBufferedPublisher/IBufferedSubscriber`, `IBufferedAsyncPublisher/IBufferedAsyncSubscriber` like C# events, with a Subscriber tied to each instance, not grouped by type.\n\nMessagePipe has better properties than a normal C# event\n\n* Using Subscribe/Dispose instead of `+=`, `-=` , easy to management subscription\n* Both sync and async support\n* Both bufferless and buffered support\n* Enable unsubscribe all subscription from publisher.dispose\n* Attaches invocation pipeline behaviour by Filter\n* To monitor subscription leak by `MessagePipeDiagnosticsInfo`\n* TO prevent subscription leak by `MessagePipe.Analyzer`\n\n```csharp\npublic class BetterEvent : IDisposable\n{\n    // using MessagePipe instead of C# event/Rx.Subject\n    // store Publisher to private field(declare IDisposablePublisher/IDisposableAsyncPublisher)\n    IDisposablePublisher<int> tickPublisher;\n\n    // Subscriber is used from outside so public property\n    public ISubscriber<int> OnTick { get; }\n\n    public BetterEvent(EventFactory eventFactory)\n    {\n        // CreateEvent can deconstruct by tuple and set together\n        (tickPublisher, OnTick) = eventFactory.CreateEvent<int>();\n\n        // also create async event(IAsyncSubscriber) by `CreateAsyncEvent`\n        // eventFactory.CreateAsyncEvent\n    }\n\n    int count;\n    void Tick()\n    {\n        tickPublisher.Publish(count++);\n    }\n\n    public void Dispose()\n    {\n        // You can unsubscribe all from Publisher.\n        tickPublisher.Dispose();\n    }\n}\n```\n\nIf you want to create event outside of DI, see [Global Provider](#global-provider) section.\n\n```csharp\nIDisposablePublisher<int> tickPublisher;\npublic ISubscriber<int> OnTick { get; }\n\nctor()\n{\n    (tickPublisher, OnTick) = GlobalMessagePipe.CreateEvent<int>();\n}\n```\n\nRequest/Response/All\n---\nSimilar as [MediatR](https://github.com/jbogard/MediatR), implement support of mediator pattern.\n\n```csharp\npublic interface IRequestHandler<in TRequest, out TResponse>\n{\n    TResponse Invoke(TRequest request);\n}\n\npublic interface IAsyncRequestHandler<in TRequest, TResponse>\n{\n    ValueTask<TResponse> InvokeAsync(TRequest request, CancellationToken cancellationToken = default);\n}\n```\n\nFor example, declare handler for Ping type.\n\n```csharp\npublic readonly struct Ping { }\npublic readonly struct Pong { }\n\npublic class PingPongHandler : IRequestHandler<Ping, Pong>\n{\n    public Pong Invoke(Ping request)\n    {\n        Console.WriteLine(\"Ping called.\");\n        return new Pong();\n    }\n}\n```\n\nYou can get handler like this.\n\n```csharp\nclass FooController\n{\n    IRequestHandler<Ping, Pong> requestHandler;\n\n    // automatically instantiate PingPongHandler.\n    public FooController(IRequestHandler<Ping, Pong> requestHandler)\n    {\n        this.requestHandler = requestHandler;\n    }\n\n    public void Run()\n    {\n        var pong = this.requestHandler.Invoke(new Ping());\n        Console.WriteLine(\"PONG\");\n    }\n}\n```\n\nFor more complex implementation patterns, [this Microsoft documentation](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/microservice-application-layer-implementation-web-api#implement-the-command-process-pipeline-with-a-mediator-pattern-mediatr) is applicable.\n\nDeclare many request handlers, you can use `IRequestAllHandler`, `IAsyncRequestAllHandler` instead of single handler.\n\n```csharp\npublic interface IRequestAllHandler<in TRequest, out TResponse>\n{\n    TResponse[] InvokeAll(TRequest request);\n    IEnumerable<TResponse> InvokeAllLazy(TRequest request);\n}\n\npublic interface IAsyncRequestAllHandler<in TRequest, TResponse>\n{\n    ValueTask<TResponse[]> InvokeAllAsync(TRequest request, CancellationToken cancellationToken = default);\n    ValueTask<TResponse[]> InvokeAllAsync(TRequest request, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken = default);\n    IAsyncEnumerable<TResponse> InvokeAllLazyAsync(TRequest request, CancellationToken cancellationToken = default);\n}\n```\n\n```csharp\npublic class PingPongHandler1 : IRequestHandler<Ping, Pong>\n{\n    public Pong Invoke(Ping request)\n    {\n        Console.WriteLine(\"Ping1 called.\");\n        return new Pong();\n    }\n}\n\npublic class PingPongHandler2 : IRequestHandler<Ping, Pong>\n{\n    public Pong Invoke(Ping request)\n    {\n        Console.WriteLine(\"Ping1 called.\");\n        return new Pong();\n    }\n}\n\nclass BarController\n{\n    IRequestAllHandler<Ping, Pong> requestAllHandler;\n\n    public FooController(IRequestAllHandler<Ping, Pong> requestAllHandler)\n    {\n        this.requestAllHandler = requestAllHandler;\n    }\n\n    public void Run()\n    {\n        var pongs = this.requestAllHandler.InvokeAll(new Ping());\n        Console.WriteLine(\"PONG COUNT:\" + pongs.Length);\n    }\n}\n```\n\nSubscribe Extensions\n---\n`ISubscriber`(`IAsyncSubscriber`) interface requires `IMessageHandler<T>` to handle message.\n\n```csharp\npublic interface ISubscriber<TMessage>\n{\n    IDisposable Subscribe(IMessageHandler<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters);\n}\n```\n\nHowever, the extension method allows you to write `Action<T>` directly.\n\n```csharp\npublic static IDisposable Subscribe<TMessage>(this ISubscriber<TMessage> subscriber, Action<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters)\npublic static IDisposable Subscribe<TMessage>(this ISubscriber<TMessage> subscriber, Action<TMessage> handler, Func<TMessage, bool> predicate, params MessageHandlerFilter<TMessage>[] filters)\npublic static IObservable<TMessage> AsObservable<TMessage>(this ISubscriber<TMessage> subscriber, params MessageHandlerFilter<TMessage>[] filters)\npublic static IAsyncEnumerable<TMessage> AsAsyncEnumerable<TMessage>(this IAsyncSubscriber<TMessage> subscriber, params AsyncMessageHandlerFilter<TMessage>[] filters)\npublic static ValueTask<TMessage> FirstAsync<TMessage>(this ISubscriber<TMessage> subscriber, CancellationToken cancellationToken, params MessageHandlerFilter<TMessage>[] filters)\npublic static ValueTask<TMessage> FirstAsync<TMessage>(this ISubscriber<TMessage> subscriber, CancellationToken cancellationToken, Func<TMessage, bool> predicate, params MessageHandlerFilter<TMessage>[] filters)\n```\n\nAlso, the `Func<TMessage, bool>` overload can filter messages by predicate (internally implemented with PredicateFilter, where Order is int.MinValue and is always checked first).\n\n`AsObservable` can convert message pipeline to `IObservable<T>`, it can handle by Reactive Extensions(in Unity, you can use `UniRx`). `AsObservable` exists in sync subscriber(keyless, keyed, buffered).\n\n`AsAsyncEnumerable` can convert message pipeline to `IAsyncEnumerable<T>`, it can handle by async LINQ and async foreach. `AsAsyncEnumerable` exists in async subscriber(keyless, keyed, buffered).\n\n`FirstAsync` gets the first value of message. It is similar as `AsObservable().FirstAsync()`, `AsObservable().Where().FirstAsync()`. If uses `CancellationTokenSource(TimeSpan)` then similar as `AsObservable().Timeout().FirstAsync()`. Argument of `CancellationToken` is required to avoid task leak. \n\n```csharp\n// for Unity, use cts.CancelAfterSlim(TIimeSpan) instead.\nusing var cts = new CancellationTokenSource(TimeSpan.FromSeconds(1));\nvar value = await subscriber.FirstAsync(cts.Token);\n```\n\n`FirstAsync` exists in both sync and async subscriber(keyless, keyed, buffered).\n\nFilter\n---\nFilter system can hook before and after method invocation. It is implemented with the Middleware pattern, which allows you to write synchronous and asynchronous code with similar syntax. MessagePipe provides different filter types - sync (`MessageHandlerFilter<T>`), async (`AsyncMessageHandlerFilter<T>`), request (`RequestHandlerFilter<TReq, TRes>`) and async request (`AsyncRequestHandlerFilter<TReq, TRes>`). To implement other concerete filters the above filter types can be extended.\n\nFilters can be specified in three places - global(by `MessagePipeOptions.AddGlobalFilter`), per handler type, and per subscription. These filters are sorted according to the Order specified in each of them, and are generated when subscribing.\n\nSince the filter is generated on a per subscription basis, the filter can have a state.\n\n```csharp\npublic class ChangedValueFilter<T> : MessageHandlerFilter<T>\n{\n    T lastValue;\n\n    public override void Handle(T message, Action<T> next)\n    {\n        if (EqualityComparer<T>.Default.Equals(message, lastValue))\n        {\n            return;\n        }\n\n        lastValue = message;\n        next(message);\n    }\n}\n\n// uses(per subscribe)\nsubscribe.Subscribe(x => Console.WriteLine(x), new ChangedValueFilter<int>(){ Order = 100 });\n\n// add per handler type(use generics filter, write open generics)\n[MessageHandlerFilter(typeof(ChangedValueFilter<>), 100)]\npublic class WriteLineHandler<T> : IMessageHandler<T>\n{\n    public void Handle(T message) => Console.WriteLine(message);\n}\n\n// add per global\nHost.CreateDefaultBuilder()\n    .ConfigureServices((ctx, services) =>\n    {\n        services.AddMessagePipe(options =>\n        {\n            options.AddGlobalMessageHandlerFilter(typeof(ChangedValueFilter<>), 100);\n        });\n    });\n```\n\nuse the filter by attribute, you can use these attributes: `[MessageHandlerFilter(type, order)]`, `[AsyncMessageHandlerFilter(type, order)]`, `[RequestHandlerFilter(type, order)]`, `[AsyncRequestHandlerFilter(type, order)]`.\n\nThese are idea showcase of filter.\n\n```csharp\npublic class PredicateFilter<T> : MessageHandlerFilter<T>\n{\n    private readonly Func<T, bool> predicate;\n\n    public PredicateFilter(Func<T, bool> predicate)\n    {\n        this.predicate = predicate;\n    }\n\n    public override void Handle(T message, Action<T> next)\n    {\n        if (predicate(message))\n        {\n            next(message);\n        }\n    }\n}\n```\n\n```csharp\npublic class LockFilter<T> : MessageHandlerFilter<T>\n{\n    readonly object gate = new object();\n\n    public override void Handle(T message, Action<T> next)\n    {\n        lock (gate)\n        {\n            next(message);\n        }\n    }\n}\n```\n\n```csharp\npublic class IgnoreErrorFilter<T> : MessageHandlerFilter<T>\n{\n    readonly ILogger<IgnoreErrorFilter<T>> logger;\n\n    public IgnoreErrorFilter(ILogger<IgnoreErrorFilter<T>> logger)\n    {\n        this.logger = logger;\n    }\n\n    public override void Handle(T message, Action<T> next)\n    {\n        try\n        {\n            next(message);\n        }\n        catch (Exception ex)\n        {\n            logger.LogError(ex, \"\"); // error logged, but do not propagate\n        }\n    }\n}\n```\n\n```csharp\npublic class DispatcherFilter<T> : MessageHandlerFilter<T>\n{\n    readonly Dispatcher dispatcher;\n\n    public DispatcherFilter(Dispatcher dispatcher)\n    {\n        this.dispatcher = dispatcher;\n    }\n\n    public override void Handle(T message, Action<T> next)\n    {\n        dispatcher.BeginInvoke(() =>\n        {\n            next(message);\n        });\n    }\n}\n```\n\n```csharp\npublic class DelayRequestFilter : AsyncRequestHandlerFilter<int, int>\n{\n    public override async ValueTask<int> InvokeAsync(int request, CancellationToken cancellationToken, Func<int, CancellationToken, ValueTask<int>> next)\n    {\n        await Task.Delay(TimeSpan.FromSeconds(request));\n        var response = await next(request, cancellationToken);\n        return response;\n    }\n}\n```\n\nManaging Subscription and Diagnostics\n---\nSubscribe returns `IDisposable`; when call `Dispose` then unsubscribe. A better reason than event is that it is easy to Unsubscribe. To manage multiple IDisposable, you can use `CompositeDisposable` in Rx(UniRx) or `DisposableBag` included in MessagePipe.\n\n```csharp\nIDisposable disposable;\n\nvoid OnInitialize(ISubscriber<int> subscriber)\n{\n    var d1 = subscriber.Subscribe(_ => { });\n    var d2 = subscriber.Subscribe(_ => { });\n    var d3 = subscriber.Subscribe(_ => { });\n\n    // static DisposableBag: DisposableBag.Create(1~7(optimized) or N);\n    disposable = DisposableBag.Create(d1, d2, d3);\n}\n\nvoid Close()\n{\n    // dispose all subscription\n    disposable?.Dispose();\n}\n```\n\n```csharp\nIDisposable disposable;\n\nvoid OnInitialize(ISubscriber<int> subscriber)\n{\n    // use builder pattern, you can use subscription.AddTo(bag)\n    var bag = DisposableBag.CreateBuilder();\n\n    subscriber.Subscribe(_ => { }).AddTo(bag);\n    subscriber.Subscribe(_ => { }).AddTo(bag);\n    subscriber.Subscribe(_ => { }).AddTo(bag);\n\n    disposable = bag.Build(); // create final composite IDisposable\n}\n\nvoid Close()\n{\n    // dispose all subscription\n    disposable?.Dispose();\n}\n```\n\n```csharp\nIDisposable disposable;\n\nvoid OnInitialize(ISubscriber<int> subscriber)\n{\n    var bag = DisposableBag.CreateBuilder();\n\n    // calling once(or x count), you can use DisposableBag.CreateSingleAssignment to hold subscription reference.\n    var d = DisposableBag.CreateSingleAssignment();\n    \n    // you can invoke Dispose in handler action.\n    // assign disposable, you can use `SetTo` and `AddTo` bag.\n    // or you can use d.Disposable = subscriber.Subscribe();\n    subscriber.Subscribe(_ => { d.Dispose(); }).SetTo(d).AddTo(bag);\n\n    disposable = bag.Build();\n}\n\nvoid Close()\n{\n    disposable?.Dispose();\n}\n```\n\nThe returned `IDisposable` value **must** be handled. If it is ignored, it will leak. However Weak reference, which is widely used in WPF, is an anti-pattern. All subscriptions should be managed explicitly.\n\nYou can monitor subscription count by `MessagePipeDiagnosticsInfo`. It can get from service provider(or DI).\n\n```csharp\npublic sealed class MessagePipeDiagnosticsInfo\n{\n    /// <summary>Get current subscribed count.</summary>\n    public int SubscribeCount { get; }\n\n    /// <summary>\n    /// When MessagePipeOptions.EnableCaptureStackTrace is enabled, list all stacktrace on subscribe.\n    /// </summary>\n    public StackTraceInfo[] GetCapturedStackTraces(bool ascending = true);\n\n    /// <summary>\n    /// When MessagePipeOptions.EnableCaptureStackTrace is enabled, groped by caller of subscribe.\n    /// </summary>\n    public ILookup<string, StackTraceInfo> GetGroupedByCaller(bool ascending = true)\n}\n```\n\nIf you monitor SubscribeCount, you can check leak of subscription.\n\n```csharp\npublic class MonitorTimer : IDisposable\n{\n    CancellationTokenSource cts = new CancellationTokenSource();\n\n    public MonitorTimer(MessagePipeDiagnosticsInfo diagnosticsInfo)\n    {\n        RunTimer(diagnosticsInfo);\n    }\n\n    async void RunTimer(MessagePipeDiagnosticsInfo diagnosticsInfo)\n    {\n        while (!cts.IsCancellationRequested)\n        {\n            // show SubscribeCount\n            Console.WriteLine(\"SubscribeCount:\" + diagnosticsInfo.SubscribeCount);\n            await Task.Delay(TimeSpan.FromSeconds(5), cts.Token);\n        }\n    }\n\n    public void Dispose()\n    {\n        cts.Cancel();\n    }\n}\n```\n\nAlso, by enabling MessagePipeOptions.EnableCaptureStackTrace (disabled by default), the location of the subscribed location can be displayed, making it easier to find the location of the leak if it exists.\n\nCheck the Count of GroupedByCaller, and if any of them show abnormal values, then the stack trace is where it occurs, and you probably ignore Subscription.\n\nfor Unity, `Window ->  MessagePipe Diagnostics` window is useful for monitoring subscritpion. It visualizes `MessagePipeDianogsticsInfo`.\n\n![image](https://user-images.githubusercontent.com/46207/116953319-e2e41580-acc7-11eb-88c9-a4704bf3e3c9.png)\n\nTo Enable use of the MessagePipeDiagnostics window, require to set up `GlobalMessagePipe`.\n\n```csharp\n// VContainer\npublic class MessagePipeDemo : VContainer.Unity.IStartable\n{\n    public MessagePipeDemo(IObjectResolver resolver)\n    {\n        // require this line.\n        GlobalMessagePipe.SetProvider(resolver.AsServiceProvider());\n    }\n}\n\n// Zenject\nvoid Configure(DiContainer container)\n{\n    GlobalMessagePipe.SetProvider(container.AsServiceProvider());\n}\n\n// builtin\nvar prodiver = builder.BuildServiceProvider();\nGlobalMessagePipe.SetProvider(provider);\n```\n\nAnalyzer\n---\nIn previous section, we anounce `The returned IDisposable value **must** be handled`. To prevent subscription leak, we provide roslyn analyzer.\n\n> PM> Install-Package [MessagePipe.Analyzer](https://www.nuget.org/packages/MessagePipe.Analyzer)\n\n![](https://user-images.githubusercontent.com/46207/117535259-da753d00-b02f-11eb-9818-0ab5ef3049b1.png)\n\nThis will raise an error for unhandled `Subscribe`.\n\nThis analyzer can use after Unity 2020.2(see: [Roslyn analyzers and ruleset files](https://docs.unity3d.com/2020.2/Documentation/Manual/roslyn-analyzers.html) document). `MessagePipe.Analyzer.dll` exists in [releases page](https://github.com/Cysharp/MessagePipe/releases/).\n\n![](https://user-images.githubusercontent.com/46207/117535248-d5b08900-b02f-11eb-8add-33101a71033a.png)\n\nCurrently Unity's analyzer support is incomplete. We are complementing analyzer support with editor extension, please check the [Cysharp/CsprojModifier](https://github.com/Cysharp/CsprojModifier).\n\n![](https://github.com/Cysharp/CsprojModifier/raw/master/docs/images/Screen-01.png)\n\nIDistributedPubSub / MessagePipe.Redis\n---\nFor the distributed(networked) Pub/Sub, you can use `IDistributedPublisher<TKey, TMessage>`, `IDistributedSubscriber<TKey, TMessage>` instead of `IAsyncPublisher`.\n\n```csharp\npublic interface IDistributedPublisher<TKey, TMessage>\n{\n    ValueTask PublishAsync(TKey key, TMessage message, CancellationToken cancellationToken = default);\n}\n\npublic interface IDistributedSubscriber<TKey, TMessage>\n{\n    // and also without filter overload.\n    public ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IMessageHandler<TMessage> handler, MessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default);\n    public ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IAsyncMessageHandler<TMessage> handler, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default);\n}\n```\n\n`IAsyncPublisher` means in-memory Pub/Sub. Since processing over the network is fundamentally different, you need to use a different interface to avoid confusion.\n\nRedis is available as a standard network provider.\n\n> PM> Install-Package [MessagePipe.Redis](https://www.nuget.org/packages/MessagePipe.Redis)\n\nuse `AddMessagePipeRedis` to enable redis provider.\n\n```csharp\nHost.CreateDefaultBuilder()\n    .ConfigureServices((ctx, services) =>\n    {\n        services.AddMessagePipe()\n            .AddRedis(IConnectionMultiplexer | IConnectionMultiplexerFactory, configure);\n    })\n```\n\n`IConnectionMultiplexer` overload, you can pass [StackExchange.Redis](https://github.com/StackExchange/StackExchange.Redis)'s `ConnectionMultiplexer` directly. Implement own `IConnectionMultiplexerFactory` to allow for per-key distribution and use from connection pools.\n\n`MessagePipeRedisOptions`, you can configure serialization.\n\n```csharp\npublic sealed class MessagePipeRedisOptions\n{\n    public IRedisSerializer RedisSerializer { get; set; }\n}\n\npublic interface IRedisSerializer\n{\n    byte[] Serialize<T>(T value);\n    T Deserialize<T>(byte[] value);\n}\n```\n\nIn default uses [MessagePack for C#](https://github.com/neuecc/MessagePack-CSharp)'s `ContractlessStandardResolver`. You can change to use other `MessagePackSerializerOptions` by `new MessagePackRedisSerializer(options)` or implement own serializer wrapper.\n\nMessagePipe has in-memory IDistributedPublisher/Subscriber for local test usage.\n\n```csharp\nHost.CreateDefaultBuilder()\n    .ConfigureServices((ctx, services) =>\n    {\n        var config = ctx.Configuration.Get<MyConfig>();\n\n        var builder = services.AddMessagePipe();\n        if (config.IsLocal)\n        {\n            // use in-memory IDistributedPublisher/Subscriber in local.\n            builder.AddInMemoryDistributedMessageBroker();   \n        }\n        else\n        {\n            // use Redis IDistributedPublisher/Subscriber\n            builder.AddRedis();\n        }\n    });\n```\n\nInterprocessPubSub, IRemoteAsyncRequest / MessagePipe.Interprocess\n---\nFor the interprocess(NamedPipe/UDP/TCP) Pub/Sub(IPC), you can use `IDistributedPublisher<TKey, TMessage>`, `IDistributedSubscriber<TKey, TMessage>` similar as `MessagePipe.Redis`.\n\n> PM> Install-Package MessagePipe.Interprocess\n\nMessagePipe.Interprocess is also exsits on Unity(except NamedPipe).\n\nuse `AddUdpInterprocess`, `AddTcpInterprocess`, `AddNamedPipeInterprocess`, `AddUdpInterprocessUds`, `AddTcpInterprocessUds` to enable interprocess provider(Uds is Unix domain socket, most performant option).\n\n```csharp\nHost.CreateDefaultBuilder()\n    .ConfigureServices((ctx, services) =>\n    {\n        services.AddMessagePipe()\n            .AddUdpInterprocess(\"127.0.0.1\", 3215, configure); // setup host and port.\n            // .AddTcpInterprocess(\"127.0.0.1\", 3215, configure);\n            // .AddNamedPipeInterprocess(\"messagepipe-namedpipe\", configure);\n            // .AddUdpInterprocessUds(\"domainSocketPath\")\n            // .AddTcpInterprocessUds(\"domainSocketPath\")\n    })\n```\n\n```csharp\npublic async P(IDistributedPublisher<string, int> publisher)\n{\n    // publish value to remote process.\n    await publisher.PublishAsync(\"foobar\", 100);\n}\n\npublic async S(IDistributedSubscriber<string, int> subscriber)\n{\n    // subscribe remote-message with \"foobar\" key.\n    await subscriber.SubscribeAsync(\"foobar\", x =>\n    {\n        Console.WriteLine(x);\n    });\n}\n```\n\nwhen injected `IDistributedPublisher`, process will be `server`, start to listen client. when injected `IDistributedSubscriber`, process will be `client`, start to connect to server. when DI scope is closed, server/client connection is closed.\n\nUdp is connectionless protocol so does not require server is started before client connect. However protocol limitation, does not send over 64K message. We're recommend to use this if message is not large.\n\nNamedpipe is 1:1 connection, can not connect multiple subscribers.\n\nTcp has no such restrictions and is the most flexible of all the options.\n\nIn default uses [MessagePack for C#](https://github.com/neuecc/MessagePack-CSharp)'s `ContractlessStandardResolver` for message serialization. You can change to use other `MessagePackSerializerOptions` by MessagePipeInterprocessOptions.MessagePackSerializerOptions.\n\n```csharp\nbuilder.AddUdpInterprocess(\"127.0.0.1\", 3215, options =>\n{\n    // You can configure other options, `InstanceLifetime` and `UnhandledErrorHandler`.\n    options.MessagePackSerializerOptions = StandardResolver.Options;\n});\n```\n\nFor IPC-RPC, you can use `IRemoteRequestHandler<in TRequest, TResponse>` that invoke remote `IAsyncRequestHandler<TRequest, TResponse>`. using `TcpInterprocess` or `NamedPipeInterprocess` enabled it.\n\n```csharp\nHost.CreateDefaultBuilder()\n    .ConfigureServices((ctx, services) =>\n    {\n        services.AddMessagePipe()\n            .AddTcpInterprocess(\"127.0.0.1\", 3215, x =>\n            {\n                x.HostAsServer = true; // if remote process as server, set true(otherwise false(default)).\n            });\n    });\n```\n\n```csharp\n// example: server handler\npublic class MyAsyncHandler : IAsyncRequestHandler<int, string>\n{\n    public async ValueTask<string> InvokeAsync(int request, CancellationToken cancellationToken = default)\n    {\n        await Task.Delay(1);\n        if (request == -1)\n        {\n            throw new Exception(\"NO -1\");\n        }\n        else\n        {\n            return \"ECHO:\" + request.ToString();\n        }\n    }\n}\n```\n\n```csharp\n// client\nasync void A(IRemoteRequestHandler<int, string> remoteHandler)\n{\n    var v = await remoteHandler.InvokeAsync(9999);\n    Console.WriteLine(v); // ECHO:9999\n}\n```\n\nFor Unity, requires to import MessagePack-CSharp package and needs slightly different configuration.\n\n```csharp\n// example of VContainer\nvar builder = new ContainerBuilder();\nvar options = builder.RegisterMessagePipe(configure);\n\nvar messagePipeBuilder = builder.ToMessagePipeBuilder(); // require to convert ServiceCollection to enable Intereprocess\n\nvar interprocessOptions = messagePipeBuilder.AddTcpInterprocess();\n\n// register manually.\n// IDistributedPublisher/Subscriber\nmessagePipeBuilder.RegisterTcpInterprocessMessageBroker<int, int>(interprocessOptions);\n// RemoteHandler\nbuilder.RegisterAsyncRequestHandler<int, string, MyAsyncHandler>(options); // for server\nmessagePipeBuilder.RegisterTcpRemoteRequestHandler<int, string>(interprocessOptions); // for client\n```\n\nMessagePipeOptions\n---\nYou can configure MessagePipe behaviour by `MessagePipeOptions` in `AddMessagePipe(Action<MMessagePipeOptions> configure)`.\n\n```csharp\nHost.CreateDefaultBuilder()\n    .ConfigureServices((ctx, services) =>\n    {\n        // var config = ctx.Configuration.Get<MyConfig>(); // optional: get settings from configuration(use it for options configure)\n\n        services.AddMessagePipe(options =>\n        {\n            options.InstanceLifetime = InstanceLifetime.Scoped;\n#if DEBUG\n            // EnableCaptureStackTrace slows performance, so recommended to use only in DEBUG and in profiling, disable it.\n            options.EnableCaptureStackTrace = true;\n#endif\n        });\n    })\n```\n\nOption has these properties(and method).\n\n```csharp\npublic sealed class MessagePipeOptions\n{\n    AsyncPublishStrategy DefaultAsyncPublishStrategy; // default is Parallel\n    HandlingSubscribeDisposedPolicy HandlingSubscribeDisposedPolic; // default is Ignore\n    InstanceLifetime InstanceLifetime; // default is Singleton\n    InstanceLifetime RequestHandlerLifetime; // default is Scoped\n    bool EnableAutoRegistration;  // default is true\n    bool EnableCaptureStackTrace; // default is false\n\n    void SetAutoRegistrationSearchAssemblies(params Assembly[] assemblies);\n    void SetAutoRegistrationSearchTypes(params Type[] types);\n    void AddGlobal***Filter<T>();\n}\n\npublic enum AsyncPublishStrategy\n{\n    Parallel, Sequential\n}\n\npublic enum InstanceLifetime\n{\n    Singleton, Scoped, Transient\n}\n\npublic enum HandlingSubscribeDisposedPolicy\n{\n    Ignore, Throw\n}\n```\n\n### DefaultAsyncPublishStrategy\n\n`IAsyncPublisher` has `PublishAsync` method. If AsyncPublishStrategy.Sequential, await each subscribers. If Parallel, uses WhenAll.\n\n```csharp\npublic interface IAsyncPublisher<TMessage>\n{\n    // using Default AsyncPublishStrategy\n    ValueTask PublishAsync(TMessage message, CancellationToken cancellationToken = default);\n    ValueTask PublishAsync(TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken = default);\n    // snip others...\n}\n\npublic interface IAsyncPublisher<TKey, TMessage>\n    where TKey : notnull\n{\n    // using Default AsyncPublishStrategy\n    ValueTask PublishAsync(TKey key, TMessage message, CancellationToken cancellationToken = default);\n    ValueTask PublishAsync(TKey key, TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken = default);\n    // snip others...\n}\n\npublic interface IAsyncRequestAllHandler<in TRequest, TResponse>\n{\n    // using Default AsyncPublishStrategy\n    ValueTask<TResponse[]> InvokeAllAsync(TRequest request, CancellationToken cancellationToken = default);\n    ValueTask<TResponse[]> InvokeAllAsync(TRequest request, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken = default);\n    // snip others...\n}\n```\n\n`MessagePipeOptions.DefaultAsyncPublishStrategy`'s default is `Parallel`.\n\n### HandlingSubscribeDisposedPolicy\n\nWhen `ISubscriber.Subscribe` after MessageBroker(publisher/subscriber manager) is disposed(for example, scope is disposed), choose `Ignore`(returns empty `IDisposable`) or `Throw` exception. Default is `Ignore`.\n\n### InstanceLifetime\n\nConfigure MessageBroker(publisher/subscriber manager)'s lifetime of DI cotainer. You can choose `Singleton` or `Scoped`. Default is `Singleton`. When choose `Scoped`, each messagebrokers manage different subscribers and when scope is disposed, unsubscribe all managing subscribers.\n\n### RequestHandlerLifetime\n\nConfigure IRequestHandler/IAsyncRequestHandler's lifetime of DI container. You can choose `Singleton` or `Scoped` or `Transient`. Default is `Scoped`.\n\n### EnableAutoRegistration/SetAutoRegistrationSearchAssemblies/SetAutoRegistrationSearchTypes\n\nRegister `IRequestHandler`, `IAsyncHandler` and filters to DI container automatically on startup. Default is `true` and default search target is CurrentDomain's all assemblies and types. However, this sometimes fails to detect the assembly being stripped. In that case, you can enable the search by explicitly adding it to `SetAutoRegistrationSearchAssemblies` or `SetAutoRegistrationSearchTypes`.\n\n`[IgnoreAutoRegistration]` attribute allows to disable auto registration which attribute attached.\n\n### EnableCaptureStackTrace\n\nSee the details [Managing Subscription and Diagnostics](#managing-subscription-and-diagnostics) section, if `true` then capture stacktrace on Subscribe. It is useful for debugging but performance will be degraded. Default is `false` and recommended to enable only debug.\n\n### AddGlobal***Filter\n\nAdd global filter, for example logging filter will be useful.\n\n```csharp\npublic class LoggingFilter<T> : MessageHandlerFilter<T>\n{\n    readonly ILogger<LoggingFilter<T>> logger;\n\n    public LoggingFilter(ILogger<LoggingFilter<T>> logger)\n    {\n        this.logger = logger;\n    }\n\n    public override void Handle(T message, Action<T> next)\n    {\n        try\n        {\n            logger.LogDebug(\"before invoke.\");\n            next(message);\n            logger.LogDebug(\"invoke completed.\");\n        }\n        catch (Exception ex)\n        {\n            logger.LogError(ex, \"error\");\n        }\n    }\n}\n```\n\nTo enable all types, use open generics.\n\n```csharp\nHost.CreateDefaultBuilder()\n    .ConfigureServices((ctx, services) =>\n    {\n        services.AddMessagePipe(options =>\n        {\n            // use typeof(Filter<>, order);\n            options.AddGlobalMessageHandlerFilter(typeof(LoggingFilter<>), -10000);\n        });\n    });\n```\n\nGlobal provider\n---\nIf you want to get publisher/subscriber/handler from globally scope, get `IServiceProvider` before run and set to static helper called `GlobalMessagePipe`.\n\n```csharp\nvar host = Host.CreateDefaultBuilder()\n    .ConfigureServices((ctx, x) =>\n    {\n        x.AddMessagePipe();\n    })\n    .Build(); // build host before run.\n\nGlobalMessagePipe.SetProvider(host.Services); // set service provider\n\nawait host.RunAsync(); // run framework.\n```\n\n`GlobalMessagePipe` has these static method(`GetPublisher<T>`, `GetSubscriber<T>`, `CreateEvent<T>`, etc...) so you can get globally.\n\n![image](https://user-images.githubusercontent.com/46207/116521078-7c00de00-a90e-11eb-85c0-2c62c140c51d.png)\n\nIntegration with other DI library\n---\nAll(popular) DI libraries has `Microsoft.Extensions.DependencyInjection` bridge so configure by MS.E.DI and use bridge if you want.\n\nCompare with Channels\n---\n[System.Threading.Channels](https://docs.microsoft.com/en-us/dotnet/api/system.threading.channels)(for Unity, `UniTask.Channels`) uses Queue internal, the producer is not affected by the performance of the consumer, and the consumer can control the flow rate(back pressure). This is a different use than MessagePipe's Pub/Sub.\n\nUnity\n---\nYou need to install Core library and choose [VContainer](https://github.com/hadashiA/VContainer/) or [Zenject](https://github.com/modesttree/Zenject) or `BuiltinContainerBuilder` for runtime. You can install via UPM git URL package or asset package(MessagePipe.*.unitypackage) available in [MessagePipe/releases](https://github.com/Cysharp/MessagePipe/releases) page.\n\n* Core `https://github.com/Cysharp/MessagePipe.git?path=src/MessagePipe.Unity/Assets/Plugins/MessagePipe`\n* VContainer `https://github.com/Cysharp/MessagePipe.git?path=src/MessagePipe.Unity/Assets/Plugins/MessagePipe.VContainer`\n* Zenject `https://github.com/Cysharp/MessagePipe.git?path=src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Zenject`\n\nAndalso, requires [UniTask](https://github.com/Cysharp/UniTask) to install, all `ValueTask` declaration in .NET is replaced to `UniTask`.\n\n> [!NOTE]\n> Unity version does not have open generics support(for IL2CPP) and does not support auto registration. Therefore, all required types need to be manually registered.\n\nVContainer's installation sample.\n\n```csharp\npublic class GameLifetimeScope : LifetimeScope\n{\n    protected override void Configure(IContainerBuilder builder)\n    {\n        // RegisterMessagePipe returns options.\n        var options = builder.RegisterMessagePipe(/* configure option */);\n        \n        // Setup GlobalMessagePipe to enable diagnostics window and global function\n        builder.RegisterBuildCallback(c => GlobalMessagePipe.SetProvider(c.AsServiceProvider()));\n\n        // RegisterMessageBroker: Register for IPublisher<T>/ISubscriber<T>, includes async and buffered.\n        builder.RegisterMessageBroker<int>(options);\n\n        // also exists RegisterMessageBroker<TKey, TMessage>, RegisterRequestHandler, RegisterAsyncRequestHandler\n\n        // RegisterMessageHandlerFilter: Register for filter, also exists RegisterAsyncMessageHandlerFilter, Register(Async)RequestHandlerFilter\n        builder.RegisterMessageHandlerFilter<MyFilter<int>>();\n\n        builder.RegisterEntryPoint<MessagePipeDemo>(Lifetime.Singleton);\n    }\n}\n\npublic class MessagePipeDemo : VContainer.Unity.IStartable\n{\n    readonly IPublisher<int> publisher;\n    readonly ISubscriber<int> subscriber;\n\n    public MessagePipeDemo(IPublisher<int> publisher, ISubscriber<int> subscriber)\n    {\n        this.publisher = publisher;\n        this.subscriber = subscriber;\n    }\n\n    public void Start()\n    {\n        var d = DisposableBag.CreateBuilder();\n        subscriber.Subscribe(x => Debug.Log(\"S1:\" + x)).AddTo(d);\n        subscriber.Subscribe(x => Debug.Log(\"S2:\" + x)).AddTo(d);\n\n        publisher.Publish(10);\n        publisher.Publish(20);\n        publisher.Publish(30);\n\n        var disposable = d.Build();\n        disposable.Dispose();\n    }\n}\n```\n\n> [!TIP]\n> If you are using Unity 2022.1 or later and VContainer 1.14.0 or later, you do not need `RegsiterMessageBroker<>`. \n> A set of types including `ISubscriber<>`, `IPublisher<>` or its asynchronous version will be resolved automatically.\n> Note that `IRequesthandler<>` and `IRequestAllHanlder<>` still require manual registration.\n\n\nUnity version does not have open generics support(for IL2CPP) and does not support auto registration. Therefore, all required types need to be manually registered.\n\n\nZenject's installation sample.\n\n```csharp\nvoid Configure(DiContainer builder)\n{\n    // BindMessagePipe returns options.\n    var options = builder.BindMessagePipe(/* configure option */);\n    \n    // BindMessageBroker: Register for IPublisher<T>/ISubscriber<T>, includes async and buffered.\n    builder.BindMessageBroker<int>(options);\n\n    // also exists BindMessageBroker<TKey, TMessage>, BindRequestHandler, BindAsyncRequestHandler\n\n    // BindMessageHandlerFilter: Bind for filter, also exists BindAsyncMessageHandlerFilter, Bind(Async)RequestHandlerFilter\n    builder.BindMessageHandlerFilter<MyFilter<int>>();\n\n    // set global to enable diagnostics window and global function\n    GlobalMessagePipe.SetProvider(builder.AsServiceProvider());\n}\n```\n\n> Zenject version is not supported `InstanceScope.Singleton` for Zenject's limitation. The default is `Scoped`, which cannot be changed.\n\n`BuiltinContainerBuilder` is builtin minimum DI library for MessagePipe, it no needs other DI library to use MessagePipe. Here is installation sample.\n\n```csharp\nvar builder = new BuiltinContainerBuilder();\n\nbuilder.AddMessagePipe(/* configure option */);\n\n// AddMessageBroker: Register for IPublisher<T>/ISubscriber<T>, includes async and buffered.\nbuilder.AddMessageBroker<int>(options);\n\n// also exists AddMessageBroker<TKey, TMessage>, AddRequestHandler, AddAsyncRequestHandler\n\n// AddMessageHandlerFilter: Register for filter, also exists RegisterAsyncMessageHandlerFilter, Register(Async)RequestHandlerFilter\nbuilder.AddMessageHandlerFilter<MyFilter<int>>();\n\n// create provider and set to Global(to enable diagnostics window and global fucntion)\nvar provider = builder.BuildServiceProvider();\nGlobalMessagePipe.SetProvider(provider);\n\n// --- to use MessagePipe, you can use from GlobalMessagePipe.\nvar p = GlobalMessagePipe.GetPublisher<int>();\nvar s = GlobalMessagePipe.GetSubscriber<int>();\n\nvar d = s.Subscribe(x => Debug.Log(x));\n\np.Publish(10);\np.Publish(20);\np.Publish(30);\n\nd.Dispose();\n```\n\n> BuiltinContainerBuilder does not supports scope(always `InstanceScope.Singleton`), `IRequestAllHandler/IAsyncRequestAllHandler`, and many DI functionally, so we recommend to use by `GlobalMessagePipe` when use BuiltinContainerBuilder.\n\nAdding global filter, you can not use open generics filter so recommended to create these helper method.\n\n```csharp\n// Register IPublisher<T>/ISubscriber<T> and global filter.\nstatic void RegisterMessageBroker<T>(IContainerBuilder builder, MessagePipeOptions options)\n{\n    builder.RegisterMessageBroker<T>(options);\n\n    // setup for global filters.\n    options.AddGlobalMessageHandlerFilter<MyMessageHandlerFilter<T>>();\n}\n\n// Register IRequestHandler<TReq, TRes>/IRequestAllHandler<TReq, TRes> and global filter.\nstatic void RegisterRequest<TRequest, TResponse, THandler>(IContainerBuilder builder, MessagePipeOptions options)\n    where THandler : IRequestHandler\n{\n    builder.RegisterRequestHandler<TRequest, TResponse, THandler>(options);\n    \n    // setup for global filters.\n    options.AddGlobalRequestHandlerFilter<MyRequestHandlerFilter<TRequest, TResponse>>();\n}\n```\n\nAlso you can use `GlobalMessagePipe` and `MessagePipe Diagnostics` window. see: [Global provider](#global-provider) and [Managing Subscription and Diagnostics](#managing-subscription-and-diagnostics) section.\n\nLicense\n---\nThis library is licensed under the MIT License.\n"
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 0.140625,
          "content": "version: \"3.4\"\n\nservices:\n  redis:\n    image: \"redis:6.2.1\"\n    ports:\n      - \"6379:6379\"\n  nats:\n    image: nats\n    ports:\n      - 4222:4222\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "opensource.snk",
          "type": "blob",
          "size": 0.58203125,
          "content": null
        },
        {
          "name": "sandbox",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}