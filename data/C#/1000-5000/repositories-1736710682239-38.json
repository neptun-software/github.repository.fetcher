{
  "metadata": {
    "timestamp": 1736710682239,
    "page": 38,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Tyrrrz/CliWrap",
      "stars": 4480,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".assets",
          "type": "tree",
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.099609375,
          "content": "# User-specific files\n.vs/\n.idea/\n*.suo\n*.user\n\n# Build results\nbin/\nobj/\n\n# Test results\nTestResults/"
        },
        {
          "name": "CliWrap.Benchmarks",
          "type": "tree",
          "content": null
        },
        {
          "name": "CliWrap.Signaler",
          "type": "tree",
          "content": null
        },
        {
          "name": "CliWrap.Tests.Dummy",
          "type": "tree",
          "content": null
        },
        {
          "name": "CliWrap.Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "CliWrap.sln",
          "type": "blob",
          "size": 3.3076171875,
          "content": "ï»¿Microsoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio 15\nVisualStudioVersion = 15.0.27130.2024\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"Solution Items\", \"Solution Items\", \"{43514CCF-887D-43B9-81D0-A9930FE73772}\"\n\tProjectSection(SolutionItems) = preProject\n\t\tLicense.txt = License.txt\n\t\tReadme.md = Readme.md\n\t\tDirectory.Build.props = Directory.Build.props\n\tEndProjectSection\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"CliWrap\", \"CliWrap\\CliWrap.csproj\", \"{03ECCB7F-144F-4742-BF68-7F84026DA775}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"CliWrap.Tests\", \"CliWrap.Tests\\CliWrap.Tests.csproj\", \"{890D9A75-4B00-4D89-AAF8-936726B45410}\"\nEndProject\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"CliWrap.Tests.Dummy\", \"CliWrap.Tests.Dummy\\CliWrap.Tests.Dummy.csproj\", \"{666CF814-2BA5-44E5-8C44-12A08E3C6D61}\"\nEndProject\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"CliWrap.Benchmarks\", \"CliWrap.Benchmarks\\CliWrap.Benchmarks.csproj\", \"{22636DB4-8A4D-4540-95AF-59C848459948}\"\nEndProject\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"CliWrap.Signaler\", \"CliWrap.Signaler\\CliWrap.Signaler.csproj\", \"{A0E41A11-D314-45C4-890B-831385450DF8}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|Any CPU = Debug|Any CPU\n\t\tRelease|Any CPU = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{03ECCB7F-144F-4742-BF68-7F84026DA775}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{03ECCB7F-144F-4742-BF68-7F84026DA775}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{03ECCB7F-144F-4742-BF68-7F84026DA775}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{03ECCB7F-144F-4742-BF68-7F84026DA775}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{890D9A75-4B00-4D89-AAF8-936726B45410}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{890D9A75-4B00-4D89-AAF8-936726B45410}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{890D9A75-4B00-4D89-AAF8-936726B45410}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{890D9A75-4B00-4D89-AAF8-936726B45410}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{666CF814-2BA5-44E5-8C44-12A08E3C6D61}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{666CF814-2BA5-44E5-8C44-12A08E3C6D61}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{666CF814-2BA5-44E5-8C44-12A08E3C6D61}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{666CF814-2BA5-44E5-8C44-12A08E3C6D61}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{22636DB4-8A4D-4540-95AF-59C848459948}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{22636DB4-8A4D-4540-95AF-59C848459948}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{22636DB4-8A4D-4540-95AF-59C848459948}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{22636DB4-8A4D-4540-95AF-59C848459948}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{A0E41A11-D314-45C4-890B-831385450DF8}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{A0E41A11-D314-45C4-890B-831385450DF8}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{A0E41A11-D314-45C4-890B-831385450DF8}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{A0E41A11-D314-45C4-890B-831385450DF8}.Release|Any CPU.Build.0 = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {E62AAC63-51EC-45A1-A500-7B073424CA8C}\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "CliWrap",
          "type": "tree",
          "content": null
        },
        {
          "name": "Directory.Build.props",
          "type": "blob",
          "size": 1.177734375,
          "content": "<Project>\n\n  <PropertyGroup>\n    <Version>0.0.0-dev</Version>\n    <Company>Tyrrrz</Company>\n    <Copyright>Copyright (C) Oleksii Holub</Copyright>\n    <LangVersion>latest</LangVersion>\n    <Nullable>enable</Nullable>\n    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>\n    <CheckEolTargetFramework>false</CheckEolTargetFramework>\n    <IsPackable>false</IsPackable>\n  </PropertyGroup>\n\n  <!-- Disable nullability warnings on older frameworks because there is no nullability info for BCL -->\n  <PropertyGroup Condition=\"$([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'netstandard2.1')) != true\">\n    <Nullable>annotations</Nullable>\n  </PropertyGroup>\n\n  <PropertyGroup>\n    <Authors>$(Company)</Authors>\n    <Description>Library for interacting with external command-line interfaces</Description>\n    <PackageTags>yshell pipe command line executable interface wrapper standard input output error arguments net core</PackageTags>\n    <PackageProjectUrl>https://github.com/Tyrrrz/CliWrap</PackageProjectUrl>\n    <PackageReleaseNotes>https://github.com/Tyrrrz/CliWrap/releases</PackageReleaseNotes>\n    <PackageLicenseExpression>MIT</PackageLicenseExpression>\n  </PropertyGroup>\n\n</Project>"
        },
        {
          "name": "License.txt",
          "type": "blob",
          "size": 1.048828125,
          "content": "MIT License\n\nCopyright (c) 2017-2024 Oleksii Holub\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "NuGet.config",
          "type": "blob",
          "size": 0.3125,
          "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<configuration>\n  <packageSources>\n    <clear />\n    <add key=\"nuget.org\" value=\"https://api.nuget.org/v3/index.json\" protocolVersion=\"3\" />\n  </packageSources>\n  <config>\n    <add key=\"defaultPushSource\" value=\"https://api.nuget.org/v3/index.json\" />\n  </config>\n</configuration>\n"
        },
        {
          "name": "Readme.md",
          "type": "blob",
          "size": 27.9775390625,
          "content": "# CliWrap\n\n[![Status](https://img.shields.io/badge/status-active-47c219.svg)](https://github.com/Tyrrrz/.github/blob/master/docs/project-status.md)\n[![Made in Ukraine](https://img.shields.io/badge/made_in-ukraine-ffd700.svg?labelColor=0057b7)](https://tyrrrz.me/ukraine)\n[![Build](https://img.shields.io/github/actions/workflow/status/Tyrrrz/CliWrap/main.yml?branch=master)](https://github.com/Tyrrrz/CliWrap/actions)\n[![Coverage](https://img.shields.io/codecov/c/github/Tyrrrz/CliWrap/master)](https://codecov.io/gh/Tyrrrz/CliWrap)\n[![Version](https://img.shields.io/nuget/v/CliWrap.svg)](https://nuget.org/packages/CliWrap)\n[![Downloads](https://img.shields.io/nuget/dt/CliWrap.svg)](https://nuget.org/packages/CliWrap)\n[![Discord](https://img.shields.io/discord/869237470565392384?label=discord)](https://discord.gg/2SUWKFnHSm)\n[![Fuck Russia](https://img.shields.io/badge/fuck-russia-e4181c.svg?labelColor=000000)](https://twitter.com/tyrrrz/status/1495972128977571848)\n\n<table>\n    <tr>\n        <td width=\"99999\" align=\"center\">Development of this project is entirely funded by the community. <b><a href=\"https://tyrrrz.me/donate\">Consider donating to support!</a></b></td>\n    </tr>\n</table>\n\n<p align=\"center\">\n    <img src=\"favicon.png\" alt=\"Icon\" />\n</p>\n\n**CliWrap** is a library for interacting with external command-line interfaces.\nIt provides a convenient model for launching processes, redirecting input and output streams, awaiting completion, handling cancellation, and more.\n\n## Terms of use<sup>[[?]](https://github.com/Tyrrrz/.github/blob/master/docs/why-so-political.md)</sup>\n\nBy using this project or its source code, for any purpose and in any shape or form, you grant your **implicit agreement** to all the following statements:\n\n- You **condemn Russia and its military aggression against Ukraine**\n- You **recognize that Russia is an occupant that unlawfully invaded a sovereign state**\n- You **support Ukraine's territorial integrity, including its claims over temporarily occupied territories of Crimea and Donbas**\n- You **reject false narratives perpetuated by Russian state propaganda**\n\nTo learn more about the war and how you can help, [click here](https://tyrrrz.me/ukraine). Glory to Ukraine! ðŸ‡ºðŸ‡¦\n\n## Install\n\n- ðŸ“¦ [NuGet](https://nuget.org/packages/CliWrap): `dotnet add package CliWrap`\n\n## Features\n\n- Airtight abstraction over `System.Diagnostics.Process`\n- Fluent configuration interface\n- Flexible support for piping\n- Fully asynchronous and cancellation-aware API\n- Graceful cancellation using interrupt signals\n- Designed with strict immutability in mind\n- Provides safety against typical deadlock scenarios\n- Tested on Windows, Linux, and macOS\n- Targets .NET Standard 2.0+, .NET Core 3.0+, .NET Framework 4.6.2+\n- No external dependencies\n\n## Usage\n\n### Video guides\n\nYou can watch one of these videos to learn how to use the library:\n\n- [**OSS Power-Ups: CliWrap**](https://youtube.com/watch?v=3_Ucw3Fflmo) by [Oleksii Holub](https://twitter.com/tyrrrz)\n\n[![Intro to CliWrap](.assets/video-guide-oss-powerups.jpg)](https://youtube.com/watch?v=3_Ucw3Fflmo)\n\n- [**Stop using the Process class for CLI interactions in .NET**](https://youtube.com/watch?v=Pt-0KM5SxmI) by [Nick Chapsas](https://twitter.com/nickchapsas)\n\n[![Stop using the Process class for CLI interactions in .NET](.assets/video-guide-nick-chapsas.jpg)](https://youtube.com/watch?v=Pt-0KM5SxmI)\n\n### Quick overview\n\nSimilarly to a shell, **CliWrap**'s base unit of work is a **command** â€” an object that encapsulates instructions for running a process.\nTo build a command, start by calling `Cli.Wrap(...)` with the executable path, and then use the provided fluent interface to configure arguments, working directory, or other options.\nOnce the command is configured, you can run it by calling `ExecuteAsync()`:\n\n```csharp\nusing CliWrap;\n\nvar result = await Cli.Wrap(\"path/to/exe\")\n    .WithArguments([\"--foo\", \"bar\"])\n    .WithWorkingDirectory(\"work/dir/path\")\n    .ExecuteAsync();\n\n// Result contains:\n// -- result.IsSuccess       (bool)\n// -- result.ExitCode        (int)\n// -- result.StartTime       (DateTimeOffset)\n// -- result.ExitTime        (DateTimeOffset)\n// -- result.RunTime         (TimeSpan)\n```\n\nThe code above spawns a child process with the configured command-line arguments and working directory, and then asynchronously waits for it to exit.\nAfter the task has completed, it resolves to a `CommandResult` object that contains the process exit code and other relevant information.\n\n> **Warning**:\n> **CliWrap** will throw an exception if the underlying process returns a non-zero exit code, as it usually indicates an error.\n> You can [override this behavior](#withvalidation) by disabling result validation using `WithValidation(CommandResultValidation.None)`.\n\nBy default, the process's standard input, output and error streams are routed to **CliWrap**'s equivalent of a [_null device_](https://en.wikipedia.org/wiki/Null_device), which represents an empty source and a target that discards all data.\nYou can change this by calling `WithStandardInputPipe(...)`, `WithStandardOutputPipe(...)`, or `WithStandardErrorPipe(...)` to configure pipes for the corresponding streams:\n\n```csharp\nusing CliWrap;\n\nvar stdOutBuffer = new StringBuilder();\nvar stdErrBuffer = new StringBuilder();\n\nvar result = await Cli.Wrap(\"path/to/exe\")\n    .WithArguments([\"--foo\", \"bar\"])\n    .WithWorkingDirectory(\"work/dir/path\")\n    // This can be simplified with `ExecuteBufferedAsync()`\n    .WithStandardOutputPipe(PipeTarget.ToStringBuilder(stdOutBuffer))\n    .WithStandardErrorPipe(PipeTarget.ToStringBuilder(stdErrBuffer))\n    .ExecuteAsync();\n\n// Access stdout & stderr buffered in-memory as strings\nvar stdOut = stdOutBuffer.ToString();\nvar stdErr = stdErrBuffer.ToString();\n```\n\nThis example command is configured to decode the data written to the standard output and error streams as text, and append it to the corresponding `StringBuilder` buffers.\nOnce the execution is complete, these buffers can be inspected to see what the process has printed to the console.\n\nHandling command output is a very common use case, so **CliWrap** offers a few high-level [execution models](#execution-models) to make these scenarios simpler.\nIn particular, the same thing shown above can also be achieved more succinctly with the `ExecuteBufferedAsync()` extension method:\n\n```csharp\nusing CliWrap;\nusing CliWrap.Buffered;\n\n// Calling `ExecuteBufferedAsync()` instead of `ExecuteAsync()`\n// implicitly configures pipes that write to in-memory buffers.\nvar result = await Cli.Wrap(\"path/to/exe\")\n    .WithArguments([\"--foo\", \"bar\"])\n    .WithWorkingDirectory(\"work/dir/path\")\n    .ExecuteBufferedAsync();\n\n// Result contains:\n// -- result.IsSuccess       (bool)\n// -- result.StandardOutput  (string)\n// -- result.StandardError   (string)\n// -- result.ExitCode        (int)\n// -- result.StartTime       (DateTimeOffset)\n// -- result.ExitTime        (DateTimeOffset)\n// -- result.RunTime         (TimeSpan)\n```\n\n> **Warning**:\n> Be mindful when using `ExecuteBufferedAsync()`.\n> Programs can write arbitrary data (including binary) to the output and error streams, and storing it in-memory may be impractical.\n> For more advanced scenarios, **CliWrap** also provides other piping options, which are covered in the [piping section](#piping).\n\n### Command configuration\n\nThe fluent interface provided by the command object allows you to configure various aspects of its execution.\nThis section covers all available configuration methods and their usage.\n\n> **Note**:\n> `Command` is an immutable object â€” all configuration methods listed here create a new instance instead of modifying the existing one.\n\n#### `WithArguments(...)`\n\nSets the command-line arguments passed to the child process.\n\n**Default**: empty.\n\n**Examples**:\n\n- Set arguments using an array:\n\n```csharp\nvar cmd = Cli.Wrap(\"git\")\n    // Each element is formatted as a separate argument.\n    // Equivalent to: `git commit -m \"my commit\"`\n    .WithArguments([\"commit\", \"-m\", \"my commit\"]);\n```\n\n- Set arguments using a builder:\n\n```csharp\nvar cmd = Cli.Wrap(\"git\")\n    // Each Add(...) call takes care of formatting automatically.\n    // Equivalent to: `git clone https://github.com/Tyrrrz/CliWrap --depth 20`\n    .WithArguments(args => args\n        .Add(\"clone\")\n        .Add(\"https://github.com/Tyrrrz/CliWrap\")\n        .Add(\"--depth\")\n        .Add(20)\n    );\n```\n\n```csharp\nvar forcePush = true;\n\nvar cmd = Cli.Wrap(\"git\")\n    // Arguments can also be constructed in an imperative fashion.\n    // Equivalent to: `git push --force`\n    .WithArguments(args => \n    {\n        args.Add(\"push\");\n\n        if (forcePush)\n            args.Add(\"--force\");\n    });\n```\n\n> **Note**:\n> The builder overload allows you to define custom extension methods for reusable argument patterns.\n> [Learn more](https://twitter.com/Tyrrrz/status/1409104223753605121).\n\n- Set arguments directly:\n\n```csharp\nvar cmd = Cli.Wrap(\"git\")\n    // Avoid using this overload unless you really have to.\n    // Equivalent to: `git commit -m \"my commit\"`\n    .WithArguments(\"commit -m \\\"my commit\\\"\");\n```\n\n> **Warning**:\n> Unless you absolutely have to, avoid setting command-line arguments directly from a string.\n> This method expects all arguments to be correctly escaped and formatted ahead of time â€” which can be cumbersome to do yourself.\n> Formatting errors may result in unexpected bugs and security vulnerabilities.\n\n> **Note**:\n> There are some [obscure scenarios](https://github.com/Tyrrrz/CliWrap/issues/263), where you may need to assemble the command-line arguments yourself.\n> In such cases, you can use the `ArgumentsBuilder.Escape(...)` method to escape individual arguments manually.\n\n#### `WithWorkingDirectory(...)`\n\nSets the working directory of the child process.\n\n**Default**: current working directory, i.e. `Directory.GetCurrentDirectory()`.\n\n**Example**:\n\n```csharp\nvar cmd = Cli.Wrap(\"git\")\n    .WithWorkingDirectory(\"c:/projects/my project/\");\n```\n\n#### `WithEnvironmentVariables(...)`\n\nSets additional environment variables exposed to the child process.\n\n**Default**: empty.\n\n**Examples**:\n\n- Set environment variables using a builder:\n\n```csharp\nvar cmd = Cli.Wrap(\"git\")\n    .WithEnvironmentVariables(env => env\n        .Set(\"GIT_AUTHOR_NAME\", \"John\")\n        .Set(\"GIT_AUTHOR_EMAIL\", \"john@email.com\")\n    );\n```\n\n- Set environment variables directly:\n\n```csharp\nvar cmd = Cli.Wrap(\"git\")\n    .WithEnvironmentVariables(new Dictionary<string, string?>\n    {\n        [\"GIT_AUTHOR_NAME\"] = \"John\",\n        [\"GIT_AUTHOR_EMAIL\"] = \"john@email.com\"\n    });\n```\n\n> **Note**:\n> Environment variables configured using `WithEnvironmentVariables(...)` are applied on top of those inherited from the parent process.\n> If you need to remove an inherited variable, set the corresponding value to `null`.\n\n#### `WithCredentials(...)`\n\nSets domain, name and password of the user, under whom the child process should be started.\n\n**Default**: no credentials.\n\n**Examples**:\n\n- Set credentials using a builder:\n\n```csharp\nvar cmd = Cli.Wrap(\"git\")\n    .WithCredentials(creds => creds\n       .SetDomain(\"some_workspace\")\n       .SetUserName(\"johndoe\")\n       .SetPassword(\"securepassword123\")\n       .LoadUserProfile()\n    );\n```\n\n- Set credentials directly:\n\n```csharp\nvar cmd = Cli.Wrap(\"git\")\n    .WithCredentials(new Credentials(\n        domain: \"some_workspace\",\n        userName: \"johndoe\",\n        password: \"securepassword123\",\n        loadUserProfile: true\n    ));\n```\n\n> **Warning**:\n> Running a process under a different username is supported across all platforms, but other options are only available on Windows.\n\n#### `WithValidation(...)`\n\nSets the strategy for validating the result of an execution.\n\n**Accepted values**:\n\n- `CommandResultValidation.None` â€” no validation\n- `CommandResultValidation.ZeroExitCode` â€” ensures zero exit code when the process exits\n\n**Default**: `CommandResultValidation.ZeroExitCode`.\n\n**Examples**:\n\n- Enable validation:\n\n```csharp\nvar cmd = Cli.Wrap(\"git\")\n    .WithValidation(CommandResultValidation.ZeroExitCode);\n```\n\n- Disable validation:\n\n```csharp\nvar cmd = Cli.Wrap(\"git\")\n    .WithValidation(CommandResultValidation.None);\n```\n\nIf you want to throw a custom exception when the process exits with a non-zero exit code, don't disable result validation, but instead catch the default `CommandExecutionException` and re-throw it inside your own exception.\nThis way you can preserve the information provided by the original exception, while extending it with additional context:\n\n```csharp\ntry\n{\n    await Cli.Wrap(\"git\").ExecuteAsync();\n}\ncatch (CommandExecutionException ex)\n{\n    // Re-throw the original exception to preserve additional information\n    // about the command that failed (exit code, arguments, etc.).\n    throw new MyException(\"Failed to run the git command-line tool.\", ex);\n}\n```\n\n#### `WithStandardInputPipe(...)`\n\nSets the pipe source that will be used for the standard _input_ stream of the process.\n\n**Default**: `PipeSource.Null`.\n\nRead more about this method in the [piping section](#piping).\n\n#### `WithStandardOutputPipe(...)`\n\nSets the pipe target that will be used for the standard _output_ stream of the process.\n\n**Default**: `PipeTarget.Null`.\n\nRead more about this method in the [piping section](#piping).\n\n#### `WithStandardErrorPipe(...)`\n\nSets the pipe target that will be used for the standard _error_ stream of the process.\n\n**Default**: `PipeTarget.Null`.\n\nRead more about this method in the [piping section](#piping).\n\n### Piping\n\n**CliWrap** provides a very powerful and flexible piping model that allows you to redirect process's streams, transform input and output data, and even chain multiple commands together with minimal effort.\nAt its core, it's based on two abstractions: `PipeSource` which provides data for the standard input stream, and `PipeTarget` which reads data coming from the standard output stream or the standard error stream.\n\nBy default, a command's input pipe is set to `PipeSource.Null` and the output and error pipes are set to `PipeTarget.Null`.\nThese objects effectively represent no-op stubs that provide empty input and discard all output respectively.\n\nYou can specify your own `PipeSource` and `PipeTarget` instances by calling the corresponding configuration methods on the command:\n\n```csharp\nawait using var input = File.OpenRead(\"input.txt\");\nawait using var output = File.Create(\"output.txt\");\n\nawait Cli.Wrap(\"foo\")\n    .WithStandardInputPipe(PipeSource.FromStream(input))\n    .WithStandardOutputPipe(PipeTarget.ToStream(output))\n    .ExecuteAsync();\n```\n\nAlternatively, pipes can also be configured in a slightly terser way using pipe operators:\n\n```csharp\nawait using var input = File.OpenRead(\"input.txt\");\nawait using var output = File.Create(\"output.txt\");\n\nawait (input | Cli.Wrap(\"foo\") | output).ExecuteAsync();\n```\n\nBoth `PipeSource` and `PipeTarget` have many factory methods that let you create pipe implementations for different scenarios:\n\n- `PipeSource`:\n  - `PipeSource.Null` â€” represents an empty pipe source\n  - `PipeSource.FromStream(...)` â€” pipes data from any readable stream\n  - `PipeSource.FromFile(...)` â€” pipes data from a file\n  - `PipeSource.FromBytes(...)` â€” pipes data from a byte array\n  - `PipeSource.FromString(...)` â€” pipes data from a text string\n  - `PipeSource.FromCommand(...)` â€” pipes data from the standard output of another command\n- `PipeTarget`:\n  - `PipeTarget.Null` â€” represents a pipe target that discards all data\n  - `PipeTarget.ToStream(...)` â€” pipes data to any writable stream\n  - `PipeTarget.ToFile(...)` â€” pipes data to a file\n  - `PipeTarget.ToStringBuilder(...)` â€” pipes data as text into a `StringBuilder`\n  - `PipeTarget.ToDelegate(...)` â€” pipes data as text, line-by-line, into an `Action<string>`, or a `Func<string, Task>`, or a `Func<string, CancellationToken, Task>` delegate\n  - `PipeTarget.Merge(...)` â€” merges multiple outbound pipes by replicating the same data across all of them\n\n> **Warning**:\n> Using `PipeTarget.Null` results in the corresponding stream (stdout or stderr) not being opened for the underlying process at all.\n> In the vast majority of cases, this behavior should be functionally equivalent to piping to a null stream, but without the performance overhead of consuming and discarding unneeded data.\n> This may be undesirable in [certain situations](https://github.com/Tyrrrz/CliWrap/issues/145#issuecomment-1100680547) â€” in which case it's recommended to pipe to a null stream explicitly using `PipeTarget.ToStream(Stream.Null)`.\n\nBelow you can see some examples of what you can achieve with the help of **CliWrap**'s piping feature:\n\n- Pipe a string into stdin:\n\n```csharp\nvar cmd = \"Hello world\" | Cli.Wrap(\"foo\");\nawait cmd.ExecuteAsync();\n```\n\n- Pipe stdout as text into a `StringBuilder`:\n\n```csharp\nvar stdOutBuffer = new StringBuilder();\n\nvar cmd = Cli.Wrap(\"foo\") | stdOutBuffer;\nawait cmd.ExecuteAsync();\n```\n\n- Pipe a binary HTTP stream into stdin:\n\n```csharp\nusing var httpClient = new HttpClient();\nawait using var input = await httpClient.GetStreamAsync(\"https://example.com/image.png\");\n\nvar cmd = input | Cli.Wrap(\"foo\");\nawait cmd.ExecuteAsync();\n```\n\n- Pipe stdout of one command into stdin of another:\n\n```csharp\nvar cmd = Cli.Wrap(\"foo\") | Cli.Wrap(\"bar\") | Cli.Wrap(\"baz\");\nawait cmd.ExecuteAsync();\n```\n\n- Pipe stdout and stderr into stdout and stderr of the parent process:\n\n```csharp\nawait using var stdOut = Console.OpenStandardOutput();\nawait using var stdErr = Console.OpenStandardError();\n\nvar cmd = Cli.Wrap(\"foo\") | (stdOut, stdErr);\nawait cmd.ExecuteAsync();\n```\n\n- Pipe stdout into a delegate:\n\n```csharp\nvar cmd = Cli.Wrap(\"foo\") | Debug.WriteLine;\nawait cmd.ExecuteAsync();\n```\n\n- Pipe stdout into a file and stderr into a `StringBuilder`:\n\n```csharp\nvar buffer = new StringBuilder();\n\nvar cmd = Cli.Wrap(\"foo\") |\n    (PipeTarget.ToFile(\"output.txt\"), PipeTarget.ToStringBuilder(buffer));\n\nawait cmd.ExecuteAsync();\n```\n\n- Pipe stdout into multiple files simultaneously:\n\n```csharp\nvar target = PipeTarget.Merge(\n    PipeTarget.ToFile(\"file1.txt\"),\n    PipeTarget.ToFile(\"file2.txt\"),\n    PipeTarget.ToFile(\"file3.txt\")\n);\n\nvar cmd = Cli.Wrap(\"foo\") | target;\nawait cmd.ExecuteAsync();\n```\n\n- Pipe a string into stdin of one command, stdout of that command into stdin of another command, and then stdout and stderr of the last command into stdout and stderr of the parent process:\n\n```csharp\nvar cmd =\n    \"Hello world\" |\n    Cli.Wrap(\"foo\").WithArguments([\"aaa\"]) |\n    Cli.Wrap(\"bar\").WithArguments([\"bbb\"]) |\n    (Console.WriteLine, Console.Error.WriteLine);\n\nawait cmd.ExecuteAsync();\n```\n\n### Execution models\n\n**CliWrap** provides a few high-level execution models that offer alternative ways to reason about commands.\nThese are essentially just extension methods that work by leveraging the [piping feature](#piping) shown earlier.\n\n#### Buffered execution\n\nThis execution model lets you run a process while buffering its standard output and error streams in-memory as text.\nThe buffered data can then be accessed after the command finishes executing.\n\nIn order to execute a command with buffering, call the `ExecuteBufferedAsync()` extension method:\n\n```csharp\nusing CliWrap;\nusing CliWrap.Buffered;\n\nvar result = await Cli.Wrap(\"foo\")\n    .WithArguments([\"bar\"])\n    .ExecuteBufferedAsync();\n\nvar exitCode = result.ExitCode;\nvar stdOut = result.StandardOutput;\nvar stdErr = result.StandardError;\n```\n\nBy default, `ExecuteBufferedAsync()` assumes that the underlying process uses the default encoding (`Encoding.Default`) for writing text to the console.\nTo override this, specify the encoding explicitly by using one of the available overloads:\n\n```csharp\n// Treat both stdout and stderr as UTF8-encoded text streams\nvar result = await Cli.Wrap(\"foo\")\n    .WithArguments([\"bar\"])\n    .ExecuteBufferedAsync(Encoding.UTF8);\n\n// Treat stdout as ASCII-encoded and stderr as UTF8-encoded\nvar result = await Cli.Wrap(\"foo\")\n    .WithArguments([\"bar\"])\n    .ExecuteBufferedAsync(Encoding.ASCII, Encoding.UTF8);\n```\n\n> **Note**:\n> If the underlying process returns a non-zero exit code, `ExecuteBufferedAsync()` will throw an exception similarly to `ExecuteAsync()`, but the exception message will also include the standard error data.\n\n#### Pull-based event stream\n\nBesides executing a command as a task, **CliWrap** also supports an alternative model, in which the execution is represented as an event stream.\nThis lets you start a process and react to the events it produces in real-time.\n\nThose events are:\n\n- `StartedCommandEvent` â€” received just once, when the command starts executing (contains the process ID)\n- `StandardOutputCommandEvent` â€” received every time the underlying process writes a new line to the output stream (contains the text as a string)\n- `StandardErrorCommandEvent` â€” received every time the underlying process writes a new line to the error stream (contains the text as a string)\n- `ExitedCommandEvent` â€” received just once, when the command finishes executing (contains the exit code)\n\nTo execute a command as a _pull-based_ event stream, use the `ListenAsync()` extension method:\n\n```csharp\nusing CliWrap;\nusing CliWrap.EventStream;\n\nvar cmd = Cli.Wrap(\"foo\").WithArguments([\"bar\"]);\n\nawait foreach (var cmdEvent in cmd.ListenAsync())\n{\n    switch (cmdEvent)\n    {\n        case StartedCommandEvent started:\n            _output.WriteLine($\"Process started; ID: {started.ProcessId}\");\n            break;\n        case StandardOutputCommandEvent stdOut:\n            _output.WriteLine($\"Out> {stdOut.Text}\");\n            break;\n        case StandardErrorCommandEvent stdErr:\n            _output.WriteLine($\"Err> {stdErr.Text}\");\n            break;\n        case ExitedCommandEvent exited:\n            _output.WriteLine($\"Process exited; Code: {exited.ExitCode}\");\n            break;\n    }\n}\n```\n\nThe `ListenAsync()` method starts the command and returns an object of type `IAsyncEnumerable<CommandEvent>`, which you can iterate using the `await foreach` construct introduced in C# 8.\nWhen using this execution model, back pressure is facilitated by locking the pipes between each iteration of the loop, preventing unnecessary buffering of data in-memory.\n\n> **Note**:\n> Just like with `ExecuteBufferedAsync()`, you can specify custom encoding for `ListenAsync()` using one of its overloads.\n\n#### Push-based event stream\n\nSimilarly to the pull-based stream, you can also execute a command as a _push-based_ event stream instead:\n\n```csharp\nusing System.Reactive;\nusing CliWrap;\nusing CliWrap.EventStream;\n\nvar cmd = Cli.Wrap(\"foo\").WithArguments([\"bar\"]);\n\nawait cmd.Observe().ForEachAsync(cmdEvent =>\n{\n    switch (cmdEvent)\n    {\n        case StartedCommandEvent started:\n            _output.WriteLine($\"Process started; ID: {started.ProcessId}\");\n            break;\n        case StandardOutputCommandEvent stdOut:\n            _output.WriteLine($\"Out> {stdOut.Text}\");\n            break;\n        case StandardErrorCommandEvent stdErr:\n            _output.WriteLine($\"Err> {stdErr.Text}\");\n            break;\n        case ExitedCommandEvent exited:\n            _output.WriteLine($\"Process exited; Code: {exited.ExitCode}\");\n            break;\n    }\n});\n```\n\nIn this case, `Observe()` returns a cold `IObservable<CommandEvent>` that represents an observable stream of command events.\nYou can use the set of extensions provided by [Rx.NET](https://github.com/dotnet/reactive) to transform, filter, throttle, or otherwise manipulate this stream.\n\nUnlike the pull-based event stream, this execution model does not involve any back pressure, meaning that the data is pushed to the observer at the rate that it becomes available.\n\n> **Note**:\n> Similarly to `ExecuteBufferedAsync()`, you can specify custom encoding for `Observe()` using one of its overloads.\n\n#### Combining execution models with custom pipes\n\nThe different execution models shown above are based on the piping model, but those two concepts are not mutually exclusive.\nWhen running a command using one of the built-in execution models, existing pipe configurations are preserved and extended using `PipeTarget.Merge(...)`.\n\nThis means that you can, for example, pipe a command to a file and simultaneously execute it as an event stream:\n\n```csharp\nvar cmd =\n    PipeSource.FromFile(\"input.txt\") |\n    Cli.Wrap(\"foo\") |\n    PipeTarget.ToFile(\"output.txt\");\n\n// Iterate as an event stream and pipe to a file at the same time\n// (execution models preserve configured pipes)\nawait foreach (var cmdEvent in cmd.ListenAsync())\n{\n    // ...\n}\n```\n\n### Timeout and cancellation\n\nCommand execution is asynchronous in nature as it involves a completely separate process.\nIn many cases, it may be useful to implement an abortion mechanism to stop the execution before it finishes, either through a manual trigger or a timeout.\n\nTo do that, issue the corresponding [`CancellationToken`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.cancellationtoken) and include it when calling `ExecuteAsync()`:\n\n```csharp\nusing System.Threading;\nusing CliWrap;\n\nusing var cts = new CancellationTokenSource();\n\n// Cancel after a timeout of 10 seconds\ncts.CancelAfter(TimeSpan.FromSeconds(10));\n\nvar result = await Cli.Wrap(\"foo\").ExecuteAsync(cts.Token);\n```\n\nIn the event of a cancellation request, the underlying process will be killed and `ExecuteAsync()` will throw an exception of type `OperationCanceledException` (or its derivative, `TaskCanceledException`).\nYou will need to catch this exception in your code to recover from cancellation:\n\n```csharp\ntry\n{\n    await Cli.Wrap(\"foo\").ExecuteAsync(cts.Token);\n}\ncatch (OperationCanceledException)\n{\n    // Command was canceled\n}\n```\n\nBesides outright killing the process, you can also request cancellation in a more graceful way by sending an interrupt signal.\nTo do that, pass an additional cancellation token to `ExecuteAsync()` that corresponds to that request:\n\n```csharp\nusing var forcefulCts = new CancellationTokenSource();\nusing var gracefulCts = new CancellationTokenSource();\n\n// Cancel forcefully after a timeout of 10 seconds.\n// This serves as a fallback in case graceful cancellation\n// takes too long.\nforcefulCts.CancelAfter(TimeSpan.FromSeconds(10));\n\n// Cancel gracefully after a timeout of 7 seconds.\n// If the process takes too long to respond to graceful\n// cancellation, it will get killed by forceful cancellation\n// 3 seconds later (as configured above).\ngracefulCts.CancelAfter(TimeSpan.FromSeconds(7));\n\nvar result = await Cli.Wrap(\"foo\").ExecuteAsync(forcefulCts.Token, gracefulCts.Token);\n```\n\nRequesting graceful cancellation in **CliWrap** is functionally equivalent to pressing `Ctrl+C` in the console window.\nThe underlying process may handle this signal to perform last-minute critical work before finally exiting on its own terms.\n\nGraceful cancellation is inherently cooperative, so it's possible that the process may take too long to fulfill the request or choose to ignore it altogether.\nIn the above example, this risk is mitigated by additionally scheduling a delayed forceful cancellation that prevents the command from hanging.\n\nIf you are executing a command inside a method and don't want to expose those implementation details to the caller, you can rely on the following pattern to use the provided token for graceful cancellation and extend it with a forceful fallback:\n\n```csharp\npublic async Task GitPushAsync(CancellationToken cancellationToken = default)\n{\n    using var forcefulCts = new CancellationTokenSource();\n\n    // When the cancellation token is triggered,\n    // schedule forceful cancellation as a fallback.\n    await using var link = cancellationToken.Register(() =>\n        forcefulCts.CancelAfter(TimeSpan.FromSeconds(3))\n    );\n\n    await Cli.Wrap(\"git\")\n        .WithArguments([\"push\"])\n        .ExecuteAsync(forcefulCts.Token, cancellationToken);\n}\n```\n\n> **Note**:\n> Similarly to `ExecuteAsync()`, cancellation is also supported by `ExecuteBufferedAsync()`, `ListenAsync()`, and `Observe()`.\n\n### Retrieving process-related information\n\nThe task returned by `ExecuteAsync()` and `ExecuteBufferedAsync()` is, in fact, not a regular `Task<T>`, but an instance of `CommandTask<T>`.\nThis is a specialized awaitable object that contains additional information about the process associated with the executing command:\n\n```csharp\nvar task = Cli.Wrap(\"foo\")\n    .WithArguments([\"bar\"])\n    .ExecuteAsync();\n\n// Get the process ID\nvar processId = task.ProcessId;\n\n// Wait for the task to complete\nawait task;\n```"
        },
        {
          "name": "favicon.png",
          "type": "blob",
          "size": 22.28515625,
          "content": null
        }
      ]
    }
  ]
}