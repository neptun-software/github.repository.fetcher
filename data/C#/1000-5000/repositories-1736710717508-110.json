{
  "metadata": {
    "timestamp": 1736710717508,
    "page": 110,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjExMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "PowerShell/PSReadLine",
      "stars": 3804,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".config",
          "type": "tree",
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.85546875,
          "content": "# External help files\n*.dll-help.xml\n\n# Built binary placed in the root\nPSReadline.zip\n\n# Build Folders (you can keep bin if you'd like, to store dlls and pdbs)\n[Bb]in/\n[Oo]bj/\n.ionide/\n\n# VSCode directories that are not at the repository root\n/**/.vscode/\n\n# mstest test results\nTestResults\nFakesAssemblies/\n\n## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n\n# User-specific files\n*.suo\n*.user\n*.sln.docstates\n\n# Build results\n[Dd]ebug/\n[Rr]elease/\nx64/\n*_i.c\n*_p.c\n*.ilk\n*.meta\n*.obj\n*.pch\n*.pdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.log\n*.vspscc\n*.vssscc\n.builds\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opensdf\n*.sdf\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*\n\n# NCrunch\n*.ncrunch*\n.*crunch*.local.xml\n\n# Installshield output folder \n[Ee]xpress\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish\n\n# Publish Web Output\n*.Publish.xml\n\n# NuGet Packages Directory\npackages\n\n# Windows Azure Build Output\ncsx\n*.build.csdef\n\n# Windows Store app package directory\nAppPackages/\n\n# Others\n[Bb]in\n[Oo]bj\nsql\nTestResults\n[Tt]est[Rr]esult*\n*.Cache\nClientBin\n[Ss]tyle[Cc]op.*\n~$*\n*.dbmdl\nGenerated_Code #added for RIA/Silverlight projects\n*.bak*\nPSReadLine/CopyDLL.cmd\n\n# Backup & report files from converting an old project file to a newer\n# Visual Studio version. Backup files are not needed, because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\n\n#Chocolatey Build Output\nChocolateyPackage/PSReadLine/\n*.nupkg\n\n# gvim swap files\n*.swp\n*.swo\n\n# Visual Studio cache/options directory\n.vs/\n\n# Rider files\n.idea/\n"
        },
        {
          "name": ".pipelines",
          "type": "tree",
          "content": null
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "License.txt",
          "type": "blob",
          "size": 1.26953125,
          "content": "Copyright (c) 2013, Jason Shirk\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met: \n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer. \n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution. \n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "MockPSConsole",
          "type": "tree",
          "content": null
        },
        {
          "name": "PSReadLine.build.ps1",
          "type": "blob",
          "size": 9.705078125,
          "content": "#\n# To build, make sure you've installed InvokeBuild\n#   Install-Module -Repository PowerShellGallery -Name InvokeBuild -RequiredVersion 3.1.0\n#\n# Then:\n#   Invoke-Build\n#\n# Or:\n#   Invoke-Build -Task ZipRelease\n#\n# Or:\n#   Invoke-Build -Configuration Debug\n#\n# etc.\n#\n\n[CmdletBinding()]\nparam(\n    [ValidateSet(\"Debug\", \"Release\")]\n    [string]$Configuration = (property Configuration Release),\n\n    [ValidateSet(\"net462\", \"net6.0\")]\n    [string]$Framework,\n\n    [switch]$CheckHelpContent\n)\n\nImport-Module \"$PSScriptRoot/tools/helper.psm1\"\n\n# Final bits to release go here\n$targetDir = \"bin/$Configuration/PSReadLine\"\n\nif (-not $Framework)\n{\n    $Framework = if ($PSVersionTable.PSEdition -eq \"Core\") { \"net6.0\" } else { \"net462\" }\n}\n\nWrite-Verbose \"Building for '$Framework'\" -Verbose\n\nfunction ConvertTo-CRLF([string] $text) {\n    $text.Replace(\"`r`n\",\"`n\").Replace(\"`n\",\"`r`n\")\n}\n\n$polyFillerParams = @{\n    Inputs = { Get-ChildItem Polyfill/*.cs, Polyfill/Polyfill.csproj }\n    Outputs = \"Polyfill/bin/$Configuration/$Framework/Microsoft.PowerShell.PSReadLine.Polyfiller.dll\"\n}\n\n$binaryModuleParams = @{\n    Inputs  = { Get-ChildItem PSReadLine/*.cs, PSReadLine/PSReadLine.csproj, PSReadLine/PSReadLineResources.resx, Polyfill/*.cs, Polyfill/Polyfill.csproj }\n    Outputs = \"PSReadLine/bin/$Configuration/$Framework/Microsoft.PowerShell.PSReadLine2.dll\"\n}\n\n$xUnitTestParams = @{\n    Inputs = { Get-ChildItem test/*.cs, test/*.json, test/PSReadLine.Tests.csproj }\n    Outputs = \"test/bin/$Configuration/$Framework/PSReadLine.Tests.dll\"\n}\n\n$mockPSConsoleParams = @{\n    Inputs = { Get-ChildItem MockPSConsole/*.cs, MockPSConsole/Program.manifest, MockPSConsole/MockPSConsole.csproj }\n    Outputs = \"MockPSConsole/bin/$Configuration/$Framework/MockPSConsole.dll\"\n}\n\n<#\nSynopsis: Build the Polyfiller assembly\n#>\ntask BuildPolyfiller @polyFillerParams -If ($Framework -eq \"net462\") {\n    ## Build both \"net462\" and \"net6.0\"\n    exec { dotnet publish -f \"net462\" -c $Configuration Polyfill }\n    exec { dotnet publish -f \"net6.0\" -c $Configuration Polyfill }\n}\n\n<#\nSynopsis: Build main binary module\n#>\ntask BuildMainModule @binaryModuleParams {\n    exec { dotnet publish -f $Framework -c $Configuration PSReadLine }\n}\n\n<#\nSynopsis: Build xUnit tests\n#>\ntask BuildXUnitTests @xUnitTestParams {\n    exec { dotnet publish -f $Framework -c $Configuration test }\n}\n\n<#\nSynopsis: Build the mock powershell console.\n#>\ntask BuildMockPSConsole @mockPSConsoleParams {\n    exec { dotnet publish -f $Framework -c $Configuration MockPSConsole }\n}\n\n<#\nSynopsis: Run the unit tests\n#>\ntask RunTests BuildMainModule, BuildXUnitTests, { Start-TestRun -Configuration $Configuration -Framework $Framework }\n\n<#\nSynopsis: Check if the help content is in sync.\n#>\ntask CheckHelpContent -If $CheckHelpContent {\n    # This step loads the dll that was just built, so only do that in another process\n    # so the file isn't locked in any way for the rest of the build.\n    $psExePath = Get-PSExePath\n    & $psExePath -NoProfile -NonInteractive -File $PSScriptRoot/tools/CheckHelp.ps1 $Configuration\n    assert ($LASTEXITCODE -eq 0) \"Checking help and function signatures failed\"\n}\n\n<#\nSynopsis: Copy all of the files that belong in the module to one place in the layout for installation\n#>\ntask LayoutModule BuildPolyfiller, BuildMainModule, {\n    if (-not (Test-Path $targetDir -PathType Container)) {\n        New-Item $targetDir -ItemType Directory -Force > $null\n    }\n\n    $extraFiles =\n        'License.txt',\n        'PSReadLine/Changes.txt',\n        'PSReadLine/SamplePSReadLineProfile.ps1',\n        'PSReadLine/PSReadLine.format.ps1xml',\n        'PSReadLine/PSReadLine.psm1'\n\n    foreach ($file in $extraFiles) {\n        # ensure files have \\r\\n line endings as the signing tool only uses those endings to avoid mixed endings\n        $content = Get-Content -Path $file -Raw\n        Set-Content -Path (Join-Path $targetDir (Split-Path $file -Leaf)) -Value (ConvertTo-CRLF $content) -Force\n    }\n\n    if ($Framework -eq \"net462\") {\n        if (-not (Test-Path \"$targetDir/net462\")) {\n            New-Item \"$targetDir/net462\" -ItemType Directory -Force > $null\n        }\n        if (-not (Test-Path \"$targetDir/net6plus\")) {\n            New-Item \"$targetDir/net6plus\" -ItemType Directory -Force > $null\n        }\n\n        Copy-Item \"Polyfill/bin/$Configuration/net462/Microsoft.PowerShell.PSReadLine.Polyfiller.dll\" \"$targetDir/net462\" -Force\n        Copy-Item \"Polyfill/bin/$Configuration/net6.0/Microsoft.PowerShell.PSReadLine.Polyfiller.dll\" \"$targetDir/net6plus\" -Force\n    }\n\n    $binPath = \"PSReadLine/bin/$Configuration/$Framework/publish\"\n    Copy-Item $binPath/Microsoft.PowerShell.PSReadLine2.dll $targetDir\n    Copy-Item $binPath/Microsoft.PowerShell.Pager.dll $targetDir\n\n    if ($Configuration -eq 'Debug') {\n        Copy-Item $binPath/*.pdb $targetDir\n    }\n\n    if (Test-Path $binPath/System.Runtime.InteropServices.RuntimeInformation.dll) {\n        Copy-Item $binPath/System.Runtime.InteropServices.RuntimeInformation.dll $targetDir\n    } else {\n        Write-Warning \"Build using $Framework is not sufficient to be downlevel compatible\"\n    }\n\n    # Copy module manifest, but fix the version to match what we've specified in the binary module.\n    $moduleManifestContent = ConvertTo-CRLF (Get-Content -Path 'PSReadLine/PSReadLine.psd1' -Raw)\n    $versionInfo = (Get-ChildItem -Path $targetDir/Microsoft.PowerShell.PSReadLine2.dll).VersionInfo\n    $version = $versionInfo.FileVersion\n    $semVer = $versionInfo.ProductVersion\n\n    # dotnet build may add the Git commit hash to the 'ProductVersion' attribute with this format: +<commit-hash>.\n    if ($semVer -match \"(.*)-([^\\+]*)(?:\\+.*)?\") {\n        # Make sure versions match\n        if ($matches[1] -ne $version) { throw \"AssemblyFileVersion mismatch with AssemblyInformationalVersion\" }\n        $prerelease = $matches[2]\n\n        # Put the prerelease tag in private data, along with the project URI.\n        $privateDataSection = \"PrivateData = @{ PSData = @{ Prerelease = '$prerelease'; ProjectUri = 'https://github.com/PowerShell/PSReadLine' } }\"\n    } else {\n        # Put the project URI in private data.\n        $privateDataSection = \"PrivateData = @{ PSData = @{ ProjectUri = 'https://github.com/PowerShell/PSReadLine' } }\"\n    }\n\n    $moduleManifestContent = [regex]::Replace($moduleManifestContent, \"}\", \"${privateDataSection}$([System.Environment]::Newline)}\")\n    $moduleManifestContent = [regex]::Replace($moduleManifestContent, \"ModuleVersion = '.*'\", \"ModuleVersion = '$version'\")\n    $moduleManifestContent | Set-Content -Path $targetDir/PSReadLine.psd1\n\n    # Make sure we don't ship any read-only files\n    foreach ($file in (Get-ChildItem -Recurse -File $targetDir)) {\n        $file.IsReadOnly = $false\n    }\n}, CheckHelpContent\n\n<#\nSynopsis: Zip up the binary for release.\n#>\ntask ZipRelease LayoutModule, {\n    Compress-Archive -Force -LiteralPath $targetDir -DestinationPath \"bin/$Configuration/PSReadLine.zip\"\n}\n\n<#\nSynopsis: Install newly built PSReadLine\n#>\ntask Install LayoutModule, {\n\n    function Install($InstallDir) {\n        if (!(Test-Path -Path $InstallDir))\n        {\n            New-Item -ItemType Directory -Force $InstallDir\n        }\n\n        try\n        {\n            if (Test-Path -Path $InstallDir\\PSReadLine)\n            {\n                Remove-Item -Recurse -Force $InstallDir\\PSReadLine -ErrorAction Stop\n            }\n            Copy-Item -Recurse $targetDir $InstallDir\n        }\n        catch\n        {\n            Write-Error -Message \"Can't install, module is probably in use.\"\n        }\n    }\n\n    Install \"$HOME\\Documents\\WindowsPowerShell\\Modules\"\n    Install \"$HOME\\Documents\\PowerShell\\Modules\"\n}\n\n<#\nSynopsis: Publish to PSGallery\n#>\ntask Publish -If ($Configuration -eq 'Release') {\n\n    $binDir = \"$PSScriptRoot/bin/Release/PSReadLine\"\n\n    # Check signatures before publishing\n    Get-ChildItem -Recurse $binDir -Include \"*.dll\",\"*.ps*1\" | Get-AuthenticodeSignature | ForEach-Object {\n        if ($_.Status -ne 'Valid') {\n            throw \"$($_.Path) is not signed\"\n        }\n        if ($_.SignerCertificate.Subject -notmatch 'CN=Microsoft Corporation.*') {\n            throw \"$($_.Path) is not signed with a Microsoft signature\"\n        }\n    }\n\n    # Check newlines in signed files before publishing\n    Get-ChildItem -Recurse $binDir -Include \"*.ps*1\" | Get-AuthenticodeSignature | ForEach-Object {\n        $lines = (Get-Content $_.Path | Measure-Object).Count\n        $fileBytes = [System.IO.File]::ReadAllBytes($_.Path)\n        $toMatch = ($fileBytes | ForEach-Object { \"{0:X2}\" -f $_ }) -join ';'\n        $crlf = ([regex]::Matches($toMatch, \";0D;0A\") | Measure-Object).Count\n\n        if ($lines -ne $crlf) {\n            throw \"$($_.Path) appears to have mixed newlines\"\n        }\n    }\n\n    $manifest = Import-PowerShellDataFile $binDir/PSReadLine.psd1\n\n    $version = $manifest.ModuleVersion\n    if ($null -ne $manifest.PrivateData)\n    {\n        $psdata = $manifest.PrivateData['PSData']\n        if ($null -ne $psdata)\n        {\n            $prerelease = $psdata['Prerelease']\n            if ($null -ne $prerelease)\n            {\n                $version = $version + '-' + $prerelease\n            }\n        }\n    }\n\n    $yes = Read-Host \"Publish version $version (y/n)\"\n\n    if ($yes -ne 'y') { throw \"Publish aborted\" }\n\n    $nugetApiKey = Read-Host -AsSecureString \"Nuget api key for PSGallery\"\n\n    $publishParams = @{\n        Path = $binDir\n        NuGetApiKey = [PSCredential]::new(\"user\", $nugetApiKey).GetNetworkCredential().Password\n        Repository = \"PSGallery\"\n        ReleaseNotes = (Get-Content -Raw $binDir/Changes.txt)\n        ProjectUri = 'https://github.com/PowerShell/PSReadLine'\n    }\n\n    Publish-Module @publishParams\n}\n\n<#\nSynopsis: Remove temporary items.\n#>\ntask Clean {\n    git clean -fdx\n}\n\n<#\nSynopsis: Default build rule - build and create module layout\n#>\ntask . LayoutModule, RunTests\n"
        },
        {
          "name": "PSReadLine",
          "type": "tree",
          "content": null
        },
        {
          "name": "Polyfill",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.3818359375,
          "content": "[![appveyor-build-status][]][appveyor-build-site]\n\n[appveyor-build-status]: https://ci.appveyor.com/api/projects/status/9mygtkr9fkov47xv/branch/master?svg=true\n[appveyor-build-site]: https://ci.appveyor.com/project/PowerShell/PSReadLine?branch=master\n\n<!--\n[![azure-build-status][]][azure-build-site]\n[azure-build-status]: https://lzybkr.visualstudio.com/AzurePipelines/_apis/build/status/PSReadLine%20Azure%20Pipeline\n[azure-build-site]: https://lzybkr.visualstudio.com/AzurePipelines/_build/latest?definitionId=6\n-->\n\n# PSReadLine\n\nThis module replaces the command line editing experience of PowerShell for versions 3 and up.\nIt provides:\n\n* Syntax coloring\n* Simple syntax error notification\n* A good multi-line experience (both editing and history)\n* Customizable key bindings\n* Cmd and emacs modes (neither are fully implemented yet, but both are usable)\n* Many configuration options\n* Bash style completion (optional in Cmd mode, default in Emacs mode)\n* Bash/zsh style interactive history search (CTRL-R)\n* Emacs yank/kill ring\n* PowerShell token based \"word\" movement and kill\n* Undo/redo\n* Automatic saving of history, including sharing history across live sessions\n* \"Menu\" completion (somewhat like Intellisense, select completion with arrows) via Ctrl+Space\n\nThe \"out of box\" experience is meant to be very familiar to PowerShell users - there should be no need to learn any new key strokes.\n\nSome good resources about `PSReadLine`:\n\n- Keith Hill wrote a [great introduction](https://rkeithhill.wordpress.com/2013/10/18/psreadline-a-better-line-editing-experience-for-the-powershell-console/) (2013) to `PSReadLine`.\n- Ed Wilson (Scripting Guy) wrote a [series](https://devblogs.microsoft.com/scripting/tag/psreadline/) (2014-2015) on `PSReadLine`.\n- John Savill has a [video](https://www.youtube.com/watch?v=Q11sSltuTE0) (2021) covering installation, configuration, and tailoring `PSReadLine` to your liking.\n\n## Installation\n\nThere are multiple ways to install `PSReadLine`.\n\n### Install from PowerShellGallery (preferred)\n\nYou will need the `1.6.0` or a higher version of [`PowerShellGet`](https://learn.microsoft.com/en-us/powershell/gallery/powershellget/install-powershellget) to install the latest prerelease version of `PSReadLine`.\n\nWindows PowerShell 5.1 ships an older version of `PowerShellGet` which doesn't support installing prerelease modules,\nso Windows PowerShell users need to install the latest `PowerShellGet` (if not yet) by running the following commands from an elevated Windows PowerShell session:\n\n```powershell\nInstall-Module -Name PowerShellGet -Force\nExit\n```\n\nAfter installing `PowerShellGet`, you can get the latest prerelease version of `PSReadLine` by running\n\n```powershell\nInstall-Module PSReadLine -AllowPrerelease -Force\n```\n\nIf you only want to get the latest stable version, run:\n\n```powershell\nInstall-Module PSReadLine\n```\n\n>[!NOTE] Prerelease versions will have newer features and bug fixes, but may also introduce new issues.\n\nIf you are using Windows PowerShell on Windows 10 or using PowerShell 6+, `PSReadLine` is already installed.\nWindows PowerShell on the latest Windows 10 has version `2.0.0-beta2` of `PSReadLine`.\nPowerShell 6+ versions have the newer prerelease versions of `PSReadLine`.\n\n### Install from GitHub (deprecated)\n\nWith the preview release of PowerShellGet for PowerShell V3/V4, downloads from GitHub are deprecated.\nWe don't intend to update releases on GitHub, and may remove the release entirely from GitHub at some point.\n\n### Post Installation\n\nIf you are using Windows PowerShell V5 or V5.1 versions, or using PowerShell 6+ versions, you are good to go and can skip this section.\n\nOtherwise, you need to edit your profile to import the module.\nThere are two profile files commonly used and the instructions are slightly different for each.\nThe file `C:\\Users\\[User]\\Documents\\WindowsPowerShell\\profile.ps1` is used for all hosts (e.g. the `ISE` and `powershell.exe`).\nIf you already have this file, then you should add the following:\n\n```powershell\nif ($host.Name -eq 'ConsoleHost')\n{\n    Import-Module PSReadLine\n}\n```\n\nAlternatively, the file `C:\\Users\\[User]\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1` is for `powershell.exe` only.  Using this file, you can simply add:\n\n```powershell\nImport-Module PSReadLine\n```\n\nIn either case, you can create the appropriate file if you don't already have one.\n\n## Upgrading\n\nWhen running one of the suggested commands below, be sure to exit all instances of `powershell.exe`, `pwsh.exe` or `pwsh`,\nincluding those opened in `VSCode` terminals.\n\nThen, to make sure `PSReadLine` isn't loaded:\n- _if you are on Windows_, run the suggested command below from `cmd.exe`, `powershell_ise.exe`, or via the `Win+R` shortcut;\n- _if you are on Linux/macOS_, run the suggested command below from the default terminal (like `bash` or `zsh`).\n\n\nIf you are using the version of `PSReadLine` that ships with Windows PowerShell,\nyou need to run: `powershell -noprofile -command \"Install-Module PSReadLine -Force -SkipPublisherCheck -AllowPrerelease\"`.\nNote: you will need to make sure [PowershellGet is updated](https://github.com/PowerShell/PSReadLine#install-from-powershellgallery-preferred) before running this command.\n\nIf you are using the version of `PSReadLine` that ships with PowerShell 6+ versions,\nyou need to run: `<path-to-pwsh-executable> -noprofile -command \"Install-Module PSReadLine -Force -SkipPublisherCheck -AllowPrerelease\"`.\n\nIf you've installed `PSReadLine` yourself from the PowerShell Gallery,\nyou can simply run: `powershell -noprofile -command \"Update-Module PSReadLine -AllowPrerelease\"` or\n`<path-to-pwsh-executable> -noprofile -command \"Update-Module PSReadLine -AllowPrerelease\"`,\ndepending on the version of PowerShell you are using.\n\nIf you get an error like:\n\n```none\nRemove-Item : Cannot remove item\nC:\\Users\\{yourName}\\Documents\\WindowsPowerShell\\Modules\\PSReadLine\\Microsoft.PowerShell.PSReadLine.dll: Access to the path\n'C:\\Users\\{yourName}\\Documents\\WindowsPowerShell\\Modules\\PSReadLine\\Microsoft.PowerShell.PSReadLine.dll' is denied.\n```\n\nor a warning like:\n\n```none\nWARNING: The version '2.0.0' of module 'PSReadLine' is currently in use. Retry the operation after closing the applications.\n```\n\nThen you didn't kill all the processes that loaded `PSReadLine`.\n\n## Usage\n\nTo start using, just import the module:\n\n```powershell\nImport-Module PSReadLine\n```\n\nTo use Emacs key bindings, you can use:\n\n```powershell\nSet-PSReadLineOption -EditMode Emacs\n```\n\nTo view the current key bindings:\n\n```powershell\nGet-PSReadLineKeyHandler\n```\n\nThere are many configuration options, see the options to `Set-PSReadLineOption`.  `PSReadLine` has help for it's cmdlets as well as an `about_PSReadLine` topic - see those topics for more detailed help.\n\nTo set your own custom keybindings, use the cmdlet `Set-PSReadLineKeyHandler`. For example, for a better history experience, try:\n\n```powershell\nSet-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward\nSet-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward\n```\n\nWith these bindings, up arrow/down arrow will work like PowerShell/cmd if the current command line is blank.  If you've entered some text though, it will search the history for commands that start with the currently entered text.\n\nTo enable bash style completion without using Emacs mode, you can use:\n\n```powershell\nSet-PSReadLineKeyHandler -Key Tab -Function Complete\n```\n\nHere is a more interesting example of what is possible:\n\n```powershell\nSet-PSReadLineKeyHandler -Chord '\"',\"'\" `\n                         -BriefDescription SmartInsertQuote `\n                         -LongDescription \"Insert paired quotes if not already on a quote\" `\n                         -ScriptBlock {\n    param($key, $arg)\n\n    $line = $null\n    $cursor = $null\n    [Microsoft.PowerShell.PSConsoleReadLine]::GetBufferState([ref]$line, [ref]$cursor)\n\n    if ($line.Length -gt $cursor -and $line[$cursor] -eq $key.KeyChar) {\n        # Just move the cursor\n        [Microsoft.PowerShell.PSConsoleReadLine]::SetCursorPosition($cursor + 1)\n    }\n    else {\n        # Insert matching quotes, move cursor to be in between the quotes\n        [Microsoft.PowerShell.PSConsoleReadLine]::Insert(\"$($key.KeyChar)\" * 2)\n        [Microsoft.PowerShell.PSConsoleReadLine]::GetBufferState([ref]$line, [ref]$cursor)\n        [Microsoft.PowerShell.PSConsoleReadLine]::SetCursorPosition($cursor - 1)\n    }\n}\n```\n\nIn this example, when you type a single quote or double quote, there are two things that can happen.  If the character following the cursor is not the quote typed, then a matched pair of quotes is inserted and the cursor is placed inside the the matched quotes.  If the character following the cursor is the quote typed, the cursor is simply moved past the quote without inserting anything.  If you use Resharper or another smart editor, this experience will be familiar.\n\nNote that with the handler written this way, it correctly handles Undo - both quotes will be undone with one undo.\n\nThe [sample profile file](https://github.com/PowerShell/PSReadLine/blob/master/PSReadLine/SamplePSReadLineProfile.ps1) has a bunch of great examples to check out.  This file is included when `PSReadLine` is installed.\n\nSee the public methods of `[Microsoft.PowerShell.PSConsoleReadLine]` to see what other built-in functionality you can modify.\n\nIf you want to change the command line in some unimplmented way in your custom key binding, you can use the methods:\n\n```powershell\n    [Microsoft.PowerShell.PSConsoleReadLine]::GetBufferState\n    [Microsoft.PowerShell.PSConsoleReadLine]::Insert\n    [Microsoft.PowerShell.PSConsoleReadLine]::Replace\n    [Microsoft.PowerShell.PSConsoleReadLine]::SetCursorPosition\n```\n\n## Developing and Contributing\n\nPlease see the [Contribution Guide][] for how to develop and contribute.\n\n### Building\n\nTo build `PSReadLine` on Windows, Linux, or macOS,\nyou must have the following installed:\n\n* .NET Core SDK 2.1.802 or [a newer version](https://www.microsoft.com/net/download)\n* The PowerShell modules `InvokeBuild` and `platyPS`\n\nThe build script `build.ps1` can be used to bootstrap, build and test the project.\n\n* Bootstrap: `./build.ps1 -Bootstrap`\n* Build:\n    * Targeting .NET 4.6.2 (Windows only): `./build.ps1 -Configuration Debug -Framework net462`\n    * Targeting .NET Core: `./build.ps1 -Configuration Debug -Framework netcoreapp2.1`\n* Test:\n    * Targeting .NET 4.6.2 (Windows only): `./build.ps1 -Test -Configuration Debug -Framework net462`\n    * Targeting .NET Core: `./build.ps1 -Test -Configuration Debug -Framework netcoreapp2.1`\n\nAfter build, the produced artifacts can be found at `<your-local-repo-root>/bin/Debug`.\nIn order to isolate your imported module to the one locally built, be sure to run \n`pwsh -NonInteractive -NoProfile` to not automatically load the default PSReadLine module installed.\nThen, load the locally built PSReadLine module by `Import-Module <your-local-repo-root>/bin/Debug/PSReadLine/PSReadLine.psd1`.\n\n[Contribution Guide]: https://github.com/PowerShell/PSReadLine/blob/master/.github/CONTRIBUTING.md\n\n## Change Log\n\nThe change log is available [here](https://github.com/PowerShell/PSReadLine/blob/master/PSReadLine/Changes.txt).\n\n## Licensing\n\nPSReadLine is licensed under the [2-Clause BSD License][].\n\n[2-Clause BSD License]: https://github.com/PowerShell/PSReadLine/blob/master/License.txt\n\n## Code of Conduct\n\nPlease see our [Code of Conduct](.github/CODE_OF_CONDUCT.md) before participating in this project.\n\n## Security Policy\n\nFor any security issues, please see our [Security Policy](.github/SECURITY.md).\n"
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 0.650390625,
          "content": "\nimage: Visual Studio 2022\n\nenvironment:\n  POWERSHELL_TELEMETRY_OPTOUT: 1\n  # Avoid expensive initialization of dotnet cli, see: http://donovanbrown.com/post/Stop-wasting-time-during-NET-Core-builds\n  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1\n  PSREADLINE_TESTRUN: 1\n\ncache:\n  - '%HOMEDRIVE%%HOMEPATH%\\.nuget\\packages -> tools\\helper.psm1'\n\ninstall:\n  - pwsh: |\n      Write-Host \"PS Version: $($PSVersionTable.PSVersion)\"\n      ./build.ps1 -Bootstrap\n\nbuild_script:\n  - pwsh: |\n      ./build.ps1 -Configuration Release -Framework net462\n\ntest_script:\n  - pwsh: ./build.ps1 -Test -Configuration Release -Framework net462\n\nartifacts:\n  - path: .\\bin\\Release\\PSReadLine.zip\n"
        },
        {
          "name": "build.ps1",
          "type": "blob",
          "size": 2.6796875,
          "content": "<#\n.SYNOPSIS\n    A script that provides simple entry points for bootstrapping, building and testing.\n.DESCRIPTION\n    A script to make it easy to bootstrap, build and run tests.\n.EXAMPLE\n    PS > .\\build.ps1 -Bootstrap\n    Check and install prerequisites for the build.\n.EXAMPLE\n    PS > .\\build.ps1 -Configuration Release -Framework net462\n    Build the main module with 'Release' configuration and targeting 'net462'.\n.EXAMPLE\n    PS > .\\build.ps1\n    Build the main module with the default configuration (Debug) and the default target framework (determined by the current session).\n.EXAMPLE\n    PS > .\\build.ps1 -Test\n    Run xUnit tests with the default configuration (Debug) and the default target framework (determined by the current session).\n.PARAMETER Clean\n    Clean the local repo, but keep untracked files.\n.PARAMETER Bootstrap\n    Check and install the build prerequisites.\n.PARAMETER Test\n    Run tests.\n.PARAMETER Configuration\n    The configuration setting for the build. The default value is 'Debug'.\n.PARAMETER Framework\n    The target framework for the build.\n    When not specified, the target framework is determined by the current PowerShell session:\n    - If the current session is PowerShell Core, then use 'netcoreapp3.1' as the default target framework.\n    - If the current session is Windows PowerShell, then use 'net462' as the default target framework.\n#>\n[CmdletBinding()]\nparam(\n    [switch] $Clean,\n    [switch] $Bootstrap,\n    [switch] $Test,\n    [switch] $CheckHelpContent,\n\n    [ValidateSet(\"Debug\", \"Release\")]\n    [string] $Configuration = \"Debug\",\n\n    [ValidateSet(\"net462\", \"net6.0\")]\n    [string] $Framework\n)\n\n# Clean step\nif ($Clean) {\n    try {\n        Push-Location $PSScriptRoot\n        git clean -fdX\n        return\n    } finally {\n        Pop-Location\n    }\n}\n\nImport-Module \"$PSScriptRoot/tools/helper.psm1\"\n\nif ($Bootstrap) {\n    Write-Log \"Validate and install missing prerequisites for building ...\"\n\n    Install-Dotnet\n    if (-not (Get-Module -Name InvokeBuild -ListAvailable)) {\n        Write-Log -Warning \"Module 'InvokeBuild' is missing. Installing 'InvokeBuild' ...\"\n        Install-Module -Name InvokeBuild -Scope CurrentUser -Force\n    }\n\n    return\n}\n\n# Common step required by both build and test\nFind-Dotnet\nif (-not (Get-Module -Name InvokeBuild -ListAvailable)) {\n    throw \"Cannot find the 'InvokeBuild' module. Please specify '-Bootstrap' to install build dependencies.\"\n}\n\n# Build/Test step\n$buildTask = if ($Test) { \"RunTests\" } else { \"ZipRelease\" }\n$arguments = @{ Task = $buildTask; Configuration = $Configuration }\n\nif ($Framework) { $arguments.Add(\"Framework\", $Framework) }\nif ($CheckHelpContent) { $arguments.Add(\"CheckHelpContent\", $true) }\n\nInvoke-Build @arguments\n"
        },
        {
          "name": "nuget.config",
          "type": "blob",
          "size": 0.3291015625,
          "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<configuration>\n  <packageSources>\n    <clear />\n    <add key=\"PowerShell_PublicPackages\" value=\"https://pkgs.dev.azure.com/powershell/PowerShell/_packaging/powershell/nuget/v3/index.json\" />\n  </packageSources>\n  <disabledPackageSources>\n    <clear />\n  </disabledPackageSources>\n</configuration>\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}