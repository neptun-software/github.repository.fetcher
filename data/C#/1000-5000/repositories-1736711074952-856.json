{
  "metadata": {
    "timestamp": 1736711074952,
    "page": 856,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "eladshamir/Internal-Monologue",
      "stars": 1457,
      "defaultBranch": "master",
      "files": [
        {
          "name": "InternalMonologue.sln",
          "type": "blob",
          "size": 2.203125,
          "content": "﻿\r\nMicrosoft Visual Studio Solution File, Format Version 12.00\r\n# Visual Studio 15\r\nVisualStudioVersion = 15.0.27004.2009\r\nMinimumVisualStudioVersion = 10.0.40219.1\r\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"InternalMonologueExe\", \"InternalMonologueExe\\InternalMonologueExe.csproj\", \"{0C0333DB-8F00-4B68-B1DB-18A9CACC1486}\"\r\nEndProject\r\nProject(\"{D954291E-2A0B-460D-934E-DC6B0785DB48}\") = \"InternalMonologue\", \"InternalMonologue\\InternalMonologue.shproj\", \"{1E4CF34F-887B-4D47-8EC8-AD1EC6FEDA88}\"\r\nEndProject\r\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"InternalMonologueDll\", \"InternalMonologueDll\\InternalMonologueDll.csproj\", \"{84701ACE-C584-4886-A3CF-76C57F6E801A}\"\r\nEndProject\r\nGlobal\r\n\tGlobalSection(SharedMSBuildProjectFiles) = preSolution\r\n\t\tInternalMonologue\\InternalMonologue.projitems*{0c0333db-8f00-4b68-b1db-18a9cacc1486}*SharedItemsImports = 4\r\n\t\tInternalMonologue\\InternalMonologue.projitems*{1e4cf34f-887b-4d47-8ec8-ad1ec6feda88}*SharedItemsImports = 13\r\n\t\tInternalMonologue\\InternalMonologue.projitems*{84701ace-c584-4886-a3cf-76c57f6e801a}*SharedItemsImports = 4\r\n\tEndGlobalSection\r\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\r\n\t\tDebug|Any CPU = Debug|Any CPU\r\n\t\tRelease|Any CPU = Release|Any CPU\r\n\tEndGlobalSection\r\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\r\n\t\t{0C0333DB-8F00-4B68-B1DB-18A9CACC1486}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{0C0333DB-8F00-4B68-B1DB-18A9CACC1486}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{0C0333DB-8F00-4B68-B1DB-18A9CACC1486}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{0C0333DB-8F00-4B68-B1DB-18A9CACC1486}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{84701ACE-C584-4886-A3CF-76C57F6E801A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{84701ACE-C584-4886-A3CF-76C57F6E801A}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{84701ACE-C584-4886-A3CF-76C57F6E801A}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{84701ACE-C584-4886-A3CF-76C57F6E801A}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\tEndGlobalSection\r\n\tGlobalSection(SolutionProperties) = preSolution\r\n\t\tHideSolutionNode = FALSE\r\n\tEndGlobalSection\r\n\tGlobalSection(ExtensibilityGlobals) = postSolution\r\n\t\tSolutionGuid = {54B2C995-B775-4961-BAF0-D2BD4CF07B91}\r\n\tEndGlobalSection\r\nEndGlobal\r\n"
        },
        {
          "name": "InternalMonologue",
          "type": "tree",
          "content": null
        },
        {
          "name": "InternalMonologueDll",
          "type": "tree",
          "content": null
        },
        {
          "name": "InternalMonologueExe",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.1298828125,
          "content": "# Internal Monologue Attack: Retrieving NTLM Hashes without Touching LSASS\r\n\r\n## Introduction\r\nMimikatz, developed by Benjamin Delpy (@gentilkiwi), is a well-regarded post-exploitation tool, which allows adversaries to extract plain text passwords, NTLM hashes and Kerberos tickets from memory, as well as perform attacks such as pass-the-hash, pass-the-ticket or build a golden ticket. Arguably, the primary use of Mimikatz is retrieving user credentials from LSASS process memory for use in post exploitation lateral movement.\r\n\r\nRecently, Microsoft has introduced Credential Guard in Windows 10 Enterprise and Windows Server 2016, which uses virtualization-based security to isolate secrets, and it is very effective in preventing Mimikatz from retrieving hashes directly from memory.\r\nAlso, Mimikatz has become a prime target of most endpoint protection solutions, and they are very aggressive in their efforts to detect and prevent it. Although these efforts are bound to fail, they are increasingly becoming a nuisance.\r\n\r\n## NetNTLM\r\nNetNTLM is Windows’ challenge-response protocol that is mainly used where Kerberos is not supported. In NetNTLM, the server sends to the client a random 8-byte nonce as a challenge, and the client calculates a response that processes the challenge with the NTLM hash as the key, which is the MD4 hash of the user’s password. There are two versions of the NetNTLM authentication protocol, and both are vulnerable to certain attacks. Naturally, version 1 is significantly weaker than version 2, and therefore as of Windows Vista/2008 NetNTLM version 1 is disabled by default.\r\n\r\n\r\n## Pass the Hash\r\nBecause the NTLM hash is the key to calculating the response, an adversary does not necessarily need to obtain the victim’s plain text password to authenticate, hence retrieving the hash from LSASS memory using Mimikatz is almost equivalent to stealing a plain text password. \r\nChris Hummel has published an article describing this technique in 2009 and named it “Pass the Hash” [https://www.sans.org/reading-room/whitepapers/testing/crack-pass-hash-33219].\r\n\r\n## Divide and Conquer\r\nAt Defcon 2012, Moxie Marlinspike and David Hulton presented a “Divide and Conquer” attack against NetNTLMv1 [https://www.youtube.com/watch?v=sIidzPntdCM]. In NetNTLMv1, the client receives the 8-byte challenge and calculates the response by encrypting it three times using DES with the different parts of the NTLM hash as the key. The key length for DES is effectively 56 bits, which is 7 bytes, while the NTLM hash is 16 bytes. NetNTLMv1 first encrypts the challenge using the first 7 bytes of the NTLM hash as the key, then encrypts the challenge using the next 7 bytes of the NTLM hash as the key, and finally encrypts the challenge using the last 2 bytes of the NTLM hash padded with null-bytes as the key. Effectively, this means that to retrieve the NTLM hash given a NetNTLMv1 challenge and response, an adversary must crack two 56-bit DES keys, which is exponentially easier than cracking a single 128-bit key.\r\nMoxie and Hulton developed custom hardware for this task and were able to brute-force the entire DES keyspace in less than 24 hours, which guarantees the successful retrieval of the NTLM hash within a reasonable time.\r\nNote that unlike dictionary or brute force attacks against the password, which may not be fruitful, this attack guarantees the successful retrieval of the NTLM hash.\r\n\r\n\r\n## Rainbow Tables\r\nAs demonstrated by ToorCon at https://crack.sh, it is feasible to create a complete rainbow table for all the possible NetNTLMv1 responses to a chosen challenge, such as 0x1122334455667788, which allows cracking the NTLM hash for a given response within minutes. The implication is that capturing a NetNTLMv1 response for the chosen challenge can be translated to the corresponding NTLM hash almost instantly, which is almost the equivalent to obtaining the password due to Pass the Hash.\r\n\r\n## NetNTLM Downgrade Attack\r\nMimikatz is commonly executed after the adversary has gained elevated access to the target host. At this point, the adversary can also change registry keys, such as LMCompatibilityLevel, which specifies whether the host should negotiate NetNTLMv1 or NetNTLMv2. The adversary can change the value to 0, 1 or 2, which enable NetNTLMv1 as a client, and then try to authenticate to a rogue SMB server that will capture the client’s response, as described in Optiv’s blog post [https://www.optiv.com/blog/post-exploitation-using-netntlm-downgrade-attacks].\r\n\r\n## Extended NetNTLM Downgrade Attack\r\nTwo more settings may stop the victim from negotiating a NetNTLMv1 response:\r\n1. NTLMMinClientSec - if configured to \"Require NTLMv2 session security\", the connection will fail if NTLMv2 protocol is not negotiated.\r\n2. RestrictSendingNTLMTraffic - if configured to \"Deny all,\" the client computer cannot authenticate to a remote server with NetNTLM of any version.\r\nSimilarly to the NetNTLM Downgrade attack, these settings can be changed if necessary. Note that unlike LMCompatibilityLevel, these settings are not configured by default to block NetNTLMv1 authentication.\r\n\r\n## Internal Monologue Attack\r\nIn secure environments, where Mimikatz should not be executed, an adversary can perform an Internal Monologue Attack, in which they invoke a local procedure call to the NTLM authentication package (MSV1_0) from a user-mode application through SSPI to calculate a NetNTLM response in the context of the logged on user, after performing an extended NetNTLM downgrade.\r\n\r\nThe Internal Monologue Attack flow is described below:\r\n1. Disable NetNTLMv1 preventive controls by changing LMCompatibilityLevel, NTLMMinClientSec and RestrictSendingNTLMTraffic to appropriate values, as described above.\r\n2. Retrieve all non-network logon tokens from currently running processes and impersonate the associated users.\r\n3. For each impersonated user, interact with NTLM SSP locally to elicit a NetNTLMv1 response to the chosen challenge in the security context of the impersonated user.\r\n4. Restore the original values of LMCompatibilityLevel, NTLMMinClientSec and RestrictSendingNTLMTraffic.\r\n5. Crack the NTLM hash of the captured responses using rainbow tables.\r\n6. Pass the Hash.\r\n\r\n## Update: Credential Guard Compatibility\r\nI have recently retested Internal Monologue in environments with Credential Guard enabled and got negative results. I am not sure whether Credential Guard was not working properly in my test environment during the initial tests, or perhaps something changed since then.\r\nI updated the implementation to acquire a server token from AcceptSecurityContext dynamically and tamper with it to avoid the local authentication trap, so that if NetNTLMv1 without Extended Session Security fails, at least a NetNTLMv2 challenge-response can be captured.\r\n\r\n## Audit Trail\r\nThe Internal Monologue Attack is arguably stealthier than running Mimikatz because there is no need to inject code or dump memory to/from a protected process.\r\nBecause the NetNTLMv1 response is elicited by interacting with NTLM SSP locally, no network traffic is generated, and the chosen challenge is not easily visible.\r\nNo successful NTLM authentication event is recorded in the logs.\r\nThe registry changes for the NetNTLM downgrade and stealing tokens/impersonating other users may trip indicators.\r\n\r\n## Proof of Concept\r\nThis tool is a proof of concept that implements the Internal Monologue Attack in C#. Porting the code to PowerShell may substitute certain event logs in the audit trail with others.\r\nThe PoC code is far from perfect. Positive contributions and improvements are welcome.\r\n\r\n## Author\r\nElad Shamir from The Missing Link Security\r\n\r\n## Acknowledgements\r\n* Matthew Bush (3xocyte) from The Missing Link Security and Shaun Williamson (AusJock) from Beyond Binary for helping bounce off ideas and put this together\r\n* Moxie Marlinspike and David Hulton for their talk “Defeating PPTP VPNs and WPA2 Enterprise with MS-CHAPv2” at Defcon 20\r\n* Optiv for the NetNTLM Downgrade Attack\r\n* Bialek Joseph (clymb3r) for Invoke-TokenManupilation \r\n* MWR Labs for Incognito\r\n* Anton Sapozhnikov (snowytoxa) for Selfhash\r\n* Tim Malcom Vetter (malcomvetter) for multiple improvements\r\n* Marcello Salvati (byt3bl33d3r) for the DLL library addition\r\n"
        }
      ]
    }
  ]
}