{
  "metadata": {
    "timestamp": 1736710987992,
    "page": 683,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "TeamSirenix/odin-serializer",
      "stars": 1722,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 5.0322265625,
          "content": "# Created by https://www.gitignore.io/api/visualstudio\n\n### VisualStudio ###\n## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n##\n## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore\n\n# User-specific files\n*.suo\n*.user\n*.userosscache\n*.sln.docstates\n\n# User-specific files (MonoDevelop/Xamarin Studio)\n*.userprefs\n\n# Build results\n[Dd]ebug/\n[Dd]ebugPublic/\n[Rr]elease/\n[Rr]eleases/\nx64/\nx86/\nbld/\n[Bb]in/\n[Oo]bj/\n[Ll]og/\n[Ii]gnore/\n\n# Visual Studio 2015 cache/options directory\n.vs/\n# Uncomment if you have tasks that create the project's static files in wwwroot\n#wwwroot/\n\n# MSTest test Results\n[Tt]est[Rr]esult*/\n[Bb]uild[Ll]og.*\n\n# NUNIT\n*.VisualState.xml\nTestResult.xml\n\n# Build Results of an ATL Project\n[Dd]ebugPS/\n[Rr]eleasePS/\ndlldata.c\n\n# .NET Core\nproject.lock.json\nproject.fragment.lock.json\nartifacts/\n**/Properties/launchSettings.json\n\n*_i.c\n*_p.c\n*_i.h\n*.ilk\n*.obj\n*.pch\n#*.pdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.tmp_proj\n*.log\n*.vspscc\n*.vssscc\n.builds\n*.pidb\n*.svclog\n*.scc\n\n# Chutzpah Test files\n_Chutzpah*\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opendb\n*.opensdf\n*.sdf\n*.cachefile\n*.VC.db\n*.VC.VC.opendb\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n*.sap\n\n# TFS 2012 Local Workspace\n$tf/\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*/\n*.[Rr]e[Ss]harper\n*.DotSettings.user\n\n# JustCode is a .NET coding add-in\n.JustCode\n\n# TeamCity is a build add-in\n_TeamCity*\n\n# DotCover is a Code Coverage Tool\n*.dotCover\n\n# Visual Studio code coverage results\n*.coverage\n*.coveragexml\n\n# NCrunch\n_NCrunch_*\n.*crunch*.local.xml\nnCrunchTemp_*\n\n# MightyMoose\n*.mm.*\nAutoTest.Net/\n\n# Web workbench (sass)\n.sass-cache/\n\n# Installshield output folder\n[Ee]xpress/\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish/\n\n# Publish Web Output\n*.[Pp]ublish.xml\n*.azurePubxml\n# TODO: Uncomment the next line to ignore your web deploy settings.\n# By default, sensitive information, such as encrypted password\n# should be stored in the .pubxml.user file.\n#*.pubxml\n*.pubxml.user\n*.publishproj\n\n# Microsoft Azure Web App publish settings. Comment the next line if you want to\n# checkin your Azure Web App publish settings, but sensitive information contained\n# in these scripts will be unencrypted\nPublishScripts/\n\n# NuGet Packages\n*.nupkg\n# The packages folder can be ignored because of Package Restore\n**/packages/*\n# except build/, which is used as an MSBuild target.\n!**/packages/build/\n# Uncomment if necessary however generally it will be regenerated when needed\n#!**/packages/repositories.config\n# NuGet v3's project.json files produces more ignorable files\n*.nuget.props\n*.nuget.targets\n\n# Microsoft Azure Build Output\ncsx/\n*.build.csdef\n\n# Microsoft Azure Emulator\necf/\nrcf/\n\n# Windows Store app package directories and files\nAppPackages/\nBundleArtifacts/\nPackage.StoreAssociation.xml\n_pkginfo.txt\n\n# Visual Studio cache files\n# files ending in .cache can be ignored\n*.[Cc]ache\n# but keep track of directories ending in .cache\n!*.[Cc]ache/\n\n# Others\nClientBin/\n~$*\n*~\n*.dbmdl\n*.dbproj.schemaview\n*.jfm\n*.pfx\n*.publishsettings\norleans.codegen.cs\n\n# Since there are multiple workflows, uncomment next line to ignore bower_components\n# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)\n#bower_components/\n\n# RIA/Silverlight projects\nGenerated_Code/\n\n# Backup & report files from converting an old project file\n# to a newer Visual Studio version. Backup files are not needed,\n# because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\nUpgradeLog*.htm\n\n# SQL Server files\n*.mdf\n*.ldf\n*.ndf\n\n# Business Intelligence projects\n*.rdl.data\n*.bim.layout\n*.bim_*.settings\n\n# Microsoft Fakes\nFakesAssemblies/\n\n# GhostDoc plugin setting file\n*.GhostDoc.xml\n\n# Node.js Tools for Visual Studio\n.ntvs_analysis.dat\nnode_modules/\n\n# Typescript v1 declaration files\ntypings/\n\n# Visual Studio 6 build log\n*.plg\n\n# Visual Studio 6 workspace options file\n*.opt\n\n# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)\n*.vbw\n\n# Visual Studio LightSwitch build output\n**/*.HTMLClient/GeneratedArtifacts\n**/*.DesktopClient/GeneratedArtifacts\n**/*.DesktopClient/ModelManifest.xml\n**/*.Server/GeneratedArtifacts\n**/*.Server/ModelManifest.xml\n_Pvt_Extensions\n\n# Paket dependency manager\n.paket/paket.exe\npaket-files/\n\n# FAKE - F# Make\n.fake/\n\n# JetBrains Rider\n.idea/\n*.sln.iml\n\n# CodeRush\n.cr/\n\n# Python Tools for Visual Studio (PTVS)\n__pycache__/\n*.pyc\n\n# Cake - Uncomment if you are using it\n# tools/**\n# !tools/packages.config\n\n# Telerik's JustMock configuration file\n*.jmconfig\n\n# BizTalk build output\n*.btp.cs\n*.btm.cs\n*.odx.cs\n*.xsd.cs\n\n### VisualStudio Patch ###\n# By default, sensitive information, such as encrypted password\n# should be stored in the .pubxml.user file.\n\n\n# End of https://www.gitignore.io/api/visualstudio\nBuild/.vsconfig\n"
        },
        {
          "name": "Build",
          "type": "tree",
          "content": null
        },
        {
          "name": "Images",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 9.93359375,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS"
        },
        {
          "name": "Libraries",
          "type": "tree",
          "content": null
        },
        {
          "name": "OdinSerializer.sln",
          "type": "blob",
          "size": 1.70703125,
          "content": "﻿\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio 15\nVisualStudioVersion = 15.0.27130.2027\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"OdinSerializer\", \"OdinSerializer\\OdinSerializer.csproj\", \"{F1111936-6086-412C-AB26-D7D8D3448A2A}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug Editor|Any CPU = Debug Editor|Any CPU\n\t\tRelease AOT|Any CPU = Release AOT|Any CPU\n\t\tRelease Editor|Any CPU = Release Editor|Any CPU\n\t\tRelease JIT|Any CPU = Release JIT|Any CPU\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{F1111936-6086-412C-AB26-D7D8D3448A2A}.Debug Editor|Any CPU.ActiveCfg = Debug Editor|Any CPU\n\t\t{F1111936-6086-412C-AB26-D7D8D3448A2A}.Debug Editor|Any CPU.Build.0 = Debug Editor|Any CPU\n\t\t{F1111936-6086-412C-AB26-D7D8D3448A2A}.Release AOT|Any CPU.ActiveCfg = Release AOT|Any CPU\n\t\t{F1111936-6086-412C-AB26-D7D8D3448A2A}.Release AOT|Any CPU.Build.0 = Release AOT|Any CPU\n\t\t{F1111936-6086-412C-AB26-D7D8D3448A2A}.Release Editor|Any CPU.ActiveCfg = Release Editor|Any CPU\n\t\t{F1111936-6086-412C-AB26-D7D8D3448A2A}.Release Editor|Any CPU.Build.0 = Release Editor|Any CPU\n\t\t{F1111936-6086-412C-AB26-D7D8D3448A2A}.Release JIT|Any CPU.ActiveCfg = Release JIT|Any CPU\n\t\t{F1111936-6086-412C-AB26-D7D8D3448A2A}.Release JIT|Any CPU.Build.0 = Release JIT|Any CPU\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {8A313189-C983-415D-BC29-14C705983A37}\n\tEndGlobalSection\n\tGlobalSection(Performance) = preSolution\n\t\tHasPerformanceSessions = true\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "OdinSerializer",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 30.0888671875,
          "content": "<br />\n<p align=\"center\">\n    <img src=\"/Images/OdinSerializerLogo.png\" alt=\"Odin Serializer\">\n</p>\n<h3 align=\"center\" style=\"text-align:center;\">\n\tFast, robust, powerful and extendible .NET serializer built for Unity\n</h3>\n<p align=\"center\">\n\tOdinSerializer is an open-source version of the custom serializer built for and used by \n\t<a href=\"https://odininspector.com/\">Odin - Inspector & Serializer</a>\n</p>\n<hr>\n<p align=\"center\">\t\n\t<a href=\"https://twitter.com/TeamSirenix\">\n\t\t<img src=\"/Images/BtnTwitter.png\" alt=\"Sirenix Twitter\">\n\t</a>\n\t<a href=\"https://discord.gg/AgDmStu\">\n\t\t<img src=\"https://discordapp.com/api/guilds/355444042009673728/embed.png\" alt=\"Discord server\">\n\t</a>\n\t<a href=\"https://odininspector.com/\">\n\t\t<img src=\"/Images/BtnOdinInspector.png\" alt=\"Inspect all data with Odin Serializer\">\n\t</a>\n\t<a href=\"https://odininspector.com/download\">\n\t\t<img src=\"/Images/BtnDownload.png\" alt=\"Download\">\n\t</a>\n\t<a href=\"https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=YFY8ZF347Z2PN\">\n\t\t<img src=\"/Images/BtnDonate.png\" alt=\"Donate\">\n\t</a>\t\n</p>\n<hr>\n<h3 align=\"center\" style=\"text-align:center;\">\n\tUsed in hundreds of games and supported by Asset Store developers such as\n</h3>\n\n<p align=\"center\">\t\n\t<a href=\"http://www.devdog.io\" target=\"_blank\">\n\t\t<img src=\"/Images/DevdogLogo.png\" alt=\"DevDog\">\n\t</a>\n\t<a href=\"https://assetstore.unity.com/publishers/735\" target=\"_blank\">\n\t\t<img src=\"/Images/ParadoxNotionLogo.png\" alt=\"ParadoxNotion\">\n\t</a>\n\t<a href=\"https://assetstore.unity.com/publishers/11548\" target=\"_blank\">\n\t\t<img src=\"/Images/LudiqLogo.png\" alt=\"Ludiq\">\n\t</a>\n</p>\n<hr>\n\n## Performance charts and comparisons\n\nOdinSerializer compares very well to many popular serialization libraries in terms of performance and garbage allocation, while providing a superior feature-set for use in Unity.\n\nThe performance graphs in this section are profiled with OdinSerializer's binary format.\n\n|                                       | Odin Serializer  | Unity JSON       | Full Serializer  | Binary Formatter | JSON.NET        |Protobuf-net          |\n|---------------------------------------|------------------|------------------|------------------|------------------|------------------|------------------|\n|Open Source                            |:heavy_check_mark:|:x:|:heavy_check_mark:|:x:               |:heavy_check_mark:|:heavy_check_mark:|\n|Cross Platform                         |:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:\n|Out of the box Unity Support           |:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:|:x:               |:x:               |:x:\n|Supports Unity structs                 |:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:|:x:               |:x:               |:x:\n|Binary Formatter                       |:heavy_check_mark:|:x:               |:x:               |:heavy_check_mark:|:x:               |:heavy_check_mark:\n|Json Formatter                         |:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:|:x:               |:heavy_check_mark:|:x:\n|Merge-friendly data in Unity objects   |:heavy_check_mark:|:x:               |:x:               |:x:               |:x:               |:x:\n|Interfaces                             |:heavy_check_mark:|:x:               |:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:\n|Properties                             |:heavy_check_mark:|:x:               |:heavy_check_mark:|:x:               |:heavy_check_mark:|:heavy_check_mark:\n|Polymorphism                           |:heavy_check_mark:|:x:               |:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:\n|Generics                               |:heavy_check_mark:|:x:               |:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:\n|Dictionaries                           |:heavy_check_mark:|:x:               |:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:\n|Circular References                   |:heavy_check_mark:|:x:               |:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:\n|Delegates                              |:heavy_check_mark:|:x:               |:x:               |:heavy_check_mark:|:x:               |:x:\n|Multi-dimensional arrays               |:heavy_check_mark:|:x:               |:x:               |:heavy_check_mark:|:heavy_check_mark:|:x:\n|Extendable                             |:heavy_check_mark:|:x:               |:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:\n|Renaming Members                       |:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:\n|Renaming Types                         |:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:\n|IL Optimized                           |:heavy_check_mark:|-                 |:x:               |:x:               |:x:               |-\n|Supports .NET interfaces               |:heavy_check_mark:|:x:               |:x:               |:heavy_check_mark:|?                 |:x:\n|Supports .NET callback attributes      |:heavy_check_mark:|:x:               |:x:               |:heavy_check_mark:|:heavy_check_mark:|:heavy_check_mark:\n\n#### Serialization of a simple object with no polymorphism\n![Benchmark](/Images/SimpleObjectSerializationBenchmark.png)\n#### Serialization of a complex object with lots of polymorphism\n##### *Unity JsonUtility has been excluded from this benchmark because it supports neither polymorphism or dictionaries\n![Benchmark](/Images/ComplexObjectSerializationBenchmark.png)\n#### Serialization of various large arrays and lists\n![Benchmark](/Images/HugeArraysSerializationBenchmark.png)\n#### Garbage allocation of the 3 tests above\n![Benchmark](/Images/GarbageCollectionSerializationBenchmark.png)\n\n## How to get started\n\nThere are many different use cases for OdinSerializer. If you just need a serialization library to use in your own private project, we can recommend that you simply use it out of the box. If you would like to make your own tweaks and builds, or if you intend to include OdinSerializer in a package that you are distributing, you would be better served by forking the repository.\n\n### Using OdinSerializer out of the box\n\nTo use OdinSerializer as-is, simply head to the [download](https://odininspector.com/download) page on our website to download the latest commit as a .unitypackage file, and import the package into your Unity project. OdinSerializer will then be in your project, ready to use.\n\n### Forking OdinSerializer\n\n*Note: currently, working with and building the OdinSerializer project has only been tested on Windows machines, using Visual Studio.*\n\nTo get started, you may want to read [GitHub's guide to forking](https://guides.github.com/activities/forking/), to get the basics of forking down. \n\nOnce you've forked OdinSerializer, you can start making your own changes to the project. Perhaps you want to add a feature, or tweak a part of it to suit your own needs better.\n\nIf you intend to include OdinSerializer in one of your own product distributions, you should modify all source files using a tool like search and replace to move the OdinSerializer namespace into an appropriate namespace for your project, and rename the .dll's that are built. This is to avoid namespace and assembly conflicts in the cases where multiple different assets in the same project all use possibly differing versions of OdinSerializer. For example, you might globally rename \"OdinSerializer\" to \"MyProject.Internal.OdinSerializer\", and also have the .dll's renamed to \"MyProject.Internal.OdinSerializer.dll\".\n\nHere's a goto list of things that need to be renamed during this process:\n\n- OdinSerializer.csproj: AssemblyName and RootNamespace and XML doc path.\n- OdinBuildAutomation.cs: Namespace, and assembly name strings in the static constructor.\n- Namespaces in the entire OdinSerializer project (search and replace is your friend).\n- The link.xml file included in the AOT folder.\n\n### Building OdinSerializer\n\nThe OdinSerializer project is set up as an independent code project that lives outside of Unity, and which can compile assemblies for use inside of a Unity project. Its build settings are set up to use a specific MSBuild distributable (Roslyn compiler) to build assemblies that are Unity-compatible, and the pdb2mdb tool to convert .pdb symbol files to .mdb symbol files to support proper step debugging in Unity. Simply building with the default MSBuild versions that ship with many recent distributions of Visual Studio appears to cause instant runtime crashes in some versions of Unity the moment the code enters an unsafe context.\n\nThe easiest way to build and test OdinSerializer, however, is to open the Build folder as a Unity project (any Unity version at or above 5.3 should work). When open, you will see three buttons in the project scene view: \"Compile with debugging\", \"Compile release build\" and \"Open solution\".\n\n*Compile with debugging* compiles an assembly into the open project, along with the proper symbol files for step debugging. Once this assembly is imported by Unity, you can step debug OdinSerializer by attaching a Visual Studio instance to it.\n\n*Compile release build* compiles three different OdinSerializer assembly variants with release optimizations. The three assemblies are for use in respectively the editor, in builds with JIT support (Windows/Mac/Linux), and in AOT builds (IL2CPP). The OdinSerializer Unity project also includes one script file, OdinSerializerBuildAutomation.cs, which automates setting the import settings of these three assemblies correctly during the build process based on the current target platform and scripting backend so that the correct assembly is used for that build, as well as automatically scanning the project and generating AOT support for types that need it, if the build is AOT compiled. We encourage you to modify this file or otherwise adapt it to suit your own particular automation needs.\n\n*Open solution* simply opens the OdinSerializer solution file using the default application.\n\n### Basic usage of OdinSerializer\n\nThis section will not go into great detail about how OdinSerializer works or how to configure it in advanced ways - for that, see the technical overview further down. Instead, it aims to give a simple overview of how to use OdinSerializer in a basic capacity.\n\nThere are, broadly, two different ways of using OdinSerializer:\n\n#### Serializing regular C# objects\n\nYou can use OdinSerializer as a standalone serialization library, simply serializing or deserializing whatever data you give it, for example to be stored in a file or sent over the network. This is done using the SerializationUtility class, which contains a variety of methods that wrap OdinSerializer for straight-forward, easy use.\n\n###### Example: Serializing regular C# objects\n\n```csharp\nusing OdinSerializer;\n\npublic static class Example\n{\n\tpublic static void Save(MyData data, string filePath)\n\t{\n\t\tbyte[] bytes = SerializationUtility.SerializeValue(data, DataFormat.Binary);\n\t\tFile.WriteAllBytes(bytes, filePath);\n\t}\n\t\n\tpublic static MyData Load(string filePath)\n\t{\n\t\tbyte[] bytes = File.ReadAllBytes(filePath);\n\t\treturn SerializationUtility.DeserializeValue<MyData>(bytes, DataFormat.Binary);\n\t}\n}\n```\n\nNote that you cannot save references to Unity objects or assets down to a file in this manner. The only way to handle this is to ask for a list of all encountered UnityEngine.Object references when serializing, and then pass that list of references back into the system when deserializing data.\n\n###### Example: Serializing regular C# objects containing Unity references\n\n```csharp\nusing OdinSerializer;\n\npublic static class Example\n{\n\tpublic static void Save(MyData data,  string filePath, ref List<UnityEngine.Object> unityReferences)\n\t{\n\t\tbyte[] bytes = SerializationUtility.SerializeValue(data, DataFormat.Binary, out unityReferences);\n\t\tFile.WriteAllBytes(bytes, filePath);\n\t\t\n\t\t// The unityReferences list will now be filled with all encountered UnityEngine.Object references, and the saved binary data contains index pointers into this list.\n\t\t// It is your job to ensure that the list of references stays the same between serialization and deserialization.\n\t}\n\t\n\tpublic static MyData Load(string filePath, List<UnityEngine.Object> unityReferences)\n\t{\n\t\tbyte[] bytes = File.ReadAllBytes(filePath);\n\t\treturn SerializationUtility.DeserializeValue<MyData>(bytes, DataFormat.Binary, unityReferences);\n\t}\n}\n```\n\n#### Extending UnityEngine.Object serialization\n\nYou can also use OdinSerializer to seamlessly extend the serialization of Unity's object types, such as ScriptableObject and MonoBehaviour. There are two general ways of doing this, one of which is manual and requires a few lines of code to implement, and one of which is very easy to implement, but exhibits only the default behaviour.\n\nThe easier approach is to simply derive your type from one of many pre-created UnityEngine.Object-derived types that OdinSerializer provides, that have the above behaviour implemented already. Note that doing this will have the default behaviour of not serializing fields that Unity will serialize.\n\n###### Example: Easily extending UnityEngine.Object serialization\n\n```csharp\nusing OdinSerializer;\n\npublic class YourSpeciallySerializedScriptableObject : SerializedScriptableObject\n{\n\tpublic Dictionary<string, string> iAmSerializedByOdin;\n\tpublic List<string> iAmSerializedByUnity;\n}\n```\n\nThe manual method requires that you implement Unity's ISerializationCallbackReceiver interface on the UnityEngine.Object-derived type you want to extend the serialization of, and then use OdinSerializer's UnitySerializationUtility class to apply Odin's serialization during the serialization callbacks that Unity invokes at the appropriate times.\n\n###### Example: Manually extending UnityEngine.Object serialization\n\n```csharp\nusing UnityEngine;\nusing OdinSerializer;\n\npublic class YourSpeciallySerializedScriptableObject : ScriptableObject, ISerializationCallbackReceiver\n{\n\t[SerializeField, HideInInspector]\n\tprivate SerializationData serializationData;\n\n\tvoid ISerializationCallbackReceiver.OnAfterDeserialize()\n\t{\n\t\t// Make Odin deserialize the serializationData field's contents into this instance.\n\t\tUnitySerializationUtility.DeserializeUnityObject(this, ref this.serializationData, cachedContext.Value);\n\t}\n\n\tvoid ISerializationCallbackReceiver.OnBeforeSerialize()\n\t{\n\t\t// Whether to always serialize fields that Unity will also serialize. By default, this parameter is false, and OdinSerializer will only serialize fields that it thinks Unity will not handle.\n\t\tbool serializeUnityFields = false;\n\t\t\n\t\t// Make Odin serialize data from this instance into the serializationData field.\n\t\tUnitySerializationUtility.SerializeUnityObject(this, ref this.serializationData, serializeUnityFields, cachedContext.Value);\n\t}\n}\n```\n\nNOTE: If you use OdinSerializer to extend the serialization of a Unity object, without having an inspector framework such as Odin Inspector installed, the Odin-serialized fields will not be rendered properly in Unity's inspector. You will either have to acquire such a framework, or write your own custom editor to be able to inspect and edit this data in Unity's inspector window.\n\nAdditionally, always remember that Unity doesn't strictly know that this extra serialized data exists - whenever you change it from your custom editor, remember to manually mark the relevant asset or scene dirty, so Unity knows that it needs to be re-serialized.\n\nFinally, note that *prefab modifications will not simply work by default in specially serialized Components/Behaviours/MonoBehaviours*. Specially serialized prefab instances may explode and die if you attempt to change their custom-serialized data from the parent prefab. OdinSerializer contains a system for managing an object's specially-serialized prefab modifications and applying them, but this is an advanced use of OdinSerializer that requires heavy support from a specialised custom editor, and this is not covered in this readme.\n\n## How to contribute\n\nWe are taking contributions under the Apache 2.0 license, so please feel free to submit pull requests. Please keep in mind the following rules when submitting contributions:\n\n* Follow the pre-existing coding style and standards in the OdinSerializer code.\n* If you work in your own fork with a modified OdinSerializer namespace, please ensure that the pull request uses the correct namespaces for this repository and otherwise compiles right away, so we don't need to clean that sort of stuff up when accepting the pull request.\n\nWe are taking any contributions that add value to OdinSerializer without also adding undue bloat or feature creep. However, these are the areas that we are particularly interested in seeing contributions in:\n\n#### Bugfixes\n* We would be very grateful if you could submit pull requests for any bugs that you encounter and fix.\n\n#### Performance\n* General overall performance: faster code is always better, as long as the increase in speed does not sacrifice any robustness.\n* Json format performance: the performance of the json format (JsonDataWriter/JsonDataReader) is currently indescribably awful. The format was originally written as a testbed for use during the development of OdinSerializer, since it is human-readable and thus very useful for debugging purposes, and has remained largely untouched since.\n* EnumSerializer currently allocates garbage via boxing serialized and deserialized enum values. As such, serializing enums always results in unnecessary garbage being allocated. Any approaches for fixing this would be most welcome. Some unsafe code may be required, but we haven't yet had time to really look into this properly.\n\n#### Testing\n* A thorough set of standalone unit tests. Odin Inspector has its own internal integration tests for OdinSerializer, but currently we have no decent stand-alone unit tests that work solely with OdinSerializer.\n\n## Technical Overview\n\nThe following section is a brief technical overview of the working principles of OdinSerializer and many of its bigger features. First, however, let's have a super brief overview, to give some context before we begin.\n\nThis is how OdinSerializer works, on the highest level:\n\n* Data to be written to or read from is passed to a data writer/reader, usually in the form of a stream.\n* The data writer/reader is passed to a serializer, along with a value to be serialized, if we are serializing.\n* If the value can be treated as an atomic primitive, the serializer will write or read that directly using the passed data writer/reader. If the value is \"complex\", IE, it is a value that consists of other values, the serializer will get and wrap the use of a formatter to read or write the value.\n\n### \"Stack-only\", forward-only\n\nOdinSerializer is a forward-only serializer, meaning that when it serializes, it writes data immediately as it inspects the object graph, and when it deserializes, it recreates the object graph immediately as it parses the data. The serializer only ever moves forward - it cannot \"go back\" and look at previous data, since we retain no state and are doing everything on the fly, as we move forward. Unlike some other serializers, there is no \"meta-graph\" data structure that is allocated containing all the data to be saved down later.\n\nThis means that we can serialize and deserialize data entirely without allocating anything on the heap, meaning that after the system has run once and all the writer, reader, formatter and serializer instances have been created, there will often be literally zero superfluous GC allocations made, depending on the data format used.\n\n### Data writers and readers\n\nData writers and readers are types that implement the IDataReader and/or IDataWriter interfaces. They abstract the writing and reading of strongly typed C# data in the form of atomic primitives, from the actual raw data format that the data is written into and read from. OdinSerializer currently ships with data readers and writers that support three different formats: Json, Binary and Nodes.\n\nData writers and readers also contain a serialization or deserialization context, which is used to configure how serialization and deserialization operates in various ways.\n\n### Atomic primitives\n\nAn atomic primitive (or merely a primitive), in the context of OdinSerializer, is a type that can be written or read in a single call to a data writer or reader. All other types are considered complex types, and must be handled by a formatter that translates that type into a series of atomic primitives. You can check whether something is an atomic primitive by calling FormatterUtilities.IsPrimitiveType(Type type).\n\nThe following types are considered atomic primitives:\n\n* System.Char (char)\n* System.String (string)\n* System.Boolean (bool)\n* System.SByte (sbyte)\n* System.Byte (byte)\n* System.Short (short)\n* System.UShort (ushort)\n* System.Int (int)\n* System.UInt (uint)\n* System.Long (long)\n* System.ULong (ulong)\n* System.Single (float)\n* System.Double (double)\n* System.Decimal (decimal)\n* System.IntPtr\n* System.UIntPtr\n* System.Guid\n* All enums\n\n### Serializers and formatters\n\nThis is an important distinction - serializers are the outward \"face\" of the system, and are all hardcoded into the system. There is a hardcoded serializer type for each atomic primitive, and a catch-all ComplexTypeSerializer that handles all other types by wrapping the use of formatters.\n\nFormatters are what translates an actual C# object into the primitive data that it consists of. They are the primary point of extension in OdinSerializer - they tell the system how to treat various special types. For example, there is a formatter that handles arrays, a formatter that handles multi-dimensional arrays, a formatter that handles dictionaries, and so on.\n\nOdinSerializer ships with a large number of custom formatters for commonly serialized .NET and Unity types. An example of a custom formatter might be the following formatter for Unity's Vector3 type:\n\n```csharp\nusing OdinSerializer;\nusing UnityEngine;\n\n[assembly: RegisterFormatter(typeof(Vector3Formatter))]\n\t\npublic class Vector3Formatter : MinimalBaseFormatter<Vector3>\n{\n\tprivate static readonly Serializer<float> FloatSerializer = Serializer.Get<float>();\n\n\tprotected override void Read(ref Vector3 value, IDataReader reader)\n\t{\n\t\tvalue.x = FloatSerializer.ReadValue(reader);\n\t\tvalue.y = FloatSerializer.ReadValue(reader);\n\t\tvalue.z = FloatSerializer.ReadValue(reader);\n\t}\n\t\n\tprotected override void Write(ref Vector3 value, IDataWriter writer)\n\t{\n\t\tFloatSerializer.WriteValue(value.x, writer);\n\t\tFloatSerializer.WriteValue(value.y, writer);\n\t\tFloatSerializer.WriteValue(value.z, writer);\n\t}\n}\n```\n\nAll complex types that do not have a custom formatter declared are serialized using either an on-demand emitted formatter, or if emitted formatters are not available on the current platform, using a fallback reflection-based formatter. These \"default\" formatters use the serialization policy set on the current context to decide which members are serialized.\n\n### Serialization policies\n\nSerialization policies are used by non-custom formatters (emitted formatters and the reflection formatter) to decide which members should and should not be serialized. A set of default policies are provided in the SerializationPolicies class.\n\n### External references\n\nExternal references are a very useful concept to have. In short, it's a way for serialized data to refer to objects that are not stored in the serialized data itself, but should instead be fetched externally upon deserialization.\n\nFor example, if an object graph refers to a very large asset such as a texture, stored in a central asset database, you might not want the entire texture to be serialized down along with the graph, but might instead want to serialize an external reference to the texture, which would then be resolved again upon deserialization. When working with Unity, this feature is particularly useful, as you will see in the next section.\n\nExternal references in OdinSerializer can be either by index (int), by guid (System.Guid), or by string, and are used by implementing the IExternalIndexReferenceResolver, IExternalGuidReferenceResolver or IExternalStringReferenceResolver interfaces, and setting a resolver instance on the context that is set on the current data reader or writer.\n\nAll reference types (except strings, which are treated as atomic primitives) can potentially be resolved externally, and all available external reference resolvers in the current context will be queried for each encountered reference type object as to whether or not that object ought to be serialized as an external reference.\n\n### How OdinSerializer works in Unity\n\nOdinSerializer comes with a built-in Unity integration for use with types derived from Unity's special UnityEngine.Object class. This integration comes primarily in the form of the UnitySerializationUtility class, and the various convenience classes to derive from, that implement OdinSerializer using UnitySerializationUtility. Each such class derives from a given commonly used UnityEngine.Object type:\n\n* SerializedUnityObject : UnityEngine.Object\n* SerializedScriptableObject : UnityEngine.ScriptableObject\n* SerializedComponent : UnityEngine.Component\n* SerializedBehaviour : UnityEngine.Behaviour\n* SerializedMonoBehaviour : UnityEngine.MonoBehaviour\n* SerializedNetworkBehaviour : UnityEngine.NetworkBehaviour\n* SerializedStateMachineBehaviour : UnityEngine.StateMachineBehaviour\n\nDeriving from any of these types means that your derived type will be serialized using UnitySerializationUtility. Note that this will, by default, *not* serialize *all* serialized members on your derived type. These convenience types use the SerializationPolicies.Unity policy to select members for serialization, and also have the added behaviour that *they will not serialize any members on the derived type that Unity would usually serialize.* Note that this only applies directly on the root members of the serialized UnityEngine.Object-derived type. Take the following example:\n\n```csharp\n// This is the component you put on a GameObject. It is THIS component, and only this component, that decides whether or not something is serialized by Odin\npublic class MyMonoBehaviour : SerializedMonoBehaviour // Inheriting the component from SerializedMonoBehaviour means we use Odin's serialization\n{\n    public Dictionary<string, string> someDictionary; // Will be serialized by Odin\n\n    [SerializeField]\n    private SomeClass someClass1; // Will be serialized by Unity, NOT Odin. \"someClass1.someString\" will be serialized, but \"someClass1.someDict\" will NOT be serialized. Polymorphism is NOT supported. Null values are NOT supported.\n\n    [OdinSerialize]\n    private SomeClass someClass2; // Will be serialized by Odin, NOT Unity. Both \"someClass2.someString\" and \"someClass2.someDict\" will be serialized. Both polymorphism and null values are supported.\n}\n\n[Serializable]\npublic class SomeClass // No matter what you inherit from here, it makes no difference at all to the serialization of this class - that is decided \"higher up\" in the component itself\n{\n    public string someString;\n    public Dictionary<string, string> someDict;\n}\n```\n\nIf you wish to change this behaviour, you must implement your own special serialized UnityEngine.Object type using Unity's ISerializationCallbackReceiver interface, and manually change either the policy or the arguments passed to UnitySerializationUtility. For example:\n\n```csharp\nusing UnityEngine;\nusing OdinSerializer;\nusing OdinSerializer.Utilities;\n\npublic class YourMonoBehaviour : MonoBehaviour, ISerializationCallbackReceiver\n{\n\t[SerializeField, HideInInspector]\n\tprivate SerializationData serializationData;\n\n\tvoid ISerializationCallbackReceiver.OnAfterDeserialize()\n\t{\n\t\tusing (var cachedContext = Cache<DeserializationContext>.Claim())\n\t\t{\n\t\t\tcachedContext.Value.Config.SerializationPolicy = SerializationPolicies.Everything;\n\t\t\tUnitySerializationUtility.DeserializeUnityObject(this, ref this.serializationData, cachedContext.Value);\n\t\t}\n\t}\n\n\tvoid ISerializationCallbackReceiver.OnBeforeSerialize()\n\t{\n\t\tusing (var cachedContext = Cache<SerializationContext>.Claim())\n\t\t{\n\t\t\tcachedContext.Value.Config.SerializationPolicy = SerializationPolicies.Everything;\n\t\t\tUnitySerializationUtility.SerializeUnityObject(this, ref this.serializationData, serializeUnityFields: true, context: cachedContext.Value);\n\t\t}\n\t}\n}\n```\n\nFinally, it should be noted that the UnitySerializationUtility class always sets a UnityReferenceResolver as an external index resolver. This external reference resolver ensures that all references to Unity objects encountered in the data to serialize become external references, which are shunted into a list in the SerializationData struct for Unity to serialize, and later used to link the external references back up to the correct Unity instance.\n\nThis is done because there is no way for Odin to actually serialize and later reconstruct most UnityEngine.Object-derived types, and therefore, we have established it as a hard rule that we will never even try to do so.\n\n### AOT Support details\n\nOdinSerializer contains two utility classes, AOTSupportUtilities and AOTSupportScanner, for providing support for AOT (Ahead-Of-Time) compiled platforms such as IL2CPP and Mono AOT. These utilities can be used to scan the entire project (or merely parts of it) and generate a list of types that are serialized by OdinSerializer, and they can take a list of types and create a .dll file in your project that ensures that there will be serialization support for all the given types in an AOT build.\n\nTo automate this process of AOT support, you can use Unity's IPreProcessBuild/IPreProcessBuildWithReport and IPostProcessBuild/IPostProcessBuildWithReport interfaces to create an AOT support dll upon building, and delete it again after building. (Note that this only becomes possible in Unity 5.6, where IPreProcessBuild was introduced.)\n\nOdinSerializer already includes one script file in the Unity project, OdinSerializerBuildAutomation.cs, which automates setting the import settings of OdinSerializer's three assembly variants correctly during the build process based on the current target platform and scripting backend, as well as automatically scanning the project and generating AOT support for types that need it, if the build is AOT compiled. We encourage you to modify this file to suit your own particular automation needs.\n"
        }
      ]
    }
  ]
}