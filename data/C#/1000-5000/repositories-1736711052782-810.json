{
  "metadata": {
    "timestamp": 1736711052782,
    "page": 810,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "shuxinqin/Chloe",
      "stars": 1526,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 2.458984375,
          "content": "###############################################################################\n# Set default behavior to automatically normalize line endings.\n###############################################################################\n* text=auto\n\n###############################################################################\n# Set default behavior for command prompt diff.\n#\n# This is need for earlier builds of msysgit that does not have it on by\n# default for csharp files.\n# Note: This is only used by command line\n###############################################################################\n#*.cs     diff=csharp\n\n###############################################################################\n# Set the merge driver for project and solution files\n#\n# Merging from the command prompt will add diff markers to the files if there\n# are conflicts (Merging from VS is not affected by the settings below, in VS\n# the diff markers are never inserted). Diff markers may cause the following \n# file extensions to fail to load in VS. An alternative would be to treat\n# these files as binary and thus will always conflict and require user\n# intervention with every merge. To do so, just uncomment the entries below\n###############################################################################\n#*.sln       merge=binary\n#*.csproj    merge=binary\n#*.vbproj    merge=binary\n#*.vcxproj   merge=binary\n#*.vcproj    merge=binary\n#*.dbproj    merge=binary\n#*.fsproj    merge=binary\n#*.lsproj    merge=binary\n#*.wixproj   merge=binary\n#*.modelproj merge=binary\n#*.sqlproj   merge=binary\n#*.wwaproj   merge=binary\n\n###############################################################################\n# behavior for image files\n#\n# image files are treated as binary by default.\n###############################################################################\n#*.jpg   binary\n#*.png   binary\n#*.gif   binary\n\n###############################################################################\n# diff behavior for common document formats\n# \n# Convert binary document formats to text before diffing them. This feature\n# is only available from the command line. Turn it on by uncommenting the \n# entries below.\n###############################################################################\n#*.doc   diff=astextplain\n#*.DOC   diff=astextplain\n#*.docx  diff=astextplain\n#*.DOCX  diff=astextplain\n#*.dot   diff=astextplain\n#*.DOT   diff=astextplain\n#*.pdf   diff=astextplain\n#*.PDF   diff=astextplain\n#*.rtf   diff=astextplain\n#*.RTF   diff=astextplain\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 2.8212890625,
          "content": "## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n\n# User-specific files\n*.suo\n*.user\n*.sln.docstates\n\n# Build results\n[Dd]ebug/\n[Dd]ebugPublic/\n[Rr]elease/\nbuild/\nbld/\n[Bb]in/\n[Oo]bj/\n\n# Roslyn cache directories\n*.ide/\n\n# MSTest test Results\n[Tt]est[Rr]esult*/\n[Bb]uild[Ll]og.*\n\n#NUNIT\n*.VisualState.xml\nTestResult.xml\n\n# Build Results of an ATL Project\n[Dd]ebugPS/\n[Rr]eleasePS/\ndlldata.c\n\n*_i.c\n*_p.c\n*_i.h\n*.ilk\n*.meta\n*.obj\n*.pch\n*.pdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.tmp_proj\n*.log\n*.vspscc\n*.vssscc\n.builds\n*.pidb\n*.svclog\n*.scc\n\n# Chutzpah Test files\n_Chutzpah*\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opensdf\n*.sdf\n*.cachefile\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n\n# TFS 2012 Local Workspace\n$tf/\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*/\n*.[Rr]e[Ss]harper\n*.DotSettings.user\n\n# JustCode is a .NET coding addin-in\n.JustCode\n\n# TeamCity is a build add-in\n_TeamCity*\n\n# DotCover is a Code Coverage Tool\n*.dotCover\n\n# NCrunch\n_NCrunch_*\n.*crunch*.local.xml\n\n# MightyMoose\n*.mm.*\nAutoTest.Net/\n\n# Web workbench (sass)\n.sass-cache/\n\n# Installshield output folder\n[Ee]xpress/\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish/\n\n# Publish Web Output\n*.[Pp]ublish.xml\n*.azurePubxml\n## TODO: Comment the next line if you want to checkin your\n## web deploy settings but do note that will include unencrypted\n## passwords\n#*.pubxml\n\n# NuGet Packages Directory\npackages/*\n## TODO: If the tool you use requires repositories.config\n## uncomment the next line\n#!packages/repositories.config\n\n# Enable \"build/\" folder in the NuGet Packages folder since\n# NuGet packages use it for MSBuild targets.\n# This line needs to be after the ignore of the build folder\n# (and the packages folder if the line above has been uncommented)\n!packages/build/\n\n# Windows Azure Build Output\ncsx/\n*.build.csdef\n\n# Windows Store app package directory\nAppPackages/\n\n# Others\nsql/\n*.Cache\nClientBin/\n[Ss]tyle[Cc]op.*\n~$*\n*~\n*.dbmdl\n*.dbproj.schemaview\n*.pfx\n*.publishsettings\nnode_modules/\n\n# RIA/Silverlight projects\nGenerated_Code/\n\n# Backup & report files from converting an old project file\n# to a newer Visual Studio version. Backup files are not needed,\n# because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\nUpgradeLog*.htm\n\n# SQL Server files\n*.mdf\n*.ldf\n\n# Business Intelligence projects\n*.rdl.data\n*.bim.layout\n*.bim_*.settings\n\n# Microsoft Fakes\nFakesAssemblies/\n\n# LightSwitch generated files\nGeneratedArtifacts/\n_Pvt_Extensions/\nModelManifest.xml\n.vs/\n*.nupkg\n*.bak\n/src/DotNetCore/ChloeTest\n/src/DotNet/ChloeTest\n/src/ChloeTest\n.vs/*"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.041015625,
          "content": "MIT License\n\nCopyright (c) 2017 shuxinqin\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.8603515625,
          "content": "# Chloe(克洛伊)\nChloe is a lightweight Object/Relational Mapping(ORM) library.\nThe query interface is similar to LINQ. You can query data like LINQ and do any things(Join Query | Group Query | Aggregate Query | Insert | Batch Update | Batch Delete | Sharding) by lambda with Chloe.ORM.\n\n**Documentation**: [https://github.com/shuxinqin/Chloe/wiki](https://github.com/shuxinqin/Chloe/wiki \"https://github.com/shuxinqin/Chloe/wiki\")\n\n# NuGet Install Command\n\n|     Database         | Install Command  |\n| ------------ | --------------- |\n| SqlServer  | Install-Package Chloe.SqlServer  |\n| MySql  | Install-Package Chloe.MySql  |\n| Oracle  | Install-Package Chloe.Oracle  |\n| SQLite  | Install-Package Chloe.SQLite  |\n| PostgreSQL  | Install-Package Chloe.PostgreSQL  |\n| 达梦  | Install-Package Chloe.Dameng  |\n| 人大金仓  | Install-Package Chloe.KingbaseES  |\n\n# License\n[MIT](http://opensource.org/licenses/MIT) License\n\n# Usage\n* **Entity**\n```C#\npublic enum Gender\n{\n    Male = 1,\n    Female\n}\n\n[Table(\"Users\")]\npublic class User\n{\n    [Column(IsPrimaryKey = true)]\n    [AutoIncrement]\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public Gender? Gender { get; set; }\n    public int? Age { get; set; }\n    public int? CityId { get; set; }\n    public DateTime? OpTime { get; set; }\n}\n\npublic class City\n{\n    [Column(IsPrimaryKey = true)]\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public int ProvinceId { get; set; }\n}\n\npublic class Province\n{\n    [Column(IsPrimaryKey = true)]\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n```\n* **DbContext**\n```C#\nIDbContext context = new MsSqlContext(DbHelper.ConnectionString);\nIQuery<User> q = context.Query<User>();\n```\n* **Query**\n```C#\nIQuery<User> q = context.Query<User>();\nq.Where(a => a.Id > 0).FirstOrDefault();\nq.Where(a => a.Id > 0).ToList();\nq.Where(a => a.Id > 0).OrderBy(a => a.Age).ToList();\nq.Where(a => a.Id > 0).Take(10).OrderBy(a => a.Age).ToList();\n\nq.Where(a => a.Id > 0).OrderBy(a => a.Age).ThenByDesc(a => a.Id).Select(a => new { a.Id, a.Name }).Skip(20).Take(10).ToList();\n/*\n * SELECT TOP (10) [T].[Id] AS [Id],[T].[Name] AS [Name] FROM (SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],ROW_NUMBER() OVER(ORDER BY [Users].[Age] ASC,[Users].[Id] DESC) AS [ROW_NUMBER_0] FROM [Users] AS [Users] WHERE [Users].[Id] > 0) AS [T] WHERE [T].[ROW_NUMBER_0] > 20\n */\n\nq.Where(a => a.Id > 0).Where(a => a.Name.Contains(\"lu\")).ToList();\n/*\n * SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime] \n * FROM [Users] AS [Users] \n * WHERE ([Users].[Id] > 0 AND [Users].[Name] LIKE '%' + N'lu' + '%')\n */\n```\n* **Join Query**\n```C#\nMsSqlContext context = new MsSqlContext(DbHelper.ConnectionString);\n\nvar user_city_province = context.Query<User>()\n                         .InnerJoin<City>((user, city) => user.CityId == city.Id)\n                         .InnerJoin<Province>((user, city, province) => city.ProvinceId == province.Id);\n\nuser_city_province.Select((user, city, province) => new { UserId = user.Id, CityName = city.Name, ProvinceName = province.Name }).Where(a => a.UserId == 1).ToList();\n/*\n * SELECT [Users].[Id] AS [UserId],[City].[Name] AS [CityName],[Province].[Name] AS [ProvinceName] \n * FROM [Users] AS [Users] \n * INNER JOIN [City] AS [City] ON [Users].[CityId] = [City].[Id] \n * INNER JOIN [Province] AS [Province] ON [City].[ProvinceId] = [Province].[Id] \n * WHERE [Users].[Id] = 1\n */\n \nvar view = user_city_province.Select((user, city, province) => new { User = user, City = city, Province = province });\n \nview.Where(a => a.User.Id == 1).ToList();\n/*\n * SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime],[City].[Id] AS [Id0],[City].[Name] AS [Name0],[City].[ProvinceId] AS [ProvinceId],[Province].[Id] AS [Id1],[Province].[Name] AS [Name1] \n * FROM [Users] AS [Users] \n * INNER JOIN [City] AS [City] ON [Users].[CityId] = [City].[Id] \n * INNER JOIN [Province] AS [Province] ON [City].[ProvinceId] = [Province].[Id] \n * WHERE [Users].[Id] = 1\n */\n \nview.Where(a => a.User.Id == 1).Select(a => new { UserId = a.User.Id, CityName = a.City.Name, ProvinceName = a.Province.Name }).ToList();\n/*\n * SELECT [Users].[Id] AS [UserId],[City].[Name] AS [CityName],[Province].[Name] AS [ProvinceName] \n * FROM [Users] AS [Users] \n * INNER JOIN [City] AS [City] ON [Users].[CityId] = [City].[Id] \n * INNER JOIN [Province] AS [Province] ON [City].[ProvinceId] = [Province].[Id] \n * WHERE [Users].[Id] = 1\n */\n\n/*\n * Chloe also supports left join,right join and full join query.\n * For details please see 'https://github.com/shuxinqin/Chloe/blob/master/src/Chloe/IQuery%60.cs'.\n */\n```\n* **Group Query**\n```C#\nIQuery<User> q = context.Query<User>();\n\nIGroupingQuery<User> g = q.Where(a => a.Id > 0).GroupBy(a => a.Age);\ng = g.Having(a => a.Age > 1 && Sql.Count() > 0);\n\ng.Select(a => new { a.Age, Count = Sql.Count(), Sum = Sql.Sum(a.Age), Max = Sql.Max(a.Age), Min = Sql.Min(a.Age), Avg = Sql.Average(a.Age) }).ToList();\n/*\n * SELECT [Users].[Age] AS [Age],COUNT(1) AS [Count],SUM([Users].[Age]) AS [Sum],MAX([Users].[Age]) AS [Max],MIN([Users].[Age]) AS [Min],CAST(AVG([Users].[Age]) AS FLOAT) AS [Avg] \n * FROM [Users] AS [Users] \n * WHERE [Users].[Id] > 0 \n * GROUP BY [Users].[Age] HAVING ([Users].[Age] > 1 AND COUNT(1) > 0)\n */\n```\n* **Sql Query**\n```C#\ncontext.SqlQuery<User>(\"select Id,Name,Age from Users where Name=@name\", DbParam.Create(\"@name\", \"lu\")).ToList();\ncontext.SqlQuery<int>(\"select Id from Users\").ToList();\n```\n* **Aggregate Query**\n```C#\nIQuery<User> q = context.Query<User>();\n\nq.Select(a => Sql.Count()).First();\n/*\n * SELECT TOP (1) COUNT(1) AS [C] FROM [Users] AS [Users]\n */\n\nq.Select(a => new { Count = Sql.Count(), LongCount = Sql.LongCount(), Sum = Sql.Sum(a.Age), Max = Sql.Max(a.Age), Min = Sql.Min(a.Age), Average = Sql.Average(a.Age) }).First();\n/*\n * SELECT TOP (1) COUNT(1) AS [Count],COUNT_BIG(1) AS [LongCount],SUM([Users].[Age]) AS [Sum],MAX([Users].[Age]) AS [Max],MIN([Users].[Age]) AS [Min],CAST(AVG([Users].[Age]) AS FLOAT) AS [Average] \n * FROM [Users] AS [Users]\n */\n\nvar count = q.Count();\n/*\n * SELECT COUNT(1) AS [C] FROM [Users] AS [Users]\n */\n\nvar longCount = q.LongCount();\n/*\n * SELECT COUNT_BIG(1) AS [C] FROM [Users] AS [Users]\n */\n\nvar sum = q.Sum(a => a.Age);\n/*\n * SELECT SUM([Users].[Age]) AS [C] FROM [Users] AS [Users]\n */\n\nvar max = q.Max(a => a.Age);\n/*\n * SELECT MAX([Users].[Age]) AS [C] FROM [Users] AS [Users]\n */\n\nvar min = q.Min(a => a.Age);\n/*\n * SELECT MIN([Users].[Age]) AS [C] FROM [Users] AS [Users]\n */\n\nvar avg = q.Average(a => a.Age);\n/*\n * SELECT CAST(AVG([Users].[Age]) AS FLOAT) AS [C] FROM [Users] AS [Users]\n */\n```\n* **Method**\n```C#\nIQuery<User> q = context.Query<User>();\n\nvar space = new char[] { ' ' };\n\nDateTime startTime = DateTime.Now;\nDateTime endTime = DateTime.Now.AddDays(1);\nq.Select(a => new\n{\n    Id = a.Id,\n\n    String_Length = (int?)a.Name.Length,//LEN([Users].[Name])\n    Substring = a.Name.Substring(0),//SUBSTRING([Users].[Name],0 + 1,LEN([Users].[Name]))\n    Substring1 = a.Name.Substring(1),//SUBSTRING([Users].[Name],1 + 1,LEN([Users].[Name]))\n    Substring1_2 = a.Name.Substring(1, 2),//SUBSTRING([Users].[Name],1 + 1,2)\n    ToLower = a.Name.ToLower(),//LOWER([Users].[Name])\n    ToUpper = a.Name.ToUpper(),//UPPER([Users].[Name])\n    IsNullOrEmpty = string.IsNullOrEmpty(a.Name),//too long\n    Contains = (bool?)a.Name.Contains(\"s\"),//\n    Trim = a.Name.Trim(),//RTRIM(LTRIM([Users].[Name]))\n    TrimStart = a.Name.TrimStart(space),//LTRIM([Users].[Name])\n    TrimEnd = a.Name.TrimEnd(space),//RTRIM([Users].[Name])\n    StartsWith = (bool?)a.Name.StartsWith(\"s\"),//\n    EndsWith = (bool?)a.Name.EndsWith(\"s\"),//\n\n    DiffYears = Sql.DiffYears(startTime, endTime),//DATEDIFF(YEAR,@P_0,@P_1)\n    DiffMonths = Sql.DiffMonths(startTime, endTime),//DATEDIFF(MONTH,@P_0,@P_1)\n    DiffDays = Sql.DiffDays(startTime, endTime),//DATEDIFF(DAY,@P_0,@P_1)\n    DiffHours = Sql.DiffHours(startTime, endTime),//DATEDIFF(HOUR,@P_0,@P_1)\n    DiffMinutes = Sql.DiffMinutes(startTime, endTime),//DATEDIFF(MINUTE,@P_0,@P_1)\n    DiffSeconds = Sql.DiffSeconds(startTime, endTime),//DATEDIFF(SECOND,@P_0,@P_1)\n    DiffMilliseconds = Sql.DiffMilliseconds(startTime, endTime),//DATEDIFF(MILLISECOND,@P_0,@P_1)\n    //DiffMicroseconds = Sql.DiffMicroseconds(startTime, endTime),//DATEDIFF(MICROSECOND,@P_0,@P_1)  Exception\n\n    AddYears = startTime.AddYears(1),//DATEADD(YEAR,1,@P_0)\n    AddMonths = startTime.AddMonths(1),//DATEADD(MONTH,1,@P_0)\n    AddDays = startTime.AddDays(1),//DATEADD(DAY,1,@P_0)\n    AddHours = startTime.AddHours(1),//DATEADD(HOUR,1,@P_0)\n    AddMinutes = startTime.AddMinutes(2),//DATEADD(MINUTE,2,@P_0)\n    AddSeconds = startTime.AddSeconds(120),//DATEADD(SECOND,120,@P_0)\n    AddMilliseconds = startTime.AddMilliseconds(20000),//DATEADD(MILLISECOND,20000,@P_0)\n\t\n    Now = DateTime.Now,//GETDATE()\n    UtcNow = DateTime.UtcNow,//GETUTCDATE()\n    Today = DateTime.Today,//CAST(GETDATE() AS DATE)\n    Date = DateTime.Now.Date,//CAST(GETDATE() AS DATE)\n    Year = DateTime.Now.Year,//DATEPART(YEAR,GETDATE())\n    Month = DateTime.Now.Month,//DATEPART(MONTH,GETDATE())\n    Day = DateTime.Now.Day,//DATEPART(DAY,GETDATE())\n    Hour = DateTime.Now.Hour,//DATEPART(HOUR,GETDATE())\n    Minute = DateTime.Now.Minute,//DATEPART(MINUTE,GETDATE())\n    Second = DateTime.Now.Second,//DATEPART(SECOND,GETDATE())\n    Millisecond = DateTime.Now.Millisecond,//DATEPART(MILLISECOND,GETDATE())\n    DayOfWeek = DateTime.Now.DayOfWeek,//(DATEPART(WEEKDAY,GETDATE()) - 1)\n\n    Int_Parse = int.Parse(\"1\"),//CAST(N'1' AS INT)\n    Int16_Parse = Int16.Parse(\"11\"),//CAST(N'11' AS SMALLINT)\n    Long_Parse = long.Parse(\"2\"),//CAST(N'2' AS BIGINT)\n    Double_Parse = double.Parse(\"3\"),//CAST(N'3' AS FLOAT)\n    Float_Parse = float.Parse(\"4\"),//CAST(N'4' AS REAL)\n    //Decimal_Parse = decimal.Parse(\"5\"),//CAST(N'5' AS DECIMAL)  ps: 'Decimal.Parse(string s)' is not supported now,because we don't know the precision and scale information.\n    Guid_Parse = Guid.Parse(\"D544BC4C-739E-4CD3-A3D3-7BF803FCE179\"),//CAST(N'D544BC4C-739E-4CD3-A3D3-7BF803FCE179' AS UNIQUEIDENTIFIER) AS [Guid_Parse]\n\n    Bool_Parse = bool.Parse(\"1\"),//CASE WHEN CAST(N'1' AS BIT) = CAST(1 AS BIT) THEN CAST(1 AS BIT) WHEN NOT (CAST(N'1' AS BIT) = CAST(1 AS BIT)) THEN CAST(0 AS BIT) ELSE NULL END AS [Bool_Parse]\n    DateTime_Parse = DateTime.Parse(\"1949-10-01\"),//CAST(N'1949-10-01' AS DATETIME) AS [DateTime_Parse]\n\n    B = a.Age == null ? false : a.Age > 1,\n}).ToList();\n```\n* **Insert**\n```C#\nIDbContext context = new MsSqlContext(DbHelper.ConnectionString);\n\n//return the key value\nint id = (int)context.Insert<User>(() => new User() { Name = \"lu\", Age = 18, Gender = Gender.Male, CityId = 1, OpTime = DateTime.Now });\n/*\n * INSERT INTO [Users]([Name],[Age],[Gender],[CityId],[OpTime]) VALUES(N'lu',18,1,1,GETDATE());SELECT @@IDENTITY\n */\n\n\nUser user = new User();\nuser.Name = \"lu\";\nuser.Age = 18;\nuser.Gender = Gender.Male;\nuser.CityId = 1;\nuser.OpTime = new DateTime(1970, 1, 1);\n\nuser = context.Insert(user);\n/*\n * String @P_0 = \"lu\";\n   Gender @P_1 = Male;\n   Int32 @P_2 = 18;\n   Int32 @P_3 = 1;\n   DateTime @P_4 = \"1970/1/1 0:00:00\";\n   INSERT INTO [Users]([Name],[Gender],[Age],[CityId],[OpTime]) VALUES(@P_0,@P_1,@P_2,@P_3,@P_4);SELECT @@IDENTITY\n */\n```\n* **Update**\n```C#\nMsSqlContext context = new MsSqlContext(DbHelper.ConnectionString);\n\ncontext.Update<User>(a => a.Id == 1, a => new User() { Name = a.Name, Age = a.Age + 1, Gender = Gender.Male, OpTime = DateTime.Now });\n/*\n * UPDATE [Users] SET [Name]=[Users].[Name],[Age]=([Users].[Age] + 1),[Gender]=1,[OpTime]=GETDATE() WHERE [Users].[Id] = 1\n */\n\ncontext.Update<User>(a => a.Gender == Gender.Woman, a => new User() { Age = a.Age - 1, OpTime = DateTime.Now });\n/*\n * UPDATE [Users] SET [Age]=([Users].[Age] - 1),[OpTime]=GETDATE() WHERE [Users].[Gender] = 2\n */\n\n\nUser user = new User();\nuser.Id = 1;\nuser.Name = \"lu\";\nuser.Age = 28;\nuser.Gender = Gender.Male;\nuser.OpTime = DateTime.Now;\n\ncontext.Update(user); //update all columns\n/*\n * String @P_0 = \"lu\";\n   Gender @P_1 = Male;\n   Int32 @P_2 = 28;\n   Nullable<Int32> @P_3 = NULL;\n   DateTime @P_4 = \"2016/7/8 11:28:27\";\n   Int32 @P_5 = 1;\n   UPDATE [Users] SET [Name]=@P_0,[Gender]=@P_1,[Age]=@P_2,[CityId]=@P_3,[OpTime]=@P_4 WHERE [Users].[Id] = @P_5\n */\n\ncontext.TrackEntity(user);//track entity\nuser.Name = user.Name + \"1\";\ncontext.Update(user);//update the column 'Name' only\n/*\n * String @P_0 = \"lu1\";\n   Int32 @P_1 = 1;\n   UPDATE [Users] SET [Name]=@P_0 WHERE [Users].[Id] = @P_1\n */\n```\n* **Delete**\n```C#\nMsSqlContext context = new MsSqlContext(DbHelper.ConnectionString);\n\ncontext.Delete<User>(a => a.Id == 1);\n/*\n * DELETE [Users] WHERE [Users].[Id] = 1\n */\n\ncontext.Delete<User>(a => a.Gender == null);\n/*\n * DELETE [Users] WHERE [Users].[Gender] IS NULL\n */\n \n \nUser user = new User();\nuser.Id = 1;\ncontext.Delete(user);\n/*\n * Int32 @P_0 = 1;\n   DELETE [Users] WHERE [Users].[Id] = @P_0\n */\n```\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "更新日志.md",
          "type": "blob",
          "size": 16.5302734375,
          "content": "* **2024-11-4**\n    * SplitQuery 查询优化\n\t* 版本更新至 v5.40.0\n* **2024-10-30**\n    * 支持使用变量的形式将 lambda 传入表达式中\n\t* 版本更新至 v5.39.0\n* **2024-10-1**\n    * sharding 优化\n    * 修改 Chloe.SQLite 读写锁支持递归锁\n\t* 版本更新至 v5.38.0\n* **2024-9-22**\n    * 代码优化\n    * Chloe.MySql 增加 MySqlFunctions.FindInSet()\n\t* 版本更新至 v5.37.0\n* **2024-9-11**\n    * 修改在表达式树中多层嵌套使用 IQuery 对象引发的错误\n\t* 版本更新至 v5.36.0\n* **2024-9-10**\n    * bug修改\n\t* 版本更新至 v5.34.0\n* **2024-9-6**\n    * 代码优化\n\t* 版本更新至 v5.33.0\n* **2024-9-4**\n    * 代码优化\n\t* 版本更新至 v5.32.0\n* **2024-8-22**\n    * 支持 SplitQuery\n\t* 功能增强以及个别 bug 修改\n\t* 版本更新至 v5.30.0\n* **2024-8-20**\n    * 修改分片查询有内存暴涨风险问题\n\t* 版本更新至 v5.28.0\n* **2024-8-18**\n    * 代码优化\n\t* 版本更新至 v5.27.0\n* **2024-8-14**\n    * 性能优化（缓存查询时表达式树解析结果）\n\t* 版本更新至 v5.26.0\n* **2024-8-5**\n    * 代码优化\n\t* 版本更新至 v5.25.0\n* **2024-8-1**\n    * 代码整理：DbOptions.DefaultInsertCountPerBatchForInsertRange -> DbOptions.DefaultBatchSizeForInsertRange\n\t* 版本更新至 v5.24.0\n* **2024-7-26**\n    * InsertRange() 修改：增加参数个数限制，以免超出数据库设置导致报错\n\t* 版本更新至 v5.23.0\n* **2024-7-22**\n    * 重构 InsertRange 方法\n\t* 版本更新至 v5.22.0\n* **2024-7-10**\n    * IDbContext 实现 ICloneable 接口\n\t* 版本更新至 v5.21.0\n* **2024-5-23**\n    * Chloe.Oracle：调整 DateTime.Now 的解析以及调整 OracleTableGenerator 生成脚本换行问题\n    * Chloe.SqlServer：升级驱动依赖版本\n\t* Chloe.Oracle、Chloe.SqlServer 版本更新至 v5.20.1\n* **2024-5-21**\n    * 代码优化\n\t* 版本更新至 v5.20.0\n* **2024-1-14**\n    * 代码优化和 bug 修改\n\t* 版本更新至 v5.19.0\n* **2023-12-8**\n    * 执行拦截器时先执行会话拦截器再执行全局拦截器\n    * EntityTypeBuilder 初始化时支持使用注解映射关系\n    * 支持属性为 null 或空时不参与插入\n    * 导航查询时，取消子对象将父对象设置到子对象对应的属性上默认行为，改为显示调用 IQuery.BindTwoWay() 的方式。注：此改动有破坏原本行为实现，谨慎升级!\n\t* 版本更新至 v5.18.0\n* **2023-12-5**\n    * 支持人大金仓，由 hongyl 贡献\n    * 修改 FeatureEnumerator 在某些情况下出现异常问题\n\t* 版本更新至 v5.17.0\n* **2023-12-3**\n    * 调整 string.IsNullOrEmpty() 解析\n\t* 版本更新至 v5.16.0\n* **2023-12-2**\n    * 重构 DbContext 构造函数，增加 DbOptions 参数。升级提示：有些属于 DbContext 的选项配置转移到了 DbOptions 中，升级框架版本时请注意。\n\t* 版本更新至 v5.15.0\n* **2023-11-30**\n    * 重构属性解析，增加 IPropertyHandler 属性解析器\n\t* 版本更新至 v5.13.0\n* **2023-11-20**\n    * 修改更新操作：track 实体后更新实体时对值先做是否改变检查再做不可为 null 检查\n    * 支持设置 in 参数最大个数\n\t* 版本更新至 v5.12.0\n* **2023-11-17**\n    * 支持 .net8\n\t* 优化 method handler\n\t* 版本更新至 v5.11.0\n* **2023-6-11**\n\t* 排除字段功能增强\n\t* 版本更新至 v5.10.0\n* **2023-6-10**\n\t* 查询支持排除字段，参考 IQuery.Exclude() 方法\n    * 修改分片普通 Take 查询如 query.Take(20).ToList() 返回错误数据量 bug\n\t* SqlGenerator 优化\n\t* 版本更新至 v5.9.0\n* **2023-5-24**\n\t* 代码整理\n\t* 版本更新至 v5.7.0\n* **2023-5-15**\n\t* 代码重构优化\n\t* 版本更新至 v5.6.0\n* **2023-4-21**\n\t* lambda更新操作增强，支持如：this.DbContext.Update<Person>(a => a.Id == 1, a => new Person() { Name = this.DbContext.Query<City>().Where(p => p.Id == a.Id).First().Name });\n\t* 版本更新至 v5.5.0\n* **2023-4-12**\n    * 删除一些废弃的方法\n\t* 删除操作增强，支持如 dbContext.Delete<Person>(a => !this.DbContext.Query<City>().Select(a => a.Id).ToList().Contains(a.CityId)) 复杂条件删除\n\t* 版本更新至 v5.4.0\n* **2023-3-22**\n\t* fix #359: 修改带排序的分组查询后再求总数执行错误问题，如 dbContext.Query().GroupBy(a => a.Id).OrderByDesc(a => Sql.Sum(a.Age)).Count()\n\t* 版本更新至 v5.3.1\n* **2022-11-17**\n\t* fix #344: 过滤器对Count、Max、Min、Avg无效 bug\n\t* 版本更新至 v5.3.0\n* **2022-5-22**\n\t* 支持分库分表(用法参考：[ShardingDemo](https://github.com/shuxinqin/Chloe/tree/master/src/ChloeDemo/Sharding \"ShardingDemo\") )\n\t* 版本更新至 v5.0.0\n* **2021-12-19**\n\t* 使用 C#10\n\t* Chloe.MySql 支持设置 Schema\n\t* 版本更新至 v4.19.0\n* **2021-11-27**\n\t* 修改 https://github.com/shuxinqin/Chloe/issues/275\n\t* 版本更新至 v4.18.0\n* **2021-6-25**\n\t* 参数类型支持 ParamDirection.ReturnValue\n\t* 版本更新至 v4.16.0\n* **2021-5-28**\n\t* 异步操作优化（强烈建议升级到此版本）\n\t* 版本更新至 v4.15.0\n* **2021-1-31**\n\t* 实体支持对指定字段忽略更新(UpdateIgnoreAttribute)\n\t* 版本更新至 v4.12.0\n* **2021-1-23**\n\t* 支持设置方法解析器\n\t* 版本更新至 v4.11.0\n* **2020-11-27**\n\t* 修改Query.Any()方法有可能引起的 sql 慢查询问题\n\t* 修改个别 bug\n\t* 版本更新至 v4.9.0\n* **2020-7-16**\n\t* 修改bug：#183\n\t* 版本更新至 v4.8.0\n* **2020-6-21**\n\t* 性能优化\n\t* 版本更新至 v4.7.0\n* **2020-5-19**\n\t* 修改 DbParam.Value 和 DbParam.Type 都为 null 时的 bug\n\t* 版本更新至 v4.6.0\n* **2020-5-6**\n\t* 修改 Sum 函数 bug(影响范围Chloe.SqlServer v4.5.0) #161\n\t* Chloe.SqlServer 更新至 v4.5.1\n* **2020-4-12**\n\t* IDbContext、IQuery 支持异步操作方法\n\t* 修改些许 bug\n\t* 版本更新至 v4.5.0\n\t* 注：此版本不再支持 .Net Framework4.0，如需在 .Net Framework4.0 下使用，请引用 Chloe.ORM v4.1 或以下版本\n* **2020-3-29**\n\t* 添加 IQuery<T>.IncludeAll() 方法\n\t* 版本更新至 v4.1.0\n* **2020-1-12**\n\t* 支持导航属性，使用方式请参考 github 上的 demo\n\t* 支持过滤器，使用方式请参考 github 上的 fluent mapping\n\t* Sequence 支持指定 schema\n\t* 支持行版本乐观并发控制\n\t* DbContext.Session 支持传入外部事务\n\t* 取消 Chloe.SqlServer.Annotations.TimestampAttribute，改用 Chloe.Annotations.ColumnAttribute.IsRowVersion\n\t* IJoiningQuery 改为 IJoinQuery\n\t* 版本更新至 v4.0.0\n\t* 注：此版本较之前版本有些许不兼容（但影响不大），升级请谨慎\n* **2019-11-7**\n\t* 修改bug #129\n\t* 版本更新至 v3.10.0\n* **2019-5-12**\n\t* 修改bug #90\n\t* #86 Chloe.Oracle 支持触发器自增字段(AutoIncrementAttribute)\n\t* 重构 InserRange 接口\n\t* 版本更新至 v3.9.0\n* **2019-3-23**\n\t* Chloe.SqlServer: 支持 timestamp 类型映射\n\t* 版本更新至 v3.8.1\n* **2019-3-20**\n\t* DbContext.SqlQuery 方法支持 ColumnAttribute 特性映射\n\t* 增加 IDbContext.UseTransaction() 方法\n\t* lambda 中支持 new 数组操作\n\t* 版本更新至 v3.8.0\n* **2019-3-14**\n\t* 代码优化\n\t* 版本更新至 v3.6.0\n* **2019-2-27**\n\t* 修改 Chloe.Oracle v3.3-v3.4.2 插入数据存在的bug\n\t* Chloe.Oracle 版本更新至 v3.4.3\n* **2019-1-20**\n\t* GroupBy 方法参lambda中支持 new 匿名类操作，如：query.GroupBy(a => new { a.CityId, a.Age })\n\t* 代码优化\n\t* 版本更新至 v3.4.0\n* **2019-1-3**\n\t* 支持 case when 操作，具体参考：https://github.com/shuxinqin/Chloe/blob/master/src/Chloe/CaseWhen.cs\n\t* 新增值比较函数 Sql.Compare<T>(T value1, CompareType compareType, T value2)，可支持字符串大小于比较\n\t* 查询时支持 with nolock/updlock\n\t* 优化oracle插入：利用 returning into 语法返回序列值\n\t* 版本更新至 v3.3.0\n* **2018-11-7**\n\t* Chloe.SqlServer bug修改: 分页查询时对分页结果进行排序 https://stackoverflow.com/questions/10980877/sql-row-number-and-sorting-issue\n\t* Chloe.SqlServer 3.*版本更新至 v3.2.1\n\t* Chloe.SqlServer 2.*版本更新至 v2.8.1\n* **2018-11-6**\n\t* DbContext.InsertRange 方法增加参数 table\n\t* SqlServer 插入时，使用 SELECT @@IDENTITY 获取返回的自增值(3.0版本使用的是 output.inserted.Id)\n\t* 版本更新至 v3.2.0\n* **2018-6-24**\n\t* 支持 fluent mapping\n\t* 支持用户定义数据库函数(Chloe.Annotations.DbFunctionAttribute)\n\t* Chloe.SqlServer：支持 SqlServer2012 序列\n\t* 支持 PostgreSQL 数据库\n\t* 注：在 v3.0 版本中，实体特性(TableAttribute，ColumnAttribute...)命名空间由 Chloe.Entity 变更为 Chloe.Annotations，相对 v2.* 有些许不同，已用 v2.* 版本的项目谨慎升级\n\t* 版本更新至 v3.0.0\n* **2018-6-23**\n\t* 修改如果实体指定了 Schema，执行插入、更新、删除操作时不带 Schema 的 bug\n\t* 版本更新至 v2.28.0\n* **2018-4-28**\n\t* 修改 ReflectionExtension.SetMemberValue 方法始终抛出异常的 bug\n\t* 版本更新至 v2.27.0\n* **2018-3-25**\n\t* 移除过时类 AggregateFunctions 和 DbFunctions\n\t* 版本更新至 v2.26.0\n* **2018-3-11**\n\t* 修改在lambda中使用子查询作为相等判断的操作数时生成复杂的sql影响效率问题，如q.Where(a => a.Id == context.Query<TestEntity>().First().Id)\n\t* 版本更新至 v2.25.0\n* **2018-2-3**\n\t* 新增API：IDbContext.SqlQuery<T>(string sql, object parameter)\n\t* IDbContextServiceProvider -> IDatabaseProvider\n\t* 版本更新至 v2.24.0\n* **2018-1-6**\n\t* 修改 IQuery.Average 部分方法的返回类型（所有Average方法将返回可空类型，避免当数据量为空时报错）\n\t* 标记 AggregateFunctions 和 DbFunctions 类 ObsoleteAttribute，取而代之使用 Chloe.Sql\n\t* 版本更新至 v2.23.0\n* **2017-11-20**\n\t* 新增api：IJoiningQuery.Where()\n\t* lambda中使用相等(==)或不相等(!=)判断考虑数据库null值问题，如 a.Name == a.XName 会被翻译成 a.Name == a.XName or (a.Name is null and a.XName is null)；a.Name != a.XName 会被翻译成 a.Name <> a.XName or (a.Name is null and a.XName is not null) or (a.Name is not null and a.XName is null)\n\t* 增加判断相等和不等api：Sql.Equals<T>(T value1, T value2)，Sql.NotEquals<T>(T value1, T value2)，此两个接口不会考虑数据库null值问题\n\t* 整合 .NET CORE 和 .NET Framework nuget安装包，统一使用安装命令 Install-Package Chloe.xxx，即 .NET CORE 版不再使用额外的安装包 ChloeCore.xxx\n\t* 版本更新至 v2.22.0\n* **2017-10-27**\n\t* 支持 string.Replace()\n\t* 版本更新至 v2.21.1\n* **2017-10-20**\n\t* 支持数据库 int64 类型数据映射到枚举\n\t* 优化 'IN' 查询\n\t* 性能优化\n\t* 版本更新至 v2.21.0\n* **2017-10-11**\n\t* fix bug：对于实体包含类型为double，float，decimal的属性，调用 IDbContext.InsertRange() 方法插入数据时，生成错误sql导致插入数据有误。\n\t* 版本更新至 v2.19.0\n* **2017-9-25**\n\t* 支持Distinct：IQuery<T>.Distinct()\n\t* 支持取负操作：a=> -a.Id\n\t* 修改查询如：query.Take(10).GroupBy(a => a.Id) ，先Take或Skip，然后在GroupBy操作，生成错误sql的bug\n\t* 丰富子查询，支持 exists(select id from ...)，in(select id from ...) 等操作，具体用法：https://github.com/shuxinqin/Chloe/blob/master/src/DotNet/ChloeDemo/MsSqlDemo.cs#L212\n\t* 版本更新至 v2.18.0\n* **2017-9-18**\n\t* 新增api：IDbContext.InsertRange()\n\t* Chloe.SqlServer：支持 SqlBulkCopy 批量插入数据接口，MsSqlContext.BulkInsert()\n\t* Chloe.Oracle：对于 a => a.Name == \"\" 将被翻译成 Name is null\n\t* 版本更新至 v2.17.0\n* **2017-9-3**\n\t* api 'IDbContext.SqlQuery<dynamic>()' 的泛型参数支持 dynamic 类型\n\t* 在 lambda 中支持使用'ToString()'方法（仅部分类型）\n\t* 版本更新至 v2.16.0\n* **2017-8-24**\n\t* 支持 .NET Core2.0\n\t* 版本更新至 v2.15.0\n* **2017-8-12**\n\t* 新增api：IGroupingQuery<T>.OrderBy() 和 IGroupingQuery<T>.OrderByDesc()\n\t* 版本更新至 v2.14.0\n* **2017-8-10**\n\t* lambda 表达式中支持 decimal 类型数值相加\n\t* 版本更新至 v2.13.0\n* **2017-7-9**\n\t* 实体支持多主键\n\t* 版本更新至 v2.12.0\n* **2017-7-6**\n\t* #18：支持数据库 byte 类型映射到枚举\n\t* 修改Chloe.MySql、ChloeSQLite BUG：在 lambda 表达式树中使用 'bool.Parse(\"1\")' 方法时生成错误 sql\n\t* 版本更新至 v2.11.0\n* **2017-6-18**\n\t* 增加更易用的多表连接查询接口 DbContext.JoinQuery\n\t* 修改连续调用 Skip 方法时生成错误的 sql 语句 bug，如 IQuery.Skip(10).Skip(5)\n\t* 版本更新至 v2.10.0\n* **2017-6-15**\n\t* 支持插入无主键的实体\n\t* 将特性 SequenceAttribute 命名空间修改为 Chloe.Entity，同时将其移到 Chloe/Entity 文件夹下\n\t* 增加 Add DbExpressionType.Coalesce，修改 ?? 操作符生成sql策略: 如 a.Age??18 将会被翻译成相应的数据库函数，如 ISNULL(Age,18)\n\t* 修改 IDbSession.BeginTransaction() 的实现：之前版本其内部统一使用 IsolationLevel.ReadCommitted，现修改为调用数据库驱动的无参方法，即 DbConnection.BeginTransaction()\n\t* 版本更新至 v2.9.0\n* **2017-6-4**\n\t* CURD 支持指定表名\n\t* Chloe.SQLite 增加读写锁\n\t* 修改BUG：当枚举类型不是 int 类型时，将枚举值转换为数据库值报错\n\t* 版本更新至 v2.8.0\n* **2017-5-21**\n\t* 特性 TableAttribute 支持设置 Schema\n\t* 修改issue#14 Query().Sum 的bug\n\t* 略微调整字符串相加生成的sql策略\n\t* 版本更新至 v2.7.0\n* **2017-4-8**\n\t* 特性 ColumnAttribute 增加 DbType 和 Length\n\t* 支持注册映射类型\n\t* 在lambda表达式树中支持取模运算符\n\t* DbContext.SqlQuery<T>() 移除对泛型 T 的 new() 约束\n\t* 支持数据库 int16 类型映射到 C# 枚举类型\n\t* Chloe.Oracle：支持数据库 int16 类型映射到 C# 的 bool 类型\n\t* IGroupingQuery<T>.ThenBy() 更改为 IGroupingQuery<T>.AndBy()\n\t* 版本更新至 v2.6.0\n* **2017-3-3**\n\t* 简化连接查询操作#9：IJoiningQuery 接口增加多个重载方法，支持 query.LeftJoin((a, b) => a.SN == b.UserSN).LeftJoin((a,b,c) => b.Id==c.BId)... 写法\n\t* 移除 DbContext.Query<TEntity>() 和 DbContext.QueryByKey<TEntity>(object key, bool tracking = false) 的泛型 TEntity 约束(where TEntity : new())，改为抛出异常的方式，即当传入的 TEntity 泛型不含有空构造函数时会报异常提示\n\t* 修复bug：执行分组查询如 g = g.Having(a => true); 时，解析 a => true lambda表达式树生成错误 sql 问题\n\t* 移除废弃的接口，DbContext.CurrentSession 和 DbContext.Update<TEntity>(Expression<Func<TEntity, TEntity>> body, Expression<Func<TEntity, bool>> condition)\n\t* 更改开源协议：由 apache 2.0 更改为更加宽松的 MIT 开源协议\n\t* 版本更新至 v2.5.0\n* **2017-1-19**\n\t* 支持在lambda中使用Nullable<T>.HasValue 和 obj.Equals(object obj)\n\t* 版本更新至 v2.4.0\n* **2017-1-6**\n\t* 增加 sql 拦截器功能\n\t* 修复问题：.Net Core 版本中通过 DbContext.SqlQuery() 或 IDbSession.ExecuteReader() 方法调用存储过程，如果有输出参数（output），方法执行完得不到返回的参数值\n\t* 版本更新至 v2.3.0\n* **2016-12-20**\n\t* Fixes bug: 执行查询如 context.Query<User>().Select(a => new User() { Id = a.Id, Age = a.Age }).Where(a => a.Id == 1).ToList();，其中，User.Id 是继承属性，当调用投影映射 Select 方法 Id=a.Id 后，后续的Where或其它方法lambda中用到Id这个属性，会出现异常问题。\n\t* 版本更新至 v2.2.1\n* **2016-12-18**\n\t* 修改内容：增加API IDbContext.QueryByKey(object key) 和 IDbContext.DeleteByKey(object key)\n\t* 版本更新至 v2.2.0\n* **2016-12-10**\n\t* 修改内容：如果一个继承属性出现在 IQuery.Select 方法的 lambda 中，会出现空引用异常，现已修复\n\t* 版本更新至 v2.1.2\n* **2016-12-7**\n\t* 修改内容：InternalDbSession 中的 IDbCommand 是单例可重用的，所以，每次调用 PrepareCommand 方法时需要清掉上次执行的残留参数，即执行 cmd.Parameters.Clear()（主要防止以下“特俗”情况：当执行 sql 过程出现异常，会来不及调用 cmd.Parameters.Clear()，就会出现残留的参数，为了保证每次使用 IDbCommand 不受上次异常情况下的影响，所以得清除一下上次残留的参数）\n\t* 版本更新至 v2.1.1\n* **2016-12-4**\n\t* 支持 Oracle 数据库\n\t* 实体支持继承\n\t* 支持存储过程\n\t* 重命名：NotAutoIncrementAttribute --> NonAutoIncrementAttribute\n\t* 废弃 DbContext.CurrentSession 属性，取而代之 DbContext.Session\n\t* IQuery 接口增加 TakePage 方法\n\t* 内部代码结构调整\n\t* 版本升级至 v2.1.0\n\n* **2016-8-26**\n\t* 版本升级至 v2.0.0\n\t* 发布 ChloeCore.MySql NuGet 包\n\n* **2016-8-8**\n\t* 支持 SQLite 数据库\n\t* .NET Ver update: v1.0.2\n\t* .NET Core Ver update: v1.0.4\n\n* **2016-8-1**\n\t* 支持 .NET Core\n    * 发行 NuGet 包\n      * .NET Ver: v1.0.1\n      * .NET Core Ver: v1.0.3\n\n* **2016-7-25**\n    * 支持 MySql 数据库\n\n* **2016-7-4**\n\t* 正式开源\n"
        }
      ]
    }
  ]
}