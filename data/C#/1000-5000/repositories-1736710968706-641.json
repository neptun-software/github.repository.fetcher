{
  "metadata": {
    "timestamp": 1736710968706,
    "page": 641,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "FransBouma/Massive",
      "stars": 1799,
      "defaultBranch": "v2.0",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.01171875,
          "content": "* text=auto\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 2.837890625,
          "content": "## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n\n# User-specific files\n*.suo\n*.user\n*.userosscache\n*.sln.docstates\n\n# User-specific files (MonoDevelop/Xamarin Studio)\n*.userprefs\n\n# Build results\n[Dd]ebug/\n[Dd]ebugPublic/\n[Rr]elease/\n[Rr]eleases/\nx64/\nx86/\nbuild/\nbld/\n[Bb]in/\n[Oo]bj/\n\n# Visual Studo 2015 cache/options directory\n.vs/\n\n# MSTest test Results\n[Tt]est[Rr]esult*/\n[Bb]uild[Ll]og.*\n\n# NUNIT\n*.VisualState.xml\nTestResult.xml\n\n# Build Results of an ATL Project\n[Dd]ebugPS/\n[Rr]eleasePS/\ndlldata.c\n\n*_i.c\n*_p.c\n*_i.h\n*.ilk\n*.meta\n*.obj\n*.pch\n*.pdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.tmp_proj\n*.log\n*.vspscc\n*.vssscc\n.builds\n*.pidb\n*.svclog\n*.scc\n\n# Chutzpah Test files\n_Chutzpah*\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opensdf\n*.sdf\n*.cachefile\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n\n# TFS 2012 Local Workspace\n$tf/\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*/\n*.[Rr]e[Ss]harper\n*.DotSettings.user\n\n# JustCode is a .NET coding addin-in\n.JustCode\n\n# TeamCity is a build add-in\n_TeamCity*\n\n# DotCover is a Code Coverage Tool\n*.dotCover\n\n# NCrunch\n_NCrunch_*\n.*crunch*.local.xml\n\n# MightyMoose\n*.mm.*\nAutoTest.Net/\n\n# Web workbench (sass)\n.sass-cache/\n\n# Installshield output folder\n[Ee]xpress/\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish/\n\n# Publish Web Output\n*.[Pp]ublish.xml\n*.azurePubxml\n# TODO: Comment the next line if you want to checkin your web deploy settings \n# but database connection strings (with potential passwords) will be unencrypted\n*.pubxml\n*.publishproj\n\n# NuGet Packages\n*.nupkg\n# The packages folder can be ignored because of Package Restore\n**/packages/*\n# except build/, which is used as an MSBuild target.\n!**/packages/build/\n# Uncomment if necessary however generally it will be regenerated when needed\n#!**/packages/repositories.config\n\n# Windows Azure Build Output\ncsx/\n*.build.csdef\n\n# Windows Store app package directory\nAppPackages/\n\n# Others\n*.[Cc]ache\nClientBin/\n[Ss]tyle[Cc]op.*\n~$*\n*~\n*.dbmdl\n*.dbproj.schemaview\n*.pfx\n*.publishsettings\nnode_modules/\nbower_components/\n\n# RIA/Silverlight projects\nGenerated_Code/\n\n# Backup & report files from converting an old project file\n# to a newer Visual Studio version. Backup files are not needed,\n# because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\nUpgradeLog*.htm\n\n# SQL Server files\n*.mdf\n*.ldf\n\n# Business Intelligence projects\n*.rdl.data\n*.bim.layout\n*.bim_*.settings\n\n# Microsoft Fakes\nFakesAssemblies/\n\n# Node.js Tools for Visual Studio\n.ntvs_analysis.dat\n\n# Visual Studio 6 build log\n*.plg\n\n# Visual Studio 6 workspace options file\n*.opt\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.6435546875,
          "content": "﻿Massive v2.0. \nLicensed to you under the New BSD License\nhttp://www.opensource.org/licenses/bsd-license.php\nMassive is copyright (c) 2009-2017 various contributors.\nAll rights reserved.\nSee for sourcecode, full history and contributors list: https://github.com/FransBouma/Massive\n\nRedistribution and use in source and binary forms, with or without modification, are permitted \nprovided that the following conditions are met:\n\n- Redistributions of source code must retain the above copyright notice, this list of conditions and the \n  following disclaimer.\n- Redistributions in binary form must reproduce the above copyright notice, this list of conditions and \n  the following disclaimer in the documentation and/or other materials provided with the distribution.\n- The names of its contributors may not be used to endorse or promote products derived from this software \n  without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS \nOR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY \nAND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR \nCONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL \nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, \nWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY \nWAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.markdown",
          "type": "blob",
          "size": 20.119140625,
          "content": "﻿Massive, a small, happy, dynamic MicroORM for .NET that will love you forever\n=============================================================================\n\nMassive was started by Rob Conery and [has been transfered](https://twitter.com/robconery/status/573139252487323648) to Frans Bouma on March 4th, 2015. It's a small MicroORM based on the `Expando` or `dynamic` type and allows you to work with your database with almost no effort. The design is based on the idea that the code provided to you in this repository is a start: you get up and running in no-time and from there edit and alter it as you see fit.  \n\n## Current Status\nMassive is currently on v2.0. To obtain the old v1.0 code, please select the v1.0 branch in the GitHub menu or click [here](https://github.com/FransBouma/Massive/tree/v1.0).\n\n## Installation\nTo use Massive in your project simply download the following files from the repository's [src](https://github.com/FransBouma/Massive/tree/v2.0/src) folder:\n\n* Massive.Shared.cs\n* Massive._YourDatabase_.cs, e.g. Massive.SqlServer.cs for SQL Server\n* Massive.Shared.Async.cs, if you want to use the Massive API asynchronously. Requires .NET 4.5 or higher.\n\nDue to its design, all files share the same namespace. If you need to use more than one database in your project, you have to change the namespace of the files and use per database a version of the Massive.Shared.* files. \n\n## Requirements\nMassive has no external direct dependencies, just get the code, compile it with your project and enjoy. It does have an _indirect_ dependency, namely on the ADO.NET provider of the database used. The ADO.NET provider is obtained through .NET's `DbProviderFactory` system. This requires that the ADO.NET provider has been setup properly so .NET can find the factory needed. The following ADO.NET providers are supported out of the box. \n\n* SQL Server. The ADO.NET provider ships with .NET.\n* Oracle: [ODP.NET](http://www.oracle.com/technetwork/topics/dotnet/index-085163.html). The installer for ODP.NET v12c installs both a full managed ADO.NET provider and a wrapper around its Java based Client Level Interface (CLI). By default Massive uses the latter, using the factory name `Oracle.DataAccess.Client`. If you want to use the Managed provider, please change the value in property `DbProviderFactoryName` in the [Massive.Oracle.cs](https://github.com/FransBouma/Massive/blob/v2.0/src/Massive.Oracle.cs) file around [line 297](https://github.com/FransBouma/Massive/blob/v2.0/src/Massive.Oracle.cs#L297) to `Oracle.ManagedDataAccess.Client`. This requires .NET 4.0 or higher.\n* PostgreSQL: [Npgsql](http://www.npgsql.org/). The Npgsql distribution contains an installer, offered at the \n'releases' section. This installer will add the required DbProviderFactory reference and will add the npgsql dll to the gac. \n* SQLite: Massive uses the official SQLite .NET provider. [Please read the official documentation](https://system.data.sqlite.org/index.html/doc/trunk/www/index.wiki) on that provider to get started. \n* MySQL: Massive works with the [Oracle/MySQL ADO.NET Driver](https://dev.mysql.com/downloads/connector/net/) (`MySql.Data.MySqlClient`) and with the [Devart dotConnect for MySQL](https://www.devart.com/dotconnect/mysql/download.html) driver (`Devart.Data.MySql`). Be aware of licensing issues. At the time of writing the free version of the Oracle/MySQL driver [must not be used in closed source development](https://www.mysql.com/about/legal/licensing/oem/), though it [can be used in many open source contexts](https://www.mysql.com/about/legal/licensing/foss-exception/). However the free version of the Devart driver [can be used in closed source development subject to some restrictions](https://www.devart.com/dotconnect/mysql/licensing-faq.html). If you want to use the Devart driver, please change the value in property `DbProviderFactoryName` in the [Massive.MySql.cs](https://github.com/FransBouma/Massive/blob/v2.0/src/Massive.MySql.cs) file around [line 280](https://github.com/FransBouma/Massive/blob/v2.0/src/Massive.MySql.cs#L280) to `Devart.Data.MySql`.\n\n## Migrating from v1.0 to v2.0\nIf you're using v1.0 currently and want to migrate to v2.0, please take a look at [What's new in v2.0](https://github.com/FransBouma/Massive/wiki/v2.0-Whats-new) page for more details about whether you'll run into the changes made. In general the breaking changes will be minor, if any. \n\n## What's new in v2.0\nBesides some changes as documented in the [What's new in v2.0](https://github.com/FransBouma/Massive/wiki/v2.0-Whats-new), the following features / additions are new:\n\n* Async / Await support. Not all supported databases support asynchronous data-access under the hood, but the Massive API at least allows you to work with the code asynchronously. Full Async is supported by the ADO.NET providers of SQL Server and Npgsql (3.x). ODP.NET (Oracle) doesn't support async under the hood so using the Async API with Oracle will still use synchronous data-access under the hood (through the default DbCommand fall back code). SQLite's ADO.NET provider does support async using specific types but Massive doesn't support these.\n* Shared code. In v1.0 code which was effectively the same among all supported databases was copy/pasted, in v2.0 Massive uses partial classes and shares as much code as possible among all supported databases. \n* Unit Tests. In v1.0 there were no tests but in v2.0 we properly implemented a series of tests to see whether things indeed work the way they do. They can also be used as an example how to get started. \n* Culling of dead code. \n\n## Contributing\nIf you want to add new features to Massive or have a fix for a bug, that's great! There are some rules however and if you don't meet them, I won't merge your code, no matter how long you've worked on it. This is nothing personal, and to many of you these rules might sound rigid, but this repository isn't a playground for newbies: the code is used by many people and they depend on it. It therefore has to be of high quality and changes made to the repository will live on forever so they aren't accepted without review. \n\n* PRs which are solely about whitespace changes are ignored. \n* Before sumitting a PR, first open an issue and discuss your proposed change/feature there. This is **mandatory**. Any PR without a linked issue is closed without comment. The main reasoning behind this is that it prevents people wasting time on things that will never make it into the code base or that e.g. a PR requires refactoring before it's being accepted because it doesn't fit into the codebase. ORMs, even small ones like Massive aren't simple: there are a lot of pitfalls and in general non-ORM devs overlook a lot of them. Discussing a change before a PR is a good thing in this case. Also don't be afraid to ask if you don't know how to proceed: that's why the issue is opened. \n* If your PR contains submissions from others, I can't accept your PR: a committer owns the code of a change. If you commit code into Massive owned by others, it is unclear those others were willing to share that code with the main repository. \n* Don't change the API nor its current behavior. Massive doesn't have a fixed version number, and is distributed through text files, but I still want the API to be dependable: no method is removed nor has its signature changed. For instance if you want to add functionality to a method and it requires extra arguments for that, you have to add an overload of the method, you can't simply append arguments to a method's signature. \nBe very careful here. Adding a new overload to a method which has a `params` argument at the end can easily break existing code (by causing it to unintentionally compile against your new method instead of the `params` version). Even simply adding optional parameters to the end of an existing method will break the API, since code which is linked against a pre-compiled version of Massive will fail. I cannot accept changes like this.\n* Tests are preferred. If your change can be tested with the current tests, no new tests are needed. If your change requires additional tests because the current tests don't cover it, add them with your PR.\n* If possible support all databases supported by Massive. I've designed Massive in v2.0 to share as much code as possible across all supported databases. New submissions are required to follow that pattern: for instance large pieces of code specific for SQL Server which are also usable with some tweaks on Oracle are not accepted. Instead the code has to be made generic and added to Massive.Shared, using methods implemented in the specific database partial classes to configure the code for that particular database. This can be a great pain, e.g. because you don't have access to Oracle nor Postgresql. In that case, request what you should add for these databases or that I do that for you and test the changes for you locally using the tests you wrote. \n* No new files please. There's currently a Massive.Shared.Async, and the sooner I can merge that into Massive.Shared, the better (MS still supporting .NET 3.5 is currently the limitation on that, but it's likely it will be merged in the near future). \n* Code defensively. If your code accepts input from the user, be absolutely sure this input is passed on as parameters and user crap like null values and name mismatches are covered. You don't need to throw a myriad of exceptions, but at least make a bit of an effort.\n* If it takes less time for me to write the code myself than to look at your PR, tell you how to change things and go into an endless bikeshedding debate with you, chances are I'll write it myself instead of debating things with you. \n* If you add to the API, it's recommended you add a small example to the documentation in this readme below. Some people think tests are documentation, but tests are tests, they test things. Documentation document things, so it's preferable to have documentation as well. \n* For the databases which are currently supported there are free downloads available. You can freely assume code which works on SQL Server Express and Oracle Express / developer edition to work on the paid commercial versions, unless you use a feature only available in those paid versions. \n\n## Usage\nNote, the following is a work in progress and doesn't contain all the new API methods. It is primarily the original text written by Conery, and I'll update it when I have time. If you're unsure how to use a given method, please look at the [tests](https://github.com/FransBouma/Massive/tree/v2.0/tests).  \n\nMassive is a \"wrapper\" for your DB tables and uses System.Dynamic extensively. If you try to use this with C# 3.5 or below, it will explode and you will be sad. Me too honestly - I like how this doesn't require any DLLs other than what's in the GAC. Yippee.\n\n * Get a Database. Northwind will work nicely. Add a connection to your database in your web.config (or app.config). Don't forget the providerName! If you don't know what that is - just add providerName = 'System.Data.SqlClient' right after the whole connectionString stuff.\n * Create a class that wraps a table. You can call it whatever you like, but if you want to be cool just name it the same as your table.\n * Query away and have fun\n\nCode Please\n-----------\nLet's say we have a table named \"Products\". You create a class like this:\n\n```csharp\npublic class Products:DynamicModel {\n\t//you don't have to specify the connection - Massive will use the first one it finds in your config\n\tpublic Products():base(\"northwind\", \"products\",\"productid\") {}\n}\n```\n\nYou could also just instantiate it inline, as needed:\n\n```csharp\nvar tbl = new DynamicModel(\"northwind\", tableName:\"Products\", primaryKeyField:\"ProductID\");\n```\n\nOr ignore the object hierarchy altogether:\n\t\n```csharp\nMassive.DB.Current.Query(...);\n```\n\nNow you can query thus:\n\n```csharp\nvar table = new Products();\n//grab all the products\nvar products = table.All();\n//just grab from category 4. This uses named parameters\nvar productsFour = table.All(columns: \"ProductName as Name\", where: \"WHERE categoryID=@0\",args: 4);\n```\n\nThat works, but Massive is \"dynamic\" - which means that it can figure a lot of things out on the fly. That query above can be rewritten like this:\n\n```csharp\ndynamic table = new Products(); //\"dynamic\" is important here - don't use \"var\"!\nvar productsFour = table.Find(CategoryID:4,columns:\"ProductName\");\n```\n\t\nThe \"Find\" method doesn't exist, but since Massive is dynamic it will try to infer what you mean by using DynamicObject's TryInvokeMember. See the source for more details. There's more on the dynamic query stuff down below.\n\t\nYou can also run ad-hoc queries as needed:\n\n```csharp\nvar result = tbl.Query(\"SELECT * FROM Categories\");\n```\n\nThis will pull categories and enumerate the results - streaming them as opposed to bulk-fetching them (thanks to Jeroen Haegebaert for the code). \n\nIf you want to have a paged result set - you can:\n\n```csharp\nvar result = tbl.Paged(where: \"UnitPrice > 20\", currentPage:2, pageSize: 20);\n```\n\nIn this example, ALL of the arguments are optional and default to reasonable values. CurrentPage defaults to 1, pageSize defaults to 20, where defaults to nothing.\n\nWhat you get back is a Dynamic with three properties: Items, TotalPages and TotalRecords. Items is a Query which is lazily evaluated and you can enumerate it after casting it to `IEnumerable<dynamic>`. TotalPages is the total number of pages in the complete result set and TotalRecords is the total number of records in the result set. What's in the Items collection is totally up to you, it's dynamic: meaning that it's malleable and exciting. It will take the shape of whatever you return in your query, and it will have properties and so on. You can assign events to it, you can create delegates on the fly. You can give it chocolate, and it will kiss you.\n\nThat's pretty much it. One thing I really like is the groovy DSL that Massive uses - it looks just like SQL. If you want, you can use this DSL to query the database:\n\n```csharp\nvar table = new Products();\nvar productsThatILike = table.Query(\"SELECT ProductName, CategoryName FROM Products INNER JOIN Categories ON Categories.CategoryID = Products.CategoryID WHERE CategoryID = @0\",5);\n//get down!\n```\n\nSome of you might look at that and think it looks suspiciously like inline SQL. It *does* look sort of like it doesn't it! But I think it reads a bit better than Linq to SQL - it's a bit closer to the mark if you will. \n\nInserts and Updates\n-------------------\nMassive is built on top of dynamics - so if you send an object to a table, it will get parsed into a query. If that object has a property on it that matches the primary key, Massive will think you want to update something. Unless you tell it specifically to update it.\n\nYou can send just about anything into the MassiveTransmoQueryfier and it will magically get turned into SQL:\n\n```csharp\nvar table = new Products();\nvar poopy = new {ProductName = \"Chicken Fingers\"};\n//update Product with ProductID = 12 to have a ProductName of \"Chicken Fingers\"\ntable.Update(poopy, 12);\n```\n\nThis also works if you have a form on your web page with the name \"ProductName\" - then you submit it:\n\n```csharp\nvar table = new Products();\n//update Product with ProductID = 12 to have a ProductName of whatever was submitted via the form\ntable.Update(poopy, Request.Form);\n```\n\nInsert works the same way:\n\n```csharp\n//pretend we have a class like Products but it's called Categories\nvar table = new Categories();\n//do it up - the inserted object will be returned from the query as expando \nvar inserted = table.Insert(new {CategoryName = \"Buck Fify Stuff\", Description = \"Things I like\"});\n// the new PK value is in the field specified as PrimaryKeyField in the constructor of Categories. \nvar newID = inserted.CategoryID;\n```\n\nYippee Skippy! Now we get to the fun part - and one of the reasons I had to spend 150 more lines of code on something you probably won't care about. What happens when we send a whole bunch of goodies to the database at once!\n\n```csharp\nvar table = new Products();\n//OH NO YOU DIDN't just pass in an integer inline without a parameter! \n//I think I might have... yes\nvar drinks = table.All(\"WHERE CategoryID = 8\");\n//what we get back here is an IEnumerable < ExpandoObject > - we can go to town\nforeach(var item in drinks.ToArray()){\n\t//turn them into Haack Snacks\n\titem.CategoryID = 12;\n}\n//Let's update these in bulk, in a transaction shall we?\ntable.Save(drinks.ToArray());\n```\n\t\nNamed Argument Query Syntax\n-------------------\nI recently added the ability to run more friendly queries using Named Arguments and C#4's `DynamicObject.TryInvokeMember` method-on-the-fly syntax. In an earlier version this was trying to be like Rails ActiveRecord (so, calls were like `var drinks = table.FindBy_CategoryID(8);`), but I figured \"C# is NOT Ruby, and Named Arguments can be a lot more clear\". So now calls look like `var drinks = table.FindBy(CategoryID:8);` (examples below). In addition, Mark Rendle's Simple.Data is already supporting ActiveRecord style syntax, so ... why duplicate things?\n\nIf your needs are more complicated - I would suggest just passing in your own SQL with Query().\n\n```csharp\n//important - must be dynamic\ndynamic table = new Products();\n\nvar drinks = table.FindBy(CategoryID:8);\n//what we get back here is an IEnumerable < ExpandoObject > - we can go to town\nforeach(var item in drinks){\n\tConsole.WriteLine(item.ProductName);\n}\n//returns the first item in the DB for category 8\nvar first = table.First(CategoryID:8);\n\n//you dig it - the last as sorted by PK\nvar last = table.Last(CategoryID:8);\n\n//you can order by whatever you like\nvar firstButReallyLast = table.First(CategoryID:8,OrderBy:\"PK DESC\");\n\n//only want one column?\nvar price = table.First(CategoryID:8,Columns:\"UnitPrice\").UnitPrice;\n\n//Multiple Criteria?\nvar items = table.Find(CategoryID:5, UnitPrice:100, OrderBy:\"UnitPrice DESC\");\n```\n\t\nAggregates with Named Arguments\n-------------------------------\nYou can do the same thing as above for aggregates:\n\n```csharp\nvar sum = table.Sum(columns:\"Price\", CategoryID:5);\nvar avg = table.Avg(columns:\"Price\", CategoryID:3);\nvar min = table.Min(columns:\"ID\");\nvar max = table.Max(columns:\"CreatedOn\");\nvar count = table.Count();\n```\n\t\nMetadata\n--------\nIf you find that you need to know information about your table - to generate some lovely things like ... whatever - just ask for the Schema property. This will query INFORMATION_SCHEMA for you, and you can take a look at DATA_TYPE, DEFAULT_VALUE, etc for whatever system you're running on.\n\nIn addition, if you want to generate an empty instance of a column - you can now ask for a \"Prototype()\" - which will return all the columns in your table with the defaults set for you (getdate(), raw values, newid(), etc).\n\nFactory Constructor\n-------------------\nOne thing that can be useful is to use Massive to just run a quick query. You can do that now by using \"Open()\" which is a static builder on DynamicModel:\n\n```csharp\nvar db = Massive.DynamicModel.Open(\"myConnectionStringName\");\n```\n\nYou can execute whatever you like at that point.\n\nValidations\n-----------\nOne thing that's always needed when working with data is the ability to stop execution if something isn't right. Massive now has Validations, which are built with the Rails approach in mind:\n\n```csharp\npublic class Productions:DynamicModel {\n\tpublic Productions():base(\"MyConnectionString\",\"Productions\",\"ID\") {}\n\tpublic override void Validate(dynamic item) {\n\t\tValidatesPresenceOf(\"Title\");\n\t\tValidatesNumericalityOf(item.Price);\n\t\tValidateIsCurrency(item.Price);\n\t\tif (item.Price <= 0)\n\t\t\tErrors.Add(\"Price can't be negative\");\n\t}\n}\n```\n\nThe idea here is that `Validate()` is called prior to Insert/Update. If it fails, an Error collection is populated and an InvalidOperationException is thrown. That simple. With each of the validations above, a message can be passed in.\n\nCallBacks\n---------\nNeed something to happen after Update/Insert/Delete? Need to halt before save? Massive has callbacks to let you do just that:\n\n```csharp\npublic class Customers:DynamicModel {\n\tpublic Customers():base(\"MyConnectionString\",\"Customers\",\"ID\") {}\n\t\n\t//Add the person to Highrise CRM when they're added to the system...\n\tpublic override void Inserted(dynamic item) {\n\t\t//send them to Highrise\n\t\tvar svc = new HighRiseApi();\n\t\tsvc.AddPerson(...);\n\t}\n}\n```\n\nThe callbacks you can use are:\n\n * Inserted\n * Updated\n * Deleted\n * BeforeDelete\n * BeforeSave\n\n\n\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}