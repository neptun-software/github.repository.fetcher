{
  "metadata": {
    "timestamp": 1736710809897,
    "page": 300,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "dotnet-script/dotnet-script",
      "stars": 2786,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.8662109375,
          "content": "*.doc  diff=astextplain\n*.DOC\tdiff=astextplain\n*.docx\tdiff=astextplain\n*.DOCX\tdiff=astextplain\n*.dot\tdiff=astextplain\n*.DOT\tdiff=astextplain\n*.pdf\tdiff=astextplain\n*.PDF\tdiff=astextplain\n*.rtf\tdiff=astextplain\n*.RTF\tdiff=astextplain\n\n*.jpg  \tbinary\n*.png \tbinary\n*.gif \tbinary\n\n*.cs text=auto diff=csharp \n*.vb text=auto\n*.resx text=auto\n*.c text=auto\n*.cpp text=auto\n*.cxx text=auto\n*.h text=auto\n*.hxx text=auto\n*.py text=auto\n*.rb text=auto\n*.java text=auto\n*.html text=auto\n*.htm text=auto\n*.css text=auto\n*.scss text=auto\n*.sass text=auto\n*.less text=auto\n*.js text=auto\n*.lisp text=auto\n*.clj text=auto\n*.sql text=auto\n*.php text=auto\n*.lua text=auto\n*.m text=auto\n*.asm text=auto\n*.erl text=auto\n*.fs text=auto\n*.fsx text=auto\n*.hs text=auto\n\n*.csproj text=auto\n*.vbproj text=auto\n*.fsproj text=auto\n*.dbproj text=auto\n*.xproj text=auto\n*.sln text=auto eol=crlf\n\n*.sh text eol=lf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 4.4423828125,
          "content": "## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n\n# User-specific files\n*.suo\n*.user\n*.userosscache\n*.sln.docstates\n\n# User-specific files (MonoDevelop/Xamarin Studio)\n*.userprefs\n\n# Build results\n[Dd]ebug/\n[Dd]ebugPublic/\n[Rr]elease/\n[Rr]eleases/\nx64/\nx86/\nbld/\n[Bb]in/\n[Oo]bj/\n[Ll]og/\nbuild/Chocolatey/*.nuspec\nbuild/.vscode\nbuild/Artifacts\ncoverage.info\n# Ignore these since we download dotnet-script into the root folder on the build server.\ndotnet-script\ndotnet-script.zip\n# Visual Studio 2015 cache/options directory\n.vs/\n# Uncomment if you have tasks that create the project's static files in wwwroot\n#wwwroot/\n\n# MSTest test Results\n[Tt]est[Rr]esult*/\n[Bb]uild[Ll]og.*\n\n# NUNIT\n*.VisualState.xml\nTestResult.xml\n\n# Build Results of an ATL Project\n[Dd]ebugPS/\n[Rr]eleasePS/\ndlldata.c\n\n# DNX\nproject.lock.json\nartifacts/\n\n*_i.c\n*_p.c\n*_i.h\n*.ilk\n*.meta\n*.obj\n*.pch\n*.pdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.tmp_proj\n*.log\n*.vspscc\n*.vssscc\n.builds\n*.pidb\n*.svclog\n*.scc\n\n# Chutzpah Test files\n_Chutzpah*\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opendb\n*.opensdf\n*.sdf\n*.cachefile\n*.VC.db\n*.VC.VC.opendb\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n*.sap\n\n# TFS 2012 Local Workspace\n$tf/\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*/\n*.[Rr]e[Ss]harper\n*.DotSettings.user\n\n# JustCode is a .NET coding add-in\n.JustCode\n\n# TeamCity is a build add-in\n_TeamCity*\n\n# DotCover is a Code Coverage Tool\n*.dotCover\n\n# NCrunch\n_NCrunch_*\n.*crunch*.local.xml\nnCrunchTemp_*\n\n# MightyMoose\n*.mm.*\nAutoTest.Net/\n\n# Web workbench (sass)\n.sass-cache/\n\n# Installshield output folder\n[Ee]xpress/\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish/\n\n# Publish Web Output\n*.[Pp]ublish.xml\n*.azurePubxml\n# TODO: Comment the next line if you want to checkin your web deploy settings\n# but database connection strings (with potential passwords) will be unencrypted\n*.pubxml\n*.publishproj\n\n# Microsoft Azure Web App publish settings. Comment the next line if you want to\n# checkin your Azure Web App publish settings, but sensitive information contained\n# in these scripts will be unencrypted\nPublishScripts/\n\n# NuGet Packages\n*.nupkg\n# The packages folder can be ignored because of Package Restore\n**/packages/*\n# except build/, which is used as an MSBuild target.\n!**/packages/build/\n# Uncomment if necessary however generally it will be regenerated when needed\n#!**/packages/repositories.config\n# NuGet v3's project.json files produces more ignoreable files\n*.nuget.props\n*.nuget.targets\n\n# Microsoft Azure Build Output\n\n*.build.csdef\n\n# Microsoft Azure Emulator\necf/\nrcf/\n\n# Windows Store app package directories and files\nAppPackages/\nBundleArtifacts/\nPackage.StoreAssociation.xml\n_pkginfo.txt\n\n# Visual Studio cache files\n# files ending in .cache can be ignored\n*.[Cc]ache\n# but keep track of directories ending in .cache\n!*.[Cc]ache/\n\n# Others\nClientBin/\n~$*\n*~\n*.dbmdl\n*.dbproj.schemaview\n*.pfx\n*.publishsettings\nnode_modules/\norleans.codegen.cs\n\n# Since there are multiple workflows, uncomment next line to ignore bower_components\n# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)\n#bower_components/\n\n# RIA/Silverlight projects\nGenerated_Code/\n\n# Backup & report files from converting an old project file\n# to a newer Visual Studio version. Backup files are not needed,\n# because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\nUpgradeLog*.htm\n\n# SQL Server files\n*.mdf\n*.ldf\n\n# Business Intelligence projects\n*.rdl.data\n*.bim.layout\n*.bim_*.settings\n\n# Microsoft Fakes\nFakesAssemblies/\n\n# GhostDoc plugin setting file\n*.GhostDoc.xml\n\n# Node.js Tools for Visual Studio\n.ntvs_analysis.dat\n\n# Visual Studio 6 build log\n*.plg\n\n# Visual Studio 6 workspace options file\n*.opt\n\n# Visual Studio LightSwitch build output\n**/*.HTMLClient/GeneratedArtifacts\n**/*.DesktopClient/GeneratedArtifacts\n**/*.DesktopClient/ModelManifest.xml\n**/*.Server/GeneratedArtifacts\n**/*.Server/ModelManifest.xml\n_Pvt_Extensions\n\n# Paket dependency manager\n.paket/paket.exe\npaket-files/\n\n# FAKE - F# Make\n.fake/\n\n# JetBrains Rider\n.idea/\n*.sln.iml\n/*.DS_Store\n/src/.DS_Store\nproject.json\n\n# Archive files\n*.zip\n/build/dotnet-script\n/dotnet-script\n/.vscode\n/src/Dotnet.Script/Properties/launchSettings.json\n.DS_Store\n"
        },
        {
          "name": "Dotnet.Script.sln",
          "type": "blob",
          "size": 10.0908203125,
          "content": "Microsoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio Version 16\nVisualStudioVersion = 16.0.31129.286\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Dotnet.Script\", \"src\\Dotnet.Script\\Dotnet.Script.csproj\", \"{057F56AD-AF29-4ABD-B6DE-26E4DEE169F7}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Dotnet.Script.Core\", \"src\\Dotnet.Script.Core\\Dotnet.Script.Core.csproj\", \"{684FEFEE-451B-4E68-B662-C16E3A7DA794}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Dotnet.Script.Extras\", \"src\\Dotnet.Script.Extras\\Dotnet.Script.Extras.csproj\", \"{BCBB3155-4463-4748-8032-EF82AE297CE1}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Dotnet.Script.Tests\", \"src\\Dotnet.Script.Tests\\Dotnet.Script.Tests.csproj\", \"{ADA5A9A5-CBE9-48DA-8C71-318574C986C8}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Dotnet.Script.DependencyModel\", \"src\\Dotnet.Script.DependencyModel\\Dotnet.Script.DependencyModel.csproj\", \"{EA963598-ED46-4530-9094-51F70FCCEDA2}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Dotnet.Script.DependencyModel.NuGet\", \"src\\Dotnet.Script.DependencyModel.Nuget\\Dotnet.Script.DependencyModel.NuGet.csproj\", \"{E361528F-178A-4489-AF01-FFD3A7122D99}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Dotnet.Script.Desktop.Tests\", \"src\\Dotnet.Script.Desktop.Tests\\Dotnet.Script.Desktop.Tests.csproj\", \"{B0E5959C-6E7F-4023-96BA-5AD4A5E00541}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Dotnet.Script.Shared.Tests\", \"src\\Dotnet.Script.Shared.Tests\\Dotnet.Script.Shared.Tests.csproj\", \"{8FFA2816-411E-437C-AB75-FFA546780E7A}\"\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"tests\", \"tests\", \"{F20002BB-970C-4318-B618-58D478CAC405}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|Any CPU = Debug|Any CPU\n\t\tDebug|x64 = Debug|x64\n\t\tDebug|x86 = Debug|x86\n\t\tRelease|Any CPU = Release|Any CPU\n\t\tRelease|x64 = Release|x64\n\t\tRelease|x86 = Release|x86\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{057F56AD-AF29-4ABD-B6DE-26E4DEE169F7}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{057F56AD-AF29-4ABD-B6DE-26E4DEE169F7}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{057F56AD-AF29-4ABD-B6DE-26E4DEE169F7}.Debug|x64.ActiveCfg = Debug|Any CPU\n\t\t{057F56AD-AF29-4ABD-B6DE-26E4DEE169F7}.Debug|x64.Build.0 = Debug|Any CPU\n\t\t{057F56AD-AF29-4ABD-B6DE-26E4DEE169F7}.Debug|x86.ActiveCfg = Debug|Any CPU\n\t\t{057F56AD-AF29-4ABD-B6DE-26E4DEE169F7}.Debug|x86.Build.0 = Debug|Any CPU\n\t\t{057F56AD-AF29-4ABD-B6DE-26E4DEE169F7}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{057F56AD-AF29-4ABD-B6DE-26E4DEE169F7}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{057F56AD-AF29-4ABD-B6DE-26E4DEE169F7}.Release|x64.ActiveCfg = Release|Any CPU\n\t\t{057F56AD-AF29-4ABD-B6DE-26E4DEE169F7}.Release|x64.Build.0 = Release|Any CPU\n\t\t{057F56AD-AF29-4ABD-B6DE-26E4DEE169F7}.Release|x86.ActiveCfg = Release|Any CPU\n\t\t{057F56AD-AF29-4ABD-B6DE-26E4DEE169F7}.Release|x86.Build.0 = Release|Any CPU\n\t\t{684FEFEE-451B-4E68-B662-C16E3A7DA794}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{684FEFEE-451B-4E68-B662-C16E3A7DA794}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{684FEFEE-451B-4E68-B662-C16E3A7DA794}.Debug|x64.ActiveCfg = Debug|Any CPU\n\t\t{684FEFEE-451B-4E68-B662-C16E3A7DA794}.Debug|x64.Build.0 = Debug|Any CPU\n\t\t{684FEFEE-451B-4E68-B662-C16E3A7DA794}.Debug|x86.ActiveCfg = Debug|Any CPU\n\t\t{684FEFEE-451B-4E68-B662-C16E3A7DA794}.Debug|x86.Build.0 = Debug|Any CPU\n\t\t{684FEFEE-451B-4E68-B662-C16E3A7DA794}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{684FEFEE-451B-4E68-B662-C16E3A7DA794}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{684FEFEE-451B-4E68-B662-C16E3A7DA794}.Release|x64.ActiveCfg = Release|Any CPU\n\t\t{684FEFEE-451B-4E68-B662-C16E3A7DA794}.Release|x64.Build.0 = Release|Any CPU\n\t\t{684FEFEE-451B-4E68-B662-C16E3A7DA794}.Release|x86.ActiveCfg = Release|Any CPU\n\t\t{684FEFEE-451B-4E68-B662-C16E3A7DA794}.Release|x86.Build.0 = Release|Any CPU\n\t\t{BCBB3155-4463-4748-8032-EF82AE297CE1}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{BCBB3155-4463-4748-8032-EF82AE297CE1}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{BCBB3155-4463-4748-8032-EF82AE297CE1}.Debug|x64.ActiveCfg = Debug|Any CPU\n\t\t{BCBB3155-4463-4748-8032-EF82AE297CE1}.Debug|x64.Build.0 = Debug|Any CPU\n\t\t{BCBB3155-4463-4748-8032-EF82AE297CE1}.Debug|x86.ActiveCfg = Debug|Any CPU\n\t\t{BCBB3155-4463-4748-8032-EF82AE297CE1}.Debug|x86.Build.0 = Debug|Any CPU\n\t\t{BCBB3155-4463-4748-8032-EF82AE297CE1}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{BCBB3155-4463-4748-8032-EF82AE297CE1}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{BCBB3155-4463-4748-8032-EF82AE297CE1}.Release|x64.ActiveCfg = Release|Any CPU\n\t\t{BCBB3155-4463-4748-8032-EF82AE297CE1}.Release|x64.Build.0 = Release|Any CPU\n\t\t{BCBB3155-4463-4748-8032-EF82AE297CE1}.Release|x86.ActiveCfg = Release|Any CPU\n\t\t{BCBB3155-4463-4748-8032-EF82AE297CE1}.Release|x86.Build.0 = Release|Any CPU\n\t\t{ADA5A9A5-CBE9-48DA-8C71-318574C986C8}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{ADA5A9A5-CBE9-48DA-8C71-318574C986C8}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{ADA5A9A5-CBE9-48DA-8C71-318574C986C8}.Debug|x64.ActiveCfg = Debug|Any CPU\n\t\t{ADA5A9A5-CBE9-48DA-8C71-318574C986C8}.Debug|x64.Build.0 = Debug|Any CPU\n\t\t{ADA5A9A5-CBE9-48DA-8C71-318574C986C8}.Debug|x86.ActiveCfg = Debug|Any CPU\n\t\t{ADA5A9A5-CBE9-48DA-8C71-318574C986C8}.Debug|x86.Build.0 = Debug|Any CPU\n\t\t{ADA5A9A5-CBE9-48DA-8C71-318574C986C8}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{ADA5A9A5-CBE9-48DA-8C71-318574C986C8}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{ADA5A9A5-CBE9-48DA-8C71-318574C986C8}.Release|x64.ActiveCfg = Release|Any CPU\n\t\t{ADA5A9A5-CBE9-48DA-8C71-318574C986C8}.Release|x64.Build.0 = Release|Any CPU\n\t\t{ADA5A9A5-CBE9-48DA-8C71-318574C986C8}.Release|x86.ActiveCfg = Release|Any CPU\n\t\t{ADA5A9A5-CBE9-48DA-8C71-318574C986C8}.Release|x86.Build.0 = Release|Any CPU\n\t\t{EA963598-ED46-4530-9094-51F70FCCEDA2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{EA963598-ED46-4530-9094-51F70FCCEDA2}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{EA963598-ED46-4530-9094-51F70FCCEDA2}.Debug|x64.ActiveCfg = Debug|Any CPU\n\t\t{EA963598-ED46-4530-9094-51F70FCCEDA2}.Debug|x64.Build.0 = Debug|Any CPU\n\t\t{EA963598-ED46-4530-9094-51F70FCCEDA2}.Debug|x86.ActiveCfg = Debug|Any CPU\n\t\t{EA963598-ED46-4530-9094-51F70FCCEDA2}.Debug|x86.Build.0 = Debug|Any CPU\n\t\t{EA963598-ED46-4530-9094-51F70FCCEDA2}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{EA963598-ED46-4530-9094-51F70FCCEDA2}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{EA963598-ED46-4530-9094-51F70FCCEDA2}.Release|x64.ActiveCfg = Release|Any CPU\n\t\t{EA963598-ED46-4530-9094-51F70FCCEDA2}.Release|x64.Build.0 = Release|Any CPU\n\t\t{EA963598-ED46-4530-9094-51F70FCCEDA2}.Release|x86.ActiveCfg = Release|Any CPU\n\t\t{EA963598-ED46-4530-9094-51F70FCCEDA2}.Release|x86.Build.0 = Release|Any CPU\n\t\t{E361528F-178A-4489-AF01-FFD3A7122D99}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{E361528F-178A-4489-AF01-FFD3A7122D99}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{E361528F-178A-4489-AF01-FFD3A7122D99}.Debug|x64.ActiveCfg = Debug|Any CPU\n\t\t{E361528F-178A-4489-AF01-FFD3A7122D99}.Debug|x64.Build.0 = Debug|Any CPU\n\t\t{E361528F-178A-4489-AF01-FFD3A7122D99}.Debug|x86.ActiveCfg = Debug|Any CPU\n\t\t{E361528F-178A-4489-AF01-FFD3A7122D99}.Debug|x86.Build.0 = Debug|Any CPU\n\t\t{E361528F-178A-4489-AF01-FFD3A7122D99}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{E361528F-178A-4489-AF01-FFD3A7122D99}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{E361528F-178A-4489-AF01-FFD3A7122D99}.Release|x64.ActiveCfg = Release|Any CPU\n\t\t{E361528F-178A-4489-AF01-FFD3A7122D99}.Release|x64.Build.0 = Release|Any CPU\n\t\t{E361528F-178A-4489-AF01-FFD3A7122D99}.Release|x86.ActiveCfg = Release|Any CPU\n\t\t{E361528F-178A-4489-AF01-FFD3A7122D99}.Release|x86.Build.0 = Release|Any CPU\n\t\t{B0E5959C-6E7F-4023-96BA-5AD4A5E00541}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{B0E5959C-6E7F-4023-96BA-5AD4A5E00541}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{B0E5959C-6E7F-4023-96BA-5AD4A5E00541}.Debug|x64.ActiveCfg = Debug|Any CPU\n\t\t{B0E5959C-6E7F-4023-96BA-5AD4A5E00541}.Debug|x64.Build.0 = Debug|Any CPU\n\t\t{B0E5959C-6E7F-4023-96BA-5AD4A5E00541}.Debug|x86.ActiveCfg = Debug|Any CPU\n\t\t{B0E5959C-6E7F-4023-96BA-5AD4A5E00541}.Debug|x86.Build.0 = Debug|Any CPU\n\t\t{B0E5959C-6E7F-4023-96BA-5AD4A5E00541}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{B0E5959C-6E7F-4023-96BA-5AD4A5E00541}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{B0E5959C-6E7F-4023-96BA-5AD4A5E00541}.Release|x64.ActiveCfg = Release|Any CPU\n\t\t{B0E5959C-6E7F-4023-96BA-5AD4A5E00541}.Release|x64.Build.0 = Release|Any CPU\n\t\t{B0E5959C-6E7F-4023-96BA-5AD4A5E00541}.Release|x86.ActiveCfg = Release|Any CPU\n\t\t{B0E5959C-6E7F-4023-96BA-5AD4A5E00541}.Release|x86.Build.0 = Release|Any CPU\n\t\t{8FFA2816-411E-437C-AB75-FFA546780E7A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{8FFA2816-411E-437C-AB75-FFA546780E7A}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{8FFA2816-411E-437C-AB75-FFA546780E7A}.Debug|x64.ActiveCfg = Debug|Any CPU\n\t\t{8FFA2816-411E-437C-AB75-FFA546780E7A}.Debug|x64.Build.0 = Debug|Any CPU\n\t\t{8FFA2816-411E-437C-AB75-FFA546780E7A}.Debug|x86.ActiveCfg = Debug|Any CPU\n\t\t{8FFA2816-411E-437C-AB75-FFA546780E7A}.Debug|x86.Build.0 = Debug|Any CPU\n\t\t{8FFA2816-411E-437C-AB75-FFA546780E7A}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{8FFA2816-411E-437C-AB75-FFA546780E7A}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{8FFA2816-411E-437C-AB75-FFA546780E7A}.Release|x64.ActiveCfg = Release|Any CPU\n\t\t{8FFA2816-411E-437C-AB75-FFA546780E7A}.Release|x64.Build.0 = Release|Any CPU\n\t\t{8FFA2816-411E-437C-AB75-FFA546780E7A}.Release|x86.ActiveCfg = Release|Any CPU\n\t\t{8FFA2816-411E-437C-AB75-FFA546780E7A}.Release|x86.Build.0 = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(NestedProjects) = preSolution\n\t\t{ADA5A9A5-CBE9-48DA-8C71-318574C986C8} = {F20002BB-970C-4318-B618-58D478CAC405}\n\t\t{B0E5959C-6E7F-4023-96BA-5AD4A5E00541} = {F20002BB-970C-4318-B618-58D478CAC405}\n\t\t{8FFA2816-411E-437C-AB75-FFA546780E7A} = {F20002BB-970C-4318-B618-58D478CAC405}\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {3B983DCE-42D8-48BE-BCC9-CDE81001EBDA}\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0390625,
          "content": "MIT License\n\nCopyright (c) 2016 Filip W\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "NuGet.Config",
          "type": "blob",
          "size": 0.1943359375,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<configuration>\n<packageSources>\n <add key=\"nuget.org\" value=\"https://api.nuget.org/v3/index.json\" protocolVersion=\"3\" />\n</packageSources>\n</configuration>\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 23.8017578125,
          "content": "# dotnet script\n\nRun C# scripts from the .NET CLI, define NuGet packages inline and edit/debug them in VS Code - all of that with full language services support from OmniSharp.\n\n## Build status\n\n[![Build Status](https://bernhardrichter.visualstudio.com/dotnet-script/_apis/build/status/filipw.dotnet-script?branchName=master)](https://bernhardrichter.visualstudio.com/dotnet-script/_build/latest?definitionId=4&branchName=master)\n\n## NuGet Packages\n\n| Name                                  | Version                                                                                                                                                             | Framework(s)                       |\n| ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------- |\n| `dotnet-script` (global tool)         | [![Nuget](http://img.shields.io/nuget/v/dotnet-script.svg?maxAge=10800)](https://www.nuget.org/packages/dotnet-script/)                                             | `net8.0`,`net9.0`                  |\n| `Dotnet.Script` (CLI as Nuget)        | [![Nuget](http://img.shields.io/nuget/v/dotnet.script.svg?maxAge=10800)](https://www.nuget.org/packages/dotnet.script/)                                             | `net8.0`,`net9.0`                  |\n| `Dotnet.Script.Core`                  | [![Nuget](http://img.shields.io/nuget/v/Dotnet.Script.Core.svg?maxAge=10800)](https://www.nuget.org/packages/Dotnet.Script.Core/)                                   | `net8.0`,`net9.0`,`netstandard2.0` |\n| `Dotnet.Script.DependencyModel`       | [![Nuget](http://img.shields.io/nuget/v/Dotnet.Script.DependencyModel.svg?maxAge=10800)](https://www.nuget.org/packages/Dotnet.Script.DependencyModel/)             | `netstandard2.0`                   |\n| `Dotnet.Script.DependencyModel.Nuget` | [![Nuget](http://img.shields.io/nuget/v/Dotnet.Script.DependencyModel.Nuget.svg?maxAge=10800)](https://www.nuget.org/packages/Dotnet.Script.DependencyModel.Nuget/) | `netstandard2.0`                   |\n\n## Installing\n\n### Prerequisites\n\nThe only thing we need to install is [.NET 8.0 or .NET 9.0 SDK](https://dotnet.microsoft.com/en-us/download/dotnet).\n\n[Note](https://learn.microsoft.com/en-us/dotnet/core/install/linux-scripted-manual#manual-install):\n> If you install the .NET SDK to a non-default location, you need to set the environment variable `DOTNET_ROOT` to the directory that contains the dotnet executable\n\n### .NET Core Global Tool\n\n.NET Core 2.1 introduced the concept of global tools meaning that you can install `dotnet-script` using nothing but the .NET CLI.\n\n```shell\ndotnet tool install -g dotnet-script\n\nYou can invoke the tool using the following command: dotnet-script\nTool 'dotnet-script' (version '0.22.0') was successfully installed.\n```\n\nThe advantage of this approach is that you can use the same command for installation across all platforms.\n.NET Core SDK also supports viewing a list of installed tools and their uninstallation.\n\n```shell\ndotnet tool list -g\n\nPackage Id         Version      Commands\n---------------------------------------------\ndotnet-script      0.22.0       dotnet-script\n```\n\n```shell\ndotnet tool uninstall dotnet-script -g\n\nTool 'dotnet-script' (version '0.22.0') was successfully uninstalled.\n```\n\n### Windows\n\nPowerShell script for installation.\n\n```powershell\n(new-object Net.WebClient).DownloadString(\"https://raw.githubusercontent.com/dotnet-script/dotnet-script/master/install/install.ps1\") | iex\n```\n\n### Linux and Mac\n\n```shell\ncurl -s https://raw.githubusercontent.com/dotnet-script/dotnet-script/master/install/install.sh | bash\n```\n\nIf permission is denied we can try with `sudo`\n\n```shell\ncurl -s https://raw.githubusercontent.com/dotnet-script/dotnet-script/master/install/install.sh | sudo bash\n```\n\n### Docker\n\nA Dockerfile for running dotnet-script in a Linux container is available. Build:\n\n```shell\ncd build\ndocker build -t dotnet-script -f Dockerfile ..\n```\n\nAnd run:\n\n```shell\ndocker run -it dotnet-script --version\n```\n\n### Github\n\nYou can manually download all the releases in `zip` format from the [GitHub releases page](https://github.com/dotnet-script/dotnet-script/releases).\n\n## Usage\n\nOur typical `helloworld.csx` might look like this:\n\n```cs\nConsole.WriteLine(\"Hello world!\");\n```\n\nThat is all it takes and we can execute the script. Args are accessible via the global Args array.\n\n```\ndotnet script helloworld.csx\n```\n\nThe following namespaces are available in the script implicitly and do not need to be imported explicitly:\n\n - System\n - System.IO\n - System.Collections.Generic\n - System.Console\n - System.Diagnostics\n - System.Dynamic\n - System.Linq\n - System.Linq.Expressions\n - System.Text\n - System.Threading.Tasks\n\n### Scaffolding\n\nSimply create a folder somewhere on your system and issue the following command.\n\n```shell\ndotnet script init\n```\n\nThis will create `main.csx` along with the launch configuration needed to debug the script in VS Code.\n\n```shell\n.\n├── .vscode\n│   └── launch.json\n├── main.csx\n└── omnisharp.json\n```\n\nWe can also initialize a folder using a custom filename.\n\n```shell\ndotnet script init custom.csx\n```\n\nInstead of `main.csx` which is the default, we now have a file named `custom.csx`.\n\n```shell\n.\n├── .vscode\n│   └── launch.json\n├── custom.csx\n└── omnisharp.json\n```\n\n> Note: Executing `dotnet script init` inside a folder that already contains one or more script files will not create the `main.csx` file.\n\n### Running scripts\n\nYou can execute your script using **dotnet script** or **dotnet-script**. \n\n```bash\ndotnet script foo.csx\ndotnet-script foo.csx\n```\n\nOn OSX/Linux, scripts can be executed directly from a shell as if they were executables.\n\n```bash\nfoo.csx arg1 arg2 arg3\n```\n\n> OSX/Linux\n>\n> Just like all scripts, on OSX/Linux you need to have a `#!` and mark the file as executable via **chmod +x foo.csx**.\n> If you use **dotnet script init** to create your csx it will automatically have the `#!` directive and be marked as\n> executable.\n\nThe OSX/Linux shebang directive should be **#!/usr/bin/env dotnet-script**\n\n```cs\n#!/usr/bin/env dotnet-script\nConsole.WriteLine(\"Hello world\");\n```\n\nOn Windows, you can run `dotnet script register` to achieve a similar behaviour. This registers dotnet-script in the Windows registry as the tool to process .csx files.\n\nYou can pass arguments to control your script execution more.\n\n```bash\nfoo.csx arg1 arg2 arg3\ndotnet script foo.csx -- arg1 arg2 arg3\ndotnet-script foo.csx -- arg1 arg2 arg3\n```\n\n#### Passing arguments to scripts\n\nAll arguments after `--` are passed to the script in the following way:\n\n```shell\ndotnet script foo.csx -- arg1 arg2 arg3\n```\n\nThen you can access the arguments in the script context using the global `Args` collection:\n\n```c#\nforeach (var arg in Args)\n{\n    Console.WriteLine(arg);\n}\n```\n\nAll arguments before `--` are processed by `dotnet script`. For example, the following command-line\n\n```shell\ndotnet script -d foo.csx -- -d\n```\n\nwill pass the `-d` before `--` to `dotnet script` and enable the debug mode whereas the `-d` after `--` is passed to script for its own interpretation of the argument.\n\n### NuGet Packages\n\n`dotnet script` has built-in support for referencing NuGet packages directly from within the script.\n\n```c#\n#r \"nuget: AutoMapper, 6.1.0\"\n```\n\n![package](https://user-images.githubusercontent.com/1034073/30176983-98a6b85e-9404-11e7-8855-4ae65a20d6b1.gif)\n\n> Note: Omnisharp needs to be restarted after adding a new package reference\n\n#### Package Sources\n\nWe can define package sources using a `NuGet.Config` file in the script root folder. In addition to being used during execution of the script, it will also be used by `OmniSharp` that provides language services for packages resolved from these package sources.\n\nAs an alternative to maintaining a local `NuGet.Config` file we can define these package sources globally either at the user level or at the computer level as described in [Configuring NuGet Behaviour](https://docs.microsoft.com/en-us/nuget/reference/nuget-config-file)\n\nIt is also possible to specify packages sources when executing the script.\n\n```shell\ndotnet script foo.csx -s https://SomePackageSource\n```\n\nMultiple packages sources can be specified like this:\n\n```shell\ndotnet script foo.csx -s https://SomePackageSource -s https://AnotherPackageSource\n```\n\n### Creating DLLs or Exes from a CSX file\n\nDotnet-Script can create a standalone executable or DLL for your script.\n\n| Switch | Long switch                     | description                                                                                                         |\n| ------ | ------------------------------- | ------------------------------------------------------------------------------------------------------------------- |\n| -o     | --output                        | Directory where the published executable should be placed. Defaults to a 'publish' folder in the current directory. |\n| -n     | --name                          | The name for the generated DLL (executable not supported at this time). Defaults to the name of the script.         |\n|        | --dll                           | Publish to a .dll instead of an executable.                                                                         |\n| -c     | --configuration <configuration> | Configuration to use for publishing the script [Release/Debug]. Default is \"Debug\"                                  |\n| -d     | --debug                         | Enables debug output.                                                                                               |\n| -r     | --runtime                       | The runtime used when publishing the self contained executable. Defaults to your current runtime.                   |\n\nThe executable you can run directly independent of dotnet install, while the DLL can be run using the dotnet CLI like this:\n\n```shell\ndotnet script exec {path_to_dll} -- arg1 arg2\n```\n\n### Caching\n\nWe provide two types of caching, the `dependency cache` and the `execution cache` which is explained in detail below. In order for any of these caches to be enabled, it is required that all NuGet package references are specified using an exact version number. The reason for this constraint is that we need to make sure that we don't execute a script with a stale dependency graph.\n\n#### Dependency Cache\n\nIn order to resolve the dependencies for a script, a `dotnet restore` is executed under the hood to produce a `project.assets.json` file from which we can figure out all the dependencies we need to add to the compilation.\nThis is an out-of-process operation and represents a significant overhead to the script execution. So this cache works by looking at all the dependencies specified in the script(s) either in the form of NuGet package references or assembly file references. If these dependencies matches the dependencies from the last script execution, we skip the restore and read the dependencies from the already generated `project.assets.json` file. If any of the dependencies has changed, we must restore again to obtain the new dependency graph.\n\n#### Execution cache\n\nIn order to execute a script it needs to be compiled first and since that is a CPU and time consuming operation, we make sure that we only compile when the source code has changed. This works by creating a SHA256 hash from all the script files involved in the execution. This hash is written to a temporary location along with the DLL that represents the result of the script compilation. When a script is executed the hash is computed and compared with the hash from the previous compilation. If they match there is no need to recompile and we run from the already compiled DLL. If the hashes don't match, the cache is invalidated and we recompile.\n\n> You can override this automatic caching by passing **--no-cache** flag, which will bypass both caches and cause dependency resolution and script compilation to happen every time we execute the script.\n\n#### Cache Location\n\nThe temporary location used for caches is a sub-directory named `dotnet-script` under (in order of priority):\n\n1. The path specified for the value of the environment variable named `DOTNET_SCRIPT_CACHE_LOCATION`, if defined and value is not empty.\n2. Linux distributions only: `$XDG_CACHE_HOME` if defined otherwise `$HOME/.cache`\n3. macOS only: `~/Library/Caches`\n4. The value returned by [`Path.GetTempPath`](https://docs.microsoft.com/en-us/dotnet/api/system.io.path.gettemppath) for the platform.\n\n###\n\n### Debugging\n\nThe days of debugging scripts using `Console.WriteLine` are over. One major feature of `dotnet script` is the ability to debug scripts directly in VS Code. Just set a breakpoint anywhere in your script file(s) and hit F5(start debugging)\n\n![debug](https://user-images.githubusercontent.com/1034073/30173509-2f31596c-93f8-11e7-9124-ca884cf6564e.gif)\n\n### Script Packages\n\nScript packages are a way of organizing reusable scripts into NuGet packages that can be consumed by other scripts. This means that we now can leverage scripting infrastructure without the need for any kind of bootstrapping.\n\n#### Creating a script package\n\nA script package is just a regular NuGet package that contains script files inside the `content` or `contentFiles` folder.\n\nThe following example shows how the scripts are laid out inside the NuGet package according to the [standard convention](https://docs.microsoft.com/en-us/nuget/schema/nuspec#including-content-files) .\n\n```shell\n└── contentFiles\n    └── csx\n        └── netstandard2.0\n            └── main.csx\n```\n\nThis example contains just the `main.csx` file in the root folder, but packages may have multiple script files either in the root folder or in subfolders below the root folder.\n\nWhen loading a script package we will look for an entry point script to be loaded. This entry point script is identified by one of the following.\n\n- A script called `main.csx` in the root folder\n- A single script file in the root folder\n\nIf the entry point script cannot be determined, we will simply load all the scripts files in the package.\n\n> The advantage with using an entry point script is that we can control loading other scripts from the package.\n\n#### Consuming a script package\n\nTo consume a script package all we need to do specify the NuGet package in the `#load`directive.\n\nThe following example loads the [simple-targets](https://www.nuget.org/packages/simple-targets-csx) package that contains script files to be included in our script.\n\n```C#\n#load \"nuget:simple-targets-csx, 6.0.0\"\n\nusing static SimpleTargets;\nvar targets = new TargetDictionary();\n\ntargets.Add(\"default\", () => Console.WriteLine(\"Hello, world!\"));\n\nRun(Args, targets);\n```\n\n> Note: Debugging also works for script packages so that we can easily step into the scripts that are brought in using the `#load` directive.\n\n### Remote Scripts\n\nScripts don't actually have to exist locally on the machine. We can also execute scripts that are made available on an `http(s)` endpoint.\n\nThis means that we can create a Gist on Github and execute it just by providing the URL to the Gist.\n\nThis [Gist](https://gist.githubusercontent.com/seesharper/5d6859509ea8364a1fdf66bbf5b7923d/raw/0a32bac2c3ea807f9379a38e251d93e39c8131cb/HelloWorld.csx) contains a script that prints out \"Hello World\"\n\nWe can execute the script like this\n\n```shell\ndotnet script https://gist.githubusercontent.com/seesharper/5d6859509ea8364a1fdf66bbf5b7923d/raw/0a32bac2c3ea807f9379a38e251d93e39c8131cb/HelloWorld.csx\n```\n\nThat is a pretty long URL, so why don't make it a [TinyURL](https://tinyurl.com/) like this:\n\n```shell\ndotnet script https://tinyurl.com/y8cda9zt\n```\n\n### Script Location\n\nA pretty common scenario is that we have logic that is relative to the script path. We don't want to require the user to be in a certain directory for these paths to resolve correctly so here is how to provide the script path and the script folder regardless of the current working directory.\n\n```c#\npublic static string GetScriptPath([CallerFilePath] string path = null) => path;\npublic static string GetScriptFolder([CallerFilePath] string path = null) => Path.GetDirectoryName(path);\n```\n\n> Tip: Put these methods as top level methods in a separate script file and `#load` that file wherever access to the script path and/or folder is needed.\n\n## REPL\n\nThis release contains a C# REPL (Read-Evaluate-Print-Loop). The REPL mode (\"interactive mode\") is started by executing `dotnet-script` without any arguments.\n\nThe interactive mode allows you to supply individual C# code blocks and have them executed as soon as you press <kbd>Enter</kbd>. The REPL is configured with the same default set of assembly references and using statements as regular CSX script execution.\n\n### Basic usage\n\nOnce `dotnet-script` starts you will see a prompt for input. You can start typing C# code there.\n\n```\n~$ dotnet script\n> var x = 1;\n> x+x\n2\n```\n\nIf you submit an unterminated expression into the REPL (no `;` at the end), it will be evaluated and the result will be serialized using a formatter and printed in the output. This is a bit more interesting than just calling `ToString()` on the object, because it attempts to capture the actual structure of the object. For example:\n\n```\n~$ dotnet script\n> var x = new List<string>();\n> x.Add(\"foo\");\n> x\nList<string>(1) { \"foo\" }\n> x.Add(\"bar\");\n> x\nList<string>(2) { \"foo\", \"bar\" }\n>\n```\n\n### Inline Nuget packages\n\nREPL also supports inline Nuget packages - meaning the Nuget packages can be installed into the REPL from _within the REPL_. This is done via our `#r` and `#load` from Nuget support and uses identical syntax.\n\n```\n~$ dotnet script\n> #r \"nuget: Automapper, 6.1.1\"\n> using AutoMapper;\n> typeof(MapperConfiguration)\n[AutoMapper.MapperConfiguration]\n> #load \"nuget: simple-targets-csx, 6.0.0\";\n> using static SimpleTargets;\n> typeof(TargetDictionary)\n[Submission#0+SimpleTargets+TargetDictionary]\n```\n\n### Multiline mode\n\nUsing Roslyn syntax parsing, we also support multiline REPL mode. This means that if you have an uncompleted code block and press <kbd>Enter</kbd>, we will automatically enter the multiline mode. The mode is indicated by the `*` character. This is particularly useful for declaring classes and other more complex constructs.\n\n```\n~$ dotnet script\n> class Foo {\n* public string Bar {get; set;}\n* }\n> var foo = new Foo();\n```\n\n### REPL commands\n\nAside from the regular C# script code, you can invoke the following commands (directives) from within the REPL:\n\n| Command  | Description                                                  |\n| -------- | ------------------------------------------------------------ |\n| `#load`  | Load a script into the REPL (same as `#load` usage in CSX)   |\n| `#r`     | Load an assembly into the REPL (same as `#r` usage in CSX)   |\n| `#reset` | Reset the REPL back to initial state (without restarting it) |\n| `#cls`   | Clear the console screen without resetting the REPL state    |\n| `#exit`  | Exits the REPL                                               |\n\n### Seeding REPL with a script\n\nYou can execute a CSX script and, at the end of it, drop yourself into the context of the REPL. This way, the REPL becomes \"seeded\" with your code - all the classes, methods or variables are available in the REPL context. This is achieved by running a script with an `-i` flag.\n\nFor example, given the following CSX script:\n\n```csharp\nvar msg = \"Hello World\";\nConsole.WriteLine(msg);\n```\n\nWhen you run this with the `-i` flag, `Hello World` is printed, REPL starts and `msg` variable is available in the REPL context.\n\n```\n~$ dotnet script foo.csx -i\nHello World\n>\n```\n\nYou can also seed the REPL from inside the REPL - at any point - by invoking a `#load` directive pointed at a specific file. For example:\n\n```\n~$ dotnet script\n> #load \"foo.csx\"\nHello World\n>\n```\n\n## Piping\n\nThe following example shows how we can pipe data in and out of a script.\n\nThe `UpperCase.csx` script simply converts the standard input to upper case and writes it back out to standard output.\n\n```csharp\nusing (var streamReader = new StreamReader(Console.OpenStandardInput()))\n{\n    Write(streamReader.ReadToEnd().ToUpper());\n}\n```\n\nWe can now simply pipe the output from one command into our script like this.\n\n```shell\necho \"This is some text\" | dotnet script UpperCase.csx\nTHIS IS SOME TEXT\n```\n\n### Debugging\n\nThe first thing we need to do add the following to the `launch.config` file that allows VS Code to debug a running process.\n\n```JSON\n{\n    \"name\": \".NET Core Attach\",\n    \"type\": \"coreclr\",\n    \"request\": \"attach\",\n    \"processId\": \"${command:pickProcess}\"\n}\n```\n\nTo debug this script we need a way to attach the debugger in VS Code and the simplest thing we can do here is to wait for the debugger to attach by adding this method somewhere.\n\n```c#\npublic static void WaitForDebugger()\n{\n    Console.WriteLine(\"Attach Debugger (VS Code)\");\n    while(!Debugger.IsAttached)\n    {\n    }\n}\n```\n\nTo debug the script when executing it from the command line we can do something like\n\n```c#\nWaitForDebugger();\nusing (var streamReader = new StreamReader(Console.OpenStandardInput()))\n{\n    Write(streamReader.ReadToEnd().ToUpper()); // <- SET BREAKPOINT HERE\n}\n```\n\nNow when we run the script from the command line we will get\n\n```shell\n$ echo \"This is some text\" | dotnet script UpperCase.csx\nAttach Debugger (VS Code)\n```\n\nThis now gives us a chance to attach the debugger before stepping into the script and from VS Code, select the `.NET Core Attach` debugger and pick the process that represents the executing script.\n\nOnce that is done we should see our breakpoint being hit.\n\n## Configuration(Debug/Release)\n\nBy default, scripts will be compiled using the `debug` configuration. This is to ensure that we can debug a script in VS Code as well as attaching a debugger for long running scripts.\n\nThere are however situations where we might need to execute a script that is compiled with the `release` configuration. For instance, running benchmarks using [BenchmarkDotNet](http://benchmarkdotnet.org/) is not possible unless the script is compiled with the `release` configuration.\n\nWe can specify this when executing the script.\n\n```shell\ndotnet script foo.csx -c release\n```\n\n##\n\n## Nullable reference types\n\nStarting from version 0.50.0, `dotnet-script` supports .Net Core 3.0 and all the C# 8 features.\nThe way we deal with [nullable references types](https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references) in `dotnet-script` is that we turn every warning related to nullable reference types into compiler errors. This means every warning between `CS8600` and `CS8655` are treated as an error when compiling the script.\n\nNullable references types are turned off by default and the way we enable it is using the `#nullable enable` compiler directive. This means that existing scripts will continue to work, but we can now opt-in on this new feature.\n\n```csharp\n#!/usr/bin/env dotnet-script\n\n#nullable enable\n\nstring name = null;\n```\n\nTrying to execute the script will result in the following error\n\n```shell\nmain.csx(5,15): error CS8625: Cannot convert null literal to non-nullable reference type.\n```\n\nWe will also see this when working with scripts in VS Code under the problems panel.\n\n![image](https://user-images.githubusercontent.com/1034073/65727087-0e982600-e0b7-11e9-8fa0-d16331ab948a.png)\n\n## Specifying an SDK\n\nStarting with `dotnet-script` 1.4.0 we can now specify the SDK to be used for a script. \n\nFor instance, creating a web server in a script is now as simple as the following.\n\n```csharp\n#r \"sdk:Microsoft.NET.Sdk.Web\"\n\nusing Microsoft.AspNetCore.Builder;\n\nvar a = WebApplication.Create();\na.MapGet(\"/\", () => \"Hello world\");\na.Run();\n```\n\n> Please note the the only SDK currently supported is `Microsoft.NET.Sdk.Web`\n \n## Team\n\n- [Bernhard Richter](https://github.com/seesharper) ([@bernhardrichter](https://twitter.com/bernhardrichter))\n- [Filip W](https://github.com/filipw) ([@filip_woj](https://twitter.com/filip_woj))\n\n## License\n\n[MIT License](https://github.com/dotnet-script/dotnet-script/blob/master/LICENSE)\n - \n"
        },
        {
          "name": "build.ps1",
          "type": "blob",
          "size": 0.3515625,
          "content": "$scriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent\n$dotnetScriptPath = \"$scriptRoot\\build\\dotnet-script\"\nif (!(Test-Path $dotnetScriptPath)) {\n    Write-Host \"Downloading dotnet-script...\"\n    Invoke-Expression \"$scriptRoot\\build\\install-dotnet-script.ps1\"\n}\n\ndotnet \"$dotnetScriptPath\\dotnet-script.dll\" \"$scriptRoot\\build\\build.csx\" -- $scriptRoot"
        },
        {
          "name": "build.sh",
          "type": "blob",
          "size": 0.8642578125,
          "content": "#!/bin/bash\n\nSCRIPT_DIR=$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\nDOTNET_SCRIPT=\"$SCRIPT_DIR/build/dotnet-script\"\nif [ ! -d \"$DOTNET_SCRIPT\" ]; then\n    currentVersion=$(curl https://api.github.com/repos/dotnet-script/dotnet-script/releases/latest?access_token=3a5de576bd32ddfccb52662d2d08d33a7edc318b | grep -Eo \"\\\"tag_name\\\":\\s*\\\"(.*)\\\"\" | cut -d'\"' -f4)\n    echo \"Downloading dotnet-script version $currentVersion...\"\n    curl -L https://github.com/dotnet-script/dotnet-script/releases/download/$currentVersion/dotnet-script.$currentVersion.zip > \"$SCRIPT_DIR/build/dotnet-script.zip\"\n    unzip -o \"$SCRIPT_DIR/build/dotnet-script.zip\" -d \"$SCRIPT_DIR/build/\"\n    if [ $? -ne 0 ]; then\n        echo \"An error occured while downloading dotnet-script\"\n        exit 1\n    fi\nfi\ndotnet \"$DOTNET_SCRIPT/dotnet-script.dll\" \"$SCRIPT_DIR/build/Build.csx\" \"--debug\" -- \"$SCRIPT_DIR\"\n"
        },
        {
          "name": "build",
          "type": "tree",
          "content": null
        },
        {
          "name": "global.json",
          "type": "blob",
          "size": 0.083984375,
          "content": "{\r\n  \"sdk\": {\r\n    \"version\": \"9.0.100\",\r\n    \"rollForward\": \"latestFeature\"\r\n  }\r\n}\r\n"
        },
        {
          "name": "install",
          "type": "tree",
          "content": null
        },
        {
          "name": "omnisharp.json",
          "type": "blob",
          "size": 0.5166015625,
          "content": "{\n  \"fileOptions\": {\n    \"systemExcludeSearchPatterns\": [\n      \"**/TestFixtures/**/*.csx\",\n      \"**/ScriptPackages/**/*.csx\"\n    ],\n    \"userExcludeSearchPatterns\": []\n  },\n  \"script\": {\n    \"enableScriptNuGetReferences\": true,\n    \"defaultTargetFramework\": \"net6.0\"\n  },\n  \"FormattingOptions\": {\n      \"organizeImports\": true,\n      \"enableEditorConfigSupport\": true\n  },\n  \"RoslynExtensionsOptions\": {\n      \"enableImportCompletion\": true,\n      \"enableAnalyzersSupport\": true,\n      \"enableDecompilationSupport\": true\n  }\n}\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}