{
  "metadata": {
    "timestamp": 1736711137646,
    "page": 997,
    "hasNextPage": false,
    "endCursor": "Y3Vyc29yOjEwMDA=",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "stefanprodan/WebApiThrottle",
      "stars": 1277,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.4716796875,
          "content": "# Auto detect text files and perform LF normalization\n* text=auto\n\n# Custom for Visual Studio\n*.cs     diff=csharp\n*.sln    merge=union\n*.csproj merge=union\n*.vbproj merge=union\n*.fsproj merge=union\n*.dbproj merge=union\n\n# Standard to msysgit\n*.doc\t diff=astextplain\n*.DOC\t diff=astextplain\n*.docx diff=astextplain\n*.DOCX diff=astextplain\n*.dot  diff=astextplain\n*.DOT  diff=astextplain\n*.pdf  diff=astextplain\n*.PDF\t diff=astextplain\n*.rtf\t diff=astextplain\n*.RTF\t diff=astextplain\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3671875,
          "content": "[Oo]bj/\n[Bb]in/\nTestResults/\n.nuget/\n_ReSharper.*/\npackages/\nartifacts/\nPublishProfiles/\n*.user\n*.suo\n*.cache\n*.docstates\n_ReSharper.*\nnuget.exe\n*net45.csproj\n*k10.csproj\n*.psess\n*.vsp\n*.pidb\n*.userprefs\n*DS_Store\n*.ncrunchsolution\n*.*sdf\n*.ipch\n.vs/\n.sass-cache/\ntmp/\nThumbs.db\nehthumbs.db\nDesktop.ini\n$RECYCLE.BIN/\nproject.lock.json\n\nbower_components/\nnode_modules/\n*.TMP\n\n\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.0830078125,
          "content": "The MIT License (MIT)\n\nCopyright 2013-2016 Stefan Prodan (https://stefanprodan.com/)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 18.666015625,
          "content": "WebApiThrottle\n==============\n\n[![Build status](https://ci.appveyor.com/api/projects/status/vdvuhk2c0tqds297?svg=true)](https://ci.appveyor.com/project/stefanprodan/webapithrottle) \n[![NuGet](https://img.shields.io/nuget/v/WebApiThrottle.svg)](https://www.nuget.org/packages/WebApiThrottle)\n\nASP.NET Web API Throttling handler, OWIN middleware and filter are designed to control the rate of requests that clients \ncan make to a Web API based on IP address, client API key and request route. \nWebApiThrottle package is available on NuGet at [nuget.org/packages/WebApiThrottle](https://www.nuget.org/packages/WebApiThrottle/).\n\nWeb API throttling can be configured using the built-in ThrottlePolicy. You can set multiple limits \nfor different scenarios like allowing an IP or Client to make a maximum number of calls per second, per minute, per hour per day or even per week.\nYou can define these limits to address all requests made to an API or you can scope the limits to each API route.  \n\n---\nIf you are looking for the ASP.NET Core version please head to [AspNetCoreRateLimit](https://github.com/stefanprodan/AspNetCoreRateLimit) project.\n\nAspNetCoreRateLimit is a full rewrite of WebApiThrottle and offers more flexibility in configuring rate limiting for Web API and MVC apps.\n\n---\n\n### Global throttling based on IP\n\nThe setup bellow will limit the number of requests originated from the same IP. \nIf from the same IP, in same second, you'll make a call to <code>api/values</code> and <code>api/values/1</code> the last call will get blocked.\n\n``` cs\npublic static class WebApiConfig\n{\n\tpublic static void Register(HttpConfiguration config)\n\t{\n\t\tconfig.MessageHandlers.Add(new ThrottlingHandler()\n\t\t{\n\t\t\tPolicy = new ThrottlePolicy(perSecond: 1, perMinute: 20, perHour: 200, perDay: 1500, perWeek: 3000)\n\t\t\t{\n\t\t\t\tIpThrottling = true\n\t\t\t},\n\t\t\tRepository = new CacheRepository()\n\t\t});\n\t}\n}\n```\n\nIf you are self-hosting WebApi with Owin, then you'll have to switch to <code>MemoryCacheRepository</code> that uses the runtime memory cache instead of <code>CacheRepository</code> that uses ASP.NET cache.\n\n``` cs\npublic class Startup\n{\n    public void Configuration(IAppBuilder appBuilder)\n    {\n        // Configure Web API for self-host. \n        HttpConfiguration config = new HttpConfiguration();\n\n        //Register throttling handler\n        config.MessageHandlers.Add(new ThrottlingHandler()\n        {\n            Policy = new ThrottlePolicy(perSecond: 1, perMinute: 20, perHour: 200, perDay: 1500, perWeek: 3000)\n            {\n                IpThrottling = true\n            },\n            Repository = new MemoryCacheRepository()\n        });\n\n        appBuilder.UseWebApi(config);\n    }\n}\n```\n\n### Endpoint throttling based on IP\n\nIf, from the same IP, in the same second, you'll make two calls to <code>api/values</code>, the last call will get blocked.\nBut if in the same second you call <code>api/values/1</code> too, the request will go through because it's a different route.\n\n``` cs\nconfig.MessageHandlers.Add(new ThrottlingHandler()\n{\n\tPolicy = new ThrottlePolicy(perSecond: 1, perMinute: 30)\n\t{\n\t\tIpThrottling = true,\n\t\tEndpointThrottling = true\n\t},\n\tRepository = new CacheRepository()\n});\n```\n\n### Endpoint throttling based on IP and Client Key\n\nIf a client (identified by an unique API key) from the same IP, in the same second, makes two calls to <code>api/values</code>, then the last call will get blocked. \nIf you want to apply limits to clients regardless of their IPs then you should set IpThrottling to false.\n\n``` cs\nconfig.MessageHandlers.Add(new ThrottlingHandler()\n{\n\tPolicy = new ThrottlePolicy(perSecond: 1, perMinute: 30)\n\t{\n\t\tIpThrottling = true,\n\t\tClientThrottling = true,\n\t\tEndpointThrottling = true\n\t},\n\tRepository = new CacheRepository()\n});\n```\n\n### IP and/or Client Key White-listing\n\nIf requests are initiated from a white-listed IP or Client, then the throttling policy will not be applied and the requests will not get stored. The IP white-list supports IP v4 and v6 ranges like \"192.168.0.0/24\", \"fe80::/10\" and \"192.168.0.0-192.168.0.255\" for more information check [jsakamoto/ipaddressrange](https://github.com/jsakamoto/ipaddressrange).\n\n``` cs\nconfig.MessageHandlers.Add(new ThrottlingHandler()\n{\n\tPolicy = new ThrottlePolicy(perSecond: 2, perMinute: 60)\n\t{\n\t\tIpThrottling = true,\n\t\tIpWhitelist = new List<string> { \"::1\", \"192.168.0.0/24\" },\n\t\t\n\t\tClientThrottling = true,\n\t\tClientWhitelist = new List<string> { \"admin-key\" }\n\t},\n\tRepository = new CacheRepository()\n});\n```\n\n### IP and/or Client Key custom rate limits\n\nYou can define custom limits for known IPs or Client Keys, these limits will override the default ones. Be aware that a custom limit will only work if you have defined a global counterpart.\n\n``` cs\nconfig.MessageHandlers.Add(new ThrottlingHandler()\n{\n\tPolicy = new ThrottlePolicy(perSecond: 1, perMinute: 20, perHour: 200, perDay: 1500)\n\t{\n\t\tIpThrottling = true,\n\t\tIpRules = new Dictionary<string, RateLimits>\n\t\t{ \n\t\t\t{ \"192.168.1.1\", new RateLimits { PerSecond = 2 } },\n\t\t\t{ \"192.168.2.0/24\", new RateLimits { PerMinute = 30, PerHour = 30*60, PerDay = 30*60*24 } }\n\t\t},\n\t\t\n\t\tClientThrottling = true,\n\t\tClientRules = new Dictionary<string, RateLimits>\n\t\t{ \n\t\t\t{ \"api-client-key-1\", new RateLimits { PerMinute = 40, PerHour = 400 } },\n\t\t\t{ \"api-client-key-9\", new RateLimits { PerDay = 2000 } }\n\t\t}\n\t},\n\tRepository = new CacheRepository()\n});\n```\n### Endpoint custom rate limits\n\nYou can also define custom limits for certain routes, these limits will override the default ones. \nYou can define endpoint rules by providing relative routes like <code>api/entry/1</code> or just a URL segment like <code>/entry/</code>. \nThe endpoint throttling engine will search for the expression you've provided in the absolute URI, \nif the expression is contained in the request route then the rule will be applied. \nIf two or more rules match the same URI then the lower limit will be applied.\n\n``` cs\nconfig.MessageHandlers.Add(new ThrottlingHandler()\n{\n\tPolicy = new ThrottlePolicy(perSecond: 1, perMinute: 20, perHour: 200)\n\t{\n\t\tIpThrottling = true,\n\t\tClientThrottling = true,\n\t\tEndpointThrottling = true,\n\t\tEndpointRules = new Dictionary<string, RateLimits>\n\t\t{ \n\t\t\t{ \"api/search\", new RateLimits { PerSecond = 10, PerMinute = 100, PerHour = 1000 } }\n\t\t}\n\t},\n\tRepository = new CacheRepository()\n});\n```\n\n### Stack rejected requests\n\nBy default, rejected calls are not added to the throttle counter. If a client makes 3 requests per second \nand you've set a limit of one call per second, the minute, hour and day counters will only record the first call, the one that wasn't blocked.\nIf you want rejected requests to count towards the other limits, you'll have to set <code>StackBlockedRequests</code> to true.\n\n``` cs\nconfig.MessageHandlers.Add(new ThrottlingHandler()\n{\n\tPolicy = new ThrottlePolicy(perSecond: 1, perMinute: 30)\n\t{\n\t\tIpThrottling = true,\n\t\tClientThrottling = true,\n\t\tEndpointThrottling = true,\n\t\tStackBlockedRequests = true\n\t},\n\tRepository = new CacheRepository()\n});\n```\n\n### Define rate limits in web.config or app.config\n\nWebApiThrottle comes with a custom configuration section that lets you define the throttle policy as xml.\n\n``` cs\nconfig.MessageHandlers.Add(new ThrottlingHandler()\n{\n    Policy = ThrottlePolicy.FromStore(new PolicyConfigurationProvider()),\n    Repository = new CacheRepository()\n});\n```\n\nConfig example (policyType values are 1 - IP, 2 - ClientKey, 3 - Endpoint):\n``` xml\n<configuration>\n  \n  <configSections>\n    <section name=\"throttlePolicy\" \n             type=\"WebApiThrottle.ThrottlePolicyConfiguration, WebApiThrottle\" />\n  </configSections>\n  \n  <throttlePolicy limitPerSecond=\"1\"\n                  limitPerMinute=\"10\"\n                  limitPerHour=\"30\"\n                  limitPerDay=\"300\"\n                  limitPerWeek =\"1500\"\n                  ipThrottling=\"true\"\n                  clientThrottling=\"true\"\n                  endpointThrottling=\"true\">\n    <rules>\n      <!--Ip rules-->\n      <add policyType=\"1\" entry=\"::1/10\"\n           limitPerSecond=\"2\"\n           limitPerMinute=\"15\"/>\n      <add policyType=\"1\" entry=\"192.168.2.1\"\n           limitPerMinute=\"12\" />\n      <!--Client rules-->\n      <add policyType=\"2\" entry=\"api-client-key-1\"\n           limitPerHour=\"60\" />\n      <!--Endpoint rules-->\n      <add policyType=\"3\" entry=\"api/values\"\n           limitPerDay=\"120\" />\n    </rules>\n    <whitelists>\n      <!--Ip whitelist-->\n      <add policyType=\"1\" entry=\"127.0.0.1\" />\n      <add policyType=\"1\" entry=\"192.168.0.0/24\" />\n      <!--Client whitelist-->\n      <add policyType=\"2\" entry=\"api-admin-key\" />\n    </whitelists>\n  </throttlePolicy>\n\n</configuration>\n``` \n\n### Retrieving API Client Key\n\nBy default, the ThrottlingHandler retrieves the client API key from the \"Authorization-Token\" request header value. \nIf your API key is stored differently, you can override the <code>ThrottlingHandler.SetIdentity</code> function and specify your own retrieval method.\n\n``` cs\npublic class CustomThrottlingHandler : ThrottlingHandler\n{\n\tprotected override RequestIdentity SetIdentity(HttpRequestMessage request)\n\t{\n\t\treturn new RequestIdentity()\n\t\t{\n\t\t\tClientKey = request.Headers.Contains(\"Authorization-Key\") ? request.Headers.GetValues(\"Authorization-Key\").First() : \"anon\",\n\t\t\tClientIp = base.GetClientIp(request).ToString(),\n\t\t\tEndpoint = request.RequestUri.AbsolutePath.ToLowerInvariant()\n\t\t};\n\t}\n}\n```\n\n### Storing throttle metrics \n\nWebApiThrottle stores all request data in-memory using ASP.NET Cache when hosted in IIS or Runtime MemoryCache when self-hosted with Owin. If you want to change the storage to Velocity, Redis or a NoSQL database, all you have to do is create your own repository by implementing the <code>IThrottleRepository</code> interface. \n\n``` cs\npublic interface IThrottleRepository\n{\n\tbool Any(string id);\n\t\n\tThrottleCounter? FirstOrDefault(string id);\n\t\n\tvoid Save(string id, ThrottleCounter throttleCounter, TimeSpan expirationTime);\n\t\n\tvoid Remove(string id);\n\t\n\tvoid Clear();\n}\n```\n\nSince version 1.2 there is an interface for storing and retrieving the policy object as well. The <code>IPolicyRepository</code> is used to update the policy object at runtime.\n\n``` cs\npublic interface IPolicyRepository\n{\n    ThrottlePolicy FirstOrDefault(string id);\n    \n    void Remove(string id);\n    \n    void Save(string id, ThrottlePolicy policy);\n}\n```\n\n### Update rate limits at runtime\n\nIn order to update the policy object at runtime you'll need to use the new <code>ThrottlingHandler</code> constructor along with <code>ThrottleManager.UpdatePolicy</code> function introduced in WebApiThrottle v1.2.  \n\nRegister the <code>ThrottlingHandler</code> providing <code>PolicyCacheRepository</code> in the constructor, if you are self-hosting the service with Owin then use <code>PolicyMemoryCacheRepository</code>:\n\n``` cs\npublic static void Register(HttpConfiguration config)\n{\n    //trace provider\n    var traceWriter = new SystemDiagnosticsTraceWriter()\n    {\n        IsVerbose = true\n    };\n    config.Services.Replace(typeof(ITraceWriter), traceWriter);\n    config.EnableSystemDiagnosticsTracing();\n\n    //Web API throttling handler\n    config.MessageHandlers.Add(new ThrottlingHandler(\n        policy: new ThrottlePolicy(perMinute: 20, perHour: 30, perDay: 35, perWeek: 3000)\n        {\n            //scope to IPs\n            IpThrottling = true,\n            \n            //scope to clients\n            ClientThrottling = true,\n            ClientRules = new Dictionary<string, RateLimits>\n            { \n                { \"api-client-key-1\", new RateLimits { PerMinute = 60, PerHour = 600 } },\n                { \"api-client-key-2\", new RateLimits { PerDay = 5000 } }\n            },\n\n            //scope to endpoints\n            EndpointThrottling = true\n        },\n        \n        //replace with PolicyMemoryCacheRepository for Owin self-host\n        policyRepository: new PolicyCacheRepository(),\n        \n        //replace with MemoryCacheRepository for Owin self-host\n        repository: new CacheRepository(),\n        \n        logger: new TracingThrottleLogger(traceWriter)));\n}\n\n```\n\nWhen you want to update the policy object call the static method <code>ThrottleManager.UpdatePolicy</code> anywhere in you code.\n\n``` cs\npublic void UpdateRateLimits()\n{\n    //init policy repo\n    var policyRepository = new PolicyCacheRepository();\n\n    //get policy object from cache\n    var policy = policyRepository.FirstOrDefault(ThrottleManager.GetPolicyKey());\n\n    //update client rate limits\n    policy.ClientRules[\"api-client-key-1\"] =\n        new RateLimits { PerMinute = 80, PerHour = 800 };\n\n    //add new client rate limits\n    policy.ClientRules.Add(\"api-client-key-3\",\n        new RateLimits { PerMinute = 60, PerHour = 600 });\n\n    //apply policy updates\n    ThrottleManager.UpdatePolicy(policy, policyRepository);\n\n}\n```\n\n### Logging throttled requests\n\nIf you want to log throttled requests you'll have to implement IThrottleLogger interface and provide it to the ThrottlingHandler. \n\n``` cs\npublic interface IThrottleLogger\n{\n\tvoid Log(ThrottleLogEntry entry);\n}\n```\n\nLogging implementation example with ITraceWriter\n``` cs\npublic class TracingThrottleLogger : IThrottleLogger\n{\n    private readonly ITraceWriter traceWriter;\n        \n    public TracingThrottleLogger(ITraceWriter traceWriter)\n    {\n        this.traceWriter = traceWriter;\n    }\n       \n    public void Log(ThrottleLogEntry entry)\n    {\n        if (null != traceWriter)\n        {\n            traceWriter.Info(entry.Request, \"WebApiThrottle\",\n                \"{0} Request {1} from {2} has been throttled (blocked), quota {3}/{4} exceeded by {5}\",\n                entry.LogDate, entry.RequestId, entry.ClientIp, entry.RateLimit, entry.RateLimitPeriod, entry.TotalRequests);\n        }\n    }\n}\n```\n\nLogging usage example with SystemDiagnosticsTraceWriter and ThrottlingHandler\n``` cs\nvar traceWriter = new SystemDiagnosticsTraceWriter()\n{\n    IsVerbose = true\n};\nconfig.Services.Replace(typeof(ITraceWriter), traceWriter);\nconfig.EnableSystemDiagnosticsTracing();\n            \nconfig.MessageHandlers.Add(new ThrottlingHandler()\n{\n\tPolicy = new ThrottlePolicy(perSecond: 1, perMinute: 30)\n\t{\n\t\tIpThrottling = true,\n\t\tClientThrottling = true,\n\t\tEndpointThrottling = true\n\t},\n\tRepository = new CacheRepository(),\n\tLogger = new TracingThrottleLogger(traceWriter)\n});\n```\n\n### Attribute-based rate limiting with ThrottlingFilter and EnableThrottlingAttribute\n\nAs an alternative to the ThrottlingHandler, ThrottlingFilter does the same thing but allows custom rate limits to be specified by decorating Web API controllers and actions with EnableThrottlingAttribute. Be aware that when a request is processed, the ThrottlingHandler executes before the http controller dispatcher in the [Web API request pipeline](https://www.asp.net/media/4071077/aspnet-web-api-poster.pdf), therefore it is preferable that you always use the handler instead of the filter when you don't need the features that the ThrottlingFilter provides.\n\nSetup the filter as you would the ThrottlingHandler:\n\n``` cs\nconfig.Filters.Add(new ThrottlingFilter()\n{\n    Policy = new ThrottlePolicy(perSecond: 1, perMinute: 20, \n    perHour: 200, perDay: 2000, perWeek: 10000)\n    {\n        //scope to IPs\n        IpThrottling = true,\n        IpRules = new Dictionary<string, RateLimits>\n        { \n            { \"::1/10\", new RateLimits { PerSecond = 2 } },\n            { \"192.168.2.1\", new RateLimits { PerMinute = 30, PerHour = 30*60, PerDay = 30*60*24 } }\n        },\n        //white list the \"::1\" IP to disable throttling on localhost\n        IpWhitelist = new List<string> { \"127.0.0.1\", \"192.168.0.0/24\" },\n\n        //scope to clients (if IP throttling is applied then the scope becomes a combination of IP and client key)\n        ClientThrottling = true,\n        ClientRules = new Dictionary<string, RateLimits>\n        { \n            { \"api-client-key-demo\", new RateLimits { PerDay = 5000 } }\n        },\n        //white list API keys that don’t require throttling\n        ClientWhitelist = new List<string> { \"admin-key\" },\n\n        //Endpoint rate limits will be loaded from EnableThrottling attribute\n        EndpointThrottling = true\n    }\n});\n```\n\nUse the attributes to toggle throttling and set rate limits:\n\n``` cs\n[EnableThrottling(PerSecond = 2)]\npublic class ValuesController : ApiController\n{\n    [EnableThrottling(PerSecond = 1, PerMinute = 30, PerHour = 100)]\n    public IEnumerable<string> Get()\n    {\n        return new string[] { \"value1\", \"value2\" };\n    }\n\n    [DisableThrotting]\n    public string Get(int id)\n    {\n        return \"value\";\n    }\n}\n```\n\n### Rate limiting with ThrottlingMiddleware\n\nThrottlingMiddleware is an OWIN middleware component that works the same as the ThrottlingHandler. With the ThrottlingMiddleware you can target endpoints outside of the WebAPI area, like OAuth middleware or SignalR endpoints.\n\nSelf-hosted configuration example:\n\n``` cs\npublic class Startup\n{\n    public void Configuration(IAppBuilder appBuilder)\n    {\n        ...\n\n        //throtting middleware with policy loaded from app.config\n        appBuilder.Use(typeof(ThrottlingMiddleware),\n            ThrottlePolicy.FromStore(new PolicyConfigurationProvider()),\n            new PolicyMemoryCacheRepository(),\n            new MemoryCacheRepository(),\n            null,\n            null);\n\n        ...\n    }\n}\n```\n\nIIS hosted configuration example:\n\n``` cs\npublic class Startup\n{\n    public void Configuration(IAppBuilder appBuilder)\n    {\n        ...\n\n\t//throtting middleware with policy loaded from web.config\n\tappBuilder.Use(typeof(ThrottlingMiddleware),\n\t    ThrottlePolicy.FromStore(new PolicyConfigurationProvider()),\n\t    new PolicyCacheRepository(),\n\t    new CacheRepository(),\n        null,\n        null);\n\n        ...\n    }\n}\n```\n\n### Custom ip address parsing\n\nIf you need to extract client ip's from e.g. additional headers then you can plug in custom ipAddressParsers.\nThere is an example implementation in the WebApiThrottle.Demo project - <code>WebApiThrottle.Demo.Net.CustomIpAddressParser</code>\n\n``` cs\nconfig.MessageHandlers.Add(new ThrottlingHandler(\n    policy: new ThrottlePolicy(perMinute: 20, perHour: 30, perDay: 35, perWeek: 3000)\n    {        \n        IpThrottling = true,\n        ///...\n    },\n    policyRepository: new PolicyCacheRepository(),\n    repository: new CacheRepository(),\n    logger: new TracingThrottleLogger(traceWriter),\n    ipAddressParser: new CustomIpAddressParser()));\n```\n\n### Custom Quota Exceeded Response\n\nIf you want to customize the quota exceeded response you can set the properties <code>QuotaExceededResponseCode</code> and <code>QuotaExceededMessage</code>.\n\n``` cs\nconfig.MessageHandlers.Add(new ThrottlingHandler(\n    policy: new ThrottlePolicy(perMinute: 20, perHour: 30, perDay: 35, perWeek: 3000)\n    {        \n        IpThrottling = true,\n        ///...\n    },\n    repository: new CacheRepository(),\n    QuotaExceededResponseCode = HttpStatusCode.ServiceUnavailable,\n    QuotaExceededMessage = \"Too many calls! We can only allow {0} per {1}\"));\n```"
        },
        {
          "name": "WebApiThrottle.StrongName",
          "type": "tree",
          "content": null
        },
        {
          "name": "WebApiThrottle.Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "WebApiThrottle.WebApiDemo",
          "type": "tree",
          "content": null
        },
        {
          "name": "WebApiThrottle.sln",
          "type": "blob",
          "size": 3.244140625,
          "content": "﻿\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio 14\nVisualStudioVersion = 14.0.25420.1\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"WebApiThrottle\", \"WebApiThrottle\\WebApiThrottle.csproj\", \"{F049811F-BC05-4CEE-B329-CE3BF2E2E4BE}\"\nEndProject\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"WebApiThrottler.SelfHostOwinDemo\", \"WebApiThrottler.SelfHostOwinDemo\\WebApiThrottler.SelfHostOwinDemo.csproj\", \"{22B91BA0-EFC9-4AF8-A24B-CF1CB476A50D}\"\nEndProject\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"Readme\", \"Readme\", \"{D4FF492F-0AB9-4F78-9F9E-99ADE0D8C3AC}\"\n\tProjectSection(SolutionItems) = preProject\n\t\tLICENSE.md = LICENSE.md\n\t\tREADME.md = README.md\n\tEndProjectSection\nEndProject\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"WebApiThrottle.WebApiDemo\", \"WebApiThrottle.WebApiDemo\\WebApiThrottle.WebApiDemo.csproj\", \"{62251AC4-F48A-442B-B1B3-0164D97661EE}\"\nEndProject\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"WebApiThrottle.StrongName\", \"WebApiThrottle.StrongName\\WebApiThrottle.StrongName.csproj\", \"{FBF3012B-08EF-408C-9E7D-175ABF286CB4}\"\nEndProject\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"WebApiThrottle.Tests\", \"WebApiThrottle.Tests\\WebApiThrottle.Tests.csproj\", \"{A2DB243C-DFD4-4E22-9753-ED95CF6FC21E}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|Any CPU = Debug|Any CPU\n\t\tRelease|Any CPU = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{F049811F-BC05-4CEE-B329-CE3BF2E2E4BE}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{F049811F-BC05-4CEE-B329-CE3BF2E2E4BE}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{F049811F-BC05-4CEE-B329-CE3BF2E2E4BE}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{F049811F-BC05-4CEE-B329-CE3BF2E2E4BE}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{22B91BA0-EFC9-4AF8-A24B-CF1CB476A50D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{22B91BA0-EFC9-4AF8-A24B-CF1CB476A50D}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{22B91BA0-EFC9-4AF8-A24B-CF1CB476A50D}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{22B91BA0-EFC9-4AF8-A24B-CF1CB476A50D}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{62251AC4-F48A-442B-B1B3-0164D97661EE}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{62251AC4-F48A-442B-B1B3-0164D97661EE}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{62251AC4-F48A-442B-B1B3-0164D97661EE}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{62251AC4-F48A-442B-B1B3-0164D97661EE}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{FBF3012B-08EF-408C-9E7D-175ABF286CB4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{FBF3012B-08EF-408C-9E7D-175ABF286CB4}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{FBF3012B-08EF-408C-9E7D-175ABF286CB4}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{FBF3012B-08EF-408C-9E7D-175ABF286CB4}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{A2DB243C-DFD4-4E22-9753-ED95CF6FC21E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{A2DB243C-DFD4-4E22-9753-ED95CF6FC21E}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{A2DB243C-DFD4-4E22-9753-ED95CF6FC21E}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{A2DB243C-DFD4-4E22-9753-ED95CF6FC21E}.Release|Any CPU.Build.0 = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "WebApiThrottle",
          "type": "tree",
          "content": null
        },
        {
          "name": "WebApiThrottler.SelfHostOwinDemo",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}