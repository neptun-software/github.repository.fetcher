{
  "metadata": {
    "timestamp": 1736557648893,
    "page": 743,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "charmbracelet/bubbletea",
      "stars": 28971,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.01,
          "content": "*.golden -text\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.51,
          "content": ".DS_Store\n.envrc\n\nexamples/fullscreen/fullscreen\nexamples/help/help\nexamples/http/http\nexamples/list-default/list-default\nexamples/list-fancy/list-fancy\nexamples/list-simple/list-simple\nexamples/mouse/mouse\nexamples/pager/pager\nexamples/progress-download/color_vortex.blend\nexamples/progress-download/progress-download\nexamples/simple/simple\nexamples/spinner/spinner\nexamples/textinput/textinput\nexamples/textinputs/textinputs\nexamples/views/views\ntutorials/basics/basics\ntutorials/commands/commands\n.idea\ncoverage.txt\ndist/\n"
        },
        {
          "name": ".golangci-soft.yml",
          "type": "blob",
          "size": 0.57,
          "content": "run:\n  tests: false\n  issues-exit-code: 0\n\nissues:\n  include:\n    - EXC0001\n    - EXC0005\n    - EXC0011\n    - EXC0012\n    - EXC0013\n\n  max-issues-per-linter: 0\n  max-same-issues: 0\n\nlinters:\n  enable:\n    - exhaustive\n    - goconst\n    - godot\n    - godox\n    - mnd\n    - gomoddirectives\n    - goprintffuncname\n    - misspell\n    - nakedret\n    - nestif\n    - noctx\n    - nolintlint\n    - prealloc\n    - wrapcheck\n\n  # disable default linters, they are already enabled in .golangci.yml\n  disable:\n    - errcheck\n    - gosimple\n    - govet\n    - ineffassign\n    - staticcheck\n    - unused\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.36,
          "content": "run:\n  tests: false\n\nissues:\n  include:\n    - EXC0001\n    - EXC0005\n    - EXC0011\n    - EXC0012\n    - EXC0013\n\n  max-issues-per-linter: 0\n  max-same-issues: 0\n\nlinters:\n  enable:\n    - bodyclose\n    - gofumpt\n    - goimports\n    - gosec\n    - nilerr\n    - revive\n    - rowserrcheck\n    - sqlclosecheck\n    - tparallel\n    - unconvert\n    - unparam\n    - whitespace\n"
        },
        {
          "name": ".goreleaser.yml",
          "type": "blob",
          "size": 0.16,
          "content": "# yaml-language-server: $schema=https://goreleaser.com/static/schema-pro.json\nversion: 2\nincludes:\n  - from_url:\n      url: charmbracelet/meta/main/goreleaser-lib.yaml\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.05,
          "content": "MIT License\n\nCopyright (c) 2020-2023 Charmbracelet, Inc\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 14.46,
          "content": "# Bubble Tea\n\n<p>\n    <a href=\"https://stuff.charm.sh/bubbletea/bubbletea-4k.png\"><img src=\"https://github.com/charmbracelet/bubbletea/assets/25087/108d4fdb-d554-4910-abed-2a5f5586a60e\" width=\"313\" alt=\"Bubble Tea Title Treatment\"></a><br>\n    <a href=\"https://github.com/charmbracelet/bubbletea/releases\"><img src=\"https://img.shields.io/github/release/charmbracelet/bubbletea.svg\" alt=\"Latest Release\"></a>\n    <a href=\"https://pkg.go.dev/github.com/charmbracelet/bubbletea?tab=doc\"><img src=\"https://godoc.org/github.com/charmbracelet/bubbletea?status.svg\" alt=\"GoDoc\"></a>\n    <a href=\"https://github.com/charmbracelet/bubbletea/actions\"><img src=\"https://github.com/charmbracelet/bubbletea/actions/workflows/build.yml/badge.svg\" alt=\"Build Status\"></a>\n    <a href=\"https://www.phorm.ai/query?projectId=a0e324b6-b706-4546-b951-6671ea60c13f\"><img src=\"https://stuff.charm.sh/misc/phorm-badge.svg\" alt=\"phorm.ai\"></a>\n</p>\n\nThe fun, functional and stateful way to build terminal apps. A Go framework\nbased on [The Elm Architecture][elm]. Bubble Tea is well-suited for simple and\ncomplex terminal applications, either inline, full-window, or a mix of both.\n\n<p>\n    <img src=\"https://stuff.charm.sh/bubbletea/bubbletea-example.gif\" width=\"100%\" alt=\"Bubble Tea Example\">\n</p>\n\nBubble Tea is in use in production and includes a number of features and\nperformance optimizations we’ve added along the way. Among those is\na framerate-based renderer, mouse support, focus reporting and more.\n\nTo get started, see the tutorial below, the [examples][examples], the\n[docs][docs], the [video tutorials][youtube] and some common [resources](#libraries-we-use-with-bubble-tea).\n\n[youtube]: https://charm.sh/yt\n\n## By the way\n\nBe sure to check out [Bubbles][bubbles], a library of common UI components for Bubble Tea.\n\n<p>\n    <a href=\"https://github.com/charmbracelet/bubbles\"><img src=\"https://stuff.charm.sh/bubbles/bubbles-badge.png\" width=\"174\" alt=\"Bubbles Badge\"></a>&nbsp;&nbsp;\n    <a href=\"https://github.com/charmbracelet/bubbles\"><img src=\"https://stuff.charm.sh/bubbles-examples/textinput.gif\" width=\"400\" alt=\"Text Input Example from Bubbles\"></a>\n</p>\n\n---\n\n## Tutorial\n\nBubble Tea is based on the functional design paradigms of [The Elm\nArchitecture][elm], which happens to work nicely with Go. It's a delightful way\nto build applications.\n\nThis tutorial assumes you have a working knowledge of Go.\n\nBy the way, the non-annotated source code for this program is available\n[on GitHub][tut-source].\n\n[elm]: https://guide.elm-lang.org/architecture/\n[tut-source]: https://github.com/charmbracelet/bubbletea/tree/master/tutorials/basics\n\n### Enough! Let's get to it.\n\nFor this tutorial, we're making a shopping list.\n\nTo start we'll define our package and import some libraries. Our only external\nimport will be the Bubble Tea library, which we'll call `tea` for short.\n\n```go\npackage main\n\n// These imports will be used later on the tutorial. If you save the file\n// now, Go might complain they are unused, but that's fine.\n// You may also need to run `go mod tidy` to download bubbletea and its\n// dependencies.\nimport (\n    \"fmt\"\n    \"os\"\n\n    tea \"github.com/charmbracelet/bubbletea\"\n)\n```\n\nBubble Tea programs are comprised of a **model** that describes the application\nstate and three simple methods on that model:\n\n- **Init**, a function that returns an initial command for the application to run.\n- **Update**, a function that handles incoming events and updates the model accordingly.\n- **View**, a function that renders the UI based on the data in the model.\n\n### The Model\n\nSo let's start by defining our model which will store our application's state.\nIt can be any type, but a `struct` usually makes the most sense.\n\n```go\ntype model struct {\n    choices  []string           // items on the to-do list\n    cursor   int                // which to-do list item our cursor is pointing at\n    selected map[int]struct{}   // which to-do items are selected\n}\n```\n\n### Initialization\n\nNext, we’ll define our application’s initial state. In this case, we’re defining\na function to return our initial model, however, we could just as easily define\nthe initial model as a variable elsewhere, too.\n\n```go\nfunc initialModel() model {\n\treturn model{\n\t\t// Our to-do list is a grocery list\n\t\tchoices:  []string{\"Buy carrots\", \"Buy celery\", \"Buy kohlrabi\"},\n\n\t\t// A map which indicates which choices are selected. We're using\n\t\t// the  map like a mathematical set. The keys refer to the indexes\n\t\t// of the `choices` slice, above.\n\t\tselected: make(map[int]struct{}),\n\t}\n}\n```\n\nNext, we define the `Init` method. `Init` can return a `Cmd` that could perform\nsome initial I/O. For now, we don't need to do any I/O, so for the command,\nwe'll just return `nil`, which translates to \"no command.\"\n\n```go\nfunc (m model) Init() tea.Cmd {\n    // Just return `nil`, which means \"no I/O right now, please.\"\n    return nil\n}\n```\n\n### The Update Method\n\nNext up is the update method. The update function is called when ”things\nhappen.” Its job is to look at what has happened and return an updated model in\nresponse. It can also return a `Cmd` to make more things happen, but for now\ndon't worry about that part.\n\nIn our case, when a user presses the down arrow, `Update`’s job is to notice\nthat the down arrow was pressed and move the cursor accordingly (or not).\n\nThe “something happened” comes in the form of a `Msg`, which can be any type.\nMessages are the result of some I/O that took place, such as a keypress, timer\ntick, or a response from a server.\n\nWe usually figure out which type of `Msg` we received with a type switch, but\nyou could also use a type assertion.\n\nFor now, we'll just deal with `tea.KeyMsg` messages, which are automatically\nsent to the update function when keys are pressed.\n\n```go\nfunc (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n    switch msg := msg.(type) {\n\n    // Is it a key press?\n    case tea.KeyMsg:\n\n        // Cool, what was the actual key pressed?\n        switch msg.String() {\n\n        // These keys should exit the program.\n        case \"ctrl+c\", \"q\":\n            return m, tea.Quit\n\n        // The \"up\" and \"k\" keys move the cursor up\n        case \"up\", \"k\":\n            if m.cursor > 0 {\n                m.cursor--\n            }\n\n        // The \"down\" and \"j\" keys move the cursor down\n        case \"down\", \"j\":\n            if m.cursor < len(m.choices)-1 {\n                m.cursor++\n            }\n\n        // The \"enter\" key and the spacebar (a literal space) toggle\n        // the selected state for the item that the cursor is pointing at.\n        case \"enter\", \" \":\n            _, ok := m.selected[m.cursor]\n            if ok {\n                delete(m.selected, m.cursor)\n            } else {\n                m.selected[m.cursor] = struct{}{}\n            }\n        }\n    }\n\n    // Return the updated model to the Bubble Tea runtime for processing.\n    // Note that we're not returning a command.\n    return m, nil\n}\n```\n\nYou may have noticed that <kbd>ctrl+c</kbd> and <kbd>q</kbd> above return\na `tea.Quit` command with the model. That’s a special command which instructs\nthe Bubble Tea runtime to quit, exiting the program.\n\n### The View Method\n\nAt last, it’s time to render our UI. Of all the methods, the view is the\nsimplest. We look at the model in its current state and use it to return\na `string`. That string is our UI!\n\nBecause the view describes the entire UI of your application, you don’t have to\nworry about redrawing logic and stuff like that. Bubble Tea takes care of it\nfor you.\n\n```go\nfunc (m model) View() string {\n    // The header\n    s := \"What should we buy at the market?\\n\\n\"\n\n    // Iterate over our choices\n    for i, choice := range m.choices {\n\n        // Is the cursor pointing at this choice?\n        cursor := \" \" // no cursor\n        if m.cursor == i {\n            cursor = \">\" // cursor!\n        }\n\n        // Is this choice selected?\n        checked := \" \" // not selected\n        if _, ok := m.selected[i]; ok {\n            checked = \"x\" // selected!\n        }\n\n        // Render the row\n        s += fmt.Sprintf(\"%s [%s] %s\\n\", cursor, checked, choice)\n    }\n\n    // The footer\n    s += \"\\nPress q to quit.\\n\"\n\n    // Send the UI for rendering\n    return s\n}\n```\n\n### All Together Now\n\nThe last step is to simply run our program. We pass our initial model to\n`tea.NewProgram` and let it rip:\n\n```go\nfunc main() {\n    p := tea.NewProgram(initialModel())\n    if _, err := p.Run(); err != nil {\n        fmt.Printf(\"Alas, there's been an error: %v\", err)\n        os.Exit(1)\n    }\n}\n```\n\n## What’s Next?\n\nThis tutorial covers the basics of building an interactive terminal UI, but\nin the real world you'll also need to perform I/O. To learn about that have a\nlook at the [Command Tutorial][cmd]. It's pretty simple.\n\nThere are also several [Bubble Tea examples][examples] available and, of course,\nthere are [Go Docs][docs].\n\n[cmd]: https://github.com/charmbracelet/bubbletea/tree/master/tutorials/commands/\n[examples]: https://github.com/charmbracelet/bubbletea/tree/master/examples\n[docs]: https://pkg.go.dev/github.com/charmbracelet/bubbletea?tab=doc\n\n## Debugging\n\n### Debugging with Delve\n\nSince Bubble Tea apps assume control of stdin and stdout, you’ll need to run\ndelve in headless mode and then connect to it:\n\n```bash\n# Start the debugger\n$ dlv debug --headless --api-version=2 --listen=127.0.0.1:43000 .\nAPI server listening at: 127.0.0.1:43000\n\n# Connect to it from another terminal\n$ dlv connect 127.0.0.1:43000\n```\n\nIf you do not explicitly supply the `--listen` flag, the port used will vary\nper run, so passing this in makes the debugger easier to use from a script\nor your IDE of choice.\n\nAdditionally, we pass in `--api-version=2` because delve defaults to version 1\nfor backwards compatibility reasons. However, delve recommends using version 2\nfor all new development and some clients may no longer work with version 1.\nFor more information, see the [Delve documentation](https://github.com/go-delve/delve/tree/master/Documentation/api).\n\n### Logging Stuff\n\nYou can’t really log to stdout with Bubble Tea because your TUI is busy\noccupying that! You can, however, log to a file by including something like\nthe following prior to starting your Bubble Tea program:\n\n```go\nif len(os.Getenv(\"DEBUG\")) > 0 {\n\tf, err := tea.LogToFile(\"debug.log\", \"debug\")\n\tif err != nil {\n\t\tfmt.Println(\"fatal:\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer f.Close()\n}\n```\n\nTo see what’s being logged in real time, run `tail -f debug.log` while you run\nyour program in another window.\n\n## Libraries we use with Bubble Tea\n\n- [Bubbles][bubbles]: Common Bubble Tea components such as text inputs, viewports, spinners and so on\n- [Lip Gloss][lipgloss]: Style, format and layout tools for terminal applications\n- [Harmonica][harmonica]: A spring animation library for smooth, natural motion\n- [BubbleZone][bubblezone]: Easy mouse event tracking for Bubble Tea components\n- [ntcharts][ntcharts]: A terminal charting library built for Bubble Tea and [Lip Gloss][lipgloss]\n\n[bubbles]: https://github.com/charmbracelet/bubbles\n[lipgloss]: https://github.com/charmbracelet/lipgloss\n[harmonica]: https://github.com/charmbracelet/harmonica\n[bubblezone]: https://github.com/lrstanley/bubblezone\n[ntcharts]: https://github.com/NimbleMarkets/ntcharts\n\n## Bubble Tea in the Wild\n\nThere are over [10,000 applications](https://github.com/charmbracelet/bubbletea/network/dependents) built with Bubble Tea! Here are a handful of ’em.\n\n### Staff favourites\n\n- [chezmoi](https://github.com/twpayne/chezmoi): securely manage your dotfiles across multiple machines\n- [circumflex](https://github.com/bensadeh/circumflex): read Hacker News in the terminal\n- [gh-dash](https://www.github.com/dlvhdr/gh-dash): a GitHub CLI extension for PRs and issues\n- [Tetrigo](https://github.com/Broderick-Westrope/tetrigo): Tetris in the terminal\n- [Signls](https://github.com/emprcl/signls): a generative midi sequencer designed for composition and live performance\n- [Superfile](https://github.com/yorukot/superfile): a super file manager\n\n### In Industry\n\n- Microsoft Azure – [Aztify](https://github.com/Azure/aztfy): bring Microsoft Azure resources under Terraform\n- Daytona – [Daytona](https://github.com/daytonaio/daytona): open source dev environment manager\n- Cockroach Labs – [CockroachDB](https://github.com/cockroachdb/cockroach): a cloud-native, high-availability distributed SQL database\n- Truffle Security Co. – [Trufflehog](https://github.com/trufflesecurity/trufflehog): find leaked credentials\n- NVIDIA – [container-canary](https://github.com/NVIDIA/container-canary): a container validator\n- AWS – [eks-node-viewer](https://github.com/awslabs/eks-node-viewer): a tool for visualizing dynamic node usage within an EKS cluster\n- MinIO – [mc](https://github.com/minio/mc): the official [MinIO](https://min.io) client\n- Ubuntu – [Authd](https://github.com/ubuntu/authd): an authentication daemon for cloud-based identity providers\n\n### Charm stuff\n\n- [Glow](https://github.com/charmbracelet/glow): a markdown reader, browser, and online markdown stash\n- [Huh?](https://github.com/charmbracelet/huh): an interactive prompt and form toolkit\n- [Mods](https://github.com/charmbracelet/mods): AI on the CLI, built for pipelines\n- [Wishlist](https://github.com/charmbracelet/wishlist): an SSH directory (and bastion!)\n\n### There’s so much more where that came from\n\nFor more applications built with Bubble Tea see [Charm & Friends][community].\nIs there something cool you made with Bubble Tea you want to share? [PRs][community] are\nwelcome!\n\n## Contributing\n\nSee [contributing][contribute].\n\n[contribute]: https://github.com/charmbracelet/bubbletea/contribute\n\n## Feedback\n\nWe’d love to hear your thoughts on this project. Feel free to drop us a note!\n\n- [Twitter](https://twitter.com/charmcli)\n- [The Fediverse](https://mastodon.social/@charmcli)\n- [Discord](https://charm.sh/chat)\n\n## Acknowledgments\n\nBubble Tea is based on the paradigms of [The Elm Architecture][elm] by Evan\nCzaplicki et alia and the excellent [go-tea][gotea] by TJ Holowaychuk. It’s\ninspired by the many great [_Zeichenorientierte Benutzerschnittstellen_][zb]\nof days past.\n\n[elm]: https://guide.elm-lang.org/architecture/\n[gotea]: https://github.com/tj/go-tea\n[zb]: https://de.wikipedia.org/wiki/Zeichenorientierte_Benutzerschnittstelle\n[community]: https://github.com/charm-and-friends/charm-in-the-wild\n\n## License\n\n[MIT](https://github.com/charmbracelet/bubbletea/raw/master/LICENSE)\n\n---\n\nPart of [Charm](https://charm.sh).\n\n<a href=\"https://charm.sh/\"><img alt=\"The Charm logo\" src=\"https://stuff.charm.sh/charm-badge.jpg\" width=\"400\"></a>\n\nCharm热爱开源 • Charm loves open source • نحنُ نحب المصادر المفتوحة\n"
        },
        {
          "name": "commands.go",
          "type": "blob",
          "size": 5.44,
          "content": "package tea\n\nimport (\n\t\"time\"\n)\n\n// Batch performs a bunch of commands concurrently with no ordering guarantees\n// about the results. Use a Batch to return several commands.\n//\n// Example:\n//\n//\t    func (m model) Init() Cmd {\n//\t\t       return tea.Batch(someCommand, someOtherCommand)\n//\t    }\nfunc Batch(cmds ...Cmd) Cmd {\n\tvar validCmds []Cmd //nolint:prealloc\n\tfor _, c := range cmds {\n\t\tif c == nil {\n\t\t\tcontinue\n\t\t}\n\t\tvalidCmds = append(validCmds, c)\n\t}\n\tswitch len(validCmds) {\n\tcase 0:\n\t\treturn nil\n\tcase 1:\n\t\treturn validCmds[0]\n\tdefault:\n\t\treturn func() Msg {\n\t\t\treturn BatchMsg(validCmds)\n\t\t}\n\t}\n}\n\n// BatchMsg is a message used to perform a bunch of commands concurrently with\n// no ordering guarantees. You can send a BatchMsg with Batch.\ntype BatchMsg []Cmd\n\n// Sequence runs the given commands one at a time, in order. Contrast this with\n// Batch, which runs commands concurrently.\nfunc Sequence(cmds ...Cmd) Cmd {\n\treturn func() Msg {\n\t\treturn sequenceMsg(cmds)\n\t}\n}\n\n// sequenceMsg is used internally to run the given commands in order.\ntype sequenceMsg []Cmd\n\n// Every is a command that ticks in sync with the system clock. So, if you\n// wanted to tick with the system clock every second, minute or hour you\n// could use this. It's also handy for having different things tick in sync.\n//\n// Because we're ticking with the system clock the tick will likely not run for\n// the entire specified duration. For example, if we're ticking for one minute\n// and the clock is at 12:34:20 then the next tick will happen at 12:35:00, 40\n// seconds later.\n//\n// To produce the command, pass a duration and a function which returns\n// a message containing the time at which the tick occurred.\n//\n//\ttype TickMsg time.Time\n//\n//\tcmd := Every(time.Second, func(t time.Time) Msg {\n//\t   return TickMsg(t)\n//\t})\n//\n// Beginners' note: Every sends a single message and won't automatically\n// dispatch messages at an interval. To do that, you'll want to return another\n// Every command after receiving your tick message. For example:\n//\n//\ttype TickMsg time.Time\n//\n//\t// Send a message every second.\n//\tfunc tickEvery() Cmd {\n//\t    return Every(time.Second, func(t time.Time) Msg {\n//\t        return TickMsg(t)\n//\t    })\n//\t}\n//\n//\tfunc (m model) Init() Cmd {\n//\t    // Start ticking.\n//\t    return tickEvery()\n//\t}\n//\n//\tfunc (m model) Update(msg Msg) (Model, Cmd) {\n//\t    switch msg.(type) {\n//\t    case TickMsg:\n//\t        // Return your Every command again to loop.\n//\t        return m, tickEvery()\n//\t    }\n//\t    return m, nil\n//\t}\n//\n// Every is analogous to Tick in the Elm Architecture.\nfunc Every(duration time.Duration, fn func(time.Time) Msg) Cmd {\n\tn := time.Now()\n\td := n.Truncate(duration).Add(duration).Sub(n)\n\tt := time.NewTimer(d)\n\treturn func() Msg {\n\t\tts := <-t.C\n\t\tt.Stop()\n\t\tfor len(t.C) > 0 {\n\t\t\t<-t.C\n\t\t}\n\t\treturn fn(ts)\n\t}\n}\n\n// Tick produces a command at an interval independent of the system clock at\n// the given duration. That is, the timer begins precisely when invoked,\n// and runs for its entire duration.\n//\n// To produce the command, pass a duration and a function which returns\n// a message containing the time at which the tick occurred.\n//\n//\ttype TickMsg time.Time\n//\n//\tcmd := Tick(time.Second, func(t time.Time) Msg {\n//\t   return TickMsg(t)\n//\t})\n//\n// Beginners' note: Tick sends a single message and won't automatically\n// dispatch messages at an interval. To do that, you'll want to return another\n// Tick command after receiving your tick message. For example:\n//\n//\ttype TickMsg time.Time\n//\n//\tfunc doTick() Cmd {\n//\t    return Tick(time.Second, func(t time.Time) Msg {\n//\t        return TickMsg(t)\n//\t    })\n//\t}\n//\n//\tfunc (m model) Init() Cmd {\n//\t    // Start ticking.\n//\t    return doTick()\n//\t}\n//\n//\tfunc (m model) Update(msg Msg) (Model, Cmd) {\n//\t    switch msg.(type) {\n//\t    case TickMsg:\n//\t        // Return your Tick command again to loop.\n//\t        return m, doTick()\n//\t    }\n//\t    return m, nil\n//\t}\nfunc Tick(d time.Duration, fn func(time.Time) Msg) Cmd {\n\tt := time.NewTimer(d)\n\treturn func() Msg {\n\t\tts := <-t.C\n\t\tt.Stop()\n\t\tfor len(t.C) > 0 {\n\t\t\t<-t.C\n\t\t}\n\t\treturn fn(ts)\n\t}\n}\n\n// Sequentially produces a command that sequentially executes the given\n// commands.\n// The Msg returned is the first non-nil message returned by a Cmd.\n//\n//\tfunc saveStateCmd() Msg {\n//\t   if err := save(); err != nil {\n//\t       return errMsg{err}\n//\t   }\n//\t   return nil\n//\t}\n//\n//\tcmd := Sequentially(saveStateCmd, Quit)\n//\n// Deprecated: use Sequence instead.\nfunc Sequentially(cmds ...Cmd) Cmd {\n\treturn func() Msg {\n\t\tfor _, cmd := range cmds {\n\t\t\tif cmd == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif msg := cmd(); msg != nil {\n\t\t\t\treturn msg\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// setWindowTitleMsg is an internal message used to set the window title.\ntype setWindowTitleMsg string\n\n// SetWindowTitle produces a command that sets the terminal title.\n//\n// For example:\n//\n//\tfunc (m model) Init() Cmd {\n//\t    // Set title.\n//\t    return tea.SetWindowTitle(\"My App\")\n//\t}\nfunc SetWindowTitle(title string) Cmd {\n\treturn func() Msg {\n\t\treturn setWindowTitleMsg(title)\n\t}\n}\n\ntype windowSizeMsg struct{}\n\n// WindowSize is a command that queries the terminal for its current size. It\n// delivers the results to Update via a [WindowSizeMsg]. Keep in mind that\n// WindowSizeMsgs will automatically be delivered to Update when the [Program]\n// starts and when the window dimensions change so in many cases you will not\n// need to explicitly invoke this command.\nfunc WindowSize() Cmd {\n\treturn func() Msg {\n\t\treturn windowSizeMsg{}\n\t}\n}\n"
        },
        {
          "name": "commands_test.go",
          "type": "blob",
          "size": 2.02,
          "content": "package tea\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestEvery(t *testing.T) {\n\texpected := \"every ms\"\n\tmsg := Every(time.Millisecond, func(t time.Time) Msg {\n\t\treturn expected\n\t})()\n\tif expected != msg {\n\t\tt.Fatalf(\"expected a msg %v but got %v\", expected, msg)\n\t}\n}\n\nfunc TestTick(t *testing.T) {\n\texpected := \"tick\"\n\tmsg := Tick(time.Millisecond, func(t time.Time) Msg {\n\t\treturn expected\n\t})()\n\tif expected != msg {\n\t\tt.Fatalf(\"expected a msg %v but got %v\", expected, msg)\n\t}\n}\n\nfunc TestSequentially(t *testing.T) {\n\texpectedErrMsg := fmt.Errorf(\"some err\")\n\texpectedStrMsg := \"some msg\"\n\n\tnilReturnCmd := func() Msg {\n\t\treturn nil\n\t}\n\n\ttests := []struct {\n\t\tname     string\n\t\tcmds     []Cmd\n\t\texpected Msg\n\t}{\n\t\t{\n\t\t\tname:     \"all nil\",\n\t\t\tcmds:     []Cmd{nilReturnCmd, nilReturnCmd},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"null cmds\",\n\t\t\tcmds:     []Cmd{nil, nil},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"one error\",\n\t\t\tcmds: []Cmd{\n\t\t\t\tnilReturnCmd,\n\t\t\t\tfunc() Msg {\n\t\t\t\t\treturn expectedErrMsg\n\t\t\t\t},\n\t\t\t\tnilReturnCmd,\n\t\t\t},\n\t\t\texpected: expectedErrMsg,\n\t\t},\n\t\t{\n\t\t\tname: \"some msg\",\n\t\t\tcmds: []Cmd{\n\t\t\t\tnilReturnCmd,\n\t\t\t\tfunc() Msg {\n\t\t\t\t\treturn expectedStrMsg\n\t\t\t\t},\n\t\t\t\tnilReturnCmd,\n\t\t\t},\n\t\t\texpected: expectedStrMsg,\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tif msg := Sequentially(test.cmds...)(); msg != test.expected {\n\t\t\t\tt.Fatalf(\"expected a msg %v but got %v\", test.expected, msg)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestBatch(t *testing.T) {\n\tt.Run(\"nil cmd\", func(t *testing.T) {\n\t\tif b := Batch(nil); b != nil {\n\t\t\tt.Fatalf(\"expected nil, got %+v\", b)\n\t\t}\n\t})\n\tt.Run(\"empty cmd\", func(t *testing.T) {\n\t\tif b := Batch(); b != nil {\n\t\t\tt.Fatalf(\"expected nil, got %+v\", b)\n\t\t}\n\t})\n\tt.Run(\"single cmd\", func(t *testing.T) {\n\t\tb := Batch(Quit)()\n\t\tif _, ok := b.(QuitMsg); !ok {\n\t\t\tt.Fatalf(\"expected a QuitMsg, got %T\", b)\n\t\t}\n\t})\n\tt.Run(\"mixed nil cmds\", func(t *testing.T) {\n\t\tb := Batch(nil, Quit, nil, Quit, nil, nil)()\n\t\tif l := len(b.(BatchMsg)); l != 2 {\n\t\t\tt.Fatalf(\"expected a []Cmd with len 2, got %d\", l)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "exec.go",
          "type": "blob",
          "size": 3.46,
          "content": "package tea\n\nimport (\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n)\n\n// execMsg is used internally to run an ExecCommand sent with Exec.\ntype execMsg struct {\n\tcmd ExecCommand\n\tfn  ExecCallback\n}\n\n// Exec is used to perform arbitrary I/O in a blocking fashion, effectively\n// pausing the Program while execution is running and resuming it when\n// execution has completed.\n//\n// Most of the time you'll want to use ExecProcess, which runs an exec.Cmd.\n//\n// For non-interactive i/o you should use a Cmd (that is, a tea.Cmd).\nfunc Exec(c ExecCommand, fn ExecCallback) Cmd {\n\treturn func() Msg {\n\t\treturn execMsg{cmd: c, fn: fn}\n\t}\n}\n\n// ExecProcess runs the given *exec.Cmd in a blocking fashion, effectively\n// pausing the Program while the command is running. After the *exec.Cmd exists\n// the Program resumes. It's useful for spawning other interactive applications\n// such as editors and shells from within a Program.\n//\n// To produce the command, pass an *exec.Cmd and a function which returns\n// a message containing the error which may have occurred when running the\n// ExecCommand.\n//\n//\ttype VimFinishedMsg struct { err error }\n//\n//\tc := exec.Command(\"vim\", \"file.txt\")\n//\n//\tcmd := ExecProcess(c, func(err error) Msg {\n//\t    return VimFinishedMsg{err: err}\n//\t})\n//\n// Or, if you don't care about errors, you could simply:\n//\n//\tcmd := ExecProcess(exec.Command(\"vim\", \"file.txt\"), nil)\n//\n// For non-interactive i/o you should use a Cmd (that is, a tea.Cmd).\nfunc ExecProcess(c *exec.Cmd, fn ExecCallback) Cmd {\n\treturn Exec(wrapExecCommand(c), fn)\n}\n\n// ExecCallback is used when executing an *exec.Command to return a message\n// with an error, which may or may not be nil.\ntype ExecCallback func(error) Msg\n\n// ExecCommand can be implemented to execute things in a blocking fashion in\n// the current terminal.\ntype ExecCommand interface {\n\tRun() error\n\tSetStdin(io.Reader)\n\tSetStdout(io.Writer)\n\tSetStderr(io.Writer)\n}\n\n// wrapExecCommand wraps an exec.Cmd so that it satisfies the ExecCommand\n// interface so it can be used with Exec.\nfunc wrapExecCommand(c *exec.Cmd) ExecCommand {\n\treturn &osExecCommand{Cmd: c}\n}\n\n// osExecCommand is a layer over an exec.Cmd that satisfies the ExecCommand\n// interface.\ntype osExecCommand struct{ *exec.Cmd }\n\n// SetStdin sets stdin on underlying exec.Cmd to the given io.Reader.\nfunc (c *osExecCommand) SetStdin(r io.Reader) {\n\t// If unset, have the command use the same input as the terminal.\n\tif c.Stdin == nil {\n\t\tc.Stdin = r\n\t}\n}\n\n// SetStdout sets stdout on underlying exec.Cmd to the given io.Writer.\nfunc (c *osExecCommand) SetStdout(w io.Writer) {\n\t// If unset, have the command use the same output as the terminal.\n\tif c.Stdout == nil {\n\t\tc.Stdout = w\n\t}\n}\n\n// SetStderr sets stderr on the underlying exec.Cmd to the given io.Writer.\nfunc (c *osExecCommand) SetStderr(w io.Writer) {\n\t// If unset, use stderr for the command's stderr\n\tif c.Stderr == nil {\n\t\tc.Stderr = w\n\t}\n}\n\n// exec runs an ExecCommand and delivers the results to the program as a Msg.\nfunc (p *Program) exec(c ExecCommand, fn ExecCallback) {\n\tif err := p.ReleaseTerminal(); err != nil {\n\t\t// If we can't release input, abort.\n\t\tif fn != nil {\n\t\t\tgo p.Send(fn(err))\n\t\t}\n\t\treturn\n\t}\n\n\tc.SetStdin(p.input)\n\tc.SetStdout(p.output)\n\tc.SetStderr(os.Stderr)\n\n\t// Execute system command.\n\tif err := c.Run(); err != nil {\n\t\t_ = p.RestoreTerminal() // also try to restore the terminal.\n\t\tif fn != nil {\n\t\t\tgo p.Send(fn(err))\n\t\t}\n\t\treturn\n\t}\n\n\t// Have the program re-capture input.\n\terr := p.RestoreTerminal()\n\tif fn != nil {\n\t\tgo p.Send(fn(err))\n\t}\n}\n"
        },
        {
          "name": "exec_test.go",
          "type": "blob",
          "size": 1.45,
          "content": "package tea\n\nimport (\n\t\"bytes\"\n\t\"os/exec\"\n\t\"runtime\"\n\t\"testing\"\n)\n\ntype execFinishedMsg struct{ err error }\n\ntype testExecModel struct {\n\tcmd string\n\terr error\n}\n\nfunc (m testExecModel) Init() Cmd {\n\tc := exec.Command(m.cmd) //nolint:gosec\n\treturn ExecProcess(c, func(err error) Msg {\n\t\treturn execFinishedMsg{err}\n\t})\n}\n\nfunc (m *testExecModel) Update(msg Msg) (Model, Cmd) {\n\tswitch msg := msg.(type) {\n\tcase execFinishedMsg:\n\t\tif msg.err != nil {\n\t\t\tm.err = msg.err\n\t\t}\n\t\treturn m, Quit\n\t}\n\n\treturn m, nil\n}\n\nfunc (m *testExecModel) View() string {\n\treturn \"\\n\"\n}\n\nfunc TestTeaExec(t *testing.T) {\n\ttype test struct {\n\t\tname      string\n\t\tcmd       string\n\t\texpectErr bool\n\t}\n\ttests := []test{\n\t\t{\n\t\t\tname:      \"invalid command\",\n\t\t\tcmd:       \"invalid\",\n\t\t\texpectErr: true,\n\t\t},\n\t}\n\n\tif runtime.GOOS != \"windows\" {\n\t\ttests = append(tests, []test{\n\t\t\t{\n\t\t\t\tname:      \"true\",\n\t\t\t\tcmd:       \"true\",\n\t\t\t\texpectErr: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"false\",\n\t\t\t\tcmd:       \"false\",\n\t\t\t\texpectErr: true,\n\t\t\t},\n\t\t}...)\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar buf bytes.Buffer\n\t\t\tvar in bytes.Buffer\n\n\t\t\tm := &testExecModel{cmd: test.cmd}\n\t\t\tp := NewProgram(m, WithInput(&in), WithOutput(&buf))\n\t\t\tif _, err := p.Run(); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\n\t\t\tif m.err != nil && !test.expectErr {\n\t\t\t\tt.Errorf(\"expected no error, got %v\", m.err)\n\t\t\t}\n\t\t\tif m.err == nil && test.expectErr {\n\t\t\t\tt.Error(\"expected error, got nil\")\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "focus.go",
          "type": "blob",
          "size": 0.24,
          "content": "package tea\n\n// FocusMsg represents a terminal focus message.\n// This occurs when the terminal gains focus.\ntype FocusMsg struct{}\n\n// BlurMsg represents a terminal blur message.\n// This occurs when the terminal loses focus.\ntype BlurMsg struct{}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.78,
          "content": "module github.com/charmbracelet/bubbletea\n\ngo 1.18\n\nrequire (\n\tgithub.com/charmbracelet/lipgloss v1.0.0\n\tgithub.com/charmbracelet/x/ansi v0.6.0\n\tgithub.com/charmbracelet/x/term v0.2.1\n\tgithub.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f\n\tgithub.com/mattn/go-localereader v0.0.1\n\tgithub.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6\n\tgithub.com/muesli/cancelreader v0.2.2\n\tgolang.org/x/sync v0.10.0\n\tgolang.org/x/sys v0.29.0\n)\n\nrequire (\n\tgithub.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect\n\tgithub.com/lucasb-eyer/go-colorful v1.2.0 // indirect\n\tgithub.com/mattn/go-isatty v0.0.20 // indirect\n\tgithub.com/mattn/go-runewidth v0.0.15 // indirect\n\tgithub.com/muesli/termenv v0.15.2 // indirect\n\tgithub.com/rivo/uniseg v0.4.7 // indirect\n\tgolang.org/x/text v0.3.8 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 3.08,
          "content": "github.com/aymanbagabas/go-osc52/v2 v2.0.1 h1:HwpRHbFMcZLEVr42D4p7XBqjyuxQH5SMiErDT4WkJ2k=\ngithub.com/aymanbagabas/go-osc52/v2 v2.0.1/go.mod h1:uYgXzlJ7ZpABp8OJ+exZzJJhRNQ2ASbcXHWsFqH8hp8=\ngithub.com/charmbracelet/lipgloss v1.0.0 h1:O7VkGDvqEdGi93X+DeqsQ7PKHDgtQfF8j8/O2qFMQNg=\ngithub.com/charmbracelet/lipgloss v1.0.0/go.mod h1:U5fy9Z+C38obMs+T+tJqst9VGzlOYGj4ri9reL3qUlo=\ngithub.com/charmbracelet/x/ansi v0.6.0 h1:qOznutrb93gx9oMiGf7caF7bqqubh6YIM0SWKyA08pA=\ngithub.com/charmbracelet/x/ansi v0.6.0/go.mod h1:KBUFw1la39nl0dLl10l5ORDAqGXaeurTQmwyyVKse/Q=\ngithub.com/charmbracelet/x/term v0.2.1 h1:AQeHeLZ1OqSXhrAWpYUtZyX1T3zVxfpZuEQMIQaGIAQ=\ngithub.com/charmbracelet/x/term v0.2.1/go.mod h1:oQ4enTYFV7QN4m0i9mzHrViD7TQKvNEEkHUMCmsxdUg=\ngithub.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f h1:Y/CXytFA4m6baUTXGLOoWe4PQhGxaX0KpnayAqC48p4=\ngithub.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f/go.mod h1:vw97MGsxSvLiUE2X8qFplwetxpGLQrlU1Q9AUEIzCaM=\ngithub.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=\ngithub.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/mattn/go-localereader v0.0.1 h1:ygSAOl7ZXTx4RdPYinUpg6W99U8jWvWi9Ye2JC/oIi4=\ngithub.com/mattn/go-localereader v0.0.1/go.mod h1:8fBrzywKY7BI3czFoHkuzRoWE9C+EiG4R1k4Cjx5p88=\ngithub.com/mattn/go-runewidth v0.0.15 h1:UNAjwbU9l54TA3KzvqLGxwWjHmMgBUVhBiTjelZgg3U=\ngithub.com/mattn/go-runewidth v0.0.15/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 h1:ZK8zHtRHOkbHy6Mmr5D264iyp3TiX5OmNcI5cIARiQI=\ngithub.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6/go.mod h1:CJlz5H+gyd6CUWT45Oy4q24RdLyn7Md9Vj2/ldJBSIo=\ngithub.com/muesli/cancelreader v0.2.2 h1:3I4Kt4BQjOR54NavqnDogx/MIoWBFa0StPA8ELUXHmA=\ngithub.com/muesli/cancelreader v0.2.2/go.mod h1:3XuTXfFS2VjM+HTLZY9Ak0l6eUKfijIfMUZ4EgX0QYo=\ngithub.com/muesli/termenv v0.15.2 h1:GohcuySI0QmI3wN8Ok9PtKGkgkFIk7y6Vpb5PvrY+Wo=\ngithub.com/muesli/termenv v0.15.2/go.mod h1:Epx+iuz8sNs7mNKhxzH4fWXGNpZwUaJKRS1noLXviQ8=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=\ngithub.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngolang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=\ngolang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20210809222454-d867a43fc93e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.29.0 h1:TPYlXGxvx1MGTn2GiZDhnjPA9wZzZeGKHHmKhHYvgaU=\ngolang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.3.8 h1:nAL+RVCQ9uMn3vJZbV+MRnydTJFPf8qqY42YiA6MrqY=\ngolang.org/x/text v0.3.8/go.mod h1:E6s5w1FMmriuDzIBO73fBruAKo1PCIq6d2Q6DHfQ8WQ=\n"
        },
        {
          "name": "inputreader_other.go",
          "type": "blob",
          "size": 0.21,
          "content": "//go:build !windows\n// +build !windows\n\npackage tea\n\nimport (\n\t\"io\"\n\n\t\"github.com/muesli/cancelreader\"\n)\n\nfunc newInputReader(r io.Reader) (cancelreader.CancelReader, error) {\n\treturn cancelreader.NewReader(r)\n}\n"
        },
        {
          "name": "inputreader_windows.go",
          "type": "blob",
          "size": 2.17,
          "content": "//go:build windows\n// +build windows\n\npackage tea\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"sync\"\n\n\t\"github.com/charmbracelet/x/term\"\n\t\"github.com/erikgeiser/coninput\"\n\t\"github.com/muesli/cancelreader\"\n\t\"golang.org/x/sys/windows\"\n)\n\ntype conInputReader struct {\n\tcancelMixin\n\n\tconin windows.Handle\n\n\toriginalMode uint32\n}\n\nvar _ cancelreader.CancelReader = &conInputReader{}\n\nfunc newInputReader(r io.Reader) (cancelreader.CancelReader, error) {\n\tfallback := func(io.Reader) (cancelreader.CancelReader, error) {\n\t\treturn cancelreader.NewReader(r)\n\t}\n\tif f, ok := r.(term.File); !ok || f.Fd() != os.Stdin.Fd() {\n\t\treturn fallback(r)\n\t}\n\n\tconin, err := coninput.NewStdinHandle()\n\tif err != nil {\n\t\treturn fallback(r)\n\t}\n\n\toriginalMode, err := prepareConsole(conin,\n\t\twindows.ENABLE_MOUSE_INPUT,\n\t\twindows.ENABLE_WINDOW_INPUT,\n\t\twindows.ENABLE_EXTENDED_FLAGS,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to prepare console input: %w\", err)\n\t}\n\n\treturn &conInputReader{\n\t\tconin:        conin,\n\t\toriginalMode: originalMode,\n\t}, nil\n}\n\n// Cancel implements cancelreader.CancelReader.\nfunc (r *conInputReader) Cancel() bool {\n\tr.setCanceled()\n\n\treturn windows.CancelIo(r.conin) == nil\n}\n\n// Close implements cancelreader.CancelReader.\nfunc (r *conInputReader) Close() error {\n\tif r.originalMode != 0 {\n\t\terr := windows.SetConsoleMode(r.conin, r.originalMode)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"reset console mode: %w\", err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Read implements cancelreader.CancelReader.\nfunc (*conInputReader) Read(_ []byte) (n int, err error) {\n\treturn 0, nil\n}\n\nfunc prepareConsole(input windows.Handle, modes ...uint32) (originalMode uint32, err error) {\n\terr = windows.GetConsoleMode(input, &originalMode)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"get console mode: %w\", err)\n\t}\n\n\tnewMode := coninput.AddInputModes(0, modes...)\n\n\terr = windows.SetConsoleMode(input, newMode)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"set console mode: %w\", err)\n\t}\n\n\treturn originalMode, nil\n}\n\n// cancelMixin represents a goroutine-safe cancelation status.\ntype cancelMixin struct {\n\tunsafeCanceled bool\n\tlock           sync.Mutex\n}\n\nfunc (c *cancelMixin) setCanceled() {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tc.unsafeCanceled = true\n}\n"
        },
        {
          "name": "key.go",
          "type": "blob",
          "size": 21.3,
          "content": "package tea\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"regexp\"\n\t\"strings\"\n\t\"unicode/utf8\"\n)\n\n// KeyMsg contains information about a keypress. KeyMsgs are always sent to\n// the program's update function. There are a couple general patterns you could\n// use to check for keypresses:\n//\n//\t// Switch on the string representation of the key (shorter)\n//\tswitch msg := msg.(type) {\n//\tcase KeyMsg:\n//\t    switch msg.String() {\n//\t    case \"enter\":\n//\t        fmt.Println(\"you pressed enter!\")\n//\t    case \"a\":\n//\t        fmt.Println(\"you pressed a!\")\n//\t    }\n//\t}\n//\n//\t// Switch on the key type (more foolproof)\n//\tswitch msg := msg.(type) {\n//\tcase KeyMsg:\n//\t    switch msg.Type {\n//\t    case KeyEnter:\n//\t        fmt.Println(\"you pressed enter!\")\n//\t    case KeyRunes:\n//\t        switch string(msg.Runes) {\n//\t        case \"a\":\n//\t            fmt.Println(\"you pressed a!\")\n//\t        }\n//\t    }\n//\t}\n//\n// Note that Key.Runes will always contain at least one character, so you can\n// always safely call Key.Runes[0]. In most cases Key.Runes will only contain\n// one character, though certain input method editors (most notably Chinese\n// IMEs) can input multiple runes at once.\ntype KeyMsg Key\n\n// String returns a string representation for a key message. It's safe (and\n// encouraged) for use in key comparison.\nfunc (k KeyMsg) String() (str string) {\n\treturn Key(k).String()\n}\n\n// Key contains information about a keypress.\ntype Key struct {\n\tType  KeyType\n\tRunes []rune\n\tAlt   bool\n\tPaste bool\n}\n\n// String returns a friendly string representation for a key. It's safe (and\n// encouraged) for use in key comparison.\n//\n//\tk := Key{Type: KeyEnter}\n//\tfmt.Println(k)\n//\t// Output: enter\nfunc (k Key) String() (str string) {\n\tvar buf strings.Builder\n\tif k.Alt {\n\t\tbuf.WriteString(\"alt+\")\n\t}\n\tif k.Type == KeyRunes {\n\t\tif k.Paste {\n\t\t\t// Note: bubbles/keys bindings currently do string compares to\n\t\t\t// recognize shortcuts. Since pasted text should never activate\n\t\t\t// shortcuts, we need to ensure that the binding code doesn't\n\t\t\t// match Key events that result from pastes. We achieve this\n\t\t\t// here by enclosing pastes in '[...]' so that the string\n\t\t\t// comparison in Matches() fails in that case.\n\t\t\tbuf.WriteByte('[')\n\t\t}\n\t\tbuf.WriteString(string(k.Runes))\n\t\tif k.Paste {\n\t\t\tbuf.WriteByte(']')\n\t\t}\n\t\treturn buf.String()\n\t} else if s, ok := keyNames[k.Type]; ok {\n\t\tbuf.WriteString(s)\n\t\treturn buf.String()\n\t}\n\treturn \"\"\n}\n\n// KeyType indicates the key pressed, such as KeyEnter or KeyBreak or KeyCtrlC.\n// All other keys will be type KeyRunes. To get the rune value, check the Rune\n// method on a Key struct, or use the Key.String() method:\n//\n//\tk := Key{Type: KeyRunes, Runes: []rune{'a'}, Alt: true}\n//\tif k.Type == KeyRunes {\n//\n//\t    fmt.Println(k.Runes)\n//\t    // Output: a\n//\n//\t    fmt.Println(k.String())\n//\t    // Output: alt+a\n//\n//\t}\ntype KeyType int\n\nfunc (k KeyType) String() (str string) {\n\tif s, ok := keyNames[k]; ok {\n\t\treturn s\n\t}\n\treturn \"\"\n}\n\n// Control keys. We could do this with an iota, but the values are very\n// specific, so we set the values explicitly to avoid any confusion.\n//\n// See also:\n// https://en.wikipedia.org/wiki/C0_and_C1_control_codes\nconst (\n\tkeyNUL KeyType = 0   // null, \\0\n\tkeySOH KeyType = 1   // start of heading\n\tkeySTX KeyType = 2   // start of text\n\tkeyETX KeyType = 3   // break, ctrl+c\n\tkeyEOT KeyType = 4   // end of transmission\n\tkeyENQ KeyType = 5   // enquiry\n\tkeyACK KeyType = 6   // acknowledge\n\tkeyBEL KeyType = 7   // bell, \\a\n\tkeyBS  KeyType = 8   // backspace\n\tkeyHT  KeyType = 9   // horizontal tabulation, \\t\n\tkeyLF  KeyType = 10  // line feed, \\n\n\tkeyVT  KeyType = 11  // vertical tabulation \\v\n\tkeyFF  KeyType = 12  // form feed \\f\n\tkeyCR  KeyType = 13  // carriage return, \\r\n\tkeySO  KeyType = 14  // shift out\n\tkeySI  KeyType = 15  // shift in\n\tkeyDLE KeyType = 16  // data link escape\n\tkeyDC1 KeyType = 17  // device control one\n\tkeyDC2 KeyType = 18  // device control two\n\tkeyDC3 KeyType = 19  // device control three\n\tkeyDC4 KeyType = 20  // device control four\n\tkeyNAK KeyType = 21  // negative acknowledge\n\tkeySYN KeyType = 22  // synchronous idle\n\tkeyETB KeyType = 23  // end of transmission block\n\tkeyCAN KeyType = 24  // cancel\n\tkeyEM  KeyType = 25  // end of medium\n\tkeySUB KeyType = 26  // substitution\n\tkeyESC KeyType = 27  // escape, \\e\n\tkeyFS  KeyType = 28  // file separator\n\tkeyGS  KeyType = 29  // group separator\n\tkeyRS  KeyType = 30  // record separator\n\tkeyUS  KeyType = 31  // unit separator\n\tkeyDEL KeyType = 127 // delete. on most systems this is mapped to backspace, I hear\n)\n\n// Control key aliases.\nconst (\n\tKeyNull      KeyType = keyNUL\n\tKeyBreak     KeyType = keyETX\n\tKeyEnter     KeyType = keyCR\n\tKeyBackspace KeyType = keyDEL\n\tKeyTab       KeyType = keyHT\n\tKeyEsc       KeyType = keyESC\n\tKeyEscape    KeyType = keyESC\n\n\tKeyCtrlAt           KeyType = keyNUL // ctrl+@\n\tKeyCtrlA            KeyType = keySOH\n\tKeyCtrlB            KeyType = keySTX\n\tKeyCtrlC            KeyType = keyETX\n\tKeyCtrlD            KeyType = keyEOT\n\tKeyCtrlE            KeyType = keyENQ\n\tKeyCtrlF            KeyType = keyACK\n\tKeyCtrlG            KeyType = keyBEL\n\tKeyCtrlH            KeyType = keyBS\n\tKeyCtrlI            KeyType = keyHT\n\tKeyCtrlJ            KeyType = keyLF\n\tKeyCtrlK            KeyType = keyVT\n\tKeyCtrlL            KeyType = keyFF\n\tKeyCtrlM            KeyType = keyCR\n\tKeyCtrlN            KeyType = keySO\n\tKeyCtrlO            KeyType = keySI\n\tKeyCtrlP            KeyType = keyDLE\n\tKeyCtrlQ            KeyType = keyDC1\n\tKeyCtrlR            KeyType = keyDC2\n\tKeyCtrlS            KeyType = keyDC3\n\tKeyCtrlT            KeyType = keyDC4\n\tKeyCtrlU            KeyType = keyNAK\n\tKeyCtrlV            KeyType = keySYN\n\tKeyCtrlW            KeyType = keyETB\n\tKeyCtrlX            KeyType = keyCAN\n\tKeyCtrlY            KeyType = keyEM\n\tKeyCtrlZ            KeyType = keySUB\n\tKeyCtrlOpenBracket  KeyType = keyESC // ctrl+[\n\tKeyCtrlBackslash    KeyType = keyFS  // ctrl+\\\n\tKeyCtrlCloseBracket KeyType = keyGS  // ctrl+]\n\tKeyCtrlCaret        KeyType = keyRS  // ctrl+^\n\tKeyCtrlUnderscore   KeyType = keyUS  // ctrl+_\n\tKeyCtrlQuestionMark KeyType = keyDEL // ctrl+?\n)\n\n// Other keys.\nconst (\n\tKeyRunes KeyType = -(iota + 1)\n\tKeyUp\n\tKeyDown\n\tKeyRight\n\tKeyLeft\n\tKeyShiftTab\n\tKeyHome\n\tKeyEnd\n\tKeyPgUp\n\tKeyPgDown\n\tKeyCtrlPgUp\n\tKeyCtrlPgDown\n\tKeyDelete\n\tKeyInsert\n\tKeySpace\n\tKeyCtrlUp\n\tKeyCtrlDown\n\tKeyCtrlRight\n\tKeyCtrlLeft\n\tKeyCtrlHome\n\tKeyCtrlEnd\n\tKeyShiftUp\n\tKeyShiftDown\n\tKeyShiftRight\n\tKeyShiftLeft\n\tKeyShiftHome\n\tKeyShiftEnd\n\tKeyCtrlShiftUp\n\tKeyCtrlShiftDown\n\tKeyCtrlShiftLeft\n\tKeyCtrlShiftRight\n\tKeyCtrlShiftHome\n\tKeyCtrlShiftEnd\n\tKeyF1\n\tKeyF2\n\tKeyF3\n\tKeyF4\n\tKeyF5\n\tKeyF6\n\tKeyF7\n\tKeyF8\n\tKeyF9\n\tKeyF10\n\tKeyF11\n\tKeyF12\n\tKeyF13\n\tKeyF14\n\tKeyF15\n\tKeyF16\n\tKeyF17\n\tKeyF18\n\tKeyF19\n\tKeyF20\n)\n\n// Mappings for control keys and other special keys to friendly consts.\nvar keyNames = map[KeyType]string{\n\t// Control keys.\n\tkeyNUL: \"ctrl+@\", // also ctrl+` (that's ctrl+backtick)\n\tkeySOH: \"ctrl+a\",\n\tkeySTX: \"ctrl+b\",\n\tkeyETX: \"ctrl+c\",\n\tkeyEOT: \"ctrl+d\",\n\tkeyENQ: \"ctrl+e\",\n\tkeyACK: \"ctrl+f\",\n\tkeyBEL: \"ctrl+g\",\n\tkeyBS:  \"ctrl+h\",\n\tkeyHT:  \"tab\", // also ctrl+i\n\tkeyLF:  \"ctrl+j\",\n\tkeyVT:  \"ctrl+k\",\n\tkeyFF:  \"ctrl+l\",\n\tkeyCR:  \"enter\",\n\tkeySO:  \"ctrl+n\",\n\tkeySI:  \"ctrl+o\",\n\tkeyDLE: \"ctrl+p\",\n\tkeyDC1: \"ctrl+q\",\n\tkeyDC2: \"ctrl+r\",\n\tkeyDC3: \"ctrl+s\",\n\tkeyDC4: \"ctrl+t\",\n\tkeyNAK: \"ctrl+u\",\n\tkeySYN: \"ctrl+v\",\n\tkeyETB: \"ctrl+w\",\n\tkeyCAN: \"ctrl+x\",\n\tkeyEM:  \"ctrl+y\",\n\tkeySUB: \"ctrl+z\",\n\tkeyESC: \"esc\",\n\tkeyFS:  \"ctrl+\\\\\",\n\tkeyGS:  \"ctrl+]\",\n\tkeyRS:  \"ctrl+^\",\n\tkeyUS:  \"ctrl+_\",\n\tkeyDEL: \"backspace\",\n\n\t// Other keys.\n\tKeyRunes:          \"runes\",\n\tKeyUp:             \"up\",\n\tKeyDown:           \"down\",\n\tKeyRight:          \"right\",\n\tKeySpace:          \" \", // for backwards compatibility\n\tKeyLeft:           \"left\",\n\tKeyShiftTab:       \"shift+tab\",\n\tKeyHome:           \"home\",\n\tKeyEnd:            \"end\",\n\tKeyCtrlHome:       \"ctrl+home\",\n\tKeyCtrlEnd:        \"ctrl+end\",\n\tKeyShiftHome:      \"shift+home\",\n\tKeyShiftEnd:       \"shift+end\",\n\tKeyCtrlShiftHome:  \"ctrl+shift+home\",\n\tKeyCtrlShiftEnd:   \"ctrl+shift+end\",\n\tKeyPgUp:           \"pgup\",\n\tKeyPgDown:         \"pgdown\",\n\tKeyCtrlPgUp:       \"ctrl+pgup\",\n\tKeyCtrlPgDown:     \"ctrl+pgdown\",\n\tKeyDelete:         \"delete\",\n\tKeyInsert:         \"insert\",\n\tKeyCtrlUp:         \"ctrl+up\",\n\tKeyCtrlDown:       \"ctrl+down\",\n\tKeyCtrlRight:      \"ctrl+right\",\n\tKeyCtrlLeft:       \"ctrl+left\",\n\tKeyShiftUp:        \"shift+up\",\n\tKeyShiftDown:      \"shift+down\",\n\tKeyShiftRight:     \"shift+right\",\n\tKeyShiftLeft:      \"shift+left\",\n\tKeyCtrlShiftUp:    \"ctrl+shift+up\",\n\tKeyCtrlShiftDown:  \"ctrl+shift+down\",\n\tKeyCtrlShiftLeft:  \"ctrl+shift+left\",\n\tKeyCtrlShiftRight: \"ctrl+shift+right\",\n\tKeyF1:             \"f1\",\n\tKeyF2:             \"f2\",\n\tKeyF3:             \"f3\",\n\tKeyF4:             \"f4\",\n\tKeyF5:             \"f5\",\n\tKeyF6:             \"f6\",\n\tKeyF7:             \"f7\",\n\tKeyF8:             \"f8\",\n\tKeyF9:             \"f9\",\n\tKeyF10:            \"f10\",\n\tKeyF11:            \"f11\",\n\tKeyF12:            \"f12\",\n\tKeyF13:            \"f13\",\n\tKeyF14:            \"f14\",\n\tKeyF15:            \"f15\",\n\tKeyF16:            \"f16\",\n\tKeyF17:            \"f17\",\n\tKeyF18:            \"f18\",\n\tKeyF19:            \"f19\",\n\tKeyF20:            \"f20\",\n}\n\n// Sequence mappings.\nvar sequences = map[string]Key{\n\t// Arrow keys\n\t\"\\x1b[A\":    {Type: KeyUp},\n\t\"\\x1b[B\":    {Type: KeyDown},\n\t\"\\x1b[C\":    {Type: KeyRight},\n\t\"\\x1b[D\":    {Type: KeyLeft},\n\t\"\\x1b[1;2A\": {Type: KeyShiftUp},\n\t\"\\x1b[1;2B\": {Type: KeyShiftDown},\n\t\"\\x1b[1;2C\": {Type: KeyShiftRight},\n\t\"\\x1b[1;2D\": {Type: KeyShiftLeft},\n\t\"\\x1b[OA\":   {Type: KeyShiftUp},    // DECCKM\n\t\"\\x1b[OB\":   {Type: KeyShiftDown},  // DECCKM\n\t\"\\x1b[OC\":   {Type: KeyShiftRight}, // DECCKM\n\t\"\\x1b[OD\":   {Type: KeyShiftLeft},  // DECCKM\n\t\"\\x1b[a\":    {Type: KeyShiftUp},    // urxvt\n\t\"\\x1b[b\":    {Type: KeyShiftDown},  // urxvt\n\t\"\\x1b[c\":    {Type: KeyShiftRight}, // urxvt\n\t\"\\x1b[d\":    {Type: KeyShiftLeft},  // urxvt\n\t\"\\x1b[1;3A\": {Type: KeyUp, Alt: true},\n\t\"\\x1b[1;3B\": {Type: KeyDown, Alt: true},\n\t\"\\x1b[1;3C\": {Type: KeyRight, Alt: true},\n\t\"\\x1b[1;3D\": {Type: KeyLeft, Alt: true},\n\n\t\"\\x1b[1;4A\": {Type: KeyShiftUp, Alt: true},\n\t\"\\x1b[1;4B\": {Type: KeyShiftDown, Alt: true},\n\t\"\\x1b[1;4C\": {Type: KeyShiftRight, Alt: true},\n\t\"\\x1b[1;4D\": {Type: KeyShiftLeft, Alt: true},\n\n\t\"\\x1b[1;5A\": {Type: KeyCtrlUp},\n\t\"\\x1b[1;5B\": {Type: KeyCtrlDown},\n\t\"\\x1b[1;5C\": {Type: KeyCtrlRight},\n\t\"\\x1b[1;5D\": {Type: KeyCtrlLeft},\n\t\"\\x1b[Oa\":   {Type: KeyCtrlUp, Alt: true},    // urxvt\n\t\"\\x1b[Ob\":   {Type: KeyCtrlDown, Alt: true},  // urxvt\n\t\"\\x1b[Oc\":   {Type: KeyCtrlRight, Alt: true}, // urxvt\n\t\"\\x1b[Od\":   {Type: KeyCtrlLeft, Alt: true},  // urxvt\n\t\"\\x1b[1;6A\": {Type: KeyCtrlShiftUp},\n\t\"\\x1b[1;6B\": {Type: KeyCtrlShiftDown},\n\t\"\\x1b[1;6C\": {Type: KeyCtrlShiftRight},\n\t\"\\x1b[1;6D\": {Type: KeyCtrlShiftLeft},\n\t\"\\x1b[1;7A\": {Type: KeyCtrlUp, Alt: true},\n\t\"\\x1b[1;7B\": {Type: KeyCtrlDown, Alt: true},\n\t\"\\x1b[1;7C\": {Type: KeyCtrlRight, Alt: true},\n\t\"\\x1b[1;7D\": {Type: KeyCtrlLeft, Alt: true},\n\t\"\\x1b[1;8A\": {Type: KeyCtrlShiftUp, Alt: true},\n\t\"\\x1b[1;8B\": {Type: KeyCtrlShiftDown, Alt: true},\n\t\"\\x1b[1;8C\": {Type: KeyCtrlShiftRight, Alt: true},\n\t\"\\x1b[1;8D\": {Type: KeyCtrlShiftLeft, Alt: true},\n\n\t// Miscellaneous keys\n\t\"\\x1b[Z\": {Type: KeyShiftTab},\n\n\t\"\\x1b[2~\":   {Type: KeyInsert},\n\t\"\\x1b[3;2~\": {Type: KeyInsert, Alt: true},\n\n\t\"\\x1b[3~\":   {Type: KeyDelete},\n\t\"\\x1b[3;3~\": {Type: KeyDelete, Alt: true},\n\n\t\"\\x1b[5~\":   {Type: KeyPgUp},\n\t\"\\x1b[5;3~\": {Type: KeyPgUp, Alt: true},\n\t\"\\x1b[5;5~\": {Type: KeyCtrlPgUp},\n\t\"\\x1b[5^\":   {Type: KeyCtrlPgUp}, // urxvt\n\t\"\\x1b[5;7~\": {Type: KeyCtrlPgUp, Alt: true},\n\n\t\"\\x1b[6~\":   {Type: KeyPgDown},\n\t\"\\x1b[6;3~\": {Type: KeyPgDown, Alt: true},\n\t\"\\x1b[6;5~\": {Type: KeyCtrlPgDown},\n\t\"\\x1b[6^\":   {Type: KeyCtrlPgDown}, // urxvt\n\t\"\\x1b[6;7~\": {Type: KeyCtrlPgDown, Alt: true},\n\n\t\"\\x1b[1~\":   {Type: KeyHome},\n\t\"\\x1b[H\":    {Type: KeyHome},                     // xterm, lxterm\n\t\"\\x1b[1;3H\": {Type: KeyHome, Alt: true},          // xterm, lxterm\n\t\"\\x1b[1;5H\": {Type: KeyCtrlHome},                 // xterm, lxterm\n\t\"\\x1b[1;7H\": {Type: KeyCtrlHome, Alt: true},      // xterm, lxterm\n\t\"\\x1b[1;2H\": {Type: KeyShiftHome},                // xterm, lxterm\n\t\"\\x1b[1;4H\": {Type: KeyShiftHome, Alt: true},     // xterm, lxterm\n\t\"\\x1b[1;6H\": {Type: KeyCtrlShiftHome},            // xterm, lxterm\n\t\"\\x1b[1;8H\": {Type: KeyCtrlShiftHome, Alt: true}, // xterm, lxterm\n\n\t\"\\x1b[4~\":   {Type: KeyEnd},\n\t\"\\x1b[F\":    {Type: KeyEnd},                     // xterm, lxterm\n\t\"\\x1b[1;3F\": {Type: KeyEnd, Alt: true},          // xterm, lxterm\n\t\"\\x1b[1;5F\": {Type: KeyCtrlEnd},                 // xterm, lxterm\n\t\"\\x1b[1;7F\": {Type: KeyCtrlEnd, Alt: true},      // xterm, lxterm\n\t\"\\x1b[1;2F\": {Type: KeyShiftEnd},                // xterm, lxterm\n\t\"\\x1b[1;4F\": {Type: KeyShiftEnd, Alt: true},     // xterm, lxterm\n\t\"\\x1b[1;6F\": {Type: KeyCtrlShiftEnd},            // xterm, lxterm\n\t\"\\x1b[1;8F\": {Type: KeyCtrlShiftEnd, Alt: true}, // xterm, lxterm\n\n\t\"\\x1b[7~\": {Type: KeyHome},          // urxvt\n\t\"\\x1b[7^\": {Type: KeyCtrlHome},      // urxvt\n\t\"\\x1b[7$\": {Type: KeyShiftHome},     // urxvt\n\t\"\\x1b[7@\": {Type: KeyCtrlShiftHome}, // urxvt\n\n\t\"\\x1b[8~\": {Type: KeyEnd},          // urxvt\n\t\"\\x1b[8^\": {Type: KeyCtrlEnd},      // urxvt\n\t\"\\x1b[8$\": {Type: KeyShiftEnd},     // urxvt\n\t\"\\x1b[8@\": {Type: KeyCtrlShiftEnd}, // urxvt\n\n\t// Function keys, Linux console\n\t\"\\x1b[[A\": {Type: KeyF1}, // linux console\n\t\"\\x1b[[B\": {Type: KeyF2}, // linux console\n\t\"\\x1b[[C\": {Type: KeyF3}, // linux console\n\t\"\\x1b[[D\": {Type: KeyF4}, // linux console\n\t\"\\x1b[[E\": {Type: KeyF5}, // linux console\n\n\t// Function keys, X11\n\t\"\\x1bOP\": {Type: KeyF1}, // vt100, xterm\n\t\"\\x1bOQ\": {Type: KeyF2}, // vt100, xterm\n\t\"\\x1bOR\": {Type: KeyF3}, // vt100, xterm\n\t\"\\x1bOS\": {Type: KeyF4}, // vt100, xterm\n\n\t\"\\x1b[1;3P\": {Type: KeyF1, Alt: true}, // vt100, xterm\n\t\"\\x1b[1;3Q\": {Type: KeyF2, Alt: true}, // vt100, xterm\n\t\"\\x1b[1;3R\": {Type: KeyF3, Alt: true}, // vt100, xterm\n\t\"\\x1b[1;3S\": {Type: KeyF4, Alt: true}, // vt100, xterm\n\n\t\"\\x1b[11~\": {Type: KeyF1}, // urxvt\n\t\"\\x1b[12~\": {Type: KeyF2}, // urxvt\n\t\"\\x1b[13~\": {Type: KeyF3}, // urxvt\n\t\"\\x1b[14~\": {Type: KeyF4}, // urxvt\n\n\t\"\\x1b[15~\": {Type: KeyF5}, // vt100, xterm, also urxvt\n\n\t\"\\x1b[15;3~\": {Type: KeyF5, Alt: true}, // vt100, xterm, also urxvt\n\n\t\"\\x1b[17~\": {Type: KeyF6},  // vt100, xterm, also urxvt\n\t\"\\x1b[18~\": {Type: KeyF7},  // vt100, xterm, also urxvt\n\t\"\\x1b[19~\": {Type: KeyF8},  // vt100, xterm, also urxvt\n\t\"\\x1b[20~\": {Type: KeyF9},  // vt100, xterm, also urxvt\n\t\"\\x1b[21~\": {Type: KeyF10}, // vt100, xterm, also urxvt\n\n\t\"\\x1b[17;3~\": {Type: KeyF6, Alt: true},  // vt100, xterm\n\t\"\\x1b[18;3~\": {Type: KeyF7, Alt: true},  // vt100, xterm\n\t\"\\x1b[19;3~\": {Type: KeyF8, Alt: true},  // vt100, xterm\n\t\"\\x1b[20;3~\": {Type: KeyF9, Alt: true},  // vt100, xterm\n\t\"\\x1b[21;3~\": {Type: KeyF10, Alt: true}, // vt100, xterm\n\n\t\"\\x1b[23~\": {Type: KeyF11}, // vt100, xterm, also urxvt\n\t\"\\x1b[24~\": {Type: KeyF12}, // vt100, xterm, also urxvt\n\n\t\"\\x1b[23;3~\": {Type: KeyF11, Alt: true}, // vt100, xterm\n\t\"\\x1b[24;3~\": {Type: KeyF12, Alt: true}, // vt100, xterm\n\n\t\"\\x1b[1;2P\": {Type: KeyF13},\n\t\"\\x1b[1;2Q\": {Type: KeyF14},\n\n\t\"\\x1b[25~\": {Type: KeyF13}, // vt100, xterm, also urxvt\n\t\"\\x1b[26~\": {Type: KeyF14}, // vt100, xterm, also urxvt\n\n\t\"\\x1b[25;3~\": {Type: KeyF13, Alt: true}, // vt100, xterm\n\t\"\\x1b[26;3~\": {Type: KeyF14, Alt: true}, // vt100, xterm\n\n\t\"\\x1b[1;2R\": {Type: KeyF15},\n\t\"\\x1b[1;2S\": {Type: KeyF16},\n\n\t\"\\x1b[28~\": {Type: KeyF15}, // vt100, xterm, also urxvt\n\t\"\\x1b[29~\": {Type: KeyF16}, // vt100, xterm, also urxvt\n\n\t\"\\x1b[28;3~\": {Type: KeyF15, Alt: true}, // vt100, xterm\n\t\"\\x1b[29;3~\": {Type: KeyF16, Alt: true}, // vt100, xterm\n\n\t\"\\x1b[15;2~\": {Type: KeyF17},\n\t\"\\x1b[17;2~\": {Type: KeyF18},\n\t\"\\x1b[18;2~\": {Type: KeyF19},\n\t\"\\x1b[19;2~\": {Type: KeyF20},\n\n\t\"\\x1b[31~\": {Type: KeyF17},\n\t\"\\x1b[32~\": {Type: KeyF18},\n\t\"\\x1b[33~\": {Type: KeyF19},\n\t\"\\x1b[34~\": {Type: KeyF20},\n\n\t// Powershell sequences.\n\t\"\\x1bOA\": {Type: KeyUp, Alt: false},\n\t\"\\x1bOB\": {Type: KeyDown, Alt: false},\n\t\"\\x1bOC\": {Type: KeyRight, Alt: false},\n\t\"\\x1bOD\": {Type: KeyLeft, Alt: false},\n}\n\n// unknownInputByteMsg is reported by the input reader when an invalid\n// utf-8 byte is detected on the input. Currently, it is not handled\n// further by bubbletea. However, having this event makes it possible\n// to troubleshoot invalid inputs.\ntype unknownInputByteMsg byte\n\nfunc (u unknownInputByteMsg) String() string {\n\treturn fmt.Sprintf(\"?%#02x?\", int(u))\n}\n\n// unknownCSISequenceMsg is reported by the input reader when an\n// unrecognized CSI sequence is detected on the input. Currently, it\n// is not handled further by bubbletea. However, having this event\n// makes it possible to troubleshoot invalid inputs.\ntype unknownCSISequenceMsg []byte\n\nfunc (u unknownCSISequenceMsg) String() string {\n\treturn fmt.Sprintf(\"?CSI%+v?\", []byte(u)[2:])\n}\n\nvar spaceRunes = []rune{' '}\n\n// readAnsiInputs reads keypress and mouse inputs from a TTY and produces messages\n// containing information about the key or mouse events accordingly.\nfunc readAnsiInputs(ctx context.Context, msgs chan<- Msg, input io.Reader) error {\n\tvar buf [256]byte\n\n\tvar leftOverFromPrevIteration []byte\nloop:\n\tfor {\n\t\t// Read and block.\n\t\tnumBytes, err := input.Read(buf[:])\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error reading input: %w\", err)\n\t\t}\n\t\tb := buf[:numBytes]\n\t\tif leftOverFromPrevIteration != nil {\n\t\t\tb = append(leftOverFromPrevIteration, b...)\n\t\t}\n\n\t\t// If we had a short read (numBytes < len(buf)), we're sure that\n\t\t// the end of this read is an event boundary, so there is no doubt\n\t\t// if we are encountering the end of the buffer while parsing a message.\n\t\t// However, if we've succeeded in filling up the buffer, there may\n\t\t// be more data in the OS buffer ready to be read in, to complete\n\t\t// the last message in the input. In that case, we will retry with\n\t\t// the left over data in the next iteration.\n\t\tcanHaveMoreData := numBytes == len(buf)\n\n\t\tvar i, w int\n\t\tfor i, w = 0, 0; i < len(b); i += w {\n\t\t\tvar msg Msg\n\t\t\tw, msg = detectOneMsg(b[i:], canHaveMoreData)\n\t\t\tif w == 0 {\n\t\t\t\t// Expecting more bytes beyond the current buffer. Try waiting\n\t\t\t\t// for more input.\n\t\t\t\tleftOverFromPrevIteration = make([]byte, 0, len(b[i:])+len(buf))\n\t\t\t\tleftOverFromPrevIteration = append(leftOverFromPrevIteration, b[i:]...)\n\t\t\t\tcontinue loop\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase msgs <- msg:\n\t\t\tcase <-ctx.Done():\n\t\t\t\terr := ctx.Err()\n\t\t\t\tif err != nil {\n\t\t\t\t\terr = fmt.Errorf(\"found context error while reading input: %w\", err)\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tleftOverFromPrevIteration = nil\n\t}\n}\n\nvar (\n\tunknownCSIRe  = regexp.MustCompile(`^\\x1b\\[[\\x30-\\x3f]*[\\x20-\\x2f]*[\\x40-\\x7e]`)\n\tmouseSGRRegex = regexp.MustCompile(`(\\d+);(\\d+);(\\d+)([Mm])`)\n)\n\nfunc detectOneMsg(b []byte, canHaveMoreData bool) (w int, msg Msg) {\n\t// Detect mouse events.\n\t// X10 mouse events have a length of 6 bytes\n\tconst mouseEventX10Len = 6\n\tif len(b) >= mouseEventX10Len && b[0] == '\\x1b' && b[1] == '[' {\n\t\tswitch b[2] {\n\t\tcase 'M':\n\t\t\treturn mouseEventX10Len, MouseMsg(parseX10MouseEvent(b))\n\t\tcase '<':\n\t\t\tif matchIndices := mouseSGRRegex.FindSubmatchIndex(b[3:]); matchIndices != nil {\n\t\t\t\t// SGR mouse events length is the length of the match plus the length of the escape sequence\n\t\t\t\tmouseEventSGRLen := matchIndices[1] + 3 //nolint:gomnd\n\t\t\t\treturn mouseEventSGRLen, MouseMsg(parseSGRMouseEvent(b))\n\t\t\t}\n\t\t}\n\t}\n\n\t// Detect focus events.\n\tvar foundRF bool\n\tfoundRF, w, msg = detectReportFocus(b)\n\tif foundRF {\n\t\treturn w, msg\n\t}\n\n\t// Detect bracketed paste.\n\tvar foundbp bool\n\tfoundbp, w, msg = detectBracketedPaste(b)\n\tif foundbp {\n\t\treturn w, msg\n\t}\n\n\t// Detect escape sequence and control characters other than NUL,\n\t// possibly with an escape character in front to mark the Alt\n\t// modifier.\n\tvar foundSeq bool\n\tfoundSeq, w, msg = detectSequence(b)\n\tif foundSeq {\n\t\treturn w, msg\n\t}\n\n\t// No non-NUL control character or escape sequence.\n\t// If we are seeing at least an escape character, remember it for later below.\n\talt := false\n\ti := 0\n\tif b[0] == '\\x1b' {\n\t\talt = true\n\t\ti++\n\t}\n\n\t// Are we seeing a standalone NUL? This is not handled by detectSequence().\n\tif i < len(b) && b[i] == 0 {\n\t\treturn i + 1, KeyMsg{Type: keyNUL, Alt: alt}\n\t}\n\n\t// Find the longest sequence of runes that are not control\n\t// characters from this point.\n\tvar runes []rune\n\tfor rw := 0; i < len(b); i += rw {\n\t\tvar r rune\n\t\tr, rw = utf8.DecodeRune(b[i:])\n\t\tif r == utf8.RuneError || r <= rune(keyUS) || r == rune(keyDEL) || r == ' ' {\n\t\t\t// Rune errors are handled below; control characters and spaces will\n\t\t\t// be handled by detectSequence in the next call to detectOneMsg.\n\t\t\tbreak\n\t\t}\n\t\trunes = append(runes, r)\n\t\tif alt {\n\t\t\t// We only support a single rune after an escape alt modifier.\n\t\t\ti += rw\n\t\t\tbreak\n\t\t}\n\t}\n\tif i >= len(b) && canHaveMoreData {\n\t\t// We have encountered the end of the input buffer. Alas, we can't\n\t\t// be sure whether the data in the remainder of the buffer is\n\t\t// complete (maybe there was a short read). Instead of sending anything\n\t\t// dumb to the message channel, do a short read. The outer loop will\n\t\t// handle this case by extending the buffer as necessary.\n\t\treturn 0, nil\n\t}\n\n\t// If we found at least one rune, we report the bunch of them as\n\t// a single KeyRunes or KeySpace event.\n\tif len(runes) > 0 {\n\t\tk := Key{Type: KeyRunes, Runes: runes, Alt: alt}\n\t\tif len(runes) == 1 && runes[0] == ' ' {\n\t\t\tk.Type = KeySpace\n\t\t}\n\t\treturn i, KeyMsg(k)\n\t}\n\n\t// We didn't find an escape sequence, nor a valid rune. Was this a\n\t// lone escape character at the end of the input?\n\tif alt && len(b) == 1 {\n\t\treturn 1, KeyMsg(Key{Type: KeyEscape})\n\t}\n\n\t// The character at the current position is neither an escape\n\t// sequence, a valid rune start or a sole escape character. Report\n\t// it as an invalid byte.\n\treturn 1, unknownInputByteMsg(b[0])\n}\n"
        },
        {
          "name": "key_other.go",
          "type": "blob",
          "size": 0.2,
          "content": "//go:build !windows\n// +build !windows\n\npackage tea\n\nimport (\n\t\"context\"\n\t\"io\"\n)\n\nfunc readInputs(ctx context.Context, msgs chan<- Msg, input io.Reader) error {\n\treturn readAnsiInputs(ctx, msgs, input)\n}\n"
        },
        {
          "name": "key_sequences.go",
          "type": "blob",
          "size": 3.46,
          "content": "package tea\n\nimport (\n\t\"bytes\"\n\t\"sort\"\n\t\"unicode/utf8\"\n)\n\n// extSequences is used by the map-based algorithm below. It contains\n// the sequences plus their alternatives with an escape character\n// prefixed, plus the control chars, plus the space.\n// It does not contain the NUL character, which is handled specially\n// by detectOneMsg.\nvar extSequences = func() map[string]Key {\n\ts := map[string]Key{}\n\tfor seq, key := range sequences {\n\t\tkey := key\n\t\ts[seq] = key\n\t\tif !key.Alt {\n\t\t\tkey.Alt = true\n\t\t\ts[\"\\x1b\"+seq] = key\n\t\t}\n\t}\n\tfor i := keyNUL + 1; i <= keyDEL; i++ {\n\t\tif i == keyESC {\n\t\t\tcontinue\n\t\t}\n\t\ts[string([]byte{byte(i)})] = Key{Type: i}\n\t\ts[string([]byte{'\\x1b', byte(i)})] = Key{Type: i, Alt: true}\n\t\tif i == keyUS {\n\t\t\ti = keyDEL - 1\n\t\t}\n\t}\n\ts[\" \"] = Key{Type: KeySpace, Runes: spaceRunes}\n\ts[\"\\x1b \"] = Key{Type: KeySpace, Alt: true, Runes: spaceRunes}\n\ts[\"\\x1b\\x1b\"] = Key{Type: KeyEscape, Alt: true}\n\treturn s\n}()\n\n// seqLengths is the sizes of valid sequences, starting with the\n// largest size.\nvar seqLengths = func() []int {\n\tsizes := map[int]struct{}{}\n\tfor seq := range extSequences {\n\t\tsizes[len(seq)] = struct{}{}\n\t}\n\tlsizes := make([]int, 0, len(sizes))\n\tfor sz := range sizes {\n\t\tlsizes = append(lsizes, sz)\n\t}\n\tsort.Slice(lsizes, func(i, j int) bool { return lsizes[i] > lsizes[j] })\n\treturn lsizes\n}()\n\n// detectSequence uses a longest prefix match over the input\n// sequence and a hash map.\nfunc detectSequence(input []byte) (hasSeq bool, width int, msg Msg) {\n\tseqs := extSequences\n\tfor _, sz := range seqLengths {\n\t\tif sz > len(input) {\n\t\t\tcontinue\n\t\t}\n\t\tprefix := input[:sz]\n\t\tkey, ok := seqs[string(prefix)]\n\t\tif ok {\n\t\t\treturn true, sz, KeyMsg(key)\n\t\t}\n\t}\n\t// Is this an unknown CSI sequence?\n\tif loc := unknownCSIRe.FindIndex(input); loc != nil {\n\t\treturn true, loc[1], unknownCSISequenceMsg(input[:loc[1]])\n\t}\n\n\treturn false, 0, nil\n}\n\n// detectBracketedPaste detects an input pasted while bracketed\n// paste mode was enabled.\n//\n// Note: this function is a no-op if bracketed paste was not enabled\n// on the terminal, since in that case we'd never see this\n// particular escape sequence.\nfunc detectBracketedPaste(input []byte) (hasBp bool, width int, msg Msg) {\n\t// Detect the start sequence.\n\tconst bpStart = \"\\x1b[200~\"\n\tif len(input) < len(bpStart) || string(input[:len(bpStart)]) != bpStart {\n\t\treturn false, 0, nil\n\t}\n\n\t// Skip over the start sequence.\n\tinput = input[len(bpStart):]\n\n\t// If we saw the start sequence, then we must have an end sequence\n\t// as well. Find it.\n\tconst bpEnd = \"\\x1b[201~\"\n\tidx := bytes.Index(input, []byte(bpEnd))\n\tinputLen := len(bpStart) + idx + len(bpEnd)\n\tif idx == -1 {\n\t\t// We have encountered the end of the input buffer without seeing\n\t\t// the marker for the end of the bracketed paste.\n\t\t// Tell the outer loop we have done a short read and we want more.\n\t\treturn true, 0, nil\n\t}\n\n\t// The paste is everything in-between.\n\tpaste := input[:idx]\n\n\t// All there is in-between is runes, not to be interpreted further.\n\tk := Key{Type: KeyRunes, Paste: true}\n\tfor len(paste) > 0 {\n\t\tr, w := utf8.DecodeRune(paste)\n\t\tif r != utf8.RuneError {\n\t\t\tk.Runes = append(k.Runes, r)\n\t\t}\n\t\tpaste = paste[w:]\n\t}\n\n\treturn true, inputLen, KeyMsg(k)\n}\n\n// detectReportFocus detects a focus report sequence.\n// nolint: gomnd\nfunc detectReportFocus(input []byte) (hasRF bool, width int, msg Msg) {\n\tswitch {\n\tcase bytes.Equal(input, []byte(\"\\x1b[I\")):\n\t\treturn true, 3, FocusMsg{}\n\tcase bytes.Equal(input, []byte(\"\\x1b[O\")):\n\t\treturn true, 3, BlurMsg{}\n\t}\n\treturn false, 0, nil\n}\n"
        },
        {
          "name": "key_test.go",
          "type": "blob",
          "size": 15.92,
          "content": "package tea\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestKeyString(t *testing.T) {\n\tt.Run(\"alt+space\", func(t *testing.T) {\n\t\tif got := KeyMsg(Key{\n\t\t\tType: KeySpace,\n\t\t\tAlt:  true,\n\t\t}).String(); got != \"alt+ \" {\n\t\t\tt.Fatalf(`expected a \"alt+ \", got %q`, got)\n\t\t}\n\t})\n\n\tt.Run(\"runes\", func(t *testing.T) {\n\t\tif got := KeyMsg(Key{\n\t\t\tType:  KeyRunes,\n\t\t\tRunes: []rune{'a'},\n\t\t}).String(); got != \"a\" {\n\t\t\tt.Fatalf(`expected an \"a\", got %q`, got)\n\t\t}\n\t})\n\n\tt.Run(\"invalid\", func(t *testing.T) {\n\t\tif got := KeyMsg(Key{\n\t\t\tType: KeyType(99999),\n\t\t}).String(); got != \"\" {\n\t\t\tt.Fatalf(`expected a \"\", got %q`, got)\n\t\t}\n\t})\n}\n\nfunc TestKeyTypeString(t *testing.T) {\n\tt.Run(\"space\", func(t *testing.T) {\n\t\tif got := KeySpace.String(); got != \" \" {\n\t\t\tt.Fatalf(`expected a \" \", got %q`, got)\n\t\t}\n\t})\n\n\tt.Run(\"invalid\", func(t *testing.T) {\n\t\tif got := KeyType(99999).String(); got != \"\" {\n\t\t\tt.Fatalf(`expected a \"\", got %q`, got)\n\t\t}\n\t})\n}\n\ntype seqTest struct {\n\tseq []byte\n\tmsg Msg\n}\n\n// buildBaseSeqTests returns sequence tests that are valid for the\n// detectSequence() function.\nfunc buildBaseSeqTests() []seqTest {\n\ttd := []seqTest{}\n\tfor seq, key := range sequences {\n\t\tkey := key\n\t\ttd = append(td, seqTest{[]byte(seq), KeyMsg(key)})\n\t\tif !key.Alt {\n\t\t\tkey.Alt = true\n\t\t\ttd = append(td, seqTest{[]byte(\"\\x1b\" + seq), KeyMsg(key)})\n\t\t}\n\t}\n\t// Add all the control characters.\n\tfor i := keyNUL + 1; i <= keyDEL; i++ {\n\t\tif i == keyESC {\n\t\t\t// Not handled in detectSequence(), so not part of the base test\n\t\t\t// suite.\n\t\t\tcontinue\n\t\t}\n\t\ttd = append(td, seqTest{[]byte{byte(i)}, KeyMsg{Type: i}})\n\t\ttd = append(td, seqTest{[]byte{'\\x1b', byte(i)}, KeyMsg{Type: i, Alt: true}})\n\t\tif i == keyUS {\n\t\t\ti = keyDEL - 1\n\t\t}\n\t}\n\n\t// Additional special cases.\n\ttd = append(td,\n\t\t// Unrecognized CSI sequence.\n\t\tseqTest{\n\t\t\t[]byte{'\\x1b', '[', '-', '-', '-', '-', 'X'},\n\t\t\tunknownCSISequenceMsg([]byte{'\\x1b', '[', '-', '-', '-', '-', 'X'}),\n\t\t},\n\t\t// A lone space character.\n\t\tseqTest{\n\t\t\t[]byte{' '},\n\t\t\tKeyMsg{Type: KeySpace, Runes: []rune(\" \")},\n\t\t},\n\t\t// An escape character with the alt modifier.\n\t\tseqTest{\n\t\t\t[]byte{'\\x1b', ' '},\n\t\t\tKeyMsg{Type: KeySpace, Runes: []rune(\" \"), Alt: true},\n\t\t},\n\t)\n\treturn td\n}\n\nfunc TestDetectSequence(t *testing.T) {\n\ttd := buildBaseSeqTests()\n\tfor _, tc := range td {\n\t\tt.Run(fmt.Sprintf(\"%q\", string(tc.seq)), func(t *testing.T) {\n\t\t\thasSeq, width, msg := detectSequence(tc.seq)\n\t\t\tif !hasSeq {\n\t\t\t\tt.Fatalf(\"no sequence found\")\n\t\t\t}\n\t\t\tif width != len(tc.seq) {\n\t\t\t\tt.Errorf(\"parser did not consume the entire input: got %d, expected %d\", width, len(tc.seq))\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(tc.msg, msg) {\n\t\t\t\tt.Errorf(\"expected event %#v (%T), got %#v (%T)\", tc.msg, tc.msg, msg, msg)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDetectOneMsg(t *testing.T) {\n\ttd := buildBaseSeqTests()\n\t// Add tests for the inputs that detectOneMsg() can parse, but\n\t// detectSequence() cannot.\n\ttd = append(td,\n\t\t// focus/blur\n\t\tseqTest{\n\t\t\t[]byte{'\\x1b', '[', 'I'},\n\t\t\tFocusMsg{},\n\t\t},\n\t\tseqTest{\n\t\t\t[]byte{'\\x1b', '[', 'O'},\n\t\t\tBlurMsg{},\n\t\t},\n\t\t// Mouse event.\n\t\tseqTest{\n\t\t\t[]byte{'\\x1b', '[', 'M', byte(32) + 0b0100_0000, byte(65), byte(49)},\n\t\t\tMouseMsg{X: 32, Y: 16, Type: MouseWheelUp, Button: MouseButtonWheelUp, Action: MouseActionPress},\n\t\t},\n\t\t// SGR Mouse event.\n\t\tseqTest{\n\t\t\t[]byte(\"\\x1b[<0;33;17M\"),\n\t\t\tMouseMsg{X: 32, Y: 16, Type: MouseLeft, Button: MouseButtonLeft, Action: MouseActionPress},\n\t\t},\n\t\t// Runes.\n\t\tseqTest{\n\t\t\t[]byte{'a'},\n\t\t\tKeyMsg{Type: KeyRunes, Runes: []rune(\"a\")},\n\t\t},\n\t\tseqTest{\n\t\t\t[]byte{'\\x1b', 'a'},\n\t\t\tKeyMsg{Type: KeyRunes, Runes: []rune(\"a\"), Alt: true},\n\t\t},\n\t\tseqTest{\n\t\t\t[]byte{'a', 'a', 'a'},\n\t\t\tKeyMsg{Type: KeyRunes, Runes: []rune(\"aaa\")},\n\t\t},\n\t\t// Multi-byte rune.\n\t\tseqTest{\n\t\t\t[]byte(\"☃\"),\n\t\t\tKeyMsg{Type: KeyRunes, Runes: []rune(\"☃\")},\n\t\t},\n\t\tseqTest{\n\t\t\t[]byte(\"\\x1b☃\"),\n\t\t\tKeyMsg{Type: KeyRunes, Runes: []rune(\"☃\"), Alt: true},\n\t\t},\n\t\t// Standalone control chacters.\n\t\tseqTest{\n\t\t\t[]byte{'\\x1b'},\n\t\t\tKeyMsg{Type: KeyEscape},\n\t\t},\n\t\tseqTest{\n\t\t\t[]byte{byte(keySOH)},\n\t\t\tKeyMsg{Type: KeyCtrlA},\n\t\t},\n\t\tseqTest{\n\t\t\t[]byte{'\\x1b', byte(keySOH)},\n\t\t\tKeyMsg{Type: KeyCtrlA, Alt: true},\n\t\t},\n\t\tseqTest{\n\t\t\t[]byte{byte(keyNUL)},\n\t\t\tKeyMsg{Type: KeyCtrlAt},\n\t\t},\n\t\tseqTest{\n\t\t\t[]byte{'\\x1b', byte(keyNUL)},\n\t\t\tKeyMsg{Type: KeyCtrlAt, Alt: true},\n\t\t},\n\t\t// Invalid characters.\n\t\tseqTest{\n\t\t\t[]byte{'\\x80'},\n\t\t\tunknownInputByteMsg(0x80),\n\t\t},\n\t)\n\n\tif runtime.GOOS != \"windows\" {\n\t\t// Sadly, utf8.DecodeRune([]byte(0xfe)) returns a valid rune on windows.\n\t\t// This is incorrect, but it makes our test fail if we try it out.\n\t\ttd = append(td, seqTest{\n\t\t\t[]byte{'\\xfe'},\n\t\t\tunknownInputByteMsg(0xfe),\n\t\t})\n\t}\n\n\tfor _, tc := range td {\n\t\tt.Run(fmt.Sprintf(\"%q\", string(tc.seq)), func(t *testing.T) {\n\t\t\twidth, msg := detectOneMsg(tc.seq, false /* canHaveMoreData */)\n\t\t\tif width != len(tc.seq) {\n\t\t\t\tt.Errorf(\"parser did not consume the entire input: got %d, expected %d\", width, len(tc.seq))\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(tc.msg, msg) {\n\t\t\t\tt.Errorf(\"expected event %#v (%T), got %#v (%T)\", tc.msg, tc.msg, msg, msg)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestReadLongInput(t *testing.T) {\n\tinput := strings.Repeat(\"a\", 1000)\n\tmsgs := testReadInputs(t, bytes.NewReader([]byte(input)))\n\tif len(msgs) != 1 {\n\t\tt.Errorf(\"expected 1 messages, got %d\", len(msgs))\n\t}\n\tkm := msgs[0]\n\tk := Key(km.(KeyMsg))\n\tif k.Type != KeyRunes {\n\t\tt.Errorf(\"expected key runes, got %d\", k.Type)\n\t}\n\tif len(k.Runes) != 1000 || !reflect.DeepEqual(k.Runes, []rune(input)) {\n\t\tt.Errorf(\"unexpected runes: %+v\", k)\n\t}\n\tif k.Alt {\n\t\tt.Errorf(\"unexpected alt\")\n\t}\n}\n\nfunc TestReadInput(t *testing.T) {\n\ttype test struct {\n\t\tkeyname string\n\t\tin      []byte\n\t\tout     []Msg\n\t}\n\ttestData := []test{\n\t\t{\n\t\t\t\"a\",\n\t\t\t[]byte{'a'},\n\t\t\t[]Msg{\n\t\t\t\tKeyMsg{\n\t\t\t\t\tType:  KeyRunes,\n\t\t\t\t\tRunes: []rune{'a'},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\" \",\n\t\t\t[]byte{' '},\n\t\t\t[]Msg{\n\t\t\t\tKeyMsg{\n\t\t\t\t\tType:  KeySpace,\n\t\t\t\t\tRunes: []rune{' '},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"a alt+a\",\n\t\t\t[]byte{'a', '\\x1b', 'a'},\n\t\t\t[]Msg{\n\t\t\t\tKeyMsg{Type: KeyRunes, Runes: []rune{'a'}},\n\t\t\t\tKeyMsg{Type: KeyRunes, Runes: []rune{'a'}, Alt: true},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"a alt+a a\",\n\t\t\t[]byte{'a', '\\x1b', 'a', 'a'},\n\t\t\t[]Msg{\n\t\t\t\tKeyMsg{Type: KeyRunes, Runes: []rune{'a'}},\n\t\t\t\tKeyMsg{Type: KeyRunes, Runes: []rune{'a'}, Alt: true},\n\t\t\t\tKeyMsg{Type: KeyRunes, Runes: []rune{'a'}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"ctrl+a\",\n\t\t\t[]byte{byte(keySOH)},\n\t\t\t[]Msg{\n\t\t\t\tKeyMsg{\n\t\t\t\t\tType: KeyCtrlA,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"ctrl+a ctrl+b\",\n\t\t\t[]byte{byte(keySOH), byte(keySTX)},\n\t\t\t[]Msg{\n\t\t\t\tKeyMsg{Type: KeyCtrlA},\n\t\t\t\tKeyMsg{Type: KeyCtrlB},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"alt+a\",\n\t\t\t[]byte{byte(0x1b), 'a'},\n\t\t\t[]Msg{\n\t\t\t\tKeyMsg{\n\t\t\t\t\tType:  KeyRunes,\n\t\t\t\t\tAlt:   true,\n\t\t\t\t\tRunes: []rune{'a'},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"abcd\",\n\t\t\t[]byte{'a', 'b', 'c', 'd'},\n\t\t\t[]Msg{\n\t\t\t\tKeyMsg{\n\t\t\t\t\tType:  KeyRunes,\n\t\t\t\t\tRunes: []rune{'a', 'b', 'c', 'd'},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"up\",\n\t\t\t[]byte(\"\\x1b[A\"),\n\t\t\t[]Msg{\n\t\t\t\tKeyMsg{\n\t\t\t\t\tType: KeyUp,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"wheel up\",\n\t\t\t[]byte{'\\x1b', '[', 'M', byte(32) + 0b0100_0000, byte(65), byte(49)},\n\t\t\t[]Msg{\n\t\t\t\tMouseMsg{\n\t\t\t\t\tX:      32,\n\t\t\t\t\tY:      16,\n\t\t\t\t\tType:   MouseWheelUp,\n\t\t\t\t\tButton: MouseButtonWheelUp,\n\t\t\t\t\tAction: MouseActionPress,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"left motion release\",\n\t\t\t[]byte{\n\t\t\t\t'\\x1b', '[', 'M', byte(32) + 0b0010_0000, byte(32 + 33), byte(16 + 33),\n\t\t\t\t'\\x1b', '[', 'M', byte(32) + 0b0000_0011, byte(64 + 33), byte(32 + 33),\n\t\t\t},\n\t\t\t[]Msg{\n\t\t\t\tMouseMsg(MouseEvent{\n\t\t\t\t\tX:      32,\n\t\t\t\t\tY:      16,\n\t\t\t\t\tType:   MouseLeft,\n\t\t\t\t\tButton: MouseButtonLeft,\n\t\t\t\t\tAction: MouseActionMotion,\n\t\t\t\t}),\n\t\t\t\tMouseMsg(MouseEvent{\n\t\t\t\t\tX:      64,\n\t\t\t\t\tY:      32,\n\t\t\t\t\tType:   MouseRelease,\n\t\t\t\t\tButton: MouseButtonNone,\n\t\t\t\t\tAction: MouseActionRelease,\n\t\t\t\t}),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"shift+tab\",\n\t\t\t[]byte{'\\x1b', '[', 'Z'},\n\t\t\t[]Msg{\n\t\t\t\tKeyMsg{\n\t\t\t\t\tType: KeyShiftTab,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"enter\",\n\t\t\t[]byte{'\\r'},\n\t\t\t[]Msg{KeyMsg{Type: KeyEnter}},\n\t\t},\n\t\t{\n\t\t\t\"alt+enter\",\n\t\t\t[]byte{'\\x1b', '\\r'},\n\t\t\t[]Msg{\n\t\t\t\tKeyMsg{\n\t\t\t\t\tType: KeyEnter,\n\t\t\t\t\tAlt:  true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"insert\",\n\t\t\t[]byte{'\\x1b', '[', '2', '~'},\n\t\t\t[]Msg{\n\t\t\t\tKeyMsg{\n\t\t\t\t\tType: KeyInsert,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"alt+ctrl+a\",\n\t\t\t[]byte{'\\x1b', byte(keySOH)},\n\t\t\t[]Msg{\n\t\t\t\tKeyMsg{\n\t\t\t\t\tType: KeyCtrlA,\n\t\t\t\t\tAlt:  true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"?CSI[45 45 45 45 88]?\",\n\t\t\t[]byte{'\\x1b', '[', '-', '-', '-', '-', 'X'},\n\t\t\t[]Msg{unknownCSISequenceMsg([]byte{'\\x1b', '[', '-', '-', '-', '-', 'X'})},\n\t\t},\n\t\t// Powershell sequences.\n\t\t{\n\t\t\t\"up\",\n\t\t\t[]byte{'\\x1b', 'O', 'A'},\n\t\t\t[]Msg{KeyMsg{Type: KeyUp}},\n\t\t},\n\t\t{\n\t\t\t\"down\",\n\t\t\t[]byte{'\\x1b', 'O', 'B'},\n\t\t\t[]Msg{KeyMsg{Type: KeyDown}},\n\t\t},\n\t\t{\n\t\t\t\"right\",\n\t\t\t[]byte{'\\x1b', 'O', 'C'},\n\t\t\t[]Msg{KeyMsg{Type: KeyRight}},\n\t\t},\n\t\t{\n\t\t\t\"left\",\n\t\t\t[]byte{'\\x1b', 'O', 'D'},\n\t\t\t[]Msg{KeyMsg{Type: KeyLeft}},\n\t\t},\n\t\t{\n\t\t\t\"alt+enter\",\n\t\t\t[]byte{'\\x1b', '\\x0d'},\n\t\t\t[]Msg{KeyMsg{Type: KeyEnter, Alt: true}},\n\t\t},\n\t\t{\n\t\t\t\"alt+backspace\",\n\t\t\t[]byte{'\\x1b', '\\x7f'},\n\t\t\t[]Msg{KeyMsg{Type: KeyBackspace, Alt: true}},\n\t\t},\n\t\t{\n\t\t\t\"ctrl+@\",\n\t\t\t[]byte{'\\x00'},\n\t\t\t[]Msg{KeyMsg{Type: KeyCtrlAt}},\n\t\t},\n\t\t{\n\t\t\t\"alt+ctrl+@\",\n\t\t\t[]byte{'\\x1b', '\\x00'},\n\t\t\t[]Msg{KeyMsg{Type: KeyCtrlAt, Alt: true}},\n\t\t},\n\t\t{\n\t\t\t\"esc\",\n\t\t\t[]byte{'\\x1b'},\n\t\t\t[]Msg{KeyMsg{Type: KeyEsc}},\n\t\t},\n\t\t{\n\t\t\t\"alt+esc\",\n\t\t\t[]byte{'\\x1b', '\\x1b'},\n\t\t\t[]Msg{KeyMsg{Type: KeyEsc, Alt: true}},\n\t\t},\n\t\t{\n\t\t\t\"[a b] o\",\n\t\t\t[]byte{\n\t\t\t\t'\\x1b', '[', '2', '0', '0', '~',\n\t\t\t\t'a', ' ', 'b',\n\t\t\t\t'\\x1b', '[', '2', '0', '1', '~',\n\t\t\t\t'o',\n\t\t\t},\n\t\t\t[]Msg{\n\t\t\t\tKeyMsg{Type: KeyRunes, Runes: []rune(\"a b\"), Paste: true},\n\t\t\t\tKeyMsg{Type: KeyRunes, Runes: []rune(\"o\")},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"[a\\x03\\nb]\",\n\t\t\t[]byte{\n\t\t\t\t'\\x1b', '[', '2', '0', '0', '~',\n\t\t\t\t'a', '\\x03', '\\n', 'b',\n\t\t\t\t'\\x1b', '[', '2', '0', '1', '~',\n\t\t\t},\n\t\t\t[]Msg{\n\t\t\t\tKeyMsg{Type: KeyRunes, Runes: []rune(\"a\\x03\\nb\"), Paste: true},\n\t\t\t},\n\t\t},\n\t}\n\tif runtime.GOOS != \"windows\" {\n\t\t// Sadly, utf8.DecodeRune([]byte(0xfe)) returns a valid rune on windows.\n\t\t// This is incorrect, but it makes our test fail if we try it out.\n\t\ttestData = append(testData,\n\t\t\ttest{\n\t\t\t\t\"?0xfe?\",\n\t\t\t\t[]byte{'\\xfe'},\n\t\t\t\t[]Msg{unknownInputByteMsg(0xfe)},\n\t\t\t},\n\t\t\ttest{\n\t\t\t\t\"a ?0xfe?   b\",\n\t\t\t\t[]byte{'a', '\\xfe', ' ', 'b'},\n\t\t\t\t[]Msg{\n\t\t\t\t\tKeyMsg{Type: KeyRunes, Runes: []rune{'a'}},\n\t\t\t\t\tunknownInputByteMsg(0xfe),\n\t\t\t\t\tKeyMsg{Type: KeySpace, Runes: []rune{' '}},\n\t\t\t\t\tKeyMsg{Type: KeyRunes, Runes: []rune{'b'}},\n\t\t\t\t},\n\t\t\t},\n\t\t)\n\t}\n\n\tfor i, td := range testData {\n\t\tt.Run(fmt.Sprintf(\"%d: %s\", i, td.keyname), func(t *testing.T) {\n\t\t\tmsgs := testReadInputs(t, bytes.NewReader(td.in))\n\t\t\tvar buf strings.Builder\n\t\t\tfor i, msg := range msgs {\n\t\t\t\tif i > 0 {\n\t\t\t\t\tbuf.WriteByte(' ')\n\t\t\t\t}\n\t\t\t\tif s, ok := msg.(fmt.Stringer); ok {\n\t\t\t\t\tbuf.WriteString(s.String())\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Fprintf(&buf, \"%#v:%T\", msg, msg)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttitle := buf.String()\n\t\t\tif title != td.keyname {\n\t\t\t\tt.Errorf(\"expected message titles:\\n  %s\\ngot:\\n  %s\", td.keyname, title)\n\t\t\t}\n\n\t\t\tif len(msgs) != len(td.out) {\n\t\t\t\tt.Fatalf(\"unexpected message list length: got %d, expected %d\\n%#v\", len(msgs), len(td.out), msgs)\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(td.out, msgs) {\n\t\t\t\tt.Fatalf(\"expected:\\n%#v\\ngot:\\n%#v\", td.out, msgs)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc testReadInputs(t *testing.T, input io.Reader) []Msg {\n\t// We'll check that the input reader finishes at the end\n\t// without error.\n\tvar wg sync.WaitGroup\n\tvar inputErr error\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer func() {\n\t\tcancel()\n\t\twg.Wait()\n\t\tif inputErr != nil && !errors.Is(inputErr, io.EOF) {\n\t\t\tt.Fatalf(\"unexpected input error: %v\", inputErr)\n\t\t}\n\t}()\n\n\t// The messages we're consuming.\n\tmsgsC := make(chan Msg)\n\n\t// Start the reader in the background.\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tinputErr = readAnsiInputs(ctx, msgsC, input)\n\t\tmsgsC <- nil\n\t}()\n\n\tvar msgs []Msg\nloop:\n\tfor {\n\t\tselect {\n\t\tcase msg := <-msgsC:\n\t\t\tif msg == nil {\n\t\t\t\t// end of input marker for the test.\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t\tmsgs = append(msgs, msg)\n\t\tcase <-time.After(2 * time.Second):\n\t\t\tt.Errorf(\"timeout waiting for input event\")\n\t\t\tbreak loop\n\t\t}\n\t}\n\treturn msgs\n}\n\n// randTest defines the test input and expected output for a sequence\n// of interleaved control sequences and control characters.\ntype randTest struct {\n\tdata    []byte\n\tlengths []int\n\tnames   []string\n}\n\n// seed is the random seed to randomize the input. This helps check\n// that all the sequences get ultimately exercised.\nvar seed = flag.Int64(\"seed\", 0, \"random seed (0 to autoselect)\")\n\n// genRandomData generates a randomized test, with a random seed unless\n// the seed flag was set.\nfunc genRandomData(logfn func(int64), length int) randTest {\n\t// We'll use a random source. However, we give the user the option\n\t// to override it to a specific value for reproduceability.\n\ts := *seed\n\tif s == 0 {\n\t\ts = time.Now().UnixNano()\n\t}\n\t// Inform the user so they know what to reuse to get the same data.\n\tlogfn(s)\n\treturn genRandomDataWithSeed(s, length)\n}\n\n// genRandomDataWithSeed generates a randomized test with a fixed seed.\nfunc genRandomDataWithSeed(s int64, length int) randTest {\n\tsrc := rand.NewSource(s)\n\tr := rand.New(src)\n\n\t// allseqs contains all the sequences, in sorted order. We sort\n\t// to make the test deterministic (when the seed is also fixed).\n\ttype seqpair struct {\n\t\tseq  string\n\t\tname string\n\t}\n\tvar allseqs []seqpair\n\tfor seq, key := range sequences {\n\t\tallseqs = append(allseqs, seqpair{seq, key.String()})\n\t}\n\tsort.Slice(allseqs, func(i, j int) bool { return allseqs[i].seq < allseqs[j].seq })\n\n\t// res contains the computed test.\n\tvar res randTest\n\n\tfor len(res.data) < length {\n\t\talt := r.Intn(2)\n\t\tprefix := \"\"\n\t\tesclen := 0\n\t\tif alt == 1 {\n\t\t\tprefix = \"alt+\"\n\t\t\tesclen = 1\n\t\t}\n\t\tkind := r.Intn(3)\n\t\tswitch kind {\n\t\tcase 0:\n\t\t\t// A control character.\n\t\t\tif alt == 1 {\n\t\t\t\tres.data = append(res.data, '\\x1b')\n\t\t\t}\n\t\t\tres.data = append(res.data, 1)\n\t\t\tres.names = append(res.names, prefix+\"ctrl+a\")\n\t\t\tres.lengths = append(res.lengths, 1+esclen)\n\n\t\tcase 1, 2:\n\t\t\t// A sequence.\n\t\t\tseqi := r.Intn(len(allseqs))\n\t\t\ts := allseqs[seqi]\n\t\t\tif strings.HasPrefix(s.name, \"alt+\") {\n\t\t\t\tesclen = 0\n\t\t\t\tprefix = \"\"\n\t\t\t\talt = 0\n\t\t\t}\n\t\t\tif alt == 1 {\n\t\t\t\tres.data = append(res.data, '\\x1b')\n\t\t\t}\n\t\t\tres.data = append(res.data, s.seq...)\n\t\t\tres.names = append(res.names, prefix+s.name)\n\t\t\tres.lengths = append(res.lengths, len(s.seq)+esclen)\n\t\t}\n\t}\n\treturn res\n}\n\n// TestDetectRandomSequencesLex checks that the lex-generated sequence\n// detector works over concatenations of random sequences.\nfunc TestDetectRandomSequencesLex(t *testing.T) {\n\trunTestDetectSequence(t, detectSequence)\n}\n\nfunc runTestDetectSequence(\n\tt *testing.T, detectSequence func(input []byte) (hasSeq bool, width int, msg Msg),\n) {\n\tfor i := 0; i < 10; i++ {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\ttd := genRandomData(func(s int64) { t.Logf(\"using random seed: %d\", s) }, 1000)\n\n\t\t\tt.Logf(\"%#v\", td)\n\n\t\t\t// tn is the event number in td.\n\t\t\t// i is the cursor in the input data.\n\t\t\t// w is the length of the last sequence detected.\n\t\t\tfor tn, i, w := 0, 0, 0; i < len(td.data); tn, i = tn+1, i+w {\n\t\t\t\thasSequence, width, msg := detectSequence(td.data[i:])\n\t\t\t\tif !hasSequence {\n\t\t\t\t\tt.Fatalf(\"at %d (ev %d): failed to find sequence\", i, tn)\n\t\t\t\t}\n\t\t\t\tif width != td.lengths[tn] {\n\t\t\t\t\tt.Errorf(\"at %d (ev %d): expected width %d, got %d\", i, tn, td.lengths[tn], width)\n\t\t\t\t}\n\t\t\t\tw = width\n\n\t\t\t\ts, ok := msg.(fmt.Stringer)\n\t\t\t\tif !ok {\n\t\t\t\t\tt.Errorf(\"at %d (ev %d): expected stringer event, got %T\", i, tn, msg)\n\t\t\t\t} else {\n\t\t\t\t\tif td.names[tn] != s.String() {\n\t\t\t\t\t\tt.Errorf(\"at %d (ev %d): expected event %q, got %q\", i, tn, td.names[tn], s.String())\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestDetectRandomSequencesMap checks that the map-based sequence\n// detector works over concatenations of random sequences.\nfunc TestDetectRandomSequencesMap(t *testing.T) {\n\trunTestDetectSequence(t, detectSequence)\n}\n\n// BenchmarkDetectSequenceMap benchmarks the map-based sequence\n// detector.\nfunc BenchmarkDetectSequenceMap(b *testing.B) {\n\ttd := genRandomDataWithSeed(123, 10000)\n\tfor i := 0; i < b.N; i++ {\n\t\tfor j, w := 0, 0; j < len(td.data); j += w {\n\t\t\t_, w, _ = detectSequence(td.data[j:])\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "key_windows.go",
          "type": "blob",
          "size": 8.17,
          "content": "//go:build windows\n// +build windows\n\npackage tea\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/erikgeiser/coninput\"\n\tlocalereader \"github.com/mattn/go-localereader\"\n\t\"golang.org/x/sys/windows\"\n)\n\nfunc readInputs(ctx context.Context, msgs chan<- Msg, input io.Reader) error {\n\tif coninReader, ok := input.(*conInputReader); ok {\n\t\treturn readConInputs(ctx, msgs, coninReader.conin)\n\t}\n\n\treturn readAnsiInputs(ctx, msgs, localereader.NewReader(input))\n}\n\nfunc readConInputs(ctx context.Context, msgsch chan<- Msg, con windows.Handle) error {\n\tvar ps coninput.ButtonState                 // keep track of previous mouse state\n\tvar ws coninput.WindowBufferSizeEventRecord // keep track of the last window size event\n\tfor {\n\t\tevents, err := coninput.ReadNConsoleInputs(con, 16)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"read coninput events: %w\", err)\n\t\t}\n\n\t\tfor _, event := range events {\n\t\t\tvar msgs []Msg\n\t\t\tswitch e := event.Unwrap().(type) {\n\t\t\tcase coninput.KeyEventRecord:\n\t\t\t\tif !e.KeyDown || e.VirtualKeyCode == coninput.VK_SHIFT {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfor i := 0; i < int(e.RepeatCount); i++ {\n\t\t\t\t\teventKeyType := keyType(e)\n\t\t\t\t\tvar runes []rune\n\n\t\t\t\t\t// Add the character only if the key type is an actual character and not a control sequence.\n\t\t\t\t\t// This mimics the behavior in readAnsiInputs where the character is also removed.\n\t\t\t\t\t// We don't need to handle KeySpace here. See the comment in keyType().\n\t\t\t\t\tif eventKeyType == KeyRunes {\n\t\t\t\t\t\trunes = []rune{e.Char}\n\t\t\t\t\t}\n\n\t\t\t\t\tmsgs = append(msgs, KeyMsg{\n\t\t\t\t\t\tType:  eventKeyType,\n\t\t\t\t\t\tRunes: runes,\n\t\t\t\t\t\tAlt:   e.ControlKeyState.Contains(coninput.LEFT_ALT_PRESSED | coninput.RIGHT_ALT_PRESSED),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\tcase coninput.WindowBufferSizeEventRecord:\n\t\t\t\tif e != ws {\n\t\t\t\t\tws = e\n\t\t\t\t\tmsgs = append(msgs, WindowSizeMsg{\n\t\t\t\t\t\tWidth:  int(e.Size.X),\n\t\t\t\t\t\tHeight: int(e.Size.Y),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\tcase coninput.MouseEventRecord:\n\t\t\t\tevent := mouseEvent(ps, e)\n\t\t\t\tif event.Type != MouseUnknown {\n\t\t\t\t\tmsgs = append(msgs, event)\n\t\t\t\t}\n\t\t\t\tps = e.ButtonState\n\t\t\tcase coninput.FocusEventRecord, coninput.MenuEventRecord:\n\t\t\t\t// ignore\n\t\t\tdefault: // unknown event\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Send all messages to the channel\n\t\t\tfor _, msg := range msgs {\n\t\t\t\tselect {\n\t\t\t\tcase msgsch <- msg:\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\terr := ctx.Err()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn fmt.Errorf(\"coninput context error: %w\", err)\n\t\t\t\t\t}\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc mouseEventButton(p, s coninput.ButtonState) (button MouseButton, action MouseAction) {\n\tbtn := p ^ s\n\taction = MouseActionPress\n\tif btn&s == 0 {\n\t\taction = MouseActionRelease\n\t}\n\n\tif btn == 0 {\n\t\tswitch {\n\t\tcase s&coninput.FROM_LEFT_1ST_BUTTON_PRESSED > 0:\n\t\t\tbutton = MouseButtonLeft\n\t\tcase s&coninput.FROM_LEFT_2ND_BUTTON_PRESSED > 0:\n\t\t\tbutton = MouseButtonMiddle\n\t\tcase s&coninput.RIGHTMOST_BUTTON_PRESSED > 0:\n\t\t\tbutton = MouseButtonRight\n\t\tcase s&coninput.FROM_LEFT_3RD_BUTTON_PRESSED > 0:\n\t\t\tbutton = MouseButtonBackward\n\t\tcase s&coninput.FROM_LEFT_4TH_BUTTON_PRESSED > 0:\n\t\t\tbutton = MouseButtonForward\n\t\t}\n\t\treturn\n\t}\n\n\tswitch {\n\tcase btn == coninput.FROM_LEFT_1ST_BUTTON_PRESSED: // left button\n\t\tbutton = MouseButtonLeft\n\tcase btn == coninput.RIGHTMOST_BUTTON_PRESSED: // right button\n\t\tbutton = MouseButtonRight\n\tcase btn == coninput.FROM_LEFT_2ND_BUTTON_PRESSED: // middle button\n\t\tbutton = MouseButtonMiddle\n\tcase btn == coninput.FROM_LEFT_3RD_BUTTON_PRESSED: // unknown (possibly mouse backward)\n\t\tbutton = MouseButtonBackward\n\tcase btn == coninput.FROM_LEFT_4TH_BUTTON_PRESSED: // unknown (possibly mouse forward)\n\t\tbutton = MouseButtonForward\n\t}\n\n\treturn button, action\n}\n\nfunc mouseEvent(p coninput.ButtonState, e coninput.MouseEventRecord) MouseMsg {\n\tev := MouseMsg{\n\t\tX:     int(e.MousePositon.X),\n\t\tY:     int(e.MousePositon.Y),\n\t\tAlt:   e.ControlKeyState.Contains(coninput.LEFT_ALT_PRESSED | coninput.RIGHT_ALT_PRESSED),\n\t\tCtrl:  e.ControlKeyState.Contains(coninput.LEFT_CTRL_PRESSED | coninput.RIGHT_CTRL_PRESSED),\n\t\tShift: e.ControlKeyState.Contains(coninput.SHIFT_PRESSED),\n\t}\n\tswitch e.EventFlags {\n\tcase coninput.CLICK, coninput.DOUBLE_CLICK:\n\t\tev.Button, ev.Action = mouseEventButton(p, e.ButtonState)\n\t\tif ev.Action == MouseActionRelease {\n\t\t\tev.Type = MouseRelease\n\t\t}\n\t\tswitch ev.Button {\n\t\tcase MouseButtonLeft:\n\t\t\tev.Type = MouseLeft\n\t\tcase MouseButtonMiddle:\n\t\t\tev.Type = MouseMiddle\n\t\tcase MouseButtonRight:\n\t\t\tev.Type = MouseRight\n\t\tcase MouseButtonBackward:\n\t\t\tev.Type = MouseBackward\n\t\tcase MouseButtonForward:\n\t\t\tev.Type = MouseForward\n\t\t}\n\tcase coninput.MOUSE_WHEELED:\n\t\tif e.WheelDirection > 0 {\n\t\t\tev.Button = MouseButtonWheelUp\n\t\t\tev.Type = MouseWheelUp\n\t\t} else {\n\t\t\tev.Button = MouseButtonWheelDown\n\t\t\tev.Type = MouseWheelDown\n\t\t}\n\tcase coninput.MOUSE_HWHEELED:\n\t\tif e.WheelDirection > 0 {\n\t\t\tev.Button = MouseButtonWheelRight\n\t\t\tev.Type = MouseWheelRight\n\t\t} else {\n\t\t\tev.Button = MouseButtonWheelLeft\n\t\t\tev.Type = MouseWheelLeft\n\t\t}\n\tcase coninput.MOUSE_MOVED:\n\t\tev.Button, _ = mouseEventButton(p, e.ButtonState)\n\t\tev.Action = MouseActionMotion\n\t\tev.Type = MouseMotion\n\t}\n\n\treturn ev\n}\n\nfunc keyType(e coninput.KeyEventRecord) KeyType {\n\tcode := e.VirtualKeyCode\n\n\tshiftPressed := e.ControlKeyState.Contains(coninput.SHIFT_PRESSED)\n\tctrlPressed := e.ControlKeyState.Contains(coninput.LEFT_CTRL_PRESSED | coninput.RIGHT_CTRL_PRESSED)\n\n\tswitch code {\n\tcase coninput.VK_RETURN:\n\t\treturn KeyEnter\n\tcase coninput.VK_BACK:\n\t\treturn KeyBackspace\n\tcase coninput.VK_TAB:\n\t\tif shiftPressed {\n\t\t\treturn KeyShiftTab\n\t\t}\n\t\treturn KeyTab\n\tcase coninput.VK_SPACE:\n\t\treturn KeyRunes // this could be KeySpace but on unix space also produces KeyRunes\n\tcase coninput.VK_ESCAPE:\n\t\treturn KeyEscape\n\tcase coninput.VK_UP:\n\t\tswitch {\n\t\tcase shiftPressed && ctrlPressed:\n\t\t\treturn KeyCtrlShiftUp\n\t\tcase shiftPressed:\n\t\t\treturn KeyShiftUp\n\t\tcase ctrlPressed:\n\t\t\treturn KeyCtrlUp\n\t\tdefault:\n\t\t\treturn KeyUp\n\t\t}\n\tcase coninput.VK_DOWN:\n\t\tswitch {\n\t\tcase shiftPressed && ctrlPressed:\n\t\t\treturn KeyCtrlShiftDown\n\t\tcase shiftPressed:\n\t\t\treturn KeyShiftDown\n\t\tcase ctrlPressed:\n\t\t\treturn KeyCtrlDown\n\t\tdefault:\n\t\t\treturn KeyDown\n\t\t}\n\tcase coninput.VK_RIGHT:\n\t\tswitch {\n\t\tcase shiftPressed && ctrlPressed:\n\t\t\treturn KeyCtrlShiftRight\n\t\tcase shiftPressed:\n\t\t\treturn KeyShiftRight\n\t\tcase ctrlPressed:\n\t\t\treturn KeyCtrlRight\n\t\tdefault:\n\t\t\treturn KeyRight\n\t\t}\n\tcase coninput.VK_LEFT:\n\t\tswitch {\n\t\tcase shiftPressed && ctrlPressed:\n\t\t\treturn KeyCtrlShiftLeft\n\t\tcase shiftPressed:\n\t\t\treturn KeyShiftLeft\n\t\tcase ctrlPressed:\n\t\t\treturn KeyCtrlLeft\n\t\tdefault:\n\t\t\treturn KeyLeft\n\t\t}\n\tcase coninput.VK_HOME:\n\t\tswitch {\n\t\tcase shiftPressed && ctrlPressed:\n\t\t\treturn KeyCtrlShiftHome\n\t\tcase shiftPressed:\n\t\t\treturn KeyShiftHome\n\t\tcase ctrlPressed:\n\t\t\treturn KeyCtrlHome\n\t\tdefault:\n\t\t\treturn KeyHome\n\t\t}\n\tcase coninput.VK_END:\n\t\tswitch {\n\t\tcase shiftPressed && ctrlPressed:\n\t\t\treturn KeyCtrlShiftEnd\n\t\tcase shiftPressed:\n\t\t\treturn KeyShiftEnd\n\t\tcase ctrlPressed:\n\t\t\treturn KeyCtrlEnd\n\t\tdefault:\n\t\t\treturn KeyEnd\n\t\t}\n\tcase coninput.VK_PRIOR:\n\t\treturn KeyPgUp\n\tcase coninput.VK_NEXT:\n\t\treturn KeyPgDown\n\tcase coninput.VK_DELETE:\n\t\treturn KeyDelete\n\tdefault:\n\t\tif e.ControlKeyState&(coninput.LEFT_CTRL_PRESSED|coninput.RIGHT_CTRL_PRESSED) == 0 {\n\t\t\treturn KeyRunes\n\t\t}\n\n\t\tswitch e.Char {\n\t\tcase '@':\n\t\t\treturn KeyCtrlAt\n\t\tcase '\\x01':\n\t\t\treturn KeyCtrlA\n\t\tcase '\\x02':\n\t\t\treturn KeyCtrlB\n\t\tcase '\\x03':\n\t\t\treturn KeyCtrlC\n\t\tcase '\\x04':\n\t\t\treturn KeyCtrlD\n\t\tcase '\\x05':\n\t\t\treturn KeyCtrlE\n\t\tcase '\\x06':\n\t\t\treturn KeyCtrlF\n\t\tcase '\\a':\n\t\t\treturn KeyCtrlG\n\t\tcase '\\b':\n\t\t\treturn KeyCtrlH\n\t\tcase '\\t':\n\t\t\treturn KeyCtrlI\n\t\tcase '\\n':\n\t\t\treturn KeyCtrlJ\n\t\tcase '\\v':\n\t\t\treturn KeyCtrlK\n\t\tcase '\\f':\n\t\t\treturn KeyCtrlL\n\t\tcase '\\r':\n\t\t\treturn KeyCtrlM\n\t\tcase '\\x0e':\n\t\t\treturn KeyCtrlN\n\t\tcase '\\x0f':\n\t\t\treturn KeyCtrlO\n\t\tcase '\\x10':\n\t\t\treturn KeyCtrlP\n\t\tcase '\\x11':\n\t\t\treturn KeyCtrlQ\n\t\tcase '\\x12':\n\t\t\treturn KeyCtrlR\n\t\tcase '\\x13':\n\t\t\treturn KeyCtrlS\n\t\tcase '\\x14':\n\t\t\treturn KeyCtrlT\n\t\tcase '\\x15':\n\t\t\treturn KeyCtrlU\n\t\tcase '\\x16':\n\t\t\treturn KeyCtrlV\n\t\tcase '\\x17':\n\t\t\treturn KeyCtrlW\n\t\tcase '\\x18':\n\t\t\treturn KeyCtrlX\n\t\tcase '\\x19':\n\t\t\treturn KeyCtrlY\n\t\tcase '\\x1a':\n\t\t\treturn KeyCtrlZ\n\t\tcase '\\x1b':\n\t\t\treturn KeyCtrlCloseBracket\n\t\tcase '\\x1c':\n\t\t\treturn KeyCtrlBackslash\n\t\tcase '\\x1f':\n\t\t\treturn KeyCtrlUnderscore\n\t\t}\n\n\t\tswitch code {\n\t\tcase coninput.VK_OEM_4:\n\t\t\treturn KeyCtrlOpenBracket\n\t\t}\n\n\t\treturn KeyRunes\n\t}\n}\n"
        },
        {
          "name": "logging.go",
          "type": "blob",
          "size": 1.36,
          "content": "package tea\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"unicode\"\n)\n\n// LogToFile sets up default logging to log to a file. This is helpful as we\n// can't print to the terminal since our TUI is occupying it. If the file\n// doesn't exist it will be created.\n//\n// Don't forget to close the file when you're done with it.\n//\n//\t  f, err := LogToFile(\"debug.log\", \"debug\")\n//\t  if err != nil {\n//\t\t\tfmt.Println(\"fatal:\", err)\n//\t\t\tos.Exit(1)\n//\t  }\n//\t  defer f.Close()\nfunc LogToFile(path string, prefix string) (*os.File, error) {\n\treturn LogToFileWith(path, prefix, log.Default())\n}\n\n// LogOptionsSetter is an interface implemented by stdlib's log and charm's log\n// libraries.\ntype LogOptionsSetter interface {\n\tSetOutput(io.Writer)\n\tSetPrefix(string)\n}\n\n// LogToFileWith does allows to call LogToFile with a custom LogOptionsSetter.\nfunc LogToFileWith(path string, prefix string, log LogOptionsSetter) (*os.File, error) {\n\tf, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0o600) //nolint:gomnd\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error opening file for logging: %w\", err)\n\t}\n\tlog.SetOutput(f)\n\n\t// Add a space after the prefix if a prefix is being specified and it\n\t// doesn't already have a trailing space.\n\tif len(prefix) > 0 {\n\t\tfinalChar := prefix[len(prefix)-1]\n\t\tif !unicode.IsSpace(rune(finalChar)) {\n\t\t\tprefix += \" \"\n\t\t}\n\t}\n\tlog.SetPrefix(prefix)\n\n\treturn f, nil\n}\n"
        },
        {
          "name": "logging_test.go",
          "type": "blob",
          "size": 0.5,
          "content": "package tea\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n)\n\nfunc TestLogToFile(t *testing.T) {\n\tpath := filepath.Join(t.TempDir(), \"log.txt\")\n\tprefix := \"logprefix\"\n\tf, err := LogToFile(path, prefix)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tlog.SetFlags(log.Lmsgprefix)\n\tlog.Println(\"some test log\")\n\tif err := f.Close(); err != nil {\n\t\tt.Error(err)\n\t}\n\tout, err := os.ReadFile(path)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif string(out) != prefix+\" some test log\\n\" {\n\t\tt.Fatalf(\"wrong log msg: %q\", string(out))\n\t}\n}\n"
        },
        {
          "name": "mouse.go",
          "type": "blob",
          "size": 7.72,
          "content": "package tea\n\nimport \"strconv\"\n\n// MouseMsg contains information about a mouse event and are sent to a programs\n// update function when mouse activity occurs. Note that the mouse must first\n// be enabled in order for the mouse events to be received.\ntype MouseMsg MouseEvent\n\n// String returns a string representation of a mouse event.\nfunc (m MouseMsg) String() string {\n\treturn MouseEvent(m).String()\n}\n\n// MouseEvent represents a mouse event, which could be a click, a scroll wheel\n// movement, a cursor movement, or a combination.\ntype MouseEvent struct {\n\tX      int\n\tY      int\n\tShift  bool\n\tAlt    bool\n\tCtrl   bool\n\tAction MouseAction\n\tButton MouseButton\n\n\t// Deprecated: Use MouseAction & MouseButton instead.\n\tType MouseEventType\n}\n\n// IsWheel returns true if the mouse event is a wheel event.\nfunc (m MouseEvent) IsWheel() bool {\n\treturn m.Button == MouseButtonWheelUp || m.Button == MouseButtonWheelDown ||\n\t\tm.Button == MouseButtonWheelLeft || m.Button == MouseButtonWheelRight\n}\n\n// String returns a string representation of a mouse event.\nfunc (m MouseEvent) String() (s string) {\n\tif m.Ctrl {\n\t\ts += \"ctrl+\"\n\t}\n\tif m.Alt {\n\t\ts += \"alt+\"\n\t}\n\tif m.Shift {\n\t\ts += \"shift+\"\n\t}\n\n\tif m.Button == MouseButtonNone { //nolint:nestif\n\t\tif m.Action == MouseActionMotion || m.Action == MouseActionRelease {\n\t\t\ts += mouseActions[m.Action]\n\t\t} else {\n\t\t\ts += \"unknown\"\n\t\t}\n\t} else if m.IsWheel() {\n\t\ts += mouseButtons[m.Button]\n\t} else {\n\t\tbtn := mouseButtons[m.Button]\n\t\tif btn != \"\" {\n\t\t\ts += btn\n\t\t}\n\t\tact := mouseActions[m.Action]\n\t\tif act != \"\" {\n\t\t\ts += \" \" + act\n\t\t}\n\t}\n\n\treturn s\n}\n\n// MouseAction represents the action that occurred during a mouse event.\ntype MouseAction int\n\n// Mouse event actions.\nconst (\n\tMouseActionPress MouseAction = iota\n\tMouseActionRelease\n\tMouseActionMotion\n)\n\nvar mouseActions = map[MouseAction]string{\n\tMouseActionPress:   \"press\",\n\tMouseActionRelease: \"release\",\n\tMouseActionMotion:  \"motion\",\n}\n\n// MouseButton represents the button that was pressed during a mouse event.\ntype MouseButton int\n\n// Mouse event buttons\n//\n// This is based on X11 mouse button codes.\n//\n//\t1 = left button\n//\t2 = middle button (pressing the scroll wheel)\n//\t3 = right button\n//\t4 = turn scroll wheel up\n//\t5 = turn scroll wheel down\n//\t6 = push scroll wheel left\n//\t7 = push scroll wheel right\n//\t8 = 4th button (aka browser backward button)\n//\t9 = 5th button (aka browser forward button)\n//\t10\n//\t11\n//\n// Other buttons are not supported.\nconst (\n\tMouseButtonNone MouseButton = iota\n\tMouseButtonLeft\n\tMouseButtonMiddle\n\tMouseButtonRight\n\tMouseButtonWheelUp\n\tMouseButtonWheelDown\n\tMouseButtonWheelLeft\n\tMouseButtonWheelRight\n\tMouseButtonBackward\n\tMouseButtonForward\n\tMouseButton10\n\tMouseButton11\n)\n\nvar mouseButtons = map[MouseButton]string{\n\tMouseButtonNone:       \"none\",\n\tMouseButtonLeft:       \"left\",\n\tMouseButtonMiddle:     \"middle\",\n\tMouseButtonRight:      \"right\",\n\tMouseButtonWheelUp:    \"wheel up\",\n\tMouseButtonWheelDown:  \"wheel down\",\n\tMouseButtonWheelLeft:  \"wheel left\",\n\tMouseButtonWheelRight: \"wheel right\",\n\tMouseButtonBackward:   \"backward\",\n\tMouseButtonForward:    \"forward\",\n\tMouseButton10:         \"button 10\",\n\tMouseButton11:         \"button 11\",\n}\n\n// MouseEventType indicates the type of mouse event occurring.\n//\n// Deprecated: Use MouseAction & MouseButton instead.\ntype MouseEventType int\n\n// Mouse event types.\n//\n// Deprecated: Use MouseAction & MouseButton instead.\nconst (\n\tMouseUnknown MouseEventType = iota\n\tMouseLeft\n\tMouseRight\n\tMouseMiddle\n\tMouseRelease // mouse button release (X10 only)\n\tMouseWheelUp\n\tMouseWheelDown\n\tMouseWheelLeft\n\tMouseWheelRight\n\tMouseBackward\n\tMouseForward\n\tMouseMotion\n)\n\n// Parse SGR-encoded mouse events; SGR extended mouse events. SGR mouse events\n// look like:\n//\n//\tESC [ < Cb ; Cx ; Cy (M or m)\n//\n// where:\n//\n//\tCb is the encoded button code\n//\tCx is the x-coordinate of the mouse\n//\tCy is the y-coordinate of the mouse\n//\tM is for button press, m is for button release\n//\n// https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Extended-coordinates\nfunc parseSGRMouseEvent(buf []byte) MouseEvent {\n\tstr := string(buf[3:])\n\tmatches := mouseSGRRegex.FindStringSubmatch(str)\n\tif len(matches) != 5 { //nolint:gomnd\n\t\t// Unreachable, we already checked the regex in `detectOneMsg`.\n\t\tpanic(\"invalid mouse event\")\n\t}\n\n\tb, _ := strconv.Atoi(matches[1])\n\tpx := matches[2]\n\tpy := matches[3]\n\trelease := matches[4] == \"m\"\n\tm := parseMouseButton(b, true)\n\n\t// Wheel buttons don't have release events\n\t// Motion can be reported as a release event in some terminals (Windows Terminal)\n\tif m.Action != MouseActionMotion && !m.IsWheel() && release {\n\t\tm.Action = MouseActionRelease\n\t\tm.Type = MouseRelease\n\t}\n\n\tx, _ := strconv.Atoi(px)\n\ty, _ := strconv.Atoi(py)\n\n\t// (1,1) is the upper left. We subtract 1 to normalize it to (0,0).\n\tm.X = x - 1\n\tm.Y = y - 1\n\n\treturn m\n}\n\nconst x10MouseByteOffset = 32\n\n// Parse X10-encoded mouse events; the simplest kind. The last release of X10\n// was December 1986, by the way. The original X10 mouse protocol limits the Cx\n// and Cy coordinates to 223 (=255-032).\n//\n// X10 mouse events look like:\n//\n//\tESC [M Cb Cx Cy\n//\n// See: http://www.xfree86.org/current/ctlseqs.html#Mouse%20Tracking\nfunc parseX10MouseEvent(buf []byte) MouseEvent {\n\tv := buf[3:6]\n\tm := parseMouseButton(int(v[0]), false)\n\n\t// (1,1) is the upper left. We subtract 1 to normalize it to (0,0).\n\tm.X = int(v[1]) - x10MouseByteOffset - 1\n\tm.Y = int(v[2]) - x10MouseByteOffset - 1\n\n\treturn m\n}\n\n// See: https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Extended-coordinates\nfunc parseMouseButton(b int, isSGR bool) MouseEvent {\n\tvar m MouseEvent\n\te := b\n\tif !isSGR {\n\t\te -= x10MouseByteOffset\n\t}\n\n\tconst (\n\t\tbitShift  = 0b0000_0100\n\t\tbitAlt    = 0b0000_1000\n\t\tbitCtrl   = 0b0001_0000\n\t\tbitMotion = 0b0010_0000\n\t\tbitWheel  = 0b0100_0000\n\t\tbitAdd    = 0b1000_0000 // additional buttons 8-11\n\n\t\tbitsMask = 0b0000_0011\n\t)\n\n\tif e&bitAdd != 0 {\n\t\tm.Button = MouseButtonBackward + MouseButton(e&bitsMask)\n\t} else if e&bitWheel != 0 {\n\t\tm.Button = MouseButtonWheelUp + MouseButton(e&bitsMask)\n\t} else {\n\t\tm.Button = MouseButtonLeft + MouseButton(e&bitsMask)\n\t\t// X10 reports a button release as 0b0000_0011 (3)\n\t\tif e&bitsMask == bitsMask {\n\t\t\tm.Action = MouseActionRelease\n\t\t\tm.Button = MouseButtonNone\n\t\t}\n\t}\n\n\t// Motion bit doesn't get reported for wheel events.\n\tif e&bitMotion != 0 && !m.IsWheel() {\n\t\tm.Action = MouseActionMotion\n\t}\n\n\t// Modifiers\n\tm.Alt = e&bitAlt != 0\n\tm.Ctrl = e&bitCtrl != 0\n\tm.Shift = e&bitShift != 0\n\n\t// backward compatibility\n\tswitch {\n\tcase m.Button == MouseButtonLeft && m.Action == MouseActionPress:\n\t\tm.Type = MouseLeft\n\tcase m.Button == MouseButtonMiddle && m.Action == MouseActionPress:\n\t\tm.Type = MouseMiddle\n\tcase m.Button == MouseButtonRight && m.Action == MouseActionPress:\n\t\tm.Type = MouseRight\n\tcase m.Button == MouseButtonNone && m.Action == MouseActionRelease:\n\t\tm.Type = MouseRelease\n\tcase m.Button == MouseButtonWheelUp && m.Action == MouseActionPress:\n\t\tm.Type = MouseWheelUp\n\tcase m.Button == MouseButtonWheelDown && m.Action == MouseActionPress:\n\t\tm.Type = MouseWheelDown\n\tcase m.Button == MouseButtonWheelLeft && m.Action == MouseActionPress:\n\t\tm.Type = MouseWheelLeft\n\tcase m.Button == MouseButtonWheelRight && m.Action == MouseActionPress:\n\t\tm.Type = MouseWheelRight\n\tcase m.Button == MouseButtonBackward && m.Action == MouseActionPress:\n\t\tm.Type = MouseBackward\n\tcase m.Button == MouseButtonForward && m.Action == MouseActionPress:\n\t\tm.Type = MouseForward\n\tcase m.Action == MouseActionMotion:\n\t\tm.Type = MouseMotion\n\t\tswitch m.Button { //nolint:exhaustive\n\t\tcase MouseButtonLeft:\n\t\t\tm.Type = MouseLeft\n\t\tcase MouseButtonMiddle:\n\t\t\tm.Type = MouseMiddle\n\t\tcase MouseButtonRight:\n\t\t\tm.Type = MouseRight\n\t\tcase MouseButtonBackward:\n\t\t\tm.Type = MouseBackward\n\t\tcase MouseButtonForward:\n\t\t\tm.Type = MouseForward\n\t\t}\n\tdefault:\n\t\tm.Type = MouseUnknown\n\t}\n\n\treturn m\n}\n"
        },
        {
          "name": "mouse_test.go",
          "type": "blob",
          "size": 17.7,
          "content": "package tea\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestMouseEvent_String(t *testing.T) {\n\ttt := []struct {\n\t\tname     string\n\t\tevent    MouseEvent\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"unknown\",\n\t\t\tevent: MouseEvent{\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonNone,\n\t\t\t\tType:   MouseUnknown,\n\t\t\t},\n\t\t\texpected: \"unknown\",\n\t\t},\n\t\t{\n\t\t\tname: \"left\",\n\t\t\tevent: MouseEvent{\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonLeft,\n\t\t\t\tType:   MouseLeft,\n\t\t\t},\n\t\t\texpected: \"left press\",\n\t\t},\n\t\t{\n\t\t\tname: \"right\",\n\t\t\tevent: MouseEvent{\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonRight,\n\t\t\t\tType:   MouseRight,\n\t\t\t},\n\t\t\texpected: \"right press\",\n\t\t},\n\t\t{\n\t\t\tname: \"middle\",\n\t\t\tevent: MouseEvent{\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonMiddle,\n\t\t\t\tType:   MouseMiddle,\n\t\t\t},\n\t\t\texpected: \"middle press\",\n\t\t},\n\t\t{\n\t\t\tname: \"release\",\n\t\t\tevent: MouseEvent{\n\t\t\t\tAction: MouseActionRelease,\n\t\t\t\tButton: MouseButtonNone,\n\t\t\t\tType:   MouseRelease,\n\t\t\t},\n\t\t\texpected: \"release\",\n\t\t},\n\t\t{\n\t\t\tname: \"wheel up\",\n\t\t\tevent: MouseEvent{\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonWheelUp,\n\t\t\t\tType:   MouseWheelUp,\n\t\t\t},\n\t\t\texpected: \"wheel up\",\n\t\t},\n\t\t{\n\t\t\tname: \"wheel down\",\n\t\t\tevent: MouseEvent{\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonWheelDown,\n\t\t\t\tType:   MouseWheelDown,\n\t\t\t},\n\t\t\texpected: \"wheel down\",\n\t\t},\n\t\t{\n\t\t\tname: \"wheel left\",\n\t\t\tevent: MouseEvent{\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonWheelLeft,\n\t\t\t\tType:   MouseWheelLeft,\n\t\t\t},\n\t\t\texpected: \"wheel left\",\n\t\t},\n\t\t{\n\t\t\tname: \"wheel right\",\n\t\t\tevent: MouseEvent{\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonWheelRight,\n\t\t\t\tType:   MouseWheelRight,\n\t\t\t},\n\t\t\texpected: \"wheel right\",\n\t\t},\n\t\t{\n\t\t\tname: \"motion\",\n\t\t\tevent: MouseEvent{\n\t\t\t\tAction: MouseActionMotion,\n\t\t\t\tButton: MouseButtonNone,\n\t\t\t\tType:   MouseMotion,\n\t\t\t},\n\t\t\texpected: \"motion\",\n\t\t},\n\t\t{\n\t\t\tname: \"shift+left release\",\n\t\t\tevent: MouseEvent{\n\t\t\t\tType:   MouseLeft,\n\t\t\t\tAction: MouseActionRelease,\n\t\t\t\tButton: MouseButtonLeft,\n\t\t\t\tShift:  true,\n\t\t\t},\n\t\t\texpected: \"shift+left release\",\n\t\t},\n\t\t{\n\t\t\tname: \"shift+left\",\n\t\t\tevent: MouseEvent{\n\t\t\t\tType:   MouseLeft,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonLeft,\n\t\t\t\tShift:  true,\n\t\t\t},\n\t\t\texpected: \"shift+left press\",\n\t\t},\n\t\t{\n\t\t\tname: \"ctrl+shift+left\",\n\t\t\tevent: MouseEvent{\n\t\t\t\tType:   MouseLeft,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonLeft,\n\t\t\t\tShift:  true,\n\t\t\t\tCtrl:   true,\n\t\t\t},\n\t\t\texpected: \"ctrl+shift+left press\",\n\t\t},\n\t\t{\n\t\t\tname: \"alt+left\",\n\t\t\tevent: MouseEvent{\n\t\t\t\tType:   MouseLeft,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonLeft,\n\t\t\t\tAlt:    true,\n\t\t\t},\n\t\t\texpected: \"alt+left press\",\n\t\t},\n\t\t{\n\t\t\tname: \"ctrl+left\",\n\t\t\tevent: MouseEvent{\n\t\t\t\tType:   MouseLeft,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonLeft,\n\t\t\t\tCtrl:   true,\n\t\t\t},\n\t\t\texpected: \"ctrl+left press\",\n\t\t},\n\t\t{\n\t\t\tname: \"ctrl+alt+left\",\n\t\t\tevent: MouseEvent{\n\t\t\t\tType:   MouseLeft,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonLeft,\n\t\t\t\tAlt:    true,\n\t\t\t\tCtrl:   true,\n\t\t\t},\n\t\t\texpected: \"ctrl+alt+left press\",\n\t\t},\n\t\t{\n\t\t\tname: \"ctrl+alt+shift+left\",\n\t\t\tevent: MouseEvent{\n\t\t\t\tType:   MouseLeft,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonLeft,\n\t\t\t\tAlt:    true,\n\t\t\t\tCtrl:   true,\n\t\t\t\tShift:  true,\n\t\t\t},\n\t\t\texpected: \"ctrl+alt+shift+left press\",\n\t\t},\n\t\t{\n\t\t\tname: \"ignore coordinates\",\n\t\t\tevent: MouseEvent{\n\t\t\t\tX:      100,\n\t\t\t\tY:      200,\n\t\t\t\tType:   MouseLeft,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonLeft,\n\t\t\t},\n\t\t\texpected: \"left press\",\n\t\t},\n\t\t{\n\t\t\tname: \"broken type\",\n\t\t\tevent: MouseEvent{\n\t\t\t\tType:   MouseEventType(-100),\n\t\t\t\tAction: MouseAction(-110),\n\t\t\t\tButton: MouseButton(-120),\n\t\t\t},\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor i := range tt {\n\t\ttc := tt[i]\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual := tc.event.String()\n\n\t\t\tif tc.expected != actual {\n\t\t\t\tt.Fatalf(\"expected %q but got %q\",\n\t\t\t\t\ttc.expected,\n\t\t\t\t\tactual,\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseX10MouseEvent(t *testing.T) {\n\tencode := func(b byte, x, y int) []byte {\n\t\treturn []byte{\n\t\t\t'\\x1b',\n\t\t\t'[',\n\t\t\t'M',\n\t\t\tbyte(32) + b,\n\t\t\tbyte(x + 32 + 1),\n\t\t\tbyte(y + 32 + 1),\n\t\t}\n\t}\n\n\ttt := []struct {\n\t\tname     string\n\t\tbuf      []byte\n\t\texpected MouseEvent\n\t}{\n\t\t// Position.\n\t\t{\n\t\t\tname: \"zero position\",\n\t\t\tbuf:  encode(0b0000_0000, 0, 0),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      0,\n\t\t\t\tY:      0,\n\t\t\t\tType:   MouseLeft,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonLeft,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"max position\",\n\t\t\tbuf:  encode(0b0000_0000, 222, 222), // Because 255 (max int8) - 32 - 1.\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      222,\n\t\t\t\tY:      222,\n\t\t\t\tType:   MouseLeft,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonLeft,\n\t\t\t},\n\t\t},\n\t\t// Simple.\n\t\t{\n\t\t\tname: \"left\",\n\t\t\tbuf:  encode(0b0000_0000, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseLeft,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonLeft,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"left in motion\",\n\t\t\tbuf:  encode(0b0010_0000, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseLeft,\n\t\t\t\tAction: MouseActionMotion,\n\t\t\t\tButton: MouseButtonLeft,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"middle\",\n\t\t\tbuf:  encode(0b0000_0001, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseMiddle,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonMiddle,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"middle in motion\",\n\t\t\tbuf:  encode(0b0010_0001, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseMiddle,\n\t\t\t\tAction: MouseActionMotion,\n\t\t\t\tButton: MouseButtonMiddle,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"right\",\n\t\t\tbuf:  encode(0b0000_0010, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseRight,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonRight,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"right in motion\",\n\t\t\tbuf:  encode(0b0010_0010, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseRight,\n\t\t\t\tAction: MouseActionMotion,\n\t\t\t\tButton: MouseButtonRight,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"motion\",\n\t\t\tbuf:  encode(0b0010_0011, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseMotion,\n\t\t\t\tAction: MouseActionMotion,\n\t\t\t\tButton: MouseButtonNone,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"wheel up\",\n\t\t\tbuf:  encode(0b0100_0000, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseWheelUp,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonWheelUp,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"wheel down\",\n\t\t\tbuf:  encode(0b0100_0001, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseWheelDown,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonWheelDown,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"wheel left\",\n\t\t\tbuf:  encode(0b0100_0010, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseWheelLeft,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonWheelLeft,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"wheel right\",\n\t\t\tbuf:  encode(0b0100_0011, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseWheelRight,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonWheelRight,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"release\",\n\t\t\tbuf:  encode(0b0000_0011, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseRelease,\n\t\t\t\tAction: MouseActionRelease,\n\t\t\t\tButton: MouseButtonNone,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"backward\",\n\t\t\tbuf:  encode(0b1000_0000, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseBackward,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonBackward,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"forward\",\n\t\t\tbuf:  encode(0b1000_0001, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseForward,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonForward,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"button 10\",\n\t\t\tbuf:  encode(0b1000_0010, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseUnknown,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButton10,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"button 11\",\n\t\t\tbuf:  encode(0b1000_0011, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseUnknown,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButton11,\n\t\t\t},\n\t\t},\n\t\t// Combinations.\n\t\t{\n\t\t\tname: \"alt+right\",\n\t\t\tbuf:  encode(0b0000_1010, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tAlt:    true,\n\t\t\t\tType:   MouseRight,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonRight,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ctrl+right\",\n\t\t\tbuf:  encode(0b0001_0010, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tCtrl:   true,\n\t\t\t\tType:   MouseRight,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonRight,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"left in motion\",\n\t\t\tbuf:  encode(0b0010_0000, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tAlt:    false,\n\t\t\t\tType:   MouseLeft,\n\t\t\t\tAction: MouseActionMotion,\n\t\t\t\tButton: MouseButtonLeft,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"alt+right in motion\",\n\t\t\tbuf:  encode(0b0010_1010, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tAlt:    true,\n\t\t\t\tType:   MouseRight,\n\t\t\t\tAction: MouseActionMotion,\n\t\t\t\tButton: MouseButtonRight,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ctrl+right in motion\",\n\t\t\tbuf:  encode(0b0011_0010, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tCtrl:   true,\n\t\t\t\tType:   MouseRight,\n\t\t\t\tAction: MouseActionMotion,\n\t\t\t\tButton: MouseButtonRight,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ctrl+alt+right\",\n\t\t\tbuf:  encode(0b0001_1010, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tAlt:    true,\n\t\t\t\tCtrl:   true,\n\t\t\t\tType:   MouseRight,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonRight,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ctrl+wheel up\",\n\t\t\tbuf:  encode(0b0101_0000, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tCtrl:   true,\n\t\t\t\tType:   MouseWheelUp,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonWheelUp,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"alt+wheel down\",\n\t\t\tbuf:  encode(0b0100_1001, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tAlt:    true,\n\t\t\t\tType:   MouseWheelDown,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonWheelDown,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ctrl+alt+wheel down\",\n\t\t\tbuf:  encode(0b0101_1001, 32, 16),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tAlt:    true,\n\t\t\t\tCtrl:   true,\n\t\t\t\tType:   MouseWheelDown,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonWheelDown,\n\t\t\t},\n\t\t},\n\t\t// Overflow position.\n\t\t{\n\t\t\tname: \"overflow position\",\n\t\t\tbuf:  encode(0b0010_0000, 250, 223), // Because 255 (max int8) - 32 - 1.\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      -6,\n\t\t\t\tY:      -33,\n\t\t\t\tType:   MouseLeft,\n\t\t\t\tAction: MouseActionMotion,\n\t\t\t\tButton: MouseButtonLeft,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor i := range tt {\n\t\ttc := tt[i]\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual := parseX10MouseEvent(tc.buf)\n\n\t\t\tif tc.expected != actual {\n\t\t\t\tt.Fatalf(\"expected %#v but got %#v\",\n\t\t\t\t\ttc.expected,\n\t\t\t\t\tactual,\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// func TestParseX10MouseEvent_error(t *testing.T) {\n// \ttt := []struct {\n// \t\tname string\n// \t\tbuf  []byte\n// \t}{\n// \t\t{\n// \t\t\tname: \"empty buf\",\n// \t\t\tbuf:  nil,\n// \t\t},\n// \t\t{\n// \t\t\tname: \"wrong high bit\",\n// \t\t\tbuf:  []byte(\"\\x1a[M@A1\"),\n// \t\t},\n// \t\t{\n// \t\t\tname: \"short buf\",\n// \t\t\tbuf:  []byte(\"\\x1b[M@A\"),\n// \t\t},\n// \t\t{\n// \t\t\tname: \"long buf\",\n// \t\t\tbuf:  []byte(\"\\x1b[M@A11\"),\n// \t\t},\n// \t}\n//\n// \tfor i := range tt {\n// \t\ttc := tt[i]\n//\n// \t\tt.Run(tc.name, func(t *testing.T) {\n// \t\t\t_, err := parseX10MouseEvent(tc.buf)\n//\n// \t\t\tif err == nil {\n// \t\t\t\tt.Fatalf(\"expected error but got nil\")\n// \t\t\t}\n// \t\t})\n// \t}\n// }\n\nfunc TestParseSGRMouseEvent(t *testing.T) {\n\tencode := func(b, x, y int, r bool) []byte {\n\t\tre := 'M'\n\t\tif r {\n\t\t\tre = 'm'\n\t\t}\n\t\treturn []byte(fmt.Sprintf(\"\\x1b[<%d;%d;%d%c\", b, x+1, y+1, re))\n\t}\n\n\ttt := []struct {\n\t\tname     string\n\t\tbuf      []byte\n\t\texpected MouseEvent\n\t}{\n\t\t// Position.\n\t\t{\n\t\t\tname: \"zero position\",\n\t\t\tbuf:  encode(0, 0, 0, false),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      0,\n\t\t\t\tY:      0,\n\t\t\t\tType:   MouseLeft,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonLeft,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"225 position\",\n\t\t\tbuf:  encode(0, 225, 225, false),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      225,\n\t\t\t\tY:      225,\n\t\t\t\tType:   MouseLeft,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonLeft,\n\t\t\t},\n\t\t},\n\t\t// Simple.\n\t\t{\n\t\t\tname: \"left\",\n\t\t\tbuf:  encode(0, 32, 16, false),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseLeft,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonLeft,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"left in motion\",\n\t\t\tbuf:  encode(32, 32, 16, false),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseLeft,\n\t\t\t\tAction: MouseActionMotion,\n\t\t\t\tButton: MouseButtonLeft,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"left release\",\n\t\t\tbuf:  encode(0, 32, 16, true),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseRelease,\n\t\t\t\tAction: MouseActionRelease,\n\t\t\t\tButton: MouseButtonLeft,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"middle\",\n\t\t\tbuf:  encode(1, 32, 16, false),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseMiddle,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonMiddle,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"middle in motion\",\n\t\t\tbuf:  encode(33, 32, 16, false),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseMiddle,\n\t\t\t\tAction: MouseActionMotion,\n\t\t\t\tButton: MouseButtonMiddle,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"middle release\",\n\t\t\tbuf:  encode(1, 32, 16, true),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseRelease,\n\t\t\t\tAction: MouseActionRelease,\n\t\t\t\tButton: MouseButtonMiddle,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"right\",\n\t\t\tbuf:  encode(2, 32, 16, false),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseRight,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonRight,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"right release\",\n\t\t\tbuf:  encode(2, 32, 16, true),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseRelease,\n\t\t\t\tAction: MouseActionRelease,\n\t\t\t\tButton: MouseButtonRight,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"motion\",\n\t\t\tbuf:  encode(35, 32, 16, false),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseMotion,\n\t\t\t\tAction: MouseActionMotion,\n\t\t\t\tButton: MouseButtonNone,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"wheel up\",\n\t\t\tbuf:  encode(64, 32, 16, false),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseWheelUp,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonWheelUp,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"wheel down\",\n\t\t\tbuf:  encode(65, 32, 16, false),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseWheelDown,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonWheelDown,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"wheel left\",\n\t\t\tbuf:  encode(66, 32, 16, false),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseWheelLeft,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonWheelLeft,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"wheel right\",\n\t\t\tbuf:  encode(67, 32, 16, false),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseWheelRight,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonWheelRight,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"backward\",\n\t\t\tbuf:  encode(128, 32, 16, false),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseBackward,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonBackward,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"backward in motion\",\n\t\t\tbuf:  encode(160, 32, 16, false),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseBackward,\n\t\t\t\tAction: MouseActionMotion,\n\t\t\t\tButton: MouseButtonBackward,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"forward\",\n\t\t\tbuf:  encode(129, 32, 16, false),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseForward,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonForward,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"forward in motion\",\n\t\t\tbuf:  encode(161, 32, 16, false),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tType:   MouseForward,\n\t\t\t\tAction: MouseActionMotion,\n\t\t\t\tButton: MouseButtonForward,\n\t\t\t},\n\t\t},\n\t\t// Combinations.\n\t\t{\n\t\t\tname: \"alt+right\",\n\t\t\tbuf:  encode(10, 32, 16, false),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tAlt:    true,\n\t\t\t\tType:   MouseRight,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonRight,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ctrl+right\",\n\t\t\tbuf:  encode(18, 32, 16, false),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tCtrl:   true,\n\t\t\t\tType:   MouseRight,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonRight,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ctrl+alt+right\",\n\t\t\tbuf:  encode(26, 32, 16, false),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tAlt:    true,\n\t\t\t\tCtrl:   true,\n\t\t\t\tType:   MouseRight,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonRight,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"alt+wheel press\",\n\t\t\tbuf:  encode(73, 32, 16, false),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tAlt:    true,\n\t\t\t\tType:   MouseWheelDown,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonWheelDown,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ctrl+wheel press\",\n\t\t\tbuf:  encode(81, 32, 16, false),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tCtrl:   true,\n\t\t\t\tType:   MouseWheelDown,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonWheelDown,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ctrl+alt+wheel press\",\n\t\t\tbuf:  encode(89, 32, 16, false),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tAlt:    true,\n\t\t\t\tCtrl:   true,\n\t\t\t\tType:   MouseWheelDown,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonWheelDown,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ctrl+alt+shift+wheel press\",\n\t\t\tbuf:  encode(93, 32, 16, false),\n\t\t\texpected: MouseEvent{\n\t\t\t\tX:      32,\n\t\t\t\tY:      16,\n\t\t\t\tShift:  true,\n\t\t\t\tAlt:    true,\n\t\t\t\tCtrl:   true,\n\t\t\t\tType:   MouseWheelDown,\n\t\t\t\tAction: MouseActionPress,\n\t\t\t\tButton: MouseButtonWheelDown,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor i := range tt {\n\t\ttc := tt[i]\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual := parseSGRMouseEvent(tc.buf)\n\t\t\tif tc.expected != actual {\n\t\t\t\tt.Fatalf(\"expected %#v but got %#v\",\n\t\t\t\t\ttc.expected,\n\t\t\t\t\tactual,\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "nil_renderer.go",
          "type": "blob",
          "size": 1.3,
          "content": "package tea\n\ntype nilRenderer struct{}\n\nfunc (n nilRenderer) start()                     {}\nfunc (n nilRenderer) stop()                      {}\nfunc (n nilRenderer) kill()                      {}\nfunc (n nilRenderer) write(_ string)             {}\nfunc (n nilRenderer) repaint()                   {}\nfunc (n nilRenderer) clearScreen()               {}\nfunc (n nilRenderer) altScreen() bool            { return false }\nfunc (n nilRenderer) enterAltScreen()            {}\nfunc (n nilRenderer) exitAltScreen()             {}\nfunc (n nilRenderer) showCursor()                {}\nfunc (n nilRenderer) hideCursor()                {}\nfunc (n nilRenderer) enableMouseCellMotion()     {}\nfunc (n nilRenderer) disableMouseCellMotion()    {}\nfunc (n nilRenderer) enableMouseAllMotion()      {}\nfunc (n nilRenderer) disableMouseAllMotion()     {}\nfunc (n nilRenderer) enableBracketedPaste()      {}\nfunc (n nilRenderer) disableBracketedPaste()     {}\nfunc (n nilRenderer) enableMouseSGRMode()        {}\nfunc (n nilRenderer) disableMouseSGRMode()       {}\nfunc (n nilRenderer) bracketedPasteActive() bool { return false }\nfunc (n nilRenderer) setWindowTitle(_ string)    {}\nfunc (n nilRenderer) reportFocus() bool          { return false }\nfunc (n nilRenderer) enableReportFocus()         {}\nfunc (n nilRenderer) disableReportFocus()        {}\n"
        },
        {
          "name": "nil_renderer_test.go",
          "type": "blob",
          "size": 0.41,
          "content": "package tea\n\nimport \"testing\"\n\nfunc TestNilRenderer(t *testing.T) {\n\tr := nilRenderer{}\n\tr.start()\n\tr.stop()\n\tr.kill()\n\tr.write(\"a\")\n\tr.repaint()\n\tr.enterAltScreen()\n\tif r.altScreen() {\n\t\tt.Errorf(\"altScreen should always return false\")\n\t}\n\tr.exitAltScreen()\n\tr.clearScreen()\n\tr.showCursor()\n\tr.hideCursor()\n\tr.enableMouseCellMotion()\n\tr.disableMouseCellMotion()\n\tr.enableMouseAllMotion()\n\tr.disableMouseAllMotion()\n}\n"
        },
        {
          "name": "options.go",
          "type": "blob",
          "size": 8.1,
          "content": "package tea\n\nimport (\n\t\"context\"\n\t\"io\"\n\t\"sync/atomic\"\n)\n\n// ProgramOption is used to set options when initializing a Program. Program can\n// accept a variable number of options.\n//\n// Example usage:\n//\n//\tp := NewProgram(model, WithInput(someInput), WithOutput(someOutput))\ntype ProgramOption func(*Program)\n\n// WithContext lets you specify a context in which to run the Program. This is\n// useful if you want to cancel the execution from outside. When a Program gets\n// cancelled it will exit with an error ErrProgramKilled.\nfunc WithContext(ctx context.Context) ProgramOption {\n\treturn func(p *Program) {\n\t\tp.ctx = ctx\n\t}\n}\n\n// WithOutput sets the output which, by default, is stdout. In most cases you\n// won't need to use this.\nfunc WithOutput(output io.Writer) ProgramOption {\n\treturn func(p *Program) {\n\t\tp.output = output\n\t}\n}\n\n// WithInput sets the input which, by default, is stdin. In most cases you\n// won't need to use this. To disable input entirely pass nil.\n//\n//\tp := NewProgram(model, WithInput(nil))\nfunc WithInput(input io.Reader) ProgramOption {\n\treturn func(p *Program) {\n\t\tp.input = input\n\t\tp.inputType = customInput\n\t}\n}\n\n// WithInputTTY opens a new TTY for input (or console input device on Windows).\nfunc WithInputTTY() ProgramOption {\n\treturn func(p *Program) {\n\t\tp.inputType = ttyInput\n\t}\n}\n\n// WithEnvironment sets the environment variables that the program will use.\n// This useful when the program is running in a remote session (e.g. SSH) and\n// you want to pass the environment variables from the remote session to the\n// program.\n//\n// Example:\n//\n//\tvar sess ssh.Session // ssh.Session is a type from the github.com/charmbracelet/ssh package\n//\tpty, _, _ := sess.Pty()\n//\tenviron := append(sess.Environ(), \"TERM=\"+pty.Term)\n//\tp := tea.NewProgram(model, tea.WithEnvironment(environ)\nfunc WithEnvironment(env []string) ProgramOption {\n\treturn func(p *Program) {\n\t\tp.environ = env\n\t}\n}\n\n// WithoutSignalHandler disables the signal handler that Bubble Tea sets up for\n// Programs. This is useful if you want to handle signals yourself.\nfunc WithoutSignalHandler() ProgramOption {\n\treturn func(p *Program) {\n\t\tp.startupOptions |= withoutSignalHandler\n\t}\n}\n\n// WithoutCatchPanics disables the panic catching that Bubble Tea does by\n// default. If panic catching is disabled the terminal will be in a fairly\n// unusable state after a panic because Bubble Tea will not perform its usual\n// cleanup on exit.\nfunc WithoutCatchPanics() ProgramOption {\n\treturn func(p *Program) {\n\t\tp.startupOptions |= withoutCatchPanics\n\t}\n}\n\n// WithoutSignals will ignore OS signals.\n// This is mainly useful for testing.\nfunc WithoutSignals() ProgramOption {\n\treturn func(p *Program) {\n\t\tatomic.StoreUint32(&p.ignoreSignals, 1)\n\t}\n}\n\n// WithAltScreen starts the program with the alternate screen buffer enabled\n// (i.e. the program starts in full window mode). Note that the altscreen will\n// be automatically exited when the program quits.\n//\n// Example:\n//\n//\tp := tea.NewProgram(Model{}, tea.WithAltScreen())\n//\tif _, err := p.Run(); err != nil {\n//\t    fmt.Println(\"Error running program:\", err)\n//\t    os.Exit(1)\n//\t}\n//\n// To enter the altscreen once the program has already started running use the\n// EnterAltScreen command.\nfunc WithAltScreen() ProgramOption {\n\treturn func(p *Program) {\n\t\tp.startupOptions |= withAltScreen\n\t}\n}\n\n// WithoutBracketedPaste starts the program with bracketed paste disabled.\nfunc WithoutBracketedPaste() ProgramOption {\n\treturn func(p *Program) {\n\t\tp.startupOptions |= withoutBracketedPaste\n\t}\n}\n\n// WithMouseCellMotion starts the program with the mouse enabled in \"cell\n// motion\" mode.\n//\n// Cell motion mode enables mouse click, release, and wheel events. Mouse\n// movement events are also captured if a mouse button is pressed (i.e., drag\n// events). Cell motion mode is better supported than all motion mode.\n//\n// This will try to enable the mouse in extended mode (SGR), if that is not\n// supported by the terminal it will fall back to normal mode (X10).\n//\n// To enable mouse cell motion once the program has already started running use\n// the EnableMouseCellMotion command. To disable the mouse when the program is\n// running use the DisableMouse command.\n//\n// The mouse will be automatically disabled when the program exits.\nfunc WithMouseCellMotion() ProgramOption {\n\treturn func(p *Program) {\n\t\tp.startupOptions |= withMouseCellMotion // set\n\t\tp.startupOptions &^= withMouseAllMotion // clear\n\t}\n}\n\n// WithMouseAllMotion starts the program with the mouse enabled in \"all motion\"\n// mode.\n//\n// EnableMouseAllMotion is a special command that enables mouse click, release,\n// wheel, and motion events, which are delivered regardless of whether a mouse\n// button is pressed, effectively enabling support for hover interactions.\n//\n// This will try to enable the mouse in extended mode (SGR), if that is not\n// supported by the terminal it will fall back to normal mode (X10).\n//\n// Many modern terminals support this, but not all. If in doubt, use\n// EnableMouseCellMotion instead.\n//\n// To enable the mouse once the program has already started running use the\n// EnableMouseAllMotion command. To disable the mouse when the program is\n// running use the DisableMouse command.\n//\n// The mouse will be automatically disabled when the program exits.\nfunc WithMouseAllMotion() ProgramOption {\n\treturn func(p *Program) {\n\t\tp.startupOptions |= withMouseAllMotion   // set\n\t\tp.startupOptions &^= withMouseCellMotion // clear\n\t}\n}\n\n// WithoutRenderer disables the renderer. When this is set output and log\n// statements will be plainly sent to stdout (or another output if one is set)\n// without any rendering and redrawing logic. In other words, printing and\n// logging will behave the same way it would in a non-TUI commandline tool.\n// This can be useful if you want to use the Bubble Tea framework for a non-TUI\n// application, or to provide an additional non-TUI mode to your Bubble Tea\n// programs. For example, your program could behave like a daemon if output is\n// not a TTY.\nfunc WithoutRenderer() ProgramOption {\n\treturn func(p *Program) {\n\t\tp.renderer = &nilRenderer{}\n\t}\n}\n\n// WithANSICompressor removes redundant ANSI sequences to produce potentially\n// smaller output, at the cost of some processing overhead.\n//\n// This feature is provisional, and may be changed or removed in a future version\n// of this package.\n//\n// Deprecated: this incurs a noticeable performance hit. A future release will\n// optimize ANSI automatically without the performance penalty.\nfunc WithANSICompressor() ProgramOption {\n\treturn func(p *Program) {\n\t\tp.startupOptions |= withANSICompressor\n\t}\n}\n\n// WithFilter supplies an event filter that will be invoked before Bubble Tea\n// processes a tea.Msg. The event filter can return any tea.Msg which will then\n// get handled by Bubble Tea instead of the original event. If the event filter\n// returns nil, the event will be ignored and Bubble Tea will not process it.\n//\n// As an example, this could be used to prevent a program from shutting down if\n// there are unsaved changes.\n//\n// Example:\n//\n//\tfunc filter(m tea.Model, msg tea.Msg) tea.Msg {\n//\t\tif _, ok := msg.(tea.QuitMsg); !ok {\n//\t\t\treturn msg\n//\t\t}\n//\n//\t\tmodel := m.(myModel)\n//\t\tif model.hasChanges {\n//\t\t\treturn nil\n//\t\t}\n//\n//\t\treturn msg\n//\t}\n//\n//\tp := tea.NewProgram(Model{}, tea.WithFilter(filter));\n//\n//\tif _,err := p.Run(); err != nil {\n//\t\tfmt.Println(\"Error running program:\", err)\n//\t\tos.Exit(1)\n//\t}\nfunc WithFilter(filter func(Model, Msg) Msg) ProgramOption {\n\treturn func(p *Program) {\n\t\tp.filter = filter\n\t}\n}\n\n// WithFPS sets a custom maximum FPS at which the renderer should run. If\n// less than 1, the default value of 60 will be used. If over 120, the FPS\n// will be capped at 120.\nfunc WithFPS(fps int) ProgramOption {\n\treturn func(p *Program) {\n\t\tp.fps = fps\n\t}\n}\n\n// WithReportFocus enables reporting when the terminal gains and loses\n// focus. When this is enabled [FocusMsg] and [BlurMsg] messages will be sent\n// to your Update method.\n//\n// Note that while most terminals and multiplexers support focus reporting,\n// some do not. Also note that tmux needs to be configured to report focus\n// events.\nfunc WithReportFocus() ProgramOption {\n\treturn func(p *Program) {\n\t\tp.startupOptions |= withReportFocus\n\t}\n}\n"
        },
        {
          "name": "options_test.go",
          "type": "blob",
          "size": 3.8,
          "content": "package tea\n\nimport (\n\t\"bytes\"\n\t\"os\"\n\t\"sync/atomic\"\n\t\"testing\"\n)\n\nfunc TestOptions(t *testing.T) {\n\tt.Run(\"output\", func(t *testing.T) {\n\t\tvar b bytes.Buffer\n\t\tp := NewProgram(nil, WithOutput(&b))\n\t\tif f, ok := p.output.(*os.File); ok {\n\t\t\tt.Errorf(\"expected output to custom, got %v\", f.Fd())\n\t\t}\n\t})\n\n\tt.Run(\"custom input\", func(t *testing.T) {\n\t\tvar b bytes.Buffer\n\t\tp := NewProgram(nil, WithInput(&b))\n\t\tif p.input != &b {\n\t\t\tt.Errorf(\"expected input to custom, got %v\", p.input)\n\t\t}\n\t\tif p.inputType != customInput {\n\t\t\tt.Errorf(\"expected startup options to have custom input set, got %v\", p.input)\n\t\t}\n\t})\n\n\tt.Run(\"renderer\", func(t *testing.T) {\n\t\tp := NewProgram(nil, WithoutRenderer())\n\t\tswitch p.renderer.(type) {\n\t\tcase *nilRenderer:\n\t\t\treturn\n\t\tdefault:\n\t\t\tt.Errorf(\"expected renderer to be a nilRenderer, got %v\", p.renderer)\n\t\t}\n\t})\n\n\tt.Run(\"without signals\", func(t *testing.T) {\n\t\tp := NewProgram(nil, WithoutSignals())\n\t\tif atomic.LoadUint32(&p.ignoreSignals) == 0 {\n\t\t\tt.Errorf(\"ignore signals should have been set\")\n\t\t}\n\t})\n\n\tt.Run(\"filter\", func(t *testing.T) {\n\t\tp := NewProgram(nil, WithFilter(func(_ Model, msg Msg) Msg { return msg }))\n\t\tif p.filter == nil {\n\t\t\tt.Errorf(\"expected filter to be set\")\n\t\t}\n\t})\n\n\tt.Run(\"input options\", func(t *testing.T) {\n\t\texercise := func(t *testing.T, opt ProgramOption, expect inputType) {\n\t\t\tp := NewProgram(nil, opt)\n\t\t\tif p.inputType != expect {\n\t\t\t\tt.Errorf(\"expected input type %s, got %s\", expect, p.inputType)\n\t\t\t}\n\t\t}\n\n\t\tt.Run(\"tty input\", func(t *testing.T) {\n\t\t\texercise(t, WithInputTTY(), ttyInput)\n\t\t})\n\n\t\tt.Run(\"custom input\", func(t *testing.T) {\n\t\t\tvar b bytes.Buffer\n\t\t\texercise(t, WithInput(&b), customInput)\n\t\t})\n\t})\n\n\tt.Run(\"startup options\", func(t *testing.T) {\n\t\texercise := func(t *testing.T, opt ProgramOption, expect startupOptions) {\n\t\t\tp := NewProgram(nil, opt)\n\t\t\tif !p.startupOptions.has(expect) {\n\t\t\t\tt.Errorf(\"expected startup options have %v, got %v\", expect, p.startupOptions)\n\t\t\t}\n\t\t}\n\n\t\tt.Run(\"alt screen\", func(t *testing.T) {\n\t\t\texercise(t, WithAltScreen(), withAltScreen)\n\t\t})\n\n\t\tt.Run(\"bracketed paste disabled\", func(t *testing.T) {\n\t\t\texercise(t, WithoutBracketedPaste(), withoutBracketedPaste)\n\t\t})\n\n\t\tt.Run(\"ansi compression\", func(t *testing.T) {\n\t\t\texercise(t, WithANSICompressor(), withANSICompressor)\n\t\t})\n\n\t\tt.Run(\"without catch panics\", func(t *testing.T) {\n\t\t\texercise(t, WithoutCatchPanics(), withoutCatchPanics)\n\t\t})\n\n\t\tt.Run(\"without signal handler\", func(t *testing.T) {\n\t\t\texercise(t, WithoutSignalHandler(), withoutSignalHandler)\n\t\t})\n\n\t\tt.Run(\"mouse cell motion\", func(t *testing.T) {\n\t\t\tp := NewProgram(nil, WithMouseAllMotion(), WithMouseCellMotion())\n\t\t\tif !p.startupOptions.has(withMouseCellMotion) {\n\t\t\t\tt.Errorf(\"expected startup options have %v, got %v\", withMouseCellMotion, p.startupOptions)\n\t\t\t}\n\t\t\tif p.startupOptions.has(withMouseAllMotion) {\n\t\t\t\tt.Errorf(\"expected startup options not have %v, got %v\", withMouseAllMotion, p.startupOptions)\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"mouse all motion\", func(t *testing.T) {\n\t\t\tp := NewProgram(nil, WithMouseCellMotion(), WithMouseAllMotion())\n\t\t\tif !p.startupOptions.has(withMouseAllMotion) {\n\t\t\t\tt.Errorf(\"expected startup options have %v, got %v\", withMouseAllMotion, p.startupOptions)\n\t\t\t}\n\t\t\tif p.startupOptions.has(withMouseCellMotion) {\n\t\t\t\tt.Errorf(\"expected startup options not have %v, got %v\", withMouseCellMotion, p.startupOptions)\n\t\t\t}\n\t\t})\n\t})\n\n\tt.Run(\"multiple\", func(t *testing.T) {\n\t\tp := NewProgram(nil, WithMouseAllMotion(), WithoutBracketedPaste(), WithAltScreen(), WithInputTTY())\n\t\tfor _, opt := range []startupOptions{withMouseAllMotion, withoutBracketedPaste, withAltScreen} {\n\t\t\tif !p.startupOptions.has(opt) {\n\t\t\t\tt.Errorf(\"expected startup options have %v, got %v\", opt, p.startupOptions)\n\t\t\t}\n\t\t\tif p.inputType != ttyInput {\n\t\t\t\tt.Errorf(\"expected input to be %v, got %v\", opt, p.startupOptions)\n\t\t\t}\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "renderer.go",
          "type": "blob",
          "size": 2.36,
          "content": "package tea\n\n// renderer is the interface for Bubble Tea renderers.\ntype renderer interface {\n\t// Start the renderer.\n\tstart()\n\n\t// Stop the renderer, but render the final frame in the buffer, if any.\n\tstop()\n\n\t// Stop the renderer without doing any final rendering.\n\tkill()\n\n\t// Write a frame to the renderer. The renderer can write this data to\n\t// output at its discretion.\n\twrite(string)\n\n\t// Request a full re-render. Note that this will not trigger a render\n\t// immediately. Rather, this method causes the next render to be a full\n\t// repaint. Because of this, it's safe to call this method multiple times\n\t// in succession.\n\trepaint()\n\n\t// Clears the terminal.\n\tclearScreen()\n\n\t// Whether or not the alternate screen buffer is enabled.\n\taltScreen() bool\n\t// Enable the alternate screen buffer.\n\tenterAltScreen()\n\t// Disable the alternate screen buffer.\n\texitAltScreen()\n\n\t// Show the cursor.\n\tshowCursor()\n\t// Hide the cursor.\n\thideCursor()\n\n\t// enableMouseCellMotion enables mouse click, release, wheel and motion\n\t// events if a mouse button is pressed (i.e., drag events).\n\tenableMouseCellMotion()\n\n\t// disableMouseCellMotion disables Mouse Cell Motion tracking.\n\tdisableMouseCellMotion()\n\n\t// enableMouseAllMotion enables mouse click, release, wheel and motion\n\t// events, regardless of whether a mouse button is pressed. Many modern\n\t// terminals support this, but not all.\n\tenableMouseAllMotion()\n\n\t// disableMouseAllMotion disables All Motion mouse tracking.\n\tdisableMouseAllMotion()\n\n\t// enableMouseSGRMode enables mouse extended mode (SGR).\n\tenableMouseSGRMode()\n\n\t// disableMouseSGRMode disables mouse extended mode (SGR).\n\tdisableMouseSGRMode()\n\n\t// enableBracketedPaste enables bracketed paste, where characters\n\t// inside the input are not interpreted when pasted as a whole.\n\tenableBracketedPaste()\n\n\t// disableBracketedPaste disables bracketed paste.\n\tdisableBracketedPaste()\n\n\t// bracketedPasteActive reports whether bracketed paste mode is\n\t// currently enabled.\n\tbracketedPasteActive() bool\n\n\t// setWindowTitle sets the terminal window title.\n\tsetWindowTitle(string)\n\n\t// reportFocus returns whether reporting focus events is enabled.\n\treportFocus() bool\n\n\t// enableReportFocus reports focus events to the program.\n\tenableReportFocus()\n\n\t// disableReportFocus stops reporting focus events to the program.\n\tdisableReportFocus()\n}\n\n// repaintMsg forces a full repaint.\ntype repaintMsg struct{}\n"
        },
        {
          "name": "screen.go",
          "type": "blob",
          "size": 8.56,
          "content": "package tea\n\n// WindowSizeMsg is used to report the terminal size. It's sent to Update once\n// initially and then on every terminal resize. Note that Windows does not\n// have support for reporting when resizes occur as it does not support the\n// SIGWINCH signal.\ntype WindowSizeMsg struct {\n\tWidth  int\n\tHeight int\n}\n\n// ClearScreen is a special command that tells the program to clear the screen\n// before the next update. This can be used to move the cursor to the top left\n// of the screen and clear visual clutter when the alt screen is not in use.\n//\n// Note that it should never be necessary to call ClearScreen() for regular\n// redraws.\nfunc ClearScreen() Msg {\n\treturn clearScreenMsg{}\n}\n\n// clearScreenMsg is an internal message that signals to clear the screen.\n// You can send a clearScreenMsg with ClearScreen.\ntype clearScreenMsg struct{}\n\n// EnterAltScreen is a special command that tells the Bubble Tea program to\n// enter the alternate screen buffer.\n//\n// Because commands run asynchronously, this command should not be used in your\n// model's Init function. To initialize your program with the altscreen enabled\n// use the WithAltScreen ProgramOption instead.\nfunc EnterAltScreen() Msg {\n\treturn enterAltScreenMsg{}\n}\n\n// enterAltScreenMsg in an internal message signals that the program should\n// enter alternate screen buffer. You can send a enterAltScreenMsg with\n// EnterAltScreen.\ntype enterAltScreenMsg struct{}\n\n// ExitAltScreen is a special command that tells the Bubble Tea program to exit\n// the alternate screen buffer. This command should be used to exit the\n// alternate screen buffer while the program is running.\n//\n// Note that the alternate screen buffer will be automatically exited when the\n// program quits.\nfunc ExitAltScreen() Msg {\n\treturn exitAltScreenMsg{}\n}\n\n// exitAltScreenMsg in an internal message signals that the program should exit\n// alternate screen buffer. You can send a exitAltScreenMsg with ExitAltScreen.\ntype exitAltScreenMsg struct{}\n\n// EnableMouseCellMotion is a special command that enables mouse click,\n// release, and wheel events. Mouse movement events are also captured if\n// a mouse button is pressed (i.e., drag events).\n//\n// Because commands run asynchronously, this command should not be used in your\n// model's Init function. Use the WithMouseCellMotion ProgramOption instead.\nfunc EnableMouseCellMotion() Msg {\n\treturn enableMouseCellMotionMsg{}\n}\n\n// enableMouseCellMotionMsg is a special command that signals to start\n// listening for \"cell motion\" type mouse events (ESC[?1002l). To send an\n// enableMouseCellMotionMsg, use the EnableMouseCellMotion command.\ntype enableMouseCellMotionMsg struct{}\n\n// EnableMouseAllMotion is a special command that enables mouse click, release,\n// wheel, and motion events, which are delivered regardless of whether a mouse\n// button is pressed, effectively enabling support for hover interactions.\n//\n// Many modern terminals support this, but not all. If in doubt, use\n// EnableMouseCellMotion instead.\n//\n// Because commands run asynchronously, this command should not be used in your\n// model's Init function. Use the WithMouseAllMotion ProgramOption instead.\nfunc EnableMouseAllMotion() Msg {\n\treturn enableMouseAllMotionMsg{}\n}\n\n// enableMouseAllMotionMsg is a special command that signals to start listening\n// for \"all motion\" type mouse events (ESC[?1003l). To send an\n// enableMouseAllMotionMsg, use the EnableMouseAllMotion command.\ntype enableMouseAllMotionMsg struct{}\n\n// DisableMouse is a special command that stops listening for mouse events.\nfunc DisableMouse() Msg {\n\treturn disableMouseMsg{}\n}\n\n// disableMouseMsg is an internal message that signals to stop listening\n// for mouse events. To send a disableMouseMsg, use the DisableMouse command.\ntype disableMouseMsg struct{}\n\n// HideCursor is a special command for manually instructing Bubble Tea to hide\n// the cursor. In some rare cases, certain operations will cause the terminal\n// to show the cursor, which is normally hidden for the duration of a Bubble\n// Tea program's lifetime. You will most likely not need to use this command.\nfunc HideCursor() Msg {\n\treturn hideCursorMsg{}\n}\n\n// hideCursorMsg is an internal command used to hide the cursor. You can send\n// this message with HideCursor.\ntype hideCursorMsg struct{}\n\n// ShowCursor is a special command for manually instructing Bubble Tea to show\n// the cursor.\nfunc ShowCursor() Msg {\n\treturn showCursorMsg{}\n}\n\n// showCursorMsg is an internal command used to show the cursor. You can send\n// this message with ShowCursor.\ntype showCursorMsg struct{}\n\n// EnableBracketedPaste is a special command that tells the Bubble Tea program\n// to accept bracketed paste input.\n//\n// Note that bracketed paste will be automatically disabled when the\n// program quits.\nfunc EnableBracketedPaste() Msg {\n\treturn enableBracketedPasteMsg{}\n}\n\n// enableBracketedPasteMsg in an internal message signals that\n// bracketed paste should be enabled. You can send an\n// enableBracketedPasteMsg with EnableBracketedPaste.\ntype enableBracketedPasteMsg struct{}\n\n// DisableBracketedPaste is a special command that tells the Bubble Tea program\n// to accept bracketed paste input.\n//\n// Note that bracketed paste will be automatically disabled when the\n// program quits.\nfunc DisableBracketedPaste() Msg {\n\treturn disableBracketedPasteMsg{}\n}\n\n// disableBracketedPasteMsg in an internal message signals that\n// bracketed paste should be disabled. You can send an\n// disableBracketedPasteMsg with DisableBracketedPaste.\ntype disableBracketedPasteMsg struct{}\n\n// enableReportFocusMsg is an internal message that signals to enable focus\n// reporting. You can send an enableReportFocusMsg with EnableReportFocus.\ntype enableReportFocusMsg struct{}\n\n// EnableReportFocus is a special command that tells the Bubble Tea program to\n// report focus events to the program.\nfunc EnableReportFocus() Msg {\n\treturn enableReportFocusMsg{}\n}\n\n// disableReportFocusMsg is an internal message that signals to disable focus\n// reporting. You can send an disableReportFocusMsg with DisableReportFocus.\ntype disableReportFocusMsg struct{}\n\n// DisableReportFocus is a special command that tells the Bubble Tea program to\n// stop reporting focus events to the program.\nfunc DisableReportFocus() Msg {\n\treturn disableReportFocusMsg{}\n}\n\n// EnterAltScreen enters the alternate screen buffer, which consumes the entire\n// terminal window. ExitAltScreen will return the terminal to its former state.\n//\n// Deprecated: Use the WithAltScreen ProgramOption instead.\nfunc (p *Program) EnterAltScreen() {\n\tif p.renderer != nil {\n\t\tp.renderer.enterAltScreen()\n\t} else {\n\t\tp.startupOptions |= withAltScreen\n\t}\n}\n\n// ExitAltScreen exits the alternate screen buffer.\n//\n// Deprecated: The altscreen will exited automatically when the program exits.\nfunc (p *Program) ExitAltScreen() {\n\tif p.renderer != nil {\n\t\tp.renderer.exitAltScreen()\n\t} else {\n\t\tp.startupOptions &^= withAltScreen\n\t}\n}\n\n// EnableMouseCellMotion enables mouse click, release, wheel and motion events\n// if a mouse button is pressed (i.e., drag events).\n//\n// Deprecated: Use the WithMouseCellMotion ProgramOption instead.\nfunc (p *Program) EnableMouseCellMotion() {\n\tif p.renderer != nil {\n\t\tp.renderer.enableMouseCellMotion()\n\t} else {\n\t\tp.startupOptions |= withMouseCellMotion\n\t}\n}\n\n// DisableMouseCellMotion disables Mouse Cell Motion tracking. This will be\n// called automatically when exiting a Bubble Tea program.\n//\n// Deprecated: The mouse will automatically be disabled when the program exits.\nfunc (p *Program) DisableMouseCellMotion() {\n\tif p.renderer != nil {\n\t\tp.renderer.disableMouseCellMotion()\n\t} else {\n\t\tp.startupOptions &^= withMouseCellMotion\n\t}\n}\n\n// EnableMouseAllMotion enables mouse click, release, wheel and motion events,\n// regardless of whether a mouse button is pressed. Many modern terminals\n// support this, but not all.\n//\n// Deprecated: Use the WithMouseAllMotion ProgramOption instead.\nfunc (p *Program) EnableMouseAllMotion() {\n\tif p.renderer != nil {\n\t\tp.renderer.enableMouseAllMotion()\n\t} else {\n\t\tp.startupOptions |= withMouseAllMotion\n\t}\n}\n\n// DisableMouseAllMotion disables All Motion mouse tracking. This will be\n// called automatically when exiting a Bubble Tea program.\n//\n// Deprecated: The mouse will automatically be disabled when the program exits.\nfunc (p *Program) DisableMouseAllMotion() {\n\tif p.renderer != nil {\n\t\tp.renderer.disableMouseAllMotion()\n\t} else {\n\t\tp.startupOptions &^= withMouseAllMotion\n\t}\n}\n\n// SetWindowTitle sets the terminal window title.\n//\n// Deprecated: Use the SetWindowTitle command instead.\nfunc (p *Program) SetWindowTitle(title string) {\n\tif p.renderer != nil {\n\t\tp.renderer.setWindowTitle(title)\n\t} else {\n\t\tp.startupTitle = title\n\t}\n}\n"
        },
        {
          "name": "screen_test.go",
          "type": "blob",
          "size": 2.87,
          "content": "package tea\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestClearMsg(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tcmds     sequenceMsg\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"clear_screen\",\n\t\t\tcmds:     []Cmd{ClearScreen},\n\t\t\texpected: \"\\x1b[?25l\\x1b[?2004h\\x1b[2J\\x1b[H\\rsuccess\\x1b[K\\r\\n\\x1b[K\\x1b[80D\\x1b[2K\\r\\x1b[?2004l\\x1b[?25h\\x1b[?1002l\\x1b[?1003l\\x1b[?1006l\",\n\t\t},\n\t\t{\n\t\t\tname:     \"altscreen\",\n\t\t\tcmds:     []Cmd{EnterAltScreen, ExitAltScreen},\n\t\t\texpected: \"\\x1b[?25l\\x1b[?2004h\\x1b[?1049h\\x1b[2J\\x1b[H\\x1b[?25l\\x1b[?1049l\\x1b[?25l\\rsuccess\\x1b[K\\r\\n\\x1b[K\\x1b[80D\\x1b[2K\\r\\x1b[?2004l\\x1b[?25h\\x1b[?1002l\\x1b[?1003l\\x1b[?1006l\",\n\t\t},\n\t\t{\n\t\t\tname:     \"altscreen_autoexit\",\n\t\t\tcmds:     []Cmd{EnterAltScreen},\n\t\t\texpected: \"\\x1b[?25l\\x1b[?2004h\\x1b[?1049h\\x1b[2J\\x1b[H\\x1b[?25l\\x1b[H\\rsuccess\\x1b[K\\r\\n\\x1b[K\\x1b[2;H\\x1b[2K\\r\\x1b[?2004l\\x1b[?25h\\x1b[?1002l\\x1b[?1003l\\x1b[?1006l\\x1b[?1049l\\x1b[?25h\",\n\t\t},\n\t\t{\n\t\t\tname:     \"mouse_cellmotion\",\n\t\t\tcmds:     []Cmd{EnableMouseCellMotion},\n\t\t\texpected: \"\\x1b[?25l\\x1b[?2004h\\x1b[?1002h\\x1b[?1006h\\rsuccess\\x1b[K\\r\\n\\x1b[K\\x1b[80D\\x1b[2K\\r\\x1b[?2004l\\x1b[?25h\\x1b[?1002l\\x1b[?1003l\\x1b[?1006l\",\n\t\t},\n\t\t{\n\t\t\tname:     \"mouse_allmotion\",\n\t\t\tcmds:     []Cmd{EnableMouseAllMotion},\n\t\t\texpected: \"\\x1b[?25l\\x1b[?2004h\\x1b[?1003h\\x1b[?1006h\\rsuccess\\x1b[K\\r\\n\\x1b[K\\x1b[80D\\x1b[2K\\r\\x1b[?2004l\\x1b[?25h\\x1b[?1002l\\x1b[?1003l\\x1b[?1006l\",\n\t\t},\n\t\t{\n\t\t\tname:     \"mouse_disable\",\n\t\t\tcmds:     []Cmd{EnableMouseAllMotion, DisableMouse},\n\t\t\texpected: \"\\x1b[?25l\\x1b[?2004h\\x1b[?1003h\\x1b[?1006h\\x1b[?1002l\\x1b[?1003l\\x1b[?1006l\\rsuccess\\x1b[K\\r\\n\\x1b[K\\x1b[80D\\x1b[2K\\r\\x1b[?2004l\\x1b[?25h\\x1b[?1002l\\x1b[?1003l\\x1b[?1006l\",\n\t\t},\n\t\t{\n\t\t\tname:     \"cursor_hide\",\n\t\t\tcmds:     []Cmd{HideCursor},\n\t\t\texpected: \"\\x1b[?25l\\x1b[?2004h\\x1b[?25l\\rsuccess\\x1b[K\\r\\n\\x1b[K\\x1b[80D\\x1b[2K\\r\\x1b[?2004l\\x1b[?25h\\x1b[?1002l\\x1b[?1003l\\x1b[?1006l\",\n\t\t},\n\t\t{\n\t\t\tname:     \"cursor_hideshow\",\n\t\t\tcmds:     []Cmd{HideCursor, ShowCursor},\n\t\t\texpected: \"\\x1b[?25l\\x1b[?2004h\\x1b[?25l\\x1b[?25h\\rsuccess\\x1b[K\\r\\n\\x1b[K\\x1b[80D\\x1b[2K\\r\\x1b[?2004l\\x1b[?25h\\x1b[?1002l\\x1b[?1003l\\x1b[?1006l\",\n\t\t},\n\t\t{\n\t\t\tname:     \"bp_stop_start\",\n\t\t\tcmds:     []Cmd{DisableBracketedPaste, EnableBracketedPaste},\n\t\t\texpected: \"\\x1b[?25l\\x1b[?2004h\\x1b[?2004l\\x1b[?2004h\\rsuccess\\x1b[K\\r\\n\\x1b[K\\x1b[80D\\x1b[2K\\r\\x1b[?2004l\\x1b[?25h\\x1b[?1002l\\x1b[?1003l\\x1b[?1006l\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar buf bytes.Buffer\n\t\t\tvar in bytes.Buffer\n\n\t\t\tm := &testModel{}\n\t\t\tp := NewProgram(m, WithInput(&in), WithOutput(&buf))\n\n\t\t\ttest.cmds = append([]Cmd{func() Msg { return WindowSizeMsg{80, 24} }}, test.cmds...)\n\t\t\ttest.cmds = append(test.cmds, Quit)\n\t\t\tgo p.Send(test.cmds)\n\n\t\t\tif _, err := p.Run(); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tif buf.String() != test.expected {\n\t\t\t\tt.Errorf(\"expected embedded sequence:\\n%q\\ngot:\\n%q\", test.expected, buf.String())\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "signals_unix.go",
          "type": "blob",
          "size": 0.65,
          "content": "//go:build darwin || dragonfly || freebsd || linux || netbsd || openbsd || solaris || aix || zos\n// +build darwin dragonfly freebsd linux netbsd openbsd solaris aix zos\n\npackage tea\n\nimport (\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n)\n\n// listenForResize sends messages (or errors) when the terminal resizes.\n// Argument output should be the file descriptor for the terminal; usually\n// os.Stdout.\nfunc (p *Program) listenForResize(done chan struct{}) {\n\tsig := make(chan os.Signal, 1)\n\tsignal.Notify(sig, syscall.SIGWINCH)\n\n\tdefer func() {\n\t\tsignal.Stop(sig)\n\t\tclose(done)\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase <-p.ctx.Done():\n\t\t\treturn\n\t\tcase <-sig:\n\t\t}\n\n\t\tp.checkResize()\n\t}\n}\n"
        },
        {
          "name": "signals_windows.go",
          "type": "blob",
          "size": 0.22,
          "content": "//go:build windows\n// +build windows\n\npackage tea\n\n// listenForResize is not available on windows because windows does not\n// implement syscall.SIGWINCH.\nfunc (p *Program) listenForResize(done chan struct{}) {\n\tclose(done)\n}\n"
        },
        {
          "name": "standard_renderer.go",
          "type": "blob",
          "size": 20.36,
          "content": "package tea\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/x/ansi\"\n\t\"github.com/muesli/ansi/compressor\"\n)\n\nconst (\n\t// defaultFramerate specifies the maximum interval at which we should\n\t// update the view.\n\tdefaultFPS = 60\n\tmaxFPS     = 120\n)\n\n// standardRenderer is a framerate-based terminal renderer, updating the view\n// at a given framerate to avoid overloading the terminal emulator.\n//\n// In cases where very high performance is needed the renderer can be told\n// to exclude ranges of lines, allowing them to be written to directly.\ntype standardRenderer struct {\n\tmtx *sync.Mutex\n\tout io.Writer\n\n\tbuf                bytes.Buffer\n\tqueuedMessageLines []string\n\tframerate          time.Duration\n\tticker             *time.Ticker\n\tdone               chan struct{}\n\tlastRender         string\n\tlastRenderedLines  []string\n\tlinesRendered      int\n\taltLinesRendered   int\n\tuseANSICompressor  bool\n\tonce               sync.Once\n\n\t// cursor visibility state\n\tcursorHidden bool\n\n\t// essentially whether or not we're using the full size of the terminal\n\taltScreenActive bool\n\n\t// whether or not we're currently using bracketed paste\n\tbpActive bool\n\n\t// reportingFocus whether reporting focus events is enabled\n\treportingFocus bool\n\n\t// renderer dimensions; usually the size of the window\n\twidth  int\n\theight int\n\n\t// lines explicitly set not to render\n\tignoreLines map[int]struct{}\n}\n\n// newRenderer creates a new renderer. Normally you'll want to initialize it\n// with os.Stdout as the first argument.\nfunc newRenderer(out io.Writer, useANSICompressor bool, fps int) renderer {\n\tif fps < 1 {\n\t\tfps = defaultFPS\n\t} else if fps > maxFPS {\n\t\tfps = maxFPS\n\t}\n\tr := &standardRenderer{\n\t\tout:                out,\n\t\tmtx:                &sync.Mutex{},\n\t\tdone:               make(chan struct{}),\n\t\tframerate:          time.Second / time.Duration(fps),\n\t\tuseANSICompressor:  useANSICompressor,\n\t\tqueuedMessageLines: []string{},\n\t}\n\tif r.useANSICompressor {\n\t\tr.out = &compressor.Writer{Forward: out}\n\t}\n\treturn r\n}\n\n// start starts the renderer.\nfunc (r *standardRenderer) start() {\n\tif r.ticker == nil {\n\t\tr.ticker = time.NewTicker(r.framerate)\n\t} else {\n\t\t// If the ticker already exists, it has been stopped and we need to\n\t\t// reset it.\n\t\tr.ticker.Reset(r.framerate)\n\t}\n\n\t// Since the renderer can be restarted after a stop, we need to reset\n\t// the done channel and its corresponding sync.Once.\n\tr.once = sync.Once{}\n\n\tgo r.listen()\n}\n\n// stop permanently halts the renderer, rendering the final frame.\nfunc (r *standardRenderer) stop() {\n\t// Stop the renderer before acquiring the mutex to avoid a deadlock.\n\tr.once.Do(func() {\n\t\tr.done <- struct{}{}\n\t})\n\n\t// flush locks the mutex\n\tr.flush()\n\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\tr.execute(ansi.EraseEntireLine)\n\t// Move the cursor back to the beginning of the line\n\tr.execute(\"\\r\")\n\n\tif r.useANSICompressor {\n\t\tif w, ok := r.out.(io.WriteCloser); ok {\n\t\t\t_ = w.Close()\n\t\t}\n\t}\n}\n\n// execute writes a sequence to the terminal.\nfunc (r *standardRenderer) execute(seq string) {\n\t_, _ = io.WriteString(r.out, seq)\n}\n\n// kill halts the renderer. The final frame will not be rendered.\nfunc (r *standardRenderer) kill() {\n\t// Stop the renderer before acquiring the mutex to avoid a deadlock.\n\tr.once.Do(func() {\n\t\tr.done <- struct{}{}\n\t})\n\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\tr.execute(ansi.EraseEntireLine)\n\t// Move the cursor back to the beginning of the line\n\tr.execute(\"\\r\")\n}\n\n// listen waits for ticks on the ticker, or a signal to stop the renderer.\nfunc (r *standardRenderer) listen() {\n\tfor {\n\t\tselect {\n\t\tcase <-r.done:\n\t\t\tr.ticker.Stop()\n\t\t\treturn\n\n\t\tcase <-r.ticker.C:\n\t\t\tr.flush()\n\t\t}\n\t}\n}\n\n// flush renders the buffer.\nfunc (r *standardRenderer) flush() {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\tif r.buf.Len() == 0 || r.buf.String() == r.lastRender {\n\t\t// Nothing to do.\n\t\treturn\n\t}\n\n\t// Output buffer.\n\tbuf := &bytes.Buffer{}\n\n\t// Moving to the beginning of the section, that we rendered.\n\tif r.altScreenActive {\n\t\tbuf.WriteString(ansi.CursorHomePosition)\n\t} else if r.linesRendered > 1 {\n\t\tbuf.WriteString(ansi.CursorUp(r.linesRendered - 1))\n\t}\n\n\tnewLines := strings.Split(r.buf.String(), \"\\n\")\n\n\t// If we know the output's height, we can use it to determine how many\n\t// lines we can render. We drop lines from the top of the render buffer if\n\t// necessary, as we can't navigate the cursor into the terminal's scrollback\n\t// buffer.\n\tif r.height > 0 && len(newLines) > r.height {\n\t\tnewLines = newLines[len(newLines)-r.height:]\n\t}\n\n\tflushQueuedMessages := len(r.queuedMessageLines) > 0 && !r.altScreenActive\n\n\tif flushQueuedMessages {\n\t\t// Dump the lines we've queued up for printing.\n\t\tfor _, line := range r.queuedMessageLines {\n\t\t\tif ansi.StringWidth(line) < r.width {\n\t\t\t\t// We only erase the rest of the line when the line is shorter than\n\t\t\t\t// the width of the terminal. When the cursor reaches the end of\n\t\t\t\t// the line, any escape sequences that follow will only affect the\n\t\t\t\t// last cell of the line.\n\n\t\t\t\t// Removing previously rendered content at the end of line.\n\t\t\t\tline = line + ansi.EraseLineRight\n\t\t\t}\n\n\t\t\t_, _ = buf.WriteString(line)\n\t\t\t_, _ = buf.WriteString(\"\\r\\n\")\n\t\t}\n\t\t// Clear the queued message lines.\n\t\tr.queuedMessageLines = []string{}\n\t}\n\n\t// Paint new lines.\n\tfor i := 0; i < len(newLines); i++ {\n\t\tcanSkip := !flushQueuedMessages && // Queuing messages triggers repaint -> we don't have access to previous frame content.\n\t\t\tlen(r.lastRenderedLines) > i && r.lastRenderedLines[i] == newLines[i] // Previously rendered line is the same.\n\n\t\tif _, ignore := r.ignoreLines[i]; ignore || canSkip {\n\t\t\t// Unless this is the last line, move the cursor down.\n\t\t\tif i < len(newLines)-1 {\n\t\t\t\tbuf.WriteString(ansi.CUD1)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif i == 0 && r.lastRender == \"\" {\n\t\t\t// On first render, reset the cursor to the start of the line\n\t\t\t// before writing anything.\n\t\t\tbuf.WriteByte('\\r')\n\t\t}\n\n\t\tline := newLines[i]\n\n\t\t// Truncate lines wider than the width of the window to avoid\n\t\t// wrapping, which will mess up rendering. If we don't have the\n\t\t// width of the window this will be ignored.\n\t\t//\n\t\t// Note that on Windows we only get the width of the window on\n\t\t// program initialization, so after a resize this won't perform\n\t\t// correctly (signal SIGWINCH is not supported on Windows).\n\t\tif r.width > 0 {\n\t\t\tline = ansi.Truncate(line, r.width, \"\")\n\t\t}\n\n\t\tif ansi.StringWidth(line) < r.width {\n\t\t\t// We only erase the rest of the line when the line is shorter than\n\t\t\t// the width of the terminal. When the cursor reaches the end of\n\t\t\t// the line, any escape sequences that follow will only affect the\n\t\t\t// last cell of the line.\n\n\t\t\t// Removing previously rendered content at the end of line.\n\t\t\tline = line + ansi.EraseLineRight\n\t\t}\n\n\t\t_, _ = buf.WriteString(line)\n\n\t\tif i < len(newLines)-1 {\n\t\t\t_, _ = buf.WriteString(\"\\r\\n\")\n\t\t}\n\t}\n\n\t// Clearing left over content from last render.\n\tif r.lastLinesRendered() > len(newLines) {\n\t\tbuf.WriteString(ansi.EraseScreenBelow)\n\t}\n\n\tif r.altScreenActive {\n\t\tr.altLinesRendered = len(newLines)\n\t} else {\n\t\tr.linesRendered = len(newLines)\n\t}\n\n\t// Make sure the cursor is at the start of the last line to keep rendering\n\t// behavior consistent.\n\tif r.altScreenActive {\n\t\t// This case fixes a bug in macOS terminal. In other terminals the\n\t\t// other case seems to do the job regardless of whether or not we're\n\t\t// using the full terminal window.\n\t\tbuf.WriteString(ansi.CursorPosition(0, len(newLines)))\n\t} else {\n\t\tbuf.WriteString(ansi.CursorBackward(r.width))\n\t}\n\n\t_, _ = r.out.Write(buf.Bytes())\n\tr.lastRender = r.buf.String()\n\n\t// Save previously rendered lines for comparison in the next render. If we\n\t// don't do this, we can't skip rendering lines that haven't changed.\n\t// See https://github.com/charmbracelet/bubbletea/pull/1233\n\tr.lastRenderedLines = newLines\n\tr.buf.Reset()\n}\n\n// lastLinesRendered returns the number of lines rendered lastly.\nfunc (r *standardRenderer) lastLinesRendered() int {\n\tif r.altScreenActive {\n\t\treturn r.altLinesRendered\n\t}\n\treturn r.linesRendered\n}\n\n// write writes to the internal buffer. The buffer will be outputted via the\n// ticker which calls flush().\nfunc (r *standardRenderer) write(s string) {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\tr.buf.Reset()\n\n\t// If an empty string was passed we should clear existing output and\n\t// rendering nothing. Rather than introduce additional state to manage\n\t// this, we render a single space as a simple (albeit less correct)\n\t// solution.\n\tif s == \"\" {\n\t\ts = \" \"\n\t}\n\n\t_, _ = r.buf.WriteString(s)\n}\n\nfunc (r *standardRenderer) repaint() {\n\tr.lastRender = \"\"\n\tr.lastRenderedLines = nil\n}\n\nfunc (r *standardRenderer) clearScreen() {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\tr.execute(ansi.EraseEntireScreen)\n\tr.execute(ansi.CursorHomePosition)\n\n\tr.repaint()\n}\n\nfunc (r *standardRenderer) altScreen() bool {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\treturn r.altScreenActive\n}\n\nfunc (r *standardRenderer) enterAltScreen() {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\tif r.altScreenActive {\n\t\treturn\n\t}\n\n\tr.altScreenActive = true\n\tr.execute(ansi.SetAltScreenSaveCursorMode)\n\n\t// Ensure that the terminal is cleared, even when it doesn't support\n\t// alt screen (or alt screen support is disabled, like GNU screen by\n\t// default).\n\t//\n\t// Note: we can't use r.clearScreen() here because the mutex is already\n\t// locked.\n\tr.execute(ansi.EraseEntireScreen)\n\tr.execute(ansi.CursorHomePosition)\n\n\t// cmd.exe and other terminals keep separate cursor states for the AltScreen\n\t// and the main buffer. We have to explicitly reset the cursor visibility\n\t// whenever we enter AltScreen.\n\tif r.cursorHidden {\n\t\tr.execute(ansi.HideCursor)\n\t} else {\n\t\tr.execute(ansi.ShowCursor)\n\t}\n\n\t// Entering the alt screen resets the lines rendered count.\n\tr.altLinesRendered = 0\n\n\tr.repaint()\n}\n\nfunc (r *standardRenderer) exitAltScreen() {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\tif !r.altScreenActive {\n\t\treturn\n\t}\n\n\tr.altScreenActive = false\n\tr.execute(ansi.ResetAltScreenSaveCursorMode)\n\n\t// cmd.exe and other terminals keep separate cursor states for the AltScreen\n\t// and the main buffer. We have to explicitly reset the cursor visibility\n\t// whenever we exit AltScreen.\n\tif r.cursorHidden {\n\t\tr.execute(ansi.HideCursor)\n\t} else {\n\t\tr.execute(ansi.ShowCursor)\n\t}\n\n\tr.repaint()\n}\n\nfunc (r *standardRenderer) showCursor() {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\tr.cursorHidden = false\n\tr.execute(ansi.ShowCursor)\n}\n\nfunc (r *standardRenderer) hideCursor() {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\tr.cursorHidden = true\n\tr.execute(ansi.HideCursor)\n}\n\nfunc (r *standardRenderer) enableMouseCellMotion() {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\tr.execute(ansi.SetButtonEventMouseMode)\n}\n\nfunc (r *standardRenderer) disableMouseCellMotion() {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\tr.execute(ansi.ResetButtonEventMouseMode)\n}\n\nfunc (r *standardRenderer) enableMouseAllMotion() {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\tr.execute(ansi.SetAnyEventMouseMode)\n}\n\nfunc (r *standardRenderer) disableMouseAllMotion() {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\tr.execute(ansi.ResetAnyEventMouseMode)\n}\n\nfunc (r *standardRenderer) enableMouseSGRMode() {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\tr.execute(ansi.SetSgrExtMouseMode)\n}\n\nfunc (r *standardRenderer) disableMouseSGRMode() {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\tr.execute(ansi.ResetSgrExtMouseMode)\n}\n\nfunc (r *standardRenderer) enableBracketedPaste() {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\tr.execute(ansi.SetBracketedPasteMode)\n\tr.bpActive = true\n}\n\nfunc (r *standardRenderer) disableBracketedPaste() {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\tr.execute(ansi.ResetBracketedPasteMode)\n\tr.bpActive = false\n}\n\nfunc (r *standardRenderer) bracketedPasteActive() bool {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\treturn r.bpActive\n}\n\nfunc (r *standardRenderer) enableReportFocus() {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\tr.execute(ansi.SetFocusEventMode)\n\tr.reportingFocus = true\n}\n\nfunc (r *standardRenderer) disableReportFocus() {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\tr.execute(ansi.ResetFocusEventMode)\n\tr.reportingFocus = false\n}\n\nfunc (r *standardRenderer) reportFocus() bool {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\treturn r.reportingFocus\n}\n\n// setWindowTitle sets the terminal window title.\nfunc (r *standardRenderer) setWindowTitle(title string) {\n\tr.execute(ansi.SetWindowTitle(title))\n}\n\n// setIgnoredLines specifies lines not to be touched by the standard Bubble Tea\n// renderer.\nfunc (r *standardRenderer) setIgnoredLines(from int, to int) {\n\t// Lock if we're going to be clearing some lines since we don't want\n\t// anything jacking our cursor.\n\tif r.lastLinesRendered() > 0 {\n\t\tr.mtx.Lock()\n\t\tdefer r.mtx.Unlock()\n\t}\n\n\tif r.ignoreLines == nil {\n\t\tr.ignoreLines = make(map[int]struct{})\n\t}\n\tfor i := from; i < to; i++ {\n\t\tr.ignoreLines[i] = struct{}{}\n\t}\n\n\t// Erase ignored lines\n\tlastLinesRendered := r.lastLinesRendered()\n\tif lastLinesRendered > 0 {\n\t\tbuf := &bytes.Buffer{}\n\n\t\tfor i := lastLinesRendered - 1; i >= 0; i-- {\n\t\t\tif _, exists := r.ignoreLines[i]; exists {\n\t\t\t\tbuf.WriteString(ansi.EraseEntireLine)\n\t\t\t}\n\t\t\tbuf.WriteString(ansi.CUU1)\n\t\t}\n\t\tbuf.WriteString(ansi.CursorPosition(0, lastLinesRendered)) // put cursor back\n\t\t_, _ = r.out.Write(buf.Bytes())\n\t}\n}\n\n// clearIgnoredLines returns control of any ignored lines to the standard\n// Bubble Tea renderer. That is, any lines previously set to be ignored can be\n// rendered to again.\nfunc (r *standardRenderer) clearIgnoredLines() {\n\tr.ignoreLines = nil\n}\n\n// insertTop effectively scrolls up. It inserts lines at the top of a given\n// area designated to be a scrollable region, pushing everything else down.\n// This is roughly how ncurses does it.\n//\n// To call this function use command ScrollUp().\n//\n// For this to work renderer.ignoreLines must be set to ignore the scrollable\n// region since we are bypassing the normal Bubble Tea renderer here.\n//\n// Because this method relies on the terminal dimensions, it's only valid for\n// full-window applications (generally those that use the alternate screen\n// buffer).\n//\n// This method bypasses the normal rendering buffer and is philosophically\n// different than the normal way we approach rendering in Bubble Tea. It's for\n// use in high-performance rendering, such as a pager that could potentially\n// be rendering very complicated ansi. In cases where the content is simpler\n// standard Bubble Tea rendering should suffice.\n//\n// Deprecated: This option is deprecated and will be removed in a future\n// version of this package.\nfunc (r *standardRenderer) insertTop(lines []string, topBoundary, bottomBoundary int) {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\tbuf := &bytes.Buffer{}\n\n\tbuf.WriteString(ansi.SetTopBottomMargins(topBoundary, bottomBoundary))\n\tbuf.WriteString(ansi.CursorPosition(0, topBoundary))\n\tbuf.WriteString(ansi.InsertLine(len(lines)))\n\t_, _ = buf.WriteString(strings.Join(lines, \"\\r\\n\"))\n\tbuf.WriteString(ansi.SetTopBottomMargins(0, r.height))\n\n\t// Move cursor back to where the main rendering routine expects it to be\n\tbuf.WriteString(ansi.CursorPosition(0, r.lastLinesRendered()))\n\n\t_, _ = r.out.Write(buf.Bytes())\n}\n\n// insertBottom effectively scrolls down. It inserts lines at the bottom of\n// a given area designated to be a scrollable region, pushing everything else\n// up. This is roughly how ncurses does it.\n//\n// To call this function use the command ScrollDown().\n//\n// See note in insertTop() for caveats, how this function only makes sense for\n// full-window applications, and how it differs from the normal way we do\n// rendering in Bubble Tea.\n//\n// Deprecated: This option is deprecated and will be removed in a future\n// version of this package.\nfunc (r *standardRenderer) insertBottom(lines []string, topBoundary, bottomBoundary int) {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\tbuf := &bytes.Buffer{}\n\n\tbuf.WriteString(ansi.SetTopBottomMargins(topBoundary, bottomBoundary))\n\tbuf.WriteString(ansi.CursorPosition(0, bottomBoundary))\n\t_, _ = buf.WriteString(\"\\r\\n\" + strings.Join(lines, \"\\r\\n\"))\n\tbuf.WriteString(ansi.SetTopBottomMargins(0, r.height))\n\n\t// Move cursor back to where the main rendering routine expects it to be\n\tbuf.WriteString(ansi.CursorPosition(0, r.lastLinesRendered()))\n\n\t_, _ = r.out.Write(buf.Bytes())\n}\n\n// handleMessages handles internal messages for the renderer.\nfunc (r *standardRenderer) handleMessages(msg Msg) {\n\tswitch msg := msg.(type) {\n\tcase repaintMsg:\n\t\t// Force a repaint by clearing the render cache as we slide into a\n\t\t// render.\n\t\tr.mtx.Lock()\n\t\tr.repaint()\n\t\tr.mtx.Unlock()\n\n\tcase WindowSizeMsg:\n\t\tr.mtx.Lock()\n\t\tr.width = msg.Width\n\t\tr.height = msg.Height\n\t\tr.repaint()\n\t\tr.mtx.Unlock()\n\n\tcase clearScrollAreaMsg:\n\t\tr.clearIgnoredLines()\n\n\t\t// Force a repaint on the area where the scrollable stuff was in this\n\t\t// update cycle\n\t\tr.mtx.Lock()\n\t\tr.repaint()\n\t\tr.mtx.Unlock()\n\n\tcase syncScrollAreaMsg:\n\t\t// Re-render scrolling area\n\t\tr.clearIgnoredLines()\n\t\tr.setIgnoredLines(msg.topBoundary, msg.bottomBoundary)\n\t\tr.insertTop(msg.lines, msg.topBoundary, msg.bottomBoundary)\n\n\t\t// Force non-scrolling stuff to repaint in this update cycle\n\t\tr.mtx.Lock()\n\t\tr.repaint()\n\t\tr.mtx.Unlock()\n\n\tcase scrollUpMsg:\n\t\tr.insertTop(msg.lines, msg.topBoundary, msg.bottomBoundary)\n\n\tcase scrollDownMsg:\n\t\tr.insertBottom(msg.lines, msg.topBoundary, msg.bottomBoundary)\n\n\tcase printLineMessage:\n\t\tif !r.altScreenActive {\n\t\t\tlines := strings.Split(msg.messageBody, \"\\n\")\n\t\t\tr.mtx.Lock()\n\t\t\tr.queuedMessageLines = append(r.queuedMessageLines, lines...)\n\t\t\tr.repaint()\n\t\t\tr.mtx.Unlock()\n\t\t}\n\t}\n}\n\n// HIGH-PERFORMANCE RENDERING STUFF\n\ntype syncScrollAreaMsg struct {\n\tlines          []string\n\ttopBoundary    int\n\tbottomBoundary int\n}\n\n// SyncScrollArea performs a paint of the entire region designated to be the\n// scrollable area. This is required to initialize the scrollable region and\n// should also be called on resize (WindowSizeMsg).\n//\n// For high-performance, scroll-based rendering only.\n//\n// Deprecated: This option will be removed in a future version of this package.\nfunc SyncScrollArea(lines []string, topBoundary int, bottomBoundary int) Cmd {\n\treturn func() Msg {\n\t\treturn syncScrollAreaMsg{\n\t\t\tlines:          lines,\n\t\t\ttopBoundary:    topBoundary,\n\t\t\tbottomBoundary: bottomBoundary,\n\t\t}\n\t}\n}\n\ntype clearScrollAreaMsg struct{}\n\n// ClearScrollArea deallocates the scrollable region and returns the control of\n// those lines to the main rendering routine.\n//\n// For high-performance, scroll-based rendering only.\n//\n// Deprecated: This option will be removed in a future version of this package.\nfunc ClearScrollArea() Msg {\n\treturn clearScrollAreaMsg{}\n}\n\ntype scrollUpMsg struct {\n\tlines          []string\n\ttopBoundary    int\n\tbottomBoundary int\n}\n\n// ScrollUp adds lines to the top of the scrollable region, pushing existing\n// lines below down. Lines that are pushed out the scrollable region disappear\n// from view.\n//\n// For high-performance, scroll-based rendering only.\n//\n// Deprecated: This option will be removed in a future version of this package.\nfunc ScrollUp(newLines []string, topBoundary, bottomBoundary int) Cmd {\n\treturn func() Msg {\n\t\treturn scrollUpMsg{\n\t\t\tlines:          newLines,\n\t\t\ttopBoundary:    topBoundary,\n\t\t\tbottomBoundary: bottomBoundary,\n\t\t}\n\t}\n}\n\ntype scrollDownMsg struct {\n\tlines          []string\n\ttopBoundary    int\n\tbottomBoundary int\n}\n\n// ScrollDown adds lines to the bottom of the scrollable region, pushing\n// existing lines above up. Lines that are pushed out of the scrollable region\n// disappear from view.\n//\n// For high-performance, scroll-based rendering only.\n//\n// Deprecated: This option will be removed in a future version of this package.\nfunc ScrollDown(newLines []string, topBoundary, bottomBoundary int) Cmd {\n\treturn func() Msg {\n\t\treturn scrollDownMsg{\n\t\t\tlines:          newLines,\n\t\t\ttopBoundary:    topBoundary,\n\t\t\tbottomBoundary: bottomBoundary,\n\t\t}\n\t}\n}\n\ntype printLineMessage struct {\n\tmessageBody string\n}\n\n// Println prints above the Program. This output is unmanaged by the program and\n// will persist across renders by the Program.\n//\n// Unlike fmt.Println (but similar to log.Println) the message will be print on\n// its own line.\n//\n// If the altscreen is active no output will be printed.\nfunc Println(args ...interface{}) Cmd {\n\treturn func() Msg {\n\t\treturn printLineMessage{\n\t\t\tmessageBody: fmt.Sprint(args...),\n\t\t}\n\t}\n}\n\n// Printf prints above the Program. It takes a format template followed by\n// values similar to fmt.Printf. This output is unmanaged by the program and\n// will persist across renders by the Program.\n//\n// Unlike fmt.Printf (but similar to log.Printf) the message will be print on\n// its own line.\n//\n// If the altscreen is active no output will be printed.\nfunc Printf(template string, args ...interface{}) Cmd {\n\treturn func() Msg {\n\t\treturn printLineMessage{\n\t\t\tmessageBody: fmt.Sprintf(template, args...),\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "tea.go",
          "type": "blob",
          "size": 20.46,
          "content": "// Package tea provides a framework for building rich terminal user interfaces\n// based on the paradigms of The Elm Architecture. It's well-suited for simple\n// and complex terminal applications, either inline, full-window, or a mix of\n// both. It's been battle-tested in several large projects and is\n// production-ready.\n//\n// A tutorial is available at https://github.com/charmbracelet/bubbletea/tree/master/tutorials\n//\n// Example programs can be found at https://github.com/charmbracelet/bubbletea/tree/master/examples\npackage tea\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/signal\"\n\t\"runtime/debug\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"syscall\"\n\n\t\"github.com/charmbracelet/x/term\"\n\t\"github.com/muesli/cancelreader\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\n// ErrProgramKilled is returned by [Program.Run] when the program gets killed.\nvar ErrProgramKilled = errors.New(\"program was killed\")\n\n// ErrInterrupted is returned by [Program.Run] when the program get a SIGINT\n// signal, or when it receives a [InterruptMsg].\nvar ErrInterrupted = errors.New(\"program was interrupted\")\n\n// Msg contain data from the result of a IO operation. Msgs trigger the update\n// function and, henceforth, the UI.\ntype Msg interface{}\n\n// Model contains the program's state as well as its core functions.\ntype Model interface {\n\t// Init is the first function that will be called. It returns an optional\n\t// initial command. To not perform an initial command return nil.\n\tInit() Cmd\n\n\t// Update is called when a message is received. Use it to inspect messages\n\t// and, in response, update the model and/or send a command.\n\tUpdate(Msg) (Model, Cmd)\n\n\t// View renders the program's UI, which is just a string. The view is\n\t// rendered after every Update.\n\tView() string\n}\n\n// Cmd is an IO operation that returns a message when it's complete. If it's\n// nil it's considered a no-op. Use it for things like HTTP requests, timers,\n// saving and loading from disk, and so on.\n//\n// Note that there's almost never a reason to use a command to send a message\n// to another part of your program. That can almost always be done in the\n// update function.\ntype Cmd func() Msg\n\ntype inputType int\n\nconst (\n\tdefaultInput inputType = iota\n\tttyInput\n\tcustomInput\n)\n\n// String implements the stringer interface for [inputType]. It is inteded to\n// be used in testing.\nfunc (i inputType) String() string {\n\treturn [...]string{\n\t\t\"default input\",\n\t\t\"tty input\",\n\t\t\"custom input\",\n\t}[i]\n}\n\n// Options to customize the program during its initialization. These are\n// generally set with ProgramOptions.\n//\n// The options here are treated as bits.\ntype startupOptions int16\n\nfunc (s startupOptions) has(option startupOptions) bool {\n\treturn s&option != 0\n}\n\nconst (\n\twithAltScreen startupOptions = 1 << iota\n\twithMouseCellMotion\n\twithMouseAllMotion\n\twithANSICompressor\n\twithoutSignalHandler\n\t// Catching panics is incredibly useful for restoring the terminal to a\n\t// usable state after a panic occurs. When this is set, Bubble Tea will\n\t// recover from panics, print the stack trace, and disable raw mode. This\n\t// feature is on by default.\n\twithoutCatchPanics\n\twithoutBracketedPaste\n\twithReportFocus\n)\n\n// channelHandlers manages the series of channels returned by various processes.\n// It allows us to wait for those processes to terminate before exiting the\n// program.\ntype channelHandlers []chan struct{}\n\n// Adds a channel to the list of handlers. We wait for all handlers to terminate\n// gracefully on shutdown.\nfunc (h *channelHandlers) add(ch chan struct{}) {\n\t*h = append(*h, ch)\n}\n\n// shutdown waits for all handlers to terminate.\nfunc (h channelHandlers) shutdown() {\n\tvar wg sync.WaitGroup\n\tfor _, ch := range h {\n\t\twg.Add(1)\n\t\tgo func(ch chan struct{}) {\n\t\t\t<-ch\n\t\t\twg.Done()\n\t\t}(ch)\n\t}\n\twg.Wait()\n}\n\n// Program is a terminal user interface.\ntype Program struct {\n\tinitialModel Model\n\n\t// handlers is a list of channels that need to be waited on before the\n\t// program can exit.\n\thandlers channelHandlers\n\n\t// Configuration options that will set as the program is initializing,\n\t// treated as bits. These options can be set via various ProgramOptions.\n\tstartupOptions startupOptions\n\n\t// startupTitle is the title that will be set on the terminal when the\n\t// program starts.\n\tstartupTitle string\n\n\tinputType inputType\n\n\tctx    context.Context\n\tcancel context.CancelFunc\n\n\tmsgs     chan Msg\n\terrs     chan error\n\tfinished chan struct{}\n\n\t// where to send output, this will usually be os.Stdout.\n\toutput io.Writer\n\t// ttyOutput is null if output is not a TTY.\n\tttyOutput           term.File\n\tpreviousOutputState *term.State\n\trenderer            renderer\n\n\t// the environment variables for the program, defaults to os.Environ().\n\tenviron []string\n\n\t// where to read inputs from, this will usually be os.Stdin.\n\tinput io.Reader\n\t// ttyInput is null if input is not a TTY.\n\tttyInput              term.File\n\tpreviousTtyInputState *term.State\n\tcancelReader          cancelreader.CancelReader\n\treadLoopDone          chan struct{}\n\n\t// was the altscreen active before releasing the terminal?\n\taltScreenWasActive bool\n\tignoreSignals      uint32\n\n\tbpWasActive bool // was the bracketed paste mode active before releasing the terminal?\n\treportFocus bool // was focus reporting active before releasing the terminal?\n\n\tfilter func(Model, Msg) Msg\n\n\t// fps is the frames per second we should set on the renderer, if\n\t// applicable,\n\tfps int\n}\n\n// Quit is a special command that tells the Bubble Tea program to exit.\nfunc Quit() Msg {\n\treturn QuitMsg{}\n}\n\n// QuitMsg signals that the program should quit. You can send a [QuitMsg] with\n// [Quit].\ntype QuitMsg struct{}\n\n// Suspend is a special command that tells the Bubble Tea program to suspend.\nfunc Suspend() Msg {\n\treturn SuspendMsg{}\n}\n\n// SuspendMsg signals the program should suspend.\n// This usually happens when ctrl+z is pressed on common programs, but since\n// bubbletea puts the terminal in raw mode, we need to handle it in a\n// per-program basis.\n//\n// You can send this message with [Suspend()].\ntype SuspendMsg struct{}\n\n// ResumeMsg can be listen to to do something once a program is resumed back\n// from a suspend state.\ntype ResumeMsg struct{}\n\n// InterruptMsg signals the program should suspend.\n// This usually happens when ctrl+c is pressed on common programs, but since\n// bubbletea puts the terminal in raw mode, we need to handle it in a\n// per-program basis.\n//\n// You can send this message with [Interrupt()].\ntype InterruptMsg struct{}\n\n// Interrupt is a special command that tells the Bubble Tea program to\n// interrupt.\nfunc Interrupt() Msg {\n\treturn InterruptMsg{}\n}\n\n// NewProgram creates a new Program.\nfunc NewProgram(model Model, opts ...ProgramOption) *Program {\n\tp := &Program{\n\t\tinitialModel: model,\n\t\tmsgs:         make(chan Msg),\n\t}\n\n\t// Apply all options to the program.\n\tfor _, opt := range opts {\n\t\topt(p)\n\t}\n\n\t// A context can be provided with a ProgramOption, but if none was provided\n\t// we'll use the default background context.\n\tif p.ctx == nil {\n\t\tp.ctx = context.Background()\n\t}\n\t// Initialize context and teardown channel.\n\tp.ctx, p.cancel = context.WithCancel(p.ctx)\n\n\t// if no output was set, set it to stdout\n\tif p.output == nil {\n\t\tp.output = os.Stdout\n\t}\n\n\t// if no environment was set, set it to os.Environ()\n\tif p.environ == nil {\n\t\tp.environ = os.Environ()\n\t}\n\n\treturn p\n}\n\nfunc (p *Program) handleSignals() chan struct{} {\n\tch := make(chan struct{})\n\n\t// Listen for SIGINT and SIGTERM.\n\t//\n\t// In most cases ^C will not send an interrupt because the terminal will be\n\t// in raw mode and ^C will be captured as a keystroke and sent along to\n\t// Program.Update as a KeyMsg. When input is not a TTY, however, ^C will be\n\t// caught here.\n\t//\n\t// SIGTERM is sent by unix utilities (like kill) to terminate a process.\n\tgo func() {\n\t\tsig := make(chan os.Signal, 1)\n\t\tsignal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)\n\t\tdefer func() {\n\t\t\tsignal.Stop(sig)\n\t\t\tclose(ch)\n\t\t}()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-p.ctx.Done():\n\t\t\t\treturn\n\n\t\t\tcase s := <-sig:\n\t\t\t\tif atomic.LoadUint32(&p.ignoreSignals) == 0 {\n\t\t\t\t\tswitch s {\n\t\t\t\t\tcase syscall.SIGINT:\n\t\t\t\t\t\tp.msgs <- InterruptMsg{}\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tp.msgs <- QuitMsg{}\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn ch\n}\n\n// handleResize handles terminal resize events.\nfunc (p *Program) handleResize() chan struct{} {\n\tch := make(chan struct{})\n\n\tif p.ttyOutput != nil {\n\t\t// Get the initial terminal size and send it to the program.\n\t\tgo p.checkResize()\n\n\t\t// Listen for window resizes.\n\t\tgo p.listenForResize(ch)\n\t} else {\n\t\tclose(ch)\n\t}\n\n\treturn ch\n}\n\n// handleCommands runs commands in a goroutine and sends the result to the\n// program's message channel.\nfunc (p *Program) handleCommands(cmds chan Cmd) chan struct{} {\n\tch := make(chan struct{})\n\n\tgo func() {\n\t\tdefer close(ch)\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-p.ctx.Done():\n\t\t\t\treturn\n\n\t\t\tcase cmd := <-cmds:\n\t\t\t\tif cmd == nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// Don't wait on these goroutines, otherwise the shutdown\n\t\t\t\t// latency would get too large as a Cmd can run for some time\n\t\t\t\t// (e.g. tick commands that sleep for half a second). It's not\n\t\t\t\t// possible to cancel them so we'll have to leak the goroutine\n\t\t\t\t// until Cmd returns.\n\t\t\t\tgo func() {\n\t\t\t\t\t// Recover from panics.\n\t\t\t\t\tif !p.startupOptions.has(withoutCatchPanics) {\n\t\t\t\t\t\tdefer p.recoverFromPanic()\n\t\t\t\t\t}\n\n\t\t\t\t\tmsg := cmd() // this can be long.\n\t\t\t\t\tp.Send(msg)\n\t\t\t\t}()\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn ch\n}\n\nfunc (p *Program) disableMouse() {\n\tp.renderer.disableMouseCellMotion()\n\tp.renderer.disableMouseAllMotion()\n\tp.renderer.disableMouseSGRMode()\n}\n\n// eventLoop is the central message loop. It receives and handles the default\n// Bubble Tea messages, update the model and triggers redraws.\nfunc (p *Program) eventLoop(model Model, cmds chan Cmd) (Model, error) {\n\tfor {\n\t\tselect {\n\t\tcase <-p.ctx.Done():\n\t\t\treturn model, nil\n\n\t\tcase err := <-p.errs:\n\t\t\treturn model, err\n\n\t\tcase msg := <-p.msgs:\n\t\t\t// Filter messages.\n\t\t\tif p.filter != nil {\n\t\t\t\tmsg = p.filter(model, msg)\n\t\t\t}\n\t\t\tif msg == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Handle special internal messages.\n\t\t\tswitch msg := msg.(type) {\n\t\t\tcase QuitMsg:\n\t\t\t\treturn model, nil\n\n\t\t\tcase InterruptMsg:\n\t\t\t\treturn model, ErrInterrupted\n\n\t\t\tcase SuspendMsg:\n\t\t\t\tif suspendSupported {\n\t\t\t\t\tp.suspend()\n\t\t\t\t}\n\n\t\t\tcase clearScreenMsg:\n\t\t\t\tp.renderer.clearScreen()\n\n\t\t\tcase enterAltScreenMsg:\n\t\t\t\tp.renderer.enterAltScreen()\n\n\t\t\tcase exitAltScreenMsg:\n\t\t\t\tp.renderer.exitAltScreen()\n\n\t\t\tcase enableMouseCellMotionMsg, enableMouseAllMotionMsg:\n\t\t\t\tswitch msg.(type) {\n\t\t\t\tcase enableMouseCellMotionMsg:\n\t\t\t\t\tp.renderer.enableMouseCellMotion()\n\t\t\t\tcase enableMouseAllMotionMsg:\n\t\t\t\t\tp.renderer.enableMouseAllMotion()\n\t\t\t\t}\n\t\t\t\t// mouse mode (1006) is a no-op if the terminal doesn't support it.\n\t\t\t\tp.renderer.enableMouseSGRMode()\n\n\t\t\tcase disableMouseMsg:\n\t\t\t\tp.disableMouse()\n\n\t\t\tcase showCursorMsg:\n\t\t\t\tp.renderer.showCursor()\n\n\t\t\tcase hideCursorMsg:\n\t\t\t\tp.renderer.hideCursor()\n\n\t\t\tcase enableBracketedPasteMsg:\n\t\t\t\tp.renderer.enableBracketedPaste()\n\n\t\t\tcase disableBracketedPasteMsg:\n\t\t\t\tp.renderer.disableBracketedPaste()\n\n\t\t\tcase enableReportFocusMsg:\n\t\t\t\tp.renderer.enableReportFocus()\n\n\t\t\tcase disableReportFocusMsg:\n\t\t\t\tp.renderer.disableReportFocus()\n\n\t\t\tcase execMsg:\n\t\t\t\t// NB: this blocks.\n\t\t\t\tp.exec(msg.cmd, msg.fn)\n\n\t\t\tcase BatchMsg:\n\t\t\t\tfor _, cmd := range msg {\n\t\t\t\t\tcmds <- cmd\n\t\t\t\t}\n\t\t\t\tcontinue\n\n\t\t\tcase sequenceMsg:\n\t\t\t\tgo func() {\n\t\t\t\t\t// Execute commands one at a time, in order.\n\t\t\t\t\tfor _, cmd := range msg {\n\t\t\t\t\t\tif cmd == nil {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmsg := cmd()\n\t\t\t\t\t\tif batchMsg, ok := msg.(BatchMsg); ok {\n\t\t\t\t\t\t\tg, _ := errgroup.WithContext(p.ctx)\n\t\t\t\t\t\t\tfor _, cmd := range batchMsg {\n\t\t\t\t\t\t\t\tcmd := cmd\n\t\t\t\t\t\t\t\tg.Go(func() error {\n\t\t\t\t\t\t\t\t\tp.Send(cmd())\n\t\t\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//nolint:errcheck\n\t\t\t\t\t\t\tg.Wait() // wait for all commands from batch msg to finish\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tp.Send(msg)\n\t\t\t\t\t}\n\t\t\t\t}()\n\n\t\t\tcase setWindowTitleMsg:\n\t\t\t\tp.SetWindowTitle(string(msg))\n\n\t\t\tcase windowSizeMsg:\n\t\t\t\tgo p.checkResize()\n\t\t\t}\n\n\t\t\t// Process internal messages for the renderer.\n\t\t\tif r, ok := p.renderer.(*standardRenderer); ok {\n\t\t\t\tr.handleMessages(msg)\n\t\t\t}\n\n\t\t\tvar cmd Cmd\n\t\t\tmodel, cmd = model.Update(msg) // run update\n\t\t\tcmds <- cmd                    // process command (if any)\n\t\t\tp.renderer.write(model.View()) // send view to renderer\n\t\t}\n\t}\n}\n\n// Run initializes the program and runs its event loops, blocking until it gets\n// terminated by either [Program.Quit], [Program.Kill], or its signal handler.\n// Returns the final model.\nfunc (p *Program) Run() (Model, error) {\n\tp.handlers = channelHandlers{}\n\tcmds := make(chan Cmd)\n\tp.errs = make(chan error)\n\tp.finished = make(chan struct{}, 1)\n\n\tdefer p.cancel()\n\n\tswitch p.inputType {\n\tcase defaultInput:\n\t\tp.input = os.Stdin\n\n\t\t// The user has not set a custom input, so we need to check whether or\n\t\t// not standard input is a terminal. If it's not, we open a new TTY for\n\t\t// input. This will allow things to \"just work\" in cases where data was\n\t\t// piped in or redirected to the application.\n\t\t//\n\t\t// To disable input entirely pass nil to the [WithInput] program option.\n\t\tf, isFile := p.input.(term.File)\n\t\tif !isFile {\n\t\t\tbreak\n\t\t}\n\t\tif term.IsTerminal(f.Fd()) {\n\t\t\tbreak\n\t\t}\n\n\t\tf, err := openInputTTY()\n\t\tif err != nil {\n\t\t\treturn p.initialModel, err\n\t\t}\n\t\tdefer f.Close() //nolint:errcheck\n\t\tp.input = f\n\n\tcase ttyInput:\n\t\t// Open a new TTY, by request\n\t\tf, err := openInputTTY()\n\t\tif err != nil {\n\t\t\treturn p.initialModel, err\n\t\t}\n\t\tdefer f.Close() //nolint:errcheck\n\t\tp.input = f\n\n\tcase customInput:\n\t\t// (There is nothing extra to do.)\n\t}\n\n\t// Handle signals.\n\tif !p.startupOptions.has(withoutSignalHandler) {\n\t\tp.handlers.add(p.handleSignals())\n\t}\n\n\t// Recover from panics.\n\tif !p.startupOptions.has(withoutCatchPanics) {\n\t\tdefer p.recoverFromPanic()\n\t}\n\n\t// If no renderer is set use the standard one.\n\tif p.renderer == nil {\n\t\tp.renderer = newRenderer(p.output, p.startupOptions.has(withANSICompressor), p.fps)\n\t}\n\n\t// Check if output is a TTY before entering raw mode, hiding the cursor and\n\t// so on.\n\tif err := p.initTerminal(); err != nil {\n\t\treturn p.initialModel, err\n\t}\n\n\t// Honor program startup options.\n\tif p.startupTitle != \"\" {\n\t\tp.renderer.setWindowTitle(p.startupTitle)\n\t}\n\tif p.startupOptions&withAltScreen != 0 {\n\t\tp.renderer.enterAltScreen()\n\t}\n\tif p.startupOptions&withoutBracketedPaste == 0 {\n\t\tp.renderer.enableBracketedPaste()\n\t}\n\tif p.startupOptions&withMouseCellMotion != 0 {\n\t\tp.renderer.enableMouseCellMotion()\n\t\tp.renderer.enableMouseSGRMode()\n\t} else if p.startupOptions&withMouseAllMotion != 0 {\n\t\tp.renderer.enableMouseAllMotion()\n\t\tp.renderer.enableMouseSGRMode()\n\t}\n\tif p.startupOptions&withReportFocus != 0 {\n\t\tp.renderer.enableReportFocus()\n\t}\n\n\t// Start the renderer.\n\tp.renderer.start()\n\n\t// Initialize the program.\n\tmodel := p.initialModel\n\tif initCmd := model.Init(); initCmd != nil {\n\t\tch := make(chan struct{})\n\t\tp.handlers.add(ch)\n\n\t\tgo func() {\n\t\t\tdefer close(ch)\n\n\t\t\tselect {\n\t\t\tcase cmds <- initCmd:\n\t\t\tcase <-p.ctx.Done():\n\t\t\t}\n\t\t}()\n\t}\n\n\t// Render the initial view.\n\tp.renderer.write(model.View())\n\n\t// Subscribe to user input.\n\tif p.input != nil {\n\t\tif err := p.initCancelReader(); err != nil {\n\t\t\treturn model, err\n\t\t}\n\t}\n\n\t// Handle resize events.\n\tp.handlers.add(p.handleResize())\n\n\t// Process commands.\n\tp.handlers.add(p.handleCommands(cmds))\n\n\t// Run event loop, handle updates and draw.\n\tmodel, err := p.eventLoop(model, cmds)\n\tkilled := p.ctx.Err() != nil || err != nil\n\tif killed && err == nil {\n\t\terr = fmt.Errorf(\"%w: %s\", ErrProgramKilled, p.ctx.Err())\n\t}\n\tif err == nil {\n\t\t// Ensure we rendered the final state of the model.\n\t\tp.renderer.write(model.View())\n\t}\n\n\t// Restore terminal state.\n\tp.shutdown(killed)\n\n\treturn model, err\n}\n\n// StartReturningModel initializes the program and runs its event loops,\n// blocking until it gets terminated by either [Program.Quit], [Program.Kill],\n// or its signal handler. Returns the final model.\n//\n// Deprecated: please use [Program.Run] instead.\nfunc (p *Program) StartReturningModel() (Model, error) {\n\treturn p.Run()\n}\n\n// Start initializes the program and runs its event loops, blocking until it\n// gets terminated by either [Program.Quit], [Program.Kill], or its signal\n// handler.\n//\n// Deprecated: please use [Program.Run] instead.\nfunc (p *Program) Start() error {\n\t_, err := p.Run()\n\treturn err\n}\n\n// Send sends a message to the main update function, effectively allowing\n// messages to be injected from outside the program for interoperability\n// purposes.\n//\n// If the program hasn't started yet this will be a blocking operation.\n// If the program has already been terminated this will be a no-op, so it's safe\n// to send messages after the program has exited.\nfunc (p *Program) Send(msg Msg) {\n\tselect {\n\tcase <-p.ctx.Done():\n\tcase p.msgs <- msg:\n\t}\n}\n\n// Quit is a convenience function for quitting Bubble Tea programs. Use it\n// when you need to shut down a Bubble Tea program from the outside.\n//\n// If you wish to quit from within a Bubble Tea program use the Quit command.\n//\n// If the program is not running this will be a no-op, so it's safe to call\n// if the program is unstarted or has already exited.\nfunc (p *Program) Quit() {\n\tp.Send(Quit())\n}\n\n// Kill stops the program immediately and restores the former terminal state.\n// The final render that you would normally see when quitting will be skipped.\n// [program.Run] returns a [ErrProgramKilled] error.\nfunc (p *Program) Kill() {\n\tp.shutdown(true)\n}\n\n// Wait waits/blocks until the underlying Program finished shutting down.\nfunc (p *Program) Wait() {\n\t<-p.finished\n}\n\n// shutdown performs operations to free up resources and restore the terminal\n// to its original state.\nfunc (p *Program) shutdown(kill bool) {\n\tp.cancel()\n\n\t// Wait for all handlers to finish.\n\tp.handlers.shutdown()\n\n\t// Check if the cancel reader has been setup before waiting and closing.\n\tif p.cancelReader != nil {\n\t\t// Wait for input loop to finish.\n\t\tif p.cancelReader.Cancel() {\n\t\t\tif !kill {\n\t\t\t\tp.waitForReadLoop()\n\t\t\t}\n\t\t}\n\t\t_ = p.cancelReader.Close()\n\t}\n\n\tif p.renderer != nil {\n\t\tif kill {\n\t\t\tp.renderer.kill()\n\t\t} else {\n\t\t\tp.renderer.stop()\n\t\t}\n\t}\n\n\t_ = p.restoreTerminalState()\n\tif !kill {\n\t\tp.finished <- struct{}{}\n\t}\n}\n\n// recoverFromPanic recovers from a panic, prints the stack trace, and restores\n// the terminal to a usable state.\nfunc (p *Program) recoverFromPanic() {\n\tif r := recover(); r != nil {\n\t\tp.shutdown(true)\n\t\tfmt.Printf(\"Caught panic:\\n\\n%s\\n\\nRestoring terminal...\\n\\n\", r)\n\t\tdebug.PrintStack()\n\t}\n}\n\n// ReleaseTerminal restores the original terminal state and cancels the input\n// reader. You can return control to the Program with RestoreTerminal.\nfunc (p *Program) ReleaseTerminal() error {\n\tatomic.StoreUint32(&p.ignoreSignals, 1)\n\tif p.cancelReader != nil {\n\t\tp.cancelReader.Cancel()\n\t}\n\n\tp.waitForReadLoop()\n\n\tif p.renderer != nil {\n\t\tp.renderer.stop()\n\t\tp.altScreenWasActive = p.renderer.altScreen()\n\t\tp.bpWasActive = p.renderer.bracketedPasteActive()\n\t\tp.reportFocus = p.renderer.reportFocus()\n\t}\n\n\treturn p.restoreTerminalState()\n}\n\n// RestoreTerminal reinitializes the Program's input reader, restores the\n// terminal to the former state when the program was running, and repaints.\n// Use it to reinitialize a Program after running ReleaseTerminal.\nfunc (p *Program) RestoreTerminal() error {\n\tatomic.StoreUint32(&p.ignoreSignals, 0)\n\n\tif err := p.initTerminal(); err != nil {\n\t\treturn err\n\t}\n\tif err := p.initCancelReader(); err != nil {\n\t\treturn err\n\t}\n\tif p.altScreenWasActive {\n\t\tp.renderer.enterAltScreen()\n\t} else {\n\t\t// entering alt screen already causes a repaint.\n\t\tgo p.Send(repaintMsg{})\n\t}\n\tif p.renderer != nil {\n\t\tp.renderer.start()\n\t}\n\tif p.bpWasActive {\n\t\tp.renderer.enableBracketedPaste()\n\t}\n\tif p.reportFocus {\n\t\tp.renderer.enableReportFocus()\n\t}\n\n\t// If the output is a terminal, it may have been resized while another\n\t// process was at the foreground, in which case we may not have received\n\t// SIGWINCH. Detect any size change now and propagate the new size as\n\t// needed.\n\tgo p.checkResize()\n\n\treturn nil\n}\n\n// Println prints above the Program. This output is unmanaged by the program\n// and will persist across renders by the Program.\n//\n// If the altscreen is active no output will be printed.\nfunc (p *Program) Println(args ...interface{}) {\n\tp.msgs <- printLineMessage{\n\t\tmessageBody: fmt.Sprint(args...),\n\t}\n}\n\n// Printf prints above the Program. It takes a format template followed by\n// values similar to fmt.Printf. This output is unmanaged by the program and\n// will persist across renders by the Program.\n//\n// Unlike fmt.Printf (but similar to log.Printf) the message will be print on\n// its own line.\n//\n// If the altscreen is active no output will be printed.\nfunc (p *Program) Printf(template string, args ...interface{}) {\n\tp.msgs <- printLineMessage{\n\t\tmessageBody: fmt.Sprintf(template, args...),\n\t}\n}\n"
        },
        {
          "name": "tea_init.go",
          "type": "blob",
          "size": 0.7,
          "content": "package tea\n\nimport (\n\t\"github.com/charmbracelet/lipgloss\"\n)\n\nfunc init() {\n\t// XXX: This is a workaround to make assure that Lip Gloss and Termenv\n\t// query the terminal before any Bubble Tea Program runs and acquires the\n\t// terminal. Without this, Programs that use Lip Gloss/Termenv might hang\n\t// while waiting for a a [termenv.OSCTimeout] while querying the terminal\n\t// for its background/foreground colors.\n\t//\n\t// This happens because Bubble Tea acquires the terminal before termenv\n\t// reads any responses.\n\t//\n\t// Note that this will only affect programs running on the default IO i.e.\n\t// [os.Stdout] and [os.Stdin].\n\t//\n\t// This workaround will be removed in v2.\n\t_ = lipgloss.HasDarkBackground()\n}\n"
        },
        {
          "name": "tea_test.go",
          "type": "blob",
          "size": 4.77,
          "content": "package tea\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype incrementMsg struct{}\n\ntype testModel struct {\n\texecuted atomic.Value\n\tcounter  atomic.Value\n}\n\nfunc (m testModel) Init() Cmd {\n\treturn nil\n}\n\nfunc (m *testModel) Update(msg Msg) (Model, Cmd) {\n\tswitch msg.(type) {\n\tcase incrementMsg:\n\t\ti := m.counter.Load()\n\t\tif i == nil {\n\t\t\tm.counter.Store(1)\n\t\t} else {\n\t\t\tm.counter.Store(i.(int) + 1)\n\t\t}\n\n\tcase KeyMsg:\n\t\treturn m, Quit\n\t}\n\n\treturn m, nil\n}\n\nfunc (m *testModel) View() string {\n\tm.executed.Store(true)\n\treturn \"success\\n\"\n}\n\nfunc TestTeaModel(t *testing.T) {\n\tvar buf bytes.Buffer\n\tvar in bytes.Buffer\n\tin.Write([]byte(\"q\"))\n\n\tctx, cancel := context.WithTimeout(context.TODO(), 3*time.Second)\n\tdefer cancel()\n\n\tp := NewProgram(&testModel{}, WithInput(&in), WithOutput(&buf), WithContext(ctx))\n\tif _, err := p.Run(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif buf.Len() == 0 {\n\t\tt.Fatal(\"no output\")\n\t}\n}\n\nfunc TestTeaQuit(t *testing.T) {\n\tvar buf bytes.Buffer\n\tvar in bytes.Buffer\n\n\tm := &testModel{}\n\tp := NewProgram(m, WithInput(&in), WithOutput(&buf))\n\tgo func() {\n\t\tfor {\n\t\t\ttime.Sleep(time.Millisecond)\n\t\t\tif m.executed.Load() != nil {\n\t\t\t\tp.Quit()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tif _, err := p.Run(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestTeaWithFilter(t *testing.T) {\n\ttestTeaWithFilter(t, 0)\n\ttestTeaWithFilter(t, 1)\n\ttestTeaWithFilter(t, 2)\n}\n\nfunc testTeaWithFilter(t *testing.T, preventCount uint32) {\n\tvar buf bytes.Buffer\n\tvar in bytes.Buffer\n\n\tm := &testModel{}\n\tshutdowns := uint32(0)\n\tp := NewProgram(m,\n\t\tWithInput(&in),\n\t\tWithOutput(&buf),\n\t\tWithFilter(func(_ Model, msg Msg) Msg {\n\t\t\tif _, ok := msg.(QuitMsg); !ok {\n\t\t\t\treturn msg\n\t\t\t}\n\t\t\tif shutdowns < preventCount {\n\t\t\t\tatomic.AddUint32(&shutdowns, 1)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn msg\n\t\t}))\n\n\tgo func() {\n\t\tfor atomic.LoadUint32(&shutdowns) <= preventCount {\n\t\t\ttime.Sleep(time.Millisecond)\n\t\t\tp.Quit()\n\t\t}\n\t}()\n\n\tif err := p.Start(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif shutdowns != preventCount {\n\t\tt.Errorf(\"Expected %d prevented shutdowns, got %d\", preventCount, shutdowns)\n\t}\n}\n\nfunc TestTeaKill(t *testing.T) {\n\tvar buf bytes.Buffer\n\tvar in bytes.Buffer\n\n\tm := &testModel{}\n\tp := NewProgram(m, WithInput(&in), WithOutput(&buf))\n\tgo func() {\n\t\tfor {\n\t\t\ttime.Sleep(time.Millisecond)\n\t\t\tif m.executed.Load() != nil {\n\t\t\t\tp.Kill()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tif _, err := p.Run(); !errors.Is(err, ErrProgramKilled) {\n\t\tt.Fatalf(\"Expected %v, got %v\", ErrProgramKilled, err)\n\t}\n}\n\nfunc TestTeaContext(t *testing.T) {\n\tctx, cancel := context.WithCancel(context.Background())\n\tvar buf bytes.Buffer\n\tvar in bytes.Buffer\n\n\tm := &testModel{}\n\tp := NewProgram(m, WithContext(ctx), WithInput(&in), WithOutput(&buf))\n\tgo func() {\n\t\tfor {\n\t\t\ttime.Sleep(time.Millisecond)\n\t\t\tif m.executed.Load() != nil {\n\t\t\t\tcancel()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tif _, err := p.Run(); !errors.Is(err, ErrProgramKilled) {\n\t\tt.Fatalf(\"Expected %v, got %v\", ErrProgramKilled, err)\n\t}\n}\n\nfunc TestTeaBatchMsg(t *testing.T) {\n\tvar buf bytes.Buffer\n\tvar in bytes.Buffer\n\n\tinc := func() Msg {\n\t\treturn incrementMsg{}\n\t}\n\n\tm := &testModel{}\n\tp := NewProgram(m, WithInput(&in), WithOutput(&buf))\n\tgo func() {\n\t\tp.Send(BatchMsg{inc, inc})\n\n\t\tfor {\n\t\t\ttime.Sleep(time.Millisecond)\n\t\t\ti := m.counter.Load()\n\t\t\tif i != nil && i.(int) >= 2 {\n\t\t\t\tp.Quit()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tif _, err := p.Run(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif m.counter.Load() != 2 {\n\t\tt.Fatalf(\"counter should be 2, got %d\", m.counter.Load())\n\t}\n}\n\nfunc TestTeaSequenceMsg(t *testing.T) {\n\tvar buf bytes.Buffer\n\tvar in bytes.Buffer\n\n\tinc := func() Msg {\n\t\treturn incrementMsg{}\n\t}\n\n\tm := &testModel{}\n\tp := NewProgram(m, WithInput(&in), WithOutput(&buf))\n\tgo p.Send(sequenceMsg{inc, inc, Quit})\n\n\tif _, err := p.Run(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif m.counter.Load() != 2 {\n\t\tt.Fatalf(\"counter should be 2, got %d\", m.counter.Load())\n\t}\n}\n\nfunc TestTeaSequenceMsgWithBatchMsg(t *testing.T) {\n\tvar buf bytes.Buffer\n\tvar in bytes.Buffer\n\n\tinc := func() Msg {\n\t\treturn incrementMsg{}\n\t}\n\tbatch := func() Msg {\n\t\treturn BatchMsg{inc, inc}\n\t}\n\n\tm := &testModel{}\n\tp := NewProgram(m, WithInput(&in), WithOutput(&buf))\n\tgo p.Send(sequenceMsg{batch, inc, Quit})\n\n\tif _, err := p.Run(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif m.counter.Load() != 3 {\n\t\tt.Fatalf(\"counter should be 3, got %d\", m.counter.Load())\n\t}\n}\n\nfunc TestTeaSend(t *testing.T) {\n\tvar buf bytes.Buffer\n\tvar in bytes.Buffer\n\n\tm := &testModel{}\n\tp := NewProgram(m, WithInput(&in), WithOutput(&buf))\n\n\t// sending before the program is started is a blocking operation\n\tgo p.Send(Quit())\n\n\tif _, err := p.Run(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// sending a message after program has quit is a no-op\n\tp.Send(Quit())\n}\n\nfunc TestTeaNoRun(t *testing.T) {\n\tvar buf bytes.Buffer\n\tvar in bytes.Buffer\n\n\tm := &testModel{}\n\tNewProgram(m, WithInput(&in), WithOutput(&buf))\n}\n"
        },
        {
          "name": "tty.go",
          "type": "blob",
          "size": 2.88,
          "content": "package tea\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/x/term\"\n\t\"github.com/muesli/cancelreader\"\n)\n\nfunc (p *Program) suspend() {\n\tif err := p.ReleaseTerminal(); err != nil {\n\t\t// If we can't release input, abort.\n\t\treturn\n\t}\n\n\tsuspendProcess()\n\n\t_ = p.RestoreTerminal()\n\tgo p.Send(ResumeMsg{})\n}\n\nfunc (p *Program) initTerminal() error {\n\tif _, ok := p.renderer.(*nilRenderer); ok {\n\t\t// No need to initialize the terminal if we're not rendering\n\t\treturn nil\n\t}\n\n\tif err := p.initInput(); err != nil {\n\t\treturn err\n\t}\n\n\tp.renderer.hideCursor()\n\treturn nil\n}\n\n// restoreTerminalState restores the terminal to the state prior to running the\n// Bubble Tea program.\nfunc (p *Program) restoreTerminalState() error {\n\tif p.renderer != nil {\n\t\tp.renderer.disableBracketedPaste()\n\t\tp.renderer.showCursor()\n\t\tp.disableMouse()\n\n\t\tif p.renderer.reportFocus() {\n\t\t\tp.renderer.disableReportFocus()\n\t\t}\n\n\t\tif p.renderer.altScreen() {\n\t\t\tp.renderer.exitAltScreen()\n\n\t\t\t// give the terminal a moment to catch up\n\t\t\ttime.Sleep(time.Millisecond * 10) //nolint:gomnd\n\t\t}\n\t}\n\n\treturn p.restoreInput()\n}\n\n// restoreInput restores the tty input to its original state.\nfunc (p *Program) restoreInput() error {\n\tif p.ttyInput != nil && p.previousTtyInputState != nil {\n\t\tif err := term.Restore(p.ttyInput.Fd(), p.previousTtyInputState); err != nil {\n\t\t\treturn fmt.Errorf(\"error restoring console: %w\", err)\n\t\t}\n\t}\n\tif p.ttyOutput != nil && p.previousOutputState != nil {\n\t\tif err := term.Restore(p.ttyOutput.Fd(), p.previousOutputState); err != nil {\n\t\t\treturn fmt.Errorf(\"error restoring console: %w\", err)\n\t\t}\n\t}\n\treturn nil\n}\n\n// initCancelReader (re)commences reading inputs.\nfunc (p *Program) initCancelReader() error {\n\tvar err error\n\tp.cancelReader, err = newInputReader(p.input)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating cancelreader: %w\", err)\n\t}\n\n\tp.readLoopDone = make(chan struct{})\n\tgo p.readLoop()\n\n\treturn nil\n}\n\nfunc (p *Program) readLoop() {\n\tdefer close(p.readLoopDone)\n\n\terr := readInputs(p.ctx, p.msgs, p.cancelReader)\n\tif !errors.Is(err, io.EOF) && !errors.Is(err, cancelreader.ErrCanceled) {\n\t\tselect {\n\t\tcase <-p.ctx.Done():\n\t\tcase p.errs <- err:\n\t\t}\n\t}\n}\n\n// waitForReadLoop waits for the cancelReader to finish its read loop.\nfunc (p *Program) waitForReadLoop() {\n\tselect {\n\tcase <-p.readLoopDone:\n\tcase <-time.After(500 * time.Millisecond): //nolint:gomnd\n\t\t// The read loop hangs, which means the input\n\t\t// cancelReader's cancel function has returned true even\n\t\t// though it was not able to cancel the read.\n\t}\n}\n\n// checkResize detects the current size of the output and informs the program\n// via a WindowSizeMsg.\nfunc (p *Program) checkResize() {\n\tif p.ttyOutput == nil {\n\t\t// can't query window size\n\t\treturn\n\t}\n\n\tw, h, err := term.GetSize(p.ttyOutput.Fd())\n\tif err != nil {\n\t\tselect {\n\t\tcase <-p.ctx.Done():\n\t\tcase p.errs <- err:\n\t\t}\n\n\t\treturn\n\t}\n\n\tp.Send(WindowSizeMsg{\n\t\tWidth:  w,\n\t\tHeight: h,\n\t})\n}\n"
        },
        {
          "name": "tty_unix.go",
          "type": "blob",
          "size": 1.07,
          "content": "//go:build darwin || dragonfly || freebsd || linux || netbsd || openbsd || solaris || aix || zos\n// +build darwin dragonfly freebsd linux netbsd openbsd solaris aix zos\n\npackage tea\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"github.com/charmbracelet/x/term\"\n)\n\nfunc (p *Program) initInput() (err error) {\n\t// Check if input is a terminal\n\tif f, ok := p.input.(term.File); ok && term.IsTerminal(f.Fd()) {\n\t\tp.ttyInput = f\n\t\tp.previousTtyInputState, err = term.MakeRaw(p.ttyInput.Fd())\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error entering raw mode: %w\", err)\n\t\t}\n\t}\n\n\tif f, ok := p.output.(term.File); ok && term.IsTerminal(f.Fd()) {\n\t\tp.ttyOutput = f\n\t}\n\n\treturn nil\n}\n\nfunc openInputTTY() (*os.File, error) {\n\tf, err := os.Open(\"/dev/tty\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not open a new TTY: %w\", err)\n\t}\n\treturn f, nil\n}\n\nconst suspendSupported = true\n\n// Send SIGTSTP to the entire process group.\nfunc suspendProcess() {\n\tc := make(chan os.Signal, 1)\n\tsignal.Notify(c, syscall.SIGCONT)\n\t_ = syscall.Kill(0, syscall.SIGTSTP)\n\t// blocks until a CONT happens...\n\t<-c\n}\n"
        },
        {
          "name": "tty_windows.go",
          "type": "blob",
          "size": 1.67,
          "content": "//go:build windows\n// +build windows\n\npackage tea\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/charmbracelet/x/term\"\n\t\"golang.org/x/sys/windows\"\n)\n\nfunc (p *Program) initInput() (err error) {\n\t// Save stdin state and enable VT input\n\t// We also need to enable VT\n\t// input here.\n\tif f, ok := p.input.(term.File); ok && term.IsTerminal(f.Fd()) {\n\t\tp.ttyInput = f\n\t\tp.previousTtyInputState, err = term.MakeRaw(p.ttyInput.Fd())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Enable VT input\n\t\tvar mode uint32\n\t\tif err := windows.GetConsoleMode(windows.Handle(p.ttyInput.Fd()), &mode); err != nil {\n\t\t\treturn fmt.Errorf(\"error getting console mode: %w\", err)\n\t\t}\n\n\t\tif err := windows.SetConsoleMode(windows.Handle(p.ttyInput.Fd()), mode|windows.ENABLE_VIRTUAL_TERMINAL_INPUT); err != nil {\n\t\t\treturn fmt.Errorf(\"error setting console mode: %w\", err)\n\t\t}\n\t}\n\n\t// Save output screen buffer state and enable VT processing.\n\tif f, ok := p.output.(term.File); ok && term.IsTerminal(f.Fd()) {\n\t\tp.ttyOutput = f\n\t\tp.previousOutputState, err = term.GetState(f.Fd())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar mode uint32\n\t\tif err := windows.GetConsoleMode(windows.Handle(p.ttyOutput.Fd()), &mode); err != nil {\n\t\t\treturn fmt.Errorf(\"error getting console mode: %w\", err)\n\t\t}\n\n\t\tif err := windows.SetConsoleMode(windows.Handle(p.ttyOutput.Fd()), mode|windows.ENABLE_VIRTUAL_TERMINAL_PROCESSING); err != nil {\n\t\t\treturn fmt.Errorf(\"error setting console mode: %w\", err)\n\t\t}\n\t}\n\n\treturn\n}\n\n// Open the Windows equivalent of a TTY.\nfunc openInputTTY() (*os.File, error) {\n\tf, err := os.OpenFile(\"CONIN$\", os.O_RDWR, 0o644)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn f, nil\n}\n\nconst suspendSupported = false\n\nfunc suspendProcess() {}\n"
        },
        {
          "name": "tutorials",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}